00:00:08 <ddarius> SSA doesn't have mutable state, SSA is equivalent to pure FP.
00:00:46 <ddarius> scodil: For relatively simple things, it should be pretty easy.  For things like migrating processes, you'd be more or less screwed.
00:01:11 <MyCatVerbs> ddarius: mmmhmmm. But you can derive SSA from mutable state programs and you can derive mutable state programs from SSA.
00:01:44 <ddarius> I can provide a denotational semantics for imperative programs and implement them with imperative languages.
00:02:15 <pjd> non-mutating descriptions of mutation
00:02:51 <emu> scodil: parMap =)
00:02:57 <emu> @hoogle parMap
00:02:58 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
00:03:22 <emu> there's a tutorial on the gph site
00:03:24 <scodil> emu: right i'm thinking of using a handful of different computers, though
00:03:27 <emu> @where gph
00:03:28 <lambdabot> I know nothing about gph.
00:03:28 <emu> o
00:03:34 <emu> gdh?
00:03:44 <emu> i haven't messed with it though
00:03:47 <scodil> is that active?
00:05:59 <ddarius> http://www.macs.hw.ac.uk/~dsg/gdh/
00:06:01 <lambdabot> Title: Glasgow Distributed Haskell
00:07:25 <ddarius> scodil: Clean, I believe, does have some interesting distribution support.
00:08:26 <scodil> yeah, and i know erlang owns that area too. although i'm not really interested in picking up a new language just for this project (although having the time for that would be nice.)
00:08:40 <pierre-> hello. Has someone used HDBC?
00:09:06 <MyCatVerbs> scodil: personally, to attack mapreduce in true boring-slacker fashion, I'd just use one of the distributed make(1) implementations.
00:09:47 <ddarius> scodil: For just Map-Reduce it should be easy enough to distribute it "manually".
00:10:05 <MyCatVerbs> Probably with some gnarly shellscript generating the makefile from a list of input files to be processed. Then just write the map and the reduce functions as completely standalone Haskell programs to be invoked by make.
00:10:15 <scodil> well its not exactly map-reduce
00:10:28 <MyCatVerbs> ddarius: that wouldn't be baroque enough, though. =)
00:10:47 <scodil> and sure I can think of many ways to do it. I just wanted to see how one would do it in haskell
00:11:15 <ddarius> Well you can see how it's been done, just look at the links googling "Distrubuted Haskell" turns up.
00:11:45 <ddarius> But, if I were going to do it right this second, I'd probably do it as a kind of message passing system.
00:12:01 <ddarius> I think Ports works essentially that way.
00:12:04 <scodil> yeah thats what i'm looking for
00:12:23 <MyCatVerbs> scodil: personally, by hand, using sockets. Up to some (fairly small, maybe around fourty-ish) number of machines (coincidentally, way above my budget ^^) if the problem is coarse grained it'd still scale well enough even with a really shit implementation.
00:12:24 <scodil> you said ports is dead?
00:12:43 <ddarius> scodil: I believe it is, that doesn't mean the ideas were bad.
00:12:53 <scodil> true
00:13:25 <MyCatVerbs> If you're only using up to a hundred or so machines, I bet you don't even need half the features in the mapreduce whitepaper.
00:13:37 <scodil> ok so anybody know of simple examples of sockets programming in haskell? or anything higher-leve, like message passing
00:13:52 <scodil> sorry forget i said map-reduce. i just meant basic distributed processing
00:13:59 <scodil> no process migration or fault tolerance
00:14:17 <ddarius> Sockets work in Haskell just like they do in most languages.
00:14:30 <MyCatVerbs> scodil: the network-facing bits of lambdabot's source code, perhaps, since it parses IRC, if you *really* need example code.
00:15:00 <scodil> no i don't really need example code, just anything more verbose than the docs for the Network module.
00:15:04 <MyCatVerbs> scodil: but it really does just work in exactly the same way that Berkeley sockets work in C or whatever else, so prolly no worries anyway.
00:15:46 <MyCatVerbs> scodil: eh, okay, want a dozen or two line example?
00:15:58 <ddarius> scodil: http://www.haskell.org/hawiki/ShortExamples_2fPOPCleaner
00:15:59 <lambdabot> Title: ShortExamples/POPCleaner - The Haskell Wiki
00:16:17 <scodil> yeah something stupid like a chat server
00:16:30 <ddarius> scodil: That code is pretty old so there are some minor changes.
00:17:40 <MyCatVerbs> scodil: good idea.
00:18:12 <ddarius> Heck, the only networking specific thing there is connectTo everything else is just writing to handles.
00:18:59 <scodil> does all network IO happen via Strings?
00:19:44 <MyCatVerbs> scodil: it's exactly the same as file IO. Unix deliberately makes the two look the same.
00:20:27 <MyCatVerbs> scodil: anything you can send into or take out of a file, you can do the exact same thing with a socket, except for shifting backwards and forwards with fseek(). But that would be silly.
00:20:38 <scodil> oh right ok. i'm just looking at the Network docs and I see String arguments. But if I use hPutBuf and hGetBuf then I can do pretty much anything (as long as its Storable)  right?
00:20:52 <ddarius> Yes.
00:22:01 <MyCatVerbs> scodil: yes, but unless you're quite extremely bandwidth constrained, please do at least consider using plaintext instead anyway. It'll be a bit easier to test and debug.
00:22:50 <scodil> sure yeah of course
00:23:20 <scodil> i was just thinking of things like Doubles
00:23:30 <scodil> don't want to write those to strings
00:24:35 <MyCatVerbs> Oh, buggery in a lemon.
00:25:30 <MyCatVerbs> I really don't think a braindead chatserver would be the most sensible thing to use as example network code, because the only sane way of writing it would surely have to involve making the thing multithreaded too.
00:26:04 <ddarius> Practically all interesting network code is multithreaded.
00:26:15 <MyCatVerbs> ddarius: point.
00:26:42 * MyCatVerbs looks up Control.Current.
00:28:18 <scodil> so how do you write a simple server in haskell? forkIO and then block on accept? or is there something analogous to poll/select?
00:28:36 <dons> threadWait on a handle does a select
00:28:58 <MyCatVerbs> scodil: you can use poll/select directly if you really want to, there's a Posix module with most of the interesting stuff in it.
00:29:10 <dons> there's also an epoll thread/event library
00:29:10 <ddarius> Um, all of the above.
00:29:54 <MyCatVerbs> ddarius: I love that answer. ^^
00:30:20 <scodil> but "forkIO $ do stuff <- accept socket" won't work?
00:30:43 <scodil> er, modulo syntax. you get the idea
00:31:55 <ddarius> Sure it will.
00:32:00 <dons> look fine. if 'accept' has some sensible defn :-)
00:32:52 <dons> basically any way you could conceivably write a multithreaded server is doable. channels, messages, select/poll , blocking, whatever. we have the concurrency abstractions :-)
00:33:00 <duey> !
00:33:07 <duey> finally got haskell sorted
00:33:15 <dons> cool. i haven't yet. how'd you do it?
00:33:16 <dons> :-)
00:33:23 <duey> it was tough!
00:33:26 <MyCatVerbs> dons: not quite.
00:33:28 <dons> > sort "haskell" -- maybe it's not too hard.
00:33:29 <duey> the guy at the end was real hard
00:33:30 <lambdabot>  "aehklls"
00:33:37 <MyCatVerbs> dons: I don't see any AIO support in System.Posix.IO. =D
00:33:46 <duey> with case syntax
00:33:53 <dons> MyCatVerbs: is that the linux epoll system?
00:33:59 <duey> can you use free form
00:34:07 <ddarius> duey: Yes.
00:34:08 <dons> (its in the events/threads library, if so (rings a bell, anyway))
00:34:08 <duey> case { blah; blah; blah;}
00:34:18 <duey> where do the { brackets go?
00:34:19 <MyCatVerbs> dons: nah, there's an asynchronous IO API defined in one of the later versions of POSIX.
00:34:21 <dons> > case 1 of 2 -> 7 ; 1 -> 3 ; 7 -> 2
00:34:22 <lambdabot>  3
00:34:27 <scodil> do you still have to add -threaded to the ghc command line to get forkIO to work properly?
00:34:40 <MyCatVerbs> dons: it's been in Linux userspace for ages, I think it's already shifted into Linux kernelspace but don't quote me on that.
00:34:40 <duey> hmmmm
00:34:42 <dons> to use smp threads, yes.
00:34:57 <dons> scodil: otherwise its a single threaded runtime emulating multiple thread with select
00:35:11 <MyCatVerbs> dons: some Unixes don't actually implement it though. e.g. OpenBSD, much to my dismay.
00:35:15 <dons> MyCatVerbs: there's a binding, not sure where  it is. i've definitely seen work on it.
00:35:19 <ddarius> > case 1 of { 2 -> 7; 1 -> 3; 7 -> 2 }
00:35:21 <lambdabot>  3
00:35:33 <scodil> dons: but in that case I can still have multiple lightweight threads all blocking on IO, and it will still work fine, right?
00:35:39 <dons> > case 1 of x | x == 2 -> 7 | x == 3 -> 1
00:35:40 <lambdabot>   Non-exhaustive patterns in case
00:35:41 <dons> hehe
00:35:50 <int-e> scodil: yep
00:35:52 <dons> scodil: should be fine.
00:35:53 <duey> sweet
00:35:54 <duey> thanks
00:36:06 <dons> ?pretty case 1 of { 2 -> 7; 1 -> 3; 7 -> 2 }
00:36:07 <lambdabot> "Parse error" at column 37
00:36:13 <dons> ?pretty x = case 1 of { 2 -> 7; 1 -> 3; 7 -> 2 }
00:36:14 <lambdabot>  x = case 1 of
00:36:14 <lambdabot>          2 -> 7
00:36:14 <lambdabot>          1 -> 3
00:36:14 <lambdabot>          7 -> 2
00:36:20 <MyCatVerbs> dons: oh, spiffy. Just how rapidly do such things get added to the standard, anyhoo?
00:36:37 <ddarius> Uh, something like that wouldn't I would think.
00:36:39 <dons> these days, they don't. they get put into well-maintained 3rd party packages on hackage.
00:36:48 <dons> esp. if its not portable
00:36:51 <MyCatVerbs> Ah, wrong question.
00:37:17 <MyCatVerbs> Just how rapidly do such things get added to the library set bundled with ghc, nhc, hugs?
00:37:24 <ddarius> They don't.
00:37:34 <dons> btw, here's xmonad as a zipper. the only real world use of a zipper (?) http://darcs.haskell.org/~sjanssen/xmonad/StackSet.hs
00:37:53 <dons> there must be others, surely. oh, there's oleg's demo filesystem.
00:38:17 <ddarius> dons: I'm sure zippers have been used in others.  And likely explicitly used no less.
00:38:30 <MyCatVerbs> ddarius: oh. But... hrmn.
00:38:47 <dons> ddarius: I think there must be, i'd love some examples though.
00:39:00 <dons> also, here's how you integrate a workspace zipper back to a list,
00:39:00 <dons> index :: Eq a => StackSet i a s -> [a]
00:39:01 <dons> index = with [] $ \(Node t l r) -> reverse l ++ t : r
00:39:02 <dons> :-)
00:39:23 <ddarius> It's would be hard to find the cases where zippers are being used without the developer realizing it.
00:39:37 <dons> ddarius: oh, Huet's original paper said that was actually the case.
00:39:48 <dons> people came up with pointer-reversal path tracking, without giving it a name.
00:40:05 <dons> or realising that you can derive such a structure from a regular type.
00:40:22 <dons> let's see if google can find zippers.
00:40:45 <ddarius> Oleg's left-fold enumerator stuff may also lead to zippers used in e.g. SXML.
00:41:01 <ddarius> Or whatever it was called.
00:41:56 <dons> oh, i note collection-0.3 has Data.Tree.AVL.Zipper
00:41:58 <dons> (!)
00:42:50 <dons> not having a lot of luck finding examples other than in papers though
00:44:22 <dons> "Purely Applicative XML Cursor" sounds possible
00:46:16 * ddarius is going to go to sleep before he riles himself up.
00:46:50 <dons> night ddarius
00:50:32 <MyCatVerbs> Sleep well.
00:59:29 <ivanm> @hoogle zipWith
00:59:31 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
00:59:31 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
00:59:31 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
00:59:39 <ivanm> why can't hoogle find zipWith3?
01:05:06 <dons> ?hoogle+
01:05:06 <lambdabot> List.zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
01:05:07 <lambdabot> List.zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
01:05:07 <lambdabot> Monad.zipWithM :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]
01:05:16 <dons> strange.
01:05:18 <dons> ?hoogle+
01:05:19 <lambdabot> Monad.zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()
01:05:19 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:05:21 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:05:25 <dons> there you go :-)
01:05:35 <dons> its in Prelude, not List
01:06:03 <ivanm> @help hoogle+
01:06:04 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
01:06:17 <dons> just returns more matches
01:06:20 <ivanm> dons: I knew it existed... was just trying to find where it was?
01:06:28 <ivanm> ahhh... that was going to be my next question :p
01:06:42 <ivanm> s/?/.
01:06:57 <ivanm> and since its in the prelude, @src won't work?
01:08:19 <dons> @src zipWith3
01:08:19 <lambdabot> Source not found. It can only be attributed to human error.
01:08:25 <dons> if I forgot to add it. yes.
01:10:49 <ivanm> oh, you have to manually add the src files to lambdabot?
01:10:55 <ivanm> or just for the prelude?
01:12:14 <dons> yeah. just didn't add everything.
01:13:17 <ivanm> *nod*
01:13:57 <ivanm> I'm wanting to check whether three lists equal each other... would it be better to do two lots of all, or try and do a zipWith3 version of all?
01:14:20 <dons> :t zipWith3
01:14:23 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:14:35 <int-e> @docs Control.Exception
01:14:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
01:15:01 <dons> >  zipWith3 (\a b c -> a == b && b = c) [1..10] [1..10] [1..9]
01:15:02 <lambdabot>  Parse error
01:15:19 <dons> > zipWith3 (\a b c -> a == b && b == c) [1..10] [1..10] [1..9]
01:15:21 <lambdabot>  [True,True,True,True,True,True,True,True,True]
01:15:29 <ivanm> and then just do an and in front?
01:15:33 <dons> so also check the length :-)
01:15:41 <ivanm> nah, that won't be a problem
01:15:51 <dons> ?pl \a b c -> a == b && b == c
01:15:51 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
01:15:54 <dons> hah
01:16:00 <dons> > and $ zipWith3 (\a b c -> a == b && b == c) [1..10] [1..10] [1..9]
01:16:02 <lambdabot>  True
01:16:12 <opqdonut> ^_^
01:16:24 <ivanm> what I want to test is that for a bunch of numbers ns, nub ns is in increasing order
01:16:41 <ivanm> and that nub . map fst . group . sort is also in increasing order
01:16:44 <opqdonut> ?pl \a b c -> a == b && a == c
01:16:44 <lambdabot> ap (flip . (((.) . (&&)) .) . (==)) (==)
01:16:53 <ivanm> i.e. both those lists should equal some prefix of [1..]
01:16:59 <opqdonut> ?pl \a b c -> (a,a) == (b,c)
01:17:00 <lambdabot> (. (,)) . (.) . (==) . join (,)
01:17:09 <opqdonut> hrrm
01:17:56 <ivanm> thanks dons, opqdonut
01:17:57 <ivanm> bbl
01:18:08 <dons> i checked for increasing order recently with this code,
01:18:08 <dons> monotonic []       = True
01:18:09 <dons> monotonic (x:[])   = True
01:18:09 <dons> monotonic (x:y:zs) | x == y-1  = monotonic (y:zs)
01:18:09 <dons>                    | otherwise = False
01:18:16 <dons> if that's related to your problem.
01:19:10 <dons> so you could paramaterise that with a predicate, and get a more useful function
01:19:20 <dons> its also a fold
01:19:38 <dons> or mapAccumL (yay)
01:19:42 <dons> :t mapAccumL
01:19:45 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
01:20:19 <dons> > mapAccumL (\x y -> (y, x == y - 1)) 0 [1..10]
01:20:20 <lambdabot>  (10,[True,True,True,True,True,True,True,True,True,True])
01:21:18 <dons> > mapAccumL (\x y -> (y, x == y - 1)) 0 (zip3 [1,3,2,4,5,6,1]
01:21:19 <lambdabot>  Parse error
01:21:25 <dons> > mapAccumL (\x y -> (y, x == y - 1)) 0 [1,3,2,4,5,6,1]
01:21:26 <lambdabot>  (1,[True,False,False,False,True,True,False])
01:21:44 <dons> > mapAccumL (\x y -> (y, x < y)) 0 [1,3,2,4,5,6,1]
01:21:45 <lambdabot>  (1,[True,True,False,True,True,True,False])
01:26:23 <davidL> dmwit is on bash!
01:27:26 <wolverian> heh
01:27:40 <MyCatVerbs> I thought the name sounded vaguely familiar.
01:28:02 <MyCatVerbs> Didn't realise this place was quite such a wonderously wretched hive of scum and villainy, though.
01:28:31 <davidL> heh
01:28:40 <dons> hmm? /me is lost.
01:28:50 <MyCatVerbs> http://bash.org/?762681
01:28:52 <lambdabot> Title: QDB: Quote #762681
01:28:54 <MyCatVerbs> Byoiiiing.
01:29:07 <dons> ah ha.
01:31:24 <monochrom> sick. :)
01:40:32 <int-e> fix $ \loop -> do ... is a nice idiom.
01:42:02 <dons> abstracts the loop body out nicely
01:42:32 <int-e> and I finished a trivial chat server. http://int-e.home.tlink.de/haskell/chat.hs :)
01:42:40 <dons> heh
01:43:00 <dons> very agile, int-e :-D
01:43:06 <int-e> at work: http://int-e.home.tlink.de/tmp/chat.png
01:43:26 <dons> int-e you should stick it on the wiki
01:43:36 <dons> "Roll Your Own Chat Server" or something
01:44:20 <wolverian> int-e, couldn't you use handle instead of catch there?
01:44:25 <wolverian> (just a nitpick)
01:44:25 <dons> then we can point people at that if they want to see a simple server example
01:44:49 <dons> yeah, that's a handle (const $ return ()) $ do ...
01:45:03 <DRMacIver> Morning
01:45:08 <dons> yeah, that's a handle (const $ return ()) $ fix $ \loop -> do
01:45:30 <dons> you might also consider:  liftM init (hGetLine hdl)
01:45:35 <dons> as a clearer style for beginners
01:46:26 <wolverian> you know, broadCast looks strange. it's not "broad cast", surely..
01:48:17 <dons> int-e: stick the code on your blog :)
01:49:13 <matthew-_> morning
01:52:29 <int-e> @src Control.Exception.Handle
01:52:29 <lambdabot> Source not found. You type like i drive.
01:52:32 <int-e> @src Control.Exception.handle
01:52:32 <lambdabot> Source not found. My pet ferret can type better than you!
01:53:31 <int-e> @index handle
01:53:32 <lambdabot> Control.Exception
01:55:05 <wolverian> hrm. I'm looking at using the pixbuf and file loading from gtk2hs. they return IO Either.. is there a way to elegantly pipe those together to get a list of succesfully loaded images, where unsuccesful ones are just ignored?
01:56:46 <int-e> wolverian: heh. yes, broadcast is better.
02:00:01 <dons> :t Control.Exception.handle
02:00:03 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
02:02:13 <Saizan> wolverian: do xs <- mapM getPixbuf files; return [x | Right x <- xs] ?
02:03:12 <wolverian> Saizan, ooh, shiny.
03:08:56 <int-e> dons: http://haskell.org/haskellwiki/Chat_Server :)
03:08:58 <lambdabot> Title: Chat Server - HaskellWiki
03:10:51 <dons> very good
03:10:54 <dons> int-e++
03:11:06 <dons> maybe link to the screenshot illustrating use? or upload it?
03:12:27 <ivanm> dons: just saw your monotonic function...
03:13:07 <ivanm> looks good, but the only possible problem is that I might have a list of values where I want the test to fail if the first value =/= 1
03:15:49 <nominolo> meh, gtk2hs makefile hacking sucks ..
03:16:05 <araujo> morning
03:21:18 <int-e> dons: ok, I added a screenshot thumbnail to the final code section. Not sure if that's the best way.
03:29:05 <mux> int-e: just out of curiosity, is there a specific reason you used fix in your chat server example?
03:30:00 <dons> its cute? and he doesn't like 'forever a = a >> forever a' ? :-)
03:30:11 <int-e> mux: no. I just heard of the idiom and wanted to try it out. It's cute.
03:30:12 <dons> in Control.Monad in ghc head, btw.
03:30:23 <dons> int-e: oh, from the mailing list post, this morning?
03:30:41 <int-e> dons: no from something you said here earlier, about xmonad
03:30:50 <dons> yeah, this thiiing:
03:30:51 <dons>     allocaXEvent $ \p -> fix $ \again -> do
03:30:51 <dons>         more <- checkMaskEvent d enterWindowMask p
03:30:52 <dons>         when more again -- beautiful
03:31:57 <dons> and they say you can't write loops in haskell
03:32:03 <vincenz> >take 10 $ fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter .  ((0 /=) .) . flip mod)) . (.)) [2..]
03:32:06 <vincenz> > take 10 $ fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter .  ((0 /=) .) . flip mod)) . (.)) [2..]
03:32:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
03:32:12 <dons> haha
03:32:58 <vincenz> here is the unpl version
03:32:59 <vincenz> primes = do_primes [2..] where do_primes (x:xs) = x:do_primes (filter ((/= 0) . (`mod` x)) xs)
03:33:08 <mux> int-e: yeah funny, but I tend to find it less readable :)
03:33:26 <mux> dons: yeah that is more readable to me :D
03:33:46 * mux notes int-e could have used mdo too
03:34:29 <vincenz> dons: how's work?
03:34:48 <int-e> so \again is better than \loop in your eyes?
03:34:49 <int-e> hmm.
03:35:47 <nominolo> whoa .. c2hs's #c ... #endc doesn't know of pointer syntax :/
03:36:20 <mux> int-e: well, the fix version actually isn't unreadable, but the problem is if someone not used to fixed-point combinators try to understand how it works :)
03:37:11 <int-e> mux: but it's so pretty :)
03:38:06 <dons> int-e: nah, i like loop, but i like the when more again code in xmonad sjanssen wrote :-)
03:38:09 <nominolo> int-e: what's wrong with let loop = ... ?
03:38:14 <dons> bah.
03:38:25 <dons> ?src fix
03:38:26 <lambdabot> fix f = let x = f x in x
03:38:44 <int-e> nominolo: you have to repeat 'loop' one more time then ;)
03:38:54 <mux> > fix (\f s -> case s of [] -> []; (x:xs) -> f xs ++ x) "foobar"
03:38:54 <lambdabot>  Couldn't match expected type `Char' against inferred type `[a]'
03:38:56 <int-e> nominolo: there's nothing wrong with it really.
03:39:10 <int-e> nominolo: it's just not as ... and I repeat myself here ... pretty.
03:39:15 <dons> > fix (:1)
03:39:16 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:39:16 <lambdabot>       Expected...
03:39:21 <dons> > fix (1:)
03:39:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:39:26 <int-e> (:1) is too broken to be fixed.
03:39:33 <dons> go for pretty. this is haskell :-)
03:40:00 <dons> you can delay a release in order to make code prettier, here. its fine.
03:40:01 <nominolo> int-e: but, you know, we can't win the obfuscation contest against perl .. no, wrong, we don't WANT to
03:41:33 <DRMacIver> Hm. I don't know, Haskell can get pretty heavily obfuscated if you start writing things in point free style. :)
03:41:46 * int-e tries to find the IOHCC archives ... hmm.
03:41:47 <dons> ?wiki Obfuscation
03:41:48 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
03:41:51 <dons> its a whole sub-genre
03:41:59 <nominolo> DRMacIver: that's why i corrected myself ;)
03:42:32 <int-e> DRMacIver: at first it's an obfuscation, then it becomes an idiom.
03:43:03 <int-e> dons: thanks
03:43:21 <mux> > fix ((1:) . scanl (+) 1)
03:43:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:43:42 <nominolo> :t scanl
03:43:44 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:44:42 <nominolo> > scanl (+) 3 [4]
03:44:43 <lambdabot>  [3,7]
03:44:49 <DRMacIver> int-e: Well, yesno. I'm not saying pointfree style is always obfuscated - it's a lot more readable in some circumstances.
03:45:15 <DRMacIver> But its overuse certainly makes obfuscation easier. :)
03:45:16 <mux> > fix (\f s -> case s of [] -> []; (x:xs) -> f xs ++ [x]) "foobar"
03:45:18 <lambdabot>  "raboof"
03:46:02 <nominolo> > foldr (flip (:)) [] "foobar"
03:46:03 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
03:46:03 <lambdabot>       Expected...
03:46:37 <nominolo> > foldr (:) [] "foobar"
03:46:38 <lambdabot>  "foobar"
03:46:43 <nominolo> d'oh
03:46:58 <nominolo> > foldl (flip (:)) [] "foobar"
03:46:59 <mux> > fix (\f s1 s2 -> case s1 of [] -> s2; (x:xs) -> x:(f xs s2)) "foo" "bar"
03:47:01 <lambdabot>  "foobar"
03:47:01 <lambdabot>  "raboof"
03:47:04 <ToRA> > scanr (:) [] "foobar"
03:47:06 <lambdabot>  ["foobar","oobar","obar","bar","ar","r",""]
03:47:29 <mux> always fun to reimplement things in term of fix :)
03:47:57 <nominolo> mux: although the fix (\f ... ) ideom is very simple
03:48:04 <mux> @pl \f s1 s2 -> case s1 of [] -> s2; (x:xs) -> x:(f xs s2)
03:48:04 <lambdabot> (line 1, column 27):
03:48:04 <lambdabot> unexpected ">" or "-"
03:48:04 <lambdabot> expecting variable, "(", operator or end of input
03:48:13 <mux> nominolo: it is when you know how to use it
03:48:27 <mux> but it still scares the hell out of many people that don't know how it works
03:48:29 <mux> @src fix
03:48:29 <lambdabot> fix f = let x = f x in x
03:48:45 <mux> this definition is just uber-cute
03:48:58 <mux> but very confusing at first
03:49:23 <int-e> tying knots is fun!
03:49:54 <nominolo> @seen dcoutts
03:49:54 <lambdabot> dcoutts is in #ghc, #haskell-overflow, #haskell and #gentoo-haskell. I last heard dcoutts speak 14h 2m 9s ago.
03:50:37 <int-e> http://hpaste.org/1710 also ties a few knots :)
03:52:31 <nominolo> @kick me
03:52:31 <lambdabot> Maybe you meant: dice dict kind
03:52:38 <nominolo> @kick nominolo
03:52:38 <lambdabot> Maybe you meant: dice dict kind
03:52:50 <nominolo> @slap nominolo
03:52:51 * lambdabot smacks nominolo about with a large trout
03:52:56 <nominolo> @botsnack
03:52:57 <lambdabot> :)
03:52:57 <Saizan> it's me or KMP is like building a DFA for .*needle.* ?
03:53:10 <sieni> @dice 1d0
03:53:10 <lambdabot> 1d0 => 1
03:53:13 <sieni> @dice 1d1
03:53:14 <lambdabot> 1d1 => 1
03:53:15 <sieni> @dice 1d1
03:53:15 <lambdabot> 1d1 => 1
03:53:17 <sieni> @dice 1d-1
03:53:18 <lambdabot> unexpected "-": expecting number
03:53:22 <int-e> Saizan: that's exactly what it does
03:53:25 <sieni> @dice 1d(-1)
03:53:25 <lambdabot> unexpected "(": expecting number
03:53:37 <sieni> @dice 0d1
03:53:38 <lambdabot> 0d1 => 0
03:54:37 <int-e> Saizan: although that fact is usually hidden by the use of arrays and offsets.
03:56:50 <Saizan> int-e: ugh, it's fascinating how i don't built-in arrays at all in haskell :)
03:57:01 <Saizan> +miss
03:58:25 <int-e> but Haskell does have arrays when you need them. :)
03:59:39 <DRMacIver> What's KMP?
03:59:50 <int-e> Knuth Morris Pratt (modulo spelling)
03:59:51 <mux> knuth morris pratt algorithm I guess?
03:59:55 <DRMacIver> Ah
04:00:04 <mux> a fixed-string searching algorithm
04:05:41 <ivanm> @pl \ (x,y) -> (isSet x) || (isSet y)
04:05:42 <lambdabot> uncurry ((. isSet) . (||) . isSet)
04:06:02 <ivanm> is there a way of simplifying this knowing that the operation applied to both elements is the same?
04:07:30 <Saizan> ?type join (&&&) isSet
04:07:33 <lambdabot> Not in scope: `isSet'
04:07:39 <Saizan> ?type \isSet -> join (&&&) isSet
04:07:41 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
04:07:44 <int-e> @quote 1500
04:07:44 <lambdabot> atp says: hell, i can write 1500 lines of java in an hour. won't do anything.
04:07:53 <Saizan> ?type \isSet -> join (***) isSet
04:07:54 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:08:11 <Saizan> mmh, not quite :D
04:08:50 * LeCamarade finds he has to come up with very string search algorithms all the time, 'pending on the format.
04:09:07 <LeCamarade> But they are usually specified variants of the Bayer-Moore.
04:09:36 <LeCamarade> s/very/very fast, specific/gi
04:09:36 <ivanm> @hoogle &&&
04:09:37 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
04:10:10 <ivanm> what is &&& meant to do?
04:10:23 <ivanm> I know *** lets you define functions on the first and second elements of a pair...
04:11:05 <Saizan> > (head &&& tail) [1..10]
04:11:06 <lambdabot>  (1,[2,3,4,5,6,7,8,9,10])
04:11:33 <ivanm> ahhh...
04:11:35 <ivanm> so is it the same as liftM2 (,) ?
04:11:40 <ivanm> @src (&&&)
04:11:41 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
04:12:07 <ToRA> @type uncurry (==) . unzip . (:[]) . join (***) size
04:12:09 <lambdabot> Not in scope: `size'
04:12:17 <ToRA> @type uncurry (==) . unzip . (:[]) . join (***) length
04:12:19 <lambdabot> forall a. ([a], [a]) -> Bool
04:12:38 <ToRA> swapping length and (==) as appropriate
04:13:40 <Pastorn> @type (***)
04:13:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:13:50 <Pastorn> kill me now
04:14:01 * ToRA wonders if he really needed unzip . (:[])
04:14:54 <ToRA> Pastorn: you can think of (***) as :: ( a -> b) -> (c -> d) -> (a,c) -> (b,d)
04:15:08 <ivanm> @hoogle join
04:15:09 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
04:15:09 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
04:15:09 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
04:19:29 <dcoutts> nominolo: hia
04:20:16 <dcoutts> wolverian: we should have just made the pixbuf loader use exceptions rather than Either
04:25:56 <nominolo> hi dcoutts
04:26:00 <dcoutts> @arr!
04:26:00 <lambdabot> Avast!
04:26:05 <nominolo> i found my bug
04:26:13 <nominolo> too stupid to be true
04:26:16 <nominolo> though it was
04:26:28 <dcoutts> oh good, what was it?
04:26:35 <nominolo> it couldn't find a file -- because it didn't exist!
04:26:41 <nominolo> (i didn't save it)
04:27:00 * nominolo ----> wall
04:27:05 <EliasAmaral> there are a quote service in this channel? :-)
04:27:12 <dcoutts> @quote
04:27:12 <lambdabot> ddarius says: * ddarius comes back and everyone is like ftw this and ftw that, and I'm wtf?
04:27:14 <nominolo> @quote
04:27:14 <lambdabot> dcoutts says: Apparently that's only 200x faster than the faster of two common python serialisation libs, so we've got some way to go yet.
04:27:34 <EliasAmaral> how can i add a quote? :P
04:27:41 <dcoutts> @help quote
04:27:41 <lambdabot> quote <nick>
04:27:41 <lambdabot> remember <nick> <quote>
04:27:41 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:27:41 <ivanm> @quote quote
04:27:42 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
04:28:06 <ivanm> @quote lambdabot
04:28:06 <lambdabot> lambdabot says: Of course i'm female
04:28:09 <ivanm> heh
04:28:22 <nominolo> dcoutts: now i wonder:  what should the exported type of imageSurfaceGetData be
04:28:37 <nominolo> ATM, it's: imageSurfaceGetStride
04:28:42 <nominolo> uh
04:28:53 <dcoutts> ForeignPtr Word8 ?
04:28:56 <nominolo> imageSurfaceGetData :: Surface -> IO (ForeignPtr CUChar)
04:28:56 <nominolo>  
04:29:21 <ivanm> @hoogle mapAccumL
04:29:22 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
04:29:22 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:29:24 <nominolo> is marshalling CUChar to Word8 a no-op?
04:29:34 <dcoutts> nominolo: casting a pointer is a no-op
04:29:45 <EliasAmaral> @quote nominolo <nominolo> i found my bug <nominolo> too stupid to be true <nominolo> it couldn't find a file -- because it didn't exist!
04:29:46 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
04:29:49 <nominolo> i guess it's an unsafeCast though
04:30:08 <dcoutts> @hoogle cast
04:30:08 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
04:30:08 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
04:30:08 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
04:30:14 <EliasAmaral> its remember, guess i will try in pvt
04:30:19 <dcoutts> nominolo: Foreign.ForeignPtr.castForeignPtr
04:31:49 <ivanm> dons: with those mapAccumL versions of the monotonic function you gave me earlier, what's the difference between them?
04:31:57 <ivanm> just how you define monotonic?
04:33:35 <nominolo> ok, it compiled.
04:35:13 <nominolo> EliasAmaral: you have to use @remember to add a quote
04:35:36 * int-e found the command for adding quotes somewhat difficult to remember.
04:35:38 <wolverian> dcoutts, yes, please :)
04:35:46 <int-e> (and grr nominolo for spoiling this :)
04:41:35 <nominolo> dcoutts: there's one little problem with the current interface. getWidth, getHieght, getStride, getFormat return something in the Render monad.  When you want to use the surface data, however, you want to be in IO
04:42:01 <wolverian> dcoutts, anything I should read/consider/rtfm if I want to hack it in?
04:42:10 <dcoutts> nominolo: mm, one can use liftIO I guess
04:42:21 <dcoutts> wolverian: I was just looking at it actually
04:42:36 <dcoutts> wolverian: we want to translate the pixbuf errors into an IOError
04:43:15 <wolverian> doesn't look hard
04:43:39 <nominolo> dcoutts: yes, i'm just writing a test program.  let's see
04:43:51 <wolverian> of course I don't know anything about gtk2hs or the bindings :)
04:44:50 <dcoutts> nominolo: and renderWith will get you back to IO
04:45:31 <dcoutts> wolverian: the code is in gtk/Graphics/Gtk/Gdk/Pixbuf.chs.pp
04:45:51 <dcoutts> wolverian: but see also: http://developer.gnome.org/doc/API/2.0/gdk-pixbuf/gdk-pixbuf-gdk-pixbuf.html#GDK-PIXBUF-ERROR:CAPS
04:45:53 <lambdabot> Title: The GdkPixbuf Structure, http://tinyurl.com/2zfnw2
04:46:07 <dcoutts> wolverian: we want to map than error enumeration to an IOError as best we can
04:46:24 <wolverian> I was just going to ..
04:46:30 <wolverian> (\gerror -> fail $ liftM $ handlePixbufError gerror) or so :)
04:47:40 * wolverian wrangles types
04:48:03 <dcoutts> wolverian: IOError is in System.IO.Error
04:48:09 <wolverian> this should really be parametrised better
04:49:21 <wolverian> dcoutts, right.. fail in IO monad throws that
04:50:27 <dcoutts> wolverian: fail throws a 'user error' kind of IOError, which looks like the best we can do, except we can add a FilePath to the error
04:50:50 <wolverian> oh, right. it wants a String
04:52:27 <dcoutts> wolverian: we probably want ioError (mkIOError msg Nothing (Just filename))
04:53:05 <wolverian> hum.. do we want to use PixbufError at all?
04:54:02 <wolverian> it'd be more granular..
04:54:09 <dcoutts> wolverian: seems we can't make any good use of it, it doesn't map to any of the IOError types
04:54:16 <wolverian> right
04:55:24 <wolverian> I'm a bit confused here
04:56:01 <wolverian> oh.. I was reading handlePixbufError already used fail -- but it only uses it when there's an error in it
05:00:45 <wolverian> I'm a bit hesitant to actually patch this. the real solution seems to be adding generic GError -> IOError handling. that would be used all over gtk2hs, I assume
05:17:12 <dcoutts> wolverian: yeah, I guess so, but with per-error domain mapping of error enums to IOError types
05:18:14 <dcoutts> wolverian: for example for the GFileError we can map many of those to appropriate IOErrorType values
05:18:16 <dcoutts> http://developer.gnome.org/doc/API/2.0/glib/glib-File-Utilities.html#GFileError
05:18:18 <lambdabot> Title: File Utilities, http://tinyurl.com/yv2bgv
05:18:33 * dcoutts -> lunch -> IO ()
05:28:08 <dons> ndm, could you try the isSpace in isSpaceWord8 :: Word8 -> Bool
05:28:12 <dons> Data.ByteString.Base
05:30:02 * dons `ap` bed
05:30:09 <kolmodin> g'night dons
05:30:37 <kolmodin> "sweet dreams"
05:33:30 <dcoutts> wolverian: actually, the simple change is just to throw the GError
05:37:04 <dcoutts> wolverian: ie we should use propagateGError
05:37:46 <nominolo> hm, how can I read the data pointed to by a Ptr ?
05:38:37 <wolverian> dcoutts, ah, I see.
05:39:47 <nominolo> ah, peekElemOff
05:50:35 <nominolo> dcoutts: ok, seems to work
05:52:28 <nominolo> dcoutts: not sure how to reliably test for memory leaks, though
06:01:13 <ivanm> I'm going through the following discussion on shuffling algorithms in haskell: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
06:01:45 <Lemmih> @seen shapr
06:01:45 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 1d 7h 44m 24s ago.
06:02:00 <ivanm> I'm just having trouble working out what the inputs being passed into them are :s
06:03:46 <balodja> how to cause simple stack overflow?
06:03:54 <Saizan> ivanm: "them"?
06:04:06 <nominolo> > fix id
06:04:10 <lambdabot>  Exception: <<loop>>
06:04:15 <ivanm> Saizan: there's a naive and a good implementation, which do the same thing
06:04:46 <nominolo> fix not True
06:04:51 <nominolo> > fix not True
06:04:51 <lambdabot>  Couldn't match expected type `Bool -> t'
06:05:01 <nominolo> > fix not
06:05:02 <lambdabot>  Exception: <<loop>>
06:05:04 <dibblego> > fix $ not True
06:05:04 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Bool'
06:05:10 <dibblego> ?type fix
06:05:12 <lambdabot> forall a. (a -> a) -> a
06:05:20 <dibblego> ?type not True
06:05:22 <lambdabot> Bool
06:05:35 <nominolo> > let f = g; g = f in f
06:05:36 <lambdabot>  Exception: <<loop>>
06:05:37 <dibblego> ?type fix not
06:05:39 <lambdabot> Bool
06:05:53 <Saizan> ivanm: shuffle:: [b] -> [Integer] -> [b], the [Integer] is a list of random numbers, the first is between 0 and n-1, the second 0 and n-2 etc..
06:06:15 <balodja> > let f n = f (n+1); in f 1
06:06:17 <ivanm> Saizan: OK, so how would I generate that list of random numbers?
06:06:21 <lambdabot> Terminated
06:06:41 * ivanm has only just started looking at random numbers in Haskell
06:07:48 <Saizan>  let sz = Set.size s - 1
06:07:48 <Saizan>               is <- mapM (getRandomR . ((,) 0)) [sz,(sz-1)..(sz-n)]
06:08:48 <Saizan> ?type getRandomR
06:08:51 <lambdabot> Not in scope: `getRandomR'
06:09:23 <Saizan> ?hoogle getRandomR
06:09:24 <lambdabot> No matches found
06:09:30 <Saizan> mmh
06:09:49 <ivanm> heh
06:09:55 <ivanm> @hoogle+ random
06:11:39 <Saizan> ?hoogle randomR
06:11:39 <lambdabot> Random.randomR :: (Random a, RandomGen b) => (a, a) -> b -> (a, b)
06:11:39 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
06:11:39 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
06:11:58 <Saizan> yeah, getRandomR is an happs' function
06:12:22 <ivanm> ahhh
06:12:32 <ivanm> getRandomR returns a range?
06:12:42 <Saizan> no, it's like randomRIO
06:12:49 <Saizan> it doesn't need a seed
06:12:57 <balodja> > foldr (-) 0 [1..] -- simple enough
06:12:59 <lambdabot>  Exception: stack overflow
06:13:04 <Saizan> it return a element in teh range you specify
06:14:14 <ivanm> nice!
06:14:28 <ivanm> hmmmm.... I suppose the range criteria can be done by something like...
06:14:56 <ivanm> > let n = 5 in map ((,) 0) . take n . iterate pred $ n
06:14:57 <lambdabot>  [(0,5),(0,4),(0,3),(0,2),(0,1)]
06:15:32 <erider> good morning
06:15:44 <ivanm> > let n = 5 in map ((,) 0) . take (succ n) . iterate pred $ n
06:15:45 <lambdabot>  [(0,5),(0,4),(0,3),(0,2),(0,1),(0,0)]
06:15:49 <ivanm> good evening, erider
06:15:50 <ivanm> ;-)
06:17:13 <ivanm> > let n = 5 in map (flip randomR (mkStdGen n) . (,) 0) . take (succ n) . iterate pred $ n
06:17:14 <lambdabot>  [(5,240084 40692),(3,240084 40692),(1,240084 40692),(2,240084 40692),(1,2400...
06:17:29 <ivanm> > let n = 5 in map (flip randomR (mkStdGen n) . (,) 0) . take (succ n) . iterate pred $ n :: [Int]
06:17:30 <lambdabot>  Couldn't match expected type `Int'
06:18:28 <ivanm> > let n = 5 in map (randomRIO . (,) 0) . take (succ n) . iterate pred $ n
06:18:30 <lambdabot>  [<IO Int>,<IO Int>,<IO Int>,<IO Int>,<IO Int>,<IO Int>]
06:19:59 <ivanm> @hoogle [IO a] -> [a]
06:20:00 <lambdabot> No matches, try a more general search
06:20:10 <ivanm> @hoogle [m a] -> [a]
06:20:11 <lambdabot> Prelude.cycle :: [a] -> [a]
06:20:11 <lambdabot> Prelude.init :: [a] -> [a]
06:20:11 <lambdabot> Prelude.reverse :: [a] -> [a]
06:20:20 <ivanm> @hoogle (Monad m) => [m a] -> [a]
06:20:21 <lambdabot> Prelude.cycle :: [a] -> [a]
06:20:21 <lambdabot> Prelude.init :: [a] -> [a]
06:20:21 <lambdabot> Prelude.reverse :: [a] -> [a]
06:21:40 <ivanm> can I use mapAccumL + randomR in some way for this?
06:22:09 <Saizan> > let n = 5 in unfoldr (\(g,xs) -> case xs of x:xs' -> let (a,g) = randomR g x in Just ((g,xs'),a); [] -> Nothing) . map ((,) 0) . take (succ n) . iterate pred $ n
06:22:10 <lambdabot>      Occurs check: cannot construct the infinite type:
06:22:10 <lambdabot>       t = (t1, [(t, t)...
06:22:26 <Saizan> > let n = 5 in unfoldr (\(g,xs) -> case xs of x:xs' -> let (a,g) = randomR g x in Just (a,(g,xs')); [] -> Nothing) . map ((,) 0) . take (succ n) . iterate pred $ n
06:22:27 <lambdabot>  Couldn't match expected type `((t, t), [(t, t)])'
06:22:35 <Saizan> ?type unfoldr
06:22:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:22:42 <ivanm> I can get it to generate a random list of IO Int...
06:22:45 <cdsmith> How do I get ByteString.readFile to finish reading and close the file?
06:24:24 <Saizan> > let n = 5 in unfoldr (\(g,xs) -> case xs of x:xs' -> let (a,g) = randomR g x in Just (a,(g,xs')); [] -> Nothing) . ((,) (mkStdGen n)) . map ((,) 0) . take (succ n) . iterate pred $ n
06:24:24 <lambdabot>  Couldn't match expected type `(t, t)'
06:25:46 <ivanm> @type mapAccumL
06:25:48 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:29:49 <ivanm> Saizan: actually, I just found this code by vincenz: http://paste.lisp.org/display/25032
06:30:22 <ivanm> but it looks like using lists for an imperative style random permutation function :(
06:32:01 <Saizan> well list just means O(n) instead of O(log n)
06:34:05 <ivanm> is it?
06:34:16 <ivanm> it is too... thought it was O(n^2) for a bit there
06:34:33 <ivanm> but it never uses removeAt for any n > 1
06:35:26 <ivanm> how can I generate a random seed?
06:35:36 <Saizan> well every removeAt (or extract in oleg) is O(n) instead of O(log n) so you get O(n^2) overall
06:35:45 <ivanm> ahhhh
06:35:56 <ivanm> I suppose I'm not using it much...
06:36:07 <ivanm> and its a lot easier to visualise conceptually....
06:36:20 <ivanm> so, for a random seed, use one of the randomIO functions?
06:36:38 <Saizan> yes
06:36:50 <Saizan> http://www.haskell.org/haskellwiki/New_monads/MonadRandom <-- yopu may want to look at this
06:36:51 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
06:37:24 <ivanm> thanks Saizan++ ! :D
06:38:25 <sorear> .
06:38:46 <ivanm> you're rather voluble today, sorear... :p
06:39:40 <sorear> @web1913 voluble
06:39:42 <lambdabot> *** "Voluble" web1913 "Webster's Revised Unabridged Dictionary (1913)"
06:39:42 <lambdabot> Voluble \Vol"u*ble\, a. [L. volubilis, fr. volvere, volutum, to
06:39:42 <lambdabot>    roll, to turn round; akin to Gr. ? to infold, to inwrap, ? to
06:39:42 <lambdabot>    roll, G. welle a wave: cf. F. voluble. Cf. F. {Well} of
06:39:42 <lambdabot>    water, {Convolvulus}, {Devolve}, {Involve}, {Revolt}, {Vault}
06:39:44 <lambdabot> [22 @more lines]
06:40:14 <ivanm> Saizan: that new monad looks a little complicated for what I want...
06:40:16 <ivanm> thanks anyway
06:40:37 <ivanm> I'll probably use either the naive approach by oleg, or else vincenz's one
06:40:49 <ivanm> the tree based one is probably too complex for my needs ;-)
06:41:57 <Saizan> well the random-ralted part is the same
06:42:48 <Saizan> and the naive from oleg is exactly the one used from vintcenz
06:43:33 <ivanm> but vincenz's one only need one random input, rather than a list of them
06:43:52 <Saizan> because it's generating them on the fly
06:43:59 <ivanm> can I use x <- randomRIO inside a where statement?
06:44:01 <ivanm> true...
06:44:31 <Saizan> you only need a seed anyway
06:45:32 <ivanm> yeah, but I'm trying to get the seed generated using newStdGen
06:46:03 <Saizan> ?docs System.Random
06:46:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
06:46:49 <ivanm> figured it out... rather than having g at the end of the first line of the funtion, have =<< newStdGen
06:47:11 <Saizan> yup
06:47:27 <ivanm> I take it back, it doesn't work :(
06:47:41 <Saizan> newStdGen is in IO
06:48:33 <ivanm> yeah... without using g <- newStdGen inside a do block, how can I get the value?
06:49:24 <Saizan> that's the only way, or the equivalent newStdGen >>= \x -> in the IO monad
06:50:29 <Saizan> main = do { x <- newStdGen; randomPerm x list }
06:50:44 <Saizan> main = do { x <- newStdGen; print $ randomPerm x list }
06:52:36 <ivanm> no, tried that...
06:52:48 <ivanm> it keeps having type problems
06:52:49 <ivanm> :(
06:53:11 <Saizan> like?
06:54:17 <ivanm> Couldn't match expected type `[t]'
06:54:17 <ivanm> 	   against inferred type `IO StdGen'
06:54:17 <ivanm>     In a 'do' expression: g <- newStdGen
06:54:17 <ivanm>     In the expression:
06:54:17 <ivanm> 	do g <- newStdGen
06:54:17 <ivanm> 	   randomPerm' l (length l) g
06:54:54 <ivanm> ummm..... does a do-based function _have_ to return a monad?
06:54:58 <ivanm> maybe that's it...
06:55:02 <Saizan> yes.
06:55:12 <Saizan> but you shouldn't modify randomPerm
06:55:16 <Saizan> you should just use it
06:55:22 <Saizan> providing a seed
06:55:38 <ivanm> *nod*
06:56:29 <ivanm> which would require a do-block, right?
06:56:41 <ivanm> if I want a random seed
06:56:41 <mauke> nothing requires a do block
06:57:09 <ivanm> do block / explicit monadic passing
06:57:10 <Saizan> yoou can have randomPermIO :: [a] -> IO [a]; randomPermIO list = do g <- newStdGen; return $ randomPerm g list
06:57:18 <ivanm> yeah
06:57:32 <ivanm> but then I'd need yet another function that would un monadise it
06:57:44 <Saizan> you can't unmonadise IO
06:57:50 <ivanm> oh.....
06:57:56 <ivanm> but I need to...
06:57:57 <Saizan> IO is a one way monad
06:58:20 <dcoutts> cdsmith: ByteString.readFile is strict, so it reads the whole file and closes it.
06:58:49 <ivanm> Saizan: but I need to perform more operations on the result :s
06:59:18 <cdsmith> dcoutts: Hmm... that's not what I'm seeing.  (I'm actually using Data.Binary's decodeFile, but it says it uses ByteString)
06:59:36 <dcoutts> cdsmith: ah, that's using a lazy BytString
06:59:42 <Saizan> ivanm, just write your code needing a random seed, you'll eventually get one from your main function that must be in IO
06:59:50 <dcoutts> cdsmith: there's Data.ByteString and Data.ByteString.Lazy
07:00:06 <ivanm> Saizan: I have a data structure that I need to shuffle in three different ways...
07:00:09 <cdsmith> dcoutts: Okay.  So I should use Data.ByteString explicitly?
07:00:24 <ivanm> or are you saying to get main to pass through the random seed?
07:00:45 <dcoutts> cdsmith: so with a lazy bytestring, it's lazy in the same way that ordinary readFile is lazy, it closes the file when it's read the whole input
07:01:11 <Saizan> ivanm: exactly, remember that you can get two seeds from one by splitting
07:01:18 <dcoutts> cdsmith: so the ideal way is to read all the stuff you're decoding with Data.Binary, then it'll have read the whole file.
07:01:25 <ivanm> splitting?
07:01:33 <cdsmith> dcoutts: I thought I was doing that.
07:01:35 <Saizan> ?type split
07:01:37 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
07:01:56 <ivanm> > split (mkStdGen 42)
07:01:58 <lambdabot>  (44 40692,1720602 2147483398)
07:02:03 <ivanm> mkStdGen 42
07:02:06 <ivanm> > mkStdGen 42
07:02:08 <lambdabot>  43 1
07:02:24 <ivanm> ok, how did it do that? :s
07:02:27 <ivanm> @src split
07:02:28 <lambdabot> Source not found. My mind is going. I can feel it.
07:02:29 <cdsmith> @paste
07:02:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:02:30 <ivanm> heh
07:02:38 <Lemmih> ivanm: Try running it again.
07:02:45 <ivanm> > split (mkStdGen 42)
07:02:46 <lambdabot>  (44 40692,1720602 2147483398)
07:02:50 <Saizan> ivanm: you know how pseudo random generators work?
07:02:55 <ivanm> yeah, it's determnistic
07:03:11 <ivanm> Saizan: yes... so split generates two new lots of random numbers then?
07:03:25 <ivanm> using the given value?
07:03:56 <Saizan> it generates two seeds from one
07:04:02 <ivanm> using a PRNG?
07:04:09 <cdsmith> dcoutts: Do you mind looking at http://hpaste.org/1912?  It's not complete code, but that's my input and output bits
07:04:13 <ivanm> > genRange (mkStdGen 42)
07:04:14 <lambdabot>  (0,2147483562)
07:04:17 <Saizan> yes
07:04:25 <ivanm> *nod*
07:05:42 <Saizan> that's why you need newStdGen if you expetc a diffrent sequence of random numbers each time you run your program
07:05:48 <ivanm> *nod*
07:05:58 <dcoutts> cdsmith: so what is wrong with it?
07:06:23 <cdsmith> dcoutts: It's leaving the file open on read, so the write fails.
07:06:39 <cdsmith> dcoutts: From what you said, it should be sufficient to read the whole file, but I think I am.
07:06:55 <ivanm> Saizan: so, for a related problem, if I wanted to find a random value from a (potentially infinite) list, is one way of going about it is to traverse the list with some probability, and keep generating random numbers until we get one less than that probability?
07:07:18 <ivanm> e.g. randomElem 0.5 [1..] gives a 50:50 chance of any particular element being chosen
07:07:34 <ivanm> so you'd probably want one that's pretty small
07:08:05 <kolmodin> cdsmith: on another topic.... if not (isValid path) then error "Bad path" else return () == unless (isValid path) $ error "Bad path"
07:08:21 <Saizan> ivanm: do you want equiprobability for every element to be chosen?
07:08:31 <ivanm> that would be nice
07:08:39 <ivanm> but its only a small, side-part of what I need to do
07:08:47 <ivanm> more of a proof of concept than anything else
07:08:50 <cdsmith> kolmodin: thanks; I'll change that.
07:09:00 <dcoutts> cdsmith: presumably your Binary instance for SnapWorld is fully strict? you don't build a SnapWorld lazily at all do you?
07:09:46 <cdsmith> dcoutts: Umm, I don't understand the question, I guess.
07:10:34 <cdsmith> dcoutts: I annotated with the Binary instance
07:10:58 <dcoutts> cdsmith: hmm, actually it might be a bug in lazy bytestring hGetContents
07:11:14 <Saizan> ivanm: there's an algorithm but you need to traverse the whole list
07:11:22 <ivanm> nah, don't want that
07:11:28 <ivanm> as it could be a very large list
07:11:30 <kolmodin> dcoutts: oh noes!
07:11:44 <kolmodin> so the problem is that it doesn't close the file?
07:12:04 <dcoutts> dons: you around? looks like hGetContentsN doesn't hClose the handle when it finishes reading, so it'll only get closed by the finaliser.
07:12:26 <kolmodin> dons said good night a few hours ago
07:12:33 <TomMD> What is so difficult about building in a method to catch pattern match failures?  I don't get it.
07:12:34 <Saizan> ivanm: so just pick a random number x in an acceptable range and list !! x
07:12:43 <ivanm> hmmm......
07:12:43 <dcoutts> it should be a one line fix: change (return []) for (hClose h >> return [])
07:12:55 <ivanm> now just have to worry about what constitutes an "acceptable range" :s
07:13:01 <ivanm> thanks anyway, Saizan++
07:13:08 <cdsmith> dcoutts: Thanks for taking a look.  I suppose I'll use strict ByteString for now, and try it out again soon.
07:13:13 <cdsmith> dcoutts++
07:13:13 <dcoutts> cdsmith: the workaround is to read the file as a strict bytestring and then convert it to a lazy one
07:13:22 <TomMD> @quote dcoutts
07:13:22 <lambdabot> dcoutts says: Apparently that's only 200x faster than the faster of two common python serialisation libs, so we've got some way to go yet.
07:13:40 <dcoutts> cdsmith: using Lazy.fromChunks
07:13:48 <dcoutts> with just a single chunk
07:14:02 <cdsmith> okay, great
07:18:55 <kolmodin> cdsmith: are you sure that the reading of the state is strict?
07:19:26 <cdsmith> kolmodin: Again, I don't understand the question.
07:20:46 <kolmodin> cdsmith: ah. ok
07:21:23 <kolmodin> cdsmith: if the read is strict it reads all of the file at once
07:21:38 <kolmodin> cdsmith: while if you're using binary the default is to read it lazily
07:21:53 <kolmodin> thus it won't use all of the file until its actually needed
07:22:17 <cdsmith> kolmodin: I'm thinking that even if it's read lazily, then convert should make it strict.  That wraps everything in newTVar.
07:23:19 <kolmodin> so in the example you posted, lets say you read the state but don't use it for 30 seconds. that would mean that the state hasn't been used and the file is thus still opened
07:23:30 <kolmodin> cdsmith: ok. I don't know how the TVars work wrt strictness
07:23:45 <ivanm> @pl \ (x,y) -> (x,f y)
07:23:46 <lambdabot> second f
07:24:30 <cdsmith> kolmodin: I guess I don't, either.
07:35:48 <nominolo> dcoutts: yes, lazy hGetContents doesn't close the handle.  We hit that problem when using it for network sockets
07:37:11 <nominolo> I wonder how this bug could stay in there for so long, though
07:56:00 <koeien> @src Functor
07:56:00 <lambdabot> class  Functor f  where
07:56:00 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:06:18 <sphynx> @src Either
08:06:18 <lambdabot> Source not found. Take a stress pill and think things over.
08:09:14 <koeien> data Either a b = Left a | Right b    i believe
08:09:43 <shapr> How do I start using yi 0.2 ?
08:10:14 <jyp> shapr: have you downloaded the tarballs from hackage?
08:10:48 <jyp> or you prefer to work from darcs directly, maybe
08:10:51 <jyp> ?
08:12:21 <shapr> I'm working from darcs directly.
08:12:28 <shapr> I'm now looking at http://haskell.org/haskellwiki/Yi#How_to_Configure_Yi
08:12:29 <lambdabot> Title: Yi - HaskellWiki
08:13:07 <mux> wow, this is sick
08:13:14 <shapr> mux: Yi?
08:13:20 <mux> GCC 4.2 has been merged into FreeBSD HEAD and it does wild things
08:13:37 <Jaak> wild things?
08:13:37 <jyp> shapr: Any problem to report?
08:13:55 <shapr> jyp: Most likely PEBKAC
08:13:57 <mux> there are some constructs he somehow doesn't like, and it warns about the code being incorrect and that the program will abort() if it reaches that point but still compiles the file
08:14:18 <shapr> jyp: I suspect user error :-)
08:14:35 <mux> so we've been ending up with users having tons of crappy binaries
08:14:47 <mux> because some OpenSSL macros were making GCC produce those abort() calls
08:14:54 <jyp> shapr: Ok :) If you have anything specific I'd be glad to help.
08:14:55 <mux> infecting many OpenSSL consumers
08:14:59 <mux> ouch, ouch, ouch
08:15:22 <IvdSangen> FreeBSD head is the "unstable" revision right?
08:15:27 <mux> yes
08:15:51 <IvdSangen> than it's not a total disaster
08:15:56 <IvdSangen> *then
08:16:38 <mux> no, it's okay, it's just... wild
08:17:06 <mux> d1_srvr.c:845: warning: function called through a non-compatible type
08:17:06 <mux> d1_srvr.c:845: note: if this code is reached, the program will abort
08:17:30 <mux> this way of dealing with this just sounds very wrong
08:17:40 <mux> I have no idea why they introduced this kind of stuff
08:17:47 <mux> maybe there's a rationale behind it
08:18:19 <mux> anyways, that was probably highly off-topic, sorry
08:18:29 <int-e> mux: hmm. maybe it's a case of unspecified or undefined behaviour?
08:18:50 <int-e> mux: you aren't allowed to fail compiling just for that, are you?
08:18:58 <mux> int-e: I'd like it better if they had chosen to just error and not build at that point the, that's the point
08:19:05 <mux> aren't allowed? hmm.
08:19:14 <mux> sounds rather unlikely
08:19:44 <pejo> int-e, if the behaviuor is undefined the compiler can just throw you into nethack.
08:19:59 <int-e> pejo: at run time.
08:21:30 <mux> if a standard explicitely disallows compiling something that makes no sense, I'd say the standard is wrong, and it doesn't really harm to stop build with an error when the compiled version would just call abort() anyways
08:21:41 <mux> err, disallows not compiling
08:23:38 <int-e> hmm. failing at compile time is explicitely mentioned as an option, sorry.
08:25:17 <nominolo> Yi is emacs-like, isn't it?
08:25:37 <dcoutts> nominolo: it also has vi bindings
08:26:31 <Heffalump> mux: so how do people compile a program that just calls abort() ?
08:26:35 <Heffalump> (by your rules)
08:26:57 <mux> come on, this isn't the same thing
08:27:12 <dcoutts> Heffalump: well it's a silly program, disallow it :-)
08:27:19 <mux> don't get pedantic over the potential imprecision of what I said
08:27:34 <mux> in this case GCC itself is adding abort() calls
08:27:36 <Heffalump> well, I'm just a bit concerned about where the boundary is
08:27:44 <Heffalump> if you won't allow a clearly defined one
08:27:58 <mux> I'm talking within the context of this problem only
08:28:25 <IvdSangen> a compiler doesn;t know its context, does it?
08:28:40 <Heffalump> I'm not sure I agree with you even for that specific problem.
08:28:58 <Heffalump> But even if I did, I want to know how you'd define the line.
08:29:30 <mux> sure, let's replace all the build errors where it's possible by a warning and inserting abort() calls
08:30:12 <Heffalump> presumably this was something that was valid in the C type system, though?
08:30:15 <dcoutts> mmm, runtime type checking
08:30:41 <Heffalump> In Haskell we have exactly the same thing for pattern-match failure and undefined class methods
08:30:49 <Heffalump> are you suggesting outlawing those at compile-time too?
08:30:49 <pitecus> the search box on the haskell wiki doesnt seem to be working. Is that on purpose or smth?
08:32:07 <mux> dcoutts: the difference with runtime type checking being that in this case GCC fully knows this isn't going to lead to anything useful at runtime :-)
08:32:52 <Heffalump> I still don't quite follow how this differs from runtime pattern-match failure.
08:32:56 <igli> can someone make lambdabot @ignore fragalot pls?
08:33:03 <mux> Heffalump: C != Haskell
08:33:04 <Heffalump> Every type system divides things into compile-time errors and runtime errors.
08:33:19 <igli> [16:27] <igli> @ignore fragalot
08:33:19 <igli> [16:27] <lambdabot> Not enough privileges
08:33:21 <dcoutts> Heffalump: it's indicative of a pretty serious bug to have the calling conventions not match up
08:33:31 <igli> dons: you live?
08:33:39 <Heffalump> @ignore fragalot
08:33:39 <lambdabot> Not enough privileges
08:33:48 <Heffalump> I'm sure I used to have privileges over lambdabot :-)
08:33:57 <igli> sorear did it for the bot before
08:34:04 <igli> heh :)
08:34:15 <LeCamarade> @seen hpaste
08:34:15 <lambdabot> I saw hpaste leaving #haskell 1d 12h 10m 41s ago, and .
08:34:19 <LeCamarade> :-o
08:34:25 <Heffalump> is there a way to find out who does have them?
08:34:33 <olsner> just as with other undefined or unsafe constructs, there are cases where the programmer knows the unsafe case will never happen and still wants to write the code like that
08:34:36 <Heffalump> dcoutts: sure, but the C type system is weaker than the Haskell type system :-)
08:34:45 <int-e> @ignore + freenode:fragalot
08:35:10 <dcoutts> Heffalump: hmm, I don't think it's a type problem. Calling convention is outside the C spec iirc
08:35:20 <sdf> hi
08:35:29 <sdf> i have stupid question
08:35:34 <olsner> and GCC does need to support lots of old code that is formally unsafe but still works
08:35:47 <sdf> how can i write speedy in keyboard?
08:35:57 <sdf> what do i do for this?
08:36:08 <mux> olsner: the point here is that the old, maybe unsafe, code doesn't work anymore actually
08:36:17 <mux> olsner: GCC makes sure of that by inserting an abort() call itself
08:36:19 <Heffalump> dcoutts: right, so if the C type system doesn't prevent it, I think it's legitimate not to ban it at compile-time
08:36:26 <mux> so I don't see how support for old code justifies this case
08:37:51 <sdf> help
08:38:13 <igli> int-e: thanks :)
08:38:20 <mux> anyways, I'll be back later
08:38:21 * mux &
08:38:41 <int-e> mux: re: gcc: there's a comment in the source saying /* This situation leads to run-time undefined behavior.  We can't, therefore, simply error unless we can prove that all possible executions of the program must execute the code.  */
08:38:46 <int-e> mux :/
08:40:19 <sdf> why don t any one help me?
08:41:24 <twanvl> sdf: "how can i write speedy in keyboard?": Parse error in question
08:41:31 <twanvl> i.e. could you rephrase that
08:41:53 <Heffalump> people keep ignoring my questions too, I wouldn't take it personally ;-)
08:41:54 <sdf> but you understood what i mean?
08:41:59 <twanvl> no
08:42:02 <Heffalump> no, we don't understand what you mean
08:43:10 <olsner> sdf: you can always upgrade your hands - they're not cheap but damn do they write fast
08:43:15 <sdf> i want touch typing
08:43:35 <Heffalump> why are you asking #haskell that?
08:43:52 <sdf> olsner how can you understand me?
08:44:18 <sdf> heffalump simple
08:44:33 <Heffalump> I am not simple, thank you very much!
08:44:40 <sdf> hehe
08:44:57 <sdf> heffalump sorry if i annoy you
08:45:28 <Heffalump> that's ok :-) But I'd still like to know why you think #haskell is a good place to ask about touch typing.
08:46:07 <sdf> this is the room that i used to stay
08:46:21 <sdf> haskell and c rooms
08:46:23 <roconnor> @tr nl en wijziging
08:46:23 <lambdabot> Maybe you meant: . arr bf ft id pl rc src url v wn
08:46:42 <roconnor> @bab nl en wijziging
08:46:43 <lambdabot>   modification
08:47:00 <sdf> lambdabot what is this?
08:47:10 <Heffalump> that still doesn't mean we know anything about it, or are an appropriate place to ask the question
08:47:43 <sdf> heffalump wher can i ask this question?
08:47:45 <nominolo> :t realToFrac
08:47:46 <sdf> where
08:47:47 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:47:58 <Heffalump> I have no idea. But #haskell isn't a directory service either :-)
08:48:03 <nominolo> @instances Fractional
08:48:04 <lambdabot> Double, Float
08:48:33 <kaol> @google how to learn touch typing
08:48:34 <lambdabot> http://www.sense-lang.org/typing/
08:48:34 <lambdabot> Title: Free Touch Typing Program
08:49:01 <isaacd_> lambdabot: what about Integral a => Fractional (Ratio a)
08:49:13 <sdf> lambdabot thank you
08:49:48 <isaacd_> particularly Rational
08:50:02 <isaacd_> = Ratio Integer
08:50:09 <Heffalump> hi ndm
08:50:21 <ndm> hi Heffalump
08:50:28 <ndm> sorry i barely got to see anyone at FITA...
08:50:47 <ndm> one of our party needed to be back in time for a train in york, so we were straight off afterwards
08:52:07 <Heffalump> that's ok
08:52:29 <Heffalump> Hopefully I won't need to rush off after the next one.
08:52:41 <Heffalump> or indeed the one after that.
08:52:46 <ndm> yeah, i won't
08:52:52 <ndm> York is a handy location for me :)
08:53:11 <Heffalump> how far is the uni from the railway station?
08:53:46 <ndm> in York? maybe 20 mins by foot or bus
08:54:44 <ndm> they are pretty close, the bus time is around 5 mins, and buses are every 10/15 mins
08:55:52 <Heffalump> cool
09:01:14 <Igloo> Where is the one after York?
09:03:21 <ndm> Igloo: undecided as yet
09:08:04 <Heffalump> Credit Suisse.
09:08:11 <Heffalump> unless something goes badly wrong, anyway
09:08:24 <ndm> http://www.cs.york.ac.uk/fp/darcs/catch/extra/catch.png
09:08:31 <ndm> what do people think of that "checked with catch" logo
09:08:55 <Heffalump> not sure I understand the right hand side
09:08:59 <Heffalump> is it supposed to be cricketing?
09:09:05 <mauke> .oO( fap fap fap )
09:09:06 <Heffalump> oh, that's a bottom
09:09:12 <Heffalump> IM the left hand side
09:09:30 <Heffalump> a lambda somewhere would be good. Not sure where it'd fit in there, though.
09:09:50 * Philippa_ seconds mauke's comment - looks a bit unfortunate
09:09:55 <ndm> i did try a lambda, but not really enough space
09:09:56 <Heffalump> if the bottom had been flying through the air it'd have been clearer
09:10:03 <Heffalump> fap fap fap?
09:10:11 * Heffalump doesn't get it
09:10:15 <ndm> its a hand catching a _|_
09:10:17 <ddarius> Heffalump: Good.
09:10:23 <ari> Heffalump: Internet culture
09:10:36 <Philippa_> Heffalump: bad onomatopeia for male masturbation
09:10:36 <ddarius> Though I'm a bit surprised due to that "poem" you wrote...
09:10:38 <Heffalump> ahh
09:11:01 <Heffalump> I didn't write it, if you mean the one on my webpage.
09:11:20 <ddarius> Well I mean one that was there years ago, but you didn't?
09:11:27 <Heffalump> I haven't even read all of it. It's just there on principle, because it's illegal.
09:11:45 <Heffalump> at least was found to be illegal in 1977 or so. I doubt it would be now.
09:12:02 <Heffalump> http://news.bbc.co.uk/onthisday/hi/dates/stories/july/11/newsid_2499000/2499721.stm
09:12:05 <lambdabot> Title: BBC ON THIS DAY | 11 | 1977: Gay paper guilty of blasphemy, http://tinyurl.com/abuvq
09:12:16 <mauke> http://www.sexylosers.com/113.html
09:12:18 <lambdabot> Title: #113 - Tripping the Light Faptastic
09:12:39 <ddarius> Heffalump: Ah, I see.
09:13:09 <Heffalump> it does ahve a fairly clear "by" line on it, so I don't see why you thought I wrote it
09:13:18 <ddarius> Well, as I said, I read it years and years ago.
09:13:26 <Heffalump> fair enough
09:13:48 <Heffalump> I don't think it's very good, or very interesting. I just object strongly to the concept of a blasphemy law.
09:14:28 <ddarius> It's pretty clear, even without going to the link, that you didn't write it looking at the sight again now.
09:14:39 <Heffalump> mind you, the domain it's hosted at does damage the point somewhat, I once found a link to it saying that it's illegal in the UK, but legal to host it outside the UK :-)
09:22:27 <fasta`> What is the best way to make an ST monad enhanced with a way to get unique identifiers? I was thinking of combining StateT and ST with a simple counter. It could also be that there's some built-in way to get unique identifiers already...
09:23:05 <ndm> dcoutts_: does that mean you are going to microbenchmark the crap out of isSpace then?
09:23:07 <Philippa_> StateT ST is probably best
09:23:34 <Heffalump> why not ReaderT ST?
09:23:57 <fasta`> Heffalump: that would be better, semantically.
09:24:19 <fasta`> Although, most of the times a little requirement change might need I do need StateT.
09:24:27 <Heffalump> well, you could switch then
09:24:49 <Philippa_> Heffalump: depends on your uniqueness requirement and whether you're willing to put an STRef in the environment
09:25:32 <Heffalump> well, it seems no worse than passing around the list of names in the StateT monad
09:25:44 <Heffalump> but I think all the options are pretty close in "goodness"
09:26:28 <Philippa_> ReaderT isn't good if you later on need totally unique names as opposed to just ones that don't shadow anything though
09:26:54 <fasta`> I only need to fake compare by reference.
09:27:21 <Heffalump> the point about any monad is that if you abstract suitably (which is easy) you can change the details later
09:27:27 <fasta`> I have STRefs containing references to other nodes and when I go up I need to know whether I came from the left or right child.
09:27:44 <fasta`> The only way I can tell this is if the value the references contain is unique
09:28:04 <fasta`> Or is there an instance for Eq for STRef?
09:28:09 <Philippa_> yes, there is
09:28:32 <fasta`> Philippa_: Oh, I see :)
09:28:35 <fasta`> Very nice :)
09:28:45 <fasta`> Not that it is difficult to write...
09:28:49 <fasta`> It's just convenient now :)
09:32:21 <ddarius> I don't think you -could- write an instance of Eq for STRef in terms of the publically available primitives...
09:32:35 <ddarius> Incidentally, there are premade monads for generating unique names.
09:32:54 <Heffalump> fasta`: are you aware of zippers, btw?
09:33:08 <Heffalump> (just a general comment, they may well not be appropriate to your application)
09:33:12 <fasta`> Heffalump: yes, I have made a very non-trivial implementation with zippers
09:33:22 <fasta`> Heffalump: the problem is that zippers don't cut it
09:33:34 <fasta`> @where+ openproblem
09:33:35 <lambdabot> Done.
09:33:42 <fasta`> @where openproblem
09:34:04 <fasta`> @where+ openproblem http://haskell.org/haskellwiki/OpenProblem
09:34:05 <lambdabot> Done.
09:34:09 <fasta`> @where openproblem
09:34:09 <lambdabot> http://haskell.org/haskellwiki/OpenProblem
09:34:35 <fasta`> If you can solve that with zippers, give me a call :)
09:34:55 <fasta`> My actual problem is vastly more difficult.
09:35:48 <jmg_> hi fasta
09:36:15 <fasta`> jmg_: hi, you are from Ja** Scheme, right?
09:36:23 <jmg_> no
09:36:30 <jmg_> i just read your openproblem page
09:36:46 <jmg_> and it occured to me that i might have a tool that should help
09:36:47 <Heffalump> I don't understand the problem. Could you state it more clearly?
09:37:16 <fasta`> Heffalump: what don't you understand?
09:37:23 <jmg_> it's not yet released, but we plan to do so
09:37:32 <fasta`> jmg_: what does it do?
09:37:58 <jmg_> it generates data structures with similar properties to zipper, but that are nice to use in patterns and nice to use in general
09:37:59 <fasta`> As for useful tools: one that converts a functional implementation in a reference based would be nice.
09:38:16 <jmg_> that's somehow what it does
09:38:37 <fasta`> jmg_: now, that's indeed nice.
09:38:49 <jmg_> it is still purely functional but every subtree knows its position in an overall tree
09:39:12 <mauke> fasta`: "all structures together holds the numbers exactly once"?
09:39:25 <fasta`> mauke: ok, a spelling error.
09:39:37 <Heffalump> "move one element to another structure"
09:39:39 <Heffalump> from what structure?
09:39:40 <mauke> what does it mean?
09:39:50 <fasta`> I didn't put too much time in it.
09:39:57 <sitaram> hello all!  Does anyone have a mirror a .tgz of http://nomaware.com/monads ?  I see references to it everywhere but the site seems to be down (been trying for a few days, then decided to ask here)
09:40:07 <fasta`> Heffalump: I will try to clarify it.
09:40:20 <sitaram> mirror a .tgz --> mirror *or* .tgz (sorry for the typo)
09:40:26 <jmg_> fasta: the theory behind it is described here http://softech.informatik.uni-kl.de/twiki/pub/Homepage/Publikationen/wadt04.pdf
09:40:30 <lambdabot> http://tinyurl.com/2dtq4z
09:40:35 <jmg_> i have a haskell code generator for it
09:41:16 <fasta`> jmg_: I think the "theory" is pretty trivial if you compile to ST, otherwise it might not :)
09:41:31 <jmg_> no i don't compile to a monad
09:41:37 <fasta`> No, that doesn't seem easy.
09:42:06 <fasta`> Tepos-algebra???
09:42:20 * fasta` always forgets the different algebra types.
09:42:31 <jmg_> another kind of zipper
09:42:45 * ddarius has never heard of Tepos-algebra.
09:42:45 <jmg_> just think of a tree with upwards pointers
09:42:55 <fasta`> jmg_: Will you announce it on the haskell-cafe mailing list?
09:43:17 <jmg_> i can do that if there is some interest
09:43:28 <jmg_> currently documentation and a homepare is missing
09:43:58 <jmg_> there is also a java and an isabelle/hol backend so it's not a typical haskell tool
09:43:59 <fasta`> jmg_: imho, it's better to release something when you think it's ready.
09:44:07 <cdsmith> jmg_: this is Haskell, and it looks like math.  Of course there's interest. :)
09:44:08 <ndm> logo attempt 2: http://www.cs.york.ac.uk/fp/darcs/catch/extra/catch.png
09:44:30 <ndm> no unintentional sexual stuff, hopefully
09:44:49 <mauke> sitaram: http://www.haskell.org/all_about_monads/html/
09:44:49 <fasta`> ndm: the glove is hard to see and I think it infringes.
09:44:50 <lambdabot> Title: All About Monads
09:45:29 <jmg_> cdsmith: ok,, i will anounce it when there is some more documentation
09:45:51 <cdsmith> jmg_: I was joking.  I don't even know what it is; but I will read the paper later today.
09:45:58 <fasta`> ndm: unless the W3C validator logo has another license than usual.
09:46:04 <sitaram> mauke: thank you so much -- so obvious, but I didnt find it!  (Somehow the nuclear waste thing on the wikibook site didnt grab me:-)
09:46:39 <ndm> not too worried about hte infringe bit
09:46:46 <Heffalump> why would it infringe?
09:46:50 <fasta`> jmg_: but what exactly does your program solve?
09:46:50 <jmg_> cdsmith: i don't think the idea is so deep or enlightning if you are aware of zippers, it's just a different characterization
09:46:52 <ndm> and as long as you can tell its a glove, its close enough
09:47:04 <ndm> Heffalump: have you seen the valid css/html logos?
09:47:05 <ndm> @where ndm
09:47:06 <lambdabot> http://www.cs.york.ac.uk/~ndm/
09:47:13 <ndm> they are at the bottom of my home page
09:47:13 <Heffalump> ndm: yes
09:47:22 <jmg_> it generates zipper like datatypes, that are easy to naviagte and pattern match in
09:47:23 <Heffalump> I just don't think that they could copyright a colour scheme.
09:47:36 <ndm> technically i stole the tick as well
09:47:38 <jmg_> it is useful to implement abstract syntax trees
09:47:43 <Heffalump> hmm, true
09:47:49 <ndm> but without the tick, there really is very little copyrightable stuff left
09:47:54 <fasta`> jmg_: but as for your initial remark: zippers don't solve the "open problem".
09:48:16 <jmg_> Heffalump: Deutsche Telekom has protected the colour of their T in their logo :-(
09:48:18 <Heffalump> still, there's no passing off issue, so if they do complain I think they'd be being unreasonable
09:48:46 <Heffalump> well, we should force people that try to do that to actually generate bad publicity to enforce it
09:48:46 <Igloo> They might be able to trademark the style
09:49:12 <fasta`> I think if they go to court for it that they will win.
09:49:18 <chessguy> hi haskellers
09:49:29 <Heffalump> it wouldn't get that far, though
09:49:30 <Heffalump> Igloo: true.
09:49:44 <ndm> if they threaten me with court i bend, and post my "sob story" about a poor open source developer to slashdot
09:49:50 <ndm> its funny and not much work for me
09:49:51 <Heffalump> precisely
09:49:52 <fasta`> Heffalump: probably not
09:50:56 <Pastorn> i'm modelling chess... i need one word for data XXX = King | Queen | ... | Pawn and another for Type YYY = YYY Colour XXX pos
09:51:08 <Pastorn> and i only know the names in swedish...
09:51:20 <ndm> Piece
09:51:42 <Heffalump> YYY = Position  ?
09:51:46 <Pastorn> yes, that would be YYY
09:51:48 <Heffalump> but it's just the position of one piece
09:51:52 <Heffalump> no, XXX is Piece
09:52:05 <chessguy> i would call XXX Piece and YYY something like PieceInfo
09:52:08 <Heffalump> I guess if you use Board for all the pieces, it's ok
09:52:14 <chessguy> or PieceType and Piece
09:52:17 <Heffalump> or what chessguy said. I guess he should be the expert :-)
09:52:25 <gkr> @src Integral
09:52:25 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:52:25 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:52:25 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:52:25 <lambdabot>     toInteger           :: a -> Integer
09:52:33 <Pastorn> chessguy: why didn't i ask you to begin with =)
09:52:35 <Pastorn> thanks
09:53:08 <chessguy> Pastorn: what are your plans?
09:53:50 <Pastorn> for starters just to create a way of playing the game, leaving it up to the players to keep track of rules
09:54:04 <Pastorn> this would demand a board on the side or good memory
09:54:05 <chessguy> ok
09:54:27 <Pastorn> though it will be possible to take out your opponents pieces
09:54:41 <chessguy> you may also be interested in http://mu.org/~mux/LambdaChess/
09:54:42 <lambdabot> Title: Index of /~mux/LambdaChess
09:54:54 <Pastorn> although not winning, that requires attack lines and stuff
09:55:14 <Pastorn> chessguy: i'm calling this Cheskell =)
09:55:52 <Pastorn> nah, I wanna do this on my own, maybe i'll look at that when i feel stuck, but thanks :)
09:56:11 <fasta`> Liskell, Cheskell, what's next? Aeskell?
10:02:05 <mnislaih> Igloo: I am updating cabal-install for Distribution.Verbosity. Wouldn't verbosity be an instance of Enum too ?
10:02:52 <Igloo> mnislaih: How would you use it?
10:03:35 <mnislaih> to find current verbosity minus one, for instance
10:03:50 <Igloo> Do you actually need that?
10:04:25 <mnislaih> there is some code in cabal-install that does this, although I don't know exactly why
10:04:30 <ndm> mnislaih: sounds like you want Verbosity to be a Num to me..
10:04:37 <ndm> :-)
10:04:44 <Igloo> What's pred silent? silent? an error?
10:05:06 <ndm> Igloo: Haskell spec requires it to be an error
10:05:17 <vincenz_> Igloo: pred silent = loud
10:05:25 <vincenz_> or rather thunder
10:05:27 <vincenz_> after thunder comes silence
10:05:42 <Igloo> mnislaih: Where abouts does it do this?
10:05:51 <mnislaih> that would be annoying for a cabal-install user pov vincenz_
10:06:32 <mnislaih> Igloo: Network.Hacka....Update
10:06:53 <mnislaih> I will leave Verbosity out of Enum, you convinced me
10:07:49 <Igloo> Hmm, I think that should just pass verbosity through unchanged
10:08:39 <mnislaih> will do that
10:08:40 <Igloo> Or possibly "if v == verbose then normal else v"
10:08:55 <mnislaih> fine :)
10:09:32 <Igloo> But personally I'd go with just passing it through unchanged. I'm not really fussed either way, though  :-)
10:14:51 <thetallguy> Hmm... anyone know if filepath-any is provided by libgh6-filepath-dev?
10:15:07 <thetallguy> Cabal on the left, Debian on the right
10:20:13 <stepcut> thetallguy: it seems to be on my system
10:21:08 <stepcut> -any should match any version number, e.g. -1.0. I got libghc6-filepath-dev from sid
10:22:29 <Igloo> thetallguy: If you have ghc 6.6.1 then it's in the ghc6 package
10:23:10 <fasta`> Heffalump: http://haskell.org/haskellwiki/Open_research_problems updated
10:23:11 <lambdabot> Title: Open research problems - HaskellWiki
10:23:12 <Igloo> thetallguy: Which provides: libghc6-filepath-dev
10:28:03 <Heffalump> it's still not written very clearly
10:28:23 <Heffalump> is the "move" operation parametrised by the structure you want to move from?
10:28:36 <Heffalump> Or is there just one "move" operation and the implementation is free to pick any structure at all?
10:28:53 <Heffalump> and is the destination structure a parameter too?
10:29:19 <Heffalump> perhaps if you give an imperative spec it'd be clearer
10:31:14 <fasta`> Heffalump: It's written intentionally abstract. I don't want to specify ways in which you may not implement it.
10:31:56 <Philippa_> okay, an imperative pseudocode reference implementation, then?
10:32:27 <fasta`> Heffalump: move should have type move::SomeValueContainingAllElementsInSubstructures -> :SomeValueContainingAllElementsInSubstructures
10:33:40 <fasta`> Heffalump: There's, AFAIK, no other way to represent it in Haskell.
10:34:17 <fasta`> Heffalump: So you could take SomeValueContainingAllElementsInSubstructures as [[Int]], but it would be _very_ slow.
10:34:34 <fasta`> Heffalump: the challenge is to find some representation in which you can solve it.
10:35:09 <fasta`> Heffalump: I think it's impossible to do so, currently, but roconnor thinks it's possible.
10:35:27 <fasta`> That's why the wiki page exists in the first place.
10:36:05 <fasta`> Is the problem clear now?
10:39:03 <Heffalump> no, not really
10:39:11 <Heffalump> I like the idea of an imperative reference implementation.
10:39:34 <Heffalump> is there just one SomeValueContainingblahblah at any given time?
10:40:19 <fasta`> Heffalump: yes
10:40:44 <fasta`> Heffalump: but I'd consider that to be an implementation detail.
10:41:24 <Heffalump> I mean conceptually.
10:41:37 <Heffalump> so the only operation is move, and "find out what structure an element is in"?
10:41:44 <Laney> Can someone give me a hint as to this: http://hpaste.org/1913 --- i.e. is there a solution other than using different function names? I'm trying to revise for a Haskell exam tomorrow!
10:42:12 <fasta`> Heffalump: if you use the operations in a single-threaded way it should work as efficient as defined.
10:42:18 <fasta`> Heffalump: yes
10:42:51 <ndm> Laney: import Prelude hiding ((>>=))
10:43:03 <ndm> Laney: or import Prelude() -- imports nothing by default
10:43:10 <Heffalump> fasta`: ok, I can implement that in O(1) time.
10:43:12 <Laney> I guess I want the rest of the prelude available ;)
10:43:14 <Laney> thanks ndm
10:43:38 <ndm> import Prelude(Maybe(..)) etc can work
10:43:45 <fasta`> Heffalump: ok, how? Since in that case I need to make the problem more complicated.
10:43:53 <Heffalump> type SomeValueContainingblahblah = Bool
10:44:12 <Heffalump> structure svcbb n = if n == 0 && svcbb then 1 else 0
10:44:23 <Heffalump> move = not
10:44:48 <Heffalump> conceptually, either everything is in the same structure, or one thing (0) is in a different structure
10:45:08 <Heffalump> (yes, I do realise this is probably not what you meant, I'm just trying to demonstrate that you have woefully underspecified things)
10:45:33 <Pastorn> @paste
10:45:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:45:38 <Laney> ndm: The "hiding" one didn't work, but I guess I can get away with "import Prelude (Maybe(..))", seems to do the job. Thanks
10:45:56 <fasta`> Heffalump: ok, I told you I didn't put too much time in it. I don't mind that you interpret it in this way. I will try to write a reference imperative version with more operations.
10:45:59 <ndm> i'm not convinced that this moving things between structures is a real problem,  you have to state the problem in a more "what you want to work out" - not a very low-level method
10:46:24 <fasta`> ndm: if I specify the actual problem, nobody would try to solve it.
10:46:57 <Heffalump> what I think you might be trying to solve sounds somewhat similar to union-find (though not the same). Might be worth looking at specifications of that to get some tips on how to explain your own problem more clearly.
10:46:58 <ddarius> fasta`: If you don't specify any problem nobody will be -able- to solwe it.
10:47:26 <ndm> I am curious if you can implement Union Find in Haskell, as it happens
10:47:38 <ddarius> @faq
10:47:39 <lambdabot> The answer is: Yes! Haskell can do that.
10:47:39 <ndm> with decent time bounds, inverse ackermans etc.
10:52:00 <thetallguy> stepcut: what version do you have?  I'm pointed at etch
10:56:29 <bos31337> @seen CosmicRay
10:56:30 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 1d 18h 11m 17s ago, and .
10:56:37 <bos31337> @seen dons
10:56:38 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 5h 26m 35s ago.
10:56:43 <bos31337> grump.
10:56:56 <Heffalump> ndm: presumably you don't want to use imperative structures?
10:57:22 <ndm> Heffalump: i would like Union Find with a pure and abstract interface, below the surface you can go wild
10:57:50 <ndm> find :: Key -> Key -> UF -> Bool -- are they in the same set
10:57:55 <Heffalump> can't be too hard with STArrays and some unsafe freezing and thawing, surely?
10:58:02 <ndm> union :: Key -> Key -> UF -> UF -- union two keys
10:58:23 <Heffalump> oh, I guess we want to fork the UF state there.
10:58:39 <ndm> yeah
10:58:52 <ndm> I couldn't figure it out, but didn't try too hard
11:00:25 <fasta`> ndm: You can implement everything in Haskell with ST* within constant factors of optimal.
11:00:51 <Heffalump> fasta`: yes, but a pure interface is harder
11:00:55 <ndm> fasta`: not necessarily with a pure interface, and if you can't, i'm not interested
11:01:00 <fasta`> ddarius: I think that the intention of the problem is quite clear. Apparently I was wrong.
11:01:04 <Heffalump> especially if you need to keep state around between invocations
11:03:35 <syntaxfree> is that arrow like a class context arrow or an implication arrow? :)
11:04:35 <Heffalump> what arrow?
11:07:08 <Saizan> in the topic
11:07:26 <Heffalump> ah, right
11:09:30 <vincenz_> I think an implication
11:09:31 <lispy> dons: ping?
11:10:17 <lispy> dons: i was wondering if you have any ideas why lambdabot.codersbase.com is doing funny
11:10:33 <lispy> > 1 + 1 /usr/lib/ghc-6.4.2/package.conf: openFile: does not exist (No such file or directory
11:10:33 <lambdabot>  Parse error
11:10:57 <lispy> oh, maybe my ghc-6.4.2 is hosed
11:11:38 <lispy> yup that's the problem
11:15:28 <syntaxfree> the class context arrow is actually a reverse implication. That bugs me to no end.
11:16:03 <nominolo> syntaxfree: not in a function declaration
11:16:10 <Heffalump> how is it reverse?
11:16:18 <Heffalump> if you have the thing on the left, you can get the thing on the right
11:16:25 <Heffalump> imagine the dictionary passing implementation
11:16:47 <syntaxfree> instance (Num a) => Fractional a
11:16:52 <Heffalump> oh, right.
11:16:55 <Heffalump> that one is, yes
11:17:02 <syntaxfree> a being a Num doesn't imply a being Fractional.
11:17:03 <Heffalump> well, kind of.
11:17:14 <syntaxfree> but it being fractional implies it being Num.
11:17:28 <syntaxfree> as for function declarations, it isn't an implication at all, so I can live with it.
11:17:38 <Heffalump> why isn't it an implication in a function decl?
11:18:10 <syntaxfree> because the -> arrow is the implication.
11:18:43 <Heffalump> but so is the =>, it's just a different kind from the language's point of view
11:19:21 <Heffalump> if you replace the class by a datatype defining the dictionary, it really is the same thing
11:19:53 <syntaxfree> hmm. let me think.
11:20:19 <nominolo> syntaxfree: you read it like this:  "If a is a number, then a is also a fractional and in the following I show you why by giving definitions of the functions that constitute a fractional's operations."
11:20:39 <Heffalump> oh, yes.
11:20:56 <Heffalump> instance (Num a) => Fractional a really does say that every Num is Fractional
11:20:57 <nominolo> syntaxfree: you might want to watch wadler's google talk video
11:21:03 <Heffalump> class Num a => Fractional a is dodgier
11:21:17 <syntaxfree> nominolo: I saw the wadler talk where he defined the semantics of type classes in terms of product types.
11:21:36 <nominolo> he also showed how to translate from => to ->
11:22:02 <syntaxfree> hmm. thanks :)
11:22:19 <nominolo> I mean this one: http://video.google.com/videoplay?docid=-4167170843018186532
11:22:20 <lambdabot> Title: Faith, Evolution, and Programming Languages - Google Video
11:22:24 <syntaxfree> yes, I saw it
11:22:47 <syntaxfree> Now I'm wondering to which extent -> can be considered a normal infix data constructor.
11:23:01 <Pastorn> how do i do this? data A = A B C {funD :: D}
11:23:12 <Pastorn> since that won't work...
11:23:23 <syntaxfree> I remember functions being defined as pairs of domain/image values in real analysis.
11:23:29 <syntaxfree> So in a way functions are really product types.
11:23:41 <fasta`> I chose the easy way out for specifying the problem: http://haskell.org/haskellwiki/Open_research_problems
11:23:42 <lambdabot> Title: Open research problems - HaskellWiki
11:23:49 <sjanssen> Pastorn: what are you trying to do?
11:24:12 <Pastorn> i only need to have a constructor function for one of the values of A
11:24:21 <syntaxfree> Do ordinary product types curry?
11:25:17 <sjanssen> Pastorn: you have to use record syntax for the whole constructor or not use it at all
11:25:26 <mauke> Pastorn: do you mean data A = A B C D; funD (A _ _ d) = d?
11:25:48 <Pastorn> yes
11:25:56 <Heffalump> fasta: that's just silly.
11:26:24 <syntaxfree> records are just syntactic sugar that create destructor functions.
11:33:18 --- mode: irc.freenode.net set +o ChanServ
11:33:54 <syntaxfree> americans often think Lynyrd Skynyrd and the Grateful Dead are the most popular rock bands ever.
11:35:33 <bos31337> uuuhhhh, no.
11:35:41 <Heffalump> submit a patch
11:35:56 <Heffalump> though I guess not everyone would want the extra constant factor.
11:36:00 <Pastorn> no, 'cause that would be linkin park
11:38:40 <emu> kmp?
11:38:58 <emu> there was a recent blog article on kmp, and dynamic programming
11:39:06 <emu> go use his code;)
11:39:31 <mauke> does kmp need Ord?
11:39:39 <Saizan> no
11:40:09 <lispy> this is so weird
11:40:16 <lispy>     Could not find module `Data.Binary':
11:40:16 <lispy>       it is a member of package binary-0.3, which is hidden
11:40:29 <lispy> [$ ghc-pkg list | grep binary Cabal-1.1.6, QuickCheck-1.0, altdata-0.9.10, base-2.0, binary-0.3,
11:40:43 <lispy> my binary package is not hidden but ghc thinks it is?
11:40:48 <Saizan> lispy: you have not listed binary in build-depends?
11:42:05 <lispy> Saizan: thanks, why does that fix that error message?
11:42:39 <Saizan> lispy: cabal hides all packages that are not listed there, by default, so that you don't forget dependencies
11:43:00 <lispy>  
11:43:00 <lispy>  /tmp/ghc23723_0/ghc23723_8.hspp:21:1: lexical error at character 'i'
11:43:07 <lispy> i wonder what is wrong now
11:43:19 <lispy> Saizan: how annoying
11:43:30 <sjanssen> lispy: it's a feature
11:44:06 <Saizan> lispy: mmh, what are you building?
11:44:12 <lispy> lambdabot
11:44:15 <sjanssen> good dependency information is really important -- you know exactly what to tell your users to install
11:44:19 <lispy> i'm trying to repair lambdaweb
11:44:40 <lispy> sjanssen: sure, so either fix the error message or add a special mode for dependency checking
11:44:48 <Saizan> oh, you should use build.sh, not using Setup.hs directly
11:44:58 <lispy> Saizan: i know i am
11:45:06 <Saizan> k
11:45:35 <sjanssen> lispy: binary is listed in lambdabot's build-depends
11:46:58 <lispy> were all the .cabal files rolled into one?
11:47:28 <lispy> i did a pull then backedup my lambdabot.cabal and then copied lambdabot.cabal.plugins over top of it like i usually do
11:47:46 <sjanssen> lispy: I think .plugins is broken
11:51:36 <lispy> any idea where ghc-options is in debian?
11:54:10 <kaol> according to packages.debian.org, nowhere
11:54:27 <lispy>     Could not find module `ghc-options:':
11:54:27 <lispy>       Use -v to see a list of the files searched for.
11:54:42 <sjanssen> lispy: your .cabal file is screwed up somehow
11:54:43 <lispy> could that be a cabal error?
11:57:01 <lispy> okay...i reverted now i get this
11:57:05 <lispy> Modules.hs:23:17: Could not find module `Plugin.Lambda':
11:57:27 <lispy> oh, i see
11:57:36 <lispy> hm...looks like all the modules changed too?
12:03:36 <shapr> Does Yi have a ghci mode? Can I dump the current buffer into an interactive ghci ?
12:04:11 <lispy> shapr: i don't know...but the last ANN of Yi made it sound like that's possible
12:04:54 <shapr> I've gotten yi-static to work, but I can't figure out how to get dynamic yi working...
12:05:09 <lispy> scripts/RunPlugs.hs:10:0: Bad interface file: /usr/local/lib/plugins-1.0/ghc-6.6/System/Eval/Haskell.hi
12:06:26 <lispy> maybe that's just a permission error
12:06:33 <lispy> man, why does building lambdabot have to be so hard...
12:07:32 <edwardk> heh i got lambdabot built once, then i just sort of left it running in fear that if i ever tweaked anything it would never work again ;)
12:07:51 <lispy> edwardk: same here, so it's been about six months since i built it
12:08:09 <lispy> unfortunately, i wanted to upgrade to ghc6.6...and i did, now lambdabot stopped working :(
12:08:13 <lispy> so i have to ubild it again
12:08:31 <edwardk> yeah, i had to build mine back in 6.4.2 because at the time hsplugins weren't playing nice with 6.6
12:10:13 <sjanssen> you have to use the darcs version of hs-plugins with 6.6
12:10:45 * shapr tries that for yi
12:12:16 <Nafai> Hi shapr
12:13:01 <lispy> grr....someone changed the lambdabot command line
12:13:02 <shapr> hiya Nafai, how's code?
12:14:09 <Nafai> Haven't really been doing much programming lately
12:14:12 <lispy> how do you get lambdabot to use online mode now?
12:15:14 <edwardk> sjanssen yeah, i just can't be buggered to endure that build process again ;)
12:15:31 <shapr> Nafai: What do you do for fun?
12:21:36 <lispy> i give up
12:21:44 <lispy> this isn't worth my time...i have to also fix GOA
12:22:11 <lispy> lambdaweb is broken until either i find time or someone else fixes GOA
12:24:59 <lispy> the authorities have been notified
12:25:00 * lispy &
12:25:03 * jyp is back
12:25:17 <jyp> shapr ...
12:26:22 <jyp> you have a *console* buffer which should behave "ghci-like"
12:26:29 <syntaxfree> @notify-authorities
12:26:29 <lambdabot> Unknown command, try @list
12:26:45 <syntaxfree> my ghci is all broken. i can hardly use it.
12:26:48 <syntaxfree> backspace doesn't work!
12:28:08 <jyp> shapr: also note that Yi 0.2 no longer depends on hs-plugins.
12:34:04 <nominolo> dcoutts_: ok, now i can finally use cairo images as gl-surfaces and run all this inside gtk.  It looks buttugly, but it works.  What kind of patch format do you prefer?  BTW, i have patched against the tarball, not against darcs.
12:48:40 <kombinator> Is it possible to print lexical stack which led to <<loop>> ?
12:50:19 <monochrom> I hope someone knowing the ghc debugger will answer.
12:52:59 <sjanssen> kombinator: it's very hard to get stack traces out of ghc -- the lazy evaluation strategy makes it difficult
12:53:11 <sjanssen> as monochrom hints, the new debugger might be able to do this
12:53:46 <Heffalump> @seen kowey
12:53:46 <lambdabot> kowey is in #darcs and #haskell. I don't know when kowey last spoke.
12:54:05 <kowey> hi, Heffalump
12:54:05 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
12:54:10 <Heffalump> 'lo
12:54:28 <Heffalump> your randomiser thingy will not be brilliantly random if the list rs has duplicates
12:54:49 <Heffalump> it also depends on the elements being Ord which it ought not to (though that shouldn't be so hard to fix)
12:54:51 <Lemmih> Better stack traces were initially planned but dropped later on, as far as I know.
12:55:59 <kowey> oh! thanks... it's good enough for my needs, but I'd be curious to see if there was a nice short way to express it that's more random
12:56:00 <ihope> What's the fixity of ->?
12:56:14 <Lemmih> For now the development on the GHC debugger seems to be focused on breakpoints and printing closures.
12:56:42 <kowey> (i really ought to read that perfect shuffle thing someday, i guess)
12:58:03 <kowey> i guess the reason it's good enough is that i only have < 100 things to unsort
12:59:11 <monochrom> -> is infix right-associative. I don't know if it needs a precedence to compete with other type constructors.
12:59:47 <ddarius> GHC does allow you to define arbitrary infix type constructors I'm fairly certain.
13:00:00 <ddarius> But otherwise, I think there is nothing for it to conflict with.
13:00:12 <ddarius> Unlike ugly ugly *ML
13:01:14 <Heffalump> kowey: well, it depends on how much you care about absolute perfection
13:01:24 <Heffalump> ihope: maximum binding strength
13:01:48 <ihope> Second only to juxtaposition?
13:02:31 <ihope> (At least, I think that's called juxtaposition...)
13:03:00 <ihope> Now, there's probably some good reason "a -> forall b. a" isn't a valid type, isn't there?
13:03:53 <monochrom> It is invalid for rank-1 polymorphism, e.g., HM. It is valid for rank-2 polymorphism.
13:04:12 <ihope> HM?
13:04:14 <Igloo> How is it different to a -> a?
13:04:17 <monochrom> Oh wait. forall b. (something without b). OK, I don't know.
13:04:28 <ihope> Igloo: it isn't very.
13:04:34 <ihope> Maybe it plain old isn't.
13:05:32 <Heffalump> sorry, I meant minimum binding strength.
13:05:39 <Heffalump> juxtaposition is maximum
13:07:13 <kowey> Heffalump: well... in theory I _ought_ to welcome the intellectual exercise thereof :-)
13:07:29 <kowey> although, does this mean I can feel less silly about my initial array swapping version?
13:08:40 <ndm> ihope: hindley milner
13:09:28 <Heffalump> I didn't read that, it looked long
13:09:30 <ihope> Ah, right.
13:09:38 <Heffalump> and ugly :-)
13:09:40 * Heffalump is lazy
13:09:42 <kowey> aye
13:09:46 <ihope> Does anybody know of a command like switch or something I can use to make "a -> forall b. a" valid?
13:09:58 <Heffalump> ihope: why do you want it?
13:10:09 <Heffalump> doesn't -fglasgow-exts work, anyway, with a few brackets?
13:10:19 <mnislaih> is there any stuff for lexing in base, apart from Text.Read.Lex? I'm looking for the equivalent of trim in other languages
13:10:24 <Heffalump> (I guess forall b . may be an exception to the minimum precedence of ->)
13:10:28 <ihope> Add brackets and it works?
13:10:36 * Heffalump is guessing
13:10:45 <Heffalump> it might just object cos it's nonsensical
13:11:11 <Heffalump> Prelude> :t undefined :: a -> forall b . a
13:11:12 <Heffalump> undefined :: a -> forall b . a :: forall a. a -> a
13:11:15 <kowey> anyway, thanks for pointing that out... good night
13:11:16 <Heffalump> that's in ghci -fglasgow-exts
13:11:46 <Heffalump> as you can see, it thinks it's nonsensical and removed it :-)
13:11:54 <ToRA> @type id :: (a -> forall b . a)
13:11:56 <lambdabot>     Couldn't match expected type `forall b. a'
13:11:57 <lambdabot>            against inferred type `a' (a rigid variable)
13:12:13 <ihope> Hmm.
13:12:40 <ihope> Continue this sequence: S, M S, M . M S, (M .) . M . M S.
13:13:32 <Heffalump> @pl m (m (m (m s)))
13:13:32 <lambdabot> m (m (m (m s)))
13:13:46 <Heffalump> @pointfree m (m (m (m s)))
13:13:46 <lambdabot> Unknown command, try @list
13:13:48 <ToRA> @type id :: (forall a . (forall b . a) -> forall b . a)
13:13:51 <lambdabot> (forall a . (forall b . a) -> forall b . a) :: forall a. (forall b. a) -> a
13:13:58 <ToRA> ok, now that's odd...
13:14:15 <ihope> @pl \s -> m (m (m (m s)))
13:14:15 <lambdabot> m . m . m . m
13:14:47 <Heffalump> oh, ok.
13:14:59 <Heffalump> ((M .) .) . (M .) . M . M S
13:15:21 <DRMacIver> Ick. :)
13:16:21 <Heffalump> I'm not sure if that can even type check.
13:16:28 <Heffalump> Well, not without a rank-2 type, anyway.
13:17:03 <DRMacIver> GHCI complains about constructing the infinite type c = a -> c
13:17:04 <ddarius> Heffalump, ihope: It moves the forall b out and then drops it.  It's not a rank-2 type, but it requires -fglasgow-exts to allow the explicit foralls
13:17:47 <ihope> Indeed, Heffalump has it.
13:18:35 <ihope> @type \x -> x x :: (forall a. a -> a) -> a -> a
13:18:38 <lambdabot>     Occurs check: cannot construct the infinite type:
13:18:38 <lambdabot>       t = t -> (forall a1. a1 -> a1) -> a -> a
13:18:42 <ihope> Bah.
13:18:46 <Heffalump> ddarius: right, that was what I thought
13:18:53 <Heffalump> my rank 2 type was referring to ihope's sequence
13:18:56 <ihope> @type (\x -> x x) :: (forall a. a -> a) -> a -> a
13:18:58 <lambdabot> (forall a. a -> a) -> a -> a :: forall a. (forall a1. a1 -> a1) -> a -> a
13:19:03 <ihope> Better.
13:19:25 <ddarius> I was responding to earlier.
13:19:31 <ihope> @type \m s -> ((m .) .) . (m .) . m . m s
13:19:33 <lambdabot> forall b a. (b -> a -> b) -> b -> a -> a -> a -> a -> b
13:19:38 <ihope> Isn't that fun?
13:19:42 <Heffalump> I think we're all in violent agreement here :-)
13:19:51 <Heffalump> ihope: ah, ok, no rank-2 types in sight.
13:19:51 <ihope> Seems so to me.
13:21:17 <matthew-_> is there something wrong with the way I ask questions on -cafe? I don't understand why no one replies.
13:21:38 <earthy> matthew-: maybe the question isn't all that interesting?
13:21:45 <earthy> maybe people are enjoying a long weeknd?
13:21:47 <earthy> +e
13:22:10 <matthew-_> earthy: how can the question not be interesting? It's about types!!
13:22:29 <matthew-_> mmm. I /might/ accept the weekend arguement, but that supposes people have other things to do.
13:22:45 * matthew-_ grumbles to himself.
13:22:47 <ddarius> Don't worry, no one listens to me either.
13:23:19 <matthew-_> it's just as well #haskell exists - I seem to get much better results asking here
13:23:57 <matthew-_> Maybe I'll try to corner SPJ an the london HUG on weds...
13:27:40 <Heffalump> noone ever answers my interesting (to me) questions here, I think I need to use haskell-cafe :-)
13:27:47 <earthy> ;)
13:28:03 <byorgey> Hrm... my installation of GHC can't seem to find Control.Monad.Error...
13:28:03 * earthy hasn't got stellar results on either avneue. :)
13:28:06 <Heffalump> but while I'm moaning, I'll ask it again.
13:28:12 <earthy> byorgey: you don't have the mtl installed
13:28:20 <byorgey> ah, ok
13:28:24 <byorgey> where can I find that?
13:28:29 <Heffalump> does a function of type (MonadTrans t, Monad m1, Monad m2) => (m1 a -> m2 a) -> (t m1 a -> t m2 a) exist?
13:28:50 <Heffalump> and if not, what is it about a monad transformer that makes it possible to write such a function for a specific t?
13:28:51 <earthy> hackage, or the haskell-extra-libs (or ghc-extra-libs?) tarball on the ghc download site
13:28:52 <byorgey> n/m, I'll figure it out =)
13:29:02 <byorgey> ok, thanks
13:30:36 <byorgey> earthy: do you happen to know if there's a Debian/Ubuntu package for it?
13:30:46 <Heffalump> in Debian it's libghc6-mtl-dev
13:30:55 <Heffalump> oh, and that reminds me, I need to install the docs for that on my laptop
13:30:59 <byorgey> ok, thanks
13:32:26 <sjanssen> matthew-_: why don't you make the 'b' parameter an associated type?
13:32:30 <Heffalump> see, still noone answers my question!
13:32:40 <ToRA> Heffalump: i'm thinking about it
13:32:40 * Heffalump feels all unloved ;-)
13:32:47 <Heffalump> oh good :-)
13:33:04 * earthy is thinking
13:33:14 <earthy> it *looks* as though it's a s'simple' lift
13:33:21 <Heffalump> really?
13:33:31 <earthy> but I'm not quite sure
13:33:32 <ToRA> your question is is impossible to write in the general case, but possible for specific t's?
13:33:43 <ToRA> *is: is it impossible to write...
13:33:59 <earthy> it should be possible for all t such that t is a functor
13:34:00 <Heffalump> I'd like either a definition in the general case, or an explanation of why it's impossible and a characterisation of the special cases where it is possible.
13:34:14 <Heffalump> But any answers in the general direction of what I'd like would be nice :-)
13:34:29 <Heffalump> treating t as a functor isn't kind correct
13:34:31 <earthy> at least, it looks like it should
13:34:34 <ToRA> but MonadTrans != Functor
13:34:34 <earthy> hef: I know
13:34:41 <Heffalump> unless I'm confused about how general functors are
13:35:35 <ToRA> if you think about the form of the implementation of that function, it'll take (\m1atom2afn tm1a -> unwrap tm1a, apply m1atom2afn, lift result)
13:36:06 <Heffalump> right. So for example I know how to do it for StateT.
13:36:13 <Heffalump> at least I think I do
13:36:29 <ToRA> right, but StateT is also a monad
13:36:34 <ToRA> and that gives you liftM
13:36:37 <Heffalump> but every monad transformer is a monad
13:36:39 <ToRA> (and also fmap from Functor)
13:36:56 <Heffalump> well, can be made into a monad by applying to Id
13:36:59 * earthy ponders
13:37:00 <Heffalump> StateT isn't a monad per se
13:37:33 <davidL_> can I filter a list with the condition (mod x 5 /= 0) *without* using a lambda such as (\x -> mod x 5 /= 0)?
13:37:52 <earthy> ((m1 a) -> (m2 a)) -> ((t (m1 a)) -> (t (m2 a))  is simple
13:38:04 <Heffalump> that looks kind incorrect too
13:38:05 <mauke> @pl (\x -> mod x 5 /= 0)
13:38:05 <lambdabot> (0 /=) . flip mod 5
13:38:15 <ToRA> Heffalump: Monad m => Monad (StateT s m), it's not per-se, but in any case where it's useful, it is
13:38:25 <mauke> a.k.a. (0 /=) . (`mod` 5)
13:38:27 <Heffalump> ToRA: but that's what it means to be a MonadTrans
13:38:35 <earthy> but you were asking about ((m1 a) -> (m2 a)) -> (((t m1) a) -> ((t m2) a))
13:38:41 <Heffalump> @info MonadTrans
13:38:41 <lambdabot> MonadTrans
13:38:43 <davidL_> thanks mauke
13:39:38 <Heffalump> igloo: btw, I can't actually find the mtl docs in Debian. Am I missing something?
13:39:59 <Igloo> Heffalump: Do you have libghc6-mtl-doc installed?
13:40:00 <ToRA> Heffalump, your constraint list doesn't include that (t m1) is a monad from the type system point of view, so you can't write liftM / fmap in the general case to do the unwrap and apply part of the implementation
13:40:03 <Heffalump> Igloo: does it exist?
13:40:11 <Igloo> Heffalump: In unstable, yes
13:40:19 <Heffalump> ah. What about stable?
13:40:24 <Igloo> Nope
13:40:45 <Heffalump> ToRA: hmm, true. OK, You can add Monad (t m1) and Monad (t m2)
13:40:46 <Heffalump> does that help?
13:41:37 <Heffalump> I think that's a deficiency in the spec of MonadTrans, though one that may not be rectifiable within the language
13:41:58 <Heffalump> Igloo: ok, ta
13:42:40 <ToRA> Heffalump: aah...yeah.  I think i see a problem with my reasoning
13:42:57 * ToRA thinks
13:46:44 <cinimod> @msg
13:46:45 <lambdabot> Not enough privileges
13:47:28 <sioraiocht> anyone here in the UK and use Vodafone for their mobile?
13:50:52 <mux> how am I supposed to handle uint32_t types in C when doing FFI bindings with haskell?
13:51:01 <Heffalump> Word32?
13:51:04 <mux> Int won't be big enough, should I go for Integer?
13:51:07 <mux> ah yeah, right.
13:51:15 <mux> silly me, I asked that one already
13:51:20 <mux> there's a slight problem though
13:51:37 <mux> Word32 isn't Foreign.C.Types area though
13:52:00 <mux> for instance, is there a Storable instance for it?
13:52:05 <mux> @instances Word32
13:52:06 <lambdabot> Couldn't find class `Word32'. Try @instances-importing
13:52:09 <mux> err
13:52:12 <mux> @instances Storable
13:52:13 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
13:52:22 <monochrom> there is UInt iirc
13:52:35 <monochrom> Excuse, CUInt
13:52:44 <mux> yes, but it's not an uint32_t
13:53:27 <Heffalump> can you follow the chain of typedefs that actually define uint32_t to get the right Haskell type?
13:53:36 <Heffalump> I guess that'd be tricky.
13:54:04 <Heffalump> I guess you could use CPP to look at the sizeof
13:54:08 <mux> that would be c2hs material
13:54:18 <mux> and I don't think it does that, I could be wrong
13:54:26 <monochrom> I see. You will need to make platform assumptions.
13:54:37 <mux> mmm, apparently Word32 is an instance of Storable
13:54:44 <mux> I'll try it, maybe it'll just work nice
13:54:52 <mux> even if it's not really good semantically speaking
13:57:33 <ddarius> Just to say, I believe a monad transformer is a functor (albeit maybe not a Haskell one).
14:00:46 <byorgey> @pl (\(x,y) -> (y,x))
14:00:46 <lambdabot> uncurry (flip (,))
14:03:50 <monochrom> Fun. Let me calculate whether a monad transformer is a functor.
14:04:45 <Heffalump> sadly I have to go to bed shortly.
14:04:56 <Heffalump> But do Heffalump at me if you figure out something of interest :-)
14:06:17 <ToRA> Heffalump, at the very least i think you need to relax the function sig to something like:  (Monad m1, Monad m2) => (forall a . m1 a -> m2 a) -> (t m1 x -> t m2 x) to make any progress
14:06:54 <ToRA> (i don't see how you can implement the StateT version without the forall a. on the first arg)
14:07:18 <monochrom> Damn, first of all it is unclear what is a morphism between two monads.
14:07:37 <mux> mmm, apparently c2hs resolves u_int32_t into CUInt which is quite bad
14:08:03 <mux> it doesn't let me use Word32, and thus it would fail to build on anything where this is not an unsigned int
14:13:04 <Heffalump> ToRA: oh, sorry, that's right
14:13:11 <Heffalump> being careless.
14:15:36 <ddarius> monochrom: If you even want to hope for a Haskell functor it would be best to forget the monad structure and consider merely natural transformations between (endo)functors (i.e. polymorphic functions)
14:15:54 <matthew-_> drat, sjanssen disappeared
14:16:20 <ddarius> monochrom: But a monad morphism is just a natural transformation that makes return and join still work out.
14:16:55 <ToRA> @type (\fn stateT -> StateT (fn . runStateT stateT)) -- Heffalump is that what you had for StateT?
14:16:58 <lambdabot> forall s (m :: * -> *) a (m1 :: * -> *) a1. (m (a, s) -> m1 (a1, s)) -> StateT s m a -> StateT s m1 a1
14:20:46 <Heffalump> something like that, yes
14:21:06 <ddarius> monochrom: I believe the equations for preservation of join are: f . join = join . fmap f . f = join . f . fmap f
14:21:18 <Heffalump> perhaps it's just a question of being able to extract the underlying representation using some run operation
14:21:20 <ddarius> Where f : M -> N
14:21:54 <Heffalump> that was some of my intuition, but I can't quite see whether that's generally applicable or not
14:21:56 <ddarius> I -think- the answer to your question is: no, there isn't a general solution.
14:22:25 <Heffalump> it might be that with associated types, we can make a souped up MonadTrans where it is possible, and that all existing transformers fit into
14:22:44 <Heffalump> (associated types so you can express the "underlying type" as something concrete)
14:23:07 <ddarius> I think not because I believe there are multiple reasonable ways of lifting to a transformer for some combinations.
14:23:16 <bringert> dcoutts: cabal-install depends on HTTP>=1&&<2, I think it should be >=3000.0.0
14:23:21 <Heffalump> but I don't think it's quite that easy, because \s -> m (a, s) and m [a] only share structure in a complicated way
14:23:31 <dcoutts> bringert: right'o
14:23:39 <bringert> dcoutts: 1.0 is a previous version
14:23:58 <dcoutts> bringert: you've got commit rights
14:24:09 <Heffalump> I think this probably does call for a haskell-cafe post.
14:24:31 <Heffalump> especially since a few of you have thought about it and not come up with a complete answer, so it's worthy of further discussion :-)
14:24:56 <bringert> dcoutts: ok, will fix. just wondering if there we any problems with 3000.0.0, apart from the silly number
14:25:11 <monochrom> I personally prefer research to discussion.
14:25:35 <dcoutts> bringert: the 3000.0.0 and 1.0 versions were exactly the same except for the version number. I checked with diff.
14:26:00 <bringert> dcoutts: ah, ok. I didn't remember that
14:27:32 <Heffalump> anyway, must go to bed now
14:27:51 <ddarius> Heffalump: I'm pretty sure it's been thought about before and has been partially resolved or a similar thing has been partially resolved.
14:29:50 <Heffalump> ok, I'll search a bit first, then.
14:29:53 <Heffalump> <gone>
14:31:55 <matthew-_> sjanssen: I'm trying that, but can't see it working
14:32:33 <matthew-_> sjanssen: I need b as a class param too in order for other parts to work - though I can drop the fundep from a -> b
14:33:45 <sjanssen> matthew-_: I think it's unsafe without the fundep
14:35:32 <matthew-_> well, you can't write class F a b | a -> b where type BThing a :: *; instance F a b where type BThing a = b
14:35:41 <matthew-_> you get the same again - b not in scope
14:37:37 <matthew-_> now sure, you wouldn't generally instance F a b, but in my case, it's not ground types, it's just types constrained by the context on F so instance (G a b) => F a b where ...
14:37:43 <sjanssen> matthew-_: I think the scoping is necessary for safety purposes
14:38:00 <sjanssen> matthew-_: you could write an unsafe type cast with that
14:38:18 <davidL_> @hoogle Maybe a -> a
14:38:19 <lambdabot> Maybe.fromJust :: Maybe a -> a
14:38:19 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
14:38:19 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
14:38:35 <sjanssen> cast :: (F a b, F a c) => b -> c -- is possible
14:38:48 <sjanssen> (without the fundep, that is)
14:39:02 <matthew-_> sjanssen: using (ultimately) unsafeCoerce# ?
14:39:14 <sjanssen> matthew-_: no, just pattern matching
14:39:36 <sjanssen> oh, nevermind
14:39:59 <sjanssen> you could do it with an associated _data_, not type
14:40:15 <matthew-_> sjanssen: eh? That's what I've been trying!
14:40:55 <sjanssen> matthew-_: where 'it' is an unsafe type cast
14:41:12 <matthew-_> right.
14:41:35 <matthew-_> Currently I have it working using just fundeps but with one unsafeCoerce. I was hoping that associated/indexed types would allow me to get rid of the unsafe coerce.
14:42:08 <sjanssen> but you're trying to write a safe coercion, right?
14:42:21 <sjanssen> you're just having trouble proving that it's safe?
14:42:56 <matthew-_> I'm trying to hide a dependent type in some container such that I can safely unpack it later and recover the type
14:43:42 <matthew-_> yes, I think you're description is right
14:43:48 <matthew-_> grr, your, not you're
14:45:27 <sjanssen> matthew-_: http://hpaste.org/1915
14:46:36 <sjanssen> matthew-_: if the compiler put 'b' in scope, you could write that evil cast
14:46:42 <matthew-_> ahh.
14:46:47 <matthew-_> that's interesting
14:46:54 <matthew-_> why is that evil?
14:47:32 <sjanssen> umm, because it's a function (forall a b. a -> b)
14:48:04 <matthew-_> ahhhh!
14:48:09 <matthew-_> sorry, I'm being dumb
14:48:17 <matthew-_> I was reading that code as if it would work!
14:48:48 <matthew-_> ok, but with the fundep a -> b, it is safe
14:48:55 <sjanssen> somewhat
14:49:51 <matthew-_> as in - it would be if it was a closed class?
14:52:36 <sjanssen> I'm not sure
14:52:51 <sjanssen> I do know that GHC doesn't rely on fundeps in situations like this
14:53:56 <sjanssen> is there any reason you can't push 'b' into an associated type?
14:54:26 <matthew-_> yes
14:55:17 <matthew-_> the situation is complex. The class is actually class CB c t n | c -> t n where...
14:55:40 <matthew-_> I want data C c :: * and then the ability to store n in it
14:56:06 <matthew-_> but n is actually an instance of CB itself, unwrapped, eg CB n t' n' ...
14:56:28 <matthew-_> so if I push n into data C c n :: * then n unwraps infinitely and I can't express it
14:56:44 <matthew-_> I bet that's as clear as mud
14:57:47 <matthew-_> it's like the type level list
14:58:24 <Spark> i have to go back to college tommorow :(
14:58:54 <Spark> i could just quit my phd and become a drug using hippie
14:58:58 <Spark> it's suprisingly tempting
14:59:22 <matthew-_> Spark: yeah, I won't be in!
15:00:13 <Spark> it's a hard life
15:06:00 <matthew-_> sjanssen: err, hang on, I'm trying to write it out simply
15:06:55 <IvdSangen> @src Functor
15:06:55 <lambdabot> class  Functor f  where
15:06:55 <mux> how am I supposed to call a foreign function given a FunPtr ?
15:06:55 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:08:17 <mux> @hoogle FunPtr a -> IO a
15:08:21 <lambdabot> No matches, try a more general search
15:10:53 <mux> mm, seems I should use a dynamic import stub
15:14:40 <matthew-_> sjanssen: http://hpaste.org/1916
15:20:34 <sjanssen> matthew-_: you're reusing the 'FDC' name, you can't do that
15:20:58 <matthew-_> grr. damn it, that's what happens when I don't test code!
15:21:10 <matthew-_> ok, that FDC should be FDC'
15:21:13 <sjanssen> okay
15:22:47 <sjanssen> hmm, what does that error message mean?
15:23:00 <matthew-_> dunno
15:23:23 <matthew-_> could well be a bug in the current implementation
15:25:20 <metaperl> dons: that is really quite an impressive amount of work to open a file and sum it's contents - http://shootout.alioth.debian.org/debian/benchmark.php?test=sumcol&lang=ghc&id=0
15:25:22 <metaperl> :)
15:25:22 <lambdabot> Title: sum-file Haskell GHC program | Debian : AMD&#8482; Sempron&#8482; Computer Langu ..., http://tinyurl.com/2w9jzc
15:25:48 <matthew-_> sjanssen: but that's not the main problem
15:27:08 <matthew-_> sjanssen: the annotated version is the real problem
15:34:36 <Jedai> metaperl: But it's the fastest program
15:35:03 <metaperl> Jedai: everything has its pros and cons I suppose
15:36:06 <Jedai> This one is prettier (but slower) : http://shootout.alioth.debian.org/debian/benchmark.php?test=sumcol&lang=ghc&id=3
15:36:09 <lambdabot> Title: sum-file Haskell GHC #3 program | Debian : AMD&#8482; Sempron&#8482; Computer La ..., http://tinyurl.com/26axuc
15:36:52 <metaperl> Jedai: I'm doing the examples in J - here is sum-file in j - clean version - http://hg.metaperl.com/alioth?f=7c36d38c8e1e;file=sum-file;style=raw
15:36:56 <lambdabot> http://tinyurl.com/27h4ty
15:37:15 <metaperl> Jedai: and version by an advanced j'er - http://hg.metaperl.com/alioth?f=406234df3828;file=sum-file.raul;style=raw
15:37:18 <lambdabot> http://tinyurl.com/yqqt82
15:39:37 <Jedai> metaperl : But doesn't your program slurp stdin ? It's explicitly forbidden by the rules
15:39:51 <metaperl> Jedai: yes, I currently am in violation of the spec :)
15:39:58 <metaperl> I think the advanced version would confuse most people :)
15:40:04 <metaperl> i'm asking about that on the mailing list now
15:40:43 <Jedai> Note that the Haskell versions don't do that since they're reading lazily.
15:45:48 <metaperl> mattrepl? an anagram of metaperl (almost) :)
15:50:51 <davidL_> > intersectBy (\(x,y) p -> x == p) [(1,1),(4,2),(11,3),(7,4)] [3,5,7,11]
15:50:52 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
15:50:52 <lambdabot>       Expe...
15:51:22 <davidL_> :(
15:53:47 <mauke> :t intersectBy
15:53:49 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
15:55:22 <davidL_> I want to intersect by the first number of the pairs
15:57:48 <mauke> > catMaybes (map (flip lookup [(1,1),(4,2),(11,3),(7,4)]) [3,5,7,11])
15:57:50 <lambdabot>  [4,3]
15:58:18 <davidL_> ?t catMaybes
15:58:18 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
15:58:28 <davidL_> ?ty catMaybes
15:58:30 <lambdabot> forall a. [Maybe a] -> [a]
15:58:39 <mauke> > catMaybes (map (\k -> fmap ((,) k) $ lookup k [(1,1),(4,2),(11,3),(7,4)]) [3,5,7,11])
15:58:39 <Saizan> ?ty lookup
15:58:40 <lambdabot>  [(7,4),(11,3)]
15:58:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
15:59:00 <timthelion> wtf, I have Char.isUpper in a .hs file that I load in ghci, and it says not in scope, but if I just run Char.isUpper in the interactive prompt it works?
15:59:05 <davidL_> that is amazing
15:59:14 <mauke> timthelion: yes
15:59:22 <timthelion> why
15:59:26 <timthelion> how do I fix it?
15:59:29 <Saizan> timthelion: in your file you have to import Data.Char
15:59:52 <timthelion> oh, that's silly
16:00:14 <Saizan> timthelion: no, it's ghci that's unproperly smart :)
16:00:56 <Saizan> well ghci is able to load new modules while running, but think of a compiled binary, it has to be linked with the library.
16:02:03 <Saizan> with import Data.Char you can just use isUpper without the module part
16:03:30 <davidL_> thanks mauke
16:09:10 <ndm> @seen dons
16:09:11 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 10h 39m 7s ago.
16:18:55 <timthelion> so why does emphasisword a = if isUpper (head a) then a : "<h1>" else a not work? it says     Couldn't match `[Char]' against `Char'
16:19:07 <timthelion> but the type of a should be agnostic no?
16:22:22 <mauke> is a supposed to be a Char or a [Char]?
16:22:34 <timthelion> it's supposed to be a string
16:22:39 <timthelion> like if Char.isUpper (head "Hello") then "Hello" : "<h1>" else "Hello"
16:22:43 <mauke> then a : "<h1>" is wrong
16:22:50 <mauke> > "Hello" : "<h1>"
16:22:57 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:23:07 <timthelion> how does that work?
16:23:18 <mauke> the type of (:) is a -> [a] -> [a]
16:23:19 <timthelion> doesn't : concatinate?
16:23:22 <mauke> no
16:23:25 <ari> > "Hello" ++ "<h1>@
16:23:25 <lambdabot>  Improperly terminated string
16:23:26 <mauke> that's (++)
16:23:26 <ari> > "Hello" ++ "<h1>"
16:23:27 <lambdabot>  "Hello<h1>"
16:24:06 <qwr> mauke: head wants a list
16:24:09 <qwr> :t (:)
16:24:11 <lambdabot> forall a. a -> [a] -> [a]
16:24:13 <george--> hi, I have a haskell exam coming up soon and one question in a past paper: why is laziness a problem for IO and other 'phenomena' which involve side effects? I think i understand this but the next question i need some help:
16:24:33 <qwr> :t head
16:24:35 <lambdabot> forall a. [a] -> a
16:24:36 <george--> outline how haskell has solved the previously mentioned problem, mentioning the relevant type and basic operations
16:24:38 <qwr> :t "a"
16:24:40 <lambdabot> [Char]
16:24:56 <george--> could anyone tell me how haskell has solved laziness in IO?
16:25:06 <ari> george--: Magnets!
16:25:14 <ari> george--: I mean... monads!
16:25:41 <george--> so i know haskell uses monads for IO
16:25:49 <qwr> by moving IO out of your sight ;)
16:25:54 <ari> george--: I found http://haskell.org/haskellwiki/IO_inside rather enlightening
16:25:55 <lambdabot> Title: IO inside - HaskellWiki
16:26:08 <george--> i will read this and see if i have questions ;)
16:26:55 <qwr> monads are just a way to make IO actions, from which you can't take actual values out
16:27:04 <Saizan> in your question IO refers to Input/Output, rather than the IO monad, right?
16:27:12 <mauke> george--: haskell cheats.
16:27:36 <george--> my main problem is to me... the benefit of laziness is passing a list like [1,2..] (i dont remember exact syntx but an infinite size list)
16:27:52 <george--> if i knew it was never going to for example evaluate the size of the list
16:27:53 <mauke> a haskell program doesn't perform I/O itself; instead it constructs an imperative program that is then interpreted by the haskell runtime
16:28:01 <george--> it was just going to do operations on the first few elements
16:28:10 <george--> then i could pass around this infinite list
16:28:12 <gravity> george--: You can do that with IO as well
16:28:14 <george--> that is how i have understood laziness
16:28:24 <mauke> yes
16:28:26 <gravity> george--: Just imagine it as an infinite list of IO events
16:28:32 <george--> ok
16:28:42 <george--> and that eans the program never terminates
16:28:44 <george--> which is bad?
16:29:01 <george--> apologies.. my 'm' key is bad... i may repeatedly miss m's
16:29:07 <mauke> no, the problem with mixing side effects and laziness is that you don't know when (and if) a side effect really happens
16:29:40 <george--> care to give an example?
16:29:47 <gravity> The program can terminate. The same way most event loops in imperative programs are infinite loops that you exit out of when you're finished
16:29:48 <mauke> take an OCaml function like print_char
16:29:59 <ari> george--: Passing around infinite lists is one thing that you can do with laziness, but it's healthier to think laziness as considering the output of the program (or any one function) and going backwards from it toward the computations that you need to find out the output
16:30:01 <mauke> it takes a char, prints it, and returns nothing
16:30:24 <mauke> in a lazy language the call to print_char is not evaluated until you look at the result
16:30:34 <mauke> the problem: there is no result
16:31:43 <qwr> it wouldn't be much better, if there were result :P
16:32:00 <george--> sorry what is OCaml ?
16:32:25 <mauke> OCaml is a strict functional language
16:32:59 <mauke> it's roughly similar to haskell but it has side effects
16:33:29 <pjd> mauke: that's not really a problem;  such a result is just the empty tuple
16:33:29 <timthelion> >(\x.x)(4)
16:33:34 <timthelion> > (\x.x)(4)
16:33:34 <lambdabot>  Parse error
16:33:55 <pjd> the problem is not knowing when, or in what order, it will get evaluated
16:34:15 <george--> i dont see how this manifests
16:34:15 <timthelion> what's wrong with my lambda?
16:34:33 <mauke> pjd: evaluating a tuple is simple (and there's only one order in which it can happen)
16:34:36 <qwr> > (\x -> x) 4
16:34:44 <lambdabot>  4
16:36:41 <qwr> george--: read2chars () = let a = readchar() in let b = readchar() in (a, b)
16:37:11 <qwr> george--: now the result in lazy language would depend on which part of the tuple you happen to use first
16:37:49 <qwr> george--: because the readchar's wouldn't happen when you request the tuple
16:38:26 <mauke> worse, a compiler could fold all invocations of read2chars into the same tuple
16:38:51 <mauke> wait, that also applies to readchar
16:39:37 <qwr> yes, the compiler is free to optimise it to read2chars () = let a = readchar() in (a, a)
16:40:17 <timthelion> > (\x str -> x + str)(4 3)
16:40:18 <lambdabot>   add an instance declaration for (Num (t -> a))
16:40:25 <timthelion> hmm
16:40:37 <timthelion> nothing seems to work the way I think it does
16:40:58 <twanvl> > (\x str -> x + str) 4 3
16:41:00 <lambdabot>  7
16:41:16 <mauke> > ((\x str -> x + str) 4) 3
16:41:17 <lambdabot>  7
16:41:32 <qwr> > 4 3
16:41:33 <lambdabot>   add an instance declaration for (Num (t -> a))
16:41:33 <lambdabot>     In the expression: 4 3
16:41:33 <lambdabot>  ...
16:41:35 <qwr> :)
16:41:57 <george--> so if i understand this... our 'problem' is that the you expect it to evaluate a as the first keystroke and b as the second... but if haskell uses b before a then it is switched?
16:42:25 <mauke> yes
16:42:34 <george--> and this is what we refer to as a side effect?
16:42:43 <mauke> lazy evaluation means stuff can happen in an unpredictable order, or not at all
16:42:54 <mauke> a side effect is something that changes the state of the world
16:43:09 <mauke> e.g. changing the value of a variable would be a side effect
16:43:18 <ndm> a nice example is that in a strict language "head (sort xs)"
16:43:23 <mauke> or interacting with the outside world
16:43:29 <qwr> side effect is that readchar changes the state of the world - second readchar gives different result than the first one
16:43:39 <ndm> would require sorting _all_ the xs, in Haskell it only sorts enough to find the first, i.e. minimum
16:45:18 <pjd> george--: the simplest example i can think of is using a getChar function to read a list of characters from input
16:46:05 <george--> that is a side effect?
16:46:09 <george--> using getchar?
16:46:10 <pjd> yep
16:46:30 <george--> but surely 'side' effect is something like... unpurposeful?
16:46:39 <pjd> in a strict language, you'd get a list of, say, 'a', 'b', 'c', ...
16:46:40 <george--> getChar is MADE to get a char
16:46:40 <timthelion> qwr, but if I did {n x str = x + str} then n(4 3) would be correct
16:46:43 <timthelion> right?
16:46:54 <pjd> in the order they appear on input
16:47:12 <qwr> timthelion: you cannot apply to 4 - it is not a function
16:47:13 <pjd> in a lazy language, the getChars would get called in the order you *use the result*
16:47:26 <gravity> george--: Side effects aren't really things you don't do on purpose. In an imperative language, the entire design of the program is basically one side effect after another
16:47:30 <pjd> so if you consume the list from the end, you could get 'c', 'b', 'a'
16:47:32 <pjd> or any other order
16:47:37 <timthelion> qwr so haskell is like lisp then?
16:47:48 <qwr> timthelion: ( ) do not mean function arguments. they are just grouping
16:47:53 <pjd> or if you don't use the result, the getChars might not gt called at all
16:48:34 <mauke> george--: getChar returns a Char, and as a side effect changes the world so the next call will return the next char
16:48:39 <qwr> timthelion: (n 4) 3 would work. or n 4 3
16:48:46 <pjd> george--: in this context, "side effect" generally refers to any lack of referential transparency
16:48:59 <pjd> getChar has the side effect of taking a character out of the input buffer
16:49:05 <gravity> george--: If you have no side effects, you can make a function dependent soley on the inputs that you pass it. If you call getChar twice within a function (say callGetChar), callGetChar will produce a different result each time because getChar will produce a different result each time. So callGetChar isn't solely dependent on its inputs
16:49:16 <mauke> in C, x = y returns the value of y, and as a side effect changes the value of x
16:49:17 <pjd> that's why it returns a different character each time you call it
16:51:04 <vincenz_> mauke: it returns the value of x, not y
16:51:19 <vincenz_> mauke: very mportant when working with lvals
16:53:17 <mauke> vincenz_: how so?
16:53:17 <gravity> george--: So monads, among other things, provide a means of handling this problem by allowing you to encapsulate the side-effects in the monad
16:53:18 <vincenz_> int x = 1; int y =2; (x = y) = 3; =>
16:53:19 <vincenz_> x = 3
16:53:21 <vincenz_> y = 2
16:53:28 <mauke> vincenz_: I'm pretty sure that's illegal
16:53:32 <vincenz_> no it's not
16:53:37 <vincenz_> retval of operator = is T&
16:53:42 <mauke> it's definitely illegal
16:53:47 <vincenz_> it's definitely not
16:53:49 <mauke> let's see if it's a compile time error
16:53:58 <vincenz_> mauke: I don't even get a warning
16:54:11 <mauke> try.c:4: error: lvalue required as left operand of assignment
16:54:16 <mauke> get a better C compiler
16:54:34 <vincenz_> hmm
16:54:39 <vincenz_> maybe cause I'm using c++
16:54:55 <mauke> yeah, it compiles in C++. it's still illegal, though
16:55:01 <george--> i keep reading and re-reading what you said about callGetChar and i really dont follow it
16:55:03 <mauke> (violation of sequence point rules)
16:55:30 <vincenz_> mauke: hmm, good point
16:55:59 <pjd> george--: think of a normal non-lazy program
16:56:18 <MyCatVer1s> mauke: C++ might return a reference to y instead of the value of y in (x=y)?
16:56:22 <mauke> it would be valid if = was overloaded there
16:56:22 <gravity> george--: Try to think of a function in mathematical terms. A function always outputs the exact same thing when you pass it a certain input, no matter what.
16:56:22 <pjd> and imagine you lose the guarantee that everything is executed in strict sequential order
16:56:25 <vincenz_> mauke: anyways, what is returned is the reference to x, not y
16:56:32 <MyCatVer1s> mauke: (which'd make it legal, but still sick and wrong)
16:56:40 <pjd> functions could start evaluating from the end, in reverse
16:56:48 <pjd> or only half the function gets evaluated
16:56:49 <vincenz_> that's why all custom operator= return *this
16:56:53 <MyCatVer1s> Oh, x, right. Not y.
16:57:00 <pjd> or anything else
16:57:04 <mauke> pjd: are you sure he knows what a "normal non-lazy program" is?
16:57:04 <pjd> *that*'s the problem
16:57:06 <gravity> george--: If you use getChar(), you pass it no arguments. But depending on when you run getChar() you might get a totally different result, despite having passed the exact same thing in (nothing) each time
16:57:11 <phoniq> T& T::operator=(const T&rhs)
16:57:22 <pjd> mauke: i am hopeful :)
16:57:28 <gravity> george--: That's because the state of the world changed
16:57:37 <mauke> vincenz_: yeah, the difference is not observable in C
16:58:06 <qwr> george--: getChar() return value wouldn't be a function of its argument - which is ()
16:58:08 <gravity> george--: That state of the world changing bit is a side effect. It's something that happens externally to the function that's got nothing to do with what was explicitly passed to it that caused it to alter its output
16:58:40 <george--> 'state of the world' ? this is confusing me somewhat
16:58:48 <vincenz_> hmm
16:58:53 <gravity> george--: 'state of the world' == user types a key
16:58:54 <vincenz> mauke: made me wonder why you were talking to _
16:58:54 <vincenz> :)
16:58:59 <gravity> george--: Or you advance in reading the file
16:59:02 <qwr> george--: and always same. if it would, it would act as a function returning a constant, since it argument has only one possible value and is therefore practically a constant
17:00:17 <timthelion> is there a way to make ghci spit out what I need to import to get a method to work in a .hs file?
17:00:28 <george--> but getchar acts the same way... i pass it an 'n' twice and it returns an 'n' to my program
17:00:43 <george--> it doesnt return 'n' one time and 'b' another if i type n twice
17:00:47 <mauke> you don't pass getchar anything
17:01:00 <george--> i hit my kbd?
17:01:02 <mauke> getchar interacts with the outside world; it doesn't take data from your program
17:01:13 <qwr> george--: george-- kbd is not getchar argument :)
17:01:29 <george--> what is getchar argument?
17:01:33 <gravity> nothing
17:01:34 <qwr> george--: kbd is outside world
17:01:41 <timthelion> how do I find out what moduals I need to load to get something to compile?
17:01:49 <mauke> timthelion: read the docs?
17:01:58 <gravity> The c type would be char = getChar();
17:02:13 <mauke> er, what?
17:02:30 <timthelion> mauke: what do you mean, read the docs to find out what to load, or read the docs to find out how to find out?
17:02:34 <mauke> the real C getchar has the type int (void)
17:02:47 <gravity> mauke: The point being the ()
17:02:53 <mauke> timthelion: read the docs for the functions you want to use to find out where they're defined
17:03:23 <timthelion> mauke: don't rtfm me on this. this is something that should exist redilly in ghci
17:03:28 <george--> hmmm. ok apologies if my questions appear dense... i have only programmed before in VB ~4 years ago and now i have started to learn haskell
17:03:40 <mauke> timthelion: sorry, I only know how to do it in lambdabot
17:04:02 <george--> i just dont understand when you say it gets pased the sae thing twice and acts differently
17:04:06 <timthelion> and that is different than ghci?
17:04:26 <gravity> george--: Ok... functions have arguments. Right?
17:04:30 <psi> ?where getChar
17:04:31 <lambdabot> I know nothing about getchar.
17:04:31 <qwr> george--: the same thing is its argument which is nothing
17:04:42 <george--> yea
17:04:42 <psi> hm, not where...
17:04:47 <george--> functions have arguments
17:04:54 <gravity> george--: Those arguments are things that you explicitly pass to the function.
17:04:55 <timthelion> god  I hate it when the IRC bots for channels for software are better than the software they represent.
17:05:01 <george--> right
17:05:10 <gravity> george--: When you hit a button on the keyboard, it's not a function argument.
17:05:24 <george--> ok
17:05:36 <jbauman> timthelion: get GOA
17:05:49 <gravity> george--: So when you call getChar, you pass it no function arguments, ok?
17:05:53 <psi> timthelion: have you used hoogle?
17:06:04 <george--> ok
17:06:06 <gravity> george--: And it returns a character, whatver the user typed
17:06:11 <timthelion> yes, but I hate web bassed interfaces
17:06:44 <gravity> george--: That thing the user typed is entirely independent of the function arguments that were passed to the function
17:07:35 <george--> because none were passed to the function?
17:07:43 <gravity> george--: Yes
17:08:28 <gravity> george--: So the output of getChar changes depending entirely on things outside of the function arguments (the input to the function) and the function definition itself
17:08:41 <george--> ok
17:08:47 <gravity> george--: That's a side effect
17:09:00 <george--> ok
17:10:38 <george--> and why is laziness a problem for features which involve side effects?
17:11:30 <ddarius> george--: Essentially because people are stupid, but to a reasonable level.
17:15:51 <ddarius> Anyways, when we look at putChar, putChar doesn't return any value so I should be able to discard all uses of it.  Probably not what the programmer wants.
17:17:10 <MyCatVer1s> ddarius: except in the instance that s?he's been captured by the Spanish Inquisition and they've promised to drive one nail through the programmer's kneecaps for every byte of output that their program produces.
17:17:43 <MyCatVer1s> ddarius: probably out of scope, though. =)
17:17:59 <timthelion> the designers of haskell should have just made two languages, one flow logic one, and one functional logic one, and then we could just have the flow logic language handle all the IO and such, and let the functional one(called by the flow logic one) be functional
17:18:53 <ddarius> timthelion: Either (a) Haskell essentially did something along those lines or (b) it didn't but what we have is better because we have first class IO actions.
17:19:58 <timthelion> ddarius: if it where as simple as that, then why are there like 7 books devoted to the concept and all written in abstraction like it is some impossible concept?
17:20:00 * ddarius hates technology.
17:20:00 <MyCatVer1s> timthelion: I'd say the IO monad (and especially with the associated syntactic sugar) pretty much counts as having already done that.
17:20:23 <ddarius> timthelion: There are zero books written on IO in Haskell.
17:20:46 <timthelion> I've found quite a few, they are just online ones.
17:21:01 <ddarius> Online -books- dedicated solely to IO in Haskell?
17:21:10 <MyCatVer1s> timthelion: by accident, more or less. Using the IO monad to program in a straightforward imperative style is -trivially- easy to understand. You can actually ignore pretty much -all- the details of how it works and treat it as voodoo.
17:21:15 <QtPlatypus> ddarius: How meany tutorals are there dedicated  solely to IO in Haskell?
17:21:29 <monochrom> monad is a flow logic. arrow may be an even better flow logic.
17:21:47 <ddarius> QtPlaytpus: That's a different question, but some of them ensure that more will be written.
17:22:20 <MyCatVer1s> timthelion: whereas the really horrible scary voodoo is trying to explain how it works under the hood and how the abstraction is more generalised. Under the hood explainations are guaranteed to be difficult though, since it's basically the most cunning evil bastard of a continuation passing hack ever created.
17:22:23 <pjd> MyCatVer1s: it's hardly that much voodoo, even:  it's just a dumbed-down version of the State monad
17:23:04 <timthelion> MyCatVer1s: is it just a simple folding order hack?
17:23:19 <MyCatVer1s> pjd: that still a Hell of a lot when you've just come from a rather boring imperative background.
17:23:24 <ddarius> MyCatVer1s: There is no particular way IO is implemented.  In reality, it is mostly handled by treating it fairly abstractly.
17:24:09 <ddarius> The GHC implementation of IO is just bookkeeping, it doesn't actually -do- anything.
17:24:13 <mauke> I don't see IO as a variant of State
17:24:16 <MyCatVerbs> timthelion: kinda, maybe, I think. Ish? Best description I've heard of it was the most awesome continuation passing hack in the history of mankind.
17:24:26 <MyCatVerbs> ddarius: that's the sexy bit. ^^
17:24:33 <monochrom> http://www.haskell.org/haskellwiki/IO_inside  gives a story of under the hood. It's basically a flow story.
17:24:34 <lambdabot> Title: IO inside - HaskellWiki
17:24:38 <mauke> you can completely understand IO without knowing continuations or state passing
17:24:57 <ddarius> Indeed, because IO in Haskell is only defined at the level of the IO monad.
17:25:28 <timthelion> sorry, the only programing language I'm fluent in is elisp, and that is defiantly simple flow logic com paired to this do stuff
17:25:32 <MyCatVerbs> ddarius: (well, the IO monad would presumably be the most logical place to put things like your own PID, address space information and all that other bumf and information the OS hands you when your program is executed, no?)
17:26:02 <stmartin> Is there an equivalent to Perl's join() function in Haskell? I've seen Data.List.intersperse, but that's not appropriate for joining strings.
17:26:03 <MyCatVerbs> ddarius: not that you neccessarily would, but it's a nice mental model for it.
17:26:06 <monochrom> The flow logic of elisp is simpler and less general.
17:27:09 <ddarius> MyCatVerbs: Not really.
17:27:18 <mauke> stmartin: concat
17:27:25 <ddarius> join !
17:27:47 <mauke> perlJoin sep xs = concat (intersperse sep xs)
17:27:56 <MyCatVerbs> timthelion: the only FP I'd tried before Haskell was precalculation of values using C++ templates. I have a directory with around a half dozen or so semitrivial progams in my homedir which took days each to write and turned my skull inside out at the time. =)
17:28:13 <pjd> mauke: if you use the State monad to pass around a dummy value, minus any way of directly accessing it, you literally have the IO monad
17:28:22 <ddarius> MyCatVerbs: The C++ template language is a lazy pure functional language.
17:28:32 <pjd> (the dummy value representing the "state of the world", of course)
17:28:34 <mauke> pjd: too complicated
17:28:41 <mauke> I don't think of IO like that
17:28:46 <ddarius> pjd: Doesn't do concurrency well.
17:28:52 <stmartin> mauke: no, that's similar to join. I want to join a list of strings with another string. intersperse ',' on "abc" returns "a,b,c". I want something like join ", " ["abc", "cde"] to produce "abc, def"
17:28:54 <monochrom> If you say, why not have a flow language plus a functional language, the former surrounds the latter. The answer is yes, it is done. The surprise is that, the latter may also surround the former. I think your brain explodes because of that.
17:28:58 <MyCatVerbs> timthelion: so, having come from pretty much exclusively plain C, nah, no sympathy. =)
17:29:10 <mauke> stmartin: no, that's exactly the perl join
17:29:24 <mauke> > let perlJoin sep xs = concat (intersperse sep xs) in perlJoin ", " ["abc", "cde"]
17:29:25 <lambdabot>  "abc, cde"
17:29:52 <stmartin> How does that work?
17:29:59 <pjd> mauke, ddarius: modulo optimization, that's still what happens, though
17:30:11 <mauke> pjd: not really
17:30:17 <stmartin> :t intersperse
17:30:19 <lambdabot> forall a. a -> [a] -> [a]
17:30:21 <ddarius> pjd: Not necessarily.  And even in GHC it's just artifice.
17:30:21 <mauke> "what happens" depends on your haskell implementation
17:30:39 <pjd> ddarius: right, that's my point :)
17:30:47 <ddarius> > intersperse ", " ["abc", "def"]
17:30:48 <lambdabot>  ["abc",", ","def"]
17:31:03 <ddarius> > concat ["abc", ", ", "def"]
17:31:04 <lambdabot>  "abc, def"
17:31:04 <pjd> mauke: right, but many (most?) do it this way
17:31:13 <ddarius> pjd: No, just GHC.
17:31:19 <stmartin> Oh, that behaves differently than how I thought.
17:31:19 <mauke> pjd: I don't want to know that
17:31:19 <pjd> and if they don't you can still think about them this way
17:31:38 <mauke> pjd: why? it's complicated to think of IO actions as functions
17:31:48 <ddarius> pjd: You can to an extent, it starts to break down when you have concurrency.
17:32:18 <ddarius> pjd: And there is no necessity and little benefit to thinking this way.
17:34:02 <monochrom> How do you reason about IO?
17:34:12 <stmartin> mauke: thanks.
17:34:16 <ddarius> pjd: In fact the "world passing" model of IO is pretty crappy.
17:34:28 <stmartin> for some reason I thought intersperse worked only on characters.
17:34:49 <mauke> I think of IO as a tree type
17:35:01 <timthelion> there is getChar but no getString?
17:35:08 <monochrom> getLine
17:35:30 <mauke> getContents
17:35:37 <ddarius> readLine !
17:35:42 <mauke> readLn
17:35:49 <ddarius> Er yeah that.
17:35:57 <ddarius> Crazy inconsistency.
17:36:02 <monochrom> Pascal nostagia
17:36:42 <Philippa_> timthelion: think about it, how do you want that string to be got? getContents is one option...
17:37:31 <timthelion> I want the user to type in a line and press RET
17:40:40 <ddarius> getLine
17:43:02 <timthelion> hmm, main = do fname <- getLine and I moved the do down one line at the same indentation, and added a putStr "File to convert:" and now it doesn't work anymore: /home/timothy//haskell/espeak.hs:9:7: parse error on input `do'
17:43:35 <monochrom> I don't understand.
17:43:41 <mauke> what do you mean by "down one line at the same indentation"?
17:44:11 <timthelion> well, I have it so that the word do, is in the same collumn as it was before
17:44:29 <mauke> 1) always indent function bodies  2) always start a new line after do/where
17:44:44 <timthelion> it is indented.
17:45:29 <petekaz> are liftM and fmap the same?
17:45:39 <petekaz> ?src fmap
17:45:39 <lambdabot> Source not found. Take a stress pill and think things over.
17:45:39 <monochrom> Yes.
17:45:41 <timthelion> http://rafb.net/p/A19I6u64.html
17:45:41 <mauke> petekaz: basically, yes
17:45:42 <lambdabot> Title: Nopaste - No description
17:45:48 <petekaz> ?source fmap
17:45:48 <lambdabot> fmap not available
17:45:54 <mauke> timthelion: you didn't follow rule 2)
17:46:07 <mauke> also, that's a syntax error
17:46:15 <timthelion> how so?
17:46:21 <timthelion> and I don't get rule 2
17:46:29 <mauke> putStr "..." do ... is a syntax error
17:46:38 <timthelion> why?
17:47:06 <mauke> what is that supposed to do?
17:47:06 <ddarius> @pretty f = do c <- getChar; putChar c
17:47:07 <lambdabot>  f = do c <- getChar
17:47:07 <lambdabot>         putChar c
17:47:10 <ddarius> crappers
17:47:23 <monochrom> http://hpaste.org/1917
17:47:25 <mauke> timthelion: putStr takes only one argument anyway, so why is there a do after it?
17:47:29 <monochrom> http://hpaste.org/1917 for timthelion
17:47:40 <timthelion> it is supposed to print the text, and then prompt for a file name
17:47:42 <ddarius> timthelion: Look at any other code using layout (almost all multiline definitions) and compare it to what you wrote.
17:47:44 <monochrom> Alternative indentations from all of you welcome
17:47:46 <mauke> timthelion: http://hpaste.org/1918
17:48:21 <ddarius> blech monochrom
17:48:31 <ddarius> Do it mauke's way.
17:48:48 <monochrom> I like my way.
17:48:49 <timthelion> monochrom: thanks, that works
17:49:16 <timthelion> what is wrong with his?
17:49:20 <mauke> it's ugly
17:49:25 <mauke> non-even indentation, etc
17:49:28 <monochrom> But I believe stronger in showing all options.
17:49:30 <ddarius> monochrom: Until you want to rename an argument or add/remove one.
17:49:43 <mauke> also it breaks if you use tabs for indentation
17:50:04 <timthelion> ah, I see what you mean
17:50:06 <ddarius> It also leads to much deeper indentation and an indentation level dependent on the head of the function rather than consistent in all definitions.
17:50:28 <mauke> ddarius: <3
17:50:46 <monochrom> http://hpaste.org/1917#a2  is my answer to dependence.
17:51:05 <mauke> monochrom: eww
17:51:10 <monochrom> hahaha
17:51:20 <mauke> that combines the disadvantages of both methods
17:51:22 <monochrom> Learn to appreciate alternatives!
17:51:24 <ddarius> monochrom: Still deeper indentation and ugly.  If you do that you might as well do mauke's view.
17:51:35 <ddarius> monochrom: It also makes it harder to rearrange lines.
17:52:17 <ddarius> monochrom: Both styles are (I hope!) inconsistent with other uses of layout, I really doubt you do module Main (main) where bar = baz etc.
17:52:18 <monochrom> OK, that last reason convinces me.
17:52:31 <mauke> ddarius: you can
17:52:39 <mauke> you just have to indent the entire file
17:52:40 <timthelion> so do is like a thing that turns on flow logic no?
17:52:44 <monochrom> I mean the reason about rearranging lines.
17:52:49 <ddarius> mauke: I know but I haven't seet -anyone- do that.
17:52:54 <ddarius> monochrom: I understood
17:52:56 <mauke> I have :(
17:53:15 <ddarius> I have seen Ashley Yakely indent entire files, but he doesn't use layout at all.
17:53:18 <mauke> timthelion: do is syntactic sugar for calls to >> and >>=
17:54:49 <timthelion> ok
17:54:56 <timthelion> mmm sweet
17:55:22 <ddarius> @undo do c <- getChar; putChar c
17:55:23 <lambdabot> getChar >>= \ c -> putChar c
17:55:37 <ddarius> @. pl undo do c <- getChar; putChar c
17:55:37 <lambdabot> putChar =<< getChar
17:55:39 <timthelion> eww
17:55:47 <timthelion> without the sugar it's crap
17:56:03 <ddarius> timthelion: Actually it looks almost -exactly- the same without the sugar.
17:56:21 <mauke> 'do { X }' is X.  'do { v <- X; ... }' is X >>= \v -> do { ... }.  'do { let v = X; ... }' is let v = X in do { ... }.  'do { X; ... }' is X >> do { ... }.
17:56:47 <ddarius> Except when v is a pattern binding in v <- X
17:57:07 <monochrom> http://hpaste.org/1918#a1  translates do to >>=
17:57:09 <mauke> http://hpaste.org/1918#a2
17:57:11 <mauke> huhu
17:57:28 <monochrom> Why do I always win the race? :)
17:57:42 <mauke> 6 seconds
17:58:23 <monochrom> @quote stereo
17:58:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:58:47 <mauke> @quote race
17:58:47 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
17:58:48 <lambdabot> entire human race would have to be rewritten!
17:58:59 <timthelion> that's pretty bad for stereo,
17:59:05 <timthelion> 6 secconds...
17:59:18 <monochrom> But it's ok.
18:00:00 <timthelion> can you run a shell command from haskell/
18:00:13 <ddarius> monochrom: The good news now is that most of the recent history of the human race is stored on volatile media (relative to stone tablets).
18:00:27 <ddarius> timthelion: Sure.
18:00:41 <mauke> @hoogle String -> IO a
18:00:41 <lambdabot> Foreign.C.Error.throwErrno :: String -> IO a
18:00:41 <lambdabot> System.Win32.Types.errorWin :: String -> IO a
18:00:41 <lambdabot> System.Environment.withProgName :: String -> IO a -> IO a
18:00:57 <ddarius> @hoogle system
18:00:57 <timthelion> I searched hoogle for shell, and got nothing.
18:00:57 <lambdabot> System.system :: String -> IO ExitCode
18:00:57 <lambdabot> System :: module
18:00:57 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
18:01:03 <ddarius> @hoogle runInteractiveProcess
18:01:03 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
18:02:02 <monochrom> EEPROM ftw.  I actually possess one of those machines for shining UV at EEPROMs to erase them.
18:02:20 <ddarius> monochrom: Wouldn't the sun work?
18:02:25 <monochrom> Err I mean EPROM.  EEPROM the extra E means no need for UV.
18:02:35 <monochrom> The sun works. Takes 2 weeks I'm told.
18:02:46 <timthelion> so I could runInterativeProcess "/bin/bash" ("espeak -f " ++ fname ++ ".spk")
18:02:50 <timthelion> ?
18:03:14 <ddarius> Except that it takes a heck of a lot more arguments than that, yes.
18:03:14 <mauke> no
18:03:36 <ddarius> system maybe more suitable for this purpose
18:03:36 <timthelion> grr
18:03:40 <timthelion> too many args
18:03:51 <ddarius> @doc System.Process
18:03:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
18:03:55 <mauke> timthelion: more like rawSystem "espeak" ["-f", fname ++ ".spk"]
18:04:48 <ddarius> @hoogle rawSystem
18:04:48 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
18:05:05 <monochrom> Another fun fact. I have the machine to erase, but I don't have the machine to write!  Talk about entropy increases.
18:05:08 <timthelion> Not in scope: `rawSystem'
18:05:15 <mauke> timthelion: import System.Cmd
18:05:32 <timthelion> so ghci just imports heckload of common libs
18:05:37 <timthelion> it's not actually smart
18:05:48 <mauke> <interactive>:1:0: Not in scope: `rawSystem'
18:05:54 <mauke> ghci doesn't import anything here
18:06:38 <ddarius> GHCi is a set of patterns of binary values.
18:06:39 <timthelion> wow, that's pretty sick
18:07:09 <monochrom> I am a set of patterns of wave values.
18:07:17 * monochrom wobbles
18:07:33 * SamB_XP shifts monochrom's phase by \pi
18:07:40 <Saizan> timthelion: in ghci it works only if you use the qualified name, like System.Cmd.rawSystem
18:07:53 * monochrom walks through the wall!
18:08:04 <SamB_XP> monochrom: what?
18:08:35 <monochrom> Sorry, watched STTNG too much.
18:08:52 <ddarius> That's the only one I liked.
18:09:56 <timthelion> yay! I wrote a usefull program(to me). http://hpaste.org/1919
18:10:19 <ddarius> Someday I should write useful programs...
18:10:42 <MyCatVerbs> ddarius: never! =D
18:10:53 <MyCatVerbs> ddarius: three cheers for useless, entertaining tripe!
18:11:10 <timthelion> I like my way of thinking of things.  that the main(which I keep do'd) is in flow logic, and the rest is functional.
18:11:10 <monochrom> For doing ++ foldr is better than foldl. But OK.
18:11:11 <SamB_XP> how is it useless if it is entertaining?
18:11:22 <SamB_XP> I should write a pdp1 emulator
18:11:44 <SamB_XP> and an assembler
18:12:16 <MyCatVerbs> SamB_XP: Personally, I agree in principle.
18:12:17 <timthelion> someone should write a ps3 emulator that displays with an ascii art stream, so it could be used over ssh.
18:12:24 <MyCatVerbs> SamB_XP: but in practice, it's nice to eat regularly.
18:12:27 <SamB_XP> MyCatVerbs: principle? what principle?
18:12:32 <SamB_XP> I want to play spacewar!
18:12:55 <MyCatVerbs> SamB_XP: I meant the "how is it useless if it is entertaining?" thing but Spacewar is awesome, go for it dude.
18:13:04 <SamB_XP> oh.
18:13:07 <SamB_XP> that ;-)
18:13:46 <SamB_XP> anyway, I don't think a spacewar-quality PDP-1 should be too hard...
18:14:34 <MyCatVerbs> SamB_XP: dunno. They must've been pushing the hardware pretty hard =D
18:15:16 <SamB_XP> well, I mean, I think all it needs is the CPU and the screen, plus you need to load it somehow...
18:15:29 <SamB_XP> preferably with a RIM-format tape
18:15:40 <SamB_XP> imo
18:16:10 <monochrom> I don't know. WWE is entertaining and useless.
18:17:20 <SamB_XP> actually spacewar! was useful.
18:17:36 <MyCatVerbs> SamB_XP: bloody good machine tester.
18:17:42 <SamB_XP> yeah
18:18:09 <SamB_XP> also good motivation to get the system up and running ;-)
18:18:26 <timthelion> what are the opposites of head and tail?
18:18:31 <timthelion> I want to get the last char
18:18:35 <MyCatVerbs> SamB_XP: I've heard of "compile Linux ten times in a row on the box, if it fails nondeterministically junk it, if it fails deterministically go poke a dev with a toothpick" being used for that.
18:18:37 <timthelion> and all but the last char.
18:18:40 <SamB_XP> last and init
18:19:12 <SamB_XP> MyCatVerbs: well, spacewar is more entertaining
18:19:18 <MyCatVerbs> SamB_XP: guess it's a bit less useful now that people are running around with boxes that do Linux from scratch in ten minutes flat, but still.
18:19:29 <MyCatVerbs> SamB_XP: yeah, but it doesn't exercise the disks.
18:19:36 <SamB_XP> true.
18:24:30 <monochrom> How to exercise disk: Emulate PDP-1, inside that emulation, emulate PDP-1, inside that, emulate PDP-1, ... eventually run spacewar.
18:25:22 <SamB_XP> monochrom: but then I would have to figure out how to program the thing
18:25:53 <SamB_XP> also I guess I'd need to write an emulator that swapped...
18:25:54 <monochrom> Maybe it doesn't exercise the disk.
18:26:42 <ddarius> SamB_XP: Just give the emulated emulators a massive amount of memory.
18:27:01 <ddarius> How wide is the PDP's address bus?
18:28:20 * ddarius pretends that he actually wants to watch this movie.
18:28:34 <monochrom> Emulate the logic circuits of PDP-1. Inside that emulation, emulate the logic circuits of PDP-1...
18:29:35 <ddarius> Emulate a quantum computer and run spacewar in it.
18:29:42 <SamB_XP> it can apparantly have anywhere from 4096 to 64k 18-bit words
18:29:56 <monochrom> Now that's an idea.
18:30:34 <SamB_XP> anyway, considering that I do not have the single remaining PDP-1, I don't see why I'd need a hardware stress test ;-)
18:31:06 <monochrom> We're testing your personal computer.
18:31:12 <SamB_XP> oh.
18:31:37 <SamB_XP> can we please skip the lightning test?
18:31:57 <monochrom> Somehow, just building ghc is not enough.
18:32:09 <monochrom> It has to be: on your PC, emulate PDP-1, inside that, emulate PC, inside that, build ghc...
18:35:57 <monochrom> I need to implement a G-machine, then use it to run a program that emulates a G-machine...
18:36:04 <monochrom> At the 74th level the thing gains consciousness. It asks, "where am I", and the level underneath replies, "you're on a G-machine, and it's all G-machines all the way down!"
18:36:50 <monochrom> That dialogue takes 200 years to complete.
18:43:46 <lispy> at which point Douglas Adams wakes from death and writes a novel detailing the conversation as a footnote involving a whale
18:45:11 * stmartin thinks the /pot/ plant might be integral to groking monads.
18:45:43 <lispy> stmartin: i've never used pot and i grok monads...
18:46:07 <timthelion> I've never used pot, and I don't grok them
18:46:19 <monochrom> I eat lamb chops and drink darjeeling tea.
18:46:35 <monochrom> Baklava for dessert.
18:47:01 <lispy> (really i should say, i've never knowingly used pot...my parents smoked enough of it I may have gotten a contact high as a child ;)
18:47:39 <dons> stmartin: you've used some simple state monads, for example?
18:47:51 <dons> i find them easiest to understand. then Maybe.
18:48:06 <lispy> dons: hey, do you know why --restricted and --online were dropped from the lb command line?
18:48:21 <lispy> it threw me for a loop
18:48:27 <stmartin> We've covered them in lectures, but I've yet to really understand how they work behind the scenes.
18:48:27 <dons> i think sorear didn't know why we used them. :/
18:48:37 <dons> when he rewrote it all as a config rc system.
18:48:42 <lispy> dons: are you no longer the maintainer?
18:48:53 <dons> i am, but sorear rewrote the arg handling mechanism
18:49:07 <lispy> ah, he needs to update the README then
18:49:12 <dons> stmartin: hmm. maybe write some code? then look at how things are desugarred.
18:49:20 <Korollary> thats why projects need project wikis
18:49:39 <stmartin> I intend to, when my teaching load this semester is over.
18:49:44 <lispy> Korollary: that would be nice, i think lb is big enough to warrant some wiki space
18:50:12 <dons> for example,
18:50:13 <dons>         return a = State $ \s -> (a, s)
18:50:13 <dons>         m >>= k  = State $ \s -> let
18:50:13 <dons>                 (a, s') = runState m s
18:50:14 <dons>                 in runState (k a) s'
18:50:28 <dons> is the State monad, newtype State s a = State { runState :: s -> (a, s) }
18:50:30 <lispy> @tell sorear How can I use --restricted with lambdabot's new .rc format?  I need it for lambdaweb.  Thanks.
18:50:30 <lambdabot> Consider it noted.
18:50:39 <dons> which provides:
18:50:39 <dons>         get   = State $ \s -> (s, s)
18:50:40 <dons>         put s = State $ \_ -> ((), s)
18:50:55 <dons> ?undo do x <- get ; put (x+1) ; return 2
18:50:55 <lambdabot> get >>= \ x -> put (x + 1) >> return 2
18:51:16 <dons> becomes, (State $ \s -> (s, s)) >>= \x -> State $ \_ -> ((), x+1) >> return 2
18:51:40 <dons> --> (State $ \s -> (s, s)) >>= \x -> State $ \_ -> ((), x+1) >>  State $ \s -> (2,s)
18:52:13 <lispy> i think this desugaring technique is a more general technique that CS people are prone to forget.  When you don't understand something that you want the computer to do, just work some examples by hand.  You'll get up to speed in no time.
18:52:28 <dons> --> (State $ \s -> (s, s)) >>= \x -> State $ \_ -> ((), x+1) >>= \_ -> State $ \s -> (2,s)
18:52:34 <dons> then inline >>=
18:52:43 <stmartin> dons: Thanks for trying to explain it, but I don't really have time to listen right now, as I have a lab to teach.
18:52:50 <dons> hehe
18:53:09 <monochrom> All people are prone to forget.
18:53:30 <dons> which we can format as:
18:53:31 <dons>       (State $ \s -> (s,    s)) >>= \x ->
18:53:31 <dons>       (State $ \_ -> ((), x+1)) >>= \_ ->
18:53:31 <dons>       (State $ \s -> (2,    s))
18:53:41 <dons> now we start to see what's going on. the state is being threaded.
18:53:54 * stmartin thinks he shall have to try writing a FSM in Haskell as an exercise later.
18:54:21 <lispy> stmartin: or anything that wants to thread some state around...like a random number monad
18:54:47 <stmartin> That was an example that was handed out in lectures, so yes, I should start with that...
18:54:50 <lispy> BUT, this is just one use of monads
18:54:53 <dons> in prefix form, so we can substitute >>= more easily:
18:54:54 <dons>      (>>=) (State $ \s -> (s,    s))  (\x ->
18:54:54 <dons>        (>>=) (State $ \_ -> ((), x+1)) (\_ ->
18:54:54 <dons>                (State $ \s -> (2,    s))))
18:55:23 <lispy> stmartin: i'm fond of the list monad examples
18:55:47 <lispy> > do { x <- [1..3]; y <- "abc"; return (x,y) }
18:55:55 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
18:56:30 <lispy> figure that one out and you'll be well on your way
18:56:46 <stmartin> less than or equal to is   <=   in haskell, right?
18:56:53 <monochrom> Yes.
18:57:01 <lispy> :t (<=)
18:57:03 <lambdabot> forall a. (Ord a) => a -> a -> Bool
18:57:04 * cdsmith write a state machine in Haskell recently.  It wasn't all that interesting, though.
18:57:20 <stmartin> :t (=>)
18:57:22 <lambdabot> parse error on input `=>'
18:57:25 <monochrom> >=
18:57:32 <stmartin> OIC
18:57:57 <lispy> you could also hoogle it
18:58:02 <lispy> ?hoogle a -> a -> Bool
18:58:02 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
18:58:02 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
18:58:02 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
18:58:05 <dons> now, after inlining >>= we get:
18:58:06 <dons> (State $ \s -> let (a, s') =
18:58:06 <dons>     runState (State $ \s -> (s, s)) s in
18:58:06 <dons>         runState (((\x -> State $ \s -> let (a,s') =
18:58:06 <dons>              runState ((State $ \_ -> ((), x+1))) s in
18:58:09 <dons>                   runState ((\_ -> (State $ \s -> (2,    s)))) a) s')  a) s')
18:58:19 <dons> which seems scary, but then we realise that State/runState are just wrapping and unwrapping a tag
18:58:50 <lispy> and it's that unwrapping the value so we can look at it that starts the chain of evaluation
18:58:58 <lispy> hence the name runState
19:01:46 <lispy> stmartin: tackling the akward squad might be a good read for you since they develop the IO monad from basic prinicples
19:03:00 <dons> stripping off the tags, (\s -> let (a, s') = (\s -> (s, s)) s in (((\x -> \s -> let (a, s') = ((\_ -> ((), x+1))) s in ((\_ -> (\s -> (2, s)))) a) s')  a) s')
19:03:04 <dons> which is well typed, I hope:
19:03:06 <dons> :t (\s -> let (a, s') = (\s -> (s, s)) s in (((\x -> \s -> let (a, s') = ((\_ -> ((), x+1))) s in ((\_ -> (\s -> (2, s)))) a) s')  a) s')
19:03:09 <lambdabot> forall a t. (Num a, Num t) => a -> (t, a)
19:03:24 <dons> good. that is, the state computation is a function from an initial state, to a final state, and a result
19:03:38 <cdsmith> Woohoo!  I have now created my own project with darcs and cabal.  Not too bad, really.
19:03:57 <lispy> cdsmith: congrats, did you follow the guide on the wiki or figure out things on your own?
19:04:10 <cdsmith> lispy: a combination.
19:07:02 <cdsmith> The hardest part was finding a place to put it, and installing darcs into my home directory on the server where I have no root access.
19:08:25 <lispy> cdsmith: what is your project?
19:08:33 <lispy> are you going to share it?
19:08:47 <lispy> have you contributed to lambdabot yet?
19:09:22 <cdsmith> lispy: It's part of my evil plan to make all my friends learn Haskell before the ICFP contest.
19:09:26 <cdsmith> It is a MUD (multi-user dungeon), because that practiclly guarantees that one friend of mine will learn Haskell and start hacking at it.
19:10:01 <lispy> dons: that reminds me, can we split lambdabot's module list to one module per line?  That way when people customize the line they will get fewer conflicts from darcs
19:10:02 <cdsmith> lispy: and yes, I did write a lambdabot patch, actually.
19:10:35 <lispy> cdsmith: great, you're part of the community officialy if you send in a lambdabot patch :)
19:11:00 <lispy> cdsmith: a haskell mud?  so tell me about your architecture
19:11:29 <lispy> cdsmith: i tossed around the idea once, but i run into some threading bugs with the way i wanted to make it work...
19:11:38 <cdsmith> lispy: Umm, not much to say.  I'm using STM.
19:11:44 <edwardk> hsplugins to do mob scripting would be fun =)
19:12:02 <cdsmith> lispy: darcs get http://cdsmith.twu.net/darcs/mud if you're curious.  It's fairly small.
19:12:05 <lambdabot> Title: Index of /darcs/mud
19:12:54 <timthelion> ok, I'm stuck, I want to write a recursive function that builds a string from right to left. but I can't seem to do it without making a wrapper function to add the []
19:12:59 <timthelion> is it possible?
19:13:37 <lispy> timthelion: can you give more details, i don't think i understand why you need a wrapper function to add []
19:14:01 <monochrom> Like 'a':('b':('c':[])) ?
19:14:06 <cdsmith> timthelion: if you hpaste what you've got, it might help
19:14:54 <dons> and jsut to round things off (after a bit of @unpl/@pl ing, we find that
19:14:54 <dons> (do x <- get put (x+1) return 2)
19:15:03 <dons> reduces to :
19:15:04 <dons>  (\s -> let (a, s') = (s,      s) in (((\x s ->
19:15:04 <dons>         let (a, s') = ((), x + 1) in (\_ ->
19:15:04 <dons>                       ((,) 2))
19:15:04 <dons>    a) s') a) s')
19:15:20 <timthelion> well, if I'm going from left to right, it is easy, I just do n [x:xs] = n xs : x \n n x = x : []
19:15:27 <dons> at which point my parens matching gives up. but you can continue to reduce this further, and you get back the explicit state threading you'd write, if there were no monads to begin with
19:15:27 <timthelion> but if I'm going from right to left
19:15:34 <dons> all that plumbing is hidden inside >>=
19:15:40 <timthelion> how do I do it? I need to add the [] first
19:16:11 <timthelion> how do I know I'm at the first iteration of the recursion
19:16:27 <timthelion> without having that first iteration be a seperate function?
19:16:36 <monochrom> I really don't understand. I hope someone does.
19:16:58 <twanvl> timthelion: Usually you use function composition
19:17:20 <twanvl> This is done by the show functions, the tail of the list is a parameter
19:17:27 <timthelion> well, I could do n x = y x : [] and then I can make y recursive
19:17:46 <timthelion> but then I have to come up with a name for y, even though it is not relevant to the rest of the program
19:17:56 <edwardk> you can bury such things in a where clause
19:18:34 <lispy> cdsmith: so you have two threads per connection, one input and one output?
19:18:45 <edwardk> its common to see things like foo x = foo' x initialsomethingorother where foo' x y = ...
19:18:51 <twanvl> Or you could have the function return a ShowS (a type synonym for String->String), and make the caller responsible for turning it into a string
19:18:58 <cdsmith> lispy: yeah.  No real need, except it isolates one client from the I/O problems of others.
19:19:19 <lispy> cdsmith: and how does one connection talk to another connection?
19:19:24 <edwardk> heh i wish i had had enough threads to afford to do that back in my mud programming days ;)
19:19:28 <lispy> cdsmith: for example if players chat
19:19:33 <timthelion> edwardk: that looks good
19:19:42 <cdsmith> lispy: by adding to its event buffer, which will wake up the output thread.
19:20:08 <lispy> cdsmith: i tried to do something very similar and i fell on my face...where is the event thread?
19:20:14 <lispy> er event buffer
19:20:30 <cdsmith> lispy: the event buffer is a field of 'data Conn' defined in ConnCtx.hs
19:21:13 <edwardk> i like the STM'ing of world state
19:21:30 <cdsmith> edwardk: yeah, I think race conditions wouldn'
19:21:39 <cdsmith> ve been impossible otherwise
19:21:49 <edwardk> they shouldn't be bad especially as your world grows
19:21:57 <edwardk> just keep the transactions small
19:22:39 <edwardk> last time i wanted to use STM i needed some pretty hefty transactions, needless to say, they sometimes took a looooong time to get through, coz they can starve pretty easily
19:22:48 <lispy> edwardk: ghc threads should be so lightweight that his implementation scales similarly to a select based implementation
19:23:00 <cdsmith> The most interesting bit is in World.hs, where I manage to reuse one structure for both a live world with TVars, and also a snapshot without them.  That was ugly, but fun.
19:24:38 <lispy> cdsmith: i'm partial to parsers, so i say, "Hey, write a parser instead of using Binary!" :)
19:24:57 <edwardk> heh
19:25:12 <lispy> cdsmith: still, looks nice
19:25:15 <cdsmith> lispy: the decision to use Binary is somewhat orthogonal, though.  The tough part is getting a snapshot of the state.
19:25:32 <edwardk> yeah
19:25:45 <lispy> $(derive makeBinary ''Player)  <-- is this TH or something else?
19:25:58 <cdsmith> Yes, it's TH.  and Data.Derive
19:28:18 <lispy> cdsmith: well, it looks nice (i've read through pretty much all the source now)
19:28:22 <lispy> simple but effective
19:28:48 <cdsmith> lispy: Thanks.  It needs some cleaning up (especially in Commands.hs), but I'm fairly happy with it.
19:29:16 <edwardk> yeah, well thought out
19:29:56 <lispy> cdsmith: maybe each command could be like a module in lambdabot...that way you could add new commands on the fly
19:30:23 <edwardk> or have modules that load and supply a bunch of commands, less boilerplate
19:30:24 <cdsmith> lispy: Could be... again, the changes would be relatively small.
19:30:52 <lispy> cdsmith: right, you've got a good design going
19:30:54 <edwardk> hsplugins still not windows friendly with 6.6?
19:31:24 <lispy> i wish i had more spare time, i'd like to resurrect my attempt
19:31:28 <edwardk> heya vincenz, long time no see
19:31:43 <lispy> i should get going
19:31:52 <cdsmith> lispy: Thanks for the comments!
19:33:47 <cdsmith> So how expensive are TVars in STM?  Would it be reasonable to write a Data.IntMap that sprinkles them throughout the middle of the tree?
19:34:09 <lispy> ?src TVar
19:34:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:34:31 <edwardk> the problem is the root of the tree you'll have high traffic there, even if its only read access
19:34:36 <lispy> cdsmith: you should be able to find their data TVar definition and judge for yourself
19:34:52 <edwardk> they are implemented as primitive by ghc, there is a TVar# and all that
19:35:08 <cdsmith> edwardk: It would be almost all reads, though.
19:35:10 <edwardk> i have a transactional hash table that ran into problems
19:35:29 <edwardk> yeah but isn't the check in for transactions proportional to the tvar read total?
19:36:07 <cdsmith> edwardk: It should be proportional to the number of reads in a single thread.
19:36:23 <cdsmith> edwardk: Why would it matter if they were all reading the same base TVars?
19:36:37 <edwardk> it'll just make the transactional checkins slower
19:37:14 <edwardk> still logarithmic to data structure size, so shouldn't suck tooo bad
19:37:19 <cdsmith> edwardk: Wouldn't the checkin be lock-free in the fast case?
19:37:51 <edwardk> when you go to finish a transaction in STM it checks that all the things you read haven't changed since, no?
19:38:00 <edwardk> that was the funny business with STM vs traditional methods
19:38:03 <edwardk> where the cost lays
19:38:20 <cdsmith> edwardk: Yes, it does do so.
19:38:23 <edwardk> its been a while since i thought about this so i may be a litle mixed up
19:39:02 <cdsmith> edwardk: Well, the alternative here is to replace the whole tree every time a change is made to any element of it.  I'm a little worried about that scaling at all.
19:39:14 <edwardk> just saying you might fare better with a higher fan out or even just using stm over a certain level in the hierarchy and going normal from there down
19:40:02 <edwardk> iirc a tvar containing a tree is how pugs stores such things, but yeah its not all that wonderful performance wise
19:40:11 <cdsmith> edwardk: That certainly makes sense.  I was planning on doing TVars like every fourth level or something like that.
19:40:39 <edwardk> should work, i used a pair of levels for them in an extensible hash table implementation
19:40:58 <edwardk> still a bit slower than i'd hoped though
19:41:11 <cdsmith> edwardk: Of course, balancing the tree may make things a little messier; change the levels and all that.
19:41:39 <lispy> i'd go with one TVar for the whole tree initially then optimize later
19:41:42 <edwardk> yeah, lot of variables involved there
19:42:05 <cdsmith> Well, I just find the problem interesting.  I doubt this code will ever see enough use for it to matter.
19:42:55 <lispy> i don't like to optimize until i have some real-world inspired timing data
19:43:21 <cdsmith> lispy: Makes sense.  Personally, I'm a little less attached to the real world. :)
19:43:25 <edwardk> hehehe
19:43:43 <monochrom> I'm attached to the pure world.
19:44:04 <dibblego> only the fourth spatial dimension mutates!
19:44:07 <edwardk> i'm attached to my own little world, but hey, they know me there
19:44:22 <SamB_XP> monochrom: the same way as an IORef is?
19:44:48 <monochrom> Very likely.
19:45:08 <lispy> or maybe an STRef
19:45:35 <SamB_XP> lispy: they are connected in exactly the same way
19:45:39 <SamB_XP> i.e. not at all
19:46:21 * lispy leaves for real this time
19:46:29 <cdsmith> lispy: good night
19:47:43 <MyCatVerbs> Sleep well.
19:52:37 <timthelion> hmm, can someone please help me debug? http://hpaste.org/1920
19:53:09 <timthelion> I want that to return "index.html" when passed "www.google.com/index.html"
19:53:48 <dibblego> what about www.google.com/foo/index.html?
19:53:57 <timthelion> same result
19:54:11 <timthelion> my code won't compile
19:54:19 <timthelion> I put the error below it.
19:54:44 <timthelion> I'm trying to walk from right from right to left, building a new string.
19:54:54 <timthelion> it should be easy, but I'm very new to haskell.
19:55:13 <dibblego> you can't walk right to left on a cons list
19:55:54 <timthelion> huh, why not? I think that is what my code does, it just doesn't compile
19:56:02 <timthelion> it takes init and last
19:56:06 <timthelion> in order to do so.
19:56:39 <dibblego> > let f xs = reverse $ takeWhile (/= '/') $ reverse xs in reverse "www.google.com/foo/index.html"
19:56:40 <lambdabot>  "lmth.xedni/oof/moc.elgoog.www"
19:56:45 <dibblego> > let f xs = reverse $ takeWhile (/= '/') $ reverse xs in f "www.google.com/foo/index.html"
19:56:46 <lambdabot>  "index.html"
19:57:32 <timthelion> Thankyou, but it would help me learn if you where to tell me why my code doesn't work.
19:57:41 <dibblego> let f = reverse . takeWhile ('/' /=) . reverse in f "www.google.com/foo/index.html"
19:57:45 <dibblego> > let f = reverse . takeWhile ('/' /=) . reverse in f "www.google.com/foo/index.html"
19:57:47 <lambdabot>  "index.html"
19:58:05 <dibblego> ?type last
19:58:07 <lambdabot> forall a. [a] -> a
19:58:26 <dibblego> ?type init
19:58:29 <lambdabot> forall a. [a] -> [a]
19:59:20 <dibblego> you can't walk right to left on a cons list
19:59:29 <dibblego> it is singly linked from the head
19:59:43 <timthelion> so my code would work, if not for a limitation of haskell?
19:59:55 <dibblego> it's not a limitation of haskell
19:59:58 <dibblego> it'
20:00:02 <dibblego> s a data structure
20:00:27 <dibblego> last runs in O(n) on a cons list
20:00:33 <timthelion> but I don't do anything that is against the rules do I? I don't get why it doesn't work.
20:00:52 <timthelion> you can say that, but each step of the way, I mentally whent though the function
20:00:57 <dibblego> clearly you do; but I can't quite tell what because I don't know the type of fname
20:00:58 <timthelion> and didn't see anything odd.
20:01:18 <timthelion> fname, is [a] -> [a]
20:01:19 <dibblego> ?type (:)
20:01:21 <lambdabot> forall a. a -> [a] -> [a]
20:01:39 <timthelion> dibblego: what do you mean you don't know the type of fname. I gave you the error.
20:02:03 <timthelion> fname isn't defined elsewhere
20:02:03 <dibblego> what type is fname (init url) ?
20:02:16 <dibblego> oh wait, I see it
20:02:29 <timthelion> it's recursive
20:02:39 <dibblego> you probably want ++ instead of :
20:02:49 <dibblego> but then, you probably don't *really* want that
20:02:56 <dibblego> ?type (++)
20:02:58 <lambdabot> forall a. [a] -> [a] -> [a]
20:03:06 <dibblego> > "abc" ++ "def"
20:03:07 <lambdabot>  "abcdef"
20:03:25 <dibblego> you cannot append a single element to a cons list
20:03:47 <bd_> If you're going to be doing a lot of appending, look into Data.Seq
20:04:18 <timthelion> so the problem is that : is looking for a : [a] and I'm giving it [a] : [a]
20:04:46 <dibblego> you're giving it [a] : a
20:04:54 <timthelion> yes
20:04:59 <timthelion> ok, and that's what I can't do
20:05:03 <timthelion> is it not possible to do?
20:05:15 <dibblego> you cannot append a single element to a cons list
20:05:20 <timthelion> ok
20:05:22 <timthelion> damn
20:05:22 <sioraiocht> timthelion: you have to listefy it
20:05:29 <dibblego> do you know what a singly linked list is?
20:05:47 <sioraiocht> > [1,2,3,4] ++ 5
20:05:48 <lambdabot>   add an instance declaration for (Num [t])
20:05:57 <sioraiocht> > [1,2,3,4] ++ [5]
20:05:58 <lambdabot>  [1,2,3,4,5]
20:06:02 <timthelion> it is a list in which there is a pointer to the next element but not to the previos
20:06:40 <timthelion> now why can't I set that pointer, for the last element, from nul to a?
20:06:46 <dibblego> and pointers are not overwritten (like they may have been in C/Java class)
20:07:00 <sioraiocht> timthelion: because haskell said so =p
20:07:04 <dibblego> because that's a destructive update and that is VERY nasty
20:07:14 <timthelion> ok
20:07:16 <dibblego> we shun such ideas here in #haskell and we hope you will soon too :)
20:07:35 <timthelion> so you would have to build a whole new list for the new value of the one pointer on the last element
20:07:38 <sioraiocht> timthelion: most haskelltypes are immutable
20:07:46 <timthelion> and you can do that, it's just a really stupid thing to do.
20:07:56 <dibblego> timthelion, the act of "building a whole list" never actually occurs, but otherwise, yes
20:08:04 <dibblego> no, it's a clever thing to do
20:08:27 <dibblego> this is the single biggest counter-intuitive ideal for Haskell newcomers in my opinion by the way
20:08:41 <timthelion> well it would be rather ineficient to rebuild the whole list each time you added an element to one end.
20:08:42 <sioraiocht> timthelion: there are a lot of guarantees about haskell code you can't make about other code
20:08:44 <dibblego> from C/Java world
20:09:04 <MyCatVerbs> > (\x->(take 4 x)++(drop 2 x)) [1..20]
20:09:05 <sioraiocht> timthelion: most of it, for example, is inherently threadsafe
20:09:05 <lambdabot>  [1,2,3,4,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:09:06 <dibblego> timthelion, no, it is actually more efficient (just trust me for now or we can go into detail)
20:09:16 <timthelion> I'm coming from an elisp and C background.
20:09:54 <dibblego> timthelion, Haskell is a *lazy* language; this makes things very different
20:10:50 <sioraiocht> timthelion: just to prepare you, haskell, by definition, has a rather parochial following, as strict versus lazy evaluation is one of the great holy wars in programming language research
20:10:55 <timthelion> I should think that my code would still work, it would just have to unfold the entire function to get the first element.
20:11:03 <MyCatVerbs> timthelion: concentrate on adding to and removing from the *head* of the list where possible. Those operations are really, *really* fast. Faster than doing so in C, unless you do a lot of work to handle memory pools yourself instead of using malloc.
20:11:24 <timthelion> sioraiocht: it's not as bad a vim vers emacs...
20:11:41 <dibblego> timthelion, for your perusal later http://blog.tmorris.net/you-lazy-thunk/
20:11:42 <lambdabot> Title:  Tony&#8217;s blog   Blog Archive  You Lazy Thunk!
20:11:49 <sioraiocht> timthelion: I dunno about that, it's just not as widespread in nerd community
20:12:02 <dibblego> I think the strict v lazy war has been won
20:12:09 <MyCatVerbs> sioraiocht: really?
20:12:17 <sioraiocht> dibblego: go to a SIGPLAN conference and you'll see =p
20:12:22 <MyCatVerbs> dibblego: it looks to me more like the strict v lazy war has been absconded from.
20:12:30 <dibblego> sioraiocht, remind me not to go to SIGPLAN conferences then :)
20:12:30 <MyCatVerbs> sioraiocht: ohhhhh. I see.
20:12:33 <timthelion> hmm w3m says Cannot retrieve URL: http://blog.tmorris.net/you-lazy-thunk/ (exit status: 1)
20:12:34 <lambdabot> Title:  Tony&#8217;s blog   Blog Archive  You Lazy Thunk!
20:12:44 <timthelion> op
20:12:48 <timthelion> it's happy now
20:13:01 <dibblego> timthelion, read it later; it's just a rant of mine that is relevant to your issue
20:13:05 <sioraiocht> MyCatVerbs: A lot of researchers don't think the difficult in analysing time and space complexity is worth the gains of lazy evalutation
20:13:39 <dibblego> a lot of horse and carriage operators don't think a car is worth learning how to drive, because it is much harder
20:14:20 <sioraiocht> dibblego: I think a horse and carriage would actually be harder =p
20:14:25 <timthelion> dibblego: I'm only 16, I think I have the time to learn yet another outlook on programing.
20:14:25 <dibblego> an *honest* researcher would say "lazy evaluation is the correct foundation, I am just not clever enough to reason about it - I know of others who are"
20:14:37 <dibblego> timthelion, you're in the right place :)
20:14:41 <monochrom> I won't say which one is better, lazy or strict. But I want to remind you that with lazy, immutable cons cells, you would approach problems and algorithms differently.
20:14:45 <edwardk> heh, i wish i had read this paper 8 months ago before i started trying to figure out mixed lazy/eager semantics: http://portal.acm.org/citation.cfm?doid=944705.944731
20:14:47 <lambdabot> Title: Optimistic evaluation
20:14:56 <MyCatVerbs> sioraiocht: TBH, from where I'm sitting it looks like the Haskell community is quite happily implementing a lazy evaluated language and programs in it, while everyone else is quite happily sitting in their own corner and ignoring the Haskellers.
20:15:31 <dibblego> if the CPU versus volatile memory relative cost was inverted, I wonder if those researchers would change their minds
20:15:34 <edwardk> er, non ACM link here http://citeseer.ist.psu.edu/ennals03optimistic.html
20:15:36 <lambdabot> Title: Optimistic Evaluation: An Adaptive Evaluation Strategy for Non-Strict Programs - ...
20:15:45 <sioraiocht> dibblego: that's entirely possible
20:16:07 <sioraiocht> dibblego: but in the meantime, reasoning about complexity is extremely important in some circumstances
20:16:14 <timthelion> I wondered when I first learned about functional programing, weather one could turn the dial on memory efficient verse cpu efficient, by caching the outcome of pure functions. is this done?
20:16:15 <dibblego> converting a lazy structure to a strict one is easy; the other way around requires a rewrite
20:16:46 <sioraiocht> timthelion: what do you mean the outcome?
20:17:01 <sioraiocht> timthelion: you mean memoization?
20:17:07 <dibblego> memoisation I expect; but in any case, you "turn the dial" yourself (as the programmer)
20:17:34 <timthelion> sioraiocht: well if I have function f, and I pass "hello" to it and it returns "hi", and f is pure , then even though it took 5 minutes to return "hi" it could cache "hi" for the next time "hello" was passed
20:17:45 <dibblego> ?where memoization
20:17:46 <lambdabot> I know nothing about memoization.
20:17:51 <sioraiocht> timthelion: that is called memoization
20:17:55 <dibblego> timthelion, that technique is called memoisation
20:18:01 <edwardk> tim: http://ttic.uchicago.edu/~umut/papers/pldi06.html is an overview of a library for self-adjusting memoization
20:18:03 <lambdabot> Title:
20:18:05 <edwardk> as i recall
20:18:40 <dibblego> timthelion, many backtracking algorithms perform memoisation (I have just written one in a strict (by default) language using a DPA algorithm)
20:18:41 <edwardk> but in general you can memoize lots of things, its also called 'dynamic programming' in imperative circles
20:19:22 <sioraiocht> using weak references, you can actually implement decently efficient memoization
20:19:34 <sioraiocht> that keeps your cache from getting too big
20:19:45 <edwardk> yeah
20:20:12 <sioraiocht> of course, that requires a language that uses GC, heh
20:20:13 <edwardk> i kind of have a hack for doing that using System.Mem.Weak and a hash table that i tend to use for hash consing
20:20:34 <edwardk> by tend to use i mean, 'have been using for a couple days' ;)
20:20:39 <sioraiocht> hahah
20:20:44 <dibblego> CAL (a Haskell-like language) has a memo :: (a -> b) -> a -> b function
20:21:31 <olsner> how about transparent memoization of everything in the runtime system? that'd be cool!
20:21:39 <monochrom> Here is an example. Let's create the list [0, 0, ..., 0] n terms. You know the drill in C and lisp. But here is what haskell looks like. zeroes n = if n==0 then [] else 0 : zeroes (n-1). Note that we use the generator (yield) technique. No need for mutable cons cells, just as efficient.
20:21:45 <sioraiocht> olsner: I hope you have a fuckton of RAM =p
20:22:03 <dibblego> I think the fibonacci example is pretty good for explaining memoisation
20:22:06 <dibblego> or the edit distance problem
20:22:30 <sioraiocht> dibblego: the ackermann function is a good example, too
20:22:56 <sioraiocht> which is how it was explained to me, heh
20:23:14 <olsner> sioraiocht: the memoizer would of course determine the optimal compromise between memory use and cache efficiency, so it'd be a net win for me ;-)
20:23:43 <sioraiocht> olsner: that takes computation time =p
20:24:47 <sioraiocht> I mean, I guess we're talking FP so we're not too concerned with cost, lol
20:25:15 <monochrom> I think it's too hard to decide what to memoize.
20:25:37 <sioraiocht> monochrom: I think it would have to be decided heuristically, possibly at compile time, to be efficient
20:26:14 <monochrom> Maybe not too hard. Just discard LRU or something.
20:26:32 <olsner> LRU would be a place to start at least
20:27:39 <olsner> and since haskell is pure, almost everything can be cached safely
20:27:46 <timthelion> now lots of file systems, use the free space for indexing
20:28:11 <timthelion> is it possible for haskell to initialize all working memorie in the computer loosly like that for cacheing?
20:28:24 <timthelion> or would you need to write a whole new functional kernel
20:28:35 <sioraiocht> timthelion: would depend on the OS, but I suspect not =p
20:29:02 <timthelion> it would be helacool
20:29:26 <olsner> that's basically the same problem you have when deciding whether to GC or allocate more memory.. so I think there are working work-arounds out there
20:29:27 <timthelion> I wonder what it would take to write a new memorie manager for linux, without re-writting the device support.
20:29:31 <sioraiocht> timthelion: from northern california?
20:29:42 <monochrom> You bought a wedding ring for your girl. Then there was a quarrel, and you tossed the ring into the trash in sadness. Next morning the two of you were happy together again, and you rushed to the Garbage Collector: "Do you still have my ring?" "Yes! I still have it in the cache!"
20:29:45 <timthelion> sioraiocht: me, no, I'm from washington.
20:29:45 <edwardk> olsner: the paper i linked to by acar above was about an automatic self-tuning memoization library, doesn't work so well in practice as i recall
20:30:04 <sioraiocht> timthelion: Same thing, only peple from the pacific northwest say hellacool
20:30:21 <sioraiocht> ;)
20:30:52 <sioraiocht> I would just suspect that you only get the benefits in a very limited subset of circumstances
20:31:29 <olsner> edwardk: reading now.. the fanout ratio of other papers to read to really understand that paper seems quite large though ;-)
20:32:14 <sioraiocht> I always hate that about papers, they speak as if you are well versed in the domain of what they are talking about -_-
20:32:23 <sioraiocht> makes me feel stupid, lol
20:33:59 <sioraiocht> timthelion: you looking to do CS in college?
20:34:32 <timthelion> I don't know
20:34:35 <timthelion> I think I might
20:35:09 <sioraiocht> any idea where?
20:35:33 <timthelion> someplace warm
20:35:45 <sioraiocht> ha, I won't recommend my Alma Mater then
20:36:09 <olsner> dynamic dependency graphs, sounds interesting... would be interesting to mix-and-match a compiler with memoization, persistency and those DDG:s
20:36:21 <timthelion> sioraiocht: where are you?
20:36:51 <sioraiocht> timthelion: I went to Syracuse University
20:37:00 <timthelion> oh.
20:37:00 <sioraiocht> for Computer Science
20:37:05 * timthelion looks that up
20:37:22 <olsner> that'd basically be perfect incremental compilation without actually having to write an incremental compiler
20:37:38 <sioraiocht> timthelion: it's in the frozen wastelands of central new york
20:37:52 <sioraiocht> it gets the most snow of anywhere else in the country
20:38:08 <timthelion> Don't want to go there, unless I'm going into electrical engineering
20:38:28 <timthelion> then I'd make myself hand warmers that worked and could be typed in.
20:38:36 <sioraiocht> lol
20:38:51 <monochrom> Incremental, lazy programmer is cooler. Some of us are experimenting with that, using ourselves as prototypes.
20:38:52 <SubStack> who uses hand warmers?
20:39:04 <timthelion> me!
20:39:05 <sioraiocht> SubStack: the weak
20:39:11 <SubStack> it gets down to -40F for weeks a time here and nobody uses hand warmers
20:39:24 <sioraiocht> SubStack: where do you live?
20:39:28 <SubStack> Fairbanks, Alaska
20:39:33 <sioraiocht> and for the record -40 is the same on both scales, roughly, hehe
20:39:37 <sioraiocht> eeep
20:39:48 <SubStack> there are more than two scales
20:40:02 <sioraiocht> yes, but weather isnt often report in Kelvin
20:40:04 <monochrom> major and minor
20:40:10 <sioraiocht> haha
20:40:20 <sioraiocht> Myxolydian..Dorian..
20:40:33 <monochrom> more than two because minor harmonic or minor melodic
20:40:45 <sioraiocht> pentatonic..
20:41:33 <sioraiocht> arabic scales typically have a minor 2nd..
20:43:12 <sioraiocht> have a good night all!
21:05:54 <encryptio> :t \x -> x (\x -> (\x -> x x) x) x)
21:05:56 <lambdabot> parse error on input `)'
21:05:57 <encryptio> :t \x -> x (\x -> (\x -> x x) x) x
21:05:59 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
21:05:59 <lambdabot>     Probable cause: `x' is applied to too many arguments
21:07:38 <kaol> what would you recommend for accessing a postgresql DB? haskelldb?
21:08:49 <bos> hdbc, probably.
21:09:37 <timthelion> is it possible to have a let block be child to a do block this tabification does not seem to work? http://hpaste.org/1921
21:11:11 <olsner> timthelion: remove the 'in' - let has a different syntax in do-blocks
21:11:20 <MyCatVerbs> o/" got a feelin' nineteen twenty one is gonna be a good year, / 'specially if you and me ring it in together... o/"
21:12:03 <stepcut> timthelion: refresh the page
21:12:26 <timthelion> yes, I got that, and it worked!
21:16:34 <bos> @seen CosmicRay
21:16:35 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 2d 4h 31m 20s ago, and .
21:16:38 <bos> @seen dons
21:16:38 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 8s ago.
21:16:47 <dons> yo.
21:16:55 <bos> afternoon.
21:16:55 <timthelion> yo yo
21:17:12 <timthelion> good eavnin
21:22:12 <timthelion> wow, I hope haskell isn't as slow as I thinks it is :(
21:22:44 <c> its always a good sign if the language lets you shoot yourself in the foot
21:23:15 <timthelion> I think I shot myself in the pistol
21:23:44 <monochrom> No, your brain exploded spontaneously, no pistol.
21:24:48 <kaol> there is no spoon^Wstate
21:25:40 <timthelion> you know what's wrong with pure functionality?
21:25:53 <dibblego> it makes sense while the world doesn't?
21:25:55 <timthelion> no status bars
21:28:53 <Heffalump> timthelion: YM progress bars?
21:30:02 <timthelion> well I mean when you have a pure recursive function, a status bar on it is theoretically impossible
21:30:37 <Heffalump> yes, but what do you mean by a status bar? Something showing its progress?
21:30:45 <dibblego> timthelion, many people prefer inductive reasoning instead
21:30:50 <dons> timthelion: ah ha, no. there's purely functoinal progress bars. :-)
21:31:01 <dons> its a list of results you thread through each recursive step.
21:31:05 <Heffalump> and can you predict how many iterations the recursion will take
21:31:05 <Heffalump> ?
21:31:06 <dibblego> Heffalump, stdout.println statements in the middle of calls I expect :)
21:31:06 <dons> (see the HW 2005 (?) paper)
21:31:18 <timthelion> is putStr pure?
21:31:22 <Heffalump> if so, just rewrite the function in terms of fix (easy to do), then call it with iterate instead
21:31:26 <timthelion> I should think not since it could error
21:31:47 <Heffalump> if you can't predict the number of iterations, you can't make a sane progess bar anyway
21:32:25 <TomMD> But your progress bar can still be more sane than some i have seen in industry.
21:32:47 <timthelion> have you ever done the project where you make a predicted life expectancy progress bar, and chart what percent of your life you have wasted to date?
21:33:11 <timthelion> TomMD: What! You claiming to have used windows?
21:33:20 <TomMD> I try not to dwell on how much time I spend solving compile errors.
21:33:51 <TomMD> timthelion: Careful about M$ knocking here - MS funds much of the work on Haskell.... but no, I make not admission to having used Windows.
21:34:01 <byorgey> timthelion: what, and waste 0.02% of my life figuring out how much of it I've wasted?  No thanks
21:34:10 <timthelion> TomMD: Do you care about M$?
21:34:24 <timthelion> TomMD: I mean funding is unnecessary
21:34:26 <encryptio> what's the name of this transformation?: (\x -> (x `op` x) `etc` (x `op` x))   ==>   (\x -> let y = (x `op` x) in (y `etc` y))
21:34:42 <TomMD> To the extent that most people I know and most people who use computers use Windows? Yes, I as a practical minded engineer do care.
21:34:56 <Heffalump> encryptio: CSE
21:34:57 <TomMD> encryptio: is this twenty questions?
21:35:10 <encryptio> TomMD: first question i've asked, asshat.
21:35:17 <encryptio> Heffalump: thanks
21:35:32 <byorgey> encryptio: is this a HW assignment? =)
21:35:48 <TomMD> encryptio: Ummm... I wasn't meaning it like that - 'twenty questions' the game 'Are you a monad?' etc.  signed - asshat.
21:35:49 <encryptio> nope. i implemented it and i forgot what it was called.
21:36:00 <byorgey> fair enough.
21:36:07 <timthelion> byorgey: What, I thought IRC was a valid research medium
21:36:11 * Heffalump won't bother answering your questions in future if you're just going to be rude
21:36:36 <encryptio> TomMD: never heard of it
21:37:42 <encryptio> TomMD: and if it wasn't meant in hostility i retract my previous statement to you. sorry.
21:38:53 <TomMD> Ahh, it is also called 'animal, mineral, or vegetable'.  A simple word game in which you must guess what the other person is thinking.  Because the other person is answering 'Yes/No' and you have 20 questions you should beable to explore a 2^20 problem space (although, you must ask very good questions to get no overlap).
21:39:04 <timthelion> encryptio: 20 Questions is a trivia game, I think he was saying that was a hard, and obscure question to answer.
21:39:38 <monochrom> Oh! That one!
21:39:38 <Heffalump> didn't look very hard or obscure
21:40:03 <timthelion> Heffalump: I was just stating my interpretation of the situation.
21:40:22 <TomMD> Honestly I didn't look at the type and just wondered if he was playing a game in which I could ask for further hints.  I am also quite tired, so one shouldn't expect too much sense out of me.
21:40:56 <encryptio> it's difficult to google that question. (relatively easy to google "let floating", another question of mine)
21:41:12 <dibblego> so you do have more than one question!!
21:41:19 <Heffalump> it's easy to google once you know the name :-)
21:41:20 <encryptio> not for here, no
21:41:26 <TomMD> Have a good night all, I'm hitting the mattress.
21:41:32 <encryptio> night.
21:41:33 <byorgey> night.
21:41:55 <timthelion> grr
21:42:01 <timthelion> do blocks aren't done in order?
21:42:17 <dibblego> do blocks are just syntactic sugar
21:42:17 <cdsmith> timthelion: in which monad?
21:42:19 <timthelion> I have one that executes differently when compiled verse when run in ghci
21:42:44 <cdsmith> timthelion: no you don't.  Now let's figure out why it looks that way.
21:42:53 <timthelion> http://hpaste.org/1922
21:43:14 <timthelion> it putStr's first in ghci
21:43:23 <timthelion> but second when compiled with ghc
21:43:32 <Heffalump> as in after the getLine?
21:43:35 <Heffalump> that's just line buffering
21:43:36 <encryptio> i'd guess a buffering problem
21:43:37 <timthelion> yes
21:43:43 <Heffalump> look at hSetBuffering
21:44:16 <timthelion> shit hoogle is SLOW
21:44:24 <byorgey> also hFlush
21:44:38 <encryptio> ghci automatically sets NoBuffering, compiled apps don't. (iirc)
21:44:39 <timthelion> @hoogle hSetBuffering
21:44:43 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
21:44:54 <timthelion> that's not very usefull
21:44:56 <timthelion> :(
21:45:00 <Heffalump> why not?
21:45:12 <cdsmith> timthelion: BufferMode == LineBuffering | BlockBuffering | NoBuffering
21:45:29 <encryptio> hSetBuffering stdout NoBuffering
21:45:40 <encryptio> with proper imports (from IO)
21:45:47 <timthelion> Heffalump: well it doesn't tell me what cdsmith told me, which is what I need to know.
21:46:28 <cdsmith> @info BufferMode
21:46:29 <lambdabot> BufferMode
21:46:37 <cdsmith> @src BufferMode
21:46:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:46:42 <cdsmith> hmm...
21:46:54 <cdsmith> :i in ghci would tell you
21:46:59 <byorgey> @hoogle BufferMode
21:46:59 <lambdabot> System.IO.BufferMode :: data BufferMode
21:47:18 <Heffalump> timthelion: true, but it tells you what to look for
21:48:33 <byorgey> does lambdabot do :i ?
21:48:50 <Heffalump> @info BufferMode
21:48:51 <lambdabot> BufferMode
21:49:03 <byorgey> oh, that's what @info does?
21:49:07 <Heffalump> I thought it did, but I can never figure out how to make it
21:49:08 <cdsmith> That's not terribly helpful. :)
21:49:25 <byorgey> but typing :i BufferMode in ghci gives lots more info, as cdsmith pointed out (I tried it)
21:49:35 <byorgey> :i BufferMode
21:52:49 <Heffalump> @info System.IO.BufferMode
21:52:50 <lambdabot> System.IO.BufferMode
21:53:25 <cdsmith> Good thing lambdabot can tell us that BufferMode is BufferMode.  I'd have never guessed.
21:54:18 <encryptio> @info Maybe
21:54:19 <lambdabot> Maybe
21:54:25 <Heffalump> @yhjulwwiefzojcbxybbruweejw
21:54:25 <lambdabot> Exception: <<loop>>
21:54:29 <encryptio> lol
21:55:09 <encryptio> @info blahblahblah
21:55:09 <lambdabot> blahblahblah
21:55:13 <encryptio> >.>
21:56:52 <byorgey> ?i BufferMode
21:56:53 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . v
21:57:01 <xwl> Hi, `make' ghc fails at: "/usr/bin/ar: building dist/build/libHSbase-2.1.a, make[1]: *** [build.library.base] error 9." what does this mean?
21:57:41 <cdsmith> xw: current HEAD?
21:57:48 <cdsmith> xwl, I mean
21:58:04 <xwl> cdsmith: yes, pull from darcs days ago
21:58:59 <cdsmith> I believe there was a build problem in HSbase recently that I ran into.  Do a darcs-all pull now and see what happens, perhaps?
21:59:31 <cdsmith> I was able to build from HEAD on Friday, anyway.
21:59:32 <xwl> hmm, okay, i'll try.
22:03:16 <xwl> ooh, no remote changes?
22:03:38 <xwl> so it's up-to-date.
22:04:00 <cdsmith> I'm building now to see if I can reproduce your problem.
22:04:40 <xwl> thanks, the building takes sooooooo long..
22:05:23 <cdsmith> Did you copy mk/build.mk.sample to mk/build.mk and uncomment the quickest build settings?
22:06:37 <xwl> no, i simply configure, make,
22:06:52 <cdsmith> Ah.  That speeds it up a little.  Not a lot, though.
22:07:52 <xwl> if there was something similar to `ccache', it would be much better.
22:08:05 <cdsmith> ccache?
22:08:15 <xwl> for gcc ,
22:08:24 <cdsmith> @google ccache
22:08:27 <lambdabot> http://ccache.samba.org/
22:08:27 <lambdabot> Title: ccache
22:08:58 <jcreigh> it caches the compiler based on a hash of the source code, for quicker rebuilds.
22:09:15 <jcreigh> I don't know if that implies "make" is broken or not.
22:10:41 <timthelion> hmm, I was told that I needed to use  hSetBuffering to make it so that a prompt would show up before a getLine was called
22:10:50 <timthelion> but that doesn't make sence to me
22:11:08 <timthelion> becaues hSetBuffering takes a file Handle
22:11:25 <byorgey> timthelion: use stdout as the file handle
22:11:33 <jcreigh> *and* a BufferMode
22:12:00 <timthelion> what buffer mode do I want?
22:12:01 <jcreigh> "hSetBuffering stdout NoBuffering" is that you want, I think.
22:12:34 <timthelion> ok thankyou
22:13:38 <cdsmith> xwl: GHC builds fine for me.  Anything odd about your environment?
22:13:40 <jcreigh> just for reference, there's some great docs at:
22:13:41 <jcreigh> @docs
22:13:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:14:24 <encryptio> timthelion: a "filehandle" is just something you can do serialized (or seekable) i/o on. that includes most stream sockets (tcp), files, and pipes (stdout/in/err)
22:14:30 <timthelion> god this is slow... http://hpaste.org/1923
22:14:37 <xwl> cdsmith: it's debian_powerpc_gcc4.1,
22:15:05 <cdsmith> xwl: Well, I spoke too soon; but libHSbase builds fine for me, anyway. :(
22:15:14 <timthelion> I tried running http://www.gutenberg.org/etext/1399 through that and it still hasn't finnished.
22:15:16 <encryptio> timthelion: try compiling with -O if you aren't already... after that, convert to ByteStrings (difficult imo)
22:15:17 <lambdabot> Title: Anna Karenina by graf Leo Tolstoy - Project Gutenberg
22:15:31 <jcreigh> :t (||)
22:15:33 <lambdabot> Bool -> Bool -> Bool
22:15:41 <xwl> cdsmith: is there a reference page for the thing, like "error 9 " ?
22:15:59 <jcreigh> timthelion: if (isUpper (head a)) || (length a > 7)
22:16:57 <byorgey> timthelion: perhaps try using foldl' instead of foldl in texttoespeak?
22:16:58 <cdsmith> xwl: I dunno.  Let's see if someone else knows anything.
22:17:51 <timthelion> byorgey: what is the difference?
22:18:18 <byorgey> timthelion: foldl' is strict, so it calculates partial results as it goes along
22:18:39 <byorgey> whereas foldl ends up with a huge mass of nested thunks before it actually reduces it to a string
22:18:55 <byorgey> and actually, unwords does what you want anyway
22:19:01 <timthelion> not in scope
22:19:06 <monochrom> No, use foldr here.  This is essentially foldl (++) vs foldr (++).
22:19:07 <xwl> cdsmith: ok, thanks anyway.
22:19:13 <jcreigh> timthelion: foldl' is in Data.List
22:19:29 <timthelion> ok
22:19:30 <Heffalump> strictness won't help much anyway
22:19:35 <timthelion> I'm trying unwords first
22:19:37 <Heffalump> cos ++ isn't very strict
22:19:37 <jcreigh> @src unwords
22:19:37 <lambdabot> unwords [] = ""
22:19:38 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
22:19:44 <bos> foldl' is not the right function to use here. you want to generate the list of words lazily.
22:19:59 <timthelion> wow
22:20:07 <byorgey> ok, thanks for correcting me =)
22:20:08 <timthelion> unwords made a world of difference
22:20:12 <bos> yeah.
22:20:53 <bos> unwords is essentially yielding each word before it continues, so writeFile can make continuous progress.
22:21:15 * mztimmu ha
22:21:17 <bos> your earlier code was building a *huge* pile of stuff in memory before writeFile ever got to do anything.
22:21:37 <bos> using foldl' would have reduced the hugeness of the pile, but not fixed the problem.
22:21:46 <timthelion> bos really!? that's cool
22:22:03 <monochrom> Not just that. Going through essentially the same data over and over again. O(n^2) in total.
22:22:13 <bos> yep.
22:22:29 <bos> aren't you glad you hang out in #haskell?
22:22:32 <bos> @quote stereo
22:22:32 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:22:40 <timthelion> haskell is going to be the next perl for me
22:23:26 <olsner> if it weren't already 7AM, I'd be porting perl to haskell too
22:23:34 * olsner calls it a night
22:23:58 <bos> the trick is remembering the various things you need to know to avoid digging yourself a hole with either too much laziness or too much strictness.
22:24:11 <bos> but the list isn't all that long for most programs.
22:24:20 <byorgey> @src foldr1
22:24:20 <lambdabot> foldr1 _ [x]    = x
22:24:20 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:24:20 <lambdabot> foldr1 _ []     = undefined
22:24:48 * Heffalump --> work
22:24:52 <timthelion> I like how the program I just wrote is 30 lines long, half of that interaction, and took me over 3 hours to write
22:25:15 <bos> yeah, that's how new languages go.
22:25:17 * roconnor hopes timthelion isn't paid by the line.
22:25:21 <byorgey> ah, now I get it =)
22:25:49 <timthelion> roconnor: you think the ration of interaction lines to code would be that low if I was paid that way?
22:26:05 <roconnor> ;)
22:26:10 <byorgey> so when is it better to use foldl (or foldl')?
22:26:14 <bos> the nice thing is that there's a much higher probability of your program actually being correct when the haskell compiler finally deigns to accept it than when a perl, python, or ruby interpreter gets all friendly and says sure, it'll just fire right up.
22:26:19 <bos> foldl == always bad.
22:26:26 <sjanssen> byorgey: foldl' is always better than foldl
22:26:30 <byorgey> fair enough =)
22:26:33 <jcreigh> byorgey: when the function is strict
22:26:35 <roconnor> (almost always)
22:26:49 <bos> foldl' == use when you need a complete result, not a lazy bunch of parts of the result.
22:26:51 <jcreigh> for instance, (+) will never produce any results without both arguments fully evaluated.
22:26:55 <timthelion> then why is in the ' one?
22:27:00 <monochrom> foldl' (+). foldr (++).  Please please please remember that.
22:27:29 <monochrom> But I suspect no one will listen to me, as has been proved today.
22:27:43 <sjanssen> @hug monochrom
22:27:43 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
22:27:51 <sjanssen> heh
22:27:54 * bos laughs
22:27:55 <byorgey> ah, that makes sense.  especially bos's description.  thanks!
22:28:06 <timthelion> hoogle does not work :(
22:28:28 <timthelion> ie http://haskell.org/hoogle/ does not return any results
22:28:29 <lambdabot> Title: Hoogle
22:28:39 <jcreigh> timthelion: for what search?
22:28:47 <bos> @hoogle [a] -> Int -> [a]
22:28:48 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
22:28:48 <lambdabot> Prelude.take :: Int -> [a] -> [a]
22:28:48 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
22:28:49 <timthelion> http://haskell.org/hoogle/?q=shell?q=file+exists is blank for me
22:29:02 <bos> hoogle doesn't work that way.
22:29:23 <jcreigh> hoogle is usually for searching on the name of the function or the type of the function.
22:29:24 <timthelion> so is there no apropos of haskell?
22:29:48 <timthelion> that's one heck of a bug...
22:30:15 <jcreigh> so if you're thinking, "I wish I had a function that built up a list based on the a predicate and a list". You figoure out what type it should be, and search:
22:30:16 <bos> @hoogle doesFileExist
22:30:16 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
22:30:19 <sjanssen> @hoogle FilePath -> IO Bool
22:30:19 <timthelion> how do I find out what function to use to determine if a file exists then?
22:30:19 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
22:30:20 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
22:30:52 <jcreigh> @hoogle (a -> Bool) -> [a] -> [a]
22:30:52 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
22:30:52 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
22:30:52 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
22:31:11 <jcreigh> and oh, looks, there's "filter", as well as some new friends.
22:31:20 <sjanssen> timthelion: you can phrase your question in terms of a type signature, or you can visit:
22:31:21 <sjanssen> @docs
22:31:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:31:27 <sjanssen> timthelion: and try to find the right module
22:32:34 <timthelion> grr
22:32:50 <timthelion> someone needs to write a short little haskell app called appropos
22:33:00 <timthelion> that searches god knows what
22:33:14 <timthelion> and returns a list of possible functions
22:33:32 <timthelion> I guess that wouldn't really work since haskell doesn't have docstrings
22:33:50 <sjanssen> it has haddock markup
22:36:08 <timthelion> great language, suck ass dev tools
22:36:27 <monochrom> http://www.google.com/search?q=site%3Awww.haskell.org%2Fghc%2Fdocs%2Flatest%2Fhtml%2Flibraries+file+exist   is this the apropos you're looking for?
22:36:29 <lambdabot> Title: site:www.haskell.org/ghc/docs/latest/html/libraries file exist - Google Search, http://tinyurl.com/227rwm
22:37:26 <timthelion> monochrom: no, because that didn't return any mention of the function doesFileExist
22:37:38 <timthelion> @hoogle doesFileExist
22:37:39 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
22:37:49 <Jessehk> I'm trying very hard to understand state monads, but I have a few questions.
22:37:59 <bos> fire away.
22:38:02 <Jessehk> :)
22:38:21 <Jessehk> A state monad represents a calculation dependant on a given state s
22:38:23 <Jessehk> right?
22:38:41 <bos> yeah.
22:39:11 <monochrom> Oh well.
22:39:23 <Jessehk> and returns the appropriate result, in addition to the updated state: (\s -> (a, s))
22:39:50 <Jessehk> What I'm having trouble with are get and set
22:40:01 <Jessehk> what exactly do they do?
22:40:42 <rashakil> Jessehk: it's just a cute way of looking at a function of the type (\s -> (a,s)).  get s = (s,s), and put x = ((),x).
22:41:49 <thoughtpolice> Jessehk: you same Jessehk from pfo?
22:41:57 <Jessehk> yup
22:41:59 <thoughtpolice> ah
22:42:05 <thoughtpolice> didn't know you did haskell :)
22:42:12 <Jessehk> hey mad_guy  ( I think ;))
22:42:17 <thoughtpolice> bingo
22:42:34 <timthelion> http://hpaste.org/1923
22:42:36 <thoughtpolice> also, rashakil, I changed my signature on cboard because you made me cry
22:42:41 <timthelion> what is wrong with my indentation?
22:43:07 <timthelion> aww, what's wrong thoughtpolice?
22:43:13 <Jessehk> rashakil bos: This example is extremely confusing to me. http://hpaste.org/1924
22:43:49 <thoughtpolice> Jessehk: what's the issue?
22:44:14 <byorgey> Jessehk: something which took me a while to understand is that get IS a state monad
22:44:39 <byorgey> i.e. it is a computation which does nothing and returns the current state
22:44:42 <monochrom> timthelion: http://hpaste.org/1923#a2
22:45:12 <Jessehk> byorgey : _WHICH_ current state? There isn't one yet. Driving me nuts
22:45:12 <byorgey> and put takes a value and produces a computation which sets the state to that value
22:45:32 <bos> Jessehk: the current state is the thing you pass in at the beginning.
22:45:47 <thoughtpolice> Jessehk: if you tried 'plusOne 1' you'd get 2
22:46:02 <bos> no, he wouldn't. he'd get 1.
22:46:24 <thoughtpolice> oh, right
22:46:32 <bos> the result of the computation and the state you're fiddling with are not the same thing.
22:46:35 <thoughtpolice> overlooked the execState :/
22:46:41 <thoughtpolice> my bad
22:46:55 <bos> that's why, if you look at the source for the state monad, you see that it's a 2-tuple.
22:47:31 <bos> one element is the state; the other is the result to pass along.
22:47:37 <byorgey> well, it's actually a function from the previous state to a 2-tuple (value, new state).
22:47:39 <byorgey> right?
22:47:52 <monochrom> execState throws away something.
22:47:57 <thoughtpolice> bos: i've just gotten accustomed to using evalState generally.
22:48:03 <bos> byorgey: yes
22:48:09 <thoughtpolice> so yeah, that was a bad on my part
22:48:15 <Jessehk> Could somebody walk through the tick function? I think I'm really close to getting it.
22:48:54 <thoughtpolice> Jessehk: think of tick as being executed in the context of a container; this container not only holds your computation (tick,) but a state your computation can modify.
22:49:07 <bos> Jessehk: it gets the current state, puts something back in, but returns the value that it got out.
22:49:35 <bos> the call to put will only affect the next call to get.
22:49:50 <thoughtpolice> get and put are just ways of modifying your state. it's like having a global variable in a referentially transparent world.
22:49:54 <bos> it won't affect the result of running the code.
22:50:16 <bos> and since you don't have a next call to get, your call to put does nothing.
22:50:30 <bos> well, it has no observable effect.
22:50:34 <thoughtpolice> yeah
22:51:01 <byorgey> but it would if you chained together several ticks.
22:51:03 <thoughtpolice> by replacing  your execState with evalState, you'd get back '2' since evalState returns the end result of your 'global var' rather than the result of your 'tick' function
22:51:23 <bos> but if you followed tick with another function that ran in the same monad and called get, *it* would see what you last put in there.
22:52:04 <Jessehk> bos : In "tick", is the Monad that is created equal to (\s -> (s, s)) ?
22:52:13 <monochrom> Aren't you guys swapping execState and evalState?
22:52:17 <rashakil> Jessehk: tick = State (\x -> (x, x + 1)).
22:52:56 <jbauman> :t execState
22:52:58 <lambdabot> forall s a. State s a -> s -> s
22:53:19 <jbauman> :t evalState
22:53:20 <lambdabot> forall s a. State s a -> s -> a
22:53:22 <byorgey> Jessehk: (\s -> (s,s)) == get.
22:53:48 <byorgey> well, State (\s -> (s,s)), that is
22:54:02 <monochrom> > execState (do {n <- get; put (n+1); return n}) (3 :: Int)
22:54:03 <lambdabot>  4
22:54:16 <monochrom> > evalState (do {n <- get; put (n+1); return n}) (3 :: Int)
22:54:17 <lambdabot>  3
22:55:47 <Jessehk> Aha! I think I just got it.
22:56:21 <rashakil> then Jessehk, what does (execState (tick >> tick) n) return?
22:57:26 <Jessehk> n + 2?
22:57:36 <rashakil> okay
22:57:42 <monochrom> > execState (do {n <- get; put (n+1); return n} >> do {n <- get; put (n+1); return n}) (3 :: Int)
22:57:43 <lambdabot>  5
22:58:25 <thoughtpolice> Jessehk: here's another one: http://hpaste.org/1925
22:58:41 <Jessehk> Can I think out loud for a second?
22:58:48 <Jessehk> get = (\s -> (s, s))
22:59:59 <Jessehk> n is the current state
23:00:15 <Jessehk> put (n + 1) == (\s -> s, (s + 1))
23:00:42 <Jessehk> return n == (\s -> (s, s + 1))
23:00:43 <Jessehk> is that right?
23:02:12 <rashakil> Jessehk: put (n + 1) = (\s -> ((), (n + 1)))
23:02:26 <rashakil> and return n == (\s -> (n, s))
23:02:33 <jbauman> well, switch the order of the tuple around, for put
23:02:34 <rashakil> or =, not ==...
23:03:04 <monochrom> ((), (n + 1)) is the right order. I double-checked.
23:03:16 <jbauman> oh?
23:03:23 <jbauman> :t Control.Monad.State.put
23:03:25 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
23:03:29 <jbauman> hmm
23:03:42 <monochrom> @src Control.Monad.State.State
23:03:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:03:45 <rashakil> look at the source code and the state is second
23:04:15 <rashakil> newtype State s a = State { runState :: s -> (a, s) }
23:04:29 <byorgey> well, the order isn't all that important to understanding how it works
23:04:34 <jbauman> true
23:04:42 <byorgey> it seems Jessehk has the right ideas =)
23:04:56 <thoughtpolice> you can just pick your values out via eval/execState. but that's the general gist. :)
23:07:48 <Jessehk> Is this equivelent? tick = get >>= (\n -> put (n + 1) >> return n
23:07:53 <thoughtpolice> rashakil: btw, your advice on cboard was good; monad transformers are tons o' fun. :p
23:08:02 <monochrom> Yes.
23:08:10 <thoughtpolice> Jessehk: you could also just use modify (+1)
23:08:25 <Jessehk> thoughtpolice: Just a teaching example. :)
23:08:30 <thoughtpolice> Jessehk: fair enough.
23:08:37 <rashakil> thoughtpolice:okay
23:09:01 <thoughtpolice> Jessehk: you'll get it the easiest by just playing around; I found State one of the monads you can have fun with pretty quickly
23:09:18 <Jessehk> I know I should know this (I do with IO): in this case, the (>>) does ... what?
23:09:39 <monochrom> >>= \_ ->     ignores "return" value
23:09:50 <thoughtpolice> it's just a way of ordering operations, basically
23:09:51 <byorgey> @src (>>)
23:09:51 <lambdabot> m >> k      = m >>= \_ -> k
23:10:38 <byorgey> chaining while ignoring the return value.
23:10:53 <slava> so i wonder if this algorithm has a name
23:10:59 <slava> suppose you have two maps between finite sets
23:11:39 <dons> hey slava.
23:11:42 <thoughtpolice> Jessehk: personally though the writer monad is what clinched the whole monads story for me.
23:11:44 <slava> f: (1->2, 3->4) and g: (2->5, 5->3), for instance
23:12:12 <slava> and you view these maps as substitutions on an alphabet, and look at the map obtained by composing the two substitutions
23:12:36 <dons> ok.
23:12:43 <Jessehk> thoughtpolice: I'm trying. :) I can handle IO pretty easily and (thanks to all of you) I understand State monads now
23:12:53 <slava> so the result is a map (1->5, 3->4, 2->4, 5->3)
23:13:04 <dons> 2->5, for the 2nd last elem, you mean.
23:13:10 <slava> dons: i think i got that example wrong. can i just paste a unit test?
23:13:17 <dons> sure.
23:13:23 <slava> H{ { 1 2 } { 3 4 } } H{ { 2 5 } } union*  ==>  H{ { 1 5 } { 3 4 } { 2 5 } }
23:13:32 <slava> H{ { 1 2 } { 3 4 } } H{ { 2 3 } } union*  ==>  H{ { 1 4 } { 2 4 } { 3 4 } }
23:14:04 <thoughtpolice> Jessehk: just have fun with them, your brain will abstract away the details and it'll make 100% sense in 0 time.
23:14:07 <dons> reminds me of unification of substitutions in hindley-milner.
23:14:10 <slava> i've tried to think of this as a union of two graphs, and then one takes the transitive closure
23:14:25 <dons> where you find a subsitution, then have to walk of the rest of your substitutions to update the mapping.
23:14:27 <thoughtpolice> anyway i'm out
23:14:57 <sjanssen> slava: the rule is that a final path must alternate between 'left' and 'right' edges?
23:15:29 <slava> the "union" here is a hashtable whose set of keys is the union of the sets of keys of the two input hashtables
23:15:40 <slava> and the values are computed by 'following' key->value mappings
23:16:03 <byorgey> sjanssen: sounds like it doesn't matter whether they alternate
23:16:30 <byorgey> although if you start with 'reduced' mappings then they always will...
23:16:35 <dons> slava: right, sounds like the W algo in H-R type inference :-)
23:16:46 <dons> you have to do this for tracking type variable instantiation
23:16:55 <sjanssen> so how is this different from the transitive closure of a graph?
23:17:04 <slava> dons: this is used here to perform value substitutions in a compiler IR
23:17:23 <dons> tyvars:  a = b, b = c, c = Int, d = Int ==>  a = Int, b = Int, c = Int, d = Int
23:17:35 <slava> dons: i found that by 'composing' subsitutions and performing them in one sweep, a lot less work has to be performed, but it took me ages to figure out how to 'compose' two substitutions, specified as hashtables mapping values to values
23:17:40 <dons> slava: right. same thing as in H-R but on the value level.
23:17:56 <monochrom> transitive closure includes 1->2, 1->5, 2->5.  This one omits 1->2.
23:18:05 <dons> slava: i think this algo is described early on in Bob Harper's programming language design book
23:18:15 <sjanssen> ah, I see.  Prune the 'in between' edges
23:18:17 <slava> monochrom: there's no 1->2 because we already have 1->5
23:18:23 <dons> when he starts talking about substitutions on variables (in evaluators) and again on tyvars (in type inference)
23:18:26 <slava> the 'newer' substitution takes precedence
23:18:29 <dons> if you want a reference.
23:18:44 <dons> there's a neat way to do it with functions, iirc.
23:18:55 <dons> where 1 -> 2 literally is the function \1 -> 2
23:19:07 <dons> and then composition gives you a (\2 -> 3) . (\1 -> 2)
23:21:17 <jbauman> reminds me of a permutation group...
23:21:49 <slava> this is not quite a permutation because the maps are not necessarily one to one
23:22:01 <monochrom> except that you have an explicit 1->2 and an implicit 2->2. Not a permutation.
23:22:18 <jbauman> yeah
23:22:51 <dons> from Harper's chapter on type inference, building up sets of type constraints of type variables,
23:22:56 <jbauman> it isn't but it seems somewhat similar
23:23:04 <dons> (i.e. substituions from tyvar 'a' to some other type)
23:23:05 <dons> -- A constraint, \phi, pg 286 of Harper
23:23:05 <dons> --
23:23:05 <dons> -- "we may regard a constraint as a multiset (set with repetitions) of
23:23:07 <dons> -- unordered pairs of type schemes.
23:23:10 <dons> --
23:23:12 <dons> type Constraint = [(Type,Type)]
23:24:34 <dons> given sets of these things, you unify by substituting over pairs of constraints, till its all resolved, and there's no type errors. then you've got your type inference for all program variables. so similar
23:25:02 <dons> where you need, substitute :: Soln -> Type -> Type, and Soln is a mapping from Type -> Type
23:30:41 <byorgey> goodnight all!
23:30:45 <byorgey> > repeat 'z'
23:30:46 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
23:41:42 <sjanssen> slava: http://hpaste.org/1926 I'm curious whether this is the algorithm you've described
23:42:24 <Jessehk> Thanks for all the help everyone. It's highly appreciated. G'night. :)
23:42:52 <sjanssen> the unit tests seem to pass . . .
23:43:47 <slava> sjanssen: yes that looks like it
23:44:34 <sjanssen> is your (presumably) factor implementation that short? :P
23:44:55 <slava> http://hpaste.org/1927 -- the syntax highlighting is funny :)
23:45:29 <monochrom> The syntax is funny too :)
23:46:10 <dons> heh
23:46:11 <sjanssen> slava: will this code paths of length > 2?
23:46:20 <sjanssen> s/paths/take paths/
23:46:20 <slava> 'follow' is recursive
23:46:35 <slava> at* ( key assoc -- value ? ) -- returns two values
23:46:46 <slava> this is used in place of the Maybe type :)
23:47:08 <slava> at ( key assoc -- value ) is the one when you want to pun 'f' with no value
23:47:14 <dons> so its shorter due to the use of domain-specific combinators like union, pick/follow?
23:47:21 <slava> but its amazing how similar this is to the haskell code
23:47:27 <slava> pick is a shuffle word
23:47:55 <slava> the haskell code imports a 'union' function from Data.Map too
23:48:18 <dons> its interesting how often factor and haskell code appear quite similar.
23:48:25 <dons> whitespace + similar high level list/stack api
23:48:26 <sjanssen> slava: the H constructor takes a list of keys and a function from (key -> value)?
23:48:39 <slava> H{ } is a literal hashtable :)
23:48:48 <slava> map>assoc takes an 'example' association, and creates one of that type
23:49:08 <slava> hashtables are an implementation of associations, but other types exist too
23:49:24 <slava> if you want an array of pairs, you can use { } map>assoc -- { } is an array literal and sequences of pairs are associations
23:49:35 <slava> in haskell, you could do this all with type classes
23:49:38 <slava> and i'm sure you do
23:49:44 <dons> we should embed a little factor interpreter in lambdabot :-)
23:49:47 <dons> @factor some stuff here
23:49:48 <lambdabot> I know nothing about some
23:50:00 <slava> dons: how small is the ghc runtime?
23:50:14 <dons> its a micro kernel, so not so small :-)
23:50:25 <dons> > 1+2 -- but the plugin is small.
23:50:27 <lambdabot>  3
23:50:46 <dons> the ghc rts runs on bare metal with about 800 lines of asm to bootstrap it
23:50:54 <slava> dons: that's tiny.
23:50:55 <dons> as a proper multithreaded OS. kinda scary
23:51:04 <slava> is there any effort to bring a JIT to ghci?
23:51:07 <sjanssen> slava: what is nip?
23:51:21 <dons> slava: rather than the one pass bytecode compilation ghci currently uses?
23:51:27 <slava> sjanssen: http://factorcode.org/responder/help/show-help?topic=shuffle%2dwords
23:51:29 <lambdabot> Title: Shuffle words, http://tinyurl.com/24k9gl
23:51:41 <slava> dons: yeah. something like sbcl for haskell. an interactive compiler
23:52:05 <dons> not that i'm aware of. people seem happy to use native code libs, with interpreter current code, in ghci.
23:52:32 <dons> (ghci mixes native code and bytecode)
23:52:54 <slava> i guess an untyped bytecode interpreter is fast enough for many things
23:53:15 <dons> any time people care about speed, they just use the native compiler anyway.
23:53:28 <slava> still its nice having interactive compilation
23:53:34 <dons> ghci happens to be fast enough, but its really for exploratory work only.
23:53:43 <dons> yeah, for interactive experimenting, in particular
23:53:57 <sjanssen> ghci HEAD can do true compilation now
23:54:05 <dons> oh?
23:54:21 <sjanssen> yeah, I saw patches a few weeks ago
23:54:38 <slava> does it use ghc's code generator at run tme?
23:54:39 <dons> hmm, to native code? in memory?
23:54:42 <sjanssen> slava: yeah
23:54:46 <slava> neat
23:54:48 <sjanssen> dons: to .hi's and .o's
23:55:01 <slava> does it go through intermediate .o files?
23:55:05 <dons> oh, writes out .s files, get .o from that, link it.
23:55:05 <slava> or does it really compile in memory?
23:55:17 <dons> i don't think it would compile in memory, though hmm, harpy does that now.
23:55:25 <dons> the new in-memory x86 opcode generator
23:55:33 <sjanssen> yeah, it's just an interface to ghc's --make mode
23:56:22 <slava> for some reason, writing opcode assemblers is fun in a stack language. i imagine it is in haskell, too, because you use combinators to give an almost declarative description of the instruction set.
23:56:32 <slava> with varying amounts of hacks, depending on the CPU.
23:56:58 <dons> yeah. it almost reduces to pretty printing, so fun.
23:57:09 <slava> hah. that's one way of looking at it.
23:57:20 <slava> i haven't tackled disassemblers yet.
23:57:31 <slava> would be nice to specify an assembler and disassembler in one code unit
23:57:43 <dons> oh, hmm. nice idea.
23:57:49 <slava> i don't know if it is feasable.
23:58:01 <dons> I think it is.
23:58:20 <dons> wheras for grammars ther's usually several concrete syntaxes you can print out (and you have one)
23:58:27 <slava> for powerpc, i can see it working. but for x86, there is so much logic which is specific to every instruction group.
23:58:30 <dons> for opcodes, there's a nice one-to-one mapping between opcode and AST.
23:58:46 <dons> yeah, depends on how many scary variations you want to try
23:59:32 <dons> the native code gen really is a pretty printer in ghc,
23:59:34 <slava> one distrurbing thing about x86 is that it is redundant. for many instructions, there are many encodings which are functionally equivalent, but longer or shorter, and disassemblers display them the same way.
23:59:44 <slava> so its hard to get 1-1 disassembly iwth x86
23:59:46 <dons> the actual compilation is Cmm data type to ASM data type
23:59:52 <dons> then there's per-arch ppr,
23:59:53 <dons> pprAddr (AddrRegImm r1 i)
23:59:53 <dons>   = (<>) (pprImm i) (parens (pprReg r1))
