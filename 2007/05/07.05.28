00:04:21 <dons> hmm. there's a way to spot this
00:05:16 <nburlett> now none of my keymaps work :-<
00:05:25 <Jaak> @src retry
00:05:25 <lambdabot> Source not found. That's something I cannot allow to happen.
00:09:40 <nburlett> weird, xmonad doesn't work now
00:18:01 <jyp> @yo
00:18:01 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR REGIONS!
00:26:22 <nburlett> blah, I can't make the keyboard work nicely on mac os x
00:27:09 <dons> how so?
00:27:13 <dons> numlock?
00:27:25 <dons> nburlett: --> #xmonad is a good place to discuss
00:27:32 <dons> we're going through the release process
00:42:20 <arcatan> I wanna code a compiler
00:44:09 <mornfall> arcatan :-)
00:44:19 <mornfall> noone's holding you ;)
00:45:25 <arcatan> my limited knowledge is holding me
00:46:23 <Korollary> arcatan: There are several books online that walk you through it.
00:52:03 <newsham> nice, the haskell browser in programatica lets you click on identifiers in expressions and shows you their types
00:52:31 <mornfall> i said noone :-)
00:52:44 <mornfall> learn, young jedi ;-)
00:53:22 <newsham> ?seen glguy
00:53:23 <lambdabot> glguy is in #haskell. I last heard glguy speak 3d 16h 32m 15s ago.
01:37:51 <yakov> morning
01:41:40 <LeCamarade> Mornning.
01:42:04 <LeCamarade> Or evening, depending. Or afternoon.
01:42:51 <LeCamarade> @tell Philippa_ The Anglo-Haskell ... wow. You're the guy 'hind it, no?
01:42:51 <lambdabot> Consider it noted.
01:43:10 <LeCamarade> @tell Phi
01:43:10 <lambdabot> Consider it noted.
01:44:01 <LeCamarade> @tell Philippa_ Not that I'll be there. :o(
01:44:01 <lambdabot> Consider it noted.
01:46:46 <Korollary> LeCamarade: Yes, she is.
01:52:55 <LeCamarade> Korollary: Bon.
02:30:38 <LeCamarade> I hate exceptions, and I believe in my heart that all exceptions can be replaced with Maybe-ism.
02:30:54 <LeCamarade> Even the sane, functional exceptions of OCaml.
02:31:35 <LeCamarade> Even DivisionByZero. Or hGetLine-got-EOF-from-stdin.
02:31:54 * LeCamarade is pissed with this Matho-puritans!!!
02:34:01 <ejt> ocaml exceptions are sane and functional ?!
02:37:49 <MyCatVerbs> ejt: dude comes into a room with nick set to "LeCamarade"
02:38:18 <MyCatVerbs> ejt: and you don't immediately assume a pro-OCaML bias on the basis of Frenchness? Who's been drugging your coffee?
02:38:33 <LeCamarade> ejt: They are sane and functional. At least they return. Nothing Java-like.
02:38:43 <LeCamarade> MyCatVerbs: :oD
02:38:48 <MyCatVerbs> LeCamarade: ?
02:39:07 <ejt> LeCamarade: I always found them imperative and ugly
02:39:09 <LeCamarade> MyCatVerbs: :-D, alright.
02:39:11 <MyCatVerbs> LeCamarade: they do something like call setjmp(), throw the exception then allow you to longjmp() back into place?
02:39:24 * LeCamarade writes smileys with a big nose.
02:39:34 <MyCatVerbs> LeCamarade: I wasn't critiquing your smiley, I was after further elaboration, heh. ^_^
02:40:07 <LeCamarade> MyCatVerbs: ^_^ Work of art.
02:40:25 <MyCatVerbs> LeCamarade: nahhh. Stolen from random Korean people and shrunk in the middle. =)
02:41:03 <opqdonut> exceptions are nicer in the way that you don't have to handle them unless you want to
02:41:09 <LeCamarade> ejt: They are evil, yeah. I hate exceptions. But they return stuff - the last expression is returned. They don't go alterting data and leaving you unstable. So even the catch has to return the same type. That's much, much better than Language X.
02:41:17 <opqdonut> with maybeism you are made explicitly aware of the "exceptions"
02:42:03 <LeCamarade> I am for Maybe-ism - because then you have a value returned to you, which may or may not indicate an error. You are forced by the type system to deal with it.
02:42:06 <ejt> LeCamarade: saying something is better than Java isn't going to persuade a lot of people here ;)
02:42:27 <LeCamarade> ejt: I understand.
02:42:32 <LeCamarade> @quote java'
02:42:32 <lambdabot> dons says: Java's type system is unsuitable for young children, the elderly or infirm of constitution
02:42:34 <LeCamarade> @quote java
02:42:34 <lambdabot> java says: public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
02:42:40 <LeCamarade> ^^
02:42:49 <ejt> lol
02:42:59 <LeCamarade> :oD
02:43:25 <LeCamarade> When I saw public static void main, I just had to go back to pushl, popl, movl and friends.
02:43:31 <ejt> (and I agree about using Maybe, [] or some other monad to rep failure)
02:43:47 <MyCatVerbs> ejt: we should use a duck instead.
02:44:01 <ejt> duck ?
02:44:06 <LeCamarade> But tha problem is that many, many things can fail. And without exceptions, you end up with a valley of maybes.
02:44:23 <MyCatVerbs> data Duck x = Quack | QuackQuack x
02:44:29 <LeCamarade> Every division can fail, you know. Could be by zero.
02:44:35 <mux> LeCamarade: it's not so bad when you use the maybe monad, it avoids a lot of boilerplate code
02:44:38 <MyCatVerbs> ejt: like Maybe, but you implement a getEgg function.
02:44:43 <LeCamarade> MyCatVerbs: I see you're being very artistic .... :oD
02:44:46 <MyCatVerbs> LeCamarade: mmmmm, nope.
02:44:57 <ejt> :)
02:45:02 <LeCamarade> mux: I'm for welding syntax around it.
02:45:23 <MyCatVerbs> LeCamarade: division by zero is quite perfectly fine in the universe of IEEE 754. Just returns positive or negative infinity, as appropriate. ^^
02:45:23 <LeCamarade> After all, aren't True and False just aristocratic constructors?
02:45:51 <LeCamarade> MyCatVerbs: And how are you going to proceed with my bank balance when given Infinity?
02:46:03 <LeCamarade> > 0 1 / 0 -- Infinity, but what then?
02:46:05 <kaol> @quote lisp
02:46:05 <lambdabot> psykotic says: Let me get this straight: in your tireless Lisp-bashing efforts you have now dragged out Prolog as an exemplar of practicality? *Prolog*? My goodness, you must be desperate!
02:46:06 <lambdabot>   add an instance declaration for (Num (t -> a))
02:46:12 <LeCamarade> > 1 / 0 -- Infinity, but what then?
02:46:14 <lambdabot>  Infinity
02:47:04 <andun> > 1 / -0
02:47:04 <lambdabot>      precedence parsing error
02:47:04 <lambdabot>         cannot mix `(/)' [infixl 7] and prefix ...
02:47:10 <LeCamarade> High-powered heart drill drill gets back infinity. What then? [Answers should try to be sympathetic. :o)]
02:47:46 <MyCatVerbs> LeCamarade: not really a problem for me. =)
02:47:50 <andun> > 1 / (-0)
02:47:51 <lambdabot>  -Infinity
02:48:20 <MyCatVerbs> LeCamarade: all incorrect results are equally bad in banking systems. It's better for the machine to spontaneously burst into flame than ever produce an incorrect result.
02:48:53 <MyCatVerbs> LeCamarade: flames merely lead to broken equipment and possibly dead people. Whereas banking systems that give out incorrect answers? Those cause lawyerin' to commence.
02:51:13 <kral> for a beginner, is it better "The Haskell School of Expression" or "Haskell: The Craft of Functional Programming"?
02:53:00 <ibid> kral: depends on the beginner
02:55:25 <kral> ibid: i have a little knowledge of fp, i've been thought yaht and some chapters of "practical common lisp" (i know it's not haskell, but...)
02:55:56 <kral> also, my math skills are not so good :)
02:55:57 <opqdonut> SICP is best for anyone :):):)
02:56:19 <opqdonut> SOE is for people who want to get fast results
02:56:21 <opqdonut> see something spiffy
02:56:33 <opqdonut> haven't tried CoFP
02:56:51 <kral> opqdonut: i know sicp, but i don't want to learn scheme, but haskell :)
02:57:04 <kaol> I'm still hoping that I'd learn Haskell well enough without buying a book
02:57:05 <opqdonut> many things in sicp apply to haskell
02:57:25 <opqdonut> in my experience, learning some haskell syntax and coding a little bit first and then reading SICP is a good idea
02:57:36 <opqdonut> it really "blows your mind"
02:58:36 <MyCatVerbs> kaol: except for macros, most things you could write in Scheme you can also express relatively straightforwardly in Haskell too, by adding millions of damn brackets everywhere, hee.
02:58:58 <MyCatVerbs> kaol: except call/cc and friends, I guess. >>
02:59:23 * kaol does not know of this "Scheme" thing
02:59:49 <kral> well, maybe i can do a few sicp exercises in haskell, but this doesn't answer my question :)
03:02:13 <dolio> @type callcc
03:02:16 <lambdabot> Not in scope: `callcc'
03:02:37 <dolio> @type callCC
03:02:39 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
03:02:42 <dolio> There we are.
03:03:39 <MyCatVerbs> dolio: holy shit.
03:04:28 <nominolo> ?src concatMap
03:04:28 <lambdabot> concatMap f = foldr ((++) . f) []
03:04:36 <Heffalump> it's like (>>=), but backwards ;-)
03:04:40 <LeCamarade> kral: No single tutorial does it for Haskell. You'll have to mix them a bit.
03:04:47 <MyCatVerbs> kral: hee. Hrmn. I dunno which textbooks are how good.
03:04:57 <MyCatVerbs> kral: personally, I buzzed the meta-tutorial, mainly.
03:04:59 <dolio> Just write all your code in the (ContT IO) monad. That's scheme. :)
03:05:01 <nominolo> @check \f xs -> concatMap f xs == (concat . map f xs)
03:05:02 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
03:05:05 <LeCamarade> You may use the YAHT and the Wikibooks thing.
03:05:11 <nominolo> @check \f xs -> concatMap f xs == (concat (map f xs))
03:05:12 <lambdabot>  Add a type signature
03:05:24 <nominolo> @check \f xs -> concatMap f xs == (concat (map f (xs :: [Int])))
03:05:24 <lambdabot>  Add a type signature
03:06:32 <nominolo> :t \f -> concat . map f
03:06:34 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
03:06:39 <LeCamarade> kral: And if it is functional that you want, why think of anything else? Haskell only.
03:09:39 <kral> LeCamarade: you're right
03:19:29 <Jaak> @check \f xs -> concatMap f xs == (concat (map (f :: Int -> [Int]) (xs :: [Int])))
03:19:35 <lambdabot> Terminated
03:19:38 <dcoutts_> Excedrin: btw, yes the clock window is scalable by middle or right clicking it, I can't remember which one
03:19:54 <dcoutts_> one scales, the other moves
03:30:20 <earthy> drat. the existing libexif bindings don't allow writing.
03:44:38 <aleator> Should I expect a performance increase if I do forkOS in multiprocessor machine?
03:45:17 <matthew-_> aleator: what version of ghc?
03:45:19 <Lemmih> aleator: Yes.
03:45:29 <aleator> 6.6
03:45:39 <aleator> Hmm. This is quite odd then.
03:45:57 <matthew-_> then use forkIO and start up ghc with +RTS -N $numCores$ -RTS
03:47:17 <aleator> Aha. Silly me. My build script says -N2 instead of -N8.
03:47:47 <matthew-_> thus two cores in use. Presumeably xosview or similar should show you the loading
03:47:55 <aleator> Well. Seems I get an extra coffeebreak for forgetting this.
03:48:48 <int-e> hmm, but you'll need a similar RTS option when running your program.
03:49:44 <aleator> int-e: do I? It seems to be utilizing 2 cores even without?
03:50:05 <int-e> hm..
04:05:26 <TSC> Is there a good way to do fast parsing with Bytestring?
04:05:46 <dcoutts_> TSC: alex has bytestring support
04:05:49 <TSC> Parsec doesn't currently support it, IIRC
04:05:50 <Lemmih> Lexer + parsec?
04:06:10 <TSC> Ah, thanks
04:06:16 <dcoutts_> TSC: alex is a lexer of course
04:06:19 <TSC> Is it hard to write a fast lexer?
04:06:23 <TSC> Ah
04:06:28 <TSC> alex + parsec, then?
04:06:39 <dcoutts_> sounds reasonable
04:06:50 <TSC> Terrific, thanks guys
04:06:51 <dcoutts_> alex also works well with happy
04:07:12 <TSC> Ok (but I already know parsec, so I'll start with that)
04:07:39 <dcoutts_> TSC: I think only the darcs version of alex has the extra bytestring wrapper, with the current released version you need a little extra code
04:07:59 <TSC> Thanks, I don't mind using the darcs one
04:26:25 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/80
04:26:44 <Mitar> does haskell reuse this code?
04:27:06 <Mitar> or should i manually put those constants one level higher?
04:27:32 <Mitar> as only n is changing ... other values are constants ...
04:27:33 <Mitar> http://hpaste.org/80
04:27:35 <pjd> any Python hackers about?
04:28:18 <pjd> i'm looking at PEP 3119, and it seems interestingly like type classes
04:29:01 <bXi> are there any haskell tools for symbian s60v3 phones?
04:29:27 <Lemmih> Mitar: It's up to the compiler.
04:29:35 <Mitar> bxi, i think it does not have the power ...
04:29:49 <Mitar> hmm, but ghc deos this?
04:29:55 <Mitar> s/deos/does/
04:30:22 <dancor> how do you get the current user's username in haskell
04:30:59 <bXi> Mitar: i doubt that
04:32:51 <Mitar> bah
04:33:15 <Mitar> this should be really simple ...
04:34:29 <Saizan> the problem is that "caching" is not always a win, and it's not easy to determine when it is
04:34:55 <pjd> profiling
04:37:16 <Saizan> i meant for the compiler..
04:38:49 <pjd> Saizan: sorry, reflex
04:39:46 <hpaste>  Saizan annotated "(no title)" with "this will probably cache more" at http://hpaste.org/80#a1
04:45:17 <Mitar> it is a difference, 10 % speedup
04:45:30 <Mitar> (of course this is only a part of the code)
04:45:41 <Lemmih> Mitar: Even with -O2?
04:45:50 <Mitar> hmm, noo
04:45:52 <Mitar> good question
04:46:00 <Mitar> i was checking without it ...
04:47:14 <Mitar> or yes ... with it ...
04:47:29 <Mitar> i forgot that it have it on all the time ..
04:47:44 <Mitar> so with -O2 there is 10 % speedup if i move manually code
04:47:53 <Mitar> which could be reused elsewhere ..
04:48:35 <Mitar> i have another question ... i understand that if i want to store some IO data from one function for use in another i should use IORef
04:48:52 <Mitar> but the problem is that then GHC does not cache this second function
04:49:27 <Mitar> and even if I do not change the IORef value it reevaluates whole seconf function again every time
04:49:57 <Mitar> why is there no "dirty" flag so that GHC would know that I never called modify or something on IORef and that it can reuse old value?
04:50:03 <Lemmih> How about just passing the data from one function to the other?
04:50:54 <Mitar> i cannot ... those functions are called in OpenGL callbacks
04:50:55 <Lemmih> You are most likely creating multiple IORef's.
04:51:19 <Mitar> first callback is storing some value it gets from user into IORef
04:51:24 <Mitar> the other is drawing the window
04:51:38 <Mitar> and even if there is no change in the IORef (no user input) and I get a window redraw
04:52:06 <Lemmih> paste?
04:52:37 <Mitar> in reevaluate whole callback (ok, i understand that it evaluates monad actions, but i would like that it does not reevaluate functional part of the actions)
04:53:26 <Lemmih> Why do you care and how did you notice?
04:53:52 <Mitar> because one redraw takes 40 seconds
04:54:03 <Mitar> and it happens every time i move the window around
04:54:18 <Lemmih> The redraw is pure?
04:54:23 <Mitar> (even if it could just draw the calculated data - not recalculate it)
04:54:29 <Mitar> no, it is a monad
04:54:46 <Mitar> but the data it is drawing was pure ... then it took only fraction of a seconf
04:54:57 <Lemmih> paste?
04:55:01 <Mitar> now, when i added IORefs as a parameters to functional part ..
04:55:01 <Mitar> yes ..
04:55:16 <Mitar> a moment
04:55:47 <Mitar> http://www.druga.org/~mitar/Temp/Main.hs
04:56:23 <Mitar> currently i never even change the IORef
04:56:29 <Mitar> but it still reevaluates it ...
04:56:43 <Lemmih> re-evaluates the IORef?
04:56:58 <Mitar> no
04:57:09 <Lemmih> The contents of the IORef seems pretty strict already.
04:57:17 <Mitar> reevaulates the functional part of the drawin actions which uses ioref as a parameter
04:57:44 <Mitar> i understand it reevaluates them when IORef changes
04:58:04 <Mitar> but why does it reevaluate it when IORef does not change ..
04:58:14 <Mitar> so: i think there should be some dirty flag
04:58:39 <Saizan> Mitar: you should give up thinking that lazy evaluation means memoization
04:58:40 <Lemmih> GHC doesn't do advanced/dangerous caching.
04:59:03 <Mitar> hmm, so how could i do this then?
05:01:18 <ToRA> Mitar, can't you put the result of rendering in an IORef, or probably better, use a DisplayList for the glCalls and pass that around in an ioref?
05:02:36 <Mitar> displaylist?
05:03:03 <Mitar> let's see ...
05:03:07 <ToRA> opengl DisplayList
05:03:18 <Mitar> yes ... i am searching now ..
05:03:28 <Mitar> thanks for the pointer
05:04:00 <ToRA> dl <- defineNewList Compile (rendering code)  ; then when you want to actually do the rendering; callList dl
05:04:12 <ToRA> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-DisplayLists.html#t%3ADisplayList
05:04:15 <lambdabot> http://tinyurl.com/278rxm
05:05:23 <Mitar> nice ...
05:05:40 <Mitar> (i doubt i will finish my homework in two hours when it is due ... :-) )
05:05:49 <Mitar> (i am making a raycasting engine in haskell)
05:06:03 <ToRA> ah
05:06:40 <Mitar> (i definitely complicate way too much)
05:12:41 <Mitar> great, i get a white screen now :-)
05:13:29 <ToRA> is that progress, or a step backwards?
05:13:39 <Mitar> step backwards ...
05:13:48 <Mitar> it means that it does not draw the list i generate
05:14:02 <Mitar> eh... of course :-)
05:14:05 <Mitar> i do not execute it ...
05:14:06 <Mitar> heh
05:15:16 <Mitar> thanks ...
05:15:25 <ToRA> now white any more?
05:15:25 <Mitar> i am still learning opengl ..
05:15:35 <Mitar> it works now ...
05:15:48 <Mitar> i will just cache into ioref now this displaylist
05:16:10 <Mitar> and then check if that ioref from before changes ... if not i will just execute the list ...
05:17:03 <ToRA> when the display list needs to change, recompile it on the same display list, (use defineList)
05:17:33 <ToRA> and then you never need to check if the ioref changes, and in render just always execute the list
05:17:52 <ToRA> (well unless you have other data in the ioref)
05:18:10 <Mitar> ohh .. yes :-)
05:18:37 <Mitar> you are opening me whole new horizonts :-)
05:18:38 <Mitar> thanks ...
05:19:05 <ToRA> you only want one defineNewList - (and then need to use deleteLists [dl] should you ever want to delete them) - displayLists arnt garbage collected iirc
05:19:07 <Mitar> i think that there is too little examples of working opengl code in haskell
05:20:04 <ToRA> the only thing i ever found was michi's blog which was quite good.  But since you're using iorefs, I assume you've seen that already
05:20:05 <ToRA> ?
05:20:22 <matthew-_> ToRA: mmm. I wonder if there's some reason you can't put a finaliser on the displaylist
05:20:37 <matthew-_> is it some pointer to a structure on the gpu-card?
05:20:57 <ToRA> i think you probably can, it's possible that you may loose the pointer, but it is still nested inside another displayList, so you have to be careful
05:21:31 <ToRA> (i.e. it's a sensible default, as pointers to it may exist that arn't in haskell memory)
05:21:42 <Mitar> oh, i have not found this tutorial yet ...
05:21:43 <matthew-_> gotcha
05:21:43 <Mitar> thanks :-)
05:21:48 <ToRA> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
05:21:52 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ( ..., http://tinyurl.com/ea6tc
05:22:23 <ToRA> mmm, did the utf-8 chars render there for anyone or did lambdabot mangle them on output?
05:22:55 <Mitar> has anybody done any work on running haskell code on gpu?
05:23:23 <ToRA> i'm thinking about looking into it.
05:23:29 <Mitar> really?
05:23:35 <Mitar> i was thinking also about that ..
05:23:38 * ToRA has opengl shader book sitting on a shelf begging to be used
05:23:43 <Mitar> but have probably too little knowledge ...
05:23:56 <ToRA> i have no knowledge, but am interested in learning
05:23:58 <Mitar> but i thought it would be interesting to port this raycaster to the gpu
05:24:01 <ClaudiusMaximus> Mitar: is your raycaster using CSG-type models?  i've been hacking on a 4D raytracer (originally written in C by someone else), would be interesting to rewrite in Haskell at some point, because i don't fancy adding CSG models to the C version....
05:24:30 <Mitar> my raycaster is more voxel based ...
05:25:00 <Mitar> or more precisely ... you define a "word" function which takes x y z coordinates and return color of that voxel
05:25:08 <ClaudiusMaximus> Mitar: oh ok
05:25:40 <Mitar> i wanted to use it for 3d fractals, voxel rendering and probably some other mathematical projections
05:25:45 <matthew-_> mmm. if the interface is there, there's a lot of interesting stuff that can be done on the GPU.
05:26:05 <matthew-_> I guess much depends on how good the drivers are and how much access you can get to the hardware
05:26:42 <Mitar> raycasting is very easy to parallel as every pixel is independed from others ...
05:27:07 <Mitar> so it would be nice to store few "rays" into gpu and let gpu calculate the pixels
05:30:04 <ToRA> i don't suppose there's a magical way of aliasing all functions that use (IO a) in a module to something else (like (OpenGL a))?
05:30:45 <Saizan> type OpenGL = IO? :)
05:30:48 <ToRA> where OpenGL a is a  newtype OpenGL a = OpenGL { runGL :: IO a }
05:30:52 <Mitar> :-)
05:31:02 <ToRA> Saizan: i want a type-system enforced separation
05:31:03 <matthew-_> Mitar: I was meaning more general tasks. The GPU is the most powerful chip in your computer, if you measure flops. The R600, for example, is a staggaringly powerful device, that'll probably never be used fully by a game..
05:31:40 <Saizan> ToRA: i think you need to write your own wrappers
05:31:51 <ToRA> Saizan: yeah, i was afraid of that
05:32:11 <Mitar> matthew-_: i know, it would be great if we could haskell runtime would see it just as an another cpu in a machine :-)
05:32:44 <Mitar> but the problem is that gpus have their limitations - floating point calculating are not strict IEEE ...
05:33:30 <matthew-_> Mitar: floats have their limitations - they don't do maths ...
05:33:46 <Mitar> :-)
05:34:23 <Mitar> so, who will do it? so that i will be able to do program +RTS -N2 -G1 to run on two cpus and one gpu
05:34:24 <Mitar> :-)
05:34:52 <Heffalump> it's probably more realistic to treat it as a target for data-parallel haskell
05:34:55 <matthew-_> Mitar: apparently, the compiler / jit suite which is available for the R600 and similar from nvidia may get you close to being able to treat it as a cpu. But you really have to have you head screwed on right - the mixture of multi-SIMD and limited instruction mix gets very complex, very quickly
05:36:34 <Mitar> i will leave this simple things to GHC people to think about :-)
06:46:20 <emu> hmm, i'm looking to use "floor" on values of class Num in general, not just RealFrac. any ideas?
06:46:55 <emu> > floor (1::Int)
06:46:58 <lambdabot>   add an instance declaration for (RealFrac Int)
06:46:58 <lambdabot>     In the expression: floor...
06:48:01 <twanvl> What sould floor (1::Int) do?
06:48:06 <emu> just return 1
06:48:18 <emu> sometimes i am dealing with integers, and sometimes i am dealing with doubles
06:48:26 <emu> i want to use the same code for both
06:48:36 <Heffalump> just declare RealFrac for Int and Integer?
06:48:38 <twanvl> You could make a class ToInt a where toInt :: a -> Int
06:49:20 <twanvl> (Or very evil: use fromEnum)
06:49:27 <Heffalump> oh, I guess you'd ahve to define /, recip and fromRational
06:49:31 <emu> yea
06:49:45 <Heffalump> well, make some other class that just has floor etc in it (hiding the real ones)
06:50:16 <Heffalump> if you didn't mind non H98 instances, you could even have instance Integral a => Floor a and instance RealFrac a => Floor a
06:51:06 <Saizan> ?type flooe
06:51:07 <Saizan> ?type floor
06:51:08 <lambdabot> Not in scope: `flooe'
06:51:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:51:19 <emu> yea i will do the ToInt idea i guess
07:01:08 <pjd> emu: Nums in general might not sensibly support the notion of floor
07:12:43 <hpaste>  (anonymous) pasted "newtype deriving MonadTrans" at http://hpaste.org/81
07:13:23 <sorear> Because FooMonad isn't a monad transformer.
07:13:31 <sorear> The arguments are in the wrong order
07:13:40 <pjd> > let fromIntegral x = fromInteger (toInteger x) in floor $ fromIntegral (5::Int)
07:13:43 <sorear> you need to have the base monad second-to-last
07:13:48 <lambdabot>  5
07:13:49 <sorear> @src StateT
07:13:49 <lambdabot> Source not found. stty: unknown mode: doofus
07:13:58 <sorear> @ki StateT
07:13:58 <pjd> emu: something like that?
07:14:00 <lambdabot> * -> (* -> *) -> * -> *
07:15:35 <sorear> newtype FooMonad a b m c = FooMonad { state:: StateT (FooState a b) m c} deriving (MonadTrans)
07:15:38 <sorear> should work
07:18:12 <emu> > let fromIntegral x = fromInteger (toInteger x) in floor $ fromIntegral (5.3::Double)
07:18:13 <lambdabot>   add an instance declaration for (Integral Double)
07:20:00 <Saizan> if you have foo s = "foo " ++ (toplevelconstant1 ++ ("bar " ++ s)), every call of foo would reevaluate all the ++ right?
07:20:28 <fasta> sorear: isn't it just because the current newtype mechanism is not smart enough? It seems not a fundamental propery to be in second-last position.
07:20:54 <fasta> sorear: it does work, thanks.
07:21:04 <pjd> emu: you'll probably want to do the conversion more outside, at the point where the code first expects RealFrac instances
07:21:35 <Botje> Saizan: not necessarily. if the compiler does its work properly, there should be only 1 ++ operation at runtime
07:21:46 <Botje> or at least after evaluating it once, i think
07:21:53 <Saizan> instead with fooc =  "foo " ++ toplevelconstant1 ++ "bar ", foo s = fooc ++ s, the first 2 are shared, but now the last ++ is more expensive ..
07:23:12 <sorear> fasta: it's part of the definition of the MonadTrans class
07:23:17 <sorear> @src MonadTrans
07:23:17 <lambdabot> Source not found. That's something I cannot allow to happen.
07:23:24 <pjd> emu: in other words, the code doing the flooring should just expect a RealFrac, and the code that calls it should be responsible for converting Int/Integer values
07:23:26 <sorear> @kick lambdabot
07:23:26 <lambdabot> Maybe you meant: dice dict kind
07:23:51 <sorear> @ki MonadTrans
07:23:53 <lambdabot> Class `MonadTrans' used as a type
07:24:17 <emu> it goes back too far
07:24:23 <sorear> class MonadTrans t where
07:24:27 <sorear>  lift :: Monad m => m a -> t m a
07:24:37 <fasta> sorear: ok
07:24:38 <emu> it's got to be an Int or a Double all the way to this point, and it's gotta stay as an Int or a Double when it returns
07:24:43 <ToRA> @info MonadTrans
07:24:43 <lambdabot> MonadTrans
07:24:55 <emu> the flooring was just used for one particular computation
07:24:58 <fasta> instance MonadST s m => MonadST s (ContT r m) where
07:24:58 <fasta>      liftST = lift . liftST
07:24:58 <fasta> instance MonadST s m => MonadST s (StateT v m) where
07:24:58 <fasta>     liftST = lift . liftST
07:25:02 <sorear> ToRA: there is no @info
07:25:21 <fasta> Is it possible to unify these definitions into one using a MonadTrans constraint?
07:25:34 <sorear> Yes.
07:25:38 <Saizan> Botje: i've found a compromise (which is what ShowS do, but it clicked just now) foo = ("foo " ++).(constant ++).("bar"++)
07:26:06 <sorear> It requires incoherent AND undecidable instances however...
07:26:31 <pjd> emu: then the client code should probably doing the converse after the call, converting the RealFrac back to the appropriate integral type
07:27:00 <emu> but only when it is in fact an Int...
07:27:19 <pjd> right, it would depend on the caller
07:27:30 <emu> the caller doesn't know, it's quite generic
07:27:49 <pjd> with the caller, i mean whoever does know about the Int
07:27:53 <fasta> instance (MonadST s m, MonadTrans t) => MonadST s (t m) where liftST st = lift . liftST
07:28:05 <fasta> This is what I would expect should work, but doesn't.
07:28:11 <emu> naw i'll just stick with the class, it's local
07:28:27 <emu> this is not a small program
07:28:39 <fasta> oops
07:29:07 <fasta> instance (Monad (t m), MonadST s m, MonadTrans t) => MonadST s (t m) where liftST = lift . liftST
07:29:11 <fasta> This seems to work
07:29:54 <sorear> fasta: Good luck writing the MonadST s (ST s) instance.
07:30:52 <fasta> instance MonadST s (ST s) where liftST = id
07:31:07 <fasta> sorear: did you mean to imply that was impossible or was it a joke?
07:36:21 <Newbiehaskell> hi all
07:36:41 <Newbiehaskell> i m a totally newbie on haskell, so i have a question for u
07:36:46 <mauke> welcome back my friends to the show that never ends
07:37:12 <LeCamarade> Newbiehaskell: The question?
07:37:12 <lambdabot> LeCamarade: You have 1 new message. '/msg lambdabot @messages' to read it.
07:37:13 <mauke> I'm so glad you could attend; come inside, come inside
07:37:24 <Newbiehaskell> why i cant do this? type x = [(char,Int)]
07:37:25 <LeCamarade> mauke: :oD
07:37:46 <mauke> Newbiehaskell: x and char must start with an uppercase letter
07:38:20 <fasta> Newbiehaskell: Not in scope: type variable `char'
07:38:21 <mauke> that's how haskell distinguishes between type constants and type variables
07:38:24 <Newbiehaskell> so then..... type X = [(Char,Int)]?
07:38:27 <mauke> yes
07:38:39 <gidyn> @vixen Hello
07:38:39 <lambdabot> <undefined>
07:38:43 <Newbiehaskell> ok i would try it
07:39:11 <gidyn> The lambdabot's vixen need fixen'
07:39:22 <Newbiehaskell> negatice to that , not in scope on ghci
07:39:58 <mauke> you can't type type declarations into ghci
07:40:05 <Newbiehaskell> well i have a problem with tuples with diferentes types
07:40:17 <mauke> put it in a file
07:40:22 <pjd> s/declarations/definitions/
07:40:28 <mauke> er, yes
07:40:43 <Newbiehaskell> i would do a list  with type [(Char, Int)]
07:40:58 <Newbiehaskell> but i cant do it
07:41:17 <mauke> > [('a', 1), ('b', 2)]
07:41:25 <lambdabot>  [('a',1),('b',2)]
07:41:34 * fasta thinks it might be a good idea to have ghci recognize the case of someone trying to do type <foo> = <bar> or f = <bar> and then tell the user to put the definitions in a file. This is a major FAQ.
07:41:44 <pjd> fasta: indeed
07:41:51 <LeCamarade> fasta: Aye.
07:41:55 <mux> > zip ['a'..'z'] [1..]
07:41:57 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j...
07:42:22 <Newbiehaskell> zip [a..z][1..26]?
07:42:49 <Newbiehaskell> why 'a' instead a
07:42:58 <kpreid> Newbiehaskell: a is a variable, 'a' is a character
07:43:05 <mauke> > [a .. z]
07:43:05 <lambdabot>   Not in scope: `z'
07:43:09 <Newbiehaskell> roger that
07:43:15 <Newbiehaskell> i understand now
07:43:17 <kpreid> and you don't need to specify 26 because zip stops at the first end of list
07:43:20 <LeCamarade> > ['a', 'b']
07:43:21 <lambdabot>  "ab"
07:43:26 <LeCamarade> ^^
07:43:29 <Newbiehaskell> thanks a lot
07:43:31 <mauke> > zip ['a' ..] [1 ..]
07:43:32 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j...
07:44:35 <kpreid> @let zip' xs ys = (head xs, head ys) : zip' (tail xs) (taiil ys)
07:44:35 <lambdabot> <local>:2:50: Not in scope: `taiil'
07:44:39 <kpreid> @let zip' xs ys = (head xs, head ys) : zip' (tail xs) (tail ys)
07:44:41 <lambdabot> Defined.
07:44:45 <kpreid> @type zip'
07:44:47 <lambdabot> Not in scope: `zip''
07:45:03 <desp> haskell runs several lightweight threads in a single native thread, right?
07:45:41 <mauke> ghc does, by default
07:45:53 <mauke> I think you can change that with command line options
07:46:19 <desp> mauke: do you know what hugs does?
07:46:25 <mauke> no
07:46:31 <gidyn> @help src
07:46:31 <lambdabot> src <id>. Display the implementation of a standard function
07:46:41 <gidyn> @help url
07:46:42 <lambdabot> url <key>. Return element associated with key
07:46:47 <gidyn> @url me
07:46:47 <lambdabot> I know nothing about me.
07:46:53 <Newbiehaskell> is more intuitive visual haskell  to write scripts?
07:47:01 <gidyn> @help slap
07:47:01 <lambdabot> slap <nick>. Slap someone amusingly.
07:47:07 <gidyn> @slap gidyn
07:47:08 * lambdabot slaps gidyn
07:47:20 <desp> gidyn: you can privmsg the bot as well :)
07:47:21 <sorear> fasta: http://hackage.haskell.org/trac/ghc/ticket/1387
07:47:23 <lambdabot> Title: #1387 (Ad-hoc recognition for attempts to use Haskell top-level syntax in the GH ...
07:48:04 <gidyn> Sorry, typing in the wrong buffer
07:48:09 <gidyn> \me blush
07:48:31 <kpreid> > map fst $ L.zip' [1..] []
07:48:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:49:53 <sorear> Also, zip' ~(x:xs) ~(y:ys) = (x,y) : zip' xs ys
07:51:03 <kpreid> ah, that's better.
07:51:28 <Newbiehaskell> > [ (x,y) | x<-['a'..'z'], y<-[1..] ]
07:51:29 <lambdabot>  [('a',1),('a',2),('a',3),('a',4),('a',5),('a',6),('a',7),('a',8),('a',9),('a...
07:52:06 <fasta> sorear: http://hackage.haskell.org/trac/ghc/ticket/1388 ;)
07:52:07 <lambdabot> Title: #1388 (Newbie help features) - GHC - Trac
07:52:10 <Newbiehaskell> [ (x,y) | x<-['a'..'z'], y<-[1..26] ]
07:52:44 <Newbiehaskell> >[ (x,y) | x<-['a'..'z'], y<-[1..26] ]
07:54:12 <kpreid> Newbiehaskell: the space after > is required
07:54:18 <Newbiehaskell> is fata replies some kind of IA?
07:54:23 <Newbiehaskell> *fasta
07:54:26 <kpreid> fasta is not a bot.
07:54:37 <Newbiehaskell> thanks
07:54:58 <Newbiehaskell> > [ (x,y) | x<-['a'..'z'], y<-[1..26] ]
07:54:59 <lambdabot>  [('a',1),('a',2),('a',3),('a',4),('a',5),('a',6),('a',7),('a',8),('a',9),('a...
07:55:03 <jfredett> watch, try to give him a botsnack
07:55:10 <Heffalump> @botsnack
07:55:11 <lambdabot> :)
07:55:15 <fasta> Yammie
07:55:16 * jfredett tosses a botsnack @ fasta
07:55:20 <Heffalump> if fasta is a bot, he's much slower
07:55:55 <SamB_XP> you might even call him slowa
07:56:13 <jfredett> da dum tcshhhh
07:56:43 * SamB_XP wonders if fasta found where lambdabot stashes her botsnacks
07:57:11 <fasta> Why do you say if fasta is a bot he's much slower?
07:57:14 <Newbiehaskell> [ (x,y) | x<-['a'..], y<-[1..] ]
07:57:33 <Newbiehaskell> > [ (x,y) | x<-['a'..], y<-[1..] ]
07:57:34 <lambdabot>  [('a',1),('a',2),('a',3),('a',4),('a',5),('a',6),('a',7),('a',8),('a',9),('a...
07:57:35 <SamB_XP> fasta: you took 5 seconds longer to respond
07:57:47 <fasta> Is it because of your plans that you say I took 5 seconds longer to
07:57:48 <fasta> respond?
07:58:09 <kpreid> Newbiehaskell: you're not going to see the difference because lambdabot truncates the output before the difference appears. try it in your own ghci
07:58:19 <SamB_XP> why have you pitted me against doctor-mode?
07:58:24 <Newbiehaskell> ok i w do
07:58:34 <fasta> What do you think?
07:58:34 <jfredett> Newbiehaskell, why not try [ (x,y) | x <- [1..], y<- ['a'..'z'] ]
07:58:46 <jfredett> then you just have to deal with a reversal
07:59:24 <fasta> SamB_XP: You figured out that pretty fast.
07:59:27 <jfredett> just a thought, but it looks like x never gets to the 'b' part,
08:00:29 <Newbiehaskell> nope, instead of ('a',1),('a',2) im trying to reach ('a',1), ('b',2) etc without zip
08:01:43 <kpreid> Newbiehaskell: ah, you want parallel list comprehensions (which is a ghc extension)
08:01:59 <kpreid> or, don't use list comprehensions
08:01:59 <SamB_XP> fasta: that "Is it because of your plans" was a pretty good clue
08:02:39 <kpreid> Newbiehaskell: when you do [ ... | x <- ..., y <- ... ] you're asking for the cross product, not zipping
08:02:58 <Newbiehaskell> then?
08:02:58 <Heffalump> > [(x,y) | x <- [1..] | y <- ['a'..'z']]
08:02:58 <lambdabot>  Parse error
08:03:01 <SamB_XP> because my plans are in no way related to how long it took you to respond to @botsnack
08:04:33 <haskellnew> suppose i create "let stms=newTVar 10" and then "forkIO (funcadd stms)"  where funcadd does some addition and write it back to tvar , but from main when i access the TVAR its not updated why?
08:04:35 <fasta> Are there any people that have tried to build a bot that can program?
08:04:57 <LeCamarade> Compiler. :o)
08:05:02 <Eelis> fasta: have a look at lambdabot's @djinn
08:05:10 <kpreid> haskellnew: stms isn't a TVar, it's an action that creates one
08:05:22 <fasta> Eelis: that's not what I mean.
08:05:29 <kpreid> haskellnew: so if you use it you're making a new one inside the thread
08:05:30 <fasta> Eelis: well, maybe I do.
08:05:45 <kpreid> haskellnew: you need: do stms <- newTVar 10; forkIO (funcadd stms) -- and change the type of funcadd correspondingly
08:05:50 <SamB_XP> how about building a bot that can play with technics?
08:06:00 <SamB_XP> you know, the legos with holes in 'em?
08:06:58 <kpreid> SamB: Not Technic, but it's at least got wheels: http://youtube.com/watch?v=GQ3AcPEPbH0
08:07:06 <fasta> Eelis: hmm, djinn is more general than I believed before.
08:09:11 <fasta> Eelis: it doesn't do STRefs?
08:11:50 <Eelis> fasta: i don't know much about it.
08:12:19 <haskellnew> kpreid : i see , do stms<-newTVar 10 is a STM action rt ?
08:12:47 <kpreid> no, it's do syntax. 'newTVar 10' is an expression for a STM action
08:13:38 <Newbiehaskell> /whoami
08:13:48 <shapr> I don't know!
08:13:54 <Newbiehaskell> lol
08:13:56 <kpreid> ah, right, so it'll need to be stms <- atomically $ newTVar 10
08:13:56 <fasta> Tell us!
08:14:09 <Newbiehaskell> do u see my nick?
08:14:13 <Newbiehaskell> :P
08:15:39 <SamB_XP> kpreid: huh. that was kinda cool, but it went so slow and used so many RCX units...
08:15:58 * kpreid nods
08:16:22 <fasta> @where u
08:16:23 <lambdabot> It's "you", not "u".
08:16:38 <SamB_XP> heh
08:16:44 <SamB_XP> @where you
08:16:44 <lambdabot> I know nothing about you.
08:17:03 <kpreid> SamB_XP: I imagine it runs slow because it doesn't have much feedback or degrees of freedom so it has to have completely reliable behavior from the parts
08:17:19 <SamB_XP> kpreid: mmm.
08:17:40 <SamB_XP> it does use rotation sensors right?
08:17:44 <kpreid> dunno.
08:17:54 <kpreid> but you'd think they could use some variable speed on the pusher rods
08:18:35 <SamB_XP> maybe some of the units need to take a predictable amount of time...
08:18:38 <arjanoosting> kaol: haxml is uploaded to unstable (in incoming now)
08:18:59 <fasta> Computing is still to expensive to get really useful robots, I guess.
08:19:16 <SamB_XP> fasta: those were $100 microcontroller bricks
08:19:20 <fasta> Google has >500,000 machines and they probably don't do it.
08:19:25 <malcolmw> arjanoosting: which version? 1.13.2 or 1.17?
08:19:40 <arjanoosting> malcolmw: 1.13.2
08:19:41 <SamB_XP> with 32k of RAM each
08:19:43 <fasta> SamB_XP: I am not seeing those make money.
08:19:50 <arjanoosting> malcolmw: 1.17 is in experimental
08:19:59 <malcolmw> arjanoosting: makes sense
08:20:03 <fasta> SamB_XP: (which is a nice way to define "intelligent")
08:20:22 <SamB_XP> fasta: yeah. so your lego robots don't earn money...
08:22:25 <arjanoosting> malcolmw: any idea when the 1.17 branch will become the stable branch?
08:22:41 <malcolmw> arjanoosting: when it is stable :-)
08:22:47 <haskellnew> kpreid : i am going to paste the code , if thats ok with you ?
08:22:49 <arjanoosting> :-)
08:23:12 <malcolmw> arjanoosting: no timescale, just when I get round to it
08:25:22 <kpreid> haskellnew: use hpaste
08:25:57 <hpaste>  haskellnew pasted "TVAR and threads" at http://hpaste.org/82
08:27:07 <kpreid> haskellnew: that looks like it'll hang with tstm holding 14
08:28:04 <Heffalump> did you intend test3 to loop infinitely?
08:28:06 <kpreid> haskellnew: perhaps you intended to make test3 repeat?
08:28:09 <Heffalump> if so, you need to include a tail call to it
08:28:24 <Heffalump> in place of the return ()
08:28:27 <haskellnew> kpreid : oops sorry instead of 4 it was supposed be the lst
08:28:32 <haskellnew> it works
08:28:34 <haskellnew> now
08:28:42 <kpreid> or: forkIO $ sequence $ repeat $ test3 tstm
08:28:47 <kpreid> er, sequence_
08:29:06 <Heffalump> bah, you and your higher-order combinators
08:29:11 <Heffalump> real men use recursion ;-)
08:31:28 <Saizan> ?type forever
08:31:31 <lambdabot> Not in scope: `forever'
08:31:41 <Saizan> ?type Control.Monad.Reader.forever
08:31:43 <lambdabot> Not in scope: `Control.Monad.Reader.forever'
08:32:12 <desp> are bound threads already a part of ghc?
08:32:18 <Heffalump> ?type Control.Monad.forever
08:32:20 <lambdabot> Not in scope: `Control.Monad.forever'
08:32:48 <Saizan> bound threads?
08:32:48 <kpreid> @src sequence_
08:32:48 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:33:01 <haskellnew> kpreid : thanks , i was using "test1 22" and i forget to remove "4" from atomically (newTVar 4)  from there , thanks a lot bye
08:33:29 <desp> Saizan: bound threads. http://research.microsoft.com/~simonpj/Papers/conc-ffi/index.htm
08:33:31 <lambdabot> Title: Extending the Haskell Foreign Function Interface with Concurrency
08:33:53 <fasta> I get " No instances for <a long list> ", how do I get those instances into scope? And more importantly: in what scope are all of those entries in long list used?
08:35:01 <olsner> @src sequence
08:35:01 <lambdabot> sequence ms = foldr k (return []) ms
08:35:01 <lambdabot>     where
08:35:01 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:35:30 <Heffalump> k = liftM2 (:), right?
08:36:23 <pastorn> ?where logs
08:36:23 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
08:39:25 <olsner> mmkay, so sequence returns a list of results... I think I should learn to use sequence_ more
08:40:42 <sorear> desp: you don't want bound threads, I'm almost certain.
08:41:16 <sorear> desp: they are useless except in the presence of broken (TLS-using) libs like openGL
08:41:46 * SamB_XP wonders who Leshchinskiy is...
08:41:50 <sorear> desp: without exception they will make your program slower not faster
08:42:27 <sorear> SamB_XP: aka RL aka Roman, co-designer of stream fusion
08:42:42 <sorear> i think he also works on NDP
08:43:16 * SamB_XP must not have read the latest stream fusion paper?
08:44:07 <ozone> samb: he works with dons and the other sydney guys
08:44:17 <sorear> desp: it is a common misconception that bound threads allow your program to use multiple cores.  this has no truth to it!
08:44:24 <ozone> is a very, very crazy man
08:44:55 <jyp> aren't we all ?
08:45:12 <desp> sorear: I do need to work with a TLS lib
08:45:34 <desp> I would really be grateful for not trying to outguess me :)
08:46:47 <sorear> oh :)
08:47:02 <desp> see, I'm trying to find information on the current state of concurrency in GHC
08:47:04 <sorear> in that case, YES we have them
08:47:09 <desp> ah, thank you
08:47:12 <sorear> Control.Concurrent.forkOS
08:47:50 <pjd> Haskell let's you fork the OS?
08:47:56 <pjd> "lets", even
08:48:17 <Heffalump> it means "fork OS thread", so kind of, yes
08:49:03 <olsner> so normal haskell threads are just soft threads?
08:49:07 <Heffalump> yes
08:49:12 <Heffalump> very lightweight
08:49:42 <SamB_XP> desp: unfortunately, we do not have a way to bind multiple haskell threads to the same OS thread...
08:50:03 <SamB_XP> unless we got one?
08:50:45 <desp> "A bound thread has a fixed associated OS thread"
08:50:51 <sorear> olsner: but forkOS threads are no more parallel!
08:51:22 <sorear> olsner: the GHC RTS will spread threads over as many processors as you give it
08:51:25 <SamB_XP> yeah, GHC will spawn a number of OS threads to handle unbound threads
08:51:31 <olsner> yeah, I assumed as much
08:51:45 <olsner> semi-worthless otherwise ;-)
08:51:47 <SamB_XP> you can specify how many you want in the RTS options
08:52:59 <sorear> olsner: it's amazing how many people think forkOS is needed to support multicore :(
08:53:15 <olsner> shouldn't #cpus be a sensible default for that parameter though?
08:53:33 <olsner> (i.e. why require rts options at all?)
08:53:42 <SamB_XP> sorear: perhaps the documentation should say "forkOS is not needed to take advantage of multicore -- forkIO is fine!"
08:53:59 <SamB_XP> olsner: it isn't a required option, and that is the default
08:54:06 <olsner> aah, okay
08:54:39 <sorear> no, the default is 1
08:54:44 <SamB_XP> oh?
08:54:50 <SamB_XP> sorear: really?
08:54:57 <SamB_XP> huh.
08:55:00 <SamB_XP> sorry ;-)
08:55:09 <olsner> but is it required to use forkIO to get multi-cpu computation? shouldn't it be possible for the runtime to automatically fork off pure computations?
08:55:20 <Heffalump> olsner: it's too hard for it to decide where to do that
08:55:24 <sorear> olsner: Possible, yes.  A good idea, never.
08:55:34 <Heffalump> but there's the par function you can use to tell it to
08:55:37 <sah> aw, it sounded like a good idea to me
08:56:00 <Heffalump> GHC needs profile feedback :-)
08:56:02 <olsner> of course, the problem is hard.. but I thought the haskell people were smart enough :P
08:56:09 <sorear> olsner: 2 + 2 + 2 can be evaluated multithreaded, but the communication overhead WILL kill you
08:56:20 <Heffalump> olsner: NDP is the current approach to doing that kind of thing
08:56:26 <olsner> NDP?
08:56:33 <Heffalump> nested data parallelism
08:56:52 <Heffalump> basically you specify your computation as a function over a strict array (using a bit of new notation)
08:56:55 <matthew-_> @where cyclical imports
08:56:55 <lambdabot> I know nothing about cyclical.
08:57:16 <sorear> matthew-_: huh?
08:57:31 <olsner> Heffalump: OpenMP-style?
08:57:41 <Heffalump> olsner: no, higher-level than that
08:57:43 <matthew-_> sorear: I once read some way of dealing with imports that form a cycle
08:57:50 <matthew-_> sorear: I need it now and can't find it!
08:57:56 <Heffalump> matthew-_: try searching for hs-boot
08:57:59 <sorear> Heffalump: Which worries me.  Why do we have to introduce notation as a performance hack, when semantically important things like comonads don't have any?
08:58:27 <Heffalump> the notation isn't strictly necessary, is it?
08:58:31 <Heffalump> it's just convenient
08:58:50 <Heffalump> can you tell me a good use of comonads, then? :-) I still don't understand the point of them.
08:59:31 <sorear> Better example: why is forkIO a library function, if NDP is wired-in punctionation?
09:00:21 <matthew-_> Heffalump: got it, thanks. http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
09:00:22 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/2y3hr6
09:00:59 <olsner> "Instant insanity when done by hand"
09:01:05 <Heffalump> sorear: I'm still interested in a good use of comonads for its own sake :-) But why does forkIO need punctuation?
09:01:15 <sorear> let's introduce magic punctuation syntax for `par`, and Parsec parsers, and ...
09:01:26 <olsner> http://research.microsoft.com/~simonpj/papers/ndp/NdpSlides.pdf
09:01:36 <sorear> Heffalump: It doesn't.  And having punctuation for NDP seems equally ridiculous.
09:01:38 <Heffalump> array comprehensions are quite like list comprehensions, though. Perhaps they should just generalise those appropriately.
09:02:10 <Heffalump> sorear: Do you disagree with punctuation for list comprehensions?
09:02:30 <olsner> I'd like generalization on all sequences.. no reason to differentiate arrays and lists in most cases, like map et al
09:03:36 <sorear> No, because I've been exposed to them for too long :)  I definitely disagree with them being monomorphic
09:03:39 <fasta> Where can I find the exact rules for how instances are found?
09:03:42 <Heffalump> olsner: the type class is tricky, though
09:04:11 <Heffalump> fasta: I didn't think it was any more complicated than "all the instances declared in the transitive closure of all the modules you've imported"
09:04:46 <fasta> Heffalump: me neither, but it seems it's not importing some.
09:04:49 <sorear> Heffalump: We've had the technology for MANY years now.  Functional dependencies aren't exactly oleg food.
09:05:23 <Heffalump> I meant "tricky" as in "makes life more complicated", not "impossible/really hard to write"
09:06:14 <Heffalump> sorear: re array comprehensions, I would say the difference with forkIO is that the new syntax is helpful in simplifying code
09:07:23 <rafe> if i have a function signature with one argument like so:
09:07:29 <rafe> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:07:41 <rafe> how can i define it with 2 args like....
09:07:48 <rafe> bind f' (gx, gs) = let (fx, fs) = f' gx in  (fx, gs ++ fs)
09:07:58 <rafe> grrr
09:08:15 <sorear> rafe: Um, that works!
09:08:20 <rafe> yes!
09:08:30 <sorear> rafe: you don't need to do anything to make it work
09:08:31 <rafe> i have run it
09:08:37 <sorear> oh, you're asking WHY it works
09:08:43 <rafe> yup
09:08:43 <sorear> currying
09:08:52 <mauke> f x y = body is equivalent to f = \x -> \y -> body
09:08:55 <sorear> all functions in haskell have 1 argument
09:09:11 <sorear> two arg definitions are sugar for chained definitions
09:09:26 <rafe> ok
09:09:26 <sorear> two arg applications are sugar for chained applications
09:09:42 <rafe> ahh
09:09:43 <sorear> in terms of types, (->) is right associative
09:09:59 <sorear> (Float -> (Float,String)) -> ((Float,String) -> (Float,String))  ==  (Float -> (Float,String)) -> (Float,String) -> (Float,String)
09:10:03 <mauke> f :: a -> b -> c parses as f :: (a -> (b -> c))
09:10:49 <rafe> oh
09:10:54 <rafe> penny dropped
09:11:11 <rafe> thank you
09:11:16 <mauke> > (flip id 2) sqrt
09:11:25 <lambdabot>  1.4142135623730951
09:12:35 <sorear> (flip id 2) sqrt  ==  flip id 2 sqrt  ==  id sqrt 2  ==  (id sqrt) 2  ==  sqrt 2
09:12:44 <sorear> @pl (flip id 2) sqrt
09:12:44 <lambdabot> sqrt 2
09:12:54 <sorear> yay for the @pl optimizer
09:13:12 <mauke> @type flip
09:13:14 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:13:18 <mauke> @type id
09:13:20 <lambdabot> forall a. a -> a
09:13:29 <olsner> @type flip id
09:13:30 <lambdabot> forall b c. b -> (b -> c) -> c
09:13:40 <olsner> woa
09:13:53 <mauke> you understand currying when you understand why/how flip id works :-)
09:14:16 <olsner> id = (a->b->c) => a=b->c?
09:14:22 <rafe> well then
09:14:27 <Heffalump> @src id
09:14:28 <lambdabot> id x = x
09:14:49 <sorear> A and B implies C   ===   A implies (B implies C)
09:14:52 <rafe> i'll mess with thatstuff next
09:14:56 <sorear> Currying in Curry Howard
09:15:18 <rafe> i was going thru the "You could have invented" monads tute
09:16:05 <mauke> ah, that's why "bind"
09:16:07 <rafe> it was all making sense until the type signature... currying of the args
09:16:36 <rafe> but you explanations help a lot
09:16:49 <olsner> oh, flip id x is a function that curries a function with x? wild
09:17:05 <mauke> olsner: ($) = id
09:17:15 <mauke> flip ($) == flip id
09:17:48 <olsner> @type (\x f -> f x)
09:17:50 <lambdabot> forall t t1. t -> (t -> t1) -> t1
09:17:52 <dmwit> In this case, id :: (a -> b) -> (a -> b).
09:18:37 <olsner> @type ($)
09:18:39 <lambdabot> forall a b. (a -> b) -> a -> b
09:19:45 <olsner> @type sqrt `id` 2
09:19:46 <lambdabot> forall a. (Floating a) => a
09:20:14 <olsner> @type (sqrt `id`)
09:20:16 <lambdabot> forall a. (Floating a) => a -> a
09:20:56 <olsner> ... obviously
09:21:07 * olsner thinks he groks
09:21:42 <rafe> well... enuf to sleep tonight
09:21:46 <rafe> :)
09:21:47 <Saizan> haskell: where you don't really ever know how many arguments a function takes
09:23:19 <emu> Saizan: 1
09:23:22 <rafe> so... i can chop off the arg list anywhere i like?
09:23:36 <rafe> as long as it matches?
09:23:52 <Saizan> as long as you remember that -> is right associative
09:24:00 <rafe> ok
09:24:02 <emu> > (+) 1
09:24:04 <lambdabot>  <Integer -> Integer>
09:24:35 <olsner> f x y == (f x) y... so any function applied to "not enough" arguments returns a function that takes the rest of them
09:24:43 <emu> > lookup 1
09:24:43 <lambdabot>  Add a type signature
09:25:22 <emu> :t lookup 1
09:25:24 <lambdabot> forall t b. (Num t) => [(t, b)] -> Maybe b
09:25:44 <rafe> this will be excessively useful
09:26:14 <emu> indeed
09:26:20 <sah> so I understand currying, but not flip
09:26:25 <emu> > map (+1) [1..5]
09:26:26 <lambdabot>  [2,3,4,5,6]
09:26:33 <sah> wtf was all that craziness with id and sqrt up there?
09:26:38 <olsner> f x y = (flip f) y x
09:26:50 <sah> oic
09:27:04 <mauke> @src flip
09:27:04 <lambdabot> flip f x y = f y x
09:28:41 <sah> ah, got it
09:40:39 <fasta> GHC claims there's no instance FooBar (a112, Bool), but there is an instance FooBar (Int, Bool). Why doesn't it just use that one? Not in scope?
09:41:10 <Saizan> maybe it can't infer Int from teh context?
09:41:54 <fasta> Hmm, maybe I need to add a functional dependency
09:42:07 <Saizan> that would help
09:42:12 <Heffalump> fasta: MPTCs?
09:42:19 <SamB_XP> fasta: probably
09:42:23 <SamB_XP> well.
09:42:27 <SamB_XP> if you can!
09:42:35 <Heffalump> FooBar doesn't look multi-parameter the way you quote it
09:42:57 <SamB_XP> fasta: how is it supposed to know that a112 is Int?
09:42:58 <Heffalump> I have observed GHC giving errors like you describe, though.
09:43:09 <Saizan> (or you can just insert a type annotation)
09:43:39 <fasta> Heffalump: yes
09:43:49 <fasta> Ok, this reduced "long list" to "small list".
09:44:24 <fasta> Heffalump: I oversimplified, in that case.
09:46:22 <Heffalump> any xmonad devs around?
09:46:25 <fasta> Ok, now I only got 1 line of context remaining :)
09:48:27 <dmwit> Heffalump: Yep, looks like #xmonad is active. ;-)
09:48:39 <Heffalump> ah, didn't realise that existed
09:48:51 <sorear> @users
09:48:51 <lambdabot> Maximum users seen in #haskell: 340, currently: 309 (90.9%), active: 40 (12.9%)
09:58:47 <rafe_coding> > $
09:58:47 <lambdabot>  Parse error
09:58:59 <rafe_coding> > ($)
09:59:00 <lambdabot>  Add a type signature
10:00:14 <rafe_coding> > :t ($)
10:00:15 <lambdabot>  Parse error
10:00:31 <rafe_coding> > :t $
10:00:31 <lambdabot>  Parse error
10:01:41 <Lemmih> :t ($)
10:01:43 <lambdabot> forall a b. (a -> b) -> a -> b
10:01:54 <emu> :t ($) ($)
10:01:56 <lambdabot> forall a b. (a -> b) -> a -> b
10:02:10 <emu> :t fix ($)
10:02:12 <lambdabot> forall a b. a -> b
10:02:52 <Lemmih> @type id `asTypeOf` ($)
10:02:54 <lambdabot> forall a b. (a -> b) -> a -> b
10:03:36 <rafe_coding> thanks
10:05:56 <Newbiehaskell> Prelude> let [x,y]= zip ['a'..'z'][1..2]
10:05:56 <Newbiehaskell> Prelude> [x,y]
10:05:56 <Newbiehaskell> [('a',1),('b',2)]
10:05:56 <Newbiehaskell> Prelude> let [x,y]= zip ['a'..'z'][1..26]
10:05:56 <Newbiehaskell> Prelude> [x,y]
10:05:56 <Newbiehaskell> [*** Exception: <interactive>:1:4-31: Irrefutable pattern failed for pattern [x, y]
10:06:42 <sorear> Newbiehaskell: the RHS is a 26 element list.  the pattern is 2 element.  why do you thing it will match?
10:06:49 <sorear> s/thing/think
10:07:01 <Newbiehaskell> ok ok :)
10:10:56 <sorear> @seen glguy
10:10:56 <lambdabot> glguy is in #haskell. I last heard glguy speak 4d 1h 49m 47s ago.
10:11:22 * sorear probably should have used /msg
10:13:04 <mauke> > let (x : y : _) = zip ['a'..'z'][1..26] in [x,y]
10:13:11 <lambdabot>  [('a',1),('b',2)]
10:13:35 <Newbiehaskell> thanks i will studiy it
10:15:37 <Newbiehaskell> let (x:y)= zip ['a'..'z'][1..26] without ""in [x,y]"" same results
10:17:11 <mauke> > let (x:y)= zip ['a'..'z'][1..26] in x
10:17:12 <lambdabot>  ('a',1)
10:17:16 <mauke> > let (x:y)= zip ['a'..'z'][1..26] in y
10:17:18 <lambdabot>  [('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j',10),('...
10:17:42 <Newbiehaskell> i got it
10:17:48 <Newbiehaskell> thanks a lot
10:24:10 <LeCamarade> Am I the only one who finds using anything other than [h]GetContents to troubling? ([h]GetLine, et al). As in, error handling and so on ... ?
10:24:38 <LeCamarade> @src hGetContents
10:24:38 <lambdabot> Source not found. Are you on drugs?
10:24:42 <LeCamarade> Yes
10:24:57 <LeCamarade> @slap -f lambdabot
10:24:57 * lambdabot beats up -f lambdabot
10:25:17 <LeCamarade> Gotta go.
10:25:37 <LeCamarade> :-(
10:30:05 <olsner>  /usr/bin/ld: Undefined symbols: _mtlzm1zi0zi1_ControlziMonadziStateziLazzy_polyzuget_closure
10:31:16 <mauke> --make?
10:31:41 <olsner> cool, worked
10:33:06 <sorear> -package mtl if you want to be explicit
10:33:44 <mauke> how do I get a list of available packages?
10:33:53 <Heffalump> ghc-pkg list
10:34:25 <mauke> ah
10:35:58 <sorear> @where hackage   for a different value of available
10:35:59 <lambdabot> http://hackage.haskell.org/trac/hackage
10:48:28 <nominolo> > zip ['a'..'z'] [1..]
10:48:30 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('j...
10:48:37 <nominolo> uh
10:49:43 <ttt-> zip [1..'a'][1..2]
10:49:49 <ttt-> zip [1..'a'] [1..2]
10:50:01 <ttt-> :(
10:50:05 <mauke> >
10:50:13 <nominolo> > 42
10:50:14 <lambdabot>  42
10:50:31 <dmwit> > zip [chr 1..'a'] [1,2]
10:50:33 <lambdabot>  [('\SOH',1),('\STX',2)]
10:50:55 <dmwit> > zip [chr 0..] [1..]
10:50:56 <lambdabot>  [('\NUL',1),('\SOH',2),('\STX',3),('\ETX',4),('\EOT',5),('\ENQ',6),('\ACK',7...
10:51:14 <Heffalump> @more
10:51:15 <dmwit> -- off by one error
10:51:22 <Heffalump> did that get removed?
10:51:29 <Heffalump> or is it only for certain other commands?
10:51:30 <dmwit> ?eval+
10:51:41 <dmwit> ?lsit
10:51:41 <lambdabot> Maybe you meant: gsite let list quit
10:51:43 <mauke> @eval no.
10:51:43 <dmwit> ?list
10:51:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:51:49 <ttt-> quit
10:52:28 <olsner> haskell... where making something tail-recursive just brings you to another hell
10:52:58 <Vq^> olsner: another?
10:53:21 <mauke> just add strictness
10:53:56 <olsner> I have.. no luck
10:54:13 <dmwit> ...and two squeezes of lemon
10:54:17 <mauke> what are you trying to do?
10:54:43 <sorear> olsner: tail recursion is a bad idea in lazy languages
10:54:43 <mauke> !  <- squeeze
10:54:55 <sorear> olsner: it's actively harmful
10:55:19 <Heffalump> even when it's strict?
10:55:24 <Heffalump> e.g. in many monads
10:55:41 <Heffalump> oh, that's not tail recursion, sorry
10:56:01 <olsner> dons reimplemented everything using ByteStrings and Maps and it worked fine, but my way using folds on lists just overflows the stack
10:56:15 <mauke> foldr or foldl?
10:56:25 <olsner> both
10:56:31 <olsner> or either
10:56:37 <Vq^> shouldn't that be foldl' ?
10:56:48 <mauke> probably
10:57:26 <olsner> according to my understanding, foldl' should update the state one step at a time, and not overflow the stack and/or allocate everything as thunks.. but that's not the behaviour I see
10:57:41 <olsner> I'm basically counting words in a filtered file
10:57:56 <Heffalump> is your function actually strict?
10:58:09 <dmwit> Sounds like a case for hpaste!
10:58:11 <Heffalump> and fully strict, not just to WHNF
11:03:34 <olsner> WHNF?
11:03:51 <dcoutts_> weak head normal form
11:04:01 <dcoutts_> (_|_, _|_) is in weak head normal form
11:04:07 <dcoutts_> but not in normal form
11:04:45 <dcoutts_> when something is in WHNF we know its top level constructor
11:05:29 <HairyDude> has anyone got experience using the listings package in latex? specifically the literate option
11:05:43 <HairyDude> I have it sending \ to lambda but it's doing it in strings as well, which is less than optimal
11:06:01 <olsner> ah, okay.. so basically WHNF is what you get from f g (x:xs) = (g x:f xs) or something like that?
11:10:55 <dcoutts_> olsner: yes, that f forces its second arg to whnf
11:11:28 <dcoutts_> olsner: it's just enough to distinguish (_:_) from []
11:11:45 <olsner> mm
11:16:00 <emu> HairyDude: consider lhs2TeX?
11:16:20 <HairyDude> emu: haven't come across it... will have a look, thanks
11:25:04 <fbuilesv> dons: The Control.Monad.Reader module imported in your mkcabal program is not included with normal GHC-6.6 distribution?
11:26:08 <Saizan> fbuilesv: it's in the mtl package, distribuited with extralibs
11:26:12 <dblhelix> fbuilesv: it is, it's in the mtl package
11:26:18 <Saizan> libghc6-mtl-dev on debian
11:26:49 <fbuilesv> And libghc6-mtl-dev in Ubuntu, thank you.
11:27:27 <SamB> I really want mtl recommend:ed...
11:27:32 <SamB> er. something like that...
11:43:16 <hpaste>  olsner pasted "Stack overflow" at http://hpaste.org/84
11:44:15 <olsner> How can I force the entire state to be evaluated in its entirety before proceeding through the file?
11:44:34 <Heffalump> deepSeq
11:45:17 <Heffalump> you've got the right idea by sprinkling seqs all over the place
11:45:35 <Heffalump> but if you use deepSeq (google for it, the implementation is fairly simple but repetitive), you can avoid all that
11:45:57 <int-e> @index rnf
11:45:58 <lambdabot> Control.Parallel.Strategies
11:46:15 <olsner> I'd like to be able to just add a single seq in one well-considered place and stop worrying :P
11:46:51 * Lemmih doesn't condone sprinkling seqs all over the place as an optimization technique.
11:47:03 <int-e> rnf is the new deepSeq ;)
11:47:15 <Heffalump> rnf doesn't have any pars in it?
11:47:54 <int-e> no, just seqs as far as I can see.
11:48:27 <Heffalump> olsner: rnf in one well-considered place is the way to go
11:48:35 <emu> rnf is mostly things of the form: rnf subfield `seq` ()
11:48:49 <Heffalump> specifically, around the rhs of updateState
11:48:49 <emu> so everything's seqing to ()
11:48:54 <olsner> something like foldl' (f `rnf`) then?
11:49:04 <Heffalump> rnf isn't an application operator
11:49:15 <Heffalump> @type Control.Parallel.Strategies.rnf
11:49:17 <lambdabot> forall a. (NFData a) => a -> Done
11:49:24 <Heffalump> foldl' (rnf (f ...))
11:49:29 <olsner> ah
11:49:37 <Heffalump> no, not that
11:49:42 <Heffalump> just put it in updateState
11:49:48 <Heffalump> otherwise you'll need a lambda in the foldl' argument
11:51:38 <ddarius> 212 emails in haskell-cafe
11:52:55 <norgul> now, i'm ready to learn some haskell
11:53:13 <norgul> after i've done this school work
11:54:04 <olsner> there is beauty in the world again! deepSeq works!
11:54:16 <olsner> constant memory usage ;-)
11:54:18 <Heffalump> cool
11:54:24 <ddarius> deepSeq is ugly
11:54:37 <Heffalump> at some level, yes
11:54:38 <Heffalump> but it works
11:54:57 <Heffalump> and a good compiler should be able to remove the unnecessary bits
11:55:15 <Heffalump> well, that might be tricky
11:55:32 <Heffalump> I guess you could specialise a function to produce a deepSeq'd result.
11:56:19 <olsner> ddarius: feel free to suggest a better solution...
11:56:24 <olsner> I am also queasy with specifying the evaluation order unnecessarily - using something like foldl' should've done "the right thing" from the start
11:56:39 <Heffalump> there should be a foldl'' perhaps
11:57:24 * Heffalump doesn't think this whole area is really understood at all well (even by the experts)
11:57:46 <Heffalump> and "good style" is hard to define in such a situation
12:01:59 <Lemmih> olsner: How do you generate your input files?
12:02:13 <olsner> objdump -d
12:02:34 <Heffalump> does anyone make .debs of GHC HEAD?
12:06:19 <olsner> 11mins to process a 2.5 gig file... dons' (I think it was him at least) attempt took 4mins using ByteStrings and Maps
12:26:46 <Lemmih> olsner: What does your updated source look like?
12:27:52 <hpaste>  olsner pasted "Now in constant space" at http://hpaste.org/85
12:30:56 <olsner> @pl (($) . snd)
12:30:56 <lambdabot> snd
12:31:47 <fbuilesv> Is there any way to get the version of a project using Cabal without having to read the Project.cabal file?
12:33:39 <int-e> olsner: ah the updated code looks prettier.
12:33:59 <olsner> yes, much less seq crud, now that I can use deepSeq
12:35:23 <thorsten_> hi folks
12:35:26 <Lemmih> olsner: Does it generate the correct result?
12:35:50 <olsner> I think so
12:35:54 <olsner> ;-)
12:39:29 <olsner> @pl ((\f -> f x) . snd)
12:39:29 <lambdabot> flip snd x
12:39:51 <olsner> :t flip snd
12:39:53 <lambdabot> forall a b c. b -> (a, b -> c) -> c
12:40:38 <olsner> :t ($ x)
12:40:40 <lambdabot> Not in scope: `x'
12:41:30 <sjanssen> @yow!
12:41:30 <lambdabot> HOORAY, Ronald!!  Now YOU can marry LINDA RONSTADT too!!
12:42:58 <olsner> @. elite yow!
12:42:58 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "yow!"
12:43:06 <olsner> @. elite yow
12:43:06 <lambdabot> I'/\/\ re(3I\/InG A (ODEd mEsz49E Fr0/\/\ 3u8ie BLAxe!!
12:44:28 <olsner> I'd like a haskell editor where I can get things like mouse-over determination of expression types
12:45:07 <olsner> and also that can run @pl on the all expressions in the file and suggest optimizations
12:46:41 <Saizan> you can get cursor over determination of types in emacs
12:47:50 <olsner> argh... useful features that have gotten stuck in emacs :(
12:48:02 <sjanssen> heh
12:49:20 <Saizan> ?where ghc-api
12:49:20 <lambdabot> http://www.haskell.org/ghc/
12:54:51 <dmwit> olsner: vim has a keybinding _t for determining types, if you have the right plugin.
12:54:56 <dmwit> Hold on, let me dig up the link.
12:55:22 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
12:55:24 <lambdabot> Title: Haskell mode for Vim
12:55:33 <edwardk> dmwit: that would be really useful, grabbing
12:58:10 <HairyDude> how do I get lhs2TeX to preserve my pragmas?
12:58:18 <olsner> I might revive my vim installation then
12:58:20 <HairyDude> it seems to just throw them away atm
12:59:35 <Heffalump> I read "pragmas" as "programs" :-)
12:59:43 <Heffalump> does it throw away comments too?
13:00:01 <Lemmih> olsner: 200M file. StackConstant => 1m3. StackArray (no seqs) => 6.8seconds.
13:00:28 <olsner> Lemmih: StackConstant? StackArray?
13:01:08 <olsner> you've found the magical don't-overflow-the-stack switch?
13:01:12 <Lemmih> olsner: StackConstant is the one you posted. StackArray is version using arrays.
13:01:25 <olsner> aah okay
13:01:42 <Lemmih> olsner: Yep. It's called "using the right data structure".
13:01:47 <olsner> is that representing the state as an array instead?
13:02:06 <Lemmih> olsner: Yes, it's fast, pretty and pure.
13:02:32 <olsner> the array must be doing something special to be strict though (even if it is hidden from view), right?
13:02:46 <HairyDude> Heffalump: it keeps line comments. dunno about block comments, I don't have nay
13:02:50 <HairyDude> s/nay/any/
13:03:25 <HairyDude> quick testing shows it throws away block comments as well
13:03:48 <Lemmih> olsner: Well, unboxed arrays are strict in their elements.
13:04:11 <HairyDude> wait, no it doesn't
13:04:20 <HairyDude> forgot to rerun the thing before compiling.
13:06:37 <Lemmih> olsner: With arrays and bytestrings, 47% of the time is spent in 'getOp' and only 32% in 'doSearch'.
13:18:16 <newsham> ?seen glguy
13:18:16 <lambdabot> glguy is in #haskell. I last heard glguy speak 4d 4h 57m 7s ago.
13:23:03 <hpaste>  Lemmih annotated "Stack overflow" with "Faster version" at http://hpaste.org/84#a1
13:23:38 <matthew-_> what's the equivalent of id at the type level?
13:23:53 <matthew-_> agh, there isn't one is there?
13:24:04 <Lemmih> matthew-_: They cause havoc.
13:24:27 <sorear> matthew-_: newtype Id a = Id a
13:24:54 <sorear> It's perfectly safe as long as it isn't transparent
13:25:14 <matthew-_> sorear: yeah, but that's not quite the same. It'll do though
13:25:15 <sorear> or if it is transparent but all lambdas are decorated with types
13:25:43 <sorear> matthew-_: Aside from kind polymorphism, what is my Id :: * -> * missing ?
13:26:48 <EvilTerran> "type Id a = a"?
13:27:19 <matthew-_> sorear: well, the type Id Int /= Int, whereas id 5 == 5
13:27:23 <Heffalump> the restrictions on partially applying type synonyms will stop you doing a lot of stuff with it
13:27:47 <matthew-_> i.e. it's stuck Id on the front. But what I really want is actually higher order type classes.
13:27:54 <EvilTerran> what do you need this for, matthew?
13:28:05 <edwardk> > drop 1 $ fix (fmap . flip id =<<) $ map (\n m -> if n == 1 then [1] else if odd n then n:m!!(3*n+1) else n:m!!(n`div`2)) [0..]
13:28:06 <lambdabot>  [[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2,1],...
13:28:40 * sorear smells a challenge!
13:28:40 <matthew-_> EvilTerran: that's a complex question. The big answer is converting between type systems.
13:28:42 <nominolo> @seen bringert
13:28:43 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
13:28:45 <pjd> hail edwardk
13:28:47 <edwardk> =)
13:28:48 <edwardk> hail
13:29:03 <sorear> collatz optimization time!
13:29:19 <nominolo> @tell: any ideas how to get rid of http's strange 3000.x.x version format?
13:29:20 <lambdabot> Consider it noted.
13:29:30 <edwardk> its the 3n+1 problem rolled on itself as a list using loeb's paradox
13:29:48 <sorear> @print-notices
13:29:48 <lambdabot> fromList [("audreyt:",(Nothing,[Note {noteSender = "fglock", noteContents = "have you registered the 'Pugs' namespace in CPAN? I need comaint in order to have the v6.pm modules indexed", noteTime = (
13:29:48 <lambdabot> 1178627870,751397000000), noteType = Tell},Note {noteSender = "fglock", noteContents = "actually, the problem is specific to Pugs::Grammar::P6Rule - you are the owner; I need comaint", noteTime = (
13:29:48 <lambdabot> 1178628101,874469000000), noteType = Tell},Note {noteSender = "fglock", noteContents = "do you think it would make sense to start some bootstrapping work for pugs?", noteTime = (1180037661,48979100000
13:29:48 <lambdabot> 0), noteType = Tell}])),("clkao:",(Nothing,[Note {noteSender = "fglock", noteContents = "would you upload Sub::Multi to CPAN? I've made a small fix", noteTime = (1178629354,782618000000), noteType =
13:29:50 <lambdabot> Tell}])),("fglock:",(Nothing,[Note {noteSender = "spinclad", noteContents = "you won't get this message (try @tell nick, not nick:)", noteTime = (1180125494,88763000000), noteType = Tell}])),("'dons'
13:29:52 <matthew-_> But what I actually want to be able to do is class Foo m a where f :: (m g) => a -> x
13:29:53 <lambdabot> [35 @more lines]
13:30:05 <matthew-_> i.e. m is a type class
13:30:13 <nominolo> @tell bringert any ideas how to get rid of http's strange 3000.x.x version format?  maybe renaming the package?
13:30:13 <lambdabot> Consider it noted.
13:30:30 <matthew-_> and I want to be able to parameterise type classes with type classes
13:30:31 <Heffalump> I thought the version format was added deliberately.
13:30:37 <Heffalump> (by bringert)
13:31:02 <sorear> nominolo: sure, we need to implement epochs in cabal
13:31:14 <nominolo> sorear: details plz :)
13:31:37 <nominolo> Heffalump: it was, because people used a date-based scheme first
13:31:41 <Heffalump> epochs are a "super" version number element that you use when you need to go backwards in the real version numbers
13:31:45 <Heffalump> ah, yes
13:32:03 <sorear> nominolo: debian uses stuff like 1:2.2 after 20070518
13:32:27 <sorear> s/after/>/
13:32:33 <pjd> edwardk: that is extremely cool
13:32:38 <nominolo> sorear: so just ':' instead of '." ?
13:33:03 <sorear> nominolo: I think so
13:33:12 <nominolo> i wouldn't wonder we'd need new "overriding delimiters" some day
13:33:14 <edwardk> =)
13:33:44 <nominolo> hm, let's plan ahead.  i vote for ;
13:33:45 <edwardk> i've been using it to 'watch' recursion on recursive functions
13:33:48 <Heffalump> you have to be sparing in the use of them
13:34:19 <sorear> nominolo: http://www.us.debian.org/doc/debian-policy/ch-controlfields.html#s-f-Version
13:34:21 <lambdabot> Title: Debian Policy Manual - Control files and their fields, http://tinyurl.com/2okmwu
13:34:32 <Heffalump> you only bump the epoch when things have gone badly wrong underneath
13:35:08 <nominolo> hm.  but for now we can just toggle the casing of various characters
13:35:25 <Heffalump> ugh, no
13:35:27 <sorear> dpkg has more or less the end-all of version comparison schemes, if you really want to forget about cabal's version number code you should make it use the dpkg scheme
13:35:29 <Heffalump> that'd be really confusing
13:35:34 <nominolo> i.e.  http < 3000 || Http > 0.0.1
13:35:45 <nominolo> then hTtp
13:35:48 <nominolo> then htTp
13:35:51 <nominolo> etc
13:35:54 <sorear> @slap nominolo
13:35:54 <lambdabot> why on earth would I slap nominolo
13:36:01 <nominolo> \o/
13:36:04 <Heffalump> @slap nominolo
13:36:04 <lambdabot> why on earth would I slap nominolo
13:36:16 <Heffalump> bah, the usual tricks don't work either :-)
13:36:17 <nominolo> that's 16 new epochs for free!
13:36:35 <sorear> nominolo: I'd rather just install my code using a magnet, thanks
13:36:41 <Heffalump> 15 new ones, actually.
13:37:17 <nominolo> well.  acutally we already have epochs:  http2-0.1
13:37:24 <edwardk> >
13:37:25 <nominolo> though that is a bit hard to compare
13:37:26 <edwardk> er
13:37:28 <edwardk> >
13:37:37 <edwardk> > fix (fmap . flip id =<<) $ [const 0, const 1] ++ map (\n m -> (m!!(n-1)) + (m!!(n-2))) [2..]
13:37:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:37:43 <edwardk> there =)
13:38:01 <ddarius> "tricksy"
13:38:09 <edwardk> it even memoizes =)
13:38:11 <Heffalump> what's interesting about that?
13:38:40 <Heffalump> (on the face of it it's just a pointlessly complicated version of the standard fibonacci list)
13:38:56 <edwardk> sure
13:39:22 <edwardk> 'though, it does build the list as it goes and look back into it so it memoizes intermediate results
13:39:59 <Heffalump> let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
13:40:02 <Heffalump> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
13:40:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:40:05 <edwardk> sure
13:40:09 <edwardk> same idea
13:40:15 <sorear> > let l = [1] : [ l!!if odd x then 3*x+1 else x `div` 2 | x <- [2..] ] in l
13:40:17 <lambdabot>  Exception: stack overflow
13:40:19 <Heffalump> doesn't that one memoise too?
13:40:41 <sorear> > let l = []:[1] : [ l!!if odd x then 3*x+1 else x `div` 2 | x <- [2..] ] in l
13:40:42 <lambdabot>  [[],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],...
13:40:50 <sorear> > let l = []:[1] : [ x:l!!if odd x then 3*x+1 else x `div` 2 | x <- [2..] ] in l
13:40:51 <lambdabot>  [[],[1],[2,1],[3,10,5,16,8,4,2,1],[4,2,1],[5,16,8,4,2,1],[6,3,10,5,16,8,4,2,...
13:41:18 <bringert> nominolo: (what Heffalump said)
13:41:18 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
13:41:27 <edwardk> fair enough. i started using the loeb thing for another functor, i just started playing with it for lists
13:41:28 <bringert> @messages
13:41:28 <lambdabot> nominolo said 11m 15s ago: any ideas how to get rid of http's strange 3000.x.x version format? maybe renaming the package?
13:41:36 <bringert> re that
13:41:53 <nominolo> bringert: you don't want to get rid of it?
13:41:57 <Heffalump> you shoudld all join my campaign for all package names to be lowercase :-)
13:42:01 <edwardk> heh
13:42:29 <Heffalump> (on the basis that they should all be consistently capitalised, and most nowadays are lowercase, so everyone should standardise in that direction)
13:42:36 <Heffalump> s/lowercase/all lowercase/g
13:43:20 <pjd> edwardk: planning to write something about it on Comonad.Reader, by any chance?
13:43:30 <sorear> > let x = 0:0: [ 1+x!!(1+5*l)*m+l | m <- [1..] , l <- [0,1] ] in x
13:43:31 <lambdabot>  [0,0,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,17,1,1...
13:43:54 <edwardk> pjd: well, if it works for the purpose i'm putting it to
13:43:58 <nominolo> bringert: so the next major version will be 3001.0.0 ?
13:44:14 <ejt_> why is fix in Control.Monad ?
13:44:22 <bringert> nominolo: yes, unfortunately
13:44:26 <sorear> hysterical raisins
13:44:34 <bringert> nominolo: do you have a better suggestion?
13:44:49 <Heffalump> ejt_: I don't see it there
13:44:50 <nominolo> no.  except adding epochs
13:44:55 <bringert> nominolo: it could also be 4000.0.0 :-)
13:44:58 <ejt_> Control.Monad.Fix
13:45:06 <sorear> ejt_: it's the mfix implementation for (->), so they exported it from the module they were writing at the time
13:45:07 <bringert> right, epochs would do it
13:45:09 <nominolo> i guess there're more packages with date-based schems
13:45:13 <edwardk> pjd: though i do like it for things like
13:45:19 <edwardk> >  fix (fmap . flip id =<<) $ listArray (('a',1),('c',3)) $ [(!('a',2)), const 10, (!('c',2)), (!('a',1)), liftM2 (+) (!('a',3)) (!('a',1)), (!('c',3)), const 4, const 5, const 600]
13:45:20 <lambdabot>  array (('a',1),('c',3)) [(('a',1),10),(('a',2),10),(('a',3),5),(('b',1),10),...
13:45:21 <bringert> nominolo: all of mine used to be
13:45:22 <ejt_> sorear: ah, thx
13:45:38 <edwardk> which then works like a spreadsheet
13:45:46 <edwardk> without any real mess
13:46:03 <edwardk> or for tying the knot on let bindings
13:46:07 <Heffalump> sorear: are you sure? It doesn't have the same type.
13:46:09 <nominolo> bringert: i'll spend 3 months on hacking cabal, so if there's no good reason not to add them, i should find the time to add them
13:46:15 <sorear> > fix(\x->0:0: [ 1+x!!(1+5*l)*m+l | m <- [1..] , l <- [0,1] ])
13:46:16 <lambdabot>  [0,0,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,17,1,1...
13:46:36 <sorear> Heffalump: Er, yeah, I meant identity then :)
13:46:44 <bringert> nominolo: sounds good
13:46:59 <bringert> nominolo: add a trac ticket for it to start with
13:47:08 <Heffalump> sorear: ok :-) I was wondering if it eta-reduced cleverly somehow
13:49:26 <sorear> > fix$\x->0:0:[1+x!!l|m<-[1..],l<-[m,6*m+1]]  -- for the cute one liners file
13:49:26 <lambdabot>  Parse error
13:49:38 <sorear> > fix(\x->0:0:[1+x!!l|m<-[1..],l<-[m,6*m+1]])  -- for the cute one liners file
13:49:42 <Heffalump> I'll bear it in mind when I need to demonstrate errors ;-)
13:49:44 <lambdabot> Terminated
13:50:22 <Heffalump> interesting, it produces the first 3 results quite fast on my computer
13:50:41 <Heffalump> or does lambdabot just say Terminated if it didn't produce the number of results it wanted to print in time?
13:50:59 <sorear> Heffalump: right, it needs to make 80 chars
13:51:05 <sorear> > fix(\x->0:1:1:[1+x!!l|m<-[1..],l<-[m,6*m+1]])
13:51:06 <lambdabot>  Exception: stack overflow
13:51:15 <sorear> > fix(\x->0:1:2:3:[1+x!!l|m<-[1..],l<-[m,6*m+1]])
13:51:21 <lambdabot> Terminated
13:51:25 <sorear> > fix(\x->0:1:2:3:[1+x!!l|m<-[2..],l<-[m,6*m+1]])
13:51:31 <lambdabot> Terminated
13:51:47 <Heffalump> so what's cute about it? It just seems like a good way of making a fast exponential blowup
13:51:51 <sorear> hmmph, i wonder what broke
13:54:36 <Heffalump> s/fast exponential blowup/non-termination/ # since all odd elements depend on a bigger odd element
13:55:35 <edwardk> you need an odd multiplier for it to be interesting no?
13:55:36 <Heffalump> oh, I see what you're trying to do
13:55:56 <Heffalump> he's trying to do 3*m+1, but because it's every other element he needs to multiply by 6
13:56:01 <edwardk> ah
13:56:15 <Heffalump> now I'm confused why it doesn't work :-)
13:56:51 <Heffalump> I think there's an off-by-one error somewhere
13:58:29 <Heffalump> >fix(\x->0:0:[1+x!!l|m<-[1..],l<-[m,6*m+4]])
13:58:39 <Heffalump> > fix(\x->0:0:[1+x!!l|m<-[1..],l<-[m,6*m+4]])
13:58:47 <lambdabot>  [0,0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,1...
13:59:36 <mdmkolbe|home> Heffalump: what function is that?
13:59:47 <Heffalump> I'm not sure. Probably not the one that sorear was trying for.
13:59:52 <edwardk> =)
14:00:12 <pitecus> anyone here familiar with Data.Derive?
14:00:28 <bos> ndm would be :-)
14:00:36 <Heffalump> I think he was trying to produce the length of the chains required to get to 1 in the f n | even n = n `div` 2 | odd n = 3*n + 1
14:00:54 <Heffalump> s/in the/when you iterate f, where /
14:01:17 <mdmkolbe|home> Heffalump: I think I've heard of that function.  What is it's common name again?
14:01:22 <Heffalump> no idea
14:01:25 <Heffalump> if I knew I'd have used it :-)
14:01:36 <mdmkolbe|home> collatz
14:01:42 <Heffalump> actually, maybe I have made it
14:01:54 <mdmkolbe|home> http://en.wikipedia.org/wiki/Collatz_conjecture
14:01:55 <lambdabot> Title: Collatz conjecture - Wikipedia, the free encyclopedia
14:01:59 <shapr> @where pretty
14:01:59 <lambdabot> I know nothing about pretty.
14:02:29 <sorear> pitecus: both _n_eil _d_ _m_itchell and _s_tefan _orear_ frequent #haskell
14:02:30 * shapr grumbles
14:02:41 <edwardk> mdm: its just the length of the 3n+1 problem for each integer =)
14:02:50 <Mitar> i would need to save an image to a file from haskell data structure
14:02:55 <Mitar> which module do you recommend?
14:03:02 <pitecus> sorear, i just downloaded it from hackage
14:03:03 <sorear> shapr: which pretty printer are you looking for - PPrint ?
14:03:04 <Mitar> is there any png, jpeg or similar?
14:03:17 <Baughn> ..two hours, spent not noticing I'd said Array instead of UArray.
14:03:26 <shapr> sorear: I'm trying to install cabal-install, and it requires the pretty package. No clue where it's from.
14:03:40 <pitecus> sorear, the example in the docs says: import Data.Derive.TH
14:03:41 <sorear> shapr: Yesterday they split base
14:03:50 <pitecus> but there is no scuh module
14:03:58 <pitecus> in the package
14:04:04 <edwardk> > let loeb = fix (fmap . flip id =<<) in drop 1 $ loeb $ map (\n m -> if n == 1 then 1 else 1 + if odd n then m!!(3*n+1) else  m!!(n`div`2)) [0..]
14:04:08 <lambdabot>  [1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,19,1...
14:04:16 <sorear> shapr: Text.PrettyPrint.HughesPJ has been moved into 'pretty' - you can hack the cabal file if you don't want a day old ghc
14:04:35 <edwardk> but, i'm not sure where your numbers come from though
14:04:35 <Modius> (Note - not language trolling!  Searching for understanding) - I read in a comparision of OCaml and Haskell performance in certain situations that the lazy-eval (and the functions/closures it had to build up and execute) caused a speed hit.  However, in pure functional, I'd imagine that (albeit slow) code analysis could turn the fucntional expression back into optimized loops.  Is there any past/present/future work on this?  Or is it n
14:04:43 <sorear> pitecus: Huh.  That module was renamed Data.DeriveTH, I wonder why the doc was missed
14:04:53 <Heffalump> Modius: you were cut off at "Or is it n"
14:05:08 <Heffalump> but essentially strictness analysis is what you are looking for
14:05:13 <Modius> <append> "or is it not really possible?"
14:05:15 <Heffalump> and a compiler like GHC does it very aggressively
14:05:16 <edwardk> modius: in certain circumstances lazy evaluation does admittedly cause a performance hit, but there are ways to ameliorate that
14:05:17 <Baughn> Modius: In fact, GHC works very hard at generating strict code whenever possible, and there are all sorts of ways to help it.
14:05:20 <emu> Modius: yep tons of work on it
14:05:30 <Heffalump> but often a function that is intended to be used strictly isn't actually strict semantically
14:05:36 <pitecus> sorear, fair enough. do i also need to import other TH related modules? I get parser error when i use TH syntax
14:05:37 <edwardk> strictness analysis is performed by ghc, which gets rid of most cases, and a few manual strictness anotations can handle almost all the rest
14:05:39 <emu> keep in mind, laziness is not always bad
14:05:49 <sorear> Modius: languages get faster the closer they resemble asm
14:05:52 <emu> it's necessary to implement many efficient data structures
14:05:54 <Heffalump> and data structures generally can't be inferred to be strict without hints
14:06:11 <sorear> Modius: asm is strict, so strict languages are always faster with identical algorithms
14:06:13 <Modius> Understood - I just meant that, for all the performance hit, the guarantee of purity could be leveraged for some cool optmiizations
14:06:23 <emu> Modius: yes there is some really cool stuff along those lines
14:06:44 <sorear> Modius: (that said the same code often turns out to implement a better algorithm when interpreted lazily)
14:06:53 <Modius> "Strictness analysis" <-- generally is this done by GHC already?  Or is there some "takes 100x as long but makes faster code" compiler addon?
14:07:06 <sorear> Modius: yeah, specify -O
14:07:17 <sorear> Modius: not quite 100x slower, but close :P
14:07:19 <emu> http://haskell.org/haskellwiki/Correctness_of_short_cut_fusion
14:07:20 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki
14:07:36 <edwardk> i still find that i get the most speed from not doing unnecessary work, and laziness gives me a sharper knife to cut off the corners of my program that i don't need the answers from in the current use-case without forcing me to think about the shape of the problem all the time.
14:07:54 <sorear> Modius: Pretty much the only work really using purity is automatic deforestation
14:08:28 <sorear> Modius: Manual deforestation is of course faster (but we don't care about small efficiencies - if we we'd be using assemblers)
14:08:43 <Modius> Sorear:  I kind of figured that saying :  "Okay, he's always currying this function and that function etc. etc., I'll just build the loop that does the same thing" - unless that's what you mean by deforestaton.
14:08:47 <Mitar> any haskell image library??
14:08:49 <emu> haskell, cutting down rain forests one program at a time
14:09:24 <emu> Modius: deforestation is getting rid of intermediate data structures -- often lists or trees, hence the term
14:09:50 <Modius> Just seems you'd have enough information in some cases to get rid of lambdas (and their function calls) too
14:09:54 <emu> for example, noticing that: map f . map g == map (f . g) is a transformation that can get rid of an intermediate list
14:10:16 <olsner> but doesn't map produce the result one item at a time anyway?
14:10:20 <sorear> Modius: that's called inlining, pretty much every optimizing compiler ever written does it
14:10:21 <edwardk> modius: deforestation kind of looks at the fact that you are bulding up a list, then tearing it down immediately so they just turn it into a loop, or that you are looping over a list, then performing another loop over the result, so it rewrites them into one function that goes through the list once.
14:10:23 <Modius> Aah - I forgot (being a mega-noob with Haskell, barely through the tutorial) - by "list" you are referring to combinations of functions not just sequence data structures.
14:10:40 <Modius> Sorear:  Yeah; but (at least in other languages) a first-class function can't really be inlined out.  But in pure you may have that option.
14:10:46 <mdmkolbe|home> Mitar: do you want a research image library or a "practical" image library? I.e. do you want to do images the "functional way" or do you want to manipulate jpegs?
14:10:51 <emu> olsner: still creating the extra cons cells
14:11:08 <olsner> ah, forgot about that
14:11:19 <sorear> Modius: You can't inline the passed function but you can inline the passed-to function
14:11:33 <Mitar> i render an image (functional) and i want to store the result to the disk ... no big manipulation
14:11:47 <sorear> Modius: consider eg map (+1) - once you inline map, the firstclassness goes away and (+1) can be inlined
14:12:04 <Modius> Sorear:  Okay, wasn't sure it was doing that.
14:12:05 <sorear> Mitar: install netpbm
14:12:20 <sorear> Mitar: then do man ppm
14:12:36 <sorear> ./my_program_generating_ppm_data | pnmtopng > /tmp/x.png
14:14:08 <emu> Mitar: more stuff: http://haskell.org/haskellwiki/Applications_and_libraries/Graphics
14:14:12 <lambdabot> Title: Applications and libraries/Graphics - HaskellWiki, http://tinyurl.com/3axmhe
14:14:52 <ddarius> I'm sure there are quite a few image file outputting functions in other libraries.  Things like wxHaskell, hsSDL, hsCairo and such should have something.
14:14:56 <pitecus> Are there any guidelines about when it is "safe" to make a foreign function a pure function?
14:15:05 <ddarius> pitecus: When it's pure.
14:15:08 <emu> http://hackage.haskell.org/packages/archive/pkg-list.html
14:15:12 <emu> has a gd binding
14:15:25 <shapr> sorear: Is the same true for the directory package?
14:15:48 <Mitar> hmm, there is no pure-haskell solution?
14:15:48 <sorear> shapr: Yes.  System.Directory et al
14:15:54 <pitecus> ddarius, they are never really pure, no? as in they tend to mutate variables etc
14:15:57 <Mitar> without external libraries?
14:16:05 <emu> Mitar: Pan? the functional JPEG library?
14:16:13 <emu> other ones
14:16:28 <sorear> pitecus: Doesn't matter what happens inside
14:16:32 <ddarius> pitecus: a) You certainly can have pure C, say, functions, b) it can use mutation internally and still be a pure function.
14:16:44 <sorear> pitecus: All haskell code mutates data on the stack, etc
14:17:09 <ddarius> Mitar: Yes, but why reinvent the wheel?
14:17:11 <pitecus> so basically as long as it doesnt do any IO should be OK?
14:17:29 <ddarius> pitecus: No.
14:17:42 <ddarius> And it may be okay even if it does IO.
14:19:24 <mdmkolbe|home> Do GADT's cause any "weird" stuff to happen? (e.g. like overlapping instances (and to a lesser extent multi-parameter type classes (not sure about that one (ack, scheme parens!))))
14:23:28 <hpaste>  Baughn pasted "Help me optimize withCImage?" at http://hpaste.org/88
14:23:50 <Baughn> Specifically, the fillComponents call - it takes far too much time.
14:24:56 <Baughn> It also uses too much memory, but GC time isn't the issue. Hmm..
14:51:23 <SamB> Baughn: hmm.
14:54:41 <Baughn> SamB: Replacing the fillComponents group with a simple pokeArray halved runtime, but 0.6 seconds to build an array still seems like too much
14:56:57 <Mitar> how can I check if file exists on a system?
14:57:40 <Baughn> Mitar: Try to open it. If the open fails, it didn't.
14:57:41 <SamB> hmm.
14:57:47 <Lemmih> @index doesFileExist
14:57:47 <lambdabot> System.Directory, Distribution.Compat.Directory
14:58:02 <Baughn> Actually /checking/ first is always a race condition
14:58:10 <int-e> Baughn: does that loop still read from the DiffUArray in the given image?
14:58:44 <Baughn> int-e: Except that I replaced it with "pokeArray componentptr (elems array)", which is slightly faster, it does.
14:58:56 <Baughn> There's no room for improvement in the latter, though.
14:59:54 <Baughn> Experimenting a bit, the array lookup is indeed the slow part
15:01:15 <SamB> Baughn: array lookup, eh?
15:01:31 <Baughn> :t (!)
15:01:33 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:01:46 <int-e> DiffArrays aren't very fast - every read operation reads an MVar (which means it takes it and writes it back) at the least.
15:01:55 <Baughn> (!) is slow. writeArray is not. Hmm..
15:02:02 <Baughn> I'll try to unsafeThaw it first
15:02:09 <SamB> why *are* you using diffarrays?
15:02:29 <Baughn> On the theory that the user of this library will want to /change/ the image before writing it back out
15:02:55 <SamB> why would you want to change only pieces of it?
15:03:20 <SamB> try UArray?
15:03:37 <Baughn> I'll try it..
15:03:46 <SamB> I think unsafeThaw may totally destroy the array you pass it...
15:03:49 <dmead> allo channel
15:04:01 <SamB> (for diffarrays)
15:04:08 <Baughn> It doesn't, if I don't actually write to the array. Here I only want fast reads.
15:04:31 <dmead> anyone seen this
15:04:33 <dmead> it's pretty lol
15:04:34 <dmead> http://lolcode.com/
15:04:35 <lambdabot> Title: home Â· LOLCODE
15:05:20 <SamB> Baughn: it looks like it is unsafe to me...
15:05:47 <Baughn> SamB: That's unreasonable. Well, regardless, converting to UArray completely fixed the problem, so I'm happy.
15:06:20 <int-e> hmm. the thawDiffArray code doesn't hold onto the MVar while copying, I wonder whether that's a good idea.
15:06:31 <sorear> diffarrays are a good idea, but pretty useless in practice, i've heard figures of 200x slower than plain mutable arrays
15:07:20 <int-e> yes, constant factors matter, O(1) isn't everything.
15:07:33 <emu> i'm pretty happy with my diffarrays, though i do the big construction work in STarrays
15:08:16 <SamB> Baughn: if the source array isn't the most recent version (and has Diff nodes), then unsafeThawDiffArray will happily mutate the underlying MArray...
15:09:13 <int-e> "unsafeThawDiffArray is really unsafe. Better don't use the old array at all after thawing."
15:09:37 <cdsmith53> dmead: That's an awesome language!  I might have to abandon Haskell now.
15:09:47 <SamB> ... nor any of its relatives
15:10:10 <SamB> basically it will slaughter the whole family
15:10:10 <Mitar> how could i make this is into correct function (which would return IO String wich name of first non-existing filename): find (not . doesFileExist) (zipWith (++) (repeat "voxel") (map (\i -> show i ++ ".bmp") [1..]))
15:11:44 <thorsten_> hi
15:12:09 <cdsmith> thorsten_: hi
15:12:15 <Baughn> SamB: Well, I think this is good enough for now. If anyone wants better, they can submit a patch. Thanks for you help. ^_^
15:12:25 <thorsten_> i converted the rijndael algorithm into a sat instance. is anyone interrested ?
15:12:36 <SamB> a what?
15:12:53 <Korollary> satisfiability problem
15:12:59 <thorsten_> exactly
15:13:16 <thorsten_> http://nillakaes.de/dtest.tar.gz
15:13:23 <dmead> cdsmith, i think someone could implement it by changing the token names in a pascal or cobol compiler :P
15:14:02 <emu> thorsten_: but can you do the other way? :)
15:14:04 <cdsmith> dmead: What?!?  What about parsec and ...umm, yeah!
15:14:26 <thorsten_> emu you mean sat -> rijndael ?
15:14:27 <dmead> :P
15:14:32 <Korollary> What's the complexity of rijndael?
15:14:43 <thorsten_> Korollary, exponential
15:14:47 <augustss_> linear
15:14:51 <sorear> thorsten_: Eh?
15:14:56 <emu> can't be outside of NP if he can reduce it to SAT
15:15:25 <jcreigh> pet peeve of the day: People who don't know that XML has attributes: <Address><PostalCode><Code>12345</Code></PostalCode></Address> Gah, WHY?
15:15:27 <thorsten_> every problem in p can be reduced to sat
15:15:29 <augustss_> you do it in chunks and each chunk takes a fixed amount of work
15:15:31 <Korollary> It's gotta be fast
15:15:32 <int-e> Mitar: write your own loop:  checkFiles (n:ns) = do exists <- doesFileExist n; if exists then checkFiles ns else return ns  -- would return the first non-existing file in a given list.
15:16:06 <sorear> Even *cracking* rijndael is linear.  Big O hides much!
15:16:07 <Korollary> jcreigh: The distinction between attributes and a subelement is not clear.
15:16:09 <cdsmith> jcreigh: Or, people who use XML.  WHY?
15:16:21 <emu> converting rijndael to SAT seems a bit counterproductive
15:16:30 <EvilTerran> cdsmith, heh, agreed
15:16:32 <SamB> cdsmith: it is better in some respects than a customized hairy format
15:16:36 <int-e> Mitar: uh. return n, not return ns. (clearly I didn't test the code)
15:16:37 <thorsten_> at first glance
15:16:40 <Korollary> emu: It's just theoretical messing around
15:16:44 <cdsmith> SamB: Yes, I'm being fecetious
15:16:52 <Mitar> :-)
15:16:52 <thorsten_> Korollary, yep
15:16:53 <Mitar> ok
15:17:12 <EvilTerran> i'm not. there's often a better choice, depending on what exactly you're after
15:17:39 <SamB> EvilTerran: perhaps.
15:17:45 <SamB> but perhaps not really.
15:17:53 <monochrom> I wonder why not <Address><PostalCode>12345</PostalCode><Address>
15:18:06 <jcreigh> *I* wonder why not <Address PostcalCode="12345" />
15:18:07 <EvilTerran> (sexps, json, yaml, ...)
15:18:16 <emu> monochrom: that's not XML!
15:18:20 <SamB> I also wonder this. Additionally, I wonder why it lacks any of the other information commonly found in an address
15:18:24 <emu> monochrom: not enough metadata
15:18:39 <int-e> monochrom: I wonder why not ...><digit><value>1</value></digit><...
15:18:43 <SamB> such as, oh, the street name!
15:18:51 <emu> <BeginAddressThing><StartingAddressBlock><AddressFragment>...
15:19:00 <int-e> monochrom: oh, I guess that should be <one />
15:19:01 <jcreigh> SamB: it's just an example. But for its purpose (UPS shipping rates), giving the postal code and other information as attributes would have worked fine.
15:19:07 <emu> yes i have seen @$%$&#%&!@# schemas like this
15:19:14 <cdsmith> jcreigh: serious, sometimes that's done because it's easier to visually render using old versions of CSS
15:19:29 <jcreigh> cdsmith: ah, that sounds halfway plausable.
15:19:32 <Korollary> jcreigh: giving it as subelements also works fine. Other than syntactic, what concern is there?
15:19:37 <EvilTerran> XML is often best in the current environment not on its own merit, but because there's massive community support for it
15:19:37 <SamB> CSS can render attributes now?
15:19:52 <dmhouse> SamB: CSS3 can, yes.
15:19:55 <EvilTerran> SamB: foo:before { content: attr(bar} }
15:20:06 <SamB> also, it is hard to add subelements to an attribute later
15:20:07 <cdsmith> jcreigh: and, of course, because someone saw someone who saw someone who saw someone do it that way once.
15:20:23 <jcreigh> Korollary: it's just harder to work with. There's no reason to overcomplicate things like that, IMO.
15:20:23 <SamB> that still doesn't explain the doubly-enclosed zip code though
15:20:40 <jcreigh> and anyway, sorry to spark this big OT discussion. I meant that for -blah, accidentally said it here. :)
15:20:44 <monochrom> Inside PostalCode there is no need for Code.
15:21:23 <Korollary> monochrom: maybe postal codes can sprout non-code things later on?
15:21:38 <cdsmith> Korollary: precisely!  Gotta be forward looking. :)
15:21:40 <int-e> hmm. Diffarrays just aren't threadsafe I guess.
15:22:06 <Mitar> is there anything like printf in haskell?
15:22:18 <jcreigh> <PostalCode Code="12345" /> would be just as forward compatible.
15:22:19 <Saizan> ?type printf
15:22:19 <Korollary> @index Text.Printf.printf
15:22:20 <Mitar> i would like to have integer formated to three digits ...
15:22:20 <jcreigh> Mitar: yeah, printf
15:22:22 <int-e> > printf "%d" 32 :: String
15:22:25 <monochrom> > Text.Printf.printf "%d" 10 :: String
15:22:27 <lambdabot> forall r. (PrintfType r) => String -> r
15:22:27 <lambdabot> bzzt
15:22:28 <lambdabot>  "32"
15:22:28 <lambdabot>  "10"
15:22:29 <EvilTerran> show, also?
15:22:31 <Korollary> lol
15:22:45 <monochrom> You can also use "IO a" instead of "String"
15:22:46 <EvilTerran> (but not for that sort of thing. ignore me)
15:23:12 <thorsten_> > printf "%10d" 32
15:23:12 <lambdabot>  Add a type signature
15:23:18 <monochrom> Don't you love a question split into two lines.
15:23:26 <thorsten_> > printf "%10d" 32 :: String
15:23:27 <lambdabot>  "        32"
15:23:33 <Korollary> you mean dont you love
15:23:38 <Korollary> a question split into two lines?
15:23:41 <int-e> > printf "%d" "" :: String -- note that this is a runtime error
15:23:42 <lambdabot>  Exception: Printf.printf: bad argument
15:23:52 <jcreigh> or fragements
15:23:54 <EvilTerran> why does printf need typed?
15:23:54 <jcreigh> of sentences
15:23:57 <jcreigh> spread across
15:24:02 <jcreigh> lots of messages like some
15:24:11 <int-e> printf is weird. try to understand it's source - it can teach you a lot about type classes.
15:24:13 <jcreigh> high-concept poem or something.
15:24:15 <cdsmith> EvilTerran: has to do witht he varags stuff
15:24:19 <int-e> @type printf
15:24:21 <lambdabot> forall r. (PrintfType r) => String -> r
15:24:36 <int-e> @type printf "" ""
15:24:38 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
15:25:24 <EvilTerran> now you mention it, there is something very odd about that type
15:25:30 <int-e> EvilTerran: the type will allways look like that, (PrintfType (... -> r)) => r - the type signature fixes the type for the final r.
15:25:32 <cdsmith> @instances PrintfType
15:25:33 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:26:17 <EvilTerran> int-e, so the type signature effectively tells it how many parameters there are?
15:26:18 <int-e> @source Text.Printf
15:26:19 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
15:26:25 <int-e> EvilTerran: yes.
15:26:29 <cdsmith> @instances-importing Text.Printf PrintfType
15:26:29 <EvilTerran> cunning.
15:26:30 <lambdabot> (a -> r), IO a, [c]
15:26:32 <int-e> EvilTerran: and which type they have.
15:26:34 <monochrom> printf is overloaded. can be String or IO a. In a good context you need no annotation.
15:26:46 <Mitar> > printf "voxel %3d.bmp" 12
15:26:46 <lambdabot>  Add a type signature
15:26:52 <Mitar> > printf "voxel %3d.bmp" (12 :: Int)
15:26:53 <lambdabot>  Add a type signature
15:27:01 <Mitar> > printf "voxel %3d.bmp" 12 :: String
15:27:01 <monochrom> > 'a' : printf "hello"  {- no annotation necessary -}
15:27:03 <lambdabot>  "voxel  12.bmp"
15:27:03 <lambdabot>  "ahello"
15:27:13 <int-e> monochrom: that's evil
15:27:26 <Mitar> > printf "voxel %03d.bmp" 12 :: String
15:27:27 <lambdabot>  "voxel 012.bmp"
15:27:29 <monochrom> > do { putStrLn "hello"; printf "hello" }  {- still no annotation necessary -}
15:27:30 <lambdabot>  Add a type signature
15:27:44 <monochrom> Hrm!
15:27:49 <EvilTerran> hehe
15:27:56 <monochrom> > do { putStrLn "hello"; printf "hello"; return () }  {- still no annotation necessary -}
15:27:58 <lambdabot>  <IO ()>
15:28:01 <monochrom> There!
15:28:22 <dmhouse> > do { printf "hello"; putStrLn "hello"; }
15:28:24 <lambdabot>  <IO ()>
15:29:00 <Saizan> ?type do { putStrLn "hello"; printf "hello" }
15:29:02 <lambdabot> forall t. IO t
15:29:18 <SamB> > printf "%03d" 32 :: String
15:29:19 <lambdabot>  "032"
15:29:26 <int-e> > error (printf "%d" 42)
15:29:27 <lambdabot>  Exception: 42
15:29:29 <SamB> oh, oops...
15:29:29 <EvilTerran> that's quite weird
15:29:32 <SamB> was scrolled up
15:29:33 <dmhouse> ?instances-importing Text.Printf PrintfType
15:29:34 <lambdabot> (a -> r), IO a, [c]
15:29:45 <EvilTerran> but clever
15:29:55 <dmhouse> > printf "%d" 5 :: [Int]
15:29:56 <lambdabot>   add an instance declaration for (IsChar Int)
15:29:56 <lambdabot>     In the expression: printf ...
15:29:58 <EvilTerran> the miracle of type inference, eh
15:30:02 <dmhouse> Ah.
15:30:07 <dmhouse> It's an IsChar c =?
15:30:13 <dmhouse> IsChar c => [c] instance.
15:30:18 <SamB> > putStrLn (printf "Hello!")
15:30:20 <lambdabot>  <IO ()>
15:32:55 <int-e> > fix (printf "C=%d" . ord . head)
15:32:56 <lambdabot>  "C=67"
15:33:51 <monochrom> Wicked.
15:33:54 <cdsmith> huh?
15:34:03 <dmhouse> int-e: awesome :
15:34:08 <dmhouse> s/$/)/
15:34:47 <cdsmith> oh, I see!
15:34:57 <jcreigh> great. now I have to spend the rest of the day trying to figure out why that works.
15:35:12 <dmhouse> jcreigh: fixpoints are among the weirdest things to get your head around
15:35:24 <ddarius> jcreigh: Just unroll it.
15:35:29 <jcreigh> I kinda see...but I don't htink I grok "fix" in the general case.
15:35:32 <monochrom> On a related note, I have recently done  callCC (\c -> return (fix c))
15:35:36 * dmhouse has been meaning to write something on them for a long time.
15:36:06 <ddarius> > let str = printf "C=%d" . ord . head $ str in str
15:36:08 <lambdabot>  "C=67"
15:36:15 <Korollary> monochrom: Oleg's done that too
15:36:24 <Korollary> well, something similar
15:36:31 <dmhouse> jcreigh: if you happen to own Types And Programming Languages, there's a great explanation in there
15:36:38 <monochrom> I'm slowly learning :)
15:36:44 <sorear> Korollary: Oleg did fix callCC  iirs
15:36:46 <jcreigh> > let f = printf "C=%d" . ord . head  in (f (f undefined))
15:36:48 <lambdabot>  "C=67"
15:36:48 <ddarius> fix f = f (fix f) says it all.
15:36:49 <sorear> *iirc
15:37:22 <monochrom> :t fix callCC {- does it typecheck? -}
15:37:24 <lambdabot>     Occurs check: cannot construct the infinite type:
15:37:24 <lambdabot>       m = (->) (a -> m b)
15:37:34 <cdsmith> jcreigh, dmhouse: I prefer the description from the SICP lectures.  It's really very clear and done in detail.
15:37:34 <ddarius> mfix ?
15:37:45 <monochrom> But ok, there is a newtype technique to help that.
15:42:22 <RafaelKbraw> :t isPrefixOf
15:42:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
15:43:49 <cdsmith> Hmm.  If I exactly copy the gcd code from the prelude, my version take 4.5 times as long to run as the prelude one.
15:44:14 <twanvl> Are you using -O?
15:44:19 <cdsmith> -O3
15:44:26 <ddarius> Use -02
15:44:46 <ddarius> cdsmith: Also, are you copying from the source or from the Report?
15:45:14 <cdsmith> ddarius: Actually, I'm copying from lamdabot's src command
15:45:17 <cdsmith> @src gcd
15:45:17 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
15:45:17 <lambdabot> gcd x y = gcd' (abs x) (abs y)
15:45:17 <lambdabot>    where gcd' a 0  =  a
15:45:17 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
15:45:27 <sorear> cdsmith: Use -O2
15:45:35 <cdsmith> -O2 doesn't make any different
15:45:45 <cdsmith> ...ce
15:46:03 <sorear> cdsmith: -O3 produces considerably worse code than -O0, due to a bug in the GHC option parser
15:46:44 <cdsmith> Okay, but in this case, -O2 and -O3 run about the same speed
15:46:44 <stepcut> perhaps GHC is doing some inlining because rem, gcd, and abs are all in the same module? But is not inlining when they aren't?
15:48:05 <sorear> ah, it seems GHC has an optimized version of gcd
15:48:31 <cdsmith> Aha.  That explains it.
15:48:31 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Base.lhs  search for gcdInt
15:49:17 <sorear> No, it's worse, far worse
15:50:13 <sorear> ghc uses a gcd routine written in C
15:50:23 <stepcut> :p
15:50:28 <cdsmith> Hmm.
15:50:31 <sorear> gmpn_gcd_1 to be exact
15:50:51 <Mitar> how can i convert a int into a list of word8 in little endian order?
15:51:32 <sorear> note that this is no FFI binding, it is in PrimOps.cmm (considerably faster I think)
15:52:19 <cdsmith> sorear: Hmm.  It appears GHCi uses the one from Prelude, but GHC uses that one when compiling.  I can tell the difference in the error message on gcd 0 0
15:53:23 <monochrom> Interesting
15:53:25 <sjanssen> cdsmith: it's probably the difference between -O and -Onot
15:53:37 <cdsmith> sjanssen: Ah!  probably
15:53:45 <sjanssen> ie. a RULE isn't firing in ghci
15:54:12 <cdsmith> Indeed.  Compiling without -O gives the Prelude error message
15:55:35 <cdsmith> Okay, I learned something.  Thanks!
15:56:20 <emu> Mitar: one sec
15:59:20 <sorear> Impressive.
15:59:54 <sorear> It takes GHC 17 instructions, including two indirect and one conditional branches, to implement foreign import ccall unsafe "stdlib.h abs" c_abs :: Int# -> Int#
16:00:00 <RafaelKbraw> what package isPrefixOf from ?
16:00:14 <sorear> List
16:00:40 <cdsmith> RafaelKbraw: Data.List
16:00:48 <cdsmith> @index isPrefixOf
16:00:48 <lambdabot> Data.List
16:00:49 <emu> > let littleEndian x = [x .&. 255, shiftR x 8 .&. 255, shiftR x 16 .&. 255, shiftR x 24 .&. 255] in littleEndian 259 :: [Int]
16:00:51 <lambdabot>  [3,1,0,0]
16:00:59 <emu> Mitar: use module Data.Bits
16:01:02 <emu> @doc Data.Bits
16:01:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
16:01:48 <Mitar> why this is not "transparent"
16:01:56 <Mitar> i have a need to work with
16:02:00 <emu> hmm?
16:02:00 <Mitar> binary data
16:02:17 <RafaelKbraw> ok thanks... well... how i can to know from package a function is ?
16:02:22 <Mitar> and i would like to have a possibility to write Int in two or four bytes lengths ..
16:02:38 <cdsmith> RafaelKbraw: use @index, as I just did
16:02:44 <cdsmith> @index print
16:02:44 <lambdabot> System.IO, Prelude
16:02:46 <emu> Mitar: i'm confused
16:02:53 <desp> http://lolcode.com/home
16:02:54 <lambdabot> Title: home Â· LOLCODE
16:03:08 <cdsmith> RafaelKbraw: or, http://haskell.org/ghc/docs/latest/html/libraries/doc-index.html
16:03:39 <Mitar> so, for example i have some binary format which requires that i output some data in binary form, little endian for example ..
16:03:43 <Mitar> like: http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
16:03:44 <lambdabot> Title: The .bmp file format
16:04:25 <emu> ok?
16:04:41 <emu> i was just providing an example, not amazingly clean code
16:05:09 <Mitar> i know ...
16:05:22 <Mitar> but is there some nice and transparent way to do that in haskell?
16:05:33 <emu> what do you mean by transparent?
16:06:08 <Baughn> Mitar: Something like http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.3 , for example?
16:06:10 <lambdabot> http://tinyurl.com/25ptqt
16:06:25 <emu> binary is a nice package for working with binary formats in general
16:06:40 <Baughn> Mitar: Glancing at it, it doesn't appear to provide for endianness, but you could add that with less code than writing your own would take.
16:06:53 <Baughn> Just instance Binary appropriately
16:07:23 <emu> i'm still curious what you mean by transparent
16:07:59 <monochrom> union { int32 i; word8 w8[8] };  is this what you mean by transparent?
16:08:37 <RafaelKbraw_> @index isPrefixOf
16:08:38 <lambdabot> Data.List
16:09:00 <emu> 8 word8s?
16:09:16 <Baughn> For the padding.
16:10:00 <monochrom> For making the point that it's error-prone.
16:11:03 <Mitar> transparent == write16le 1234
16:11:17 <LoganCapaldo> If I don't care about "emptyness" is there a reason to use an TMVar over a TVar?
16:11:42 <emu> Mitar: myWriteFunction . littleEndian
16:11:53 <emu> write16le = myWriteFunction . littleEndian
16:12:35 <ddarius> Mitar: Few languages have that in the standard library.
16:12:48 <emu> ok in general what you could do is create a class and instance it for Ints and your own datatype for LittleEndian or something
16:13:14 <emu> then you could write things like myfunc :: (LittleEndianable a) => a -> ...
16:14:12 * ddarius would just use phantom or wrapper types and extend a library like Binary.
16:16:46 <ClaudiusMaximus> > let leWord8s n x = if n == 0 then [] else (fromIntegral (x .&. 255) : leWord8s (n-1) (shiftR x 8)) in (leWord8s 4 (1782356::Int)) :: [Word8] -- inefficient, but seems to work
16:16:47 <lambdabot>  [84,50,27,0]
16:17:14 <LoganCapaldo> Do I even want to be using STM if I am doing IO?
16:17:25 <ddarius> Why not?
16:17:37 <LoganCapaldo> ddarius: Cause I'm really confused as to how to do it :)
16:17:57 <sorear> Mitar: Don't write .bmp files
16:18:03 <LoganCapaldo> assuming that was direct at me
16:18:21 <LoganCapaldo> s/direct/directed/
16:18:26 <Mitar> sorear: why not?
16:18:36 <sorear> Mitar: it's far too complicated
16:18:45 <Mitar> really?
16:18:52 <ddarius> Writing them isn't all that bad.
16:19:13 <sorear> Mitar: sure.  the header format is hard to remember, bit packing is tedious, etc etc.
16:19:18 <Mitar> easier than png :-)
16:19:22 <cdsmith> LoganCapaldo: You just have to separate things.  That comes with the territory, since the STM transactions can be retried.
16:19:29 <sorear> Mitar: use ppm, really
16:19:40 <EvilTerran> Mitar, TGA's nice
16:19:45 * ddarius used ppm for his music analysis program.
16:19:54 <sorear> Mitar: here's a PPM header: "P6 1024 1024 255\n"
16:19:55 <tga> wha?
16:19:55 <EvilTerran> and more featureful than, say, ppm
16:20:02 <tga> sure I am
16:20:13 <Mitar> 24 bit ppm files?
16:20:16 <sorear> Mitar: notice the lack of little endian
16:20:19 <LoganCapaldo> cdsmith: I'm just trying to read some vars and then do some IO with their values
16:20:22 <Mitar> that could be large ...
16:20:23 <EvilTerran> tga, i'm sure you are, but i was referring to the graphics form
16:20:28 <EvilTerran> *format
16:20:37 <sorear> Mitar: Smaller than 24 bin bmp files (minutely)
16:20:53 <cdsmith> LoganCapaldo: and where are you having problems?
16:20:56 <monochrom> We need a Haskell image format.
16:21:04 <EvilTerran> Mitar, not if you use binary ppm instead of plaintext ppm
16:21:19 <sorear> Mitar: seriously, you ought to delegate work.  ./myprogram | pnmtopng
16:21:50 <emu> hey just implement Discrete Cosine Transform and make jpegs
16:21:57 <sorear> Note that binary ppm uses plaintext headers.
16:22:05 <ddarius> monochrom: Why?
16:22:25 <hpaste>  cdsmith pasted "example for LoganCapaldo" at http://hpaste.org/89
16:22:28 <ddarius> JPEGs are more than just DCT
16:22:34 <sorear> Mitar: writePPMheader w h = "P6 " ++ show w ++ " " ++ show h ++ " 255\n"
16:22:34 <cdsmith> LoganCapaldo: is that what you're doing?
16:22:35 <ddarius> And the DCT is easy to implement.
16:22:44 <sorear> Mitar: now make a bmp writer that short
16:22:47 <emu> yea we did it in underclass cs
16:22:47 <Mitar> but PPM cannot have 24 bit colors ...
16:22:54 <sorear> Mitar: Huh?
16:22:55 <LoganCapaldo> cdsmith: Oh, is that all there is?
16:23:09 <LoganCapaldo> I've clearly been trying too hard
16:23:10 <cdsmith> "All there is"?
16:23:12 <sorear> Mitar: 99% of PPM's seen in the real world are 24 bit
16:23:15 <monochrom> ddarius: I like everything in Haskell :)
16:23:16 <Mitar> The maximum color value (Maxval), again in ASCII decimal. Must be less than 65536 and more than zero.
16:23:21 <Mitar> http://netpbm.sourceforge.net/doc/ppm.html
16:23:23 <lambdabot> Title: PPM Format Specification
16:23:37 <EvilTerran> monochrom, ''listArray ((0,0),(width,height)) $ map ord "binary data"''
16:23:53 <ddarius> Mitar: -per component-
16:23:55 <cdsmith> LoganCapaldo: of course, you'd try to break things up more modularly in general.  I wouldn't expose too many TVars in much of the code.
16:23:56 <sorear> Mitar: do you really think you need more than 16 bits per component!?
16:24:07 <sorear> Mitar: that's 48 bits per pixel!
16:24:10 <emu> Mitar: that would be 48-bit pixels
16:24:13 <emu> woot
16:24:14 <LoganCapaldo> cdsmith: its just one tvar and a chan
16:24:18 <Mitar> aha ...
16:24:54 <EvilTerran> er, wouldn't 65536 be 16 bpp? or is that per channel?
16:25:07 <sorear> EvilTerran: 16 bits per component
16:25:15 <EvilTerran> that's... a tad excessive
16:25:17 <Mitar> and how is binary ppm?
16:25:25 <emu> 48bpp oughta be enuf for anyone!
16:25:30 <EvilTerran> the most i knew was PNG's monochrome 16bpp
16:25:31 <ClaudiusMaximus> Mitar: are you using OpenGL to render and then doing readPixels (or similar)?
16:25:36 * emu waits for 64bpp 
16:25:42 <EvilTerran> and the usual 24bpp
16:25:52 <Mitar> i use opengl to render ...
16:25:59 <sorear> EvilTerran: PNG supports 48bpp color just fine
16:26:01 <cdsmith> LoganCapaldo: type alert.  That '=' should be '<-'
16:26:12 <EvilTerran> sorear, okay. i didn't know of that, tho.
16:26:15 <LoganCapaldo> cdsmith: yeah i figured that out already :)
16:26:18 <cdsmith> cdsmith s/type/typo/  bleh
16:26:20 * ddarius waits for eyes that can differentiate that many colors.
16:26:20 <LoganCapaldo> but thanks
16:26:23 <Mitar> but i stored the rendered image in the list before (i compute list of pixels and then render that with opengl)
16:26:42 <emu> cat eyes?
16:26:51 <sorear> @let writePPM24 w h d = "P6 " ++ show w ++ " " ++ show h ++ " 255\n" ++ concat [ chr (fromIntegral (floor (c*255))) | (r,g,b) <- d , c <- [r,g,b] ]
16:26:59 <lambdabot> Couldn't match expected type `[Char]' against inferred type `Char'
16:27:09 <sorear> @let writePPM24 w h d = "P6 " ++ show w ++ " " ++ show h ++ " 255\n" ++ [ chr (fromIntegral (floor (c*255))) | (r,g,b) <- d , c <- [r,g,b] ]
16:27:11 <lambdabot> Defined.
16:27:16 <sorear> @type writePPM24
16:27:18 <lambdabot> Not in scope: `writePPM24'
16:27:22 <sorear> @type L.writePPM24
16:27:24 <lambdabot> Couldn't find qualified module.
16:28:05 <sorear> > L.writePPM24 5 5 [ (x/5,y/5,0) | y <- [0..5] , x <- [0..5] ]
16:28:06 <lambdabot>  "P6 5 5 255\n\NUL\NUL\NUL3\NUL\NULf\NUL\NUL\153\NUL\NUL\204\NUL\NUL\255\NUL\...
16:28:14 <Mitar> ClaudiusMaximus: interesting idea, i have no idea about that possibility ... so i could store those pixels directly into the file from opengl rendering ...
16:28:22 <EvilTerran> I've had trouble with @type not being able to see @let'd stuff...
16:28:56 <ClaudiusMaximus> Mitar: yeah, the pixels are the correct format, except for one detail (which can be solved afterwards by flipping the image vertically)
16:29:22 <Mitar> in correct format for what?
16:29:36 <sorear> Mitar: .bmp brokenness I suspect
16:29:40 <ClaudiusMaximus> Mitar: binary PPM
16:30:48 <mdmkolbe|home> Does the 'a' in the GADT "data Foo a where ..." have any meaning more than specifying the kind of "Foo"?  Is it in scope at all in the body?
16:31:10 <dmhouse> mdmkolbe|home: err, yes, just like a normal datatype.
16:31:47 <sorear> dmhouse: no, it only specifies a kind
16:32:01 <sorear> dmhouse: indeed, you don't even have to name the arguments
16:32:11 <sorear> data Foo :: * -> * where ..
16:32:19 <mdmkolbe|home> dmhouse: "data Foo a where FooUnit :: b -> Foo b"
16:32:41 <dmhouse> sorear, mdmkolbe|home: oh, sorry, that's something I didn't know.
16:34:37 <mdmkolbe|home> I take it then that the standard style for writting GADTs would be "data Foo :: * -> * where ..." instead of the other way b/c otherwise you have a meaningless name.  Is that correct?
16:35:08 <sorear> mdmkolbe|home: Normally people give names, for the mnemonic value.
16:35:32 <sorear> mdmkolbe|home: obsessivly not naming things is considered pointless
16:35:51 <EvilTerran> altho using ::*->* would make it clear that something unusual was happening
16:36:05 <mdmkolbe|home> pointsfree? ;-J
16:36:40 <sorear> mdmkolbe|home: Pointless is a widely recognized synonym of pointsfree
16:36:49 <Mitar> how can one use readPixels ?? i am reading the type and does not get it ...
16:37:30 <ClaudiusMaximus> readPixels (Position 0 0) (Size w h) (PixelData RGB UnsignedByte p)
16:37:32 <ClaudiusMaximus> writePPM handle p
16:37:46 <ClaudiusMaximus> where p is a pointer you declared earlier
16:38:13 <mdmkolbe|home> Hmm GHC doesn't seem to support this but couldn't the compiler just infer the kind from the body? (e.g. "data Foo where FooUnit :: a -> Foo a" is obviously "Foo :: * -> *")
16:40:13 <SamB> mdmkolbe|home: it could sometimes... but your readers might prefer not to need to do so as well
16:40:49 <mdmkolbe|home> SamB: true, though the same could be said about most type inference
16:40:55 <Mitar> and i make a ptr with ioref?
16:41:25 <EvilTerran> mdmkolbe|home, i was reading the paper earlier, and i got the impression that it doesn't, for reasons of keeping the inference engine sane and the error messages decipherable
16:41:25 <SamB> mdmkolbe|home: I can pretty well tell you that the reader would prefer not to wade through *all* the types...
16:41:29 <ClaudiusMaximus> Mitar: newIORef nullPtr -- i think this is enough, i can't find any allocation in my uncommented code...
16:42:00 <dons> ?yow
16:42:01 <lambdabot> TONY RANDALL!  Is YOUR life a PATIO of FUN??
16:42:08 <dons> ?users
16:42:08 <lambdabot> Maximum users seen in #haskell: 340, currently: 297 (87.4%), active: 50 (16.8%)
16:42:11 <dons> ?uptime
16:42:11 <lambdabot> uptime: 12d 9m 54s, longest uptime: 13d 18h 36m 21s
16:42:24 <ClaudiusMaximus> Mitar: oops, i do allocate it
16:42:38 <ClaudiusMaximus> Mitar: pixels <- (mallocArray (fromIntegral (w * h * 3))) :: IO(Ptr CChar)
16:42:55 <Mitar> gah ... i though i will never see malloc in haskell ..
16:42:59 <Mitar> you must be kidding me?
16:43:01 <mdmkolbe|home> SamB: If it doesn't cause ambiguity for the compiler, then whether to allow it comes down to whether to allow the program writter to choose how to present the program.  Oh well, it doesn't really matter that much o me.
16:43:05 <ClaudiusMaximus> Mitar: that's in the reshape callback
16:43:09 <mdmkolbe|home> s/o/to/
16:43:28 <Mitar> why do you need this in a reshape callback?
16:43:40 <Mitar> i only resize the viewport there ..
16:44:01 <dibblego> is there an application that will simplify logical statements? e.g. simplify !(!p & !q & r)
16:44:11 <ClaudiusMaximus> Mitar: so that you have a new array the right size for all the data
16:45:05 <SamB> mdmkolbe|home: well, it would need implementing anyway
16:45:08 <mdmkolbe|home> dons: BTW, I've been able to generalize the zipper to support DAGs per our previous conversation about using the zipper in Xmonad, but I'm still working on cycles
16:45:42 <Mitar> so you are using this array also for other things?
16:46:14 <ClaudiusMaximus> Mitar: no; it's where readPixels writes the pixels from the gfx card into
16:47:15 <ddarius> dibblego: Yes
16:47:29 <Mitar> ok, i understand now ... but i am interested now what does your program do so that it needs this on reshape?
16:47:34 <dibblego> ddarius, what is its name?
16:47:35 <olsner> how do you write functions to work on both ByteString and String?
16:47:49 <ddarius> dibblego: Heck if I know, I just know that there are bunches.
16:47:59 <dibblego> ddarius, google search term even?
16:48:02 <ddarius> olsner: Type classes
16:48:14 <ClaudiusMaximus> Mitar: so that when the size changes, you free the array (if it is allocated) and allocate a new one big enough
16:48:22 <olsner> or, preferrably on generalized lists of generalized tokens
16:48:47 <ddarius> boolean expression/function simplification
16:49:01 <Mitar> hmm, i need to free this pointer somewhere?
16:49:07 <Mitar> or is it garbagecollected?
16:49:20 <ddarius> :t free
16:49:28 <lambdabot> Not in scope: `free'
16:49:34 <ddarius> @hoogle free
16:49:35 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
16:49:35 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
16:49:35 <lambdabot> Foreign.StablePtr.freeStablePtr :: StablePtr a -> IO ()
16:49:35 <ClaudiusMaximus> Mitar: yes, with free (or if your OS is modern it will be freed at program termination)
16:50:27 <ddarius> dibblego: Also looking at propositional logic stuff will no doubt also return things.
16:50:34 <dibblego> ddarius, thanks
16:51:03 <ddarius> dibblego: You can probably find something in Haskell fairly easily if you care.
16:53:01 <Mitar> :t CChar
16:53:03 <lambdabot> Not in scope: data constructor `CChar'
16:53:14 <Mitar> where have you found this CChar?
16:53:33 <Mitar> Foreign.C.Types
16:54:34 <Mitar> :t GLsizei
16:54:36 <lambdabot> Not in scope: data constructor `GLsizei'
16:55:25 <sorear> ClaudiusMaximus: "modern"? 1969 UNIX automatically freed data segments aiui
16:55:45 <sorear> most *people* here aren't that old
16:56:01 <ClaudiusMaximus> ?localtime ClaudiusMaximus
16:56:04 <lambdabot> Local time for ClaudiusMaximus is Mon May 28 23:51:02 2007
16:56:20 <mdmkolbe|home> @index CChar
16:56:20 <lambdabot> Foreign.C.Types, Foreign.C
16:56:26 <mdmkolbe|home> @index GLsizei
16:56:26 <lambdabot> Graphics.Rendering.OpenGL.GL.BasicTypes, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
16:56:37 * ClaudiusMaximus goes to eat and sleep, in some order
16:56:41 <dons> mdmkolbe|home: very interesting, re zipper.
16:57:11 <olsner> some Windows versions are notorious for leaving various OS objects hanging around, aiui though
16:58:19 <mdmkolbe|home> dons: Yeah, now I just have to descide what is the most appropriate venue to propagate the trick to it (and whether to wait until I can figure out how to do cycles)
16:58:40 <ddarius> Good luck with cycles
16:59:03 <sorear> dons: what's the subject ... blogreply?
16:59:05 <astrolabe> That's odd.  I was thinking about zippers for DAGs in another context.
16:59:32 <dons> sorear: irc reply
17:00:17 <mdmkolbe|home> astrolabe: oh? what context was that?
17:00:58 <sorear> sure, with a little cleverness you can zip cyclic structures
17:01:18 <sorear> circular lists can be zipped with (a, Seq a)
17:01:28 <astrolabe> mdmkolbe|home: searching a game tree.  For some search strategies (eg proof number search), you need to keep the whole tree and modify it.
17:02:34 <astrolabe> obviously for some games (eg chess) the tree has repititions, and can be thought of as a DAG.
17:02:54 <mdmkolbe|home> speaking of zippers.  What is a one hole context when there is no hole? (i.e. a sort of cursor into a data structure that can lie to the left (or right if you prefer) of any place that I hole could)
17:04:18 <mdmkolbe|home> astrolabe: I see, so would you perhapse be modifying the tree as you apply some huristic to extend and explore the tree
17:04:28 <sorear> mdmkolbe|home: one hole contexts are a mechanically derivable realization of the abstract concept of zipper
17:05:02 <sorear> ([a],[a]) is a holefree zipper on a sequence of a's
17:05:04 <mdmkolbe|home> sorear: "zip" cyclic data structures or "zipper" cyclic data structures
17:05:10 <olsner> argh, multi-parameter type-classes seem to be quite troublesome
17:05:24 <sorear> mdmkolbe|home: "abuse" "nomenclature" i think
17:05:43 <astrolabe> mdmkolbe|home: exactly
17:05:51 <mdmkolbe|home> sorear: heh
17:05:56 <olsner> the error messages suggest that I provide instance for seven anonymous types t3, t2, t1, t11, t, t4 that seem to refer to different expressions in the called function
17:06:31 <monochrom> would some fundep help?
17:06:49 <olsner> they probably would help to know about, yes
17:08:42 <mdmkolbe|home> sorear: so yeah if (l::[a],r::[a]) is the one hole context for x::[a] where (len l)+(len r)+1==len x, and (l::[a],a::a,r::[a]) is the zipper for x::[a] where (len l)+(len r)+1==len x, when what is (l::[a],r::[a]) for x::[a] where (len l)+(len r)==len x ?
17:09:13 <mdmkolbe|home> err..well maybe saying it even that way isn't quite right
17:11:51 * mdmkolbe|home just talked himself back to using regular one-hole contexts
17:13:26 <olsner> functional dependencies seems to be exactly what I want, but what is the syntax? the paper I found just uses squiggly arrows :P
17:13:48 <sorear> mdmkolbe|home: a different realization of the abstract concept of zipper
17:13:57 <sorear> class Foo a b | a -> b
17:14:11 <mdmkolbe|home> olsner: "class Foo a b c d | a b -> c d where ..." reads "any specific a and b determines both c and d"
17:14:39 <mdmkolbe|home> sorear: a zipper is just a one-hole context plus what to put in that context
17:14:51 <olsner> ah, that seems to actually work!
17:16:00 <olsner> beautiful
17:16:03 <monochrom> squiggy arrows for the win
17:16:20 <monochrom> We need a Haskell keyboard, featuring all squiggol symbols.
17:16:31 <olsner> there, twice as fast with bytestrings
17:16:57 <jfredett> lol, monochrom then we'ed become APL, not haskell.
17:17:23 <jfredett> though- it would be neat to have some haskellian characters, arrows and whatnaught.
17:18:10 <olsner> APL+Haskell = a purely functional array language that is not merely hard to think about but also nigh impossible to type!
17:18:12 <monochrom> Don't worry, APL doesn't have monads, we do.
17:18:33 <jfredett> lol...
17:18:41 <rt> damn, i'm bored.
17:19:04 <jfredett> write code!
17:19:11 <mdmkolbe|home> olsner: *and* it can implement a complete lambda calulus interpreter and type checker in 15 characters
17:19:12 <monochrom> Learn the Cont monad, rt, if you are bored.
17:19:17 <Korollary> rt: Watch the Ducks at the stanley cup finals if you're from southern CA.
17:20:20 <matthew-_> yay! if I put in enough unsafeCoerce# then it compiles!
17:21:37 <twanvl> anything compiles if you put enough unsafeCoerce in it
17:21:49 <ddarius> APL has monads
17:22:09 <jfredett> well, its TC, so we should just implement Haskell in APL
17:22:11 <monochrom> How about type classes?
17:22:24 <ddarius> No, no type classes.
17:22:28 * rt admits that there is an infinite amount of stuff i could learn about haskell, but I've exhausted my brain for today.
17:22:35 <monochrom> Good!
17:23:07 <mdmkolbe|home> matthew-_: heresy! stone him! (nope thats 200 BC) crucify him! (nope that's 100 AD) burn him! (darn still only 1000AD) what do we do with a heretic now days?
17:23:40 <jfredett> slap him on the wrist and let him go
17:23:45 <Korollary> Sue his ass
17:23:48 <jfredett> and give him a stern look
17:24:00 <matthew-_> admit that there are cases where I know better than the haskell type checker?
17:24:00 <ddarius> Firebomb
17:24:19 <ddarius> matthew-_: You are probably wrong.
17:24:38 <monochrom> What you do to a heretic now: call him terrorist
17:24:56 <ddarius> There are plenty of heretics that aren't terrorists.
17:25:00 <matthew-_> ddarius: no, I'm not. I understand closed classes, and what that means. The haskell type checker doesn't
17:25:17 <monochrom> ddarius is right, but that's what anti-heretics do.
17:25:56 <ddarius> No, no.  There are plenty of people that anti-heretics call heretics and (usually) don't call terrorists.
17:26:16 <mdmkolbe|home> matthew-_: now you've got my interest, could you give an example?
17:26:54 <matthew-_> mdmkolbe|home: not easily in less than 1000 horrible lines of code
17:26:55 <monochrom> I can't win.
17:27:33 <matthew-_> mdmkolbe|home: I'm basically able to infer types that Haskell can't because of the fact that I know exactly what instances of classes there are
17:27:35 <ddarius> monochrom: Heretic!
17:27:55 <matthew-_> Haskell always assumes that type classes are open, and this limits type inference
17:28:35 <ndm> hi
17:28:38 <ndm> i have cabal questions!
17:28:54 <mdmkolbe|home> matthew-_: so you're taking a quallified type and casting it to the only concrete type that instantiates those qualifications?
17:29:07 <ndm> if you are building an executable, it says exposed-modules is not valid, only in a library
17:29:22 <ndm> so how do you specify source code which makes up the library?
17:29:31 <olsner> mdmkolbe|home: nah, make that *1* character! compile+eval will be the unary > operator
17:29:39 <jfredett> hmm, i need a better prime number generator, time for seive of atkin...
17:29:51 <sorear> ndm: Uh, what would exposing modules *mean* in a non-lib?
17:29:56 <wastez> Hello, is it normal that after compiling a Gtk2HS program I don't get any kind of feedback (no window or exception in console). I'm using GHC 6.6
17:30:09 <sorear> ndm: you should make a library and an exec which depends on the lib
17:30:20 <ndm> sorear, who cares, what do i stay to mean "these modules are part of the source code of this?"
17:30:22 <matthew-_> mdmkolbe|home: yes, pretty much.
17:30:27 <sorear> ndm: oh. other-modules
17:30:32 * mdmkolbe|home shivers
17:30:58 <ndm> sorear, thanks :)
17:31:09 <bos> ndm: it's awkward to build both libraries and executables from a single cabal file
17:31:12 <bos> just fyi
17:31:34 <matthew-_> mdmkolbe|home: heh, yeah. Well, it's actually safe in terms of type signatures. It's not safe in terms of I'm unpacking values from ADTs and casting them.
17:31:41 <emu> really? i do it all the time
17:32:35 <emu> i just add Executable: clauses
17:32:51 <sorear> ndm: pitecus came in 3.5h ago asking about Data.Derive.TH which is apparently still used in the documentation
17:33:00 <mdmkolbe|home> matthew-_: maybe that's nessisary in your app, but I would seriously reconsider the design of your application (maybe add another class that encapsulates what ever it is you're needing the cast for) (in an existing multi-k-line app that may be infeasiable though)
17:33:01 <ndm> bos, i only want to build an executable
17:33:09 <ndm> sorear, oh, the manual?
17:34:11 <matthew-_> mdmkolbe|home: oh, it's not possible I'm afraid. And this is all written by me in the last few weeks
17:35:18 <wastez> dcoutts: I think the Gtk2HS tutorial for glade (http://haskell.org/gtk2hs/docs/tutorial/glade/) needs a "widgetShowAll window" in the source code for it to work.
17:35:19 <lambdabot> Title: Gtk2Hs » Documentation » Glade Tutorial
17:35:24 <matthew-_> mdmkolbe|home: basically, take a type-level list. Make a chain of MVars so that you can walk down the list and either write to on read from each MVar in turn, where the value in the MVar is the value in the type-list plus the MVar of the next elem. That's all fine. Now add to the type-level list looping and branching structures. Good luck. ;)
17:35:47 <ndm> sorear, manual updated now
17:39:02 <sorear> matthew-_: I heartily recommend the use of real dependant programming :)
17:39:55 <mdmkolbe|home> matthew-_: I'd need a couple days to catch up on my type level lists (I've seen them before I just need to refresh) to judge or myself if it's nessisary
17:39:58 <ddarius> You can embed the lambda calculus into the type language, this should be nothing.
17:40:53 <mdmkolbe|home> ddarius: if you can do that then why isn't Haskell already dependantly typed?
17:41:17 <matthew-_> sorear: indeed. And the only reason I don't is that I actually need things like threads, sockets, MVars, STM etc etc
17:41:56 <ddarius> mdmkolbe|home: Having the lambda calculus at the type level available doesn't make Haskell dependently typed.
17:45:59 <mdmkolbe|home> ddarius: I had to think about that, but now I see you're right
17:46:38 <byorgey_> @pl \f g (x,y) = (f x,g y)
17:46:38 <lambdabot> (line 1, column 12):
17:46:38 <lambdabot> unexpected "="
17:46:38 <lambdabot> expecting pattern or "->"
17:46:47 <byorgey_> @pl \f g (x,y) -> (f x,g y)
17:46:48 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
17:46:54 <byorgey_> gah
17:47:37 <mdmkolbe|home> byorgey_: I've been wishing for that operator for a while (Stratego has it)
17:48:11 <Jessehk> I'm still learning Monads, and I was having difficulty with StateT. Could anyone help my fill in the blanks? http://hpaste.org/90
17:48:19 <byorgey_> mdmkolbe|home: yeah, could be useful...
17:48:22 <Jessehk> s/my/me
17:49:04 <Saizan> ?type (***)
17:49:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:49:27 <ndm> Ilgoo, what were the warning messages in filepath? -fwarn-single-letter-variables?
17:49:29 <mdmkolbe|home> Jessehk: now you need a function that does whatever change to the deck you want to make and you 'put' the new state of the deck
17:49:33 <mdmkolbe|home> ?type put
17:49:35 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
17:49:43 <kpreid> @type \f g -> first f . second g
17:49:45 <lambdabot> forall c b c1 d. (d -> c) -> (b -> c1) -> (d, b) -> (c, c1)
17:50:08 <kpreid> byorgey_: depending on the context, this might be a nice expression
17:50:25 <Jessehk> mdmkolbe|home: I have a function to do that. It returns IO (Card, Deck)
17:50:36 <byorgey_> @type second
17:50:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
17:50:57 <mdmkolbe|home> Jessehk: eh, can you do it without the IO?
17:51:15 <mdmkolbe|home> @index second
17:51:16 <lambdabot> Control.Arrow
17:51:25 <Jessehk> mdmkolbe|home: Maybe, I don't really know. ;) I thought I needed the IO for the randomness
17:51:30 <byorgey_> kpreid: interesting.  actually, I'm not using it for anything, I'm just reading the "Bananas, Lenses,..." paper =)
17:51:30 <kpreid> oh, it's generalized to arrows if you replace . with <<< or >>>
17:51:41 <kpreid> @type \f g -> first f -> second g
17:51:43 <kpreid> er
17:51:43 <lambdabot> Parse error in pattern
17:51:47 <kpreid> @type \f g -> first f >>> second g
17:51:48 <lambdabot> forall (a :: * -> * -> *) b c b1 c1. (Arrow a) => a b c -> a b1 c1 -> a (b, b1) (c, c1)
17:51:55 <kpreid> byorgey_: oh, okay.
17:52:23 <Saizan> Jessehk: randCard = do d <- get; (d',c) <- liftIO $ randCard' d; put d'; return c
17:52:34 <ddarius> kpreid: That's the definition of *** that Saizan referenced.
17:52:38 <byorgey_> kpreid: yikes.  I'm still not sure what arrows are/do... someday. =)
17:52:41 <ddarius> (or _a_ to be particular)
17:52:58 <mdmkolbe|home> Jessehk: you can probably 'lift' that operation from IO (Card,Deck) to StateT Deck IO (Card, Deck)
17:53:01 <mdmkolbe|home> @type lift
17:53:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:53:04 <kpreid> ddarius: huh, so it is. I looked at that and misread it!
17:53:21 <kpreid> byorgey_: in this context, think of it as a generalization of (->)
17:53:28 <Saizan> Jessehk: err, (c,d') actually
17:53:50 <kpreid> byorgey_: take an (Arrow a) => type signature and replace a with (->) and you'll understand it in terms of functions
17:54:10 <byorgey_> kpreid: ok.  interesting.
17:54:18 <mdmkolbe|home> Jessehk: yeah, what Saizan said (I hadn't read it until after my last reply)
17:54:44 <byorgey_> kpreid: so (Arrow a) => a b c would be sort of like b -> c ?
17:54:48 <kpreid> yes!
17:54:55 <byorgey_> kpreid: but somehow more general?
17:55:07 <kpreid> they can have extra features
17:55:10 <mdmkolbe|home> @src Arrow (->)
17:55:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:55:54 <byorgey_> kpreid: extra features... sort of like monads?
17:56:16 <Saizan> byorgey_: yes, they are more general than monads
17:56:17 <Jessehk> Saizan mdmkolbe|home: Thanks. I thought it was something along those lines, but the nested monads confused me.
17:56:23 <kpreid> byorgey_: arrows are used for the same sort of things as monads, but the arrow system forces the *data* flow to be explicitly written (such that th earrow implementation can see it) rather than hiding it behind ">>= \x ->"
17:56:49 <kpreid> byorgey_: and an arrow doesn't necessarily allow a program to choose what to do next.
17:57:03 <Saizan> Jessehk: remeber to use lift, or liftIO when you are using a computation in the inner one
17:57:23 <kpreid> byorgey_: this is strictly less powerful than monads for the user, but it allows an arrow type to do more interesting things. for example, more efficient parser combinators, and data-flow stuff.
17:57:30 <mdmkolbe|home> byorgey_: technically less features, since more general => less is known about the actual type, but at the same time more functions can bewritten to comply with the interface since less is required
17:57:31 <Saizan> Jessehk: you might need more than one level, lift . lift $ act
17:57:56 <byorgey_> kpreid, mdmkolbe|home: ok, thanks.  that makes sense in general.  one of these days soon I will go read up on them in more detail!
17:58:01 <kpreid> byorgey_: you can turn any monad into an arrow using Kliesli
17:58:21 <Saizan> Jessehk: only when you have more than one transformer, off course
17:58:23 <byorgey_> kpreid: what is Kliesli?
17:58:34 <kpreid> @index Kliesli
17:58:35 <lambdabot> bzzt
17:58:40 <kpreid> @type Control.Arrow.Kliesli
17:58:42 <lambdabot>     Not in scope: data constructor `Control.Arrow.Kliesli'
17:58:45 <kpreid> @type Control.Arrow.Kleisli
17:58:47 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
17:59:04 <kpreid> @type runKleisli
17:59:06 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
17:59:17 <mdmkolbe|home> Jessehk: FYI, some of the built-in monad transformers save you the trouble of doing the lift (e.g. StateT and ReaderT), but I guess StateT doesn't automatically lift IO for you. (Just FYI in case you get code that unexpectedly works witout the lift)
17:59:19 <kpreid> hrm, not obvious
17:59:23 <byorgey_> kpreid: ok, I see.
17:59:33 <byorgey_> kpreid: at least, I think I do =)
17:59:48 <kpreid> byorgey_: basically, it packages up a monad type (m b) with an argument type (a) so that it fits the shape of an arrow
18:00:03 <kpreid> Kleisli (a -> m b) is an arrow
18:00:30 <kpreid> well, actually, Kleisli m is an Arrow
18:00:33 <mdmkolbe|home> byorgey_: Kliesli is an arrow that has an "apply" operation.  Adding that operation makes it exactly equivalent to a monad
18:00:34 <Saizan> mdmkolbe|home: IO is never completely automatically lifted, you just need liftIO instead multiple lifts though
18:01:08 <mdmkolbe|home> Saizan: is there a type reason for that or just to keep the cost of using IO appropriately high?
18:01:25 <mdmkolbe|home> cost = psichological cost not run time cost
18:01:36 <monochrom> StateT actually supports liftIO
18:01:39 <mdmkolbe|home> s/psi/psy/
18:02:02 <Mitar> what would be a nice way to split a list into lists with n elements (so first n elements would go into first list, second n elements into second ...)
18:02:02 <Saizan> mdmkolbe|home: you'd need a MonadIO context on all the IO primitives
18:02:13 <mdmkolbe|home> @src MonadIO
18:02:14 <lambdabot> Source not found. Take a stress pill and think things over.
18:02:19 <byorgey_> kpreid, mdmkolbe|home: ok, I see.  If I want to read more about arrows where's a good place to start?  Are there any sort of seminal papers or anything?  Or anything in some documentation?
18:02:19 <mdmkolbe|home> @source MonadIO
18:02:20 <lambdabot> MonadIO not available
18:02:24 <mdmkolbe|home> @doc MonadIO
18:02:25 <lambdabot> MonadIO not available
18:02:29 <mdmkolbe|home> @index MonadIO
18:02:29 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:02:39 <mdmkolbe|home> @doc Control.Monad
18:02:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
18:02:44 <kpreid> byorgey_: I just read http://www.haskell.org/arrows/biblio.html
18:02:45 <lambdabot> Title: Arrows: bibliography
18:02:55 <jfredett> you know, I wish I had lambdabot as my Haskell interpreter, rather than ghci
18:03:01 <kpreid> byorgey_: (the other pages in that area as well as the papers)
18:03:02 <byorgey_> kpreid: ah! that looks like an excellent place to start! =)  thanks.
18:03:05 <ddarius> @hoogle chunk
18:03:05 <lambdabot> Control.Parallel.Strategies.parListChunk :: Int -> Strategy a -> Strategy [a]
18:03:13 <kpreid> byorgey_: the "Introduction" has very nice diagrams
18:03:32 <ddarius> Mitar: Look at splitAT
18:03:41 <ddarius> s/splitAT/splitAt
18:03:44 <byorgey_> kpreid: ok, thanks, I will check it out
18:04:06 <kpreid> byorgey_: when trying to read arrow types, it can help to remember that "a b c" is just like "b `a` c"
18:04:35 <kpreid> first :: b `a` c -> (b,d) `a` (c,d)
18:04:38 <Mitar> yes, but this only returns first n elements and the rest .. i would like to get a list of lists which all of them have n elements
18:04:55 <byorgey_> kpreid: ok, I will keep that in mind.  ah, that makes sense.
18:05:24 <monochrom> (Arrow ~>) => b ~> c -> (b,d) ~> (c,d)   actually works on some compilers
18:05:30 <mdmkolbe|home> ok, to bed.  night all
18:06:08 <ddarius> Mitar: The function you want is commonly wanted, but you can make it with splitAt fairly easily.
18:07:34 <Mitar> hmm, one other question
18:08:46 <Mitar> is there anything like parMapChunk which would apply a function on elements in parallel but in chunks (so each thread would work on one chunk and that it would not build new thread for every element)
18:09:50 <bos> Mitar: you're veering into nested data parallelism territory there. i don't know of a standard function to do that, because it's moderately complicated.
18:09:55 <ddarius> Presumably that is what parListChunk does if I understand you correctly.
18:10:30 <Saizan> isn't that just parMap on the list of chunks
18:10:33 <Saizan> ?
18:11:06 <Mitar> i thought so ... but type is not like that ...
18:11:15 <Mitar> it just applies strategy to a list ...
18:11:20 <Saizan> ?type parMap
18:11:23 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
18:11:46 <bos> Control.Parallel.Strategies is so fiddly.
18:12:12 <Mitar> ?type parListChunk
18:12:14 <lambdabot> forall a. Int -> Strategy a -> [a] -> Done
18:16:12 <Mitar> how could i evaluate this strategy then?
18:17:13 <sorear> huh?
18:17:38 <Mitar> so there is no parMapChunk?
18:18:15 <ddarius> Mitar: You just map the function then use parListChunk to evaluate it.
18:18:42 <byorgey_> @type (&&&)
18:18:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:18:47 <Saizan> parMapChunk n f = parListChunk n . map f
18:19:26 <Saizan> ?pl parMapChunk n f = parListChunk n . map f
18:19:26 <lambdabot> parMapChunk = (. map) . (.) . parListChunk
18:20:44 <Mitar> but the type is Done and not the [a] i would get from map
18:21:32 <Mitar> ?t parMap
18:21:33 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:21:53 <ddarius> Mitar: You use it as let ys = map f xs in parListChunk n ys `seq` ys or some such craziness.
18:21:53 <Mitar> ?type parMap
18:21:55 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
18:22:18 <Saizan> parMapChunk s n f xs = let list = map f xs in parListChunk s n list `seq` list
18:24:03 <Mitar> thanks
18:24:08 <edwardk> is there a good way in ghc to say that i want a 128 bit value that is 128 bit aligned unboxed inside a given data type?
18:25:06 <edwardk> (for things like SSE)
18:25:39 <ddarius> There's a way to say that at all?
18:26:07 <edwardk> well, its like Int#, just bigger ;)
18:27:56 <ddarius> edwardk: I'm not sure you can specify alignment constraints.
18:27:59 <ddarius> @hoogle Word128
18:28:00 <lambdabot> No matches found
18:28:06 <sorear> edwardk: GHC doesn't believe in alignment, period.
18:28:08 <ddarius> @index Word128
18:28:08 <lambdabot> bzzt
18:28:10 <edwardk> hrmm
18:28:20 <edwardk> =(
18:28:32 <sorear> edwardk: as far as ghc is concerned, the x86 has 32-bit bytes and everything is byte aligned, even Double
18:28:44 <edwardk> ah ick
18:29:22 <edwardk> so no sse-optimized strict list data family for me basically ;)
18:29:31 <Mitar> i tried with scanl and splitat to get splitting the list into lists with n elements but i have not find a elegant solution
18:30:57 <EvilTerran> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 4 xs)) [1..]
18:31:02 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20],[21,22,23,24],...
18:31:21 <dibblego> does multi-parameter type-classes have another name?
18:31:30 <monochrom> MPTC if you will
18:31:57 <monochrom> sometimes: multiple parameter type class
18:32:35 <EvilTerran> Mitar, how's that ^?
18:32:52 <ddarius> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 2 xs)) [1..5]
18:32:53 <lambdabot>  [[1,2],[3,4],[5]]
18:33:00 <Mitar> oh
18:33:07 <Mitar> nice ...
18:33:17 <Mitar> unfoldr ..
18:33:35 <sorear> > map(flip map [0..3].(+)) [0,4..]
18:33:36 <lambdabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],[...
18:33:37 <EvilTerran> you could possibly do something with mapAccumL, as well
18:33:43 <ddarius> > unfoldr (\xs -> guard (null xs) >> return (splitAt 2 xs)) [1..4]
18:33:44 <lambdabot>  []
18:33:54 <ddarius> > unfoldr (\xs -> guard (not $ null xs) >> return (splitAt 2 xs)) [1..4]
18:33:55 <lambdabot>  [[1,2],[3,4]]
18:34:33 <twanvl> > unfoldr (listToMaybe . cojoin . splitAt 2) [1..5]
18:34:33 <lambdabot>   Not in scope: `cojoin'
18:34:58 <twanvl> For some definition of cojoin
18:35:30 <mauke> > unfoldr (\xs -> do _:_ <- return xs; return $ splitAt 2 xs) [1..4]
18:35:31 <lambdabot>  [[1,2],[3,4]]
18:35:43 <mauke> delicious
18:35:54 <ddarius> mauke: I was considering that, but didn't like the return xs
18:35:57 <edwardk> er that also rules out dumping to core and using ghc to compile my back end =(
18:36:34 <byorgey> mauke: why do you need the _:_ pattern match?
18:36:48 <ddarius> byorgey: Lookup the translation of do notation in the report.
18:37:11 <EvilTerran> byorgey, it's an (IMO uglier) way of doing not.null
18:37:24 <twanvl> > takeWhile (not . null) . unfoldr (Just . splitAt 2) $ [1..5]
18:37:26 <lambdabot>  [[1,2],[3,4],[5]]
18:37:29 <byorgey> EvilTerran: oh, I get it
18:37:33 <ddarius> > unfoldr (\xs -> do _:_ <- Just xs; Just $ splitAt 2 xs) [1..4]
18:37:35 <lambdabot>  [[1,2],[3,4]]
18:37:51 <EvilTerran> or rather, guard (not.null xs)
18:38:33 <ddarius> @src takeWhile
18:38:33 <lambdabot> takeWhile _ []                 =  []
18:38:33 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
18:38:33 <lambdabot>                    | otherwise =  []
18:39:59 <twanvl> > takeWhile (not . null) . iterate (drop 2) $ [1..5]
18:40:00 <lambdabot>  [[1,2,3,4,5],[3,4,5],[5]]
18:40:05 <twanvl> not quite
18:40:32 <Mitar> > takeWhile (not . null) . unfoldr (Just . splitAt 2) $ [1..4]
18:40:34 <lambdabot>  [[1,2],[3,4]]
18:40:34 <Mitar> this is nice ...
18:40:35 <ddarius> > let tW p = foldr (\x xs -> if p x then x:xs else []) [] in tW (not . null) . unfoldr (Just . splitAt 2) $ [1..5]
18:40:37 <lambdabot>  [[1,2],[3,4],[5]]
18:41:13 <olsner> how can I specify what the default value of array elements, when constructing from e.g. array from a list of index/value pairs?
18:41:45 <sorear> it's the 2nd arg to array iirc
18:41:48 <sorear> @ty array
18:41:50 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
18:42:06 <sorear> huh.  I was sure it existed
18:42:10 <sorear> @ty accumArray
18:42:12 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
18:42:15 <sorear> @ty accum
18:42:16 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
18:42:27 <ddarius> So we have a foldr . unfoldr a hylomorphism
18:43:21 <sorear> @ty accumArray (const id)
18:43:22 <lambdabot> forall a i. (Ix i) => a -> (i, i) -> [(i, a)] -> Array i a
18:43:33 <sorear> there, fst arg is default
18:43:52 <olsner> woa
18:43:59 <olsner> thanks ;-)
18:45:46 <Jessehk> I'm back to bother you all again. How could I write a dealCards function from the dealCard function? http://hpaste.org/91
18:45:54 <byorgey> > accumArray (const id) 2 (1,10) [(3,6)]
18:45:55 <lambdabot>  array (1,10) [(1,2),(2,2),(3,6),(4,2),(5,2),(6,2),(7,2),(8,2),(9,2),(10,2)]
18:46:05 <ndm> have i just started a haskell-cafe flame war?
18:46:13 <Mitar> good night and thanks for all help
18:46:30 <ndm> and can anyone following tell me where the quoted line ">It's a sort of natural reaction to self-righteous jerks."
18:46:45 <ndm> comes from, its just appeared as a quote, but not a message...
18:47:03 <dolio> ndm: I don't think you started it.
18:47:28 <ddarius> ndm: You didn't start it and PR Stanley added it.
18:47:29 <ndm> dolio, well, became involved at the begining - i don't tend to start flame wars
18:47:40 <dolio> :)
18:48:35 <ndm> isn't dons the official karma policeman on the mailing list?
18:48:38 <dolio> ndm: And I think that quoted line is him speaking, accidentally leaving a '>' at the beginning of the line.
18:48:54 <byorgey> Jessehk: try something using replicate and mapM.
18:48:55 <ndm> fair enough, just wondered where it came from
18:49:04 <byorgey> @ty mapM
18:49:06 <lambdabot>     Ambiguous occurrence `mapM'
18:49:06 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
18:49:15 <ndm> @hoogle mapM
18:49:16 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:49:16 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
18:49:16 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
18:49:29 <ndm> @hoogle replicateM
18:49:30 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
18:49:30 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
18:50:25 <byorgey> Jessehk: it appears replicateM would be better =)
18:51:07 <Jessehk> byorgey: It would. Thanks for the head start. :)
18:51:24 <LoganCapaldo> > replicateM 3 (Just 3)
18:51:25 <lambdabot>  Just [3,3,3]
18:51:44 <olsner> > (minBound,maxBound)::(Char,Char)
18:51:45 <lambdabot>  ('\NUL','\1114111')
18:51:56 <byorgey> Jessehk: I think what I meant at first was replicate + sequence, which I would guess is what replicateM does.
18:52:32 <LoganCapaldo> > sequence $ replicate 3 (Just 3)
18:52:33 <lambdabot> Terminated
18:52:56 <ndm> @type sequence $ replicate 3 (Just 3)
18:52:58 <lambdabot>     Ambiguous occurrence `sequence'
18:52:58 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:53:10 <ndm> @type Prelude.sequence $ replicate 3 (Just 3)
18:53:12 <lambdabot> forall a. (Num a) => Maybe [a]
18:53:41 <ndm> i don't see why that gets terminated?
18:53:55 <ddarius> > Prelude.sequence $ replicate 3 (Just 3)
18:53:56 <lambdabot>  Just [3,3,3]
18:54:13 <olsner> > (first ord) (maxBound,maxBound)
18:54:14 <lambdabot>  Add a type signature
18:54:15 <ndm> oh, its defaulting to writer
18:54:24 <olsner> > (first ord) (maxBound,maxBound::Char)
18:54:25 <lambdabot>  (1114111,'\1114111')
18:54:33 <byorgey> > Prelude.replicateM 3 (Just 3)
18:54:33 <lambdabot>   Not in scope: `Prelude.replicateM'
18:54:38 <byorgey> > replicateM 3 (Just 3)
18:54:40 <lambdabot>  Just [3,3,3]
18:54:49 <sjanssen> ndm: no, I don't think it's defaulting to writer
18:54:57 <ddarius> @hoogle sequence
18:54:58 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
18:54:58 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
18:54:58 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
18:55:08 <olsner> how does that add up? is \ in decimal, or is the integer printed in a strange radix?
18:55:09 <sjanssen> ndm: the (Just 3) makes it the Maybe monad
18:55:19 <ddarius> \ is in decimal
18:55:42 <ndm> sjanssen, then why is it terminating?
18:55:56 <olsner> oh, weird.. I assumed hex or octal :P
18:56:05 <dolio> > showHex 1114111 ""
18:56:06 <lambdabot>  "10ffff"
18:56:13 <ndm> sjanssen, oh, and i've put up a new Catch build, which uses Cabal's Data-File support and doesn't require an environment variable - although no reason to upgrade if you've already got it going
18:56:30 <LoganCapaldo> > ord '\1114111'
18:56:30 <lambdabot>  Character constant out of range
18:56:53 <LoganCapaldo> > maxBound :: Char
18:56:54 <lambdabot>  '\1114111'
18:57:01 <LoganCapaldo> I see how it is
18:57:12 <LoganCapaldo> > ord maxBound
18:57:14 <lambdabot>  1114111
18:57:20 <byorgey> LoganCapaldo: lol
18:57:54 <byorgey> > ord '\1114110'
18:57:54 <lambdabot>  Character constant out of range
18:58:14 <hpaste>  Jessehk pasted "Cards" at http://hpaste.org/92
18:58:33 <LoganCapaldo> Does this mean there is a bug in either read and/or show for Char, or is this just an artifact of lambdabot?
18:58:47 <LoganCapaldo> Or something completely different?
18:59:09 <ndm> LoganCapaldo, works fine in GHCi
19:00:02 <LoganCapaldo> ndm: so it does. I guess it's an artifact of whatever lb does
19:00:21 <dolio> > '\131071
19:00:21 <lambdabot>  Improperly terminated character constant
19:00:24 <dolio> > '\131071'
19:00:25 <lambdabot>  '\131071'
19:00:27 <dolio> > '\131072'
19:00:27 <lambdabot>  Character constant out of range
19:00:32 <sorear> LoganCapaldo: is what a bug?
19:00:44 <TomMD> > data Foo = Foo Foo
19:00:44 <lambdabot>  Parse error
19:00:54 <sorear> TomMD: Nice try.
19:01:01 <sjanssen> > sequence [Just 3]
19:01:01 <sorear> TomMD: > wants expressions
19:01:02 <lambdabot> Terminated
19:01:12 <sjanssen> > Control.Monad.sequence [Just 3]
19:01:14 <lambdabot>  Just [3]
19:01:23 <LoganCapaldo> sorear: not being able to say '\1114111' to lambdabot
19:01:26 <dolio> 2^17 appears to be the breaking point.
19:01:41 <sjanssen> > Data.Traversable.sequence [Just 3]
19:01:42 <lambdabot>  Just [3]
19:03:24 <byorgey> Jessehk: I like your "Cards" code
19:04:13 <EvilTerran> ?pl (\f a b -> f a == f b)
19:04:13 <lambdabot> flip =<< (((.) . (==)) .)
19:04:19 <EvilTerran> ooer
19:04:27 <byorgey> yeesh
19:04:32 <Jessehk> byorgey: Thanks. Nothing practical will come out of it, but it's fun to learn.
19:04:46 <Jessehk> It's painful trying to work with monads
19:04:49 <byorgey> Jessehk: right, that's what I figured. =)
19:05:01 * EvilTerran is wishing there were fooOn fns where there are fooBy fns
19:05:19 <LoganCapaldo> Jessehk: what not data Face = Two | Three | ... | Ace deriving (Eq, Ord, Show)? then you can even do if Two < King ...
19:05:26 <byorgey> Jessehk: my current "learning project" is a brainf*** interpreter =)
19:05:36 <LoganCapaldo> It's not liek it's more typing that what you are doing now, after all
19:05:40 <EvilTerran> where sortOn f = sortBy (\x y -> f x `compare` f y)
19:05:56 <EvilTerran> etc
19:06:11 <EvilTerran> except pro'lly made more efficient with zipping and stuffs
19:06:11 <Jessehk> LoganCapaldo: Ah, good tip. Thanks
19:06:39 <dolio> @type on
19:06:41 <lambdabot> Not in scope: `on'
19:06:54 <byorgey> Jessehk: also, but less importantly, some decks distinguish between the two Jokers
19:07:06 <byorgey> Jessehk: this would be important if you ever wanted to implement Pontifex =)
19:07:25 <dolio> @let on g f x y = f x `g` f y
19:07:27 <lambdabot> Defined.
19:08:02 <tuukkah> can cabal use more than one processor for building?
19:08:07 <dolio> > sortBy (compare `on` fst) [(1,1) .. (5, 5)]
19:08:08 <lambdabot>   add an instance declaration for (Enum (a, b))
19:08:53 <EvilTerran> > map snd . groupBy ((==) `on` fst) . zip ([0..] >>= replicate 4) $ [0..]
19:08:54 <lambdabot>  Couldn't match expected type `(a, b)'
19:09:23 <EvilTerran> > map (map snd) . groupBy ((==) `on` fst) . zip ([0..] >>= replicate 4) $ [0..]
19:09:24 <lambdabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],[...
19:09:28 <dolio> EvilTerran: Anyhow, 'on' exists in 6.7, in Data.Function, I believe.
19:09:36 <Jessehk> byorgey: I don't know if I'll get as far as implementing anything. But we'll see. :)
19:10:23 <EvilTerran> dolio, it seems to me that there could be fairly significant performance gains possible if f is expensive
19:11:29 <byorgey> Jessehk: sure.  I was mostly joking. =)
19:11:44 <dolio> EvilTerran: You mean, do 'sortOn f l = map fst . sortBy (comparing `on` snd) . map (\x -> (x, f x)) $ l'?
19:12:04 <byorgey> ok, bedtime for me... goodnight all!
19:12:14 <EvilTerran> well, yes. but that's barely prettier than the original.
19:14:53 <dolio> EvilTerran: Well, you wouldn't want to write that every time, certainly.
19:16:18 <ddarius> \x -> (x,f x) == id &&& f
19:16:32 <dolio> == ap (,) f
19:17:07 <mauke> :t second
19:17:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
19:17:39 <ddarius> dolio: Both of which are 8 characters, but mine is much clearer
19:17:47 <dolio> :)
19:18:34 * dolio is defeated.
19:18:34 <matthew-_> sheesh, an entire cafe digest about /=.
19:18:36 <mauke> liftM2 (,) id f  -- clearest
19:20:31 * EvilTerran envisages a data Schwartz a b with specially crafted Eq and Ord instances to only consider the first (or the second) parameter
19:22:12 <ddarius> :t ($) . uncurry
19:22:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:22:31 <ddarius> foldPair = ($) . uncurry
19:22:33 <sorear> haha
19:22:49 <sorear> ($) . uncurry ==> id . uncurry ==> uncurry
19:22:54 <sorear> @pl ($) . uncurry
19:22:55 <lambdabot> uncurry
19:23:18 <mauke> data Schwartz1 a b = Schwartz1 a b; instance (Eq a) => Eq (Schwartz a b) where Schwartz x _ == Schwartz y _ = x == y
19:24:04 <mauke> hmm, that feels wrong
19:24:20 <ddarius> Schwartz1 v. Schwartz
19:25:23 <mauke> data Schwartz a b = Schwartz a b; instance (Eq b) => Eq (Schwartz a b) where Schwartz _ x == Schwartz _ y = x == y
19:25:49 <mauke> instance Functor (Schwartz a) where fmap f (Schwartz x y) = Schwartz x (f y)
19:28:16 <matthew-_> damn it. I got rid of one unsafeCoerce, only to find that ghc cannot construct the infinite type
19:30:27 * matthew-_ spots it's 3:30am and heads for bed
19:31:51 <Jessehk> Thanks for all the help (as always). G'night.
19:38:17 <ddarius> I nominate for quote of the day for yesterday, "...Hugs can do FFI??"
19:38:35 <dons> heh
19:38:53 <dons> is /= really an evil emoticon?
19:39:07 <dylan> note: it's bad to unbind the enter key in irssi before checking if your replacement binding works.
19:39:19 <dolio> It's a reversed variation on :/, so, I suppose.
19:39:46 <dons> :(
19:42:25 <syntaxfree> watching the SPJ video on nested data parallelism.
19:42:35 <syntaxfree> I'm awestruck.
19:42:36 <dibblego> lol @ P.S. Have some cute code:
19:42:48 <dolio> That's a quality video.
19:42:52 <dolio> He's so energetic.
19:43:01 <dons> he's a great speaker - very exciting.
19:43:04 <syntaxfree> that stuff is amazing.
19:43:10 <dons> syntaxfree: oh, what's the url again for the video?
19:43:11 <syntaxfree> I hope it gets into mainstream GHC.
19:43:16 <syntaxfree> Philip Wadler is a great speaker.
19:43:19 <dons> i meant to download it, apparently it talks about stream fusion somewhere :)
19:43:20 <syntaxfree> Oleg is kinda odd.
19:43:27 <syntaxfree> http://video.google.com/videoplay?docid=370317485066035666&q=peyton-jones
19:43:29 <sjanssen> dons: it does
19:43:30 <lambdabot> Title: Nested Data Parallelism in Haskell - Google Video, http://tinyurl.com/yt5nlj
19:43:41 <syntaxfree> I think I'll submit it again to Reddit with a catchier title.
19:43:43 <dolio> The data families stuff looked interesting, too.
19:43:47 <dons> yeah, this is very likely to make ghc, btw.
19:43:51 <dons> MS is paying for it.
19:43:54 <syntaxfree> "The name of the game is beating Fortran" -- Making Haskell faster than C
19:44:07 <dons> bytestrings use much of the same technology, btw.
19:44:14 <dons> not the distributed stuff, of course.
19:44:15 <sjanssen> dons: calls it 'clever' as opposed to that 'foldr/build system daft people in Glasgow invented'
19:44:22 <dons> heh
19:44:31 <sjanssen> dons: not exact quotes, of course, but something similar
19:44:53 <syntaxfree> emk/randomhacks.net was telling me that getting NDP stuff done on the GPU would be a real win.
19:44:57 <dons> build/foldr is a bit daft :-) since length et al are all left folds
19:45:05 <syntaxfree> @seen emk
19:45:05 <lambdabot> I haven't seen emk.
19:45:10 <dons> syntaxfree: yeah, Sean Lee, a phd student at unsw, is doing that for his degree
19:45:14 <sjanssen> foldl is a left fold, though :)
19:45:23 <dons> we've got some pretty beefy gpus here to play with ;)
19:45:25 <syntaxfree> what, the GPU stuff?
19:45:26 <sjanssen> erm, right fold
19:45:36 <dons> hehe, yeah, only with evil hacks, it is.
19:45:47 <dons> syntaxfree: yes, ndp  + gpu.
19:45:57 <dons> the gpu is like a custom ndp machine
19:46:28 <syntaxfree> UNSW = University of North South Wales?
19:46:44 <dibblego> s/North/New
19:46:45 <dons> almost.
19:47:05 <LoganCapaldo> North South Wales. Would that just be Wales?
19:47:18 <syntaxfree> that would be id Wales.
19:48:08 <dibblego> ?check id = north . south
19:48:09 <lambdabot>  Parse error
19:48:14 <mauke> North :: (* -> *) -> * -> *
19:48:53 <LoganCapaldo> That's a pretty hefty type
19:48:53 <syntaxfree> @kind (,)
19:48:58 <lambdabot> * -> * -> *
19:48:59 <dmwit> (kind North) /= (kind South) -- =(
19:49:15 <mauke> sorry, can't do infinite kinds :(
19:49:17 <syntaxfree> hmm. why is the kind of North that, then?
19:49:34 <dmwit> Because South :: * -> *
19:49:56 <LoganCapaldo> Since North and South have to be constructors (so does Wales for that matter)
19:49:59 <jfredett> wait, is * a kind of type variable? like a? or is it different?
19:50:10 <dons> the type of type variables :-)
19:50:15 <dmwit> jfredett: * is a "kind" variable.
19:50:17 <dons> values have types, yes?
19:50:18 <LoganCapaldo> So I guess North South Wales can't be Wales
19:50:19 <ddarius> the type of any types
19:50:21 <dons> and types have 'kinds'
19:50:25 <dons> so,
19:50:26 <sorear> no, * is a kind atom
19:50:29 <dons> :t 'x'
19:50:30 <jfredett> so can star be any type equation?
19:50:31 <lambdabot> Char
19:50:31 <sorear> like Int is a type atom
19:50:33 <dons> :k Char
19:50:35 <lambdabot> *
19:50:41 <sorear> * is a concrete kind
19:50:44 <dons> :t Right
19:50:46 <lambdabot> forall b a. b -> Either a b
19:50:47 <jfredett> that is, * = a -> b
19:50:50 <dons> :k Either
19:50:52 <lambdabot> * -> * -> *
19:50:56 <jfredett> or * = a -> a -> a
19:50:57 * dmwit decides that contributing to this instruction would just be contributing to jfredett's confusion
19:50:58 <jfredett> etc?
19:50:59 <sorear> * :: []
19:51:06 <sorear> (->) :: [] -> [] -> []
19:51:07 <SamB_XP> (a -> b) :: *
19:51:26 <sorear> those two constants plus application make up the univers of hinds
19:51:32 <dons> jfredett: the `kind' of a type gives you some information about the type. for example, how many type variables it can be applied to
19:51:42 <dons> just as the 'type' of a value tells you information about the value
19:51:51 <sorear> unlike the infinite coc, where kinds are just as cool as types and values
19:52:01 <jfredett> so is that like saying
19:52:18 <jfredett> wait, no, still don't get it
19:52:33 <jfredett> thats alright, I don't think my brain is ready to grok this yet
19:52:43 <jcreigh> all values have a type
19:52:44 <mauke> grokking kinds is optional
19:52:46 <jcreigh> all types have a kind
19:53:06 <jfredett> i need to grasp more type theory before getting deeper into it... :/
19:53:16 <jcreigh> no, it's not complex at all.
19:53:27 <mauke> jfredett: kinds are why something like Int Char is an error
19:53:34 <jfredett> okay
19:53:40 <jfredett> that makes sense, I guess
19:53:42 <mauke> or why Maybe is not a type
19:53:53 <mauke> well, a full type or whatever it's called
19:54:00 <dmwit> (but "Maybe a" is, also because of kinds)
19:54:07 <jfredett> whoa-- Maybe isn't a type? *passes out*
19:54:18 <syntaxfree> Int Char is an error because Int takes no type parameter. Duh.
19:54:21 <syntaxfree> @kind Maybe
19:54:22 * jfredett 's mind just kersploded
19:54:23 <lambdabot> * -> *
19:54:25 <dmwit> jfredett: Maybe is a type constructor.  So Maybe Int is a type.
19:54:25 <syntaxfree> @kind Int
19:54:27 <lambdabot> *
19:54:36 <jfredett> oh- okay
19:54:36 * LoganCapaldo lies
19:54:51 <LoganCapaldo> Maybe is a function from a type to a new type
19:55:18 <dons> jfredett: so yes, the kind tells you how you can combine types.
19:55:25 <jfredett> Whats some good text about type theory, preferably something that gets into kinds at some point?
19:55:25 <SamB_XP> also known as a type constructor
19:55:27 <dons> and says why Either Int Bool works, but why Int Char fails.
19:55:31 <LoganCapaldo> Just like f x = x + 1 isn't an Int, but f 3 is
19:55:36 <dons> jfredett: the book, TaPL is very good.
19:55:41 <dons> ?where tapl
19:55:41 <lambdabot> I know nothing about tapl.
19:55:44 <dons> bah
19:55:48 <jfredett> TaPL, okay,
19:55:49 <dons> ?google tapl
19:55:51 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
19:55:51 <lambdabot> Title: Types and Programming Languages
19:55:52 <syntaxfree> when you have a single process of taking a type to a type and a function to a function, you have a functor.
19:56:05 <dmwit> jfredett: Just about anything that is a type (not a type constructor) has kind *.
19:56:21 <dmwit> The other kinds tell you how many parameters you need to fully specify a type.
19:56:44 <dmwit> So * -> * means it takes a type (i.e. something of kind *) and creates a new type (another thing of kind *).
19:56:47 <dmwit> :k Maybe
19:56:48 <jfredett> okay- my question is, if I want to create a function which can take any kind of function, that is, a function with any type sig
19:56:49 <lambdabot> * -> *
19:56:54 <mauke> syntaxfree: hmm. then where do C++ functors come from?
19:57:00 <jfredett> and then apply it to a given list of arguments
19:57:06 <jfredett> that is, something which looks like:
19:57:34 <jfredett> (a -> b -> ...) -> [a,b,c...] -> result
19:57:45 <jfredett> i guess lets say that all the types are the same
19:57:58 <jfredett> so (a -> a -> ...) -> [a] -> a
19:58:03 <dmwit> :t foldr ($) -- something...
19:58:05 <lambdabot> forall b. b -> [b -> b] -> b
19:58:09 <jfredett> OOH!
19:58:17 * jfredett just got enlightened
19:58:21 <LoganCapaldo> mauke: namespace collision
19:58:24 <dmwit> No, wait, that doesn't work.
19:58:30 <SamB_XP> mauke: abuse of the language?
19:58:38 <jfredett> dmwit, I knew it was to good to be true
19:58:39 <SamB_XP> in Python, they call them "callables"
19:58:48 <mauke> who came up with the name "functor"?
19:58:49 <SamB_XP> a much more intuitive name if you ask me ;-)
19:59:03 <syntaxfree> mauke:  no idea. but ML functors are not the same as haskell functors though.
19:59:15 <dmwit> jfredett: I don't think that is really possible.  But have a look at the type-hackery in the Text.Printf module... =)
19:59:15 <syntaxfree> Haskell functors come from category theory.
19:59:17 <jfredett> its from catagory theory, blame Russell, I think it was his fault
19:59:28 <jfredett> dmwit, awesome
19:59:37 <syntaxfree> a Haskell functor is precisely an endofunctor on the category with types as objects and arrows as morphisms.
19:59:54 <syntaxfree> C++ functors and ML functors mean entirely different things, not related to category theory.
19:59:58 <jfredett> I'll read TaPL after I finish PRIMES in P, and then hit Text.Printf
20:00:02 <SamB_XP> an ML functor seems to be some kind of templatey thing?
20:00:07 <jfredett> plenty of good stuff to read this week. :)
20:00:15 <syntaxfree> ML functors are a way to transform modules. Damned if I know what C++ functors are.
20:00:30 <SamB_XP> syntaxfree: callable objects
20:00:35 <dolio> dmwit: Seems like a job for dependent types, or something in that direction.
20:00:46 <LoganCapaldo> C++ functors are faked closures :)
20:00:50 <cdsmith> syntaxfree: C++ functors are just objects of classes that override the function call operator.
20:00:59 <jfredett> C++ is one giant fake closure...
20:01:05 <SamB_XP> as I said, Python calls them "callables"
20:01:09 <sorear> C++ has ['f','u','n','c','t','o','r']s ?
20:01:38 <ddarius> "functor"s ?
20:01:43 <syntaxfree> hmm.
20:01:50 <syntaxfree> C++ functors sound like closures.
20:01:53 <mauke> struct Hay_im_a_functor { int operator() const { return 42; } };
20:02:02 <ddarius> syntaxfree: They mimic closures.
20:02:18 <syntaxfree> but they're not closures?
20:02:21 <cdsmith> syntaxfree: Well, they externally appear that way, but they are in no way connected to lexical scope.
20:02:47 <ddarius> syntaxfree: They could be considered explicitly constructed closures.
20:02:49 <thermoplyae> It would be nice to be able to read those slides in the Google video linked a little bit ago on parallelism
20:03:01 <syntaxfree> pretty much the only thing I know about C++ is that it uses curly braces, semicolons and the ugly for (i=0; i++; i<=10) syntax.
20:03:02 <thermoplyae> Is there a separate link available for that?
20:03:06 <LoganCapaldo> C++: I'll lift my own lambdas, dagnabit!
20:03:07 <ddarius> thermopylae: Yes, see LtU.
20:03:15 <syntaxfree> thermoplyae: try spj's website.
20:03:33 <dolio> thermoplyae: http://research.microsoft.com/~simonpj/papers/ndp/NdpSlides.pdf
20:03:44 <mauke> syntaxfree: wrong order :-)
20:04:04 <ddarius> mauke: Not necessarily... ...
20:04:08 <syntaxfree> mauke: heh.
20:04:21 <thermoplyae> Thanks a bunch
20:04:24 <syntaxfree> just today I thought I should learn J in order to write fast matrix-based algorithms.
20:04:25 <mauke> ddarius: ok, not if i is an object with overloaded operator<=
20:04:37 <syntaxfree> and then somehow link it to Haskell to have a nice DSL-y combinator library for building econometric models.,
20:04:52 <syntaxfree> I'm increasingly convinced that R's CLOS-y OO hampers more than helps.
20:05:00 <ddarius> mauke: Even if i is an int that will work fine.
20:05:18 <syntaxfree> A lot of new research in econometric models is being directly programmed into Stata, an expensive proprietary package with no easily-available Mac version.
20:05:32 <mauke> ddarius: yes, but the i<=10 part is useless
20:05:53 <syntaxfree> I suspect that part of that is because econometricians used to Fortran and RATS can't wrap their heads around R's clos-y oo.
20:05:55 <mauke> and it would be better written as i = 1; of course
20:06:07 <ddarius> mauke: The whole thing is useless; exactly.
20:06:35 <syntaxfree> now writing numerical algorithms directly into Haskell starts sounding like a possibility!
20:08:45 <SamB_XP> hmm...
20:09:15 <SamB_XP> ddarius: well, it does set i = 1;
20:09:46 <SamB_XP> and whatever statement comes after the for does get run
20:16:32 <EvilTerran> > [x, 2*x | x <- [1..]] -- is there any particular reason this shouldn't do concat [[x, 2*x] | x <- [1..]] ?
20:16:32 <lambdabot>  Parse error
20:16:45 <EvilTerran> (aside from feature creep in the language)
20:17:46 <sorear> No
20:20:45 <mauke> not flexible enough
20:21:19 <mauke> > (\x -> [(x, 2*x)]) =<< [1..]
20:21:22 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(11,22),...
20:21:32 <mauke> > (\x -> [x, 2*x]) =<< [1..]
20:21:33 <lambdabot>  [1,2,2,4,3,6,4,8,5,10,6,12,7,14,8,16,9,18,10,20,11,22,12,24,13,26,14,28,15,3...
20:23:16 <EvilTerran> i'm not sure i follow
20:24:25 <EvilTerran> i mean, it wouldn't generalise to monad comprehensions, but the language doesn't _have_ those ATM
20:25:01 <EvilTerran> and the first of your lines there would still be [(x, 2*x) | x <- [1..]]
20:26:08 <Cale> actually, it could generalise to monad comprehensions with MonadPlus
20:26:13 <mauke> yeah, braino
20:26:51 <mauke> EvilTerran: your syntax only works with a fixed number of elements. what if I want to return them from a function?
20:27:34 <EvilTerran> mauke, er, you can't.
20:27:45 <EvilTerran> but then you can't do that in a non-comprehension list, either
20:27:59 <Cale> well, the [3,12,4] syntax only works with a fixed number of elements too
20:28:01 <mauke> I can with ++
20:28:02 <EvilTerran> [1, 2, foo x, 4, 5]
20:28:15 <mauke> [1, 2] ++ foo x ++ [4, 5]
20:28:38 <syntaxfree> I don't undersyand "unboxed" and "boxed" types.
20:28:45 <EvilTerran> well, in those cases, you could just use the existing concat[...|...] form
20:28:58 <syntaxfree> s/undersyand/understand/
20:28:59 <dolio> Let's just add Ruby's splat to Haskell. :)
20:29:08 <dolio> [1, 2, *(foo x), 4, 5]
20:29:28 <mauke> perl is so much easier :)
20:29:33 * EvilTerran tries to think of a way of doing something even remotely like that with TH
20:29:39 <mauke> 1, 2, foo(x), 4, 5
20:29:45 * syntaxfree cries "MONAD COMPREHENSIONS NOW!"
20:29:56 <syntaxfree> I mean, Visual freaking Basic has monad comprehensions by now.
20:29:57 * ddarius sees a new crazy type hackery thing to make .: DWIM
20:30:11 <ddarius> syntaxfree: Haskell 1.4 had monad comprehensions
20:30:23 <syntaxfree> ddarius: I know the story.
20:30:33 <syntaxfree> Too complicated, they said.
20:30:36 <mauke> (of course, (,) is a binary infix operator in perl)
20:30:43 <syntaxfree> But now we have GADTs and STM and monad transformers.
20:31:49 <syntaxfree> so, what's with "unboxed" and "boxed" types?
20:32:11 <syntaxfree> by now I got that unboxed types are somehow rawer, and that boxedness has to do with memory representation of data.
20:32:15 <sorear> syntaxfree: unboxed types have kind #, and variables of kind # cannot be generalized
20:32:26 <sorear> syntaxfree: oh, and bindings of them are strict
20:32:42 <SamB_XP> and not allowed at the top level!
20:32:47 <syntaxfree> hmm. so it simplifies type-checking.
20:32:59 <sorear> syntaxfree: there are two subtly different properties of types
20:33:00 <syntaxfree> OTOH, the type-system flexibility depends on the boxing stuff?
20:33:10 <sorear> syntaxfree: Boxed types are represented as pointers
20:33:39 <sorear> syntaxfree: they are all the same size, and have enough dynamic type info that the GC can handle any of them anywhere
20:33:55 <sorear> syntaxfree: so with boxed types you can have polymorphism
20:33:57 <syntaxfree> while unboxed types are directly on the stack or something like that?
20:34:04 <sorear> syntaxfree: BUT, you need more memory references
20:34:07 <syntaxfree> oh, ok!
20:34:08 <SamB_XP> there are, though, some pointed but unlifted types...
20:34:11 <sorear> syntaxfree: Yeah.  Stack and registers.
20:34:16 <SamB_XP> or do I mean pointered...
20:34:19 <sorear> syntaxfree: Int# is 32 bits inline
20:34:28 <syntaxfree> so unboxed types are basically good for nasty optimization.
20:34:32 <sorear> yeah.
20:34:39 <sorear> @src Int
20:34:39 <lambdabot> data Int = I# Int#
20:34:48 <sorear> they are the only primitive types
20:34:58 <sorear> all boxed types are defined in the standard library
20:35:10 <sorear> which simplifies things a LOT
20:35:12 <syntaxfree> Oh, cool.
20:35:22 <olsner> @pl ((== x).head.fst)
20:35:22 <lambdabot> (x ==) . head . fst
20:35:27 <sorear> in yhc just about every primitive has to handle laziness
20:35:36 <sorear> in ghc, only case does
20:35:44 <syntaxfree> Interesting.
20:36:10 <sorear> (+) x y = case x of I# x# -> case y of I# y# -> case x# +# y# of xpy# -> I# xpy#
20:36:30 <syntaxfree> does Lisp have a concept of boxed/unboxed types?
20:36:36 <syntaxfree> does every GC language?
20:36:49 <SamB_XP> lisp? no. lisp compilers? yes.
20:37:09 <sorear> syntaxfree: Pretty much.  there are some interesting exceptions though
20:37:27 <cdsmith> syntaxfree: You can map the words onto all garbage collected languages, but language will differ a bit.
20:37:55 <sorear> syntaxfree: O'Caml and elisp use tag bits so that integers can be treated the same as pointers by the gc, at the cost of making arithmetic slower
20:38:49 <sorear> syntaxfree: Java has boxed types (objects; support subtyping polymorphism) and unboxed types (non-objects; always monomorphic)
20:39:01 <sorear> in Perl everything is boxed
20:39:05 <syntaxfree> oh. Of course. "boxed" is a polymorphic concept.
20:39:12 <syntaxfree> a concept-class, in a way.
20:40:28 <syntaxfree> actually it's kinda cool that Haskell can directly handle unboxed types.
20:40:40 <sorear> i
20:40:43 <syntaxfree> unboxed types + strict functions is almost like C.
20:40:50 <sorear> 've one other random idea
20:41:22 <sorear> what if we gave each unboxed type its own kind?  then just normal lack of kind poly would protect use
20:41:53 <syntaxfree> uniqueness kinding?
20:43:45 <syntaxfree> @kind Int#
20:43:48 <lambdabot> Not in scope: type constructor or class `Int#'
20:43:53 <syntaxfree> @kind I#
20:43:54 <lambdabot> Not in scope: type constructor or class `I#'
20:43:59 <sorear> @kind GHC.Prim.Int#
20:44:00 <syntaxfree> @kind Functor
20:44:02 <lambdabot> #
20:44:03 <lambdabot> Class `Functor' used as a type
20:44:18 <sorear> @kind GHC.Prim.ByteArray#  -- one other trick
20:44:20 <lambdabot> !
20:44:30 <SamB_XP> !!
20:44:33 <syntaxfree> @kind Maybe
20:44:34 <sorear> ! is strict but boxed
20:44:35 <lambdabot> * -> *
20:44:39 <SamB_XP> ah.
20:44:48 <syntaxfree> @king Maybe Int
20:44:48 <lambdabot> Maybe you meant: kind ring
20:44:57 <syntaxfree> @kind Maybe Int
20:44:59 <lambdabot> *
20:45:07 <syntaxfree> @kind foldl'
20:45:09 <lambdabot> Not in scope: type variable `foldl''
20:45:11 <syntaxfree> @kind foldl_
20:45:13 <lambdabot> Not in scope: type variable `foldl_'
20:45:16 <ddarius> @help ring
20:45:17 <lambdabot>  @ring <user>, CSE phonebook
20:45:17 <syntaxfree> duh.
20:45:20 <syntaxfree> stupid.
20:45:23 <syntaxfree> @type foldl_
20:45:25 <lambdabot> Not in scope: `foldl_'
20:45:27 <syntaxfree> @type foldl'
20:45:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:46:16 <syntaxfree> @kind ->
20:46:18 <lambdabot> parse error on input `->'
20:46:26 <cdsmith> @kind forall a b. (a -> b -> a) -> a -> [b] -> a
20:46:28 <lambdabot> *
20:46:32 <syntaxfree> shouldn't the kind of -> be the same as the kind of (,)?
20:46:42 <mauke> @kind (->)
20:46:43 <syntaxfree> @kind (->)
20:46:44 <SamB_XP> indeed not
20:46:44 <lambdabot> ?? -> ? -> *
20:46:44 <cdsmith> @kind (->)
20:46:46 <lambdabot> ?? -> ? -> *
20:46:47 <lambdabot> ?? -> ? -> *
20:46:53 <syntaxfree> what is ?? and ?
20:46:53 <SamB_XP> @kind (,)
20:46:55 <lambdabot> * -> * -> *
20:46:55 <cdsmith> :)
20:47:06 <SamB_XP> ?? includes both lifted and unlifted types
20:47:18 <syntaxfree> SamB_XP: lifted? unlifted?
20:47:22 <olsner> @hoogle (a -> a -> b) -> a -> b
20:47:23 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
20:47:31 <SamB_XP> ? includes even unboxed tuples
20:47:54 <syntaxfree>  
20:48:07 <syntaxfree> I don't understand lifted and unlifted.
20:48:09 <SamB_XP> syntaxfree: well, ? includes *!#
20:48:14 <mauke> olsner: join
20:48:18 <SamB_XP> @kind (# 1, 1 #)
20:48:20 <lambdabot> (#)
20:48:26 <olsner> :type join
20:48:33 <olsner> :t join
20:48:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:48:37 <SamB_XP> @kind (# Int, Int #)
20:48:39 <lambdabot> (#)
20:48:46 * SamB_XP wonders why the first one worked
20:48:47 <syntaxfree> what is lifted/unlifted?
20:49:00 <SamB_XP> syntaxfree: lifted types have _|_
20:49:04 <olsner> hmm... so (a -> b) is also a monad?
20:49:11 <SamB_XP> olsner: no.
20:49:16 <mauke> @instances Monad
20:49:17 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:49:17 <syntaxfree> hmm.
20:49:24 <mauke> olsner: ((->) r) is
20:49:24 <SamB_XP> ((->) r) is a monad though ;-)
20:49:30 <syntaxfree> wait, wait, wait. are unlifted types accessible in Haskell?
20:49:44 <cdsmith> syntaxfree: another way to put that: lifted types are lazy; there's actually code to run to compute them.
20:49:57 <syntaxfree> oh.
20:50:02 <syntaxfree> unlifted types are !
20:50:07 <SamB_XP> syntaxfree: standard Haskell? no. GHC? yes.
20:50:17 <SamB_XP> syntaxfree: ! and #
20:50:24 * olsner <- confused
20:50:40 <SamB_XP> @kind 1#
20:50:42 <lambdabot> parse error on input `1#'
20:50:43 <syntaxfree> this is probably machine-dependent, but how are unboxed tuples "sewn" together in the register/stack?
20:50:53 <cdsmith> olsner: confused about...
20:50:55 <syntaxfree> in a hand-wavy way?
20:50:57 <SamB_XP> syntaxfree: does it matter?
20:51:09 <SamB_XP> they survive
20:51:12 <mauke> olsner: (r ->) is a monad. (m a) corresponds to (r -> a)
20:51:15 <SamB_XP> that is the important thing!
20:51:40 <mauke> olsner: m (m a) -> m a  really means  (r -> (r -> a)) -> (r -> a)  here
20:51:46 <syntaxfree> dunno. This is my first contact ever with lower-level programming and I must say I'm fascinated.
20:51:55 <mauke> olsner: which is the same as (a -> a -> b) -> a -> b
20:52:09 <olsner> aah
20:52:32 <SamB_XP> syntaxfree: my answer for you is that I haven't got a clue how unboxed tuples are stuffed into registers and stack, and probably you shouldn't either ;-)
20:52:40 <mauke> > join (++) "zomg"
20:52:42 <lambdabot>  "zomgzomg"
20:52:43 <olsner> nice... but I still don't *really* know what's going on ;-)
20:52:53 <syntaxfree> > join (+) 2
20:52:54 <lambdabot>  4
20:52:54 <mauke> you don't need to; it just works :-)
20:52:59 <syntaxfree> @unpl join f
20:52:59 <lambdabot> (f >>= \ a -> a)
20:53:16 <syntaxfree> @unpl join f :: (a->a) -> a -> a
20:53:17 <lambdabot> (f >>= \ a -> a) :: (a -> a) -> a -> a
20:53:17 <mauke> heh, it inlined join and id
20:53:37 <syntaxfree> > join (,) [1..10]
20:53:39 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
20:53:49 <syntaxfree> > zip $ join (,) [1..10]
20:53:49 <lambdabot>  Couldn't match expected type `[a]' against inferred type `(a1, a1)'
20:53:58 <syntaxfree> > unzip $ join (,) [1..10]
20:53:59 <lambdabot>  Couldn't match expected type `[(a, b)]'
20:54:02 <syntaxfree> @type zip
20:54:04 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:54:08 <syntaxfree> @type unzip
20:54:10 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
20:54:25 <olsner> (inverse . unzip)
20:54:29 <syntaxfree> @hoogle ([a],[b]) -> [(a,b)]
20:54:30 <lambdabot> No matches, try a more general search
20:54:38 <olsner> rather without that dot, but whatever
20:55:14 <olsner> > liftM2 unzip $ join (,) [1..10]
20:55:14 <lambdabot>  Couldn't match expected type `a2 -> r'
20:55:23 <olsner> > liftM unzip $ join (,) [1..10]
20:55:23 <syntaxfree> olsner:  look at this:
20:55:24 <lambdabot>   add an instance declaration for (Num (a, b))
20:55:24 <lambdabot>     In the expression: 10
20:55:32 <syntaxfree> > join [[1,2],[3,4]]
20:55:33 <lambdabot>  [1,2,3,4]
20:55:54 <syntaxfree> :t join
20:55:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:56:06 <syntaxfree> get it? get it? ;)
20:56:23 <syntaxfree> in the reader monad, (-> ((->) a) -> ((->) a)
20:56:41 <syntaxfree> or ((a ->) ->) -> (a ->)
20:56:49 <mauke> you're missing an r there
20:56:58 <syntaxfree> true.
20:57:06 <olsner> suddenly both Perl and APL seem readable
20:57:21 <syntaxfree> in the reader monad, (-> r ((->) r  a) -> ((->) r a)
20:57:43 <syntaxfree> or ((a -> r) -> r) -> (a -> r)
20:57:54 <syntaxfree> now look at the type of (+)
20:57:57 <syntaxfree> @type (+)
20:58:06 <lambdabot> forall a. (Num a) => a -> a -> a
20:58:07 <mauke> ITYM (r -> (r -> a))
20:58:24 <syntaxfree> oh?
20:58:26 * syntaxfree ducks
20:58:35 <syntaxfree> @type join (+)
20:58:37 <lambdabot> forall a. (Num a) => a -> a
20:58:43 * syntaxfree shuts his gabber hole.
20:58:53 <syntaxfree> @type join (.)
20:58:55 <lambdabot> forall b. (b -> b) -> b -> b
20:59:03 <LoganCapaldo> Is there a quick way to export all the constructors for a type when using an export list?
20:59:21 <syntaxfree> > join (.) (+1) 2
20:59:22 <lambdabot>  4
20:59:29 <olsner> hmm... isn't that also the S or K combinator? (apply the second argument twice to the first argument)
20:59:31 <mauke> LoganCapaldo: Type(..)
20:59:39 <syntaxfree> > join (.) (++ "duh") []
20:59:40 <lambdabot>  "duhduh"
21:00:03 <olsner> @pl (\x -> f x $ g x)
21:00:04 <lambdabot> ap f g
21:00:06 <SamB_XP> @roll 2d6
21:00:07 <lambdabot> Consider it noted.
21:00:08 <syntaxfree> @type join (.) (++ " duh")
21:00:10 <lambdabot> [Char] -> [Char]
21:00:21 <syntaxfree> @type join (join (.) (++ " duh"))
21:00:23 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
21:00:23 <lambdabot>     Probable cause: `.' is applied to too many arguments
21:00:23 <SamB_XP> @dice 2d6
21:00:24 <lambdabot> 2d6 => 12
21:00:33 <syntaxfree> @type join
21:00:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:00:57 * syntaxfree drops dead.
21:00:58 <dibblego> > \forall
21:00:58 <lambdabot>  Parse error
21:00:59 <LoganCapaldo> mauke: thanks
21:01:09 <mauke> @kill
21:01:09 <lambdabot> Maybe you meant: keal kind tell
21:01:18 <syntaxfree> @protontorpedo
21:01:19 <lambdabot> is haskell able to outdo perl or python for web?
21:01:20 <dibblego> I wish there were a a lambdabot plugin for getting non-ASCII characters like \forall
21:01:46 <syntaxfree> @protontorpedo
21:01:46 <lambdabot> does huge or ghc have more stuff?
21:01:50 <syntaxfree> @protontorpedo
21:01:50 <lambdabot> here is the big one: is it mroe prctical than say python?
21:03:03 <syntaxfree> @protontorpedo
21:03:04 <lambdabot> lazy makes macro not needed?
21:04:25 <syntaxfree> @protontorpedo
21:04:26 <lambdabot> how abut vs APL
21:04:33 <moconnor> What is the common library to use for doing MD5Sums?  I can't get http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/ to compile on Ubuntu Dapper w/ GHC 6.4.1.  Lots of missing modules and even a lexical error here and there.
21:04:33 * syntaxfree killed the channel?
21:04:34 <lambdabot> Title: MD5 in Haskell
21:05:58 <LoganCapaldo> Man Haskell makes stuff _easy_
21:07:43 <araujo> @yarr!
21:07:43 <lambdabot> Arr! Me ship be the biggest brig in the port!
21:12:03 <olsner> @quote APL
21:12:03 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
21:12:09 <olsner> @quote APL
21:12:09 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
21:12:53 <ddarius> @quote factor
21:12:53 <lambdabot> skew says: We don't believe in constant factors.
21:16:10 <olsner> why is it that changing a polymorphic function from f x = g x; into f = g brings up cryptic messages about the monomorphism restriction, rather than JustWorking?
21:16:35 <ddarius> Because the monomorphism restriction only applies to value bindings.
21:16:39 <syntaxfree> because you didn't enable -fnomonorphism-restriction.
21:17:25 <sorear> Or maybe you just spelled it wrong.
21:18:17 * syntaxfree cries
21:18:23 <olsner> was just afraid of adding -f flags ;-) they all feel like they just might mean -fignore-errors -fdo-the-wrong-thing
21:18:44 <syntaxfree> they are, in a way :)
21:19:58 <dblhelix> olsner: admittedly, the monomorphism restriction is quite an unfortunate language feature
21:20:11 <sorear> -fno-monomorphism-restiction is a kind of -fno-bug-compatibility
21:20:18 <olsner> but why treat f= different from f x =? and the monomorphism restriction also applies to things like f = (\x -> ...), right?
21:20:27 <dblhelix> olsner: it was added for good reasons, though; nevertheless it is unfortunate
21:20:41 <dblhelix> olsner: that is correct
21:21:16 <dblhelix> olsner: note that it only applies to *overloaded* functions
21:21:26 <ddarius> olsner: f = ... makes f look like a CAF
21:21:39 <olsner> CAF?
21:21:49 <ddarius> Constant Applicative Form
21:22:01 <edwardk> http://haskell.galois.com/trac/haskell-prime/wiki/MonomorphismRestriction
21:22:03 <lambdabot> Title: MonomorphismRestriction - Haskell Prime - Trac, http://tinyurl.com/2cdlyh
21:22:04 <dblhelix> so, if you declare a function f = ... with type (C ...) => ... your f actually expects a 'hidden' argument, i.e., the dictionary for C
21:22:30 <ddarius> dblhelix: It applies to -all- polymorphic functions.
21:22:46 <dblhelix> still, it looks like f is a constant and evaluating it should only have a computational overhead once
21:23:37 <dblhelix> ddarius: ah your right, my bad... :-) been exposed to it for almost ten years now and still can't explain it properly... yeah, it's an unfortunate feature
21:23:57 <mutjida> @users
21:23:57 <lambdabot> Maximum users seen in #haskell: 340, currently: 297 (87.4%), active: 39 (13.1%)
21:24:02 * dblhelix is in desperate need for some coffee (remember: it's 6:22am here)
21:24:04 <ddarius> But f x = ... is clearly non-constant so the fact that it is reevaluted everytime it is used is clear.
21:24:19 <olsner> hmm.. so the thing that people are/were afraid of was that when different f's for different types is (perhaps) introduced, they wouldn't share their value or implementation?
21:24:37 <ddarius> olsner: More or less.
21:25:45 <edwardk> seven = 3 + 5
21:25:46 <edwardk> er
21:25:49 <edwardk> seven = 3 + 4 =)
21:25:52 <mutjida> hello all. i once saw an article on using ffi which had an example with a struct (i.e. how to use Storable to convert a datatype to a C struct). i am unable to find the article now, after searching an hour on google and haskell.org. anyone know where this article is?
21:25:56 <edwardk> now use seven as a float, then an int, etc.
21:26:18 <edwardk> @type 3 + 4
21:26:20 <lambdabot> forall t. (Num t) => t
21:26:26 <dblhelix> here things are worse: there's interaction with defaulting
21:26:33 <olsner> defaulting?
21:26:38 <dblhelix> @type let seven = 3 + 4 in seven
21:26:40 <lambdabot> forall t. (Num t) => t
21:27:15 <olsner> @type let seven = 3 + 4 in seven + (1:: Int)
21:27:17 <lambdabot> Int
21:27:56 <olsner> isn't that an example of something violating the monomorphism restriction?
21:28:28 <edwardk> @type let seven = 3 + 4; eight = seven + (1::Int) in seven
21:28:29 <lambdabot> Int
21:28:33 <edwardk> there =)
21:28:38 <jfredett> bah,  i need to actually _buy_ TaPL?
21:28:48 <edwardk> worth every penny
21:28:55 <dblhelix> jfredett: it's worth it
21:29:02 <jfredett> i'm sure, but I don't have any pennys to spend
21:29:07 * ddarius isn't even really keen on ATTaPL
21:29:29 <olsner> edwardk: so with no-monomorphic-restriction, that would produce (Num t) => t?
21:29:30 <Korollary> jfredett: there are a few online pdf's that cover the basics
21:29:49 <olsner> TaPL? ATTaPL?
21:30:03 <dblhelix> olsner: that last example? no, it'd still be Integer
21:30:04 <jfredett> yeh- I'll scrimp some money up and buy it
21:30:04 <dolio> Advanced Topics in ...
21:30:18 <jfredett> my birthday is coming up, I'll get someone to get it for me
21:30:19 <jfredett> :)
21:30:26 <dblhelix> olsner: Pierce's books on, well, Types and Programming Languages
21:30:36 <Korollary> jfredett: That's a very nerdy birthday wish. I grant you a +10 sword.
21:30:42 <edwardk> olsner: exactly let seven = 3 + 4; eight = seven + (1::Int) in seven :: (Num a) => a per ghci -fno-monomorphism-restriction
21:31:03 <jfredett> I got Russell's Principia Mathematica and Euclids Elements for my last birthday
21:31:07 <olsner> @type let a= 3+4;b=a+(1::Int);c=a+(1::Float) in (a,b,c)
21:31:09 <lambdabot>     Couldn't match expected type `Int' against inferred type `Float'
21:31:09 <lambdabot>     In the second argument of `(+)', namely `(1 :: Float)'
21:31:13 <jfredett> both leatherbound copys, really nice
21:31:21 <ddarius> Wow, you are a nerd.
21:31:23 <jfredett> I collect nice math books, TaPL counts
21:31:24 <jfredett> :)
21:31:37 <ddarius> I think Elements is available online no less.
21:32:24 <ddarius> But I guess if someone else is paying...
21:32:27 <jfredett> My most prized math book is a copy of Godel's proof of Incompleteness, signed by Godel himself,
21:32:47 <ddarius> Goedel was a nutcase.
21:33:03 <Korollary> Goedel became a nutcase
21:33:09 <jfredett> Godel is my hero (i'm a nutcase too)
21:33:19 <Korollary> you're not nearly nutty
21:33:20 <edwardk> tapl and attapl are both really good, i keep going back and referencing them for good counterexamples of decidability whenever i think i have a fancy schmancy solution to some high-falutin problem, pierce always lets me down easy ;)
21:33:48 <jfredett> Dad got it while he was in college, Godel gave a guest lecture in one of his classes
21:33:59 <ddarius> jfredett: I imagine you're still eating, so you aren't nearly the nutcase Goedel was.
21:34:14 <jfredett> true that, but I am still mildly insane
21:34:18 <mutjida> i finally found the page i was looking for. it is: http://haskell.org/hawiki/FfiExample. i had to go to nabble and search the haskell-cafe archives to find a link to this.
21:34:19 <lambdabot> Title: FfiExample - The Haskell Wiki
21:34:23 <ddarius> jfredett: So am I.
21:34:26 <jfredett> I can't bring myself to touch doorknobs anymore
21:34:35 <jfredett> I bring gloves nowadays
21:34:36 <ddarius> Not that crazy.
21:34:38 <Korollary> We're all normal if we define non-#haskell as abnormal
21:34:45 <jfredett> and a little bottle of sanitizer
21:35:19 <jfredett> meh, Korollary, thats what we in the Math biz call a null solution, multipling by 0, whatnaught
21:35:22 <ddarius> jfredett: Maybe you're working your way to Goedel nuttiness.
21:35:24 <jfredett> multiplying*
21:35:29 <jfredett> ddarius, I hope so
21:35:37 <jfredett> that'd be sweet, minus the not eating part
21:35:40 <Korollary> We're cheering for you
21:35:40 <SamB_XP> Korollary: so if I /part #haskell, will I be abnormal?
21:35:57 <Korollary> SamB_XP: Hotel California baby.
21:36:29 <jfredett> I have AS like Godel, so I guess i'm on my way. :)
21:38:16 <ddarius> jfredett: Just being as crazy as Goedel doesn't mean you'll produce as significant work as him.
21:38:44 <jfredett> thats okay, if I'm that crazy, I probably won't care
21:41:13 <jfredett> good lord, $40 for TaPL on half no less
21:41:29 <jfredett> I can smell it costing me an arm and a leg.. :/
21:41:43 <ddarius> And then there's ATTaPL after that.
21:42:28 <dolio> Amazon has an offer for both for $100 or so.
21:42:40 <jfredett> you know whats sad, I use ghci as a calculator now, even before I use the real one at my side... :/
21:42:52 <Korollary> it makes more sense
21:42:52 <jfredett> here's ubernerd for you
21:43:01 <jfredett> I have a holster for my TI 83
21:43:15 <jfredett> :)
21:43:23 <SamB_XP> I would just put it in my pocket
21:43:31 <ddarius> I decided not to bring back my TI-83.
21:43:34 <jfredett> see, my pockets aren't that deep
21:43:44 <SamB_XP> see, you should wear more pockety jeans
21:43:52 <jfredett> I wear slacks, usually
21:43:58 <SamB_XP> that might be the trouble
21:43:59 <dolio> Wow, ATTaPL is $30 on half.
21:44:21 <jfredett> so I made a holster for my calculator, Ipod, wallet, and cell phone
21:44:29 <jfredett> It's my Batman belt
21:44:47 <SamB_XP> batman has an ipod?
21:44:54 <SamB_XP> is that for stealth purposes?
21:45:11 <SamB_XP> (I assume he uses a black headset to avoid the white outline?)
21:45:14 <jfredett> well, okay, nerdman belt
21:45:16 <ddarius> SamB_XP: Where do you think the theme music and sound effects come from?
21:45:26 <jfredett> spiff! pow! blammo!
21:46:05 <jfredett> well, i guess 40$ is better than the 70 it is direct from MIT
21:46:42 <jfredett> 50 a peice on Amazon, meh...
21:46:46 <jfredett> i wish I had money.
21:47:10 <ddarius> Perhaps you should become a professional programmer
21:47:16 <jfredett> lol, I'm trying
21:47:18 <jfredett> i really am
21:47:21 <jfredett> but noone wants me
21:47:22 <jfredett> :(
21:47:41 <SamB_XP> I actually just bought a TI 30-IIX
21:47:47 * cdsmith wants jfredett, but just can't afford to pay him anything. :)
21:47:54 <jfredett> lol
21:48:04 * ddarius doesn't want jfredett.
21:48:15 <SamB_XP> I bought a copy of Purely Functional Data Structures to get free shipping with it
21:48:30 <cdsmith> err... I meant as a programmer.  None of those other connotations here.
21:48:39 <ddarius> Hmm, that's a book I might buy.
21:49:07 <jfredett> cdsmith, you know you want me, baby...
21:49:41 <jfredett> i mean-- wait-- what?
21:52:16 <jfredett> *awkward silence*
21:52:41 <cdsmith> quite awkward, yes.
21:52:57 * jfredett laughs
21:53:03 <cdsmith> So, how 'bout them monads?
21:53:06 <dolio> Ooo, slashdotters pontificating on how hard parallel programming is. That should be good.
21:53:15 <edwardk> heh
21:53:29 <dolio> "our brains aren't wired to think in parallel"
21:53:32 <rt> all programming is hard.
21:53:33 <jfredett> ... parallel programming is hard?
21:53:39 <ddarius> *blink* *blink* ?
21:53:52 <rt> if it wasn't, ordinary chimps could do it.
21:54:09 <jfredett> omg, our brains are totally wired for that, I play Doom! Thats all parallel processing
21:54:50 <jfredett> watch for enemys, complete objective, monitor health and ammo, totally parallel problem... I hate dumb slashdotters.
21:54:53 <ddarius> We live in a massively parallel universe.
21:55:04 <sorear> people have been programming people for many thousands of years
21:55:10 <rt> uh, programming is a little different than playing doom.
21:55:46 <jfredett> I know, rt, but the concepts are the same, we need to monitor things with program threads, and react to them on a higher level in some way
21:55:59 <ddarius> rt: Clearly you are using the wrong programming language.
21:55:59 <rt> i don't agree.
21:56:19 <jfredett> playing doom is just learning how to thread your brain- prioritizing tasks, etc.
21:56:33 <rt> ddarius: just what programming language do you think makes parallel programming easier/simpler/tractable?
21:56:44 <ddarius> rt: That's not what I was referring to.
21:57:00 <rt> ah.
21:57:09 <jfredett> rt, I'd say Erlang, honestly, its what it was designed for, but thats with no knowledge of Haskell's capabilitys
21:57:27 <rt> erlang might indeed be the most credible answer that I know of.
21:57:44 <jfredett> anything purely functional tends to thread easy, but thats a colloquialism, I've never tested it
21:57:51 <jfredett> i've used Scheme's threading abilitys
21:57:58 <dolio> Oz is supposed to be good, too, but that's even less well known than Erlang.
21:58:23 <edwardk> erlang is probably the best language for parallel programming right now, sad as that is
21:58:25 <jfredett> the syntax was obtuse, but the concepts were easy, and the actual hard work was almost trivialized
21:58:27 <ddarius> jfredett: The real issue is not having too much "parallelism" in pure functional code.
21:58:40 <sorear> i suspect vhdl is a very good parallel programming language
21:58:51 <cdsmith> I think parallel (especially distributed) programming is hard.  I doubt that any language will completely solve that problem.  We don't even know much about the theoretical characteristics of efficiently paralelizable algorithms.  Of course, languages can help, but the problem will remain hard.
21:59:00 <jfredett> ddarius, exactly, there comes a point at which something is so easy, you do it just because you can
21:59:05 <jfredett> and not because you should
21:59:33 <rt> most people who think parallel processing is easy work on toy problems with toy requirements.
21:59:34 <sorear> shared memory is artificial and a joke ...
21:59:51 <rt> people say things like "raytracing is inherently parallel", which is true, but useless.
22:00:29 <jfredett> cdsmith, and rest of channel, I think the real issue is that we blur the line between designing a parallel answer to a problem, and implementing said answer-- the former is difficult, but only because formulating any answer to any problem is typically nontrivial
22:00:39 <sorear> how about sudoku solvers?  those seem to be of immense practical utility
22:00:46 <jfredett> the latter is relatively straightforward, if the specification is good
22:00:46 <jcreigh> heh
22:00:58 <SamB_XP> sorear: how so?
22:01:03 <jfredett> and Raytracing is totally useful. if only because it's pretty.
22:01:14 <rt> given that even brute forcing sudoku solutions can be done in just a few seconds, it hardly is worth parallelizing.
22:01:16 <cdsmith> jfredett: okay, you're probably right, for some values of "design" and "implementation"
22:01:21 <ddarius> Raytracing has several practical aspects.
22:01:23 <mrsolo> you going to go against amdahl's law eventually
22:01:32 <jfredett> I, however, do use Pov ray to teach my math students (I tutor.)
22:01:40 * rt notes that his nick "rt" stands for "raytracer".
22:01:46 <SamB_XP> jfredett: cool
22:01:50 <jfredett> it makes analytical geometry sooo much easier to teach
22:02:04 <SamB_XP> I figured out what sin and cos were for from playing with povray
22:02:10 <jfredett> and the kids I help learn a neat tool at the same time
22:02:36 <jfredett> a couple of the students I tutored were art enthusiasts, and I showed them the whole wide world of computer art
22:02:47 <jfredett> they were very impressed, as I remember.
22:03:30 <kilimanjaro> The algorithms used in raytracing are useful, at least
22:03:31 <cdsmith> hi smithzv :)
22:03:32 <jfredett> mrsolo, enlighten me, whats amdahls law? I've never heard of it?
22:03:48 <smithzv> Hey, man
22:03:52 <rt> raytracing is beguiling because they are easy to write.  But to write really decent ones is incredibly challenging.
22:03:56 <kilimanjaro> All the computational geometry stuff used to speed up raytacers is also used to solve optimization problems in the "real world"
22:04:00 <smithzv> Sorry I had to cut you off earlier.
22:04:04 <mrsolo> jfredett: http://www.phy.duke.edu/resources/computing/brahma/brahma_old/als/als/node3.html
22:04:06 <lambdabot> Title: Amdahl's Law & Parallel Speedup, http://tinyurl.com/2cnckt
22:04:15 <cdsmith> smithzv: no problem.
22:04:20 <jfredett> kilimanjaro, absolutely, you can learn about all sorts of useful things from writing a good raytracer, including parallel programming
22:05:10 <jfredett> bah, stupid prime sum thing, my seive is too slow.
22:05:17 <rt> you can even make bad images like this one: http://brainwagon.org/images/x29.jpg
22:05:41 <rt> I think I generated this image on a vax11/750 back in 1985 or so.
22:05:58 <cdsmith> jfredett: In any case, my point was just that there are certainly hard problems in parallelism.  Perhaps they can be solved once and shared, but they are there.
22:06:08 <mrsolo> or http://en.wikipedia.org/wiki/Amdahl's_law
22:06:09 <lambdabot> Title: Amdahl's law - Wikipedia, the free encyclopedia
22:06:16 <cdsmith> jfredett: actually, spj seems to be looking a lot at solutions that "compose" well, which is cool.
22:06:17 <jfredett> cdsmith, i agree
22:06:46 <hpaste>  olsner pasted "String labeler DFA" at http://hpaste.org/93
22:06:47 <cdsmith> (especially cool because we get the results in Haskell)
22:10:48 <ddarius> kilimanjaro: Raytracing its self is a useful thing.
22:11:06 <kilimanjaro> Why?
22:11:11 <kilimanjaro> For vision or something?
22:11:20 <kilimanjaro> (err, computer vision)
22:11:28 <rt> it pays my salary.
22:11:32 <rt> i find that useful.
22:11:37 <jfredett> because it advances human creativity, and creativity solves hard problems.
22:11:52 <ddarius> Even ignoring the multi-billion dollar industry based on pretty pictures, there are industrial uses such as building design.
22:11:54 <kilimanjaro> rt, do you work at pixar or something?
22:12:03 <rt> as a matter of fact, I do.
22:12:07 <jfredett> and if so, can you get me a job?
22:12:15 * jfredett looks eager
22:12:26 <rt> in the years i've worked at pixar, i've never managed to collect a hiring bonus.
22:12:30 <kilimanjaro> I was under the impression that most of the stuff done was scanline and raytracing was only used for a small number of frames where reflections deemed it necessary
22:12:39 <kilimanjaro> but I could be wrong, I certainly dont work there
22:12:58 <rt> cars was the first film to make extensive use of raytracing.   almost every frame had some raytracing in it.  Often a lot.
22:13:04 <rt> prman is a hybrid scanline/raytracer now.
22:13:05 <kilimanjaro> Ahh
22:13:06 <jfredett> I seem to remember some article about how raytracing was being used more and more.
22:13:23 <mrsolo> why wasn't it used it the first place?
22:13:29 <kilimanjaro> mrsolo, performance
22:13:34 <rt> because it is slow.
22:13:36 <jfredett> its getting easier to use because of faster raytracing algorithms, faster computers, etc.
22:13:41 <rt> and harder to control.
22:14:29 <mrsolo> ah
22:14:33 <rt> unfortunately, there are limits to how many cpus you can put in a building.
22:14:45 <rt> (air conditioning and power requirements and such...)
22:14:56 <jfredett> rt, truer words have not been spoke.
22:15:20 <jfredett> alas, i can only fit 30 computers in my room at home... I -- need-- more-- power!
22:15:23 <kilimanjaro> rt, do they ever use GPU or other specialized hardware for anything?
22:15:24 <rt> it's not a question of $$$.  We'd spend 10x as much on computing hardware if we ould.
22:15:31 <ddarius> rt: There -are- limits, but there are completely other directions to go that can make those limits rather large...
22:15:42 <rt> kil: not in our renderfarm.  Some of our interactive tools use gpu stuff.
22:15:44 <jfredett> i wonder, are there any raytracers in Haskell
22:15:53 <ddarius> jfredett: Several
22:15:57 <jfredett> that sounds like something that should be a rite of passage.
22:16:07 <edwardk> sounds like you need to spend 10x as much on buildings then first ;)
22:16:10 <rt> they aren't very interesting.
22:16:37 <jfredett> Level 14 Haskell guru, write a raytracer, in three lines...
22:16:40 <kilimanjaro> rt, is it because of stability/precision issues? Or is there some other reason (just haven't gotten around to it yet?) The reason I ask is because for the $$ (though maybe not for the power) it seems GPU would be the way to go
22:16:40 <olsner> @type (***)
22:16:42 <scodil> is a 300 line program too big to send to a mailing list?
22:16:42 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:16:50 <rt> most are quite primitive compared to even the toy raytracer that I wrote a couple of years ago.
22:16:54 <sorear> scodil: No.
22:17:06 <edwardk> kilimanjaro: i'd be scared of the power requirements
22:17:15 <scodil> sorear: include it in the body or attach it?
22:17:33 <kilimanjaro> edwardk, well, it's power/computation so it might not be as bad as a CPU
22:17:40 <sorear> scodil: attach it, unless it looks like prose (oleg's 1000line lhs messages)
22:17:43 <edwardk> i started doing some gpgpu work, and i could cook eggs with it if i wanted ;)
22:18:00 <rt> getting high quality rendering to run on gpus isn't trivial.  the Gelato guys at nVidia have been trying for years, and still have relatively unimpressive results.
22:18:21 <jfredett> well aren't GPU's effectively designed for Matrix Multiplication?
22:18:29 <wolverian> GPUs
22:18:31 <olsner> @type liftM2 (,)
22:18:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
22:18:45 <jfredett> that's what I heard, I'm certainly no hardware guru
22:18:53 <jfredett> GPUs, excuse me.
22:19:03 <kilimanjaro> GPU is designed for basically linear algebra in 4d
22:19:04 <rt> while jim blinn thought that (somewhat jokingly) that all computer graphics is matrix multiplies, the reality is somewhat different.
22:19:09 <jfredett> I like my apostrophes, what can I say.
22:19:19 <kilimanjaro> most of raytracing is intersection testing
22:19:27 <rt> memory bandwidth is often more important.
22:19:35 <kilimanjaro> yea I guess for the sort of stuff pixar does
22:19:49 <edwardk> jfredett: sure, but its generally hard to find enough stages in the pipeline that are that parallel and that shallow that they fit into shaders, and they are designed for 4x4 transformations unless you manipulate the contents of a texture and even then you are typically limited to 32 bits with funny behavior on ieee corner cases.
22:19:49 <rt> ray intersection testing accounts for maybe 3% of our rendering.
22:20:20 <rt> our expense is nearly all shading.
22:20:23 <kilimanjaro> rt, while I do speak from personal experience, my personal experience was as a 9th grader writing a raytracer with pretty minimal features :) so I'm naive about any production work
22:20:45 <edwardk> the problem is that GPUs suck for manipulating data structures that aren't flat array like things.
22:20:46 <jfredett> silly computers, this is why I like math...
22:20:52 <bos> rt: you work for pixar?
22:20:55 <rt> aye.
22:20:59 <jfredett> all these IEEE corner cases and such
22:21:08 <bos> are you over in emeryville?
22:21:08 <rt> so go out and buy lots of tickets for ratatouille.  :-)
22:21:14 <rt> every day.
22:21:20 <mrsolo> is it out? finally? :-)
22:21:23 <jfredett> the Integers have no corners, cases, or precision limits, ayup
22:21:28 <rt> June 29.
22:21:29 <bos> yeah, i'll get taken out back and beaten if i don't.
22:21:40 <ddarius> jfredett: On computers they do.
22:21:41 * bos is in sf
22:21:44 <edwardk> typically they don't handle NaNs/infinities nicely or gracefully degrade when you go into denormalized floats because your values are infinitesmally small, etc.
22:22:17 <dons> edwardk, right, you've got to do a flattening transformation
22:22:19 <jfredett> ahh! denormalized floats! *hides*
22:22:45 <edwardk> i've been trying to figure out tricks for compiling code for the gpu in special cases, but the number of problems with their floating point implementation is huge.
22:22:53 * jfredett hugs his set of Real's
22:23:08 <ddarius> jfredett: You'd first have to find a physical realization.
22:23:23 <jfredett> ddarius, shh, I'm crazy, remember? it's all in my noggin
22:23:53 <jfredett> I live in my own world where all the computers are implemented so that my equations work perfectly... ayup
22:24:07 <jfredett> no IEEE corners or none of that
22:24:10 <jfredett> :)
22:24:21 <edwardk> dons: yeah, i am currently doing that with a large number gpu library that a friend of mine and I are working on, to flatten things so it can do the addition and multiplication passes, etc. my point was though that their floating point implementations suck ;)
22:24:27 <jfredett> I only come out of that world when I hit a IEEE corner... then I cry.
22:24:35 * rt likes to write programs that use only increment, decrement and test against zero.
22:24:45 <kfish> in mathematicsland, proofs are made of chocolate!
22:25:02 * jfredett thinks rt is crazy, but likes kfish's chocolate idea
22:25:04 <mauke> rt: you must like brainfuck
22:25:08 <ddarius> jfredett: You can use things other than IEEE floats, but they still aren't real numbers.  You can never use real numbers in a computer.
22:25:11 <kilimanjaro> rt, have you ever tried programming with just a "Decrement and jump if not zero" operator?
22:25:14 <edwardk> dons: in fact some of the transformations are very much DPH-inspired ;)
22:25:20 <olsner> @remember <kfish> in mathematicsland, proofs are made of chocolate!
22:25:21 <lambdabot> Done.
22:25:24 * rt digs in his old pile.
22:25:24 <jfredett> ddarius, sshh! you're ruining my delusion!
22:25:47 <sieni> of course you can use real numbers in a computer
22:25:53 <sieni> 0 is a real number as is 1
22:26:04 <ddarius> sieni: Some of them, yes.
22:26:05 <rt> http://brainwagon.org/files/jhconway.txt
22:26:09 <jfredett> kfish, I'm using that as my away message now... :) excellentness.
22:26:13 <rt> (it's C, sorry to offend)
22:26:16 <SamB_XP> sieni: I prefer fake numbers, like Q!
22:26:20 <rt> I have a shorter version somewhere.
22:26:32 * jfredett hides from the pointers,
22:26:32 <kilimanjaro> eww
22:26:38 <jfredett> ahh! pointers are eevvill!
22:26:42 <SamB_XP> @quote <kfish>
22:26:42 <lambdabot> <kfish> says: in mathematicsland, proofs are made of chocolate!
22:26:56 <ddarius> Pointers make the world go round.
22:27:01 <kilimanjaro> but the point isn't about being able to use individual real numbers, it's about being able to use the real field
22:27:05 <SamB_XP> @quote kfish
22:27:05 <lambdabot> kfish says: haskell programmers don't have problems, just solutions they haven't yet learned how to understand
22:27:12 <SamB_XP> @quote kfish
22:27:13 <lambdabot> kfish says: haskell programmers don't have problems, just solutions they haven't yet learned how to understand
22:27:16 <rt> http://brainwagon.org/images/jhconway2.c
22:27:16 <SamB_XP> @quote fish
22:27:17 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
22:27:21 <SamB_XP> @quote .*fish
22:27:22 <lambdabot> No quotes match. I feel much better now.
22:27:26 <ddarius> kilimanjaro: The field is the easy part, it's the axiom of completenes.
22:28:05 <kilimanjaro> Well, right, that's pretty much the definition of the real numbers :)
22:28:25 <dolio> @quote <kfish>
22:28:25 <lambdabot> <kfish> says: in mathematicsland, proofs are made of chocolate!
22:28:35 <jfredett> yay! mathematicsland!
22:28:54 <jfredett> anywho
22:29:10 <jfredett> gnite ladies and germs, wait, are there any ladies on this channel?
22:29:20 <ddarius> Yes
22:29:29 <jfredett> Geek girls exist!!!
22:29:32 <jfredett> WHAT?!
22:29:50 <mauke> rt: http://mauke.ath.cx/stuff/asm/factor.s
22:30:03 <jfredett> I must say, I've met 3 female mathematicians in my entire life, and only a few dozen female computer programmers.
22:30:18 <kilimanjaro> Somebody showed me a pic of their friend, she got a tattoo on her arm of the fibonacci sequence implemented in... Scheme
22:30:26 <ddarius> AT&T syntax, blech
22:30:44 <jfredett> kilimanjaro, holy dogpoo batman, best idea ever
22:30:45 <SamB_XP> kilimanjaro: eww
22:30:51 <kilimanjaro> yea, exactly
22:30:54 <stepcut> one summer I work with a cute programmer girl -- and the next summer I worked with her twin sister :)
22:30:54 <ddarius> In Scheme...
22:31:02 * jfredett calls his local tatoo parlor
22:31:03 <kilimanjaro> jfredett, you just need to lower your standards. Pretend that the geeks with long hair are female
22:31:10 <SamB_XP> stepcut: she didn't happen to also be a programmer?
22:31:32 <SamB_XP> jfredett: save money for books
22:31:41 <jfredett> Geeky 3-way... interesting.
22:31:55 <scodil> can someone take a look at this and see if they can tell why readArray is faster than unsafeRead?
22:31:57 <hpaste>  scodil pasted "readArray is faster than unsafeRead" at http://hpaste.org/94
22:32:02 <jfredett> SamB_XP, I can't save money if I don't make any, I'm poor and unemployed.
22:32:04 <jfredett> :(
22:32:17 <dons> scodil: what does the core turn into? that's the true way to fid out.
22:32:18 <SamB_XP> I mean, no wasting it on tatoos
22:32:27 <SamB_XP> 'specially ugly scheme tatoos
22:32:34 <SamB_XP> with lots of silly parenthesis
22:32:35 <scodil> dons: I don't know... how would I find that out?
22:32:39 <jfredett> SamB_XP, I wouldn't, I'm afraid of needles, and I like scheme, its handy
22:32:43 <dons> -O2 -ddump-simpl
22:32:47 <dons> and compare the output for each program
22:33:03 <jfredett> when your syntax is the same as your data, the possibilitys are endless
22:33:05 <ddarius> jfredett: It is, but fibs in it is not particularly elegant.
22:33:06 <dons> scodil: it might be to do with the indexing.
22:33:06 <kilimanjaro> jfredett, a three way? Isn't that the TCP handshake?
22:33:08 * rt has a certain fondness for scheme.
22:33:16 <scodil> that paste got truncated before the main, but the two relevant functions are there
22:33:24 <rt> it's probably irrational, but...
22:33:27 <kilimanjaro> rt, so do I, but she used COND instead of IF for no reason
22:33:31 <ddarius> I don't find that aspect of Lisp languages at all compelling.
22:33:46 <jfredett> ddarius, it depends on whose writing it, most people hack scheme, but the real guru's actually take the time to write it cleanly.
22:33:47 <rt> if i was gonna get a scheme tatoo, i'd probably use cond instead of if too.
22:33:57 <scodil> dons: right but unsafeRead is much faster in the matrixMult functions, and slightly slower in the gaussElim functions... ?
22:34:02 <jfredett> i've seen some pretty nifty stuff in scheme
22:34:11 <rt> most people write crap in whatever language they use.
22:34:12 <kilimanjaro> Scheme is easy to learn, easy to use, and very powerful
22:34:13 <SamB_XP> if I was going to write it in Haskell, I'd use cond instead of if, too
22:34:21 <ddarius> jfredett: As have I, but no implementation of fibs is going to look all -that- elegant.
22:34:22 <SamB_XP> actually I'd use patterns
22:34:26 <ddarius> (in Scheme)
22:34:28 <SamB_XP> but that isn't the point ;-P
22:34:28 <sieni> scheme is nice until you start getting "why does this program say 'cadar: expects argument of type <cadarable value>; given 7' and exit" complaints from customers
22:34:43 <jfredett> ddarius, my favorite was a function that self optimized...
22:34:44 <kilimanjaro> I just suck at haskell, I think I have a natural predisposition towards Scheme
22:34:46 <rt> customers?  customers don't write programs.
22:34:50 <dons> scodil: compile both versions with -ddump-simpl. pipe the results to a file, then vimdiff them. then we'll know what's what.
22:35:08 <sieni> rt: customers use programs
22:35:21 <jfredett> kilimanjaro, give it time, haskell's learning curve is a bitch, but it's worth getting into. took me a year to get passed the, "what the frak, type sigs?"
22:35:23 <jfredett> stage
22:35:40 <rt> So, why did you send a poorly typed program to customers?  :-)
22:35:46 <ddarius> And they expect their cdrs to have cars gosh darn it!
22:35:57 <SamB_XP> rt: bad typechecker
22:36:10 <kilimanjaro> jfredett, true. I just don't actually do a whole lot of programming
22:36:21 <kilimanjaro> Haskell has way more stuff to remember
22:36:22 <rt> the problem with scheme is that it relies on humans to be type checkers.  a very dubious proposition.
22:36:38 <SamB_XP> rt: yeah.
22:36:52 <SamB_XP> especially with that untyped syntax!
22:36:53 <ddarius> kilimanjaro: Not really.  Not stuff you -have- to remember.
22:37:00 <rt> i find it hard to take any language which delays type shcecking to runtime very seriously.
22:37:14 <kilimanjaro> ddarius, well, right. But to be a productive "casual" programmer is difficult, at least for me
22:37:17 <dibblego> Haskell, of all programming languages, has the *least* to rememvber
22:37:24 <jfredett> kilimanjaro, I hear yah.
22:37:30 <ddarius> Especially when people think of "lists" as a one data structure fits all tool.
22:37:59 <rt> when all you have is a hammer, everything looks like a nail.
22:38:15 <ddarius> They aren't limited to hammers...
22:38:25 <SamB_XP> Ever played Lists and Lists? it is "An Interactive REPL" or something...
22:38:26 <jfredett> rt, see, sometimes I like scheme exactly for the fact that I'm the type checker
22:38:43 <jfredett> theres nothing to fight with when I want to do something very wrong to scheme
22:38:53 <ddarius> jfredett: And you are both inconsistent and unsound
22:38:54 <bos> i wish haskell's string manipulation wasn't so impoverished.
22:39:00 <ddarius> bos: ?
22:39:06 <rt> doing things which are wrong is usually wrong, even when you think it is right.
22:39:15 <SamB_XP> bos: than enrichen it
22:39:32 <fuzan__> bos: how is it impoverished?
22:39:43 <bos> it would be nice if there were standard functions to do common things like strip whitespace off the end of a string, so i don't have to roll my own all the time.
22:39:52 <dibblego> I know a Lisp user who finds it difficult to comprehend that I am never compelled to insert unsafe print statements into my functions
22:40:02 <rt> it's embarrassing to the computer scientist in me, but I still write most useful programs in either C or Python.
22:40:07 <bos> granted, reverse . dropWhile isSpace . reverse isn't very long, but it's much longer than rstrip.
22:40:26 <fuzan__> > (unwords.words) "lol whitespace   "
22:40:35 <lambdabot>  "lol whitespace"
22:40:48 <bos> fuzan__: that mucks with all the internal whitespace.
22:40:50 <brad_> are data declarations not allowed in ghci?
22:40:53 <fuzan> true
22:40:54 <fuzan> :)
22:40:57 <ddarius> You could shake the regex hammer at it.
22:41:01 <ddarius> brad_: No they are not.
22:41:05 <ddarius> Not at the REPL.
22:41:10 <brad_> thanks ddarius!
22:41:14 <scodil> dons: ok what am I looking for in this -ddump-simple output? I can't really read this stuff
22:41:24 <jfredett> that annoys me too, I want data decl's in my REPL.
22:41:25 <brad_> just making sure i wasn't doing something wrong
22:41:32 <jfredett> but meh- c'est la vie
22:41:33 <SamB_XP> bos: so rstrip = reverse . dropWhile isSpace . reverse
22:41:34 <kilimanjaro> rt, my motto is that good work can be done in pretty much any language
22:41:36 <sorear> scodil: it's just a simple functional language
22:41:44 <jfredett> gnight folks.
22:41:51 <SamB_XP> brad_: well, you were ;-)
22:41:56 <kfish> night jfredett
22:41:57 <kilimanjaro> Some are more convenient though, and probably the most significant factor is programmer experience
22:42:03 <brad_> true enough SamB_XP
22:42:07 <SamB_XP> brad_: you are supposed to put them in a file ;-)
22:42:15 <rt> i haven't yet really figured out the programming project that will make me really learn haskell.
22:42:16 * mrsolo shrugs
22:42:22 <kilimanjaro> rt, you could write a...
22:42:23 <sorear> scodil: you want to look at your function and try to understand the control flow ... look for calls to library functions ... in a case like yours diff might help
22:42:24 <brad_> yes SamB_XP, i'm getting there!
22:42:25 <bos> SamB_XP: well spotted, that man. and my point was that it would be nice to have that in, say, Data.String or summat.
22:42:31 <mrsolo> people have different natural inclination to certain programming language
22:42:41 <mrsolo> people do think differently
22:42:49 <mrsolo> but it the end.. they are more or less the same
22:42:49 <SamB_XP> bos: libraries@ for all your complaining about libraries needs!
22:43:00 <bos> SamB_XP: heh
22:43:12 <brad_> mrsolo - lets make an exception for php
22:43:13 <mauke> is there a good regex library for haskell?
22:43:19 <ddarius> Um, you may also want to check what is out there to; beyond the standard libraries.
22:43:23 <rt> hmmm.  when is the ifcp programming contest coming up?
22:43:24 <dons> scodil: looking for the functions you know are causing trouble. then compare their fast and slow implementations
22:43:25 <ddarius> mauke: Yes.
22:43:39 * rt keeps wanting to do it for real, but hasn't succumbed yet.
22:43:47 <rt> I did have fun working on last years problem.
22:43:56 <dblhelix> rt: july 20th
22:43:56 <kilimanjaro> Make sure you use haskell if you want to win
22:44:03 <brad_> thanks for the answers and wisdom folks!
22:44:05 <brad_> byr
22:44:07 <dblhelix> @google icfp programming contest
22:44:08 <brad_> bye
22:44:10 <lambdabot> http://icfpc.plt-scheme.org/
22:44:10 <lambdabot> Title: ICFP 2005 Contest
22:44:10 <ddarius> kilimanjaro: You can win with C++
22:44:11 <SamB_XP> I still don't think I have enough RAM for ./advent
22:44:19 <kilimanjaro> ddarius, I was joking :P
22:44:24 <kilimanjaro> well, being sarcastic
22:44:24 <rt> my umix machine was written in C.
22:44:29 <dblhelix> @google icfp programming contest 2007
22:44:32 <lambdabot> http://www.icfpcontest.org/
22:44:32 <lambdabot> Title: ICFP Programming Contest 2007
22:44:42 <dblhelix> that's the one :-)
22:44:46 <mauke> ddarius: which one?
22:44:48 <SamB_XP> rt: yeah, Haskell UMs were quite slow
22:44:54 <rt> it seems to be as fast or faster than all the ones that were written that didn't do JIT compilation.
22:44:57 <SamB_XP> I wonder if they still are now?
22:45:42 <SamB_XP> rt: you used the "stuff pointers into int32_t" model?
22:45:47 <sjanssen> there are a handful of non-pathetic Haskell UMs
22:45:48 <ddarius> mauke: There is one in the "standard" libraries.
22:45:59 <mauke> Text.Regex.Posix?
22:46:18 <sjanssen> hmm, where did that benchmark page go
22:46:24 <sjanssen> @where um
22:46:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
22:46:26 <dolio> http://www.cse.unsw.edu.au/~dons/um.html
22:46:26 <lambdabot> Title: Haskell UM
22:46:26 <ddarius> mauke: The whole heirarchy.
22:47:43 <rt> it'll be tough to beat last years contest for sheer cleverness.
22:48:00 <mauke> ddarius: so... is there a good regex lib in that hierarchy?
22:48:27 <SamB_XP> now, everyone remember that you need to use 2d in order to win the contest!
22:48:30 <ddarius> mauke: Which aspects are you referring to when you say "good"?
22:48:56 <ddarius> mauke: But, it should be fine.
22:49:13 <mauke> ddarius: 1) can handle strings with embedded '\0's
22:49:20 <mauke> 2) supports non-capturing groups
22:49:33 <mauke> 3) sane syntax
22:49:37 <SamB_XP> what kind of maths is 2d made of anyway...
22:49:42 * rt runs the sandmark on his macbook
22:49:55 <mauke> 4) (optional) escape syntax that doesn't clash with haskell string syntax
22:50:11 <fuzan> i really don't see why you people are talking about nerdery when starcraft 2 is approaching.
22:50:18 <fuzan> we should all be honing our skills.
22:50:28 <SamB_XP> mauke: do you want un-stringy syntax then?
22:50:30 <sieni> SamB_XP: for example math like that: http://en.wikipedia.org/wiki/Jordan_curve_theorem
22:50:30 <lambdabot> Title: Jordan curve theorem - Wikipedia, the free encyclopedia
22:50:40 <ddarius> mauke: It uses the normal regex syntax and the .Posix subheirarchy should support whatever is supported by the POSIX standard.
22:50:49 <jcreigh> approaching? Starcraft 2 and Haskell' are probably going to end up with the same release date...
22:50:58 <ddarius> jcreigh: Never ?
22:51:00 <bos> oh noes! fps has a bug!
22:51:08 <fuzan> ?
22:51:24 <dons> bos, !!?
22:51:25 <SamB_XP> sieni: that doesn't look like the right kind of 2d
22:51:36 <jcreigh> ddarius: undetermined.
22:51:37 <dons> bos, the known one to do with lazy unlines?
22:51:39 <mauke> ddarius: there is no "normal regex syntax"
22:51:51 <rt> hmmm.  2m41s on my wimpy macbook.
22:52:01 <bos> no, the behaviour of lines is wrong.
22:52:02 <SamB_XP> bedtime...
22:52:10 <mauke> ddarius: every regex engine uses a slightly incompatible syntax (and/or semantics)
22:52:22 <mauke> SamB_XP: huh?
22:52:25 <dons> bos, sorry, lines. yes, that's known.
22:52:26 <bos> it doesn't emit empty strings for sequences of newlines.
22:52:29 <dons> right.
22:52:36 <jcreigh> yeah, saying "normal regex syntax" is like saying "normal religious beliefs". There's always something different. :)
22:52:39 <SamB_XP> mauke: I should go to bed!
22:52:47 <dons> our QC test didn't generate enough consectuvie \n\n's to spot it. but we have a custom test for that now
22:52:50 <dons> just haven't written the fix yet.
22:52:56 <SamB_XP> or are you referring to my "wrong kind of 2d" comment?
22:53:12 <mwc> jcreigh: well, there are defacto standards... posix regex, perl regex
22:53:20 <bos> yeah, i've found QC to not find bugs at depth 100, but flush them out at 1000
22:53:22 <SamB_XP> I will remind you of "the language of choice for discriminating hackers"
22:53:37 <dons> bos, yes. quite so.
22:53:52 <dons> lines/char8 stuff should use a custom generator that adds more \n's
22:54:04 <mwc> I suppose we could just say that all regex languages are approximations to a platonic ideal of an ideal regex language ;)
22:54:05 <bos> i found a nice bug in my rope code that required a 48KB input string to tickle.
22:54:16 <SamB_XP> dons: extra spaces too?
22:54:31 <dons> yeah.
22:54:37 <dons> bos, oh, nice. to hit a chunk boundary?
22:54:39 <mauke> I think elisp regexes look like "\\(foo\\|\\\\\\)"
22:54:42 <bos> dons: exactly.
22:54:47 <mauke> this is an example of how not to do it
22:55:05 <dons> bos, the chunks size is configurable, see the fps test suite (and try setting it to 1 for [Char] emulation ;)
22:55:19 <jcreigh> Friends don't let friends use nested escaping.
22:55:19 <dons> also known as "boy, haskell sucks" mode :}
22:55:31 <bos> dons: in fact, it would be a nice bug to include in the chapter on ropes, and then say "and here's how QC saves us from ourselves" in the chapter on QC :-)
22:55:44 <dons> mm. yes.
22:55:51 <rt> hmm.  1m38s on my amd64 box.
22:55:52 <ddarius> mauke: Well you get your choice with a "consistent" "interface" http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base.html
22:55:57 <lambdabot> http://tinyurl.com/2almet
22:56:07 <dons> i've found since using serious QC, all bugs have been due to either a) missing properties or b) bad generators
22:56:23 <bos> the regex libraries are nice, but underdocumented.
22:56:47 <mauke> ddarius: I don't get it
22:57:39 <ddarius> mauke: You can use various backends.
22:57:55 <thorkilnaur> dons, What could c) conceivably be? I mean, could there be bugs not covered by a) or b)?
22:57:59 <mauke> ddarius: irrelevant
22:58:04 <mauke> I don't need various backends
22:58:15 <dons> hey thorkilnaur
22:58:46 <dons> thorkilnaur: i'd imagine it is possible to have bugs for a function, if the property doesn't accurately describe the function's semantics
22:59:01 <dons> thorkilnaur: say, prop_sort x = length x == length (sort x)
22:59:03 <ddarius> mauke: The point is that the backends likely implement different syntax/semantics, so with any luck -one- of them will be suitable.
22:59:07 <dons> is a prop for sort, but an incorrect one.
22:59:18 <dons> but maybe there is no c)
22:59:47 <ddarius> dons: It's not incorrect, it's incomplete.
23:00:15 <bos> posix and perl regexps have different syntax and semantics, for example, and posix regexps can be a whole lot faster in many cases as a result.
23:00:18 <dons> yeah. so a correct QC property for a function does cover it. a correct unit test doesn't.
23:00:21 <thorkilnaur> dons, Hi. But wouldn't you agree that this would be a case of a) missing properties?
23:00:27 <dons> thorkilnaur: yep.
23:00:27 <mauke> ddarius: I wouldn't count on it
23:00:40 <dons> all bugs are missing properties, or bad generators :-)
23:00:46 <dons> the second are the worse kind
23:01:33 <ddarius> mauke: Perhaps not, but it is certainly more likely than the alternative and it can be mixed with others, e.g. if I remember correctly, Parsec should have a combinator based version if you don't like regex strings.
23:02:03 <bos> speaking of QC, you know that chris kulewicz found bugs in some widely used C regexp libraries when he wrote haskell interfaces to them, right?
23:02:10 <bos> via use of QC.
23:02:28 <bos> er, kulewicz.
23:02:33 <bos> er, ku*k*lewicz.
23:02:36 <bos> damn keyboard.
23:03:06 * ddarius needs to sleep.
23:03:17 <SamB_XP> ah, yes, me too
23:03:18 <mauke> I'm browsing http://darcs.haskell.org/packages/regex-parsec/
23:03:20 <lambdabot> Title: Index of /packages/regex-parsec
23:04:40 <mauke> ... and parsec is out, too
23:05:17 <mauke> what's so hard about pattern matching that everyone gets at least one thing wrong?
23:05:49 <bos> writing a good, fast pattern matcher is a lot of work?
23:05:56 <bos> software has bugs?
23:06:04 <nburlett> have you guys seen "elastic tabstops"? http://nickgravgaard.com/elastictabstops/index.html?source=rss
23:06:07 <lambdabot> Title: Elastic tabstops - the solution to the tabs-versus-spaces issue
23:06:32 <mauke> it doesn't have to be fast, just easy to use and more or less sane
23:06:45 <nburlett> I want this for haskell code :->
23:10:51 <dolio> I don't see why it wouldn't work in Haskell, as long as you use tabs liberally enough.
23:11:33 <dolio> The gedit patch lets you automatically convert to spaces on save, so you could still compile it without changes.
23:12:07 <nburlett> well, mostly I just want it for writing haskell code
23:12:12 <nburlett> and I want it in gvim ;->
23:12:15 <nburlett> and TextMate
23:12:20 <dolio> Heh.
23:13:41 <nburlett> most of the haskell code I see has really nice formatting
23:13:49 <nburlett> way better than I end up doing
23:13:50 <nburlett> I'm too lazy
23:14:06 <dolio> gvim has passable indenting for haskell.
23:14:34 <dolio> If you get one of the .vim files posted on one of the haskell mailing lists, at least.
23:14:42 <nburlett> sure
23:15:01 <nburlett> but it's not the beginning of line formatting I'm concerned with here
23:15:35 <dolio> Commenting is probably less fun.
23:16:07 <nburlett> and inside of pattern matching
23:16:13 <dolio> I suppose I do spend time occasionally aligning argument lists, which elastic tabs would be handy for.
23:16:27 <nburlett> exactly
23:34:27 <dons> a release candidate for xmonad is out, http://www.haskell.org/pipermail/xmonad/2007-May/000415.html
23:34:28 <lambdabot> Title: [Xmonad] xmonad 0.2 release candidate 2
23:34:36 <dons> if you want to try out a haskell window manager before the release
23:36:56 <ivanm> dons: does it support floating windows/dialogs yet?
23:37:47 <dons> transient windows are handled. it doesn't do unhandled floating , no. its a tiling wm. most applications (all?) seem to be usable without floating though.
23:38:16 <dons> so, no floating, but i'm not sure its needed anyway.
23:38:20 <notsmack> dons: have you tried cgoban?  i couldn't get it usable in xmonad the other day...
23:38:48 <dons> is that a bug report? :-)
23:38:56 <dons> let's see...
23:39:25 <sjanssen> notsmack: 'usable'?
23:39:37 <notsmack> sjanssen: couldn't figure out a way to start a game
23:40:02 <notsmack> sjanssen: couldn't see or select an ok button... i'll try again in a few
23:40:12 <dons> sounds odd.
23:40:17 <ivanm> dons: well, I was trying to use it (0.1, not the RC) over the last few days
23:40:35 <ivanm> and every time firefox, etc would pop up a dialog, it'd take up the whol main frame
23:40:47 <ivanm> which, if I was working in full-screen mode, meant the whole screen
23:40:49 <dons> ivanm: quite so. unless you're in a tiling mode. try the RC.
23:40:52 <dons> yep.
23:40:58 <dons> that's the expected behaviour
23:41:04 <ivanm> there's a tiling mode for firefox?
23:41:54 * ivanm hasn't been keeping track with xmonad lately
23:42:03 <ivanm> I should probably subscribe to the mailing list...
23:42:12 <ivanm> its not like I don't get enough emails as it is :p
23:42:29 <sjanssen> you can use gmane, if that's more convenient
23:42:45 <araujo> nice, a xmonad release candidate
23:42:54 <dons> cgoban doesn't seem to resize properly.
23:43:05 <notsmack> dons: right
23:43:14 <notsmack> i'm sure it's their bug, just thought i'd mention it
23:43:36 <dons> its their bug. they're making some assumption about the size of the window, i think
23:43:38 <ivanm> sjanssen: that would require me remembering to read gmane :p
23:43:54 <dons> its a rather old app, i guess its not terribly wm compliant. :/
23:45:09 <lokadin> how do I get haskell chat bot like from the tutorial to stay dedicated to a channel?
23:45:30 <lokadin> so that when it goes offline -- ip change -- it can reconnect
23:45:55 <dons> is that a haskell question? or a lambdabot question? or a networking question?
23:46:09 <dibblego> lokadin, have you been using @join ?
23:46:10 <dons> i'd imagine the kernel handles that, and you just reconnect? sit in a loop.
23:46:18 <lokadin> well it's a haskell question relating to haskell irc bot tutorial
23:46:18 <dibblego> @join #foo
23:46:18 <lambdabot> Not enough privileges
23:46:30 <dons> lokadin: ok. so perhaps sit in a loop, sending and receiving pings.
23:46:39 <dons> should a ping timeout, have the timeout thread trigger a reconnect
23:47:05 <lokadin> hmmm I was pretty sure that's what I did
23:47:12 <lokadin> i'll go check thank
23:47:13 <lokadin> s
23:48:14 <lokadin> is there any way of testing it?
23:48:27 <ivanm> crash your computer? ;-)
23:48:27 <lokadin> short of reconnecting to the internet
23:49:39 <lokadin> oh well
23:49:49 <lokadin> i'll figure something out
23:54:15 <dons> argh. don't let a cat loose on a laptop with a tiling wm running keyboard madness!
23:55:29 <roconnor> @quote dons argh. don't let a cat loose on a laptop with a tiling wm running keyboard madness!
23:55:29 <lambdabot> No quotes match. I've seen penguins that can type better than that.
23:55:50 <dons>    @remember ;)
23:56:04 <roconnor> @remember dons argh. don't let a cat loose on a laptop with a tiling wm running keyboard madness!
23:56:05 <lambdabot> Done.
23:57:20 <roconnor> @quote cat
23:57:20 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
23:57:25 <roconnor> @quote cat
23:57:25 <lambdabot> skew says: [on the subject of strictness] there is a sequet incatation.
23:57:35 <roconnor> @quote cat
23:57:35 <lambdabot> dons says: argh. don't let a cat loose on a laptop with a tiling wm running keyboard madness!
23:57:38 <roconnor> :)
23:58:19 <dons> ?quote a.cat
23:58:19 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
23:58:25 <dons> heh
