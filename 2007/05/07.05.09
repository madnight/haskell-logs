00:28:50 * osfameron posts notes on chapter 2 of SOE at http://osfameron.vox.com ('scuse pimping... but comments welcome, even if just "Oh dear, what a dull post")
00:31:49 <integral> osfameron: :t Shape doesn't work since "Shape" is a module name and a type, and :t looks for the type of expressions.  :kind tells you the kind of types
00:32:47 <osfameron> integral: I guess that my learner's intuition was that Circle isa Shape, so :t Circle and :t Shape would both work
00:33:13 <integral> Wrong sort of "is-a" :-)   And vox has terrible formatting for so many headings/subheadings
00:33:17 <osfameron> I'm hoping to look back on these notes when I've learnt the language and laugh gently at my naivete' :-)
00:33:34 <osfameron> is that a general thing with vox or is it my formatting?
00:33:52 <osfameron> I pasted the HTML markup I'd made with pod2html and let vox translate it, I could probably process it differently
00:34:54 <integral> Probably vox, it seems to have dreadful stylesheets
00:35:32 <osfameron> I noticed it formats my headings to get underlined on hover, as if they were hyperlinks, which is a bit odd
00:45:51 <goltrpoat> osfameron:  Shape is a type constructor.  Circle and Square are data constructors.  the latter two work as functions:  Circle :: Float -> Shape.  the former doesn't, it works as a type:  Circle :: Float -> *Shape*
00:49:02 <osfameron> goltrpoat: ok
00:49:43 <goltrpoat> cos 90 is 0 :)  sin 90 though is 1:
00:49:45 <goltrpoat> > sin (pi/2)
00:49:47 <lambdabot>  1.0
00:50:29 <osfameron> goltrpoat: yeah, that was about as much trig as I remembered.  Then I realised I didn't remember what to do with it ;-)
00:50:59 <goltrpoat> i think most people agree that degrees are a silly convention, so most things default to radians
00:51:05 <quicksilver> osfameron: it's a reasonable intuition that a typeclass is 'something like a type'
00:51:28 <osfameron> like a type.. only classier!
00:51:31 <quicksilver> osfameron: but maybe the real confusion comes from the convention that you overload a type and its constructor?
00:51:45 <quicksilver> osfameron: so Foo is a type, but Foo is *also* a function (because its a constructor)
00:52:04 <osfameron> yes, I may not be making that distinction very clearly yet
00:52:26 <quicksilver> right
00:52:29 <quicksilver> yes, that is the confusion :)
00:52:44 <quicksilver> with data Shape = Circle | Square
00:52:46 <osfameron> of course, with a nullary constructor, Nothing creates a Nothing...
00:52:53 <quicksilver> Circle and square aren't actually types
00:52:57 <quicksilver> although 'logically' they are 'subtypes'
00:53:07 <quicksilver> in the haskell type system, you can't give a name to 'part of a type'
00:53:28 <quicksilver> Circle and Square are 'merely' constructors, and :t tells you the type of the function associated with the constructor
00:53:35 <goltrpoat> "I think that we
00:53:35 <goltrpoat> can tell that it's convex if all the vertices turn in the same direction
00:53:36 <goltrpoat> (clockwise or anticlockwise)"
00:53:40 <goltrpoat> good intuition, but no
00:53:51 <goltrpoat> (imagine a star-shaped polygon)
00:53:58 <DRMacIver> I still haven't done enough Haskell, so I'm constantly amused by little things like the type of numeric literals.
00:54:09 <DRMacIver> (Amused in a good way)
00:54:15 <osfameron> goltrpoat: ah!  but that's self crossing, which I'm not worrying about yet :-)
00:54:15 <quicksilver> goltrpoat means a star drawn so that it crosses over itself
00:54:22 <quicksilver> like the conventional way to draw a pentagram :)
00:54:26 <goltrpoat> yeah.
00:54:41 <quicksilver> not a star drawn by turning back and forth :) which would of course obey the rule
00:55:17 <quicksilver> osfameron: it's common (and convenient) to overload the type, the constructor, and the construction function, giving them all th e same name
00:55:23 <osfameron> one of the later exercises is to think about self-crossing polygons.  I thought about it, got confused, gave up.
00:55:27 <quicksilver> in fact, haskell forces you to overload the last two things
00:55:31 <quicksilver> (ML doesn't)
00:55:48 <quicksilver> I believe this is a good thing, but it can be confusing if you are a very precise thinker
00:56:25 <osfameron> ah... see, I've already forgotten what the distinction between the constructor and the construction function was... :-(
00:56:39 <osfameron> I think I must be the other sort of thinker
00:57:10 <quicksilver> logically a constructor is something you can match against
00:57:25 <osfameron> why is it called a "constructor" in that case?
00:57:26 <quicksilver> in "f (x:xs) = xs", the : is a constructor
00:57:33 <osfameron> it's been constructed ages ago...
00:57:40 <goltrpoat> (not a proper one :) )
00:57:43 <quicksilver> and we build functions on alegbraic types by matching
00:57:55 <quicksilver> however there is also an associated function
00:57:57 <quicksilver> :t (:)
00:58:06 <lambdabot> forall a. a -> [a] -> [a]
00:58:19 <quicksilver> but of course you can't pattern match against most functions
00:58:21 <quicksilver> just constructors
00:59:29 <quicksilver> in ML you can't pass a constructor around into higher-order functions
00:59:34 <quicksilver> because they distinguish the two
00:59:39 <quicksilver> in haskell we can, because we merge the two
00:59:44 <quicksilver> the haskell decision is the right one :)
00:59:48 <quicksilver> but there is room for confusion
01:00:09 <goltrpoat> and people tend to confuse type constructors with data constructors at first
01:00:25 <osfameron> I'm still working with metaphors like OO constructors, I'm wondering at what point that will start to be unhelpful
01:00:55 <quicksilver> I think there's a fairly good match between the metaphor
01:01:03 <quicksilver> the constructor is the only way to make 'things' of that type
01:01:33 <goltrpoat> personally, i'm going to voice the opinion that there's little utility in trying to match haskell constructors to OO constructors
01:01:39 <goltrpoat> but that's me
01:03:13 <osfameron> I just mean that it's a piece of data tagged with the information that it's *this* kind of data.
01:04:24 <quicksilver> that's part of it, yes
01:04:50 * DRMacIver head asplodes
01:04:56 <DRMacIver> Too much I want to read. :(
01:07:42 <quicksilver> DRMacIver: print it out 4-up
01:07:49 <quicksilver> DRMacIver: then you can read 4 pages at once
01:09:20 <DRMacIver> quicksilver: That's a good idea. Then I could cut it down to only a few thousand sheets of A4 (if I print on both sides)
01:09:38 <osfameron> microfiche!
01:10:31 <DRMacIver> The basic problem is that I a) Have no real computer science background and b) Wish to acquire knowledge of a large chunk of the existing body of literature on the implementation and extension of Standard ML.
01:11:02 <olsner> (re integer types) Ada also has a funky "generic numeric literal" type... if you declare a variable const Argh := 10; Argh will have that funky type and be castable to all kinds of numeric types
01:11:18 <DRMacIver> While we're at it, reading a significant chunk of my bookshelves would also be good. :)
01:11:39 <ivanm> what? those books are meant to be _read_?
01:11:51 <ivanm> I thought they were there solely for the show-off factor :p
01:12:05 <DRMacIver> ivanm: You wouldn't know it looking at my habits. I have five year old books which I've barely touched.
01:12:14 <ivanm> heh
01:12:16 <olsner> DRMacIver: it's just a matter of finding the right IRC channel with pickable brains to read and understand things for you
01:12:33 <DRMacIver> olsner: Why do you think I'm here? :D
01:12:34 * ivanm will read fiction as soon as he gets it, nonfiction is a different story though ;-)
01:12:41 <DRMacIver> ivanm: Same.
01:12:43 <goltrpoat> i recently discovered that i have two copies of menzel's 'mathematical physics'
01:12:53 <ivanm> heh
01:13:02 <goltrpoat> in my defense, i bought the first copy long before someone gave me the second edition as a christmas present
01:13:32 <goltrpoat> and the second one is hardback!
01:13:33 <DRMacIver> olsner: In my phone interview yesterday I was asked "You said you've not really done any Haskell, but your answers to some of these questions were quite sophisticated. What's up with that?" (or words to that effect) and a significant part of my answer was "I hang out on IRC." :)
01:15:09 <goltrpoat> if i ever have to interview again, i fully intend on answering all programming questions in J
01:15:22 <DRMacIver> Not APL?
01:15:29 <goltrpoat> i don't know any APL
01:15:34 <bluestorm_> FP ? :-Â°
01:15:40 <DRMacIver> goltrpoat: Shame.
01:16:06 <lollicide> how do i "hide" the negate meaning of "-"? i.e. i want to be able to make a section like (- 1) and for that to mean ((-) 1) and not (negate 1)
01:16:13 <DRMacIver> (Note that I answered Haskell questions not because I was showing off my knowledge of Haskell, but because it was for a Haskell job. I'm attempting to join Heffalump and augustss at CS)
01:16:24 <goltrpoat> > ((-) 1) 5
01:16:25 <lambdabot>  -4
01:16:54 <DRMacIver> lollicide: I don't think you can do that, because - has to be an infix operator.
01:16:59 <bluestorm_> hm
01:17:00 <bluestorm_> http://en.wikipedia.org/wiki/Heffalump
01:17:01 <lambdabot> Title: Heffalump - Wikipedia, the free encyclopedia
01:17:22 <DRMacIver> bluestorm_: No, the Heffalump that's in here. :)
01:17:39 <DRMacIver> Anyway, work.
01:18:04 <olsner> goltrpoat: APL is just like J but with its own non-ASCII character set and keyboard ;-)
01:18:24 <goltrpoat> ooh.
01:19:05 <dmwit> :t minus
01:19:08 <lambdabot> Not in scope: `minus'
01:19:09 <goltrpoat> i mean, i knew about the character set bit, i didn't realize it was like J though.  or do you mean "like J" as in, "both look like like noise"
01:19:09 <dmwit> :t subtract
01:19:11 <lambdabot> forall a. (Num a) => a -> a -> a
01:19:23 <dmwit> lollicide: Use subtract instead. =(
01:20:01 <lollicide> hm, i can't somehow set (-) = subtract?
01:20:25 <jbauman> i'm pretty sure J is based on APL
01:20:36 <olsner> goltrpoat: array-oriented, line-noise for functions, do-a-lot-with-very-little-code... I haven't actually coded them but from what I've read they share lineage
01:20:43 <goltrpoat> (-) *does* equal subtract, it's just that - gets special treatment parser-side
01:20:53 <goltrpoat> olsner:  awesome.
01:20:55 <olsner> :t (-)
01:20:57 <goltrpoat> APL it is then
01:20:57 <lambdabot> forall a. (Num a) => a -> a -> a
01:20:58 <lollicide> damn.
01:21:45 <dmwit> You're not the first person to bemoan this particular ambiguity.
01:22:26 <goltrpoat> well.. this particular resolution to this particular ambiguity
01:22:27 <goltrpoat> hehe
01:23:04 <olsner> speaking of line-noise ... http://en.wikipedia.org/wiki/Text_Editor_and_Corrector - scroll down to the brainfuck interpreter
01:23:05 <lambdabot> Title: Text Editor and Corrector - Wikipedia, the free encyclopedia
01:24:00 <goltrpoat> that looks like it needs to have +++ATZ at the end
01:24:27 <goltrpoat> or ATH0 or whatever the kids are calling it these days.
01:24:45 <olsner> modems are so pre-broadband... that's just not real for anyone anymore ;-)
01:25:59 <goltrpoat> (it's mildly amusing that you can actually type +++ATZ in an irc channel and not have half the channel sign off)
01:26:48 <dmwit> +++ATH0
01:27:23 <dmwit> Do people still use modems?
01:27:29 <goltrpoat> apparently not :)
01:27:43 <olsner> wow, hadn't they invented the escape sequence before the modem?
01:28:00 <goltrpoat> that's a hayes sequence
01:28:37 <jbauman> well, it could be compressed now
01:28:49 <olsner> the protocol should differentiate "+++ATH0" as traffic and "+++ATH0" as a command
01:28:50 <jbauman> ppp deflate
01:29:05 <mgoetze> i use an adsl modem :P
01:30:39 <goltrpoat> olsner:  yeah.  for a while, you could just type it on irc or in someone's terminal with talk, and they'd sign off.  then a bunch of kids ran around with the "type /privmsg #haskell :+++ATH0 to get your personalized horoscope" bit.  then people started filtering it i think.
01:32:00 <goltrpoat> then it died out because hayes init strings don't exactly work on people who don't use modems.
01:34:53 <jbauman> should have used icmp echo to force them to respond
01:35:25 <Wild_Cat> yeah... It seems modems, like parachute pants and viruses that do something other than make your computer join a spam botnet, are now a thing of the past.
01:37:11 * quicksilver hitches up his parachute pants
01:37:21 <olsner> I should get an APL keyboard.. just for the fun of it
01:37:23 <goltrpoat> jbauman:  except most people were on shell accounts, so that wouldn't have done much good :)
01:37:33 <mrsolo__>   +++ATH0... a long time ago... :-)
01:37:58 <mrsolo__> most recent one is netgear router kill bug...
01:38:01 <olsner> wonder if they work on PC
01:38:23 <kolmodin> there is still a trick like that for people running windows and norton antivirus
01:38:34 <kolmodin> you say something like startkeyboardlogging
01:38:43 <kolmodin> or similar. and they start dropping out :)
01:38:48 <goltrpoat> oh, nuts.
01:38:57 * osfameron drops to the floor, clutching his throat...
01:39:48 <Wild_Cat> fun. Reminds me of the time when typing "Allah bomb plutonium president Washington" would spawn men in black suits near your place... ^^
01:40:13 <liber> lol
01:40:16 <olsner> Wild_Cat: as if that's *really* happened to anyone?
01:40:26 <Wild_Cat> olsner: who cares if it has? :p
01:41:02 <goltrpoat> i'm envisioning men in black suits popping up like mushrooms around wild_cat
01:41:04 <olsner> anyone feeling like typing "Allah bomb plutonium president Washington" ;-)
01:41:08 <Wild_Cat> or maybe it *did* happen, but they erased all traces!
01:41:30 <ADEpt> goltrpoat: any time now. His case officer has already been notified ;)
01:41:40 <Wild_Cat> oh, wait a second, somebody's knocking on my do-- oh God please NO!!jikluyhqutr
01:41:48 <goltrpoat> i remember some kid sent out a threatening email to clinton, back when he was president, using an anonymous mailer
01:42:06 <goltrpoat> and was quickly explained why anonymous mailers aren't anonymous
01:42:12 <Wild_Cat> scared ya, didn't I? :p
01:42:27 <QtPlatypus> goltrpoat: A Mixmaster remailer?
01:42:27 <goltrpoat> by burly guys in suits.
01:42:58 <liber> Allah bomb plutonium president Washington
01:43:04 <goltrpoat> no idea, qt
01:45:07 <QtPlatypus> goltrpoat: The mixmaster remailing system was truely mathmatically provably anonoymouse.  But most anonomizers where not like that.
01:45:43 <liber> The blacksuited men have not arrived yet... It may take them a while to reach sweden
01:45:48 <sieni> anonoymouse :-D
01:46:19 <goltrpoat> QtPlatypus:  i'm talking 95 or so :)
01:47:24 <QtPlatypus> goltrpoat: Then its most likely the psydoanonoymouse server that they used to have in sweeden?
01:48:04 <goltrpoat> there were a bunch of them, several in finland
01:48:13 <goltrpoat> i don't know which one it was in particular, but yeah, something like that
01:48:50 <takamura> hi
01:48:54 <dmwit> heyo!
01:49:05 <goltrpoat> penet or one of those.
01:49:36 * QtPlatypus nods and recalls that one "its a pitty that the chirch of scientology got it shut down"
01:50:19 <goltrpoat> haha
01:51:04 <goltrpoat> nothing like the church of scientology contacting interpol to retrieve their secret tetan information.
01:52:15 <Saizan> +
01:53:07 <liber> I was trying to come up with a "insensitive clod"-joke, but I could not make it seem like a joke. You guys might have thought I was a scientologist
01:53:20 <liber> dang
01:53:37 <osfameron> you could have started ranting about us being psychiatrists ?
01:54:00 * Wild_Cat is trying to come up with a russian reversal...
01:54:02 <ari> "Hey, I don't know about you, but I was evolved from a space clam... you insensitive clod!"
01:54:22 <Wild_Cat> "in scientologist america, earth battlefields YOU!!"
01:54:23 <Cheery> how well computers can keep up with recognizing the context from continuous chunk of text?
01:54:26 <Wild_Cat> nah. That one sucked.
01:54:40 <liber> :)
02:10:31 <liber> My worldsoul/Tetan is actually a nice being, you insensitive clod!
02:16:23 <osfameron> ooo!  I want a worldsoul too!
02:17:03 <liber> But to get it "nice" you have to pay liek... alot of money
02:19:25 <osfameron> can I have an opensource worldsoul?
02:20:08 <liber> no
02:24:37 <Wild_Cat> I thought scientologists were rather into open source... What with the Xenu virtualization layer and all...
02:25:31 <liber> You should be ashamed... I hope you understand that
02:26:16 * Wild_Cat bows with a smile
02:26:39 <liber> If it is any comfort, I am ashamed for laughing
02:27:02 * dmwit didn't get it
02:27:16 <liber> dmead: xen viritualisation in the linux kernel
02:27:23 <dmwit> o
02:27:29 <liber> dang
02:27:55 <liber> I ofcource meant to say: dmwit
02:28:01 <dmwit> yeah
02:28:42 <osfameron> I didn't know what "xenu" was otoh
02:29:07 <osfameron> a warrior princess!
02:29:51 <Wild_Cat> http://en.wikipedia.org/wiki/Xenu
02:29:52 <lambdabot> Title: Xenu - Wikipedia, the free encyclopedia
02:30:50 <osfameron> gosh, well, that looks perfectly sane and reasonable
02:31:01 <dmwit> > 169%64-23%8
02:31:05 <lambdabot>  (-15)%64
02:31:44 <osfameron> what package is % defined in?
02:31:49 <dmwit> Data.Ratio
02:32:13 * osfameron struggles to load that into his ghci
02:32:35 <dmwit> :m +Data.Ratio
02:32:36 <liber> osfameron: Doesn't it? That is why it is so funny to make jokes about scientology. It is the worst mumbo-jumbo efer
02:33:36 <liber> ever*
02:33:37 <osfameron> dmwit: ah!  I don't think I would ever in a million years have worked that out from :?
02:34:02 <osfameron> "import Data.Ratio" or ":package Data.Ratio" would have made sense to my feeble brane.  thanks
02:34:17 <dmwit> It's :module Data.Ratio
02:34:25 <dmwit> But with an extra + ;-)
02:35:03 <osfameron> dmwit: I suppose - it complains that Data.Ratio is a "package module" when you try to :l it
02:35:17 <osfameron> so I might have got there eventually.  OK.  Less than a million years then.
02:35:42 <dmwit> heh
02:37:23 <earthy> damn. damn damn damn damn damn.
02:37:41 <earthy> and another damn for good measure.
02:38:01 <kosmikus> earthy: ?
02:38:01 <dmwit> ?slap earthy
02:38:02 <lambdabot> why on earth would I slap earthy
02:38:06 <dmwit> Pull it together, man!
02:38:19 <earthy> oh, something fundamental that won't work with Doaitse's parser combinators
02:38:42 <earthy> which basically means that I'm going to have to either depend on the actual guts of the combinators
02:38:50 <earthy> or switch to monadic parser combinators
02:39:18 <dmwit> Mmm, neither of those is exactly what you want, huh?
02:39:32 <earthy> both of them are a lot of shitty busy-work yeah
02:39:36 <Wild_Cat> liber: in all fairness, there's worse, as far as mainstream sects are concerned. There used to be a Flash intro to http://www.rael.org that just rendered all attempts at humor obsolete.
02:39:37 <lambdabot> Title: Intelligent : Design - Message from the Designers
02:39:51 <earthy> and I was hoping that I could have this all done by tomorrow
02:40:25 <dmwit> ?localtime earthy
02:40:26 <lambdabot> Local time for earthy is Wed May  9 11:39:50 2007
02:40:33 <dmwit> Oh, you're already on Wednesday.
02:40:36 <dmwit> You have all day!
02:40:38 <dmwit> =P
02:40:46 <earthy> I have less than 24 hours. ;)
02:41:00 <liber> Wild_Cat: Raelians are funny too,... you insensitive clod
02:41:49 <Wild_Cat> liber: not as funny as scientologists. It's harder to make jokes about them, in the same way it's harder to make jokes about a clown than it is to make jokes about Mr. Bean.
02:42:01 * earthy shrugs off the body-thetans and goes back to hacking
02:42:57 <dmwit> Wild_Cat: You mean this? http://www.rael.org/e107_plugins/raeltv_menu/view.php
02:42:59 <lambdabot> Title: The Raelian Movement: Videos - Summary of the Messages
02:43:44 <liber> There are some wacky christians too: www.fstdt.com/top100.asp
02:43:51 <liber> although the site seems down
02:44:10 * DRMacIver does his best to be amused by these people, but has gotten to the stage where htey just make me feel vaguely sad.
02:44:25 <Wild_Cat> dmwit: nope. I mean the Flash animation where the 1950s flying saucer flies toward earth and sends symbols of all religions toward it. It used to be on the home page -- I guess they realized how ridiculous it was and removed it.
02:44:37 <LeCamarade> #haskell-blah
02:44:48 <liber> LeCamarade: great idea
02:45:08 * LeCamarade is scared it will get to Communists, and he has to pretend he's not in the Party.
02:45:12 <Wild_Cat> yeah. Getting way off-topic here ^^
02:45:19 <osfameron> "Getting" :-)
02:45:26 <Wild_Cat> you're not fooling anyone, TheComrade ;)
02:45:41 <LeCamarade> Wild_Cat: :oO    !
02:45:44 <osfameron> heh
02:46:20 * LeCamarade is a Good Cadre. Haskell for the Revolution - so we are more-sure of success. :oD
02:55:04 <LeCamarade> The way I use $ is OCaml! That's the 4th thing Haskell taught me. How to use $. :oD
02:55:11 <LeCamarade> s/is/in/gi
02:55:20 * JKnecht calls the Quadriga of Haskell, Lisp, Prolog and Squeak the Cadre
02:56:10 <JKnecht> (since cadre literally means 'square' or 'framework')
02:56:20 <nomeata> Hi. I need a case-insensitive substring function for Lazy Bytestrings
02:56:31 * LeCamarade is drawn to the ML/Miranda crew. Lisp makes his eyes hurt, with all the ((()))(((((())))))
02:56:57 <nomeata> Obviosly it would be most efficient if I could implement it using the âinsideâ of a LBS
02:57:15 <nomeata> But can I do that without actually modifying the ByteString sources?
02:57:32 <dcoutts> nomeata: import Data.ByteString.Base
02:57:47 <DRMacIver> LeCamarade: Yeah, there are a number of features of Haskell which are purely cultural and port well.
02:58:26 <nomeata> dcoutts: thx
03:00:00 <LeCamarade> Which is why I don't get it when folk don't count Haskell in the ML family. What do they mean?
03:00:28 <LeCamarade> Miranda family?
03:00:32 <JKnecht> they stoopid
03:00:44 <LeCamarade> (Miranda is a trademark of Research Software).
03:01:10 <LeCamarade> JKnecht: But it's not in the list at Wikipedia, yet that list has been seen by all of #haskell.
03:02:41 <JKnecht> want me to add it?
03:03:19 <LeCamarade> JKnecht: Not if we are not all in agreement. Maybe we are subtly wrong to think Haskell is of the ML family.
03:03:35 <osfameron> it looks very similar
03:03:40 <osfameron> more similar than, say, C
03:03:46 <JKnecht> well if family means a descendant of ...
03:04:06 <LeCamarade> More-similar than C and Java. There, though, is this thing of parallel evolution.
03:04:32 <JKnecht> and for that matter on some platforms and some implementations there's interoperability (OCaml and the DOS Haskell)
03:05:04 <LeCamarade> Nobody can deny Miranda. What we should finish first is if Miranda is ML-inspired.
03:05:10 <LeCamarade> (Miranda is a trademark of Research Software).
03:06:33 <LeCamarade> Maybe the Miranda guy (name slips) came up with this stuff independently, or from an earlier thing.
03:06:46 <LeCamarade> (Miranda is a trademark of Research Software).
03:06:56 * LeCamarade is trying to rub it in how that trademark notice sucks.
03:07:56 <earthy> ;)
03:09:17 <sieni> the wikipage of miranda says that it was inspired by krc, ml and sasl
03:09:51 <jbauman> of course, that's wikipedia
03:09:57 <nomeata> ?paste
03:09:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:10:28 <hpaste>  nomeata pasted "subStringCI for ByteString â sensible definition?" at http://hpaste.org/1765
03:10:55 <nomeata> RFC: Do you think the function is relatively good? Itâs not using the BS internals after all.
03:11:30 <LeCamarade> Wikipedia says Python was inspired by Haskell. Utter hogwash. Guido spat when I asked.
03:11:43 <dcoutts> nomeata: why not just lowercase both the search string and the text?
03:12:07 <nomeata> dcoutts: it would copy the whole BS, woudnât it?
03:12:25 <nomeata> The str is rather large (a whole file)
03:12:28 <dcoutts> nomeata: depends if it fuses or not, but yes, possibly.
03:12:37 <njbartlett> Ruby was inspired by "Monkey", the low-budget 70s Japanese kung fu series.
03:12:55 <nomeata> And since the pat is relatively short, I hope that the lazyly walking through the zipâed list might be better
03:14:19 <earthy> Python was never inspired by haskell, ever
03:14:21 <nomeata> ugh:
03:14:23 <nomeata> latexki: internal error: stg_ap_v_ret
03:14:23 <nomeata>     (GHC version 6.6 for i386_unknown_linux)
03:14:23 <nomeata>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
03:14:25 <lambdabot> Title: 1.2. Reporting bugs in GHC
03:14:32 <earthy> it was a variant of ABC, initially
03:14:35 <nomeata> My first ghc bug
03:14:55 <dmwit> earthy, LeCamarade: Not even layout?
03:15:00 <earthy> not even layout
03:15:06 <earthy> ABC already had that, IIRC
03:15:26 <jbauman> where'd python get list comprehensions from?
03:15:36 <earthy> yup. it did have that.
03:15:42 <earthy> jbauman: maths
03:15:57 <LeCamarade> earthy: Yeah, but the Wikipedia page has claimed so for long. Crap.
03:16:07 <dmwit> On a side note, when will Haskell have monad comprehensions again?
03:16:13 <earthy> Python was initially developed at cwi in Amsterdam, which is filled with mathematicians and computer scientists
03:16:16 <dmwit> That sounds neat, I want to try them.
03:16:48 <LeCamarade> You can't have a language inspired by ML-family and not have patterns and functional. And Haskell's mark is laziness.
03:16:57 <njbartlett> dmwit: Good question, anybody know why they were removed?
03:17:08 <dmwit> They were too complicated for the layman.
03:17:23 <njbartlett> dmwit: And monads aren't? ;-)
03:17:33 <LeCamarade> dmwit: Since when was that a reason in Haskell? Monads wouldn't exist at all. :oD
03:17:34 <dmwit> njbartlett: Right, that was my response, too.
03:17:46 <LeCamarade> Haskell wouldn't exist.
03:17:53 <dmwit> LeCamarade: Hey, I'm on your side, I want 'em back in.
03:18:28 <LeCamarade> dmwit: Forgiven. Get him on his feet, soldier. :oD
03:18:37 <njbartlett> I seem to recall some reasoning behind the decision in SPJ's history of haskell paper.
03:19:06 <njbartlett> http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
03:19:08 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
03:20:47 <dmwit> February 1999
03:20:54 <nomeata> strage. a recompile of my project makes the ghc bug go away
03:20:58 <dmwit> "List comprehensions reverted to just lists."
03:21:01 <dmwit> That's all it says.
03:23:13 <njbartlett> "...generalising comprehensions
03:23:13 <njbartlett> to monads meant that errors in ordinary list comprehensions could
03:23:13 <njbartlett> be difficult for novices to understand"
03:23:27 <njbartlett> Page 25, right column, first para
03:23:58 <dmwit> Yup, just reached that one.
03:25:11 * DRMacIver is sortof unconvinced that what Haskell needs is more syntactic sugar.
03:25:22 <nomeata> ARG, now I get a floating point exception even before my program does anything.
03:27:19 <njbartlett> DRMacIver: Are you talking about monad comprehensions? The sugar is already there, for list comp. It would be the same syntax for the more general case.
03:27:43 <DRMacIver> Yes, true.
03:27:44 <olsner> (\x -> (g x, h x)) = (funcyFunction (,) g h) - what is funcyFunction?
03:28:26 <dmwit> :t join (,)
03:28:29 <lambdabot> forall a. a -> (a, a)
03:28:46 <dmwit> funcyFunction = join
03:28:50 <dmwit> Oh, wait, no.
03:29:04 <dmwit> :t ap
03:29:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:29:47 <dmwit> ?pl \g h x -> (g x, h x)
03:29:48 <lambdabot> liftM2 (,)
03:30:09 <dmwit> There you have it! =)
03:30:56 <ski> (Control.Arrow.&&&)
03:31:20 <olsner> wait.. what I tried to do already existed *at the same name* in GHC.List
03:31:30 <olsner> I just had a different capitalization
03:32:41 <olsner> :type (Control.Arrow.&&&)
03:33:15 <olsner> :t (&&&)
03:33:17 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:42:39 <DRMacIver> Hm.
03:42:41 <DRMacIver> :t (,)
03:42:44 <lambdabot> forall a b. a -> b -> (a, b)
03:43:06 <DRMacIver> I see.
03:45:49 <Cheery> @hoogle justValues
03:45:50 <lambdabot> No matches found
03:46:47 <dmwit> :t fromJust -- Cheery, this?
03:46:49 <lambdabot> forall a. Maybe a -> a
03:47:41 <olsner> > fromJust Nothing
03:47:42 <lambdabot>  Exception: Maybe.fromJust: Nothing
03:48:21 <LeCamarade> fromJust == unsafePerformMaybe?
03:48:35 <LeCamarade> ?
03:51:12 <olsner> :pl curry snd
03:51:33 <olsner> ?pl \a _ -> a
03:51:34 <lambdabot> const
03:51:41 <olsner> ?pl \_ a -> a
03:51:42 <lambdabot> const id
03:52:06 <dmwit> ?pl curry snd
03:52:07 <lambdabot> const id
03:52:10 <dmwit> heh
03:52:43 <olsner> :t const id 1
03:52:46 <lambdabot> forall a. a -> a
03:53:34 <olsner> const id _ = id
03:54:29 <dmwit> const x _ = x
03:54:39 <dmwit> ?src const
03:54:39 <lambdabot> const x _ = x
03:54:43 <dmwit> ;-)
03:55:29 <olsner> heh, goes around comes around ;-)
04:06:36 <Cheery> dmwit: no, but I just wrote such thing swiftly
04:07:07 <dmwit> Cheery: What does it do?
04:07:58 <Cheery> [Time] -> [Maybe a] -> [(Time,a)]
04:08:14 <Cheery> just trying out stream based equations for FRP
04:09:08 <dmwit> :t \times -> zip times . catMaybes
04:09:13 <lambdabot> forall a a1. [a] -> [Maybe a1] -> [(a, a1)]
04:09:24 <Cheery> kewl
04:09:38 <Cheery> these seem substantially more cleaner than continuation based implementation
04:10:15 <dmwit> FRP = functional reactive programming?
04:10:43 <Cheery> y
04:11:12 <LeCamarade> From the What-Is-The-Word-Coming-To Department ...
04:11:49 <Cheery> dmwit: thought your function does not do the required thing
04:11:58 <dmwit> oh =(
04:11:58 <LeCamarade> > if (id $ True) == True then True else False
04:12:00 <lambdabot>  True
04:12:27 <dmwit> LeCamarade: Where did you see that?
04:12:40 <dmwit> data Logic = True | False | FileNotFound
04:13:05 <mauke_> deriving (Enum)
04:13:14 <Cheery> dmwit, I see your stuff does something like: [1,2,3] -> [Just a, Nothing, Just b] -> [(1,a),(2,b)] when the resoult should be: [(1,a),(3,b)]
04:13:21 <LeCamarade> dmwit: Just suffice it to say I should not code on an empty stomach. That last False was even (not False)
04:14:00 <Cheery> mauke_, lol
04:14:06 <Cheery> :info Enum
04:14:19 <dmwit> :t liftM (,)
04:14:21 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
04:14:21 <notsmack> :t \times ms -> filter (isJust snd) $ zip times ms
04:14:21 <LoganCapaldo> :t \times -> catMaybes . (zipWith (\a b -> b >>= (\b' -> return (a, b')) times)
04:14:24 <lambdabot> parse error (possibly incorrect indentation)
04:14:25 <lambdabot>     Couldn't match expected type `Maybe a'
04:14:25 <lambdabot>            against inferred type `(a1, b) -> b'
04:14:37 <Cheery> suc True == FileNotFound :D
04:14:44 <Cheery> *succ
04:14:58 <mauke> > (\x y -> [(a,b) | (a, Just b) <- zip x y]) [1,2,3] [Just 'a', Nothing, Just 'b']
04:14:59 <lambdabot>  [(1,'a'),(3,'b')]
04:15:15 <pitecus> is there a way to parse and evaluate haskell expressions at runtime in GHC?
04:15:17 <dmwit> :t ap
04:15:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:15:30 <mauke> @where hs-plugins
04:15:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:15:36 <mauke> pitecus: ^
04:15:55 <Cheery> ap seems useful
04:15:59 <Cheery> @hoogle ap
04:16:00 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
04:16:00 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
04:16:00 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
04:16:03 <pitecus> mauke, hs-plugins isn't included in GHC, no?
04:16:07 * notsmack forgot a .
04:16:09 <mauke> no
04:16:10 <Cheery> looks nice I think
04:16:36 <dmwit> ?hoogle (a -> b) -> a -> m b
04:16:37 <notsmack> > (\times ms -> filter (isJust . snd) $ zip times ms) [1,2,3] [Just 'a', Nothing, Just 'b']
04:16:38 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
04:16:38 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
04:16:38 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
04:16:39 <lambdabot>  [(1,Just 'a'),(3,Just 'b')]
04:17:09 * notsmack is tired.
04:18:18 <pitecus> ghci does it somewho, isnt that functionality available as a library?
04:19:25 <dmwit> > let raise a = liftM (a,); catEm xs ys = catMaybes (zipWith raise xs ys) in catEm [1,2,3] [Just 'a', Nothing, Just 'b']
04:19:26 <lambdabot>  Parse error
04:19:45 <dmwit> > let raise a = liftM ((,) a); catEm xs ys = catMaybes (zipWith raise xs ys) in catEm [1,2,3] [Just 'a', Nothing, Just 'b']
04:19:47 <lambdabot>  [(1,'a'),(3,'b')]
04:20:28 <dmwit> :t (catMaybes .) . zipWith (liftM ((,) a))
04:20:30 <lambdabot> Not in scope: `a'
04:20:43 <dmwit> :t (catMaybes .) . zipWith (\a -> liftM ((,) a))
04:20:45 <lambdabot> forall a a1. [a] -> [Maybe a1] -> [(a, a1)]
04:20:54 <quicksilver> pitecus: yes, it's called hs-plugins
04:20:59 <dmwit> ?pl \a -> liftM ((,) a)
04:21:00 <lambdabot> fmap . (,)
04:21:12 <dmwit> :t (catMaybes .) . zipWith (fmap . (,))
04:21:14 <lambdabot> forall a a1. [a1] -> [Maybe a] -> [(a1, a)]
04:21:19 <dmwit> Unreadable as hell.
04:21:29 <pitecus> quicksilver, i mean having to use a package not included in GHC
04:22:03 <mauke> > (\x y -> [(a,b) | a <- x | Just b <- y]) [1,2,3] [Just 'a', Nothing, Just 'b']
04:22:04 <lambdabot>  Parse error
04:22:19 <quicksilver> pitecus: no, it is available as the library package hs-plugins :)
04:22:56 <dmwit> > (\x y -> [(a, b) | a <- x, Just b <- y]) [1,2,3] [Just 'a', Nothing, Just 'b'] -- Cartesian product, or pattern match failure?
04:22:57 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b'),(3,'a'),(3,'b')]
04:23:17 <mauke> http://www.choosenursing.com/for_you/challenged.html
04:23:18 <lambdabot> Title: Choose Nursing: Be Intellectually Challenged
04:23:42 <dmwit> > (\x y -> [(a, b) | (a, Just b) <- zip x y]) [1,2,3] [Just 'a', Nothing, Just 'b']
04:23:44 <lambdabot>  [(1,'a'),(3,'b')]
04:23:47 <dmwit> whoa
04:24:06 <quicksilver> well zip is not the same as cartesian product :)
04:24:16 <Cheery> :DD
04:24:17 <dmwit> Right, I'm saying that solution is very pretty.
04:24:22 * quicksilver nods
04:24:32 <quicksilver> pattern matches in list comprehensions are very lovely
04:24:51 <quicksilver> @src catMaybes
04:24:52 <lambdabot> catMaybes ls = [x | Just x <- ls]
04:24:54 <dmwit> Ah, and I see he'd already done it, too.
04:24:56 <quicksilver> so simple :)
04:26:45 <Cheery> if something fails in list monad, the value is discarded?
04:26:52 <olsner> it'd be even nicer if list comprehension could be curried, like so: [(a,b) | (a,Just b) <- zip]
04:28:02 <mauke> Cheery: fail _ = []
04:28:04 <ToRA> > let f x y = (do { (a,Just b) <- zip x y ; return (a,b)}) in f [1,2,3] [Just 'a', fail "", Just 'b']
04:28:05 <lambdabot>  [(1,'a'),(3,'b')]
04:28:10 <mauke> iterating over 0 elements, etc
04:29:43 <roconnor> what's the relation between RSA-Haskell and haskell crypto library?
04:32:28 <quicksilver> Cheery: fail in the list monad has the effect of 'prune'
04:33:21 <_frederik_> hello, can anyone summarise rigid types?
04:33:23 <_frederik_>     Couldn't match expected type `xv' (a rigid variable)
04:33:23 <_frederik_>            against inferred type `Sparse CULLong Double Double'
04:33:32 <_frederik_> (i mean rigid variables)
04:34:10 <quicksilver> well it means that it is already fixed by somethiing
04:34:14 <quicksilver> so it can't be unified with something else
04:34:30 <olsner> shouldn't a back-tracking non-determinism monad be equivalent to the list monad, but without necessarily saving each intermediate value?
04:34:36 <vali> hmm, i'm trying to convince my teacher who is a mathematician to give Haskell a try. he is currently using C++ ... any code or something i can give him to illustrate the power of Haskell?
04:35:02 <_frederik_> quicksilver: really? what would it be fixed by?
04:35:07 <dmwit> I came across this earlier today:
04:35:23 <quicksilver> _frederik_: a nested forall, perhaps
04:35:33 <quicksilver> _frederik_: some kind of polymorphism
04:35:38 <_frederik_> quicksilver: indeed, why would that cause it to be fixed?
04:35:40 <matthew_-> vali: just show him what C++ code looks like... oh, wait.
04:35:51 <quicksilver> _frederik_: because a nested forall says 'this works at every type'
04:35:57 <quicksilver> _frederik_: so you aren't allowed to choose
04:35:57 <dmwit> > let fact n = product [1..n]; choose a b = fact a `div` fact b `div` fact (a - b) in map (\x -> map (choose x) [0..x]) [0..5]
04:36:06 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]
04:36:28 <dmwit> That's three powerful math concepts in one line of code. =)
04:36:42 <hpaste>  _frederik_ pasted "exampleOutputOfTypeVec1" at http://hpaste.org/1766
04:37:02 <_frederik_> quicksilver: can you look at that?
04:37:12 <dmwit> > fix sin
04:37:13 <lambdabot>  Exception: <<loop>>
04:38:03 <mauke> vali: fib = 1 : 1 : zipWith (+) fib (tail fib)
04:38:14 <_frederik_> i just pasted more
04:38:16 <hpaste>  _frederik_ annotated "exampleOutputOfTypeVec1" with "(no title)" at http://hpaste.org/1766#a1
04:39:08 <quicksilver> _frederik_: why do you think you need higher-rank there?
04:39:18 <quicksilver> _frederik_: why does that need to return a (forall a b c) ?
04:39:57 <_frederik_> because it is using type-level numerals
04:40:08 <quicksilver> ah
04:40:12 <quicksilver> I see hmm
04:40:12 <_frederik_> that's what "ReflectNum" means
04:40:49 * quicksilver nods
04:41:39 <_frederik_> but it complains even without the nested forall
04:41:46 <quicksilver> _frederik_: yes, that was a red herring
04:41:50 <_frederik_> i think it is because RawVector has functional dependencies which are completely determined
04:42:02 <quicksilver> _frederik_: you're claiming that that function works for any 'xv'
04:42:14 <quicksilver> _frederik_: but the fun deps disagree
04:42:15 <_frederik_> well, it does, as long as xv satisfies the constraints
04:42:23 <quicksilver> that isn't 'any xv' then
04:42:44 <_frederik_> what do you call "forall x . Show x => x -> String"?
04:42:54 <_frederik_> that's not any x is it? it's any x which is a Show
04:42:57 <quicksilver> right
04:43:00 <_frederik_> same here
04:43:07 <quicksilver> so where is the constraint on xv ?
04:43:14 <_frederik_> RawVector
04:43:35 <quicksilver> then you need a => part
04:43:41 <_frederik_> ?
04:43:42 <quicksilver> you need the 'Show x =>' part
04:43:45 <quicksilver> in your analogy
04:43:49 <_frederik_> i have it
04:43:56 <quicksilver> no, you don't
04:43:59 <_frederik_>   ) :: forall xv yv r . (RawVector (RSV Double CULLong) Double xv, RawVector (RSV Double CULLong) Double yv) =>
04:43:59 <quicksilver> there is no => in that type
04:44:07 <_frederik_> at the end of the line
04:44:14 <quicksilver> ah hmm
04:44:19 <quicksilver> hpaste isn't letting me see that bit :)
04:44:25 <_frederik_> (and further down as well)
04:44:26 <_frederik_> oh
04:44:34 <quicksilver> I got it now :)
04:45:12 <quicksilver> hmm
04:45:25 <_frederik_> i think i will have to do something else, the code is meant to be generated and i will have to make the generator smarter
04:46:23 <quicksilver> certainly I can't get my head around enough of that code to help you
04:46:32 <quicksilver> it looks like Sparse might be a type when you want it to be a class
04:46:33 <quicksilver> perhaps
04:46:42 <_frederik_> hmm
04:46:51 <_frederik_> too late for that
04:47:15 <_frederik_> whether it makes sense ornot
04:48:37 <quicksilver> if you post that to haskell-cafe someone with a bit more experience of type class hackery might be able to help you with it
04:48:47 <quicksilver> the problem is it's quite a long way from 'minimal'
04:48:53 <quicksilver> there's quite a bit you need to understand to understand it
04:48:59 <_frederik_> it's ok i can work around it
04:49:26 <_frederik_> i will add a member to RawVector which produces a TypeQ and splice it in
04:51:07 <_frederik_> hmm is there a way to produce a TypeQ from a TypeRep?
04:53:32 <_frederik_> never mind i already wrote such a function a long time ago
04:57:32 <swiert> @tell dcoutts Have you seen: http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_bbs_1/104-0185139-2315178?ie=UTF8&s=books&qid=1178711781&sr=8-1?
04:57:33 <lambdabot> Consider it noted.
04:58:41 <dcoutts> swiert: heh, cool.
04:58:42 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
04:59:55 <dcoutts> swiert: I wonder how long that has been there. I sent the review to the bod at CUP yesterday.
05:01:22 <Igloo> I like "Duncan Coutts, Monad Reader" - it sounds like your profession is reading monads  :-)
05:01:41 <dcoutts> Igloo: I thought that was my profession ;-)
05:01:55 * dcoutts -> office -> IO ()
05:02:01 <kosmikus> dcoutts: congratulations
05:02:42 <Igloo> dcoutts: You're fully polymorphic in your first argument?
05:03:51 <_frederik_> ah, geeks
05:04:46 <LeCamarade> Um, guys, what is darcs' equivalent of CVS' $Id$?
05:04:56 <mux> there isn't any
05:05:06 <LeCamarade> :oO
05:05:13 <LeCamarade> How will I fake leetness?
05:05:24 <LeCamarade> l33tn355, sorry.
05:05:26 <kosmikus> by not missing it
05:05:34 <mux> there have been discussions about how nice it would be to have those, but authors have been saying that it's a bit hard because it doesn't fit the framework, and so on
05:05:35 <Cheery> by being yourself
05:05:48 <mux> I agree this is lacking, ids are useful
05:06:12 <LeCamarade> Like the 12-year olds who have never seen it, since REM $Id$ isn't ... oh, well.
05:07:13 <DRMacIver> Hm. Is there a standard type class for partial orderings in Haskell?
05:07:26 * LeCamarade thinks it could be a handy addition. Don't say `where is the patch?'
05:08:14 <lypanov> where's the patch?
05:08:20 <lypanov> (different! i used a '!)
05:08:35 <lypanov> LeCamarade: whats it useful for out of interest?
05:08:49 <Cheery> it's interesting, in this stream based implementation of FRP they use something like: Behavior a -> Env -> Time -> Time -> a
05:09:24 <Cheery> I wonder why they don't just lift monads inside behaviors
05:09:37 <Cheery> ie. Behavior (IO a)
05:09:57 <Cheery> then just do:
05:10:22 <LeCamarade> lypanov: The $Id$ thing? Well, it identifies the file and changes and versions and last committer, et cetera.
05:10:46 <Cheery> at :: Behavior (IO a) -> [Time] -> IO a
05:11:00 <olsner> if the file drifts away from its working copy, you can still know where it came from by looking at the $Id$
05:11:15 <quicksilver> Cheery: because they don't want to tie it to IO?
05:11:51 <Cheery> why they don't want to tie it to IO?
05:11:55 <SyntaxNinja> @seen shapr
05:11:55 <lambdabot> I saw shapr leaving #haskell 13h 13m 41s ago, and .
05:13:42 <lypanov> LeCamarade: svn info ?
05:13:45 <notsmack> lambdabot: and?
05:13:45 <Igloo> LeCamarade: So how do you do that in a system where patches can be cherry-picked?
05:13:48 <lypanov> LeCamarade: or darcs quiv
05:13:51 <lypanov> equiv.
05:14:16 * lypanov generally just looks at the logs to find such information
05:14:24 <lypanov> you mean for a deployment?
05:15:00 <quicksilver> Cheery: because if it's not tied to IO you can use it in pure computations?
05:15:09 <lumi> Hi
05:16:55 <lumi> I've a question: I'm trying to write a function enumerating N x N, that is (Integer -> (Integer, Integer))
05:17:16 <Cheery> quicksilver: just how you use pure computations in main?
05:17:19 <dcoutts_> kosmikus: ta :-)
05:17:35 <lumi> And it seems to be just off the edge of my mathematical skills, for today, at least
05:17:40 <quicksilver> Cheery: right
05:17:46 <quicksilver> Cheery: but if it's IO then I can't use it in a pure computation
05:17:51 <quicksilver> Cheery: I can onlly use it in an IO action
05:18:05 <quicksilver> Cheery: bottom line: why put it in IO unless it does IO :)
05:18:49 <lumi> I've solved the case for finite subsets, of course
05:19:08 <lumi> Can anyone kindly clue me?
05:19:30 <quicksilver> lumi: there's more than one enumeration, of course
05:20:05 <lumi> quicksilver: Can you point me the right way? I'm not sure exactly how to google it
05:20:10 * LeCamarade missed some messages.
05:20:11 <quicksilver> > concatMap (\n -> zip [0..n] [n..0]) [0..]
05:20:18 <lambdabot> Terminated
05:20:26 * quicksilver ponders
05:20:43 <olsner> > take 10 $ concatMap (\n -> zip [0..n] [n..0]) [0..]
05:20:49 <lambdabot> Terminated
05:20:59 <LeCamarade> Um ... no, it may have been good for CVS but not good for darcs. I'm only starting out with darcs, and I hate CVS, so I am not in position to say much sanity.
05:20:59 <swiert> dcoutts: I'm not sure how long it's been on there. Graham only just mentioned it to me.
05:21:02 <mauke> lumi: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf
05:21:03 <lambdabot> http://tinyurl.com/3dj4lx
05:21:04 <olsner> > concatMap (\n -> zip [0..n] [n..0]) [0..20]
05:21:06 <lambdabot>  [(0,0)]
05:21:12 * LeCamarade sprints off mumbling `the nearly got me....'
05:21:22 <quicksilver> > concatMap (\n -> zip [0..n] (reverse [0..n])) [0..]
05:21:24 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
05:21:37 <olsner> > [10..0]
05:21:39 <lambdabot>  []
05:21:45 <quicksilver> lumi: that's one possible enumeration
05:22:04 <mauke> (1,0)? OH SHI-
05:22:06 <quicksilver> lumi: it's all the pairs which add up to 0, then all the ones which add up to 1, then all the ones which add up to 2, etc etc
05:22:29 <swiert> lumi: Joao Ferreira, a PhD student at nottingham, has been working on enumerating the rationals.
05:22:48 <mauke> he's currently at 123322/95288347
05:23:00 <swiert> lumi: He's writing a paper for JFP - I'm sure he'd welcome feedback. I think he's also giving a talk next week at Fun in the Afternoon...
05:23:00 <quicksilver> could be a long PhD
05:23:13 <lumi> quicksilver: Thanks, exactly what I need :)
05:23:33 <lumi> swiert: Thanks, I'll read it. What's "Fun in the Afternoon"?
05:23:50 <swiert> @where Fun in the Afternoon
05:23:50 <lambdabot> I know nothing about fun.
05:23:57 <lumi> Poor lb :(
05:24:12 <swiert> lumi: http://sneezy.cs.nott.ac.uk/fun/
05:24:15 <lambdabot> Title: Fun in the Afternoon
05:24:15 <olsner> @remember <lambdabot> I know nothing about fun.
05:24:16 <lambdabot> Done.
05:24:24 <swiert> lambdabot is a real workaholic.
05:24:40 <mauke> @quote
05:24:41 <lambdabot> desp says: [monochrom]: It is, however, hard to demand other people to be open-minded. [desp]: not if you've got a big enough axe
05:24:48 <olsner> All work and no play makes lambdabot a dull bot.
05:25:12 <lumi> Interesting! Sadly, I'm o nthe wrong continent
05:25:31 <mauke> no love for functional pearls? :(
05:25:37 <olsner> @quote
05:25:38 <lambdabot> inv2004 says: lambdabot: monads ?
05:25:56 <olsner> @quote lambdabot
05:25:56 <lambdabot> lambdabot says: Of course i'm female
05:26:13 <mauke> @vixen oh, hi
05:26:14 <lambdabot> <undefined>
05:26:17 <JohnMeacham> yay. jhc is passing regressions again.
05:26:28 <mauke> writing in RPS?
05:26:36 <JohnMeacham> eradicating the world is harder than it sounds.
05:26:38 <dcoutts_> JohnMeacham: great
05:26:51 <mauke> (regression passing style)
05:26:52 <olsner> eradicating the world?
05:27:22 <DRMacIver> Eradicating the whole world is a very useful programming technique.
05:27:45 <DRMacIver> It lets you implement very efficient sorting algorithms.
05:27:46 <earthy> yaay! type correctness (that can be derived from a type error! :))
05:28:00 <olsner> There are no bugs without users ;-)
05:28:03 <mauke> quantum bogosort?
05:28:07 <DRMacIver> Exactly!
05:29:45 <olsner> I rather like the intelligent design sort... runs in O(1) universes
05:32:16 <olsner> (but quantum bogosort as defined by http://en.wikipedia.org/wiki/Bogosort is quite inefficient in its consumption of universes... it should be possible to do it in O(n!) rather than O(inf) universes)
05:32:17 <lambdabot> Title: Bogosort - Wikipedia, the free encyclopedia
05:33:04 <dcoutts_> @hoogle memcpy
05:33:08 <lambdabot> No matches found
05:33:12 <dcoutts_> @hoogle copy
05:33:13 <lambdabot> Distribution.InstalledPackageInfo.copyright :: InstalledPackageInfo -> String
05:33:13 <lambdabot> Distribution.PackageDescription.copyright :: PackageDescription -> String
05:33:13 <lambdabot> System.Directory.copyFile :: FilePath -> FilePath -> IO ()
05:33:16 <DRMacIver> olsner: Yeah, but it's an expected O(n!) universe consumption, which is what matters. :)
05:33:41 <olsner> expected O(n!) is still much worse than O(1)
05:33:43 <DRMacIver> The number of genocides committed in sorting your array is asymptotically finite.
05:34:49 <mauke> @remember DRMacIver The number of genocides committed in sorting your array is asymptotically finite.
05:34:50 <lambdabot> Done.
05:35:08 <olsner> really? I mean, for each of an infinite number of correctly-sorted universes you should have like (n!-1) incorrectly-sorted ones
05:35:33 <swiert> I saw a talk by someone claiming that classical and constructive logic are asymptotically equal.
05:36:11 <ddarius> swiert: The limit as what approaches infinity?
05:38:16 <swiert> ddarius: Something along the lines of "number of tautologies" as the size of a random chosen formula grows.
05:41:35 <olsner> http://tcs.uj.edu.pl/~zaionc/papers_ps/negation3.pdf
05:42:34 <olsner> I don't expect to understand anything of that paper, but apparently the limit's about 42%
05:44:06 <swiert> fun (S : Set) (P : S -> Set) (P0 : W S P -> Set) => W_rect S P P0
05:44:06 <swiert>      : forall (S : Set) (P : S -> Set) (P0 : W S P -> Set),
05:44:06 <swiert>        (forall (s : S) (p : P s), P0 (sup S P s p)) -> forall w : W S P, P0 w
05:44:07 <mux> 42!
05:44:12 <swiert> woops.
05:45:01 <kosmikus> swiert: thanks
05:52:04 <lumi> quicksilver: Is there a way to do that in constant time and space btw?
05:52:24 <quicksilver> lumi: the answer I gave you was constant space
05:52:30 <quicksilver> lumi: I'm not sure what you mean about constant time :)
05:52:41 <quicksilver> lumi: it's linear time in the number of entries you inspect
05:52:50 <quicksilver> lumi: did you want constant time to choose a particular entry?
05:53:04 <lumi> Yes, sorry
05:53:53 <lumi> I was unclear, but a way in constant time for any n, yes
05:54:11 <quicksilver> well then you just have to work out the closed form for 'the value at position n'
05:54:20 <quicksilver> it's not particularly hard but I'm not going to do it for you :P
05:54:26 <lumi> Hehe
05:54:36 <matthew_-> I would like to propose a new extension with the following ghc option flag:
05:54:40 <matthew_-> -fallow-perl
05:55:10 <lumi> It's not homework, I'm trying to write a module to map integers to any structure, a kind of generator combinator (erk) thing
05:55:12 <mauke> -fignore-errors
05:55:31 <matthew_-> -fi-meant-what-i-said-damnit
05:55:35 <lumi> I'll try to figure it out, then
05:55:51 <lumi> quicksilver: Thanks for the pedagogical approach :P
05:56:21 <olsner> hmm... doesn't INTERCAL have good support for de/interleaving bits in numbers?
05:56:36 <mux> heh, INTERCAL
05:56:40 <osfameron> also it has powerful branching constructs!
05:56:41 <mux> PLEASE
05:56:42 <lumi> INTERCAL doesn't have good support for numbers
05:56:50 <mux> COMEFROM 10
05:57:03 <lumi> PLEASE DON'T
05:57:04 <olsner> not numbers as you usually think of them, no ;-)
05:57:09 <mauke> oh yeah, computed come from
05:58:52 <notsmack> is there a good arrows primer around?
05:59:05 <mux> @where arrows
05:59:06 <lambdabot> http://www.haskell.org/arrows/
05:59:50 <notsmack> mux: already there, was hoping for more examples of their use
06:00:05 <osfameron> one of the yampa tutorials maybe?
06:00:10 <mux> sorry then, I don't know of another toturial
06:00:22 <mux> this one is good thouh :)
06:00:28 <osfameron> or there was a paper on using arrows to write a space invaders game.  It terrified me though..
06:00:51 <notsmack> osfameron: hah, that's the paper that sent me looking for a tutorial
06:00:57 <osfameron> notsmack: :D
06:01:26 <osfameron> notsmack: my approach is to ignore it and see if I understand it after having worked through SOE including the chapter on FRP
06:01:54 <osfameron> I'm hoping that if I understand the concepts up to there, then the arrows notation will make sense.  If I try to understand it before, my head will explode
06:02:51 <notsmack> heh, my copy's on the other side of the country.  i think understood it as i went through, but haven't had the epiphany about when i'd actually want to create an arrow
06:03:31 <igli> when you want more flexibility than a monad i *think*
06:03:56 <notsmack> igli: "But if you're using a structure that's very like a monad, but isn't one, maybe it's an arrow."
06:04:39 <osfameron> bah, I haven't yet even had the full epiphany on monads... I keep on having part-epiphanies, which is rather frustrating
06:05:09 <igli> heh i haven't created one yet, so i haven't got an example for you. looking at the tutorial, i could imagine using it for a grey-box approach, eg to circuits
06:05:40 <quicksilver> I wouldn't worry too much about creating a monad
06:05:46 <quicksilver> just get happy with abstracting thiings at all
06:05:59 <quicksilver> at some later stage, you'll look at some abstraction you made, and say 'oh, that's a monad after all'
06:06:01 <notsmack> osfameron: "You could have invented ..." is when monads clicked for me
06:06:26 <quicksilver> but other than a warm fuzzy feeling and some syntactic sugar, there isn't much gain from the magic 'instance Foo Monad where' line
06:06:45 <osfameron> notsmack: yeah, that's a part epiphany - automatically threading *something* along a pipeline of function calls
06:06:52 * quicksilver nods
06:06:57 <quicksilver> that's one of the best simple ones
06:07:16 <osfameron> anyway, I just need to spent some (or a lot) more tuits on working through the examples
06:07:18 <quicksilver> and if you're threading it along inputs only, then that's a reader, but if you thread it along inputs and returns then it's a state
06:07:43 <njbartlett> And if you thread it along returns only, it's a Writer?
06:07:44 <notsmack> quicksilver: interesting, can you elaborate on that?
06:07:54 <quicksilver> 'generating unique names' is another one which comes up quite often
06:08:09 <quicksilver> njbartlett: Writer actually isn't dual to Reader; at least, not in the obvious way
06:08:22 * earthy finally understood the use of parser monads
06:08:24 <quicksilver> njbartlett: Writer is more like 'syslog' (if you're familiar with unix metaphors)
06:08:34 <earthy> (rather than just parser arrows)
06:09:03 <njbartlett> Yes, you're right. I was being lazy
06:09:21 <quicksilver> notsmack: well a Reader is just like 'parameters in common between multiple functions', some people would call that 'an environment'
06:09:31 <njbartlett> One of the things that helped me understand monads was LINQ. Which I know is a little bit backwards, but there you go
06:09:40 <quicksilver> notsmack: but if your functions need to be able to modify the environment, and "later" functions notice that fact, then that's a full State monad
06:10:12 <notsmack> quicksilver: yeah, i get State...
06:10:40 <quicksilver> notsmack: Reader is a substitute for 'global configuratoin constants'
06:10:51 <quicksilver> notsmack: i.e. constants which turn out not to be constant because they're read from a config file
06:10:57 <notsmack> quicksilver: ah.
06:11:07 <notsmack> quicksilver: that makes a lot of sense, thanks
06:11:24 <fasta> Is there a way to enumerate all values in String in the order "A" "B" "C" -> "Z" -> "AB" "AC" etc?
06:11:42 <fasta> I.e. something that I can use already, no need to explain the trivial algorithm.
06:12:39 <mauke> does it have to be that order?
06:13:07 <quicksilver> > let words n = replicateM n ['A'..'Z'] in concatMap words [1..]
06:13:12 <quicksilver> fasta: like that?
06:13:14 <lambdabot>  ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S"...
06:13:24 <quicksilver> > let words n = replicateM n ['A'..'C'] in concatMap words [1..]
06:13:26 <lambdabot>  ["A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","AAC",...
06:13:37 <quicksilver> (made the alphabet shorter so we could see more)
06:14:34 <mauke> > map (\n -> showIntAtBase 26 (['A'..'Z'] !!) n "") [20 ..]
06:14:37 <lambdabot>  ["U","V","W","X","Y","Z","BA","BB","BC","BD","BE","BF","BG","BH","BI","BJ","...
06:14:51 <fasta> quicksilver: yes, like that. What a nice solution.
06:15:55 <quicksilver> replicateM in the list monad is cartesian product
06:15:59 <quicksilver> handy to know :)
06:16:03 <mux> yummy!
06:16:36 <fasta> I personally think it's better to name it cartesian product then.
06:16:41 <quicksilver> of course, concatMap is >>= so I could have written
06:16:44 <quicksilver> > let words n = replicateM n ['A'..'C'] in  [1..] >>= words
06:16:46 <lambdabot>  ["A","B","C","AA","AB","AC","BA","BB","BC","CA","CB","CC","AAA","AAB","AAC",...
06:16:50 <fasta> Overly generalized code is hard to read.
06:16:54 <quicksilver> fasta: yes, well that's why I gave it the name 'words'
06:17:01 <quicksilver> fasta: rather than just inlining it
06:17:05 <mauke> > words "a b c"
06:17:07 <lambdabot>  ["a","b","c"]
06:17:26 <quicksilver> of course, I overrode a prelude function :) which was  bad style
06:17:29 <quicksilver> but there you go
06:17:51 <Amran> hello
06:18:02 <mux> > [1..3] >>= [1..4]
06:18:03 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
06:18:05 <mux> err.
06:18:11 <Amran> wanted to ask - what's the easiest way to talk to databases in haskell?
06:18:11 <mux> > 2 >>= [1..4]
06:18:12 <lambdabot>  Couldn't match expected type `a -> m b'
06:18:22 <Amran> checking out hdbc - but are there other options for noobies
06:18:23 <mauke> > [1..3] >> [1..4]
06:18:24 <lambdabot>  [1,2,3,4,1,2,3,4,1,2,3,4]
06:18:36 <mux> yeah, that's it :-P
06:18:50 <mux> I rarely use the list monad
06:19:15 <yaxu> i'm having some problems...  is there an obvious reason why a haskell program involving threads would work from the ghci prompt but not in compiled form?
06:19:38 <mux> maybe the lack of -threaded ?
06:19:39 <quicksilver> yaxu: because the main thread terminates, perhaps
06:19:51 <quicksilver> yaxu: compiled apps die when main thread does
06:19:57 <quicksilver> yaxu: ghci lets them live
06:20:29 <SamB_XP> yaxu: how does it not work?
06:20:50 <yaxu> a thread seems to die sometime after it starts up
06:21:27 <yaxu> the main thread isn't dying though
06:21:52 <quicksilver> it's getting a signal which ghci masks, possibly?
06:23:22 <yaxu> ah, i think mux was right
06:23:52 <mux> it really was a wild guess, retrospectively, I think quicksilver and others' explanation made much more sense
06:24:47 <yaxu> yes, that's working now
06:24:49 <yaxu> thanks :)
06:25:06 <yaxu> which leads me to problem number too - i'm getting many stack space overflows
06:26:14 <yaxu> actually i've asked about this before, i'll check the irc logs
06:26:28 <chessguy> "In any case, one thing seems clear, if surprising: the language of the future is JavaScript."
06:26:45 <osfameron> url?
06:26:51 <chessguy> http://www.advogato.org/article/929.html
06:26:53 <lambdabot> Title: Advogato: The browser wars are once again upon us
06:26:58 <chessguy> (linked from LtU
06:27:12 <SamB_XP> oh no... worse than... the clone wars... they are!
06:27:15 <osfameron> but actually, javascript is a nice little langauge
06:27:24 <mux> I tend to disagree
06:27:31 <mux> ECMAScript sucks
06:27:36 <psnl> x86 assembler is the language of the future.
06:27:38 <mux> it has useless closure semantics
06:27:41 <matthew_-> osfameron: indeed. I like it, so long as you chuck everything you know about java out the window first
06:28:03 <matthew_-> mux: you mean the capturing of the variable rather than the value?
06:28:10 <osfameron> mux: that's interesting, I've not played with closures enough to notice them being useless, how do you mean
06:28:13 <chessguy> JS 2.0 is supposed to be getting even better
06:28:13 <mux> matthew_-: precisely
06:28:16 <SamB_XP> psnl: remind me why they are happy to be lowering ASM/C ratio in ZSNES?
06:28:28 <mux> that and the fact that it's waaaay too dynamic to my taste
06:28:42 <matthew_-> mux: iirc, python does the same thing wrt closures
06:28:54 <osfameron> it has some rough edges like iterating over an array and hash being confused by the inherited universal methods
06:29:02 <mux> matthew_-: I trust you on that one, I'm not using python :-) but I still find these semantics really, really bad
06:29:02 <ndm> mux: javascript is great!
06:29:15 <matthew_-> there are some nice functional features now in javascript 1.8
06:29:15 <mux> bleh :-P
06:29:16 <chessguy> they say JS is stealing hot features from python
06:29:34 <mux> yeah, destructured assignments, some basic list comprehension thingie
06:29:42 <psnl> SamB_XP: throwaway comment. it was a reference to the fact that the language that is run isn't the language you code in.
06:29:43 <mux> I've read about those new features
06:29:47 <ndm> matthew_-: who cares, javascript can never evolve beyond about 1.4, since its web and reverse compatability
06:29:51 <osfameron> but noone really has javascript 1.8...
06:29:59 <mux> they're not enough to make my like it, and maybe this is because I have used way too much in my previous work
06:30:14 <matthew_-> ndm: I care. I don't run windows and can't be arsed to care about IE. The javascript I write is firefox only.
06:30:21 <mux> heh
06:30:38 * mux scares matthew_- by waving a innerHTML sign
06:30:53 <mux> all your DOM is belong to me
06:30:59 <chessguy> they're adding on a type system too
06:31:03 <mux> !
06:31:10 <mux> for ECMAScript 2.0? :-)
06:31:12 <chessguy> @remember mux all your DOM is belong to me
06:31:12 <lambdabot> Done.
06:31:16 <chessguy> yup
06:31:26 <matthew_-> google write javascript by compiling to it
06:31:31 <mux> well, that has a chance of making me like it better
06:31:32 <quicksilver> osfameron: closures made inside a loop get references to the same vars rather than fresh ones
06:31:37 <matthew_-> aren't there some haskell -> javascript compilers?
06:31:40 <quicksilver> osfameron: fresh scopes are only set up by functions
06:31:44 <mux> osfameron: and that's fucking annying :-)
06:31:53 <quicksilver> osfameron: so you have to put silly anonymous functions in the way to get the behaviour you expect
06:32:00 <mux> this is my biggest gripe about js
06:32:01 <osfameron> ah!  yes, ok, there brace scoping is broken, I remember that
06:32:02 <matthew_-> mux: it's not if a) you remember it and b) you plan ahead
06:32:14 <mux> how many times I had to add functions in between
06:32:14 <quicksilver> osfameron: well it's correct according to design
06:32:22 <quicksilver> osfameron: it's just an odd design :)
06:32:30 <osfameron> quicksilver: heh
06:32:41 <mux> matthew_-: using the same reasoning, nothing is annoying
06:32:50 <matthew_-> mux: quite - be happy!
06:32:56 <mux> heh :-)
06:32:58 <matthew_-> mux: actually, I find that one of the strangest things is that it pushes you to write CPS code - particularly for ajax stuff
06:32:59 <osfameron> I get caught out with Perl's closures only coming out of subroutines, I don't understand why I can't close *any* lexical scope but, there you go
06:33:09 <pitecus> Is there a functions which does the same as read but give a more useful exception than just Prelude.read: no parse?
06:33:22 <mux> my second biggest gripe with js is the lack of threading primitives to deal with synchronization issues
06:33:32 <mux> which is hella annoying when you do a lot of AJAX stuff
06:33:38 <mux> with lots of callbacks
06:33:49 <matthew_-> mux: yeah, I've not suffered that one myself yet.
06:34:03 <mux> matthew_-: I suggest you do some google maps code then :D
06:34:09 <matthew_-> NOOOOOOOOOO!
06:34:17 <mux> hehehe
06:34:19 <sphynx> hi! could you please tell me, where can I find PDF version of "All about monads" tutorial?
06:34:45 <quicksilver> pitecus: no; if you want useful errors, you need a real parser ;(
06:34:50 <chessguy> ?where monads
06:34:50 <lambdabot> http://www.nomaware.com/monads/html/index.html
06:35:06 <mux> aaaah, it feels good to spread some hate on js
06:35:08 <chessguy> ugh
06:35:14 <sphynx> chessguy, it is HTML version
06:35:18 <chessguy> i thought i updated that version
06:35:20 <chessguy> err, that link
06:35:21 <notsmack> sphynx: http://www.google.com/search?q=all+about+monads+pdf
06:35:22 <lambdabot> Title: all about monads pdf - Google Search
06:35:42 <pitecus> aha
06:35:58 <mux> matthew_-: I had to do some huge google maps coding at my previous work, and I really, really didn't enjoy it - it made me dream of DOM bindings for Haskell along with a FF plugin :-)
06:36:36 <chessguy> mux: really? what were you doing with google maps?
06:36:46 <sphynx> thanks! :)
06:36:49 <pitecus> i still don't get why so many haskell functions dont even give you line numbers when they throw an error. Pattern matching exceptions do that so why dont other exceptions?
06:36:51 <mux> chessguy: a site for giving road traffics in france
06:37:05 <chessguy> like real-time traffic reporting?
06:37:05 <mux> chessguy: displaying lots of little icons according to events on the roads (traffic jams, accidents, and so on)
06:37:09 <mux> yes
06:37:11 <chessguy> ah, nice
06:37:13 <mux> with webcams and all
06:37:21 <mux> I want a DOM monad
06:37:36 <chessguy> i wonder if you could do monads in JS
06:37:38 <chessguy> 2.0
06:38:16 <mux> I'm not going to try :-P
06:40:10 <fasta> pitecus: because apparently nobody cares enough
06:40:17 <mux> matthew_-: that being said, doing JS is *much* more convenient with the Prototype layer
06:40:22 <fasta> pitecus: (and it's easy to do as a user, anyway)
06:40:29 <mux> it adds a few very convenient methods and idioms
06:40:31 <chessguy> hmm, i thought i had a decent reference on javascript. if so, i don't have it on my shelf here
06:40:34 <pitecus> fasta, easy?
06:40:35 <fasta> pitecus: you can create a CPP macro
06:40:42 <pitecus> yuck
06:40:45 <timlarson_> I have heard jquery really helps too.
06:41:05 <mux> I'm not fond of $('foo') though..
06:41:26 <quicksilver> JS has fairly good abstraction
06:41:36 <quicksilver> you can implement quite a lot of sugar in it if you want to
06:41:45 <matthew_-> mux: yeah, I just prototype and json libraries without thinking...
06:41:47 <mux> yep, that's the positive point
06:41:52 <matthew_-> s/just/use/
06:41:54 <quicksilver> JQuery is 'almost declarative' in its rather elegant query-and-modify DOM syntax
06:42:04 <fasta> There was a presentation on JS on programming.reddit.com, but unfortunately the poor guy claimed that C has no way to pass functions.
06:42:21 <fasta> Otherwise it was quite a nice presentation.,
06:42:36 <chessguy> meh, it's possible, but impractical in C
06:42:37 <mux> matthew_-: the .each for the Array object of Prototype is particularly useful
06:42:55 <chessguy> ?seen procyon112
06:42:55 <lambdabot> I saw procyon112 leaving #gentoo-haskell and #haskell 1d 11h 38m 20s ago, and .
06:43:05 <mux> and rather functional-like
06:43:20 <fasta> chessguy: right, but if you are going to say that "nobody understands JavaScript", be sure to understand what _you_ are talking about.
06:43:44 <chessguy> sure
06:44:30 * mux frowns at the memories of using a JS obfuscator without breaking his google maps code because the client wanted it
06:44:41 <mux> that sucked so hard :-(
06:45:01 <mux> the poor thing had problems distinguinshing code from strings due to the poor JS API
06:45:10 <mux> like setTimeout()
06:45:25 <mux> where you are supposed to pass code within a string (yay!)
06:45:49 <njbartlett> Any thoughts on the "next big language", as Steve Yegge puts it?
06:46:06 <quicksilver> the consensus is that the consensus is javascript
06:46:07 <matthew_-> well I think I speak for everyone here, when I suggest:
06:46:10 <matthew_-> Haskell
06:46:13 <quicksilver> if you'll excuse the important indirection :)
06:46:18 <osfameron> the comments to that thread suggested Javascript or Perl6 :-)
06:46:24 <mux> ewww
06:46:29 <osfameron> Haskell doesn't have the convenient and familiar C syntax
06:46:31 <quicksilver> perl6 my arse :P
06:46:35 <njbartlett> If there was any justice in the world: Haskell, of course.
06:46:37 <mux> JS the "next big language"? I guess it all depends on the definition of "the next big language"
06:46:40 <matthew_-> quicksilver: constipation?
06:46:44 <quicksilver> I disagreed with a lot of his article
06:46:47 <mux> the next big language as in, used a lot, or as in, really cool? :-)
06:46:50 <quicksilver> It was interesting stuff
06:46:52 <osfameron> well, Yegge is good for that
06:46:56 <quicksilver> mux: used a lot
06:47:02 <mux> so I don't even care about it
06:47:05 <mux> ;-)
06:47:05 <osfameron> when he writes interesting he writes well, doesn't really matter if it's all right
06:47:12 <quicksilver> mux: 'big' meaning 'commercial and socially successful' or something
06:47:17 <mux> okay
06:47:22 <quicksilver> where socially refers to the society of blogsters and hackers
06:47:22 <fasta> What makes Yegge so special?
06:47:23 <mux> not an interesting criterion IMHO
06:47:31 <osfameron> I'd rather it be Perl6 or Javascript than C# for example
06:47:40 <mux> hey, C# ain't bad
06:47:42 <njbartlett> Nothing makes Yegge special. He's just another opinionated blogger.
06:47:47 <fasta> Isn't he just a random blogger?
06:47:55 <osfameron> sure, but it's another strongly typed low level language like Java
06:48:04 <osfameron> LINQ looks shiny though
06:48:05 <fasta> Right
06:48:19 <mux> Links is the future!
06:48:25 <mux> go Wadler!
06:48:26 <njbartlett> i think he used to have a fairly important job at Amazon, and now has a very secret job at Google, so is obviously qualified to tell everybody what language they should use
06:48:46 <matthew_-> mux: you know that he can barely get papers published about Links atm
06:48:51 <osfameron> he's interesting to read.  I don't think he claims to be a guru, he just gets drunk and blogs.
06:49:03 <osfameron> what's Links ?
06:49:06 <matthew_-> osfameron: don't we all?
06:49:11 <njbartlett> Links sounds interesting, it needs a better name though. I mean, try googling for "links"
06:49:17 <ndm> mux: links is impure, strict, lacks type classes and monads - its a haskell wannabe with a javascript back end
06:49:32 <mux> the point of links isn't the language, really, but the framework
06:49:36 <mux> the language can be improved
06:49:42 <matthew_-> and looks scarily like PHP
06:49:44 <mux> that being said, I'm off, bbl
06:49:48 <ndm> yes, improved iteratively until it reaches Haskell :)
06:49:49 <osfameron> @where links
06:49:49 <lambdabot> http://groups.inf.ed.ac.uk/links/
06:50:04 <ndm> the framework is very cool, list comps as database queries is a really neat trick
06:50:24 <njbartlett> ndm: taken directly from HaskellDB, of course...
06:50:57 <fasta> Was HaskellDB even the first with that idea?
06:51:00 <osfameron> so is LINQ based on Links?  or name just coincidental ?
06:51:02 <fasta> I doubt it.
06:51:08 <ndm> osfameron: no relation
06:51:10 <njbartlett> osfameron: no relation
06:51:14 <osfameron> heh
06:51:18 <njbartlett> LINQ = Language Integrated Query
06:51:28 <ndm> njbartlett: i saw it first in Links, and that was the bit that impressed me
06:51:30 <osfameron> how does comprehension tie to database?  Is it munging with parse tree?
06:51:31 <njbartlett> Dunno where the N comes from. Sodding backronyms
06:51:45 <ndm> maybe i shouldn't have been as impressed as i was ;)
06:52:06 <ndm> although FlapJax is _really_ cool, Wadler covered that as well, and thats well worth a look
06:53:29 <osfameron> @where flapjax
06:53:30 <lambdabot> I know nothing about flapjax.
06:53:43 <njbartlett> http://www.flapjax-lang.org/
06:53:45 <lambdabot> Title: Flapjax
06:55:08 <osfameron> ah, I vaguely think I heard of that
06:59:18 <Mark__> hello
06:59:27 <shapr> hiya
06:59:48 <Mark__> was wondering if someone could help me with some Haskell i'm having difficulty with
07:00:11 <shapr> It's better to ask the question rather than ask to ask.
07:00:18 <Mark__> hehee. true
07:00:46 <Mark__> ok i'm trying to load a list of tuples from a txt file, with line breaks to represent new tuples
07:01:09 <Mark__> i've managed to get the writing to file ok
07:01:13 <Mark__> toStr :: [Sale] -> String
07:01:13 <Mark__> toStr [] = ""
07:01:13 <shapr> More xmonad advertising from imperialviolet: http://imperialviolet.org/page29.html#e562 , yay!
07:01:16 <lambdabot> Title: I M P E R I A L V I O L E T . O R G
07:01:18 <Mark__> toStr ((artist, track, copiesSold):xs) = (("("++artist++", "++track++", "++(show copiesSold)++"),\n")++toStr xs)
07:01:29 <shapr> @paste
07:01:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:01:46 <shapr> Mark__: Paste your code with hpaste, that way we can easily annotate it.
07:02:02 <Mark__> hpaste toStr :: [Sale] -> String
07:02:02 <Mark__> toStr [] = ""
07:02:03 <Mark__> toStr ((artist, track, copiesSold):xs) = (("("++artist++", "++track++", "++(show copiesSold)++"),\n")++toStr xs)
07:02:06 <shapr> Mark__: Are you doing Thompson's Craft of Functional programming?
07:02:14 <Mark__> i have that book yes.
07:02:27 <shapr> Mark__: Visit http://hpaste.org/new and paste your code into the form there.
07:03:24 <hpaste>  Mark__ pasted "(no title)" at http://hpaste.org/1767
07:03:47 <Mark__> you recieve?
07:04:49 <shapr> Yup
07:05:03 <shapr> Mark__: So you want to read that format back from disk, yeah?
07:05:12 <Mark__> yes please
07:05:31 <shapr> Well, do you know how to convert a tuple to a string and back/
07:05:31 <shapr> ?
07:05:45 <shapr> For example, if you had (1,2) how would you turn that into a string?
07:06:04 <Mark__> with show?
07:06:27 <shapr> That's a good approach.
07:06:36 <shapr> > show (1,2)
07:06:38 <lambdabot>  "(1,2)"
07:07:10 <shapr> So how would you turn "(1,2)" into a tuple of two numbers?
07:07:43 <Mark__> read "(1, 2)" ?
07:07:52 <shapr> Yeah, that's what I'd do.
07:08:10 * dylan wonders.
07:08:21 <dylan> > read "(1, 2)" :: (Int, Float)
07:08:23 <lambdabot>  (1,2.0)
07:08:38 <shapr> dylan: picky :-P
07:08:59 <shapr> Mark__: So, could you use that same idea to 'show' the album information to a file, and then 'read' it back out?
07:09:37 <Mark__> yes, the only problem is having to read a single line at a time right?
07:09:38 <mauke> > read "[(1, 2),\n(3, 4)\n]" :: [(Int,Int)]
07:09:39 <lambdabot>  [(1,2),(3,4)]
07:10:35 <shapr> From what mauke just did, it looks to me like you can read the whole file at once if it's a legal list.
07:11:09 <shapr> Mark__: Are you writing each album on its own line because the exercise asks you to do it that way?
07:12:00 <Mark__> yes. The idea is that each track is only stored once, with the number of sales with it in the tuple to avoid having a new tuple for every sale
07:12:15 <shapr> That makes sense.
07:13:23 <shapr> Well, what options come to mind?
07:13:44 <mux> read is evil
07:14:04 * mux points at his Data.Parsable thingie
07:14:25 <shapr> Mark__: Do you know how to apply one function to every item of a list?
07:14:47 <Mark__> map f
07:15:02 <hpaste>  mux pasted "Data.Parsable" at http://hpaste.org/1768
07:15:23 <shapr> Do you know how to split a string at line endings, into a list of strings?
07:16:06 <Mark__> not come across that yet, no.
07:16:17 <joelr1> dons: ping
07:16:25 <joelr1> shapr: yo
07:16:27 <mux> :type lines
07:16:30 <shapr> hiya joelr1
07:16:46 <shapr> Mark__: mux just pointed out the 'lines' function.
07:16:58 <mux> @type lines
07:17:06 <lambdabot> String -> [String]
07:17:12 <shapr> > lines "foo\nbar\nbaz"
07:17:14 <lambdabot>  ["foo","bar","baz"]
07:17:46 <joelr1> shapr, dons: i'm debating whether to base my web app around happs or a lambdabot/hope architecture, what do you think?
07:17:48 <Mark__> brb - phone call :@
07:18:04 <Wild_Cat> >lines "foo\r\nbar\r\nbaz"
07:18:07 <shapr> Mark__: So I'd suggest reading in the file, running lines on it, and then doing "map (read :: (Artist,Track,NumCopies))" on the resulting list.
07:18:13 <Wild_Cat> > lines "foo\r\nbar\r\nbaz"
07:18:14 <lambdabot>  ["foo\r","bar\r","baz"]
07:18:27 <Wild_Cat> aw... So close, yet so far.
07:18:58 <Wild_Cat> (although maybe it does what I expect it to do when run on Windows)
07:20:53 <quicksilver> Wild_Cat: no, but the file input/output functions convert newlines before 'lines' ever sees them
07:20:59 <quicksilver> Wild_Cat: as long as you don't open the file in binary mode
07:21:09 <Wild_Cat> quicksilver: groovy.
07:27:54 <nominolo> any idea why one might experience with lazy bytestrings read from a socket handle?
07:28:13 <nominolo> it might have to do with problems in recognizing the end of a stream
07:28:40 <nominolo> it only reads 32K and then stops, while instead it should read 175MB
07:28:45 <nominolo> (and write it to a file)
07:31:30 <tom_> hi all
07:31:48 <shapr> hi tom_
07:32:06 <tom_> ah, I seem to have solved the problem I was about to ask about before I finished writing the question, I like it when that happens :p
07:32:17 <shapr> Yeah, cardboard consultant.
07:32:45 <DRMacIver> Recommended procedure is to put a small stuffed toy on top of your monitor and explain your problem to it.
07:32:59 <shapr> http://c2.com/cgi-bin/wiki?RubberDucking
07:33:02 <lambdabot> Title: Rubber Ducking
07:33:51 <tom_> haha, good idea. I usually use my cat for that though :p
07:35:50 <shapr> I like the quote from http://c2.com/cgi-bin/wiki?CardboardAnalyst, "Why is that developer trying to explain two-phase commit to a big cardboard wookie?"
07:35:52 <lambdabot> Title: Cardboard Analyst
07:37:17 <tom_> Now if I could only find my a life size cardboard wookie
07:39:55 <ptolomy> Fun tiny programming puzzle: I just thought I'd make a lazy list of the (x,y) coordinates of a spiral starting at (0,0)  (a la Ulam Spiral) and continuing, but the implementation is way less obvious to me than the idea. Can anybody think of a elegant way of doin' it?
07:40:45 <ptolomy> Oop. Just figured it out.
07:40:48 * ptolomy feels silly.
07:41:43 <nominolo> @seen dons
07:41:44 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 15h 18m 38s ago.
07:44:45 <shapr> ptolomy: Oh, I want to see!
07:45:42 * ptolomy is implementing it in (very) small portions in between things he gets paid to do.
07:45:47 * ptolomy haskells on the sly. :-P
07:48:52 <SimonRC> hmm
07:49:07 <SimonRC> how much stuff would break in Haskell if it was dynamically typed?
07:49:28 <quicksilver> 'dynamic' typing refers normally to variables which can change their type later?
07:49:34 <quicksilver> since in haskell variables don't change, in that sense...
07:49:46 <quicksilver> I think your question needs more context to make sense :)
07:49:59 <quicksilver> > let l = "foo" in let l = 3 in l
07:50:01 <lambdabot>  3
07:50:07 <quicksilver> (was l dynamically typed in that example?)
07:51:17 <osfameron> does it even make sense to have dynamic typing in a functional langugae ?
07:51:23 <osfameron> there aren't variables to change the type of
07:51:32 <SimonRC> What I mean is, Haskell currently has static typing.  What would stop working if it used dynamic typing instyead?  What expressiveness would it lose?
07:51:51 <quicksilver> SimonRC: What I mean is 'dynamic typing' is used to mean some rather different things; which thing did you want it to mean?
07:52:00 <SimonRC> osfameron: how about LISP, LISP, LISP, and LISP?
07:52:04 * ptolomy wishes once every few weeks for the haskell equivalent of ocaml's Graphics module.
07:52:20 <osfameron> SimonRC: LISP has variables though
07:52:29 <Lemmih> ptolomy: What does it do?
07:52:31 <SimonRC> so does Haskell...
07:52:40 <quicksilver> SimonRC: not in the 'setq' sense, it doesn't
07:52:49 <njbartlett> nominolo: dons is on vacation
07:52:51 <ptolomy> Lemmih: provides a really simple cross-platform way of opening windows and drawing 2d shapes.
07:52:53 <SimonRC> let me give you an example...
07:53:03 <ptolomy> Lemmih: Or colored pixels.
07:53:18 <osfameron> ptolomy: are the haskell libraries not as good?
07:53:35 <SimonRC> concatMap show ["foo", 42]
07:53:36 <ptolomy> I'm not familiar with an equivalent library that is standardly distributed with hasekll.
07:53:46 * earthy would guess SOE.Graphics qualifies.
07:53:54 <quicksilver> SimonRC: that's heterogenous lists
07:53:57 <quicksilver> SimonRC: we can do that in haskell :)
07:54:02 <joelr1> Lemmih: ping
07:54:05 <earthy> err. Graphics.SOE that is. :)
07:54:06 <SimonRC> yeah, not just that though
07:54:07 <nominolo> njbartlett: ok, thanks
07:54:23 <nominolo> anyone else with some bytestrings internals knowledge around?
07:54:25 * ptolomy checks on this SOE thing..
07:54:27 <pitecus> What does that mean Ambiguous type variable `a' in the constraint:      `Ord a'
07:54:36 <nominolo> I fixed the immediate problem
07:54:42 <pitecus> i dont have any type signature where its complaining about
07:54:50 <SimonRC> By dynamically-typed, I mean in the LISP/Python/Ruby sense: variables do not have types, values do.
07:54:53 <nominolo> the question is now:  Does a lazy bytestring close the handle once it's done?
07:55:07 <quicksilver> SimonRC: right. But haskell doesn't have variables, in that sense
07:55:23 <flux> quicksilver, btw, can you do heterogenous lists in haskell98, or in ghc?
07:55:24 <quicksilver> > let l = "foo" in let l = 3 in l -- l just changed type!
07:55:26 <lambdabot>  3
07:55:33 <nominolo> flux: yep
07:55:39 <cdsmith> SimonRC: A more accurate characterization of static types is that expressions have types, not variable.
07:55:43 <nominolo> flux: typesafe and not typesafe
07:55:49 <SimonRC> quicksilver: no, what I meant is more like...
07:55:53 <flux> nominolo, so no ghc extensions are involved? nice
07:55:57 <Lemmih> joelr1: er, pong.
07:56:03 <nominolo> flux: not in the latter
07:56:18 <joelr1> Lemmih: Where's HAppS.Protocols.S3? I just pulled the latest version of  HAppS but can't find it
07:56:30 <quicksilver> flux: I believe you need at least MPTCs
07:56:33 <nominolo> flux: if you want it to be typesafe you need faked dependent types. and this needs many GHC-exts
07:56:44 <flux> quicksilver, it's a stretch to say that changed any types ;)
07:57:09 <quicksilver> ack, no. I'm wrong
07:57:18 <quicksilver> Dynamic + Typeable are pure h98, according to the docs
07:57:24 <quicksilver> HList requires MPTC
07:57:24 <nominolo> > [toDyn 5, toDyn "foo", toDyn 'c']
07:57:26 <lambdabot>  [<<Integer>>,<<[Char]>>,<<Char>>]
07:57:27 <SimonRC> ... let foo x = type_case x of {Int -> show x; String -> x} in concatMap foo ["asdf", 123]
07:57:39 <quicksilver> SimonRC: right, well you can certainly do that
07:57:39 <SimonRC> Dynamic is a bit clunky
07:57:47 <SimonRC> quicksilver: how?
07:57:55 <quicksilver> SimonRC: using Dynamic + Typeable
07:58:04 <Lemmih> joelr1: It's not public yet. Plus, Amazon has introduced a $0.01 price on writes so it has become too expensive to be useful.
07:58:54 <joelr1> Lemmih: are you sure /useful/?
07:58:57 <SimonRC> but the time you want dynamic typing is in the exploratory stages, which is exactly the time you don't want to be using something like Data.Dynamic
07:58:58 <quicksilver> SimonRC: although for any *particular* example I'd rather use an alegbraic data type tailored to the problem at hand
07:59:04 <SimonRC> quicksilver: indeed
07:59:13 <joelr1> Lemmih: i thought local traffic (from ec2 to s3) was free
07:59:14 <SimonRC> it is quite hard to give examples
07:59:20 <quicksilver> SimonRC: I don't understand what you mean by exploratory stages, I don't think
07:59:30 <quicksilver> SimonRC: I find that strong typing is *especially* helpful in the exploratory stages
07:59:39 <SimonRC> When you are not really sure how you want to write the program.
07:59:39 <quicksilver> since it helps me build up a model of correct ways to transform my data
07:59:49 * quicksilver nods
07:59:50 <SimonRC> Well, I am told that is what cytnamic typing is good for.
07:59:54 <quicksilver> then I understand, and disagree
07:59:56 <SimonRC> *todl*
07:59:59 <SimonRC> *told(
08:00:00 <SimonRC> *told*
08:00:22 <SimonRC> I was reading   http://steve-yegge.blogspot.com/2007/02/next-big-language.html
08:00:24 <quicksilver> I find during that process strong typing catches serious 'thinkos' (that is, bugs in my preconceptions about the problem)
08:00:24 <lambdabot> Title: Stevey's Blog Rants: The Next Big Language
08:00:34 <quicksilver> and greatly improves things
08:00:49 <quicksilver> note that many people prototype in haskell before implementing in a dynamic language, not the other way around :)
08:01:37 <Lemmih> joelr1: The price of GBs transferred is zero but writes are still $0.01 a pop.
08:01:40 <ptolomy> I'm noticing that SOE and HGL aren't in my GHC install, but are listed in the onlie docs.
08:02:07 <SimonRC> Actually, I find that static typing is good for exploration too.
08:03:02 <SimonRC> The thing I was trying to ask is ... would you loose any expressivness if Haskell was dynamically typed?  (Disregarding the reduction in the ability of the compiler to help you.)
08:03:36 <joelr1> Lemmih: i'm writing a post on this to cafe but, essentially, i want to deploy a haskell web app on amazon ec2/s3. i'll bite the bullet and go with the 1c writes until i see that it's too expensive.
08:03:59 <osfameron> ptolomy: oh, I got them with my apt-got ghc on ubuntu
08:04:16 <dolio> SimonRC: It might have weird interactions with type classes.
08:04:20 <mux> apt-gimme
08:04:34 <osfameron> apt-nowayitsmine
08:04:46 <SimonRC> dolio: You wouldn't have typeclasses, you'd have duck-typing
08:04:57 <quicksilver> SimonRC: haskell without typeclasses is very weak
08:05:03 <quicksilver> SimonRC: completely differnet language
08:05:06 <quicksilver> almost useless
08:05:10 <quicksilver> typeclasses are everything!
08:05:12 <quicksilver> ;P
08:05:13 <dolio> SimonRC: Consider, "runX m", where "m" uses a bunch of generic monad operations.
08:05:16 <SimonRC> surely you can do almost all the typeclass stuff with dynamic types?
08:05:33 <dolio> SimonRC: Currently, the "runX" chooses which monad is used, and specializes all the operators for that monad.
08:05:43 <ptolomy> SimonRC: I think you'd lose some expressiveness, yes. The assumptions and the generalizations that happen based on the known type or type class wouldn't be possible without it.
08:06:03 <SimonRC> Ah, waitamo, the type-inference goes both directions doesn't it?
08:06:04 <dolio> SimonRC: In a dynamically typed language, how would it choose which monad to build "m" in?
08:06:28 <SimonRC> dolio: good point
08:06:46 <flux> hmm.. the runtime would know the type of the value (from a tag), and it has a list of typeclasses, aren't those enough?
08:06:48 <SimonRC> heck, really good point
08:07:00 <dolio> SimonRC: That might be solvable, but I'm not sure.
08:07:14 <SimonRC> flux: ok, write me a dynamically-typed read function.
08:07:30 <flux> simonrc, well, atleast the case (read :: Int) could be handled in a dynamic fashion
08:07:48 <flux> simonrc, perhaps the set of valid return types could be passed as the code is interpreted
08:08:01 <SimonRC> so Haskell has a collection of bizarre features whose restrictions are required to make the other features work, and if you remove any of them, the language becomes crap.  :-P
08:08:03 <flux> and if you end up into a 'read' when having more than one valid type, signal an error
08:08:06 <joelr1> Lemmih: any idea when the S3 interface may become public?
08:09:22 <Lemmih> joelr1: I'm afraid not. I don't even know why my employer is holding back the release.
08:09:28 <osfameron> SimonRC: that's rather harsh, I quite like the quote though
08:10:05 <DRMacIver> I think Haskell's distinguishing feature from a type system point of view is that a Haskell program isn't just an untyped Haskell program which has been proved typesafe.
08:10:09 <osfameron> but given that the best thing about Haskell seems to be the "static typing done really well", it doesn't seem sensible to think about removbing it
08:10:29 <SimonRC> DRMacIver: yes.  That was what I was trying to confirm.
08:10:53 <tfc> complete noob question
08:11:04 <tfc> how do u declare a constant in haskell?
08:11:11 <quicksilver> foo = 18.5
08:11:13 <tfc> Hi Milena,
08:11:13 <tfc> Just a quick questions about the new ISE coursework. Part 1 asks "Create a realistic description of the basic functionality. Could you expand on what this means? Is it basically a step by step description of the system? How many words are expected? I only ask because its worth 40% of the marks and seems simpler than the other parts of the coursework.
08:11:13 <tfc> Thanks
08:11:13 <tfc> Tim Childs
08:11:15 <mauke> constant = value
08:11:30 <SimonRC> LISP is the language in which you can tell the compiler to do almost anything.  Haskell is the language in which you can explain almost anything to the compiler.
08:11:34 <SimonRC> :-D
08:11:36 <tfc> opps
08:11:38 <quicksilver> :)
08:11:42 <quicksilver> welcome back tim
08:11:48 <tfc> lol
08:11:48 <quicksilver> did you see my answer before you vanihsed?
08:11:56 <tfc> nope
08:11:58 <quicksilver> foo = 18.5
08:12:01 <quicksilver> it's that simple
08:12:07 <tfc> k
08:12:28 <DRMacIver> If you'd asked how to define a variable in Haskell... that would have been a bit harder. ;)
08:12:38 <tfc> i get Undefined data constructor errors
08:12:51 <matthew_-> lower case names
08:13:00 <SimonRC> Actually, even things like lambda calculus have variables...
08:13:10 <matthew_-> Wibble = 18.5 -- this will blow up
08:13:10 <quicksilver> tfc: all names must be lower case
08:13:16 <SimonRC> and so does very-pure Haskell
08:13:18 <quicksilver> SimonRC: yes, but in a different sense
08:13:25 <quicksilver> SimonRC: the word variable is a little fiddly :)
08:13:43 <SimonRC> do you mean *mutable* variable?
08:13:44 <DRMacIver> SimonRC: You mean you don't write all your Haskell point free?
08:13:50 <SimonRC> :-P
08:13:53 <DRMacIver> How odd
08:14:14 <arcatan> state is for loserz!
08:14:23 <SimonRC> let f x = x + 1 in map f [42, 69] -- if variables don't vary, then what is the value of x here?
08:14:27 <DRMacIver> (Yes, I did of course mean 'mutable variable')
08:14:33 <SimonRC> (I guessed)
08:14:46 <SimonRC> hmm
08:14:48 <mauke> SimonRC: which x?
08:14:55 <mauke> the one in f 42 or the one in f 69?
08:14:56 <kpreid> SimonRC: it's varying in a different dimension!
08:15:04 <quicksilver> as I said, it's fiddly
08:15:12 <SimonRC> I was merely defending th terminology "variable"
08:15:16 <ptolomy> SimonRC: The equivalent is "map (+ 1) [42, 69]"
08:15:21 <quicksilver> haskell has bound variables, which vary over calls to a particular function
08:15:22 <ptolomy> free variable.
08:15:25 <ptolomy> err bound.
08:15:33 <SimonRC> I know all that
08:15:36 <psnl> SimonRC: drink more.
08:15:40 <SimonRC> psnl: bah
08:15:40 <quicksilver> but it doesn't have variables in the sense that $a is a variable in perl
08:15:50 <mauke> $a is special anyway
08:15:55 <quicksilver> which is what I meant by saying it's fiddly
08:15:56 <psnl> quicksilver: SimonRC does know that, I think
08:16:00 <quicksilver> psnl: I know he does
08:16:14 <mauke> $a is exempt from strict 'vars' checks
08:16:22 <SimonRC> WTF?!
08:16:27 <SimonRC> ?!?!?!
08:16:28 <lambdabot> Unknown command, try @list
08:16:31 <psnl> SimonRC: don't you have exams?
08:16:38 <SimonRC> psnl: yeah
08:16:51 * psnl thinks they aren't in haskell
08:16:58 <SimonRC> well yeah
08:17:33 <arcatan> yeah
08:17:35 <psnl> SimonRC: you bastard.
08:18:20 <psnl> SimonRC: your big exam isn't for weeks
08:23:52 <shapr> ptolomy: Can I see the lazy spiral code?
08:25:17 <ptolomy> shapr: It's a bit clunky, but sure.
08:25:25 <sjanssen> @quote
08:25:26 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
08:25:38 * ptolomy hpastes.
08:26:40 <hpaste>  ptolomy pasted "lazy spiral coords.. improvements?" at http://hpaste.org/1769
08:31:46 <dylan> both $a and $b are exempt from use strict vars.
08:32:09 <osfameron> because of a performance hack which is, as far as I can see, no longer valid
08:32:25 <dylan> also because of sort { $a <=> $b }
08:32:32 <osfameron> yeah, but you can do
08:32:40 <mauke> sort { $_[0] <=> $_[1] }
08:32:41 <osfameron> sort { $_[0] <=> $_[1] }
08:32:49 <osfameron> which has the advantage of NOT BEING INSANE
08:32:50 <dylan> that's more typing.
08:32:57 <mauke> haha
08:33:00 <osfameron> and working if the sub was defined in a different package
08:33:10 <osfameron> because of the magicness of $a and $b
08:33:12 <mauke> oh, that part works
08:33:49 <ari> YOW! What LANGUAGE is this?
08:33:49 <mauke> { package X; sub foo ($$) { $_[0] <=> $_[1] } } sort X::foo ... should run as expected. I think.
08:33:58 * osfameron kills $a and $b with extreme prejudice
08:34:13 <Mark__> :R
08:34:21 <Mark__> eww.... wrong terminal :(
08:34:26 <Wild_Cat> probably perl.
08:34:26 <ptolomy> shapr: Any suggestions for improvement to the spiraly thing?
08:34:34 <osfameron> yup perl
08:34:56 <ptolomy> .. in as much as you can improve code that exists without a real use-case, and as such has no real performance or design constraints.
08:35:10 <mauke> osfameron: but they're essential for http://home.cs.tum.edu/~mai/stuff/sigs/h9q+.pl
08:35:30 <osfameron> mauke: oh, well, yeah, anything's good for an obfu
08:35:34 <Mark__> Wild_Cat: i've got the lines thing working fine, but i'm now having problems mapping a read function on the list of strings.
08:35:58 <dcoutts_> nominolo: lazy bytestring hGetContents does close the file when you read the last chunk
08:36:07 <Wild_Cat> Mark__: huh?
08:36:53 <Mark__> Wild_Cat: remember earlier we was talking about my reading a list of tuples from file
08:38:05 <Wild_Cat> Mark__: (confused) Are you sure this was with me? I don't remember this...
08:38:35 <Mark__> you and shapr
08:38:59 <emu> ack perl
08:39:35 <Syzygy-> ?src iterate
08:39:35 <lambdabot> iterate f x =  x : iterate f (f x)
08:40:36 <Wild_Cat> Mark__: Damn, and my logging is turned off. Anyway, nevermind. What was the problem again?
08:40:58 <ptolomy> @pl double (x:xs) = x : x : double xs
08:40:59 <lambdabot> double = fix ((`ap` tail) . (. head) . liftM2 (.) (:) . flip ((.) . (:)))
08:41:23 <ptolomy> Hmm.. I think I like the non-pointfree version better..
08:41:31 <Wild_Cat> (the only productive things I recall doing here today are trying to split a \r\n-separated string, and cracking jokes about scientology)
08:41:39 <mauke> @pl \x -> x : x : []
08:41:40 <lambdabot> ap (:) return
08:41:48 <Wild_Cat> (which, of course, depends on your definition of "productive".)
08:42:00 <Mark__> Wild_Cat: basically i'm trying to load a list of tuples, (string, string, int) from a file. I've got now a list of strings which have the things i want to read into the tuple.
08:42:15 <mauke> @pl \x z -> x : x : z
08:42:16 <lambdabot> liftM2 (.) (:) (:)
08:42:46 <mauke> :t foldr (join (liftM2 (.)) (:)) []
08:42:55 <lambdabot> forall a. [a] -> [a]
08:42:57 <Mark__> Wild_Cat so i have a list:  ["abc def 1","ghi jkl 4" ... ]
08:43:20 <mauke> > (foldr (join (liftM2 (.)) (:)) []) "is this thing on?"
08:43:22 <lambdabot>  "iiss  tthhiiss  tthhiinngg  oonn??"
08:43:59 <quicksilver> mauke: cute :)
08:44:06 <Mark__> Wild_Cat: now i'm trying to return the list of tuples, after mapping a read function onto the list of strings
08:44:08 <sjanssen> > map (\xs -> case words xs of [s1, s2, n] -> (s1, s2, read n :: Int)) ["abc def 1","ghi jkl 4"]
08:44:10 <lambdabot>  [("abc","def",1),("ghi","jkl",4)]
08:45:53 <Mark__> :R
08:46:29 <ptolomy> @pl \v -> [v,v]
08:46:30 <lambdabot> ap (:) return
08:46:56 <Wild_Cat> Mark__: right. so your read function would be :: String -> (String, String, Int)?
08:47:00 <ptolomy> @pl map (\x -> [1..x])
08:47:00 <lambdabot> map (enumFromTo 1)
08:47:26 <quicksilver> :t [ (read a, read b,read c) | [a,b,c] <- map words l ]
08:47:29 <lambdabot> Not in scope: `l'
08:47:44 <quicksilver> :t [ (read a, read b,read c) | [a,b,c] <- map words ["abc def 1","ghi jkl 4"] ]
08:47:46 <lambdabot> forall a a1 a2. (Read a, Read a1, Read a2) => [(a, a1, a2)]
08:47:58 <quicksilver> Mark__: one approach is to use 'read' like that
08:48:09 <quicksilver> Mark__: and then annotate the list with the correct type
08:48:22 <quicksilver> which IIRC was something like [(Artist,Track,Int)]
08:49:19 <Mark__> hmmm... thanks... going to try it
08:54:22 <Mark__> ok, i'm almost there i think.
08:55:14 <Mark__> i think i'm missing a step with the annotate the list from IO (string, string, int) into [Sale]
08:58:01 <Mark__> yes, i'm getting:  IO[(a,b,c)] does not match [Sale]... .if this was C#, i'd have to cast from the type IO[(a,b,c)] into [Sale]
08:59:24 <mauke> that doesn't make sense
08:59:29 <mauke> an IO [...] is not a list
09:00:13 <Mark__> *is more confused*
09:00:30 <Wild_Cat> Mark__: you're lacking an accumulation loop, basically.
09:00:42 <mauke> an IO t is a data structure that describes how to perform some I/O that results in a value of type t
09:00:56 <mauke> it doesn't contain a t
09:01:19 <Wild_Cat> what you need is an IO [String] that reads the whole file (say, readFile), and then you apply your parsing function on the results.
09:01:50 <sioraiocht> this is why people shouldnt mess with monads on their first foray into haskell ;)
09:01:55 <Mark__> would the entire function i have atm help if i post it?
09:02:27 <Wild_Cat> much easier this way. Isolate the side effects so that they span as few lines as possible, and do most of your reasoning in happy fun pure world.
09:02:35 <Wild_Cat> perhaps.
09:05:14 <hpaste>  Mark__ pasted "loadData" at http://hpaste.org/1770
09:08:10 <quicksilver> Mark__: make the 'parsing part' a separate thing
09:08:23 <quicksilver> Mark__: make a function String -> [Sale] which does the parsing
09:08:42 <quicksilver> Mark__: loadData, however, can only ever have type IO [Sale]
09:09:01 <Wild_Cat> quicksilver: String -> Sale would probably be better.
09:09:33 <Wild_Cat> then a map or two to combine it into [String] -> [Sale]
09:10:25 <quicksilver> Wild_Cat: well, then he loses his pretty list comprehension
09:10:30 <quicksilver> Wild_Cat: *shrug*
09:11:46 <Mark__> not too worried about how the data is retrieved, as long as eventually i can return the [Sale]
09:11:52 <quicksilver> you can't
09:11:53 <quicksilver> not ever
09:11:57 <quicksilver> it's just not possible :P
09:12:04 <quicksilver> the type of that is IO [Sale]
09:12:11 <Wild_Cat> [parseSale line | line <- lines contents]
09:12:13 <quicksilver> this reflects the fact that IO was done, in order to create it
09:12:34 <ptolomy> @pl \(a,b) (c,d) -> (a+c, b+d)
09:12:35 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
09:13:04 <osfameron> that's just obfu
09:13:18 <mauke> @. unpl pl \(a,b) (c,d) -> (a+c, b+d)
09:13:19 <lambdabot> uncurry (\ ab f -> (\ p x -> ((,)) (ab + (fst p)) (f + x)) >>= \ ag -> snd >>= \ af -> return (ag af))
09:13:28 <mauke> this is SPARTA!
09:13:46 <hpaste>  ejt annotated "loadData" with "you can't escape the IO monad !" at http://hpaste.org/1770#a1
09:19:18 <emu> beschmi: did you take slime's code and M-% slime shim? =)
09:21:44 <Mark__> :r
09:22:05 <mauke> use : (it's shorter)
09:23:25 <Mark__> hehe, i forgetting to switch terminal windows in yakauke as i have irc on one, and hugs on another
09:36:52 <mainland> any profiler gurus here?
09:37:14 <mainland> who are also willing to answer some silly questions? :)
09:42:24 <Lemmih> mainland: Ask and you shall receive.
09:42:40 <Lunar^> Igloo: I started a rebuild of all Debian packages depending on ghc6 with the version you uploaded to haskell-unsafe
09:43:08 <quicksilver> ask and you might receive. Don't ask and I imagine you certainly won't.
09:43:21 <mainland> Lemmih: i've read the manual, compiled with -prof and -auto-all, but about 50% of my time is attributed to s single function that doesn't do any work itself
09:43:22 <Lunar^> Igloo: most of them will need a source upload because they explicitely depends on ghc6=6.6 (modulo binNMU)
09:43:38 <mainland> profile dump: http://www.apeiron.net/~mainland/dumbo.prof.txt
09:44:21 <Igloo> Lunar^: Right (a source upload is much less hassle than a binNMU on all arches anyway, plus I want to update to the versions of extralibs released with 6.6.1)
09:44:26 <mainland> runBench is the culprit, runs some stuff in (essentially) the ST monad
09:45:00 <Igloo> Lunar^: Is this on PPC?
09:45:02 <Lunar^> Igloo: I'm trying to build them after updating the build-depends to see if it's ok
09:45:06 <Lunar^> Igloo: amd64
09:45:16 <Igloo> Ah, OK
09:45:47 <Igloo> Lunar^: Thanks; let me know if anything unexpected happens  :-)
09:46:17 <Lunar^> Igloo: if we need to do new source upload for every new compiler version, I think it would really be better if all packages would be maintained in a collective repository
09:46:58 <Lunar^> Igloo: we'll need to wait for every individual maintainer to handle the transition, which is not optimal, IMHO
09:52:10 <joelr1> Lemmih: how long did it take you to write the S3 interface?
09:52:48 <joelr1> Lemmih: did you use any built-in haskell http client libraries or something in happs to issue requests and parse output
09:56:52 <Mark__> quicksilver: everything works now except for one thing..... (sorry to keep nagging)
09:57:11 <Mark__> it loads and saves files fine
09:58:03 <Mark__> however, after saving it outputs all the details to screen. i imagine due to mapM_ (putStrLn . show)sales
09:58:28 <ddarius> putStrLn . show = print
09:59:17 <ejt> just knock out that line if you don't want it, I just put it in to show that it had loaded correctly
09:59:30 <Mark__> but if i remove the mapM_ line, it replaces the whole file with the newly entered single entry
09:59:48 <ejt> paste your code again ?
09:59:54 <Mark__> sure, sec
10:02:19 <Lemmih> joelr1: About a week and I used a slightly changed version of Network.HTTP.
10:02:40 <joelr1> Lemmih: what did you need to change? why?
10:03:25 <Lemmih> joelr1: Network.HTTP doesn't support the 'DELETE' request method.
10:03:38 <hpaste>  Mark__ pasted "updating Sale record" at http://hpaste.org/1771
10:03:49 <Mark__> ejt: posted
10:03:49 <joelr1> Lemmih: ah, i see! did you make the patch available, by chance?
10:03:59 <ejt> Mark__: looking
10:04:09 <Mark__> coolio
10:04:31 <Lemmih> joelr1: I'm afraid not.
10:04:44 <joelr1> Lemmih: ok, thanks
10:05:01 <ejt> you are indeed just writing the new Sale to the file
10:05:31 <ejt> hmm, hang on
10:05:40 <Mark__> only if you remove the mapM_ line
10:05:54 <Mark__> otherwise it does exactly as needed, only it displays the old file before updating
10:06:32 <ddarius> It wouldn't, would it?
10:06:59 <ddarius> I think I know what's wrong.
10:07:13 <Mark__> yes?
10:07:26 <ejt> Mark__: I don't like recordSale
10:08:00 <Mark__> that does work. i've tested that with test data
10:08:01 <ejt> the way it takes the components of a Sale
10:08:15 <ejt> y, it's more the type signature I don't like ;)
10:08:33 <Mark__> hehe, that was given to us....
10:08:37 <ddarius> The file is being truncated by writeFile before it is being read by readFile.
10:08:51 <ddarius> Thus, you are reading in zero entries and then appending the new one.
10:09:04 <ddarius> Moral of the story: lazy IO is evil.
10:09:16 <ejt> blech
10:09:17 <emu> nooo
10:10:06 <ddarius> You something like mapM_ (liftM process getLine) instead of readFile >>= liftM process . lines
10:10:13 <Mark__> wait, you saying as i read the file in, it's removed from the actual file, then when i go to write to it, everything's already been removed. so it just goes ahead and writes the single new entry?
10:11:01 <ddarius> Mark__: I'm saying the file isn't even read from at all until after you open the file for writing, which presumably truncates the file upon invokation.
10:11:03 <ptolomy> Anyone know where I can find some examples of Data.Sequence use, particularly the View stuff?
10:11:44 <ddarius> Mark__: Put length contents `seq` writeFile ... and see if it works (without the mapM_)
10:11:48 <ejt> Mark_: to check you could write to a different file
10:11:48 <pitecus> what is the option for newtype deriving?
10:11:57 <mauke> -fglasgow-exts
10:12:18 <ejt> and if that works rename the files (that's arguable the right thing to do anyway)
10:12:23 <Mark__> ok, i'm gonna try and read from one file, and write to a new file... see what happens.
10:12:32 <pitecus> thanks
10:13:10 <ddarius> The right thing to do is not use lazy IO.  Other than some ACID property issues, which likely aren't that important, there's no reason not to overwrite the file.
10:13:29 <sjanssen> pitecus: you should probably use a LANGUAGE pragma
10:13:32 <ejt> if an error occurs you've trashed your database
10:13:45 <ddarius> Of course it would be best just to append to the file.
10:13:46 <pitecus> sjanssen, what would that look like?
10:13:58 <ddarius> ejt: "Other than some ACID property issues, which likely aren't that important,"
10:14:22 <ejt> sorry, didn't pick up on the ACID bit
10:14:28 <sjanssen> pitecus: {-# LANGUAGE GeneralizedNewtypeDeriving #-}
10:14:42 <mauke> where is LANGUAGE documented?
10:14:50 <sjanssen> pitecus: LANGUAGE pragmas are the way of the future, as far as I can tell
10:14:59 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html for a list of them
10:15:01 <lambdabot> http://tinyurl.com/2xjyqs
10:15:02 <pitecus> sjanssen, what if i also need -fimplicit-params?
10:15:29 <sjanssen> {-# LANGUAGE ImplicitParams #-}
10:15:34 <ddarius> pitecus: You don't need implicit parameters.
10:15:44 <sjanssen> ddarius++
10:15:47 <mauke> can you use multiple Extensions in the same LANGUAGE directive?
10:15:50 <pitecus> ddarius, i kind of like them
10:16:07 <ddarius> pitecus: I think they're going away, because you're the only one.
10:16:37 <pitecus> nobody ever told me whats wrong with them
10:17:28 <ddarius> Perhaps someone will today, but it's not going to be me, because I have to go.
10:17:33 <mauke> they're not as cool as passing parameters through the type system
10:17:36 <pitecus> cool
10:18:57 <sjanssen> pitecus: they make your code GHC dependent, when you could have used a portable Reader monad instead
10:19:29 <pitecus> sjanssen, Reader isnt that portable either afaiu
10:20:08 <pitecus> sjanssen,  Portability: non-portable (multi-param classes, functional dependencies)
10:20:37 <abz> how do you get the output string from System.system?
10:20:40 <pitecus> and implicit params have the advantage of being simpler to use
10:20:55 <mauke> abz: I don't think you can
10:21:05 <abz> so I have to redirect it into a file?
10:21:15 <abz> and then read the file?
10:21:24 <Mark__> ok, without the mapM_ function, it seems not to rebuild the entire list, only the last entry. hwoever with the mapM function it also outputs to screen the entire list beofre correctly updating it
10:21:57 <sjanssen> pitecus: Control.Monad.Reader is portable to all the compilers that matter right now (GHC and Hugs).  If you don't use the auto-magic overloading in Reader, your code would be 100% portable
10:22:34 <hpaste>  mauke pasted "tmp.hs" at http://hpaste.org/1772
10:22:38 <pitecus> sjanssen, it doesn't matter anyway, i'm never gonna use Hugs for anything
10:23:14 <mauke> abz: I use http://hpaste.org/1772 to read the output from a command (requires unix)
10:23:15 <sjanssen> pitecus: another downside to using implicit parameters is that #haskell will annoy you about them :)
10:23:25 <pitecus> Ya i noticed
10:23:44 <pitecus> sjanssen, Any real reasons to to use them you can think of?
10:23:49 <pitecus> not to use them
10:24:23 <sjanssen> I think they're hackish
10:24:29 <abz> mauke, thanks
10:24:51 <sjanssen> an extension that can be emulated just fine with a Reader
10:25:16 <pitecus> lots of things can be emulated with some other construct
10:26:13 <mauke> pitecus: possibly relevant thread: http://haskell.org/pipermail/haskell/2003-August/012412.html
10:26:14 <lambdabot> Title: Solution to the monomorphism restriction/implicit parameter problem
10:26:17 * ski kindof likes implicit parameters, too, for the record
10:27:37 <sjanssen> pitecus: right.  I just think the overhead (compiler support, more concepts to learn) outweigh the benefits (a couple less parameters to pass, or avoiding a Reader monad)
10:28:27 <pitecus> sjanssen, could be. The same could probably be said of lots of other GHC extensions
10:29:14 <ski> 'do'-syntax forces explicit sequencing of the code .. which seems overkill for things like Reader
10:29:40 <mauke> pitecus: see also http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf section 6.2
10:32:47 <Mark__> ejt: could you confirm for me that loadData is returning a list of Sale tuples. (ie all of them and not just the first) ?
10:37:27 <pitecus> mauke, that looks interesting, but im afraid to look at it, it ll probably cook my brain.
10:37:52 <mauke> it's not that complicated :-)
10:38:47 <ptolomy> does HGL currently work on windows?
10:58:59 <TantumLex> Epigram is pretty nifty.
11:03:00 <shapr> truly
11:16:28 <mdmkolbe|work> How many bit's is a Char?
11:17:15 <dmwit> > maxBound :: Char
11:17:17 <lambdabot>  '\1114111'
11:17:26 <dmwit> > logBase 2 1114111
11:17:28 <lambdabot>  20.087461546321563
11:17:39 <mdmkolbe|work> > 2^20
11:17:40 <dmwit> At least 21. ;-)
11:17:41 <lambdabot>  1048576
11:17:52 <mauke> 21, yay unicode
11:18:27 <dmwit> > 'a' + 'b'
11:18:28 <Saizan> 8 bit for IO
11:18:28 <lambdabot>   add an instance declaration for (Num Char)
11:18:28 <lambdabot>     In the expression: 'a' + 'b'...
11:19:06 <dmwit> > let cadd a b = chr (ord a + ord b) in cadd 'a' 'b' -- =(
11:19:07 <lambdabot>  '\195'
11:19:28 <dmwit> I decided not to abuse Char to store numbers.
11:19:30 <dmwit> =)
11:19:55 <mdmkolbe|work> > "Hello \x640000000000 World"
11:19:56 <lambdabot>  Character constant out of range
11:20:09 <mdmkolbe|work> > "Hello \x64000000000000000 World"
11:20:09 <lambdabot>  Character constant out of range
11:20:58 <mdmkolbe|work> > length "\x640000000000000000"
11:20:59 <lambdabot>  Character constant out of range
11:21:15 <mdmkolbe|work> I guess they fixed that already
11:33:20 <shapr> Is haskell-unsafe broken?
11:34:06 <arcatan> is there Data.Map equivalent to List.findIndex?
11:37:00 <mauke> well, there's a Data.Map.findIndex
11:39:22 <arcatan> yeah, but that's quite different. I guess I can just write it myself, though
11:39:48 <mauke> :t \f -> foldWithKey (\k a -> mplus (if f a then Just k else Nothing)) Nothing
11:39:51 <lambdabot> Not in scope: `foldWithKey'
11:40:35 <mauke> :t \f -> Data.Map.foldWithKey (\k a -> mplus (if f a then Just k else Nothing)) Nothing
11:40:38 <lambdabot> forall k a. (a -> Bool) -> Data.Map.Map k a -> Maybe k
11:42:07 <mauke> :t \f -> Data.Map.foldWithKey (\k a -> if f a then const (Just k) else id) Nothing
11:42:09 <lambdabot> forall k a. (a -> Bool) -> Data.Map.Map k a -> Maybe k
11:42:49 <arcatan> heh, thanks
11:43:25 <mauke> @pl \f -> foldWithKey (\k a -> if f a then const (Just k) else id) Nothing
11:43:26 <lambdabot> flip foldWithKey Nothing . flip flip id . (flip .) . (. (const . Just)) . flip . (if' .)
11:48:44 <Heffalump> 'lo
11:49:09 <joelr1> how well is ghc supported on newer versions of solaris?
11:49:45 <boegel> dcoutts_: how hard would it be to create an interactive 3D scatter plot program using Gtk2Hs ?
11:49:47 <MyCatVerbs> joelr1: pretty well, I think.
11:50:16 <joelr1> MyCatVerbs: how do you know?
11:50:51 <MyCatVerbs> joelr1: I think there's a -HEAD follower or two who build ghc regularly on a high-firepower SMP box, which I *think* was a Solaris box.
11:51:03 <MyCatVerbs> joelr1: ask in #ghc, they'll know better.
11:51:20 <joelr1> MyCatVerbs: thanks
11:51:37 <nominolo> > "\x3d"
11:51:46 <lambdabot>  "="
11:52:43 <dcoutts_> boegel: well you can use OpenGL with Gtk2Hs of course. As for the interactive bit, well it depends what kind of interaction you're looking for.
11:53:04 <dcoutts_> boegel: eg mapping mouse clicks back to points in 3D space is a bit tricky :-)
11:53:09 <MyCatVerbs> > putStr "Monad!"
11:53:11 <lambdabot>  <IO ()>
11:53:19 <dcoutts_> boegel: having lost a dimension and all
11:55:22 <mdmkolbe|work> Does the syntax "data Foo" declare a data type with no constructors or does it just declare that there is some datatype but we don't know what constructors it has?
11:55:33 <mauke> the former
11:56:27 <mdmkolbe|work> thx mauke
11:57:25 <DRMacIver> Hm. Is there any use to defining a type with no constructors?
11:57:35 <mauke> oh yes
11:57:43 <DRMacIver> Example?
11:57:45 <sjanssen> DRMacIver: it is sometimes handy when doing type-oriented programming
11:57:46 <mauke> type-level code
11:57:57 <mauke> (see also: oleg)
11:58:00 <DRMacIver> Heh
11:58:19 <DRMacIver> So in other words "No, unless you breathe monads and have an IQ of 620."? ;)
11:58:23 <sjanssen> data Succ n; data Zero; -- we know that _|_ is the only occupant of both of these types
11:59:33 <mauke> class Nat a where nat :: a -> Integer; instance Nat Zero where nat _ = 0; instance (Nat a) => Nat (Succ a) where nat _ = 1 + nat (undefined :: a)
12:00:00 <joelr1> shapr: ping
12:00:05 <Igloo> Does Christopher Kuklewicz IRC?
12:00:09 <boegel> dcoutts_: I would settle for buttons controlling the browsing through the space
12:00:17 <dcoutts_> boegel: sounds feasible
12:00:43 <DRMacIver> mauke: Ok, that's quite neat, but... err, what's the point? :)
12:00:47 <boegel> dcoutts_: I'll look into it.. maybe you'll have a nice set of screenshots sometime soon for your website ;-)
12:00:50 <dcoutts_> boegel: I made that lsystem stuff work nicely with opengl+gtk2hs
12:00:56 <dcoutts_> boegel: cool :-)
12:01:13 <boegel> dcoutts_: I was first planning to try it using a web-applet or something, but that seems hard (and slow)
12:01:20 <mauke> DRMacIver: see e.g. http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf  :-)
12:01:34 <dcoutts_> boegel: I should post new screenshots of the 3d lsystem stuff
12:01:52 <boegel> dcoutts_: yeah... did I get that code from you?
12:02:12 <dcoutts_> boegel: no, I got it from you! ;-)
12:02:33 <dcoutts_> boegel: remember? you ported a version from GLUT to Gtk2Hs
12:02:59 <shapr> Igloo: Yeah, he's TuringTest
12:03:03 <dcoutts_> boegel: I took that, and made it use a single window with an embeded OpenGL widget rather than two windows.
12:03:27 <dcoutts_> boegel: and recoded almost all of it and turned it into an undergrad programming practical. :-)
12:04:02 * dcoutts_ -> home
12:04:50 <DRMacIver> mauke: ... Ok, that's really cool. I'm convinced. :)
12:07:20 <Igloo> shapr: Ta
12:07:41 <joelr1> shapr: what do you think of my web app dilemma?
12:08:01 <DRMacIver> joelr1: What's your web app dilemma?
12:08:04 <boegel> dcoutts_: oh, right :-)
12:08:27 <joelr1> DRMacIver: check haskell-cafe
12:08:34 <boegel> dcoutts_: well, did I ever get the single window version then?
12:08:41 <joelr1> DRMacIver: the post is called Picking an architecture ...
12:09:18 <DRMacIver> Ah
12:13:13 <Cheery> @hoogle Maybe a -> Maybe a -> Maybe a
12:13:14 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
12:15:19 <mauke> mplus
12:16:13 <Cheery> > mplus (Just 1) (Just 2)
12:16:15 <lambdabot>  Just 1
12:16:20 <Cheery> > mplus (Just 1) (Nothing)
12:16:22 <lambdabot>  Just 1
12:16:32 <Cheery> > mplus (Nothing) (Just 2)
12:16:34 <lambdabot>  Just 2
12:16:39 <Cheery> > mplus (Nothing) (Nothing)
12:16:41 <lambdabot>  Nothing
12:16:44 <Cheery> correct behavior!
12:16:53 <Cheery> @hoogle mplus
12:16:54 <lambdabot> Control.Monad.mplus :: MonadPlus m => m a -> m a -> m a
12:19:14 <hpaste>  Cheery pasted "This makes me feel ridiculous. (further FRP laming)" at http://hpaste.org/1773
12:20:51 <Cheery> comment with will, I will yet implement 'until' and 'when' -combinators
12:21:44 <Cheery> if those are as ridiculously short, I start wondering what can I do with this thing. :)
12:22:18 <joelr1> how do you fetch stuff from hackage? regular download?
12:22:31 <Cheery> for instance yes
12:22:58 <emu> :t toDyn
12:23:00 <lambdabot> forall a. (Typeable a) => a -> Dynamic
12:23:08 <emu> > show $ toDyn 1
12:23:10 <lambdabot>  "<<Integer>>"
12:23:30 <Cheery> :t fromDyn
12:23:32 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
12:23:34 <emu> > dynApply (toDyn show) (toDyn 1)
12:23:35 <lambdabot>  Just <<[Char]>>
12:23:43 <Cheery> huh!!!
12:24:05 <Cheery> emu: how haskell marshalls data structures?
12:24:26 <emu> > fromJust . fromDynamic . fromJust $ dynApply (toDyn show) (toDyn 1)
12:24:27 <Cheery> ie. binary storage
12:24:28 <lambdabot>  Exception: Maybe.fromJust: Nothing
12:25:08 <emu> > fromDynamic . fromJust $ dynApply (toDyn show) (toDyn 1)
12:25:08 <Cheery> that thing is a sort of mutant from stream-architecture FRP and CPS -style
12:25:09 <lambdabot>  Nothing
12:25:19 <emu> argh
12:26:06 <emu> dynamic is kicking my ass
12:26:38 <emu> > fromJust $ dynApply (toDyn show) (toDyn 1)
12:26:40 <lambdabot>  <<[Char]>>
12:26:56 <dcoutts> boegel: I think the last version of your Haskls that I saw was using 2 windows.
12:27:03 <dolio> Specify a type for fromDynamic.
12:27:10 <dolio> It's defaulting to the wrong one, most likely.
12:27:21 <emu> > fromDyn "" . fromJust $ dynApply (toDyn show) (toDyn 1)
12:27:22 <lambdabot>  Couldn't match expected type `Dynamic'
12:27:36 <emu> > fromDyn (fromJust $ dynApply (toDyn show) (toDyn 1)) ""
12:27:37 <lambdabot>  "1"
12:32:02 <emu> still, writing a more general one results in fun type errors
12:32:44 <emu> i'm just looking to be able to obtain output like GHCi does, for arbitrary values
12:32:55 <emu> so i can show them
12:36:35 <boegel> dcoutts: yes I agree... but did I ever got your 1-window version?
12:36:56 <dcoutts> boegel: oh, no probably not.
12:37:32 <dcoutts> boegel: the practical code itsn't available since we don't want solutions poping up on the net.
12:37:49 <dcoutts> boegel: but I could probably extract a smaller demo that shows off the technique.
12:49:05 <boegel> dcoutts: ah, I see... nevermind then :-)
12:49:32 <dcoutts> boegel: if you want the code I can send it to you
12:49:33 <boegel> dcoutts: ah, so your assignment is probably the reason why HaskLS is getting a reasonable amount of hits
12:49:42 <dcoutts> boegel: heh heh
12:49:46 <boegel> dcoutts: if I get the code I'll throw it online, so don't ;-)
12:49:52 <dcoutts> hah, right'o
12:50:48 <boegel> dcoutts: I might ask you something in the near future about it... because the 3D-scatter plot tool I'm planning will probably also use HOpenGL
12:51:02 <dcoutts> boegel: ok, np
12:51:26 <dcoutts> boegel: bear in mind that I'm not it any way an expert on HOpenGL
12:51:55 <boegel> dcoutts: oh that's ok, my questions to you will be Gtk2Hs related, not HOpenGL
12:52:01 <dcoutts> ok good
13:00:16 <mdmkolbe|work> If someone were to write a DSEL for a build system (e.g. make, Jam, etc.).  What do people think would be the proper semantics when an intermediate file is missing?  E.g. foo.c -> foo.o; foo.o -> foo.exe where foo.c and foo.exe are up to date (i.e. matching timestamp/hash) but foo.o is missing.  A second case where this comes up is when lib.o -- ar --> liblib.a; liblib.a -- ranlib --> liblib.a.  In this case the running of ranlib
13:01:07 <olsner> "do what make does" ;-)
13:01:08 <Heffalump> I see no reason to build it.
13:01:18 <Heffalump> you got cut off at "the running of ranlib", btw.
13:01:23 <Heffalump> at least you seem to have
13:01:45 <mdmkolbe|work> ... In this case the running of ranlib will change the hash of liblib.a (i.e. the intermediate liblib.a is missing b/c it was replaced by the final liblib.a)
13:02:02 <olsner> lib.o -- ar+ranlib --> liblib.a avoids the second problem
13:03:26 <mdmkolbe|work> olsner: it would and a good rule designer would probably do that, but as DSEL designer one still has to think about such cases, b/c they might occationally come up
13:03:38 <joelr1> does anyone know where to get pfesetup?
13:03:41 <olsner> the beauty of make in this case is that it is the simplest possible recursive descent on the target dependencies
13:04:33 <olsner> but it's probably necessary to make it illegal for a target to have itself as a dependency (I guess make does this)
13:04:41 <Heffalump> oh, ick, intermdiate and final files the same?
13:05:30 <mdmkolbe|work> olsner, Heffalump: I've had stranger things happen in production systems with no easy way around it.  (Don't ask me the details though, I seem to have blacked that out of my memory.)
13:08:29 <mdmkolbe|work> olsner: yeah, the odd thing about make, is that if you want to beat it, you can't just make a "better" dependancy graph traverser.  I think that one would also need to make it significantly easier to use.  (E.g. 'make dist' would just know how to do it with out you telling it.)  That is a bit harder b/c we can't just throw a formal semantics at it.
13:08:51 <Heffalump> mdmkolbe|work: oh, sure. It's still ick :-)
13:09:10 <Heffalump> mdmkolbe|work: you could significantly improve on make just by making sane parametrisation mechanisms
13:09:23 <Heffalump> oh, and by embedding in a real programming language
13:10:00 <mdmkolbe|work> Heffalump: what kind of parameterization do you mean? functions?
13:10:03 <Heffalump> one of the good things make does is being a defacto standard for dependency generation (e.g. ghc -M)
13:10:20 <Heffalump> mdmkolbe|work: rules like "%.o: %.c"
13:10:41 <Heffalump> it's quite painful to do more complicated stuff than that, IME
13:11:09 <Heffalump> some stuff is possible and some stuff isn't, by a variety of different mechanisms that all have different dependency chasing rules
13:11:53 <olsner> sensible quoting, variables and functions could probably be improved, but otherwise, make is IMO a good model of compiling/building stuff - i.e. target, dependencies, commands
13:12:07 <Heffalump> yes, the basic model is good
13:12:18 <Heffalump> recursive make isn't
13:12:19 * dylan wrote a make replacement language.
13:12:21 <dcoutts> Heffalump: I think Cabal needs more make-like stuff: a combination of a dep graph traverser, a DSEL for the build actions (replacing make's use of sh) and a framework for generating the dep graph by dep chasing, suffix rules and more.
13:12:25 <shapr> @yow
13:12:25 <lambdabot> I smell like a wet reducing clinic on Columbus Day!
13:12:31 <shapr> dylan: Have you seen Maak in Haskell?
13:12:49 <dylan> shapr: nope. is it modeled like make?
13:12:49 <Heffalump> I still hate the fact that every language has its own dependency system, but I keep saying that :-)
13:13:04 <Heffalump> suffix rules?
13:13:05 <mdmkolbe|work> dylan: which one? aap? scons? Jam? cons? CMake? ...
13:13:15 <dcoutts> Heffalump: yeah, when non-recursive make works well it's great. With a built Gtk2Hs build tree it takes a faction of a sec to figure out that there's nothing to do.
13:13:20 <dcoutts> Heffalump: nothing else is that fast.
13:13:24 <dylan> mdmkolbe|work: eh, those are boring. ;)
13:13:41 <Heffalump> dcoutts: yeah, that's a huge advantage of make
13:13:41 <olsner> some kind of make-library system would be nice... i.e. 1) include "gcc+pch+dependency generation"-library, 2) GO
13:13:52 <dylan> my bake (not to be confused with a python system of the same name) had the slowest lexical variables ever.
13:13:57 <mdmkolbe|work> shapr: I've looked at Maak.  It looks nice, but IIRC it lacked support and only provided the most basic stuff
13:14:03 <Heffalump> olsner: yeah.
13:14:23 <Heffalump> proper compositionality, that's another thing a DSEL would bring to the party
13:14:30 <dylan> in addition to slow lexicals, it had first-class modules.
13:14:46 <dmwit> What's the E in DSEL?
13:14:50 <mdmkolbe|work> dylan: bake was your system?
13:14:53 <dcoutts> dmwit: embedded
13:15:04 <dylan> mdmkolbe|work: yeah. I abandoned it when I abandoned the ocaml language.
13:15:06 <nn-main> SamB, or SamB_XP You there
13:15:22 <dmwit> Hi nn-main!
13:15:24 <dylan> I learned ocaml while implementing bake, in fact. took about 6 months.
13:15:28 <nn-main> hi
13:16:02 <nn-main> lambdabot, darcs
13:16:08 <nn-main> ack
13:16:19 <mdmkolbe|work> dylan: was it embedded?
13:16:20 <kpreid> @where darcs
13:16:21 <lambdabot> http://darcs.net/
13:16:53 <nn-main> tell lamdabot to give its darcs address
13:17:02 <kpreid> @version
13:17:03 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
13:17:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:17:12 <nn-main> thanks
13:17:34 <dylan> mdmkolbe|work: it had an executable, but I intended to use it from ocaml too.
13:17:40 <olsner> @where Maak
13:17:41 <lambdabot> I know nothing about maak.
13:18:16 <nn-main> stetting up lamdabot for "nets" irc which is hosted on filebin.info at the moment
13:18:34 <emu> is there a way to redirect stdout to a string?
13:18:49 <Cheery> @hoogle maybe
13:18:50 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
13:18:51 <lambdabot> Maybe :: module
13:18:51 <lambdabot> Prelude.Maybe :: data Maybe a
13:19:17 <dylan> yech, my syntax looks so weird after all these months... http://svn.gna.org/viewcvs/bake/trunk/example/build/Recipe?rev=185&view=markup
13:19:21 <lambdabot> Title: SVN Repositories at Gna! - markup - bake: trunk/example/build/Recipe, http://tinyurl.com/27g55p
13:20:09 <dmwit> emu: From within Haskell, you mean?
13:20:17 <Cheery> maybe 1 id (Just 2)
13:20:19 <Cheery> > maybe 1 id (Just 2)
13:20:21 <lambdabot>  2
13:20:22 <emu> yep
13:20:25 <Cheery> > maybe 1 id Nothing
13:20:26 <lambdabot>  1
13:20:30 <dmwit> > fromMaybe 1 (Just 2)
13:20:32 <lambdabot>  2
13:20:33 <dmwit> > fromMaybe 1 Nothing
13:20:35 <lambdabot>  1
13:20:49 <dmwit> emu: How are you launching it?
13:20:59 <nn-main> oh man ! ghc is going to take a while to gcc
13:21:13 <Cheery> this is sick dream:
13:21:16 <Cheery> till :: Reactive e a -> Discrete e a -> Reactive e a
13:21:17 <dmwit> nn-main: Use a precompiled version.
13:21:18 <Cheery> till = op (flip maybe id)
13:21:23 <nn-main> ** using gentoo
13:21:32 <emu> dmwit: i am just invoking some IO action and i want its output to go to a string
13:21:35 <dmwit> There's still a way to do it, but I don't know the right words to use.
13:21:38 <olsner> still, use a precompiled version :P
13:21:38 <dmwit> ^^nn-main
13:21:45 <kpreid> Cheery: flip maybe id == fromMaybe
13:21:52 <emu> how would the gentoo package compile ghc without first having ghc installed?
13:22:02 <emu> ghc is not written in C
13:22:28 <olsner> by first compiling ghc, of course
13:22:41 <emu> dmwit: someone has suggested functions in System.Posix.Process, but I'm not seeing how
13:22:43 <olsner> ghc: ghc\n\tbuild-ghc.sh
13:22:50 <dmwit> emu: I don't know.
13:22:55 <nn-main> ?? ghc was a binary for gentoo weard?????????
13:22:57 <mdmkolbe|work> dylan: the syntax looks about on par with Jam.  The biggest problem I see is that it uses too many ideas.  Most developers don't want to think to hard about what they're building (except when they do).  I think the challange is to pull a Larry Wall and "make the easy things easy, and the hard things possible".
13:23:15 <Cheery> kpreid: ok, this is even more weird
13:23:36 <olsner> but make already meets that goal
13:23:49 <dylan> mdmkolbe|work: well, that was the eventual idea. I wanted to just say CProgram(...) like scons.
13:24:42 <dylan> main reason I wrote bake was make's pattern rules didn't do what I expected.
13:24:44 <tapi> hum, i have a strange parse error with ghc...
13:24:47 <hpaste>  Tapi pasted "Parse error... ?!" at http://hpaste.org/1774
13:24:53 <dylan> e.g. %.o: %.c $(DEPENDS)...
13:24:58 <tapi> could someone take a look at that ?
13:25:16 <kpreid> tapi: "let pos = 1" needs to be either in a do block or "let pos = 1 in ..."
13:25:23 <tapi> ouch
13:25:30 <kpreid> tapi: what you're looking for is "let pos = if ... then 1 else p"
13:25:44 <mdmkolbe|work> dylan: yeah, except think something more file oriented would be better.  I.e. as developer I don't want to learn the systems particular names for built-in rules (e.g. CProgram); I want to say here's a bunch of source files, make a dll from them.
13:25:47 <kpreid> better yet, "let pos = min 1 p"
13:26:22 <tapi> well, that's not the real code, it only reproduces the error i had
13:26:23 <hpaste>  sjanssen annotated "Parse error... ?!" with "will compile" at http://hpaste.org/1774#a1
13:26:40 <nn-main> hpaste darcs
13:26:47 <nn-main> !hpaste darcs
13:26:53 <nn-main> ack?
13:26:55 <tapi> thx sjanssen ;)
13:27:04 <hpaste>  ari pasted "haskelldb installation woes" at http://hpaste.org/1775
13:27:14 <dmwit> nn-main: What are you looking for?
13:27:14 <araujo> hello
13:27:16 <mdmkolbe|work> @hpaste darcs
13:27:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:27:22 <sjanssen> nn-main: http://www.scannedinavian.com/~eric/hpaste/
13:27:33 <nn-main> k
13:27:35 <kpreid> sjanssen: I didn't know you could use guards in let...
13:27:37 <olsner> hmm, interesting, sort of a backwards make: have(main.c adf.c asdfsl.c) want(liblib.a) fix!
13:27:53 <kpreid> oh, of course
13:27:55 <Heffalump> olsner: isn't that what make does?
13:27:55 <nn-main> looking for bots to add to my irc and sight
13:27:58 <kpreid> same as let-function
13:28:09 <mdmkolbe|work> olsner: for the simple, things, it should be as simple as that
13:28:31 <olsner> Heffalump: yeah, but no ;-) [explaining...]
13:28:39 <Heffalump> araujo: to add hsplugins to the package list, edit the .cabal file
13:28:51 <araujo> Heffalump, yeah
13:28:52 <araujo> :-)
13:28:57 <Heffalump> from the message you just want "plugins"
13:29:17 <dylan> mdmkolbe|work: hmmm, yes.
13:29:19 <Heffalump> there ought to be a pretty obvious line to change
13:30:08 <Cheery> @hoogle (a -> b -> c) -> Maybe a -> b -> Maybe c
13:30:17 <nn-main> how do you program in haskell
13:30:17 <nn-main> it never made sence to me
13:30:22 <mdmkolbe|work> if *proerly* done, then from "have (main.c) want (liblib.a)", all the nice things like CFLAGS, clean, distclean, dist (make tarball of source), bindist should come automatically
13:30:32 <Heffalump> nn-main: step 1, learn Haskell. Step 2, write program.
13:30:32 <Cheery> huh
13:30:38 <Cheery> @hoogle (a -> b -> c) -> Maybe a -> b -> Maybe c
13:30:44 <lambdabot> No matches, try a more general search
13:30:44 <lambdabot> No matches, try a more general search
13:30:57 <mdmkolbe|work> s/proerly/properly/
13:30:57 <Cheery> @hoogle Maybe a -> b -> Maybe c
13:30:58 <ari> Heffalump: (look this way...) the build-depends line does contain plugins, and any other line in here does not seem "pretty obvious"
13:30:58 <lambdabot> No matches, try a more general search
13:30:59 <olsner> you could have rules like "a .a is built from a number of .o-files" and ".o-files are build from .c-files", and the gaps are filled in automagically.. if you wanted something special, you'd modify ".c -> .o" or "[.o] -> .a".. and dependency analysis like how a .c file depends on .h files should be handled by plugins or defaults in a sensible way
13:31:11 <Heffalump> ari: can you paste the .cabal file?
13:31:14 <Heffalump> no, wait
13:31:25 <kpreid> Cheery: \x f m -> fmap (f x) m might be close enough
13:31:34 <dmwit> ?hoogle (Monad m) => (a -> b -> c) -> m a -> b -> m c
13:31:35 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
13:31:40 <Heffalump> oh. perhaps you just need to unhide it with ghc-pkg, then
13:31:45 <mdmkolbe|work> @where nix
13:31:46 <lambdabot> I know nothing about nix.
13:31:51 <nn-main> um ? what packages use haskell
13:31:52 <Heffalump> ghc-pkg expose plugins
13:31:54 <mdmkolbe|work> @where+ nix http://nix.cs.uu.nl/
13:31:54 <kpreid> Cheery: some sort of use of fmap, at least
13:31:54 <lambdabot> Done.
13:31:58 <mdmkolbe|work> @where nix
13:31:58 <lambdabot> http://nix.cs.uu.nl/
13:32:09 <dmwit> :t fmap
13:32:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:32:33 <mdmkolbe|work> @where+ Maak http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
13:32:34 <lambdabot> Done.
13:32:34 <kpreid> see also liftM2, etc
13:32:38 <mdmkolbe|work> @where maak
13:32:38 <lambdabot> http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
13:32:51 <dmwit> :t \f m i -> fmap (flip f i) m
13:32:53 <lambdabot> forall a b c (f :: * -> *). (Functor f) => (a -> b -> c) -> f a -> b -> f c
13:33:15 <ari> Heffalump: No change
13:33:26 <dmwit> :t (>>=)
13:33:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:33:38 <nn-main> um ? why landabot have 1548 patches
13:33:46 <Heffalump> ari: ok, I dunno then. I don't really understand the whole package hiding/exposing business.
13:33:56 <Heffalump> nn-main: why not?
13:34:01 <Heffalump> people work quite hard on it
13:34:18 <nn-main> hu
13:34:18 <dmwit> :t \f m i -> liftM (flip f i) m
13:34:21 <lambdabot> forall a1 b c (m :: * -> *). (Monad m) => (a1 -> b -> c) -> m a1 -> b -> m c
13:34:28 <ari> I'm wondering if I should change hs-plugins instead and move that module to exposed-modules
13:34:35 <dmwit> liftM ~= fmap for Monads?
13:34:43 <Heffalump> ahhh.
13:34:43 <mdmkolbe|work> nn-main: did you mean "who"?
13:34:43 <kpreid> dmwit: exactly the same
13:34:50 <LoganCapaldo> @type ap zip tail
13:34:51 <Heffalump> right, it's a module hidden within hs-plugins, I see.
13:34:52 <lambdabot> forall a. [a] -> [(a, a)]
13:34:57 <mauke> map = fmap = liftM = (.)
13:34:58 <Heffalump> I think you have to, then.
13:35:04 <Heffalump> Or fix HaskellDB to read the right thing.
13:36:33 <joelr1> who's responsible for planet.haskell, again?
13:37:19 <sjanssen> joelr1: ibid
13:37:36 <joelr1> ibid: ping
13:38:04 <mdmkolbe|work> @who planet.haskell
13:38:05 <lambdabot> Maybe you meant: echo ghc show what wn
13:56:19 <Cheery> @hoogle Bool -> a -> Maybe a
13:56:20 <lambdabot> No matches, try a more general search
13:56:27 <Cheery> @hoogle a -> Bool -> Maybe a
13:56:28 <lambdabot> No matches, try a more general search
13:56:55 <LoganCapaldo> @djinn Bool -> a -> Maybe a
13:56:56 <lambdabot> f a b =
13:56:56 <lambdabot>     case a of
13:56:56 <lambdabot>     False -> Nothing
13:56:56 <lambdabot>     True -> Just b
13:57:18 <ejt_> amazing toy
13:58:14 <ejt_> why did it choose to map False to Nothing and not True ?
13:58:21 <ejt_> or was that luck
13:58:23 <ari> Right... now I'm wondering where I can find the documentation for what claims to be hs-plugins-0.9.10 on my system, because it certainly isn't http://www.cse.unsw.edu.au/~dons/hs-plugins/html/ . For instance, in what I have resolveObjs takes no arguments (it's of type IO ()), and loadFunction_ isn't exported at all...
13:58:49 <ari> (ref. System.Plugins.Load)
13:59:36 <DukeDave> Erm, where did that Bool -> a -> Maybe a function lambdabot just said come from?
13:59:49 <DukeDave> @type f
13:59:51 <lambdabot> Not in scope: `f'
14:00:03 <mauke> it came from @djinn
14:00:04 <ejt_> DukeDave: djinn inferred it from the type
14:00:12 <Cheery> I wonder when ppl starts using haskell for controlling aircrafts instead of that microsoft BOB
14:00:25 <olsner> BOB?
14:00:38 * DukeDave has never heard of djinn, but likes the look of it
14:01:07 <ejt_> http://lambda-the-ultimate.org/node/1178
14:01:10 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
14:01:14 <Cheery> olsner: or was it written 'Bob'?
14:02:21 <olsner> while learning haskell, the aircraft engineers' heads started exploding, and now the people they have left can only program Microsoft Bob
14:02:25 <DukeDave> @djinn a -> a
14:02:26 <lambdabot> f a = a
14:02:36 <DukeDave> @djinn [a] -> Int
14:02:37 <lambdabot> -- f cannot be realized.
14:02:41 <DukeDave> @djinn [a] -> Integer
14:02:41 <lambdabot> -- f cannot be realized.
14:03:01 <ejt_> @djinn [a] -> (a -> b) -> [b]
14:03:01 <lambdabot> -- f cannot be realized.
14:03:18 <mauke> @djinn a -> (a -> b) -> b
14:03:19 <lambdabot> f a b = b a
14:03:37 <DRMacIver> I'm confused as to why it can't realise ejt_'s one.
14:03:42 <ejt_> me too
14:03:49 <ejt_> it's only flip map
14:03:58 <mauke> because it can't destructure lists
14:03:58 <DRMacIver> Right
14:04:03 <DRMacIver> Ah, of course
14:04:04 <ejt_> oh
14:04:11 <nn-main> configure: /usr/bin/ghc-pkg
14:04:11 <nn-main> configure: Dependency base-any: using base-2.0
14:04:11 <nn-main> configure: Dependency unix-any: using unix-1.0
14:04:16 <nn-main> ??
14:04:39 <nn-main> how do i fix
14:05:02 <DukeDave> @djinn Integral b => [a] -> b
14:05:02 <lambdabot> Cannot parse command
14:05:23 <kpreid> nn-main: that doesn't look like an error
14:05:49 <nn-main> um ? Setup.hs: cannot satisfy dependency network-any
14:05:58 <olsner> Cheery: this isn't the bob you're referring to is it? http://en.wikipedia.org/wiki/Microsoft_Bob
14:06:00 <lambdabot> Title: Microsoft Bob - Wikipedia, the free encyclopedia
14:06:48 <nn-main> new be how do i fix
14:06:48 <Igloo> nn-main: Install the network package
14:06:53 <nn-main> how
14:06:59 <knobo> I have a problem understanding the simpel list let x = 1 : 2 : [ y + 1 | y <- tail x ]
14:07:13 <Igloo> nn-main: What OS?
14:07:16 <joelr1> darn, i need the Amazon S3 interface like... yesterday
14:07:18 <nn-main> debian
14:07:29 <Igloo> nn-main: apt-get install libghc6-network-dev
14:07:43 <Heffalump> joelr1: a Haskell one?
14:07:46 <ejt_> knobo: what part don't you understand ?
14:07:54 <knobo> if I do let n = tail x, and then head n, I get 2
14:08:09 <joelr1> Heffalump: by all means. then i could write a version of haskelldb for S3 and  run HOPE on on EC2
14:08:18 <Heffalump> joelr1: that'd be cool
14:08:28 <knobo> so from that I understand that y + 1 should give 3 all the time
14:08:33 <Heffalump> though wouldn't running a database on S3 be quite expensive in terms of requests?
14:08:44 <ejt_> y is drawn from tail x
14:08:48 <joelr1> Heffalump: lemmih wrote a library, part of HAppS but alex is not releasing it for now
14:09:01 <Heffalump> oh, so some HAppS development is private?
14:09:02 <joelr1> Heffalump: they are charging 1 cent per store op these days
14:09:09 <knobo> tail x should always return a list with the first elemen = 2
14:09:11 <geezusfreeek> knobo: in 1 : 2 : [ y + 1 | y <- tail x ], 2 : [ y + 1 | y <- tail x ] is the tail, and the head of that is 2
14:09:11 <joelr1> Heffalump: apparently /private/
14:09:13 <Heffalump> joelr1: 1c per request I thought
14:09:28 <Heffalump> from June anyway
14:09:39 <knobo> so it's the <- that does some magick
14:09:46 <joelr1> Heffalump: i need to refresh my memory. let me double-check. in any case, it should not be that much of a trouble for me
14:09:51 <knobo> If i just could understand how it does it.
14:09:52 <njbartlett> Heffalump: but isn't it free when accessed from EC3?
14:09:59 <njbartlett> Or even EC2, oops
14:10:00 <Heffalump> joelr1: I guess it depends if you are proposing to use it as a real DB or not.
14:10:03 <Heffalump> njbartlett: oh, right, yeah.
14:10:13 <ejt_> knobo: do you understand this:  [x | x <- [1..10]] ?
14:10:14 <joelr1> njbartlett: we need to settle this ... let me read the announcement
14:10:16 <Saizan> knobo: in that case is equivalent to map (+1) (tail x)
14:10:25 * Heffalump doesn't know much about EC2. Just been using S3 for some backups.
14:10:36 <knobo> ejt_: thanx I think that explains it
14:10:55 <knobo> It was in fact simple
14:11:11 <knobo> I was thinking iterating
14:11:19 <joelr1> njbartlett, Heffalump: i think it's 1 c for _any_ request
14:11:20 <knobo> but that would not work
14:11:20 <nn-main> what package Setup.hs: cannot satisfy dependency zlib-any
14:11:29 <joelr1> http://www.amazon.com/gp/browse.html?node=16427261
14:11:32 <lambdabot> Title: Amazon.com: Amazon S3, Amazon Simple Storage Service, Unlimited Online Storage:  ...
14:11:54 <Heffalump> joelr1: ah, yes, even from EC2. It's just transfer to/from EC2 that is free.
14:11:55 <ejt_> knobo: if you're not used to list comprehensions it's no wonder you're confused
14:12:13 <njbartlett> But it's 1c per 1000 requests, not per request
14:12:18 <nn-main> what package Setup.hs: cannot satisfy dependency zlib-any
14:12:23 <Cheery> olsner: yeh, and I was joking
14:12:40 <Heffalump> oh, that's rather better :-)
14:12:44 <Cheery> gn
14:12:54 <Saizan> nn-main: you ahve to install the package zlib, you can get it from here -> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.3
14:12:57 <lambdabot> http://tinyurl.com/ypj2uf
14:13:01 <Heffalump> and 1c/10000 GET requests
14:13:04 <joelr1> Heffalump: right. in my case i'll be storing blog posts from HOPE and customer transaction info. it's gonna be manageable
14:13:12 <joelr1> njbartlett: right you are
14:13:16 <Heffalump> joelr1: fair enough.
14:13:30 <Heffalump> it also doesn't really offer a relational interface, does it?
14:13:38 <joelr1> Heffalump: anyway, haskelldb has a flat driver. it seems reasonable to rewrite that into s3-driver
14:13:42 <Heffalump> (I'm still slightly struggling to see how haskelldb is a good fit)
14:13:45 <joelr1> Heffalump: flat-file driver that is
14:14:03 <joelr1> Heffalump: a flat file doesn't offer a relational interface either
14:14:06 <Heffalump> oh, I suppose you do need to store the DB _somewhere_
14:14:09 <Heffalump> right, fair enough
14:14:49 <joelr1> Heffalump: if you look at how the flat-file driver is implemented, they are doing relational ops in software. S3 is just a big hash table so i assume it can be made to work
14:15:10 <Heffalump> right - as long as it isn't hideously inefficient in requests
14:15:48 <SamB> speaking of relational databases, does anyone know of a good way to set up a kind of "relational wiki"?
14:17:43 <joelr1> Heffalump: right now i'm trying to figure out what to use to process the xml i retrieve. not sure if alexj will release S3 so i'm gearing up to roll m own
14:18:24 <joelr1> Heffalump: i know alex is planning to sell some sort of a service on top of amazon ec2 to ease deployment of haskell apps. i don't believe in such a service being successful myself.
14:19:02 <Heffalump> I guess if he is also providing HAppS expertise it might work
14:19:10 <Heffalump> so users don't need to be too Haskell-savvy
14:19:24 * DRMacIver suspects the market isn't there for it yet
14:19:43 <shapr> DRMacIver: You'd might be surprised..
14:19:46 <ari> Ah, right. In the end my HaskellDB woes were solved by installing hs-plugins-1.0-rc0.
14:19:57 <DRMacIver> shapr: I'd love it if I were. :)
14:20:54 <joelr1> Heffalump: the world of haskell users wanting to deploy web apps is too small. you further restrict them by deploying on amazon ec2 with its lack of database
14:21:19 <joelr1> Heffalump: this results in a business model that's not viable
14:21:29 <Heffalump> joelr1: that was why I was thinking the market could be expanded by not requiring much Haskell clue
14:21:35 <Saizan> well, HAppS is made to have your data "in memory"
14:21:39 <Heffalump> just offering HAppS as a platform for doing "cool stuff"
14:21:46 <njbartlett> joelr1: It's viable if you have very low expectations
14:21:55 <nn-main> um i got the tar but were do i put the folder so i dont get errs
14:21:55 <joelr1> Heffalump: how do you do that? you already have ruby for clueless people
14:22:01 <joelr1> clueless about haskell that is
14:22:14 <Heffalump> well, perhaps HAppS has advantages in usability terms, I dunno
14:22:25 <Heffalump> I think it's quite a cool idea, though I still don't understand how it scales in parallel
14:22:35 <nn-main> where do i put zlib
14:22:48 <joelr1> i looked at the code for hpaste and compared it to the hope code. i found the hope code to be easier to grasp
14:23:07 <Heffalump> hpaste is written in happs?
14:23:18 <joelr1> Heffalump: yep
14:23:21 <Saizan> nn-main: are you on windows? try something like C:/zlib , you have to compile it with cabal
14:23:31 <SamB> Saizan: no he isn't
14:23:54 <nn-main> ? debian what is canbell and ?? SamB
14:24:24 <nn-main> what do i where do i put the zlib dir
14:25:15 <DRMacIver> HAppS is among the many cool things I need to look at at some point.
14:25:28 <Saizan> ?where hope
14:25:29 <lambdabot> http://hope.bringert.net/
14:25:38 <nn-main> Saizan, if i used windows i woudn't be running my own ircd right now!
14:25:39 <joelr1> hope is a cms
14:25:46 <joelr1> which is awesome
14:25:50 <Saizan> oh
14:25:52 <SamB> nn-main: wherever you feel like
14:25:58 <DRMacIver> Intriguingly there's an internal server error on that page. :)
14:26:02 <SamB> nn-main: you have to compile it...
14:27:11 <SamB> also, nn-main, do you happen to know what pin I should use for the CS line to the MMC (SD) card?
14:27:31 <joelr1> DRMacIver: which page? the hope one? i was there a few hours ago
14:27:40 <DRMacIver> Yeah, the hope one.
14:27:51 <DRMacIver> FCGX_PutStr failed
14:27:59 <joelr1> DRMacIver: oops
14:28:20 <DRMacIver> It's good that Haskell's strong type system catches all reasonable bugs, isn't it? ;)
14:28:32 <joelr1> are there any examples of REST with haskell? and parsing resulting XML?
14:31:40 <nn-main> SamB, Talk in Nets irc
14:46:04 <njbartlett> joelr1: http://darcs.haskell.org/http/ I suppose... plus HXT
14:46:06 <lambdabot> Title: Index of /http
14:47:02 <joelr1> njbartlett: thanks. not HaXML?
14:48:34 <njbartlett> Nah. I tried HaXML for a while, found I preferred HXT, but can't recall now why!
14:50:39 <joelr1> njbartlett: interesting... both hope and happs use haxml seemingly
14:53:02 <njbartlett> joelr1: Well, it was just a personal thing. Looking back at the docs for HaXml, I'm reminded that because HXT is more general, I felt it was more flexible.
14:53:17 <njbartlett> Also being based on arrows it seemed to offer more powerful ways to combine stuff
14:53:25 <joelr1> njbartlett: right. thanks!
14:55:12 <ddarius> @docs
14:55:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:06:27 <joao> 3
15:10:00 <ddarius> 4 TH
15:14:44 <sorear> hello.
15:15:55 <sorear> @uptime
15:15:56 <lambdabot> uptime: 2d 20h 54m 51s, longest uptime: 13d 18h 36m 21s
15:15:58 <sorear> @seen
15:16:12 <sorear> @users
15:16:13 <lambdabot> Maximum users seen in #haskell: 336, currently: 302 (89.9%), active: 41 (13.6%)
15:24:37 <monochrom> Haxml is complete if you muck with the tree data structure yourself. I don't want to muck with the tree data structure myself.
15:26:45 <olsner> @src listM2
15:26:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:27:08 <monochrom> So, if you want to use the filters and never muck with the tree data structure, haxml's are like (Tree -> [Tree]) which is too restrictive. hxt's are like (a->[b]) more general. Furthermore hxt generalizes it further to (xmlarrow a b) so it can even allow state and IO.
15:27:13 <ddarius> @src liftM2
15:27:14 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:27:37 <olsner> aaah! thanks ;-)
15:27:50 <Daveman> Don't Dave me, HAL!
15:28:10 * Daveman grumbles
15:29:07 <monochrom> If you want to use haxml but also want to thread along a state or do some IO, you muck with the tree data structure yourself, and write your own code to traverse the tree, and add state and IO. When you are done, CONGRATULATIONS! You have re-implemented hxt.
15:30:57 <SamB> lambdabot's README seems to need updating...
15:31:30 <olsner> :type liftM2 (,)
15:31:39 <olsner> :t liftM2 (,)
15:31:45 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:31:51 <olsner> @type liftM2 (,)
15:31:54 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:32:09 <olsner> ?type liftM2 (,)
15:32:12 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:32:13 <SamB> @where binary
15:32:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
15:32:19 <olsner> :type liftM2 (,)
15:32:37 <mauke> all normal commands can be used with ? or @
15:32:46 <olsner> why are @, ? or : not the same?
15:32:50 <mauke>  :t is special-cased to invoke @type
15:33:17 <ddarius> And > is special cased to invoke @run
15:33:18 <mauke> and > behaves like @run
15:34:00 <olsner> mmkay
15:34:13 <ddarius> :k Maybe
15:34:15 <lambdabot> * -> *
15:34:32 <SamB> lambdabot++ is also special-cased
15:34:40 <SamB> @karma lambdabot
15:34:41 <lambdabot> lambdabot has a karma of 42
15:34:52 <mauke> @keal
15:34:53 <lambdabot> i have basically written a proof that shows an assumption is wrong
15:36:29 <olsner> hmm... "Talk like keal"
15:36:31 <olsner> @keal
15:36:32 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
15:36:49 <mauke> @keal
15:36:50 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
15:37:10 <nn-main> @lambdabot you are to complex
15:37:11 <lambdabot> Unknown command, try @list
15:37:28 <DukeDave> Hey gang, can someone remind me of the syntax for that "give components of data types names you can access them with" magic? :)
15:38:04 <olsner> write it in haskell syntax and it'll be fine :)
15:38:09 <monochrom> data Myself = { name :: String; age :: Int }
15:38:10 <nominolo> DukeDave: data Foo { bla :: Blub, bar :: Baz }
15:38:15 <monochrom> err
15:38:17 <DukeDave> Wow, cheers guys :D
15:38:21 <monochrom> data Myself = Mycon{ name :: String; age :: Int }
15:38:24 <lambdakjot> What is keal?
15:38:27 <nominolo> @quote stereo
15:38:27 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
15:38:51 <monochrom> yuck, ; should be ,
15:39:01 <DukeDave> Hehe, it does give the answers that rich & deep sound I keep coming back for :)
15:39:03 <nominolo> yo
15:39:09 <ddarius> @oldwiki UsingRecords
15:39:10 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
15:42:03 <sorear> lambdakjot: Keal was a schizo genius type who frequented here a couple years ago.  We had to ban him for his own good.
15:42:19 <nominolo> @keal
15:42:20 <lambdabot> doctor just give meds not fix prollem
15:42:44 <Cale> @keal
15:42:45 <lambdabot> perhaps i just genius and never tested
15:42:47 <Cale> @keal
15:42:47 <lambdabot> i want to invent white dye
15:42:49 <Cale> @keal
15:42:50 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
15:42:51 <nominolo> "for his own good"?
15:42:54 <Cale> @keal
15:42:54 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
15:43:01 <Cale> @keal
15:43:02 <lambdabot> bot seems useless
15:43:07 <Cale> @keal
15:43:07 <lambdabot> i use an 8088
15:50:56 <nominolo> @users
15:50:57 <lambdabot> Maximum users seen in #haskell: 336, currently: 299 (89.0%), active: 44 (14.7%)
15:51:18 <nominolo> @seen bringert
15:51:19 <lambdabot> I saw bringert leaving #haskell 16m 39s ago, and .
15:55:29 <_frederik_> has anyone any experience profiling C code which is linked with Haskell code? perhaps it would be better to compile an all-C program for profiling purposes. gcc says that i need to pass -p in both the compile and link stage for profiling
15:55:52 <_frederik_> or maybe i should be using valgrind... what should i use to profile c code?
15:58:19 <Saizan> instance (Epsilon e) => Epsilon (EpsDiv10 e) where eps x = eps x / 10  <-- in this code, the eps call in the definition, is still resolved for (EpsDiv10 e) right?
15:59:34 <sorear> I can't tell you without seeing the definition of Epsilon.
15:59:54 <Saizan> class Epsilon e where eps :: e -> Rational
16:00:06 <sorear> In that case, 'Yes'
16:00:49 <Saizan> mmh in fact oleg would have used Epsilon (EpsDiv10 e) where eps x = eps (undefined :: e) / 10
16:00:55 <ddarius> sorear: eps x = (eps x) / 10
16:01:17 <yumiko> _frederik_, try valgrind first
16:01:32 <yumiko> though gprof should get you what you want
16:02:15 <sorear> ddarius: why are you reminding me of this?
16:02:18 <ddarius> Surely if eps is called on the same variable it's using the same instance
16:02:51 <ddarius> Well I guess it might not be, nm.
16:03:06 <Saizan> it could be polymorphic in the return type
16:03:06 * ddarius is tired.
16:03:41 <kpreid> Saizan: perhaps you want eps (EpsDiv10 x) = eps x / 10 ? (assuming EpsDiv10 is also a data constructor)
16:07:03 <Saizan> kpreid: no, it's an abtract type
16:08:01 <davidL> why would GHC say "unrecognized option -R" ?
16:08:12 <_frederik_> yumiko: thanks
16:08:14 <sorear> davidL: context!
16:08:25 <davidL> sorear: what?
16:08:49 <_frederik_> yumiko: for gprof, what about needing to pass -p to the linker? i only give an object file to ghc... maybe i can tell ghc to pass -p to the linker
16:08:53 <davidL> sorear: has that ever happened to you when building X11-extras?
16:08:55 <dibblego> davidL, because the best answer is "GHC didn't recognize the option -R"
16:11:39 <davidL> but -R specifies the location of libraries
16:12:12 <mauke> it does?
16:12:21 <sorear> says who?
16:12:49 <davidL> cabal, apparantly
16:16:35 <davidL> actually, hsc2hs has the flag "-lflag=-R/usr/X11R6/lib" and therefore ghc-6.6 gets -R/usr/...
16:24:40 <sek> which is the function that generates all permutations of 2tuples of 2 sets?
16:24:51 <nominolo> davidL: some GHC functions need a special prefix
16:25:17 <nominolo> otoh, if it's supposed to work ...
16:25:43 <davidL> does hsc2hs have a darcs repository?
16:25:48 <mauke> > [(a, b) | a <- [1 .. 4], b <- ['a' .. 'c']]
16:25:50 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4,...
16:27:03 <nominolo> davidL: FWIW, some options need to be prefixed with -optdep
16:27:49 <sek> mauke, thanks
16:27:51 <davidL> nominolo: dcoutts sent a patch to fix what I believe is an error
16:28:07 <pitecus> anyone know how i can runProcess in a separate os thread?
16:28:19 <davidL> -lflags=-R/blah should be -lflags=-L/blah
16:28:25 <dcoutts> davidL: I did? :-) what was that?
16:28:47 <davidL> dcoutts: that's what I found when I searched google ;)
16:29:25 <davidL> dcoutts: http://osdir.com/ml/lang.haskell.cabal.devel/2006-07/msg00000.html
16:29:27 <nominolo> pitecus: forkIO >> runProcess  maybe?
16:29:28 <lambdabot> Title: darcs patch: Change flags passed to hsc2hs, http://tinyurl.com/2btzjd
16:29:37 <_frederik_> > (,) `liftM` [1..4] `ap` ['a'..'c']
16:29:39 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4,...
16:29:54 <nominolo> :t forkIO
16:29:57 <lambdabot> Not in scope: `forkIO'
16:30:03 <nominolo> @hoogle forkIO
16:30:04 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
16:30:31 <nominolo> ok, it's do { tid <- forkIO (runProcess ...); ... }
16:31:09 * nominolo `ap` bed
16:31:40 <davidL> ?src ap
16:31:40 <lambdabot> ap = liftM2 id
16:32:09 <pitecus> nominolo, that wont typecheck?
16:32:42 <nominolo> The Real World is a Monad!
16:32:43 <_frederik_> > (ap . ((,) `liftM`)) [1..4] ['a'..'c']
16:32:45 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4,...
16:33:19 <nominolo> :t runProcess
16:33:21 <lambdabot> Not in scope: `runProcess'
16:33:45 <Botje> > sequence [1..4] ['a'..'c']
16:33:46 <lambdabot> Terminated
16:33:51 <Botje> O_O
16:33:52 <nominolo> pitecus: forkIO (runProcess ...; return ())
16:34:24 <Botje> oh.
16:34:38 <nominolo> pitecus: s/;/>>/
16:34:53 <pitecus> nominolo, so you have to throw away the handle runProcess retruns..
16:35:38 <nominolo> well, I guess, what you want is runInteractiveProcess
16:36:33 <nominolo> or take a look at what's available: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
16:36:35 <lambdabot> http://tinyurl.com/lw4ug
16:37:37 <pitecus> well i would like the process to run on the second processor thats the point
16:38:25 <nominolo> it doesn't?
16:38:44 <pitecus> no
16:39:59 <Saizan> do you compile with -threaded and start your program with +RTS -N2 ?
16:40:31 <pitecus> actually no
16:40:39 <pitecus> Saizan, is that all thats needed?
16:40:47 <Saizan> youd' still need to forkIO, you can use a Chan to get the handler to the other thread
16:40:57 <nominolo> Saizan: that shouldn't effect the spawning of new _processes_
16:41:25 <Saizan> oh, right :D
16:41:39 <nominolo> but it's worth a try
16:42:08 <pitecus> How does that Chan thing work?
16:42:50 <Saizan> ?index Chan
16:42:50 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
16:43:04 <pitecus> cool thanks
16:43:09 <Saizan> it's message passing inside your process
16:49:12 <nominolo> pitecus: do { c <- newChan; forkIO (runProcess ... >>= writeChan c }; h <- readChan c }
16:49:41 <pitecus> nominolo, yep i figured it out. Thanks!
16:50:50 * ndm is writing a paper on Haskell for people who don't know Haskell
16:51:05 <ndm> its not easy!
16:51:24 <nominolo> what *do* they know?
16:51:51 <ndm> computer science degree
16:51:59 <sorear> ndm: hi!  I read the yds2007 paper, looks pretty cool
16:52:02 <ndm> i.e. nothing much
16:52:08 <pitecus> it compiles and runs but doesnt seem to be using the second cpu
16:52:10 * sorear rereads for commenting purposes
16:52:16 <ndm> sorear, cheers :) - can you think of any related work?
16:52:35 <ndm> i have genetic algorithms so far, and proof tools
16:52:37 <sjanssen> pitecus: compile with -threaded and run with +RTS -N 2?
16:52:57 <ndm> its still a few months away from due, i just want to pass it to some non-Haskell people first to get it checked out
16:53:10 <pitecus> sjanssen, i put this in my cabal file: ghc-options:     -threaded
16:53:16 <sorear> ndm: ISTR reading about a 3rd party Mac program that analyses mouse motions and automatically infered macros, dunno how sophisticated it was
16:53:43 <pitecus> sjanssen, and do run it with +RTS -N2
16:53:55 <nominolo> pitecus: are you sure you have enough busy processes?
16:54:01 <ndm> sorear, its academic, so only academic citations can be included really - programs that have actually implemented something are frowned upon
16:54:32 <sorear> ndm: ok, in the abstract: "This pattern is common" - what pattern?
16:54:34 <pitecus> nominolo, what do you mean?
16:54:42 <_frederik_> kcachegrind is awesome
16:54:44 <sorear> ndm: and how do you measure
16:54:47 <_frederik_> it is like a computer game
16:55:26 <nominolo> pitecus: CPUs are often only scheduled on the second CPU if the first one is busy.  So maybe one of you processes is blocked for some reason
16:55:54 <sorear> ndm: in Sec1.1 you have a bunch of refs to Sec0
16:55:59 <ndm> sorear, the results say how i got the 60% number, and the abstract is horrid - i'm still trying to figure out how to make it less disjointed
16:56:18 <ndm> sorear, those are present in the version sat in front of me - its still early days for the paper :)
16:56:46 <ndm> I realised that I don't say what Haskell is, so i have to add stuff like that in...
16:56:46 <pitecus> well with top I see each of the two processes taking up nearly 50% cpu
16:57:03 <sjanssen> pitecus: is your program in a paste somewhere?
16:57:31 <pitecus> sjanssen, wait
16:57:56 <sorear> ndm: I think you might do well for 3.1 with something like "An environment represents a possible part of the data type the code fragment could depend on, such as the whole thing, or the first alternative."
16:58:14 <hpaste>  pitecus pasted "forkIO" at http://hpaste.org/1776
16:58:19 <sorear> ndm: it's already there, but too far down - past my "I don't get this, *reread*" windo
16:58:27 <pitecus> sjanssen, ^^
16:58:38 <ndm> sorear, good point
16:59:45 <ndm> i found out today that the YDS, which i'm submitting this to, isn't an easy walk - but is actually intending to reject over half the submitted papers....
17:00:18 <ndm> which is annoying, but i still get a free meal even if i get rejected, and can bring a date (its free to all York students), which is handy
17:01:13 <sorear> ndm: in that case, let me say the writing style isn't very polished right now...
17:01:13 <ndm> sorear, definately - its a very early draft - one or two brain dumps in only
17:01:26 <ndm> after a few more brain dumps comes a polish
17:01:48 <mdmkolbe|home> @fuse \f -> any . map f
17:01:53 <lambdabot> Maybe you meant: flush free
17:02:01 <mdmkolbe|home> @type \f -> any . map f
17:02:03 <lambdabot>     Couldn't match expected type `a -> Bool'
17:02:03 <lambdabot>            against inferred type `[b]'
17:02:17 <sorear> mdmkolbe|home: you want just 'any'
17:02:20 <sorear> @type any
17:02:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:02:32 <mdmkolbe|home> thx sorear
17:02:33 <sorear> @type \f -> or . map f
17:02:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:02:42 <kpreid> @pl \f -> or . map f
17:02:43 <lambdabot> any
17:03:57 <mdmkolbe|home> @pl \f x y -> or . zipWith f x y
17:03:57 <lambdabot> (((or .) .) .) . zipWith
17:04:36 <mdmkolbe|home> @pl \f x y -> and . zipWith f x y
17:04:37 <lambdabot> (((and .) .) .) . zipWith
17:06:33 <gravity> Are there any plans to add a plugin system to xmonad so it doesn't need to be rebuilt to be customized?
17:06:50 <sorear> gravity: let me find the quote
17:07:03 <gravity> uh oh
17:07:38 <olsner> just run through ghci?
17:07:49 <sorear> ./07.03.17-17:02:23 <sorear> dons: now what was I saying about hs-plugins dynamicity? :p
17:07:49 <sorear> ./07.03.17:17:02:44 <dons> sorear: don't come at me with that bloatware
17:08:03 <mdmkolbe|home> I think Haskell would need an improved dynamic loading system first.  (I don't even know if it even has one right now.)
17:08:30 <gravity> I thought dons had implemented a dynamic loading system of sorts for yi, but I never actually looked for it
17:08:43 <sorear> gravity: he did.
17:08:48 <gravity> mdmkolbe|home: I'd like to see that
17:08:55 <sorear> gravity: and now he considers it too much code for xmonad
17:09:00 <gravity> Ah, ok
17:09:10 <sorear> gravity: even though it's just 'import System.Eval.Haskell'
17:09:44 <MyCatVerbs> sorear: that's still 0.25% of his code budget, y'know.
17:09:58 <mdmkolbe|home> sorear: how did the dynamic loading interact with the type system?
17:10:12 <sorear> mdmkolbe|home: It doesn't
17:11:17 <olsner> is dons now in seclusion working on that shell, or where did he go?
17:11:57 <gravity> Cool, hs-plugins looks pretty hot
17:12:52 <mdmkolbe|home> sorear: there are so many applications where a good solution to dynamic loading would be so nice, it's a pity no one has step up to the plate
17:13:17 <mdmkolbe|home> (though since they'd likely be up against a 100MPH fast ball, I understand)
17:14:34 <ndm> olsner, he went to the beach on holiday
17:14:48 <olsner> haskell coders bathe!?
17:15:16 <sjanssen> gravity, sorear: note that hs-plugins doesn't have a release that works at all on 6.6.  That's one big stumbling block
17:16:13 <sjanssen> gravity: I bet there's a clever way to do dynamic-ish loading with runghc
17:16:58 <gravity> Hrm
17:18:11 <mdmkolbe|home> sjanssen: what do you mean?  I thought runghc was just for #! tricks
17:20:11 <sjanssen> mdmkolbe|home: it's just a handy way to run Haskell code without compiling it
17:20:12 <Cale> mdmkolbe|home: hm?
17:20:32 <Cale> mdmkolbe|home: Isn't hs-plugins a good solution to dynamic loading?
17:20:44 <Cale> I haven't been following the conversation.
17:21:05 <mdmkolbe|home> sjanssen: so you mean like, GHCi could be used to do dynamic-ish stuff?
17:21:29 <Cale> mm, it's already been mentioned.
17:21:33 <sjanssen> well, not really
17:21:47 <sjanssen> more like fast restarting
17:23:00 <sorear> mdmkolbe|home: Why do you call hsplugins inadequate?
17:24:00 <Cale> The main problem with hs-plugins is that it's not built on top of the GHC API.
17:24:09 <mdmkolbe|home> sorear: I thought you said that hs-plugins doesn't interact with the type system.  By that did you mean, it's not a problem or it's so much of a problem that they avoid eachother entirely?
17:24:20 <mdmkolbe|home> (I interpreted it as the later)
17:24:47 <sorear> mdmkolbe|home: Both, really :(
17:25:03 <sorear> mdmkolbe|home: it's used with success by lambdabot though
17:25:26 <Cale> eval :: Typeable a => String -> [Import] -> IO (Maybe a)
17:25:43 <sorear> It's more of an issue with load.
17:26:01 <sorear> load :: FilePath -> Flags -> IO (Maybe a)
17:26:13 <sorear> notice the lack of a Typeable constraint
17:26:24 <mdmkolbe|home> sorear: why doesn't it have the Typeable?
17:26:46 <sorear> mdmkolbe|home: Because it doesn't check types
17:27:21 <mdmkolbe|home> Then what good it the 'Maybe a' over just a boolean?  (It's not even existential)
17:27:33 <mdmkolbe|home> s/it/is/
17:27:37 <Cale> Because the load might fail.
17:28:08 <Cale> er, hmm
17:28:19 <mdmkolbe|home> Cale: That could be indicated by a false return value
17:28:41 <Cale> the 'a' there is the type of the value which is loaded
17:28:48 <Cale> which presumably isn't checked
17:29:08 <Cale> (there's an evil cast going on somewhere :)
17:29:19 <olsner> so how's it work? something like this? let ld :: FilePath -> Flags -> IO (Maybe Int) = load in ld "aasdf" Flags
17:29:34 <sorear> yes
17:29:42 <mdmkolbe|home> Cale: yeah, I was reading it backwards.
17:30:25 <Saizan> but FilePath is a module, so you specify which value you want in the Flags?
17:31:09 <Saizan> or can you list the contents?
17:31:55 <Cale> load :: FilePath -> [FilePath] -> [PackageConf] -> Symbol -> IO (LoadStatus a)
17:32:27 <Cale> Or perhaps the document I'm reading is out of date, but the Symbol parameter is the one which specifies which symbol to load.
17:33:51 <Cale> dynload :: Typeable a => FilePath -> [FilePath] -> [PackageConf] -> Symbol -> IO (LoadStatus a)
17:33:56 <Cale> Perhaps this does more checking?
17:34:22 <Cale> Too bad dons isn't around
17:38:36 <DukeDave> Uh, is there any reasonable way to deal with "Recursive import dependency "
17:38:48 <DukeDave> My implementation kind of requires it :|
17:39:01 <mdmkolbe|home> DukeDave: have you tried hi-boot files?
17:39:07 <DukeDave> At least, it would make my life a lot easier :)
17:39:13 <sorear> Cale: It does the same amount of checking.
17:39:29 <sorear> mdmkolbe|home: manually creating .hi-boot files will make his life a nightmare
17:39:48 <sorear> mdmkolbe|home: .hs-boot files achieve the same effect, but are plain text
17:40:01 <DukeDave> Erk
17:40:17 <DukeDave> Does Hugs support them?
17:40:23 <sorear> Cale: load assumes the symbol has type 'a.  dynload assumes the symbol has type Dynamic.  Either way a segfault is possible.
17:40:33 <DukeDave> Because I like my develop in hugs approach :)
17:40:35 <sorear> DukeDave: Hugs doesn't support module recursion period.
17:40:40 <Cale> sorear: ah, okay
17:40:51 <DukeDave> sorear, okay, Thanks
17:41:26 <mdmkolbe|home> sorear: By segfault I assume you mean returns Nothing (or LoadFailed or what ever)
17:42:11 <sorear> mdmkolbe|home: By segfault I mean what I say.
17:42:22 <sorear> mdmkolbe|home: Segmentation violation.  Signal 11.
17:42:58 <sorear> mdmkolbe|home: Or, "This application has performed an illegal operation and will be shut down."
17:43:19 <SamB> sorear: are you certain that Dynload doesn't *check* the type?
17:43:21 <SamB> er.
17:43:24 <SamB> dynload
17:43:36 <mdmkolbe|home> sorear: Then I hope I missunderstood something else.  Were you saying that Dynload can cause your haskell program to segfault?
17:43:52 <sorear> SamB: I'm merely stating the documented behaviour.  I've never tried it.
17:43:55 <ndm> DukeDave, remove the recursion, saying GHC supports it is like saying C supports functional programming
17:43:58 <sorear> mdmkolbe|home: That's what I said
17:44:13 <ndm> DukeDave - general strategy, put the data type in a separate module, and then layer things that way
17:45:01 <SamB> ndm: at least GHC has a workaround for recursive modules
17:45:05 <sorear> If the value exported by the plugin is not of type Dynamic, dynload will crash -- this is a limitation of the existing Dynamic library, it can only type-check Dynamic values.
17:45:54 <sorear> that's from http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-2.html#node_sec_Temp_2
17:45:55 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules, http://tinyurl.com/278jwo
17:46:04 <ndm> SamB - Hugs has a workaround, use Hall-in-one - neither is a good answer
17:46:15 <ndm> JHC supports recursive modules properly
17:46:18 <mdmkolbe|home> scarry
17:46:25 <sphynx> @where lambdabot
17:46:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:48:19 <mdmkolbe|home> g'nite
17:51:37 <nn-main> ok got lamdabot working
17:51:54 <nn-main> ?
17:52:28 <nn-main> hi
17:52:35 <nn-main> @lamdabot
17:52:35 <lambdabot> Unknown command, try @list
17:52:44 <nn-main> @list
17:52:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:54:58 <sphynx> I'm trying to install zlib for building lambdabot, but it doesn't seem to work
17:55:37 <DukeDave> Lol, Hugs being amusing:
17:55:42 <sphynx> I've got zlib from darcs repository, then I've tried run ./Setup.hs configure
17:56:01 <DukeDave> ERROR "./RobotState.lhs":38 - Type error in application
17:56:01 <DukeDave> *** Expression     : addReading lastmap (last states)
17:56:01 <DukeDave> *** Term           : last states
17:56:01 <DukeDave> *** Type           : RobotState
17:56:01 <DukeDave> *** Does not match : RobotState
17:56:07 <sphynx> but nothing happens, it just waits from my input after this.
17:56:17 <sphynx> for my input *
17:56:37 <sphynx> what I'm doing wrong?
17:57:05 <DukeDave> Apparently my recursive import solution of "copy the code across" wasn't the smartest move :)
17:58:21 <ndm> DukeDave, put RobotState in a module of its own, that will break the import
17:58:34 <ndm> sphynx, runhaskell - not run
17:58:57 <nn-main> how do you tell lamdabot to do math
17:59:02 <DukeDave> Hey, that's not a bad idea ndm ;)
17:59:03 <dibblego> > 2 + 2
17:59:05 <lambdabot>  4
17:59:11 <nn-main> ok thanks
17:59:37 <QtPlatypus> > (*) 2 2
17:59:39 <lambdabot>  4
17:59:39 <sphynx> ndm, oh, I've ran simply ./Setup.hs, even without "run" before
17:59:49 <nn-main> didnt work in my irc??????????????//
18:00:32 <sphynx> ndm, but why some Seups.hs need to be ran with runhaskell and some can be ran simply "./Setup.hs"?
18:00:39 <olsner> you have to be in the same IRC as lambdabot for it to work?
18:02:18 <nn-main> olsner, you come and help me set it up!
18:02:27 <sorear> nn-main: what do you mean math?
18:03:04 <nn-main> well you can do math here but the bot in filebin.info #test wont same lamdabot
18:03:12 <nn-main> ??
18:03:37 <SamB_XP> he forgot the space after "> "
18:03:37 <nn-main> some one join and show me how to work the thing
18:03:40 <SamB_XP> er.
18:03:43 <SamB_XP> in "> "
18:04:29 <SamB_XP> when you say "> 1 * 1", it says...
18:04:32 <SamB_XP> <main-bot>      Failed to load interface for `Monad.Writer':
18:04:32 <SamB_XP> <main-bot>       Use -v to see a list ...
18:05:05 <nn-main> SamB_XP, well how do i fix
18:07:04 <SamB_XP> sorear: any clue?
18:07:06 <dmwit> Install mtl?
18:07:37 <SamB_XP> nn-main: you already installed libghc6-mtl, didn't you?
18:08:16 <ndm> sphynx: some have #! lines in, some don't
18:08:24 <dmwit> You can check by looking for it in "ghc-pkg list".
18:09:14 <sphynx> ndm, Ok, I've understood
18:09:47 <SamB> nn-main: oh, you didn't install that?
18:09:54 <SamB> well go ahead and install it
18:10:48 <nn-main> SamB_XP, well that isnt real package
18:11:14 <SamB> true
18:11:23 <nn-main> SamB, libghc6-mtl-dev is installed
18:11:24 <SamB> libghc6-mtl-dev
18:16:59 <sphynx> hm, it seems that Setup.hs can't find zlib.h. But I can see it in my linux-headers
18:17:21 <sphynx> how can I specify where should it search for zlib.h?
18:17:45 <sorear> setup.hs shouldn't be looking for zlib.h
18:18:10 <sorear> lambdabot's setup.hs is looking for the haskell package named "zlib"
18:18:51 <sphynx> sorear, but I'm compiling zlib now
18:18:58 <sorear> zlib's setup.hs is spawning a configure script
18:19:06 <sorear> that would look for zlib.h
18:19:18 <sphynx> yeah, I've ran configure
18:19:36 <sorear> you're not supposed to manually run configure
18:20:07 <sphynx> sorear, hm, I'm a bit confused.
18:20:21 <LoganCapaldo> unsafeRunConfigure
18:20:27 <sphynx> sorear, I've got from darcs repo two projects - lambdabot and zlib
18:20:41 <LoganCapaldo>  Clearly the build system isn't strongly typed enough
18:20:53 <sorear> LoganCapaldo: uselessRunConfigure, actually.  It's perfectly safe
18:20:53 <sphynx> sorear, what should I do next?
18:21:00 <sorear> no clue.
18:21:20 <sphynx> sorear, :)
18:21:39 <sphynx> it seems building of zlib is hard thing
18:21:52 <sphynx> ok, I'll try again
18:22:29 <sphynx> but how are you building lambdabot anyway?
18:22:51 <sphynx> sphynx@behexen:~/haskell/zlib$ runhaskell ./Setup.hs build
18:22:51 <sphynx> Setup.hs: error reading ./.setup-config; run "setup configure" command?
18:26:21 <sorear> sphynx: you need to run configure first
18:26:32 <dibblego> Haskell is to QuickCheck as Clean is to ?
18:26:38 <Sgeo> Will my pun be added to the humor page?
18:26:42 <sorear> sphynx: I just used a normal cabal install to build zlib.
18:26:55 <Sgeo> Or is it too lame, or too soon, or is it a bit silly for me to ask, or what?
18:27:12 <sphynx> sorear, yeah, but previously you said "you're not supposed to manually run configure"
18:27:28 <sorear> sphynx: Oh, sorry, I wasn't clear enough.
18:27:35 <sphynx> sorear, and certainly I was running configure :)
18:27:38 <sorear> sphynx: You should run './Setup.lhs configure'
18:27:47 <sorear> sphynx: You shouldn't run './configure'
18:28:01 <sorear> sphynx: the first runs the second for you automatically, if it exists
18:28:11 <sorear> sphynx: the first is cabal, the second is autoconf
18:28:36 <sphynx> sorear, yeah, I know this. But my first question was - I've ran configure (yeah, runhaskell ./Setup.hs configure) and after this when I'm building - I'm getting an error - "zlib.h not found"
18:29:15 <sphynx> I type "locate zlib.h" - it is placed in linuxheaders, as usually
18:29:55 <sphynx> and I am wondering - why "runhaskell ./Setup.hs build" can't find it...
18:30:26 <sphynx> sphynx@behexen:~/haskell/zlib$ runhaskell ./Setup.hs build
18:30:26 <sphynx> Preprocessing library zlib-0.3...
18:30:26 <sphynx> Stream.hsc:69:18:  error: zlib.h: No such file or directory
18:30:26 <sphynx> Stream.hsc: In function âmainâ:
18:34:37 <hpaste>  Sgeo pasted "repeating myself" at http://hpaste.org/1778
18:35:51 <newsham> dibblego: isnt clean similar enough tohaskell to easily port quickcheck?
18:35:55 <newsham> quickcheck's not very long
18:36:00 * Sgeo pokes
18:36:35 <dibblego> newsham, I was under the impression it had its own testing setup, that was better than QC (for reasons I have also forgotten)
18:36:48 <newsham> oh i have no idea.
18:38:03 <LoganCapaldo> Hey Sgeo's paste gives me idea. Wouldn't it be great if we had a "cunning existential deriving" to go along with the "cunning newtype deriving"?
18:38:18 <LoganCapaldo> oh wait
18:38:21 <LoganCapaldo> I'm dumb
18:38:25 <SamB> do we?
18:38:26 <genbie> Anyone knows if there are solution to the exercises contained in the book "The Haskell School of Expression" by Paul Hudak please?
18:38:54 * LoganCapaldo retracts previous statement before anyone points out how dumb he is
18:39:02 <Sgeo> LoganCapaldo, hms?
18:39:11 <SamB> genbie: hopefully there are
18:39:45 <sphynx> sorear, well, it seems that something is wrong with my linux headers. I'm investigating this question
18:40:06 <genbie> i hope so SamB! It's a great book, but I find some exercises really challengin.. I just finished chapter 5
18:40:22 <LoganCapaldo> Sgeo: I was thinking it would be cool if you could do data (Show a) => SH a = SH a deriving Show. but clearly you can already do that anyway
18:40:57 <LoganCapaldo> also your type isn't an existential anyway, is it?
18:43:32 <SamB> LoganCapaldo: but can you do it for existentials?
18:43:35 <nn-main> <main-bot>      Failed to load interface for `Monad.Writer':
18:43:35 <nn-main> <main-bot>       Use -v to see a list ...
18:43:36 <SamB> which that is not...
18:43:54 <nn-main> what is up with theat!
18:44:06 <nn-main> i need that function
18:47:58 <Cale> nn-main: perhaps the mtl package isn't installed?
18:48:08 <Cale> Also, shouldn't that be Control.Monad.Writer?
18:50:55 <wy> I'm trying epigram. It looks nice although I haven't figured out how to use it.
18:51:07 <nn-main> i installed it
18:51:23 <wy> nn-main: Does that mean you haven't used it?
18:51:59 <nn-main> ???wy what you mean and lamdabot wont recompile
18:52:09 <sphynx> sorear, yeah, I've done it. zlib is installed! :) I've just need to install package with dev-files for zlib library. Sorry for so many questions
18:52:54 <wy> I hope to find some epigram users here
18:53:22 <wy> I can't start using. It seems totally different from other languages.
18:54:28 <nn-main> @version
18:54:29 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
18:54:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:56:04 <Sgeo> epigram/
18:56:05 <Sgeo> ?
18:56:20 <LoganCapaldo> SamB: I have no idea
18:56:26 <LoganCapaldo> Maybe not
18:56:37 <wy> Sgeo: Yes. The language Epigram
18:57:30 <wy> It seem to have a two dimentional syntax
18:57:56 <sorear> So does haskell :)
18:58:40 <wy> sorear: But haskell doesn't have horizontal bars there
18:58:58 <dmwit> Ew, epigram looks gross.
19:00:23 <dmwit> Although having first-class types sounds interesting.
19:00:31 <wy> I think maybe they should use a graphical interface like mathematica, then use a one dimentional source language in the back end.
19:01:15 <dmwit> Yeah, that would make a lot more sense.
19:01:19 * Sgeo points bd_ to how functions can be instances of Show
19:01:23 <dmwit> They must have a real headache parsing that layout.
19:01:33 <bd_> Sgeo: Not /useful/ instances :)
19:01:40 <bd_> Though if you just want to derive Show I guess it's useful
19:02:03 <Sgeo> It's useful if you want to just be able to type in things like Just Right
19:02:20 <Sgeo> And see what shows up
19:02:59 <wy> Yes. I believe that parsing shouldn't be hard.
19:03:44 * Sgeo would have a real headache typing in code for that language
19:03:50 <bd_> :t Just Right
19:03:53 <lambdabot> forall b a. Maybe (b -> Either a b)
19:03:54 <bd_> :)
19:04:17 <Sgeo> @fact Goldilocks
19:04:18 <lambdabot> goldilocks: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:04:30 <bd_> @djinn Maybe (b -> Either a b)
19:04:31 <lambdabot> f = Nothing
19:04:34 <bd_> heh
19:04:54 <dolio> You wouldn't type it all in yourself. The editing environment is designed to give you help.
19:05:51 <Sgeo> Is the editing environment available for Linux?
19:06:11 <dolio> It's an editing mode in xemacs, I believe.
19:06:29 * Sgeo is mildly scared of Emacs
19:07:02 <wy> dolio: why XEmacs? I have been used to use Emacs.
19:09:07 <Sgeo> @src Right
19:09:08 <lambdabot> Source not found. Wrong!  You cheating scum!
19:09:14 <Sgeo> >.>
19:09:20 <Sgeo> @src (++)
19:09:20 <lambdabot> (++) []     ys = ys
19:09:20 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
19:09:59 <wy> Though I think neither of them are nice enough. We should develop another big editor which supports nice graphics.
19:10:24 <emu> extend Yi!
19:11:59 <dmwit> wy: Have you seen Vital?
19:12:06 <dmwit> I just saw it recently, it looks kind of neat.
19:13:20 <wy> dmwit: I searched "vital editor" and found Crisp
19:13:40 <dmwit> http://www.cs.kent.ac.uk/projects/vital/
19:13:41 <lambdabot> Title: Vital homepage
19:13:47 <dmwit> It's Haskell-specific.
19:15:17 <Procyon_> wy: I believe the new gnu emacs now in beta has nice graphics support, although I haven't checked it out.
19:15:24 <shapr> Has anyone tried to get cups to talk to a printer over usb?
19:15:32 <dmwit> yes
19:15:32 <thetallguy> ugh
19:15:33 <SamB> tried?
19:15:39 <SamB> what do you mean, tried?
19:15:49 <thetallguy> shapr: yes
19:15:51 <shapr> SamB: I mean, I can't get it to work for me.
19:15:59 <SamB> ... I don't know that I've ever tried the other way
19:16:15 <SamB> shapr: what seems to be the trouble
19:16:17 <Procyon_> shapr: You have hotplug, correct?
19:16:21 <dmwit> I just used gnome-cups-manager and everything magically worked, though, so I can't help you much.
19:16:24 <thetallguy> shapr: I'm using Debian roughly from 6 months ago and it didn't work
19:16:27 <SamB> do you have /dev/usb/lp0?
19:16:31 <wy> dmwit: It seems to be written in Java?
19:16:37 <dmwit> yep!
19:16:48 <shapr> I do have /dev/usb/lp0
19:17:03 <shapr> thetallguy: I'm using debian/unstable from right now, and cannot discover the problem.
19:17:20 <shapr> Procyon_: No, I don't have hotplug scripts installed.
19:17:29 <shapr> I do have udev though.
19:17:30 <thetallguy> shapr: I wish I could help, but it's still on my list of todo's
19:17:37 <thetallguy> hal
19:17:44 <thetallguy> presumably you have hal?
19:17:56 <thetallguy> and dbus
19:18:25 <Procyon_> shapr: and it shows up under lsusb?
19:18:37 <shapr> Yup, I have hal and dbus.
19:18:50 <shapr> Procyon_: Bus 001 Device 002: ID 04f9:000d Brother Industries, Ltd HL-1440 Laser Printer
19:21:02 <Procyon_> shapr: Well, your machine is detecting it... and, um, that's about the extent of my cups knowledge... It always "just works" for me after my basic drivers are detecting it.
19:21:14 <wy> dmwit: Good. I'm running it.
19:22:18 * shapr wonders
19:23:30 <wy> It's really cool!
19:25:00 <wy> Why is it related with Haskell while it's written in Java? Can Haskell be compiled into Java classes?
19:25:19 <shapr> wy: What's written in Java?
19:25:37 <wy> shapr: Vital editor
19:26:06 <dmead> wy: theres an experimental translator that lets you go haskell -> java
19:26:10 <shapr> oh
19:26:19 <shapr> What about Pivotal, the sequel to Vital?
19:26:31 <sjanssen> wy: Vital is a Haskell interpreter
19:27:03 <wy> sjanssen: really? written in Java?
19:27:20 <sjanssen> wy: yeah
19:27:31 <sjanssen> maybe just a subset of Haskell, I haven't looked at it closely
19:28:35 <wy> shapr: Where is Pivotal?
19:29:26 <shapr> @go pivotal haskell
19:29:29 <lambdabot> http://www.cs.kent.ac.uk/projects/pivotal/
19:29:29 <lambdabot> Title: Pivotal home page
19:36:49 <wy> shapr: Got it.
19:37:14 <wy> ghc.exe: unknown package: plugins
19:38:57 <yome> Anybody has a fun Haskell book to recommend?
19:39:04 <dibblego> ?where yaht
19:39:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:39:07 <shapr> yome: Haskell Road to Logic and Maths?
19:39:08 <dibblego> yome ^^
19:39:09 <dmead> haskell.org/tutorial
19:39:12 <dmead> is also good
19:39:33 <Procyon_> I'm partial to "The Haskell school of Expression"
19:40:41 <yome> OK thanks, looking into those right now...
19:41:27 <monochrom> "fun with programming"
19:42:37 <yome> monochrom, http://web.comlab.ox.ac.uk/oucl/publications/books/fop/ ?
19:42:39 <lambdabot> Title: The Fun of Programming
19:42:50 <monochrom> yeah
19:44:43 <yome> Is there a dead-tree version of yaht that I could order online?
19:45:03 <Cale> yome: No, also, it's not exactly finished.
19:45:18 <Cale> (You'll notice there are some empty chapters.)
19:45:39 <Cale> But there is Graham Hutton's book which is apparently good for the beginner stuff.
19:46:09 <yome> I have some limited experience with Haskell, but I suppose a beginner book would still be appropriate...
19:47:07 <Cale> I never really got into any of the dead-tree Haskell books when I was learning it.
19:47:18 <wy> monochrom: That looks like a good book
19:48:46 <wy> I wonder if all the extensions to haskell can be compiled in windows? Currently I have problem with hs-plugins
19:56:09 <Cale> iirc, it's possible to get hs-plugins working under windows, but it might be tricky.
19:56:59 <Cale> I don't run windows, so I'm not sure. Maybe it needs mingw or something?
19:57:18 <sioraiocht> I'm doing this huge project in C# that i have to finish by midnight tomorrow, I just wanted to let you all know I MISS HASKELL
20:00:54 <dmwit> awww
20:00:57 <dmwit> it misses you too
20:17:38 <wy> dmwit: I'm done with the experiments with vital and pivotal.
20:18:08 <dmwit> conclusion?
20:18:33 <wy> dmwit: I can't compile pivotal, so I only tried vital.
20:19:57 <wy> It's interesting to create something like that although it can't be put into serious use
20:38:45 <wy> I finally found the true manual for epigram
20:40:14 <dino-> I noticed that the Wikipedia page for Xmonad was not referenced in the list of tiling wm's in Wikipedia's 'X window manager' page. I corrected this: http://en.wikipedia.org/wiki/X_window_manager#Tiling_window_managers
20:40:17 <lambdabot> http://tinyurl.com/wcqom
20:41:32 <dino-> Hm. I see it's in the list of 'Other X window managers' though. Wonder if it should be removed from there.
20:41:37 <yome> Quick question: how good is Vim's support for Haskell?
20:41:49 <dmwit> Very good.
20:41:52 <dmwit> Especially with this:
20:41:57 <dino-> yome: I have best results with non-literal files. Very good results actually.
20:42:02 <dmwit> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
20:42:04 <lambdabot> Title: Haskell mode for Vim
20:42:14 <yome> dmwit, thanks!
20:57:48 <wy> dmwit: epigram seems to have good idea about editing
21:12:05 <hpaste>  Bradly annotated "(no title)" with "Conner" at http://hpaste.org/1431#a2
21:16:45 <wy> Anyone used proof systems?
21:19:23 <Korollary> I played with Coq briefly. Stop snickering.
21:21:42 <Sgeo> @hoogle Integer -> Float
21:21:43 <lambdabot> No matches, try a more general search
21:21:56 <Sgeo> @hoogle (Num a) => a -> Float
21:21:57 <lambdabot> No matches, try a more general search
21:22:03 <cdsmith> Sgeo: fromInteger ??
21:22:13 <Sgeo> @ty fromInteger
21:22:15 <lambdabot> forall a. (Num a) => Integer -> a
21:22:20 <Sgeo> ty cdsmith
21:22:51 <wy> Korollary: Do you use it for math?
21:22:52 <dibblego> is there a way of emulating rank-2 polymorphism in languages without it (like Scala)?
21:23:28 <sorear> dibblego: Yes.
21:23:33 <Korollary> wy: I don't use it. But it is best suited for math.
21:23:36 <sorear> dibblego: Do you have type classes?
21:23:39 <dibblego> sorear, I've spent hours trying
21:23:46 <dibblego> sorear, I have a rough equivalent
21:23:46 * dmwit needs to learn what rank means
21:23:57 * cdsmith does, too.
21:24:01 <dibblego> sorear, I have something inspired by type-classes
21:24:05 <sorear> dibblego: Functional dependancies?
21:24:10 <sorear> dibblego: URL?
21:24:16 <dibblego> I'm lost now
21:24:37 <sorear> Uniform Resource Locator.
21:24:41 <wy> Korollary: Yes. I hope the mathematicians can use it to prove theorems, so that I don't need to spend a lot of time verify their truth
21:24:44 <dibblego> URL of what?
21:24:57 <sorear> dibblego: Scala's equivalent to type classes
21:24:57 <dibblego> of the description of type-class equivalent?
21:25:00 <dibblego> oh
21:25:01 <sorear> yea
21:25:16 <Korollary> wy: (Some) mathematicians already use it for proofs.
21:25:31 <dibblego> searching Scala docs is a bit of a pain, but they can be emulated with traits and implicit defs
21:26:12 <sorear> It also depends on how much static safety you want.
21:26:15 <dibblego> you could say trait X{def foo} then have a function that has an argument of type implicit def X, which would mean that an implementation of X must be within compiler scope
21:26:28 <sorear> Everything you can do with rank-2 you can do with Object.
21:26:32 <dibblego> all I want is to abstract the index and length functions of an array
21:26:55 <dibblego> http://www.scala-lang.org/intro/implicit.html
21:26:58 <lambdabot> Title: The Scala Programming Language: Implicit Parameters
21:27:08 <Korollary> Is there a #scala?
21:27:16 <dibblego> Korollary, yes
21:27:20 <Korollary> ah, you're already there
21:27:20 <sorear> Korollary: There is /who
21:27:29 <Korollary> sorear: I am lazy. Shocker eh?
21:28:01 <sorear> Sometimes I feel like such a freak.
21:28:11 <dibblego> the #scala people I've spoken to don't quite understand that you can emulate type-classes
21:28:18 <sorear> I go out of my way to read documentation before using a program!
21:28:27 <dibblego> the only person who understands that I know of is Martin Odersky, the creator himself
21:28:38 <dibblego> I'm sure some of his colleagues do too
21:28:46 <sorear> This is almost all of why I know more about GHC than almost everone else :(
21:29:09 <cdsmith> sorear: Yes, that is a bit freakish. ;)
21:29:18 <dibblego> my point is, asking in #haskell is likely to be more fruitful than asking in #scala :)
21:29:35 <dmwit> sorear: How do you have so much free time?  Don't you have an Internet connection?
21:29:40 <Korollary> sorear: Sometimes not everything is worth knowing.
21:29:43 <sorear> dibblego: You can generalize #scala to an arbitrary forum.
21:29:54 <dibblego> sorear, #haskell !! :)
21:30:09 <dibblego> sorear, really, I just think the clever people are too busy
21:30:39 <dan_> ack
21:30:43 <dan_> hey sorear
21:30:52 <sorear> hello dan.
21:30:54 <dan_> whats the "normal" mode called in emacs?
21:30:59 <sorear> Do I know you?
21:31:01 <dan_> for copy-paste
21:31:06 <sorear> fundamental-mode
21:31:10 <dan_> ah
21:31:13 <dmead> right
21:31:38 <sorear> hey dmead :)
21:31:44 <dmead> hi :P
21:31:58 <dmead> i got my predicate logic prover working
21:32:02 <sorear> hurray!
21:32:10 <dmead> but only with monadic predicates so far :<
21:32:18 <dmead> i haven't got to skolemization
21:33:41 <sorear> dmead: That sounds like a progress report.  I can guess monadic means unit-arity, but skolemization sounds like a necromancer ability :)
21:34:02 * sorear hasn't made much of a study of logic
21:34:04 <dmead> ah
21:34:17 <dmead> in this context monadic means single parameter
21:34:21 <dmead> hehe
21:34:40 <dmead> unifying stuff like Fxy
21:34:46 <dmead> as opposed to just Fx
21:34:53 <sorear> Aside from Not and Id, what monadic predicates are there?
21:35:04 <dmead> might require that y gets bound to a function
21:35:05 <sorear> dmead: How does that complicate thing?
21:35:09 <sorear> ah...
21:35:20 <sorear> (because of dependancy?)
21:35:25 <dmead> yep
21:35:35 <dmead> if an existential depends on a universal
21:35:39 <sorear> Yay, dependant type inference.
21:35:42 <sorear> Sounds fun.
21:35:48 <dmead> (x)(Ey)Fxy
21:36:00 <dmead> you have to instantiate y as f(x)
21:36:14 <dmead> which leads to undecidability
21:36:57 <dmead> and yea monadic is just singular variables
21:37:35 <dmead> but i guess by unit-arity you mean zero variables/parameters
21:37:52 <sorear> Actually unit = 1 i thought ;)
21:38:27 <sorear> I might have confused you because ML's dummy type also uses that name.
21:39:56 <Sgeo> What's #parrot ?
21:40:14 <sorear> Sgeo: /topic #parrot
21:40:21 <hpaste>  dibblego pasted "Can you do this?" at http://hpaste.org/1780
21:40:35 <Sgeo> * #parrot :There isn't a topic.
21:40:36 <sorear> IRC clients are so underutilized :)
21:41:01 <sorear> In that case I'm willing to bet #parrot is development for Parrot.
21:41:11 <Sgeo> Not only that, but lambdabot and myself are the only ones there
21:41:14 <sorear> Parrot is the codename of the project to rewrite Pugs in C.
21:41:14 <dmwit> But the only person there is lambdabot!
21:41:34 <jbauman> it's a small project
21:41:37 <jcreigh> sorear: heh
21:41:53 <dmwit> So what are Haskell's warts in your opinion?
21:41:58 <jcreigh> Parrot is the name of a project to write a VM suitable for dynamic languages, such as Perl6
21:41:59 <dmwit> I could only think of two that I'd run across.
21:42:02 <Sgeo> so, lambdabot left..
21:42:10 <jcreigh> dmwit: the record system's namespacing problems kind of annoy me.
21:42:12 <Cale_> dmwit: fail
21:42:14 <Sgeo> Why was the bot in there in the first place?
21:42:21 <dmwit> Ooo, record system is a good one.
21:42:29 <sorear> Sgeo: some idiot must have patched online.rc
21:42:33 <Cale> Lack of a real record system ;)
21:42:37 <Cale> hehe
21:42:38 <Sgeo> online.rc ?
21:43:06 <sorear> dmwit: Impossible to write a true interactive system for, record system, no first class modules, no user defined defining words, no standard split,
21:43:11 <Cale> Tied up with the existence of fail, is that do-notation could be translated in a better way
21:43:12 <sorear> Sgeo: one of lambdabot's config files
21:43:22 <sorear> Num is too big
21:43:26 <Cale> also ($) has the wrong associativity
21:43:33 <Cale> (and ($!) as well)
21:44:00 <dmwit> sorear: "no user defined defining words"?
21:44:12 <jcreigh> Monad isn't a subclass of Function...map isn't fmap...
21:44:12 <dmwit> ...and what do you mean by split?
21:44:17 <dmwit> Like Python's split?
21:44:21 <Cale> fmap, liftM, liftA, map, and (.) are all "the same thing"
21:44:23 <sorear> dmwit: You can define functions, but they can't define names.
21:44:25 <sorear> dmwit: yes.
21:44:30 <dmead> hey channel
21:44:35 <sorear> hey dmead
21:44:39 <dmead> is there a convention for including code in a technical report?
21:44:46 <dmead> or do you just like, link to it
21:44:49 <dmead> or use a staaaapler
21:44:56 <Sgeo> arrrrrrrrrrrrrrrrrrrrrrrrrrrrgggggggggh
21:45:01 <dmead> raaaaaaarrrarar
21:45:01 <sorear> Most people use an appendix.
21:45:04 * Sgeo should have gone to sleep
21:45:08 <sorear> Sgeo: mmmmeeeeoowww?
21:45:10 <dmead> oh right :)
21:45:11 <dmwit> Wait, (.) and fmap are the same?
21:45:12 <Sgeo> about 2 hours ago
21:45:16 <Cale> dmwit: yep
21:45:17 <jcreigh> dmwit: yeah
21:45:21 <dmead> :o
21:45:21 <Sgeo> I need to wake up at 6AM local time
21:45:22 <dmwit> Oh, (.) is a subset of fmap.
21:45:23 <Cale> dmwit: with the functor instance for ((->) e)
21:45:32 <dmwit> yeah
21:45:32 <jcreigh> > fmap (*2) (+5) 8
21:45:37 <lambdabot>  26
21:45:52 <sorear> typo of the day: ERC> /msg lambdabot op #haskell
21:46:06 <Cale> heh
21:46:09 <Sgeo> hm?
21:46:10 <dmwit> But, I mean, having multiple names for things is fine.
21:46:17 <dmwit> It helps convey to the reader which meaning is being used.
21:46:20 <Cale> Yeah, it's only slightly warty
21:46:30 <sorear> Sgeo: to temporarily kickban you.
21:46:34 <jcreigh> dmwit: sure, but fmap vs. map? Just silly.
21:46:37 <sorear> Sgeo: nice motivation :)
21:46:51 <Cale> I think we could get away with just map and (.), and have them both mean what fmap means now.
21:46:52 <Cale> whoa lag
21:47:11 <sorear> IRL people tend to trust me for no good reason, so I figured I'd probably been given ops already.  (I was wrong)
21:47:40 <dmwit> :t liftA
21:47:43 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
21:48:05 * Sgeo leaves
21:48:08 <Sgeo> byesall
21:48:12 <Cale> later
21:48:17 <sorear> @ignore + Sgeo
21:48:22 <Sgeo> ..?
21:48:28 <Cale> This wart is also tied up with the fact that Monad isn't a subclass of Functor
21:48:37 <dmwit> Yeah, I think that's odd.
21:48:41 <dibblego> 'tis in CAL :)
21:48:54 <dmwit> I'm not sure I'd put that at "wart" status though -- it doesn't really make code that much uglier in any way.
21:49:04 <sorear> Sgeo: Lambdabot won't listen until you sleep
21:49:09 <Cale> Which in turn is tied up with the fact that it's hard to refine chains of class dependencies.
21:49:11 <Sgeo> :D
21:49:56 <Cale> Well, really, that it's hard to work with fine-grained class hierarchies at all.
21:50:17 <dmwit> sorear: What would a first-class module system entail?
21:50:26 <dmwit> (What does it mean to "pass a module" to a function?)
21:50:27 <Cale> So we need something like Class Aliases
21:50:43 <sorear> dmwit: Modules parameterized by values and modules, at least.
21:50:55 <dmwit> ?
21:51:03 <sorear> dmwit: So you could pass Config as an argument to Operations
21:51:24 <sorear> dmwit: imagine the ML module system, but a little bit more powerful.
21:51:24 <dmwit> huh
21:51:31 <dmwit> Does any language have this?
21:51:31 <sorear> dmwit: Operations is a functor
21:51:40 <Sgeo> G'night
21:51:45 <Cale> A functor in not the Haskell sense of the word.
21:51:49 <sorear> SML has something close enough to count.
21:52:00 <sorear> isn't dmwit a ml user?
21:52:00 <sorear> @ignore - Sgeo
21:52:06 <dmwit> no
21:52:54 * dmwit googles SML module system
21:52:58 <Cale> Basically, when you import a module, imagine being able to pass it a module as a parameter, which it will in turn import things from for its own uses.
21:53:14 <Cale> and it'll export the results to you
21:53:16 <dmwit> This takes care of circular dependencies?
21:53:24 <dmwit> Oh, wait.
21:53:29 <dmwit> This makes some interesting things possible.
21:53:40 <dmwit> Like, multiple backends that you choose at compile-time.
21:53:44 <Philippa> right
21:54:02 <dmwit> That's kind of a neat idea.
21:54:08 <Philippa> I've found myself wanting an ML-style module system in haskell apps of ~1KLoC...
21:54:13 <Cale> Basically, you can imagine a module as just being a great big record data structure consisting of its exports, and this sort of parametrisation would make it a function on datastructures of that sort.
21:54:49 <Cale> I'd rather use the term 'module function' than 'functor', since the latter already has an established use in mathematics and computer science.
21:55:40 <Cale> Truly first class modules would make modules into values you could pass around. :)
21:56:09 <sorear> SML/NJ has truly first class modules.
21:56:28 <Cale> What's the type of a module in that system?
21:56:55 <Cale> (or a function which takes a module)
21:56:59 <sorear> Cale: Incorrect article.  Module functions are statically typechecked by reifying signatures as types.
21:57:15 <Cale> hmm
21:57:18 <Procyon_> Chessguy and I are building multiple, selectable backends for genetic programming (different representations, different primitive sets, different type systems)... first class modules would VASTLY simplify this kind of "passing in library configuration"
21:57:21 <wy> Scheme has true first class modules ;-)
21:57:25 <Cale> So they don't have some sort of row-polymorphism.
21:57:47 <Procyon_> wy: Scheme doesn't even have an agreement of what constitutes a module yet ;)
21:57:59 <sorear> scheme doesn't even have static types
21:58:01 <Philippa> normally there's an ordinary subtyping relationship on signiatures instead
21:58:07 <wy> Procyon_: I mean you can package things up if you want
21:58:10 <Procyon_> wy: But yeah, once they come to a concensus, they will have first class modules
21:58:15 <Heffalump> associated types get you quite close to first-class modules, don't they?
21:58:17 <sorear> there is a LOT of fun stuff you can do if you ignore types
21:58:24 <sorear> including fail at runtime!
21:58:37 <Cale> :)
21:58:56 <wy> In fact maybe failing at runtime is not that bad.
21:59:08 <Procyon_> I wonder if you could define an HM system in terms of syntax-case....
21:59:09 <Cale> Fail at runtime in stupid ways that make you wish that you'd just shot yourself in the foot instead.
21:59:50 <wy> I really like the interactive way of epigram!
22:01:24 <Procyon_> if you could define a type system in scheme macros, you could re-define the base primitives to be type safe variants... Type safe scheme in terms of scheme.
22:01:40 <wy> It seems that the system can infer a lot for you, including put a template for you if you input "case y", ...
22:02:53 <wy> Procyon_: I think it's possible to do this in Common Lisp but not Scheme. They really skrewed the macro up in Scheme.
22:03:37 <Procyon_> wy: not really.  Scheme macros are more powerful.  You can define def-macro in terms of syntax-case, but not vice-versa.
22:03:57 <Procyon_> wy: Scheme macros are a bit more hairy to get the hang of, but they can do more.
22:04:10 <hpaste>  dibblego annotated "Can you do this?" with "(no title)" at http://hpaste.org/1780#a1
22:04:26 <wy> Procyon_: How can they do more? defmacro is full power of lisp.
22:05:19 <wy> When I read R5RS, they only had syntax-rules, it seems.
22:07:48 <Procyon_> wy: I was writing, once upon a time, a scheme-compatibility layer (write code that runs on multiple distros).  writing defmacro is fairly trivial in systems that only define syntax-rules/syntax-case.  Going the other way forces you to redefine the entire language.  This was backed up by the Scheme big-wigs like dybvig.  The massive syntax-case.scm file that gambit-c distribute
22:08:08 <Procyon_> wy: is this reimplementation of the language to be able to support syntax-case.
22:09:12 <Procyon_> wy: I'm not sure of the underlying reason.. I just know it exists ;)
22:09:50 <wy> Procyon_: I guess there will be still endless modifications to these things, so I stopped using Scheme.
22:10:19 <hpaste>  dibblego annotated "Can you do this?" with "for sorear" at http://hpaste.org/1780#a2
22:11:04 <wy> I wonder if there can be a language that's "meta" enough so that you can get everything you want. I know ML is "meta language", but it's not as meta as its name.
22:11:07 <Procyon_> wy: Hopefully R6RS, which is supposed to be ratified very soon now, will bring the distros back together... at least the main ones.  It would be nice for chicken, gambit, plt and bigloo to be mostly compatible.
22:11:52 <sorear> dibblego: Your code is literally valid in a language without rank2 - namely Haskell 98
22:12:07 <sorear> dibblego: you didn't use rank2 at all in that paste
22:12:09 <Procyon_> wy: The main point of divergence is in the module systems... Once they agree on that, theres not much reason to be incompatible.
22:12:24 <dibblego> sorear, I keep thinking that, but then convince myself otherwise
22:12:38 <dibblego> sorear, the a b throws me
22:12:56 <wy> Procyon_: My idea is that just keep it small, as their inventor's original purpose.
22:13:11 <sorear> dibblego: a b has nothing to do with higher rank polymorphism.
22:13:30 <Procyon_> wy: I totally agree.. but I think modules are part of "small" that never got defined :(
22:13:40 <dibblego> sorear, I think I'm about to have a duh moment
22:13:58 <sorear> dibblego: I think you're confusing kinds and ranks.
22:14:10 <dibblego> indeed I think you're right
22:14:19 <sorear> 'a' is a higher kinded type variable
22:14:40 <wy> Procyon_: as small as can be used in SICP is enough ;-) You can write your own module system and OOP system. That's the purpose of teaching with Scheme.
22:15:08 <dibblego> sorear, ok, so how can I do that in Scala?
22:15:10 <Procyon_> wy: What I'd really like to see is only the 5 or 6 core forms defined, and then everything else defined as a standard prelude/library, with a reference implementation in terms of the core forms... the distros being free to optimize the standard library, but not deviate from it's functionality.
22:15:21 <sorear> dibblego: I don't know.  I never learned Scala.
22:16:03 <dibblego> sorear, Java?
22:16:27 <Procyon_> wy: That way you could write the core forms in an interpreter, and a load module function, import the standard prelude, and your off with your own implementation of scheme in just a few lines of code.
22:16:32 <sorear> dibblego: In Java you would specialize a to only hold objects of type Object, and use lots of casts.
22:16:41 <wy> Procyon_: Sometimes I'm wondering if the Lisp way is more fundamental. No types, just symbols. In a philosophical way, this is more fundamental. At the beginning, there is only symbols and meanings.
22:16:48 <dibblego> sorear, that's what I figured
22:16:56 <sorear> dibblego: that's the way the standard collections lib does it
22:17:15 <Procyon_> wy: more fundamental than scheme?
22:17:17 * sorear gave up on java in the 1.2 era
22:17:22 <dibblego> sorear, only at compile-time; it has parametric polymorphism
22:17:33 <wy> Procyon_: than functional languages with type systems.
22:17:36 <dibblego> sorear, List<T> is valid Java these days
22:18:00 <wy> dibblego: Have you heard of polyglot?
22:18:07 <dibblego> nup
22:18:08 <sorear> dibblego: If I hadn't heard the rumors I wouldn't have done the /me.
22:18:21 <sorear> dibblego: I have no interest in relearning java.
22:18:24 <wy> dibblego: It's a system that let's you modify Java as whatever you want.
22:18:30 <dibblego> sorear, fair enough
22:19:09 <Procyon_> wy: Oh.. totally.  Lisps are pretty much pure lambda calculus.  Adding a type system is a totally seperate layer to enforce constraints.  The lisps are WAY more fundamental than ML/Haskell.
22:19:10 <dibblego> I don't want to fix Java; I just want to express what I wrote in Haskell, but in Scala
22:19:42 <sorear> I'm sure if it was ever a condition of employment I could learn java in six hours (nothing but hits in my blub cache)
22:20:10 <Heffalump> wy: well, it's a Java frontend that does that
22:20:17 <dibblego> sorear, there is a lot of learning and internalisation of hyperbole as well; that is what gets you a job
22:20:50 <Heffalump> wy: IIRC it just produces "normal" Java at the end
22:21:11 <wy> Heffalump: You've used that?
22:21:16 <Heffalump> wy: yes
22:21:27 <hpaste>  dibblego annotated "Can you do this?" with "(no title)" at http://hpaste.org/1780#a3
22:21:31 <wy> Heffalump: How do you like it?
22:21:33 <Heffalump> well, I worked on a project that did. I didn't use it that much myself.
22:21:34 <Procyon_> wy: Writing a very core lisp subset is only a couple lines of code... writing a basic ML is substantially more work.
22:21:44 <Heffalump> not bad, a bit clunky and heavyweight, but it works
22:21:54 <Heffalump> (well, modulo being quite buggy)
22:22:20 <Heffalump> (it's the front end in abc: http://www.aspectbench.org )
22:22:25 <lambdabot> Title: abc: The AspectBench Compiler for AspectJ - Introduction
22:22:36 <Philippa> any language where the code is data isn't too close to being pure lambda calculus though
22:23:00 <wy> Heffalump: A student here is trying to rewrite it.
22:23:02 <Philippa> you can capture most of the dynamic aspects of haskell with a well-chosen calculus with let and case
22:23:37 <Heffalump> to do what?
22:23:52 <Procyon_> Philippa: But the static parts are a bit more hairy
22:24:07 <wy> Heffalump: rewrite polyglot in some more efficient way.
22:24:56 <wy> Heffalump: You did AspectJ?
22:25:04 <Philippa> Procyon_: sure, although Hindley-Milner itself isn't that bad
22:25:15 <Heffalump> wy: yes
22:25:28 <Heffalump> well, the abc compiler. Not the ajc one written by the AspectJ team.
22:25:46 <Procyon_> Philippa: The dynamic parts of lisp and haskell are pretty equivelent (with the exception of call-by-name vs call-by-value and lisp having mutable references)... either language is trivial to evaluate.
22:26:36 <Philippa> the differences between cond and case are fairly involved, no?
22:26:45 <Heffalump> anyway, got to run
22:26:49 <wy> Heffalump: Can you tell me about the difference of polyglot and the Lisp macro systems. My guess is that macros are just syntactic level transformation, but polyglot has semantics understanding. Anything more?
22:27:02 <Heffalump> wy: grab me this evening (UK time)
22:27:08 <Heffalump> or some othertime
22:27:12 <Heffalump> I'll miss my train otherwise
22:27:18 <wy> Heffalump: See you!
22:27:54 <Procyon_> Philippa: cond is fundamental.  Case is a macro.  if is also a macro.
22:27:56 <wy> @localtime Heffalump
22:27:58 <lambdabot> Local time for Heffalump is Thu May 10 06:27:20 2007
22:28:35 <ddarius> Procyon_: You could implement a polymorphic lambda calculus-ish thing in about as much code as a Lisp.
22:29:55 <kpreid> Procyon_: in what Lisp system? in Common Lisp, IF is a special form and COND is a macro.
22:30:02 <Procyon_> ddarius: agreed.  I'd say it's about 10 lines of haskell to do an evaluator for either one.
22:30:29 <Procyon_> kpreid: It's matter of taste.  Either one can be defined in terms of the other.
22:31:52 <kpreid> Right, so I object to your claim that cond is fundamental :-)
22:32:30 <Procyon_> kpreid: I concede.  I only said cond was fundamental in respect to case.  I threw if in there for good measure :)
22:33:04 <kpreid> anyway, I have nothing actually on-topic to say, so I'll go away now
22:33:10 <Procyon_> hehe
22:38:39 <Philippa> Procyon_: *Haskell* case is fundamental
22:39:06 <Philippa> you might implement it in terms of cond in lisp, but so what?
22:41:22 <Cale> Case is such a nice thing to make fundamental.
22:42:40 <SamB_XP> actually cond is trivially easy to do in Haskell...
22:43:43 <SamB_XP> ... not only can you do it with guards on a silly case, but you can also use lookup...
22:43:47 <SamB_XP> @type lookup
22:43:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:43:57 <Cale> I like doing cond with a new data structure for the condition/value pairs.
22:43:59 <SamB_XP> @type lookup True
22:44:01 <lambdabot> forall b. [(Bool, b)] -> Maybe b
22:44:04 <Procyon_> All of lisp is trivial to do in haskell :-)  I think the parser is the most difficult part.
22:44:19 <SamB_XP> cond = lookup True -- ;-P
22:44:35 <Cale> That is nice though :)
22:45:09 <Cale> data Guard a = Bool :-> a
22:45:17 <SamB_XP> oooh
22:45:25 <Cale> cond :: [Guard a] -> Maybe a
22:45:26 <SamB_XP> a smiley data constructor!
22:45:30 <Procyon_> lol
22:45:57 <Cale> or even just  cond' :: [Guard a] -> a
22:46:06 <Cale> if you want to live life dangerously
22:47:30 <monochrom> my "safe" combinator can convert dangerous cond' to safe cond.
22:47:49 <SamB_XP> how does it work?
22:47:50 <Cale> :)
22:47:58 <Cale> It cheats :)
22:48:02 <SamB_XP> ah.
22:48:04 <monochrom> unsafePerformIO, catch exception.
22:48:06 <SamB_XP> I was going to say.
22:48:14 <SamB_XP> didn't see how else it could do it...
22:48:22 <monochrom> All safety is provided courtesy of unsafety. :)
22:49:13 <SamB_XP> I can almost write it now...
22:49:46 <SamB_XP> ... but I'd need to know the argument order and I'd also need to look up Control.Exception.catch
22:49:50 <Cale> I've used that trick before to "show" undefined values.
22:50:01 <monochrom> ha!
22:56:32 <glguy> anyone have a hint for solving: a_n+1 = r * a_n - p
22:58:19 <sorear> night.
22:58:26 <sorear> hey glguy!
22:58:46 <sorear> hpaste is up to 1700+ :)
22:59:02 <sorear> glguy: Yes.
22:59:19 <sorear> glguy: let b_n = [ a_n 1 ]  (a vector)
22:59:24 <sorear> glguy: need more hint?
23:00:13 <glguy> not sure that I've used that notation before..
23:00:14 <Procyon_> Hey, I'm trying to set up darcs on my apache server.  Anyone know apache enough to answer a stupid question?
23:00:17 <sorear> glguy: a_(n+1) = [ r -p , 0 1 ] a_n
23:00:39 <sorear> glguy: a_n = [ r -p , 0 1 ]^n a_0
23:00:47 <sorear> glguy: now use matrix exponentiation
23:01:04 <sorear> Procyon_: don't.  darcs only needs sshd
23:01:29 <Procyon_> I have a servername xxx with an existing site.  I want Location /repos to point to /var/www/repos.  What's the apache keyword?
23:01:45 <sorear> anyways, I'm off.
23:01:52 <Procyon_> sorear: For read-only access.  I'll have an ssh for read-write
23:04:23 <ddarius> Multiply both sides by x^n, sum over n, apply transformations to the formal power series, go back to the sequence.
23:07:20 <ddarius> Or just, mostly equivalently, just view it as a digital signal processing problem.
23:08:08 <glguy> :)
23:09:11 <Procyon_> To answer my own question, Alias /repos "/var/www/repos"
23:10:50 <Procyon_> now to figure out how to turn on directory browsing
23:25:17 <Procyon_> Ugh... The kernel random number entropy problem REALLY sucks on a server which is headless with SCSI only. :(
