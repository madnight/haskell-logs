00:05:23 <monn> hi all
00:06:12 <ivanm> hi monn
00:06:14 <monn> I want to purchase a book for learning Haskell. Is there any book you guys recommend?
00:06:56 <ivanm> http://haskell.org/haskellwiki/Books_and_tutorials
00:06:59 <lambdabot> Title: Books and tutorials - HaskellWiki
00:07:00 <ivanm> look under textbook
00:07:13 <monn> I don't have much money, so I plan to buy only one
00:07:26 <ivanm> I own craft, and have read school of expression and introduction to functional programming
00:07:44 <fridim> SoC is only in english?
00:07:46 <ivanm> I quite like craft, but school of expression is pretty good
00:07:52 <fridim> SoE*
00:08:06 <monn> which one is best for first timer?
00:08:06 <ivanm> wouldn't have a clue...
00:08:21 <Cale> monn: If you're a beginner, Graham Hutton's new book is supposed to be good.
00:08:25 <ivanm> you have much experience with programming?
00:08:42 <ivanm> school of expression has downloadable code...
00:08:54 <ivanm> and its isn't "mathsy" - uses multimedia for its examples
00:09:02 <ivanm> so if you want practical results, it might be better
00:09:04 <Cale> It doesn't go quite as far as one might like, but what it covers, it covers well. (This is a second-hand review, I haven't had a chance to check it out personally :)
00:09:21 <fridim> monn, you can start with Yet Another Haskell tutorial (for free)
00:09:22 <ivanm> yeah, I can't comment on that one either
00:09:25 <monn> I'm from OOP, but has some experience in some Lisp dialects
00:09:28 <ivanm> or the wikibook
00:09:33 <fridim> or "Haskell for C programmers"
00:10:02 * Shimei likes the 48 hour scheme interpreter tutorial
00:10:04 <Cale> Yeah, look at the online stuff before you decide to go looking for a book.
00:10:04 <ivanm> the algorithms book is pretty good as well, but doesn't go into as much detail on the haskell language
00:10:16 <Shimei> The scheme thing may be good if you're familiar with lisp.
00:10:44 <monn> fridim:I have read that one, but need much more stuffs to learn
00:10:50 <ivanm> http://en.wikibooks.org/wiki/Haskell
00:10:52 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
00:10:54 <ivanm> have a look there, monn
00:10:58 <ivanm> all online stuff
00:11:25 <ivanm> have a look at the meta-tutorial link down the bottom for more ideas
00:11:45 <ivanm> but personally, I found craft of functional programming the best out of the three I've read
00:12:00 <ivanm> then again, it was the first one I'd read, so I might be slightly biased ;-)
00:12:28 <monn> I've also downloaded the print version of haskell wikibook, but it seems the graphics can't be saved using my browser
00:12:30 <ivanm> my only problem with them are, none of them go into enough detail of monads, etc, IMHO
00:12:35 <ivanm> :(
00:12:41 <alan_> i like YAHT
00:13:02 <Syzygy-> ivanm: For details on Monads, I'd recommend Michael BArr's and whatshisname's Toposes, Triples and Theories.
00:13:06 <ivanm> dons: is this what you meant? http://cs.anu.edu.au/student/comp1100/haskell/tourofsyntax.html
00:13:07 <lambdabot> Title: Tour of the Haskell Syntax
00:13:13 <monn> is this monad thing really needed to be studied first?
00:13:13 <ivanm> Syzygy-: is that a book or an online tutorial?
00:13:24 <ivanm> monn: no, later
00:13:35 * ivanm still needs to study monads properly
00:13:47 <Syzygy-> ivanm: That's a GTM book (available online as pdf) on the relevant and some nearby mathematics.
00:13:49 <fridim> I haven't found any book about haskell translated to french :/
00:13:58 <ivanm> Syzygy-: nice! I'll have a look!
00:14:02 <dons> ivanm: npoe. let http://haskell.org/haskellwiki/Category:Style
00:14:03 <alan_> can you eben implement most monads in haskell 98?
00:14:04 <lambdabot> Title: Category:Style - HaskellWiki
00:14:07 <ivanm> fridim: wasn't YAHT just translated?
00:14:18 <Syzygy-> ivanm: The 'triples' in the title refers to monads under another name.
00:14:22 <ivanm> dons: found that, didn't seem to have anything on indentation
00:14:23 <Shimei> I think gentle introduction was translated into French.
00:14:25 <ivanm> Syzygy-: *nod*
00:14:26 <dons> alan_: all monads, few monad transformers.
00:14:38 <monn> ivanm:I'll check the crafts of fp then
00:14:44 <dons> well, other than the existentially-quantified monads, like Set.
00:14:47 <dons> you need extensions for those.
00:15:05 <ivanm> monn: if you can, try and borrow them out of a library or something and have a quick read through
00:15:11 <fridim> ivanm, I don't know i'am speaking about "being sold" books
00:15:18 <ivanm> oh
00:15:30 * ivanm has no idea about physical books
00:15:48 <ivanm> not much demand for them down-under, AFAIK ;-)
00:15:54 <monn> ivanm:i doubt there will be any of them in here :)
00:15:59 <ivanm> heh
00:16:17 <ivanm> well, my uni used to teach haskell,l so I managed to borrow books from there to start with
00:16:48 <ivanm> *sigh* as I suspected, I've been writing where expressions wrong all along
00:16:54 <fridim> AFAIK= ?
00:17:04 <ivanm> AFAIK: as far as I know
00:17:06 <DRMacIver> Syzygy-: Hm. I should probably pick that book up again.
00:17:13 <DRMacIver> It's depressing how rusty my maths has got.
00:18:04 <fridim> Not so worrying, It should improve my english
00:18:22 <ivanm> heh
00:19:34 <fridim> s/Not so worrying/it does not matter/
00:19:43 <fridim> :)
00:19:44 <ivanm> @type mapM_
00:19:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
00:20:03 <monn> what is mapM_?
00:20:16 <ivanm> a version of map used for monads
00:20:36 <ivanm> s/monads/warm fuzzy things ;-)
00:20:46 <ivanm> or whatever the new, official name for them is :p
00:21:11 <monn> then I shouldn't bother it :) (since I wouln't deal with monad first)
00:22:30 <ivanm> nah, it was for me ;-)
00:25:31 <monn> my haskell code failed to pass this test : http://www.spoj.pl/problems/INTEST
00:25:37 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem INTEST
00:25:46 <olsner> mapM_ :: (TeddyBear teddy) => (a -> teddy b) -> [a] -> teddy ()
00:26:07 <monn> is there any trick for optimizing IO read?
00:26:18 <olsner> lambdabot should have a warm-fuzziness-filter
00:26:36 <osfameron> morning
00:27:03 <ivanm> hey osfameron
00:27:05 <ivanm> olsner: lol
00:27:32 <osfameron> quick question:  is Graphics.SOE absurdly and comically slow?  (If not, the algorithm I've chosen is probably awful)
00:28:09 <ivanm> monn: well, IO uses monads...
00:28:19 <ivanm> so you might want to look up some monad stuff
00:28:24 <olsner> *warm fuzzy things
00:28:46 <osfameron> I did exercise 3.2 from SOE, and it works just lovely,except for being slow, and hanging occasionally, only to be woken up by an IO event (keypress, mouse move)
00:29:12 * ivanm just read the book, didn't bother with the exercises
00:29:26 <dons> monn: use Data.ByteStringr ?
00:29:39 <osfameron> I found that "just reading" doesn't help.  FP is far too different from what I'm used to, so I have to make myself do all the baby steps
00:29:46 <dons> osfameron: the SoE based on gtk?
00:29:56 <monn> dons: nope, I use getLine (combined with sequence)
00:29:57 <dons> should be faster and neater than old school SoE, if you're not using it.
00:29:57 <osfameron> I learnt perl by "just reading" Learning Perl tho'
00:30:14 <osfameron> dons: Graphics.SOE, based on HGL, it imports the HGL and X11 packages
00:30:43 <dons> not sure how performant that is, but I'd imagine its not that bad.
00:31:24 <monn> dons: where can I find Data.ByteString?
00:31:36 <dons> its in Data.ByteString, in the base library :-)
00:31:36 <monn> dons: is it on standard lib?
00:31:38 <dons> yeah
00:31:41 <dons> for ghc 6.6
00:31:48 <dons> is that what the sphere-y thing uses?
00:32:10 <monn> arghhh.. my GHC is 6.4.2
00:32:20 <monn> ooh, I don't know bout that
00:33:01 <osfameron> dons: ok.  I'll have a look at the algorithm I used, but as far as I can see it's doing it as he instructed.  TBH, it's more the random hanging that's worrying me
00:34:32 <dons> there's some other haskell guys who've done quite well on SPOJ.
00:34:40 <dons> maybe ask glguy or chessguy?
00:37:07 <monn> can't find chessguy, and have trouble in sending glguy a pm (I'm not registered yet)
00:37:31 <ivanm> dons: with that lprint function I was talking about before, using mapM_ instead seems to be slower :(
00:38:43 <osfameron> @where spoj
00:38:44 <lambdabot> I know nothing about spoj.
00:39:14 <monn> http://www.spoj.pl
00:39:15 <lambdabot> Title: Sphere Online Judge (SPOJ)
00:40:38 <sjanssen> monn: you should request 6.6 on the SPOJ forums
00:41:54 <monn> http://www.spoj.pl/forum/viewtopic.php?t=3852&sid=b94b2dc5ffa91f6b84cc6f2d32aea3af
00:41:57 <lambdabot> http://tinyurl.com/ytmkmu
00:42:36 <sjanssen> complain some more :)
00:43:12 <sjanssen> upgrading should be a 20 minute task
00:43:34 <monn> tomek seems agreed too (he is a national hero of poland, in algo world), then my post won't give much help :)
00:43:43 <alan_> join #gcj
00:43:58 <monn> spam?
00:44:06 <monn> gjc <- is this java thing?
00:44:08 <alan_> typo
00:44:15 <arcatan> spam, spam, lovely spam
00:44:18 <monn> ooh :)
00:44:20 <alan_> i mean /join
00:46:10 <alan_> what os is everyone here running? im on windows
00:46:24 <ivanm> gentoo linux
00:46:26 <osfameron> I'm on ubuntu linux
00:47:27 <monn> i'm on unlicensed winxp
00:47:38 <ivanm> ooooh, a pirate!
00:47:41 <ivanm> @arr!!
00:47:42 <lambdabot> Yo ho ho, and a bottle of rum!
00:48:00 <dons> irix!
00:48:13 <ivanm> dons: with that lprint function I was talking about before, using mapM_ instead seems to be slower :(
00:48:15 <monn> nope, i haven't license this one (got installed a few hours ago)
00:48:23 <ivanm> oh, so you have an excuse
00:48:32 <alan_> lol, lambdabot can impersonate linus torvalds
00:48:40 <dons> ivanm: ok. weird. check the Core.
00:48:49 <monn> don't have time to go to HR department yet
00:48:55 <ivanm> alan_: how?
00:48:59 <ivanm> dons: how do I do that again?
00:49:44 <dons> -O2 -ddump-simpl | less
00:49:49 <dons> check for the key function you're interested in
00:50:35 <hpaste>  Cheery pasted "Yet further trickery with FRP" at http://hpaste.org/1735
00:50:56 <alan_> @google linus pirate
00:50:57 <lambdabot> http://lkml.org/lkml/2006/9/20/2
00:50:57 <lambdabot> Title: LKML: Linus Torvalds: Arrr! Linux 2.6.18
00:51:00 <Cheery> what was the another representation for FRP haskell supported?
00:52:17 <alan_> ivanm: see?
00:52:23 <ivanm> ahhh!
00:52:26 <ivanm> or should I say...
00:52:28 <ivanm> @arr!!
00:52:28 <lambdabot> Yeh scurvy dog...
00:52:32 <ivanm> heh
00:52:42 <cinimod> In EMACS haskell mode is there any way to get text completion?
00:53:25 <Cheery> the stream oriented one
00:54:28 <cinimod> Cheery: Is that a question for me?
00:54:32 <ivanm> dons: can't seem to find it...
00:54:40 <Cheery> cinimod: nop
00:55:02 <Cheery> asked it in general
01:04:00 <alan_> cinimod: the only thing i know you can do is download the haskell source and use hasktags to make etags
01:17:26 <cinimod> alan_: ok I'll google hasktags thanks
01:21:18 <alan_> cinimod: it comes with ghc
01:22:19 <alan_> does anyone know the order for using autotools. im trying to generate a makefile for Drift
01:25:49 <earthy> alan_: :hasktags in ghci also generates tags.
01:25:58 <earthy> and I *bet* emacs has identifier-completion
01:26:50 <ozone> M-/
01:26:55 <ozone> (not identifier completion, but it's close enough)
01:46:46 <cinimod> ozone: that's brilliant thanks
01:47:01 <ozone> cinimod: yep, can't live without it now
01:49:11 <monn> are function applications always be memoized in haskell?
01:50:35 <Heffalump> no
01:50:57 <Heffalump> in fact they are never memoized in any implementation I know of (although CSE might produce a similar effect occasionally)
01:51:40 <monn> why?
01:52:20 <monn> is that counts as disadvantage when haskell is a pure functional language?
01:53:05 <dons> hehe, no, doesn't really have anything to do with it.
01:53:10 <dons> you can memoise if you want.
01:53:51 <LeCamarade> @tell ehird` Thanks for sending me to zsh! I am certainly going apt-get remove bash --yes --force-yes
01:53:52 <lambdabot> Consider it noted.
01:54:04 <Heffalump> dons: it's not very easy, though.
01:54:14 <monn> dons : how can we do that?
01:54:41 <dons> monn: the usual way is with a list of results.
01:54:49 <monn> may be one approach is by additional parameter
01:55:19 <monn> how about performance?
01:55:29 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:55:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:55:41 <dons> performance of haskell?
01:55:52 <dons> its comparable to other compiled, statically typed languages, like OCaml or C++.
01:56:14 <monn> nope, i mean when we add list of result in the function
01:56:25 <dons> ah right. should be pretty efficient. see above.
01:56:34 <osfameron> dons: are there good studies on that btw?  comparisons of like for like applications, that sort of thing?
01:56:38 <dons> its a lazy list, which just emulates a loop.
01:57:04 <dons> osfameron: only for small things. for very large systems, they tend not to get rewritten in both low and high languages.
01:57:14 <dons> osfameron: but we know what the assmebly looks like.
01:57:31 <dons> that ghc generates, that ocaml generates, that C++ generates, so you can just infer from that.
01:57:38 * Heffalump doesn't think it's really that simple. In general you just want arbitrary calls to a function to save the result, rather than to enumerate the entire set of results for the function.
01:57:56 <dons> i suppose xmonad is very comparable to dwm. its a clone. performs very similarly.
01:58:12 <dons> the src is about 1/5th the size, the heap about twice as big. runtime seems similar.
01:58:34 <dons> yes, for the other cases you need unsafePerformIO to force certain memo behaviour.
01:58:41 <dons> the good cases are handled by lists and recursion.
01:58:47 <dons> and 'let'
01:59:06 <osfameron> this always baffles me, if a high level language performs as well as something like C++, why people aren't wetting themselves about it more...
01:59:29 <Heffalump> I don't think Haskell does, really.
01:59:29 <dons> they are, are't they?
01:59:37 <dons> its not "as well", it "close"
01:59:41 <Heffalump> but I don't have any concrete evidence of that
01:59:55 <dons> for the apps I've written, it certainly seems to be "comparable"
01:59:58 <Heffalump> I don't think a significant constant factor is really "close"
02:00:00 <osfameron> and then occasionally you see complaints about consing being slow and that the generated code is too slow, and I never know what to think.
02:00:08 <osfameron> ah, ok
02:00:35 <dons> its possible to produce identical code, given enough effort, usually.
02:00:43 <dons> depends on how much effort.
02:00:50 <ivanm> dons: still can't work out why mapM_ is slower than my original printing function
02:00:58 <dons> its not possible in python or ruby. so we're in a strong positoin :-)
02:01:07 <dons> ivanm: you have to look at the core. that's the only way to know.
02:01:19 <ivanm> well, I can't even find it in the core :s
02:01:26 <ivanm> or at least not in any recognizable form
02:01:28 <dons> how big is the program?
02:02:49 <ivanm> the core for the whole program (main + library) is 76K
02:02:56 <ivanm> the core for just the main program is 8K
02:03:01 <dons> how big is the src of the program? could you post it?
02:03:06 <dons> then I could tell you why :-)
02:03:15 <dons> both versoins, preferably
02:03:15 <monn> dons: the fibs you give above, isn't it dynamic programming approach instead of memoization?
02:03:21 <dons> yeah.
02:03:42 <dons> google for 'memoization' on the haskell mailing list, there's a thread recently on the best techniques.
02:04:44 <ivanm> 55 lines of code
02:04:47 <ivanm> !hpaste
02:04:52 <ivanm> @hpaste
02:04:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:05:08 <ivanm> is there any easy way to strip out all the comments from a literate file?
02:05:31 <dons> unlit ?
02:05:38 <monn> ivanm: then you'll get no code after that?
02:05:55 <ivanm> dons: that leaves whitespace where the comments were though, doesn't it?
02:06:10 <ivanm> monn: ummm.... sure there will be code... why wouldn't there be?
02:06:10 <dons> i think so.
02:06:16 <earthy> yeah, but whitespace minimization is easy-peasy
02:06:25 <ivanm> example?
02:06:42 <LeCamarade> unlit | sed '{s/^\s*$//gi}'
02:06:45 <LeCamarade> :oD
02:06:52 <monn> ivanm: since the comments are the code :)
02:06:56 <earthy> lecamarade: that'll kill *just* a bit too much ;)
02:06:59 <dons> won't strip newlines, though, LeCamarade
02:07:01 <ivanm> monn: not quite...
02:07:13 <dons> you want consecutive blank lines removed.
02:07:35 <ivanm> monn: in literate code, you just differentiate code from whitespace instead of the other way round
02:08:05 <LeCamarade> dons: I thought it would ... the $. Maybe not. There's a reason I'm not at either #regex or #perl. Or #sed.
02:08:13 <mnislaih> dcoutts_:  I just finished filepath'ing Cabal. It seems to work here, but I'll be sending you the patch for review
02:08:38 <dons> LeCamarade: sed is basically a unlines . map f . lines
02:09:02 <earthy> lecamardae: you could do it with perl though, repeatedly mapping \n\s*\n to \n
02:09:06 <dons> LeCamarade: it never sees the list terminators. though with the N;G; etc loop control flow, you can mungle extra lines.
02:09:36 <mnislaih> dcoutts_: Also, before you apply it let the GHC folks know, the absence of Compat.FilePath breaks the GHC build process
02:09:41 <earthy> dons: you can actually implement turing machines that way in sed. :)
02:09:51 <LeCamarade> runghc -c 'unlines ...' Someone save us. :oD
02:10:00 <dons> earthy: yeah :-)
02:10:03 * earthy ponders... where the fuck did I leave that code. :)
02:10:07 <dons> the unlambda machine in sed is amazing.
02:10:19 <LeCamarade> whatis hawk(1)  # Haskell-ish wak. :oD
02:10:23 <earthy> that was a great new-years day in 1997
02:10:55 <earthy> ah to be young again and without obligations...
02:11:03 <LeCamarade> earthy: I suspected as much. Nobody uses sed(1) when there's no strong drink in the 2-foot circumference.
02:11:14 <earthy> back to the grind of hacking parser combinators. :)
02:11:16 <dons> earthy: ftp://quatramaran.ens.fr/pub/madore/unlambda/contrib/unlambda.sed
02:11:27 <dons> LeCamarade: hey, I like sed.
02:11:32 <dons> I wrote some of the sed faq one liners :-)
02:11:41 <earthy> sed is muy cool
02:12:13 <hpaste>  ivanm pasted "Printing lists incrementally" at http://hpaste.org/1737
02:12:37 <LeCamarade> dons: I'm one of the new-gen ones, unfortunately. We start with JavaScript, then to Perl and Python. Little in-between. :o(
02:12:49 <dons> sed '/./,/^$/!d'
02:13:05 <dons> delete , not, the regions that contain characters
02:13:12 <dons> (i.e. delete consecutive blank lines)
02:13:34 <dons> the low level looping way is,
02:13:35 <dons> sed '/^$/N;/\n$/D'
02:13:47 * LeCamarade .oO Does anybody else feel as sad as I am for having missed the Years? For having woken up to an Windows world?
02:14:45 <LeCamarade> dons: Stop harassing me! Your Haskell is already esoteric enough ... too much density, you know. But very, very edifying code you have dons. Worth a year of school, just reading your xmonad stuff.
02:14:50 <LeCamarade> @karma++ dons
02:14:50 <lambdabot> dons's karma raised to 146.
02:15:07 * LeCamarade Blinkenlichten!!! 146?
02:15:13 <earthy> oh, right, 1998
02:16:30 <dons> xmonad is a bit of an exercise in writing programs whose source you want to display in public.
02:16:51 <earthy> dons: http://www.xs4all.nl/~arthurvl/turing.sed
02:17:10 <dons> oh very very nice.
02:17:29 <earthy> needs GNU Sed though, due to the length of the labelnames
02:18:08 <dons> that's beautiful, earthy.
02:20:24 * earthy was pretty proud of having written that in a day
02:20:51 * earthy just realizes that that code is *9* years old already
02:21:22 <ivanm> dons: did you have a look at my hpaste?
02:21:30 * LeCamarade wonders what is _beautiful_ about it.
02:21:44 <earthy> try reading it.
02:22:05 * LeCamarade obscene rape of the Shift and the top line of the keyboard. X-(
02:22:36 <LeCamarade> earthy: I certainly would, if I could understand it. I guess I am just freaked out. :o(
02:22:49 <olsner> nah, that's nothing... now *TeX* is obscene keyboard rape!
02:22:52 <earthy> okay, it helps to have a sed refmanual next to you.
02:22:59 * LeCamarade gets scared when comments don't start in REM.
02:23:01 <earthy> olsner: I've been learning some more TeX lately. ;)
02:23:23 <dons> ivanm: sorry, dinner time.
02:23:24 <earthy> REM? that's from the language I started with some 23 years ago...
02:23:32 <dons> earthy: and it still runs :-)
02:23:34 <ivanm> dons: heh, fair enough
02:23:34 * LeCamarade ... and no variable declarations starting in LET. :oD
02:23:34 * earthy is suddenly scared of himself
02:23:36 <olsner> tex makes you want to hack an AltGr-lock
02:23:36 <earthy> dons: :)
02:23:54 <LeCamarade> earthy: And it goes zoom on .NET.
02:24:07 * earthy has been programming on and off for almost 25 years... *gulp*
02:24:14 <ivanm> LeCamarade: so you don't like comments in Haskell then, since they don't start with REM? :p
02:24:15 <LeCamarade> earthy: You are quite ... unyoung.
02:24:37 <ivanm> heh, that's a polite way of putting it ;-)
02:24:41 <olsner> earthy: so you're like ... 30 years old?
02:24:49 * earthy 's age will hit a power of two coming november
02:24:51 <earthy> olsner: :)
02:25:00 <LeCamarade> ivanm: Only scared. But MSSQL comments start with --, so I jumped and said `Aha! At least one thing I _understand_ about Haskell!'
02:25:10 <LeCamarade> olsner: :oD
02:25:21 <ivanm> earthy: you started programming when you were 7?
02:25:26 <earthy> 9
02:25:33 <earthy> almost :)
02:25:37 <earthy> 8 to be exact
02:26:09 * earthy was a certified pascal programmer by the time I was 17
02:26:53 <earthy> damn I'm starting to feel old all of a sudden
02:27:18 <earthy> now I understand why the students feel as though there's a big gap between them and me... :)
02:27:23 <olsner> I'm only just hitting 13 years of coding
02:27:28 <therp> I guess I wrote my first basic programs when I was 9/10..
02:27:35 <earthy> therp: makes sense
02:27:45 <LeCamarade> > 9 / 10
02:27:47 * earthy intends to teach his children Haskell in about oh, 7 years.
02:27:49 <lambdabot>  0.9
02:28:08 <earthy> at least the firstborn, by then. ;)
02:28:19 <ivanm> earthy: well, depends when you were counting the "25" from, I suppose...
02:28:22 <earthy> (and no, I don't have any yeat ;))
02:28:31 <ivanm> heh
02:28:52 <ivanm> so, if you don't have any kids for 5 years, you're going to teach the first one to code when they're 2 years old? :p
02:29:10 * LeCamarade will at least club together with kolmodin. Same age group. :o( Feels like we missed the fun years.
02:29:18 * ivanm thinks he read a blog post about someone helping their 3 yo write a dodgy game in python or haskell... ekidd maybe?
02:29:33 <ivanm> LeCamarade: how old are you then?
02:29:37 <olsner> many people learn their native tongue in about a year or so - and most natural languages aren't even context-free
02:29:42 <olsner> can't be that hard, I mean ;-)
02:29:52 <monn> damn, I just started programming when I hit 18 :(
02:29:55 <earthy> ivanm: the gf is 5 months pregnant. :)
02:30:13 <ivanm> ahhh, fair enough
02:30:23 <ivanm> I started programming when I was 12 or 13...
02:30:25 <LeCamarade> ivanm: I am slightly younger than kolmodin. He has his age on his blog.
02:30:59 <ivanm> since there was nothing to do at lunchtimes when I started high school, so quite a few of us taught ourselves turbo pascal and made dodgy programs in that :p
02:31:11 <LeCamarade> I started when I was ... 15, I think. But I had been a computer freak since 8. How about we start the `My Road to Haskell' Wiki? Like the Lisp one?
02:31:13 <ivanm> LeCamarade: he's 27 or something? so you're what, 25?
02:31:35 <LeCamarade> ivanm: Woah! He's old! I thought he was 22!
02:31:40 <earthy> ivanm: kolmodin is 23.
02:31:40 <LeCamarade> He said 22.
02:31:50 <earthy> lecamarade is 20, then
02:31:52 <earthy> right? :)
02:31:54 <LeCamarade> yeah, 23.
02:31:56 <ivanm> ahhh.... I must be getting confused with someone else then
02:31:59 <earthy> almost old enough to drink in the US? :)
02:32:03 <ivanm> possibly araujo...
02:32:03 <LeCamarade> > 20 + 1
02:32:05 <lambdabot>  21
02:32:06 * ivanm is 21
02:32:25 <monn> dons: are you still up?
02:32:56 <LeCamarade> ivanm: Yay!
02:33:04 * Heffalump feels old :-)
02:33:37 <monn> is there any of you guys using haskell at work?
02:33:42 * Heffalump is
02:33:46 * earthy is
02:33:58 <LeCamarade> monn: Even when the boss doesn't allow, you mean?
02:33:58 * dons is
02:34:22 <monn> great!!
02:34:24 * Heffalump was hired specifically to use Haskell at work
02:34:24 <ivanm> monn: well, does using it for uni assignments count? :p
02:34:29 * LeCamarade will answer after 5:30pm.
02:34:30 <mdmkolbe|work> monn: I'm writing the Haskell compiler at work
02:34:45 <ivanm> monn: especially when the lecturer for the subject I'm using it for hates haskell? ;-)
02:35:12 <Heffalump> mdmkolbe|work: you're an intern at GHC HQ?
02:35:33 <mdmkolbe|work> Heffalump: yep
02:35:39 <Heffalump> cool, what are you working on?
02:35:41 <LeCamarade> If my boss knew how much corporate time I spend on Haskell one-liners and stuff, he'd have blocked irc.freenode.org. And he's a nice guy. It's just I take it over the edge.
02:35:41 <monn> LeCamarade: haha
02:35:54 <ivanm> Heffalump: what do you do then?
02:36:05 <dons> mdmkolbe|work: ah ha :-)
02:36:13 <monn> ivanm: no, it doesn't
02:36:18 <mdmkolbe|work> Heffalump: refactoring the code generator to use CPS
02:36:24 <mdmkolbe|work> dons: :-)
02:36:28 <ivanm> monn: :(
02:36:32 <dons> mdmkolbe|work: C-- level stuff?
02:36:37 <earthy> hef is at credit suisse these days, right?
02:36:41 <ivanm> mdmkolbe|work: what's CPS?
02:36:41 <mdmkolbe|work> dons: yeah
02:36:42 <Heffalump> ivanm: I work for the quant group in an investment bank. We use Haskell to make better tools for the quants to write their stuff with.
02:36:46 <monn> ivanm: hehe
02:36:48 <Heffalump> earthy: yep
02:36:57 <dons> (are you the C-- optimisation guy we're all hoping on hearing from, down here in bytestring land?)
02:36:59 <mdmkolbe|work> @go wikipedia continuation passing style
02:37:01 <lambdabot> http://en.wikipedia.org/wiki/Continuation_passing_style
02:37:02 * LeCamarade just refactored all his code and replaced all CPS-using funcs to use fold*!
02:37:02 <ivanm> Heffalump: ahh, similar to that company offering the OCaml scholarships?
02:37:02 <lambdabot> Title: Continuation-passing style - Wikipedia, the free encyclopedia
02:37:07 * LeCamarade just refactored all his code and replaced all CPS-using funcs to use fold*!
02:37:18 <Heffalump> ivanm: a bit different, they use O'Caml for all their code, and we just use Haskell in certain areas
02:37:27 <Heffalump> though we're trying to increase those areas :-)
02:37:34 <ivanm> *nod*
02:37:39 <dons> mdmkolbe|work: if you ever some nice loop code to hammer on the code gen, let me know.
02:37:44 <ivanm> after all, purity must win? ;-)
02:38:21 <Heffalump> absolutely :-)
02:38:35 <ivanm> @botsnack
02:38:35 <lambdabot> :)
02:38:37 <LeCamarade> If Haskell was .NET-friendly, I'd not have a hand at #ocaml, right now.
02:38:41 <mdmkolbe|work> dons: RE: C-- optimization/bytestring etc.  I'm not sure, but probably not if there was some specific person in mind.  Though I'll do my best
02:38:46 <LeCamarade> @go wikipedia f sharp
02:38:47 <lambdabot> http://en.wikipedia.org/wiki/F_Sharp_programming_language
02:38:48 <lambdabot> Title: F Sharp programming language - Wikipedia, the free encyclopedia
02:38:54 <ivanm> LeCamarade: why do you want .NET?
02:38:54 <Heffalump> I'd really like Haskell to have .NET integration too
02:39:09 <ski> 'fold*' ?
02:39:11 <LeCamarade> ivanm: Work, my friend. Work.
02:39:22 * ivanm gets really annoyed when people say "why don't you use/try .NET", and I have to ask "do you mean .NET or C#?"
02:39:25 <ivanm> LeCamarade: fair enough
02:39:26 <LeCamarade> ski: fold[r|l]
02:39:46 <ivanm> most people treat the term ".NET" as the language, when its just a platform
02:40:23 <Heffalump> I think that's the key point, really
02:40:34 <Heffalump> it is a platform, and it's one that many people want to be able to interoperate on
02:40:38 <LeCamarade> ivanm: C# and VB.NET were once the dot in .NET. But with F#, you can actually program functional style on .NET. And if Haskell had nice .NET integration (if it existed at all), I'd not use F# (which is based on OCaml nearly 100%).
02:40:45 <Heffalump> C# is just the flagship language
02:41:08 <ivanm> Heffalump: yeah, but people say .NET, when they mean C#
02:41:13 <Heffalump> well, we're not :-)
02:41:16 <LeCamarade> Heffalump: And a crappy one, at that. But at least .NET has F#. (Is my drool visible? :oD)
02:41:27 <ivanm> its like saying "let's use JVM", since may languages have the option to compile to the JVM
02:41:30 <LeCamarade> JVM doesn't have nice functional langs.
02:41:31 <ivanm> Heffalump: yeah, I realise that
02:41:45 <LeCamarade> @go jaskell
02:41:47 <lambdabot> http://jaskell.codehaus.org/
02:41:47 <lambdabot> Title: Jaskell - Home
02:41:50 <ivanm> LeCamarade: well, there's IronPython, which is _slightly_ functional
02:42:04 <Heffalump> I hear a lot of people going on about F# nowadays. But it doesn't really seem to have anything like the same level of support/development as Haskell does. On the other hand, it gets the benefit of all the .NET libraries.
02:42:09 <ivanm> LeCamarade: though many people say that C# > Java
02:42:15 * earthy did an implementation of half of Clean 0.5 on the JVM once
02:42:20 <earthy> that sucked
02:42:20 <ivanm> Heffalump: but why do you want .NET?
02:42:27 <ivanm> earthy: heh
02:42:38 <LeCamarade> ivanm: For me functional is between SML and Haskell. Can't live sans pattern matching. I am in bondage. Haskell is harsh mistress.
02:42:39 <Heffalump> ivanm: for binary interop that's a step up from COM
02:42:52 <Heffalump> earthy: that's the thing, lots of people have done *half* implementations
02:42:53 <earthy> (the issue being that clean strongly depends on graph-rewriting semantics, and doing graph-rewriting on the JVM is somewhat... slow)
02:42:53 <ivanm> Heffalump: *nod*
02:43:06 <Heffalump> well, I personally don't give a shit. But it'd be useful at work.
02:43:10 <LeCamarade> C# is better than java, but I am sick of for(int notI = 0; notI < N; ++notI);
02:43:18 <ivanm> though, in most cases, I'd prefer to compile directly to a stand alone executable, rather than one requiring an interpreter/virtual machine
02:43:38 <LeCamarade> What's worng with a map, for [insert prefered deity's name]'s sake?
02:43:54 <Heffalump> ivanm: sure. But that doesn't really work in a large environment where the users don't have compilers on their machines.
02:43:58 <ivanm> true
02:44:00 <olsner> doesn't C# have some kind of foreach?
02:44:01 <matthew-_> so err, why does mailman for the mailing lists not accept mails with a mime entry which is useful, eg text/x-literate ?
02:44:01 <ozone> Heffalump: there's yet another UNSWian working on .NET <-> Haskell right now
02:44:07 <olsner> even Java's got one nowadays
02:44:12 <dons> Heffalump: we've got a student doing their .. oh, like ozone said.
02:44:18 <ozone> (though the goal of his thesis is WPF in haskell, i believe)
02:44:21 <andrewa> I'm that student :-)
02:44:25 <dons> that guy.
02:44:27 <Heffalump> ozone: oh good. Will it actually work when it's done, or will it just be another part-complete impl? :-)
02:44:29 <dons> hey andrewa
02:44:31 <ivanm> heh
02:44:36 <Heffalump> hello :-)
02:44:37 <ozone> Heffalump: ask him yourself i guess ;)
02:44:41 <Heffalump> I just did :-)
02:44:46 <Heffalump> effectively.
02:44:56 <Heffalump> (by not hitting ^U when I noticed him appear)
02:45:04 <andrewa> Heffalump: the aim is to produce a 'practical' implementation, so yup that's the plan
02:45:06 <LeCamarade> olsner: It is meant to still be procedural. I did that for years on end - it doesn't teach me anything new. JavaScript had it before, and Java and C# were late with foreach. Doesn't make them even barely usable, still.
02:45:12 <Heffalump> andrewa: cool.
02:45:20 <dons> andrewa: Heffalump is working at credit suisse now, btw, where gabi was last year.
02:45:22 <Heffalump> how much time do you have to do it?
02:45:41 <ozone> you're at credit suisse now?  i thought you were at intel, or arm, or something
02:45:52 <Heffalump> I was at ARM. I moved to CS in January.
02:45:59 <Heffalump> seduced by the Haskell
02:46:10 <andrewa> Heffalump: one session, so about 5 months
02:46:14 <olsner> LeCamarade: agreed there are other shortcomings - but at least you don't have to do (specifically) for(int i=0;i<n;i++) unless you want to
02:46:15 <ozone> cool, congrats
02:46:17 <LeCamarade> andrewa: So, you are working on a .NET <-> Haskell thing? :-*!
02:46:18 <ozone> you're in NYC then?
02:46:24 <Heffalump> ozone: no, London
02:46:30 <andrewa> Heffalump: if you have some specific use cases that'd be helpful
02:46:40 <ozone> ah, the other white meat
02:46:42 <LeCamarade> olsner: What I don't want is to alter variables. That alone s a bug.
02:46:49 <LeCamarade> @go what is wrong with the for loop
02:46:52 <lambdabot> http://notes-on-haskell.blogspot.com/2007/02/whats-wrong-with-for-loop.html
02:46:52 <lambdabot> Title: Notes on Haskell: What's Wrong with the For Loop
02:46:56 <andrewa> LeCamarade: yep, it's a runtime bridge, so I'm not looking at compiling Haskell to .NET
02:46:59 <olsner> for some value of bug :P
02:47:25 <LeCamarade> andrewa: I'll be praying hard for you. You're my hero. :o*
02:47:35 <ozone> andrewa: compiling games for the xbox 360 the XDK :}
02:47:52 <andrewa> LeCamarade: :-)  My first fan...
02:47:55 <Heffalump> andrewa: how will the bridge work? (I have no specific use cases, just a general desire to be able to have the two interoperate nicely. I'll see if I can find out more about specific things we might find useful.)
02:48:30 <Heffalump> ozone: well, I still live near Cambridge, so it's a bit of a commute :-)
02:48:58 <ozone> Heffalump: nice to see you back in haskell land, btw, the community will benefit greatly :)
02:49:11 <andrewa> Heffalump: it'll be implemented as a library that uses the standard C FFI.  On Windows I'm using a bit of COM hackery to host the CLR and talk to it.
02:49:15 <Heffalump> not sure about that, my work stuff is all proprietary :-)
02:49:33 <ozone> it means you have a valid excuse to hang out on the mailing lists again, though!
02:49:36 <Heffalump> but I think helping Haskell employers to develop is a good thing, so I guess it will indirectly.
02:49:40 <Heffalump> true.
02:49:46 <LeCamarade> Heffalump: You seem interested in .NET <-> Haskell. (Giveth me hope that there'll be some good Haskell hacker watching. :oD)
02:50:33 <andrewa> Heffalump: I haven't worked out the high-level mapping stuff yet, but it'll certainly be using .NET reflection to generate the bindings automatically.
02:50:34 <Heffalump> LeCamarade: well, I'm interested in something we can use at work.
02:50:54 <Heffalump> I'll need to do a bit more investigation to see if people will consider a bridge good enough.
02:51:46 <LeCamarade> Heffalump: Yeah, clients want .NET (okay, I mean Windows with no segfaults) stuff, so I have to do .NET. But certainly not C#. So, I will be using F# while I wait for andrewa's work.
02:51:56 <andrewa> Indeed, for some things a bridge isn't sufficient.  It won't help if you want to use the .NET Compact Framework, for example.
02:52:03 <Heffalump> that's not an issue
02:52:14 * LeCamarade was on the verge of going off on a Haskell <-> .NET mission on his own, recently. :oD
02:52:27 <Heffalump> but I don't know if it'll provide deployment problems, e.g. our infrastructure might just be set up to handle proper .NET assemblies and nothing else.
02:52:47 <Heffalump> (I don't know much about how a external code + a bridge would look to the .NET distribution world)
02:53:06 <andrewa> Heffalump: yeah that could be a problem.  With the bridge you still end up with a native exe (produced by GHC), which loads in the CLR dynamically.
02:53:22 <Heffalump> but realistically, a bridge is the best we can expect. Actual compilation to .NET bytecode would be tricky and probably slow.
02:53:39 <Heffalump> andrewa: oh, so other CLR stuff couldn't call the Haskell code?
02:53:44 <earthy> won't yhc be a good base for compiling to CLR?
02:54:04 <earthy> hm.
02:54:37 <andrewa> Heffalump: via delegates you can certainly call back into Haskell.  But (to begin with at least), I plan to focus on Haskell being 'in control'.
02:55:04 <Heffalump> andrewa: right.
02:55:42 <Heffalump> "call back into" probably isn't good enough, though, I'd expect we'd want Haskell to be there as a library that can be called, not the thing that runs initially.
02:55:53 <andrewa> The main goal is to allow the use of the excellent libraries provided by .NET (such as WPF).  Using these libraries requires some level of bidirectionality in the bridge (but not full bidirectionality).
02:56:10 <andrewa> Heffalump: ozone brought up the same point to me the other day.
02:56:45 <Heffalump> anyway, even if you don't make it possible yourself, making your design such that someone else could do it would be a good start
02:57:26 <andrewa> Heffalump: true indeed.  Extending the bridge to support both directions is in my list of tasks (but it's an 'if I get time' one atm).
02:58:22 <Heffalump> is having a library that is called via a bridge technically feasible, anyway? I can only half see how it'd work.
02:59:02 <andrewa> by library, do you mean a .NET library/class or Haskell?
02:59:26 <Heffalump> Haskell.
03:01:17 <Heffalump> actually, I guess it can't be that bad if you can put your Haskell in a DLL.
03:01:34 <Heffalump> just do whatever the native code interop stuff is in .NET in a stub library.
03:01:51 <Heffalump> the details would probably be quite fiddly though
03:01:59 <earthy> wouldn't that require for dynamic loading of haskell though?
03:02:04 <andrewa> One issue is making sure that you only have one version of the Haskell RTS around.
03:02:07 <earthy> is that solved for anything but Mac OS X already?
03:02:18 <Heffalump> earthy: "if you can put your Haskell in a DLL" :-)
03:02:22 <andrewa> earthy: Yeah, I think hsplugins might help there.
03:02:40 <andrewa> earthy: (In the absense of DLL support in GHC)
03:02:45 * earthy seems to recall a SoC project on making haskell dynamically loadable
03:02:46 <Heffalump> andrewa: if you have multiple Haskell libraries only interfacing with each other via .NET, multiple RTSes should be ok, shouldn't it?
03:03:22 <earthy> yup. clemens fruhwirth
03:03:58 <andrewa> Heffalump: I guess so, although I'm not really sure about that.  The RTS uses a lot of global state, but if such state is in different DLLs...
03:04:21 <Heffalump> andrewa: right. I'd be more concerned about having multiple .NET thingies calling the same bit of Haskell concurrently.
03:04:46 <LeCamarade> andrewa: =^o If you add that, it is a complex game, then. !!!
03:04:48 <Heffalump> but hopefully Haskell threads could handle that.
03:04:54 <andrewa> Heffalump: With the threaded RTS it's all good.
03:05:15 <andrewa> Heffalump: Of course all the Haskell code only ever runs on one thread at a time.
03:05:32 * LeCamarade .oO Looks like fun to just reverse-compile .NET assemblies to GHC. :oD
03:05:44 <DRMacIver> LeCamarade: That would be awesome. :)
03:06:02 <LeCamarade> andrewa: You need some eal prayers.
03:06:09 <andrewa> LeCamarade: Indeed, that's (partly) why I figured I focus on the other direction (Haskell to .NET).
03:06:12 * LeCamarade goes off to locate a nice, warm god.
03:06:17 <andrewa> :-)
03:06:19 <Heffalump> I thought Haskell code can run on multiple OS threads these days.
03:06:26 <dons> right.
03:06:28 <Heffalump> -N 2 to the RTS
03:06:31 <Heffalump> (or whatever)
03:06:35 <dons> +RTS -N2
03:06:41 <dons> and compiled with -threaded runtime
03:06:54 <andrewa> Ah, okay, that's great.
03:07:08 <dons> or , you know, andrewa , +RTS -N32
03:07:09 <ozone> my lord, it's a mkra
03:07:12 <ozone> mrak even
03:07:17 <andrewa> dons: :-)
03:07:17 <blackdog> g'day andre
03:07:20 <dons> hey the whole crew!
03:07:21 <blackdog> long time no talky
03:07:33 <ozone> dons: yeah, now all we need is the gimp!
03:07:36 <ozone> (seafood)
03:07:39 <dons> just like old times.
03:08:00 <LeCamarade> andrewa: I am just curious, here. Would it be unforgivably silly to actually break the .NET assemblies apart (read `steal source from Mono') and turn them into ... and image GHCi can load ... okay, that was stupid of me.
03:08:08 <blackdog> except this time i'm actually doing some work :)
03:08:15 <ozone> blackdog: ha ha, that's funny
03:08:22 <ozone> so when do you wanna go to the pub?
03:08:23 <dons> blackdog: don't scare me.
03:08:43 <blackdog> Tomorrow's good for me :)
03:08:48 <dons> heh. i'm off on holiday :-)
03:08:58 <andrewa> LeCamarade: I think you lost me there :-)
03:09:09 <blackdog> i heard suzie was on holiday and you're hacking in hotels
03:09:14 * LeCamarade backs away from any two oceanians discussing a pub on a Tuesday.
03:09:15 <dons> yeah. well, beach.
03:09:34 <dons> hope i can find some wifi.
03:09:41 <ozone> dons: it's a hard life man
03:09:50 <dons> yeah. so true.
03:09:53 <blackdog> LeCamarade: you're not an alcoholic until you start going to meetings
03:10:21 <dons> ozone: i mean, the question is, pool side or beach side. so hard!
03:10:43 <LeCamarade> blackdog: :oD And even then, not until you get a pseudonym. (andrewa, I'm writing. )
03:10:47 <alan_> all my characters changed on my console because i accidentaly wrote the output of a zip file to the terminal
03:10:48 <ozone> dons: whichever place has the larger amount of female skin showing, obviously
03:10:54 <dons> heh
03:10:58 <alan_> how can i change the characters back to normal
03:11:18 <dons> alan_: 'reset'
03:11:25 <blackdog> ozone: you old horndog...
03:11:43 <alan_> dons: yay dons
03:12:06 <LeCamarade> andrewa: As in, it is silly, of course, but what if one just tried to map the assemblies to a Haskell runtime ... It's not too well-thought-out. Okay, I'll just wait for your results. And I will be hoping hard.
03:12:13 <monn> how will they call haskell on .net? netskell?
03:12:32 <blackdog> Hask Hash
03:12:34 <LeCamarade> monn: H#
03:12:37 <ozone> blackdog: check your messages window, larrikin :)
03:12:58 <olsner> HasCash
03:13:09 <monn> lol
03:13:23 <earthy> HasCash? wazzat? :)
03:13:44 <olsner> say HaskHash
03:13:45 <monn> may be it will simply be haskell.net
03:13:48 <andrewa> LeCamarade: Well, knowing that there's interested people out there is encouraging.  I'm sure I'll work that extra bit harder!
03:13:57 <blackdog> hm. what do you macosxians use for IRC? I'm using irssi and i'm too blind to notice people messaging me...
03:14:09 <olsner> (and listen to what comes out)
03:14:13 <blackdog> hey, whose idea was haskell' ?
03:14:16 <blackdog> the name, i mean
03:14:18 * earthy can find hashcash
03:14:19 <Heffalump> I get a nice red Act flag when someone messages me
03:14:38 <ozone> blackdog: there's colloquy, but that might be a bit too gui for you
03:14:39 <Heffalump> I assume the name is only temporary.
03:14:41 <ozone> (i just use ssh+irssi)
03:14:52 <ozone> that's right, the real name will be Haskell eXtreme
03:14:57 <blackdog> hm. ok. the message is "mark, pay attention"
03:15:03 <blackdog> i actually kinda like haskell'
03:15:03 <monn> is there any firefox distribution for OSX?
03:15:06 <ozone> (in tribute to that dumbass ron jeffries)
03:15:15 <blackdog> it makes no sense to anyone outside the community, which is great :)
03:15:25 <earthy> blackdog: I use irssi as well, but I fan out messages to new windows and have the statusbar highlight activity
03:15:29 <monn> the draconite ron
03:15:31 <earthy> in each window
03:15:58 <LeCamarade> andrewa: And there is a whole bunch of us. Just drop a line and you'll see. There are many people who want your work. The revolution is knocking. :oD
03:17:13 <blackdog> i want irssi with Growl support :) ah well.
03:17:17 * olsner doesn't see what's so cool about .net
03:17:22 <LeCamarade> Non-Haskellers will say the string in Haskell' is not closed.
03:17:23 <andrewa> LeCamarade: :-)
03:18:00 <ski> haskell is open
03:18:13 <ozone> dammit, some domain squatter has the punycode name for lambda.com
03:18:16 <ozone> beeyotch
03:18:18 <LeCamarade> olsner: Well, it runs on the most-common OS around. And we have clients who we can't tell `Okay, just type ``make'' and press Enter!' :oD
03:19:08 <LeCamarade> http://lambda.com
03:19:10 <lambdabot> Title: Welcome to Lambda.com
03:19:10 <andrewa> olsner: The libraries that are available on .NET are pretty cool too.
03:19:20 <LeCamarade> I'd have it, otherwise. :oD
03:19:48 <LeCamarade> ozone: Not really a squatter, it seems.
03:20:00 <dons> ozone, comonad.org is free, I think?
03:20:04 <ozone> no, what you want is xn--wxa.com
03:20:17 <osfameron> @where haskell'
03:20:18 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
03:20:34 <ski> dons : istr edwardk got that ?
03:20:37 <olsner> ozone: squatted
03:20:46 <ozone> olsner: that's what i mean
03:20:55 <dons> ski, yeah. but there's no site now. i wonder if he still has it.
03:21:29 <blackdog> i'm trying to find a representation for a datatype for sorting networks. My current best bet seems to be "SN Int [(Int,Int)]", but it's not really restricted enough - i'd like to be able to specify that the Ints in the list are between 1 and the first Int
03:21:37 * ski could ask .. next time he sees him
03:22:06 <ozone> blackdog: what you do is just post that question on the mailing list.  then oleg will answer it, and your brain will explode, and it's no longer your problem
03:22:07 <monn> blackdog: do you want to do topological sort?
03:22:07 <alan_> blackdog: have  you tried a directed graph?
03:22:41 <blackdog> monn: ... topological sort?
03:22:56 <Heffalump> blackdog: is it really worth the effort of enforcing the restriction in the type system?
03:23:10 <blackdog> Heffalump: it depends how much effort it is, really
03:23:14 <ozone> i'd be inclined to agree with heffy
03:23:22 <Heffalump> I'm sure it's possible with some Oleging, but it's bound to be slightly painful.
03:23:32 <Heffalump> and make your type look less natural
03:23:37 <blackdog> Ok, fair enough.
03:23:44 <ozone> blackdog: not unless you're prepared to do the usual church numerals in type systems stuff
03:24:00 <blackdog> ozone: ugh
03:24:01 <blackdog> yeah, ok.
03:24:17 * LeCamarade wonders why Oleg is not yet in prison. Is that stuff legal? Really? Our morals ...
03:24:29 <blackdog> alan_: how would the digraph rep work?
03:24:42 <blackdog> alan_: i can't quite get the intuition
03:24:51 <alan_> @hoogle topsort
03:24:51 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort :: Graph gr => gr a b -> [Node]
03:24:52 <lambdabot> Data.Graph.topSort :: Graph -> [Vertex]
03:24:52 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort' :: Graph gr => gr a b -> [a]
03:25:07 <Heffalump> data Upto x = Zero | OnePlus x
03:25:37 <Heffalump> Upto (Upto (Upto ())) can represent numbers from 0..3, right?
03:25:51 <Heffalump> 0..2, maybe. You get the general idea.
03:27:47 <blackdog> Heffalump: ok, is becoming clear. but i still get a fair runtime hit, right?
03:28:11 <Heffalump> blackdog: yes.
03:28:21 <Heffalump> you could probably make a binary encoding instead, with yet more syntactic pain
03:28:32 <Heffalump> thus reducing the hit to a constant factor from a linear factor
03:28:50 <blackdog> i guess the pragmatic way is to just export functions to work on the data type and not expose the guts
03:29:02 <Heffalump> yeah
03:29:09 <Heffalump> and use quickCheck to make sure you're on the straight and narrow
03:30:54 <blackdog> ak, that makes sense. Thanks Heffalump.
03:31:14 <ozone> kettle chips, chilli flavour!
03:31:51 <osfameron> yum
03:32:02 <osfameron> I like Jonathan Crisp tabascoe flavour too
03:33:12 <pitecus> is there something like unfoldrM?
03:37:25 <dcoutts> @hoogle unfoldr
03:37:25 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
03:37:26 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
03:37:41 <dcoutts> pitecus: seems not, but I imagine it's simple to define
03:37:45 <ivanm> I asked this before, but no-one answered...
03:37:53 <dcoutts> @hoogle unfold
03:37:53 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
03:37:53 <ivanm> I'm storing a matrix as a list of lists
03:37:53 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
03:37:53 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
03:38:11 <pitecus> fair enough
03:38:17 <ivanm> I want to write a function subSquares that takes in a matrix m and an Int u
03:39:00 <ivanm> the function is to return every possible way of choosing u items that satisfy a predicate, and replace them with a constant value (that doesn't satsify the predicate)
03:39:31 <ivanm> Any ideas?
03:39:37 <dcoutts> ivanm: write one that selects all possible ways of choosing u items first, then filter
03:39:59 <dcoutts> ivanm: ie break it into smaller problems
03:40:05 <ivanm> yeah...
03:40:46 <LeCamarade> ivanm: Sample runs usually come off clearer. (Well, at least for people with perception problems like me :oD)
03:40:52 <ivanm> the only way I've worked out to do it so far is to break it down into (row,column,value) form, filter out the ones that don't match the predicate, take len - u combinations of them, and re-form the matrix
03:41:16 <ivanm> OK, p = (/= 0)
03:41:57 <LeCamarade> ivanm: Like: subSuquares [1, 2, 3] 3 ... returns?
03:42:01 <ivanm> subSquares [[1,0],[2,2] 2 = [ [[0,0],[0,2]] , [[0,0],[2,0]] , [[1,0],[0,0]] ]
03:42:19 <ivanm> LeCamarade: its of type [[Int]] -> Int -> [ [[Int]] ]
03:44:06 * LeCamarade don't get it, still. Wondering if the 2 (-> Int ->) is the length of ([[Int]] ->).
03:44:31 <LeCamarade> Would it be (1, 0) instead [1, 0].
03:44:37 <ivanm> LeCamarade: the first one had 3 elements that match the predicate p = (/= 0)
03:44:50 <ivanm> the results have (3 - 2 = 1) elements that match the predicate
03:46:13 * LeCamarade no get it. Starved, anyway. :o(
03:47:00 <ivanm> heh
03:57:56 <ivanm> dcoutts: still have no idea how I'm meant to write a function that chooses u items...
03:58:19 <ivanm> hmmm.... would it be easier if I concat'ed my list first, then re-split it?
03:59:44 <ndm> @seen dcoutts
03:59:45 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 19m 46s ago.
03:59:50 <ivanm> hey ndm
03:59:54 <ndm> @slap dcouts
03:59:55 <lambdabot> why on earth would I slap dcouts
03:59:59 <ndm> hi ivanm
04:00:00 <ivanm> heh
04:00:06 <ivanm> ndm: maybe you can help me...
04:00:17 <ivanm> I'm storing a matrix as a list of lists
04:00:24 <ivanm> I want to write a function subSquares that takes in a matrix m and an Int u
04:00:36 <ivanm> the function is to return every possible way of choosing u items that satisfy a predicate, and replace them with a constant value (that doesn't satsify the predicate)
04:00:45 <ivanm> any ideas?
04:00:58 <ivanm> the predicate is a global one, as is the constant replacing
04:01:47 <ndm> sounds expensive
04:01:55 <ivanm> heh
04:01:55 <ndm> since you need to find all sub-sets of a set
04:02:00 <ndm> essentially the powerset
04:02:16 <ivanm> well, I've got a function that acts as subSquares m 1...
04:02:45 <ivanm> but, since I then find sub-squares of those sub-squares, I have a double-up, since each second level value will be present twice
04:03:48 <monn> isn't this a dynamic programming (a.k.a working from the ground up) problem?
04:04:01 <pitecus> I have a function which is a bit hairy. It's quite ugly with manual threading of state, but i can't quite figure out how to improve it. Could someone have a look?
04:04:10 <hpaste>  pitecus pasted "ugly code with State" at http://hpaste.org/1738
04:04:13 <ivanm> monn: ummm.... no, I don't think so...
04:04:28 <ivanm> here's an example:
04:04:32 <ivanm> subSquares [[1,0],[2,2]] 2 = [ [[0,0],[0,2]] , [[0,0],[2,0]] , [[1,0],[0,0]] ]
04:04:57 <ivanm> where the predicate I'm using is p = (/= 0), and the constant value is 0
04:07:42 <monn> @hoogle unsplit
04:07:43 <lambdabot> No matches found
04:10:04 <monn> hmm, i only got dfs approach
04:21:32 <nominolo> does anyone know (off of one's head) if SimonM's exception paper requires non-Haskell98 features?
04:23:56 <monn> @hoogle filterM
04:23:56 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
04:23:57 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
04:23:57 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
04:24:04 <marscher> hi
04:24:40 <chyntia> hi
04:24:49 <marscher> how do i filter e.g. isAlpha for a list of strings?
04:25:05 <Igloo> nominolo: Existential types, I think
04:25:46 <marscher> i need a operator to get each Char from the String list
04:26:41 <pitecus> marscher,  map (filter Char.isAlpha)?
04:27:44 <monn> >let chars = map show "haskell" in chars
04:28:37 <monn> why lambdabot doesn't evaluate my line?
04:29:01 <ivanm> try a space after the >
04:29:09 <ivanm> > let chars = map show "haskell" in chars
04:29:11 <lambdabot>  ["'h'","'a'","'s'","'k'","'e'","'l'","'l'"]
04:29:15 <ivanm> see?
04:29:18 <marscher> yeah
04:29:41 <marscher> strings of chars.. but it doesn't work with isAlpha
04:30:05 <pitecus> marscher, what is it you re trying to do?
04:30:15 <ivanm> > let chars = filter isAlpha "haskell\n" in chars
04:30:16 <lambdabot>  "haskell"
04:30:39 <ivanm> oh, a list of strings?
04:30:42 <marscher> > map ( filter isAlpha) ["asdf", "5a5aaa" ]
04:30:44 <lambdabot>  ["asdf","aaaa"]
04:30:47 <monn> ivanm: oh :)
04:30:48 <ivanm> map (filter isAlpha)
04:31:02 <marscher> i need to filter out all strings containing non alpha chars
04:31:08 <chyntia> who have the code of sodoku ?
04:31:08 <ivanm> ahhh
04:31:17 <ivanm> filter (any (not . isAlpha))
04:31:33 <ivanm> chyntia: look on the haskell wiki
04:31:33 <monn> cynthia: http://haskell.org/haskellwiki/Sudoku
04:31:35 <lambdabot> Title: Sudoku - HaskellWiki
04:32:10 <monn> sorry, chyntia not cynthia
04:32:16 <marscher> > filter (any (not . isAlpha)) ["asdf" , "a4asdf" ]
04:32:18 <lambdabot>  ["a4asdf"]
04:32:26 <ivanm> oh, whoops...
04:32:30 <marscher> *g*
04:32:32 <ivanm> filter (all isAlpha)
04:32:37 <ndm> @seen dcoutts
04:32:38 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 52m 40s ago.
04:32:43 <dcoutts_> hia ndm
04:32:47 <ivanm> > filter (all isAlpha) ["asdf", "a4sdf"]
04:32:48 <ndm> hi dcoutts_
04:32:49 <lambdabot>  ["asdf"]
04:33:01 <ndm> dcoutts_ - any news on that installer article? i was hoping to do the winhugs installer today
04:33:20 <ivanm> dcoutts_: I can't even work out how to use your suggestion to find all ways of choosing u elements from a list of lsits
04:33:22 <ivanm> *lists
04:33:31 <monn> > isAlpha '4'
04:33:33 <lambdabot>  False
04:34:03 <dcoutts_> ndm: the advice comes down to just this: grab this .zip file of .dll files, unpack it and put your .exe in the bin/ dir.
04:34:21 <dcoutts_> ndm: http://haskell.org/gtk2hs/win32/gtk+-2.10.9-win32.zip
04:34:44 <ndm> dcoutts_ - i want to use the same installer, but to install a C program (WinHugs), which installer was it that you used to create it
04:34:47 <dcoutts_> ndm: and a demo I did earlier: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
04:34:55 <ndm> dcoutts_ - and do you have any advice on where to start etc
04:35:02 <ndm> i don't want to install Gtk2Hs programs :)
04:35:19 <dcoutts_> ndm: InnoSetup, it's free and scriptable with pascal
04:35:43 <dcoutts_> ndm: I thought you did, that's why you were asking me about this article about deploying gtk2hs apps :-)
04:36:08 <ndm> dcoutts_ - miscommunication :)
04:36:15 <ndm> dcoutts_ - scriptable with pascal? yuk!
04:36:50 <dcoutts_> ndm: it's not too bad actually. I've used worse commercial products that cost .
04:37:33 <chyntia> thx
04:37:55 <ndm> dcoutts_ - mild pain is not hte recommendation i was looking for ;)
04:38:03 <dcoutts_> ndm: anyway, it's probably that or VB script. Though I've hear you don't hate VB script that much :-)
04:38:12 <hpaste>  marscher pasted "(no title)" at http://hpaste.org/1739
04:38:19 <dcoutts_> ndm: windows installers are always painful. always.
04:38:25 <marscher> plz take a look ;)
04:38:31 <marscher> trivia
04:38:32 <dcoutts_> ndm: mild pain is the best you'll find.
04:39:50 <ndm> dcoutts_ - vbscript is doable, pascal is a bit nasty, but i did know it once... - yeah, i know mild pain is a good result - will take a shot today
04:40:07 <dcoutts_> ndm: first job I was given when I joined an AV company was to write a new installer using a commercial msi installer builder. The complexity of the msi installer technology and the number of bugs in that system is quite staggering.
04:40:25 <marscher> my question is in the commentary in the post
04:40:48 <ivanm> any idea how to take a list of value lst and a number u, and find all ways of replacing u items in that list that match a predicate with another value?
04:41:06 <dcoutts_> ndm: so the only downside of inno setup is that it doesn't build .msi installers. Some people might see that as a benefit though.
04:41:55 <ndm> dcoutts_ - i see it as couldn't care less, so thats fine then
04:42:05 <dcoutts_> good good :-)
04:42:22 <dcoutts_> ivanm: just asking the same thing again probably does not help much, have you tried tacking the sub-problems ?
04:42:34 <ivanm> dcoutts_: well, I have split it up a bit...
04:42:42 <ivanm> but AFAICT, that _is_ the sub-problem
04:42:58 <ivanm> and I really have no idea how to do it, efficiently at least
04:43:15 <dcoutts_> ivanm: how about finding all ways of splitting a list into two lists
04:43:41 <dcoutts_> ivanm: lists representing sets I presume
04:43:59 <ivanm> dcoutts_: no, order is important
04:44:06 <Heffalump> I don't even understand your specification.
04:44:09 <ivanm> and that's what makes it tricky, IMO
04:44:14 <dcoutts_> ivanm: ah, so it's just sub-lists
04:44:37 <marscher>  http://hpaste.org/1739 why is "cc" missing in the output?
04:44:50 <Heffalump> but yeah, why not start by writing a function that constructs all sublists of a given list. Perhaps using the non-determinism (list) monad
04:45:08 <ivanm> Heffalump: because that will be too inefficient?
04:45:13 <pitecus> marscher, you throw away the a in a:as
04:45:16 <dcoutts_> marscher: how about using map ?
04:45:45 <dcoutts_> marscher: actually, ignore my suggestion
04:45:45 <Heffalump> marscher: does your definition really not have brackets around the a:as at the left?
04:45:49 <ivanm> Heffalump: I'd like to have it as deterministinc as possible
04:46:14 <dcoutts_> ivanm: it'll always be deterministic
04:46:14 <astrolabe> ivanm: You might be too ambitious if you want to solve the problem, and solve it efficiently at the same time.
04:46:23 <Heffalump> ivanm: well, I suggest you start by writing an inefficient version that's easy to read. Then optimise.
04:46:33 <marscher> Heffalump, yes it has
04:46:34 <ivanm> hmmm....
04:46:35 <ndm> dcoutts_ - apparently i must be logged in as an admin to run the setup for inno installer - is that true of the installers it creates, and is there no way to install it without admin?
04:47:01 <marscher> filterStrings (a:as) = map (filter (any isAlpha) ) a:as
04:47:08 <ivanm> Ok, so you're saying I need to find a way to generate all sublists from a list...
04:47:10 <LeCamarade> astrolabe: Worse is Better.
04:47:17 <LeCamarade> ivanm: Worse is Better.
04:47:20 <ivanm> not _quite_ sure how substrings will help
04:47:23 <ivanm> LeCamarade: heh
04:47:29 <dcoutts_> ndm: it has a flag that sets whether you need to be admin to use the installer, by default it's true but if you know you don't need it then you can turn it off.
04:48:01 <ndm> dcoutts_ - but for its installer, can you install it without admin?
04:48:02 <LeCamarade> marscher: You don't include a in your func body, hence why it is not there.
04:48:11 <dcoutts_> ndm: if you can't actually install it due to the admin problem (and I can't) then use a slightly older version and click ignore when it tries to set a couple admin registry things
04:48:15 <Heffalump> marscher: ok, so you should just write as, not (a:as)
04:48:17 <gour> ndm: when will you upgrade your OS? ;)
04:48:20 <kolmodin> I'm sure someone must have written a portage thingie for windows, or like the freebsd package management?
04:48:33 <Heffalump> and you don't want that map. Stop guessing, and think about what the functions actually do :-)
04:48:46 <LeCamarade> > let fs (a:as) = as in fs ["cs", "55"]
04:48:48 <lambdabot>  ["55"]
04:48:54 <dcoutts_> ndm: so for the installers you create with it you'll be fine, for it's own installer, either become admin or use a slightly older version and ignore the warnings.
04:48:57 <ndm> kolmodin: monkeys writing software scrip kiddies
04:49:11 <ivanm> kolmodin: what, geNToo?
04:49:13 <ivanm> its dead
04:49:37 <Zr40> wasn't that an april fools joke?
04:50:18 <ivanm> no, Redhatter actually started work on it
04:50:19 <ivanm> then gave up
04:50:48 <dcoutts_> ndm: if you want some example code, see the gtk2hs.iss
04:51:28 <kolmodin> ndm: what? I didn't get that at all :)
04:52:03 <ndm> kolmodin: they usually are written by idiots, for 12 year old script kiddies - no one has done a serious and good package management who had the brains to understand what it meant
04:52:11 <ivanm> dcoutts_, Heffalump: the only way I can think of getting the sub-lists is to take combinations of u elements from the list, then convert the list to an array, do array replacement and then get the list back
04:52:19 <pitecus> I want to build a list of IO actions with unfoldr when item n depends on item n-1. I have a sketch of the function f to pass to unfoldr
04:52:21 <pitecus> f x = if final x then Nothing else Just (do { y <- ask x ; return y },new y x)
04:52:28 <kolmodin> ndm: that's too bad
04:52:29 <Heffalump> ivanm: think about how to generate all sub-lists, not just those of length u.
04:52:36 <Heffalump> Then filter the list of sub-lists for those of length u.
04:52:37 <pitecus> But the y in "new y x" is not in scope
04:52:51 <ivanm> Heffalump: no, I need to replace u elements in the original list...
04:52:51 <pitecus> Is there a way of achieving something like that?
04:52:55 <kolmodin> ndm: there seem to be some comersial alternatives, used for companies
04:52:57 <ivanm> _not_ get lists of length u
04:53:11 <Heffalump> well, you could number the elements in the original list first
04:53:19 <ndm> kolmodin: .msi was meant to sort this all out, but so many .msi's are just a bit broken that it doesn't work...
04:53:26 <dcoutts_> ivanm: don't think of it as replacing things in the original list, you're generating a new list based on bits of the old one.
04:54:10 <kolmodin> ndm: I guess you don't need dependencies in the same way as most linux distros does, as you distribute binaries
04:54:21 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/1739#a1
04:54:40 <marscher> ^^
04:55:17 <ivanm> hmmmm....
04:55:36 <Heffalump> marscher: presumably that doesn't type check?
04:55:36 <marscher> it makes me headaches :D
04:56:18 <LeCamarade> marscher: I don't think your new one solves your old problem ... you seemed to be misunderstanding the pattern thing.
04:56:32 <marscher> perhaps
04:56:48 <LeCamarade> marscher: You're new, right? (Trying to put it in perspective.)
04:58:09 <marscher> LeCamarade, yeah bloody new :)
04:58:21 <pitecus> I could also use unfoldrM to get IO [a] instead of unfoldr to get [IO a] but I want a lazy list...
04:59:01 * LeCamarade prides himself in dealing _well_ with new Haskellers. Lemme go off and re-write your function for you with lots of explanations. Waiting?
05:00:00 <osfameron> yay!
05:00:23 <ozone> googling for "goto monad" turns up 4 hits, woot
05:02:16 <Heffalump> you are a sick, sick man
05:03:24 <ozone> now all we need is a ComesFrom monad
05:03:31 <dcoutts_> pitecus: you could use unfoldr and unsafeInterleaveIO
05:03:31 <joelr1> good day
05:03:40 <joelr1> @seen JaffaCake
05:03:40 <lambdabot> I saw JaffaCake leaving #haskell-soc, #ghc and #haskell 3h 38m 5s ago, and .
05:04:17 <pitecus> dcoutts, newbies arent supposed to use that i thought?
05:04:58 <dcoutts_> pitecus: well, perhaps there's another way of solving it, but the basis of lazy io is unsafeInterleaveIO
05:05:19 <dcoutts_> unsafeInterleaveIO is not nearly as scary as unsafePerformIO
05:05:35 <pitecus> isn't it? OK I'll look at it
05:05:52 <dcoutts_> @hoogle unsafeInterleaveIO
05:05:53 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
05:06:42 <dcoutts_> @src sequence
05:06:43 <lambdabot> sequence ms = foldr k (return []) ms
05:06:43 <lambdabot>     where
05:06:43 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
05:09:09 <joelr1> do :set -odir and :set -hidir work for anyone in ghci?
05:09:52 <dcoutts_> @paste
05:09:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:09:56 <Heffalump> does ghci produce .hi and .o files?
05:10:05 <hpaste>  dcoutts pasted "unsafeInterleaveIOs" at http://hpaste.org/1740
05:10:13 <dcoutts_> pitecus: ^^
05:10:44 <pitecus> thanks dcoutts
05:10:56 <joelr1> Heffalump: it searches for them
05:11:02 <LPhas> anyone knows if HDBC is lazy?
05:11:20 <Heffalump> aren't those just for directing output, though?
05:11:28 <Heffalump> -i is how you tell it where to look for stuff
05:11:34 <Heffalump> I may be confused.
05:12:16 <joelr1> Heffalump: i'm trying to tell ghci that my hi and o files are in a different directory from my source code
05:12:39 <Heffalump> ah, so you've compiled stuff but want it to read in the compiled versions from a different directory?
05:12:49 <joelr1> Heffalump: right
05:12:50 <hpaste>  dcoutts annotated "unsafeInterleaveIOs" with "or lazy in the elements rather than the spine" at http://hpaste.org/1740#a1
05:12:57 <dcoutts_> pitecus: so it's a slightly dangerous weapon :-)
05:12:58 <Heffalump> have you tried using -i and -L?
05:13:13 <joelr1> Heffalump: i'm running from within emacs so i'm trying with :set
05:13:27 <Heffalump> ok, have you tried setting those flags?
05:13:36 <joelr1> Heffalump: there's a thread in ghc-users, sec
05:13:50 <joelr1> Heffalump: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-April/012438.html
05:13:52 <lambdabot> Title: ghci module load path, http://tinyurl.com/yqxla2
05:13:53 <pitecus> dcoutts,  However the main problem is that i don't see how i can use the result of the IO action to create a new seed for unfoldr
05:14:17 <Heffalump> ah, ok. I'm just ignorant, then.
05:14:32 <dcoutts_> pitecus: if you do need to use the result of the IO action to get the next seed then it's a bit harder
05:14:37 <pitecus> I need the y in "new y x" in f x = if final x then Nothing else Just (do { y <- ask x ; return y },new y x
05:14:43 <Heffalump> (sorry for being unhelpful)
05:15:00 <dcoutts_> pitecus: you're probably better off just doing a direct recursive thing using unsafeInterleaveIO directly.
05:15:24 <dcoutts_> pitecus: look at the pattern of the functions I pasted
05:15:31 <pitecus> dcoutts, OK will do
05:15:33 <pitecus> thanks
05:18:11 <chell> hey
05:18:19 <Heffalump> 'lo
05:18:27 <chell> I'm currently learning functional programming with haskell, I'm using the wikibooks book to do that
05:18:33 <chell> however, I'm stuck (using ghci)
05:18:55 <chell> I'm creating a symbol(?) pi = 3.14
05:19:08 <Heffalump> defining a value, is how it's normally phrased
05:19:12 <Heffalump> anyway, go on.
05:19:16 <chell> then a function for calculating a circle's area: let area r = pi * r^2
05:19:35 <Heffalump> If you want to do that at a ghci interactive prompt, you need to say let pi = 3.14, but since you seem to know how to do that for area I guess you realise that.
05:19:36 <chell> then a function for calculating a cylinder's volume: let volume h r = h * area  r
05:19:45 <Heffalump> looks good so far
05:19:50 <chell> when I call the cylinder function
05:19:55 <chell> I get the following area
05:20:10 <Heffalump> @type (^)
05:20:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:20:35 <chell> <interactive>:1:0:
05:20:35 <chell>     No instance for (Show (Double -> Double))
05:20:36 <chell>       arising from use of `print' at <interactive>:1:0-7
05:20:36 <chell>     Possible fix:
05:20:36 <chell>       add an instance declaration for (Show (Double -> Double))
05:20:36 <chell>     In the expression: print it
05:20:37 <chell>     In a 'do' expression: print it
05:20:42 <chell> sorry for the long paste ;-)
05:20:48 <Heffalump> did you call it with two arguments?
05:21:04 <Heffalump> all it's telling you is that what you did produced a function from Double -> Double, and it doesn't know how to print that out
05:21:17 <Heffalump> (there's a paste bucket, http://hpaste.org/new, for long pastes)
05:21:29 <chell> in the wikibook it doesn't mention that the function doesn't work
05:21:35 <Heffalump> got a URL?
05:21:38 <chell> yeah
05:21:41 <chell> http://en.wikibooks.org/wiki/Haskell/Variables_and_functions
05:21:44 <chell> bottom of the page
05:21:58 <Heffalump> it does "work", just ghci can't print it out
05:22:10 <chell> ah I see
05:22:22 <chell> I guess I'll learn why after finishing the book
05:22:29 <chell> thanks for your help
05:22:33 <Heffalump> I don't quite see where it tells you to do what you did.
05:22:45 <Heffalump> if you call "volume 3.5 2.5" (say), it should work fine
05:22:53 <chell> ah
05:22:54 <chell> yeah
05:22:55 <chell> I forgot
05:23:02 <chell> Haskell doesn't let me do Integer * Double right
05:23:06 <Heffalump> it's just that you called "volume 3.5", and since you haven't yet provided one argument, you get a function that needs one more argument
05:23:09 <Heffalump> not directly, that's right
05:23:15 <Heffalump> @type fromIntegral
05:23:16 <ivanm> OK, I don't mean to be a pain or anything, but I _still_ can't work out how to find all sublists and how that will be relevent to what I want
05:23:18 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:23:27 <Heffalump> but that function will convert your Integer into a Double
05:23:57 <pitecus> chell there is the module Text.Show.Functions which defines the Show instance for functions so you dont get those confusing erros
05:24:10 <chell> ok
05:25:39 <chell> so far I really like functional programming
05:25:55 <chell> I've only been doing procedural and object-oriented programming in the past, so this is something entirely new
05:26:38 <Heffalump> ivanm: all sublists is easy: sublists [] = [[]], sublists (x:xs) = let ys = sublists xs in ys ++ map (x:) ys
05:26:57 <chell> One question though: In the book it says that "variables" in haskell (stuff defined with let) does not change
05:26:58 <ivanm> ahhh, OK, yeah, I get that...
05:27:08 <ivanm> Heffalump: so how is it relevant to what I want?
05:27:13 <chell> but when I do: let a = "hello" and then let a = 20 it works
05:27:24 <chell> and a has changed to 20
05:27:28 <Heffalump> ivanm: well, one way of solving your problem would be first to number your original list (zip [0..] xs)
05:27:39 <ibid> chell: you're making a new variable with the same name, not changing hte variable
05:27:41 <ivanm> *nod*
05:27:43 <Heffalump> then get all sublists, then filter them for length u, then apply your predicate, and finally write a function to do the replacement
05:27:45 <dons> nice, nominolo, http://programming.reddit.com/info/1oae7/comments
05:27:46 <lambdabot> Title: Towards Better Error Handling (in Haskell) (reddit.com)
05:27:52 <ibid> chell: variable shadowing, iow
05:28:08 <chell> so the other one is still there, just inaccessible
05:28:12 <ibid> chell: yep
05:28:15 <chell> okay
05:28:15 <chell> thanks
05:28:49 <ivanm> Heffalump: yeah, OK, I get that... but for that I could probably make it more efficent by filtering by predicate, taking combinations of u elements, then replacing
05:28:53 <Heffalump> well, it might have got garbage collected, being inaccessible
05:29:08 <Heffalump> ivanm: I don't quite follow, but fair enough.
05:29:13 <Heffalump> what do you need help with, then?
05:29:31 <chyntia> the gui of sodoku?
05:29:32 <chell> so because it is inaccessible, it automatically gets deleted?
05:29:51 <nominolo> dons: are you asking me to add a comment?
05:29:57 <Heffalump> chell: well, it could be, since there's a garbage collector
05:30:02 <Heffalump> I dunno if ghci actually does or not.
05:30:02 <chell> ah
05:30:13 * Heffalump disappears for a while
05:30:15 <ivanm> Heffalump: OK, I'll try that then
05:30:19 <ivanm> cya Heffalump!
05:30:24 <ivanm> @karma++ Heffalump
05:30:25 <lambdabot> Heffalump's karma raised to 7.
05:30:57 <nominolo> dons: ok, no, that was just the reason. thanks :)
05:33:33 <malcolmw> > let a = "hello" in (let a = 20 in a, a)
05:33:41 <lambdabot>  (20,"hello")
05:33:43 <chell> when I have a list of lists, can that list only contain lists (I assume so)
05:33:52 <chyntia> where i can find the code of  sadoku?with gui?
05:37:50 <monn> i got this memoization (not dp/stream) version of fibonacci : http://www.kimbly.com/blog/000263.html
05:38:35 <monn> what is the meaning of first line?
05:39:51 <hpaste>  monn pasted "memoized fib" at http://hpaste.org/1741
05:40:20 <glauber_sp> hi guys! Does anyone work with Isabelle or Coq here?
05:40:42 <pitecus> monn it looks like a section, i.e. a curried operator
05:41:22 <pitecus> >  ("abcd"!!) 2
05:41:31 <lambdabot>  'c'
05:42:31 <osfameron> @src dropWhile
05:42:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:45:27 <MarcWeber> dons: I had another look at the xmonad page. I think you might want to add http://www.suckless.org/wiki/wmii to the list of links of related work.
05:45:29 <lambdabot> Title: about &mdash; wmii &mdash; suckless.org
05:46:01 <MarcWeber> Oh. dwm is related. Sorry for this stupid comment.
05:46:07 <monn> pitecus: is that same with this one?
05:47:12 <dons> MarcWeber: same one, yeah.
05:47:17 <pitecus> aha
05:47:17 <dons> wmii -> dwm.
05:48:17 * earthy grumbles at Doaitse
05:48:23 * earthy grumbles a bit more
05:48:59 <dons> monn: there's a nice one here, http://www.cubbi.org/serious/fibonacci/haskell.html (just found this today)
05:49:00 <earthy> making his parser combinators depend on Ord for equality-comparison! *BLECH*!
05:49:00 <lambdabot> Title: cubbi.com: fibonacci numbers in Haskell
05:49:13 <dons> monn: also, did you see the mailnig list thread on memoising fibonacci?
05:49:27 <dons> monn: this one, http://comments.gmane.org/gmane.comp.lang.haskell.cafe/19623
05:49:29 <lambdabot> Title: gmane.comp.lang.haskell.cafe
05:49:43 <hpaste>  monn pasted "memoized fib 2" at http://hpaste.org/1742
05:51:44 <Heffalump> earthy: what's he done?
05:52:19 <monn> dons: I got a thread in comp.lang.scheme discussing about fibonacci (which leads me to http://www.kimbly.com/blog/000263.html)
05:54:16 <monn> dons: I miss that one :(
05:57:24 <hpaste>  mdmkolbe|work annotated "memoized fib 2" with "Make the memoization more explicit" at http://hpaste.org/1742#a1
05:57:33 <mdmkolbe|work> monn: are you sure that is properly memoized?  Don't you need something like http://hpaste.org/1742#a1
05:57:51 <glauber_sp> does anyone here work or study HasCASL here?
05:57:54 <monn> are http://hpaste.org/1741 and http://hpaste.org/1741 identical?
05:57:57 <earthy> heffalump: his parser combinators do not need Eq
05:58:02 <earthy> however, they do need Ord
05:58:05 <earthy> on the tokens
05:58:28 <earthy> and he uses case compare t1 t2 of  EQ ->     as his equality test
05:58:59 <dblhelix> doesn't Ord imply Eq!?
05:59:09 <mdmkolbe|work> monn: 1741 and 1742#a1 are identical
05:59:09 <dblhelix> @src Ord
05:59:10 <lambdabot> class  (Eq a) => Ord a  where
05:59:10 <lambdabot>     compare      :: a -> a -> Ordering
05:59:10 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:59:10 <lambdabot>     max, min         :: a -> a -> a
05:59:27 <earthy> dblhelix: it does. however, try this situation: your tokens have a *custom* Eq
05:59:38 <dblhelix> okay
05:59:42 <earthy> and a derived Ord because there really is no semantically valid Ord for your tokens
06:00:16 <earthy> now, even if t1 == t2 you might end up with    parse (pSym t1) [t2]  failing
06:00:35 <mdmkolbe|work> I think 1742 might not be the same as 1741/1742#a2 b/c each entry into the function "fib" will cause a new let binding to be entered which may (I'm not sure about this) cause a new allocation and thus wouldn't be memoized
06:00:38 <dblhelix> earthy: I've to admit I'm not sure how the derived Ord instance is defined then... I take it does *not* use the custom Eq
06:00:45 * earthy nods
06:00:54 <earthy> this is highly, and I do mean *highly* counterintuitive
06:00:55 <monn> mdmkolbe|work: thanks
06:01:08 * ndm spots another paper that incorrectly references S. P. Jones
06:01:15 <earthy> ndm: oh? :)
06:01:32 <earthy> as in: S. P. Jones rather than S. Peyton Jones ? :)
06:01:34 <ivanm> so, what is more efficient, concat . filter, or filter . concat?
06:01:38 * ivanm guesses the former
06:01:42 <ndm> earthy: yeah, its S. Peyton Jones - but bibtex always (by default) gets it wrong
06:01:51 * earthy nods
06:01:57 <earthy> you can force it not to, IIRC
06:02:06 <ndm> yeah {Peyton Jones}
06:02:14 <earthy> indeed
06:02:18 <augustss> you need a non-breaking space
06:02:18 <ndm> or define an spj macro
06:02:28 <mdmkolbe|work> ndm: would Peyton~Jones also force it to work right?
06:02:33 <ivanm> make that concat . map (filter p) compared to filter p . concat
06:02:38 <ndm> mdmkolbe|work: i never know these things...
06:02:38 <monn> mdmkolbe|work: can you please tell me the definition of fib in 1742 and 1742b?
06:02:45 <dblhelix> earthy: however, imho the implementor of the token type (you ;)) is to blame; he should take care of mutually consistent instances of Eq and Ord
06:02:56 <ndm> its just in this case its a paper from the guy who sits next to me, and got submitted yesterday - he should know better
06:02:59 <mdmkolbe|work> monn: http://hpaste.org/1742#a1
06:03:07 <earthy> dblhelix: true enough
06:03:19 <earthy> but there is *no* documentation on this, and Doaitse had not mentioned it
06:03:26 <earthy> (and I *specifically* asked
06:03:26 <earthy> )
06:03:44 <earthy> so I still feel fine grumbling. :)
06:03:49 <mdmkolbe|work> monn: I'm not sure I understand your question.  Are you asking why they are different (i.e. one memoized and the other doesn't)?
06:03:57 <dblhelix> since this is a logged channel, I will remain silent on this... ;-)
06:04:14 <kosmikus> this is getting interesting
06:04:48 <dblhelix> is it? :-)
06:05:07 <LeCamarade> ehird`: I am actually lovin' zsh. Lots.
06:05:36 <earthy> dblhelix: yeah, you still want his signature, right? :)
06:05:59 <dblhelix> earthy: somewhere in 2009, yes
06:08:11 <monn> mdmkolbe|work: yup
06:08:13 <earthy> dblhelix: btw, what makes you think there are non-logged channels? :)
06:08:33 <dblhelix> :-)
06:09:49 <monn> mdmkolbe|work: if I have this application, let z = fib 10 + fib 20, how many result will be created in memory?
06:10:26 <monn> mdmkolbe|work: (in 1742 and 1742#a1)
06:11:46 <haskellnew> type Parser a = String->[(a,String)] , does it mean that Parser a  is  a type  of String  which can be expressed as [(a,String)]
06:12:16 <mdmkolbe|work> monn: 1742#a1 will create only one array in memory of length 20.  1742 will create *lots* of arrays.  Let me see if I can explain why.
06:12:30 <syntaxfree> haskellnew: it means Parser a is a type of function.
06:12:55 <monn> mdmkolbe|work: great :)
06:14:11 <mdmkolbe|work> monn: With 1742 you have a function 'fib n', so everytime that function is entered the let binding inside it is also entered.  You and I know that the binding is a constant, but the GHC compiler may not be smart enough to realize that.  So the *binding* and thus the allocation could be executed for every entry into the function.
06:14:34 <earthy> haskellnew: http://www.willamette.edu/~fruehr/haskell/seuss.html
06:14:36 <lambdabot> Title: Dr. Seuss on Parser Monads
06:15:36 <mdmkolbe|work> monn: With 1742#a1, 'fib' is bound to a let binding directly.  The function doesn't appear until the inside of the let binding.  So the same binding will be used by each call of the function.
06:15:37 <haskellnew> thanks  syntaxfree and earthy , last question  please expand item2::Parser (Char , Char)  means
06:15:58 <earthy> is this homework? :)
06:16:11 <earthy> item2: is a parser that returns a tuple of 2 characters
06:16:14 <monn> mdmkolbe|work: great explanation!!
06:16:23 <monn> mdmkolbe|work: how can I thank you?
06:16:53 <earthy> i.e. a function that takes a string and returns a list of tuples of tuples of 2 characters an strings
06:16:55 <mdmkolbe|work> monn: Again I'm not sure whether GHC will be smart enough to make the let bindings in 1742 constant, but I *am* sure that 1742#a1 will make them constant (comparing run time is the best way to be sure)
06:17:45 <haskellnew> no no , i stuck at some example of book  , thanks ill get back here after few hrs , thanks for explanation
06:18:01 <monn> mdmkolbe|work: ok, left the test to me :)
06:19:19 <monn> mdmkolbe|work: is there any implicit memoization facility in haskell system?
06:20:05 <monn> so that we don't need to create explicit memo like 1742#a1
06:20:07 <ndm> dcoutts - does your installer change the %PATH% at all?
06:20:18 <dcoutts_> ndm: yep, the user's path
06:20:39 <earthy> haskellnew: okay, no probs. good luck!
06:20:56 <dcoutts_> ndm: this is of course the least pleasant aspect of the installer
06:21:08 <ndm> dcoutts_ yeah, the docs didn't make it look easy...
06:21:24 <ndm> dcoutts_ where exactly is the installer .iss
06:21:25 <mdmkolbe|work> monn: there are example of general memoization (i.e. for any function) floating around, but they all require some kind of memo to be passed around (though sometimes implicitly like a Monad)
06:21:44 <ndm> ah, got it now
06:21:56 <dcoutts_> ndm: http://darcs.haskell.org/gtk2hs/tools/win32/gtk2hs.iss
06:22:07 <ndm> eeek, thats quite a bit of pascal
06:22:18 <dcoutts_> yeah
06:22:30 <dcoutts_> ndm: because people keep asking me to add checks and custom UI elements
06:23:05 <dcoutts_> ndm: and there are approximately a million ways we can fail to find ghc :-)
06:23:05 <monn> mdmkolbe|work: oh, I'll try to search another example
06:23:25 <dcoutts_> ndm: and many more ways we can have the path be messed up
06:23:26 <ndm> dcoutts_ would it be easier if GHC always set some registry key saying where it was?
06:23:46 <dcoutts_> ndm: it does do that, but we don't always use the installer
06:23:56 <ndm> ah
06:24:16 <dcoutts_> ndm: so I check for ghc on the path first, then look in various places in the registry
06:24:31 <monn> mdmkolbe|work: many thanks, sorry for my ignorance
06:24:38 <dcoutts_> ndm: then check that ghc does actually exist in the location claimed
06:24:50 <dcoutts_> and that it's a suitable version
06:25:00 <mdmkolbe|work> monn: we all have to start somewhere :-)
06:25:16 <dcoutts_> and if it isn't a suitable version we try and look for another version that is suitable
06:26:11 <monn> mdmkolbe|work: yeah, but some people start well and other not :)
06:27:50 <monn> good night all! see you!
06:38:06 <haskellnew> ok, i am getting "Type error in explicitly typed binding" , i have one function "returns :: a->Parser a" and another function "item2 :: Parser (Char, Char)" where in item2 in the end i call "returns (x,y)" , since "Parser (Char,Char) is equivalent to Parser a" hence the return type is same rt ? and i have "type Parser a = String->[(a,String)]"
06:40:22 <monn> :q
06:42:48 <ski> haskellnew : " .. the return type is the same rt ?" ?
06:43:27 <ski> maybe it would be simplest if you pasted the code (and error message) in question ?
06:43:32 <ski> @where paste
06:43:32 <lambdabot> http://paste.lisp.org/new/haskell
06:43:50 <ski> actually
06:43:54 <ski> !hpaste
06:44:10 <ski> !paste
06:44:10 <hpaste> Haskell paste bin: http://hpaste.org/
06:44:18 <ski> ah, there you are, hpaste :)
06:44:33 <kosmikus> different bot?
06:44:37 <Saizan> ?where+ paste http:/hpaste.org/new
06:44:37 <lambdabot> Done.
06:45:04 <Saizan> kosmikus: yes
06:45:13 <ski> (actually, me sortof preferred lisppaste .. but whatever)
06:45:17 <kosmikus> why?
06:45:23 <ski> i don't know
06:46:01 <Saizan> at the time lisppaste was often laggy or down, and glguy was willing to try HAppS :)
06:46:30 <kosmikus> the Q is not why hpaste rather than lisppaste, but why it isn't handled by lambdabot
06:47:16 <dolio> @hpaste
06:47:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:48:33 <Saizan> hpaste bot and website are the same process, so we should either insert an HAppS process inside lambdabot or change the website so that it can send announces through http
06:48:49 <kosmikus> I see
06:49:12 <hpaste>  haskellnew pasted "Parser" at http://hpaste.org/1743
06:49:14 <kosmikus> if the information is provided by lambdabot, it's fine with me
06:49:49 <haskellnew> ok , i pasted it  :)
06:50:30 <ski> haskellnew : you need to use 'newtype' or 'data', and make an 'instance Monad ...', to use the 'do'-notation with your monad
06:51:27 <ski> @undo do { x <- item; item; y <- item; returns (x,y) }
06:51:28 <lambdabot> item >>= \ x -> item >> item >>= \ y -> returns (x, y)
06:51:54 <DRMacIver> Oh, neat.
06:51:55 <ski> that is what your 'do'-block expands to (more or less) .. so you need to define '(>>=)'
06:52:33 <ski> and since that is overloaded in the 'Monad' class, you need to make a instance of that .. and to do that, you can't use a type sysnonym (using 'type' as you are)
06:52:45 <ski> haskellnew : questions ?
06:53:20 <ski> (s/sysnonym/synonym/)
06:54:01 <Saizan> so ghc was trying to use the reader monad?
06:54:16 <ski> (i think so, yes)
06:54:40 <ski> (.. or, just error ..)
06:55:44 * ski is not sure, actually
06:55:45 <haskellnew> i see , ok let me go back and try it thanks , i think i got it now :) :)
06:56:04 <ski> haskellnew : btw, are you using hugs or ghc (or other) ?
06:56:09 <ski> (*dang* :)
06:59:35 <fridim> hugs happens to be faster than ghci, but ghc is written in haskell 8-)
07:00:05 * ski was about to note a hugs-specific extension ..
07:00:39 <fridim> who said in LaTeX ?
07:00:40 <fridim> :)
07:01:09 <ski> ?
07:01:27 <fridim> ghc has a lot of .lhs
07:01:38 <DRMacIver> Hm. I think I've just lightbulbed as to how do notation works. Yay. :)
07:02:00 <ski> @arr
07:02:00 <lambdabot> Arrr!
07:02:10 <DRMacIver> (For some reason I've never been able to wrap my head around the desugaring process)
07:02:19 <ski> (<http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> in case anyone's interested)
07:02:28 <ski> @src do
07:02:28 <lambdabot> Source not found. That's something I cannot allow to happen.
07:02:32 <ski> bah! :)
07:03:38 <DRMacIver> I wish Haskell code had more brackets. :)
07:04:40 <_Stinger_> eek die
07:04:42 <_Stinger_> ;)
07:04:55 <ski> you can always denounce significant-indentation, and use brackets and semis instead, if you like
07:05:13 <ski> (but people may want to avoid reading your code)
07:05:16 <LeCamarade> DRMacIver: It's a sin, what you just said. More brackets?
07:05:22 <DRMacIver> ski: I do.
07:05:23 <Stinger> one of the things that attracted me to haskell was its neatish syntax
07:06:01 <ski> DRMacIver : or .. you could have a look at liskell :)
07:06:20 <DRMacIver> I find that having to know what the precedence of all the operators is in order to mentally parse what the code means can be very disconcerting.
07:06:30 <DRMacIver> ski: I don't want *that* many more brackets. :)
07:06:54 <ski> DRMacIver : i thought the lispers say the parens are invisible ?
07:07:13 * DRMacIver is not a lisper
07:08:03 <therp> liskell yeah! :)
07:08:06 <Saizan> well, most of the time you just have to know that function application wins
07:08:20 <therp> oh btw. the liskell branch for ghc-6.6(.1) is ready. http://liskell.org/
07:08:22 <lambdabot> Title: About Liskell
07:08:27 <therp> is should announce it properly on my blog.
07:08:31 <dolio> It's also handy to know that $ loses.
07:08:34 <therp> s/is/I/
07:08:54 <Saizan> dolio: yes :)
07:09:19 <dolio> Even when you might not want it to.
07:09:24 <LeCamarade> dolio: $ loses?
07:09:44 <dolio> $ has lower precedence than every other operator, I think.
07:09:53 <dolio> At least, I don't know of a lower one off hand.
07:10:06 <DRMacIver> Well it has a precedence of 0. You can define other 0 precedence operators.
07:10:36 <dolio> Yeah. I'm not sure if there are any in the standard libraries, though.
07:10:37 <Heffalump> therp: so why would one want to use liskell rather than TH?
07:10:45 * LeCamarade started writing OCaml code with $. Had to clone it. :oD
07:10:51 <Saizan> dolio: an example where you don't want $ to "lose"?
07:11:19 <DRMacIver> I still want XMLiskell. ;)
07:11:25 <therp> heffalump: syntax sugar
07:11:46 <therp> heffalump: syntax sugar can be = embedding a complete new language (like scheme, prolog, whatever)
07:11:57 <dolio> Saizan: I think I've accidentally written code that looked like 'a $ b >>= c' or 'b >>= a $ c' before where I wanted '(a $ b) >>= c' instead of 'a $ (b >> c)'. I can't recall the exact example, though.
07:12:11 <therp> drmaciver: no please, I rewrote my liskell.org websites in a lisp-to-html markup language because I couldn't stand the close tags
07:12:53 <Heffalump> therp: not quite sure I see the point, but fair enough
07:13:12 <Heffalump> dolio: you should have used do notation :-)
07:13:25 <dolio> Heffalump: I think that's what I ended up doing. :)
07:13:47 <dolio> With brackets and semicolons so it fit on one line.
07:14:08 <shapr> @yow !
07:14:08 <lambdabot> I am having FUN...  I wonder if it's NET FUN or GROSS FUN?
07:14:12 <shapr> Goood morning #haskell!
07:14:17 <Nafai> Morning shapr!
07:14:20 <kosmikus> morning shapr
07:15:27 * shapr boings cheerfully
07:15:44 <augustss> @djinn-env
07:15:45 <lambdabot> data () = ()
07:15:45 <lambdabot> data Either a b = Left a | Right b
07:15:45 <lambdabot> data Maybe a = Nothing | Just a
07:15:45 <lambdabot> data Bool = False | True
07:15:45 <lambdabot> data Void
07:15:45 <mdmkolbe|work> shapr: What put you in such a good mood?
07:15:47 <lambdabot> type Not x = x -> Void
07:15:49 <lambdabot> class Eq a where (==) :: a -> a -> Bool
07:15:51 <lambdabot> data Ordering = LT | EQ | GT
07:15:53 <lambdabot> class Ord a where compare :: a -> a -> Ordering
07:15:55 <lambdabot> class Monoid a where mempty :: a; mappend :: a -> a -> a; mconcat :: [a] -> a
07:15:57 <lambdabot> class Monad m where (>>=) :: m a -> (a -> m b) -> m b; return :: a -> m a
07:15:59 <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
07:16:14 <therp> heffalump: with TH, you just can't modify the syntax of your language. look at the "<-" prolog clauses at http://clemens.endorphin.org/testsuite-liskell/tests/liskell/prolog/PrologMotherFather.lsk -- you don't get that kind of language integration with TH or anything in Haskell. all this syntax "sugar" comes from importing the Prolog module (same path called Prolog.lsk) and adding the prolog syntax to the compiler environment (via
07:16:14 <therp>  add-dspr)
07:16:17 <lambdabot> http://tinyurl.com/2hf8lt
07:16:35 <augustss> tsk, tsk.  someone went overboard with adding classes to djinn
07:16:38 <ski> augustss : it can do classes now !?
07:17:23 <LeCamarade> Good Evening, shapr! :oD
07:17:24 <Saizan> ?djinn Not a -> b
07:17:27 <mdmkolbe|work> @djinn (Monad m) => m a -> (a -> m b) -> (b -> m c) -> m c
07:17:28 <lambdabot> -- f cannot be realized.
07:17:29 <lambdabot> -- f cannot be realized.
07:17:32 <LeCamarade> Good night, shapr!
07:17:34 <augustss> it can do some things
07:17:36 <LeCamarade> :oD
07:17:47 <ski> @djinn Ord a => a -> a
07:17:48 <lambdabot> Cannot parse command
07:17:54 <augustss> but Monoid, Monad, and Functor should not be there
07:18:15 <augustss> @djinn (Ord a) =>a->a
07:18:16 <lambdabot> f a = a
07:18:23 <ndm> does lambdabot not limit the djinn output? i thought it always was meant to
07:18:24 <Heffalump> therp: ah, ok
07:18:27 <mdmkolbe|work> augustss: why? b/c they are over kind *->*?
07:18:42 <Heffalump> anyway, I have no desire to use lisp syntax :-)
07:19:10 <mdmkolbe|work> @djinn (Ord a) => a -> a -> Ordering
07:19:11 <lambdabot> f = compare
07:19:16 <augustss> mdmkolbe|work: djinn can't handle polymorphism.  so the type variables mentioned in the methods but not in the class decl will never be instantiated
07:19:20 <therp> heffalump: you get used to it (just like coffee) and after a while you can go without it.
07:19:23 <ski> augustss : istr someone trying higher-ranked types with djinn, and it didn't seem to work .. i assume this is indeed the case, right ?
07:19:31 <therp> sexp based editing in emacs is so much faster than with haskell syntax.
07:19:59 <augustss> ski: that's right.  you'd have to make some drastic changes
07:20:09 * ski suspected so
07:20:12 <LeCamarade> therp: You're the liskell guy?
07:20:16 <nominolo> therp: yes, i'll add a structural editing mode for haskell Real Soon Now (YM)
07:20:18 <therp> lecamarade: positive
07:20:21 <nominolo> * (TM)
07:20:29 <LoganCapaldo> therp: That's only because emacs sexp parser is better than its Haskell parser though no?
07:20:37 <dolio> What's wrong with the monoid instance? mconcat?
07:20:39 <augustss> @djinn (Eq a) => a -> a -> Maybe a
07:20:40 <lambdabot> f a b =
07:20:40 <lambdabot>     case a == a of
07:20:40 <lambdabot>     False -> Nothing
07:20:40 <lambdabot>     True -> Just b
07:20:43 <nominolo> LoganCapaldo: partly
07:20:51 <dolio> Er, class.
07:21:36 * ski wonders if his LP implication,forall could be converted into serving djinn ..
07:21:38 <augustss> dolio: mconcat has a list.  djinn doesn't do lists
07:21:58 <therp> logancapaldo: that's for sure a reason, but in Lisp syntax you have unambigious editing positions (=cursor positions) like the start of a sublist. these points are not presend in haskell, because you have a far less amount of parenthesis.
07:22:05 <dolio> augustss: Ah, yeah. The other two work, though. :)
07:22:14 <dolio> @djinn (Monoid a) => a
07:22:14 <lambdabot> f = mappend mempty mempty
07:22:18 <dolio> Sort of. :)
07:22:20 <augustss> dolio: they should
07:22:25 <ndm> dcoutts_: i'm still having PATH problems, but have sorted everything else
07:22:27 <ndm> Root: HKCU; Subkey: "Environment"; ValueName: "Path"; ValueType: "string"; ValueData: "{app}\bin;{olddata}"; Flags: preservestringtype
07:22:34 <ndm> thats my attempt, but i can't see it has any effect
07:22:44 <lypanov> hows the haskell editor doing?
07:22:45 <mdmkolbe|work> @type mempty
07:22:47 <lambdabot> forall a. (Monoid a) => a
07:23:34 <dcoutts_> ndm: you'll note that in the reg-editor that it has actually changed, however explorer does not re-read the env vars from the registry unless you tell it to...
07:23:52 <augustss> I should change djinn to complain more.  people never read the fine print about the restrictions
07:23:53 <dcoutts_> ndm: ChangesEnvironment=yes
07:24:11 <ndm> dcoutts_ thanks!
07:24:23 <shapr> mdmkolbe|work: It's a good day to be awake!
07:24:32 <ndm> dcoutts_ my copy is too old for ChangesEnvironment...
07:25:00 <ndm> dcoutts_ - any idea what version you picked that is old enough to install and new enough to support that?
07:25:26 <dcoutts_> ndm: 5.1.8
07:25:46 <dcoutts_> ndm: 5.1.9 introduced the admin check
07:26:16 <LoganCapaldo> therp: Suggest maybe that lisp syntax makes it easier to find said editing points, but I don't know that haskell's syntax is more ambiguous. True you'd need more movement commands, so I suppose that ultimately you are right, but I think a go-next-interesting-feature would make the difference imperceptible for the majority of cases
07:27:11 * ndm finds it amusing that anyone can justify Lisp syntax as being a code idea
07:27:24 <therp> code idea?
07:27:39 <ndm> * code -> good
07:28:02 <ndm> (as typo's go, that one is pretty special)
07:28:18 <balodja> hello, guys, could you advise any paper about monad reader?
07:28:50 <ndm> balodja: what about it?
07:28:54 <ndm> balodja: which one?
07:29:46 <therp> ndm: don't be so narrow minded
07:30:26 <ndm> being narrow minded is the only way to acheive perfection (or your interpretation of perfection, which is usually wrong)
07:30:30 <therp> or better phrased more positive: be more open-minded
07:34:32 <balodja> ndm: about use of Control.Monad.Reader, about it's purposes and where it can be used
07:34:53 <ndm> balodja: oh, sorry - i thought you were refering to The Monad.Reader
07:35:54 <LeCamarade> Lisp syntax is a pattern. And I rebel against all patterns. I want the parens abstracted away. You get?
07:38:23 <dcoutts_> is it a pattern? or just information
07:38:26 <therp> monad syntax is a pattern..
07:38:45 <therp> haskell syntax itself is a pattern. I'm not sure, was this a serious comment?
07:39:05 <dcoutts_> remember that a certain amount of syntactic redundancy helps readability
07:39:28 <dcoutts_> all natural languages have quite a bit of redundancy, partly for this reason
07:40:38 <LeCamarade> Yes, it was serious, but maybe not proffesional. I think `I just don't like repetitiveness' is what I am trying to say. Some repetiveness (like whitespace and off-side spacing) isn't as horrible to the eye as (((((((()))))) ... [one, two, three ... seven, eight, okay, two more])).
07:40:58 <emu> no lisp code looks like that
07:41:01 <emu> only strawman lisp code
07:41:14 <mdmkolbe|work> emu: not so
07:41:26 <emu> please don't offer stupid arguments to me.  i work extensively in CL.
07:41:31 <Stinger_> my lisp code looks like that :)
07:41:36 <emu> (and yet I still like Haskell)
07:41:46 <Stinger_> I dont claim to be a very good lisp programmer however :P
07:41:50 <LeCamarade> emu: You're a find.
07:41:56 <ndm> i personally find Haskell much more readable than Lisp
07:41:57 <dcoutts_> LeCamarade: but people round this corner of the prog lang world probably agree, you'll not see too many parens in most Haskell code.
07:42:14 <ndm> partly because when i first see a beginners lisp they have the indentation done one way, and the bracketing done in a conflicting way
07:42:21 <ndm> with Haskell people can't pull tricks like that
07:42:27 <emu> well that's their fault for not using a real editor
07:42:28 <mdmkolbe|work> emu: Dan Friedman regularly writes functions that end in 5-10 close parents in our classes.
07:42:31 <LeCamarade> Haskell ruins it for Lisp. Going back to bracks, when you've been exposed to $, can be painful.
07:42:41 <emu> mdmkolbe|work: so? do you actually count them?
07:42:54 <emu> parentheses in lisp and haskell are completely different beasts
07:42:59 <ndm> emu: in that case lisp is more than a textual format, its a tree format, which happens to have a serialisation to brackets
07:43:01 <mdmkolbe|work> emu: bingo.
07:43:16 <emu> i really miss auto-indentation when i work in haskell
07:43:44 <mdmkolbe|work> LeCamarade: most good scheme programs only have lots of parens at the close.  So a good editor that will flash the matching paren is very usefull.  You get use to them after a while.
07:43:53 <emu> if you know how to take advantage of the tree-structure of lisp code, then it is a really big boon
07:44:20 <emu> mdmkolbe|work: for example, i use structural modes in emacs (paredit) which maintain balanced structure at all times
07:44:39 <emu> asking if I count parentheses is silly.  I don't use any editing operations which would unbalance them.
07:45:09 <mdmkolbe|work> emu: you don't have to convince me.  I'm neutral/ambidextrous/come from Indiana U.
07:45:26 <LeCamarade> Lisps surrendered paren count for acrobatic flexibility. In the end, it is what you prefer. I, for one, would want less, small separation operators in Haskell, for example. I adore whitespace. List: [1 2 3 4 5 6 7 8 .. 20] Et cetera.
07:46:08 <emu> i still prefer haskell-style for FP, currying, etc
07:46:25 <emu> and yes, i wouldn't mind removing some superfluous commas from haskell =)
07:46:59 <LeCamarade> emu: First one on my side! Most of the time I get tarred-and-feathered when I say stuff like that! :oO
07:47:07 <mdmkolbe|work> LeCamarade: you reallize that the commas in that aren't superflouous.  [1 2 3 4] == [(1 (2 (3 4))]
07:47:24 <emu> (((1 2) 3) 4)
07:47:38 <emu> yea yea, sigh. i still hate commas.
07:47:42 <mdmkolbe|work> emu: yeah, I don't know what I was thinking
07:47:53 <emu> it's those damn parentheses, oh wait
07:48:03 <LeCamarade> mdmkolbe|work: Yeah, but I thought the compiler would know I am not ... oh, I see. Because, then, a list of curried funcs is impossible. My bad.
07:48:04 * emu kicks precedence and associativity
07:48:47 * lypanov kicks logic
07:48:53 <LeCamarade> But I hate those little eye-sores.
07:49:18 <mdmkolbe|work> LeCamarade: yeah, the trouble is that whitespace is the function application operator, which is cool, but kind of eats up your syntax options really quickly
07:49:22 * LeCamarade kicks [^0-9a-zA-Z ]
07:49:24 <emu> well mostly commas get in the way when manipulating text
07:49:31 <emu> emacs tries to handle it but it's not perfect
07:49:41 <mdmkolbe|work> @type [1,2,3,]
07:49:44 <lambdabot> parse error on input `]'
07:50:24 <mdmkolbe|work> and it's a trouble for generated code
07:50:32 <sjanssen> @keal
07:50:33 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
07:50:53 <LeCamarade> mdmkolbe|work: And any other way to do it makes you a syntax Nazi: `One space is func application, more than that is a separator! Observe! [1  2  3  4  func 2  5]' Which is sick.
07:51:21 <emu> actually, ascii syntax for FP always seems cramped
07:51:30 <lypanov> APL!
07:51:32 <emu> let's expand
07:51:56 <mdmkolbe|work> LeCamarade: Well, there is always quasi-quote/unquote
07:52:06 <LeCamarade> emu: I will never design a language, for example, that says this crap Haskell says about identifiers that start in Caps, for example. Can't code in Chinese!
07:52:15 <emu> heh
07:52:20 <LeCamarade> > let  = 23 in 
07:52:21 <lambdabot>   lexical error (UTF-8 decoding error)
07:52:23 <emu> I think that extension is being proposed for _ to mean caps
07:52:23 <mdmkolbe|work> LeCamarade: `(1 2 3 ,(+ 2 2))
07:52:43 <osfameron> superfluous commas?
07:52:46 * osfameron cries
07:52:49 <LeCamarade> mdmkolbe|work: No, don't give the Lisp guy a reason to be happy! We had won!
07:53:13 * LeCamarade cries bitterly.
07:53:16 <lypanov> isn't um... lisp and haskell... well, aren't they are bit different?
07:53:25 <emu> what annoyed me about caps is that i wanted to call one variable Q and another q :(
07:53:28 <lypanov> why are we talking about the syntax? its kind of um.. just the top layer? :)
07:53:32 <LeCamarade> mdmkolbe|work: We had defeated the Lispers, man! You've ruined it.
07:53:36 <osfameron> it's also important
07:53:48 <emu> gosh darnit, if we can't argue about syntax then we got nothing to argue about
07:53:51 <osfameron> a lot of the reasons that haskell works are to do with the syntax permitting it
07:53:57 <mdmkolbe|work> LeCamarade: in the end, the truth can never be defeated
07:54:03 <osfameron> (of course, I'm a perl programmer, so by definition obsessed with the stuff)
07:54:05 <LeCamarade> lypanov: We enter via the top. I spend lots of time reading code, I can't stand code that isn't pretty - even seductive.
07:54:06 <mdmkolbe|work> ;-)
07:54:06 <ndm> lypanov: thats not true - by making something more natural and shorter you encourage it over something thats longer and more verbose
07:54:15 <lypanov> the reason i stpped away from haskell was thecomplexity of optimisation for me
07:54:34 <LeCamarade> mdmkolbe|work: I can't belie ... spy! Get him! Send him out of GHC HQ! Spy!
07:54:41 <lypanov> LeCamarade: and you prefer lisp for that or haskell?
07:54:43 <ndm> lypanov: but Haskell implementations keep getting better and better at automatically optimising your code
07:55:10 <LeCamarade> lypanov: I prefer Haskell. One of the cleanest syntaces under the sun.
07:55:39 <mdmkolbe|work> LeCamarade: seriously though, I suspect TH might give Haskell quote/unquote
07:55:49 <osfameron> though at the expense of some crackfueled stuff like whitespace alignment and capital/lower case distinction
07:56:12 <emu> whitespace alignment is o.k. except that it kills automatic indentation. fbofw
07:56:23 <sjanssen> osfameron: I think both of those are good decisions
07:56:50 <sjanssen> the layout system is quite flexible (and optional!)
07:56:56 <ndm> the layout rule is too complex
07:57:05 <ndm> but having indentation/white space based layout is a good idea
07:57:20 <sjanssen> ndm: from an implementor's point of view?
07:57:33 <LeCamarade> mdmkolbe|work: Would be very nice. First thing Haskell did to me was to make me write the $ for OCaml. Repetitions suck, be they (((()))), (,,,,) or others. I hate them, because they take my focus away. I'm just like that. Mental thing. :oD
07:57:33 <ndm> sjanssen: precisely, and therefore from a standards/compatibility point of view
07:57:35 <osfameron> sjanssen: they may well be good decisions, but they come across as slightly crackfueled to me.  The whitespace thing seems to be done quite well tho
07:57:49 <emu> layout is intended to simulate the kind of grouping you might use with math on paper.  i'd prefer more of that kind of flexibility, which being stuck in an ASCII buffer does not permit.
07:58:06 <ndm> i thought a vs A was initially quite crazy, but after a while it seems natural
07:58:09 <LeCamarade> ndm: I have been using off-sed layout rule in my prose! Ilove it.
07:58:11 * lypanov is only back because of that damn bird sukodo thingy
07:58:39 <emu> the capitalization thing though runs counter to single-letter variable names
07:58:44 <emu> which is both good and bad
07:59:05 <emu> it's good because single-letter variable names are evil.  it's bad because single-letter variable names go really well with the mathematical style.
07:59:18 <LeCamarade> s/off-sed/off-side/gi
07:59:29 <osfameron> some lines of haskell would become unreadable with long variable names :-)
07:59:34 <emu> right
08:00:07 <emu> if haskell syntax is all about conciseness then why do i need unwieldy names?
08:00:12 <LeCamarade> emu: But Haskell's problem may be her inability to put the mathematicians on one side and the rest of us, who want to code in ... Ancient Maya ... on one side.
08:00:32 <LeCamarade> > let  = 23 in 
08:00:33 <lambdabot>   lexical error (UTF-8 decoding error)
08:00:36 <osfameron> I'd quite like to have named parameters in the type signature
08:00:43 <LeCamarade> ^^ So evil!
08:00:46 <osfameron> right now, to document your function calls well you need a type synonym
08:01:01 <lypanov> has anyone played with gems?
08:01:05 <emu> anonymous records, named currying
08:01:11 <sjanssen> LeCamarade: I don't have those characters in my font, what are they?
08:01:11 <lypanov> s/gems/CAL/
08:02:50 <LeCamarade> sjanssen: e with an accent, and a with an ` accent.
08:03:50 <sjanssen> LeCamarade: have you tried putting that in a .hs and compiling it with ghc 6.6?
08:04:21 <sjanssen> lambdabot is most likely mutilating the text
08:04:58 <fridim> > foldr (++) ["oui", "non"]
08:05:00 <lambdabot>  <[[[Char]]] -> [[Char]]>
08:05:02 <osfameron> utf8 is evil
08:05:05 <fridim> > foldr (++) "" ["oui", "non"]
08:05:07 <lambdabot>  "ouinon"
08:05:13 <osfameron> until it magically works across toolchain I mean
08:05:16 <LeCamarade> Yes. UTF-8 decoding error.
08:05:19 <fridim> > foldl (++) "" ["oui", "non"]
08:05:21 <lambdabot>  "ouinon"
08:05:23 <fridim> why?
08:05:32 <LeCamarade> sjanssen: ^
08:05:50 <sjanssen> LeCamarade: hmm.  Sure you're using valid UTF-8?
08:06:43 <LeCamarade> Oui. :oD Des caractres franais. Valid UTF-8. Nobody else sees these accents in his/her IRC client?
08:07:00 <osfameron> nope
08:07:03 * LeCamarade knows he's not alone when fridim is here.
08:07:04 <lypanov> no. not here. its coming out pretty messed up
08:07:12 <therp> lecamarade: works for me.
08:07:20 <osfameron> and I thought I'd (finally) got putty+screen+irssi fixed for utf8
08:07:23 <ulfdoz> I can see the accents.
08:07:27 <lypanov> oh. i'm on linux.. lemme try on a non sucky machine
08:07:48 <lypanov> looks fine LeCamarade
08:07:50 <lypanov> (osx)
08:08:40 * osfameron is terrified of perl6 and other languages using utf8.  I still think utf8 belongs in data, if anywhere
08:09:15 <hpaste>  ndm pasted "(no title)" at http://hpaste.org/1744
08:09:22 <emu> no, what we need is not only utf8, but layout at least as good as TeX markup
08:09:24 <LeCamarade> osfameron: People will want to code in Haskell and Chinese - at least the Chinese `Hello, World!', and will not be able to.
08:09:28 <malcolmw> the accents look fine for me in Colloquy (OS X), but I do see a system message (incompatible encoding) occasionally
08:10:39 <Wild_Cat> same here.
08:10:58 <Wild_Cat> weird thing though, as my client is set up to use UTF-8.
08:10:59 <osfameron> LeCamarade: yeah, I know I'm coming across as an intolerant monoglot, which actually I'm not - it's just that utf8 doesn't seem to be ready, and I anticipate much more great pain if people start using it in code, at least until it gets fixed.
08:11:23 <mdmkolbe|work> LeCamarade: I don't see any of these accents in Gaim 1.5 (win).  But I might be able to see a real lambda (wierd)
08:11:45 <Wild_Cat> the main problem with UTF-8 is that most (all?) Windows programs use ISO-8859-1 and give you no choice in that matter.
08:11:56 <ulfdoz> osfameron: ACK, depending on system it works differently well. This causes some problems in interoparability.
08:12:06 <emu> if you have a strong enough electron microscope, you can photograph a real lambda
08:12:27 * Wild_Cat would prefer to photograph a real lambada.
08:12:53 <osfameron> ulfdoz: for me it works differently badly... and getting it to work across systems - like the putty+screen+irssi thing, is never much fun
08:13:03 <LeCamarade> osfameron: I understand. But ... worse is better. No Spanish Haskell code. Because Spanish hello.hs requires .
08:13:28 <osfameron> what's the point of having a lingua franca if people don't use it? ;-)
08:13:32 <LeCamarade> Wild_Cat: Find it at the top of the building where the Haskell Hackathon '07 was held. :oD
08:13:33 <kc5tja> LeCamarade: No; I do not see them.
08:13:42 <Wild_Cat> heh
08:13:53 * kc5tja just woke up.
08:13:53 <emu> i too run screen+irssi, and have trouble with utf8.  but screen+emacs doesn't have trouble, last time i tried.
08:14:05 <Wild_Cat> LeCamarade: out of curiosity, what encoding does your client use? (and do you see those:  ?)
08:14:08 <osfameron> and vim seems to be quite happy too
08:14:21 <ulfdoz> emu: emacs completely ignores system-encoding does his own soup.
08:14:30 <Syzygy-> Wild_Cat: My irssi recodes from utf to latin-1, and I see oe from you.
08:15:04 <LeCamarade> Wild_Cat: Nope. I don't see. This is a very Americanised machine that I have to click some button (I made) to run xkbd(1) to enable accents.
08:15:09 <assl0r> > delete all ' ' ["foo bar", "barfoo"]
08:15:11 <lambdabot>  Couldn't match expected type `[(a -> Bool) -> [a] -> Bool]'
08:15:29 <assl0r> > delete all (== ' ') ["foo bar", "barfoo"]
08:15:30 <lambdabot>      The section `(== ' ')' takes one argument,
08:15:31 <lambdabot>     but its type `[(a -> Bool...
08:15:32 <kc5tja> I saw some Cyrillic character (backwards-looking N) with a Hangul character adjacent.  :)
08:15:43 <Syzygy-> > map (delete all (==' ')) ["foo bar", "barfoo"]
08:15:44 <lambdabot>      The section `(== ' ')' takes one argument,
08:15:44 <lambdabot>     but its type `[(a -> Bool...
08:15:46 <kc5tja> This suggests that the UTF-to-X11-font mapping is wonky.
08:15:48 <Wild_Cat> LeCamarade: right. I guess your client uses latin-1 then.
08:15:56 <LeCamarade> osfameron: vim has to be happy - it is a vi clone. And I write the accents in OCaml. (Just to spit you all.)
08:16:00 <kc5tja> But I'm too lazy to find out how to fix it.
08:16:06 <assl0r> > delete (== ' ') ["foo bar", "barfoo"]
08:16:07 <Syzygy-> :t delete
08:16:07 <lambdabot>  Couldn't match expected type `Char -> Bool'
08:16:09 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:16:21 * LeCamarade notes that OCaml is at a .fr site. :oD They had to enable UTF-8.
08:16:37 <cdsmith> :t deleteBy
08:16:40 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
08:16:53 <Wild_Cat> LeCamarade: oh, you never know. Ruby is a .jp language, yet it doesn't support UTF-8 yet.
08:16:57 <Syzygy-> > map (delete ' ') ["foo bar", "barfoo"]
08:16:59 <lambdabot>  ["foobar","barfoo"]
08:17:07 <Syzygy-> assl0r: That's it?
08:17:08 <vegai> the japanese are used to some other encoding
08:17:09 <assl0r> ah :)
08:17:13 <assl0r> Syzygy-, thx
08:17:34 <Wild_Cat> yeah (JIS, right?). Not sure how Ruby handles it, though.
08:17:37 <LeCamarade> Wild_Cat: Yeah. I found that very strange. Very. .rb against .jp.
08:17:38 <assl0r> Syzygy-, but doesn't delete only deletes the first occourence?
08:17:50 <assl0r> http://www.zvon.org/other/haskell/Outputlist/delete_f.html
08:17:51 <lambdabot> Title: Haskell : delete
08:18:07 <Syzygy-> > map (delete ' ') ["foo bar baz", "barfoo"]
08:18:09 <lambdabot>  ["foobar baz","barfoo"]
08:18:13 <Syzygy-> Apparently it does.
08:18:24 <sjanssen> I think Unicode is controversial in Japan
08:18:31 <Syzygy-> > map (filter (/=' ')) ["foo bar baz", "barfoo"]
08:18:33 <lambdabot>  ["foobarbaz","barfoo"]
08:18:42 <cdsmith> > fix (map (delete ' ')) ["foo bar baz", "bar foo"]
08:18:43 <lambdabot>  Couldn't match expected type `[[Char]] -> t'
08:18:43 <Syzygy-> Better?
08:18:49 <LeCamarade> sjanssen: Oh, is it?
08:18:54 <assl0r> why does that work O_o
08:19:01 <Syzygy-> cdsmith: Oh, come on. fix is not a good solution to everything!
08:19:07 <cdsmith> :)
08:19:08 <assl0r> /= ' '
08:19:11 <LeCamarade> sjanssen: That may explain it, then. Links?
08:19:19 <Syzygy-> assl0r: Because "abs" = ['a','b','s']
08:19:31 <emu> don't "fix" what ain't broke?
08:19:38 <Syzygy-> assl0r: So I filter out, from each string, all characters that aren't spaces.
08:19:41 <Wild_Cat> chances are it's because they already have something that works.
08:19:43 <Syzygy-> This is the same as deleting all spaces.
08:20:12 <LeCamarade> assl0r: Because /= is a function, and it is curried, there.
08:20:16 <Wild_Cat> and they don't want to go through the trouble of converting everything to Unicode, especially since UTF-8 isn't a superset of their existing charset (like it is for our ASCII).
08:20:30 <LeCamarade> > let  ne = (/= ' ') in ne 'r'
08:20:32 <lambdabot>  True
08:20:37 <LeCamarade> > let  ne = (/= ' ') in ne ' '
08:20:39 <lambdabot>  False
08:20:39 <assl0r> Syzygy-, ah i seee, you used filter not delete ;)
08:20:41 <LeCamarade> Got it?
08:20:44 <sjanssen> LeCamarade: http://en.wikipedia.org/wiki/Unicode#East_Asia
08:20:52 <assl0r> yeah thx
08:21:02 <Syzygy-> assl0r: Ayup. Since delete doesn't continue through.
08:21:16 <kc5tja> Wild_Cat: Judging by the amount of spam I get that is in UTF-8 from Japan, that concern is subsiding.  :)
08:23:40 <Wild_Cat> you know you need to get a life when... You start analyzing and making statistics about the character encoding of spam you receive :p
08:23:50 <LeCamarade> sjanssen: Reading that. But we all must concede computing is, in general, quite biased West-ward.
08:24:07 <lypanov> english-ward to be honest
08:24:17 <emu> formal languages defined in terms of an alphabet oO
08:24:17 * LeCamarade realises late that he is not at #haskell-blah
08:24:26 <lypanov> heh
08:24:40 <osfameron> you missed a million naked mexicans!
08:25:01 <assl0r> > filter (any isAlpha) . map (filter (/= ' ')) ["foo bar baz", "bar foo", "555aaa"]
08:25:02 <lambdabot>  Couldn't match expected type `a -> [[Char]]'
08:25:07 <LeCamarade> lypanov: The farther West, the closer to English. Um ... Australia is a town in America, right? :oD
08:25:20 <lypanov> LeCamarade: nope. england
08:25:25 <lypanov> :P
08:25:28 <emu> L = { <M> | where M is a turing machine that recognizes characters that look like a person }
08:25:30 <LeCamarade> lypanov: Oh! :oD
08:25:36 <LeCamarade> Bad memory.
08:26:04 <LeCamarade> Been there, you know. Australia in England. Nice little town. :oD
08:26:12 <assl0r> > filter (any Data.isAlpha) . map (filter (/= ' ')) ["foo bar baz", "bar foo", "555aaa"]
08:26:13 <lambdabot>   Not in scope: `Data.isAlpha'
08:27:06 <assl0r> > filter (any isAlpha) . (filter (/= ' ')) ["foo bar baz", "bar foo", "555aaa"]
08:27:08 <lambdabot>  Couldn't match expected type `a -> [[Char]]'
08:27:25 <mauke> > filter (any isAlpha) (map (filter (/= ' ')) ["foo bar baz", "bar foo", "555aaa"])
08:27:27 <lambdabot>  ["foobarbaz","barfoo","555aaa"]
08:27:44 <kc5tja> Wild_Cat: I don't have to do the encoding analysis -- I don't have JIS on my box, and I get at least 3 Japanese e-mails (in Japanese) a day.  >:(
08:27:52 <assl0r> why i can't use a composition here?
08:28:00 <Wild_Cat> kc5tja: good point :D
08:28:06 <mauke> > (filter (any isAlpha) . map (filter (/= ' '))) ["foo bar baz", "bar foo", "555aaa"]
08:28:07 <lambdabot>  ["foobarbaz","barfoo","555aaa"]
08:28:15 <assl0r> argh
08:28:28 <mauke> (f . g) x, not f . (g x)
08:28:28 <ehird`> the lazy-evaluation-explanation page says that when needed, haskell evaluates "the next bit" of the function - how is "the next bit" determined?
08:28:29 <lambdabot> ehird`: You have 1 new message. '/msg lambdabot @messages' to read it.
08:28:37 <assl0r> is there a rule where i have to put in brackets? :D
08:28:44 <mauke> it's called precedence
08:29:00 <assl0r> $ is the same right?
08:29:12 <mauke> hmm?
08:29:13 <Wild_Cat> most of the spam that comes through my filter nowadays is image-based, English-language stuff.
08:29:29 <assl0r> > $ filter (any isAlpha) . map (filter (/= ' ')) ["foo bar baz", "bar foo", "555aaa"]
08:29:30 <lambdabot>  Parse error
08:29:37 <Wild_Cat> noisy images at that, in what I imagine is an attempt to thwart OCR spam filters.
08:29:41 <kc5tja> That is one thing that has confuddled me more than once: when is it appropriate to use . versus $?  Some questions were never meant to be asked, I guess.
08:30:13 <mauke> kc5tja: $ is for when you want to avoid parens
08:30:20 <mauke> . is for when you want to compose functions
08:30:25 <emu> a . b . c $ x
08:30:32 <mauke> that's both :-)
08:30:36 <emu> (a . b . c) x
08:30:45 <assl0r> yeah
08:30:47 <cdsmith> a $ b $ c $ x
08:30:55 <mauke> a (b (c x))
08:31:01 <mdmkolbe|work> ehird`: the need for the next bit is usually caused b/c the expression is being used in a case statement (there are exceptions) in which case the 'next bit' is what ever is nessisary to determine which case branch to take (usually just which constructor the value being examined (i.e. "scruninized") has at it's top)
08:31:03 <kc5tja> (a . b . c) x = a (b (c x)) = a $ b $ c $ x
08:31:08 <cdsmith> Yep.  Point is, there's defintiely a choice there
08:31:22 <dcoutts_> kc5tja: so use the most readable one
08:31:23 <emu> hm, the most compact choice is with parentheses
08:32:21 <ehird`> mdmkolbe|work: yes, but how do you evaluate "a bit"?
08:32:21 <ehird`> my feeble brain thinks of a function as not consisting of bits, but being one expression... which, naturally, gives no way to evaluate " a bit"
08:32:36 <dcoutts_> emu: equally compact is a . b . c $ x
08:32:36 <dcoutts_> > length "a . b . c $ x" == length "(a . b . c) x"
08:32:37 * emu hides
08:32:39 <lambdabot>  True
08:33:14 <kc5tja> dcoutts_: In my Haskell coding, I tend to use $ exclusively.  I personally have never used .
08:33:14 <osfameron> you could always argue about which is more readable (I find second more so)
08:33:39 <mauke> ehird`: it's not the function; it's the return value
08:33:40 <LeCamarade> Truth is, the mathematicians put . because it is Maths notation.
08:33:41 <lambdabot> LeCamarade: You have 1 new message. '/msg lambdabot @messages' to read it.
08:34:28 <mdmkolbe|work> ehird`: the answer to taht depends on how much you already know.  Do you know what thunks are? Closures? Have you read the Stackless Tagless G-Machine paper?
08:34:28 <cdsmith> kc5tja, presumably you use . when there's no other choice, right?
08:34:28 <kc5tja> cdsmith: I've never run into that situation.
08:34:39 <LeCamarade> cdsmith: I think there is always the $ choice.
08:34:40 <cdsmith> filter ((/= foo) . bar) mylist ???
08:34:45 <ehird`> mauke: right. but if you're not going to evaluate the whole thing, how do you know the return value
08:34:58 <mauke> ehird`: why do you need to know?
08:35:03 <dcoutts_> kc5tja: many people consider (.) nicer, for a few reasons
08:35:03 <dcoutts_> kc5tja: for example if you have: f x = a $ b $ c $ x you can say instead f = a . b . c
08:35:10 <ehird`> mauke: curiosity. understanding haskell more.
08:35:34 <mauke> ehird`: huh? are you saying code evaluates return values to understand haskell more?!
08:35:40 <mauke> category error. core dumped.
08:35:50 <osfameron> dcoutts_: why is that considered nicer?  doesn't it obfuscate the fact that "f" takes a parameter?
08:36:05 <emu> \cdot is math's notation. or maybe \circ
08:36:11 <dcoutts_> osfameron: no, it's clear it's a function since it's defined as the composition of other functions.
08:36:15 <mauke> osfameron: both versions obfuscate the fact that "f" takes two parameters
08:36:18 <kc5tja> \circ is the composition symbol.
08:36:19 <ehird`> mauke: no - i want to know how it gets a "part" of the return value, to satisfy an evaluation requirement (pattern or something), without evaluating the entire function
08:36:24 <ehird`> knowing that would improve my understanding of haskell
08:36:33 <mauke> ehird`: s/entire function/entire value/
08:36:35 <dcoutts_> osfameron: it is a tab more abstract
08:36:40 <dcoutts_> tab/tad
08:36:48 <mauke> ehird`: consider f x = (g x, h x)
08:36:53 <emu> algebraically i see \cdot a lot more for composition
08:36:58 <emu> as in multiplication
08:37:08 <emu> but whatever
08:37:10 <osfameron> \cdot ?
08:37:11 <ehird`> mauke: it evaluates the first of the set there or something?
08:37:13 <emu> i need to go look for a new phone
08:37:14 <mauke> ehird`: it's obvious that the return value of f is a tuple
08:37:15 <ehird`> and then the next if it needs more
08:37:29 <mauke> ehird`: as long as you don't ask for the actual values of the components, it won't call g or h
08:37:33 * kc5tja has run into the obfuscation thing before, which is why I declare types for all "public" (aka, functions with greater than 2% probability I'll use it in another location in the code, especially another module).
08:37:37 <ehird`> so, with recursive functions, does it evaluate up to the next recursive call?
08:37:42 <kc5tja> s/"public"/"public" functions/
08:37:49 <mauke> ehird`: it's not about functions
08:37:51 <mauke> it's about values
08:37:57 <osfameron> dcoutts_, mauke: ok.  sometimes the definitions *do* look very neat, but if you have to read to see what's really going on, it helps to look at the type signature...
08:38:26 <ehird`> i was thinking, if it was pattern matching e.g. the result of a factorial
08:38:27 <mauke> type signatures don't always determine the number of arguments
08:38:38 <ehird`> it'd see "dumbfac n = n * fac (n - 1)"
08:38:47 <emu> ehird`: consider a cons.  it's a value : another value.   for example, [1,2,3] is 1:(2:(3:[])).  but you could also say [1 ..] which is 1 : (not yet computed)
08:38:48 <dcoutts_> osfameron: yes, the type sig very often tells us a lot about the function. I consider it crucial (and beautifully concise) documentation.
08:38:49 <lypanov> hey BCoppens
08:38:50 <ehird`> which it'd expand to "thenumber * fac (whatever thenumber - 1 is)"
08:38:50 <kc5tja> mauke: Example?
08:38:56 <ehird`> and then execute the recursive call if needed?
08:39:04 <mauke> kc5tja: id :: a -> a
08:39:17 <emu> ehird`: then if you compute a little bit of it more you get 1 : (2 : (not yet computed))
08:39:20 <emu> and so on
08:39:26 <mauke> :t flip id
08:39:27 <kc5tja> mauke: Right.  id takes a single parameter, and returns a single value.
08:39:28 <lambdabot> forall b c. b -> (b -> c) -> c
08:39:34 <mauke> think again, bat man!
08:39:56 <dcoutts_> osfameron, kc5tja: it is often most natural to define operations in terms of other operations, rather than in terms of what they do directly to their inputs.
08:40:02 <emu> batman, where?
08:40:19 <kc5tja> flip is a function that accepts a function of two arguments, so of course it's going to magically alter the type signature.
08:40:24 <kc5tja> :t flip $ flip id
08:40:27 <lambdabot> forall b c. (b -> c) -> b -> c
08:40:30 <kc5tja> see?
08:40:36 <mauke> flip doesn't alter type signatures
08:40:47 <kc5tja> flip alters the order of a function's parameters.
08:40:50 <kc5tja> id only takes one.
08:40:52 <kc5tja> So it curries.
08:40:58 <mauke> so?
08:41:02 <kc5tja> And that curry appears in the type signature.
08:41:08 * emu could use a curry
08:41:09 <kc5tja> The point is, the type signature IS reliable.
08:41:12 <dcoutts_> :t (id :: a -> a)
08:41:14 <lambdabot> forall a. a -> a
08:41:18 <lypanov> emu: damnit now i'm hungry
08:41:23 <mauke> the point is: if a is a function type, a -> a doesn't tell you anything about the number of arguments you can use
08:41:26 <dcoutts_> :t (id :: (a -> b) -> (a -> b))
08:41:28 <lambdabot> forall a b. (a -> b) -> a -> b
08:41:48 <emu> @src ($)
08:41:48 <lambdabot> f $ x = f x
08:41:49 <dcoutts_> kc5tja: see, the type sig does not directly tell you the number of args.
08:42:11 <emu> > subtract`id`1
08:42:12 <lambdabot>  <Integer -> Integer>
08:42:12 <kc5tja> mauke: Well, of course 'a' could stand for anything.  That's not in question.  The point is, id as a self-standing function unto itself, in complete isolation of the rest of the system, takes a parametner, and returns a value.
08:42:39 <emu> > product`id`[1..10]
08:42:40 <lambdabot>  3628800
08:42:47 <mauke> kc5tja: that's true for all functions, not just id
08:43:00 <kc5tja> mauke: Stop changing the argument.
08:43:05 <mauke> what
08:43:25 <kc5tja> You made the claim that the type signature is not a reliable means of identifying a function's inputs or returns.
08:43:26 <dcoutts_> kc5tja: I suppose it tells you the maximum number of args in the functions definition.
08:43:28 <kc5tja> I claim that it is.
08:43:50 <kc5tja> Haskell compilers will puke all over you if you violate the type signature in any way.
08:43:55 <mauke> either you see all functions as taking one value and returning one value, or you interpret curried functions as taking multiple arguments
08:44:03 <emu> that's a sticky situation
08:44:26 <mauke> in the latter case you can't always determine the number of arguments from the type signature
08:44:40 <kc5tja> And I claim that you can.
08:44:46 <kc5tja> When you consider JUST THAT FUNCTION.
08:44:49 <dcoutts_> yes, not even the maximum as I sugested a second ago
08:44:49 <mdmkolbe|work> mauke: see the Push/Enter vs. Eval/Apply paper for how GHC gets around that issue
08:44:59 <kc5tja> Functions-as-parameters are not in question -- they're to be treated as values just like any other.
08:45:01 <mauke> kc5tja: I gave a counterexample
08:45:21 <DRMacIver> On a scale of one to inane I have this argument a 7.3
08:45:25 <kc5tja> And I rejected the counter-example on the basis of insufficient evidence.
08:45:28 <DRMacIver> s/have/give/
08:45:34 <emu> > id (+) 1 2
08:45:35 <dcoutts_> kc5tja: this depends somewhat on how you choose to implement the language
08:45:35 <lambdabot>  3
08:45:37 <mauke> kc5tja: irrelevant. you're still wrong :-)
08:45:38 <kc5tja> In fact, it rather proved my point.
08:46:06 <dcoutts_> kc5tja: for example is a function f x y z = ... implemented as f = \x -> (\y -> (\z -> ...))
08:46:17 <DRMacIver> So, guys, we all agree that dynamic typing is really much better than static, right? Haskell is basically just a cute experiment.
08:46:27 <dcoutts_> DRMacIver: heh heh heh
08:46:32 <kc5tja> emu: id (+) 1 2 == ((+)) 1 2 == 1+2 == 3 <-- note that id returns "a" value (the function +).  id itself does not take more than one parameter.
08:46:37 <cdsmith> DRMacIver: yeah, sounds good to me.
08:46:44 <DRMacIver> Good good. Just checking.
08:46:47 <kc5tja> Yes, yes, yes, yes, I know about currying.
08:46:49 <emu> it's indistinguishable from currying
08:46:54 <hpaste>  assl0r pasted "(no title)" at http://hpaste.org/1745
08:47:11 <mauke> kc5tja: f x y z  <-- note that f returns a value, the function (f x). f itself does not take more than one parameter
08:47:19 <DRMacIver> (Oh well, so much for my attempts to derail this silly conversation)
08:47:19 <kc5tja> If I cannot rely on id returning "a" value, then I cannot rely AT ALL on the entirety of functional reasoning of code.
08:47:46 <Heffalump> huh?
08:47:50 * emu is confused too
08:47:58 * Heffalump appears in the conversation rather late and fails to understand what kc5tja is on about
08:47:59 <kc5tja> mauke: Look, if I have to spell this out, then there is something seriously wrong with everyone's reasoning.
08:48:10 <osfameron> dcoutts_: yeah, the type sig is handy, better than letting haskell infer it I think.  Though it's not always that useful: "Int" could be anything - which is why type synonyms are nice if appropriate
08:48:11 <kc5tja> YES, f x y z = \wwww -> ...etc...
08:48:12 <DRMacIver> Heffalump: I wouldn't worry about it. It's a really silly argument.
08:48:20 <dcoutts_> osfameron: yes.
08:48:22 <kc5tja> But at SOME point, you're going to have to evaluate a function in terms of x, y, and zz.
08:48:23 <mdmkolbe|work> DRMacIver: yeah, I lost track of which side everyone was on
08:48:38 <kc5tja> Otherwise, what is the point of the currying?
08:48:46 <kc5tja> So you think of f x y z as a whole expression.
08:48:53 <mauke> kc5tja: I can't even comprehend your position
08:48:55 <kc5tja> That takes THREE parameters, and returns SOMETHING.
08:48:56 <Heffalump> kc5tja: so your argument is that a function must take as many arguments as its type indicates?
08:48:59 <dcoutts_> kc5tja: the notion of how many args it takes at runtime is actually quite a subtle implementation issue.
08:49:03 <DRMacIver> mdmkolbe|work: Me too.
08:49:08 <kc5tja> Heffalump: To be evaluated, YES.
08:49:14 <assl0r> if i have a list of integer-lists, how can i apply a fold function to each int element?
08:49:18 <osfameron> DRMacIver: nice attempt at derailing!
08:49:26 <bd_> assl0r: map (fold* ...) l
08:49:38 <Heffalump> I don't follow how polymorphism interacts with that. The example of id is a good one.
08:49:42 <DRMacIver> osfameron: I thought if anything would set people off, that would, but I guess it was too obvious a troll. :)
08:49:44 <osfameron> DRMacIver: actually, I believed that position (and still kinda do) until using haskell types.  Though they might just be a cute experiment I dunno.. still very powerful
08:49:47 <Heffalump> How many arguments does ($) take?
08:49:54 <kc5tja> $ takes two.
08:49:57 <kc5tja> a $ b == b a
08:50:01 <osfameron> one for each bracket
08:50:03 <kc5tja> Now, a and b MAY BE functions.
08:50:06 <Heffalump> no, a $ b = a b
08:50:10 <Heffalump> but that's an aside
08:50:14 <cdsmith> assl0r: with map?  Or am I misunderstanding?
08:50:15 <kc5tja> In fact, it darn well better be.
08:50:16 <DRMacIver> $ takes the same number of arguments as any other Haskell function. 1. :)
08:50:26 <emu> yep
08:50:30 <kc5tja> But it nonetheless stands as reason that $ takes two arguments.
08:50:34 <mauke> ($) x = x
08:50:36 <Heffalump> and how many arguments does id take?
08:50:42 <kc5tja> It takes one.
08:50:43 <osfameron> function composition and application must be lightning fast in haskell!
08:50:46 <kc5tja> It's the identity function.
08:50:49 <Heffalump> but a `id` b = a b
08:50:50 <kc5tja> That returns its value.
08:50:54 <Heffalump> just like with ($)
08:51:00 <kc5tja> No buts!!!
08:51:03 <kc5tja> Watch closely.
08:51:06 <osfameron> if you had to apply a function in Perl by first currying it several times, everything would be (*cough* even more) slow
08:51:07 <sjanssen> @type ($)
08:51:07 <kc5tja> a `id` b
08:51:09 <lambdabot> forall a b. (a -> b) -> a -> b
08:51:10 <bd_> > ($) id id id id id id id "$ takes 8 arguments)
08:51:11 <lambdabot>  Improperly terminated string
08:51:12 <kc5tja> (id a) b
08:51:13 <bd_> > ($) id id id id id id id "$ takes 8 arguments"
08:51:13 <kc5tja> a b
08:51:15 <lambdabot>  "$ takes 8 arguments"
08:51:15 <kc5tja> See?
08:51:25 <mauke> kc5tja: you have no point
08:51:27 <Heffalump> ok, so what you're saying is that instantiating a polymorphic function at a particular type can change the number of arguments it takes?
08:51:42 * mux yawns
08:51:47 <kc5tja> How can you say that I have no point, when I've offered evidence upon evidence in support of my point?
08:51:58 <mauke> how can you support a point that doesn't exist?
08:52:18 <kc5tja> My point is that the type signatures is a reliable means of identifying what functions take in, and what they produce.
08:52:24 <kc5tja> That has ALWAYS been my point.
08:52:27 <mauke> ($) :: (a -> b) -> (a -> b); ($) x = x
08:52:31 <mauke> valid definition of ($)
08:52:38 <bd_> kc5tja: type Foo a b = a -> b; Now ($) :: (a -> b) -> Foo a b
08:52:39 <mauke> one argument.
08:52:43 <Heffalump> I think most people probably think that your point is rather irrelevant. You seem to be choosing to define something a particular way because it helps you to think about things. Most people don't think it's worth sticking quite so dogmatically to that view, because sometimes it's better to think about things in other ways.
08:53:07 <bd_> kc5tja: or! ($) :: (a -> b) -> (a -> b)
08:53:09 <dcoutts_> kc5tja: and also because the standard implementations do not work that way.
08:53:16 <osfameron> mauke: can you make that points free by just definiting it as:   ($);
08:53:25 <Heffalump> And do you accept what I said, that your position means that instantiating a polymorphic function at a particular type changes this property you are trying to define?
08:53:31 <mauke> osfameron: heh, no
08:53:39 <Heffalump> osfameron: would be nice :-)
08:53:41 <kc5tja> dcoutts_: The implementations are a means to an end, not the end itself.
08:53:45 <dcoutts_> kc5tja: what they identify as arguments at runtime is not quite the same as what you're thinking about. The push/enter vs eval/apply paper explains this.
08:54:12 <mdmkolbe|work> DRMacIver: at the language level, yes, every function takes 1 argument.  But at the implementation level GHC plays some tricks so ... eh, dcoutts_ beat me to it.
08:55:47 <kc5tja> bd_: Your example, again, just proves the effect of Currying.  Currying has never been in contention.
08:56:05 <DRMacIver> mdmkolbe|work: Well, I'd expect it to. It's only sensible (although the implementation details must be fun). I don't think that's what's being argued though - the question is purely about the language level. I think.
08:56:27 <bd_> kc5tja: Right, but (a -> b) -.(a -> b)
08:56:28 <bd_>  er
08:56:43 <mauke> kc5tja: what's your definition of function argument?
08:56:45 <DRMacIver> Certainly that's all I'm concerned with at this point. I barely understand how to use Haskell, let alone how to implement it. ;)
08:56:47 <bd_> kc5tja: Right, but (a -> b) -> (a -> b) could easily be seen as taking only one argument; rather than two. So either view is equally valid, really.
08:56:48 <mauke> I mean, how do you count them?
08:56:54 <kc5tja> mauke: Wow.
08:57:16 <kc5tja> mauke: I'm not sure how to respond to that.  I believe that to be _so_ basic as to all but defy explanation.
08:57:26 <mauke> it's the core of this issue
08:57:49 <kc5tja> mauke: An argument is ..... an argument.  It's axiomatic that a function of type a -> b takes one argument ('a') and returns one result ('b').
08:57:56 <mauke> I disagree
08:58:01 <Heffalump> kc5tja: even if b = Int -> Int ?
08:58:06 <kc5tja> Heffalump: YES.
08:58:17 <mauke> then all functions take a single argument
08:58:19 <kc5tja> I never said what 'a' or 'b' actually are.
08:58:22 <mauke> according to your definition
08:58:23 <bd_> kc5tja: Then, ($) is of type (a -> b) -> (a -> b), and takes a single argument.
08:58:38 <mauke> because every haskell function has the type a -> b
08:59:13 <Heffalump> kc5tja: ok, so if id is applied to a function, it suddenly takes a different number of arguments to if its applied to an Int.
08:59:25 <kc5tja> Unlike lists, though, an infinite function will never terminate if evaluated.  There comes a time when you MUST reach the end of a chain of one-valued functions.
08:59:29 <cdsmith> This seems to be going in circles.
08:59:34 <kc5tja> Heffalump: No.
08:59:34 <Heffalump> oh, no, you said the opposite of that, sorry.
08:59:40 <kc5tja> Doggone it, I'm about to frigging cry.
08:59:51 <mauke> what's an infinite function?
08:59:53 * mux grabs some pop-corn
09:00:01 <kc5tja> Given a function f x y z
09:00:06 <mauke> oh, as in f x1 x2 x3 ... ?
09:00:13 <kc5tja> We know that it can be curried to ((f x) y) z
09:00:32 <kc5tja> But at some point, at _some_ point, it MUST be evaluated such that (((f x) y) z) = v for some v.
09:00:42 <Heffalump> kc5tja: so your claim is that because id can sometimes only take one argument, we should think of it as *always* only taking one argument?
09:00:45 <mauke> yeah, so?
09:00:45 <kc5tja> Thus, f x y z is a _single_ expression.
09:01:03 <kc5tja> That takes three arguments, for _any_ x y z
09:01:09 <kc5tja> And returns some value v
09:01:14 * ibid 's new laptop has arrived
09:01:14 <mauke> f x y z is (((f x) y) z) because of precedence
09:01:19 <kc5tja> Who cares?
09:01:21 <kc5tja> non sequitor.
09:01:21 <mauke> it takes no arguments; it's an expression
09:01:34 <Heffalump> kc5tja: but the three is only significant if the result type is ground.
09:01:37 <kc5tja> OK, I give up.
09:01:43 <Heffalump> If it turns out to be another function, then f takes more than three arguments.
09:01:51 <kc5tja> My position still stands, but if you're not willing to listen, then *** it.
09:02:06 <Heffalump> and I don't understand how your position deals with functions wrapped up in datatypes.
09:02:10 <mauke> kc5tja: your position is that all functions take exactly 1 argument
09:02:14 <sjanssen> kc5tja: please be civil
09:02:29 <Heffalump> if f :: Int -> Foo, where data Foo = Foo (Int -> Int), how many arguments does f take?
09:02:31 <kc5tja> Heffalump: How many times do I have to say, "for _any_ x y z or v?"  I don't care WHAT x y z or v are -- they exist and can be reasoned about _independently_ of the expression under consideration.
09:02:36 <bd_> kc5tja: in (map f $ l), how many arguments does map take?
09:03:02 <kc5tja> sjanssen: I've been civil.  I ask that the community please be considerate.
09:03:12 <Heffalump> but f x y = w for some w, too.
09:03:13 <bd_> 1? It is after all ($) (map f) l. 2? It is after all equivalent to (map f l)
09:03:21 <kc5tja> Heffalump: Yes......that's very true.
09:03:25 <cdsmith> :t \f -> (map f $ 1)
09:03:28 <lambdabot> forall a b. (Num [a]) => (a -> b) -> [b]
09:03:32 <ski> > foldr (\c f s -> f (c : s)) id "foo" ""
09:03:34 <lambdabot>  "oof"
09:03:38 <mauke> bd_: (map f l) == ((map f) l)
09:03:39 <Heffalump> and please answer my question about Foo
09:03:44 <mauke> so both map and (map f) take a single argument
09:03:52 <bd_> mauke: Indeed! But I'm wondering how kc5tja's rule would classify it.
09:03:54 <cdsmith> bd_: I don't think (map f $ 1) really makes any sense at all.
09:04:03 <bd_> cdsmith: l not 1 :)
09:04:04 <kc5tja> f takes one argument.
09:04:08 <pitecus> I have a function with this signature: (a -> IO [a]) -> ([a] -> IO [a]) Can I lift it somehow to (a -> IO (Maybe [a])) -> ([a] -> IO (Maybe [a])) ?
09:04:12 <cdsmith> bd_: oh!
09:04:28 <Heffalump> kc5tja: but to be any use, we have to unwrap its result and give it another argument
09:04:32 <DRMacIver> pitecus: Hm. Isn't that what monad transformers are for?
09:04:33 <bd_> cdsmith: And I suppose you could define instance Num [a]... but it'd be evil to do so :)
09:04:42 <Heffalump> I don't see what's conceptually different about f and another function of type Int -> Int -> Int
09:04:44 <cdsmith> bd_: yes, it would
09:04:47 <pitecus> DRMacIver, could be...
09:04:55 <mauke> bd_: "It's axiomatic that a function of type a -> b takes one argument ('a') and returns one result ('b')."  "even if b = Int -> Int ?"  "YES."
09:05:04 <sjanssen> kc5tja: I'd just like to point out that claiming others are "not willing to listen" is not generally helpful
09:05:04 <bd_> Indeed.
09:05:11 <DRMacIver> pitecus: I ask this in ignorance. I don't know much about them. :) But the people who are likely to know seem more concerned about the number of arguments functions have.
09:05:35 <sjanssen> pitecus: that looks possible
09:05:50 <Heffalump> pitecus: yes, but I don't think monad transformers are helpful.
09:05:59 <kc5tja> sjanssen: Others can disagree, but should offer support for their claims.  I haven't see this support.  They just disagree and blow me off.  And that's rather rude.
09:06:04 <Heffalump> cos your function isn't polymorphic in the monad to begin with
09:06:08 <DRMacIver> ok.
09:06:09 <pitecus> sjanssen, Heffalump code inference would be helpful..
09:07:00 <sjanssen> pitecus: hack until it typechecks -- with a type like that, there's likely only one reasonable solution :)
09:07:00 * Heffalump types your signature into an editor
09:07:19 <bd_> kc5tja: I don't think people are really understanding how you're arguing... see mauke's quote of your argument. Given: "It's axiomatic that a function of type a -> b takes one argument ('a') and returns one result ('b')."  "even if b = Int -> Int ?"  "YES." - it's hard to see how/why you're arguing ($) has two arguments
09:07:24 <bd_> After all I can do:
09:07:24 <bd_> map' = ($) map
09:07:42 <kc5tja> bd_: Because it's defined as such.
09:07:50 <mauke> kc5tja: no, it isn't. see above.
09:07:52 <bd_> kc5tja: I can define ($) as follows:
09:07:53 <kc5tja> bd_: a $ b = ... <-- that's how it's defined.
09:07:56 <bd_> ($) :: (a -> b) -> (a -> b)
09:07:56 <mauke> kc5tja: ($) x = x
09:07:57 <bd_> ($) = id
09:08:01 <mauke> kc5tja: that's how it's defined
09:08:05 <bd_> this is a legal and accurate definition of ($)
09:08:13 <bd_> we can verify this:
09:08:24 <DRMacIver> Neat.
09:08:25 <Heffalump> irssi is suddenly cutting off the first character of everyone's nicks!
09:08:27 <sjanssen> I think kc5tja's concept of arity might be better explained as a lower bound of possible applications given a specific type signature
09:08:33 <Heffalump> oh, and the first character of what they say.
09:08:44 <ski> @src $
09:08:45 <lambdabot> f $ x = f x
09:08:45 <mauke> kc5tja: the number of parameters before the = isn't directly related to the type signature
09:08:49 <bd_> @check let ($$) = id in \a b -> ((a :: Int -> Int) $$ (b :: Int -> Int)) == (a $ b)
09:08:51 <lambdabot>  Couldn't match expected type `Int -> Int'
09:08:56 <bd_> erm
09:08:59 <bd_> @check let ($$) = id in \a b -> ((a :: Int -> Int) $$ (b :: Int)) == (a $ b)
09:09:00 <assl0r> > 1^infinity
09:09:00 <lambdabot>  OK, passed 500 tests.
09:09:01 <lambdabot>   Not in scope: `infinity'
09:09:25 <bd_> kc5tja: As you can see, we have a completely valid alternate implementation of ($) which takes 'one argument'. They are indistinguishable by their effects.
09:09:43 <bd_> Actually, we have three: a $ b = a b; ($) x = x; ($) = id.
09:09:46 <cdsmith> sjanssen: could that be falsified, though, by doing something like (instance Real (a -> b))?  Then you don't have to apply a function to get a value from it.
09:09:46 <mauke> ($) = ask
09:09:50 <joelr1> @undo .pl do { x <- toSharp y; return $ x : [] }
09:09:51 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
09:09:56 <Heffalump> pitecus: can you msg me your signature?
09:09:56 <bd_> and now a monadic implementation :)
09:09:56 <ski> pitecus : erm .. is your '(a -> IO [a]) -> ([a] -> IO [a])' some kind of bind for '[]' in the kleisli category over 'IO' ?
09:10:08 <joelr1> @undo do { x <- toSharp y; return $ x : [] }
09:10:09 <lambdabot> toSharp y >>= \ x -> return $ x : []
09:10:12 <Heffalump> unless someone has already answered your question
09:10:30 <joelr1> @pl toSharp y >>= \ x -> return $ x : []
09:10:31 <lambdabot> return `fmap` toSharp y
09:11:19 <pitecus> ski, I dont even know what you're taking about
09:11:37 <joelr1> @pl let f y = toSharp y >>= \ x -> return $ x : []
09:11:38 <lambdabot> (line 1, column 47):
09:11:38 <lambdabot> unexpected end of input
09:11:38 <lambdabot> expecting variable, "(", operator, ":", "++", "$", "$!", "`seq`", ">>", ">>=", "=<<", ";" or "in"
09:11:52 <kc5tja> If one cannot depend on the type signature of a function to tell me what is expected or is returned, then it is not possible to statically reason about the code, which undermines the whole the reason for FPLs in the first place, in my opinion.
09:11:56 <Heffalump> pitecus: oh, wait. I don't think it is possible.
09:12:10 <Heffalump> oh, no, I think it is, sorry :-)
09:12:14 * Heffalump --> hack a bit more
09:12:21 <mauke> kc5tja: it's called "polymorphism"
09:12:25 <pitecus> But I think there are multiple solutions
09:12:35 <Heffalump> actually, what do you want it to do?
09:12:43 <joelr1> @undo f x = do { x' <- toSharp x; return $ x' : [] }
09:12:44 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}) "Parse error"
09:12:47 <kc5tja> mauke: I know what polymorphism is, but you can still make claims and verify results with it.
09:12:48 <pitecus> You can collect all the Justs and concat them
09:12:48 <joelr1> rrrr
09:12:50 <Heffalump> somehow we have to make an a -> IO [a] out of your a -> IO (Maybe [a])
09:12:54 <mauke> kc5tja: yes, exactly
09:13:01 <kc5tja> mauke: Provided you know what's going on.
09:13:07 <mauke> kc5tja: so what's the problem now?
09:13:11 <Heffalump> and we could just throw it away and use return . wrap
09:13:19 <kc5tja> mauke: The problem is, you can't know.
09:13:19 <Heffalump> so we'd better decide on the actual behaviour we want
09:13:21 <bd_> kc5tja: On the contrary; it is, but you cannot simply say that 'function x has y arguments' in the general case; it depends on the specific type. We can make a more formal definition of a function's arity like so: arity(x) = 0 if x is not a function; arity(x -> y) = arity(y) + 1. However this depends on the context of the function and, more specifically, the type it is instantiated to. It also does not consider newtypes.
09:13:38 <mdmkolbe|work> I think (but I'm not sure) that the point of confusion/dissagreement depends on the realization that 'f a b = expr' is the same (in Haskell) as 'f a = \b -> expr' is the same as 'f = \a -> \b -> expr'.  So f could be thought of as taking 0, 1 or 2 (or more depending on expr) arguments.  But then again I haven't been listening to closely so I'm completely confused what anyone ie arguing for.
09:13:44 <cdsmith> kc5tja: I'm interested in what you think about (instance Real (a -> b)).  Then I get define f :: a -> b -> c, and get a value from it without applying f to two arguments.
09:13:57 <bd_> kc5tja: And you can make plenty of claims, they just have to be valid no matter what the type comes out to. @free can actually generate them from the type :)
09:14:03 <bd_> @free (a -> b) -> (a -> b)
09:14:04 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:14:09 <bd_> ... or it might be broken
09:14:14 <Heffalump> @free a -> a
09:14:14 <bd_> @free id :: (a -> b) -> (a -> b)
09:14:15 <lambdabot> Extra stuff at end of line
09:14:15 <lambdabot> g . h = k . f => g . id h = id k . f
09:14:18 <bd_> there we go
09:14:26 <bd_> @free id :: (a -> a)
09:14:26 <lambdabot> f . id = id . f
09:14:33 <osfameron> it's funny how the "lists of positional arguments" thing is an antipattern in, for example, idiomatic Perl, yet turns out to have useful consequences (currying etc.) in haskell
09:14:39 <pitecus> I think I need to return a Nothing as soon as one there is Nothing in the result list
09:14:39 <kpreid> @free always needs a name, and maybe a type
09:14:40 <lambdabot> Extra stuff at end of line
09:15:02 <Heffalump> so if any of the input values causes a nothing, you want the whole thing to cause a nothing?
09:15:03 <cdsmith> osfameron: I think that says more about the antipatterns trend than about perl or haskell.
09:15:18 <Heffalump> I'm not sure why you actually want to use the (a -> IO [a]) -> [a] -> IO [a] function at all.
09:15:24 <joelr1> @undo let f x = do { x' <- toSharp x; return $ [x'] }
09:15:25 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
09:15:31 <joelr1> @pl let f x = do { x' <- toSharp x; return $ [x'] }
09:15:31 <lambdabot> (line 1, column 14):
09:15:32 <lambdabot> unexpected "{"
09:15:32 <lambdabot> expecting variable, "(", operator, ";" or "in"
09:15:32 <Heffalump> Why not just implement what you want directly? Do you want to parameterise over it somehow?
09:15:35 <LeCamarade> @check let fac x = if x < 1 then 1 else x * fac (x - 1)
09:15:35 <lambdabot>  Parse error
09:15:54 <ski> pitecus : converting '(a -> IO [b]) -> ([a] -> IO [b])' to is too general '(a -> IO (Maybe [b])) -> ([a] -> IO (Maybe [b]))' ?
09:16:08 <joelr1> @undo do { x' <- toSharp x; return $ [x'] }
09:16:09 <lambdabot> toSharp x >>= \ x' -> return $ [x']
09:16:12 * ski doesn't know if that is possible, btw
09:16:16 <pitecus> Heffalump, I have the other functions lying around
09:16:28 <ski> pitecus : the
09:16:28 <joelr1> @pl toSharp x >>= \ x' -> return $ [x']
09:16:29 <lambdabot> return `fmap` toSharp x
09:16:33 <Heffalump> pitecus: I still think it'd be easier not to use it :-)
09:16:41 <ski> (a -> IO [a]) -> ([a] -> IO [a])' one ?
09:17:07 <sjanssen> @. pl undo do { x' <- toSharp x; return $ [x'] } -- looking for this, joelr1?
09:17:08 <lambdabot> return `fmap` toSharp x
09:17:09 <LeCamarade> @check let fac x = if x < 1 then 1 else x * fac (x - 1) in fac 2
09:17:17 <lambdabot>  Add a type signature
09:17:23 <joelr1> sjanssen: yes, thanks :-)
09:17:41 <osfameron> cdsmith: oh?  Well, in an untyped languages a function taking lots of positional parameters gets very ugly and hard to maintain.  Often it's "better" to do ( foo=>$foo, bar=>$bar, ...) etc.  Not sure that's really an antipattern movement, more thinking about what works best.
09:17:43 <pitecus> ski its ok
09:18:33 <hpaste>  Heffalump pasted "(no title)" at http://hpaste.org/1746
09:18:37 <Heffalump> e.g. that
09:18:54 <cdsmith> osfameron: I meant that one ought to expect different idioms will work differently in different languages.
09:19:16 <Heffalump> even in Haskell it can make sense to use a record parameter to a function
09:19:30 <Heffalump> if it's growing to take a lot of arguments, for example, or the argument list isn't stable
09:19:35 <cdsmith> osfameron: so the idea of identifying something as an "antipattern" instead of just evaluating whether it's a good idea on a case by case basis carries some risks.
09:19:40 <osfameron> cdsmith: yes, ok.  I guess I thought I was admitting that by the "it's funny how..." ;-)
09:19:41 <ski> @type let foo amb [] = return (Just []); foo amb (a:as) = amb a >>= maybe (return Nothing) (\a -> foo amb as >>= maybe (return Nothing) (\as -> return (Just (a:as)))) in foo
09:19:44 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> m (Maybe a)) -> [t] -> m (Maybe [a])
09:20:03 <cdsmith> osfameron: I wasn't arguing against you.  Just commetning.
09:20:07 <ski> actually, that's not right
09:20:08 <cdsmith> or even commenting.
09:20:11 <osfameron> Heffalump: right, that's the same reasoning
09:20:16 <osfameron> cdsmith :-)
09:20:23 <Heffalump> ski: I think you need a ++ not a :
09:20:43 <Heffalump> cos you're missing a [] in the result type of the input function
09:21:02 <ski> yes, i just noticed that :)
09:21:07 <joelr1> how do i convert toSharp :: a -> Class b into something that runs toSharp and then does result : []? point-free, of course
09:21:25 <ski> (but i'm not sure about '(++)' yet)
09:21:26 <Heffalump> (:[]) . toSharp
09:21:29 <mauke> return . toSharp
09:21:59 <Heffalump> mine has an easier to understand type, mauke's is more general if you want an arbitrary monad :-)
09:22:11 <joelr1> Heffalump: thanks
09:22:20 * Heffalump disappears
09:22:24 <Saizan> @quote eat
09:22:25 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
09:22:47 <Saizan> @quote eat.a.comment
09:22:47 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
09:22:52 <joelr1> Heffalump: hmm, that's wrong. that's a -> [Class b] whereas I want a -> Class [b]
09:23:03 <lypanov> lol
09:23:09 <Saizan> that depends on your Class
09:23:12 <mdmkolbe|work> @type [{- -}]
09:23:13 <mauke> fmap return . toSharp
09:23:15 <lambdabot> forall a. [a]
09:23:28 <joelr1> mauke: whereas the making of a list?
09:23:35 <mdmkolbe|work> @type [ ]
09:23:36 <mauke> joelr1: what?
09:23:37 <lambdabot> forall a. [a]
09:23:53 <ski> (Heffalump : yes, probably doing '(++)' is the best one can do, i think)
09:24:08 <joelr1> mauke: you said fmap return . toSharp
09:24:08 <Saizan> joelr1: if your class is a subclass of Functor you can use fmap (:[]) . toSharp
09:24:11 <mdmkolbe|work> @type \x -> case x of [ ] -> 0
09:24:13 <lambdabot> forall t t1. (Num t1) => [t] -> t1
09:24:16 <mauke> joelr1: yes
09:24:23 <DRMacIver> What on earth is toSharp?
09:24:26 <Saizan> return = (:[]) in the list monad
09:24:27 <joelr1> Saizan: Class is a monad
09:24:32 <joelr1> toSharp is a function
09:24:34 <ski> pitecus : so .. care to tell if it does what you wanted to do ?
09:24:38 <mauke> then you can make it a Functor
09:24:40 <mauke> or use liftM
09:24:48 <Saizan> ok, so you can use liftM (:[]) . toSharp
09:25:00 <pitecus> ski sorry i missed it wher is it?
09:25:20 <Heffalump> pitecus: there's my paste, or the line of code ski provided
09:25:22 <mauke> :t liftM return . ?f
09:25:24 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1, ?f::a -> m1 a1) => a -> m1 (m a1)
09:25:32 <Heffalump> They do the same thing if you fix ski's code with (++) as we discussed afterwards.
09:25:49 <ski> @hoogle concatMapM
09:25:50 <lambdabot> No matches found
09:26:11 * ski nods
09:27:48 <pitecus> Ya Heffalump ski that looks good
09:29:32 <pitecus> This one is even shorter: h f xs = mapM f xs >>= \rs -> if all isJust rs then  return . Just . concat . catMaybes $ rs else  return Nothing
09:29:52 <Heffalump> yes, that looks ok too
09:30:12 <ski> m
09:30:55 <Heffalump> although it runs f more times than ours do
09:31:07 <Heffalump> so if f has side-effects you care about, you need to decide which you actually want
09:32:12 <ski> short-circuit behaviour, or strict execution over every list element ?
09:32:55 <pitecus> thats right
09:33:03 <pitecus> haven't noticed
09:47:42 <shapr> Life is good!
09:49:03 <stepcut> yay!
09:49:16 <cdsmith> Curiosity: what is the design reason for (Show a) => Num a.  Was it necessary for some reason?
09:49:28 <emu> coLife is not good!
09:50:17 <ski> why not ?
09:50:20 <emu> cdsmith: i think to prevent enlarging of func type sigs in prelude
09:50:39 <Heffalump> how many prelude functions on Num a need Show a too?
09:50:42 <emu> because life /= colife?
09:50:56 <mauke> Heffalump: none?
09:51:08 <emu> so much for that explanation
09:51:11 * Heffalump was thinking it was something to do with helping people just use literals and display them easily, but you could do that just by having Show on all the standard Num types
09:51:47 <mauke> I think having Show and Eq in Num is a bug
09:51:54 <cdsmith> Well, saying (print 5) would cause 5 to have type (Num a, Show a) => a, which would in turn affect defaulting.  So that shouldn't be needed.
09:52:03 <Heffalump> Eq is useful, I think
09:52:15 <mauke> not if you want to make functions instances of Num
09:52:17 <Heffalump> for example I think the implementation of Complex sqrt uses it
09:52:30 <Heffalump> not universally useful, but useful in some cases
09:53:18 <cdsmith> mauke: for example, if one were implementing Church numerals in Haskell? ;)
09:54:11 <mauke> no, I want a generic monad instance
09:54:13 <shapr> dons: How do you grep the #haskell logs so quickly? I want to do that too!
09:54:25 <mauke> instance (Num a, Monad m) => Num (m a)
09:54:55 <cdsmith> mauke: I see.
09:54:58 <vegai> he probably has a 32-core supercomputer reserved for that, shapr
09:55:39 <sjanssen> oh, there's a good idea
09:56:11 <sjanssen> write a program that uses Data.ByteString and GHC's parallelism support to write a really fast grep
09:56:19 <dolio> cdsmith: You can also do cute things by defining 'instance Num a => Num (a -> a) ...'
09:56:43 <Heffalump> except that's not H98
09:57:06 <Heffalump> Num a => Num (b -> a) is
09:57:12 <dolio> cdsmith: Then you can write stuff like, 'f = sin^2 + 1', and then evaluate 'f 1' which gives you '(sin 1)^2 + 1'.
09:57:15 <dcoutts_> sjanssen: hmm, divide the input into NCPU chunks and grep on each?
09:57:26 <sjanssen> dcoutts_: right
09:57:33 <dcoutts_> sjanssen: the tricky bit is dealing with matches that cross chunk boundaries
09:57:41 <Heffalump> thus giving your disk a headache :-)
09:57:52 <mauke> dolio: that's what my instance does
09:58:04 <sjanssen> dcoutts_: or only search each file argument in parallel
09:58:22 <dolio> mauke: Ah, yeah. I guess that's just a special case with the (->) e monad?
09:58:24 <dcoutts_> sjanssen: that'd probably be easier
09:58:47 <mauke> dolio: exactly
09:58:47 <Heffalump> @instances Monad
09:58:47 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:58:47 <dolio> Nice.
09:59:18 <sjanssen> dcoutts_: yeah, getArgs >>= mapM_ (forkIO . search)
09:59:20 <sjanssen> done.
10:00:31 <ski> @instances MonadTrans
10:00:32 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
10:00:34 <ddarius> dcoutts_: Have the chunks overlap.
10:00:59 <ski> @hoogle Endo
10:01:00 <lambdabot> System.Win32.File.c_SetEndOfFile :: HANDLE -> IO Bool
10:01:00 <lambdabot> System.Win32.File.setEndOfFile :: HANDLE -> IO ()
10:01:11 <dcoutts_> ddarius: a single match could start just before the end of a chunk and extend to the end of the file.
10:01:18 <sjanssen> if we still had Data.ByteString.mmapFile, I'd be writing this right now ;)
10:01:31 <dcoutts_> sjanssen: you could make it portable for us :-)
10:01:48 <dcoutts_> sjanssen: ie get mmap into System.Posix.Internals
10:02:08 <dcoutts_> sjanssen: and implement in terms of mmap or the win32 equivalent
10:02:20 <ddarius> In practice, that's probably not a problem, though in practice losing the boundary crossing chunks probably isn't a problem either.
10:02:21 * ndm reminds dcoutts_ that Posix /= portable
10:02:39 <ddarius> @vera POSIX
10:02:41 <lambdabot> *** "posix" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
10:02:41 <lambdabot> POSIX
10:02:41 <lambdabot>      Portable Operating System for unIX (OS, IEEE 1003, ISO 9945, PASC,
10:02:41 <lambdabot>      Unix)
10:02:41 <lambdabot>  
10:03:11 <dcoutts_> ndm: you need to have System.Posix.Internal renamed, since de-facto it is the bit that is portable to win32 and unix
10:03:32 <dcoutts_> sjanssen: hmm, actually System.MMap might be better, with a more portable api that doesn't expose the unixisms.
10:04:09 <dcoutts_> or System.MappedFile or something
10:04:54 <dcoutts_> ndm: any suggestion how we should implement portable things in base that need to use either the posix or win32 packages?
10:05:07 <ddarius> dcoutts_: Also, for this purpose you could have (and it's probably desirable to have) a user specified limit to how big the matches should be.
10:05:46 <ndm> dcoutts_ cpp, but generally you need to take concepts, not individual API's - the information currently leaks too much
10:06:34 <dcoutts_> ndm: and the base package would have to conditionall depend on win32/posix
10:07:29 <ndm> dcoutts_ yes
10:07:47 <Cheery> FRP is actually quite ugly
10:08:14 <ddarius> Perhaps Cells or FrTime would do you better.
10:08:40 <Cheery> I wonder what would contain same expressive strength but be simpler
10:08:50 <Cheery> ?where Cells
10:08:50 <lambdabot> I know nothing about cells.
10:08:55 <Cheery> ?where FrTime
10:08:55 <lambdabot> I know nothing about frtime.
10:09:02 <Cheery> @google Cells
10:09:04 <lambdabot> http://www.cellsalive.com/
10:09:05 <lambdabot> Title: Home of CELLS alive!
10:09:12 <Cheery> ...
10:09:12 <ddarius> Cells is a Common Lisp thing and FrTime is a Scheme thing.
10:09:24 <ddarius> @google Cells "Kenny Tilton"
10:09:27 <lambdabot> http://mail.python.org/pipermail/python-list/2003-August/221487.html
10:09:27 <lambdabot> Title: For Kenny Tilton: Why do I need macros revisited.
10:09:38 <ddarius> @google FrTime Scheme
10:09:39 <lambdabot> http://citeseer.ist.psu.edu/cooper04frtime.html
10:09:40 <lambdabot> Title: FrTime: Functional Reactive Programming in PLT Scheme (ResearchIndex)
10:09:44 <Cheery> how are they implemented?
10:09:57 <emu> Kenny spams Cells in every email/news posting he makes, so its gonna come up all over
10:10:21 <ddarius> I think Cells is more or less implemented the same way as FrTime and there are papers detailing FrTime's implementation.
10:10:27 <ddarius> That one probably does.
10:11:21 <Cheery> so I can just look at FrTime
10:13:11 <Cheery> a toilet having external outlets going on the floor would best resemble yampa
10:14:01 <Cheery> something useful, but too complex
10:14:30 <Cheery> *too complex to use
10:18:31 <hpaste>  one_sk pasted "please help to compile" at http://hpaste.org/1747
10:18:50 <Cheery> I like the idea of taking input and interacting with the world via timetagged events and streams of values, but I wouldn't like to get too complicated while getting to it
10:23:36 <dolio> Cheery: You might want to look at Flapjax. It's more or less FRP, intended for use in web programming/ajaxy stuff.
10:24:25 <dolio> Of course, it's not Haskell.
10:25:09 <Cheery> dolio: I've not looked into it, if it's not too imperative, I could look into it
10:25:51 <dolio> Cheery: There was a nice video presenting it a while back. I'll see if I can find it.
10:26:24 <dolio> You might be able to mix and match with imperative style a little more than in one of the Haskell type FRP frameworks, though.
10:26:34 <dolio> Since it's intended for use by real people. :)
10:27:22 <Cheery> but functional is intended for use by real people! ;)
10:27:31 <Cheery> btw. this flapjax starts well I think
10:27:55 <Cheery> (reading the tutorial, looks good from first glance)
10:28:21 <dolio> http://programming.reddit.com/goto?id=jb4v
10:28:28 <dolio> That should take you to the video.
10:28:39 <dolio> The first half is a continuation-based web framework, the second half is flapjax.
10:29:25 <dolio> And don't mind his derogatory comments about functional programming. That's just how you sell it to the masses, apparently. :)
10:31:24 <dmwit> "We all know those Haskell people are crazy."
10:31:28 <kc5tja> hmmm....is it just me, or am I the only one who finds The Little Lisper/Schemer to be a gut-wrenchingly, brain inflammatory exercise in intelligence insultation?
10:31:47 <DRMacIver> No, I'm with you on that
10:31:48 <dmwit> I think another of my favorite quotes compares monad transformers to a true knowledge of Hell.
10:32:22 <one_sk> Sorry, can I ask for little help?
10:32:38 <dmwit> one_sk: Just ask the question, don't ask to ask.
10:32:40 <dmwit> ;-)
10:32:53 <emu> can I ask you to ask a question?
10:33:11 <dmwit> DIDN'T GIVE ME MUCH CHOICE THERE, NOW DID YOU EMU?
10:33:19 <one_sk> ;) I tried to exerice Haskell by writing a tiny Brainf**k implementation in it
10:33:37 <one_sk> Of course, to make matters simpler, I used implicit parameters, monad transformers and state threads
10:33:42 <emu> lol
10:33:46 <one_sk> and have bad luck compiling it ;)
10:33:53 <dmwit> heh
10:34:09 <mauke> aren't implicit parameters deprecated?
10:34:28 <dolio> They're ghc-only, aren't they?
10:34:39 <one_sk> the code is on hpaste: http://hpaste.org/1747
10:34:42 <emu> implicit params + monad transformers seem a bit redundant
10:35:12 <one_sk> the whole thing is about ST polymorphism restricted i think
10:35:30 * esap just crashed emacs :-)
10:35:37 <one_sk> Yeah, I could've passed tape in the ReaderT, but i just wanted to give implicit params a try :shy:
10:36:30 <mauke> heh
10:36:54 <mauke> "oh, a new feature! ... HNNG MUST USE IT"
10:37:00 <one_sk> to me, it's the only viable alternative for global state when compared to unsafePerformIO
10:37:31 <one_sk> Well,l people, I'm just trying features. Can't I do that? ;)
10:37:36 <mauke> one_sk: http://okmij.org/ftp/Haskell/types.html#Prepose
10:37:37 <lambdabot> Title: Haskell Programming: Types
10:37:41 <DRMacIver> dolio: Is it just my imagination or is that video very staticky?
10:37:51 <DRMacIver> s/imagination/computer/
10:38:40 <dolio> DRMacIver: Yeah. He's kind of loud. I think his voice gets clipped a lot.
10:39:04 <Saizan> one_sk: can you annotate the error?
10:40:16 <one_sk> The problem is that i simply don't understand the reason of error: it says that it can't match (ST s (Int, String,String)) with (forall s. ST s (Int, String,String))
10:40:38 <one_sk> but as far as I'm concerned they're perfectly compatible
10:41:07 <Cale> one_sk: The first might be instantiated with some s
10:41:18 <Cale> Like, if you have a function of type:
10:41:30 * kc5tja thinks he should parody Little Lisper by making a Little Forther book, only with extra insults.  ;)
10:41:49 <Heffalump> oh, you're doing runST $
10:41:51 <Heffalump> you can't do that
10:41:53 <DRMacIver> kc5tja: There are all sorts of Little Languager books. There's a Little MLer as well.
10:42:03 <Cale> (forall s. (s,s) -> s) -> (a, a) -> a
10:42:04 <Heffalump> you need to use runST (...) instead of runST $ ...
10:42:06 <kc5tja> DRMacIver: Yeah, but how many are _parodies?_
10:42:19 <DRMacIver> kc5tja: Not many. I'm just saying, it's not inconceivable that there's a serious little Forther. :)
10:42:21 <Cale> then you can't pass it something which is of type (Char, Char) -> Char
10:42:31 <one_sk> You mean that the reason is the monomorphism of ($)?
10:42:34 <Heffalump> one_sk: yes
10:42:44 <DRMacIver> (But it doesn't seem there is)
10:42:46 <Heffalump> well, it's not exactly monomorphic
10:42:49 <Cale> ($) is polymorphic, but it's not *that* polymorphic
10:42:51 <Heffalump> it just can't handle a rank-2 type
10:42:55 <kc5tja> I mean, nobody ever would consider using Forth for anything but an embedded project now-a-days, so that'd be a joke in itself.  But the fact that it'd do everything from insult your intelligence to your family lineage ... now THAT qualifies as a Little Forther!  ;D
10:43:14 <Saizan> and that type annotation in wrapRTS should go away and you should give a rank2 signature to wrapRTS instead, i think
10:43:19 <cinimod> @type unfold
10:43:20 * DRMacIver would consider using Forth simply for the cool value.
10:43:22 <lambdabot> Not in scope: `unfold'
10:43:27 <DRMacIver> But probably not for a real project. :)
10:43:45 <one_sk> ;) that simple. Sorry for not having paid enough attention. One error less...
10:43:51 <dolio> @type unfoldr
10:43:54 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:44:08 <ski> evening esap
10:44:12 <kc5tja> "Now what do you suppose 2 does?"  "It puts a tree in the ground outside the Whitehouse?" || "Correct!  Now what kind of tree?" "Ummmm......a CHERRY tree!"  ||  "Right!"
10:44:17 <kc5tja> DRMacIver: Heheh
10:44:42 <DRMacIver> kc5tja: It seems like a really appealing language.
10:44:54 <kc5tja> Forth is a nice language -- but it really sucks ass when things go really wrong.  ;D
10:44:55 <DRMacIver> But there are lots of really appealing languages which I never get around to using.
10:45:14 <chessguy> hi haskellers
10:45:16 <Heffalump> one_sk: people get confused by runST $ so often that the current GHC head has a type system hack just to fix that problem.
10:45:25 <Heffalump> Though I think SPJ accepted it was too nasty to keep.
10:45:26 <DRMacIver> chessguy: I thought we agreed that we were haskellistas?
10:45:29 <esap> evening ski!
10:45:42 <chessguy> i don't recall that
10:45:45 <esap> ski: what's up?
10:45:51 <one_sk> Heffalump: Yes, that's quite a tricky pitfall. For a newbie like me at least
10:46:04 <kc5tja> Or maybe we're Haskellian?
10:46:35 <one_sk> and one more question concerning implicit parameters: are they hoisted like foralls by GHC?
10:49:11 <one_sk> Inferred type is less polymorphic than expected
10:49:13 <one_sk>   Quantified type variable `s' is mentioned in the environment:
10:49:14 <one_sk>     act :: Int -> StateT BfState (ST s) () (bound at BF.hs:33:17) - how to understand that?
10:52:59 <Heffalump> one_sk: it means you are letting some STRef/STArray "escape"
10:53:09 <ehird`> quick
10:53:12 <ehird`> catch it
10:53:37 <one_sk> ok. gonna look it through
10:53:57 <Heffalump> ah, I see the problem
10:54:13 <one_sk> aha, something to do with STUArray not being in the state thread?
10:54:38 <Heffalump> it's because you're trying to wrap it up in a datatype
10:54:49 <Heffalump> using a type synonym
10:54:58 <Heffalump> I think if you made BfAction a newtype with an explicit forall you'd be ok
10:55:10 <one_sk> ok, i'll try that
10:55:14 <Heffalump> newtype BfAction = BfAction { unBfAction :: forall s. ... }
10:55:28 <Heffalump> not 100% certain, though
10:57:13 <augustss> ummm, won't that fail when you try to construct the BfAction value?
10:57:19 <Heffalump> (disappearing for a reboot shortly)
10:57:42 <Heffalump> augustss: why, the thing should be polymorphic in the s, surely?
10:58:08 <one_sk> you mean that type synonyms doesn't have an implicit forall in front of them?
10:58:24 <augustss> it feels wrong
10:58:26 <Heffalump> one_sk: umm. Not sure :-)
10:59:05 <augustss> when you exit the runST you should be able to free anything that has been allocated with an s in it.  that is my operational intuition
10:59:07 <Heffalump> one_sk: the thing is that they are basically just aliases.
10:59:21 <Heffalump> augustss: but this is just for sticking together bits of ST computations
10:59:43 <Heffalump> runST is only applied later
10:59:43 <one_sk> IMO, the problem is in the implicit parameter thing - it seems that STUArray has somehow "different" s that the whole ST computation
10:59:53 <augustss> oh.  i thought it was escaping the runST.  I didn't actually look at any code :)
10:59:57 <one_sk> implicit parameters seem to pass ?tape in some other way
10:59:58 <Heffalump> one_sk: conceptually, or in the type system?
11:00:03 <sjanssen> shouldn't it be "type BfAction s = ..."?
11:00:15 <one_sk> in type system sense I suppose
11:00:20 <Heffalump> oh, maybe that, yeah
11:00:43 <sjanssen> one_sk: have you tried floating 's' to the left of the = ?
11:01:03 <sjanssen> one_sk: implicit parameters aren't generally recommended, by the way
11:01:04 <one_sk> sjanssen: that's a good idea. trying it right now
11:01:24 <Heffalump> except that the closer forall reflects the code better, I think.
11:01:32 <fasta> Anyone here using Haskell-mode 2.3 with working jump to definition?
11:01:34 <Heffalump> actually, perhaps it makes no difference
11:01:43 <Heffalump> but it'll infect data ImCode too
11:01:54 <Heffalump> or you could put the forall there.
11:02:06 <Heffalump> (really about to disappear for this machine to be rebooted)
11:02:38 <emu> fasta: what about it?
11:02:53 <fasta> emu: how did you get it to work?
11:03:07 <emu> you need ghci running with your code loaded
11:03:11 <fasta> emu: or more precise: what's your configuration?
11:03:17 <fasta> emu: I have
11:03:42 <emu> it sends ":info symbol" to ghci and extracts the definition loc from the output of that
11:04:11 <emu> the code in question must be interpreted by ghci for it to know the location
11:04:18 <fasta> emu: I use hierarchical modules (and also refer to places higher in the hierarchy).
11:04:36 <emu> that may cause a problem
11:04:37 <fasta> emu: ghci can handle it, but haskell-mode 2.3 can't AFAIK.
11:05:04 <one_sk> aaaargh... I'd better rewrite the whole thing with ReaderT ;)
11:05:59 <Heffalump> I'm not convinced that implicit parameters are your problem.
11:06:03 <Heffalump> Though I never use them myself.
11:07:40 <njbartlett> Ah, augustss, thank you! :)
11:19:16 <lypanov> whats a good editor for interactive haskell usage?
11:19:45 <dcoutts_> grrr, QuickCheck's Gen isn't an instance of Applicative
11:20:20 <Cale> lypanov: Emacs?
11:20:48 <lypanov> Cale: it lets you execute a buffer for example? or a snippet? with a background ghci?
11:20:51 <Cale> lypanov: I usually just use vim, with ghci open in another window. Occasionally I'll use emacs if I intend to have the same Haskell files open for a long time.
11:20:52 <lypanov> i'm just trying to get into it
11:20:58 <lypanov> ah
11:21:20 <Cale> You can reload code in ghci with :
11:21:29 <Cale> (just a single colon on a line)
11:21:40 <lypanov> whats the most basic .hs file i can create?
11:21:45 <lypanov> evidently just "5" didn't work :P
11:21:53 <Cale> foo = 5
11:22:04 <dylan> main = return ()?
11:22:10 <Cale> or sure, define a main :)
11:22:25 <Cale> Depends if you want to compile it or just load definitions for ghci to use.
11:22:47 <lypanov> just defs for the moment
11:22:50 <emu> lypanov: yes, haskell-mode lets you do that stuff
11:23:16 <lypanov> i'm actually a vim/textmate user generally. and would prefer not to get into the emacs thing just yet
11:23:40 <emu> then what cale suggests works too
11:23:44 <lypanov> i'll go with cmd line ghci and : with textmate for editing. hope its syn hl doesn't suck
11:23:47 <lypanov> emu: :)
11:24:04 <lypanov> i have:
11:24:09 <emu> i can't speak for textmate but vim does have syn hl packages
11:24:11 <lypanov> map (map (2 *)) [[5, 5], [6, 5]]
11:24:30 <lypanov> but i wondered, can i simplify this and remove some of the parens using $ or . somehow?
11:24:53 <Cale> lypanov: It looks like TextMate has Haskell syntax highlighting support, though I have no idea how good it is.
11:25:19 <sjanssen> where can I find how many files a program can have open?
11:25:33 <ski> > let pam = flip map in [[5, 5], [6, 5]] `pam` \xs -> xs `pam` \x -> 2 * x
11:25:35 <lambdabot>  [[10,10],[12,10]]
11:25:51 <emu> > map (2 *) `map` [[5,5],[6,5]]
11:25:52 <Cale> hehe
11:25:52 <lambdabot>  [[10,10],[12,10]]
11:26:14 <Cale> If there was any justice in the world, you could write it as map $ map (2 *) $ [[5, 5], [6, 5]]
11:26:15 <ski> > ((2 *) `map`) `map` [[5,5],[6,5]]
11:26:17 <lambdabot>  [[10,10],[12,10]]
11:26:22 <Cale> but no, the associativity of $ is wrong
11:26:25 <lypanov> Cale: thats what i tried
11:26:37 <shapr> Why Haskell shuns side-effects: <Lemmih> I don't think executing side-eKAJLdfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFFFFFFJAL
11:26:50 <Cale> hahaha
11:26:54 <ski> Cale : yes
11:27:28 <Cale> @remember Lemmih I don't think executing side-eKAJLdfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFFFFFFJAL
11:27:29 <lambdabot> Done.
11:28:17 <sjanssen> shapr: you should see my faster log searcher
11:28:42 <hpaste>  sjanssen pasted "sjanssen" at http://hpaste.org/1748
11:28:58 <sjanssen> oops, wrong title
11:29:52 <sjanssen> shapr: http://hpaste.org/1748 is already twice as fast as grep over here
11:30:36 <lypanov> Cale: you used to be in #perl?
11:30:51 <emu> the hidden past unveiled
11:30:54 <Cale> lypanov: hmm
11:31:02 <Cale> lypanov: I've joined there a couple times.
11:31:09 <Cale> lypanov: and #perl6 too
11:31:12 <shapr> sjanssen: Is that good for searching all the #haskell logs?
11:31:15 <Cale> But not as a regular.
11:31:42 <lypanov> Cale: recall you being helpful in the past. maybe just mixed memories. i guess it was #haskell :)
11:31:52 <Cale> Maybe #math?
11:31:58 <Cale> I hang out there an awful lot.
11:32:16 <lypanov> don't think so. i'm an on/off user of #haskell tho so i've very vague memories of it all
11:32:21 <DRMacIver> I've always been under the impression that being helpful in #math took valuable time away from mocking newbies
11:32:27 <lypanov> heh
11:32:30 <shapr> lypanov: We missed you!
11:32:35 <lypanov> hey shapr :)
11:32:38 <shapr> hiya lypanov!
11:32:43 <lypanov> shapr: blame birds stupid soduku thing
11:32:44 <Cale> DRMacIver: heh
11:32:44 <DRMacIver> Maybe this is a difference between freenode and EFNet. :)
11:32:55 <shapr> lypanov: Well, you gotta do what's worth investigating.
11:32:59 <sjanssen> shapr: yeah.  hsgrep takes 20 seconds to grep my 200mb of logs -- grep takes about a minute
11:33:01 <lypanov> shapr: i absolutely refuse to end the year not understanding every single character in it
11:33:08 <Cale> DRMacIver: Yeah, when I'm around, I generally try to keep things friendly for beginners.
11:33:17 <emu> sjanssen: because it's multithreaded?
11:33:39 <Cale> DRMacIver: I haven't been around as much lately though, I should really keep an eye on it :)
11:33:52 <sjanssen> shapr: this is after the OS has cached all the files in memory
11:34:01 <DRMacIver> Me neither
11:34:12 <emu> or because it's not using regular expressions
11:34:16 <Cale> Elitism when it comes to mathematics is pretty stupid, and yet people fall into it so easily.
11:34:17 <sjanssen> emu: yeah.  It also has a small gain because it's simpler (fixed strings only, no regexes)
11:34:39 <DRMacIver> I don't think we're elitist so much as malicious. :)
11:34:43 <Cale> heh
11:35:01 <shapr> sjanssen: Would it be faster if it all the haskell logs were stored as gzip'd lazy bytestrings?
11:35:13 <DRMacIver> (I'm not really that bad, unless someone is really annoying me)
11:35:34 <sjanssen> shapr: gzip would probably slow things down
11:35:50 <dcoutts_> sjanssen: I guess that depends on the cost of IO vs CPU
11:35:57 <dcoutts_> sjanssen: in the non-cached case
11:35:59 <sjanssen> right
11:36:00 <shapr> Cale: I think elitism in general is pretty silly.
11:36:34 <sjanssen> I'm working on testing non-cached (hard when you have 2 GB of RAM and a smart VM)
11:37:03 <lypanov> sjanssen: akpm made a cute lil tool to fix that fuckup. assuming you are using linux
11:37:07 <dcoutts_> sjanssen: recent linux kernels have a drop_caches thingie somewhere in /sys
11:37:16 <lypanov> dcoutts_: !!! whoa. nice
11:37:28 <lypanov> finally it was fixed properly :D
11:37:35 * lypanov uses osx and is out of it wrt linux these days
11:37:37 <dcoutts_> right
11:37:55 <sjanssen> dcoutts_: ah, cool.  much better than ghci -e 'last [1..]'
11:38:03 <dcoutts_> sjanssen: heh
11:38:19 <emu> > last [1..]::Int
11:38:20 <dcoutts_> sjanssen: lypanov: http://linux-mm.org/Drop_Caches
11:38:22 <lambdabot> Title: Drop Caches - linux-mm.org Wiki
11:38:27 <lambdabot> Terminated
11:38:38 <emu> > maxBound :: Int
11:38:40 <lambdabot>  2147483647
11:38:51 <lypanov> sjanssen: lol
11:38:57 <dcoutts_> sjanssen: lypanov: basically # echo $someNumber > /proc/sys/vm/drop_caches
11:39:04 <lypanov> sjanssen: i'm glad i know enough haskell to grok that
11:39:12 <dcoutts_> the number determines what gets dropped
11:39:34 <Cale_> *grumble*
11:39:36 <lypanov> wow, ghci does really clever bounding inference on that?
11:39:56 <Cale> DRMacIver: (In case my last message wasn't sent) You just have to remember that at some point, you were learning that too :)  I seem to have more patience than most people though.  There have been times where I spent a couple hours explaining the basics of rational numbers to someone which were pretty taxing, but it's a good feeling when they finally get it. :)
11:40:40 <DRMacIver> Cale: Simply not getting something isn't sufficient to annoy me though. :)
11:40:44 <lypanov> um. /me joins said channel
11:41:09 <sjanssen> dcoutts_: did you see the hsgrep prototype?
11:41:27 <dcoutts_> sjanssen: no. Where is it?
11:43:00 <sjanssen> dcoutts_: http://hpaste.org/1748
11:43:22 <Cheery> have you thought about making the ghci output colored syntax?
11:43:33 <sjanssen> dcoutts_: switching to strict ByteString was actually a loss (presumably the cost of building the KMP table)
11:43:48 <sjanssen> haven't tried Data.ByteString.Lazy yet
11:44:13 <Cheery> ie. different colors for different syntactic elements and such
11:44:27 <Cheery> my friend noticed this helps especially with debugging
11:44:42 <Cheery> ie. color coding for different elements in the error output
11:45:38 <sjanssen> dcoutts_: I decided that mmap probably isn't the best tool here -- you want the RTS to know when an IO source is blocking
11:45:54 <dcoutts_> sjanssen: I think the current KMP search is not well optimised
11:46:04 <dcoutts_> sjanssen: yes, that's probably right.
11:46:27 <dcoutts_> sjanssen: mmap doesn't allow Haskell thread concurrency
11:46:57 <dcoutts_> sjanssen: on the other hand, in practise, file reads never block anyway
11:47:01 <ski> Cale :)
11:47:50 <dcoutts_> sjanssen: the kernel never considers file read/writes as blocking even on slow usb/nfs devices
11:48:12 <sjanssen> dcoutts_: I certainly see plenty of blocking when grepping through 200mb
11:48:40 <sjanssen> dcoutts_: oh?  Then what happens while the OS is waiting on my disk?
11:49:05 <dcoutts_> sjanssen: it'll schedule other tasks or sit idle
11:49:06 <lypanov> is there an autotest like thing for haskell?
11:49:35 <Cale> lypanov: QuickCheck?
11:49:53 <Cale> There's also HUnit
11:50:03 <dcoutts_> sjanssen: check with strace, look for read returning -EAGAIN (ie the kernel telling the rts that the read would block). You'll note it never happens with files but does happen with pipes, consoles etc.
11:50:25 <sjanssen> fascinating
11:50:29 <mux> this is just due to the default setting of file descriptors
11:50:44 <dcoutts_> mux: not on linux. it's a 'feature' of the kernel.
11:50:48 <Cale> lypanov: both of which come with GHC, but are underdocumented in the hierarchical libraries documentation. I can get you better documentation links :)
11:50:52 <Baughn> Is there a way to lock files outside of System.Posix.IO? Or a way to extract the FD without closing the handle?
11:50:52 <lypanov> Cale: is there a "continuous" mode for it? that watches for file changes?
11:51:21 <mux> dcoutts_: mm, I read what you said wrong; indeed this is expected, I think this is POSIX
11:51:26 <Cale> Not that I'm aware of.
11:51:53 <mux> even though technically speaking, read() and write() on files can block, it's not considered as such
11:52:00 <Cale> You might be able to just rig something up in the shell.
11:52:08 <dcoutts_> mux: I didn't realise it's mandated by posix, that's a little unfortunate
11:52:20 <mux> I think so, but since I'm not sure
11:52:40 <dylan> there is a (linux-specific) syscall for watching files for changes.
11:52:41 <mux> it especially unfortunate when you consider network filesystems :-)
11:52:43 <Baughn> dcoutts_: read() usually blocks for me, which is why I use async I/O instead
11:52:49 <lypanov> Cale: heh. it was the first thing and only thing i wrote for scala when i got into that
11:52:52 <mux> it does block
11:53:08 <dcoutts_> Baughn: right, though sadly that's usually slower
11:53:34 <mux> and not very portable
11:53:51 <Baughn> dcoutts_: I can't let the average case stand in the way of big-o perfection
11:54:01 <dcoutts_> Baughn: heh :-)
11:54:16 <dcoutts_> the kernel folk have been talking about a nice implementation of async IO that is synchronous in the fast cached case and only forks when the syscall would block.
11:54:45 <mux> however, read() and write() on files can theoritically return EINTR
11:55:16 <dcoutts_> mux: aye, that's posix stuff that I've never understood, interruptible syscalls.
11:55:19 <Baughn> Theoretically. It /should/ have been guaranteed, and not rare.
11:55:29 <Baughn> ..well, for EAGAIN
11:55:32 <lypanov> Cale: you generally use quickcheck?
11:55:35 <mux> dcoutts_: most modern OSes automatically restart syscalls
11:55:41 <mux> and there is SA_RESTART
11:55:46 <mux> so in practice it's not much of an issue
11:55:52 <dcoutts_> mux: right, which is why I've never had to know what it is :-)
11:55:56 <Baughn> dcoutts_: It's handy to be able to say alert(3); for syscalls with no timeout
11:56:26 <Baughn> Say, about them file locks? Any way around using System.Posix?
11:56:29 <Cale> lypanov: If I was writing something very important, I would. (Like a datastructure library, say.)
11:56:32 <mux> hmm, augmenting kqueue() / kevent() to be notified when data really arrived on disk would be nice
11:56:50 <dcoutts_> sjanssen: I expect the reason it's faster is because you can take advantage of kernel readahead on multiple files
11:56:51 <mux> even though you can't be sure of this these days, with all those ATA disks lying about having flushed their data
11:57:21 <dcoutts_> sjanssen: though you said it's faster even in the cached case?
11:57:45 <Baughn> mux: If it's a good one, it'll have enough capacitance to flush regardless of power failures
11:57:56 <dcoutts_> sjanssen: and you've tried (in the cached case) comparing the forkIO vs an ordinary serial version?
11:58:02 <mux> I'm precisely talking about bad disks :-)
11:58:09 <mux> good disks wouldn't lie about this.
11:58:24 <mux> fortunately, this is possibly not going to be an issue for long with NCQ
11:58:32 <sjanssen> dcoutts_: I'm testing those as we speak
11:58:35 <dcoutts_> sjanssen: are you using multiple CPUs?
11:58:48 <sjanssen> should have numbers in three minutes or so
11:58:56 <dcoutts_> @arr!
11:58:57 <lambdabot> I want me grog!
11:58:57 <sjanssen> dcoutts_: yeah, dual core with +RTS -N2
11:59:02 <dcoutts_> right
11:59:46 <Cale> This is getting annoying, my lan connection is getting dropped about once every couple of minutes.
11:59:47 <dcoutts_> sjanssen: btw hGetLine is slow
11:59:58 <Cale> lypanov: Most of the stuff that I write with Haskell, I can generally tell if it's correct or not by reading it carefully, so that's what I usually do.
12:00:24 <dcoutts_> sjanssen: it should be much quicker to do a lazy bs readFile, lines, convert to strict and use the regex
12:00:28 <Cale> (In the way one would read a mathematical proof.)
12:00:57 <dcoutts_> sjanssen: then we don't have to copy via the Handle buffer and we don't have to lock it so often.
12:01:02 <lypanov> Cale: i'll try and think that way also then
12:01:13 * dcoutts_ notes that lazy IO is fast
12:01:16 <lypanov> are there any nice haskell talks on google video btw? i've waited ages now :)
12:01:36 <Cale> lypanov: If it's not easy to analyse a piece of code like that, it's usually work considering how to break it up better into parts which are easier to study.
12:01:42 <Cale> worth*
12:01:47 <Cale> heh :)
12:01:51 <Cale> also work, I suppose
12:01:59 <lypanov> ;)
12:02:01 <mux> I think video.haskell.org is called for :-)
12:02:12 <Cale> There's some talks about Haskell, but not nearly as many as you might like.
12:02:31 <Cale> Which is a shame, since Simon Peyton Jones is such an eloquent speaker.
12:02:34 <lypanov> i just need a pep talk really :P
12:02:54 <Cale> (We need to bring video cameras to more of his talks :)
12:03:03 <mux> I'd sell my parents for a video of SPJ at POPL'07
12:03:03 <sjanssen> dcoutts_: is Data.ByteString.Lazy.isPrefixOf fast?
12:03:46 <lypanov> Cale: i loved the stm paper
12:03:56 <Cale> Oh, yeah, that paper rocks :)
12:04:11 <mux> yeah it's nice, and 'tackling the awkward squad' is incredibly great too
12:04:16 <dcoutts_> sjanssen: pretty fast I think.
12:04:30 <Cale> http://video.google.com/videoplay?docid=-4167170843018186532
12:04:31 <lambdabot> Title: Faith, Evolution, and Programming Languages - Google Video
12:06:37 <kc5tja> Cale: Heh, Microsoft would never allow his speeches to be hosted on the video servers of its biggest competitor.
12:06:48 <lypanov> lol
12:07:15 <SamB_XP_> kc5tja: but this way they don't have to pay for it
12:07:40 <newsham> hi.  anyone here familiar with the Programatica stuff?
12:07:44 <Cale> kc5tja: I doubt they have *that* much control over it :)
12:08:06 <newsham> they seem to have several websites, and their "tools" link points to some .org (through a redirect) that does not resolve.
12:08:20 <newsham> know an email address I can inquire about this on?  (hallgren's?)
12:10:02 <SamB_XP_> damn you, internet words and your ambiguous pronunciation...
12:10:19 <newsham> "No, no!  It is a sign that, like Him, we must think not of the things of the body, but of the face and head!"
12:10:24 <newsham> oops, misfire
12:12:17 <sjanssen> dcoutts_: turns out serial hsgrep is faster (in the non-cached case).  I suppose forking 1000 threads is slightly expensive
12:12:49 <dcoutts_> sjanssen: forking 1000 haskell threads should be really cheap
12:13:13 <dcoutts_> sjanssen: but doing lots of IO out of order could be bad I suppose
12:13:20 <sjanssen> ./hsgrep +RTS -N2 -RTS sjanssen haskell-logs/* > /dev/null  33.17s user 0.99s system 68% cpu 50.061 total # parallel
12:13:31 <sjanssen> ./hsgrep +RTS -N2 -RTS sjanssen haskell-logs/* > /dev/null  24.19s user 0.74s system 64% cpu 38.420 total # serial
12:13:43 <SamB_XP_> does GHC have O(1) scheduling?
12:13:56 <dcoutts_> sjanssen: that doesn't look like it's using 2 cpus
12:14:16 <sjanssen> dcoutts_: because it's bounded by IO, presumably
12:14:22 <dcoutts_> sjanssen: try limiting the concurrency a little
12:14:36 <njbartlett> Cale: SPJ is going to be speaking at the London HUG on 23rd May about nested data parallelism. I'm going to be taping it...
12:14:53 <augustss> good idea
12:15:04 <Cale> njbartlett: awesome :)
12:15:10 <dcoutts_> sjanssen: I'd have thought the IO system might get better throughput by interleaving readahead on a small handfull of files with processing
12:15:13 <sjanssen> njbartlett++ more karma after I see the video ;)
12:15:15 <njbartlett> No way I can host the video on my own site though, so maybe it needs to go up on something like Google Video
12:16:11 <njbartlett> Can anybody just submit videos to Google Video, like YouTube? Or is it more complicated than that?
12:16:18 <DRMacIver> Are Haskell threads not implemented as OS threads then?
12:16:23 <lypanov> anyone can afaiu
12:16:26 <augustss> put it on youtube
12:16:40 <sjanssen> ./hsgrep +RTS -N2 -RTS sjanssen haskell-logs/* > /dev/null  29.61s user 0.63s system 152% cpu 19.803 total # parallel, cached
12:16:45 <njbartlett> Doesn't youtube have a limit of ten minutes?
12:16:51 <SamB_XP_> augustss: why youtube?
12:16:51 <lypanov> tho i don't know how you make them "downloadable"
12:16:56 <augustss> oh, maybe so
12:17:02 <davidL> try speedyshare.com
12:17:16 <augustss> i can probably host it for downloading
12:17:18 <njbartlett> davidL: Haven't heard of that one. Will take a look
12:17:24 <sjanssen> bittorrent, perhaps?
12:17:26 <DRMacIver> SamB_XP_: Because he doesn't like using things owned by google? ;)
12:17:27 <Cale> You could create a torrent, but probably it's not so hard to put it on Google video.
12:17:48 <SamB_XP_> ... youtube *is* owned by google. Unless they sold it?
12:18:00 <Cale> yes, it is
12:18:04 <sjanssen> DRMacIver: GHC uses a hybrid approach.  One OS thread per CPU, then the RTS schedules lightweight Haskell threads
12:18:11 <DRMacIver> ok
12:18:12 <DRMacIver> Sensible
12:18:20 <lypanov> sjanssen: hadn't realized that. very cool
12:18:35 <SamB_XP_> more OS threads if you do forkOS
12:18:38 <njbartlett> augustss: Thanks for the offer, I'll bear that option in mind as well
12:18:54 <davidL> what is it a video of?
12:19:21 <sjanssen> lypanov: yes, I think it's the nicest system
12:19:36 <sjanssen> I feel sorry for the Ruby guys wrt. threading
12:19:48 <SamB_XP_> what does Ruby do?
12:20:00 <sjanssen> pure userspace now
12:20:01 <DRMacIver> Suck, apparently. ;)
12:20:04 <DRMacIver> *cough*
12:20:10 <DRMacIver> (From a performance perspective that is)
12:20:26 <sjanssen> but the next version of Ruby will have an OS thread for each Ruby thread -- except there's a global interpreter lock!
12:20:41 <SamB_XP_> you mean it can only use one core?
12:20:45 <sjanssen> so you'll get all the overhead of OS threading, with zero concurrency
12:20:50 <sjanssen> SamB_XP_: right
12:20:54 <merus> Wow! That's exciting.
12:21:03 <njbartlett> Samb_XP_: Well it can use multiple cores... but only one at a time ;-)
12:21:10 <merus> njbartlett, lol
12:21:15 <SamB_XP_> well, yeah. that doesn't quite count.
12:21:17 <Saizan> sjanssen: like CPython?
12:21:38 <SamB_XP_> Saizan: CPython can use more than one core at a time... just not to execute *Python*
12:21:42 <sjanssen> Saizan: I don't know, is that how CPython works?
12:21:53 <sjanssen> SamB_XP_: ah, that's the case with Ruby
12:22:00 <Saizan> CPython has a global lock for the GC
12:22:02 <sjanssen> foreign calls can execute concurrently
12:22:19 <mux> Cale: thanks for that link it's very interesting :-)
12:22:23 <Saizan> so yeah, only foreign runs concurrently
12:22:28 <njbartlett> JRuby will be able to do real multicore stuff, because it takes advantage of the JVM. The problem is, it doesn't have any decent abstractions to deal with concurrency, so it'll be no better than Java is
12:22:37 <mux> I like how Philip Wadler explains why today when we chose a programming language "faith" wins
12:22:59 <njbartlett> In fact it will be worse, because at least the Java programming language has the synchronized keyword and so on
12:22:59 <SamB_XP_> Saizan: for the GC, is it?
12:23:52 <Saizan> SamB_XP_: afaik, yes, because it is mark and sweep and not thread safe
12:24:40 <sjanssen> GHC's garbage collector is single threaded, but we can still have concurrency when it isn't running
12:25:15 <SamB_XP_> ... isn't there a more efficient way to halt all other threads for GC than to halt all other Python threads?
12:25:43 <SamB_XP_> ... by which I mean threads that are currently executing python bytecode...
12:26:02 <SamB_XP_> (also, how does that stop C code from messing up the heap?)
12:26:20 <Saizan> i was wrong, it's reference counting, and that's apparently the reason for the lock
12:26:39 <sjanssen> SamB_XP_: C probably has to grab a lock when it needs to access Python structures
12:27:00 <SamB_XP_> I don't remember anything like that.
12:27:23 <Saizan> isn't there a passage of responsability?
12:27:31 * DRMacIver mutters
12:27:45 <DRMacIver> Why on earth do people still use reference counting garbage collectors?
12:27:57 <sjanssen> anyway, we should all be thankful that the GHC team has given us a well thought out concurrency system
12:28:24 <njbartlett> DRMacIver: Because they're easy to write?
12:28:27 <DRMacIver> I guess
12:28:39 <lypanov> DRMacIver: ever tried to interface c with non ref counting gc?
12:29:04 <SamB_XP> I think there is some hacky code about that assumes refcounting.
12:29:09 <DRMacIver> lypanov: I've tried to use a non ref counting gc in C. :)
12:29:19 <lypanov> DRMacIver: hehe. poor you
12:29:26 <SamB_XP> also, all the C extensions would need recoding
12:29:29 <lypanov> DRMacIver: i just did a few perl and a few ruby extensions
12:29:41 <lypanov> and i /hated/ the maintenance period wrt the ruby extensions
12:29:50 <lypanov> getting it Just Perfect as a bitch
12:29:56 <lypanov> s/as/was/
12:29:59 <DRMacIver> I din't get very far to be honest, for reasons not directly related to the garbage collection
12:30:19 <SamB_XP> Python does have some kind of "cycle collector" thing
12:30:33 <SamB_XP> to pick up after the refcounting
12:31:17 <lypanov> DRMacIver: have you seen ulterior ref counting paper?
12:31:23 <DRMacIver> Nope
12:31:23 <mux> hah, P. Wadler has a nice lambda tie
12:31:35 <DRMacIver> My following of the literature is basically non existent
12:31:56 <lypanov> DRMacIver: http://grothoff.org/christian/teaching/2007/4705/urc-oopsla-2003.pdf
12:31:59 <lambdabot> http://tinyurl.com/yocwnx
12:33:16 <DRMacIver> Ha ha. "Using this you can prove false, which... makes your logic very powerful."
12:33:32 <mux> if anyone has other p. wadler talk videos I'd be pleased :)
12:33:40 <DRMacIver> lypanov: I'll read it when I'm done with wadler's video. :)
12:33:42 <mux> DRMacIver: we're at exactly the same point heh
12:43:13 <mux> haha, "Define `universe', give three examples."
12:48:52 <igli> heh i like that
12:53:19 <mnislaih> dcoutts:  will the gtk2hs Windows installer work for ghc 6.6.1 ?
12:53:42 <dcoutts_> mnislaih: not yet, I'll need to do a rebuild
12:53:54 <mnislaih> I'll be glad to beta test it, let me know when you have it
12:54:06 <dcoutts_> mnislaih: will do
12:55:16 <nominolo> I was hoping for a few comments on http://nominolo.blogspot.com/2007/05/towards-better-error-handling.html.  Does anyone have an opinion on whether this style of error handling is worthwhile for a compatibility braking change to the HTTP lib?
12:55:19 <lambdabot> Title: nominolo's Blog: Towards Better Error Handling, http://tinyurl.com/2327nn
12:56:00 <nominolo> s/braking/breaking/
12:56:19 <Baughn> nominolo: Perhaps, but there should be something better
12:56:31 <nominolo> This and ByteString support
12:56:40 <Baughn> nominolo: It's a bit beyond me as yet, but maybe it could be possible to import the ideas from CL conditions?
12:56:45 <nominolo> Baughn: what do you have in mind?  Like in SimonM's paper?
12:57:24 <nominolo> Baughn: oh, well.  This would probably involve the Cont monad or similar trickery
12:57:40 <nominolo> I'd rather not put this as a requirement for the user-side monad
12:57:51 <Baughn> nominolo: I like the idea of attaching possible actions to the exception. Some standardization would help.
12:58:55 <Baughn> ..but I really don't understand Haskell well enough to say if that's a good idea or not
12:58:56 <nominolo> Baughn: when should these actions be executed?
12:59:09 <ocram> hello. I'm an Haskell newbye and I'm trying to understand the meaning of this datatype delcaration: data Seq g1 g2 u = Seq (g1 u) (g2 u); It seems that the Haskell manual I'm reading doesn't show an example like this.. can someone give me an hint?
12:59:35 <Baughn> nominolo: When the exception is thrown?
12:59:57 <nominolo> Baughn: can you give an example?
12:59:58 <ocram> for what I've undestood about Haskell, g1 and g2 should be type placeholders.. or not?
13:00:13 <nominolo> ocram: yes, and they expect a parameter
13:00:22 <Baughn> nominolo: Let's say you have a ByteString -> String parser
13:00:28 <nominolo> ocram: just like a monad is parameterized over the result type
13:00:32 <dcoutts_> nominolo: actually I think your current code can do what Baughn wants
13:00:46 <Heffalump> ocram: right, so Seq takes two type constructors and a type
13:00:58 <Heffalump> and applies the type constructors to the type to produce the types that will be parameters to Seq
13:01:32 <dcoutts_> nominolo: I think Baughn just needs to use a continuation monad on top of IO and have the error action call something to resume / retry.
13:01:47 <Heffalump> for example type type Seq IO [] Int would produce a data constructor Seq of type IO Int -> [Int] -> Seq IO [] Int
13:01:53 <Baughn> nominolo: ...it turned into a very long line. I'll try to write this down
13:01:55 <ocram> Heffalump: it seems pretty complicated :D . tnx
13:01:56 <nominolo> dcoutts_: hm, yes, that sounds workable
13:02:14 <Heffalump> ocram: yes, it does seem like a fairly complicated type. If you can give some context it might make more sense what it's useful for.
13:02:27 <nominolo> Baughn: okay
13:03:52 <Sgeo> Dumb joke time:
13:04:14 <Sgeo> What did Goldilocks say upon seeing "Maybe (b -> Either a b)"
13:04:31 <ocram> Heffalump: I'm studying this: http://www.cs.uu.nl/research/techreps/repo/CS-2006/2006-025.pdf
13:04:37 <merus> Sgeo, what?
13:04:44 <Sgeo> It's Just Right!
13:04:48 <merus> hahaha
13:05:05 <ocram> Heffalump: but without a real practice of Haskell it's really difficoult to understand :P
13:05:24 <ocram> *difficult
13:05:32 <nominolo> ocram: indeed
13:06:01 <DRMacIver> Sgeo: Argh
13:06:07 <Sgeo> DRMacIver, hm?
13:06:29 <DRMacIver> The joke.
13:06:41 <Sgeo> Why "argh" though?
13:07:09 <nominolo> ?where ByteString
13:07:09 <DRMacIver> "Argh" is the appropriate appreciative response to an awful pun.
13:07:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:07:17 <therp> @where hsplugins
13:07:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:07:52 <nominolo> @instances Binary
13:07:57 <lambdabot> Couldn't find class `Binary'. Try @instances-importing
13:08:06 <Sgeo> @help
13:08:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:08:11 <nominolo> @instances-importing Binary
13:08:13 <Sgeo> @help list
13:08:13 <lambdabot> Couldn't find class `Binary'. Try @instances-importing
13:08:14 <lambdabot> list [module|command]
13:08:14 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:08:19 <Sgeo> @list
13:08:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:08:49 <Sgeo> @djinn Maybe (b -> Either a b)
13:08:50 <lambdabot> f = Nothing
13:08:59 <Heffalump> ocram: ok, I think what they're doing is leaving the actual contained type as a parameter
13:09:10 <Heffalump> so they're defining XML composition with Seq and Or
13:09:27 <Heffalump> so you might build up a big XML type with Seq (Seq .. ..) (Or (Seq .. ..) ..)
13:09:38 <Heffalump> and then finally you pick some type to put inside it
13:10:02 <Heffalump> (I think)
13:10:52 <drigz> wow, i didn't know haskell's community was this forgiving
13:11:12 <drigz> someone asked what the $ operator did on the mailing list
13:11:49 <drigz> anywhere else, i hate to think what would have happened
13:11:50 <Heffalump> isn't that what the list is for?
13:12:08 <Heffalump> anywhere else, they'd have been told off for asking about Haskell on a non-Haskell list :-)
13:12:13 <DRMacIver> $ confused the hell out of me when I first saw it.
13:12:20 <drigz> it always seemed to me like the list is something you go to last, after googling and asking in irc
13:12:34 <drigz> because you're sending an email to probably hundreds of people
13:12:38 <nominolo> hm, do ByteStrings work with sockets?
13:12:44 <Heffalump> how do you google for ($) ?
13:12:50 <Heffalump> and you might not use IRC
13:12:53 <ehird`> Heffalump: you dont
13:12:56 <Baughn> nominolo: I keep getting stuck at needing to catch exceptions in pure code. This may take some work.
13:13:03 <Heffalump> and there's 300 people on this channel, so you're bugging that many potentially :-)
13:13:04 <drigz> Heffalump: when i wanted to find out i googled 'haskell operators'
13:13:17 <SamB> Baughn: where do they come from, these exceptions?
13:13:25 <nominolo> Baughn: I don't think you can do that.  it's not refer. transp.
13:13:32 <Heffalump> no, you definitely can't do that
13:13:39 <Heffalump> you can use mapException to convert them into other ones, if that helps
13:13:39 <Baughn> SamB: throws in the function that's being evaluated in order to evaluate the catch
13:14:22 <nominolo> Baughn: try implementing this in terms of callCC in the Cont monad
13:14:56 * monochrom <3 Cont
13:15:55 <nominolo> I liked Wadler's note, that the type of call/cc is isomorphic two the law of the excluded middle
13:16:13 <nominolo> s/two/to/
13:16:25 * DRMacIver needs to figure out continuations properly.
13:16:35 <Heffalump> <aol>
13:16:37 <Baughn> I'm quite aware it won't work, which is why I'm pondering exception-as-values
13:16:39 <DRMacIver> I more or less understand what they do, I just don't know how to use them.
13:17:08 <nominolo> DRMacIver: just think of it as "the rest of the continuation"
13:17:11 <nominolo> er
13:17:11 <Heffalump> Baughn: or use an Exception monad
13:17:17 <nominolo> "rest of the computation"
13:17:36 <DRMacIver> nominolo: I think you misunderstand. I've heard the general vague explanations. :)
13:17:44 * DRMacIver has even heard some of the specific explanations.
13:17:52 <Heffalump> shift, reset and the like confuse me too.
13:17:55 <DRMacIver> I've just never used them, so I don't have a good feel for how they work.
13:18:08 <Heffalump> I once found a reason to refactor a bunch of code in CPS
13:18:09 <nominolo> DRMacIver: hm, the nicest example i've seen was Termite's migrate process
13:18:34 <Heffalump> It was previously code that did stuff recursively. But I wanted it to be able to break into a GUI somewhere deep in the recursive chain.
13:18:39 <nominolo> DRMacIver: basically:  (call/cc (c) (spawn-some-where-else (lambda () (c))))
13:18:43 * Baughn would short-circuit, but is evaluating that out of order. Hmm, laziness is sometimes troublesome
13:18:52 <Heffalump> So I refactored it into CPS, so I had a continuation I could pass to the GUI stuff that it could call when it finished.
13:19:10 * Sgeo wonders if his pun will be added to the Haskell Humor page?
13:19:32 <Heffalump> what was your pun?
13:19:41 <Sgeo> What did Goldilocks say upon seeing "Maybe (b -> Either a b)"?
13:19:48 <nominolo> Just Right!
13:19:49 <Sgeo> It's Just Right!
13:20:00 <nominolo> (almost)
13:20:03 <Heffalump> that's not even type correct!
13:20:06 <DRMacIver> nominolo: I don't mean to be rude, but it's pretty much guaranteed that nothing you say to me at this point will help me understand them. I've read the explanations, and it's not that continuations confuse me. But I need to get my hands dirty with them before I get any further. :)
13:20:10 <Heffalump> you can't have type incorrect puns.
13:20:11 <Sgeo> Heffalump, hm?
13:20:17 <mauke> :t Just Right
13:20:17 <dolio> Just . Right?
13:20:17 <Heffalump> @type Just Right
13:20:19 <Sgeo> :t Just Right
13:20:21 <lambdabot> forall b a. Maybe (b -> Either a b)
13:20:23 <lambdabot> forall b a. Maybe (b -> Either a b)
13:20:23 <lambdabot> forall b a. Maybe (b -> Either a b)
13:20:23 <Sgeo> @t Just Right
13:20:24 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
13:20:26 <mauke> AIIRRR
13:20:27 <Heffalump> oh.
13:20:30 <Heffalump> sorry, I'm confused.
13:20:33 <Heffalump> you're right.
13:20:36 <nominolo> DRMacIver: yes, I understand. :)
13:20:38 <dolio> Heh.
13:21:28 <monochrom> @remember Sgeo What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
13:21:29 <lambdabot> Done.
13:22:00 <ehird`> monochrom: groooooooan
13:22:06 <monochrom> There is some chance it will appear in the Haskell Weekly News.
13:22:28 <DRMacIver> "That's not supported, and even trying to think of doing such a thing makes my brain hurt."
13:22:29 <Heffalump> oh, does dons use the @remembers to pick quotes for that?
13:22:30 <nominolo> who is goldilocks?
13:22:30 <yetAnotherOne> i want to compile greencard 3.01, but it needs data.finitemap. is there a newer version of greencard, or is there a patch? i don't have data.finitemap
13:22:58 <Heffalump> Data.FiniteMap was replaced by Data.Map
13:22:59 <nominolo> (a joke protagonist?)
13:23:02 <monochrom> Yes, dons picks some from the @remember's
13:23:14 <Heffalump> I don't know of any updates, but it probably isn't too hard to change the uses.
13:23:21 <nominolo> @quote right
13:23:22 <lambdabot> chessguy says: [<newsham> (if complicatedly is indeed a word)] <chessguy> newsham, if it's not a word, just define it and add it to the language. that's what FP is is all about, right?
13:23:30 <Sgeo> nominolo, have you heard of "Goldilocks and the Three Bears"?
13:23:47 <Sgeo> http://en.wikipedia.org/wiki/Goldilocks
13:23:49 <lambdabot> Title: The Three Bears - Wikipedia, the free encyclopedia
13:23:55 <nominolo> Sgeo: thanks
13:23:58 <Sgeo> yw
13:24:10 <yetAnotherOne> maybe for a good programmer, but i am just a small noob and doesn't know much about thia
13:24:11 <mux> heh, I like the justficiation of P. Wadler for having written Links in OCamel
13:24:13 <yetAnotherOne> *this
13:24:14 <monochrom> I have only heard of "the Wolf and the Three Pigs" and "King Lear and His Three Daughters".
13:24:34 <dylan> :t Just Right
13:24:37 <lambdabot> forall b a. Maybe (b -> Either a b)
13:25:22 <nominolo> Sgeo: the story sounds like a remake of "Snow White" :)
13:25:28 <DRMacIver> Hm. Moe-nad? I've always pronounced it Moh-nad.
13:25:30 <Baughn> nominolo: http://rafb.net/p/BvAkYz74.html is about as good as it gets from me
13:25:32 <lambdabot> Title: Nopaste - No description
13:25:33 <mux> he said he just wanted to learn ocaml and that he is now happy to write all his future work in haskell :-)
13:26:14 <Sgeo> How does the @remember thing work?
13:26:21 <mauke> @magic
13:26:22 <lambdabot> Unknown command, try @list
13:26:55 <Heffalump> mux: lol
13:27:04 <Sgeo> @quote Sgeo
13:27:05 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
13:27:25 <nominolo> Baughn: I'll try to write a proof of concept using the Cont monad.  This cannot be done in pure code.
13:27:45 <Baughn> nominolo: Well, it can if you ignore everything from "What I get stuck on...".
13:28:18 <Baughn> nominolo: At that point it's sufficiently easy that I'd be surprised if it hasn't been reinvented a hundred times already
13:28:38 <nominolo> Baughn: I'd just pass along a continuation expecting an argument to fix the condition/error.
13:29:13 <mux> ROFL
13:29:32 <nominolo> I.e., when we encounter a fixable error we throw an exception and attach it with the continuation.
13:29:35 <mux> P. Wadler has a Superman-like t-shirt with a red lambda on yellow triangle
13:29:36 <Baughn> nominolo: Which is what thunks effectively are in pure code, I think..
13:29:39 <mux> awesome
13:29:44 <Baughn> nominolo: Any ideas on withRestart?
13:30:24 <nominolo> Baughn: catchError m (\e -> case e of Restart1 ... -> ...; Restart2 ... )
13:30:37 <mux> he says something along the lines of "when you bump into a hard problem, you should think: this a job for lambda calculus" opening his jacket to show the t-shirt
13:30:40 <mux> heheheh
13:30:58 <nominolo> Baughn: oh, wait. Let me refresh my conditions knowledge a bit
13:31:04 <Baughn> Indeed. ;)
13:31:20 <Heffalump> nominolo: have you encountered this being done in practice before, OOI?
13:31:37 <Heffalump> I had the same idea for something a while back and was a bit surprised not to be able to find any examples of it.
13:31:46 <Heffalump> (throwing a continuation with an exception, that is)
13:33:05 <nominolo> Heffalump: what are you referring to, my blogpost or conditions?
13:33:12 <nominolo> ah
13:33:13 <nominolo> heh
13:33:27 <nominolo> didn't read to the end
13:34:25 <Baughn> nominolo: withRestart probably depends on dynamic variables. Are those possible/do they make sense?
13:36:06 <Baughn> Mind you, dynamic bindings works. They don't need to be variable.
13:36:24 <nominolo> Baughn: I'm trying to implement a proof of concept
13:36:32 <nominolo> Baughn: may take a while ;)
13:36:35 <nominolo> :t callCC
13:36:44 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:38:07 <DRMacIver> callCC is apparently one of those htings where the type signature really doesn't help you understand it. :)
13:38:19 <kc5tja> DRMacIver: I SAW THAT!
13:38:31 <DRMacIver> kc5tja: Hm?
13:38:55 <kc5tja> DRMacIver: You missed the big argument earlier today?  (Precisely about type signatures and their assistance in understanding a function)
13:39:14 <DRMacIver> Oh, heh.
13:39:15 <dolio> (a -> m b) is the escape continuation.
13:39:57 <nominolo> DRMacIver: ie, if you call the continuation you may return with a completely different result
13:39:58 <Baughn> DRMacIver: The signature works just fine if you already know what it does
13:40:04 <Baughn> Which is usually the case anyway
13:40:25 <DRMacIver> Baughn: Like I said. The signature doesn't really help you understand it. :)
13:40:29 <monochrom> Generally, (Monad m) => ... m ...  cannot tell you much, since that m hides a whole lot of things.
13:40:34 * DRMacIver didn't say it didn't make sense.
13:41:11 <nominolo> I guess I'll soon stumbe upon some problems with the ContT monad transformer ...
13:41:30 <monochrom> Compare: "a -> b" tells you almost everything, "a -> IO b" tells you almost nothing.
13:42:45 <dcoutts_> monochrom: which is why people don't like Cabal code ;-)
13:44:00 <monochrom> Cabal code is full of that?  Like guessMe :: a -> IO b; guessMe _ = system "rm -rf *"?  :)
13:44:26 <Baughn> Even worse, guessMe :: IO ()
13:44:59 <monochrom> Imperative programming requires a lot of intelligence. It is very hard.
13:45:40 <DRMacIver> Baughn: Or, equally badly, main :: IO () ? :)
13:46:01 <Baughn> Yesterday I theorized that Haskell programmers will generally prefer Go to Chess. True?
13:46:13 * nominolo does
13:46:14 <DRMacIver> I don't like either.
13:46:18 <monochrom> I prefer Chinese Chess, which is netiehr.
13:46:25 * nominolo is bad at both, though ;)
13:46:40 <DRMacIver> Well, that's not true. I like both, but neither strongly.
13:46:50 <Baughn> Me go. I just can't stand the way things /move around/ in chess.
13:46:50 <dylan> I prefer tabletop RPGs.
13:46:51 <monochrom> That is an unlikely permutation of "neither"!
13:47:02 <Heffalump> I don't know Go and I do know Chess.
13:47:07 * DRMacIver prefers risk. :)
13:47:32 <Baughn> You play go recursively; you play chess iteratively. Any questions? :P
13:47:50 <monochrom> I guess someone is harping on the analogy that Go is write-once read-many like lazy evaluation, Chess is more mutable.
13:48:29 <Baughn> monochrom: It's not just that. If you see the way experts play, it looks a *lot* like a typical divide-and-conquer algorithm done breadth-first
13:48:59 <Baughn> Moreover, that's the way it feels when I'm playing
13:49:08 <nominolo> :t random
13:49:14 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:50:15 <monochrom> The essence of Risk is betrayal. DRMacIver likes to pull pranks on his programming colleagues! :)
13:50:45 <DRMacIver> monochrom: Err. Have you *seen* my code? :)
13:50:50 * DRMacIver peers at Heffalump 
13:51:02 <DRMacIver> By which I mean of course "My code is always clear and reliable."
13:51:09 * DRMacIver nods sagely
13:51:41 <Baughn> Sufficiently bad haskell code might win IOCCC?
13:52:09 <DRMacIver> monochrom: But actually I like Risk because it lets me conquer the world in effigy
13:52:18 <Heffalump> lalalala, I can't hear anything
13:52:47 <kc5tja> Baughn: I neither enjoy playing chess nor Go.  Although I've played both.
13:52:56 <DRMacIver> Heffalump: Gooood. :)
13:53:01 <kc5tja> I'm with dylan -- it's ALL about pencil/paper RPGs!!
13:54:22 * DRMacIver hasn't found a group in London yet.
13:54:26 <monochrom> OOP = subclass, subvert, subdue.
13:54:51 <DRMacIver> @remember  < monochrom> OOP = subclass, subvert, subdue.
13:54:52 <lambdabot> Done.
13:54:52 <dylan> I do find chess fun. Never really been interested in go.
13:55:25 <kilimanjaro> Same
13:55:59 <kilimanjaro> This is sort of like the hackers and painters thing though. Baughn likes Haskell, and he likes Go...
13:56:18 <merus> C = Trap, dominate, fuck?
13:56:19 <Baughn> And I can't find a single go player
13:56:21 <kc5tja> I don't find Chess to be fun.  Go is more interesting to me, but I still get bored with it after about 9 pieces or so.
13:56:28 <Baughn> Seriously. In a large city of 50,000 people, there's not one.
13:56:52 <kc5tja> C = #define, point, em{}
13:57:13 <DRMacIver> Hm.
13:57:18 <mauke> @quote <
13:57:19 <lambdabot> < says: monochrom> OOP = subclass, subvert, subdue.
13:57:21 <nominolo> hm, how can a break this recursion?: newtype RM a = RM (ContT (RM a) (ErrorT (Restart RM a) IO) a)
13:57:26 <mauke> DRMacIver: fail
13:57:30 <DRMacIver> Oops
13:57:41 * DRMacIver does indeed fail at lambdabot
13:58:00 <Baughn> kc5tja: The interesting parts of go require you to study a bit to get to - sadly, there's a learning curve. With spikes. Lots of wicked, sharp spikes at various points.
13:58:01 <Sgeo> @quote Sgeo
13:58:01 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
13:58:21 <DRMacIver> @remember monochrom OOP = subclass, subvert, subdue.
13:58:22 <lambdabot> Done.
13:58:43 <kc5tja> Baughn: I fail at physical sport.  I fail at intellectual sport.  I pretty much fail at everything.
13:58:55 <kc5tja> It's amazing I've lived this long in this world.
13:58:58 <Baughn> kc5tja: At least you've made it to #haskell. That's something.
13:59:05 <DRMacIver> Baughn: So what you're saying is that Go is the Haskell of board games? ;)
13:59:11 <Baughn> DRMacIver: Yes! :D
13:59:14 * Heffalump is pretty poor at chess
13:59:27 <Heffalump> I can beat incompetent people and that's about it.
13:59:28 * lypanov gets to wondering if there is a haskell club of sorts in .nl
13:59:32 <kilimanjaro> Go is the Scheme of board games
13:59:34 <lypanov> Heffalump: lol. ditto
13:59:46 <merus> Beating incompetent people++
13:59:49 <Heffalump> There are a surprising number of incompetent people interested in playing chess.
13:59:55 <Baughn> kilimanjaro: Only into you start thinking about subboard classes
13:59:59 <Baughn> *unil
14:00:01 <Baughn> *until
14:00:02 <DRMacIver> Hm. I'm starting to get the disturbing sensation that I understand Haskell. I wonder how that happened.
14:00:06 <DRMacIver> It's probably a false alarm.
14:00:08 <Heffalump> personally I feel that my standard or a bit lower is about the minimum that I would find acceptable in terms of actually wanting to play it
14:00:15 <kilimanjaro> Baughn, I don't think about those
14:00:18 <kc5tja> Since all you have are S and K combinators in Unlambda, and Go only has white and black pieces, I'd hazard a guess to say that Go is _really_ the unlambda of board games.
14:01:06 <Baughn> DRMacIver: Keeping with the go analogy, there's a sharp learning curve at first, a learning wall before "long-time haskell user", a learning wall between "expert haskell user" and "beginning professional", and then learning walls at regular points thereafter.
14:01:09 <int-e> unlambda has many primitives
14:01:43 <DRMacIver> unlambda *is* primitive. :)
14:01:46 <Baughn> DRMacIver: You're just coasting before hitting a learning wall
14:01:48 * Heffalump hasn't really encountered any learning walls since figuring out monads, that I can think of
14:01:58 <kilimanjaro> Go is a competitive zero sum game played by nerds. Haskell!
14:02:30 <DRMacIver> Yeah, I think my "I understand Haskell" feeling probably comes from a major piece of how monads work clicking into place.
14:02:37 <Baughn> Positive-sum, actually, since you can capture pieces
14:02:48 <Baughn> Newbies usually end with far higher scores than experts. :P
14:02:58 <kilimanjaro> Baughn, ohh, I thought it was just win/lose
14:03:18 <kilimanjaro> I know nothing about Go
14:03:19 <Heffalump> mostly since then I've found I can learn anything I want to by just playing with writing code with it for a while
14:03:37 <kilimanjaro> Heffalump, could you learn French that way?
14:03:40 <Heffalump> although that does lead to a practical rather than a theoretical grasp
14:03:43 <Baughn> kilimanjaro: It's all in the scoring. There is no winning move in go - the game ends when both players agree it does, and the scoring gives varying amounts of points.
14:03:49 <Heffalump> kilimanjaro: I guess I could improve my French by living in France for a while..
14:04:03 <Heffalump> at the moment it's so bad that French people invariably switch to English when I try to talk to them in French
14:04:57 <lypanov> Heffalump: sound german
14:05:03 <lypanov> Heffalump: simple trick really
14:05:20 <Heffalump> how will that help? :-)
14:05:31 <lypanov> if they don't know it, they will continue in french
14:05:42 <lypanov> at least in .nl the dutch do this
14:05:44 * kc5tja sometimes finds himself, in the process of refactoring code for greater maintenance, reinventing Lisp.
14:05:50 <lypanov> they assume i'm not english for some rendom reason
14:05:52 <kc5tja> Like now, for instance.  >:/
14:05:53 <lypanov> random*
14:06:05 <kilimanjaro> kc5tja, I try to refactor code for less maintenance, but that's just me
14:06:05 <Heffalump> ah :-)
14:06:15 <ehird`> kc5tja: greenspun's tenth law
14:07:00 <Baughn> Someday I'm going to implement CL in Haskell. And there will be crc errors in gravity.
14:07:56 <kc5tja> ehird`: Yup.
14:08:08 <kc5tja> kilimanjaro: Job security here actually requires the opposite.
14:08:16 <kilimanjaro> ahh
14:08:24 <kc5tja> See, we have a coding ecosystem here.
14:08:29 <kc5tja> The engineers produce crap code.
14:08:30 <lypanov> um.
14:08:35 <kc5tja> We refactor it as necessary into clean code.
14:08:42 <kc5tja> Then the engineers take our clean code and make it crappy again.
14:08:48 <kc5tja> See -- it's sustainable.  :)
14:08:48 <kilimanjaro> Symbiosis
14:08:50 <Baughn> And as in any ecosystem, the bugs are the most numerous species?
14:08:51 <kilimanjaro> beautiful :)
14:08:52 <lypanov> lol
14:09:03 <kc5tja> Baughn: Precisely.
14:09:04 <kilimanjaro> Baughn, algae
14:09:37 <flq> Codecology
14:09:42 <dmwit> Really? In a monad-infested language, you can still reinvent Lisp?
14:10:32 * lypanov admits he wondered this
14:10:46 <Baughn> Not a problem. Just keep everything in IO.
14:10:52 <Philippa> data SExp = Atom Identifier | Cons SExp SExp...
14:10:53 <Baughn> Lisp is a strict language anyway
14:11:29 <joelr1> is there a way to override a duplicate instance declarations error?
14:11:46 <mauke> joelr1: make a new type
14:12:00 <joelr1> mauke: can't :) i'm re-declaring show
14:12:03 <ehird`> reinvent haskell in lisp in "haskell in lisp" in haskell "in lisp"
14:12:07 <sjanssen> joelr1: don't do that
14:12:11 <sjanssen> :)
14:12:16 <kc5tja> dmwit: I did it in CUT as a means of making string processing substantially faster, yes.
14:12:21 <mauke> -fignore-errors
14:12:22 <Baughn> joelr1: Call it MyShow instead
14:12:27 <kc5tja> However, I'm coding in Python.
14:12:32 <monochrom> Please do not use -fallow-overlapping-instances etc
14:12:53 <joelr1> sjanssen: well, i have an AST and everything in the AST is deriving show, right? so then i want to override the show for the top-level AST data structure so that i can pretty print it. i don't want to use pretty-printing everywhere, though,
14:12:57 <joelr1> maybe i should..
14:12:58 <Baughn> monochrom: How does that work? Does it pick an instance at random?
14:13:18 <sjanssen> Show should be used for exactly two things: developer facing debugging, and printing at the interpreter
14:13:20 <monochrom> It is random for me. This means I don't know.
14:13:20 <Baughn> joelr1: Make the top-level AST /not/ derive Show?
14:13:22 <SamB> joelr1: you should make a Pretty class
14:13:24 <sjanssen> joelr1: write a PrettyPrint class
14:13:40 <joelr1> sjanssen, SamB: i do :)
14:13:49 <Baughn> Hmm, yes. PrettyPrint. Not Show.
14:13:54 <SamB> oh, well, what Baughn said then.
14:13:59 <sjanssen> or even a prettyPrint function, if you don't need overloading
14:14:03 <joelr1> i guess i should just remove the auto-derivation everywhere
14:14:18 <joelr1> cause my pretty-printing should work correctly after all
14:14:23 <sjanssen> no, you should stop using Show for things it isn't supposed to do
14:14:35 <SamB> joelr1: why would you want to use Show for anything but maybe the toplevel one?
14:14:36 <Baughn> joelr1: Anything you Show you should be able to Read. Can you Read the pretty-printing?
14:14:38 <joelr1> sjanssen: it's just that QC prints the differences using Show
14:14:48 <joelr1> Baughn: no
14:14:52 <sjanssen> joelr1: ahh, now we get to the crux of the matter
14:14:56 <Baughn> joelr1: Then I'd suggest using Pretty
14:15:02 <sjanssen> I can certainly see how that'd be annoying when QCing
14:15:15 <joelr1> sjanssen: if i make qc use pretty then i'd have to write pretty-printers for everything
14:15:16 <SamB> well, you could always stuff it in a newtype...
14:15:17 <DRMacIver> Heffalump: I've bizarrely found that a great way to learn something is to think about it until you get stuck and then give up. :) Enlightenment then dawns at some later date.
14:15:42 <DRMacIver> It's how I learned Algebraic Topology and Linear Algebra
14:15:50 <SamB> DRMacIver: ... too bad you probably forgot where you had the problem!
14:16:04 <DRMacIver> (The enlightenment for the former very fortuitously dawning *in the middle of the exam*)
14:16:08 <lypanov> SamB: gtd
14:16:12 <lypanov> DRMacIver: thats how i solve most things
14:16:17 <lypanov> wait for my brain to "get back to me"
14:16:35 <lypanov> meditative states work wonders
14:16:43 <DRMacIver> SamB: Well this only works for general high level learning. For immediate problems I actually need to solve I take a more direct approach. :)
14:16:48 <sjanssen> joelr1: maybe try adding -fallow-overlapping-instances and cross your fingers?
14:16:52 <dmwit> shower moments for great justice
14:16:59 <lypanov> dmwit++
14:17:08 <DRMacIver> Yeah. The shower is the best educational tool ever invented.
14:17:13 <SamB> sjanssen: "overlapping" does not mean "identical"
14:17:16 <SamB> it won't work
14:17:17 <joelr1> sjanssen: nah, i'll just stop deriving show for things i can pretty-print
14:17:25 <joelr1> sjanssen: auto-deriving show that is
14:17:32 <sjanssen> SamB: ah, didn't know that
14:18:22 <lypanov> whats that uber cool haskell data structure gui thingymagic?
14:18:23 <lypanov> java iirc
14:18:39 <joelr1> thank you guys
14:18:49 <sjanssen> lypanov: vital, perhaps?
14:18:57 <lypanov> yup. thx
14:23:02 <kaol> nice, hlist made it into Debian unstable
14:28:46 <BRS_Runaro> Wow, this vital thing is kinda cool.
14:30:07 <olsner> vital thing?
14:30:20 <joelr1> has anyone used PPrint?
14:30:27 <joelr1> @google PPrint
14:30:30 <lambdabot> http://docs.python.org/lib/module-pprint.html
14:30:30 <lambdabot> Title: 5.18 pprint -- Data pretty printer
14:30:36 <joelr1> hmm, no, not that one
14:31:10 <joelr1> i'm trying to figure out how to print stuff within braces so that the last brace returns back to the level of the 1st one
14:31:17 <lypanov> BRS_Runaro: yeah
14:31:32 <lypanov> olsner: http://www.cs.kent.ac.uk/projects/vital/
14:31:34 <lambdabot> Title: Vital homepage
14:32:48 <joelr1> or, to ask differently, does anyone have a C or C++ pretty-printer?
14:33:19 <mauke> indent(1)
14:33:20 <DRMacIver> I think that, no matter what you do to it, C or C++ is never going to be pretty. ;)
14:33:24 <DRMacIver> </troll>
14:33:32 <nominolo> there's a new Language.C
14:33:39 <nominolo> I think it's got a pretty printer
14:33:47 <joelr1> mauke: i tried indent but the last brace does not return back
14:34:05 <nominolo> I think it was announced on haskell-cafe a few weeks a ago
14:34:19 <mauke> joelr1: did you use -kr (or whatever the name is)?
14:34:26 <joelr1> mauke: huh?
14:34:34 <joelr1> nominolo: interesting
14:34:41 <mauke> to specify K&R-style indenting
14:34:52 <joelr1> mauke: ah, you are talking about indent the program, no, i'm doing this in haskell
14:35:40 <dmead> ?src find
14:35:41 <lambdabot> find p          = listToMaybe . filter p
14:35:46 <dmead> yuck
14:35:49 <phoniq> you just want some decent syntax hilighting?
14:36:31 <DRMacIver> That's a rather cool implementation.
14:37:19 <DRMacIver> Incidentally, I've realised what I like the most about Haskell's purity. Getting rid of that damn value restriction.
14:37:34 <lypanov> value restriction?
14:38:07 <DRMacIver> lypanov: That wouldn't have been a valid definition in ML, because top level values may not be polymorphic.
14:38:09 <joelr1> phoniq: that will come later
14:38:10 <DRMacIver> (Only top level functions)
14:38:10 <joelr1> http://groups.google.com/group/fa.haskell/browse_frm/thread/6d70543295478ee4/ff77615d4110a536?lnk=gst&q=pretty+printer&rnum=2#ff77615d4110a536
14:38:13 <lambdabot> Title: fa.haskell | Google Groups, http://tinyurl.com/25t6xz
14:38:37 <DRMacIver> You'd have to arbitrarily make it pointful by adding an explicit argument.
14:38:52 <DRMacIver> This used to drive me mad when I was writing a lot of ML. :)
14:39:27 <DRMacIver> (The reason for it is reference types and other similar mutable data structures)
14:39:45 <dmwit> Something like the monomorphism restriction?
14:39:48 <sjanssen> that is a bit of a wart
14:40:08 <DRMacIver> dmwit: I can never remember what the monomorphism restriction is. :)
14:40:24 <dmwit> ?wiki monomorphism restriction
14:40:24 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
14:40:39 <sjanssen> dmwit: you can subvert the type system with polymorphic mutable references -- I imagine this is what DRMacIver is referring to
14:40:45 <ddarius> The monomorphism restriction is just like the value restriction only it doesn't need to be there.
14:40:57 <DRMacIver> sjanssen: Yes.
14:41:01 <sjanssen> you can do it in Haskell with unsafePerformIO
14:41:07 <dmwit> Ah, okay.
14:41:44 <sjanssen> the restrictions are quite different, I think
14:42:04 <sjanssen> you can always sidestep the monomorphism restriction with a type signature
14:42:21 <SamB> but isn't that the only difference?
14:42:47 <ddarius> sjanssen: That's because it's not necessary, but I agree I didn't phrase what I said very clearly.
14:43:25 <DRMacIver> SamB: Well, the value restriction is very neccessary in ML (although it could be weakened).
14:43:53 <DRMacIver> It's just a pain in the ass in the cases where it is 'obviously' safe to do so. :)
14:44:45 <DRMacIver> And as I a) Wrote almost entirely pure ML (which I then invoked from the interpreter to do computations with) and b) Used a lot of currying to build up functions by parts I ran into it on a very regular basis.
14:45:26 <ddarius> And now you're here.
14:45:44 <DRMacIver> Indeed.
14:45:48 <ptolomy> A question on reddit: "why isn't head :: [a] -> Maybe a?".. am I right in assuming "history" and "because it is a convenience function with a well-defined meaning, and the maybe would sorta ruin the convenience. plus, you don't have to use it in unsafe situations"?
14:46:28 <DRMacIver> Sounds about right.
14:46:40 <Philippa> yep, very much historical reasons
14:47:05 <sjanssen> I'd say convenience
14:47:08 <DRMacIver> There'd probably be little benefit in using it if it were [a] -> Maybe a
14:47:28 <DRMacIver> (And, as we saw a few minutes ago, there's listToMaybe for the cases where there would be one)
14:47:30 <sjanssen> practically zero benefit: I'd almost always use pattern matching instead
14:48:07 <Wild_Cat> [a] -> Maybe a would force you to do some sort of (longer) pattern matching anyway.
14:48:59 <monochrom> "head" is intended to be unsafe.
14:49:02 <Wild_Cat> which'd end up as some over-copy/pasted boilerplate code, like empty catch blocks in Java.
14:49:59 <monochrom> I always wondered "should I throw exception, or should I return Nothing"?
14:50:10 <monochrom> But now I have found the answer!
14:50:35 <DRMacIver> In Java the answer is always "you should throw an exception" :)
14:50:42 <Wild_Cat> monochrom: depends. Is Nothing a logical result for your function?
14:51:06 <Wild_Cat> that's all there is to it, really.
14:51:31 <lypanov> nigtht all!
14:51:33 <mauke> head :: (Monad m) => [a] -> m a
14:51:50 <DRMacIver> Oh dear. Now monochrom is going to launch into some really extended and convoluted metaphor.
14:51:52 <mauke> runIdentity head "hi"
14:52:02 <ddarius> Now if only we could do, type Id a =a instance Monad Id
14:52:55 <mauke> instance Monad a where return = id; (>>=) = flip id
14:53:39 * DRMacIver is off to bed
14:53:40 <DRMacIver> night
14:55:11 <araujo> hello
14:55:58 <monochrom> safe :: a -> Maybe a; safe x = unsafePerformIO (catchJust errorCalls (liftM Just (evaluate x)) (const (return Nothing)))
14:56:29 <mauke> forceSafe
14:56:30 <monochrom> Example.  safe (head []) = Nothing.  safe (head [1]) = Just 1.
14:56:45 <monochrom> Isn't it nice that "safe" is implemented by "unsafe"? :)
14:56:59 <monochrom> (Now that's the convoluted metaphor you're looking for!)
14:57:34 <Saizan> ?djinn a -> Maybe a
14:57:35 <lambdabot> f = Just
14:59:16 <monochrom> I don't think logic alone dictates what should be logical results of intelligent designs.
15:01:25 <ddarius> monochrom: Safe is always implemented by unsafe.
15:01:35 <monochrom> Hee
15:03:27 <jbauman> ?djinn ((t -> s) -> t) -> t
15:03:27 <lambdabot> -- f cannot be realized.
15:07:28 <monochrom> yeah that one requires continuation aka classical logic
15:08:56 <jbauman> pretty much
15:09:05 <jbauman> i was wondering how much it could do
15:10:22 <ddarius> ?users
15:10:22 <lambdabot> Maximum users seen in #haskell: 336, currently: 297 (88.4%), active: 49 (16.5%)
15:11:49 <Saizan> how can you make a function with that type?
15:11:58 <ddarius> callcc
15:12:26 <Saizan> even in haskell?
15:12:39 <ddarius> You can't in Haskell, that's why Djinn fails.
15:12:46 <nominolo> hm, I feel stupid.  How do you write the manual MonadError instance for a newtype that is a wrapped ErrorT?
15:12:52 <monochrom> In Scheme.
15:13:00 <nominolo> haskell has no callCC?
15:13:14 <Saizan> haskell has the Cont monad
15:13:17 <monochrom> In Haskell you do it in the Cont monad.
15:13:22 <nominolo> ah, ok, not a pure
15:13:22 <ddarius> nominolo: You can use a monad, but a "native" call/cc would destroy referential transparency.
15:13:59 <nominolo> I have: newtype RM a = RM (ErrorT Restart (ContT a IO) a)
15:14:04 <monochrom> One of the TMR articles helps.
15:14:13 <nominolo> can someone help me write the MonadError instance for this one?
15:14:19 <nominolo> (newtype deriving doesn't work)
15:14:48 <sorear> hello.
15:14:49 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:53 <sorear> @messages
15:14:54 <lambdabot> kosmikus said 15h 19m 34s ago: Excuse me if I somehow missed it, but have you written a vty entry for the HCAR? If not, why not -- and how soon could you do it?
15:14:57 <monochrom> Is Restart an instance of Error?
15:15:01 <ddarius> You should just be able to unwrap and rewrap and use ErrorT's methods.
15:15:07 <nominolo> monochrom: yeop
15:15:43 <nominolo> no the problem is the second argument to catchError is a function returning the wrapped thing
15:16:03 <nominolo> I have no idea how to wrap the successful result and not wrap the handler-result
15:16:09 <nominolo> !paste
15:16:09 <hpaste> Haskell paste bin: http://hpaste.org/
15:16:12 <monochrom> throwError e = RM (throwError e)
15:16:36 <nominolo> monochrom: of course, i've got that! :)
15:16:43 <nominolo> now catchError please :)
15:17:26 <ddarius> @type catchError
15:17:28 <dmead> > succ '1'
15:17:28 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
15:17:30 <lambdabot>  '2'
15:17:42 <ddarius> > succ '9'
15:17:43 <lambdabot>  ':'
15:17:44 <sphynx> hi. I wonder why my foldr realization is a bit slower that standard foldr..
15:18:12 <ddarius> sphynx: Probably because it doesn't have rewrite rules that fuse it with good producers.
15:18:18 <sphynx> my mfoldr is: mfoldr f c [] = c
15:18:18 <sphynx> mfoldr f c (x:xs) = x `f` (mfoldr f c xs)
15:18:19 <hpaste>  nominolo pasted "catchError definition?" at http://hpaste.org/1749
15:18:28 <ddarius> @src foldr
15:18:28 <lambdabot> foldr k z xs = go xs
15:18:28 <lambdabot>     where go []     = z
15:18:28 <lambdabot>           go (y:ys) = y `k` go ys
15:18:32 <dolio> catchError m f = RM $ catchError (unRM m) (unRM . f) ?
15:19:02 <sphynx> ddarius, so rewrite rules do some optimization? this is only one reason?
15:19:05 <nominolo> dolio: Thanks.  I knew I would feel stupid now
15:19:15 <nominolo> @slap nominolo
15:19:16 * lambdabot smacks nominolo about with a large trout
15:19:23 <nominolo> @botsnack
15:19:24 <lambdabot> :)
15:19:31 <sphynx> ddarius, or there are some principal differences between my code and standard code
15:19:53 <ddarius> sphynx: Well, as the @src suggests.  If GHC can't infer a worker/wrapper transform then it will also likely be slower.
15:20:00 <ddarius> sphynx: Your code
15:20:05 <ddarius> -is- the standard code.
15:20:43 <stepcut> sphynx: you can read more about rewrite rules here: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
15:20:44 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
15:21:29 <dcoutts> dons: I've got QC tests for Binary Get & Put working
15:21:39 <kuribas> Why cann't ghc do rewrite based on the function definition?
15:21:42 <sphynx> stepcut, ok, I'll take a look. Bit maybe this article is too hard for little haskeller? :)
15:21:48 <nominolo> isn't the standard code  unstream . foldr_s . stream ?
15:21:48 <dcoutts> kuribas: it does that too
15:22:04 <kuribas> Oh, then why are rewrite rules necessary?
15:22:18 <ddarius> The standard code is foldr c n [] = n; foldr c n (x:xs) = c x (foldr c n xs)
15:22:21 <dcoutts> kuribas: they give extra things that the compiler couldn't ever infer on it's own
15:22:27 <sphynx> ddarius, so, if GHC encounters some known function (as foldr), it do some optimization then using rewrite rules, am I right?
15:22:43 <ddarius> sphynx: You can make your own rewrite rules.
15:22:49 <dcoutts> kuribas: the compiler call already use the function definition itself as rewrite rules, this gives additional rules
15:22:57 <dcoutts> call/can
15:23:00 <MeMeN> Hey guys, i was wondering if you knew any resources where i could learn how to use polymorphic types better? i have an exam soon and just had a look at a past paper, the function we were given was: fun1 (a:b) f x = a ((x f b) . f) and it completly threw me since i had never really programmed with lists of functions before
15:23:03 <ddarius> dcoutts: In theory it could, but that'd take more than a "sufficiently smart" compiler.
15:23:19 <ddarius> (And in some cases it couldn't, simply because the rewrite rules aren't true.)
15:23:27 <MeMeN> by types i mean how to type complicated functions :)
15:23:34 <sphynx> ddarius, yes, I know. Where can I look for GHC standard rewrite rules? Somewhere in GHC sources?
15:23:45 <sorear> sphynx: yeah, base source
15:23:46 <dcoutts> ddarius: it theory it could prove arbitrary theorems but it's not helpful to suggest it should :-)
15:23:47 <ddarius> Yes, the source.
15:23:50 <sorear> @source GHC.List
15:23:51 <lambdabot> GHC.List not available
15:23:55 <sorear> @slap @source
15:23:56 * lambdabot smacks @source about with a large trout
15:24:09 <ddarius> dcoutts: I definitely wasn't suggesting it should.
15:24:45 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/List.lhs
15:24:50 <sorear> there's one of them
15:24:51 <dcoutts> ddarius: I know, I know. I'm just slightly tired of the "sufficiently smart compiler" meme.
15:24:58 <sorear> @seen kosmikus
15:24:59 <lambdabot> kosmikus is in #haskell, #gentoo-haskell and #darcs. I last heard kosmikus speak 8h 10m 50s ago.
15:25:00 <monochrom> MeMeN: I spent years practising logic (in particular "unification" aka plugging in things) and then these type things became easy to me. I am serious.
15:25:21 <ddarius> sphynx: There's also a flag that will show which rules are used so you can grep for them if you compare code.
15:25:30 <SamB> a sufficiently smart compiler could rewrite GHC's inliner
15:25:33 <sorear> -ddump-simpl-stats
15:25:44 <SamB> did I mention it would be rather a dangerous thing?
15:26:12 <sphynx> sorear, is this the flag mentioned by ddarius ?
15:26:17 <sorear> sphynx: yes
15:26:17 <monochrom> The computer also performs "unification" to figure it out. It's an exponential-time algorithm, to make you feel better.
15:26:18 <ddarius> I only knew Prolog and templates in C++ and I had no problem picking up parametric polymorphism.
15:26:23 <MeMeN> monochrom : hehe, so nothing then? :)
15:27:05 <dcoutts> hia waern
15:27:18 <waern> hi duncan
15:27:22 <waern> what's up?
15:27:26 <monochrom> Well, if pressed, I could find a collection of web pages explaining the process. But without practice one still can't do it reliably and speedily during exam.
15:27:43 <sorear> hiya
15:27:44 <dcoutts> waern: binary hacking :-) doing interesting QC tests
15:28:01 <MeMeN> monochrom : given the example above can you work out the type? no cheating :)
15:28:10 <kuribas> dcoutts: I image some kind of constraint propagation could infer certain rules.
15:28:11 <monochrom> I'll try.
15:28:22 <MeMeN> its long lol
15:28:24 <waern> dcoutts, ok. I've worked a little more on my scintilla binding today :)
15:28:29 <dcoutts> kuribas: perhaps, but not the fusion rules we use I think.
15:28:47 <dcoutts> waern: oh yeah? what new features have you got access to ?
15:28:53 <ddarius> MeMeN: Just start writing down constraints.
15:28:57 <sorear> dcoutts: there is a word for using function definitions as rewrite rules.
15:29:02 <sorear> dcoutts: it's called "inlining"
15:29:22 <dcoutts> sorear: and case elimination
15:29:30 <monochrom> from "a:b" get a :: t, b :: [t].
15:29:37 <dcoutts> sorear: but that's not the only way to do it
15:29:38 <ddarius> Or subsuming all of them, beta-reduction.
15:29:49 <kuribas> Or partial evaluation?
15:29:50 <waern> dcoutts, well I've not bound any new functionality, just made all constants into proper datatypes (that is, I've worked on the binding generator)
15:29:57 <MeMeN> ddarius : i understand your logic, and im usually fine with this stuff but taking the example above and you show me what your thinking would be?
15:30:22 <ddarius> monochrom is already doing it, it's fairly mechanical.
15:30:31 <MeMeN> :)
15:30:35 <dcoutts> kuribas: it my experience you work much harder on the rules than on the code and the rules are small and carefully crafted.
15:30:45 <ddarius> I'd need paper and pencil because I can't keep track of all the constraints in my head.
15:30:52 <ddarius> And I don't feel like getting some out.
15:30:53 <monochrom> from "a (...)" get a :: u->v, (x f b) . f :: v.  Henceforth t = u->v and I won't use t again.
15:31:01 <dcoutts> kuribas: my point is, infering rules seems to be the wrong way round, try inferring the verbose bits
15:31:48 <kosmikus> sorear: ?
15:33:09 <monochrom> (x f b) . f  also says that (x f b) and f are functions (possibly different type).  Let's say (x f b) :: c->d, f :: e->c.  So v = e->d
15:33:10 <sorear> kosmikus: I've lost interest.  Should I still write an entry?
15:33:14 <kuribas> dcoutts: which verbose bits?
15:33:32 <dcoutts> kuribas: the implementation :-)
15:33:35 <dcoutts> the definition
15:34:17 <kuribas> yes.
15:34:30 <dcoutts> kuribas: the other thing is if you're going to infer rules, you need to know they are confluent and terminating
15:34:38 <dcoutts> and you want to know they are optimisations
15:34:56 <kosmikus> sorear: lost interest in vty? well, I think it would be good to submit an entry, but obviously, I can't force you ;)
15:34:59 <monochrom> In (x f b) :: c->d, we now also know the types of f :: e->c, b :: [u->e->d].  So x :: (e->c)->[u->e->d]->c->d
15:35:01 <dcoutts> to know which way round to use the equation as a rewrite rule
15:35:51 <icarroll> @hoogle Ord b => (a,b) -> (a,b) -> Ordering
15:35:52 <lambdabot> No matches, try a more general search
15:36:51 <MeMeN> monochrom : whats this algorithm called?
15:37:03 <monochrom> Now I have figured out everything. fun1 (a:b) f x :: e->d (look at RHS of fun1), and we know f and x, therefore f :: [u->e->d] -> (e->c) -> ((e->c)->[u->e->d]->c->d) -> e->d.
15:37:24 <monochrom> Unification. Actually look for "type inference".
15:37:27 <kuribas> dcoutts: I'd think removing temporary objects would be a good optimisation.
15:37:47 <monochrom> "Hindley-Milner type inference"
15:38:02 <dcoutts> kuribas: aye, but how do you know a rewrite rule one infers does indeed do something like that
15:38:23 <ddarius> @oldwiki QuotesPage
15:38:26 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
15:38:26 <MeMeN> monochrom : cool :) your getting there
15:38:52 <kuribas> dcoutts: just inline the definition, and see if it gets somewhere.
15:38:55 <ddarius> MeMeN: Just where this shirt to class! http://www.cafepress.com/skicalc
15:39:10 <dcoutts> kuribas: right, and ghc already does that
15:39:17 <monochrom> I hope I made no mistake. But even so, it illustrates the idea. Algebra! Assign variable to unknowns. Then use knowns to figure out unknowns.
15:39:25 <MeMeN> dcoutts lol
15:39:53 <MeMeN> monochrom : thanks, i'll have a closer look
15:39:55 <dcoutts> kuribas: the rules system is a good deal more powerful than that
15:40:07 <dcoutts> MeMeN: huh?
15:40:13 <sorear> IMO constraint solving is a bad way to look at algorithms because it tends to obscure data patterns.
15:40:19 * kc5tja just watched the Wadler tech-talk.  That guy is a weirdo.  :)
15:40:35 <dcoutts> kc5tja: did he do the lambda man thing? :-)
15:40:50 <kc5tja> But the topic was very, very, very interesting, and gives me something to think about supporting something _like_ typeclasses in Forth.
15:40:51 <sorear> I was taught gaussian elimination using intuitive constraint solving, and for many years thought it was impossible to mechanize.
15:40:54 <kc5tja> dcoutts: Yes.
15:41:00 <sorear> hiya kc5tja
15:41:22 <kc5tja> re sorear
15:41:46 <monochrom> sorear: I may agree. It is a way to teach humans how to do it. Maybe not for computers.
15:41:52 <MeMeN> MeMeN: Just where this shirt to class! http://www.cafepress.com/skicalc
15:41:54 <MeMeN> :)
15:42:08 <kuribas> dcoutts: So ghc will rewrite (map f (map g l)) into (map (f . g) l)?
15:42:28 <sorear> kuribas: Yes.
15:42:43 <sorear> kuribas: Well, technically no.
15:42:54 <dcoutts> kuribas: yes, but only because of rewrite rules that the authors of the Data.List library added into that library.
15:42:59 <sorear> kuribas: it will rewrite it into map (f . g) l with map inlinee
15:43:16 <chessguy> MeMeN: heh. what is that shirt about?
15:43:19 <sorear> ah yes, 3rd party RULES could make it a Yes again.
15:43:30 <ddarius> sorear: Just use a constraint programming language.
15:43:31 <dcoutts> sorear: actually our's goes back to map and lets ghc decide if it wants to inline map
15:43:33 <chessguy> that looks like denotational semantics
15:44:14 <ddarius> chessguy: It's the Hindley-Milner type inference algorithm.
15:44:19 <dcoutts> kuribas: without those rules, ghc could inline both maps but it could not fuse them because map is involves a fixpoint.
15:44:24 <ddarius> For the lambda calculus with let
15:44:24 <monochrom> Someone still has to compile the constraint programming language into instructions and data.
15:44:31 <sorear> Hehe.
15:44:47 <sorear> I have (and wear to class frequently) a very similar shirt.
15:44:56 <monochrom> Alternatively the ancient Roman way of using slaves for computing is also an option.
15:44:59 <dcoutts> kuribas: and the ordinary optimisations don't trace data flow through fixpoints
15:45:04 <sorear> Unfortunately mine has the Navier-Stokes equations, not HM :(
15:45:07 <chessguy> aha
15:45:09 <njbartlett> MeMeN: I'm wearing that shirt right now!
15:45:18 <MeMeN> njbartlett lol
15:45:21 <dcoutts> kuribas: that's what fusion systems are all about, like the build/foldr fusion system or the new stream fusion system.
15:45:56 <ddarius> sorear: Unfortunately, those are essentially useless to you without a computer.  Whereas the H-M rules are easy enough to do by hand.
15:45:57 <dcoutts> kuribas: they deal with eliminating the intermediate data structures in examples like map f . map g  (and in many much more complex examples)
15:46:00 <sorear> How long until GHC implements nuclear fusion?
15:46:09 <nominolo> Baughn: ping
15:46:22 <dcoutts> sorear: I intend to work on warm fusion for ghc
15:46:32 <kuribas> dcoutts: sounds nice.  And it can do this based on the function definition?
15:46:40 <ddarius> sorear: Once we compile it on enough cores in a close space.
15:46:49 <dcoutts> kuribas: no, based on the library author being cunning
15:47:06 <hpaste>  nominolo pasted "Continuable Exceptions in Haskell" at http://hpaste.org/1750
15:47:10 <sorear> ddarius: Contrariwise, the *results* of NS are intuitively meaningful, but the output of HM is only really useful for avoiding type errors.
15:47:33 <monochrom> HM is intuitively meaningful too.
15:47:55 <nominolo> @tell Baughn Maybe this is what you were looking for?  http://hpaste.org/1750
15:47:56 <lambdabot> Consider it noted.
15:48:09 <dcoutts> kuribas: warm fusion is about doing fusion without the library author having to be cunning and many fusion systems can be generalised from lists/arrays to arbitrary algebraic data types (like trees).
15:48:23 <ddarius> sorear: Now if only you could get to some of those results with paper and pencil.
15:48:36 <dcoutts> kuribas: so there's plenty more automation possible in fusion systems
15:49:16 <monochrom> When will GHC break even? When will GHC sustain itself?  *duck*
15:49:39 <kuribas> dcoutts: That's sort of what I was thinking of.  Are there papers describing this?
15:49:49 <ddarius> kuribas: Yes
15:49:57 <ddarius> @google "warm fusion" haskell
15:50:00 <lambdabot> http://www.program-transformation.org/Stratego/WarmFusionInStratego
15:50:00 <lambdabot> Title: Stratego / Warm Fusion In Stratego
15:50:01 <monochrom> (Love poem to GHC)  You are my Sun, my Star, my Light....
15:50:14 <dcoutts> kuribas: the stream fusion paper and all the previous papers on short cut, warm fusion and hylo fusion
15:50:42 <ddarius> CT is actually handy here.
15:51:17 <ddarius> "GHC, you are the kerosene to my silicon space heater."
15:51:40 <nominolo> @hoogle Socket -> Handle
15:51:41 <lambdabot> No matches, try a more general search
15:52:01 <nominolo> @hoogle Socket -> ByteString
15:52:02 <lambdabot> No matches, try a more general search
15:52:08 * nominolo cries
15:52:11 <monochrom> hahaha
15:52:33 <kuribas> Ah, great, I'll check them out.
15:52:50 <nominolo> is this a fact or an artifact of limited wisdom of lambdabot?
15:52:50 <monochrom> Are you absolutely sure you want your Socket and then Handle-ize it?
15:53:09 <nominolo> monochrom: no, i actually care more about the second request
15:53:26 <nominolo> but it seems BS are only defined on handles
15:54:44 <monochrom> use Network.accept or Network.connectTo. They return Handles.
15:55:10 <monochrom> that means, use Socket only for listenOn and accept.
15:55:29 <sorear> nominolo: Sockets cannot be read from.
15:55:44 <sorear> C's pathetic type system doesn't stop you from trying.
15:55:49 <sorear> it's all fds there
15:56:06 <monochrom> Do not use Network.Socket.socketToHandle.
15:56:45 <nominolo> sorear: so how would you read a socket as a bytestring?
15:57:10 <monochrom> I think I have answered that.
15:57:21 <dcoutts> monochrom: why not convert to a Handle ?
15:57:35 <monochrom> Same reason why not convert IO Int to Int.
15:58:01 <monochrom> Do not use unsafePerformIO to convert IO Int to Int.
15:58:03 <nominolo> monochrom: I am confused about the "Sockets cannot be read from." statement
15:58:20 <monochrom> <monochrom> use Network.accept or Network.connectTo. They return Handles.
15:58:29 <dcoutts> ah ok
15:58:39 <sorear> nominolo: Why, oh why, do you want to read a socket?!
15:58:45 <sorear> kosmikus: Sent.
15:59:00 <nominolo> I'm trying to make Network.HTTP use ByteStrings
15:59:45 <sorear> nominolo: How are you reading [Char] from sockets?
15:59:52 <sorear> You shouldn't be able to.
16:00:32 <monochrom> Someone's using Network.Socket.recv or something.
16:01:19 <nominolo> :t recv
16:01:22 <lambdabot> Not in scope: `recv'
16:01:28 <ddarius> @hoogle recv=
16:01:28 <nominolo> :t Network.Socket.recv
16:01:28 <lambdabot> hoogle: Hoogle.Parser.readType: ([recv,=],BItem =)
16:01:29 <lambdabot>  
16:01:31 <lambdabot> Network.Socket.Socket -> Int -> IO String
16:03:25 <nominolo> So, how do I write recv :: Socket -> Int -> IO ByteString ?
16:03:37 <nominolo> or how much effort would that be?
16:04:36 <monochrom> Hack the source code of Network.Socket.
16:05:25 <nominolo> fair enough.  that's what I hoped to avoid.
16:05:36 <monochrom> This is twindling down the low-level programming tarpit. Don't join the dark side. But it's your choice.
16:06:36 <monochrom> I would rewrite Network.HTTP to use Network.connectTo and handles, no socket. But it's your choice. I can only look at you and say, "this kid is lost to the dark side".
16:08:36 <nominolo> monochrom: you are contradicting yourself "Hack the source code of Network.Socket" vs. "This is twindling down the low-level programming tarpit. Don't
16:08:36 <nominolo> 	    join the dark side."
16:10:28 <monochrom> Because I try to "put myself into your shoe", at the same time disagreeing it in distaste.
16:10:50 <sjanssen> what is wrong with socketToHandle?
16:11:14 <monochrom> You want to hear me talk like sorear "just don't do that" and risk being marked as "unhelpful"?
16:11:49 <monochrom> Nothing wrong with socketToHandle. But don't do that. Nothing wrong with unsafePerformIO but don't do that either.
16:12:27 <Knuckles> hello all!
16:12:28 <sjanssen> there are plenty of reasons not to use unsafePerformIO
16:12:33 <nominolo> monochrom: if I know the invariants, it's OK
16:12:37 <Knuckles> I need your help for one on my function!
16:12:42 <sjanssen> monochrom: what are the reasons you shouldn't use socketToHandle?
16:13:23 <monochrom> There are already connectTo, accept, ... safe wrappers. Try to use safe wrappers.
16:13:41 <Knuckles> i have created a data, and i want to apply a function on it. but in this function, i have to use the name of the data, and also the "things inside"
16:13:43 <Knuckles> like
16:13:50 <Knuckles> equilibre mobile =
16:13:52 <Knuckles> &&
16:13:59 <Knuckles> equilibre (Branche e g d)
16:14:03 <Knuckles> how can i do?
16:14:17 <kpreid> equilibre mobile@(Branche e g d) = ...
16:14:38 <Knuckles> oh thanks :D
16:14:47 <Amran> kpreid: so that's what the @ syntax does
16:14:51 <nominolo> monochrom: socketToHandle is bad because the original socket might be closed.  That's not a problem in my case
16:14:53 <Amran> always wondered
16:15:09 <nominolo> s/might be close/must not be used anymore/
16:15:16 <kpreid> Knuckles: of course, you can also just reconstruct the value on the right side
16:15:38 <ddarius> or use a case statement
16:15:53 <ddarius> Amran: What did you think it meant?
16:16:20 <Amran> ddarius: just didn't know what it meant, so filtered it out when reading haskell code
16:18:25 <Knuckles> i have an "non exhaustive patterns in function equilibre"
16:18:28 <Knuckles> this is my function :
16:18:39 <Knuckles> equilibre mobile@( Branche e g d )
16:18:39 <Knuckles> 			| estEquilibre mobile = mobile
16:18:39 <Knuckles> 			| otherwise = ( Branche ((poidsTotal d)/(poidsTotal g + poidsTotal d)) (equilibre g) (equilibre d) )
16:18:55 <kosmikus> sorear: thanks
16:19:01 <Knuckles> do you have an idea?
16:19:28 <Knuckles> because i don't understand what it means.
16:19:50 <monochrom> Bah.
16:20:09 <igli> Knuckles: you are missing some cases i believe
16:20:18 <sjanssen> Knuckles: that means that there are patterns your function doesn't check for
16:20:30 <Knuckles> oh
16:20:32 <Knuckles> ok...
16:20:36 <Knuckles> don't see wich ones
16:21:01 <ddarius> Knuckles: You are only handling one, I suspect your data type has multiple constructors.
16:21:18 <Amran> Knuckles: is the definition of mobile only Branch e g d?
16:21:18 <Knuckles> data Mobile a = Poids a | Branche a (Mobile a) (Mobile a) deriving (Show,Eq)
16:21:24 <Knuckles> there is poids
16:21:30 <Knuckles> but in poidsTotal i have
16:21:41 <Amran> yeah that's probably it then
16:21:41 <Knuckles> poidsTotal :: (Mobile Float)->Float
16:21:41 <Knuckles> poidsTotal ( Poids a ) = a
16:21:41 <Knuckles> poidsTotal ( Branche _ g d ) = poidsTotal g + poidsTotal d
16:22:07 <kpreid> Knuckles: equilibre needs a case for Poids
16:22:09 <ddarius> Knuckles: equilibre recurses on the structure of Mobile so it will eventually hit the base case, Poids, and it doesn't handle that case.
16:22:36 <Knuckles> ok
16:23:22 <Knuckles> but i don't understand
16:23:23 <Knuckles> because
16:23:26 <Knuckles> in my first case
16:23:32 <Knuckles> if estEquilibre return True
16:23:38 <Knuckles> it just returns the mobile
16:23:41 <Knuckles> and
16:23:50 <Knuckles> estEquilibre :: (Mobile Float)->Bool
16:23:50 <Knuckles> estEquilibre (Poids a) = True
16:23:50 <Knuckles> estEquilibre ( Branche e g d ) = if (e==(poidsTotal d)/((poidsTotal g)+(poidsTotal d))) then estEquilibre g && estEquilibre d else False
16:23:53 <ddarius> Knuckles: It still performs the pattern match even with the @ syntax.
16:23:53 <Knuckles> so
16:23:54 <dmwit_> But the pattern match happens before the guard, so...
16:24:05 <Knuckles> oh
16:24:10 <Knuckles> how can i do?
16:24:13 <Knuckles> i can't use guards?
16:24:26 <kpreid> you must put the pattern match after the =
16:24:29 <ddarius> You -could- use an irrefutable match or rebuild the data structure, but I'd just handle the Poids case separately.
16:24:31 <kpreid> with a case or let
16:24:37 <kpreid> or what ddarius said
16:24:55 <Knuckles> yeah
16:24:59 <Knuckles> Thank you for your help
16:25:01 <olsner> urgh... non-english code
16:25:02 <Knuckles> i succeed :p
16:25:08 <Knuckles> (french code sorry :p )
16:25:17 <Knuckles> equilibre (Poids a) = (Poids a)
16:25:17 <Knuckles> equilibre mobile@( Branche e g d )
16:25:17 <Knuckles> 			| estEquilibre mobile = mobile
16:25:17 <Knuckles> 			| otherwise = ( Branche ((poidsTotal d)/(poidsTotal g + poidsTotal d)) (equilibre g) (equilibre d) )
16:25:24 <Knuckles> Thank you for your help !
16:28:11 <kc5tja> Nothing wrong with non-English code.  Learning a new language is good for you.
16:28:27 <kc5tja> (so says the one who cannot learn other spoken languages, but takes on programming languages like a sponge in water)
16:28:43 <ehird`> kc5tja: ditto with the parens
16:29:06 * syntaxfree whirls in, dancing and spinning in the embrace of the trade winds.
16:29:23 <augustss> how poetic :)
16:29:32 <olsner> @quote syntaxfree
16:29:32 <lambdabot> syntaxfree says: yes, The Wadlerman. the Prince of Funktions.
16:29:38 * sorear rots in place in one of San Diego's yearly heat waves
16:30:58 <kc5tja> parentheses without living ways of there exists I agree more could not but   ;)
16:31:19 <olsner> hmm, strange... at first I though "heat waves!? but it's winter!" .. but then I realized it's actually almost summer now
16:31:31 <syntaxfree> @quote heat
16:31:32 <lambdabot> syntaxfree says: I'm trying out common lisp.  ...  I feel like I'm cheating on my wife or something.
16:31:37 <olsner> how does one confuse summer and winter?
16:31:44 <beelsebob> http://www.hugeurl.com/?NjFjMTk0Zjk5YmI5YjNjODY3ZWYxYjBjY2M4Njg3YzkmMTMmVm0wd2QyUXlVWGxWV0d4WFlUSm9WMVl3Wkc5V1ZsbDNXa2M1YWxKc1dqQlVWbHBQVjBaYWMySkVUbGhoTVVwVVZtcEdZV015U2tWVWJHaG9UV3N3ZUZacVFtRlRNazE1VTJ0V1ZXSkhhRzlVVm1oRFZWWmFkR1ZHV214U2JHdzFWa2QwYzJGc1NuUmhSemxWVmpOT00xcFZXbUZrUjA1R1pFWlNUbFpVVmtwV2JURXdZVEZrU0ZOclpHcFRSVXBZVkZWYWQxTkdVbFZTYlVacVZtdGFNRlZ0ZUZOVWJVWTJVbFJHVjFaRmIzZFdha1poVjBaT2NtSkdTbWxTTW1oWlYxZDRiMkl3TUhoWGJHUllZ
16:31:49 <beelsebob> o.O
16:32:12 <sorear> olsner: SD has really really weird weather 2 mo / yr.
16:32:26 <sorear> then spends 10mo erasing your memory
16:32:35 <augustss> @quote
16:32:36 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
16:33:03 <olsner> beelsebob: I think your url was truncated
16:33:12 <beelsebob> olsner: wouldn't be surprised
16:33:20 <beelsebob> I just discovered hugeurl
16:33:28 <beelsebob> that was a hugeurl link to tinyurl
16:33:29 <beelsebob> :DD
16:33:47 <olsner> hugeurl link to a tinyurl link to a hugeurl link to ... :P
16:34:06 <beelsebob> hehe
16:34:23 <syntaxfree> ah.
16:34:49 <augustss> what an excellent service!
16:35:01 <kc5tja> That guy needs to sell t-shirts.
16:35:10 <kc5tja> I would not buy one, but there are plenty who would.
16:35:14 <beelsebob> http://tinyurl.com/32rnar
16:35:46 <Utooo> any opensource KM system made in Haskell ?
16:36:02 <Utooo> hi ;)
16:36:05 <syntaxfree> the type system is pretty much a KM system :)
16:36:15 <sorear> KM?
16:36:15 <Sgeo> KM?
16:36:17 <olsner> KM?
16:36:58 <syntaxfree> knowledge management.
16:37:00 <Utooo> knowledge management, like wikis
16:37:07 <syntaxfree> like wikis?
16:37:14 <syntaxfree> I thought you mean hard KR-fu.
16:37:20 <Utooo> well, a wiki is still better than something worth
16:37:28 <syntaxfree> ontologies & stuff.
16:37:34 <sorear> @google flippi haskell
16:37:36 <lambdabot> http://www.flippac.org/projects/flippi/
16:37:36 <lambdabot> Title: Flippi: a Wiki clone written in Haskell
16:37:39 <Utooo> yep but that users can use ;)
16:37:46 <kc5tja> Hmmm.....Haskell Wiki....Hiki....No, I can't say that I'd want a hiki on my website.  ;D
16:37:52 <syntaxfree> a wiki is not a KM system!
16:38:14 <syntaxfree> a wiki is merely a snotty CMS for rebellious teens!
16:38:24 <Philippa> Utooo: you're welcome to tweak Flippi into having a nice UI :-) It's not particularly difficult work, just tedious
16:38:35 <Utooo> well if you can better Im all ears, a complete KM user usable tool in Haskell, please tell me
16:38:35 <kc5tja> @remember syntaxfree a wiki is merely a snotty CMS for rebellious teens!
16:38:36 <lambdabot> Done.
16:38:44 <gravity> Ha!
16:38:51 <syntaxfree> @quote kc5tja
16:38:51 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
16:39:45 <chessguy> @quote
16:39:45 <lambdabot> tizoc says: * tizoc tiene poderes de verga regenerativa y se sigue garchando a emonk
16:39:58 <kc5tja> Not aware of any KM systems in Haskell.
16:40:10 <Sgeo> @quote
16:40:11 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
16:40:13 <chessguy> KM?
16:41:41 <Utooo> thx, do you think that Haskell could be used for that ? I mean allowing better options than another language (distributed agents, formal provers, resursive structures)
16:43:05 <Sgeo> @quote Sgeo
16:43:06 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
16:43:45 <SimonRC> Has anyone told the Goldilocks joke here yet?
16:43:48 <augustss> @djinn Maybe (b -> Either a b)
16:43:49 <lambdabot> f = Nothing
16:43:57 <SimonRC> feck, the answer is yes, it seems
16:44:00 <Sgeo> SimonRC, yes, me
16:44:19 <gmh33> anyone know how Scala deals with operator overloading (just as aside, feel free to /msg me if you know..)
16:44:35 <kc5tja> Goldilocks joke?
16:44:52 <monochrom> The answer is given before the question!
16:45:51 <Sgeo> kc5tja, <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
16:45:57 <dolio> djinn isn't a joke answering machine, it seems.
16:45:59 <kc5tja> Utooo: Haskell is a general purpose programming language, so it's certainly doable.  As far as options are concerned, I don't think it's any different than any other language, because Haskell's safety all comes from compile-time analysis, not run-time.
16:46:58 <monochrom> djinn takes the easy way out
16:47:40 <kc5tja> Sgeo: That's just ... BAD.
16:48:04 <int-e> @index Bad
16:48:05 <lambdabot> bzzt
16:48:16 <monochrom> @index recv
16:48:17 <lambdabot> Network.Socket
16:48:24 <SimonRC> but Djinn gives a function with a too-general type
16:49:01 <SimonRC> Erm, maybe
16:49:37 <sorear> @users
16:49:38 <lambdabot> Maximum users seen in #haskell: 336, currently: 297 (88.4%), active: 56 (18.9%)
16:50:42 <BRS_Runaro> Is there such a thing as a multi-user haskell system?
16:51:11 <Utoo> re, connection problem. I guess I missed the answer to my question :(
16:51:35 <sorear> Utoo: last line you saw?
16:51:45 <dibblego> is there an article describing how to write a double linked list?
16:51:58 <Utoo> nothing after my question ... firefox crashed
16:52:39 <int-e> check http://www.ircbrowse.com/channel/haskell/today ?
16:52:42 <lambdabot> Title: Meme haskell IRC Log 2007/05/07
16:52:47 <ehird`> BRS_Runaro: haskell mud? :)
16:53:03 <sorear> @where logs
16:53:03 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:53:17 <ddarius> Djinn returns multiple results, lambdabot just doesn't display them.
16:53:28 <Utoo> thank you
16:53:42 <BRS_Runaro> Yea, like a haskell mud... except with functions rather than rooms.
16:54:07 <ddarius> dibblego: Mutable or immutable lists?
16:54:45 <dibblego> ddarius, good question; I guess both (I can't think of how it would be done with an immutable list)
16:54:52 <jbauman> with an immutable list, that would be...challenging
16:54:57 <BRS_Runaro> More generally: is there a functional DBMS or functional OS?
16:55:01 <ddarius> @oldwiki TyingTheKnot
16:55:02 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
16:55:09 <ddarius> That has immutable doubly-linked lists.
16:55:16 <dibblego> thanks
16:55:23 <ddarius> BRS_Runaro: I don't know and yes.
16:55:40 <BRS_Runaro> ddarius: Thanks, and which one?
16:56:04 <ddarius> BRS_Runaro: There have been a couple functional OSes.
16:56:23 <ehird`> common lisp OS' are common
16:56:25 <ehird`> very common
16:56:29 <ehird`> ...lisp
16:56:32 <ehird`> BADUMMMMTISH
16:56:38 <BRS_Runaro> bwahaha
16:56:49 <ehird`> it wasn't that funny
16:56:51 <ddarius> dibblego: Mutable doubly linked lists are a more or less straightforward application of ST/IORefs.
16:56:57 <BRS_Runaro> Functional OS: An OS that actually functions.
16:57:04 <dibblego> ddarius, yeah I figured, thanks again
16:57:06 <ehird`> BRS_Runaro: yet to see one
16:57:08 <ddarius> @where hop
16:57:09 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
16:58:31 <Utoo> kc5tja: well yep but if offers easier tools for specific used to facilitate work (not going as far as making abstract ideas more tangible) so let's imagine I had to choose to build such a system, would you see any advantage here ?
16:59:18 <Utoo> (plus I tend to think that the architecture giving its structure to the language can make a difference)
17:03:24 <kc5tja> Utoo: I don't have any experience in the field, so I can't answer your question.  Sorry.  :/
17:03:32 <sorear>  
17:03:33 <sorear> *** You have joined channel #haskell [15:11]
17:03:33 <sorear> *** Topic for #haskell: ["The Haskell programming language: Summon Iron Coder
17:03:33 <sorear>     FUNCTIONAL!","Home: http://haskell.org","Paste: http://hpaste.org","Logs:
17:03:33 <BRS_Runaro> Yea, looks like there have been lots of Lisp-OS attempts.
17:03:35 <sorear>     http://tunes.org/~nef/logs/haskell/","History:
17:03:41 <sorear>     http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]
17:03:44 <sorear> *** #haskell: topic set by dons, 05:17:44 2007/05/06
17:03:47 <sorear> *** Users on #haskell: sorear tstewart stepcut ulf_ triplah_ Zeroth404 araujo
17:03:47 <sorear>     stef__ ptolomy sometwo davidL erider siti Wild_Cat gmh33 ddarius cmeme nbb
17:03:53 <sorear>     Cale_ dolio michaelr BRS_Runaro Metabol sphynx beelsebob ulfdoz agoode
17:03:56 <sorear>     FordCortina monochrom GeoBesh Plareplane Sgeo mathrick jmelesky ozo Muad_Dib
17:03:59 <sorear>     Igloo LPhas levitation[A] lucca dcnstrct andygill lispy slipstream--
17:04:15 <beelsebob> o.O\
17:04:18 <Cale_> wow, thanks for pinging everyone's name :)
17:04:26 <kpreid> not mine!
17:04:26 <beelsebob> sorear splode
17:04:41 <Utoo> kc5tja: no problem, thanks
17:04:43 <kc5tja> Not mine either.
17:04:57 <Utoo> wait...
17:05:49 <Sgeo> ok, I strongly suspect that trying to teach people Haskell by showing them the Either a b type is NOT the way to go
17:06:22 <beelsebob> Sgeo: why do you say that?
17:06:37 <beelsebob> I'm not saying it is the right way to go, it just seems a bit arbitrary
17:06:45 <Utoo> :)
17:06:58 <Sgeo> Because I tried it, in helping some people understand my pun :/
17:07:12 <beelsebob> I see
17:07:21 <Utoo> they are some research about education and pedagogy that could be used there
17:07:50 <beelsebob> if I had my way, we'd have disjunctive tuples anyway :P
17:08:07 <Sgeo> ..disjunctive tuples? What's those?
17:08:21 <beelsebob> tuples
17:08:25 <beelsebob> but disjunctive
17:08:28 <beelsebob> not conjunctive
17:08:42 <Sgeo> explain please?
17:08:48 <beelsebob> (a | b) -- this tuple has either the type a, or the type b
17:08:51 <int-e> @src Either
17:08:51 <lambdabot> Source not found. I feel much better now.
17:08:54 <beelsebob> it is synonymous with Either a b
17:09:04 <Sgeo> @src Left
17:09:04 <lambdabot> Source not found. stty: unknown mode: doofus
17:09:32 <beelsebob> ( | 5) -- This has type Num b => (a | b)
17:09:46 <monochrom> crazy
17:09:50 <beelsebob> yep
17:10:00 <beelsebob> useful though
17:10:04 <kpreid> beelsebob: how do you write the equivalent of (,)?
17:10:14 <beelsebob> kpreid: (|)
17:10:23 <kpreid> and is that a left or a right?
17:10:33 <beelsebob> good question
17:10:36 <beelsebob> *thinks*
17:10:40 <beelsebob> wait no
17:10:45 <beelsebob> | is unary
17:10:46 <int-e> (|) :: Either a b -> (a | b) ;-)
17:10:52 <beelsebob> indeed
17:10:57 <beelsebob> that makes sense int-e
17:11:02 <beelsebob> although not general enough
17:11:09 <kpreid> not very much like normal constructors though
17:11:22 <beelsebob> kpreid: true, but (,) isn't either
17:11:29 <sorear> @botsnack
17:11:29 <lambdabot> :)
17:11:39 <kpreid> (,) is just like (:)
17:11:40 <beelsebob> (,5) -- This section is not part of Haskell depsite being the normal syntax
17:11:42 <int-e> it doesn't really make sense. you'd have to mark the place of injection somehow.
17:11:50 <kpreid> it's only (,,) that is weird...okay, and that
17:11:50 <beelsebob> (:[]) -- This section is
17:11:52 <nominolo> @djinn (Either a b,Either c d) -> (Either (a,c) (b,d))
17:11:56 <lambdabot> -- f cannot be realized.
17:12:07 <int-e> beelsebob: that's not a section and you know it.
17:12:14 <kpreid> okay, (,) is weird, but (|) would be weirder
17:12:15 <nominolo> huh?
17:12:25 <beelsebob> int-e: which isn't a section?
17:12:32 <int-e> (,2)
17:12:32 <Sgeo> :t (:)
17:12:35 <lambdabot> forall a. a -> [a] -> [a]
17:12:37 <beelsebob> int-e: exactly
17:12:39 <beelsebob> that's my point
17:12:40 <int-e> not in the haskell sense anyway.
17:12:42 <Sgeo> What's (:)?
17:12:49 <dibblego> Sgeo, pronounced cons
17:12:50 <beelsebob> that (,) doesn't behave like a normal infix operator
17:12:51 <twanvl> @djinn (Either (a,c) (b,d)) -> (Either a b,Either c d)
17:12:52 <lambdabot> f a =
17:12:52 <lambdabot>     case a of
17:12:52 <lambdabot>     Left (b, c) -> (Left b, Left c)
17:12:52 <lambdabot>     Right (d, e) -> (Right d, Right e)
17:12:53 <Sgeo> oh
17:12:54 <Sgeo> sorry
17:13:03 <SamB> beelsebob: we know!
17:13:17 <int-e> nominolo: what would the result of f (Left a) (Right b) be?
17:13:23 <kpreid> @djinn (Either a b,Either c d) -> Maybe (Either (a,c) (b,d))
17:13:23 <lambdabot> f (a, b) =
17:13:24 <lambdabot>     case a of
17:13:24 <lambdabot>     Left c -> case b of
17:13:24 <lambdabot>               Left d -> Just (Left (c, d))
17:13:24 <lambdabot>               Right _ -> Nothing
17:13:25 <lambdabot>     Right e -> case b of
17:13:27 <lambdabot>                Left _ -> Nothing
17:13:29 <lambdabot>                Right f -> Just (Right (e, f))
17:13:53 <kpreid> hm, that could be written as three lines of =
17:14:06 <beelsebob> SamB: kpreid was suggesting than (,) acted like anything else, but that (|) wouldn't
17:14:15 <SamB> oh
17:14:40 <beelsebob> I do admit though that (|) would be even weirder than (,) is
17:14:50 <int-e> beelsebob: you'd still need something to distinguish left injection from right injection. say, (_|) and (|_).
17:14:57 <lispy> :t (,)
17:14:58 <SamB> we already have guards using |
17:15:00 <lambdabot> forall a b. a -> b -> (a, b)
17:15:07 <Sgeo> What's wrong with using Either?
17:15:08 <beelsebob> int-e: yeh, that's not so neat, but yeh
17:15:18 <int-e> Sgeo: nothing
17:15:19 <beelsebob> Sgeo: it's not clean in a lot of cases
17:15:26 <Sgeo> Other than the fact that there's only two thingies
17:15:46 <beelsebob> Sgeo: nothing -- I'm suggesting this as a method of making Haskell cleaner
17:15:59 <SamB> beelsebob: yes, yes, by making it dirtier
17:16:03 <beelsebob> in almost every case Haskell covers the disjunctive and conjuncitve case
17:16:05 <Philippa> tbh disjunctive tuples strike me as pretty yucky. Better to have extensible variants and some standard "I can't be arsed to name this properly" labels
17:16:06 <lispy> afterall, haskell is so dirty :)
17:16:11 <int-e> beelsebob: getting rid of tuples would be interesting.
17:16:14 <kpreid> One could argue that Either is bad because the constructor names are arbitrary
17:16:21 <beelsebob> int-e: that would be the alternative way of cleaning it up
17:16:33 <int-e> beelsebob: infix constructors are almost as neat.
17:16:33 <sorear> and (_|_) as dual injection?
17:16:39 <SamB> ooooo!
17:16:40 <Philippa> there aren't any disjunctive lists either, no biggie
17:16:41 <Sgeo> What am I supposed to do if I want three constructors?
17:16:41 <SamB> butts!
17:16:44 <beelsebob> int-e: indeed
17:16:50 <kpreid> with Maybe (for example) there is a structural difference and the constructors fit it; with Either the difference necessarily depends on the usage
17:16:52 <sorear> @quote (_|_)
17:16:53 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
17:17:01 <sorear> @quote (_\|_)
17:17:02 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
17:17:09 <lispy> kpreid: well, i think left and right are descriptive once you realize they are relative to the positions of the types...but they seem unrelated to "Either"
17:17:22 <sorear> INL! INR!
17:17:34 <Sgeo> Why is Just used as a constructor for Maybe?
17:17:45 <sorear> Just 1
17:17:48 <sorear> Nothing
17:17:58 <dolio> Yeah, the injection functions into (|) should be the duals of fst and snd, no?
17:17:58 <lispy> would you prefer Some?
17:18:00 <SamB> @quote (_\|_)
17:18:01 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
17:18:02 <dolio> Not related to (,).
17:18:05 <SamB> @quote _\|_
17:18:05 <Sgeo> Other than to allow me to make a bad pun way into the future..
17:18:06 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
17:18:07 <Sgeo> >.>
17:18:16 <SamB> hmm.
17:18:21 <SamB> no other quotes?
17:18:24 <int-e> @quote bad
17:18:24 <lambdabot> Cheery says: I don't know that I'd be allergic to anything, I just get very bad itch to my back when somebody mentions C
17:18:27 <SamB> @quote bottom
17:18:28 <lambdabot> nmessenger says: (_|_) <-- haha look at my bottom!
17:18:33 <lispy> why does | have to be escaped when looking up quotes?
17:18:33 <gmh33> Sgeo, because it can be Just a | Nothing :P
17:18:45 <SamB> lispy: regex metacharacter!
17:18:50 <Sgeo> @quote Sgeo
17:18:50 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
17:19:01 <lispy> SamB: oh, it's a regex search?
17:19:05 <SamB> yeah.
17:19:17 <Sgeo> @quote Just Right
17:19:18 <lambdabot> No quotes for this person. Are you on drugs?
17:19:24 <int-e> @djinn Maybe (b  -> Either a b)
17:19:25 <lambdabot> f = Nothing
17:19:32 <lispy> so why does it fail on whitespace?
17:19:37 <Sgeo> @djinn b -> Either a b
17:19:38 <lambdabot> f = Right
17:19:39 <lispy> ?quote Just.Right
17:19:40 <lambdabot> shapr says: I'm not stubborn, I'm just right.
17:20:14 <Sgeo> @quote Just\ Right
17:20:15 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
17:20:28 * SamB does *not* see how that would help
17:20:56 <Sgeo> Is it just me, or is there a difference between @quote and ?quote
17:21:01 <Sgeo> @quote Just.Right
17:21:01 <lambdabot> shapr says: I'm not stubborn, I'm just right.
17:21:05 <Sgeo> ..
17:21:14 <Sgeo> n/m
17:22:06 <SamB> @quote (just\ right)
17:22:07 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
17:22:21 <SamB> @quote just\ right.*
17:22:22 <lambdabot> No quotes for this person. My pet ferret can type better than you!
17:22:25 <SamB> hmm.
17:22:26 <monochrom> @quote \(monochrom\)
17:22:26 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
17:22:30 <sorear> SamB: spaces can't be escaped!
17:22:41 <SamB> sorear: ... oh.
17:22:44 <SamB> that is kinda stupid
17:22:46 <sorear> SamB: it uses 'break' to find where nick ends and regex begins
17:23:05 <waern> can I use the fact that I know a data type has an instance of a certain type class, in any way, even though that class isn't available (i.e. not exported at all)?
17:23:08 <sorear> (with fallback to regex if nick-only fails)
17:23:22 <SamB> well, it ought to give up on there being a nick if there is more text
17:23:29 <SamB> IMO
17:23:34 <sorear> waern: yeah, you can instantiate functions
17:23:51 <sorear> module A(foo) { class Foo ... foo :: Foo a => a }
17:23:55 <waern> sorear, oh right, of course
17:23:58 <sorear> import A ; foo :: Int
17:24:06 <waern> hmh
17:26:06 <Utoo> sorry I know it out of topic but maybe people should think on how to put Haskell into that http://www.firstmonday.org/issues/issue12_4/spoerri/index.html (I didnt say Haskell need a propaganda team ;)
17:26:10 <lambdabot> Title: Visualizing the Overlap between the 100 Most Visited Pages on Wikipedia for Sept ...
17:26:57 * Sgeo has not a clue about how to use import and stuff
17:27:30 <waern> sorear: so if I don't export any functions that use the typeclass, it would be nice if Haddock didn't show instances for that class in the documentation right?
17:28:26 <waern> for instances defined in the same module as the class
17:30:02 <Sgeo> What functions have type b -> Either a b ?
17:30:06 <Sgeo> Besides Right?
17:30:27 <sorear> waern: yes
17:30:52 <int-e> const Nothing
17:30:59 <int-e> const (Right undefined)
17:31:01 <dolio> There are some easy ones you could come up with.
17:31:01 <int-e> undefined
17:31:02 <sorear> Sgeo: undefined, \_ -> undefined , \_ -> Left undefined, \_ -> Right undefined
17:31:43 <Sgeo> How is \_ -> Left undefined of that type?
17:31:45 <sorear> Sgeo: \x -> x `seq` Right x, \x -> x `seq` Left undefined, \x -> x `seq` right undefined
17:31:51 <Sgeo> :t \_ -> Left undefined
17:31:54 <lambdabot> forall t a b. t -> Either a b
17:32:11 <int-e> Sgeo: take t = b.
17:33:46 <Sgeo> Functions that the Computer Science community wished existed:
17:33:51 <Sgeo> isBottom :: a -> Bool
17:34:09 <Sgeo> hmm..
17:34:20 <newsham> anyone know why programatica redirects to ogi.altocumulus.org which doesnt exist?
17:34:21 <Sgeo> Can I do pattern matching on undefined?
17:34:52 <dibblego> Sgeo, you might want to look at Turing's Halting Problem
17:35:19 <int-e> you can try with evaluate  and catching exceptions. of course you will still not catch nontermination that way.
17:35:31 <Pseudonym> The halting problem, sadly, is deferred until GHC 7.
17:35:50 <Pseudonym> Check with Oleg, though, I think he solved it in the type system.
17:36:05 <Sgeo> Pseudonym, >.>
17:38:03 <monochrom> sometimes by "undefined" we mean infinite loop.
17:38:16 <Sgeo> _|_
17:38:17 <newsham> > last [1..]
17:38:19 <monochrom> just sometimes.
17:38:21 <lambdabot> Terminated
17:38:25 <ddarius> @wn
17:38:29 <ddarius> @wn indoctrinate
17:38:31 <lambdabot> *** "indoctrinate" wn "WordNet (r) 2.0"
17:38:31 <lambdabot> indoctrinate
17:38:31 <lambdabot>      v : teach doctrines to; teach uncritically; "The Moonies
17:38:31 <lambdabot>          indoctrinate their disciples"
17:39:12 <Sgeo> At what point does an explict undefined actually get evaluated and cause an error?
17:39:25 <newsham> when it is needed.
17:39:41 <Sgeo> How is that determined?
17:40:11 <newsham> are you familiar with lazy evaluation?
17:40:13 <monochrom> "print stuff" is an example.  if stuff is bad, ...
17:40:38 <Sgeo> newsham, at what point does it stop being lazy?
17:40:42 <bd_> Sgeo: There are explicit rules for when _|_ is propagated into a function's result. We say that a function is 'strict in its argument' when the function's result is _|_ when the argument is _|_. So for example, (+) is strict in both arguments for all built-in numeric types, since _|_ + (anything) = _|_ and (anything) + _|_ = _|_
17:41:15 <Sgeo> How is that specified though?
17:41:17 <bd_> Sgeo: But, (:) - the list constructor - is not strict in its argument, as for example _|_ : [] = [_|_] which is not undefined in itself, but simply contains an undefined value.
17:41:38 <newsham> > let f d [] = []; f d (x:[]) = x; f d (_:xs) = f d xs in f 0 (undef : undef : undef : 5 : [])
17:41:39 <lambdabot>   Not in scope: `undef'
17:41:59 <Sgeo> > let f d [] = []; f d (x:[]) = x; f d (_:xs) = f d xs in f 0 (undefined : undefined : undefined : 5 : [])
17:42:00 <lambdabot>   add an instance declaration for (Num [a])
17:42:20 <bd_> Sgeo: the Prelude specifies which functions are strict on what, and with user-defined functions it's just derived based on what you're doing in them. There's also an extension to explicitly make arguments strict called 'bang patterns'. There's /also/ a function called 'seq' - seq a b = b, unless a is _|_ - it's used to force evaluation when you have space leaks or the link
17:42:27 <newsham> > let f d [] = d; f d (x:[]) = x; f d (_:xs) = f d xs in f 0 (undefined : undefined : undefined : 5 : [])
17:42:28 <lambdabot>  5
17:42:28 <bd_> like*
17:42:32 <newsham> > let f d [] = d; f d (x:[]) = x; f d (_:xs) = f d xs in f 0 (undefined : undefined : undefined : [])
17:42:34 <lambdabot>  Undefined
17:42:43 <Sgeo> space leaks?
17:42:55 <newsham> the "undefined" werent needed because we only used (_:xs) if xs wasnt []
17:42:59 <sorear> bd_: ..."or the link"
17:43:03 <sorear> bd_: confirm?
17:43:08 <bd_> 20:40 < bd_> like*
17:43:32 <BRS_Runaro> Hah. There's an actual legal case on record "Noble State v. Haskell"
17:43:39 * Sgeo hits self for not noticing bd_ in here >.>
17:43:50 <Sgeo> It's a bd_! No bd_!
17:44:10 <bd_> Sgeo: space leaks are when unevaluated thunks end up using more ram than you like. For example, sp l = (sum l, product l). If you do sp (verylonglist), store its result, then examine the first element of the pair, it'll keep around verylonglist for the product later.
17:44:34 <bd_> You can fix this by using seq: sp l = s `seq` p `seq` (s, p) where (s, p) = (sum l, product l)
17:44:59 * Sgeo brainsplodes
17:45:08 <bd_> heh
17:45:22 <bd_> all it does is says that, you must compute s and p before returning (s, p)
17:45:27 <bd_> otherwise for example:
17:45:28 <SamB_XP> @quote splode
17:45:29 <lambdabot> No quotes match. Wrong!  You cheating scum!
17:45:31 <bd_> fst $ sp [1..10000]'
17:45:35 <bd_> or rather
17:45:37 <SamB_XP> @quote .splode
17:45:38 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:45:46 <SamB_XP> @quote .plode
17:45:47 <lambdabot> ghc says: My brain just exploded.
17:45:49 <bd_> bind (s, p) = sp [1..10000]
17:45:49 <SamB_XP> @quote .plode
17:45:50 <lambdabot> procyon_ says: Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head
17:45:50 <lambdabot> exploded out of sheer amazement.
17:45:53 <bd_> then do something with s
17:46:08 <bd_> now p = (product [1..10000]) - except [1..10000] is represented as a list of all 10,000 elements :)
17:46:26 <SamB_XP> @quote .plode
17:46:27 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
17:46:30 <bd_> but if we use seq to force it, then the moment you break open that pair, p is replaced with the product as well.
17:46:50 <bd_> Actually it could be a bit more efficient - in the above we still need to keep the list around to compute the product the first time
17:46:56 <lispy> ?quote xml
17:46:57 <lambdabot> mwc says: XML is like violence. If it doesn't work, use more.
17:47:00 <bd_> you'd need to do your own fold to fix that :)
17:47:09 <tessier> That quote has made me famous.
17:47:18 <tessier> That quote is why I get all the chicks.
17:47:27 <lispy> tessier: wow
17:47:37 <lispy> ?quote chicks
17:47:38 <lambdabot> Korollary says: [On Perelman going AWOL before the Fields Medal award] I can have it if he doesnt want it. Chicks dig Fields Medals
17:47:59 <SamB_XP> ?quote chicks
17:47:59 <lambdabot> Korollary says: [On Perelman going AWOL before the Fields Medal award] I can have it if he doesnt want it. Chicks dig Fields Medals
17:48:18 <SamB_XP> @quote
17:48:19 <lambdabot> dmwit says: Curiously, the ellipsis is immune to relativistic effects.
17:48:34 <olsner> @quote ellipsis
17:48:34 <lambdabot> dmwit says: Curiously, the ellipsis is immune to relativistic effects.
17:49:16 <QtPlatypus> Are there any modern homoiconic functional lanauges?
17:49:38 <kc5tja> @dict homoiconic
17:49:39 <lambdabot> Supported dictionary-lookup commands:
17:49:39 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:49:39 <lambdabot> Use "dict-help [cmd...]" for more.
17:49:47 <kc5tja> @foldoc homoiconic
17:49:49 <lambdabot> No match for "homoiconic".
17:50:04 <kc5tja> @wn homoiconic
17:50:05 <lambdabot> No match for "homoiconic".
17:50:13 <SamB_XP> @go "homoiconic"
17:50:15 <lambdabot> http://en.wikipedia.org/wiki/Homoiconic
17:50:16 <lambdabot> Title: Homoiconicity - Wikipedia, the free encyclopedia
17:50:32 <tessier> A homo language? #perl is right that way ->
17:50:51 <kc5tja> SamB_XP: I just googled.  I've never seen that term before.
17:51:01 <tessier> Actually #php is probably the more homo language. Perl isn't bad.
17:51:02 <kc5tja> QtPlatypus: I think Scheme is as modern as they get.
17:51:21 <tessier> kc5tja: Hey, there's nothing homo about scheme
17:51:23 <SamB_XP> you mean scheme?
17:51:25 <kc5tja> Since PHP and Perl look absolutely identicall . . .
17:51:47 <SamB_XP> kc5tja: I think perl has better semantics
17:51:50 * QtPlatypus nods "So nothing lazy or Strongly typed?"
17:52:40 <SamB_XP> maybe lambda calculus ;-P
17:52:42 <QtPlatypus> kc5tja: Only on the serface, PHP has alot of uglyness that makes Perl look pritty in comparison.
17:52:48 <olsner> @lojban monad
17:52:51 <lambdabot> Error: 501 Syntax error, illegal parameters
17:53:17 <SamB_XP> whoohoo for strange HTTP errors
17:53:24 <olsner> ... apparently, monads aren't not logical enough for lojban
17:53:32 <SamB_XP> @lojban hello
17:53:34 <lambdabot> Error: 501 Syntax error, illegal parameters
17:53:37 <kc5tja> tessier: It's homoiconic.
17:53:38 <Sgeo> @lojban
17:53:45 <SamB_XP> apparantly @lojban is broken
17:53:51 <olsner> indeed
17:54:09 <ddarius> Joy is newer and homoiconic (a property that I find misnamed/misdescribed/ridiculous)
17:54:45 <QtPlatypus> What better name would you use?
17:55:32 <SamB_XP> hmm. I don't think XSLT should count.
17:55:34 <ddarius> I wouldn't.
17:55:44 <SamB_XP> it hides so much in strings.
17:55:54 <SamB_XP> or SmallTalk...
17:57:08 <desp> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls -- coolness
17:57:11 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki, http://tinyurl.com/238y2c
17:57:46 <ddarius> desp: Now do a site search of LtU for each of them and add links to any decent posts about them.
17:58:16 * desp disappears in a puff of logic
17:58:38 * ddarius pulls out a broom and sweeps up the puffs of logic lying about.
17:58:51 <tessier> I need to learn more about XSLT.
17:58:57 <kc5tja> Joy actually is not homoiconic.
17:58:58 <SamB_XP> why doesn't that page list the month?
17:59:04 <desp> tessier: it hurts
17:59:07 <kc5tja> Definitions rely on infix notation (procedure == definition)
17:59:31 <ddarius> kc5tja: Yeah, I don't like that, but that's easy enough to ignore and/or get rid of.
17:59:33 <SamB_XP> kc5tja: so?
18:00:24 <kc5tja> A homoiconic language is one that can be expressed in the same externalized representation as its internal data structure.  Infix equation operators != stack notation.
18:01:34 <SamB_XP> ah.
18:02:18 * kc5tja brought this up before on the concatenative list once, and got into such a HUGE fight over it with Manfred (inventor of Joy) that I ended up leaving the list.
18:02:23 <kc5tja> My idea was simple enough.
18:02:29 <kc5tja> definition --> name
18:02:51 <kc5tja> How much simpler can it get?  But, alas, it was burned at the stake with me as the coals.
18:03:15 <SamB_XP> it *is* the stake
18:03:25 <dmead> >lisftM2 (,) [1..3] [1..3]
18:03:29 <dmead> >liftM2 (,) [1..3] [1..3]
18:03:33 <dmead> > liftM2 (,) [1..3] [1..3]
18:03:35 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:04:02 <int-e> > (,) <$> [1..3] <*> [1..3]
18:04:04 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:04:23 <dmead> :o
18:04:52 <SamB_XP> @type <$>
18:04:54 <lambdabot> parse error on input `<$>'
18:05:04 <SamB_XP> @type (<$>)
18:05:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:05:42 <ddarius> kc5tja: What was his issue with it?
18:06:29 <int-e> @type (<*>)
18:06:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:06:41 <dolio> > getZipList $ (,) <$> ZipList [1..5] <*> ZipList [6..10]
18:06:43 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
18:06:59 <kc5tja> It's been years ago, so I don't remember exactly.  But, it has to do with something like, "Joy is a pure functional language, and as a result, cannot modify any state, including its own.  Therefore, -->, being an operator that modifies its own environment's state, is not allowed, and therefore you pretty much can go to hell and suck it.  Have a nice day."
18:07:10 <kc5tja> That's a polite summary of the vitriol I got back from him.
18:07:19 <chessguy> ?hoogle ZipList
18:07:20 <lambdabot> No matches found
18:07:22 <kc5tja> And that's why, to this day, I refuse to join the concatenative mailing list.
18:07:55 <byteshack> hello all
18:08:22 <byteshack> can someone help me understand what the "Ord a" means in empty :: Ord a => Int -> StackSet a
18:08:30 <ddarius> kc5tja: I can see what he's saying.  The natural thing to add it would be like postscripts dictionary mutation, but that doesn't go with Joy's philosophy.
18:08:53 <dons> byteshack: it means  that any type 'a' you use with 'empty', must be an instance of the Ord class
18:08:54 <byteshack> that's from the xmonad code, and I still can't seem to wrap my brain around some things in hs (as can be easily shown)
18:08:56 <dons> ?src Ord
18:08:57 <lambdabot> class  (Eq a) => Ord a  where
18:08:57 <lambdabot>     compare      :: a -> a -> Ordering
18:08:57 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:08:57 <lambdabot>     max, min         :: a -> a -> a
18:08:58 <ddarius> @google Gentle Introduction to Haskell
18:09:00 <lambdabot> http://www.haskell.org/tutorial/
18:09:00 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
18:09:07 <syntaxfree> the wikipedia article on Hoare is incredibly bad.
18:09:13 <syntaxfree> http://en.wikiquote.org/wiki/C._A._R._Hoare
18:09:18 <syntaxfree> ohj. that's wikiquote. nevermind.
18:09:25 <dons> byteshack: that is, all elements of stackSet must implement Ord as well, to provide effiicient lookups from a tree
18:09:50 <ddarius> "probably best known for the development of Quicksort" ...
18:10:00 <byteshack> and Ord meaning that you have to be able to "sort" them?
18:10:08 * ddarius knows of Tony Hoare for several reasons, that not among them.
18:10:11 <dons> meaning you have to be able to compare them.
18:10:21 <dons> you have to provide (<), (<=), (>), (>=) :: a -> a -> Bool
18:10:22 <dons> for the type.
18:10:33 <SamB_XP> ddarius: that doesn't mean he isn't best known for that ;-P
18:10:34 <dons> its like one step up from Eq
18:11:02 <syntaxfree> byteshack: try using @info on lambdabot or :instances in GHCi
18:11:05 <syntaxfree> @info Ord
18:11:06 <lambdabot> Ord
18:11:12 <SamB_XP> @info is not here anymore
18:11:12 <ddarius> No, it doesn't.  But I don't consider myself particularly sheltered in that regard, so it's odd that that's totally not what I associate with hem.
18:11:13 <lambdabot> is not here anymore
18:11:14 <dons> things you don't see everyday : "I think the key hook that allowed me to pass interview #2 was that I put the word ?Haskell? on my
18:11:17 <dons> resume."
18:11:18 <syntaxfree> not :instances, :info itself.
18:11:39 <notsmack> dons: is there going to be a part 2 to the xmonad tutorial?
18:11:42 <dons> other people here might consider this, http://pshaw.wordpress.com/2007/05/07/status-update/
18:11:44 <lambdabot> Title: Status Update  Nickel Raman Noodles
18:11:47 <dons> notsmack: there sure is.
18:11:49 <SamB_XP> dons: it works better if you use the right encoding
18:11:52 <dons> it just takes a while to write.
18:12:05 <dons> ?slap SamB_XP
18:12:05 <lambdabot> why on earth would I slap SamB_XP
18:12:25 <dons> notsmack: i'm off on vacation tomorrow, i hope to write the next 2 editions then
18:12:32 <byteshack> that xmonad tutorial is nice, it sure helps when you have code explained to learn a lang
18:12:42 <dons> cool
18:12:51 <dons> you learning Haskell by reading the xmonad source?
18:13:05 <byteshack> I'm learning more about haskell
18:13:16 <dons> xmonad can't hurt, I think.
18:13:28 <byteshack> I sure hope not ;)
18:13:53 <SamB_XP> its awful tiny to hurt
18:14:12 <syntaxfree> reading thesource to the standard libraries would be more productive, I reckon.
18:14:25 <SamB_XP> perhaps.
18:14:27 <ddarius> syntaxfree: It depends on which sources...
18:14:41 <cconnett> hey room, semi-newbie question: is there a reason for a where clause to not work inside a do block?
18:14:44 <SamB_XP> probably the report would be the best place to read them?
18:14:58 <dons> cconnett: you can only hang them off  the end of the block
18:15:01 <SamB_XP> cconnett: they only work with bindings
18:15:06 <SamB_XP> and cases
18:15:11 <SamB_XP> Er.
18:15:16 <byteshack> syntaxfree: that has helped too, but its a bit harder to see usefulness, I guess
18:15:16 <SamB_XP> cases, I guess.
18:15:17 <ddarius> Sam_XP: Yes.
18:15:19 <syntaxfree> the Prelude, the Data>* hierarchy.
18:15:19 <SamB_XP> two kinds!
18:15:22 <ddarius> Mostly.
18:15:36 <cconnett> hmm, i'm getting a scoping error that isn't making sense
18:15:46 <SamB_XP> basically wherever guards are allowed...
18:15:56 <cconnett> the where is at the end of the block
18:16:03 * Sgeo wonders if Just Right is useful in anything other than bad puns..
18:16:07 <cconnett> attached to the last expression
18:16:08 * ddarius doesn't think he's ever seen a where in a case statement.
18:16:22 <hpaste>  cconnett pasted "do and where" at http://hpaste.org/1751
18:16:27 <syntaxfree> http://en.wikipedia.org/wiki/Chinese_BASIC
18:16:28 <lambdabot> Title: Chinese BASIC - Wikipedia, the free encyclopedia
18:16:42 <dons> > Just . Right $ "NOW"
18:16:50 <ddarius> where is not an expression
18:16:57 <lambdabot>  thread killed
18:17:03 <dons> cute.
18:17:05 <cconnett> hmm
18:17:07 <dmead> ?src search
18:17:08 <lambdabot> Source not found. You type like i drive.
18:17:11 <dmead> ?src find
18:17:12 <lambdabot> find p          = listToMaybe . filter p
18:17:24 <Sgeo> > show (Just . Right $ "NOW")
18:17:28 <int-e> > Just Right <*> Just "NOW"
18:17:34 <dmead> > find 1 [1..2]
18:17:35 <lambdabot>   add an instance declaration for (Num (a -> Bool))
18:17:39 <Sgeo> What's <*>?
18:17:39 <lambdabot>  thread killed
18:17:40 <dons> the machine is realy slow. hang on.. something fishy...
18:17:44 <lambdabot>  thread killed
18:18:02 <ddarius> @flush ?
18:18:02 <lambdabot> Not enough privileges
18:18:12 <dolio> <*> is ap.
18:18:13 <Sgeo> @t <*>
18:18:14 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:18:19 <cconnett> so do i have to put those defs in let statements before the last expression?
18:18:20 <Sgeo> @t (<*>)
18:18:20 <phoniq> @botsnack
18:18:21 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
18:18:21 <lambdabot> :)
18:18:29 <Sgeo> dolio, hm?
18:18:30 <dmwit> :t (<*>)
18:18:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:18:38 <int-e> Sgeo: a Control.Applicative operator. For monads that are Applicative instances it's usually `ap`
18:18:40 <dolio> :t ap
18:18:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:18:49 * Sgeo mindsplodes again
18:18:57 <dons> > 1+2
18:19:01 <dolio> Yeah, <*> has a more general type.
18:19:13 <lambdabot>  thread killed
18:19:13 <dons> it really weird how @eval starts failing randomly
18:19:34 <Sgeo> > show $ Left "Left"
18:19:36 <int-e> maybe there's not enough cpu time to finish the compilation in 3 seconds?
18:19:47 <dons> its something to do with that, yes.
18:19:50 <lambdabot>  thread killed
18:19:56 <ddarius> Sgeo: Monad => Applicative Applicative =/=> Monad
18:20:41 <dons> > 1+2
18:20:55 <dons> nope.
18:20:57 <lambdabot>  thread killed
18:21:00 <int-e> Prelude Control.Applicative> Just Right <*> Just "NOW" ===> Just (Right "NOW")
18:21:25 <cconnett> i think i got it now, thanks all
18:21:32 <int-e> is there a flipped version of <$>? hmm.
18:21:53 <Sgeo> flip ($) ?
18:22:08 <ddarius> sorear likes to call it (>>$)
18:22:31 <EvilTerran> I tend to call it ($>)
18:22:33 <davidL> ?nazi-on
18:22:33 <lambdabot> Not enough privileges
18:22:52 <Sgeo> Can it be called (flip ($))?
18:23:03 <dons> > 1+2
18:23:04 <int-e> I mean something of type  Applicative f => f (a -> b) -> a -> f b
18:23:04 <lambdabot>  3
18:23:09 <EvilTerran> well, yes, but not infix
18:23:22 <kc5tja> ddarius: Yeah, I know what he's saying, and I agree that it's true.  But nothing stops --> from being a compiler directive.  And, I'm wondering how possible it'd be to express the dictionary as some kind of monad which --> uses to affect its state?  :)
18:23:28 <dons> it does seem to be related to loads and timeouts, int-e
18:23:33 <kc5tja> Anyway, I gotta get home.  Have a flat on my bike to replace still.
18:23:43 <dons> and if it times out, it leaves a ghc process forked, which goes a bit nuts
18:23:46 <ddarius> kc5tja: I agree with the compiler directive part or just syntax.
18:23:49 <dons> leading to more time outs..
18:24:05 <kc5tja> ddarius: It's just that he could have been more civil.
18:24:07 * kc5tja shrugs.
18:24:11 <kc5tja> Anyway, I'm out.
18:24:18 <ddarius> See ya.
18:24:39 <EvilTerran> int-e, oh, you mean a flipped version of (<$>) rather than a flipped version of ($)... my bad.
18:24:58 <Sgeo> What's <$>?
18:25:01 <int-e> it's not exactly flipped either.
18:25:03 <int-e> Sgeo: fmap
18:25:04 <Sgeo> What's with the <> things?
18:25:37 <int-e> Sgeo: read the functional pearl on Applicative Programming with Effects
18:25:40 <EvilTerran> they're Control.Applicative related
18:25:59 <Sgeo> I'd like my brain to remain intact, actually...
18:26:00 <Sgeo> >.>
18:26:05 <sjanssen> @keal
18:26:05 <lambdabot> doctor just give meds not fix prollem
18:26:06 <int-e> Sgeo: you did ask though
18:26:58 <syntaxfree> ?protontorpedo
18:26:59 <lambdabot> that dude is selling u  a book
18:27:03 <ddarius> Sgeo: If you understand Monads, Applicative should be no problem.
18:27:10 <int-e> @index (>.>)
18:27:11 <lambdabot> bzzt
18:27:35 <ozzilee> Can someone tell me how to load a module like Data.HashTable into GHCi?
18:27:57 <int-e> :m +Data.HashTable
18:28:02 <dolio> Sgeo: The original paper has nicer looking operators, since it uses latex.
18:28:10 <dolio> Sgeo: Those are rough ascii equivalents.
18:29:21 <ozzilee> Ah ok. Is there a way to "import qualified" so I can play with other modules at the same time?
18:29:48 <int-e> ozzilee: no. you can write your own module that does it for you and :load that though
18:30:14 <ozzilee> Ok, thanks.
18:30:50 <dolio> Although I guess it doesn't actually have a nicer fmap.
18:40:48 <Sgeo> @src uncurry
18:40:49 <lambdabot> uncurry f p = f (fst p) (snd p)
18:41:07 <Sgeo> @src either
18:41:08 <lambdabot> either f _ (Left x)     =  f x
18:41:08 <lambdabot> either _ g (Right y)    =  g y
18:41:17 <ddarius> or uncurry f ~(x,y) = f x y
18:41:27 <Sgeo> ~?
18:42:01 <ddarius> It makes it an irrefutable ("lazy") pattern match, i.e. it doesn't actually perform the match until one of the components is needed.
18:42:16 <ddarius> > "working"?
18:42:17 <lambdabot>  Parse error
18:42:19 <ddarius> > "working"
18:42:22 <Sgeo> Why is that needed?
18:42:35 <lambdabot>  thread killed
18:43:09 <ddarius> Sgeo: Otherwise the uncurried version would be stricter than the curried version.
18:43:37 <ddarius> Or maybe not, it's slightly weird.
18:44:16 <ddarius> At any rate, this version is lazier than without the ~ and equivalent to the one using fst and snd.
18:45:03 <ddarius> The important part is probably having curry . uncurry = id and uncurry . curry = id
18:45:22 <Sgeo> How is import used?
18:45:42 <ddarius> Sgeo: The simplest version is: import ModuleName.
18:45:52 <ddarius> (Uh, not counting the period)
18:46:37 <Sgeo> How specific do I have to be?
18:46:49 <ddarius> Sgeo: You have to give the full name of the module.
18:47:10 <Sgeo> I'd have to import, e.g. Data.Unique and Data.Version separately/
18:47:48 <ddarius> Yes, you can't do import Data in general.  Often times, there are higher level modules that re-export the functions of several lower level ones.
18:49:07 <ddarius> However, the higher level modules can re-export anything (they are just normal modules and as such don't even need to be there, e.g. there is no Data module), and usually they shape the interface.
19:07:39 <sphynx> I'm reading paper "Tutorial on the universality and expressiveness of fold" by Hutton, it's quite interesting! Does someone use in practice universal property of fold to produce fold representations of functions in fold-way?
19:10:39 <sphynx> also I've read about tupling technique and it seems that I've understood how to use it, but I haven't got why such happens - why adding argument as second in tuple - makes possible to represent any function in fold-way.
19:11:51 <monochrom> use the second component as state. throw it away at the end.
19:12:14 <kc5tja> Anyone know of a good wav file recorder for Linux?  I need to make a custom (louder) Ring tone for skype, since I'm going to be outside most of today.
19:13:06 <desp> kc5tja: I highly recommend http://desp.night.pl/tmp/alarm.wav
19:13:14 <olsner> 'sox' can do anything
19:13:36 <desp> (that's my alarm clock sound)
19:15:06 <wy> augustss: Are you here?
19:15:06 <kc5tja> desp: PERFECT!!!  Thank you!
19:15:12 <desp> :)
19:18:48 <chessguy> ?time desp
19:18:49 <lambdabot> Local time for desp is Tue May  8 04:17:10 2007
19:21:17 <desp> chessguy: hmm?
19:24:55 <dmwit> "The debugger can now log each step of the evaluation without actually stopping, keeping a history of the recent steps."
19:25:00 <dmwit> This means we can TRAVEL IN TIME?
19:25:29 <monochrom> This means it blogs.
19:25:47 <dmwit> heh
19:25:59 <chessguy> @quote travel
19:26:00 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
19:26:00 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
19:26:13 <Sgeo> I'm... dreaming of a isBottom::a->Bool...
19:26:43 <dolio> @type let isBottom a = True in isBottom
19:26:44 <dmwit> Sgeo: Step one is solving the halting problem.
19:26:46 <lambdabot> forall t. t -> Bool
19:26:56 <dolio> :)
19:27:09 <dmwit> Sgeo: Or don't you need it to return? ;-)
19:27:25 <dmwit> dolio: Surely it's isBottom a = False...
19:27:30 * Sgeo needs it to return always >.>
19:27:56 <Sgeo> i.e. please solve the halting problem for me, kthx
19:28:03 <dolio> dmwit: They seem equally useful to me.
19:28:13 <dmwit> Fair enough.
19:28:19 <monochrom> \x -> unsafePerformIO ((evaluate x >> return False) `catch` (\_ -> return True))
19:28:30 <Sgeo> ??
19:28:41 <monochrom> It works if there is an "infinite loop exception"
19:28:52 <Sgeo> Infinite loop exception?
19:29:05 * Sgeo mindsplodes
19:29:28 <dolio> dmwit: 'isBottom a = a `seq` False' might actually be a better approximation.
19:30:00 <Sgeo> monochrom, oh, a hypothetical exception..
19:30:03 * Sgeo slaps self
19:30:22 <Sgeo> Hi xwl
19:30:39 <dmwit> > let foo = show foo in foo -- how does it go? something like this...
19:30:41 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:30:48 <dmwit> ...
19:30:53 <dmwit> That isn't a loop exception.
19:31:17 <dolio> > let a = a in a
19:31:19 <lambdabot>  Exception: <<loop>>
19:32:09 <jcreigh> well, lambdabot just does take 80 $ show (your expression)
19:32:30 * monochrom trolls the channel
19:32:41 <monochrom> No one can stop me. You're opless!
19:32:44 <jcreigh> (I don't know what the exact number is, probably not 80)
19:32:44 <jcreigh> so for strings, you can get that far without hitting bottom
19:33:19 <dolio> > replicate 80 'a' ++ [undefined]
19:33:20 <monochrom> How do you use unsafePrformIO to implement web apps in haskell?
19:33:21 <lambdabot>  Undefined
19:33:34 <dolio> > replicate 100 'a' ++ [undefined]
19:33:36 <lambdabot>  Undefined
19:33:58 <monochrom> i heard it cant be don
19:33:58 --- mode: irc.freenode.net set +o ChanServ
19:34:06 <monochrom> oops, nvm
19:34:07 <dmwit> > repeat 'a'
19:34:09 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:34:11 --- mode: ChanServ set +o dons
19:34:14 <chessguy> @v
19:34:15 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
19:34:22 <dmwit> > length "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
19:34:24 <lambdabot>  75
19:34:36 <dolio> @fact chessguy
19:34:37 <lambdabot> chessguy: is not cheeseguy
19:34:39 <littledan> > length repeat 'a'
19:34:40 <lambdabot>  Couldn't match expected type `[a]'
19:34:45 <littledan> length $ repeat 'a'
19:34:48 --- mode: ChanServ set -o dons
19:34:51 <littledan> > length $ repeat 'a'
19:34:54 <chessguy> @help fact
19:34:55 <lambdabot> fact <fact>, Retrieve a fact from the database
19:34:57 <dmwit> Doesn't work...
19:34:57 <lambdabot> Terminated
19:34:59 <chessguy> @fact dons
19:34:59 <ray> ooh, repeat is cool
19:34:59 <lambdabot> I know nothing about dons
19:35:10 <desp> @fact oleg
19:35:10 <lambdabot> I know nothing about oleg
19:35:13 <lispy> ray: try this one:
19:35:15 <jcreigh> As a wild guess, I'd say it truncates at 75 and adds an ellipsis... :)
19:35:15 <chessguy> @fact
19:35:16 <lambdabot> I can not handle empty facts.
19:35:18 <lispy> > fix show
19:35:20 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:35:23 <dolio> The list of facts isn't very long.
19:35:30 <littledan> @fact haskell
19:35:31 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
19:35:34 <desp> @quote olegfact
19:35:35 <lambdabot> No quotes match. Are you on drugs?
19:35:36 <ray> nice
19:35:42 <dolio> @fact hsu
19:35:43 <lambdabot> hsu: I know nothing about Haskell Secret Underground.
19:35:44 <lispy> :t fix
19:35:45 <chessguy> @fact fact
19:35:45 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
19:35:46 <lambdabot> forall a. (a -> a) -> a
19:36:01 <dmwit> ?src fix
19:36:02 <lambdabot> fix f = let x = f x in x
19:36:23 <dmwit> How does it seed f?  That's kind of mind-blowing to me.
19:36:32 <chessguy> ?src fix
19:36:32 <lambdabot> fix f = let x = f x in x
19:36:56 <olsner> @hoogle [a] -> Int -> [a]
19:36:57 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
19:36:57 <lambdabot> Prelude.take :: Int -> [a] -> [a]
19:36:57 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
19:37:14 <dolio> I'm not sure it seeds it, per se. It has to do with evaluation order.
19:37:16 <ddarius> dmwit: It seeds it with a thunk that will evaluate to f x
19:37:40 <sorear> .
19:37:42 <Sgeo> @fact Goldilocks
19:37:42 <lambdabot> I know nothing about goldilocks
19:37:53 <ddarius> sorear: Stack Empty!
19:37:58 <sorear> Why don't you just read the database?
19:38:09 <sorear> Why must you interrogate it blindly?
19:39:01 <monochrom> wo ist dein database?
19:39:08 <Sgeo> @list
19:39:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:39:15 <monochrom> err "dein" is wrong...
19:39:21 <ray> ou est le database
19:39:22 <ddarius> monochrom: I was about to say.
19:39:28 <dmwit> ?where state
19:39:28 <lambdabot> I know nothing about state.
19:39:32 <ddarius> Presumably it is "das"
19:39:35 <dmwit> ?where lambdabotstate
19:39:35 <lambdabot> I know nothing about lambdabotstate.
19:39:47 <Sgeo> #fact-set
19:39:49 <Sgeo> @fact-set
19:39:50 <lambdabot> I can not handle empty facts.
19:39:59 <Sgeo> @help fact-set
19:40:00 <lambdabot> Define a new fact, guard if exists
19:40:00 <ddarius> But who knows, perhaps the Germans have met a male or female database.
19:40:19 <monochrom> yeah.  I learned German from A German Requiem.  "Tod, wo ist dein Stachel?"  The "dein" is hardcoded to my brain...
19:40:28 <Sgeo> @quote Sgeo
19:40:29 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:40:34 <desp> "dein database" would mean "your database"
19:40:42 <Sgeo> @fact-set Goldilocks: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:40:43 <lambdabot> Fact recorded.
19:40:48 <Sgeo> @fact Goldilocks
19:40:49 <lambdabot> I know nothing about goldilocks
19:40:53 <Sgeo> @fact Goldilocks:
19:40:54 <lambdabot> goldilocks:: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:40:57 <desp> @quote oleg
19:40:57 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
19:40:57 <Sgeo> meh
19:41:02 <desp> @quote oleg
19:41:02 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
19:41:03 <Sgeo> how do I fix that?
19:41:29 <Sgeo> @fact-delete goldilocks:
19:41:30 <lambdabot> Fact deleted.
19:41:35 <desp> @quote oleg
19:41:35 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
19:41:37 <desp> meh
19:41:38 <Sgeo> @fact-set Goldilocks What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:41:38 <lambdabot> Fact recorded.
19:41:44 <Sgeo> @fact goldilocks
19:41:45 <lambdabot> goldilocks: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
19:41:55 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/fact
19:41:59 <sorear> @ignore + Sgeo
19:42:02 <Sgeo> ..
19:42:07 <SamB> @fact hex
19:42:08 <lambdabot> I know nothing about hex
19:42:11 <lispy> don't forget that you can /msg lambdabot
19:42:13 <SamB> @quote hex
19:42:14 <lambdabot> hex says: 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
19:42:18 <desp> ah
19:42:22 <SamB> @fact-set hex 09 F9 11 02 9D 74 E3 5B D8 41 56 C5 63 56 88 C0
19:42:22 <lambdabot> Fact recorded.
19:42:32 <ray> sorear: 404
19:42:33 <Sgeo> sorear, 404
19:42:38 <ray> silly dons
19:42:50 <sorear> try deleting www then
19:42:58 <sorear> also try cgi
19:44:06 <sorear> dons!!
19:44:31 <lispy> ya know, i don't get the subject line...what does it mean? summon iron coder functional?
19:44:50 <ddarius> Supposedly a reference to Iron Chef
19:44:55 <desp> probably a quote from a japanese cartoon
19:45:14 * lispy thinks for a minute
19:45:19 <lispy> ddarius: was iron chef something on tv?
19:45:21 <dons> sorear: ?
19:45:32 <ddarius> lispy: It was on cable.
19:45:34 <desp> "battle programmer shirase"
19:45:39 <sorear> dons: rerun your linkchecker - the lambdabot repo you link doesn't exist
19:45:44 <ddarius> "is" I'm pretty sure
19:45:50 <dons> a reference to Iron Chef, in a recent blog post.
19:46:04 <dons> and that #haskell is the source for Iron Chef "Functional"
19:46:21 <lispy> huh....okay :)
19:46:35 <dons> lispy: you know the show?
19:46:39 * ddarius has only seen like an episode or two of Iron Chef.
19:46:54 <dons> samurai chefs, each masters in a different style, battle each other
19:47:05 <dons> s/chefs/hackers/
19:47:27 <lispy> ah
19:47:33 <lispy> sounds exotic
19:47:46 <dons> it's brilliant
19:47:50 <lispy> i live under a rock with no TV
19:48:06 * ddarius lives on a rock and chooses not to watch TV.
19:48:12 <dmwit> ooo unfoldr you're so hott
19:48:24 <ddarius> @google Underappreciated unfold
19:48:27 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/
19:48:27 <lambdabot> Title: Jeremy Gibbons' Publications
19:48:27 <lispy> unfoldr makes my brain hurt :)
19:48:34 <ddarius> More Gibbons.
19:48:40 <dons> lispy: http://images.dawgsports.com/images/admin/Iron_Chef.gif
19:48:45 <ddarius> unfoldr?
19:49:24 <lispy> :t unfoldr
19:49:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:49:47 <dmead> why does ghci freak out when i try and show a list of tuples?
19:49:59 <syntaxfree> ?protontorpedo
19:50:00 <lambdabot> is functional progrmaming the same as object oriented?
19:50:03 <lispy> > unfoldr (\b -> Just (1, b)) (Just 2)
19:50:16 <ddarius> "Towards a colimit-based semanticns for visual programming".  Colimits! Just what visual programming needed.
19:50:18 <lambdabot>  thread killed
19:50:19 <gmh33> ?protontorpedo
19:50:19 <jcreigh> dmead: it shouldn't. What are you trying to do?
19:50:19 <lambdabot> is haskell able to outdo perl or python for web?
19:50:20 <dons> unfoldr is the essence of functional programming with lists :-)
19:50:31 <chessguy> > zip [1..100] [1..100]
19:50:42 <dmead> just returing a list of types of a datatype
19:50:46 <lambdabot>  thread killed
19:50:46 <dons> silly bot.
19:50:47 <dmead> =/
19:50:49 <littledan> dmead, are your tuples all the same type? They have to be the same length and have the same thing in corresponding spots
19:50:57 <dmead> they are
19:50:58 <dons> its weird. this error comes and goes.
19:51:02 <lispy> > unfoldr (\b -> Nothing) (Just 2)
19:51:04 <syntaxfree> > zip [1..5] [1..5]
19:51:05 <ddarius> Is it bad when I can immediately see how colimits -would- apply to visual programming?
19:51:08 <chessguy> > zip [1..10] [1..10]
19:51:18 <lambdabot>  thread killed
19:51:19 <syntaxfree> > zip [1..5] [1..5]
19:51:20 <lambdabot>  thread killed
19:51:22 <lambdabot>  ghc: failed with error code 9
19:51:22 <lambdabot>  ghc: failed with error code 9
19:51:26 <chessguy> what the heck
19:51:27 <littledan> dmead, it works for me
19:51:30 <lispy> ooo, not error code 9
19:51:42 <littledan> dmead, what is your code?
19:51:43 <chessguy> @slap lambdabot
19:51:43 * lambdabot beats up lambdabot
19:51:46 <dons> > 1+2
19:52:01 <lambdabot>  thread killed
19:52:05 <dons> i really hate this non-deterministic load-based scary error
19:52:17 <syntaxfree> @pl f x = g x x
19:52:18 <lambdabot> f = join g
19:52:41 <syntaxfree> > map (join (,)) [1..5]
19:52:45 <sorear> dons: where is the lambdabot repo?
19:52:56 <lambdabot>  thread killed
19:53:04 <ddarius> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#unfold
19:53:06 <lambdabot> Title: Jeremy Gibbons' Publications, http://tinyurl.com/y56qzx
19:53:08 <jcreigh> @where lambdabot
19:53:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:53:32 <sorear> jcreigh: Tried it already.
19:53:38 <syntaxfree> > 2
19:53:43 <sorear> jcreigh: that's why I need dons' input!
19:53:53 <lambdabot>  thread killed
19:53:55 <jcreigh> sorear: ah, I see
19:54:52 <ddarius> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#fission Newish and looks cool
19:54:55 <lambdabot> Title: Jeremy Gibbons' Publications, http://tinyurl.com/y56qzx
19:55:02 <dons> runplugs just forks, ghc doesn't return, things get loaded, it all turns nasty
19:55:13 <dons> ?version
19:55:13 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
19:55:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:55:24 <sorear> But ... why?
19:55:30 <dons> i don't know.
19:55:44 <dons> it happened on openbsd, it happened on linux. it went away for 2 weeks, now its back.
19:56:13 <dons> > 1+@
19:56:13 <lambdabot>  Parse error
19:56:15 <dons> > 1+2
19:56:16 <lambdabot>  3
19:56:28 <dons> so if I rebuild runplugs, all is good. for a while
19:56:34 <sorear> dons: do the ghc processes consume CPU?
19:56:34 <dons> super weird.
19:56:43 <dons> they sure do.
19:56:51 <dons> and when runplugs terminated, they stay running
19:56:52 <dons> and load goes up
19:57:08 <dons> there's a lot of runplugs zombies.
19:57:18 <dons> sorear: want to have to a look a zombieness?
19:57:28 <dons> maybe the wait code isn't working
19:57:37 <dmead> littledan: i think i got it, nm :P
19:58:07 <sorear> dons: if you gdb $GHC.BIN $PID , then ^C, what symbol does it give?
19:58:12 <dmead> Top level:
19:58:12 <dmead>     No instance for (Show ([(Parameter, Parameter)]
19:58:12 <dmead> 			   -> ([(Parameter, Parameter)], [Formula], Bool)))
19:58:12 <dmead>       arising from use of `print' at Top level
19:58:12 <dmead>     Probable fix:
19:58:13 <dmead>       add an instance declaration for (Show ([(Parameter, Parameter)]
19:58:15 <dmead> 					     -> ([(Parameter, Parameter)], [Formula], Bool)))
19:58:17 <dmead>     In a 'do' expression: print it
19:58:25 <dmead> > :<
19:58:25 <lambdabot>  Parse error
19:58:43 <jcreigh> dmead: you're trying to show a function
19:58:47 <dons> sorear: don't have any running forked ghc's yet.
19:58:52 <dons> i'll try it if it happens again
19:59:02 <dmead> oh
19:59:04 <sorear> Yay, I have more code online than dons!
19:59:11 <jcreigh> dmead: you're probably missing an argument somewhere
19:59:15 <lispy> what is the name of the database api which can type check your data accesses?
19:59:19 <dmead> right right
19:59:27 <dmead> ah yes
19:59:29 <lispy> is it haskelldb?
19:59:29 <dmead> your right
19:59:30 <dmead> thanks :)
19:59:40 <dmead> yep
19:59:41 <dmead> that did it
20:00:11 <Sgeo> Where's a tutorial on States?
20:00:22 <dons> on the State monad?
20:00:35 <dons> there's probably one in the haskell wikibook (see haskell.org)
20:00:52 <sorear> dons: ~dons/code doesn't exist!
20:01:03 <dons> hmm
20:01:28 <dons> ah yes. they're updating the file server
20:01:37 <sorear> *phew*
20:01:43 <dons> look up now.
20:02:29 <dons> it might not be responding though.
20:02:51 <dons> yes. things in the proxy will be there. anything else isn't available for a little while
20:03:05 <ddarius> "This whole area has been described as being 'about as easy as reconstructing a pig from sausage'."
20:03:26 <dons> nice.
20:05:10 * sorear has found the 65816 datasheet internallly inconsistant and is resorting to emulator source code as the final reference
20:05:33 * Sgeo reads http://en.wikibooks.org/wiki/Haskell/YAHT/Modules
20:05:40 <Sgeo> Should have read it a long time ago
20:05:41 <ddarius> "Indeed, as we shall see, it is even harder than that: a given sausage can have only one explanation, but a given program might have multiple explanations."
20:06:06 <jcreigh> the whole "functions cannot be shown" thing trips up so many people. Is there a chance the GHC people would accept a patch that imported Text.Show.Functions in ghci by default?
20:07:14 <Sgeo> Text.Show.Functions?
20:07:24 * Sgeo mindsplodes again
20:07:34 <jcreigh> instance Show (a -> a) where show _ = "<function>"
20:07:37 <jcreigh> nothing fancy.
20:07:42 <sorear> jcreigh: Better idea, we need sometihg like ANS-forth 'SEE'
20:07:51 <jcreigh> sorear: what's that?
20:07:57 <olsner> I'd like transparent decompilation
20:08:09 <dons> jcreigh: in ghci, yes, maybe.
20:08:12 <sorear> SEE :
20:08:12 <sorear> : :
20:08:12 <sorear>   header (:noname) ; ok
20:08:19 <jcreigh> dons: yeah, obviously not all the time
20:08:21 <littledan> sorear, I agree, I really miss see
20:08:21 <sorear> it decompiles from memory
20:08:22 <dons> jcreigh: anything we do in lambdabot is a possible candidate for ghci
20:08:25 <dons> > ord
20:08:26 <lambdabot>  <Char -> Int>
20:08:29 <Sgeo> What's see?
20:08:33 <dons> would be useful in ghci
20:08:51 <jcreigh> dons: my understanding is that the typable solution doesn't work for polymorphic functions?
20:08:55 <jcreigh> > fromEnum
20:08:56 <lambdabot>  Add a type signature
20:09:16 <sorear> http://www.taygeta.com/forth/dpans15.htm#15.6.1.2194
20:09:19 <lambdabot> Title: DPANS94
20:09:25 <sorear> Sgeo: ^^^
20:11:06 * kc5tja compiles code to actual 65816 machine language, so it's not practical to decompile the code in the sense that Smalltalk does.
20:11:21 <kc5tja> (If I'd used direct-threading instead of machine language, then I could more easily decompile)
20:11:45 <littledan> in Factor, a Forth-like language, functions are basically stored twice: as the AST (which is efficiently executable) and the compiled machine code. see just prints out the AST. I don't see why that should be difficult in Haskell
20:11:45 <sorear> kc5tja: You can still disassemble and perform reverse symbol lookups.
20:11:57 <kc5tja> However, Pygmy included a reference to the source block in which a definition was found, so you could SEE FOO and it'd open the editor with the block containing FOO.  Very convenient.
20:12:10 <littledan> it doesn't require any special sort of disassembly
20:12:20 <sorear> CODE :
20:12:21 <sorear>   jsr _colon
20:12:21 <sorear>   jsr header
20:12:21 <sorear>   jser _lp_cononame_rp
20:12:24 <sorear>   jsr _ses
20:12:27 <dons> so I'm going to start using Kant to back my static typing (a priori proof based on structure) versus testing (a posteriori checking) arguments. haha. reddit.
20:12:52 <littledan> dons, you want to depend on that hypocrite?
20:13:04 <dons> he's fine on judgements and proofs.
20:13:09 <kc5tja> littledan: Forth systems that use a RAFTS-like approach and also some Smalltalk systems do the same basic thing.
20:13:19 <littledan> RAFTS=?
20:13:51 <kc5tja> A proof of concept paper showing that Forth can be substantially better compiled on many-registered machines using static single-assignment form for an intermediate representation.
20:14:17 <kc5tja> @google RAFTS Forth
20:14:21 <lambdabot> http://www.complang.tuwien.ac.at/projects/rafts.html
20:14:21 <lambdabot> Title: Compilation of Stack-Based Languages
20:14:41 <sorear> kc5tja: what do TRB and TSB do?
20:14:51 <kc5tja> Test and Re(Set) Bits
20:14:52 <littledan> "Since February 1998, the project has stalled, but I expect to continue it some time in the future."
20:15:03 * olsner wants the new Heroes episode to be out now
20:15:18 <kc5tja> littledan: He doesn't need to anymore; commercial Forth implementations implement RAFTS-like compilers.
20:15:28 <littledan> oh
20:16:11 <kc5tja> SwiftForth, from Forth, Inc., produces code that can hold its own against MSVC with full optimizations.  Pretty dang impressive.  And iForth (Win32 and Linux) has some mighty impressive benchmarks too.
20:18:31 <nornagon> sorear: hey, can you tell me how to get a (framebuffered?) console that's bigger than 80x24? :)
20:19:21 <sorear> nornagon: yes, get a standard vga card
20:19:40 <sorear> nornagon: normal pc hardware doesn't support 80x24 text mode - only 80x25
20:20:02 <nornagon> Hm.
20:20:17 <nornagon> You're right.
20:20:17 <sorear> nornagon: I was using the sisfb and fbconsole modules - use fbset(1) to control resolution
20:20:29 <nornagon> Ah, nifty :) *apt-gets*
20:20:38 <SamB> there is a command to get a bigger textmode console
20:20:51 <SamB> ... but I can only remember how to do it in DOS :-(
20:20:55 <sorear> nornagon: obviously you shouldn't use sisfb unless SiS actually made your graphics card
20:20:59 <SamB> (mode ,50)
20:21:02 <kc5tja> The command in DOS definitely isn't the same in Linux.
20:21:06 <nornagon> yeah.
20:21:08 <SamB> I know that ;-P
20:21:09 <jcreigh> there's an option to the kernel to select a different textmode.
20:21:10 <nornagon> it's an nvidia card.
20:21:12 <jcreigh> (on linux)
20:21:16 <kc5tja> In Linux, you need to set the font to something like 8x8 pixels, and you'll get an 80x50 display.
20:21:34 <sorear> yes, but changing the hard resolution is nicer
20:21:38 <sorear> no tiny fonts
20:21:41 <nornagon> kc5tja: I've seen gentoo do magical framebuffery things like a background and stuff.
20:21:41 <olsner> there's SVGATextMode also, if you don't use the framebuffer drivers
20:22:08 <sorear> kc5tja: how accurate are the comments in lib65816?
20:22:19 <jcreigh> or you could just use xmonad and X11 :)
20:22:36 <kc5tja> sorear: Depends on the comments.  Most of the code predates my acquisition of the package.
20:22:42 <kc5tja> jcreigh: That's what I do.  :)
20:22:47 <nornagon> open /dev/fb0: No such file or directory :(
20:23:04 <kc5tja> nornagon: You're going to need to recompile the kernel with fbcon support enabled.
20:23:15 <kc5tja> fbcon is definitely not trivial.
20:23:18 <sorear> Debian kernels are compiled with fbcon!
20:23:22 <SamB> or use what olsner said...
20:23:29 <nornagon> eek
20:23:29 <kc5tja> Yeah, because fbcon isn't trivial.  :)
20:23:42 <nornagon> I did modprobe nvidiafb and now I can't see half my screen :/
20:24:03 <sorear> nornagon: hit enter a few dozen times
20:24:07 <nornagon> XD
20:24:21 <nornagon> nah, I did /clear and now I can see stuff in irssi, at least
20:24:46 <sorear> see, fbcon is trivial!
20:24:58 <nornagon> ah
20:25:01 <kc5tja> Well, I've never had much luck with it.
20:25:04 <nornagon> fbset -xres 1280 -yres 800
20:25:07 <nornagon> and, done. :D
20:25:10 <nornagon> neat :)
20:25:11 <kc5tja> In fact, I can't say I've had _any_ luck with it at all.
20:25:47 <nornagon> I wonder what'll happen if I start X.
20:25:55 <nornagon> (Also, how do I change the font?
20:25:55 <nornagon> )
20:26:04 <sorear> nornagon: SiSfb works fine with X
20:26:10 <sorear> nornagon: consolechars
20:26:24 <kc5tja> GoboLinux uses setfont.
20:26:26 <sorear> fbcon only supports 8-wide fonts, alas.
20:28:24 <nornagon> Alas. :(
20:29:11 <nornagon> hmph, startx reckons there's no such device when I try to start X. :(
20:29:26 <nornagon> ah.
20:29:35 <nornagon> modprobe nvidia tells me it does not agree with nvidiafb.
20:30:07 <nornagon> ERROR: Module nvidiafb is in use
20:30:10 <nornagon> Interesting!
20:31:08 <Sgeo> For States, it's import Data.STRef ?
20:31:12 <SamB> tdfxfb and tdfx have no such problems...
20:31:39 <jcreigh> does darcs make a separate HTTP request for each patch?
20:31:47 <Sgeo> um..
20:31:49 <Sgeo> n/m
20:31:53 * Sgeo still needs a tutorial
20:32:15 <monochrom> http://en.wikibooks.org/wiki/Haskell
20:32:17 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
20:32:40 <sorear> jcreigh: Yes!
20:33:03 <jcreigh> oh. Is somebody working on fixing that?
20:33:08 <sorear> Not afaik.
20:33:34 <Sgeo> monochrom, yes, now, if the page on States wasn't empty..
20:33:50 <sorear> I still think somebody who knows haskell should rewrite darcs.
20:34:19 <monochrom> http://en.wikibooks.org/wiki/Haskell/Understanding_monads#The_State_monad  is this empty?
20:34:24 <lambdabot> http://tinyurl.com/ewuzt
20:34:58 <dons> sorear: a year's work. better to get the algorithms right.
20:35:32 <jcreigh> but some thing like HTTP pipelining shouldn't be hard
20:35:52 <dons> yeah.
20:38:49 <jcreigh> or at least a persistent connection...
20:38:50 <jcreigh> hmm.
20:41:36 <nornagon> so, how does one view images without starting X? >.>
20:41:44 <nornagon> oh ah, cacaview.
20:41:51 <sorear> nornagon: I use fbi
20:42:16 * nornagon installs that too.
20:43:12 <sorear> btw I'm on day 2 of forcing myself to use X exclusively
20:43:43 <nornagon> XD
20:44:28 <cdsmith> sorear: are you allowing yourself to have only a single xterm running?
20:44:29 <dons> sorear: xmonad + nice xterm?
20:44:41 <dons> should make a reasonable console :-)
20:44:46 <dons> but with better fonts.
20:45:44 <sorear> xmonad + several xterms + emacs + xpdf
20:45:59 <sorear> and the fonts are rather worse
20:48:03 <sorear> kc5tja: are you busy, or is your client eating my /msg's?  (this only needs to be answered once)
20:48:04 <kilimanjaro> you can configure fonts
20:48:26 <sorear> kilimanjaro: every font in debian is as ugly is misc-fixed or worse
20:48:34 <sorear> s/y is/y as/
20:48:59 <fridim> I don't understand   data MyInt = MyInt Int; Why is it not  data MyInt = Int ?
20:49:15 <sorear> fridim: Because you need to name your constructor.
20:49:16 <ddarius> @src Either
20:49:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:49:23 <cdsmith> fridim: because the second MyInt is a data constructor name.
20:49:37 <glen_quagmire> how does ghci capture ctrl+c and not quit in linux?
20:49:44 <fridim> what is the first MyInt ? its definition name ?
20:49:45 <jcreigh> fridim: somewhat confusingly, you can have a constructor with the same name as your type, since they're not in the same namespace.
20:49:54 <kilimanjaro> ddarius, try using @dons
20:49:54 <cdsmith> fridim: It's a type name.
20:49:59 <fridim> ok
20:50:12 <olsner> @dons Either
20:50:13 <lambdabot> Either not available
20:50:18 <fridim> they are not in the same namespace ?
20:50:25 <cdsmith> e.g., you could say "data MyInt = MI Int" instead.
20:50:29 <olsner> @dons Just
20:50:31 <lambdabot> Just not available
20:51:07 <cdsmith> fridim: right.  The compiler decides from context whether you mean a data or type constructor.  So you can reuse the same name in both places.
20:51:34 * Sgeo doesn't understand the State thing in the wiki page
20:51:52 <sorear> > 2
20:51:57 <lambdabot>  2
20:52:21 <fridim> but MyInt constructor doesn't exists, does it?
20:52:31 <fridim> since i'am constructing the data
20:52:59 <cdsmith> fridim: The data declaration creates BOTH a type, MyInt, and a data constructor, also called MyInt (in your code)
20:53:38 <dons> sorear: I like Verdana, anti aliased. fonts don't need to be ugly.
20:53:43 <fridim> can I write  a :: MyInt ?   or MyInt a ?
20:53:45 <dons> for console-ish stuff, Terminus is good
20:53:53 <dons> reminds me a bit of the old apple system font.
20:54:27 <lispy> ah yeah, i've used terminus in the past
20:54:37 <lispy> i like apple's terminal font
20:54:37 <cdsmith> fridim: you could write (a :: MyInt), assuming there's something called a.  To write (MyInt a), you'd need to declare MyInt differently.
20:54:50 <kc5tja> sorear: I'm AFK intermittently, watching web videos and so forth.
20:54:51 <lispy> and the font putty uses is okay
20:54:53 <kpreid> dons: Chicago
20:54:57 <cdsmith> fridim: ignore that
20:55:32 <cdsmith> fridim: Yes, in your case, (MyInt a) is how you create a MyInt.  (Sorry, I looked up and saw my code instead; which used MI for that purpose.)
20:55:33 <fridim> (i'am at "advanced types" in YAHT)
20:55:36 <dons> kpreid: that's it!
20:55:48 <dons> kpreid: i'd love Chicago for X..
20:56:01 <dons> very retro
20:56:41 <cdsmith> fridim: (a :: MyInt) only works if a is alread a MyInt, or some compatible type.
20:57:06 <fridim> and how do you declare a as a MyInt ?
20:57:31 <cdsmith> fridim: a :: MyInt
20:57:37 <lispy> unless MyInt is a typeclass you'd need a type constructor
20:57:55 <lispy> maybe that's isn't true
20:58:00 <cdsmith> lispy: It's not.  The decl was "data MyInt = MyInt a"
20:58:10 <cdsmith> s/a/Int/
20:58:13 <fridim> cdsmith, you mean (a :: Myint) only works if a :: MyInt ? :D
20:58:22 <lispy> > ([] :: [Int], [] :: [Char])
20:58:24 <lambdabot>  ([],"")
20:59:05 <cdsmith> fridim: sort of. :)  Actually, there are more complex types in which the type ascription might be necessary.  But for the most part, type ascriptions are just telling the compiler to check your assumptions.
20:59:12 <dmead> ack
20:59:18 <cdsmith> fridim: if you use a variable as a MyInt, it will be a MyInt.
20:59:21 <dmead> unifying to list of predicates
20:59:28 <dmead> is really difficult to describe
20:59:29 <dmead> :s
20:59:30 <dons> so have we changed the WORLD yet!?
20:59:32 <dons> ?yow!
20:59:32 <lambdabot> does your DRESSING ROOM have enough ASPARAGUS?
20:59:33 <dmead> *two
20:59:35 <fridim> I should go further on YAHT before asking more.
20:59:38 <dmead> ?losers
20:59:39 * dons is loaded up on espresso
20:59:39 <lambdabot> Maximum users seen in #haskell: 336, currently: 290 (86.3%), active: 46 (15.9%)
20:59:41 <dons> let's code!
20:59:56 <davidL> how does the overhead of HAppS compare to that of a similar web framework in PHP?
21:00:00 <lispy> dons: no, let's go home and get in an hour of relaxtation before bed...
21:00:02 <cdsmith> fridim: You really don't NEED to "declare" a variable as being some type... unless you want to.
21:00:10 <fridim> cdsmith, ok.
21:00:20 <lispy> ?localtime lispy
21:00:23 <lambdabot> Local time for lispy is Mon May  7 20:59:33 2007
21:00:26 <fridim> (because of lazyness I suppose)
21:00:28 <SamB_XP> davidL: similar framework in PHP?
21:00:39 <SamB_XP> like what?
21:00:58 * lispy has been coding C# all day and finds it hard to think about any more coding
21:00:59 <dons> so, we've got a nice window manager in haskell now. what's some other semi-flakey ubiquitous system software we can rewrite?/
21:01:06 <lispy> heh
21:01:09 <davidL> SamB_XP: I don't know, it's a general question
21:01:10 <lispy> dons: windows
21:01:12 <SamB_XP> the kernel!
21:01:12 <dons> xterm? a minimalist xterm ? irssi?
21:01:14 <sorear> dons: firefox
21:01:19 <dons> seriously, guys.
21:01:20 <SamB_XP> oh, xterm is nice too.
21:01:24 <cdsmith> fridim: You mean laziness as a language feature?  That's got little to do with it.  Laziness of a programmer might have something to do with whether you declare types or not, I suppose. ;)
21:01:25 <SamB_XP> and firefox.
21:01:26 <dons> something that we can do in < 500 lines.. :-)
21:01:26 <sorear> xterm isn't semiflaky.
21:01:29 <lispy> dons: oh right, you said "semi" flakey....
21:01:31 <sorear> xterm is pretty nice.
21:01:33 <dons> sorear: but it is bloated
21:01:42 <SamB_XP> sorear: I've had it crash lately displaying certain binary files in less!
21:01:44 <davidL> adobe photoshop
21:01:50 <dons> thanks guys.
21:01:57 <dons> irssi is one candidate.
21:02:14 <lispy> irssi segfaulted on my yesterday
21:02:14 <dons> but its pretty stable. so hmm.
21:02:16 <SamB_XP> I propose the name hxterm
21:02:19 <dons> ah ok.
21:02:22 <ddarius> syn-ack
21:02:26 <dons> xterm might be fun, but its pretty low level
21:02:34 <dons> more ideas!
21:02:39 <lispy> dons: it had a channel with no name and when i went to that channel it crashed
21:02:42 <davidL> IM client
21:02:55 <SamB_XP> dons: links!
21:03:03 <lispy> i really like the webbrowser idea as i'm sick of how buggy FF is
21:03:10 <SamB_XP> it shouldn't be too hard to go from links to firefox, really!
21:03:20 <kilimanjaro> Yea, just add gtk support
21:03:27 <davidL> oh no
21:03:30 <kilimanjaro> :)
21:03:31 <lispy> dons: how about an IDE
21:03:43 <kilimanjaro> ... an extensible editor?
21:04:05 <olsner> xterm sounds interesting... a shell would be another idea
21:04:07 <sorear> hugs!
21:04:20 <SamB_XP> also, in the process of doing links, we'd no doubt get a fabulous text UI framework
21:04:35 <lispy> dons: a GUI for darcs
21:04:38 <dons> mmm. a shell.
21:04:41 <lispy> a real GUI
21:04:45 <lispy> that works on windows
21:04:55 <sorear> dons: Hugs is a smallish flaky program that would be trivial to write in haskell
21:05:15 <dons> i wrote a small shell for a job interview, it wouldn't be too hard to scale that up.
21:05:18 <lispy> someone could rewrite the current tortoise darcs into haskell and then link it directly with darcs instead of calling it as a subprocess
21:05:20 <kilimanjaro> i would be so happy if somebody made a nice shell in haskell
21:05:21 <SamB_XP> sorear: would it be so lightning fast anymore?
21:05:28 <dons> and  once you write them as a proper language. they're trivial
21:05:46 <jcreigh> I never got why "cd" couldn't be implict
21:05:47 <sorear> SamB_XP: it's already the slowest haskell impl around.  can't lose any more ranks!
21:06:00 <SamB_XP> sorear: I meant in LOADING
21:06:04 <dons> and have a nice Zipper at the heart of the eval phase of the shell
21:06:11 <dons> so you can test the whole thing abstractly
21:06:14 <SamB_XP> it has the fasted load time
21:06:21 <dmead> yea
21:06:24 <SamB_XP> from source to >
21:06:31 <dmead> hugs bangs out code quick imo
21:06:48 <lispy> dons: a database
21:07:00 <dons> mnesia, that would be one idea.
21:07:05 <dons> a core bit of infrastructure
21:07:09 <dons> but a shell is very very tempting
21:07:33 <dons> it makes sense in the whole 'haskell stack' concept. :-)
21:07:45 <lispy> if you write a shell can you make it so that all commands have to be typed in xml? ;)
21:07:56 <davidL> good idea
21:07:58 <fridim> I understood absolutly nothing in the "advanced types" part of YAHT :-D
21:08:03 <olsner> X11 -> xmonad -> hterm -> hsh
21:08:09 <dons> and we can aim for minimalist, high assurance. not having to worry about too many design issues: we know how shells should work.
21:08:18 <SamB_XP> lispy: no. someone will hack it so that you can type in a real language!
21:08:32 <SamB_XP> alternatively, no one will use it
21:08:35 <lispy> <run-command program="ls"></run-command>
21:08:36 <cdsmith> fridim: what's the most basic thing you didn't understand?
21:08:37 <dons> its really a perfect applicatoin for haskellers. shells are usually badly designed languages. we know how to design languages. so lets design a shell
21:08:37 <sorear> olsner: X11 isn't haskell
21:08:39 <SamB_XP> depending on how overcomplicated you make it
21:08:49 <sorear> <run-command program="ls"/>
21:08:58 <lispy> sorear: but then how would you pass options
21:09:00 <olsner> yeah, I know.. just the start of the chain
21:09:02 <jcreigh> dons: so sh-compatible or not?
21:09:02 <fridim> cdsmith, the difference between type, newtype, data
21:09:16 <lispy> <run-command program="ls"><arg1>-l</arg1></run-command>
21:09:17 <fridim> It seems the first has no constructor
21:09:27 <dons> jcreigh: i'd start with a sh clone. in less code, with more correctness / specification
21:09:36 <SamB_XP> I suggest rc(1)-based, personally
21:09:39 <dons> in the model of xmonad-as-better-dwm, and yi-as-vi
21:09:39 <lispy> <run-command program="ls"><arg num="1">-l</arg></run-command>
21:09:44 <cdsmith> fridim: Okay, newtype versus data is a little trick.  type is very different; it doesn't really create a type at all; just another name -- a synonym -- for an existing type
21:09:50 <lispy> dons: rewrite latex
21:09:52 <SamB_XP> rc(1) seems a lot cleaner than sh(1)
21:09:55 <SamB_XP> lispy: hahahahah
21:10:06 <dons> jcreigh: the killer would be to provide a saner language on top
21:10:06 <fridim> cdsmith, ok for "type".
21:10:20 <dons> jcreigh: i.e. 'map' as a built in control structure :-)
21:10:37 <SamB_XP> dons: are you familiar with rc(1)?
21:10:38 <dmwit> jcreigh: zsh has implicit cd -- or is this what gave you the idea?
21:10:42 <SamB_XP> dons: if not, become so.
21:10:48 <lispy> how about a virus scanner written in haskell
21:10:49 <jcreigh> dmwit: oh! I didn't know that.
21:10:56 <cdsmith> fridim: newtype and data are more similar.  newtype creates a "wrapper" for an existing type.
21:11:00 <dons> @slap SamB_XP
21:11:00 <lambdabot> why on earth would I slap SamB_XP
21:11:10 <dmwit> jcreigh: Also available is implicit *pushd* -- YES!
21:11:16 <sorear> lispy: how about a statically virusproof kernel in haskell?
21:11:23 <SamB_XP> see, lambdabot likes plan9 as well ;-P
21:11:27 <jcreigh> dmwit: hmm. I may have to check out zsh
21:11:37 <davidL> zsh completion is nuts
21:11:39 <cdsmith> fridim: e.g., "newtype MyType = MyType (Int, Int)" -- MyType is a different type from (Int, Int), but it "wraps" the base type
21:11:49 <jcreigh> davidL: in a good way or a bad way?
21:11:52 <lispy> sorear: no way, if you did that you'd put symantec out of work
21:11:53 <davidL> great way
21:11:53 <dmwit> Yeah, zsh completion is really good.
21:12:04 <olsner> mm, zsh is nice
21:12:05 <dmwit> It autocompletes parameters to programs...
21:12:07 <dons> see, you guys are just silly. we don't take over the world with idle speculation. you have to come up with realistic, small applications to take a bite out of. :-)
21:12:13 <dons> not this kernel/firefox/windows/... stuff
21:12:17 <dons> pick your battles.
21:12:20 <SamB_XP> dmwit: but it won't ask the programs how to do that
21:12:24 <fridim> cdsmith, what's the difference with  type MyInt = (Int, Int) ?
21:12:28 <SamB_XP> dons: hey!
21:12:29 <dmwit> SamB_XP: No, it asks the users.
21:12:32 <SamB_XP> I did suggest "links"
21:12:34 <dmwit> Even better, and often more correct.
21:12:38 <dons> links is good.
21:12:48 <sorear> dons: coreutils
21:12:54 <lispy> dons: but, most of the really annoying software i use is the big mainstream stuff
21:12:55 <SamB_XP> I think links is an excellent stepping-stone to firefox, in Haskell.
21:13:00 <dons> sorear: also good.
21:13:05 <dmwit> It will correct --foobar options, and my apt-get completes package names...
21:13:11 <SamB_XP> since in Haskell you could probably reuse most of your links code in firefox.
21:13:25 <SamB_XP> using the *same* library, eventually
21:13:36 <sorear> dmwit: same with bash
21:13:47 <dmwit> sorear: Ah, really?  I wasn't aware of that.
21:13:50 <lispy> to be fair about the FF re-implementation...it's super easy until you realize you have to be tolerant to abused standards and mal-formed markup
21:13:51 <cdsmith> fridim: with the "type" there is no new type.  Functions that take (Int, Int) can be called with a MyInt, and vice versa.  With "newtype" that's not true.  MyInt in that case is a different type, and can't be passed to functions expecting (Int, Int)
21:14:07 <dons> a better wiki is another good one
21:14:12 <SamB_XP> lispy: but you have to do that in links too.
21:14:16 <dons> or say, an irssi that supported latex markup :-)
21:14:22 <olsner> I'd like to see a shell with nice ways to combine directory recursion and other processing... like find |xargs etc, but without the quoting hell
21:14:27 <dmwit> lispy: But we'd have the leg up -- we could use Cairo straight from v0.1. ;-)
21:14:38 <dons> olsner: right .a proper DSL for filesystem manipulation
21:14:41 <lispy> dons: ah i was thinking a wiki that supported latex and could export to pdf...easy paper collaboration!
21:14:44 <SamB_XP> olsner: I think rc(1) can do that better...
21:14:48 <dons> lispy: and with a rcs backend.
21:14:55 <dons> very easy to do, imo.
21:15:13 <SamB_XP> but you need cooperative tools :-(
21:15:23 * dons `catch` bus
21:15:35 <lispy> dons: and the wiki/paper collaboration tool seems very natural for haskellers since so many are academics
21:16:17 * lispy :: Bike -> Home
21:16:42 <kc5tja> Speaking of bike, my rear tire is all fixed.
21:17:27 <cdsmith> fridim: oops, I gotta run.  I'm sure someone else here can help with questions.
21:19:29 <dmwit> What about a mail reader?  Too complicated?
21:19:53 <sorear> dmwit: that's on the project ideas wiki page
21:20:10 <dmwit> sorear: ?where project ideas wiki page?
21:22:07 <kc5tja> Talk of re-implementing Firefox in Haskell?
21:22:09 <kc5tja> Sign me up.
21:23:01 <sorear> http://www.haskell.org/haskellwiki/Ideas_for_projects
21:23:03 <lambdabot> Title: Ideas for projects - HaskellWiki
21:23:07 <kilimanjaro> I wish there was an emacs clone written in Haskell, but it had support for implementing applications like firefox
21:23:18 <kilimanjaro> so I could just have a universal tool, written in haskell
21:23:28 <cdr> so write one
21:23:37 <olsner> M-x write-firefox
21:23:38 <cdr> isnt es4 prototyped in haskell - you could be one step ahead of ffox
21:23:42 <sorear> Well, if you'll accept Lisp, emacs already has a web browser!
21:23:48 <cdr> w3m is crap
21:24:02 <monochrom> First you want G-machine hardware. If you make it and give some to me, I'll be happy to do the software.
21:24:21 <cdr> zero-slice triple-axle stackless double twist?
21:24:25 <cdr> ok
21:24:26 <desp> I like the phrase "accept Lisp".
21:24:29 <kilimanjaro> sorear, w3m is not sufficient for my general browsing
21:24:47 <olsner> uhm.. www.haskell.org/hawiki/ and www.haskell.org/haskellwiki/?
21:25:18 <cdr> id imagine you could define the DOM and CSS fairly easy using some series of functions..., then hook it all into cairo
21:25:21 <cdr> would be a neat summer of code project
21:25:24 <desp> it's almost begging to be "accept Lisp into your life"
21:25:25 <dmwit> olsner: hawiki is the old one, and (I think) they're trying to migrate to haskellwiki instead.
21:31:53 <kc5tja> I keep seeing Cairo and continue to think, "Why would anyone want to use Windows NT 4 anymore?"
21:31:56 <kc5tja> ;D
21:32:07 <dmwit> ?
21:32:49 <olsner> was that the project name for NT4, or what?
21:32:56 <ulfdoz> what's cairo's point in this question?
21:33:14 <olsner> @src Cairo
21:33:15 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:33:24 <olsner> lambdabot doesn't know either
21:33:30 <dmwit> ?where gtk2hs
21:33:31 <lambdabot> http://haskell.org/gtk2hs/
21:33:50 <dmwit> olsner: Probably the most well-known bindings to Cairo are in there.
21:38:05 <kc5tja> olsner: Yes.  Chicago was the project name for Windows 95, and Cairo was for NT 4.
22:03:38 <jbauman> ?djinn [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
22:03:38 <lambdabot> -- f cannot be realized.
22:04:33 <jbauman> ?djinn [a] -> [a] -> [a] -> [a] -> [(a,a,a,a)]
22:04:33 <lambdabot> -- f cannot be realized.
22:05:06 <sorear> djinn doesn't do recursion
22:05:15 <sorear> not even recursive types
22:06:00 <jbauman> oh well
22:06:16 <jbauman> seemed like it was worth a shot
22:13:44 <thetallguy> Hey folks, I need a pointer
22:14:00 <monochrom> void *ptr;
22:14:04 <dibblego> thetallguy, use C then
22:14:08 <thetallguy> sjanssen answered a question of mine last week: http://hpaste.org/1685
22:14:18 <thetallguy> dibblego: ;-)
22:14:29 <thetallguy> but the answer doesn't work.
22:14:44 <thetallguy> Can someone cite a reference for what he intended?
22:18:15 <dolio> thetallguy: In haskell 98, you're allowed to have a data declaration like 'data MyClass a => Phantom a = Phantom String'
22:18:57 <thetallguy> dolio, yes, but it doesn't carry through.
22:19:09 <thetallguy> The first example in the hpaste does not typecheck
22:19:11 <dolio> However, that just constrains the type of the constructor. It doesn't actually remember it.
22:19:15 <thetallguy> Right
22:19:29 <thetallguy> that's what sjanssen made clear
22:19:39 <dolio> However, with generalized algebraic datatypes, in the latest GHC, it will remember it.
22:19:48 <thetallguy> he said using the GADT would fix it.
22:19:59 <thetallguy> The example he pasted still doesn't typecheck for me
22:20:20 <thetallguy> latest ghc?
22:20:22 <thetallguy> 6.6.1?
22:20:24 <thetallguy> or Head?
22:20:30 <dolio> head
22:20:42 <thetallguy> Ugh.
22:20:49 <thetallguy> Okay, that explains it.
22:20:51 <thetallguy> Thanks.
22:33:18 <mikepence> hey dudes
22:33:29 <mikepence> WTF is a monad?
22:33:36 <mikepence> I have read like 23 tutorials
22:33:38 <mikepence> and still
22:33:43 <mikepence> I am like, WTF is a monad?
22:33:46 <sorear> A monad is an abstract structure.
22:33:58 <mikepence> ok
22:34:00 <sorear> "A monad" is as meaningful as "A kind of number"
22:34:09 <mikepence> and what are its constraints?
22:34:20 <sorear> "Monad" is like "number", it represents a set of operations on a type.
22:34:22 <mikepence> so it is abstract
22:34:28 <sorear> You can + - * / etc numbers
22:34:34 <sorear> You can return >>= monads
22:34:47 <sorear> The whole point is code reuse
22:34:58 <mikepence> and the operations get passed with the type?
22:35:07 <sorear> the functions like replicateM use only return and >>=, so they work on all monads
22:35:08 <sorear> yes
22:35:18 <mikepence> oh, wow
22:35:20 <mikepence> see
22:35:29 <mikepence> I knew someone here would be able to explain it simply
22:35:36 <mikepence> what is wrong with all those tutorials?!
22:35:38 <sorear> > replicateM [1,2]  -- in [] (backtracking), replicateM builds all possible lists
22:35:41 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
22:35:41 <mikepence> nuclear waster?!
22:35:48 <sorear> > replicateM 3 [1,2]  -- in [] (backtracking), replicateM builds all possible lists
22:35:51 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
22:36:23 <sorear> > execState (replicateM 3 (modify (*2))) 1  -- in State, replicateM runs a modifier several times
22:36:25 <lambdabot>  8
22:36:26 <mikepence> thanks, sorear
22:36:31 <ddarius> This might be helpful http://koweycode.blogspot.com/2007/01/think-of-monad.html
22:36:32 <lambdabot> Title: koweycode: think of a monad...
22:36:36 <sorear> you're welcome
22:36:43 <dons> mikepence: in practice, we use monads to provide a 'programmable semicolon' . that is, inserting some user-specified behaviour into the ';' between each statement. (maybe that helps :)
22:36:52 <Cale_> mikepence: I know, that tutorial is kind of confusing.
22:37:04 <dons> do a ; b ; c ; return d,   the monad lets us program some behaviour into the ';'
22:37:34 <mikepence> so the monad is like a code block that goes with the values?
22:37:40 <mikepence> a lexical closure?
22:37:43 <sorear> Remember that do is syntax sugar.
22:37:51 <dons> mikepence: it can be used in that way, yeah.
22:38:00 <sorear> Use it all you like but don't ever ask "what's the difference between do and >>="
22:38:03 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- first read this, which is I/O specific, but I think it should help :)
22:38:05 <lambdabot> Title: Introduction to IO - HaskellWiki
22:38:08 <sorear> Because there is none.
22:38:21 <mikepence> ok, thanks
22:38:28 <mikepence> so, Haskell or Erlang?
22:38:32 <mikepence> I just read the Erlang book
22:38:47 <mikepence> and it was cool, but I want programs that are provable, without side effects
22:38:53 <mikepence> I am very tired of OOP
22:38:59 <sorear> We like haskell because it is rigged to jam if you point it at your foot.
22:39:06 <Cale> You should enjoy Haskell :)
22:39:18 <sorear> Sure it jams a lot, but at least we still have feet!
22:39:18 <dons> yeah, haskell is a bit of a superset of erlang. I think if you know haskell, erlang is no trouble. knowing erlang helps with haskell, but there's a lot more to it.
22:39:35 <dons> sorear: nice.
22:39:41 <dons> ?remember sorear We like haskell because it is rigged to jam if you point it at your foot
22:39:42 <lambdabot> Done.
22:39:46 <mikepence> are there any good online books about it?
22:40:01 <mikepence> if I go to buy another $50 book, my wife will kill me
22:40:02 <dons> yes, start at haskell.org. In particular, the haskell wikibook is recommended.
22:40:09 <Cale> There's the wikibook, but sections of that are better than others, as you can see.
22:40:09 <dons> no, no need to spend real dollars :-)
22:40:12 <mikepence> thanks, dons
22:40:21 <vegai> another one of these "there has to be a better way to do this": rrdtool
22:40:23 <dons> we have a stunning amount of documentation online, imo.
22:40:30 <vegai> http://oss.oetiker.ch/rrdtool/
22:40:32 <lambdabot> Title: RRDtool - About RRDtool
22:40:34 <Cale> For monads, let me point you around and/or chatter about them :)
22:40:52 <Cale> Do you know what a combinator library is?
22:40:53 <vegai> I wish I was as good at implementing things as finding things to implement ;/
22:41:13 <Cale> I wish I was as good at finding things to implement as implementing things :)
22:41:14 <mikepence> not really
22:41:16 <dons> vegai: hehe
22:41:23 <mikepence> the whole lambda calculus thing is new to me
22:41:30 <mikepence> hell, any advanced maths are new to me
22:41:41 <mikepence> I grew up an under-educated Jehovah's Witness
22:41:44 <dons> don't worry. no math is needed. (let alone advanced math)
22:41:45 <mikepence> stupid religion
22:42:02 <Cale> mikepence: Okay, well the basic idea behind a combinator library is that it's basically a library whose API is rich enough to make it look like a small programming language in its own right.
22:42:26 <mikepence> like a DSL?
22:42:28 <Cale> mikepence: The library implements some simple "programs" as well as ways to combine those programs into more complex ones.
22:42:31 <Cale> yes, exactly
22:42:43 <mikepence> right, I get it
22:42:46 <Cale> So I just used the wrong word :)
22:42:51 <mikepence> Ruby does that in a way
22:42:56 <dons> hehe, people know about DSLs now
22:43:05 <mikepence> Rails is my day job, these days
22:43:11 <Cale> Monads are a particular way of structuring DSLs so that control structure operations can be shared between them.
22:43:16 <dons> good on ruby for spreading the word about embedded combinator sets
22:43:32 <Cale> (at least, this is how you should look at it if you're not a mathematician :)
22:43:34 <mikepence> whoa, Cale
22:43:41 <mikepence> I think I just blew a circuit
22:44:07 <mikepence> so Monads let you share data and the code that operates on them, like...objects?
22:44:36 <Cale> Well, they make use of polymorphism to do this...
22:44:50 <Cale> (parametric, rather than subtype polymorphism though)
22:44:52 <mikepence> I better just read about IO
22:44:59 <mikepence> to get a practical example
22:45:05 <Cale> Yeah, read about IO, and then we'll talk about it some more :)
22:45:23 <mikepence> so, this wikibook: http://en.wikibooks.org/wiki/Haskell
22:45:25 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
22:45:32 <mikepence> and the IO tutorial?
22:45:35 <thetallguy> mikepence: try the 'You could have invented monads' blog
22:45:37 <Cale> The 'return', (>>) and (>>=) are the general monad operations, but that page I linked to talks about them in the specific case of IO
22:45:58 <Cale> Just read the IO thing right now, as it'll only take a couple minutes
22:46:06 <thetallguy> mikepence: given your questions, I think it would be a good place to start
22:46:09 <mikepence> k, thx
22:46:12 <Cale> and hopefully doesn't assume too much
22:46:31 <Cale> and then I'll give you some pieces of the larger picture :)
22:46:54 <thetallguy> you could have invented -- works through three examples of monads, showing the similar absract structure
22:47:28 <Cale> Yes, also, I wrote a tutorial called "Monads as Containers", which I think is rather useful, but it takes an alternate approach to the explanation.
22:47:30 <mikepence> googling
22:47:51 <mikepence> Cale, I think that was one of the 23 that I read
22:48:08 <thetallguy> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:48:11 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
22:48:19 <mikepence> thanks, tallguy
22:48:36 <mikepence> ok, my delicious bookmarks runneth over
22:48:43 <mikepence> thanks for the help
22:48:58 <thetallguy> oh, one more piece of advice
22:49:00 <mikepence> hopefully I will be back with better questions than "WTF is a monad?"
22:49:02 <Cale> Since monads are really just anything with a given set of operations which satisfy some rules, there are lots of rather different approaches to understanding them.
22:49:04 <thetallguy> Just code them for a while
22:49:27 <thetallguy> the more you use them, the clearer they become
22:49:30 <Cale> Since you know what a DSL is, I think the shortest route to enlightenment for you is just to approach them as a way to structure embedded DSLs.
22:49:46 <mikepence> interesting
22:50:01 <Cale> So you implement some basic combining operations which are then treated as polymorphic across many DSLs.
22:50:28 <Cale> and so things like 'foreach' loops can be written once and then used in any monad
22:50:44 <Cale> The Control.Monad library is full of such operations
22:51:41 <mikepence> sounds very powerful
22:51:59 <mikepence> so you can basically pass DSL's with their behaviors, around
22:52:43 <Cale> well, the computations of various DSLs
22:53:00 <mikepence> well, thanks again
22:53:02 <Cale> Because you're implementing those computations as data structures.
22:53:06 <mikepence> TTYL
22:58:01 <therp> good morning #haskell
22:58:36 <ddarius> For small values of morning
23:04:20 <therp> better than "for small values of #haskell"
23:05:09 <therp> for small values of #haskell, it holds that everyone is nice and brilliant.
23:10:45 <therp> grr, I hate ion focus bugs.
23:11:27 <vegai> move to xmonad today!
23:11:40 <sjanssen> xmonad has focus bugs
23:11:50 <sjanssen> ... but at least  we'll fix them!
23:12:22 <therp> yeah right. the problem I have some deadlines approaching by the end of the month
23:13:21 <vegai> dwm as an intermediate solution? :P
23:15:21 <therp> "coding and working" like mad as intermediate solution :)
23:17:55 <dons> therp: you know what to do ---> xmonad.org ;-)
23:19:12 * therp nods and resumes ora&labora
23:35:19 <therp> assume I would like to reimplement the IO monad, supporting newIORef/readIORef/writeIORef. side-effects via reader/writer monad are easy to do, but how about newIORef, and how would I store these references? a list won't work obviously. is this even possible?
23:36:17 <dons> have you read John Hughes' functional pearl, "Global variables in Haskell" ?
23:36:43 <therp> no, sounds interesting
23:36:54 <dons> this one, http://www.cs.chalmers.se/~rjmh/Globals.ps
23:36:57 <dons> explain the story, I think.
23:37:01 <dons> explains.
23:37:01 <therp> merci
23:37:06 <therp> dons++
23:38:00 <dons> no worries.
23:44:25 <newsham> anyone know where to download programatica?  ogi.altocumulus.org isnt responding
23:46:06 <monochrom> you're the second one to ask in two days. perhaps it's getting so powerful the government classifies it as military grade "don't export"? You know, wouldn't want any other country to run it and find a proof to P=NP.
23:46:14 <newsham> i asked earlier :)
23:46:16 <dons> heh.
23:46:35 <newsham> that would explain why finding "alfa" is also hard!
23:46:38 <newsham> ;-)
23:48:10 <newsham> seeking "alfa"
23:50:20 <andygill> Does anyone here know how to run the nofib benchmark suite?
23:50:34 <joelr1> good morning
23:50:38 <newsham> good evening
23:50:44 <andygill> Its been a while, and the makefiles seem like the are in bitrot.
23:53:53 <dons> andygill: hmm. they can be run in tree.
23:53:57 <dons> in a ghc tree.
23:54:24 <dons> another option might be nobench, my fork of nofib to use a better build system, http://www.cse.unsw.edu.au/~dons/nobench.html
23:54:24 <lambdabot> Title: nobench : benchmarking Haskell implementations
23:54:32 <andygill> I've got it in there, but  mk/package.mk is missing.
23:54:51 <dons> oh hmm. maybe check how the nightly build scripts manage to run nofib?
23:55:03 <dons> in the nightly/ sub dir, there's some scripts that walk into nofib and run it
23:56:04 <andygill> I expect if I make boot'ed from the GHC root it would work, but I dont want to break my one working local build :-)
23:56:17 <andygill> So, tell me about nobench.. what different?
23:56:39 <andygill> s/t d/t is d/
23:56:46 <dons> same base programs, plus some new ones from the language shootout and happy, alex, djinn
23:56:58 <dons> and a compiler independent build system.
23:57:07 <dons> you just specify your compiler in header.mk, and things "should work" :-)
23:57:18 <dons> oh, and it doesn't gather the same extensive stats that nofib can
23:57:27 <dons> so no cache misses or such. just runtime and compile data.
23:57:36 <andygill> We do need some new nofib programs; there is a lot of new code out there, and some nofib programs run way to quickly.
23:57:43 <andygill> nofib07, if you want
23:58:01 <dons> yeah. i updated most of them to not run so quickly, and added a few new ones to nobench,
23:58:05 <dons> so it can be seen as nofib07
23:58:13 <andygill> :-)
23:58:16 <dons> but to be fully useful it needs all the stat scripts from nofib as well
23:58:22 <dons> so you can measure cache / memory /gc stuff
23:58:37 <dons> e.g. here's the results for nobench, http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
23:58:38 <lambdabot> Title: nobench: Haskell implementation shootout
23:58:41 <dons> across a range of compilers.
23:59:26 <dons> but you're just hacking ghc? so might be best to just stick to the in-tree nofib?
23:59:40 <andygill> This is not bad time lengths; is this wall time or CPU time?
