00:00:18 <DRMacIver> Pretty much every language channel ever has its own bot written in that language. ;)
00:00:30 <DRMacIver> Except #malbolge I guess
00:01:13 <LeCamarade> #blurb?
00:01:40 <arcatan> #ruby-lang doesn't :P
00:01:59 <LeCamarade> For some languages, bots are unwieldy as REPLs. You've got to create a class for every Java line ...
00:09:19 <DRMacIver> arcatan: Really? Odd. There are definitely ruby IRC bots. :)
00:09:32 <DRMacIver> LeCamarade: ##java has a perfectly functioning javabot. :-p
00:10:42 <Cheery> or disfunctioning ;)
00:11:24 <DRMacIver> Mindless Java bashing is not a useful thing to be doing. :) It's got many failings, but an inability to write working programs is not one of them.
00:11:33 <Cheery> hey! it serves people but does not collect their money! :P it's against the specs given to it
00:11:59 <LeCamarade> I've never understood the whole anti-Java sentiment. Java rocks, even though Haskell rocks more.
00:12:19 <LeCamarade> But then again, I am the guy who says BASIC is the most-importnat programming language of all time.
00:12:32 * LeCamarade is very, very serious with thos BASIC remarks.
00:12:45 <kolmodin> LeCamarade: java rocks in comparison to many other languages. still doesn't mean it's good :)
00:12:59 <Cheery> I'm quite neutral towards anything, I just like to bash
00:13:15 <DRMacIver> LeCamarade: It just lacks a number of advanced features which make it rather clumsy to use, and has a very verbose syntax.
00:13:28 <kolmodin> DRMacIver: very true
00:13:29 <arcatan> Java is overly verbose
00:13:49 <DRMacIver> It's by no means the worst language ever, and is in most respects perfectly adequate.
00:13:54 <LeCamarade> kolmodin: I can't stand it most of the time, but until Jaskell works, I'll be using Java for my phone apps. And when something runs, you are glad Java is better than the general elitist sentiment wants to make you believe.
00:14:02 <DRMacIver> But writing a large quantity of Java can get very very frustrating. :)
00:14:30 <DRMacIver> (More so if you're having to use the 'enterprise' nonsense)
00:14:50 <LeCamarade> DRMacIver: After a day on the GHCi REPL, you can puke at the most-terse Java. As it is, Haskell sets too high a standard.
00:15:16 <kolmodin> LeCamarade: me neither. I've written a smallish/medium sized app at work, and it was not fun at all
00:15:24 <Cheery> Haskell sets so high standard that I don't know a language other than haskell which can beat it
00:15:26 <DRMacIver> LeCamarade: I can live with the verbosity.
00:15:38 <kolmodin> DRMacIver: yes, especially if you know better. if you've ever only seen java you're probably still happy
00:15:46 <Cheery> you could possibly get better than haskell by leaning over 'low-level' -border
00:16:02 <DRMacIver> LeCamarade: It's the really weak type system and lack of first class functions I have trouble living with. :)
00:16:12 <LeCamarade> I can't live with the verbosity. Compilers were invented to kill verbosity. Java is dragging us back there. Bad. But for post-compilation portability, Java beats most other things.
00:16:41 <kolmodin> java has several good IDEs which help generate much of the brain dead verbosity (even if you still have to read all the code)
00:16:45 <DRMacIver> It's possible to write... well, relatively terse Java.
00:16:46 <Cheery> I love verbosity, thought there's those things where I want to be more verbose than in others
00:16:52 <LeCamarade> DRMacIver: Me, I want: closures, type inference, tuples, REPL.
00:17:10 <LeCamarade> kolmodin: I don't use IDEs, unfortunately.
00:17:25 <kolmodin> DRMacIver: I miss continuations and lazyness
00:17:28 <LeCamarade> ed(1)
00:17:30 <LeCamarade> :oD
00:17:30 <Cheery> there's no sense in describing types for every single function you write
00:17:39 <kolmodin> LeCamarade: java without IDE?!?
00:17:50 <LeCamarade> OCaml is more OO than Java, yet not as painful or as verbose.
00:17:58 <LeCamarade> kolmodin: vi(1).
00:17:58 <DRMacIver> LeCamarade: I'm indifferent to the REPL. I can live without tuples, as I have a code generator for building simple data structures anyway. :) (but they would be nice)
00:18:00 <LeCamarade> :o(
00:18:12 <DRMacIver> OCaml is more OO than Java? Nonsense.
00:18:20 <LeCamarade> Actually, the right way to write Java is to have a script generate it for you.
00:18:34 <kolmodin> LeCamarade: omg! :) I would die without a good ide for Java, it's so much to write!
00:18:41 <LeCamarade> DRMacIver, what can Java OO do that OCaml OO can't?
00:18:49 <Cheery> I've written java and c++ without IDEs
00:19:11 <kolmodin> OCaml has OO, but it seems like not many are using it
00:19:33 * Cheery usually feels IDEs too obscure
00:19:46 <LeCamarade> kolmodin: I don't use it (except as F#, where I have to use the Windows classes stuff), but I know it will always be there if I need it.
00:20:02 <Cheery> most IDEs are like biohazard suits
00:20:16 <Cheery> you won't like to keep them on all the time
00:20:18 <arcatan> Smalltalk is OO
00:20:33 <kolmodin> LeCamarade: you're on to something. this guy http://jsolutions.se/?p=120 wrote 1400 loc java in 50 min
00:20:37 <lambdabot> Title: JSolutions.se » Koda snabbt som F*N! (The IntelliJ way&#8230;)
00:21:10 <Cheery> there's exceptions of course, with smalltalk the IDE is IDEa
00:21:18 <DRMacIver> LeCamarade: Well, the vast majority of Java is OO (FSVO OO anyway). It's OO with a few exceptions. OCaml on the other hand is a functional/imperative language which incidentally has an object system.
00:21:36 <DRMacIver> The vast majority of OCaml code (By LoC rather than by project) never touches an object.
00:21:37 <Cheery> thus I'd like from some universal IDE
00:21:56 <quicksilver> DRMacIver: that's because OO is shit and no sane person wants to sue it
00:21:56 <Cheery> nothing like eclipse, instead I'd want set of similar tools I can use everywhere
00:22:03 <quicksilver> DRMacIver: not because ocamlo doesn't support it
00:22:11 <Cheery> ie. grep&vim -style
00:22:13 <DRMacIver> quicksilver: No comment.
00:22:28 <quicksilver> the fact that no one using ocaml use the objects is just a piece of anecdotal evidence that OO isn't what we want :)
00:22:42 <quicksilver> Obviously, I'm being flippant.
00:22:43 <DRMacIver> quicksilver: I'm not saying this is a problem with OCaml, nor making a value judgement on OO. I'm just responding to the comment that "OCaml is more OO than Java".
00:22:45 <LeCamarade> quicksilver: Co-sign!
00:23:03 <quicksilver> But the more serious poiunt is that OO is the *only* abstraction tool that java gives you
00:23:18 <quicksilver> so if you want to do anything in java, you need the objects
00:23:18 <DRMacIver> LeCamarade: I'm rather tempted by the idea of using Haskell to generate Java code. :)
00:23:21 <LeCamarade> Me, OO is only useful for state, in which case I actually want a hash (think Perl OO, JavaScript OO, et al).
00:23:30 <LeCamarade> Not to encapsulate.
00:23:32 <quicksilver> case in point: you can emulate functions as first-class in java
00:23:39 <quicksilver> but to do so, you use a Function object
00:23:44 <DRMacIver> quicksilver: And it's *such* a pain. :)
00:24:09 <DRMacIver> quicksilver: I've spent a lot of time trying to greenspun Java, and it makes the baby jesus cry. :)
00:24:10 <LeCamarade> Not to tell people that this logic is off-bounds. I can live without OO, but I like my objects (ints, strings, lists, whatever) to carry arbitrary state info.
00:24:10 <quicksilver> whereas ocaml gives you a wide variety of abstraction tools
00:24:10 <quicksilver> including one fso powerful that no one in the world really understands it (ML
00:24:11 <quicksilver> -style modules)
00:24:11 <Cheery> OO allows you to write leaky abstractions easier than imperative programming would allow
00:24:43 <DRMacIver> Why does no one understand ML style modules?
00:25:01 <quicksilver> again, I'm being flippant. It's early in the morning and I haven't had c offee yet
00:25:03 <kolmodin> I implemented part of the prelude in java, and it was hardly usable at all
00:25:15 <Cheery> also, it's a playground for immature
00:25:19 <kolmodin> also see http://www.cs.chalmers.se/~bringert/hoj/
00:25:21 <DRMacIver> I admit this is a coment made in ignorance, as I've not used them in anger, but ML modules seem quite easy.
00:25:21 <lambdabot> Title: HOJ - Higher-Order Java
00:25:22 <quicksilver> but it's sometimes said that the reason haskell doesn't have ML-style modules-and-functors is that they are very powerful and no one really undestand them
00:25:40 <DRMacIver> But admittedly this is speaking as someone who is currently plotting a massive extension to them. ;)
00:25:49 * kolmodin gets some more coffee
00:25:57 <LeCamarade> DRMacIver: Haskell was made to heal wounds, to make the babies stop crying, to bring redemption to man. It takes one monad to write a Java code generator in Haskell. :o) I don't see why you don't do that. Java is supposed to be generated, not typed, because Carpal Tunnel syndrome is bad.
00:26:19 <LeCamarade> kolmodin: Coffee? Coffee is Java! X-(   :o)
00:26:22 <Cheery> "OMG! this object is a 'train' object! tuut tuut. now I put this train wrecker to depend from it's very fine details, now I make an interface for this blah blah blah..."
00:26:23 <DRMacIver> LeCamarade: At the moment I don't do it because I've got no strong motivation to do so. :)
00:26:39 <LeCamarade> DRMacIver: Yeah. No Java code to write.
00:26:43 <LeCamarade> @go jaskell
00:26:47 <lambdabot> http://jaskell.codehaus.org/
00:26:47 <lambdabot> Title: Jaskell - Home
00:26:50 <LeCamarade> That's another nice thing.
00:26:54 <DRMacIver> LeCamarade: Well, aside from the stuff I do in my day job. :)
00:27:36 <Cheery> enough from ridicule for this minute
00:29:31 <int-e> @hoogle [a -> a] -> a -> a
00:29:33 <lambdabot> No matches, try a more general search
00:30:37 <int-e> @type flip (foldr id)
00:30:40 <lambdabot> forall a. [a -> a] -> a -> a
00:31:00 <DRMacIver> @type foldr (.) id
00:31:04 <lambdabot> forall a. [a -> a] -> a -> a
00:31:53 <DRMacIver> LeCamarade: Isn't jaskell much less Haskell like than it tries to claim?
00:32:59 <DRMacIver> (In particular it's dynamically typed)
00:33:05 <LeCamarade> DRMacIver: Not used it, but I'd not expect it to want me to type 'public static void main(String[] args)' before I can have a program ...
00:34:25 <LeCamarade> @quote java public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
00:34:25 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
00:34:36 <LeCamarade> @quote+ java public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
00:34:37 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
00:34:45 <LeCamarade> @remember java public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
00:34:45 <lambdabot> Done.
00:34:47 <chr1s> hey
00:34:54 <LeCamarade> @quote java
00:34:54 <lambdabot> java says: public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
00:35:02 <chr1s> any ideas why Control.Monad.State isn't installed by default on ubuntu?
00:35:16 <LeCamarade> chr1s: You can easily apt-get it.
00:35:30 <eumenides> get mtl
00:35:53 <ulfdoz> LeCamarade: Can't see it anymore! *uarg* ;)
00:36:03 <LeCamarade> apt-get install libghc6-mtl-dev
00:36:14 <LeCamarade> chr1s: apt-get install libghc6-mtl-dev
00:36:16 <ulfdoz> Btw. Pair in java were 60 lines of code plus comments.
00:36:24 <LeCamarade> As root.
00:36:58 <LeCamarade> ulfdoz: That's small. Try Either. Is it even possible?
00:37:32 * LeCamarade goes off to do corporate work ...
00:38:07 <igli> good luck
00:40:13 <chr1s> thanks, that worked :)
00:41:37 <dozer_> morning all
00:48:19 <LeCamarade`Gone> I can't help feeling sorry for the guy who wrote HOJ.
00:48:43 <LeCamarade`Gone> He can't have done it sans script, really. I can't trust all that typing to hands.
00:48:56 <LeCamarade`Gone> Now I'm gone for real. :o)
00:49:58 <LeCamarade`Gone> /me bows in respect.
00:59:15 <vegai> has anyone checked out mercurial and compared it to darcs?
01:00:01 <bringert> vegai: joelr1 mentioned that he is using mercurial
01:00:22 <DRMacIver> Idle rambling: People often complain about how hard Haskell makes IO. But in actual fact, Haskell makes IO *easier* by giving you more expressive power to deal with it. In most other languages you have to emulate IO with functions that happen to have side effects. In Haskell you get to treat it as a first class value and manipulate it as such.
01:00:34 <DRMacIver> vegai: No, but I know a number of people who use it and they speak quite highly of it.
01:00:43 <DRMacIver> I don't think they've even looked at darcs though. :)
01:01:06 <DRMacIver> Hm. Maybe not a number. I can think of one, and I seem to recall others mentioning it but can't think who.
01:02:00 <LeCamarade`Gone> DRMacIver: Haskell's IO is one of those things you start out by hating, and then your thinking is re-ordered and the rest is history.
01:03:16 <beelsebob> http://changelog.complete.org/posts/528-Whose-Distributed-VCS-Is-The-Most-Distributed.html <-- seems to indicate darcs is a little bit more "right" than mercurial
01:03:19 <lambdabot> Title: Whose Distributed VCS Is The Most Distributed? - The Changelog, http://tinyurl.com/qcovu
01:03:30 <DRMacIver> LeCamarade`Gone: I never really hated it, mainly because I mostly avoided it until I understood monads. :)
01:04:48 <flux> drmaciver, well, it might depend on the definition of 'easy'
01:04:58 <DRMacIver> Maybe.
01:05:01 <igli> hmm but mercurial won the openSolaris thing
01:05:03 <flux> drmaciver, for example adding randomness to functions after first designing them will not be easy
01:05:11 <DRMacIver> True
01:05:57 <igli> tho i don't think they considered darcs
01:06:24 <vegai> also mozilla and xine are using/going to move to it
01:07:33 <mlh> igli: pretty sure they did
01:08:00 <mlh> got knocked out early on speed grounds
01:08:04 <DRMacIver> The general consensus outside of the Haskell community is that darcs is less awesome than people would like to claim. :)
01:08:08 <igli> oh ok
01:08:13 <igli> i only read summary
01:08:15 <DRMacIver> (In that it's conceptually cool but doesn't scale)
01:09:46 <ADEpt> @src filter
01:09:47 <lambdabot> filter _ []     = []
01:09:47 <lambdabot> filter p (x:xs)
01:09:47 <lambdabot>     | p x       = x : filter p xs
01:09:47 <lambdabot>     | otherwise = filter p xs
01:10:18 <johnnowak> DRMacIver: ghc is also more of a pain for a lot of people than python, which is generally already there
01:12:08 <vegai> well...
01:12:25 <vegai> pacman -S mercurial is just as easy as pacman -S darcs
01:12:45 <mux> http://www.streetwars.net/paris2007.php
01:12:47 <lambdabot> Title: StreetWars: A 3 week long, 24/7, watergun assassination tournament - San Francis ...
01:12:50 <johnnowak> if there's a binary for your platform, sure
01:12:55 <mux> now that sounds fun :-)
01:13:24 <vegai> a watersniper would be fun
01:13:39 <vegai> although I suppose it would have to be quite dangerous to be able to throw water so far away
01:14:08 <vegai> water mines? :)
01:15:06 <quicksilver> I know the mozilla project have also considered bzr
01:15:17 <quicksilver> but it was too slow for them (which was a powerful incentive for the bzr guys to speed it up)
01:15:34 <quicksilver> It's nice finally having competition for VCS
01:15:44 <quicksilver> instead of everyone using the same one which was shit :)
01:16:44 <mux> vegai: heh
01:16:48 <johnnowak> no one seems to talk about git
01:17:06 <LeCamarade`Gone> johnnowak: :oD
01:18:38 <mux> chances are the FreeBSD project will move to mercurial
01:19:03 <mux> we have a few VCS groups debating the merits of each one, depending on the needs we have
01:19:41 <johnnowak> i just hope that, if one of them wins, it doesn't immediately be come filled with useless features and additional complexity
01:19:56 <DRMacIver> They. They should just add the one extra feature that I want.
01:19:57 <quicksilver> I think there are enough design choices to keep several alive
01:20:09 <quicksilver> darc's patchset-based approach is unique, AFAIK.
01:20:17 <quicksilver> (and personally I don't really believe in it)
01:20:36 <quicksilver> there are choices about how you represent divergence and merges, too
01:20:38 <mux> darcs and mercurial are my personal favourites
01:20:42 <quicksilver> and how (or if) you support cherry picking
01:22:13 <johnnowak> who cares about fancy merging algorithms.. just find a grad student
01:22:19 <mux> converting the FreeBSD CVS repo to some other VCS is a nice benchmark :-)
01:22:23 <mux> it's quite huge.
01:22:40 <quicksilver> good merging algorithms are one of thos things that don't matter at all until they do
01:22:50 <quicksilver> and then, once they do, and you're trying to merge a 100-file changeset
01:22:54 <quicksilver> suddenly they matter a lot
01:23:10 <mux> perforce is really nice too, too bad it's not open source
01:23:25 <mux> branches in p4 are a breeze to work with
01:25:40 * mux notes the size of FreeBSD's src, ports, doc and projects repo is 3.2GB
01:27:26 <johnnowak> mux: how good are the chances of freebsd moving to mercurial?
01:28:05 <mux> johnnowak: quite good I'd say; mercurial quite nicely fits our needs and the team supporting it has been rather convincing
01:28:33 <mux> but for what it's worth, we'll *have* to still have exports to a CVS repo for CVSup/csup etc
01:29:00 <mux> johnnowak: http://wiki.freebsd.org/VersionControl
01:29:02 <lambdabot> Title: VersionControl - FreeBSD Wiki
01:40:27 <johnnowak> mux: thanks
02:11:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1837
02:16:40 <igli> mux: is that because of usr base?
02:18:29 <mux> igli: yes, and also because if we don't do that we can't ship a release that already contains all the tools necessary to update or do development, like we like to do
02:19:07 <igli> how so?
02:19:30 <igli> surely mercurial has hg etc cli
02:19:30 <mux> well mercurial is python for instance, it would mean we'd need to import python into the base
02:19:34 <igli> ah ic
02:19:53 <igli> so a bootstrap for devs then?
02:20:02 <igli> no sorry
02:20:05 <igli> silly me
02:21:02 <igli> deps if you can sep usrs from devs i guess which is pretty common? (not a distro guy here)
02:21:34 <mux> what do you mean?
02:21:51 <mux> (and please don't call FreeBSD a distro, heh :-P)
02:22:49 <vegai> that's not as bad as calling it a Linux distro, is it :P
02:23:43 <mux> heh right.
02:24:38 <igli> heh
02:25:13 <igli> i mean distro in the sense of a bundle of software which is distributed as a single package/ disk
02:26:00 <igli> but i mean if users don't need to have access to mercurial repo, it's acceptable to ask devs to install an extra package or 5
02:26:17 <igli> or 10 or whatever you need to make it work
02:26:17 <mux> yes
02:26:32 <igli> *phew* tired ;)
02:26:49 * mux hands igli some nespresso
02:27:21 * igli gladly accepts then realises it's coffee and offers mux some Earl-Grey
02:27:35 <mux> why not :-)
02:27:45 <igli> ew can't stand coffee
02:27:52 <igli> never liked it when i was a kid
02:27:55 <mux> I used to as well, but somehow it changed
02:27:57 <igli> don't like it now
02:28:00 <igli> nah not for me
02:28:20 <igli> only drank half a cup in my whole life, that was when i was 24
02:28:25 <johnnowak> no kid likes coffee
02:28:34 <johnnowak> it's an acquired taste
02:28:34 <igli> heh i'm 36 ty ;D
02:28:50 <igli> so's Earl Grey tho
02:28:54 <mux> I'm 25 and started liking coffee only like last year or so
02:29:00 <mux> mainly for the boosting effects :-P
02:29:03 <johnnowak> earl grey is vaguely flavored water
02:29:12 <mux> earl grey is very good
02:29:21 <johnnowak> bah
02:29:33 <igli> lol
02:29:51 <igli> heh cokkka kola ;)
02:30:12 <igli> plugs the autism thing as well apparently
02:30:29 <igli> similar to ritalin or some such crap
02:30:36 <johnnowak> it does
02:30:47 <igli> yeah?
02:30:57 * ibid drinks apple-flavored pepsi max
02:30:59 <igli> i read it wasn't sure
02:31:10 <johnnowak> ibid: haha
02:31:18 <igli> heh
02:31:42 * johnnowak prefers red tea
02:31:58 <ibid> johnnowak: what's funny?
02:32:40 <igli> haha
02:32:40 <johnnowak> sounds horrdendous
02:32:49 <johnnowak> so horrendous i can't even spell
02:32:50 <igli> rotfl
02:34:09 <ibid> it tastes pretty good actually
02:34:15 <igli> ibid: that was *too* good
02:34:31 <ibid> don't believe me?
02:34:43 <igli> not my point sir ;)
02:35:20 <johnnowak> nothing like caramel colored corn syrup with trace amounts of fruit
02:35:36 <ibid> johnnowak: no sugar :)
02:35:38 <igli> and caffeine
02:35:53 <johnnowak> ah!
02:35:55 <igli> ah you need the sugar imo
02:36:02 <ibid> i don't
02:36:06 <igli> cool
02:36:34 <igli> you weren't joking earlier were you ibid?
02:36:43 <ibid> no
02:36:48 <igli> my bad
02:37:18 * igli takes a sip of sweet-ish tea
02:37:24 <ibid> i am actually drinking something called "pepsi max chill" which is "with a rush of cool apple". tastes surprisingly good
02:37:42 <ibid> tho if i listen to certain people i'm destroying my brains with the phenylalanine and my teeth with the citric acid
02:37:44 <johnnowak> haha
02:37:49 <igli> yeah taste is easy nowadays imo
02:38:00 <DRMacIver> ibid: And your sense of taste with the flavour.
02:38:06 <igli> citric acid isn't so bad really
02:38:33 <igli> relatively speaking i mean
02:39:13 <ibid> DRMacIver: it's already ruined with all the capsaicin i've eaten over the years :)
02:39:27 <igli> hmm
02:39:37 <igli> green chillis rock :)
02:40:12 <DRMacIver> Heh
02:40:42 <igli> tho not first thing in the morning :)
02:41:18 <ibid> this is much better than the pepsi max cappuccino btw that was around recently
02:42:19 <DRMacIver> Pepsi first thing in the morning? Gross.
02:42:32 <DRMacIver> The only acceptable beverage first thing in the morning is coffee so black you can use it to tar roads.
02:42:32 <ibid> no, third thing
02:42:32 <olsner> pepsi max cappucino?
02:42:44 * ibid actually has eaten lunch already
02:42:51 * ibid doesn't drink coffee much
02:42:56 <ibid> olsner: yep
02:43:05 <ibid> olsner: tasted quite horrible
02:43:14 <olsner> I can only imagine
02:43:22 <johnnowak> my breakfast today was coffee and a bean burrito...
02:43:27 <johnnowak> actually, that was also my lunch...
02:43:34 <johnnowak> i need money.
02:43:36 <ibid> my lunch was my breakfast too :)
02:43:42 <ibid> but i was late in waking up
02:43:59 <johnnowak> i got up at 4pm...
02:44:18 <ibid> i got up at 8am
02:44:19 <johnnowak> school ended friday. :)
02:44:41 <DRMacIver> I got up at 7. :( Not because I need to get up, just because a damn pigeon was cooing incessantly outside my bloody window.
02:44:48 <DRMacIver> (Not bitter at all, honest)
02:44:55 <johnnowak> could've been breakfast
02:45:10 <olsner> DRMacIver: admit it, you are bitter
02:45:19 <ibid> why am i talking about food and drink on a non-related channel while i *should* be reading one of the master theses...
02:45:26 <ibid> *master's
02:45:32 <DRMacIver> johnnowak: London pigeons have enough lead content that you could could fire them out of a rifle.
02:45:38 <DRMacIver> And I'm vegetarian :)
02:45:40 <igli> yeah i should be coding apparently
02:46:02 <johnnowak> DRMacIver: eat a few and you'll forget that
02:50:49 <marscher> hi
02:53:09 <marscher> i have a custom datatype e.g. data foo = a :: String, b :: [String] -- how do select elements of foo::b in an concrete instance?
02:55:35 <marscher> is there a need for a custom dataselector?
02:56:34 <ibid> i assume your actual declaration is syntactically correct? :)
02:56:50 <ibid> if x :: Foo then x a selects the a-component of x
02:56:55 <ibid> gah
02:56:58 <ibid> a x
02:57:00 <ibid> of course
02:57:11 <ibid> and b x for the other
02:58:46 <marscher> ibid, yes my syntax works ;)
02:59:10 <marscher> so i need a dataselector for my type?
02:59:16 <quicksilver> no
02:59:20 <quicksilver> a and b are dataselector
02:59:28 <quicksilver> fieldnames are automatically dataselectors
02:59:50 <ibid> marscher: as quicksilver said, you already have declared them in the data declaration :)
03:00:30 <marscher> mhm
03:01:02 <marscher> perhaps i expressed myself incorrectly..
03:01:26 <marscher> if i have a function f :: foo -> Int
03:01:45 <ibid> marscher: (note that types have to start with an upper-case character)
03:01:49 <marscher> and i want to sum the elements of (foo :: b)
03:02:07 <ibid> is b a type?
03:02:08 <marscher> ibid, yeah, choosed wrong example - sorry
03:02:21 <marscher>  data Foo = a :: String, b :: [String]
03:02:33 <marscher> b is a list of strings
03:02:34 <ibid> marscher: yes, but if you do that then foo :: b is meaningless
03:03:35 <quicksilver> marscher: f x = sum (b x)
03:03:46 <quicksilver> marscher: 'b x' === the b-component of x
03:03:57 <marscher> i mean how may i access the list of Strings in the datatype Foo?
03:04:14 <quicksilver> by using the selector 'b'
03:04:28 <ibid> marscher: as i said, if x has the type Foo, then you get the list of strings by b x
03:05:17 <ibid> marscher: or you could pattern-match, whichever is more convenient
03:06:17 <igli> <ibid> i assume your actual declaration is syntactically correct? :)
03:07:05 <igli> sorry noob here, that's the bit that drew my attention
03:07:15 <ibid> igli: ?
03:07:43 <igli> well you thought to ask, so i wondered whether there's a possibility it wasn't
03:07:56 <quicksilver> igli: as he wrote it, it wasn't
03:07:59 <quicksilver> igli: it needed {} around it
03:08:03 <igli> ah sorry just saw that
03:08:05 <igli> my bad
03:08:13 <igli> beg pardon marscher
03:08:19 <quicksilver> igli: so we were assuming he was just typing quickly but the decl was correct in his code
03:08:26 <igli> cool
03:08:58 <igli> sorry was reading the bottom bit couldn't work out what was wrong
03:08:58 <marscher> data Foo =  { a :: String, b :: [String] }
03:09:09 <quicksilver> right
03:09:13 <marscher> i have that in my code.. missed it in this example..
03:09:20 <quicksilver> and then, for example, to get the length of the b-part of the Foo, you do this
03:09:25 <quicksilver> f :: Foo -> Int
03:09:31 <quicksilver> f x = length (b x)
03:09:35 <quicksilver> marscher: is it clear now?
03:09:39 <igli> lovely
03:11:15 <ibid> quicksilver, igli: he's also misssing a data constructor in the declaration :)
03:11:27 <quicksilver> oh yes :)
03:11:40 <igli> ok
03:11:43 <marscher> my f is bit more complicated :S
03:11:59 <igli> data constructor?
03:12:02 <marscher> f :: String -> [Foo] -> [Foo]
03:12:13 <igli> what?
03:12:13 <marscher> so this b x stuff won't work?!
03:12:23 <marscher> f === function
03:12:42 <igli> f x = sum (b x) bit?
03:12:43 <Baughn> marscher: Oh, that part works. The problem is, how do you make a Foo?
03:12:57 <ibid> marscher: there is no Foo there, so there is no place for b to be needed
03:13:39 <quicksilver> igli: data Foo = Foo { a :: String, b :: [String] }
03:13:47 <quicksilver> igli: the second 'Foo' is the data constructor
03:13:51 <quicksilver> igli: marscher missed that out
03:13:52 <igli> ah ok
03:13:59 <igli> i hate that tbh
03:14:00 <marscher> missed that too :D
03:14:03 <marscher> sorry
03:14:25 <igli> data Foo =  { a :: String, b :: [String] } # is that nonsense then?
03:14:29 <quicksilver> marscher: yes, the 'b x' stuff still works
03:14:35 <ibid> igli: yes
03:14:38 <igli> ok
03:14:38 <quicksilver> marscher: I'm having difficultly understand which part you don't understand
03:14:47 <ibid> igli: data Foo = Foo { a :: String, b :: String } -- works
03:14:59 <quicksilver> marscher: 'b' is an automatically created selector, it has type b :: Foo -> [String]
03:15:00 <igli> sure it just seems b0rked syntax to me
03:15:13 <ibid> igli: huh?
03:15:54 <marscher> ahhh
03:15:56 <igli> well if first form isn't used (eg for tuple) then why not allow it? it's similar to C++ forcing ~Class
03:15:59 <marscher> now i got it =)
03:16:31 <ibid> igli: for that to work you'd effectively need record subtyping
03:16:50 <igli> no i mean iff syntax is unused, allow it
03:16:53 <ibid> igli: which haskell doesn't have (and aiui is a bit hard to get right)
03:17:15 <igli> so: data Foo = { a :: String, b :: String } === data Foo = Foo { a :: String, b :: String }
03:17:25 <ibid> igli: what i mean is that if you allow that syntax, then you either create a crippled system or you create semantic complications
03:17:45 <vegai> Haskellers shun syntax sugar, perhaps?
03:17:47 <ibid> igli: ah, you mean it's just elided repetition? i suppose that might work
03:17:56 <igli> ah the semantuc complexity interests me
03:17:59 <igli> i*
03:18:10 <igli> ibid: yes
03:18:40 <igli> easier to type :) and intuitive
03:18:42 <DRMacIver> Note that data Foo = Bar { a :: String, b :: String } also works.
03:18:49 <quicksilver> it's pretty marginal benefit
03:18:51 <igli> is that a subclass?
03:18:54 <DRMacIver> No
03:18:57 <quicksilver> in real applications you often don't use the same name
03:18:58 <igli> ok
03:19:07 <quicksilver> igli: there is no need for the constructor name to match the type name
03:19:08 <DRMacIver> You're not repeating 'Foo' so much as defining two differents things and taking advantage of the fact that they live in different namespaces.
03:19:10 <ibid> igli: well, if you allow untagged records (which is what i thought you were talking about but you weren't), you create a system where you need to basically allow structural subtyping on records
03:19:13 <DRMacIver> Bar is a constructor, Foo is a type.
03:19:16 <quicksilver> igli: and often it's not a particularly good idea
03:19:21 <igli> ok
03:19:22 <quicksilver> igli: it's just handy in toy examples
03:19:33 <igli> ah why is it a bad idea tho?
03:19:41 <ibid> quicksilver: i don't agree it's a bad idea
03:19:50 <quicksilver> I didn't say it was
03:19:54 <quicksilver> I said it wasn't particularly good
03:19:55 <quicksilver> :P
03:19:56 <ibid> quicksilver: i personally think the data Foo = MkFoo ... pattern is just silly
03:20:03 <igli> heh
03:20:11 <quicksilver> consider data Foo = ThisFoo { a:: ... } | ThatFoo { a:: ... }
03:20:18 <igli> ok
03:20:30 <ibid> quicksilver: yes, but the situation there is different, as you have multiple alternatives
03:20:34 <quicksilver> right
03:20:40 <quicksilver> but that's a common situation, for record syntax
03:20:46 <igli> so where <id> missing assume <type-name>
03:20:58 <ibid> quicksilver: sure it's common, but the other one is too
03:21:05 <quicksilver> furthermore, I'd argue that using the same name for two different things is probably not a good idea for pedagogical reasons
03:21:05 <igli> instead of throwing an error
03:21:16 <quicksilver> and I think this current discussion illustrates that
03:21:25 <igli> what for a data type and its constructor?
03:21:28 * quicksilver nods
03:21:28 <ibid> that i can agree with
03:21:50 <quicksilver> it's quite confusing to explain the difference between Foo the type and Foo the constructor, sometimes
03:21:50 <igli> you mean breaking the link?
03:21:53 <DRMacIver> As an idle point, if you're defining single constructor types you should probably be using newtype anyway shouldn't you?
03:21:58 <ibid> i mean, it makes sense to avoid it when introducing haskell :)
03:21:58 <araujo> morning
03:22:10 <igli> morning araujo :)
03:22:21 <ibid> DRMacIver: you can't do it if you have more than one field in the type
03:22:24 * araujo using xmonad!
03:22:28 <DRMacIver> ibid: True
03:22:29 <ibid> DRMacIver: newtype requires a single field
03:22:30 <araujo> hi igli
03:22:30 <igli> w00t
03:22:35 <igli> :)
03:22:39 <vegai> perhaps type constructors should use different syntax
03:22:43 <DRMacIver> ibid: But that's what we have here. :)
03:22:52 <ibid> DRMacIver: where?
03:22:55 <igli> ok not for single field case then
03:23:00 <vegai> perl way :P  data Foo = :Foo ...
03:23:07 <ibid> DRMacIver: i don't think any of the examples under discussion are single-field
03:23:26 <vegai> ok, so colon is already reserved for the postfix constructor, but something like that.
03:23:43 <ibid> vegai: bah, i believe the haskell committee designed the language carefully to allow them use the same namespace :)
03:23:53 <ibid> vegai: (infix constructor, you mean)
03:24:13 <vegai> So... some programming languages are designed so that programs are written for computers
03:24:20 <vegai> some so that programs are written for humans
03:24:30 <vegai> and Haskell is so that programs are written for compilers :)
03:24:37 <ibid> uh, no
03:24:49 <ibid> if that were so, the language would be much different
03:25:32 <igli> heh that's C ;)
03:25:40 <Baughn> Fortran is written for computers; C is written for compilers. Haskell.. mathematicians?
03:25:51 <igli> hmm
03:25:51 <quicksilver> haskell is written for programmers
03:25:56 <igli> lmao
03:26:00 <ibid> igli: speaking as one who has tried to write both C and Haskell frontends, i beg to disagree!
03:26:15 <igli> ah you were using gcc then
03:26:21 <Baughn> quicksilver: Not the programmers we've actually got, I'm afraid
03:26:48 <ibid> igli: was that addressed to me? if so, i don't get it
03:26:50 <quicksilver> Baughn: it works for me :P
03:27:05 <Baughn> quicksilver: You're atypical. >_<
03:27:11 <vegai> quicksilver: perhaps for computer scientists
03:27:23 <igli> ibid: gcc is god-awful before version 4
03:27:25 <quicksilver> that's not quite what I meant
03:27:33 <DRMacIver> ibid: Hm. I thought that when you were defining data with named fields you were really defining data which took a record argument. Apparently I'm wrong.
03:27:42 <quicksilver> I didn't mean "haskell is written for those people who currently, despite their inadequacies, have a job in programming' :P
03:27:50 <quicksilver> I meant 'haskell is written for programmers'
03:27:55 <quicksilver> i.e. not any particular group of programmers
03:28:00 <ibid> DRMacIver: haskell has no records, the record syntax is just sugar for regular algebreaic types
03:28:07 <quicksilver> but just 'haskell's design features are chosen to make the programmer's life easier'
03:28:15 <igli> sure so is smalltalk
03:28:17 <quicksilver> rather than the compilers, or the CPUs
03:28:26 <vegai> so was C...
03:28:40 <vegai> (easier compared to what?)
03:28:52 <Baughn> vegai: C was most definitely made to make the compiler writer's job easier
03:28:54 <quicksilver> (easier compared to the other choices for that feature)
03:29:06 <quicksilver> (help, vegai and I are trapped in parentheses)
03:29:09 <vegai> Baughn: is compiler writer not a programmer?
03:29:10 <quicksilver> (someone let use out!)
03:29:13 <ibid> DRMacIver: so basically, data Foo = MkFoo { a :: A, b :: B } desugars into data Foo = MkFoo A B ; a (MkFoo x _) = x ; b (MkFoo _ x) = x (and adds support for record update and record pattern matching syntaxes)
03:29:28 <DRMacIver> ibid: Ah, I see.
03:29:31 <vegai> (quicksilver: (follow me, I know a way out, (it's over here)))
03:29:33 <Baughn> vegai: It used to be understood that "programmer" meant "user of the compiler" in this conversation
03:29:57 <EvilTerran> is there a way of viewing the steps taken by the interpreter in reducing an expression?
03:30:06 <ibid> igli: i still miss how gcc entered the discussion :)
03:30:43 <igli> heh cos you said you were writing a front-end; i thought you'd have said "no" straight off :)
03:31:08 <quicksilver> EvilTerran: the new ghci debugger has some of that, yes
03:31:13 <ibid> igli: i'm actually writing a c frontend, it just happens that i'm currently in the frontend phase of it :)
03:31:21 <ibid> gah
03:31:29 <igli> for which compiler tho?
03:31:31 <ibid> igli: i'm actually writing a c *compiler* ...
03:31:36 <igli> heh
03:31:46 <igli> good luck mate :)
03:31:57 <igli> i am actually writing a meta compiler ;)
03:32:02 <ibid> no luck involved, just lots of butt-meet-chair
03:32:05 <therp> igli: meta compiler?
03:32:09 <igli> yup and no irc
03:32:20 <igli> therp: it's just marketing speak really
03:32:31 <EvilTerran> quicksilver, i'll investigate that, ta
03:32:37 <therp> igli: and what's this meta-compiler thing really about? :)
03:32:47 <ibid> meta compiler sounds like a compiler compiler (which for some reason means lexer and parser generators)
03:33:01 <igli> idea is to have all performance of C, sugar of haskell and *proper* i18n
03:33:18 <igli> so all tokens etc are translatable between teams
03:33:20 <therp> igli: and you are writing it in what kind of language?
03:33:30 <igli> heh C to start then itself
03:33:30 <Baughn> ibid: Once upon a time, the lexer and parser were the largest parts of a compiler. They still are, if you're willing to be very dumb.
03:33:51 <igli> yeah i was amazed how simple it is
03:34:05 <igli> that's why i said C is for compiler writers
03:34:13 <Cheery> ?where image
03:34:13 <lambdabot> I know nothing about image.
03:34:22 <Baughn> Problem is, making C /fast/ on modern machines is anything but easy
03:34:28 <ibid> igli: C is particularly annoying as a compiler writing language :)
03:34:35 <igli> well gcc does ok and so does ICC
03:34:44 <Cheery> @go image manipulation haskell
03:34:45 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/gtk/
03:34:45 <lambdabot> Title: A GTK+ Binding for Haskell
03:34:51 <igli> ibid: tell me about it :) but i've done the hard bit
03:35:16 <Cheery> ok, not exactly what I am looking for. I'd like to output pictures to file?
03:35:22 <Baughn> igli: gcc is awful, and not actually written in C either. People keep telling me that ICC isn't C, too.
03:35:37 <Cheery> does haskell have some library for working with images?
03:35:41 <ibid> Baughn: what is it written in, then?
03:35:44 <igli> gcc is indeed in C. it's godawful like i said
03:35:48 <Cheery> ie. storing, loading, etc.
03:35:59 <igli> but from ver 4 the front-end stuff is much cleaner
03:36:07 <igli> you should have seen 3.x
03:36:12 <ibid> Baughn: it used to be bootstrappable using just about any old c compiler. i think they recently started requiring C89 conformance from the bootstreap compioler
03:36:25 <igli> it still is you know?
03:36:51 <igli> builds xgcc first
03:36:59 <igli> gentoo ftw ;)
03:37:03 <Baughn> ibid: GCC is written in GNU99, whatever that is. They may have a tiny bootstrap compiler that's valid C99, in much the same way that GHC does.
03:37:06 <ibid> igli: even with a K&R compiler with no support for function prototypes? i heard they dropped support for that
03:37:19 <Baughn> But the main, /optimizing/ compiler is definitely not C. It uses a garbage collector, too.
03:37:24 <igli> dunno man, i'm an asm coder at heart
03:37:25 <quicksilver> Baughn: GHC doesn't have a bootstrap compiler, afaik
03:37:39 <quicksilver> Baughn: it has the ability to build a bootstrap compiler, by compiling itself to C
03:37:52 <igli> doesn't need to gcc can build it
03:37:55 <dcoutts> Baughn: it is C, it just uses the Bohem GC for C. That doesn't change the language.
03:38:00 <igli> and gcc can bootstrap
03:38:08 <Baughn> dcoutts: No, the extensive extensions does that
03:38:17 <quicksilver> I was fairly sure gcc used non-C extensions in its own code
03:38:21 <igli> man i have dug thru loads of that code
03:38:29 <igli> it's C all right
03:38:48 <quicksilver> igli: it's 'nearly C' of course
03:38:56 <Baughn> Just looks like C. It uses every GNU extension they've got, including closures and such things you wouldn't normally find in C code.
03:38:58 <quicksilver> igli: it's just it uses GNU extensions. Or that's what I was told
03:39:11 <igli> yeah sure
03:39:18 <quicksilver> so in that sense, it isn't C :)
03:39:20 <igli> but any sane *nix developer does
03:39:24 <igli> not C89 no
03:39:30 <dcoutts> Baughn: erm the GNU C language doesn't have built-in GC, it's provided by the Bohem GC. See the gcc sources in the bohem-gc subdir.
03:39:34 <Baughn> Can you call it C when it's got /closures/?
03:39:39 <ibid> my compiler (what i have completed of it) is C89 :)
03:39:40 <Baughn> dcoutts: I'm well aware
03:39:41 <igli> but is GHCi6 the same as hugs98?
03:39:46 <quicksilver> nope
03:40:06 <igli> continuations are so simple to code tho. closures aren't much harder
03:40:08 <Baughn> ibid: Freestanding or hosted?
03:40:15 <ibid> Baughn: hosted
03:40:27 <ibid> Baughn: the language it's written in, that is
03:40:42 <ibid> the source language tries to be C99
03:40:54 <DRMacIver> gcc uses Boehm? Interesting.
03:40:56 <igli> point is if you only know haskell it's hard to write code that efficient. that's the motivation for our thing.
03:41:19 <Cheery> @index Image
03:41:20 <lambdabot> bzzt
03:41:21 <igli> glib is excellent as well tbh
03:41:47 <Cheery> I read about an image -type or class at the Prelude, where has it disappeared?
03:41:54 <dcoutts> Baughn: closures? I didn't notice that. What extension are you thinking of?
03:42:33 <igli> yeah i never saw em in gcc but i didn't read every file and it was about 3 years ago
03:42:51 <Cheery> or wait, maybe it's not haskell here
03:43:00 <Cheery> http://www.cs.kent.ac.uk/projects/vital/reference/lib/prelude.html
03:43:04 <lambdabot> Title: The Prelude module, http://tinyurl.com/249cbm
03:43:19 <igli> continuations are nice tho ; there's a classic book on that somewhere "compiling with continuations"
03:43:48 <Baughn> dcoutts: info gcc "c ext" nest
03:44:15 <Baughn> dcoutts: Nested functions. It works pretty much like closures, so long as you take care not to /return/ one - the variables stay on the stack.
03:45:08 <dcoutts> Baughn: hmm, I don't think pascal-style nested functions really count as closures
03:45:11 <Baughn> Extremely handy, of course, if you're willing to tie yourself to gcc. Mostly I am.
03:45:54 <dcoutts> I've seen very few C modules that use nested functions
03:45:54 <Baughn> dcoutts: The nested functions can access variables in the nestee, even if you take a pointer and pass it to qsort or something. That's close enough for me.
03:46:27 <Cheery> There is no image processing libraries for haskell?
03:46:28 <Baughn> Probably because it's not C
03:47:35 <dcoutts> Baughn: yes, but most modules seem to use some GNU extensions but I was able to parse pretty much everything on the system before adding nested functions into my C parser.
03:48:03 <quicksilver> nested functions are one of the most annoying omissions from C, IMO
03:48:04 <DRMacIver> Cheery: Hackage has various things under graphics that might work.
03:48:52 <dcoutts> Cheery: depends what you're looking for, raster or vector? generating or reading?
03:49:04 <Cheery> raster, generating&reading
03:49:38 <Cheery> I'd like to put pixel and generate .png -files
03:50:04 <dcoutts> Cheery: someone uploaded a small GD binding to Hackage recently and Gtk2Hs has some support for bitmaps & pngs too
03:50:24 <dcoutts> the latter isn't terribly convenient however
03:50:41 <dcoutts> it just gives you an array interface and png load and save functions
03:52:50 * EvilTerran lets trace x = unsafePerformIO $ print x >> return x
03:53:00 * EvilTerran weaves this into his program in appropriate places
03:53:25 <Baughn> EvilTerran: There are far better method built into GHC already. Which is not to say that I haven't done just that. before. -_-;
03:54:06 <DRMacIver> I think you mean 'inappropriate places' ;)
03:54:57 <EvilTerran> I'm using 6.4.1 here
03:55:02 <EvilTerran> what do you suggest?
03:55:21 <Cheery> how well image file specs bend to haskell?
03:55:33 <EvilTerran> (can't upgrade, i'm afraid; this is the university's computer, and i lack the permissions)
03:55:43 <Cheery> I'm just wondering, whether one could just do that. :)
03:55:56 <Saizan> Debug.Trace.trace ^
03:57:22 <EvilTerran> well, yes. but then if i want to show the same value as the one it's returning, i need to pass it in as two parameters
04:01:10 <EvilTerran> incidentally, is there a haskell equivalent to __LINE__ and __FILE__?
04:01:17 <EvilTerran> (or TH)
04:01:25 <Baughn> EvilTerran: Sure, if you pass -cpp to ghc.
04:01:30 <EvilTerran> heh
04:29:19 <matthew-_> if you have class F a b | a -> b where and then you have data G :: * -> * where GC :: (F a b) => a -> G b and then you try to pattern match on the GC and return the value, GHC complains about the escaping variable. But it's defined by the FunDep so there's nothing that can go wrong is there?
04:29:30 <matthew-_> So is this a missing feature of GHC or am I confused?
04:30:34 <matthew-_> or is the FunDep going the wrong way? Effectively I'd be writing wibble :: (F a b) => G b -> a so maybe that fundep should be the otherway round
04:35:20 <mux> dcoutts: around?
04:40:13 <Saizan> matthew-_: forall a there's only one b, but for every b there can be more than one a, so effectively by G b you don't know which instance to pick
04:41:52 <ToRA> @paste
04:41:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:42:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1838
04:42:44 <ToRA> matthew-_ ^ is this a fair rep of your problem?
04:42:49 <hpaste>  matthew-_ pasted "I was about to send this to the mailing list..." at http://hpaste.org/1839
04:43:26 <matthew-_> ToRA: yeah, but I think you only need the fundep one way
04:43:52 <ToRA> i don't disagree
04:43:53 <matthew-_> Saizan: I think I explained myself better in that hpaste.
04:45:02 <kolmodin> what are combinators called in the OO world?
04:45:23 <Baughn> Patterns, at best
04:45:35 <igli> some god awful design pattern
04:46:08 <kolmodin> yes, I'm sure they call it for some kind of pattern, but which ? :D
04:46:26 <Saizan> i think that: foo2 :: G b -> (forall a. (F a b) => a)
04:47:04 <igli> not strategy there's some functor one
04:47:11 <Saizan> i'd post on the mailing list :)
04:47:57 <igli> Factory Method i imagine
04:48:00 <matthew-_> Saizan: done :)
04:48:07 <igli> or Template Method
04:48:17 <hpaste>  ToRA annotated "I was about to send this to the mailing list..." with "If it's any help" at http://hpaste.org/1839#a1
04:48:25 <kolmodin> igli: no, it's not factories (i think)
04:48:29 <igli> as used by Strategy
04:48:43 <igli> well i dunno i thought this was functional prog?
04:48:53 <igli> factories generate classes
04:48:56 <igli> or objects
04:49:14 <igli> "Factory Method i imagine"
04:50:21 <igli> jeez only cos it's you lot ;) "Define an interface for creating an object, but let subclasses decide which class to instantiate"
04:50:38 <igli> AKA Virtual Constructor
04:51:07 <kolmodin> hmm
04:52:08 <kolmodin> yeah, the factory method pattern seems to be part of what I do, but it doesn't describe everything
04:52:31 <igli> ok
04:52:50 <igli> can you explain it simply?
04:53:05 <igli> you're prob'y right tho; everyone uses Factory
04:53:06 <kolmodin> factory pattern seems only to be that you don't specify exactly which type you return, but only an abstraction
04:53:50 <kolmodin> but the part I'd like to describe is that I've written as      return new JoinResult(result1, new DoSomething(result2)) // for example
04:53:54 <igli> no that's not true at all. All the patterns are to abstract something cos C++ is sh*t at it *or* its coders are idiots i haven't worked it out yet
04:54:43 <kolmodin> I didn't get that
04:54:49 <igli> (to be blunt for a sec) kolmodin i am way too tired to read over a long discussion
04:55:04 <igli> yeah it was a bit of a rant sorry
04:55:37 <igli> ah ok i'll read that for a minute sorry (tired)
04:56:03 <igli> yeah a factory method should do that
04:56:29 <igli> altho what's wrong with fn ptrs i don't know ;)
04:56:56 <kolmodin> it also got quite complicated as there aren't continuations in javav
04:56:58 <kolmodin> -v
04:57:03 <kolmodin> or lazyness
04:57:05 <kolmodin> .. :(
04:57:27 <igli> eh this is C++
04:57:34 <igli> but yeah no cont'ns
04:58:04 <kolmodin> the patterns applies to any OO language
04:58:06 <igli> tbh i hate C++ it's awful
04:58:10 <igli> yeah
04:58:30 <igli> SmallTalk looks so nice man i have to play with it
04:58:54 <matthew-_> yeah, the 70s always look great on TV... ;)
04:59:03 <kolmodin> yes, there is a reason for why we're in #haskell
05:00:01 <pejo> Are you guys arguing against objects, subtyping or something else?
05:00:29 <kolmodin> pejo: not really
05:00:40 <quicksilver> just arguing
05:00:50 <kolmodin> haha :) general arguing :)
05:00:54 <kolmodin> (again)
05:01:06 <kolmodin> no, I was trying to identify what patterns I've used
05:01:22 <kolmodin> it's a bit blurry to me what I've done in terms of patterns :)
05:01:26 <kolmodin> "it just works"
05:02:15 <igli> forget the patterns then imo they're kludges
05:02:30 <kolmodin> no. they are good to know
05:02:39 <kolmodin> it makes talking about code easier
05:03:08 <igli> oh ok
05:03:10 <kolmodin> as you have to use them anyway, even if you don't know their names or which ones exist
05:03:18 <igli> hmm
05:03:38 <quicksilver> it's very fashionable in a certain subculture to dismiss design patterns
05:03:50 <igli> i don't know if i am getting monads, but they seem like chain of command or strategy (i hope the latter)
05:03:51 <kolmodin> yeah, I'm sure
05:03:54 <quicksilver> like most fashionable memes there is a seed of truth but it's overdone
05:04:03 <quicksilver> design patterns is a good book, and they are interesting things
05:04:16 <jmelesky> patterns are language-dependent
05:04:17 <quicksilver> it's not true that 'Haskell doesn't have patterns' or 'only stupid OO languages need patterns'
05:04:29 <kolmodin> quicksilver: yes!
05:04:34 <quicksilver> although it certainly *is* true that some of the popular patterns exist to paper over a lack of abstraction power
05:04:40 <quicksilver> (..in a particular language)
05:04:44 <kolmodin> quicksilver: I'll summon a few ideas some time and blog about it :) but I don't have time atm
05:05:02 <kolmodin> quicksilver: I completely agree
05:05:11 <jmelesky> it doesn't make much sense to talk about the gang of four patterns in a context outside of Java/C++
05:05:17 <jmelesky> (imho)
05:05:24 <quicksilver> jmelesky: smalltalk is a pretty different language from java/C++
05:05:28 <jmelesky> that said, there are patterns in other languages
05:05:32 <kolmodin> jmelesky: yes, naturally we have different patters in different languages
05:05:34 <quicksilver> jmelesky: and yet, smalltalk was one of the basis languages for the book
05:05:41 <bringert> kosmikus: did you ever have time to figure out why I didn't get linebreaks in inline lhs2TeX code? See http://tunes.org/~nef/logs/haskell/07.04.06 09:20:47 - 09:29:34 for the details.
05:06:28 <jmelesky> ok, smalltalk, too, fair enough. perhaps "OO languages of a certain vintage"
05:07:58 <quicksilver> having names for stuff is good, too. (and bad, sometimes)
05:08:05 <kosmikus> bringert: no
05:08:11 <quicksilver> but it's good because you can talk about them, then
05:08:19 <quicksilver> and bad because sometimes another level of jargon just makes stuff obscure
05:08:22 <dozer_> yeah, some patterns are specifically usefull in java/c++ because they work arround a lacking bit of language expressivity
05:08:43 <pejo> Are all of the gang of four patterns totally useless in a language with both OO and fp features?
05:09:03 <dozer_> wouldn't have thought so
05:09:13 <quicksilver> not at all
05:09:18 <bringert> kosmikus: ok thanks, I'll keep using {-"\linebreak"-} then
05:09:34 <dozer_> if you have languages where you need to manage some memory then a load of the patterns are useful e.g. singleton, flyweight
05:10:03 <quicksilver> 'Adapter' is pretty much a universal pattern, IMO
05:10:19 <quicksilver> I can't conceive of any language where you don't sometimes need to abstract between different APIs
05:10:23 <dozer_> and delegate
05:10:48 <quicksilver> actually I can't remember if I got the name right, there :)
05:11:06 <quicksilver> ah yes, I did
05:11:12 <jmelesky> ... but the Iterator pattern is irrelevant in a whole slew of languages nowadays
05:11:26 <dozer_> the overall thrust of the GOF where you seperate out concerns is universal good programming style - it's just that in different languages different bits of concern seperation come for free, or have to be engineerd in
05:11:57 <kosmikus> bringert: the default formatting simply doesn't allow any linebreaks, I think. is this a huge problem?
05:12:00 <dozer_> jmelesky: but the motivation to hide stoorage structure from things needing to access elements still stands
05:12:22 <quicksilver> jmelesky: http://okmij.org/ftp/Haskell/#fold-stream
05:12:24 <lambdabot> Title: Haskell Programming: Miscellanea
05:12:34 <dozer_> just that haskell does it with mappable and foldable, rather than Iterable<E> :)
05:12:34 <quicksilver> jmelesky: is a rather high-level iterator abstraction for haskell
05:12:52 <bringert> kosmikus: no, not really. I have some inline code which is longer than one line in a few places, but I can format those manually.
05:12:59 <quicksilver> actually the simplest iterator pattern in haskell is simply 'toList'
05:13:12 <quicksilver> 'toList' sounds like it's a structure-transforming function
05:13:20 <dozer_> :)
05:13:21 <quicksilver> but because of lazy evaluation, it's actually an iterator
05:13:35 <quicksilver> this is pretty clever magic
05:13:50 <kosmikus> bringert: actually, I think linebreaks are allowed at operators
05:14:07 <bringert> ah, my code had no operators
05:14:18 <dozer_> well that's enouther thing - lazy languages need totaly different patterns for sequencing to eager ones - you'd never use a future in haskell in the same way you do in java.lang.concurrent
05:15:28 * quicksilver nods
05:16:01 <roconnor> @quickCheck \a b c d -> max a b + max c d == max (a+c) mac (b+d)
05:16:01 <lambdabot> Unknown command, try @list
05:16:08 <roconnor> @check \a b c d -> max a b + max c d == max (a+c) mac (b+d)
05:16:13 <lambdabot>   Not in scope: `mac'
05:16:17 <kosmikus> bringert: you could try adding a line %subst space = "\linebreak[1]\;"
05:16:21 <kosmikus> does this help?
05:16:26 <roconnor> @check \a b c d -> max a b + max c d == max (a+c) (b+d)
05:16:31 <lambdabot>  Add a type signature
05:16:45 <roconnor> @check \a b c d -> max a b + max c d == (max (a+c) (b+d))::Integer
05:16:51 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Bool'
05:16:58 <roconnor> @check \a b c d -> max a b + max c d == (max (a+c) (b+d)::Integer)
05:17:04 <lambdabot>  Falsifiable, after 2 tests: 1, -1, 1, 3
05:17:54 <gkr> Wow.
05:18:06 <gkr> @check \a b -> a == b
05:18:14 <lambdabot>  Add a type signature
05:18:32 <quicksilver> @check \a b -> a == b::Integer
05:18:39 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Bool'
05:18:43 <gkr> That makes what integer?
05:18:44 <quicksilver> @check \a b -> a == (b::Integer)
05:18:49 <quicksilver> the wrong thing, clear :)
05:18:52 <dozer_> rocnnor - you probably want something closer to (max a+c a+d) + (max b+c b+d)
05:18:55 <lambdabot>  Falsifiable, after 3 tests: -2, 0
05:18:58 <gkr> @check \a b -> a == b::Bool
05:19:04 <lambdabot>  Add a type signature
05:19:08 <quicksilver> that's correct but doesn't help it :)
05:19:09 <roconnor> @check \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (c+d)
05:19:13 <lambdabot>  Add a type signature
05:19:15 <quicksilver> it needs to know the type of a,b
05:19:16 <bringert> kosmikus: I get "! Paragraph ended before \addcontentsline was complete." from latex
05:19:17 <roconnor> @check \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (c+d::Integer)
05:19:25 <lambdabot>  Falsifiable, after 1 tests: 2, 1, 0, 2
05:20:03 <roconnor> no wonder it was so hard to prove
05:20:27 <quicksilver> @karma+ lambdabot -- saving roconner from wasting time proving stuff that isn't true
05:20:27 <lambdabot> lambdabot's karma raised to 50.
05:20:38 <roconnor> I already wasted the time
05:20:56 <quicksilver> @karma- lambabot -- stable door? horse has bolted :(
05:20:57 <lambdabot> lambabot's karma lowered to -1.
05:21:29 <kosmikus> bringert: that sounds like a very strange message for this change; are you sure?
05:21:31 <dozer_> @check \a b c d -> max a b + max c d == (max (a+c) (a+d)::Integer) + (max (b+c) (b+d))
05:21:42 <lambdabot>  Falsifiable, after 0 tests: 0, 0, 1, 0
05:21:48 <roconnor> crap
05:21:53 <roconnor> I really wanted this lemma
05:22:28 <quicksilver> roconnor: consider, you can reduce a arbitrarily low
05:22:35 <quicksilver> roconnor: without chaning the value of max a b
05:22:49 <quicksilver> roconnor: and  yet, it will change the value of a+c and a+d and hence max a+c a+d
05:22:53 <dozer_> @check \a b c d -> max a b + max c d == max (max (a+c) (a+d)::Integer) (max (b+c) (b+d))
05:23:00 <takamura> hi
05:23:06 <lambdabot>  OK, passed 500 tests.
05:23:10 <ndm> hi takamura
05:23:11 <roconnor> quicksilver: yep, I see why it is false
05:23:13 <dozer_> dang, I can be dumb sometimes
05:24:12 <bringert> kosmikus: yes. I don't understand latex error messages though. Here's more context:
05:24:16 <dozer_> can check to proofs, or just tests?
05:24:21 <bringert> Runaway argument?
05:24:21 <bringert> {\csname ext@\@captype {\write \@auxout {\string \@writefile {\csname \ETC.
05:24:21 <bringert> ! Paragraph ended before \addcontentsline was complete.
05:24:25 <roconnor> @check \a c d -> 0 < a ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp a d == clamp (a+a) (c+d::Integer)
05:24:31 <lambdabot>  Falsifiable, after 4 tests: 2, 2, -3
05:25:17 <kosmikus> bringert: I still don't believe it. As a test, adding %subst space = "\;" should be a noop and cause no error.
05:25:21 <kombinator> Is it possible to have classes A and B, where B is a subclass of A and to define a generic function for class A which behaves differently if type is also member of class B?
05:26:04 <dozer_> differently in what way? the 'difference' would need to be encded into class B somehow
05:26:15 <dozer_> unless you use the introspection stuff
05:26:30 <ndm> kombinator: no, i don't think so
05:26:49 <kombinator> that's a shame...
05:27:05 <quicksilver> well you can acheive that effect
05:27:11 <bringert> kosmikus: the line it complained about was a |...| in a figure caption. When I remove that, the other inline code works fine.
05:27:14 <quicksilver> but the 'different' needs to be realized by a method
05:27:14 <ndm> yeah, lots of things with type classes are unfrotunate
05:27:25 <kombinator> I guess I would have to add a method with a default implementation to class A
05:27:30 <bringert> kosmikus, but that code in the caption worked fine with the subst
05:27:37 <kombinator> but I don't have access to class A...
05:28:13 <ndm> kombinator: class A x => B x where method_b = inefficient_in_terms_of_A
05:28:38 <ndm> kombinator: then hope your instances overlap in the correct unsafe way (hint, they won't, without Oleg+ level trickery)
05:28:43 <kosmikus> bringert: ok. so what about %subst space = "\protect\linebreak[1]\;"
05:30:36 <kombinator> ndm: in fact, I wanted to get something like this: pack objectInB = [existentialOfB objectInB]; pack _ = []
05:31:04 <bringert> kosmikus, works great, thanks!
05:31:10 <kombinator> ndm: of course resolved statically
05:31:25 <quicksilver> can't be resolved statically, though
05:31:27 <ndm> kombinator: read HList to see if its even possible, then email Oleg
05:31:41 <quicksilver> if you have a function which returns (A a) => a
05:31:47 <quicksilver> how can it possibly know statically if it's a B?
05:32:12 <kombinator> quicksilver: well, for class methods it can, I think
05:32:41 <kombinator> quicksilver: class B can provide alternative default implementations of A's methods
05:33:21 <hpaste>  bringert pasted "getting fancy quotes in lhs2TeX" at http://hpaste.org/1840
05:34:08 <bringert> kosmikus: I'm trying to get nice quotes for lhs2TeX string literals, but \" becomes "": http://hpaste.org/1840
05:35:58 <bringert> kosmikus, I modelled the subst on the ones in lhs2TeX.fmt
05:41:31 <kosmikus> bringert: I'm afraid the assumption that you use the tt font for strings is hardcoded.
05:41:57 <ndm> kosmikus: any way to get `f` to appear differently, i mean `anything`, i know you can override specific ones
05:42:39 <kosmikus> ndm: I have to check
05:42:57 <ndm> if there is, i couldn't find it in the documentation
05:44:07 <kosmikus> ndm: not surprised. look, almost 100% of the documentation is written by me, so it only contains stuff I'm actually aware of.
05:44:28 <ndm> thats fair enough, i really appreciate lhs2tex
05:45:07 <ndm> the only reason i ask for that one is because in my particular style it tends to look ugly with extra curly ` and italic innards
05:45:41 <kosmikus> yes, I agree that backquotes sometimes look suboptimal
05:47:27 <ndm> it is rarely an issue though, since usually they end up as a symbol
05:47:44 <kosmikus> that's what I do
05:50:22 <kosmikus> ndm: no, ` seems to be hardcoded as well; would require a patch
05:51:12 <kosmikus> but I'm willing to put both of these issues on the TODO list for the next lhs2TeX version
05:52:27 <ndm> kosmikus: thanks
05:53:25 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1841
05:54:01 <kombinator> ndm: I don't think I will study HList now, I didn't want to do anything fundamental, just save up some work
05:54:16 <kombinator> ndm: and I have already worked around it
05:54:53 <bringert> kosmikus: how come \text{\textquotedblleft \char92 \char34 \textquotedblright} becomes two left quotes and two right quotes?
05:57:04 <bringert> hmm, interestingly, \text{\texttt{\textquotedblleft \char92 \char34 \textquotedblright}} becomes \\""
05:57:07 <roconnor> @check \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (clamp a c + clamp b d)
05:57:08 <lambdabot>  Add a type signature
05:57:14 <roconnor> @check \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (clamp a c + clamp b d::Integer)
05:57:20 <lambdabot>  Arguments exhausted after 298 tests.
05:57:26 <bringert> is the left double quote the same character as backslash in some way?
05:57:31 <ndm> @scheck \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (clamp a c + clamp b d::Integer)
05:57:40 <lambdabot>   Completed 28561 test(s) without failure.  But 22477 did not meet ==> condit...
05:58:17 <ndm> roconnor: that actually constitutes a proof up to some depth
05:59:14 <roconnor> ndm: actually I want it for rational numbers :)
06:01:20 <ddarius> roconnor: I'm pretty sure if it works for Integers then it must also work for Rationals.
06:01:31 <roconnor> @scheck \a b c d -> 0 < a && 0 < b ==> let clamp x y = max (-x) (min x y) in clamp a c + clamp b d == clamp (a+b) (clamp a c + clamp b d::Rational)
06:01:32 <lambdabot>       add an instance declaration for (Serial (Ratio Integer))
06:01:32 <lambdabot>     In the exp...
06:03:48 <ddarius> @let data Foo = Bar | Baz
06:03:49 <lambdabot> Invalid declaration
06:05:57 <Saizan> Serial?
06:06:42 <ndm> Saizan: the smallcheck class
06:07:08 <chessguy> 'morning
06:15:35 <Saizan> TAPL is only available on paper?
06:17:22 <nominolo> @scheck x < 100
06:17:23 <lambdabot>  Not in scope: `x'
06:17:35 <nominolo> @scheck \x -> x < 100
06:17:42 <lambdabot> Add a type signature
06:17:54 <nominolo> @scheck \x -> (x :: Int) < 100
06:18:02 <lambdabot>   Completed 13 test(s) without failure.
06:18:10 <ndm> Saizan: as far as i know, but its an awful lot of paper
06:19:42 <nominolo> Saizan: there are not-so-legal ebook-rips on the web.  i prefer my paper-version though
06:19:54 <mux> I downloaded it illegally
06:19:56 <mux> and am going to buy it
06:20:06 <mux> the versions you can find on the web suck, it's .chm stuff
06:20:11 <mux> and .pdf converted from the .chm :-P
06:20:23 <mux> I wanted to first know if it was going to match what I wanted
06:20:27 <mux> and it's just great
06:20:42 <nominolo> mux: you know this channel is logged? ;)
06:20:56 <mux> nominolo: *shrugs*
06:21:05 <ddarius> > let bitrev :: [a] -> [a]; bitrev [x] = [x]; bitrev xs = uncurry (++) $ unzip $ bitrev $ group2 xs where group2 [] = []; group2 (x:y:xs) = (x,y):group2 xs in bitrev [0..15]
06:21:07 <lambdabot>  [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]
06:21:10 <mux> I don't expect Benjamin Pierce to wait for me on my doorstep with a stick
06:21:17 <mux> or whatever :-)
06:21:25 * ibid notes that downloading is generally legal
06:21:45 <mux> and I suppose he wouldn't mind people downloading stuff just to make sure of what they're going to buy anyways
06:21:46 <ibid> it's the uploader or the provider who is breaking the law
06:22:01 <mux> because it's sincerely just what I did :-)
06:22:10 <bringert> I can't believe I've never had to do this before: how do you get a literal backslash in latex text mode?
06:22:12 <nominolo> mux: yep. i regard this as fair, too.
06:22:14 * ibid likes ebooks for fiction
06:22:21 <Igloo> ibid: You aren't handling stolen goods, or similar?
06:22:23 <ibid> DRM-less, legal ebooks
06:22:40 <ibid> Igloo: no, you aren't, of course laws vary from country to country
06:22:41 <takamura> hi
06:22:47 <mux> I've read the whole harry potter series as illegal ebooks :-P
06:22:49 * mux blushes
06:22:54 <kolmodin> bringert: \backslash
06:23:01 <mux> and I liked it. *double-blush*
06:23:13 <bringert> kolmodin: no, that seems to be in math mode, afaict
06:23:13 <quicksilver> I don't think ibid is right
06:23:18 <kolmodin> ah
06:23:19 <ibid> Igloo: but the general rule, copyright only covers distribution and commercial copying
06:23:23 <ibid> quicksilver: i do :)
06:23:23 <quicksilver> the act of copying, is copyright infringement
06:23:26 <bringert> ah, \textbackslash
06:23:29 <quicksilver> and downloading is copying
06:23:37 <ibid> quicksilver: no it isn't if you do it for private use
06:23:39 <mux> quicksilver: come and get me! :D
06:23:45 <igli> yes it is
06:23:45 <ibid> quicksilver: for commercial purposes it is
06:23:52 <quicksilver> ibid: neither the US nor EU law have 'private use' exceptions
06:23:55 <ibid> quicksilver: of course, this varies from country from country
06:23:59 <quicksilver> ibid: you have swallowed some propaganda
06:24:01 <mux> quicksilver: they do
06:24:05 <ibid> quicksilver: EU law most definitely does!
06:24:06 <igli> fair use
06:24:09 <mux> I'm living in the EU and there are such exceptions
06:24:10 <quicksilver> fair, yes
06:24:10 <igli> of owned works
06:24:13 <quicksilver> private, now
06:24:14 <shapr> Good morning #haskell!
06:24:16 <ibid> quicksilver: i have read the actual law
06:24:21 <kolmodin> good morning shapr!
06:24:25 <quicksilver> ibid: I'd be interested in a reference
06:24:28 <shapr> hej kolmodin!
06:24:29 <ibid> quicksilver: studied it in quite a detail
06:24:37 <igli> and for academic work i believe so maybe
06:24:48 <ibid> quicksilver: the law is my reference. i can give you a precise citation for finnish law if you like
06:24:54 <igli> it still counts as copying tho
06:25:06 <quicksilver> and online citation for EU law would be more helpful :)
06:25:09 <igli> ah ok
06:25:14 <igli> not EU level no
06:25:15 <quicksilver> I don't claim to know anything about finnish law
06:25:18 <Saizan> here you can only copy 15% of a book for private use
06:25:20 <mux> and as soon as amazon is nice enough to send me the TAPL, the copy I have on my computer will become legal
06:25:30 <mux> well, as soon as I receive it
06:25:36 <igli> hehe
06:25:45 <igli> not necessarily
06:25:55 <ibid> quicksilver: i might be able to give you a cite on the international treaties though that govern both EU and USA copyright law
06:25:55 <mux> igli: in .fr a least it is
06:26:05 <mux> you have the right to do at least one personal copy of stuff you bought
06:26:21 <mux> so having a copy of the book on my PC is 100% legal
06:26:21 <igli> it could be construed that you already have title to an electronic work if you have paid for it
06:26:29 <igli> s/construed/held/
06:26:35 <mux> that just wouldn't hold
06:26:36 <ndm> mux: you have a right _to make_ one copy, not to illegally download one copy
06:26:49 <ndm> mux: you'd need to spend some time with a scanner :)
06:26:58 <mux> ndm: sure, but once I have t he book you can't say which is which
06:27:01 <mux> and noone is going to bother anyways.
06:27:03 <ndm> (not that anyone cares...)
06:27:08 <mux> yup
06:27:10 <ibid> quicksilver: the reference for finnish copyright act is section 12
06:27:22 <igli> yeah they're right, and no no-one cares atm about books
06:27:47 <igli> imo
06:27:54 * mux notes he still has the advanced TAPL pdf and he hasn't ordered the book though
06:27:58 <mux> woops
06:28:02 <igli> hehe
06:28:10 <ndm> i just borrowed my copy of TAPL
06:28:11 <igli> send in the police state!
06:28:18 <ndm> cheap, and more conenient
06:28:23 <mux> that would be pretty bad :-)
06:28:34 <mux> anyways, I have so many MIT Press ebooks...
06:28:44 <mux> not my fault if they write so cool books
06:28:45 <mux> heh
06:29:16 <igli> what is TAPL anyhow? *hides*
06:29:29 <mux> advanced types and programming languages
06:29:34 <igli> ah ok
06:29:37 <mux> err, stirp the advanced
06:29:38 <mux> that's part 2
06:29:44 <igli> i'll search
06:29:46 <igli> ok
06:29:50 <mux> from Benjamin C. Pierce
06:29:52 <mux> very very nice
06:29:53 <shapr> @go types and programming languages pierce
06:29:55 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:29:55 <lambdabot> Title: Types and Programming Languages
06:29:57 <mux> someone in hered recommended it to me
06:30:03 * shapr joins the herd
06:30:03 <igli> ty
06:30:06 <mux> and I thank him, whoever it was
06:30:11 <shapr> oh, you said here
06:30:18 * shapr moos quietly
06:30:24 <mux> heh
06:30:26 <ddarius> Moral of the story: The law is what is enforced, not what is written.
06:31:00 <igli> hmm
06:31:06 * shapr enforces the law of #haskell !
06:31:18 <igli> trouble is a lot of bad laws come in like that
06:31:25 <igli> then get enforced later
06:31:45 <igli> usu for a totally diff thing to what was in primary leg
06:31:47 * mux wonders what is the law of #haskell
06:31:52 <igli> lol
06:32:04 <ddarius> igli: ?  Then don't have them come in like that.  Would it be better if they were enforced immediately?
06:32:10 <mux> Thou Shalt Not Enter Here Without Your Haskell Compiler
06:32:17 <igli> "Thou shalt have no other languages before me."
06:32:38 <LoganCapaldo> "Two men enter, one man leaves"
06:32:45 <igli> "For I am the Haskell thy One True Code" ;)
06:32:47 <LoganCapaldo> Oh wait, thats #thunderdome
06:32:52 <igli> lol
06:33:25 <mux> thou shalt think on the function-level, data is for wimps
06:33:39 <ddarius> functions are data, data are functions
06:34:10 <Saizan> think in types, and think of your types as propositions
06:34:13 <mux> yes but thinking on the function-level /= thinking on the data-level
06:34:27 <igli> yes but don't proposition me ty ;)
06:34:28 <chrismbrown> actually it's very useful to design the data types first, and then let the functions follow
06:34:41 <igli> "Heretic!"
06:35:14 <LoganCapaldo> Thou shalt not commit unsafePerformIO
06:35:18 <ibid> quicksilver: section 29 of the UK law seems to say something similar as the finnish one (though it's not as wide in scope)
06:35:21 <shapr> mux:  "Be nice" (or else)
06:35:46 <mux> shapr: sorry?
06:35:54 <shapr> mux: That's the law of #haskell
06:35:57 <mux> oh
06:36:10 <LoganCapaldo> There is only one Language Haskell and Simons are its prophets
06:36:14 <mux> lol
06:36:47 * ndm points out that the Simons are responsible for less than 1/5th of the available Haskell compilers
06:36:57 <mux> Forgive me my Lord Haskell because I have sinned
06:37:06 <igli> lmao
06:37:06 <mux> I used to write imperative code
06:37:16 <mux> and I even enjoyed it :-(
06:37:17 <quicksilver> ibid: can you get that on a web reference?
06:37:22 <LoganCapaldo> ndm: its funnier becuase here are two simons though
06:37:28 <igli> "Thou shalt not commit unsafePerformIO"
06:37:30 <LoganCapaldo> *there
06:37:35 <quicksilver> ibid: I think UK statutes are supposed to be all online
06:37:39 <igli> LoganCapaldo: excellent!
06:37:49 <ndm> quicksilver: some you have to pay for, since they are crown copyright
06:37:55 <mux> ndm: yes but the one they're working on attracts maybe 90% of the haskell users :-P
06:37:56 <igli> quicksilver: oh no
06:37:57 <ibid> quicksilver: also section 34 of the EUCD allows memer states to provide such exceptions
06:38:12 <ibid> quicksilver: for EUCD, i'm looking at http://ukcdr.org/issues/eucd/eucd.html
06:38:14 <lambdabot> Title: EUCD - The Annotated Web Ready Version
06:38:30 <ndm> mux: today, but years back nhc was more popular, and one day something else may be more popular
06:38:31 <ibid> quicksilver: for UK, i was looking at http://www.opsi.gov.uk/acts/acts1988/Ukpga_19880048_en_1.htm
06:38:34 <lambdabot> Title: Copyright, Designs and Patents Act 1988 (c.&#160;48)
06:38:36 <mux> ndm: but I'm sure you are in the process of changing that :-)
06:38:39 <igli> they are supposed to be free
06:38:41 <ndm> mux: of course ;)
06:38:57 <ibid> quicksilver: note that i might have mistaken as to whether those are the correct versions
06:39:07 <igli> but hey if you can chuck the Magna Carta, what's a bit of Creative Commons?
06:39:32 <ibid> quicksilver: the US law has a very vague exception for "fair use", the interpretation of which is beyond my capabilities :)
06:39:53 <ibid> quicksilver: i couldn't find an english translation of the finnish law, sorry
06:40:02 <igli> heh the US has been royally ***ed
06:40:46 <quicksilver> ibid: ok, but the key point in the UK is 'fair dealing'
06:40:57 <quicksilver> ibid: taking a verbatim copy of the whole work is not 'fair dealing'
06:41:03 <quicksilver> (fair use is the more modern term)
06:41:36 <quicksilver> 'fair dealing' includes, for example, making a copy of a page and showing it to a friend to stimulate a discussion or prove a point
06:42:27 <dcoutts> mux: hia
06:42:31 <dylan> "fair use" in the US depends on who you are, too.
06:42:46 <dozer_> uk fair use covers taking the piss
06:42:50 <ibid> quicksilver: well, that's a matter of interpretation, which i decline to do for UK law which i am not conversant aboujt :)
06:43:13 <ibid> quicksilver: "fair use" is the US term, btw, i don't think this has anything to do with "modern" or otherwise
06:43:29 <mux> dcoutts: hi, I've stepped onto yet another c2hs bug and this one is clearly real, there's a non-exhaustive pattern match
06:44:00 <quicksilver> ibid: ok, but perhaps the US term has become the 'modern term' in the UK due to media exposure :) I can only hypothesise
06:44:13 <mux> dcoutts: c/CTrav.hs, line 686
06:44:18 <dozer_>  Magna Carta, contrary to popular belief, was a contract between the king and the 2nd tier nobility, not between the king/state and the common man, but it was the first step towards us moving from a warlord-state to a supported monarchy
06:45:00 <mux> dcoutts: I've hit the problem when running c2hs on some header
06:45:02 <dcoutts> mux: the last one was a real limitation too
06:45:11 <dcoutts> mux: right, lemme have a look
06:45:17 <mux> yeah it was :)
06:45:34 <mux> I still need to write to the c2hs mailing list
06:45:41 <mux> I'm such a freaking bug magnet
06:45:48 * Saizan wonders if you can write a comonad transformer
06:45:56 * mux brb, cig &
06:46:08 <igli> the thing is copyright has been extended as have corporate charters (much bigger issue)
06:46:10 <dcoutts> mux: so that's checkForOneCUName I presume?
06:46:17 <mux> dcoutts: yes
06:46:27 <mux> dcoutts: I'm back in a few minutes :-)
06:46:32 <dcoutts> 'k
06:46:36 <ibid> quicksilver: my unofficial translation of the finnish law section follows:
06:46:44 <ibid> >> (p1) Anyone may create a few copies of a published work for their own private use. Such a copy may not be used for other purposes. (p2) It is permissible to have s omeone else create such a copy for the private use of the person for whom it is being made. (p3)  What paragraph 2 says does not apply to musical compositions, motion pictures, functional pieces or sculpture, and neither does it apply to th e copying of an artistic work by artictic
06:46:50 <ibid> >> means. (p4) What the preceding paragra phs say does not apply to a computer program in machine-readable form, nor to th e creation of a machine-readable copy of a machine-readable database nor the con struction of a building.
06:47:31 <igli> what about human-readable? or is that covered by machine?
06:47:44 <igli> (since machine parses it)
06:47:46 <ibid> igli: they're orthogonal
06:47:55 <igli> hmm
06:48:00 <ibid> igli: the point is, "machine-readable" means stuff on your hard drive etc
06:48:14 <igli> yeah but a machine reads a source file too
06:48:20 <dozer_> there is a clause somewhere about computational translation e.g. the rot-13 version of the ascii representation of a poem is owned by the owner of the ascii representation of that poem
06:48:30 <ibid> igli: source files on hard drive are machine readable
06:48:52 <ibid> quicksilver: the conclusion seems to be, it depends on the jurisdiction :)
06:48:56 <igli> so all src as well then (effectively)
06:48:59 <quicksilver> ibid: I believe that is unusual; that is, I don't believe it is true is most EU states or the US
06:49:09 <quicksilver> ibid: it's rather a nice little law though and I envy you it :)
06:49:09 <igli> no it doesn't actually
06:49:13 <ibid> quicksilver: :)
06:49:20 <dcoutts> mux: so I presume the pattern match failure is in "case declaredDeclr decl of" rather than the top level function pattern?
06:49:22 <ibid> igli: well, not if you print it out :)
06:49:24 <igli> Berne Convention or whatever it was
06:49:39 <igli> ibid: you just copied it
06:50:09 <ibid> igli: fair enough.  say you got a copy of TeX The Program from the library :)
06:50:14 <igli> a bit like GATT Accords; no one is actually aware of it
06:50:19 <ibid> igli: that's not machine readable
06:50:28 <igli> scanner?
06:50:39 <igli> machine typeset it
06:51:00 <igli> was already in machine form to produce book
06:51:07 <ibid> igli: i was under the impression you were asking for the interpretation of "machine-readable copy"
06:51:25 <bringert> join #latex
06:51:28 <bringert> eh
06:51:49 <ibid> igli: the Berne Convention specifies the minimum requirements for the copyright protection, it does not specify all of it
06:51:52 <igli> ok cool; i am just pointing out that "interpretation" changes; primary legislation has to be overridden by further primary leg
06:52:00 <ibid> igli: incidentally, i've read the Berne Convention :)
06:52:07 <igli> heh i couldn't do it ;)
06:52:31 <ibid> ive also studied the WPO copyright treaty
06:52:42 <mux> dcoutts: yes
06:53:09 <mux> dcoutts: I've added a _ -> Nothing for the inner case and it seemed to fix the problem but I have no idea if it's good or not
06:53:12 <dcoutts> mux: I think I've found it, let me email you the patch and if it cures the problem for you then I'll apply.
06:53:21 <mux> oki
06:54:09 <igli> ibid: are you a lawyer then?
06:54:36 <igli> btw have you seen the GATT accords ibid?
06:54:42 <ibid> igli: IANAL :)
06:54:54 <igli> heh np me neither :)
06:54:56 <ibid> igli: but i do play one in a courtroom. (well, actually not)
06:55:00 <igli> lol
06:55:05 <igli> my granddad was
06:55:19 <ibid> (i'm a lay judge in the local district court. more to the point, i am a debian developer:)
06:55:58 <dcoutts> mux: http://haskell.org/~duncan/c2hs/cprtdeclr-fix.patch
06:56:26 <ibid> igli: (in case you want to know, a lay judge is sort of a cross between an english magistrate and an american juror, closer to the former though)
06:56:41 <igli> ah ok
06:56:59 <igli> that explains it :)
06:57:19 <ibid> igli: (for obvious reasons, the swedish nÃ¤mdeman is a very close parallel)
06:57:38 <igli> is that where we get ombudsman?
06:58:03 <ibid> igli: well, we only sit criminal cases. my interest in copyright law really comes from my debian work
06:58:16 <igli> ok
06:58:56 <ibid> igli: ombudsman is swedish. i don't know of any other connection :)
06:59:18 <igli> heh just checking worked for some Norwegians a while ago
06:59:45 <igli> man apparently, according to GATT, a member state is not allowed to re-nationalise a privatised industry no matter what its people decide
07:00:03 <shapr> @yow !
07:00:04 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
07:00:05 <igli> hence the UK "not quite" renationalised RailTrack
07:00:36 <ibid> time to go, bbml :)
07:02:15 <shapr> Does anyone know of a google talk voip client that runs on debian/unstable/i386 ?
07:02:36 <ibid> igli: http://antti-juhani.kaijanaho.fi/newblog/archives/3 ... and i'm really gone now
07:02:38 <lambdabot> Title: Antti-Juhani Kaijanaho » Blog Archive » The Finnish Criminal Court System
07:02:50 <igli> thanks man
07:06:37 <monn> how long is pasted code in hpaste saved?
07:08:10 <quicksilver> forever, at the moment
07:08:12 <Saizan> indefinitely, unless you upset glguy by not putting a title
07:08:20 <quicksilver> maybe one day they'll need to truncate it
07:09:07 <monn> oh
07:09:16 <monn> may I paste non haskell code there?
07:10:10 <ndm> monn: yes, but don't set it to announce to the channel, unless its for the channel
07:12:22 <monn> :)
07:18:42 <tom_> hi, anyone here know if/how Yi will run on osx?
07:19:30 <mux> dcoutts: just confirmed that your patch fixes the problem
07:19:32 <mux> dcoutts: thanks
07:20:16 <igli> hpaste is awesome
07:32:43 <dcoutts> mux: great
07:36:37 <jmanson> hello all
07:36:59 <jmanson> igli: are you still on from last night?
07:37:05 <igli> fraid so :)
07:37:26 <jmanson> do you live in india or something?
07:37:54 <igli> no UK i just work whenever i feel like it; then crash for a coupla weeks
07:38:13 <igli> joys of homeworking ;)
07:38:29 <igli> might as well be in india tho ;)
07:38:41 <jmanson> well, could you help out a bit? i am trying to get state to work at all, so copied an example from the net, and it won't compile.
07:39:15 <jmanson> It's the second from the bottom on: http://www.haskell.org/hawiki/MonadState
07:39:16 <lambdabot> Title: MonadState - The Haskell Wiki
07:40:50 <jmanson> My error is: state.hs:14:0: parse error (possibly incorrect indentation)
07:40:58 <jmanson> But, indentation looks fine to me
07:41:10 <Saizan> which line is 14?
07:41:12 <ToRA> missing bracket end of line 12
07:41:19 <ToRA> jmanson ^
07:41:26 <ToRA> and line 15
07:41:31 <quicksilver> if ToRA isn't right, paste your code in hpaste
07:42:30 <Saizan> oh, yeah the two Selector definitions needs a ) to close the tuple
07:42:38 <mux> dcoutts: damn you! I darcs pulled the latest changes and now I need filepath!
07:42:41 <mux> :-)
07:42:45 <dcoutts> heh
07:43:04 <mux> @where filepath
07:43:05 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
07:43:06 <jmanson> ToRA: thanks a lot
07:43:09 <igli> jmanson: i know less hs than you man ;)
07:43:10 <chessguy_work> type FilePath = String
07:43:13 <chessguy_work> done :)
07:43:17 <dcoutts> mux: it's good for you :-)
07:43:21 <mux> chessguy_work: I wish that as enough :-P
07:43:40 <chessguy_work> filepath is an easy lib to install, what's the problem?
07:43:40 <jmanson> igli: you must be joking. i know nothing
07:43:41 <quicksilver> FWIW, I think that example is a bit fruit-loopy :P
07:43:45 <igli> lol
07:44:07 <ndm> mux: upgrade to GHC 6.6.1, and you'll have filepath installed by default
07:44:09 <dcoutts> mux: you can get the tarball from hackage, no need for the darcs version
07:44:30 <igli> well all i've ever done is fire up GHC and write about 3 lines of stuff
07:44:43 <jmanson> I pulled that code off a wiki, so i guess i can fix it
07:44:46 <chessguy_work> quicksilver: if nothing else, sample is a terrible function name, even for a sample
07:44:56 <mux> well
07:44:57 <jmanson> save some other noob some pain
07:45:01 <mux> I already installed the darcs version.
07:45:17 * mux hearts --user
07:45:30 <igli> yeah ++jmanson
07:45:42 <quicksilver> chessguy_work: layering StateT over IO is a bit cooky, especially for the purpose of an example
07:45:50 <chessguy_work> yeah
07:45:53 <chessguy_work> that too
07:45:55 <quicksilver> chessguy_work: the *main* point of State is to show that you can use state in pure code
07:46:52 <jmanson> aww man.. it says i'm not allowed to edit the page
07:47:16 <chessguy_work> just create a new page for it on the new wiki
07:47:20 <chessguy_work> @wiki
07:47:20 <lambdabot> http://www.haskell.org/haskellwiki/
07:47:59 <jmanson> chessguy_work: do you mean copy the whole page?
07:49:20 <chessguy_work> sure, if you want
07:49:58 <mux> omg, we get so great emails from people
07:50:16 <mux> we are a company selling contextual advertisement a la google adsense, and we receive stuff like this:
07:50:33 <mux> bastards, you defaced my website www.sabha.info.
07:50:33 <mux> Remove your message and restore all my data or I'll sue you. I am in the United Sattes, so you fucking french will lose the lawsuit.
07:50:36 <mux> Get it, you filthy scum? If you use the email id in this email to spam me, I will sue you for 1 million dollars.
07:50:41 <mux> hahaha
07:50:47 <Baughn> @version
07:50:48 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
07:50:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:51:07 <chessguy_work> haha
07:51:43 <mux> No matter what you do, you never underestimate the stupidity of people
07:52:09 <mux> he then went on accusing us to pay people in africa to deface sites without getting sued, because he was apparently hacked from an african ip
07:52:37 <mux> "You are paying people in Africa to hack sites so that you won't get caught."
07:53:43 <chessguy_work> it takes talent to be that stupid :)
07:53:52 <Botje> mux: "okay, your service is now canceled. Too bad you won't receive the $BIGNUM amount we owed you. bye!"
07:55:45 <mux> those guys get defaced by people who put some ad from our website to, erm, make profit with their defacement
07:55:52 <mux> so we get some of the blame afterwards
07:55:58 <Botje> oh
07:55:59 <mux> Botje: he isn't even one of our customers actually :)
07:56:03 <Botje> nm then :)
07:56:18 <Guest88856> THIS IS BLASPHEMY!
07:56:21 <Guest88856> THIS IS MADNESS!
07:56:22 <Guest88856> THIS
07:56:23 <Guest88856> IS
07:56:26 <Guest88856> SPARTAAAAAAAAAAAAAAAAAAAA
07:56:35 <arcatan> sure
07:56:55 <flux> I never got the sparta jokes. perhaps seeing the movie would help. I'm not quite certain I'd like to get them, though..
07:56:56 <matthew-_> awesome, I can make GHC hang, type checking, at 100% CPU usage and not produce any result
07:57:04 <Botje> Guest88856 :: Madness -> Sparta
07:57:16 <Baughn> flux: More to the point, you don't want to see the movie
07:57:18 <arcatan> flux: the movie looks awesome, but the plot sucks
07:57:22 <roconnor> matthew-_: are you using non positive data types?
07:57:30 <Botje> 300 is a nipplefest.
07:57:37 <matthew-_> roconnor: not sure what you mean by that
07:57:50 <dcoutts> Botje: surely it's Guest88856 :: Madness -> Sparta -> IO ()
07:57:50 <Baughn> matthew-_: Are you using a known degenerate case?
07:58:00 <matthew-_> Baughn: well I don't know of it! ;-)
07:58:18 <Baughn> matthew-_: Does the code look like something a human might plausibly write?
07:58:19 <roconnor> matthew-_: newtype Mu a = Roll { unroll :: Mu a -> a }
07:58:29 <roconnor> fix f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x)))
07:58:32 <Botje> dcoutts: well, it's always the same result, so it doesn't need to be in the IO monad, right? :)
07:58:35 <matthew-_> roconnor: err yeah, I have stuff like that in there
07:58:42 <dcoutts> Botje: heh heh
07:58:48 <matthew-_> Baughn: I'm human.
07:58:52 <roconnor> matthew-_: that would do it
07:59:02 <Botje> maybe guest8856 was using unsafePerformIO
07:59:05 <Baughn> matthew-_: A human who isn't actually /trying/ to break it, I mean
07:59:05 <Botje> that would explain the caps.
07:59:17 <matthew-_> Baughn: I'm not trying! I'm trying to do my PhD!
07:59:26 <Baughn> matthew-_: Ah. That would do it.
07:59:51 <matthew-_> roconnor: that fix there, is that coinduction?
08:00:19 <roconnor> matthew-_: no, it's just the Y combinator
08:00:34 <Baughn> matthew-_: Going down the checklist.. Are you sure it's hanging in the typechecker? Have you tried adding type signatures to everything?
08:00:45 <roconnor> if you remove all the Roll and unroll's you see the Y combinator
08:01:00 <roconnor> and since it is a newtype, Roll and unroll is essentially a noop
08:01:01 <matthew-_> Baughn: I have about a 10-line to 1-line ratio of type sigs to code
08:01:18 <Botje> your type sigs are 10 lines each?
08:01:25 <matthew-_> I have some big type sigs
08:01:33 <matthew-_> 20 lines odd is the biggest
08:01:35 <Botje> i'd sulk if I had to check that too
08:01:39 <matthew-_> and 90% of that is context
08:02:05 <matthew-_> Baughn: and it's hanging in ghci on a :t blah blah
08:02:16 <roconnor> matthew-_: the NOINLINE pragma at certin spots allows the function I gave to compile in GHC.
08:02:36 <roconnor> matthew-_: http://www.haskell.org/pipermail/haskell/2006-September/018498.html
08:02:38 <lambdabot> Title: [Haskell] How to define Y combinator in Haskell, http://tinyurl.com/22xtcf
08:03:44 <matthew-_> roconnor: ok, I do have the Mu stuff, but I'm not explicitly using fix. I do have explicit recursion though which I guess could be causing it?
08:04:07 <Baughn> matthew-_: That's a bit outside my experience. Out of curiosity, what are you doing with 10-line type signatures?
08:04:48 <roconnor> matthew-_: The problem with my definition of fix, is that the inliner is repeated inlining code.
08:04:53 <Botje> > unwords $ join ("heh":) []
08:04:54 <lambdabot>  Couldn't match expected type `[[Char]] -> [String]'
08:04:57 <roconnor> is there a way to just turn off the inliner?
08:05:03 <roconnor> to test to see if that is the problem.
08:05:06 <matthew-_> Baughn: well, a lot of type-level programming. I'm lifting Session Types into the haskell type system.
08:05:11 <Botje> > join ("heh":) []
08:05:16 <lambdabot>  Couldn't match expected type `(->) [[Char]]'
08:05:33 <Botje> what the ..
08:05:35 <matthew-_> -Onot ?
08:05:50 <matthew-_> there's -fno-pre-inlining
08:06:00 <quicksilver> Botje: 'join' applies the same argument twice to a two-arg function
08:06:06 <quicksilver> Botje: that doesn't seem to be what you're doing there
08:06:08 <Botje> oh yeah
08:06:10 <Botje> boo :[
08:06:37 <quicksilver> > join (++) "heh"
08:06:43 <Botje> > unwords $ join (++) ["heh"]
08:06:53 <lambdabot>  "heh heh"
08:06:53 <lambdabot>  thread killed
08:07:10 <Botje> why's \bot so sluggish lately? heat?
08:07:27 <quicksilver> lag to its machine, perhaps
08:08:15 <Botje> myeah :/
08:08:39 <roconnor> matthew-_: hmm, but you said you are dying at type-checking time.
08:08:57 <matthew-_> roconnor: yeah, and there's a memory leak as ghc eventually gobbles up all my ram
08:09:07 <matthew-_> well, it may not be a leak...
08:09:16 <gleb> Hi all! Can anyone please tell me how do I make inferior-haskell-type actually insert type signature into buffer? Doc string says in can be done interactively but I cannot figure out how
08:09:49 <roconnor> matthew-_: right, so you have a different problem :(
08:10:17 <matthew-_> roconnor: I'll happily send you the code, but it's big and complex
08:10:29 <roconnor> matthew-_: I'm afraid I won't have any ideas
08:10:41 <matthew-_> roconnor: np
08:10:41 <roconnor> the inlining thing is the only problem I am aware of
08:10:47 <roconnor> I thought it might be that
08:10:56 <roconnor> but that is a compilation problem.
08:11:01 <Saizan> gleb: the command is C-u C-c C-t when you ahve the cursor on a definition, you have to C-c C-l first, and be sure to be using inf-haskell
08:11:38 <gleb> Saizan: thanks a lot!
08:11:54 <Saizan> ?wiki haskell mode
08:11:55 <lambdabot> http://www.haskell.org/haskellwiki/haskell_mode
08:12:39 <Saizan> gleb: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use
08:12:42 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
08:13:58 <matthew-_> roconnor: ok, I'll file it as a bug
08:14:18 <gleb> Saizan: I googled before asking, but google got me to another page, which didn't mention C-u trick. Thanks again
08:14:43 <Saizan> gleb: yeah, it's not an easy page to find
08:15:56 <bringert> kosmikus, this solved the backslash problem: \usepackage[T1]{fontenc}
08:15:57 <bringert> \usepackage{ae}
08:16:20 <quicksilver> Saizan: why does that first page exist?
08:16:32 <quicksilver> Saizan: it appears to have no value :) could it redirect to the second?
08:18:22 <Saizan> i don't thnk it exist
08:18:39 <Saizan> ?wiki Blah
08:18:40 <lambdabot> http://www.haskell.org/haskellwiki/Blah
08:18:45 <matthew-_> roconnor: just checking - that issue with fix only blows up ghc after the type checker?
08:19:07 <Saizan> it's ?wiki that's quite dumb, as well as ?hackage
08:20:59 <roconnor> matthew-_: yeah, I just checked.
08:21:09 <roconnor> *Main> :type let fix f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x))) in fix
08:21:09 <roconnor> let fix f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x))) in fix :: (a -> a) -> a
08:21:25 <matthew-_> roconnor: thank you
08:21:40 <roconnor> ... I don't suppose you are using allow_undecidable_instances?
08:21:41 <quicksilver> Saizan: Oh, I see :)
08:21:48 <roconnor> because that is undecidable.
08:22:08 <roconnor> or so I've been told
08:22:50 <matthew-_> roconnor: err yeah, I am
08:22:56 <matthew-_> roconnor: I have many flags on!
08:23:14 <matthew-_> roconnor: but I've not had a problem so far with  allow_undecidable_instances
08:29:48 <eumenides> the haskellwiki search is absolutely terrible. it's more productive to just hit "random page" until you find what you're looking for
08:31:15 <dozer_> lol, that is a good enough search strategy to be implemented inside "Live Search" ... why not in the wiki?
08:35:58 <matthew-_> roconnor: I thought that with allow_undecidable_instances, termination is guaranteed by using a fixed context stack
08:36:10 <matthew-_> roconnor: I've written code which blows up the context stack
08:36:42 <matthew-_> roconnor: yes, that's right, see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#undecidable-instances
08:36:44 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
08:41:05 <roconnor> matthew-_: oh interesting.
08:42:59 <matthew-_> roconnor, Baughn: the code is now at http://hackage.haskell.org/trac/ghc/attachment/ticket/1353/Session.hs so if you want to see the crazy big type sigs...
08:43:02 <lambdabot> Title: #1353: Session.hs - GHC - Trac, http://tinyurl.com/37sf7x
08:43:24 <sm> morning all
08:44:01 <andrei> Hi; if I need a fast binary vector in Haskell; what would be the best choice?
08:45:16 <sjanssen> andrei: do you need mutability?
08:46:04 <andrei> It might improve performance by quite a bit; but it's not necessary
08:46:22 <sjanssen> UArray or IOUArray might work
08:46:51 <sjanssen> when used with Bool they automatically pack bits to bytes
08:47:13 <andrei> Thanks; I had no clue
08:47:22 <chessguy_work> hmm, is mutability ever strictly necessary? isn't it always an efficiency issue?
08:47:40 <andrei> I saw them, but feared they would be too slow
08:48:23 <sjanssen> andrei: lookups should be reasonably fast (especially if you use to unsafeAt and friends)
08:48:35 <sjanssen> what operations will you use?
08:48:41 <assl0r> > \x -> x
08:48:43 <lambdabot>  Add a type signature
08:49:18 <opqdonut> ?src id
08:49:18 <lambdabot> id x = x
08:49:25 <opqdonut> ?unpl id
08:49:25 <lambdabot> (\ a -> a)
08:49:30 <opqdonut> ^_^
08:49:34 <andrei> sjanssen, Taking slices of that vector and combining it with slices of a different one
08:57:36 <erider> good evening all
08:58:08 <opqdonut> hi erider
08:59:15 <kosmikus> bringert: backslash problem?
09:00:15 <kosmikus> kolmodin: \usepackage{ae} is nonsense, btw. most fonts should have T1-encoded variants, and ae is just a hack that was useful in the times that standard TeX fonts were not properly encoded.
09:00:35 <kosmikus> I meant bringert, not kolmodin
09:01:17 <bringert> kosmikus: without it, some letters looked a bit crappy in acroread
09:01:55 <bringert> kosmikus: by backslash problem I meant that weird things happend when I wanted a non-tt for string literals
09:02:08 <bringert> non-tt *font*
09:05:54 <bringert> kosmikus: hmm, maybe I just imagined that
09:06:17 * bringert goes home
09:06:26 <kolmodin> luxury!
09:08:34 <LeCamarade> @slap nonexistent
09:08:35 <lambdabot> why on earth would I slap nonexistent
09:08:42 <LeCamarade> @slap -f nonexistent
09:08:43 * lambdabot smacks -f nonexistent about with a large trout
09:08:47 <LeCamarade> ;oD
09:08:50 <kolmodin> haha!
09:10:48 <kosmikus> is it possible to find out the (relative to working dir) pathname of the current binary in a Haskell program?
09:12:08 <quicksilver> that is, in fact, impossible in a unix-like system
09:12:28 <kolmodin> quicksilver: due to links?
09:12:31 <ndm> kosmikus: no, which sucks muchly
09:12:41 <ndm> kolmodin: you can run a program from memory, never writing it to disk
09:13:02 <quicksilver> you can run a program which was orginally on disk but has since been deleted :)
09:13:10 <quicksilver> and many other permutations of that idea
09:13:10 <ndm> its the beauty to unix throwing away the common case to make the obscure case nicer
09:13:10 <kolmodin> ndm: ah, well. yes. but that must be a special case.
09:13:23 <kosmikus> ndm: thanks
09:13:47 <quicksilver> however, there is an API to get what the shell calls $0
09:13:47 <ndm> it is possible in windows, and i would like haskell to have a getProgramFile :: IO (Maybe FilePath)
09:13:57 <quicksilver> or at least, I thought there was
09:13:58 <kolmodin> I like to remove programs while they are running. I do it all the time :)
09:13:59 <quicksilver> can't find it though ;)
09:14:05 <mux> but since there is no 1:1 mapping in UNIX, it can't be right
09:14:16 <mux> between filenames and files, that is.
09:14:52 <chessguy_work> kolmodin: what a fascinating hobby. i bet the women love you :)
09:15:14 <quicksilver> oh, just getProgName is what I was thinking of. But it's only the leaf name
09:15:29 <kolmodin> chessguy_work: it's the effect of upgrading your system while you run it. and it's not as popular amongst the women as you might think
09:15:55 <chessguy_work> amazing
09:16:05 <dcoutts> quicksilver: well that depends on how the program was invoked, it could be the full path if it was invoked via a full name rather than using the $PATH
09:16:20 <quicksilver> dcoutts: not according to the docs
09:16:34 <quicksilver> dcoutts: "so instead, for maximum portability, we just return the leafname of the program as invoked."
09:16:40 <dcoutts> quicksilver: oh ok
09:16:50 <quicksilver> i.e. it isn't $0
09:16:55 <kosmikus> ndm: it's a Haskell-specific problem, not a Unix-specific one
09:17:03 * mux ponders getArgv0
09:17:09 <mux> would be such an horrible name
09:17:11 <mux> I already like it
09:17:20 <ndm> kosmikus: no, its a unix specific one, the reason for it not being in Hsakell is because its not reliable in Unix
09:17:31 <quicksilver> I don't see much harm in getArgv0
09:17:41 <quicksilver> but I would urge anyone thinking of using it for much, to reconsider
09:17:41 <kosmikus> ndm: says who?
09:17:45 <ndm> kosmikus: me :)
09:17:52 <quicksilver> IMO there is only one acceptable use of $0
09:18:02 <ndm> i want getProgName to return the entire name, as best it can guess
09:18:03 <kosmikus> ndm: original documentation: However, this is hard-to-impossible to implement on some non-Unix OSes, ...
09:18:04 <quicksilver> and that's in echo "Usage: $0 <options>"
09:18:30 <ndm> kosmikus: its trivial to implement on Windows, its impossible to implement on Unix - i don't think it was ever a good idea though
09:18:31 <quicksilver> otherwise, you're much better of trying to work out what your *real* objective is, and solving that problem
09:18:54 <kosmikus> ndm: why is it difficult to implement in Unix? C can do it ...
09:19:07 <quicksilver> kolmodin: argv[0] does not give you the path to your app
09:19:09 <ndm> kosmikus: it can return argv[0], not hthe path
09:19:16 <quicksilver> kolmodin: it just tells you how the shell chose to invoke you
09:19:20 <quicksilver> oops
09:19:25 <quicksilver> sorry kolmodin
09:19:30 <quicksilver> stupid lazy tab completion :)
09:19:43 <kosmikus> quicksilver: shell invocation would be enough for me
09:19:54 <dcoutts> kosmikus: on windows, the kernel prevents you from deleting the .exe of a running program, so there is always a file backing the currently running program. Unix lets you delete it, or just fork so you never had an executable image in the first place.
09:19:56 <quicksilver> kosmikus: you are aware that your shell is free to put 'ha-ha-tricked-you' in argv[0] if it chooses :)
09:20:14 <SamB_XP_> dcoutts: what about that new, actually-useful POSIX support?
09:20:19 <kosmikus> quicksilver: the user of such a shell deserves some problems
09:20:34 <dcoutts> SamB_XP_: huh?
09:20:51 <ndm> dcoutts - not true, you can delete the current file
09:21:00 <kosmikus> dcoutts: sure, I only want to use this info as a hint to auto-detect library files if an envvar isn't set. if it doesn't work, you can still give the information by other means.
09:21:13 <quicksilver> more 'sensible' reasons for not having the path are things like being launched into a chroot
09:21:13 <SamB_XP_> they tell me that on Vista there is *real* POSIX support
09:21:37 <quicksilver> kosmikus: but then I would (very likely) have symlinked your binary into /usr/local/bin
09:21:40 <dcoutts> ndm: oh ok, that must be new. Last time I looked you had to do really tricky hacks to do that. So what does the getProgramName function return in those cases?
09:21:53 <ndm> dcoutts - who knows...
09:21:58 <quicksilver> kosmikus: however looking for your library files in /usr/local/bin won't work, I suppose
09:22:03 <SamB_XP_> dcoutts: also, on unix it doesn't actually delete the file backing a running process afaik...
09:22:04 <kosmikus> quicksilver: there's no problem to follow symlinks.
09:22:07 <ndm> dcoutts - oh, you can't delete the file, but you can rename it on NT
09:22:10 <SamB_XP_> it just removes the *name*
09:22:19 <quicksilver> SamB_XP_: right. So the path no longer exists.
09:22:23 <dcoutts> SamB_XP_: right, just unlinks it from the directory structure
09:22:26 <quicksilver> SamB_XP_: and it's finding paths we're after here
09:22:29 <SamB_XP_> yeah.
09:22:40 <quicksilver> kosmikus: there is a problem following hardlinks, though :)
09:22:59 <SamB_XP_> well, /proc/self/exe might be of interest
09:23:12 <kosmikus> quicksilver: this is not what the Makefile would do, though. if you go and change the symlink that's been installed and replace it with a hardlink, it's your problem of choice.
09:23:16 <dcoutts> ndm: I used to work on an anti-virus update program which had to be able to update itself in addition to the other software it managed. We had to do some hairy things to work around the problem that we could not delete our own .exe file while upgrading ourself.
09:23:18 <SamB_XP_> but, that only works with Linux ABI
09:23:53 <quicksilver> kosmikus: that makefile would more profitably spend its time writing the location of the lib dir somewhere sensible
09:24:04 <quicksilver> kosmikus: most likely, in /etc/myapp.conf or ~/.myapp.conf
09:24:11 <dcoutts> ndm: I read articles at the time that you could use some low level NT kernel calls to unmap the view of the .exe file, but then you had to be really careful that you didn't need to swap.
09:24:20 <quicksilver> kosmikus: rather than futzing around with symlnks and trying to support a misguided feature...
09:24:59 <kosmikus> quicksilver: oh please, I don't want to justify what I'm doing. I just asked a simple question. you can be assured I'm somewhat familiar with Unix packaging standards.
09:25:38 <quicksilver> kosmikus: Ok, but since you don't pay me to answer, I'll answer as I choose :)
09:25:59 <kosmikus> quicksilver: fair enough
09:25:59 <quicksilver> kosmikus: I strongly disagree with the notion of depending on current location and I attempt to give you alternatives, which, personally, I think are better
09:26:11 <quicksilver> if you don't like them, it's your program :)
09:27:44 <kosmikus> a program shouldn't rely on being installed to a fixed location. so you can't reliably write to any global location. user's home dir is a no-go for the installer, because the installation shouldn't by default be user-specific. the classic workaround is envvars, and you can set an envvar in a shell-script that is installer-generated. the whole background of my question was to find out if there's an easy way to do it without a wrapper shell sc
09:28:43 <SamB_XP_> it would be really sweet if you could know where a program had been installed.
09:28:50 <SamB_XP_> when it was running.
09:29:02 <dcoutts> SamB_XP_: cabal generates a module which tells you that
09:29:12 <SamB_XP_> dcoutts: I meant in general ;-)
09:29:14 <quicksilver> I would have said the installer can reliably assume one of two possibilities: either it is being run as privileged user, and it can write to /etc (or /usr/local/etc, or similar); or it is being run as unprivileged user and it can safely write to $HOME/.app.conf
09:29:44 <SamB_XP_> so how is the installer to pass the info to the program?
09:29:51 <kosmikus> quicksilver: and how do you find out the prefix?
09:29:55 <SamB_XP_> oh, right.
09:30:00 <SamB_XP_> you assume a single install per user
09:30:34 <quicksilver> SamB_XP_: that seems a sane default; if you anticipate multiple versions being a common case you can instead default to $HOME/.app/1.1/conf
09:30:56 <quicksilver> we are merely discussing sane defaults, which can be overridden by users anyway, presumably
09:31:31 <kosmikus> quicksilver: in the privileged case, you have to respect the prefix; you shouldn't write to /etc if the priviliged user specifies /my/software/pkgs, and if you write to /my/software/pkgs/etc, you still have to get at that info
09:31:45 <matlads> @bot
09:31:46 <lambdabot> :)
09:31:53 <SamB_XP_> but, e.g., apparantly classic Mac apps could just be stuck wherever
09:31:54 <opqdonut> @botsnack
09:31:55 <lambdabot> :)
09:32:06 <SamB_XP_> that seems nice to me
09:32:27 <opqdonut> appdirs, yes
09:33:58 <quicksilver> kosmikus: privileged case, non-default-prefix, typically requires the app to have the chosen prefix compiled in
09:34:18 <quicksilver> kosmikus: unless the nature of the app is that you can safely substitute in place (e.g. script file wrapper)
09:34:36 * shapr boings cheerfully
09:34:48 <kosmikus> quicksilver: I'm just looking for better solutions.
09:34:56 <quicksilver> kosmikus: *nod*
09:35:17 <SamB_XP_> better solutions involve changes to Unix, I think
09:35:38 <quicksilver> OS X gives one alternative approach
09:35:46 <chessguy_work> @get-slap
09:35:47 <lambdabot> shapr!!
09:35:47 <quicksilver> it gives the app another piece of state at run time
09:35:56 <quicksilver> (I think just by setting the cwd)
09:36:28 <shapr> chessguy_work: You called?
09:36:39 <SamB_XP_> or, yeah, you could just change the interface to apps ;-P
09:36:49 <chessguy_work> no, i don't even have my cell phone handy
09:39:02 <SamB_XP_>  @get-slap?
09:39:04 <SamB_XP_> what is that for?
09:39:11 <ddarius> @help get-shapr
09:39:12 <lambdabot> get-shapr. Summon shapr instantly
09:39:19 <SamB_XP_> i.e. what was the intent behind saying that
09:39:27 <SamB_XP_> not what command is it and what is it for...
09:39:56 <SamB_XP_> ISTR comissioning that command. except I didn't offer any money ;-P
09:39:57 <chessguy_work> SamB_XP_: just messing with shapr
09:45:54 <dcoutts_> kosmikus: perhaps you've got some advice for us for cabal-install
09:46:33 <dcoutts_> kosmikus: I was thinking of putting a config file in the $HOME/.cabal/ which would have the defaults for what prefix etc to pass to cabal
09:47:15 <dcoutts_> kosmikus: we'd copy that config file from some default that was shipped with cabal-install, there would probably be different defaults for different platforms
09:47:43 <dcoutts_> kosmikus: the difficulty is knowing if we should install by default into some global location or a per-user location
09:48:09 <dcoutts_> kosmikus: trying to find out if we're root or non-root seems icky
09:48:46 <dcoutts_> but of course we cannot install to a global location without user intervention if we've just got ordinary user permissions
09:49:20 <shapr> hiya dpiponi
09:49:38 <dpiponi> hiya. You a bot or something. That was quick!
09:50:07 <dcoutts_> @get-shapr
09:50:07 <lambdabot> shapr!!
09:50:25 <ndm> dcoutts_ - just recommend that everyone logs in as root when working with haskell
09:50:26 <shapr> dcoutts_: You called?
09:50:29 <kosmikus> dcoutts_: so you want to detect where to install without any user interaction?
09:50:46 <shapr> dpiponi: People regularly accuse me of being a bot, but I'm not!
09:51:00 <dcoutts_> shapr: sorry, just testing the bot theory ;-)
09:51:03 <Vulpyne> That's what he's programmed to say.
09:51:13 * ndm has met shapr in real life, and still isn't sure if he's a bot
09:51:53 <dcoutts_> kosmikus: so the user says: cabal install lhs2tex, what happens? where does it get installed by default?
09:52:19 <dcoutts_> ndm: that would not be popular with unix folk :-)
09:52:29 <kosmikus> well, I'd go with the platform defaults. i.e., /usr/local on Unix. if there aren't sufficient permissions, it should fail.
09:52:40 <dcoutts_> kosmikus: so it'll fail by default
09:52:46 <dpiponi> What does @get mean to lambdabot?
09:53:00 <dcoutts_> kosmikus: the fact that the current error message isn't great makes this worse
09:53:22 <ndm> dcoutts_ having to run install/build/configure is not popular (or normal) with windows folk, this way its balanced
09:53:39 <kosmikus> dcoutts: wouldn't cabal configure already take a prefix and user/global specification?
09:53:46 <dcoutts_> ndm: right, cabal-install is supposed to be a single command tool, it does all the steps, and all the deps.
09:54:10 <dcoutts_> kosmikus: this is cabal-install, like emerge/apt it's a single command, not configure/build/install
09:54:30 <kosmikus> dcoutts_: ah, right. so it needs root permissions then. like emerge/apt ...
09:54:55 <dcoutts_> kosmikus: only if you want to install globally, it currently installs into a location inside $HOME/
09:55:04 <dcoutts_> so it works by default
09:55:13 <dcoutts_> but that also does not seem to be so popular
09:55:35 <kosmikus> so can you say cabal-install --global --prefix=/usr/local, too?
09:55:46 <dcoutts_> kosmikus: something like that, yes.
09:56:03 <ddarius> Having your logo be "Quality Chekd" does not inspire confidence.
09:56:32 <kosmikus> dcoutts_: that's fine with me. and you could have a cabal-install configuration file where you could reset the default.
09:56:43 <dcoutts_> kosmikus: yes, that's my plan
09:57:18 <kosmikus> dcoutts_: only thing I'd pay attention to is that if you specify a global prefix and don't have permissions, cabal-install should either allow you to resume after building and prior to installation, or fail in the beginning already.
09:57:46 <dcoutts_> kosmikus: yes, cabal should check that the appropriate dirs are writable
09:57:48 <kosmikus> dcoutts_: I'd prefer the first solution, because of course, I'd prefer building the package without being root, and I don't know if cabal-install currently drops permissions in the build phase.
09:57:58 <dcoutts_> it does not
09:58:04 <dcoutts_> but if you do it all as user it's ok
09:58:21 <kosmikus> I can't install a package globally as a user
09:58:25 <dcoutts_> right
09:58:44 <kosmikus> but just because I want to install it as root, I don't want to have to build it as root
09:58:48 <dcoutts_> hence the default of building and installing locally as user
09:59:11 <kosmikus> emerge solves this by dropping the privileges itself, and considering it should be a trusted program for Gentoo users, that's good enough.
09:59:24 <dcoutts_> yes, and using a sandbox
09:59:25 <arcatan> hey, in record definitions I see lines like "workspace :: !WindowSet". what the bang does?
09:59:36 <dcoutts_> but that's a very unixy solution
09:59:50 <dcoutts_> arcatan: it's a strictness annotation
09:59:50 <dmhouse> arcatan: is that in a datatype definition?
10:00:15 <arcatan> dmhouse: yeah
10:00:24 <kosmikus> dcoutts_: so how do I use cabal-install to build a package as user, and then install it as root?
10:00:36 <dmhouse> arcatan: it means that that parameter is strict. Are you familiar with strictness vs. laziness?
10:00:37 <dcoutts_> kosmikus: that's not directly supported.
10:00:46 <arcatan> dmhouse: not in datatypes
10:01:07 <kosmikus> dcoutts_: so if I try to install it in /usr/local as user, I'll get a cryptic error message after building the package and before installation?
10:01:19 <dcoutts_> kosmikus: currently, yes.
10:01:31 <kosmikus> dcoutts_: and if I then call cabal-install again as root, it will *rebuild* the package as root, or just do the installation?
10:01:45 <dcoutts_> kosmikus: probably rebuild
10:01:50 <dmhouse> arcatan: right, well say you have data T = C !Blah. Whenever you have 'C x' in your code, x will get evaluated (to WHNF), and an error will occur if it's bottom.
10:02:07 <kosmikus> dcoutts_: ok, that should be changed. if it just resumes where it failed before, it'd be fine with me.
10:02:14 <arcatan> dmhouse: okay, thanks
10:02:35 <dcoutts_> kosmikus: we shouldn't rely on it failing and then resuming, that's a bit of a hacky solution.
10:03:02 <kosmikus> dcoutts_: then I don't see a better one if you want to prevent doing everything as root.
10:03:20 <Cheery> dons: your Data.Binary rocks!
10:03:48 <dcoutts_> kosmikus: people have suggested using sudo (configurable by the user) or doing it as root and dropping priviledges
10:03:56 <dmhouse> arcatan: if you're still confused, I'd recommend perusing through the various untidy sections of http://en.wikibooks.org/wiki/Haskell/Laziness.
10:04:00 <dcoutts_> kosmikus: both are a little tricky
10:04:21 <chessguy_work> i seem to remember something about a CMS being done in haskell, anyone recall the name of it?
10:04:35 <jmanson> how do you add a page to the haskell wiki?
10:04:40 <kosmikus> dcoutts_: yes, I can imagine. but one of the two it probably should be then.
10:04:51 <dmhouse> jmanson: just visit that page and click 'Edit' at the top.
10:05:03 <chessguy_work> ?wiki MyNewPage
10:05:03 <lambdabot> http://www.haskell.org/haskellwiki/MyNewPage
10:05:04 <dmhouse> jmanson: same way that, e.g., Wikipedia works.
10:05:17 <dmhouse> chessguy_work: or My_new_page, to stick with naming conventions
10:05:27 <kosmikus> dcoutts_: or you create a cabal group and have all packages be installed to a directory belonging to that group, and require cabal-install users to be in that group.
10:05:35 <dcoutts_> kosmikus: how does one drop priviledges in unix anyway? change user id to nobody?
10:05:39 <jmanson> So, you just type in some address that doesn't exist yet?
10:05:45 <dmhouse> jmanson: yep
10:05:50 <Saizan> chessguy_work: "hope" maybe?
10:05:56 <jmanson> dmhouse: thanks
10:06:26 <kosmikus> dcoutts_: I think so, but I have to look it up again.
10:06:29 <dcoutts_> kosmikus: that'd work but it'd need some setup to make the dir and group and it'd mean we'd not be following standard unix conventions on install locations.
10:06:49 <chessguy_work> Saizan: i'll look, t hanks
10:07:07 <ddarius> jmanson: It should be linked from something, so edit the page to link to what you want then click on the link to create the new page.
10:07:19 <kosmikus> dcoutts_: true. it would work fine if all cabal ever does is install Haskell libraries, but for binaries it's difficult.
10:08:02 <ddarius> kosmikus, dcoutts_: How do other similar systems do it?
10:08:38 <jmanson> ddarius: ok. will do
10:08:44 <dcoutts_> ddarius: I don't know, we should probably investigate perl's cpan, and the equivalent systems in ruby and python.
10:09:52 <pejo> For CPAN you need to have write access in the installation directory in reality, doing it as a non-priviliged user (for packaging for example) tends to fail and you end up patching things.
10:10:54 <ddarius> Yeah, look at the existing solutions, find the one that pisses people off least and follow them unless you can beat them.
10:12:33 <pejo> (And it's really simple to verify a bunch of things for packages, much like debian does with something lintish).
10:13:42 <Saizan> mmh sudo-ing the install phase seems the least annoying solution to me
10:16:26 <dcoutts_> Saizan: however we'd have to get the user to sudo multiple times if there are many deps
10:16:57 <dozer_> just checking - if in a do block I call "is <- return map foo bar", will the map be expanded lazily as I chew on is further down?
10:16:58 <dcoutts_> or we'd have to install/register locally while building everything and then install all the packages in one go
10:17:20 <sjanssen> why not just run the whole thing as root?
10:17:21 <dcoutts_> dozer_: generally, yes
10:17:30 <dcoutts_> sjanssen: apparently that upsets people
10:18:00 <emu> dozer_: don't forget, return $ map foo bar
10:18:01 <ddarius> dozer: Module your syntax error, that's the same as let is = map foo bar
10:18:07 <dcoutts_> dozer_: if a monad is following the rules then yes
10:18:24 <dcoutts_> dozer_: and your specific example is equivalent to: let is = map foo bar
10:18:28 <sjanssen> dcoutts_: and how does their favorite package manager do it?
10:18:31 <ddarius> And I have to leave.
10:18:32 <emu> @quote stereo
10:18:32 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:18:54 <dcoutts_> sjanssen: some of them use sandboxes or drop privileges during the build steps
10:18:59 <sjanssen> I'd say require root in version 0.1, and build packages with dropped privileges in the next release
10:19:12 <kc5tja> dcoutts_: On my workstation here, I've written some scripts which make multiple invocations of sudo.  I only get asked for a password once though, since sudo has a timeout mechanism.  Maybe that would help?  (Haven't read the thread of discussion -- I've just arrived at work)
10:19:27 <sjanssen> if this is blocking progress, that is
10:19:45 <dcoutts_> sjanssen: yes, that's certainly the easiest. I'd also default to installing everything in $HOME with --global as an option which requires root.
10:20:20 <dcoutts_> kc5tja: yes, if it's quick enough then you'll get away with fewer sudo calls
10:20:25 <kosmikus> dcoutts_: it's a good compromise for a first version
10:20:37 <dcoutts_> @arr
10:20:37 <lambdabot> I'll keel haul ya fer that!
10:20:40 <dcoutts_> good good
10:21:29 <chessguy_work> @yow
10:21:29 <lambdabot> Used staples are good with SOY SAUCE!
10:21:43 <chessguy_work> @quote soy
10:21:43 <lambdabot> erg0t says: x k soy re gay
10:21:46 <kosmikus> dcoutts_: you don't need many sudo calls. in principle, you can start one root shell via sudo and pass all root-tasks to that shell.
10:21:59 <dcoutts_> kosmikus: ah yes, true.
10:23:22 <hpaste>  mnislaih pasted "filepath & ghc" at http://hpaste.org/1842
10:55:12 <shapr> Is there some way to automatically update the edoc with haskell-mode for my personal projects?
10:56:20 <liber> Who here was working on a haskell compiler?
10:56:45 <dcoutts_> liber: JohnMeacham_ works on jhc, Igloo works on ghc, ndm works on yhc
10:57:00 <liber> damn.. sorry
10:57:05 <liber> what I meant to say wa
10:57:12 <liber> Who here was working on a BRAINFUCK compiler?
10:57:18 <dcoutts_> heh heh
10:57:18 <liber> alot on my mind right now
10:57:24 <sioraiocht> liber: compiler or interpreter?
10:57:28 <sioraiocht> I was working on an interpreter
10:57:40 <liber> sioraiocht: would this run: http://www.muppetlabs.com/~breadbox/bf/factor.b.txt ???
10:58:11 <mauke> I have a working (but stupid) brainfuck compiler
10:58:21 <liber> mauke: http://www.muppetlabs.com/~breadbox/bf/factor.b.txt :))
10:58:47 <mauke> already compiled it
10:59:06 <mauke> liber: generated code: http://rafb.net/p/LTnyZe99.html
10:59:07 <lambdabot> Title: Nopaste - factor.s
10:59:14 <liber> What about an optimiser?
10:59:20 <arcatan> haskell is nearly same as brainfuck, anyway
10:59:51 <sioraiocht> liber: does it take input at somepoint?
11:00:01 <liber> sioraiocht: I have no idea
11:00:06 <mauke> factor.b? yes
11:00:17 <mauke> grep for getchar in my code
11:00:34 <liber> the guy who wrote it must be... ... I have no words!
11:00:35 <sioraiocht> liber: it worked
11:01:40 <sioraiocht> hehe I'm making it factor 2701, now
11:01:44 <sioraiocht> it's not very happy, lol
11:01:55 <liber> hehehe
11:02:43 <mauke> that takes 0.003s here
11:02:45 <sioraiocht> it factored 35 pretty fast
11:03:01 <sioraiocht> lol my interpreter doesn't promise to be fast, I'm working on it ;)
11:03:25 <mauke> 1238932857283742 took 22s
11:03:36 <liber> mauke: that is very good...
11:06:45 <sioraiocht> ps whoever wrote that is nuts
11:15:46 <LeCamarade> @uptime
11:15:46 <lambdabot> uptime: 7d 16h 54m 28s, longest uptime: 13d 18h 36m 21s
11:16:47 <jmanson> what is wrong with this data declaration? data Position = Position {(x :: Int, y :: Int)}
11:17:27 <Cheery> real unix-gurus keep penguins on their rooms, that's because they warn by dying when amount of lethal gasses rise high enough that it'd be time to open a window.
11:17:45 <mauke> jmanson: the parens
11:18:11 <jmanson> mauke: I want to store a tuple. can i not do that?
11:18:24 <jmanson> Mauke: or, rather, how do i do that?
11:18:50 <mauke> if you want a tuple, what are x and y for?
11:18:54 <kpreid> data Position = Position { xy :: (Int,Int) }
11:19:11 <kpreid> -- contains a tuple
11:19:12 <Saizan> or simply data Position = Position (Int,Int)
11:19:13 <vincenz> kpreid: data Position = Position {x :: Int, Y :: Int} ?
11:19:19 <kpreid> vincenz: that's two fields
11:19:21 <mauke> type Position = (Int, Int); x = fst; y = snd;
11:19:24 <vincenz> kpreid: why do you want 1 field?
11:19:35 <kpreid> vincenz: jmanson said he wanted to store a tuple.
11:19:39 <vincenz> oh
11:19:41 * vincenz nods
11:19:49 <vincenz> newtype Position = Position (Int, It) is best then
11:20:05 <jmanson> Ok. thanks
11:21:10 <jmanson> I wanted to store it as a tuple, because I thought I may change from just storing a position to something more complex in the future.
11:21:45 <jmanson> Part of the problem then is that Position is a bad name for what I wanted
11:21:52 <jmanson> Player is more like it
11:22:22 <Saizan> i'm not sure wheter having it as a tuple helps, record syntax may help more
11:22:25 <kpreid> data Player = Player { position :: (Int, Int) }
11:22:41 <kpreid> Or you could use complex numbers!
11:23:48 <vincenz> kpreid: use newtype
11:24:01 <jmanson> krepid: haha. 2 dimensions is for losers :)
11:24:27 <Cheery> -INF dimensions is the thing!
11:28:06 <abz> is it possible to have a directory, say Foo, and a modules in it like `module Foo.Main ( main ) where...` ?
11:29:03 <abz> or does the Main module always have to be at the top level directory
11:29:31 <Igloo> abz: For H98, top level
11:29:41 <Igloo> With ghc you can say -main-is Foo.Main.main
11:29:59 <abz> excellent, thanks Igloo, I'll give it a go
11:30:53 <kpreid> vincenz: I was, er, assuming without evidence that there were going to  be more fields
11:32:42 <Cheery> "evaluating cellular automaton is comonadic" http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
11:32:45 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
11:34:23 <jmanson> I'm having a bit of trouble with some code. I want to increase the position of my player by 1 in the x direction and can't seem to get it working.
11:35:46 <hpaste>  jmanson pasted "modify position" at http://hpaste.org/1843
11:37:16 <tibell> test
11:41:59 <tibbe> Good evening
11:42:11 <Eelis> is there a way to import macro definitions of numerical constants from system headers using FFI ?
11:42:43 <kpreid> jmanson: You didn't describe the failure.
11:42:53 <kpreid> jmanson: Does it print the unaltered value? Does it not compile?
11:44:18 <jmanson> kpreid: It doesn't compile
11:44:29 <kpreid> Well, include the error, then.
11:44:39 <kpreid> (in what you paste)
11:44:48 <jmanson> specifically, it doesn't like the line: sample = do mods sPlayer (\Player (x,y) -> Player (x + 1, y))
11:44:50 <shapr> Yay ghc 6.6.1 is in debian/unstable!
11:44:52 * shapr cheers
11:45:33 <kpreid> jmanson: don't paraphrase; it's not helpful. paste the exact error.
11:45:38 <shapr> um, it wants to remove everything libghc6-  that I have :-(
11:45:57 <jmanson> kpreid: Ok. I will make a new paste with the error message.
11:46:10 <kpreid>  use the annotate feature
11:46:47 <Baughn> @pl \a b c -> f a b c d
11:46:47 <lambdabot> flip flip d . (flip .) . f
11:47:12 <hpaste>  (anonymous) annotated "modify position" with "(no title)" at http://hpaste.org/1843#a1
11:47:36 <kpreid> jmanson: Excellent. The problem is now obvious.
11:47:36 <Heffalump> shapr: presumably cos they haven't been built for whatever ghc you are installing?
11:47:57 <jmanson> kpreid: good
11:48:06 <shapr> Heffalump: Yeah, most likely.
11:48:17 <kpreid> jmanson: You're specifying two parameters for the lambda, because lambda parameters are separated by whitespace. You need parentheses around the usage of Player
11:48:24 <jmanson> kpreid: I'm sure the problem stems from my having no clue how data types work in haskell
11:48:58 <jmanson> kpreid: ok. i'll try that
11:49:08 <kpreid> this is just syntax
11:49:20 <kpreid> \(Player (x,y)) -> ...
11:49:49 <kpreid> \Player (x,y) -> would mean a lambda with two parameters, one required to be the value 'Player' and the other a tuple
11:50:35 <jmanson> kpreid: it's still a no go
11:50:55 <kpreid> Stop saying that!
11:51:07 <kpreid> Better yet, stop thinking it. There is no such thing as "It doesn't work."
11:51:28 <hpaste>  (anonymous) annotated "modify position" with "(no title)" at http://hpaste.org/1843#a2
11:51:48 <kpreid> Just because fixing one problem allows the process to proceed to reveal another problem doesn't mean that it's "still not working".
11:52:33 <kpreid> That error's "possible fix" is the proper fix.
11:52:50 <kpreid> You haven't told it how to print a Player; you need to do that before "print b" can work.
11:53:17 <hpaste>  sjanssen annotated "modify position" with "add deriving Show" at http://hpaste.org/1843#a3
11:53:25 <migraine> is it normal to have IO in almost every function of a multithreaded (STM) backend server (MUD) or am I looking at haskell entirely wrong?
11:53:55 <kpreid> migraine: well, it depends on where the points of mutation (STRef etc.) in your data structures are.
11:54:01 <sjanssen> migraine: depends
11:54:15 <Philippa> you're probably looking at it wrong - odds are factoring it well'd cut down the proportion of IO
11:54:17 <sjanssen> it is certainly reasonable that a MUD would need to do lots of IO
11:54:27 <kpreid> migraine: the more rootward you can push them, the more non-monadic code you can write
11:54:57 <Philippa> kpreid: remember that STM variables don't need to be mutated from within the IO monad
11:55:11 <jmanson> I see. How do you extract just the position part to print?
11:55:17 <kpreid> oh, right
11:55:28 <jmanson> BTW, the code now works. I am so happy!
11:55:49 <kpreid> so assuming migraine really meant IO, the question is why his functions are in IO and not just STM
11:56:06 <Philippa> jmanson: do your pattern-matching and then call print with the position part
11:56:18 <kpreid> jmanson: the same way you did it for GameData in the sPlayer definition
11:56:21 <migraine> good question, perhaps I could get away with just STM
11:56:25 <migraine> in some
11:56:54 <Philippa> you probably only really need IO when you're pushing data across the network or trying to make a persistant (or to put it another way, goes-to-disk) change
11:56:58 <Botje> I'd be very interested in an article about "de-IOizing" code
11:57:22 <migraine> just learning... 4 weeks of struggle before the language started to make more sense than C
11:57:22 <Botje> since it's not always clear how to do that
11:57:33 <Philippa> Botje: a 'command interpreter' pattern can go a long way - pure code builds up a 'program' of things to do, and then it gets interpreted by something that does the IO
11:57:48 <Philippa> you get cheap undos that way too
11:58:18 <Botje> so you lose some IO-ness, but have to pack/unpack your "actions" manually
11:59:06 <sjanssen> you can construct IO actions directly, but then they become opaque
11:59:26 <Philippa> yeah, though really that's barely any cost in code - it's no more expensive to call the EDSL constructors than to call the actions
11:59:49 <Philippa> it does cost you a little space and time, but if you've got any other uses for it then it's generally a net gain
12:00:03 <Philippa> cheap undos and getting to finish verifying everything before running the action'd be examples
12:00:31 <Philippa> also, if you want to work with a strict subset of IO to maintain some kind of invariant it gets you that, too
12:00:43 <Philippa> (and you can send commands down TChans, and...)
12:00:52 <migraine> well all of my IO is done in a thread for each socket, so they are really fire and forget... perhaps I could store the actions in the thread and have it just run through them
12:01:31 <Philippa> if so far your code's IO-heavy because it's all code for actually doing IO - socket management, stuff like that - then don't worry too much
12:02:14 <migraine> yeah maybe when I get in deeper it will be lighter on the IO as well, good point
12:02:16 <sjanssen> migraine: one trick is to write actions-to-be-executed into a TChan.  Then have one thread read and execute them
12:02:40 <migraine> \sjanssen mmm thats interesting idea
12:03:03 <Philippa> sjanssen: for values of 'execute' that may then dispatch things to eg invidual socket-IO threads
12:03:09 <Philippa> BTDT, that's how I was structuring an IRC client
12:03:36 <jmanson> I did the pattern matching thing to get the pos as follows: getpos (Player p) = p
12:04:01 <sjanssen> Phillippa: certainly
12:04:16 <sjanssen> this pattern can also be used to provide mutual exclusion
12:04:30 <jmanson> It works, but I had to create a new function to do it. Is there a more compact way to do it so that I don't need to create a function each time I need to get a data member?
12:04:41 <kpreid> jmanson: but you're using record syntax for your data
12:04:51 <kpreid> jmanson: the whole point of it is that the accessors are defined for you
12:04:53 <sjanssen> jmanson: there is, in fact.  Use record syntax
12:05:42 <sjanssen> jmanson: in your code 'pos' is exactly the same as 'getpos'
12:05:48 <Cheery> does haskell have module for directed acyclic graphs?
12:05:52 <Cheery> ?where DAG
12:05:53 <lambdabot> I know nothing about dag.
12:06:02 <Botje> Cheery: Data.Graph
12:06:13 <Botje> and more specifically, Data.Graph.Inductive
12:06:25 <jmanson> oh... i'll try that
12:07:12 <jmanson> heh. it works.
12:07:18 <jmanson> yay!
12:16:47 <jmanson> in the line "type GameState a = StateT GameData IO a" is the order of StateT GameData and IO important?
12:17:33 <kpreid> Yes.
12:22:57 <chessguy> bringert: hi
12:23:05 <bringert> hi chessguy
12:23:15 <chessguy> hey, is Hope still an active project?
12:24:48 <jmanson> Hey again, I was reading this article: http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
12:24:52 <lambdabot> Title: Haskell Records Considered Grungy « :: (Bloggable a) => a -> IO (), http://tinyurl.com/3akjdr
12:25:30 <sjanssen> yes, records have some well known limitations
12:25:33 <jmanson> It seems to indicate that if I have both a type Monster and Player that both have a member named pos that the compiler will complain.
12:25:44 <jmanson> Is that true?
12:25:51 <sjanssen> yes, if they're in the same module
12:26:41 <roconnor> > product [1..4]
12:26:43 <lambdabot>  24
12:27:22 <jmanson> The article said that this is something that is well known and that there are several proposals to improve records. How soon is it expected for a fix to become available?
12:27:28 <chessguy> ha!
12:27:43 <chessguy> likely when a cold place freezes over
12:27:47 <chessguy> err
12:27:49 <chessguy> hot place
12:28:57 <jmanson> So, not too soon, eh?
12:29:16 <chessguy> i don't think it made the list for haskell prime
12:29:37 <sjanssen> backwards compatibility is one hurdle
12:29:44 <jmanson> Seriously? How can it not be a priority to fix?
12:29:54 <bringert> chessguy: Hope is active on and off
12:30:01 <sjanssen> jmanson: it's not that big of a deal, in practice
12:30:04 <bringert> chessguy: right now it's pretty active
12:30:21 <chessguy> bringert: oh, cool. is there any documentation available for it somewhere?
12:30:31 <bringert> chessguy: it's a lot easier to install these days
12:30:41 <chessguy> that's always a good thing :)
12:31:31 <Heffalump> jmanson: also, there's no easy fix
12:31:40 <bringert> chessguy: the only docs are the INSTALL file, http://hope.bringert.net/about and http://hope.bringert.net/entry
12:32:18 <chessguy> ok, i'll look. thanks
12:33:00 <bringert> chessguy: I've just changed the install process and the INSTALL instructions are untested, so feedback is welcome
12:33:27 <bringert> chessguy: note that hope is not available in hackage yet, depite what INSTALL says. its deps are though.
12:34:10 <chessguy> i may play with it. i really don't particularly have a spare web server sitting around to play with though
12:36:13 <chessguy> bringert: thanks for the update
12:41:53 <matthew-_> would you expect that :t let a = blah in a and :t let a = blah in 1 would give different results?
12:42:13 <Igloo> yes
12:42:26 <matthew-_> well, particularly, would you expect that the former wouldn't give errors but the latter would?
12:43:18 <Heffalump> what is the blah?
12:43:18 <Igloo> No
12:43:32 <matthew-_> Heffalump: big expression not mentioning a
12:43:48 <DRMacIver> Hi
12:44:01 <Heffalump> I can't think of any reason that should happen.
12:44:09 <Heffalump> Can you hpaste the expression?
12:44:14 <Heffalump> hi
12:44:41 <matthew-_> Heffalump: well it depends on a 500 line module I've written which is at http://hackage.haskell.org/trac/ghc/attachment/ticket/1353/Session.hs
12:44:44 <lambdabot> Title: #1353: Session.hs - GHC - Trac, http://tinyurl.com/37sf7x
12:44:50 <Heffalump> ah.
12:44:56 <Heffalump> what's the error?
12:45:01 <matthew-_> err, 400, not 500
12:45:04 <Heffalump> oh, wait, I know the problem, I bet
12:45:07 <Heffalump> type classes.
12:45:13 <matthew-_> yep
12:45:32 <Heffalump> blah is constrained by some type class.
12:45:51 <hpaste>  matthew-_ pasted "is it me or is this weird?" at http://hpaste.org/1844
12:45:59 <Heffalump> and the type of the left hand expression is ok, because the type variable mentioned in the constraint is part of the overall type
12:46:15 <Heffalump> and the right hand one isn't, cos there's no way you could use context to decide what actual type class instance to use
12:46:23 <matthew-_> ahh! yes, ok that makes much sense then
12:46:46 <DRMacIver> Heffalump: Well, if nothing else comes out of it, I think I at least understand rank 2 types a bit better now. ;)
12:46:47 <Heffalump> though that's not quite what your error is
12:46:54 <Heffalump> DRMacIver: :-)
12:47:03 <haskellnew> data SS a = SS a Int ; instance (Monad a)=> Monad (SS a) where (SS x y)  >>= f = f x y    this gives error in ghci , but why ?
12:47:08 <matthew-_> yeah - I doubt you'd be able to satisfy those constrainst from 1 !
12:47:23 <DRMacIver> haskellnew: You can't define types in GHCi
12:47:37 <Heffalump> ok. A small test suggests that my explanation is bogus.
12:47:45 <DRMacIver> haskellnew: GHCi is basically a big do block.
12:48:11 <haskellnew> DRMacIver : i mean i loaded the file in ghci where it is defined in the file
12:48:19 <DRMacIver> Oh, right.
12:48:30 <DRMacIver> What does the error say?
12:48:48 <Heffalump> ok, I think it's just about when the overload resolution happens
12:48:56 <Heffalump> can you actually use the former expression anywhere successfully?
12:49:02 <haskellnew> `a' is not applied to enough type arguments
12:49:20 <haskellnew>  Expected kind `*', but `a' has kind `* -> *
12:49:32 <haskellnew> In the type `SS a'
12:49:42 <mauke> haskellnew: that's because Monad wants a type constructor but SS wants a type
12:50:12 <haskellnew> ok kind of "m a"
12:50:52 <haskellnew> no i did not get it
12:51:07 <matthew-_> Heffalump: well, I'm trying to hack in recursion. Everything else works fine, it's just the mkLoop stuff that goes nuts
12:51:47 <Heffalump> matthew-_: try and make a cut down example
12:52:13 <matthew-_> Heffalump: yeah, Simon asked for that. It's going to be /really/ hard.
12:53:42 <matthew-_> Heffalump: in fact, thinking hard about it, I actually can't - the code that I'm pasting that hangs literally uses everything in that module
12:54:16 <Heffalump> and you can't cut it down?
12:54:41 <matthew-_> well it's mostly type sigs, and removing those has a bad effect. ;-)
12:55:08 <matthew-_> I realise how crap it is to post a bug report with 400 lines of complex code attached...
12:55:32 <Heffalump> can't you simplify the types?
12:56:54 * matthew-_ thinks
12:59:26 <matthew-_> define "simplify"? Without those types, it probably won't work. I could try and consolidate the types, but I doubt that would make it simpler
13:01:14 <matthew-_> ahh! light bulb has appeared
13:03:51 <matthew-_> cool, it's down to 200 lines
13:06:36 <Heffalump> matthew-_: I find it difficult to believe that there isn't a simpler type signature that demonstrates the same problem, that's all
13:06:44 <Heffalump> (much simpler than 200 lines too)
13:06:53 <Heffalump> but it would require a fair bit of butchering
13:07:26 <matthew-_> Heffalump: I'm sure you're right. Gimme a few hours and I might get there!
13:09:19 <Heffalump> actually, I think my explanation is roughly right.
13:09:36 <Heffalump> In both cases, that instance isn't satisfiable.
13:09:46 <Heffalump> However, in one case it's decided there's no hope of ever doing so, and is telling you so.
13:09:53 <Heffalump> In the other, it is still holding out hope, so to speak.
13:09:58 <Heffalump> Are you using -fglasgow-exts?
13:10:03 <hpaste>  haskellnew pasted "instance monad" at http://hpaste.org/1845
13:10:16 <matthew-_> Heffalump: ahh, sorry, I'd moved back to dealing with the bug itself rather than the let
13:10:25 <matthew-_> Heffalump : yep: {-# OPTIONS_GHC -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances #-}
13:10:41 <Heffalump> ok, I have no idea how typechecking works in that situation ;-)
13:10:50 <Heffalump> I think it's just what I said.
13:10:59 <matthew-_> you may well be right.
13:12:49 <haskellnew> i have pasted the code , with 2 eg , one works other does not , sorry i am just not able to get it
13:13:27 <Heffalump> thinking about it some more, it makes sense for it to be holding out hope, because there might be some specific instances with those type variables further constrained
13:13:55 <Heffalump> but if it can be sure there aren't instances general enough to cover the whole lot, then there's no chance of them becoming further constrained in the "... in 1" version.
13:14:19 <matthew-_> agreed.
13:14:36 <matthew-_> it'd be smoking something funky to satisfy those constraints with "1" !
13:14:51 <cdr> omfg, theres a Haskell street in Allston
13:15:30 <Heffalump> the 1 is irrelevant to actually satisfying them
13:15:40 <Heffalump> it's just about whether the type variables are visible in the type signature or not
13:15:51 <matthew-_> right, gotcha
13:22:41 <swiert> @users
13:22:41 <lambdabot> Maximum users seen in #haskell: 336, currently: 323 (96.1%), active: 49 (15.2%)
13:24:33 <Baughn> @version
13:24:33 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
13:24:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:24:55 <Baughn> As per usual, it fails to work with 6.6.1. Oh well..
14:06:14 <shapr> AHA! It's a bug in hslogger! No wonder!
14:06:43 <DRMacIver> What? Haskell code doesn't have bugs does it? :)
14:07:33 <kolmodin> afaik that's the first haskell bug I've ever heard of.... .. ... almost
14:08:04 <shapr> heh
14:08:33 <shapr> I've been trying to get hslogger to work for hours, and I kept thinking I was doing something wrong!
14:09:26 <shapr> @seen CosmicRay
14:09:27 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 1d 22h 50m 32s ago, and .
14:12:17 <shapr> Now if only I can find the bug...
14:23:21 <monochrom> > printf
14:23:23 <lambdabot>  Add a type signature
14:23:42 <monochrom> > printf "%08x" (0x80000000 :: Int) :: String
14:23:53 <lambdabot>  "17ffffffe"
14:24:22 <monochrom> > printf "%x" (0x80000000 :: Int) :: String
14:24:28 <lambdabot>  "17ffffffe"
14:25:10 <Saizan> ?seen ski
14:25:11 <lambdabot> ski is in #haskell-overflow, #oasis, #haskell-blah and #haskell. I don't know when ski last spoke.
14:25:55 <monochrom> > fromIntegral (0x80000000 :: Int) :: Integer
14:26:05 <lambdabot>  -2147483648
14:26:20 <monochrom> ok, at least that one isn't the problem.
14:54:06 <nominolo> ?where YAHT
14:54:07 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:56:18 <nominolo> ?where wikibook
14:56:19 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:58:27 <yaxu> could anyone recommend a source for finding out about grouping algorithms?
14:58:43 <ddarius> "grouping"?
14:59:09 <yaxu> well i don't know the terminology is the problem i guess
14:59:47 <yaxu> but i have some data and a way of measuring similarity between each pair of datums and want to group them by similarity
15:00:57 <ddarius> yaxu: Does the method of measuring similarity return a Bool or something like a Double or something else all together?
15:01:10 <yaxu> an integer
15:01:21 <nominolo> yaxu: maybe a trie could do it?
15:01:24 <yaxu> edit distance between words
15:01:54 <yaxu> sorry this isn't a very haskell specific question...
15:02:05 <ddarius> yaxu: That's fien.
15:02:09 <ddarius> s/fien/fine.
15:02:39 <ddarius> Maybe "clustering" is the keyword you want.
15:03:06 <ddarius> E.g. http://en.wikipedia.org/wiki/Data_clustering
15:03:09 <lambdabot> Title: Data clustering - Wikipedia, the free encyclopedia
15:03:18 <yaxu> ah yes, i've been looking at this page
15:04:49 <Saizan> anyone has an example of the use of the Context comonad? (dual to State=
15:05:21 <newsham> is there a gtk2hs installer for windows for the 6.6.1 ghc?
15:05:29 <newsham> the one on the front page doesnt want 6.6.1
15:06:28 <dcoutts> newsham: not yet
15:06:57 <yaxu> i'll go through the references there, thanks ddarius
15:07:03 <newsham> is it something that will be around soon (next month) or should I not hold my breath? :)
15:12:38 <nominolo> oh, btw, is gtk2hs known not to work with ghc 6.6.1 on MacOSX Intel ?
15:12:53 <nominolo> i get a bus error on every demo program i trie
15:12:57 <nominolo> er, try
15:17:01 <dcoutts> nominolo: I've had a couple reports like that, however it's pretty hard for me to track down, not having access to the hardware and all
15:17:19 <nominolo> dcoutts: any tips how to give you more information?
15:17:22 <dcoutts> nominolo: if you feel like helping track it down that'd be great
15:18:00 <dcoutts> nominolo: well, to start with details of the environment and how you installed gtk2hs, ie from source or via mac ports
15:18:30 <nominolo> from source, using custom-built macports
15:18:33 <nominolo> er
15:18:40 <nominolo> s/macports/ghc6.6.1/
15:22:10 <nominolo> !paste
15:22:10 <hpaste> Haskell paste bin: http://hpaste.org/
15:24:35 <hpaste>  nominolo pasted "gtk2hs helloworld ktrace output before death" at http://hpaste.org/1847
15:24:57 <nominolo> oh, i pasted a bit too much
15:27:57 <mdmkolbe|home> Is there any existing documentation on lambdabot in the wiki?  If not, where would be a good place for me to put some?
15:28:49 <bos> not that i've noticed.
15:32:58 <nominolo> dcoutts: it dies in widgetShowAll (but i guess you expected that already)
15:36:39 <mdmkolbe|home> Found it
15:36:43 <dfranke> once I build this system I think I'll volunteer it a GHC build slave.
15:36:43 <mdmkolbe|home> @wiki lambdabot
15:36:44 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
15:36:48 <dfranke> 8 cores :-)
15:36:54 <mdmkolbe|home> (I guess that should have been obvious)
15:37:34 <chessguy> mdmkolbe|home: just so you know, @wiki isn't very good for if you don't know where something is
15:37:41 <chessguy> @wiki NothingAtAll
15:37:41 <lambdabot> http://www.haskell.org/haskellwiki/NothingAtAll
15:37:51 <chessguy> instead, try this:
15:37:54 <chessguy> ?where lambdabot
15:37:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:38:02 <mdmkolbe|home> @help where
15:38:03 <lambdabot> where <key>. Return element associated with key
15:38:13 <nominolo> dcoutts_: maybe an interesting side note, is that gtk is 2.10 and was built using macports.  i have working gtk-apps though
15:38:18 <chessguy> or if you know it's on the wiki, just go there and search
15:38:34 <chessguy> just an FYI
15:38:41 <mdmkolbe|home> ok
15:39:33 <mdmkolbe|home> just so I don't repeate any extra work, has anyone already run @doc over all the lambdabot commands?  If not, I'll do it.
15:39:35 <chessguy> @go lambdabot site:haskell.org/haskellwiki
15:39:37 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
15:39:37 <lambdabot> Title: Lambdabot - HaskellWiki
15:39:48 <chessguy> that one works too :)
15:40:06 <chessguy> mdmkolbe|home: i'm not sure what you mean
15:40:54 <mdmkolbe|home> run @doc bf' '@doc check', @doc compose, @doc, etc and safe the output somewhere
15:40:57 <nominolo> @localtime dcoutts_
15:40:59 <lambdabot> Local time for dcoutts_ is Mon May 14 23:40:08
15:41:10 <ddarius> mdmkolbe|home: You mean @help?
15:41:34 <chessguy> @doc bf
15:41:34 <ddarius> @help
15:41:35 <lambdabot> bf not available
15:41:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:41:36 <mdmkolbe|home> ddarius: I think, @help just lists the commands.  I want a list of all the commands along with their help
15:41:39 <chessguy> @help bf
15:41:39 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
15:42:06 <chessguy> @list -- this is what gives a list of commands
15:42:07 <lambdabot> No module "-- this is what gives a list of commands" loaded
15:42:11 <chessguy> bah
15:42:12 <chessguy> @list
15:42:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:42:23 <ddarius> I'd recommend walking over the source rather than interacting with the bot.
15:42:49 <balodja> bf ,>++++++[<-------->-],[<+>-]<.
15:42:55 <balodja> @bf ,>++++++[<-------->-],[<+>-]<.
15:42:56 <lambdabot>  fd:28: hClose: resource vanished (Broken pipe)
15:42:59 <nominolo> @bf .
15:42:59 <lambdabot>  fd:28: hClose: resource vanished (Broken pipe)
15:43:00 <chessguy> anyway, i'd bet dons has all that somewhere
15:43:17 <chessguy> @quote Hello
15:43:17 <lambdabot> java says: public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
15:43:22 <chessguy> @quote Hello
15:43:22 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
15:43:47 <freshhawk> anyone have any tips on debugging the "Foo version 1.2 or later is required to compile Bar" error when compiling haskell packages. Right now i just installed happy and it's still reporting it missing
15:43:48 <chessguy> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
15:43:48 <lambdabot>  fd:28: hClose: resource vanished (Broken pipe)
15:44:15 <chessguy> hm, sounds like it's not very happy
15:44:42 <nominolo> freshhawk: what does "ghc-pkg" list say?
15:45:02 <nominolo> er "ghc-pkg list"
15:45:46 <nominolo> (or your compiler/interpreter's equivalent)
15:45:55 <freshhawk> nominolo, aha, that's the command i wanted. it shows alot of things but happy-1.16 isn't one of them
15:46:17 <nominolo> freshhawk: then it's not installed correctly, or not in the right place
15:46:35 <freshhawk> nominolo, yup, that should at least set me on the right path, thanks
15:46:36 <chessguy> did you do the runhaskell Configure.hs --install
15:46:40 <chessguy> or something equivalent?
15:47:12 <freshhawk> yes, i think it's because i'm putting all this in /opt with a --prefix=/opt
15:47:35 <freshhawk> it seems to work only about 90% of the time
16:18:32 <beelsebob> > "Haskell's" ++ " great"
16:18:34 <lambdabot>  "Haskell's great"
16:36:34 <tsp> hmm
16:37:27 <tsp> > 2^(1/12)
16:37:28 <lambdabot>  Add a type signature
16:37:36 <tsp> damnit, I can't get anything to solve that
16:38:38 <tsp> ah, found it, 1.059
16:39:37 <davidL> > 49/95
16:39:45 <davidL> > 49/75
16:39:47 <lambdabot>  0.5157894736842106
16:39:56 <lambdabot>  0.6533333333333333
16:41:28 <mauke> > 2**(1/12)
16:41:43 <lambdabot>  1.0594630943592953
16:43:32 <tsp> ah
16:43:57 <johnnowak> pow(2, 1 / (double) 12);
16:48:41 <ddarius> The well balanced Klavier
16:58:16 <hpaste>  matthew-_ pasted "Any ideas on how to fill in the <<BLANK>> ?" at http://hpaste.org/1848
16:58:32 <matthew-_> I'm quite stumped
16:59:42 <matthew-_> mmm. is no one awake?
16:59:56 <Botje> too much magic for me, sorry :(
17:12:49 <_frederik_> how should i force a garbage collection?
17:12:57 <beelsebob> you shouldn't
17:13:07 <jcreigh> _frederik_: I don't know if you can...
17:13:08 <dibblego> ring your local council and yell at them for not collecting your garbage
17:13:13 <beelsebob> lol
17:13:49 <_frederik_> dibblego: thanks
17:13:57 <dibblego> _frederik_, always willing to help :)
17:13:59 <jcreigh> _frederik_: in general, you shouldn't need to, everything should just work. (That's the point of GC, after all). Are you having any specific problems?
17:14:25 <_frederik_> jcreigh: i'm debuggin finalizers, sorry
17:14:30 <_frederik_> g
17:15:49 <int-e> matthew-_: I think that requires unsafeCoerce. i.e. proof anInt value = unsafeCoerce# (TEq :: TEq Bool Bool)
17:16:04 <mauke> @index performGC
17:16:04 <lambdabot> System.Mem
17:16:13 <matthew-_> int-e: ahh, interesting. How unsafe is unsafe?
17:17:22 <int-e> matthew-_: you're promising that all instances of F Int * have *=Bool. The compiler can't check that. However if you add an functional dependency to F it'll be relatively save.
17:17:42 <int-e> matthew-_: still potentially unsafe though: you can define conflicting instances for F in different modules.
17:17:52 <matthew-_> int-e: it's explicitly there to get round limitations of fundeps
17:18:19 <matthew-_> int-e: http://www.haskell.org/pipermail/haskell-cafe/2007-May/025421.html
17:18:21 <lambdabot> Title: [Haskell-cafe] More mystery with existentials and fundeps, http://tinyurl.com/2vwkkj
17:19:26 <int-e> matthew-_: yes, I saw that. But I couldn't answer that when I saw the mail. (I didn't think of the conflicting instances scenario that I just described)
17:20:22 <matthew-_> I wish I could declare classes as closed. So many limitations seem to be "well you could define a conflicting instance in another module..."
17:20:56 <int-e> matthew-_: the scenario basically shows that you either need closed classes, or some whole program check (at compile or link time) to make the fundep work as you want.
17:21:07 <matthew-_> yep
17:21:32 <matthew-_> well currently, the compiler doesn't even take into account whether or not the class is exported (it seems to me)
17:21:48 <matthew-_> if it's not exported, is there a reason it can't be considered closed?
17:23:06 <int-e> this has been proposed for haskell', btw. http://hackage.haskell.org/trac/haskell-prime/wiki/ClosedClasses (but probably won't be adopted, according to its status page.)
17:23:09 <lambdabot> Title: ClosedClasses - Haskell Prime - Trac
17:25:16 <int-e> no reason, but it complicates the type checker, of course.
17:25:41 <matthew-_> sure
17:26:12 <matthew-_> sorry, where is unsafeCoerce# ?
17:26:21 <int-e> GHC.Base
17:26:29 <matthew-_> cheers
17:27:20 <int-e> with darcs head of the base library, you can also find it in Unsafe.Coerce as unsafeCoerce (without #)
17:29:39 <matthew-_> wow, I'll die happy if that's the craziest code I ever write!
17:30:00 * matthew-_ is giddy having finally "got there"
17:31:12 <matthew-_> what's the general format for how things get into haskell' or into ghc 6.7 ? Is there some sort of correlation between the two?
17:31:31 <matthew-_> I notice there are things in haskell' which have been in ghc 6 for some time
17:35:13 <SamB_XP_> well, something has to go into, what, at least two compilers before it gets into Haskell'?
17:36:42 <SamB_XP_> also I think there is an unspoken rule that one of the two compilers must be GHC ;-P
17:36:42 <sjanssen> one is the rule of thumb
17:36:42 <SamB_XP_> just one?
17:36:45 <SamB_XP_> okay...
17:36:47 <sjanssen> matthew-_: I wonder if associated types will work better for you
17:36:54 * SamB_XP_ would prefer two
17:37:01 <matthew-_> ahh, that's "the rule" is it?
17:37:18 <sjanssen> I don't think that's even a hard rule -- more like a guideline
17:37:46 <sjanssen> there are certainly popular proposals that haven't been implemented
17:38:23 <matthew-_> right. So I guess I only follow GHC in any sort of detail. From the mailing list, hugs is clearly still active, but what about the others? How far away are they all from ghc?
17:38:31 <sjanssen> very
17:39:35 <sjanssen> I believe GHC and Hugs are the only compilers that support MPTC + fundeps, for example
17:39:39 <matthew-_> sjanssen: it's possible - in this case, I think associated types would work well. But I'm slightly scared about using them and thus relying on an unstable version of GHC that has a varying degree of stability.
17:40:05 <matthew-_> and build-ability
17:40:15 <sjanssen> matthew-_: certainly you'll have to wait a while before you can use them freely
17:41:10 <matthew-_> sjanssen: yeah, my supervisor would like that: "Sorry, I can't do any work until SPJ et al finish GHC 6.8. I'll be down the pub..."
17:41:48 <sjanssen> matthew-_: ghc and hugs are probably the only compilers that are usable in practice
17:41:58 <sjanssen> maybe nhc98, on occasion
17:42:14 <sjanssen> similarly for yhc
17:42:14 <matthew-_> sjanssen: yeah, these days I tend to overuse GADTs a lot which cuts out hugs I think
17:48:21 <littledan> what's an example of an ambiguity from a lack of fundep in a multiparameter typeclass?
17:50:21 <matthew-_> I would guess, instance F Int Bool ... instance F Int Double ... and then you're trying to satisfy F Int a
17:50:43 <matthew-_> so it doesn't know which instance to pick. But that is a guess.
17:50:55 <matthew-_> (for some class F a b)
17:51:56 <littledan> really? I don't understand why that couldn't work
17:52:35 <littledan> you couldn't have a type like, for example, (F Int a) => Int -> a ?
17:52:50 <matthew-_> yeah you can
17:52:56 <matthew-_> eg, the monad class
17:53:08 <matthew-_> @type (>>=)
17:53:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:53:33 <matthew-_> but there the class is a type constructor (hence the m :: * -> *)
17:54:22 <matthew-_> littledan: you could paste your code - @hpaste
17:54:29 <matthew-_> @hpaste
17:54:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:54:36 <littledan> well, I don't have code, I was just wondering
17:54:49 <matthew-_> ahh, and I'm just guessing!
17:55:11 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#id3148387 has an example
17:55:14 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
17:57:04 <littledan> int-e, thanks, that makes sense
18:22:38 <jmanson> what is the best linux editor for haskell that is not emacs or vi?
18:23:24 <SamB_XP_> what have you got installed?
18:23:27 <jmanson> I suppose emacs would be alright though, if there is some easy way to get the key commands to be normal :)
18:23:33 <SamB_XP_> hah
18:24:01 <jmanson> So far, I have just been using gedit
18:24:21 <jmanson> but, it would be nice to have indenting work
18:24:37 <jmanson> maybe even other features
18:25:40 <jmanson> As far as what I have installed, I am willing to install whatever works best.
18:30:55 <SamB_XP_> I have yet to see indenting work totally...
18:31:08 <SamB_XP_> but emacs does reasonably well
18:31:44 <jmanson> do you know of some configuration file that changes key bindings to those used in the windows world?
18:31:58 <SamB_XP_> no.
18:32:27 <SamB_XP_> I don't think it is a good idea, anyway.
18:32:48 <jmanson> why not?
18:33:13 <jmanson> I find it hard to see how Ctrl-Y is a good idea for copy
18:33:31 <SamB_XP_> there would probably be conflicts...
18:35:16 <SamB_XP_> for instance, what do you do with what is already on C-x and C-c ?
18:35:28 <jmanson> True, Conflicts may arise, but I would only use basic functions.
18:35:47 <jmanson> I would map it to something else.
18:35:48 <SamB_XP_> a likely story
18:38:26 <jmanson> It sounds like I may just be stuck with gedit.
18:38:43 <SamB_XP_> well, you could *write* a config file where you attempt to remap keys...
18:38:55 <SamB_XP_> but I don't have any idea how you'd remap C-c...
18:38:59 <lemao> what is the recommended haskell book?
18:39:01 <SamB_XP_> since it is a prefix key
18:39:08 <dibblego> ?where yaht
18:39:30 <SamB_XP_> well... it isn't simon&simon...
18:39:44 <dibblego> lemao, http://darcs.haskell.org/yaht/yaht.pdf
18:39:51 <dibblego> what's simon&simon?
18:40:21 <SamB_XP_> that would be the names of the lead GHC developers?
18:41:51 <lemao> thanks!
18:49:16 <sch> @google comprehending queries
18:49:21 <lambdabot> http://www.ub.uni-konstanz.de/kops/volltexte/1999/312/312_1.pdf
19:00:47 <sorear> hello.
19:01:22 <MyCatVerbs> sorear: your mother's cushions.
19:01:34 <MyCatVerbs> Wait, no.
19:01:41 <MyCatVerbs> Um, good morning.
19:13:05 <JKnecht> any advice on 6.6.1 vs. 6.4.2?
19:14:17 <JKnecht> (from a minimum breakage perspective)
19:14:55 <JKnecht> (with maximum advancement if poss.)
19:17:02 <sorear> Just use 6.6.0, if you want to be conservative.
19:17:26 <sorear> 6.6.0 is a huge improvement over 6.4.anything, and fairly old
19:17:50 <sorear> of course 6.6.1 will probably be better yet, but you might think it's too new
19:20:18 <littledan> jmanson, I used to use gedit too but I've grown to like vim
19:21:59 <jmanson> littledan: really? I can't get past the mode switching, so have never seriously considered it, but that is the editor that I use when I don't have X around.
19:23:09 <littledan> jmanson, once you learn to fluently use many different commands that put you in insertion mode (eg a, o, etc) it gets a lot more useful
19:23:52 <sorear> jmanson: If you want a lightweight modeless editor, you should take a look at mg (emacs-style keys)
19:25:45 <jmanson> does vim have haskell syntax highlighting and indentation?
19:26:10 <MyCatVerbs> jmanson: yes and yes.
19:26:19 <MyCatVerbs> jmanson: though I find the indentation a little off, sometimes.
19:27:38 <jmanson> Hmm. Sounds interesting. One thing that I forsee having to do often is change the indentation of whole blocks of text.
19:28:19 <jmanson> I know I have to do that in C++ at least
19:29:26 <MyCatVerbs> shift I tab escape, then smush the . key every time you want to increment an indentation.
19:36:36 <shapr> wheee
19:39:48 <desp> @hoogle IO () -> IO ()
19:39:49 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
19:39:49 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
19:39:49 <lambdabot> GHC.Conc.addMVarFinalizer :: MVar a -> IO () -> IO ()
19:40:14 <JKnecht> sorear: thanks!
19:40:34 <sorear> @hoogle+
19:40:56 <sorear> desp: are you looking for a 'forever' funciton?
19:41:08 <desp> jmanson â shift-V for visual block select mode; that's quite  useful coming from a more modern editor
19:41:11 <desp> sorear â yup
19:41:44 <sorear> Shift-V is visual line, block is Ctrl-V.  (at least in vim)
19:41:50 <desp> right
19:41:54 <sorear> @type Control.Monad.repeatM_
19:41:57 <lambdabot> Not in scope: `Control.Monad.repeatM_'
19:41:58 <desp> but shift-V and arrows, etc...
19:42:03 <sorear> @type Control.Monad.forever
19:42:07 <lambdabot> Not in scope: `Control.Monad.forever'
19:42:13 <sorear> huh.  it's in 6.7
19:42:21 <LoganCapaldo> @type let forever a = a >> forever a in forever
19:42:22 <jmanson> I have a haskell problem now.
19:42:23 <sorear> you can just use sequence_ (repeat foo)
19:42:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:42:33 <desp> LoganCapaldo: oh, hi ;)
19:42:46 <desp> LoganCapaldo: yes, I know how to write one; just trying to avoid reinventing every wheel
19:42:50 <sorear> desp: 19:40 < desp> sorear â yup  was that supposed to be an arrow??
19:43:02 <desp> sorear: it is, if you use UTF-8
19:43:03 <LoganCapaldo> desp: yerp
19:43:08 <LoganCapaldo> I was bored
19:43:31 <sorear> desp: My system has a long history of mangling stuff like that.
19:43:46 * sorear celebrates the workingness!!
19:43:51 <jmanson> It came out as an arrow for me.
19:44:44 <LoganCapaldo> uâ Æ-8 is fun
19:45:12 <LoganCapaldo> Âµâ Æâ8 even
19:45:35 <desp> Âµâ Æââ
19:45:44 <jmanson> Could someone take a look at my code? I have been trying to add state to a little program I am writing, and I can't seem to extract the state information.
19:46:05 <LoganCapaldo> jmanson: you're clearly going backwards. you're supposed remove state :)
19:46:06 <sorear> Yea, someone could.
19:46:36 <hpaste>  jmanson pasted "simple game" at http://hpaste.org/1849
19:47:08 <jmanson> LoganCapaldo - haha
19:47:29 <jmanson> I have 2 problems I guess.
19:47:48 <jmanson> one is that when I press 'd' nothing is printed
19:48:02 <jmanson> the second is that the picture isn't moving
19:48:46 <jmanson> as a first for me, the program actually compiles :)
19:51:46 <kpreid> jmanson: are you sure it compiles? those type signatures on display and loop don't look consistent
19:52:38 <jmanson> kpreid: yes, well, it loads in ghci: Ok, modules loaded: Main.
19:52:50 <kpreid> odd.
19:53:25 <jmanson> kpreid: wait
19:54:21 <jmanson> kpreid: i was always just reloading with :r, but when I quit and loaded it again it failed
19:54:21 <kpreid> perhaps :r was loading a different file.
19:54:21 <jmanson> :-(
19:55:03 <jmanson> that would explain why it wasn't working
19:55:10 <kpreid> jmanson: your display and loop need to be in the GameState monad, not IO
19:55:28 <kpreid> and you need to lift the drawing operations back into IO
19:55:42 <kpreid> @type lift
19:55:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
19:56:13 <kpreid> or perhaps one says lift it to GameState
19:58:15 <desp> quick question -- how do I read a number from stdin?
19:58:25 <desp> like scanf("%d")
19:58:43 <sorear> readLn
19:58:47 <sorear> @ty readLn
19:58:50 <lambdabot> forall a. (Read a) => IO a
19:58:58 <MyCatVerbs> desp: read read:m
19:59:11 <kpreid> That type signature is disturbing.
19:59:15 <MyCatVerbs> Erk. *stab keyboard*
19:59:18 <kpreid> It seems like it ought to have more parameters.
19:59:21 <desp> thanks.  I was trying to find this in the Haskell prelude
19:59:26 <desp> but failed
19:59:47 <jmanson> kpreid: I'm seriously confused at this point
20:00:21 <kpreid> jmanson: I'd like to help, and this is something I know about, but it's time for me to get some sleep. See you in eight hours.
20:00:29 <int-e> @where SDL
20:00:29 <lambdabot> I know nothing about sdl.
20:00:34 <sorear> kpreid: what's wrong about readLn's type?  what else should it take, besides a realworld and a read dictionary?
20:00:38 <sorear> @where hsSDL
20:00:38 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
20:00:50 <jmanson> kpreid: thanks for your help up to this point
20:01:13 <jmanson> I'm saying point too often
20:01:22 <Korollary> point taken
20:03:07 * shapr points that out
20:03:20 * edwardk waves to shapr
20:03:26 * shapr waves to edwardk
20:04:08 <Korollary> edwardk: thesis done yet?
20:04:26 <edwardk> no =/ been hiding in industry
20:04:33 <edwardk> got back to work on it a week or so ago though
20:06:09 <edwardk> found a new duality to exploit, so i got excited again ;)
20:07:50 <edwardk> also ran into a hurdle where one of my modalities failed to satisfy the comonad laws
20:11:40 <edwardk> how have things been around here?
20:18:27 <hpaste>  int-e annotated "simple game" with "this works." at http://hpaste.org/1849#a1
20:25:59 <petekaz> question on foldl ... if the function passed to it is strict, does that mean you don't have to worry about using foldl'?
20:26:09 <petekaz> ?source foldl
20:26:10 <lambdabot> foldl not available
20:26:19 <petekaz> where is that defined?
20:27:05 <petekaz> where is everyone?
20:27:10 <int-e> no, on the contrary, if the function is strict you want to use foldl', because foldl will often construct a big expression.
20:27:12 <edwardk> i was wondering the same thing =)
20:27:17 <petekaz> right.
20:27:29 <int-e> @src foldl
20:27:30 <lambdabot> foldl f z xs = lgo z xs
20:27:30 <lambdabot>     where lgo z []     =  z
20:27:30 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
20:27:31 <petekaz> I posted this comment on some guys blog, but he disagrees with me.
20:27:38 <petekaz> I thinkc he is wrongi.
20:27:43 <int-e> source /= src
20:27:56 <int-e> hmm.
20:28:01 <sorear> As long as he doesn't have a name, I don't think you have to worry about what he thinks.
20:28:06 <int-e> ghc defines it in GHC.List
20:28:09 <sorear> :)
20:28:15 <petekaz> http://www.serpentine.com/blog/2007/05/14/norvigs-spell-checker-and-idiomatic-haskell/
20:28:18 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » Norvig&#8217;s spell checker and idi ..., http://tinyurl.com/24qz82
20:28:28 <petekaz> bryan o'sullivan.
20:28:37 <sorear> doesn't matter where it's defined - it's *exported* from Prelude
20:28:43 <sorear> we call him bos here.
20:28:45 <petekaz> maybe someone with a litle more conviction can explain it to him.
20:28:46 <sorear> @seen bos
20:28:47 <lambdabot> bos is in #haskell and #haskell-soc. I don't know when bos last spoke.
20:29:04 <sorear> actually a rather active member
20:29:09 <bos> hmm?
20:29:14 <int-e> sorear: which doesn't help if you want to see how its implemented.
20:29:34 <sorear> The real solution, IMO, is for ghci to implement SEE.
20:29:36 <petekaz> bos: you mention that my comment re: foldl' was not needed.
20:29:44 <bos> yes.
20:29:50 <int-e> then again with GHC.List, the definition is only half of the story.
20:29:58 <petekaz> bos: I just asked some others, I think there is some confusion.
20:32:03 <bos> i'm distracted by trying to fix my wife's crashy mac.
20:32:42 <int-e> petekaz: I think you're right regarding foldl and foldl'. the classical foldl' example (foldl' (+) 0 vs. foldl (+) 0) also features a strict function.
20:34:22 <petekaz> > foldl (+) 0 [1..1000000]
20:34:25 <lambdabot>  500000500000
20:34:31 <petekaz> > foldl (+) 0 [1..10000000]
20:34:41 <int-e> of course a clever compiler may fix that problem
20:34:46 <lambdabot>  thread killed
20:35:01 <int-e> ghc is quite clever for primitive operations (like (+) with known type)
20:35:13 <petekaz> ok ... but in theory, from everything I have learned thus far, it does seem that foldl' is the right choice.
20:35:38 <petekaz> thanks, I have to go to bed, but maybe you can help explain to bos.
20:35:52 <petekaz> (or leave a note to me why I'm wrong)
20:40:34 <jmanson> I have stamped out most of the compilation errors now, but am having some trouble with the event polling.
20:40:44 <int-e> bos: the code won't build any 1+1+1+1+... thunks, but it will build M.insertWith (+) word 1 $ M.insertWith (+) word 1 $ ... thunks, unless the compiler does something surprisingly clever.
20:41:08 <jmanson> On some events I need to quit the program, and in others I need to modify the state.
20:41:14 <int-e> jmanson: did you see my annotation?
20:41:24 <jmanson> int-e: no
20:43:03 <jmanson> int-e: oh, that looks nicer than what I came up with.
20:44:52 <jmanson> int-e: instead of doing a liftIO for a do statement I was calling lift for each time a function that needed to be in IO was called.
20:45:03 <ddarius__> I left a note on the blog, but petekaz is completely correct with regards to using foldl' with strict functions.
20:45:39 <jmanson> int-e: thanks for the annotation
20:46:04 <int-e> you're welcome :)
20:46:07 <ddarius> bos: If it seems like it works, it's only due to strictness analysis that results in foldl being turned into foldl'.
20:46:56 <jmanson> int-e: it definitely was useful for me to try to figure out how to make most of the errors go away myself, but your code is much nicer than what I would have come up with, and I didn't know how to handle the case statement.
20:51:50 <jmanson> int-e: hahaha. i got the case part working after looking at your code and it works. the image moves right!!! I never thought I would be so happy to make something so simple happen. Now I will switch to your code :)
20:57:38 <desp> is The Craft of Functional Programming a good book?
20:59:10 <dibblego> yes, I liked it
20:59:10 <bos> ddarius: yep.
20:59:45 <desp> bos: hi :)
21:04:42 <bos> desp: howdy.
21:05:02 <bos> ddarius: i've fixed the article, but left the comments as they stood and added a new mea culpa.
21:05:55 <bos> le sigh.
21:25:32 <sorear> @users
21:25:33 <lambdabot> Maximum users seen in #haskell: 336, currently: 297 (88.4%), active: 20 (6.7%)
21:28:20 <dibblego> ?where shhotout
21:28:21 <lambdabot> I know nothing about shhotout.
21:28:23 <dibblego> ?where shootout
21:28:23 <lambdabot> http://shootout.alioth.debian.org/
21:29:16 <cdr> hrm, they moved teh site off vt.edu?
21:55:21 <desp> nubBy (((>1) .) . gcd) [2..]
21:55:26 <desp> > nubBy (((>1) .) . gcd) [2..]
21:55:28 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:55:49 <sorear> Yes?
21:56:47 <desp> impressively obfuscated
21:57:29 <emu> not really
21:57:34 <sorear> You forgot to remove the spaces.
21:57:42 <desp> emu: well, yes, I've been to the Obfuscation page
21:57:47 <desp> ;)
21:57:59 <emu> the 1 line mandelbrot fractal is impressive
21:58:06 <emu> that's actually rather sensible if you read it
21:58:09 <emu> (the primes)
21:58:10 <sorear> That code was written for *one* purpose - character minimization excercise.
21:58:21 <ddarius> @unpl ((>1) .) . gcd
21:58:22 <lambdabot> (\ e h -> (gcd e h) > 1)
21:58:48 <sorear> emu: So what do you think of my 600 character theorem prover?
21:59:15 <ddarius> desp: It's almost idiomatic code, though I guess "almost" isn't saying too much when it's about an eigth of a line of code.
22:00:02 <desp> I guess that point-free style just confuses me a lot
22:00:48 <ddarius> desp: When things get to be (f .) . g then it's getting ugly.
22:01:59 <sorear> nubBy (((>1) .) . gcd) [2..]  is just silly.  if you're concerned enough about readability to use spaces, you ought to use a lambda
22:03:59 <ddarius> Indeed, nubBy (\x -> (>1) . gcd x) [2..]
22:17:16 <desp> I've been reading Oleg's materials on prime generation in Haskell
22:17:20 <desp> http://okmij.org/ftp/Algorithms.html#Eratosthenes-sieve
22:17:22 <lambdabot> Title: Algorithms and Data Structures
22:17:32 <Heffalump> I agree that (f . ) . g is quite hard to follow, but actually once you've realised that it's just two-argument composition it's quite easy to spot
22:17:42 <desp> and there's a paper referenced, by Melissa O'Neil: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
22:18:07 <desp> is anyone aware of a faster Haskell implementation of the sieve of Erastothenes than given in that paper?
22:18:34 <ddarius> Heffalump: True, but that's not in the collective Haskell mindshare.
22:18:44 <Heffalump> right
22:18:57 * Arafangion blinks
22:19:03 <Heffalump> we should just have (..) :-)
22:19:08 * Arafangion backs out slowly, and returns to the safety of ##C++
22:19:17 <Heffalump> "safety"????
22:19:24 <desp> certainly not type-safety
22:19:29 <Heffalump> at least we mark our unsafe functions!
22:19:42 <ddarius> readFile/writeFile...
22:19:46 <Arafangion> Damn, I must've tripped on the way out :(
22:20:09 <Korollary> HALT! ALARM!
22:20:25 <Korollary> Aren't WW2 movies so cool...
22:20:27 <emu> sorear: too long to put in a sig
22:27:55 <sorear> emu: /wg 3
22:28:07 <sorear> grr
22:28:26 <sorear> must check for text already on input line before typing commands...
22:28:26 <moconnor> Is it possible to rewrite this function, http://paste.lisp.org/display/41226 using foldl?  I played around a bit and couldn't figure out a way.  I don't need this, was just playing around.
22:29:03 <ddarius> :t foldl ($)
22:29:05 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
22:29:05 <lambdabot>     Probable cause: `$' is applied to too many arguments
22:29:17 <ddarius> :t foldl (flip ($))
22:29:33 <lambdabot> thread killed
22:30:20 <ddarius> Anyways, that it.
22:30:27 <ddarius> s/that/that's
22:31:16 <moconnor> bah!  I tried (flip.($)) and the type error made my eyes cross and give up.
22:31:20 <moconnor> ddarius: thanks!
22:31:37 <ddarius> However, since flip ($) is non-strict in it's first, it would be better to use foldr.
22:32:17 <ddarius> Well, conditionally strict depending on the x I guess.
22:33:14 <ddarius> Hmm, this might actually be a good use for foldl (or is it?).  I need to think about this one.
22:33:33 <bos> the elusive case for the existence of foldl :-)
22:33:53 <dibblego> which one is the strict foldl?
22:33:59 <ddarius> foldl'
22:34:53 <moconnor> Why would it be a problem that "flip ($)" is non-strict in it's first parameter?
22:35:42 <ddarius> > foldl (flip ($)) 0 [1..100000]
22:35:44 <lambdabot>   add an instance declaration for (Num (b -> b))
22:35:44 <lambdabot>     In the expression: 100000
22:35:58 <ddarius> > foldl (flip ($)) 0 (map (+) [1..100000])
22:36:08 <lambdabot>  5000050000
22:36:16 <ddarius> > foldl (flip ($)) 0 (map (+) [1..1000000])
22:36:32 <lambdabot>  thread killed
22:36:50 <moconnor> ddarius: basically, b/c it's non-strict the expression grows unevaluated in memory?
22:39:02 <ddarius> moconnor: This case is tricky in that really the strictness of flip ($) depends on the list input.
22:40:08 <ddarius> If all of the functions are strict, then yes you have that issue.
22:41:03 <ddarius> If they are all non-strict, then foldr is simply better (better memory usage, works on infinite lists)
22:42:38 <ddarius> If however, some of the functions are non-strict, or more dramatically, don't use their input at all, then foldl may be the best.
22:48:33 <dibblego> in formal logic notation, how do you constrain a free variable to a condition?
22:48:57 <dibblego> for example, "for all i where i % 2 == 0"
22:49:41 <sieni> dibblego: \forall x (Cond(x) => Foo(x))
22:50:04 <dibblego> ah thanks
22:50:25 <sieni> or with an existential quantifier: \exists x (Cond(x) /\ Foo(x))
22:51:07 <sorear> [x : *0] [_ : cond x] foo x  :)
22:58:16 <Korollary> dibblego: "i" is not free in that logic eq iirc
22:58:43 <dibblego> Korollary, yes, I was missing the proposition itself
22:59:03 <dibblego> "for all i where i % 2 == 0 ... some proposition about i"
23:01:37 <largos> has anyone tried building haskellDB recently?
23:01:49 <largos> I'm running into compile errors with the driver-hsql portion of the build
23:02:02 <whaleofconfusion> it's funny how there is the mathematical concept of "functions of a variable" so that you could have y = f(u, v) and u = f(t) then you also say that y is a function of t
23:02:12 <whaleofconfusion> but I don't think there is any programming language that directly accomodates that concept
23:02:14 <ddarius> \forall i \in { n | n % 2 == 0 } . Foo(i)
23:02:30 <hpaste>  largos pasted "driver-hsql errors" at http://hpaste.org/1850
23:02:53 <dibblego> ddarius, what is the actual symbol for \in ?
23:03:23 <ddarius> A curved E shaped thing usually, though occasionally : is used.
23:03:31 <dibblego> ah of course
23:03:40 <ddarius> whaleofconfusion: You mean u = g(t) ?
23:04:22 <whaleofconfusion> oh yes
23:05:01 <largos> actually, has anyone used haskellDB at all recently? the ubuntu package has some weird dependencies.. (it requires MySQL? shouldn't it manage with the db on a remote machine?)
23:05:14 <ddarius> whaleofconfusion: I imagine there are languages that let you do that, you could probably do that in Haskell; however, most programming languages prefer to make it explicit what the parameters are.
23:05:46 <whaleofconfusion> yes but it's a concept worth exploring
23:09:18 <ddarius> whaleofconfusion: Implicit parameters do pretty much exactly that.
23:10:53 <ddarius> They are a pretty unsuccessful and disliked extension.
23:13:32 <whaleofconfusion> I don't think that's quite it
23:13:52 <whaleofconfusion> here is what it would do, in a programming language
23:14:01 <whaleofconfusion> you could let x = f(y), y = g(z)
23:14:15 <whaleofconfusion> then let z = 2 and ask what x is without explicitly saying f(g(z))
23:14:28 <whaleofconfusion> it's a form of constraint propagation basically
23:14:45 <dibblego> how would you askwhat x is?
23:15:11 <whaleofconfusion> ? some syntactic construct ?  I'm not sure I see what you're asking
23:15:18 <dibblego> oh wait, I see
23:15:42 <whaleofconfusion> and here's something interesting
23:15:51 <whaleofconfusion> let's say x = f(y, z) and y = f(q)
23:15:54 <ibid> largos: haven't looked at the ubuntu package, but the debian packages depend on the mysql client library (and other db client libraries), not on the mysql database backend. this seems to me to be the correct way of doing it
23:15:56 <whaleofconfusion> let q = 2 and ask what x is
23:16:03 <whaleofconfusion> and have the response that it's a function of z
23:16:10 <dibblego> implicit parameters are in Scala - the language I use all day (sometimes Haskell because it's clearer :))
23:16:44 <dr_strangelove> did you notice that haskell.org is not indexed by google?
23:17:05 <dibblego> dr_strangelove, second hit for me
23:17:34 <ddarius> dibblego: He means if you did a search like "site:haskell.org foobar"
23:17:40 <dr_strangelove> yeah
23:17:42 <ibid> dr_strangelove: probably because of the robots.txt disallowing all robots in haskellwiki
23:17:43 <dibblego> ah right, yes I've noticed that
23:18:05 <dibblego> http://haskell.org/robots.txt
23:18:23 <ddarius> A pain in the ass as googling haskell.org used to be the easiest way to get mailinglist references.
23:18:24 <eumenides> is that because haskellwiki is full of arcane secrets that we don't want normal people to know?
23:19:24 <ddarius> whaleofconfusion: There are some systems/languages that do things like that and I would be far from surprised if there aren't some systems that do pretty much exactly that.
23:20:05 <desp> sigh
23:20:37 <desp> reading about polyvariadic functions has made me depressed
23:21:28 <dibblego> of all things eh?
23:21:58 <ddarius> desp: Why?
23:22:16 <desp> I mean, Oleg's implementation of said in Haskell
23:22:39 <ddarius> desp: Why?
23:22:44 <desp> I feel stupid.
23:22:56 <bos> oleg makes almost everyone feel stupid.
23:31:03 <largos> ibid: ah.. I'll look into it more.  I saw mysql-common, and assumed that had a dependency on server, but you're probably right.
23:32:32 <ibid> largos: i don't see a direct dependency on -common, perhaps it's pulled in by the client library?
23:36:05 <largos> ibid: could be
23:37:02 <largos> hm.. maybe I'm on crack, or it was fixed in the last update
23:38:16 <largos> well, I'll poke around more later. it's getting late over here
23:40:20 <whaleofconfusion> actually I think I was just describing a dataflow language
23:40:55 <whaleofconfusion> with currying
23:43:54 <ibid> largos: the changelog ought to tell you if that was changed :)
