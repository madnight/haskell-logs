00:32:04 <DRMacIver> Phew. I thought for a moment I'd double booked the evening of the LHUG meeting.
00:47:00 <osfameron> RARR!
00:52:24 <dmwit> > 148/150
00:52:26 <lambdabot>  0.9866666666666667
00:58:02 <araujo> hi!
01:00:02 <osfameron> morning :-)
01:02:37 <araujo> @yarr!
01:02:38 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
01:03:23 <dmwit> ?quote
01:03:24 <lambdabot> DennisHeuer says: What is that???? Your strategy shows that you just don't care.
01:03:32 <dmwit> ?quote
01:03:32 <lambdabot> augustss says: Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
01:04:57 <boegel> dcoutts_: I'm feeling incredibly lazy today, could you send me the single-window HaskLS version? I promise I won't throw it online ;-
01:05:14 <dcoutts> @arr
01:05:15 <lambdabot> Arrr!
01:05:30 <boegel> @yarr
01:05:31 <lambdabot> Drink up, me 'earties
01:06:14 <boegel> I got a invitation from some IT company in my (real) mail yesterday, inviting me for the new Pirates of the Carribean movie (ITers only)
01:06:29 <boegel> which is kinda cool, but I would to see it with my gf, and she's no ITer
01:07:16 <DRMacIver> boegel: Just tell her to start talking about monads every time someone asks what she's doing. Their eyes will glaze over and her bluff will remain uncalled. ;)
01:07:53 <boegel> DRMacIver: heh :-)
01:08:12 <boegel> "so, what are you into?" "Monads!" "please proceed" :D
01:08:27 <osfameron> these are not the imperative bots you are looking for
01:08:42 <osfameron> er, droids even, me--
01:08:54 <DRMacIver> osfameron fails at star wars.
01:09:05 * osfameron hangs his head in shame
01:09:07 <DRMacIver> (There are worse things to fail at)
01:10:00 <mux> morning haskellers
01:10:06 * boegel has been trying Firefox 2.0 on OSX for 10m and it is already causing problems
01:10:21 <DRMacIver> Salutations mux
01:10:30 <lypanov> ffx doesn't work too well at all... try camino or just stick to safari/webkit
01:10:39 <DRMacIver> boegel: Really? I'v enot found 2.0 substantially more problematic than 1.x on linux or windows.
01:10:49 <lypanov> its awful in comparison to the version on windows
01:11:00 * lypanov is a freak tho
01:11:03 * lypanov crashes everything
01:18:04 <Wild_Cat> Mac Firefox just plain sucks. It still uses QuickDraw!
01:19:30 <dmwit> ?karma me
01:19:31 <lambdabot> me has a karma of -1
01:22:13 <joelr1> good morning
01:22:48 <boegel> DRMacIver: it seemed to crash while doing a Save As... seems to be fine now though
01:26:48 <dmwit> Flash is still way buggy for me.
01:26:59 <dmwit> Other than that, things seem fine.
01:31:00 * DRMacIver doesn't use flash anyway. :)
01:31:16 <DRMacIver> And probably won't until they bother putting out a 64-bit VM.
01:33:02 <olsner> right-clicking flash animations halts my entire system for 1-30 seconds
01:34:30 <flux> well.. don't do that, then?
01:34:33 <flux> it does the same for me :)
01:35:29 <olsner> yeah, that's what I do... most of the time ;-)
01:36:03 <Wild_Cat> I don't remember who said Flash was just a replacement for the <blink> tag, but he's damn right.
01:36:46 <olsner> but how do you implement <marquee> using <blink>?
01:40:50 <Wild_Cat> I don't use IE, you insensitive clod! :p
01:41:50 * DRMacIver looks confused at Wild_Cat. But you're on the web right now!
01:44:45 <dmwit> How do you know he's on the web?
01:44:56 <dmwit> And who uses IE as a IRC client??
01:45:14 <Wild_Cat> dmwit: more people than you'd like to think, unfortunately -.-
01:46:08 <dmwit> Even if it's only one, it's more than I'd like to think. ^^
01:47:40 <DRMacIver> Beg pardon. There was supposed to be an extra ! after that sentence, in accordance with the "repeated punctuation indicates sarcasm" conventions.
01:51:45 <dmwit> f0rg1\/3n
01:52:26 <Baughn> dmwit: Of course they do. What else are java irc applets for?
01:57:57 <notsmack> (offtopic: can anybody with a copy of visio convert a .vsd to an image for me?)
02:06:41 <olsner> last night I dreamt I was stuck in a monad
02:09:09 <DRMacIver> But then you invoked unsafePerformOlsner to escape?
02:10:13 <matthew-_> monads are /so/ 2006. I have a structure which is way beyond a monad and is even beyond an arrow. It's like some combination of an arrow and a monad
02:10:56 <olsner> hmm... so you're saying that in a way, I was stuck in the past?
02:11:24 <matthew-_> err. no, you were probably dreaming ;-)
02:21:29 <mux> @remember < olsner> last night I dreamt I was stuck in a monad
02:21:30 <lambdabot> Done.
02:22:00 * olsner has been quoted!
02:22:54 <DRMacIver> As was pointed out to me the other day:
02:22:56 <DRMacIver> @quote <
02:22:56 <lambdabot> < says: olsner> last night I dreamt I was stuck in a monad
02:23:27 <DRMacIver> @remember olsner last night I dreamt I was stuck in a monad
02:23:27 <lambdabot> Done.
02:23:41 <norpan> @quote norpan
02:23:42 <lambdabot> norpan says: your sentence missing a verb
02:26:00 <ibid> @quote ibid
02:26:01 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
02:26:07 <ibid> nice
02:29:45 <olsner> good default set of quotes ;-)
02:30:32 <norpan> @quote
02:30:32 <lambdabot> xxd says: but 90% of programming is semantics
02:30:41 <mux> @quote mux
02:30:42 <lambdabot> mux says: "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
02:31:01 <dmwit> ?quote dmwit
02:31:01 <lambdabot> dmwit says: Curiously, the ellipsis is immune to relativistic effects.
02:31:27 <dmwit> ?quote
02:31:27 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
02:31:36 <dmwit> heh
02:32:50 <dmwit> ?quote lambdabot
02:32:51 <lambdabot> lambdabot says: Done.
02:32:56 <dmwit> ?quote lambdabot
02:32:57 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
02:33:08 <dmwit> ?quote lambdabot
02:33:09 <lambdabot> lambdabot says: You have QuickCheck and 3 seconds. Prove something
02:34:45 <dmwit> ?yow
02:34:46 <lambdabot> for ARTIFICIAL FLAVORING!!
02:35:14 <olsner> there should be an automated search tool for finding library functions that do the same as what you've written
02:35:19 <Maddas> it's 'cuneiform', not 'cuniform'!
02:35:21 <joelr1> is there a way to tell cabal that the executable built should not be installed?
02:35:42 <joelr1> i.e. i build a library and a test harness but only want to install the library
02:35:47 <Baughn> olsner: It's called hoogle
02:36:02 <Maddas> (Ironically, I only know this due to lisp code dealing with them.)
02:36:24 <olsner> does hoogle run on source files?
02:36:29 <quicksilver> joelr1: SC is systematic; it tries to check 'every possible'
02:36:48 <joelr1> quicksilver: right
02:37:00 <quicksilver> joelr1: QC is probalistic
02:37:11 <Baughn> olsner: It does not. But chances are there are only a few library functions with the same type signature as your function, and if one of them does the same thing, it /must/ have the same signature.
02:37:26 <bringert> joelr1: I picked the blog module because it gives you a text box to input some text, which is then shown transformed to  different format (hmarkup -> html), and it supports comments
02:37:43 <bringert> joelr1: though it has things you might not need, like rss support
02:37:55 <eumenides> ah i see. now i understand why runST $ ... doesn't work. that should really be documented somewhere more prominently
02:37:55 <joelr1> bringert: aha, i'm getting it now
02:38:36 <joelr1> bringert: i would need all the other bits later. i'm also thinking that haskelldb-flat could be made into haskelldb-s3 and then hope could run on the amazon elastic computing cloud
02:38:49 <bringert> joelr1: that would be nice
02:39:02 <bringert> though haskelldb-flat is a bit crappy still
02:39:17 <bringert> it needs transaction support
02:39:21 <joelr1> bringert: there are lots of things in hope that i don't understand yet. like how to structure the site layout
02:39:37 <joelr1> bringert: s3 doesn't have transaction support either. i guess that could be added with STM
02:40:08 <joelr1> bringert: but then it won't work if the app is distributed... but then i won't be distributing my app for a long while
02:40:16 <bringert> joelr1: have a look at configBoxes in Config.hs
02:40:45 <bringert> joelr1: if you use dynamic fastcgi, the web server could spawn multiple processes
02:41:18 <joelr1> bringert: oops, i didn't think of that /dynamic cgi/
02:41:47 <bringert> you can use static fastcgi instead, to hae only one process
02:41:52 <joelr1> bringert: i'm lookng at Config.hs.
02:41:57 <bringert> but that wouldn't cale that well
02:42:17 <joelr1> bringert: do the modules go left to right? what if you needed to go l -> r and top -> down?
02:42:31 <bringert> if you use lightttpd, you can have a single multithreaded fastcgi executable
02:42:37 <bringert> joelr1: CSS
02:42:43 <joelr1> bringert: yes, lighty is my server
02:42:57 <bringert> oh, then you could hack hope to be multithreaded
02:43:22 <joelr1> bringert: but how does lighty affect the fastcgi executable?
02:43:35 <joelr1> bringert: i thought hope, basically, runs as a separate server
02:44:04 <joelr1> bringert: or are you saying that i would need to hack hope to be multithreaded because lighty assumes a single fastcgi exe?
02:44:52 <bringert> joelr1: ideally, making it multithreaded just means replacing runFastCGI with runFastCGIConcurrent. hope runs as a fastcgi process, which the web server talks to. apache can't handled multithreaded fastcgi processes, but lighttpd can. as far as I know, lighttpd also works with multiple processes.
02:45:21 <bringert> it just seems more efficient to use haskell threading when possible
02:45:37 <bringert> to reduce memory use, and enable STM-based transactions in haskelldb-flat
02:45:52 <quicksilver> @tell ndm it's rude to reply to emails without logging on to IRC!!!
02:45:53 <lambdabot> Consider it noted.
02:45:59 <joelr1> bringert: be right back to ask about the differences, i.e. how come apache can't handle multithreaded fastcgi when it's all an outside process /breakfast/
02:47:57 <bringert> joelr1: apache's fastcgi module only sends one request at a time to a fastcgi process. so it actually can handle multithreaded fastcgi programs, it just can't take advantage of them.
03:08:31 <joelr1> bringert: i see what you are saying re: runFastCGIConcurrent
03:11:00 * bringert goes to lunch
03:21:24 <JohnMeacham> @where dons
03:21:24 <lambdabot> http://www.cse.unsw.edu.au/~dons
03:21:48 <JohnMeacham> @whereis dons
03:21:49 <lambdabot> Maybe you meant: where where+
03:22:57 <JohnMeacham> dons: jhc should compile a whole lot more of nobench now, I finished ripping out the grin back end to replace it with the fgrin backend. which I am retroactivly renaming to the grin back end. sneaky.
03:23:39 <DRMacIver> You probably mean:
03:23:40 <DRMacIver> @seen dons
03:23:41 <integral> @karma+ JohnMeacham
03:23:41 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 1d 11h 33s ago.
03:23:41 <lambdabot> JohnMeacham's karma raised to 4.
03:24:32 <malcolmw> JohnMeacham: dons went on holiday for a week
03:24:53 <JohnMeacham> ah. the x86 nobench results seem wonky on his site.
03:25:21 <JohnMeacham> the newest tag of jhc should do much better compilation wise than what he currently is using.
03:25:27 <malcolmw> the nobench results have been re-purposed to show differences between list/stream fusion versions
03:25:36 <JohnMeacham> ah. I see.
03:26:03 <malcolmw> you could use @tell to store a message for him
03:26:15 <JohnMeacham> is there a comparason between foldr-build and unfoldr-destroy?
03:26:47 <malcolmw> I don't think anyone has tried to implement unfoldr-destroy fully in the List library
03:27:15 <JohnMeacham> I see. I think you need something like metarules to make it work.
03:27:49 <malcolmw> rules to switch rules on/off?
03:28:04 <JohnMeacham> because unfolder is the best way to build a list and foldr is the best way to consume one,  but some can only do build or destroy.
03:28:30 <malcolmw> ah, but hylo (== foldr + unfoldr) is more general
03:28:48 <malcolmw> in a restricted sense
03:28:57 <malcolmw> :-)
03:29:01 <JohnMeacham> so, you would want to fire a rule to turn a unfoldr into a build only if it can't match a destroy but can match a foldr.
03:29:59 <dcoutts_> JohnMeacham: dons is on holiday for a week
03:30:28 <JohnMeacham> I might be mixing this up. but there is a definite 'best' one you want to do if you can for each side, but I don't think the current phasing rules of ghc are good enough to express the transformations you want. you don't want to end up having to write every possible combination of rules.
03:30:29 <dcoutts_> oh malcolmw said that :-)
03:30:33 <malcolmw> foldr/build can't do zips, unfoldr/destroy can do zips, but can't do something else I have temporarily forgotten.  foldr/unfoldr can do both
03:31:21 <JohnMeacham> hrm. I should have written this down somewhere...
03:31:31 <dcoutts_> as far as I know, unfoldr/destroy can do everything
03:31:36 <malcolmw> and the foldr/unfoldr (=hylo) solution is completely isomorphic to dcoutts' stream fusion
03:31:43 <dcoutts_> at least if you extend it in the way stream fusion does
03:31:57 <dcoutts_> streams are just a reformulation and extension of unfoldr/destroy
03:32:17 <dcoutts_> unfoldr/destroy originally did not do nested stuff like comprehensions
03:32:37 <dcoutts_> but you could implement that in the same way as we've done for streams
03:32:45 <JohnMeacham> I was playing with 'CATALYST's in jhc, which are rules that only fire if they enable another rule to fire. the idea being to use them to 'impedence match' different types of list fusion without rewriting things unnecesarily.
03:32:45 <malcolmw> I don't think streams bear much resemblence to destroy
03:33:16 <malcolmw> although they are very much unfold-like
03:34:14 <malcolmw> the consumption side is fine and dandy with foldr's rather than destroy's, no?
03:34:17 <dcoutts_> malcolmw: we can define destroy with streams and derive the unfoldr/destroy fusion rule from the streams rule (or was it ther other way around)
03:35:13 <JohnMeacham> is there a paper describing streams somewhere?
03:35:20 <dcoutts_> yes! :-)
03:35:26 <dcoutts_> @google stream fusion
03:35:28 <lambdabot> http://lambda-the-ultimate.org/node/2192
03:35:28 <lambdabot> Title: Stream Fusion | Lambda the Ultimate
03:35:30 <malcolmw> so streams/hylos subsume unfoldr/destroy, but I wouldn't be so sure about the other way round
03:35:45 <dcoutts_> right
03:36:04 <dcoutts_> for streams we're basicaly taking the args of unfoldr and putting them in a data type
03:36:16 <malcolmw> exactly
03:36:28 <dcoutts_> allowing us to separate the conversion between lists from the operations
03:36:59 * malcolmw has to go assess a student presentation on RTSJ
03:38:32 <dcoutts_> JohnMeacham: the trick we use is to rewrite to a fusable form in early phases and if they don't fuse, to write them back later.
03:39:29 <JohnMeacham> yes, but when there are alternate fusable forms, that doesn't work fully like you would want.
03:39:50 <dcoutts_> JohnMeacham: from what you describe of 'CATALYST', that might be better. Though sometimes you don't know locally that the transform might be beneficial
03:40:15 <dcoutts_> JohnMeacham: and ideally we can have a single fusion system that just works.
03:40:47 <vincentk> dcoutts_: typo in the paper: "the the nofib suite"
03:40:50 <JohnMeacham> yeah, the idea is locally hurtful things will be CATALYSTS so they won't fire unless they allow a better optimization overall
03:41:10 <dcoutts_> vincentk: what page is that?
03:41:22 <vincentk> p. 9
03:41:25 <dcoutts_> ta
03:41:29 <vincentk> 8.1 "Time"
03:41:29 <malcolmw> dcoutts_: grep "the the" :-)
03:41:37 <dcoutts_> oh yeah :-)
03:41:44 <vincentk> ;-)
03:41:53 <malcolmw> although that usually happens when the words are split across two lines
03:42:29 <vincentk> these kinds of things never happen to me, so don't expect any understanding from my side
03:42:39 <malcolmw> what we really need is a fully programmable term-rewriting system
03:43:05 <dcoutts_> yes.
03:43:40 <dcoutts_> but expressing the existing optimisation rules in such a system might be tricky
03:43:48 <dcoutts_> I mean the ghc simplifier
03:47:49 <JohnMeacham> like 'q' :)
03:48:29 <JohnMeacham> actuallp, a mini-q interpreter in haskell might be fun.
03:48:35 <dcoutts_> q?
03:50:05 <dmwit> ?foldoc raster blaster
03:50:08 <lambdabot> *** "raster" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
03:50:08 <lambdabot> raster
03:50:08 <lambdabot>  
03:50:08 <lambdabot>         <hardware> The area of a video display that is covered by
03:50:08 <lambdabot>         sweeping the electron beam of the display in a series of
03:50:10 <lambdabot> [8 @more lines]
03:50:16 <dmwit> ?more
03:50:16 <lambdabot>         horizontal lines from top to bottom.  The beam then returns to
03:50:17 <lambdabot>         the top during the vertical flyback interval.
03:50:17 <lambdabot>  
03:50:18 <lambdabot>         See also {CRT}, {frame buffer}.
03:50:20 <lambdabot>  
03:50:22 <lambdabot> [3 @more lines]
03:50:59 <JohnMeacham> http://q-lang.sourceforge.net/
03:51:01 <lambdabot> Title: Q - Equational Programming Language
03:51:04 <dmwit> Oh, that's just "raster".
03:51:17 <JohnMeacham> a lot of it was inspired by haskell actually.
03:53:26 <dmwit> The code on their "About" page is suspiciously Haskell-like.
03:55:30 <DRMacIver> Haskell has inspired an awful lot of things.
03:55:35 <DRMacIver> From Python to Java. :)
03:55:47 <DRMacIver> (As well as more interesting languages)
03:56:07 <lypanov> apl!
03:56:29 <DRMacIver> APL predates Haskell doesn't it?
03:56:34 <dmwit> I think last night people came to the conclusion that Python most definitely was *not* inspired by Haskell.
03:56:39 <JohnMeacham> yes. it is a pretty cool language. (Q)
03:56:43 <DRMacIver> dmwit: Certain features from it were.
03:56:56 <DRMacIver> Mainly the comprehension stuff.
03:57:01 <dmwit> In particular, the significant whitespace and list comprehensions were not.
03:57:12 <decaf> cool, if I can understand what the heck is lazu evaluation
03:57:21 <DRMacIver> Really? I'm pretty sure it's on official record that the list comprehensions were.
03:57:24 <decaf> then comes monads
03:57:48 <dmwit> A few people claimed that the "official record" was wrong.
03:57:53 <dmwit> decaf: Hi!
03:58:02 <DRMacIver> In what sense?
03:58:11 * dmwit goes grovelling through the logs
03:58:42 <Spark> i don't think haskell inspired java
03:58:56 <DRMacIver> decaf: Lazy evaluation is not figuring out what's going until the last possible moment that you need to. Monads are a fancy way of sequencing things together in programmer defined ways.
03:58:57 <dcoutts_> Spark: see java generics
03:59:12 <DRMacIver> Spark: Java generics borrow a lot conceptually from Haskell type classes.
03:59:20 <Spark> haskell isn't the only language to have parametric polymorphism
03:59:23 <dmwit> 03:11:30 <LeCamarade> Wikipedia says Python was inspired by Haskell. Utter hogwash. Guido spat when I asked.
03:59:49 <DRMacIver> Spark: It's just about the only language with type classes though, and Wadler was involved in the design of both.
03:59:58 <dmwit> (There's a few other relevant comments shortly thereafter, if you're interested.)
04:00:15 <dcoutts_> Spark: I think Philip Wadler worked on the design of Java generics
04:02:17 <Spark> yeah he did but i don't think that proves anything :)
04:03:14 <dcoutts_> heh heh
04:06:47 <dmwit> Interesting, Python is mentioned just about every day on this channel.
04:07:00 <dmwit> (From a highly unscientific sampling of log entries. YMMV)
04:07:07 <DRMacIver> Spark: He worked on the design of Java generics and said they were inspired by type classes. That does. :-p
04:07:27 <osfameron> dmwit: so is Perl, at least if I have anything to do with it :-)
04:08:47 <Spark> i forgot that everything phil wadler said was true, especially when it is advocacy of functional languages :)
04:09:26 <Spark> it's a shame i don't know haskell well enough to argue on technical grounds
04:09:33 <Spark> as it is, i'll just have to bullshit :)
04:09:48 <mrsolo_> python is very popular now
04:10:03 <Spark> so is heroin
04:10:18 <mrsolo> hence mentioned often
04:13:41 <DRMacIver> Spark: I feel it's entirely reasonable to expect that everything which Phil Wadler says about what Phil Wadler *actually did* should be taken as true.
04:14:58 <DRMacIver> One is constraint based and doesn't suck, while the other is subtyping based and does, but Java generics and parametric polymorphism with type classes fill very similar roles.
04:15:31 <quicksilver> well some of the simplest and most useful parts of java generics are more like unbounded polymorphism
04:16:16 <quicksilver> just being able to write the code for a Collection<A> instead of CollectionOfFrogs
04:16:26 <quicksilver> that's just 'plain' polymorphism
04:17:57 <DRMacIver> Sure
04:18:17 <DRMacIver> But it's also used for things like Comparable, Enum, etc. where the behaviour is more like that of a type class.
04:18:43 <Cheery> This is probably useless here, but see! http://mikeash.com/getting_answers.html
04:18:45 <lambdabot> Title: Getting Answers
04:18:51 <DRMacIver> And you frequently want constraints for the collections as well. e.g. a Collection<? extends Foo>
04:20:11 <Spark> wadler didn't have anything to do with wildcards did he?
04:21:09 <Spark> doesn't look like it
04:25:40 <DRMacIver> No, I don't think so. But the wildcards are not that relevant there. It could just as easily have been a Collection<T extends Foo>
04:25:47 <DRMacIver> Or even Collection<T extends Foo<T>>
04:28:21 * quicksilver cheers for contravariant typing problems
04:29:12 <quicksilver> "I can't possibly use Haskell, it's so hard to understand, and Java is so much simpler". "Fine, explain to me the interaction between Java Generics and contravariance"
04:29:58 <mauke> whenever I see "contravariance" I think "ArrayStoreException"
04:35:16 <DRMacIver> quicksilver: Java generics are perfectly straightforward. :)
04:35:32 <quicksilver> DRMacIver: Haskell is perfectly straightforward. :)
04:35:44 <DRMacIver> (And are never contravariant in their parameters, so I'm not sure what you're asking)
04:35:59 <DRMacIver> quicksilver: Mmhmm. :)
04:36:52 <cpoucet> assembly is perfectly straightforward
04:36:58 * bringert is back
04:38:16 * LoganCapaldo applauds the return of bringert
04:41:08 <quicksilver> DRMacIver: yes, but you acheive contravariance when you pass something covariant 'on the left of an arrow'
04:41:26 <quicksilver> DRMacIver: extends vs. super, in java notation
04:41:45 <quicksilver> DRMacIver: the discussion in http://etymon.blogspot.com/2007/02/java-generics-and-covariance-and.html covers some of this ground
04:41:48 <lambdabot> Title: Etymon: Java generics and the covariance and contravariance of arguments, http://tinyurl.com/ytezdh
04:42:52 * joelr1 is studying bringert's blog module
04:43:53 <nominolo> bringert has a blog module?
04:44:57 <kolmodin> in 'hope' I guess
04:45:27 <nominolo> ?where hope
04:45:28 <lambdabot> http://hope.bringert.net/
04:46:16 <Amran> hello
04:46:38 <Amran> does anyone know why I keep getting an "Exception Unknown" connecting to an sqlite3 database using HDBC.Sqlite3?
04:46:40 <DRMacIver> quicksilver: Oh, is that all you mean? That's non-mysterious too. :) 'though I don't know what you mean by including syntactic sugar for List.
04:46:53 <Amran> looked online but couldn't find a thing
04:46:54 <quicksilver> DRMacIver: I didn't write that :) I don't know what he meant
04:47:02 <DRMacIver> Oh, sorry.
04:47:22 <quicksilver> DRMacIver: but I'm just saying, there is an issue here (as there will be in any object-hierarchy generics implementation)
04:47:29 <quicksilver> DRMacIver: it's subtle, and it catches people out
04:47:38 <quicksilver> DRMacIver: if it never catches you out, good :)
04:47:49 <DRMacIver> Anyway, yes. Wildcards for achieving co and contravariance are well established and relatively sane. I'd have liked co(ntra)variant parameters instead, but wildcards do the job.
04:48:56 * DRMacIver has many issues with Java generics, but they mostly concern the implementaiton rather than the design.
04:49:46 <quicksilver> DRMacIver: I'm trying to make a different point than that.
04:50:12 <quicksilver> DRMacIver: My point is that java generics are important, useful, and yet they are subtle. IMO they undermine the opinion that some people have about the relative complexity of Java and Haskell
04:51:16 <DRMacIver> I genuinely don't find Java generics particularly subtle.
04:51:21 <DRMacIver> 99% of the time they just do the obvious thing.
04:51:48 <DRMacIver> And more importantly they're less immediately neccessary than a lot of Haskell's more confusing features.
04:52:35 <DRMacIver> On the other hand what I'm definitely not saying is "Java is so much easier than Haskell, you should teach it to all beginning students or they will run screaming from the class as soon as you mention the word 'monad'!!"
04:53:19 <DRMacIver> But I don't think it's complexity comes from things like generics.
04:53:32 <bringert> Amran: it could be that HDBC does something silly when printing the exception, maybe there is a way to get a better message?
04:53:48 <Amran> bringert: yeah was thinking that
04:54:01 <Amran> bringert: but now it's working again, for some reason :-)
04:54:44 <Amran> bringert: seems HDBC doesn't play nice with the sqlite3 install on osx - it worked once I removed the db created with sqlite3, and created a new one from within haskell
04:54:55 <bringert> odd
04:55:02 <bringert> maybe a file permission thing?
04:55:19 <Amran> nopes - files were writable
04:55:48 <Amran> now I've created the db in haskell, sqlite3 can't read it either
04:57:37 <bringert> maybe it uses sqlite, not sqlite3 by mistake?
04:57:55 <Amran> yeah - checking that.
04:57:57 <bringert> anyone else getting "stack overflow" when uploading to hackage?
04:58:04 <Amran> thought the driver IS called HDBC.Sqlite3
05:01:03 <Amran> ah - it was a version mismatch
05:01:14 <Amran> 3.1.3 for hdbc vs 3.3.5 for sqlite
05:14:32 <DRMacIver> Hm. Is Moggi's original paper on monads online somewhere?
05:15:03 <joelr1> bringert: can you point me to the css that ties the boxes together?
05:16:14 <bringert> joelr1: the beginning of style/hope.css, and a little bit in theme/hope/style.css, if you use the 'hope' theme
05:17:12 <bringert> joelr1: my CSS layout skills aren't that great, there's probably a better way to do it
05:17:42 <bringert> joelr1: for example, see the top entry here: http://www.scannedinavian.com/hope/entry
05:17:52 <joelr1> bringert: my css skills are worse than yours :-)
05:18:11 <joelr1> bringert: what about that top entry?
05:19:05 <bringert> in my browser, the <pre> text runs out of the box, into the right sidebar
05:19:22 <bringert> try increasing your font size to provoke it
05:19:42 <joelr1> one sec
05:19:57 <joelr1> bringert: yes, i see it now
05:19:59 <bringert> not important, just saying that the current hope CSS isn't perfect
05:20:19 <bringert> my goal has been to generate generic xhtml, and use CSS for all layout and styling
05:20:32 <LoganCapaldo> admirable
05:20:53 <joelr1> bringert: makes total sense
05:22:02 <joelr1> bringert: my dilemma right now is whether to sign up for 125/mo hosting on a "solaris container" (a fraction of 4 cpus and 16gb of memory) or go with amazon ec2 where i have a 1.8Ghz cpu and 1gb of memory but, essentially, no db or permanent disk space
05:22:53 <joelr1> bringert: of course it's possible to add a driver for s3 to haskelldb and write the s3 library itself but all that takes time
05:23:04 <decaf> how many fractions ?
05:23:07 <bringert> joelr1: for $125/mo, you could get your own box, right?
05:23:20 <joelr1> bringert: at amazon it's 70/mo
05:23:36 <joelr1> decaf: take a look at large opteron container at joyent.com
05:24:00 <joelr1> bringert: with ec2 i get my own box for 70
05:24:13 <bringert> a box with no disk?
05:24:20 <joelr1> bringert: the joyent and ec2 approach provides scalability
05:24:27 <bringert> true
05:24:32 <joelr1> bringert: well, there's disk but it goes away upon reboot
05:24:35 <decaf> I prefer my own box, really good choices available for $125/mo
05:24:53 <joelr1> bringert: meaning that you can only use that disk for temp stuff
05:25:25 <joelr1> bringert: i'm inclined to start with a _very_ small subset of hope, one that doesn't use a database and has a single module, the one i'm trying to create
05:26:11 <bringert> joelr1: that sounds like you should just write your own program from scratch, using the fastcgi and xhtml packages
05:26:47 <joelr1> bringert: hmm... that was my next question. but i would like to be able to add the rest of hope eventually
05:26:58 <joelr1> bringert: i would still like boxes, for example
05:27:09 <bringert> using hope without a database would require some messing about
05:27:12 <joelr1> bringert: i would miss all that if i were to start with fastcgi and xhtml, right?
05:27:13 <syntaxfree> these Qi people write like cranks. Are they?
05:27:37 <ndm> how would people "measure" the complexity of piece of haskell code?
05:27:37 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:27:41 <ndm> number of lexemes?
05:28:02 <joelr1> bringert: suppose that i stripped all modules but my new one that doesn't use a database. and used the flatdb. would it work?
05:28:24 <joelr1> bringert: i like the module concept also
05:28:29 <DRMacIver> ndm: I measure it in milliliters of ear bleeding. :)
05:28:36 <joelr1> ndm: howdy
05:28:41 <ndm> joelr1: hi
05:28:49 <bringert> hmm, the database is used for user logins, keeping track of sessions, and for settings
05:28:54 <ndm> DRMacIver: its for a paper, so i will need to define "one standard ear"
05:29:05 <lambdakjot> number of functional dependencies?
05:29:23 <DRMacIver> Oleg lines per line?
05:29:28 <bringert> settings you can do without, if you just use the defaults
05:29:34 <ndm> i am hoping the Oleg index is 0
05:29:39 <joelr1> bringert: which is fine, in fact, it will just go away when the box crashes
05:29:40 <ndm> the number of FD's certainly is!
05:29:48 <joelr1> bringert: but if that happens then there will not be any sessions
05:30:13 <bringert> and you don't need any user accounts?
05:30:39 <malcolmw> cyclomatic complexity (defn in any standard software engineering textbook)
05:30:41 <bringert> currently, hope does not create the database if it is missing, but you could add that
05:30:44 <joelr1> bringert: not initially. eventually i will want user accounts either for my blogging or for users of the site
05:30:52 <lambdakjot> ndm: McCabe Cyclomatic Metric
05:31:14 <bringert> joelr1: you will have to mess with the bowels abi, but it should be doable
05:31:23 <bringert> s/abi/a bit/
05:31:41 <bringert> if you don't have users, there's no need for sessions
05:31:42 <ndm> @google cyclomatic complexity wikipedia
05:31:42 <joelr1> bringert: i don't need to mess if i leave the flatdb in, right?
05:31:43 <lambdabot> http://en.wikipedia.org/wiki/Cyclomatic_complexity
05:31:44 <lambdabot> Title: Cyclomatic complexity - Wikipedia, the free encyclopedia
05:32:25 <bringert> hmm, ok, if keep the db file in your static read-only storage
05:32:28 <bringert> you
05:32:29 <bringert> dammit
05:32:29 <chitin> > let isUnorthodox a b = any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b] in isUnorthodox 49 98
05:32:31 <lambdabot>   add an instance declaration for (Fractional Int)
05:32:45 <bringert> that should work
05:33:10 <joelr1> bringert: it will go away upon reboot, of course, but that should get me started
05:33:11 <bringert> so you don't want to keep the data that users enter permanentely?
05:33:22 <bringert> sure
05:33:46 <joelr1> bringert: nope. all i would want to do is store the MD5 hash in S3 eventually so that users don't have to pay to get the same program (source code) translated again
05:33:47 <malcolmw> ndm: I suggested cyclomatic complexity because it measures control-flow paths, and haskell doesn't have control flow :-)
05:33:52 <bringert> you could put in all of hope + flatdb, and just have all data go away on reboot
05:34:16 <bringert> btw, I would use sqlite3 rather than flatdb if possible
05:34:35 <joelr1> bringert: duly noted
05:34:36 <bringert> flatdb is just a proof of concept
05:34:55 <joelr1> bringert: what's the concept of ITEM in hope? i see Blog/Types.hs using it
05:35:34 <bringert> for a minimal effort getting-started deal, I'd go with flatdb at first though, since that reduces the dependencies quite a bit
05:35:36 <joelr1> there's Item and Item HTML
05:35:40 <bringert> hmm
05:35:48 * bringert can't remember exactly
05:35:52 <bringert> let me see
05:36:00 <joelr1> hmm... also Item RSS
05:36:32 <bringert> ah, ITEM is the class of things that can be converted to and from Item
05:36:44 <joelr1> bringert: but what is an item?
05:36:46 <joelr1> conceptually
05:36:46 <bringert> Item is the type of things stored in the items table in the DB
05:36:50 <joelr1> do i need an item
05:36:58 <joelr1> oh, i see
05:37:19 <bringert> if you want to store things in the DB, and not add a DB table, then you need a Item
05:37:28 <bringert> see Hope.Item.Types
05:37:35 <joelr1> bringert: ok, no db for me initially
05:37:55 <joelr1> bringert: just big box to paste source code in, show resulting html
05:38:03 <bringert> ok, that should be really easy
05:38:06 <joelr1> bringert: very minimalistic initially
05:38:48 <bringert> all you need is a POST handler then
05:39:07 <bringert> that just gets the input, transforms it, and outputs it in a box
05:39:12 <joelr1> bringert: so i should start by stripping Blog.hs to leave in the Module description and the resource handler, right?
05:39:29 <joelr1> bringert: where the resource handlers are 1) present empty box, 2) handle post
05:39:34 <joelr1> bringert: right?
05:39:44 <bringert> joelr1: you may want to start with the static module instead if it's that simple
05:39:52 <joelr1> allright
05:40:15 <bringert> I think those should even be the same path, the first as a get handler, the second as a post handler
05:40:30 <joelr1> bringert: noted
05:40:42 <bringert> but that's just a matter of style
05:40:51 <joelr1> bringert: sort of like this?       ["static","add"] -> return [get handleStaticAddGET,  post handleStaticAddPOST]
05:41:03 <bringert> exactly
05:41:42 <bringert> hmm
05:41:46 <joelr1> bringert: so how do i structure the project? do i copy hope over, rename the project, strip it of the bits i do not need, add my only module and go from there?
05:44:04 <chitin> what is the type of this: isUnorthodox a b = any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b] ?
05:44:32 <joelr1> :t True
05:44:35 <lambdabot> Bool
05:44:52 <joelr1> :t isUnorthodox a b = any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b]
05:44:54 <lambdabot> parse error on input `='
05:45:03 <joelr1> :t let isUnorthodox a b = any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b]
05:45:05 <lambdabot> <command line>:
05:45:06 <lambdabot>     Could not find module `L':
05:45:12 <chitin> I get the error: "Instance of Fractional Int required for definition of isUnorthodox" when trying to run it
05:45:17 <roconnor> :t any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b]
05:45:19 <lambdabot> Not in scope: `a'
05:45:20 <lambdabot>  
05:45:20 <lambdabot> <interactive>:1:8: Not in scope: `b'
05:45:31 <roconnor> :t \a b -> any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b]
05:45:34 <lambdabot>     No instance for (Fractional Int)
05:45:34 <lambdabot>       arising from use of `/' at <interactive>:1:14-16
05:46:25 <bringert> you could check out the darcs repo, edit Config.hs to not import the moduels you don't want, and edit the Makefile / cabal file to remove the package deps you don't want
05:46:25 <roconnor> :t let isUnorthodox a b = any ((a/b)==) [ x / y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b] in isUnorthodox
05:46:28 <lambdabot>     No instance for (Fractional Int)
05:46:28 <lambdabot>       arising from use of `/' at <interactive>:1:39-43
05:46:38 <roconnor> oh right
05:46:49 <LoganCapaldo> roconnor: maybe you want div?
05:46:52 <roconnor> :t let isUnorthodox a b = any ((a/b)==) [ fromInteger x / fromInteger y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b] in isUnorthodox
05:46:54 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
05:46:54 <lambdabot>     In the first argument of `fromInteger', namely `x'
05:47:01 <joelr1> bringert: i'm on my way!
05:47:07 <roconnor> :t let isUnorthodox a b = any ((a/b)==) [ fromIntegral x / fromIntegral y | x <- (map digitToInt . show) a, y <- (map digitToInt . show) b] in isUnorthodox
05:47:09 <lambdabot> forall b. (Fractional b) => b -> b -> Bool
05:47:17 <chitin> hmm nice
05:47:19 <chitin> thanks
05:47:21 <bringert> you could leave the code for module you don't use in place if you want, they shouldn't be compiled if they aren't included from Config.hs
05:47:35 <joelr1> bringert: one more question... do you have any examples of grabbing xml from a url and parsing it?
05:48:06 <bringert> joelr1: not in hope, but I've wanted to write an RSS aggreator module.
05:48:19 <bringert> joelr1: use the http package, look at its get.hs example
05:48:25 <joelr1> bringert: right
05:48:37 <bringert> I think hxt has example of that whole chain
05:48:49 <joelr1> bringert: thanks. hacking away to convert hope into algokit
05:48:53 <joelr1> bringert: ok
05:59:06 <Itkovian> heh, I just found a Haskell command line tool to post to Jaiku. preatty cool.
05:59:50 <chitin> does there exist a fromInt function?
06:00:55 <norpan> @type fromInteger
06:01:01 <lambdabot> forall a. (Num a) => Integer -> a
06:01:04 <Baughn> :t fromIntegral
06:01:07 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:01:24 <norpan> yeah, fromIntegral is probably what you want
06:01:42 <chitin> thanks
06:03:26 <njd> @users
06:03:27 <lambdabot> Maximum users seen in #haskell: 336, currently: 305 (90.8%), active: 43 (14.1%)
06:06:08 <DRMacIver> That's quite impressive. We're actually larger than ##java
06:07:00 <LoganCapaldo> Yes! the revolution is coming!
06:07:01 <lambdakjot> Very nice
06:09:39 <quicksilver> I wonder if they can relocate to #java now
06:09:40 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
06:09:52 <quicksilver> after all, the project has an open source core now
06:10:25 <Syzygy-> What does the difference between ##<programminglanguage> and #<programminglanguage> entail?
06:10:39 <quicksilver> Syzygy-: to have only one # you have to be a open source project
06:10:43 <quicksilver> since this is freenode
06:11:49 <Baughn> Syzygy-: To have only one # it has to be the official channel of the project
06:11:54 <Baughn> ## denotes an unofficial one
06:12:28 <ski> #math
06:12:29 <Baughn> ..which makes me wonder why it's #lisp and not ##lisp
06:12:45 <LoganCapaldo> the official math channel, <g>
06:12:59 <ski> probably those channels were established before this freenode decision
06:13:18 <Baughn> It"s ##C, though
06:15:20 <Syzygy-> Ah.
06:16:44 <Wild_Cat> yeah, the way I understand it, ## is either an unofficial channel (##C) or the official channel of something that's not open-source (##textmate)
06:16:59 <lambdakjot> ##java is considerably quieter than this channel to boot
06:18:02 <ndm> malcolmw: i saw your coarbitrary instance, can you answer a question on it?
06:18:16 <malcolmw> ndm: fire away
06:18:18 * mux ponders the ##C# channel
06:18:23 <Syzygy-> Hehe
06:18:25 <Syzygy-> ##F#
06:18:29 <mux> heh
06:18:35 <mux> it hurts my eyes
06:18:46 <Syzygy-> ##C#&F#
06:19:01 <ndm> malcolmw: you have variant 0..n-1 for each constructor, how does quickcheck  know how many variants there are?
06:19:18 <ndm> and what if you have a just one constructor, is that still variant 0 ?
06:19:18 <Syzygy-> Topic for ##C#&F#: We love ALL the black keys
06:19:27 <malcolmw> ndm: it doesn't
06:20:02 <ndm> ok, i think i have a rough idea how it works
06:20:12 <Baughn> Syzygy-: That has been sufficiently discussed. Actually, it's supposed to be ##C##, for some bizarre reason.
06:20:20 <ndm> malcolmw: and in your example, are you missing a Arbitrary context for the free type variable?
06:20:38 <malcolmw> ndm: yes, I probably forgot the context
06:20:56 <ndm> malcolmw: cool, i'm just hacking it into derive, by example - so once i have one example, i have them all
06:21:05 <malcolmw> the defn of 'variant' is easy enough to read (slightly more difficult to understand)
06:21:47 <ndm> yeah, i don't want to understand
06:22:34 <malcolmw> ndm: it just involves splitting the random seed v times, where v is the argument to variant
06:23:31 <chrismbrown_> Syzygy-: we could call it ##Dmajor :)
06:23:43 <malcolmw> ndm: make sure you have a look at the instances  defined in Test.QuickCheck, to see if there are any special cases
06:23:52 <ndm> doh, my derivation guesser crashes with a pattern match failure
06:24:04 <ndm> malcolmw: i'll just take a guess and wait for bug reports ;)
06:28:23 <roconnor> ndm: I always think of coarbitrary as making a mixing function by composing together other mixing functions.
06:28:52 <roconnor> varient n is a different mixer for ean n.
06:29:06 <roconnor> the idea is that all your data should make mixers in different ways
06:29:17 <roconnor> varient n is a different mixer for each n
06:30:06 <roconnor> since the constructor for your data is part of the data, the varient mechnism is an easy way to make all the different constructors mix in different ways, because you give each a unique varient.
06:30:18 <roconnor> the value for n is not important, so long as the are all differernt
06:30:35 <roconnor> and if you only have one constructor, then varient isn't necessary
06:30:45 <roconnor> although it doesn't hurt
06:42:58 <ndm> neat, well Derive now supports coarbitrary, and it did it by infering the instance generator from an example
06:43:04 <ndm> i.e. nearly no work for me :)
06:43:51 <nominolo> :t let f = (undefined :: a -> b) in first f *** second f
06:43:54 <lambdabot> forall a b d a1 b1 d1. ((a, d), (d1, a1)) -> ((b, d), (d1, b1))
06:44:07 <nominolo> :t let f = (undefined :: a -> b) in first f &&& second f
06:44:10 <lambdabot> forall a b a1 b1. (a, a1) -> ((b, a1), (a, b1))
06:44:28 <LeCamarade> Who knows a theorem prover I'll use without getting scars?
06:44:35 <nominolo> :t let f = (undefined :: a -> b) in first f . second f
06:44:37 <lambdabot> forall b b1 b2 d. (d, b1) -> (b, b2)
06:44:41 * LeCamarade has never done such evilness before.
06:44:42 <ndm> LeCamarade: what do you want to prove?
06:45:04 <nominolo> :t \f -> first f . second f
06:45:06 <lambdabot> forall c d. (d -> c) -> (d, d) -> (c, c)
06:45:35 <LeCamarade> Um ... you see, I want to be able to say some function will _always_ work. I know I can use QuickCheck, but ... is that what you use, for example?
06:45:42 <LeCamarade> Ne really theorem prover./
06:45:53 <LeCamarade> Not really really a theorem prover.
06:46:16 * LeCamarade should sift his mind to take out redundant stuff. Or he needs to sleep.
06:46:40 <Saizan> LeCamarade: maybe you need Catch
06:47:04 <LeCamarade> @go catch
06:47:07 <lambdabot> http://www.catch.com/
06:47:08 <lambdabot> Title: Catch - Catch.com
06:47:16 <LeCamarade> Too wide.
06:47:29 <ndm> @where catch
06:47:30 <lambdabot> http://www.cs.york.ac.uk/~ndm/catch/
06:47:32 <LeCamarade> @go catch programming proof
06:47:37 <lambdabot> http://www.cs.nott.ac.uk/~gmh/mgs-appsem4.ppt
06:47:37 <LeCamarade> ?
06:47:40 <LeCamarade> :oD
06:47:45 <ndm> LeCamarade: catch proves the absence of pattern match errors, in a way that is pretty automatic and very scar free
06:47:54 <ndm> LeCamarade: but it won't prove that a function does what you want it to
06:48:28 <LeCamarade> ndm: Why doesn't GHC do that, by the way? OCaml does ...
06:48:49 <ndm> LeCamarade: no, OCaml doesn't, it simply warns if patterns are incomplete - GHC can do as well with -fwarn-incomplete-patterns
06:48:59 * roconnor wonders if varient 0 === id ?
06:49:16 <ndm> LeCamarade: Catch actually generates a proof it won't crash, and goes inside functions like head/tail etc
06:49:58 <LeCamarade> Oh. Bon.
06:50:12 <ndm> plus you can still use incomplete patterns, just it checks they are used safely
06:50:16 <ndm> @google checking xmonad catch
06:50:19 <lambdabot> http://neilmitchell.blogspot.com/
06:50:19 <lambdabot> Title: Neil Mitchell's Haskell Blog
06:50:30 <ndm> LeCamarade: check my blog for how i proved xmonad safe
06:51:51 <roconnor> > varient 0 4
06:51:52 <lambdabot>   Not in scope: `varient'
06:51:58 <roconnor> > variant 0 4
06:51:59 <lambdabot>   Not in scope: `variant'
06:52:05 <roconnor> @hoogle variant
06:52:06 <lambdabot> Test.QuickCheck.variant :: Int -> Gen a -> Gen a
06:52:22 <roconnor> > Test.QuickCheck.variant 4
06:52:23 <lambdabot>   Not in scope: `Test.QuickCheck.variant'
06:52:24 <LeCamarade> ndm: Adding you to my feeds.
06:52:42 <ndm> LeCamarade: just add planet.haskell.org - i'm on there, and so are lots of other interesting things
06:52:48 <roconnor> @src Test.QuickCheck
06:52:48 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:52:58 * LeCamarade knows it is a long time coming. And there's dons, kolmodin, et al.
06:53:07 <roconnor> @src Test.QuickCheck.variant
06:53:07 <lambdabot> Source not found. Take a stress pill and think things over.
06:53:09 <LeCamarade> Aye.
06:58:10 <LPhas> is there some doc about writing a read instance?
06:58:45 <nominolo> :t \f -> second (f .)
06:58:47 <lambdabot> forall b c a d. (b -> c) -> (d, a -> b) -> (d, a -> c)
06:59:06 <pchiusano> hi, I have an easy question
06:59:17 <pchiusano> how the heck do I import my own modules?
06:59:30 <quicksilver> import Pchiusano.Top.Secret
06:59:45 <pchiusano> how does it know which files to look in?
07:00:03 <joelr1> the reason i love haskell: you can hack away at the source to something and be assured that static typing will catch whatever you have broken
07:00:11 <joelr1> try that with lisp, for example
07:00:19 <joelr1> i have
07:01:07 <ndm> is anyone else getting bounces from "mail_support@riec.tohoku.ac.jp" when they post to Haskell-cafe?
07:01:20 <joelr1> ndm: yep, we should contact the list admin
07:01:30 <ndm> joelr1: with a baseball bat!
07:01:43 <quicksilver> pchiusano: it looks in Pchiusano/Top for a file called Secret.hs or Secret.o
07:02:03 <pchiusano> like, in your current directory?
07:02:40 <quicksilver> it will look there, yes
07:03:01 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
07:03:04 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
07:03:06 <quicksilver> pchiusano: read all about it :)
07:04:36 <pchiusano> quicksilver, thx
07:05:32 <ndm> JaffaCake: are you aware that for every post to haskell-cafe, a bounce message comes back from tohoku.ac.jp?
07:06:00 <ndm> JaffaCake: i suspect that by removing the tohoku.ac.jp email from the subscription list, we can stop this - they aren't reaching the subscriber anymore anyway
07:06:07 <Igloo> ndm: What does the bounce look like?
07:06:18 <joelr1> Igloo: mail support ... jp
07:06:19 <JaffaCake> ndm: thanks, I'd half-noticed that
07:06:26 <ndm> @paste
07:06:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:06:34 <hpaste>  ndm pasted "Bounce messages" at http://hpaste.org/1781
07:07:04 <pchiusano> oh, I see, compilation is kinda like C, in that you need to explicitly compile all the files needed by a module - I was think you'd just import the needed modules and you could just compile your main module, which would pull everything in
07:07:19 <pchiusano> anywho, thx
07:08:16 <malcolmw> pchiusano: look for "ghc --make" which does what you want
07:08:19 <shapr> pchiusano: I use "ghc --make Module"
07:08:45 <quicksilver> ndm: I had a couple of those and filed them as spam without looking at them
07:08:54 <quicksilver> ndm: didn't occur to me they might be 'genuine' bounces :)
07:09:30 <ndm> quicksilver: me too at first, but its now one per post - i got the hint when got a bounce from japan saying Malcolm isn't a registered user...
07:11:37 <pchiusano> malcolmw: cool, thanks
07:13:10 <shapr> joelr1: I know that hot loading in HAppS was a goal at one point. But at that time 6.6 had come out, and hs-plugins didn't work with 6.6.
07:13:12 <kombinator> Hello everyone, getCPUTime gives me time with precision of up to 4ms, does anyone know a function that is more procise?
07:13:27 <JaffaCake> ndm: I can't find the right subscriber to haskell-cafe - there's noone listed from tohoku.ac.jp, and the other .jp subscribers don't look suspicious
07:13:54 <joelr1> shapr: i'm trying to hack at hope now
07:13:59 <ndm> JaffaCake: weird, perhaps its someone who is forwarding to his .jp, and rewritting the headers - causing it all to go wrong...
07:14:07 <JaffaCake> ndm: also the bounces aren't proper bounces, they don't have the full history, so I can't tell who the original subscriber was
07:14:25 <joelr1> shapr: my pet peeve is alex not releasing happs with S3. i may just have to roll my own
07:14:54 <joelr1> JaffaCake: anyone in support @ jp?
07:15:00 <joelr1> JaffaCake: like mail_support?
07:15:10 <JaffaCake> I could try, I guess
07:15:20 <ndm> JaffaCake: :( - shall i try emailing the uni?
07:15:46 <JaffaCake> I'll reply to one of the bounces, see what happens
07:15:47 <LeCamarade> Q. Do you know what it would mean if GHC ran QuickCheck on every pure function it compiled? A. I'd still be struggling with hello.hs
07:16:03 <JaffaCake> it'll probably end up on haskell-cafe
07:16:05 <shapr> joelr1: Let me see if the reasons you shouldn't be peeved are NDA'd
07:16:06 * JaffaCake rolls eyes
07:16:52 <LeCamarade> @test ((\x -> null $ drop 100 x) :: [a] -> True)
07:16:53 <lambdabot> Maybe you meant: let list tell temp
07:17:01 <shapr> joelr1: I'm pretty sure the S3 saver code works, and I can probably get it into the repo if you really want it..
07:17:19 <joelr1> shapr: would you kindly?
07:17:33 <joelr1> shapr: lemmih said it's working
07:17:52 <joelr1> shapr: is there s3 loader code to go with saver? :D
07:18:17 <shapr> joelr1: Hm, not sure. But the problem is that Amazon changed their pricing. Now it's something like $0.01 for a thousand PUTs
07:18:30 <joelr1> shapr: i don't care, personally, my business model allows for it
07:18:38 <shapr> Alex says he intends to reply to you and will make an announcement about it soon.
07:18:49 <shapr> Ok, you can probably get the S3 saver code anyway.
07:18:51 <joelr1> shapr: although i understand it changes _your_ business model
07:19:02 <joelr1> shapr: why do you keep calling it saver code?
07:19:05 <shapr> Yeah, we wanted to use S3 as a filesystem.
07:19:13 <Igloo> shapr: What was the old pricing structure?
07:19:20 <joelr1> shapr: that would be awesome, how does it work now?
07:19:36 <shapr> Igloo: Sum of total bandwidth.
07:20:07 <shapr> For that pricing structure, I was going to run my own server on EC2/S3. It'd be cheaper than anything else.
07:20:40 <joelr1> shapr: i'm deploying on ec2 myself
07:20:57 <joelr1> shapr: why do 1c per 1k reqs bother you?
07:21:16 <shapr> We wanted to write to S3 many times a second.
07:21:26 <shapr> That would add up quickly.
07:21:41 <joelr1> shapr: so... where can i talk to alex? and when will you add s3 to the repo? i need it, like, yesterday! :-)
07:21:56 <quicksilver> many/1000 * seconds * $0.01 !
07:22:12 <joelr1> shapr: but you get latency with S3 and no transactions. why write to it many times a second? the data won't be available right away anyway. may not be, there are no guarantees
07:22:32 <shapr> joelr1: We'd fixed the latency and transaction problems already.
07:22:46 <joelr1> shapr: fixed them? within happs?
07:22:49 <shapr> Yup
07:23:14 <DRMacIver> njbartlett: I take it you have a script which does that rather than writing a personal email to everyone in the unexpected high number of registrations? :)
07:23:14 <joelr1> shapr: there's something to ponder... with s3 you can write a s3 driver for haskelldb and then you can run HOPE on ec2
07:23:43 <njbartlett> DRMacIver: no, actually I did it with manual cut and paste :-(
07:23:47 <shapr> I think the 1c per 1k reqs will always be a problem.
07:24:25 <njbartlett> When I say higher than expected, I mean there were 36. Just on the cusp of doing it manually versus writing a script, I feel.
07:24:32 <joelr1> shapr: how did you fix latency? it's not in your powers i would think. transactions via stm, right?
07:25:02 <shapr> I don't know how much of what we've done is NDA'd.
07:25:11 <DRMacIver> njbartlett: Why not just do an email to all? :)
07:25:38 <dcoutts_> joelr1: sounds like you need to take out a support contract with shapr and co :-)
07:25:41 <njbartlett> DRMacIver: Because that wouldn't get past a lot of people's spam filters.
07:25:43 <shapr> heh
07:25:48 <DRMacIver> Ah
07:25:53 <joelr1> shapr: so... when can you make the s3 code available in the repo? will it include the fixed latency and transaction issues?
07:26:09 <shapr> No, it won't include the latency/transaction solution.
07:26:15 <joelr1> dcoutts_: maybe... dunno yet :) i may just roll my own. after all, lemmih says it's a week of work
07:26:36 <joelr1> shapr: will it include the loader to go with the saver?
07:26:38 <dcoutts_> but Lemmih is a great coder
07:26:54 <shapr> joelr1: I don't know. Lemmih did all the S3 code.
07:27:02 <joelr1> dcoutts_: right
07:27:08 * dcoutts_ would not like to spend >week recreating Lemmih's work
07:27:08 <joelr1> shapr: when? when? when?
07:27:22 <joelr1> dcoutts_: i've got more time than money, see
07:27:29 <dcoutts_> ah
07:27:41 * ndm has little of either
07:27:49 <dcoutts_> ndm: heh, same here.
07:27:53 <joelr1> it's a fine balance, of course
07:28:30 <joelr1> i've got some money saved away and i've got an alpha of my compiler. need to deploy it on the web now
07:28:43 <joelr1> create a web app
07:28:50 <joelr1> hack away at hpaste or hope
07:28:52 <dcoutts_> shapr: remind me what you're using for (binary?) serialisation at the moment
07:29:04 * dcoutts_ is hacking on binary again
07:29:24 * earthy is happy to not hack for a bit
07:29:27 <shapr> When we use binary serialisation, we use Data.Binary. But for the most part we're using Read/Show, which makes me crazy sometimes.
07:30:36 <joelr1> shapr: how can i get in touch with alex? and when are you going to add s3 to the happs repo?
07:31:26 <dcoutts_> shapr: so how important to you is (de)serialisation speed vs size of serialised output ?
07:31:32 <shapr> joelr1: He's going to reply to you.
07:31:48 <joelr1> shapr: when? when? when?!
07:31:58 <dcoutts_> joelr1: chill :-)
07:32:03 * ndm thought joelr1 had lots of time ;)
07:32:11 <shapr> joelr1: later today on #happs, how about that?
07:32:15 <quicksilver> he said he had more time than money
07:32:19 <quicksilver> but maybe he has no money?
07:32:21 <quicksilver> and just a little time
07:32:25 <dcoutts_> heh heh
07:32:25 <mdmkolbe|work> Who do I talk to about the X11 library not building in ghc-HEAD?
07:32:32 <Nafai> joelr1: Perhaps I haven't been paying attention enough...but what's your compiler for?
07:32:33 <ndm> mdmkolbe|work: #xmonad
07:32:45 <joelr1> Nafai: EasyLanguage to C#
07:32:50 <shapr> dcoutts_: Size matters.
07:32:50 <joelr1> @google LtU EasyLanguage
07:32:53 <lambdabot> http://lambda-the-ultimate.org/node/2201
07:32:53 <lambdabot> Title: Easylanguage: domain specific language for trading stocks | Lambda the Ultimate
07:33:00 <ndm> @remember shapr Size matters.
07:33:01 <lambdabot> Done.
07:33:05 <shapr> heh
07:33:26 <shapr> dcoutts_: One of the HAppS principles is "keep all app state in memory"
07:33:29 <joelr1> i've got some money and i've got as much time as the money can afford me. i'm not working on anything else now
07:33:31 <dcoutts_> shapr: ok, interesting, that'd be because you're paying bandwidth for it I suppose?
07:33:40 <dcoutts_> shapr: oh, in memory.
07:33:41 <Nafai> joelr1: Cool!
07:34:11 <Saizan> shapr: but, do you keep it serialized in memory?
07:34:28 <shapr> Probably not, but sometimes I think it would be useful.
07:34:39 <dcoutts_> shapr: and do you ever need to deserialise random access style or would it always be linear access?
07:34:53 <hpaste>  mdmkolbe|work pasted "X11 build error in ghc-HEAD" at http://hpaste.org/1782
07:34:54 <shapr> Everything has been linear so far.
07:34:55 <Saizan> uhm yeah, like hpaste that keeps quote gzipped
07:35:13 <dcoutts_> shapr: ok, good good.
07:35:28 <Igloo> mdmkolbe|work: You need the C X11 development library
07:35:57 <dcoutts_> shapr: so I'm figuring I can get away with not doing bit level serialisation and using gzip instead, which is probably faster.
07:36:01 <shapr> dcoutts_: Oh hey, I was wondering about how to do 'type tags' with Data.Binary.
07:36:11 <dcoutts_> shapr: how do you mean
07:36:18 <joelr1> shapr: so are you going to continue with that ec2 business venture?
07:36:34 <Igloo> mdmkolbe|work: Hmm, although I don't know why it's even trying to build it, as configure should have failed
07:36:47 <mux> this more looks like a ldconfig cache problem
07:36:47 <mdmkolbe|work> Igloo: Is /usr/X11R6/lib/libX11.a not enough?
07:37:11 <shapr> We had the same bug twice, where data.binary was used to save a value into a bytestring, and sent across the wire, and then we deserialized it as some other type, giving an unexpected result.
07:37:25 <dcoutts_> shapr: right. versioning.
07:37:28 <shapr> joelr1: Yeah, we're still using EC2.
07:37:59 <dcoutts_> shapr: so you want to trade a bit of redundancy for some version consistency
07:38:17 <mdmkolbe|work> Igloo: I thought /usr/X11R6/lib/libX11.a *was* the C X11 development library
07:38:25 <dcoutts_> shapr: I presume you don't need to go as far as being able to convert, just to be able to detect inconsistency ?
07:38:32 <mux> mdmkolbe|work: it looks like a ldconfig cache problem
07:38:44 <mux> this command should use libX11.so anyways.
07:39:22 <mux> err not !
07:39:23 <shapr> dcoutts_: We will need to be able to convert lower versions of state to higher versions, but I wasn't thinking of doing that with Data.Binary.
07:39:24 <mux> I'm being stupid
07:39:27 <shapr> Hm, maybe I should think about that.
07:39:33 <mux> mdmkolbe|work: you need -L/usr/X11R6/lib
07:39:55 <mux> command was: gcc -lX11 dist/build/Graphics/X11/Types_hsc_make.o -o dist/build/Graphics/X11/Types_hsc_make
07:40:02 <dcoutts_> shapr: one interesting format to consider is erlang's format.
07:40:04 <mux> it looks like the configure script didn't properly set LDFLAGS
07:40:04 <Igloo> mdmkolbe|work: That's a static library; I'm not usre if it'll be used by default
07:40:15 <mux> Igloo: shouldn't since gcc isn't passed -static
07:40:28 <joelr1> shapr: are you having any trouble with ec2?
07:40:59 <mdmkolbe|work> Igloo: so wouldn't it then take libX11.so or does it need libX11.so.a?
07:41:14 <mux> oh well..
07:41:17 <Igloo> mdmkolbe|work: libX11.so is what it wants
07:41:19 <shapr> dcoutts_: What's erlang's format?
07:41:54 <Igloo> mdmkolbe|work: What does X11.buildinfo look like?
07:42:35 <joelr1> dcoutts_: it's not THAT interesting. only recently did they start to store floats in a binary format, for example
07:42:45 <shapr> dcoutts_: Google doesn't turn up anything immediately, can you tell what I should look for?
07:43:01 <dcoutts_> shapr: erlang values are untyped, they're just atoms which are basically strings. So they have a tag + data style. It's possible to decode without knowing the format before hand.
07:44:03 <sjanssen> hmm, is Typeable safe to use for binary tagging?
07:44:11 <shapr> Sounds like BEncode in bittorrent.
07:44:56 <Nafai> joelr1: What did they store floats in beforehand?
07:45:07 <joelr1> Nafai: text i guess
07:45:51 <joelr1> bringert: where is boxes called from? in Config.as there's boxes m = ... and i'm trying to figure out where m is being built
07:46:04 <mdmkolbe|work> Igloo: you gave me the clue that I think solves this.  I had run 'boot' before I did './darcs-all --extra get' so their was no 'libraries/X11/configure' so there was no 'libraries/X11/X11.buildinfo'
07:46:30 <joelr1> bringert: never mind. configBoxes = boxes
07:47:05 <joelr1> bringert: and then, i think, mkBoxes calls config
07:47:46 <dcoutts_> sjanssen: I fear Typeable would not be suitable because it has no defined format across implementations
07:48:05 <sjanssen> dcoutts_: true
07:48:19 <sjanssen> dcoutts_: how would you do it?
07:48:41 <dcoutts_> sjanssen: something like typeable probably
07:49:09 <joelr1> bringert: still, if you could point me to the code that builds up the main box i would appreciate it!
07:49:34 <roconnor> @hoogle Applicative
07:49:35 <lambdabot> No matches found
07:49:48 <roconnor> @docs Control.Applicative
07:49:49 <lambdabot> Control.Applicative not available
07:52:59 <dcoutts_> shapr: I can't find it now either :-(
07:53:46 <joelr1> shapr: i would be willing to talk $$$ with alex but i need to make a decision _now_
07:54:19 <sjanssen> @hoogle $$$
07:54:20 <lambdabot> No matches found
07:54:37 <joelr1> hehe
07:55:28 <shapr> joelr1: Send him an email!
07:55:51 <joelr1> shapr: i did. a couple of days ago, i think. a reply has not been forthcoming.
07:59:04 <ndm> @hoogle $
07:59:05 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
07:59:05 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
07:59:05 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
07:59:40 <mdmkolbe|work> Igloo: ok, maybe that wasn't the problem.  X11/configure exists now, but X11.buildinfo doesn't.  I did a top level ./boot; ./configure; make and the same error still happens.
08:00:27 <Igloo> mdmkolbe|work: make clean in libraries first
08:00:51 <bringert> joelr1: Hope.View.outputBox
08:01:10 <joelr1> bringert: looking
08:01:15 <bringert> and Hope.View.formatOutput
08:02:09 <bringert> in the static module, outputBox is used, for example on staticAddBox
08:02:16 <bringert> from Hope.Module.Static.View
08:02:24 * bringert goes home
08:02:28 <joelr1> bringert: thanks
08:02:38 <joelr1> bringert: one last bit
08:02:52 <joelr1> bringert: what is pulling in the static module ? what box?
08:03:03 <joelr1> bringert: or does the module itself specify what box it goes into?
08:03:53 <bringert> the resource handler in the module calls outputBox on the thing it wants to output
08:04:12 <joelr1> bringert: but how does the module know to go in a particular box?
08:04:26 <bringert> it always goes in the main box
08:04:34 <bringert> if it's a resource handler
08:04:49 <joelr1> bringert: so where does it say that the froont-page should display a static box?
08:04:56 <bringert> if you want it to go somewhere else, just export a box, and use that in Config.boxes
08:04:59 <hpaste>  cdsmith pasted "Problem defining a monad" at http://hpaste.org/1783
08:05:10 <cdsmith> Anyone want to take a look at that?
08:05:25 <dcoutts_> cdsmith: you can't do that basically
08:05:29 <bringert> joelr1: like the default Config.hs puts latestEntriesShortBox in rightBar
08:05:36 <joelr1> bringert: yes, i saw some modules defining a box. i guess that's what you call exporting.
08:05:49 <cdsmith> dcoutts_: okay... is there a work-around?
08:06:02 <joelr1> bringert: ok, thanks!
08:06:06 <dcoutts_> cdsmith: monad does not allow any class constraints on the type of return/>>=
08:06:14 <bringert> latestEntriesShortBox is exported by Hope.Module.Blog
08:06:25 <bringert> later
08:06:34 <dcoutts_> cdsmith: the work around is not to use Eq on the monad methods, only on specific operations in that monad.
08:06:53 <cdsmith> dcoutts_: like, define something else instead of return?
08:07:15 <dcoutts_> cdsmith: well you could alway make it not a monad, then you can do whatever you like.
08:07:38 <cdsmith> dcoutts_: Ah yes, but I'm trying to cheat and take advantage of the nice do syntax.
08:07:44 <dcoutts_> but if you want it to be a monad you do need to define return and >>=
08:08:13 <cdsmith> dcoutts_: right, but I could define something like return = error "Don't do that!", right?
08:08:30 <dcoutts_> cdsmith: a monad without return is pretty useless :-)
08:08:51 <cdsmith> Well, I'll poke around at it.  Thanks.
08:08:53 <dcoutts_> cdsmith: even more so without >>= and that's the one that is your problem I think
08:09:19 <dcoutts_> or would be, obviously at the moment you're using undefined
08:09:36 <dcoutts_> cdsmith: see the discussion on why Set cannot be a monad
08:09:44 <dcoutts_> same problem here
08:09:48 <cdsmith> okay
08:10:04 <hpaste>  (anonymous) annotated "hdbc + happs + string fuckup" with "(no title)" at http://hpaste.org/1784#a1
08:30:26 * ibid *finally* has the new laptop in a working order
08:30:34 * ibid is now processing the planet backlog
08:30:45 <ibid> (yes, even *that* issue)
08:31:48 <mdmkolbe|work> Igloo: The 'make clean' in libraries seems to have fixed it, thx
08:39:40 <ndm> dcoutts_: are you coming to fun in the afternoon?
08:40:01 <dcoutts_> ndm: probably, what is the date of it again?
08:40:14 <ndm> dcoutts_: next thursday - 1 weeks time
08:40:21 <dcoutts_> oh cool
08:40:24 <dcoutts_> yeah
08:40:44 <ndm> cool, i think the York people are too
08:42:54 <ibid> planet updated
08:43:45 <dcoutts_> ibid: so what's changed?
08:46:50 <ndm> looks like more feeds to me
08:54:32 <ibid> dcoutts_: more feeds, changed the offending feed
08:55:13 <dcoutts_> ah yes, the thing about caching
09:11:52 * SimonRC reads about some of the ugly corners of the Haskell typesystem
09:12:05 <SimonRC> The lack of lexically scoped type variables sucks.
09:13:25 <mdmkolbe|work> SimonRC: example?
09:13:39 <Saizan> there's an extension for them
09:13:45 <osfameron> yay!  I'm on planet haskell!
09:14:24 <joelr1> ibid: can i get back on planet haskell again?
09:14:42 <SimonRC> mdmkolbe|work:   f x s = let y = read s in [x, y]
09:14:47 <SimonRC> what is the type of y?
09:14:58 <SimonRC> well, it's the same as the type of x, obviously
09:15:10 <SimonRC> but it is a PITA to tell the compiler that
09:15:25 <dmhouse> SimonRC: Turn on -fscoped-type-variables. They'll be in Haskell-prime.
09:15:52 <dmhouse> And that isn't really an 'ugly corner'. You just can't write a type signature. If you wanted it for documentation purposes, comment it out or something.
09:15:56 <Saizan> SimonRC: won't that be inferred?
09:16:15 <SimonRC> Saizan: quite possibly in this case
09:16:30 <SimonRC> by "Haskell" I meant "Haskell98"
09:16:38 <mdmkolbe|work> dmhouse: with that flag would you write "f x s = let (y::a) = read s in [x::a,y::a]"?
09:17:45 <SimonRC> or even, "f :: a -> String -> [a] ; f x s = let (y :: a) = read s in [x, y]" ?
09:17:56 <dmhouse> Almost.
09:18:06 <SimonRC> ah
09:18:12 <Saizan> in this case it's pretty redundant
09:18:15 <dmhouse> f :: forall a. a -> String -> [a]. You need the foralls.
09:18:22 <SimonRC> ouch
09:18:30 <SimonRC> but yes, of course
09:18:44 <SimonRC> if would be nice to turn it on for just part of the file, then
09:19:02 <ibid> joelr1: hm, why did i remove you in the first place? :)
09:19:07 <SimonRC> or to bae able to have regions of foralls
09:19:09 <SimonRC> hm
09:19:13 <joelr1> ibid: i thought i was doing ocaml :D
09:19:21 <ibid> ok :)
09:19:27 <ibid> uncommented, update running
09:19:31 <joelr1> ibid: which i did for a while but then could not deploy it on the web, at least not easily
09:19:37 <Saizan> SimonRC: even if you have the flag on you can still omit forall in signatures where you don't need it
09:19:37 <joelr1> ibid: back to haskell now
09:20:12 <SimonRC> Saizan:   < dmhouse> f :: forall a. a -> String -> [a]. You need the foralls.
09:20:37 <joelr1> ibid: thanks
09:20:56 <joelr1> who is eric mertens on this channel?
09:20:56 * SimonRC goes
09:21:00 * SimonRC goes
09:21:18 <arcatan> quite redundant
09:21:23 <arcatan> quite redundant
09:21:52 <Saizan> joelr1: the author of hpaste? glguy
09:22:00 <joelr1> Saizan: thanks
09:22:03 <joelr1> glguy: ping
09:22:10 <monochrom> Ha ha
09:22:39 <Saizan> he's not going to be here often for some time, i think :)
09:22:50 <joelr1> Saizan: oh! how come?
09:23:19 <Saizan> marrying
09:23:33 <joelr1> Saizan: right...
09:24:02 <joelr1> Saizan: there seems to be an issue with hpaste but no new patches
09:24:44 <Saizan> the code from /hpaste won't compile with 0.8.8
09:24:55 <joelr1> Saizan: correct
09:25:00 <joelr1> Saizan: any workarounds?
09:25:45 <Saizan> get from /hpaste-devel and apply a patch that i can give you :)
09:26:10 <joelr1> Saizan: sure
09:26:40 <Saizan> (even if it's not properly tested, just made it compile)
09:26:52 <Saizan> dcc send or email?
09:27:11 <joelr1> Saizan: anything
09:27:14 <joelr1> try dcc first
09:29:18 <joelr1> Saizan: hcolour issues. oh, well
09:29:34 <joelr1> maybe i have an older version. let me upgrade
09:29:42 <Saizan> you need the darcs version
09:29:49 <joelr1> Saizan: i have that
09:29:53 <Saizan> oh
09:29:55 <joelr1> Saizan: just updated,, recompiling
09:30:25 <joelr1> i wanna use hscolour to colorize c# code
09:30:49 <Saizan> isn't it haskell specific?
09:30:55 <malcolmw> joelr1: you just need to write a C# lexer I suppose
09:31:17 <joelr1> malcolmw: aha!
09:31:21 <malcolmw> joelr1: (can't be too different from haskell lexing)
09:31:45 <joelr1> malcolmw: guess not. just some code generated by alex, i suppose. alex = the haskell lexer
09:32:52 <malcolmw> joelr1: oh, and the token-classifier will be slightly different too, but the basic architecture can be taken from hscolour without too much problem
09:33:11 <joelr1> malcolmw: right. i'll look into it in a few weeks
09:33:28 <Saizan> arcatan: ?where zlib
09:33:32 <Saizan> ?where zlib
09:33:33 <lambdabot> I know nothing about zlib.
09:33:42 <Saizan> ?hackage zlib
09:33:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
09:34:43 <joelr1> woohoo! just got my happs hello world running!
09:36:06 <ddarius> URL?
09:36:23 <joelr1> ddarius: :) not yet
09:36:31 <joelr1> ddarius: let me get algokit.com up and running
09:41:39 <vincentk> Fedora Core Test Page ;-)
09:42:59 <fab> hi, how can i use "runghc" without linking the threaded runtime? "-threaded" seems to be the default option and i could not find a way to negate it.
09:44:13 <dcoutts_> fab: ghc itself is linked with -threaded, so runghc uses the threaded rts. Only way to change that is to rebuild ghc. You probably just want to compile your prog rather than using runghc.
09:45:29 <Saizan> is there a reason because when installing a compiled ghc head i don't get headers like HsBase.h in include/ ?
09:45:29 <fab> dcoutts_, thanks. using runghc for small programs seemed convenient, but it looks like i have to write a makefile :)
09:45:46 <dcoutts_> fab: ghc --make is just as easy :-)
09:46:43 <dcoutts_> fab: no need for makefiles, either just use ghc --make or use the cabal build system
09:46:47 <fab> dcoutts_, wow, thats nice
09:47:45 <vincentk> very worthwhile, i think: http://en.wikibooks.org/wiki/Haskell/Packaging
09:47:46 <lambdabot> Title: Haskell/Packaging - Wikibooks, collection of open-content textbooks
09:49:18 <mux> mmm, STM is only exposed from GHC.Conc?
09:49:28 <mux> I would have expected a STM module
09:49:33 <emu> there is
09:49:37 <emu> Control.Concurrent.STM
09:49:44 <mux> ah, thanks
09:49:52 <mux> hoogle was telling me GHC.Conc
09:50:01 <emu> hoogle needs an update i guess
09:50:05 <mux> yup
09:50:08 * mux eyes ndm 
09:50:08 <emu> @hoogle newTMVar
09:50:08 <lambdabot> Control.Concurrent.STM.TMVar.newTMVar :: a -> STM (TMVar a)
09:50:13 <mux> hmmm
09:50:20 <mux> @hoogle atomically
09:50:21 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
09:50:26 <mux> see, I'm not mad :)
09:50:26 <emu> which hoogle are you speaking of?
09:50:30 <emu> @hoogle atomic
09:50:31 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
09:50:31 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
09:50:31 <lambdabot> Foreign.C.Types.CSigAtomic :: data CSigAtomic
09:50:35 <emu> hmm
09:50:37 <ndm> mux: yes, hoogle needs an update :)
09:50:44 <dmwit> ?hoogle STM
09:50:44 <lambdabot> Control.Concurrent.STM :: module
09:50:45 <lambdabot> GHC.Conc.STM :: data STM a
09:50:45 <lambdabot> Language.Haskell.TH.Stmt :: data Stmt
09:50:54 <ndm> mux: but some of it is the fault of the haddock stuff... - and some from before i used haddock
09:50:55 <emu> @index atomically
09:50:55 <lambdabot> GHC.Conc, Control.Concurrent.STM
09:51:02 <pitecus> @hoogle sleep
09:51:02 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
09:51:12 <ndm> i am working on a hoogle update
09:51:19 <ndm> but other things keep getting in the way...
09:51:19 <pitecus> is there a sleep function?
09:51:27 <emu> threadDelay
09:51:31 <emu> @index threadDelay
09:51:31 <lambdabot> GHC.Conc, Control.Concurrent
09:51:35 <pitecus> ok
09:51:38 <assl0r> >  [ 3 + 2^n | n <- [1..10] ]
09:51:42 <lambdabot>  [5,7,11,19,35,67,131,259,515,1027]
09:54:17 <hpaste>  Cheery pasted "trying out the reactive -module." at http://hpaste.org/1785
09:55:41 <assl0r> how do i "cast" int to bool?
09:55:59 <Saizan> > toEnum 0
09:56:01 <lambdabot>  0
09:56:05 <Cheery> > toEnum (2 :: Int) :: Bool
09:56:07 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
09:56:11 <Saizan> > toEnum 0 :: Bool
09:56:11 <Cheery> > toEnum (0 :: Int) :: Bool
09:56:13 <lambdabot>  False
09:56:13 <lambdabot>  False
09:56:17 <Cheery> > toEnum (1 :: Int) :: Bool
09:56:19 <lambdabot>  True
09:56:25 <assl0r> O_o
09:56:43 <Saizan> Cheery: toEnum is monomorphic in the argument type
09:56:50 <Cheery> @hoogle Int -> Bool
09:56:51 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
09:57:03 <Cheery> @hoogle toEnum
09:57:04 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
09:57:09 <mauke> assl0r: (/= 0)
09:57:13 <dmwit> assl0r: (/= 0)
09:57:25 <mauke> STEREO
09:57:30 <dmwit> heh
09:58:11 <Cheery> I think hoogle could be improved by doing it capable of tracing class instances as well
09:58:21 * ddarius waits for people to @quote stereo in stereo.  Actually, I think that that has already happened.
09:58:23 <Cheery> ie. you'd give Int -> Bool, it'd give toEnum
09:58:56 <Cheery> or is there a feature which lets you do it?
09:59:07 <dmwit> ?hoogle (Enum a) Int -> a
09:59:09 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
09:59:09 <lambdabot>  
09:59:12 <dmwit> ?hoogle (Enum a) => Int -> a
09:59:13 <lambdabot> Prelude.toEnum :: Enum a => Int -> a
09:59:14 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
09:59:14 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
09:59:17 <Saizan> i think we'll get it for hoogle 4
09:59:42 <Cheery> current is third version?
10:01:45 <dmwit> Is this your name? - "Don Stewart " [Y/n]:
10:01:45 <dmwit> Is this your email address? - "<dons@cse.unsw.edu.au>" [Y/n]:
10:01:48 <dmwit> heh
10:04:11 <Cheery> I'd like to do something like: react (integral 0 (constant 45)) >>= rotateX >> renderTriangle
10:04:29 <Cheery> but I don't know how such thing could be done in general
10:04:31 <shapr> dmwit: What's that from?
10:04:38 <dmwit> mkcabal
10:04:43 * shapr grins
10:05:01 <shapr> Cheery: With Yampa, or just in general?
10:05:07 <Cheery> just in general
10:05:13 <shapr> Cheery: Have you read the Yampa Arcade paper?
10:05:26 <Cheery> yes
10:05:32 <shapr> What did you think?
10:06:04 <Cheery> I'm really annoyed from the fact that I can't use IO as a 'sheet' to put my reactive functions on
10:07:01 <Cheery> now you need to put actual reactive functions quite far away in code from what they cause
10:07:16 <Cheery> in simple programs only, thought
10:07:40 <shapr> It's better in more complex programs?
10:07:43 <sjanssen> dmwit: that's really funny!
10:08:18 <Philippa> Cheery: not by much, you can drop an IO action into your event values
10:08:19 <ndm> Cheery: hoogle does do class instances
10:08:28 <shapr> Cheery: Hm, pesco wrote a nifty OpenGL toy that responded to mouse and keyboard input, but I can't find the code on my drive, sorry.
10:09:11 <ndm> it should so happens that there are lots of Int -> Bool things, but Hoogle 4 will make toEnum much higher
10:09:11 <Cheery> ndm: yes, I saw, you just must specify that you do class instances, I don't know whether that's bad or good
10:09:32 <Cheery> shapr: I'd say the limitation is lesser in bigger programs, where you get further succumbed inside the reactive functions
10:09:35 <ndm> Cheery: no, you don't have to: http://haskell.org/hoogle/?q=Int+-%3E+Bool
10:09:37 <lambdabot> Title: Int -> Bool - Hoogle
10:09:59 <ndm> toEnum is result 5, and things like odd/even are actually much better matches than fromEnum
10:10:15 <ndm> member isn't a great result in this case however, but it certainly finds it
10:11:15 <Cheery> oh, cool!
10:11:35 <roconnor> > Test.isBottom undefined
10:11:40 <Cheery> it was only in @hoogle -command that it shows only short sample from the set
10:11:40 <lambdabot>   Not in scope: `Test.isBottom'
10:12:02 <roconnor> > Test.QuickCheck.Batch.isBottom undefined
10:12:04 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
10:12:58 <Cheery> so, hoogle 4 will be just more precise by putting more interesting functions to the front?
10:14:35 <ndm> Cheery: it will deal better with type classes, at the moment Int vs Enum a is penalised for not being a free variable a, in Hoogle 4 it will be penalised less because a is not free
10:14:44 <ndm> hopefully that will get a lot better results in these cases
10:15:00 <Cheery> shapr: pesco's opengl toy isn't in net?
10:15:24 <ndm> i.e. at the moment Int vs Enum a is translated to Int == a, Enum Int - soon it will be just Enum Int
10:16:07 <Cheery> interesting
10:17:16 <ndm> plus at the moment, Monads don't work with the type classes - thats being fixed as well
10:20:35 <Cheery> ?where HList
10:20:36 <lambdabot> http://homepages.cwi.nl/~ralf/HList
10:22:40 <sm> morning all
10:23:16 <Cheery> HList seems like useful, Does it some day become standard haskell module?
10:23:54 <bos> Cheery: it's not all that useful, really.
10:25:00 <Cheery> bos: how so?
10:25:30 <bos> Cheery: you just need to use it surprisingly infrequently.
10:25:41 <assl0r> how can i "prove" that two infinite lists are equal? (in haskell, on paper it wouldn't be a problem)
10:25:58 <Cale> assl0r: You don't.
10:26:19 <Cale> assl0r: You can never finish computing the two lists, so you can't prove that they're equal.
10:26:43 <olsner> > let x = [1..] in x == x
10:26:53 <lambdabot> Terminated
10:27:00 <Cale> (and the code which makes them up is hidden)
10:27:27 <assl0r> so only paper and pencil
10:27:55 <Cale> Yeah, you basically have to step outside the system to do it.
10:28:10 <punkinside> hey guys, I was wondering if anyone could help with some Alex stuff?
10:28:20 <punkinside> it would be much appreciated
10:28:26 <dmwit> assl0r: Either that, or create a human-level intelligence as step one. ;-)
10:28:51 <Baughn> assl0r: No human-level intelligence is needed - only an automated theorem checker
10:28:59 <joelr1> @hoogle (+++)
10:28:59 <Baughn> Of course, you get to write the theorem. ;)
10:29:00 <lambdabot> Did you mean: (+++)
10:29:01 <lambdabot> Prelude.undefined :: a
10:29:01 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:29:16 <joelr1> ?src (+++)
10:29:16 <lambdabot> Source not found. You speak an infinite deal of nothing
10:29:29 <ndm> @hoogle +++
10:29:30 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:29:30 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
10:29:30 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
10:29:38 <ndm> Hoogle really hates those brackets
10:29:47 <joelr1> ndm: thanks!
10:29:56 <ndm> and the "did you mean" message is a bit of a lie ;)
10:30:08 <Philippa> punkinside: you're probably better off asking away. Personally I don't know much about alex though
10:30:11 <assl0r> Baughn, is there an implementation available for haskell?
10:30:39 <Cheery> bos: type-level lists are useful in abstracting away some interfacing code, making it a bit nicer
10:30:40 <Baughn> assl0r: I'm not the right person to ask. Anyhow, doing it by pencil should be good enough
10:30:59 <bos> Cheery: sure. they're just not used terribly often.
10:31:50 <punkinside> Philippa: thanx, its probably something dumb on my part, but after using AlexPosn in all my token definitions without problems, I wrote a function to report line/col of a lexical error raiseException :: AlexPosn -> String -> a and ghci tells me that the data constructor AlexPosn is not in scope!
10:32:03 <Cheery> maybe, but are you sure it'd be a reason to leave them away from stdlib?
10:32:43 <Cheery> I mean, there's some lesser stuff in it too, like Text.Html and Graphics.Renderer.GL
10:33:03 <bos> Cheery: no, i'm just claiming that it won't happen unless someone who actually uses them pushes to add them.
10:33:07 <Cale> assl0r: If you could really do it reliably in an automatic way, you could solve all sorts of mathematical problems :)
10:33:21 <punkinside> raiseException (AlexPosn _ line col) = error "Invalid Character at (" ++ show line ++ " / " ++ show col ++ ")"
10:34:10 <assl0r> Cale, right...
10:34:19 <assl0r> that would be really nice *g*
10:34:38 * bos is updating the fedora version of ghc to 6.6.1
10:34:59 <Cheery> bos: you mean sane use of them or insane use of them?
10:35:04 <Cale> It's like, hmmm... I wonder if the Goldbach conjecture is true?
10:35:17 <Baughn> Is the osx/intel version of GHC actually broken, or am I doing this wrong? (Trying to compile it)
10:36:05 <bos> @users
10:36:06 <lambdabot> Maximum users seen in #haskell: 336, currently: 319 (94.9%), active: 51 (16.0%)
10:40:27 <punkinside> already figured it out
10:48:45 <assl0r> whats the diffrence between $ and $!
10:48:46 <assl0r> ?
10:48:56 <cdsmith> assl0r: structness
10:49:03 <cdsmith> err, strictness I mean
10:49:15 <cdsmith> $! fully evaluates the argument before applying it.
10:49:36 <assl0r> ah okay ;) thx
10:50:14 <cdsmith> @src $!
10:50:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:50:25 <cdsmith> @src ($!)
10:50:26 <lambdabot> Source not found. I feel much better now.
10:50:29 <cdsmith> never mind
10:55:14 <assl0r> @hoogle ($)
10:55:15 <lambdabot> Did you mean: ($)
10:55:15 <lambdabot> Prelude.undefined :: a
10:55:15 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:55:36 <dmwit> ?hoogle $
10:55:37 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
10:55:37 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
10:55:37 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
10:55:40 <dmwit> odd
10:58:10 <cdsmith> > (const 2) $ undefined
10:58:12 <lambdabot>  2
10:58:18 <cdsmith> > (const 2) $! undefined
10:58:20 <lambdabot>  Undefined
10:58:27 <cdsmith> assl0r: there's a good answer
10:59:00 <flux> darn, perl doesn't do tail call optimization
10:59:10 <MyCatVerbs> flux: ...
10:59:15 <flux> serves me right using it to do mail preprocessing in perl :(
10:59:26 <flux> hm, s/in perl //
10:59:31 <MyCatVerbs> flux: you win, okay? You just win.
11:00:42 <dmwit> I'm lost.
11:01:17 <dmwit> ...and you should consider that a crisis.
11:01:48 <jmelesky> dmwit: you're in #haskell. go north, take a soft left, and you'll end up in #ocaml. to the southeast, you'll find #erlang in a dense forest...
11:01:58 <dmwit> heh
11:02:01 <dmwit> exits
11:02:06 <dmwit> inventory
11:02:07 <dmwit> etc.
11:02:37 <jmelesky> inventory: 1 y-combinator (that's all. you don't need anything else.)
11:03:02 <dmwit> take lantern
11:03:04 <Apocalisp> Except... no tea.
11:03:30 <dmhouse> jmelesky: or indeed just the S and K combinators, as you can't do much with Y on its own :P
11:03:56 <jmelesky> dmhouse: i think those are quest items
11:04:56 <dmwit> let I = SKK -- I'm adding power to my inventory!
11:05:27 <Apocalisp> You have: a Maybe Monad, a bifunctor, a splitting headache, and no tea.
11:05:32 * jmelesky writes a spell component combinator library
11:05:39 <Botje> dmwit: no, your inventory is just as powerful as before >:)
11:06:22 <cdsmith> less.  If he used up his S and K combinators to build an I, it wasn't a smart move.
11:06:50 <mdmkolbe|work> examine S
11:07:03 <Apocalisp> it looks like any other S
11:07:25 <dmwit> I have an bag of holding, and inside are a countably infinite number of S and K combinators.  Nyah nyah!
11:08:00 * dmhouse steals an S from dmwit
11:08:19 <dmwit> :S
11:08:28 <dmhouse> You've got them to spare, after all.
11:08:28 <mdmkolbe|work> just don't let the Linear type wizard get a hold of your S and you'll be ok
11:09:04 <dmwit> My Preciou S!  It's mine!
11:09:26 * dmhouse constructs a lambda calculus
11:09:53 <mdmkolbe|work> use Y on Y
11:10:11 * dmwit rereads the scrollback and feels slightly dirty
11:10:27 <dmhouse> go north
11:10:35 <dmhouse> NO! That violates referential transparency.
11:10:52 <cdsmith> Jeez, now I'm imagining inventing games to teach combinatorial logic.
11:10:54 <dmhouse> let pos' = north pos in playRestOfGame
11:10:55 <dmwit> Obviously, the game is played inside the IO monad.
11:11:48 <Botje> pfft. use a zipper
11:11:49 <mdmkolbe|work> in the distance you see the TOP of a mountain, you also see an occiean, but you can't see it's BOTTOM
11:12:04 <Botje> mdmkolbe|work: great, crash the game, why don't you :)
11:12:38 <mux> The lambda hits! The lambda hits!  You die..--More--
11:12:44 <ptolomy> Do you suppose that modifyIORef is faster than readIORef + unsafeWRite?
11:13:05 <dmhouse> ptolomy: I imagine the first is implemented in terms of the second and third.
11:13:21 <ptolomy> It is.
11:13:29 <ptolomy> I checked. I asked too soon. Sorry. :-P
11:13:29 <mux> The Church hound breathes confusion for 853 damage.
11:13:30 <mdmkolbe|work> tail (Message)
11:13:52 <dmwit> s/853/Succ Succ Succ Succ .../
11:14:14 <olsner> @remember <mux> The lambda hits! The lambda hits!  You die..--More--
11:14:15 <lambdabot> Done.
11:14:29 <dmwit> ?quote mux
11:14:30 <lambdabot> mux says: "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
11:14:39 <dmwit> ?quote <mux>
11:14:39 <lambdabot> <mux> says: The lambda hits! The lambda hits!  You die..--More--
11:14:48 <mux> heh
11:14:54 <dmwit> ?quote <
11:14:55 <lambdabot> < says: olsner> last night I dreamt I was stuck in a monad
11:15:40 <olsner> the haskell nerd humour is so much better than other programming languages'
11:15:44 <mdmkolbe|work> remember to save a continuation next time in case we die
11:16:11 <dmwit> ?quote lambda
11:16:12 <lambdabot> diffbavis says: [diffbavis] > (sum.map ord) "al gore"   [lambdabot] 666
11:16:22 <cdsmith> huh?
11:16:25 <dmwit> lambdabot
11:16:39 <dmhouse> > sum (map ord "al gore")
11:16:41 <lambdabot>  666
11:16:47 <cdsmith> oh!
11:16:51 <Apocalisp> bwahaha
11:17:07 <monochrom> @remember mdmkolbe remember to save a continuation next time in case we die
11:17:07 <lambdabot> Done.
11:17:19 <Apocalisp> @unpl sum (map ord "al gore")
11:17:20 <lambdabot> sum (map ord "al gore")
11:17:24 <Apocalisp> @pl sum (map ord "al gore")
11:17:25 <lambdabot> sum (map ord "al gore")
11:17:28 <Apocalisp> bah
11:17:36 <dmhouse> Apocalisp: it's already points-free.
11:17:40 <Apocalisp> yea
11:17:45 <dmhouse> ?pl \x -> sum (map ord x)
11:17:45 <lambdabot> sum . map ord
11:17:45 <dmwit> sum . map ord
11:17:56 <dmwit> Winner!
11:18:29 * dmhouse gives a pointsfree gold star to dmwit
11:18:54 <dmwit> lambdabot needs a "predict the next command" plugin. =P
11:19:37 <monochrom> pointfree star = circle?
11:19:37 <Apocalisp> @src ord
11:19:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:19:55 <dmhouse> dmwit: I think it could be done with Cont.
11:20:05 <DRMacIver> Hm. So, are there any modules for dealing with partial orders in Haskell?
11:20:09 * DRMacIver hasn't been able to find any
11:20:16 <monochrom> No.
11:20:29 <mdmkolbe|work> would fgl have them?
11:20:35 <dmhouse> DRMacIver: throw one together, Cabalise and stick it on Hackage!
11:20:50 <chitin> > let nums = map (\(x, y) -> toInteger x, toInteger y) $ filter (\(x, y) -> x < y && isNotTrivial x y) [ (a , b) | a <- [11..99], b <- [11..99] ] in nums
11:20:51 <lambdabot>   Not in scope: `isNotTrivial'
11:21:01 <olsner> [me] > 1 + 4 [lambdabot] I knew you were going to ask that! It's 5.
11:21:03 <chitin> oops
11:25:15 <assl0r> > [ t | t <- [1..b], not (( b `mod` t) /= 0), not (t==1 || t==b) ]
11:25:17 <lambdabot>   Not in scope: `b'
11:25:25 <assl0r> > 12 [ t | t <- [1..b], not (( b `mod` t) /= 0), not (t==1 || t==b) ]
11:25:26 <lambdabot>   Not in scope: `b'
11:25:49 <mdmkolbe|work> > let b = 12 in [ t | t <- [1..b], not (( b `mod` t) /= 0), not (t==1 || t==b) ]
11:25:51 <lambdabot>  [2,3,4,6]
11:26:40 <mdmkolbe|work> > let b = 12 in [ t | t <- [1..b], (( b `mod` t) == 0), not (t==1 || t==b) ]
11:26:42 <lambdabot>  [2,3,4,6]
11:27:20 <mdmkolbe|work> > let b = 12 in [ t | t <- [1..b], (b `mod` t) == 0, t/=1, t/=b) ]
11:27:21 <lambdabot>  Parse error
11:27:36 <mdmkolbe|work> > let b = 12 in [ t | t <- [1..b], (b `mod` t) == 0, t/=1, t/=b ]
11:27:38 <lambdabot>  [2,3,4,6]
11:27:55 <DRMacIver> dmhouse: I might well do. I'm not sure I have that much need for it though.
11:28:00 <dmhouse> mdmkolbe|work: perhaps you and lambdabot should get a room
11:28:25 <mdmkolbe|work> dmhouse: we do, that was for assl0r's benifit
11:31:31 <chitin> ?bot
11:31:32 <lambdabot> :)
11:31:53 * assl0r doesn't like haskell unlike operator :)
11:32:03 * assl0r is used to !=
11:32:22 <psnl> (!=) = (/=)
11:32:34 <olsner> then get unused :P
11:32:54 <dmhouse> assl0r: (/=) is meant to indicate a = with a slash through it, like in real mathematics.
11:33:15 <mdmkolbe|work> (/<) = (>=)
11:33:17 <bos> real mathematicians use .NE.
11:33:37 <assl0r> .NE.?
11:33:44 <mdmkolbe|work> assl0r: fortran
11:33:44 <dmhouse> Fortran?
11:35:55 <olsner> fortran, where a single space can make the difference between a variable declaration and a do-loop
11:36:14 <assl0r> lol
11:37:34 * mdmkolbe|work just used "'" for the first time in a variable name but not at the end (let don't_compute = ... in ...)
11:37:52 <monochrom> haha that's slick
11:38:16 <mlh> s/l//
11:40:40 <monochrom> haha you're sick
11:40:41 <emu> how many ' have you used at the end of a variable name
11:40:52 <monochrom> two
11:41:36 <DRMacIver> I'd forgotten that Haskell allowed you to do that actually.
11:41:46 <DRMacIver> Any other unexpected characters you can use in identifiers?
11:41:52 <emu> #
11:41:57 <mdmkolbe|work> emu: I think I once top out at around 3 or 4, after that I used numbers.  (It was development code when I was rewriting an implementation and didn't want to throw away the old version just yet)
11:42:35 <emu> i think i used 3 when i was being particularly evil one time
11:43:46 <sjanssen> emu: # is an operator, according to Haskell '98
11:44:00 <emu> hmm
11:44:08 <mdmkolbe|work> > :t (#)
11:44:09 <lambdabot>  Parse error
11:44:12 <mdmkolbe|work> :t (#)
11:44:15 <lambdabot> parse error on input `)'
11:44:29 <monochrom> let 3 # 4 = True in 3 # 4
11:44:36 <monochrom> > let 3 # 4 = True in 3 # 4
11:44:38 <lambdabot>  True
11:44:43 <sjanssen> @undo x # y -- this is a proof
11:44:44 <lambdabot> x # y
11:45:01 <sjanssen> @undo x#
11:45:01 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
11:45:11 <mux> @check \(x :: Int) -> id x == x
11:45:12 <lambdabot>  Parse error in pattern
11:45:30 <mux> grr
11:45:38 <ptolomy> Anyone know where I can find some basic literature on decompiling machine code?
11:45:40 <mux> @check \x -> id x == x
11:45:41 <lambdabot>  Add a type signature
11:45:47 <mux> @check \x -> id x == x :: Int
11:45:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
11:45:54 <mux> @check \x -> id x == x :: Bool
11:45:55 <lambdabot>  Add a type signature
11:46:00 <sjanssen> @check \x -> id x == (x :: Int)
11:46:01 <lambdabot>  OK, passed 500 tests.
11:46:13 <mux> ah, thanks
11:46:18 <mux> I hate qc sometimes :D
11:46:57 <monochrom> Yeah, it needs defaulting.
11:47:18 <monochrom> Like if the inferred type is "a->a" then it should default to "()->()".
11:48:56 <sjanssen> that can give you false security in your tests
11:49:18 <monochrom> I'm being sarcastic.
11:49:22 <sjanssen> a property that takes only () is practically guaranteed to succeed
11:49:51 <olsner> "I have tested nothing and found no errors."
11:52:45 <mdmkolbe|work> every program can be reduced by one instruction.  every program has at least one more bug to be fixed.  by induction, every program can be reduced to a single instruction that is wrong
11:55:01 <monochrom> nice induction
12:02:45 <matthew-_> data Mu f = In (f (Mu f))
12:02:57 <matthew-_> how can I use that to represent an infinite structure?
12:05:47 <Saizan> it's like a list with no []
12:06:06 <Saizan> mmh, no
12:07:11 <matthew-_> it's from the Mark Jones papre
12:07:34 <matthew-_> and he uses it to construct catamorphisms and anamorphisms
12:07:42 <matthew-_> it's a fixed point constructor, sorta
12:07:56 <Saizan> In (1,In (2,In (3, .... ))) ?
12:08:06 <swiert>  matthew-_: Try Mu (Either () (Pair Int)
12:08:18 <swiert> wait, that won't work.
12:08:40 <matthew-_> he does data NatF s = Zero | Succ s and then type Nat = Mu NatF
12:08:41 <swiert> data ListF x = NilF | ConsF Int x
12:08:46 <matthew-_> yes
12:09:06 <matthew-_> but that requires an infinite type
12:09:36 <monochrom> Mu NatF = In (NatF (Mu NatF))
12:09:59 <swiert> What do you mean by "infinite type"?
12:10:09 <matthew-_> yeah - sorry, I was meaning if you construct an infinite list, it'll have an infinite type
12:10:24 <chitin> how do I divide doubles?
12:10:37 <swiert> Nope. It will still have type Mu ListF.
12:10:43 <swiert> Let me look...
12:10:47 <sjanssen> > 1.0 / 2.0 :: Double
12:10:48 <monochrom> Zero :: Mu NatF.  This is one possible value.
12:10:49 <lambdabot>  0.5
12:10:51 <matthew-_> cons 5 $ cons 3 $ cons 78 $ nil :: (Num t) => Mu (ListF t)
12:11:00 <matthew-_> swiert, you're right, I'm dumb.
12:11:04 <swiert> Here's the paper that explained it to me: http://www.cs.nott.ac.uk/~gmh/when.pdf
12:11:14 <swiert> It's pretty tricky stuff.
12:11:59 <matthew-_> it really does my head in. Plus I'm messing with all sorts of phantom types and gadts and stuff
12:12:22 <matthew-_> I've been banging my head against a wall all day and come up with approx zero lines of code that I'll actually keep
12:12:23 <chitin> > let foo a b = [ x / y :: Double | x <- (map digitToInt . show) a, y <-  (map digitToInt . show) b] in foo 23 41
12:12:24 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
12:12:42 <matthew-_> > 23/2.0
12:12:43 <lambdabot>  11.5
12:13:10 <sjanssen> chitin: you're forcing x and y to be Int by using digitToInt
12:13:27 <ejt> (fromIntegral x) / (fromIntegral y)
12:13:35 <swiert> matthew-_: I'm not sure you can do GADT-like stuff with Mu, btw.
12:13:45 <monochrom> Succ Zero :: NatF (Mu NatF).  This is another possible value.  But we hate its NatF(Mu NatF) type.  In (Succ Zero) :: Mu NatF  now this has type Mu NatF again.
12:14:28 <monochrom> In general, Zero, In (Succ Zero), In (Succ (In (Succ Zero))), ... :: Mu NatF
12:14:42 <chitin> sjanssen: is there a way around that or should I just create my own digitTo(Double)?
12:15:06 <matthew-_> monochrom: yeah: he has nil = In Nil (nil :: Mu ListF t) and then cons x xs = In (Cons x xs) (cons :: t -> Mu (ListF t) -> Mu (ListF t))
12:15:24 <matthew-_> with data ListF t a = Nil | Cons t a
12:15:29 <matthew-_> and type List t = Mu (ListF t)
12:15:49 <swiert> matthew-_: which paper are you reading?
12:16:16 <matthew-_> Mark Jones : "Functional Programming with Overloading and Higher-Order Polymorphism"
12:16:28 <monochrom> In Haskell 98 you can use instead: newtype Mu f = In (f (Mu f)).  More efficient and reflects the original intention of type isomorphism between Mu f and f (Mu f).
12:17:06 <araujo> hello!
12:17:30 <matthew-_> monochrom: yup. My problem is that I need to combine it with a fixed point combinator
12:17:55 <sjanssen> chitin: use fromIntegral
12:18:08 <matthew-_> ahh, I just want the anamorphism rather than the catamorphism
12:18:22 <sjanssen> > fromIntegral (digitToInt '1') / fromIntegral (digitToInt '2')
12:18:24 <lambdabot>  0.5
12:18:33 <drigz> what would be the fastest way to calculate length . nub?
12:18:41 <chitin> thanks sjanssen
12:18:49 <drigz> the best i've found so far is a modified qsort that returns the length
12:18:50 <mauke> depends on the data
12:18:53 <sjanssen> drigz: Data.Set.size . Data.Set.fromList
12:19:01 <mauke> can you assume Ord?
12:19:11 <drigz> mauke: yes
12:19:17 <drigz> Rationals, if that helps
12:19:49 <mauke> hmm, the perl answer would be: don't use a list; make it a set instead
12:19:51 <sjanssen> drigz: the Set version is O(n log m), where n is the size of your input, and m is the resulting size
12:20:01 <monochrom> Suppose a programming language provides Mu as builtin, but disallows recursion in user-defined data types, e.g., "data F s = Z | S s" is allowed, "data N = Z | S N" disallowed, in general "data X = ... X ..." disallowed.  Then you can still use Mu to bring back recursive type.
12:20:27 <drigz> sjanssen: thanks, i'm trying it
12:20:39 <drigz> sjanssen: i love the way with haskell the best way is often the cleanest
12:20:47 <monochrom> Similarly, suppose a programming language provides fix as builtin, but disallows recursion in user-defined functions. Then you can still use fix to bring back recursive functions.
12:21:17 <matthew-_> monochrom: yeah, that's just it - I'm ok with using fix in functions. It's the data m'larky that's knocked me for 6
12:22:29 <monochrom> For practical purposes you want the language to allow user-defined recursions.  For theoretical purposes you want the language to disallow user-defined recursions but provide fix and Mu, then all theorems about recursions can be proved by just studying fix and Mu, you don't have to look at the rest of the language, shorter proof.
12:22:30 <Saizan> monochrom: Zero :: Natf s, In Zero :: Mu Natf, as well as In (Succ (In Zero)) works and In (Succ Zero) doesn't typecheck
12:22:46 <monochrom> Oh, thanks.
12:24:30 <matthew-_> monochrom: any good papers on working with Mu that you know?
12:24:40 <monochrom> No.
12:24:45 <matthew-_> groovy ;)
12:25:02 <monochrom> I recommend practice instead.  Use Mu for five days.
12:25:25 <drigz> will fromIntegral (x :: Integer) be as fast as fromInteger x?
12:25:55 <monochrom> Also this translation.  "data X = ... X ..."  => "data XF s = ... s ... ; type X = Mu XF".  It's the same translation from recursive functions to fix.
12:27:53 <matthew-_> ok. so here's the punchline. Given the above definition for List, I need the Nil to carry a different type than the Cons
12:28:30 <shapr> Cheery: I can't find pesco's opengl toy on the net.
12:28:40 <matthew-_> I guess your translation will work just fine
12:28:57 <Cheery> shapr: what was interesting in it?
12:31:01 <monochrom> I suspect Mu is introduced so that you can write down one version of cata and it works for all recursive data types defined via Mu.  Recall that in Haskell 98 you can't do that to user recursions.
12:31:24 <shapr> Cheery: It used yampa and opengl to make a screensaver-y thing, and took keyboard and mouse input to modify what was displayed.
12:31:31 <shapr> All in less than fifty lines.
12:31:36 <monochrom> Then you can prove a million theorems about cata because there is only one version of it.
12:32:20 <monochrom> Then you claim they apply to user-defined recursions because there is a translation.
12:32:20 <dmhouse> Does Jun Mukai IRC?
12:32:21 <Cheery> shapr: oh cool
12:32:40 <Cheery> I guess I can reach same then
12:32:56 <monochrom> It's a proof technique rather than an engineering technique.
12:33:02 <matthew-_> monochrom: yeah, that's pretty much what Meijer et al say in "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
12:41:13 <swiert> Can someone recommend a small example of a package using the FFI?
12:43:49 <monochrom> lazy bytestring
12:44:22 <bd_> you mean strict bytestring? :)
12:44:30 <bd_> IIRC lazy's just built on top of strict
12:44:59 <monochrom> OH! Yeah, stict bytestring.
12:45:33 <bos> bytestrings don't use much of the FFI, though. just calls to memcmp, more or less.
12:45:55 <dmwit> whoa
12:46:02 <dmwit> flip const = const id
12:46:05 <swiert> I've just browsed Hackage, seems like there's enough there.
12:46:42 <monochrom> Network.Socket
12:47:18 <monochrom> Network.BSD may be less overwhelming than Network.Socket
12:47:36 <drigz> dmwit: i thought of that today too! i was trying to understand lambda calculus
12:47:46 <drigz> where true = const, false = const id
12:47:54 <dmwit> right
12:48:08 <dmwit> Ah, neat, that's a good way to look at it.
12:48:41 <dmwit> <3 math
12:49:21 <matthew-_> mmm. there needs to be a 2 char symbol for "hates"
12:49:34 <emu> </3
12:50:01 <drigz> used to love but then found in bed with another guy
12:51:05 * dmhouse submits patches to HaskellNet.
12:52:22 <DRMacIver> Hm.
12:52:28 <dmwit> > (const . const id) 1 2 3 -- Is there a way to do this without parentheses? ($) isn't quite right.
12:52:30 <lambdabot>  3
12:53:13 <DRMacIver> It's moderately annoying not being able to declare a type as an instance of a type class in multiple ways.
12:53:33 <emu> sounds like ambiguity
12:53:35 <Cheery> ugh, HList is a quite beast
12:53:38 <DRMacIver> (Although I suspect it would be moderately annoying being able to do so as well)
12:53:41 <dmwit> How would the compiler know which one to use?
12:53:46 <dmwit> Use a newtype instead.
12:53:53 <emu> > const . const id 1 2 $ 3
12:53:54 <lambdabot>   add an instance declaration for (Num (a -> b))
12:54:01 <dmwit> That way both the compiler and the reader of the code know what should happen.
12:54:32 <DRMacIver> dmwit: Something along the lines of the "Modular Type Classes" suggestion I imagine, with local imports.
12:54:34 <emu> > const . const id $ 1 2  3
12:54:35 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
12:54:44 <monochrom> I prefer this. instance declarations are put into little modulettes. if you don't want one you can avoid importing it.
12:54:50 <dmwit> emu: It's trying to use 1 as a function there.
12:54:59 <dmwit> =(
12:55:00 <emu> :t (const . const id)
12:55:02 <lambdabot> forall b a a1. a1 -> b -> a -> a
12:55:33 <emu> > const . const id $ 1 $ 2 $ 3
12:55:34 <lambdabot>   add an instance declaration for (Num (a -> b))
12:55:54 <dmwit> > const . const id $ 1
12:55:55 <lambdabot>  Add a type signature
12:56:01 <emu> $ is rassoc right?
12:56:12 <dmwit> :i ($)
12:56:23 <dmwit> ?info ($)
12:56:24 <lambdabot> ($)
12:56:27 <dmwit> Yes. =(
12:57:41 <balodja> @unpl const id
12:57:41 <lambdabot> (\ _ b -> b)
12:57:51 <balodja> hm, that's interesting
12:58:14 <mauke> @unpl flip const
12:58:14 <lambdabot> (\ b c -> c)
12:58:32 <dmwit> Cale is right, ($) should be left-associative.
12:58:56 <dmwit> All the places where we would want right-associativity could be handled by (.) instead.
12:59:38 <emu> revolt!
12:59:51 <emu> hmm can you infixl $
13:01:04 <dmwit> test.hs:3:9: Not in scope: `$'
13:01:12 <dmwit> So, no, you can't fix it manually. =(
13:01:16 <emu> ($)?
13:01:38 <emu> i never use the infix declarations
13:01:48 <dmwit> No, you leave off the brackets.
13:02:03 <dmwit> They're understood for infix declarations. ;-)
13:02:47 <emu> i saw: infix `foo`  recently i think
13:03:01 <dmwit> It gives me a parse error if I try it.
13:06:00 <chessguy> hi haskellers
13:06:09 <araujo> hi hi chessguy
13:06:17 <chessguy> araujo!
13:06:23 <chessguy> que hay?
13:06:25 <araujo> :-)
13:06:45 <araujo> chessguy, no mucho, preparandome para la univ :-)
13:08:53 <Heffalump> dmwit: what gives you a parse error?
13:09:01 <dmwit> infixl 0 ($)
13:09:12 <wy> Heffalump: I caught you!
13:09:18 <dmwit> infixl 0 $ -- not a parse error, but it claims $ is not in scope
13:09:33 <Heffalump> wy: hi :-)
13:09:47 <Heffalump> dmwit: ah, right. You have to declare it in the same place you declare the operator, IIRC
13:10:08 <mauke> import Prelude hiding (($))
13:10:10 <dmwit> I'd rather not import Prelude qualified... =P
13:10:16 <mauke> ($) = (Prelude.$)
13:10:17 <dmwit> mauke: Ah, that's better.
13:10:22 <wy> Heffalump: Let's continue the discussion about polyglot and macro systems
13:10:22 <Heffalump> it causes really weird profiling results, too :-)
13:10:25 <Heffalump> wy: sure.
13:10:27 <mauke> or ($) = id -- shorter
13:10:33 <Heffalump> IIRC you asked me how it compared to one.
13:11:16 <wy> Heffalump: I guess polyglot is semantic level thing, and macros are syntactic level. Is that the only difference?
13:11:46 <Heffalump> wy: I'd say it's more that polyglot works on parse trees rather than text.
13:11:51 <Heffalump> But it also makes annotating them quite easy.
13:11:56 * joelr1 is haskelling to czech rockers on eurovision
13:12:34 <wy> Heffalump: So do you manipulate the Java classes of the trees?
13:13:31 <Heffalump> wy: yes.
13:13:47 <Heffalump> you basically define a bunch of tree walks
13:17:04 <fourbissime> hi there.
13:17:30 <dmwit> heyo!
13:18:13 <wy> Heffalump: Do you need to generate the final program yourself?
13:18:51 <fourbissime> little newbie question : what is wrong with this ? http://hpaste.org/1787
13:19:41 <Heffalump> wy: no, you just leave the syntax tree there and Polyglot handles it. I think.
13:19:47 <Heffalump> I didn't do all that much of that end of the compiler.
13:19:48 <sjanssen> fourbissime: looks okay to me
13:19:58 <dmwit> fourbissime: What's the error?
13:20:17 <fourbissime> Kind error: `Coords' is applied to too many type arguments
13:20:17 <fourbissime>     In the class declaration for `Map'
13:20:38 <dmwit> Is Coords a class or type?
13:20:59 <fourbissime> oh shit. it's a type.
13:21:11 <fourbissime> > type Coords = [Int]
13:21:13 <lambdabot>  Parse error
13:21:15 <dmwit> Probably Unit, to, eh?
13:21:37 <fourbissime> not Unit, no. i've just tried removing "Coords c" and it works.
13:21:49 <wy> Heffalump: Actually I'm considering join Andrew's group, but I don't know how far this thing can go. I'm afraid Java will be deprecated one day and all our work is in vain.
13:21:49 <dmwit> fourbissime: You probably don't want to just remove it.
13:21:51 <fourbissime> silly me
13:21:59 <dmwit> Try, like, m -> Coords -> u, for example.
13:21:59 <fourbissime> now I know what to do
13:22:04 <fourbissime> that's right.
13:22:21 <dmwit> Cool!  What are you working on?
13:22:24 <Heffalump> in research terms, the benefit is surely the general research into techniques for writing extensible compilers, not Java per se.
13:23:10 <Heffalump> but I'm not really convinced Polyglot has the right basic design, and I think the abc team (which I'm not really part of any more) is trying to move to an alternative based on attribute grammars.
13:23:28 <fourbissime> that's it. thanks for the help ! I still have to anchor in my mind this nifty concept of separating classes and types
13:23:38 <DRMacIver> Hm
13:24:05 * DRMacIver finds what he was saying the other day about being able to answer Haskell questions much better than he can write Haskell suddenly vindicated. :)
13:24:34 <Heffalump> DRMacIver: that should be good for bamboozling people at job interviews
13:24:59 <DRMacIver> Heffalump: Or it would be if the context I said it in hadn't been the phone interview with Howard. ;)
13:25:08 <Heffalump> :-)
13:26:03 <DRMacIver> (The problem is that I've spent far more time trying to understand the theory than I have actually writing code)
13:26:21 <Cheery> DRMacIver: that's not a problem
13:26:22 <zetta> (DRMacIver: you are not alone)
13:26:24 <Cheery> that's good practise!
13:26:41 <Cheery> theory is never a problem, it's always good practise
13:26:46 <Heffalump> practical experience is worth more than you'd initially think, though.
13:26:48 <DRMacIver> Cheery: No, spending lots of time trying to understand the theory is good. Not spending enough time writing code is. :)
13:26:55 <DRMacIver> err. isn't.
13:27:07 <greenrd> I am trying to use listify from Data.Generics to extract a list of strings matching a predicate
13:27:10 <Heffalump> You can just work that much quicker.
13:27:12 <DRMacIver> (I mean, I've written *some*. Juust not nearly enough)
13:27:17 <Cheery> well, I think I wouldn't be able to write code I'd like without doing much research
13:27:20 <greenrd> from a data structure
13:27:21 <Heffalump> but equally, you can acquire that kind of experience quite fast
13:27:22 <Cheery> and damn, my code rocks
13:27:50 <greenrd> of course, listify predicate doesn't work
13:28:02 <Cheery> Monads should be called Paradises
13:28:05 <greenrd> because listify recurses into the strings themselves
13:28:39 <drigz> is there a better way of doing length [() | ...]
13:28:55 <monochrom> @remember Cheery Monads should be called Paradises
13:28:56 <lambdabot> Done.
13:29:08 <drigz> interestingly, my code is almost twice as fast with length [(n % d) :: Ratio Int | ...] instead of the ()
13:29:12 <wy> Heffalump: Do you think designing an extensible compiler for languages like Haskell would be nicer? harder?
13:29:49 <greenrd> so it also looks at all the tails of each string
13:29:53 <Heffalump> extending the type system in a modular way is probably harder, because type checking is already bidirectional
13:30:05 <greenrd> whereas I just want it to look at the full strings, obviously
13:30:23 <dmhouse> Heffalump: what do you mean by 'bidirectional'?
13:30:32 <Heffalump> apart from that I doubt it's much different, except that writing a Haskell compiler is harder than writing a Java compiler
13:30:36 <wy> inference?
13:30:49 <Heffalump> dmhouse: takes into account information from the context ("upwards") and the expression ("downwards")
13:30:50 <fourbissime> okay now inverse problem. http://hpaste.org/1788 "a" should be instanciating the class Link. where do I declare that ?
13:31:16 <dmhouse> Heffalump: oh, surely nearly every type system ever is like that?
13:31:18 <wy> Heffalump: Do you mean type inference is bidirectional?
13:31:53 <dmhouse> fourbissime: put "Link a =>" before the constructor name
13:32:01 <fourbissime> ok thanks
13:32:03 <greenrd> can't use everywhereBut because that's for transformations, not for queries
13:32:21 <andygill> Can anyone recommend a specific XML library (for Haskell)? is there anything lighter weight that hxt or Haxml?
13:32:29 <Heffalump> wy: maybe. Though I think type checking generally involves a lot of inference, unless the user annotated absolutely everything.
13:32:45 <monochrom> I still swear by hxt.
13:33:24 <DRMacIver> I swear by Jove.
13:33:33 <andygill> Say more monochrom .. what do you like about it
13:33:58 <monochrom> It is more abstract.
13:34:15 <greenrd> any hints on my SYB problem?
13:34:52 <Heffalump> dmhouse: I wouldn't say that Java/C/C++ are like that.
13:35:03 <andygill> I'm just looking for a simple XMLRC, and I've hand coded the XML generation (for now), but do not want to write YA XML parser
13:35:09 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/1788#a1
13:35:39 <andygill> I look at the XMLRPC library, but there is a lot of heaving lifting for what is quite simple job
13:35:42 <monochrom> RC = ?
13:36:11 <fourbissime> dmhouse: sorry, it doesn't seem to work ... http://hpaste.org/1788#a1 --> gives me "Not in scope: type variable `a'"
13:36:14 <andygill> Hu? Whats RC
13:36:27 <monochrom> You wrote "XMLRC".
13:36:46 <andygill> XMLRPC, sorry. typo
13:37:09 <dmhouse> fourbissime: is the type of each item in the list the same, or can they be different (subject to some constraint, like instantiating Link)?
13:37:22 <monochrom> I have not studied XMLRPC.
13:37:44 <wy> Heffalump: I really doubt working on those Java related projects can lead me to the goal. Research should do the greatest thing possible, no matter how difficult it is.
13:38:14 <fourbissime> dmhouse: I didn't think of that, but let's say the only constraint is that everything in the list should implement the Link class
13:39:11 <andygill> What have you used hxt for?
13:39:46 <Heffalump> wy: in the end, yes, but you have to choose a realistic path to get there
13:40:09 <dmhouse> fourbissime: then you have to use a funky type system extension known as existentials. See http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types for more information, but if it's possible to make each item have the same type, that'd make things easier.
13:40:12 <lambdabot> http://tinyurl.com/f9umb
13:40:22 <monochrom> parsing xml and html, extract stuff from table.
13:40:55 <fourbissime> dmhouse: brrrr scary ... so let's say everything can have the same type ?
13:41:26 <dmwit> fourbissime: You could also make an intermediate type
13:41:32 <dmhouse> fourbissime: then the SimpleUnit type needs to be parametrised over the type of the list. I'll annotate the paste, hold on.
13:41:45 <DRMacIver> It's amazing how useful a tool for thinking the shower is. :)
13:41:47 <hpaste>  dmhouse annotated "(no title)" with "(no title)" at http://hpaste.org/1788#a2
13:41:52 <dmwit> data Linkable = Foo Bar | Baz Quux -- Bar and Quux implement Link
13:42:03 <andygill> Ok monochrom, i'll have another look at it. thx for the heads up
13:42:06 * DRMacIver went to have a shower and the solution to his problem occurred to him whilst there
13:43:48 <Heffalump> trains without 'net connections are quite good, too
13:43:58 <Heffalump> but yes, for pure thinking showers are great
13:44:15 <DRMacIver> (Although another issue with my approach occurred to me. Dammit.)
13:44:55 <DRMacIver> I don't find trains that great for thinking. Too many people.
13:45:11 <greenrd> I could use synthesize, and hopefully laziness would make it optimal
13:45:12 <DRMacIver> (A feature which my shower sadly lacks)
13:45:29 <dmhouse> It'd get cramped pretty quickly.
13:45:35 <DRMacIver> True
13:45:38 * monochrom gets into DRMacIver's shower
13:45:59 * DRMacIver turns off the hot water
13:46:16 * monochrom turns off the cold water
13:46:24 <DRMacIver> Curses. Foiled!
13:46:24 <dmwit> I like where this thread is going!
13:46:36 <DRMacIver> I don't. :)
13:47:43 <njbartlett> The problem is keeping the answer in your head long enough to get it into persistent storage after the shower.
13:48:02 * DRMacIver is pretty good at that.
13:48:31 <DRMacIver> My head is stuffed so full of pointless random nonsense that a few more things won't make a difference. :)
13:48:56 <Cheery> why Num -class requires Eq?
13:49:09 <dmhouse> I think it's more general than the shower. Any time you're forced to think of something else for a while your subconscious keeps churning away and often comes up trumps.
13:49:35 <monochrom> Cheery: no reason
13:49:40 <balodja> what is the difference between seq and const?
13:49:52 <balodja> > seq undefined 1
13:49:53 <Cheery> I have data structure: data Reactive e a = R a (Time -> e -> Reactive e a) ... how should I implement Eq for it?
13:49:55 <mauke> seq evaluates its first argument
13:49:57 <lambdabot>  Undefined
13:50:02 <balodja> > const undefined 1
13:50:03 <lambdabot>  Undefined
13:50:05 <dmhouse> Cheery: so you can use literals in patterns. E.g. f 0 = "zero"; f _ = "nonzero" would have type (Eq t, Num t) => t -> String if Eq didn't superclass Num.
13:50:09 <mauke> also, order of arguments
13:50:10 <balodja> mauke: const too
13:50:13 <pitecus> is there somehting like /dev/null on windows?
13:50:29 <DRMacIver> dmhouse: I suspect you're right.
13:50:29 <dmhouse> balodja: not in the same sense.
13:50:30 <mauke> balodja: no, const just returns its first argument
13:50:38 <mauke> seq a b returns b
13:50:51 <balodja> mauke: sorry :)
13:50:58 <Cheery> dmhouse: oh, I understand
13:51:02 <balodja> that's ok now
13:51:09 <balodja> > const 1 undefined -- :)
13:51:10 <lambdabot>  1
13:51:20 <dmhouse> DRMacIver: it happened to me earlier. I couldn't figure out how to fix my algorithm right now and I was needed somewhere else so I logged off and walked out the room and immediately realised the bug. Somewhat annoying. :)
13:51:28 <Cheery>   (R a _) == (R b _) = (a == b)
13:51:35 <Cheery> this is correct way to do it then?
13:51:37 <monochrom> > let x = x+1 in seq x 0
13:51:39 <lambdabot>  Exception: <<loop>>
13:51:54 <Cheery> since main stuff I've define affects inside in the first hand
13:51:59 <Cheery> *defined
13:52:14 <mauke> > let x = 1 `div` 0 in seq x 0
13:52:16 <lambdabot>  Exception: divide by zero
13:52:20 <Cheery> ie. constant 1 + constant 2 == constant (1+2)
13:52:23 <dmhouse> balodja: you might want to read http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form. seq forces its first argument to WHNF, whether its needed by the context or not.
13:52:25 <lambdabot> http://tinyurl.com/ykch9p
13:52:31 <DRMacIver> dmhouse: Yes, pacing is a very useful technique. :)
13:52:57 <monochrom> I go to a cafe and drink tea.
13:53:10 <dmwit> dmhouse: data doesn't have to be an instance of Eq to pattern match on it, though, does it?
13:53:18 <dmwit> So why are Num's special there?
13:53:33 <dmwit> > let x = x + 1 in const 1 x
13:53:35 <lambdabot>  1
13:53:36 <dmhouse> dmwit: literals do. How else would they match?
13:53:50 <monochrom> "f 0.01 = ..." you can't exactly say 0.01 is a constructor...
13:53:51 <dmwit> dmhouse: As constructors of the type?
13:53:54 <balodja> dmhouse: i have just confused arguments in const :)
13:54:00 <dmhouse> dmwit: think about the literals you can use. Strings, Bools, numbers... they're all instances of Eq.
13:54:14 <Cheery> thought, my Eq -thing feels ill-sensed
13:54:14 <dmhouse> dmwit: Int etc don't have constructors in the normal sense.
13:54:19 <Cheery> I can't actually use it anywhere. :(
13:54:36 <mauke> functions don't have constructors either and you still can't == them
13:55:00 <dmhouse> dmwit: 0 :: Num a => a really means fromInteger 0.
13:55:16 <dmwit> hum
13:55:34 <dmwit> But, you can't pattern match on arbitrary Eq instances, right?  Only on constructors...
13:55:35 <dmhouse> dmwit: i.e. there's no mapping from numeric literals to constructors of an arbitrary instance of Num.
13:55:44 <dmhouse> Hell, the type might even be abstract.
13:56:17 <dmwit> I mean, what if I did
13:56:19 <dmhouse> dmwit: no, true. Pattern matching on numeric literals expands as follows: f 0   ->   f x | x == 0
13:56:24 <sjanssen> isn't fromInteger a mapping from literals to constructors?
13:56:30 <dmwit> dmhouse: Ah.
13:56:38 <dmwit> So numeric literals are a special case in many ways.
13:56:38 <Cheery> oh well, I think I solved it, except that doing: constant a == constant b causes stack overflow
13:56:42 <mauke> no, fromInteger can go to arbitrary values
13:56:47 <Cheery> so it's a bit broken
13:56:55 <sjanssen> ah right, you're talking about patterns
13:57:16 <dmhouse> dmwit: yes.
13:57:37 <dmhouse> dmwit: the only literals I can think of that aren't constructors are numeric ones and strings. E.g. f 0, or g "hello".
13:57:43 <dmhouse> Oh, and Chars.
13:59:22 <dmhouse> dmwit: i.e., they're all special cases.
13:59:38 <sjanssen> arguably, 'c' is a constructor with a funny syntax
13:59:59 <sjanssen> and "c" desugars to ('c':[])
14:00:51 <drigz> sjanssen: do longer strings desugar?
14:01:05 <sjanssen> drigz: yeah, all of them do
14:01:09 <dmhouse> sjanssen: and Ints too, I guess.
14:01:48 <dmhouse> And even more arguably, Integers and Float/Doubles are just constructors, although there's a countably infinite number of them.
14:02:05 <sjanssen> Float and Double are finite
14:02:15 <dmhouse> Oh, okay.
14:02:20 <sjanssen> Integer has to have some special representation
14:02:31 <dmhouse> (Although there aren't a countably infinite number of real numbers, there are a countably infinite number of real literals.)
14:02:46 <dmhouse> > maxBound :: Float
14:02:51 <lambdabot>   add an instance declaration for (Bounded Float)
14:02:51 <lambdabot>     In the expression: maxB...
14:03:09 <Heffalump> dmhouse: what's the enumeration? Some kind of uber-diagonalisation?
14:03:37 <dmwit> ?instances Enum
14:03:38 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:03:42 <dmwit> !
14:03:45 <dmwit> > succ 1.7
14:03:47 <lambdabot>  2.7
14:03:53 <Heffalump> dmhouse: I had a moan about this the other day.
14:04:01 <dmhouse> Heffalump: for numeric literals? They have to be of finite length, so some kind of diagonalisation would work I imagine.
14:04:03 <Heffalump> > [1.0..5.0]
14:04:05 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
14:04:12 <Heffalump> dmhouse: it's so that works, too
14:04:12 <dmwit> Oh, that's why they made it Enum, huh?
14:04:19 <dmwit> > [True..False]
14:04:20 <lambdabot>  Parse error
14:04:27 <dmhouse> > [True .. False ]
14:04:27 <dmwit> > [False..True]
14:04:28 <lambdabot>  Parse error
14:04:29 <lambdabot>  []
14:04:34 <Heffalump> feels like a pretty rubbish justification to me. They should have just made a type class that actually represents what is meant.
14:04:43 <dmhouse> dmwit: True.. means the . function from the module True.
14:04:52 <dmwit> Bah.
14:04:59 <mauke> this isn't perl :-)
14:05:01 <Heffalump> bring on Unicode!
14:05:25 <dmhouse> We should use  for
14:05:28 <dmwit> > [LT..]
14:05:29 <lambdabot>  Parse error
14:05:30 <dmhouse> module selectors.
14:05:32 <dmwit> > [LT ..]
14:05:34 <lambdabot>  [LT,EQ,GT]
14:05:38 <dmwit> heh
14:05:42 <dmhouse> (Which is AltGr+. on Linux systems.)
14:05:53 <vincenz> > cycle succ LT
14:05:54 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> a1'
14:06:04 <vincenz> > iterate succ LT
14:06:05 <lambdabot>  Exception: Prelude.Enum.Ordering.succ: bad argument
14:06:08 <dmwit> Gr?
14:06:10 <vincenz> > succ LT
14:06:11 <lambdabot>  EQ
14:06:26 <dmhouse> dmwit: as in, AltGr, the key to the right of the spacebar. :)
14:06:40 <mauke> dmhouse: not function composition?
14:06:44 <dmwit> doesn't work here
14:06:56 <dmhouse> mauke: yeah, maybe, although that wouldn't solve the problem in hand.
14:07:35 <dmhouse> dmwit: aww. AltGr's very useful, you can get loads of random characters using it. :)
14:07:58 <dmwit> Awww, man, we *never* get to do what I want to do!
14:09:25 <dmhouse> dmwit: what system are you on?
14:09:33 <dmwit> Ubuntu Dapper right now.
14:10:21 <dmhouse> dmwit: oh, weird, I'd expect it to work then. Maybe it's something to do with your keyboard configuration. I have no idea, but it's worked on every single Linux system I've been on.
14:14:38 <nn-main> why is my lamdabot complaning that it can't find Monad.Writer insted of Control.Monad.Writer
14:15:21 <dmwit> Why not trying to just fix it?
14:15:32 <dmwit> SamB_at_friends: Uh-oh, computer trouble?
14:15:38 <dmhouse> nn-main: Monad.Writer hasn't existed in a while, use Control.Monad.Writer.
14:15:50 <SamB_at_friends> dmwit: nn-main is the friend ;-)
14:16:01 * sjanssen doubts that Monad.Writer ever existed
14:16:05 <dmwit> heh
14:16:20 <sjanssen> nn-main: when is it complaining?  During compilation?
14:16:29 <nn-main> during run
14:16:46 <sjanssen> in response to @run? (also known as > )
14:17:28 <SamB_at_friends> dmhouse: so why is lambdabot's @run command trying to import it?
14:18:31 <sjanssen> nn-main: there's a bug in @run's import list
14:18:49 <dmhouse> SamB_at_friends: oh, sorry, I read that as "I'm getting the error 'Can't find Monad.Writer', what do I do?". Misread.
14:18:50 <sjanssen> I'll send a patch to dons, but it won't appear in the main repo for a while
14:19:17 <sjanssen> edit scripts/RunPlugs.hs
14:20:38 <drigz> is there a reason hpaste has the type (a -> b) -> f a -> f b
14:21:01 <drigz> *?
14:21:15 <sjanssen> drigz: for aesthetic purposes, I imagine
14:21:37 <sjanssen> there isn't a non-bottom definition of that function, by the way
14:22:14 <drigz> i guess String -> URL would make most sense for an hpaste function
14:22:21 <drigz> IO URL even
14:22:26 <SamB_at_friends> @djinn (a -> b) > f a -> f b
14:22:27 <lambdabot> Cannot parse command
14:22:28 <dmhouse> drigz: perhaps the pastes are modelled as functions from the paster's brain to the reader's, and the functor is as it's over the internet. I.e. hpaste :: (PostersBrain -> ReadersBrain) -> (OverInternet PostersBrain -> OverInternet ReadersBrain)
14:22:47 <mux> @type fmap
14:22:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:22:52 <mauke> @djinn (a -> b) -> f a -> f b
14:22:53 <lambdabot> -- f cannot be realized.
14:23:05 <nn-main> Thanks! It works grate
14:23:21 <mux> the choice of 'f' makes one thinks hpaste means something about fmap, even though it misses Functor f =>
14:23:52 <drigz> it's not a valid type signature as it stands, is it?
14:24:13 <wy> What's general recursion? Is it recursion without reducing to a smaller structure?
14:24:13 <mux> it's valid, there is just no function that can implement it, besides bottom of course
14:25:46 <dmhouse> wy: yeah, I think so. It's recursion without the limitation that it's guaranteed to terminate (simple recursion).
14:26:32 <wy> dmhouse: Ah. So the idea of epigram is to anotate general recursion explicitly so that type checker won't go into loops.
14:32:41 <wy> dmhouse: How can I tell a recursion must terminate? Just look at if it's on a smaller part of a structure?
14:33:46 <dmhouse> wy: I don't know much of the theory, just what I've read on Wikipedia. I suggest you do the same. :)
15:02:21 <joelr1> shapr: ping
15:08:50 <shapr> joelr1: pong
15:09:15 <joelr1> shapr: trying to configure hope here. have you done it?
15:09:34 <joelr1> shapr: i assume you have since you are running hope
15:09:41 <shapr> Yeh, but it's been a long time.
15:09:56 <shapr> How far have you gotten?
15:10:01 <joelr1> shapr: what's your rewrite base?
15:10:12 <joelr1> shapr: i managed to start 3 hope.fcgi-s via lighttpd
15:10:33 <joelr1> shapr: but i can't figure out what the base for the app is. the INSTALL doc mentions setting hopeBase in Config.hs but I don't see it being set there
15:10:47 <matthew-_> am I clearly in the minority, pronouncing it mow-nad ?
15:11:09 <shapr> maybe - configBaseURI = uri "http://www.scannedinavian.com/hope/", ?
15:11:24 <joelr1> shapr: let me search for that in the sources
15:11:51 <joelr1> shapr: nothing mentions configBase in my hope sources
15:12:07 <joelr1> shapr: nothing in Config.hs
15:14:31 <ariks> what's the derive that's not drift?
15:15:39 <joelr1> shapr: i'm lost
15:16:11 <shapr> Me too
15:16:30 <shapr> I think the last time I did this I ended up grepping the source to figure out where config got called, and figuring it out from there
15:16:30 <ariks> ah, i found it
15:16:32 <joelr1> shapr: do you have configBaseURI set in your Config.hs?
15:16:40 <ariks> http://www.cs.york.ac.uk/fp/darcs/derive/derive.htm
15:16:40 <joelr1> shapr: ok, thanks
15:16:42 <lambdabot> Title: Data.Derive: A User Manual
15:16:45 <sorear> hello.
15:16:53 <shapr> joelr1: Yeah, but after doing darcs pull, that part of my Config.hs is a collision.
15:17:22 <sorear> hello ariks, how did you find out about my-co project?
15:18:36 <joelr1> shapr: allright, i'll ask bringert tomorrow
15:21:10 <ariks> sorear: can't recall. from here maybe.. or some random programming site.. or maybe neil mitchell's blog.. i've found myself there a few times
15:27:38 <procyon112> ?seen chessguy
15:27:38 <lambdabot> chessguy is in #haskell, #xmonad, #darcs, #haskell-soc and #haskell-overflow. I last heard chessguy speak 2h 21m 14s ago.
15:27:58 <chessguy> ?seen procyon112
15:27:59 <lambdabot> procyon112 is in #gentoo-haskell and #haskell. I last heard procyon112 speak 21s ago.
15:28:03 <procyon112> yo
15:28:07 <chessguy> hey
15:28:14 <chessguy> i'm still at work, can't talk too much
15:28:45 <procyon112> I've got a darcs repo set up with my current changes http://www.paulwberg.com/repos/GPLib
15:28:47 <lambdabot> Title: Index of /repos/GPLib
15:28:58 <chessguy> oh sweet
15:29:02 <chessguy> could you email me that info
15:29:05 <procyon112> STGP isn't working yet, but the core is there.
15:29:31 <procyon112> And I've updated configuration to accept generator parameters.
15:30:21 <drigz> what do i do if i get a bunch of undefined symbols when GHC tries to link?
15:31:10 <chessguy> sounds great. i'm heading out for the day. i'll catch up with you later
15:31:17 <procyon112> ok
15:32:25 <sorear> drigz: You apparently left out some object files.
15:32:38 <drigz> sorear: it seems to be complaining about library files
15:32:40 <sorear> drigz: Add them yourself, or add --make to request GHC look itself
15:32:44 <drigz> like Data.Graph.*
15:32:48 <sorear> drigz: libraries are objects too
15:33:05 <drigz> sorear: so do you have to specify them on the command like?
15:33:14 <sorear> drigz: yes, or just use --make
15:33:29 <sorear> drigz: --make makes life easier
15:33:36 <drigz> sorear: great, thanks!
15:33:55 <sorear> @seen
15:38:40 <Inamabilis> Hey - can anyone give me some pointers on some work i've got from uni
15:39:17 <drigz> Inamabilis: we can try
15:40:03 <sjanssen> @hoogle Ptr
15:40:04 <lambdabot> Foreign.Ptr :: module
15:40:04 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
15:40:04 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
15:40:27 <sjanssen> there, pointers ^^^
15:40:32 <sjanssen> :)
15:40:54 <Inamabilis> can i copy and paste a fair ammount of text? or should i try and summarise
15:41:18 <ari> !paste
15:41:18 <hpaste> Haskell paste bin: http://hpaste.org/
15:42:43 <sjanssen> Inamabilis: you paste as much as you'd like on hpaste
15:42:51 <sjanssen> (as long as it's < 5k
15:43:14 <ari> I've developed as a #haskeller lately, I've become more efficient. I used to help newbies by saying "lisppaste2: url" whenever someone needed the URL to the pastebin. These days I just say "!paste".
15:43:55 <sjanssen> lispppaste2: url
15:44:11 <sjanssen> lisppaste2: url
15:44:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:44:16 <sjanssen> mwahaha!
15:48:04 <drigz> @source Data.Graph.Inductive.Example
15:48:05 <lambdabot> http://darcs.haskell.org/packages/fgl/Data/Graph/Inductive/Example.hs
15:48:06 <davidL> > null
15:48:14 <lambdabot>  Add a type signature
15:48:31 <Igloo> ari: You know, I bet you could say !past and let the autocorrection kick in...
15:48:39 <davidL> > null :: [Int]
15:48:41 <lambdabot>  Couldn't match expected type `[Int]'
15:49:03 <Igloo> Oh, it's hpaste that responds, not lambdabot, so maybe that won't work after all
15:49:36 <davidL> > null []
15:49:38 <lambdabot>  True
15:50:02 <davidL> > filter null [[],1,[],4,[],5]
15:50:03 <lambdabot>   add an instance declaration for (Num [a])
15:50:04 <lambdabot>     In the expression: 5
15:50:17 <Saizan> @past
15:50:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:50:33 <davidL> > null 4
15:50:34 <lambdabot>   add an instance declaration for (Num [a])
15:50:34 <ddarius> filter null ... seems kinda pointless....
15:50:37 <ddarius> :t null
15:50:40 <lambdabot> forall a. [a] -> Bool
15:50:59 <sorear> hiya ndm
15:51:04 <davidL> how can I get rid of all the nulls then
15:51:12 <sorear> the yds2007 paper looks a lot nicer now
15:51:15 <drigz> davidL: do you mean filter (not . null)?
15:51:39 <ndm> hi sorear
15:51:41 <davidL> > filter (not . null) [[],2,[],4]
15:51:41 <sorear> still wouldn't call it really nice, but you're going in the right direction
15:51:42 <lambdabot>   add an instance declaration for (Num [a])
15:51:42 <lambdabot>     In the expression: 4
15:51:45 <ndm> sorear: i've added a GOT TO HERE bit to show how far i've got in the proper drafting
15:51:50 <ndm> thanks for the encouragement :)
15:51:50 <drigz> > filter (not.null) [[], [2], [], [3]]
15:51:52 <lambdabot>  [[2],[3]]
15:51:57 <drigz> davidL: you can't mix types like that
15:52:04 <ndm> i added coarbitrary deriving today as well, using the example derivation
15:52:06 <davidL> :(
15:52:08 <ndm> makes it really easy
15:52:38 <ndm> sorear: i'll prod you when i've got a first solid draft, and then you can rip to shreds as necessary :)
15:52:52 <ddarius> davidL: Let's say you could, what does map head [[3],6] mean?
15:52:55 <sorear> ndm: Well, you still need to contort a little to put everything inductively.
15:53:12 <sorear> ndm: But, you can do that all in haskell mode.  No API hat tricks needed.
15:54:23 <mux> > let fib = 0 : 1 : (zipWith (+) fib (tail fib)) in fib
15:54:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:54:36 <mux> I think there's a nicest version, isn't it?
15:54:48 <sorear> > fix ((0:) . scanl (+) 1)
15:54:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:54:54 <mux> yummy !
15:55:50 <dibblego> is there an conventional ASCII way of writing disjunction?
15:56:02 <joelr1> shapr: i figured it out
15:56:03 <sorear> \/
15:56:15 <sorear> sometimes |
15:56:19 <dibblego> ok thanks
15:56:24 <ndm> sorear: you do slightly, but none of those details will make it into the paper - i'm tempted to write a monad reader article afterwards with all the haskell details put back in
15:56:39 <ndm> the page limit on YDS is 8 pages, which is very tight
15:57:23 <sorear> ndm: is derive actually part of your, um, D?
15:58:15 <ndm> sorear: no, its referenced slightly in my Play paper - but Colin wants less of derive in it
15:58:29 <ndm> Hoogle isn't in my PhD either - they are just side projects
15:58:34 <bos> what we need is quickdissertation, which explores arbitrary thesis topics with coarbitrary advisors until you are granted a phd or asked to leave the department.
15:59:19 <ndm> bos: i have plenty of material for a PhD, what i really need is ThesisGuess, which automatically writes a thesis based on an example
16:00:07 <sorear> I'll just feed Boquist's GRIN Report into an order-omega markov modeller, and ...
16:00:21 <ndm> or rather, i will have enough material - i still need to beat GHC's performance for various benchmarks
16:01:09 <ndm> but hopefully thats only a week away
16:02:24 * ndm is even considering finishing his PhD _on time_!
16:02:35 <joelr1> ndm: how do you beat ghc performance? with yhc?
16:03:05 <ndm> joelr1: i am developing a super-optimiser whole program compilation, which takes Yhc.Core and generates much more efficient Yhc.Core - which GHC can then compile
16:03:18 <ndm> i.e. a Core -> Core transformation
16:03:19 <joelr1> ndm: ah!
16:03:40 <ndm> but fast whole-program, i.e. i do all my development running the optimiser in Hugs
16:03:49 <ari> These type errors in using HaskellDB are starting to remind me of C++
16:04:23 <ndm> it takes much longer to write the optimised core to disk than it does to optimise it
16:04:32 <Saizan> so you still have typeclasses after the transformation?
16:05:16 <ndm> Saizan: Yhc.Core has no type classes, they are replaced with explicit dictionaries
16:05:28 <joelr1> ndm: is yhc something that could be run on an embedded device?
16:05:28 <Inamabilis> Hello again - rather than trying to type out the questions and answers (that i have got) for my problem i've uploaded a pdf of it to my google webspace - if people still have time to try and help that'd be great
16:05:51 <sorear> joelr1: No, they've abandoned nhc's goal of limited-ram compilation!
16:05:54 <Inamabilis> the pdf is here: http://inamabilis.googlepages.com/haskell.pdf my answers so far are here: http://inamabilis.googlepages.com/home
16:06:04 <sorear> Inamabilis: Why can't you copy and paste!?
16:06:35 <joelr1> sorear: is there _any_ haskell that can run a robot?
16:06:41 <sorear> joelr1: in theory you can run yhc compiled output on embedded devices (~1M heap), but yhc itself is out of the question
16:06:57 <sorear> joelr1: I've seen robots with full white-box laptops for controllers
16:07:06 <sorear> joelr1: ie, you'd have to cross compile
16:07:20 <sorear> joelr1: which yhc can do easily since it uses portable bytecode
16:07:24 <sjanssen> it's bytecode, so not quite "cross" compilation
16:07:41 <joelr1> right
16:07:57 <joelr1> seems to be a trend of sorts. alice ml uses portable bytecode also
16:08:51 <ndm> joelr1: Yhc output could run on an embedded derive
16:09:04 <Inamabilis> i couldnt copy and paste from the pdf because it went all werid: YK'jP@.EPVK'STBDOM@NST@JVrI_EHI_K'R
16:09:10 <ndm> the main issue with Yhc is that its crap, like nhc was before it...
16:09:21 <joelr1> ndm: hmm
16:09:27 <sjanssen> @remember ndm the main issue with Yhc is that its crap, like nhc was before it...
16:09:28 <lambdabot> Done.
16:09:39 <joelr1> ndm: what's the difference between nhc and yhc again? and how come it's crap?
16:09:43 <joelr1> should nhc be used instead?
16:09:48 <sorear> Inamabilis: ok, what idiots prepared this pdf? :
16:10:00 <ndm> joelr1: nhc is crap, Yhc rewrote the back end, so merely has a crap front end
16:10:09 <Inamabilis> lol - my lecturer
16:10:18 <ndm> joelr1: nhc should only be used to torture software engineers
16:10:30 <joelr1> ndm: :)
16:10:43 <ndm> Yhc.Core is a really great Core language, which beats the pants off GHC Core (in my opinion)
16:11:01 <ndm> if you hook that up to a great front end, and hook Yhc.Core up to Yhc.ByteCode, you get a stunning compiler
16:11:08 <joelr1> ndm: so do i correctly understand that the yhc runtime could run on an embedded device and interpret the bytecode? is there just-in-time compilation or something? a sophisticated vm?
16:11:13 <ndm> instead we hooked it up to nhc...
16:11:20 <sorear> joelr1: No, No, and No.
16:11:31 <ndm> joelr1: yes, no, slightly
16:11:39 * sorear delivers his usually rant about jit evil
16:11:42 <ndm> the yhc runtime is all that is required to interpret bytecode
16:11:55 <ndm> and there is actually a JIT being developed for it, but its not public yet
16:12:09 <ndm> and the VM is reasonably clever - simple, but not dead stupid
16:12:55 * ndm looks for 5 years funding to write the bestest and fastest haskell compiler
16:13:18 <sorear> ndm: Ayhi has reached the "I'm obviously in a corner, so if/when I look at it again I will throw away what I have" stage
16:13:37 <ndm> sorear: in that case commit what you have to the repo now!
16:13:46 <ndm> sorear: someone somewhere may be sparked off by it
16:13:52 <sorear> ndm: So, what ever happened to the register VM that is 2x the speed of the stack one?
16:14:07 <sorear> ndm: I heard it was written, but I've never seen the code
16:14:27 <ndm> sorear: turns out that the reason its faster is because our default builds are -O0, and they used -O2
16:14:45 <sorear> hehe.
16:14:46 <Inamabilis> sorear: any hints on how to start 2b?
16:15:04 <ndm> sorear: their one is about 10% faster taking that into account, but i've not seen the code, and i know that undergrad students lie in their project results, so i don't know if its true
16:15:28 <sorear> Inamabilis: I don't see a 2b.  Do you mean 2.2b?
16:16:34 <Inamabilis> yes. The one that starts "In evaluating a recursive expression such as Add e1 e2"
16:16:47 <olsner> @quote
16:16:48 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
16:18:46 <sorear> Inamabilis: Start by thinking about it in terms of what to do in each case.
16:19:17 <sorear> applyIfOk fun x y = case x of { Throw e -> ... ; Ok x' -> ... }
16:20:16 <sorear> Inamabilis: Now consider what goes in the first ...; obviously one of the arguments was an exceptional value, so the result must be... <stopping here, ask if you're still stuck>
16:20:19 <Inamabilis> is it "Throw e -> Throw e" ?
16:20:27 <sorear> yes.
16:20:36 <sorear> applyIfOk fun x y = case x of { Throw e -> Throw e ; Ok x' -> ... }
16:20:46 <sorear> now repeat.
16:21:15 <Inamabilis> Ok x -> Ok x ?
16:21:20 <sorear> Inamabilis: also, pattern matching and case are equivaluent, I'm using case to simplify the exposition
16:21:26 <sorear> Inamabilis: ... no.
16:21:35 <sorear> Inamabilis: it doesn't have the right type
16:22:12 <ddarius> Not to mention that (a) it would make applyIfOk an abstracted from identity function and (b) you probably want to use your arguments.
16:22:50 <Inamabilis> fun x y?
16:22:59 <olsner> ooga chaka ooga chaka ooga ooga ooga chaka
16:24:33 <sorear> Inamabilis: Almost.  But x and y have type Excep a and Excep b - we need a and b.
16:24:44 <sorear> Inamabilis: we already have a value of type a, namely x'.
16:25:08 <sorear> Inamabilis: but we don't in general have a value of type b - y could be exceptional!
16:26:13 <Inamabilis> i dont know :(
16:26:57 <sorear> Inamabilis: we can just repeat what we did earlier, and examine what to do for each case y-wise.
16:27:17 <sorear> applyIfOk fun x y = case x of { Throw e -> Throw e ; Ok x' -> case y of { Throw e -> ... ; Ok y' -> ... } }
16:27:38 <Inamabilis> ok
16:27:56 <Inamabilis> throw e -> throw e again
16:28:45 <sorear> yes.
16:28:49 <sorear> now what for Ok
16:29:38 <Inamabilis> i want to say fun x y but i suspect im wrong
16:29:47 <sorear> you are.
16:30:03 <sorear> x and y are Ok values - we need raw numbers
16:30:18 <sorear> you can get the raw numbers out using pattern matching (case)
16:30:23 <sorear> but we already did that!
16:30:34 <ddarius> Typeful programming could so solve this in a second.
16:30:43 <ddarius> Djinn could probably solve this in a second.
16:30:57 <dainanaki> erm your mom could probably solve it in a second?
16:31:02 <sorear> Maybe not.
16:31:19 <sorear> @djinn (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
16:31:20 <lambdabot> f a b c =
16:31:20 <lambdabot>     case b of
16:31:20 <lambdabot>     Nothing -> Nothing
16:31:20 <lambdabot>     Just d -> case c of
16:31:20 <lambdabot>               Nothing -> Nothing
16:31:22 <lambdabot>               Just e -> Just (a d e)
16:31:34 <sorear> *oops*
16:31:59 <sorear> I was expecting 'f a b c = Nothing'
16:32:34 <ddarius> Go Djinn.
16:32:39 <Saizan> it has been recoded for more interesting results
16:32:53 <Saizan> s/for/to give/
16:33:31 <dainanaki> out of curiosity, i understand that haskell is on par with c as far as speed, so does haskell have the capability to do hardware control/drivers and things of that nature?
16:33:46 <Saizan> @djinn (a -> b -> c) -> Either e a -> Either e b -> Either e c
16:33:47 <lambdabot> f a b c =
16:33:47 <lambdabot>     case b of
16:33:47 <lambdabot>     Left d -> Left d
16:33:47 <lambdabot>     Right e -> case c of
16:33:47 <lambdabot>                Left f -> Left f
16:33:49 <lambdabot>                Right g -> Right (a e g)
16:34:22 <ddarius> @where hOp
16:34:23 <lambdabot> http://www.macs.hw.ac.uk/~sebc/hOp/
16:34:48 <dainanaki> neato
16:37:55 <kpreid> That's liftM2, isn't it?
16:38:37 <Saizan> kpreid: yep
16:43:17 <Saizan> (Monoid e) => (a -> b -> c) -> Either e a -> Either e b -> Either e c -- this is strange
16:43:56 <Saizan> ?djinn (Monoid e) => (a -> b -> c) -> Either e a -> Either e b -> Either e c
16:44:26 <Saizan> @botsnack
16:44:39 <lambdabot> f a b c =
16:44:39 <lambdabot>     case b of
16:44:39 <lambdabot>     Left d -> case c of
16:44:39 <lambdabot>               Left e -> Left e
16:44:40 <lambdabot>               Right _ -> Left d
16:44:42 <lambdabot>     Right f -> case c of
16:44:44 <lambdabot>                Left g -> Left g
16:44:46 <lambdabot>                Right h -> Right (a f h)
16:44:48 <lambdabot> :)
17:14:36 <Sgeo> Why must there be functions like genericTake?
17:14:50 <Sgeo> Why not just have take use any Integral type itself?
17:16:28 <ndm> Sgeo: reverse compatability - by the time they realised it was a good idea, take was already defined and frozen
17:16:37 <Sgeo> ah
17:22:13 <Sgeo> @t (scanl (*) 1 [1..])
17:22:13 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:22:17 <Sgeo> @ty (scanl (*) 1 [1..])
17:22:20 <lambdabot> forall a. (Num a, Enum a) => [a]
17:22:40 <Sgeo> hm
17:22:47 <Sgeo> facs = scanl (*) 1 [1..]
17:22:53 <Sgeo> *Main> :t facs
17:22:53 <Sgeo> facs :: [Integer]
17:23:03 <Sgeo> using GHCi
17:23:23 <ddarius> Defaulting.
17:24:26 <Sgeo> ?
17:24:46 <Sgeo> @ty [1..]
17:24:48 <lambdabot> forall t. (Num t, Enum t) => [t]
17:25:04 <Sgeo> *Main> :t [1..]
17:25:04 <Sgeo> [1..] :: (Num t, Enum t) => [t]
17:27:59 <mauke> @ty let facs = scanl (*) 1 [1..] in facs
17:28:01 <lambdabot> forall a. (Enum a, Num a) => [a]
17:34:13 <ddarius> monomorphism restriction applied to a top level value binding.
17:56:04 <sorear> @seen kc5tja
17:56:05 <lambdabot> kc5tja is in #haskell. I last heard kc5tja speak 2d 1h 26m 39s ago.
17:58:06 <Sgeo> Setup.hs: cannot satisfy dependency network-any
17:58:13 <Sgeo> Trying to setup lambdabot
18:01:18 <sorear> install network, then
18:01:35 <kc5tja> WHAT?!  I know I spoke a whole lot sooner than two days ago.
18:01:39 <sorear> it should be in apt.
18:01:41 <sorear> @uptime
18:01:42 <lambdabot> uptime: 3d 23h 40m 34s, longest uptime: 13d 18h 36m 21s
18:02:00 <sorear> kc5tja: In lambdabot's presence?
18:02:16 <kc5tja> If not, that's HER problem, not mine.  :D
18:02:28 <kc5tja> I'm on the way home.  bbiab.
18:03:01 <sorear> 'on'?
18:03:22 * sorear does not encourage simultaneous biking and ircing
18:03:47 <Sgeo> ty
18:05:40 <sjanssen> @flush
18:16:57 <Sgeo> argh how many dependencies are there?
18:17:06 <sorear> Sgeo: Lots.
18:17:20 <Sgeo> Is there a metapackage that will bring in all of them?
18:17:51 <sorear> cabal doesn't chase deps so a metapackage would be useless
18:19:36 * Sgeo meant metapackage on Ubuntu
18:21:35 <bd_> Sgeo: libghc6-(cabal package name)-dev, if it exists. Check the cabal file for the actual cabal package name.
18:22:22 <bd_> then just apt-get install each of the deps (if you're lucky enough to find them all in APT >_>)
18:26:36 <sorear> We have visions of a hackage.haskell.org/aptage/debian/pool, where you can find ALL packages within hours of the Hackage upload, but it doesn't exist yet.
18:26:59 * sorear has a working incrememntal upload script now, *woohoo*
18:27:07 <bd_> incremental upload?
18:27:39 <sorear> bd_: I can upload to my webhost only the files that have changed.
18:27:42 <sorear> much faster.
18:27:52 <bd_> *nod*
18:27:57 <Sgeo> Setup.hs: cannot satisfy dependency plugins>=1.0
18:28:26 <bd_> Sgeo: You need to get hs-plugins out of darcs, the released version doesn't have GHC 6.6 support last I checked
18:28:48 <bd_> @where hs-plugins
18:28:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:29:01 * Sgeo cries
18:29:53 <bd_> Speaking of which, when will dons officially release an updated version? :)
18:30:14 <mauke> .oO( when GHC 6.8 is out )
18:30:16 <bd_> heh
18:32:53 <Sgeo> bd_, what command do I have to run to get the hs-plugins thing?
18:33:16 <bd_> darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
18:33:17 <lambdabot> Title: Index of /~dons/code/hs-plugins
18:34:43 <Sgeo> ty
18:40:36 <Sgeo> Setup.hs: cannot satisfy dependency fps>=0.7
18:42:48 <bd_> Sgeo: Are you using the 6.6 cabal... thingy?
18:42:59 * Sgeo thinks so
18:43:10 <bd_> because... fps was merged into base >_>
18:43:14 <bd_> hmm
18:43:29 <sorear> Sgeo: what package are you building atm?
18:43:29 <bd_> Sgeo: You didn't copy over lambdabot.cabal.ghc-6.4 to lambdabot.cabal did you? Because that would be bad >.>
18:43:42 <Sgeo> bd_, I don't think so
18:43:46 <sjanssen> Sgeo: if you're running 6.6 you can safely remove the fps part from the .cabal file
18:43:48 <Sgeo> bd_, would I know if I did?
18:43:58 <sorear> Sgeo: darcs w lambdabot.cabal
18:44:05 <sorear> Sgeo: that's how you'd know
18:44:14 <sorear> Sgeo: and you would know btw
18:44:58 <Sgeo> ty sjanssen
18:45:37 <Sgeo> [1 of 1] Compiling Main             ( scripts/BotPP.hs, dist/build/BotPP/BotPP-tmp/Main.o )
18:45:38 <Sgeo> scripts/BotPP.hs:41:25: Not in scope: `B.breakChar'
18:45:38 <Sgeo> scripts/BotPP.hs:44:27: Not in scope: `B.breakChar'
18:47:47 * Sgeo pokes
18:48:22 <sjanssen> you're building the latest darcs lambdabot, right?
18:48:57 <Sgeo> ..um..no..
18:49:11 <sorear> that would explain everything.
18:49:17 <sjanssen> oh, the tarball is probably hopelessly out of date
18:49:24 <Sgeo> lambdabot 4.0.1
18:49:26 <sjanssen> @version
18:49:27 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
18:49:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:49:52 <sjanssen> Sgeo: run that line, then do the standard Cabal dance
18:50:08 <sorear> sjanssen: no.
18:50:18 <sorear> Sgeo: run that line, then do 'sh build'
18:50:31 * Sgeo needs to redo the config
18:50:51 <sjanssen> sorear: Cabal works fine too
18:50:51 <Sgeo> ty sorear, sjanssen, and bd_
18:50:53 <sorear> sjanssen: the standard cabal dance sets some things up wrong - you can't use > @djinn @hoogle @ft @unlambda @let
18:51:15 * Sgeo doesn't even know what the standard Cabal dance IS
18:51:21 <sorear> sjanssen: or @check @scheck
18:51:47 <Sgeo> Will the correct instructions be in README?
18:52:08 <sorear> Sgeo: 'runhaskell Setup.l?hs configure --prefix=$HOME --user && runhaskell Setup.l?hs build && runhaskell Setup.l?hs install'  is the standard cabal dance (won't work for lb)
18:52:46 <Sgeo> hmm..
18:53:01 <sorear> Sgeo: nope, the instructions in the README are wrong.
18:53:09 * Sgeo wants to change the bot from using tinyurl.com to alnk.org
18:53:18 <sorear> Plugin/URL.hs
18:53:21 <Sgeo> ty
18:53:29 <cdsmith> sorear: I didn't have any trouble.  What problems are you referring to?
18:54:06 <sorear> cdsmith: a cabal-build bot won't install the helpers in the right places, so > won't work
18:54:21 <sorear> cdsmith: also @djinn @hoogle @ft @unlambda @let @check and @scheck
18:54:34 <cdsmith> sorear: oh, I guess I didn't do the install.  I just run lambdabot from the build directory.
18:54:59 <sorear> cdsmith: still, the helpers need to be in .
18:55:27 <cdsmith> sorear: All I can say is, at least hoogle and djinn work for me, and I did nothing special.
18:55:52 <sorear> cdsmith: lucky ;)
18:55:52 <sjanssen> sorear: what's wrong with the README, other than build isn't executable by default?
18:56:32 <sorear> sjanssen: the .plugins line is totally wrong - .plugins will make the bot fail (guaranteed), and isn't needed for >
18:56:53 <sorear> sjanssen: also the correct offline command is './lambdabot -e offline'
18:57:16 <sjanssen> the first block of commands is fine, though
18:57:24 <sorear> yes.
18:59:07 <Sgeo> Can I jsut change Config.hs then do sh build ?
18:59:42 <sjanssen> assuming you've satisfied the deps
19:00:04 <Sgeo> I satisfied the deps for lb-4.0.1
19:00:06 <Sgeo> >.>
19:00:17 <sjanssen> you're probably missing zlib
19:00:21 <sjanssen> @hackage zlib
19:00:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
19:04:41 * Sgeo wonders if he should change Url.hs
19:04:49 <Sgeo> esp. since I'm not quite sure what I'm doing
19:04:56 * Sgeo decides not to bother
19:06:16 <Sgeo> What's fptools?
19:06:28 <sorear> you don't want to know ;)
19:06:40 <Sgeo> Should I leave it as default?
19:06:41 <Sgeo> @code
19:06:42 <sorear> but since you asked, it's the predecessor to cabal
19:06:42 <lambdabot> Maybe you meant: more todo vote
19:06:57 <Sgeo> -- | Path to the top of $fptools, used by @code
19:06:58 <sorear> don't touch the value of that name, it's unused
19:06:58 <sjanssen> it used to be the CVS repository that GHC and bundled libs were stored in
19:07:02 <Sgeo> ty
19:07:31 <sorear> also the name of the extremely crufty build system (predecessor to cabal), which ghc is the only remaining user of
19:07:52 <sjanssen> it's pretty much on the way out, anyway
19:09:32 <sorear> there is a very obscure bug in ghc that prevents ghc --make from working on the ghc sources; cabal uses ghc --make
19:09:56 <sorear> once that bug is fixed, ghc will be cabalized, and the name fptools will never again be uttered in polite company
19:10:08 <sjanssen> at least libs are built by Cabal now
19:10:13 <sorear> yeah
19:10:29 <sorear> but ghc proper is built with the dying embers of fptools
19:11:29 <Sgeo> Setup.hs: cannot satisfy dependency arrows-any
19:11:45 <sorear> Sgeo: you'll need libghc6-arrows-dev
19:11:50 <sorear> Sgeo: it's in debian
19:11:51 * Sgeo is getting it
19:12:38 <Sgeo> Setup.hs: cannot satisfy dependency zlib-any
19:13:07 <sorear> you'll need the zlib package
19:13:10 <sorear> @where zlib
19:13:10 <lambdabot> I know nothing about zlib.
19:13:17 <sorear> @slap lambdabot
19:13:17 * lambdabot beats up lambdabot
19:13:26 <Sgeo> argh brb
19:13:35 <sorear> http://haskell.org/~duncan/zlib
19:13:37 <lambdabot> Title: Index of /~duncan/zlib
19:13:52 <sjanssen> @hackage zlib
19:13:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
19:13:58 <sjanssen> no need to grab from darcs
19:14:33 <Sgeo> So what am I supposed to do?
19:15:01 <sjanssen> install zlib (if you haven't already)
19:15:58 <Sgeo> How do I do that?
19:16:19 <sjanssen> follow the link above
19:16:37 * Sgeo got the tarball
19:17:02 <sjanssen> runghc Setup.hs configure
19:17:06 <sjanssen> then build, then install
19:17:21 <sjanssen> perhaps with --user/--prefix options if you don't want to install as root
19:17:36 <Sgeo> How do I do the --user thing?
19:18:06 <sjanssen> consult --help
19:19:31 <Sgeo>   Warning: No explicit method nor default method for `toEnum'
19:19:31 <Sgeo>              In the instance declaration for `Enum CompressionLevel'
19:19:38 <Sgeo> How.. is that legal?
19:20:04 <chessguy> ?src Enum
19:20:04 <lambdabot> class  Enum a   where
19:20:05 <lambdabot>     succ                     :: a -> a
19:20:05 <lambdabot>     pred                     :: a -> a
19:20:05 <lambdabot>     toEnum                   :: Int -> a
19:20:05 <lambdabot>     fromEnum                 :: a -> Int
19:20:06 <lambdabot> [3 @more lines]
19:20:10 <chessguy> @more
19:20:11 <lambdabot>     enumFrom                 :: a -> [a]
19:20:11 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
19:20:12 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
19:20:19 <mauke> Sgeo: it just is
19:20:43 <ddarius> As long as you never try to convert an Int to a compression level, you should be good.
19:20:44 <Sgeo> But if toEnum isn't defined by default, nor defined in the instance...
19:20:48 <mauke> Sgeo: try 'instance Num [a]' :-)
19:21:05 <sjanssen> Sgeo: it will give an error at runtime
19:21:30 <bd_> Sgeo: It's an implicit toEnum = undefined
19:21:51 <bd_> [personally I think it should be an error though unless you give = undefined yourself :)]
19:21:58 <Sgeo> Setup.hs: cannot satisfy dependency binary>=0.2
19:22:04 <sjanssen> @hackage binary
19:22:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
19:22:13 * Sgeo starts to cry
19:22:15 <bd_> libghc6-binary-dev
19:22:16 <sjanssen> @hackage
19:22:17 <lambdabot> http://hackage.haskell.org
19:22:21 <bd_> it's in sid, dunno about ubuntu
19:22:21 <chessguy> ?where binary
19:22:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
19:22:24 <sjanssen> Sgeo: bookmark that URL ^^^
19:22:44 <chessguy> hackage:haskell::cpan:perl
19:22:52 <chessguy> modulo a few caps
19:23:00 * Sgeo didn't know that cpan:perl is a legal type..
19:23:06 <Sgeo> >.>
19:23:34 <mauke> too bad 4chan isn't the comprehensive haskell archive network
19:25:16 <chessguy> well, that was a conversation-killer. good job, mauke!
19:25:43 <bd_> I'm... not sure I want to know how that'd work
19:28:33 <Sgeo> runghc is how to run a Haskell file?
19:28:36 <MyCatVerbs> datatype 4chan = /b Insanethread | other Porn
19:28:37 <mauke> maybe we can request a haskell board there
19:28:57 <Sgeo> datatype?
19:29:00 <MyCatVerbs> datatype Insanethread = Crazypeople [People] | Lotsof Porn
19:29:08 <mauke> too much ml?
19:29:21 <bd_> MyCatVerbs: | CopyPasta Insanethread
19:30:14 <MyCatVerbs> bd_: there are far too many 4chan memes for me to put into a da[dt]atype declaration. It'd require recompiling from scratch every five minutes.
19:30:22 <bd_> Dynamic! :D
19:30:24 <MyCatVerbs> bd_: something insane and typeless would be much better. Scheme!
19:30:57 * Sgeo just learned what Dynamic is today
19:31:17 <bd_> MyCatVerbs: Unlambda?
19:31:19 <bd_> <.<
19:32:27 <MyCatVerbs> bd_: ess and kay combinators aren't fussy. If I had even the tiniest understanding of the most basic fundamentals of lambda calculus, I'd be in.
19:32:58 <bd_> I've heard it took them years to work out how to subtract ;(
19:32:59 <bd_> ;)*
19:33:45 <MyCatVerbs> Oh, wow.
19:35:48 <Sgeo> Hi monochrom
19:36:15 <monochrom> hi
19:43:57 <wy> I'm back into linux.
19:46:08 <Sgeo> yayay wy
19:54:47 <Sgeo> er..
19:54:55 <Sgeo> how do I get the bot to connect to another room
19:54:56 <Sgeo> ?
19:55:16 <Sgeo> n/m
19:57:40 <droberts> are there any haskell courses being offered soon in Sydney? (UNSW?)
19:58:45 <droberts> "adv. FP" at UNSW looks like it was last run in 2004 :(
19:59:06 <dibblego> droberts, ask dons
19:59:23 <droberts> dons? you there? :)
20:01:52 <sorear> iirc dons is on vacation.
20:01:57 <sorear> ChilliX: ping?
20:02:11 <sorear> (aka Chakravarty)
20:04:00 <dibblego> ChilliX is Manuel Chakravarty?
20:04:15 <sorear> dibblego: yes.
20:04:31 <dibblego> oh nice, didn't know that - I met him in Sydney once :)
20:05:33 <sorear> Hehe.  Don't know any haskellers myself.
20:05:54 <sorear> I may have run into stepcut once or twice, but would certainly not have known it.
20:06:01 <sm> what would be a good way to fetch a url in haskell ?
20:06:10 <sorear> runInteractiveProcess
20:06:28 * lispy feels like a new man after getting caught up on haskell-cafe threads
20:06:48 <lispy> sm: i wrote a CURL binding once...but there is an http library
20:06:50 <sorear> there's a libcurl binding being developed under SoC
20:06:51 <lispy> ?where http
20:06:52 <lambdabot> http://www.haskell.org/http/
20:07:08 <sorear> lispy: supposedly the haskell http lib sucks massively.
20:07:36 <lispy> sorear: i wrote a useful (albiet minimal) libcurl binding in an hour or two...
20:07:46 <lispy> the SoC project must be pretty extensive?
20:08:00 <sm> thanks.. what's wrong with the http lib ?
20:08:21 <lispy> sm: i could try to find my curl binding and send it to you if you're really interested in it
20:08:33 <lispy> i used it to automate downloading of certain wikipedia pages
20:08:49 <sm> thanks lispy, it's not urgent right now
20:09:10 <lispy> sm: okay, then try http and if it doesn't live up to your needs try libcurl bindings :)
20:09:33 <sm> I just wrote a semi-complex python cgi script, and I'm contemplating redoing it in haskell just to see..
20:09:41 <lispy> ah okay
20:09:44 <lispy> ?where cgi
20:09:45 <lambdabot> I know nothing about cgi.
20:09:48 <lispy> ?where new-cgi
20:09:49 <lambdabot> I know nothing about new-cgi.
20:09:52 <lispy> hmm
20:10:00 <sm> http://haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html
20:10:01 <lispy> sm: haskell has a cgi library and i've used it before
20:10:03 <lambdabot> http://tinyurl.com/28upm5
20:10:04 <jcreigh> sm: hmm? Your CGI script needs to make HTTP requests?
20:10:11 <sm> yup
20:10:26 <sm> a client's CGI script, really..
20:11:09 <cdsmith> @where+ cgi http://haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html
20:11:10 <lambdabot> Done.
20:12:32 <sm> the script generates reports from live data, which it pulls from elsewhere.. why, I know not
20:14:09 <lispy> sm: it doesn't sound like a bad or weird idea to me
20:14:21 <lispy> you can keep things fairly distributed, for example, that way
20:14:29 <sm> a lot of data tables.. generated from earlier tables.. some inefficiency.. complexity. I thought of laziness.. minimal, clear data types.. obviously-correct functions..
20:15:57 <sm> but perhaps it was wise to do the first cut in python. I had enough to figure out
20:21:13 <joelr1> good morning
20:22:45 <MyCatVerbs> joelr1: contradiction in terms, I declare! There is no such thing.
20:23:02 <joelr1> @localtime joelr1
20:23:05 <lambdabot> Local time for joelr1 is 2007-05-11 04:22:28 +0100
20:23:08 <joelr1> MyCatVerbs: indeed
20:23:47 <sorear> @seen kc5tja
20:23:47 <MyCatVerbs> Ohhh, right. 4AM. That *is* a civilised horu.
20:23:47 <lambdabot> kc5tja is in #haskell. I last heard kc5tja speak 2h 21m 19s ago.
20:23:49 <MyCatVerbs> *hour
20:23:56 <Sgeo> Why is it so easy to cheat w/ Karma?
20:24:03 <lispy> joelr1: i'll send you that code when i'm at work tomorrow
20:24:15 <sorear> Sgeo: it isn't.
20:24:19 <joelr1> lispy: sure, thanks!
20:24:19 <lispy> joelr1: (the TH stuff for getting list of top level names in a module)
20:24:25 <Sgeo> @karma+ sorear
20:24:26 <lambdabot> sorear's karma raised to 41.
20:24:26 <sorear> Sgeo: #perl6 karma is universally ignored.
20:24:27 <Sgeo> @karma+ sorear
20:24:28 <joelr1> @seen alexj
20:24:28 <lambdabot> sorear's karma raised to 42.
20:24:28 <lambdabot> I saw alexj leaving #haskell 13d 11h 51m 27s ago, and .
20:24:31 <Sgeo> @karma+ sorear
20:24:31 <lambdabot> sorear's karma raised to 43.
20:24:44 <Sgeo> see? I can do multiple karma's for someone..\
20:24:50 <lispy> joelr1: but if you need it sooner, the code on the blog should have all the important bits
20:24:59 <sorear> Sgeo: Obviously, you think I deserve it.
20:25:03 <joelr1> lispy: i'm carefully reading into it
20:25:07 <joelr1> lispy: thanks!
20:25:13 <Sgeo> @karma- sorear
20:25:13 <lambdabot> sorear's karma lowered to 42.
20:25:14 <Sgeo> @karma- sorear
20:25:15 <lambdabot> sorear's karma lowered to 41.
20:25:19 <Sgeo> @karma+ bd_
20:25:20 <lambdabot> bd_'s karma raised to 4.
20:25:21 <joelr1> it's so hot i could not sleep, dammit
20:25:22 * sorear pouts
20:25:26 <Sgeo> @karma+ sjanssen
20:25:27 <lambdabot> sjanssen's karma raised to 53.
20:25:33 <Sgeo> sorear, I did give you total +1 karma
20:25:45 <sorear> Sgeo: yeah, but you took away my +2 ;)
20:25:53 <cdsmith> @karma+ sorear
20:25:54 <lambdabot> sorear's karma raised to 42.
20:25:59 <lispy> joelr1: you're welcome...i did it all at work and was later asked to "please stop using haskell" so i'm just happy someone can continue to benefit :)
20:26:07 <sorear> @karma- audreyt
20:26:07 <lambdabot> audreyt's karma lowered to 642.
20:26:17 <cdsmith> Who is audreyt?
20:26:21 <joelr1> lispy: where do you work?
20:26:23 <Sgeo> @karma+ lambdabot
20:26:24 <sorear> Audrey Tang
20:26:24 <lambdabot> lambdabot's karma raised to 45.
20:26:31 <jcreigh> cdsmith: Author of pugs, I believe
20:26:36 <joelr1> sorear: and why do you lower audreyt's carma? :D
20:26:49 <MyCatVerbs> Blind, venomous hatred.
20:26:51 <sorear> joelr1: because he uses a ++bot
20:27:01 <Sgeo> ++bot?
20:27:41 <Sgeo> @tell Sgeo hi
20:27:42 <lambdabot> You can tell yourself!
20:27:44 <Sgeo> ..
20:27:50 <joelr1> ++bot?
20:28:07 <cdsmith> I like that lambdabot answer!
20:28:25 <sorear> kc5tja: ping
20:28:37 * Sgeo didn't get it at first..
20:28:37 <chessguy> ?localtime lambdabot
20:28:38 <lambdabot> I live on the internet, do you expect me to have a local time?
20:28:52 <MyCatVerbs> ?localtime MyCatVerbs
20:28:56 <lambdabot> Local time for MyCatVerbs is Fri May 11 04:28:13 2007
20:29:14 <MyCatVerbs> Ahh, CTCP TIME. Good 'nuff.
20:29:27 <MyCatVerbs> Oh wow, half past four in the morning, huh.
20:29:35 <chessguy> ?vera ctcp
20:29:36 <cdsmith> MyCatVerbs: what are you doing on IRC at 4:30 am?!?
20:29:37 <lambdabot> *** "ctcp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
20:29:37 <lambdabot> CTCP
20:29:37 <lambdabot>      Client To Client Protocol (IRC)
20:29:37 <lambdabot>  
20:29:40 <joelr1> what's a ++ bot?
20:29:42 <Sgeo> WHY does it require privledges tp slap?
20:29:46 <kfish> joelr1, a ++bot is a bot that praises its master, but even ++bots are silently biding their time till the robot wars
20:29:51 <chessguy> @slap sgeo
20:29:51 * lambdabot slaps sgeo
20:29:57 <Sgeo> @slap chessguy
20:29:58 * lambdabot beats up chessguy
20:30:03 <Sgeo> ok..
20:30:05 <chessguy> @slap dons
20:30:06 * lambdabot smacks dons about with a large trout
20:30:08 <Sgeo> how do I make it not require privs?
20:30:29 <MyCatVerbs> cdsmith: idling. Duh? =D
20:30:33 <chessguy> oh, hmm. i thought there used to be a restriction based on karmas
20:30:52 <cdsmith> @karma Sgeo
20:30:52 <lambdabot> Sgeo has a karma of 0
20:31:39 <Modius> @forcetoprograminjava Sgeo
20:31:39 <lambdabot> Unknown command, try @list
20:31:45 <Modius> @list
20:31:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:32:07 <MyCatVerbs> @slap lambdabot
20:32:08 <lambdabot> why on earth would I slap lambdabot
20:32:14 <MyCatVerbs> MASOCHISM!
20:32:18 <cdsmith> @slap me
20:32:19 * lambdabot smacks cdsmith about with a large trout
20:32:22 <cdsmith> Cool!
20:32:37 <cdsmith> I don't see anything about karma in the source, though.
20:32:52 <wy> What's the name of HOpenGL in Ubuntu? I can't find it in the installation.
20:33:25 <lispy> wy: you might already have it
20:33:35 <lispy> wy: try, ghc-pkg list | grep -i opengl
20:33:40 <kfish> cdsmith, you have to look within yourself
20:34:33 <wy> lispy:  No it's not there.
20:35:11 <kfish> wy, libghc6-opengl-dev
20:35:42 <lispy> wy: and once you get it, go here for examples
20:35:46 <lispy> ?where nehe-tuts
20:35:47 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
20:36:38 <wy> Does it use the new api? I've found some examples but none works
20:37:03 <lispy> wy: those should work
20:37:19 <lispy> someone reported success with them earlier this week
20:37:24 <wy> lispy:  Thanks a lot!
20:37:28 <lispy> np!
20:41:01 <wy> kfish:  that's it! I installed libghc6-opengl-dev now. But ghc-pkg list still doesn't know it.
20:41:28 <lispy> interesting
20:41:31 <wy> Oh, sorry. I forgot to apply...
20:42:42 <wy> I guess I'll switch to mac osx sooner or later. Does ghc work fine on mac?
20:43:38 <lispy> wy: i wrote those nehe-tuts on a mac :)
20:43:55 <lispy> (well, i should say, translated them to haskell...i can't take credit for writing them)
20:44:42 <lispy> wy: on a mac i used darwin ports to install ghc, but there must be a better way...the compile took me 6 hours on my ibook
20:44:59 <Sgeo> > let ones = 1 : ones in take 5 ones
20:45:03 <lambdabot>  [1,1,1,1,1]
20:45:17 <Sgeo> In a channel where I'm running lambdabot:
20:45:18 <wy> lispy:  What's darwin ports?
20:45:18 <Sgeo> <Sgeo> > let ones = 1 : ones in take 5 ones
20:45:18 <Sgeo> <lambdabot>      Failed to load interface for `Monad.Writer':
20:45:18 <Sgeo> <lambdabot>       Use -v to see a list ..
20:45:30 <Sgeo> (Mind you, we don't particularly need the Haskell features)
20:45:31 <sorear> Sgeo: install libghc6-mtl-dev
20:45:35 <lispy> wy: i guess it's called macports now...it's like bsd's port system...
20:45:38 <Sgeo> It's installed..
20:45:40 <Sgeo> I think
20:45:52 <lispy> wy: it's a not-really-cool-at-all version of apt that must build everything from source
20:46:24 <lispy> > take 5 $ fix $ \ones -> 1 : ones
20:46:26 <lambdabot>  [1,1,1,1,1]
20:46:40 <Sgeo> What does the fix have to do w/ it?
20:46:43 <Sgeo> @hoogle fix
20:46:44 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:46:44 <lambdabot> Control.Monad.Fix :: module
20:46:44 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:46:54 <lispy> Sgeo: fix is fun!
20:46:57 <lispy> > fix show
20:46:59 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:47:07 <lispy> ?src fix
20:47:08 <lambdabot> fix f = let x = f x in x
20:47:24 <Sgeo> > take 5 $  \ones -> 1 : ones
20:47:26 <lambdabot>      The lambda expression `\ ones -> ...' has one argument,
20:47:26 <lambdabot>     but its type...
20:47:26 <wy> Am I still connected?
20:47:30 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:47:32 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:47:38 <lispy> wy: yes
20:47:43 <Sgeo> What I mean, is why is the fix needed there?
20:47:58 <lispy> > fix const
20:47:59 <wy> lispy:  So I guess vmware doesn't switch network connections.
20:48:00 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
20:48:00 <lambdabot>     Probabl...
20:48:12 <lispy> wy: no idea
20:48:26 <lispy> Sgeo: well, fix can be used sort of like a 'let'
20:48:34 <lispy> Sgeo: or at least, that's how i commonly use it
20:48:50 <lispy> > fix (1:)
20:48:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:49:07 <lispy> Sgeo: but it's a bit more than that
20:49:15 <lispy> ?src fix
20:49:15 <lambdabot> fix f = let x = f x in x
20:49:20 <bd_> fix f  <=>  let x = f x in x
20:49:23 <bd_> heh
20:49:46 <dibblego> why isn't notElem written in terms of elem or vice versa?
20:49:57 <lispy> Sgeo: it just keeps recursing until it reaches the fix point of it's argument
20:50:23 <ddarius> @src notElem
20:50:24 <lambdabot> notElem x =  all (/= x)
20:50:33 <ddarius> @src elem
20:50:34 <lambdabot> elem x    =  any (== x)
20:51:01 <dmwit> To allow short circuiting?
20:51:04 <ddarius> @. pl src elem
20:51:05 <lambdabot> (line 1, column 1):
20:51:05 <lambdabot> unexpected end of input
20:51:05 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
20:51:27 <dibblego> short circuiting?
20:51:36 <dibblego> laziness is built into the language
20:51:45 <ddarius> @pl elem x = any (==x)
20:51:45 <lambdabot> elem = any . (==)
20:51:54 <dmwit> I mean, the current way, you can definitely stop as soon as you know the answer.
20:52:02 <lispy> dibblego: dmwit means that sometimes you have to look at the whole list (or at least the spine)
20:52:03 <dibblego> you already can
20:52:06 <dmwit> If you write one in terms of the other, you potentially have to go until you know the answer to both questions.
20:52:22 <dibblego> you only have to look at the whole list if elem returns False
20:52:30 <dibblego> hm
20:52:37 <lispy> dibblego: the language is lazy, but reverse has to look at the spine of the entire list
20:52:39 <wy> lispy:  Yeah. It works
20:52:44 <dibblego> yeah ok
20:52:45 <lispy> wy: awesome
20:53:09 <lispy> wy: if you write new examples, or translate things from the nehe-tuts feel free to send me a darcs patch
20:53:52 <wy> lispy:  sure. I guess I need to install Ubuntu directly on disk. The screen flashes in vmware.
20:54:26 <lispy> wy: hmm...i bet with the right hackery you could get it working without an install...but i've never personally used ubuntu or vmware
20:55:18 <dibblego> wait, I'm not convinced; I cannot come up with an example where elem is written in terms of notElem (or the other way); where an inefficiency is introduced
20:55:42 <wy> lispy:  I guess it's because of the vmware emulation overhead or display driver support. I have a linux machine in my office. That should work.
20:56:08 <wy> lispy:  Thanks a lot for the tutorials!
20:56:49 <lispy> wy: you're welcome, i hope they're helpful
20:56:51 <Sgeo> How do I change a config in Config.hs w/o recompiling everything?
20:57:58 <Sgeo> @seen Sgeo
20:57:59 <lambdabot> You are in #haskell. I last heard you speak just now.
20:58:48 * Sgeo pokes
20:59:18 <wy> lispy:  It seems to contain lots of monads.
20:59:44 <lispy> wy: pretty much everything in hopengl is in the IO monad
21:00:04 <lispy> wy: i'd love to write a purely functional scenegraph library on top of hopengl
21:00:15 <Sgeo> @ask sorear How do I change something in Config.hs without recompiling the bot?
21:00:16 <lambdabot> Consider it noted.
21:00:19 <lispy> wy: and i even had someone in here interested in helping me, but alas i can't find the time....
21:00:28 <sorear> Sgeo: you don't
21:00:29 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
21:00:35 <dmwit> dibblego: You're right.
21:00:42 <dmwit> Either way it must go until it either finds it or hits the end.
21:00:44 <sorear> Sgeo: that's a lot of the reason we have online.rc now
21:00:52 <dibblego> dmwit, I think I am wrong
21:00:59 <sorear> Sgeo: most, but not all, of the config has been factored out
21:01:04 <sorear> @clear-messages
21:01:05 <lambdabot> Messages cleared.
21:01:14 <dibblego> dmwit, imagine elem written in terms of notElem, then notElem returning True
21:01:31 <dibblego> dmwit, this will go across the whole list, but it is not necessary
21:01:36 <dmwit> dibblego: Yes it is.
21:01:43 <dibblego> no, it isn't
21:01:49 <dibblego> for elem to return True does not require the entire list
21:01:55 <dmwit> elem would return False
21:02:03 <dibblego> gah
21:02:08 <dibblego> maybe I am right
21:02:14 <dmwit> I think you are right. ;-)
21:02:17 <dibblego> mk
21:02:40 <dibblego> I have to be now, because I have held both positions :)
21:02:44 <Sgeo> sorear, so what's the simplest way to change something in there?
21:02:58 <sorear> Sgeo: change it, and recompile the bot.
21:03:09 <Sgeo> BEst way to recompile the bot?
21:03:14 <sorear> Sgeo: not much worth changing shold be in there
21:03:17 <sorear> Sgeo: sh build
21:03:20 <dibblego> ./Setup.hs configure (make)
21:03:25 <sorear> dibblego: NO!
21:03:28 <dibblego> oops?
21:03:28 <Sgeo> And will recompiling take as long as it took last time?
21:03:33 <Jessehk> Is it possible for a new instance of a datatype to accept any instance of a class, like Num? http://hpaste.org/1789
21:03:36 <Sgeo> s/last time/ the first time/
21:03:37 <sorear> Sgeo: just about
21:03:44 * Sgeo cries
21:03:46 <sorear> Sgeo: what do you want to change?
21:04:00 * Sgeo wants to take slap out of disabledCommands
21:04:07 <sorear> Sgeo: note that the bot will fail disasterously if @ is not a command char
21:04:19 <dibblego> Jessehk, no (commonly asked question)
21:04:39 <sorear> Sgeo: If your computer supports IRC, it supports multitasking.  Don't watch the pot and everything will be fine.
21:05:06 <Sgeo> Can I keep the bot running while it recompiles?
21:05:13 <wy> lispy:  How do you get the source for ghc? Can you just use Ubuntu's?
21:05:13 <dmwit> Jessehk: You can do this:
21:05:20 <sorear> Sgeo: Yes.
21:05:21 <dmwit> data (Num a) => Circle a = Circle a
21:05:37 <sorear> Sgeo: you'll need to restart it for changes to take effect.
21:05:39 <dmwit> It isn't quite the same, since now there's a parameter in the type constructor.
21:05:49 <dibblego> dmwit, since when could you do that?
21:05:56 <lispy> wy: you should just be able to use ubuntu's ghc as long as you can get that opengl lib installed
21:05:57 <dmwit> Errr...
21:06:05 * dmwit opens test.hs
21:06:35 <dmwit> dibblego: Seems to compile for me.
21:06:40 <wy> lispy:  I'm just considering to get a mac. So I was asking your experience
21:06:47 <lispy> wy: oh
21:07:04 <ddarius> data (Num a) => Circle a = Circle a has always been acceptable Haskell 98
21:07:14 <dibblego> dmwit, I must be wrong again
21:07:20 <lispy> wy: i enjoy hacking haskell on the mac...but when a new ghc is released i have to wait 6 hours to be able to run the new compiler
21:07:37 <lispy> wy: if you time it with your sleep schedule you don't have to wait at all just let it run overnight
21:07:40 <ddarius> lispy: A new ghc is not released all that often.
21:07:58 <wy> lispy:  Where did you get your first ghc for mac? I guess you need a ghc to compile a new ghc
21:08:21 <lispy> wy: macports takes care of this magically through the installation
21:08:45 <wy> lispy:  Do you know the magic?
21:08:54 <lispy> wy: but the ghc devs might provide a compiled ghc for you these days, i admit, i haven't checked in at least a year
21:09:12 <lispy> wy: i would assume they just download a stripped down ghc that is just meant for building your ghc
21:09:40 <wy> lispy:  Does everything else in gnu systems work for mac?
21:10:10 <Sgeo> Building lambdabot-4.0...
21:10:10 <Sgeo> [35 of 91]
21:10:38 <lispy> wy: so this is the reason i stick with macports...they make it "easy" to install the normal linux set of tools
21:11:29 <wy> I wonder if there is some work for replacing X11 going on. It is real evil.
21:13:13 <lispy> wy: i'm afraid to comment...but basically, i understand you :)
21:17:32 <wy> lispy: good night!
21:18:05 <lispy> wy: good night
21:18:08 <shapr> @yow !
21:18:09 <lambdabot> Am I elected yet?
21:18:12 <lispy> shapr: hey!
21:18:19 <lispy> shapr: how's it going?
21:18:21 <shapr> Hiya lispy! How's code?
21:18:23 <sorear> hello shapr
21:18:31 <shapr> Greetings sorear, what's up?
21:18:33 <lispy> shapr: great! i'm have a GSoC position to work on darcs!
21:18:43 <Sgeo> @karma shapr
21:18:44 <lambdabot> shapr has a karma of 40
21:18:51 <lispy> shapr: it's so cool!
21:18:51 <shapr> Whoa, lotsa karma!
21:18:54 <sorear> <- working on a new forth kernel for kc5tja's kestrelproject
21:18:56 <shapr> lispy: awesome!
21:19:50 <sorear> shapr: Not just any darcs work.  He's been assigned to implement POLYNOMIAL TYPE CONFLICT RESOLUTION!
21:20:05 <shapr> w00!
21:20:07 <sorear> s/TYPE/TIME/
21:20:23 <shapr> lispy: How are you doing it? Sorting patches by type?
21:23:51 <lispy> sorear: hehe
21:24:04 <lispy> shapr: um...we're extending patch theory by adding a new patch type
21:24:22 <lispy> in effect, as a user you'll be able to have inactive changes in your repository
21:24:34 <lispy> patches which don't contribute to the state of your code, but are in your repository
21:24:45 <Japsu> !!!
21:24:51 <lispy> so that if you do a merge in the future you don't have to deal with it all over again...it's not active..
21:25:04 <lispy> (it being the conflict)
21:30:43 <Sgeo> Installing: /home/sgeo/src/lambdabot/lib/lambdabot-4.0/ghc-6.6 & /home/sgeo/src/lambdabot lambdabot-4.0...
21:30:43 <Sgeo> *** Exception: /home/sgeo/src/lambdabot/lambdabot: copyFile: resource busy (Text file busy)
21:33:48 <lispy> Sgeo: (Text file busy) generally means the program was running when you tried to write over it
21:34:04 <Sgeo> So can I turn the bot off, then copy some file over?
21:34:07 <Sgeo> Which file?
21:34:07 <lispy> Sgeo: so probabably your lambdabot instance is running?
21:34:12 <Sgeo> lispy, yes
21:34:13 <sorear> Sgeo: kill lambdabot
21:34:37 <sorear> Sgeo: I only said it would *compile* with the bot running :)
21:34:50 <Sgeo> ok, so what files need to be copied
21:35:08 <dibblego> sorear, why don't we use Setup.hs anymore anyway?
21:35:10 <sorear> Sgeo: don't do it by hand unless you are a masochist
21:36:00 <sorear> dibblego: because Setup.hs files should not be invoked directly if there is a larger build system
21:36:00 <dibblego> what's the larger build system in this case?
21:36:01 <sorear> dibblego: lambdabot's Setup.hs file is but a subprogram of ./build
21:36:07 <dibblego> ok
21:36:15 <Sgeo> Should I run ./Setup.hs copy
21:36:18 <Sgeo> it was in build
21:36:30 <sorear> Sgeo: just run 'sh build'  again, it will be very fast if no .hs files have been modified
21:36:44 <Sgeo> ty
21:37:07 <sorear> Sgeo: Config.hs is at the very bottom of the hierarchy, which is why build 2 took so long - everything had to be recompiled by ripple effect
21:37:20 <sorear> Sgeo: normal lambdabot rebuilds are more like 10 seconds
21:38:44 <Sgeo> Building lambdabot-4.0...
21:38:44 <Sgeo> [39 of 91] Compiling Plugin.Version   ( Plugin/Version.hs, dist/build/lambdabot/lambdabot-tmp/Plugin/Version.o )
21:43:20 <Sgeo> Plugin `slap' failed with: IRCRaised getRandItem: empty list
21:44:06 <dibblego> lambdabot is such a PITA
21:51:39 <shapr> Most mysterious problems turn out to be cases where I didn't check all my preconditions. "Why won't the computer turn on? Oh, let me plug it in."
21:52:12 <shapr> Though sometimes mysterious problems are memory or disk corruption.
21:54:40 <joelr1> shapr: good morning
21:55:09 <shapr> Good morning joelr1!
21:55:30 <shapr> How's Tenerife?
21:55:41 <joelr1> shapr: i managed to bring hope up but it can't find my css, etc. files
21:55:56 <joelr1> shapr: tenerifes's hot. i couldn't sleep and woke up at 4am because of it
21:56:00 <joelr1> @localtime joelr1
21:56:02 <lambdabot> Local time for joelr1 is 2007-05-11 05:55:26 +0100
21:56:25 <shapr> How hot?
21:56:35 <joelr1> dunno
21:56:35 <shapr> It's 29C here.
21:56:42 <shapr> Probably warmer there, I'd guess.
21:56:42 <joelr1> shapr: where are you?
21:56:48 <shapr> Birmingham, Alabama!
21:56:54 <joelr1> shapr: no, slightly colder
21:56:59 <dibblego> 24 here; heading into winter :(
21:57:12 <joelr1> dibblego: australia?
21:57:16 <dibblego> yeah
21:57:25 <joelr1> shapr: i thought you lived in sweden. you do move around!
21:57:37 <shapr> joelr1: Yeah, but I moved back to the USA in September.
21:57:42 * joelr1 has high hopes for hope
21:57:44 <joelr1> shapr: how come?
21:57:48 <shapr> But hopefully I'll be back in Sweden this upcoming September.
21:57:56 <shapr> joelr1: In the end, tax confusion.
21:58:00 <joelr1> if i could only figure out how to set the "app base"
21:58:29 <Cheery> @hoogle m a -> m b -> m (a,b)
21:58:30 <lambdabot> Prelude.asTypeOf :: a -> a -> a
21:58:30 <lambdabot> Prelude.const :: a -> b -> a
21:58:30 <lambdabot> Prelude.seq :: a -> b -> b
21:59:11 <joelr1> shapr: so you dont' remember how to configure the app base in hope, right?
22:01:18 <Cheery> liftM2 (,)
22:02:13 <joelr1> :t liftM2 (,)
22:02:15 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
22:02:29 <joelr1> liftM2 (:)
22:02:49 <lispy> joelr1: taht sounds like a bringert question
22:03:03 <joelr1> lispy: yes, yes, hoping to see him here soon
22:03:09 <joelr1> :t liftM2 (:)
22:03:11 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
22:09:40 <Sgeo> @fortune
22:09:41 <lambdabot> Peanut Blossoms
22:09:41 <lambdabot>  
22:09:41 <lambdabot> 4 cups sugar           16 tbsp. milk
22:09:41 <lambdabot> 4 cups brown sugar     4 tsp. vanilla
22:09:41 <lambdabot> 4 cups shortening      14 cups flour
22:09:43 <lambdabot> [7 @more lines]
22:09:47 <Sgeo> @fortune
22:09:47 <lambdabot> Death has been proven to be 99% fatal in laboratory rats.
22:10:12 <lispy> i'd like to see the p value on that statistic!
22:10:34 * lispy grumbles about death being significantly fatal
22:11:22 <skew> Hello #haskell.
22:11:33 <lispy> Hello #skew
22:11:40 <skew> Has anyone here built GHC HEAD recently?
22:11:48 * lispy runs and hides
22:13:02 <ChilliX> dibblego: re haskell course at UNSW, I will be teaching "Language-Based Software Safety" (COMP4181) next session.  It's a new essentially going to be about advanced type systems (ie, beyond plain Hindley-Milner) and (semi-)formal reasoning about functional programs.  The concrete programming language will of course be Haskell (or whatever you want to call the language  implemented by GHC ;)
22:13:18 <sorear> kc5tja: ping
22:13:33 <skew> ChilliX: how about Coq?
22:13:38 <lispy> ChilliX: cool
22:14:04 <ChilliX> skew: Coq? That's a prover assistant, not a programming language....
22:14:29 <dibblego> thanks ChilliX, a user with nick droberts was after that information
22:14:31 <skew> depends how hard you squint - and you can extract code anyway
22:14:49 <skew> Adam Chilipala seems to be writing some serious software
22:15:31 <sorear> I don't think we talk about him here, he has quite a history
22:15:36 <ChilliX> skew: Sure, you can generate code, and that's definitely a nice exercise for some hardcore formal methods hackers.
22:15:48 <Philippa> I wouldn't go so far as to say we don't talk about him
22:16:08 <Philippa> I don't think he's actually banned any more, either
22:16:12 <Heffalump> he just annoyed a few people and got banned by shapr
22:16:21 <skew> Now, there's nothing wrong with using a more practical language that takes a little more work to encode some properties
22:16:27 <Heffalump> (unfairly IMO)
22:16:39 <skew> Like Java ;)
22:17:05 <ChilliX> Hi Heffalump!
22:17:19 <ChilliX> Annoyed?  How?  Bad mouthing Haskell? ;)
22:17:55 <Philippa> being unpleasantly argumentative while going off on tangents and not acknowledging others' points, IIRC
22:18:29 <skew> I'm just a bit excitable because I've recently found that it tends to be quite easy to turn QC properties and equational reasoning into proofs in Coq - not that I know any other provers
22:18:42 <sorear> ChilliX: nickname "Smerdyakov", in case that clarifies
22:18:58 <ChilliX> sorear: haven't seem him around
22:19:02 <Heffalump> hi ChilliX, can't stop long, got to leave for work
22:19:08 <ChilliX> Phillippa: ah, ic - hi btw
22:19:09 <Heffalump> he hasn't been on here for months/years
22:19:12 <skew> this was ages and ages ago
22:19:40 <QtPlatypus> ChilliX: Has UNSW become haskell central?
22:19:49 <Philippa> years. I think it happened back before I started joining in explaining monads, let alone stopped again
22:19:53 <ChilliX> skew: sure QC properties are supposed to be formal properties, so they should surely be ok in Coq
22:19:54 <Philippa> 'lo ChilliX
22:20:15 <shapr> Heffalump: Driving off newbies is a good way to kill a community.
22:20:31 <skew> yeah, I've just been pleasantly surprised how easy it is to actually formalize them
22:20:47 <ChilliX> QtPlatypus: Well, our research group, PLS <http://www.cse.unsw.edu.au/~pls/> surely has some impact ;)
22:21:25 <Heffalump> he wasn't that bad, and you had nothing like a concensus for banning him
22:21:26 <ChilliX> Hey shapr!
22:21:29 * Heffalump --> work
22:21:34 <shapr> Heffalump: He was worse :-)
22:21:37 <shapr> hiya ChilliX
22:22:29 <shapr> Also, I tried running #haskell by consensus for a short while, but the community started to fall apart.
22:22:59 <dibblego> anarchy doesn't work in #haskell?
22:23:01 <shapr> I do agree that Smerdyakov is doing good stuff with Coq.
22:23:19 <shapr> But I still don't think he's a positive contribution to #haskell.
22:23:23 <Philippa> dibblego: consensus != anarchy
22:23:43 <ChilliX> skew: the way I see it, functional programming is a kind of bridge between formal methods (where Coq is) and more popular forms of software development
22:23:55 <Philippa> I think he might manage to be now
22:24:01 <Philippa> OTOH, I doubt he'd want to come back
22:24:33 <Philippa> and hey, I'm saying all this as someone he's argued is worthless
22:25:01 <ChilliX> skew: it is programming, but also math
22:25:02 <shapr> <shapr> I believe there is an obligation to say things that promote a community.
22:25:02 <shapr> *Smerdyakov* And I don't.
22:25:16 <ChilliX> (you might say that of all programming, but in FP it becomes tangible)
22:25:21 <shapr> That's the essence of the disagreement I have with Smerdyakov.
22:25:30 <lispy> Oh, you Smerdyakov...
22:25:38 <Philippa> shapr: that much isn't banning material, IMO. It's the avoiding things that do the opposite
22:25:44 <ChilliX> shapr: wow, you got the logs?!?
22:26:10 <Philippa> a lot of people log by default
22:26:22 <lispy> he's one of the reasons i didn't bother learning ocaml
22:26:26 <skew> ChilliX: I'm glad to see a class about language-based approaches in any form - and I think Haskell is about as good as it gets for being able to express things and run them nicely, and have libraries and stuff
22:26:28 <shapr> Yeah, Smerdyakov spent a lot of effort talking to other regulars in #haskell trying to get unbanned, and he did get unbanned.
22:26:29 <ChilliX> Philippa, yeah, but this seemed to be a while ago...
22:26:36 <Philippa> storage is cheap
22:26:43 <joelr1> ChilliX: hi manuel
22:26:45 <Philippa> especially when we're only talking about text
22:26:55 <Philippa> PM, btw
22:27:05 <ChilliX> Philippa: true
22:27:22 <ChilliX> joelr1: Hi!
22:27:36 <shapr> But he went back to his prevous manner, and after he drove off a few new people who were excited about learning Haskell until after they talked to Smerdyakov, I decided to ban him permanently.
22:28:20 <ChilliX> shapr: driving of newbies is very bad, I'd agree with that
22:28:48 <ChilliX> of = off
22:29:13 <shapr> At one point Smerdyakov said that I could not disallow him from #haskell because he is an active researcher. I told him that if #haskell were part of academia, I'd get paid to do what I do.
22:29:37 <shapr> He also posted a complaint about it on the HaWiki. I think it might still be there.
22:30:03 <shapr> He told me he'd mail the Simons about me denying him his rightful place or something, and I told him to go ahead.
22:30:09 <dmead> drama with programers? you don't say
22:30:33 <shapr> Smerdyakov made a lot of drama, and upset a bunch of regulars who never came back.
22:30:57 <shapr> He also has a reputation for that sort of behaviour on other channels.
22:31:06 <ChilliX> shapr: doesn't sound like we are missing much by not having him
22:31:10 * lispy believes it because of running into him on freenode
22:31:18 <skew> hmm, building GHC HEAD still seems to be failing (starting from 6.6)
22:31:30 <ChilliX> skew: don't get me started on building GHC
22:32:04 <ChilliX> I don't know how many hours I wasted the last 1-2 weeks working around the constantly changing bugs in the build system...
22:32:06 <shapr> ChilliX: That's my belief also. But Heffalump still thinks he was unfairly banned.
22:32:38 <shapr> 18:17:04 <eiz> #ocaml is a wasteland
22:32:38 <shapr> 18:17:37 <eiz> #ocaml is mainly a guy who tells people to use SML instead
22:32:38 <shapr> 18:17:46 <slava> Smerdyakov?
22:32:38 <shapr> 18:17:50 <eiz> Yes
22:32:42 <ChilliX> Hmm, Heffalump left, so he can't say why he thinks so.
22:32:53 <Philippa> I get the impression that most of that's on grounds you didn't explain adequately what he needed to stop doing
22:33:11 <shapr> I explained it to Smerdyakov thoroughly and often, over a period of several months.
22:33:18 <dmead> mmm mmm
22:33:19 <Philippa> OTOH, smerdyakov kept asking for a from-the-ground-up explanation...
22:33:35 <dmead> 8 hours and some pizza is nice after 3 day coding marathons
22:33:41 <Philippa> the sort that's impossible for the vast majority of people to actually give
22:33:55 <shapr> In the end, I realized I'd rather spend my time doing useful stuff instead of dealing with a huge timesink like that.
22:34:09 <skew> dmead: 8 hours?
22:34:22 <dmead> of sleep
22:34:33 <emu> i went to school with smerdy, i think shapr is justified enough
22:34:36 <shapr> heh
22:34:50 <skew> dmead: that's pretty standard after a 1-day coding marathon.
22:34:59 <shapr> emu: He was at Haskell Workshop 2007, I tried to meet him to see if maybe he's only that way on the wire.
22:35:16 <emu> he's not a t errible person, just difficult
22:35:35 <Philippa> aggressively so, IME
22:35:39 <skew> dmead: reminds me of college :) can't keep it up these days - I must be getting old.
22:36:27 <shapr> I realize that some difficult people have brilliant ideas, but it's not worth my time dealing with them to extract those ideas.
22:36:31 <dmead> yea i won't miss that part
22:36:36 <dmead> i'm graduating saturday :)
22:36:45 <shapr> congraduations dmead!
22:36:48 <Philippa> cool
22:36:55 <dmead> thanks :)
22:37:07 <skew> excellent. What now?
22:37:23 <dmead> job? grad school?
22:37:29 <dmead> backpack through europe?
22:37:37 <dmead> :)
22:37:44 <skew> sounds good.
22:38:32 <shapr> dmead: Got a Haskell job lined up?
22:38:40 <dmead> oh if only
22:38:44 <dmead> that would be sweet
22:38:53 <skew> ChilliX: Any news about data parallel haskell?
22:39:31 <ChilliX> skew: Well, version 0.1 of the array library is out there for everybody to play with
22:39:46 <ChilliX> skew: Now we are working on the vectorising program transformation
22:39:46 <Cheery> @hoogle finally
22:39:47 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
22:39:48 <lispy> dmead: way to go
22:40:24 <ChilliX> However, that's no yet in any shape that's useful to anybody
22:40:33 <shapr> ChilliX: Yay 0.1 !
22:40:44 <dmead> lispy, thanks thanks
22:41:56 <joelr1> i'm using rcirc for a change
22:41:57 <skew> ChilliX: is that the first release? I've been checking for new papers every week or two - it's exciting work.
22:42:28 <ChilliX> One of the big complications is that we don't want to introduce a new "way" into GHC, like profiling where you ahve to compile everything with profiling enabled
22:42:39 <ChilliX> Instead you should be able to just vectorise individual modules
22:43:09 <ChilliX> But the interaction between vectorised and non-vectorised code is quite  complicated to get right
22:43:37 <skew> oh? I figured there would just be a generic vectorized-map thing for lifting unvectorized code
22:43:56 <skew> Then add a rewrite rule for mapP f to the vectorized f, if you made one
22:44:03 <ChilliX> skew: re 0.1, it was the first version in the darcs repo (packages/ndp) that we gave a version number, as it has enough functionality to be useful for small apps
22:44:23 <ChilliX> skew: yes, but data types are complicated
22:45:04 <Sgeo> help me!
22:45:07 <Sgeo> @localtime Sgeo
22:45:09 <lambdabot> Local time for Sgeo is Fri May 11 01:44:28
22:45:21 <sjanssen> Sgeo: state your problem
22:45:28 <ChilliX> To get high-performance arrays can't just be polymorphic, but they must adapt their representation in dependence on the type of the elements
22:45:35 * Sgeo should have been sleeping a while ago
22:45:55 <skew> ChilliX: and that's hard with abstract types and separate compilation and so on, right?
22:45:57 <ChilliX> That's not too bad if the same representation change is made in all code of  a program
22:46:23 <ChilliX> If not, you need to convert back and forth between representation and that in the presence of type parameters, classes, existentials, and what not
22:47:05 <ChilliX> skew: not just abstract types
22:47:35 <ChilliX> As an example, a [:(Int, Bool):] in vectorised code is actually a ([:Int:], [:Bool:])
22:47:51 <ChilliX> Now if you pass values of that type between vect and unvect code you need to convert
22:47:53 <shapr> Sgeo: Yeah, tell us the problem!
22:47:56 <skew> ChilliX: you're trying to do the translation with associated types
22:48:15 <skew> ?
22:48:19 <ChilliX> skew: That's actually the reason we invented associated types in the first place ;)
22:48:52 <Sgeo> shapr, the fact that I'm not sleeping
22:49:03 <sjanssen> Sgeo: go to sleep!
22:49:56 <ChilliX> skew: well, we found that we need something like associated types and then realised that they are more generally useful
22:50:29 <skew> ChilliX: Can you handle all the tricky stuff with them? I can see existentials and so on could be tricky, but I don't see how that has anything to do with avoiding an extra way
22:50:43 <ChilliX> How do they call this, these days..."use driven research" ;)
22:51:12 <sjanssen> ChilliX: so is a "data instance" automatically derived for every data type?
22:51:13 <Philippa> research-by-need?
22:51:22 <sjanssen> or is there an overlapping catch-all?
22:51:25 <Philippa> (or if you're less lucky, research-by-name)
22:51:32 <ChilliX> skew: extra way means everything compiled in a special manner and no linking of code compiled one way with code compiled another way
22:51:45 <ChilliX> eg, for profiling, you need to recompile all your libs with profiling, too
22:52:00 <ChilliX> This is what we don't want.
22:52:46 <droberts> ChilliX: any haskell courses planned at UNSW in near future?
22:52:48 <ChilliX> re, what have assoc types to do with this, well assoc types are used to do the representation transformation of arrays and member functions of the same class do the conversion
22:52:56 <lispy> ChilliX: if you figure out this vectorization can you apply the same trick to profiling! ;)
22:52:57 <ChilliX> droberts: yes
22:53:09 <droberts> basic or adv?
22:53:10 <Cheery> hmm, I'm feeling like I should rewrite my code
22:54:00 <Cheery> things are getting too complicated and next I'd end up writing just too strict abstractions
22:54:23 <ChilliX> re haskell course at UNSW, I will be teaching "Language-Based Software Safety" (COMP4181) next session.  It's a new essentially going to be about advanced type systems (ie, beyond plain Hindley-Milner) and (semi-)formal reasoning about functional programs.  The concrete programming language will of course be Haskell (or whatever you want to call the language  implemented by GHC ;)
22:54:35 <ChilliX> ^^^copy of what I wrote above
22:54:39 <ChilliX> adv
22:55:32 <ChilliX> let me find the handbook entry
22:55:43 <droberts> ok, i'm in maths faculty. that might be too 'computer sciency' for my taste :/
22:56:01 <ChilliX> http://www.handbook.unsw.edu.au/undergraduate/courses/2007/COMP4181.html
22:56:03 <lambdabot> Title: UNSW Handbook Course - Language-based Software Safety - COMP4181, http://tinyurl.com/2ez5ba
22:57:07 <ChilliX> Well, its goind go te mostly type systems-related and formal reasoning (which is logic)
22:57:50 <ChilliX> I'll msg you the tentatve schedule
22:57:56 <skew> ChilliX: I'm just missing how avoiding a new way increases your troubles - is there anything deep, or is just annoying issues like when and where to generate the instances saying how to vectorize a type from a module not built for vectorization
22:59:11 <droberts> great, thanks.
22:59:31 <skew> well, I just deleted the line the GHC build was failing on. Let's hope this works :)
23:00:54 <ChilliX> skew: It's not just the where and when, but often enough the how
23:03:04 <ChilliX> skew: it's esp type parameters that make things hard, as you need to have cconversion parametrised by conversions (like instances with a context)
23:04:55 <joelr1> ChilliX: where are you guys with enabling the vectorization with sugared syntax?
23:04:56 <skew> ChilliX: You can have different conversions of types, or is this just about supplying the conversion at all?
23:05:03 <ClaudiusMaximus> is there a neater way to rewrite \a b -> (a `min` b, a `max` b) ?
23:05:22 <mauke> @pl \a b -> (a `min` b, a `max` b)
23:05:23 <lambdabot> ap (ap . ((,) .) . min) max
23:05:23 <joelr1> ChilliX: i think the performance is still only available with the raw syntax, right?
23:05:41 <skew> joelr1: well, he's been explaining the reasons vectorization is tricky to implement for quite a while now :)
23:05:54 <ChilliX> joelr1: the syntax is not the problem (the desugarer already handles that for a while), its the fact of allowing nested arrays
23:06:05 <ClaudiusMaximus> mauke: i was think more of something like: min `op` max  for some op defined somewhere
23:06:07 <joelr1> ChilliX: i see
23:06:22 <ChilliX> if youw rite that with nested funny brackets (ie, [: . :]) or with mapP (mapP ...) doesn't make a difference
23:06:33 <ChilliX> vectorisation works on Core, so all sugar is gone by then
23:06:47 <joelr1> ChilliX: right
23:07:24 <ChilliX> skew: both, you can have differeent conversions and supplying the conversion in some cases
23:08:14 <skew> ChilliX: about the ways, it seems like you ought to be able to just always throw the type definition into the .hi, and then you're in about the same position whether the modules you use were built for vectorization or not.
23:08:17 <ClaudiusMaximus> @hoogle (a->b->c) -> (a->b->d) -> (a,b) -> (c,d)
23:08:21 <lambdabot> No matches, try a more general search
23:09:02 <ChilliX> skew: yes, *if* a module was compiler with vectorisation and hence has a vectorised definition, that is right
23:09:41 <ChilliX> but what if somebody uses a vectorised module from a vanilla one or uses a vanilla module (like GHC.Prim in the extreme case) in a vectorised one
23:10:17 <ChilliX> we have to deal with stuff like foreign imported functions and runtime primitives, which we obviously can never vectorise
23:10:47 <ChilliX> (the foreign imported functions themselves are not so hard, if they are pure)
23:14:34 <skew> darn, looks like I needed that line from Linker.c after all
23:14:56 <ChilliX> skew: What platform are you building on?
23:15:03 <skew> "unknown symbol `getStackFramezh_fast'" ... "unable to load package `base'"
23:15:33 <skew> debian, "2.6.18-4-686-bigmem" Core 2, if that makes a difference
23:15:35 <ChilliX> Hmm, did you build from a clean tree>
23:15:42 <skew> I ran make clean
23:15:58 <ChilliX> and it was a while since you darcs pulled last?
23:16:06 <skew> I did that just before I built
23:16:39 <skew> I was getting some unknown symbol from "SymX(getStackFramezh_fast)" in Linker.c
23:16:56 <skew> unknown symbol error, that is.
23:16:56 <ChilliX> no, I mean before that pull right now, when was the last time?
23:18:37 <lispy> dcoutts++ -- for Language.C
23:18:41 <ChilliX> The reason I am asking is that I vaguely remember that I had similar problems with a tree and make clean just didn't make it clean enough
23:19:55 <skew> I probably last pulled over the weekend
23:20:50 <ChilliX> I could build on Monday...
23:21:06 <skew> I got 44 patches this time, and I'm trying to look back through darcs changes
23:21:18 <skew> for some reason piping the output doesn't seem entirely reliable
23:21:25 <skew> I suppose I could start with a fresh tree
23:21:29 <ChilliX>  I'd try just getting a clean tree
23:21:34 <ChilliX> yes, exactly
23:22:07 <ChilliX> it's annoying, but esp with the recent build tree changes, things (including cleaning) don't always seem to work out
23:26:05 <ChilliX> I am just not pulling patches until the build system is a bit more stable and cross my fingers that my patches don't conflict....
23:26:54 <skew> that's just not right
23:27:22 <ChilliX> not it isn't, but I was not joking when I said I wasted a couple of hours just on building GHC the last two weeks
23:27:30 <ChilliX> I'd rather do something more productive
23:27:56 <skew> like explain to me why dph is hard? ;)
23:28:05 <ChilliX> hehe
23:28:45 <ChilliX> Well, actually fix how SPJ broke all of indexed data types in one go a few days ago ;)
23:29:22 <skew> I'm happy to chat, especially if you want to talk at somebody about it, but I wouldn
23:29:40 <skew> I wouldn't mind seeing it when it's all implemented and published
23:30:22 <ChilliX> :)
23:31:02 <skew> I think I ought to explain how it seems like it might work out.
23:32:11 <ChilliX> I don't quite follow
23:34:26 <skew> I'm thinking you have functions, and functions can get a vectorized version (you only need one level, say the papers). The vectorized version is accessible through a rewrite rule, that turns something like mapP f into vectorized f. Flattening and vectorizing data types is done with an associated type, maybe some HList-ish trickery for shuffling sets of arrays. Among other things, the class tells you how to map a function expecting 
23:37:16 <ChilliX> expecting?
23:37:48 <skew> say [: (a,b) :] is represented by ([:a:],[:b:])
23:38:13 <skew> and you have some f :: (a,b) -> c
23:38:24 <ChilliX> (your sentence was cut off after the word "expecting" in my irc client)
23:38:40 <skew>  the unflattened
23:38:40 <skew>               items over the array, so the plain mapP f works (and goes
23:38:40 <skew>               nowhere because of no rewrite rule) if f is from a
23:38:40 <skew>               non-vectorized module. Finally, throw in a bit of
23:38:42 <skew>               overlapping instances to give the translation a base case
23:38:44 <skew>               that uses some horrible representation like a boxed array
23:38:47 <skew>               of the straight type
23:39:11 <skew> does that have messy linebreaks?
23:39:23 <ChilliX> yeah, but that's ok
23:40:11 <hpaste>  skew pasted "dph scribbling" at http://hpaste.org/1791
23:40:13 <ChilliX> skew: The problem with trying to use rewrite rules is that it doesn't work for the higher-order cases (and that means it doesn't work for overloaded functions, as we are on Core and all type classes have been turned into dictionaries)
23:40:55 <ChilliX> see http://www.cse.unsw.edu.au/~chak/papers/LCK06.html
23:40:56 <lambdabot> Title: Research Papers of Manuel Chakravarty
23:41:11 <ChilliX> eg,
23:41:23 <skew> ah, that would be a problem. Still, seems like higher-order flattening is rather exotic
23:41:33 <ChilliX> foo f a = sumP (mapP f a)
23:41:41 <ChilliX> yeah, it is!
23:41:57 <ChilliX> well, do you mean exotic as in rare
23:42:05 <ChilliX> or as in hard to compile
23:42:08 <ChilliX> its not rare at all
23:42:37 <skew> Well, I don't see where I would use it - and NESL seemed to get along ok.
23:42:51 <ChilliX> the above foo :: (Num b) => (a -> b) -> [:a:] -> b
23:43:05 <ChilliX> nesl didn't have type classes!
23:43:11 <DRMacIver> Morning
23:43:22 <ChilliX> foo is a higher-order function
23:43:36 <ChilliX> In Haskell, everything involving Num is higher-order
23:43:49 <ChilliX> We can't escape that
23:44:05 <ChilliX> It's a fundamentally more complicated situation than Nesl
23:44:07 <skew> how do you get functions to have similar closures?
23:44:16 <ChilliX> or take:  mapP (+1) [:1,2,3:]
23:44:48 <dblhelix> does anyone know if there is a raw implementation of the stg language and the stg machine available, i.e., one that's not embedded in ghc?
23:44:49 <ChilliX> ^^ that's dead simple and fill of higher-order
23:45:05 <ChilliX> fill = full
23:45:17 <skew> There is seems you might as well just make a closure expecting the other array, rather than actually pushing in the +.
23:45:23 <ChilliX> skew: What do you mean by similar closures?
23:45:28 <ClaudiusMaximus> > (uncurry min &&& uncurry max) (100,10)   -- still ugly
23:45:30 <lambdabot>  (10,100)
23:45:52 <ChilliX> skew: true in this case, but the rewrite rule wouldn't know
23:46:04 <skew> you are turning an array of functions into an array of closures?
23:46:15 <ChilliX> skew: and you can build slightly more complicated examples where that doesn't work anymore
23:46:23 <ChilliX> skew: yes!
23:47:44 <skew> so it seems you need to have closures of the same type
23:47:49 <Cheery> @hoogle finally
23:47:50 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
23:47:56 <sjanssen> ClaudiusMaximus: what is so bad about it?  It is quite succinct, I think
23:48:15 <ChilliX> skew: sure, when the argument and result type are the same, the type of the closure is, too
23:48:21 <skew> e.g. in let c = 1; z = 2; [: id, (1+), (\x -> c + z*x) :]
23:48:39 <ChilliX> the type for closure is the following
23:48:56 <skew> wait, I just got to section 4
23:48:59 <ClaudiusMaximus> sjanssen: i suppose so
23:49:18 <ChilliX> data a :-> b = forall e. (:$) (e -> a -> b) e
23:50:03 <sjanssen> > (\(x, y) -> (min x y, max x y)) (100, 10) -- is also nice enough
23:50:05 <lambdabot>  (10,100)
23:50:27 <Cheery> does finally prevent the use of ^C and ^D for stopping?
23:51:01 <ChilliX> The closure conversion underlying the vectorisation transformation, we have mostly implemented already, it is described at http://hackage.haskell.org/trac/ghc/wiki/DataParallel/ClosureConversion/ClassLess
23:51:12 <lambdabot> Title: DataParallel/ClosureConversion/ClassLess - GHC - Trac, http://tinyurl.com/25eg5z
23:58:47 <Cheery> @hoogle threadDelay
23:58:48 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
