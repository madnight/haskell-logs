00:00:20 <Korollary> It looks like readFile is what you need.
00:00:32 <Korollary> @type Data.ByteString.readFile
00:00:34 <lambdabot> FilePath -> IO Data.ByteString.Base.ByteString
00:01:12 <Korollary> I don't see a version that works on a handle, though.
00:02:55 <fuzan> yah. i'm writing a simple little mpd-thingy. i send a simple string to it and receive a response.
00:03:11 <fuzan> i dont think there's any sort of header info, but let me check again
00:05:39 <fuzan> yah.none :\
00:07:33 <hpaste>  fuzan pasted "simple socket io?" at http://hpaste.org/1637
00:08:04 <fuzan> here's what I was trying to do earlier , but I can't seem to get catch working correctly along with my loopPrint
00:10:20 <hpaste>  (anonymous) annotated "simple socket io?" with "doesn't terminate as expected." at http://hpaste.org/1637#a1
00:32:58 <_frederik_> sorear: thanks yes that was what i meant
00:35:00 <vagif> hdbc question. query returns all values as SqlString, but sql statemnt contains 2 fields, integer and varchar. How to get integers instead od strings ?
00:41:20 <dons> http://programming.reddit.com/info/1mcu8/details
00:41:23 <lambdabot> Title: Roll your own window manager: Haskell and QuickCheck (reddit.com)
00:41:31 <dons> there you go guys. write your own xmonad :-)
00:42:46 <matthew-_> so, are there any good discrete event simulators for Haskell, or is it roll your own?
00:43:03 <dons> don't people use arrows to write these things?
00:43:11 <dons> probably roll your own, yeah.
00:45:13 <dons> hehe, this rocks. i'm getting one. http://www.spreadshirt.com/shop.php?article_id=2125373&view_id=181
00:45:17 <lambdabot> Title: xmonad inverse:xmonad is a minimalist tiling window manager for X, written in Ha ..., http://tinyurl.com/2exl9u
00:46:53 <notsmack> dons: looks like a great post;  thanks for sharing
00:48:18 <fuzan> what is the optimal method for reading ALL content from a handle and return
00:48:35 <matthew-_> fantastic - spreadshirt do string thongs. "Xmonad styled lingerie"
00:48:43 <dons> heh
00:48:52 <dons> fuzan: readingit strictly, you mean?
00:49:11 <dons> fuzan: the 'optimal' (:) method would be to use Data.ByteString.hGetContents, I think.
00:49:12 <fuzan> sequence_ (repeat ( dosomething )) `catch` (const $ return())
00:49:34 <dons> otherwise, System.IO.hGetContents >>= \s -> last s `seq` return s
00:49:38 <fuzan> dons: well, hGetContents doesn't terminate, it just waits for more input.
00:49:48 <dons> it stops once you get eof.
00:50:09 <fuzan> what about a network socket that doesn't use eof?
00:50:25 <dons> then you read packets, either bytewise or chunkwise
00:50:39 <dons> getChar and friends. or hGetN (in bytestring)
00:50:49 <eumenides> has anyone used ftphs before? what kind of filepath do i pass to newHVFSChroot? anything but "/" seems to fail
00:50:49 <fuzan> i attempted bytewise, yet i'm not sure hwo to use catch correctly.
00:52:04 <fuzan> let readLoop h = sequence_ (repeat (B.hGet 1 h) >>= B.putStr) in readLoop mpdsock
00:52:08 <fuzan> something like that
00:52:09 <fuzan> err
00:52:11 <fuzan> left out the catch :\
00:52:20 <fuzan> let readLoop h = sequence_ (repeat (B.hGet 1 h) >>= B.putStr) in readLoop mpdsock `catch` (const $ return())
00:54:59 <dons> notsmack: cheers. yeah, its got I think the first public use of QuickCheck 2 :-)
00:55:24 <dons> but should be interesting to anyone looking at writing data structures, or using QC for more-complex systems,  I hope
00:56:51 <ski> > tell ""
00:56:52 <lambdabot>   add an instance declaration for (Show (m ()))
00:57:00 <ski> > tell "" :: Writer String ()
00:57:01 <lambdabot>        add an instance declaration for (Show (Writer String ()))
00:57:29 <dons> run*
00:58:25 <ski> yes .. i was just looking for what 'show' if any, it had
01:04:56 <ski> @type Writer
01:04:58 <lambdabot> forall a w. (a, w) -> Writer w a
01:04:59 <ski> @type runWriter
01:05:02 <lambdabot> forall w a. Writer w a -> (a, w)
01:05:03 <ski> @hoogle Writer
01:05:04 <lambdabot> Control.Monad.Writer :: module
01:05:05 <lambdabot> Control.Monad.Writer.Writer :: (a, w -> Writer w a)
01:05:05 <lambdabot> Control.Monad.Writer.Writer :: newtype Writer w a
01:05:06 <ski> @hoogle runWriter
01:05:07 <lambdabot> Control.Monad.Writer.runWriter :: (Writer w a -> a, w)
01:05:08 <lambdabot> Control.Monad.Writer.runWriterT :: WriterT w m a -> m (a, w)
01:05:15 <ski> was 'Writer' changed recently ?
01:05:43 <ski> or ..
01:06:09 <ski> ah, it must be strange parenthesizing
01:07:39 <ski> @tell ndm why's the parens like they are in e.g. '@hoogle Writer' and '@hoogle runWriter' (in channel lambdabot) ?
01:07:39 <lambdabot> Consider it noted.
01:09:46 <ski> instance (Show w,Show a) => Show (Writer w a)
01:09:48 <ski>   where
01:10:39 <ski>   shows (Writer (a,w)) = showString "tell " . shows w . showString " >> return " . shows a
01:11:06 <ski> whaddya think of this instance ?
01:12:37 <eumenides> @pl \k -> gets keymap >>= Map.findWithDefault (return ()) k
01:12:37 <_magus_> I'm having some problems whipping a cabal into shape :( how do I stick a library and an executable using that library into the same cabal file?
01:12:37 <lambdabot> (gets keymap >>=) . (Map .) . findWithDefault return
01:12:42 <ski> a bit like
01:12:43 <ski> > array (0,3) [(i,i*i) | i <- [0..3]]
01:12:45 <lambdabot>  array (0,3) [(0,0),(1,1),(2,4),(3,9)]
01:12:47 <ski> i guess
01:12:53 <eumenides> hm
01:12:56 <eumenides> @pl \k -> gets keymap >>= findWithDefault (return ()) k
01:12:57 <lambdabot> (gets keymap >>=) . findWithDefault return
01:13:03 <_magus_> when linking the executable I get the message that the library can't be found :(
01:27:37 <Cheery> I'm wondering, why yampa is this messy?
01:28:27 <Cheery> it has a good foundation but it just doesn't use it. :/
02:41:50 <kolmodin> ?users
02:41:51 <lambdabot> Maximum users seen in #haskell: 335, currently: 304 (90.7%), active: 24 (7.9%)
02:42:10 <ski> @seen
02:42:31 <Wild_Cat> that bot really does everything. Is the source available somewhere?
02:42:38 * ski wonders why lambdabot responds in private ..
02:42:40 <ski> @source
02:42:41 <lambdabot>  not available
02:42:46 <ski> er
02:42:48 <ski> @version
02:42:48 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
02:42:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:42:49 <ski> i meant
02:43:19 <Wild_Cat> I'll have to take a look. If only to see how Haskell handles IRC and stuff.
02:43:41 <ski> @where lambdabot
02:43:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:44:20 <psykotic> dons, great work on the wm article
02:44:27 <Wild_Cat> cheers.
02:44:33 <Wild_Cat> anyway, gotta go. See you around.
02:45:02 <dcoutts> fuzan: did you find the non-blocking ByteString read function in the end?
02:49:49 <dons> psykotic: cheers.
02:57:14 <foxy-om_> what's the function to slurp in a textfile all at once?
02:57:56 <dcoutts> dons: very nice article, this should have gone in TMR :-)
02:58:59 <dons> yeah, timing timing.
02:59:18 <dons> didn't have a chance to do it before TMR deadline, due to travel
02:59:44 <dcoutts> yeah, I know
03:00:05 <dcoutts> perhaps it can go into the next edition
03:00:56 <dcoutts> dons: if you decide to extract a TMR article from it I'll send you the typos :-)
03:01:19 * dcoutts counts only two so far
03:01:37 <foxy-om_> does Parsec support ByteStrings?
03:03:11 <dcoutts> foxy-om_: not yet
03:03:20 <Cheery> @pl \dt a k -> f dt a (\f' b -> g dt b (\g' c -> k (f' >>> g') c))
03:03:21 <lambdabot> ap (flip . ((.) .) . f) ((. ((. (>>>)) . (.))) . (.) . flip . g)
03:03:28 <Cheery> hah
03:03:54 <Cheery> @help
03:03:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:04:03 <Cheery> @list
03:04:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:04:50 <Cheery> @unpl ap (flip . ((.) .) . f) ((. ((. (>>>)) . (.))) . (.) . flip . g)
03:04:51 <lambdabot> ((\ ac b c h -> f ac c (b h)) >>= \ v -> (\ ai ay q t -> g ai t (\ m -> ay (q >>> m))) >>= \ u -> return (v u))
03:05:10 <Cheery> !!!
03:05:32 <dons> dcoutts: yeah, send me the typos anyway
03:05:49 <ski> Cheery : just rename a few variables, and you're ready to go !
03:11:24 <nomeata> @unpl id
03:11:25 <lambdabot> (\ a -> a)
03:13:32 <ski> @unpl liftM
03:13:33 <lambdabot> liftM
03:14:55 <ozone> @elite oh really!
03:14:55 <lambdabot> Oh REA1Ly!
03:16:33 <ski> o'reilly ?
03:17:25 <dcoutts> dons: forAll positive $ \n ->
03:18:33 <dcoutts> dons: this really simple change can make many many more useful test cases, so instead of filtering , n >= 0 ==>  we just generate positive ones
03:19:11 <dcoutts> of course as you say you can extend that into generating exclusively useful test cases, but that's hard and this is really really easy
03:19:52 <dcoutts> forAll arbitrary $ \n -> ...  vs forAll positive $ \n -> ...
03:21:06 <dons> dcoutts: ah yes.
03:21:33 <dcoutts> dons: does QC2 have useful generators like this? positive powerOfTwo etc ?
03:21:38 * dcoutts thinks it should do
03:22:02 <dons>   , NonEmptyList(..)
03:22:03 <dons>   , Positive
03:22:03 <dons>   , NonZero(..)
03:22:05 <dons> maybe?
03:22:14 <dons> not sure how to use those yet.
03:22:15 <dcoutts> ah newtype wrappers
03:22:30 <dons> yeah,
03:22:32 <dcoutts> dons: I wrote QC instructions for my students yesterday :-)
03:22:33 <ozone> @protontorpedo moof
03:22:34 <lambdabot> what makes haskell more fun than say clisp?
03:22:38 <dons> instance (Num a, Ord a, Arbitrary a) => Arbitrary (NonZero a) where
03:22:38 <dons>   arbitrary = fmap NonZero $ arbitrary `suchThat` (/= 0)
03:22:52 <ozone> @yhjulwwiefzojcbxybbruweejw moof
03:22:53 <lambdabot> Just 'J'
03:23:02 <ozone> very odd
03:24:47 <dcoutts> dons: they're doing simulations of digital circuits like adders etc, so it's very easy to specify. They were previously asked to do manual testing, so I've written some properties and a blurb about how manual testing is boring and inefective but testing from a formal spec is fun and effective.
03:25:09 <dcoutts> and I force them to look at the property code
03:25:31 <dcoutts> so hopefully they'll spot how easy it is and how it corresponds to the mathematical spec
03:25:47 <dons> nice. :-)
03:25:51 <dcoutts> force, as in they have to uncomment each property when they want to use it
03:26:08 <dons> hhe
03:27:03 <matthew-_> ok, so I have a type Foo a. I want to write two instances of Show (Foo a), one where (Show a) => and the other when not. How do I do this?
03:27:25 <ski> no
03:27:41 <ski> you can't use both instances in same program
03:28:03 <ski> you can use two isomorphic types, however (e.g. with 'newtype')
03:28:21 <matthew-_> right.
03:40:19 <dolio> dons++ Quality article.
03:40:31 <fasta>  :t keys_and_edges keys_and_edges :: STRef s (Tree s IndexedItem) -> DirectionToChild -> ST s ([Int], [EdgeType]) Why can't I do (\t -> runST (keys_and_edges t  None))? I get the "inferred type" is less polymorphic than expected.
03:43:54 <dcoutts> dons: hmm, interesting SML example
03:43:59 <dolio> fasta: My understanding of ST is shaky, but I think the problem is that you're passing in an external STRef.
03:44:34 <dons> dcoutts: nice code, eh?
03:44:41 <dons> dolio: cheers
03:45:01 <dcoutts> dons: yeah, better than ghc :-), we need to give it to JaffaCak1 as an example :-)
03:45:09 <dcoutts> http://mlton.org/pipermail/mlton-user/2007-April/001091.html
03:45:10 <lambdabot> Title: [MLton-user] Stream Fusion
03:46:04 <dcoutts> yes, much more tasty
03:47:14 <dolio> fasta: Any STRef used in S, for 'runST S' has to originate from within S, while in '(\t -> runST (keys_and_edges t None))', t doesn't.
03:47:17 <dcoutts> dons: this is really very nice actually
03:47:50 <dolio> At least, that's a first guess.
03:48:02 <ski> that's it
03:48:07 <fasta> dolio: yes
03:50:02 <dcoutts> dons: interesting comment about map f s1 ++ s2 holding onto f for too long, I'd have to think about that.
03:50:15 <psykotic> dons: you should tell spj about the wm article, for his oscon presentation.
03:50:27 <ski> oscon ?
03:51:08 <dcoutts> dons: and of course they don't have rules so have to write directly in terms of the stream functions rather than converting from lists as we do.
03:51:11 <sphynx> dmwit, hi!
03:51:39 <dmwit> heya, sphynx
03:52:18 <sphynx> dmwit, could you please point me to some keywords and places for searching papers about that problem we talked with you (defining types of exressions)?
03:53:31 <dmwit> It's probably not a bad idea to start at Wikipedia's page for type inference.
03:53:40 <dmwit> http://en.wikipedia.org/wiki/Type_inference
03:53:41 <lambdabot> Title: Type inference - Wikipedia, the free encyclopedia
03:54:06 <sphynx> dmwit, Oh, maybe lambda-the-ultimate.org will be good too?
03:54:33 <dmwit> Definitely, the quality of comments/papers at LtU is always very high.
03:55:46 <sphynx> dmwit, ok, I will read this Wikipedia article first, Thanks!
03:55:51 <dcoutts> JaffaCake: ah I see you saw my rant about runInteractiveProcess and filed a bug. Thanks! :-)
03:55:55 <dcoutts> (of course a trac bug would have been a better place for me to put that rant in the first place)
03:56:17 <JaffaCake> right, just wanted to make sure I didn't forget
03:56:34 <JaffaCake> you're not the first to complain that runInteractiveProcess didn't do what you want
03:56:57 <dcoutts> aye, though I've never been entirely clear about what the right function is
03:57:24 <JaffaCake> I haven't given it a lot of thought either
03:58:35 <dcoutts> I think it was CosmicRay who was complaining before, perhaps he has some ideas, or we can ask him to come up with some
04:00:57 <JaffaCake> you want to pass in a 3-valued thing for each handle: either use the parent's Handle, create a pipe, or use an existing Handle
04:01:25 <JaffaCake> but then the return type would be messy, you'd have to return 3 Maybe Handles for the pipes
04:02:11 <ski> 'Either3' ?
04:02:30 <JaffaCake> ski: I think I'd make a new datatype
04:02:51 <ski> @hoogle Either3
04:02:52 <lambdabot> No matches found
04:05:08 <mauke> oleg++
04:05:36 <ski> oleg?
04:05:49 <mauke> I <3 oleg
04:05:55 <mauke> @where oleg
04:05:56 <lambdabot> I know nothing about oleg.
04:06:00 <mauke> :(
04:06:31 <mauke> http://okmij.org/ftp/Haskell/
04:06:32 <lambdabot> Title: Haskell Programming: Miscellanea
04:06:57 <ski> @where oleg http://okmij.org/ftp/
04:06:58 <lambdabot> I know nothing about oleg.
04:06:59 <ski> @where+ oleg http://okmij.org/ftp/
04:07:00 <lambdabot> Done.
04:09:52 <Igloo> JaffaCake: You could always return the Handle used, couldn't you?
04:09:53 <dcoutts> JaffaCake: right, it looks a bit messy.
04:10:43 <dcoutts> Igloo: ah, your own stdin for example if you inherit
04:10:51 <Igloo> Yup
04:10:59 <JaffaCake> Igloo: true, except it's still a bit messy: in the case where you passed a Handle in, the handle is now closed
04:11:03 <dcoutts> Igloo: but don't the passed in handles get closed
04:11:16 <Igloo> Ah
04:11:37 <quicksilver> there ought to be an option to not close them
04:11:40 <quicksilver> that is, to dup them first
04:52:26 <araujo> morning
05:02:15 <fasta> Did somebody wrote a library to implement position based algorithms easier in Haskell?
05:02:57 <fasta> write*
05:05:45 <SamB_XP> what kind of position?
05:07:18 <fasta> SamB_XP: position in memory
05:07:30 <fasta> SamB_XP: STRefs are not fun to use
05:07:38 <SamB_XP> try IORefs ;-)
05:08:13 <dcoutts> fasta: what do you mean? pointer-based algorithms?
05:08:21 <fasta> dcoutts: yes
05:08:50 <fasta> dcoutts: I can't use a zipper for this application.
05:08:52 <dcoutts> fasta: and you really need mutable ones I suppose
05:08:54 <dcoutts> right
05:09:33 <dcoutts> fasta: and you can't use something like and array or finite map?
05:09:48 <fasta> dcoutts: it'
05:09:52 <fasta> dcoutts: s a tree
05:09:55 <SamB_XP> fasta: what do you need the pointers for?
05:12:46 <fasta> SamB_XP: Hmm, well, I might be able to do it with a zipper, but that would be the first time I actually use a zipper and it might only complicate things.
05:13:10 * SamB_XP wonders how fasta keeps his fly closed
05:13:34 <fasta> SamB_XP: I need to keep track of two "next insert positions"
05:14:14 <SamB_XP> *two*!
05:14:15 <psykotic> fasta: do they move around incrementally?
05:14:15 * SamB_XP still doesn't know how ZipperFS works
05:14:27 <fasta> SamB_XP: I don't know how ZipperFS works, but I understand The Zipper.
05:15:00 <Cheery> @hoogle (t -> t) -> t
05:15:05 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
05:15:05 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
05:15:05 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
05:15:15 <fasta> Please assume I don't want to use a zipper.
05:16:30 <psykotic> fasta: what was that, you say you really really want to use zippers? :)
05:17:53 <Cheery> why fix is in such weird place? Shouldn't it be in prelude?
05:18:54 <SamB_XP> Cheery: don't know!
05:18:56 <foxy-om_> @type (^)
05:18:58 <SamB_XP> ask libraries@?
05:18:59 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:19:14 <foxy-om_> @type (**)
05:19:16 <lambdabot> forall a. (Floating a) => a -> a -> a
05:21:01 <matthew-_> multiparameter class variables: do they decompose the type params of another type?
05:21:24 <SamB_XP> ???
05:21:39 <matthew-_> ikegami--: class MyClass a b where... data Foo t = C1...|C2... etc. instance MyClass Foo s where ...
05:21:51 <matthew-_> right, well done bitchx...
05:21:58 <matthew-_> eg. class MyClass a b where... data Foo t = C1...|C2... etc. instance MyClass Foo s where ...
05:22:16 <matthew-_> is the s there at the end, bound to the t and the b ?
05:22:52 <Saizan> is bound to the b but not to automatically to the t
05:23:24 <Saizan> in fact e.g. instance MonadState (State s) s where ...
05:23:36 <SamB_XP> matthew-_: there is no t!
05:24:04 <matthew-_> Saizan: that example is just what I was after.
05:24:07 <SamB_XP> which is why we can make funny faces in it using the powers of our minds
05:25:40 <Saizan> mmh i always misremember the order of the types in the Monad* classes
05:25:57 <foxy-om_> @hoogle sort
05:25:57 <lambdabot> List.sort :: Ord a => [a] -> [a]
05:25:58 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
05:25:58 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
05:26:21 <SamB_XP> too bad @kind doesn't remind you
05:26:34 <SamB_XP> but :i does
05:27:00 <SamB_XP> however, "a" always comes last
05:27:20 <Saizan> ?info MonadState
05:27:20 <lambdabot> MonadState
05:27:41 <ndm> @seen assumu
05:27:42 <lambdabot> I haven't seen assumu.
05:27:59 <ndm> @seen asumu
05:28:00 <lambdabot> I haven't seen asumu.
05:28:23 <SamB_XP> Saizan: unfortunately lambdabot doesn't have an :i command
05:28:27 <SamB_XP> or @info
05:28:40 <SamB_XP> it seems to be running @id instead
05:28:42 <dons> yeah, a bit too noisy we found
05:28:51 <SamB_XP> dons: you tried it?
05:29:09 <dons> we did, yep.
05:29:13 <dons> let me find the logs
05:29:47 <dons> 04.05.17:18:17:23 <shapr> I wrote @info last thursday
05:29:53 <Saizan> for types with many instances and/or contructors it can be quite verbose..
05:30:02 <SamB_XP> dons: funky date
05:30:15 <dons> hmm
05:30:15 <SamB_XP> is that 2004 or 2005?
05:30:20 <dons> 2004.
05:30:23 <SamB_XP> okay.
05:30:27 <SamB_XP> not *too* funky
05:30:43 <SamB_XP> our american dates are much funkier
05:30:57 <Saizan> the year in the middle seems just nonsense..
05:31:04 <SamB_XP> Saizan: yeah.
05:31:05 <dons> yeah, crazy stuff. @info was then removed some time. and then reimplemented by me.
05:31:09 <dons> 05.03.30:05:03:29 <Darius> Did you add @kind and @info, dons?
05:31:13 <dons> about a year later.
05:31:18 <dons> 05.03.30:05:04:25 * Darius isn't so sure @info is a good idea.
05:31:19 <SamB_XP> oh you added @info with @kind?
05:31:28 <dons> 05.04.01:01:32:23 <dons> there's no @info now, we had it yesterday for ghci
05:31:32 <dons> SamB_XP: yeah
05:31:35 <SamB_XP> how many lines was it making?
05:31:39 <dons> 05.04.05:10:18:52 <xerox> CosmicRay: @info was banned for verbosity
05:31:47 <dons> 05.04.08:09:01:18 <dons>  @info was too spammy by far
05:31:59 <dons> 05.04.16:04:45:03 <Cale> where did @info go?
05:31:59 <dons> 05.04.16:04:45:33 <dons> didn't we decide that @info was far too verbose?
05:32:05 <dons> 05.04.20:09:38:44 <xerox> Who wants to sign a petition to get @index and @info back?
05:32:08 <dons> 05.04.24:14:03:55 <shapr> @info was removed for spam reasons.
05:32:13 <dons> oh, the controversial history of @info !
05:32:36 <dons> 05.12.06:16:33:18 <SamB> dons: why no @info?
05:32:37 <dons> hah ^^
05:32:58 <SamB_XP> so, how many lines?
05:33:00 <dons> 06.03.23:06:36:27 <ihope> I oughta give lambdabot an @info once I'm done with my threaded factorial
05:33:03 <dons> hehe ^^
05:33:14 <quicksilver> you could have @info as PM-only
05:33:20 <dons> 06.04.21:20:22:51 <SamB>  @info was too verbose
05:33:20 <quicksilver> that we solve the spam issue
05:33:29 <dons> 06.03.23:06:57:50 <ihope> And could replies to the "normal" @info just always go directly to the requesting user
05:33:32 <dons> hah ^^
05:33:33 <SamB_XP> hah
05:33:46 <SamB_XP> I said that?
05:34:00 <SamB_XP> I am *so* absentminded!
05:34:00 <quicksilver> grate minds
05:34:12 <dons> so that's the history of @info
05:34:22 <SamB_XP> so how many lines was it generating?
05:34:26 <dons> and we all sit here talking in circles for years at a time
05:35:25 <dons> SamB_XP: 6 or so, but some produced huge output
05:36:02 <Saizan> e.g. :info Language.Haskell.TH.Exp
05:36:53 <SamB> dons: could cut it off after a few lines...
05:37:23 <SamB> would be nice to have a way to list the constructors of a datatype, though
05:37:56 <dons> yeah
05:37:59 <dons> @src []
05:37:59 <lambdabot> data [] a = [] | a : [a]
05:38:09 <Saizan> it should remove some newlines
05:38:37 <SamB> Saizan: well, that would be longer than just a list...
05:38:42 <xerox> note that there also is @instances now
05:39:11 <SamB> which works a lot better than :i would for that purpose, anyway
05:40:23 <SamB> Saizan: that doesn't look longer than Control.Exception.Exception
05:42:25 <Saizan> SamB: right, that reminds me that i've never used exceptions
05:43:51 <SamB> Saizan: I think the principle thing I've done with them is annotate them with the instruction pointer in my Z-machine implementation
05:45:10 * SamB wonders why :b is qualifying types
05:45:18 <SamB> (unneccessarily, I mean)
06:43:58 <shapr> yarr
06:44:16 <bos> @seen dons
06:44:17 <lambdabot> dons is in #xmonad, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dons speak just now.
06:44:54 <dons> yo
06:44:57 <petekaz> funny ... I was just going to look for dons.
06:45:07 <dons> i'm just on my way to bed. quick quick!
06:45:25 <petekaz> I'll ask my question another tiem.
06:45:43 <dcoutts> g'night dons
06:45:48 <astrolabe> I didn't think he went to bed :)
06:45:49 <dons> bos?
06:46:21 <shapr> I was just going to look for dons too!
06:46:50 <shapr> Mostly because I like my daily code fix, and around dons I can get it by osmosis!
06:47:00 <dcoutts> heh heh :-)
06:47:26 <shapr> Good morning Duncan! How's the unicycle?
06:47:36 <dcoutts> shapr: luck me, I got 6 weeks of dons code osmosis by sitting at the next desk in his office :-)
06:47:44 <shapr> Whoa, I bet that was awesome!
06:47:49 <dcoutts> shapr: I need to pump up the tyre
06:48:02 <dcoutts> it needs to be rock hard for a good road cycle experience
06:48:18 <dcoutts> makes hovering hard if the tyre has and give
06:48:21 <dcoutts> and/any
06:48:21 <shapr> You're pretty far up the code scale yourself, with both of you in one room I bet everyone around you started writing lambdas.
06:48:43 <dcoutts> I think we wrote some good code, yes
06:48:50 <shapr> And a paper?
06:48:51 <dcoutts> shapr: you'll have to read the paper :-)
06:48:54 <dcoutts> yep
06:49:02 <dcoutts> @google stream fusion
06:49:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
06:49:03 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
06:49:30 <shapr> Yeah, I saw it mentioned places, but haven't had time to read it yet.
06:49:47 <dcoutts> dons: see how we've taken over that phrase on google? :-)
06:50:25 <dcoutts> it is stream fusion, and everyone now knows it as such
06:50:48 * dcoutts will be back later
06:53:43 <dons> dcoutts: nice.
06:54:24 <dons> mwhaha.
06:54:48 <dons> shapr: yeah, had a great time with dcoutts visiting. lots and lots of code and ideas.
06:54:59 <dons> taking over the world is just that little bit closer now
06:55:14 <araujo> anybody would know what it is the utf code for the lambda symbol?
06:55:53 <dons> shapr: seen the cool xmonad tshirts?
06:55:55 <dolio> 0x03bb?
06:56:12 <int-e> > ord 'λ' -- sniff
06:56:12 <lambdabot>  Improperly terminated character constant
06:56:34 <araujo> mm...
06:57:03 <int-e> 0x3bb, yes.
06:57:03 <ski> http://www.spreadshirt.com/shop.php?article_id=2125373&view_id=181
06:57:04 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
06:57:07 <lambdabot> Title: xmonad inverse:xmonad is a minimalist tiling window manager for X, written in Ha ..., http://tinyurl.com/2exl9u
06:57:11 <ski> @messages
06:57:12 <lambdabot> ndm said 1h 22m 58s ago: looks like a hoogle parsing bug to me, i think its fixed in the next version
06:57:17 <araujo> Thanks dolio int-e
06:57:59 <dons> yeah, the black tshirts are nicest, imo.
06:58:15 <dons> i know what i'm wearing to icfp this year :-)
07:00:14 <dino-> I wish I could get stuff like that in a polo shirt.
07:00:18 <dino-> More my style than t-shirts.
07:00:56 <shapr> dons: xmonad t-shirts??
07:01:05 <dons> see above :-)
07:01:13 <sproingie> haskell-themed gimp suits
07:01:21 <sproingie> hey it is a bondage and discipline language
07:01:32 <shapr> dons: Wow that's cool!
07:02:06 <shapr> dons: I must have one!
07:03:45 <Cheery> I started playing around, do you know how could I yet make this better?
07:03:47 <Cheery> integral accum = SF (\a -> (\dt -> integral (accum + a * realToFrac dt), accum))
07:04:17 <Knuckles12> hello all!
07:04:30 <Knuckles12> i really need help for one of my function, if someone can help me
07:04:56 <Knuckles12> please
07:05:09 <norpan> ask away
07:05:51 <Knuckles12> i have a list of lists like [[1,2,3],[4,5,6],[7,8,9]]
07:06:08 <Cheery> Knuckles12: sorry to say, but I do not posses haskell community's certified crystal ball yet.
07:06:21 <Knuckles12> i want to create a list composed of the first element of the first list, the second element of the second list
07:06:24 <Knuckles12> etc..
07:06:35 <Knuckles12> sorry i don't understand very well, you mean i can't ask questions?
07:06:39 <norpan> the diagonal
07:06:40 <Botje> zipwith (!!) yourlist [0..]
07:06:48 <opqdonut> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0..]
07:06:50 <Knuckles12> yeah, i want the diagonal
07:06:52 <opqdonut> gah, too fast
07:06:53 <lambdabot>  [1,5,9]
07:06:54 <sproingie> hm.  i'm trying to see how these are qualitatively different:
07:06:55 <sproingie> replicateM 5 $ getStdRandom $ random
07:06:58 <sproingie> >
07:07:00 <sproingie> argh
07:07:03 <sproingie> > replicateM 5 $ getStdRandom $ random
07:07:05 <lambdabot>  Add a type signature
07:07:18 <Knuckles12> what is the (!!) ?
07:07:21 <sproingie> > getStdRandom $ runState $ replicateM 5 $ State random
07:07:22 <lambdabot>  Add a type signature
07:07:31 <norpan> !! is list indexing
07:07:33 <astrolabe> @type (!!)
07:07:36 <lambdabot> forall a. [a] -> Int -> a
07:07:48 <Knuckles12> thank you
07:07:51 <Knuckles12> thank you very much
07:07:53 <Cheery> heh, somebody owns haskell community's certified crystal ball! :D
07:07:58 <Knuckles12> didn't know this
07:08:08 <sproingie> > getStdRandom $ runState $ replicateM 5 $ State random :: IO [Int]
07:08:10 <lambdabot>  <IO [Int]>
07:08:17 <sproingie> golly
07:09:06 <sproingie> i take it getStdRandom is expensive?
07:09:21 <astrolabe> sproingie: you can pm lambdabot until you get it right :)
07:10:13 <sproingie> well i did, but it doesn't like to print
07:10:15 <dolio> @src getStdRandom
07:10:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:10:56 <Cheery> Knuckles12: you can always ask, just type your question first
07:11:08 <Knuckles12> I did
07:11:16 <sproingie> lemme rephrase .. i take it repeatedly calling getStdRandom is more expensive than threading the new random seed through in State?
07:12:04 <Knuckles12> and if i want the other diagonal
07:12:13 <Knuckles12> how do you do?
07:12:16 <quicksilver> sproingie: it might be expensive, but that's not the main point
07:12:25 <quicksilver> sproingie: the main point, is that's daft :)
07:12:54 <quicksilver> Knuckles12: I bet you can work that out, given the answer you've already got
07:12:59 <quicksilver> Knuckles12: or at least make an attempt
07:13:05 <Knuckles12> yep
07:13:05 <Botje> Knuckles12: something with reverse.
07:13:09 <Cheery> > [3..0
07:13:10 <lambdabot>  Parse error
07:13:12 <Knuckles12> ok
07:13:12 <Cheery> > [3..0]
07:13:14 <Knuckles12> sorry
07:13:14 <lambdabot>  []
07:13:16 <Knuckles12> i reverse my list
07:13:20 <Knuckles12> and i do the same thing
07:13:25 <Knuckles12> migt work
07:13:28 <Knuckles12> might work
07:13:47 <Cheery> wait a bit
07:13:48 <Botje> except the diagonal will come out bottom left -> top right
07:14:01 <Botje> which might not be what you want, but it might not matter
07:14:04 <quicksilver> > zipWith (!!) (reverse [[1,2,3],[4,5,6],[7,8,9]]) [0..]
07:14:05 <lambdabot>  [7,5,3]
07:14:10 <quicksilver> as Botje says
07:14:12 <quicksilver> it's nearly right
07:14:17 <quicksilver> but it's also obvious how you fix that :)
07:14:20 <Knuckles12> yep
07:14:25 <Knuckles12> i can do two reverse
07:14:34 <Cheery> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [3,2,1]
07:14:34 <Botje> I was actually thinking about zipWith (!!) (map reverse ...) [0..]
07:14:36 <lambdabot>  Exception: Prelude.(!!): index too large
07:14:41 <Botje> but okay, whatever :)
07:14:45 <Cheery> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [2,1,0]
07:14:47 <lambdabot>  [3,5,7]
07:14:56 <Cheery> Knuckles12: that's what you want?
07:15:08 <Knuckles12> yeah
07:15:09 <Knuckles12> perfect
07:15:29 <Knuckles12> it was hard to find documentation and help on web, i'm really grateful for your help
07:15:48 <Cheery> @hoogle zipWith
07:15:49 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:15:49 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
07:15:49 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
07:15:52 <Cheery> @hoogle (!!)
07:15:54 <lambdabot> Did you mean: (!!)
07:15:54 <lambdabot> Prelude.undefined :: a
07:15:54 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:15:54 <Botje> Knuckles12: you should check out hoogle
07:16:12 <Knuckles12> yep
07:16:14 <Knuckles12> I did
07:16:23 <Knuckles12> but i'm french
07:16:27 <Knuckles12> so i prefer french documentation
07:16:34 <Knuckles12> if i want a good understanding
07:16:42 <Knuckles12> and french documentation is hard to find for Haskell
07:18:12 <Cheery> yes, thought you rarely need to read anything else except the type of function and understand what it does
07:18:14 <quicksilver> your english seems good to me
07:18:33 <quicksilver> and furthermore, I think if you want good understanding of computer science, imporving your english will be time well spent
07:18:44 <quicksilver> I'm afraid it's an english-centric world out here :)
07:18:56 * Cheery is finnish
07:18:56 <opqdonut> yep
07:19:13 <Knuckles12> i know
07:19:23 <opqdonut> Cheery: me too
07:19:34 * norpan is swedish
07:19:35 <Knuckles12> but i always find a quick definition of functions
07:19:39 <Cheery> I wonder how long it will be english-centric, it is not likely to change anytime soon, but one never knows
07:19:39 <Knuckles12> like this one :
07:19:50 <Knuckles12> http://www.zvon.org/other/haskell/Outputprelude/zipWith_f.html
07:19:52 <lambdabot> Title: Haskell : zipWith
07:19:58 <Knuckles12> not so helpful for me
07:20:05 <quicksilver> Cheery: if automatic translation ever became reliable, things might change
07:20:21 <quicksilver> Cheery: but frankly the economic and practical benefits of a common language are vast, at the moment
07:20:38 <xerox> @src zipWith
07:20:39 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:20:39 <lambdabot> zipWith _ _      _      = []
07:21:08 <Cheery> Knuckles12: do you know yet how to read those type definitions?
07:21:39 <Cheery> ie: that (a -> b -> c) -> [a] -> [b] -> [c]
07:21:52 <Knuckles12> nop
07:21:59 <Knuckles12> you give three element of any type
07:22:09 <Knuckles12> and it returns three lists of this type
07:22:21 <Knuckles12> ??
07:22:33 <Cheery> no
07:23:01 <Knuckles12> ok
07:23:02 <Knuckles12> :D
07:23:09 <Cheery> type definitions are real time savers, they give lots of direction about what the function does.
07:24:04 <Cheery> (a -> b -> c) is in brackets because it is a function of it's own
07:24:18 <fasta> (Monad (CC r m), Monad m) =>
07:24:18 <fasta> > 	    ((term -> CC r m (Maybe term, dir)) -> term -> CC r m term)
07:24:18 <fasta> > 	    -> term -> CC r m (Zipper r m term dir)
07:24:18 <lambdabot>  Parse error
07:24:19 <lambdabot>  Parse error
07:24:23 <fasta> Cheery: how about that one?
07:24:25 <fasta> :)
07:24:53 <Cheery> :D
07:25:03 <Knuckles12> wow
07:25:20 <Cheery> fasta, ok, there are exceptions
07:25:20 <fasta> For complex types you don't want to write down the type yourself.
07:25:40 <shapr> Cheery: hyvää huomenta!
07:25:53 <Cheery> terve
07:26:02 <shapr> mitta?
07:26:38 <fasta> If only people would provide sensible visualizations of the data structures they described....
07:26:48 <shapr> heippa hei kaikilla!
07:27:01 <Cheery> Knuckles12: anyways, fire up ghci and try write:    :t (+)
07:27:05 <sieni> kaikill_e_
07:27:05 * shapr is Alabamsk
07:27:07 <sieni> :-)
07:27:13 <Knuckles12> ok
07:27:16 <Knuckles12> i test it
07:27:17 <shapr> sieni: Bah, I rarely get Finnish right.
07:27:36 <shapr> Minä en puhu suomea.
07:27:39 * fasta is using paper as a substitute now :(
07:27:48 <shapr> fasta: For type signatures?
07:27:49 <kaol> I thought I had switched to #debian-fi for a moment and wondered why shapr would be there ;-)
07:27:49 <Cheery> then try :t (+) 1
07:27:53 * shapr is confused.
07:27:55 <fasta> shapr: no
07:27:55 <sieni> shapr: that went right :-)
07:27:58 <shapr> kaol: Hey, I started that channel.
07:28:06 <fasta> shapr: I am trying to create an overly complex data structure
07:28:20 <shapr> kaol: It was my mistake that it got named #debian-fi instead of #debian.fi :-(
07:28:33 <Knuckles12> ok
07:28:48 <Knuckles12> i'm lost
07:28:50 <Knuckles12> :)
07:29:38 <shapr> kaol: Ah the lonely years I spent living in Tornio
07:29:41 <Cheery> Knuckles12: you got something like: (Num a) => a -> a -> a, right?
07:29:51 <Cheery> :t (+)
07:29:53 <lambdabot> forall a. (Num a) => a -> a -> a
07:30:04 <fasta> Execution on paper is slow
07:30:09 <shapr> kaol: Where is #debian-fi these days, oftc?
07:30:16 <Cheery> :t (+) 1
07:30:19 <lambdabot> forall t. (Num t) => t -> t
07:30:24 <Knuckles12> yeah i did
07:30:35 * shapr boings distractedly
07:30:39 <kaol> shapr: yes, oftc
07:30:56 <Knuckles12> but i don't understand why it becomes t->t when i write 1
07:31:02 <Cheery> type signatures describe what type and kind of things function can get
07:31:32 <Cheery> (Num t) => t -> t means it takes numbers and spits numbers
07:31:47 <Knuckles12> ok
07:31:49 <sproingie> i never found a good explanation of kinds
07:32:05 <sproingie> kinds are haskell's equivalent to arity, right?
07:32:13 <Cheery> > map (+1) [1,2,3..]
07:32:14 <lambdabot>  Parse error
07:32:17 <Cheery> > map (+1) [1,2,3...]
07:32:17 <lambdabot>  Parse error
07:32:22 <dolio> Kinds are like the type of types.
07:32:23 <shapr> sproingie: A type describes what values can be, a kind describes what types can be.
07:32:24 <Cheery> > map (+1) [1,2,..]
07:32:24 <lambdabot>  Parse error
07:32:27 <Cheery> huh
07:32:37 <Cheery> > map (+1) [1,2..]
07:32:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
07:33:07 <Knuckles12> ok
07:33:08 <assl0r> wow =)
07:33:09 <Cheery> Knuckles12: map, in other hand is high-order function
07:33:15 <Cheery> :t map
07:33:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:33:18 <Knuckles12> ii know the map function
07:33:30 <Knuckles12> it takes all the elements of a list, and apply the function
07:33:35 <Cheery> yes
07:33:47 <Knuckles12> ok
07:33:49 <dons> i love this kind of enthusiasm: http://errantember.livejournal.com/50627.html
07:33:50 <Cheery> you see it's type is: (a -> b) -> [a] -> [b]
07:33:51 <lambdabot> Title: errantember: Unexpected Attack of Geekery Continues...
07:33:56 <dons> shapr: ^^ this is what we like to see, eh?
07:34:07 <Knuckles12> yeah i do
07:34:19 <Cheery> Knuckles12: do you start to realise what all those type signatures mean? :)
07:34:25 <shapr> dons: Haha, yes!
07:34:58 <Cheery> :t map (+1)
07:34:59 <Knuckles12> yeah
07:35:01 <lambdabot> forall a. (Num a) => [a] -> [a]
07:35:14 <Knuckles12> i think i start to understand all of this
07:35:15 <shapr> I got the TCP/IP stack from House 0.8 to build with GHC 6.6 last night.
07:35:25 <shapr> Haven't tried it out yet, but should be fun.
07:35:26 <Knuckles12> I have to experiment this
07:36:00 <Cheery> heh, I think I'm done then. :)
07:36:38 <kaol> @check (take 100 $ map (+1) [1..]) == (take 100 $ tail [1..])
07:36:38 <Knuckles12> Thank you for your help
07:36:40 <lambdabot>  OK, passed 500 tests.
07:37:15 <Cheery> the => is about classes, you will understand it better when you get to understand haskell's type system better
07:37:38 <dons> ibid: johan jeuring has a blog! why isn't it on planet haskell?? :-) http://johanjeuring.blogspot.com/2007/05/advertising-icfp-programming-contest.html
07:37:40 <lambdabot> Title: Johan Jeuring's blog: Advertising the ICFP Programming Contest, http://tinyurl.com/2e2mpb
07:37:52 <Cheery> and forall. is also such thing you will learn more about later
07:38:55 <Knuckles12> yeahhh
07:38:56 <fasta> dons: I suspect because he will only have a few entries this year, followed by zero.
07:38:56 <Knuckles12> great
07:38:59 <Knuckles12> I understand
07:39:02 <Knuckles12> zipwith and all
07:39:05 <Knuckles12> will help me
07:39:08 <Knuckles12> thank you so much
07:39:08 <Knuckles12> :D
07:39:56 <dons> fasta: followed by zero?
07:40:14 <quicksilver> kaol: awesome you'd just proved map (+1) == tail! that should be a really useful optimisation trick!
07:40:29 <fasta> dons: a blog is a "popular" way to distribute content. When the reason for distribution halts, to does the blog.
07:40:58 <fasta> er so
07:41:01 <shapr> fasta: Er, what's the reason for distribution for Johan Jeuring? Do you think he'll stop being cool and interesting?
07:41:21 <fasta> shapr: isn't he one of the organisers?
07:41:30 <kaol> quicksilver: that's not all
07:41:35 <fasta> shapr: he wants to make sure it doesn't get ignored.
07:41:47 <fasta> shapr: that seems like a sensible thing to do.
07:41:52 <shapr> Why would he get ignored?
07:42:04 <fasta> shapr: not "he", but ICFP
07:42:07 <shapr> oh
07:42:22 <kaol> @check (take 100 $ map (+2) [1..]) == (take 100 $ tail $ tail [1..])
07:42:24 <lambdabot>  OK, passed 500 tests.
07:42:34 <ski> @check \xs -> (take 100 $ map (+1) xs) == (take 100 $ tail xs)
07:42:35 <fasta> shapr: Do you think that he will continue to talk about his cats after ICFP on that blog?
07:42:36 <lambdabot>  Add a type signature
07:42:43 <ski> @check \xs -> (take 100 $ map (+1) xs) == (take 100 $ tail xs :: [Int])
07:42:44 <fasta> shapr: I believe he won't.
07:42:45 <lambdabot>  Exception: Prelude.tail: empty list
07:42:51 <fasta> shapr: That's all I was saying.
07:42:55 <shapr> fasta: How can you tell? Have you met him and talked to him?
07:42:58 <ski> @check \xs -> (not (null xs)) ==> (take 100 $ map (+1) xs) == (take 100 $ tail xs :: [Int])
07:43:00 <lambdabot>  Falsifiable, after 0 tests: [1,-1,0]
07:43:29 <dolio> @check \(i :: Int) -> (i > 0) ==> (take 100 $ map (+i) [1..]) == (take 100 $ drop i [1..])
07:43:30 <lambdabot>  Parse error in pattern
07:44:02 <dolio> @check \i -> (i > 0) ==> (take 100 $ map (+i) [1..]) == (take 100 $ drop i [1..])
07:44:04 <lambdabot>  OK, passed 500 tests.
07:44:08 <dolio> :)
07:44:09 <fasta> shapr: I don't know it, but it's based on some experience in similar situations.
07:44:13 <sproingie> isn't "falsifiable" the wrong term?
07:44:34 <sproingie> i thought falsifiable meant a theory had to admit a test that could conceivably prove it wrong
07:44:38 <shapr> fasta: I met Johan Jeuring at the past Haskell Workshop, he's a cool guy. He seems very serious and focussed to me.
07:44:42 <Knuckles12> that so bad that zipwith return an empty list if you use it between a normal list, and and empty one
07:44:51 <Knuckles12> would be great that it returns the normal list
07:44:54 <fasta> shapr: yes, that's consistent with what I said
07:45:00 <shapr> I was also impressed that Johan Jeuring spoke Swedish.
07:45:07 <sproingie> tho i guess if something's proved wrong, it's falsifiable.  nvm :P
07:45:27 <dolio> sproingie: 'map (+1) xs == tail xs' is your theory. :)
07:45:38 <ski> Knuckles12 : what to do in case one list is shorter than the other (but isn't empty) ?
07:46:23 <dolio> Perhaps 'falsified' would be a better word?
07:46:34 <fasta> dolio: no
07:46:42 <Knuckles12> don't know
07:50:00 <Knuckles12> Have a nice day!
07:50:03 <Knuckles12> bye everyone!
07:50:13 <Knuckles12> Thanks for your help Cheery
07:59:01 <Cheery> *FRP> further (integral 5) (repeat 1) [1..9]
07:59:02 <Cheery> [5.0,6.0,8.0,11.0,15.0,20.0,26.0,33.0,41.0]
07:59:09 <Cheery> I somehow feel satisfied
08:00:34 <opqdonut> SATISFACTION
08:00:46 <dolio> @yow
08:00:47 <lambdabot> I am covered with pure vegetable oil and I am writing a best seller!
08:01:32 <shapr> Wow, scary thought.
08:02:32 <Cheery> that integral -signal function went well
08:04:04 <Cheery> I guess I'll try implement more yampa and see whether it all turns out look as nice
08:04:41 <shapr> Cheery: Do you think all of yampa could be implemented as comonads?
08:04:48 <Cheery> if it does, I think I'll show it to the original author(s) if I can find any of them.
08:05:08 <shapr> Cheery: The one big problem with arrows is that you can't lift normal functions and keep the really nice properties of arrows.
08:05:13 <Cheery> shapr: heck, what is a comonad?
08:05:16 <psykotic> shapr, the stuff i've seen of yampa can be done using comonads.
08:05:30 <shapr> Hej Per
08:05:37 <psykotic> admittedly i've only looked at it superficially. but causal procedures defined over streams is a classical application of comonads.
08:05:38 <psykotic> hey
08:06:01 <shapr> Cheery: A comand is the dual of a monad, it pulls a value from an environment, sort of
08:06:01 <Cheery> shapr: I've been watching yampa and decided to restructure it a bit, no comonads involved
08:06:08 <shapr> Restructure it how?
08:06:19 <psykotic> shapr, have you seen sigfpe's old blog entry on comonads and causal stream functions?
08:06:30 <Cheery> I can paste the sources to hpaste
08:06:36 <shapr> psykotic: Yeah I've seen it, it's nice. I just wonder how the implementations would compare.
08:06:37 <psykotic> shapr, cuz that's pretty much exactly what functional reactive programming is about.
08:06:43 * psykotic nods.
08:07:16 <shapr> I've been wondering how a TCP/IP stack would work if structured with Yampa or some sort of arrow-style FRP, and that led me to wondering about a stack built with comonads instead.
08:07:59 <hpaste>  Cheery pasted "FRP replication, main difference is in the signal function type signature" at http://hpaste.org/1638
08:08:03 <ski> comonads ftw !
08:08:30 <Cheery> shapr: can you give me a link/quick introduction to comonads?
08:08:32 <shapr> Actually, Nanevski's possibiliy and necessity monad split is probably more immediately important to the Haskell world at large.
08:08:49 <shapr> Cheery: http://www.haskell.org/hawiki/CoMonad
08:08:51 <lambdabot> Title: CoMonad - The Haskell Wiki
08:10:09 <shapr> psykotic: Any thoughts on whether arrows or comonads would be more natural for a TCP/IP stack?
08:10:33 <psykotic> shapr: comonads is my guess, although i guess it's slightly unchartered ground.
08:10:36 <Cheery> shapr: anyways, what do you think about the reordering?
08:10:45 <psykotic> arrows are kind of like a product of a monad and a comonad, so they often have too much structure.
08:11:05 <shapr> Hm, good point.
08:11:26 <ski> too much ?
08:11:37 <arcatan> or too sexy?
08:11:44 * ski thought it was too little
08:11:47 <ibid> dons: you know perfectly well why :)
08:12:15 <psykotic> ski: well, consider working with causal functions over streams. the natural structure there is comonadic, but you can use arrows; they just get in the way.
08:12:31 <ibid> dons: in any case, i am currently computer-crippled and in particular i don't temporarily have access to the planet system
08:12:36 <shapr> I've seen arrows composed of a monad and comonad.
08:12:52 <ibid> dons: (i expect this to go away in a week or so)
08:13:02 <ski> psykotic : yes .. so i'd say that's because you get too little structure from the arrow, so you have to build it yourself with extra combinators
08:13:16 <psykotic> ski: well, a bare comonad has almost no structure either.
08:13:41 <shapr> Cheery: I don't really have the spare brain power to compare your reimplementation to the original at the moment, but... have you http://zoo.cs.yale.edu/classes/cs490/03-04a/benjamin.lerner/ by Benjamin Lerner?
08:13:42 <ski> every comonad has a cokleisli arrow, no ?
08:13:43 <lambdabot> Title: Arrow Laws and Efficiency in Yampa
08:14:09 <psykotic> ski: sure
08:14:15 <Cheery> shapr: I haven't thanks!
08:14:24 <Cheery> going to read it very soon
08:14:31 * ski hmms
08:14:31 <psykotic> ski: every monad has a kleisli arrow. you get an arrow from every monad. you get an arrow from every comonad too, no?
08:14:39 <shapr> Cheery: I'm pretty sure those changes are available in the release of Yampa from a few months back.
08:14:55 <dolio> @type CoKleisli
08:14:58 <lambdabot> Not in scope: data constructor `CoKleisli'
08:15:04 <ski> psykotic : but i think not every arrow yields a monad, nor comonad
08:15:26 <psykotic> ski: true, and that's because there are arrows there are "proper" combinations of monads and comonads. well, i dunno :)
08:15:28 <ski> newtype CoKleisli w a b = MkCK {unCK :: w a -> b}
08:15:40 <ski> newtype CoKleisliT w ar a b = MkCK {unCK :: ar (w a) b}
08:15:54 <Cheery> shapr: ok
08:16:45 <ski> psykotic : i'd say there are arrow effects that can't be expressed either as monad, nor comonad, effects
08:17:26 <ski> psykotic : but it may be we're both right (or wrong, if you wish) .. depending on which inclusions between monads / comonads and arrows one takes
08:17:58 * ski hmms some more
08:18:01 <shapr> Wasn't it perfectly clear that Swierstra & Duponcheel's parser combinators could not be monads? Could they be comonads instead?
08:18:11 <ski> shapr : i think not
08:18:34 <shapr> So there are clearly arrows that cannot be monads or comonads.
08:18:35 <psykotic> shapr, but consider the static part of their parser arrows. couldn't that be comonadic in itself? i'm talking about the nullable/first data.
08:18:44 <shapr> I dunno.
08:18:48 <psykotic> my point is that it may be a kind of product of a monad and a comonad.
08:18:49 <Cale> Arrows are a more general idea than monads or comonads, so arrows are less expressive polymorphically, but have more instances.
08:19:02 <helmut> Could you give me a hint on how to write a type annotator? I've got a tree of expressions and now I'd like to add types. Should I create a typed-tree? (i.e. a new treetype?)
08:19:06 <shapr> @quote spears
08:19:06 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
08:19:08 <shapr> aww
08:19:13 <ski> shapr : but should this be considered "outside scope of monad and comonad" or "strange combination of monad and comonad which doesn't yield a monad or comonad" ?
08:19:24 <Cheery> wow, comonad type signatures are almost opposite to monad's.
08:19:29 <shapr> Cheery: Yeah, "dual"
08:19:30 <psykotic> Cheery, that's the co part :)
08:19:36 <ski> Cheery : that's the point
08:19:44 <psykotic> a mathematician turns coffee into theorems; a comathematician turns theorems into coffee. :)
08:19:48 <shapr> haha
08:20:32 <shapr> ski: The second part of what you said implies that any arrow can be decomposed into a monad and comonad. Is that true?
08:20:43 * emu hires a comathematician for the kitchen
08:20:49 <ski> shapr : i think not
08:21:25 <shapr> Or, could you split an arrow into three parts? co/monad and some simple thing to mix them?
08:21:54 <psykotic> Cheery, have you also noticed that product (,) and disjoint sum (what is expressed by Either) are dual in this sense? with product you have projection functions fst and snd: a <-fst- (a,b) -snd-> b. with Either you have injections Left and Right. a -Left-> Either a b <-Right- b. note how it's the same kind of diagram but with the arrows turned around.
08:22:00 <ski> (btw, what second part did you mean ?)
08:22:37 <shapr> ski: You said 1. Are arrows 'outside ofthe scope of monad and comonad' or 2. Are they somehow composed of monad(s) and comonad(s)?
08:22:59 <ToRA> random question, can anyone think of a suitable (not already taken) name for this function: Eq a => [(a,b)] -> [(a,[b])]?
08:23:08 <shapr> Wouter Swierstra pointed me to a cool paper that describes arrows as being one step away from monads in Category Theory terms... I wonder if I can find it...
08:23:18 <ski> shapr : clarification .. i was there babbling about specifically Swierstra & Duponcheel's parser combinators
08:24:00 <shapr> Ah, here it is.. http://lambda-the-ultimate.org/node/1750
08:24:02 <lambdabot> Title: Arrows, like Monads, are Monoids | Lambda the Ultimate
08:24:28 <matthew-_> can I use forall or something like that to create a list like [Foo a] where the 'a' can vary for each elem?
08:24:43 <ToRA> no
08:24:48 <shapr> matthew-_: Yeah, universal quantification I think it's called.
08:24:49 <earthy> Swierstra & Duponcheel's parser combinators cannot be comonads IIRC, for much the same reasons that they cannot be monads
08:25:07 <ToRA> you can't do [ forall a. Foo a ], you'd have to manually hide it
08:25:20 <matthew-_> ToRA: go on!
08:25:24 <ToRA> i.e.
08:25:34 <quicksilver> psykotic: a comathematician would turn cotheorems into cocoffee, unfortunately
08:25:44 <ToRA> data MyFoo = MF forall a . a  (or possibly forall a . MF a )
08:25:48 <ToRA> [MyFoo]
08:25:48 <ski> matthew-_ : what you want is '[ exists a. Foo a ]'
08:25:59 <quicksilver> psykotic: you'd need to solve the cocoffee -> coffee problem to make the loop, and that's believed insoluble
08:26:04 <ToRA> ski: is 'exists' actually syntax?
08:26:07 <psykotic> quicksilver :)
08:26:17 <ski> matthew-_ : .. which can't be expressed directly, so do what ToRA is attempting to tell you
08:26:27 <ski> ToRA : it is not
08:26:33 <matthew-_> lol. right, thanks!
08:26:35 <ToRA> ski: ah phew
08:26:37 <shapr> Well, back to paying Haskell work...
08:26:47 <psykotic> shapr, you bastard
08:26:48 <psykotic> :)
08:26:54 <ski> (ToRA : in jhc it is actual syntax .. in *some* positions .. not including this :/ )
08:27:09 <ski> data MyFoo = forall a. MF a
08:27:11 <ski> this gives
08:27:17 <shapr> psykotic: Hey, my company is hiring...
08:27:27 <ski> forall a. MF :: a -> MyFoo
08:27:29 <ski> or
08:27:39 <ski> MF :: forall a. a -> MyFoo  -- in more correct syntax
08:28:01 <shapr> psykotic: Plus you have enough reputation that you could likely get Haskell stuffed into your projects too. :-P
08:28:08 <ski> matthew-_ : note however that you need some more constraint on 'a' to make this useful
08:28:22 <matthew-_> ski: yeah, I'm thinking about that
08:28:22 <psykotic> shapr, re: stuffing haskell, that would be a miracle :)
08:28:59 <ski> matthew-_ : usually that is some extra "member functions" in the constructor .. or a class constraint (which amounts to the same thing)
08:30:41 <matthew-_> ski: yep exactly, one of the fields is a function that makes use of the a
08:30:51 <ski> quicksilver : 'cotheorems' is the same as 'falsities' ?
08:32:12 <blakkino> newtype Pixel2Hex = Pixel2HexNew Map PixelCoords HexCoords <- how to tell the compiler that "PixelCoords" and "HexCoords" are Map params instead of other stuff into the datatype.. (sorry for the stupid/syntax-only question)
08:32:40 <quicksilver> blakkino: (Map foo bar)
08:32:45 <quicksilver> blakkino: that is, use parens
08:33:11 <quicksilver> in emacs, position  your cursoe over the 'M' of Map and hit M-3 M-(
08:33:11 <quicksilver> :)
08:33:41 <blakkino> i have tried that but it seem to take it as a list of one element.. but maybe i have not properly read the ghc output..
08:33:42 <Uto> is there a lisp to haskell tutorial ? or prolog to haskell tutorial ?
08:34:20 <shapr> psykotic: Nah, write a scripting language that works like Yampa where the user doesn't get to play with the actual values and you won't have to worry about space or time leaks. Then you'll have something more pleasant than Lua in WoW.
08:34:40 <fasta> Uto: if it's not in the meta index of tutorials, no.
08:35:04 <yorg123> I have a question on one of the excercises in the yaht tutorial
08:35:30 <yorg123> i tried to write map and filter using cps. this is what i have:
08:36:04 <yorg123> cmap' f [] = []
08:36:05 <yorg123> cmap' f (x:xs) = f x xs (\list -> cmap' f list)
08:36:07 <yorg123> cmap f list = cmap' (\el ls cont -> (f el) : (cont ls)) list
08:36:40 <yorg123> the interesting thing is, the cfilter' is exactly the same funciton. i just pass a different funciton in the cfilter wrapper:
08:37:02 <yorg123> cfilter p list =
08:37:04 <yorg123>     cmap' (\el ls cont ->
08:37:05 <yorg123>             if p el then el : cont ls
08:37:07 <yorg123>             else cont ls)
08:37:08 <yorg123>         list
08:37:19 <Cheery> psykotic: I haven't noticed
08:37:23 <fasta> !paste
08:37:23 <hpaste> Haskell paste bin: http://hpaste.org/
08:37:52 <yorg123> is this the intended result? it somehow seems strange that the actual filtering happens only in the wrapper cfilter, not in the cps-style function
08:38:18 <blakkino> quicksilver, in my previous sentence i was thinking about a tuple, not a list.. obviusly.. anyway tuple of one element seem not to exist :)
08:38:52 <blakkino> thanks
08:39:05 <psykotic> Cheery, well, it's the same kind of thing. :)
08:44:09 <hpaste>  yorg pasted "Solution for "Write map and filter using continuation passing style."? (Excercise from YAHT)" at http://hpaste.org/1639
08:44:55 <Nafai> shapr: What's Yampa?
08:45:28 <ski> yorg123 : 'cfilter' is not in CPS, it's in nqCPS
08:46:34 <yorg123> what is nqCPS?
08:46:40 <ski> yorg123 : and your "cmap'" is not the CPS version of 'map'
08:46:51 <ski> not-quite-Continuation-Passing-Style
08:46:54 <ski> :)
08:46:59 <yorg123> ok :)
08:47:25 <ski> yorg123 : 'cfilter' would require 'shift' and 'reset' to write in DS (Direct-Syle)
08:47:57 <Saizan> what are shift and reset?
08:48:00 <yorg123> uh, ok. i have not gotten that far through the tutorial yet :)
08:48:44 <ski> Saizan : http://community.schemewiki.org/?composable-continuations-tutorial
08:48:48 <lambdabot> http://tinyurl.com/yy2eux
08:49:04 <ski> yorg123 : 'f' should not be given 'xs' as argument
08:51:17 <tom_> Hi all
08:51:47 <tom_> I'm having a little trouble defining an Arbitrary instance for QuickTest tests, I'm sure I'm doing something silly but I don't know what
08:51:59 <hpaste>  tom_ pasted "(no title)" at http://hpaste.org/1640
08:52:15 <tom_> Anyone know what I might be doing wrong?
08:53:05 <sjanssen> tom_: you'll need to use -fglasgow-exts
08:53:41 <sjanssen> Haskell '98 says that you can only write an instance for "Bloom a", not "Bloom String"
08:54:23 <yorg123> ski: so f should only take x (the element) and the continuation as parameters?
08:54:28 <quicksilver> blakkino: inserting parens doesn't make it a list
08:54:33 <quicksilver> blakkino: not sure if we're at cross purposes
08:55:35 <blakkino> yes i was speaking about tuples not lists
08:56:50 <quicksilver> blakkino: I also was speaking about tuples not lists
08:56:57 <quicksilver> blakkino: I don't think anyone was talking about lists :)
08:57:07 <blakkino> <quicksilver> blakkino: inserting parens doesn't make it a list
08:57:13 <quicksilver> blakkino: it would only be a list if you used []
08:57:20 <quicksilver> maybe that's the source of confusion?
08:57:23 <quicksilver> did you use [] instead of () ?
08:57:28 <tom_> thanks sjanssen
08:57:33 <blakkino> yea but i never thinked about lists.. i was thinking about tuples.. and writing list
08:57:41 <helmut> Is there a way to take a recursive data type and make a new type of it inserting a bit of information at every node?
08:58:16 <quicksilver> helmut: only if you plan in advance
08:58:21 <quicksilver> helmut: and put a 'spare parameter' in the type
08:58:37 <quicksilver> helmut: which is quite a common idiom, SPJ recommends it in one of his compiler-writing tutorials
08:59:03 <blakkino> quicksilver, i was afraid that "Map (A,B)" was considered a Map with the first "type argument" of one tuple type
08:59:21 <helmut> quicksilver: well I am writing a compiler.
08:59:22 <Saizan> quicksilver: but if he makes a newtype?
08:59:29 <helmut> quicksilver: so I'll do that. :-)
08:59:31 <quicksilver> blakkino: (Map A B)
08:59:34 <quicksilver> blakkino: is what I meant
08:59:51 <blakkino> yes it works now
08:59:54 <quicksilver> newtype Pixel2Hex = Pixel2HexNew (Map PixelCoords HexCoords)
09:00:03 <quicksilver> good :)
09:00:15 <blakkino> i'm already thinking about the next prob and have forgotten that.. anyway yes..
09:00:33 <quicksilver> Saizan: you can't make a newtype in a way which 'recursively annotates each node' of an algebriac type, no
09:00:35 <blakkino> in in that case there is no ambiuity becose tuple of one element doesn't make much sense
09:00:50 <quicksilver> Saizan: not without scrap-my-boilerplate type tricks, at least
09:01:11 <helmut> quicksilver: could you be more concrete on those type tricks? ;-)
09:01:15 <quicksilver> blakkino: yes
09:01:23 <ski> yorg123 : yes
09:01:30 <ski> @type map
09:01:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:01:46 <quicksilver> helmut: suppose a simple type is this
09:01:56 <Saizan> quicksilver: i see, the internal types doesn't know that it should recurse on the newtype now
09:02:13 <quicksilver> data AST = BinExpr Op AST AST | Unary Op AST | Atom Atom
09:02:22 <helmut> quicksilver: yes.
09:02:26 <quicksilver> you change it thus:
09:02:28 <ski> cmap :: (a -> (b -> o) -> o) -> [a] -> ([b] -> o) -> o  -- i think this is the usual type
09:02:31 <ski> yorg123 ^^
09:02:44 <quicksilver> data AST a = BinExpr a Op AST AST | Unary a Op AST | Atom a Atom
09:02:48 <Cheery> @unpl (=>> (f . (=>> g)))
09:02:48 <lambdabot> (\ b -> b =>> \ e -> f (e =>> g))
09:03:00 <quicksilver> helmut: you add a parameter a, and you add it at each possible node
09:03:11 <quicksilver> helmut: then AST () is the basic case (empty tuple stores no information)
09:03:18 <helmut> quicksilver: I thought about that. However I cannot access the type of a node without knowing what the node is then.
09:03:22 <quicksilver> helmut: but you can also have AST String, or AST Type, or AST (something,complex)
09:03:25 <syntaxfree> the Ord instance for Maybe is kind of a wart.
09:03:35 <syntaxfree> > compare (Just 2) (Just 3)
09:03:41 <lambdabot>  LT
09:03:46 <syntaxfree> huh?
09:04:00 <syntaxfree> nevermind.
09:04:06 <syntaxfree> it's not :)
09:04:19 <yorg123> ski: this means i have to pass the result of applying f to the first element on to the continuation, right?
09:04:22 <syntaxfree> class deriving works in mysterious ways.
09:05:06 <dolio> > compare Nothing undefined
09:05:07 <lambdabot>  Undefined
09:05:15 <ski> yorg123 : to the continuation of 'f', yes
09:05:48 <sjanssen> > compare Nothing (Just 1)
09:05:50 <lambdabot>  LT
09:06:08 <sjanssen> @type maybe
09:06:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:06:11 <assl0r> how can i `take` some elements directly from a infinite mapped list?
09:06:25 <assl0r> >:t take
09:06:32 <sjanssen> > take 10 $ map (*2) [1..]
09:06:33 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
09:06:41 <quicksilver> helmut: I don't think I understand
09:06:42 <sjanssen> :t take
09:06:43 <assl0r> ah thx
09:06:45 <lambdabot> forall a. Int -> [a] -> [a]
09:06:53 <quicksilver> helmut: you can define the function annotation :: AST a -> a
09:06:55 <shapr> Nafai: http://www.haskell.org/yampa/
09:06:57 <lambdabot> Title: Yampa
09:07:00 <quicksilver> helmut: to get the annotation at the (head) of a node
09:07:34 <sjanssen> @src []
09:07:35 <lambdabot> data [] a = [] | a : [a]
09:07:42 <sjanssen> @src Maybe
09:07:43 <lambdabot> data Maybe a = Nothing | Just a
09:08:00 <fasta> sjanssen: isn't that pseudo syntax?
09:08:10 <fasta> sjanssen: or is that really how it's implemented?
09:08:17 <sjanssen> fasta: the [] isn't quite legal
09:08:25 <syntaxfree> Is the Ord instance for (,), (,,), (,,,) etc. defined in Haskell somewhere?
09:08:26 <helmut> quicksilver: Yes. However the design looks a bit broken to me as every node has the same information which could also be saved outside. I therefore thought about data AST = Bin Op (AST, a) (AST, a) | Unary Op (AST, a)
09:08:39 <helmut> quicksilver: but this seems to look even worse.
09:08:41 <shapr> sjanssen: Any ideas if it's possible to write a single QuickCheck property like x+y == y+x and test it for lots of different types, say Int, Integer and Float, etc?
09:08:48 <fasta> sjanssen: right, but it might be that the compiler makes an exception when compiling itself :)
09:09:06 <syntaxfree> @get-shapr
09:09:07 <lambdabot> shapr!!
09:09:11 <sjanssen> shapr: write instance Arbitrary Dynamic? ;)
09:09:23 <syntaxfree> hey. I was reading the c2 wiki and I found lots of questions from back when you were a newbie :)
09:09:39 <shapr> syntaxfree: You screamt?
09:09:51 <syntaxfree> lambdabot screamt.
09:10:02 <shapr> syntaxfree: Yeah, I was a very active member of Ward's Wiki in the mid and late nineties.
09:10:23 <shapr> I learned *lots* of good stuff there.
09:10:32 <shapr> sjanssen: Would that really work?
09:10:44 <sjanssen> shapr: probably not very well
09:11:02 <syntaxfree> shapr: I think the problem is passing a class context to another class there.
09:11:18 <syntaxfree> you really want the property to apply to types for which (+) is defined, that is..
09:11:22 <syntaxfree> :t (+)
09:11:24 <lambdabot> forall a. (Num a) => a -> a -> a
09:11:30 <shapr> Yeah, good point.
09:11:34 <syntaxfree> types that are an instance of Num.
09:11:44 <sjanssen> shapr: I don't you can make the property test *every* Num, but you could enumerate some
09:12:03 <syntaxfree> sounds like a GADT job to me.
09:12:17 <shapr> Also, some Num instances will fail commutative tests.
09:12:28 <shapr> IEEE754 says so.
09:13:17 <shapr> Hm, didn't there used to be commutative, associative, etc extensions for QuickCheck in GHC?
09:13:33 <Cheery> is Comonad Context similar to State -monad?
09:13:49 <syntaxfree> floating point numbers are such a hatchett job.
09:14:00 <syntaxfree> whatever a "hatchett" is, haha.
09:14:04 <syntaxfree> @google define:hatchett
09:14:06 <lambdabot> No Result Found.
09:14:08 <shapr> hatchet
09:14:14 <syntaxfree> @google define:hatchet
09:14:16 <lambdabot> No Result Found.
09:14:19 <shapr> It's a small hand axe.
09:14:19 <syntaxfree> I'm not sure that's what I want
09:14:33 <Cheery> @OI
09:14:33 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
09:14:35 <syntaxfree> yes. I learned english from reading stuff like Salon.com
09:14:38 <Cheery> @hoogle OI
09:14:39 <lambdabot> Data.Graph.Inductive.Query.GVD.Voronoi :: type Voronoi a
09:14:39 <lambdabot> Data.Graph.Inductive.Query.ArtPoint :: module
09:14:39 <lambdabot> Data.Monoid :: module
09:14:54 <shapr> That's how the original meaning of "hack" came about. People created functional furniture from wood in a very short amount of time.
09:14:58 <syntaxfree> so sometimes those cliches are stuck in my head and I don't even know what a hatchet is.
09:15:12 <quicksilver> helmut: not really sure I understand your objection, maybe you don't want what I think you want...
09:15:51 <Saizan> ski: are you sure that cmap :: (a -> (b -> o) -> o) -> [a] -> ([b] -> o) -> o ? how does it get a (b -> o) to pass it to the first parameter?
09:17:05 <syntaxfree> I'm frustrated about a project euler problem.
09:17:11 <dolio> Cheery: "Defines the state-in-context comonad, which is dual to the state monad."
09:17:14 <ski> Saizan : 'cmap' would pass it to the argument function
09:17:15 <syntaxfree> @paste
09:17:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:17:21 <helmut> quicksilver: anyhow I'll do that. :-)
09:18:12 <hpaste>  syntaxfree pasted "Everything seems to be okay but I'm getting the wrong answer." at http://hpaste.org/1641
09:19:13 <ski> 17:07 <lambdabot> forall t a b. (t -> (a -> b) -> b) -> [t] -> ([a] -> b) -> b
09:19:20 <olsner> is it possible to serialize (to disk) lazy values unevaluated?
09:19:21 <ski> Saizan : lambdabot agrees with me
09:19:49 <LoganCapaldo> OT Straw poll: would you rather use C++ or K in a work environment?
09:20:21 <syntaxfree> K?
09:20:21 <Cheery> if IO would be a comonad, would main's typesig look like this?
09:20:21 <Cale> olsner: no, unfortunately. Well, it would be, theoretically, but it requires lots of runtime support.
09:20:22 <Saizan> ok, i just don't have a clue on how to write cmap then :)
09:20:22 <quicksilver> olsner: no
09:20:33 <Cheery> main :: IO () -> ()
09:20:37 <LoganCapaldo> syntaxfree: child of APL
09:20:48 <syntaxfree> APL/J is so weird.
09:20:55 <kc5tja> But so worth it.
09:20:59 * kc5tja _loves_ J.
09:21:00 <syntaxfree> It has second-order functions. But no third-order ones.
09:21:07 <syntaxfree> just verbs and adverbs.
09:21:23 <yorg123> Saizan: right now I have (t -> (a -> [a]) -> [a]) -> [t] -> [a], which is probably nqCPS ;)
09:21:24 <Cale> Cheery: there are some problems with IO being a comonad (It just really isn't one), but yes.
09:21:30 <ski> Cheery : 'main :: OI () -> ()' in that case
09:21:33 * ski nods
09:21:49 <quicksilver> main :: IO (OI () -> ())
09:22:09 <quicksilver> if you want to split the monadic and comonadic parts
09:22:09 <syntaxfree> oldmcdonald: EI (EI (IO ())))
09:22:11 <kc5tja> LoganCapaldo: I'd rather use K, personally.
09:22:27 <quicksilver> EI ( E -> IO () )
09:22:29 <syntaxfree> s/:/::
09:22:40 <LoganCapaldo> well looks like K is winning so far <g>
09:22:50 <Cheery> Cale: what problems?
09:22:51 <ski> yorg123 : yes .. the "answer/result/final" type should be polymorphic .. you have it to be a list type
09:22:54 <syntaxfree> can't you use matlab or something?
09:23:10 <ski> yorg123 : that is a clear indication of something nqCPS :)
09:23:12 <Cheery> I think Comonad feels paradoxical
09:23:15 <LoganCapaldo> syntaxfree: No. :)
09:23:30 <LoganCapaldo> (if that was directed at me)
09:23:31 <syntaxfree> GNU R is a very nice environment for matrix manipulation.
09:23:33 <syntaxfree> very LIspy.
09:23:34 <Cale> Cheery: well, first of all, what would the type of getChar be?
09:23:58 <Cheery> OI a -> Char
09:24:10 <Cale> but then that's a pure function
09:24:13 <ski> (/me suspects 'OI' wouldn't even work in a framework alike Clean ..)
09:24:14 <syntaxfree> as far as you're using one-letter languages.
09:24:20 <LoganCapaldo> I'm trying to choose between jobs, I don't get to dictate what lang they use (not yet anyway :) )
09:24:33 <syntaxfree> well, choose based on salary or perks.
09:24:38 <syntaxfree> choose a good chair.
09:24:42 <syntaxfree> choose a sexy secretary.
09:24:47 <Cheery> can you write into Context?
09:24:56 <MyCatVerbs> syntaxfree: Define "lispy"? Small syntax, powerful abstractions?
09:25:03 <Cheery> I'd like to see an example of function writing into Context.
09:25:13 <LoganCapaldo> well its C++ if I choose based on slaray/perks. Probably C++ for the chair too for that matter :)
09:25:18 <Cheery> the OI -example gave me empty
09:25:25 <LoganCapaldo> I don't think I get a secretary either way
09:25:26 <syntaxfree> ah, half-functional, full support for higher-order functions, CLOS-like OO.
09:25:39 <syntaxfree> LoganCapaldo: well, don't you get to stare at one either way?
09:25:50 <Cale> That particular case might not ordinarily be a problem, in that the (OI a) value could represent the entire outside world.
09:26:00 <syntaxfree> even if you have a good woman at home, it's nice to have a view. I'm guessing you don't get an office with a window or anything, of course.
09:26:19 <LoganCapaldo> hmm. No based on the office configs I don't think I get to stare at any secretaries
09:26:25 <Cale> But there'd be no way to sequence the getChar's which happen in a program.
09:26:25 <yorg123> ski: ok, thanks. I am wondering if the cfold example given in the YAHT is true CPS? There isn't any continuation passed to cfold' (or am i just not seeing it)?
09:26:35 <MyCatVerbs> syntaxfree, LoganCapaldo: this is all irrelevant. You're missing the *real* solution. Set up your office in a strip club.
09:26:35 <syntaxfree> MyCatVerbs: the syntax is the most regular and simple I've ever seen in a pro statistics package.
09:26:40 <yorg123> the function is defined in the tutorial as:
09:26:42 <yorg123> cfold' f z (x:xs) = f x z (\y -> cfold' f y xs)
09:26:42 <ski> yorg123 : i haven't seen it
09:27:10 <ski> that is a left-fold, yes ?
09:27:14 <LoganCapaldo> MyCatVerbs: clearly. Is that where you work? :)
09:27:18 * ski nods
09:27:26 <syntaxfree> I'm used to lots of pain in stuff like Stata and suchlike.
09:27:42 <yorg123> ski: the tutorial says: "It mimicks neither exactly. It's behavior most closely resembles foldr, but differs slightly in its treatment of the initial value."
09:27:56 <ski> yorg123 : in the case of tail-recursive functions (like left-folds) you could get away with not having the outer function taking a continuation, i think
09:28:00 <syntaxfree> MyCatVerbs: but anyway, I mostly referred to full lambda support and CLOS OO.
09:28:14 <chessguy> are HOFs the only requirement to be able to have monads?
09:28:37 <syntaxfree> The "monads in x lang" efforts have all been pointless.
09:28:44 <syntaxfree> someone implemented Id and Maybe in Ruby and stopped.
09:28:57 <ski> syntaxfree : even the clean one ?
09:29:00 <chessguy> why do they not work in other languages?
09:29:16 <LoganCapaldo> syntaxfree: would you like my ruby source code for the State monad?
09:29:17 <syntaxfree> Part of the problem is you need something equivalent to type classes to overload (>>=) and return.
09:29:40 <syntaxfree> so "monads in scheme", for example, was pointless IO encapsulation.
09:29:49 <ski> yorg123 : i still think it is basically 'foldl', CPSified
09:29:59 <helmut> I know there is some kind of "monadic map" could you give me a hint?
09:30:05 <ski> @type mapM
09:30:15 <lambdabot>     Ambiguous occurrence `mapM'
09:30:15 <chessguy> ski: that's a pretty big hint :)
09:30:15 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
09:30:15 <ski> @type Control.Monad.mapM
09:30:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:30:19 <MyCatVerbs> syntaxfree: oh. Full lambda support seemed the best candidate, but CLOS OO hadn't really occurred to me.
09:30:22 <syntaxfree> is anyone bored enough to look at my solution for problem 11 in project euler and hint me on what I got wrong?
09:30:24 <helmut> Thanks!
09:30:33 <ski> chessguy : sorry ?
09:30:37 <int-e> syntaxfree: nobody tried a list monad?
09:30:42 <chessguy> ski: just teasing
09:30:43 <syntaxfree> MyCatVerbs: Full lambda support could be haskelly, javascripty, etc. CLOS-like OO is typically Lispy.
09:31:01 <syntaxfree> int-e: not last time I checked. But I've been outta the programming loop since... uh, look at the date of my last blog post.
09:31:09 <Cale> yorg123: It's kind of misleading. cfold' in that tutorial uses the function parameter as if it was written in continuation passing style
09:31:13 <chessguy> ?go syntaxfree
09:31:15 <int-e> syntaxfree: that's sad really, all the examples you named are just sequential execution; monads will seem pointless then.
09:31:22 <lambdabot> http://syntaxfree.org/blog/index.php
09:31:22 <lambdabot> Title: syntaxfree
09:31:24 <Cale> Rather than being written in continuation passing style itself.
09:31:34 <syntaxfree> heh. who is that?
09:31:38 <syntaxfree> that is NOT me!
09:31:42 <chessguy> lol
09:31:47 <chessguy> ?go syntaxfree haskell
09:31:49 <lambdabot> http://swik.net/Haskell/Data.Syntaxfree
09:31:49 <lambdabot> Title: Haskell : Data.Syntaxfree - SWiK
09:31:49 <syntaxfree> man, I lost my #1 poisition at google.
09:32:06 <syntaxfree> I should've kept the rants comin'. :P
09:32:08 <yorg123> Cale: by "function parameter" you mean the "f" passed to cfold'?
09:32:11 <Cale> yes
09:32:12 <MyCatVerbs> syntaxfree: ah. Being a Scheme fanboy meant CLOS didn't really occur to me. =)
09:32:16 <syntaxfree> I made quite a splash in the beginning.
09:32:22 <ski> Cale : but 'foldl' is tail-recursive, so it's a simple matter of wrapping with '\k -> k (...)'
09:32:32 <Cale> ski: right
09:33:23 <helmut> ski: wow. that just worked. :-) (still a bit of magic of me)
09:33:51 <syntaxfree> jesii. What is swik.net and how it came to eat my blog?
09:34:18 <syntaxfree> and it ain't got none of the comments.
09:34:29 <syntaxfree> http://syntaxfree.wordpress.com
09:34:32 <lambdabot> Title: Data.Syntaxfree
09:35:10 <hpaste>  sjanssen pasted "testing on the type dimension" at http://hpaste.org/1642
09:35:22 <sjanssen> shapr: ping ^^^
09:36:16 <ski> @where jesii
09:36:16 <lambdabot> http://uncyclopedia.org/wiki/Jesii
09:36:42 <syntaxfree> Stata has one solid advantage over R.
09:36:53 <syntaxfree> Help lets you search over packages you haven't installed.
09:37:15 <syntaxfree> How the hell am I supposed to discover in which unintuitively-named package is an Oaxaca-Blinder decomposition or a Hausmann-Wu test in R?
09:37:37 <chessguy> ROFL
09:37:39 <syntaxfree> That's why most of the older econometricians hang on to Stata
09:37:40 <chessguy> this is hilarious
09:37:40 <chessguy> http://swik.net/Haskell
09:37:43 <lambdabot> Title: Haskell - SWiK
09:37:52 <LoganCapaldo> does Stata also come with a dictionary to explain what the heck an Oaxaca-Blinder is? :)
09:38:04 <syntaxfree> heh.
09:38:43 <syntaxfree> LoganCapaldo: I can send you a PDF on that stuff if you'd like :)
09:39:39 <syntaxfree> Oaxaca-Blinder decompositions are not hard to grok. The Hausmann-Wu stuff requires a lot of theory I'm afraid.
09:40:15 <shapr> sjanssen: whoa!
09:40:48 <shapr> awesome!
09:41:59 <chessguy> did anyone watch that video?
09:42:11 <syntaxfree> video?
09:42:19 <sjanssen> shapr: a fun test to try: quickCheck $ liftWit2 (\x y -> x == (x + y) - y)
09:42:25 <sjanssen> (notice how it always fails with Float, but never with Int)
09:42:59 <chessguy> syntaxfree:  http://swik.net/Haskell
09:43:03 <lambdabot> Title: Haskell - SWiK
09:43:29 <chessguy> hm. the first time i loaded it there was a video there
09:43:43 <LoganCapaldo> chessguy: I watched it
09:43:50 <LoganCapaldo> twas indeed hilarious
09:44:02 <LoganCapaldo> if you are speaking of the source labs ad
09:44:10 <chessguy> yes
09:44:32 <chessguy> try http://www.sourcelabs.com/
09:44:33 <LoganCapaldo> He said jib. hehe, jib
09:44:37 <lambdabot> Title: SourceLabs | Dependable Open Source Systems
09:45:04 <syntaxfree> the middleware video?
09:45:12 <chessguy> yeah
09:46:00 <syntaxfree> you can never bve too careful, wilson!
09:46:01 <syntaxfree> hahahahaa
09:46:46 <chessguy> "is it Tuesday already?"
09:47:11 <syntaxfree> hahahaah
09:47:19 <syntaxfree> that's AYBABTU material.
09:47:33 <syntaxfree> Hours worth of laughing just by repeating quotations.
09:47:37 <chessguy> ?vera AYBABTU
09:47:39 <lambdabot> No match for "AYBABTU".
09:48:34 <syntaxfree> ?vera vera
09:48:36 <lambdabot> *** "vera" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:48:36 <lambdabot> VERA
09:48:36 <lambdabot>      Just playing around, huh?
09:48:36 <lambdabot>  
09:48:38 <LoganCapaldo> all your base are belong to us
09:48:44 <chessguy> aha
09:49:02 <syntaxfree> someone set us up the bomb!
09:49:03 <chessguy> wonder what the 13th level reference is
09:49:57 <syntaxfree> let's (what?) down, cowboy.
09:50:04 <chessguy> settle
09:50:28 <syntaxfree> Wilson, I understand we're vulnerable to a virus
09:50:45 <syntaxfree> @remember SourceLabs Wilson, I understand we're vulnerable to a virus.
09:50:46 <lambdabot> Done.
09:50:50 <Cheery> > let funny (a,d) = (d, if d /= 0 then 1 else a-1) in loop funny
09:50:52 <lambdabot>  <Integer -> Integer>
09:50:58 <Cheery> > let funny (a,d) = (d, if d /= 0 then 1 else a-1) in loop funny 5
09:51:00 <lambdabot>  Exception: <<loop>>
09:51:42 <sjanssen> ghc++ for solving (some instances of) the halting problem
09:52:11 <syntaxfree> well, wouldn't some hoare logic solve some instances of the halting problem?
09:52:15 <Cheery> I wonder, how to express something like a factorial with such arrow?
09:52:36 <syntaxfree> I've looked at five minutes of dijkstra's predicate transformer calculus and can see it predicting infinite loops.
09:53:09 <sjanssen> syntaxfree: I'm sure there are plenty of systems that can do it
09:53:26 <sjanssen> but ghc's is actually enabled
09:53:44 <syntaxfree> isn't lambdabot just time-outing?
09:54:17 <syntaxfree> @karma c
09:54:17 <lambdabot> c has a karma of 15
09:54:33 <sjanssen> syntaxfree: no.  "Exception: <<loop>>" is an exception that ghc throws when it detects that the program is stuck
09:54:43 <syntaxfree> yay for purity!
09:54:48 <sjanssen> > last (repeat ())
09:54:52 <chessguy> c++
09:54:52 <lambdabot> Terminated
09:54:54 <chessguy> @karma c
09:54:54 <lambdabot> c has a karma of 15
09:55:06 <Cheery> @karma c--
09:55:07 <lambdabot> c-- has a karma of 2
09:55:10 * syntaxfree is watching the sourcelabs video nonstop.
09:55:22 <dcoutts_> c--++
09:55:24 <chessguy> > product [1..999]
09:55:25 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
09:55:30 <dcoutts_> @karma c--
09:55:31 <chessguy> > product [1..999999]
09:55:31 <lambdabot> c-- has a karma of 3
09:55:35 <lambdabot> Terminated
09:55:39 <chessguy> that's the timeout
09:56:03 <Cheery> @karma c++---
09:56:04 <lambdabot> c++--- has a karma of 0
09:56:07 <Cheery> @karma c++--
09:56:08 <lambdabot> c++-- has a karma of 0
09:56:25 <sjanssen> the timeout is best experienced with a Schwarzenegger voice
09:56:27 <syntaxfree> > product $ uncurry (*) $ do { x<-[1..9999]; y<-[1..9999]; return (x,y);}
09:56:28 <lambdabot>  Couldn't match expected type `(a, t)' against inferred type `[a1]'
09:56:37 <syntaxfree> :t uncurry
09:56:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:56:40 <Cheery> c++--
09:56:43 <Cheery> @karma c++
09:56:44 <lambdabot> c++ has a karma of -7
09:56:49 <syntaxfree> :t uncurry (*)
09:56:52 <lambdabot> forall a. (Num a) => (a, a) -> a
09:56:58 <sjanssen> syntaxfree: map
09:57:08 <syntaxfree> > product $ map ( uncurry (*) ) $ do { x<-[1..9999]; y<-[1..9999]; return (x,y);}
09:57:13 <lambdabot> Terminated
09:57:48 <Cheery> @src ArrowLoop (->)
09:57:49 <lambdabot> Source not found. My mind is going. I can feel it.
09:57:51 <syntaxfree> > product $ map ( uncurry (*) ) $ do { x<-[1..7]; y<-[1..7]; return (x,y);}
09:57:53 <lambdabot>  6823819180249038753817675898369448345600000000000000
09:58:31 <sjanssen> @type join (liftM2 (*)) [1.99]
09:58:34 <lambdabot> forall a1. (Fractional a1) => [a1]
09:58:41 <Cheery> ?src Control.Arrow.ArrowLoop (->)
09:58:42 <lambdabot> Source not found. My mind is going. I can feel it.
09:58:48 <int-e> > let foldT f [x] = x; foldT f xs = let t (x:y:xs) = f x y : t xs; t xs = xs in foldT f (t xs) in foldT (*) [1..100000]
09:58:49 <Cheery> ?src Control.Arrow.ArrowLoop
09:58:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:58:50 <lambdabot>  2824229407960347874293421578024535518477494926091224850578918086542977950901...
09:58:53 <Uto> syntaxfree:  Ive been skimming through your "Guido is wrong" article (meaning Ill probably get it all wrong too)
09:58:55 <Cheery> ?src ArrowLoop
09:58:56 <lambdabot> Source not found. It can only be attributed to human error.
09:59:00 <Cheery> @src ArrowLoop
09:59:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:59:06 <Uto> syntaxfree: and I was wondering if you already thought about putting langages (especially langage to interact with computers) into the light of emergence (as in Kim and other's view)
09:59:07 <olsner> @type enumerate
09:59:09 <lambdabot> Not in scope: `enumerate'
09:59:11 <Cheery> gah
09:59:25 <syntaxfree> Kim?
09:59:55 <Uto> let's say philosphical concept of emergence
10:00:02 <LoganCapaldo> @src LoopDeLoop
10:00:02 <lambdabot> Source not found. I feel much better now.
10:00:16 <chessguy> "Impending security breach?....oh no, it's nothing, they're just testing the patch now"
10:00:16 <syntaxfree> I have a few problems with the concept of emergence.
10:00:32 <syntaxfree> There's too much risk of slipping into pure holistic thinking.
10:00:45 <int-e> > product [1..7]^14
10:00:47 <lambdabot>  6823819180249038753817675898369448345600000000000000
10:01:23 <chessguy> boy i hope my boss never says "huh. i like the cut of your jib, son"
10:01:57 <syntaxfree> that's AYBABTU material I tell you.
10:02:08 <syntaxfree> "You can never be too careful, Wilson."
10:02:21 <chessguy> What you say?
10:02:31 <syntaxfree> Someone set us up the bomb.
10:02:50 <chessguy> Let's settle dwon there cowboy
10:03:26 <Uto> ok, fair enough, heard about someone who already did it then ? :P
10:03:38 <chessguy> One BILLION dollars MUAHAHAHAHAHAHAHAHAHAAAAAAAAA!
10:04:01 <syntaxfree> Uto: I'm not saying I disagree with the basic idea of emergence; I'm more saying that I don't understand it to its fullest.
10:04:02 <LoganCapaldo> > let billion = 10^9 in 1 * billion
10:04:04 <lambdabot>  1000000000
10:04:51 <Uto> oh ok, when I'll get my 25th hour per day I'll do it then
10:04:51 <int-e> one thousand million ...
10:04:52 <syntaxfree> @type forM (const GT) "justice"
10:04:55 <lambdabot>     Ambiguous occurrence `forM'
10:04:55 <lambdabot>     It could refer to either `forM', imported from Control.Monad.Writer
10:05:49 <LoganCapaldo> @type Control.Monad.Writer.forM (const GT) "justice"
10:05:51 <lambdabot>     Ambiguous occurrence `GT'
10:05:51 <lambdabot>     It could refer to either `GT', imported from Data.Ord
10:06:07 <chessguy> ?hoogle GT
10:06:08 <lambdabot> Prelude.GT :: Ordering
10:06:08 <lambdabot> Data.Generics.Aliases.GT :: Data a => a -> a -> GenericT'
10:06:08 <lambdabot> Data.Graph.Inductive.Query.Monad.GT :: data GT m g a
10:06:33 <chessguy> @type Control.Monad.Writer.forM (const PreludeGT) "justice"
10:06:35 <lambdabot> Not in scope: data constructor `PreludeGT'
10:06:36 <chessguy> @type Control.Monad.Writer.forM (const Prelude.GT) "justice"
10:06:39 <lambdabot>     Couldn't match expected type `[a]'
10:06:39 <lambdabot>            against inferred type `b -> Ordering'
10:06:42 <LoganCapaldo> @type Control.Monad.Writer.forM (const Prelude.GT) "justice"
10:06:45 <lambdabot>     Couldn't match expected type `[a]'
10:06:45 <lambdabot>            against inferred type `b -> Ordering'
10:07:06 <syntaxfree> > "for great justice"
10:07:08 <lambdabot>  "for great justice"
10:07:40 <LoganCapaldo> So what version of GHC has IsString?
10:07:51 <chessguy> ?hoogle isString
10:07:52 <lambdabot> No matches found
10:07:56 <LoganCapaldo> > "for great justice" :: IO ()
10:07:57 <lambdabot>  Couldn't match expected type `IO ()' against inferred type `[Char]'
10:08:47 <syntaxfree> > IO "for great justice" :: IO String
10:08:48 <bos> @hoogle isPrefix
10:08:49 <lambdabot>   Not in scope: data constructor `IO'
10:08:49 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
10:09:12 <LoganCapaldo> > return "for great justice" :: IO String
10:09:14 <lambdabot>  <IO [Char]>
10:09:38 <chessguy> > return "for great justice" :: IO [Char]
10:09:40 <lambdabot>  <IO [Char]>
10:09:45 <sjanssen> LoganCapaldo: 6.7
10:09:49 <syntaxfree> ~hmm.
10:09:55 <LoganCapaldo> @botupgrade
10:09:55 <lambdabot> Unknown command, try @list
10:10:00 <LoganCapaldo> @botsnakc
10:10:00 <lambdabot> :)
10:10:04 <chessguy> ok, enough fun for today. time to get back to work
10:10:05 <syntaxfree> notionally, Control.Monad.IO hides the IO data constructor?
10:10:37 <syntaxfree> or is IO not a data constructor at all, but  a tycon?
10:10:54 <LoganCapaldo> well you can't say IO "foo" you have to say IO (\(world, stuff) -> "foo") or some such
10:11:11 <LoganCapaldo> @src IO
10:11:12 <syntaxfree> oh, true
10:11:12 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:11:34 <sjanssen> syntaxfree: IO is a tycon, and if there is a data constructor called IO it is hidden
10:11:57 <sjanssen> (the representation of the data type associated with IO is not specified in the report
10:12:29 <LoganCapaldo> You could completely throw it away right?
10:12:49 <LoganCapaldo> newtype IO a = IO a
10:13:05 <LoganCapaldo> and just make your primitive IO functions side effecting
10:13:13 <SamB_XP> LoganCapaldo: er, no
10:13:18 <SamB_XP> not like that
10:13:24 <SamB_XP> that messes up the strictness!
10:13:31 <syntaxfree> couldn't you write the IO monad in terms of unsafePerformIO and unsafeInterleaveIO?
10:13:51 <SamB_XP> syntaxfree: ... huh?
10:13:55 <sjanssen> syntaxfree: probably not
10:13:55 <sjanssen> neither of those have a concept of sequence
10:14:21 <syntaxfree> unsafeInterleaveIO has a concept of sequence, doesn't it?
10:14:29 <SamB_XP> no!
10:14:32 <SamB_XP> that is the whole point
10:14:44 <sjanssen> you can write IO with two primitives: inSequence :: IO a -> (a -> IO b) -> IO b, and mkIO :: a -> IO a
10:14:55 <_dolio> > let fact (n, f) = (f n, \x -> if x == 0 then 1 else x * f (x - 1)) in loop fact 5 :: Int
10:14:57 <lambdabot>  120
10:15:06 <SamB_XP> sjanssen: isn't that just >>= and return?
10:15:11 <syntaxfree> how is loop different from fix?
10:15:13 <sjanssen> SamB_XP: exactly :)
10:15:21 <SamB_XP> @type loop
10:15:24 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
10:15:31 <syntaxfree> @type fix
10:15:34 <lambdabot> forall a. (a -> a) -> a
10:16:59 <SamB_XP> @src loop
10:16:59 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:17:01 <LoganCapaldo> woah, the type of fix looks really weird now that I think about it :)
10:17:10 <SamB_XP> LoganCapaldo: why does it look wierd?
10:17:12 <SamB_XP> @src fix
10:17:13 <lambdabot> fix f = let x = f x in x
10:17:16 <Cale> (P implies P) implies P
10:17:25 <LoganCapaldo> its like you produce somethig from nothing. huzzah fixpoints
10:17:30 <sioraiocht> @type fix
10:17:31 <int-e> @djinn (a -> a) -> a
10:17:33 <lambdabot> forall a. (a -> a) -> a
10:17:33 <lambdabot> -- f cannot be realized.
10:17:34 <SamB_XP> no
10:17:49 <int-e> djinn agrees :)
10:17:51 <SamB_XP> you just tie a function in a knot ;-)
10:18:21 <SamB_XP> @free fix :: (a -> a) -> a
10:18:21 <lambdabot> f . g = h . f => f (fix g) = fix h
10:18:40 <Cale> Nice free theorem
10:19:07 <SamB_XP> what does it mean?
10:19:37 <olsner> > sequence (replicate 5 [0,1])
10:19:41 <LoganCapaldo> it means that if f.g is equal to h .f then f (fix g) is the same as fix h. Clearly :)
10:19:48 <int-e> not a proof: f.g.g.g.g.g.g... = h.f.g.g.g.g... = h.h.h.h.h.h...
10:19:50 <SamB_XP> LoganCapaldo: yeah.
10:19:56 <syntaxfree> I wonder in what sense the concept of an invertible function can be built into Haskell.
10:20:12 <syntaxfree> and how it can help with verifying the conditions for free theorems.
10:20:17 <Cale> If f following g is the same as h following f, then f applied to the fixpoint of g is a fixpoint for h.
10:20:19 <shapr> syntaxfree: http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
10:20:23 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
10:20:31 <SamB_XP> syntaxfree: haskell? you've got to be kidding!
10:20:52 <SamB_XP> maybe you could do something with PreArrows or whatever you call them
10:21:12 <SamB_XP> but they would not be functions, exactly
10:21:17 <syntaxfree> well, it's certain that inv (*2) = (/2)
10:21:29 <syntaxfree> so, take map fusion.
10:21:31 <syntaxfree> @free map
10:21:34 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:22:00 <ski> nice
10:22:20 <SamB_XP> @free inv :: (a -> b) -> (b -> a)
10:22:21 <lambdabot> g . h = k . f => f . inv h = inv k . g
10:22:39 <LoganCapaldo> f . g = id => inv f = g ??
10:22:41 <syntaxfree> yeah, that's the property I was trying to enunciate.
10:22:44 <chessguy> ?help free
10:22:45 <lambdabot> free <ident>. Generate theorems for free
10:22:47 <ski> @free undefined
10:22:49 <lambdabot> f undefined = undefined
10:22:55 <ski> hehe
10:23:02 <LoganCapaldo> @free willy
10:23:05 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `willy'\n\n"
10:23:28 <SamB_XP> @free []
10:23:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:23:31 <SamB_XP> hah
10:23:36 <LoganCapaldo> @free beer
10:23:39 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
10:23:39 <ski> @free nil :: [a]
10:23:40 <lambdabot> $map f nil = nil
10:23:42 <syntaxfree> @. elite free (a -> b) (b -> a)
10:23:43 <lambdabot> P4+t3RN mAtch f4I1uRE IN Do 3XprEs5I0N a7 pluGiN/phR3e/FR33+heor3M.|-|s:54:20-34
10:23:57 <syntaxfree> @. elite free (a -> b) ->  (b -> a)
10:23:58 <kc5tja> /clear/echo -----------------------------------------------------------------------
10:23:58 <lambdabot> Pa7+eRN MA7c|-| fAilUR3 IN do 3XPREz$IoN 47 P1U9in/fR3E/fReE7HeOre/\/\.h5:54:20-34
10:23:59 <ski> @free cons :: a -> [a] -> [a]
10:24:00 <lambdabot> $map f . cons x = cons (f x) . $map f
10:24:01 <Cale> Here's another way to prove it. Suppose that x is a fixed point of g, so that g x = x, and that f . g = h . f. Then f x = f (g x) = h (f x), and so f x is a fixed point for h.
10:24:06 <LoganCapaldo> Is elite invertible? :)
10:24:31 <SamB_XP> LoganCapaldo: of course not
10:24:32 <syntaxfree> @. elite free inv ::  (a -> b) ->  (b -> a)
10:24:32 <ski> hehe, the free theorems of '[]' and '(:)' is basically the definition of 'map' :)
10:24:32 <lambdabot> g . H = K . ph => F . iNV h = in\/ k . G
10:24:49 <SamB_XP> @elite Hi!
10:24:50 <lambdabot> HI!
10:24:52 <kc5tja> I am interested in writing a GUI application in Haskell that will run in both Windows and Linux environments.  Is there a binding to a cross-platform GUI library available by any chance?
10:24:54 <SamB_XP> @elite Hi!
10:24:54 <lambdabot> hi!
10:25:04 <SamB_XP> it isn't even consistant!
10:25:08 <sjanssen> @free maybe :: b -> (a -> b) -> Maybe a -> b
10:25:09 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
10:25:11 <Cale> kc5tja: well, there's Gtk2Hs and WxHaskell
10:25:22 <LoganCapaldo> inv :: (a -> b) -> Maybe (b -> a) :)
10:25:30 <syntaxfree> by "consistent", you mean "surjective"?
10:25:31 <ski> 'elite' is not referentially transparent
10:25:45 <kc5tja> Except that GTK isn't really supported that well under Windows; WxHaskell (assuming it uses wxWidgets) is probably the better choice here.  Thanks!
10:25:46 <syntaxfree> @. elite free inv ::  (a -> b) ->  Maybe (b -> a)
10:25:47 <lambdabot> G . H = K . f => (phorAL1 q f1. f . q = F1 . g => P Q = f1) => $MAp_MAY83 P (inV H) = Inv x
10:25:50 <Cale> kc5tja: Gtk2Hs is rather well-supported. WxHaskell hasn't seen a release in quite some time, but it looks like work has started again and we should see a release soon.
10:26:02 <yorg123> Hah! I got it!
10:26:03 <yorg123> cmap3 f (x:xs) cont = f x (\y -> cmap3 f xs (\r -> cont (y:r)))
10:26:22 <yorg123> Ski, Cale, thanks a lot for your help. :)
10:26:22 <ski> yorg123 : congrats !
10:26:25 <LoganCapaldo> @djinn (a -> b) -> Maybe (b -> a)
10:26:26 <lambdabot> f _ = Nothing
10:26:27 <Cale> yorg123: :)
10:26:33 <syntaxfree> @free inv ::  (a -> b) ->  Maybe (b -> a)
10:26:34 <lambdabot> g . h = k . f => (forall q f1. f . q = f1 . g              =>               p q = f1) => $map_Maybe p (inv h) = inv k
10:26:42 <SamB_XP> hmm, is it just me, or is http://www.inform-fiction.org/I7/InformÏ.html totally messed up?
10:26:43 <Cale> kc5tja: if you're going to go with WxHaskell, try the development branch
10:27:14 <SamB_XP> hmm.
10:27:16 <LoganCapaldo> Ooooo!
10:27:22 <SamB_XP> apparantly that didn't copy/paste right
10:27:26 <Cale> (which is in darcs: darcs get http://darcs.haskell.org/wxhaskell)
10:27:27 <LoganCapaldo> class Invertible ???
10:27:28 <lambdabot> Title: Index of /wxhaskell
10:27:32 <SamB_XP> http://www.inform-fiction.org/I7/Inform 7.html
10:28:08 <syntaxfree> @free isJust
10:28:10 <lambdabot> isJust = isJust . $map_Maybe f
10:28:23 <ski> valid
10:28:28 <LoganCapaldo> and then you canmake instances with which the complier can use for fusion?
10:28:29 <syntaxfree> @free (map fromJust) . (filter isJust)
10:28:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:28:49 <ski> @free catMaybes
10:28:51 <syntaxfree> LoganCapaldo: I'm thinking of fusion all along.
10:28:52 <lambdabot> $map f . catMaybes = catMaybes . $map ($map_Maybe f)
10:28:57 <LoganCapaldo> I know
10:29:14 <LoganCapaldo> I just thought that might be a way to express to system the inverses
10:29:37 <syntaxfree> in what sense is (*2) the inverse of (/2), though?
10:29:38 <ski> data a <-> b = ...
10:29:38 <ski> ?
10:30:08 <LoganCapaldo> (*2) . (/2) = id ?
10:30:17 <syntaxfree> not for floating point types.
10:30:29 <syntaxfree> (3.75*2)/2
10:30:31 * SamB_XP wonders how hard it would be to do a decent Inform 7 ide in Emacs...
10:30:33 <LoganCapaldo> well thats just because fp sucks :)
10:30:34 <syntaxfree> > (3.75*2)/2
10:30:35 <lambdabot>  3.75
10:30:43 <syntaxfree> > (3.7599999999999999*2)/2
10:30:45 <lambdabot>  3.76
10:30:56 <ski> > 3.7599999999999999
10:30:58 <lambdabot>  3.76
10:31:13 <syntaxfree> 8-)
10:31:14 <olsner> > (*2) 2^31
10:31:16 <lambdabot>  4611686018427387904
10:31:18 <eumenides> @free Control.Arrow.loop
10:31:19 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:31:34 <ski> @free negate
10:31:37 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Num a) => a -> a\n"
10:31:44 <olsner> > 2^32
10:31:45 <lambdabot>  4294967296
10:31:52 <LoganCapaldo> @free negate :: Int
10:31:53 <lambdabot> negate = negate
10:31:59 * ski thinks 'free' can't handle constraints
10:31:59 <LoganCapaldo> boring :(
10:31:59 <syntaxfree> @free (Num a) => a -> a
10:32:00 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:32:06 <olsner> > (2^31) * 2
10:32:08 <lambdabot>  4294967296
10:32:11 <syntaxfree> @free unop :: Int -> Int
10:32:12 <lambdabot> unop = unop
10:32:24 <syntaxfree> @free binop :: Int -> Int -> Int
10:32:25 <lambdabot> binop = binop
10:32:27 <int-e> > 2^31 :: Int
10:32:28 <lambdabot>  -2147483648
10:32:33 <ski> you need some polymorphism in the type to make the free theorem nontrivial
10:32:34 <syntaxfree> isn't that the universal theorem?
10:32:34 <LoganCapaldo> @free (*0)
10:32:34 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:32:41 <syntaxfree> @free binop :: Int -> a
10:32:41 <lambdabot> f . binop = binop
10:32:52 <syntaxfree> whoa.
10:33:05 <LoganCapaldo> I'm confused
10:33:06 <syntaxfree> what the hell does that mean?
10:33:24 <SamB_XP> syntaxfree: the same as...
10:33:29 <SamB_XP> @free undefined
10:33:32 <lambdabot> f undefined = undefined
10:33:41 <syntaxfree> wait.
10:33:45 <LoganCapaldo> oh duh
10:33:52 <syntaxfree> no, no.
10:33:55 <Saizan> uuh nice
10:33:55 <SamB_XP> because obviously binop is essentially the same as "const undefined"
10:34:17 <Saizan> @free binop :: a -> b
10:34:17 <syntaxfree> SamB_XP: is it?
10:34:17 <lambdabot> g . binop = binop . f
10:34:29 <ski> '@free undefined' gets a theorem that insists that all functions are strict :)
10:34:36 <LoganCapaldo> @type const undefined :: Int -> a
10:34:39 <lambdabot> Int -> a :: forall a. Int -> a
10:34:41 <SamB_XP> ski: true ;-)
10:35:00 * ski ponders why that might be ..
10:35:06 <syntaxfree> const undefined is but one function of type Int -> a
10:35:23 <syntaxfree> @type const 7 :: Int -> a
10:35:24 <LoganCapaldo> Its the only function of Int -> a no?
10:35:26 <lambdabot>     No instance for (Num a)
10:35:26 <lambdabot>       arising from the literal `7' at <interactive>:1:6
10:35:27 <ski> or ..
10:35:38 <syntaxfree> @type const 7 :: (Num a) => Int -> a
10:35:40 <lambdabot> (Num a) => Int -> a :: forall a. (Num a) => Int -> a
10:35:51 <ski> no, it insists that all functions of type 'forall a0 a1. a0 -> a1' are strict !
10:35:54 <syntaxfree> ah, haha.
10:35:55 <SamB_XP> ski: because theorems that deal with lazy functions are less usefull?
10:36:17 <syntaxfree> @free a->b->c->a
10:36:17 <lambdabot> Extra stuff at end of line
10:36:22 <SamB_XP> ski: aren't they?
10:36:22 * ski ponders that
10:36:24 <syntaxfree> @free weird :: a->b->c->a
10:36:25 <lambdabot> f . weird x y = weird (f x) (g y) . h
10:36:32 * syntaxfree ponders.
10:36:45 <ski> hm .. it depends on how the quantifiers are laid out
10:37:23 <syntaxfree> @free weird :: a->b->a
10:37:24 <lambdabot> f . weird x = weird (f x) . g
10:37:24 <ski> is it 'forall a0 a1. forall f :: a0 -> a1. ...' or is it 'forall f :: (forall a0 a1. a0 -> a1). ...' ?
10:37:42 <LoganCapaldo> what the heck is g?
10:37:53 <dmwit> Any function.
10:37:54 <SamB_XP> in other words, f . weird x y z = weird (f x) (g y) (h z)
10:37:58 <ski> LoganCapaldo : 'g :: b0 -> b1'
10:38:19 <SamB_XP> for the first one...
10:38:26 <syntaxfree> @free weird :: (Maybe a) -> (Either a b)
10:38:27 <lambdabot> $map_Either f g . weird = weird . $map_Maybe f
10:38:38 <syntaxfree> what is map_Either?
10:38:55 <SamB_XP> it is an imaginary "map" function
10:39:02 <ski> mapEither :: (a0 -> a1) -> (b0 -> b1) -> (Either a0 b0 -> Either a1 b1)
10:39:08 <ski> the bifunctor map for 'Either'
10:39:08 <syntaxfree> fmap?
10:39:14 <SamB_XP> syntaxfree: nope
10:39:16 <LoganCapaldo> @type either
10:39:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:39:21 <syntaxfree> liftM2?
10:39:25 <ski> class BiFunctor f
10:39:26 <ski>   where
10:39:27 <LoganCapaldo> nope thats not it
10:39:28 <bd_> Hm, is there an ArrowChoice function for that...?
10:39:42 <ski>   bimap :: (a0 -> a1) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
10:39:46 <bd_> :t (>|<)
10:39:48 <lambdabot> Not in scope: `>|<'
10:39:53 <bd_> :t Control.Arrow.(>|<)
10:39:55 <lambdabot> Couldn't find qualified module.
10:40:12 <bd_> oh
10:40:14 <SamB_XP> @free $map_mapEither :: (a->b) -> (c->d) -> Either a c -> Either b d
10:40:15 <bd_> :t Control.Arrow.(+++)
10:40:15 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:40:17 <lambdabot> Couldn't find qualified module.
10:40:19 <SamB_XP> @free map_mapEither :: (a->b) -> (c->d) -> Either a c -> Either b d
10:40:19 <lambdabot> g . p = q . f => k . f1 = f2 . h => $map_Either g k . map_mapEither p f1 = map_mapEither q f2 . $map_Either f h
10:40:27 <bd_> :t (+++)
10:40:29 <syntaxfree> is map_Maybe fmap for Maybe?
10:40:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
10:40:33 <bd_> here we go
10:40:45 <bd_> :t ((+++) :: (a0 -> a1) -> (b0 -> b1) -> (Either a0 b0 -> Either a1 b1))
10:40:47 <ski> SamB_XP : i think the quantifiers for 'a0',.. should be outside the types of the mapped functions .. so it talks about all functions, i think
10:40:48 <lambdabot> forall a0 a1 b0 b1. (a0 -> a1) -> (b0 -> b1) -> Either a0 b0 -> Either a1 b1
10:40:49 <bd_> :)
10:41:01 <bd_> so @free should probably use that I guess
10:41:12 <SamB_XP> @free build
10:41:15 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `build'\n\n"
10:41:18 <SamB_XP> aww.
10:41:21 <SamB_XP> @hoogle build
10:41:22 <lambdabot> GHC.Exts.build :: ((a -> b -> b) -> b -> b) -> [a]
10:41:22 <lambdabot> Distribution.Simple.Build.build :: PackageDescription -> LocalBuildInfo -> Int -> [PPSuffixHandler] -> IO ()
10:41:22 <lambdabot> Data.Graph.Inductive.Internal.Heap.build :: Ord a => [(a, b)] -> Heap a b
10:41:25 <syntaxfree> ((+2) +++ (-3)) (5,5)
10:41:29 <SamB_XP> @free GHC.Exts.build
10:41:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:41:32 <ski> 'free' probably can't handle higher-ranked types, either
10:41:32 <syntaxfree> > ((+2) +++ (-3)) (5,5)
10:41:34 <lambdabot>  Couldn't match expected type `Either b b''
10:41:37 <SamB_XP> awwwwwwww
10:42:18 <syntaxfree> @. elite . free . djinn a -> Int -> a
10:42:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "a"
10:42:33 <syntaxfree> @djinn a -> Int -> a
10:42:33 <lambdabot> f a _ = raa (\ b -> b a)
10:42:45 <LoganCapaldo> raa?
10:42:48 * ski wish someone could kill 'raa'
10:42:53 <syntaxfree> @. free djinn a -> Int -> a
10:42:53 <LoganCapaldo> raa raa sis boom bah
10:42:54 <lambdabot> Extra stuff at end of line
10:43:04 <syntaxfree> raaaaaa
10:43:06 <syntaxfree> haahaahah
10:43:09 <ski> i inserted 'raa' when i was testing something .. now i can't get it to dissappear
10:43:14 <syntaxfree> they should call it rah.
10:43:23 <ski> raa :: forall a. ((a -> Void) -> Void) -> a
10:43:35 <ski> (in the above case it is a benign use, though)
10:43:38 <sjanssen> @djinn-del raa
10:43:51 <sjanssen> @djinn a -> Int -> a
10:43:52 <lambdabot> f a _ = a
10:44:07 <syntaxfree> @pl f a _ = a
10:44:07 <lambdabot> f = const
10:44:22 <syntaxfree> @. pl djinn a -> b -> Float -> a
10:44:22 <lambdabot> f = const . const
10:44:24 <ski> (ok .. i tried 'djinn-clr' but it didn't want ..)
10:44:28 <bd_> > ((+2) *** (flip (-) 3)) (5,5) -- @ syntaxfree
10:44:30 <lambdabot>  (7,2)
10:44:48 <olsner> @src raa
10:44:49 <lambdabot> Source not found. Where did you learn to type?
10:44:52 <syntaxfree> cool.
10:44:53 <ski> olsner : no
10:44:54 <syntaxfree> @src rra
10:44:55 <lambdabot> Source not found. You type like i drive.
10:44:59 <syntaxfree> @src arr
10:45:00 <lambdabot> Source not found. My pet ferret can type better than you!
10:45:05 <syntaxfree> @type arr
10:45:07 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:45:09 <ski> olsner : it can't be written in haskell
10:45:15 <syntaxfree> I am a pirate and I'm okay.
10:45:27 <syntaxfree> I code all night and I sleep all day.
10:45:34 <syntaxfree> @type rra
10:45:36 <lambdabot> Not in scope: `rra'
10:45:42 <ski> @arr
10:45:43 <lambdabot> Swab the deck!
10:45:51 <ski> @pure
10:45:52 <lambdabot> Maybe you meant: more part url
10:45:52 <syntaxfree> @arr arr
10:45:53 <lambdabot> I'll keel haul ya fer that!
10:46:05 <bd_> @. elite arr
10:46:05 <ski> ('pure' ought to be an alias for 'arr')
10:46:05 <lambdabot> smAR71Y me Lazs
10:46:16 <syntaxfree> @. google . elite . arr
10:46:18 <lambdabot> No Result Found.
10:46:19 <SamB> ski: that would be a silly joke ;-)
10:46:29 <syntaxfree> @. google arr
10:46:31 <lambdabot> http://themeparks.about.com/cs/disneyparks/a/potc_3.htm
10:46:31 <lambdabot> Title: Pirates of the Caribbean song
10:46:35 <ski> SamB : indeed, that was the intension
10:46:41 <SamB> @. google arr
10:46:44 <lambdabot> http://parslow.com/mornington/move.pl?323&start=1
10:46:44 <lambdabot> Title: Mornington Crescent: Arrrr!
10:46:55 <syntaxfree> that's a nice way to find pir8 l1nkz.
10:47:00 <syntaxfree> @. google arr
10:47:03 <lambdabot> http://www.thefreedictionary.com/aye
10:47:03 <lambdabot> Title: aye - definition of aye by the Free Online Dictionary, Thesaurus and Encyclopedi ...
10:47:11 <syntaxfree> @. quote arr
10:47:11 <lambdabot> No quotes for this person. My pet ferret can type better than you!
10:47:18 <syntaxfree> @. quote . google . arr
10:47:21 <lambdabot> No quotes for this person. It can only be attributed to human error.
10:47:26 <syntaxfree> @. google . quote
10:47:27 <lambdabot> http://mla.libertine.org/tmda-users/2003-08/msg00156.html
10:47:27 <lambdabot> Title: Postfix&tmda: TypeError: not enough arguments for format string
10:47:37 * syntaxfree drops dead.
10:47:38 <SamB> must have been a GHC quote
10:47:40 <ski> @fix google
10:47:41 <lambdabot> Maybe you meant: faq ft id
10:47:44 <SamB> @. google . quote
10:47:46 <lambdabot> http://mla.libertine.org/tmda-users/2003-08/msg00156.html
10:47:46 <lambdabot> Title: Postfix&tmda: TypeError: not enough arguments for format string
10:47:52 <cameron> @. google keal
10:47:52 <SamB> ski: I'm pretty sure google is strict
10:47:54 <lambdabot> http://francischolle.com/index.php/francis_cholle/conferences/
10:47:55 <lambdabot> Title: conferences + seminars  intuitive intelligence &middot; francis cholle
10:48:08 <sioraiocht> SamB: do you have that link to your Brainfuck interpreter?
10:48:16 <syntaxfree> @help keal
10:48:17 <lambdabot> keal. Talk like Keal
10:48:20 <SamB> @oldwiki ShortExamples/BFInterpreter
10:48:21 <lambdabot> http://www.haskell.org/hawiki/ShortExamples/BFInterpreter
10:48:21 <syntaxfree> who?
10:48:22 <syntaxfree> @keal
10:48:23 <lambdabot> i need math friendly compiler to compile for jvm or flash
10:48:24 <eumenides> @quote gore
10:48:25 <lambdabot> diffbavis says: [diffbavis] > (sum.map ord) "al gore"   [lambdabot] 666
10:48:34 <syntaxfree> oh. keal is good.
10:48:40 <syntaxfree> @keal
10:48:40 <lambdabot> ithink has to do with hardcased government failsafe in chip
10:48:41 <SamB> sieni: there you are
10:48:45 <ski> @keal
10:48:46 <lambdabot> my proof show math is broken right now
10:48:56 <SamB> really ought to move it off the old wiki...
10:49:03 <SamB> I wish I knew a nice way to migrate with history...
10:49:06 <syntaxfree> @quote bush
10:49:07 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
10:49:27 <syntaxfree> @quote functors
10:49:28 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
10:49:32 <ski> instance Monad NuclearWaste
10:50:19 <ski> safeLaunch :: NuclearWaste ()
10:50:29 <SamB> is BF supposed to start with a blank tape or not?
10:52:00 <sioraiocht> SamB: no, 0 through 29,999 are supposed to contain 0
10:52:03 <SamB> where do short examples go on the haskellwiki?
10:52:08 <SamB> sioraiocht: ah.
10:52:25 <olsner> @hoogle raa
10:52:26 <lambdabot> No matches found
10:52:41 <ski> olsner : it doesn't exists (and cannot) in haskell, ok ?
10:52:57 <SamB> well, I don't have the copyright on the changes people made to my interpreter... so I think I'm just going to copy the last version Cale submitted...
10:53:47 <olsner> mmkay... then what is raa?
10:53:47 <sioraiocht> > read "c" :: Int
10:53:52 <lambdabot>  Exception: Prelude.read: no parse
10:54:51 <ski> olsner : it stands for "reduction ad absurdum" .. which, as i type it out, begin to doubt is the correct name for the thing i intended
10:55:26 <ski> (that is latin and means "from the absurd, whatever you wish (can be inferred)")
10:56:06 <cameron> well, that latin means something more like "to reduce to an absurdity"
10:56:18 <cameron> the latter is what logicians mean by it :-)
10:56:41 <ski> no, i'm confused :)
10:56:47 <ski> right
10:57:51 <ski> *"ex falso quodlibet"* means "from something false, whatever you wish (can be inferred)" !
10:57:52 <olsner> so "raa" just refers to the fact that given P and \+P anything can be inferred? then what does something like raa (\b -> b a) mean?
10:57:59 * ski was confusing things :)
10:58:10 <syntaxfree> ex falso quodlibet means "true by vacuity"?
10:58:54 <ski> ex_falso_quodlibet :: Not a -> a -> Void
10:58:57 <ski> @djinn Not a -> a -> Void
10:58:58 <lambdabot> f a = a
10:59:19 <ski> which is provable in intuitionistic logic, as shown
10:59:31 <Cale> syntaxfree: it's "from a contradiction, anything follows"
10:59:39 <ski> reductio_ad_absurdum :: Not (Not a) -> a
10:59:52 <ski> is not provable in intuitionistic logic, however
11:00:02 <Eidolos> ?hoogle Floating -> Integer
11:00:02 <cameron> @djinn Not (Not a) -> a
11:00:03 <lambdabot> No matches, try a more general search
11:00:03 <lambdabot> -- f cannot be realized.
11:00:28 <syntaxfree> wait. so an intuitionistic basis to mathematics outlaws proofs by raa?
11:00:32 <Eidolos> ?hoogle (Floating a) => a -> Integer
11:00:33 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
11:00:33 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
11:00:33 * ski was adding 'raa :: Not (Not a) -> a' as an axiom to 'djinn' some time ago, to try something out
11:00:38 <cameron> syntaxfree: that's the entire point of intuitionistic logic
11:00:48 <ski> syntaxfree : of course :)
11:00:49 <cameron> syntaxfree: raa is "not intuitive"
11:00:59 <syntaxfree> how does that relate to constructivism in mathematics?
11:01:20 <syntaxfree> constructivism is about not relying on existence proofs to assume objects away, right?
11:01:20 <ski> actually, 'raa' is intuitive (well, somewhat, at least :) in linear logic
11:01:25 <LoganCapaldo> two nots don't make a right?
11:01:26 <Cale> syntaxfree: Proof by contradiction can end up proving that certain things exist without actually constructing an example.
11:01:31 <Eidolos> I guess ceiling is what I want
11:01:38 <bd_> :t build
11:01:41 <lambdabot> Not in scope: `build'
11:01:46 <bd_> :t GHC.Exts.build
11:01:49 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
11:01:54 <syntaxfree> Cale: the proof of the density of real numbers I saw was by contradiction.
11:02:07 <syntaxfree> Cale: do you know what's grey and proves the uncountability of real numbers?
11:02:46 * LoganCapaldo is expecting a punchline
11:02:47 <Cale> hmm, Cantor's diagonal aardvark?
11:02:52 <syntaxfree> hahaha.
11:03:00 <syntaxfree> That's even better than the original punchline.
11:03:01 <syntaxfree>  a punchline
11:03:19 <syntaxfree> I like making Cantor diagonal jokes. They piss everyone off.
11:03:21 <ski> the original being ?
11:03:24 <LoganCapaldo> I don't get it
11:03:27 <syntaxfree> Cantor's diagonal elephant.
11:03:34 <syntaxfree> @google cantor's diagonal
11:03:40 <lambdabot> http://en.wikipedia.org/wiki/Cantor's_diagonal_argument
11:03:40 <lambdabot> Title: Cantor's diagonal argument - Wikipedia, the free encyclopedia
11:03:59 <SamB> does haskellwiki have subpages turned off?
11:04:11 <SamB> in the main namespace, I mean
11:04:56 <Cale> What's sour and shows that every ring has a maximal ideal?
11:05:01 <syntaxfree> I wonder if it'd be possible to design a strictly constructivist undergraduate degree in mathematics.
11:05:19 <Cale> syntaxfree: You'd have to leave out most of analysis.
11:05:20 * syntaxfree goes fetch his algebra book.
11:05:47 <LoganCapaldo> Ok so know I know the diagonal thing. I still don't get the joke :)
11:05:47 <ski> Cale : can't one just weaken it somewhat ?
11:05:51 <syntaxfree> Cale: even with that alternative "infinitesimal calculus" approach someone was proposing some time ago?
11:05:57 <LoganCapaldo> s/know/now/
11:05:58 * ski hasn't read Bishop
11:06:03 <cameron> Zorn's lemon (ahahaha)
11:06:20 <ski> syntaxfree : which one ?
11:06:21 <syntaxfree> The other day I was reading Karl Marx's mathematical manuscripts.
11:06:41 <Cale> well, you lose fundamental things like the Hahn-Banach theorem.
11:06:53 <Cale> Constructivists hate the axiom of choice :)
11:06:58 <ski> well
11:07:15 <syntaxfree> He basically argues by the method of materialistic dialectics that differentiation means dividing by zero.
11:07:41 <Cale> heh
11:07:51 <syntaxfree> it's somewhere at marxists.org
11:07:59 <Cale> I think I might have seen that :)
11:08:01 <syntaxfree> @google calculus site:marxists.org
11:08:04 <lambdabot> http://www.marxists.org/reference/archive/hegel/works/hl/hl274.htm
11:08:04 <lambdabot> Title: Science of Logic - Quantum
11:08:16 <syntaxfree> @google mathematical manuscripts site:marxists.org
11:08:18 <lambdabot> http://www.marxists.org/archive/marx/works/1881/mathematical-manuscripts/index.htm
11:08:19 <lambdabot> Title: Marx's Mathematical Manuscripts 1881
11:08:53 <syntaxfree> Lenin's "Materialism and empiriocriticism" apparently sustained that teletransportation should be possible.
11:09:37 <syntaxfree> http://www.marxists.org/archive/lenin/works/1908/mec/index.htm
11:09:38 <lambdabot> Title: Lenin: MATERIALISM and EMPIRIO-CRITICISM
11:09:39 <fezsentido> the unrestricted axiom of choice... Certain constructivist theories have analogues very close to it
11:10:27 <ski> Cale : roconnor had an arcticle at his blog where he say's he's pro-choice :) .. unfortunately i can't find his blog :/
11:10:32 <Cale> Well, if you're a finitist, or you reject the powerset axiom, then choice is easier to cope with as a constructivist.
11:10:55 <Cale> ski: Waterloo sells t-shirts which say Pro (axiom of) Choice
11:11:05 <Cale> where (axiom of) is written in tiny letters
11:11:10 <Wild_Cat> should I be afraid that I open up a chat window to a channel about a programming language, to find people in it talking about marxism?
11:11:11 <shapr> Does anyone know if cryptolib has some way to generate keys for the encryptions it supports?
11:11:12 <ski> (iirc he's pro extensional choice, but against intensional choice (was it the other way around ?))
11:11:29 <cameron> heh
11:11:30 <Cale> Wild_Cat: don't be afraid, comrade.
11:11:32 <ski> (roconnor is definitely a constructivist)
11:12:03 <Cale> I think unduly restricting oneself to the constructible is kind of pointless.
11:12:04 <Wild_Cat> da. In Soviet Russia, languages program YOU!!
11:12:04 * ski 's even proved it in Alfa/Agda :)
11:12:28 <SamB> ski: you proved that a person fits a certain label in Alfa/Agda?
11:12:31 <potts> I am amazed as always by the arcane knowledge on display here!
11:12:45 <syntaxfree> Cale: if Marx had a deeper notion of mathematical logic, I think he'd be a constructivist, though.
11:12:51 <ski> no, i proved whichever version of choice roconnor said he's pro (i can't recall which)
11:12:53 <syntaxfree> I wonder why soviet mathematics never developed on that.
11:13:05 <shapr> potts: #haskell knows lots of surprising stuff.
11:13:06 <ski> (i didn't know at the time it was equivalent to some version of choice)
11:13:10 <cameron> potts: I find that lurking in #haskell is a great way to feel humble
11:13:25 <Cale> I mean, it's nice to keep track of what's done in a constructive way, and what's just existential, but I don't think it's worthwhile to ignore results just due to non-construction.
11:13:25 <shapr> cameron: Yeah, for me too... and I started this channel!
11:13:35 <potts> Marx on calculus -- who knew? (Well, who wanted to know, too, but that's not the point : )
11:13:49 <shapr> #haskell - keeping you humble for 6 years 1 week!
11:13:50 <syntaxfree> @pl 15:11 < ski> (roconnor is definitely a constructivist) 15:12  * ski 's even proved it in Alfa/Agda :)
11:13:50 <lambdabot> (line 1, column 12):
11:13:51 <lambdabot> unexpected ">"
11:13:51 <lambdabot> expecting letter or digit, variable, "(", operator, space or end of input
11:13:51 <lambdabot> ambiguous use of a non associative operator
11:13:51 <arcatan> no for me, I know everything
11:13:54 <syntaxfree> oops.
11:14:04 <Cale> I mean, every vector space having a basis is really nice. :)
11:14:04 <shapr> dons: Hey, we just missed the six year anniversary of #haskell!
11:14:08 <syntaxfree> @remember  15:11 < ski> (roconnor is definitely a constructivist) 15:12  * ski 's even proved it in Alfa/Agda :)
11:14:09 <lambdabot> Done.
11:14:18 <Maddas> cameron: I found that it can be dangerous in that it changes your idea of what constitutes smalltalk :)
11:14:18 <Cale> I don't really care that sometimes I can't actually write that basis down.
11:14:23 <ski> classicallity is a bit like side-effects .. it sometimes makes things more concise .. but it is also dangerous
11:14:34 <ski> syntaxfree : ty :)
11:14:46 <syntaxfree> bah, stop being quotable.
11:14:52 <syntaxfree> @remember 15:14 < ski> classicallity is a bit like side-effects .. it sometimes makes things more concise .. but it is  also dangerous
11:14:52 <lambdabot> Done.
11:15:02 * ski laughs
11:15:05 <Cale> Well, for programming languages and type systems, I'll agree that other logics are probably more appropriate.
11:15:12 <Cale> But for mathematics, it's another matter entirely.
11:15:32 <Cale> Really, I don't think we should put any restrictions on what sorts of axioms we'll accept.
11:15:36 <ski> why isn't type theory a part of math ?
11:15:44 <Cale> I mean general mathematics.
11:16:09 <cameron> Mathematicians I've spoken don't seem to want to subscribe to a single formal logic for describing all of maths
11:16:14 <syntaxfree> It'd be interesting to see what happens to the theoretical ends of my field if a strict intuitionistic discipline is kept.
11:16:29 <Cale> Also, Platonism and mathematical realism are fundamentally flawed viewpoints.
11:16:30 <cameron> and would prefer the people that care about such differences stuck to their own little world and never bothered anyone else...
11:16:43 <ski> m, yes .. i think i agree on not putting that kind of restriction into math .. (which is of course why classical logic oughtn't be the default ! ;)
11:16:48 <hpaste>  Eidolos pasted "prime factorization -- type issues" at http://hpaste.org/1643
11:16:56 <cameron> Cale: oooh, harsh
11:16:58 <SamB> personally I prefer to accept only small axioms
11:17:01 <Cale> ski: oh?
11:17:12 <Cale> ski: It's what we've developed the farthest.
11:17:23 <Cale> (which is why it is popular)
11:17:40 <syntaxfree> a lot of right-leaning economic theory is based on proving the existence of things that aren't properly constructed.
11:17:41 <Cale> cameron: yep, but it's a really easy position to defend :)
11:17:58 <ski> hm, ok i may be writing too far ahead of my thought .. but how easy is it to embed intuitionistic logic in classical logic (including proofs) ?
11:18:03 <syntaxfree> like proving the existence of economic general equilibria in infinite-dimensional differentiable manifolds.
11:18:22 <SamB> Cale: so what viewpoints are not fundamentally flawed?
11:18:30 <ski> (the other direction is basically CPS)
11:18:50 <Cale> ski: In the logic directly it's hard, but once you have (e.g.) set theory, it's not so hard.
11:19:32 <ski> Cale : ok (one more thing to look up ..)
11:19:42 <syntaxfree> this may come off as perfectly ignorant, but are there intuitionistic modal logics?
11:19:51 <ski> syntaxfree : i believe so
11:19:53 <syntaxfree> (I can't see why there wouldn't, but...)
11:19:57 <Cale> SamB: My current position is that truth and falsity are just labels which we apply to statements according to rules which are perhaps inspired by the world we live in, but which are ultimately arbitrary.
11:19:57 <cameron> syntaxfree: don't see why not
11:20:06 <ski> syntaxfree : look for papers on staged computation
11:20:30 <Cale> Mathematics is not a science, because it doesn't use the scientific method.
11:20:40 <cameron> Cale: that doesn't really feel very comforting, though
11:20:42 <syntaxfree> I'm especially interested in temporal logics for econometric inference.
11:20:51 <cameron> Agreed on maths != science
11:20:56 <Cale> cameron: Nobody claimed it had to be :)
11:21:01 <SamB> however...
11:21:06 * cameron grins.
11:21:12 <syntaxfree> Cale: I disagree. I count mathematics, philosophy and even theology as scientific endeavours.
11:21:27 <syntaxfree> Science is a discourse on falsifiable statements mediated by a theoretical corpus.
11:21:34 <Cale> syntaxfree: You have a much broader definition of "science" than I'd usually allow.
11:21:41 <SamB> if maths are used in scientific theories...
11:21:45 <ski> in swedish, i count math as part of 'vetenskap' ('Wissenshaft' in german) ..
11:21:55 <cameron> syntaxfree: philosophy and theology don't produce falsifiable statements :P
11:21:59 <ski> (more specifically 'formell vetenskap')
11:22:10 <fezsentido> I hereby proclaim myself as a finitist, thus i believe in the finite
11:22:20 <Cale> Statements in mathematics are not falsifiable in the same sense as scientific theories.
11:22:24 <syntaxfree> they produce statements that are falsifiable inside a theoretical field of discourse.
11:22:53 <SamB> cameron: sure they do -- maybe. its just that you usually have to die to find out the truth/falsity thereof -- maybe
11:23:04 <Eidolos> can someone help decode my type issues? http://hpaste.org/1643
11:23:15 <cameron> SamB: fair enough ... but you first, okay? ;-)
11:23:18 <syntaxfree> The field shifts much more slipperily in philosophy than in electrical engineering, sure.
11:23:24 <Cale> syntaxfree: statements in mathematics are true or false according to arbitrarily selected rules.
11:23:26 <SamB> cameron: no guarentees
11:23:44 <syntaxfree> Cale: yes. But as soon as you fix a theoretical corpus, things are either true or false.
11:23:47 <Cale> and there's no way to make that selection of rules any less arbitrary
11:23:49 <ski> syntaxfree : doesn't goedel incompleteness seem to suggest that in general, formulae isn't falsifiable ?
11:23:53 <syntaxfree> Cale: much like in theology and philosophy.
11:23:57 <Eidolos> I also get problems like "No instance for (RealFrac Integer) arising from use of `ceiling'"
11:24:10 <Cale> syntaxfree: yeah, that's why "science" is an inappropriate word.
11:24:28 <Cale> It does a disservice to actual science.
11:24:28 <SamB> syntaxfree: wait a minute
11:24:36 <syntaxfree> Restricting "science" to deal with "reality" depends on a slippery notion of "reality".
11:24:37 <SamB> syntaxfree: you subscribe to the law of excluded middle?
11:24:43 <Cale> (and to these other disciplines)
11:24:59 <hpaste>  titus annotated "prime factorization -- type issues" with "(no title)" at http://hpaste.org/1643#a2
11:25:11 <Cale> syntaxfree: I think reasonable people can come to some consensus on what it means to observe something.
11:25:18 <ski> (the "law of excluded middle" is basically just 'id')
11:25:30 <syntaxfree> Cale: basically because we have the same brain structures.
11:25:42 <syntaxfree> Cale: the same "categories of pure reason", as Kant would say.
11:25:43 <SamB> > if undefined then 1 else 2
11:25:45 <lambdabot>  Undefined
11:25:46 * syntaxfree is a kantian idealist.
11:26:09 <cameron> Cale: there's a certain sense in which these arbitrary rules of mathematics "describe the world"
11:26:12 <ttt-> pretty rare
11:26:26 <Cale> syntaxfree: sure. I mean, the very fact that we can claim to communicate with one another is predicated on that assumption.
11:26:40 <syntaxfree> Cale: we can't really communicate with each other.
11:26:43 <Cale> cameron: There are many senses in which they don't.
11:26:44 <SamB> cameron: certain sets of them do
11:26:49 <clanehin> Now if only unreasonable people could come to a consensus about what reasonable means.
11:26:49 <SamB> most sets do not
11:27:00 <kolmodin> dons, dcoutts_: you've got mail
11:27:01 <syntaxfree> We can imperfectly translate complex, incommunicable thoughts to a common simplified language that throws most interesting things away.
11:27:21 <SamB> note that I am using ruleset in the game-like sense, not in any set-theoretical sense
11:27:27 <Cale> syntaxfree: sure. We can do something useful enough about it though.
11:27:42 <ttt-> what kind of thoughts would be incommunicable?
11:27:44 <syntaxfree> sure. you can also do something useful about black sorcery.
11:27:47 <Cale> syntaxfree: Otherwise, we wouldn't be having this conversation.
11:28:00 <Maddas> ttt-: *gestures wildly*
11:28:05 <kolmodin> I'm out for a bit, bbl
11:28:05 <SamB> Maddas: hehe
11:28:17 <Eidolos> titus: thanks :) I tried adding a type to prime_factors_of before but it didn't work; fromIntegral was what I needed (I think)
11:28:18 <fezsentido> We are assuming people correctly assign the concepts in their minds even if the language is quite opaque
11:28:18 <syntaxfree> "Usefulness" is in the eye of the beholder :)
11:28:25 <Cale> Sure.
11:28:31 <Cale> I'll agree with that.
11:28:38 <syntaxfree> fezsentido: No. I'm saying the concepts are built inside people's minds.
11:28:47 <syntaxfree> There is no concept outside the human brain.
11:28:52 <SamB> fortunately most humans have approximately the same occular facilities
11:29:14 <SamB> syntaxfree: ah. so writing is magic then?
11:29:16 <syntaxfree> Cale: for all its vices, religion does quite useful things. Religion is not science, though.
11:29:17 <Cale> I'll also make the claim that the only way we can measuring stick of truth is a personal sense of utility. (Or beauty, if you want.)
11:29:18 <fezsentido> I am anti-antroposcentristic... I even believe in strong AI :)
11:29:28 <fezsentido> So i dont agree that it's specific to the human mind
11:29:29 <Cale> er, heh
11:29:36 <syntaxfree> Ok, maybe I sounded more anthropocentric than I should.
11:29:37 <Cale> that sentence changed hafway through
11:29:44 <Cale> half
11:29:49 <Cale> I should get another coffee :)
11:29:55 <syntaxfree> sure, a strong AI or a chimp could develop consciousness and fabricate concepts inside its brain.
11:29:59 <Cale> "I'll also make the claim that the only measuring stick of truth is a personal sense of utility. (Or beauty, if you want.)"
11:30:07 <SamB> I expect other races would come up with similar laws of physics...
11:30:10 <fezsentido> ok dokie then :)
11:30:21 <ski> syntaxfree : and an electron ?
11:30:28 <syntaxfree> what I'm radically opposed to is "realism".
11:30:33 <ttt-> unless they perceive other dimensions than us
11:30:34 <titus> Eidolos: if your function won't type-check with the type you *think* it should have, then you have a problem so resist the temptation to take out the type annotation :-)
11:30:35 <fezsentido> SamB: maybe they would have different explanations... But probably similar mathematics
11:30:57 <Cale> I don't believe in objective reality, simply because I think it's a mostly useless concept.
11:30:59 <syntaxfree> The bizarre idea that things are "real" somehow, as if they had consciousness and souls and existed beyond one noticing them or not.
11:31:11 <dmwit> ?remember bos <mauke> why does it seem like existentials let me create types at runtime? <bos> um, to get to the other side?
11:31:12 <lambdabot> Done.
11:31:17 <Eidolos> titus: :)
11:31:19 <SamB> and probably their physics books would not contain problems involving fruit striking the head of a physicist
11:31:54 <Cale> fezsentido: I think alien mathematics would look very different.
11:32:09 <SamB> titus: wouldn't it be instructive to take it out and see what you get?
11:32:24 <dmwit> Cale: Beyond mere symbol differences?
11:32:25 <syntaxfree> I do agree that there is a reality-in-itself, but it's inintelligible.
11:32:25 <Cale> At least, if there was some part of their way of thinking which we could compare to mathematics at all.
11:32:26 <ski> Cale : not even things like groups ?
11:32:46 <syntaxfree> It's a fluid mass of spacetime, not a bunch of neat little objects interacting with each other.
11:32:46 <Cale> The axioms could be completely different and still useful.
11:33:08 <titus> SamB: yes, definitely. My advice was flippant.
11:33:24 <syntaxfree> alien mathematics is really a *fascinating* debate.
11:33:25 <SamB> mass of spacetime?
11:33:33 <fezsentido> Cale: could be... Although there would be consensus with our Math and theirs in terms of results?!
11:33:34 <SamB> I think it is a really boring debate
11:33:41 <SamB> because we don't have anything to look at
11:33:44 <Cale> fezsentido: How could there be?
11:33:44 <cameron> syntaxfree: nah, it seems a bit wanky to be honest
11:33:55 <cameron> because (what SamB said)
11:34:04 <Cale> fezsentido: They wouldn't be using the same systems we do.
11:34:04 <ski> i'd be more interesting when we get some of them here to interrogate
11:34:18 <Cale> fezsentido: So results would be in some sense incomparable.
11:34:20 <fezsentido> Cale: if we calculate what will be the velocity of a projectile, both would agree on the results?! Or would not?
11:34:20 <SamB> Cale: I bet they'd find a lot of the same answers
11:34:33 <Cale> fezsentido: Perhaps, but that's not mathematics.
11:34:36 <cameron> fezsentido: but that's physics
11:34:53 <SamB> 2 + 2 is still 1 + 3
11:34:56 <Cale> and the "result" in their case might not actually be a "number" in the sense that we tend to mean it.
11:35:03 <syntaxfree> I quote from Lenin.
11:35:04 <syntaxfree> "15:14 < ski> classicallity is a bit like side-effects .. it sometimes makes things more concise .. but it is  also dangerous
11:35:11 <syntaxfree> no, that's ski.
11:35:12 <titus> that article on alien maths by minsky was interesting to me (a non-maths person) - what's it called?
11:35:14 <ski> syntaxfree : ?
11:35:15 <syntaxfree> "The principal feature of Kants philosophy is the reconciliation of materialism with idealism, a compromise between the two, the combination within one system of heterogeneous and contrary philosophical trends. When Kant assumes that something outside us, a thing-in-itself, corresponds to our ideas, he is a materialist. When he declares this thing-in-itself to be unknowable, transcendental, other-sided, he is an idealist."
11:35:21 <Maddas> SamB: Actually, I consider the fortunate part to be that all of these theories are just fancy conjectures. So whenever they give me a headache, I can walk out the door and indulge in more worldly pleasures :-)
11:35:31 <SamB> Cale: what the heck is a number anyway
11:35:40 <Cale> syntaxfree: Unknowable things are worthless to think about.
11:36:00 <syntaxfree> Cale: yes. That's pretty much the conclusion of the Critique of Pure Reason.
11:36:19 <syntaxfree> Then he deals with the unknowable things in the Critique of Practical Reason, which deals with morality, religion, etc. etc.
11:36:24 <SamB> sometimes I wonder how the world can exist
11:36:25 <Cale> SamB: well, that's a good question :) I'd usually say something like "element of a ring", but it's really a little broader than that.
11:36:29 <SamB> I try to stop as soon as possible
11:36:34 <syntaxfree> Practical Reason isn't half as well-constructed as Pure Reason. But it's still fascinating.
11:36:50 <kc5tja> If things were worthless to think about, we wouldn't have the scientific world we live in today, with its technologies and literature.
11:36:56 <Maddas> SamB: I try, but I often fail to stop before it becomes unpleasantly time-consuming :-)
11:36:58 <vegai> SamB: why stop?
11:37:04 <Cale> kc5tja: Uh, that's not about unknowable things though.
11:37:11 <SamB> vegai: it scares me to think about there not being a world
11:37:17 <kc5tja> Cale: But, once, it was.
11:37:27 <Cale> kc5tja: That's about the construction of models for predicting our observations.
11:37:34 <vegai> SamB: that would make functional programming easier
11:37:41 <SamB> not really
11:37:46 <SamB> there wouldn't be anyone to do it
11:38:00 <vegai> it would make everything easier...
11:38:00 <Maddas> SamB: So there wouldn't be anything hard about it!
11:38:05 <Maddas> ;-)
11:38:12 <Cale> There's nothing perfectly objective about science :)
11:38:13 <SamB> Maddas: true
11:38:18 <kc5tja> My point is, that which is unknowable _today_ may not be _tomorrow_.  At some point, however, someone _has_ to ponder that which is unknowable to offer predictions, so that they become knowable.
11:38:20 <SamB> but there would be nothing easy about it either
11:38:25 <ski> what would it mean if "the world" (synonym of "universe" ?) would not exist ?
11:38:32 <Cale> kc5tja: Unknowable is different from unknown.
11:38:36 <cameron> Cale: how do you know what is unknowable and what is not?
11:38:40 <Maddas> kc5tja: I think Cale and syntaxfree were talking about 'unknowable' in a very different sense
11:38:42 <SamB> there would be nothing to mean anything, I think, ski ;-P
11:38:48 <vegai> SamB: are you afraid that thinking about it makes the world disappear?
11:38:58 <Cale> There are certain things which are pretty much unknowable by definition.
11:39:00 * cameron mutters something about known knowns, known unknowns, unknown knowns and unknown unknowns...
11:39:02 <ski> SamB : and that's a pretty useless language, no ?
11:39:09 <Maddas> cameron: heh, rumsfeld?
11:39:14 <cameron> Maddas: yea
11:39:27 <Cale> For example, they rely on having some nonexistent objective viewpoint.
11:39:43 <Maddas> cameron: Do you know about the book 'The poetry of Donald Rumsfeld'?
11:39:54 <cameron> How can anything be knowable without some kind of objective viewpoint?
11:39:58 <cameron> Maddas: nope ...
11:40:02 <Maddas> oops, 'The existential Poetry', even
11:40:04 <SamB> Cale: how do you know such a viewpoint to be nonexistant?
11:40:09 <SamB> Cale: you can't know that
11:40:15 <Cale> SamB: you're right :)
11:40:20 <ski> (cameron : mayhaps there could be local knowledge ??)
11:40:26 <kc5tja> I guess I just don't agree with that philosophy, but we'll agree to disagree here.
11:40:39 <Cale> The truths I express are not absolute :)
11:40:51 <SamB> now, unattainable
11:40:52 <Cale> How can anything be known without perception?
11:41:04 <SamB> you could maybe know it to be unattainable
11:41:23 <Cale> I mean, I don't have a single piece of objective knowledge in my head, or at least anything I can tell is objectively true.
11:41:31 * Maddas finds emergent discussions on IRC about such topics too hopelessly informal to lead to lengthy, generally interesting/fruitful exchanges :-\
11:41:39 <Cale> It's always subjective, because it's taken from my viewpoint.
11:41:42 <Cale> I can't help that.
11:41:57 <ski> Maddas : yea
11:42:14 <SamB> somehow, I think better of teachers who have shamelessly subjective grading than those who do not
11:42:39 <Maddas> That clearly depends on their particular grading schemes, though :-)
11:42:41 <cameron> well, grading is a whole 'nother kettle of worms again
11:42:46 <Cale> I have no idea about how I'd acquire any knowledge without somehow involving my perception.
11:42:57 <Cale> I can't absolutely claim that it's impossible
11:43:02 <Cale> but I don't know how to do it.
11:43:20 <Cale> Do you get what I'm saying?
11:43:25 <ski> Cale : Extra-Sensory Perception ? ;)
11:43:32 <Cale> ski: heh ;)
11:43:48 <SamB> well, I think you can potentially gain knowlege using your perception in such a way that that knowlege is somehow untainted by that perception.
11:43:52 <SamB> say, in digital form ;-P
11:44:12 <kc5tja> Your senses will, barring genetic defects, report what's really there.  Your brain, however, will filter that knowledge based on previous experiences.
11:44:20 <kc5tja> This is why artists see things differently than scientists.
11:44:21 <ski> mayhaps mediums could be the true knowers of the universe ?!
11:44:31 <SamB> kc5tja: they don't report what is there
11:44:42 <SamB> they report what is coming to them
11:44:48 <cameron> SamB: what do they report, then? a fantasy world?
11:44:49 <kc5tja> No -- Heisenburg's principle forbids that.
11:44:56 <kc5tja> Of course.
11:44:57 <cameron> "what's coming to them" is still something that's actually there
11:45:05 <SamB> well okay.
11:45:06 <Cale> ski: however, their track record on that point hasn't been too good so far ;)
11:45:15 <SamB> so I was assuming that by "there" you meant "out there"
11:45:38 <Cale> kc5tja: "what's really there"
11:45:48 <Cale> :)
11:46:35 <Cale> How can we say anything about "what's really there", besides deciding to agree on our subjective perceptions?
11:46:54 <SamB> we could use an electron microscope!
11:46:59 <Cale> We can come up with rules which seem to predict our perceptions.
11:47:03 <cameron> Short of any evidence to the contrary, I'm quite happy to just assume that my subjective perceptions are some reflection of reality
11:47:03 <SamB> yeah.
11:47:07 <kc5tja> Within the range of its perception, yes.  Your eye cannot detect ultraviolet or infrared (usually; given an intense enough source, and a totally black room, you _can_ see near-IR), but within the scope of the visible spectrum, the signals transmitted to the brain from the receptors of the eye WILL reflect what photons it receives.
11:47:11 <cameron> Imperfect, perhaps, but useful
11:47:16 <SamB> okay, so maybe reality is something we imagine
11:47:37 <cameron> SamB: maybe it is. Maybe you're imagining me and I don't exist ...
11:47:39 <Cale> cameron: I just see the existence of an objective reality as a frivolous assumption which can be safely removed by Ockham's razor.
11:47:40 <kc5tja> What your brain does with it, however, is quite another matter.
11:47:41 <SamB> but if so we have a pretty good imagination
11:47:53 <cameron> It feels so odd being the figment of someone else's imagination :P
11:47:59 <SamB> cameron: liar
11:48:05 <SamB> it feels totally normal, I'm sure
11:48:13 <SamB> if it can be said to feel like anything
11:48:22 * Heffalump appears
11:48:27 <Cale> kc5tja: You're working inside a physical model. In that physical model, there is a definition of what "reality" is, but it's a part of that model.
11:48:34 <SamB> Heffalump: are you a figment of someone's imagination?
11:48:49 <Maddas> I have never understood the appeal of debating the existence of the universe (or anything but myself, or similar ideas). Whether it exists or not has never been relevant to any other part of my life :-)
11:49:01 <Cale> Maddas: right
11:49:06 <monochrom> Why are we discussing reality and sensors?
11:49:10 <Cale> Maddas: which is why I cut out that assumption :)
11:49:13 <helmut> Is there a (a -> b) -> a -> (a, b) function? (and could I search for similar things somewhere?)
11:49:18 <SamB> monochrom: nothing better to do?
11:49:23 <monochrom> Haha
11:49:31 <SamB> Cale: I'd use occam's razor, and just assume it to exist
11:49:32 <cameron> monochrom: someone let some philosophers in here...
11:49:32 <kilimanjaro> monochrom, the Monads are on vacation
11:49:35 <ski> @djinn (a -> b) -> a -> (a, b)
11:49:35 <allbery_b> @hoogle (a -> b) -> a -> (a,b)
11:49:36 <lambdabot> f a b = (b, a b)
11:49:36 <lambdabot> No matches, try a more general search
11:49:38 <SamB> it makes things easier to talk about
11:49:43 <monochrom> You have to write your own (a -> b) -> a -> (a, b) function.
11:49:52 <helmut> thanks again!
11:49:56 <monochrom> But wait a second!
11:50:07 <kc5tja> Cale: Correct; and we know the model to be mostly correct based on observations made by _many_ different people, and taking the average of the reports.  The results are consistent.  Thus bringing us right back to predictability.
11:50:08 <Cale> SamB: Ockham's razor is used to eliminate concepts, not introduce them.
11:50:16 <ski> @type (id &&&)
11:50:17 <monochrom> > ((+ 5) *** id) 1
11:50:19 <lambdabot>   add an instance declaration for (Num (b, a))
11:50:19 <lambdabot> forall a c'. (a -> c') -> a -> (a, c')
11:50:25 <Cale> @type ap (,)
11:50:28 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
11:50:39 <ski> monochrom : you want '(&&&)' ..
11:50:41 <monochrom> > (id &&& (+ 5)) 1
11:50:43 <lambdabot>  (1,6)
11:50:50 <monochrom> We rock.
11:50:53 <SamB> Cale: I count "there is a reality" as a simpler explanation than "someone, possibly yourself, is playing an elaborate practical joke on you"
11:50:57 <Cale> > ap (,) (+5) 1
11:50:59 <lambdabot>  (1,6)
11:51:15 <Cale> SamB: no, I'm not saying that someone is playing a practical joke at all
11:51:27 <monochrom> I use Ockham's razor to eliminate the concept of myself.
11:51:28 <Cale> SamB: I'm just saying that we don't need a notion of "objective reality"
11:51:45 <cameron> monochrom: there are support groups for people who feel like doing that
11:51:52 <monochrom> we don't need a notion of "subjective unreality" either.
11:51:52 <Knuckles> hello again
11:51:57 <SamB> okay, so how do we talk about this chair that I am sitting in if we don't pretend there is a reality?
11:52:03 <Knuckles> i need some explanations on the foldr function!
11:52:14 <ski> SamB : there is no chair
11:52:16 <monochrom> the foldr function doesn't exist.  *duck*
11:52:25 <SamB> ski: no, we haven't decided that either!
11:52:25 <Knuckles> how can i verify in a list of list if all the elements are equal with a foldr
11:52:31 <Cale> SamB: by agreeing to use some model
11:52:44 <SamB> Cale: okay.
11:52:46 <monochrom> Seriously, Cale has pictures depicting the folds.
11:52:56 <SamB> So how is that different from what I said?
11:53:06 <Maddas> monochrom: Hah :-)
11:53:35 <Cale> SamB: We just don't confuse ourselves into thinking that our model is in any sense "absolute truth", or that there even is some kind of "absolute truth" to be obtained.
11:53:48 <Cale> It's just the best we have.
11:53:53 <ski> Knuckles : you need to pass up both the current boolean result .. and also any of the elements of the tail (e.g. the first in the tail) .. you need to handle the base case correctly somehow, also
11:53:57 <SamB> I don't see why we shouldn't.
11:54:10 <ski> Knuckles : probably there are other ways, too
11:54:24 <Cale> SamB: You can do so if you want. It's never served any purpose to me.
11:54:39 <astrolabe> Knuckles: 'a list of list'?  If you mean 'a list of lists', do you want all the lists to be equal?
11:54:47 * ski can imagine one using a returned function ..
11:55:05 <Cale> SamB: How would we really know that we had the "objective truth" about something even if we did?
11:55:22 <SamB> good question
11:55:24 <xerox> ?type null . tail . group
11:55:26 <Cale> SamB: All we can do is make some subjective observations.
11:55:26 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:55:34 <cameron> Cale: we don't, which is why we're arguing.
11:55:45 <SamB> heh
11:55:55 <cameron> Cale: your default seems to be subjective, others (including me) seem to think objective is simpler
11:55:55 <SamB> and here I thought it was becuase we were bored
11:56:00 <ski> > let for_all = flip; xss = [[0,1],[0,1],[0,1]] all in for_all xss $ \xs0 -> for_all xss $ \xs1 -> xs0 == xs1
11:56:01 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
11:56:14 <Cale> Knuckles: read http://en.wikipedia.org/wiki/Foldr :)
11:56:20 <ski> > let for_all = flip all; xss = [[0,1],[0,1],[0,1]] all in for_all xss $ \xs0 -> for_all xss $ \xs1 -> xs0 == xs1
11:56:21 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
11:56:22 <astrolabe> You can make as many observations as you like.  If you don't have a prior, you don't get a posterior probablilty.
11:56:22 <monochrom> I propose this for Knuckles.  all (== head (head xxx)) (concat xxx)
11:56:22 <Cale> Knuckles: I wrote it, and it has some useful diagrams
11:56:36 <ski> > let for_all = flip all; xss = [[0,1],[0,1],[0,1]] in for_all xss $ \xs0 -> for_all xss $ \xs1 -> xs0 == xs1
11:56:38 <lambdabot>  True
11:56:42 <ski> (arg, damn typo)
11:57:04 <ski> i believe this is the functionality Knuckles want to be expressed by a 'foldr'
11:57:13 <Cale> Knuckles: basically, the way to think about foldr f z is to see it as replacing each (:) in the list with f, and the [] at the end with z
11:57:18 <monochrom> > let xxx = [[0,1],[0,1],[0,1]] in all (== head (head xxx)) (concat xxx)
11:57:20 <lambdabot>  False
11:57:28 <monochrom> > let xxx = [[1,1],[1,1],[1,1]] in all (== head (head xxx)) (concat xxx)
11:57:30 <lambdabot>  True
11:58:05 <monochrom> A technique of lazy programming is: do not respect the original structure!
11:58:24 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
11:58:26 <lambdabot> Title: Fold Diagrams - CaleWiki
12:00:26 <ski> (Knuckles : did you understand any of my two ideas ?)
12:00:34 <dmhouse> dons: ping.
12:00:50 <xerox> > (\xs -> case xs of [] -> True; (y:ys) -> foldr ((&&) . (y ==)) True ys) [[0,1],[0,1],[0,1]]
12:00:52 <lambdabot>  True
12:00:58 <monochrom> Knuckles: and how about mine?
12:02:21 <cameron> dmhouse: it's 5am in Sydney ...
12:02:48 <dmhouse> Righto.
12:02:48 <shapr> I'm trying to generate a keypair with OpenSSL to read into the Haskell cryptolib, does anyone know how to do that? I started with "openssl genrsa -out rsa.key 768" but the 'PKCS8Example user.key' fails. Hm, maybe Language.ASN1 only reads binary ASN.1?
12:02:50 <dmhouse> sjanssen: ping
12:02:54 <xerox> ah, all elements of all lists? (null . tail . group . concat)
12:03:04 <shapr> Hiya Megz, are you back to learn Haskell?
12:03:22 <sjanssen> dmhouse: pong
12:03:38 <ski> xerox : using 'foldr' as sole mathcing facility ?
12:03:51 <Megz> Don't have time for Haskell, gosh.
12:03:51 <ski> (on lists, i mean)
12:03:57 <monochrom> I don't believe in "must use foldr" or "must use ___".
12:03:57 <shapr> Megz: Oh, why join #haskell then?
12:03:59 <dmhouse> sjanssen: Hey :) I want to play around with xmonad, but I guess I can't start it from within another WM (Gnome, in this case). Is there an easy way to do so?
12:04:12 <ski> good evening augustss
12:04:15 <Megz> I have enough time to glance at this channel.
12:04:26 <shapr> dmhouse: vi ~/.xsession and put in xmonad, then run startx
12:04:44 <monochrom> I only believe in "must use haskell"
12:04:56 <shapr> My .xsession has three lines: xmodmap /home/shae/.xmodmap-thunderbird.scannedinavian.com \n xmodmap -e "pointer = 3 8 1 9 5 6 7 4 2 10 11" \n xmonad
12:05:04 <dmhouse> sjanssen: what'll that do?
12:05:16 <sjanssen> dmhouse: that will make xmonad your default window manager
12:05:24 <dmhouse> shapr: hrm, what does the pointer line do?
12:05:28 <ski> monochrom : try writing 'zipWith' where you may only use 'foldr' for recursion :)
12:05:32 <dcoutts_> kc5tja: Gtk2Hs has a nice windows installer, wx doesn't, the latest Gtk2Hs release works with ghc-6.6, wx doesn't.
12:05:32 <shapr> dmhouse: I'm a lefty.
12:05:54 <dmhouse> sjanssen: so if I'm within Gnome, and I start a terminal and hit startx, what happens? X restarts?
12:06:11 <kc5tja> dcoutts_: Thanks for the data point.  Upon further reflection, the decision doesn't matter since the program will be run on Linux systems only.
12:06:13 <dmhouse> shapr: I see. How cryptic.
12:06:14 * shapr wonders about xnest
12:06:18 <SamB> dmhouse: I don't think that is allowed
12:06:27 <dcoutts_> kc5tja: well then Gtk is a no-brainer :-)
12:06:29 <SamB> I think you have to do it at the console
12:06:32 <shapr> dmhouse: Well, it just tells X to assign the buttons in that order.
12:06:37 <Saizan> you can spawn another display, can't you?
12:06:39 <dmhouse> shapr: the call to xmodmap, that is, not the fact that you're left-handed.
12:06:49 <SamB> Saizan: it is supposed to work
12:06:53 <dcoutts_> kc5tja: what are you building?
12:06:57 <kc5tja> dcoutts_: Yeah.  Obviously.  I wanted it to work on Windows just on the off-chance this project ended up replacing another (which currently _only_ runs on Windows).
12:06:58 <shapr> dmhouse: The first call loads my "I am not a koala" keymap.
12:06:58 <SamB> it tends to crash things for me, though
12:07:09 <dmhouse> Saizan: ooh, good call. That's one of those Ctrl+Alt+F* thingies, right? :)
12:07:19 * dmhouse is somewhat new to playing around at the WM level.
12:07:41 <dcoutts_> kc5tja: well you're fine then, you always have the option of deploying on windows
12:08:07 <dcoutts_> kc5tja: I'm currently writing a thing for the Gtk2Hs website about how to deploy on windows
12:08:14 <shapr> dmhouse: First call to xmodmap loads my heavily customized keymap, second call mirrors the mouse buttons for left handed use.
12:08:21 <Saizan> dmhouse: mmh don't think so, i don't exactly know how do it, but for example the "change user" feature of gnome is based on this iirc
12:08:25 <sjanssen> dmhouse: startx will probably flip out because you're trying to start on the same display
12:08:26 <dcoutts_> ie build a nice installer that doesn't have any other deps
12:08:34 <sjanssen> dmhouse: I'd recommend 'startx -- :2', that will start a new X display, and keep the old one running
12:08:47 * shapr throws evil lambdas at openssl and cryptolib
12:08:48 <xerox> > foldr (\(x:xs) k -> k && foldr ((&&) . (x ==)) True xs) True [[1,1],[1,1],[1,1]]
12:08:50 <lambdabot>  True
12:08:53 <SamB> sjanssen: why :2?
12:08:55 <dmhouse> sjanssen: thanks, I'll try that.
12:08:59 <SamB> is there something wrong with :1?
12:09:05 <shapr> SamB: It's sometimes used for other stuff.
12:09:13 <SamB> oh.
12:09:19 <SamB> like what?
12:09:24 <xerox> (that breaks on lists of empty lists)
12:09:25 <shapr> Virtual displays, etc
12:09:46 <ski> > foldr (\(x:xs) k -> k && foldr ((&&) . (x ==)) True xs) True []
12:09:48 <lambdabot>  True
12:09:52 <ski> > foldr (\(x:xs) k -> k && foldr ((&&) . (x ==)) True xs) True [[]]
12:09:54 <lambdabot>   Non-exhaustive patterns in lambda
12:09:55 <shapr> The Nokia 770/N800 development kit runs its server on :1 and so do some other applications.
12:09:56 <kc5tja> dcoutts_: Unfortunately, if the tool gets to be popular enough, I'll be forced to rewrite it in Java.  *shudder*
12:09:56 <xerox> :)
12:10:09 <SamB> kc5tja: okay...
12:10:10 <ski> xerox: stress-tesing your baby :)
12:10:16 <xerox> a case analysis solves it though
12:10:18 <kc5tja> Well, s/will be forced/will most likely be forced/
12:10:22 <shapr> SamB: I have no idea how they get to display inside :0 anyway... xnest maybe?
12:10:27 <sjanssen> SamB: oops, I meant :1
12:10:27 <sjanssen> both should work equally well
12:10:27 <sjanssen> dmhouse: your initial X session will be running probably be running at ctrl+alt+F7 and the new one on ctrl+alt+F8
12:10:43 <dcoutts_> kc5tja: ah well. prototypes often end up becoming the real thing
12:10:44 <SamB> shapr: something of that sort
12:10:48 <SamB> maybe Xephyr
12:10:53 <kc5tja> SamB: Like I said, Google's set of official languages is C++, Python, Java, and Javascript.  And although Python is workable, I'd rather it be in Haskell.  :)
12:11:08 <shapr> sjanssen: I thought :2 was a good suggestion because I do sometimes have stuff running on :1 as well :-)
12:11:21 <shapr> kc5tja: compile to parrot?
12:11:28 <kc5tja> Plus, I'll be learning more about Haskell coding in the process.
12:11:39 <kc5tja> shapr: Perl is all but verbotten here (and with good reason).
12:12:45 <shapr> Perl can be pretty and maintainable. The Perl culture seems to accept stuff that isn't though.
12:12:56 <SamB> kc5tja: did someone tell you about the Evil Mangler?
12:13:08 <shapr> I've seen ugly but working Haskell code. I didn't use it though :-)
12:13:08 <kc5tja> SamB: Never heard of it.
12:13:28 <SamB> it happens to be written in Perl for some reason
12:13:43 <dmhouse> sjanssen: I just get a kind of grey textured background and a crosshair cursor.
12:13:48 <SamB> though actually it doesn't seem hard to edit
12:13:58 <sjanssen> dmhouse: that probably means it's working :)
12:13:59 <kc5tja> I'm not denying that Perl code "can be" nice.
12:14:08 <Knuckles> sorry ski and monochrom, i was away
12:14:09 <sjanssen> dmhouse: alt+shift+enter to start an xterm
12:14:15 <kc5tja> The problem I find with Perl is, however, it almost actively _invites_ bad code.
12:14:16 <Knuckles> i don't really understand your ideas
12:14:20 <osfameron> perl culture is very pro testing/documentation/modules etc, all of which is good for maintainability
12:14:23 <SamB> it is called "the Evil Mangler" because of what it *does*
12:14:37 <xerox> > (\xs -> case xs of (ys:_) -> case ys of (y:_) -> foldr ((&&) . foldr ((&&) . (y ==)) True) True xs; [] -> True) [[],[],[]]
12:14:37 <shapr> osfameron: Yeah, that's a good point.
12:14:38 <kc5tja> It makes writing maintainable code more difficult than writing quick, one-off code that ultimately becomes the burden of maintainers.
12:14:38 <SamB> namely, scrambling GCC's ASM output
12:14:39 <lambdabot>  True
12:15:05 <Knuckles> i want to use foldr because i think its possible and  I want to understand the utilisation of foldr
12:15:16 <ventonegro> SamB, sounds like a hack
12:15:21 <ventonegro> GHC's output?
12:15:31 <SamB> ventonegro: quite a hack
12:15:37 <SamB> and no, GCC's output
12:15:46 <SamB> so that it will do what GHC wants it to do
12:16:11 <SamB> like, putting info tables before the code they go with
12:16:12 <syntaxfree> does anyone have jstor access?
12:16:18 <norpan> Knuckles: foldr is easy, it takes a list and replaces : and [] with the things you supply instead
12:16:27 <ski> xerox(,Knuckles) : wanna see one version of it ?
12:16:27 <osfameron> SamB: "evil" means written in perl, right? iirc when it gets rewritten in haskell it becomes "glorious"
12:16:42 <SamB> osfameron: no, I'm pretty sure it is going to stay evil.
12:16:48 <ventonegro> SamB, seems pretty low-level
12:16:52 <Knuckles> it replaces what?
12:16:52 <SamB> that, and it won't be rewritten in Haskell ;-)
12:16:57 <Knuckles> ski yeah, i want plz
12:17:03 <SamB> ventonegro: yeah.
12:17:05 <sjanssen> -fvia-c, roughly: assembler . evilMangler . gcc . coreToC . haskellToCore :: Haskell -> Binary
12:17:08 <osfameron> oh? bootstrapping problem?
12:17:12 <ski> Knuckles : or would you rather think on it yourself, first ?
12:17:21 <Knuckles> i want to think
12:17:25 <Knuckles> but i want some hints
12:17:32 <ski> :)
12:17:53 <Knuckles> because i don't see the manner to use foldr and (&&) to know if the elements of list of lists or equal
12:17:53 <ventonegro> sjanssen, nice point-free explanation :-)
12:18:08 <Cheery> it is nice thing that lambdas are also arrows, it allows you to use first and second, which, I consider being quite useful.
12:18:15 <dmhouse> sjanssen: cool!
12:18:33 <ventonegro> GHC's -O2 implies -fvia-c, right?
12:18:47 <sjanssen> ventonegro: in ghc 6.6 and younger
12:19:01 <sjanssen> ventonegro: 6.8 will use -fasm
12:19:23 <ventonegro> sjanssen, -fasm for translating to C?
12:19:34 <dcoutts_> dons, kolmodin: did you see the email today in reply to my post some time ago on "more speed please!", interesting and very relevant to the Binary stuff
12:19:36 <sjanssen> ventonegro: nah, -fasm skips C entirely
12:19:51 <ventonegro> sjanssen, but what about the others archs?
12:20:01 <ventonegro> s/others/other/
12:20:13 <sjanssen> -fasm, roughly: assembler . coreToAssembly . haskellToCore :: Haskell -> Binary
12:20:34 <sjanssen> ventonegro: those archs will stick with the C backend
12:20:49 <ventonegro> sjanssen, i see
12:20:51 <sjanssen> ventonegro: but, in practice, those archs don't use the evil mangler anyway
12:22:19 <ventonegro> i must say sometimes it looks like GHC is doing some magic, so i guess it's the mangler
12:22:27 <shapr> Is there some way to persuade openssl to output the keypair in binary instead? Or to convert the ascii-armored version to binary?
12:29:11 <joelr1> good evening
12:29:13 <kc5tja> dcoutts_: Oh well -- looks like someone else has already started porting what I'd wanted to port in Java.
12:29:31 <astrolabe> good evening joelr1
12:29:37 <dcoutts_> kc5tja: ah well
12:30:05 <joelr1> what do you call a parser that recognizes something as a particular type of expression when it's _followed_ by a keyword? is this something for happy or for parsec?
12:30:43 <kc5tja> joelr1: Give an example?  I'm thinking LR at this point, but not sure.
12:31:10 <joelr1> one sec
12:31:37 <kc5tja> dcoutts_: I still want to try my hand at writing something with a GUI though, just to gain the experience.  Not sure what to write at this point though.  :)
12:31:42 <joelr1> @hpaste
12:31:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:32:06 <hpaste>  joelr1 pasted "ambiguous grammar" at http://hpaste.org/1644
12:32:18 <joelr1> kc5tja: ^^^
12:33:01 <joelr1> yacc would see a conflict since i won't be able to tell a name (expr in parens) from expr in parens representing shares
12:33:22 <joelr1> i don't think it can look one token ahead to see if shares is there and resolve the conflict
12:34:00 <astrolabe> I think parsec can do that kind of thing.  It has a 'try' operator I think.
12:34:17 <kc5tja> Yeah, that is definitely a parsing conflict, even for LL too.
12:34:40 <kc5tja> One thing is to narrow down the expression in the parentheses.
12:34:41 <joelr1> astrolabe: yes, my parsec parser works fine. i'm trying to figure out how to resolve that with yacc
12:34:50 <kc5tja> If it's a name, can it just be a constant string-identifier?
12:35:16 <joelr1> kc5tja: yes but that one is also part of expr so it won't work
12:35:30 <kc5tja> No, I mean:
12:35:37 <kc5tja> LP identifier RP expr SHARES
12:35:57 <kc5tja> That way, it might be easier for yacc to tell the difference, since the state-machine has a different branch.
12:36:10 <joelr1> kc5tja: it can't be identifier, must be string in quotes but, again, identifier is also part of expr :D
12:36:25 <joelr1> kc5tja: basically you have : when expr do this, when expr shares do that
12:36:27 <cedricshock> What's the lazy way to flatten a list of lists?
12:36:38 <dmhouse> ?src concat
12:36:38 <lambdabot> concat = foldr (++) []
12:36:43 <dmhouse> Is that not lazy?
12:36:58 <kc5tja> But I'm saying _don't use_ the expr term in the production.
12:37:05 <dmhouse> > concat [repeat [1..3]]
12:37:07 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
12:37:09 <kc5tja> Narrow it down so it's more specific.
12:37:20 <dmhouse> > concat (repeat [1..3]) -- Sorry, meant this.
12:37:21 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
12:37:30 <dmhouse> cedricshock: looks lazy enough to me...
12:37:42 <cedricshock> dmhouse: thanks.
12:37:49 <joelr1> kc5tja: anything i can narrow it down to is already part of expr, you see. so even if i don't use expr yacc won't be able to tell the difference
12:37:49 <kc5tja> Otherwise, you'll probably have to change the syntax.
12:37:54 <eumenides> darn. my app is crashing with a stack overflow and i can't figure out where
12:37:57 <joelr1> kc5tja: yeah
12:38:17 <cedricshock> > repeat [1..3]
12:38:18 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
12:38:36 <kc5tja> I wonder if there are any tools to make contextual grammar parsers.
12:44:42 <SamB> eumenides: well, there is Debug.Trace
12:45:00 <SamB> maybe the profiler
12:45:18 <SamB> gdb could be of use, too...
12:46:20 <eumenides> hmm, i'll try profiling
12:47:15 <SamB> see, when you build for profiling, then you have half a chance of getting a reasonable backtrace ;-)
12:55:40 <syntaxfree> here's a modern marxist trying to defend Marx's interpretation of the differential calculus!
12:55:44 <syntaxfree> http://www.marxist.com/dialectical-materialism-calculus-3.htm
12:55:46 <lambdabot> Title: Dialectical materialism and Calculus
12:55:46 <syntaxfree> hahahaa.
12:56:50 <Heffalump> I don't speak Spanish
12:57:08 <osfameron> marx programmed haskell?
12:57:11 <Heffalump> :-)
12:57:49 <syntaxfree> we were discussing mathematical constructivism earlier.
12:58:09 <syntaxfree> Marx explicitly rejects Cauchy's formalization of the calculus for being "idealistic" and incompatible with materialist dialectics.
12:59:53 <nomeata> Hi. How would I replace text foo with bar in a ByteString.Lazy without chopping it up in single chars, but also without writing a bunch of non-idiomatic code?
13:01:03 <nomeata> maybe work on zip (inits text) (tails text) ?
13:01:17 <dcoutts_> nomeata: findSubstring or findSubstrings
13:01:23 <TuringTest> nomeata: use take and drop when finding each piece?
13:01:39 <nomeata> dcoutts_: sounds good, why don’t I see these functions...
13:01:46 <dcoutts_> nomeata: probably a combination of findSubstring and take & drop
13:02:07 <nomeata> dcoutts_: are they not part of the lazy variant?
13:02:15 <nomeata> or just not documented?
13:03:23 <dcoutts_> nomeata: ah, looks like we've not implemented those for lazy bytestring
13:04:14 <nomeata> :-(
13:04:19 <dcoutts_> so you'd have to do something like elemIndex, drop and isPrefixOf
13:04:30 <nomeata> ok, that sounds not too bad
13:04:50 <dcoutts_> nomeata: if you want to implement the search functions for us that'd be cool :-)
13:05:37 <dcoutts_> nomeata: ie search for the index of the first char with elemIndex, drop up to that index and see if your word isPrefixOf that tail
13:06:15 <dcoutts_> do that in an unfold to give a list of bytestrings, and concat the lot together
13:06:27 <sjanssen> I think a combination of tails+inits should be more efficient
13:06:48 <dcoutts_> I don't, elemIndex is really really fast
13:07:01 <sjanssen> but it requires two traversals, right?
13:07:09 <dcoutts_> tails+inits you'll be doing the elemIndex search but more slowly in custom code
13:07:49 <dcoutts_> sjanssen: ah, hmm well this assumes the chunks are big and you don't have to look that far to find the thing you're looking for
13:08:28 <dcoutts_> it's two traversals, but only over the big chunk list, so that cost is pretty low
13:08:36 <sjanssen> obviously the solution is to write KMP and send in a patch :)
13:08:47 <sjanssen> dcoutts_: yeah, memchr probably wins this one
13:08:50 <dcoutts_> yes! that's what I suggested :-)
13:09:06 <dcoutts_> we do have a (probably slow) kmp search for strict bytestring
13:09:21 <sjanssen> hmm, I wonder how much trickier it is for lazy ByteStrings
13:09:38 <sjanssen> probably not too bad if you accept mediocre performance
13:09:41 <dcoutts_> sjanssen: not much more so I'd expect. I think you could probably do it on streams even.
13:09:48 <dcoutts_> sjanssen: implementing a generic template substitute might be an interesting task
13:10:06 <sjanssen> streams KMP sounds *really* fun
13:10:33 <dcoutts_> sjanssen: it seems plausible since kmp visits each char only once
13:10:55 <dcoutts_> sjanssen: just carry the skip array around in the state
13:11:41 * dcoutts_ -> home
13:13:55 <Kobold> On "Programming in Haskell" pg. 60, to implement mergesort, it says to define halve :: [a] -> [([a], [a])] that splits a list into two lists whose lengths differ by at most one, but I don't get why it would have that type.
13:14:11 <Kobold> Shouldn't it be [a] -> ([a], [a]) ?
13:14:41 <Saizan> by your description i think you are right
13:15:03 <Saizan> [([a],[a])] is a list of pairs of lists
13:15:32 <Kobold> Right. There isn't much more description than that, as it's one of the exercises, but I can't figure out how [([a],[a])] would be useful.
13:16:27 <Saizan> yeah
13:17:13 * xerox notes that the proof of f :: dcoutts_ -> home is f = unicycle !
13:17:27 <Kobold> I think I'll email hutton then. In any case, would (take n xs, drop n xs) where n = length xs `div` 2, be considered ok haskell style for implementing halve?
13:18:03 <int-e> Kobold: yes. but splitAt (length xs `div` 2) xs  seems clearer.
13:18:17 <osfameron> and more efficient
13:18:21 <Kobold> ah. Thanks!
13:18:25 <nomeata> ?paste
13:18:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:19:08 <hpaste>  nomeata pasted "substring replacement with elemIndices" at http://hpaste.org/1647
13:19:09 * Saizan wonder if you can do this in one traversal
13:19:28 <nomeata> dcoutts_: is that about what you intended when suggesting elemIndices
13:23:11 <syntaxfree> oh, fun. Haskell arrays are lazy.
13:23:23 <eumenides> some of them
13:23:30 <mahogny_> or un-fun
13:23:39 <syntaxfree> How can I tell if my array is being too lazy?
13:23:48 <syntaxfree> Should I wake him up if he dozes off?
13:24:29 <mahogny_> if your memory usage goes to the skies, then it is a bad sign. or if performance is non-existent
13:26:43 <syntaxfree> how weird. Ix is treated specially.
13:26:46 <Heffalump> what's lazy about them, apart from the elements?
13:27:00 <monochrom> the elements are lazy. that's it.
13:27:08 <SamB> syntaxfree: Ix treated specially?
13:27:24 <syntaxfree> Derived instance declarations for the class Ix are only possible for enumerations (i.e. datatypes having only nullary constructors) and single-constructor datatypes, including arbitrarily large tuples, whose constituent types are instances of Ix.
13:27:40 <syntaxfree> you can't write something about arbitrarily large tuples in Haskell.
13:28:14 <Saizan> well a derivation is meta-haskell :)
13:28:52 <nominolo> g'evening
13:28:53 <syntaxfree> I s'ppose you're right :)
13:29:33 <nominolo> @localtime nomeata
13:29:35 <dcoutts> xerox: hah, yeah true :-)
13:29:36 <lambdabot> Local time for nomeata is Tue May  1 22:27:47
13:29:42 <nominolo> @localtime nominolo
13:29:46 <lambdabot> Local time for nominolo is Tue May  1 22:27:52 2007
13:30:54 <nominolo> @karma nominolo
13:30:55 <lambdabot> You have a karma of 1
13:31:01 <nominolo> yeah.  ONE!
13:31:29 <syntaxfree> @karma SyntaxNinja
13:31:30 <lambdabot> SyntaxNinja has a karma of 11
13:31:35 <syntaxfree> @karma syntaxfree
13:31:36 <lambdabot> You have a karma of 2
13:31:43 <syntaxfree> TWO, baby.
13:32:02 <SyntaxNinja> :)
13:32:15 <Heffalump> @karma
13:32:15 <nominolo> nah, i'll getcha soon :)
13:32:16 <lambdabot> You have a karma of 6
13:32:31 <Heffalump> 3 syntaxfrees, that's me
13:32:45 <Heffalump> and 6 nominolos. Or 2 syntaxfrees and 2 nominolos.
13:33:00 <nominolo> lol
13:33:16 <nominolo> 10^-6 olegs or so ;)
13:33:30 <nominolo> @karma lambdabot
13:33:31 <lambdabot> lambdabot has a karma of 41
13:34:01 <matthew-_> is Oleg actually real or is this some mythical genius?
13:34:18 <dmhouse> ?google Oleg Haskell
13:34:19 <syntaxfree> I think Oleg is like Bourbaki.,
13:34:20 <lambdabot> http://okmij.org/ftp/
13:34:20 <lambdabot> Title: This FTP site
13:34:33 <nominolo> matthew-_: both ;)
13:34:40 <syntaxfree> @kind oleg
13:34:43 <lambdabot> Not in scope: type variable `oleg'
13:34:45 <nominolo> oh, no, not mythical
13:34:47 <syntaxfree> @kind Oleg
13:34:49 <lambdabot> Not in scope: type constructor or class `Oleg'
13:34:53 <nominolo> @where oleg
13:34:54 <lambdabot> http://okmij.org/ftp/
13:35:25 <jmelesky> Oleg was the one who proved Haskell's type-system itself was turing-complete, right?
13:35:25 <nominolo> there's a lecture video of him on google video on danfest
13:35:25 <matthew-_> I see
13:35:30 <helmut> Hi. Could you help me with syntax again? What is the correct form of instance (Show a, Eq a) => Monad (Spam a) where ...?
13:35:47 <nominolo> @go oleg kiselov danfest google video
13:35:48 <Heffalump> helmut: that looks right to me.
13:35:49 <lambdabot> No Result Found.
13:35:59 <Heffalump> does it not work?
13:36:04 <syntaxfree> @go speed racer
13:36:06 <lambdabot> http://www.speedracer.com/
13:36:14 <TomMD> @go xmonad
13:36:17 <lambdabot> http://xmonad.org/
13:36:17 <lambdabot> Title: xmonad : a tiling window manager
13:36:19 <Heffalump> oh, I see the problem
13:36:22 <helmut> Heffalump: Expected kind `* -> *', but `Spam a' has kind `*'
13:36:24 <Heffalump> what is the definition of Spam?
13:36:26 <Heffalump> ok
13:36:39 <Heffalump> the thing you make an instance of Monad has to be a type constructo
13:36:40 <Heffalump> r
13:36:51 <syntaxfree> Wait, wait, wait.
13:36:56 <Heffalump> so you need to write instance Monad Spam, not instance Monad (Spam a)
13:36:56 <syntaxfree> Wait, wait, wait, wait, wait, wait.
13:37:03 <Heffalump> which I suspect means that you can't do what you are trying to do.
13:37:04 <tom_> Anyone here know anything about setting up xmonad?
13:37:05 <syntaxfree> Wait, wait, wait, wait, wait, wait, wait, wait, wait, wait.
13:37:09 <helmut> data (Show a, Eq a) => Spam a = Beacon a | Egg (Spam a) (Spam a) deriving (Show, Eq)
13:37:16 <syntaxfree> the Haskell type system is turing-complete??
13:37:29 <Heffalump> so the problem is that you can't have a Monad that restricts its parameter to members of Show and Eq
13:37:51 <Heffalump> at least, not in Haskell 98. There's talk of it becoming possible in the new ghc, I think, but that's not out yet.
13:38:10 <helmut> So I cannot make Spam be instance Show or Eq?
13:38:23 <syntaxfree> http://video.google.com/videosearch?q=oleg+donfest
13:38:26 <sjanssen> syntaxfree: with common extensions, yes
13:38:28 <lambdabot> Title: oleg donfest - Google Video
13:38:30 <Heffalump> you can't restrict the parameter to Spam to being instance Show and Eq, and still make Spam a monad.
13:38:46 <Heffalump> why do you need those constraints?
13:40:13 <helmut> Heffalump: it really looks like data (Show a, Eq a) => Type a = SomeType a | FuncType (Type a) (Type a) deriving (Show, Eq)
13:40:29 <nominolo> syntaxfree: yes, with MPTCs and undecidable instances
13:40:29 <jmelesky> syntaxfree: http://www.haskell.org/pipermail/haskell/2006-September/018486.html
13:40:32 <lambdabot> Title: [Haskell] On computable types. I. Typed lambda and type closures, http://tinyurl.com/2x8mvd
13:40:50 <Heffalump> helmut: ok, but why are the Show and Eq constraints required in the data declaration?
13:41:08 <nominolo> syntaxfree: GHCHaskellTypeSystem = Prolog - Backtracking + ALotOfLineNoise
13:41:11 <helmut> Heffalump: because Types essentially need to be Equity comparable.
13:41:22 <helmut> Heffalump: without that they're useless.
13:41:49 <Heffalump> helmut: can't you just write instance Monad Spam anyway?
13:42:00 <Heffalump> and then just use it only on Eq/Show types
13:42:12 <helmut> Heffalump: Could not deduce (Show a, Eq a) from the context (Monad Type)
13:42:24 <Heffalump> ok, then remove it from the context of the data declaration
13:42:36 <Heffalump> it won't do much good there anyway, you'll still need it in the context of any functions that work on Type
13:43:03 <helmut> Heffalump: ok. :-)
13:43:12 <helmut> works
13:45:54 <syntaxfree> gah. oleg sure is humbling.
13:47:41 * shapr agrees
13:47:50 <shapr> I met Oleg at HW2006, he's cool.
13:47:50 <kosmikus> what has he done now? :)
13:49:06 <DukeDave> Lol, this is so frustrating, have a problem for you guys but my God I'm having difficulty expressing it! ;)
13:49:51 <kc5tja> DukeDave: When you can express it, you're liable to find the solution too.  :)
13:50:44 <DukeDave> Hehe, I know.. Basically I have an implementation which 'looks' like it would be more elegant if it used the State Monad..
13:51:29 <desp> ha
13:51:33 <desp> the MS CLR is going cross-platform
13:51:38 <DukeDave> Although, I'm not sure if I really 'need' to use it :S
13:51:49 <Heffalump> desp: what platform(s)?
13:52:15 <desp> well, Core CLR
13:52:35 <shapr> Cale: Where's desrt these days?
13:53:25 <desp> Heffalump: apparently Mac OS X for now
13:54:05 <kc5tja> They don't need to port to Linux since we already have Mono.
13:57:24 <helmut> is there some pretty printer for treelike data structures? ;-)
13:58:59 <shapr> Does anyone know what format is output from "openssl genrsa"? It doesn't appear to be PKCS8, or at least the PKCS8Example from Language.ASN1 doesn't parse the DER form of genrsa output.
13:59:12 <TuringTest> @type drawTree
13:59:15 <lambdabot> Tree String -> String
13:59:18 * gene9 is looking for pretty printer also
13:59:26 <TuringTest> @type drawForest
13:59:29 <lambdabot> Forest String -> String
14:00:13 <TuringTest> helmut and gene9: Those function are for Data.Tree.  If you need to adapt them then you could copy the source
14:03:21 <Cale> shapr: no idea
14:03:52 <gene9> TuringTest hmm. it's the way. hard way .)
14:04:01 <shapr> Cale: I heard he was in .au, but that's the last I know.
14:10:18 <whaleofconfusion> is it possible to construct a value x such that f x = f 3 for all f except for g, where g x = g 4?
14:11:17 <syntaxfree> haha. that's such an excellent nickname.
14:11:50 <syntaxfree> I don't think you can construct a value x such that f x = f 3 for all functions.
14:12:40 <whaleofconfusion> well you could let x be 3
14:12:58 <int-e> hmm. g 3 = g 4
14:13:27 <whaleofconfusion> no, g 3 and g 4 must be different for it to be more than just a brainteaser
14:14:29 <SamB> but you said g x = 4
14:14:31 <Cale> No, there's no way for a value to observe which function is applied to it.
14:14:33 <SamB> @pl g x = 4
14:14:39 <SamB> heh
14:14:43 <Kobold> It seems as though that would require the value to know what context it's being evaluated in, which isn't possible in general.
14:14:46 <lambdabot> g = const 4
14:15:25 <Cale> SamB: no, he said g x = g 4, but yeah, if g is a constant function already, that's asy.
14:15:28 <Cale> easy*
14:15:37 <Cale> Without assuming anything about g, it's not possible
14:16:21 <int-e> whaleofconfusion: you can try to compare pointers (I guess, using *evil* unsafeCoerce) and the implementation has every right to break that hack.
14:16:24 <SamB> oh, right
14:16:27 <SamB> g x = g 4.
14:16:44 <int-e> whaleofconfusion: oh and that'd be magic in the g function.
14:16:45 <SamB> @pl g x = g 4; g 4 = "hi!"
14:16:46 <lambdabot> (line 1, column 10):
14:16:46 <lambdabot> unexpected ";"
14:16:46 <lambdabot> expecting variable, "(", operator or end of input
14:17:42 <SamB> int-e: I thought there was a reallyUnsafeCompareAddresses or something
14:17:46 <Cale> Well, if you're allowed to control what g is, then you can just pick some g for which g 3 = g 4
14:18:06 <Cale> and then take x = 3 :)
14:19:47 * shapr throws evil lambdas at openssl and Language.ASN1
14:23:44 <shapr> Is ghc 6.6.1 in debian/unstable?
14:24:03 <Cale> http://www.wolfram.com/products/mathematica/newin6/content/UnificationOfGraphicsTextAndControls/IncludeGraphicsAnywhereInAnExpression.html -- hahaha
14:24:06 <lambdabot> Title: Include Graphics Anywhere in an Expression, http://tinyurl.com/2afcmf
14:24:24 <SamB> shapr: doesn't look like it
14:24:38 * xerox pokes Cale :D
14:24:50 * shapr pokes a random byte in Cale's memory.
14:24:56 <Cale> heh
14:25:06 <nominolo> Cale: a friend used to do similar stuff in math classes
14:25:17 <nominolo> he used pentagrams instead of x
14:25:38 <SamB> hmm.
14:25:48 <shapr> I first used POKE and PEEK for programming some 24 years ago.
14:26:04 <SamB> how does mathematica identify graphics?
14:26:25 <shapr> Go C= !
14:26:48 <Cale> SamB: structurally. They're just big expressions.
14:26:58 <monochrom> Is that a joke?
14:27:08 <shapr> My uncle still has one or two C= 64 compatible laptops... made by Osborne. Those things were huge!
14:28:29 <SamB> shapr: you didn't type that correctly
14:30:02 <int-e> SamB: ah. here it is: reallyUnsafePtrEquality#
14:31:05 <dmhouse> int-e: what a great name.
14:31:24 <int-e> dmhouse: hard to remember. just perfect :)
14:31:33 <nominolo> :t \x -> let k = \z.z z in k k
14:31:36 <lambdabot> parse error on input `.'
14:31:43 <nominolo> :t \x -> let k = \z -> z z in k k
14:31:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:31:46 <lambdabot>     Probable cause: `z' is applied to too many arguments
14:31:56 <szabi> is there a portable way to wait for given time in haskell?
14:32:04 <nominolo> @where Y
14:32:05 <lambdabot> I know nothing about y.
14:32:07 <dmhouse> What's next? unsafeNoReallyWeMeanItThisTimeAndToProveItWeAreGoingToMakeThisFunctionNameUnreasonablyLongToPersuadeYouNotToUseItTooFrequently#, maybe?
14:32:36 <SamB> dmhouse: you forgot to mention what it is for
14:32:40 <dmhouse> ?src fix
14:32:41 <lambdabot> fix f = let x = f x in x
14:32:46 <dmhouse> nominolo: how's that?
14:32:57 <monochrom> No need to mention what it is for.  It's polymorphic.
14:33:02 <nominolo> :t \f -> let k = \z -> f (z z) in k k
14:33:03 <dmhouse> SamB: oh, true. Perhaps the entire Haddocks should be camel-case encoded into the name.
14:33:05 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:33:05 <lambdabot>     Probable cause: `z' is applied to too many arguments
14:33:10 <mnislaih> Data.Derive hackers around: can it be used to derive Typeable for System.Time.ClockTime ?
14:33:16 <nominolo> no, i tried to find Y
14:33:25 <nominolo> but wikipedia was faster :)
14:33:34 <int-e> > 'u':cucle"nsafeU"
14:33:35 <lambdabot>   Not in scope: `cucle'
14:33:38 <int-e> > 'u':cycle"nsafeU"
14:33:40 <SamB> hmm, I just got a call from school... apparantly they are opening again tomorrow, but people aren't supposed to bring backpacks, bags, or bundles!
14:33:40 <lambdabot>  "unsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUns...
14:33:45 <dmhouse> nominolo: well, what you've written there doesn't typecheck in any reasonable type system (like Haskell's).
14:33:53 <SamB> I'm not exactly sure what the point of this is...
14:34:45 <nominolo> dmhouse: good point
14:34:48 <syntaxfree> @paste
14:34:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:35:04 <syntaxfree> I wish paste.haskell.org would redirect to hpaste.org
14:35:28 <syntaxfree> anyway, is anyone bored enough to take a look at this?
14:35:28 <syntaxfree> http://hpaste.org/1641
14:35:53 <dmhouse> syntaxfree: if you're using Emacs, you could have made that paste using hpaste.el! </shameless-plug>
14:36:06 <SamB> so should I stay home, go to school with one or two books (and nowhere to put a book for the bus!), or bring my backpack anyway?
14:36:11 <Syzygy-> > 'u':(cycle "nsafeU")++"serIOAction"
14:36:12 <lambdabot>  "unsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUns...
14:36:43 <syntaxfree> Emacs suffers from the same problem of the Dvorak layout.
14:36:53 <SamB> > 'u':(cycle "nsafeU")++"SerIOAction"
14:36:55 <lambdabot>  "unsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUnsafeUns...
14:36:55 <syntaxfree> You need to stop being productive for a couple of months before you get super-badass-productive.
14:36:57 <int-e> @remember primops.txt.pp (#1 Bad Guy: Alistair Reid :)
14:36:57 <lambdabot> Done.
14:37:20 <int-e> [that line is right next to the definition of pointer equality]
14:37:22 <Syzygy-> SamB: Why the Ser ?
14:37:23 <monochrom> That is a description of Haskell.
14:37:26 <nominolo> syntaxfree: how long does it take to catch up on the lost productity?
14:37:39 <SamB> syntaxfree: because it would go after an "e" if it went anywhere!
14:37:44 <syntaxfree> nominolo: you know, I can't just afford stop being productive right now.
14:37:45 <SamB> not at the beginning of the name
14:38:12 <syntaxfree> monochrom: well, no, it isn't.
14:38:19 <Syzygy-> SamB: Why wouldn't it go at the end of the cycle bit?
14:38:21 <syntaxfree> Haskell isn't gratuituosly obscure.
14:38:32 <Syzygy-> Apart from small stuff like it being obviously ill defined...
14:38:39 <sjanssen> > 20 * 20 * 3
14:38:41 <lambdabot>  1200
14:39:14 <SamB> syntaxfree: sure it is
14:39:26 <SamB> well, maybe not gratuitously...
14:39:46 <syntaxfree> it would be gratuituosly obscure if it employed Squiggol notation, for example.
14:39:48 <SamB> but, remember the old motto?
14:39:53 <SamB> "avoid success at all costs"
14:39:54 <syntaxfree> [(a,b)] for folds, ([a,b]) for unfolds and suchlike.
14:40:38 <SamB> syntaxfree: those aren't real lenses
14:40:41 * kc5tja does some more polishing on CUT's cutgen....
14:40:44 <SamB> you should use real lenses
14:40:56 <syntaxfree> {[]}
14:41:08 <SamB> that isn't real barbed wire
14:41:24 <kilimanjaro> yea
14:41:28 <LoganCapaldo> > {[]}
14:41:28 <lambdabot>  Parse error
14:41:38 <kilimanjaro> that's not a real error
14:41:43 <kilimanjaro> it's only the idea of an error
14:41:56 <syntaxfree> I'm frustrated at project euler.
14:42:02 <monochrom> I am summarizing the sentiment of many who posted to the "Newbie" thread.  I myself find nothing to be obscure.  Squiggol is obvious to me.
14:42:06 <syntaxfree> I have the correct solution and it tells me its not.
14:42:17 <LoganCapaldo> project euler is frustrated with you
14:42:45 <LoganCapaldo> are you using the correct units?
14:42:49 <LoganCapaldo> heh
14:43:15 <kilimanjaro> Must be well-typed
14:44:05 <syntaxfree> monochrom: the point is, emacs is just an incrementally more productive way of doing what i'm already doing.,
14:44:08 <syntaxfree> so is dvorak.
14:44:21 <syntaxfree> learning Haskell is like learning the calculus. It's a completely new, shiny tool.
14:44:26 <kc5tja> Does ghc's runtime realize when you're redirecting the command's output to /dev/null, and just never evaluate anything that produces output to stdout?  I did a profiling test on my project, and redirected output to /dev/null, and the profile run's output is half of what it normally is.
14:44:45 <kilimanjaro> syntaxfree, how long did it take you to feel comfortable with dvorak?
14:44:45 <SamB> kc5tja: wierd!
14:44:47 <SamB> I'd hope not
14:44:53 <syntaxfree> kilimanjaro: I never did.
14:44:55 <SamB> because that would mess with strictness
14:45:09 <syntaxfree> I'm hoping I eventually get faster with dasher than I am with a keyboard.
14:45:15 <kilimanjaro> syntaxfree, dasher?
14:45:19 <SamB> kc5tja: what happens if you redirect to a file?
14:45:21 <syntaxfree> except the OS X port of dasher is freaking unstable.
14:45:44 <osfameron> dasher is very odd
14:45:52 <syntaxfree> http://www.dasher.org.uk/DasherSummary2.html
14:45:54 <monochrom> Yes, and so, I say: "stop being productive for a couple of months before you get super-badass-productive" is a description of Haskell.
14:45:55 <lambdabot> Title: Inference Group: Dasher Project: How does Dasher work?
14:46:24 <kilimanjaro> syntaxfree, that would probably give me motion sickness
14:46:34 <syntaxfree> the motion sickness wears off.
14:46:43 <syntaxfree> the thing learns from your writing too, so it's kinda interesting.
14:46:56 <syntaxfree> it randomly crashes on my mini though.
14:47:15 <monochrom> It tries to learn you. Then its brain explodes.
14:47:17 <kc5tja> SamB: I just tried it -- same thing.  So, something bizarro is happening.  :(
14:47:36 <SamB> kc5tja: xterm is SLOOOW
14:47:58 <kc5tja> xterm is plenty fast enough for me.
14:48:15 <kilimanjaro> syntaxfree, part of me thinks it would be cool if people figured out the most effiicient sign language for expressing haskell and then you could just use sensor gloves
14:48:18 <SamB> yes but it is still a lot slower than nothing, or even than a file
14:48:39 <kc5tja> Well, the program isn't producing a damn lick of output now.  >:(
14:48:48 <SamB> ... oh?
14:48:52 <SamB> okay that *is* wierd
14:49:43 <kc5tja> Doggone it, I know what I did.  >:(
14:51:48 <sjanssen> syntaxfree: do you want to compare solutions to problem 11?
14:52:08 <ptolomy> Do people generally consider haskell to be an "agile" language?
14:52:18 <sjanssen> syntaxfree: I just coded up a quick solution, not 100% sure that it's right
14:52:19 <kc5tja> Boy, when they say that Haskell is lazy, they really mean it.  The problem was that I was early-exiting because all CUT tokens start with __CUT_ somehow.  Well, I forgot to use not $ on my predicate to test for that.  :)
14:52:35 <monochrom> No, Haskell is not considered an agile language.
14:52:40 <kc5tja> So, naturally, all tokens were being treated as invalid, and therefore, well, nothing to do.  :)
14:53:03 <monochrom> Haskell is a lazy language.
14:53:06 * kc5tja has never heard of a satisfactory definition of an agile language.
14:53:27 <monochrom> Here is a satisfactory definition.  agile = not lazy.  :)
14:53:28 <kilimanjaro> Most Haskell programmers are not agile either, due to poor diet and a lack of exercise
14:53:41 <SamB> well, raw machine code is not generally one
14:53:50 <SamB> kilimanjaro: aren't those stereotypes a bit old?
14:53:55 <SamB> not that I don't fit them
14:53:57 * kc5tja has done agile coding with Oberon and C, so ...
14:54:09 <kc5tja> (in fact, that's the whole purpose of CUT.  :) )
14:54:36 <monochrom> I thought the Haskell programmer stereotype was "vegetarian, unicycle".  Can't say lack of exercise there.
14:54:41 <shapr> mnislaih: I use EpochSeconds instead of ClockTime
14:54:56 <LoganCapaldo> vegatarian with a unicycle? bizzare
14:55:06 <ptolomy> Well, you can do agile-style coding in any language, but the definition I'm choosing is "changing stuff when needed is cheaper than planning ahead and being wrong now and then".
14:55:07 <SamB> vegatarian?
14:55:08 <SamB> what?
14:55:09 <Cheery> @hoogle (Fractional a, Enum b) => a -> b
14:55:09 <mnislaih> thanks shapr, I'll give a look
14:55:10 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
14:55:11 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
14:55:11 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
14:55:11 <shapr> mnislaih: toEpochSeconds :: ClockTime -> EpochSeconds \n toEpochSeconds ct = let TOD sec _ = ct in fromIntegral sec
14:55:22 <SamB> I'd be a meat eater if it wasn't so expensive!
14:55:25 <quicksilver> kc5tja: an agile language is one that, just when you think you have it pinned down, kicks you in the teeth
14:55:32 * kc5tja is hardly vegetarian (though I have nothing against it, and enjoy veggie dishes too!), but I DO bike ride a lot.
14:55:47 <kc5tja> quicksilver: OH....so...like Haskell then?  :D
14:55:54 <shapr> I consider Haskell an agile language!
14:55:55 <monochrom> @remember SamB I'd be a meat eater if it wasn't so expensive!
14:55:56 <lambdabot> Done.
14:55:57 <mnislaih> shapr: I see
14:56:06 <kc5tja> "Hah, this should fix the proble....WHAT?!  FIFTEEN TYPE ERRORS?~!"
14:56:16 <SamB> actually I eat meat
14:56:28 <shapr> mnislaih: HAppS can only serialize things that have Read/Show defined, and EpochSeconds does, ClockTime doesn't.
14:56:29 <SamB> what I mean is that I'd eat almost nothing but if it wasn't so expensive
14:57:07 <mnislaih> shapr: yes, I'm working with HAppS. What annoys me is the Read requeriment, shouldn't it use the Serialize class ?
14:57:19 * kc5tja hugs GHC's profiler.  The best profiler in the world.  Ever.
14:57:32 <monochrom> Really?
14:57:45 <kc5tja> CUT bores through the 7MB C test input file in 4.5 seconds now.  BOOYAH.
14:57:56 * Cale is getting sick of non-programming articles ending up on programming.reddit.com with hundreds of points.
14:58:46 * kc5tja thanks dons and everyone else who has helped me to understand a bit more about what's going on.  Alas, I'm liable to continue to have a large quantity of questions though.  But this rocks.
14:58:56 <Cheery> How could I turn fractional into enum?
14:59:18 <int-e> Cheery: uh, why do you need to?
14:59:35 <LoganCapaldo> fromEnum ?
14:59:37 <Cheery> well, Actually I don't necessarily
14:59:52 <Cheery> I'd need to forge picoseconds into milliseconds
14:59:58 <shapr> mnislaih: It used to, but I think it got changed so that you only needed to have Read and Show instead.
15:00:13 <shapr> I think alex felt that Serialize caused too much boilerplate code in simple applications.
15:00:16 <Cheery> my picoseconds are in integer form
15:00:34 <Cheery> so it'd reduce to getting Enum from integer
15:00:54 <int-e> Cheery: then divide by 10^9?
15:01:26 <Cheery> :t div
15:01:26 * kc5tja would think fromEnum converts something _from_ an enum into something else.  What is the logic behind naming it fromEnum instead of toEnum?
15:01:29 <lambdabot> forall a. (Integral a) => a -> a -> a
15:01:36 <int-e> I don't understand where the Enum comes in.
15:01:49 <kc5tja> 14:55 < Cheery> How could I turn fractional into enum?
15:01:51 <kc5tja> 14:56 < LoganCapaldo> fromEnum ?
15:02:22 <SamB> @type fromEnum
15:02:24 <LoganCapaldo> kc5tja: I could be confused :)
15:02:25 <lambdabot> forall a. (Enum a) => a -> Int
15:02:34 <TuringTest> Perhaps we should record time in Cs oscillations? "1 second = 9,192, 631,770 cycles of the standard Cs-133 transition"
15:02:37 <LoganCapaldo> See?
15:02:47 <mnislaih> shapr: in any case, there is an instance of Serialize available, so HAppS should try to use that. Anyway, I guess I can always define Read and Show in terms of Serialize, but it is a bit confusing.
15:03:03 <SamB> TuringTest: maybe on 128-bit computers
15:03:04 <shapr> mnislaih: Send an email to the HAppS list?
15:03:10 <ptolomy> What is CUT?
15:03:22 <LoganCapaldo> :t toEnum . toInteger
15:03:24 <lambdabot>     Couldn't match expected type `Int' against inferred type `Integer'
15:03:25 <lambdabot>     In the second argument of `(.)', namely `toInteger'
15:03:46 <LoganCapaldo> :t toEnum . toInt
15:03:49 <lambdabot> Not in scope: `toInt'
15:03:54 <LoganCapaldo> merp
15:04:02 <LoganCapaldo> @hoogle Integer -> Int
15:04:03 <lambdabot> No matches, try a more general search
15:04:10 <mnislaih> shapr: actually I sent one a few days ago; did you read it ? any idea ?
15:04:23 <Cheery> 10^8
15:04:26 <LoganCapaldo> :t toIntegral
15:04:28 <lambdabot> Not in scope: `toIntegral'
15:04:34 <LoganCapaldo> le sigh
15:04:40 <kc5tja> ptolomy: http://www.falvotech.com/content/cut -- C Unit Test tool.
15:04:43 <lambdabot> Title: CUT
15:04:45 <syntaxfree> oh noes.
15:04:49 <ptolomy> aahhh.
15:05:00 <kc5tja> Currently written in C, but I'm rewriting the next version in Haskell.
15:05:11 <LoganCapaldo> @hoogle (Integral a) => a -> Int
15:05:12 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
15:05:13 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
15:05:13 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
15:05:15 <kc5tja> I did it as an excuse to force a maintenance release of CUT, but more importantly, as a vehicle to learn some Haskell.
15:05:47 <LoganCapaldo> Is there really no built in way to go from Integer to Int?
15:06:02 <int-e> LoganCapaldo: fromInteger, or fromIntegral
15:06:06 <ptolomy> fromIntegral
15:06:22 <LoganCapaldo> :t toEnum . fromIntegral
15:06:25 <int-e> @src fromIntegral
15:06:25 <lambdabot> fromIntegral = fromInteger . toInteger
15:06:25 <lambdabot> forall a a1. (Enum a, Integral a1) => a1 -> a
15:06:41 <LoganCapaldo> huzzah
15:06:56 <LoganCapaldo> :t fromIntegral
15:06:58 <lambdabot> forall a b. (Num b, Integral a) => a -> b
15:08:49 <LoganCapaldo> @bs
15:08:50 <lambdabot> Done.
15:08:55 <LoganCapaldo> what?
15:09:02 <LoganCapaldo> @botsnack
15:09:02 <lambdabot> :)
15:09:06 <LoganCapaldo> @help bs
15:09:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:09:23 <LoganCapaldo> :(
15:09:30 <LoganCapaldo> @list
15:09:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:10:09 <LoganCapaldo> bs is not on the list of commands
15:10:11 <LoganCapaldo> @bs
15:10:11 <nominolo> LoganCapaldo: @ tries to correct
15:10:12 <lambdabot> Done.
15:10:19 <LoganCapaldo> ?bs
15:10:20 <lambdabot> Done.
15:10:23 <nominolo> @losers
15:10:24 <lambdabot> Maximum users seen in #haskell: 336, currently: 328 (97.6%), active: 51 (15.5%)
15:10:28 <nominolo> oh
15:10:37 <LoganCapaldo> but what is it correcting too?
15:10:40 <LoganCapaldo> *to
15:10:53 <nominolo> well, ?bs shouldn't correct
15:11:01 <LoganCapaldo> ?losers
15:11:02 <lambdabot> Maximum users seen in #haskell: 336, currently: 328 (97.6%), active: 51 (15.5%)
15:11:04 <nominolo> so it seems to be a correct command
15:11:14 <nominolo> !bs
15:11:20 <nominolo> ok, that's new
15:11:33 <nominolo> @uptime
15:11:34 <lambdabot> uptime: 8d 15h 25m 37s, longest uptime: 8d 15h 25m 37s
15:12:08 <LoganCapaldo> @tell me what bs means
15:12:09 <lambdabot> Consider it noted.
15:12:13 <LoganCapaldo> heh
15:12:26 <me> hello
15:12:27 <lambdabot> me: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:12:36 <Ogedei> practical question: say I have a tree structure built out of a bunch of different data types, and I need to traverse it to do stuff with some nodes -- the straightforward code for a traversal is easy, but I need to do a few different things to a few different nodes. this gives me a bunch of very similar pieces of code. what would be a good way to shorten/simplify/generalize traversals?
15:12:39 <me> @messages
15:12:40 <lambdabot> br1kok said 6m 15d 2h 43m 16s ago: hi
15:12:40 <lambdabot> zeeeeeee said 4m 1d 22h 37m 57s ago: aoeu
15:12:40 <lambdabot> LoganCapaldo said 31s ago: what bs means
15:13:30 <nuncanada> @tell lambdabot hello, am i recursive?
15:13:31 <lambdabot> Nice try ;)
15:13:32 <nominolo> "4m 1s" ago?  that's 4 months?
15:13:37 <LoganCapaldo> Isn't what Ogedei asked about exactly what SYB is for?
15:13:37 <sorear> hello!
15:13:44 <sorear> nominolo: or minutes!
15:13:48 <LoganCapaldo> @where SYB
15:13:49 <lambdabot> I know nothing about syb.
15:13:56 <Ogedei> LoganCapaldo: what does syb stand for?
15:13:56 <nominolo> sorear: no, the first one
15:14:00 <nuncanada> @tell lambdabot hello, am i recursive?
15:14:00 <lambdabot> Consider it noted.
15:14:01 <Pastorn> @seen cantadou
15:14:02 <lambdabot> I haven't seen cantadou.
15:14:09 <nominolo> Ogedei: Scrab Your Boilerplate
15:14:17 <nominolo> *scrap
15:14:22 <Ogedei> nominolo: hah, sounds like what i need, i'll google
15:14:26 <LoganCapaldo> http://www.cs.vu.nl/boilerplate/
15:14:27 <lambdabot> Title: Scrap your boilerplate ... in Haskell
15:14:38 <sorear> nominolo: yep, fst is 4 months ago
15:15:17 <nominolo> lambdabot has a memory like an elephant, then :)
15:15:25 <nominolo> @botsnack
15:15:25 <lambdabot> :)
15:15:58 <nominolo> @seen br1kok
15:15:59 <lambdabot> I haven't seen br1kok.
15:16:12 <nuncanada> @tell nuncanada hello, am i recursive?
15:16:13 <lambdabot> You can tell yourself!
15:16:50 <nominolo> hehe, that's why he didn't use lambdabot in Memento :)
15:17:03 <nornagon> @tell lambdabot recurse moar
15:17:04 <lambdabot> Nice try ;)
15:17:05 <nuncanada> @tell chanserv you there?
15:17:05 <lambdabot> Consider it noted.
15:17:45 <nuncanada> @tell #haskell I will always be here.
15:17:46 <lambdabot> Consider it noted.
15:17:57 <int-e> huh
15:20:00 <dmwit> Is there a ?count-messages or so?  I think it would be fun to see how long the queue is from bogus stuff like that... =)
15:20:28 <Gwern> it's interesting to read the latest Monad Reader where the Jane street guy is complaining about printing values in OCaml. this is solved in haskell through Show, right?
15:21:16 <nominolo> Gwern: or better through your own class
15:22:02 <Gwern> nominolo: but that's usually just 'deriving (Show)' from what I've seen
15:22:03 <nominolo> > printf "%6.2f" 3.14159265358979
15:22:04 <lambdabot>  Add a type signature
15:22:18 <nominolo> :t printf
15:22:20 <lambdabot> forall r. (PrintfType r) => String -> r
15:22:29 <nominolo> > printf "%6.2f" (3.14159265358979 :: Double)
15:22:30 <lambdabot>  Add a type signature
15:22:41 <monochrom> :: String
15:22:44 <nominolo> > printf "%6.2lf" 3.14159265358979 :: String
15:22:46 <lambdabot>  Exception: Printf.printf: bad formatting char l
15:22:54 <nominolo> > printf "%6.2f" 3.14159265358979 :: String
15:22:56 <lambdabot>  "  3.14"
15:23:21 <nominolo> Gwern: yes, but it give you little control
15:23:35 <monochrom> You need ::String because it could be ::IO() instead.
15:23:39 <nominolo> Gwern: if you want to have more control you better define your own instance
15:23:49 <nominolo> @instances PrintfType
15:23:50 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
15:24:14 <sorear> dmwit: it was 500-something, but I just flushed it
15:24:19 <sorear> @print-notices
15:24:20 <lambdabot> fromList []
15:24:33 <LoganCapaldo> :t fromList
15:24:35 <lambdabot> Not in scope: `fromList'
15:24:42 * Gwern shrugs. thus far I haven't wanted more complex output than Show provides
15:24:50 <sorear> LoganCapaldo: show syntax for Data.Map
15:24:54 <nominolo> :t Data.Map.fromLIst
15:24:55 <dmwit> sorear: That's a lot...
15:24:56 <lambdabot> Not in scope: `Data.Map.fromLIst'
15:24:59 <nominolo> :t Data.Map.fromList
15:25:02 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
15:25:05 <sorear> dmwit: 500?
15:25:10 <nominolo> :t Data.Set.fromList
15:25:13 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
15:25:33 <dmwit> sorear: Well, yeah, if all of them were bogus.
15:25:40 <nominolo> :t DonsLatestArticle.StackSet.fromList
15:25:43 <lambdabot> Couldn't find qualified module.
15:25:50 <LoganCapaldo> > Data.Map.fromList [("a", 1), ("a", 2), ("b", 3)]
15:25:51 <lambdabot>   Not in scope: `Data.Map.fromList'
15:25:57 <LoganCapaldo> fine
15:26:31 <sorear> kilimanjaro: ut;s unoirted as N,
15:26:41 <nominolo> fromList could well be a type class
15:26:43 <sorear> grumble, keyboard misalighment error
15:26:52 <sorear> LoganCapaldo: it's imported as M.
15:26:59 <sorear> > M.fromList [("a", 1), ("a", 2), ("b", 3)]
15:27:00 <lambdabot>  fromList [("a",2),("b",3)]
15:27:24 <nominolo> :t M.adjust
15:27:27 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
15:27:32 <LoganCapaldo> Speaking of IsString....
15:27:52 <LoganCapaldo> [("a", 2), ("b", 4)] :: Map [Char] Int
15:28:05 <LoganCapaldo> [1,2,3] :: Array Int
15:28:25 <sorear> Who is this Antonio Cangiano guy and should I drop him a mail complaininga bout how he singlehandedly halved p.h.o's usability?
15:28:28 <LoganCapaldo> Yes? No? Maybe?
15:28:39 <nominolo> :t []
15:28:41 <lambdabot> forall a. [a]
15:29:02 <nominolo> :t ((:) . [])
15:29:05 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
15:29:05 <lambdabot>     In the second argument of `(.)', namely `[]'
15:29:21 <nominolo> ah, who cares
15:30:38 <nominolo> LoganCapaldo: using some clever combination of foldl and M.adjust you could have lists of values for each key
15:31:23 <LoganCapaldo> nominolo: No, no, I was jsut curious what it did when it encountered duplicates, whether it took the first or the last
15:31:29 <LoganCapaldo> that's all
15:31:39 <nominolo> okay
15:31:58 <LoganCapaldo> But thanks anyway :)
15:32:59 <Saizan> how do you turn off the warning on MR?
15:33:18 <sorear> Saizan: upgrade
15:33:30 <monochrom> -fnomonomorphism-restriction
15:33:49 <sorear> Saizan: -fno-warn-monomorphism-restriction
15:34:11 <sorear> Saizan: but if you can figure out how to build modern head, the warning is gone
15:34:26 <nominolo> -fhaskell-prime ;)
15:34:27 <Saizan> sorear: is that so hard?
15:34:37 <sorear> Data/Time/Clock/CTimeval.hs:12:5:
15:34:37 <sorear>     Warning: Definition but no type signature for `Data.Time.Clock.CTimeval.$gtoCTimeval'
15:34:37 <sorear>              Inferred type: Data.Time.Clock.CTimeval.$gtoCTimeval :: (GHC.Base.:*:)
15:34:37 <sorear>                                                                        CLong CLong
15:34:43 <sorear>                                                                      -> CTimeval
15:34:48 <sorear> + -Wall + -Werror = boom
15:35:08 <Saizan> is that in time or in base?
15:35:13 <sorear> needless to say, $gtoCTimeval isn't even in the source!
15:35:15 <sorear> time
15:35:34 <int-e> sorear: -fgenerics generates that.
15:35:44 <int-e> sorear: and I didn't see a -Werror either.
15:35:55 <Saizan> i just deleted time from libraries :)
15:36:00 <sorear> int-e: duh, I didn't paste it :)
15:36:19 <int-e> sorear: no, I had that build error earlier and didn't see a -Werror in that.
15:36:31 <sorear> int-e: yeah.
15:36:45 <sorear> int-e: you don't see compiler flags without a higher cabal -v option
15:36:52 <sorear> at all
15:37:00 <sm> dons: beautiful window manager article, thanks!
15:37:02 <int-e> anyway I can live without a darcs head ghc for a few days :)
15:37:13 <LordBrain> window manager article?
15:37:28 <LordBrain> i want to see
15:37:38 <sm> http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
15:37:40 <lambdabot> Title: Haskell hacking, http://tinyurl.com/232r46
15:37:42 <sorear> int-e: i've been waiting two and a half weeks already.
15:38:46 <LoganCapaldo> > let m = M.fromList [] in foldl (\(k, v) m -> M.insert k (case M.lookup k of Nothing -> [v] ; Just s -> s ++ v) m) m [("a", 1), ("a", 2), ("b", 3)]
15:38:54 <lambdabot>  Couldn't match expected type `M.Map t a -> m a'
15:39:22 <LoganCapaldo> > let m = M.fromList [] in foldl (\(k, v) m -> M.insert k (case M.lookup k m of Nothing -> [v] ; Just s -> s ++ v) m) m [("a", 1), ("a", 2), ("b", 3)]
15:39:23 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
15:39:24 <lambdabot>       Expected...
15:39:36 <chessguy> hi haskellers
15:42:57 <sorear> hi chessguy!
15:44:41 * DukeDave waves
15:46:21 <LoganCapaldo> > let m = M.fromList [] in foldl (\(k, v) m -> M.insert k (case M.lookup k m of Nothing -> [v] ; Just s -> s ++ [v]) m) m [("a", 1), ("a", 2), ("b", 3)]
15:46:22 <lambdabot>  Couldn't match expected type `(t, a)'
15:49:21 <sorear> @users
15:49:21 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 46 (14.6%)
15:50:18 <chessguy> M.fromList?
15:50:30 <chessguy> ?hoogle fromList
15:50:31 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
15:50:31 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
15:50:31 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
15:50:49 <chessguy> how did LB infer Map from M?
15:51:10 <Saizan> import Data.Map as M?
15:51:15 <sorear> yeah
15:51:19 <sorear> that's what it does
15:51:25 <hpaste>  LoganCapaldo pasted "duplicates" at http://hpaste.org/1648
15:51:38 <Saizan> qualified, also
15:51:55 <sorear> there is SUCH easier ways
15:52:49 <LoganCapaldo> But the hard way is more fun
15:52:58 <LoganCapaldo> esp. since I don't actually need to do it
15:53:09 <ddarius_> Map k (v,Int) ?
15:53:23 <hpaste>  sorear annotated "duplicates" with "much easier!" at http://hpaste.org/1648#a1
15:53:53 <LoganCapaldo> ddarius: duplicate occurences of keys not values
15:54:16 <ddarius> ah
15:55:38 <LoganCapaldo> i know multimap was a lousy name
15:59:42 <LoganCapaldo> sorear: I like the list comprehension action
16:12:38 <kc5tja> OK, major problem with ByteString's implementation of hPut.
16:12:52 <kc5tja> When directing to a file, it's apparently not flushing the buffer when .....
16:12:53 <kc5tja> ...
16:13:00 <kc5tja> never mind.  I need to hClose the file.  Duhh.. :(
16:13:04 <sorear> :)
16:13:22 <kc5tja> I would have expected Haskell's RT to do that automatically, but guess not.
16:13:26 <kc5tja> No biggie.
16:13:27 <dmwit> :t foldM
16:13:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:15:54 <Saizan> main/BreakArray.hs:22:0:
16:15:54 <Saizan>     Failed to load interface for `GHC.Prim':
16:15:58 <Saizan>       Use -v to see a list of the files searched for.
16:16:12 <Saizan> ghc still doesn't build for me :\
16:16:39 <sorear> Saizan: you need to pass --with-ghc=/path/to/working/ghc  to ./configure
16:16:49 <Saizan> uh
16:16:59 <sorear> Saizan: 0413 and nearby were buildable, but unable to build ghc.
16:18:32 <kc5tja> Heh, well, it took me two hours to get the code for -o implemented in CUT 2.6, but the doggone thing works!  w00t!
16:18:49 <kc5tja> (mostly due to type errors, and library research)
16:19:32 <ddarius> unsafeCoerce would have gotten rid of those type errors
16:19:57 <Saizan> sorear: so you mean that i should build stage1 with a previous snapshot or 6.6?
16:20:09 <sorear> Saizan: either should work.
16:20:33 <sorear> Saizan: a previous snapshot will go much faster if you have it, because of the -fasm default
16:20:54 <sorear> fantasma `diff` davidL ?
16:21:14 <fantasma> fantasma = davidL
16:21:18 <fantasma> wait
16:21:23 <Saizan> sorear: ok, thanks
16:21:31 <fantasma> wait, how am I on this nick
16:21:49 <sorear> fantasma, davidL_, and davidL are all herew
16:22:17 <hpaste>  dmwit pasted "I feel like this could be a foldM, but how?" at http://hpaste.org/1649
16:23:27 <TSC> What does it do?
16:23:54 <dmwit> It gives a list of lists of counts, where the count never exceeds n, and the list of counts has length m.
16:24:24 <sorear> well, it doesn't work!
16:24:38 <olsner> isn't it just a list of n copies of [0..m]?
16:25:03 <dmwit> Sorry, I got n and m mixed up in my description.
16:25:15 <dmwit> The count never exceeds m, and each list has length n.
16:25:27 <dmwit> olsner: No, definitely not.
16:25:50 <dmwit> For example, atMost 3 2 ~= [[x, y] | x <- [0..3], y <- [0..3]].
16:25:57 <sorear> dmwit: you have no sum check!
16:26:14 <dmwit> sorear: It should allow up to m objects *of each type*.
16:26:27 <dmwit> So at most there are m*n objects.
16:26:50 <sorear> dmwit: give me some data points please?
16:26:58 <sorear> erm, I have lb
16:27:01 <TSC> Ah, I think I see what it does
16:27:35 <dmwit> > let atMost m 2 = [[x, y] | x <- [0..m], y <- [0..m]] in atMost 5 2
16:27:41 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[2,...
16:27:45 <TSC> I think it's equivalent to:
16:27:53 <sorear> > let {  atMost :: (Integral a, Integral b) => a -> b -> [[a]]  ;  atMost m 0 = return []  ;  atMost m n = do  ;  counts <- atMost m (n - 1)  ;  firsts <- [0..m]  ;  return (firsts:counts) } in atMost 3 2
16:27:55 <lambdabot>  [[0,0],[1,0],[2,0],[3,0],[0,1],[1,1],[2,1],[3,1],[0,2],[1,2],[2,2],[3,2],[0,...
16:27:59 <TSC> sequence $ replicate n [0..m]
16:28:01 <dmwit> > let atMost m 3 = [[x, y, z] | x <- [0..m], y <- [0..m], z <- [0..m]] in atMost 2 3
16:28:01 <sorear> > let {  atMost :: (Integral a, Integral b) => a -> b -> [[a]]  ;  atMost m 0 = return []  ;  atMost m n = do  ;  counts <- atMost m (n - 1)  ;  firsts <- [0..m]  ;  return (firsts:counts) } in atMost 1 2
16:28:03 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1,...
16:28:03 <lambdabot>  [[0,0],[1,0],[0,1],[1,1]]
16:28:11 <sorear> TSC: which is called replicateM btw
16:28:21 <TSC> Right (:
16:28:25 <sorear> dmwit: ah yes, that is replicateM!
16:28:29 <sorear> > replicateM 3 2
16:28:31 <lambdabot>   add an instance declaration for (Show (m [a]))
16:28:38 <sorear> > replicateM 3 [0..2]
16:28:40 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,1,2],[0,2,0],[0,2,1],[0,2,2],[1,...
16:28:46 <dmwit> Perfect!
16:28:53 <dmwit> Thanks, guys.
16:35:09 <jmelesky> hm. i'm having trouble installing the X11 package on ghc/OSX/intel. is that an impossible combo?
16:36:00 <sorear> jmelesky: intel what?
16:36:38 <sorear> jmelesky: the X11 package is known incompatible with 64 bit processors
16:36:40 <jmelesky> 2x2.66 dual-core xeon (standard Mac Pro tower)
16:36:49 <jmelesky> ah. ok.
16:37:05 <jmelesky> i was wondering. i didn't recall having problems installing it on my G4 laptop
16:37:10 <sorear> sjanssen: has the 64bit problem been fixed yet?
16:37:25 <TSC> Works fine here (amd64)
16:38:06 <jmelesky> i mean, it's very polite. it tells me it can't be built on my system, which is far nicer than dropping core files or syntax bombs.
16:38:41 <sorear> oh, well, the 64bit issue manifested as silent runtime failure
16:38:47 <sorear> nm then
16:39:02 <jmelesky> hm. perhaps it's not finding my x11 install, then
16:39:14 <sorear> what's the error message?
16:39:21 <sjanssen> jmelesky: you'll need to use darcs version of X11 if you're on 64-bit
16:39:24 <jmelesky> Setup.hs: Package X11-1.2 can't be built on this system.
16:39:34 <sorear> jmelesky: back up?
16:39:53 <sorear> (scrolling that is)
16:40:37 <jmelesky> sorear: the salient piece seems to be "checking for X... no"
16:41:01 <jmelesky> i have the Apple X11 installed, but it's not always findable by unixy things.
16:41:41 <jmelesky> sjanssen: where is it? i'm looking at darcs.haskell.org and don't see it.
16:42:00 <dmwit> ?karma+ haskell
16:42:01 <lambdabot> haskell's karma raised to 24.
16:42:05 <jmelesky> sjanssen: wait, nevermind, it's in packages/
16:42:10 <dmwit> Haskell programs are very short. =)
16:43:44 <jmelesky> dangit. now darcs isn't installing.
16:43:52 * jmelesky is setting up a new machine, in case you can't tell.
16:44:11 <dmwit> ?karma Haskell
16:44:12 <lambdabot> Haskell has a karma of 11
16:44:24 <dmwit> case-sensitivity--
16:45:19 <Saizan> ?karma Haskell|haskell
16:45:19 <lambdabot> Haskell|haskell has a karma of 35
16:45:47 <kuribas> "Perl 6 has been embraced by the Haskell community as a potential scripting language." Is that so?
16:46:13 <kuribas> I thought it was the other way around...
16:46:40 <kuribas> (from <http://en.wikipedia.org/wiki/Perl>)
16:46:49 <liquidengineer> Hi.
16:47:06 <liquidengineer> I've built a very simple Binary Tree structure using the data keyword
16:47:15 <liquidengineer> I was wondering if I can use it to store functions
16:48:03 <monochrom> Yes.  The type variable "a" can be instantiated to "Int -> Bool" for example.
16:49:02 <dmwit> Unless there is a class restriction like (Ord a) => Tree a.
16:49:15 <liquidengineer> there's not. :)
16:49:16 <dmwit> In which case, your functions probably aren't instances of Ord. ;-)
16:49:18 <liquidengineer> so...
16:49:30 <liquidengineer> type NimProgTree = Tree (Int->Int) ?
16:49:34 <liquidengineer> Is it that simple?
16:49:38 <monochrom> Yes.
16:49:55 <dmwit> liquidengineer: Wait, you never use (<)?  In that case, what's the advantage of a tree over, say, a list?
16:50:12 <liquidengineer> what?
16:50:17 <monochrom> I'm sure there is a purpose.
16:50:19 <liquidengineer> what's (<)
16:50:22 <TomMD> How is your tree sorted?
16:50:22 <sorear> dmwit: Sequence is a tree!
16:50:25 <liquidengineer> Oh
16:50:28 <TomMD> less than
16:50:28 <liquidengineer> I don't sort the tree
16:50:34 <liquidengineer> It's a representation of a program
16:50:42 <ddarius> kuribas: As far as I can tell.  That is not the case at all.  If nothing else, I still hate Perl with a passion.
16:50:45 <liquidengineer> it defines an execution path
16:50:54 <dmwit> Ah, okay okay.
16:50:57 <dmwit> cool
16:50:59 <sorear> dmwit: he never said it was a *search* tree
16:51:04 <monochrom> Don't assume!
16:51:06 <dmwit> Right.  My mistake.
16:51:09 <dmwit> =/
16:51:10 <liquidengineer> These programs are actually pretty simple
16:51:22 <kuribas> ddarius: that's what I would guess :)
16:51:28 <liquidengineer> every function's a single in single out function, so I may very well end up using lists of functions and foldr
16:51:32 <monochrom> Or, Assume! Assume the most basic things.
16:51:55 <TomMD> liquidengineer: if you find I good way to do this for complex programs, let us know ;-)
16:52:23 <sorear> Too bad "self-balancing binary search tree" is such a mouthful.
16:52:23 <liquidengineer> Isn't haskell implemented using trees/graphs?
16:52:38 <ddarius> AVL tree
16:52:39 <sorear> if it was shorter, people would use the correct nomenclature more often.
16:52:52 <sorear> liquidengineer: Usually.  (but not necessarily!)
16:53:05 <liquidengineer> I'm in Graph Theory right now
16:53:08 <liquidengineer> and we're using haskell
16:53:13 <liquidengineer> so the implemenation details are neat
16:53:27 <sorear> liquidengineer: the graphiness of haskell data structures is unobservable.
16:53:39 <liquidengineer> Yeah
16:53:44 <liquidengineer> but it's neat to know it's there
16:53:54 <liquidengineer> TomMD: how complex is complex?
16:53:56 <sorear> liquidengineer: it might be better to use clean, which is explicitly graph based (so you have same-node operations etc)
16:54:07 <sorear> liquidengineer: otoh, it could make graphs seem magic.
16:54:17 <jmelesky> well, dangit. the darcs version of X11 is failing on configure.
16:54:28 <sorear> liquidengineer: are you using webs of STRef or indirection Maps?
16:54:33 <liquidengineer> TomMD: I'm basically using a BNF grammar and building parse trees to represent operations
16:54:42 <sorear> jmelesky: --with-x?
16:54:52 <liquidengineer> sorear: Neither
16:54:59 <liquidengineer> I don't even know what that is
16:55:14 <sorear> jmelesky: cabal has an option to pass flags to configure, use --help to find it.
16:55:39 <sorear> jmelesky: autoconf has an option to specify where X is installed, use --optionyoujustfound--help to find it.
16:56:41 <jmelesky> sorear: the error seems to be in Setup.hs itself: Couldn't match expected type `UserHooks' against inferred type `Maybe UserHooks'
16:56:47 <TomMD> BNF: I usually think RFCs (ex: RFC 3344) is sufficiently complex
16:56:59 <TomMD> err... liquidengineer, that was for you
16:57:25 <monochrom> Haha
16:57:32 <sorear> jmelesky: ah, that's the result of a breaking change in cabal.
16:57:43 <TomMD> liquidengineer: Do you plan on public release of any part of your work?
16:57:49 <sorear> jmelesky: edit the Setup.hs file and delete the type signature
16:58:44 <liquidengineer> TomMD: It's nothing very complex
16:59:00 <liquidengineer> It's hardly implemented at all right now...just planning stages
16:59:04 <liquidengineer> But yeah
16:59:10 <liquidengineer> I"m more than happy to send you anything I have
16:59:14 <liquidengineer> though I'm not sure how useful it'd be
16:59:18 <liquidengineer> IS this a valid statement?
16:59:19 <liquidengineer> type NimFunct = (Int -> Int)
16:59:34 <jmelesky> sorear: i don't think the relevant type signature is in Setup.hs
16:59:41 * jmelesky feels quickly out of his depth
17:00:39 <TomMD> liquidengineer: I don't see anything wrong with it... except the name being hard to remember.
17:01:12 <liquidengineer> NimFunct?
17:01:18 <liquidengineer> IT makes sense in the context of the project
17:01:18 <kpreid> the parentheses are unnecessary.
17:01:22 <liquidengineer> Everything's Nim
17:01:25 <liquidengineer> kpreid: so noted
17:04:59 <ddarius> :t elemIndex
17:05:01 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
17:05:03 <ddarius> :t foldM
17:05:06 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:06:02 <kuribas> liquidengineer: ghc has a module for graph functions (Data.Graph.Inductive), at least the version that I use (6.6).
17:06:07 <dmwit> Bah!  I always searched for a -> [a] -> Int and never found anything.
17:06:14 <dmwit> Now here it is as simple as a -> [a] -> Maybe Int.
17:06:41 <liquidengineer> kuribas: yeah...but I have to learn to implement things myself
17:06:56 <liquidengineer> brb
17:08:31 <ddarius> Okay.  It typechecked.  It must be correct.
17:10:23 <SamB> ddarius: oh really?
17:13:37 <chessguy_away> ?remember ddarius It typechecked.  It must be correct.
17:13:38 <lambdabot> Done.
17:15:06 <SamB> @quote
17:15:06 <lambdabot> apfelmus says: Programming in Haskell is like dual-wielding two light sabers whereas programming in imperative languages is like being equipped with a blunt kitchen knife.
17:15:42 <SamB> huh. maybe if you use unsafeMaybeDisembowel a lot...
17:16:34 <kc5tja> For a good time, try to compile a program that accidentally omits a comma in a list of OptDescr objects, and try to decipher the resulting inferred type.  :D
17:16:46 <kuribas> lol, you should add that to :)
17:16:52 <chessguy_away> ?hoogle OptDescr
17:16:52 <dmwit> ?quote
17:16:53 <lambdabot> Distribution.GetOpt.OptDescr :: data OptDescr a
17:16:53 <lambdabot> therp says: and minion pro comes with acrobat reader. I never thought that I would find this proprietary thing useful for anything than blocking my cpu
17:17:09 <dmwit> ?quote
17:17:10 <lambdabot> Binkley says: is it because of your mother that you added an integer to a pointer without a cast?
17:17:40 <decaf> ?quote
17:17:41 <lambdabot> Baughn says: [I] once explained monads to a non-programmer. "And? What's so hard about that?"
17:18:08 <decaf> ?quote
17:18:09 <lambdabot> astrolabe says: I don't know what that means, but it sounds painful.
17:19:16 <decaf> ?quote
17:19:17 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
17:19:35 <pchiusano> hello
17:19:51 <ddarius> show (show x) interesting...
17:19:56 <sorear> hesllo pchiusano !
17:20:14 <pchiusano> hey sorear
17:20:20 <olsner> > show (show 1234)
17:20:22 <lambdabot>  "\"1234\""
17:24:40 <pchiusano> is there a way from ghci that I can see what names are in scope?
17:24:52 <pchiusano> or some way I can get all the names imported by a module?
17:26:06 <sorear> <TAB><TAB>, and :br <module>, respectively.
17:27:01 <dmwit> <tab><tab> shows the files in the current directory for me, but :b is very nice.
17:27:18 <sorear> dmwit: you must have an oldish version of ghci
17:27:31 <sorear> dmwit: newer ones use a custom completion function
17:27:41 * sorear regress-tests his collection of ghcs
17:27:55 <pchiusano> files in the current directory?
17:27:58 <dmwit> sorear: Ah, yeah, I have 6.4.1.
17:28:13 <sorear> my 6.4.2 lists files, my 6.6 and HEAD list symbols.
17:28:37 <sorear> pchiusano: yes, files that are in the current directory.  I take it you don't use *nix.
17:28:43 <pchiusano> is there a way I can get the info from <tab><tab> as a list of strings
17:28:59 <pchiusano> well, osx
17:28:59 <ddarius> Someone give me a (non-extended) regex.
17:29:05 <sorear> x
17:29:15 <ddarius> That's remotely interesting.
17:29:17 <sorear> pchiusano: system "ghci -e ':br'"
17:29:32 <sorear> ddarius: how about .*\.hs?
17:29:44 <sorear> the ? was not in the literal
17:29:45 <dfranke> (^(Mailing-List:|Precedence:.*(junk|bulk|list)|To: Multiple
17:29:45 <dfranke>        recipients of |(((Resent-)?(From|Sender)|X-Envelope-From):|>?From
17:29:45 <dfranke>        )([^>]*[^(.%@a-z0-9])?(Post(ma?(st(e?r)?|n)|office)|(send)?Mail(er)?
17:29:45 <dfranke>        |daemon|m(mdf|ajordomo)|n?uucp|LIST(SERV|proc)|NETSERV|o(wner|ps)
17:29:45 <dfranke>        |r(e(quest|sponse)|oot)|b(ounce|bs\.smtp)|echo|mirror|s(erv(ices?|er)
17:29:45 <dfranke>        |mtp(error)?|ystem)|A(dmin(istrator)?|MMGR|utoanswer))(([^).!:a-
17:29:47 <dfranke>        z0-9][-_a-z0-9]*)?[%@>\t ][^<)]*(\(.*\).*)?)?$([^>]|$)))
17:30:11 <dmwit> jeez
17:30:13 <sorear> dfranke: please don't paste the value of procmail's FROM_DAEMON
17:30:14 <dfranke> not sure if that's extended or not.
17:30:46 <sorear> that regex was so bad it was burned into my eyeballs when I saw it in procmail(1)
17:30:58 <sm> ha, that's nothing :)
17:31:05 <dfranke> I've done worse.
17:31:07 <sorear> @google Regular expressions can be simple and fast
17:31:10 <lambdabot> http://swtch.com/~rsc/regexp/regexp1.html
17:31:11 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
17:31:20 * ddarius hasn't added any character classes.
17:31:27 <sorear> re optimization is for people with dumb  libraries!
17:31:28 <dfranke> I once wrote a regex that matches Scheme's numeric literals.
17:31:28 <dmwit> sorear: An excellent article.
17:31:45 <dfranke> it was two screens long.
17:31:55 <sorear> dfranke: I did it with Parsec. :)
17:32:27 <ddarius> dmwit: Indeed.  That is what I'm implementing.
17:33:14 <ddarius> Right now, I have a regex parser, a compiler to a NFA, and dot output for the NFAs.
17:33:17 <dons> moin
17:33:35 <sorear> hiya dons
17:33:39 <sorear> ddarius: 'dot'?
17:33:49 <ddarius> www.graphviz.org
17:34:27 <liquidengineer> @paste
17:34:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:35:59 <sorear> ooh cool re visualizing
17:36:10 <emu> yea i use dot for my NFAs/DFAs output too
17:36:13 <emu> it's hot
17:36:32 <hpaste>  LiquidEngineer pasted "Problem Deriving Eq" at http://hpaste.org/1651
17:37:00 <liquidengineer> If anyone has any ideas as to why that data declaration doesn't properly derive Eq, I would be most greatful
17:37:03 <olsner> (Eq a) => (Tree a -> ...)
17:37:04 <sorear> liquidengineer: you need an instance of Eq for a!
17:37:24 <sorear> correct -> isLeaf :: Eq a => Tree a -> Bool
17:37:26 <emu> i wrote a library to parse regexes, convert to DFA, minimize, and go back to regexes among other things
17:37:35 * olsner knows but does not understand
17:37:59 <liquidengineer> olsner: there is no spoon
17:38:21 <olsner> DFA -> regexp algorithms seldom give readable regexps though
17:38:23 <liquidengineer> sorear: Oh my GOd.  I'd just like to say I usually know to instanteate a in functions
17:38:26 <liquidengineer> brainfart
17:38:36 <emu> that they don't heh
17:38:37 * liquidengineer feels stupid
17:38:47 <emu> i'm more interested in the algebraic analysis
17:39:00 <emu> and cool looking graphs!
17:39:07 <Pseudonym> You know, there's a problem here.
17:39:16 <Pseudonym> Wiht that "simple and fast" paper.
17:39:22 <olsner> algebraic = applying regexp rules for simplification?
17:39:28 <Pseudonym> Regular expressions != posix regexps.
17:39:31 <Pseudonym> Or even PCREs.
17:39:43 <emu> olsner: no, dealing with automatons in an algebraic theory
17:39:55 <Pseudonym> When you add backreferences and stuff, the "simple and fast" goes out the window.
17:39:58 <emu> i'm talking about regular languages here, not pcre
17:40:11 <kc5tja> Question: is there any way to get argv[0] in Haskell?  getArgs apparently only returns argv[1:]
17:40:15 <emu> backreferences make "regex" deciding NP-complete
17:40:22 <Pseudonym> Yeah, but it's unfair to compare Perl regexes with the Thompson NFA algorithm.
17:40:24 <emu> kc5tja: there's a getProgramName somewhere
17:40:30 <Pseudonym> That's my point.
17:40:33 <thoughtpolice> kc5tja: getProgramName is in System.Environment
17:40:36 <stepcut> I am building ghc 6.6.1 using ghc 6.6.1, do I need to build the stage1 compiler ?
17:40:40 <kc5tja> emu: Thanks.  I tried finding something but wasn't able to find anything.  This gives me a clue at least.
17:40:41 <int-e> @index getProgName
17:40:41 <lambdabot> System.Environment
17:40:46 <Pseudonym> Yeah, it's slow in Perl, PHP, Python etc.
17:40:48 <Pseudonym> But they do more.
17:40:53 <sorear> Pseudonym: you need to actually read the paper.
17:41:01 <sorear> Pseudonym: they do talk about the problem
17:41:04 <Pseudonym> Right.
17:41:06 <emu> they're not really "regular" though. it's a mis-classification
17:41:10 <Pseudonym> I've already read Thompson's PhD thesis.
17:41:14 <Pseudonym> If that helps.
17:41:34 <Pseudonym> It's a very good read, BTW.
17:41:44 <olsner> the article seems to add as a hindsight that "simple and fast" does not *actually* include all of what it's supposed to replace
17:41:51 * Pseudonym nods
17:41:57 <Pseudonym> Now mind you...
17:42:13 <Pseudonym> It's possible to analyse the PCRE to see if it could be implemented with a NFA.
17:42:23 <sorear> Still, 95% of regexps in the wild don't have backrefs.
17:42:27 <Pseudonym> Right.
17:42:30 <ddarius> Still it's not unreasonable to do 'if backreferenceless regex then thompsonNFA regex else backtracking regex
17:42:35 * Pseudonym nods
17:42:45 <Pseudonym> Actually, I'm not sure about the 95% figure.
17:42:49 <Pseudonym> Now that I think about it.
17:43:03 <Pseudonym> I reckon the majority of PCREs at least do field extraction.
17:43:12 <sorear> I pulled it out of my hat based on personal experience.
17:43:26 <sorear> field extraction /= backreferences
17:43:31 <sorear> eg, see tdfa
17:43:46 <olsner> I do find it a bit strange that PCRE has/hadn't already implemented that simple check and optimization
17:44:38 <Pseudonym> The Hopkins NFA construction algorithm might be easier to plug in, actually.
17:44:59 <kc5tja> And with that, cutgen 2.6 is _finished._
17:45:08 <olsner> I always figured perl-land to be optimizing people, esp wrt something as widely used as regexps
17:45:23 <sorear> kc5tja: don't you need to optimize it first?
17:45:25 <ddarius> "that" being the successful completion of a test suite?
17:45:31 <kc5tja> sorear: It's already optimized enough.
17:45:38 <Pseudonym> Perl also optimises its regexes for space/cache usage.
17:45:43 <kc5tja> sorear: It bores through the 7MB test C file in 4.5 seconds on my box.  I'm happy.
17:45:45 <Pseudonym> Which is the enemy of optimising for time.
17:45:56 <sorear> kc5tja: how fast was cutgen 2.4?
17:45:57 <ddarius> Pseudonym: Not always.
17:46:20 <kc5tja> sorear: WAY faster, since it's written in C.  But, if you have piles of 7MB source files lying around, you deserve what you get.
17:46:31 <Pseudonym> I am curious about it now, though.
17:46:38 <SamB> stepcut: do you want GHCi?
17:46:52 <Pseudonym> How easy it would be to implement regexes that also use NFAs where it can.
17:47:31 <emu> regexes allowing a complement operator won't be terribly efficient, but regular
17:47:36 <ddarius> Pseudonym: What do you mean by "where it can" and/or what do you mean by "regexes"?
17:47:54 <Pseudonym> I mean PCREs or POSIX regexes.
17:48:11 <olsner> "irregexps" :P
17:48:28 <sproingie> most regex engines are NFA's to start with
17:48:36 <Pseudonym> And by "where it can", I don't mean "use NFAs if the regex as a whole doesn't do anything funny, otherwise fall back".
17:48:41 <ddarius> I was wondering if you could add backtracking in a controlled form to Thompson.
17:48:50 <Pseudonym> I mean using NFAs for the bits that you can use it for.
17:49:15 <Pseudonym> I suspect that the Hopkins algorithm will work a bit better than the Thompson one.
17:49:30 <pchiusano> I have a question about Parsec... the import statements in the docs are not right, but I'm not sure what they should be
17:49:35 <Pseudonym> I have a suspicion that "real" regexes often have duplicate subexpressions.
17:49:45 <Pseudonym> So building the automaton by hash consing would have some benefit.
17:49:48 <pchiusano> for instance, what should 'import ParsecLanguage( haskellStyle )' become ?
17:50:02 <sorear> pchiusano: s/Parsec/Text.ParserCombinators.Parsec./
17:50:32 <Pseudonym> Oh, and the paper skips over something important with DFAs.
17:50:43 <pchiusano> huh?
17:50:53 <Pseudonym> Minimal DFAs can be exponential in the size of the regular expression.
17:51:25 <Pseudonym> You don't want that to be under the control of the client.
17:51:49 <sorear> The Linux posix-re lib uses DFAs.
17:52:08 <pchiusano> sorear, did you mean to type something else?
17:52:12 <emu> conversion of NFA to DFA can be exponential in the worst case, but the average case no
17:52:17 <sorear> If you pass a pathological RE to lambdabot on Linux, it will consume all memory!
17:52:24 <Pseudonym> Woo.
17:52:27 <pchiusano> for my Parsec question
17:52:31 <sorear> pchiusano: No, I meant what I said.
17:52:39 <Pseudonym> I know it's not exponential in the average case.
17:52:50 <sproingie> i suspect there's a size limit baked in
17:52:51 <Pseudonym> However, the point remains.  This is a potential DoS which can be alleviated by simply using NFAs.
17:53:00 <pchiusano> so just type that in place of the import statement?
17:53:01 * emu just reimplemented his dumb exponential nfaToDFA routine which couldn't handle NFAs larger than 10 =)
17:53:14 <sorear> pchiusano: yes.
17:53:19 <emu> couldn't an NFA take exponential time to run?
17:53:23 <sorear> no!
17:53:24 <Pseudonym> No.
17:53:30 <ddarius> Pseudonym: Which paper?
17:53:32 <Pseudonym> It's the number of states that's exponential.
17:53:38 <emu> sure
17:53:39 <sorear> pchiusano: for instance, import Text.ParserCombinators.Parsec.Language( haskellStyle )
17:53:40 <Pseudonym> ddarius: Sorry?
17:53:50 <pchiusano> sorear: that is not even valid Haskell syntax...
17:53:56 <ddarius> [19:47] <Pseudonym> Oh, and the paper skips over something important with DFAs.
17:53:58 <sproingie> (x.*)+
17:54:01 <Pseudonym> http://swtch.com/~rsc/regexp/regexp1.html
17:54:02 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
17:54:09 <Pseudonym> It's not really a paper.
17:54:16 <sorear> pchiusano: uh? it wasn't supposed to be HaskellSyntax.
17:54:22 <sorear> pchiusano: it was HaskellSyntax -> HaskellSyntax
17:54:32 <sorear> pchiusano: specced in the IRC standard, sed syntax
17:54:36 <ddarius> Are you just stating that?  It's primarily about NFAs (and talks about a more DFA specific sequel).
17:55:16 <sorear> pchiusano: "s/Parsec/Text.ParserCombinators.Parsec./" means "substitute Text.ParserCombinators.Parsec. for the first occurence of Parsec"
17:55:18 <sorear> man sed
17:55:38 <pchiusano> I see
17:55:51 <Pseudonym> I'm saying that the small DFA section skips over that rather important limitation.
17:56:14 <pchiusano> okay, ya, obviously I did not pick up on that :)
17:56:20 <ddarius> Pseudonym: Okay.  I noticed that too, but forgave it.  It presumably will be discussed in the sequel.
17:56:32 <Pseudonym> Sure.
17:58:48 <emu> i see
18:00:31 <emu> i have some more work to do in my NFA implementation =)
18:00:43 <chessguy_away> err, http://swtch.com/~rsc/regexp/regexp1.html hardly seems fair, comparing the 2 approaches based on a single regex-match
18:00:44 <emu> but my List monad implementation was so neato
18:00:45 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
18:01:15 <chessguy_away> (not to mention using actual time instead of asymptotic time)
18:01:32 <emu> it's very fair
18:01:42 <emu> we're talking about exponential vs linear here
18:01:57 <chessguy_away> we're talking about a single case
18:02:00 <chessguy_away> as far as i can tell
18:02:08 <chessguy_away> i'm not saying its conclusion is wrong. i have no idea
18:02:13 <emu> he talks about the way the implementations are
18:02:50 <chessguy_away> well, i haven't read the whole thing, just the intro
18:03:06 <ddarius> Some might argue that this test is unfair to the backtracking implementations, since it focuses on an uncommon corner case. This argument misses the point: given a choice between an implementation with a predictable, consistent, fast running time on all inputs or one that usually runs quickly but can take years of CPU time (or more) on some inputs, the decision should be easy.
18:03:56 <ddarius> (unquote, in case that's not obvious)
18:04:21 <cedricshock> I can never remember how to do this monad io: main = do
18:04:21 <cedricshock>    a <- 7
18:04:21 <cedricshock>    b <- left_inverse a
18:04:21 <cedricshock>    putStr (show b)
18:04:53 <cedricshock> I think I remember the word "in" ...
18:04:53 <ddarius> cedricshock: Are you comfortable with Haskell's type system?
18:05:16 <monochrom> May I ask for the type signature of left_inverse?
18:05:22 <cedricshock> ddarius: Getting there. b is a mess. a is IO (Int)
18:05:22 <emu> let a = 7?
18:05:34 <cedricshock> monochrom: Int -> Int
18:05:42 <emu> 7 is Int, not m Int, so you don't need to remove it from the box
18:05:45 <monochrom> putStr (show (left_inverse 7))
18:05:49 <chessguy_away> well, i suppose i should reserve any more judgment until i've read the rest of the article (which looks fascinating)
18:05:51 <dmwit> Probably "let b = left_inverse a in ..."
18:06:06 <ddarius> Or 'print (left_inverse 7)'
18:06:20 <chessguy_away> @quote melt
18:06:20 <emu> cedricshock: only use <- when faced with a value wrapped in a monad
18:06:21 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
18:06:47 <dmwit> ?quote Monad
18:06:48 <lambdabot> syntaxfree says: monad tutorials are the "Hello world" of our community.
18:07:14 <monochrom> Yeah, make sure the thing on the right of <- has the IO type (or in general a monadic type but I suppose don't worry about that yet)
18:07:34 <monochrom> a <- readLn    -- this is good
18:07:36 <liquidengineer> @paste
18:07:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:07:44 <monochrom> a <- sin x   -- this is bad
18:08:39 <monochrom> a <- 0.1   -- if you ever do this, you should be sent back to the haskell boot camp :)
18:08:52 <hpaste>  LiquidEngineer pasted "Foldr error." at http://hpaste.org/1652
18:09:03 <ddarius> I could make a <- 0.1 work...
18:09:07 <liquidengineer> This one has me feeling really dumb
18:09:10 <monochrom> PLEASE DON'T!
18:09:30 <dmwit> :t (.)
18:09:31 <cedricshock> monochrom: Yeah, I'm definitely not out of boot camp yet.
18:09:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:09:42 <ddarius> liquidengineer: the base case of the foldr needs to be a function
18:09:47 <liquidengineer> ?
18:10:00 <ddarius> b = Int -> Int
18:10:10 <emu> :t (.)
18:10:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:10:18 <monochrom> perhaps use id for the base case.
18:10:25 <liquidengineer> Hmm
18:10:26 <liquidengineer> okay
18:10:29 <liquidengineer> so (id input)
18:10:30 <liquidengineer> ?
18:10:30 <emu> the 2nd argument of foldr should match the type (a->b)
18:10:33 <dmwit> Then you probably want "answer input" as your return value.
18:10:40 <dmwit> liquidengineer: No, just id.
18:10:41 <emu> (id input) is still of type Int
18:10:52 <liquidengineer> what's id do?
18:10:58 <dmwit> > id 3
18:10:59 <lambdabot>  3
18:11:03 <liquidengineer> ah
18:11:15 <dmwit> id . f = f . id = f
18:11:23 <dino-> liquidengineer: Identity function.
18:11:36 <DukeDave> > id id
18:11:37 <lambdabot>  Add a type signature
18:11:42 <emu> > const 3
18:11:43 <lambdabot>  Add a type signature
18:11:49 <emu> > const 3 1
18:11:50 <lambdabot>  3
18:12:00 <DukeDave> > id id : Int -> Int
18:12:01 <lambdabot>  Parse error
18:12:06 <DukeDave> > id id :: Int -> Int
18:12:07 <lambdabot>  <Int -> Int>
18:12:16 <dmwit> > id id id id id id "whee!"
18:12:18 <lambdabot>  "whee!"
18:12:25 <emu> > (+1) `id` 2
18:12:27 <lambdabot>  3
18:12:39 <DukeDave> Heh, I was about to get replicate out :)
18:12:58 <liquidengineer> Wait
18:13:00 <liquidengineer> so...
18:13:01 <liquidengineer> answer = foldr (.) id program
18:13:24 <dmwit> answer = foldr (.) id program :: Int -> Int
18:13:30 <dmwit> answer = foldr (.) id program input :: Int
18:13:30 <emu> :t foldr (.) id
18:13:33 <lambdabot> forall a. [a -> a] -> a -> a
18:14:16 <liquidengineer> :t id
18:14:18 <lambdabot> forall a. a -> a
18:14:21 <liquidengineer> ah
18:14:23 <emu> :t fix
18:14:25 <lambdabot> forall a. (a -> a) -> a
18:14:29 <ddarius> @free id
18:14:31 <cedricshock> can I write a class both ways around. As in both "class (A t, B t) => C t" (t must be an A and a B to be a C) and "instance (A t, B t) => C t" (everything that's an A and a B is a C)?
18:14:31 <lambdabot> f . id = id . f
18:14:47 <liquidengineer> So this does it?
18:14:48 <liquidengineer> answer = foldr (.) id program input :: Int
18:15:11 <ddarius> Ask the compiler.
18:15:23 <emu> cedricshock: hm? i think you need incoherant instances for that
18:15:44 <ddarius> @free fix
18:15:47 <lambdabot> f . g = h . f => f (fix g) = fix h
18:16:41 <cedricshock> ddarius, emu: The compiler says I can.
18:18:23 <emu> ghc, the little compiler that could
18:18:35 <emu> maybe not so little
18:20:51 <cedricshock> Ok, If I say "let a = 7", how can I tell the compiler that a's an int? (It knows a needs to be an Inverse t, 7 is a Num t, and I have Instance Inverse Int - using num instead for my instance would solve this, but I like to learn...)
18:21:17 <dmwit> let a = 7 :: Int
18:22:45 <emu> hmm? it should figure that out
18:24:12 <cedricshock> emu: It could since I have only one instance of both, but I could easily have made more... I'm not really faulting it.
18:24:24 <emu> ok
18:24:53 <emu> :: has very low precedence so it will basically apply to any whole expression on the LHS
18:25:15 <cedricshock> It seems that having instance loops is not approved of.
18:25:31 <emu> mutual inheritance?
18:25:36 <emu> er
18:25:47 <emu> something
18:26:26 <emu> clearly, we need a lazily checked type system
18:27:31 <kc5tja> cedricshock: You can code iteratively in Haskell if you wish, but it won't look like you are.  I often have functions like "where foo a b = if (P a) then b else foo a (F b)" where P and F are some arbitrary functions.
18:28:01 <cedricshock> emu: Like this: I have something with an Identity and Invertible. That lets me deduce how to divide them. Now it's identity, invertible, divisible, and having an identity and a way to divide lets it figure out how to find an inverse, and now I have two conflicting definitions for inverse.
18:28:33 <cedricshock> At least, that's what I think is happening.
18:28:40 <emu> a way to divide lets you figure out an inverse?
18:28:54 <kc5tja> cedricshock: Sorry; I apparently didn't read far back enough.  :)
18:28:54 <cedricshock> If you have an identity, yeah.
18:29:08 <dons> ?users
18:29:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 307 (91.4%), active: 48 (15.6%)
18:29:09 <emu> that doesn't work in modular integer arithmetic
18:29:17 <emu> unless you call egcd, division
18:30:38 <cedricshock> emu: Modular under addition? Subtraction is the "division" (from the point of view of a Quasigroup)
18:33:27 <hpaste>  cedricshock pasted "New approch to abstract algebra, with instance error" at http://hpaste.org/1653
18:34:01 <cedricshock> Anyone who's a class guru know how to resolve the above?
18:37:53 <Binkley> you've specified two versions of left_inverse and right_inverse for Int, and the compiler doesn't know which to use
18:39:18 <cedricshock> Binkley: Right on. But the second one is defined (and only possible to define) in terms of the first one.
18:40:53 <cedricshock> I see it like this. The "instance Inverse Int" should be chosen because it's not an inverse, and thus not divisible, and thus not an inverse by division and identity if it's not.
18:41:24 <Binkley> hmm
18:42:35 <Binkley> I can't see how you can express that in the type system
18:42:42 <Binkley> but you could always cheat and use -fallow-overlapping-instances :-)
18:42:43 <cedricshock> It's clear (to the programmer) via the graph of types alone that Inverse Int is the sensible definition (the other definition is infinitely recursive... hmm that could be a problem, will it try to make everythign with an identiy invertible and divisible?)
18:43:49 <cedricshock> allow overlapping instances works.
18:50:27 <liquidengineer> What's the easiest way to display a function of type (a->a)?
18:50:34 <cedricshock> Ok, this is just fun.
18:50:41 <cedricshock> liquiengineer: display?
18:50:47 <liquidengineer> can I just import Text.Show.Functions ?
18:51:05 <ddarius> liquidengineer: Sure.
18:51:13 <sorear> liquidengineer: \f -> show (map f [minBound .. maxBound])
18:51:25 <Cale>  instance Show (a -> b) where
18:51:25 <Cale>  	showsPrec _ _ = showString \"\<function\>\"
18:51:25 <liquidengineer> sorear: ?
18:51:39 <sorear> @type \f -> show (map f [minBound .. maxBound])
18:51:42 <lambdabot> forall a b. (Bounded a, Enum a, Show [b]) => (a -> b) -> String
18:51:54 <liquidengineer> What does that do?
18:52:08 <liquidengineer> I know what show does, but shouldn't running it on a map call just return a list?
18:52:11 <Cale> it shows the results of applying f to every element of the domain
18:52:25 <Cale> which completely determines f, if you can do it at all.
18:52:55 <ddarius> :t \f -> show $ map (id &&& f) [minBound .. maxBound]
18:52:58 <lambdabot> forall a c'. (Show [(a, c')], Bounded a, Enum a) => (a -> c') -> String
18:53:17 <Cale> :t \f -> show $ map (ap (,) f) [minBound .. maxBound]
18:53:19 <lambdabot> forall a a1. (Show [(a, a1)], Bounded a, Enum a) => (a -> a1) -> String
18:54:14 <ddarius> Cale: Were you reimplementing my suggestion or did we just have the same thought at the same time?
18:54:52 <Cale> sort of both
18:55:27 <Cale> I had the idea to do that (except with ap), then you did it with &&&, so then I took your code and modified it :)
18:55:53 <ddarius> They turn out to be exactly the same length.
18:56:33 <cedricshock> More haskell boot camp: class Monoid a .... double :: Monoid m -> Monoid m .... Class `Monoid' used as a type
18:56:43 <sioraiocht> StateT monad question:  I have a state that is a record type called Env, and the inner monad is going to be IO, is "type NullState a = StateT Env IO a" a correct type definition?
18:57:15 <sorear> cedricshock: should be ... Monoid m => ...
18:57:17 <Binkley> sioraiocht: looks right to me
18:57:17 <sorear> not ->
18:57:44 <sioraiocht> @paste
18:57:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:58:08 <hpaste>  sioraiocht pasted "(no title)" at http://hpaste.org/1654
18:58:34 <sioraiocht> Binkley: that hpaste shows an update function to the state that doesn't work, and I don't know what to do to fix it
18:58:35 <cedricshock> sorear: Same error after changing.
18:58:58 <ddarius> Somehow I don't think current = current env + 1 `mod` 3 does quite what you think it does.
18:59:09 <sioraiocht> ddarius: explain?
18:59:12 <ddarius> > 2 + 1 `mod` 3
18:59:13 <lambdabot>  3
18:59:37 <ddarius> > (2 + 1) `mod` 3
18:59:37 <sioraiocht> > (2+1) `mod` 3
18:59:38 <lambdabot>  0
18:59:39 <lambdabot>  0
18:59:42 <Binkley> sioraiocht: well, I see a few things that are odd
18:59:43 <sioraiocht> okay, fixed that ;)
18:59:51 <Binkley> first, you name "n" with the call to get, but don't use it
19:00:01 <Binkley> second, you're passing a function to put rather than an Env
19:00:18 <kpreid> @let test = "is let working again?"
19:00:20 <lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
19:00:26 <kpreid> oh well
19:01:01 <sioraiocht> Binkley: *shakes head* okay, now I see what I messed up...lemme tinker for sec
19:01:01 <kpreid> > (\f -> "(\\x -> case x of {" ++ concat (intersperse "; " $ map (\v -> show v ++ " -> " ++ show (f v)) [minBound..maxBound]) ++ "})") not
19:01:02 <lambdabot>  "(\\x -> case x of {False -> True; True -> False})"
19:02:06 <ddarius> kpreid: Too bad that that is useless to just about every function it is applicable to.
19:02:28 <cedricshock> sorear: Oh, I see. It should be "double :: Monoid m => m -> m"
19:02:51 <hpaste>  sioraiocht pasted "Take two" at http://hpaste.org/1655
19:03:06 <sioraiocht> okay, that one still gets mad
19:03:18 <ddarius> :t modify
19:03:21 <ddarius> :t put
19:03:21 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
19:03:22 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:03:28 <Binkley> sioraiocht: that code looks ok to me, can you paste the error, too?
19:03:57 <sioraiocht> No instance for (MonadState Env t)
19:03:57 <sioraiocht>       arising from use of `put'
19:04:21 <Binkley> try giving a type signature for nextQueue
19:04:25 <Binkley> you might get a better error message
19:04:30 <sioraiocht> hrm, StateT doesn't have a put, does it?
19:05:12 <jaap__> is there a version read that has type Read a => String -> Maybe a , instead of throwing an exception when it can't read?
19:05:39 <sorear> Not exactly.
19:05:43 <sorear> but you can use reads
19:05:52 <ddarius> listToMaybe . reads
19:05:55 <cedricshock> Wow. This is awesome. I made a function that requires an abeliangroup, and ran it on the list monoid. the error is that my lists aren't commutative!
19:06:07 <sorear> @type listToMaybe . map fst . reads
19:06:10 <lambdabot> forall a. (Read a) => String -> Maybe a
19:06:27 <sioraiocht> ddarius: how do you modify a state kept by stateT opposed to state
19:06:30 <jaap__> sorear: thanks. i figured there must be something like that, but i couldn't find it
19:06:33 <sorear> cedricshock: lists don't have an inverse, either
19:07:01 <ddarius> sioraiocht: The methods of MonadState should work for a StateT
19:07:22 <ddarius> cedricshock: Lists are the free monoids.
19:07:22 <cedricshock> sorear: Yeah, but the compiler doesn't need to find /every/ reason it won't work.
19:08:15 <sioraiocht> Binkley: A type signature fixed it ;)
19:08:33 <gravity> Is there a better way to make an event loop than to just have a recursive function?
19:08:45 <ddarius> mapM
19:08:47 <ddarius> _
19:08:57 <sorear> forever!
19:09:03 <Binkley> sioraiocht: cool :-)
19:09:40 <cedricshock> ddarius: I think I've designed my abstract algebra library such that the graph of class inheritance can be changed (expanded) radically without breaking the external interface, so more interesting or specific classes could be added easily.
19:09:51 <gravity> ddarius: Thanks
19:09:56 <hpaste>  sm pasted "overview.hs" at http://hpaste.org/1656
19:10:01 <ddarius> cedricshock: Okay...
19:10:02 * gravity goes off to figure out how to turn mapM_ in to an event loop
19:10:16 <ddarius> gravity: It depends on how the recursion would work.
19:10:23 <sm> anyone up for a little gentle refactoring ?
19:10:46 <SamB_XP_> @type fixM
19:10:49 <lambdabot> Not in scope: `fixM'
19:10:51 <SamB_XP_> hmm.
19:10:57 <sm> I'd like to make this clearer
19:11:21 <cedricshock> ddarius: I don't have free monoids specifically yet, that's all I meant.
19:11:30 <ddarius> @type mfix
19:11:32 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
19:11:38 <SamB_XP_> :T iterateM
19:11:48 <SamB_XP_> :t iterateM_
19:11:50 <lambdabot> Not in scope: `iterateM_'
19:11:53 <sorear> SamB_XP_: it's called forever
19:11:53 <SamB_XP_> aww.
19:12:09 <ddarius> cedricshock: My comment was merely that lists, being free monoids, are definitely not commutative or have inverses.
19:12:18 <SamB_XP_> sorear: I was looking for this one...
19:12:58 <SamB_XP_> iterateM_ f x = f x >>= iterateM_ f
19:13:03 <ddarius> gravity: How do you receive events?
19:13:29 <ddarius> :t \f x -> fix (f x >>=)
19:13:32 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
19:13:32 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
19:13:41 <ddarius> I see.
19:14:25 <kilimanjaro> How do I search for functions given a type signature?
19:14:38 <kilimanjaro> I know lambdabot has that feature but I can't recall it
19:14:41 <ddarius> @hoogle a -> b -> b
19:14:41 <lambdabot> Prelude.const :: a -> b -> a
19:14:42 <lambdabot> Prelude.seq :: a -> b -> b
19:14:42 <lambdabot> Control.Parallel.par :: a -> b -> b
19:14:56 <cedricshock> ddarius: And my comment originally was that I was happy that the compiler refused to do it without an assertion that lists were commutative.
19:15:29 <kilimanjaro> @hoogle (a,b) -> a -> Bool
19:15:30 <lambdabot> No matches, try a more general search
19:16:20 <sorear> kilimanjaro: what could that possibly be?
19:16:30 <LoganCapaldo> :t first . (==)
19:16:30 <olsner> http://farm1.static.flickr.com/191/480556169_6d731d2416_o.jpg
19:16:32 <kilimanjaro> @free \ x y -> fst x == y
19:16:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:16:33 <lambdabot> forall d a. (Eq a) => a -> (a, d) -> (Bool, d)
19:16:45 <kilimanjaro> LoganCapaldo, ahh thanks
19:17:01 <LoganCapaldo> :t fst . first . (==)
19:17:03 <kilimanjaro> I'm not used to composition (I blame Lisp)
19:17:04 <lambdabot>     Couldn't match expected type `(a, b)'
19:17:04 <lambdabot>            against inferred type `(a1, d) -> (Bool, d)'
19:17:15 <LoganCapaldo> :t . (first . (==))
19:17:18 <lambdabot> parse error on input `.'
19:17:28 <LoganCapaldo> :t fst . (first . (==))
19:17:31 <lambdabot>     Couldn't match expected type `(a, b)'
19:17:31 <lambdabot>            against inferred type `(a1, d) -> (Bool, d)'
19:17:33 <sioraiocht> @type liftIO
19:17:36 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
19:17:38 <LoganCapaldo> mmm
19:17:57 <sioraiocht> @where liftIO
19:17:58 <lambdabot> I know nothing about liftio.
19:18:03 <sioraiocht> @docs liftIO
19:18:03 <lambdabot> liftIO not available
19:18:11 <sioraiocht> anyone? what lib is that in?
19:18:14 <sorear> @index liftIO
19:18:15 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:18:23 <sioraiocht> neat
19:19:08 <ddarius> @hoogle liftIO
19:19:08 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
19:19:21 <ddarius> hoogle makes a better @index
19:19:35 <LoganCapaldo> :t (fst .) . (first . (==))
19:19:37 <lambdabot> forall d a. (Eq a) => a -> (a, d) -> Bool
19:19:43 <LoganCapaldo> huzzah
19:20:34 <narain> :t (==) . first
19:20:35 <ddarius> :t uncurry (\a _ b -> a == b)
19:20:38 <lambdabot> forall a b. (Eq a) => (a, b) -> a -> Bool
19:20:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Eq (a (b, d) (c, d)), Arrow a) => a b c -> a (b, d) (c, d) -> Bool
19:21:10 <ddarius> @pl \a _ b -> a == b
19:21:11 <lambdabot> const . (==)
19:21:23 <ddarius> :t uncurry (const . (==))
19:21:25 <lambdabot> forall b a. (Eq a) => (a, b) -> a -> Bool
19:21:42 <LoganCapaldo> ddarius: but where are the arrows? :)
19:23:26 <narain> instance Arrow Fortune.Outrageous where
19:24:07 <ddarius> @. pl djinn (a -> a -> Bool) -> (a,b) -> a -> Bool
19:24:07 <lambdabot> f = (`ap` snd) . (. fst) . (const .)
19:24:35 <LoganCapaldo> um
19:24:53 <LoganCapaldo> why / how come snd?
19:25:13 <ddarius> LoganCapaldo: It has to route eq too.
19:25:22 <narain> ?pl ((`ap` snd) . (. fst) . (const .)) (==)
19:25:22 <lambdabot> (==) . fst
19:25:44 <narain> ah. so we come full circle
19:25:54 <LoganCapaldo> ddarius: I don't follow but ok
19:26:16 <ddarius> narain: Surprisingly no one suggested that.
19:26:22 <narain> i did!
19:26:48 <narain> <narain> :t (==) . first <lambdabot> forall a b. (Eq a) => (a, b) -> a -> Bool
19:27:00 <ddarius> :t (==) . first
19:27:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Eq (a (b, d) (c, d)), Arrow a) => a b c -> a (b, d) (c, d) -> Bool
19:27:08 <ddarius> narain: You meant to.
19:27:11 <narain> oh
19:27:40 <narain> darn out-of-order responses, i thought i had cracked it
19:27:46 <LoganCapaldo> :t first id
19:27:49 <lambdabot> forall a d. (a, d) -> (a, d)
19:27:54 <LoganCapaldo> drat
19:27:57 <ddarius> That was a pretty sequence of djinn and pl work though.
19:28:14 <narain> it was indeed
19:28:30 <LoganCapaldo> what's the arrow thingy that drops the second bit?
19:28:45 <ddarius> :t arr fst
19:28:47 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) a
19:28:57 <LoganCapaldo> @arr
19:28:58 <lambdabot> Ahoy mateys
19:30:04 <LoganCapaldo> :t pure fst
19:30:07 <lambdabot>     Ambiguous occurrence `pure'
19:30:07 <lambdabot>     It could refer to either `pure', imported from Control.Arrow
19:31:05 <LoganCapaldo> :t Control.Arrow.pure fst
19:31:08 <lambdabot> forall a b (a1 :: * -> * -> *). (Arrow a1) => a1 (a, b) a
19:31:24 <gravity> ddarius: In this case it'll be a simple server receiving connections and events from clients
19:32:40 <ddarius> gravity: How does it receive the events, a Chan?
19:33:13 <gravity> ddarius: I don't know yet. I haven't gotten that far... I'm still really new at this
19:34:45 <ddarius> gravity: Essentially, you'd probably want a HOF of the form: hof handler state = do event <- getEvent; state' <- handler event state; hof handler state'
19:34:50 <cedricshock> How do the newtypes in Data.Monoid separate out addition and multiplication of numbers?
19:35:26 <hpaste>  Kobold pasted ""Programming in Haskell" monadic parser code/error" at http://hpaste.org/1657
19:35:33 <ddarius> cedricshock: Sum, Product
19:35:51 <ddarius> @hoogle Sum
19:35:52 <lambdabot> Prelude.sum :: Num a => [a] -> a
19:35:52 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
19:35:52 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
19:36:00 <ddarius> @src Sum
19:36:00 <lambdabot> Source not found. That's something I cannot allow to happen.
19:36:35 <Kobold> Yeah, so I'm having troubles with an exercise about writing a parser. It barfs on do notation. Can someone take a look at the paste and see where I'm going wrong?
19:36:41 <cedricshock> ddarius: Yeah. but they aren't monoids... I'm just going to need to read the Prelude.
19:38:01 <sioraiocht> why does liftIO . putChar work and not liftIO . getChar?
19:38:21 <narain> :t liftIO
19:38:23 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
19:38:43 <sioraiocht> see? that should work, imo
19:38:54 <narain> :t liftIO getChar
19:38:57 <lambdabot> forall (m :: * -> *). (MonadIO m) => m Char
19:39:31 <sioraiocht> hrm...
19:39:39 <gravity> ddarius: Sorry, I can't figure out what a HOF is...?
19:39:49 <ddarius> @vera HOF
19:39:50 <lambdabot> No match for "HOF".
19:40:00 <ddarius> @foldoc HOF
19:40:01 <lambdabot> No match for "HOF".
19:40:07 <ddarius> Higher Order Function
19:40:10 <gravity> Ah, I just found it. Higher Order Function?
19:40:14 <gravity> Ah, ok, thank you!
19:40:54 <ddarius> gravity: The gen_server things in Erlang are good examples.
19:41:05 <gravity> ddarius: Cool, I'll have a look. Thank you again!
19:41:12 <narain> ?docs monadio
19:41:13 <lambdabot> monadio not available
19:41:21 <sm> in ghc -prof output, what is the "no." column, before entries ?
19:41:51 <ddarius> @doc Control.Monad.Trans
19:41:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Trans.html
19:42:30 <narain> sioraiocht: out of curiosity, what does MonadIO do?
19:42:47 <olsner> > [(i,j) | i<- [1..3], j<-[1..3]]
19:42:49 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:43:01 <Kobold> sm: me?
19:44:01 <sioraiocht> narain not sure, I just know I can lift IO to be wrapped inside a monad that is an instance of monadIO
19:44:48 <ddarius> > join (liftM2 (,)) [1..3] -- disgusting
19:44:49 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:45:08 <sioraiocht> lol
19:45:42 <olsner> @src liftM2
19:45:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:46:25 <olsner> @src join
19:46:26 <lambdabot> join x =  x >>= id
19:46:59 <narain> sioraiocht, ok, maybe i should ask, what are you using MonadIO for?
19:49:17 <sioraiocht> narain to Wrap IO in a StateT monad
19:50:18 <narain> ah ok, thanks
19:50:31 <olsner> > (concatMap (liftM2 (,)) id) [1..3]
19:50:33 <lambdabot>  Couldn't match expected type `[b]'
19:50:53 <ddarius> I knew that that would throw you.
19:51:05 <olsner> > (concatMap id (liftM2 (,))) [1..3]
19:51:06 <lambdabot>  Couldn't match expected type `[[b]]'
19:52:07 <olsner> @src liftM2
19:52:08 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:52:15 <ddarius> olsner: Not that this is helpful, but for [], join = concat (= concatMap id = concat . map id = concat)
19:52:18 <liquidengineer> @paste
19:52:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:53:20 <hpaste>  LiquidEngineer pasted "Strange error on constant declaration" at http://hpaste.org/1658
19:53:41 <ddarius> liquidengineer: type
19:53:43 <ddarius> liquidengineer: typo
19:53:48 <liquidengineer> ?
19:54:01 <monochrom> ible, able
19:54:10 <liquidengineer> ah
19:54:12 <liquidengineer> crap
19:54:15 <liquidengineer> I'm too tired for this. :P
19:54:17 <liquidengineer> Thanks
19:54:17 <monochrom> haha
19:54:29 <liquidengineer> how do you spell available?
19:54:35 <ddarius> Like that.
19:54:36 <narain> yes, that way
19:54:37 <monochrom> that is correct.
19:54:39 <ddarius> @spell available
19:54:47 <liquidengineer> ...
19:54:49 <olsner> list monads be damned
19:55:04 <olsner> haskellgolf :(
19:55:21 <monochrom> now is a good time to mess with your mind.  plural for virus is viruses? virii?  how about radius?  ...
19:55:22 <narain> olsner: if it helps, in ddarius's original example, the join was on the function (liftM2 (,))
19:55:27 <ddarius> olsner: The trick is that there are -two- monad instances involved there.
19:55:42 <ddarius> viruses, radii
19:55:49 <Binkley> I saw a comment in some code I was working on with "statii" as the plural for status
19:55:51 <Binkley> that made me cry a little
19:55:59 <narain> > join (*) 5
19:56:00 <lambdabot>  25
19:56:12 <monochrom> yeah, should be stati
19:56:30 <monochrom> and viri :)
19:56:37 <narain> do multiple magicians say hoci poci?
19:56:55 <olsner> hmm... so join f x = f x x?
19:57:10 <ddarius> @src (->) join
19:57:10 <monochrom> multiple canadians certainly say hockey pockey
19:57:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:57:18 <ddarius> Damn, join not being a member of monad
19:57:21 <sioraiocht> Binkley, ddarius, thanks for your help
19:57:24 <ddarius> @src (->) (>>=)
19:57:24 <lambdabot> f >>= k = \ r -> k (f r) r
19:57:35 <sioraiocht> have a good night everyone :)
19:57:56 <ddarius> so join = (>>= id) and for k = id, we get join f r = f r r
20:00:11 <sm> how do I test for the presence of a substring in a string ? without using Regex ?
20:00:29 <Gwern> would 'elem' work?
20:00:38 <sm> there it is! isInfixOf
20:00:43 <sm> I searched for that critter
20:01:02 <narain> ?index isInfixOf
20:01:03 <lambdabot> bzzt
20:01:05 <olsner> mmkay, so the end result is that (liftM2 (,)) is run on two copies of the list/"monad" [1..3]?
20:01:06 <ddarius> :t \substring -> any (substring `isPrefixOf`) . tails
20:01:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
20:01:23 <narain> olsner: yes
20:01:47 <narain> it's exactly the same as liftM2 (,) [1..3] [1..3]
20:01:51 <ddarius> But, I think there is a predefined function better that that.
20:02:10 <narain> substring matching should be O(n), and that one probably isn't
20:03:41 <narain> i mean O(m+n). that one is O(mn)
20:04:26 <reitblatt> just bust out some good ole Boyer-Moore =p
20:05:22 <narain> i see your boyer-moore and raise you knuth-morris-pratt
20:05:22 <narain> ?src isInfixOf
20:05:22 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
20:05:22 <narain> boo
20:05:22 <ddarius> hah
20:05:34 <ddarius> @oldwiki RuntimeCompilation
20:05:34 <lambdabot> http://www.haskell.org/hawiki/RuntimeCompilation
20:06:10 <ddarius> @oldwiki RunTimeCompilation
20:06:10 <lambdabot> http://www.haskell.org/hawiki/RunTimeCompilation
20:06:20 <reitblatt> BoyerMoore > KMP
20:06:40 <reitblatt> and in runtime BM < KMP =p
20:07:09 <ddarius> > "BoyerMoore" < "KMP"
20:07:10 <lambdabot>  True
20:07:13 <dibblego> was it Church who wrote the definition for adding two numbers by adding 1 to x and subtracting 1 from y? (using lambda calculus?) (excuse my vague recollection)
20:07:24 <narain> ddarius: haha
20:07:56 <reitblatt> > "reitblatt" > "lambdabot"
20:07:58 <lambdabot>  True
20:08:28 <sioraiocht|sleep> > "sioraiocht" > "lambdabot"
20:08:30 <lambdabot>  True
20:08:32 <sioraiocht|sleep> hurrah!
20:08:45 <dons> hehe
20:08:47 <sioraiocht|sleep> @src (>>=) []
20:08:47 <lambdabot> Source not found. Where did you learn to type?
20:08:58 <sioraiocht|sleep> @src (>>=)
20:08:58 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:09:18 <narain> reitblatt: boyer-moore :: O(mn), knuth-morris-pratt :: O(m+n)
20:09:23 <sioraiocht|sleep> > @src [] (>>=)
20:09:24 <lambdabot>  Parse error
20:09:31 <sioraiocht|sleep> @src [] (>>=)
20:09:32 <lambdabot> m >>= k     = foldr ((++) . k) [] m
20:09:34 <reitblatt> worst case, yeah
20:09:34 <sioraiocht|sleep> ha, i have you now
20:09:53 <cedricshock> ddarius: I figured it out. It wraps Num up in a trivial little type, and then getSum pulls the Num back out of the Sum.
20:10:14 <narain> well, yes, worst case. that's all i was taught in algorithms class :)
20:10:17 <ddarius> @oldwiki WrapperType
20:10:17 <lambdabot> http://www.haskell.org/hawiki/WrapperType
20:10:26 <reitblatt> take a better algorithms class =p
20:10:32 <reitblatt> avg case is more interesting
20:11:19 <reitblatt> which is why stuff like knap-sack crypto doesn't work
20:13:51 * narain searches google for knap-sack crypto and finds a long article typeset entirely in courier
20:13:58 <dibblego> Church Encoding!
20:14:35 <LoganCapaldo> So what is knuth-morris-pratt = convert the first string into a FSM?
20:14:58 <reitblatt> keep track of the overlay of prefixes and suffixes
20:15:27 <LoganCapaldo> ah hmm
20:16:03 <sm> I think there's a standard function to get all but the last of a list ?
20:16:16 <dons> > init "haskell"
20:16:18 <lambdabot>  "haskel"
20:16:27 <LoganCapaldo> :t last . inits
20:16:30 <lambdabot> forall a. [a] -> [a]
20:16:34 <LoganCapaldo> I'm silly
20:16:43 <LoganCapaldo> last . inits $ "haskell"
20:16:45 <ddarius> butlast in CL
20:16:58 <LoganCapaldo> > last . inits $ "haskell"
20:17:00 <lambdabot>  "haskell"
20:17:06 <LoganCapaldo> ooof
20:17:14 <ddarius> > inits "haskell"
20:17:15 <lambdabot>  ["","h","ha","has","hask","haske","haskel","haskell"]
20:17:42 <LoganCapaldo> I'm both silly and not getting the right answer
20:17:43 <sm> ah, thanks
20:18:08 <narain> > map last . tail . inits $ "haskell"
20:18:11 <lambdabot>  "haskell"
20:18:18 <narain> ?pl map last . tail . inits
20:18:19 <lambdabot> map last . tail . inits
20:18:27 <narain> aww, i wanted id
20:18:50 <chessguy> @pl \s -> take 1 . drop $ length s - 1
20:18:51 <lambdabot> take 1 . drop . subtract 1 . length
20:19:05 <LoganCapaldo> narain: aim higher, you should hope for the empty string :)
20:19:22 <chessguy> > take 1 . drop . subtract 2 . length $ "haskell"
20:19:23 <lambdabot>  Couldn't match expected type `[a]'
20:19:28 <ddarius> pl is a compiler not a simplifier
20:19:57 <LoganCapaldo> so clearly what we need is an optimizing pl <g>
20:20:03 <narain> LoganCapaldo: what type is the empty string, anyway?
20:20:20 <dibblego> ?type ""
20:20:22 <lambdabot> [Char]
20:20:30 <ddarius> @free map last . tail . inits
20:20:30 <lambdabot> Extra stuff at end of line
20:20:48 <LoganCapaldo> I <3 that error message
20:21:15 <chessguy> @pl \s -> take 1 . (drop (length s - 2)) s
20:21:15 <narain> then clearly "" /= id
20:21:16 <lambdabot> (take 1 .) . (drop =<< subtract 2 . length)
20:21:49 <chessguy> > (take 1 .) . (drop =<< subtract 2 . length) "haskell
20:21:50 <lambdabot>  Improperly terminated string
20:21:51 <chessguy> > (take 1 .) . (drop =<< subtract 2 . length) "haskell"
20:21:53 <lambdabot>  Couldn't match expected type `a -> a2 -> [a1]'
20:22:00 <LoganCapaldo> narain: I mean more like eval ""
20:22:16 <LoganCapaldo> not an empty string literal consisting of the string ""
20:22:29 <chessguy> @type \s -> take 1 . (drop (length s - 2)) s
20:22:32 <lambdabot>     Couldn't match expected type `a -> [a1]'
20:22:32 <lambdabot>            against inferred type `[a2]'
20:22:56 <chessguy> @type \s -> take 1 . (drop ((length s) - 2)) s
20:22:59 <lambdabot>     Couldn't match expected type `a -> [a1]'
20:22:59 <lambdabot>            against inferred type `[a2]'
20:23:01 <narain> LoganCapaldo: i'm just taking your quip and running with it
20:23:14 <LoganCapaldo> well bring it back when you're done :)
20:23:24 <narain> roger wilco!
20:23:33 <narain> map id list /= map list
20:23:39 <chessguy> @type \s -> (drop ((length s) - 2))
20:23:41 <lambdabot> forall a a1. [a] -> [a1] -> [a1]
20:24:16 <chessguy> wtf
20:24:38 <chessguy> @type \s -> (drop ((length s) - 2)) s
20:24:41 <lambdabot> forall a. [a] -> [a]
20:24:59 <chessguy> @type \s -> take 1 $ (drop ((length s) - 2)) s
20:25:02 <lambdabot> forall a. [a] -> [a]
20:25:14 <chessguy> @type \s -> head $ (drop ((length s) - 2)) s
20:25:17 <lambdabot> forall a. [a] -> a
20:25:28 <chessguy> @pl \s -> head $ (drop ((length s) - 2)) s
20:25:29 <lambdabot> head . (drop =<< subtract 2 . length)
20:25:45 <LoganCapaldo> mmmm monad
20:25:52 <chessguy> > head . (drop =<< subtract 2 . length) "haskell"
20:25:53 <lambdabot>  Couldn't match expected type `a -> [a1]'
20:26:18 <chessguy> > (head . (drop =<< subtract 2 . length)) "haskell"
20:26:19 <lambdabot>  'l'
20:26:37 <LoganCapaldo> > last "haskell"
20:26:38 <lambdabot>  'l'
20:26:42 <LoganCapaldo> heh
20:26:44 <LoganCapaldo> I cheat
20:26:52 <dibblego> > 'l'
20:26:53 <LoganCapaldo> because it has 2 ls
20:26:54 <lambdabot>  'l'
20:26:54 <chessguy> > (head . (drop =<< subtract 2 . length)) "foobar"
20:26:56 <lambdabot>  'a'
20:27:06 <chessguy> try cheating for that one, LoganCapaldo
20:27:12 <dibblego> > 'a'
20:27:14 <lambdabot>  'a'
20:27:18 <dibblego> ftw!
20:27:22 <chessguy> @slap dibblego
20:27:23 * lambdabot beats up dibblego
20:27:26 <LoganCapaldo> dibblego is a vastly superior cheater
20:27:34 <LoganCapaldo> > const 'a' "foobar"
20:27:36 <lambdabot>  'a'
20:28:24 <LoganCapaldo> @pl \s -> s !! (length s - 2)
20:28:25 <lambdabot> ap (!!) (subtract 2 . length)
20:28:33 <dibblego> > head . tail . reverse $ "foobar"
20:28:35 <lambdabot>  'a'
20:29:07 <LoganCapaldo> > ap (!!) (subtract 2 . length) "foobar"
20:29:08 <lambdabot>  'a'
20:29:43 <narain> :t ap -- i keep forgetting
20:29:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:30:04 <dibblego> narain, map without the 'm'!
20:30:22 <narain> no way, i see lots of m's in there
20:30:42 <dibblego> that's where it got to after it left map
20:31:07 <dibblego> :t ap -- where is m?
20:31:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:31:13 <dibblego> -- oh there it is!
20:31:30 <LoganCapaldo> @pl ap ---> drop m map
20:31:31 <lambdabot> ap
20:31:49 <narain> ?pl drop m map
20:31:50 <lambdabot> drop m map
20:32:08 <narain> :t drop ?m map
20:32:11 <lambdabot>     Couldn't match expected type `[a]'
20:32:11 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
20:32:26 <LoganCapaldo> @free drop n . map f
20:32:27 <lambdabot> Extra stuff at end of line
20:32:38 <narain> ?help free
20:32:39 <lambdabot> free <ident>. Generate theorems for free
20:32:45 <narain> ?free dro[
20:32:46 <lambdabot> Extra stuff at end of line
20:32:47 <narain> ?free drop
20:32:49 <lambdabot> $map f . drop x = drop x . $map f
20:33:03 <LoganCapaldo> eh thats pretty much what I wanted
20:33:13 <narain> what's the $ for?
20:33:24 <LoganCapaldo> Money?
20:33:26 <ddarius> @type fix (:[])
20:33:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
20:33:28 <lambdabot>       Expected type: a
20:33:35 <narain> moneymap?
20:33:46 <LoganCapaldo> @type fix (++[])
20:33:49 <lambdabot> forall a. [a]
20:33:53 <narain> or has lambdabot started asking for tips?
20:34:05 <LoganCapaldo> > fix (++[])
20:34:07 <lambdabot>  Exception: <<loop>>
20:34:13 <LoganCapaldo> its funny
20:34:28 <LoganCapaldo> I knew it wouldn't terminate, but I almost expected it to
20:34:37 <sorear> .
20:34:54 <LoganCapaldo> @botsnack
20:34:55 <lambdabot> :)
20:35:05 <LoganCapaldo> theres lambdabot's tip right there
20:35:11 <sproingie> @botcrack
20:35:12 <lambdabot> :)
20:35:18 <sproingie> YES
20:35:28 <narain> ?botattack
20:35:29 <lambdabot> Unknown command, try @list
20:35:35 <LoganCapaldo> @botsmack
20:35:36 <lambdabot> :)
20:35:42 <LoganCapaldo> hehehe
20:35:49 <kpreid> narain: the intent is to mean "this is the Prelude map, not an identifier in the provided code"
20:35:51 <LoganCapaldo> it is to LOL
20:36:02 <narain> kpread: thanks!
20:36:07 <narain> kpreid, even
20:36:27 <LoganCapaldo> It's a new song, smack my bt up
20:36:30 <LoganCapaldo> *bot
20:36:45 <LoganCapaldo> that or give her heroin
20:36:58 <narain> ?smack lambdabot
20:36:59 <lambdabot> Unknown command, try @list
20:37:25 <LoganCapaldo> @slap lambdabot
20:37:25 * lambdabot slaps lambdabot
20:37:41 <LoganCapaldo> so violent
20:37:48 <LoganCapaldo> and self-destructive
20:39:26 <sm> does ghc's -prof option have noticeable cost ? can I leave it on all the time
20:39:32 <sm> ?
20:39:50 <sorear> sm: compared to -O0 I'm sure it's neglible
20:39:56 <sorear> -O0 *kills* performance
20:40:23 <LoganCapaldo> Everytime you pass -O0 GHC kills a performance
20:40:35 <sm> I'm passing no -O, is that -O0 ?
20:40:40 <sorear> right.
20:41:04 * sm swiftly tries -O2
20:41:06 <sorear> also, is your code actually perf-critical?
20:41:10 <LoganCapaldo> sm: Your hands are dripping with the blood of dead performances
20:41:23 <sm> yes it really is..
20:41:51 <sm> I'm porting the c++ ledger program, and mine is currently too slow to use
20:42:00 <sorear> 'ledger'?
20:42:09 <sm>  http://newartisans.com/ledger.html
20:42:10 <lambdabot> Title: New Artisans LLC
20:42:22 <sm> a very useful prog
20:43:08 <sm> allows you to query and examine your money (or time) transactions
20:43:36 <sm> woo.. ghc is certainly thinking harder
20:44:41 <LoganCapaldo> Don't anthromophize ghc. It hates that.
20:48:11 <sm> holy mackerel
20:48:17 <sorear> ?
20:48:28 <sm> my laptop is struggling
20:48:33 <sorear> wouldn't "holy haddock" be better?
20:48:44 <dons> sm, yeah -prof rouhgly halves performance
20:48:53 <sorear> dons: even with -O0?
20:49:03 <dons> who uses -O0?
20:49:03 <sm> I mean, to compile with -O2
20:49:12 <sorear> dons: sm
20:49:17 <sorear> dons: me
20:49:18 <sm> dons good to know, thx
20:49:22 <dons> yeah, -O2 makes ghc think really hard. but it is *required* if you care about performance
20:49:45 <monochrom> Are -O2 and -O1 very different?
20:49:52 <dons> -O2 is getting better now
20:49:59 <monochrom> Nice.
20:50:04 <LoganCapaldo> is there an -O3
20:50:13 <dons> things like stream fusion and heavy rules/heavy inlining/spec constr only kick in at -O2
20:50:18 <dons> no, there's no -O3
20:50:19 <chessguy> ?remember LoganCapaldo Don't anthromophize ghc. It hates that.
20:50:19 <lambdabot> Done.
20:50:35 * monochrom contemplates re-building GHC with -O2.  Nah, that will kill our planet.
20:51:01 <dons> it used to be that -O2 didn't do much, but its pretty good now (in ghc head, in particualr, since you get the spec constr optimisatoin)
20:51:05 <Adamant> but when will ghc go to -O11?
20:51:15 <dons> nah, that's for yhc.
20:51:32 <LoganCapaldo> yhc is gonna do WPO, right?
20:51:44 * LoganCapaldo laughs manaically
20:52:00 <monochrom> I am using lazy bytestring in 6.6.1.  Does -O2 buy me more than -O1?  Does -fvia-C buy me more than -fasm?
20:52:01 <jcreigh> ghc -O11 should error with "get a life, you gentoo nerd" :)
20:52:07 <hpaste>  sm annotated "hledger profile" with "(no title)" at http://hpaste.org/1659#a1
20:52:10 <monochrom> (Meanwhile I'll try.)
20:52:21 * kc5tja wonders how difficult it is to make a Haskell interpreter or compiler...  Probably insanely difficult.
20:52:33 <Adamant> jcreigh, I resemble that remark
20:52:37 <monochrom> @remember jcreigh ghc -O11 should error with "get a life, you gentoo nerd" :)
20:52:38 <lambdabot> Done.
20:52:56 <narain> ?quote ghc
20:52:57 <lambdabot> ghc says: Exotic pattern inside meta brackets
20:53:03 <sorear> i'd like to point out that -O3 is roughly equivalent to -O0
20:53:09 <dons> monochrom: -O2 -optc-O might buy you 5-10%
20:53:16 <dons> with bytestrings.
20:53:27 <sproingie> wasn't yhc a project to learn haskell by writing a haskell compiler?
20:53:27 <dons> i'd recommend -O2 with bytestrings
20:54:12 <olsner> -O2 and -O3 should be -O10 and -O11 ... just so that people would ask for -O[2-9]
20:54:13 <sorear> Anyone have a cayley table for Dih[4]?
20:54:32 <ddarius> kc5tja: The syntax is probably the hardest part of the simple Haskell 98 interpreter.
20:54:49 <ddarius> sproingie: jhc
20:54:51 <sorear> write a liskell interpreter :)
20:54:59 <sproingie> ahh right
20:55:36 <kc5tja> ddarius: Oh?  I would have thought it was the laziness aspect, the support for closures (which still blow my mind from an _implementation_, not usability, point of view), list comprehensions, and support for monads.
20:55:43 <sorear> btw, I've decided I really will make the Kestrel Interactive ML System.  Sounds very fun.
20:55:44 <gmh33> is haskell supposed to take a few hours to build through macports on a G4? ;)
20:55:58 <kc5tja> gmh33: It took about 8 hours to build on my 800MHz Athlon box.
20:55:58 <monochrom> Yes.
20:56:01 <sorear> kc5tja: I've implemented closures at least twice.  They aren't hard!
20:56:15 <dons> gmh33: ghc you mean?
20:56:16 <dfranke> what's the big deal about monads?  They have syntactic sugar and they're used for IO.  Other than that they're just a library.
20:56:20 <sorear> I have a half-finished lazy scheme.  The evaluator is all there.
20:56:26 <ddarius> list comprehensions are a trivial syntactic transformation to monad style which is a trivial syntactic transformation to normal functions.
20:56:27 <dons> dfranke: yeah, bizarre, isn't it?
20:56:31 <sorear> dfranke: there is no big deal
20:56:34 <ddarius> Laziness and closures are easy and standard.
20:56:43 <dons> i suppose people like having backtracking and continuations as libraries. that's cute.
20:56:55 <monochrom> The layout rules are by far the most difficult to implement.  Hell, you can't even expect too many people to know all of them.
20:56:57 <dons> and structuring programs with transformers is new and interesting.
20:56:58 <olsner> would be interresting to represent an entire C/C++ program as a monad on syscalls and writes to volatile globals
20:57:07 <sorear> I've actually implemented all of the pieces of a haskell compiler.
20:57:11 <sm> cool that hpaste highlights profiles
20:57:20 <ddarius> monochrom: Which means you don't have to implement it correctly.
20:57:20 <Adamant> closures? in C, they are just a function pointer to code and then a data structure for variables
20:57:22 <kc5tja> sorear: The only thing I can think of is to keep a list of variables used that aren't in the formal parameter list, and silently tack them onto the function's parameter list as _pointers_ into the associated calling frame.
20:57:36 <monochrom> haha ddarius that's an interesting way to look at it :)
20:57:44 <sorear> Unfortunately, each piece is written in a different language using subtly incompatible data structures.
20:57:45 <kc5tja> Adamant: Not quite.  But close.  :)
20:57:59 <sorear> seriously, nobody implements the layout rule correctly.
20:58:02 <sorear> *nobody*
20:58:13 <sorear> Philippa is working on it though
20:58:15 <Adamant> kc5tja, well, it's a struct that holds that. anyway, that is a way to impliment them for a language written in C.
20:58:38 <sorear> kc5tja: you described exactly how scheme does it.
20:58:43 <dfranke> on the other hand, Monad transformers are purely a library, yet they're managing to kick my ass at the moment :-)
20:58:49 <ddarius> @google from interpreter to compiler and virtual machine
20:58:50 <sm> oh, I should make clean before trying to rebuild this with O2
20:58:53 <lambdabot> http://www.brics.dk/RS/03/14/index.html
20:58:53 <lambdabot> Title: From Interpreter to Compiler and Virtual Machine: A Functional Derivation
20:59:00 <sproingie> i have a marvelous haskell compiler that is unfortunately too large to fit in this margin
20:59:00 <ddarius> @google "Definitional interpreters for higher order languages"
20:59:02 <sorear> kc5tja: in Haskell it's slightly simpler - because of immutability we can copy the values and forget about the old frame
20:59:03 <lambdabot> http://www.dina.kvl.dk/~sestoft/papers/plc-0.34-2up.pdf
20:59:05 <kc5tja> sorear: heh, interesting.
20:59:22 <sorear> kc5tja: that is how GHC does it
20:59:28 <sorear> actually all of them
20:59:45 <sorear> every haskell compiler in existance uses lambda lifting
20:59:48 <sm> I'll be back, thanks all
20:59:50 <gmh33> dons: yes
21:00:18 <sorear> although GHC does it very late, during codegen;  yhc/nhc do it even before the core stage
21:00:42 <kc5tja> sorear: So, if you'll pardon the conceptual leap, Haskell's closures use call-by-value (well, the value being a thunk of course), instead of call by reference then.
21:00:52 <EvilTerran> @where prime
21:00:52 <lambdabot> I know nothing about prime.
21:00:56 <EvilTerran> @where primes
21:00:56 <sorear> kc5tja: Right.
21:00:56 <lambdabot> I know nothing about primes.
21:01:10 <LoganCapaldo> we got the thunk, we got the thunk
21:01:15 <kc5tja> I was pondering that, but then, I'd be interested in maintaining some state too -- which raises the need for monads.
21:01:25 <monochrom> @quote thunk
21:01:25 <sorear> kc5tja: Scheme passes parameters by value and free variables by reference.
21:01:26 <lambdabot> sjanssen says: your mom has a thunk for a tail
21:01:26 <dfranke> in a purely functional language there's not really any difference between call-by-{value,name,reference}
21:01:27 <EvilTerran> is there a canonical primes sieve in haskell? a fast one?
21:01:28 <kc5tja> And that's something I still don't know how to implement.
21:01:36 <sorear> kc5tja: how's that for orthogonality! :)
21:01:49 <dons> EvilTerran: the one on the shootout?
21:01:54 <sorear> kc5tja: wait, why do you need state for a haskell interpreter?
21:01:55 <narain> for future reference, is there a readymade machine-readable haskell grammar, in case i ever want to write a haskell interpreter but am not interested in parsing the syntax?
21:02:01 <gmh33> oh well, I'll let this build over night then
21:02:01 <sorear> if you don't need speed
21:02:10 <sorear> narain: yes, it's in haskell-src
21:02:16 <dons> narain: yeah, there's several happy and other grammars floating around
21:02:18 <kc5tja> sorear: It's gotta remember stuff somehow.
21:02:20 <sorear> narain: but it doesn't do the whole job :(
21:02:26 <sorear> kc5tja: like what?
21:02:41 <kc5tja> sorear: Like the state you store in a State monad.  :)
21:02:46 <sorear> > nubBy(((>1).).gcd)[2..]   -- my favorite (uses trial division)
21:02:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:02:52 <sorear> kc5tja: that's just parameters
21:03:40 <EvilTerran> sorear, it's elegant, but is it efficient?
21:03:56 <kc5tja> EvilTerran: With tail recursion support, it's precisely equivalent to iteration.
21:04:07 <sorear> EvilTerran: Yes.
21:04:19 <narain> "The Haskell grammar in the report is not an LR grammar." yuck.
21:04:23 <sorear> EvilTerran: it makes *very* efficient use of finger cycles.
21:04:31 <EvilTerran> *wibble*
21:04:43 <sorear> narain: it isn't even contextfree!
21:04:47 <kc5tja> How is IO handled then?
21:04:58 <sorear> narain: nor is it self contained
21:05:01 <ray> how come there's no comonad tutorials?
21:05:03 <kc5tja> It would be totally "neat-o" if I could get low-level enough to touch raw hardware with Haskell.
21:05:04 <narain> sorear: eep
21:05:05 <ddarius> > drop 1000 $ nubBy(((>1).).gcd)[2..]
21:05:09 <lambdabot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,...
21:05:12 <dfranke> with infix[lr]? I don't think it's even context-sensitive.
21:05:26 <ddarius> ray: Because people don't use comonads.
21:05:27 <sorear> narain: the syntactic correctness of a file depends on the content of imported modules!
21:05:35 <sorear> ray == ray_?
21:05:39 <EvilTerran> sorear, great, thanks. very impressive.
21:05:47 <narain> i didn't know haskell had infix declarations
21:05:49 <ray> i don't think i have ray_
21:05:50 <sorear> EvilTerran: it will waste CPU though.
21:06:15 <ddarius> EvilTerran: nubBy alone is O(n^2)
21:06:23 <sorear> ray: ray_ identified as "Peter de Wachter"
21:06:41 <EvilTerran> being light on the cpu usage (well, running time) is what i meant by efficient, really...
21:06:42 <ray> well, i'm not peter, i'm ray
21:06:45 <ray> so i guess not
21:07:06 <narain> sorear: is the non-context-free-ness due to infix declarations?
21:07:08 <ray> (stealing this nick from ray johnston was quite the adventure)
21:07:32 <ray> maybe i can come up with a metaphor for comonads
21:07:40 <ddarius> @google higher order definitional interpreters
21:07:43 <lambdabot> http://portal.acm.org/citation.cfm?id=805852&dl=
21:07:44 <lambdabot> Title: Definitional interpreters for higher-order programming languages
21:07:45 <sorear> narain: yes
21:07:59 <kc5tja> ddarius: ??  That's the second time you posted that.  Is that intended for someone in particular?
21:08:17 <sorear> kc5tja: I'm pretty sure it was for you.
21:08:34 <sorear> kc5tja: that is THE classic paper on lfpl implementation
21:08:34 <ddarius> kc5tja: The first time I jacked it up a little.  But, it's vaguely intended for you, but it's rather diffuse.
21:08:47 <EvilTerran> intuitively, I'd've gone for
21:08:51 <EvilTerran> > fix $ \ps -> 2 : filter (\n -> all ((0/=).mod n) $ takeWhile ((n>=).(^2)) ps) [3..]
21:08:53 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:09:07 <EvilTerran> as seeming relatively efficient to me
21:09:15 <sorear> EvilTerran: read the mailing list
21:09:21 <ddarius> It's a good paper.  It's about (one way) of implementing higher-order languages in first order ones.
21:09:23 <narain> sorear: if that's all, i guess that's fine
21:09:34 <sorear> EvilTerran: there was a huge thread on efficient primesieves this year
21:09:41 <EvilTerran> okay
21:09:50 <reitblatt> ddarius: thanks for the link
21:09:57 <reitblatt> I didn't even know I was looking for it :)
21:10:05 <ddarius> It's also related to the other paper I referenced which shows (with a companion paper) how to go to and from interpreters and abstract/virtual machines (mostly) systematically.
21:10:10 <kc5tja> Unfortunately, I don't do ACM -- I have to pay to read the papers.  Bzzzt.  ACM and IEEE both are cliques in my opinion.
21:10:24 <ddarius> It's available elsewhere.
21:10:31 <narain> kc5tja: it may be on citeseer
21:10:35 <ddarius> I'll probably never have an ACM account.
21:10:55 <ddarius> Any paper/book/thesis I reference is available online unless otherwise specified.
21:11:14 <kc5tja> I was thinking that, but I'm reading some other things at the moment.  I'll search for it in a bit.
21:18:55 <kc5tja> narain: Nope.  But it is on the web in general.
21:21:42 <kc5tja> OK, so I have a question now.
21:22:43 <kc5tja> If I'm running code inside a monad transformer (say, StateT myType lowerType), and I want to invoke a function on the state of lowerType, why do I need to lift?  Why can I not just invoke the function?
21:22:47 <bos> is it about assembly language programmers?
21:22:51 <ddarius> "A Functional Correspondence between Evaluators and Abstract Machines" "A Functional Correspondence between Call-by-Need Evaluators
21:22:51 <ddarius> and Lazy Abstract Machines" "From Interpreter to Logic Engine by Defunctionalization" "A Functional Correspondence between Monadic Evaluators
21:22:51 <ddarius> and Abstract Machines for Languages with Computational Effects" http://www.brics.dk/~danvy/
21:22:53 <kc5tja> I ask this, because there is no visible "lifting" when, say, invoking main.
21:22:53 <lambdabot> Title: Olivier Danvy's home page
21:23:25 <ddarius> kc5tja: There are no monad transformers involved with main.
21:23:37 <kc5tja> Well, main runs "inside" the IO monad.
21:23:48 <ddarius> But, M A /= T M a
21:23:48 <kc5tja> Yet, I can still invoke State-monadic functions via runState.
21:23:51 <ddarius> @type lift
21:23:54 <kc5tja> How is runState related to lift?
21:24:00 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:25:23 <clanehin> kc5tja: iirc, the monad transformer instance for StateT calls runState (or one of it's friends)
21:25:45 <kc5tja> clanehin: Not if the lower monad is IO it's not.  :)
21:26:06 <kc5tja> Maybe I'm just not asking the right question.
21:26:16 <kc5tja> I'll give up, because I'm not communicating clearly.
21:26:45 <kc5tja> brb -- food.
21:26:59 <clanehin> hmm, I think I got that backwards
21:29:27 <clanehin> And kc5tja went brb so now I can't correct myself.
21:33:17 <clanehin> But kc5tja, when you come back, evalStateT and it's friends call runStateT, using return from the underlying monad as a pure function, when you use lift you insert an impure usage of the underlying monad that is being used anyway
21:34:35 <sorear> woo, I just wrote a Haskell program to generate the cayley table for dih[4]
21:35:36 <clanehin> kc5tja: So the relationship between lift and runState is that lift /stops/ running the state and just holds onto it for a while
21:35:52 <ddarius> lift is the return of monad transformers.
21:39:28 <kc5tja> back
21:40:33 * kc5tja needs to get the GHC sources, so I can poke around these transformers a bit...
21:40:50 <kc5tja> All I have are .hi files in my package directory.
21:42:03 <clanehin> kc5tja: http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
21:43:02 <sm> timing stats for my program with various options: hledger-o0 19.28  hledger-o2 4.68  hledger-o0-prof 42.93  hledger-o2-prof 6.90
21:44:16 <bos> @pl \m p d s -> evalClause m (mkFI p d s)
21:44:17 <lambdabot> (. mkFI) . (.) . (.) . evalClause
21:44:27 <kc5tja> Oh -- duhh -- of course.  :)
21:44:41 <sm> aha, I thought those were off.. those are if I pipe output to dev null. If I print output, it is much slower :(
21:44:56 <sm> anyway, good.. on with the profiling
21:45:56 <sm> my functional data structures are making it work much too hard, compared to what an OO/imperative program would do
21:46:13 <sm> here's where it gets a bit tricky, for me
21:47:10 <sorear> ...
21:47:35 <bos> is there a term that describes the function you pass to a fold?
21:47:38 <bos> the foldee?
21:47:43 <bos> the shiny doodad?
21:48:05 <sorear> argument :)
21:48:10 <olliej|home> bos: heheh
21:48:14 <bos> well, that's no fun.
21:48:16 <bos> http://www.flickr.com/photos/goopymart/51915073/
21:48:17 <lambdabot> Title: shiny do-dad on Flickr - Photo Sharing!
21:48:25 <dmead> folder?
21:48:27 <sm> I think the next step is to make smarter data structures, that cache frequently-used values
21:48:28 <dmead> foldie?
21:48:39 <sm> Ledger -> CookedLedger...
21:49:27 <fridim> I don't understand why   square x = x*x   and  square = \x -> x*x   are from different type (first is Num and the other is Int)
21:49:40 <jcreigh> I tend to think of it as the "folding function"
21:49:53 <monochrom> the functions you pass to a fold, can be called an algebra, considering that the data type is an initial algebra, and fold provides the homomorphism from the initial algebra to yours.
21:49:56 <fridim> :t \x -> x*x
21:50:01 <jcreigh> fridim: monomorhish restriction, I believe.
21:50:05 <lambdabot> forall a. (Num a) => a -> a
21:50:16 <dmead> fridim: force it with the type signatures
21:50:20 <jcreigh> monomorphism, rather
21:50:26 <allbery_b> yel, that's the MMR
21:50:29 <allbery_b> yeh
21:50:32 <ddarius> http://cs.wellesley.edu/~fturbak/captain-abstraction.html
21:50:34 <lambdabot> Title: Captain Abstraction
21:50:55 <bos> wellesley must be some kind of hotbed of fp.
21:51:08 <fridim> I still don't understand :)
21:51:13 <jcreigh> fridim: it's an obscure corner of Haskell's type system: http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:51:15 <lambdabot> Title: Monomorphism restriction - HaskellWiki
21:51:42 <dfranke> anyone know of a tutorial on the ContT and  StateT transformers?
21:52:04 <clanehin> if it's foldr it's called the dexterous sequential combinator, foldl is the sinister reverse confused combinator
21:52:20 <fridim> jcreigh, thanks
21:52:27 <bos> fold chirality. i like it.
21:55:12 <kc5tja> OK, this is so far way above my head.
21:56:04 <kc5tja> But there is just enough of a hook for me to ponder on while I sleep tonight: If runState :: s -> (a,s), then runStateT :: s -> m (a,s), which is intriguing.
21:59:01 <clanehin> kc5tja: my experience, the brilliance of monad transformers is how they trick you into thinking that they are many times more complicated than they actually are (like many things haskell)
21:59:26 <ddarius> :t mapAccumL
21:59:29 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:59:40 <dfranke> clanehin, well, they still seem to be fooling me ATM.
21:59:45 <Cheery> can you flatten monad transformers some way?
21:59:51 <clanehin> my wayward explanations probably didn't help :)
22:00:27 <Cheery> ie. say you have TimerT with one interesting method- capture
22:00:44 <kc5tja> clanehin: Thus leading to further evidence that the human brain is designed to work with a minimum amount of complexity.
22:00:54 <Cheery> how would you remake the IO -monad to be seen again under the TimerT?
22:00:56 <kc5tja> Anything too low or too much complexity, and it becomes intractible.
22:01:22 <Cheery> I'm simple guy, can I help?
22:02:48 <kc5tja> Well, let me think here (with respect to flattening things).
22:03:23 <kc5tja> The MonadTrans class declares a lift method, which is "supposed" to lift the lower method into your "current level".
22:03:23 <allbery_b> no flattening that I know of but you can lift stuff
22:03:27 <kc5tja> But this is wrong.
22:03:39 <Cheery> transformer monads are just monads that are put on an another monad, so that you can lift it up and do something with the underlying monad
22:03:39 <allbery_b> or liftIO, specifically, when layered on top of the IO monad
22:03:50 <kc5tja> Looking at runStateT, it's clearly showing that your "current level" stuff is being *lowered* into the 2nd monad parameter.
22:04:06 <Cheery> thought, you can't directly put, say State over IO
22:04:09 <kc5tja> So, for example, if you're using state and IO together, all your state transactions are being done through the IO monad (IO (a,s))
22:04:12 <Cheery> so you need transformed version from it
22:04:14 <Cheery> StateT
22:04:35 <monochrom> The way you combat complexity is to worry about just one thing at a time.  Monad transformers do that.  Say you're looking at StateT Int Blahblah a.  Worry one thing at a time: sometimes you think "this has Int as state" and ignore Blahblah, sometimes you think "this has Blahblah" and ignore state.  Don't think both at once.
22:04:50 <sorear> @unmtl StateT Int IO Foo
22:04:51 <lambdabot> Int -> IO (Foo, Int)
22:05:10 <kc5tja> monochrom: That's irrelavent.  I'm trying to understand the tool, not how to use it.  Using it is obvious.
22:05:10 <sorear> think about how to combine two of those in sequence.
22:05:39 <monochrom> OK, I'm making a comment not necessarily directed at you.
22:05:48 <kc5tja> Ah, I thought it was.
22:06:11 <allbery_b> kc5tja: I'd claim that when you have e.g. StateT IO, you are in the StateT, if you want to do I/O you lift its result into the StateT, hence lift (IO action)
22:06:32 <allbery_b> you lower an action into the IO monad, then lift the result back out
22:06:50 <dfranke> I have the misfortune of needing to use two (possibly three) transformers at the same time.
22:06:59 <dfranke> when I've never used one before.
22:07:05 <kc5tja> allbery_b: I see that as a nice conceptual sugarcoated view, but runStateT's type signature doesn't appear to agree.
22:07:08 <dons> hehe we use 2 in xmonad without rouble
22:07:15 <dons> trouble. ReaderT (StateT IO ..)
22:07:16 <jcreigh> newtype X a = X (ReaderT XConf (StateT XState IO) a)
22:07:22 <dons> that's the one!
22:07:39 <dons> read-only state, over modifiable state, over IO
22:07:46 <dfranke> I'm looking  at needing StateT, ErrorT, and possibly ContT.
22:08:30 <dfranke> all while interpreting an arrow implemented by GADT tree, on a base monad that's user specified.
22:08:45 <allbery_b> it does, actually, if you remember that you don't lift out a result by unwrapping it, but by wrapping it
22:09:00 <kc5tja> Damn, this is complicated -- so many interactions going on at once.  I suppose this is why we have computers doing all the hard work.
22:09:16 <dfranke> so if you're cleaning up bits of shrapnel that were once my brain, you'll know what happened.
22:09:20 <allbery_b> so lift converts an IO something to a StateT something (IO something)
22:10:11 <allbery_b> and runStateT unwraps the StateT, producing an IO something --- but because you can't unwrap IO, you get IO (something, something) instead of (something, IO something)
22:10:14 <bos> am i missing the existence of an "is sublist of" function?
22:10:33 <allbery_b> @type isInfixOf
22:10:36 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
22:10:38 <kc5tja> allbery_b: That's what I said above.
22:10:42 <mauke> new in 6.6
22:10:46 <bos> thanks.
22:10:53 <Cheery> I'd probably need to get something like unlift
22:11:21 <kc5tja> Cheery: beatDownWithaBillyClub sounds like a good candidate.  ;D
22:11:44 <sm> hm. I get a *** Exception: Prelude.head: empty list at runtime.. I wonder how to track it down
22:12:02 <allbery_b> Debug.Trace.trace?
22:12:13 <kc5tja> Ohh, I remember reading somewhere in the GHC manual how to set compiler flags that causes more precise diagnostics on exceptions.
22:12:58 <allbery_b> I do kinda wish exceptions carried location information, yeh
22:13:01 <Cheery> maybe my billyclub would be the MonadIO -thing.
22:13:02 <Cheery> :)
22:13:03 <monochrom> Control.Exception.assert can produce line numbers.
22:13:08 <Cheery> lets see..
22:13:52 <sm> allbery_b: excellent idea, thanks
22:14:07 <sm> kc5tja: oh, nice
22:14:09 <sorear> sm: compile with -prof -auto-all, run with +RTS -xc
22:14:23 <dfranke> and oh yes, did I mention that my state is going to contain a field whose kind is (* -> *) -> * -> (* -> *) -> * -> * -> * -> * -> *?
22:14:26 <sm> sorear: ah, thx
22:14:28 <sorear> sm: this of course costs 2x performance
22:14:41 <sorear> and requires profiling libs to be installed
22:14:52 * allbery_b has had such nasties... he redesigned to simplify things a bit
22:14:54 <sm> yes.. that's ok, I have them
22:15:16 <Cheery> ?src StateT
22:15:17 <sm> I think I need -prof on always for the moment
22:15:17 <lambdabot> Source not found. You type like i drive.
22:15:27 <sorear> dfranke: fields can only have kind * or #, sorry
22:15:37 <mauke> @source Control.Monad.State
22:15:38 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
22:15:56 <dfranke> sorear, yeah, all those parameters will get filled and it'll end up as *.  But I have to fill them in first.
22:16:04 <sm> ah.. so I'll have to make the binary, no way to profile when running the .hs I guess
22:16:31 <sorear> dfranke: the tycon could have that kind - but values are all concrete
22:16:44 <dfranke> so right now I have a structure with that kind, and it'll get stuck into another structure which then get an equally nasty kind because of it.
22:16:57 <dfranke> which will*
22:18:30 <sorear> sm: you can't run hs directly.  ALL haskell implementations are compilers.
22:18:57 <sorear> (alas, the ultrafast bytecode compiler doesn't work with -prof)
22:19:20 <sm> ok
22:19:41 <sm> always looking for ways to speed up my edit test cycle, of course
22:19:56 <kc5tja> sm: ??
22:20:04 <kc5tja> Oh, sorry -- getting late here.
22:20:11 * kc5tja thinks he sees what's happening in StateT.
22:20:20 * sorear cheers kc5tja on
22:20:35 <kc5tja> lift just executes a monadic function in the lower monad, _preserving_ s in the process by just returning it verbatim.
22:20:44 <dfranke> I don't understand what the runState/runStateT function is supposed to do.
22:21:15 <kc5tja> where s is the outer monad's state.
22:21:30 <sorear> dfranke: it does absolutely nothing.  it's just a newtype extractor, and exists only to pacify the type checker.
22:22:13 <kc5tja> This warrents another article!  But, I'll do it later.  Gotta get to bed.
22:22:16 <dfranke> sorear, yes, but how do I create a function of the type that it extracts?
22:22:54 <kc5tja> dfranke: You might find it handy to review my Monad explanation (I won't call it a tutorial because, well, I'm no expert in this either).  But I think it captures my epiphanal moment.
22:23:04 <kc5tja> dfranke: http://www.falvotech.com/content/publications/monads/
22:23:05 <lambdabot> Title: Haskell Monads: Another View
22:23:28 <kc5tja> that explains the state monad as I attained enlightenment pondering it.  :)
22:23:36 <monochrom> Does lambdabot know Control.Monad.State?
22:23:50 <kc5tja> However, it doesn't do StateT.  I think I just received understanding of that just now.  Anyway, I'm off.
22:23:55 <sorear> monochrom: yes!
22:24:02 <sorear> bye!
22:24:03 <dfranke> I already understand monads just fine.
22:25:33 <dfranke> I need to construct a State object.  That means I need to pass a function of type (s -> (a,s)) to the type constructor.  What is that function supposed to do?
22:25:35 <monochrom> > runState (do { modify not; return "hello"}) True
22:25:37 <lambdabot>  ("hello",False)
22:25:43 <monochrom> That is an example.
22:26:41 <dfranke> ah!  Ok, I think I get it.
22:26:46 <monochrom> You can, of course, also write this by hand, but I won't recommend it:
22:27:10 <monochrom> > runState (State (\b -> ("hello", not b))) True
22:27:12 <lambdabot>  ("hello",False)
22:27:55 <foxy-om_> who's volunteering to rewrite Rubato in nice, friendly Haskell?
22:28:08 <monochrom> In the case of State, usually you only care about "hello", and you use evalState; or you only care about True, and you use execState.
22:30:47 <sproingie> i'm still puzzled how getStdRandom $ runState $ replicateM 5 $ State random works
22:32:19 <sproingie> i think i don't understand replicateM as much as i thought
22:32:29 <sorear> foxy-om_: who's Rubato?
22:32:33 <mauke> @src replicateM
22:32:34 <lambdabot> replicateM n x = sequence (replicate n x)
22:33:56 <monochrom> @type random
22:33:58 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
22:34:12 <monochrom> @type State random
22:34:14 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
22:34:55 <monochrom> The random generator is the state.  (State random) returns the next number and modifies the generator (ready for more).
22:35:45 <monochrom> replicateM 5 (State random) does that 5 times. Returns list of the 5 numbers. Modifies generator too.
22:37:18 <monochrom> runState (replicateM 5 (State random))  casts that back into a function of type: generator -> ([number], generator)
22:37:23 <monochrom> @type getStdRandom
22:37:26 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
22:38:23 <monochrom> getStdRandom gladly takes that function and executes it, so that the colossal task I have just described is actually materialized.
22:39:10 <monochrom> It updates the global generator as per the thing specifies. Therefore the result needs to be in IO.
22:42:02 <hpaste>  Reuben Grinberg pasted "Ruby Syntax" at http://hpaste.org/1660
22:42:24 * monochrom marvels at the Unreasonable Effectiveness of Types in Program Comprehension
22:44:33 <hpaste>  sm pasted "to optimize.." at http://hpaste.org/1661
22:45:06 <sm> it's weird coming back to haskell after a month or two
22:45:22 <sm> I feel as if another person wrote this code
22:45:41 <sorear> intersect is very very bad
22:45:44 <monochrom> You were in heaven.
22:45:48 <sorear> it is O(n^2)
22:46:07 <sorear> can you guarantee e.g. sortedness?
22:46:20 <sm> sorear, do you have a sort of mental map of what O each standard function is ?
22:46:34 <sorear> sm: yes!
22:46:38 <Cheery> @hoogle unsafeIO
22:46:39 <monochrom> I do.
22:46:39 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
22:46:40 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
22:46:42 <dmead> sm: he could just tell if he recalls the code structure :P
22:46:50 <Cheery> @hoogle unsafe
22:46:51 <sm> very good.. that's something I should work on
22:46:51 <lambdabot> Language.Haskell.TH.unsafe :: Safety
22:46:51 <lambdabot> System.IO.Unsafe :: module
22:46:51 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
22:46:54 <dfranke> ok, I think I've got the hang of this.
22:46:59 <sorear> sm: actually, I just have an unreasonably good factual memory.
22:47:07 <dfranke> I'm beginning to implement it and it's miraculously typechecking.
22:47:28 <sorear> Cheery: System.IO.Unsafe.unsafePerformIO
22:47:35 * monochrom invites dfranke to marvel at the Unreasonable Effectiveness of Types in Program Comprehension
22:47:39 <sm> I never thought of functions in O terms in other languages.. I just knew when they were too slow
22:48:05 <sorear> O is pretty meaningless in haskell anyway.
22:48:12 <sorear> there are just too many variables
22:48:12 <Cheery> sorear: ok, thanks, thought I was looking at unsafeInterleaveIO
22:48:13 <sm> oh. :(
22:48:14 <dons> monochrom: :-)
22:48:19 <dfranke> so now my type signature is just runTransaction' :: (Monad m) => (Transaction m b c) -> b ->
22:48:19 <dfranke>                    StateT TransactionState m c
22:48:30 <sorear> night all.
22:48:34 <sm> night
22:48:37 <dfranke> sure beats what I had on my previous attempt.
22:48:41 <sorear> (must sleep for the standardised testing!)
22:48:48 <seliopou> Any word on when a binaries for 6.6.1 will be available for OS X?
22:50:29 <sorear> dons: did you write your own blog sw?
22:50:58 <sorear> whole bunch of unbalanced      </ br>
22:51:10 <Cheery> I wonder whether it is safe to do unsafeInterleaveIO with pollEvent
22:51:13 <Cheery> I guess so
22:51:25 <monochrom> I disagree.
22:52:40 <dfranke> apropos nothing: is/has there ever been any effort at adding support for infinite types to Haskell?
22:53:05 <Cheery> monochrom: why do you disagree?
22:53:55 <dfranke> so it would be legal to write, eg, v _ = v?
22:54:05 <monochrom> Because I don't know what you're doing. I'm joking. I think you'll make an informed decision.
22:54:17 <dons> sometwo: hmm, does it render incorrectly?
22:54:17 <dons> oh. gone.
22:57:13 <Cheery> monochrom: well, actually I'm afraid that I'm doing premature optimization, I refrained
23:02:34 <MarcWeber> Hi. I have some trouble. I want to read a 16MB file to memory and get single bytes. Which module would you prefer? I've tried ByteString which did work fine on linux but on windows the resulting string was only 158 bytes long (fps-0.7).
23:03:09 <mauke> was the 159th byte a ^Z?
23:03:38 <MarcWeber> mauke: That may have been the case. Don't know. How is ^Z represented in hex?
23:03:44 <MarcWeber> mauke: It's a binary file
23:03:53 <emu> likely it
23:04:02 <mauke> 1A
23:04:11 <mauke> if so, you need to open the file in binary mode
23:04:29 <MarcWeber> mauke: It is
23:04:56 <MarcWeber> So all I have to do is recompiling fpc adding binary ? Thanks a lot!
23:07:59 <MarcWeber> mauke: bracket (openFile f ReadMode) hClose
23:09:02 <mauke> ?
23:09:04 <MarcWeber> is used. How can I add the binary option?
23:09:39 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AopenBinaryFile
23:09:42 <lambdabot> http://tinyurl.com/sbkmj
23:10:47 <hpaste>  fridim pasted "how can I do that with an intermediate b ?" at http://hpaste.org/1662
23:12:07 <hpaste>  monochrom annotated "how can I do that with an intermediate b ?" with "let" at http://hpaste.org/1662#a1
23:13:21 <fridim> damn
23:18:53 <MarcWeber> mauke: Drop me a message if it happens that I can do anything for you! (It did work)
23:20:49 <bos> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip-0.1
23:20:52 <lambdabot> http://tinyurl.com/28fpk6
23:22:02 <dons> sweet
23:22:45 <dons> ndm, got to get 'filepath' on hackage please.
23:23:54 <sm> oh this is great
23:24:26 <sm> in a profile, replace leading spaces with stars and turn on emacs org-mode, for a folding outline
23:25:17 <Cheery> @hoogle sleep
23:25:21 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
23:25:29 <Cheery> @hoogle wait
23:25:30 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
23:25:31 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
23:25:31 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
23:25:35 <dons> Control.Concurrent.threadDelay?
23:25:44 <Cheery> @hoogle threadDelay
23:25:45 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
23:25:50 <Cheery> hmm
23:26:08 <Cheery> I can try that!
23:27:38 <Cheery> dons: threadDelay does not delay
23:27:43 <Cheery> @hoogle delay
23:27:44 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
23:27:45 <lambdabot> Network.Socket.NoDelay :: SocketOption
23:27:45 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
23:28:58 <dons> Cheery: I think you need to compiled with -threaded
23:29:04 <monochrom> threadDelay 1  will delay for probably.... 1 microsecond
23:29:05 <Cheery> ok
23:29:08 <dons> or, you got the seconds value wroog :-)
23:29:28 <dons> try: threadDelay ( 1 * 10^9 )
23:29:32 <Cheery> picosec, microsec, millisec.. GRAAAAH!!!!
23:29:42 <monochrom> Do you know how long 1 microsecond is?
23:29:57 <dons> Prelude> Control.Concurrent.threadDelay (10^6)
23:30:13 * monochrom takes out a small piece of optical fibre and talks like Gracehopper.
23:30:13 <Cheery> monochrom: it's somewhere between pico and milli
23:30:30 <monochrom> "It's the time for light to travel this length."
23:30:40 <Cheery> I guess it was 1/10 of millisecond
23:30:52 <dons> yes, the docs do say, "-- | Suspends the current thread for a given number of microseconds
23:30:55 <dons> -- (GHC only).
23:30:58 <dons> "
23:31:05 <dons> we should really have a type for this :) since 'Int' doesn't help much
23:31:19 <Cheery> or wait
23:31:22 <dons> hmm, and limits us to what, 30 minutes sleeping
23:31:26 <Cheery> it was 1/1000
23:31:48 <monochrom> Learn SI! It's always 1000 or 1/1000 times!
23:32:15 <Cheery> monochrom: it's not that I wouldn't know it, I just don't remember
23:32:20 <dons> ?google 1 second in microseconds
23:32:21 <lambdabot> 1 second = 1,000,000 microseconds
23:32:46 <arcatan> do you really have to google that?
23:32:59 <dons> heh.
23:33:01 <Korollary> It costs them electricity
23:33:14 <dons> yeah, power to the people man!
23:33:18 <Korollary> ?google one hour in minutes
23:33:20 <lambdabot> http://www.tripadvisor.com/ShowTopic-g188590-i60-k1140724-One_hour_five_minutes_enough_for_plane_change-Amsterdam_Noord_Holland.html
23:33:21 <lambdabot> Title: Amsterdam forum: One hour, five minutes enough for plane change? - TripAdvisor
23:33:33 <Korollary> wtf
23:33:37 <dons> ?google 1 hour in minutes
23:33:38 <lambdabot> 1 hour = 60 minutes
23:33:40 <Korollary> ahaha
23:34:28 <dons> > maxBound :: Int
23:34:29 <lambdabot>  2147483647
23:34:40 <dons> ?google 2147483647 microseconds in minutes
23:34:41 <lambdabot> 2,147,483,647 microseconds = 35.7913941 minutes
23:34:53 <dons> there you go, max sleep with threadDelay is a bit short.
23:35:18 <Cheery> :t threadDelay
23:35:21 <lambdabot> Not in scope: `threadDelay'
23:35:27 <Cheery> it was Int anyways?
23:35:28 <dons> ?hoogle threadDelay
23:35:28 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
23:35:44 <Cheery> @hoogle getCPUTime
23:35:44 <lambdabot> CPUTime.getCPUTime :: IO Integer
23:35:46 <dons> > maxBound :: Word
23:35:48 <lambdabot>  4294967295
23:35:57 <Cheery> @hoogle Integer -> Int
23:35:58 <lambdabot> No matches, try a more general search
23:36:01 <dons> ?google 4294967295 microseconds in minutes
23:36:02 <lambdabot> 4,294,967,295 microseconds = 71.5827882 minutes
23:36:14 <dons> > maxBound :: Word4096
23:36:17 <lambdabot>  ghc: failed with error code 9
23:36:21 <dons> heh
23:36:27 <dons> > maxBound :: Word256
23:36:27 <monochrom> haha
23:36:30 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639935
23:36:30 <Cheery> anyways, that threadDelay doesn't seem to fuck up getCPUTime
23:36:39 <dons> > maxBound :: Word128
23:36:41 <lambdabot>  340282366920938463463374607431768211455
23:36:45 <Cheery> I propose removal of SDL.delay, because of this
23:36:52 <dons> ?google 340282366920938463463374607431768211455 microseconds in minutes
23:36:53 <lambdabot> 340,282,366,920,938,463,463,374,607,431,768,211,455 microseconds = 5.67137278 x 10^30 minutes
23:36:58 <dons> that should do
23:37:16 <dons> > 340282366920938463463374607431768211455 microseconds in years
23:37:16 <lambdabot>  Parse error
23:37:19 <monochrom> "until Hell freezes over"
23:37:22 <dons> ?google 340282366920938463463374607431768211455 microseconds in years
23:37:23 <lambdabot> 340,282,366,920,938,463,463,374,607,431,768,211,455 microseconds = 1.07831278 x 10^25 years
23:37:44 <dons> ?google 340282366920938463463374607431768211455 microseconds in epochs
23:37:45 <lambdabot> No Result Found.
23:37:46 <dons> doh
23:37:49 <dons> :)
23:37:51 <monochrom> Have you tried 64 bits?
23:38:04 <dons> > maxBound :: Word64
23:38:05 <lambdabot>  18446744073709551615
23:38:14 <dons> ?google 18446744073709551615 microseconds in year
23:38:15 <lambdabot> 18,446,744,073,709,551,615 microseconds = 584,554.531 year
23:38:16 <monochrom> ?google 2^64 microseconds in year
23:38:18 <lambdabot> (2^64) microseconds = 584,554.531 year
23:38:26 <dons> I suppose that would be ok.
23:38:34 <dons> though some of my haskell software seems very stable..
23:38:47 <dons> nice round numbe rthat.
23:38:52 <monochrom> The Sun will not be stable by then.
23:39:04 <dons> in 500k years??
23:39:13 <monochrom> I actually forgot.
23:39:44 <dons> i'd have though maybe 2-4 billion.. (aren't we half way through?)
23:40:00 <monochrom> ok good
23:40:06 <dons> 500k isn't very long.
23:40:24 <dons> lambdabot might control the universe before then
23:40:50 <monochrom> @remember dons 500k isn't very long. lambdabot might control the universe before then
23:40:50 <lambdabot> Done.
23:41:20 <dons> i wouldn't even consider that feature bloat
23:41:45 <dons> type checking, haskell eval, theorem proving, power over the cosmos..
23:41:46 <dons> seems logical
23:41:58 <monochrom> heh
23:43:58 <Korollary> Somebody would spoil it with the Lambdabot Incompetence Theorem
23:44:52 <Cheery> oh well, the threadDelay does exactly same thing
23:44:57 <lambdabot> i am kompitint!
23:45:01 <Cheery> @hoogle getTime
23:45:02 <lambdabot> No matches found
23:45:08 <Cheery> @hoogle time
23:45:09 <lambdabot> System.Time :: module
23:45:09 <lambdabot> Time :: module
23:45:09 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
23:51:49 <ailndx> dons: any progress of hs-plugins in win lately?
23:54:09 <Cheery> @google 1 microsec in picosecs
23:54:14 <lambdabot> http://darwinsource.opendarwin.org/10.3/AppleMESH-112.3.1/mesh.cpp
23:54:20 <Cheery> @google 1 microsec in picoseconds
23:54:28 <lambdabot> http://www.nea.fr/html/dbdata/dictionaries/units.html
23:54:36 <Cheery> @google 1 microseconds in picoseconds
23:54:37 <lambdabot> 1 microseconds = 1,000,000 picoseconds
23:59:26 <Cheery> this is annoying
23:59:32 <Cheery> things just do not work together :/
