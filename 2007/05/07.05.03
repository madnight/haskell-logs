00:01:01 <dfranke> dons, I want to be as current as I can.  The reason I'm doing this is so I can contribute a patch to the POSIX library that I realized that I'm going to need for my current project.
00:02:06 <dfranke> (adding bindings for POSIX shared memory and semaphores)
00:04:10 <dons> dfranke: yeah, if you're writing patches, definitely a good idea to use head
00:10:15 <dons> mm, random blogger who probably represents a common case:
00:10:16 <dons> "Thanks to GoodMathBadMath for fueling a certain arcane interest in the Haskell language again which I deemed incredibly useless back at University and am just learning to enjoy now that I don?t have to anymore."
00:10:48 <dons> i always wonder what happened to the 600 undergrads a year we taught haskell at unsw between 98 and 02
00:11:06 <jmg_> hi
00:11:16 <dons> hey jmg_
00:11:20 <dons> how's code?
00:11:37 <jmg_> i just arrived at work, it's morning here
00:11:46 <dons> ?time jmg_
00:11:46 <lambdabot> Local time for jmg_ is 2007-05-03 09:10:19 +0200
00:11:48 <dons> ah yes :)
00:11:53 <jmg_> cool
00:12:27 <jmg_> we are teaching first years sml for years now. and i must admit that most of them don't seem to realize how useful functional programming can be
00:13:14 <dons> yeah. got to give them 5 years of C++ first
00:13:17 <dons> then they'll beg for it
00:13:22 <jmg_> :-)
00:13:26 <Korollary> People have all kinds of bad opinions. Politics, religion, technical stuff. You can't correct everybody.
00:13:47 <jmg_> of course not
00:13:49 <dons> Haskell was my first language, and I abandoned it till after I'd done 2 years of Java at school.
00:14:04 <dfranke> no, but you can at least beat them with a cluebat and see if it helps.
00:15:22 <dmwit> I think learning something really cool and hating it, then loving it a few years later is pretty common.
00:15:23 <narain> i was taught sml in first year undergrad. most of us already knew c++. i was one of the very few who actually liked functional programming. in fact i'm not sure i wasn't the only one
00:15:25 <jmg_> so many seem resistent to new insights
00:15:25 <dons> Korollary: but you love to correct people :-) you know it's fun!
00:15:50 <dmwit> (Happened to me with go, for instance.)
00:16:10 <dons> kids dont' know what's good for them
00:16:31 <narain> my fellow undergrads looked at me strangely when i said i liked sml
00:16:32 <dons> you have to fail on your own a few times to really appreciate why things are done a certain way
00:16:40 <dmwit> My theory is that it lays dormant, but every time something comes up that's hard in your current language and would be easy elsewhere, your subconcious makes a little post-it note.
00:16:41 <dons> narain: you're a weirdo!
00:16:47 <jmg_> but i thought they come to university because they want to learn the best stuff there is
00:16:50 <dmwit> Then when you come to it again, you're like, hey!  This could be neat.
00:17:12 <dons> i like how dcoutts at oxford is making the undergrads use gtk2hs and QuickCheck. that'll learn 'em
00:17:13 <jmg_> And java is definitely not the bust language there is
00:17:36 <narain> dons: yeah, well i'm trying to get better at it :)
00:17:44 <notsmack> first years probably haven't hit the problems solved by functional code.  also, a lot of them code by typing until it compiles and works, which may lend itself better to traditional languages?
00:17:49 <dmwit> jmg_: I think most don't.
00:17:58 <dmwit> Most do it because it is the convential next step.
00:18:00 <dons> notsmack: yeah, maybe to scheme.
00:18:01 <jmg_> narain: do you study there?
00:18:06 <ari> Hey, I code Haskell by typing until it compiles and works :(
00:18:15 <dons> hehe.
00:18:23 <narain> jmg_: no, i did undergrad at iit delhi in india
00:18:28 <dons> the program is out there, its just a matter of asking the type checker to guide you to it
00:18:41 <jmg_> :-)
00:18:59 <Cheery> dmwit: your in right, first time when I encountered haskell, I didn't understood it's value
00:19:18 <Cheery> I guess same has happened for anyone noob noob who whas tried to get into haskell
00:19:28 <narain> i liked haskell for the mental aerobics
00:19:34 <dons> i had a bug in xmonad a couple of weeks ago, and the type checker just wouldn't let me go. then i found the key, fundamental flaw in my thinking. and in the end there was only one way to write this function that made sense, and that was the only one that would type too. it was beautiful
00:19:42 <dmwit> narain: Me too. =)
00:19:46 <dons> the type checker really did know more about what I was trying to do than I did
00:19:50 <Cheery> I think there would have not been an easy to turn me to like about haskell then
00:20:20 <narain> dons: wow, that's ... inspiring
00:20:29 <Cheery> dons: I've noticed that myself too
00:20:42 <jmg_> it's not only undergrad who don't see the value of haskell or  fp in general, there are even many professors here who just refuse two give it a try in their heads.
00:20:50 <Cheery> I guess I refuse to use a language without marking up and reasoning about types anymore
00:21:47 <dmwit> jmg_: Re: people going to college to learn; people look at me strangely when I read sections of books that aren't assigned.
00:21:55 <Cheery> thought, I don't know why would I use other language since haskell does that for me automaticly
00:22:01 <jmg_> dons: do you use xmonad or is it just a toy project?
00:22:11 <dmwit> I use xmonad!
00:22:13 <narain> dmwit: people go to college because their parents want them to learn
00:22:15 <dmwit> It's no toy.
00:22:19 <dmwit> narain: =)
00:22:53 <Cheery> well, what's the difference between a toy and everything else?
00:23:13 <notsmack> i've been meaning to try xmonad, maybe now's the time...
00:23:15 <jmg_> sorry, i didn't want to offend anyone. windowmanager aren't that useful with os x, therefore I didn't try it
00:23:20 <narain> toys are fun! ergo, haskell is a toy
00:23:20 <Cheery> I've thought there's just toys
00:23:49 <notsmack> i've always loved ion; how does xmonad do with multi-small-window stuff like gimp, gaim, etc?
00:24:00 <jmg_> cheery: sometimes it seems so. perhaps i should have said proof-of-concept instead of toy
00:24:17 <dmwit> Ah, so maybe I should say, "It's more than a toy" instead.
00:24:49 <dmwit> notsmack: sjanssen is working on a floating layer that should handle that situation pretty nicely.
00:25:00 <vegai> notsmack: check out dwm as well, xmonad's spiritual father
00:25:09 <dmwit> Yes, dwm is very nice.
00:25:19 <notsmack> dmwit: yeah?  what's the theory behind it?
00:25:36 <Cheery> dmwit: I assume xmonad is good old-style window manager, have you thought about windowless managers?
00:25:39 <dmwit> notsmack: It acts just like more conventional window managers. =P
00:25:53 <dmwit> Cheery: What does windowless mean?
00:26:17 <Cheery> that it has no program-associated-to-window -abstraction
00:26:33 <dmwit> Tell me more, I'm intrigued.
00:26:55 <dmwit> Does one exist now with a web page I could peruse?
00:26:59 <narain> so *that's* why people dismiss new programming ideas. toys are fun, therefore things that make programming fun are toys, and only things that are painful are "real world development in the enterprise"
00:27:04 <Cheery> well, usually when you create a program.. you make it it's own frontend to interact with the window
00:27:28 <notsmack> so the floating windows would just float over the tiles?
00:27:33 <dmwit> yeah
00:27:45 <dmwit> This is how dwm handles it, too.
00:27:54 <notsmack> yeah, i'm not a fan of that
00:28:01 <dmwit> Ah, what do you prefer?
00:28:02 * notsmack is looking at dwm screenshots now
00:28:30 <Cheery> add friends for window
00:28:42 <notsmack> dmwit: i'd never actually decided, it's why i left ion.  I'd imagine some sort of scripting where the tiles rearrange to accomodate certain apps with unusual needs?
00:29:18 <Cheery> then put the program select it's interaction method
00:29:23 <dmwit> Hmmm... I've thought about that some.
00:29:42 <jmg_> narain: i hope you don't think that is my attitude. i was just wondering whether xmonad was developed to be used everyday or to show and play around with some nice concepts.
00:29:43 <dmwit> Something like OSX's algorithm for placing windows in the Expose mode.
00:30:02 <Cheery> window is for things which want to create very specialised frontends or games
00:30:06 <dmwit> Cheery: I'm not sure I follow you.  Does this mean that each program would replace its window with, for example, dialogs?
00:30:11 <narain> jmg_: not at all, just a general attemptedly-humorous rant
00:30:13 <notsmack> dmwit: i'm not sure how it could be made workable...
00:30:21 <jmg_> narain: fine
00:30:24 <dmwit> notsmack: Have a *very* big screen. =)
00:30:35 <notsmack> dmwit: (i use a 30" dell.)
00:30:39 <notsmack> :-)
00:31:07 <Cheery> dmwit: yes
00:31:25 <dmwit> What is the advantage?
00:31:58 <Cheery> chance of uniform interfaces
00:32:33 <dmwit> Hmmm...
00:32:43 <dmwit> This would require rewriting all current GUI programs?
00:32:43 <Cheery> think about how a terminal would blend into this
00:32:50 <notsmack> ion's solution is interesting, it creates a tiled window as normal, except floating windows can exist within that
00:32:51 <Cheery> yes
00:33:22 <dmwit> As long as we're rewriting everything, aren't there better ways to get a uniform interface?
00:34:04 <dmwit> notsmack: Ah, interesting.  See also the mailing list suggestion of having an Xnest window with another window manager running inside for floating windows.
00:34:07 <Cheery> hmm, allow old programs to still use window
00:36:17 <Cheery> I guess I'd love the most if my desktop would look more like a screen rather than usual GUI
00:36:38 <dmwit> notsmack: Never mind, I can't find it.  But the content is all in my last sentence anyway. =P
00:38:07 <Cheery> that's another thing I've thought, in screen it's quite easy to jump between different programs
00:39:31 <dmwit> Oh, I've never used screen.
00:39:56 <shapr> Yarr!
00:40:17 <notsmack> shapr: it's not that time of year already, is it?
00:40:21 <shapr> Oh right
00:40:28 <shapr> Why is the HaskellWiki so very slow right now?
00:40:54 <Cheery> dmwit: think about a set, made from console programs, then you have one or two views where you can switch between that set of console programs
00:41:50 <Cheery> It's simple, much more simple idea than usual GUI in a window, and I think it works for many things
00:42:23 <DRMacIver> Hmph. HGL is refusing to install on my machine because of an unrecognised architecture (AMD64 linux). Is it likely to flat out not work, or do I just need to convince the script to install anyway?
00:43:16 <dmwit> Cheery: What are the (say) four most common C-a commands I should know to give screen a try?
00:43:43 <vegai> dmwit: d, c, n, p
00:43:47 <mauke> d (detach), n (next), p (prev), C-a (last)
00:43:47 <notsmack> C-a C-a : switch to previous window
00:43:48 <dmwit> (From the man page, screen looks pretty big.)
00:43:48 <Cheery> ^A?
00:43:57 <Cheery> ^A? (help)
00:43:59 <mauke> well, and c, yeah
00:44:07 <vegai> amazing consensus
00:44:10 <nornagon> ^A k
00:44:34 <notsmack> "screen -r" to attach to a detached screen
00:44:46 <nornagon> -d -r to detach and reattach
00:44:48 <dmwit> Okay, dcnp? are the ones I'll remember for now.
00:44:50 <nornagon> -x to get multiview
00:45:10 <mauke> oh, and C-a a if you need to send a real ^A
00:45:24 <Cheery> there's yet third thing I've thought
00:45:56 <Cheery> I think there should be very rare cases where you should close a program
00:46:13 <Cheery> programs should about open and close on themselves
00:46:44 <Cheery> there shouldn't be [X] mark in top right cornel, it should be unnecessary
00:47:03 <mauke> I don't have a [X] :-)
00:47:17 <dmwit> me neither
00:47:59 <narain> i have an [X] but i only use it when a program stops responding
00:48:12 <dmwit> Ah, screen is actually a bit nicer than gnome-terminal's tabs.
00:48:39 <mauke> I use konsole tabs *and* screen
00:49:03 <dmwit> Cheery: But from what I can see, it's basically just choosing one (fullscreen) "window" at a time.
00:49:10 <dmwit> If you want that there are WM's to do that already!
00:49:15 <dmwit> xmonad, for example. =)
00:49:26 <Cheery> UI should form and programs should open and close when you work with content
00:49:36 <flux> someone should integrate mrxvt and screen
00:49:39 <Cheery> you shouldn't work with the programs themselves :)
00:49:52 <flux> so any mrxvt-session would be a screen-session, and also you could attach screens to mrxvt
00:50:16 * Cheery suddenly remembers MS voice recognition as a great example about working with a program instead of document
00:50:39 <narain> does emacs have a command-line flag to make it run insider the terminal instead of opening a window when in X?
00:50:45 <narain> *inside
00:50:49 <ari> narain: -nw
00:51:08 <mauke> DISPLAY= emacs
00:51:10 <narain> ari: thanks!
00:51:42 <narain> yow, ugly colors
00:51:49 <flux> (also: a real 'screen for x' would be nice..)
00:52:25 <dmwit> flux: vncserver?
00:52:50 <DRMacIver> Hm. I'm rapidly coming to the conclusion that no one actually bothers to do graphics programming in Haskell.
00:52:50 <shapr> narain: Oh yeah? Check out my emacs color-theme: http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html
00:52:52 <lambdabot> Title: Test_TutorRing.hs
00:53:02 <flux> dmwit, not really.. it works by copying regions, not like X
00:53:10 <Cheery> DRMacIver: how so?
00:53:18 <flux> dmwit, it's not as fast as X in a local network
00:53:33 <flux> dmwit, but does it nowadays support 'storing' single windows?
00:53:35 <shapr> DRMacIver: I think people use HOpenGL, SDL, GTK, etc bindings for graphics in Haskell.
00:53:54 <flux> dmwit, or resizing windows..
00:53:59 <dmwit> flux: True it isn't fast, but it has the screen-fu in that you can "detach" and work on the same windowset from another machine.
00:54:09 <narain> shapr: oh, well done :p ...but i just ran emacs inside a terminal and it was my terminal emulator's colors that were apparently ugly
00:54:10 <DRMacIver> Cheery: Well the first two graphics libraries I've picked at random (well, not at random. One was recommended in School of Expression) haven't been updated in the last 4 years and respectively don't work on my architecture and depend on deprecated APIs.
00:54:26 <narain> at least in the combination that emacs put them together in
00:54:30 <dmwit> Heh, I bet one of them was Fran.
00:54:50 <flux> dmwit, yeah, and it even has multi-detach
00:54:51 <narain> i'm trying to do graphics in haskell
00:54:55 <shapr> DRMacIver: dcoutts wrote an HGL clone that uses GTK and Cairo, I think. It should work fine for you.
00:54:59 <DRMacIver> Well, indirectly. HOpenGL depends on Green Card depends on Data.FiniteMap.
00:55:09 <DRMacIver> shapr: Ok, I'll take a look. Thanks.
00:55:24 <shapr> I can't remember its name at the moment, bit too sleepy.
00:55:34 <DRMacIver> That's ok. I probably shouldn't be working on this right now anyway. :)
00:56:07 <Cheery> DRMacIver: are you meaning non-interactive graphics?
00:56:27 <DRMacIver> Cheery: Right now if I can get a window to pop up saying "Hello World" it would be a good start. :)
00:56:43 <Cheery> interactive huh
00:56:55 <DRMacIver> Well, I suppose.
00:57:00 <DRMacIver> I don't want ot just generate flat images.
00:57:15 <narain> DRMacIver: have you used OpenGL before?
00:57:20 <DRMacIver> Not really, no.
00:57:29 <Cheery> hmm, would hSDL be what you want?
00:58:36 <dmwit> DRMacIver: My suggestion is to use Cairo with gtk2hs.
00:58:48 <dmwit> The pictures it makes are very pretty, and easy to specify.
00:58:54 <narain> it depends on what kind of graphics you want to do: 3d objects? image manipulation? 2d animation?
00:59:10 <notsmack> @where X11-extras
00:59:11 <lambdabot> http://darcs.haskell.org/~sjanssen/X11-extras
00:59:16 <Cheery> I'm just rewriting nehe-tuts for haskell, mixed in a bit of spicy stuff
00:59:31 <Cheery> I wonder where could I get darcs or SVN space?
00:59:47 <narain> 3d -> opengl | image -> i_dunno | 2d -> Either opengl cairo
01:00:31 <dmwit> heh
01:00:33 <dmwit> narain++
01:00:34 <DRMacIver> I don't want to do anything complicated at the moment. Assume "window with Hello World" in it is the extent of my ambitions for the minute. :)
01:00:53 <dmwit> ?where gtk2hs
01:00:54 <lambdabot> http://haskell.org/gtk2hs/
01:01:23 <dmwit> Oh, wait.
01:01:34 <dmwit> You want the "Hello world" to be rendered?  Or just text?
01:02:01 <DRMacIver> Just text is fine.
01:02:25 <dmwit> yeah, ok
01:02:28 <Cheery> I'm going to elaborately document my every move, but the code will be more like a library rather than tutorial
01:02:31 <hpaste>  notsmack pasted "X11 configure error" at http://hpaste.org/1689
01:03:02 <sjanssen> notsmack: are you on a 64 bit machine?
01:03:02 * narain can easily make a window with (a terminal emulator with) hello world in it ;)
01:03:07 <notsmack> sjanssen: yeah
01:03:17 <Cheery> I'll give you some what I've done this far
01:03:28 <Cheery> (I'm still lacking the document part thought)
01:03:43 <notsmack> (AMD Athlon(tm) 64 X2 Dual Core Processor 4200+)
01:03:53 <sjanssen> notsmack: it seems stupid, but I've heard you can just delete all the type signatures in Setup.hs
01:04:15 <narain> actually a window with a triangle or square in it is more common as a graphics hello-world program
01:04:27 <notsmack> sjanssen: seems stupid, but it works
01:04:31 <narain> since drawing text is less trivial in a graphics window\
01:04:33 <DRMacIver> Hm
01:04:41 <hpaste>  Cheery pasted "my version of nehe-tutorials. :>" at http://hpaste.org/1690
01:05:11 <DRMacIver> The source archive on the gtk2hs download page seems to be corrupt.
01:05:57 <narain> Cheery: that's pretty cool, there needs to be a nehe for haskell
01:06:23 <narain> i had a bit of trouble getting started with hopengl since the documentation was out of date
01:06:39 <narain> any particular reason why you're using sdl rather than hopengl?
01:06:58 * DRMacIver labels this as "fuckit, I'll figure this out later"
01:07:09 <Cheery> I'm using sdl just for opening a window
01:07:21 <Cheery> I finalize the first example
01:07:34 <shapr> DRMacIver: @tell it to dcoutts, he's one of the top people in charge of gtk2hs
01:09:34 <dmwit> "It'd make creation of config-file feel like very sunny day!" =))))
01:09:49 <dmwit> The additional parenthesis indicate how happy this made me.
01:10:19 <narain> DRMacIver: it worked fine for me...
01:10:25 <narain> the source archive i mean
01:11:15 <narain> dmwit: oh i forgot to say, thanks for the ++ back there :)
01:11:52 <dmwit> ?karma narain
01:11:53 <lambdabot> narain has a karma of 5
01:12:03 <dmwit> yay!
01:12:18 <dmwit> multiples of five are nice and round
01:12:30 <earthy> as are multiples of 2. ;)
01:12:50 <earthy> or, better yet, powers of 2 :)
01:12:59 <dmwit> Multiples of 0 are nice and round.
01:13:09 <sieni> I prefer cubes of primes
01:13:10 <earthy> depends on your zeros. :)
01:13:41 <dmwit> > map (^3) [2,3,5,7,11,13] -- hmmm...
01:13:46 <lambdabot>  [8,27,125,343,1331,2197]
01:14:06 <shapr> The number five is Erisian.
01:14:21 <earthy> all hail discordia
01:14:37 <narain> > 10 `mod` 3
01:14:39 <lambdabot>  1
01:14:54 <shapr> Hail Eris!
01:15:04 <narain> > let factors = filter ((==0).(n `mod`)) [1..n] in factors 1337
01:15:05 <lambdabot>   Not in scope: `n'
01:15:10 <narain> > let factors n = filter ((==0).(n `mod`)) [1..n] in factors 1337
01:15:10 <dmwit> spoiler: Aeris dies
01:15:12 <lambdabot>  [1,7,191,1337]
01:15:51 <narain> the only discordian quote i know is "death to all fanatics!"
01:16:06 <shapr> Actually, it's "ALL FANATICS MUST DIE!"
01:16:36 <narain> i definitely read "death to all fanatics"
01:16:43 <shapr> Another good Discordian quote is "Fliegende Kinderscheisse!"
01:16:45 <narain> i don't recall the capitalization
01:17:34 * shapr reads the Principia Discordia often
01:19:07 <shapr> I'm a member of the Paratheo-anametamystikhood of Eris Esoteric.
01:19:09 <ari> shapr: No, it's "KILL ALL FANATICS! KILL THEM WITH FIRE!" The Principia Discordia is wrong, and so are you.
01:19:18 <shapr> I mean, c'mon, my name is Erisson
01:19:24 <chowmeined> how do you handle GUIs and things like OpenGL? I mean they use state so much...
01:19:47 <narain> chowmeined: in fact, opengl is entirely a state machine.
01:19:58 <chowmeined> yes i..
01:20:00 <chowmeined> ok
01:20:10 <chowmeined> but how do you handle that with a functional language?
01:20:16 <shapr> narain: Did you go by the irc nick of rahul about five years ago?
01:20:39 <narain> shapr: no, couldn't have been me
01:20:50 <shapr> I'm glad to hear that.
01:21:06 <dmwit> chowmeined: I would assume it's handled in a monad.
01:21:19 <shapr> salut Lunar^
01:21:21 <narain> chowmeined: from what i've seen of hopengl, most of the functions you write are of type IO ()
01:21:22 <dmwit> (Not having actually used HOpenGL I can't be certain.)
01:21:40 <ari> You know your instance-writing is not going well when the first error you get is "parse error on input `instance'"
01:21:42 <chowmeined> doesnt that kind of ruin the whole functional deal?
01:21:50 <narain> well, most of the opengl-related functions anyway
01:21:55 <dmwit> gtk2hs certainly puts most of its stuff in IO ().
01:22:23 <dmwit> chowmeined: You still get to construct the computation in a purely functional way.
01:22:24 <narain> i guess you try to keep your main computation separate from the IO stuff that just renders it
01:22:31 <dmwit> It's just running the computation that isn't necessarily functional.
01:22:41 <narain> like you do in most haskell programs, actually
01:22:57 <Lunar^> shapr: salut :)
01:23:01 <shapr> ca va?
01:23:24 <Lunar^> shapr: I'm still quite off the Haskell community these days...
01:23:42 <narain> shapr: what was this "rahul" of IRC 5 years ago like?
01:25:24 <hpaste>  Cheery pasted "yet small finetuning, but it is here. first example" at http://hpaste.org/1691
01:25:25 <Cale> chowmeined: There are interesting things you could do in order to wrap OpenGL in a purely functional model, but I don't think anyone's done it for Haskell so far.
01:25:39 <shapr> narain: He was a Common Lisp fanatic. So much so that he put me off of CLisp ever since.
01:26:13 <Cheery> chowmeined: look at that paste and you see
01:26:32 <chowmeined> ok
01:27:11 <narain> chowmeined: at this point i'm still not sure what the best way to handle large amounts of state in a hopengl program is, but i should pick up some experience on that since i'm in the process of writing a game in it. ask me later :)
01:27:35 <chowmeined> well i still need to figure out haskell
01:27:44 <Cheery> I think I'm going to look at the original example and see whether it has the same problems as my example
01:27:56 <chowmeined> my mind is so locked into imperative languages
01:28:15 <Cale> The ideal sort of thing I think might be some kind of pure scene modelling DSL.
01:28:40 <Cheery> blow it open, it is not like you wouldn't have the tools
01:29:02 <Cheery> Cale, DSL?
01:29:07 <narain> actually, if anybody else knows about that, it would help me too :) should i dump all my state in a single record or use something like yampa's model? i don't know too much about yampa except that it does some kind of event loop and scarily huge types
01:29:08 <Cale> Domain specific language
01:29:08 <Cheery> or wait, remembering
01:29:49 <Cheery> narain: I just read much about yampa
01:30:19 <Cale> But that still wouldn't encompass interactivity -- the arrows-based combinator libraries are pretty neat in that regard.
01:30:21 <narain> Cale: what would a scene modeling DSL buy you?
01:30:38 <narain> Cale: yes, i think interactivity is the hard part
01:30:55 <narain> Cheery: can you tell me about it?
01:31:36 <Cheery> narain: yampa is for modelling complex simulations, where one signal results with an another
01:31:54 <Cheery> the model is quite simple, it is a changing graph
01:32:10 <Cheery> and there's time distance between changes
01:32:17 <Cale> narain: well, you could manipulate scenes as data structures, possibly even by pattern matching, rather than having to send the right commands in the right order to get the right triangles on the screen :)
01:32:40 <Cale> (and then send those data structures all at once to a library call to draw them)
01:33:15 <Cale> At least, as a first approximation to how it might work.
01:33:41 <Cheery> yampa is excellent for processing input with such functions like quitEmitted or resizeEmitted
01:33:44 <narain> Cale: sounds like something any sane haskeller would do as the very first thing :) i wondered why you'd want a dsl rather than just using lists and other builtin datatypes
01:33:57 <Cale> You might have things like constructive solid geometry operations built in to the library.
01:34:09 <narain> Cheery: sounds interesting
01:34:50 <narain> Cale: ah, now you need a geometry processing library
01:35:07 <Cheery> Cale: I've thought about exactly same, but not yet knowing how to do it
01:35:10 <Cale> well, that's what it would halfway look like
01:36:20 <Cheery> and the idea drag me too deep to be of any help right now
01:36:21 <Cale> I wonder whether building meshes could usefully be done lazily based on visibility.
01:36:45 <Cale> Sounds like it might make a good topic for a thesis :)
01:36:55 <Cheery> Cale: it should know about frustum
01:37:01 <narain> Cale: :)
01:37:46 <narain> typically you have the mesh already, but it may be useful for e.g. implicit surfaces and other computationally constructed meshes
01:37:51 <Cale> right
01:37:59 <Cheery> oh, and of course about details
01:38:00 <Cale> and CSG operations
01:38:25 <Cheery> you don't want to halt into infinitely recursive meshes :)
01:38:29 <Cheery> while you actually want to see them
01:40:04 <narain> computing visibility is pretty hard though for arbitrary shapes
01:40:14 <Cale> It'd be neat to have a library which made you think that you were dealing with a raytracer, but it adaptively constructed meshes for you :)
01:40:21 <narain> which is why you just throw everything at the screen and let the z-buffer sort it out
01:40:29 <narain> Cale: hm?
01:40:34 <dons> re.
01:41:04 <narain> Cale: oh. you mean arbitrary precision shapes?
01:41:09 <Cale> yes
01:41:35 <narain> that would be fun
01:42:09 <Cale> Basically, have a scene graph like in a raytracer, but construct meshes in some intelligent way instead of raytracing.
01:42:46 <narain> and then render using opengl instead of raytracing? hmm
01:42:57 <Cale> yeah
01:43:14 <Cale> g'night!
01:43:16 <Cale> hehe
01:43:52 <quicksilver> I've written 'somewhat functional' opengl code a bit like that
01:44:03 <quicksilver> with a 'world object' containing the scene graph
01:44:18 <quicksilver> but it does "redo everything" each frame, which might not be efficient
01:44:26 <narain> people regularly use a scene graph in opengl anyway
01:44:49 <quicksilver> scene graph is a bit of a grand description for my 'a few lists of objects' to be honest :)
01:44:58 <dons> DRMacIver did you find the right lib? pretty much everyone uses gtk2hs now
01:46:27 <Cheery> I think I should learn write scenegraph
01:46:31 * narain wonders if he's the only one using GLUT
01:46:47 <Cheery> I guess it'd good idea to look at raytracers for that. .)
01:47:45 <earthy> sounds like 'generate octree from scene graph' 'order meshes in order in which ray walks octree'
01:48:07 <earthy> but I haven't played with 3d graphics since doom came out.
01:48:11 <narain> Cheery: scene graphs aren't anything non-trivial
01:49:31 <narain> a scene graph is just a tree with shapes at the leaves
01:50:09 <narain> and a spatial transformation at a node
01:50:34 <narain> think of "grouping" things in a drawing program so you can move/rotate/scale them together
01:51:47 <DRMacIver> dons: Yeah, I've been pointed to that since.
01:53:29 <dons> i like the funny 'we sold out' reddit logo the last couple of days. they're fun.
01:53:35 <narain> well, i guess the definition varies. you can have modifiers and complicated operations in your scene graph if you want, such as CSG operations
01:54:22 <Cheery> hmm, I guess it's joy to define a scene graph in haskell. :)
01:54:27 <narain> but then you can't render it directly with graphics hardware (unlike before)
01:54:35 <Cheery> I mean, it's automaticly lazy
01:54:45 <Cheery> you can attach computable information into it
01:54:55 <Cheery> it's perfect!
01:55:01 <Cheery> :D
01:55:12 <Cheery> now I really thing game developers are commonly stupid
01:55:15 <Cheery> *think
01:55:33 <Cheery> if they weren't they'd all use haskell already
01:55:54 <narain> Cheery: shifting computation from the graphics hardware to the cpu typically slows rendering down by orders of magnitude :p
01:56:14 <narain> why do you think people buy graphics cards?
01:56:38 <narain> now if only you could get haskell to run on the gpu...
01:56:58 <Cheery> well, you still build meshes and do other such stuff on cpu
01:57:06 <dons> hehe. lovely haskelish stream processors.
01:57:25 <dons> i want that gpu for my parallel maps and filters!
01:58:03 <narain> dons: yes! and very functional, too, since you can't write to arbitrary locations in memory
01:58:28 <narain> Cheery: and in the end you throw all your polygons at the gpu
01:58:53 <narain> you don't even move/rotate/scale them, you let the gpu do it
01:58:58 <petekaz> dons: got a 2 questions regarding your Shell programming blog. I've been rereading it and reading other docs out there to better understand monad transformers and such.  do you have a minute or two?
01:59:50 <mux> dons: that makes me think, you could have used the -n flag of sysctl(1) to avoid a bit of parsing
02:00:03 <mux> unless maybe OpenBSD doesn't have it?
02:00:05 <dons> petekaz: ok shoot.
02:00:19 <dons> mux, ah yes :)
02:00:24 <dons> -n   Suppress printing of the field name
02:00:39 <dons> i probably should have looked at the api
02:02:44 <petekaz> I'm unsure of the value of ErrorT in that example.  From what I understand, since Shell is an instance of MonadError and MonadIO, and it having its own definition of throwError, what's the point of ErrorT?  Couldn't shell just be a container for some IO action instead of an ErrorT monad?
02:03:35 <dons> yeah, it could be. I think it was to just illustrate ErrorT a bit
02:03:42 <dons> there are plenty of ways you can go with this idea
02:03:54 <dons> probably the most useful bit, imo, is the newtype for sudo access.
02:04:15 <dons> i.e. lifting domain info into the type system. that's a more valuable lesson. but now, at least, you know about ErrorT :)
02:05:17 * narain is trying to figure out how best to make an array whose size he doesn't know in advance in his C program :(
02:06:06 <dons> heh
02:06:08 <dons> malloc
02:06:33 <petekaz> So to make sure I understand correctly, there is no need for ErrorT because the Shell monad is an instance of MonadError and MonadIO.  However, if Shell were instead defined as 'type Shell a = ErrorT String IO a', then of course ErrorT would be of value, is this correct?
02:06:46 <narain> no, not even at runtime. not until i'm done putting stuff in the array do i know how many :(
02:07:00 <mux> then you surely don't want an array
02:07:08 <mux> you want a red-black tree, a hash table, an AVL...
02:07:10 <dons> narain: sounds like a list to me.
02:07:23 <mux> or just a list, but it sounds less cool :-)
02:07:24 <dons> unless you have particular complexity constraints on index.
02:07:36 <narain> hmm
02:07:36 <mux> will you need to lookup items in your collection?
02:07:47 <mux> are you aiming at O(1) access?
02:07:54 <DRMacIver> Well you could always make a list, find out how large it is then read the list into an array of the appropriate size and free the memory used by the list.
02:08:04 <narain> i shouldn't bother you guys with this anyway, this is #haskell
02:08:05 <petekaz> dons: re: the newtype for Priv, I haven't gotten that far as I've been stuck on the error handling part for quite some time.
02:08:10 <dons> petekaz: we deriving MonadError, don't we? and ErrorT is in MonadError, so there's no big advantage.
02:08:20 <dons> instance (Monad m, Error e) => MonadError e (ErrorT e m) where
02:08:20 <dons>     throwError l     = ErrorT $ return (Left l)
02:08:20 <dons>     m `catchError` h = ErrorT $ do
02:08:20 <dons>         a <- runErrorT m
02:08:20 <dons>         case a of
02:08:22 <dons>             Left  l -> runErrorT (h l)
02:08:25 <dons>             Right r -> return (Right r)
02:08:27 <dons> that relates the two.
02:08:28 <mux> ErrorT is sexy
02:08:39 <narain> but thanks for the suggestions :)
02:08:43 <dons> yeah, ErrorT is totally hot.
02:09:16 <petekaz> dons: So by defining your own instance of MonadError, you completely blow away any advantage of ErrorT, is that what you are saying?
02:09:29 <dons> hang on, let me check the code...
02:11:42 <dons> petekaz: the reason to use ErrorT comes from the use of Either. its the natural way to abstract over a series of tests for Either Left/Right. and yes, looks like we basically add ErrorT to MonadError. when we could just either derive MonadError, or use ErrorT directly
02:11:51 <dons> so there's a bit of extra wrapping there for no good reason, I think.
02:12:04 <dons> (other than to explore the various interfaces a bit)
02:12:17 <petekaz> Good.
02:13:04 <dons> so I'd probably keep newtype Shell a = Shell { runShell :: ErrorT String IO a }
02:13:13 <dons> and derive MonadError for Shell
02:13:14 <petekaz> I think I understand.  The Either part of ErrorT never really gets to flex its muscle because there will never be an error condition that calls ErrorT's throwError because your Shell monad overloads (sorry for the OO term) it.
02:13:17 <dons> then you avoid needing to write any instances
02:13:22 <dons> and you get throwError for Shell
02:13:32 <dons> petekaz: yeah, it overrides it
02:13:44 <dons> throwError = error . ("Shell failed: "++)
02:14:08 <dons> actually, that reminds me, the goal at the time might have been to add the custom "Shell failed" bit
02:14:09 <petekaz> Why newtype? Why not just 'type Shell a = ErrorT ...?
02:14:13 <dons> which means overriding the default deriving
02:14:31 <dons> petekaz: oh, so that Shell is distinct from any particular ErrorT out there : enforce abstraction
02:14:46 <dons> type aliases are evil ;-)
02:15:01 <dons> and that then leads to the obivous Priv monad
02:15:07 <dons> as (yet another) distinct type
02:15:53 <dons> i'm so glad someone actually paid attention to the article :)
02:15:53 <petekaz> I see.
02:15:55 <dons> you understand the benefits of newtype for new monads?
02:16:02 <olsner> dons: (reading your blog) why is modify not in the Priv monad like set? IMO, it'd be nicer to force main to do priv (modify ...) rather than having modify hiding the fact that it sudoes
02:16:35 <dons> olsner: yeah, that's another approach, lifting the priv further out
02:16:43 <dons> its probably better for a library api
02:16:54 <dons> since then you tag at the outermost level blocks of code that do sudo
02:17:02 <dons> at the time I was looking to minimise the 'critical' section
02:17:13 <dons> (that's usually the goal of privledge seperation in C code)
02:17:20 <petekaz> dons: one more question, above you I'd use newtype, and the following line said derive MonadError?  You mean you would implicitly derive it?  I.e. you would not still define your own instance for throwError right?  You would take advantage of ErrorT's Either.
02:17:46 <dons> yeah, you can derive MoandError for newtype, which just wraps ErrorT's MonadError instance
02:18:16 <dons> since ErrorT is in MonadError, and Shell is just a wrapped ErrorT, deriving MonadError gives you the (wrapped) version of ErrorT's MoandError instance
02:18:21 <petekaz> Oh .. I missed that point.  I see, so by using newtype you have to derive MonadError again.
02:18:21 <dons> saving a bit of boilerplate
02:18:33 <dons> yes
02:18:37 <dons> the 'type' would avoid this.
02:18:38 <petekaz> that happens magically right?
02:18:43 <dons> since then you directly have an ErrorT
02:18:45 <dons> it does.
02:19:05 <dons> (ghc extensions)
02:19:22 <dons> petekaz: i'll be talking more about newtype deriving for the next xmonad article actually
02:19:29 <dons> since we deriving MonadReader and MonadState for xmonad
02:19:36 <petekaz> But how does GHC know that you are wrapping ErrorT?  Your constructor may have had two parameters?
02:19:48 <petekaz> not just an ErrorT?
02:20:08 <olsner> aah, minimizing critical sections is probably good also.. interresting read, but the final result is much longer than the shell script was :P
02:20:19 <dons> petekaz: check the docs for newtype deriving for the limitations
02:20:42 <dons> olsner: yeah, but its about writing a general api for this kind of stuff, and tackling shell programming at a very high level
02:20:44 <mux> olsner: yes but it has a lot nicer properties
02:21:01 <dons> olsner: you'd write a library for it, then wrap up all your system tools, and program simple code (with nice properties) directly in haskell
02:21:01 <mux> olsner: and can be reused for other snippets of shell scripting
02:21:13 <dons> at the start of the entry is the direct translation
02:21:35 <dons> this is , I believe, much how linspire does their haskell wrrapping of system tools
02:22:10 <dons> you wrap a gunky unix tool in a nice api, with very clean properties, then program on that level
02:22:27 <dons> so haskell both abstracts over, and glues, legacy tools and apis
02:22:44 <dons> for example, treating sysctls as mutable variables, or embedding sudo in the type system
02:22:59 <olsner> indeed ;-)
02:23:06 <dons> (people spend real time doing that sudo transformation in C -- we get it for free from the type check)
02:23:13 <dons> the type checker.
02:23:45 <dons> its specifically not about replacing 2 line perl and shell with sudo-in-the-type-system ;)
02:23:53 <petekaz> dons: ok.  Thanks for the help.  In summary I learned that I should use newtype instead of plain old type which is the approach I was going to use based on some ErrorT tutorials I saw out there.  But with newtype and the whole making it an instance of the various classes (MonadReader, MonadIO, MonadError) seems to be the better approach nawadays (due to the deriving features of GHC) because it creates a new unique type.  Thanks again.
02:24:19 <dons> petekaz: yes, i would agree with that summary
02:24:25 <dons> and it is the approach i use now.
02:24:31 <petekaz> I feel great!
02:24:50 <dons> :D
02:25:14 <dons> here's the code i'm working on at the moment, http://darcs.haskell.org/~sjanssen/xmonad/XMonad.hs
02:25:28 <dons> you'll see newtype deriving for key monad classes there.
02:25:34 <petekaz> It took me FOREVER to understand that error handling section and the reasoning behind it (I realize it was not geared towards total newbies).  Many mornings spent riding the bike at the gym were spent pondering/reading those 2 pages of your blog!
02:25:49 <dons> oh wow!
02:26:00 <dons> sorry for inflicting that on you :)
02:26:13 <petekaz> I think it was a great learning experience
02:26:28 <mux> whenJust is great, I have added it to some code of mine and use it extensively
02:26:33 <dons> so the main thing was 'why use MonadError when there's an ErrorT just there'?
02:26:40 <narain> :t whenJust
02:26:41 <olsner> "We will implement a simple fullscreen window manager in the style of xmonad" - and here I thought I was reading about xmonad itself :P
02:26:44 <mux> it probably would fit nicely into Control.Monad
02:26:50 <dons> and the answer was 'because we use a newtype, and want to override the default ErrorT instance of throwError' ?
02:26:52 <lambdabot> Not in scope: `whenJust'
02:26:55 <mux> someone should writte a proposal for it
02:27:11 <dons> olsner: it doesn't support xinerama, that's the main difference
02:27:12 <petekaz> dons: Yes.  It seemed superfluous to me.
02:27:14 <dons> so its a bit simpler
02:27:47 <dons> petekaz: yeah, it would be, bar for the newtype. I should definitely talk about the difference between newtype and type then, in the xmonad newtype deriving article coming up
02:28:01 <petekaz> That would be great.
02:28:21 <petekaz> Ok ... now I'm off to the gym to read about the Priv part!
02:28:25 <mux> whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()
02:28:25 <mux> whenJust = flip (maybe (return ()))
02:28:40 <mux> here's my version, not tied to the X monad
02:28:45 <dons> you read my blog at the gym?
02:28:56 <earthy> hm. that's interesting. is there no way to get to archived articles on your blog, dons?
02:29:01 <petekaz> Seems much easier, although I had the same question that someone else asked earlier, why modify did not return a Priv type.
02:29:14 <dons> earthy: ah there is, the links aren't generated.
02:29:20 * earthy seems to recall haveing seen more than 4 articles. ;)
02:29:22 <dons> earthy: you want a collection of previous postings ?
02:29:25 <petekaz> dons: I printed it out.  Its quite gnarly now that its been sweat all over.
02:29:39 <earthy> well, at least a way to get at them would be nice. :)
02:29:45 <dons> earthy: right. they just disappear at the moment. (you can get them back by adding /2007 or /2007/02 to the url
02:29:52 <dons> earthy: i might switch to wordpress or some such
02:29:56 * earthy nods
02:30:01 <dons> whatever sigfpe or ekidd is using
02:30:11 <dons> the 200 line blosxom script is a bit minimal
02:31:11 <narain> sigfpe is on blogger i believe
02:31:36 <dons> on blogspot.com
02:31:58 <dons> basically, all my articles in darcs, and i'd like to keep publishing that way
02:32:10 <dons> so i need something that'll render pages from a simple directory layout
02:32:25 <narain> right, blogger == blogspot afaik, so i don't think you want that
02:32:36 <dons> all 51 posts i've apparently made.
02:32:38 <dons> crikey.
02:33:29 <dons> what's eric running, http://www.randomhacks.net/
02:33:30 <lambdabot> Title: Random Hacks
02:33:31 <mux> @where Safe
02:33:31 <lambdabot> I know nothing about safe.
02:33:36 <mux> @where libsafe
02:33:37 <lambdabot> I know nothing about libsafe.
02:33:42 <mux> hmm
02:33:46 <narain> dons: typo, it says so on a little button in the sidebar
02:33:47 <dons> typo.
02:33:50 <mux> @google neil mitchell safe library
02:33:52 <lambdabot> http://neilmitchell.blogspot.com/2006/11/library-idea-safe-library.html
02:33:53 <lambdabot> Title: Neil Mitchell's Haskell Blog: Library idea: the Safe library
02:34:01 <dons> yeah, i see. anyone else used typo?
02:34:07 <mux> @where+ safe http://neilmitchell.blogspot.com/2006/11/library-idea-safe-library.html
02:34:08 <lambdabot> Done.
02:34:08 <dons> mux, safe is on hackage, iirc
02:34:14 <mux> ok
02:34:26 <mux> I want to check if it has a toEnumMaybe function because I'm using one
02:34:47 <narain> dons: imho you could just put links to /2007, /2006 etc on the front page and be done with it :)
02:35:00 <mux> @where+ safe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Safe-0.1
02:35:01 <lambdabot> Done.
02:35:38 <dons> narain: yeah, that's the other option.
02:35:44 <mux> ah, it doesn't have toEnumMaybe
02:35:46 * dons tries this for now
02:37:44 <mux> that would be toEnumMay given the naming scheme though.
02:37:57 * mux invokes ndm
02:38:27 <Cheery> ah, first lesson done
02:39:14 <Cheery> @hoogle whenJust
02:39:15 <lambdabot> No matches found
02:39:29 <Cheery> mux: I think I'll replicate your whenJust ;)
02:39:34 <Cheery> it is nice
02:39:47 <narain> :t flip . maybe . return $ ()
02:39:50 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> (a -> m ()) -> m ()
02:40:35 <mux> Cheery: be my guest :-)
02:41:08 <narain> :t maybe
02:41:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:41:38 <Cheery> so it's: whenJust (return ())
02:41:47 <Cheery> ugh
02:41:58 <Cheery> whenJust = maybe $ return ()
02:42:33 <mux> you miss a flip here, unless you want to use it that way
02:42:42 <mux> I like how I defined it so that I can write:
02:42:53 <mux> whenJust (someMaybe)$ \x -> do
02:42:54 <mux>   ...
02:43:42 <Cheery> mux: of, there was a flip
02:44:15 <Cheery> yes, I think I use the form: whenJust = flip . maybe . return $ ()
02:47:19 <therp> anyone familiar with m4 in here?
02:47:21 <mux> btw, this code makes LB go mad
02:47:35 <mux> @pl whenJust = flip (maybe (return ()))
02:47:36 <lambdabot> whenJust = flip (maybe return)
02:47:49 <mux> which isn't equivalent
02:48:13 <mux> it seems like it didn't get the () after the return were the unit type and not syntactic parentheses
02:48:45 <Cheery> hmm
02:48:51 <Cheery> :t flip(maybe return)
02:48:53 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Maybe a1 -> (a1 -> a -> m a) -> a -> m a
02:49:26 <quicksilver> mux: @pl has its own parser, it doesn't use the haskell one
02:49:37 <quicksilver> mux: I believe it has a couple of infelicities
02:51:42 <Cheery> Hmm, I should yet tune this so that it goes inactive when thing is minimized
02:51:50 <mux> @pl whenJust = flip (maybe (return x))
02:51:50 <lambdabot> whenJust = flip (maybe (return x))
02:52:04 <Cheery> ie. no rendering when minimized
02:52:30 <Cheery> thought, the mainloop starts being such stuff which should be better supplied from the Ignite
02:52:41 <mux> as expected, giving it some identifier in place of () makes it correctly parse it
02:53:25 <Cheery> you see it's a common thing in every example, and starts being quite big
02:53:35 <dmwit> ?pl whenJust x = flip (maybe (return x))
02:53:36 <lambdabot> whenJust = flip . maybe . return
02:53:52 <mux> not the same
02:53:59 <dmwit> right
02:54:05 <dmwit> I understand.
02:54:13 <dons> earthy: i've added side bars with previous posts. thanks for reminding me about that
02:54:24 <mux> I wish there was a nicer way to write it, I'm not fond of flip . maybe . return $ () myself
02:54:33 <dons>  or, actually, creating enough pressure for me to fix it ;-)
02:54:49 <dmwit> IMO flip . maybe $ return () is (slightly) better.
02:55:04 <mux> hmm, right
02:55:07 <dmwit> In this case, I feel like "return ()" is actually the value you are applying flip . maybe to.
02:55:46 <mux> yes, that's quite nice
02:56:09 <mux> I'll probably follow your suggestion
02:59:02 <mnislaih> xerox: ping
03:07:18 <Cheery> it seems like somebody has forgotten to export Focus from hSDL
03:07:37 <Cheery> Focus and it's parameters
03:08:26 <Cheery> I can see MouseFocus, InputFocus and ApplicationFocus, but I can't use them. :D
03:10:23 <dmwit> ?sp existence
03:10:23 <lambdabot> Maybe you meant: spell spell-all . ask bf ft id map msg pl rc slap src v wn
03:10:28 <dmwit> ?spell existence
03:12:54 <ski> @pl x ()
03:12:54 <lambdabot> x
03:12:58 <ski> @pl ()
03:12:59 <lambdabot> ()
03:13:00 <ski> @pl () ()
03:13:01 <lambdabot> ()
03:22:39 <Cheery> the ApplicationFocus is not exported from Graphics.UI.SDL.Events
03:22:58 <Cheery> do you know whether I could still get it out from it?
03:38:10 <dcoutts> DRMacIver: you were having trouble with the Gtk2Hs download?
03:41:52 <DRMacIver> dcoutts: gzip complained at me when I tried to decompress the source version from the downloads page.
03:44:12 <mux> DRMacIver: did you right-click and selected 'save as' on the gtk2hs-0.9.11.tar.gz link?
03:44:23 <mux> if you did so, you shouldn't have, this is a link to a sourceforge download page
03:44:33 <mux> run 'file gtk2hs-0.9.11.tar.gz'
03:44:38 <DRMacIver> Oh, ha
03:44:44 <mux> the type it gives should be a good hint
03:44:46 <DRMacIver> I may well have done. I don't remember.
03:45:02 * DRMacIver looks vaguely embarassed.
03:45:52 <mux> that's just a guess :)
03:46:10 <SamB_XP_> I think getright is smart enough to actually download the *file* ;-)
03:47:16 <DRMacIver> mux: It sounds plausible. I've done it before.
03:47:36 <mux> getright? windows? ugh! ;-)
03:47:46 <SamB_XP_> nevertheless!
03:48:00 <dcoutts> DRMacIver: other thing to check if you got the right download is what the file size and md5sum is
03:48:08 <SamB_XP_> hey I think I bought it when I was 12 or something
03:48:37 <DRMacIver> dcoutts: I'm not at the computer I downloaded it on at the moment. I'll check later. This does sound like a rather plausible explanation though...
03:48:44 <dcoutts> ok
03:48:56 <DRMacIver> My only defence is that I had only had one mug of coffee at the time and was still waking up. :)
03:52:03 <malcolmw> dcoutts: in your recent changes to Cabal to fix a Windows problem, you introduced a dependency on System.Process into Distribution.Simple.Utils
03:52:20 <dcoutts> malcolmw: yes
03:52:35 <malcolmw> unfortunately, System.Process is non-portable
03:52:47 <dcoutts> malcolmw: since it cannot sanely be done with System.Cmd
03:52:54 <dcoutts> since that does not allow redirecting output
03:53:26 <dcoutts> and callign the command interpreter with "foo.exe > output.txt" is a recipe for all kinds of quoting problems
03:53:47 <dcoutts> in particualr it does not work if foo.exe actually has a space in the name
03:54:15 <dcoutts> malcolmw: So I avoided using runInteractiveProcess because I heard it was not portable to nhc
03:54:21 <malcolmw> dcoutts: at any rate, even though System.Process claims to be portable in the haddock header, it imports GHC.IOBase and GHC.Handle, which gives you some idea of how much its portability has been tested :-)
03:54:24 <dcoutts> or hugs, due to requiring concunrrency
03:55:30 <dcoutts> malcolmw: do you think we can get an implementation of runProcess ?
03:55:45 <dcoutts> malcolmw: I assume runCommand is not a problem for nhc, it looks simple enough
03:56:42 <malcolmw> dcoutts: it would be nice if someone could clean up the ghc-specificness of things like System.Posix.* and System.Process, so it was truly portable
03:56:56 <dcoutts> malcolmw: you can see my dilemma, windows or nhc  (and I had hoped it might work on nhc)
03:57:14 <dcoutts> malcolmw: yes that would be great, and openTempFile
03:57:30 <malcolmw> dcoutts: I don't think there will be any problems implementing it for nhc98 - it is just that there is a tangled mass of dependencies that is hard to pick apart.
03:57:41 <dcoutts> aye
03:58:21 <dcoutts> malcolmw: well do you think the time is best spent doing that or adding #ifdef workarounds to cabal?
03:58:28 <malcolmw> dcoutts: no technical problems at any rate, just the ordinary difficulties of discovering where things are, and what they are supposed to do
03:58:31 <mdmkolbe|work> on the hackage wiki is there a form of the GhcFile macro that allows one to specify the presentation of the text? e.g. I want to link to compiler/HsVersions.h but I want the text to just show the HsVersion.h part
03:59:08 <malcolmw> dcoutts: making parts of base more portable is a way better use of the time than putting hacky workarounds into Cabal
03:59:16 <dcoutts> malcolmw: I agree
04:00:29 <malcolmw> dcoutts: if the Posix/Process stuff could be done in pure Haskell'98 + FFI that would be ideal.
04:01:16 <dcoutts> malcolmw: I expect most of it could, it was written pre-ffi wasn't it?
04:01:59 <dcoutts> malcolmw: to actually sanely use runInteractiveCommand requires threads I think, but implementing it doesn't.
04:02:45 <dcoutts> malcolmw: I think we should have the Handle impl be shared and only call down to per-implmentation bits for block gets and puts
04:02:54 <malcolmw> dcoutts: System.Process claims a copyright of 2004, but then, the interesting parts of the implementation aren't in there, but under GHC.*
04:14:58 <hpaste>  mdmkolbe|work pasted "Why doesn't STRICT1(f) follow the pattern?" at http://hpaste.org/1692
04:15:33 <mdmkolbe|work> Is that a bug, or something more subtle going on?
04:16:25 <dcoutts> yay after 6 years, Gtk+'s text rendering can finally do justified text:
04:16:26 <dcoutts> http://mces.blogspot.com/2007/05/justified-text-with-pango.html
04:16:26 <cperfumo> i compiled GHC 6.6.1 for ia64 but i can't use the -N<number_of_cores> RTS option even though my programs are compiled with -threaded option. Any idea?
04:17:00 <eumenides> is O'Haskell still... usable?
04:17:36 <mdmkolbe|work> cperfumo: you have to use '+RTS -N<cores> -RTS'
04:18:47 <mdmkolbe|work> cperfumo: +RTS means the following options should be passed to the RunTime System, -RTS means the following options are normal/not to be passed to the Runtime System
04:20:31 <dmwit> Heh, "six-year-old bugzilla entry".
04:22:41 <cperfumo> mdmkolbe|work: so far I know. the problem is that when I write "miProgram +RTS -N4 -RTS", it complains that -N is not a valid RTS option
04:24:04 <mdmkolbe|work> cperfumo: have you tried cleaning the .o and .hi files?
04:29:39 <cperfumo> mdmkolbe|work: not the .hi. The .o ones yes
04:29:46 <cperfumo> can it be the problem?
04:29:51 <cperfumo> what a .hi is?
04:30:44 <jmg_> a .hi file describes the interface of a haskell module
04:32:07 <jmg_> plus some internal information needed to do cross module inlining and probably more technical stuff
04:33:17 <mdmkolbe|work> cperfumo: could you paste the compilation line (I assume you're testing on one file) and your calling line?
04:34:18 * mdmkolbe|work has to go to lunch and will be back on 30-60min
04:34:39 <mdmkolbe|work> cperfumo: sorry to run out on you like this (but my co-workers are calling me)
04:38:01 <ivanm> mdmkolbe|work: pfft, what are co-workers compared to the joys of using haskell? nothing, I tell you, nothing! :p
04:42:12 <Cheery> Hmm
04:43:12 <ivanm> you're not sounding too cheery, Cheery :p
04:44:10 <Cheery> That's because it seems I should write my scene graph and put in FRP before doing anything else :D
04:44:57 <Cheery> after that, the examples would get smaller and smaller and smaller...
04:46:36 <Cheery> And it'd be more like game programming tutorial more than nehe tutorial after that
04:46:57 <Cheery> and a language...
04:47:15 * ivanm has no idea what Cheery is talking about...
04:47:25 <ivanm> was I meant to?
04:48:37 <Cheery> nop, I'm rewriting nehe -tutorials for haskell
04:49:15 <Cheery> in a way that no unnecessary code duplicated
04:49:57 <Cheery> It'd be like a game development language which's internals can be learned
05:12:00 <therp> hmm I didn't expect darcs.haskell.org to host partial darcs repos, but /ghc-6.6/testsuite is obviously one..
05:13:54 <therp> still, this feels kinda wrong..
05:15:43 <Cheery> Does haskell have vector math module?
05:19:53 * mdmkolbe|work is back
05:30:49 <int-e> therp: http://darcs.haskell.org/testsuite is a complete repository; the partial one is for the release branch only.
05:30:52 <lambdabot> Title: Index of /testsuite
05:33:03 <kuribas> therp: how is liskell going?
05:33:34 <DRMacIver> And when will XMLiskell be coming out? :)
05:33:42 <therp> kuribas: I'm preparing a new website http://liskell.org
05:33:44 <lambdabot> Title: About Liskell
05:33:54 <therp> kuribas: I'm just pulling all the darcs repos to darcs.liskell.org
05:34:09 <therp> kuribas: I hope to release the ghc-6.6(.1) based liskell version in the next 2 days
05:34:20 <therp> kuribas: rediffing from HEAD against ghc-6.6 was a real pain
05:34:52 <therp> the website is partially broken, I apologize
05:35:31 <therp> writing html files in m4 is nicer than expected.
05:36:26 <kuribas> ok, cool.
05:38:40 <kuribas> therp: Typed macro's, that would be a nice area for research :)
05:39:13 <therp> kuribas: I better get regular macros going first :)
05:39:42 <therp> kuribas: my next little scheme is to implement a variant of http://lambda-the-ultimate.org/node/2003 in Liskell meta-programming
05:39:44 <lambdabot> Title: Total Functional Programming | Lambda the Ultimate
05:40:15 <therp> kuribas: basically this would become a static verification tool, also the partiality monad sounds interesting (mentioned in the comments)
05:40:40 <therp> kuribas: maybe after this exercise I have enough experience to tackle static verification of macros
05:41:21 <nominolo> therp: you might want to turn off the text-align:justify; css, for better readability (just a suggestion)
05:42:20 <therp> nominolo: the template was flush left-ragged right, I turned text-align on because I don't like ragged right
05:42:45 <therp> the german speaking world is used to justified text.
05:44:07 <nominolo> really?  i think it's always annoyingly less readable.  anyways.  i think "When .. then .." should rather be "If .. then ...".  I think that's a common mistake by German-speaking people
05:44:13 <therp> I authored an article once for Linux Magazine, and was surprised as the english translator sent me a ragged right version, of a text which was typset justified in the german version of linux magazin
05:44:38 <nominolo> what is "ragged right"?
05:44:46 <Wild_Cat> Justified text is the norm here in France too.
05:44:52 <therp> corrected thanks
05:45:31 <quicksilver> It's the norm in print here in the UK. Of course it helps if you have a working justification like TeXs rather than a broken one like Word's
05:46:04 <therp> nominolo: http://desktoppub.about.com/cs/typelayout/a/justifyleft.htm - there is a little graphic explaining that
05:46:05 <lambdabot> Title: Ragged Right vs Justified Text Alignment - Rules of Desktop Publishing on Text A ...
05:46:11 <Wild_Cat> I don't really think there are actually magazine or book publishers who do use Word for typesetting.
05:46:26 <Wild_Cat> (and if they do, then what the hell, they deserve all the crap they get for doing so)
05:46:39 <therp> nominolo: if/then when/then corrected thanks
05:47:00 <araujo> morning
05:47:09 <tuukkah> how would i write an IO action that takes forever to complete but takes O(1) cpu time?
05:48:04 <dcoutts_> tuukkah: sleep (2^big)
05:48:11 <nominolo> therp: ok, stick with justified.  but maybe you can increase line-spacing?  it seems kind of pushed together.
05:50:31 <chessguy> 'morning, haskellers
05:50:51 <DRMacIver> haskellites sounds better.
05:51:18 <therp> nominolo: better now?
05:51:35 <quicksilver> DRMacIver: haskellistas
05:52:42 <Wild_Cat> Indian cooks.
05:52:43 <tuukkah> dcoutts_, threadDelay is more what i was looking for so other threads don't hang
05:52:56 <dcoutts_> tuukkah: right, yes.
05:52:57 <nominolo> therp: yep
05:53:03 <dcoutts_> @hoogle threadDelay
05:53:03 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
05:53:42 <nominolo> therp: ironically the designer's site didn't work with scripts turned off (which is my default)
05:54:37 <therp> nominolo: does mine? I didn't check. I usually grab a nice template from oswd.org
05:55:01 <nominolo> therp: it works fine.
05:55:34 <nominolo> therp: actually, on macos serif fonts work better than sans-serif.  but i think you cannot rely on this in general :/
05:55:35 <tuukkah> dcoutts, with that one you can sleep only half an hour, that's far from forever. and a loop wouldn't be O(1) =)
05:57:12 <mdmkolbe|work> where do I find the vcat function?
05:57:15 <nominolo> tuukkah: just block on some event that never occurs
05:57:40 <tuukkah> nominolo, does Haskell have events ?-)
05:57:49 <tuukkah> perhaps with mvar...
05:58:02 <nominolo> tuukkah: use STM
05:58:08 <nominolo> and put in a guard
05:59:16 <koala_man> what's that tiny theorem prover that has been mentioned here?
05:59:23 <nominolo> atomically (check 1==0)
05:59:40 <nominolo> @djinn a -> (a->b)
05:59:41 <lambdabot> -- f cannot be realized.
05:59:44 <nominolo> @djinn a -> (a->b) -> b
05:59:45 <lambdabot> f a b = b a
05:59:51 <nominolo> this one?
06:00:27 <koala_man> no, some like 130 character thing for determining just if it's true
06:00:31 <malcolmw> mdmkolbe|work: try hoogle
06:00:37 <therp> nominolo: my own site uses serif fonts -- http://clemens.endorphin.org/liskell partially the same text
06:00:41 <lambdabot> Title: Liskell - clemens.endorphin.org
06:00:41 <malcolmw> @hoogle vcat
06:00:42 <lambdabot> Text.PrettyPrint.HughesPJ.vcat :: [Doc] -> Doc
06:01:11 <mdmkolbe|work> thx malcolmw
06:01:37 <nominolo> therp: yes, looks better to me.  although your disclaimer on the right shows the evil of text-align:justify ;)
06:02:29 <therp> nominolo: yes, text-align: justify needs love to look good. too much white space between most words.. it's ok for tex, where you have proper hyphenation support.. but not in html
06:02:53 <nominolo> therp: yep
06:04:06 <earthy> damn trippy... a usecase for unsafeCoerce
06:06:34 <quicksilver> therp: depends on the average word length in your prose, as well as the column width and point size :)
06:07:31 <earthy> @hoogle unsafeCoerce
06:07:32 <lambdabot> No matches found
06:07:37 <earthy> @hoogle unsafeCoerce#
06:07:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
06:07:42 <earthy> sigh.
06:07:51 <dcoutts_> @docs Control.Concurrent
06:07:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
06:08:06 <malcolmw> earthy: Unsafe.Coerce.unsafecoerce :: a -> b
06:08:08 <tuukkah> nominolo, that's cool, how does check work?
06:08:17 <earthy> malcolmw: is it there in ghc 6.6?
06:08:25 <malcolmw> earthy: no, only in HEAD
06:08:34 <earthy> right.
06:08:59 <earthy> okay, then to hell with the laziness and streaming behaviour.
06:09:01 <malcolmw> earthy: in ghc-6.6., it is called unsafeCoerce#, and I can't remember where it lives
06:09:49 <earthy> It'd be an exceedingly nasty hackish way of doing this anyway
06:09:53 <tuukkah> in the STM article, check False = retry
06:10:49 <earthy> (what I'd really like is a way to check that 2 existential types are equal...)
06:11:08 <dcoutts_> tuukkah: file a bug, suggest it be increased to Int64 microseconds
06:11:14 <earthy> ofcourse, that brings me in highly uncharted waters. :|
06:14:09 <DRMacIver> How does unsafeCoerce actually work?
06:14:17 <tuukkah> dcoutts_, I don't want my impracticalities to harm others. can we seriously say it's a bug?
06:14:33 <earthy> DRMacIver: basically it tells the type checker to stuff it
06:14:43 <earthy> (it's id, but with a 'useful' type. ;))
06:14:53 <nominolo> tuukkah: ok, you'd probably need a variable or something there
06:14:55 <DRMacIver> Yeah, but I mean, I don't see circumstances in which it could apply.
06:14:58 <dcoutts_> tuukkah: well, 35 minutes is pretty short
06:15:07 <int-e> DRMacIver: the obvious one is newtypes
06:15:11 <DRMacIver> Oh, right.
06:15:22 <DRMacIver> I'd forgotten about those. :)
06:15:25 <DRMacIver> Anywhere else?
06:15:28 <earthy> read also the SYB papers
06:15:37 <int-e> DRMacIver: and then there is code (like Data.Dynamic) that coerces stuff to forall a.a and back to the original type
06:15:40 <DRMacIver> (I guess e.g. lits of new type)
06:15:46 <DRMacIver> lists
06:16:02 <earthy> well, I have two things of type forall a. a  and I merely want to check that the actual a's are the same
06:16:17 <malcolmw> earthy: I don't think you can check that
06:16:17 <earthy> well, not even that, I know they are by construction, but I can't convice the compiler of that
06:16:31 <DRMacIver> What will happen if you use unsafeCoerce in cases where it's genuinely unsafe?
06:16:40 <earthy> malcolmw: you could if you had  forall a. Typeble a => a
06:16:43 <earthy> Typable
06:16:51 <int-e> DRMacIver: you can crash the program
06:17:01 <int-e> it *is* unsafe.
06:17:11 <earthy> (ofcourse, I don't have that class constraint...)
06:17:21 <malcolmw> there are very few things you can actually do with a value of type (forall a . a)
06:17:26 <DRMacIver> int-e: Ok, but that's fine. Can you *not* crash the program and instead continue with bizarre and undefined results?
06:17:43 <dcoutts_> malcolmw: you can force it /  inspect to see if it's _|_
06:17:49 <int-e> DRMacIver: yes. I think 'undefined' in the bad C standard sense applies to the situation.
06:17:57 <earthy> well, the *actual* values are     forall a . Constructor (a -> val) a
06:17:58 <int-e> DRMacIver: i.e. anything can happen.
06:18:20 <malcolmw> dcoutts_: inspecting something to see if it is _|_ lies outside the pure functional world
06:18:20 <DRMacIver> Ouch.
06:18:27 <tuukkah> nominolo, both newEmptyMVar >>= takeMVar and atomically $ check $ 0 == 1 seem to work. i haven't studied STM so i can't guess how the latter is implemented. reading up now
06:18:28 <earthy> (even worse,   forall a . Constructor (a -> val) (SomeDataTypeOver a)
06:18:41 <DRMacIver> I guess that's what you get for using functions labelled as unsafe. :)
06:18:49 <malcolmw> earthy: well that type makes a lot more sense
06:18:54 <dcoutts_> malcolmw: well I really just mean applying seq to it
06:18:57 <earthy> what I want to do is walk over the 'SomeDataTypeOver'
06:19:35 <nominolo> tuukkah: well, it's non-trivial.  so i couldn't tell off of my head anyways ..
06:19:40 <int-e> DRMacIver: well the label is there for a reason. (btw unsafePerformIO can be used to implement unsafeCoerce so it's at least as unsafe)
06:19:53 <malcolmw> dcoutts_: didn't someone demonstrate on teh haskell-prime list that using `seq` on a (forall a . a) value does not in fact evaluate it?
06:20:19 <dcoutts_> malcolmw: I wasn't quite clear about that. He seemed to be suggesting it was type incorrect.
06:20:51 <dcoutts_> I don't see why it shouldn't evaluate it
06:20:54 <tuukkah> nominolo, the article says the implementation would sleep until a variable that has been read changes. with no variables read, i guess it trivially sleeps forever :-)
06:21:13 <nominolo> tuukkah: on a microkernel i used to work with you just wait for the nil-thread.  and if you just want to sleep, you wait on the nil-thread with some timeout.
06:21:19 <nominolo> tuukkah: yeah, same idea :)
06:21:22 <malcolmw> dcoutts_: no hold on, I got it wrong. it was a value of type (forall a . Eq a => a) which it of course tottaly different :-)
06:21:36 <dcoutts_> malcolmw: heh yeah.
06:21:48 <malcolmw> dcoutts_: the difference being that the value is packaged with its dictionary
06:21:53 <dcoutts_> malcolmw: so that one somehow has to carry a dictionary
06:22:00 <dcoutts_> it;s not clear how that works though
06:22:20 <dcoutts_> since the thing doesn't look like it's a data constructor
06:22:31 <nominolo> @djinn modusPonens :: (a -> b) -> a -> b
06:22:31 <lambdabot> Cannot parse command
06:22:47 <nominolo> boo!
06:23:10 <dcoutts_> malcolmw: I can see that if it were implemented as a pair or something then forcing it would not force the value we're interested in
06:23:48 <earthy> okay. that got that type shit licked
06:25:17 <malcolmw> dcoutts_: exactly, although the box around it is not very visible to the programmer
06:25:21 <mauke> @djinn (a->b)->a->b
06:25:22 <lambdabot> f a = a
06:25:57 <dcoutts_> malcolmw: right, and that's what would make the seq behaviour unexpected, since that extra box is not visible to the programmer
06:26:26 <quicksilver> dcoutts_: nor is it a consequence of the semantics of the language (dictionary passing is not the only way to implement classes)
06:26:34 <dcoutts_> quicksilver: indeed
06:26:52 <quicksilver> and seq ought to have, as far as possible, an implementation-independent meaning
06:26:57 <dcoutts_> yes
06:26:59 <quicksilver> although that is an odd thing to ask, for it
06:30:31 <dcoutts_> @tell bringert Congratulations!
06:30:31 <lambdabot> Consider it noted.
06:34:41 <nominolo> dcoutts_: bday?
06:34:59 <dcoutts_> nominolo: can't say. Ask bringert :-)
06:35:34 <nominolo> @seen bringert
06:35:35 <lambdabot> I saw bringert leaving #ghc and #haskell 1d 4h 58m 33s ago, and .
06:36:47 <nominolo> dcoutts_: i was just curious what he got congrats for ..
06:36:55 <ndm> i have a reasonable idea
06:37:02 <dcoutts_> nominolo: I know you are curious :-)
06:37:18 <ndm> do you have any further details dcoutts_ - i.e. the normal ones
06:37:32 <nominolo> dcoutts_: isn't that a requirement for wannabe-researchers? :)
06:37:40 <dcoutts_> :-)
06:44:02 * dcoutts_ notes that a Cabal-1.1.6.2 tarball is now available
06:45:16 * ndm wonders if this fixes all the windows bugs
06:45:20 <nominolo> oh, dcoutts_, i think i know :)
06:45:37 <dcoutts_> ndm: no that's only in 1.1.7
06:46:14 <dcoutts_> ndm: if we're all confident that we've fixed all the windows bugs we could to another release on the 1.1.6.x branch I suppose
06:46:29 <ndm> dcoutts_, i doubt i'll get off HEAD cabal for ages yet
06:46:42 <shapr> nominolo: w00!
06:46:55 <shapr> er, dcoutts_: w00!
06:46:59 <dcoutts_> ndm: we can also do a proper release of 1.1.8 some time you know
06:47:04 <shapr> @tell bringert congrats!
06:47:05 <lambdabot> Consider it noted.
06:47:15 <dcoutts_> ndm: especially if you tell me if it works on windows :-)
06:47:42 <shapr> Good morning #haskell!
06:47:42 <ivanm> hmmm..... I have a program that generates a list of items, filters them and then prints the resulting ones to a file
06:47:46 <ivanm> hey shapr
06:47:53 <shapr> hiya ivanm!
06:48:06 <ndm> dcoutts_, you seen to have wiped out a few bugs at least
06:48:15 <dcoutts_> good good
06:48:15 <ivanm> this program takes ~ 3 hrs
06:48:30 <dcoutts_> ndm: though malcolmw tells me my windows fixes have broken nhc
06:48:33 <dcoutts_> :-(
06:48:48 <ndm> dcoutts_, always finghting against things :)
06:48:53 <dcoutts_> ndm: lack of Control.Process
06:48:57 <ivanm> but when I instead go and do a foldl' on that list so that I can test how many fulfill several criteria, it seems to get stuck part of the way through (it was running all day and didn't even go half way) :(
06:49:01 <ivanm> any ideas why?
06:49:46 <dcoutts_> time to test cabal-install methinks
06:50:11 <shapr> dcoutts_: I responded to ncm's response to your lwn.net post, but he only responded to the slightly-flamey Common Lisp reply. I think he only wants to fight.
06:50:23 <dcoutts_> heh oh well
06:52:44 <shapr> ivanm: Have you profiled the successful 3 hour run?
06:52:59 <ivanm> shapr: *nod*
06:53:16 <ivanm> and the major cost centres are pretty much what I expect...
06:53:25 <ivanm> though 25% is taken up by that filtering I'm no longer doing
06:54:11 <shapr> Do you have it printing the results to a file as soon as it gets one? Or does it print them all at the end?
06:54:17 <ivanm> instead, I'm doing a foldl' through the list of items, and comparing each item to a list of predicates, and accumulating the number that fulfill each predicate as I go along
06:54:25 <ivanm> shapr: as soon as it gets one...
06:54:41 <ivanm> so for this current version, it goes up to w = 11... but it should be going up to w = 25
06:54:50 <ivanm> works for smaller runs, just not for the big run
06:58:37 <ivanm> the only main difference I can think of is that in the original, I was using =<< (for now, anyway) to act as concat . map
06:59:32 <ivanm> but in this one, I'm just mapping the construction function, then mapping the foldl'-based operator on each resulting list, and writing the results of each of these to file as soon as I get them
07:00:36 <ndm> dcoutts_ - turns out i only beat GHC for small content streams, so it appears GHC's reading from stdin is more efficient as the buffer gets larger
07:00:58 <dcoutts_> ndm: that'd make sense, it's using at least 4k buffers
07:01:16 <shapr> ivanm: Maybe =<< was forcing some strictness?
07:01:19 <dcoutts_> Igloo: any idea what is going on with "cabal-builder" and "cabal-make" repos on darcs.h.o ? they're both nearly empty.
07:01:28 <ndm> dcoutts_ - but its still being beaten by C getchar's
07:01:31 <ivanm> shapr: I suppose so...
07:02:05 <ivanm> shapr: what could I do then? use $! to force some strictness?
07:02:13 <dcoutts_> ndm: hmm, I still find that surprising. When profiling bytestring we found getchar to be very slow.
07:02:17 * ivanm didn't know that =<< had anything to do with strictness...
07:02:19 <Igloo> dcoutts_: They're just the contents of the cabal-builder/ and cabal-make/ directories that used to be in the Cabal repo
07:02:30 <ndm> dcoutts_ it may be a windows vs linux thing
07:02:33 <quicksilver> ivanm: depends on the monad :)
07:02:37 <dcoutts_> Igloo: so why do they contain nearly no source code?
07:02:47 <ivanm> quicksilver: list
07:02:49 <tcr> How do you write a test for three cases (x > y, x < y, x == y) idiomatically in Haskell? if, else if, else, or case with guards?
07:02:58 <dcoutts_> Igloo: cabal-make has essentially nothing in the repo
07:03:01 <Igloo> dcoutts_: What code is missing from them?
07:03:02 <ndm> tcr: compare
07:03:04 <mauke> case x `compare` y of :-)
07:03:06 <ivanm> tcr: I'd use guards...
07:03:11 <dcoutts_> Igloo: it has no source code!
07:03:11 <ivanm> or that
07:03:16 <shapr> ivanm: Well, monads force sequencing, so =<< may have forced ordering more than (concat . map) ?
07:03:17 <dcoutts_> http://darcs.haskell.org/cabal-make/
07:03:18 <lambdabot> Title: Index of /cabal-make
07:03:28 <ivanm> shapr: *nod*
07:03:38 <dcoutts_> Igloo: it's got a changes and a scrap of a makefile but nothing else
07:03:41 <ivanm> I'll replace =<< with concat.map and give that a try, see what effect it has
07:03:44 <Igloo> dcoutts_: Oh, sorry, cabal-make is nothing to do with me
07:03:53 <Igloo> dcoutts_: cabal-{builder,install,setup,upload} are the packages that I split off
07:04:07 <dcoutts_> Igloo: ah ok, where is cabal-setup?
07:04:08 <ivanm> because I later want to split it so that I have each resultant sub-list being written to a separate file, rather than one big one like I do know
07:04:25 <Igloo> dcoutts_: In packages/
07:04:40 <dcoutts_> Igloo: ok, the others are on the top level :-)
07:04:54 <malcolmw> dcoutts_: cabal-make is supposed to be just a Makefile - contributed by Conal Elliott
07:04:56 <Igloo> dcoutts_: Right, the ones that could plausibly become extralibs are in packages/
07:04:56 <shapr> Which package downloads things from Hackage?
07:04:57 <dcoutts_> Igloo: also, it looks to me like cabal-builder is defunct, does it look that way to you?
07:05:01 <tcr> Nice, thanks.
07:05:13 <Igloo> dcoutts_: I've never looked at it
07:05:25 <dcoutts_> Igloo: cabal isn't in packages you'll note, nor is cabal-branches/cabal-1.1.6
07:05:45 <dcoutts_> shapr: cabal-install I think. I'm trying to clear up all this confusion :-)
07:05:46 <Igloo> dcoutts_: Yes it is, albeit as a symlink
07:05:54 <dcoutts_> malcolmw: oh hmm ok/
07:06:08 <shapr> dcoutts_: Yay, thanks for doing the research for the rest of us!
07:06:26 <dcoutts_> Igloo: right, but it means I can find all the cabal stuff in one place! :-)
07:07:20 <ndm> malcolmw: can you set up your machine as a Yhc buildbot?
07:07:33 <ndm> malcolmw: andrews plan is to remotely and automatically fix everything up that way
07:07:35 <malcolmw> ndm: buildbot for what?
07:07:41 <ndm> malcolmw: Yhc
07:07:53 <dcoutts_> Igloo: I think we need an archive dir or something where defuct packages go to die, so we can clear out the top level dir
07:08:06 <shapr> njbartlett: nice blog
07:08:08 <dcoutts_> Igloo: but not delete them just yet, give people time to complain
07:08:09 <ivanm> @hoogle ($!)
07:08:10 <lambdabot> Did you mean: ($!)
07:08:10 <lambdabot> Prelude.undefined :: a
07:08:10 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:08:16 <malcolmw> ndm: the problem is that I can't see unusual http ports from my machine
07:08:16 <ndm> @hoogle $!
07:08:17 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
07:08:56 <njbartlett> shapr: thanks :-)
07:08:56 <ivanm> thanks ndm
07:09:22 <ndm> malcolmw: how come?
07:09:40 <malcolmw> ndm: user-administered machines are firewalled from lots of stuff
07:09:48 <Igloo> dcoutts_: My plan is to fix this as we move things to the community server
07:09:54 <dcoutts_> Igloo: do you think we can do that? I see about a dozen thing on the top level of darcs.h.o that need to go into an archive/ dir to die quietly
07:10:11 <ndm> malcolmw: that sucks muchly, so i guess you can't even see the buildbot reports?
07:10:11 <ivanm> shapr: concat . map is slightly slower than =<<...
07:10:17 <malcolmw> ndm: nope
07:10:22 <dcoutts_> Igloo: it just needs a simple mv foo-broken archive/
07:10:27 <ivanm> but my second program takes more than twice the time the first one does
07:10:31 <ivanm> :s
07:10:47 <shapr> ivanm: Well, that was the result we hoped for :-)
07:11:02 <ivanm> heh, yeah
07:11:13 <ivanm> but concat . map (f $!) is faster than =<<
07:12:01 <ivanm> but even still, filtering through a whole heap of items is twice as fast as folding over groups of those same items?
07:12:17 <shapr> ivanm: I'd have to see the code probably.
07:12:27 <hpaste>  matthew-_ pasted "Hi Boys. So what have I done wrong this time?" at http://hpaste.org/1693
07:12:35 <ivanm> shapr: OK
07:12:38 <malcolmw> dcoutts_: I'm taking a quick look at undoing your damage to Cabal :-) Any reason why withTempFile became openTempFile?
07:12:39 <ivanm> !hpaste
07:12:43 <ivanm> @hpaste
07:12:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:12:49 <Saizan> isn't  a filter better fused than a foldl'?
07:13:00 <dcoutts_> malcolmw: the standard function is called System.IO.openTempFile
07:13:27 <malcolmw> dcoutts_: oh, the "standard" one that no-one implements? :-)
07:13:30 <dcoutts_> malcolmw: the intention is that cabal should switch to using that as soon as it gets implemented in everything other than GHC
07:13:38 * LeCamarade logs off to go over to his Linux box ... merde.
07:13:54 <dcoutts_> malcolmw: when it does then the hacky Cabal version of that can disappear and we use the standard one
07:13:55 <mauke> matthew-_: you killed GHC! congratulations, you've beaten Haskell
07:13:57 <malcolmw> dcoutts_: I would have thought that withTempFile was the nicer interface
07:14:08 <dcoutts_> malcolmw: perhaps so but it's not the standard one.
07:14:10 <matthew_-> err, any clues? I've seen this done many times, just using data for Zero and Succ, but that doesn't constrain the parameter of Succ properly, so I decided to use newtype. and ghc then cries...
07:14:16 <shapr> matthew_-: Yay! You beat the boss at the end!
07:14:19 <malcolmw> dcoutts_: but standard in what sense?
07:14:35 <dcoutts_> malcolmw: in the standard lib, in use in many programs.
07:14:39 <matthew_-> and it's fine, right up until the definition of zip
07:14:40 <malcolmw> dcoutts_: was openTempFile every proposed to the community, and subsequently accepted?
07:14:50 <mux> ndm: ping
07:14:59 <dcoutts_> malcolmw: I think it was before that process, feel free to propose something proper
07:15:14 <malcolmw> dcoutts_: I want to propose withTempFile !
07:15:20 <dcoutts_> malcolmw: anyway we already have bracket etc for doing the resource allocation & deallocation thing
07:15:25 <ndm> mux: pong
07:15:26 <Igloo> malcolmw: No-one's stopping you  :-)
07:15:47 <Igloo> malcolmw: It would be nice to also have the lower-level primitive available, though
07:15:50 <dcoutts_> malcolmw: I'm not so sure we can do with just withTempFile as the only primitive
07:16:00 <malcolmw> primitive?
07:16:11 <Igloo> openTempFile
07:16:19 <mux> ndm: I've written a toEnumMaybe function, which may be interesting for you to have in the Safe library
07:16:21 <Igloo> Not primitive in the built-in-to-the-cmopiler sense
07:16:25 <dcoutts_> malcolmw: what if I need a temp file but not in a simple block scoped kind of way
07:16:36 <malcolmw> no, I meant, does it have to implemented as a primitive?
07:16:54 <ndm> mux: send a patch over
07:16:57 <Igloo> No, an FFI call would certainly suffice
07:16:59 * shapr is a primitive!
07:17:05 <mux> ndm: actually, the name isn't that great - it's not really just a safe toEnum, it's a safe toEnum for some type a that is both an Enum and Bounded
07:17:10 <hpaste>  ivanm pasted "Folding problem" at http://hpaste.org/1694
07:17:19 <mux> ndm: but maybe it can be useful to others
07:17:20 <Igloo> Well, with some Windows/UNIX ifdeffery on one side or the other
07:17:26 <dcoutts_> malcolmw: the Q is, what function(s) should the standard lib provide. Certainly withTempFile is convenient but I don't know that it covers all the cases that openTempFile does.
07:17:40 <hpaste>  mux pasted "toEnumMaybe" at http://hpaste.org/1695
07:17:42 <ndm> mux: can you do a May, a Def and a Note version, and send them all over - should be simple
07:17:49 <ndm> mux: plus sounds like a good idea
07:17:55 <mux> plus?
07:17:59 <dcoutts_> malcolmw: I meant a primitive in the sense of minimal set of primitives in the temp file api
07:18:04 <malcolmw> dcoutts_: sure, but withTempFile would be widely useful, so maybe we want both/and
07:18:08 <ndm> mux: "as well", it sounds like a good idea
07:18:14 <mux> ndm: oh ok :-)
07:18:14 <ndm> mux: have you seen inRange?
07:18:20 <dcoutts_> malcolmw: right, perhaps we do want both, I wouldn't mind that.
07:18:30 <hpaste>  ivanm annotated "Folding problem" with "Original program" at http://hpaste.org/1694#a1
07:18:34 <Igloo> Yes, both would be ideal
07:18:34 <mux> ndm: yes but was annoyed by it requiring the type to be in Ix
07:18:35 <dcoutts_> withTempFile = bracket + openTempFile + hClsoe
07:18:44 <mux> ndm: plus it wasn't very convenient to me
07:18:44 <tcr> I can't find a function that emits a warning for me, does any exist at all? If not, what should I use instead?
07:18:47 <ivanm> shapr: that's the two versions
07:19:08 <mux> ndm: toEnumMaybe as it is defined now has allowed me to rewrite some piece of code in an uber-nice way
07:19:17 <mauke> tcr: just print something to stderr
07:19:46 <malcolmw> it's a pity there are so many different 'bracket's though
07:19:58 <ndm> mux: fair enough then, just leave it as is - its a good thing to add
07:20:15 <hpaste>  mux annotated "toEnumMaybe" with "example use" at http://hpaste.org/1695#a1
07:20:22 <malcolmw> oh wait, I'm just not reading the output from hoogle correctly
07:20:25 <mux> ndm: see annotation
07:20:49 <mux> ndm: before I would need 4 bound checks to be able to call toEnum, it was horrible.
07:21:00 <ndm> mux: yeah, that does look much neater
07:21:24 <mux> the Maybe monad also helps
07:22:24 <tcr> mauke: How can I do that portably?
07:22:44 <ndm> malcolmw: can you set up an ssh tunnel to venice, and then be a buildbot over that?
07:22:54 <mux> ndm: I'll see about sending you other versions for Safe - I can't promise anything with respect to when it'll happen though
07:23:13 <ndm> mux: fine, no rush - i don't intend to revisit Safe for a while yet
07:23:19 <mauke> import System.IO;  hPutStr stderr "NO BUS NO\n"
07:23:46 <malcolmw> ndm: I have an ssh tunnel to venice already (for IRC) but I don't know what is required to tunnel my web browser out
07:24:08 <malcolmw> ndm: or whatever buildbot needs
07:24:14 <ndm> malcolmw: we don't need you to tunnel the web browser out, just to tunnel buildbot in - you won't be able to see the results, but we will
07:24:44 <tcr> mauke: Ah, alright. Looked at the wrong place. Thank you!
07:24:51 <malcolmw> ndm: tell me how to do it
07:25:09 <ndm> malcolmw: i'll get andrew to email you instructions
07:25:26 <nominolo> @tell bringert congrats from me too (although i'm not entirely sure what they're for; i have a good guess, though)
07:25:27 <lambdabot> Consider it noted.
07:25:37 <shapr> ivanm: I can see the code differences, but I can't pick out the problem at the moment. I suspect there's a faster definition of howMany, but I can't think of it.
07:26:12 <ivanm> shapr: *nod*, I was asking about it last night, but quicksilver gave me that one (which was one I'd already thought of)
07:26:25 <ivanm> I know at first it crashed due to insufficient heap space...
07:26:39 <ivanm> which is weird, because my original program never used more than 5 MB
07:28:03 <matthew_-> is there a ghc 6.6.1 for debian anywhere?
07:29:51 <mauke> matthew_-: still crashes in 6.6.1
07:30:18 <mauke> same source location
07:30:28 <matthew_-> mauke: cheers
07:30:52 <mauke> are you going to report this?
07:31:03 <matthew_-> yep.
07:31:21 <ivanm> g'night all
07:31:39 <matthew_-> if you change the newtype to data then it does compile
07:33:27 <tcr> mauke: Now the question is, if I do it that way, how can I get out of the IO Monad?
07:35:06 <sproingie> you can't
07:35:43 <mauke> tcr: you don't
07:35:53 <sproingie> you can write pure functions as if they weren't in the io monad and lift them.  but you can never turn IO a -> a
07:40:14 <Wild_Cat> yeah, the way I understand it, you can call a pure function from a monad, but not the opposite -- monads are impure. Correct?
07:40:46 <tcr> Yeah, that's what I've thought. So writing a portable function warn that behaves like error (i.e. `warn :: String -> a') or a function `withWarning :: String -> a -> a' is not possible? So how can I do that if I do not restrict myself to haskell98?
07:41:27 <kpreid> tcr: look at Debug.Trace.trace
07:41:50 <kpreid> Wild_Cat: no, that's not true in general
07:42:07 <Wild_Cat> kpreid: how so?
07:42:12 <kpreid> Wild_Cat: most monads have some sort of 'run' because they *aren't* about external side effects
07:42:12 <dino-> Monads are used to wrap around impure things, but they don't have to be doing that.
07:42:20 <kpreid> @type runState
07:42:24 <lambdabot> forall s a. State s a -> s -> (a, s)
07:42:26 <kpreid> @type runReader
07:42:28 <lambdabot> forall r a. Reader r a -> r -> a
07:42:37 <kpreid> @type runCont
07:42:39 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
07:43:58 <eumenides> @type runST
07:44:01 <lambdabot> forall a. (forall s. ST s a) -> a
07:44:02 <Saizan> btw the IO monad is a way to make I/O pure, because you just represent I/O actions that get executed later by the runtime system
07:45:44 <Saizan> (however pure is often used as a term for non-monadic)
07:45:56 <Wild_Cat> I don't really see how IO can be pure.
07:46:37 <Philippa_> Wild_Cat: start with a type World, representing universe-states
07:46:39 <DRMacIver> The handwavy justification is that it's a function of type f : StateOfWorld -> StateOfWorld which the monad prevents you from abusing. :)
07:47:05 <Philippa_> right. You can represent it as a function, just not as a computable one
07:47:06 <dino-> I think sometimes the phrasing of it is unclear. But it seems to me more like IO gets (permanently) wrapped in containment that interfaces it with the rest of the (pure) software evaluating.
07:47:30 <Wild_Cat> yeah, that's what I thought.
07:47:46 <Philippa_> yeah, but there's a POV that says that's done to ensure certain invariants regarding Worlds don't get broken
07:48:04 <Philippa_> for example, only using them once (because if you break it, your code's trying to do time travel)
07:48:08 <DRMacIver> Or create massive memory leaks by referring to old copies of world. :)
07:48:29 <Philippa_> massive as in impossible, given that your memory is /in/ the world :-)
07:48:39 <DRMacIver> Infinity is pretty big!
07:49:01 <emu> > [1..]
07:49:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:49:21 <shapr> lambdabot gets tired quickly.
07:49:41 <DRMacIver> shapr: Yes. ONe might even say that it's lazy. ;)
07:52:01 <ulfdoz> I wrote an AVL-Tree. Currently the highest complexity is the function, determining the height of the subtree (O(#nodes)). Thus, I plan to incorporate the maximum distance from a node to a leave as a constructor argument. How can I hide this argument to prevent inconsistent values?
07:52:01 <psykotic> > fix $ (1:) . map (1+)
07:52:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:53:11 <psykotic> ulfdoz, you can not export the data type constructor from your module, if i understand you correctly
07:54:06 <ulfdoz> Hm, sounds reasonable.
07:54:29 <mnislaih> xerox: ping
07:54:41 <ulfdoz> Thinking this thought further, it would cost me tail-recursion in remove/insert. :(
07:54:45 <psykotic> ulfdoz, that way you only have to make sure that the internal uses of the constructor maintains the invariants
07:58:36 <ulfdoz> How far is memoization in the compiler?
07:59:42 <psykotic> none afaik, it's not the kind of thing you want to happen automatically.
08:00:08 <psykotic> unless you mean hoisting things up in lets
08:00:21 <ndm> ulfdoz: only for CAF's, functions which take no arguments
08:00:29 <mnislaih> dcoutts:  I upgraded cabal-install to use filepath (now filepath is in dependencies too) and fixed a few other things for Windows.
08:00:42 <norpan> ulfdoz: and only for non-polymorph functions
08:00:44 <ndm> @karma+ mnislaih -- filepath useage in cabal
08:00:44 <lambdabot> mnislaih's karma raised to 4.
08:00:48 <mnislaih> dcoutts: Should I send the patch to xerox or bringert or push it already ?
08:01:03 <malcolmw> dcoutts_: I think I have managed to restore the code you changed/removed in Distribution.Simple.Utils, but in a slightly nicer way.
08:01:04 <quicksilver> memoization means different things to different people
08:01:04 <ndm> norpan: it does do polymorhpic functions, just not ones with classes
08:01:06 <ulfdoz> hm, ok. I need a new idea.
08:01:06 <dcoutts_> mnislaih: oh great
08:01:11 <quicksilver> let bindings are only evaluated at most once
08:01:17 <quicksilver> that is a kind of limited memoization
08:01:35 <quicksilver> but (automatic) memoization of arbitrary sub-expressions is a pandora's box
08:01:35 <sproingie> is there a prebuilt cabal-install anywhere?
08:01:39 <norpan> ndm: what kind of zero argument function would not be class polymorph?
08:01:39 <dcoutts_> mnislaih: I was just hacking on cabal-install too, would you mind sending me the patch and I'll apply both (after resolving any conflicts)
08:01:40 <mnislaih> it *almost* works in Windows now
08:01:57 <dcoutts_> mnislaih: do you have any opinions on where these data files should go
08:02:09 <ndm> norpan: reverse = foldl (flip (:)) []
08:02:12 <dcoutts_> mnislaih: it doesn't work 'out of the box' very well at the moment
08:02:14 <psykotic> things that are explicitly introduced by a binding are of course "memoized" for their extent, in so far as non-strictness is implemented by laziness, but that wasn't what i understood by memoization here (but i might be wrong).
08:02:23 <quicksilver> norpan: myBigMap = Data.Map.fromList [..some constant list..]
08:02:34 <dcoutts_> mnislaih: especially if you're not running as root.
08:02:51 <norpan> ndm: that has one argument?
08:03:02 <mnislaih> right, but at least it works fine as root. It doesnt work at all in Windows
08:03:10 <ndm> norpan: no, that returns a function that has one argument, but in itself has 0 arguments
08:03:11 <dcoutts_> mnislaih: I think we should automatically select --user or --global depending on the permissions of the current user. Of course you could always override it.
08:03:21 <norpan> ndm: but how can it possibly memoize that
08:03:29 <norpan> it would have to keep one instance for every type
08:03:34 <ndm> norpan: it does, it memorizes the function
08:03:36 <mnislaih> I've seen a ticket about that dcoutts_
08:03:43 <quicksilver> ndm: that's not memoized in any useful sense, since it can't be evaluated any further until it receives an argument
08:03:47 <ndm> norpan: nope, it executes that exactly one :)
08:03:50 <mnislaih> I'll send the patch you
08:03:57 <mnislaih> that is, I'll send *you* the patch
08:03:59 <dcoutts_> malcolmw: what's your fix ?
08:04:00 <ndm> quicksilver: its some saving, admitedly not a huge amount
08:04:06 <dcoutts_> mnislaih: ta
08:04:12 <malcolmw> dcoutts_: darcs pull :-)
08:04:17 <dcoutts_> malcolmw: ok :-)
08:04:29 <quicksilver> norpan: however my example was a zero-argument function doing a non-trival amount of work
08:04:58 <norpan> but was it polymorphic?
08:05:31 <quicksilver> norpan: no
08:05:33 <norpan> i thought it only memoized stuff that was of a non-function type
08:05:50 <quicksilver> norpan: it doesn't distinguish between function type and non-function type
08:06:06 <quicksilver> norpan: it's just that an example like ndm's, there really isn't much to do
08:06:10 <quicksilver> however, consider this:
08:06:28 <quicksilver> myFun = let x = ( ... some big calculation ... ) in (+x)
08:06:32 <quicksilver> that has function type
08:06:38 <quicksilver> and yet it is definitely memoised
08:06:47 <quicksilver> the big calculation is only performed (at most) once
08:06:56 <norpan> but my original claim was that it didn't do it for functions with polymorphic types
08:06:59 <norpan> how could it
08:07:08 <quicksilver> it *could* do it once per type
08:07:18 <quicksilver> I've no idea what it does in practice...
08:07:49 <quicksilver> once per type for class-polymorphism
08:07:55 <norpan> it would have to keep some potentially infinite look-up table from type to memoization
08:07:59 <quicksilver> for unbounded polymorphism it might be ok
08:08:58 <quicksilver> like this:
08:09:12 <quicksilver> myFun = let x = ( ... some big calculation ... ) in (!!x)
08:09:23 <quicksilver> that's unbounded polymorphic and I imagine it can be memoised
08:09:30 <mux> do you always use let in order to kick off memoization?
08:09:30 <quicksilver> but I don't know GHC internals to tell you for sure
08:09:36 <ndm> i have a function that does a CAF inside a class, which is done one per type
08:09:41 <mux> are there other ways? shouldn't it be transparent somehow?
08:09:51 <quicksilver> mux: no, you don't always use let
08:10:04 <quicksilver> mux: that just makes for convenient examples
08:10:07 <mux> okay
08:10:27 <mux> I've often heard about 'ways' to write things in order to somehow enable memoization, hence why I'm being curious
08:10:50 <mux> such as 'a version of fibonacci with memoization'
08:11:27 <quicksilver> typically this involves a lazy data structure (like an array being lazy in its elements) to 'memoize' previous values
08:11:59 <mnislaih> dcoutts_: perhaps you can help with the Makefile, I can't handle them. The install-user target should be taught to copy the serv.list in the appropriate Windows path "C:\Documents and Settings\username\Application Data\cabal-install"
08:11:59 <shapr> hyv huomenta rahikkala!
08:12:04 <dcoutts_> mnislaih: I was trying to use cabal-install to install cabal-upload-0.3 but it doesn't even compile :-(
08:12:14 <dcoutts_> mnislaih: Makefiles? we don't want makefiles :-)
08:12:21 <mnislaih> :)
08:12:42 <mnislaih> what errors do you get ?
08:13:07 <dcoutts_> mnislaih: seriously I don't think we want them, cabal should be extended to be able to install any data files we need, or we should have the program do that when it's initialased
08:13:20 <dcoutts_> mnislaih: we already have a facility for installing data files
08:13:28 <shapr> Hej boy, vilket vackert vader.. koden skiner idag... (the code is shining today!)
08:13:35 <dcoutts_> mnislaih: however they often go into read-only directories
08:14:07 <dcoutts_> mnislaih: but that's not necessarily bad, we could let the read-only global one be the default and allow users/admins to override them
08:14:53 <mnislaih> dcoutts_: right
08:15:28 <mnislaih> dcoutts_: though right now cabal-install uses a Makefile to install itself.
08:15:32 <dcoutts_> mnislaih: ie have /usr/share/cabal-install/serv.list be the global default and if /etc/cabal-install/serv.list or ~/.cabal-install/serv.list exists then it overrides
08:15:43 <dcoutts_> mnislaih: right, but it shouldn't.
08:15:55 <dcoutts_> mnislaih: it only does that because of these silly data files.
08:16:08 <dcoutts_> mnislaih: I didn't install using the makefile, I used cabal.
08:16:28 <dcoutts_> mnislaih: that works fine except that then it doesn't know automagically where the data files are.
08:16:35 <dcoutts_> but this should be easy to fix
08:16:35 <mnislaih> yep
08:16:57 <dcoutts_> we do have the Paths_cabal_install module that cabal generates for us
08:17:12 <dcoutts_> that deals with finding data files that cabal installs for us
08:17:21 <dcoutts_> we just need to make it work within that system
08:17:41 <dcoutts_> and not demand that the installer actually create /etc/cabal-install/srv.list
08:18:56 <dcoutts_> mnislaih: that Paths_cabal_install works on windows too of course
08:19:07 <mnislaih> what is Paths_cabal_install exactly ?
08:19:18 <dcoutts_> it's a module generated by cabal
08:19:25 <dcoutts_> see dist/build/autogen/Paths_cabal_install.hs
08:19:45 <mnislaih> oh, nice
08:19:56 <dcoutts_> it has handy functions to find our data, lib etc dirs and our own version number
08:20:04 <dcoutts_> and it's portable
08:20:14 <dcoutts_> even for relocatable windows packages
08:20:56 <plediii> I've read that ghc should come with the QuickCheck module, but importing Test.QuickCheck does'nt work.  Can someone tell me how I would figure out where to find the proper name?
08:21:52 <shapr> @where QuickCheck
08:21:53 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
08:21:55 <shapr> hmm
08:21:56 <dcoutts_> plediii: install the QuickCheck package
08:22:11 <dcoutts_> it should come with your distro (assuming you got ghc from your distro)
08:22:26 <int-e> use -package QuickCheck or --make?
08:22:30 <plediii> dcoutts_: I'm confused, I have to install the package that came with my distro?
08:22:32 <int-e> (when compiling)
08:22:37 <plediii> ok
08:23:14 <shapr> plediii: If you can use darcs, I'd suggest QuickCheck 2. It can be fetched with "darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck"
08:23:18 <lambdabot> Title: Index of /~bringert/darcs/QuickCheck
08:23:40 <shapr> plediii: QuickCheck is very cool and lots of fun, if you have any questions about using or installing it, feel free to ask!
08:24:01 <plediii> I don't know if I'm ready for the most recent version, I'm just trying to follow along with the Hitch Hiker's Guide to Haskell right now.
08:24:04 <dcoutts_> malcolmw: you couldn't at implement withTempFile in terms of openTempFile?
08:24:26 <shapr> plediii: Ok, if you decide you want more testing niftiness, I'd love to enthuse about QuickCheck :-)
08:24:27 <malcolmw> dcoutts_: I didn't even try - just cut-n-pasted the old version
08:24:47 <malcolmw> dcoutts_: feel free to improve
08:25:01 <plediii> I'm sure I will in the future :)  I like testing my code.
08:25:12 <mnislaih> dcoutts_: I couldn't make gnu tar work in windows easily. What do you think about including Bringert's tar  package in cabal-install? Would that be too many dependencies?
08:25:32 <dcoutts_> mnislaih: is the problem with missing -z flag on windows tar ?
08:25:36 <shapr> plediii: Me too!
08:25:42 <ejt> @paste
08:25:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:25:48 <shapr> hiya ejt
08:26:06 <ejt> hey shapr, how are you ?
08:26:17 <mnislaih> dcoutts_: I couldn't make it understand the Windows path convention, perhaps someone with more experience could fix that but I didn't see the way
08:26:31 <shapr> I'm great! I have lots of good paying Haskell code, w00!
08:26:49 <hpaste>  ejt pasted "This must be in the standard library somewhere ?" at http://hpaste.org/1696
08:26:56 <mnislaih> dcoutts_: that was with Cygwin tar. GNU Win32 tar wasn't working, missing dll or something
08:27:10 <plediii> shapr: I've tried running ghci -package QuickCheck with ghc-6.6, but it complains unknown package.
08:27:20 <dcoutts_> mnislaih: ah, we probably want mingw tar since we are working with native paths.
08:27:32 <plediii> ah, I think it doesn't come with ghc.
08:27:33 <mnislaih> can it be bundled with cabal-install ?
08:27:43 <ejt> shapr: writing haskell for a living ?  very lucky man
08:27:49 <shapr> plediii: Try running "ghc-pkg -l|grep -i quickcheck"
08:27:53 <dcoutts_> mnislaih: Bringert's tar code is fine, but we'd still need gunzip
08:28:05 <mnislaih> ah, right
08:28:09 <shapr> plediii: "ghc-pkg -l" lists all the ghc packages you have installed.
08:28:27 <dcoutts_> mnislaih: I've got a zlib library, but it needs zlib1.dll installed too
08:28:43 <plediii> shapr: it's not a very long list, and greping verifies that quickcheck isn't there.
08:28:52 <mnislaih> dcoutts_: I'll give mingw tar a go
08:28:54 <shapr> ejt: Yeah, the Haskell jobline is expanding though. Several companies are actively hiring.
08:29:00 <plediii> shapr: I suppose there is some cabal package I can find.  It did come with hugs.
08:29:06 <shapr> plediii: Could you tell me which OS and flavor you're using?
08:29:20 <shapr> And which version of ghc?
08:29:26 <dcoutts_> mnislaih: but we do need a long term solution, we should either bundle gnu tar or our own zlib + tar code.
08:29:31 <malcolmw> plediii: you might need to install something like ghc-extras, if your OS pkg manager offers it
08:29:33 <plediii> plediii: debian etch, ghc-6.6, I'm not sure what you mean by flavor.
08:29:46 <plediii> hmm,
08:29:49 <plediii> shapr: debian etch, ghc-6.6, I'm not sure what you mean by flavor.
08:29:50 <mnislaih> dcoutts_:  yes, that's what I was thinking
08:29:53 <shapr> Well, if you're using Windows, flavor might be XP, etc
08:30:00 <mnislaih> just want to see if my patch works
08:30:05 <plediii> I suppose etch is the flavor then.
08:30:06 <shapr> plediii: Yeah, Linux/debian would be OS/flavor, imho
08:30:09 <dcoutts_> mnislaih: though how we do that nicely with cabal etc I don't know
08:30:12 <plediii> ah.
08:30:14 <shapr> I'm using debian/unstable, whatever that is these days.
08:30:41 <shapr> plediii: Lucky you, debian has one of the best collections of Haskell packages!
08:31:13 <plediii> shapr: I suppose you mean there is an apt package for quickcheck, let me look for that.
08:31:29 <shapr> plediii: You can find lots of ghc packages with "apt-cache search libghc6" but for your specific needs, try "apt-get -uf install libghc6-quickcheck-dev"
08:33:27 <dcoutts_> mnislaih: I reckon we should just make cabal-install depend on filepath and http rather than bundling them.
08:33:39 <dcoutts_> mnislaih: it depends on half a dozen libs anyway
08:33:51 <mnislaih> dcoutts_: right
08:34:06 <dcoutts_> mnislaih: most of those are 'core libs' (including filepath these days)
08:34:16 <dcoutts_> only http isn't, but it's included with ghc-extralibs
08:34:45 <dcoutts_> so if cabal-install ever gets bundled with ghc in the -extra stuff then it'll have all its deps satisfied
08:34:49 <dcoutts_> so no need for bundling
08:36:31 <dcoutts_> mnislaih: btw if you're in the mood to filepath things, you could rip out the Cabal.Compat.FilePath and replace it with proper file path :-)
08:36:46 <dcoutts_> that'd be a great service
08:37:10 <plediii> shapr: that debian package seems to have worked, thanks a bunch.
08:37:47 <mnislaih> dcoutts_: you mean, without changing the Cabal.Compat.FilePath api? Otherwise, that would be a lot of changes to Cabal related apps
08:37:49 <dcoutts_> mnislaih: filepath patch to cabal-install looks good
08:38:15 <dcoutts_> mnislaih: no I mean really ripping out Cabal.Compat.FilePath and not exporting it anymore, breakage and all
08:38:19 <shapr> plediii: Yay, any other questions?
08:38:50 <dcoutts_> mnislaih: the current dev version of cabal breaks lots of things in the interests of sanity anyway
08:39:53 <mnislaih> dcoutts_: I have a few spare minutes, so I'll give a look
08:39:54 <plediii> shapr: not for now, thanks again.
08:40:12 <mnislaih> what do Windows people use when they want to untar something (command-line) ?
08:40:22 <mnislaih> I can't find a download link for mingw tar
08:40:27 <dcoutts_> mnislaih: they mostly don't
08:40:46 <dcoutts_> mnislaih: there's some other SF.net project which has gnu utils
08:41:07 <ClaudiusMaximus> i think 7-zip supports tar and gzip and has a command line version (but it's been years since i used windows)
08:41:16 <mnislaih> I tried to use gnuwin32 already but that didn't work out of the box
08:42:27 <dcoutts_> mnislaih: ah, yeah that was the one I was thinking of
08:42:39 <sebell> I use 7-zip on Win32
08:43:04 <ndm> mnislaih: unix utils, i have a mirror somewhere...
08:43:06 <Saizan> mingw has tar in binutils
08:43:11 <eumenides> is there some md5 or sha1 lib that uses bytestrings?
08:43:21 <mnislaih> Saizan: I will try that
08:43:31 <ndm> http://www.cs.york.ac.uk/fp/yhc/dependencies/UnxUtils.zip
08:43:39 <ndm> mnislaih: that link has all the good stuff
08:43:45 <Saizan> it comes shipped with msys, actually
08:43:56 <mnislaih> ndm, do you bundle that with YHC?
08:43:58 <ndm> mingw is evil
08:44:08 <mnislaih> Saizan: nah, I didn't want to install all that
08:44:28 <mnislaih> not even in my virtual machine
08:44:53 <ndm> mnislaih: no, but that was where i could get free hosting and subtle enough to slip past our support department :)
08:45:37 <mnislaih> ndm, thanks!
08:46:00 <ndm> its a real shame the original now 404's, since it is the first thing I install on all windows boxes
08:46:45 <mnislaih> I think I'm going to delicious that link ndm
08:46:54 <mnislaih> hope you don't mind
08:47:04 <ndm> mnislaih: fair enough, as long as it doesn't become too popular...
08:47:16 <ndm> if support notice, i may have to move it off...
08:52:28 <mnislaih> hmm ndm,  tar says it cannot use compressed archives :(
08:53:21 <mnislaih> trying mingw binutils now
08:53:54 <ndm> mnislaih: it can't, use the gunzip separately
08:54:33 <mnislaih> Saizan: any idea if the mingw tar comes -z enabled ?
08:54:45 <Saizan> it does
08:55:15 <mnislaih> the last binutils build here  is from 2003, am I looking at the wrong place?
08:55:44 <mnislaih> ah, found the right link
08:57:07 <Saizan> yeah the download page could be better..
08:58:42 <mnislaih> Saizan: no tar in binutils! I'll try the 'previous' package
09:02:23 <ndm> mnislaih: why do you need the -z option in tar? why isn't gunzip and tar good enough?
09:02:43 <mnislaih> ndm: I need it for cabal-install
09:03:04 <mnislaih> I don't really want to change cabal-install to use gunzip in Windows
09:03:05 <ndm> mnislaih: fix cabal-install
09:03:17 <ndm> mnislaih: it could use gunzip everywhere
09:03:19 <ndm> could/should
09:03:37 <mnislaih> that's a possibility too
09:08:07 <ndm> its the only fix that will allow me to actually release things to hackage...
09:08:28 <ndm> currently none of my packages make it up, beacuse of that
09:08:36 <dcoutts_> ndm: where did you get your gnu tar from?
09:08:47 <ndm> @google unix utils
09:08:49 <lambdabot> http://unxutils.sourceforge.net/
09:08:49 <lambdabot> Title: Native Win32 ports of some GNU utilities
09:08:50 <dcoutts_> and why are these windows version of tar so old that they do not support the -z option?
09:09:03 <dcoutts_> or do they just not bundle gunzip ?
09:09:14 <ndm> dcoutts_, and its old because its years old - the download now 404's - i have a mirror though
09:09:22 <ndm> dcoutts_, they do bundle gunzip
09:09:42 <dcoutts_> ndm: that's very odd then because all tar -z does is call out to gunzip I think
09:09:46 <ndm> but its just a .zip, you install each program out of it individually
09:09:52 <ndm> why not have cabal call out to gunzip?
09:10:08 <ndm> unless the reason is to stop me releasing to hackage ;)
09:10:10 <dcoutts_> ndm: but this isn't a good solution anyway, unless we actually bundle tar and possible gunzip too
09:10:30 <ndm> dcoutts_ - true - do we really need to gzip cabal packages?
09:10:42 <dcoutts_> relying one totally random version of tar that the user may or may not have installed
09:10:54 <dcoutts_> ndm: I think so, bandwith is expensive
09:10:58 <ndm> if we relied on bringerts untar, and gave up on zip
09:11:08 <ndm> dcoutts_ to who is it expensive?
09:11:13 <dcoutts_> both ends
09:11:16 <ndm> dcoutts_ - if the answer is haskell.org, then use google
09:11:25 <ndm> i don't know anyone who pays for bandwidth anymore
09:11:35 <shapr> Paul Hudak?
09:11:38 <dcoutts_> ndm: surely it cannot be that hard for use to bundle zlib1.dll ?
09:11:41 <nominolo> never had a server?
09:11:46 <ndm> dcoutts_ - dll hell
09:11:51 <dcoutts_> ndm: we do have a Haskell zlib package
09:11:52 <ndm> nominolo: i mean, the downloader never pays
09:12:03 <ndm> the server does pay, but if we just google host things...
09:12:18 <ndm> there is rarely a problem to which the answer is not google
09:12:25 <dcoutts_> ndm: according to come economist bandwidth is the most expensive part of computing, by like 1000x times
09:12:31 <nominolo> this is hardly a general solution ..
09:12:42 <ndm> but double is still pretty insignificant
09:12:53 <ndm> compared to the amount of illegal movies people are downloading!
09:13:19 <amiddelk> ndm: downloading movies isn't illegal in the netherlands... uploading them is ;)
09:13:24 <dcoutts_> ndm: there is no dll hell if you install zlib1.dll in the same dir as cabal-install
09:13:39 <ndm> dcoutts_ - fair enough, but you do sometimes need the curdir set appropriately
09:13:47 <dcoutts_> ndm: no you dont
09:13:55 <dcoutts_> ndm: it always looks in the .exe dir first
09:14:02 <nominolo> how hard would it be to have a minimal (but slow) zip/tar lib in cabal?
09:14:02 <ndm> dcoutts - in other news, how easy was your gtk installer? and how much work would it to do one for hugs as well?
09:14:28 <dcoutts_> nominolo: Igloo has some pure Haskell gzip decompression code
09:14:55 <dcoutts_> CosmicRay: you were one of the people complaining about the limitations of System.Process wern't you?
09:15:06 <ndm> dcoutts_ i have some pure C unzip code which is like 10Kb - couldn't you FFI into that?
09:15:11 <CosmicRay> dcoutts: yes
09:15:19 <dcoutts_> CosmicRay: if so, propose something. We all agree it's limited.
09:15:33 <CosmicRay> dcoutts: I concluded that it is inadequate for HSH and possibly for hpodder as well
09:15:54 <dcoutts_> CosmicRay: eg I can't nicely capture the stdout of a process while not re-directing stderr
09:16:13 <dcoutts_> CosmicRay: and I don't want to capture stderr because of deadlock issues
09:16:34 <dcoutts_> CosmicRay: JaffaCake filed a bug saying we need something better, we just need a concrete proposal.
09:16:54 <dcoutts_> ndm: but if we're using C code, why not zlib ?
09:17:01 <CosmicRay> dcoutts: I can do some thinking.  Python has a nice system, I think, but it's Unix specific.  and I don't know how this works on windows.
09:17:14 <dcoutts_> CosmicRay: that'd be great.
09:17:26 <ndm> dcoutts_ could you not produce a binary which was statically linked, i.e. no .dll?
09:17:34 <dcoutts_> ndm: possibly, yes.
09:18:49 <evan_> i've a quick cabal question, if anyone's around...
09:18:52 <dcoutts_> ndm: for this to be really useful we need the compression side too, so cabal sdist will work.
09:18:55 <dcoutts_> evan_: shoot
09:19:12 <evan_> i have a library that uses the ffi, etc. and my cabal works fine for that.
09:19:28 <evan_> i'd like to build an executable to test it.  but if i specify the executable in the same cabal file as the library,
09:19:37 <dcoutts_> yeah, it's ugly
09:19:47 <dcoutts_> it rebuilds the whole lib
09:19:49 <evan_> ghc helpfully tries to rebuild the .hs from the library and fails to pull in all the cabaled setup.
09:20:06 <evan_> since i'm using this for testing, rebuilding the lib would be ok
09:20:33 <evan_> but the rebuild here fails because it doesn't bring along e.g. the C library at link time
09:20:51 <evan_> what do people normally do?
09:21:10 <dcoutts_> evan_: so the executable is not really related to the lib, there's no automatic dep, so ou have to list the src dirs and any .c files to link in seperately for the lib and executable
09:21:25 <dcoutts_> evan_: they either duplicate the build info, or they use multiple packages
09:21:37 <evan_> hm, ok.  so the executable needs to know everything that the lib does?
09:21:46 <evan_> like, which flags to pass to c2hs?
09:21:51 <dcoutts_> evan_: yes. Imagane that the're totally unrelated.
09:22:09 <dcoutts_> they just happen to build from the same source tree
09:22:10 <int-e> which also explains the complete rebuild.
09:22:17 <dcoutts_> but the build info is totally independent
09:22:21 <mnislaih> ndm: quick filepath question: is there any function to turn a windows-or-posix path into a local platform path ?
09:22:25 <evan_> that explains a lot :)
09:22:34 <dcoutts_> you can build the same modules with different flags for example
09:22:58 <dcoutts_> evan_: it's basically bad design
09:22:59 <ndm> mnislaih: no, normalise may do some of it - i.e. / to \ on windows - but generally posix paths work fine on windows normally
09:23:04 <evan_> so when building a library plus a test program, should i duplicate all the build info for each, or is there some way to have the test program only use the built library?
09:23:23 <evan_> for example, i suppose could install the library locally and then build the test program like a user of the library would.
09:23:25 <dcoutts_> evan_: use a test sub dir with it's own .cabal file and have that dep on the lib
09:23:38 <dcoutts_> evan_: but annoyingly the lib needs to be registered first
09:23:49 <dcoutts_> encryptio: but you can ./setup register --user --inplace
09:24:02 <evan_> i hadn't seen --inplace!
09:24:06 <dcoutts_> to register the built lib, in place in the build tree
09:24:44 <evan_> actually, i hadn't even yet looked at the "register" command, now that i investigate
09:24:50 <dcoutts_> evan_: the right long term solution is for cabal to deal with small collections of related .cabal packages and do the local registration automatically etc
09:25:08 <evan_> yeah... i don't envy whoever is implementing that, though ;)
09:25:11 <dcoutts_> evan_: aye, register is mostly subsumed by install
09:25:31 <dcoutts_> evan_: exactly. That's why it still works in the unintuitive way it does now :-(
09:27:34 <evan_> thanks, duncan!  i have to run to work now, but now i can move forward on hacking on this.
09:27:51 <dcoutts_> evan_: np. have fun :-)
09:33:57 <dfranke> what's the appropriate place to send a contribution to the posix package?  cvs-libraries@haskell.org?
09:36:09 <Igloo> dfranke: If it's not "obviously the right thing", then see http://www.haskell.org/haskellwiki/Library_submissions
09:36:11 <lambdabot> Title: Library submissions - HaskellWiki
09:36:39 <Igloo> dfranke: Otherwise, libraries@haskell.org
09:37:04 <Igloo> dfranke: If you do have made a darcs patch and your mail system is set up, then "darcs send" should send it there
09:37:06 <TomMD> It is obviously the right thing to change inet_addr from String -> IO Word32 into a String -> Word32
09:37:38 <mnislaih> dcoutts_: shall I remove Distribution.Compat.Directory too? most if not all of that stuff is already in System.Directory
09:37:51 <kc5tja> http://www-128.ibm.com/developerworks/linux/library/l-python-elegance-1.html?S_TACT=105AGX52&S_CMP=cn-a-l -- an interesting article that floated my way already.  Lists a number of warts with respect to Python.  Thought it might be interesting.
09:37:55 <lambdabot> Title: Charming Python: Python elegance and warts, Part 1, http://tinyurl.com/yubden
09:38:10 <dcoutts_> mnislaih: in theory cabal still works with ghc-6.2.2, so we need to bear that in mind
09:38:27 <mdmkolbe|work> is this legal haskell98 (GHC accepts it but it might just be more forgiving)? 'let f f = f in f'
09:38:30 <mnislaih> dcoutts_ yes, then I will leave it there
09:38:48 <dmhouse> mdmkolbe|work: if GHC doesn't warn about it with -Wall, it's probably legal.
09:39:00 <dmhouse> And I think that's just standard shadowing, so it should be fine.
09:39:07 <dmhouse> f = id.
09:39:10 <Igloo> TomMD: Hmm, I'd say yes, but given it could break existing code it might be worth going through the process anyway
09:39:52 <mdmkolbe|work> dmhouse: it does warn about the fact that it's shadowing, but nothing about an H98 violation (which I what I assume it would emit if it were?)
09:40:20 <dcoutts_> mnislaih: Igloo: do you think we could get away with dropping cabal support for ghc-6.2.2 ?
09:40:32 <dmhouse> mdmkolbe|work: it's fine then. That's what I thought.
09:40:49 <mdmkolbe|work> dmhouse: cool
09:41:09 <Igloo> dcoutts_: No, GHC supports back to 6.0
09:41:27 <dcoutts_> Igloo: cabal doesn't. only back to 6.2.2
09:41:40 <Igloo> dcoutts_: Cabal built with 6.0 when I tried
09:41:43 <dcoutts_> malcolmw: if you're looking at implementing more base lib bits on nhc, how about Control.Exception (bracket,finally) ?
09:41:55 <mdmkolbe|work> dcoutts_: what do you mean by that?  what kind of 'support' would be dropped?
09:41:59 <dcoutts_> Igloo: heh, it might build, that does not mean it works with 6.0
09:42:05 <malcolmw> dcoutts_: current + two previous major versions seems like a reasonable minimum for stability and minimum annoyance to users
09:42:22 <Igloo> dcoutts_: Hang on, do you mean building cabal with 6.x, or building a library /for/ 6.x?
09:42:36 <malcolmw> dcoutts_: I'm not looking at implementing more base bits right now :-)
09:42:50 <dcoutts_> Igloo: I'm happy to negotiate on either :-)
09:42:58 <malcolmw> dcoutts_: once I found a quick hack around Cabal not building, anyway
09:43:05 <Igloo> dcoutts_: I believe Cabal builds with 6.0, and GHC needs it to do so
09:43:09 <dcoutts_> malcolmw: ah great. It looks like you've implemented them in cabal's Distribution.Compat.Exception, if they can go into base that'd mean we could drop that compat module.
09:43:19 <ndm> dcoutts_, we have Control.Exception in Yhc
09:43:30 <Igloo> dcoutts_: I personally don't care if it builds /for/ 6.4 even; 6.2 support could certainly be dropped IMO
09:43:37 <malcolmw> dcoutts_: we don't have Control.Exception at all in nhc98
09:43:41 <dcoutts_> ndm: yeah, this workaround here is only for nhc
09:43:42 <ndm> hopefully, once Yhc and nhc merge back the "nyhc" will have Control.Exception
09:43:49 <Igloo> Ooops, I meant to put a smiley before the ;
09:43:55 <dcoutts_> malcolmw: ah right. well even a subset would help :-)
09:44:12 <malcolmw> dcoutts_: I don't see where the definition of the Exception datatype lives though
09:44:27 <Igloo> malcolmw: GHC.mumble
09:44:56 <malcolmw> Igloo: exactly as i though - mumble grumble
09:44:57 <Igloo> malcolmw: And I don't think that should change before we move to something like SimonM's extensible exceptions paper
09:45:16 <Igloo> malcolmw: But you don't need that to implement bracket etc
09:45:23 <dcoutts_> Igloo: but for example we have to keep the compat wrapper for Data.Map vs Data.FinteMap :-(
09:45:40 <malcolmw> Igloo: indeed, and as dcoutts_ pointed out, I already implemented them (although I'd forgotten that)
09:46:25 <Igloo> dcoutts_: Yeah, but that's not /too/ painful given it's already written
09:46:54 <dcoutts_> Igloo: yeah. But isn't cabal built by stage1, not by the original host ghc?
09:47:03 <dcoutts_> Igloo: or by both?
09:47:35 <Igloo> dcoutts_: Cabal is built by the host compiler so that we can build the libraries with it
09:48:23 <dcoutts_> Igloo: I wouldn't trust a cabal lib built by old ghc, we have nice comments like:
09:48:24 <dcoutts_>   where esc arg = "'" ++ arg ++ "'" -- this is hideously broken, actually
09:48:34 <dcoutts_> for the compat code
09:48:39 <earthy> ewwww
09:48:42 <dcoutts_> it builds, but I wouldn't like to use it
09:48:52 <Igloo> dcoutts_: It only has to work for building the core libraries
09:49:09 <dcoutts_> Igloo: so you do build cabal twice
09:49:13 <Igloo> Yes
09:49:25 <dcoutts_> Igloo: so could you not build it using the stage1 compiler?
09:49:33 <dcoutts_> since you do that for all the other libs
09:49:46 <Igloo> dcoutts_: Sure, if you remove the dependency on base
09:49:58 <dcoutts_> huh?
09:50:10 <Igloo> We use cabal to build base
09:50:18 <dcoutts_> ah, mm.
09:50:38 <dcoutts_> sigh, bootstrapping is so tricky.
09:52:30 <dcoutts_> Igloo: so could you cope if cabal depends on filepath?
09:52:51 <dcoutts_> Igloo: you'd need to build filepath and cabal with the host compiler
09:53:22 <Igloo> dcoutts_: Yeah. What we do is cp -a cabal bootstrapping.cabal and then ghc --make Setup.hs -i../bootstrapping.cabal
09:53:28 <Igloo> So we could do the same for filepath
09:53:32 <dcoutts_> ok, good
09:54:11 <dcoutts_> Igloo: mnislaih is looking at removing Distribution.Compat.FilePath and replacing it with the new filepath
09:54:25 <mnislaih> yep, working on it right now
09:54:28 <Igloo> If we can make base small enough and get rid of relevant cbits, we could even plausibly do it for base...
09:54:30 <dcoutts_> yay
09:54:50 <Igloo> (please increase the font size for the letters 'I' and 'f')
09:54:59 <dcoutts_> hah hah
09:56:06 <dcoutts_> Igloo: as you know I'd like to see the mininal amount of libs built to get us a stage2, and then have all the libs (appart from the rts) built by the stage2 compiler under control of the package manger
09:56:29 <dcoutts_> hia SyntaxNinja !
09:56:38 <malcolmw> Looking at Control.Exception, it would be really useful to have a tool that could show be the dependencies between the functions implemented there.
09:56:44 <Igloo> dcoutts_: We already do have the minimal libs built to get us to stage2
09:56:54 <dcoutts_> SyntaxNinja: I'd like to prune some of the cabal-foo repos we've got on darcs.h.o
09:57:05 <dcoutts_> SyntaxNinja: do you know if cabal-builder is defunct?
09:57:22 <malcolmw> Even better if the dependency tool could tell me the minimal parts I need to implement such that I can use the code that is already there.
09:57:31 <dcoutts_> SyntaxNinja: looks like you wrote it and were the last to touch it
09:58:21 <dcoutts_> Igloo: right, but you install the libs that were built by stage1
09:58:55 <malcolmw> I have a Cabal tool you are all going to hate - it is a Makefile that parses the .cabal file but uses makefile facilities to do the actual building/installing :-)
09:59:03 <Igloo> dcoutts_: Yes (which would actually be trivial to avoid for gentoo)
09:59:24 <dcoutts_> Igloo: oh, ok. I'll bear that in mind.
09:59:28 <malcolmw> i.e. avoiding running any Cabal code whatsoever
09:59:28 <Igloo> malcolmw: Do you know about "Setup makefile"?
09:59:45 <SyntaxNinja> dcoutts_: yeah, it's defuncct
09:59:50 <malcolmw> Igloo: yes, I see that Cabal can now generate a Makefile
10:00:15 <malcolmw> Igloo: but my tool works the other way round  - a Makefile that can read a .cabal file
10:00:24 <Igloo> dcoutts_: If you just don't recurse into libraries/ when installing then I think it should Just Work. And you could easily make a make variable to control that
10:00:49 <SyntaxNinja> cabal generates makefiles?
10:00:50 <Igloo> malcolmw: Whatever rocks your boat  :-)
10:01:02 <dcoutts_> SyntaxNinja: ok, ta. One other thing, the cabal-install.cabal file says that the license is BSD4, but it looks like BSD3 to me. As I understnad it, BSD4 is the old one that has the annoying advertising clause, requiring everyone mention things in their advertising.
10:01:13 <malcolmw> Igloo: I figure it is shorter and more readable ;-)
10:01:29 <dcoutts_> SyntaxNinja: yeah, JaffaCake added that as a semi-temporary measure to let cabal build base.
10:01:34 * Igloo would ask for more info, but has to AFK...
10:01:46 <dcoutts_> SyntaxNinja: since ghc --make cannot build base (for various technical reasons)
10:02:06 <dcoutts_> SyntaxNinja: the right solution imho is for cabal to do proper dep analysis and stop using ghc --make.
10:02:56 <SyntaxNinja> dcoutts_: I prefer bsd3 :)
10:03:11 <malcolmw> I had another idea - to extend hmake to read .cabal files and do all the building
10:03:27 <SyntaxNinja> dcoutts_: yeah, I wish it would do that.  I don't think it would be very hard at all to have cabal do dependency analysis.
10:03:34 <dcoutts_> SyntaxNinja: so do I. I just wanted to check with you before I patch it to say BSD3 in the .cabal file, since it does bear your copyright notice.
10:03:35 <SyntaxNinja> in fact, I think most of te code is already there.
10:03:45 <SyntaxNinja> dcoutts_: yeah, change it, absolutely!
10:04:12 <dcoutts_> SyntaxNinja: ok will do. I didn't notice any code for dep analysis though.
10:04:24 <dcoutts_> SyntaxNinja: and we do need it for various other reasons, eg c2hs
10:04:48 <SyntaxNinja> dcoutts_: I thought someone wrote such code for c2hs
10:05:17 <dcoutts_> SyntaxNinja: kolmodin did, but it was fairly special case for c2hs, not a general pluggable framework for dep analysis
10:05:33 <dcoutts_> I might apply that patch anyway, if we can get it to work.
10:05:36 <SyntaxNinja> hmm
10:05:37 <malcolmw> SyntaxNinja: all of ghc --make, jhc, yhc, and hmake have dependency analysis code in them
10:05:45 <SyntaxNinja> malcolmw: right
10:05:49 <SyntaxNinja> malcolmw: so clearly, we should write another one.
10:05:54 <malcolmw> SyntaxNinja: exactly!
10:05:56 <dcoutts_> yes, we just need someone to do the work :-)
10:06:05 <SyntaxNinja> hm...
10:06:07 <dcoutts_> pull out the code from one or more and combine them
10:06:19 <dcoutts_> nad make it a bit more generic so we can do pre-processors
10:06:22 <SyntaxNinja> this is something that I'm sure I could do in a handful of days
10:06:32 <dcoutts_> (including chaining pre-processors!)
10:06:46 <SyntaxNinja> I'm out of town next week, and so I therefore will have no life, so maybe I can do it then, or at least look at it.
10:06:48 <malcolmw> Actually, the dependency analysis in hmake is totally unreadable, so don't take that one.
10:06:57 <SyntaxNinja> malcolmw: I know, I've tried to read it.
10:07:00 <SyntaxNinja> ;)
10:07:16 <dcoutts_> SyntaxNinja: another benefit of that is that setup configre/build should be able to figure out which pre-processors are actually required by a package
10:07:18 <malcolmw> SyntaxNinja: blame Thomas Hallgren ;-)
10:07:33 <SyntaxNinja> dcoutts_: that would be cool.
10:07:35 <dcoutts_> SyntaxNinja: so that we should only have to have configure look for the ones we need.
10:07:43 <SyntaxNinja> malcolmw: cool, will do, next time I see him on the train.
10:07:48 <malcolmw> dcoutts_: one thing that hmake does do well though is preprocessors
10:08:13 <dcoutts_> SyntaxNinja: I think in the end though, we should have the .cabal file list the build tools that are needed, like we do with libs.
10:08:47 <SyntaxNinja> dcoutts_: yeah, but then we're asking for a world of hurt... are we going to try to detect which version of happy is installed and stuff like that?
10:08:59 <dcoutts_> SyntaxNinja: build could tell you when it discovers it needed to use a tool you didn't list.
10:09:05 <SyntaxNinja> _maybe_ we could do this for tools that promise to give standard output or something
10:09:08 <dcoutts_> SyntaxNinja: we already do that.
10:09:21 <dcoutts_> we discover the version of happy, haddock, c2hs etc
10:09:43 <dcoutts_> we should ask that any new ones we support provide a --numeric-version flag like ghc and c2hs do.
10:09:49 <SyntaxNinja> yeah.
10:11:02 <dcoutts_> SyntaxNinja: since I think it turns out that you cannot detect all the pre-processors required by a configure-time dep anlysis, since it may require *running* some pre-processors to discover the whole dep tree.
10:11:27 <SyntaxNinja> dcoutts_: why would it require running them?
10:11:42 <dcoutts_> SyntaxNinja: so cabal could check that you've listed all the right pre-processors, but not discover it automatically at configure time, so I think it's best to have them listed explicitly.
10:12:21 <dcoutts_> SyntaxNinja: you cant find the deps of a .hs.pp file without running cpp. It may depend on another module that itself needs some pre-processor to generate it.
10:12:36 * SyntaxNinja nods
10:12:56 <dcoutts_> SyntaxNinja: so we must interleave pre-processing with dep chasing
10:13:01 <malcolmw> and if the cpp symbols are just right, the preprocessor is not required
10:13:44 <malcolmw> surely cpp is the only preprocessor that falls into that category though
10:13:54 <dcoutts_> SyntaxNinja: so just like we require lib deps to be listed and we ignore ones not listed, we should do the same with build tools.
10:14:01 <dcoutts_> malcolmw: I don't follow.
10:14:02 <malcolmw> I'm not aware of any conditional stuff in happy, alex, c2hs, etc
10:14:11 <dcoutts_> malcolmw: c2hs has conditional stuff
10:14:35 <malcolmw> dcoutts_: oh? so running c2hs can determine which other modules need to be imported?
10:15:12 <malcolmw> dcoutts_: if so, then fair enough
10:15:19 <dcoutts_> malcolmw: and in general it may not be possible to find the deps sensibly without running the pre-processor. Eg even with happy, the impoted modules varies with the 'wrapper' you choose.
10:15:35 <dcoutts_> malcolmw: eg if you use the bytestring wrapper then happy will import Data.ByteString for you.
10:15:36 * malcolmw is persuaded
10:16:10 <malcolmw> dcoutts_: ah yes, if you want your parser to run *really* slowly :-) in nhc98
10:16:17 <dcoutts_> heh :-)
10:16:30 <dcoutts_> malcolmw: with c2hs it's because it sort-of integrates cpp
10:16:51 <dcoutts_> you can mix #ifdefs and #c fragments etc
10:17:24 <malcolmw> dcoutts_: I had the impression that in c2hs it was more about conditionally including C header than Haskell imports, but hey, it's a general mechanism that people can use and abuse as they like
10:18:29 <dcoutts_> malcolmw: that's the intention, that it's for conditional c header stuff, but nothing prevents it being abused for changing Haskell imports (or even c2hs {# import #} hooks)
10:25:12 <hpaste>  fridim pasted "some begginer questions" at http://hpaste.org/1697
10:26:23 <LeCamarade> fridim: Because that is wrong syntax.
10:26:33 <LeCamarade> In fact, it could have been with no (), but ...
10:26:48 <fridim> x:xs:[] ?
10:27:09 <LeCamarade> The : is a legal operator in Haskell (cons), so it ends up trying to evaluate.
10:27:12 <mauke> x1:x2:[] is the same as [x1,x2]
10:27:24 <LeCamarade> > 1:2:3:[]
10:27:28 <lambdabot>  [1,2,3]
10:27:36 <fridim> so could it be written  [x, xs] instead of (x:xs) ?
10:27:41 <LeCamarade> > [1:2:3[]]
10:27:43 <lambdabot>   add an instance declaration for (Num ([a] -> [t]))
10:27:51 <LeCamarade> > [1:2:3:[]]
10:27:53 <lambdabot>  [[1,2,3]]
10:27:57 <bd_> fridim: not quite, [x, xs] == (x:xs:[])
10:28:15 <fridim> so what is (x:xs) ?
10:28:21 <bd_> fridim: the difference is, in (x:xs), xs is a list, and x an element. In [x, xs], both are elements.
10:28:36 <fridim> ok, I got it
10:28:47 <fridim> the last element of x:x:x:x:last  is a list ?
10:28:53 <bd_> yep
10:29:02 <bd_> and the elements are each tacked onto the beginning
10:29:03 <LeCamarade> fridim: Yes, even when it is empty.
10:29:11 <LeCamarade> > 2:[]
10:29:13 <lambdabot>  [2]
10:30:37 <fridim> the second question :   why   firstElement [] = Nothing      firstElement (x:xs) = x    is not enough ?
10:32:05 <mauke> because that restricts the list type
10:32:20 <MyCatVerbs> fridim: the type inference mechanism screamed at you? Replace x with "Just x".
10:32:26 <LeCamarade> Because x is not of the same type as Nothing, and yet since that is the same func, it should return the same type.
10:32:30 <mauke> Nothing :: Maybe a, so x :: Maybe a, so firstElement :: [Maybe a] -> Maybe a
10:32:32 <LeCamarade> @type Nothing
10:32:35 <lambdabot> forall a. Maybe a
10:32:42 <LeCamarade> @type Just 2
10:32:45 <lambdabot> forall t. (Num t) => Maybe t
10:33:00 <LeCamarade> Both are of the Maybe type class.
10:33:02 <fridim> mh ok
10:33:19 <mauke> Maybe is not a class
10:33:27 <fridim> This is not the easier part of YAHT :)
10:33:43 <mauke> fridim: what languages do you know?
10:34:13 <fridim> C, Perl, PHP, (some python, java), SQL
10:34:47 <mauke> ok, this is like trying to return an int from a function that's declared to return an int_wrapper
10:34:51 <mauke> (or maybe an int *)
10:37:36 <mauke> typedef struct { enum { Nothing, Just } type; int x; } IntWrapper;  IntWrapper firstElement(IntList z) { if (isEmpty(z)) return (IntWrapper){ Nothing }; else return (IntWrapper){ Just, head(z) }; }
10:37:41 <mauke> huhu
10:37:55 <fridim> :)
10:38:46 <mauke> you can't just return head(z) because that's not the right type
10:46:33 <LeCamarade> @slap
10:46:33 <lambdabot> why on earth would I slap
10:46:38 <Eelis> in C++, of course, you get a nice implicit conversion:  boost::optional<int> divide (int x, int y) { if (y == 0) return boost::optional<int>(); else return x / y; }
10:47:42 <mauke> oh god
10:47:50 <dolio> That certainly does look nice. :)
10:47:53 <int-e> @type let divide x y = guard (y/=0) >>= liftM2 div x y in divide
10:48:02 <lambdabot> forall (m :: * -> *) b. (Num (() -> m b), Integral (m b), MonadPlus m) => (() -> m b) -> (() -> m b) -> m b
10:48:20 <int-e> @type let divide x y = guard (y/=0) >> liftM2 div x y in divide
10:48:23 <lambdabot> forall (m :: * -> *) a1. (Num (m a1), Integral a1, MonadPlus m) => m a1 -> m a1 -> m a1
10:48:35 <mauke> hmm, that gives me an idea
10:48:51 <mauke> too bad 'default' is a keyword
10:49:08 <dolio> @type let divide x y = guard (y /= 0) >> return (div x y) in divide
10:49:11 <lambdabot> forall a (m :: * -> *). (Integral a, MonadPlus m) => a -> a -> m a
10:49:32 <int-e> dolio: right. silly me.
10:49:45 <mauke> Eelis: what's a good name for a default object?
10:49:56 <Eelis> mauke: there's boost::none :)
10:50:24 <nominolo> zero
10:50:33 <nominolo> @src MonadPlus
10:50:33 <lambdabot> Source not found. My pet ferret can type better than you!
10:50:52 <int-e> mauke: Nothing ;-)
10:51:36 <dolio> nominolo: class (Monad m) => MonadPlus m where { mzero :: m a ; mplus :: m a -> m a -> m a }
10:51:49 <nominolo> yeah, it's mzero instead of zero
10:51:55 <nominolo> so zero is free
10:52:04 <int-e> mauke: defaultValue? it's long. fallback?
10:52:08 <mauke> Eelis: but that's optional specific
10:52:27 <int-e> mauke: but fallback is probably more suggestive than you like
10:52:42 <mauke> "whatever"
10:53:23 <nominolo> "auto"
10:53:54 <Eelis> mauke: it's not optional specific. boost/none.hpp and boost/none_t.hpp are separate
10:53:55 <mauke> auto is also a keyword
10:54:20 <nominolo> really?
10:54:29 <nominolo> @where syntax
10:54:30 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
10:55:11 <nominolo> in C/C++ it is, but what's it used for in haskell?
10:55:21 <mauke> Eelis: wait, that doesn't do what I want. none is a null pointer!
10:55:34 <Eelis> mauke: i don't know what it is that you want
10:56:28 <dolio> > let auto = 6 in auto
10:56:36 <lambdabot>  6
10:59:26 <shapr> w00 code!
11:00:22 <mauke> Eelis: http://rafb.net/p/EqhXEZ50.html
11:00:24 <lambdabot> Title: Nopaste - No description
11:01:31 <Eelis> mauke: what's that supposed to do?
11:01:50 <mauke> demonstrate the use of 'whatever'
11:02:07 <Eelis> it's not a demonstration if i cannot derive any semantics from it
11:02:39 <mauke> 'whatever' is a default-initialized object of any type
11:03:06 <Eelis> i've only ever used something like that once; in the analog literals
11:03:08 <Mushy-pea> Hi.
11:04:22 <mauke> ok, why doesn't boost::optional have sane output semantics?
11:04:30 <mauke> (it prints as "1")
11:04:52 <Mushy-pea> I got a new laptop last week with two processors in it.  Can anyone tell me if there are any Haskell libraries to aid parallel programming?
11:04:58 <Eelis> beats me. probably the same reason why std::pair isn't streamable.
11:05:11 <kpreid> @docs Control.Parallel
11:05:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel.html
11:05:41 <kpreid> @docs Control.Parallel.Strategies
11:05:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
11:05:45 <Mushy-pea> ?bot thanks?
11:05:45 <lambdabot> :)
11:06:06 <Mushy-pea> ....and kpreid
11:06:39 * shapr hugs dons
11:06:41 <kpreid> there's also an RTS option you have to enable to tell it to use multiple processors
11:06:44 <shapr> dons++ -- for great justice!
11:06:55 <mauke> Eelis: anyway, { return y == 0 ? whatever : x / y; }
11:09:10 <Eelis> mauke: then you can't distinguish between 0 as an actual result value and 0 as whatever
11:09:19 <sioraiocht> @src (^^)
11:09:19 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
11:09:46 <sioraiocht> > x ^^ 2
11:09:49 <Eelis> mauke: oh, you mean with the optional<int> return type. yeah, that'll work fine.
11:09:51 <lambdabot>   Not in scope: `x'
11:10:01 <sioraiocht> > 4 ^^ (-2)
11:10:03 <lambdabot>  6.25e-2
11:10:12 <sioraiocht> > 1 / 16
11:10:13 <mauke> Eelis: not quite
11:10:14 <lambdabot>  6.25e-2
11:10:23 <mauke> Eelis: it needs to be if (y == 0) return whatever; else return x / y; :/
11:10:38 <sioraiocht> > 4 ^ (-2)
11:10:39 <mauke> otherwise it'll unify whatever and x / y to int first
11:10:40 <lambdabot>  Exception: Prelude.^: negative exponent
11:11:01 <Eelis> mauke: i see.
11:12:32 <shapr> dcoutts: Oh look, he responded.. http://lwn.net/Articles/232812/ but I'm trying to think up some viewpoint that would let him believe what he says. I try to see things from the viewpoint of the person talking to me, but I'm just lost here.
11:12:34 <lambdabot> Title: LWN: What's practical?
11:13:54 <dcoutts_> shapr: so his concern is about putting 'resources' inside other structures and getting semi-automatic management
11:14:06 <shapr> But that can already be done with Haskell?
11:14:17 <dcoutts_> shapr: that of course relies on those structures being managed properly
11:14:39 <dcoutts_> which comes back to the same top level issue
11:14:57 <shapr> You mean, that he doesn't know much about anything outside of C++?
11:15:04 <dcoutts_> you either block scope resources, or rely on the GC + finalisers or do a more cunning custom scheme
11:15:19 <dcoutts_> eg you can implement pools using monads
11:15:29 <dcoutts_> run does the freeing at the end
11:15:36 <dolio> Is "Eager Haskell" even available anywhere?
11:15:44 <shapr> Yeah, I think it is.
11:15:46 <dcoutts_> dolio: no, it was a research project
11:15:57 <shapr> Maybe pH is available?
11:16:11 <dcoutts_> well it might be available but it's not practical, in the sense that I don't think it actually works
11:16:14 <shapr> I know Jan Willem Maessan worked on both of them.
11:16:20 <dcoutts_> not with current software
11:16:26 <shapr> Yeah, speculative evaluation would make more sense.
11:16:41 <shapr> Plus, I don't want strict Haskell, I'd lose all my logic modularity :-(
11:16:43 <dcoutts_> shapr: that's mostly what it was doing as I understood it
11:17:24 <pitecus> How do i include the literal character % in the format string to Printf.printf?
11:17:39 <dmwit> %%
11:17:40 <MyCatVerbs> pitecus: %%
11:17:40 <int-e> > printf "%%" :: String
11:17:42 <lambdabot>  "%"
11:17:47 <pitecus> thanks
11:17:53 <MyCatVerbs> :t printf
11:17:55 <lambdabot> forall r. (PrintfType r) => String -> r
11:17:57 <shapr> dcoutts_: Any idea what he's talking about with centralized error handling?
11:18:49 <dcoutts_> shapr: perhaps he's referring to the fact that C++ destructors for stack allocated objects always run even when there are exceptions?
11:19:02 * shapr blinks cluelessly
11:19:02 <LeCamarade> @list
11:19:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:19:18 * dolio mutters at his router.
11:19:20 <MyCatVerbs> dcoutts_: they do?
11:19:28 <dcoutts_> MyCatVerbs: sure
11:19:36 <shapr> Huh
11:19:48 * dmwit mutters at himself.
11:20:05 <MyCatVerbs> dcoutts_: my first thought: "Who, I bet at least half the compilers on the market don't correctly implement that part of the spec. I could write some really *hilariously* nonportable code like that."
11:20:06 <dcoutts_> shapr: of course the fact that C++ cannot abstract memory management makes his points, um interesting :-)
11:20:38 <dcoutts_> shapr: you can't build modular programs when you have to keep track of who ownes which pointers, is it the caller or callee?
11:20:41 <shapr> Yeah, my first thought was that GC already IS abstract management of non-memory resources.
11:20:56 <dcoutts_> shapr: you can't even compose function since what about freeing the intermediate result?
11:21:04 <Eelis> i wish Haskell had a decent equivalent of C++'s RAII
11:21:10 <sjanssen> dcoutts_: well, there are smart pointers in C++
11:21:12 <dcoutts_> RAII== ?
11:21:22 <dcoutts_> sjanssen: so that's ok for single owner
11:21:31 <sjanssen> Resource Acquisition Is Initialization
11:21:38 <dcoutts_> ahh
11:21:45 <Eelis> "Scope Bound Resource Management is a powerful idiom based on the idea of acquiring resources in constructors and releasing them in destructors. C++ guarantees that destructors are automatically called for variables when they go out of scope, thereby transparently ensuring proper cleanup - even in the face of exceptions.  Popularly called "RAII""
11:21:46 <dmwit> smart constructors?
11:21:58 <sjanssen> dcoutts_: you can do multiple owner things with a referenced counted smart pointer
11:22:23 <dcoutts_> Eelis: there are functions like bracket, and you'll see withFoo constructs quite a lot which do that
11:22:27 <sjanssen> Haskell can do RAII very easily
11:22:36 <sjanssen> see alloca, withMVar, etc.
11:22:41 <Eelis> dcoutts_: i know. i consider that a silly workaround.
11:23:01 <dcoutts_> Eelis: why is that?
11:23:14 <Eelis> i wrote a blog comment about it somewhere. let's see if i can find it
11:23:24 <dcoutts_> withFoo $ \foo -> ...
11:23:35 <dcoutts_> encapsulates the creation, use and release of resource foo
11:23:41 <dcoutts_> and it's customisable
11:23:44 <sjanssen> I'll take garbage collection and with* constructs over manual memory management any day of the week
11:23:50 <shapr> Yeah, me too.
11:23:52 <Eelis> see my comment in http://notes-on-haskell.blogspot.com/2007/03/design-patterns-in-haskell-bracket.html
11:23:55 <lambdabot> Title: Notes on Haskell: Design Patterns in Haskell: bracket, http://tinyurl.com/yorrpk
11:25:48 <shapr> Eelis: Submit a withResource library!
11:25:49 <dcoutts_> sjanssen: right, so ref-counted smart pointers do a bit more, though I seem to recall there is some trickiness with them. Why are they not in the standard lib for example? Why only the single owner smart ptr ?
11:26:14 <Eelis> shapr: hehe, way too much trouble for 2 lines of code ;)
11:26:28 <Eelis> or 3
11:26:49 <Eelis> it should just be part of the standard library
11:26:49 <shapr> Eelis: If it bothers you, fix it! That's the open source way!
11:26:59 <shapr> You can submit things to the standard libraries too.
11:27:10 <sjanssen> dcoutts_: I'm not sure why there aren't more smart pointers in C++
11:27:28 <Eelis> sjanssen: the next version of C++ will have many more in the standard library
11:27:35 <Eelis> (due in 2009)
11:27:54 <sjanssen> dcoutts_: I bet cycle detection is hard/impossible
11:27:57 <Eelis> shapr: i can't be bothered to start lobbying
11:28:20 <dcoutts_> Eelis: I hear rumours about GC in C++, that you could use it on a per-class basis or something, like an allocator
11:28:53 <Eelis> dcoutts_: i'm extremely skeptical about the proposals to add GC to C++. i suspect it may turn into a disaster.
11:28:58 <eumenides> where's the toIntegral?
11:29:09 <dcoutts_> eumenides: it's called fromIntegral
11:29:33 <shapr> C'mon, if it's important enough to wish for, it's important enough to fix, yeah?
11:29:59 <eumenides> dcoutts_: no, wait. i want Double -> Int :)
11:30:00 <Eelis> shapr: i would have to convince people that it actually needs fixing :)
11:30:07 <shapr> You don't have to lobby, if you just write it and send it to haskell-cafe, somebody might start using it.
11:30:12 <int-e> eumenides: you have to choose from round, ceiling, floor or truncate
11:30:13 <mauke> :t round
11:30:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:30:20 <dcoutts_> Eelis: it'll be interesting to watch the C++ GC issue
11:30:26 <eumenides> int-e: ooh right doh!
11:30:32 <shapr> Eelis: If your typeclass makes life easier for people then it will get used.
11:30:54 <monochrom> round, ceiling, floor, truncate are not the only choices. there are also round-to-even and round-to-odd.
11:30:58 <Eelis> dcoutts_: i agree :)
11:31:14 <dcoutts_> shapr: I'm not so sure it's that helpful, really nice withFoo functions encapsulate the allocation too, just just a use + close.
11:31:37 <dcoutts_> shapr: so they need to be per-type since they may take constructor args etc
11:31:49 <LPhas> http://swik.net/Haskell/del.icio.us+tag%2Fhaskell/Haskell+Records+Considered+Grungy+%C2%AB+::+(Bloggable+a)+%3D%3E+a+-%3E+IO+()/40u6
11:31:51 <lambdabot> Title: Haskell Records Considered Grungy  :: (Bloggable a) => a -> IO () - SWiK, http://tinyurl.com/37zrfm
11:31:54 <LPhas> this article is cool
11:31:58 <mauke> Eelis: re: you have to remember to use the withFoo wrapper - in C++ you have to remember to say Foo tmp;
11:32:10 <Eelis> mauke: uhm.. you can't forget that
11:32:12 <sjanssen> mauke++
11:32:35 <mauke> Eelis: you can't forget the withFoo either if it's the only constructor
11:33:06 <Eelis> mauke: sure, but that's not how Haskell folks design their libraries apparently.
11:33:29 <sjanssen> another point: you don't have to remember to call hClose at all, as long as you toss all references to the handle
11:33:32 <mauke> and most C++ programmers don't use smart pointers for memory management apparently
11:33:57 <dcoutts_> mauke: Eelis: for example in the cairo svg lib, we provide a number of constructors for expensive svg objects, one is bracketed the other is GC-managed, so you get to choose if you care about the resource management or not.
11:34:10 <Cheery> Is there ways to deal with infinite recursive structures, where I should get a set of records between any interval, but never everything?
11:34:12 <Eelis> mauke: i'm (reluctantly) arguing for an addition to the Haskell standard library. i fail to see how C++ inadequacies can be meaningful counter-arguments
11:34:27 <Cheery> ie. what kind of algorithms does those?
11:34:41 <dcoutts_> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo-SVG.html
11:34:43 <lambdabot> http://tinyurl.com/2ccpmj
11:35:02 <Cheery> say, I'd like to get something between interval: [20,30], and [8000,8010] with the same performance
11:35:08 <mauke> Eelis: I'm not saying your proposal is bad, I just don't see how C++-style RAII is better than what Haskell does
11:35:33 <nominolo> LPhas: your code is cut off on the right
11:35:36 <dcoutts_> Eelis: the type class approach seems tricky, for example see the withSvgFromFile :: FilePath -> (SVG -> Render a) -> Render a
11:35:52 <LeCamarade> Is there some API that lambdabot's `tiny' module uses? Definitely not parsing a page from tinyurl.com ... is it a well-known algorithm? Al Gore Rhythm?
11:36:23 <flux> hmm.. I don't see how else it _could_ work, except by requesting an url from tinyurl.com
11:36:29 <dcoutts_> Eelis: it takes one constructor arg and we've got various interesting types, we can have the type class abstract over those types, but I'm not so sure about the constructor args.
11:36:41 <flux> it's not like the whole url is compressed into a tiny sequence
11:37:04 <dolio> Tinyurl allocates new codes on the fly, doesn't it? When they're requested?
11:37:07 <dcoutts_> Eelis: you're looking for a really generic 'with' function right?
11:37:11 <Eelis> dcoutts_: yes, the IOResource type class would be a "fix" for libraries whose resource types aren't bracket-guarded by themselves
11:37:22 <dolio> Unless it's already given a code to a page.
11:37:35 <LeCamarade> flux: Since they return the same tiny URL for the same URI, there must be some Haskellish algorithm. Anyway, LB does it too fast and too frequently for it to be a call to tinyurl.com
11:37:44 <dcoutts_> Eelis: oh, I thought we were trying to make a unified interface for all these withFoo functions
11:37:52 <LeCamarade> @tiny http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:37:54 <lambdabot> http://tinyurl.com/jz56b
11:38:13 <LPhas> nominolo: @google Haskell Records Considered Grungy
11:38:16 <flux> lambdabot, well, obviously the first the the data is input to the database, the second time it's retrieved from it. hence one url always corresponds to the same tinyurl
11:38:25 <flux> +time
11:38:31 <LPhas> @google Haskell Records Considered Grungy
11:38:33 <lambdabot> http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
11:38:33 <lambdabot> Title: Haskell Records Considered Grungy  :: (Bloggable a) => a -> IO ()
11:38:42 <nominolo> i know that one
11:38:58 <Eelis> dcoutts_: well, it would achieve that for the aforementioned libraries, since for those the client code would always look like   withResource (someLibFuncThatReturnsAResource x y z) $ \r -> do ...
11:39:10 <nominolo> i was saying, that the code examples in you blog are cut off on the right
11:39:14 <dcoutts_> Eelis: but, yes, a way of doing it for things that don't provdide withFoo functions would be nice and useful too.
11:40:06 <LeCamarade> flux: You mean they are ready to archive every last long URL under the sun? Well, why not? It's the data. Web 2.0. :oD
11:40:28 <dcoutts_> Eelis: so we put that resource type (eg Handle) into this Resource class and then withResource takes the partially applied constructor function and calls the body and then the per-resource-type close function at the end of the block. Sounds good to me.
11:40:46 <dcoutts_> @hpaste
11:40:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:41:26 <flux> lecamarade, [a-zA-Z0-9]{6} can encode 56800235584 urls
11:41:40 <flux> lecamarade, how many urls do you think people have asked tinyurl about?
11:41:55 <flux> (I don't know but I guess that's the range it uses)
11:42:00 <monochrom> > log 56800235584 / log 2
11:42:01 <lambdabot>  35.72517786232125
11:42:33 <Eelis> dcoutts_: the bottom line is: how much do you need to remember to use the library's resource type? for libraries that strictly use   withFoo x y z $ \foo ->  , the optimum is already achieved. my beef is with libraries for which i have to remember both constructor and "destructor"
11:42:37 <dolio> flux: They used 4 and then 5 character strings at one point, too.
11:42:46 <dcoutts_> Eelis: yes.
11:42:51 <flux> dolio, I guess in the beginning they used 1 character?-)
11:42:52 <dolio> flux: Presumably they've gone through all those already.
11:42:54 <LeCamarade> flux: Yeah, not like it eats up space, but ... well, their servers!
11:43:11 <LeCamarade> So I have to query them? Sad.
11:43:30 <Eelis> dcoutts_: i didn't completely get your partially applied constructor idea. can you sketch an example?
11:43:32 <monochrom> I sympathize with the server.
11:43:45 <hpaste>  dcoutts pasted "withResource" at http://hpaste.org/1698
11:43:50 <dcoutts_> Eelis: ^^
11:43:56 <Eelis> thanks :)
11:44:30 <flux> given the small amount of data, I doubt tinyurl servers get loaded much
11:45:09 <MeMeN> im practicing some questions for my exam, how do i go about writing a function member using fold?
11:45:22 <hpaste>  dcoutts annotated "withResource" with "example of use" at http://hpaste.org/1698#a1
11:45:25 <MeMeN> doesn't fold just distribute a dyadic function over a list?
11:45:36 <MeMeN> how can i use it to check membership? :(
11:45:57 <dcoutts_> Eelis: seem like what we want?
11:46:24 <mauke> member k [x1, x2, x3, ...] = k == x1 || k == x2 || k == x3 || ...
11:46:34 <Eelis> dcoutts_: it doesn't seem to want to compile
11:46:54 <dcoutts_> Eelis: gah! you didn't expect me to test it did you! :-)
11:47:05 <dcoutts_> Eelis: probably need to import System.IO (Handle)
11:47:07 <MeMeN> mauke : wha?
11:47:24 <mauke> MeMeN: hmm?
11:47:25 <dcoutts_> Eelis: oh and import System.IO (Handle, hClose)
11:47:29 <Eelis> dcoutts_: i come from the land of C++, which isn't so close to pseudocode that we can forego testing ;)
11:47:30 <MeMeN> mauke : lol
11:47:39 <dcoutts_> Eelis: heh heh ;-)
11:47:58 <dolio> MeMeN: Suppose you were allowed a map and then a fold.
11:48:07 <MeMeN> right
11:48:08 <MeMeN> so
11:48:10 <dolio> And then since you can write a map as a fold...
11:48:14 <MeMeN> ah
11:48:18 <MeMeN> <-- twit
11:48:23 <mauke> member k [] = False; member k (x : xs) = k == x || member k xs
11:48:56 <Eelis> anyway, that's basically identical to what i did in my comment at that blog, right?
11:49:28 <dcoutts_> Eelis: pretty much, yes, but with an implementation behind it.
11:49:28 <dolio> There should be a way to fuse the two, as well. Something like: 'foldr k z . map f == foldr (k . f) z'
11:49:36 <MeMeN> mauke : what would be the difference when we use foldr to write member rather than foldl?
11:49:46 <dcoutts_> Eelis: oh wait, you had an impl too. I missed that :-)
11:49:53 <Eelis> dcoutts_: yeah :)
11:50:01 <dcoutts_> sorry :-)
11:50:24 <dolio> @free foldr
11:50:33 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:50:44 <dcoutts_> Eelis: so basically, yes. I think it's a reasonable idea, probably worth proposing.
11:51:02 <dcoutts_> shapr: do you want to bring up the idea on the libraries list ?
11:51:14 <shapr> Sure, fine by me.
11:51:34 <mauke> MeMeN: I think foldl doesn't work with infinite lists
11:51:55 <Eelis> uh-oh, now you're making me feel guilty for making you do the work :(
11:52:02 <MeMeN> mauke: yeah because we recurse immediatly
11:52:28 <dcoutts_> shapr: an example apart from files and db connections is my svg lib, having a generic withResource would make the api simpler
11:52:29 <mauke> foldr can stop as soon as it finds the element
11:52:59 <dcoutts_> shapr: I've got 3x2 constructors, if we had a generic with we'd only need 3
11:53:07 <shapr> Eelis: Would you rather propose it? I don't mind one way or the other. I'll give you credit for the idea if I propose it :-)
11:53:09 <Eelis> shapr/dcoutts_: anyway, thanks for taking this up. i'll keep an eye on the libs list
11:53:28 <Eelis> shapr: no, go ahead. and don't bother with credit, it's a 3 line idea!
11:53:33 <dcoutts_> Eelis: s'ok shapr is an insider who knows how to go about proposing things :-)
11:53:43 <Eelis> excellent ;)
11:54:13 <mauke> bah, compiling gcc
11:54:19 <dcoutts_> and shapr writes real IOish code for money so everyone knows that he knows that he's talking from experience
11:54:20 <shapr> heh, I'm doing insider trading! w00!
11:54:27 <shapr> I am?
11:54:28 <dcoutts_> heh heh
11:54:34 <dcoutts_> shapr: sure :-)
11:54:49 <shapr> Hm, I guess HAppS does lots of IOish stuff.
11:55:03 <shapr> Eelis: Yeah, I have two Haskell jobs, so I have some experience.
11:55:15 <Eelis> i see
11:55:19 <dcoutts_> shapr: withResource (SVG.newfromFile "foo.svg") $ \svg -> do ...
11:55:35 <dcoutts_> shapr: see the current api: http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo-SVG.html
11:55:37 <lambdabot> http://tinyurl.com/2ccpmj
11:56:50 <shapr> Eelis: And because I like Haskell and don't think it's perfect yet, when someone suggests an idea like you did, I want to investigate. If it's good, I watn to have it!
11:57:28 <Eelis> shapr: that's the spirit :)
11:57:39 <dcoutts_> shapr: what would be really good, is if we can make it subsume Foreign.Marshal.Utils.with
11:58:04 <dcoutts_> shapr: and I think we can, all that would be is the instance for Storable a => Ptr a
11:58:25 <dcoutts_> shapr: which means we can call it merely 'with' rather than a long name like withResource
11:58:38 <Eelis> that would be nice!
11:59:12 <shapr> Yay!
11:59:26 <shapr> I probably won't have time to write something to the libraries list till this weekend, I have lots of Haskell work to do.
12:00:01 <Eelis> there's no hurry
12:00:03 <shapr> But after that, improvement!
12:01:42 <dcoutts_> shapr: hmm, actually Foreign.Marshal.Utils.with is a bit different
12:02:08 <Nafai> shapr: You have 2 Haskell jobs?
12:05:09 <ttt-> how do you get a haskell job?
12:05:16 <astrolabe> Does anyone know a good place to read about rank-2 polymorphism?
12:06:51 <ttt-> i dont even nkow what it means
12:07:15 <astrolabe> The problem is, neither do I.
12:07:17 <Eelis> astrolabe: http://hackage.haskell.org/trac/haskell-prime/wiki/Rank2Types
12:07:19 <lambdabot> Title: Rank2Types - Haskell Prime - Trac
12:07:28 <astrolabe> Eelis: thank you
12:09:53 <astrolabe> Though that doesn't actually explain what a rank 2 type is as far as I can see.
12:10:44 <mauke> I think it's a type containing forall somewhere in the middle
12:11:48 <astrolabe> mauki: that seems to be right, but I don't know what the semantics of that are.
12:12:26 <mauke> it has the obvious meaning :-)
12:13:14 <dolio> ?type let w x = x x in w
12:13:17 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:13:17 <lambdabot>     Probable cause: `x' is applied to too many arguments
12:13:18 <astrolabe> For me, there is no such meaning
12:13:25 <dolio> ?type (let w :: forall b. (forall a. a) -> b ; w x = x x in w)
12:13:28 <lambdabot> forall b. (forall a. a) -> b
12:13:36 <mauke> foo :: (forall a. a -> a) -> b -> c -> (b, c); foo g x y = (g x, g y)
12:14:35 <Saizan> > let foo f = (f 1,f "a") in foo show
12:14:36 <lambdabot>   add an instance declaration for (Num [Char])
12:15:01 <mauke> heh, that tries to unify the types of 1 and "a"
12:15:07 <Saizan> > let foo:: (forall a. Show a => a -> String) -> (String,String); foo f = (f 1,f "a") in foo show
12:15:08 <lambdabot>  Parse error
12:15:22 <Saizan> well we don't have flasgow-exts here..
12:17:12 <Saizan> *Test> :set -fglasgow-exts
12:17:13 <Saizan> *Test> let foo:: (forall a. (Show a) => a -> String) -> (String,String); foo f = (f 1,f "a") in foo show
12:17:16 <Saizan> ("1","\"a\"")
12:17:28 <Saizan> this works because foo is rank2
12:18:25 <shapr> Nafai: Yeah, TWO!
12:18:33 <shapr> Nafai: Less sleep, more code!
12:18:37 <astrolabe> Thanks.  Now I'm getting a headache.
12:18:58 <mauke> it's just polymorphism
12:19:56 <astrolabe> Ah I think I'm getting something
12:19:58 <dolio> The idea is, if you have '(a -> String) -> (String, String)', then for the whole function, a can only be set to one type.
12:20:28 <dolio> Or, one scheme, I suppose.
12:20:34 <astrolabe> You can give a type signature that says that one of a functions arguments is polymorphic
12:20:46 <mauke> yes
12:20:49 <dolio> So it tries to find a scheme that includes both '1' and '"a"', but that doesn't work.
12:21:27 <astrolabe> Ah.  Right. Thanks everybody.
12:23:25 <eumenides> where could i easily upload a 6kb .hs file and have it stay there hopefully indefinitely?
12:24:26 <Saizan> google?
12:24:44 <eumenides> hm
12:24:44 <LeCamarade> Saizan: :oD
12:25:07 <LeCamarade> eumenides: Get a page somewhere. Google Pages, et cetera.
12:26:21 * dcoutts_ notes that he just uploaded a package for the first time using cabal-upload
12:26:32 <dcoutts_> you can now get filepath-1.0 from hackage
12:26:52 <shapr> yay!
12:26:54 <dcoutts_> however cabal-upload does not build 'out of the box' it needs a patched http lib
12:27:00 <shapr> How do I install directly from hackage?
12:27:16 <Saizan> cabal-install install <package>
12:27:28 <dcoutts_> shapr: hold on a mo
12:27:47 <dcoutts_> shapr: I want to push some cabal-install patches and I want you to test them :-)
12:27:53 <shapr> Yay!
12:28:14 <dcoutts_> shapr: weirdly, the http browser lib has functions that are not exported and not otherwise used. cabal-upload needs those functions
12:28:14 <shapr> Which repo has cabal-install? Main cabal repo?
12:28:21 <shapr> heh, amusing
12:28:33 <shapr> Bringert is very responsive.
12:28:37 <dcoutts_> shapr: we need to get bringert and ross to talk to each other on that one
12:28:50 <dcoutts_> shapr: or we need to fix it ourselves and do a new release
12:29:54 <shapr> Hm, I like the second approach.
12:30:21 <shapr> I suspect bringert is busy right now, and will be for a few days.
12:32:00 <shapr> Hm, cabal-install is in its own repo?
12:32:40 <Saizan> d.h.o/packages/cabal-install/ iirc
12:32:54 <shapr> Thanks
12:38:49 * LeCamarade had never ever ever ever used OCaml's lazy keyword. Until he did Haskell, the sweetest of them all. Being lazy with class.
12:43:24 <MyCatVerbs> LeCamarade: OCaML has lazy evaluation, but you have to explicitly turn it on?
12:43:46 <LeCamarade> MyCatVerbs: yep.
12:43:52 <Cale> Having to explicitly turn on lazy evaluation almost defeats the point of it being there in the first place.
12:43:59 <LeCamarade> And it looked like a silly idea, before.
12:44:49 <LeCamarade> Cale: In fact, I think Haskell taught me three important things: IO is evil, even though unavoidable. Lazy eval should be the default eval strategy. Monads exist.
12:44:55 <Cale> :)
12:44:59 <fridim> is there an HTML version of YAHT ?
12:45:06 <Cale> fridim: yes
12:45:17 <Cale> fridim: It's even wikified. We should work on it more :)
12:45:22 <LeCamarade> @go Yet Another Haskell Tutorial site:en.wikibooks.org
12:45:25 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
12:45:29 <fridim> I currently use the pdf, but evince use 120mo of RAM :/
12:45:34 <Cale> wow.
12:46:36 <Cale> Then again, I just restarted firefox for using 400MiB of memory. (There was some java_vm loaded using lots of memory even after I had browsed away from whatever page had started it)
12:47:16 <fridim> Here, firefox usually uses 120mo
12:47:18 <monochrom> I am not so sure that lazy evaluation should be the default.
12:47:46 <monochrom> I am slightly convinced by Cale.
12:47:53 <fridim> (that is still huge)
12:48:12 <dfranke> damnit.  -HEAD is crapping out again.
12:49:03 <norpan> well, any non-strict evaluation strategy is fine with me
12:49:49 <flux> cale, have you noticed the X-server also shrinking considerably after shutting ff down?
12:49:53 <nominolo> Cale: MiB /= MB, isn't it?
12:50:23 <sjanssen> non-strict is provably more flexible than strict, right?
12:50:27 <LeCamarade> monochrom: Why should stuff be evaluated unless it is needed?
12:50:38 <Cale> MiB is mebibytes
12:50:38 <nominolo> > 1024 * 1024 / 1000000
12:50:46 <lambdabot>  1.048576
12:50:47 <Cheery> what is a DSEL?
12:50:53 <Cale> flux: hmm, I'll look for it next time
12:50:56 <sjanssen> you can't express 'if' with strict evaluation (as I understand it)
12:51:02 <Cale> flux: I wouldn't be too surprised by that.
12:51:04 <nominolo> domain-specific embedded language
12:51:37 <Cale> LeCamarade: because evaluation often compresses things in memory
12:51:49 <monochrom> An advantage of eager evaluation is that the syntax almost tells you how much time (even memory) a program uses (for idiomatic code).  An advantage of lazy evaluation is that the syntax almost tells you the producer-consumer roles (for idiomatic code).
12:52:08 <nominolo> monochrom: lazy eval is easier to optimize
12:52:21 <Cale> There is a trade-off there. If you end up building and holding on to lots of expressions which never get evaluated, you can use up quite a lot of memory needlessly.
12:52:21 <LeCamarade> Cale: And memory ceased to be a good reason to have crappy code about two years ago. Memory doubles every 9 months. It's like writing in ASM for speed.
12:52:43 <monochrom> LeCamarade: And therefore in eager programming the programmer makes sure there is no wasted effort.
12:52:49 <Cale> That's often true, but there are cases where you really do need strictness.
12:53:12 <Cale> Actually, allocation often has more to do with the speed of code now than the usual metrics for time.
12:53:20 <Cale> (in a practical sense)
12:53:29 <LeCamarade> Cale: Yeah, we should work on preventing thunks that won't be used, but that strict doesn't have the problem isn't a bonus for strict. Just a nice accident that crap could have nice effects.
12:53:39 <Cale> hehe
12:53:40 <sjanssen> LeCamarade: increases in RAM don't save you from bad situations.  There are cases where laziness can turn O(1) memory use to O(n^2), or worse
12:53:56 <Cale> Well, strict default is probably going too far by today's standards.
12:53:57 <monochrom> nominolo: Is there evidence in support of "lazy eval easier to optimize"?  (I'm asking. I'm no longer sure.)
12:54:06 <Cale> But strictness annotations are still important.
12:54:36 <Cale> and knowing what things should be strict is important
12:54:39 <nominolo> monochrom: at least many optimizations are only applicable if things terminate, that's mostly not a problem with lazyness
12:54:55 <Cale> But it's an optimisation which should be gingerly applied.
12:54:57 <nominolo> *laziness
12:55:30 <Cale> I see way too much of this "oh no, it's slow, let's make absolutely everything strict!" viewpoint.
12:55:39 <LeCamarade> We can never live without strict - at some point, stuff can only be strict. But lazy is _just so the Right Thing_. Can't imagine life sans lazy.
12:55:54 <Cale> Yeah.
12:56:06 <fridim> sans -> without ?
12:56:07 <LeCamarade> Was Miranda the first lazy? (Miranda(tm) is a Trademar of Research Software.)
12:56:18 <monochrom> right
12:56:19 <nominolo> fridim: yes
12:56:20 <Cale> It's also possible that other non-strict evaluation orders are better. I wonder what we'll end up with in the limit :)
12:56:24 <LeCamarade> fridim: Oui. Sans == Without.
12:56:33 <monochrom> Learn Latin!
12:56:43 <fridim> apprenez le franais :)
12:56:54 <nominolo> monochrom: french is close ;)
12:57:18 <sieni> LeCamarade: could you explain what strict (or lazy) there is about 4 + 5 -> 9
12:57:30 <LeCamarade> fridim: Si vous tes franais, nous avons #haskell-fr, mais c'est presque vide. :oD
12:57:46 <nominolo> monochrom: for example monad laws would only apply in certain special cases if you hadn't lazy evaluation
12:57:49 <Cale> sieni: well, if 4 and 5 are atomic data, there's only one way to evaluate that.
12:57:52 <LeCamarade> If 9 will not be used, no need to evaluate it.
12:58:07 <LeCamarade> > let x = 4 + 5 in 10
12:58:16 <lambdabot>  10
12:58:26 <norpan> > let x = x + x in 10
12:58:28 <lambdabot>  10
12:58:35 <nominolo> > let x = (trace "HIA" 4 + 5) in 10
12:58:37 <lambdabot>   Not in scope: `trace'
12:58:40 <LeCamarade> Saved about 20 asm instructions. :oD
12:58:51 <sieni> but there is nothing strict happening when I say
12:58:56 <sieni> > 4 + 5
12:58:57 <lambdabot>  9
12:59:00 <norpan> lazy evaluation can turn O(inf) to O(1) :)
12:59:10 <sieni> nor is there anything lazy happening
12:59:20 <sieni> actually both are happening simultaneously
12:59:26 <Cale> hehe
12:59:28 <LeCamarade> Lazy happens.
12:59:41 <Cale> Well, both strict and lazy evaluation do the same thing to that expression.
12:59:48 <monochrom> lazy evaluation can turn O(1) to O(inf). memory.
12:59:50 <LeCamarade> Strict doesn't. Each is only evaluated when needed - right away.
12:59:56 <Cale> Assuming that + is primitive, of course
13:00:14 <int-e> (+) is strict for the basic numeric types.
13:00:22 <Cale> right
13:00:50 <fridim> LeCamarade, presque ? :)
13:00:52 <LeCamarade> Um ... oh. But will it ever see the ligh of night (that rhymes) in ...
13:01:00 <dolio> If we had recursively defined naturals, we could have lazy addition. :)
13:01:03 <LeCamarade> >let 2 + 3 in 4
13:01:07 <fridim> #haskell.fr
13:01:11 <fridim> not haskell-fr
13:01:19 <Cale> LeCamarade: right, but strictly speaking, that's another expression :)
13:01:32 <norpan> what happened to parallel haskell
13:01:37 <LeCamarade> Cale: No, lazily speaking. This is not #java. :oD
13:01:40 <Cale> norpan: It's in GHC
13:01:44 <Cale> heh
13:01:45 <norpan> oh, it is
13:01:58 <Cale> par works fine with SMP
13:02:07 <LeCamarade> fridim: Presque == Nearly. N'est pas? Vous ne parlez pas?
13:02:15 <fridim> I'am french
13:02:28 <norpan> can you get ghc to automatically insert par?
13:02:33 <Cale> No.
13:02:40 <LeCamarade> fridim: Oui! Now that makes us two. Enough to conquer the monde.
13:02:59 <nominolo> > let add' Nothing y = Nothing; add' (Maybe x) y = Maybe (add' x y) in add (Maybe (Maybe (Nothing))) (Maybe Nothing)
13:03:01 <lambdabot>   Not in scope: data constructor `Maybe'
13:03:01 <fridim> let's divide and conquer
13:03:09 <nominolo> d'oh
13:03:11 <monochrom> conquer la monde et la monade
13:03:22 <norpan> it's "Just"
13:03:26 <int-e> > let a = 0 :+ 1; b = 2 :+ undefined in realPart (a + b) -- also strict
13:03:27 <lambdabot>  Undefined
13:03:31 * LeCamarade is sad it's not 1720 anymore. And #haskell is for Oceanians. :o(
13:03:39 <nominolo> > let add' Nothing y = Nothing; add' (Jyst x) y = Just (add' x y) in add (Just (Just Nothing)) (Just Nothing)
13:03:40 <lambdabot>   Not in scope: `add'
13:03:45 <nominolo> norpan: sure :)
13:03:49 <LeCamarade> monochrom: La monade. :oD
13:03:50 <nominolo> > let add' Nothing y = Nothing; add' (Jyst x) y = Just (add' x y) in add' (Just (Just Nothing)) (Just Nothing)
13:03:51 <lambdabot>   Not in scope: data constructor `Jyst'
13:03:59 <nominolo> > let add' Nothing y = Nothing; add' (Just x) y = Just (add' x y) in add' (Just (Just Nothing)) (Just Nothing)
13:04:00 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
13:04:00 <lambdabot>       Expe...
13:04:07 <nominolo> hehe, i knew it ..
13:04:08 <Cale> We were always at war with Eastasia
13:04:19 <monochrom> Not Python?
13:04:36 <Cale> hehe ... or was it Python?
13:04:36 <monochrom> Oh!  We were always at war with Perl, allied with Python!
13:04:52 <int-e> (because of the whitespace thingy)
13:05:15 <monochrom> Tomorrow it's going to be the other way round "because of the lambda thingy"!
13:05:25 <nominolo> norpan: it should have been a type-level function anyways ...
13:05:32 <int-e> naa, it can't be the lambda thingy. Guido wants to take it away.
13:05:34 <dcoutts_> SyntaxNinja: could you please login to darcs.h.o; cd /srv/darcs/; mv cabal-with-install-OLD archive/
13:05:36 <norpan> what's the difference between a thing and a thingy?
13:05:36 <dcoutts_> SyntaxNinja: ta
13:05:53 <kaol> what's pugs then? a mole operation?
13:06:00 <monochrom> Yeah!  Tomorrow we're at war with Python allied with Perl because Perl supports closure Python is against it.
13:06:05 <Cale> kaol: absolutely
13:06:05 <fridim> can someone explain why argument are written   a -> b -> c  (function that takes a b and return c) ?
13:06:15 <Cale> kaol: It's the greatest trick ever.
13:06:19 <norpan> fridim: it's called currying
13:06:26 <monochrom> But none of this exists. You never heard me saying it.
13:06:32 <Cale> fridim: a -> b -> c = a -> (b -> c)
13:06:46 <norpan> fridim: because you can apply just one of the arguments and get a function taking only one argument
13:06:48 <fridim> ah!
13:06:49 <Cale> fridim: it takes an a and returns a function which takes a b and returns a c
13:06:58 <fridim> I've understood  (a -> b) -> c !
13:07:12 <norpan> there you go :)
13:07:13 <Cale> Yeah, it's actually the other way around.
13:07:22 <Cale> Also, f x y = (f x) y
13:07:25 <int-e> @type fix
13:07:28 <lambdabot> forall a. (a -> a) -> a
13:07:29 * dcoutts_ pushes a pile of patches to http://darcs.haskell.org/cabal-install/
13:07:32 <lambdabot> Title: Index of /cabal-install
13:07:53 <dcoutts_> shapr: darcs get --partial http://darcs.haskell.org/cabal-install/
13:07:54 <lambdabot> Title: Index of /cabal-install
13:08:10 <dcoutts_> shapr: please report on the 'out of the box' experience
13:08:35 <dcoutts_> shapr: eg try to install filepath-1.0 via cabal-install
13:09:16 <Saizan> is the darcs version of Cabal supposed to build on 6.6.1? it lacks haskell98 in build-depends to do so
13:09:25 <LeCamarade> > let _'war'_ = "peace" in _'war'_
13:09:27 <lambdabot>  "peace"
13:10:01 <LeCamarade> > let _'freedom'_ = "slavery" in _'freedom'_
13:10:02 <lambdabot>  "slavery"
13:10:12 <norpan> /ignore
13:10:14 <int-e> > let _`war`_ = "peace" in war war war
13:10:16 <lambdabot>  "peace"
13:10:26 <Cale> There seem to be certain times of day when people post lots of stuff to reddit which I mod down, leaving great big gaps in the numbers down the side of my "new" page.
13:10:46 <int-e> (how does that type check?)
13:11:10 <Cale> :t let _`war`_ = "peace" in war
13:11:13 <lambdabot> forall t t1. t -> t1 -> [Char]
13:11:39 <dfranke> hmm, I'm trying to register an account on hackage.haskell.org/trac but it's getting a permissions error when it tries to create my account.
13:11:47 <dfranke> [Errno 13] Permission denied: '/srv/trac/ghc/trac.htpasswd'
13:11:54 <int-e> yes, it's polymorphic.
13:11:59 <norpan> int-e: why shouldn't it type check?
13:12:16 <norpan> monomorphism restriction?
13:12:27 <monochrom> I think it would make a nice feature that a user can specify to reddit "I want to sort by this weighted sum of the follow people's rating" as opposed to plain uniform democracy.
13:12:50 <dfranke> monochrom, that's what the recommended tab is for.
13:13:09 <dfranke> monochrom, it gives more weight to the votes of people who vote the way you do.
13:13:17 <monochrom> Nice.  Essentially I'll only care about what dons and Cales think. :)
13:13:20 <int-e> norpan: it should, but it looks confusing - (x x) type checking worries me for no good reason.
13:13:24 <LeCamarade> int-e: How come that worketh?
13:13:51 <Saizan> ?type const const
13:13:54 <lambdabot> forall a b b1. b1 -> a -> b -> a
13:14:01 <int-e> LeCamarade: it defines a binary function war (using `` infix notation in its definition)
13:14:17 <LeCamarade> monochrom: `As opposed to ... democracy'. This _1984_ George Orwell stuff has really caught you.
13:14:56 <LeCamarade> int-e: I figure the `` shouldn't matter, being ... oh!
13:15:00 <monochrom> Yeah. I moved around a few books yesterday, found it, and read a few pages.
13:15:35 <LeCamarade> > let _`bzzt`_ = "Shock" in bzzt bzzt bzzt
13:15:36 <lambdabot>  "Shock"
13:15:56 <monochrom> that is crazy
13:15:58 * LeCamarade gets it. Kisses Haskell.
13:16:29 <LeCamarade> Um ... is Haskell male or female? The language, not the guy. Consider beauty, here. Or I go to #haskell-blah?
13:16:37 <norpan> haskell is a guy
13:16:44 <dcoutts_> lambdabot is a girl
13:16:58 <phoniq> @asl
13:16:58 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
13:17:02 <norpan> jag knner en bot, hon heter lambdabot, lambdabot heter hon
13:17:03 <phoniq> nm
13:17:31 <LeCamarade> Nope. Haskell is a girl. Cute, you know. Dainty. And prone to fits of complaining that span three pages where C gives only one masculine `Segmentation fault'.
13:19:08 <monochrom> Haskell gives you three pages of "unresolved overloading with infinite type doesn't match expected type"
13:20:18 <LeCamarade> Yeah. And that's part of the beauty. Ironically.
13:22:02 <fridim> what is One a,   Two a b  ?
13:22:33 <fridim> they seem constructors, but, what is it for?
13:22:34 <norpan> fridim: sounds like data constructors
13:23:36 <LeCamarade> fridim: In Haskell, since you can't change the values of variables, pattern matching is one way to to get the values.
13:23:38 <LeCamarade> So ...
13:23:51 <yetAnotherOne> i'm trying to build greencard 3.01 with ghc 6.6 and ghc says (he or she) can't find Data.FiniteMap. is there a patch, or can i download Data.FiniteMap somewhere?
13:24:02 <fridim> could you :                 Write a datatype Tuple which can hold one, two, three or four elements, depending on the constructor (that is, there should be four constructors, one for each number of arguments). Also provide functions tuple1 through tuple4 which take a tuple and return Just the value in that position, or Nothing if the number is invalid (i.e., you ask for the tuple4 on a tuple holding only two elements).
13:24:15 <LeCamarade> > let somefunc (Just x) = x in somefunc $ Just 3
13:24:17 <lambdabot>  3
13:25:03 <LeCamarade> When they put One and Two, they are showing you how to create them. That will come slow and sure. It will become clear.
13:25:16 * LeCamarade has to run!
13:25:42 <norpan> my money is on Three a b c and Four a b c d :)
13:26:46 <Saizan> (this exercise of YAHT happens to confuse a lot of people)
13:27:14 <norpan> confusion is the first step towards enlightenment
13:29:08 <eumenides> i've made an image board in haskell: http://code.google.com/p/himgb/
13:29:09 <lambdabot> Title: himgb - Google Code
13:29:32 <Saizan> image board as in?
13:29:43 <eumenides> Saizan: 4chan?
13:29:48 <Saizan> uoh
13:29:53 <eumenides> Saizan: a bbs with images
13:29:54 <Saizan> with CGI?
13:29:58 <eumenides> ya
13:30:16 <eumenides> it's pretty basic and bad code tho
13:30:35 <mdmkolbe-home> I asked this before, but I forgot the answer.  is there a simple way to convert a list into a MonadPlus?
13:30:49 <Saizan> ?instances MonadPlus
13:30:51 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:31:01 <eumenides> so yes
13:31:02 <kpreid> list *is* MonadPlus
13:31:04 <Saizan> see, [] *is* a MonadPlus
13:31:07 <mauke> > mzero :: [Int]
13:31:09 <lambdabot>  []
13:31:31 <mauke> > "foo" `mplus` "bar"
13:31:32 <mdmkolbe-home> I mean the other way around
13:31:33 <lambdabot>  "foobar"
13:31:53 <mauke> mdmkolbe-home: like IO a -> [a]?
13:31:59 <monochrom> There is no way. But you may mean what you never said.
13:32:22 <kpreid> mdmkolbe-home: do you mean turning a list into a *different* MonadPlus?
13:32:23 <dolio> ?type msum . map return
13:32:25 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
13:32:26 <mdmkolbe-home> foo :: (MonadPlus m) => m Int; foo = the_function_I_want [1..10]
13:32:37 <kpreid> dolio said it
13:33:07 <mdmkolbe-home> dolio: yeah, that would do it, but I thought I remembered someone mentioning a simpler way last time I asked
13:33:38 <mauke> ?pl msum . map return
13:33:39 <lambdabot> msum . map return
13:33:45 <Saizan> mmh i said lift but the problem was a little different
13:33:56 <mdmkolbe-home> @type lift
13:33:58 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:34:25 <mdmkolbe-home> @type liftM
13:34:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:35:29 <dolio> As far as I know, that's the simplest way to do it in general. It'd be nice if that had a name in the standard library, though.
13:35:31 <davidL> someone help me with this code: map (\x -> let a = fst x; b = snd x in (length . takeWhile isPrime . map (\n -> n^2 + a*n + b)) [0..]) [(a , b) | a <- [1..100], b <- [1..100]]
13:36:28 <Heffalump> what do you mean by help you with it?
13:36:41 <monochrom> I can help you run it.  :)
13:36:47 <davidL> it's not doing what I need it to do
13:37:07 <Heffalump> can you provide a clear description of what you need it to do and what it's doing instead?
13:37:16 <Heffalump> and perhaps lay it out a bit more legibly in a pastebin?
13:37:20 <Heffalump> @paste
13:37:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:37:36 <dolio> 'map (\(a, b) -> ...' is an initial improvement. :)
13:37:50 <monochrom> I am failing to understand beginner questions as I grow older.
13:38:02 <davidL> dolio: ah good idea thanks
13:38:44 <dmwit> You probably want ... takeWhile isPrime $ map ...
13:38:46 <davidL> actually, I think it's doing what I need just fine
13:39:00 <dmwit> Wait, no, I parsed that wrong.
13:39:19 <davidL> dmwit: no you didn't, that's correct
13:39:19 <mdmkolbe-home> I think davidL is trying to determine how many initial elements of each equation n^2 + a*b + c are prime
13:39:37 <dmwit> davidL: Only if you delete some parentheses.
13:39:59 <kc5tja> monochrom: "Why is the sky blue?"  "Well, timmy, it has to do with the battle between the Normans and the Britons in 1100 AD, where the Normans won the war because of the fact they were wearing stirrups and the Brits didn't.  That allowed the French to conquer the Britons, thus infusing the English language with French influence, and so we say 'blue' instead of....wait...what are you talking about, the name of the word or the actual physi
13:40:35 <monochrom> Not like that.
13:41:09 <timthelion> hey, are there any interactive comand line environments that you don't have to do the let ... in crap to test functions?
13:41:10 <kc5tja> monochrom: No, but you gotta admit, that'd be the kind of "too much information"-generated confusion most people would kill for.  ;D
13:41:18 <norpan> bah, blue is from old nordic
13:41:37 <dino-> bleu
13:41:39 <norpan> or german
13:41:39 <dmwit> timthelion: Put things in a file, then use ghci.
13:42:01 <monochrom> I don't, in fact, generate too much information.
13:42:02 <timthelion> dmwit why can't it just read the input stream the same way it reads a file?
13:42:05 <kc5tja> norpan: I'm sure it predates even those.
13:42:12 <mdmkolbe-home> timthelion: You should think of GHCi as being in side a big 'do', thus why you have to do the let's
13:42:12 <timthelion> dmwit, it can be that freekin hard.
13:42:18 <kc5tja> norpan: But that doesn't fundamentally alter the absurdity of the situation.
13:42:20 <wy> Hi all!
13:42:30 <timthelion> mdmkolbe but that's not what I want
13:42:36 <dmwit> timthelion: Hmmm... well, the short answer is that the interactive line is run in the IO monad.
13:42:38 <norpan> kc5tja: 'm just spinning along with the absurdity :)
13:42:48 <mdmkolbe-home> timthelion: but that's what the IO monad needs
13:43:07 <dmwit> If you have longish "let ... in" statements, you can omit the "in ..." part to get a (slightly more) permanent binding.
13:43:16 <timthelion> mdmkolbe should I make an interactive mode in emacs, that copies each line to a temp file, then loads the temp files?
13:43:20 <davidL> forgetting everything I've said up to now, how can idiomatically create a list of tuples like (map (\a, b -> foo), a, b) ?
13:43:31 <mdmkolbe-home> timthelion: GHCi doesn't allow forward references (for obvious reasons), so in general it can't take a *.hs file as stdin
13:43:38 <wy> I'm considering type safe languages that can be used to program operating systems. Anyone has heard some languages as safe as Haskell used in that area?
13:43:58 <monochrom> Yes. Haskell is one. There is another one I forgot.
13:43:59 <dmwit> > zip [0..3] [2..30] -- davidL: like this, or what?
13:44:01 <lambdabot>  [(0,2),(1,3),(2,4),(3,5)]
13:44:03 <timthelion> mdmkolbe I don't know what you mean.
13:44:21 <dmwit> Or maybe you meant zipWith foo instead...
13:44:32 <davidL> dmwit: ah yes, thanks again
13:44:46 <wy> monochrom: Is it in production use?
13:44:53 <dino-> wy: I have been increasingly writing Haskell with #! /usr/bin/runhaskell and executing like a script.
13:45:08 <dino-> I keep meaning to check out things like h4sh but have not yet.
13:45:20 <monochrom> The other one seems to be one of the ml family. I suppose not in production use. The OS market is so bloody saturated that even BeOS didn't have a chance.
13:45:25 <mdmkolbe-home> timthelion: the usual mode of development for haskell is to write it in a file, that you load into GHC (in a different terminal).  Edit file, save. Switch to ghci do ':reload' (or ':r').  Go back to editing file.
13:45:37 <dmwit> timthelion: If you're already in emacs, why not just write it to a file yourself?
13:45:38 <kc5tja> monochrom: You misunderstand -- it's what would happen *if* you had too much information, and not enough context to narrow your answers down.  :)  But, I guess I'm the only one who gets the humor, so I'll quit now.
13:45:46 <kc5tja> If I have to explain the joke, it fails to be joke.
13:46:08 <wy> monochrom: But I think those functional languages can lead to a next generation of OSs
13:46:09 <dolio> kc5tja: I thought it was amusing. :)
13:46:10 <monochrom> Don't give up. Please explain the joke. Only way I can learn more jokes.
13:46:23 <mdmkolbe-home> timthelion: You could put the following in Foo.hs.  "x = y \n y = 2"
13:46:46 <mdmkolbe-home> timthelion: where "\n" is a line break
13:47:04 <monochrom> I think beginner questions lack context and leave terms undefined.
13:47:29 <mdmkolbe-home> timthelion: but if you fed taht file to GHCi's input, it would see the "x = y" first and not yet know about the "y=2" so it would reject the file
13:48:02 <wy> monochrom: I'm learning compilers for functional languages, together with partial evaluation. I think they made things much cleaner than the mess I learnt in my undergrad compiler class.
13:48:11 <mdmkolbe-home> timthelion: I guess I should have asked first, but you do know that GHCi can load files from teh hard disk as well as take interative input right?
13:48:46 <kc5tja> monochrom: The problem is, I'm not sure if you're being serious or not.  :)  On the off chance that you are, there are several interpretations of "Why is the sky blue?".  All interpretations are correct in their own context -- but did you pick the same context that little Timmy picked?  If not, you can go through extraordinary lengths to explain the answer, and still leave the inquisitor thoroughly bamboozled.
13:48:48 <wy> monochrom: So I hope these neat things can clean up the messy OS stuff.
13:49:19 <davidL> :t zip3
13:49:22 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
13:50:00 <monochrom> I am serious. However, I am not even at the what-answer-to-give stage. I am saying that it is impossible to interpret many questions at all.
13:50:19 <dolio> wy: Did you see the recent paper on strongly typed memory areas for low-level development (although I don't know where exactly that's implemented)?
13:50:23 <mdmkolbe-home> wy: Cyclone is one language that might be appropos (not as safe as Haskell, but closer to being a system language)
13:52:07 <wy> mdmkolbe-home: Thanks. Is it safer than Java? I regard think Java as unsafe languages.
13:52:11 <dolio> Oops, I guess it's not that recent. 2006.
13:54:05 <mdmkolbe-home> wy: I don't think comparing to Java is meaning full b/c technically a Java program can't "go wrong", but it's *really* not a systems language.  Cyclone is a C dialect that requires you to prove statically all your uses of pointers are safe (but it might have a cast out of that for the rare ocation, I don't remember).
13:55:05 <mdmkolbe-home> wy: e.g. Cyclone won't let you return a pointer to a local variable
13:55:56 <wy> mdmkolbe-home: Thanks. I'll have a look at it.
13:56:48 <mdmkolbe-home> wy: and for functions like foo(char *str, int len) you can add an annotation that tells the compiler that str is a counted pointer by len, so in the body of foo you can't do str[10] = 'x' but you can do if (len == 20) str[10] = 'x';
13:58:05 <wy> mdmkolbe-home: Sounds good enough for OS.
13:58:55 <timthelion> is there a list of those : commands for ghci? it's not in the manual
13:59:12 <Saizan> :help
13:59:21 <mdmkolbe-home> wy: yeah, it sounds good, but I don't know how well it pans out in the end.  If you use it I would love to hear whether it went well or not, or if there were any anoying issues or missing features
13:59:48 <mdmkolbe-home> timthelion: see :help or :?
13:59:52 <kpreid> timthelion: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
13:59:54 <lambdabot> Title: 3.6. GHCi commands, http://tinyurl.com/ytkpuj
14:00:40 <davidL> how can I find the index of the biggest number in a list?
14:00:50 <norpan> length-1
14:01:01 <norpan> max
14:01:05 <dino-> davidL: Do you mean highest-valued?
14:01:20 <norpan> bah
14:01:41 <monochrom> kc5tja: let's analyze davidL's latest question and all the replies for example. :)
14:02:23 <monochrom> Actually I think this one is pretty clear (to me), but still lots of volunteered different interpretations.
14:02:28 <mdmkolbe-home> timthelion: the most usefull commands are :reload, :load, and :module (but with the last one you usually want something like ':module +Foo' (note the '+') so that it adds the module to your loaded modules instead of replacing them.  (In any case the modules you import from the file you :load will already be in scope so you might not need :module as much as you might think))
14:02:29 <davidL> monochrom: what are you talking about?
14:02:45 <monochrom> I'm discussing with kc5tja the art of understanding questions.
14:02:52 <mdmkolbe-home> timthelion: and of course all those commands can be abriviated :r, :l :m
14:03:10 <davidL> monochrom: you don't have to analyze anything if you don't want
14:03:13 <dmwit> ?hoogle a -> [a] -> Maybe Int
14:03:14 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
14:03:15 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
14:03:27 <monochrom> But I want to. It's important.
14:03:42 <norpan> elemIndex . max it is then
14:03:45 <mdmkolbe-home> timthelion: oh, yeah.  :t gives you the type of an expression and :i tells you about variables, constructors, classes, etc.
14:03:57 <norpan> and fromJust
14:04:21 <norpan> :t fromJust . elemIndex . max
14:04:23 <lambdabot>     Couldn't match expected type `Maybe a'
14:04:24 <lambdabot>            against inferred type `[a1 -> a1] -> Maybe Int'
14:04:24 <dmwit> > let biggestLocation xs = fromJust . flip elemIndex xs $ max xs in biggestLocation [3,56,4]
14:04:26 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
14:04:26 <lambdabot>     Pro...
14:04:31 <davidL> thanks norpan
14:04:31 <norpan> bah
14:04:51 <dmwit> :t max
14:04:52 <norpan> something like that
14:04:54 <lambdabot> forall a. (Ord a) => a -> a -> a
14:04:58 <dmwit> > let biggestLocation xs = fromJust . flip elemIndex xs $ maximum xs in biggestLocation [3,56,4]
14:05:01 <norpan> i'm very tired
14:05:14 <dmwit> ...
14:05:14 <dino-> Oho, I was thinking in terms of zipping with [0..] first. Well, I'll just keep quiet. :D
14:05:19 <dmwit> ?bot
14:05:20 <lambdabot> :)
14:05:32 <mdmkolbe-home> ?botsnack
14:05:32 <lambdabot> :)
14:05:44 <norpan> the number of problems you can solve by zipping with an infinite list exceeds imagination :)
14:05:46 <dmwit> > let biggestLocation xs = fromJust . flip elemIndex xs $ maximum xs in biggestLocation [3,56,4] -- why don't you like me, lambdabot?
14:05:50 <dino-> heh
14:06:04 <davidL> > (+) 1 1
14:06:48 <mdmkolbe-home> lambdabot: Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
14:07:07 <mdmkolbe-home> where's a lambdabot wrangler when you need one?
14:07:07 <dmwit> dino-: Oh, that's good, it only needs one pass of the data.
14:07:39 <dmwit> oh
14:07:39 <TomMD> norpan: here is a zip problem - I have a [Word8] I want to turn into a list of [Word32] by combining every 4 bytes into one word but not reusing any byte.
14:07:49 <TomMD> :-)
14:08:27 <davidL> ?index fromJust
14:08:28 <lambdabot> Data.Maybe
14:08:35 <dmwit> combine [] = []; combine (b1:b2:b3:b4:bs) = foo b1 b2 b3 b4 : combine bs
14:09:38 <eumenides> @hoogle unfold
14:09:38 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
14:09:39 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:09:39 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
14:09:40 <TomMD> dmwit: that is exactly what I did, but at the time I was wanting a way to do it using 'zip' so I wouldn't have to define my own funciton (I thought it could be prettier)
14:09:41 <mdmkolbe-home> combine (b1:b2:b3:b4:_) = foo b1 b2 b3 b4 : combine bs; combine _ = []
14:09:47 <dmwit> Or use that "chunk" function that everybody writes at least once.
14:10:05 <mdmkolbe-home> dmwit: handles non-multiple of 4 length strings
14:10:08 <dmwit> Then map (not zip) over it.
14:10:24 <dmwit> mdmkolbe-home: Nice, that's better.
14:10:47 <monochrom> I haven't written the chunk function. What is it?
14:10:48 <TomMD> mdmkolbe-home: Yes, but in my case the list was assured to be infinite so... I let myself be sloppy.
14:11:01 <mdmkolbe-home> it would be nice if list comprehentions had a 'chunk' syntax
14:11:25 <Claudius1aximus> let chunk _ [] = [] ; chunk n xs = let (a,b) = splitAt n xs in a : (chunk n b)
14:11:39 <Claudius1aximus> (not mine, needed it, seen it here...)
14:11:55 <mdmkolbe-home> is 'chunk' in the Wiki Prelude yet?
14:12:04 <dino-> > let foo lst = fst $ last $ Data.List.sortBy (Data.Ord.comparing snd) $ zip [0 ..] lst in foo [3,56,4]
14:12:05 <beelsebob> moin all
14:12:06 <dmwit> nope
14:12:34 <mdmkolbe-home> Wiki Prelude == that place I can never remember it's name that holds all the usefull functions they forgot in the real Prelude
14:12:43 <dmwit> licensedpreludeexts
14:12:51 <dolio> > let stoppingAt f p x = if p x then mzero else return (f p) ; chunk n = unfoldr (splitAt n `stoppingAt` null) in chunk 5 [1..50]
14:12:52 <lambdabot>  Couldn't match expected type `b -> Bool'
14:13:15 <dolio> Oops.
14:13:19 <dolio> > let stoppingAt f p x = if p x then mzero else return (f x) ; chunk n = unfoldr (splitAt n `stoppingAt` null) in chunk 5 [1..50]
14:13:34 <dino-> This is reminiscent of the 'kminima' thread that raged across one of the ml's recently.
14:14:28 <monochrom> "last" may force a full sort.
14:14:46 <beelsebob> dolio: what's you trying to do?
14:14:53 <dino-> monochrom: Yeah, I was feeling grumpy about that. Considering reverse.
14:15:05 <mdmkolbe-home> dino-: ?
14:15:24 <monochrom> Use a sorting criterion that sorts the thing in decreasing order.
14:16:08 <dolio> beelsebob: Just playing around, I guess.
14:16:25 <shapr> dcoutts_: Wow, that's a lot of patches.. especially since I pulled cabal-install just a coupla hours earlier.
14:17:29 <dino-> > let foo lst = fst $ head $ Data.List.sortBy (flip . Data.Ord.comparing $ snd) $ zip [0 ..] lst in foo [3,56,4]
14:17:53 <dino-> mdmkolbe-home: ? kminima?
14:18:03 <mdmkolbe-home> dino-: yeah
14:19:08 <dino-> mdmkolbe-home: http://www.haskell.org/pipermail/haskell-cafe/2007-April/024354.html
14:19:10 <lambdabot> Title: [Haskell-cafe] k-minima in Haskell, http://tinyurl.com/25bmrp
14:20:01 <dmwit> take k . sort
14:20:01 <dmwit> ?
14:20:25 <dino-> Return the indices of the least k elements
14:20:47 <dmwit> Oh, indices.
14:21:17 <dmwit> Then, zip [0..] and comparing fst should do it, no?
14:22:06 <dmwit> firstK k = map fst . take k . sortBy (comparing snd) . zip [0..]
14:22:56 <mdmkolbe-home> @type comparing
14:22:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:24:02 <dino-> yes
14:28:43 <mdmkolbe-home> @type on
14:28:46 <lambdabot> Not in scope: `on'
14:31:49 <dino-> mdmkolbe-home: The API docs make that one clearer: comparing p x y = compare (p x) (p y)
14:32:19 <mdmkolbe-home> ?src comparing
14:32:20 <lambdabot> Source not found. My mind is going. I can feel it.
14:32:29 <mdmkolbe-home> ?src comparing
14:32:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:32:35 <mdmkolbe-home> ?type comparing
14:32:38 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:32:44 <mdmkolbe-home> odd
14:32:54 <mdmkolbe-home> in scope, but not src-able
14:32:56 <Baughn> Not very. There are many functions with no source.
14:33:15 <mdmkolbe-home> @djinn forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:33:16 <lambdabot> Cannot parse command
14:33:31 <mdmkolbe-home> @djinn (Ord a) => (b -> a) -> b -> b -> Ordering
14:33:31 <lambdabot> Cannot parse command
14:34:01 <augustss> I guess lambdabot has the old djinn
14:34:15 <mdmkolbe-home> where is the new one?
14:34:51 <augustss> darcs.augustsson.net/Djinn
14:35:21 <augustss> ummm, there's a darcs in the url too, i think
14:36:13 <dcoutts> shapr: :-)
14:36:41 <dcoutts> shapr: let me know about the "user experience" :-)
14:54:54 <gds> @hoogle String -> IO String
14:54:55 <lambdabot> System.getEnv :: String -> IO String
14:54:56 <lambdabot> System.Console.Readline.quoteFilename :: String -> Bool -> Ptr CChar -> IO String
14:55:35 <gds> Do we have anything like perl's backticks - takes a String, tries to run it at the shell, returns the stdout of that command?
14:55:49 <mdmkolbe-home> @type system
14:55:52 <lambdabot> Not in scope: `system'
14:55:58 <mdmkolbe-home> @hoogle system
14:55:59 <lambdabot> System.system :: String -> IO ExitCode
14:55:59 <lambdabot> System :: module
14:55:59 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
14:56:40 <gds> @doc System.ExitCode
14:56:40 <lambdabot> System.ExitCode not available
14:57:06 <mdmkolbe-home> @src ExitCode
14:57:06 <lambdabot> data ExitCode = ExitSuccess | ExitFailure Int
14:58:04 <gds> Doesn't seem like quite what I'm after :/
14:58:21 <mdmkolbe-home> yeah, it's more like perl's ... 'system'
14:58:46 <qwr> @docs System.Process
14:58:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
14:59:18 <qwr> :t runInteractiveCommand
14:59:21 <lambdabot> Not in scope: `runInteractiveCommand'
14:59:30 <qwr> :t System.Process.runInteractiveCommand
14:59:32 <lambdabot> String -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
14:59:41 <kc5tja> I think he's asking for such minimal syntax as to not have to type any function names at all.
14:59:52 <allbery_b> there are painful ones in the libs, and less painful ones in MissingH, as I understand it
14:59:56 <kc5tja> result <- `ls -la >foo.out`
15:00:05 <allbery_b> no friendly syntax currently
15:00:06 <mdmkolbe-home> allbery_b: MissingH?
15:00:13 <scsibug> pipeFrom in MissingH can handle that as well
15:00:14 <allbery_b> @where missingh
15:00:14 <lambdabot> http://quux.org/devel/missingh
15:00:23 <gds> kc5tja: not at all - I'm quite happy to type things :)
15:00:34 <gds> I'm just wondering what the best way of doing it is :)
15:00:43 <kc5tja> Ahh, I misunderstood the question then.
15:00:45 <mdmkolbe-home> that link needs to be updated
15:01:17 <mdmkolbe-home> kc5tja: I think he wants more like: result <- shell "ls -la"
15:01:35 <mdmkolbe-home> @tell where MissingH http://software.complete.org/missingh
15:01:36 <lambdabot> Consider it noted.
15:01:44 <mdmkolbe-home> @where MissingH
15:01:44 <lambdabot> http://quux.org/devel/missingh
15:01:53 <mdmkolbe-home> @where MissingH http://software.complete.org/missingh
15:01:53 <lambdabot> http://quux.org/devel/missingh
15:01:54 <ddarius>  @where+
15:01:59 <where> o
15:01:59 <lambdabot> where: You have 1 new message. '/msg lambdabot @messages' to read it.
15:02:04 <mdmkolbe-home> @where+ MissingH http://software.complete.org/missingh
15:02:05 <lambdabot> Done.
15:02:11 <mdmkolbe-home> @where MissingH
15:02:12 <lambdabot> http://software.complete.org/missingh
15:02:17 <mdmkolbe-home> ddarius: thx
15:02:21 * gds goes to looks at missingh :)
15:02:28 <gds> Cheers :)
15:02:33 <where> @messages
15:02:33 <lambdabot> mdmkolbe-home said 57s ago: MissingH http://software.complete.org/missingh
15:03:00 * mdmkolbe-home really needs a cheat sheet for lambdabot
15:03:12 <gds> @list
15:03:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:03:15 <gds> :)
15:03:30 <nominolo> what's the difference between fromJust and forceMaybe in missingH?
15:03:47 <nominolo> the error message?
15:04:01 <mdmkolbe-home> gds: that's just a list of command names, I want something a little more descriptive
15:04:08 <ddarius> @help pl
15:04:09 <lambdabot> pointless <expr>. Play with pointfree code.
15:04:19 <mdmkolbe-home> @help where
15:04:19 <lambdabot> where <key>. Return element associated with key
15:04:35 <sjanssen> nominolo: it looks like the author doesn't know about fromJust
15:04:46 <ddarius> mdmkolbe-home: There is also always the source.
15:04:48 * mdmkolbe-home considers spaming lambdabot's help so he can have the entire list
15:04:55 <mdmkolbe-home> @help all
15:04:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:05:03 <ddarius> @help help
15:05:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:05:25 <qwr> /msg lambdabot @help list
15:05:28 <mdmkolbe-home> @src lambdabot
15:05:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:05:36 <nominolo> sjanssen: it seems.  also, fromMaybeMsg msg = fromMaybe (error msg)
15:05:37 <sjanssen> @keal
15:05:38 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
15:05:50 <mdmkolbe-home> @help keal
15:05:50 <lambdabot> keal. Talk like Keal
15:05:56 <mdmkolbe-home> huh?
15:06:08 <mdmkolbe-home> @keal
15:06:09 <lambdabot> there is no way to prove the failsafe exists
15:06:16 <allbery_b> keal is a psychotic
15:06:20 <shapr> @keal
15:06:20 <lambdabot> Keal angry @ dons
15:06:26 <allbery_b> (literally)
15:06:27 <nominolo> > (length "fromMaybeMsg msg", length "fromMaybe (error msg)")
15:06:29 <lambdabot>  (16,21)
15:06:40 <allbery_b> he's banned from here but was recently annoying people on cognet...
15:06:44 <shapr> allbery_b: For the first two days, I thought he was a Markov chain bot trained on the #haskell logs.
15:06:58 <shapr> It was only after he was banned that someone convinced me he was an actual human.
15:07:11 <mdmkolbe-home> shapr: roflol
15:07:23 <shapr> He really failed his Turing test.
15:07:49 <shapr> @protontorpedo
15:07:50 <lambdabot> is it fun to program in haskell?
15:07:52 <shapr> @protontorpedo
15:07:52 <lambdabot> what echniques can be used to scael application in haskell?
15:07:57 <shapr> @keal
15:07:58 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
15:08:10 <shapr> Like, wtf does that mean?
15:08:14 <sjanssen> hahahahaha
15:08:20 <mdmkolbe-home> @help protontorpedo
15:08:20 <sjanssen> that must be a new one!
15:08:20 <lambdabot> protontorpedo is silly
15:08:25 * gds thinks it needs parens ;)
15:08:45 <sjanssen> "unicorn and daisy loving girl mathematician"?!
15:08:48 <mdmkolbe-home> how bout i say (ick no (unicorn and daisy loving girl mathematician) will ever enjoy this)
15:09:10 <mdmkolbe-home> how bout i say (ick no (unicorn and daisy loving (girl mathematician)) will ever enjoy this)
15:09:26 <shapr> Hm, that does make a bit more sense..
15:09:49 <Saizan> @keal
15:09:50 <lambdabot> what the hell does Prelude > mean?
15:09:52 <mdmkolbe-home> yeah, but it does tend to make one's parser go NPC
15:09:53 <shapr> But then, most females I've known are only into unicorns and daisy around the age of twelve to fifteen.
15:09:55 <nominolo> @hoogle Maybe a -> Either e a
15:09:55 <gds> was keal a lisper?
15:09:56 <lambdabot> No matches, try a more general search
15:09:57 <mdmkolbe-home> NP-Comp
15:10:07 <steven807> Hello folks -- has anyone built X11-1.2 on a mac using ghc 6.6.1?  When I try building, it fails to compile, apparently because the "ld-options" value is ignored..
15:10:38 <shapr> To me, Keal sounds very young, and very confused.
15:10:43 <shapr> But also, very confident.
15:11:03 <dcoutts> shapr: does cabal-install work for you then ? :-)
15:11:18 <Cheery> how long does it take to get a random value from seed in haskell?
15:11:24 <shapr> Oh, I got distracted.
15:11:33 <Cheery> (seed precomputed beforehand)
15:11:33 <mdmkolbe-home> @type seed
15:11:35 <lambdabot> Not in scope: `seed'
15:11:41 <sjanssen> steven807: I've gotten reports from FreeBSD users that the darcs version of Cabal works better
15:11:42 <shapr> Cheery: It's instant?
15:11:50 <shapr> > mkStdGen 9
15:11:51 <lambdabot>  10 1
15:12:02 <mdmkolbe-home> @type mkStdGen
15:12:05 <lambdabot> Int -> StdGen
15:12:05 <sjanssen> grepping through #haskell logs for Keal yields much hilarity
15:12:13 <mdmkolbe-home> @info StdGen
15:12:13 <lambdabot> StdGen
15:12:15 <steven807> Thanks for suggestions, I'll try darcs version and maybe cabal-install
15:12:18 <mdmkolbe-home> ?src StdGen
15:12:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:12:51 <Cheery> shapr: I'm just wondering whether you can use the algorithm to make a little of 'randomising' for taking a set of samples
15:13:12 <sjanssen> steven807: cabal-install probably won't help you -- it's just a thin layer over cabal
15:13:29 <steven807> OK, darcs'ing now..
15:13:38 <steven807> (All this cause I wanna try xmonad!)
15:15:18 <gds> steven807: It is cool - I'm running it in KDE atm ;)
15:16:51 <steven807> Grr, darcs versin of cabal fails..  Debugging time!
15:17:00 <mdmkolbe-home> how hard would it be to make xmonad be non-tiling? alternatively, how good is the navigation in xmonad (tiling managers though I like them in pricipal can be awkward in practice)?
15:17:25 <gds> mdmkolbe-home: Have you tried a dynamic tiling WM before?
15:17:32 <gds> Like wmii or dwm?
15:17:50 <gds> They're a bit different feeling from the likes of ion and ratpoison as I understand it...
15:18:14 <shapr> When people tell me the dress code is "Wear what you wear to work." I get to say "You don't know what I do for a living."
15:18:30 <shapr> mdmkolbe-home: xmonad is awesome. Try it!
15:18:36 <mdmkolbe-home> gds: yeah, I think it was Ion, that I used
15:18:45 <shapr> xmonad > ion3
15:18:47 <Saizan> shapr: what is the intended way to for example query an external database and put some data in the app state in HAppS? unsafeIOtoEv ?
15:18:52 <mdmkolbe-home> shapr: does it run on cygwin?
15:19:08 <sjanssen> @check \x -> xmonad > x
15:19:08 <shapr> Saizan: I think there's explicit support for IO side effects, but I can't think of it off the top of my head.
15:19:12 <sorear> hello!
15:19:12 <lambdabot>   Not in scope: `xmonad'
15:19:15 <steven807> Woot!  Cabal fixes (the Makefile has dependencies on cabal-install and cabal-setup, which aren't in the tree), and the new one successfully builds X11.  Thanks, folks!
15:19:23 <shapr> yay!
15:19:35 <Saizan> shapr: k
15:19:41 <sjanssen> mdmkolbe-home: it can probably be done
15:19:56 <kaol> @check "xmonad" > "ion3"
15:19:58 <lambdabot>  OK, passed 500 tests.
15:20:17 <sjanssen> mdmkolbe-home: the only requirements are libX11, ghc, and a couple Haskell packages
15:20:59 <shapr> dcoutts: cabal-install almost just works.
15:20:59 <mdmkolbe-home> sjanssen: trouble is there is no cygwin ghc.  The closest you can get is Windows ghc which probably won't link the libX11
15:21:02 <gds> mdmkolbe-home: Yeah, I think you'll find xmonad a fair bit less awkward than ion
15:21:19 <monochrom> Haskell advocacy is great!
15:21:28 <shapr> dcoutts: I ran cabal-install bzlib-0.3 as user shae, and it all worked until it tried to write to /usr/local
15:21:36 <sjanssen> monochrom: meta-advocacy?
15:22:18 <monochrom> I mean the way we advocate is "haskell is cool, try it!" rather than "everything else is broken". There is a difference.
15:22:38 <dcoutts> steven807: fixed the Makefile, ta for pointing out the problem
15:22:47 <steven807> sure thing
15:23:02 <dcoutts> shapr: mm, yes it needs to use --user by default rather than --global
15:23:04 <sorear> Everything is broken.
15:23:05 <steven807> glad you were listening..
15:23:11 <mdmkolbe-home> what is this distinction between 'dynamic' wm's and regular tiling wms?
15:23:21 <ndm> hi dcoutts
15:23:24 <dcoutts> hia ndm
15:23:28 <sorear> hello ndm
15:23:30 <ndm> fantastic idea about the feedback on cabal, a definate must
15:23:42 <ndm> dcoutts, although should be combined with buildbot goodness
15:23:49 <sorear> mdmkolbe-home: marketing :)
15:23:52 <ndm> hi sorear
15:24:22 <dcoutts> ndm: btw, cabal-install apparently works on windows according to mnislaih
15:24:37 <dcoutts> ndm: as of today, if I didn't break it again with my patches
15:24:38 <monochrom> sorear speaks the cold, hard truth.
15:24:58 <gds> mdmkolbe-home: I've only tried wmii, which claims to be dynamic, and xmonad, which feels similar - but the wmii claim was that you can do stuff off the keyboard that previously required scripting...
15:25:06 <dcoutts> ndm: not sure how to combine it with build-bot, have you got any ideas ?
15:25:06 <SamB_XP_> oh, cabal install works does it?
15:25:17 <dcoutts> SamB_XP_: try it, let us know.
15:25:25 <mdmkolbe-home> sorear: oh, like the marketing that says editing the source of your WM means it's more secure than reading a config file;-)
15:25:26 <sjanssen> mdmkolbe-home: the idea behind a 'dynamic' wm is that the user shouldn't have to do much manual window managing
15:25:30 <dcoutts> g'night folks!
15:25:35 <gds> So, rather than scripting a layout you like, and then breaking it by opening more windows than usual, you have a dynamic layout pattern that can cope with as many windows as you want.
15:25:36 <ndm> dcoutts, just every night have it run everything
15:25:40 <ndm> dcoutts - one quick question
15:25:50 <dcoutts> ndm: nope! bed time
15:25:59 <ndm> dcoutts, what installer stuff did you use for Gtk2hs on windows, and do you have any good docs links?
15:26:00 <mdmkolbe-home> sjanssen, gds: makes sense
15:26:57 <mdmkolbe-home> though, I'd probably keep fighting it to get it the way *I* want the windows tiled
15:27:15 <SamB_XP_> "dynamic wm" is a much more vague term
15:27:28 <sjanssen> mdmkolbe-home: the secret is to be less picky
15:28:12 <ddarius> mdmkolbe-home: The secret is to write your own wm.
15:28:12 <sjanssen> mdmkolbe-home: the dwm/xmonad tiling algorithm isn't perfect, but it's great 95% of the time (for my uses)
15:28:38 <sjanssen> or write your own layout algorithm!  New capability in xmonad
15:29:16 <gds> mdmkolbe-home: http://www.suckless.org/wiki/wmii/docs/dynamic_window_management
15:29:18 <mdmkolbe-home> sjanssen: yeah, but any professional or high end athlete is going to be picky about their tools and that is my attitude twards computers
15:29:18 <lambdabot> Title: dynamic window management &mdash; wmii/docs &mdash; suckless.org
15:29:24 <sorear> matthew_-: ping?
15:30:11 <chessguy> hi haskellers
15:30:11 <SamB_XP> mdmkolbe-home: so, what, you want the stardock version?
15:30:24 <gds> mdmkolbe-home: Personally, I find wmii/xmonad style window management does for my guiing what static typing does for my programming.
15:30:40 <gds> There are things I can't do, but the things I can do take less thought...
15:30:52 <gds> So, my mind is free to think about more important things.
15:31:04 <gds> And the things I can't do are sufficiently rare than it's a good tradeoff.
15:31:46 <sorear> @seen matthew_-
15:31:47 <lambdabot> matthew_- is in #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard matthew_- speak 7h 17m 56s ago.
15:31:59 <mdmkolbe-home> SamB_XP: no I just want the neural interfacing version.  I can already program faster than my I/O devices (hands, keyboard, mouse)
15:32:10 <chessguy> ?seen glguy
15:32:11 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
15:32:23 <sorear> @uptime
15:32:24 <lambdabot> uptime: 10d 15h 46m 20s, longest uptime: 10d 15h 46m 20s
15:32:35 <chessguy> i think he's off in the caribbean
15:33:13 * gds wonders if there's a monadic version of "repeat"...
15:33:20 <SamB_XP> might be nice if lambdabot mentioned how long he's been here...
15:33:27 <chessguy> ?hoogle repeateM
15:33:28 <lambdabot> No matches found
15:33:30 <chessguy> ?hoogle repeatM
15:33:30 <sorear> gds: 'forever'
15:33:31 <lambdabot> No matches found
15:33:36 <gds> sorear: Cheers :)
15:33:40 <sorear> gds: it's fairly new though
15:33:54 <gds> @hoogle forever
15:33:55 <lambdabot> No matches found
15:33:57 <sorear> gds: you can use 'sequence . repeat' if you ghc doesn't have it
15:33:58 <chessguy> @type repeat
15:34:01 <lambdabot> forall a. a -> [a]
15:34:04 <sorear> gds: @hoogle is ancient
15:34:14 <sorear> gds: it hasn't been updated since 6.4
15:34:17 <gds> sequence.repeat sounds good to me, thanks :)
15:34:46 <mdmkolbe-home> @type repeat
15:34:47 <sorear> Prelude Control.Monad> :t forever
15:34:47 <sorear> forever :: (Monad m) => m a -> m ()
15:34:49 <lambdabot> forall a. a -> [a]
15:35:28 <sorear> :t forever
15:35:31 <lambdabot> Not in scope: `forever'
15:35:40 <sorear> aww, lambdabot's 6.6 is too old
15:36:01 * gds notices that sequence.repeat is immune to "pkill runhaskell"...
15:36:06 <gds> ;)
15:37:16 <sorear> gds: killall ghc-6.7.20070503
15:37:27 <sorear> gds: ghc changes its name :(
15:37:37 <sorear> replace 6.7.20070503 with the version you have
15:37:42 <gds> Ah :)
15:37:50 * sorear has a very new ghc
15:38:18 <chessguy> wow, they already have a 6.7 on the devel branch?
15:38:34 <matthew-_> hey gds
15:38:40 <mdmkolbe-home> devel == ghc-HEAD ?
15:39:09 <SamB_XP> chessguy: well, yes.
15:39:15 <gds> matthew-_: Hey :)
15:39:24 <SamB_XP> it used to be called 6.5, despite it being newer than 6.6...
15:39:42 <sorear> matthew-_: I was pinging you to tell you it might be nice to provide actual code with #1323.
15:39:48 <chessguy> nice
15:40:01 <sorear> matthew-_: but, apparently you managed to attach a file without trac telling me.
15:40:10 <sorear> matthew-_: sorry about that :)
15:40:46 <matthew-_> sorear: last time I pasted code into trac, the mediawiki abomination of markup destroyed it painfully, hence the attachment
15:40:47 <sorear> @seen narain
15:40:47 <lambdabot> I saw narain leaving #haskell 6h 10m 16s ago, and .
15:41:36 <matthew-_> sorear: were you pinging matthew-_ or matthew_-; because matthew_- is several miles from here and matthew-_ has been drinking, so I doubt either would hear ;-)
15:42:30 <sorear> matthew-_: are they associated with the same human at least? :)
15:42:48 <matthew-_> yep
15:42:52 <sorear> I was trying for "Matthew Sackman", but I can't exactly use that as an address here.
15:42:55 <matthew-_> and a 10-year old single malt
15:43:17 <monochrom> I want to speak to the 10-year old single malt please.
15:43:22 <mdmkolbe-home> I just realized that ':t' doesn't properly indent do you can't just copy and paste it into your source for a function with a (til now) infered type.  Is this on purpose or could adding that indentation be an enhancement?
15:43:23 <matthew-_> howdy
15:43:31 <matthew-_> I'm golden and really smooth
15:43:46 <monochrom> I <3 you
15:43:50 <balvenie> grrrrrr
15:43:59 <balvenie> I <3 anyone who drinks me
15:44:10 <sorear> TAG
15:44:31 <mdmkolbe-home> "<3" == upside down valentine heart?
15:44:39 <sorear> sideways, actually
15:45:06 <matthew-_> right, I must go to bed. nn y'all.
15:45:07 <mdmkolbe-home> sorear: yeah, I guess it's only upside down for a smily
15:45:17 <sorear> upside down would be
15:45:17 <sorear>   /~\
15:45:17 <sorear>  /   \
15:45:17 <sorear> \_/\_/
15:45:28 <chessguy> ?time matthew-_
15:45:29 <sorear> :) are sideways too!
15:45:30 <lambdabot> Local time for matthew-_ is Thu May  3 23:43:31 2007
15:45:35 <matthew-_> need some bezier curves there sorear
15:45:39 <dibblego> google is broken?
15:45:47 <sorear> @google dibblego
15:45:50 <lambdabot> http://programming.reddit.com/user/dibblego/
15:45:50 <lambdabot> Title: overview by dibblego (on programming.reddit.com)
15:46:23 <dibblego> it all just started responding after 30 or so seconds for me :)
15:46:39 <monochrom> some router had a small problem
15:46:45 <SamB_XP> sorear: notice how :) is looking at an upside-down <3
15:47:22 <monochrom> I hate nerds and geeks.
15:47:35 <SamB_XP> monochrom: why do you hate us, why oh why?
15:47:54 <mdmkolbe-home> monochrom: the geek shall inherit the earth
15:48:04 <SamB_XP> mdmkolbe-home: s/geek/meek/
15:54:14 <adgfdcvsfdg> hi
15:55:03 <adgfdcvsfdg> "'Parser' is not applied to enough type arguments" <- what does this means?
15:55:04 <fatalis_> adgfdcvsfdg, we've been expecting you
15:55:47 <augustss> adgfdcvsfdg: it means exactly what it says
15:56:02 <monochrom> You wrote "Parser" alone at place where something like "Parser Int", "Parser Char", "Parser a", ... is expected.
15:56:03 <adgfdcvsfdg> could you explain better?
15:56:16 <fatalis_> adgfdcvsfdg, the answer is puppy
15:56:39 <fatalis_> I must go now
15:56:47 <augustss> Parser is a type constructor that should be a pllied to some number of arguments.  you have no given it enough
15:56:54 * gds discovers what he was looking for earlier :)
15:57:07 <gds> http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
15:57:16 <gds> run :: String -> IO String
15:57:22 <gds> dons++
15:57:28 <adgfdcvsfdg> "code5 :: Parser" <- i suppose you are bothered too many times because of this code...
15:57:34 <sorear> adgfdcvsfdg: What could possibly be confusing about that error message
15:57:35 <adgfdcvsfdg> but just this has a error right?
15:57:51 <sorear> adgfdcvsfdg: We need to know, we can't fix what we don't know.
15:58:12 <monochrom> You need "code5 :: Parser ____"  <-- fill in the blank there.
15:58:31 <adgfdcvsfdg> like i was thinking
15:58:37 <adgfdcvsfdg> that blank
15:58:45 <adgfdcvsfdg> some sort of variable?
15:59:01 <monochrom> The correct thing to fill in depends on details of code5.
15:59:03 <augustss> depends on what parser wants
15:59:11 <adgfdcvsfdg> parameters
15:59:19 <adgfdcvsfdg> a parameter that it will take
15:59:22 <adgfdcvsfdg> right?
15:59:23 <augustss> indeed!
15:59:32 <augustss> you could always try Int
15:59:38 <kpreid> adgfdcvsfdg: you cnould leave off the type signature, then ask ghci what the type of code5 is, then fill copy that into the source
15:59:53 <monochrom> But since we're playing merry-go-around, I no longer want to know.
16:00:13 * SamB_XP goes up and down
16:00:14 <adgfdcvsfdg> i just dont post the full code, or you will say "not again"
16:00:15 <adgfdcvsfdg> lol
16:00:22 <monochrom> @paste
16:00:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:00:29 <monochrom> The joke is on you.
16:00:30 <adgfdcvsfdg> already happened before :P
16:00:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1699
16:01:20 <adgfdcvsfdg> maybe thats not the only error :X
16:01:43 <Saizan> they are all Parser String
16:01:44 <adgfdcvsfdg> anyway i dont expect too much help
16:01:47 <monochrom> code2 :: Parser String
16:01:58 <augustss> yep
16:02:08 <monochrom> Go with Saizan.
16:02:19 * gds -> sleep pre-pumpkining
16:02:38 <Saizan> also, there's surely an error in code3
16:02:56 <sorear> adgfdcvsfdg: Once you figure out what's wrong, tell us the error message you would *like* to have seen.
16:03:15 <sorear> adgfdcvsfdg: Progress mostly occurs through newbie reports.
16:03:44 <adgfdcvsfdg> well...
16:03:49 <adgfdcvsfdg> making them all string
16:03:57 <adgfdcvsfdg> creates a new error :P
16:04:16 <adgfdcvsfdg> couldnt match type char against inferred type string
16:04:16 <monochrom> I actually disagree, but I withold my disbelieve to hear it out.
16:04:18 <augustss> of course
16:04:26 <adgfdcvsfdg> so
16:04:38 <adgfdcvsfdg> its expecting char instead of string?
16:04:47 <monochrom> which line?
16:04:51 <adgfdcvsfdg> 51
16:04:58 <augustss> code4 is consing a string onto a string
16:05:07 <adgfdcvsfdg> in the first argument
16:05:11 <adgfdcvsfdg> namely q
16:05:19 <augustss> indeed
16:05:24 <monochrom> q ++ "ss"
16:05:41 <monochrom> OK I agree with the unsaid sentiment of augustss.
16:05:52 <augustss> lol
16:06:26 <monochrom> I restore my disbelieve. There is nothing interesting to hear out.
16:06:30 * Saizan has never seen a so fantasious use of do notation
16:06:37 <augustss> adgfdcvsfdg: looking at your code it doesn't look like you really know what you are doing
16:06:53 <adgfdcvsfdg> well
16:06:54 <adgfdcvsfdg> no :X
16:09:13 <Saizan> adgfdcvsfdg: foo (do bar) == foo bar
16:09:25 <shapr> dcoutts: Also, "cabal-install install --user bzlib-0.3" fails, where "cabal-install --user install bzlib-0.3" succeeds.
16:09:57 <Saizan> e.g. many (do char 's') == many (char 's')
16:12:31 <shapr> dcoutts: On the good side, "cabal-install --user <package>" does pick the highest version and installs it.
16:12:40 <shapr> Wow, cabal-install WORKS!
16:12:58 <Pseudonym> Haskell doesn't have any non-working code.
16:13:41 <Saizan> shapr: can you try the -w option if you have another version of ghc installed?
16:13:50 <monochrom> Pseudonym has just contradicted sorear, if I understand correctly. :)
16:14:16 <Binkley> Pseudonym: I invite you to take over my job if you think that :-)
16:14:24 <Pseudonym> Does it pay well?
16:14:52 <shapr> Saizan: I only have ghc 6.6
16:15:02 <Binkley> Pseudonym: Yes, but it may not be worth the heartbreak
16:15:18 <Pseudonym> It couldn't be worse than what I'm doing now.
16:15:23 <Binkley> What are you doing now?
16:15:28 <Binkley> And seriously, we actually are hiring Haskell programmers
16:15:30 <shapr> Pseudonym: Hey, #haskell isn't that bad!
16:15:34 <shapr> Binkley: Who? Where?
16:15:36 <Binkley> heh
16:15:36 <Pseudonym> True!
16:15:54 <Pseudonym> Actually, no, I can't take your job, since my next job will be tres cool.
16:15:59 <Binkley> well, that's cool
16:16:06 <monochrom> But I can.
16:16:12 <Pseudonym> a) It gives me an excuse to learn Python, b) there's some Haskell, and c) they're seriously using STM in anger.
16:16:37 <shapr> whoa, spiffy!
16:16:49 <shapr> Binkley: Tell us more about who's hiring Haskellers?!
16:16:58 <Pseudonym> Yes, Binkley.
16:17:01 <Pseudonym> We want to know.
16:17:10 <Binkley> I work for a company called Planning Systems
16:17:32 <Binkley> there's a small but tenacious group of Haskellers, whose size is about to decrease by 1
16:17:37 <Binkley> you have to not mind that it's a defense job, though
16:17:51 <Pseudonym> Been there, done that.
16:17:55 <Binkley> if you want to know any more than that you should probably email me privately -- catamorphism at gmail dot com
16:17:56 <shapr> Hm, fulltime? contracting? telecomutting?
16:18:01 <Binkley> fulltime on-site, alas
16:18:05 <shapr> Where?
16:18:07 <Binkley> in Monterey, CA
16:18:16 <Pseudonym> Nice place, though expensive to live in.
16:18:31 <monochrom> I mind that it's a defense job. Not the job nature, but my own eligibility.
16:18:32 <Binkley> not that expensive, but it depends on your tastes...
16:18:32 <Pseudonym> Last time I was there, my taxi driver was a schoolteacher.
16:18:44 <ehird`> um, since when did foldl (*) [1, 2, 3] become invalid
16:18:58 <chessguy> @type foldl
16:19:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:19:09 <shapr> :t foldl1
16:19:12 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:19:16 <Pseudonym> That's only valid if you define (Num [Int])
16:19:17 <shapr> ehird`: Try foldl1
16:19:35 <Pseudonym> Or even better, foldl' (*) 1 [1,2,3]
16:19:41 <Pseudonym> Or even better, product [1,2,3].
16:20:16 <chessguy> Binkley: what experience level are you looking for?
16:20:31 <astrolabe> Or even better, 6
16:20:47 <Binkley> chessguy: I am not doing the hiring, for one, and it's hard for me to say
16:21:00 <Binkley> The formal job description says one thing, but it's really just a matter of being a good Haskell programmer
16:21:22 <chessguy> i meant ya'all
16:21:35 <astrolabe> I'm not going to apply for the job (wrong country), but can I ask what kind of stuff you code?
16:21:53 <Binkley> astrolabe: security software
16:22:13 <Binkley> What I mean is, I'm not the one making hiring decisions, so it's hard for me to say anything precise about qualifications
16:22:14 <ehird`> oh my. superduperfactorials are...large
16:22:37 <chessguy> are you talking about the web services position?
16:22:57 <Binkley> if you mean the HAppS position, then no, that's not related
16:23:08 <Binkley> this one hasn't been posted to the mailing list lately... I should see about doing that
16:23:24 <chessguy> i'm talking about the only position listed under Monterey on their website. http://www.plansys.com/careers/job_details.cfm?JobID=137
16:23:26 <lambdabot> Title: Planning Systems : A QinetiQ Company
16:23:27 <Binkley> oh, sorry
16:24:03 <Binkley> chessguy: not exactly
16:24:39 <Pseudonym> What a dumb name for a holding company.  I've always thought that.
16:24:43 <Binkley> chessguy: that description does suggest some of the things that the job might involve, but I don't know if they've put up a listing for the Haskell-related position yet
16:25:04 <Pseudonym> Mind you, I contribute to some OSS called "Aqsis" (pronounced "axis").
16:25:13 <Pseudonym> So I guess it's not that dumb.
16:25:29 <Pseudonym> And it's not as much an affront to English as PricewaterhouseCoopers or whatever it is now.
16:26:02 <dibblego> IBM
16:26:28 * ehird` pasted http://pastie.textmate.org/private/1ljhsu3ie7lw2uycqh
16:26:31 <ehird`> ^ now /that/'s big
16:26:34 <astrolabe> Isn't it worse?  'Q's without 'u's, and ending with a capital?
16:26:47 <Pseudonym> Yeah, maybe you
16:26:50 <Pseudonym> 're right.
16:27:06 <Pseudonym> ehird: How long does it take to print out?
16:27:20 <Pseudonym> Pasted: 3 minutes from now
16:27:22 <ehird`> Pseudonym: Not too long.
16:27:23 <SamB_XP> aqsis lacks 'u's, too
16:27:29 <Pseudonym> ehird, are you using that time warp program again?
16:27:30 <ehird`> ./bbqfac  0.10s user 0.01s system 35% cpu 0.315 total
16:27:32 <astrolabe> Also, no one can guess how to pronounce it.
16:27:34 * chessguy decides to send in his resume, for kicks of nothing else
16:27:38 <chessguy> *if
16:27:48 <Pseudonym> I'm guessing "kinetic".
16:27:53 <Binkley> chessguy -- if you want to apply for the PlanSys job, email me, because it'll probably just get lost in the shuffle otherwise
16:28:14 <ehird`> wc tells me the number produced for uh... what notation shall we  give it... how about, the number produced for 4!BBQ is 23565 characters long
16:28:27 <chessguy> at dreamhost?
16:28:41 <sorear> ehird`: meh, I've seen much bigger.
16:28:50 <Pseudonym> ehird: Right.  Yeah, I've seen bigger, too.
16:28:58 <ehird`> sorear: still :P
16:29:00 <Pseudonym> fac . fac . fac . fac $ 4 might even be bigger.
16:29:02 <astrolabe> Pseudonym: right
16:29:05 * sorear has had reason to compute numbers with >1 billion digits
16:29:20 <Binkley> chessguy: no, catamorphism at gmail dot com
16:29:25 <Pseudonym> When working with combinatorial quantities, though, I tend to use prime factorisation.
16:29:26 <chessguy> ah, ok
16:29:26 <Binkley> not sure what would happen to email sent to the other address
16:29:30 <Pseudonym> The numbers are smaller.
16:29:40 <ehird`> implodeuniverse n = product (map bbqfac (map bbqfac [0..n]))
16:29:42 <ehird`> how about that
16:29:43 <Pseudonym> And you're mostly multiplying and dividing, not adding and subtracting.
16:29:55 <sorear> graham = ...
16:29:55 <Pseudonym> ehird: Do it.  I'll watch you lag out.
16:30:11 <ehird`> yeah, that's what i thought :)
16:30:24 <chessguy> Binkley: for the record, i'm expecting an offer from another web development company soon, probably by the end of the week. but this job sounds more interesting
16:30:31 <ehird`> sorear: product (map implodeuniverse (map graham [0..n]))
16:30:35 <Pseudonym> When it gets to seriously huge numbers, printing them out takes more time than computing them.
16:30:52 <Pseudonym> busyBeaver (busyBeaver (busyBeaver n))
16:30:52 <ehird`> yeah, it's funny how IO is almost always the bottleneck for... anything
16:30:59 <Binkley> chessguy: well, I can tell you some more about it over email... I'm not going to be a cheerleader for the company, but specifics should probably not be discussed on a logged channel :-)
16:31:00 <Pseudonym> It's not IO in this case, it's show.
16:31:01 <SamB_XP> also tiny numbers!
16:31:09 <chessguy> lol, fair enough
16:31:13 <dibblego> @google liberated from the von neumann machine
16:31:15 <lambdabot> http://en.wikipedia.org/wiki/Von_Neumann_architecture
16:31:15 <lambdabot> Title: Von Neumann architecture - Wikipedia, the free encyclopedia
16:31:17 <sorear> ehird`: graham is not a function, it's a number
16:31:19 <dibblego> ehird` ^^
16:31:38 <sorear> @google can programming be liberated from the von neumann architecture
16:31:41 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
16:31:47 <dibblego> thanks :)
16:31:52 <ddarius> @where fp
16:31:52 <lambdabot> I know nothing about fp.
16:32:06 <Pseudonym> That'd be right.
16:32:07 <ehird`> sorear: i meant "graham-ize". which would "product (map (\t -> \t * graham) [0..n])"
16:32:16 <ddarius> @where+ fp http://www.stanford.edu/class/cs242/readings/backus.pdf
16:32:17 <lambdabot> Done.
16:32:21 <chessguy> Binkley: went
16:32:25 <chessguy> uh
16:32:26 <chessguy> sent
16:32:55 <Binkley> chessguy: Got it. I'll probably have a chance to respond tonight
16:33:02 <chessguy> ok cool
16:33:02 <Binkley> can't deal with my personal email easily from here
16:33:26 <chessguy> i'll check my mail when i get back from the Spiderman midnight premiere :)
16:33:34 <Binkley> :-)
16:34:16 <chessguy> it'll be late even on the west coast by then :)
16:34:18 <SamB_XP> does it end at midnight?
16:34:24 <chessguy> no, starts then :)
16:34:36 <SamB_XP> ... and they call that may 3rd?
16:34:49 <chessguy> no, 4th
16:34:51 <SamB_XP> no, wait.
16:34:58 <SamB_XP> I got the numbers mixed ;-)
16:35:03 <SamB_XP> spiderman 3, may 4th...
16:35:05 <chessguy> the 4th tends to come after the 3rd :)
16:36:05 <chessguy> even in places where you "warsh" your hands
16:36:47 <SamB_XP> the ad was just a picture of peter and M.J. with a 3 in the corner, and the date somewhere...
16:48:37 <dfranke> account creation on http://hackage.haskell.org/trac/ghc is still broken.  Who besides Simon Marlow is able to fix that?
16:48:38 <lambdabot> Title: GHC - Trac
16:50:09 <sorear> Igloo, ross, SyntaxNinja come to mind as people worth poking
16:50:21 <sorear> JaffaCake: is smarlow's nick, btw
16:52:01 <dibblego> anyone got any ideas that will allow me to post that DVD code on a website without google censoring it? a captcha?
16:53:02 <sorear> just rewrite it creatively ;)
16:53:02 <dfranke> just write the octets backward and indicate it as such.
16:53:06 <Pseudonym> dibblego: I don't know, but I'm working on a really good hash function which has a bunch of random 32-bit constants in it.
16:53:07 <sorear> Also, I imagine google looks for 'dvdcss code here'
16:53:10 <sorear> or similar
16:53:13 <jcreigh> dibblego: XOR?
16:53:16 <Igloo> I have a feeling it's deliberately broken as new accounts can't actually do anything
16:53:22 <Binkley> you could always just use this image
16:53:24 <Binkley> http://lolgeeks.com/wp-content/uploads/2007/05/lolgeeks028.jpg
16:53:26 <sorear> Igloo: yes they can!
16:53:28 <andygill> dfranke: what is broken on trac/ghc?
16:53:28 <astrolabe> Reverse the order?
16:53:42 <dfranke> andygill, if you try to create an account your get a server error.
16:53:51 <dibblego> I just want to submit my statement of protest, but as soon as I do, google takes my page off the index
16:54:03 <sorear> Igloo: So, in other words, I'm the last person who will be able to get an account.
16:54:08 <dibblego> jcreigh, I want a casual reader to be able to read it
16:54:24 <sorear> Igloo: Since you need an account before you can ask Igloo to activate it!
16:54:25 <andygill> Can you step me through the problem?
16:54:33 <jcreigh> dibblego: and automated filtering is preventing you from posting it?
16:54:59 <dibblego> jcreigh, I don't know exactly what google is doing; only that if that code is on my website, the website disappears from google within a few hours
16:55:13 <sorear> dibblego: then the harm is already done?
16:55:18 <dfranke> andygill, just click register, enter a new username and password.
16:55:22 <dibblego> sorear, I removed it and it's back
16:55:30 <dfranke> brb
16:55:41 <sorear> Oh, nice.
16:55:51 <sorear> Does it also kick in if you use a link?
16:55:52 <davidL> how do I extract the first number (a) from a triple (a, b, c) ?
16:55:59 <sorear> davidL: Pattern matching
16:55:59 <dibblego> davidL, pattern match
16:56:12 <monochrom> Write a function f (a,b,c) = a.  No built-in.
16:56:23 <andygill> ok, I see it.
16:56:24 <sorear> fst . unsafeCoerce#
16:56:25 <davidL> alright
16:56:35 <jcreigh> no *NOT* listen to sorear! :)
16:56:41 <monochrom> Haha
16:56:42 <jcreigh> *do
16:56:47 <davidL> heh
16:56:58 <sorear> it really does work!
16:57:35 <sorear> dibblego: does it still kick in if you post a link?
16:57:57 <jcreigh> sorear: "it works" is a very poor reason.
16:58:11 <jcreigh> ...but I know you were joking.
16:58:18 <jcreigh> (I hope)
16:58:42 <sorear> jcreigh: I admit it.  I was
16:59:05 <jcreigh> sorear: but that seriously works in GHC?
16:59:24 <dibblego> sorear, nfi
16:59:25 <sorear> jcreigh: well, it did last time I tried it.
16:59:39 <sorear> @irc-expand nfi
16:59:39 <lambdabot> Unknown command, try @list
16:59:50 <dibblego> no friggin idea
17:00:45 <dons> wow. haskell made the register, http://www.regdeveloper.co.uk/2007/05/03/programming_haskell/
17:00:45 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:00:55 <sorear> hi dons!
17:02:31 <davidL> > let biggestLocation xs = fromJust . flip elemIndex xs $ maximum xs in biggestLocation [1,34,7]
17:02:40 <davidL> ?botsnack
17:02:56 <lambdabot> :)
17:02:57 <lambdabot>  1
17:03:04 <Pseudonym> A common name for this function, BTW, is fst3.
17:03:09 <SyntaxNinja> y0
17:03:09 <Pseudonym> Hence snd3, thd3.
17:03:19 <Pseudonym> That's what Gofer called them, IIRC.
17:03:35 <sorear> > let biggestLocation = fst . maximumBy snd . zip [0..] in biggestLocation [1,34,7]
17:03:37 <lambdabot>      Occurs check: cannot construct the infinite type:
17:03:37 <lambdabot>       b = (a, b) -> Or...
17:03:39 <SyntaxNinja> someone said my name, but I can't find it on scrollback ;)
17:03:47 <sorear> > let biggestLocation = fst . maximumBy (comparing snd) . zip [0..] in biggestLocation [1,34,7]
17:03:49 <lambdabot>  1
17:04:03 <sorear> <dfranke> account creation on http://hackage.haskell.org/trac/ghc is still broken.  Who besides Simon Marlow is able to fix that?
17:04:03 <sorear> <sorear> Igloo, ross, SyntaxNinja come to mind as people worth poking
17:04:05 <lambdabot> Title: GHC - Trac
17:04:42 <davidL> > let biggestLocation xs = fromJust . flip elemIndex xs $ maximum xs in biggestLocation [0,0,0,0,1,0,0,0]
17:04:44 <lambdabot>  4
17:07:41 <monochrom> Do you like this solution?
17:08:01 <shapr> dcoutts: I responded, and mostly stole your answers to my questions, hope you don't mind :-) http://lwn.net/Articles/233059/
17:08:03 <lambdabot> Title: LWN: Looks practial to me.
17:10:38 <SyntaxNinja> sorear: so I'm being poked because I'm good to poke?
17:10:39 <SyntaxNinja> interesting
17:11:41 <Pseudonym> shapr: I think the complaint is that resources are not released in any sort of guaranteed timely manner.
17:12:01 <Pseudonym> I think maybe 0.5% of all applications require this, if that.
17:12:33 <Pseudonym> I should also add that Java is worse, but we already knew this.
17:14:19 <sorear> SyntaxNinja: No, you're being poked because you are the Grand High Administrator on hackage.h.o, the failuring box.
17:14:32 <SyntaxNinja> true!
17:14:34 <SyntaxNinja> failuring oh no
17:14:48 <sorear> well software failuring.
17:14:55 <sorear> people can't create accounts
17:14:55 <SyntaxNinja> oh I see.
17:14:58 <sorear> on trac
17:15:00 <SyntaxNinja> yeah, simon is the man there, or Igloo
17:15:11 <SyntaxNinja> I don't want to muck w/ that, because I'd probably configure it wrng and we'd get tons of spam.
17:15:26 <sorear> don't worry, we already get tons of spam
17:15:28 <davidL> can the maximum stack size not be set with GHCI? I tried :set -K32M but that didn't work.
17:15:43 <sorear> davidL: you need ghc +RTS -K32M
17:15:54 <sorear> davidL: on the real command line, not :set
17:15:58 <sorear> s/ghc/ghci
17:16:43 <davidL> thanks sorear
17:17:54 <dfranke> SyntaxNinja, well, as a stopgap, can you give me an account?
17:18:37 <sorear> dfranke: do you want an actual UNIX account or a Trac account? ;)
17:18:45 <dfranke> sorear, Trac.
17:19:18 <SyntaxNinja> dfranke: so what happens when you try to create an account? (by registering)
17:19:28 <sorear> I know SyntaxNinja can handle the first (technically), but the trac setup is somewhat out of his jurisdiction
17:19:37 <dfranke> [Errno 13] Permission denied: '/srv/trac/ghc/trac.htpasswd'
17:20:17 <dfranke> (or just put up a proposal ticket for the patch I sent to libraries@h.o, since that's all I need to do)
17:20:38 <sorear> dfranke: I can submit a ticket for you
17:20:47 <dfranke> sorear, ok, thanks.
17:21:00 <fridim> is  " " the same as ,  between arguments of a function?
17:21:11 <sorear> no.
17:21:24 <fridim> a_function a b c  == a_function (a b c)  but != a_function(a,b,c) ?
17:21:47 <sorear> no.
17:21:54 <sorear> a_function a b c != a_function (a b c)
17:22:01 <sorear> a_function a b c == (a_function a b) c
17:22:09 <sorear> application is *left* associative
17:22:46 <SyntaxNinja> dfranke: msg me a username nad password
17:22:59 <QtPlatypus> a_function (a b c) == a_function ((a b) c) ?
17:23:10 <monochrom> Yes.
17:23:11 <sorear> dfranke: what should the text be?
17:23:17 <sorear> QtPlatypus: yes.
17:23:20 <SyntaxNinja> strange that it's getting permission denied. the perms look good
17:23:36 <fridim> I really don't understand data
17:23:44 <fridim> as it is explained in YAHT
17:24:04 <Ashsong> QtPlatypus: rather f a b c == ((f a) b) c)
17:24:30 <monochrom> Before you continue, are you just hung up on the choice of the keyword "data"?  Would it help if you could choose another word for it?
17:24:36 <fridim> (f a) is a function that takes two argument b and c ???
17:24:39 <fridim> I don't get it
17:24:46 <sorear> fridim: yes.
17:24:52 <sorear> fridim: currying
17:24:53 <monochrom> Yes, (f a) is a function that takes two arguments.
17:24:55 <dfranke> sorear, nm.  SyntaxNinja just got me running.
17:24:59 <sorear> > ((+) 2) 3
17:25:01 <lambdabot>  5
17:25:09 <sorear> (+) takes two arguments
17:25:15 <sorear> (+) 2 takes one argument
17:25:20 <monochrom> > map ((+) 2) [3,1,4]
17:25:21 <lambdabot>  [5,3,6]
17:25:26 <Ashsong> > :t ((+) 2)
17:25:27 <lambdabot>  Parse error
17:25:36 <sorear> Ashsong: > is not ghci
17:25:36 <monochrom> demonstrates a use of the function ((+) 2)
17:25:44 <Ashsong> Well, for someone who knows how to use lambdabot. :)
17:25:44 <SyntaxNinja> w00t
17:25:47 <SyntaxNinja> <----- the power!
17:25:52 <SyntaxNinja> now where's the karma?
17:25:52 <fridim> >:t \x -> x + 2
17:25:53 <sorear> Ashsong: it is haskell
17:26:03 <sorear> dfranke++
17:26:04 <fridim> ok, I understand now, thanks
17:26:10 <sorear> :t \x -> x + 2
17:26:13 <lambdabot> forall a. (Num a) => a -> a
17:26:22 <sorear> SyntaxNinja: there. :)
17:26:23 <Ashsong> sorear: thanks for the demonstration.
17:26:39 <QtPlatypus> I thought it was more every funtion only takes one agument but returnes a funtion that takes the next arguemnt.
17:26:58 <monochrom> Yes, that is the most correct mentality.
17:27:10 <dfranke> ugh, now I feel dumb...
17:27:20 <dfranke> "To create tickets or edit the wiki, please login with username guest, password guest."
17:27:43 <monochrom> Yes, somehow guest has more privilege. It's a weird workaround.
17:28:23 <Ashsong> Mmm. FFI question:
17:28:25 <sorear> monochrom: spammers are smart enough to register accounts, but they still can't read
17:28:50 <monochrom> This is very interesting :)
17:28:55 <Ashsong> I'm trying to understand how C2hs and the FFI work as a part of understanding Gtk2hs and the Cairo binding.
17:29:09 <sorear> dcoutts: ping?
17:29:20 <Ashsong> sorear: indeed. :)
17:29:21 <fridim> How can I define a function that use a tuple (x::Int, y::Double) ? Do I need fglasgow-exts ?
17:29:30 <sorear> fridim: no
17:29:40 <sorear> fridim: just leave off the type annotations
17:29:42 <sorear> (x, y)
17:29:55 <fridim> that is an example
17:30:11 <sorear> fridim: you need -fglasgow-exts to be explicit, but it works fine and portably if you do it implicitly
17:30:17 <monochrom> f (x,y) = show x ++ show y
17:30:41 <monochrom> f :: (Int, Double) -> String
17:30:45 <ddarius> > let f :: (Int, Double) -> String; f (x,y) = show x ++ show y in f 1 3
17:30:46 <fridim> for example x::List
17:30:47 <lambdabot>  Couldn't match expected type `t1 -> t'
17:30:58 <ddarius> > let f :: (Int, Double) -> String; f (x,y) = show x ++ show y in f(1,3)
17:31:00 <lambdabot>  "13.0"
17:31:01 <sorear> fridim: drop the types
17:31:06 * ddarius is thoroughly programmed.
17:31:27 <monochrom> Don't write the type with the formal parameter.
17:31:36 <monochrom> Just don't. Please. OK?
17:31:58 <fridim> ok
17:32:03 <monochrom> Write f :: (Int, Double) -> String on a separate line.
17:32:24 <SamB_XP> hard to do in lb!
17:32:37 <monochrom> ddarius has just done it.
17:33:20 <fridim> > let f :: ([a], a) -> String
17:33:20 <lambdabot>  Parse error
17:33:34 <monochrom> Please refer to ddarius's example.
17:34:01 <fridim> yes, i've seen it, but how would you write what I wrote?
17:34:17 <monochrom> I would first ask for the function body.
17:34:26 <monochrom> Maybe I wouldn't.
17:34:47 <monochrom> > let f :: ([a],a)->String; f _ = undefined in f ("a",'a')
17:34:49 <lambdabot>  Undefined
17:35:23 <fridim> f ([a], a) = lenght [a] + a   ; for example
17:35:34 <monochrom> The return type will not be String.
17:35:46 <monochrom> The parameter type will not be ([a],a).
17:35:47 <fridim> f ([a], a) = show (lenght [a] + a)   ; for example
17:36:02 <monochrom> The parameter type will still not be ([a],a).
17:36:09 <sorear> fridim: where is lenght defined?
17:36:15 <monochrom> Fine. I'll do it.
17:36:19 <fridim> (length)
17:37:00 <monochrom> > let f :: ([a], Int) -> String; f (x,y) = show (length x + y) in f ("aaa", 10)
17:37:01 <lambdabot>  "13"
17:38:34 <lispy> is there a way to get wxhaskell on win32 without compiling wxwidgets first?
17:38:55 <lispy> i'm having a lot of trouble getting wxwidgets to compile and that seems to be a prereq
17:39:01 <fridim> why in my Prelude, if I don't type the f (x,y) = ... on the same line it doesn't work ? (not in the same scope)
17:39:10 <monochrom> "your" Prelude?
17:39:21 <fridim> in the Prelude
17:39:30 <lispy> fridim: are you using ghci?
17:39:33 <monochrom> You are writing the Prelude?
17:39:33 <fridim> yes
17:39:45 <monochrom> ghci limitation
17:39:47 <lispy> monochrom: i think fridim is seeing the Prelude> prompt
17:40:04 <fridim> I'am using Prelude module with ghci (I suppose)
17:40:28 <lispy> fridim: you're in your own module, but it is saying the Prelude (a very standard module) is already loaded
17:40:50 <lispy> fridim: hence our confusion at first :)
17:41:01 <fridim> It seems using Prelude not so good to begin. I guess it's better to write my own .hs
17:41:14 <monochrom> Won't change that.
17:41:41 <lispy> fridim: ghci is for evaluating expressions not for writing function definitions
17:41:58 <monochrom> Oh, if you write your f in your own .hs, yes you can break it into two lines, also omit "let".
17:42:02 <lispy> fridim: but, as a trick, "let" is an expression so you can cheat and define functions in ghci
17:42:07 <olsner> is there a function to do ((a -> b) -> IO a -> IO b) or the equivalent in a monad?
17:42:18 <fridim> ok.
17:42:24 <monochrom> liftM.  also works for other monads.
17:42:25 <ddarius> liftM
17:42:28 <lispy> ?hoogle (a->b) -> IO a -> IO b
17:42:29 <ddarius> fmap more generally
17:42:29 <lambdabot> No matches, try a more general search
17:42:43 <ddarius> @hoogle (a -> b) -> m a -> m b
17:42:43 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
17:42:44 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
17:42:44 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:42:53 <lispy> :t liftM
17:42:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:42:57 <dons> :t ap
17:42:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:44:17 <olsner> test.hs:48:18: Not in scope: `liftM'
17:44:31 <ddarius> @hoogle liftM
17:44:32 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
17:44:32 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
17:44:32 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
17:44:32 <dmwit> import Control.Monad
17:44:35 <dons> Control.Monad
17:44:43 <dmwit> :t fmap
17:44:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:45:10 <monochrom> > fmap id (putStr "x")
17:45:12 <lambdabot>  <IO ()>
17:45:16 <monochrom> OK nice.
17:45:38 <monochrom> > fmap id (return "x")
17:45:39 <lambdabot>   add an instance declaration for (Show (f [Char]))
17:45:45 <dmwit> > (+1) `fmap` (*3) 7
17:45:46 <lambdabot>   add an instance declaration for (Num (f a))
17:45:57 <monochrom> :type fmap id (return "x")
17:46:07 <dmwit> :t fmap id (return "x")
17:46:08 <dons> :t
17:46:09 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => f [Char]
17:46:42 <dmwit> :t fmap (+1) (*3)
17:46:45 <lambdabot> forall a. (Num a) => a -> a
17:46:55 <dmwit> > fmap (+1) (*3) 7
17:46:57 <lambdabot>  22
17:47:01 <monochrom> I'm actually used to entering :type :info etc.
17:47:14 <dmwit> ?type fmap id (return "x")
17:47:17 <lambdabot> forall (f :: * -> *). (Monad f, Functor f) => f [Char]
17:48:25 <olsner> liftM did the trick... but why is there an 'fmap' and 'ap' as well?
17:48:35 <ddarius> ap is different
17:48:41 <ddarius> fmap is more general
17:48:56 <CosmicRay> arjanoosting: what happened to Text.Regex in Hugs?
17:49:00 <ddarius> liftM is kind of annoying and neat at the same time
17:49:05 <dmwit> ap generalizes liftM2, liftM3, etc.
17:49:30 <ddarius> :t ap . return
17:49:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
17:50:09 <dmwit> :t \f a b c -> return f `ap` a `ap` b `ap` c
17:50:12 <lambdabot> forall a a1 a2 b (m :: * -> *). (Monad m) => (a -> a1 -> a2 -> b) -> m a -> m a1 -> m a2 -> m b
17:50:51 <dmwit> ?pl \f a b c -> return f `ap` a `ap` b `ap` c -- how smart are you, @pl?
17:50:51 <lambdabot> ((ap .) .) . liftM2
17:52:02 <dolio> pl doesn't know about anything higher than liftM2, does it?
17:52:32 <ddarius> pl == compiler to combinators for a fixed set of combinators
17:53:02 <dolio> ?. pl undo do \f a b c -> do { x <- a ; y <- b ; z <- c ; return (f x y z) }
17:53:03 <lambdabot> flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=)) . flip ((.) . (.) . (>>=)) . (((return .) .) .)
17:53:33 * dmwit sniffs
17:53:37 <dmwit> That is a thing of beauty.
17:53:42 <dmwit> It brings tears to my eye.
17:54:05 <olsner> tears indeed
17:55:19 <ddarius> @djinn f :: Eq a => a -> a -> Bool
17:55:20 <lambdabot> Cannot parse command
17:55:44 <sorear> ddarius: sorry, lambdabot's djinn fork hasn't been updated (afaik ever)
17:55:46 <dmwit> djinn doesn't know about type classes...
17:56:01 <sorear> dmwit: djinn, the real thing on augustss 's website, DOES
17:56:07 <chessguy> @djinn a -> a -> Bool
17:56:07 <lambdabot> f _ _ = False
17:56:12 <dmwit> ah
17:56:17 <sorear> dons: is it possible for lambdabot to use out of tree tools?
17:56:28 <dons> interresting GADT/monad/pattern papers on LtU .... for F#
17:56:39 <sorear> lambdabot has an out of date copy of djinn in the tree.
17:56:42 <dons> now I start to wonder if F# isn't going to kill OCaml
17:56:49 <dons> sorear: ah I can update.
17:56:54 <sorear> dons: does F# work on Linux?
17:57:06 <dons> no idea.
17:57:09 <dons> i guess not.
17:57:13 <dibblego> sorear, yes, I use it with mono
17:57:22 <sorear> dons: yeah, but do you want to be pulling djinn changes for the rest of your maintainership?
17:57:29 <sorear> is it OSS?
17:57:37 <dons> sorear: that's the plan, and I do it on occasion
17:57:40 <dons> usually when the author reminds me
17:57:44 <chessguy> mono? is that the *nix version of .net?
17:57:59 <siti> lol
17:58:06 <sorear> chessguy: it's a clone of .net
17:58:13 <siti> .net is a standard :p
17:58:21 <sorear> .net is theoretically designed for clonability, like javascript
17:58:23 <siti> there's just a few implementations of that standard
17:59:33 <siti> problem with f# is that it gets compiled to msil which is not designed for functional languages...
18:00:15 <jcreigh> there's 2 types of standard: One type of standard only has one real, practical implementation and tends to be defined by that implementation. The other types has dozens of implementations, and tends to be, well, non-standard.
18:00:37 <siti> hehe
18:00:43 <sorear> Which category is Haskell in?
18:00:46 <dibblego> msil is far more adapted to FP languages than the JVM ever will be and "you've only gotta be beter than the next guy"
18:00:57 <Cale> sorear: Both :)
18:01:02 <jcreigh> sorear: I'd say the former, due to GHC
18:01:14 <jcreigh> Haskell' is basically GHC, right?
18:01:18 <Cale> no
18:01:19 <dons> GHC has a big sway over the standard.
18:01:25 <dons> jcreigh: nah, there's features from jhc in particular
18:01:26 <Cale> It's a small subset of what's in GHC.
18:01:40 <dons> and yes, only a bit of what's in GHC
18:01:46 <jcreigh> Okay, Haskell' is GHC-- then. :P
18:01:48 <sorear> ndm: "Can we forget about all compilers that don't start with G?"
18:02:11 <dons> and by compilers he meant interpreters
18:02:29 <dons> and I say, yes. we can forget about performance optimisations for hugs.
18:02:56 <sorear> you've always been anti-hugs
18:03:10 <sorear> we should force you to start ghc more than once a month
18:03:30 <dons> all my recent libraries are tested with hugs, sorear
18:03:41 <sorear> or maybe we should put nop back in nobench :)
18:03:42 <jcreigh> "Don't get me wrong, some of my best friends are Hugs users..."
18:03:43 <dons> i just don't see how it is even remotely feasible to optimise bytestring or binary for hugs
18:04:14 <Cale> Hugs users just shouldn't complain about performance.
18:04:19 <Cale> That's not what hugs is for.
18:04:21 <dons> right. ndm should know better.
18:04:22 <siti> yep
18:04:28 <sorear> In the Long Run, I think the best approach is some kind of ABI for haskell.
18:04:31 <dons> esp. now hugs is the slowest of the lot
18:04:54 <sorear> dons: the question is jhc/yhc -O11.
18:04:59 <QtPlatypus> ABI? Abstract Binary Interface?
18:05:09 <Cale> An ABI would add certain inflexibilities which would not be helpful to researchers.
18:05:12 <dons> compilers are fine. i'm happy to optimise bytestring for compilers
18:05:14 <sorear> dons: WPO is much slower than GHC because nobody cares about other compilers.
18:05:24 <dons> but yhc and jhc don't support enough of haskell.
18:05:44 <sorear> how about nhc then, that's a compiler
18:05:45 <dons> and nhc/yhc's foreign array impl. is terrible
18:05:48 <sorear> moreso than yhc
18:05:49 <dons> so that could be fixed.
18:06:07 <dons> rather than having bytestring default to [Char] when compiler == nhc/yhc
18:06:17 <Cale> hbc's Array is apparently really good relative to GHC's. I wonder why exactly that is.
18:06:18 <siti> although arrays in haskell are terrible.
18:06:48 <dons> siti, well, there's good and there's bad. its a mixture
18:06:50 <Cale> Arrays are okay. Actually I really like the immutable array interface.
18:06:56 <sorear> what I think should exist is a reasonable way of thunking between haskell abis
18:07:05 <Cale> It's probably the best immutable array interface I've come across.
18:07:05 <sorear> ghci can load code compiled with ghc
18:07:13 <sorear> hugs should too
18:08:03 <Cale> Oh, perhaps there ought to be a standard way to store thunks (at least, if they don't contain nonstandard kinds of code)
18:08:29 <Cale> So you could have GHC or Hugs or YHC convert to and from that format.
18:08:38 <Cale> Obviously in IO.
18:09:36 <Cale> So, not quite a common core, but something with homomorphisms between the cores of Haskell implementations :)
18:09:55 <sorear> Cale: I didn't mean thunking that way.
18:10:20 <sorear> Cale: thunks are what windows calls the 16-to-32-bit wrapper functions - is that not standard?
18:10:41 <Cale> Oh, that sense
18:11:01 <Cale> Well, such a core would permit that sort of thing, wouldn't it?
18:11:15 <Ashsong> dons: you might have enough FFI experience to be able to answer my question.
18:11:17 <Cale> It's important not to completely tie implementations down to using a specific core language.
18:11:34 <Ashsong> I'm looking for an injection function from Haskell->C.
18:11:54 <Ashsong> I think it should have type (Matrix -> Ptr Matrix).  Matrix is Storable.
18:11:56 <Cale> But to have some sort of Haskell pidgin-core would be nice.
18:12:07 <Ashsong> Does this need to go through a StablePtr?
18:12:07 <sorear> Ashsong: 'with'
18:12:12 <sorear> Ashsong: no!
18:12:24 <Ashsong> sorear: tried that. C2hs complains "invalid syntax"
18:12:39 <Ashsong> Which doesn't make much sense. However, I don't understand the C2hs code well enough to know why it thinks that's invalid.
18:12:42 <sorear> Ashsong: this is pure haskell, c2hs shouldn't notice
18:12:53 <Ashsong> sorear: so I thought.
18:13:04 <Cale> dons: You know more about core than I do, how possible does that sort of thing sound?
18:13:56 <sorear> Cale: Core is not executable
18:14:11 <Ashsong> Cale: you might also enjoy talking to Rob Dockins on this subject.
18:14:26 <sorear> Cale: and many vital optimizations are performed at the STG stage, so making Core executable would hurt performance
18:14:27 <Ashsong> Cale: he and I had a nice chat about unifying Cores when we met at TFP
18:14:36 <Cale> sorear: Well, depends on which compiler you're talking about there :)
18:15:12 <Cale> I suppose it would be rather difficult to go from compiled code back to something looking like core.
18:15:57 <Ashsong> sorear: what do you make of the error:
18:16:07 <Ashsong> Graphics/Rendering/Cairo/Internal/Drawing/Transformations.chs|31| (column 60) [ERROR]
18:16:13 <Ashsong> Graphics/Rendering/Cairo/Internal/Drawing/Transformations.chs|31| (column 60) [ERROR]
18:16:22 <Ashsong> ||   >>> Syntax error!
18:16:29 <Ashsong> ||   The phrase `with' is not allowed here.
18:16:57 <Ashsong> This is coming from a single line:
18:16:59 <Ashsong> {#fun transform          as transform        { id `Cairo', with `Matrix' } -> `()'#}
18:20:34 <sorear> that's not haskell
18:20:41 <sorear> (nor do I know much about it)
18:20:45 <sorear> wait for dcoutts :(
18:22:17 <Ashsong> Okay.
18:22:41 <Ashsong> Well, thanks for confirming that `with' is what we think *should* be right (from an FFI perspective)
18:22:54 <Ashsong> :)
18:31:40 <sorear> a pre-project google turns up:    You have reached the server of the mod_haskell project: integrating the Hugs Haskell interpreter into Apache so that
18:31:45 <sorear> hugs!?
18:31:53 <sorear> yay ;)
18:34:11 <olsner> what you really want is to write or find a 20-line HTTP server in haskell :P
18:35:22 <sorear> Most people have existing Apache installs.
18:35:24 <dons> there's some other mode_haskells out there
18:35:35 <sorear> :80 HTTP servers can't coexist.
18:38:14 <Ashsong> sorear: So check this out.
18:38:18 <ddarius> olsner: Why would you need 20 lines?
18:38:22 <Ashsong> C2hs lexes "with" as a special token.
18:38:47 <Ashsong> Apparently that token is illegal in the production for "parm" in the "fun" non-terminal's production.
18:39:11 <Ashsong> Consequently, writing the equation "w_th = with" and string-replacing gets past C2hs and typechecks.
18:39:15 <Ashsong> Grr.
18:39:17 <Ashsong> :)
18:39:49 <ddarius> :t with
18:39:51 <lambdabot> Not in scope: `with'
18:40:10 <Ashsong> It's in Foreign.Marshal
18:40:21 <Ashsong> (.Utils)
18:40:25 <Ashsong> @hoogle with
18:40:26 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
18:40:26 <lambdabot> Network.withSocketsDo :: IO a -> IO a
18:40:26 <lambdabot> Distribution.PackageDescription.withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
18:40:39 <sorear> Ashsong: the firsty.
18:40:43 <Ashsong> Yes.
18:41:17 <Ashsong> And C2HS thinks its a `with-token', rather than a Haskell identifier.
18:41:36 <Ashsong> I wonder if this is a bug?
18:41:39 <olsner> yeah! polyparse actually managed to do some parsing - and that on the wildly unoptimized grammar from the C++ Standard
18:41:49 <sorear> yay!
18:41:56 <sorear> which polyparse parser?
18:42:05 <olsner> I went with PolyState
18:42:23 <sorear> I'm sure malcolmw would be interested to hear of uses.
18:43:42 <olsner> the nicest thing is that I don't even have to *care* about the expression of the grammar
18:44:01 <sorear> report, report! :)
18:44:13 <ddarius> @where polyparse
18:44:14 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
18:45:24 <olsner> report? where to? to whom? why?
18:46:31 <sorear> Malcolm.Wallace@cs.york.ac.uk , Malcolm Wallace, because the authors of minor libraries care about users.
20:02:17 <Ashsong> sorear: Is there something obvious that I need to add to a .cabal file to make Cabal clean up after C2hs or is this a bug in Cabal?
20:03:01 <sorear> Ashsong: I'm not kidding
20:03:12 <sorear> Ashsong: I really *have never used* c2hs
20:03:52 <Ashsong> sorear: I understand that, and I fixed the problems I was having there.
20:04:12 <Ashsong> (Up to type-checking. I don't know if the library will immediately segfault.)
20:04:55 <dons> heh
20:04:57 <Ashsong> sorear: I was wondering, in this question, if you were familiar enough with Cabal to comment on whether Cabal normally cleans up after its supported preprocessors, whether special effort is required, or whether there's no support.
20:04:59 <dons> ffi bindings can be like that
20:05:07 <dons> cabal I thought, did clean up.
20:05:29 <Ashsong> cabal mostly cleaned up, but it left a bunch of .chi and .chs.h files lying around.
20:05:42 <dons> hmm.
20:06:13 <Ashsong> I'm not familiar enough with Cabal to know if this is intentional or if I'm not configuring Cabal properly or if it's a bug.
20:06:30 <dons> well, I don't see any special handling in , say, X11-extras, which uses c2hs
20:06:34 <dons> so it might just be a feature :}
20:07:02 <sorear> dons: X11-extras doesn't use c2hs
20:07:34 <dons> $ ls  Graphics/X11/Xlib/Extras.hsc
20:07:34 <dons> Graphics/X11/Xlib/Extras.hsc
20:07:42 <sorear> Yeah, .hscj
20:07:48 <dons> ah yeah oops
20:07:48 <sorear> > "hsc" == "chs"
20:07:50 <lambdabot>  False
20:07:55 <dons> that's right, we have 2 preprocessors
20:08:06 <dons> Ashsong: in that case, yes, c2hs might well leave behind files
20:08:21 <Ashsong> dons: It's not a big deal. Just a nit really.
20:08:35 <Ashsong> dons: The question was whether it was a nit that should end up in a bugtracker.
20:08:43 <Ashsong> :)
20:09:50 <dons> sorear: here's a job for you. you like parsers, yeah?
20:10:02 <dons> and you like Haskell, yeah?
20:10:10 <sorear> yes...
20:10:20 <dons> want to implement the system described in "Franois Pottier and Yann Rgis-Gianas. Towards efficient, typed LR parsers. In ACM Workshop on ML, volume 148(2) of Electronic Notes in Theoretical Computer Science, pages 155-180, March 2006."
20:10:29 <dons> strongly typed parsers using GADTs
20:10:40 <dons> http://pauillac.inria.fr/~fpottier/biblio/pottier_abstracts.html#pottier-regis-gianas-typed-lr
20:10:42 <sorear> ooh, that actually sounds fun
20:10:43 <lambdabot> http://tinyurl.com/2hc6ov
20:10:57 <dons> "The LR parser generators that are bundled with many functional programming language implementations produce code that is untyped, needlessly inefficient, or both. We show that, using generalized algebraic data types, it is possible to produce parsers that are well-typed (so they cannot unexpectedly crash or fail) and nevertheless efficient."
20:11:12 <sorear> strongly typed LR parsers already exists - Frown uses them
20:11:15 <dons> sound fun, no?
20:11:26 <dons> using GADTs though?
20:11:30 <Ashsong> sorear: better move quickly, or Oleg might beat you to it.
20:11:32 <Ashsong> :)
20:11:40 <sorear> Ashsong: March 2006
20:11:49 <sorear> Ashsong: Oleg is *always* faster than that.
20:11:52 <sorear> :)
20:12:08 <dons> the other thing would be to try to outperform happy or similar
20:12:09 <sorear> frown is on the first google page!
20:12:13 <dons> but without the unsafeCoerce#
20:12:21 <sorear> yeah, cause GHC is type-directed
20:12:36 <sorear> something tells me ghc can't optimize across :CoUnsafe
20:19:02 <ddarius> dons: Have you seen the Hinze paper I referenced in reply to that LtU post?
20:19:38 <sorear> Given that I'm a bit short on dragons, what good LALR introductions exist?
20:22:13 <dons> ddarius: yeah, a while ago.
20:22:31 <dons> sorear: hmm. dragon book? ask santa claus for a copy?
20:22:48 <dons> sorear: or check the online lecture notes for cs3131 at unsw?
20:23:18 <dons> sorear: somewhere here, http://www.cse.unsw.edu.au/~cs3131/
20:23:19 <lambdabot> Title: COMP3131/9102 Programming Languages and Compilers
20:23:31 <sorear> ty...
20:23:54 <dons> may as well start with your 3rd year uni courses now, eh?
20:23:56 <dons> why wait.
20:24:13 <dons> this course is taught from the dragon book, btw.
20:24:41 <sorear> my current approach of lazy education is, alas, filling my brain with closures
20:24:59 <dons> heh. you need focused, directed tasks maybe.
20:25:06 <dons> to force eval of certain areas.
20:25:12 <dons> having to sit down and write about something helps with this
20:25:20 <dons> writing is sort of a deepSeq for brain thunks
20:25:36 <dons> you could try blogging, perhaps.
20:25:39 <monochrom> It leads to stack overflow.
20:26:08 <dons> sorear: try, say, writing down the story of wadler/daan pretty printing
20:26:21 <dons> once that's done, with references et al, try writing on something else you're working on
20:26:32 <dons> you could do 1 article a week, and that'd help round off each thing you're learning
20:26:52 <Ashsong> dons: Is the validity of the build supposed to depend on the order that the elements of "other-modules:" are listed in?
20:27:00 <dons> Ashsong: hmm...
20:27:12 <sorear> Yay for blind spots.
20:27:15 <dons> Ashsong: I don't know off hand what the property is
20:27:23 <sorear> "* Check your email _at least every second_"
20:27:32 <Ashsong> dons: Just curious.
20:27:35 <Ashsong> ...
20:27:36 <Ashsong> :)
20:27:40 <dons> its a good question
20:27:54 <Ashsong> I have a build (fortunately in version control) that fails with one order but succeeds with another.
20:28:07 <dons> there's no dependency analysis in cabal
20:28:11 <dons> which would lead to this issue
20:28:17 <Ashsong> Hmm. Lovely.
20:28:29 <dons> basically, any time you avoid dependency analysis (such as for preprocessing) you better get the order right
20:28:36 <Ashsong> (The issue was masked by the fact that cabal clean doesn't delete those .chi files)
20:28:38 <sorear> What is NON-syntax-directed translation?
20:28:52 <Ashsong> Hence when I manually deleted them, the build started failing because dependencies weren't being built in the right order.
20:28:53 <dons> sorear: weird scary languages you don't want to know about ;-)
20:29:18 <dons> Ashsong: yes, sounds plausible
20:29:43 <Ashsong> dons: Consequently, there's something that should change here. Either those intermediate files should be cleaned up automatically or the dependencies should be figured out.
20:30:03 <Ashsong> Otherwise it's very hard to test whether your cabalized library builds.
20:30:04 <dons> Ashsong: sounds like a cabal bug report. do you think you could submit one/cc. cabal@
20:30:04 <Ashsong> ...
20:30:27 <Ashsong> I'd be happy to. Where should it go?
20:30:45 <dons> you could just raise it in an email on the cabal developers list first
20:30:55 <Ashsong> Okay.
20:31:00 <dons> for that, check haskell.org's mailing list page for the details
20:31:00 <Ashsong> What address is that?
20:31:04 <Ashsong> okay.
20:31:08 <Ashsong> Thanks.
20:31:34 <sorear> yay, bunzip2 has been running for 22 minutes...
20:31:41 <Ashsong> cabal-devel, it would seem.
20:34:05 <sorear> "Design Issues in Hand-Crating a Scanner"
20:35:04 <Korollary> crafting?
20:35:08 <Korollary> creating?
20:35:33 <sorear> It said Crating.
20:35:38 <TSC> Maybe it means manual packaging
20:35:40 <sorear> I think it meant Crafting
20:35:50 <sorear> but Crating just sounds soo much funnier
20:36:22 <Korollary> I'll go with the alternative hand-barreling
20:37:18 <Korollary> Hmm, what the hell is a typed LR parser
20:37:37 <sorear> joy bunzip2 is slow.  I've let it run half an hour and the output file is still only 6.6G
20:37:53 <sorear> one that the compiler can prove won't crash
20:38:00 <sorear> yacc uses unions (fast)
20:38:08 <sorear> happy uses unsafeCoerce#
20:38:14 <sorear> frown uses ... ADTs
20:38:23 <sorear> (to multiplex subtree types)
20:39:00 <ddarius> With the -cs option, frown uses a collection of ADTs.
20:39:19 <sorear> dons: I only see a red border on the bottom and left sides of my window.  (this is *probably* a monitor issue)
20:39:29 <Korollary> I have never looked into happy's output. Wow.
20:39:56 <ddarius> sorear: Press the little buttons or turn the knobs to adjust the horizontal/vertical alignment.
20:40:11 <kc5tja> @hoogle [a] -> a
20:40:12 <lambdabot> Prelude.head :: [a] -> a
20:40:12 <lambdabot> Prelude.last :: [a] -> a
20:40:12 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
20:40:21 <sorear> indeed.  M-S-enter M-space lets me see other borders
20:40:32 <kc5tja> @hoogle (Monad m) => [m a] -> m [a]
20:40:33 <lambdabot> Prelude.head :: [a] -> a
20:40:33 <dons> sorear: sounds like a tweak to your monitor width/height?
20:40:34 <lambdabot> Prelude.last :: [a] -> a
20:40:40 <sorear> ddarius: ironically, this is an LCD monitor
20:40:47 <Cale> heh
20:40:47 <sorear> ddarius: running at native resolution
20:40:54 <Cale> kc5tja: sequence
20:40:58 <dons> could be one pixel too wide?
20:41:06 <kc5tja> Cale: That's what I thought.
20:41:07 <sorear> ddarius: you'd think the pixels would be in one-to-one correspondence...
20:41:08 <kc5tja> :t sequence
20:41:11 <lambdabot>     Ambiguous occurrence `sequence'
20:41:11 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:41:17 <Cale> :t Prelude.sequence
20:41:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:41:24 <sorear> LCD with analog (widthless) input
20:41:24 <kc5tja> Thanks.
20:41:38 <Cale> For some reason lambdabot imports too many modules unqualified
20:42:15 <Korollary> Heh. So when do we get a happy+GADTs?
20:43:04 <Korollary> Nothing fun like shift/reduce tables.
20:43:19 <kc5tja> @hoogle m [a] -> m a
20:43:20 <lambdabot> Prelude.id :: a -> a
20:43:20 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:43:20 <lambdabot> Prelude.asTypeOf :: a -> a -> a
20:43:41 * kc5tja sighs -- I'm just not having much luck using Hoogle.
20:44:01 <kc5tja> Cale: Any ideas on a function to translate M [a] -> M a?
20:44:08 <Korollary> sequence and fold?
20:44:09 <kc5tja> I want to say 'join', but it's not finding it.
20:44:12 <Korollary> @type sequence
20:44:19 <lambdabot>     Ambiguous occurrence `sequence'
20:44:19 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
20:44:23 <Cale> kc5tja: you mean m [[a]] -> m [a] ?
20:44:31 <Cale> fmap concat
20:44:39 <kc5tja> No, I mean m [a] -> m a
20:44:43 <Cale> :t fmap head
20:44:46 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f a
20:44:48 <ddarius> fmap last!
20:44:59 <Cale> :t fmap concat
20:45:07 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
20:45:16 <ddarius> :t fmap (!!42)
20:45:19 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f a
20:45:27 <Cale> fmap head of course relies on there being an element in the resulting list
20:45:37 <Cale> So be careful with head as always.
20:45:40 <kc5tja> I think maybe fmap last will do it, because I want everything from start to finish to be executed.
20:45:45 <Cale> er
20:45:47 <Korollary> you want sequence
20:45:47 <Cale> hm?
20:45:51 <Cale> sequence, yeah
20:45:53 <kc5tja> Korollary: I'm already using sequence.
20:46:06 <kc5tja> I'm going [IO ()] -> IO [()]
20:46:11 <Cale> oh
20:46:13 <kc5tja> Now I need to go from IO [()] to IO ()
20:46:15 <Cale> sequence_
20:46:19 <Cale> @t sequence_
20:46:25 <ddarius> fmap mconcat
20:46:25 <ddarius> :t fmap mconcat
20:46:25 <lambdabot> forall a (f :: * -> *). (Monoid a, Functor f) => f [a] -> f a
20:46:25 <Cale> :t sequence_
20:46:29 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:46:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
20:46:32 <Cale> grrr
20:46:36 <Cale> :t Prelude.sequence_
20:46:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
20:46:53 <Cale> It throws away the result
20:47:04 <kc5tja> But evaulates it all the same?
20:47:06 <Cale> also you could do: fmap (const ()) . sequence
20:47:11 <ddarius> :t (>> return ())
20:47:12 <Cale> which is basically the same
20:47:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:47:27 <kc5tja> @src Prelude.sequence_
20:47:29 <lambdabot> Source not found. Where did you learn to type?
20:47:38 <Cale> @src sequence_
20:47:39 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:47:47 <kc5tja> Your mom's house.  >:(
20:47:53 <kc5tja> I really wish lambdabot didn't insult.
20:48:17 <kc5tja> Ahh, nice!
20:48:21 <kc5tja> That's precisely what I'm looking for!
20:48:26 <monochrom> I like the insult.
20:48:35 <sorear> dons did it
20:48:55 * Cale downloads series one of Saxondale
20:49:11 <ddarius> It's a 'bot responding mechanically.
20:50:03 <monochrom> It prepares us for all sorts of insults from outside the community.
20:50:23 <sorear> what is this "outside" of which you speak?
20:50:29 <dons> monochrom: heh
20:51:08 <Cale> Haskell: It's not just the greatest programming language. It's the only programming language.
20:52:05 <Cale> heh
20:52:09 <monochrom> One day someone is going to post "I installed haskell [sic] and it says gcc not found. where did you people learn to type?"  We'll be like "we've heard that one."
20:55:57 <sorear> @remember monochrom One day someone is going to post "I installed haskell [sic] and it says gcc not found. where did you people learn to type?"  We'll be like "we've heard that one."
20:55:58 <lambdabot> Done.
21:00:49 <narain> hello
21:02:07 <Korollary> > "hello"
21:02:12 <lambdabot>  "hello"
21:03:24 <sorear> hello.
21:03:57 <monochrom> "hello"
21:04:36 <narain> sorear: i see the buggy feed hasn't been changed
21:04:49 <narain> did you get my response?
21:06:39 <sorear> yes
21:06:47 <sorear> should I have done something?
21:07:37 <narain> no
21:24:19 <kc5tja> back
21:24:51 <kc5tja> Yes, I'm aware it's a bot responding mechanically.  I just don't like the insults.  I don't find it humorous.  (I don't particularly find it insulting either; ANNOYING maybe, but, that's an opinion)
21:25:58 <Korollary> It
21:26:01 <Korollary> It's annoying.
21:26:29 <kc5tja> Well, I /ignore lambdabot until I need it.  ;)
21:27:17 <sorear> @where lambdapot
21:27:18 <lambdabot> I know nothing about lambdapot.
21:27:20 <sorear> @where lambdabot
21:27:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:27:28 <kc5tja> lambdapot -- I like it.  :D
21:27:34 <sorear> patches are probably the best way to persuade him
21:27:58 <Pseudonym> I find it annoying too, FWIW.
21:28:22 * narain votes against giving lambdabot a personalityectomy
21:28:22 <kc5tja> sorear: Well, they disappeared for a while, and now they're back again, so I'm not thinking patches are going to work (for long).  It's not that big an issue.
21:29:16 <Korollary> Submit a GHC patch instead that detects lambdabot compilation and suppresses trash talk
21:29:32 <kc5tja> That's the Windows solution to everything.
21:30:15 <kc5tja> And on my box, ghc is some 10MB in size, no doubt detecting idiomatically every program you can possibly feed it, and emitting just the right executable as a result.  :)
21:31:15 <merus> it'd have to be a mite bigger than 10MB for that
21:33:26 <dons> as I've said maybe 10 times now, "<dons> yeah, patches are always welcome"
21:33:48 <scsibug> are there any HAppS gurus around? I've got a beginner's question.
21:34:00 <dons> but people are happier to complain, than write patches. so we still have insults.
21:34:24 <dons> and lambdabot will keep insulting till someone is insulted often enough, or bad enough, to type 'darcs send'
21:34:28 <dons> so its all good
21:34:53 <kc5tja> dons: And like I said above, there was a period of time when the insults were turned off.  But now they're back.  So someone had submitted a patch, and another reverted it.  It seems the insulters want it really bad.
21:35:08 <sorear> I'll be back... my monitor cable is loose and I don't liike hot surgery :)
21:35:13 <dons> they weren't, no.
21:35:22 <dons> the were enabled around new year, and haven't been disabled at any point since
21:35:35 <dons> no one has submitted a patch that i'm aware of.
21:35:56 <ddarius> kc5tja: Perhaps it was a different lambdabot.
21:36:04 <kc5tja> might have been.
21:36:25 <thetallguy> Maybe we could patch it to only insult people who haven't submitted a patch?
21:36:34 <dons> kc5tja: do you have any references for this? there's really no conspiracy, just 3 or 4 people who complain but don't send patches.
21:36:40 * kc5tja was thinking of putting a lambdabot instance in my own IRC room too, but only for the quotes and where facility.
21:36:43 <dons> thetallguy: i like that idea.
21:36:58 <dons> basically, the more you patch, the nicer lambdabot is to you
21:37:08 <kc5tja> dons: LIES!  It's all the neoconservative conspiracy against the free man!  I'm on to you...
21:37:18 <thetallguy> The hard part would be mapping irc names to patch owners
21:37:26 <kc5tja> Only anecdotal memory, unfortunately.  Nothing documented.
21:37:34 <dons> that's possible yes. lambdabot is part of a larger neo-con agenda, in cahoots with the military-industrial complex
21:38:07 <ddarius> Indeed.
21:44:41 <Ashsong> Yeehaw. Cairo is freed from Gtk2hs!
21:44:45 <Ashsong> (at least somewhat)
21:45:30 <sorear> @seen dcoutts
21:45:30 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 6h 19m 40s ago.
21:45:49 <Ashsong> sorear: Another day, perhaps. :)
21:46:59 <Ashsong> Good night, all. Thanks for your help.
21:54:15 <Korollary> I don't like pred's behavior in Enum
21:54:27 <sorear> What don't you like about it?
21:54:40 <Korollary> > pred LT
21:54:42 <lambdabot>  Exception: Prelude.Enum.Ordering.pred: bad argument
21:54:48 <sorear> @where derive
21:54:49 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
21:54:55 <sorear> check out EnumCyclic :)
21:55:21 <Korollary> I'd rather have something like Data.Traversable
21:55:33 <Korollary> I don't actually want cyclic behavior either
21:56:53 <Korollary> Traversable's kind doesn't match, tho
22:00:34 <dmwit> What does this mean: "Cairo is freed from Gtk2hs"?
22:00:50 <sorear> dmwit: read cabal-devel@
22:00:55 <gravity> Someone made direct cairo bindings?
22:01:28 <narain> ?instances Applicative
22:01:29 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
22:01:35 <narain> ?instances-importing Data.Applicative
22:01:37 <lambdabot> Couldn't find class `Data.Applicative'. Try @instances-importing
22:01:41 <narain> ?instances-importing Applicative
22:01:43 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
22:02:05 <narain> ok, i give up. what's Applicative?
22:02:18 <narain> oh wait, i meant Control.Applicative
22:02:19 <sorear> a class
22:02:23 <narain> ?instances-importing Control.Applicative
22:02:24 <sorear> @docs Control.Applicative
22:02:24 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
22:02:24 <lambdabot> Control.Applicative not available
22:02:38 <sorear> ?instances-importing Applicative Control.Applicative
22:02:40 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
22:02:52 <narain> i read the docs but i don't quite get it fully
22:03:12 <narain> an Applicative is a functor with  pure  which is like a monad's  return, right?
22:03:22 <narain> and a  <*>  which i don't quite get
22:10:21 <ddarius> @hoogle <*>
22:10:22 <lambdabot> No matches found
22:10:44 <narain> looking at the source, it appears (<*>) = ap in most cases
22:10:44 <ddarius> @hoogle (<$>)
22:10:45 <lambdabot> Did you mean: (<$>)
22:10:45 <lambdabot> Prelude.undefined :: a
22:10:45 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:10:54 <narain> :t ap
22:10:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:11:20 <Korollary> "Did you mean: (<$>)" ? That's what you typed.
22:11:43 <narain> i've seen that with hoogle a few times too
22:12:10 <narain> > ap Nothing (Just 42)
22:12:12 <lambdabot>  Nothing
22:12:39 <narain> > ap [floor,ceiling] [1.2, 3.4]
22:12:40 <lambdabot>  [1,3,2,4]
22:14:38 <QtPlatypus> :src ap
22:15:01 <QtPlatypus> @src ap
22:15:02 <lambdabot> ap = liftM2 id
22:15:12 <QtPlatypus> @src liftM2
22:15:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:15:18 <narain> dons++ having the ghc sources available locally is a great help, thanks for suggesting it
22:19:45 <andygill> @hoggle getUser
22:19:46 <lambdabot> System.Directory.getUserDocumentsDirectory :: IO FilePath
22:19:46 <lambdabot> System.Win32.NLS.getUserDefaultLCID :: LCID
22:19:46 <lambdabot> System.Win32.NLS.getUserDefaultLangID :: LANGID
22:21:39 <fritzr> anyone know why I don't get a "lang" package in a standard install of GHC 6.6, or where to get it?
22:24:46 <Korollary> fritzr: Is that ghc 6.6 with extralibs?
22:25:50 <fritzr> Korollary: I suppose it isn't :) I just did (what I thought was) a standard Mac OS X install using Darwin ports
22:26:06 <fritzr> Korollary: do you know how I can get extralibs?
22:26:36 <Korollary> fritzr: http://haskell.org/ghc/download_ghc_661.html
22:26:37 <lambdabot> Title: GHC: Download version 6.6.1
22:27:03 <Korollary> Well, that's for 6.6.1 sorry
22:27:12 <Korollary> http://haskell.org/ghc/download_ghc_66.html
22:27:13 <lambdabot> Title: GHC: Download version 6.6
22:28:29 <fritzr> Korollary: thanks, I will give this a try
22:37:46 <alan__> @where xml
22:37:47 <lambdabot> I know nothing about xml.
22:38:10 <alan__> what is the most common haskell xml library
22:39:45 <alan__> haXml?
22:40:27 <alan__> im really just interested in reading/writing xml similar to the dot net xml library
22:41:38 <Korollary> alan__: Did you check http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming#XML_2
22:41:41 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/253xhy
22:45:46 <dons> haxml or hxt, I think, alan__
22:46:51 <andygill> @hoggle GUID
22:46:52 <lambdabot> No matches found
22:47:17 <andygill> Does anyone know how to generate good GUIDs in Haskell?
22:47:46 <sorear> @where newpopen
22:47:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
22:47:52 <sorear> best way by far
22:48:46 <andygill> @hoggle UUID
22:48:47 <lambdabot> No matches found
22:49:34 <kc5tja> @hoogle GUID
22:49:34 <lambdabot> No matches found
22:49:48 <kc5tja> Interesting -- it equates hoggle and hoogle.
22:49:52 <sorear> andygill: newpopen is your friend.
22:49:57 <sorear> kc5tja: edit distance 3
22:50:08 <sorear> well <3
22:50:13 <sorear> 0,1,2
22:50:18 <sorear> @botsmack
22:50:19 <lambdabot> :)
22:50:54 <kc5tja> err -- no idea what you are trying to say, but it sounds like something to do with Hamming distance.
22:51:25 <sorear> Hamming is bad
22:51:27 <sorear> @otsnack
22:51:28 <lambdabot> :)
22:51:32 <sorear> try THAT with hamming
22:51:39 <kc5tja> Oh well.  I'm going to hit the sack now.  Rode home in the rain on my bike, because the weather reporter said, "Oh yeah, it'll be sunny today!"  Uh huh.
22:51:40 <sorear> we use Levenschtein here
22:51:42 <dons> andygill: GUIDs?
22:51:44 <andygill> sorear: I dont understand how newpopen will help?
22:51:58 <kc5tja> sorear: We wouldn't have the Internet today if it weren't for Hamming.
22:52:03 <dons> how does newpopen help, sorear ? i'm confused.
22:52:06 <andygill> I'm trying to generate the id field of an atom entry.
22:52:16 <sorear> man 1 uuidgen
22:52:30 <sorear> newpopen lets you use existing code in ANY language
22:52:33 <dons> oh, you want to call uuidgen, as an external process.
22:52:57 <dons> sorear: being less cryptic is a good approach to helping people ;)
22:53:14 <dons> andygill: the UUID type, as provided by uuidgen?
22:53:34 <sorear> <*andygill> Does anyone know how to generate good GUIDs in Haskell?       [22:45]
22:54:07 <andygill> yes, i'm trying to generate *exactly* what uuidgen generates.
22:54:17 <dons> but calling uuidgen isn't suitable?
22:54:24 <dons> you want a binding to libuuid?
22:54:40 <andygill> It depends of uuidgen being on the machine, but that might be ok
22:54:56 <dons> otherwise, I don't know of a binding to libuuid, (which woudl require that on the machine too, I suppose)
22:56:18 <andygill> sorear: how why do I need newpopen? what is wrong with the old one?
22:56:22 <sorear> <*andygill> I'm trying to generate the id field of an atom entry.  <-- how many machines do you expect to publish your blog on?
22:56:28 <sorear> andygill: just plain hard to use.
22:56:51 <dons> yeah, the popen function sorear referenced is just a nice wrapper over System.Process
22:57:08 <dons> you could just steal that code, since you're likely to need to duplicate the wrapper anyway.
22:57:08 <andygill> sorear: You are assuming that atom entry == blog. This is nothing to do with a blog.
22:57:26 <andygill> says the author :-)
22:57:34 <dons> but a pure haskell libuuid would be nice ... ;-)
22:58:10 <andygill> We can get the time, but the MAC address might be tricky
22:58:24 <sorear> popen ifconfig then ;)
22:58:57 <alan__> when i run 'runhaskell Setup.hs configure' on Haxml it tells me many libraries which are not found like happy and cpphs are they dependancies?
22:59:06 <sorear> no!!!
22:59:16 <alan__> ;o
22:59:19 <sorear> it's not a dependency unless configure FAILS
22:59:26 <sorear> check the exit status
22:59:38 <Korollary> It's true that configure can keep quiet about things it doesn't need.
22:59:45 <alan__> how?
22:59:54 <sorear> @ask dcoutts <*alan__> when i run 'runhaskell Setup.hs configure' on Haxml it tells me many libraries which are not found like happy and cpphs are they dependancies?  <-- can we please have a FAQ?
22:59:55 <lambdabot> Consider it noted.
23:00:08 <fritzr> Korollary: no lang in extralibs, but I think I need to fall back to GHC 6.4: GHC docs sec. 4.8.1 seems to imply this
23:00:16 <Korollary> alan__: sorry, I don't know how. I was thinking aloud.
23:00:24 <fritzr> Korollary: but thanx anyway
23:00:38 <alan__> how can i check the exitcode?
23:01:24 <sjanssen> fritzr: I think lang is deprecated in favor of haskell98
23:01:37 <thetallguy> dons: I came in halfway  -- are you looking for a reimplementation of uuid in Haskell or just a binding?
23:02:17 <dons> thetallguy: Andy was pondering if there was a UUID binding or reimplementation already,  I think.
23:02:25 <dons> thetallguy: do you know of one?
23:02:39 <fritzr> sjanssen: OK, perhaps I can tweak the makefile then (I am trying to build Tim Sheard's Omega)
23:03:12 <thetallguy> dons: don't know of one, but I was thinking that UUID's might come up in a project I'm working on
23:03:52 <thetallguy> dons:  I might take a look at it, since I'm a bit fuzzy o the ffi stuff.
23:04:29 <thetallguy> The quickcheck properties should be fun.
23:04:42 <thetallguy> Nothing should ever be the same.
23:04:47 <thetallguy> ;-)
23:05:16 <dons> heh
23:06:31 <alan__> is uuid just a random 128 bit number?
23:10:15 <fritzr> sjanssen & Korollary: Ahhh! the switch from lang package to haskell98-1.0 package did the trick. Thanks!
23:10:28 <fritzr> sjanssen & Korollary: I will let Tim know about this
23:11:00 <fritzr> sjanssen: is there somewhere I should have been able to discover this in the GHC docs? (package change, I mean)
23:11:09 <Pseudonym> alan__: I know a good random 128 bit number, but I can't tell you for legal reasons.
23:11:28 <Pseudonym> No, UUID is Universally Unique.
23:12:16 <thetallguy> alan_: no
23:12:44 <thetallguy> alan_: uuid_time - extract the time at which the UUID was created
23:15:15 <thetallguy> so there is at least that much separable data in there
23:15:43 <alan__> thetallguy: sounds cool
23:17:55 <thetallguy> looks like there is -r and -t, the first mostly random, the second time based
23:18:20 <Korollary> fritzr: I actually don't know since when lang is called haskell-98
23:19:49 <alan__> thetallguy: wikipedia says thats a version 1 uuid
23:22:27 <fritzr> Korollary: well, crunchy mega goodness will ensure despite, so all is good. Thanx again, all. Bye
23:27:40 <alan__> > showXML "a"
23:27:41 <lambdabot>   Not in scope: `showXML'
23:27:49 <alan__> > showXml "a"
23:27:50 <lambdabot>   Not in scope: `showXml'
23:53:43 <Cheery> Is there kd-tree implementation written in haskell?
