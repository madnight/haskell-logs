00:01:07 <skew> great
00:01:14 <Thomas2> skew: if I was to send a darcs patch proposing an extra fn in Data.Map, where would I send it to?
00:01:25 <quicksilver> fuzan: a function of type 'Core Picture' means that some computation must be done in order to produce the picture
00:01:25 <skew> I just hope you have to squeeze in a chapter on DPH before it goes to the presses
00:01:46 <dcoutts> bos: you know where to ask for reviewers for that Gtk2Hs chapter
00:01:47 <dons> yeah, its book time.
00:01:58 <dons> dcoutts: right. i'll add you to the book reviewer list, eh?
00:02:02 <bos> dcoutts: thanks :-)
00:02:07 <Korollary> Best of luck fellas
00:02:15 <dcoutts> dons: sure
00:02:27 <quicksilver> fuzan: there's no 'standard' way to tun a monadic computation, it depends on the monad
00:02:30 <quicksilver> fuzan: convenitonally, it would be called 'runCore' though
00:04:27 <Weremanatee> I want that book!
00:04:31 <fuzan> quicksilver: yah, i already have it running. the problem is, i'm trying to use a function of type Core from a function of another type
00:04:50 <bos> Weremanatee: yeah, us too :-)
00:05:19 <Weremanatee> can we get the book lazily... chapter-at-a-time?
00:05:26 <bos> Weremanatee: that's the plan
00:05:36 <Weremanatee> really?
00:05:44 <dons> btw, its on reddit too, http://programming.reddit.com/info/1sus7/comments
00:05:45 <lambdabot> Title: Haskell: O&#39;Reilly to publish "Real-World Haskell" book (under CC license!) ( ...
00:05:46 <skew> Thomas2: the libraries list is probably right
00:05:46 <bos> yeah, read the announcement :-)
00:05:47 * Weremanatee isn't good with sarcasm this late
00:05:57 <dons> Weremanatee: seriously. CC license.
00:05:58 <fuzan> quicksilver: what I have now (running in IO within another monad) is  : lift (botDraw >>= \x -> liftIO $ update vt x)
00:06:07 <fuzan> botDraw is of Core, and update is of IO
00:06:17 <fuzan> and this is within the MBot monad
00:06:21 <Weremanatee> Okay, I see it. Too excited to read that far.
00:06:39 <fuzan> from what I know of monads, i don't think this is possible, but i'm trying since it saves a lot of code:)
00:06:40 <Thomas2> skew: libraries@haskell.org?
00:06:46 <skew> Weremanatee: you should know by know, on this list if someone is tlaking about doing something wierd lazily, if it's not actually true it's at least wistful rather than sarcastic
00:06:57 <Weremanatee> Heh
00:07:35 <Weremanatee> Well, congrats on the book deal.
00:07:42 <skew> Thomas2: yeah
00:07:43 <Weremanatee> sounds like a great project
00:07:44 <Thomas2> fuzan: we'd need more details about what kinds of monads they are to tell you what's liftable into them
00:08:07 <Thomas2> skew: actually, I might be lazy on this one for the moment
00:08:17 <fuzan> Thomas2: what sort of details?
00:09:24 <Thomas2> well, most monads provide a means to run them or embed them in others at the point they're named, if you see what I mean
00:09:41 <skew> whoa, is there really a Haskell Coolections module?
00:09:57 <Thomas2> so ErrorT monads come with a lift function for bringing things from the enclosed monad into them and a runError?? function for running them from the enclosed monad
00:10:21 <Thomas2> State monads come with a runState function for performing them from anywhere
00:10:22 <Thomas2> etc
00:10:34 <fuzan> Thomas2: I know only a very little of nesting monads and monad transformers. I'm not sure how to provide my own with those
00:10:41 <skew> fuzan: in general you can only lift something from one monad into a another if the other monad is a monad transformer built around the first
00:11:34 <skew> then, sometimes, monads come with some kind of run function which lets you turn them into pure functions (like runState), or maybe run them in IO (like atomically, for STM)
00:11:37 <Thomas2> fuzan: well, the point is that however Core is defined, that will give you the clue you need to get things from/to it. If it's defined as some kind of wrapper around IO, you can only run it from IO. If it's just a computational monad, there will be a function for running it whenever you like
00:12:06 <Thomas2> ditto for any of your other mondsa
00:12:08 <Thomas2> blah
00:13:02 <skew> Thomas2: there were some other proposed Map patches sent to the list just today
00:14:09 <Thomas2> ok
00:14:55 <skew> Is there anything resembling a core calculus for Smalltalk? It seems like a lot of important stuff is just provided through magic methods
00:15:17 <fuzan> Thomas2: if both wrap IO, is there some method of smuggling computation between both through that?
00:15:34 <skew> (I figure asking here is more likely to turn up something I'd recognize as a langauge semantics)
00:15:41 <Korollary> skew: calculus and smalltalk?
00:16:32 <Korollary> I don't think Alan Kay has high opinions of math stuff
00:16:57 <quicksilver> fuzan: there are not *generic* functions for that , no. This is why we're asking for more details.
00:17:06 <skew> fuzan: well, one thing to consider is that if a monad can actually be used in a program there has to be some way to go from a computation in that monad to at least IO, or maybe to pure functions
00:17:22 <skew> fuzan: but it's not really generic
00:17:26 <quicksilver> fuzan: most monads come with a 'run' function which lets you interleave them with others
00:17:31 <Thomas2> fuzan: then probably there's a run??? function for producing an IO computation from one, and a lift operation for inserting an IO computation
00:17:45 <quicksilver> fuz	if Core warps IO, then you might expect  runCore :: Core a -> IO a
00:17:53 <Thomas2> yeah, exactly
00:17:57 <skew> Korollary: the expression parts seem pretty tractable, and perhaps something like Cardelli's object calulus would treat most of the rest
00:18:03 <Thomas2> and also a lift :: IO a -> Core a
00:18:22 <quicksilver> fuzan: you could only 'lift' between Core and MBot directly if the one was layerd on the other
00:18:27 <skew> Korollary: maybe Kay is allergic, but surely not all the users?
00:18:46 <quicksilver> fuzan: but yes, it should be possible to 'freeze' the state using some run function and then 'reinsert' it after
00:18:52 <quicksilver> and hence interleave the monads
00:18:57 <Korollary> skew: Probably, but Cardelli wrote that stuff later. So I don't think they based it on anything
00:19:03 <quicksilver> however the details are entirely up to the monad implementor
00:19:22 <skew> Korollary: I mean more like a rationalization
00:19:51 <Korollary> skew: Yes, it would be nice to have.
00:20:00 <skew> Korollary: Where's the tutorial "Smalltalk for Domain Theorists"?
00:20:05 <Korollary> Hh
00:20:08 <Korollary> Heh
00:20:28 <quicksilver> skew: last I looked at cardelli's stuff it was more along the lines of 'a very interesting piece of semantic research' and some distaance short of 'you could actually use this to give semantics to a language'
00:20:38 <Korollary> I once looked for "Ruby for people that know lambda calculus and some other languages."
00:21:10 <skew> Well, I suppose class creation is going to be mixed up with the compiler and perhaps some of the GUI browser stuff
00:21:46 <skew> I figure it's a good language to look at to get a baseline on things
00:21:53 <skew> and it sounds like they have some nice stuff we should steal :)
00:22:02 <Korollary> What do they have ?
00:22:31 <fuzan> make
00:22:34 <fuzan> bah
00:22:37 <skew> well, sounds like all the live editing stuff is what people point to
00:22:57 <skew> seems like it would be interesting to write a typechecker to go with that
00:23:14 <skew> I couldn't find any standard union / find / delete data structures, though
00:23:19 <Korollary> But that's primarily an IDE/runtime feature.
00:23:26 <skew> although, I haven't looked for incremental connected-components stuff
00:27:34 <fuzan> we'll, i've hit my temporary haskell barrier once again :)
00:27:36 <skew> oh, and also I've got the impression that extensible records and variants ought to come pretty close to being able to type anything people actually do in untyped languages that doesn't involve method mutating classes and junk like that
00:28:20 <Korollary> I'm afraid they like that junk particularly.
00:28:28 <quicksilver> skew: for a suitably bold definition of 'junk like that' your statement is obviously true :)
00:28:46 <skew> well, those damn assignment statements might get you
00:29:12 <quicksilver> we <- dont need (no blood assignment)
00:29:36 <Korollary> We do and we have it, tho.
00:29:43 <skew> strong update :(
00:29:48 <quicksilver> I was being slightly ironic :P
00:31:52 <osfameron> oooo! real world haskell!
00:32:28 <bos> don't forget to upvote the article on reddit :-)  (ok, really to bed)
00:33:43 <fuzan> i think i'll just continue making all the functions that I need to share be IO (), heh
00:33:54 * fuzan begins the parameter passing.
00:33:59 <skew> wait, strong update <- :(
00:34:38 <Korollary> What is strong update?
00:36:02 <skew> that's what you call it when you've got mutation, and the type in a variable changes over time
00:41:33 <fuzan> :hoogle threadKill
00:41:38 <fuzan> ?hoogle threadKill
00:41:38 <lambdabot> Control.Exception.ThreadKilled :: AsyncException
00:42:15 <fuzan> bah, killThread.
00:48:31 <kolmodin> dons: OMG! best news in a long long time!
00:48:38 <dons> heh
00:48:57 <kolmodin> congratulations guys! :D
00:49:11 <dons> yeah, its very very exciting. O'Reilly has been really great.
00:49:26 <dblhelix> @karma+ dons
00:49:26 <lambdabot> dons's karma raised to 152.
00:49:29 <kolmodin> they seem very friendly!
00:50:02 <dons> yeah. its been a good experience so far.
00:50:13 <dons> they get the community aspect.
00:51:01 <kolmodin> I was surprised that they where letting chapters be published online. how many?
00:51:16 <dons> lots!
00:51:18 <kolmodin> usually one can find about one or two chapters
00:51:25 <kolmodin> great!
00:51:54 <kolmodin> wrt being a reviewer, you mean to give you feedback?
00:52:31 <dons> yeah, or doing proper book reviews. we just want to gather a list of people to particularly contact regarding reviews.
00:52:41 <dons> but its likely we'll also have a wiki for anonymous corrections and feedback
00:52:55 <dons> like spj's papers  have been recently
00:53:00 <fuzan> how is something like "atomically" written?
00:53:04 <kolmodin> oh yeah, right
00:53:17 <dons> atomically :: STM a -> IO a
00:53:18 <dons> atomically (STM m) = IO (\s -> (atomically# m) s )
00:53:25 <dons> with a runtime primitive.
00:53:45 <arcatan> hmm, a book?
00:54:00 <dons> a book! http://programming.reddit.com/info/1sus7/comments
00:54:02 <lambdabot> Title: Haskell: O&#39;Reilly to publish "Real-World Haskell" book (under CC license!) ( ...
00:54:14 <kolmodin> dons: have you got a time schedule?
00:54:22 <arcatan> cool
00:54:45 <dons> 10 months or so.
00:54:51 <fuzan> what do you mean by runtime primitive? the atomically# ?
00:54:54 <dons> a couple of chapters a month.
00:54:57 <dons> fuzan: yeah.
00:55:09 <dons> eventually you have to get into the runtime system.
00:55:12 <fuzan> something implemented in ghc?
00:55:33 <dons> yeah
00:55:35 <skew> yeah, you can read about how it works in the STM papers
00:55:50 <slava> dons: i'm buying that book!
00:56:06 <dons> hah. cheers slava.
00:56:06 <fuzan> argh. i doubt i could write my own Monad m -> IO m functions then :)
00:56:34 <dons> slava: you'd be a good reviewer of the 'external' kind actually..
00:56:37 <dons> if you're interested.
00:56:41 <slava> sure
00:57:02 <dons> ok. /me notes this down.
00:57:04 <quicksilver> fuzan: sure you can
00:57:23 <quicksilver> fuzan: assuming the monad m is pure haskell
00:57:32 <slava> dons: if you need to email me, slava at factorcode dot org
00:57:34 <quicksilver> fuzan: the reason atomically is primitive is that STM is primitive
00:57:41 <arcatan> and finally, I've been waiting for a practical Haskell book
00:57:45 <dons> slava: ok. cheers.
00:57:48 <quicksilver> fuzan: but a normal monad written in haskell, has to have a 'run' function
00:57:56 <quicksilver> fuzan: otherwise you can't actually use it :)
00:58:08 <fuzan> :(
00:58:12 <fuzan> thanks for a lot of bad news!
00:58:16 <skew> fuzan: are you writing your own monad?
00:58:16 <quicksilver> ?
00:58:22 <quicksilver> surely it's good news?
00:58:38 <fuzan> i think i'm just a little confused.
00:58:43 <quicksilver> :)
00:58:49 <skew> otherwise, there really ought to be some function you can use
00:58:51 <fuzan> i'll post some code in a little bit, i have stuff spread all over.
00:58:54 <quicksilver> where did this MBot monad come from? and where did the Core monad come from?
00:58:57 <kolmodin> dons: I wouldn't mind reviewing too :D :D
00:59:06 <fuzan> they're nested monad transformers around IO
00:59:21 <quicksilver> fuzan: right. Well then you can 'run' them all the way back to IO
00:59:34 <slava> kolmodin: you're not external enough!
00:59:41 <quicksilver> runTrans1 . runTrans2 . runTrans3 . runTrans4 :: BigMonad a -> IO a
01:00:00 <fuzan> the problem is, neither terminate.
01:00:12 <kolmodin> slava: correct, I'd be the other kind :)
01:00:23 <dons> so i'm getting quite a list now of possible reviewers. good good.
01:00:28 <skew> or something like x -> y -> z -> IO (Either Foo (Maybe (w,a)), but either way
01:00:55 <quicksilver> skew: unless, of course, it was a 'fully abstract' monad, with the 'run functionality' not exported, of course
01:00:58 <fuzan> i fork two threads, each with a seperate monad
01:01:04 <fuzan> and they share some data via mvars/ tchan
01:01:24 <quicksilver> skew: it might be intended only to be used via a specified API not giving complete access to 'run'
01:01:27 <arcatan> I know nothing about anything, do I qualify as a reviewer
01:01:33 <quicksilver> skew: that doesn't sound like fuzan's situation, but it is possible
01:02:34 <fuzan> the Core thread handles the VTY terminal, and the other thread (MBot) handles packets coming in via sockets. on certain events, i want to be able to somehow trigger updating vty from the MBot side, and hence my dillema
01:04:08 <fuzan> http://fuzan.org/repo/fzbot/    <- repo
01:04:09 <lambdabot> Title: Index of /repo/fzbot
01:04:28 <fuzan> Interface.hs and Bot.hs provide most of the stuff in question
01:04:55 <fuzan> (this started off as a project to get more comfortable with monads, so there's probably a lot of questionable code :)
01:05:16 <quicksilver> fuzan: without reading your code, it sonuds like you have a different problem than combining monads
01:05:25 <quicksilver> fuzan: it's not monads you want to combine, but threads
01:05:33 <quicksilver> that's how it sounds from that description
01:05:56 <fuzan> quicksilver: well, i have no problem with that. the problem is i've been writing a plethora of IO functions that are shared between both threads
01:06:24 <fuzan> fuzan: i'm trying to reduce the need for those by trying to remain in the monads
01:06:46 <quicksilver> it's not clear to me why you think that's a useful goal
01:06:56 <quicksilver> a function is 'in a monad' if it depends on what the monad offers
01:07:05 <quicksilver> sounds like your monads are basically fancy state monads
01:07:11 <fuzan> they are
01:07:21 <quicksilver> if a function is just an IO action doing some output, or whatever, then it doesn't depend on that state
01:07:27 <quicksilver> so it has no right being in the monad...
01:07:52 <fuzan> that's a good point.
01:08:42 <quicksilver> So I wouldn't feel that it's somehow 'bad style' to have some shared IO a actions
01:08:51 <quicksilver> if they're doing IO, and that's all, then IO a is the correct type for them :)
01:09:06 <quicksilver> (mind you I don't know if there are any issues with multithreaded IO and vty, that would be a different problem)
01:10:41 <fuzan> there are some benifits for having some of the IO functions be in the monads though, on hindsight
01:11:40 <Pastorn> a friend just asked me for a book on algorithms, nothing heavy, just your basic knowledge, can anyone recommend me anything?
01:14:12 <dons> Pastorn: 'cormen' is the standard reference
01:14:28 <dons> and very readable, though biased towards mutable data
01:14:39 <dons> "Cormen/Leiserson/Rivest/Stein: Introduction to Algorithms"
01:15:03 <fuzan> i just had a revelation.
01:15:15 <quicksilver> is it irrational to get annoyed when people confuse 'currying' and 'partial application'? ;)
01:15:39 <dons> quicksilver: just take a deep breath.
01:16:07 <mux> morning haskellers
01:16:10 <Pastorn> dons: thank you :D
01:16:14 <quicksilver> dons: good advice :)
01:16:51 <osfameron> quicksilver: aren't they 2 sides of the same coin?
01:16:58 <quicksilver> osfameron: technically, no
01:17:13 <quicksilver> osfameron: currying is simple the idea of using a -> b -> c instead of (a,b) -> c
01:17:13 <osfameron> meh.  Take a deep breath... ;-)
01:17:28 <quicksilver> osfameron: currying is what makes partial application possible. it's the step before.
01:17:33 <mux> you need currying to have partial application though, don't you?
01:17:37 <mux> yeah, ok
01:18:21 <osfameron> right.  so partial application is simply using currying to produce a partially applied function, rather than going "all the way" and applying it fully (using currying)
01:18:27 <osfameron> ?
01:18:36 <quicksilver> and the use of sections like (+1) is only tangentially related to currying. (+1) is just a nice piece of syntax.
01:18:45 <quicksilver> you could obviously have sections in a non-curried world
01:19:05 <osfameron> aren't sections just a syntax for partial application on binary operators?
01:19:06 <quicksilver> (+1) = \a -> (a+1)
01:19:09 <slava> but they wouldn't behave as such
01:19:15 <quicksilver> (+) doesn't need to be curried for that to work
01:19:16 <Thomas2> grumble. now how do I delete a range of mappings?
01:19:27 <slava> currying refers to the iso between Hom(A\tensor B,C) and Hom(A,Hom(B,C))
01:19:34 <slava> in 'nice' categories, such an iso exists
01:20:09 <osfameron> quicksilver: but it could be:   if (+1) => (+) 1, and (1+) => flip (+) 1    (or the other way round)
01:20:09 <fuzan> quicksilver: i'm stubborn and retarded. i just used runCore to do what I needed.
01:20:16 <fuzan> quicksilver: thanks for the help :)
01:21:34 <quicksilver> osfameron: you can partially apply even in the absence of currying
01:21:48 <quicksilver> osfameron: right, yes. I'm just saying you need the one for the other
01:22:00 <Thomas2> looks like filter might be most efficient
01:22:00 <quicksilver> currying just makes partial application a bit more concise
01:22:15 <quicksilver> you could always have partially applied the long way (by unpacking the tuple)
01:22:26 <quicksilver> fuzan: good :)
01:22:40 <osfameron> quicksilver: ok
01:22:56 <quicksilver> slava: and, it exists even in very-not-nice 'categories' or things-which-might-not-be categories, like haskell :)
01:23:14 <fuzan> if anyone has a valid battle.net key, they could talk to my bot on bt@useast :)
01:23:56 <quicksilver> osfameron: missing 'don't' in there somewhere :)
01:24:19 <quicksilver> (Albert C Y Lai)++ # A sane voice in the wilderness of the editor thread
01:24:21 <fuzan> i run into an odd vty bug and sorear disspears for days :(
01:25:45 <quicksilver> fuzan: maybe his IRC client is written in vty and he isn't here because of the bug!
01:25:52 <osfameron> harr!
01:26:52 <matthew-_> quicksilver: you're still reading that thread?!
01:27:06 <osfameron> editor threads have a certain car-crash appeal
01:27:13 <osfameron> and not all of what is being said is stupid
01:27:16 <fuzan> quicksilver: hah! then he'll figure it out!
01:27:23 <matthew-_> sure, but the signal to noise ratio...
01:28:30 <quicksilver> matthew-_: I have an efficient filter, most of the time
01:42:50 <sieni> @src IO
01:42:51 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:45:33 <scodil> is there any way to get a stack trace (or something like it) if you have to interrupt the program because it goes into an infinite loop?
01:46:08 <dons> yeah, from the .prof file (compile with profiling enabled)
01:46:26 <scodil> it doesn't write anything
01:46:52 <scodil> oh wait nevermind
01:49:47 <quicksilver> dons: book proposal looks great. congrats.
01:49:56 <quicksilver> dons: No chapter on ST, though?
01:50:18 <dons> i'd imagine it will come up during the monad chapter (ST monad, you mean?)
01:50:24 <quicksilver> I did
01:50:36 <quicksilver> it's a bit of a special case as a monad though
01:50:47 <quicksilver> I was thinking of some discussion about how you can use it to use mutable algorithms in pure code
01:50:56 <dons> its not widely used, though. possibly it could be mentioned somewhere else. in relation to peek/poke FFI stuff, for example
01:51:00 * quicksilver nods
01:51:01 <dons> yeah
01:51:10 <osfameron> eeek!  today the channel is still #cheese!
01:51:18 * osfameron writes to the advertising standards authority
01:51:19 <quicksilver> yes, maybe it isn't widely needed, and maybe that's the right way to look at it
01:51:41 <fuzan> dons is releasing a book? :o
01:51:48 <dons> there's a tension of course, about what to put in.
01:51:55 <dons> so much research, so few pages available.
01:52:05 <dons> fuzan: http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
01:52:07 <lambdabot> Title: Real-World Haskell » Blog Archive » Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
01:52:30 <matthew-_> dons: well done for getting the creative commons licensing agreed
01:52:41 <fuzan> :D
01:52:49 <quicksilver> dons: it's probably more interesting to spend time talking about the way pure data structures can actually be fast
01:53:02 <quicksilver> dons: than time talking about how you can use impure structures if you have to
01:53:05 <dons> they were quite ameniable to that, actually, matthew-_ . they've been great to deal with.
01:53:10 <dons> quicksilver: yeah.
01:54:43 <fuzan> has much writing been in progress?
01:55:02 <nominolo> I love the lambda-potato
01:55:05 <swiert> dons: Do you have any idea when it will be finished?
01:55:06 <dons> just some drafts. we start in earnest quite soon though.
01:55:33 <dons> swiert: hmm, 10+ months. something like that.
01:55:40 <dons> its around 30 chapters
01:55:45 <matthew-_> LaTeX?
01:55:50 <swiert> dons: That's pretty ambitious!
01:55:52 <fuzan> wish I was a bit more talented at hte moment, i'd try and help :)
01:56:13 <swiert> Graham took a really long time to finish his book.
01:56:24 <dons> yeah, good thing we have 3 authors.
01:56:30 <nominolo> practical common lisp also took a long while
01:56:33 <dons> but we'll see how it goes.
01:58:39 <quicksilver> dons: what kind of time commitment would you need from a reviewer?
02:00:39 <dons> unsure yet. i'd imagine we'll have some for the whole book, and then some per-chapter specialists.
02:02:31 <osfameron> dons: I'm up for reviewing from the haskell newbie perspective
02:03:41 <fuzan> you could have a section of "noob reviewers" that critiqued from an unbiased and unknowledgable perspective.
02:04:52 <DRMacIver> I will certainly be reading through it and yelling if I have any complaints. :) I doubt I'll do enough to count as properly reviewing it.
02:05:45 <dons> we'll very likely have wiki-style comment/feedback stuff too, of course
02:06:07 <psnl> dons: a la simonpj's recent things?
02:06:20 <matthew-_> beautiful concurrency it was, iirc
02:06:20 <dons> yeah
02:06:29 <dons> and some of the recent papers he's done
02:07:22 <matthew-_> I wonder if anyone's ever contributed to a paper like that and then the next week found it in their inbox to review for some conference
02:07:54 <dons> hah.
02:09:25 <quicksilver> I'm sure it happens
02:10:03 <quicksilver> the academic procedure is becoming a bit contrived in the presence of the extreme 'information sharing' that the CS environment has at the moment
02:10:29 <dcoutts> dons: oh and I can review the FFI chapter
02:13:24 <kfish> quicksilver, the purpose of wikis is to ensure the integrity of peer reviewed academic articles, right? or is that meant to be the other way around? ;-)
02:17:01 <quicksilver> kfish: I believe the purpose of peer reviewed acamedic articles is to ensure the integrity of wikis, yes.
02:17:34 <kfish> :-)
02:18:57 <LeCamarade> dons: Um ... where did you people get that lambda potato on your website? I really should know!
02:19:43 <dblhelix> @quote quicksilver the purpose of peer reviewed acamedic articles is to ensure the integrity of wikis
02:19:43 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
02:21:15 <dblhelix> @quote+ quicksilver the purpose of peer reviewed acamedic articles is to ensure the integrity of wikis
02:21:15 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
02:22:34 <dblhelix> @remember quicksilver the purpose of peer reviewed acamedic articles is to ensure the integrity of wikis
02:22:34 <lambdabot> Done.
02:22:37 <dblhelix> ah :-)
02:24:12 <therp> dons: when will this book be available?
02:24:17 <LeCamarade> Ah. Seen the credits. At the bottom of the page.
02:24:23 <therp> dons: or let's say, when is the technical review phase?
02:24:29 <LeCamarade> `Lambda potato.' :oD
02:27:55 <matthew-_> I have to say, I'm increasingly surprised people need things like Epigram - you can get /so/ close to dependent types with Haskell and do a lot of type level programming in it...
02:28:35 <psnl> matthew-_: sore point that, ISTR.
02:29:03 <matthew-_> uh hu
02:32:04 <psnl> matthew-_: two things: epigram predates the newer bits of haskell, and I suppose a comparision would be to say that type-level hacking in haskell plays CIDR and NAT to epigram's IPv6.
02:32:41 <quicksilver> matthew-_: epigram isn't just about having real dependent types
02:32:58 <quicksilver> matthew-_: epigram is more significantly about how having a highly structured type system enables you programs to write themselves
02:33:24 <quicksilver> 'more significantly' being my opinion, of course
02:34:08 <quicksilver> and "true" dependent types are, in principle, a quite significantly more convenient than having to manual reflect your values into the type level
02:34:49 <matthew-_> quicksilver: oh sure. Yes, I always forget about the interactive part of Epigram. It's definately more powerful and very very cool. But having had to stop using Epigram for a number of reasons, I surprise myself how close I can get with Haskell and type trickery
02:35:35 <quicksilver> and epigram is currently total, isn't it?
02:35:50 <quicksilver> not sure if it's always going to stay total, but that's a significant difference
02:36:02 <matthew-_> I'm not sure what you mean by total
02:36:12 <quicksilver> all programs are guaranteed to terminate
02:36:17 <matthew-_> ahh, yes
02:36:20 <quicksilver> the only recursion you can write is well-founded
02:36:21 <matthew-_> it is, iirc.
02:36:30 <matthew-_> yep - recursion on the structure of terms only
02:37:15 <matthew-_> but that's fine. I have no objection to requiring that every program ever written is terminating.
02:37:23 <matthew-_> the universe will grow cold...
02:37:53 <dcoutts> dons: have you got your book website feed on planet haskell yet?
02:38:29 <quicksilver> matthew-_: yes , it's a nice property
02:38:43 <quicksilver> matthew-_: although it does make it rather hard to write operating systems :)
02:39:06 <quicksilver> matthew-_: I daresay they have some kind of codata plan in mind, though
02:39:17 <dons> dcoutts: ah good idea.
02:39:24 <matthew-_> quicksilver: no, you just have a counter in it that's the maximum number that can be held by all the ram in the machine. Every tick you count down. When you hit 0, you reboot.
02:39:54 <matthew-_> maybe that's what they were trying with NT4 when it couldn't stay up more than 41 days
02:40:31 <osfameron> @where epigram
02:40:31 <lambdabot> http://www.e-pig.org/
02:40:43 <quicksilver> matthew-_: the theoretical problems with total programming go a bit deeper than that :)
02:40:59 <matthew-_> quicksilver: damn it! I thought I'd solved it then!
02:42:55 <therp> at some point this year, I'll try to build a checker in Liskell that ensures that the program is 'total' in the sense of total programming by turner.
02:43:18 <fuzan> hmm; epigram looks interesting. never heard of it before.
02:44:54 <osfameron> how can you guarantee that a program terminates?
02:45:43 <therp> osfameron: primitive recursion, better walther recursion, better use termination graphs
02:46:33 <matthew-_> osfameron: best, run it and see!
02:47:07 <osfameron> matthew-_: yeah, that's a simple algorithm:  1) wait an infinite length of time.  If the program hasn't terminated then you know!  2)  There is no step 2!
02:48:11 <matthew-_> osfameron: actually, that's only true if you have an infinite amount of memory. Most of the time, you only have a finite amount of memory, thus there are a finite number of program states thus there are a finite number of steps to wait before you know whether it's looping infinitely or not
02:48:37 <osfameron> matthew-_: well, yes, but then the algorithm is more complicated ;-)
02:48:47 <fuzan> matthew-_: isn't that an NP problem htough?
02:48:49 <osfameron> therp: interesting
02:49:01 <kaol_> "most of the time"?
02:49:15 <matthew-_> kaol: not in our dreams!
02:50:02 <matthew-_> fuzan: yes, that's /the/ classic halting problem which is NP-hard
02:50:12 <ray> lecamarade: where's this lambda potato?
02:50:39 <ray> and where can i buy the rights to put it on t-shirts
02:50:43 <mr_simpson> visit: www.ccmplanet.co.za - Exclusive RSS Feed, Music News, Exclusive Concert Photo Gallery, Blogging, Music Features
02:50:59 <therp> osfameron: http://citeseer.ist.psu.edu/240918.html is quite ok, but more interesting for Haskell is http://www-i2.informatik.rwth-aachen.de/giesl/papers/RTA06-distribute.ps "Automated Termination Analysis for Haskell"
02:51:01 <lambdabot> Title: Walther Recursion - McAllester, Arkoudas (ResearchIndex)
02:51:56 <fuzan> alright, time to crash. peace.
02:52:07 <quicksilver> mr_simpson: news about music written in haskell? that is interesting
02:52:57 <profmakx> yay, go jürgen
02:52:59 <LeCamarade> ray: It's on someone's Flickr feed... Check the website. It has links at the bottom, for the photographer and the photo itself. Very interesting.
02:53:22 <ray> wait, found it in my planet haskell feed :)
03:01:00 <LeCamarade> Why the flood of joins and sign-offs? Which timezone is waking up?
03:01:14 <LeCamarade> @time sris
03:01:14 <lambdabot> Local time for sris is 2007-05-23 11:59:57 +0200
03:01:41 <LeCamarade> @time earthy
03:01:43 <lambdabot> Local time for earthy is Wed May 23 12:00:29 2007
03:01:51 <excellentjelly> LeCamarade, careful analysis of the collected data and sophisticated statistical deduction reveals that it is, indeed, your mother.
03:02:01 <excellentjelly> (or a netsplit)
03:02:27 <LeCamarade> excellentjelly: :-\
03:02:28 <sris> i actually just woke up :)
03:02:46 <excellentjelly> LeCamarade, cheer up, it was a joke
03:18:08 <kfish> nominolo, toxic, HTTP1 rocks -- I just put http (lazy bs) support into hogg, for debugging video streams, in no time flat
03:20:14 <nornagon> yo kfish :)
03:20:39 <nornagon> how're the lambdas?
03:21:37 <nominolo> kfish: cool, thanks.
03:21:48 * nominolo has to go now, though
03:24:19 <kfish> nornagon, rocking
03:25:55 <pitecus> I have a weird thing going on: Im using GHC to compile a Module which uses FFI. It compiles fine, unless I use -O2 in which case it spews some obscure errors
03:26:17 <pitecus> like: ./c_maxent.h:17:0:
03:26:17 <pitecus>      error: expected â€˜=â€™, â€˜,â€™, â€˜;â€™, â€˜asmâ€™ or â€˜__attribute__â€™ before â€˜c_load_from_fileâ€™
03:26:21 <pitecus> etc
03:26:32 <pitecus> Any ideea of what might be going on?
03:42:43 <LeCamarade> excellentjelly: Yeah, sure. I knew that. :oD
03:43:01 * LeCamarade hopes that grinning one makes it clear ... :oD
03:46:56 * ndm finds that eastern samoan time 11am wednesday is midnight *tonight*, not midnight yesterday
03:59:19 <matthew-_> ndm: 11am is a weird time for a deadline
03:59:46 <ndm> matthew-_: eastern samoan time is a weird time zone, its midnight in germany where the conference is being held
04:00:08 <matthew-_> I thought they were all near midnight, in eastern samoan given that it's the last timezone possible so no one can claim "I missed the deadline because my timezone is past yours".
04:02:26 <ndm> they were last year, this year its all german time
04:03:20 <matthew-_> oh. which conference?
04:04:26 <ndm> ICFP 07
04:04:29 <matthew-_> oh
04:04:48 <matthew-_> I thought the deadline had gone for that? Or is this camera ready?
04:04:59 <matthew-_> "you know you're in trouble when" #74562: You add  -fallow-incoherent-instances and your code stops compiling...
04:05:24 <zorg0f> does anyone have a function to return all elements in-order from a generic binary-search tree, that i could have a look at?
04:06:27 <ndm> the author response is midnight tonight
04:07:02 <ndm> i.e. we get the reviews, and can comment, but not any decision yet
04:07:08 <matthew-_> ahh, that deadline
04:07:32 <matthew-_> well, congrats for getting that far!
04:08:28 <ndm> 120 people got that far
04:08:40 <ndm> but only maybe 24 get to the conference (ish)
04:09:13 <matthew-_> is it the conference proper or a workshop?
04:10:00 <ndm> conference proper
04:10:09 <ndm> HW deadline is 5 weeks away, i think
04:10:41 <olsner> is it supposed to be this hard to get haskell to run right? I just want to go through a file, line per line, running a function that updates a state, then print the final state - but I keep getting stack overflows (for a 20 meg file, it needs about 100 megs of stack to complete at all)
04:11:25 <olsner> it's just a friggin' while loop ;-)
04:11:41 <dons> olsner: sounds like a job for a foldl' ?
04:12:04 <dons> olsner: hpaste , if you're really quick, i'll rewrite it in bytestrings for you..
04:12:07 <dons> ?paste <--
04:12:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:12:21 <olsner> foldl' doesn't help
04:12:40 <dons> code please. :-)
04:12:42 <dons> quick!
04:12:54 <matthew-_> dons demands speed justice!
04:13:08 <dons> i demand dinner!
04:13:18 <matthew-_> where as I require an infinite reduction stack and a quantum computer
04:14:04 <dons> olsner: you there? :-) want help? i'm in the mood for some optimising... !
04:14:09 <hpaste>  olsner pasted "fold me hard, baby" at http://hpaste.org/12
04:14:12 <dons> yay
04:14:29 <dons> i note our hpaste count has been reset . interesting...
04:14:55 <matthew-_> oh, that's sensible
04:15:07 <dons> it is?
04:15:17 <olsner> feed it with objdump disassembly if you want to test it
04:15:21 <matthew-_> oh, but it doesn't wrap
04:15:34 <dons> olsner: ok. looking.
04:15:46 <matthew-_> dons: it is because it prevents endless disk space being used
04:16:10 <dons> yes, i'd imagine so. or possibly hardware failure
04:16:34 <matthew-_> it would be better if it actually wrapped properly like a circular buffer
04:16:54 <dons> yeah, we could just wrap on 1000 like we used to wrap on 100.
04:17:51 <olsner> you'll see a lot of crud that is different attempts at making it work nicely.. did try different ways to make things strict with seq etc that didn't work (but I really don't want to have to do that... haskell doesn't really prove itself if it requires work-arounds for its most advertised features ;-)
04:17:53 <matthew-_> it should probably watch page accesses and only delete a paste if it hasn't been accessed for 24 hours
04:18:41 <dons> olsner: suspicious code, updateState :: (Num t, Eq a) => [(t1, [a])] -> [(t2, t)] -> a -> [(t2, t)]
04:19:42 <olsner> the state is a list of pairs (name, count) - the opss is a list of (name, opcodelist) pairs
04:19:47 <dons> olsner: how big is the input data, btw?
04:19:52 <dons> its own objdump ?
04:20:20 <olsner> the real data is 2.5 gigs.. just testing it with about 20megs now (head -500000)
04:20:30 <dons> ok. you certainly need to use bytestrings, not String.
04:20:40 <dons> and probably lazy bytestrings if you hope to process gig files
04:20:57 <dons> otherwise, looks doable. let's see...
04:21:03 <olsner> yeah, but that won't do me any good if it needs 10 gigs of stack ;-)
04:21:18 <dons> no no, that's very fixable. stack oflows are always simple
04:21:33 <dons> for example,
04:21:36 <dons>   tailAfterNthTab n ('\t':xs) = tailAfterNthTab (n-1) xs
04:21:43 <dons> super suspicious (do you know why?)
04:22:19 <olsner> I wrote it, so I guess no ;-)
04:23:10 <dons> hang on, let me reproduce the oflow.
04:23:42 <dons> objdump a.out ?
04:23:53 <dons> objdump -d a.out, that is?
04:24:01 <olsner> yeah, something like that
04:24:27 <dons> looks like a fun little app, btw.
04:24:44 * dons watches stack grow...
04:24:49 <dons> $ objdump -d a.out > file.s
04:24:49 <dons> $ ./a.out file.s
04:24:49 <dons> Stack space overflow: current size 8388608 bytes.
04:24:49 <dons> Use `+RTS -Ksize' to increase it.
04:24:51 <dons> :-)
04:24:54 <dons> now to fix it.
04:25:36 <olsner> yeah, I'm attempting to port the analyze-x86 perl script to haskell.. after it works ok, I'll try fun things with compiling NFA:s out of the lists of words and just play around with it until it's lightning fast ;-)
04:26:04 <nominolo> kfish: what was the project you were talking about?
04:26:07 <olsner> http://dev.gentoo.org/~dirtyepic/bin/analyze-x86
04:27:06 <olsner> what was suspicious about tailAfterNthTab though?
04:27:33 <dons> oh, that n-1 mightn't be reduced each time around the loop
04:27:45 <dons> but its probably these (a,b) pairs in the state.
04:27:47 <dons> still looking.
04:27:50 <olsner> but n is "always" small
04:27:59 <dons> yeah.
04:28:01 <olsner> rather, n is always 1 ;-)
04:28:05 <dons> its probably not that.
04:28:42 <olsner> no, just print (getOps file) is faster than you can say slartibartfast
04:29:28 <dons> yeah
04:29:36 <dons> do it starts at doSearch
04:30:30 <dons> oh, hang on. are you using a Map?
04:30:37 <dons> mkZipper x (_,ops) (name,cnt) | elem x ops = (name,cnt+1)
04:30:52 <dons> means increment occurence of value associated with key name?
04:30:53 <olsner> nope, no map.. just lists.. that's one of those optimizations for later
04:31:06 <nominolo> hm, are generalized collections coming when ATs are stable?
04:31:11 <dons> yeah, but all that list hacking could well be the problem :-)
04:31:11 <olsner> oh, is it building up reams of + expressions then?
04:31:18 <dons> yeah.
04:31:27 <dons> esp. if you look at the type inferred,
04:31:27 <dons> mkZipper :: (Num t2, Eq a) => a -> (t, [a]) -> (t1, t2) -> (t1, t2)
04:31:28 <dons> mkZipper x (_,ops) (name,cnt) | elem x ops = (name,cnt+1)
04:31:28 <dons> mkZipper _ _ y = y
04:32:53 <olsner> you mean that t2 is a Num t2 instead of Int or something?
04:33:09 <dons> so if we just step back for the moment, you're just taking all the lines of the input file
04:33:14 <dons> splitting them up to find the instruction
04:33:23 <dons> then incrementing a table based on the instructoin?
04:33:28 <olsner> yeah
04:33:29 <dons> either sse or mmx?
04:33:50 <olsner> it maintains counts for each of the instruction sets, depending on where it finds the opcode (if it finds it)
04:34:11 <dons> ok. should be possible to do this with a lot less effort. :-)
04:34:18 <dons> your code is very high level
04:34:42 <dons> so i'll start with bytestrings.
04:36:21 <olsner> it's high-level on purpose yeah, but that should just make it slow not impossible
04:36:42 <dons> yep. but i'm just finding it hard to untangle the layers.
04:37:53 <olsner> I was planning on making it readable when I gotten the stack overflows sorted out
04:39:05 <edwardk> seven hours later I've managed to convince myself that there is no monadic version of the Fegaras/Sheard catamorphism over polymorphic terms. oh well.
04:39:09 <edwardk> time for work ;)
04:42:43 <edwardk> dons: is there a plugin for lambdabot that will let it send a msg when it first logs in, so it can identify with nickserv?
04:42:53 <dons> stick it in the .rc file
04:43:00 <dons> you can add passwords there.
04:43:06 <edwardk> ah didn't see, cool
04:45:05 <dons> olsner: is discardAfterSpace, takeWhile (/= ' ') xs ?
04:45:28 <olsner> if I had known about that function, yes ;-)
04:45:50 <dons> the tab catching is break (== '\t') 3 times, i think.
04:46:02 <Lemmih> takeWhile (not.isSpace)?
04:46:18 <dons> literal ' ' in this csae.
04:46:56 * Lemmih fades to the background.
04:47:01 <dons> hey Lemmih :-)
04:47:02 <olsner> except that my functions return Nothing if the line doesn't match the format
04:47:19 <Lemmih> dons: Congrats on the book, btw.
04:47:32 <dons> olsner: yeah.
04:47:34 <dons> language cheers.
04:47:36 <dons> tab.
04:47:40 <dons> Lemmih: ah better. cheers
04:50:40 <mdmkolbe|work> I don't think catMaybes is tail recursive (thus you'll get about one stack entry per line in getOps, but maybe lazyness saves you)
04:51:13 <mdmkolbe|work> that was for dons, olsner
04:53:27 <olsner> mdmkolbe|work: getOps plays nice, so that's no problem
04:55:24 <mdmkolbe|work> olsner: do you mean you've tested that experimentally b/c I'm saying that cayMaybes might make getOps not play nice (I take it that 'file' in getOpts can be quite long)
04:55:45 * mdmkolbe|work goes to grab lunch
04:56:01 <dons> yeah, its not the catMaybe. its the accumulating loop over the instruction list
04:56:05 <kfish> nominolo, hogg
04:56:08 <kfish> ?where hogg
04:56:08 <lambdabot> http://www.annodex.net/~conrad/software/hogg/
04:56:09 <olsner> yeah, I tested that by replacing the main program with print (getOps file)
04:57:45 <olsner> (and did it only twice as slow as cat even)
04:58:13 <dons> yeah, and its a fair bit faster with bytestrings (just tested)
04:58:19 <nominolo> kfish: nice.  not though, that we have to change the interface to avoid resource leaks
04:58:53 <nominolo> kfish: i have a good idea though how to preserve lazyness when possible but have strictness when necessary
04:59:06 <olsner> so, what am I to do about that accumulating loop?
04:59:20 <nominolo> kfish: i got a very helpful comment on my blog last night
04:59:22 <dons> hang on, almost done.
04:59:45 <nominolo> kfish: that should be s/not/note/ in my first response
05:00:14 <dons> olsner: its a standard case of lazy updates, i think.
05:00:30 <dons> you've got 20 meg of instructions coming in, and you're buliding up huge chains on unevaluated counts
05:03:16 <DRMacIver> I just encountered something really sad in our project. :(
05:03:46 <DRMacIver> A utility method named mapListIntoSingletonLists. And it took 6 lines to write.
05:04:18 <DRMacIver> (Yes, it really does just do the same thing as map (:[])  )
05:06:13 <Pseudonym> Oh, yes, congrats on th ebook.
05:06:18 <LeCamarade`> DRMacIver, the name is the real disaster there. Like Java!
05:06:37 * mnislaih congrats dons too
05:06:39 <nominolo> DRMacIver: happens.  that's how you realize that you learned something
05:06:47 <Pseudonym> dons: How many technical editors so far?
05:07:11 <nominolo> DRMacIver: also, that's what code review is for
05:07:15 <kfish> nominolo, cool, that's a very interesting article (referring to LL3-collections-enumerators), that problem is easy to overlook :-)
05:07:26 <DRMacIver> nominolo: Eh. It's not like there's a shorter way of doing it in Java.
05:07:28 <dons> Pseudonym: about 30. :}
05:07:34 <DRMacIver> This is a work project, not my code.
05:07:34 <Pseudonym> LOL
05:07:37 <dons> Pseudonym: but we'll want a good list , in order to prune.
05:07:42 <Pseudonym> OK.
05:07:52 <nominolo> DRMacIver: ah, java.  well, nevermind then ;)
05:07:54 * Pseudonym was tossing up whether or not to apply
05:08:41 <nominolo> kfish: yes, i'm reading it right now.  my current idea is to provide a foldl over chunks.  and if you consume them right away you're fine, if not you'll have the memory overhead
05:08:42 <dons> Pseudonym: seems worthwhile
05:08:47 * Pseudonym nods
05:08:53 <dons> olsner: so i get the code now. almost done. :-)
05:09:10 <Pseudonym> If it helps my application, I'm also an English pedant.
05:09:23 <nominolo> kfish: have to figure out how well that performs with fusion or functions that expect a stream-like interface
05:09:38 <nominolo> (modulo grammar)
05:10:01 <kolmodin> ?users
05:10:01 <lambdabot> Maximum users seen in #haskell: 340, currently: 302 (88.8%), active: 35 (11.6%)
05:10:27 <kolmodin> dons: guess you've had ~300 people willing to do reviews :)
05:10:46 * mdmkolbe|work returns from lunch
05:10:54 <ivanm> @hoogle bound
05:10:55 <lambdabot> Network.Socket.Bound :: SocketStatus
05:10:55 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
05:10:55 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
05:11:11 <kolmodin> mdmkolbe|work: that was quick
05:11:24 * ivanm meant enumerated datatypes with upper/lower limits
05:11:43 <kolmodin> ?hoogle enum
05:11:43 <lambdabot> Prelude.Enum :: class Enum a
05:11:44 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
05:11:44 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
05:12:00 <kolmodin> umm..
05:12:03 <ivanm> like how Int has bounds on what values it can take
05:13:29 <scook0> ?hoogle Bounded
05:13:30 <lambdabot> Prelude.Bounded :: class Bounded a
05:14:54 <ivanm> @doc Bounded
05:14:54 <lambdabot> Bounded not available
05:14:59 <ivanm> @doc Prelude.Bounded
05:14:59 <lambdabot> Prelude.Bounded not available
05:15:03 <ivanm> grrr....
05:16:07 <ivanm> OK, found it, I think...
05:16:36 <ivanm> now, here's the thing: is it possible to define a Bounded datatype (a subset of Int) that has a dynamic value as its maximum?
05:16:39 * ivanm would guess not...
05:16:55 <ivanm> as in, I want values constrained between 1 and n
05:17:10 <ivanm> where n is a "global" variable I keep passing around from function to function
05:17:44 <olsner_> data DynamicBounded = DynamicBounded Int Int?
05:18:25 <ivanm> something like that...
05:20:30 <pejo> ivanm, you can't decide that statically atleast.
05:20:43 <ivanm> :(
05:20:49 <ivanm> didn't think so
05:21:03 <dons> olsner_: ok. done. seems to work nicely. (and fast!) also, code could be shorter still.
05:21:11 <ivanm> *sigh* it would have been nice (as in making my program technically more correct at the type level)
05:21:12 <dons> $ ./a.out file.s
05:21:12 <dons> fromList [(MMX,0),(SSE,0),(OTHER,420694)]
05:21:22 <ivanm> thanks anyway
05:21:32 <dons> olsner_: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
05:22:15 <dons> first step, use lazy bytestring, second, use a Map to do the lookups, third, use a Map with strict updates to accumulate the counts
05:23:53 <dons> runs in constant space, which i'm a little surprised by.
05:24:07 <dons> but we are lazily processing and counting, so it should.
05:24:15 <dons> $ time ./a.out file.s
05:24:15 <dons> fromList [(MMX,0),(SSE,0),(OTHER,420694)]
05:24:15 <dons> ./a.out file.s  2.78s user 0.09s system 88% cpu 3.238 total
05:24:15 <dons> $ du -hs /tmp/file.s
05:24:15 <dons> 23.1M   /tmp/file.s
05:24:20 <olsner_> it really should run in constant space, yeah
05:24:55 <TSC> The lazy reading of the file is safe, if you're only reading it and nothing is writing to it, right?
05:24:55 <olsner_> I was more surprised by the opposite ;-)
05:25:12 <dons> yeah, just the weird list updates, too hairy :-)
05:25:29 <dons> using a Map Instruction InstructionClass makes it a lot simpler, imo
05:26:50 <olsner_> yeah, that enum is much more readable than my string labels
05:26:50 <dons> let me know if anything's not clear.
05:27:16 <dons> oh, we can shave off another 20% by using dropWhile (/= '\t')
05:28:15 * ndm remembers that when he left for lunch, dons was just about to leave for dinner
05:28:34 <dons> almost bedtime now
05:28:50 <ndm> dons: i commented on your book thingy
05:28:57 <ddarius> ndm, escape from the deadly grasp of Haskell before it's too late!
05:29:24 <ndm> dons: have you thought about including an SYB/boilerplate chapter - its useful real-world stuff which can't be replicated in other languages
05:29:44 <dons> hmm. interesting idea!
05:29:51 <dons> i could imagine covering that instead of TH.
05:30:04 <ndm> yeah, i think its way more practically useful
05:30:10 <dons> olsner_:
05:30:11 <dons> fromList [(MMX,0),(SSE,0),(OTHER,420694)]
05:30:11 <dons> ./a.out file.s  2.26s user 0.12s system 95% cpu 2.481 total
05:30:16 <ndm> plus TH is just one MASSIVE api
05:30:16 <kolmodin> too much to cover both?
05:30:23 <ndm> its not that hard to use it
05:30:39 <dons> using an improved lexer, here: http://www.cse.unsw.edu.au/~dons/tmp/B.hs
05:30:47 <kolmodin> perhaps a note about TH and what it is and can be used for could be nice
05:31:14 <olsner_> dons: that's just incredible.. you've done magic to my code! ;-)
05:31:15 <ndm> kolmodin: i suspected the final chapter would be just a single page on each "advanced thingy", which is where i would have put TH
05:31:32 <kolmodin> ndm: aye, sounds resonable
05:32:29 <dons> olsner_: is it doing the right thing though?
05:32:38 * earthy notes that 28 chapters is quite ambitious
05:33:17 <earthy> and that a subdivision into 'parts' would probably make things flow nicer, and make the book more useful to the day-to-day grind
05:33:19 <olsner_> discardAfterSpace was completely wrong - gives the result backwards ;-)
05:33:22 <kolmodin> about the opKinds, it's a set that is created once and then not changed. /me wonders if a hash would perform better than a map (as it's O(1) lookup instead of O(log n))
05:33:31 <earthy> (and to educators cherry-picking chapters ;))
05:33:58 <dons> good advice, earthy
05:34:06 <dons> olsner_: ah yes, noticed that
05:34:22 <kolmodin> except we don't have a pure hash table, and the IO one is slow and IO
05:34:32 <mux> kolmodin: a hash table is only O(1) where there are no collisions
05:34:32 * earthy likes the basic setup though
05:34:43 <dons> we know the keys statically though
05:34:50 <kolmodin> mux: of course
05:34:51 <dons> so you can come up with a perfect hash function ;-)
05:34:54 <mux> ah, so you can use gperf :-)
05:35:23 <mux> it would be interesting to code some thing like gperf but generating a haskell hash function, or maybe adding haskell output to gperf
05:36:03 <kolmodin> mux: but as we know the number of elements when we start one could create a table big enough from the beginning
05:36:26 <kolmodin> and (in theory) there should be quite few collisions :)
05:36:34 <kolmodin> enough to still count it as O(1)
05:37:43 * ivanm is trying to convert his program from implicit Maybes to real Maybes
05:37:49 <ivanm> but it isn't turning out nicely :(
05:38:51 <ivanm> since rather than defining an empty cell value as [0], I'm now just making it Nothing, so my functions that check to see if all elements are singleton lists don't work anymore
05:40:00 <ddarius> @hoogle isJust
05:40:00 <lambdabot> Maybe.isJust :: Maybe a -> Bool
05:40:20 <ivanm> yes, but it fails for Nothing
05:40:37 <olsner_> > isJust Nothing
05:40:39 <lambdabot>  False
05:40:51 <ivanm> so, I either make my functions more complex, or use fromMaybe and pass in the default of [0], which gets rid of the point of having Maybe
05:40:57 <ivanm> oh, I thought that was fromJust :s
05:41:27 <ddarius> :t catMaybes
05:41:29 <lambdabot> forall a. [Maybe a] -> [a]
05:41:52 <ivanm> no, I'm having it of type Maybe [Int]
05:41:58 <ddarius> Why the heck is that called cat Maybes anyways?
05:42:16 <ivanm> using this to represent my sparse matrix (where each cell contains either no values or a list of values)
05:42:22 <dons> filterJust ?
05:42:23 <ndm> concat the maybes
05:42:33 <ivanm> @hooglel just
05:42:33 <lambdabot> Maybe you meant: hoogle hoogle+
05:42:38 <ivanm> @hoogle just
05:42:39 <lambdabot> Prelude.Just :: a -> Maybe a
05:42:39 <lambdabot> Maybe.fromJust :: Maybe a -> a
05:42:39 <lambdabot> Maybe.isJust :: Maybe a -> Bool
05:42:41 <dons> after all, [ a | Just a <- xs ]
05:42:42 <ddarius> Okay... so what are you trying to do?
05:43:13 <ivanm> I have a function single that returns true iff the value is a singleton list
05:43:34 <ivanm> so, to check if my processing had finished, I used to do all (all single)
05:43:45 <ivanm> but now, rather than having [Int], I have Maybe [Int]
05:44:05 <ivanm> so rather than single, I'd want it to return true if its Nothing or Just [x]
05:46:24 <mnislaih> what's the trick that people use to make Haddock swallow GADT syntax ?
05:46:44 <qwr> ivanm: define better single
05:47:02 <qwr> ivanm: that takes Maybe [Int]
05:47:12 * dcoutts_ notes that the cairo package in the gtk2hs darcs repo now supports the ps, pdf and svg backends.
05:47:12 <ivanm> I _could_ do that... but I use it for other purposes as well (/me thinks... maybe not...)
05:47:45 <dcoutts_> ie you can now create ps, pdf and svg files using the same code as you use for onscreen display
05:52:03 <kolmodin> dcoutts_: well done
05:52:11 <dcoutts_> :-)
05:53:45 <mux> yay for dcoutts_ !
05:53:47 <quicksilver> ivanm: use 'maybe'
05:53:55 <quicksilver> maybe True single
05:54:04 <ivanm> @type maybe
05:54:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:54:16 <quicksilver> ivanm: will return 'True' for nothing, and whatever 'single' returns if on x if Just x
05:54:30 <ivanm> quicksilver: how does maybe differ with fromMaybe?
05:54:42 <ivanm> oh, wait, it uses a function as well
05:54:55 <quicksilver> fromJust blows up if it's Nothing
05:54:57 <mux> maybe is a generalization
05:55:07 <quicksilver> maybe lets you choose what to do if it's nothing
05:55:16 <ivanm> *nod*
05:55:28 <quicksilver> and it lets you re-use your existing function 'single'
05:55:29 <ivanm> @src fromMaybe
05:55:29 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
05:55:31 <ivanm> @src maybe
05:55:31 <mux> if you have a Maybe a, you can only get a 'a' with fromMaybe
05:55:31 <lambdabot> maybe n _ Nothing  = n
05:55:31 <lambdabot> maybe _ f (Just x) = f x
05:55:40 <mux> whereas with maybe you can get any other type
05:55:50 <ivanm> *nod*
05:55:53 <ivanm> thanks! :D
05:56:32 <edward1> figures, bang my head against something for hours, drive to work, solve it en route
05:57:00 <dons> two new features in xmonad today, btw,  fibonacci spiral layout, http://xmonad.org/images/screen-sjanssen-spiral-thumb.png (yes! a practical reason to have a good fib function!), and `composited' window effects, like shadows, http://xmonad.org/images/xmonad_xcompmgr.png
05:57:14 <quicksilver> edward1: driving++!
05:57:32 <dons> the composite stuff is very pretty
05:57:53 <ivanm> ooohhhhh..... prettyyyy.......
05:58:02 <quicksilver> dons: did you hear my mumbles about infinite spiral n finite space?
05:58:08 <ivanm> though I'm not sure if the fibonacci layout is worth using....
05:58:15 <dons> quicksilver: hehe.
05:58:18 <dons> ivanm: it looks nice.
05:58:29 <ivanm> yes, it does...
05:58:46 <ivanm> but if the main focus window keeps changing whenever you open a new program...
05:58:52 <ivanm> it could get irritating...
05:59:03 <dons> yeah, the spiral will rotate to the right as you open new windows
05:59:21 <ivanm> and wouldn't it just increase the number of lines required for xmonad without adding any useful/required features?
05:59:37 <dons> its a contributed layout function
05:59:41 <edward1> =)
05:59:46 <dons> there's a pretty huge contrib library now
05:59:49 <dons> of cute things like this
05:59:59 <quicksilver> not only 'pretty huge' but also 'pretty', I submit
06:00:04 <dons> since you can write pure functions on lists to generate custom layouts
06:00:04 <ivanm> *nod*, so its not in the 400/500/whatever it is limit?
06:00:22 <ivanm> is that yi in the left hand frame?
06:00:25 <dons> the fib code isn't in that no. its not part of the core, its a config file.
06:00:36 <dons> i think its vim
06:01:11 <dons> the use of compositing shadows for focus is more useful/pretty, imo.
06:01:19 <dons> this tihng, http://xmonad.org/images/xmonad_xcompmgr-thumb.png
06:01:40 * quicksilver nods
06:02:01 <quicksilver> dons: I want 'glance-to-focus'
06:02:20 <ivanm> yeah, the compositing helps differentiate the focused frame a lot better
06:02:30 <ivanm> dons: is that in the core? or contrib?
06:02:42 <dons> that's an external tool! xcompmgr
06:02:57 * ivanm wonders if xmonad is going to come in two packages, core and contrib, like some distros do
06:03:18 <ivanm> dons: I meant as in the code to get the compositing working with xmonad
06:03:34 <quicksilver> xmonad-nonfree!
06:03:38 <ivanm> heh
06:04:07 <dons> i don't think we had to add any code to get xcompmgr working. we did need some for the randr support (display rotate/hot plug).
06:04:16 <dons> but the shadow stuff is just an X daemon
06:06:13 <ivanm> nice!
06:06:34 <ivanm> as an aside, is it possible to change the frame border width?
06:06:46 <dons> yeah, its just an Int in Config.hs
06:06:50 <ivanm> as in, make the red line around the focussed frame thicker and more notiecealbe?
06:06:56 <ivanm> *nod* OK
06:07:22 <ivanm> does changing Config.hs require re-compilation?
06:07:27 * ivanm would think not, but wanting to check
06:07:33 <quicksilver> no no magic hs-plugins magic!
06:07:35 <ivanm> its not like its a long compile
06:07:36 <dons> it does require recompilation.
06:07:43 <ivanm> :(
06:07:48 <ivanm> oh well
06:07:56 <dons> and then you hit mod-shift-ctrl-q, which reforks the app, piping the old state into the new app
06:08:00 <dons> so you don't notice anything :-)
06:08:04 <quicksilver> that's cute
06:08:08 <ivanm> heh
06:08:25 <dons> system ( "xmonad --restart " ++ show state) -- basically
06:08:28 <ivanm> hmmm.... with my Maybe questions, is there a mapMaybe?
06:08:40 <quicksilver> althought requiring the presence of a compiler to reconfigure a window manager si a bit unusual
06:08:43 <quicksilver> ivanm: yes, fmap
06:08:46 <quicksilver> ivanm: it's a functor
06:08:46 <subdie> hi, does anyone know which debian package is Control.Monad.State in?
06:08:52 <mux> ivanm: Maybe is a functor si you can fmap/liftM
06:08:53 <ivanm> ohhh..... thanks quicksilver!
06:08:54 <quicksilver> subdie: mtl, I think
06:09:01 <dons> it is. but heh, you got haskell as your config language :-)
06:09:11 <quicksilver> subdie: well, libghc-mtl-dev, or whatever it's called
06:09:11 <dons> so you can write fibonacci spirals in config files.
06:09:22 <subdie> thanks :)
06:09:34 <ivanm> quicksilver: but do I specifically need to take the Just's into account, or will it do that automatically?
06:09:43 <chessguy> wow, this new book thing is pretty freaking exciting
06:09:54 <quicksilver> fmap length [Just "foo",Nothing,Just "Barbaz",Just ""]
06:09:57 <chessguy> it's gonna be an awesome book
06:09:58 <quicksilver> > fmap length [Just "foo",Nothing,Just "Barbaz",Just ""]
06:09:58 <ivanm> ie. does the mapping function need to be of type (Maybe a -> Maybe b), or just a -> b
06:09:59 <lambdabot>  Couldn't match expected type `[a]'
06:10:07 <quicksilver> > map (fmap length) [Just "foo",Nothing,Just "Barbaz",Just ""]
06:10:09 <lambdabot>  [Just 3,Nothing,Just 6,Just 0]
06:10:09 <quicksilver> doh :P
06:10:15 <quicksilver> ivanm: just a->b
06:10:22 <ivanm> excellent!
06:10:25 <quicksilver> ivanm: that's what fmap does :)
06:10:34 <ivanm> heh
06:10:42 * ivanm has never used fmap before, so wasn't sure
06:10:45 <ivanm> @type fmap
06:10:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:10:50 <quicksilver> ivanm: fmap is (a->b) -> (f a -> f b)
06:10:55 <quicksilver> where here 'f' is Maybe
06:10:57 <araujo> morning
06:10:59 <ivanm> *nod*
06:12:30 <dons> bed time. night all
06:12:57 <ivanm> night dons
06:13:06 * ivanm wonders what this mystical "bed" is...
06:13:07 <ivanm> ;-)
06:13:21 <dcoutts_> g'night dons
06:13:36 <chessguy> ?seen jgoerzen
06:13:36 <lambdabot> I haven't seen jgoerzen.
06:13:54 <quicksilver> ?seen cosmicray
06:13:55 <lambdabot> I saw cosmicray leaving #haskell-blah, #darcs and #haskell 15h 3m 24s ago, and .
06:14:03 <quicksilver> ^^ I think those are the droids you're looking for
06:14:37 <ivanm> hmmm... I have a function of type [Maybe [a]] -> [Maybe [a]]
06:14:41 <chessguy> oh, cosmicray = john goerzen?
06:14:59 <ivanm> and the function is fmap f, where f is of type [a] -> [a]
06:15:16 <ivanm> so why is it complaining about types? :s
06:15:36 <quicksilver> ivanm: because that's a list of maybes
06:15:42 <quicksilver> ivanm: you want map (fmap f)
06:15:49 <ivanm> oh.....
06:15:49 <quicksilver> ivanm: map for the listy bit and fmap for the maybe bit
06:15:50 <ivanm> duh
06:15:53 <ivanm> same problem you had
06:15:57 <ivanm> ;-)
06:15:58 <ivanm> thanks quicksilver
06:16:01 <quicksilver> ivanm: actually you could write it fmap (fmap f)
06:16:08 <quicksilver> because fmap == map :)
06:16:33 <ivanm> heh... only for lists though, right?
06:16:35 <olsner> :t fmap
06:16:36 <quicksilver> :t \f -> map (fmap f)
06:16:36 <olsner> _t map
06:16:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:16:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> [f a] -> [f b]
06:16:45 <quicksilver> ivanm: yes
06:16:50 <quicksilver> ivanm: map is the special case for lists
06:16:56 <ivanm> *nod*
06:17:04 <ivanm> even though map was designed before fmap, right? :p
06:18:01 <quicksilver> that's a common pattern
06:18:06 <araujo> http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
06:18:07 <lambdabot> Title: Real-World Haskell » Blog Archive » Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
06:18:10 <quicksilver> the specific is often discovered before the general
06:18:17 <araujo> where did that come from? :-)
06:18:31 <quicksilver> araujo: it came down the tubes?
06:18:45 <chessguy> araujo: apparently they've been keeping it a secret for a while
06:19:18 <araujo> chessguy, hola!
06:19:22 <araujo> hah, nice
06:19:23 <quicksilver> 'secret' is such a dirty word. I prefer "surprise!"
06:19:26 <chessguy> nas!
06:20:46 <araujo> nice stuff
06:21:12 <chessguy> yeah, i'm pretty stinking excited
06:21:22 <chessguy> with those authors it's going to be extremely well-written
06:22:09 <dcoutts_> @yarr!
06:22:09 <lambdabot> Har de har har!
06:22:11 <dcoutts_> indeed
06:23:00 <ivanm> is this going to be a beginner, intermediate or advanced level haskell book?
06:23:10 <ivanm> i.e. how does it compare to craft, SoE, etc
06:23:28 <araujo> ivanm, read the description
06:23:42 <chessguy> ivanm: "...while there’s a huge body of introductory material available on the web, you have to be both tremendously motivated and skilled to find the “good stuff” and apply it to your own learning needs.
06:23:42 <chessguy> The time has come for the advanced, practical Haskell book."
06:23:50 <chessguy> from http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
06:23:51 <lambdabot> Title: Real-World Haskell » Blog Archive » Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
06:24:03 <ivanm> chessguy: ahh, didn't see that during my skim-through
06:24:05 <ivanm> thanks!
06:24:16 * ivanm must remember that read =/= skim :p
06:24:18 * araujo would like to help with the gtk2hs chapter
06:24:40 <dcoutts_> araujo: good, that makes two of us
06:24:46 <ivanm> OK, in case I didn't see it, is there a definite timetable for this?
06:24:46 <araujo> dcoutts_, yay!
06:25:14 <araujo> this is so cool
06:25:32 <quicksilver> ivanm: circa 1 year, I believe
06:25:41 <ivanm> :(
06:25:46 <chessguy> dcoutts_: what do you know about gtk2hs? :)
06:25:48 * ivanm can't wait :(
06:26:00 <chessguy> quicksilver: where did you hear that?
06:26:01 <dcoutts_> chessguy: heh :-)
06:26:09 <quicksilver> chessguy: on the mailing list thread on the subject, I think
06:26:15 <ivanm> quicksilver: is that just the writing, or does it include the checking, typesetting, binding, etc?
06:26:19 * ivanm guesses the former
06:26:46 <chessguy> ivanm: on the plus side, they'll be publishing some content online, so we'll get stuff along the way
06:26:51 <quicksilver> chessguy: no, apparently not
06:26:58 <quicksilver> chessguy: maybe they said it here in teh channel
06:27:03 <ivanm> chessguy: true
06:27:11 <ivanm> no, it says that on the site, and in email
06:27:34 <quicksilver> 09:53 < swiert> dons: Do you have any idea when it will be finished?
06:27:38 <quicksilver> 09:54 < dons> swiert: hmm, 10+ months. something like that.
06:27:41 <quicksilver> 09:54 < dons> its around 30 chapters
06:27:43 <ivanm> "Finally, a very exciting aspect of this project is that Oâ€™Reilly has agreed to publish chapters online, under a Creative Commons License! Weâ€™ll be publishing chapters incrementally, and seeking feedback from our reviewers and readers as we go."
06:28:14 <ivanm> oh, wait, quicksilver was talking about the deadline... :s
06:30:54 <chessguy> hmm, i'm not sure i've seen any writing from John Goerzen that's actually about haskell. most of his blogs that i read are about country living, or his son, or linux, or ...
06:31:58 <ibid> i suppose the same goes for me :)
06:32:17 <oh`> anyone got a trick to extract the 3rd element in a 3 tuple, without defining my own function?
06:32:39 <ivanm> @pl \ (_,_,x) -> x
06:32:40 <lambdabot> (line 1, column 7):
06:32:40 <lambdabot> unexpected ","
06:32:40 <lambdabot> expecting operator or ")"
06:32:40 <lambdabot> ambiguous use of a non associative operator
06:32:44 <quicksilver> oh`: (\(_,_,x) -> x)
06:32:46 <ivanm> @pl \ (a,v,x) -> x
06:32:46 <lambdabot> (line 1, column 7):
06:32:46 <lambdabot> unexpected ","
06:32:46 <lambdabot> expecting letter or digit, operator or ")"
06:32:46 <lambdabot> ambiguous use of a non associative operator
06:32:47 <ibid> cosmicray was very active in the haskell scene for a couple of years, that's a reason why he's on planet
06:32:58 <chessguy> ivanm: @pl can't handle triples
06:33:05 <ivanm> ahhh, that explains it
06:33:35 <ibid> chessguy: ^^ :)
06:33:37 <chessguy> ibid: i believe it. i just wanted to see a sample of his writing about haskell. he's the only one of the 3 that i haven't seen blog about haskell
06:33:40 <ivanm> didn't think there was a nicer way than the lambda function anyway...
06:34:19 <chessguy> ivanm: probably not
06:34:27 <quicksilver> No, there isn't
06:34:35 <ibid> chessguy: tell him that then? :)
06:34:37 <quicksilver> I've seen somebody make Tuple into a typeclass
06:34:49 <quicksilver> and define fst, snd, trd, fth and so on
06:34:56 <quicksilver> but I'm not sure it's worth it, personally
06:35:17 <quicksilver> if you use n-tuples a lot, give them a name, is a reasonable rule of thumb
06:35:17 <Eelis> when is Haskell' expected to be "ready" ? is there anything close to a (tentative) roadmap, or is it just duke nukem forever style "when it's done" ?
06:35:26 <osfameron> quicksilver: did you follow the Editor thread link to SmartEdit ?
06:35:27 <dcoutts_> quicksilver: I agree
06:35:31 <oh`> so i cant do it without defining it myself? or am i just dense?
06:35:32 <osfameron> I love that programming by example stuff.
06:35:38 <ibid> Eelis: i believe the goal was to finish last year ;)
06:35:49 <quicksilver> oh`: you can inline the function (\(_,_,x)->x)
06:35:49 <Eelis> ibid: hmm, i see :)
06:35:52 <dcoutts_> oh`: the point is, it's so small, it does not need a name
06:35:59 <quicksilver> oh`: or just do a tuple match
06:36:07 <quicksilver> oh`: depending on the context you awnt to use it
06:36:27 <ibid> Eelis: did you know that h98 was released in 1999? (not that the situations are comparable...)
06:36:32 <quicksilver> > map (\(_,_,x)->x) [(1,1,1),(2,1,0),(3,4,5)]
06:36:34 <lambdabot>  [1,0,5]
06:36:36 <ibid> (and c99 was released in 2000, but who cares about that)
06:36:39 <Eelis> ibid: i did not
06:37:04 <oh`> ahhhh i see
06:37:09 <quicksilver> windows millenium edition was released in the *third* millenium, making it presumably 2000 years late
06:37:22 <oh`> cheers
06:37:51 <ibid> hah
06:37:56 <quicksilver> osfameron: I can't remember. I remember following beelsebob's suggestion and briefly looking at subethaedit
06:38:46 <earthy> bah. Algol'68 was finalized in 1973 or somesuch
06:38:46 <quicksilver> osfameron: do you mean this: http://tlau.org/research/smartedit/ui.html
06:38:50 <lambdabot> Title: SMARTedit user interface
06:38:55 <osfameron> quicksilver: yarr!
06:38:59 <ibid> earthy: that was the revised edition, was it not?
06:39:13 <osfameron> I downloaded it to play with in my Copious Free Time
06:40:03 <quicksilver> osfameron: that looks rather fun
06:40:10 <earthy> ibid: it was. ;)
06:40:17 <quicksilver> osfameron: did you follow chessguy's link to magicink?
06:40:17 <Eelis> looking at the haskell' wiki pages it doesn't seem likely that it'll be ready before, say, third quarter of 2008. would that be an unfair assessment?
06:40:25 <earthy> no
06:40:29 <earthy> that is quite fair
06:40:34 <earthy> haskell' drowned in committee
06:40:49 <chessguy> that's probably optimistic
06:40:58 <earthy> basically, if you want haskell', sit down, write it up in a report, implement it, and hand it to the haskell community
06:41:15 <ibid> it seems to me, being subscribed to the list but not really reading that it's not so much drowned in committee but not moving
06:41:18 <ivanm> @hoogle find
06:41:19 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
06:41:19 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
06:41:19 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
06:41:27 <ivanm> how does find differ from lookup?
06:41:30 <ibid> ie, there is no one pushing it along
06:41:30 <quicksilver> Eelis: but to the community, ti doesn't matter too much. Since when a proposal is approved by the haskell' process, it probably gets implemented in one or more compilers
06:41:31 <ivanm> @hoogle lookup
06:41:31 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
06:41:31 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
06:41:31 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
06:41:44 <ivanm> forget that... :s
06:41:44 <quicksilver> ivanm: lookups for associative arrays
06:41:45 <Eelis> quicksilver: true, i guess
06:41:59 <quicksilver> Eelis: so the process still moves the community forward even if it never terminates :)
06:42:07 <ivanm> quicksilver: yeah, which is what I have, but I dind't know about lookup and was using find instead
06:42:11 <Eelis> i just like the peace of mind of a good ol' standard ;)
06:42:16 * quicksilver nods
06:42:19 <osfameron> quicksilver: I've read bits of magicink a couple of times
06:42:23 <quicksilver> the great thing about standards, is there are so many to choose from
06:42:36 <ibid> there is no standard haskell, and i like it that way
06:42:47 <ibid> well, an ECMA standard i could stomach, but ISO... eeeek
06:43:03 <Eelis> you don't like ISO ?
06:43:15 <ivanm> @pl \ s v -> fromJust (lookup v s)
06:43:15 <lambdabot> (fromJust .) . flip lookup
06:43:17 <ibid> i don't like their pricing policy
06:43:22 <ivanm> @pl \ v s -> fromJust (lookup v s)
06:43:22 <lambdabot> (fromJust .) . lookup
06:43:28 <ibid> no problems with them otherwise
06:43:33 <Eelis> ah.
06:43:34 <earthy> ISO takes ages upon ages to standardise shit
06:44:05 <quicksilver> unless it's microsoft's office format :P
06:44:19 <earthy> yeah, but they got paid for that. ;)
06:44:19 <ivanm> heh
06:44:26 <ibid> earthy: what i've seen, ISO standard drafting is slowest in the actual working group. i doubt that's any different in any other organisation
06:44:50 <Eelis> the first C++ standard is from '98. it got some corrections in '03, and will get major additions in '09. i'd say ISO is moving faster than the haskell' committee :)
06:45:23 <ibid> earthy: ISO's prodecural problem is that you sometimes need to come up with ugly hacks to please the fringe nationalitie3s
06:45:36 <ibid> earthy: (case in point: trigraphs in standard C)
06:45:53 <earthy> eelis: there's a bit more money behind C++ though, and C++ at that point had existed a long time already, longer than haskell currently exists, if I count correctly
06:45:57 <ibid> earthy: but i don't see ISO as being particularly slow otherwise
06:46:12 <earthy> standardisation tends to slow things down one way or the other
06:46:24 <ibid> haskell is now 20 years old. C++ was younger than that in 1998
06:46:28 <dcoutts_> Eelis: Haskell went through several iterations 1.0, 1,1 .2 .3 .4 and finally Haskell 98
06:46:47 <earthy> but, true, it's not extremely slow as standardisation processes go
06:46:54 <dcoutts_> which was finalised in 2003 iirc
06:46:58 <earthy> C++ was 17 in 1998?
06:47:05 <dcoutts_> or was it 01 I don't recall
06:47:13 <earthy> Haskell'98 was 16 in 2003 or thereabouts
06:47:24 <ibid> haskell 98 was finalised in 1999
06:47:41 <dcoutts_> ibid: hmm, I think the final corrected report was '01
06:47:44 <ibid> trhe 2003 release was a corrigendum release
06:48:03 <Eelis> C++ is also a vastly more complicated language than Haskell
06:48:09 <ibid> but if you compare to c++ 1998, the corresponding date for haskell 98 is 1999
06:48:10 <earthy> um. no it isn't
06:48:25 <earthy> it has a larger standard lib
06:48:44 <dcoutts_> I think the C++ language is more complex, that's one of the bad things about it
06:49:14 <ibid> i don't  have a reference handy, but c++ was birthed in around 1982-1984
06:49:45 <ibid> of course, C++ benefits from the long history of C
06:49:50 <earthy> http://www.cplusplus.com/info/history.html
06:49:51 <lambdabot> Title: History of C++
06:50:15 <earthy> ahd ANSI X3J16 took 8 years to standardise C++
06:50:41 <ibid> the ANSI committee committed lots of language design
06:50:49 <Eelis> the complete haskell98 report is 263 pages. just the non-library parts of the C++98 standard are more than 400 pages
06:50:51 <ibid> and still does
06:51:05 <ibid> the current c++0x working papers are scary reading
06:51:22 <ibid> and the c++98 standard has a very small font!
06:51:47 <Igloo> I think the C++ standard is more precisely worded than the Haskell standard, though
06:51:54 <earthy> http://portal.acm.org/citation.cfm?id=155375 if you don't trust that other link. ;)
06:51:56 <lambdabot> Title: A history of C++
06:53:42 <ibid> Igloo: yeah, the haskell reports resemble the ritchie reference manuals of C (or stroustrup rm's for C++) more than the C or C++ standards
07:02:04 <dblhelix> Igloo: I had some strange problems with building ghc-head last week (on mac os ppc, that is): somehow the FIND variable in libraries/Makefile did not get assigned
07:02:40 <nox-Hand> www.google.com <----
07:02:46 <dblhelix> Igloo: making with make FIND=find solved it, but perhaps there's something wrong with the configure/make scripts?
07:02:49 <nox-Hand> Just checking lambdabot, byee :D
07:02:59 <Igloo> dblhelix: Do you have the configure output?
07:03:29 <dblhelix> not anymore, I'm afraid... but I did see it resolving find to /usr/bin/find
07:04:41 <Igloo> dblhelix: OK, well, if you reproduce it, send me the configure output and mk/config.mk
07:04:57 <ivanm> What does this error message mean:  Warning: Pattern match(es) are overlapped ?
07:05:17 <Igloo> ivanm: One of your patterns will never match, because a pattern higher up will match first
07:05:18 <ivanm> I have foo Nothing = "."; foo (Just v) = show v
07:05:19 <dblhelix> Igloo: I might still have mk/config.mk hanging around
07:05:32 <Igloo> ivanm: That's it?
07:05:35 <ivanm> Igloo: can't see how though...
07:05:38 <ivanm> yup
07:05:47 <Igloo> ivanm: Can you put the whole thing somewhere?
07:05:56 <ivanm> hang on.... that's weird...
07:06:16 <ivanm> I had a variable which was unsetValue = Nothing
07:06:37 <ivanm> and my original function had foo unsetValue..
07:06:44 <ivanm> using foo Nothing works though :s
07:06:52 <Igloo> That doesn't do what you think it does
07:07:04 <dblhelix> Igoo: mk/config.mk [line927]: FIND =
07:07:06 <ivanm> would it be because I had unsetValue = Nothing :: Maybe a ?
07:07:19 <Igloo> It makes a new variable unsetValue which shadows the other one
07:07:51 <Igloo> dblhelix: And the next line is SORT = something?
07:08:10 <dblhelix> Igloo: indeed, where something = /usr/bin/sort
07:08:35 <ivanm> Igloo: what do you mean?
07:09:38 <Igloo> dblhelix: OK, if configure found it then I have no idea what's up. It would need some debugging
07:10:01 <Igloo> ivanm: foo = Nothing; bar foo = 5    is the same as    foo = Nothing; bar wibble = 5
07:10:24 <dblhelix> Igloo: if I've some time tonight, I'll have another look at it
07:10:28 <ivanm> Igloo: where did wibble come from?
07:10:32 <Igloo> ivanm: In both cases you are just making a new variable. In the first case this variable shadows the top-level foo, so foo on the RHS refers to the argument rather than the top-level variable
07:10:38 <ivanm> oh, duh
07:10:39 <Igloo> ivanm: It's a new variable
07:10:42 <dblhelix> Igloo: thanks, anyway
07:10:55 * ivanm forgot that you can't put variables in the LHS :s
07:11:01 <ivanm> thanks Igloo
07:12:41 * earthy looks at the pictures on johan jeuring's blog and recognizes the drawer's hand. ;)
07:13:36 <dblhelix> earthy: then maybe you can tell him who's spammed him ;-)
07:14:21 <quicksilver> ivanm: or to be more precise, when you put a variable on the LHS, it's a fresh variable
07:14:23 * earthy guesses Andres won't let him retaliate, even if Johan wanted to. ;)
07:14:32 <quicksilver> ivanm: patterns bind fresh variables, they don't re-use existing ones
07:14:33 <ivanm> quicksilver: *nod*
07:15:00 <ivanm> yeah.... I originally had it as an if statement, then decided to split it up into a pattern matching function
07:15:37 <lispy> :t 1
07:15:39 <lambdabot> forall t. (Num t) => t
07:15:51 <lispy> hm...lambdabot seems to be ignoring me
07:16:06 <quicksilver> ?
07:16:10 <lispy> but only in /query
07:16:19 <quicksilver> in /query you have to write '@type'
07:16:20 <lispy> i'm identified
07:16:22 <ivanm> oh-oh..... all those changes I made seem to have doubled the run-time of my program...
07:16:27 <ivanm> and I forgot to back it up first :s
07:16:27 <quicksilver> the abbreviations don't work in query
07:16:32 <sjanssen> lispy: it's working for me
07:16:40 <ivanm> so its a matter of undoing the darcs commit from a few days ago :s
07:16:44 <lispy> Oh, you do have to do ?type
07:17:34 <ivanm> *sigh* well, I'll do a full long run-time test to make sure, but it looks like a better programming style (i.e. using Maybe explicitly rather than implicitly) is bad for my program :(
07:18:07 <ivanm> night all
07:26:04 * lispy tries to sneak in project euler problems before breakfast -- what an addictive site!
07:33:50 <wilx|wrk> Hmm, somebody should package xmonad into Ubuntu package.
07:34:52 <LoganCapaldo> wilx|wrk: Thanks! It'll be great when you've packaged that up :)
07:34:58 <lispy> i haven't looked at xmonad at all, but i'm kinda suprised no one has done it
07:35:08 <ndm> wilx|wrk: if you prod on #xmonad they may do it
07:37:04 <sjanssen> wilx|wrk: I'd love to have some binary packages of xmonad
07:37:45 <arcatan> binary packages are not that useful considering xmonad is configured by editing source :|
07:37:51 <wilx|wrk> :)
07:38:04 <lispy> whoa, really?
07:38:18 <lispy> ?quote compiler
07:38:18 <lambdabot> ptolomy says: I'm having a hard time convincing my girlfriend that a (somewhat) sophisticated optimizing brainfuck compiler in haskell is an interesting or worthwhile thing for me to do, particularly
07:38:18 <lambdabot> on a friday night. :-P
07:38:25 <sjanssen> they're certainly less useful.  However, I imagine that most users would be okay with the default config
07:38:58 <lispy> not the quote a i wanted...i wanted the one by (i think) Pseudonym about how Haskell is optimized for writing compilers...then i wanted to chastize xmonad for not using a config language :)
07:39:05 <wilx|wrk> Well, at least they could try it fast.
07:39:26 <arcatan> yeah
07:39:31 <cdsmith> lispy: great, now you've got me hooked on this project euler stuff.  My boss probably wouldn't be happy with you.
07:39:45 <lispy> cdsmith: heh, try to beat my score
07:39:53 <sjanssen> lispy: we want the full power of Haskell for configuration.  haskell-plugins is too complicated
07:39:55 <arcatan> I used to build Arch packages for dwm with my own config
07:40:03 <cdsmith> lispy: Well, I just started.  I'm beginning problem #4 now.
07:40:22 <lispy> i'm waiting on the answer to problem 12 now
07:40:36 <lispy> i'm just brute forcing it with a 3 line haskell program :)
07:40:49 <jfredett> <-- I'm a 33% genius, :)
07:40:55 <lispy> jfredett: nice
07:41:09 <jfredett> I haven't touched it for a while though
07:41:10 <lispy> we need to bring the haskell average up! :)
07:41:19 <jfredett> I use pen and paper. :P
07:41:29 <jfredett> well, pencil
07:41:49 <fasta> Is an alternation of X and Y always the pattern X,Y,X,Y,X? Or is X,X,Y,Y,X,Y,Y,X also an alternation of X and Y?
07:42:11 <jfredett> I did problem 45 w/ pen and paper, it took me 2 months
07:42:25 <lispy> fasta: i would assume the context would need to define that clearly...
07:42:32 <lispy> jfredett: wow
07:42:34 <jfredett> I have a fully general equation with an infinite number of roots, it was naaassty
07:42:54 <jfredett> My father did the same problem in 2 minutes in C
07:42:55 <jfredett> :(
07:43:00 <lispy> heh
07:43:01 <fasta> lispy: The context doesn't say anything about it.
07:43:07 <lispy> fasta: bummer
07:43:27 <fasta> lispy: but I know an interpretation in which it means the latter.
07:43:40 <jfredett> (1 miniute to code, < 1 minute to run... :/)
07:44:06 <fasta> lispy: but since I believed alternation meant the former... it makes me think either me or those other people use alternating incorrectly.
07:44:47 <fasta> Natural languages--
07:45:05 <lispy> i don't see a wikipedia page on it
07:46:29 <pitecus> I get weird compilation errors from when i try to use -O2 on code which uses FFI
07:46:44 <pitecus> does anyone know why that might be?
07:46:49 <vydd> hm. guys. what problems are you solving?
07:46:57 <pitecus> It compiles just fine without -O2
07:47:42 <pitecus> Stuff like:
07:47:44 <pitecus> ./c_maxent.h:18:0:
07:47:44 <pitecus>      error: expected â€˜=â€™, â€˜,â€™, â€˜;â€™, â€˜asmâ€™ or â€˜__attribute__â€™ before â€˜c_load_from_fileâ€™
07:48:14 <sjanssen> pitecus: does -O2 -fasm give the same error?
07:48:28 <mauke> what is line 18 (and 17)?
07:48:41 <pitecus> sjanssen, no it doesny
07:48:55 <pitecus> sjanssen, what does -fasm mean?
07:49:08 <sjanssen> pitecus: -O implies -fvia-c.  GHC does some extra checking of FFI imports with -fvia-c
07:49:12 <pitecus> mauke its :
07:49:14 <pitecus> void   c_probability_distribution(C_ME_Model *,C_ME_Sample *, int * labels, double * probs);
07:49:14 <pitecus> bool   c_load_from_file(C_ME_Model *,const char * filename);
07:49:40 <mauke> that means bool doesn't exist
07:49:41 <sjanssen> pitecus: -fasm uses GHC's assembler, -fvia-c generates C and sends it to gcc
07:49:58 <mauke> where's the bool coming from?
07:50:04 <pitecus> sjanssen, whats the advantage of going thru C?
07:50:33 <pitecus> mauke, you mean there is no type bool in C?
07:50:34 <quicksilver> lispy: IIRC, brute forcing problem 12 isn't feasible
07:50:46 <pitecus> mauke, I forgot that ;-)
07:50:55 <pitecus> was wrapping C++ functions
07:51:04 <quicksilver> lispy: the euler problems are designed to to require a mixture of thought and computation
07:51:11 <mauke> pitecus: yeah
07:51:22 <mauke> (C99 has _Bool though)
07:51:43 * earthy congratulates cosmicray on the Big Project
07:51:50 <CosmicRay> thanks earthy!
07:52:02 * quicksilver congratulates CosmicRay on impending immortality
07:52:06 <chessguy> yeah congrats, CosmicRay, that's majorly exciting
07:52:23 <pitecus> mauke, g++ doesnt complain about the bool tho
07:52:37 <earthy> how do you get the time, what with a new house, a young kid and everything? :)
07:52:50 <CosmicRay> yes, it is great to be writing about this (I've thought it's been a weakness in Haskell books for a long time), to be working with dons and bos, and with O'Reilly too
07:52:57 <lispy> quicksilver: i'll keep that in mind if this doesn't finish soon...i admit i don't know how to opmitize this problem, maybe i need to read up on it
07:53:01 <mauke> maybe because g++ is a C++ compiler?
07:53:08 <lispy> quicksilver: (but, don't give me hints!)
07:53:11 <earthy> yeah, O'Reilly really has their shit together
07:53:13 <CosmicRay> earthy: I guess I'll just have to write lazily, and produce chapters only when their result is demanded ;-)
07:53:18 * earthy grins
07:53:45 <CosmicRay> earthy: my favorite part is that, unlike every other publisher I've written for to date, I don't have to use Word ever!
07:53:45 <pitecus> mauke, you ve got a point. im so dense today
07:53:54 * CosmicRay hates word
07:54:07 * earthy thinks Book `seq` Book
07:54:08 <chessguy> ?hoogle word
07:54:08 <lambdabot> Data.Word :: module
07:54:08 <lambdabot> Data.Word.Word :: data Word
07:54:08 <lambdabot> System.Win32.Types.WORD :: type WORD
07:54:13 <CosmicRay> heh
07:54:14 <lispy> CosmicRay: god, word is so terrible.  The equation editor is so broken....
07:54:26 <lispy> CosmicRay: hate hate hate hate hate word :)
07:54:30 <jfredett> CosmicRay, What do you use, LaTex? I don't like word either
07:54:36 <jfredett> I like LaTeX
07:54:37 <jfredett> :)
07:54:42 <earthy> CosmicRay: well, Tim O'Reilly started out with roff, so that don't surprise me one bit
07:54:49 <earthy> I know they do a lot of docbook these days. :)
07:54:53 <pitecus> latex sucks, it just sucks less
07:55:15 <CosmicRay> lispy: not only that, but try writing a sentence that starts with ls --help.  It will capitalize the "l", convert the "--" into an em-dash, etc.  you can never really figure out all the places to turn that crap off.
07:55:23 <CosmicRay> jfredett: docbook, I think
07:55:32 <lispy> CosmicRay: true dat
07:55:37 <jfredett> I Think LaTeX is as close to not sucking as possible, and if they had a better macro system I'd think it doesn't suck at all
07:55:50 <jfredett> CosmicRay, Cool.
07:55:55 <osfameron> the LaTeX parser is completely braindead though
07:56:03 <osfameron> its error reporting is terrible
07:56:03 <jfredett> I agree
07:56:09 <earthy> LaTeX doesn't really have a parser in any real sense
07:56:25 <CosmicRay> earthy: but it doesn't have any bugs, right? ;-)
07:56:31 <jfredett> LaTeX3 is supposed to be better, but who knows...
07:56:39 <osfameron> oh.  Well, whatever: the "bit that gives me a completely useless error message when I screwed up the syntax" is rubbish
07:56:57 <osfameron> and I have enough trouble debugging *code* to really, really, really hate having to debug documents too...
07:57:07 <earthy> cosmicray: TeX doesn't formally have any bugs anymore
07:57:11 <earthy> LaTeX otoh... ;)
07:57:16 <CosmicRay> earthy: ahh ;-)
07:57:31 <earthy> plus, pdftex != TeX :)
07:57:33 <jfredett> Someday, we'll have LaTeX-k, and LaTeX-k will read your mind directly, be able to write the  proof for you, etc.
07:58:00 <jfredett> but until then, LaTeX is the way for me, ayup.
07:58:01 <lispy> what is the next widely known irrational number after pi?
07:58:01 <CosmicRay> earthy: I remember an NPR interview with Knuth a few years back.  The reporter asked him if his pledge to pay for bugs is costing him much.  He said no, for two reasons: one is that there aren't that many bugs being discovered, and two because people frame checks from him rather than cashing them now ;-)
07:58:22 * earthy hasn't framed his
07:58:24 <earthy> but yeah
07:58:31 <earthy> haven't cashed it either :)
07:58:32 <SamB_XP> what? \TeX $\pir$ is out now?
07:58:35 <SamB_XP> er.
07:58:36 <pitecus> if you use more 3, 4 packages in latex things are bound to get screwed up
07:58:38 <SamB_XP> s/pir/pi/
07:58:49 <pitecus> they always interfere with each other
07:58:51 <Philippa> probably a square root or a multiple of one?
07:58:55 <lispy> SamB_XP: nope, it's converging to e last i checked
07:58:58 <earthy> SamB: nope. but TeX has been declared bug free. anything that's left is a feature.
07:59:06 <earthy> lispy: that's metafont.
07:59:09 <SamB_XP> lispy: wasn't that metafont?
07:59:15 <Philippa> sqrt 11, say
07:59:25 <SamB_XP> earthy: I don't believe it
07:59:31 <jfredett> TeX is converging to pi,
07:59:34 <jfredett> i though
07:59:34 <jfredett> t
07:59:37 <Philippa> or I could take a less literal value of "after" :-)
07:59:48 <Philippa> e and pi go together well though
08:00:20 <jfredett> they can't be proven algebraicly independent
08:00:35 <sieni> wha? has knuth died?
08:00:35 <jfredett> so maybe they go REALLY well together
08:00:44 <earthy> "I believe that the final bug in TeX was discovered and removed on November 27, 1985. But if, somehow, an error still lurks in the code, I shall gladly pay a finder's fee of $20.48 to the first person who discovers it. (This is twice the previous amount, and I plan to double it again in a year; you see, I really am confident!)"
08:00:49 <earthy> from the preface
08:01:20 <jfredett> oh, so maybe I should just sit on this bug that I found
08:01:31 <jfredett> until he starts offering some real money.
08:01:31 <SamB_XP> the number would have to get a bit higher before someone would cash the check...
08:01:31 <jfredett> :P
08:02:15 <lispy> heh, even i could afford to pay for his bug reports at his current price
08:02:20 <earthy> there's people that have cashed the chekcs
08:02:24 <jfredett> I dont understand why people just dont make a high quality copy of the check, and then cash the real thing.
08:02:39 <earthy> it'd cost me EUR 20 to cash it
08:02:39 <SamB_XP> lispy: well, if you paid for bug reports, people would cash the checks
08:02:46 <LoganCapaldo> I don't understand why people don't make high quality copies of the check and cash the copy....
08:02:50 <LoganCapaldo> oh wait er, nvm
08:02:52 <osfameron> LoganCapaldo++
08:02:56 <sieni> I don't understand why people buy expensive paintings instead of cheap posters.
08:03:01 <jfredett> LoganCapaldo, Brilliant!
08:03:05 <earthy> I'd get $ 2.56 from that EUR 20 administrative cost. and no check anymore.
08:03:16 <earthy> no I will not cash that check. :)
08:03:43 <CosmicRay> how much was yours for?
08:03:56 <earthy> as I said, ISTR it was $ 2.56
08:04:00 <CosmicRay> ah
08:04:04 <osfameron> does it double for each bug
08:04:06 <osfameron> ?
08:04:08 <earthy> nope.
08:04:10 <lispy> ah a hexidecimal dollar
08:04:10 <araujo> CosmicRay, hi there, nice work with the book :-)
08:04:15 <SamB_XP> earthy: well. you could mail it to someone else to cash it!
08:04:23 <earthy> samb: yeah. right. :)
08:04:30 <CosmicRay> thanks araujo!
08:04:31 <SamB_XP> well. if it was from lispy
08:04:32 <earthy> anyway, this was for an infelicity in TAOCP vol 2
08:04:39 <araujo> CosmicRay, i'd like to help with the gtk2hs chapter , if possible :-)
08:05:10 <SamB_XP> I mean, who is going to hang lispy's checks on walls?
08:05:25 <SamB_XP> lispy: no offense ;-)
08:05:41 * lispy takes down a couple checks he hung on his own wall
08:05:44 <lispy> SamB_XP: good point :)
08:06:28 <lispy> if i opened a two bank accounts and then wrote myself checks between the two accounts do you think my bank would 1) notice 2) care?
08:07:02 <osfameron> nope
08:07:08 <LoganCapaldo> depending on what you mean by 1) maybe and 2) no
08:07:20 <osfameron> it can sometimes be useful to do so if your bank insists on a certain amount of money being transferred into your account every month
08:07:29 <CosmicRay> araujo: I'm not sure if it is contractually possible to have additional authors, but if you're interested in reviewing, you could drop a note to book-review-interest@realworldhaskell.org
08:07:32 <osfameron> so you just pay it in, then pay it stragiht out again
08:07:51 <araujo> CosmicRay, hah, not like an author, as a reviewer :-)
08:08:05 <CosmicRay> yeah
08:08:47 <earthy> I wouldn't mind doing a bit of work on the Real World Haskell book just to be in the 'thanks' list. ;)
08:09:27 <quicksilver> CosmicRay: really you should call it 'RealWorld#' Haskell
08:09:32 <earthy> anyway, there'd better be any content to reviw first. ;)
08:09:36 <LoganCapaldo> groan
08:09:44 <SamB_XP> I believe that the checks would work
08:09:45 <sjanssen> hahaha
08:09:57 <sjanssen> @remember quicksilver CosmicRay: really you should call it 'RealWorld#' Haskell
08:09:57 <lambdabot> Done.
08:10:01 <sjanssen> @flush
08:10:03 <SamB_XP> I think your bank might notice and ask you to stop if it started filling up their SQL databases
08:10:04 <CosmicRay> hehe
08:10:30 <SamB_XP> and any humans involved in the check-cashing process might ask you to stop sooner
08:10:40 <vegai> banks don't have advanced technology like SQL databases :P
08:10:53 <SamB_XP> vegai: well, whatever they use
08:10:55 <vegai> except really cool ones, like Credit Suisse :P
08:10:58 <SamB_XP> db2
08:11:08 <earthy> banks have mucho advanced technology
08:11:19 <earthy> however, it's *cheaper* for them to not use it, often
08:11:32 <earthy> so they stick to the old stuff that they've already paid for
08:11:40 <vegai> I remember a piece of news from a local bank a year ago, that they migrated from OS/2 to Windows
08:11:45 <SamB_XP> as long as they use something at least as reliable as what gmail uses to store your data
08:11:54 <SamB_XP> vegai: what in the world did they do that for?
08:12:04 <earthy> (one of the more interesting talks I've attended was from the developer of security systems for ING Direct)
08:12:09 <vegai> SamB_XP: I suppose OS/2 salesmen weren't around
08:12:17 <SamB_XP> oh.
08:12:18 <earthy> (his budget came from *marketing*...)
08:12:23 <vegai> SamB_XP: and why should they listen to anyone else but salesmen?
08:12:24 <SamB_XP> so they sold out to nifty doorways?
08:13:05 <quicksilver> most banks have just completed the process of migrating their cash machines from OS/2 to Win32
08:13:16 <quicksilver> although there are still a few OS/2 cash machine around in the UK
08:13:40 <earthy> quicksilver: I think virtually all cash machines in .nl are still OS/2
08:14:16 <earthy> some of the newer, smaller stand alone ones might not be though
08:14:25 <earthy> then again, I don't care what OS the machine runs, really
08:14:32 <earthy> nor should you
08:14:42 <earthy> there just shouldn't be any way to get at it at all
08:14:52 <dcoutts_> earthy: it worries me when I see a cash machine with the BSOD
08:15:06 <earthy> yah
08:15:15 <earthy> does it worry you to do online banking?
08:15:28 <dcoutts_> I never have done actually
08:15:32 <SamB_XP> what is online banking?
08:15:42 <sieni> SamB_XP: ?
08:15:44 <earthy> ever heard of ING direct at all? :)
08:15:47 <SamB_XP> is that where you take your MMO money and deposit it?
08:15:57 <sieni> SamB_XP: like paying bills and such
08:16:02 <lispy> i use my bank's website
08:16:04 <SamB_XP> ah.
08:16:10 <SamB_XP> I still live with my parents
08:16:23 * lispy shakes his old man cane at SamB_XP
08:16:25 <earthy> samb: that is where you take your browser to online bank statements and pay bills and deposit savings from your checking account and stuff
08:16:36 <SamB_XP> I do the bank statement things
08:16:48 <SamB_XP> but I haven't got a savings account yet
08:17:08 <earthy> start one
08:17:11 <earthy> not hard
08:17:23 <SamB_XP> or a job, really
08:17:37 <lispy> SamB_XP: college first! :)
08:17:45 <earthy> samb: you have money to spend, right?
08:17:45 <SamB_XP> I've done some work/study
08:17:52 <SamB_XP> earthy: a small amount
08:17:58 <earthy> then put some of it monthly into a savings account
08:17:58 <SamB_XP> I've blown a lot of it buying milk...
08:18:08 <earthy> just to get in the habit of doing so. ;)
08:18:11 <SamB_XP> oh, I don't get an allowance anymore
08:18:36 <earthy> doesn't matter. :)
08:18:50 <SamB_XP> I got some money from community college scholarships...
08:18:52 <earthy> it's all about forming habits. ;)
08:19:21 <lispy> :t [a] -> a -> [a]
08:19:23 <lambdabot> parse error on input `->'
08:19:29 <lispy> ?hoogle [a] -> a -> [a]
08:19:29 <lambdabot> List.intersperse :: a -> [a] -> [a]
08:19:29 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
08:19:29 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:19:39 <lispy> ?hoogle snoc
08:19:40 <lambdabot> No matches found
08:19:59 <lispy> so List doesn't have a quick little function to append an element?
08:20:17 <lispy> ?pl \x xs -> xs++[x]
08:20:17 <lambdabot> flip (++) . return
08:20:18 <quicksilver> ++
08:20:27 <quicksilver> (the answer to your question might be 'no')
08:20:32 <quicksilver> it depends what you mean by quick
08:20:51 <lispy> efficient would be nice, but already made is what i meant by quick
08:21:12 <quicksilver> ++[] is not very many characters :)
08:21:14 <lispy> i'm no stranger to using xs++[x], but i hoped there was a "better" way
08:21:41 <chrismbrown> whats wrong with xs ++ [x]? I use it all the time...!
08:21:42 <earthy> well, there's the standard trick of functionalizing lists
08:22:02 <earthy> so instead of [x] you use [x] -> [x]
08:22:06 <fasta> The compiler should do that trick.
08:22:37 <fasta> Those "tricks" make the difference beween a high-level language and a low-level.
08:22:37 <earthy> and then you can do list :: [x] -> [x],  element :: x,  list . (element :)
08:23:01 <mauke> or Data.Sequence
08:23:04 <earthy> fasta: this one really makes the code mean something entirely different.
08:23:16 <LoganCapaldo> I <3 that trick
08:23:19 <int-e> or you could build the list in reverse.
08:23:21 <fasta> earthy: I have used the trick
08:23:31 <fasta> earthy: I fully understand how it works.
08:23:38 <fasta> earthy: And still I don't agree.
08:23:50 <Philippa> it's the difference between high-level and low-level /code/
08:23:57 <earthy> fasta: then explain how you want the compiler to lift the ++ to . ?
08:24:07 <earthy> and to infer that it can do so automatically
08:24:08 <Philippa> sounds like a case for deforestation to me
08:24:48 <fasta> earthy: that would require some thought of my side and unfortunately I am already engaged in that process for something else. I would be highly surprised if it would be an incomputable function.
08:25:22 <fasta> Another thing why Haskell is "low-level": there are no monadic sum types.
08:25:36 <fasta> As ski_ pointed out yesterday.
08:25:38 <earthy> what do you mean?
08:25:49 <earthy> haven't been following that
08:25:55 <earthy> but don't coproducts fit the bill?
08:26:04 <lispy> what about msum?
08:26:07 <chitin> is it normal for groupBy to take over 70 seconds on a list that is only 10,000 elements big?
08:26:31 <sjanssen> chitin: word on the street is that groupBy is slow
08:26:33 <earthy> chitin: depends on your hardware. oh, and the type of the elements in the list and the implementation of the equality
08:26:35 <lispy> chitin: it could very well depend on the time to generate the list or the elemnts o the list
08:26:51 <chitin> lispy: generating the list is fast
08:27:25 <lispy> > groupBy (==) [1..10000]
08:27:26 <chitin> earthy: decent hardware, and the equality test is: groupBy (\(x,y) (x',y') -> x == x')
08:27:26 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17]...
08:28:01 <earthy> still depends on the type of the x
08:28:09 <earthy> and the cost of the equality
08:28:18 <earthy> but assuming that is cheap: shouldn't take too long
08:28:20 <chitin> list :: Integral a => a -> [(Int,a)]
08:28:27 <earthy> definitely not 70s
08:28:39 <int-e> chitin: how did you measure the time it takes to generate the list?
08:28:52 <int-e> chitin: did you really force all the elements of the list?
08:29:18 <fasta> earthy: I don't know all the terminology, but I do know that Haskell as it currently stands is not great for complicated code.
08:29:20 <chitin> int-e: that is GHCi time, what do you mean by force?
08:29:54 <fasta> earthy: but OTOH, most people would never write such complicated code.
08:29:54 <int-e> chitin: force = evaluate.
08:29:54 <Philippa> no? I've not found anything better for code I think of as complicated, except arguably a lisp
08:29:55 <quicksilver> chitin: haskell is a lazy language
08:29:59 <edwardk> fasta: i'm not sure i see the connection between a lack of monadic sum types and not being great for complicated code ;)
08:30:00 <earthy> fasta: then your definition of complicated differs a *lot* from mine. ;)
08:30:13 <quicksilver> chitin: the elements in your list may not have been evaluated yet
08:30:18 <edwardk> the biggest gripe i had about Haskell was fixed with the introduction of class and type families
08:30:20 <int-e> chitin: anyway, 70 seconds sounds a lot, but it's very hard to guess what's going on without seeing the code.
08:30:22 <quicksilver> chitin: until you force the matter by trying to group them
08:30:37 <quicksilver> chitin: also ghci is *slow* since optimisation is off
08:30:38 <bos> gug
08:30:43 <quicksilver> chitin: you should try compiling your code :)
08:30:56 <earthy> yeah, in ghci groupBy for 10000 elements may well take 70s
08:31:04 <chitin> quicksilver: when I do last $ list it is very quick
08:31:20 <edwardk> The only thing I have left that I really would want is the ability to have a decent polymorphic record syntax and, by duality, extensible variants (data types)
08:31:23 <earthy> chitin: but when you do last you don't have to fill out the tuples
08:31:27 <quicksilver> last will actually skip the calculation of all the elements except the last one :)
08:31:35 <lispy> chitin: make sure that ghci didn't get interrupted
08:31:41 <earthy> whereas with your groupBy you will. ;)
08:31:46 <Philippa> edwardk: that, and I'd like a high-power module system
08:31:51 <lispy> chitin: if you hit ctrl+c twice then sometimes the next thing you type won't get evaluated
08:32:12 <earthy> oh, extensible records would be lovely, yeah
08:32:14 <Philippa> I don't care if half of it desugars into classes if the semantics're still right, but I want functors
08:32:22 <lispy> chitin: so if you're still waiting on it, then that might be the problem :)
08:32:26 <fasta> earthy: Because of the lack of monadic sums, I need to lots of stuff either by hand or I need to generate the code. The moment when that happens the language isn't expressive enough.
08:32:32 <lispy> chitin: or, the list generator could be starved out
08:32:37 <chitin> earthy: is this true even if the generator is recursive?
08:32:37 <Philippa> fasta: what are you doing?
08:32:45 <lispy> chitin: maybe you requested 10000 elements but the list isn't that long?
08:32:48 <edwardk> philippa, yeah, though, i kinda think that Haskell views its type classes as its module system. Now that we have class-associated types, and all that you can actually implement all the things you couldn't implement before because of its lack
08:32:51 <Philippa> and why won't Template Haskell do, or does that count as code generation?
08:33:19 <fasta> Philippa: Template Haskell is underdocumented
08:33:28 <chitin> let numDistinct n = (length . nub . factors) n
08:33:28 <chitin> list n = zip (map numDistinct [1..n]) [1..n]
08:33:31 <Philippa> it's not so underdocumented I couldn't use it
08:33:54 <lispy> fasta: i agree that TH needs polish and could use additional improvements, but i wouldn't say haskell is incomplete simple because i needed some meta-programming
08:33:59 <fasta> Philippa: It should take a module and produce a new module with every function prefixed by a function g.
08:34:12 <earthy> fasta: sounds like you're either not understanding enough (which I doubt) or you're doing something way complex and would really want Generic Haskell or somesuch
08:34:38 <Philippa> fasta: bundle it all up into a record, write the obvious function on the record type
08:34:39 <Philippa> BTDT
08:34:45 <Philippa> built a stack of 'em, too
08:34:56 <Philippa> and tied the knot and produced something suitably useful with it
08:35:15 <fasta> BTDT?
08:35:17 <lispy> fasta: but, i would be interested to read about these monad sum types to find out what you feel is missing
08:35:21 <mauke> been there, done that
08:35:39 <Eelis> CosmicRay: does HSH have any support for command completion or prompt customization?
08:36:01 <fasta> http://pastebin.ca/502290 <- this illustrates a current "solution" to the problem
08:36:08 <quicksilver> Eelis: it's a DSL embedded in haskell, isn't it, not a true shell?
08:36:27 <Eelis> quicksilver: i don't know, but if it is then the answers must be "no" :)
08:36:48 <chrismbrown> Philippa: what is BTDT?
08:36:59 <Eelis> quicksilver: (which would disqualify it from being a serious bash replacement)
08:37:02 <quicksilver> chrismbrown: Been There Done That
08:37:06 <fasta> lispy: the problem is that if you have n operations defined on a monad M and you want a monad M+ST, you need to write n functions to lift those to M+ST.
08:37:06 <chrismbrown> ah ;)
08:37:12 <earthy> HSH is not a serious replacement for a shell
08:37:16 <quicksilver> Eelis: I think it's supposed to be a scripting language replacement, not an interactive shell replacement
08:37:19 <earthy> as it can't be used interactively
08:37:33 <earthy> which is a bit of apity
08:37:36 <Eelis> ah, i see. that explains it. kind of strange to call it "HSH" then. oh well, thanks
08:37:55 <fasta> Philippa: It would be nice if you could be somewhat more specific.
08:37:55 <Philippa> fasta: I'm still not comfortable that I've seen a good description of your problem...
08:38:05 <sjanssen> fasta: why didn't you make M a monad transformer in the first place?
08:38:14 <Philippa> fasta: okay, let's work in MLish terms for a moment, shall we?
08:38:18 <sjanssen> fasta: then your problem disappears
08:38:28 <malsyned> Anybody brushed up on the intricacies of structures in Haskell?  I've got a question I don't think I've seen addressed anywhere.
08:38:29 * earthy sees an attempt to do coproducts
08:38:49 <Philippa> so we have "signiatures" as types of modules, "structures" as concrete implementations and "functors" are something akin to functions on modules
08:38:59 <Philippa> you can encode modules thusly:
08:39:15 <Philippa> a signiature becomes a record, with each exported value having a corresponding field of appropriate type
08:39:16 * earthy points fasta to http://portal.acm.org/ft_gateway.cfm?id=581492&type=pdf&coll=GUIDE&dl=ACM
08:39:18 <Philippa> structures become obvious
08:39:20 <lambdabot> http://tinyurl.com/ypmlch
08:39:28 <Philippa> functors are just functions on appropriate signiature types
08:39:54 <Philippa> if you have your modules encoded that way, what you're looking to do is perhaps slightly tedious but nevertheless trivial
08:40:15 <Philippa> if you pick a smarter record encoding - one based on HList, say, you can probably write a "record map" function as well
08:40:33 <Philippa> earthy: is that (legitimately) available anywhere that doesn't charge?
08:40:34 <edwardk> http://citeseer.ist.psu.edu/751836.html talks to the view of haskell typeclasses as ML modules
08:40:36 <lambdabot> Title: Modular Type Classes - Dreyer, Harper, Chakravarty, Keller (ResearchIndex)
08:40:48 <fasta> Philippa: and what if I don't have my modules encoded in that way?
08:41:02 <malsyned> If I've got a type which can take on one of several record forms, and they have field names in common so that those field accessors can be used to reach into any of the several forms of the type, is there a way to do pattern matching that disregards the specific form if all I need is the sub-field?
08:41:15 <Philippa> fasta: then you're going to have to do /something/, because modules as they exist currently don't come with any operations beyond importing
08:41:26 <earthy> http://www.cs.le.ac.uk/people/nghani/papers/icfp02.ps.gz if that previous link didn't work
08:41:43 <sjanssen> malsyned: no, I don't think that is possible
08:41:54 <fasta> Philippa: essentially you are emulating higher-order modules.
08:42:00 <quicksilver> malsyned: you can do it with pattern guards
08:42:09 <malsyned> that may not have been entirely clear.  I mean to say, is there an alternative to the pattern-matching syntax "TheConstructor {theFieldIWant = nameToBindValueTo}" that doesn't require me to specify the constructor?
08:42:11 <quicksilver> malsyned: (which is a GHC extension)
08:42:23 <malsyned> quicksilver: I'm fine with ghc extensions.  where can I learn about pattern guards?
08:42:36 <fasta> Philippa: that's called a hack (or something which Haskell lacks)
08:42:36 <CosmicRay> Eelis: no, HSH does not really provide an interactive command line as such
08:42:49 <CosmicRay> Eelis: it is more designed for programs that may otherwise be written as shell scripts
08:42:52 <quicksilver> you'd write f x | nameToBindValueTo <- theFieldIWant x
08:42:58 <fasta> Philippa: Oleg wrote that you could fake it with type-classes too, IIRC.
08:43:05 <CosmicRay> so that you can have the convenience of calling awk, grep, while also having the convenience of map, filter, and exceptions
08:43:06 <quicksilver> malsyned: which uses the fact that 'theFieldIWant' is a selector function
08:43:12 <Eelis> CosmicRay: ok, fair enough. thanks
08:43:20 <bos> hi, CosmicRay
08:43:23 <CosmicRay> Eelis: if you want to use it interactively, you can do so from the ghci prompt, but it will probably be less efficient than just using a real shell
08:43:24 <malsyned> quicksilver: that looks like exactly what I want.  How do I separate multiple pattern guards?
08:43:25 <CosmicRay> hey bos
08:43:38 <quicksilver> malsyned: with more occurences of |
08:43:47 <bos> the old web server is busy this morning
08:43:51 <quicksilver> malsyned: just like a standard guard
08:44:00 <bos> about 5,000 hits to the book blog so far
08:44:08 <Philippa> fasta: there're many encodings, yes. I don't see how what you're asking for makes life significantly easier though, surely what you're after is first class modules and a sufficiently powerful notion of 'map'?
08:44:14 <malsyned> quicksilver: hot.  thanks.
08:44:19 <sjanssen> malsyned: realize that pattern will always match.  This is dangerous if you have constructors for which theFieldIWant is not defined
08:44:24 <quicksilver> malsyned: you can write, for example, f x | Just n <- theField x = .... \n | Nothing <- theField x = ....
08:44:33 <quicksilver> malsyned: if you want to constructor-match inside the field
08:44:36 <CosmicRay> bos: wow
08:44:41 <fasta> Philippa: you mean "map" over modules?
08:44:44 <fasta> Philippa: yes, that would be nice.
08:44:57 <quicksilver> malsyned: what sjanssen said, too :)
08:45:20 <malsyned> interesting.  I'll see if that will work.  thanks guys.
08:45:52 <fasta> Philippa: Ok, so in my own words: make a record type holding all functions in a module. Make the record type an instance of fmap. Done.
08:45:59 <sjanssen> fasta: in your example, is there any reason you didn't start with a monad transformer?
08:46:04 <lispy> quicksilver: oh, re: project euler #12, i could use a binary search on the number of divisors huh?
08:46:14 <lispy> quicksilver: that might speed it up a bunch, ya think?
08:46:28 <Philippa> fasta: nearly. I don't think fmap has the right flavour of polymorphism though
08:47:06 <fasta> sjanssen: In M there is already a lot of code written, but another reason is that I haven't written any monad transformer myself yet and it wasn't suggested by ski_ (which I would have assumed they would have done otherwise).
08:47:44 <fasta> sjanssen: Monad M is isomorphic to the one in the paste.
08:48:10 <fasta> Philippa: it would need an higher-rank?
08:49:03 <Philippa> fasta: ...hmm. That might do it. I'm having a slow day today, build your record encoding and then ask someone to help you find an appropriate type for the map-like that preserves the right info?
08:49:30 <quicksilver> lispy: that wouldn't guarantee you to find the first one with more than 500
08:49:32 <malsyned> quicksilver, sjanssen: there's no way to do it where the pattern doesn't always match, huh?
08:50:07 <fasta> Philippa: ok, I guess I can manage to that by myself, but I don't know whether it means that I need to change the other existing code too.
08:50:15 <fasta> Philippa: I think I do, and that means it isn't a solution now.
08:50:17 <lispy> quicksilver: but, i could cut the search space down quite a bit
08:50:33 <chitin> does anyone know where the mailing list regarding different implementations of prime generating algorithms is?
08:50:43 <lispy> quicksilver: as i understand it, counting the divisors (naively) is really slow, so i want to test as few numbers as possible
08:50:44 <hpaste>  sjanssen pasted "refactor to a transformer" at http://hpaste.org/13
08:50:52 <sjanssen> fasta: http://hpaste.org/13
08:51:00 <sjanssen> malsyned: no way that I'm aware of
08:51:06 <fasta> sjanssen: I saw it, thanks. I hope that solves it.
08:51:24 <sjanssen> fasta: you still have to lift ST actions though
08:51:48 <quicksilver> lispy: I think it's more profitable to think about how to make your divisor counting faster
08:51:58 <sjanssen> fasta: you can make that a bit less painful by writing a MonadST module (see MonadIO for an example)
08:52:18 <fasta> sjanssen: you changed M
08:52:22 <lispy> quicksilver: okay, i'll go think about that.  Thanks.  Enough hints for now though :)
08:52:33 <fasta> sjanssen: M is the monad in which I have written lots of code already
08:52:59 <fasta> sjanssen: I already am using MonadST
08:53:59 <fasta> sjanssen: are you sure the changes I would have to make to the existing code using M would be minimal?
08:54:30 <sjanssen> fasta: you'll probably have to change all the type signatures (because the kind of M has changed)
08:54:51 <fasta> sjanssen: ok, I don't use type signaturen, so I would be fine.
08:54:54 <sjanssen> but you could probably achieve that with a really complicated regex :)
08:54:56 <fasta> signatures*
08:55:10 <sjanssen> in that case, there's a good chance it will just work
08:55:20 <fasta> Type signatures that are 10 lines long have no meaning to me anymore.
08:55:37 <fasta> I.e. writing them down is more work than writing the function.
08:55:48 <sjanssen> I suspect you have more problems if your type signatures are 10 lines long :P
08:56:00 <fasta> sjanssen: I am writing highly non-trivial code.
08:56:05 <sjanssen> are you doing some cunning class/type-level programming?
08:56:37 <fasta> sjanssen: no, but I use type classes to make interesting points in the data structure open for customization.
08:57:01 <lispy> fasta: can i ask what domain your writing code for?
08:57:08 <lispy> (ie, what type of task)
08:57:16 <fasta> lispy: academic domain
08:57:47 <fasta> lispy: It's a data structure to speed up a graph theoretical problem.
08:57:56 <lispy> ah, cool
08:58:05 <fasta> Unfortunately, nobody implemented it in the last 20 years.
08:58:14 <fasta> I understand why that is, though.
08:58:28 <fasta> It's because it's not documented precisely.
08:58:33 <fasta> (what else is new)
08:59:01 <lispy> heh, yeah
08:59:20 <fasta> Lots of references to the article, but I doubt anyone actually understands why it works.
08:59:24 * lispy should run to work
08:59:28 <fasta> They just see it as a "black box".
08:59:33 <lispy> i hate that
08:59:44 <lispy> in academia especially it's frustrating
09:00:07 <lispy> "Well, it was peer reviewed, confuses me...so i'll just cite it and move on."
09:00:23 <fasta> Peer-review means little to me.
09:00:34 <fasta> Most articles contain logic mistakes.
09:00:49 <Apocalisp> what is "It's a data structure to speed up a graph theoretical problem." ?
09:01:07 <Apocalisp> s-trees?
09:01:26 <shapr> fasta: Yeah, sounds nifty, what is it?
09:01:27 <fasta> A few papers from the 70's I read were correct, but it seems education dropped after that.
09:01:43 <shapr> Any problems with hpaste since it got restarted yesterday?
09:01:56 <fasta> shapr: I implemented a dynamic path data structure, but I can easily extend it to a dynamic tree structure.
09:01:56 <Apocalisp> Maybe because relational theory largely replaced graph theory as a database design paradigm.
09:02:32 <fasta> Try that data structure if you want to test your programming skills and not some stupid toy problem like the reddit crowd likes so much.
09:02:50 <Apocalisp> What's the data structure?
09:03:01 <fasta> Apocalisp: I just said to shapr
09:04:00 <Apocalisp> Can you elaborate?
09:04:03 <shapr> fasta: That description doesn't tell me much, can you say more?
09:04:21 <fasta> @google dynamic trees sleator tarjan
09:04:28 <lambdabot> http://portal.acm.org/citation.cfm?id=3835
09:04:28 <lambdabot> Title: Self-adjusting binary search trees
09:04:40 <lispy> shapr: i haven't seen any problems with hpaste, but is cheese still the topic?
09:04:43 * lispy &
09:04:56 <Apocalisp> Splay tree? Why didn't you say so?
09:05:09 <shapr> lispy: Probably not
09:05:20 <fasta> Apocalisp: it's not just a splay tree, it's a splay tree with a lot of bells and whistles.
09:05:32 <shapr> lispy: You've got the power to fix it!
09:05:38 <fasta> Apocalisp: especially for what I am applying it for.
09:05:52 <lispy> shapr: fix? nah, just teasing you
09:05:52 <fasta> Apocalisp: if you know an implementation in any language, tell me.
09:06:04 <kolektiv> hi all - i'm trying to make a choice between languages for a personal project, and am evaluating a few
09:06:09 <fasta> Apocalisp: there are none, AFAIK, that implement dynamic trees.
09:06:11 <shapr> lispy: You have the access level, it is your choice!
09:06:18 <malsyned> quicksilver: Is there a way to do more than one pattern guard with the same RHS of the expression?
09:06:25 <fasta> Apocalisp: you make it sound as if it's trivial.
09:06:27 <shapr> kolektiv: What sort of project is it?
09:06:36 <kolektiv> does anyone know of any development efforts in haskell toward a db/storage system comparable to mnesia (erlang)?
09:06:42 <desp> hmm
09:06:58 <fasta> Apocalisp: I suspect unless you are called Sleator or Tarjan that you don't have a clue of how or why it works.
09:07:00 <shapr> kolektiv: It's been discussed several times on #haskell, but no one has done anything about it.
09:07:05 <desp> the Awkward Squad paper describes several concurrent communication functions
09:07:05 <kolektiv> shapr - commerce - high performance cataloguing and searching
09:07:13 <quicksilver> malsyned: well not without copying it, no
09:07:22 <desp> including readMVar, which is defined as takeMVar and putMVar in a sequence
09:07:22 <shapr> fasta: Well, tell us what it is so we can read about it. Do you have any references.
09:07:25 <quicksilver> malsyned: or = answer .... and then 'where answer = ' later
09:07:30 <desp> but isn't that a race condition?
09:07:34 <kolektiv> shapr - yeah, i saw a couple of posts while looking on nabble, but it never seems to have gone anywhere
09:07:36 <malsyned> quicksilver: commas in place of pipes seems to parse, but I can't tell if it's doing the right thing.
09:07:43 <desp> ?code readMVar
09:07:43 <lambdabot> Maybe you meant: more todo vote
09:07:50 <desp> ?show readMVar
09:07:50 <lambdabot> "readMVar"
09:07:54 <desp> ehh.
09:07:58 <fasta> shapr: I just did a google query for you in this channel.
09:08:02 <desp> ?source readMVar
09:08:02 <lambdabot> readMVar not available
09:08:02 <fasta> shapr: scroll up
09:08:04 <sjanssen> desp: no, because takeMVar removes the value
09:08:09 <quicksilver> malsyned: oh, that's news to me :) maybe it does
09:08:18 <quicksilver> malsyned: test it before you believe it, though
09:08:23 <sjanssen> desp: oh, I suppose another program could putMVar it
09:08:30 <Apocalisp> fasta: Audiogalaxy indexed their database using a distributed splay tree. I wouldn't say it's trivial, but it's nothing arcane.
09:08:41 <desp> sjanssen: but what if another process calls putMVar right between our takeMVar/putMVar?
09:08:57 <fasta> Apocalisp: dynamic trees are more complicated than splay trees.
09:08:58 <malsyned> I mean to say, replace "f (TheConstructor {field1 = var1, field2 = var2}) = RHS" with "f x | var1 <- field1 x, var2 <- field2 x = RHS"
09:08:59 <desp> then readMVar will block, possibly indefinitely
09:09:03 <desp> and return a stale value
09:09:06 <shapr> kolektiv: It wouldn't be difficult to implement something like mnesia, but it would require one or two libraries that don't exist yet.
09:09:06 <malsyned> it certainly does /something/
09:09:11 <desp> that's what I meant
09:09:28 <kolektiv> shapr - hmmm - where would you say the gaps were in the ecosystem?
09:09:34 <fasta> Apocalisp: and I am not sure how making it distributed would make it much more complicated.
09:09:40 <desp> @hoogle readMVwar
09:09:43 <desp> @hoogle readMVar
09:09:44 <lambdabot> No matches found
09:09:44 <quicksilver> malsyned: I'd expect that to bind both
09:09:45 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
09:09:53 <kolektiv> shapr - out of interest, my possible languages are erlang, haskell, ocaml, or a lisp - all have pros/cons
09:09:58 <fasta> Apocalisp: (in the same way as going to a dynamic tree)
09:10:00 <desp> ?source Control.Concurrent.MVar.readMVar
09:10:01 <lambdabot> Control.Concurrent.MVar.readMVar not available
09:10:03 <desp> argh
09:10:05 <Apocalisp> fasta: the goal was not to make it complicated.
09:10:10 <fasta> Apocalisp: but if you think it's easy, just implement it.
09:10:23 <malsyned> quicksilver: me too.
09:10:44 <malsyned> that's what I want.  I want to bind multiple variables based on certain fields of the item, and regardless of which specific constructor was used to create the item.
09:11:01 <shapr> kolektiv: Yeah, I agree. Each choice has its strong points. Have you written up what's good for *you* about each choice?
09:11:28 <kolektiv> shapr - yeah i have a short list of pluses and minuses for each, including how much i "like" them
09:11:28 <Apocalisp> fasta: Are you saying that there aren't any implementation of splay trees?
09:11:49 <Apocalisp> fasta: ...or just not the bells & whistles kind?
09:12:01 <fasta> Apocalisp: I am saying there are no implementations of dynamic trees.
09:12:08 <shapr> kolektiv: That's the approach I'd suggest. Figure out what features you like/dislike, and then go with your overall "like" score.
09:12:10 <fasta> Apocalisp: LEDA has one, but they don't do it correctly.
09:12:13 <kolektiv> shapr - on the other hand, some seem to have a few killer apps if you like - for erlang it's mnesia, for ocaml it's a mixed mode and speed, for lisp various things...
09:12:16 <Apocalisp> What's the difference between a dynamic tree and a splay tree?
09:12:22 <geezusfreeek> kolektiv: of those four, i think ocaml is least eye-opening... i would tie haskell and lisp as most eye-opening i think
09:12:29 <fasta> Apocalisp: read the article
09:12:55 <fasta> Apocalisp: ask your next question when you are done implementing it.
09:12:57 <kolektiv> geezusfreeek: yeah i'd agree - i've done some coding in all of them - probably least in ocaml, most in lisp (scheme)
09:13:03 <shapr> fasta: be nice
09:13:56 <desp> @hoogle block
09:13:57 <lambdabot> Control.Exception.block :: IO a -> IO a
09:13:57 <lambdabot> Text.Html.blockquote :: Html -> Html
09:13:57 <lambdabot> Text.Html.BlockTable :: module
09:13:58 <kolektiv> my other considerations are language future - haskell has a bright future i think once pH etc. starts filtering back to general dev
09:14:16 <Apocalisp> A quick google search returns lots of splay tree implementations in various languages. What am I missing?
09:14:19 <shapr> kolektiv: I don't think pH will ever filter back to the general community.
09:14:42 <shapr> kolektiv: Are you "ncm" from lwn.net? :-)
09:14:43 <kolektiv> shapr - not directly maybe, but as developments to the future of ghc, etc. it'll probably have some effect
09:14:55 <kolektiv> shapr - nope - why do you ask? :)
09:14:57 <timlarson_> pH?
09:15:02 <sjanssen> desp: I can indeed cause deadlock with readMVar
09:15:04 <sjanssen> desp: scary!
09:15:21 <shapr> kolektiv: What sort of pH facets do you think would positively affect ghc?
09:15:22 <quicksilver> Apocalisp: you're missing what 'dynamic' means
09:15:29 <quicksilver> Apocalisp: apparently that's secret, though, and fasta wont' tell us
09:15:38 <quicksilver> Apocalisp: so, I guess we'll never know
09:15:43 <fasta> quicksilver: no, that's not a secret/
09:15:57 <geezusfreeek> will/do arrows ever compile with some pretty parallelization? if so, i'd say that's probably enough to do some nice concurrent programming in haskell
09:16:00 <Apocalisp> I see. To those who know, no explanation is necessary and to those who don't, no explanation is possible?
09:16:03 <fasta> Anyone determined to know can easily look it up.
09:16:21 <kolektiv> shapr - well, it's more that work is being done in relatively novel parallelization techniques - parallelism, distributed systems etc. are the future
09:16:35 <shapr> fasta: Well, you brought it up, so I thought you'd be able to give out urls in support of what you say.
09:16:49 <kolektiv> shapr - at the moment i would have the feeling that haskell is not particularly strong on many core/distributed systems
09:16:52 <shapr> kolektiv: Oh, I agree with that.
09:17:09 <desp> sjanssen: should I report that somewhere? :)
09:17:20 <quicksilver> geezusfreeek: no, but that's certainly a topic lots of people are interested in
09:17:24 <shapr> But so far I've only seen nested data parallelism as a viable approach. What other approaches do you think will work out well?
09:17:31 <quicksilver> sjanssen: isn't that just a "don't do that, then'?
09:17:43 <hpaste>  sjanssen pasted "deadlocking program" at http://hpaste.org/14
09:17:47 <quicksilver> sjanssen: it's not a bug in the primitives, it's just that those are not inherently safe primitives, you need to know how to use them
09:17:55 <quicksilver> sjanssen: or do I misunderstand?
09:17:58 <Philippa> geezusfreeek: there're certainly some arrows that could be compiled that way, I imagine in a few years someone'll sit down with a pile of primitives and bash out some fun rewrite rules for a few arrow types
09:18:13 <kolektiv> annoyingly i was going to be going to the london haskell meeting tonight where NDP was going to be the discussion!
09:18:24 <sjanssen> quicksilver: true.  This really should be documented, though
09:18:25 <fasta> I don't see why http://www.cs.cmu.edu/~sleator/papers/Dynamic-Trees.htm is hard to find.
09:18:25 <shapr> kolektiv: But now you'll miss it?
09:18:26 <lambdabot> Title: Dynamic Trees
09:18:36 <kaol> where can I read about when to use seq?
09:18:39 <quicksilver> sjanssen: yes, it should
09:18:41 <Philippa> if I'd known my housemate wasn't actually moving 'til tomorrow I might've gone to the HUG meeting
09:18:55 <kolektiv> shapr - yeah annoyingly so - had to go elsewhere on business - was looking forward to some interesting chat and a few beers!
09:19:06 <fasta> Apocalisp, quicksilver, shapr: seen that?
09:19:06 <Apocalisp> fasta: That wasn't so hard, was it?
09:19:24 <fasta> Apocalisp: not for me, but I don't see why I need to do the work, if you are interested.
09:19:32 <shapr> fasta: dude, be nice.
09:19:34 <kaol> I'm thinking that laziness is blowing the stack in my code...
09:19:41 <Apocalisp> grumpy gus
09:20:10 <geezusfreeek> Philippa: i was thinking more along the lines of a special arrow type, like the IO monad... or maybe even a generalization of the IO monad into an arrow (and followed by creating a new IO monad directly out of the arrow to support the old way of doing IO)
09:20:21 <sjanssen> desp: yeah, you should definitely mention this somewhere.  Either haskell-libraries@ or GHC's trac
09:20:27 <quicksilver> fasta: our motivation for understanding the dynamic trees was to understand your area of application. Because we were interested in the problems you were having with haskell.
09:20:36 <geezusfreeek> though i am still somewhat new to all this, so i might be making things up to fit my mental model
09:20:44 <Philippa> geezusfreeek: that's not necessarily as useful as it sounds
09:20:46 <kolektiv> i hope they don't wait too long until the next london hug meet
09:20:49 <quicksilver> fasta: it doesn't therefore seem that unreasonable to ask you questions about it. If you're too busy to answer, you might just say so.
09:20:56 <Philippa> mostly because you can't easily 'partition' the theoretical World type
09:21:12 <sjanssen> @karma stm
09:21:12 <lambdabot> stm has a karma of 0
09:21:15 <kaol> @src seq
09:21:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:21:16 <Saizan> kaol: the first step is to profile your application to find the culprit
09:21:41 <hpaste>  sjanssen annotated "deadlocking program" with "STM++ version doesn't deadlock" at http://hpaste.org/14#a1
09:21:45 <kaol> that applies to any situation and language...
09:21:49 <sjanssen> @karma STM
09:21:49 <lambdabot> STM has a karma of 1
09:22:13 <quicksilver> kaol: seq is primitive, it can't be expressed in haskell
09:22:25 <fasta> quicksilver: well, I think it was quite clear that I am quite busy. In fact I should not participate for some time here (for your follow up question: "then what are you doing on IRC?")
09:22:29 <desp> STM++
09:23:10 <Philippa> fasta: you were unnecessarily snappy with people who asked you for info. "Sorry, busy, another time" would have done fine
09:23:16 <shapr> Yeah
09:23:29 <malsyned> is there a shortcut to "slicing" an arbitrary argument to a function?  like, some idiomatic way of writing (\x y z -> foo x y z 3)?
09:23:30 <kaol> > 1 `seq` 2
09:23:31 <lambdabot>  2
09:23:53 <dmhouse> malsyned: pretty much what you've written.
09:23:58 <quicksilver> malsyned: that's the best way
09:24:09 <Saizan> ?pl (\x y z -> foo x y z 3)
09:24:09 <lambdabot> flip flip 3 . (flip .) . foo
09:24:10 <quicksilver> malsyned: unless you like incomprehensive compositions of flips
09:24:19 <Saizan> :D
09:24:21 <quicksilver> s/ve/ble/
09:24:28 <geezusfreeek> i like lambdabot's solution :D
09:24:31 <malsyned> quicksilver: Yeah, I prefer writing out the lambda, if those are my choices ;)
09:24:35 <kpreid> flip3 = \f a x y z -> f x y z a
09:24:40 <kpreid> er
09:24:45 <kpreid> flip3 f a x y z = f x y z a
09:24:54 <kaol> could someone please give an example of how seq is used?
09:24:54 <quicksilver> kpreid: I'd rather call that rot3, or something
09:25:10 <Saizan> ?src foldl'
09:25:10 <lambdabot> foldl' f a []     = a
09:25:10 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:25:14 <kpreid> @src foldl'
09:25:14 <lambdabot> foldl' f a []     = a
09:25:14 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:25:16 <sjanssen> > last [1..] `seq` "impossible!"
09:25:21 <shapr> fasta gets on my nerves.
09:25:22 <ptolomy> sjanssen: What does that forever STM program output on your machine? on win32, it's just a lot of '0'.
09:25:23 <lambdabot> Terminated
09:25:28 <chitin> does haskell do it's own memoization?
09:25:29 <malsyned> It'd be cool if you could use something like pattern syntax.  (foo _ _ _ 3) or so.
09:25:30 <quicksilver> kaol: let m = somethign slow to compute in m `seq` (m,rest)
09:25:35 <Apocalisp> I thought tosser's night is NEXT wednesday.
09:25:38 <shapr> fasta is smart, and knowledgable, but I wish he were more respectful of others.
09:25:40 <malsyned> as far as I know, that's not legal syntax for anything at the moment.
09:25:42 <sjanssen> ptolomy: yes, infinite stream of 0.  That's the output we want
09:25:54 <ptolomy> Ok.
09:25:58 <shapr> chitin: It can do memoization, but it doesn't do it by default.
09:26:15 <quicksilver> kaol: ensures 'm' is evaluated to WHNF at the same time the tuple is
09:26:25 <kolektiv> shapr - going back to an earlier point, where do you think the gaps in haskell are which would need filling before mnesia-type work was possible? if you've got a moment, i'm interested in your thoughts :)
09:26:27 <sjanssen> kaol: seq a b means reveal the first constructor of a before returning b
09:26:27 <quicksilver> malsyned: I think that sometimes
09:26:37 <quicksilver> malsyned: but then you need some way of specifying which _ is which
09:26:41 <quicksilver> malsyned: so you give them names
09:26:43 <chitin> shapr: so if I had: foo n = filter (`divides` n) (takeWhile (< n-1) primes') --it  would calculate primes' every time I do foo n?
09:26:45 <elrodeo> @src mod
09:26:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:26:46 <quicksilver> malsyned: and *bang* that's lamba notation :)
09:27:00 <elrodeo> @src Prelude.mod
09:27:01 <lambdabot> Source not found. My mind is going. I can feel it.
09:27:08 <quicksilver> chitin: no, probably not
09:27:19 <quicksilver> chitin: not if primes' is monomorphic, at least
09:27:37 <elrodeo> hm.. what is wrong with mod?
09:27:43 <quicksilver> chitin: A definition which takes no arguments (like primes') is called a CAF
09:27:52 <quicksilver> chitin: they are only evaluated once, as long as they are monomorphic
09:27:54 <shapr> kolektiv: mnesia handles Erlang-native values. To do the same thing in Haskell would either require that you only use instances of Data.Typeable, or that you have some way of migrating or dynamically loading types.
09:28:07 <chitin> quicksilver: but it is an infinite list
09:28:09 <shapr> kolektiv: hs-plugins might be able to do that, but I don't know for sure.
09:28:13 <quicksilver> chitin: that doesn't matter
09:28:25 <quicksilver> chitin: only part of it ends up evaluated :)
09:28:29 <quicksilver> chitin: the bit you actually use
09:28:36 <kolektiv> shapr - mmm i see (i think) - i might do a bit of investigation
09:28:38 <quicksilver> chitin: but that part isn't calculated more than once
09:28:55 <desp> elrodeo: isn't it a primitive?
09:29:28 <shapr> kolektiv: Other than that, I think Haskell is ready for an mnesia-style system.
09:29:29 <chitin> quicksilver: so if I do foo n say a million times, haskell will know to take a million primes' from the start?
09:29:44 <quicksilver> chitin: it keeps doing more as it goes along
09:29:51 <kaol> hah. that did it. the code ran in 10 seconds now, where it used to use a minute and a half before running out of stack
09:29:54 <desp> any good documents about STM?
09:29:56 <quicksilver> chitin: so at the beginning, primes' is just a big cloud of code
09:30:04 <kolektiv> shapr - it would be a popular development i think
09:30:06 <quicksilver> chitin: each time you try to access elements, they get calculated
09:30:12 <shapr> kolektiv: I agree. I'd use it!
09:30:15 <sjanssen> desp: check simonpj's homepage
09:30:29 <quicksilver> chitin: but the 'tail' of the list remains a chunk of code
09:30:35 <elrodeo> desp: what is a primitive?
09:30:41 <desp> sjanssen: thanks
09:30:42 <chitin> quicksilver: is there a way I can make all of primes' be calculated at the beginning and stored into memory for use?
09:30:42 <sjanssen> desp: something with 'composable' in the title
09:30:49 <DRMacIver> Speaking of SPJ, T-1 hour to London-HUG.
09:30:50 <quicksilver> kolektiv, shapr: there are hard problems with different versions of types, perhaps
09:31:10 <quicksilver> chitin: 'all'? it's infinite!
09:31:13 <kaol> I'm still not quite clear on why seq takes two parameters... Does it just throw away the first one?
09:31:16 <quicksilver> chitin: how much memory to you have?
09:31:20 <thorkilnaur> desp, http://research.microsoft.com/~simonpj/papers/stm/
09:31:21 <lambdabot> Title: Papers on transactional memory
09:31:25 <desp> elrodeo: I'd thing mod, as a fundamental mathematic function, is not expressed in Haskell, but instead in a lower-level language
09:31:29 <desp> s/thing/think/
09:31:33 <quicksilver> kaol: algebraic it throws it away, but it makes sure it's evaluated first
09:31:35 <desp> thorkilnaur: thanks
09:31:35 <chitin> quicksilver: heh, I mean a subset of the list, say half a million primes
09:31:38 <kolektiv> quicksilver - that applies to most comparable systems though - they either don't really do it, or require schemas for storage to be distinct, etc.
09:31:38 <shapr> quicksilver: True that. You'd probably need Erlang-style hot-loading.
09:31:51 <quicksilver> chitin: you could do it, yes
09:31:57 <quicksilver> chitin: there is no reason to that I can think of, though
09:32:04 <shapr> In any case, a Haskell implementation of mnesia would be very nifty.
09:32:08 <quicksilver> agreed
09:32:08 <kaol> I used () `seq` sequence_ ... myself, all in the IO monad
09:32:24 <kolektiv> quicksilver: though yes erlang can at least get plain records back, though to use them nicely you want the original record type somewhere
09:32:48 <sjanssen> kaol: it's the second parameter that is the real dummy.  Because Haskell is lazy, we have to depend (by pattern matching, calling seq again, etc.) on the return of seq to make sure the evaluation actually happens
09:32:54 <chitin> quicksilver: actually, come to think of it, it would make more sense if I used primes' as an IntSet
09:33:05 <elrodeo> desp, ah ok... thanks!
09:33:41 <dcoutts_> kaol: () `seq` sequence_ blah = sequence_ blah
09:33:42 <quicksilver> chitin: that's quite a bit faster if you want to test for membership, yes :)
09:34:01 <kaol> @type seq
09:34:10 <lambdabot> forall a t. a -> t -> t
09:34:19 <dcoutts_> kaol: forcing () to whnf is a noop since () is already in whnf
09:34:51 <chitin> why is there no take equivalent in Data.IntSet?
09:35:15 <kaol> dcoutts_: but using seq did certainly affect the space and time usage
09:35:35 <dcoutts_> kaol: well it wasn't that little example then
09:35:42 <shapr> Was it dons that combined QuickCheck and HUnit?
09:36:34 <quicksilver> chitin: IntSet is not really optimised for producing the elements in order
09:36:47 <quicksilver> chitin: it's optimised for union, fast membership check, and so on
09:37:00 <dcoutts_> kaol: was that the only seq you added that made the difference, perhaps you had some other use of seq elsewhere that made the difference
09:37:10 <chitin> quicksilver: I see. Thanks for your help.
09:37:11 <dcoutts_> kaol: do you see what I mean about seq () a = a  ?
09:37:17 <bringert_> why is this #cheese?
09:37:21 <bringert_> re topic
09:37:27 <quicksilver> I blame shapr
09:37:29 <quicksilver> @get-shapr
09:37:30 <lambdabot> shapr!!
09:37:58 <jcreigh> dons++
09:38:00 <jcreigh> bos++
09:38:08 <kaol> but that's all I did...
09:38:10 <jcreigh> "Real World Haskell". Very cool.
09:38:30 <quicksilver> CosmicRay++ # discrimination!
09:38:39 <kaol> and I still fail to see what's the use of the first parameter
09:39:10 <quicksilver> kaol: the first parameter is forced to WHNF
09:39:56 <shapr> quicksilver: you screamt?
09:40:08 --- mode: ChanServ set +o shapr
09:40:13 --- topic: set to '["The Haskell programming language: because forall e1 e2. e1 -> v1 && e2 -> v2 => (e1,e2) -> (v1,v2)","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by shapr
09:40:19 <shapr> Ok, no more #cheese !
09:40:19 <quicksilver> shapr: :)
09:40:24 --- mode: shapr set -o shapr
09:41:19 <Igloo> kaol: Have you got a (preferably small) example?
09:42:18 <kaol> well... the code I have is 40 lines long. Is that small?
09:42:51 <Igloo> That should do
09:43:37 <kaol> and there are some DB queries and I'd have to replace them with something if you'd like to run the example too
09:43:50 <Igloo> Yes please
09:45:00 <hpaste>  kaol pasted "(no title)" at http://hpaste.org/15
09:45:56 <kaol> not the clearest code, I'm afraid.
09:50:32 <kolmodin> kaol: on another subject... instead of: "sequence_ $ map (\x -> do much much code) list"    you could try: "forM_ list $ \x -> do the code"
09:52:57 <kaol> ok. I'm using the things that I remember from Prelude primarily, so far. I've still a lot to learn. :-)
09:53:13 <kolmodin> sure :)
09:53:13 <kaol> @type forM_
09:53:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
09:54:08 <kaol> ah. got it. that's handy for golf. ;-)
09:55:27 <kolmodin> aye :) mapM_ with flipped arguments
09:56:25 <mauke> is there a way to use the FFI from the command line?
09:56:50 <Igloo> kaol: It's hard to be sure due to alpha renaming, but it looks to me like the core is identical with and without the () `seq`
09:58:15 <Igloo> Oh, hang on
09:59:29 <Igloo> No, that's not true
09:59:33 <chessguy> @src forM_
09:59:33 <lambdabot> forM_ = flip mapM_
09:59:54 <kaol> oh. I tried the same code, now compiling with -O. I got 1.6 seconds that way, with or without seq.
10:00:05 <Igloo> Oh, doh, I wasn't using -O either
10:00:39 <kaol> @src mapM_
10:00:40 <lambdabot> mapM_ f as = sequence_ (map f as)
10:00:40 * Igloo slaps himself with a kipper and disappears for food
10:01:29 <chessguy> kaol: were you expecting flip forM_ ? :)
10:02:54 <kaol> there would have been some beautiful symmetry in it if it would have been so
10:03:21 <kaol> who cares if it would've been equal to _|_?
10:03:31 <chessguy> yes, there's great symmetry in uselessness :)
10:05:11 <kaol> I must be doing something silly if I do stuff like do ...; return ()
10:06:13 <lispy> ?pl do return ()
10:06:13 <lambdabot> do return
10:06:31 <kaol> @type do return
10:06:37 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:06:43 <kaol> @type do return ()
10:06:45 <lambdabot> forall (t :: * -> *). (Monad t) => t ()
10:06:53 <lispy> do return is redundant
10:06:58 <lispy> should just be return
10:07:11 <lispy> :t return
10:07:13 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:08:04 * kaol threw away his return (), still compiles
10:09:34 <chessguy> i have a dumb question
10:10:01 <chessguy> can a page like http://haskell.org/ghc/docs/latest/html/libraries/ be produced by Haddock, or just pages like http://haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
10:10:30 <chessguy> (i.e. the module hierarchy, or just individual module descriptions)
10:12:24 <ndm> chessguy: all can be produced by haddock
10:13:36 <chessguy> wow, nice
10:15:55 <quicksilver> lispy: indeed do is redundant with any single-statement expression
10:16:07 <quicksilver> lispy: the sugar in do is how it combines multiple expressions
10:16:17 <quicksilver> statement
10:16:20 <quicksilver> s
10:16:20 <quicksilver> :)
10:17:37 <SamB_XP> > do 1
10:17:41 <lambdabot>   add an instance declaration for (Num (t t1))
10:17:41 <lambdabot>     In the expression: 1
10:17:41 <lambdabot>     I...
10:17:52 <kaol> > do "hello"
10:17:53 <lambdabot>  "hello"
10:18:01 <SamB_XP> quicksilver: apparantly do actually affects type checking!
10:18:50 <SamB_XP> (effects?)
10:18:57 <allbery_b> affects
10:19:03 <quicksilver> SamB_XP: the expression has to be monadic
10:19:12 <quicksilver> SamB_XP: "hello" is in a monad, but '1' isn't...
10:19:20 <SamB_XP> seems kinda heavyweight
10:19:28 <quicksilver> ?
10:19:35 <kaol> > do "12"; "hello"
10:19:37 <lambdabot>  "hellohello"
10:19:56 <SamB_XP> well, can you desugar "do 1"?
10:20:33 <quicksilver> I see your point
10:20:39 <kaol> > do []; "hello"
10:20:40 <lambdabot>  ""
10:20:44 <SamB_XP> someone translated the haskell report into japanese?
10:20:48 <quicksilver> yes, do adds a Monad m constraint, effectively
10:21:14 <quicksilver> > do "iam"; "clever"
10:21:16 <quicksilver> :P
10:21:16 <lambdabot>  "clevercleverclever"
10:21:51 <kaol> > [1..]; "hello"
10:21:51 <lambdabot>  Parse error
10:22:08 <kaol> > do [1..]; "hello"
10:22:10 <lambdabot>  "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohello...
10:22:21 <LoganCapaldo> monads are silly
10:22:36 <Japsu> no, they are warm and fuzzy
10:22:38 <Japsu> by definition
10:22:52 <kaol> they're nuclear waste containers
10:22:55 <LoganCapaldo> > [1..] >> "hello"
10:22:55 <opqdonut> Mui. Japsu
10:22:56 <lambdabot>  "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohello...
10:22:58 <Japsu> Mui. opqdonut
10:23:22 <chessguy> Mui.? is that the sound of a european cheek-kissing?
10:23:25 <Japsu> no
10:23:29 <opqdonut> :D
10:23:56 <SamB_XP> I don't see anything in the report about do adding a Monad constraint...
10:24:11 <ndm> SamB_XP: it does if you use two lines
10:24:13 <Japsu> it's a secret greeting with an etymology and meaning so complex and deep you mortals could never hope to understand
10:24:19 <LoganCapaldo> > let repeat n x = [1..n] >> [x] in repeat 3 True
10:24:20 <lambdabot>  [True,True,True]
10:24:21 <ndm> since it desugars to >> and >>= which both add monad constraints
10:24:23 <SamB_XP> ndm: yes.
10:24:30 <ndm> > do 1
10:24:31 <SamB_XP> but that doesn't explain "do 1"
10:24:31 <lambdabot>   add an instance declaration for (Num (t t1))
10:24:31 <lambdabot>     In the expression: 1
10:24:31 <lambdabot>     I...
10:24:38 <ndm> > do (1 :: Int)
10:24:39 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Int'
10:24:40 <SamB_XP> I think it is a bug in GHC
10:24:47 <SamB_XP> honestly
10:24:50 <SamB_XP> ;-P
10:24:53 <ndm> Hugs agrees
10:24:59 <LoganCapaldo> > do [1]
10:25:01 <lambdabot>  [1]
10:25:04 <LoganCapaldo> clearly a bug
10:25:11 <LoganCapaldo> I agree with everyone
10:25:17 <LoganCapaldo> do 1 should work
10:25:36 <ndm> Yhc and nhc work fine with do 1
10:25:39 <opqdonut> [1] proves nothing as [] is amonad
10:25:43 <SamB_XP> how can we fix GHC?
10:25:46 <LoganCapaldo> opqdonut: Shhhhhh!
10:25:49 <LoganCapaldo> It's a secret
10:26:17 <mux> > return 1 :: [Int]
10:26:18 <lambdabot>  [1]
10:27:19 <LoganCapaldo> @type do x
10:27:21 <lambdabot> Not in scope: `x'
10:27:24 <LoganCapaldo> @type do ?x
10:27:26 <lambdabot> forall (t :: * -> *) t1. (?x::t t1) => t t1
10:27:48 <Saizan> @type \x -> do x
10:27:50 <lambdabot> forall (t :: * -> *) t1. t t1 -> t t1
10:28:14 <Saizan> it's not even a Monad contraint, more a kind one
10:28:22 <LoganCapaldo> @undo do { x }
10:28:22 <lambdabot> x
10:28:43 <LoganCapaldo> it must do (some?) type inference before desugaring?
10:28:59 <LoganCapaldo> (where it = ghc)
10:29:07 <ndm> i've sent an email to haskell-cafre
10:29:20 <ndm> to decide whether Yhc or Hugs and GHC need bug reports raising
10:29:41 <pitecus> can i import a foreign function as a function with an uncurried type?
10:30:26 <chessguy> any AI strike force members around?
10:30:57 <quicksilver> pitecus: I don't think so, no. Why would you want to? :)
10:31:31 <pitecus> quicksilver, ill only ever use it with a tuple as arguments so its pointless to have it curried
10:31:40 <pitecus> it constructs a c struct
10:32:00 <quicksilver> but it's more pointless to have it not curried :)
10:32:06 <quicksilver> it might even be faster curried
10:32:20 <quicksilver> who wants to waste time constructing and destroying tuples
10:32:53 <chessguy> what does currying have to do with point-free code?
10:32:57 <chessguy> just kidding :)
10:32:59 <Apocalisp> pointless functions that operate on tuples are awkward
10:33:09 <SamB_XP> okay, what is with trac
10:33:27 <pitecus> quicksilver, well then i have to write mapM (\(x,y,z) ->foo x y z) xs insteat of mapM_ foo xs
10:33:32 <SamB_XP> it says I don't have TICKET_CREATE privileges
10:34:15 <quicksilver> pitecus: ah, you're carrying around lists of tuples, I see
10:34:24 <pitecus> exactly
10:34:26 <quicksilver> pitecus: well it's not hard to wrap the function, I guess
10:34:27 <SamB_XP> LoganCapaldo: well, it does do type inference before desugaring
10:34:52 <SamB_XP> it isn't required, afaik, but it makes errors a lot more readable
10:35:06 <quicksilver> pitecus: you could also use unzip3 and zipWith3 :)
10:35:32 <quicksilver> pite	or, you could define a custom mapM
10:35:41 <LoganCapaldo> SamB_XP: So that would make it a bug in the inferer or the checker then, right?
10:35:43 <pitecus> quicksilver, ok i know i was just wandering about the import ;-)
10:35:53 <SamB_XP> LoganCapaldo: they are one and the same
10:36:17 <SamB_XP> but yes, it would be in the typechecker (which does inference too)
10:37:26 <SamB_XP> I guess probably it needs to special-case single-expression "do"s
10:37:36 <malsyned> what's the appropriate operator for raising an Integral number to an Integral power?
10:37:41 <SamB_XP> ^
10:37:55 <malsyned> SamB_XP: thanks
10:38:18 <SamB_XP> that actually works on any kind of number, but if you had another kind of number you might want to use ^^
10:38:36 <SamB_XP> because that supports negative exponents, too
10:40:49 * dblhelix is catching up with the discussion that led to ndm's question on haskell-cafe...
10:41:10 <SamB_XP> dblhelix: you read your mail that fast?
10:41:53 <dblhelix> SamB_XP: the message was sent  ten minutes ago, wasn't it?
10:42:00 <SamB_XP> oh, maybe
10:43:25 <SamB_XP> dmhouse: where in the report does it say that do blocks constrain types inherently?
10:44:42 <desp> why do people use do notation with explicit {;} in papers?
10:45:00 <SamB_XP> desp: vertical or horizontal layout?
10:45:27 <desp> vertical
10:45:34 <desp> i.e. not a single line (that's what you mean, right?)
10:45:37 <SamB_XP> hmm, personal preference I guess
10:45:50 <SamB_XP> also it nests better that way
10:46:23 <SamB_XP> > do { do { "Hello" } }
10:46:24 <lambdabot>  "Hello"
10:46:31 <SamB_XP> > do do "Hello"
10:46:32 <lambdabot>  "Hello"
10:46:35 <SamB_XP> oh.
10:46:36 <SamB_XP> hmm.
10:46:38 <desp> :)
10:46:40 <SamB_XP> odd!
10:46:59 <SamB_XP> well, at least it looks less silly when you do nest it that way...
10:47:38 <SamB_XP> but, some people like to write "module Foo where {}", so go figure.
10:49:07 <SamB_XP> (note: usually they also write some code in the module ;-)
10:49:21 <desp> :)
10:49:29 <dmhouse> SamB_XP: I was under that impression, nothing more.
10:49:35 <petekaz> Re: Real World Haskell, WOOHOO!!
10:49:37 <SamB_XP> dmhouse: ah.
10:50:47 <SamB_XP> well, you would kind of think it would. but it looks like do is defined by translation, and like the Monad constraint only comes from >> and >>=
10:53:39 <SamB_XP> hmm. so some allege that the bug is in Haskell 98?
10:54:10 <dcoutts_> @yarr!
10:54:10 <lambdabot> Keelhaul the swabs!
10:54:12 <dcoutts_> You can now generate eps figures to include into latex documents using the Gtk2Hs cairo bindings.
10:54:38 <dblhelix> my feeling says that do should be restricted to monads, but I agree that's not what the report prescibes
10:54:56 <SamB_XP> can you do it without having a sufficiently new gdk to use GTK with Cairo?
10:55:14 <dmhouse> SamB_XP: right, so do (1 :: Int); (2 :: Int) is illegal as they don't match the types of (>>), but do (1 :: Int) isn't?
10:55:20 <dcoutts_> SamB_XP: yes, you just need a sufficiently new cairo, doesn't matter about gtk
10:55:54 <dcoutts_> withPSSurface "out.eps" width height $ do ....... :: Render ()
10:56:53 <SamB_XP> dmhouse: so it would seem
10:57:07 <edwardk> @seen ski
10:57:07 <lambdabot> I saw ski leaving #haskell-overflow, #oasis, #haskell-blah and #haskell 2d 2h 50m 28s ago, and .
11:03:21 <nominolo> uh, what does that forall e1 e2 ... stuff in the channel topic mean?
11:04:29 <pitecus> if I have a list of ForeignPtr a objects, and I want to allocate an array of a  from those ForeignPtrs, how can i do it? There is a comment about withForeignPtr which says that it is not safe to return the pointer from the action and use it after the action completes.
11:04:52 <nominolo> @hoogle allocForeignPtr
11:04:53 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
11:04:53 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
11:04:53 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
11:05:05 <pitecus> thanks nominolo
11:05:07 <emu> hmm it doesn't quantify v1 and v2
11:05:31 <Philippa> yeah, they're implicitly existentially quantified
11:05:40 <Philippa> that is, we know they exist because they're there, and that's it :-)
11:05:49 <edwardk> nominolo: means someone with bot access just took an intro to logic course, and probably failed the midterm =)
11:05:52 <emu> usually implicit quantification is universal
11:05:58 <edwardk> ya
11:06:11 <nominolo> pitecus: not sure if this is what you need, though.  this allocates a new foreignptr
11:06:12 <edwardk> and why implicitly quantify 2 of them and explicitly quantify the other 2?
11:06:14 <nominolo> edwardk: heh
11:06:46 <pitecus> nominolo, i ll give it a try
11:07:49 <mdmkolbe|work> I don't want to start a war, but is there any standard for formatting haskell? like maybe in the report?  I'm talking about things like whether to put 'foo a =\n expr' vs 'foo a\n = expr', etc.  (I tried the Haskell Emacs mode, but I can't figure out what rules it's using)
11:09:23 <chessguy> mdmkolbe|work: there's not really a standard, as long as you satisfy layout rules
11:09:33 <chessguy> it's a question of style
11:11:34 <edwardk> Hrmm. I was reading through that neil ghani monad coproduct article, and noticed a connection between that and the higher order hoare type theory paper that was presented at the ICFP (or rather the Hoare Type Theory separation logic monad)  this last year. In HTT you have only one monad, which is parameterized over the {P} and {Q} heap preconditions and postconditions, and its permissible under the semantics to parallelize any operation that
11:11:46 <pitecus> actually i dont think mallocForeignPtrArray applies
11:11:50 <edwardk> Er that probably got cut off didn't it?
11:12:10 <pitecus> i need to pass a list of things to withArray
11:12:18 <mdmkolbe|work> edwardk: it ended with "under the semantics to parallelize any operation that"
11:12:25 <pitecus> but those things are each in a ForeignPtr
11:12:50 <edwardk> "that wouldn't cause a conflict of separation, while in the coproduct article uses a distributivity laws and a quotient to the same effect, identifying towers of layered monads that distribute."
11:14:12 <edwardk> just found it interesting, and i'd be curious to see if the non-state/IO-like monads can all be expressed in terms of hoare separation pre- and post- conditions in HTT style, exceptions work, not sure about list, etc. though
11:14:30 <desp> STM++
11:15:13 <edwardk> might require a pretty backwards encoding though
11:16:07 <mdmkolbe|work> edwardk: you've peaked my interests.  what papers would you recommend on those two topics?
11:16:55 <edwardk> http://www.cs.nott.ac.uk/~nxg/papers/icfp02.ps.gz
11:18:33 <mdmkolbe|work> what about HTT?
11:18:38 <desp> s/peaked/piqued/ ;)
11:19:06 <edwardk> ftp://ftp.deas.harvard.edu/techreports/tr-10-06.pdf
11:19:09 <mdmkolbe|work> desp: :-)
11:19:23 <edwardk> i think thats the right paper, checking
11:19:53 <edwardk> i went to the wrong site looking for it the first time
11:20:59 <edwardk> http://www.eecs.harvard.edu/~aleks/papers/hoarelogic/jfpsep07.pdf
11:21:01 <edwardk> is similar
11:22:37 <edwardk> it was just the first time i'd seen a connection between monad coproducts and separation logic
11:22:48 <edwardk> so i was geeked =)
11:23:20 <edwardk> not sure if it holds for everything but at least the state/io/ST fragment seems to work
11:26:26 <mdmkolbe|work> edwardk: this is an off chance, but would any of this apply to designing a system language (i.e. one that C programmers would put up with) that ensures memory safety in a multi-threaded context? (Some or all of those threads might be attackers)
11:27:23 <edwardk> mdm: yeah, you could go that way with it, though HTT is pretty far from something C programmers could put up with
11:28:04 <edwardk> I've been using it as sort of a sounding board for the 'right' way to do things while I go off and play in the sand and remove layering distinctions from it and generally turn something nice and pretty into something I want to code in ;)
11:28:19 <mdmkolbe|work> ?
11:29:16 <pitecus> would smth like this work: withForeignPtrs f (x:xs) acc = withForeignPtr x $ \xp-> withForeignPtrs f xs (xp:acc); withForeignPtrs f [] acc = f acc
11:29:36 <edwardk> been working on a compiler for a functional language for about 8 months now as a way to learn a lot of the meta-theory behind pure type systems, etc. HTT is a nice straw-man model, because as theoretical models it has almost everything but the kitchen sink thrown in.
11:33:01 <edwardk> basically been just throwing things into a pot and seeing what goes boom, and trying to figure out ways to annotate the types to get them to blow up less spectacularly
11:33:11 <mdmkolbe|work> edwardk: heh
11:33:53 <edwardk> right now that includes a half-dozen features that are undecidable on their own, let alone in concert, great fun ;)
11:34:26 <edwardk> keeps me off the streets at night
11:34:30 <mdmkolbe|work> edwardk: any luck systematizing the back-end of the compiler? (I've found that the math seems to break down once you start thinking about stack slots and registers and reducing instruction counts.  (Sure we have SSA, graph-coloring, etc. but that doesn't get you all the way))
11:34:42 <ohmega-> @pl \x -> f (g x) (h x)
11:34:43 <lambdabot> liftM2 f g h
11:34:45 <ohmega-> what monad is that?
11:34:50 <edwardk> actually the back end of the compiler has been really stable
11:35:01 <edwardk> ohmega: the anonymous reader monad
11:35:03 <edwardk> (->)e
11:35:18 <ohmega-> hm
11:35:47 <ohmega-> ok
11:36:50 <mdmkolbe|work> ohmega-: but most people who read your code will probably be scratching their heads if you use 'liftM2 f g h' as an idiom for '\x -> f (g x) (h x)'   (unless you really do want to use it as a monad)
11:36:53 <Saizan> ohmega-: where return = const, ask = id, f >>= g = \x -> g (f x) x
11:38:40 <Saizan> ?type \f g h -> g &&& h >>> uncurry f
11:38:41 <edwardk> mdm: i subscribe to the GHC philosophy that almost all of the work should be done in the middle layer, transform to a small core, and optimize the hell out of it, my core just happens to track a bunch of substructural type annotations for pointedness, parametricity, usage mins/maxes, ordered-access, uniqueness of reference to date, etc. the stack drops out from the set of continuations that are ordered, everything else goes in various heaps.
11:38:49 <lambdabot> forall b a b1 c. (a -> b1 -> c) -> (b -> a) -> (b -> b1) -> b -> c
11:38:52 <edwardk> er and that probably got cut off again
11:38:55 <edwardk> =)
11:40:39 <mdmkolbe|work> edwardk: it ended with "else goes in various heaps."
11:40:50 <edwardk> ah then everything made it that time =)
11:41:30 * mdmkolbe|work is actually working on the GHC code generator (STG->Cmm) right now
11:41:52 <edwardk> ah good, while you're at it install a hook so you can dump out STG or get STG back from the GHC API =)
11:42:13 <mdmkolbe|work> edwardk: you know about -ddump-simpl?
11:42:15 <edwardk> er by dump out STG i mean tell the compiler to stop at that point and output a ".stg" file or something
11:42:15 <edwardk> yeah
11:42:25 <edwardk> but it doesn't do me any good if i want to pass it to an alternate backend
11:42:31 <edwardk> like a javascript closure converter
11:42:37 <ohmega-> you never cease to learn new things from @pl ;)
11:42:50 <mdmkolbe|work> edwardk: heh, yeah.  I've thought about that
11:43:42 <edwardk> and STG is a much better model than Cmm for javascript. Because environments and values can just be objects, and a simple model can update the thunks in place, and use function() { } values for the body of the tags
11:44:35 <edwardk> the ideal solution would be to have access to it through the GHC-API to say hey convert this to STG and give it back to me
11:44:43 <edwardk> I would LOVE that
11:45:10 <edwardk> i dropped in a feature request this morning actually =)
11:45:29 <mdmkolbe|work> edwardk: one thing that might keep the GHC team from wanting that though is that it would tie us to keeping STG stable and formalized.  I'm not sure how stable STG is but the Cmm that GHC uses is a serious distortion of C--
11:45:29 <edwardk> brb rebooting, gah, windows...
11:46:38 <edwardk> simon m didn't seem too afraid of the idea. and the STG doesn't appear to have changed substantially in a few years from looking at the way the code is outputted by dump-simpl and the old articles describing it
11:48:29 <edwardk> but the transcoder from STG to javascript is pretty simple, I have one lying around here somewhere, I just don't have the ability to get at the STG without a hack (er.. and most of the work goes into reimplementing primops actually) =)
11:50:20 <mdmkolbe|work> edwardk: I suppose you could call the driver functions directly if you needed to
11:52:44 <edwardk> yeah but then i seem to have to call all the functions all the way down and stop there, it wasn't really designed to go 'half way' at least it wasn't from my 3 hour investigation a few months back
11:54:07 <mdmkolbe|work> edwardk: that seems accurate
11:56:25 <edwardk> i would also like to be able to just feed the GHC API STG raw and get it to compile it, i think thats more readily accomodated by that sort of invasive puppet-master approach though.
11:57:19 <edwardk> gah rebooting, back in 5
12:00:56 <shapr> I had a Haskell question... I wonder what it was.
12:01:30 <kaol> how much wood could a monad chuck if monads could chuck wood?
12:03:25 * shapr throws substructural types at edwinb
12:03:28 <shapr> er, edwardk
12:03:32 <shapr> gahh
12:03:33 <shapr> @seen gahh
12:03:34 <lambdabot> I haven't seen gahh.
12:03:52 * edwardk watches them and watches as they all go where they are supposed to go, leaving no garbage.
12:04:19 <shapr> hah
12:04:35 <edwardk> What affine mess of things you have made. ;)
12:04:57 * kaol fourier transforms the channel
12:05:15 * edwardk fast fourier transforms it back.
12:06:10 <edwardk> or i suppose after you did that i could have taken the logarithm of everyone here, then fourier transformed it again to approximate the Z transform, but I think that might be a little too obscure.
12:07:54 <kaol> there's a topic too obscure for #haskell?
12:07:57 <profmakx> hm
12:08:06 <Saizan> i'm not a function, i'm a real man!
12:08:27 <kaol> oh, you're saying that you're a monad?
12:08:32 * ari refrains from making the complex/real joke
12:08:33 <profmakx> input of alcohol might yield unexpected results?
12:08:37 <opqdonut> i'm not afunction, i'm a relation
12:09:13 <edwardk> ari: well, to be fair the above would only approximate the real Z transform, not the complex Z transform, but I think that is also a topic too obscure for the channel ;)
12:09:30 <edwardk> er, actually its exact for the real Z transform
12:10:37 <edwardk> Er, the Z transform maps convolution onto addition, while the Fourier transform maps convolution onto multiplication, the former is sometimes useful in DSP circles because addition is cheap.
12:11:22 <edwardk> And I'm bouncing from topic-to-topic like shapr off his medication today.
12:12:10 <shapr> Speaking of which, I have to go pick up meds today or tomorrow.
12:13:30 <allbery_b> yay meds
12:13:31 <mdmkolbe|work> ok, so what happens when you take the forier transform of a 3sat problem? (or a signed, panar 2-sat problem if you prefer)
12:13:42 <shapr> allbery_b: You got meds too?
12:13:47 <allbery_b> yeh.
12:13:52 <allbery_b> hefty antidepressants
12:13:55 <shapr> Same meds? methylphenidate?
12:13:57 <shapr> Ah
12:14:13 <edwardk> mdmkolbe|work: you get a convoluted problem? =)
12:15:11 <david48> Hello
12:15:25 <shapr> I don't think deriving works with GADTs in ghc 6.6, does it or will it work with a later version?
12:15:28 <david48> I have a piece of code, I wonder if there's a way to simplify it.
12:15:31 <hpaste>  david48 pasted "is there a simpler way to code this ?" at http://hpaste.org/16
12:16:02 <david48> that'd be cool if someone would have a look at it :)
12:16:16 <mdmkolbe|work> edwardk: I honestly don't know.  Before transformation it's a set of constraints between pairs of pixels in an image (for the signed planar 2sat), but after the transformation those constraints must get spread out some way
12:17:29 <edwardk> david48 why one type, why not break it apart into two pieces and index
12:17:53 <mdmkolbe|work> david48: you can use 'deriving (Show)', but that will print things like 'PcEq t1 t2 t3' and not 't1 t2 = t3'
12:18:10 <david48> edwardk: no idea
12:18:15 <mdmkolbe|work> david48: also I think you're missing ++ " " ++ between your shows
12:18:52 <hpaste>  mdmkolbe|work annotated "is there a simpler way to code this ?" with "is this close enough?" at http://hpaste.org/16#a1
12:19:07 <david48> mdmkolbe: I don't like the normal output, that's why I don't derive (Show)
12:19:19 <hpaste>  LoganCapaldo annotated "is there a simpler way to code this ?" with "Something like this perhaps" at http://hpaste.org/16#a2
12:20:30 <david48> the way I defined it, the output will be like   "M1<M2,M3=20,I5>=6"
12:21:01 <edwardk> gah my firewall won't let me post to hpaste, weird
12:21:30 <shapr> sucks
12:21:39 <hpaste>  edwardk annotated "is there a simpler way to code this ?" with "here ya go" at http://hpaste.org/16#a3
12:21:51 <edwardk> at work, sometimes it gets screwy
12:22:10 <LoganCapaldo> edwardk: You stole my next soln. :)
12:22:11 <shapr> hej hstenstrom, kommer du frÃ¥n Sverige?
12:22:19 <edwardk> heh
12:22:45 <hstenstrom> shapr:  Japp.
12:23:03 <david48> I like your version edwardk :)
12:23:12 <edwardk> =)
12:23:14 <hpaste>  mdmkolbe|work annotated "is there a simpler way to code this ?" with "I would avoid the indexing" at http://hpaste.org/16#a4
12:23:45 <edwardk> the indexing was a bit hokey i'll admit ;)
12:23:46 <edwardk> but it was done fast =)
12:23:49 <edwardk> and its small
12:24:10 <david48> it doesn't have to run fast, I don't mind the indexing :)
12:24:10 <EvilTerran> and it looks nice, bad though it may be for efficiency
12:24:17 <EvilTerran> it's cunning
12:24:30 <edwardk> well it could be replaced trivially by building an array fromList then indexing that
12:24:48 <mdmkolbe|work> david48: using direct indexing is bad for maintainability and safety
12:25:02 <quicksilver> depending on fromEnum is bad for maintainability
12:25:07 <quicksilver> which is maybe part of waht mdmkolbe|work is getting at
12:25:11 <edwardk> sure
12:25:22 <mdmkolbe|work> david48: e.g. someone adds/removes a constructor but forgets to update the show list
12:25:45 <david48> aah, I get it.
12:25:53 <shapr> hstenstrom: Har du sett #haskell.se ocksÃ¥?
12:26:11 <shapr> hstenstrom: Are you learning Haskell for business or pleasure?
12:27:10 <Apocalisp> is there a difference?
12:27:21 <david48> well thanks a lot everyone you've been very informative :)
12:27:57 <hpaste>  edwardk annotated "is there a simpler way to code this ?" with "philistines... " at http://hpaste.org/16#a5
12:28:02 <edwardk> there ;)
12:28:10 <edwardk> now it uses an array and every one is explicitly paired
12:28:31 <edwardk> its fast, and if you omit one you would have omitted the show case to begin with ;)
12:28:43 <edwardk> er you might have to add deriving Ix, Eq, and some otherr things though
12:29:06 <mdmkolbe|work> edwardk: but if you omitted a show case GHC would tell you
12:29:17 <mdmkolbe|work> ;-J
12:29:26 <dolio> > ["=" .. ":"]
12:29:27 <lambdabot>   add an instance declaration for (Enum [Char])
12:29:27 <lambdabot>     In the expression: ["=" ....
12:29:29 <hstenstrom> I'm reading "The Haskell School of Expression" by Paul Hudak, and want to use the SOEGraphics module that is used in the book. I use Debian Unstable. The only package in Debian unstable that containes soegraphics is hugs, which has the file usr/lib/hugs/oldlib/SOEGraphics.hs. Can it be used?  quicksilver suggested libghc6-hgl-dev, and it contains /usr/lib/HGL-3.1.1/ghc-6.6.1/Graphics/SOE.hi, but I don't understand how to used
12:29:33 <edwardk> mdm: you would get a failed pattern match, in my case you get an undefined, same difference
12:30:07 <mdmkolbe|work> edwardk: no, you would get a compile type warning telling you that you forget a case
12:30:31 <david48> edwardk : nice !
12:30:38 <edwardk> what flags?
12:31:46 <mdmkolbe|work> edwardk: -W will do it
12:32:00 <mdmkolbe|work> edwardk: there may be a lesser flag that will also do it, I don't know
12:32:07 <shapr> hstenstrom: dcoutts wrote an SOEGraphics clone that works with gtk and cairo, I think that's a better choice.
12:32:28 <edwardk> heh, i haven't been using -W, so in the default no difference ;)
12:32:36 <mdmkolbe|work> edwardk: try "echo let f True = True | ghci -W"
12:32:41 <quicksilver> edwardk: note that that will create a new array for each invocation of show, probably
12:32:52 <quicksilver> edwardk: you should make the array a CAF to guarantee sharing
12:32:58 <edwardk> quicksilver, it should probably be bound globally, etc.
12:33:07 <david48> That's probably a stupid question, but how come nobody has made QT bindings for Haskell ? I've been looking everywhere.
12:33:27 <mdmkolbe|work> edwardk: there is also a -Wall if you want to go crazy with warnings
12:33:30 <quicksilver> david48: I shouldn't think there's a really good reason
12:33:38 <quicksilver> david48: I'd note that QT is a class library, though
12:33:49 <quicksilver> david48: containing, e.g., primitives for lists and data structures and stuff
12:33:51 <edwardk> mdm: no thanks, i use a lot of things that make Haskell upset to begin with, ;)
12:34:01 <dr_strangelove_> hstenstrom: http://packages.debian.org/unstable/libdevel/libghc6-soegtk-dev
12:34:03 <lambdabot> Title: Debian -- libghc6-soegtk-dev
12:34:05 <shapr> hstenstrom: Check out the mention of Graphics.SOE on http://haskell.org/gtk2hs/
12:34:06 <lambdabot> Title: Gtk2Hs
12:34:06 <quicksilver> david48: it would be non-trivial wrapping them in haskell types, or translating to equivalent types, etc
12:34:24 <david48> quicksilver: I see
12:34:47 <quicksilver> david48: so, I suspect the answer is 'it's non-trivial, and it hasn't been an itch anyone has wanted to scratch, yet' :)
12:35:07 <quicksilver> david48: we have gtk for modern graphical cuteness, and wx for x-platformity
12:35:20 <david48> quicksilver: I wanted to scratch it, but I too much of a newbie to scratch it :)
12:35:25 <hstenstrom> dr_strangelove_: Thank you, I will try that. For the moment, it's not installable. I guess the dependencies will be resolved later...
12:36:22 <ptolomy> How do people get nifty highlighting of haskell and other languages on their blogger blogs? (I'm hoping the answer isn't "They run it through a code pretty-printer with HTML out, grab the result and paste in the 'edit html' view)
12:37:03 <edwardk> ptolomy: i have some code that i wrote that glues in the vim syntax highlighting module for perl into wordpress
12:37:11 <edwardk> ptolomy: thats how I do it anyways
12:37:40 <edwardk> probably 20 lines of code
12:38:07 <edwardk> used on http://comonad.com/reader
12:38:14 <lambdabot> Title: The Comonad.Reader
12:38:26 <hstenstrom> If I use gtk2hs, can I say "import SOEGraphics", is it is written in Paul Hudak's book? Or should it be "import Grapics.SOE"?
12:38:30 <edwardk> if anyone really wants it i can dust it off when i get home
12:38:40 <Axioplase> Hi
12:38:56 <shapr> hstenstrom: probably Graphics.SOE
12:40:34 <Axioplase> How could I zip two [String] and split a words from first list ? (I want "myZip l1 l2" to return words of l1 zipped with l2)
12:40:56 <hpaste>  edwardk annotated "is there a simpler way to code this ?" with "done for now" at http://hpaste.org/16#a6
12:40:56 <hpaste>  LoganCapaldo pasted "is there a good reason not to allow this?" at http://hpaste.org/17
12:41:41 <EvilTerran> "zip (words l1) l2"?
12:41:45 <Axioplase> myZip ''foo bar' [1..] -> [[f,1  o,2  o,3] ,[b,4  a,5  r,6]]   (possibly with haskell idomatic functions, I can do it "manually")
12:42:15 <edwardk> heh logan, i ran into a similar issue earlier, one argument might be that (_ foo)  might look at arguments with different types across different constructors
12:42:25 <hpaste>  mtahti pasted "(no title)" at http://hpaste.org/18
12:42:26 <Baughn> hpaste: You're passing a B to a function that takes an A? Why would that be okay?
12:42:26 <chessguy> @go haskell kidd spam filter
12:42:29 <lambdabot> http://www.randomhacks.net/articles/2007/03/03/smart-classification-with-haskell
12:42:29 <lambdabot> Title: Smart classification using Bayesian monads in Haskell
12:42:30 <edwardk> so its just a pain =)
12:42:39 <Baughn> LoganCapaldo: Er, that's to you
12:42:53 <Axioplase> EvilTerran: it zips words of l1, I want to zip letters. And doing a "map" will restart from the beginning of l2 at each word
12:43:02 <LoganCapaldo> Baughn:  No, I'm passing an A to a function that takes an A
12:43:09 <EvilTerran> oh, i see what you want
12:43:18 <LoganCapaldo> edwardk: I just mean for the set of types where its ok
12:43:21 <edwardk> also, even if they have the same type in that position, if some of the previous arguments were unboxed, then they might be at different 'positions' if you look at the layout of the record in memory in a naive implementation
12:43:23 <Baughn> LoganCapaldo: Oh, right. Slightly confusing naming there..
12:43:32 <LoganCapaldo> Baughn: sorry :)
12:43:34 <dolio> LoganCapaldo: So, if there were constructors with numbers of arguments other than 1, would that only range across constructors with one argument?
12:44:00 <dolio> I suppose it would have to.
12:44:11 <Baughn> LoganCapaldo: No particular reason, except that it would be extra work for the compiler writers. You could of course add a case instead.
12:44:22 <syntaxfree> amazing. there's gonna be an O'Reilly book on Haskell.
12:44:24 <Baughn> LoganCapaldo: Not likely to be an issue in reality, either
12:44:32 <edwardk> data Foo = A Int Bool | B Int# Bool | C Float# Bool ; f (_ _ True) has a funny layout in memory
12:44:58 <syntaxfree> I wonder why we don't get to profit from the productivity differential before technologies go mainstream.
12:45:11 <syntaxfree> (I guess 37Signals managed to do that with Ruby for a hile)
12:45:22 <Baughn> LoganCapaldo: *Usually*, you wouldn't have a two identical.. subtypes? What's the term?
12:45:26 <LoganCapaldo> Baughn: well I was actually thinking of david48's problem
12:45:50 <edwardk> that said, can't you give them both the same function name if they have the same type and are in the same type?    data A = A { a :: Int } | B { a :: Int } ; f v = case a v of 3 -> ...
12:45:53 <shapr> syntaxfree: Part of the problem is that profitable technology differentials in the Programming world depend partly on integration.
12:46:03 <Baughn> LoganCapaldo: What, Qt bindings? I don't see the resemblance..
12:46:34 <shapr> syntaxfree: I can call C code from Haskell, but I don't get the productivity bonus I would get from having a Haskell library that does what that C lib does.
12:46:38 <LoganCapaldo> Baughn: http://hpaste.org/16 I was looking for a less wordy way to write my "common" function
12:47:52 <EvilTerran> > snd $ mapAccumL (\xs w -> (drop (length w) xs, zip w xs)) [1..10] ["foo","bar","baz"]  --  Axioplase
12:47:53 <lambdabot>  [[('f',1),('o',2),('o',3)],[('b',4),('a',5),('r',6)],[('b',7),('a',8),('z',9)]]
12:48:06 <shapr> syntaxfree: That's my opinion at least. What do you think about that?
12:48:24 <LoganCapaldo> edwardk: Looks like that actually does work
12:48:39 <Baughn> @pl common a b c d = concat $ map show [a,b,c,d]
12:48:39 <lambdabot> common = ((((show =<<) .) .) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
12:48:44 <Baughn> ..that's not it.
12:48:51 <EvilTerran> :O
12:48:59 <syntaxfree> shapr: those are interesting insights.
12:49:00 <hpaste>  LoganCapaldo annotated "is there a good reason not to allow this?" with "Works" at http://hpaste.org/17#a1
12:49:02 <Axioplase> EvilTerran: oh thanks! I was looking for mapAccumL !
12:49:06 <syntaxfree> I'm guessing scale has a lot to do with it.
12:49:31 <syntaxfree> You need a team of Haskell developers before you start profiting from comonadic evaluation of telephony datastreams or something.
12:49:44 <EvilTerran> Axioplase, no problem =] . i think you need to import it from Data.List, mind
12:49:51 <Axioplase> I did :)
12:50:47 <syntaxfree> There's a sociological cause too: early adopters are often in academia, or tinker with new technologies for the intellectual tingle, not seeking profit per se from it. Entrepreneur types only hear about technologies as the hype starts.
12:51:10 <syntaxfree> As an economist, technological adoption fascinates me. Ever heard of Solow's paradox?
12:51:59 <shapr> syntaxfree: Also, you're measuring from an economical viewpoint, where personal productivity could be measured in other ways.
12:52:19 <syntaxfree> shapr: I'm measuring from profitability.
12:52:32 <syntaxfree> It's evident to me that Haskell is more productive than languages with no type inference like Java, for example.
12:52:46 <Saizan> LoganCapaldo: scary
12:52:50 <shapr> Yeah, I agree with that, but how do you measure profitability?
12:53:03 <kaol> anyone made a haskell the movie yet? erlang has one...
12:53:08 <syntaxfree> yet even with Paul Graham types who believe in crazy new technologies, most of what we get is lukewarm.
12:53:10 <LoganCapaldo> Saizan: which part? the a thing? I'm kind of scared by that
12:53:18 <syntaxfree> shapr: from profits :)
12:53:29 <Saizan> LoganCapaldo: exactly
12:53:34 <syntaxfree> shapr:  I mean, John Baekel invented photography film and made a fortune from it.
12:53:48 <syntaxfree> basically selling it to Kodak.
12:54:03 <syntaxfree> Then he basically spent all that fortune trying to come up with a decent plastic.
12:54:24 <syntaxfree> After many years, he did -- bakelite. And he profited again.
12:54:25 <shapr> syntaxfree: RMS hasn't made a fortune, but GNU allows many businesses to be profitable where they wouldn't if they had to buy Oracle/Microsoft/Sun/etc.
12:54:30 <LoganCapaldo> Saizan:  I wonder if that's _supposed_ to work
12:54:42 <Saizan> LoganCapaldo: i guess it makes sense, a :: A -> Int, but it does also reveal that records are smarter than i thought
12:54:46 <syntaxfree> shapr: but the profit in those companies shows up in productivity-per-worker measures.
12:54:55 <LoganCapaldo> Saizan: yeah type wise it makes sense
12:55:01 <syntaxfree> That's basically the gist of Solow's paradox.
12:55:03 <Saizan> LoganCapaldo: mmh, we should check the report :)
12:55:10 <shapr> syntaxfree: I think seed funding is needed for non-lukewarm stuff. I have an ideas file nearly 700 lines long, but I don't have the money to prototype my inventions.
12:55:10 <LoganCapaldo> @where report
12:55:11 <lambdabot> http://www.haskell.org/onlinereport/
12:55:39 <fuzan> ?seen sorear
12:55:39 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 3d 6h 11m 27s ago, and .
12:55:40 <syntaxfree> In his 1989 presidential address to the American Eocnomic Association he said -- "I see computers everywhere, except in economic statistics".
12:56:04 <syntaxfree> Of course, in the 1990s, productivity soared, and it's fair to associate it to people finally "getting" how to use computers in order to be more productive.
12:56:13 <shapr> syntaxfree: For example, one simple and possibly huge idea I had recently is to use inductrac in jet turbine engine bearings so that precision molding is no longer required.
12:56:34 <LoganCapaldo> Saizan: "A data declaration may use the same field label in multiple constructors as long as the typing of the field is the same in all cases after type synonym expansion."
12:56:40 <fuzan> b
12:56:51 <LoganCapaldo> I guess it is supposed to work
12:57:10 <edwardk> logan: yeah i remembered reading that part, which is why i suggested it =)
12:57:25 <syntaxfree> shapr: well, yes. industrial processes require scale. But in principle, I could develop a better telephone switch in my bedroom with free Haskell and Mercury compilers and a pile of free PDFs on theoretical logic.
12:57:29 <edwardk> i used it for bounded and unbounded variable quantification, using the same accessors for each in my compiler.
12:57:49 <syntaxfree> (I actually know one philosophy professor who acts as a consultant to Ericsson once in a while.)
12:58:31 <syntaxfree> shapr: you can call it the Paul Graham paradox. Paul Graham keeps on insisting that with software, scale doesn't matter, any kid in a bedroom can make something huge. But apparently early adopters of technologies aren't entrepreneur types.
12:58:31 <shapr> syntaxfree: What about making a new institution for idea prototyping? Communities could put a software/hardware/machining lab next to existing libraries, and allow taxpayers to use those facilities to try out new stuff.
12:58:52 <edwardk> though it still has to force the constructor to get at the chewy center, so you can't build a function that credit-card transforms the constructor while letting you access those fields ;)
12:59:10 <syntaxfree> I'm hatefully caught in the middle. I'm neither enough of an ascetic nerd to shut out the world and spend years living on food remains and studying linear logic, neither a super-entrepreneur type who can get rich from a lemonade stand.
12:59:13 <shapr> syntaxfree: Yeah, because entrepreneurs want money, and jumping into new technologies could be a waste of time.
12:59:31 <shapr> syntaxfree: In that case, why not be the person in the middle who connects those two extremes?
12:59:42 <syntaxfree> shapr: entrepreneurs have little vision of which technologies are worth it and which aren't.
12:59:49 <syntaxfree> shapr: maybe I will, maybe I will :)
12:59:50 <shapr> syntaxfree: You should talk to alexj, he's got both serious tech and serious business in his head.
13:00:01 <edwardk> syntax: paul graham is also a lisp-centric nutcase who makes money acting as an 'angel' buying up a piece of companies for a song while its founders eat ramen.
13:00:02 <syntaxfree> I need to get a real job and a sense of the real world for a couple of years. I've been in academia forever.
13:00:32 * syntaxfree sings "What could I know, I'm just an econometrician" to the tune of the "Home movies" cartoon theme song.
13:00:59 <syntaxfree> edwardk: yeah. but look at the kind of company he ends up funding.
13:01:08 <syntaxfree> there's scarcely something genuinely cool, technology-wise.
13:01:30 <syntaxfree> there's justintv and scribd and twitter and crummy CRUD stuff.
13:02:09 <chessguy> hey syntaxfree , you'd like the discussion in #ai right now
13:02:10 <edwardk> syntax: sure, I have some friends who went to a couple of those Y-Combinator bootcamps to talk to investors.
13:02:29 <syntaxfree> I mean, just look at all the mature technologies that can't seem to make money.
13:02:38 <syntaxfree> Genetic algorithms are almost supernatural.
13:02:53 <syntaxfree> The first time I saw a GA finding solutions for the TSP my arm hair stood up.
13:03:11 <EvilTerran> LoganCapaldo, you also might be able to hack something together to do wildcard constructor matching in TH
13:03:14 <emu> approximation algorithms are really quite good
13:03:18 <syntaxfree> now, where the hell are the start-ups making a fortune from GAs? That stuff is pretty much well-understood.
13:03:20 <emu> that's all GA is
13:03:34 <emu> a lot of research focuses on that stuff
13:03:38 <edwardk> the problem with GAs is they require a lot of 'man behind the curtain' time tuning parameters to the problem domain, they can get stuck in local optima, and there is a lot of tuning and parameter space exploration involved in using them in production.
13:03:53 <emu> it's often a LOT harder to get the 100% optimal answer than the 95% one
13:04:01 <emu> but the 95% is good enuf
13:04:23 <syntaxfree> anyway, my best economist instincts telll me that, hell, there should be money to be made on GAs somehow.
13:04:29 <syntaxfree> or Hindley-Milner type inference.
13:04:32 <emu> i mean look at 3-SAT
13:04:36 <edwardk> a lot of 'almost good-enough' algorithms have that problem. Gibbs sampling/Markov Chain Monte Carlo methods in statistics is similar. Its great for MOST problems, but when it goes wrong it goes horribly horribly wrong and doesn't tell you very well that its in trouble, so its hard for non-statisticians to use.
13:04:46 <emu> you can get a 7/8th approximation of 3-SAT for free, basically
13:04:53 <syntaxfree> I mean, how much complex business logic can be modelled into the vanilla Haskell type system and trivially checked by the compiler?
13:06:16 <syntaxfree> I sometimes think of opening a consulting company with a pedantic name like "Algebraic Business Rules Inc.". But I don't have a clue of how to sell ideas to businesses, right now.
13:06:36 <alexj> syntaxfree: that might be another name for what I want HAppS LLC to become.
13:06:38 <edwardk> syntax: "The Abelian Group" =)
13:06:39 <emu> invent buzzwords
13:06:41 <syntaxfree> That's why I hope to work for a company, even if as an econopeon, for a while after getting my Masters.
13:06:51 <syntaxfree> alexj: oh. Are you hiring ;)
13:06:54 <syntaxfree> edwardk: hahahaha
13:07:09 <syntaxfree> emu: the literature is ripe with Buzzwords for Free!
13:07:14 <edwardk> I actually thought about using that one once ;)
13:07:31 <alexj> syntaxfree: yes.  have a pile of resumes to read, but am indeed hiring.  an econopeon summer intern might be ok too.
13:07:36 <alexj> :-/
13:07:53 <alexj> syntaxfree: where are you located?
13:08:04 <syntaxfree> alexj: ah, I'm sure I'm okay-ish as a code monkey as long as you use something functional.
13:08:10 <syntaxfree> I know next to zero about OOP though.
13:08:19 <syntaxfree> alexj: Gah, I'm in South America.
13:08:44 <alexj> i try very hard to avoid oop. it never really makes sense to me.
13:08:51 <alexj> syntaxfree where in SA?
13:09:04 <syntaxfree> anyway, I've read so many horror stories in sites like thedailywtf and codinghorror, I'm pretty confident I could pass a reasonable programming skills test.
13:09:08 <syntaxfree> Brazil.
13:09:33 <alexj> ok.  well maybe we can do some remote stuff.  shapr and lemmih are both in other places.
13:09:45 <alexj> send me a cv.
13:09:56 <syntaxfree> I'm willing to move to the US, though I don't know how complicated the immigration process is.
13:10:00 <syntaxfree> I will.
13:10:16 <syntaxfree> My CV will contain next to nothing programming-related, I'm afraid. I've always done this stuff by night, on my own.
13:10:34 <alexj> even better.  immigration is nutty here right now.  hopefully will get fixed after they massively botch the legislation on the hill right now.
13:10:56 <syntaxfree> But, anyway, if you have some kind of skill test, I'm eager to try it.
13:11:17 <syntaxfree> I'm finishing a masters' degree in industrial economics.
13:11:31 <syntaxfree> I'm very skilled in statistics. It's pretty much what I've done for the last two years.
13:12:02 <syntaxfree> I'll prepare a CV and send you. Thanks :)
13:12:08 <alexj> cool.
13:12:56 * syntaxfree knows his sigma-algebras, his measure spaces and his GMM estimators. Emphatically *not* a MBA :)
13:13:53 <mwc> Alas, I have only an H.B.Sc., but soon I'll have my M.Math.
13:14:42 <chessguy> i think i'd rather lose a finger than get an MBA
13:15:05 <edwardk> I may wind up getting an MBA in the next couple of years since my job will likely pay for all or some of it.
13:15:28 <malsyned> Is there any documentation for FilePath-1.0?
13:15:31 <edwardk> (It started as all, then the 140k pricetag got them to start saying some) =)
13:16:02 <Igloo> 140k? Blimey
13:16:14 <chessguy> malsyned: http://www.cs.york.ac.uk/fp/haddock/filepath/System-FilePath-Posix.html
13:16:17 <lambdabot> http://tinyurl.com/yoh5xj
13:16:18 <syntaxfree> edwardk: can't you get some better program for that price tag?
13:16:18 <chessguy> linked from:
13:16:20 <chessguy> ?where filepath
13:16:21 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
13:16:28 <Igloo> malsyned: There are haddock docs, but haddock+cpp loses some of them them IIRC
13:16:39 <Igloo> (as opposed to haddock+cpphs)
13:16:54 <syntaxfree> if work's gonna pay for a MBA, they very well may pay for a CS MSc in  some less prestigious school.
13:17:29 <malsyned> thanks guys.
13:17:37 <mwc> Yeah, but then the lobotomy to bring you up to MBA standards will cost you a pile
13:17:49 <chessguy> lol
13:17:52 <vegai> I would gladly get an MBA
13:17:55 <Binkley> Nah, it's just a simple procedure involving shoving a crayon up your nose
13:18:02 <mwc> vegai: and just not tell anybody about it?
13:18:03 <vegai> and ditch my ongoing CS studies :)
13:18:10 <edwardk> syntax: Well, I do consulting in the defense industry for big companies. the MBA is a nice thing to add to the wall... and I already have CS and Math masters degrees. (an M.S. and an M.A. respectively)
13:18:11 <vegai> mwc: why?
13:18:16 <earthy> 140000 dollars for an MBA... that's *very* expensive
13:18:20 <syntaxfree> edwardk: oh. ENVY.
13:18:26 <earthy> 'The 21-month 2008/2009 Part-time MBA program costs â‚¬ 46.000'
13:18:44 <earthy> that's possibly the most highly regarded one in the netherlands
13:18:49 <chessguy> i'd love to add a masters in math to my BS in CS
13:18:53 <syntaxfree> I wonder how far my current MSc gets me towards a FP-oriented CS PhD program.
13:18:59 <vegai> seriously though, I'd much prefer actually doing something instead of studying all my life :)
13:19:02 <syntaxfree> but I want to work for a few years before returning to academia.
13:19:06 <mwc> We had a highly-regarded MBA school at my undergrad alma mater
13:19:11 <Binkley> doing something is highly overrated
13:19:16 <mwc> the joke was it looked like a BMW dealership
13:19:22 <mwc> it actually does
13:19:34 <edwardk> I was busy collecting little pieces of paper to line my walls for 3-4 years before I returned to industry.
13:19:38 <earthy> academentia. :)
13:20:02 <LoganCapaldo> Its time for academiacs. And they're crazy to the max
13:20:23 <edwardk> I am currently looking at Wharton for the MBA. A former coworker of mine used to be Dean there.
13:20:52 <vegai> Binkley: not nearly as much as studying
13:21:08 <Binkley> vegai: well, I've tried studying and I've tried doing things, and I've liked studying better :-) but YMMV
13:21:23 <Binkley> also, when I try to Do Things, there always seems to be something preventing anything from actually getting done
13:21:24 <vegai> well... I'm not sure if it's about what one likes
13:21:41 <vegai> if I'd do only what I'd like... oy
13:21:53 <Binkley> well, you only get one life, you might as well use it to do something you like :-)
13:21:53 <edwardk> I had originally hoped to come out here and work a little and do my PhD (I live a few blocks from Harvard now), but the timing doesn't seem to work out for me to do a Ph.D. here.
13:23:06 <earthy> (btw, that EUR 46k includes 2 weeks at Kellogg school of management)
13:23:31 <edwardk> earthy: that is for what is the currently and consistently top-ranked program though.
13:23:33 <vegai> Binkley: true, but I need to work quite a lot before I know what that is
13:23:48 <Binkley> vegai: yeah, in my experience, work is good for figuring out things you don't want to do :-)
13:24:10 <vegai> I suppose studying is worthwhile in that way as well
13:24:43 <earthy> edwardk: yeah, still... a lot
13:24:46 <syntaxfree> @quote worth
13:24:46 <lambdabot> qwe1234 says: lisp is yet another half-assed run-of-the-mill scripting language. absolutely *no different* from something like php in any significant way worth mentioning.
13:25:10 <edwardk> earthy: I have a bunch of degrees from a place no one has really ever heard of who isn't from Michigan, so I figure if I'm going to pad the resume with anything it had better have some punch. Also getting the employer to cover it lessens the blow quite a bit.
13:25:13 <sm> Binkley: agreed :)
13:25:18 <earthy> syntax looks for 'functional programmers know the value of everything but the cost of nothing'?
13:25:30 <earthy> edwardk: so where? :)
13:25:30 <edwardk> I binged through academia until I ran out of money. Now I've found someone else to pay the bill ;)
13:25:31 <syntaxfree> hahaha. I once said something like that in #lisp, when I was considering CL for a web thing I wanted to try out.
13:25:41 <edwardk> earthy: Eastern Michigan University.
13:26:00 <earthy> I have heard of it. and I'm from .nl.
13:26:02 <Binkley> syntaxfree: you said "value of everything/cost of nothing" or you said that lisp is like php?
13:26:03 <syntaxfree> I said Lisp was a compromise between Haskell and PHP to me. The people flipped out.
13:26:12 <Binkley> heh
13:26:17 <earthy> then again, I spent a week at UMich in Ann Arbor back in 2000
13:26:38 <syntaxfree> @quote value
13:26:39 <lambdabot> PaulAJ says: Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what
13:26:39 <lambdabot> other part of the program might have been using it.
13:27:01 <syntaxfree> that's a smart quote!
13:27:27 <syntaxfree> @quote nothing
13:27:27 <lambdabot> sudo says: You speak an infinite deal of nothing
13:27:42 <edwardk> earthy: B.S. Mathematics/Computer Science (4.0/4.0 GPA, summa cum laude, university/departmental honors, etc), M.A. Mathematics, Graduate Cert. in AI, M.S. in Computer Science, all 4.0/4.0 GPA, and all really just because I got really bored and obsessed for the last 3 years.
13:27:46 <edwardk> earthy: ahh
13:28:03 <earthy> whoa
13:28:15 <earthy> obsessed, obviously. :)
13:28:33 <syntaxfree> *envious*
13:28:35 * earthy never got a perfect grade point average ever :)
13:28:37 <edwardk> earthy: I'm a tidge obsessive, and as the economist in the room might say, was concerned with the opportunity cost of removing myself from the workplace to collect an education.
13:28:43 <emu> EMU?
13:28:47 <edwardk> Yeah
13:28:51 <edwardk> =)
13:29:01 <earthy> (there were always more interesting things to pursue as well ;))
13:29:04 <emu> could be Central Mich
13:29:06 <syntaxfree> @quote pursue
13:29:06 <lambdabot> No quotes match. I feel much better now.
13:29:14 <syntaxfree> @quote purse
13:29:14 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
13:29:17 <syntaxfree> @quote purs
13:29:18 <lambdabot> No quotes match. Just what do you think you're doing Dave?
13:29:24 * syntaxfree drops dead
13:29:26 <edwardk> I went to eastern, not central
13:29:38 <earthy> ofcourse, I'm now an assistant professor...
13:29:52 <earthy> (still feels weird saying that)
13:30:50 <edwardk> I worked as an adjunct lecturer after I finished the math masters while I worked on the other, somewhat amusingly teaching computer science courses while I was collecting my comp sci degree. I really liked academia, I just couldn't afford to stay there.
13:31:29 <earthy> yeah, well, they pay me the nice money to do the nice work...
13:31:37 <earthy> s/work/play/ really :)
13:31:58 <SamB_XP> ideally they are indistinguishable
13:32:03 * earthy gets to play with parser combinators for a job! what more could a guy want. :)
13:32:18 <earthy> oh, and the teaching Java part isn't half bad either
13:32:34 <SamB_XP> ???
13:32:34 <edwardk> for me the math degree was personal, I wanted to understand the consequences of an algorithm I had used for visible surface determination in 3d graphics like 12 years ago, that I didn't really understand the "why" of, and the computer science degree was the demonstrate and refine existing knowledge.
13:32:43 * LoganCapaldo debates killing earthy to assume his identity and play with parser combinators
13:33:17 <SamB_XP> LoganCapaldo: that is a very roundabout way of doing things
13:33:23 <emu> teaching java part, mm sadism
13:33:58 * earthy hints at logancapaldo that he might want to figure out why monadic parser combinators are strictly more powerful than merely arrowised parser combinators and cannot be made exactly as efficient
13:34:08 <earthy> before he tries doing that. ;)
13:34:43 <emu> did you know what you wanted to do before apping to grad schools
13:34:56 <edwardk> me?
13:35:14 <edwardk> in my case i didn't really have to apply i was already there, and i knew what i wanted to get out of both degrees
13:35:20 <SamB_XP> earthy: does that apply even with ArrowApply or whatever it is called?
13:35:51 <byorgey> @src maximum
13:35:51 <lambdabot> maximum [] = undefined
13:35:51 <lambdabot> maximum xs = foldl1 max xs
13:36:09 <edwardk> earthy: does that include little hacks like the sweirstra/duponcheel arrow parsers that have trouble fitting the monadic framework?
13:36:16 <emu> i am going to app in the fall but i'm pretty lost =)
13:36:19 <earthy> samb: it doesn't.
13:36:29 <earthy> edwardk: that includes *precisely* those hacks
13:36:41 <edwardk> earthy: nice. wanna share? =)
13:37:06 <earthy> if I can make it intelligible, sure
13:37:36 <edwardk> i'll take general direction as a starting point. i have to rewrite my parser for my compiler anyways ;)
13:38:30 <earthy> okay, the basic issue is that in the case of monadic parser combinators at each bind you *commit* to having a particular value under the monad
13:39:02 <earthy> sorry, that didn't start out right
13:39:04 <edwardk> ok, so you have to do a lot 'out of monad' then?
13:39:07 * earthy needs to think. :)
13:39:14 <earthy> it's tricky
13:39:24 <earthy> the basic issue is that bind sequences
13:39:49 <earthy> strictly sequences according to the flow specified by the arguments to the right-hand side argument of bind
13:39:50 <edwardk> ok, so far, pretty much got parsec ;)
13:40:14 <earthy> unfortunately, this does *not* allow information to flow backwards across the bind
13:40:36 <earthy> information such as e.g. the first and the follower sets
13:40:48 <earthy> (which are well-known concepts in parsing)
13:40:56 <edwardk> yep
13:41:38 <earthy> therefore, monadic parser combinators cannot do all the optimisations that parser combinators that do allow this data flow in the inverse direction
13:41:55 <earthy> +can
13:42:01 <edwardk> ok, so your premise is that arrows are better?
13:42:41 <earthy> no
13:43:00 <earthy> because one thing monadic parser combinators *do* allow you to do
13:43:08 <earthy> due to that strict sequencing
13:43:08 <edwardk> "monadic parser combinators are strictly more powerful than merely arrowised parser combinators", so I presume you find a win somewhere ;)
13:43:38 <edwardk> you can get that with a Kleisli Arrow no?
13:44:20 <earthy> is that monadic parser combinators allow you to use the lookahead token to change the parser for the remainder of the input
13:44:48 <earthy> drat. I need to scan my new passport. brb
13:44:54 <edwardk> hrmm
13:45:19 <edwardk> trying to see what precludes that under the kleisli construction
13:46:08 <byorgey> @src scanr
13:46:09 <lambdabot> scanr _ q0 []     =  [q0]
13:46:09 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:46:09 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:46:24 <earthy> oh, kleisli arrows don't allow the accumulation of first- and follower sets all through the parser
13:46:27 <Saizan> ?docs Text.Html
13:46:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Html.html
13:46:32 <earthy> independent of where these get influenced
13:46:38 <monochrom> With a monad you hand-code lookahead.
13:47:04 <earthy> monochrom: not necessarily, but you can
13:47:09 <earthy> and you need a monad to do so
13:47:19 <earthy> if you don't have a monad you need another primitive
13:47:31 <monochrom> nevermind
13:47:41 <edwardk> i'm just saying what prevents you from lifting your monad when all is said and done into a kleisli arrow though?
13:47:51 <earthy> nothing
13:48:14 <byorgey> @src scanl
13:48:14 <lambdabot> scanl f q ls = q : case ls of
13:48:14 <lambdabot>     []   -> []
13:48:14 <lambdabot>     x:xs -> scanl f (f q x) xs
13:48:16 <earthy> but if you can have bind you lose accumulation of first- and follower sets
13:48:53 <earthy> and if you don't have bind you lose the ability to coompletely freely change parser using lookahead
13:49:10 <edwardk> ok
13:49:57 <edwardk> so sans bind what is your parsing mechanism? what is the monad contributing?
13:50:09 <edwardk> am legitimately curious how your parser works
13:51:32 <earthy> the parsing mechanism is continuation based
13:52:07 <edwardk> ok, so do you ContT some base parser monad that when you bind you are committing?
13:52:50 <earthy> nope
13:52:54 <edwardk> heh
13:53:06 <edwardk> seemed sound =)
13:54:02 <earthy> I (well Swierstra's combinators) build an abstract datastructure that contains tables that map from the first set to the parser for the remainder
13:54:35 <edwardk> hrmm
13:55:00 <earthy> the combinators are available btw
13:55:11 <earthy> if you want to look at the gory details. :)
13:57:40 <earthy> ?google haskell utrecht tools
13:57:41 <lambdabot> http://www.cs.uu.nl/wiki/HUT/WebHome
13:57:42 <lambdabot> Title: HUT: Haskell Utrecht Tools
13:58:52 <edwardk> looking
13:59:09 <earthy> there. I hope that's the last bureaucratic hoop to jump through to get the dutch government to accept that I was born
13:59:32 <edwardk> heh
14:00:25 <SamB_XP> earthy: you should have asked them to prove that you were not born...
14:00:25 <edwardk> ok, driving home, will see how well they work when i go through and rewrite my parser next week
14:00:41 <hpaste>  freshhawk pasted "lambdabot error" at http://hpaste.org/20
14:01:16 <edwardk> i think its a lot cooler to standard there and not have been born wondering what all the hubbub is about than it is to fight to convince then that you really were.
14:01:27 <freshhawk> has anyone tried to compile lambdabot recently (using ghc 6.6.1?)
14:01:31 <edwardk> "Earthy the Unborn" it sounds like a cheesy fantasy novel.
14:01:38 <earthy> samb: the issue is more in that they don't have to believe who I say my parents were
14:01:56 <SamB_XP> hmm?
14:02:18 <ArthurClemens> earthy: nice that you use TWiki
14:02:28 <Saizan> do you know of something that autoindents html? i tried parsing and prettyprinting but this document doesn't parse :\
14:02:53 <edwardk> gotta run
14:02:55 * edwardk waves
14:03:00 <earthy> bubby edwardk
14:03:02 <chessguy> Saizan: so fix it!
14:03:07 <earthy> arthurclemens: not really
14:03:23 <earthy> (it's a big gaping hole, security wise)
14:03:34 <ArthurClemens> why?
14:03:44 <sjanssen> freshhawk: are you having trouble?
14:03:49 <earthy> it has already been hacked at least once in our install
14:04:09 <Saizan> chessguy: it's not mine! i just wanted to read it.. it's one of those php generated all on one line pages :(
14:04:29 <earthy> the version we run is a bunch of not very well written perl that manages to not do overly much input sanitizing
14:04:37 <ArthurClemens> you are using TWiki 3, and perhaps you didn't install a security patch
14:04:55 <earthy> oh, and it isn't really maintained either
14:05:13 <earthy> as the associate prof who installed it left for greener pastures at another uni
14:05:24 <ArthurClemens> there's also a BlackListPlugin you ought to use for public sites
14:05:29 <ArthurClemens> ah I see
14:05:33 <freshhawk> sjanssen, I got it working. just had to take out the #ifdef block at the top of Lib/Parser.hs
14:05:43 <dcoutts> @seen hstenstrom
14:05:43 <lambdabot> I saw hstenstrom leaving #haskell 1h 6m 48s ago, and .
14:06:02 <ArthurClemens> many Dutch people working with haskell?
14:06:08 <freshhawk> sjanssen, just wondering if that was known or if I was doing something weird
14:06:23 <dcoutts> @tell hstenstrom if you want the Gtk2Hs impl of the SOE api you need to import Graphics.SOE.Gtk
14:06:23 <lambdabot> Consider it noted.
14:07:40 <earthy> arthurclemens: a couple
14:08:17 <earthy> they could probably all fit in a medium auditorium
14:08:49 <earthy> if I count students that have been taught Haskell I think it'll still be less than oh, say, 2500 in all of .nl
14:09:03 <earthy> possibly less than 1000 even
14:09:40 <earthy> but that's shaving it close as the FP with Haskell course has already run for about a decade at UU, with class sizes of about a 100
14:09:40 <ArthurClemens> hmm ok
14:10:20 <earthy> .nl has a few competing fp languages of its own
14:10:25 <earthy> Clean, most notably
14:10:34 <earthy> but also a miranda variant called amanda
14:10:48 <ArthurClemens> didn't know Clean is Dutch
14:11:08 <earthy> Clean is clean lean and lean is Language of East Anglia and Nijmegen
14:11:32 <earthy> (or concurrent lean, which ever way the bat swings at that particular moment)
14:12:34 <ArthurClemens> universities are probably not trying to gain much tracking for these languages
14:16:02 <earthy> .nl isn't the best country to have software engineering research trickle out of academia
14:16:41 <earthy> as cs in .nl basically evolved in two completely separated sets
14:16:49 <earthy> the business set and the academic set
14:17:04 <earthy> and both have always had something of an aversion to the other
14:18:20 <earthy> academic computer scientists were and still are not in very high regard due to the perceived lack of practical applicability of their lofty research
14:22:42 <Binkley> @yow
14:22:43 <lambdabot> Do I have a lifestyle yet?
14:27:26 <Binkley> @quote
14:27:26 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
14:28:39 <Apocalisp> whahaha
14:29:13 <monochrom> Analogies are great. Err horrible.
14:29:47 <Binkley> especially anal analogies
14:30:03 <monochrom> Damn you. Hahahahaha.
14:35:45 <Apocalisp> Java only works on all platforms because it has an enormous adapter.
14:36:32 <opqdonut> @quote
14:36:32 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
14:36:36 <opqdonut> :)
14:36:37 <opqdonut> @quote
14:36:38 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
14:36:38 <Binkley> heh
14:36:47 <Binkley> @quote metaphor
14:36:47 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
14:36:51 <Binkley> @quote analogy
14:36:51 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
14:37:03 <psnl> how is that still in the quote db?
14:37:15 <Binkley> does anything ever get removed from the quote db?
14:37:45 <Apocalisp> @quote quote
14:37:45 <lambdabot> psykotic says: monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
14:37:54 <psnl> I hoped that when lambdabot died, it would die too..
14:38:30 <opqdonut> @quote psnl
14:38:30 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
14:38:32 <opqdonut> @quote psnl
14:38:33 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
14:38:40 <opqdonut> your 15 minutes of fame
14:38:48 <opqdonut> @quote opqdonut
14:38:49 <lambdabot> No quotes match. You speak an infinite deal of nothing
14:38:52 <Chewie[]> i have a question. i'm one of those people who learns better from notes than from examples or from complete docs.. anybody know of a set of notes (just the non-obvious stuff, i know what identifiers are, i know what types are) for Haskell or ML?
14:38:53 <opqdonut> :(
14:38:53 <opqdonut> sad
14:38:59 <psnl> 7 words of fame, at best
14:39:34 <olsner> was that a metametaphor?
14:39:42 <Binkley> I never metametaphor I didn't like
14:40:08 <olsner> mindblowing!
14:40:41 <monochrom> I don't know what "notes" means. Maybe it means blogs people write as they learn random bits of Haskell. There are plenty.
14:41:02 <Saizan> there's a page on the wiki for blog posts
14:43:18 <dainanaki> hey can someone help me with an xcode problem?
14:47:53 <Apocalisp> raise your hand if you use xmonad for day-to-day computing
14:48:11 <Apocalisp> and do you like it?
14:48:26 <Binkley> does it count if you've occasionally thought about potentially becoming interested in installing it?
14:48:35 <Apocalisp> In other words: Yarr if you like xmonad!
14:50:15 <dainanaki> yar if xcode won't work for me
14:50:26 <Apocalisp> Binkley: No, sorry. Doesn't count.
14:50:33 <Binkley> ;.-(
14:50:54 <Apocalisp> I've thought about it too. That's why I'm asking.
14:51:05 <shapr> Apocalisp: I only use xmonad.
14:51:11 <ddarius> @seen dons
14:51:11 <lambdabot> dons is in #haskell, #haskell-overflow, #ghc, #haskell-soc and #xmonad. I last heard dons speak 8h 38m 40s ago.
14:51:25 <shapr> Ya know, it'd be fun to have a TeamSpeak server for #haskell
14:51:32 <ddarius> @seen Cale
14:51:32 <lambdabot> I saw Cale leaving #oasis, #ghc, #haskell-overflow and #haskell 9d 3h 7m 46s ago, and .
14:51:34 <ddarius> @seen bos
14:51:35 <lambdabot> bos is in #haskell-soc and #haskell. I last heard bos speak 6h 7m 34s ago.
14:51:39 <Binkley> what's TeamSpeak?
14:51:42 <ddarius> @seen CosmicRay
14:51:42 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I last heard CosmicRay speak 5m 15s ago.
14:51:54 <shapr> Binkley: Voice Chat aimed at FPS gamers.
14:52:11 <shapr> Binkley: Do you have both a headset with mic?
14:52:20 <Binkley> shapr: somewhere... but it's hard to pull that off at work :-)
14:52:23 * ddarius can use his bluetooth headset.
14:52:37 <shapr> ddarius: Works with ALSA/OSS or whatever you use?
14:52:46 * ddarius uses Windows.
14:52:46 <Apocalisp> shapr: How's it working out? Never going back?
14:53:19 <shapr> Apocalisp: I won't ever go back to any other existing window manager, that's for sure. But if some new and even better wm turns up, I'll at least try that new thing.
14:53:32 <Chewie[]> i like pekwm myself.
14:53:34 * ddarius gave two units of blood today.
14:53:35 <Apocalisp> shapr: what were you using before?
14:53:44 <Chewie[]> it's fluxbox without any bars.
14:53:48 <fuzan> any vty gurus around?
14:54:04 * CosmicRay is here, for a few minutes yet
14:54:04 <fuzan> openbox > pekwm :)
14:54:10 <shapr> I have used ion3, ion2, ion1, twm, sawfish, and enlightenment that I can think of
14:54:13 <ddarius> shapr: And it's written in Haskell...
14:54:22 <shapr> ddarius: Yeah, but it's a lot faster too
14:54:33 <shapr> oh, and I used dwmii as well. It was nice, but really slow.
14:54:34 <ddarius> CosmicRay: Just going to say, good stuff about the book.
14:54:39 <CosmicRay> thanks!
14:54:42 <shapr> CosmicRay: Yes, much happiness about the book!
14:54:51 <ddarius> shapr: I meant "some new and even better wm" (written in Haskell)
14:55:12 <CosmicRay> thanks shapr
14:55:15 <shapr> ddarius: Oh, I'm not so picky about implementation language. I'll use programs that are good. But being able to hack the source is a big plus.
14:55:26 <ddarius> shapr: I was not being all that serious.
14:55:28 <shapr> For example, I use emacs lots, but I can't stand elisp or C
14:55:38 * shapr is low on sleep, can't spot humor
14:57:11 * ddarius tends to be very subtle about humor and is mildly lightheaded.
14:59:48 <DRMacIver> London HUG tentatively rated a success :)
15:00:06 <monochrom> You went? You liked it?
15:00:17 <DRMacIver> Yeah
15:01:13 <DRMacIver> The SPJ talk was interesting, and I enjoyed conversing with random haskellites at a resolution of > 10pt at the pub afterwards
15:08:49 <Binkley> ?yow
15:08:50 <lambdabot> I'm rated PG-34!!
15:30:44 <waterson> hi there! I've got a n00b question about GHCi.
15:31:04 <waterson> is there a way to suppress output for things that you evaluate with the "do" syntax?
15:31:05 <edwardk> shoot
15:31:19 <Jessehk> What does an exclamation point in from of an identifier mean?
15:31:20 <ddarius> monochrom: Currying cuts both ways as far as "pipelines" are concerned.
15:31:27 <waterson> e.g., "*Main> foo <- someThingThatMakesAMess"
15:31:43 <waterson> and I'd rather not see the mess
15:31:48 <ddarius> Jessehk: The only place it's allowed in H98 is in a data declaration and it makes that field strict.
15:32:14 <Jessehk> ddarius: What is a strict field?
15:33:02 <edwardk> it means that it will be evaluated to weak head normal form before being stored, so some work will be done before you put it away basically
15:33:05 <ddarius> Jessehk: A field that only stores evaluated contents, i.e. a strict field means that the data constructors are strict (eager) in that field.
15:33:11 <Saizan> waterson: yes there's a flag, i can't remember the name though
15:33:16 <beelsebob> shit
15:33:20 <bos> ddarius: you called?
15:33:29 <monochrom> ddarius: "cuts both ways"?
15:33:36 <Jessehk> ddarius: Ahh, as apposed to lazy.
15:33:38 <waterson> oh, jeez.  I knew as soon as I asked the question I'd find it in the doc. ":set -fno-print-bind-result"
15:33:38 <ddarius> bos: Was going to say Good work (to all of you) about the book.
15:33:43 <ddarius> Jessehk: Yep.
15:33:49 <beelsebob> looks like Lee Naish was a reviewer for our paper
15:34:10 <edwardk> who wha?
15:34:24 <bos> ah, thanks
15:34:29 <ddarius> monochrom: Currying makes pipelining more difficult when you want to pass multiple results (tupled together) to another function.
15:34:57 <ddarius> bos: I will spare you and not add my 2 cents on what _I_ think should be in the book. (I haven't really thought about it much anyways).
15:35:42 <mauke> bah, I need an image viewer that does not suck :(
15:35:57 <Binkley> then write one in Haskell :-)
15:36:00 <edwardk> beelsebob: so what is so terrible?
15:36:17 <beelsebob> edwardk: his response was "this is not original"
15:36:26 <edwardk> oh
15:36:27 <beelsebob> because his PhD student had some unpublished work on the same topic
15:36:28 * ddarius tends to use his eyes, but he's old fashioned.
15:37:14 <edwardk> =/
15:37:34 <beelsebob> note, I'm hypothesising here
15:37:49 <edwardk> heh
15:38:02 <beelsebob> I shouldn't really jump the gun
15:38:23 <beelsebob> oh well, time to write something telling them why it is original
15:38:47 <ddarius> Why is it original?  What is it?
15:39:40 <beelsebob> it's original because (a) his PhD student had published at most the basic idea behind it, and none of the gory details of how any of it worked (b) his PhD student having subsequently published his thesis, it turns out does it in a completely different way
15:39:54 <beelsebob> it... is a different way of dealing with algorithmic debugging
15:41:53 <matthew-_> sheesh, everyone else goes to the London HUG whilst ndm destroys Haskell!
15:42:05 <beelsebob> o.O
15:42:09 <Heffalump> eep, no more Haskell?
15:42:18 <beelsebob> actually I had the impression that ndm was fairly pro actually using Haskell
15:42:19 <petekaz> Is there a difference between currying and partial evaluation?
15:42:27 <ddarius> petekaz: Yes.
15:42:32 <beelsebob> rather than some convoluted thing that ghc compiles
15:42:49 <ddarius> They actually aren't really all that related.
15:42:49 <EvilTerran> currying is a process by which one can partially evaluate
15:42:54 <beelsebob> petekaz: being able to do partial application is something you get for free by having currying
15:42:56 <EvilTerran> or something
15:43:10 <ddarius> Maybe you mean partial application...
15:43:29 <Baughn> beelsebob: Except ghc doesn't do it, and you can have partial application without currying in the type system
15:43:34 <petekaz> ddarius: yes, I meant partial application as others have pointed out.
15:43:48 <beelsebob> Baughn: certainly -- but ghc simulates currying
15:44:01 <beelsebob> it may not be implemented that way -- but it is a simulation of currying
15:44:21 <petekaz> so .. what is (+1)?  Is this partial application or currying?
15:44:30 <beelsebob> it's a partial application
15:44:34 <ddarius> currying is the isomorphism between (a,b) -> c and a -> b -> c, partial application is just applying a function to less arguments than it takes which requires at least some instances of currying.
15:44:54 <petekaz> isomorphism?? (I'm retarded)
15:45:08 <Baughn> beelsebob: It simulates it a bit too well. I really thought it /did/ partial evaluation, so I wrote very slow programs.
15:45:17 <beelsebob> hehe
15:45:35 <petekaz> ddarius: what does that mean in practical terms?
15:45:46 <ddarius> A and B being isomorphic means that A and B are essentially the same without being exactly the same (and an isomorphism is the thing that shows how they are related).
15:45:55 <matthew-_> Baughn: that's better than writing really fast programs that don't work
15:46:18 <petekaz> In lisp, I can write a CURRY function to return a closure, is that currying?
15:46:23 <ddarius> Yes.
15:46:38 <ddarius> That is the only thing that is currying.
15:46:54 <petekaz> so partial application is just kinda "builtin" to a longuage?
15:46:59 <Baughn> matthew-_: True. Still, I've got "make the optimizer rewrite functions to maximize partial evaluation" on my todo-list somewhere. Good thing Map lets me write infinite ones.
15:47:14 <petekaz> And partial application could be implemented via currying?
15:47:18 <ddarius> Er, if you mean -the- curry function yes.  Not -every- function returning a closure is currying.
15:47:26 <petekaz> ddarius: right.
15:48:22 <ddarius> petekaz: Partial application requires "currying" somewhere and partial application is essentially how you use curried functions (at least categorically speaking...)
15:48:56 <ddarius> No, partial application is not built-in to a language.
15:49:02 <matthew-_> ddarius: are you an old school category theorist?
15:49:20 <ddarius> matthew-_: There are old and new school categorists?
15:49:45 <matthew-_> yeah, new school category theorists don't understand category theory ;(
15:49:49 <matthew-_> like me!
15:49:57 <edwardk> heh
15:50:12 <edwardk> i would think the latter are the 'haven't been to school' category theorists ;)
15:50:34 <matthew-_> yeah or "the damn course didn't so much as mention categories@"
15:50:41 <ddarius> If that's a necessary condition to be a new school categorist then I'm not a new school categorist.  I have a good grasp on it.
15:50:43 <DRMacIver> I disagree. I've been to school and I still don't understand category theory. ;)
15:50:48 <edwardk> heh
15:50:53 <matthew-_> hey DRMacIver!
15:51:06 <DRMacIver> (Where 'school' includes a category theory course naturally, otherwise the comment would be uninteresting)
15:51:08 <matthew-_> nice drinking with your earlier
15:51:09 <DRMacIver> Hi matthew-_
15:51:15 <DRMacIver> Likewise. :)
15:51:35 <edwardk> i picked up category theory by trying to figure out comonads ;)
15:51:44 <DRMacIver> Sorry we got separated at the station. The machine complained at me and held me up.
15:51:54 <matthew-_> no probs - I was going south anyway
15:51:55 <ddarius> I picked up category theory by banging my head against some books for a good while.
15:52:17 <matthew-_> ddarius: and what have you learnt as a result?
15:52:31 <DRMacIver> Category theory is vaguely starting to percolate into my brain.
15:52:36 <ddarius> "Pure" category theory and various applications.
15:52:37 <matthew-_> I mean, is it worth the pain - will it change me as a functional programmer?
15:52:41 <DRMacIver> But not to any 'useful' degree.
15:52:58 <matthew-_> sod that then :-P
15:53:00 <ddarius> matthew-_: Probably not all that much as a functional programmer.
15:53:28 <DRMacIver> matthew-_: No, sorry. That was a comment on percolating into my brain rather than on whether it will change you as a functional programmer. ;)
15:54:05 <DRMacIver> (I originally misread that as 'into a functional programmer' and was mildly flabbergasted0
15:54:25 <ddarius> E.g. learning about monads in category theory isn't going to make -that- much impact on monadic coding, but neither is it necessarily completely without application.  Also some "categorical" things that you can learn are very helpful.
15:54:33 <matthew-_> oh well. I know what a catamorphism and anamorphism is. That'll have to bide me over (until death)
15:55:18 <ddarius> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#calcfp
15:55:21 <lambdabot> Title: Jeremy Gibbons' Publications, http://tinyurl.com/y56qzx
15:55:24 <DRMacIver> Hm. "Real World Haskell" is gradually pervading my reader.
15:55:34 <edwardk> matthew: i find it to be useful, if you figure out functors and monads, you can move on to  catamorphisms and anamorphisms and get a new way to look at computation and how to fold together functions. Once you hit comonadic catamorphisms, and histomorphisms, and start looking for new comonads to code with you've probably gone too far and should turn back. ;)
15:56:09 <matthew-_> edwardk: yeah, I'll just write some code and see if it works...
15:56:18 <ddarius> There are other ways category theory can help, e.g. my demonstration of the free monad construction.
15:56:42 <ddarius> For general CS, limits characterize and generalize unification.
15:57:54 <geezusfreeek> i was looking into arrows earlier today and found it odd that arrows, which are a more general version of monads, are easier to understand than monads (to me, anyway)... in fact, i still am not 100% certain that i have such a great grasp on monads... anybody know if there is any way of thinking about monads downward from arrows rather than upward from some base foundation?
15:58:15 <ddarius> monads are Kleisli arrows.
15:58:36 <ddarius> Alternatively, anything thats an ArrowApply or whatever it's called, is a monad.
15:58:42 <geezusfreeek> okay, looking that up :) thanks
15:58:42 <ddarius> (and vice versa)
15:58:55 <petekaz> ddarius: thanks for the clarification of currying and partial application.  The latter implies the former, now I got it.  In LISP, I may be able to define CURRY, but to use it, I have to explicitly call it to get the closure, and then explicitly call that function.  But with partial application, this all happens automatically behind the scenes.
15:59:53 <ddarius> petekaz: Arguably.  You could say that Lisp sequence is partial application, and I probably would.
16:00:13 <tapi> @src take
16:00:13 <lambdabot> take n _      | n <= 0 =  []
16:00:13 <lambdabot> take _ []              =  []
16:00:13 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:00:15 <petekaz> ok.
16:00:24 <petekaz> ddarius: thanks!
16:00:44 <petekaz> (off to eat dinner, thanks again)
16:10:25 <Binkley> @yow
16:10:25 <lambdabot> Our father who art in heaven ... I sincerely pray that SOMEBODY at this
16:10:25 <lambdabot> table will PAY for my SHREDDED WHAT and ENGLISH MUFFIN ... and also
16:10:25 <lambdabot> leave a GENEROUS TIP ....
16:12:29 <freshhawk> can anyone give me a tip on installing an 'alternate' haskell lib, in this case the new bytestring + network.http lib, without replacing my current Network.HTTP
16:12:59 <dcoutts> freshhawk: so long as the package names are different you can have them both installed at once
16:13:13 <freshhawk> dcoutts, yeah, that's the issue, package name is the same
16:13:15 <monochrom> same package name, different version numbers is also ok.
16:13:15 <dcoutts> even though they define the same modules, just don't use both in a single program at once
16:13:24 <dcoutts> freshhawk: either change the name or the version
16:13:34 <monochrom> It is also possible to hide one version.
16:13:51 <dcoutts> so long as the version numbers are actually different
16:14:12 <freshhawk> ah right, version number...that's perfect. if it's not different i can mess with it. thanks guys
16:34:25 <sjanssen> @keal
16:34:25 <lambdabot> perhaps i just genius and never tested
16:34:33 <Binkley> @quote qwe1234
16:34:33 <lambdabot> qwe1234 says: oh come on, what do 'functional languages' have to do with lambda calculus?
16:34:34 <sjanssen> yes keal, perhaps
16:34:58 <SamB> ... is there a test for genius?
16:35:52 <procyon112> Yes.  It only costs a nominal fee and gets you into clubs where you can play D&D to your heart's content with other geniuses like yourself.
16:36:48 <EvilTerran> pardon?
16:36:58 <Philippa> there're other reasons to get an IQ test, FWIW
16:37:08 <Binkley> there are?
16:37:33 * EvilTerran reparses until the last few lines make sense
16:37:56 <Philippa> yeah. Like it's useful to demonstrate that your merely average academic performance has less to do with being merely average and more to do with, say, dyslexia
16:38:12 <Binkley> I'd think in that case it would be more effective to get tested for dyslexia
16:38:25 <Binkley> since in that case, an IQ test doesn't differentiate between dyslexia and, say, boredom :-)
16:38:53 <procyon112> Or any number of causes of underachievement.
16:39:17 <nominolo> freshhawk: for development we just named the lib HTTP1 and used that instead of the actual package.  so it should "just work".  there's a comment in "TestHTTP.hs" how to build it in ghc
16:40:22 <Philippa> Binkley: you can end up needing both, unfortunately. Or worse yet, needing the IQ test to get the dyslexia test done
16:40:52 <procyon112> I think there is a big difference between a test of IQ and a test for "genius".. the former exists legitimately (although what it measures exactly is controversial).  The latter is like testing for heroism in that it can't be done, and if someone claims it can, they're selling something.
16:40:53 <Binkley> well, in the US people with any sense generally put as much stock in IQ tests as in astrology
16:41:03 <Binkley> so I was (falsely) assuming that that was universal :-)
16:41:22 <Philippa> they're not quite that useless
16:41:44 <Philippa> I mean, they're far from the most useful tool ever, but odds are the kid with a genius-level IQ is actually smarter than average in some sense
16:41:58 <njbartlett> DRMacIver:
16:42:01 <Binkley> well, it's true that people with a high IQ are probably smart, but the converse doesn't hold
16:42:23 <dibblego> s/converse/inverse ?
16:42:33 <Binkley> me fail english? that's unpossible
16:43:06 <cdsmith> I stopped trusting IQ much, though, when I was tested as a kid, took two IQ tests in the same day, and scored 4 standard deviations different betweem the two!
16:43:11 <freshhawk> nominolo, thanks for the heads up, looks like i should have RTFM a little more
16:43:29 <nominolo> freshhawk: well, except that there is no Manual ;)
16:43:32 <dibblego> heh, Note: It should not (as is often done) be confounded with the contrary or opposite of a proposition, which is formed by introducing the negative not or no. [1913 Webster]
16:43:42 <nominolo> freshhawk: it's all hack in progress
16:44:19 <Philippa> cdsmith: one taken when you were tired, by any chance?
16:44:30 <nominolo> freshhawk: we're working on making it the next release of the http package, but i'd like to get the api right first (if possible)
16:44:30 <dibblego> when traversing a BTree, is each node simply a list with O(n) seek until you find an element the same as what is sought (base case) or greater than (in which case, you turn left) or end of list (turn right)?
16:44:53 <cdsmith> Philippa: I didn't feel that way.  It was, like, 20 years ago though.  Who knows?
16:45:13 <freshhawk> nominolo, well it was excellent timing, the night before i read the newsgroup I was messing with the annoying browser API. I though i would have to write some wrappers to make the API more LWP::UserAgent like
16:45:16 <nominolo> freshhawk: note though, that the api changed quite significantly (for the better IMO)
16:45:49 <nominolo> freshhawk: well, we're not actually touching that part of the api (yet)
16:46:25 <nominolo> freshhawk: if you feel like it, go for it.  or change the network.browser package to the appropriate type
16:46:35 <freshhawk> nominolo, for now, the simple get stuff is all i need luckily. but i might get around to it
16:47:00 <freshhawk> nominolo, although...i'm also writing a pure haskell fastcgi lib for ... "fun" ... is that the right word?
16:47:11 <nominolo> freshhawk: this is the idea behind the new error handling style: http://nominolo.blogspot.com/2007/05/towards-better-error-handling.html
16:47:12 <ddarius> cdsmith: Which one did you do better on the first or the second?
16:47:14 <lambdabot> Title: nominolo's Blog: Towards Better Error Handling, http://tinyurl.com/2327nn
16:47:26 <cdsmith> ddarius: I don't recall.
16:47:34 <moberg> hi, i've got at function f :: M [a -> a], and I want to fold (.) . If it wasn't monadic I would do "foldr1 (\x -> (.) x) f", how can I achieve this with the monadic function?
16:48:04 <nominolo> freshhawk: eventually, it might become that ;)  though, maybe you could take some code from HAppS?
16:48:06 <freshhawk> nominolo, yes, i read that a few days ago, I like it
16:48:10 <ddarius> :t foldM
16:48:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
16:48:18 <ddarius> No not that.
16:48:42 <ddarius> f :: M [a -> a] is not a function.
16:48:57 <EvilTerran> ?type liftM (foldr1 (.))
16:48:59 <lambdabot> forall b (m :: * -> *). (Monad m) => m [b -> b] -> m (b -> b)
16:49:07 <ddarius> what he said.
16:49:16 <EvilTerran> :D
16:49:20 <moberg> thanks
16:50:16 <dibblego> http://www.fing.edu.uy/inco/proyectos/fusion/tool/ how does the Leaf data type look (it's not in the source listing)?
16:50:19 <lambdabot> Title: HFusion: A Fusion Tool for Haskell Programs
16:50:59 <freshhawk> nominolo, yeah, i've read quite a bit of happs while doing this, it was helpful
16:51:12 <ddarius> nominolo: fail needs Error
16:52:57 <nominolo> ddarius: what do you mean?  is it missing from my examples?  anyways, you can give a bogus instance like: instance Error Foo where noMsg = undefined; strMsg _ = undefined
16:53:04 <EvilTerran> dibblego: data Btree a = Leaf a | Join (Btree a) (Btree a)
16:53:16 <EvilTerran>                          ^^^^^^
16:53:42 <dibblego> EvilTerran, oh thanks (my mistake) - that looks more like a binary tree
16:53:49 <EvilTerran> hehe
16:54:37 <ddarius> nominolo: When you write do Just x <- return Nothing; fail gets called.  In an Error-y monad you usually want fail to "throw an error".  Actually, even without the pattern matching aspect, you usually want that.
16:55:52 <JFT> Hello, I'm trying to use OpenGL and Glut on Mac OS X (10.4 and GHC 6.6.1)  and all I get is a white window with a frozen app. The same applicaton run at work (Windows XP 6.6) any idea? Thanks
16:56:44 <JFT> oups I meant this for #GHC sorry
16:56:51 <syntaxfree> JFT: Glut works out of the box here. Did you h
16:56:52 <nominolo> ddarius: so, you mean i should implement strMsg?
16:57:02 <nominolo> :t fail
16:57:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
16:57:07 <syntaxfree> JFT: Glut works out of the box here. Did you have it refresh the screen at the loop, or whatever it is in glutspeak?
16:57:19 <syntaxfree> @src fail
16:57:19 <lambdabot> fail s      = error s
16:57:29 <syntaxfree> @t error
16:57:29 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:57:32 <nominolo> looks deadly to me
16:57:36 <JFT> syntaxfree: nothing special, the same code work on Windows...
16:57:36 <syntaxfree> :t error
16:57:38 <lambdabot> forall a. [Char] -> a
16:57:38 <ddarius> nominolo: If you'd like, I don't care.  I don't really like fail being in Monad.
16:57:48 <syntaxfree> JFT: then again, I use 10.3.9
16:57:51 <ddarius> nominolo: That's a default implementation.
16:57:51 <syntaxfree> (and GHC 6.6.0)
16:57:57 <ddarius> @src Monad
16:57:57 <lambdabot> class  Monad m  where
16:57:58 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:57:58 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:57:58 <lambdabot>     return      :: a -> m a
16:57:58 <lambdabot>     fail        :: String -> m a
16:58:09 <JFT> I tried to use a "official" exemple
16:58:13 <JFT> and I get the same result
16:59:07 <nominolo> ddarius: i don't think that is a problem, because the http lib will use the fail your monad provides, but with throw its errors using throwError
16:59:32 <nominolo> ddarius: or what am i missing?
16:59:49 <JFT> syntaxfree: the following program has the same behavior http://darcs.haskell.org/packages/GLUT/examples/RedBook/Cube.hs
16:59:55 <nominolo> s/with/will
16:59:55 <ddarius> nominolo: I didn't say it was a problem, I was just explaining "who" needed them.
17:00:08 <JFT> syntaxfree: and you can hardly do simpler than that :(
17:00:09 <nominolo> ddarius: ah, ok.
17:00:15 <ddarius> As I said, I don't care for fail.
17:01:57 <nominolo> ah, ok, i found the code you were objecting to.  thanks for the pointer
17:05:21 <dibblego> is it possible to create a type-class that is simply the composition of two (or more) other type-classes?
17:06:00 <ddarius> dibblego: Typeclasses are predicates... they don't compose...
17:06:20 <nominolo> you could have a conjuction
17:06:37 <dibblego> I think maybe I am looking for something like this: class (Foo a, Bar a) => Baz a where
17:06:57 <dibblego> -- finished
17:07:09 <ddarius> You can do that.
17:09:23 <dibblego> data (Ord a) => BTree a = Nil | BNode (BinaryTree (a, BTree a)) -- does this look correct for a BTree? (I should be able to abstract away the BinaryTree though I think)
17:11:07 <Botje> dibblego: but it's a binary tree
17:11:25 <dibblego> Botje, what do you mean?
17:11:27 <Botje> so you know there're at most two child nods
17:11:29 <Botje> *nodes
17:11:32 <Botje> so you can encode this in the type
17:11:36 <dibblego> not in a BTree
17:11:40 <Botje> ehh
17:11:42 <Botje> oh yeah
17:11:48 <Botje> the Binarytree threw me off :)
17:11:52 <Botje> looks good, then
17:12:00 <dibblego> the BinaryTree would be a fixed size (maximum)
17:12:12 <dibblego> or, I could use an array, or even another BTree
17:12:14 <Botje> you could just use a [(a, BTree a)] too
17:12:21 <dibblego> which is why I think I could abstract it
17:12:32 <dibblego> yes, but then that's a linear search
17:13:04 <Botje> depends how big your btree is, of course
17:13:20 <Botje> for less than 10 elements, I wouldn't bother to use a btree
17:13:28 <Botje> *binarytree
17:13:29 <dibblego> well, if the list is maximum length 3, it shouldn't matter
17:13:41 <dibblego> well, that's why I'd like to abstract it
17:13:59 <dibblego> to a type-class perhaps (thinking...)
17:14:19 <Botje> certainly an option.
17:15:56 <dibblego> ok cheers
17:17:16 <ddarius> Just abstract it out.
17:17:27 <dibblego> yeah, I'm thinking of the operations
17:17:40 <dibblego> and my Haskell is rusty because I have been tainted by Scala for the last few months
17:18:45 <syntaxfree> what is Scala like?
17:18:57 <syntaxfree> I know it runs on the JVM or something.
17:19:15 <dibblego> a lot noisier, but a whole load better than say Java; and it has the advantage of appealing to the incompetent higher authority
17:19:33 <dibblego> yes, it uses Java APIs transparently (this is a huge advantage for the monkeys)
17:19:38 <syntaxfree> why does it appeal to the higher authority and how is it better than Java itself?
17:19:56 <JFT> type inference
17:20:03 <JFT> more expressive
17:20:06 <syntaxfree> oh. it's system-F Java?
17:20:14 <syntaxfree> or is it not like Java at all?
17:20:21 <dibblego> it appeals because it is effectively Java i.e. you deploy as a jar file, you use Java types, etc. it is better than Java because it has type inference, HOFs and a load of other cool things - though, it is a lot noisier than Haskell
17:20:22 <njbartlett> syntaxfree: It's about half between Haskell and Java, but remaining compatible with Java
17:20:28 <njbartlett> half way, even
17:20:33 <SamB> syntaxfree: being Java-related makes it appeal to PHBS
17:20:35 <SamB> er.
17:20:37 <syntaxfree> interesting. I'm fascinated by Mercury at the moment.
17:20:37 <SamB> PHBs
17:20:40 <dibblego> yes, what njbartlett said is pretty accurate
17:20:51 <JFT> also it used to run on the CLR too (not sure if it still does)
17:20:53 <syntaxfree> It's about halfway between Haskell and Prolog :)
17:20:55 <ddarius> syntaxfree: You are?
17:20:59 <dibblego> JFT, it doesn't anymore
17:21:13 <ddarius> syntaxfree: I'd probably recommend Curry more...
17:21:25 <syntaxfree> I'm really trying to decide on a logic language.
17:21:31 <JFT> A co-worker is trying to lure me to Scala but honestly after Haskell Scala is VERY lackluster IMVHO
17:21:33 <syntaxfree> Oz is appealing, but The Big Book is so bloody arrogant.
17:21:40 <dibblego> I can write an application in Java, expose a Java API and an organisation's Java monkeys can use it
17:21:51 <syntaxfree> JFT: otoh, having libraries for everything must rock.
17:21:54 <njbartlett> JFT: I agree but if you absolutely have to run on the JVM, Scala is a lot better than the Java language
17:22:03 <JFT> True
17:22:03 <ddarius> syntaxfree: I'd go whole hog and get a language based on abstract logic programming.
17:22:04 <SamB> dibblego: why would you want to write something in Java?
17:22:16 <syntaxfree> ddarius: I like how Haskelly Mercury is.
17:22:20 <syntaxfree> Despite the ugly syntax.
17:22:21 <dibblego> SamB, because Organisation X is filled with Java monkeys who insist
17:22:36 <SamB> dibblego: wouldn't you rather use another language...
17:22:36 <dibblego> SamB, I don't proclaim to have an overriding *rational* reason
17:22:41 <dibblego> SamB, of course!
17:22:42 <ddarius> syntaxfree: Talk to Pseudonym about Mercury some time.
17:22:53 <dibblego> SamB, any language just about even
17:22:56 <syntaxfree> ddarius: I'm really playing with examples from the tutorials, still.
17:23:08 <syntaxfree> In my copious free time. Right now I'm waiting for some GNU R packages to install.
17:23:08 <monochrom> I write in Java because I enjoy it!
17:23:19 <SamB> monochrom: we don't belieeeeeve you
17:23:22 <syntaxfree> I have to write LOTS of R code tonight to get some work for my microeconometrics class done.
17:23:22 <ddarius> I write in C++ because I enjoy it.
17:23:30 <Binkley> YKIOK, IJNMK
17:23:38 <dibblego> SamB, imagine an organisation filled with Java monkeys who *insist* on using Java; you're tasked with writing an API for them - what language do you use?
17:23:48 <SamB> dibblego: anything but JAva
17:23:49 <syntaxfree> There's no package in R for Arellano-Bond GMM-DIF estimators.
17:24:14 <syntaxfree> Stata has one, but I can't find an, um, uh, buccaneer-american copy of Stata for OS X.
17:24:21 <monochrom> I like Java so much I teach it to my friends. http://www.cs.toronto.edu/~trebla/javacourse/
17:24:22 <dibblego> I am teaching my son that the notion of "Java programmer" is as absurd as the notion of a "hammer carpenter"
17:24:23 <lambdabot> Title: Albert's Java Course
17:24:37 <Binkley> my favorite term for piracy is "non-legal information cultures"
17:24:37 <JFT> dibblego: good thing :)
17:24:42 <SamB> dibblego: I think it is more absurd
17:24:49 <migraine_> I prefer the adjustable flame wrench mechanic
17:24:57 <dibblego> SamB, me too, since a hammer can be useful in certain situations
17:24:58 <syntaxfree> R turns out to be very lacking in advanced econometrics, it seems. It was taken over by nonparametric folks like the epidemiologists.
17:25:07 <SamB> dibblego: exactly
17:25:10 <SamB> actually a lot of situations
17:25:51 <dibblego> SamB, the point is, declaring oneself a "Java programmer" is pretty darn silly - "oh, sorry, I only use Java, because I'm too retarded to learn"
17:26:20 <monochrom> I'm a Chinese programmer.
17:26:20 <SyntaxNinja> Haskell jobs yay: http://www.haskell.org/pipermail/haskell-cafe/2007-May/025851.html
17:26:21 <SyntaxNinja> :)
17:26:22 <lambdabot> Title: [Haskell-cafe] Software Engineer, Functional Programmer, Team/Project lead posit ..., http://tinyurl.com/ypuhcd
17:26:23 <syntaxfree> hmm. I never thought of Java as particularly easy to learn. Too much syntax.
17:26:29 <SamB> syntaxfree: yeah.
17:26:40 <SyntaxNinja> I'm so excited to hear dons, et al's book!
17:26:48 <monochrom> But you're syntaxfree, you're biased.
17:26:51 <migraine_> well a lot of it comes from companies that used to let code be in whatever language the developer feels like and then spent the last 5 years downsizing and cleaning up the old crap
17:26:53 <dibblego> the hyperbole far exceeds the complexity of the syntax
17:27:07 <syntaxfree> dons et al is th eone getting published by O'Reilly?
17:27:18 <JFT> syntaxfree: Java is simple enough, it just requires you to memorise the 1e9999 functions and library
17:27:24 <SamB> syntaxfree: well, not so much *syntax* as *verbosity*, afaik...
17:27:46 <ddarius> syntaxfree: Yes.
17:27:51 <ddarius> dons, bos, and CosmicRay
17:27:51 <syntaxfree> @remember [syntaxfree] hmm. I never thought of Java as particularly easy to learn. Too much syntax. [monochrom] But you're syntaxfree, you're biased.
17:27:51 <lambdabot> Done.
17:28:06 <syntaxfree> wow. dons is gonna rake in dem bux.
17:28:22 <syntaxfree> @quote
17:28:23 <monochrom> You're missing attribution.
17:28:23 <lambdabot> nilsi says: #haskell is better than google
17:28:29 <monochrom> @quote [syntaxfree]
17:28:29 <lambdabot> [syntaxfree] says: hmm. I never thought of Java as particularly easy to learn. Too much syntax. [monochrom] But you're syntaxfree, you're biased.
17:28:50 <dibblego> @message dons well done mate. we desperately need a "not-beginners" Haskell book
17:28:50 <lambdabot> Maybe you meant: messages messages?
17:28:57 <ddarius>  @tell
17:29:00 <dibblego> ta
17:29:03 <dibblego> @tell dons well done mate. we desperately need a "not-beginners" Haskell book
17:29:03 <lambdabot> Consider it noted.
17:29:10 <syntaxfree> @tell dons Hey! Congrats on the great news.
17:29:10 <lambdabot> Consider it noted.
17:29:22 <dibblego> do the co-authors hang here?
17:29:23 <monochrom> We need strong static type checking for @remember :)
17:29:36 <ddarius> [19:25] <ddarius> dons, bos, and CosmicRay
17:29:40 <syntaxfree> we need a curry mechanism for @.  first.
17:29:42 <dibblego> oh cool
17:29:45 <syntaxfree> @. is almost useless as it stands now.
17:29:45 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "is"
17:29:56 <syntaxfree> @. elite quote
17:29:56 <lambdabot> nar4iN sAy5: 5aYz Y4W9NIMEH: y0u AIN'T \/\/eirD1y G0nna NeED i+. /\/\E|-|.
17:31:03 <CSWookie> HEy folks.  I'm looking at a haskell tutorial, is it possible to not write functions s one-liners?
17:31:19 <syntaxfree> CSWookie: yep. Just use "where".
17:31:23 <ddarius> CSWookie: Uh... yeah.  Rarely are they.
17:31:33 <JFT> Is Opengl/Glut broken in GHC 6.6.1 broken on Intel Mac?
17:31:37 <monochrom> You can certainly split lines at the = sign
17:31:48 <JFT> CSWookie: not wih ghci if that's what you mean
17:31:58 <CSWookie> I'm using hugs.
17:32:07 <syntaxfree> CSWookie: Haskell is so concise that things that'd take 5 lines in ordinary imperative code often boil down to one well-placed map or foldr.
17:32:13 <monochrom> When you write "f = g . h . i" you can also split at the dots
17:32:14 <JFT> same thing single liner
17:32:41 <CSWookie> syntaxfree: Maybe so, but right now it's just an ugly one liner, and I'd like to split my ideas a bit more.
17:32:49 <monochrom> We are, of course, talking about writing functions in a source code file. We have perfect mutual understanding.
17:32:57 <syntaxfree> CSWookie: just use where.
17:33:23 <syntaxfree> > map this that where { this = (+1); that = [1..10]}
17:33:23 <lambdabot>  Parse error
17:33:27 <CSWookie> OK.  So the interpreters don't allow for line breaks, but source code does.
17:33:31 <CSWookie> Good enough.
17:33:33 * syntaxfree cries
17:33:49 <syntaxfree> > map this that where { this = (+1); that = [1..10];}
17:33:50 <lambdabot>  Parse error
17:33:56 <syntaxfree> hey, wtf?
17:34:00 <monochrom> nowhere
17:34:07 <ddarius> where is not an expression.
17:34:09 <JFT> CSWookie: it has to do with Haskell beeing "Top-down" and lazy (somebody more knowledgeable could explain :P)
17:34:13 <wolverian> monochrom, you want let.
17:34:15 <Binkley> > map this that where { this = (+1); that = [1..10] }
17:34:15 <lambdabot>  Parse error
17:34:24 <monochrom> I know let.
17:34:26 <ddarius> JFT: It has to do with Haskell implementors being lazy (in this area)
17:34:35 <JFT> lol
17:34:39 <JFT> not what I meant
17:34:41 <JFT> ;
17:34:44 * syntaxfree twiddles his thumbs while R chugs and whistles.
17:35:00 <ddarius> R sounds like a rude bastard.
17:35:11 <syntaxfree> R is Lispy.
17:35:11 <JFT> lol definitively not what I meant :P
17:35:40 <syntaxfree> no S-expressions and vector/matrix-based, but supports first-class functions and has a CLOS-y OO system.
17:36:09 * wolverian hears the echoes of dylan
17:36:43 <syntaxfree> it leads to a few WTFs. Some methods, like "diff" or "lag" don't work unless you use proper "ts" (time-series) objects and functions prepared to act on them.
17:37:04 <syntaxfree> (When writing diff and lag for arbitrary vectors so home-spun functions not willing to jerk around with the OO system would work)
17:37:18 <syntaxfree> but all-in-all, it makes for forward-planning, scalable architecture.
17:37:58 <hoelzro> this is probably a terribly stupid question, but how do I get haddock to recognize Prelude types?
17:38:20 <syntaxfree> if it's a terribly stupid question, I'm (terribly . terribly) stupid.
17:39:37 <hoelzro> I'm trying to generate some documentation, but I get the error:  the following names could not be resolved:  Ptr CUInt
17:39:47 <hoelzro> so I guess my question doesn't really involve the prelude
17:39:49 <CSWookie> Ah.  I do like lots of vertical whitespace.
17:41:01 <monochrom> It is not a great error. If you can tolerate all mentions of Ptr, CUInt not linking to anywhere, it's fine.
17:41:33 <hoelzro> I can tolerate, but I'd rather have it so they link to the appropriate module docs.
17:41:55 <hoelzro> unless the only way to do this is to build my docs with the Haskell standard library docs
17:42:00 <hoelzro> in which case I don't care that much =P
17:42:11 <monochrom> There is also a way for that. I forgot the details. Dig deeply into the doc.
17:42:29 <syntaxfree> @quote deeply
17:42:30 <lambdabot> lispy says: Korollary: i bet you have this deeply secret side where you like kittens and rainbows
17:42:46 <hoelzro> alright; I just wanted to make sure I couldn't get a quick answer before digging
17:43:07 <ddarius> Who, exactly, doesn't like kittens and rainbows?
17:43:41 <syntaxfree> @quote who
17:43:41 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
17:44:04 <Botje> @quote kitten
17:44:05 <lambdabot> lispy says: Korollary: i bet you have this deeply secret side where you like kittens and rainbows
17:44:06 <ddarius> *sigh*  The problem with monad tutorials...
17:44:06 * Pseudonym doesn't know what writing a book would make you
17:44:17 <gravity> Are people still writing monad tutorials?
17:44:19 <syntaxfree> @quote problem
17:44:20 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
17:44:20 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
17:44:20 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
17:44:22 <Pseudonym> I think that writing a monad tutorial is one of the best ways to understand monads.
17:44:33 <njbartlett> What am I if I haven't even written a monad tutorial?
17:44:35 <Pseudonym> That's not a joke.
17:44:45 <ddarius> Pseudonym: Probably, but reading them isn't...
17:44:52 <Pseudonym> Indeed.
17:44:56 <Binkley> Monad tutorials: a write-only medium
17:44:58 <syntaxfree> the best monad tutorial out there is the Patryshev one.
17:45:08 <syntaxfree> Where it explains WTF a monad actually /is/.
17:45:08 <Pseudonym> @remember Binkley Monad tutorials: a write-only medium
17:45:08 <gravity> I got a lot out of some of them
17:45:08 <lambdabot> Done.
17:45:29 <ddarius> gravity: There are a few good ones... and many many poor or even misleading ones.
17:45:34 <gravity> ddarius: True enough
17:45:35 <syntaxfree> @quote misleading
17:45:36 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:45:53 <ddarius> syntaxfree: Are you aware of the old QuotesPage on hawiki?
17:46:22 <syntaxfree> ddarius: not sure. But I'm happy to plau with @quote in a private chat with \bot.
17:46:25 <ddarius> @oldwiki QuotesPage
17:46:26 <lambdabot> http://www.haskell.org/hawiki/QuotesPage
17:46:26 <CSWookie> Hmm.  Haskell style seems to lean toward small names for things.  IS this true?
17:46:32 <monochrom> I like monads so much I teach it to my friends. http://www.cs.toronto.edu/~trebla/fp/
17:46:33 <lambdabot> Title: Albert's Functional Programming Course
17:46:39 <jfredett> I wish I had a job..
17:46:40 <ddarius> CSWookie: Not exactly.
17:46:44 <jfredett> :(
17:46:51 <syntaxfree> I wish I had a nose. Oh, wait, I do have a nose.
17:47:10 <ddarius> jfredett: Lies!  I'm willing to bet you only wish you had the money a job would bring in.
17:47:23 <jfredett> ddarius, no, really, I want a job
17:47:24 <monochrom> Hahaha, The Monad Writer!
17:47:27 <CSWookie> ddarius: Having a job rocks.
17:47:28 <sjanssen> CSWookie: yes, parameters to functions are generally short
17:47:29 <jfredett> I'm bored out of mine
17:47:43 <jfredett> syntaxfree, damn, I was hoping to sell you my nose..
17:47:47 <jfredett> s/mine/mind
17:47:57 <ddarius> jfredett: If you had a pile o' money and no job, I bet you could solve that...
17:48:00 <njbartlett> Having a job is great. It gives me an excuse not to spend all my time with the wife.
17:48:27 * Binkley emails that comment to njbartlett's wife
17:48:38 <ddarius> You want to solve his problem Binkley?
17:48:39 <syntaxfree> @remember [jfreddet]  I wish I had a job.. [syntaxfree]  I wish I had a nose. Oh, wait, I do have a nose. [jfredett] syntaxfree, damn, I was hoping to sell you my nose..
17:48:39 <lambdabot> Done.
17:48:57 <jfredett> ddarius, I'm sure I could get by w/ a big pile of $
17:49:07 * syntaxfree generally enjoys himself in a mindless way.
17:49:07 <jfredett> ddarius, but I'd really really like a job.
17:49:51 <ddarius> I was going to add a copout along the lines of "sense of fulfilment" or somesuch.
17:49:52 <syntaxfree> well, it's back to work for me.
17:50:00 <jfredett> ddarius, trouble is, I'm a math student, and even though I'm a wonderful programmer, everyone assumes I'm a bad programmer cause I'm a math major.
17:50:15 <ddarius> Ugh, horrible horrible math code...
17:50:23 <Botje> jfredett: write some (haskell) code, prove them wrong! :)
17:50:38 <ddarius> Write Haskell and say it's math!
17:50:45 <Binkley> Write math and say it's Haskell!
17:50:49 <edwardk> monochrome: monad writer?
17:50:52 <CSWookie> jfredett: My limited acquaintance with math students would lead me to draw the same conclusion.
17:50:55 <ddarius> jfredett: What job do you want?
17:51:14 <jfredett> Botje, I did, didn't help much, (I wrote a Neural net based Music generator, it works pretty well, actually)
17:51:41 <CSWookie> I on the other hand, studied computers, and only have a vague understanding for math.
17:51:58 <jfredett> ddarius, preferably something math oriented, but I can do any kind of programming needed, so-- software dev kind of stuff
17:52:21 <ddarius> jfredett: What did you think you wanted to be when you became a math major?
17:52:22 <jfredett> CSWookie, Typically, people deal w/ actuaries and not mathematicians. Real Math Majors write Code... :)
17:52:43 <jfredett> ddarius, Well, I'm interested in Applied Math and speficially Applied Logic.
17:52:58 <ddarius> Oh, so you're a programmer.
17:53:04 <jfredett> ddarius, so I was hoping to apply some math to some computers
17:53:09 <jfredett> ddarius, effectively, yes.
17:53:20 <jfredett> ddarius, but a stupid one, because I didn
17:53:25 <jfredett> 't double major
17:53:33 <edwardk> jfredett: what are you looking to learn?
17:53:33 <jfredett> brb
17:53:39 <edwardk> heh (i went the double major route) =)
17:53:41 <jfredett> edwardk, everything? :)
17:53:46 <edwardk> fair enough
17:54:05 <ddarius> forall a.a
17:54:09 <CSWookie> jfredett: They wrote code.  Poorly.
17:54:36 <ddarius> Programming = applied logic
17:55:08 <newsham> is a diseased potato really going to be the logo for ORA's haskell book? :)
17:55:09 <jfredett> CSWookie, Well, Applied Logic ala Automated Theorem Proving.
17:55:17 <newsham> congrats dons and crew.. I eagerly await the book
17:55:26 <Binkley> ?remember newsham is a diseased potato really going to be the logo for ORA's haskell book? :)
17:55:27 <lambdabot> Done.
17:55:27 <edwardk> is there a link to something about the book?
17:55:40 <newsham> http://www.realworldhaskell.org/blog/
17:55:40 <lambdabot> Title: Real-World Haskell
17:55:49 <ddarius> @where book
17:55:49 <lambdabot> I know nothing about book.
17:56:01 <ddarius> @where+ book http://www.realworldhaskell.org/blog/
17:56:01 <lambdabot> Done.
17:56:06 <kfish> there is only one book!
17:56:12 <nominolo> @where realworld
17:56:12 <lambdabot> I know nothing about realworld.
17:56:16 <SamB_XP> I thought it was going to be something riding a unicycle!
17:56:32 <newsham> read "programming in haskell" graham hutton yesterday.  good read, but a little thin.
17:56:34 <ddarius> SamB_XP: The diseased potatoe can ride a unicycle.
17:56:40 <CSWookie> Hmm.  So I'm looking at this tutorial, and it defines defines a length function as having the type [a]->Integer.  What does the 'a' signify?
17:56:52 <Binkley> CSWookie: a is a type variable
17:56:53 <ddarius> A type variable.
17:57:00 <ddarius> Implicitly universally quantified.
17:57:02 <Binkley> it means that length takes a list of elements of any type, and returns an Integer
17:57:03 <nominolo> CSWookie: literally "anything"
17:57:35 <CSWookie> is it important that it be a?  could be b?  Or tribble?
17:57:44 <Binkley> in this case, it could be anything
17:57:45 <ddarius> No, it just has to be lowercase.
17:57:47 <Binkley> since it's only used once
17:57:49 <CSWookie> OK.
17:57:59 <edwardk> CSWookie: any type, lower case names in types are placeholder variables that are quantified over all types. Int, Bool, Int -> Bool, (Int -> Int) -> Int -> Bool
17:58:20 <edwardk> any lower case variable name implicitly gets a 'forall' wrapped around your type
17:58:33 <edwardk> id :: forall a. a -> a
17:58:35 <edwardk> @type id
17:58:37 <lambdabot> forall a. a -> a
17:58:43 <nominolo> @type length
17:58:45 <lambdabot> forall a. [a] -> Int
17:58:48 <ddarius> Explicit foralls are not Haskell 98
17:58:50 <edwardk> even though it'll normally just show up as id :: a -> a
17:59:17 <edwardk> because of the way Haskell 98 specified the language
17:59:20 <CSWookie> Guys I just started reading the tutorial 10 minutes ago.  Your syntax doesn't yet hold meaning.
17:59:33 <edwardk> CS: woops =)
18:00:38 * ddarius thinks about making a sketch of the diseased potato riding a unicycle.
18:00:48 <edwardk> CSWookie: basically you could give it any name, as long as it starts with a lower case letter.
18:00:54 <Binkley> how about a diseased unicycle riding a potato?
18:01:09 * ddarius doesn't know what a diseased unicycle looks like.
18:01:15 <Binkley> me neither
18:01:31 <CSWookie> Binkley: It's bicycle, because it has an unexpected growth.
18:01:34 <Binkley> heh
18:01:41 <SamB_XP> I don't like to eat diseased potatoes
18:01:44 <Binkley> one wheel good, two wheels bad?
18:02:09 <newsham> its a lambda, it's a binary tree, it's a diseased potato
18:02:10 <ddarius> Neither did the Irish and look what happened to them
18:02:32 <dons> moin
18:02:32 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:02:59 <newsham> congrats dons
18:03:04 <dons> cheers
18:03:18 <dons> we get to take over the world with our lambdas now, right?
18:03:36 <ddarius> Every day it's looking more and more that way.
18:03:42 <newsham> i've been infiltrating our tech people with subversive lambda literature
18:04:09 <ddarius> Lambda the Ultimate Buzzword?
18:04:13 <dons> hah
18:04:27 <dibblego> I am trying to get rid of the BinaryTree in this: data (Ord a) => BTree a = Nil | BNode (BinaryTree (a, BTree a)) to use this type-class instead: class (Eq b) => BoundedContainer a b where, but my attempts are failing; what have I screwed up?
18:04:52 <ddarius> dibblego: We have no idea.
18:05:22 <dibblego> ddarius, have I screwed up nothing? if so, what is the correct syntax to use the multi-param type-class?
18:05:57 <sjanssen> dibblego: you're trying to use a class as a type?
18:06:09 <ddarius> That's the correct syntax to use multiparameter type classes.
18:06:11 <dibblego> sjanssen, not at all
18:06:24 <dibblego> ddarius, yes, but change the definition of BTree to use it - I keep failing
18:06:35 <ddarius> dibblego: No one knows what your problem actually is.
18:06:46 <dibblego> I tried this for example: data (Ord a, BoundedContainer b) => BTreeX a = NilX | BNodeX (b (a, BTreeX a))
18:06:46 <CSWookie> Blah.  What's an example of a nifty framework written in haskell?
18:06:53 <CSWookie> I'm tired of reading tutorial.
18:07:07 <ddarius> CSWookie: What kind of things do you find nifty?
18:07:23 <ddarius> BoundedContainer takes two arguments
18:07:28 <dibblego> yes, I tried that too
18:07:50 <ddarius> You also need to abstract out the b.
18:07:50 <beelsebob> *giggle* just calculated the number of board configs for go
18:07:51 <CSWookie> ddarius: Whatever.  Recommend me something that takes advantage of haskell's strengths, and which you feel shows good style.
18:07:53 <beelsebob> 17408965065903192790718823807056436794660272495026354119482811870680105167618464984116279288988714938612096988816320780613754987181355093129514803369660572893075468180597603
18:08:05 <dibblego> erm, I just got it
18:08:26 <ddarius> CSWookie: Parsec is pretty nice, but you need something to do with it.
18:08:47 <ddarius> Most people end up falling in love with Parsec.
18:08:52 <dibblego> dons, are you looking for amateur reviewers? i.e. those who you wish to target as an audience?
18:08:58 <Philippa> CSWookie: most of the time we don't do frameworks, they're too specialised
18:09:15 <Philippa> we're too fond of polymorphism to want to roll up with yet /another/ custom string type, for example
18:09:16 <dibblego> dons, as opposed to technical reviewers with strong Haskell
18:09:42 <dibblego> dons, I could get rid of all your superfluous commas if you like :)
18:09:54 <dons> i think we're mostly looking for technical reviewers.
18:09:55 <CSWookie> Philippa: I see.
18:10:05 <dibblego> dons, ok, no problem
18:10:43 <Philippa> CSWookie: we get things that look a bit like frameworks sometimes, but they tend to end up as a few hundred lines of code defining a combinator library and that's it
18:10:48 <CSWookie> Philippa: Well, the 'Gentle introduction' is about as interesting as a stick.  I think I'll do better if I start working with a code library that's been well written and use the references to help me figure out what's going on.
18:11:24 <ddarius> Parsec might actually be a good instance if a bit quirky.
18:11:28 <edwardk> CS: http://darcs.haskell.org/ has a ton of projects on there you can browse around
18:11:29 <lambdabot> Title: Index of /
18:11:33 <SamB_XP> I was going to say Parsec, too
18:11:41 <Philippa> yeah, though you want to have the paper to hand too
18:11:47 <SamB_XP> yeah.
18:11:53 <Philippa> it does just enough subtle stuff to cause some "WTF" otherwise
18:11:59 <SamB_XP> and the Parsec tutorial
18:12:07 <edwardk> Parsec is pretty inspiring if you ever had to write something using lex and yacc.
18:12:24 <SamB_XP> edwardk: even if you haven't!
18:12:28 <edwardk> =)
18:12:30 <ddarius> As I said, most people fall in love with Parsec.
18:12:31 <cdsmith> CSWookie: you know what works for you.  I learned Haskell not too long ago and had success with just picking easy but non-trivial tasks and jumping in.
18:12:44 <SamB_XP> heck, even alex and happy are inspiring compared to lex and yacc...
18:13:07 <edwardk> Heh I started with writing a javascript compiler, then decided that I'd enjoy myself more if i wrote something with a real type system ;)
18:13:27 <ddarius> javascript is an OK language
18:13:41 <cdsmith> ddarius: I agree.  It is a very nice language, IMO
18:13:43 <SamB_XP> ddarius: but doesn't give you a chance to write a typechecker
18:13:56 <edwardk> ddarius: don't get me wrong. Its not a bad little semi-functional language. I even have a javascript compiler written in javascript
18:14:05 <edwardk> But yeah, you can't typecheck it =)
18:14:16 <CSWookie> I've just seen lots of folks wander into #python talking about how great Haskell is.  I figured I'd give it a look.
18:14:30 <edwardk> Well, with ECMAScript 4 you have types and classes and stuff to typecheck at least
18:14:54 <edwardk> CSWookie: what kind of things do you like to or tend to code?
18:14:56 <CSWookie> I learned python by reading Zope source code, so I figured if there were some similar behemoth I could digest over time in Haskell, that would be a good attack.
18:15:10 <edwardk> CSWookie: lambdabot is fairly monolithic
18:15:18 <dons> hm. you could read xmonad? it's pretty nice. but there's lots of nice programs out there.
18:15:31 <ddarius> HWS
18:15:31 <edwardk> xmonad is also pretty good, both of those interact with the real world on some level
18:15:56 <dons> have a look on hackage.haskell.org for something that catches your eye.
18:15:57 <cdsmith> edwardk, CSWookie: I don't see lambdabot as good reading for someone new to haskell. :)  But perhaps I've only been looking at the hard parts.
18:16:04 <dons> or say, install the base library and read that. its very nice.
18:16:27 <edwardk> cdsmith: lambdabot was tricky because of the plugins, but it showed that there was some meat on the bones of the language ;)
18:16:32 <dons> yeah
18:16:33 <ddarius> I'd probably agree about lambdabot.  lambdabot is more for newbie-writing than newbie-reading.  At least last I checked.
18:16:38 <dons> and the first class modules.
18:16:51 <CSWookie> Well, I'm not worried about whether it's easy.  I'm a fairly competent programmer, so I'll pick it up.  I just don't want to learn the wring habits.
18:16:58 <CSWookie> s/wring/wrong./
18:17:02 <CSWookie> bah.
18:17:13 <CSWookie> Typing is hard, lets go shopping.
18:17:23 <dons> i think starting with the base library is a good start.
18:17:29 <dons> ?src Data.List
18:17:29 <lambdabot> Source not found. stty: unknown mode: doofus
18:17:35 <dons> ?source Data.List
18:17:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:17:36 <cdsmith> dons: good suggestion
18:17:52 <ddarius> Indeed, you also get the benefit of learning the standard libs.
18:17:59 <edwardk> nice thing about starting there is once you're done you can use the methods you find there in anything you write
18:18:02 <ddarius> But occasionally the code is out there.
18:18:04 <edwardk> some of them are pretty slick
18:18:30 <edwardk> I find the more that I learn about what is in the standard libs the less I need to actually code anything at all. ;)
18:18:52 <dons> ?users
18:18:52 <lambdabot> Maximum users seen in #haskell: 340, currently: 296 (87.1%), active: 46 (15.5%)
18:21:27 <dibblego> is there a data (Ord a) => SortedList a?
18:21:59 <sjanssen> not in base/
18:35:43 <Binkley> @yow
18:35:43 <lambdabot> Hey, waiter!  I want a NEW SHIRT and a PONY TAIL with lemon sauce!
18:35:43 <dons> mm. lemon.
18:35:43 <LoganCapaldo> > [1..3] >> [1,2,3]
18:35:43 <lambdabot>  [1,2,3,1,2,3,1,2,3]
18:35:52 <sjanssen> I'm enjoying this cryptic ICFP contest blog
18:36:20 <dons> its fun, isn't it.
18:45:31 <Nafai> dons: Excited to see the book that you guys are working on!
18:45:36 * gravity too
18:45:54 <gravity> If I get to see CosmicRay again I'll have him autograph it
18:46:52 <dons> heh
18:48:10 <dino-> dons: Yes, congratulations on the book to you three. From the proposed chapter list it sounds like a great deal of important stuff.
18:48:51 <dons> dino-: yeah, the stuff you need hopefully.
18:49:07 <dino-> dons: Definitely a lot that I need to read about and keep studying.
18:49:26 <gravity> I'm excited to see it come out in pieces. It'll be fun to go through it as it comes out.
18:49:40 <dino-> btw, I am two weeks into a new job (Perl programming), but there is a great deal of interest there in Haskell. I had put it on my resume and they were asking me a lot during interviewing..
18:49:48 <dons> hopefully this greatly improves the quality, and we won't miss any key topic
18:49:53 <dino-> I'm hopeful the potential is there to work the big H into this company somehow.
18:50:08 <dons> it would be great to have a standard reference the community cn use.
18:50:32 <dons> dino-: interesitng, i've had a few other people say that just having the book would be useful for getting adoption.
18:51:04 <syntaxfree> grrr. crummy text editors that crash.
18:52:09 <syntaxfree> dino-: Pugs did that, I gues :)
18:52:48 <dino-> dons: This strikes me that way too, as the post says "real world". A lot of topics here that are practical.
18:53:29 <syntaxfree> dons: I agree on that. O'Reilly does have a reputation.
18:53:51 <dino-> syntaxfree: Definitely some people in this company who are familiar with the now legendary Pugs achievement. Also some who are very hopeful about P6.
18:53:55 <gravity> dons: The pickaxe did a ton for the ruby community. If you guys pull it off, it should be a similar catalyst if people are interested
18:54:09 <syntaxfree> a book like that sets Haskell apart from, say, Io/Qi/Charity/insert impractical research lang here.
18:54:11 <SamB_XP> dons: any word on the mascot?
18:54:30 <gravity> A lamb!
18:54:38 <LoganCapaldo> to the slaughter?
18:54:58 <syntaxfree> can't they put an unicycle?
18:55:00 <gravity> I hope not
18:55:16 <syntaxfree> Haskell deserves an eccentric animal, like an ostrich.
18:55:33 <sjanssen> the evil bird from the Japanese Haskell book?
18:55:39 <LoganCapaldo> Ostriches are eccentric?
18:55:39 <syntaxfree> <-- fanboy mode.
18:55:48 <dons> not sure about lamb. some big animal with funny bits.
18:55:50 <syntaxfree> get ready for fashionable haskellistas :P
18:55:59 <allbery_b> emu?
18:56:03 <syntaxfree> is the ornitorrinc (sp?) already taken?
18:56:05 <dons> some animal that can crush its enemies, but is shy.
18:56:09 <syntaxfree> @spell ornitorrinc
18:56:10 <dons> hmm an emu. not a bad idea.
18:56:18 <SamB_XP> preferably able to ride a unicycle
18:56:25 <Binkley> always with the unicycles!
18:56:27 <syntaxfree> that mammal with a beak..
18:56:36 <dons> well, platypus. hmm.
18:56:41 <gravity> What's with the unicycle?
18:56:44 <allbery_b> actually google tells me it's taken
18:56:56 <allbery_b> "Web, Graphics, and Perl/Tk Programming"
18:57:02 <dons> echidna, perhaps.
18:57:05 <syntaxfree> dons: do you get to pick the animal, anyway?
18:57:09 <dons> spikey, can't be killed.
18:57:12 <dons> syntaxfree: no idea.
18:57:49 <syntaxfree> that's funny. the entire community of researchers in functional programming grinds to a halt debating what animal should be on don stewart's book.
18:58:06 <dons> its an important question!
18:58:19 <dons> don't want to pick a dud animal
18:58:20 <syntaxfree> management at cambridge, glasgow, microsoft research, etc. pulling their hairs.
18:58:45 <syntaxfree> dons: yeah. how much of perl's success is due to the cool reliable beast of burden status of the camel?
18:59:13 <syntaxfree> is the giraffe taken?
18:59:37 <SamB_XP> I bet
18:59:38 <Philippa> if you stand on a stool
18:59:42 <Binkley> is the sloth taken?
18:59:43 <Philippa> but the hedgehog...
18:59:47 <SamB_XP> istr a cover with a giraffe
18:59:49 <syntaxfree> the sloth is a bad idea.
18:59:52 <Philippa> (apologies)
18:59:58 <SamB_XP> how about a blue hedgehog...
19:00:30 <LoganCapaldo> turtle?
19:00:33 <LoganCapaldo> tortoise?
19:00:36 <syntaxfree> roadrunner?
19:00:39 <TSC> Porpoise?
19:00:39 * emu peers around
19:00:43 <Binkley> sure, we really want people thinking haskell runs at a turtle's pace
19:00:45 <LoganCapaldo> Porpoise is cool
19:00:48 <Binkley> how about a snail? :P
19:00:49 <SamB_XP> swarm of bees?
19:00:58 <TSC> Flock of seagulls
19:01:00 <syntaxfree> a swarm of bees belongs by right to erlang, doesn't?
19:01:04 <LoganCapaldo> Binkley: going by that logic it should be a Cheetah :)
19:01:07 <monochrom> Esop's tale about the bat. I think the bat is a good symbol for "real-world haskell" :)
19:01:12 <SamB_XP> syntaxfree: perhaps
19:01:17 <SamB_XP> do they use that?
19:01:24 <LoganCapaldo> Or a Falcon
19:01:29 <ndm> shark?
19:01:29 <LoganCapaldo> of some kind
19:01:31 <syntaxfree> flock of seagulls is interesting, but isn't "structural" enough.
19:01:34 <QtPlatypus> monochrom: Doesn't sendmail already have a bat
19:01:39 <syntaxfree> I like the falcon.
19:01:41 <monochrom> Darn.
19:01:48 <syntaxfree> birds of prey in general are proud and smart.
19:01:53 <dons> a robot from the future.
19:01:53 <ndm> unicorn!
19:01:55 <syntaxfree> the falcon can actually be trained.
19:01:57 <dons> a transformer, perhaps.
19:02:00 <Mephisto> a leech
19:02:00 <syntaxfree> i like the falcon.
19:02:02 <QtPlatypus> Platypus already is used as well.
19:02:03 * syntaxfree votes for the falcon.
19:02:04 <LoganCapaldo> My vote goes to the unicorn
19:02:10 <dons> mm.
19:02:12 <monochrom> How about the species homo sapiens? It's the most advanced animal known. It's also real-world. :)
19:02:14 <dons> cute idea.
19:02:14 <SamB_XP> oh, yes, a monad transformer would be cool
19:02:21 <LoganCapaldo> because real world Haskell is a mythical creature :)
19:02:33 <Binkley> we wouldn't want people thinking that only virgins can see Haskell
19:02:38 <dons> heh
19:02:45 <SamB_XP> oh is that why I have so much success
19:02:47 <syntaxfree> only virgins can see an unicorn?
19:02:49 <syntaxfree> DANG!
19:02:52 <Binkley> or so the legend goes
19:02:54 <dons> what happens if you kill a unicorn? something bad?
19:02:55 <SamB_XP> syntaxfree: catch, actually
19:03:03 <monochrom> No wonder I understand Haskell haha.
19:03:06 <SamB_XP> dons: you get a unicorn's horn
19:03:12 <dons> true. that's useful.
19:03:13 <LoganCapaldo> Actually on that theme, I'd rather have a dragon than a unicorn
19:03:13 <cdsmith> I think I'm missing something fundamental here...
19:03:14 <syntaxfree> Gah, I was a virgin until I was 22. I could have used that time to find an unicorn. Now it's too late.
19:03:14 <cdsmith> I'm getting many, many stack overflows and have no idea why, or how to solve them.
19:03:15 <SamB_XP> which is good for healing all kinds of ailments
19:03:16 <dons> good for stabbing
19:03:29 <dons> cdsmith: hmm. no lazy recursion?
19:03:45 <syntaxfree> I insist on the falcon.
19:03:50 <cdsmith> dons: lots of lazy recursion, actually
19:03:51 <syntaxfree> @quote animal
19:03:51 <lambdabot> No quotes match. stty: unknown mode: doofus
19:04:02 <SamB_XP> @quote mascot
19:04:02 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
19:04:09 <syntaxfree> @quote beast
19:04:09 <lambdabot> No quotes match. You speak an infinite deal of nothing
19:04:10 <dons> cdsmith: perhaps check your loops for space leaks then. (try bang patterns on key lazy args)
19:04:16 <dons> f !x = ... f (x+1)
19:04:35 <cdsmith> dons: okay, I'll try that; but I'd like to really *understand* why it's happening, as well
19:04:51 <monochrom> There is a haskellwiki page on this.
19:05:34 <cdsmith> monochrom: I'll look for it.
19:07:12 <syntaxfree> which animal is the nature's mathematician?
19:07:36 <monochrom> homo sapiens
19:07:41 <LoganCapaldo> Spider?
19:07:42 <dons> octopus?
19:07:45 <ddarius> ant
19:07:49 <dons> they solve maze problems, and have cool suckers.
19:07:51 <LoganCapaldo> Geometry and all that jazz
19:08:08 <syntaxfree> octopi?
19:08:13 <LoganCapaldo> I like how ddarius was the only one who didn't question his answer
19:08:16 <monochrom> homo sapiens not just solve math problems, they create new ones too!
19:08:17 <SamB_XP> http://www.haskell.org/pipermail/haskell-cafe/2001-January/001421.html
19:08:18 <ddarius> @oldwiki StackOverflow
19:08:18 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
19:08:19 <lambdabot> Title: Learning Haskell and FP, http://tinyurl.com/26w9tk
19:08:34 <LoganCapaldo> Except for monochrom, who cheated anyway
19:08:40 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow
19:08:41 <lambdabot> Title: Stack overflow - HaskellWiki
19:08:42 <ddarius> monochrom: Oh fantastic.  More problems humans make.
19:08:45 <dons> spider is interesting. small, agile, builds beautiful structures from simple pieces.
19:09:00 <monochrom> homo sapiens also invented monads and MPTC
19:09:11 <syntaxfree> what about a cat?
19:09:16 <dons> ok. we'll go with a picture of Mr. T. on the front.
19:09:16 <SamB_XP> ooooh
19:09:18 <SamB_XP> a cat
19:09:28 <dons> cats are sneaky. nice.
19:09:28 <ddarius> I vote for a beautiful woman.
19:09:29 <SamB_XP> but wouldn't that be more appropriate for UNIX?
19:09:31 <LoganCapaldo> A cat riding a unicycle
19:09:32 <monochrom> Mr. T. is cool.
19:09:42 <SamB_XP> whatever
19:09:42 <newsham> bunnies are the best at multiplication
19:09:43 <Binkley> Mr. T riding a unicycle
19:09:45 <newsham> if thats what you mean
19:09:46 <dons> he'll kick your butt if you don't use monad transformers.
19:09:46 <dino-> Cats are clever. I like cat.
19:09:47 <syntaxfree> a spider is an insect. many people are arachnophobic.
19:09:53 <SamB_XP> monochrom: we can't put Mr. T on the cover, I think...
19:09:59 <ddarius> A spider is not an insect.
19:10:02 <SamB_XP> syntaxfree: is not
19:10:09 <syntaxfree> yeah. you're right.
19:10:13 <ddarius> bunnies... fibonacci...
19:10:13 <syntaxfree> a spider is an arachnoid.
19:10:21 <sjanssen> I pity the fool that doesn't appreciate referential transparency
19:10:24 <syntaxfree> bunnies.
19:10:26 <LoganCapaldo> ddarius++
19:10:28 <newsham> shell fish know fibonacci sequences
19:10:29 <syntaxfree> what about transparent animals?
19:10:34 <dons> sjanssen: 'zactly!
19:10:37 <syntaxfree> what's the name of that transparent water animal?
19:10:41 <SamB_XP> jellyfish?
19:10:45 <syntaxfree> !
19:10:50 <ddarius> syntaxfree: there are a lot of them
19:10:58 <SamB_XP> yes there probably are
19:10:59 <ddarius> krill
19:11:14 <SamB_XP> for some reason they don't seem to see much point in being opaque
19:11:25 <dons> jelly fish are fun - the poison ones...http://www.cse.unsw.edu.au/~dons/images/daintree/jelly.png
19:11:36 <LoganCapaldo> Man-o-war!
19:11:44 <ddarius> I stole the picture named daintree for my phone background.
19:11:49 <dino-> box jelly
19:12:00 <newsham> sometimes haskell stings
19:12:07 <Binkley> haskell can be painful
19:12:16 <dons> ddarius: heh. its nice up there.
19:12:26 <SamB_XP> a school of jellyfish?
19:12:31 <newsham> wouldnt a unicorn be appropriate? ;-)
19:12:31 <ddarius> dons: Where was that exactly?
19:12:45 <dons> that's Cape Tribulation, on the tip of the Daintree rainforest
19:12:57 <syntaxfree> what about bonobos?
19:13:01 <ozone> dons: where on earth was that sign?
19:13:05 <ozone> ah, right
19:13:07 <newsham> (practical haskell being a myth and all  ;-)  *ducks*
19:13:12 <dons> ozone: just near Cape Trib. no swimming.
19:13:25 <LoganCapaldo> newsham: scroll up for that joke
19:13:27 <ozone> dons: http://www.youtube.com/watch?v=MiMWJ1xBo8w
19:13:39 <ozone> brilliant parody of all those crappy old high school educational videos
19:13:40 <newsham> <- old meme
19:13:44 <dons> ozone: end of the road, actually, its just dirt tracks further north up cape york . bush tucker man and all
19:13:54 <ozone> dons: crikey!
19:14:08 <newsham> i think chuck norris would make a nice cover (under his beard is a fist)
19:14:10 <syntaxfree> what animal does java use?
19:14:19 <syntaxfree> is there a lisp book?
19:14:25 <syntaxfree> let's look at the patterns.
19:14:26 <dons> ozone: you should get up there, 29 every day.
19:14:40 <syntaxfree> (or put laetitia casta in a skimpy bikini. dunno.)
19:14:46 <newsham> http://www.oreilly.com/pub/topic/java
19:14:47 <lambdabot> Title: O'Reilly Store -- Java
19:15:02 <ozone> dons: well, i'll be in the usa next month
19:15:09 <ozone> i just realised i may be missing out on HOPL-III by a day :(
19:15:32 <dons> also have this nice sign, http://www.cse.unsw.edu.au/~dons/images/daintree/croc.png
19:15:34 <syntaxfree> Java is an owl?
19:15:41 <syntaxfree> an owl with a huge tail?
19:15:49 <dons> ozone: doh.
19:16:02 <newsham> there are lots of java ORA books with diff animals
19:16:09 <LoganCapaldo> Ironically the cover of the Ant book, is not an ant
19:16:21 <syntaxfree> too obvious.
19:16:23 <newsham> like bunny "java i/o"  cangaroo "enerprise javabeans 3.0" tiger "java in a nutshell"
19:16:32 <LoganCapaldo> Doesn't python have a python though?
19:16:52 <LoganCapaldo> Yerp
19:16:59 <LoganCapaldo> http://www.oreilly.com/pub/topic/python
19:16:59 <lambdabot> Title: O'Reilly Store -- Python
19:17:16 <syntaxfree> are dolphins taken?
19:17:24 <cdsmith> dons, monochrom: thanks, I fixed this one anyway by changing a maximumBy to an explicit foldl1'.  It got uglier, though. :(
19:17:27 <newsham> ruby has a giraffe (which looks kinda like a lambda i guess)
19:17:40 <dons> cdsmith: ah yes, maximumBy is (bizarrely) a lazy fold.
19:17:43 <dons> worth a bug report..
19:17:58 <SamB_XP> what is that on "Python Cookbook"?
19:18:03 <newsham> ruby on rails just has a picture of robin williams..  what's that about?
19:18:03 <SamB_XP> is that Python's lunch?
19:18:31 <newsham> sam: looks like a jack rabbit?
19:18:36 <cdsmith> dons: I won't file a bug, though, because I don't understand this well enough yet.
19:18:40 <LoganCapaldo> O'Reilly needs a search by animal
19:18:46 <dons> ?src maximumBy
19:18:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:19:02 <syntaxfree> ohhhh. just look at this cute cute cute monkey:
19:19:03 <syntaxfree> http://www.wsd1.org/LTCActivities/Downloads%20Artful%20Prestidigitation/Symmetry/Faces%20Symmetry/monkey%20full%20face.JPG
19:19:05 <lambdabot> http://tinyurl.com/bd4bb
19:19:05 <LoganCapaldo> lambdabot: I don't believe you have
19:19:17 <syntaxfree> now just imagine it in typical O'Reilly cover colors.
19:21:02 <cdsmith> syntaxfree: what a hideous way to torture a monkey
19:21:59 <syntaxfree> cdsmith: huh?
19:22:13 <cdsmith> synbtaxfree: the O'Reilly book colors
19:22:47 <cdsmith> syntaxfree: I just think O'Reilly books are ugly.  It was a joke.
19:22:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/21
19:28:04 <dino-> Is Cale doing a book as well?
19:28:11 <cdsmith> Okay, don't let me halt the conversation.  Sorry if I said something wrong.
19:28:38 <Binkley> @yow
19:28:38 <lambdabot> If I pull this SWITCH I'll be RITA HAYWORTH!!  Or a SCIENTOLOGIST!
19:29:07 <jfredett> what?
19:31:17 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/22
19:32:10 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/23
19:32:23 <dcnstrct> hi, I'm messing around with haskell's sockets library and some concurrency primitives for the first time.  I need a little help.  http://hpaste.org/23
19:33:02 <ddarius> 23... ?
19:33:19 <dcnstrct> yea 23 is the correct paste
19:33:24 <sjanssen> dcnstrct: hpaste's maintainer gets grumpy when you don't provide nicks or titles for your posts ;)
19:33:40 <dcnstrct> noted for future reference :)
19:34:16 <ddarius> hpaste got reset?
19:34:23 <monochrom> > show "www.google.com"
19:34:26 <lambdabot>  "\"www.google.com\""
19:34:28 <dons> i think there was a hardware failure or something
19:34:38 <monochrom> I wonder if that causes some problem.
19:34:48 <SamB_XP> monochrom: hmm?
19:34:56 <gravity> Wow, it's amazing how doing simple things in haskell makes me feel like I actually accomplished something.
19:35:08 <dons> gravity: hmm :/ ;) :)
19:35:15 <gravity> hehe
19:35:34 <TomMD> gravity: 1) Haskell is not just some simple thing (often not that simple) 2) It helps you do complex things simply.
19:35:37 <Pseudonym> That's because something that's simple in Haskell is complicated in other languages.
19:35:44 <dcnstrct> monochrom, well.. it actually does establish the three TCP connections, so I'm thinking those strings are fine.
19:35:58 <gravity> TomMD: Yeah, I'm looking to build up to the complex things
19:36:00 <Pseudonym> "Wow, I wrote the TeX layout algorithm in five lines.  I accomplished something!"
19:36:21 <SamB_XP> Pseudonym: you have?
19:36:24 <SamB_XP> cool!
19:36:30 <Pseudonym> I can't remember how many lines it was.
19:36:44 <Pseudonym> It was just the line breaking algorithm, and it didn't handle hyphenation.
19:36:49 <SamB_XP> ah.
19:36:50 <Pseudonym> But about 5 lines, I think.
19:37:13 <SamB_XP> was this for plaintext, or for real proportional-fonty text?
19:37:22 <Pseudonym> Real proportional-fonty text.
19:37:27 <SamB_XP> neato
19:37:32 <SamB_XP> with mixed fonts?
19:37:48 <Pseudonym> Each "word" had a length.
19:37:54 <Pseudonym> In arbitrary units.
19:37:59 <Pseudonym> So mixed fonts fall out naturally.
19:38:25 <monochrom> dcnstrct: I see not reason why connectTo "\"www.google.com\"" ... does what we think.
19:38:28 <Pseudonym> The model is that you have arbitrary "words" with "glue" between them.
19:38:36 <Pseudonym> Words have fixed size, glue has variable size.
19:38:55 <Pseudonym> So it doesn't matter what's in a "word", so long as it has a fixed size.
19:38:56 <monochrom> dcnstrct: could you fix that, if only to remove my doubt? please?
19:39:27 <_frederik_> hello, can i have a C library write some e.g. progress information to a special file descriptor which is then read and processed by a parallel process in Haskell - will this work equally well in ghci, etc.?
19:39:37 <Pseudonym> BTW, the algorithm is dead simple if you have lazy evaluation.
19:39:59 <_frederik_> i do not have much experience with threads and wanted to make sure the support is good enough
19:40:24 <_frederik_> i assume it is but thought you guys might have more experience
19:40:44 <Pseudonym> frederik, the C library is called from the same process?
19:40:48 <Pseudonym> Or this is a different process?
19:40:55 <dcnstrct> monochrome, you were absolutely right, that fixed my whole problem, thank you very much sir, I don't even know why those shows were there to begin with o_0
19:41:30 <monochrom> Nice. :)
19:46:31 <LoganCapaldo> > zipWith5 (,,,,) "upto" "five" "was" "unexpected" "for me"
19:46:36 <lambdabot>  [('u','f','w','u','f'),('p','i','a','n','o'),('t','v','s','e','r')]
19:47:47 <wastez> Hello, what's the "good way" of processing options with GetOpts? Using ifs doesn't sound too right
19:51:19 <dons> wastez: there's a nice example at the end of the getopts source
19:51:25 <dons> ?source System.Console.GetOpt
19:51:25 <lambdabot> http://darcs.haskell.org/packages/base/System/Console/GetOpt.hs
19:51:44 <dons> wastez: also, on haskell.org's 'blog  articles' page are some small tuts on this
19:51:56 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#2
19:51:58 <lambdabot> http://tinyurl.com/y3585u
19:52:21 <wastez> dons: Thank you, I didn't totally get the docs on GetPot but I'll check the blogs then
19:52:27 <wastez> mmm, Opt, not Pot :D
19:57:19 <dino-> wastez: And then when you get the IO ([Flag], [String]) back, I think it may depend on what you need to do with the opts. In some cases, I've done something like "when (MyOpts.Foo `elem` flags) $ do ..."  Which is basically like you said, ifs.
19:59:34 <wastez> dino-: the `elem` is what I'm doing right now, but I don't think its the right way to do it :D
20:00:08 <wastez> And checking the documentation from the website got me to the same point where I am, I have the opts but I don't exactly know how to process 'em :D
20:02:55 <wastez> http://en.literateprograms.org/Special:Downloadcode/Word_count_%28Haskell%29   <-- good example of what I wanted to do
20:02:58 <lambdabot> Title: Download code - LiteratePrograms, http://tinyurl.com/24n9ws
20:06:55 <dino-> Huh, making the Opts datatype a record with Bool fields instead of explicit constructors for each switch. I had not seen this. Thank you!
20:10:47 <ClaudiusMaximus> is conjure (haskell bittorrent client) a dead project?
20:11:34 <SamB_XP> I think it has gone mostly dormant lately...
20:11:54 <dino-> I don't seen anything about it on Hackage either.
20:12:23 <ClaudiusMaximus> was wondering if it can create torrents from directories - createtorrent (400lines of uncommented C) is broken...
20:14:31 <SamB_XP> I would just use the ordinary commandline tool for that
20:14:35 <wastez> dino-: Could you explain me how "processOpts opts = foldl (flip id) (allOpts False) opts
20:14:39 <wastez> works then?
20:14:43 <wastez> sorry for the line break
20:14:59 <wastez> I dont fully understand the (flip id) part
20:16:07 <LoganCapaldo> @type (flip id)
20:16:10 <lambdabot> forall b c. b -> (b -> c) -> c
20:16:21 <dino-> @type flip
20:16:23 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:16:24 <LoganCapaldo> @type ($)
20:16:26 <lambdabot> forall a b. (a -> b) -> a -> b
20:16:32 <dino-> and id is a -> a
20:16:42 <LoganCapaldo> @type (flip ($))
20:16:44 <lambdabot> forall a b. a -> (a -> b) -> b
20:17:09 <LoganCapaldo> IOW flip id is (\a f -> f a)
20:18:41 <LoganCapaldo> > (flip id) 3 (+1)
20:18:42 <lambdabot>  4
20:21:31 <wastez> After a bit of brain-melting that makes sense, thank you.
20:21:44 <dino-> Wow, I'm having trouble getting that too. But I see in the above code (on that page), opts is a [Opts -> Opts].
20:23:02 <wastez> Yes, the options and arguments, I'm working only with [Opts] for simplicity (just -v and -h)
20:23:27 <kaol> CosmicRay++ bos++ dons++ (oh, I think you can figure out why I'm raising their karmas)
20:25:20 <dons> heh
20:27:21 <_frederik_> Pseudonym: sorry to be gone, the C library will be called from process A, this will cause it to write things to a pipe which should be read by process B; process B will never call the library
20:28:15 <_frederik_> Pseudonym: however, i want to avoid deadlock, so process B should still be able to run while process A is inside the library
20:31:51 <_frederik_> grr he's gone
20:37:40 <_frederik_> if anyone wants to give me a second chance, my original query was: "hello, can i have a C library write some e.g. progress information to a special file descriptor which is then read and processed by a parallel process in Haskell - will this work equally well in ghci, etc.?"
20:38:31 <skew> sounds pretty complicated, but it should work.
20:38:56 <_frederik_> hello skew!
20:39:02 <skew> hi
20:39:11 <_frederik_> where are you these days?
20:39:16 <skew> still where I was.
20:39:20 <_frederik_> ok
20:39:55 <_frederik_> i find that haskell makes multithreading easy, except when it doesn't work
20:40:18 <_frederik_> i will try this if you think there are no issues
20:40:45 <skew> I think it's no more complicated than getting the C code to run concurrently with Haskell
20:40:56 <_frederik_> is that complicated?
20:41:10 <skew> build with -threaded, and don't use foreign import unsafe
20:41:35 <skew> and something if you care about thread local state
20:42:06 <_frederik_> you mean in pthreads?
20:42:35 <_frederik_> and that will work in ghci?
20:42:37 <skew> yeah, that sort of thing
20:42:56 <_frederik_> i'm worried that when Haskell process A is blocked in the C library, Haskell process B won't be able to run
20:42:58 <skew> read the implementation notes at the end of Control.Concurrent
20:43:02 <_frederik_> ok
20:43:10 <skew> ghci has been built with threaded for 6.6
20:43:13 <skew> maybe earlier
20:43:18 <_frederik_> cool
20:43:59 <skew> basically, some number of OS threads multiplex all the Haskell threads, and unless you do special stuff any given thread might call out
20:44:37 <_frederik_> i see
20:45:02 <skew> but you probably don't care anyway, if it's some long-running C thing
20:45:22 <_frederik_> care about what?
20:45:39 <skew> thread-local state and stuff like that
20:45:59 <skew> you could always fork a fresh process
20:46:13 <skew> probably safer too, no segfaults reaching you that way :)
20:46:33 <_frederik_> you mean with the fork syscall?
20:46:40 <skew> yeah
20:46:56 <_frederik_> but then i would have to use some sort of RPC rather than FFI, no?
20:47:03 <skew> depends what you are doing
20:47:31 <skew> if you're sharing all kinds of memory and objects, why do you need to write progress stuff out to files?
20:47:43 <_frederik_> oh i see
20:47:54 <_frederik_> because the shared objects are being operated on by long-running C routines
20:48:15 <_frederik_> it would be nice to be able to tell the user who is multiplying two matrices that it's going to take hours
20:48:56 <skew> then you probably need all this stuff about threads
20:49:21 <_frederik_> ok thanks
20:56:56 <chessguy> hi haskellers
20:57:13 <_frederik_> hello
20:58:15 <vagif> hello haskelers. Does anyone here uses hdbc or any other database access library ?
20:58:32 <_frederik_> vagif: i use HSQL but it hasn't been updated in a while
20:59:31 <vagif> _frederik_: is there a tutorial for HSQL ?
20:59:36 <_frederik_> vagif: the timezone stuff is all broken and a new release with my fixes hasn't been out for > 1 year
20:59:46 <_frederik_> vagif: i don't know, it is pretty simple
21:07:43 <chessguy> @pl f s = nub s == s
21:07:44 <lambdabot> f = (==) =<< nub
21:08:04 <chessguy> @hoogle num
21:08:05 <lambdabot> Prelude.Num :: class (Eq a, Show a) => Num a
21:08:05 <lambdabot> Ratio.numerator :: Integral a => Ratio a -> a
21:08:05 <lambdabot> System.Win32.Types.numToMaybe :: Num a => a -> Maybe a
21:08:08 <chessguy> @hoogle nub
21:08:09 <lambdabot> List.nub :: Eq a => [a] -> [a]
21:08:09 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:28:32 <chessguy> ok, haskellites
21:28:38 <chessguy> a little math programming puzzle for you
21:28:44 <chessguy> though it's not very puzzling
21:29:10 * cdsmith already resents lispy getting me hooked on project euler this morning. :)
21:29:21 <chessguy> i'll be curious to see what kind of code you come up with, though
21:29:25 <chessguy> i did it in 4 lines
21:29:27 <chessguy> how many even numbers greater than 4000 can be formed using some or all of the digits 1,2,3,4,5,6, if each digit must feature no more than once in a number?
21:32:13 <arcatan> the ML is getting alarmingly active
21:32:29 <chessguy> why alarming?
21:33:10 <LoganCapaldo> He fears the "Guys I need to make a web store like amazon by next week. Plz. help. k thanks." messages
21:33:34 <chessguy> that's, like 200 lines of code in haskell :)
21:34:37 <cdsmith> chessguy: am I allowed to forget programming entirely and do your puzzle on paper?
21:36:04 <chessguy>  bah, that's no fun
21:36:09 <chessguy> this is #haskell, after al
21:36:11 <chessguy> l
21:36:45 <cdsmith> chessguy: main = print 744 -- or did I mess something up?
21:37:00 <chessguy> you did
21:37:05 <cdsmith> oh
21:37:08 * LoganCapaldo hopes chessguy doesn't kick anyone into a pit
21:37:20 <chessguy> a pit?
21:37:40 <LoganCapaldo> "This is #haskell
21:37:42 <LoganCapaldo> "
21:37:44 <LoganCapaldo> vm
21:37:45 <LoganCapaldo> nvm
21:37:47 <arcatan> hah :D
21:37:52 <LoganCapaldo> stupid return key
21:38:02 * chessguy totally doesn't get it
21:38:22 * cdsmith is equally befuddled.
21:38:22 <LoganCapaldo> s/#haskell/spart/
21:38:29 <LoganCapaldo> *sparta
21:38:57 <chessguy> oh, was that a movie quote?
21:39:00 <skew> how about main = print 804
21:39:21 <chessguy> show your work :)
21:39:35 <skew> intuition ;)
21:39:43 <chessguy> c'mon guys, this is haskell, and it's easy haskell code to write
21:40:42 <ari> > length . filter (ap (==) nub . show) . filter (all (`elem` ['1'..'6']) . show) $ [4000,4002..654320]
21:40:44 <lambdabot>  804
21:40:48 <lispy> cdsmith: s'okay, i'm hooked too
21:40:52 <chessguy> @quote nice
21:40:52 <lambdabot> ray says: some people claim everything is lisp. one time i was eating some spaghetti and someone came by and said "hey, nice lisp dialect you're hacking in there"
21:41:18 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in perms "123456"
21:41:19 <lambdabot>  ["123456","12345","12346","1234","12356","1235","1236","123","12456","1245",...
21:41:21 <cdsmith> chessguy: yeah, I figured out my mistake.  804 is right
21:41:35 <cdsmith> lispy: It's definitely addictive.
21:41:41 <chessguy> cdsmith: i know :)
21:42:30 <skew> > [n | s <- inits (perms "123456"), not (null s), let n = read s, n > 4000, even n]
21:42:31 <lambdabot>   Not in scope: `perms'
21:42:47 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in length $ filter (\x -> even x && x > 4000) (map read perms "123456")
21:42:47 <lambdabot>  Couldn't match expected type `[String]'
21:43:05 <cdsmith> chessguy: at first I was only considering 4-digit numbers starting with 4; forgot 5 and 6
21:43:09 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in length $ filter (\x -> even x && x > 4000) (map (read :: String -> Integer) perms "123456")
21:43:10 <lambdabot>  Couldn't match expected type `[String]'
21:43:17 <vagif> what data type is this: data Bla = Bla {Name::String, Age::Int}
21:43:19 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in length $ filter (\x -> even x && x > 4000) (map (read :: String -> Integer) $ perms "123456")
21:43:21 <lambdabot>  Exception: Prelude.read: no parse
21:43:32 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in length $ filter (\x -> even x && x > 4000) (map read $ perms "123456")
21:43:33 <lambdabot>  Exception: Prelude.read: no parse
21:43:47 <cdsmith> vagif:  umm, it's Bla, I guess.  What do you want to know about it?
21:43:49 <chessguy> LoganCapaldo: the numbers can be 4, 5, or 6 digits long
21:43:52 <vagif> what data type is this: data Bla = Bla {Name::String, Age::Int} is it structure ? record ? object ?
21:44:21 <cdsmith> vagif: Ah, it's a record.
21:44:24 <chessguy> vagif: syntax error
21:44:35 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs in length $ filter (\x -> even x && x > 4000) (map read $ filter (\x -> length x >= 4) $ perms "123456")
21:44:36 <cdsmith> oh yeah, that too
21:44:36 <lambdabot>  6
21:44:38 <vagif> i see. thx where i can read about records more
21:44:40 <chessguy> anytime you have Foo :: Bar, it's wrong
21:44:53 <LoganCapaldo> that's clearly incorrect
21:44:58 <LoganCapaldo> 6 is not the answer
21:45:02 <chessguy> LoganCapaldo: told ya so
21:45:57 <LoganCapaldo> I think my perms must be broken
21:46:13 <skew> ari has a nice solution, but that 654320 is slightly magic
21:46:36 <skew> ought to be filtering [4000..]
21:47:00 <ari> skew: Well, you do have to know when to stop (:
21:47:10 <chessguy> wow, i totally mis-read that for a second, LoganCapaldo
21:47:21 * chessguy rubs his eyes
21:47:23 <LoganCapaldo> chessguy: ?
21:48:05 <chessguy> skew: or at least [4000..999999]
21:48:51 <skew> nah, if you're throwing in bounds like that 654321 is ok
21:49:55 <LoganCapaldo> I think I wrote combinations instead of permutations
21:50:47 <skew> ap (==) nub is tricksy
21:50:58 <skew> learned that from @pl, I suppose
21:51:06 <ari> skew: Indeed
21:51:20 <chessguy> yeah, that's cute
21:51:33 <skew> I could see  delta >>> id &&& nub >>> uncurry (==)
21:51:35 <chessguy> @pl \s -> nub s == s
21:51:35 <lambdabot> (==) =<< nub
21:51:57 <chessguy> @type ap (==) nub
21:52:00 <lambdabot> forall a. (Eq [a], Eq a) => [a] -> Bool
21:52:30 <chessguy> > ap (==) nub $ "foo"
21:52:31 <Heffalump> why doesn't it reduce the context Eq [a] ?
21:52:31 <lambdabot>  False
21:52:33 <skew> what operates @type? Looks like it isn't doing as much context simplification as it could
21:52:51 <chessguy> @pl f s = nub s == s
21:52:51 <lambdabot> f = (==) =<< nub
21:52:52 <LoganCapaldo> > let perms [] = [[]]; perms (x:xs) = map (x:) (perms xs) ++ perms xs ++ (map (++[x]) (perms xs))in length $ filter (\x -> even x && x > 4000) (map read $ filter (\x -> length x >= 4) $ perms "123456")
21:52:53 <skew> @type ap (==) nub "text"
21:52:55 <lambdabot>  116
21:52:56 <lambdabot> Bool
21:53:05 <Heffalump> perhaps if it runs some of the weird instance flags then context reduction is delayed
21:53:10 <skew> I was worried for a bit...
21:53:23 <skew> looked like @type said 116
21:53:39 <Heffalump> :-)
21:53:39 <chessguy> skew: i thought that for a second too
21:53:46 <LoganCapaldo> sorry guys
21:53:53 <LoganCapaldo> I'll try not to terrify you anymore
21:55:08 <chessguy> ari++ for a nice solution
22:03:54 <thoughtpolice> wow, this google talk over type theory is really interesting.
22:04:07 <cdsmith> thoughtpolice: where?
22:04:08 <Korollary> It's a good, quick overview
22:04:28 <thoughtpolice> cdsmith: http://therning.org/magnus/archives/286
22:04:29 <lambdabot> Title: therning.org/ magnus » Types are funky&#8230;
22:05:02 <cdsmith> thoughtpolice: thanks.
22:05:09 <thoughtpolice> it's about 30 minutes
22:05:12 <thoughtpolice> but 30 minutes well spent
22:05:38 <thoughtpolice> it gave some good insight into why haskell 'just works'
22:05:54 <Korollary> There is also Wadler's google talk
22:06:03 <thoughtpolice> more in depth?
22:06:17 <Korollary> Not really
22:07:56 <thoughtpolice> speaking of google talks, i recently saw torvald's talk on distributed version control and git,
22:08:07 <Korollary> a lot of ranting
22:08:12 <thoughtpolice> it was pretty good; torvalds has a funny style.
22:08:21 <thoughtpolice> yeah, a good portion of it seemed like name calling
22:08:34 <thoughtpolice> particularly calling people ugly and stupid, but that's kind of how torvalds is
22:08:40 <cdsmith> thoughtpolice: I watched that.  It was amusing, in any case; and not bad.
22:09:48 <thoughtpolice> his fights with tanenbaum are good reads as well :)
22:10:48 <Mephisto> i wonder how amusing it would be if the software houses called people ugly and stupid .. i can already feel the waves of protest on slashdot just thinking about it
22:11:04 <Heffalump> who did he call ugly and stupid?
22:11:14 <thoughtpolice> anybody who disagreed with him 'during the talk'
22:12:46 <thoughtpolice> but like I said, that's kind of how torvalds is. a lot of the start of the talk seemed to just be a lead into 'cvs sucks, svn is pointless, etcetera.. now on with the talk: ...'
22:14:48 <cdsmith> thoughtpolice: I was wondering what he'd say about darcs, had he mentioned it.
22:14:59 <geezusfreeek> opinionated people are often easier to believe, much as i hate it
22:15:12 <geezusfreeek> he'd probably say darcs is too slow
22:15:22 <geezusfreeek> it probably is too slow for the linux kernel
22:15:38 <cdsmith> geezusfreeek: that's the impression I got.  He seemed unjustifiably obsessed with performance.
22:16:00 <geezusfreeek> i think it's a just obsession... the linux kernel is too big
22:16:05 <thoughtpolice> cdsmith: so was i.
22:16:29 <geezusfreeek> i tried using subversion for my own branch of the kernel once (when git was still pretty new), and it was unbearably slow
22:16:43 <cdsmith> geezusfreeek: Yeah, but he wasn't talking to kernel developers.
22:16:47 <geezusfreeek> true
22:18:18 <thoughtpolice> the subversion guys themselves said to stop bugging torvalds to use svn for the linux kernel after bitkeeper was dropped.
22:18:59 <thoughtpolice> but i agree; the linux kernel is huge (loc's somewhere around 7mil or so?), performance is an understandable need.
22:19:27 <skew> even GHC has some trouble with merges it seems
22:19:32 <bos> 10 million or so.
22:19:57 <thoughtpolice> bos: hm, i only got the 7mil from reading an article a while back.
22:20:05 <geezusfreeek> it's at 10 million already? last time i did anything hardcore with it it was still at around 7 or 8 million
22:20:06 <bos> i'm a kernel hacker ;-)
22:20:16 <thoughtpolice> i'll take your word for it
22:20:18 <thoughtpolice> :)
22:20:59 <geezusfreeek> hmm... that reminds me... i need to see if i can track down any of my work to finish it up
22:21:32 <geezusfreeek> it was just for a project in one of my undergraduate classes, but it was kind of neat... encrypted virtual memory
22:21:51 <geezusfreeek> it worked by the due date, but it was buggy and crash-prone
22:22:31 <geezusfreeek> there's been a couple attempts at it anyway though... by people that know far more about the linux kernel than i do
22:22:42 <geezusfreeek> oh well, back to studying more haskelly things
22:22:49 <thoughtpolice> either way the talk was pretty good. he did obviously hold the performance factor highly (and simply tossed aside alternatives the way you'd toss a bad apple,) but I liked the talk. and git isn't a bad control system.
22:23:17 <thoughtpolice> i just like hearing torvalds speak/write, mainly; it's just humorous in general I've found.
22:23:28 <Korollary> I went to one of his talks
22:23:34 <geezusfreeek> git is nice now i guess... i have had some reservations about it for a long time, but they were probably irrational due to the fact that i made some conclusions based on experiences with it when it was brand spanking new
22:23:36 <Korollary> He bored me senseless
22:23:55 <thoughtpolice> geezusfreeek: up until recently I heard quite a few bad things about the usability factor.
22:24:12 <thoughtpolice> until say 1.5 or somewhere thereabouts.
22:24:15 <geezusfreeek> thoughtpolice: yeah it was definitely hard to use for a long time
22:24:30 <thoughtpolice> Korollary: what was the talk over?
22:26:11 <Korollary> thoughtpolice: linux in general. I don't remember exactly. It was 3-4 years ago.
22:27:23 <thoughtpolice> Korollary: i'm jumping out of my seat with enthusiasm just from hearing the topic.
22:27:38 <thoughtpolice> and ironically my chair just broke.
22:28:25 <thoughtpolice> shit.
23:07:12 <fuzan> ?seen sorear
23:07:13 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 3d 16h 23m ago, and .
23:07:24 <fuzan> ;(... any vty gurus around?
23:07:50 <gwern> are there any builtin types which allow decimals like 5.5 and so on but disallow negative numbers? (such a type would considerably simplify some of my code)
23:08:16 <gwern> bos: you up right now?
23:08:20 <bos> yep
23:08:33 <gwern> bos: what's the CC license for the planned book? dons didn't seem to know
23:09:03 <bos> not set in stone yet.
23:09:26 <gwern> bos: were you guys planning to let wikimedia foundation projects make use of it?
23:09:35 <bos> we're pushing for something liberal; o'reilly's lawyers default to less liberal.
23:09:41 <gwern> (ex. wikibooks and such)
23:09:50 <bos> i don't know what wikimedia's licensing policy is.
23:09:58 <gwern> bos: hmm. well, keep in mind, NC is a kiss of death for wmf projects
23:10:06 <bos> i believe they use GFDL or OPL, both of which would be a problem.
23:10:50 <gwern> bos: if it's anything-NC, it's useless for wmf purposes except as an outsider sort of resource which might be available online
23:10:58 <bos> honestly, it's fine by me if wikimedia can't use the content. i don't like the anonymity of wikibooks. it's my book, it's going to be branded with my name :-)
23:11:03 <sieni> gwern: what do you need such type for?
23:11:09 <gwern> bos: no, we allow GFDL-comptaible stuff. but NC
23:11:13 <gwern> is fatal
23:11:34 <gwern> frex, CC-SA would be dandy, and I'm somewhat sure we allow SA-attrib as well
23:11:57 <gwern> sieni: I'm writing some toy equations for nuke explosions, and a lot of my values mustn't be negative but must allow real values
23:12:00 <bos> well, i can pretty well guarantee it will be NC, or we'll have to self-publish on stolen napkins
23:12:06 <gwern> so I'd like to clear out a lot of conditionals
23:12:23 <gwern> bos: ironically, SA discourages businesses pretty impressively
23:12:45 <gwern> *other businesses
23:13:33 * cdsmith wonders if math is broken
23:13:36 <bos> well, i don't want to get into a fight with the lawyers over that. need to save my ammo for other possibilities.
23:13:36 <skew> gwern: maybe you could newtype something and not define -
23:13:48 <gwern> bos: actually, erik moeller, one of the wmf board members wrote a long something on this very issue: http://freedomdefined.org/Licenses/NC
23:13:51 <lambdabot> Title: Licenses/NC - Definition of Free Cultural Works
23:14:03 <dons> gwern: we'll know more in coming days, anyway. its too early to state definitively yet
23:14:03 <hpaste>  cdsmith pasted "weird ghci stuff" at http://hpaste.org/25
23:14:11 <cdsmith> Does that make sense to anyone?
23:14:25 <sieni> gwern: Can't you do something like in http://www.cs.sfu.ca/CC/SW/Haskell/hugs/tutorial-1.4-html/moretypes.html
23:14:27 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again, http://tinyurl.com/24yzho
23:14:40 <gwern> dons: I've learned that when it comes to licenses, you gotta get it settled early. once stuff begins to happen, it's often too late to change
23:14:53 <gwern> sieni: I'll try that
23:15:36 <TSC> cdsmith: What is f?
23:15:37 <sieni> gwern: I assume that getting a negative value somewhere where you shouldn't have one should be a fatal error or something
23:15:47 <TSC> cdsmith: oh, never mind (:
23:15:51 <hpaste>  (anonymous) annotated "weird ghci stuff" with "(no title)" at http://hpaste.org/25#a1
23:15:54 <gwern> sieni: well, it doesn't make sense for a nuke to have a negative yield, among other things :)
23:16:06 <cdsmith> TSC: I't's there; but it shouldn't matter, should it?
23:16:37 <bos> gwern: i've worked out licenses with publishers before. i'm not concerned about the outcome here. my existing book is published under the OPL, for example.
23:17:22 <TSC> cdsmith: It shouldn't; I wasn't paying attention
23:17:32 <gwern> bos: fair enough. I just wanted to make sure you knew the relevant little bit of WMF policy (that is, "no NC!")
23:17:53 <bos> thanks.
23:18:15 <quicksilver> bos: what is your existing book?
23:18:54 <gwern> find it hard to believe there's no predefined non-negative real type for numbers though. seems like a common need to me
23:18:56 <TSC> cdsmith: It behaves correctly here (gives 33 and 13)
23:19:12 <cdsmith> TSC: Weird.  Maybe it's just telling me to go to bed.
23:19:26 <dibblego> data Nat = Zero | Succ Nat -- gwern
23:19:36 <dibblego> see also Church's Encoding
23:19:38 <bos> quicksilver: http://hgbook.red-bean.com/
23:19:38 <Korollary> That's not real
23:19:38 <quicksilver> dibblego: dat's not real :)
23:19:40 <lambdabot> Title: Distributed revision control with Mercurial
23:19:46 <quicksilver> bos: ah, neat!
23:20:02 <dibblego> oh, missed that part
23:20:06 <gwern> dibblego: natural numbers are not my need. jolly good try though
23:20:07 <Korollary> I think mostly when real numbers are needed negative quantities also make sense.
23:20:27 <quicksilver> gwern: the numeric typeclass hierarchy is well known to be not perfect
23:20:34 <gwern> Korollary: many physical quantities are non-negative reals, though aren't they?
23:20:45 <quicksilver> gwern: still, I think non-negative reals is a bit tricky, since (-) becomes a partial function
23:20:51 <gwern> fundamental stuff like mass! that's a non-negative real
23:21:18 <cdsmith> Good night eveyone.  Congratulations to the resident authors.
23:21:19 <Korollary> gwern: Yeah, but then you need acceleration, etc.
23:22:01 <gwern> quicksilver: I think I'll just define away the rest as zero. should meet my needs
23:23:42 <sieni> gwern: and naturally each quantity (like mass, energy etc.) should have separate types, so that you can automatically check, that a result of some calculation has the desired dimensional type
23:24:14 <gwern> sieni: ideally. overkill currently, but I think there are dimensional libraries already
23:26:15 <bos> @where dimensional
23:26:15 <lambdabot> I know nothing about dimensional.
23:26:33 <bos> @where+ dimensional http://code.google.com/p/dimensional/
23:26:33 <lambdabot> Done.
23:26:41 <sieni> gwern: Famous last words. I have seen too much suckage in software caused by the attitude that "it's just a prototype" and then you end up with a crappy product, since you end up using the prototype anyway in the final product
23:27:44 <gwern> sieni: heh. Remember me foolish fondly!
23:30:11 <sieni> gwern: it's kind of dropping when you train juggling. If you always juggle a pattern until you drop, you are training dropping a lot, so you end up being very good at dropping objects, which isn't exactly what you want if you are training juggling in the first place.
23:30:35 <gwern> ...wah?
23:30:47 <arcatan> I recognize myself
23:31:38 <arcatan> both as a juggler and as a programmer
23:45:28 <hpaste>  Gwern pasted "Looks like this will define positive reals" at http://hpaste.org/26
23:45:45 <gwern> well, it compiles, at least
23:46:21 <TSC> Why is there a different message for invalid subtraction?
23:46:37 <TSC> It seems you could omit that check and let it be handled by toPosReal
23:47:01 <gwern> hmm. at the time it didn't seem to work that way, but I was still realizing I was missing the derive
23:47:07 <skew> you should use MakePosReal in *
23:47:15 <skew> also in +
23:47:19 <skew> no point checking again
23:48:00 <TSC> Ah, yes
23:48:12 <TSC> I was thinking that you could do (1 + (-2)), but of course you can't (:
23:48:28 <TSC> So the result has to be non-negative
23:49:39 <skew> you have to make nonstandard names for things like sin
23:49:52 <TSC> You don't want a division operator too?
23:49:53 <skew> if it really can return a negative result
23:50:22 <gwern> TSC: I'll define a division one when I need it
23:50:33 <gwern> want to make sure I understand this num business first
23:55:25 <gwern> guess ' x - y = toPosReal ((fromPosReal x) - (fromPosReal y))' does make more sense after all
23:57:42 <gwern> aw. Fractional is not derivable
23:58:29 <qog> ghci will sometimes hang on loading in windows (vista) for me. I haven't been able to find anyone else with this problem using google or on the bug traq site.
23:59:18 <qog> I'm not sure what to try next (though rebooting generally fixes it... for a while).
