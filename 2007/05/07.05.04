00:00:37 <matthew-_> morning
00:07:33 <narain> ?src ap
00:07:34 <lambdabot> ap = liftM2 id
00:07:45 <dons> i must be doing something right:
00:07:46 <dons> Operations.hs:87:22:
00:07:46 <dons>     My brain just exploded.
00:07:48 <narain> :t (ap, liftM2 ($))
00:07:51 <lambdabot> forall (m :: * -> *) a b a1 b1 (m1 :: * -> *). (Monad m, Monad m1) => (m (a -> b) -> m a -> m b, m1 (a1 -> b1) -> m1 a1 -> m1 b1)
00:08:21 <narain> ?src ($)
00:08:22 <lambdabot> f $ x = f x
00:08:35 <narain> :t ($)
00:08:38 <lambdabot> forall a b. (a -> b) -> a -> b
00:08:48 <narain> ($) == id?
00:09:09 <narain> modulo type generality
00:10:31 <narain> ?quote explode
00:10:32 <lambdabot> ghc says: My brain just exploded.
00:10:59 <TSC> narain: It's not id
00:11:24 <narain> > (($) show 42, id show 42)
00:11:26 <lambdabot>  ("42","42")
00:11:36 <narain> isn't it?
00:12:46 <TSC> Hmm, maybe it is
00:13:42 <Korollary> Their types differ
00:14:56 <narain> it sure looks like  id :: a -> a, ($) == id restricted to a = (b -> c)
00:16:06 <narain> i was trying to understand why  ap  isn't defined as  liftM2 ($)  instead of  liftM2 id
00:16:51 <narain> but it seems to me that they're the same
00:25:20 <quicksilver> ($) is id specialised, yes
00:25:33 <quicksilver> ap should really be defined as liftM2 ($)
00:25:44 <quicksilver> that definition from src is a bit obfuscated really
00:26:02 <narain> well, it helped me learn something new :)
00:26:05 <narain> thanks quicksilver
00:26:48 <timthelion> hey, check out what I just created!!! http://www.timthelion.com/cgi-bin/blosxom.cgi//haskell-interactive-mode.html
00:26:51 <lambdabot> Title: timthelion's blog, http://tinyurl.com/yoxka5
00:30:03 <timthelion> is there a text file, or database that can be downloaded localy that has a list of all the functions that I can use with normal libraries in haskell?
00:30:24 <timthelion> forinstance, I want to search for the function that converts a string to a list of charicters.
00:30:41 <narain> a string *is* a list of characters
00:31:20 <narain> but in general, try hoogle
00:31:29 <narain> ?hoogle [a] -> a
00:31:30 <lambdabot> Prelude.head :: [a] -> a
00:31:31 <lambdabot> Prelude.last :: [a] -> a
00:31:31 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
00:31:37 <narain> ?where hoogle
00:31:38 <lambdabot> http://www.haskell.org/hoogle
00:32:07 <timthelion> hmm, that doesn't tell me much.  just the type definition.
00:33:08 <narain> if you use the hoogle website it returns links to the docs as well
00:33:13 <flux> @djinn (a -> a -> a) -> [a] -> a
00:33:13 <lambdabot> -- f cannot be realized.
00:34:07 <narain> flux: const head? :)
00:34:08 <QtPlatypus> @djinn (a -> a -> a) -> a -> a -> a
00:34:08 <lambdabot> f a = a
00:34:09 <Korollary> timthelion: You can download http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
00:34:23 <Korollary> i.e. http://www.haskell.org/ghc/docs/latest/libraries.html.tar.gz
00:39:36 <timthelion> what is that in reply to?
00:39:45 <timthelion> oops
00:40:36 <QtPlatypus> timthelion: Exactly the same thing I did.
00:48:08 <Cheery> @dice 1d61
00:48:09 <lambdabot> 1d61 => 27
00:48:45 <Cheery> @dice 1d61
00:48:46 <lambdabot> 1d61 => 13
00:48:56 <Cheery> @dice 1d61
00:48:56 <lambdabot> 1d61 => 25
00:50:48 <alan__> @whereis haddock
00:50:49 <lambdabot> Maybe you meant: where where+
00:50:53 <alan__> @where haddock
00:50:54 <lambdabot> http://www.haskell.org/haddock/
00:53:16 <quicksilver> timthelion: hoogle's underlying database has much of the information you want
00:53:27 <quicksilver> timthelion: even if the @hoogle lambdabot command doesn't show it all
00:53:27 <Cheery> What makes code hard to read/understand?
00:53:38 <quicksilver> Cheery: the reader's stupidity?
00:54:22 <Cheery> quicksilver: that's obvious, but yes
00:54:53 <alan__> haxml came with html documentation. can it only integrate with my current documentation via haddock?
00:57:11 <quicksilver> Cheery: to read code requires an 'assumed' vocabulary; a vocabulary of functions (and what they do) as well as syntactic idioms
00:57:30 <quicksilver> Cheery: code is hard to read when it uses either functions, or idioms, which you are not familiar with
00:58:04 <quicksilver> Cheery: That's assuming it hasn't in fact been *deliberately* obfuscated (misleading variable names, etc) which is a bit different
00:59:59 <Saizan> it's also easier to read when every function does a little and specific task
01:00:00 <Cheery> that's also obvious, actually, I had hard to read haskell once because I confused the monad binding to right shift
01:03:53 <Saizan> for cmd1 && cmd2 to complete cmd1 has to return a particular exit code, right?
01:05:07 <TSC> In bash?
01:05:12 <Saizan> yes
01:05:20 <dons> ?yow!
01:05:20 <lambdabot> I feel like I'm in a Toilet Bowl with a thumbtack in my forehead!!
01:05:24 <dons> scary!
01:05:28 <TSC> cmd2 only runs if cmd1 succeeds
01:05:33 <TSC> (I think)
01:05:56 <dons> right
01:06:06 <Saizan> this means that head runghc never succeeds :)
01:06:13 <dons> $ true && echo "part 2"
01:06:13 <dons> part 2
01:06:13 <dons> $ false && echo "part 2"
01:06:20 <dons> $
01:06:58 <dons> lazy eval :)
01:08:38 <quicksilver> Cheery: you may say it's obvious; and perhaps it is. But most people don't appear to realise it when they talk rubbish about some languages being harder to read than others :)
01:12:30 <Cheery> when I've been reading code written in C++, I've often hit code that's so ridiculously hard to read that it needs two weeks to find out what the code does
01:13:25 <dons> it interesting how many type system extensions we're starting to use in xmonad
01:13:28 <Cheery> in other hand, I'm very familiar with that stuff
01:13:46 <dons> existentials, dynamically typed values, newtype deriving, GADTs.. all to enforce more properties statically. fun stuff
01:15:14 <Cheery> what has been annoying me for a decade is that optimally working code is often the most hard to read
01:15:54 <quicksilver> well in, for example, a large project, the problem is often that to understand a given chunk of code you need to know what *this* and *that* functions do, and so on and so forth...
01:16:22 <Saizan> dons: Data.Dinamic?
01:16:32 <Saizan> *y
01:16:49 <ulfdoz> uaarg, my avl-tree balances quite sub-optimal.
01:16:51 <quicksilver> Data.Dynamite : If you accidentally drop your code, the whole thing blows up in your face.
01:17:26 <dons> actually, it uses Typeables, existentials, and nullay type classes, to provide open data types
01:19:15 <vegai> is hoogle there
01:20:17 * vegai ponders about a type some more
01:21:03 <narain> > typeOf (1,2,3)
01:21:04 <lambdabot>  (Integer,Integer,Integer)
01:21:18 <narain> > typeOf ["foo"]
01:21:20 <lambdabot>  [[Char]]
01:21:29 <narain> neat
01:21:33 <vegai> hmm, the Time modules are kind of a jungle
01:22:06 <vegai> ah, EpochTime
01:22:40 <quicksilver> vegai: System.Time bad, Data.Time good
01:22:55 <vegai> ?hoogle IO a -> CTime
01:22:56 <lambdabot> No matches, try a more general search
01:23:15 <narain> ?hoogle CTime
01:23:16 <lambdabot> Foreign.C.Types.CTime :: data CTime
01:23:16 <lambdabot> Time.toUTCTime :: ClockTime -> CalendarTime
01:23:45 <vegai> does the type make sense? I'm thinking of a benchmark function
01:23:47 <eumenides> ?hoogle epochTime
01:23:47 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
01:23:58 <vegai> IO a -> CTime that is
01:24:02 <narain> vegai: it might be IO CTime?
01:24:18 <vegai> yeah, I suppose it would have to
01:25:53 <narain> Time.getClockTime :: IO ClockTime
01:26:11 <narain> CPUTime.getCPUTime :: IO Integer
01:26:20 <narain> vegai: any of these? ^^
01:26:46 <Cheery> quicksilver: so kind of, in such systems functions leak too much details from their workings to another?
01:28:05 <ulfdoz> btw, shouldn't \\n interprete as a newline in a string?
01:28:45 <dons> > lines "foo\nbar"
01:28:46 <lambdabot>  ["foo","bar"]
01:28:54 <dons> > lines "foo\\nbar"
01:28:55 <lambdabot>  ["foo\\nbar"]
01:29:02 <ulfdoz> For some reason, this doesn't seem to work on MacOS.
01:29:34 <vegai> narain: yeah, I can write the function using those
01:30:06 <igli> \\ is literal \
01:30:29 <ulfdoz> The double-backslash was used due to irssi's readline.
01:30:41 <ulfdoz> It would interprete this, which leads to confusion in irc.
01:31:33 <Saizan> ulfdoz: do you get \n instead of a newline while printing the string?
01:31:42 <ulfdoz> Saizan: Yes.
01:31:55 <swiert> ulfdoz: you shold write "\n"
01:32:09 <swiert> now you're escaping the backslash.
01:32:21 <Saizan> you have a show that shouldn't be there
01:32:42 <Saizan> for example, do you call print on a String?
01:32:46 <dons> gee i'm having fun hacking on xmonad.
01:33:13 <dons> nice, practical problem, small code base, fun type tricks, QuickCheck == -Ofun !
01:33:23 <swiert> dons: What kind of properties do you check using QC?
01:33:36 <ulfdoz> > map ord "foo
01:33:36 <ulfdoz> bar"
01:33:37 <lambdabot>  Improperly terminated string
01:33:40 <dons> window manager api properties.
01:33:46 <ulfdoz> hrhr, single backslash and readline.
01:33:51 <dons> basically, using QuickCheck to check (and semi-formalise) the window manager api
01:34:01 <swiert> @where xmonad
01:34:02 <lambdabot> http://www.xmonad.org/
01:34:14 <ulfdoz> Prelude> map Char.ord  "foo
01:34:14 <ulfdoz> bar"
01:34:14 <ulfdoz> [102,111,111,10,98,97,114]
01:34:14 <dons> i wrote a blog post earlier this week about the kind of things we check
01:34:18 <ulfdoz> this works
01:34:34 <dons> swiert: http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
01:34:35 <lambdabot> Title: Haskell hacking, http://tinyurl.com/232r46
01:34:47 <swiert> dons: Thanks. I'll have a look.
01:34:50 <Saizan> ulfdoz: so, an example that doesn't work?
01:35:08 <dons> swiert: my supervisor made the point that we're using QC as machine support for finding a sane, coherent window manager api
01:35:16 <vegai> the snazzy ghc-6.6 tab completion thing doesn't work on my emacs too well. Could it be made to work?
01:35:17 <ulfdoz> Saizan: simple print "foo\\nbar"
01:35:29 <vegai> I mean when using the HaskellMode and the interpreter inside that
01:35:32 <dons> which would be harder by far without QC support guiding us towards nice, orthogonal properties
01:35:47 <Saizan> ulfdoz: you should use putStrLn "foo\nbar"
01:36:02 <Saizan> ?src print
01:36:03 <lambdabot> print x = putStrLn (show x)
01:36:20 <swiert> dons: as in "writing the quickCheck properties force us to get the API just right"?
01:36:28 <dons> exactly.
01:36:30 <Saizan> see? that (show x) escapes \n one more time
01:36:31 <ulfdoz> I think, the show is escaping the backslash.
01:36:48 <dons> so, for small data structures, you can work out a composable, sane api by hand (say, for stacks or queues)
01:36:56 <dcoutts> g'morning dons
01:36:56 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:36:59 <dons> but for a 2 or 3 level more complex structure, you need machine support
01:37:03 <dons> and QC provides that machine support
01:37:11 <dons> guiding us towards coherent interfaces
01:37:15 <dons> heya dcoutts
01:37:35 <dcoutts> @tell sorear I'd rather just fix it than add FAQs
01:37:35 <lambdabot> Consider it noted.
01:37:48 <dons> so, I think Manuel's point was, QC lets us scale up the process of finding a composable, clean api, to larger structures.
01:38:07 <swiert> Aha. Got you.
01:38:11 * dcoutts is QCing binary today
01:38:40 <dons> nice. we better start writing soon, dcoutts. and get the examples implemented
01:38:46 <dcoutts> @arr!
01:38:47 <lambdabot> Yeh scurvy dog...
01:38:56 <vegai> agh, the rest of the line editing commands don't work either in HaskellMode :/(
01:39:24 <swiert> dons: Writing something for Haskell Workshop?
01:39:57 <dcoutts> dons: do you know who knows about the HTTP libs (appart from bringert) and why we have both HTTP-1.0 and HTTP-3000
01:39:59 <dons> swiert: yeah.
01:40:11 <dons> dcoutts: hmm, -3000 sounds like a bringert-ism
01:40:15 <dcoutts> aye
01:40:17 <ulfdoz> Saizan: But is this intended behaviour, to have show escaping special characters?
01:40:22 <dons> he aims big
01:40:23 <dcoutts> it used to just be a date
01:40:29 <dcoutts> 2006.blah
01:40:35 <dons> right
01:40:42 <swiert> is it just like Python3k?
01:40:48 <lokadin> where can I get the privmsg function that's used in the IRC bot tutorial?
01:40:53 <dons> hopefully not :)
01:40:57 <dcoutts> so which is the latest version? 1.0, 2006.7.7 or 3000 ?
01:41:01 <dons> lokadin: its mentioned in there somewhere, isn't it?
01:41:05 <dcoutts> which should be be using?
01:41:08 <dons> dcoutts: hmm. -3k I think...
01:41:09 <dcoutts> be/we
01:41:15 <lokadin> dons: it says you add it, but doesn't actually have the code
01:41:20 <dcoutts> dons: and that's official, not just a hack?
01:41:21 <lokadin> We add the privmsg function - a useful wrapper over write for sending PRIVMSG lines to the server.
01:41:26 <dons> lokadin: check the full source listing at the end
01:41:29 <dcoutts> dons: so I should make cabal-upload dep on -3000 ?
01:41:38 <dons> dcoutts: hmm.
01:41:45 <dons> can we ask bringert?
01:41:55 <dcoutts> dons: not really
01:42:02 <dcoutts> he's feeding his baby
01:42:02 <lokadin> dons: kk thanks :D
01:42:13 <dcoutts> well, looking after
01:42:15 <dcoutts> :-)
01:42:27 <dons> yeah, scary!
01:42:36 <dons> we're going to have to grow up one day.
01:42:46 <dcoutts> don't say that"
01:42:48 <dcoutts> !!
01:42:53 <dons> no more unicycles!
01:42:56 <dons> no more all night hacking!
01:42:58 <dcoutts> grrr
01:43:38 <vegai> when my kid was < 1 year old, I was much more often up in the night
01:43:44 <vegai> so it really depends...
01:43:49 <dons> that's even worse! :)
01:44:55 <vegai> System.Time seems to have what I need. What's bad about it, quicksilver?
01:45:14 <quicksilver> vegai: it lacks most of the useful functions you expect to convert from one form to another
01:45:37 <vegai> yeah... well I just need two millisecond figures and their difference
01:46:02 <swiert_> damn you TYPES2007 wireless connection!
01:46:33 <dons> buzilla dev sez: "Nowadays, almost all of our competitors have one advantage: they are not written in perl. They can actually develop features more quickly than we can, not because of the number of contributors they have, but because the language they're using allows it."
01:46:56 <Baughn> dons: Where does it se that?
01:47:09 <dons> http://avatraxiom.livejournal.com/58084.html
01:47:10 <lambdabot> Title: avatraxiom: The Problems of Perl: The Future of Bugzilla
01:47:35 <dons> writing a small app in perl that has to scale up to be huge is like writing it in sed...
01:48:17 <Baughn> dons: I can only assume that at the time the only realistic alternative was C
01:48:18 <danigm> hi everyone, i'm looking for a good tutorial or documentation that explain the read of bin files, I wan't to use haskell to read an image and modify that. Someone know about a tutorial or something?
01:48:30 <quicksilver> dons: nah, it's not
01:48:31 <swiert_> dons: Have you considered using other than Map Int [a] for xmonad?
01:48:42 <quicksilver> dons: perfectly possible to write sensibly designed and abstracted code in perl
01:48:51 <swiert_> Reading your blogpost, I couldn't help think there's some nice zippery-action going on somewhere...
01:48:53 <quicksilver> dons: the fact that some people don't, is a different thing..
01:49:09 <dons> quicksilver: true. more than one way to tie a noose.
01:49:14 <dcoutts> dons: so HTTP-1.0 is identical to HTTP-3000 except for the version number
01:49:20 <dons> swiert_: hmm. we considered only Sequence-y types.
01:49:47 <dons> swiert_: but that does sound interesting (for a nice 2 level pure data type)
01:50:03 <swiert_> dons: This could be implemented really neatly in a dependently typed language, where you know the StackSet in your type.
01:50:21 <dons> the form of the stackset?
01:50:39 <dons> and 'this' meaning, the api, with type-level constraints?
01:51:04 <dons> I was thinking today about moving some of the non-empty constraints into the type
01:51:12 <dons> since that's pretty easy now with a GADT
01:52:41 <vegai> quicksilver: ah, seems like getUTCTime and diffUTCTime are pretty good
01:53:14 <swiert> dons: Yes the StackSet.
01:53:16 <vegai> getCurrentTime, that is
01:53:31 <swiert> Basically, it is a Vector of lists.
01:53:48 <swiert> A Vector being a list of known length.
01:53:57 <dons> right.
01:54:05 <dons> so some good fixed constraints there.
01:54:09 <dons> that are set on construction
01:55:18 <swiert> Instead of storing an Int of where you are, you represent the StackSet as a zipper, navigating through the windows.
01:55:36 <dons> mmm right.
01:56:00 <swiert> My fingers are itching to hack this up in Agda2...
01:57:15 <dons> hehe. now I'm intrigued too.
01:57:33 <dons> yes, lots of internal manipulation from known locations
01:58:01 <dons> so its very zipperish, given the currently focused window in each stack, and the current workspace
01:58:52 <dons> then we might get a more natural implementation of left/right next/previous and other rotate/swap operations. while simple things like index and peek just fall out easily
01:58:59 <vegai> ?paste
01:59:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:59:22 <swiert> dons: Yeah. That sounds about right.
01:59:34 <swiert> You might be able to get away with this stuff using GADTS...
01:59:41 <hpaste>  vegai pasted "trivial benchmark. Acceptable?" at http://hpaste.org/1701
01:59:55 <dons> yeah, its almost just simple indexing.
02:00:13 * dons reads some zipper papers
02:00:24 <vegai> I suppose that seemed like a more difficult thing at the start than it was
02:00:33 <vegai> perhaps there'll be something interesting soon...
02:01:52 <dons> hehe, conor's website is quite fun, http://www.cs.nott.ac.uk/~ctm/
02:01:55 <lambdabot> Title: Conor's Staring out the Window
02:03:30 <vegai> http://haskell.org/http/ is probably the preferred http client library?
02:03:31 <lambdabot> Title: Haskell HTTP package
02:03:59 <dons> http 3000, I think. we just spoke about it (is it on hackage?)
02:06:04 <Saizan> it is
02:06:30 <vegai> yeah, there is it
02:06:51 <vegai> seems to be the same thing
02:07:08 <vegai> only newer
02:24:31 <hpaste>  Cheery pasted "I don't know who made it right, but I love that person who did it!" at http://hpaste.org/1702
02:26:26 <Cheery> erlang is a great instance about a language where it has been done wrong
02:30:03 <Cheery> without that weird quard allowing me to do such filterrant function, that'd be much more ugly
02:30:27 <Cheery> those things allows me to do something like this:
02:30:35 <Cheery> let active' = foldl appFocus active events
02:30:42 <Cheery> then I can put: when active (renderContents >> glSwapBuffers)
02:31:28 <alan__> is there a haskell ide which supports command completion?
02:31:50 <dons> alan__: ghci does
02:32:01 <dons> alan__: but do you mean identifier name completion?
02:32:10 <alan__> dons: im using the windows ghci at the moment
02:32:14 <dons> Cheery: you like guards? :)
02:38:25 <Cheery> dons: what does it look like? In most other languages I've seen them, I've not been able to do that
02:39:42 <dons> yeah, guards are nice.
02:39:55 <Cheery> (oh, and lemmih fixed the thing which prevented me before from implementing such focus functions at all)
02:40:09 <Cheery> Lemmih++
02:42:52 <alan__> 
02:45:04 <arcatan> Cheery: what's wrong with Erlang guards?
02:46:48 <Cheery> arcatan: they put limitations on what can appear in guards
02:47:12 <Cheery> such 'f a' would have been just a dream in erlang world
02:47:23 <arcatan> ah, yeah. I think they don't want side-effects in guards
02:47:41 <Cheery> true
02:47:54 <Cheery> it's similar to every function being some sort of Erlang -monad
02:48:17 <Cheery> therefore you can't put your own Bool -function into guard since it'd be: Erlang Bool
02:48:42 <arcatan> yeah
02:50:14 <Cheery> the limitation is technical I guess, and they have documented it too, thought.
02:53:51 <dons> ah right. because of the impurity.
02:53:55 <hpaste>  Cheery pasted "corresponds to nehe lesson3, now." at http://hpaste.org/1703
02:54:06 <dons> yeah, impure is the wrong default for a concurrent world.
02:54:52 <hpaste>  Cheery annotated "corresponds to nehe lesson3, now." with "the IgniteSDL -module" at http://hpaste.org/1703#a1
02:56:09 <danigm> what i need to import to use the data Word8?
02:56:52 <norpan> Data.Word
02:56:58 <dons> ?hoogle Word8
02:56:59 <lambdabot> Data.Word.Word8 :: data Word8
02:57:23 <danigm> ok thanks
02:57:51 <Cheery> do you have ideas or proposals for that rewrite?
03:00:31 <vegai> oy, this is too hard with Haskell currently :/
03:00:43 <vegai> 'this' being writing simple http clients
03:01:40 <Cheery> oh darn, I forgot to ask Lemmih whether he could also put instances for Read of InitFlag & SurfaceFlag
03:01:51 <Cheery> but.. I can do that later
03:01:53 <ibid> vegai: you mean the actual HTTP code or stuff using one?
03:02:03 <pitecus> anyone know of a haskell library (or bindings) to a maximum entropy toolkit?
03:02:09 <vegai> I mean doing couple of get and post requests
03:02:15 <dcoutts> dons: building xmonad and deps with cabal-install...
03:02:29 <ibid> vegai: are you using some HTTP library?
03:02:32 <Cheery> preferrably I'll do it when I'm further, so that I'd again have some more stuff to fix
03:02:39 <vegai> yes, I was using http://haskell.org/http/
03:02:40 <lambdabot> Title: Haskell HTTP package
03:02:53 <vegai> that's a good basis, but really requires something on top of it
03:03:23 <dons> dcoutts: oooh. good test case!
03:03:27 <vegai> ibid: are the fenfire guys doing something like this as well?
03:03:33 <Cheery> google summer of code mentioned improvements into the Text.HTML -module
03:03:47 <ibid> vegai: they're doing *something* new. have you asked them? :)
03:03:51 <Cheery> what's wrong in Text.HTML?
03:03:57 <dons> vegai: yeah, its too hard i agree. a curl binding would be a lot easier
03:04:10 <dcoutts> dons: we should all start dog-fooding cabal-install rather than doing manual wget + runghc Setup blah
03:04:19 <dons> yeah
03:04:20 <ibid> vegai: come to the channel and ask, i've "dropped off the cart" already :)
03:04:28 <dons> maybe make a post with an example, so we can start on it?
03:04:35 <Cheery> is there a cabal-install? :D
03:04:40 <dons> is cabal-install standalone?
03:05:55 <Cheery> thought, I think darcs get + runghc Setup config+build+install is nice already
03:06:43 <Cheery> and cabal files are working very well
03:07:21 <dcoutts> dons: yes it is.
03:07:49 <dcoutts> Cheery: this does automagic deps though :-)
03:08:27 <dcoutts> it automates the downloading, cabal config,build,install of packages and their dependencies
03:09:00 <mnislaih> dcoutts: I've been using cabal-install for quite a while now
03:09:09 <dcoutts> mnislaih: cool, I've not :-)
03:09:22 <dcoutts> mnislaih: do you think --user should be the default?
03:09:35 <dcoutts> mnislaih: otherwise on unix it fails by default which isn't freindly
03:09:47 <dcoutts> since you don't have perms for /usr/local
03:09:47 <mnislaih> probably yes
03:10:32 <mnislaih> for cabal install there seem to be two levels of --user, actually
03:10:48 <mnislaih> with regard to cabal-install prefs, and with regard to cabal itself prefs
03:10:56 <alan__> i downloaded drift via darcs and all i got was a configure.ac and a Makefile.am
03:11:20 <mnislaih> i.e. it is not the same thing "cabal-install --user install blah"  and "cabal-install install --user blah"
03:12:59 <mnislaih> I think both --user would need to be default, the second one for sure
03:14:08 <dcoutts> mnislaih: hmm, just "cabal-install --user-install install blah" works for me
03:14:13 <Cheery> dcoutts: well, that is nice, but haskell modules have very little of depedencies so it's quite nice to DL them by hand already
03:14:33 <dcoutts> mnislaih: though why it's called --user-install rather than just --user like cabal has, I don't know.
03:15:04 <dcoutts> Cheery: they only have few deps because they're a pain the in posterior to deal with at the moment so people avoid them.
03:15:16 <dcoutts> Cheery: I expect much more modularisation in the future.
03:15:43 <dcoutts> Cheery: eg to install xmonad just now cabal-install have to install two dependent packages, X11 and X11-extras
03:15:47 <yaxu> ooh, london haskell user group!
03:15:59 <dcoutts> Cheery: random Gtk2Hs apps will have more deps than that
03:16:57 <mnislaih> "cabal-install install --user blah" works the same
03:17:28 <dcoutts> mnislaih: really? does that pass --user to cabal's configure perhaps ?
03:17:43 <mnislaih> dcoutts:  yes,
03:17:43 <dcoutts> mnislaih: if so that'd set a user registration but not install location
03:17:45 <alan__> if i compile ghc under cygwin will i get function name completion?
03:17:50 <dons> dcoutts: if this is really ready to get the broader devs beta testing, can you write a post to libraries@ or haskell-cafe@ asking for people to start using it, saying how to best get cabal-install, and giving an example?
03:18:06 <mnislaih> and any other flags you give after the install command
03:18:07 <dcoutts> dons: we're not sure we're quite there yet
03:18:19 <dcoutts> dons: we need a few more hackers to try it and fix the obvious bugs
03:18:54 <bvd> Hello, I'm trying to rebuild xmonad. However when I ./Setup.lhs configure --prefix=$HOME I get the error:  Could not find module `Distribution.Simple'. I recently installed GHC HEAD but I'm now just using my normal GHC-6.6?
03:19:07 <mnislaih> dcoutts: and  right, it doesn't set a install location
03:19:18 <dcoutts> bvd: you're missing Cabal-1.1.6.x
03:19:51 * fasta notes building Haskell software is invariably a pain
03:19:54 <dcoutts> mnislaih: which might not matter on windows fi you're admin, but on unix it'll try to do a user registration but install to /usr/local :-)
03:20:06 <dcoutts> fasta: we're fixing it, slowly.
03:20:10 <bvd> dcoutts: ghc-pkg -L says I have (Cabal-1.1.6), Cabal-1.1.6.1 and  Cabal-1.1.7 installed
03:20:29 <dons> bvd: yes, looks like you're missing cabal. or one of them is hidden. could you try: runhaskell Setup.lhs configure  .. ?
03:20:56 <bvd> dons: same error
03:21:03 <fasta> dcoutts: yes, but one would expect with Haskell the great Silver Bullet From Heaven, it should go somewhat faster. (yes, I know I could send patches...)
03:22:00 <fasta> Some guy made this and I don't think he took as long as the Haskell "community" http://snow.iro.umontreal.ca/
03:22:02 <lambdabot> Title: Snowfort
03:22:05 <dcoutts> fasta: it's mostly a matter of dev time (or the lack therof) and experience, we don't do that many IOish file churning programs.
03:22:08 <dons> bvd, is it possible your ghc head install has resulted in overwriting your cabal installation for 6.6?
03:22:16 <dons> bvd, i'd try rebuilding and install cabal
03:22:31 <fasta> dcoutts: ah, that makes sense.
03:23:05 <fasta> dcoutts: In my experience "hairy stuff" is complicated in Haskell
03:23:11 <bvd> dons: I installed GHC HEAD in a specific directory. But I will try reinstalling Cabal. Thanks
03:23:26 <fasta> dcoutts: a sublanguage for expressing mutable stuff would be much better.
03:23:41 <dcoutts> fasta: luckily we have just such a sublanguage
03:23:52 <fasta> dcoutts: you do?
03:24:00 <dcoutts> it's called the IO monad :-)
03:24:04 <fasta> ...
03:24:18 <dcoutts> actually it's too loose
03:24:39 <dcoutts> for build tasks where you want proper logging etc etc, the IO monad allows you to do too much
03:24:39 <fasta> I don't really hate using putStrLn etc, but Refs... are not fun.
03:24:59 <dcoutts> we don't need refs for this task
03:25:19 <fasta> dcoutts: "allows you to do too much"?
03:25:46 <dcoutts> you want a more restricted Build monad which does the logging for you and doesn't let you invent a dozen different ways of calling a program and getting it's output
03:27:45 <dons> fasta: but snow* is just hackage + cabal.
03:27:53 <dons> they're really quite comparable, I think.
03:28:02 <fasta> dons: that's why I mentioned it
03:28:07 <dons> one command install and so on, centralised deps.
03:28:12 <matthew_-> if anyone inverted a programming language that did more damage to your head than Haskell, it'd be illegal
03:28:16 <fasta> dons: that's a one man show
03:28:35 <dons> right .like hackage (Ross) and cabal (Isaac
03:28:45 <fasta> matthew_-: inverting a language is soo 1337 :)
03:28:50 <dons> its all one man shows
03:29:07 <matthew_-> fasta: you see what it's done to me!
03:29:13 <bvd> dons: rebuilding Cabal fixed the problem. Thx!
03:29:19 <dons> great.
03:29:28 <fasta> dons: ok, I thought Cabal was worked on by more people.
03:29:33 <yaxu> i wonder what an inverted haskell would look like
03:29:45 <dons> not really, no. there's a 'patch apply' guy, dcoutts. that's about it.
03:29:54 <fasta> yaxu: rotate your head
03:30:08 <dons> the few projects that do have more than 1 full time dev are pretty obvious
03:30:09 <yaxu> like a powerball?
03:30:19 <dons> things like gtk2hs, xmonad, darcs.
03:30:27 <dons> ghc, of course.
03:30:59 <dons> but yeah, hackage and cabal aren't those, since people just want to work on their own stuff, not the infrastructure
03:31:26 <dons> snow* is remarkably like hackage, we noticed this when it was released.
03:31:35 <dons> i suspect the idea was based on looking at hackage.haskell.org
03:31:36 <dcoutts> you can't get papers for doing infrastructure
03:31:55 <dons> yeah, isaac had a hard time with the cabal paper, for example
03:31:59 <dons> so hackage, no chance.
03:32:30 <dcoutts> and the 'practical' haskell users want it to just work and not bother them with infrastructure details
03:32:38 <dcoutts> result: very few people to hack on this stuff
03:33:15 <dons> luckily things are mostly in a state where they just work.
03:33:33 <dons> and we do get SoC students to work on infrastructure
03:33:33 * fasta likes Snowfort's logo :)
03:33:36 <dons> so thats good
03:33:42 <dcoutts> mnislaih: do you want a cabal-install bug I've tracked down? :-)
03:33:53 <mnislaih> sure dcoutts
03:34:03 <dons> yeah, i wonder if snowfort is really a (prettier) clone of hackage, or its just coincidence.
03:34:04 <mnislaih> put up a ticket and assign it to me
03:34:22 <dcoutts> mnislaih: in CabalInstall.Fetch.fetch, parseDep ignores version numbers when parsing package identifiers
03:34:42 <dcoutts> mnislaih: eg athe beginning of fetch, add print (pkgs, map parseDep pkgs)
03:34:56 <dcoutts> (and derive Show for UnresolvedDependency)
03:35:11 <fasta> dons: the planet system is about the same
03:35:17 <fasta> dons: AFAIK, it
03:35:31 <dcoutts> mnislaih: so when I ask to fetch HTTP-1.0 it instead resolves to HTTP-3000 because it ignores the version num and treats it as HTTP-any
03:35:42 <fasta> dons: 's just a unification of everything that already existed in the Scheme world.
03:35:59 <fasta> or Scheme village, if you prefer ;)
03:36:10 <dcoutts> mnislaih: similar UI buglet, when I ask to fetch a package that does not exist, it does nothing bug gives no helpful error message.
03:36:41 <dcoutts> mnislaih: the 'install' command is a bit better in that regard
03:36:50 <dcoutts> cabal-install: Couldn't satisfy dependency: 'foobar -any'.
03:37:14 <mnislaih> dcoutts, yes, I didn't ever use fetch before
03:37:21 <bvd> dons: You recently sent a mail about using dzen for a status popup bar. I have a weird problem with that. My Config.hs lists : ...((modMask, xK_s), spawn "/home/bas/bin/status.sh")... When I'm in a console and I run "/home/bas/bin/status.sh" it works perfectly. However, when I type modMask + xK_s no status bar pops up but dzen DOES run in the background. Should I file a bug-report for that or do you know a simple fix?
03:38:25 <lome31337> Hi! How can I get DataType of Constr fields? e.g something like
03:38:47 <mnislaih> dcoutts: I'll put up a ticket and look at it during the weekend
03:38:52 <lome31337> getConstrs (Just 5) => [Integer]
03:40:07 <dcoutts> mnislaih: cheers
03:40:26 <dons> bvd, i can only imagine that maybe dzen isn't in your path when run from 'spawn' ?
03:40:34 <danigm> i have a problem, someone can show me an example of use of hgetBuf with openBinaryFile?
03:40:49 <lome> I'd try to use gmapQ (Nothing `mkQ` (Just . toConstr)) but there are type errors
03:40:56 <dons> there's no obvious reason for it to not work (and it works here). double check the example in XMonadContrib perhaps?
03:41:11 <dons> danigm: to read bytes?
03:41:18 <dons> danigm: maybe just use a bytestring?
03:41:34 <danigm> yes
03:41:36 <dons> otherwise, you'll need to malloc/allocate an array from Foreign.Marshal, then hGetBuf into that Ptr.
03:41:40 <bvd> dons: well, dzen will run when I type modMask + s, however its window is not shown.
03:41:42 <danigm> how i can do that?
03:41:47 <dons> danigm: can you use Data.ByteString instead?
03:41:54 <dons> its a lot nicer interface to strict byte arrays
03:42:06 <dons> bvd, hmm. could it be rendered under the current window?
03:42:12 <dons> check what happens on an empty workspace
03:42:17 <bvd> lome31337: maybe you can use Data.Typeable?
03:42:40 <danigm> dons: where i can find a simple example of read binary data?
03:42:40 <lome> bvd: Yes, and how can I get constr field types?
03:43:05 <dons> danigm: do you want the result as just raw bytes read from a file?
03:43:23 <bvd> dons: the same problem. But I do have a background image set using Esetroot. Maybe it's shown behind that?
03:43:24 <danigm> dons: yes, i want to read an image
03:43:32 <dons> bvd, hmm, no. it wouldn't be
03:43:39 <quicksilver> if you do, in fact, just want to read a few bytes, you can just use hGetChar
03:43:50 <quicksilver> but strict bytestrings are rather more powerful
03:44:07 <quicksilver> hGetChar is incorrectly named since really it's hGetByte
03:44:10 <dons> danigm: here's the api for bytestrings, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
03:44:13 <lambdabot> http://tinyurl.com/wn5rt
03:44:19 <dons> you can use that to suck in your bytes. quickly.
03:44:52 <dons> to parse it into some structure, you'd just roll your own parser using bytestring operations. for more complex tasks, Data.Binary or maybe a custom parser combinator set
03:45:15 <dons> danigm: so you can just use 'readFile "foo" to get a byte array
03:45:34 <dons> dcoutts++ uploaded filepath
03:46:04 <dcoutts> @arr!
03:46:04 <lambdabot> Drink up, me 'earties
03:46:08 <dons> it would be nice hackage to get a reverse dependency, given a library, find out how many users it has
03:46:14 <dons> (i.e. for binary or filepath )
03:46:15 <dcoutts> and cabal-1.1.6.2
03:46:37 <dcoutts> dons: oh I thought at first you meant users like downloads, end users
03:46:51 <dons> hehe. no, not so fancy
03:46:52 <dcoutts> dons: but yes, that'd be an interesting statistic
03:47:08 <dons> just a graph of dependencies. and watch them grow over time
03:47:25 <dcoutts> dons: yeah, we've got dependencies for each package, reverse deps would be interesting too
03:47:26 <dons> mostly isolated, then links starting to form between things
03:47:34 <dons> and packages clustered around certain key libs
03:48:03 <Igloo> For a pretty #users graph: http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6%2Clibghc6-alut-dev%2Clibghc6-arrows-dev%2Clibghc6-cgi-dev%2Clibghc6-fgl-dev%2Clibghc6-glut-dev%2Clibghc6-haskell-src-dev%2Clibghc6-hgl-dev%2Clibghc6-html-dev%2Clibghc6-mtl-dev%2Clibghc6-network-dev%2Clibghc6-openal-dev%2Clibghc6-opengl-dev%2Clibghc6-quickcheck-dev%2Clibghc6-time-dev%2Clibghc6-x11-dev%2Clibghc6-xhtml-dev%2Clibghc6-gtk-dev&show_installed=on&want_le
03:48:06 <lambdabot> Title: popcon graph, http://tinyurl.com/3bsnp2
03:48:25 <Igloo> Bah, that got truncated
03:48:43 <Syzygy-> Igloo: Why don't you shurl it before you paste it?
03:48:46 <Igloo> http://tinyurl.com/2legep
03:48:48 <lambdabot> Title: popcon graph
03:49:44 <Syzygy-> Neat
03:49:46 <Igloo> (you can remove ghc6 from teh start of the list to be able to see the libs better)
03:49:57 <quicksilver> hmm
03:50:04 <quicksilver> that seems like quite a lot of ghc6 users to me
03:50:09 <quicksilver> given that popcon is only a small sample
03:50:12 <quicksilver> nice :)
03:50:28 <dons> cool
03:50:53 * Igloo notes a recent x11 spike - xmonad at work?
03:51:01 <Syzygy-> Igloo++ Cute graphishness
03:51:48 <dons> Igloo: almost certainly. are there any other users of X11?
03:52:09 <dons> (we've had 150k hits on xmonad.org during April, so there's bound to be a couple of people who tried it out)
03:52:18 <dons> though we've tried to get people to use the hackage packages
03:53:04 <dons> since we need X11 1.2 (is that in debian?)
03:54:34 <Igloo> Yes
03:54:53 <dons> Igloo: tied to xmonad, with the release date highlighted, http://tinyurl.com/2pqzlw
03:54:55 <lambdabot> Title: popcon graph
03:55:19 <dons> i think that's a trend :-)
03:55:24 <Igloo> Heh
03:56:08 <Igloo> That's pretty cool
03:56:26 <dons> what X11 is in debian, 1.2?
03:56:30 <Igloo> Yup
03:56:36 <dons> great. so that's a good sign then.
03:56:44 <Igloo> From 6.6 extralibs
03:56:58 <dons> nice strong correlation between xmonad 0.1, and people sucking down X11 1.2
03:59:21 <alan__> i downloaded the 6.6.1 source code and i can't find the prelude functions
03:59:57 <dons> there's in GHC/* and in Data/* and System/*
04:01:02 <Igloo> libraries/base/Prelude.hs is the Prelude module, but it mostly imports other things
04:01:53 <alan__> ok so its not like the hugs one where the functions are written inline
04:03:30 <dcoutts> dons: Igloo: what do you think the default cabal-install location should put libs and binaries in ?
04:03:48 <Igloo> dcoutts: For users or the system?
04:04:03 <dcoutts> dons: Igloo: for users on unix, it's currently ~/usr/lib and ~/usr/bin
04:04:18 <dcoutts> ~/usr/bin seems wrong, it's not in peoples PATH by default
04:04:48 <Igloo> dcoutts: I'd be inclined to put libraries in ~/.cabal/ghc-6.6.1/<package>
04:05:13 <dcoutts> Igloo: so would I, ~/.cabal-install/something/ghc-x.y etc
04:05:13 <Igloo> I guess the same with executables, and telling the user what to add to their path
04:05:37 <dcoutts> Igloo: it'd be nice for it to "Just Work"tm, no fiddling by default
04:05:51 <quicksilver> dcoutts: can't be done, in a unix mindset
04:05:58 <quicksilver> dcoutts: altering their path would be evil
04:06:01 <dcoutts> Igloo: so I'd use the lib and data dir under .cabal-install, but use ~/bin for executables
04:06:10 <quicksilver> dcoutts: and yet, you won't have write permission to anything else :)
04:06:15 <dcoutts> quicksilver: most people have ~/bin in their path by default
04:06:28 <quicksilver> dcoutts: I doubt that :)
04:06:31 <dcoutts> quicksilver: eg the cluless ubuntu users
04:06:33 <Igloo> dcoutts: I don't, I have ~/local/bin. And I don't want you dropping random config files in there either
04:06:49 <dcoutts> Igloo: then don't ask us to install things :-)
04:06:53 <Igloo> dcoutts: I symlink the executables I care about into there
04:07:00 <dcoutts> Igloo: you can override all these defaults
04:07:26 <Igloo> dcoutts: Well, my opinion is still that it should be the same as libraries
04:07:43 <dcoutts> but then I can't find them or use them by default :-(
04:07:52 <Igloo> I would be annoyed with something dropping stuff in my ~/bin - that's a directory I control, not one that you do
04:08:26 <dcoutts> Igloo: but this is a package installation tool we're taling about, currently it defaults to /usr/local/bin !
04:08:46 <dcoutts> which certainly is the wrong default, since it's not writable
04:09:37 <dcoutts> Igloo: we can have it be more verbose about where it has put binaries than with libs, and mention the path if it looks like it's not in the path
04:10:05 <Igloo> dcoutts: It still shouldn't be putting random files in my directories
04:10:06 <dcoutts> hia ndm
04:10:14 <Igloo> Cleaning up after that sort of thing is a PITA
04:10:29 <ndm> hi dcoutts
04:10:38 <dcoutts> Igloo: but all you're saying is that it can't put them anywhere useful, you always want manual intervention to make it work
04:10:49 <dcoutts> that's not very helpful
04:10:54 <Igloo> And it may be /a/ package installation tool, but it's not /the/ package installation tool
04:11:07 <ndm> dcoutts WinHugs needs a nice windows installer, and you seem to have done very well with Gtk2Hs
04:11:10 <dcoutts> that's why it doesn't install into /usr/bin :-)
04:11:11 <Igloo> dcoutts: You can make it put symlinks in ~/.cabal/bin/ if you want
04:11:16 <ndm> dcoutts hints, tips, offers to do it ;)
04:11:16 <Igloo> Then users can add that to their path
04:12:09 <dcoutts> ndm: I'm writing a post about how to do it, that's even better since then everyone can do it :-)
04:12:51 <dcoutts> Igloo: but if we're using ~/.cabal-install/bin then we might as well just put them there directly, no need for symlinks, or where did you mean putting the symlinks?
04:12:58 <ndm> dcoutts that is even better :)
04:14:10 * dcoutts -> out
04:14:57 <Igloo> dcoutts: symlinks mean you don't have to worry about 2 packages having the same executable names
04:15:41 <Igloo> dcoutts: But I'm much less fussed about what you do inside .cabal-install
04:20:02 <dons> i just got an email asking if I'd seen 'xmonad', and if so, could I package it for openbsd :-)
04:20:30 <ivanm> heh
04:21:00 <Botje_> tell them it's not secure. they'll rewrite it in C.
04:21:05 <Botje_> suckers :)
04:21:32 <ivanm> dons: by the way, who first got the idea to write xmonad, and why?
04:22:46 <dons> its been kicking around for about 4 years, basically, I didn't want to write lua to script ion. http://www.cse.unsw.edu.au/~pls/thesis-topics/windowmanager.html
04:22:47 <lambdabot> Title: Thesis Topic : The Haskell Window Manager
04:23:03 <dons> and this year sjanssen just dived in and wrote enough to get us started.
04:23:34 <ivanm> *nod*
04:23:55 <ivanm> also, with how you can use dzen for a status bar, do you know if its possible to use any other panel-like program?
04:24:10 <dons> interestingly, anselm, the author of dwm, actually considered coming to unsw to do this haskell wm project for his thesis. he sent us some emails about it
04:24:26 <dons> and tuomo, the author of ion, used to hang out here a lot, and helped me write yi.
04:24:37 <dons> so really, if they weren't going to do it, we had to do it ourselves one day
04:25:19 <ivanm> heh
04:25:33 <ivanm> so unsw = home of tiling wms? :p
04:28:44 <dcoutts_> Igloo: aye, I take the point about symlinks
04:29:43 <dcoutts_> Igloo: perhaps the thing to do it have a cabal-install config setting which says which dir to put symlinks in, it's default to $HOME/bin, bout you could change that setting once and have it do what you want for evermore
04:30:15 <Igloo> dcoutts_: Soudns good, except it should default to $HOME/.cabal-install/bin  :-)
04:30:20 <dcoutts_> hah hah
04:30:41 <dcoutts_> I want it to "Just Work"tm for the clueless ubuntu-using masses
04:30:53 <Igloo> (hello immovable object, my name is irresistible force)
04:31:04 <dcoutts_> ;-)
04:31:44 <dcoutts_> Igloo: you and I who are so anal and mistrusting of packaging systems know enough to change the default setting
04:33:20 <therp> dcoutts: well thanks for the "how to write shared libraries" pointer, but in fact, respecting ulrich dreppers effort in this area, maybe someone else should do the technical writing
04:33:35 <dcoutts_> therp: heh heh, aye
04:35:12 <therp> I better read the ELF specs
04:36:08 <fasta> Can I already use ∆ in my source code when I use ghci?
04:37:27 <dcoutts_> fasta: you can use it in the .hs file, but you cannot type it at the ghci command line
04:38:14 <fasta> dcoutts_: I had a =  let  ∆ = 5 in 2 in a file, and then did C-c C-l
04:38:17 <fasta> dcoutts_: that fails
04:38:23 <fasta> dcoutts_: is my version too old?
04:38:38 <dcoutts_> fasta: ghc 6.6 supports unicode in .hs files
04:38:52 <Igloo> fasta: It's an operator, so you'd need () around it there
04:39:04 <dcoutts_> fasta: do you know if ∆ is considered a variable character or an operator one?
04:39:35 <fasta> Igloo: ah, ok
04:39:40 <fasta> Why is it an operator?
04:39:44 <alan__> how do i unlink a symlink?
04:40:02 <dcoutts_> fasta: probably because of it's unicode character properties
04:40:02 <quicksilver> alan__: rm
04:40:03 <Igloo> fasta: gucharmap tells me that it is the "Laplace operator"
04:40:05 <fasta> E.g. ∆level makes more sense as a normal function
04:40:23 <Igloo> It has "Unicode category: Symbol, Math", and symbol => operator
04:40:27 <alan__> quicksilver: will that delete the origional file(its a hard link)?
04:40:40 <quicksilver> alan__: if it's a hard link, it isn't a symlink
04:40:42 <quicksilver> alan__: which is it?
04:40:57 <dcoutts_> fasta: the unicode character db has these properties about each char, that's what we use to say if it's an operator or normal variable character
04:41:08 <alan__> quicksilver: sorry its a hard link
04:41:10 <quicksilver> alan__: if it's hard, then rm'ing one doesn't effect the other. If it's sym, then rm'ing the real file kills it, rm'ing a link just kills the link
04:41:15 <dcoutts_> fasta: all programming languages supporting unicode do this
04:41:16 <mdmkolbe|work> where is Data.FiniteMap go?
04:41:19 <fasta> dcoutts_: ok, that sounds reasonable
04:41:42 <Igloo> fasta: Do you really want the Laplace operator rather than capital delta?
04:42:22 <fasta> Igloo: no, I just want something that looks like what I showed, I don't care how unicode represents it.
04:42:43 <dcoutts_> fasta: meaning is important :-) especially to the unicode folks
04:42:51 <alan__> quicksilver: thanks
04:43:01 <dcoutts_> there are many chars that look similar but with different meanings
04:43:21 <alan__> quicksilver: yep, its still there
04:43:35 <fasta> dcoutts_: I understand, but I want somethign that is not an operator but looks like what I had earlier.
04:43:50 * fasta wonders how the hell he inputs unicode characters in Emacs under Gnome...
04:43:58 <dcoutts_> Igloo: we need to campaign for a unicode lambda math character, distinct from the lowercase greek character
04:44:20 <mux> what's wrong with λ?
04:44:21 <dcoutts_> Igloo: so that the greek school kids can program Haskell without getting really confused
04:44:27 <mux> hmm
04:44:43 <fasta> Why not ban Greek? ;)
04:44:58 <dcoutts_> fasta: tell that to the Greeks :-)
04:45:02 <mux> I can see how it could be confusing for them but I don't see it as a real problem
04:45:12 <mux> at least not one you can solve by just adding another lambda character to unicode
04:45:17 <mux> it wouldn't solve a confusion
04:45:17 <dcoutts_> mux: it means they can't use greek names for variables
04:45:32 <mux> sure
04:45:41 <mux> and that's a good thing
04:45:45 <dcoutts_> they might think that's a bit rude
04:45:51 <fasta> Can lhs2tex also comprehend unicode source?
04:46:03 <dcoutts_> mux: every other language can use their own script
04:46:20 <dcoutts_> mux: why should we discriminate against the greeks?
04:46:41 <Igloo> Although actually that wouldn't work either, as it's uppercase
04:46:47 <mux> we shouldn't, we should change it so that no script beside ascii is usable for identifiers
04:47:15 <dcoutts_> Igloo: is it? ok, well type names then :-)
04:47:27 <mux> I'm not for encouraging people to write code in their own language
04:47:33 <mux> it makes for less readable code, that's about it
04:48:01 <quicksilver> and also more readable code
04:48:02 <mux> if I named variables with french names, it would drastically reduce the number of people able to read my code or at least willing to read it
04:48:03 <dcoutts_> mux: well that's a different argument, at the moment we do allow non-ascii variable and type names, though nobody uses them yet
04:48:43 <mux> dcoutts_: it's a different argument, but following that reasoning I see no point in having another lambda character :-)
04:49:18 <dcoutts_> mux: sure, if we only use ascii for variable names then we can use everyone else's chars for whatever we like
04:49:41 <mux> yep, and that would make more sense imo
04:50:26 <dcoutts_> mux: I don't know that everyone would agree that we should all write in english though
04:50:52 <Cheery> Is there a plugin in vim to get \ -appear as lambdas?
04:50:56 <dcoutts_> most programmers at the moment do, but it's harder to sell more widely
04:51:28 <dcoutts_> mux: apparently the OLPC folk want to get kids using python in their native languages, keywords, libs and all
04:51:40 <mux> I think that's a very bad idea
04:51:52 <dcoutts_> the kids don't know english
04:51:58 <mux> the kids don't need to
04:52:05 <matthew_-> fasta: you see what it's done to me!
04:52:10 <mux> don't tell me one needs to know english to use english variable names, it's wrong
04:52:10 <kosmikus> fasta: (lhs2TeX) I'm not sure. Probably not.
04:52:11 <matthew_-> agh, ww, sorry
04:52:17 <Cheery> start writing code in lojban, problems solved. ;)
04:52:24 <mux> I've been coding "in english" long before I was actually able to speak english correctly
04:52:43 <dcoutts_> mux: you can memorise a dozen keywords, but with lots of library names, the name give a strong hint as to it's meaning
04:53:30 <mux> it makes no sense to have people code in their own language, language APIs are in english, keyword languages are in english too
04:53:44 <Cheery> I asked before, what's wrong in Text.HTML?
04:53:46 <dcoutts_> the argument goes that it's basically a kind of cultural imperialism
04:53:54 <quicksilver> it *is* cultural imperialism
04:53:59 <quicksilver> but it's also bloody practical
04:54:04 <mux> yes
04:54:05 <dcoutts_> right
04:54:10 <quicksilver> the community has benefitted enormously
04:54:20 <quicksilver> the fact that most french programmers can communicate in english means they contribute
04:54:25 <mux> imagine the state of open source if everyone coded in its own language
04:54:28 <dcoutts_> I know, i'm quite comfortable with the way it is
04:54:28 <quicksilver> if we were 'all islands'...
04:54:31 <mux> yep
04:54:44 <quicksilver> compare the fact that most academic papers are published in english...
04:55:17 <Saizan> apart from this it can be nice to have a real delta in a variable name when you need it
04:55:18 <quicksilver> nonetheless, there are times when it doesn't really make sense to translate
04:55:22 <ivanm> quicksilver: no, its in an english dialect called "academic english"
04:55:23 <dcoutts_> this is true, it makes a great deal of sense to us
04:55:32 <ivanm> lets start using euro-english! :p
04:55:34 <quicksilver> imagine you are writing for a large german bank
04:55:43 <quicksilver> which has a lot of internal technical vocabulary
04:55:47 <quicksilver> (in German, clearly)
04:55:49 <mux> comments!
04:55:55 <quicksilver> and you have variables/types corresponding to that stuff
04:56:01 <quicksilver> it woul dbe absurd to translate all that to english
04:56:03 <Cheery> ridicule people with lojban if they want to translate
04:56:06 <dcoutts_> but most African school kids are writing for themselves, their teacher or friends, not german banks or the open source community in general
04:56:07 <quicksilver> you'd have to make up new word
04:56:23 <mux> that's a very particular corner case anyways
04:56:31 <fasta> kosmikus: and I suppose you are not interested in making it such that it does?
04:56:32 <quicksilver> dcoutts_: you can argue that it's better for their career prospects if they learn to work with the standard APIs
04:56:46 <quicksilver> dcoutts_: and the standard APIs will surely be in english for a long time :)
04:56:54 * mux nods at quicksilver 
04:57:08 <dcoutts_> quicksilver: the OLPC folk want to translate the standard apis apparently
04:57:14 <quicksilver> dcoutts_: yes, I saw you say that
04:57:22 <quicksilver> dcoutts_: I'm politing disagreeing with that as an idea :)
04:57:27 <mux> that's an incredible waste of time :-)
04:57:30 <dcoutts_> and I'm not sure the 10 year olds are actually being trained to be programmers
04:57:33 <quicksilver> but they know more about african children than I do...
04:57:54 <mux> the point is, they want to have 10 year old code, fine
04:57:54 <dcoutts_> quicksilver: I find it a little incredible too
04:58:05 <mux> do they want them to be able to become programmer one day or is it just for fun?
04:58:18 <mux> if it's for fun, fine, they can have them all write code in klingon if they wish
04:58:23 <dcoutts_> for fun and to learn in general
04:58:36 <mux> if they want them to be able to become programmer some day, then teaching them to code in english is more sensible
04:58:46 <mux> anyways
04:58:51 <mux> they would benefit from learning english
04:58:58 <dcoutts_> probably so
04:59:01 <lome> Once more about reflection. If I have charList = ['a'..'z'], how can I know that type of `a` in charList type [a] is Char?
04:59:02 <ivanm> maybe we should make up a new language used solely to use for programming language? :p
04:59:02 <mux> so even if it's just for "learning" I'm not so sure that's a good idea
04:59:18 <dcoutts_> ivanm: it's called Haskell!
04:59:23 <mux> an african kid knowing english, at least basically, surely has a nice advantage over other kids who don't
04:59:24 <dcoutts_> ivanm: cons, fold, nub
04:59:37 <ivanm> lome: define it to be a Char? charList :: [Char] ?
04:59:41 <ivanm> dcoutts_: heh
05:00:06 <lome> ivanm: I'm talking about something like Generics or Typeable :-)
05:00:07 <ivanm> though aren't cons, fold, etc common to all/most list-based languages?
05:00:13 <ivanm> lome: oh, OK
05:00:18 <ivanm> heh, ignore me then
05:00:28 <lome> ivanm: ;-)
05:00:33 <Saizan> typeOf . head ?
05:00:34 <ivanm> that reminds me....
05:00:52 <ivanm> I think I saw somewhere that someone had done lambda calculus on the type level... is this true?
05:00:59 <ivanm> or am I imagining things? :p
05:01:01 <lome> Saizan: in this type yes, but if I dont know a structure of type?
05:01:23 <Saizan> ivanm: i've seen the SK-calculus on the wiki
05:01:43 * ivanm goes to have a look
05:01:43 <lome> ivanm: yes but without Y comb
05:01:49 <ivanm> lome: *nod*
05:02:51 <alan__> the ghc ./configure script is pretty massive. 20,000 lines!
05:03:09 <Saizan> > typeOf1 ['a']
05:03:13 <lambdabot>  []
05:03:27 <mux> alan__: well it is automatically generated by autoconf
05:03:38 <Saizan> > typeOf ['a']
05:03:40 <lambdabot>  [Char]
05:03:42 <alan__> thankfully
05:03:42 <mux> and autoconf tends to generate massive scripts
05:04:09 <mux> (trying hard to avoid using words such as 'stupid' and 'POS software')
05:04:25 <alan__> ?
05:04:32 <alan__> shell?
05:04:40 <mux> oh no, I'm thinking about auto*
05:04:49 <alan__> oh, ok
05:04:53 <Saizan> > splitTyConApp . typeOf $ "a"
05:04:54 <lambdabot>  ([],[Char])
05:05:23 <Saizan> lome: so splitTyConApp
05:05:28 <ivanm> mux: heh
05:05:42 <lome> Saizan: Oh, thx!
05:06:00 <alan__> hmm, i think i need autoconf to generate my configure file
05:06:18 <ivanm> Saizan: yeah, that's what I was after
05:06:27 <alan__> all i have is a configure.ac and a makefile.am
05:06:34 <mux> then you need autoconf and automake
05:06:42 <mux> chances are that will need some more auto* stuff
05:06:51 <alan__> :(
05:07:02 <mux> but if you're just trying to build GHC, I think the exact steps are documented somewhere, aren't they?
05:07:30 <alan__> oh no, this is an unrelated coincidence im having with another app
05:07:36 <mux> ah, ok
05:08:52 <alan__> my GHC won't build because the configure script freezes while checking if perl works with shell scripts
05:09:46 <mux> heh, interesting
05:14:21 <kosmikus> fasta: it's not a priority.
05:14:46 <kosmikus> fasta: I'd accept a patch (as long as it doesn't break anything else).
05:20:00 <dcoutts_> ibid: do you think it'd be appropriate to add the hackage package upload rss feed to planet.haskell.org ?
05:20:07 <dcoutts_> see http://hackage.haskell.org/packages/archive/recent.rss
05:22:35 * dcoutts_ recommends everyone to add that feed to their rss subscriptions
05:29:35 <fasta> Is there also a delta that's interpreted as lower-case?
05:30:03 <fasta> (I don't mean the standard lower case delta, since that has a different shape)
05:30:25 * ivanm was about to say the delta used for kronecker delta, etc...
05:31:55 <quicksilver> dcoutts_: why does 'Haskell Eye for the Ruby Guy' keep floating to the top of planet.haskell ?
05:32:24 <dcoutts_> quicksilver: planets and rss feeds are notoriously broken when it comes to figuring out what is new
05:33:16 <dcoutts_> quicksilver: it's either the planet that is borken or more likely the rss feed it is pulling from
05:33:16 <pitecus> Does anyone know of a haskell MaxEnt library?
05:34:42 <ibid> dcoutts_: not as it is.  it'd have to have some "story" potential, for example, list o noteworthy changes. and it will potentially become a very busy eed
05:35:14 <ibid> dcoutts_: in any case, i'm currently cut off from planet (waiting for a new laptop so i can transfer the ssh key there:)
05:35:41 <dcoutts_> ibid: hmm, I don't think we can get noteworthy changes, all we know is that it's either a new package or a new version of a package, we only get the meta-data from the .cabal file
05:36:07 <ibid> dcoutts_: yep, so i wouldn't add it
05:36:25 <ibid> dcoutts_: of course, if someone were to start editing a "new in hackage" blog... :)
05:36:28 <dcoutts_> ibid: perhaps some aggregate rss, that weekly lists all the additions that week? like a list of one-liners ?
05:36:40 <ibid> dcoutts_: perhaps
05:36:50 <dcoutts_> ibid: so you'd only get one post per N days or something
05:37:10 <dcoutts_> ibid: we need some way of promoting all this new software people keep publishing
05:37:52 <ibid> dcoutts_: i'm trying to avoid putting stuff that people will skip over without looking in planet
05:37:53 <dcoutts_> much like dons' new software list in HWN
05:38:05 <ibid> dcoutts_: and anything machine-generated is very likely something like that
05:38:11 <dcoutts_> mm
05:38:30 <ibid> dcoutts_: HWN is already syndicated, why not put the list there, perhaps edited?:)
05:38:41 <dcoutts_> well that's a good alternative
05:39:42 <ibid> dcoutts_: in any case, the best way is to have a human editor who makes the data feed worth reading (reviews, or just plain good writing)
05:39:49 <dcoutts_> dons: have you got the hackage rss feed in your subscriptions for when you do HWN ?
05:40:02 <dons> dcoutts_: yeah
05:40:06 <dcoutts_> good good
05:40:15 <dcoutts_> ibid: aye, but you know how they come and go
05:40:18 <dons> so yeah, i added that entry to HWN last week
05:40:21 <ibid> dcoutts_: yep
05:40:25 <dons> since stuff is appearing there that isn't announced
05:40:30 <dcoutts_> right
05:40:38 <kolmodin> how about listsing the name-version of the package, synopsis and description
05:40:49 <kolmodin> grouped by week or so
05:40:53 <ibid> kolmodin: makes sense for new packages
05:40:53 <dcoutts_> kolmodin: too machine generated apparently, not sufficiently random
05:40:55 <dons> ibid: the rss list is already in HWN :)
05:40:56 <ibid> kolmodin: not for updates
05:40:58 <mdmkolbe|work> Is there some way to ask for an element (any element will do) of a Data.Set?  Or is there some other data structure that would work better?  The operations I need are union, add a list of members with duplicates removed, remove and return an arbitrary (single) element (i.e. I will ask for an element and the set can return what ever element it wants to), test whether it is empty, and construct an empty "set"
05:41:19 <kolmodin> ibid: sure, ok
05:41:23 <ibid> dons: included, or referenced? (too lazy to check)
05:41:23 <ailndx> "Find the number of entries wich are not divisible by 7 in the first N rows of Pascal's triangle." Is there any neat way to do this in haskell?
05:41:47 <dons> if anyone has a view of what should appear here: http://sequence.complete.org/hwn/20070427
05:41:49 <lambdabot> Title: Haskell Weekly News: April 27, 2007 | The Haskell Sequence
05:41:51 <dons> scroll down to 'Hackage'
05:41:57 <dons> currentl, just package name and link to hackage page
05:42:17 <dons> apparently, all us haskell guys think alike eh?
05:43:04 <dcoutts_> dons: we want to know if it's a new package or a new version of an existing one, and a one line sysnopsis
05:43:09 <dons> ah ok.
05:43:18 <dcoutts_> dons: this is stuff that the rss feed should provide
05:43:28 <ibid> dons: there is some of that dreaded long-list-itis in HWN too, i see.  long lists with no editorial text make the reader skip stuff
05:43:29 <dons> ok. i can do that. [New] and the synopsis field
05:43:37 <dcoutts_> dons: currently it gives the synopsis but not if it's new I think
05:43:42 <dons> ibid: mm. yes.
05:44:05 <dons> i'm trying to be comprehensive, at the cost of manually writing about each thing
05:44:08 <dons> e.g. for blog stuff
05:44:15 <dons> but for hackage i can steal the synopsis
05:44:53 <dcoutts_> dons: it would be great if hackage could somehow show change highlights in new packages, we should think about how to do that
05:45:07 <dons> yeah
05:45:16 <dcoutts_> ie release announcements or at least a couple bullet points NEWS file style
05:47:01 * dcoutts_ -> lunch -> IO ()
05:50:06 <fasta> mdmkolbe|work: if elems :: Set a -> [a] is lazy then you can just take the head and it will be O(1)
05:51:03 <fasta> That brings us to the question: how can one see by looking at the API what the lazyness properties are?
05:53:15 <fasta> mdmkolbe|work: you can easily test for it, though
05:53:15 <malcolmw> does anyone know why the mail server at haskell.org delayed the email on the ghc-bugs list from the person at Apple from Monday to today?
05:53:33 <fasta> mdmkolbe|work: insert an infinite number of items in the set and check whether you can call elems on it
05:53:42 <malcolmw> five-day delivery times are not what I expect from email :-)
05:54:05 <fasta> malcolmw: Try sending an email to the maintainer of Data.Sequence
05:54:11 <fasta> malcolmw: delivery time \infty
05:55:09 * malcolmw is puzzled
05:55:46 <ndm> malcolmw: probably moderation
05:55:53 <malcolmw> is haskell.org's mail server implemented in haskell?  that would be quite cool.  (but not if that is the reason for the delay)
05:56:08 <ndm> malcolmw: no, its implemented in PHP :)
05:56:16 <ndm> but seriously, its not in haskell or PHP, its just a normal one
05:56:21 <malcolmw> ndm: oh, moderation would certainly explain it
05:56:35 <ndm> malcolmw: its why late emails arrive in batches
05:59:03 <hpaste>  mdmkolbe|work pasted "Indentation error" at http://hpaste.org/1704
05:59:22 <mdmkolbe|work> Why is this an indentation error? http://hpaste.org/1704
05:59:42 <mauke> because of the 'do', which enables layout
06:00:07 <quicksilver> mdmkolbe|work: because inside the do, the "then" starts a new statement
06:00:08 <mauke> every line at the same indentation level causes a ';' to be inserted
06:00:22 <mdmkolbe|work> fasta: just saw your responce, that looks like it might work, thx
06:00:26 <quicksilver> mdmkolbe|work: since it's indented at the same amount as the first line of the do (which happens to be the if)
06:01:25 <mdmkolbe|work> quicksilver: so is 'do' desuggering done before parsing?
06:02:15 <norpan> desugaring is not done, but layout rule elimination is
06:02:29 <malcolmw> mdmkolbe-home: incidentally, this quirk of the layout rule is due to be fixed in haskell-prime
06:02:55 <quicksilver> mdmkolbe|work: it's not really 'do'; it's the layout rule at all
06:03:05 <quicksilver> mdmkolbe|work: but you probably see it most with do
06:04:26 <mdmkolbe|work> ok, so not the main question.  How do I get the emacs Haskell-mode to properly indent?  It keeps trying to make it look like the second one (the broken one)
06:04:32 <mdmkolbe|work> s/not/now/
06:05:54 <lome31337> Is there a way to get DataType or TypeRep from String in Haskell? If I haven't any value of this type, but its name.
06:06:24 <Saizan> mdmkolbe|work: fixing haskell-mode, i think :\
06:07:02 <quicksilver> lome: no, for a variety of reasons. Basically that would require an interpreter.
06:07:09 <quicksilver> lome: hs-plugins is such an interpreter :)
06:07:21 <quicksilver> lome: however if you have a finite set of types you can of course just use 'show'
06:07:41 <ndm> Igloo: MagicHash, now that is a great name for a Haskell extension!
06:08:20 <Saizan> MagicHash?
06:08:29 <Wild_Cat> sounds like a novelty drug.
06:08:30 <lome> quicksilver: thank you, I'll have a look at hs-plugins
06:08:51 <quicksilver> lome: I can only guess what you're doing, but there is probably a better way :)
06:08:56 <ndm> http://hackage.haskell.org/trac/ghc/ticket/1297
06:08:58 <lambdabot> Title: #1297 (No LANGUAGE option for # in symbols) - GHC - Trac
06:09:08 <ndm> thats the bug that proposes it as a haskell extension
06:09:09 <Igloo> ndm: It's a good thing the extension already exists, or we'd have to invent one so we could use the name!
06:09:27 <lome> quicksilver: I try to generate some code in TH for specified type
06:09:32 <ndm> Igloo: i still want to rename Yhc to Thc (toms haskell compiler), then add a -speed flag
06:10:14 <Igloo> :-)
06:12:04 <Saizan> lome: in TH you use for example (ConE (mkName "Just")) `AppE` (StringL "foo")  to build a Just "foo"
06:13:19 <Igloo> Saizan: You normally want   'Just   rather than   mkName Just
06:13:42 <Igloo> Saizan: Also, the [| Just "foo" |] syntax is much more concise where it's possible to use it
06:14:01 <Igloo> (and type-safer too)
06:14:33 <Saizan> Igloo: yep, lome has a String tough..
06:14:52 <lome> Saizan: I know, but I need a structure of type to generate code. As a simple example I need ${ test "Prelude.Maybe Int"} will be translated into testMaybeInt = "Nothing | Just Int"
06:14:52 <Igloo> OK, I hadn't been following the discussion
06:15:56 <Saizan> lome: have you seen reify?
06:16:39 <Saizan> even if it won't work so well starting with String ..
06:16:40 <lome> Saizan: nope. Is it the way?
06:17:10 <Saizan> to get the structure of a type starting from its Name? yes it is
06:17:25 <lome> Saizan: OK, thank you very much!
06:18:31 <alan__> what does the :kind command do. I cant generate anything other than *.
06:19:27 <ivanm> IIRC, there are only two kinds, * and something else...
06:19:33 <ivanm> @kind 2
06:19:34 <mdmkolbe|work> :kind Maybe
06:19:35 <lambdabot> Only unit numeric type pattern is valid
06:19:44 <mdmkolbe|work> @kind Maybe
06:19:46 <lambdabot> * -> *
06:19:53 <mdmkolbe|work> @kind Either
06:19:55 <Saizan> :kind StateT
06:19:55 <lambdabot> * -> * -> *
06:19:58 <ivanm> @kind Int
06:20:00 <lambdabot> *
06:20:09 <alan__> Saizan: ooh
06:20:19 <Saizan> @kind StateT
06:20:21 <lambdabot> * -> (* -> *) -> * -> *
06:20:21 <ivanm> @kind data F a b c = F a b c
06:20:24 <lambdabot> parse error on input `data'
06:20:39 <mdmkolbe|work> @kind Int#
06:20:42 <lambdabot> Not in scope: type constructor or class `Int#'
06:20:58 <mdmkolbe|work> @kind GHC.Prim.Int#
06:21:01 <lambdabot> #
06:21:34 <Saizan> alan__: it's a type of types, it's interenting with type constructors like Maybe, Either etc..
06:22:06 <mdmkolbe|work> * = boxed type, # = unboxed type, a -> b = *type* constructor (i.e. given a type of kind a, you get back a type of kind b)
06:26:57 <araujo> morning
06:27:31 <Saizan> Igloo: do you happen to know if there's the intention to extend TH to get more typelcass informations? e.g. which types instance a class or viceversa
06:28:37 <Igloo> Saizan: If you have a need for that then shout on the mailing list; the more people who shout, the sooner more work will be done!
06:31:17 <Saizan> i see :)
06:36:49 <li`> New to haskell, could anyone give a quick definition of isPrime? Thanks
06:37:16 <ivanm> is this for an assignment?
06:37:38 <li`> No. I'm working on eulerproject.
06:37:45 <ivanm> OK
06:38:26 <astrolabe> @hoogle isPrime
06:38:26 <lambdabot> No matches found
06:38:27 <ivanm> isPrime n = not (any (\ v -> n `mod` v == 0) [2..(n-1)])
06:38:37 <mdmkolbe|work> @src isPrime
06:38:38 <lambdabot> Source not found. It can only be attributed to human error.
06:38:45 <ivanm> so get all numbers between 1 and n, exclusive
06:39:02 <opqdonut> > let isPrime x = not or (zipWith mod [x..] [2..x-1]) in isPrime 13
06:39:03 <ailndx> how do i convert the base of a number?
06:39:03 <lambdabot>  Couldn't match expected type `Bool'
06:39:09 <Syzygy-> ivanm: That looks like a bloody inefficient isPrime. :P
06:39:16 <li`> how to restrict the range to [2.. sqrt (n-1)] ?
06:39:17 <ivanm> Syzygy-: yeah, but it works :p
06:39:20 <Syzygy-> Didn't we have an isPrime golf a while ago?
06:39:30 <sioraiocht|sleep> Syzygy-: try getting a better one in one line =p
06:39:34 <dcoutts_> Igloo: MagicHash is great :-)
06:39:40 <Syzygy-> sioraiocht|sleep: Don't wanna. :)
06:39:43 <astrolabe> isPrime returns true for a number if that number has no divisors except itself and 1.
06:39:55 <sioraioch> @src any
06:39:56 <lambdabot> any p =  or . map p
06:40:00 <opqdonut> > let isPrime x = empty $ filter (/=0) $ zipWith (mod [x..] [2..x-1]) in isPrime 13
06:40:00 <dcoutts_> hia SyntaxNinja
06:40:05 <alan__> >
06:40:09 <ivanm> li`: just change the [2..n-1] to [2..sqrt(n-2)]
06:40:10 <opqdonut> hrrm
06:40:13 <ivanm> which would be more efficient
06:40:15 <alan__> > nubBy (\x y -> y `rem` x == 0) [2..10]
06:40:17 <lambdabot>  [2,3,5,7]
06:40:25 <ivanm> @src rem
06:40:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:40:28 <alan__> > nubBy (\x y -> y `rem` x == 0) [2..20]
06:40:30 <lambdabot>  [2,3,5,7,11,13,17,19]
06:40:34 <ivanm> what's rem?
06:40:34 <alan__> > nubBy (\x y -> y `rem` x == 0) [2..100]
06:40:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
06:40:38 <ivanm> remainder, I presume...
06:40:39 <alan__> remainder
06:40:48 <opqdonut> nice
06:41:02 <ivanm> heh, it is nice...
06:41:09 <ivanm> didn't get what you were doing at first though
06:41:11 <alan__> > (10 `rem` 2,10 `rem` 3)
06:41:12 <lambdabot>  (0,1)
06:41:20 <ivanm> @hoogle rem
06:41:21 <lambdabot> Prelude.rem :: Integral a => a -> a -> a
06:41:21 <lambdabot> Directory.removeDirectory :: FilePath -> IO ()
06:41:21 <lambdabot> Directory.removeFile :: FilePath -> IO ()
06:41:28 <dcoutts_> SyntaxNinja: I was cleaning some stuff from the top level dir of darcs.h.o into an archive subdir. I can't mv or cp + rm the cabal-with-install-OLD/ however due to perms. I was hoping you could mv it as you seem to own it.
06:41:34 <ivanm> ahh, its in the prelude, which is why @src didn't work
06:41:39 <alan__> its equivalent to the c function (%)
06:41:43 <sioraioch> alan__: what's the time complexity of nubBy
06:41:44 <ivanm> *nod*
06:41:47 <sioraioch> @src nubBy
06:41:48 <lambdabot> nubBy eq []             =  []
06:41:48 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:41:50 <ivanm> n^2, isn't it?
06:41:52 <alan__> sioraioch: big
06:42:07 <ivanm> since you're comparing each element to every other element
06:42:10 <ivanm> so its O(n^2)
06:42:13 <alan__> sioraioch: O!
06:42:36 <ivanm> but, it gives you a list of primes...
06:42:57 <sioraioch> ivanm: aye, i was just wondering compared to your sieve =)
06:43:07 <ski> you're not comparing again with the already filtered numbers ..
06:43:12 <ivanm> well, mine would be O(n), but alan__'s give a list
06:43:37 <ivanm> of _all_ primes up to a given value...
06:43:55 <ivanm> so it depends what you want
06:44:13 <ivanm> in the real world, don't they normally use probabalistic methods for large numbers anyway?
06:44:38 <sioraioch> ivanm: depends on the application
06:44:48 <ivanm> *nod*...
06:44:58 <alan__> ivanm: depends if there using it for a encryption algorithm or for mathematical proof
06:44:59 <sioraioch> ivanm: for example, the Great Internet Mersenne Prime search uses the Lucas-Lehmer test, which is deterministic
06:45:16 <ivanm> yeah, since you want to guarantee its prime
06:45:37 <sioraiocht> but PGP, etc. tend to use probabalistic tests
06:45:40 <ivanm> but for encryption, its usually a "good enough"
06:45:51 <ivanm> though PGP uses randomness to generate the prime as well
06:46:05 <alan__> ivanm: especially considering they change the key often
06:46:18 <alan__> ivanm: in a single session
06:46:31 <ivanm> for the internal IDEA encryption? yeah
06:47:37 <sioraiocht> ivanm: for picking public keys, though, they use Fermat's primality test
06:47:42 <ivanm> yeah
06:48:07 <matthew_-> sioraiocht: they'll use /many/ probabilistic tests to achieve a high probability of being prime
06:48:30 <sioraiocht> matthew_-: generally they'll also use the /same/ test up to 10 times
06:48:39 <matthew_-> yep
06:49:01 <INeedANewNick> hi
06:49:09 <sioraiocht> as the highest failure rate of most probabilistic tests is 4^-1, and 4^-10 is around the same probability that I'm a giraffe
06:49:19 <matthew_-> I guess it depends on how quickly the δ between probabilities falls to small values
06:49:20 <ivanm> if someone can do a fast O(1) primality test, they'd probably be made for life
06:49:26 <ivanm> or killed by the nsa :p
06:49:52 <ivanm> sioraiocht: is that a failure rate of 4^-1, or 4^-10 ?
06:49:59 <integral> prime testing is already polynomial time though
06:50:32 <sioraiocht> 4^-1, but if you do the test 10 times you get a probability of 4^-10 that your overall result is a lie
06:50:40 <ivanm> sioraiocht: *nod*
06:50:55 <sioraiocht> which, well
06:50:59 <sioraiocht> > 4 ^^ (-10)
06:51:08 <lambdabot>  9.5367431640625e-7
06:51:26 <ivanm> what is ^^ as opposed to ^ or ** ?
06:51:32 <ivanm> @hoogle (^^)
06:51:32 <sioraiocht> @src (^)
06:51:33 <lambdabot> Did you mean: (^^)
06:51:33 <lambdabot> Prelude.undefined :: a
06:51:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:51:33 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:51:34 <Saizan> type
06:51:43 <sioraiocht> @type (^)
06:51:45 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:51:46 <sioraiocht> @type (^^)
06:51:49 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:51:55 <sioraiocht> @type (**)
06:51:56 <ivanm> ahhh
06:51:58 <lambdabot> forall a. (Floating a) => a -> a -> a
06:52:11 <ivanm> I know how ** differs from ^, just never saw ^^ before
06:52:20 <li`> anyway in Emacs (Haskell-mode) to access the doc or the source of a definition at point ?
06:52:26 <sioraiocht> ivanm: (^) will thrown an exception for negative exponents
06:52:35 <sioraiocht> > 4^(-10)
06:52:37 <lambdabot>  Exception: Prelude.^: negative exponent
06:52:38 <ivanm> oh, OK
06:52:49 <sioraiocht> @src (^^)
06:52:49 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
06:52:52 <ivanm> li`: you mean hoogle?
06:52:55 <ivanm> or docs?
06:53:01 <li`> docs
06:53:06 <li`> some file on disk
06:53:13 <alan__> how about
06:53:38 <ivanm> li`: don't think there's an inbuilt one...
06:54:28 <alan__> 1 % (4 ^ 10)
06:54:30 <alan__> > 1 % (4 ^ 10)
06:54:32 <lambdabot>  1%1048576
06:55:38 <mdmkolbe|work> > 4 ^^ (-10)
06:55:40 <lambdabot>  9.5367431640625e-7
06:57:37 <sioraiocht> @src (
06:57:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:57:42 <sioraiocht> @src (%)
06:57:42 <lambdabot> x % y = reduce (x * signum y) (abs y)
06:58:12 <ivanm> @hoogle (%)
06:58:13 <lambdabot> Did you mean: (%)
06:58:13 <lambdabot> Prelude.undefined :: a
06:58:13 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:58:22 <quicksilver> % is rational numbers
06:58:23 <ivanm> @hoogle %
06:58:24 <lambdabot> Ratio.(%) :: Integral a => a -> a -> Ratio a
06:58:31 <ivanm> looking for where it was defined
06:58:35 <quicksilver> > (2%3) * (1%3)
06:58:37 <lambdabot>  2%9
06:58:50 <sioraiocht> > (2%3)
06:58:52 <lambdabot>  2%3
06:58:57 <sioraiocht> that's convenient
06:59:49 <quicksilver> it's arbitrary precision, too, potentially
06:59:58 <quicksilver> Ratio Integer is arbitrary precision
07:00:18 <sioraiocht> that is neat
07:00:30 <sioraiocht> must be slooooooooow, heheh
07:00:44 <sioraiocht> what does haskell use for Integer arithmetic, BCD?
07:00:58 <Syzygy-> BCD? Binary coded decimal?
07:01:03 <sioraiocht> ay
07:01:04 <sioraiocht> e
07:01:23 <Wild_Cat> only 7-seg displays use BCD.
07:01:25 <ski> i believe ghc uses gmp
07:01:39 <Syzygy-> I would hope not. Sounds like a waste when you can build or use a bigint library that actually cares about your wordsize.
07:01:46 <quicksilver> sioraiocht: the haskell spec doesn't specify the implementation :)
07:01:49 <alan__> > let fac n = product [1..n] in (fac 100)
07:01:51 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
07:02:00 <quicksilver> sioraiocht: but sane ones use whole words as much as possible
07:02:02 <Syzygy-> As for slow.. :)
07:02:03 <alan__> > let fac n = product [1..n] in (fac 100 % fac 99)
07:02:05 <lambdabot>  100%1
07:02:07 <dons> it uses libgmp
07:02:14 <quicksilver> or, perhaps, save the top bit or two for flagging
07:02:20 <dons> ?src Ratio
07:02:21 <lambdabot> data (Integral a) => Ratio a = !a :% !a
07:02:29 <dons> that's fine too, two byte arrays and libgmp
07:02:38 <dons> and word sized values for < 2^32
07:02:52 <shapr> word to ya cpu
07:02:53 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:02:58 <dons> word shapr
07:03:01 <Wild_Cat> yeah, it's nice that Haskell uses bigints without you having to jump through any hoops.
07:03:08 <shapr> word64 up dons!
07:03:08 <petekaz> dons: I'm reading your latest blog entry, great stuff!  I look forward to the entire series!
07:03:17 <dons> jammin
07:03:27 <dons> petekaz: great :-)
07:03:35 <dons> yeah, i hope to write a draft tomorrow
07:03:53 <dons> 'cause someone has to teach yall how to write tiling window managers ;-)
07:04:08 <dons> its late, and i'm being silly
07:04:14 <petekaz> I'll settle for learning haskell.
07:04:19 <dons> time for bed. night! happy lambdas!
07:04:21 <ski> word36 ?
07:04:27 <petekaz> g'night.
07:05:42 <alan__> i dislike lambdas, i prefer where notation
07:06:20 <ski> they're for different things
07:07:39 <shapr> ski: Do you have a PDP-11 or something?
07:07:39 <shapr> Weren't those 36-bit cpus?
07:08:07 <dcoutts_> Igloo: so we can make cabal put the binaries where we want them, configure --prefix=$HOME/.cabal-install/ --bindir='$prefix/bin/$pkgid'  for example
07:08:24 <dcoutts_> Igloo: and then we just make symlinks for all bin/$pkgid/* in bin/  so that leaves all versions available but symlinks the latest version. Is that what you were thinking?
07:08:36 <SyntaxNinja> dcoutts_: will do
07:08:54 <ski> shapr : no .. but i had a classmate whose aunt programmed some such things :)
07:08:57 <Igloo> dcoutts_: Yup
07:09:02 <dcoutts_> SyntaxNinja: ta, btw what do you think about Igloo's idea for cabal-install's dir layout scheme
07:09:30 <SyntaxNinja> where's that? here? mailing list?
07:09:37 <dcoutts_> SyntaxNinja: basically, by default we put everything under .cabal-install, the package db, the installed libs and the bin dir
07:09:50 <Igloo> dcoutts_: Or just   configure --prefix=$HOME/.cabal-install/$pkgid   regardless of whether it's a library or executable
07:09:58 <alan__> ski: i can think of an instance where (\x->y) lambdas are better, they seem obfuscated
07:10:11 <Igloo> dcoutts_: Oh, and except we need the compiler details in there for libraries, at least
07:10:30 <SyntaxNinja> (done)
07:10:37 <SyntaxNinja> how does ti work now?
07:10:42 <quicksilver> alan__: they're just a simple way to have a function without giving it a name
07:10:56 <quicksilver> alan__: just as it is useful to be able ot use string constants without giving htem names
07:10:58 <dcoutts_> SyntaxNinja: it installs things in $HOME/usr/{lib,bin,share}
07:11:05 <quicksilver> alan__: sometimes giving everything a name is clumsy
07:11:15 <quicksilver> > map (\x -> (x,x)) [1,2,3,4]
07:11:16 <lambdabot>  [(1,1),(2,2),(3,3),(4,4)]
07:11:24 <quicksilver> I don't find that obfuscated
07:11:30 <dcoutts_> SyntaxNinja: which is both intrusive and doesn't actually put things in the users $PATH (since ~/bin is the usual one not ~/usr/bin)
07:12:04 <dcoutts_> SyntaxNinja: the idea instead is that everything is installed under .cabal-install/ and we symlink into a bin directory of the users choice
07:12:26 <SyntaxNinja> dcoutts_: sound OK, but how do they choose?
07:12:30 <dcoutts_> SyntaxNinja: so binaries never overwrite each other and we synlink the latest version, but users can change the symlinks
07:13:27 <dcoutts_> SyntaxNinja: a config file in ~/.cabal-install/  and I'd have the config default to ~/bin for all the clueless people who do not care. And we should probably warn upon install if that location is not in the current $PATH
07:14:04 <SyntaxNinja> and since ghc-pkg will know where the libs are anyway, they won't ever have to see those
07:14:06 <SyntaxNinja> hmm
07:14:09 <SyntaxNinja> sounds OK to me.
07:14:16 <dcoutts_> SyntaxNinja: and Igloo and seem to think it should be ~/.cabal/ not cabal-install, running cabal-install install foo feels redundant :-)
07:14:26 <quicksilver> dcoutts_: FWIW (I don't want to add confusion when it's already frustrating) I don't like the idea of putting 'real stuff' like libraries and binaries in a .directory
07:14:42 <quicksilver> dcoutts_: for me, .directories are for simple configs and hidden stuff, not entire software installations
07:14:47 <dcoutts_> quicksilver: where do you want them ?
07:14:53 <quicksilver> dcoutts_: ~/cabal, I think
07:15:12 <quicksilver> dcoutts_: or ~/haskell or ~/lib/(cabal-or-haskell)
07:15:12 <SyntaxNinja> dcoutts_: so the tool itself is called cabal?
07:15:13 <dcoutts_> quicksilver: this should probably all be set in the .cabal/config file
07:15:19 <quicksilver> dcoutts_: agreed :)
07:15:24 <dcoutts_> SyntaxNinja: not at the moment, but I think it should be
07:15:47 <SyntaxNinja> dcoutts_: or you could make the "install" command the dfeault behavior, and hence "cabal-install foo"
07:16:15 <dcoutts_> SyntaxNinja: it's got a bunch of other useful commands though, like update, list, fetch
07:16:20 <SyntaxNinja> dcoutts_: I think cabal-install is just a layered tool, and it'll confuse people to call it cabal.  why isn't cabal-setup called cabal, or cabal2rpm ;)
07:16:39 <quicksilver> cabalista!
07:16:44 <dcoutts_> SyntaxNinja: perhaps 'cabal setup' is the right thing to invoke there too
07:17:09 <dcoutts_> SyntaxNinja: it may be a layered thing, but if it's the one end users have to type all the time, it has to be quick and easy
07:17:18 <SyntaxNinja> dcoutts_: idono, I just think it's nice to have a clear distinction between the library/build system and the layered tools
07:17:27 <SyntaxNinja> true... cabaler? ;)
07:17:28 <SyntaxNinja> hmm
07:17:31 <SyntaxNinja> cabalit
07:17:35 <dcoutts_> SyntaxNinja: there is no cabal prog at the moment
07:17:38 <SyntaxNinja> cabalificat
07:17:42 <dcoutts_> hia mnislaih
07:18:36 <mnislaih> hi dcoutts_
07:18:48 <mnislaih> <- back from lunch/home
07:18:57 <dcoutts_> SyntaxNinja: we can always to crazy stuff like having a cabal prog that just calls other things depending on top level commands, install, setup etc
07:19:13 <dcoutts_> SyntaxNinja: taking a leaf out of darcs's book on nice command line UI
07:19:25 <dcoutts_> just one tool 'darcs' with many sub-commands
07:19:49 <dcoutts_> if in the background it's actually more modular than that, well great
07:19:52 <dcoutts_> cabal rpm
07:20:42 <SyntaxNinja> hohumhmm
07:20:54 <SyntaxNinja> I like the idea of a cabal command... I just don't know what it should _be_ :)
07:21:09 <dcoutts_> SyntaxNinja: my point is, just because it's modular doesn't mean we have to have a poor command line UI
07:21:16 <SyntaxNinja> I do think that cabal-install is the layered tool that'll be the most ubiquitous
07:21:18 <dcoutts_> with a proliferation of cabal-foo cabal-bar
07:21:27 <SyntaxNinja> dcoutts_: I call false dichotomy!
07:21:37 <SyntaxNinja> yeah, I agree...
07:21:38 <dcoutts_> heh :-)
07:21:55 <SyntaxNinja> but a distributed effort requires namespace discipline
07:22:21 <SyntaxNinja> if someone wants to come out with a "cabal-buy-isaac-a-gift-certificate" command, then they can do so without asking my permission
07:22:37 <dcoutts_> and is that a good or bad thing? :-)
07:22:41 <SyntaxNinja> a good thing!
07:22:47 <SyntaxNinja> I love gift certificates ;)
07:22:48 <dcoutts_> ok! :-)
07:22:59 <SyntaxNinja> but I do like the idea of having a nice command like cabal
07:23:04 <SyntaxNinja> but think about apt-get, if you can ;)
07:23:12 <SyntaxNinja> then aptitude came out, which does the same thing, but different.
07:23:38 <dcoutts_> and the darcs & cabal command spaces are flat
07:24:00 <dcoutts_> you can only have one tool take the 'cabal install' command
07:24:52 <dcoutts_> SyntaxNinja: which means we need to act now to make sure cabal install and cabal install do not clash
07:25:07 <chessguy> 'morning, haskellers
07:25:17 <dcoutts_> SyntaxNinja: I mean the install command we have with current ./Setup.hs install and the current cabal-install tool
07:25:35 <dcoutts_> SyntaxNinja: perhaps we can rename that to 'cabal get' before it's too late
07:26:31 * dcoutts_ -> out
07:26:57 <shapr> Yarr!
07:27:05 <chessguy> @arr
07:27:05 <lambdabot> Avast!
07:28:12 <sproingie> @yow
07:28:13 <lambdabot> Yow!  Now I get to think about all the BAD THINGS I did to a BOWLING
07:28:13 <lambdabot> BALL when I was in JUNIOR HIGH SCHOOL!
07:28:40 * dcoutts_ returns having failed to find the person he was after
07:28:40 <chessguy> @get-slap
07:28:41 <lambdabot> shapr!!
07:29:14 <dcoutts_> hammingDistance("get-slap", "get-shapr") <= 3
07:29:22 <fasta> Main: No match in record selector <- there's no tool to find where the match failed, right?
07:29:44 <chessguy> errmmmm, don't you mean levenshtein difference?
07:29:50 <chessguy> or whatever the heck that name is
07:30:00 <dcoutts_> possibly I do
07:30:27 <chessguy> http://en.wikipedia.org/wiki/Levenshtein_distance
07:30:27 <drigz> @typr 2
07:30:29 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
07:30:30 <lambdabot> forall t. (Num t) => t
07:30:37 <chessguy> AFAIK, hamming code is for binary numbers
07:30:43 <drigz> @tyor 2
07:30:44 <lambdabot> Maybe you meant: type yow
07:31:52 <dcoutts_> mnislaih: so here's one plan, when we first create the .cabal/ directory we copy in the read-only config file, which lists the servers and things like default prefix, libdir, etc etc. From then on we get those values from that file and of course users can edit the file (or override them on the command line)
07:32:43 <dcoutts_> mnislaih: additionally, for unix systems we'd have a dir where we make symlinks to executables, that might default to $HOME/bin, I'm not sure how you'd make exe's available for windows users, perhaps start menu nonsense.
07:34:10 <mnislaih> dcoutts_:  regarding Windows, I wonder how regular cabal install does it right now
07:34:34 <dcoutts_> mnislaih: when doing global installs I think they go in program files/ something
07:34:42 <mnislaih> I believe it does not put things in path
07:34:58 <dcoutts_> indeed
07:36:14 <dcoutts_> mnislaih: according to comments in Distribution.Simple.LocalBuildInfo, it says the bindir is $programfiles\$pkgid
07:36:29 <dcoutts_> so C:\Program Files\Alex\Alex.exe for example
07:36:36 <dcoutts_> ndm: does that sound right? ^^^
07:36:59 <ndm> dcoutts_, you are missing a bin in there somewhere
07:37:03 <dcoutts_> ndm: do those binaries go in a common dir on each in their own dir
07:37:23 <dcoutts_> and how do they get found later? how do you actually use them?
07:37:24 <ndm> "c:\Program Files\Haskell\bin\haddock.exe"
07:37:38 <dcoutts_> ah ok, so the comments are wrong :-)
07:37:53 <ndm> dcoutts_, they all go in bin, they get found by putting them in %PATH% - something the new winhugs installer will do
07:37:55 <SyntaxNinja> dcoutts_: how would the conflict? (cabal install ./setup install?)
07:38:41 <dcoutts_> SyntaxNinja: if we're unifying cabal-install and cabal-setup under one 'cabal' top level app. They both have install sub-commands.
07:38:45 <ndm> dcoutts_ - i've also just tweaked winhugs so it automatically adds the cabal path to its search path
07:38:54 <dcoutts_> ndm: right ok.
07:39:01 <ndm> and once you've unbroken Hugs due to Cabal, I'll make a new release
07:39:08 <ndm> with a new installer, once you've done your blog thingy
07:39:12 <dcoutts_> heh
07:39:21 <dcoutts_> ndm: how is hugs broken ?
07:39:46 <ndm> The Hugs library build has been multiply broken by recent changes to
07:39:47 <ndm> Cabal.  Hopefully after Cabal settles down it can be made to work again.
07:39:53 <ndm> so says Ross, yesterday
07:39:56 <dcoutts_> ok
07:40:27 <ndm> which is annoying, since i've just fixed my 5 pet winhugs hates, and now i can't use it :(
07:40:48 <dcoutts_> SyntaxNinja: remember this idea to have a cabal-setup which in most cases eliminates the need for a Setup.(l)hs (and when it doesn't, it just acts as a veneer to the Setup.hs)
07:41:16 <SyntaxNinja> dcoutts_: OK.
07:41:24 <ndm> dcoutts_ to follow your lots of .cabal files per system, you really do need to eliminate Setup.hs totally
07:41:42 <SyntaxNinja> dcoutts_: well, I've given some input; I'm happy to go either way.  if you have a vision for how the commands should work, I say go for it.
07:41:53 <SyntaxNinja> ndm: does hugs use HEAD or something, or was it a release?
07:42:06 <ndm> SyntaxNinja: HEAD
07:42:10 <dcoutts_> SyntaxNinja: will write to cabal-devel with ideas
07:43:01 <SyntaxNinja> dcoutts_: yay
07:43:17 <dcoutts_> ndm: why do you say that? I'm not sure I follow
07:43:42 <ndm> dcoutts_ if you hvae lots of .cabal files in one dir, which is the setup.hs to go with it?
07:43:50 <dcoutts_> ndm: ah yes
07:44:05 <Igloo> lots per system doesn't mean lots in the same directory
07:44:31 <ndm> Igloo: no, it could mean lots of annoying little directories created to patch over brokenness in another system
07:45:02 <Igloo> If they're separate enough to need different Cabal files then they're separate enough to be in separate directories regardless, IMO
07:45:53 <ndm> i disagree
07:45:59 <ndm> what about Yhc and Yhc.Core
07:46:06 <ndm> we want Yhc to be in src/compiler
07:46:12 <ndm> Yhc.Core to be in src/libraries/core
07:46:25 <ndm> but don't want the user to have to deep navigate our directory structure to install the thing
07:46:27 <vvv> Hi, lazy programmers!
07:46:32 <ndm> much easier if they are all in the root
07:46:34 <malcolmw> my plan for nhc98 has been to put all installed .cabal files in a single directory to serve as the package database
07:46:38 <vvv> Is there any idiomatic way to separate the following function into pure and monadic parts?
07:46:38 <vvv> > measure :: FilePath -> IO ()
07:46:38 <vvv> > measure fn = readFile fn >>= print . length . split
07:46:38 <vvv> where `split' has type
07:46:38 <vvv> > split :: String -> [String]
07:46:39 <lambdabot>  Parse error
07:46:39 <Igloo> ndm: Right, so you want a meta-yhc.cabal at the top level
07:46:40 <lambdabot>   Not in scope: `measure'
07:46:40 <lambdabot>  Couldn't match expected type `[String]'
07:47:06 <ndm> Igloo: ok, if we can have meta-yhc, then that fine
07:47:15 <dcoutts_> malcolmw: sounds sensible
07:47:35 <ski> print . lengt . split =<< readFile fn   -- /me 'd prefer this order
07:47:44 <ndm> malcolmw: what if you have two installed copies of the same package, different versions?
07:47:55 <ndm> the Yhc plan was always packagename-version directories
07:48:03 <ndm> then each directory has as its root a .cabal file
07:48:06 <dcoutts_> no probs, pkgfoo-1.0.cabal
07:48:07 <narain> since the pure part is just length . split it doesn't seem like much of an advantage to split it
07:48:08 <malcolmw> ndm: then obviously the .cabal files need to be named differently
07:48:22 <dcoutts_> malcolmw: they can all be versioned
07:48:30 <dcoutts_> malcolmw: like we do on hackage
07:48:36 <hpaste>  Saizan pasted "a better way to write prop_unicity?" at http://hpaste.org/1705
07:49:08 <dcoutts_> malcolmw: eg see http://hackage.haskell.org/packages/archive/cabal-upload/
07:49:10 <lambdabot> Title: Index of /packages/archive/cabal-upload
07:49:21 <vvv> ski: The order is not so important, actually...
07:49:28 <dcoutts_> malcolmw: a single dir of versioned .cabal files sounds nice and simple
07:49:32 <ski> vvv : i guess you could build a 'hInteract :: Handle -> Handle -> (String -> String) -> IO ()' abstraction if you wanted ..
07:49:39 <Saizan> or an example of a quickcheck property that works on a range of types..
07:49:55 <malcolmw> dcoutts_: it is simple, but probably requires expensive processing every time you compile/link something
07:50:03 <dcoutts_> malcolmw: yes.
07:50:08 <malcolmw> dcoutts_: s/you/nhc98/
07:50:18 <dcoutts_> malcolmw: for ghc we were thinking of a similar scheme, but with a binary cache
07:50:24 <vvv> ski: hInteract, aha. OK, let me think about it. Thanks!
07:50:43 <malcolmw> dcoutts_: yeah, I was going to have a cache as well, but then you need to detect whether file timestamps have changed
07:50:49 <dcoutts_> malcolmw: right.
07:50:59 <malcolmw> dcoutts_: and by that stage, you might as well just read the file
07:51:09 <ndm> malcolmw: its going to be massively cheaper than textual .hi files
07:51:22 <dcoutts_> malcolmw: hmm, I think from the kernels point of view it's much cheaper to scan the dir than to that and open them all
07:51:32 <ndm> malcolmw: we thought of it briefly, but a quick test shows the time really doesn't make any difference
07:52:31 <malcolmw> if you generate/update the cache file every time a new package is installed, then you can probably avoid checking timestamps anyway
07:53:00 <sproingie> sqlite for the cache?
07:53:01 <dcoutts_> malcolmw: I believe on posix systems that the dir's own modification time changes when you update a file in the dir, or am I talking nonsesne? If so it's just two stats.
07:53:29 <ndm> malcolmw: but they you will end up getting a stale cache at some point
07:53:31 <malcolmw> sproingie: the whole idea is to avoid using a proper database
07:53:34 <dcoutts_> malcolmw: right, so eg for ghc, still go via ghc-pkg for registration and it just updates the cache
07:53:41 <sproingie> the dir's modification time only changes when you modify a dirent i believe
07:53:49 <sproingie> add, remove, or rename a file
07:54:09 <dcoutts_> sproingie: that sounds like what we need
07:54:24 <malcolmw> sproingie: yes, file modification time does not propagate up the dir hierarchy
07:54:35 <dcoutts_> sproingie: since changing one of these text files invariably means creating a new one and atomically renaming
07:54:56 <dcoutts_> I'm pretty sure the gtk+ icon cache works this way
07:55:05 <sproingie> when you're using versioned names, yah, it's taken care of for free
07:56:29 <dcoutts_> malcolmw: it's really a great deal easier for packaging systems if they control the package registration files
07:56:57 <dcoutts_> malcolmw: so the package would install foo-1.0.cabal in nhc's packagedb dir and then just call a prog to update the cache
07:57:31 <dcoutts_> it's much more annoying with the current ghc-pkg system where ghc-pkg creates the file on your behalf
07:57:42 <dcoutts_> then nobody knows who owes that file
07:58:34 <dcoutts_> with a dir, it's simple, each package owns their own registration file and nhc/ghc/yhc own the cache file
07:58:49 <malcolmw> dcoutts_: I'm thinking that the only thing nhc98 actively needs from the .cabal database is the transitive closure of packages used by a prog, so it can link against them all.
07:59:07 <malcolmw> dcoutts_: i.e. the depends (build-depends?) field only
07:59:12 <dcoutts_> right
07:59:55 <malcolmw> dcoutts_: yeah, the way you suggest is should work is exactly the way I had envisaged it
08:00:09 <dcoutts_> good good :-)
08:00:47 <malcolmw> dcoutts_: the unfortunate thing is that I'm likely to code it up in shell script :-)
08:01:03 <dcoutts_> ha ha hah :-)
08:01:35 <malcolmw> if at all...
08:02:53 <dcoutts_> hia bringert
08:03:28 <Igloo> malcolmw: You also need to know extension, flags etc surely?
08:03:42 <dcoutts_> bringert: I was wondering if we couldn't just kill HTTP-3000 ? either go with 1.0 or the year.month.day scheme
08:03:52 <dcoutts_> -3000 feels a tad silly
08:04:34 <dcoutts_> bringert: I've set the deps in cabal-install and cabal-upload to be HTTP >= 1.0 && < 2
08:05:39 <bringert> dcoutts_: I wanted to move from date-based to major.minor, and changed to 1.0. But that broke version ordering.
08:05:39 <lambdabot> bringert: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:05:56 <bringert> dcoutts_: that's why I made it 3000.0.0
08:06:00 <quicksilver> such a nightmare
08:06:04 <dcoutts_> bringert: I understand, but we can set < 2.0
08:06:06 <quicksilver> that's why debian was forced to invent epoch
08:06:23 <Igloo> dcoutts_: You want to carry < 2.0 around until there have been 3000 major releases?
08:06:26 <bringert> dcoutts_: yeah, but everyone has to do that then
08:06:41 <dcoutts_> the old versions will die out eventually
08:06:42 <bringert> @messages
08:06:42 <lambdabot> dcoutts_ said 1d 1h 36m 7s ago: Congratulations!
08:06:43 <lambdabot> shapr said 1d 1h 19m 34s ago: congrats!
08:06:43 <lambdabot> nominolo said 1d 41m 12s ago: congrats from me too (although i'm not entirely sure what they're for; i have a good guess, though)
08:06:43 <lambdabot> swiert said 6h 24m 35s ago: Congratulations!
08:07:08 <bringert> dcoutts_, shapr, nominolo, swiert: thanks!
08:07:12 <dcoutts_> :-)
08:07:21 <Igloo> If you /are/ going to go for 1.0, which I agree with bringert would be the wrong decision, then you shouldn't bother with <2 IMO
08:07:27 <dcoutts_> bringert: feeling exhausted?
08:08:04 <dcoutts_> Igloo: because?
08:08:38 <Igloo> Because it's not what you mean
08:08:48 <dcoutts_> it probably is actually
08:09:03 <dcoutts_> if there ever is a 2.0 it's likely to break these programs
08:09:03 <Igloo> You don't do likewise for any other library though, do you?
08:09:09 <dcoutts_> true
08:09:30 <dcoutts_> we just cross our fingers and hope new libs are backwards compatible
08:09:39 <bringert> dcoutts_: it's not that bad. the little guy turns 10 days old today, and it's starting to settle down
08:10:12 <Igloo> bringert: settle down? Has he got a wife and a little cottage in the country?  :-)
08:10:22 <dcoutts_> Igloo: so you think starting the version number at 3000 is a good idea?
08:10:31 <Igloo> dcoutts_: Yes
08:10:36 * dcoutts_ sighs
08:11:04 <Igloo> It's the honest thing to do
08:11:26 <dcoutts_> perhaps, though it looks ridiculous
08:11:51 <Saizan> it's a bit like python 3000
08:11:59 <Igloo> BTW, I'm not deliberately trying to disagree with you about everything today  :-)
08:12:26 <dcoutts_> Igloo: s'ok! :-) I need people to disagree with me :-)  and as you notice I often change my mind.
08:13:20 * dcoutts_ apologises to Igloo for calling the both of us "anal about packaging" earlier
08:13:48 <Igloo> You shouldn't have apologised - I hadn't noticed  :-)
08:13:52 <dcoutts_> hah hah
08:15:18 <dcoutts_> Igloo: we were talking about installing things in ~/bin and I noted that neither of us trust package managers, probably because we both make distro packages :-)
08:15:36 <Igloo> :-)
08:15:56 * Igloo wonders why "darcs what -ls --boring" prints nothing in my ghc repo, when "darcs what -ls" prints stuff
08:16:43 <LoganCapaldo> Theres nothing boring about ghc?
08:17:13 <opqdonut> ":----D"
08:19:51 <LoganCapaldo> So i'm working my way thru ifpl: tutorial. Miranda seems like it had some neat ideas. I like prefix # for length
08:21:55 <bringert> Igloo: "it" refers to the situation. the kid is a "he". and I'm sure he won't find a wife for a least another few weeks
08:22:14 <Igloo> bringert: :-)
08:24:07 <LoganCapaldo> I guess (#) = length is not syntactically ok in haskell eh?
08:24:19 <sproingie> prefixed # for length sounds awfully perlish
08:24:26 <narain> > let (#) = length in (#) [1,2,3]
08:24:28 <lambdabot>  3
08:24:32 <LoganCapaldo> waaaaa
08:24:48 * LoganCapaldo tries -fglasgow-exts
08:25:18 * narain didn't know lb had glasgow exts
08:25:30 <Saizan> > let (#) = length in # [1,2,3]
08:25:31 <lambdabot>  Parse error
08:25:34 * LoganCapaldo doesn't know if it does or it doesn't
08:25:35 <Saizan> she doesn't
08:25:45 <olsner> > let ($#:;=) = length in ($#:;=) [1,2,3]
08:25:45 <lambdabot>  Illegal character ''\164''
08:25:50 <int-e> > let (#) = length in ([1,2,3] #)
08:25:52 <lambdabot>  3
08:25:58 <int-e> yes it does
08:26:20 <narain> whoa, that's interesting
08:26:35 <narain> > let (!) n = product [1..n] in (6!)
08:26:36 <lambdabot>  720
08:26:41 <narain> woo
08:26:59 * LoganCapaldo tries at the prompt instead of a file
08:27:16 <narain> LoganCapaldo: what's interesting in Miranda from a Haskell perspective?
08:27:47 <LoganCapaldo> Oh I dunno abotu all that
08:27:58 <LoganCapaldo> I jsut though # xs was good syntax :)
08:28:09 <narain> oh ok, i thought you had found more interesting bits :)
08:28:16 <LoganCapaldo> Not really
08:28:25 <LoganCapaldo> the abstype thing seems interesting
08:28:29 * narain didn't mean it as a rhetorical question either, in case it sounded like one
08:28:30 <LoganCapaldo> but I didn't quite get it
08:28:46 <ndm> narain: i think Miranda has some sort of views?
08:28:49 <LoganCapaldo> I get the feeling it was  a prototypical form of type classes
08:29:27 <narain> ndm: are they like ML's signatures?
08:29:44 <ndm> narain: i don't really know...
08:29:58 <narain> ok
08:30:48 <sproingie> i'm not sure that # xs is any better than length xs
08:31:20 <sproingie> i'm not a big fan of all the noisy operators in the haskell libs either
08:34:40 <quicksilver> one man's noise is another man's convenience
08:34:56 <quicksilver> when you are not familiar with an area of mathematics, you find the 'local conventions' irritating and obscure
08:35:09 <quicksilver> when you become familiar, you find they help you express complex things in a concise way
08:35:14 <quicksilver> programming languages are just the same :)
08:35:14 <malcolmw> Igloo: re .cabal files, there's very little the compiler needs to know once it has been built and installed
08:35:23 <quicksilver> haskell gives you more power to abstract in this way than most, though
08:35:34 <Igloo> malcolmw: Oh, I see, yes
08:35:42 <malcolmw> Igloo: but yeah, in addition to package dependencies, there may be linker flags I guess
08:35:49 <Igloo> Yeah, and extra libraries
08:36:26 <sproingie> i wouldn't mind all the noisy operators if haskell also allowed utf8 source
08:36:45 <sproingie> i could find all kinds of fun symbols to use that weren't funny trigrams like <*>
08:37:03 <Igloo> Haskell does allow utf8 source
08:37:18 <sproingie> s/haskell/ghc/
08:37:33 <sproingie> or am i misinformed there too
08:37:36 <Igloo> ghc does too
08:37:38 <Igloo> ghci doesn't
08:37:57 <malcolmw> ghc is a bit split-personality on unicode though.  UTF8  for source, Latin1 for runtime input
08:38:02 <sproingie> ah that's it.  what about hugs?
08:38:25 <Igloo> hugs is fully unicode AFAIK
08:38:38 <Syzygy-> Igloo: So you could write with unicode operator, but not interact with it in the interpreter for ghci?
08:38:40 <malcolmw> hugs uses your environment locale
08:38:48 <Igloo> Syzygy-: Yup
08:38:55 <Syzygy-> Yech.
08:38:56 <Syzygy->  :(
08:39:12 <Igloo> Oh, yes, I remember. But mine is utf8  :-)
08:39:22 <sproingie> windows for me right now, which would mean utf16.  i'd have to iconv all my sources i guess
08:40:08 <sproingie> meh.  guess i should stick with words and use backticks
08:40:31 <malcolmw> is there a canonical UTF8 decoder yet :: [Word8] -> [Char]?
08:41:29 <dmhouse> How big are Word8s?
08:42:35 <malcolmw> dmhouse: the clue is in the name :-)
08:42:54 <malcolmw> dmhouse: another clue is that there are Word16, Word32, and Word64 types too
08:43:09 <sproingie> [WordUp]
08:43:37 <dmhouse> malcolmw: 8 bits?
08:43:52 <dmhouse> :) Sorry, I was confusing myself, thinking that UTF8 required more than 8 bits/character.
08:44:12 <malcolmw> dmhouse: UTF8 does permit more than 8 bits/character
08:44:13 <Syzygy-> dmhouse: It requires potentially more than 1 character per codepoint though. :P
08:44:28 <dmhouse> Yes, but not for _every_ character. That's what I meant.
08:44:38 <Syzygy-> Is it 32 bit characters you need for a fixed-length unicode?
08:44:52 <malcolmw> Syzygy-: technically, 21 bits is sufficient
08:45:16 <Syzygy-> malcolmw: But the encoding floating around is with 4-byte-characters, right?
08:45:24 <Syzygy-> UCS-2 or whatever it's called...
08:46:04 <malcolmw> Syzygy-: there are very few machines with 21-bit words, yes, so 32 bits is the next largest convenient size
08:46:11 <Syzygy-> :)
08:46:57 <quicksilver> malcolmw: [Word8] -> [Char]; look in the source for CompactString
08:47:08 <quicksilver> malcolmw: it's (fairly) simple, just 6-10 lines of pure haskell
08:47:16 <quicksilver> malcolmw: AFAIK it doesn't exist in any standard lib
08:50:05 <quicksilver> Syzygy-: and yet, there are characters which do not fit in the 32-bit encoding
08:50:09 <malcolmw> CompactString claims not to do UTF8 on its webpabe
08:50:24 <quicksilver> Syzygy-: due to wasteful allocation of namespace rather than anything like running out of 4 billion possibilities
08:50:27 <Ashsong> dcoutts: ping?
08:50:27 <dmhouse> Anyone use haskell-mode on XEmacs?
08:50:32 <quicksilver> malcolmw: that's odd; I remember reading the term somewhere
08:50:38 <quicksilver> malcolmw: reading the code, I mean
08:50:41 <quicksilver> malcolmw: let me poke about
08:51:24 <malcolmw> quicksilver: actually, the announcement of CompactString 0.3 on the haskell list does claim to cover UTF8 UTF16 UTF32 and some others
08:51:59 <malcolmw> quicksilver: but the webpage "implementation details" says not.
08:52:35 <malcolmw> quicksilver: the Haddock looks more promising though - there is a module called Data.CompactString.UTF8
08:52:56 <qfs> just curious, anyone here using haskell in a production environment? or mostly hobby projects?
08:54:22 <mnislaih> shapr: any idea why resp is not exposed in SimpleHTTP2 ? Is there a better way of returning with a custom HTTP code ?
08:54:36 <vegai> given that almost everyone here is a PhD student... :P
08:54:39 <nominolo_> stupid question maybe, but:  Is Network.HTTP supposed to work with Hugs?
08:55:02 <malcolmw> qfs: Credit Suisse, Galois Connections, Linspire ...
08:55:30 <qfs> i work at morgan stanley, but they wouldnt dare allow us to touch haskell :)
08:55:34 <steven807> Hello folks.  I just compiled ghc 6.6.1 from source (on a mac), and the readline stuff seems broken (control chars don't work, I can't even backspace).
08:55:48 <steven807> The conf.log file suggests that readline was detected just fine.  Anyone have any thoughts?
08:55:58 <steven807> Oops, forgot to say that problems show up when running ghci
08:56:14 <mnislaih> steven807: readline in Mac Os X is screwed up
08:56:19 <qfs> vegai thats what i figured...
08:56:20 <malcolmw> qfs: tell the bosses that their competitors are all using Haskell :-)
08:56:33 <qfs> yes, but were beating them.
08:56:35 <steven807> mnislaih: but ghci 6.6 worked fine...
08:56:37 <qfs> lol
08:57:01 <steven807> manislaih: On the other hand, I didn't compile 6.6 from source.. Hmm..
08:57:01 <mnislaih> you probably installed it from Macports steven807
08:57:37 <steven807> mnislaih: Boo.. OK, thanks for the info.  Drat.  Without backspace, ghci is kinda unusable.  Maybe there's a port available by now.
08:57:54 <mnislaih> steven807: the port for 6.6.1 is available,
08:57:59 <qfs> just looking for an excuse to do something at work outside of c++...
08:58:10 <steven807> cool, grabbing it now
08:58:27 <mnislaih> steven807: anyway, look at here if you want to fix your build yourself. http://mult.ifario.us/articles/tag/macosx
08:58:29 <lambdabot> Title: mult.ifario.us : mult.ifario.us - tag macosx
08:58:48 <steven807> mnislaih: Oo, better yet!  Thanks!
09:05:17 <qfs> hmmm, i saw credit suisse is hiring quantitative programmers. thats a rare breed though. those guys have phds and make a 1/4 mil a year
09:05:25 <qfs> ...in haskell
09:06:36 <arcatan> what quantitative means in this sense?
09:06:56 <qfs> finance is nothing but quantities
09:07:08 <quicksilver> arcatan: precise numerical calculations (financial)
09:07:20 <quicksilver> arcatan: risk, weighted averages, predictions, models
09:07:46 <arcatan> okay
09:17:31 <dmhouse> Anyone use haskell-mode on XEmacs?
09:17:38 <dmhouse> Or even use XEmacs in general?
09:19:30 <nerdalert> does regular GNU emacs count?
09:20:40 <dmhouse> nerdalert: afraid not. There are a bunch of XEmacs bugs reported for haskell-mode and I'd like someone to test to see if they still exist.
09:21:24 <nerdalert> dmhouse: gotcha
09:21:54 <shapr> dmhouse: I do.
09:22:29 <dmhouse> shapr: presupposing you're using the latest version of haskell-mode (2.3), any chance you could test whether http://haskell.org/haskellwiki/Haskell_mode_for_Emacs#XEmacs still hold?
09:22:30 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
09:23:38 <shapr> dmhouse: I had to patch my haskell-mode specifically for 4.1.1 and 4.1.2, but I may be using 2.2 instead of 2.3
09:24:42 <shapr> I am using 2.3
09:24:55 <savanni> Have any of you run into trouble building HaXml-1.13.2 on OS X?
09:25:18 <malcolmw> savanni: using ghc-6.6?
09:25:38 <savanni> Yep.  6.6.20070326
09:25:48 <shapr> dmhouse: Why do you ask?
09:26:12 <malcolmw> savanni: building/installing via Makefiles (known to be broken) or with Cabal (known to work)?
09:26:33 <savanni> Uh....
09:26:39 <dmhouse> shapr: I wanted to see if those bugs are still there, they've been on the wiki for ages and I'm trying to clear that page up.
09:26:41 <savanni> I actually did not know that the Makefiles were broken.
09:26:55 <malcolmw> savanni: that's why you asked here :-)
09:27:10 <savanni> Yeah.  I was just following the readme instructions.  Trying Cabal now.
09:28:37 <malcolmw> on the main HaXml webpage, the installation instructions say "or, if that fails (for recent versions of ghc), ..."
09:29:27 <savanni> Arg.  Me following an in-brain script.  Sorry...
09:31:23 <malcolmw> savanni: no need to apologise
09:32:28 <malcolmw> I have just never got round to working out how to cope in Makefiles with ghc-6.6's changes to the package mechanism.
09:32:40 <Cheery> @google 09 F9
09:32:43 <lambdabot> http://www.theinquirer.net/default.aspx?article=39330
09:32:43 <lambdabot> Title: 09 f9 11 02 9d 74 e3 5b d8 41 56 c5 63 56 88 c0 is the number they tried to ban
09:32:51 <Cheery> xD
09:32:52 <syntaxfree> so, is there a decimal float data type in haskell/ghc?
09:33:01 <opqdonut> Cheery: haw haw
09:33:02 <ddarius> Float?
09:33:16 <syntaxfree> isn't Float a *binary* float?
09:33:26 <ddarius> I was wondering what you meant.
09:33:39 <syntaxfree> http://www2.hursley.ibm.com/decimal/decifaq.html
09:33:41 <lambdabot> Title: Decimal Arithmetic - FAQ
09:33:43 <ddarius> Um, I guess Floats can be considered binary.
09:33:54 <syntaxfree> that's featured on reddit. I always think everyone reads reddit :)
09:34:02 <opqdonut> gah reddit
09:34:04 <opqdonut> bah
09:34:05 <opqdonut> pthui
09:34:54 <jward> I stopped reading reddit a month or so ago.
09:35:02 * ddarius never started.
09:35:10 <syntaxfree> well, I'll be back later.
09:41:50 <dcoutts_> @tell Ashsong you were after me?
09:41:50 <lambdabot> Consider it noted.
09:43:14 <quicksilver> you can get the advantages of decimal arithmetic using fixed point
09:43:17 <quicksilver> with a base 10 base
09:43:21 <quicksilver> at least, I believe you can
09:43:58 <ddarius> That's not useful if you want floating point numbers.
09:44:42 <quicksilver> is decimal floating point a common requirement?
09:44:51 <quicksilver> my understanding was that it wasn't
09:44:52 <ddarius> No.
09:45:12 <quicksilver> still a decimal floating haskell type is quite easy to picture
09:45:30 <quicksilver> the naive version wouldn't be stupendously fast; but I"m not sure that such calculations are expected to be CPU-bound
09:48:38 <ddarius> All it is is a pair of integral numbers and a little bit of "overflow" handling logic.
09:48:49 <quicksilver> right
09:48:55 <quicksilver> or no overflow handling logic at all
09:48:59 <quicksilver> if you just use Integer :)
09:49:23 <ddarius> quicksilver: Presumably Integer would be unacceptable.
09:49:54 <ddarius> Otherwise, one could use arbitrary precision or exact real binary numbers.
09:52:45 <quicksilver> ddarius: exact rational you mean I suspect
09:52:52 <quicksilver> ddarius: exact real really would be overkill :)
09:53:37 <ddarius> You can have a representation of a irrational real number.
09:55:57 <quicksilver> ddarius: some irrationals, yes
09:56:11 <quicksilver> ddarius: but a general representation of reals is a very hard question
09:56:19 <ddarius> Yes.  You clearly can't represent -all- reals.  But there are constructive reals.
09:56:24 * quicksilver nod
09:56:45 <quicksilver> however 'exact reals' is a term I would reserve for complex + expensive real arithmetic tricks
09:57:13 <ddarius> @google "Exact Reals" haskell
09:57:18 <lambdabot> http://www.cs.ru.nl/fnds/typesreal/
09:57:18 <lambdabot> Title: Constructive analysis, types and exact real numbers
09:58:05 <LeCamarade> sadfas: sadfas?
09:58:38 * LeCamarade was testing a bot with telnet(1)!
09:58:49 <ddarius> Holy crap.  Nevermind.  Haskell does already have a decimal arithmetic library.
09:59:58 <ddarius> ERA is an implementation (in Haskell 1.2) by David Lester.
09:59:58 <ddarius>     It is quite fast, possibly the fastest Haskell implementation. At 220 lines it is also the shortest. Probably the shortest implementation of exact real arithmetic in any language.
10:02:05 <binil> I got my copy of "Programming in Haskell" last week and I am working through the examples. On page 43 Sutton mentions "The library function ord :: Char -> Int and chr :: Int covert between characters and their Unicode representation as integers". But typing :t ord or :t chr into Hugs throw an error. I could not find ord anc chr at http://haskell.org/onlinereport/prelude-index.html either. Can someone please help me find these functions?
10:02:07 <lambdabot> Title: Haskell 98 Prelude Index
10:02:31 <chessguy> ?hoogle ord
10:02:32 <lambdabot> Char.ord :: Char -> Int
10:02:32 <lambdabot> Prelude.Ord :: class Eq a => Ord a
10:02:32 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
10:03:04 <chessguy> ?hoogle chr
10:03:05 <lambdabot> Char.chr :: Int -> Char
10:03:05 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
10:03:05 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
10:03:15 <ddarius> binil: Somehow this new book runs afoul of an old bug in Hugs where Hugs erroneously had Char imported.
10:03:16 <dmwit> binil: So, in Hugs, you need to type :m +Char
10:04:04 <eumenides> what's that ghc flag to allow ! in function arguments?
10:04:06 <quicksilver> Data.Char, I think
10:04:13 <quicksilver> Char is the old pre-hierarchical name
10:04:18 <ddarius> Data.Char is preferable nowadays.
10:04:42 <dcoutts_> binil: see the errata web page for the book, it mentions that one.
10:04:52 <dcoutts_> @google programming in haskell hutton errata
10:04:55 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
10:04:55 <lambdabot> Title: Programming in Haskell
10:04:56 <binil> darius: :m +Char, :m + Char and :m Char all threw errors in Hugs
10:05:24 <binil> dcoutts_: Thanks! Mea Culpa, I should have looked there first
10:05:35 <ddarius> binil: Wrong person.  I haven't used Hugs in years and never used it much.
10:05:48 <dcoutts_> binil: s'not your fault, it's reasonable to expect it to work.
10:05:55 <LeCamarade> binil: In Hugs it does. In GHCi, it doesn't (Char.ord).
10:06:28 <dmwit> binil: Hum, what was the error?
10:07:28 <quicksilver> binil: :load Char
10:07:31 <binil> dmwit: ERROR - Cannot find module "Char"
10:07:38 <quicksilver> binil: as described on the errata page :)
10:07:50 <binil> dmwit: As quicksilver mentioned :l instead of :m works!
10:07:56 <dmwit> Great!
10:08:03 <binil> quicksilver: Yes, I justed scanned down the page and found it - thanks!
10:08:12 <quicksilver> :)
10:23:42 <procyon112> Does anyone know if there is a point free translation of the pi calculus similar to using SK combinators to translate the Lambda calculus?  I need a variable free process calculus and google is not being my friend.
10:27:48 <shapr> Is there a Haskell implementation of all the stuff in Okasaki's book?
10:28:53 <dcoutts_> shapr: isn't that the Edison library?
10:29:30 <shapr> I'm not sure. I want Haskell versions of the ML example code in Okasaki's book so I can better understand what he's written.
10:31:08 <shapr> Edison has a bunch of typeclasses for Sequence, Queue, etc, right? I wonder if that'll get in the way of me understanding his example code.
10:32:55 <kc5tja> procyon112: Fortunately for me, I haven't a clue what Pi-calculus actually _is_, so I'm under no obligation to respond.  But I did anyway.  I haven't a clue.  :)
10:33:17 <dcoutts_> shapr: I think there's also Haskell code at the back of the book
10:34:04 <shapr> dcoutts: Oh, I've been thinking about an xmonad-style programming language, finger trees can be the one single data structure, any other thoughts on how to shrink the codebase of a language?
10:34:14 <chessguy> ?hoogle [m a] -> m [a]
10:34:15 <lambdabot> Prelude.head :: [a] -> a
10:34:15 <lambdabot> Prelude.last :: [a] -> a
10:34:15 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
10:34:16 <emu> shapr: i thought it was in an appendix
10:34:31 <shapr> dcoutts, emu: um, let me look...
10:34:43 <shapr> Wow, I feel silly.
10:34:44 <dcoutts_> shapr: an xmonad style *language*?
10:34:58 <shapr> dcoutts: Yeah, keep it under 1k lines total :-)
10:35:39 <shapr> So I figure, flush all the data structures except for finger trees. But I'm not sure what else would cut down on source and installed size.
10:35:39 <procyon112> kc5tja: :)  Pi calculus is a simple calculus, similar to Lambda calculus, but instead of variable substitution in a single process, it uses variables to be communication channels between cuncurrent asynch processes.
10:35:54 <dcoutts_> shapr: oh, mm ok. So, finger trees, see Data.Sequence and the corresponding paper.
10:36:21 <shapr> dcoutts, emu: Yup it's in the back.
10:42:18 <ndm> my pattern match error checker is crashing with a pattern match error
10:42:24 <ndm> i sometimes think it has a sense of humour...
10:44:42 <ibid> ndm: let me guess, it was checking itself? :)
10:45:04 <ndm> ibid: no, it was checking the regression suite, after making a change to the Yhc.Core main data structure
10:46:47 <ndm> it doesn't run on itself, sadly...
10:55:57 <dmwit> Okay, I've just handed in a homework.
10:56:25 <dmwit> One of the problems was to create a CFG for the language of all strings that are not of the form ww, i.e. some string repeated.
10:56:31 <dmwit> Is this even possible?
10:56:44 <dmwit> ... CFG = context-free grammar, sorry.
10:57:46 <Baughn> dmwit: Some /string/ repeated, or some /character/ repeated?
10:57:52 <dmwit> string
10:58:00 <dmwit> (!)
10:58:23 <Baughn> ..I'd have failed that test
11:00:52 <chessguy> dmwit: what language?
11:01:17 <chessguy> err
11:01:17 <dmwit> chessguy: Using only, say, 'a' and 'b' as terminals.
11:01:20 <chessguy> i mean what alphabet, sorry
11:01:41 <ndm> dmwit: repeated adjacently?
11:01:49 <dmwit> ndm: Correct.
11:01:58 <chessguy> so in that case, your language is {"a","b","ab","ba"}. hmmm
11:02:07 <dcoutts_> Ashsong: you were after me earlier
11:02:14 <ndm> dmwit: its a trick question, to some degree
11:02:30 <Ashsong> dcoutts_: Indeed, I'm the fellow who posted to cabal-devel yesterday about my experience extracting Cairo
11:02:30 <lambdabot> Ashsong: You have 1 new message. '/msg lambdabot @messages' to read it.
11:02:31 <ndm> dmwit: consider a repeated string, it must be either a, ab, ba, or b
11:02:58 <ndm> dmwit: if its any longer, then it has a repeated string within it - and once you are detecting only 4 forms, you can just look for them
11:03:06 <chessguy> dmwit: what about creating a DFA that accepts all such strings and then reversing which states are accepted
11:03:28 <dmwit> ndm: It's fine to have repeated substrings, only the entire string must satisfy the constraint.
11:03:34 <dmwit> (According to my reading.)
11:03:36 <Ashsong> dcoutts_: In fact, I managed to overcome most of the difficulties that arose. Cairo passed my first test case by drawing a red line from GHCI.
11:03:51 <dcoutts_> Ashsong: good good :-)
11:03:51 * dmwit goes to read the problem again very carefully
11:03:53 <ndm> dmwit: if you have repeated substings, thats fine, but you'll have detected it anyway, so you don't need to detect the entire thing
11:04:03 <Ashsong> dcoutts_: One particularly frustrating bug that arose was an off-by-one error in c2hs' line numbering.
11:04:07 <dcoutts_> Ashsong: so you've got it building using cabal then ?
11:04:18 <ndm> i.e. is "baa" a match, since it has "aa"
11:04:34 <dcoutts_> Ashsong: ah, can you distill a nice test case and send it to the c2hs mailing list?
11:04:35 <dmwit> "baa" is definitely in the language.
11:04:43 <Ashsong> dcoutts_: Yup. I haven't tested it anywhere but on my machine, and it certainly won't work on Windows (since I'm using pkg-config and Python to extract build flags)
11:04:51 <Ashsong> But I'm happy to share it if you want.
11:05:01 <chessguy> dmwit: what about my DFA suggestion?
11:05:10 <Ashsong> dcoutts_: I suppose I can try. Probably not until June, though. :(
11:05:15 <dcoutts_> Ashsong: ok
11:05:19 <ndm> dmwit: then just detect aa, abab, baba and bb and you've got everything covered?
11:05:24 <dmwit> chessguy: The detection of a single repeated string is neither DFA nor context-free...
11:05:38 <dcoutts_> Ashsong: I was thinking of teaching cabal about pkg-config
11:05:43 <ndm> dmwit: if you detect those 4 strings, is there any instance which is in the language but not spotted?
11:05:48 <chessguy> hmm
11:06:09 <dmwit> ndm: a^{2n-1}b is in the language, but a^{2n-1}a is not...
11:06:17 <dmwit> =(
11:06:27 <chessguy> apparemtnly i'm not remembering my formal languages class well enough then
11:06:41 <Ashsong> dcoutts_: The order-dependency in "other-modules" really surprised me.
11:06:42 <chessguy> or i'm mis-underestimating the problem
11:06:45 <chessguy> (or both)
11:06:48 <dmwit> heh
11:06:54 <ndm> dmwit: hmm? you mean aaab is in the language but aaaa is not?
11:06:59 <dmwit> Yeah, a lot of people seemed to have trouble with it.
11:07:09 <ndm> both of those have aa as a repeated adjacent string
11:07:12 <dmwit> ndm: Right, because "aaaa" is "aa" repeated, but "aaab" is not the repetition of any single string.
11:07:20 <dcoutts_> Ashsong: aye, it's a pain. Cabal should have done proper dep analysis from the beginning, but all the compilers can do it themselves so it got put off. :-(
11:07:48 <ndm> dmwit: oh, so you need to specify it as m*, where m is some arbitrary string
11:07:59 <Ashsong> dcoutts_: That didn't bother me so much; all that really bothered me was the lack of obvious documentation.
11:08:15 <Ashsong> dcoutts_: I certainly don't expect cabal to fully support every preprocessor ever written for Haskell!
11:08:21 <dmwit> ndm: Right, a regular expression with back-references would do the trick -- but I don't think that's context-free, is it?
11:08:36 <ndm> dmwit: i thought those were TM....
11:08:37 <Syzygy-> DAMN! I understood "question=0xFF; // optimized Hamlet" with my mouth full of water.
11:08:47 <ndm> they are certainly NP
11:09:15 <dcoutts_> Ashsong: heh, c2hs support was added as a quick hack, so never documented. I've recently been trying to make cabal's c2hs support not suck completely. It required a few improvements to c2hs too.
11:09:33 <dcoutts_> Ashsong: the main remaining issue is with the dep analysis.
11:09:37 <dmwit> TM?
11:09:42 <dmwit> turing-machine?
11:09:44 <ndm> dmwit: turing machine
11:09:55 <Ashsong> dcoutts_: Indeed. One thing I noticed was that there was no obvious way to get c2hs' external header files included on the command line that cabal calls it with.
11:09:56 <dmwit> Yeah, I'm at a loss.  I think the problem is wrong somehow.
11:09:57 <dcoutts_> Ashsong: what is your application btw? some server side pic generating thing?
11:10:09 <dmwit> I'll have to wait to poke holes in it until after the solutions are posted, though.
11:10:10 <Ashsong> dcoutts_: I wound up just using the #c  #include <..> #endc route
11:10:11 <dcoutts_> Ashsong: right, I just fixed that too.
11:10:28 <dcoutts_> Ashsong: all the .h files you list in the cabal "includes: " list are now passed to c2hs.
11:10:41 <dcoutts_> Ashsong: but you need the darcs version of cabal and c2hs to get that.
11:10:42 <Baughn> dmwit: It doesn't help that the only almost-context-free solutions I can think of would take exponential time to actually execute
11:10:43 <Ashsong> dcoutts_: Basically, I just wanted Haskell to have a nice 2-d rendering api. I like cairo, and I knew you'd worked with it.
11:10:44 <chessguy> Syzygy-: wow, it took me this long to just get that
11:11:00 <dmwit> Bah, execution time.  Who cares about it? ;-)
11:11:02 <Ashsong> dcoutts_: So I picked up where you left off in this regard.
11:11:14 <dmwit> Baughn: The fact that you come even close to context-free boggles me.
11:11:28 <dcoutts_> Ashsong: it was xerox who did the binding as a Google SoC project a couple years ago. I supervised him.
11:11:29 <Ashsong> dcoutts_: I was helping a friend work out the types in some recursive equations in an economics homework problem he was doing.
11:11:37 <ndm> dmwit: it may be possible, if you do it non-deterministically with a pushdown automata, you push all the letters on, then non-determinisitically stop at some point, then check that the thing matches
11:11:42 <dcoutts_> Ashsong: sounds terrifying :-)
11:11:47 <Ashsong> dcoutts_: Ah. Well, thanks to xerox then. That's Paolo?
11:11:50 <dcoutts_> yes
11:11:55 <dmwit> ndm: Right, but the stack will be backwards from what you have to check.
11:12:04 <dmwit> ndm: And you don't have another stack to use to reverse it... ;-)
11:12:19 <ndm> dmwit: exactly, can you encode reverse in NDPA?
11:12:28 <ndm> non-deterministic push-down automata
11:12:33 <Ashsong> dcoutts_: Indeed. Their model cannot be well-typed. Nevertheless, we wanted to plot the output. Of course it's easy enough to go through gnuplot or similar, but really, this should be easy to do from GHCI.
11:12:34 <Baughn> dmwit: I can't seem to make it work without (back-)references, so it isn't really
11:12:36 <chessguy> ?vera NDPA
11:12:39 <lambdabot> *** "ndpa" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:12:39 <lambdabot> NDPA
11:12:39 <lambdabot>      Network Problem Determination Application
11:12:39 <lambdabot>  
11:12:49 <dmwit> ndm: No, it takes infinitely many states (or another stack).  This one we proved in class.
11:13:07 <dcoutts_> Ashsong: have you seen http://dockerz.net/twd/HaskellCharts
11:13:09 <lambdabot> Title: HaskellCharts - twd
11:13:32 <dcoutts_> Ashsong: I've never used it, but it looks nice
11:13:38 <ndm> dmwit: i can't figure it out...
11:13:53 <Ashsong> dcoutts_: Yes, I'd glanced at it when it came out and forgotten about it until you reminded me.
11:13:53 <Eidolos> ?hoogle radix
11:13:54 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
11:14:11 <Baughn> dmwit: You could make a grammar that enumerates all matching strings. It isn't infinite because your computer isn't.
11:14:50 <dmwit> Baughn: Cheating, this is in a theory class. =P
11:15:19 <dmwit> Anyway, thanks for your help.  I'm sorry I brought it up...
11:15:40 <Baughn> dmwit: Was it actually specified that the grammar must be finite?
11:15:59 * Baughn figures you could implement an infinite one - lazily.
11:16:35 * dmwit goes to check the definition of CFG
11:17:15 <dmwit> 4. There is a finite set of \emph{productions} or \emph{rules} that ...
11:17:16 <dmwit> =(
11:17:36 <dmwit> The other relevant sets are specified to be finite, too.
11:17:55 <dmwit> That would be a truly devious loophole, though.
11:19:53 <DRMacIver> What's the problem?
11:20:11 <dmwit> DRMacIver: My problem?
11:20:14 <DRMacIver> Yes
11:20:26 <dmwit> Construct a context-free grammar for the language
11:20:39 <dmwit> that consists of all strings of 'a's and 'b's that are *not* of the form
11:20:50 <dmwit> ww for some w in (a|b)*
11:21:05 <dmwit> .
11:21:09 <DRMacIver> Hm
11:21:14 <Baughn> dmwit: Just ww? Not www?
11:21:30 <Baughn> I was assuming ww+ - this makes it much easier.
11:21:47 <dmwit> No, we should only reject it if it is of the form ww.
11:22:26 <dmhouse> Well, to check a string fits that rule is easy.
11:22:36 <dmhouse> You just chop it in half and compare the first and second bit.
11:22:39 <DRMacIver> I can provide a constructive proof of the existence of such a grammar if that would help? :)
11:22:45 <Baughn> dmwit: You're not allowed to compare halves, though
11:23:03 <Baughn> I mean, dmhouse
11:23:07 <dmhouse> Baughn: why's that?
11:23:11 <dmwit> DRMacIver: I'm way skeptical.
11:23:16 <Baughn> dmhouse: Wouldn't be a CFG then
11:23:18 <dmwit> dmhouse: Because that is a context-sensitive operation.
11:23:23 <DRMacIver> One second while I convince myself that it works.
11:24:22 <Baughn> dmhouse: ...I can think of so /many/ /trivial/ ways to do this; I'm not used to thinking with blinders on. Sorry..
11:24:23 <DRMacIver> Yeah, this should work.
11:24:47 <DRMacIver>  ww is clearly context free. So we can recognise it via some pushdown automata.
11:25:00 <dmwit> No, ww is not context-free.
11:25:21 <DRMacIver> Really? It's not regular, it is context free though isn't it?
11:25:35 <DRMacIver> Oh, bollocks. I'm confused.
11:25:40 <dmwit> ww^R is context-free (i.e. even-length palindromes), but not ww
11:25:45 <DRMacIver> Yeah
11:25:55 <DRMacIver> It's a friday. My excuse and I'm sticking with it.
11:26:05 <dmwit> =)
11:27:43 <chessguy> dmwit: then you should be able to prove it if it's not a CFG
11:27:51 <chessguy> and present the proof to your prof on monday
11:27:59 <DRMacIver> ok. Well aren't context free languages closed under complementation? I was just about to outline an argument to that effect - take the same push down automata but with its transition function complemented.
11:28:08 <chessguy> heh. "proof to your prof"...say that 10 times fast
11:28:17 <dmwit> chessguy: Heh, yeah, I thought of that.  But I couldn't get the pumping lemma for CFGs to give a contradiction, either...
11:28:27 <DRMacIver> Hm, no, I don't think that works after all.
11:28:31 <DRMacIver> Friday, excuse, etc.
11:29:15 <DRMacIver> (It works for DFA, but the stack screws this construction up)
11:29:46 * DRMacIver shuts up and lets the people who know what htey're talking about speak. :)
11:30:34 <dmwit> DRMacIver: Yeah, I don't think CFLs are closed under complement.
11:30:39 <dmwit> Rats, that would have been very nice.
11:32:21 <Baughn> dmwit: Last thought on the matter: It almost has to be a /small/ grammar, so.. enumerate all of them and mechanically check if one matches.
11:33:17 <dmwit> Baughn: Sorry for the slow reply.  I actually fell out of my chair when I read that.
11:33:21 <dmwit> =DDD
11:33:30 <dmwit> I might actually do that.
11:34:05 <DRMacIver> How would one actually mechanically check if one matches? Just test it against a lot of things?
11:34:45 <dmwit> Yeah that will filter out most of them.
11:34:53 <dmwit> Then I can apply my MIGHT BRAIN to decode the rest.
11:34:57 <Baughn> DRMacIver: Ayup. It's easy to generate matching strings with a turing machine (and non-matching ones), and a small grammar won't fool you.
11:35:04 <DRMacIver> True
11:35:17 <DRMacIver> dmwit: Your mighty brain can't spel. :-p
11:35:32 <dmwit> dmwit :: Maybe Brain
11:35:43 <dmwit> type Might = Maybe ?
11:38:35 <Ashsong> dcoutts_: Well, thanks for all the hard work you're putting into cabal, gtk2hs, and all the rest.
11:38:41 <Ashsong> Take care, all.
11:43:31 <allbery_b> hm.  how do I put up a busy cursor in gtk2hs?
11:44:33 <dcoutts_> erm...
11:44:56 <allbery_b> hm?
11:48:59 <dcoutts_> allbery_b: looks like you need gdk_window_set_cursor, which we have not bound yet
11:48:59 <dcoutts_> http://developer.gnome.org/doc/API/2.0/gdk/gdk-Windows.html#gdk-window-set-cursor
11:49:01 <lambdabot> Title: Windows, http://tinyurl.com/22f8kd
11:49:09 <dcoutts_> allbery_b: patches gratefully accepted
11:49:58 <Cheery> I came up with a thought
11:50:06 <dcoutts_> allbery_b: in Gtk2Hs we call a GdkWindow a DrawWindow to distinguish it from a GtkWindow which we just call a Window. (confused? ;-))
11:50:08 <Cheery> what about making (,) a monad?
11:50:25 <dcoutts_> Cheery: a writer monad ?
11:50:26 <dmhouse> Cheery: how?
11:50:36 <dmhouse> Oh, Writer, heh, forgot about that :)
11:50:55 <Cheery> is writer monad a Tuple -monad?
11:51:00 <allbery_b> hm.  patches and darcs still a problem here
11:51:01 <dmhouse> ?src Writer
11:51:02 <lambdabot> Source not found. Where did you learn to type?
11:51:15 <hpaste>  LeCamarade pasted "Monads That Aren't Maybe and List?" at http://hpaste.org/1706
11:51:22 <dmhouse> Cheery: yep. data Writer w a = Writer { runWriter :: (w, a) } or something like that.
11:51:30 <dmhouse> Hence data Writer w a = Writer (w, a).
11:51:31 <dcoutts_> allbery_b: we can deal with non-darcs patches
11:51:35 <LeCamarade> Okay, someone help me make tha kid work. The paste.
11:51:41 <dcoutts_> allbery_b: you're on windows?
11:51:46 <allbery_b> more to the point:  autoconf version skew is a serious problem here
11:51:53 <dcoutts_> ah
11:51:54 <LeCamarade> It's just Monad toying. Simple stuff, but I don't get it.
11:52:31 <Cheery> dmhouse: why not simply just: instance Monad (,) ?
11:52:38 <LeCamarade> Can someone make that paste compile?
11:53:03 <dmhouse> "data (Show a) => SString a = Insecure a" - I don't think that context's in the right place. You probably want "data SString a = Show a => Insecure a"
11:53:11 <LeCamarade> I know I am within inches of it, but ... I die there. 100 yards from MAry Inn.
11:53:22 <Cheery> hmm, not working that way
11:53:41 <Cheery> anyways, I came up with a thought how to manage input with this FRP
11:53:53 <dmhouse> Cheery: well, it'd have to be instance Monad ((,) w) to make the kinds work. And that's really what Writer is, but it's wrapped up in a data type.
11:53:54 <Cheery> maybe it's a way ppl meant it to be
11:54:34 <dmhouse> If you want a reason for _that_, then perhaps using Writer makes things more explicit, clearer and more readable?
11:54:35 <Cheery> dmhouse: yes, but I thought about doing a monad which is a 'tuple' handling two monads. :)
11:55:13 <LeCamarade> dmhouse: No. It doesn't work.
11:55:15 <Cheery> then you could 'lift left' and 'right'
11:55:22 <dmhouse> LeCamarade: what's the point of escape?
11:55:45 <LeCamarade> To make the string secure. But it doesn't archieve it, I know.
11:55:54 <dmhouse> LeCamarade: oh, that's a dummy for what will be the escaping function. :)
11:55:57 <LeCamarade> I mean, it is pointless, right now.
11:56:02 <LeCamarade> dmhouse: Yes.
11:57:02 <Cheery> ie, it'd be probably somthing like: TupleMonad ((ma,mb), a)
11:57:02 <dmhouse> LeCamarade: I'm having a look. Give me a minute.
11:57:07 <Cheery> oh wait
11:57:17 <LeCamarade> dmhouse: Sure.
11:57:26 * LeCamarade puts his heart to rest.
11:57:30 <dmhouse> LeCamarade: ah, you're suffering from the same problem that presents us from making Set a monad.
11:57:37 <Cheery> or hmm, I'm not sure
11:58:06 <Cheery> instead: TupleMonad (m1,m2) ,   return a = (return a, return a)
11:58:21 <allbery_b> hm.  on the other hand, I just rebuilt the last release with -O2 (while also adding profiling libs which I turned out not to need) and it's fast enough I no longer care
11:58:36 <LeCamarade> dmhouse: :oO
11:58:46 <dmhouse> The short answer is: there's no way to make it an instance of the standard Monad class.
11:58:50 <LeCamarade> I am only trying to do some simple monad.
11:59:23 <Cheery> not working yes
11:59:37 <dmhouse> LeCamarade: the reason is that instances of Monad have to be parametrised over _all_ types. E.g., you can have "Maybe a" for any "a". Yours are only parametrised over Show types, so, for example, SString (a -> b) would not be a legal type.
11:59:38 <LeCamarade> Okay, can you show me an example of a Monad that isn't that simplistic Maybe and List? I want something that is a bit like ... useful.
11:59:59 <monochrom> Control.Monad.RWS
12:00:12 <chessguy> State?
12:00:17 <monochrom> Actually I like Control.Monad.Cont more.
12:00:39 <LeCamarade> monochrom: For me? No. I don't want to be dons before I figure it out.
12:00:40 <LeCamarade> :oD
12:00:47 <monochrom> Control.Monad.Cont is useful, powerful, and far from simplistic.  May even take you a month to understand its implementation.
12:00:58 <chessguy> State is between Maybe/List and RWS/Cont in terms of difficulty
12:01:03 <dmhouse> It'll take you many months to fully appreciate how Cont works.
12:01:17 <dmhouse> Perhaps start with Reader. It's a bit easier to grok than State.
12:01:33 <monochrom> OK, it took me a month. Perhaps that means several months for other people.
12:01:37 <LeCamarade> chessguy: Okay, State, yeah, but ... that is simple. Or are Monads only that kind. The stuff I could replace with ... Maybe doesn't need monads. State is part of fold. I mean ...
12:01:50 * LeCamarade goes to check Reader.
12:03:30 <chessguy> Reader is simpler than state
12:03:33 <chessguy> by definition
12:03:58 <dmhouse> Yeah, Reader is the special case of State where you'll never be changing the state.
12:04:06 <tcr> Is there any naming convention for functions that are considered to be internal to another function, and should not be called directly? Similiarly to _foo vs. foo in C, or %foo vs. foo in Lisp, or foo0 vs. foo in Java &c
12:04:31 <dmhouse> tcr: make them part of a where block?
12:04:47 <tcr> dmhouse: Nah, I do want them to be used in several places.
12:05:09 <dmhouse> tcr: oh, then they're not really internal to another function, then, are they? :P
12:05:24 <tcr> dmhouse: for some meaning of internal, yes they are. :)
12:05:50 <procyon112> chessguy: I'm so messing up your code... I hope you don't mind that It looks nothing like what you have :/  You're going to have to do a review after I'm done and we'll come to a concensus.
12:05:53 <dmhouse> tcr: no, not really. You could just not export it from the module, and document it as being internal in the Haddock documentation.
12:06:10 <chessguy> procyon112: i'm sure it deserved to be messed up
12:06:36 <chessguy> procyon112: as long as i can comprehend it when you're done, i don't care
12:07:00 <davidL> has anyone here done problem 27 on project euler?
12:07:03 <tcr> dmhouse: Well, of course. Still I have to come up with a name for the function.
12:07:06 <Cheery> my code turned into an hideous 1.5MB executable
12:07:40 <SamB_XP> Cheery: let me guess... you tried to read the machine code?
12:07:44 <tcr> dmhouse: So I asked if there's already a convention out there, if not I can just choose one myself. :)
12:07:50 <monochrom> "Maybe doesn't need monads"?  I find it very hard to use Maybe if monads disallowed.
12:07:56 <dmhouse> tcr: fair enough. "No, not really." :)
12:08:12 <dmhouse> monochrom: really? I've barely ever used a Maybe do-block.
12:09:08 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example has an example.
12:09:19 <tcr> dmhouse: foo' vs. foo seems appropriate for Haskell, what's your opinion?
12:09:39 <dmhouse> tcr: yes, perhaps, but ' doesn't really carry the semantics of "internal function".
12:09:49 <dmhouse> But sure, if you need a way of marking it out as different, go for it.
12:10:22 <monochrom> I use meaningless single letters for internal functions (those under "where").
12:11:17 <monochrom> Is it a bad sign that I can remember certain haskellwiki articles? :)
12:11:30 <Cheery> SamB_XP: why it is so big?
12:11:32 <monochrom> Err remember the url of
12:11:34 <dcoutts_> monochrom: yes. next question?
12:11:45 <Cheery> my program is only about 150 lines of haskell
12:11:50 <SamB_XP> Cheery: statically linking the Haskell libraries
12:12:01 <Cheery> SamB_XP: how can I dynamically link them?
12:12:19 <SamB_XP> Cheery: you can wait until whatever version of GHC is going to actually support that
12:13:22 <SamB_XP> ... or you could do something like what lambdabot used to do
12:13:28 <SamB_XP> with hs-plugins
12:13:29 <syntaxfree> New post!
12:13:31 <syntaxfree> http://syntaxfree.wordpress.com/2007/05/04/lra/
12:13:34 <lambdabot> Title: Simple linear analysis of the performance of two algorithms.  Data.Syntaxfree
12:13:36 <syntaxfree> I'm back in town, baby! Yeah!
12:13:51 <dcoutts_> @yarr!
12:13:52 <lambdabot> Yeh scurvy dog...
12:14:15 <SamB_XP> except, without the plugin architecture to confuse matters...
12:14:32 <syntaxfree> I got to use some \LaTeX too :P
12:16:12 <dcoutts_> syntaxfree: nice article. dons and I were talking about a QuickBench tool that should automate that kind of thing.
12:16:43 <dcoutts_> syntaxfree: to do things like generating the random data, doing the timings, making those plots and regressions.
12:17:11 <dcoutts_> syntaxfree: would be quite handy for benchmarking & optimising etc
12:17:50 <dcoutts_> and use cairo for on-screen plots and generating png output for web pages and (e)ps output for papers etc :-)
13:08:35 <seliopou> question
13:08:40 <seliopou> how does one use ?check?
13:08:47 <seliopou> do you provide it a lambda expression?
13:09:46 <Lemmih> ?check \x -> not (null x) ==> sum x >= head (x::[Int])
13:09:47 <lambdabot>  Falsifiable, after 4 tests: [3,-1,-3]
13:16:44 * araujo throws a monad at shapr 
13:17:58 <DukeDave> Hey guys, what's it called when you use a function to access something in a class?
13:18:13 <araujo> A method?
13:18:41 <DukeDave> Mmm, I've done it before in Haskell, you can name the components of a class & access them by name..
13:19:11 <araujo> example .. ?
13:19:14 <DukeDave> e.g.      data Point = P Double Double
13:19:20 <DRMacIver> Are you talking about pattern matching?
13:19:31 <DukeDave> Then I have something          myPoint :: Point
13:19:36 <seliopou> record
13:19:37 <eumenides> records
13:19:44 <DukeDave> And I want to access the first Double by the name 'x'
13:19:50 <DukeDave> And the second by 'y'
13:19:53 <DRMacIver> You're talking about pattern matching.
13:19:53 <kpreid> DukeDave: I think you're looking for records.
13:19:57 <araujo> hah
13:20:04 <DukeDave> Roger, I'll Google :)
13:20:34 <DRMacIver> (But can also do this via records)
13:20:41 <araujo> func (P x y) ......
13:20:46 <seliopou> DukeDave, you want: data P = P {x :: Int, y :: Int}
13:20:49 <seliopou> I belive...
13:20:53 <araujo> that's pattern matching
13:21:10 <DRMacIver> Yes
13:22:22 <Cheery> http://img527.imageshack.us/img527/1461/example1uw2.png
13:28:53 <DRMacIver> Cheery: Cool
13:29:39 <Cheery> http://nehe.gamedev.net/lesson.asp?index=01 -> adding color
13:29:41 <lambdabot> Title: NeHe Productions: OpenGL Lessons
13:30:07 <dmhouse> DRMacIver: do you still blog? I think I lost the URL somewhere in the midst of time and/or my badly maintained and not backed-up Firefox bookmark manager.
13:31:54 <DRMacIver> The maths block is pretty much defunct.
13:32:03 <DRMacIver> In its place a new and mightier blog has arisen from the ashes.
13:32:23 <DRMacIver> Where by 'mightier' I mean 'just as rubbish really'
13:32:32 <DRMacIver> ( http://unenterprise.blogspot.com/ )
13:32:33 <lambdabot> Title: Desperately UnEnterprise
13:34:24 <glguy> ?seen shapr
13:34:25 <lambdabot> shapr is in #haskell. I don't know when shapr last spoke.
13:37:25 <dmhouse> DRMacIver: cool! :)
13:38:07 <matthew-_> in my best Chief Wiggum impression: "That's some nice ranting you got there DRMacIver" ;-P
13:38:57 <shapr> glguy: You screamt?
13:39:00 <DRMacIver> I'd been getting annoyed with LtU threads whining about type systems for the first, and Java weenies whining about how closures would complicate the pure and pristine beauty of Java for the second.
13:39:18 <DRMacIver> And as someone who works at a prospective employer, I refer you to the xkcd strip. :-p
13:39:28 <shapr> DRMacIver: Well, if you factor in cognitive dissonance, it's easy to understand their viewpoint.
13:39:44 <matthew-_> DRMacIver: fear not. Most of LShift reads xkcd ;)
13:39:48 <glguy> shapr: Now that I'm back from crazy town I need to get sorear's patches out to hpaste, do I need to talk to you to update happs? or could I build that locally
13:40:22 <DRMacIver> shapr: I have heard good arguments against first class functions in Java. They're wrong, but they're still good arguments.
13:40:30 <DRMacIver> shapr: I've also heard an awful lot of idiotic whining. :)
13:40:43 * glguy doesn't know if hpaste builds against 0.8.8 now or not
13:40:45 <shapr> glguy: Are you already using a local version of HAppS?
13:40:55 <glguy> shapr: I don't think I am, but I think I could
13:41:05 <glguy> has kakapo's version changed in the last month?
13:41:10 <shapr> DRMacIver: Yeah, but realize that no one thinks their viewpoint is idiotic :-)
13:41:16 <shapr> glguy: nope
13:41:18 <glguy> k
13:41:34 <shapr> glguy: I don't have time to update kakapo today, but I can probably do it tomorrow.
13:41:40 <glguy> shapr: no problem
13:41:45 <DRMacIver> shapr: That's ok. I'm the sole arbiter of truth, so their opinion of their viewpoint doesn't matter.
13:41:46 <matthew-_> I was reading Functional Programming with Overloading and Higher-Order Polymorphism by Mark P Jones today. I've read papers on Java, on MyType, virtual classes and all kinds of stuff. And nothing makes me think as hard as function papers like that one.
13:41:58 <glguy> shapr: that will give me a chance to make sure I know what hpaste compiles against
13:42:03 <monochrom> I am the Centre of the Universe.
13:42:13 <tcr> Do infix data constructors have a fixity, too?
13:42:16 <matthew-_> monochrom: I have the whiskey though...
13:42:24 * glguy has been continuously logged into #haskell since April 10 :)
13:42:24 <monochrom> Heh
13:43:36 <matthew-_> I was also writing some code today using phantom types and a whole load of GADT trickery, and a whole *five* minutes after writing it, I had to go back through it all again, line by line, to work out why it worked. I've /never/ had that in Java.
13:44:10 <chessguy> glguy!
13:44:14 <chessguy> welcome back!
13:44:16 <glguy> thnx
13:44:35 <glguy> That's cool that someone remembers me ;)
13:44:52 <monochrom> glguy: I want to take this opportunity to say: Long time no see!
13:45:06 <glguy> :-p
13:45:18 <chessguy> the ball and chain looks nice on you :)
13:45:35 <glguy> I'm not married until next weekend
13:45:43 <chessguy> oh!
13:45:44 <glguy> then I'll be gone again
13:45:48 <chessguy> i thought that's where you were all this time
13:46:05 <glguy> I'm just coming up for air before I go under again
13:46:14 <chessguy> haha
13:47:18 <glguy> @messages
13:47:18 <lambdabot> You don't have any new messages.
13:47:20 <glguy> :)
13:49:51 <dmhouse> That module's probably the most useful thing I've ever written in Haskell.
13:50:52 * dmhouse just runs out of ideas for things to hack on.
13:52:11 <procyon112> ?src forM
13:52:12 <lambdabot> forM = flip mapM
13:53:13 <dmhouse> ?type execState
13:53:19 <lambdabot> forall s a. State s a -> s -> s
13:57:18 <dcoutts> stepcut: mm, so we probably want to implement that haskell modular lazy search for the cabal-install dep resolution, the current impl is probably a bit too simple I think
13:58:33 <dcoutts> when I say we, I mean some cabal hacker
13:58:34 <dcoutts> which could be anyone of course!
13:59:44 <CosmicRay> I think we also need a hacker to re-implement git in Haskell, minus all the annoying bits.
13:59:58 <DRMacIver> git?
14:00:06 <CosmicRay> see git.or.cz
14:00:21 <DRMacIver> Ah
14:00:23 <matthew-_> just use monotone, not git! ;)
14:00:32 <CosmicRay> actually I use mercurial
14:00:46 <CosmicRay> I think the git storage format is better but the git interface is far, far, far worse
14:00:50 <matthew-_> well that's close enough...
14:00:59 <CosmicRay> git, imho, has the worst ui since cvs.
14:01:06 <Saizan> but we have darcs!
14:01:14 <CosmicRay> yes
14:01:16 <CosmicRay> we do.
14:01:17 <stepcut> but darcs is unreliable
14:01:26 <CosmicRay> but darcs has some known hanging bugs
14:01:31 <shapr> Because of the recursive merges?
14:01:33 <CosmicRay> and mercurial seems to be tons faster pushing and pulling
14:02:05 <stepcut> I have seen darcs hang (many times) on a 'darcs pull' when I have not modified my local repo at all :(
14:02:10 * ibid actually hasn't run into the hanging bugs yet
14:02:36 <kc5tja> CosmicRay: Isn't that called "darcs"?  :)
14:03:01 <CosmicRay> I also like the way that mercurial's merges both preserve the granularity of the original commits, *and* can also be viewed as one big commit with a custom commit message, so you know who merged and why
14:03:14 <stepcut> what I really need is a RCS similar to quilt, except (1) able to handle binary files (2) stores the revision history of patchset
14:03:21 <hpaste>  tcr pasted "Infix data constructors" at http://hpaste.org/1707
14:03:37 <matthew-_> the fact that item 1 on the darcs wiki faq is "why does it hang" does not inspire confidence
14:03:44 <kc5tja> I just watched Torvalds give a tech talk here about git, and he's tickled pink about git's UI.
14:03:46 <tcr> I must be missing something rather obvious, could anyone enlighten me on the error message, please?
14:03:57 <kc5tja> He absolutely loves it -- just wouldn't shut up over it.
14:04:13 <stepcut> kc5tja: well, he also thinks the Linux kernel is hot stuff ;)
14:04:26 <Heffalump> has anyone got some experience of profiling programs where higher-order combinators are likely to be the bottleneck?
14:04:32 <kc5tja> stepcut: Well, it *IS* a whole lot warmer than luke-warm.
14:05:02 <ibid> tcr: you have a nullary constructor called Int, which is totally different from the type name Int
14:05:05 <CosmicRay> kc5tja: yes, git's biggest strength, and its biggest weakness, is that linus is desperately in love with it
14:05:12 <tcr> ibid: duh
14:05:19 <dmhouse> What's the current status of cabal-install?
14:05:29 <matthew-_> CosmicRay: it does seem to have raised acceptance of DSCR which is a good thing
14:05:35 <matthew-_> err, DSCM rather
14:05:53 <Saizan> dmhouse: mostly just works
14:05:58 <CosmicRay> matthew-_: true
14:06:04 <Saizan> dmhouse: on linux at least
14:06:18 <dmhouse> Saizan: then why hasn't it hit a general release? Is it still being actively developed?
14:06:22 <ibid> tcr: i assume that means the problem is solved? :)
14:06:23 <CosmicRay> matthew-_: otoh it may have turned off just as many people, who may think that dscm systems are so much more complicated than svn
14:07:01 <tcr> ibid: Heh yeah... thank you! I sure need some sleep.
14:07:03 <matthew-_> CosmicRay: no, there's a lot of interest at the moment from what I can see in mercurial and bazaar and monotone etc. I think it's all good!
14:07:30 <Saizan> dmhouse: i think it needs some refinement and to be portable on windows without relying on things like tar
14:07:51 <matthew-_> CosmicRay: mozilla just switched to mercurial. two years ago, they would have switched to svn
14:08:15 <CosmicRay> matthew-_: yep, I read about that.
14:08:25 <CosmicRay> I am still disappointed in bzr.
14:08:39 <CosmicRay> it seems to be less robust than hg, and slower
14:09:29 <stepcut> CosmicRay: well, half the reason bzr was forked from tla is because tom lord thought their code was crap ;)
14:09:32 <matthew-_> CosmicRay: well, I'm not madly fussed about speed myself - I do use mtn afterall!
14:09:49 <CosmicRay> stepcut: yes, well tom lord thinks that any code that doesn't cause RSI is crap
14:09:52 <dmhouse> Argh, bazaar, what an annoying system.
14:10:01 <stepcut> CosmicRay: yes, that is the other half of the problem
14:10:20 <matthew-_> CosmicRay: solveable through switching to dvorak and expensive keyboards ;-)
14:10:50 <CosmicRay> matthew-_: in my experience, switching to dvorak is exteremly jarring to emacs and vi users, alas.
14:11:14 <matthew-_> CosmicRay: I'm both a vim and emacs user. Emacs switches easier than vim imho
14:11:25 <stepcut> matthew-_: no, even with dvorak, it still causes RSI :(
14:11:47 <CosmicRay> matthew-_: when I tried switching to dvorak, some 8 years ago, I was using emacs and the lack of handy C-x bugged me
14:12:04 <CosmicRay> matthew-_: I imagine that now with vim, the lack of hjkl would bug me
14:12:12 <dmhouse> CosmicRay: couldn't you just rebind the C-x keymap?
14:12:21 <stepcut> CosmicRay: even with caps lock == control ?
14:12:35 <matthew-_> CosmicRay: yeah - I guess if you're used to not moving to cursor keys, that would be a pita
14:12:45 <CosmicRay> yeah but that would just be confusing when trying to learn the thing (this button acts like x except when used with control...)
14:14:14 <stepcut> I don't have a problem with C-x, but only because I set my Caps Lock to be another Control key. Otherwise, it is pretty rough (for those playing along at home, try hitting cntl-b on your qwerty keyboard)
14:14:40 <emu> like this?
14:14:43 <emu> ;)
14:15:02 <matthew-_> you missed!
14:15:24 <matthew-_> stepcut: how bad is your rsi?
14:15:25 <emu> C-b starts "bold" mode in Irssi
14:15:40 <stepcut> matthew-_: none at all
14:15:55 <Cheery> cool
14:16:01 <matthew-_> I see! Just tom lord's code then?
14:16:07 <stepcut> matthew-_: yeah
14:16:37 <stepcut> matthew-_: it's more like RSI of the brain, trying to type those really long commands
14:16:54 <matthew-_> ahh, is there no helpful bash completion configuration?
14:17:19 <Cheery> Do you know a better for function like: getSystemInput :: a -> IO (SystemInputC a)
14:17:35 <Cheery> *better name
14:18:01 <Cheery> SystemInput is basically an event list
14:18:07 <stepcut> matthew-_: I had some pretty good pcomplete bindings, but still...
14:18:55 <Cheery> whole idea is to make the event list available as a boundable tuple, so that you could bend them into larger sets
14:19:07 <Cheery> then directly alter with FRP arrows
14:20:10 <Cheery> ie. lets say I'd like it to be the lowmost thing in my set, I'd do: getSystemInput ()
14:20:40 <Cheery> but if I'd like something for even more bottom, I'd do: getSystemInput something_even_more_primitive
14:20:56 <Cheery> well, I guess you'll get the idea
14:21:33 <Cheery> what should I call my event list coming from SDL, to make it the clearest that it's the only input you get from the SDL
14:21:38 <Cheery> ?
14:22:51 <LoganCapaldo> SDLEventList ?
14:26:36 <Saizan> ?where quickcheck
14:26:37 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
14:28:19 <chessguy> hi ski !
14:30:24 <Saizan> ?index IORef
14:30:25 <lambdabot> Data.IORef
14:30:41 <dmhouse> Grr. I'm in one of those moods where I want to hack on something but don't know what.
14:30:48 <dmhouse> I need to find a project that really interests me.
14:31:08 * LoganCapaldo has opposite problem
14:31:20 <LoganCapaldo> Must stop hacking to do real work.
14:32:26 <Heffalump> evening augustss
14:33:08 <Cheery> dmhouse: what would interest you?
14:36:32 <dmhouse> Cheery: that's the problem, I'm not really sure. I'm quite interested in processes, making things more efficient, which is why I've worked a bit on haskell-mode. I'm also interested in Haskell education. I rough web background, but I wouldn't regard that as necessarily more interesting than any other area, it just happens to be what I know about.
14:36:40 <dmhouse> I really want to work on something useful, I guess.
14:41:53 * notsmack tries to wrest control of X from metacity
14:42:03 <chessguy> here's something thought-provoking for you. over the last 6 months or so maybe, i've been job-shopping, and that's actually helped me a lot in defining what kinds of things interest me and what kinds don't. it just dawned on me during an interview last week that i really enjoy working on tools/libraries that will be re-used by other programmers more than end-user applications
14:42:24 <chessguy> hm, that probably got cut off
14:42:38 <int-e> "... more than  end-user applications"
14:42:42 <int-e> looked complete
14:42:45 <chessguy> ah, it didn't then
14:43:08 <dmhouse> I'd love to work on a library, but all the good ones have already been taken :)
14:43:14 <dmhouse> Okay. Which libraries suck?
14:43:40 <Saizan> dmhouse: you could fix cabal-install so that the -w options really installs the package for the specified compiler!
14:44:00 <Saizan> s/options/option/
14:47:33 * notsmack is in xmonad
14:47:45 <chessguy> dmhouse: i'd say HTTP, but i guess there's a SoC project for that one
14:49:04 <chessguy> dmhouse: there are probably other interesting web-based libraries that could use being done. you could always browse CPAN or other such places for ideas
14:49:16 <chessguy> perl's WWW:Mechanize would be fun
14:49:38 <dmhouse> ?google Haskell WWW::Mechanize
14:49:42 <lambdabot> http://www.altlinux.com/index.php?module=sisyphus&package=perl-Test-WWW-Mechanize
14:49:43 <lambdabot> Title: ALT Linux : information on package "perl-Test-WWW-Mechanize" in ALT Linux Sisyph ...
14:50:20 <dmhouse> I'm fairly sure that's already been done.
14:50:52 <chessguy> really? wow
14:51:23 <chessguy> hmm, there's http://hackage.haskell.org/trac/summer-of-code/ticket/1107 but it doesn't look like it got beyond proposal stage
14:51:24 <lambdabot> Title: #1107 (WWW::Mechanize-like package for Haskell) - Haskell.org Google Summer of C ...
14:51:46 <dmhouse> Oh, maybe that's what I'm thinking of.
14:52:59 <chessguy> there's also HTML::TreeBuilder, which could be useful
14:53:25 <chessguy> (IMHO, a more correct approach to such things than ndm's tagsoup)
14:54:44 <chessguy> anyway, there are TONs of cool libraries on cpan
14:58:35 <shapr> dmhouse: What a short tutorial program that uses HaskellNet to fetch email via IMAP and send via POP3?
14:59:12 <chessguy> HaskellNet? is that Haskell's beta-version of Skynet?
14:59:16 <chessguy> ?where haskellnet
14:59:17 <lambdabot> I know nothing about haskellnet.
14:59:51 <shapr> @go haskellnet soc
14:59:54 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
14:59:54 <lambdabot> Title: Index of /SoC/haskellnet
15:00:13 <dmhouse> Ooh, now _there's_ an idea! An MDA. I've wanted an easy way to read my mail locally for ages, and fetchmail and buddies are a real pain to configure.
15:00:39 <chessguy> wheeee
15:09:10 <dmwit> So, is anyone interested in the solution to the CFG problem I asked about earlier?
15:31:25 <dmhouse> What does the following mean when I try to do runhaskell Setup.hs install on a built package? Setup.hs: Error: Could not find module: Text.IMAPParsers with any suffix: ["hi"]
15:34:07 <dcoutts> dmhouse: it couldn't find dist/build/Text/IMAPParsers.hi
15:34:18 <drigz> did anyone read that trivial monad article?
15:34:20 <dmhouse> dcoutts: what do I do?
15:34:22 <dmhouse> drigz: yeah
15:34:27 <drigz> i'm not finding it particularly trivial :s
15:34:45 <dmhouse> :) I thought it was a pretty good explanation, as explanations go.
15:34:47 <dcoutts> dmhouse: and you've tried to clean, configure, build and install ?
15:34:51 <dmhouse> Dan's a great writer.
15:34:51 <drigz> i managed exercise one, but i'm struggling with two
15:34:59 <int-e_> it's the Id monad. It's the second most simple monad in my opinion.
15:35:04 <dmwit> Which one is excercise two?
15:35:05 <dcoutts> dmhouse: I mean is it repeatable?
15:35:05 <ddarius> I didn't care for it.
15:35:12 <Heffalump> int-e_: so what's the simplest?
15:35:24 <dmhouse> dcoutts: give me a minute, I'll try.
15:35:24 <drigz> h (W a) (W b) = W (a+b)
15:35:25 <int-e_> data Null a = Null with the obvious instance
15:35:39 <Heffalump> I would say that id is a simpler function than const
15:36:10 <drigz> i'd prefer a hint to being told the answer
15:36:13 <ddarius> int-e_: That is a monad, but that is not a 'notion of computation' a la Moggi (which does not invalidate it...)
15:36:15 <drigz> i'm just not so sure how to approach this
15:36:45 <int-e> ddarius: it's an unobservable computation.
15:37:17 <ddarius> int-e: No, formally it is not a 'notion of computation' because return for it is not monomorphic.
15:37:19 <dmhouse> drigz: what exactly do you have to do with h?
15:37:40 <drigz> dmhouse: find a definition that doesn't use unwrapping, just uses >>=, fmap and return
15:37:59 <ddarius> drigz: You know how to use monads in Haskell?
15:38:18 <drigz> ddarius: no
15:38:39 <dmhouse> drigz: right. How can you 'get at' the value within the monadic wrapper?
15:38:40 <drigz> ddarius: well, other than what i learnt from this article, pretty much
15:38:43 <ddarius> drigz: Hmm, do you know how do-notation maps to uses of (>>=)?
15:38:58 <drigz> ddarius: i know it does but not how
15:39:13 <dmhouse> ddarius: do-notation wasn't explained in that article, you don't need it and it's not really in the spirit of the problem :)
15:39:29 <drigz> http://sigfpe.blogspot.com/2007/04/trivial-monad.html if you haven't seen it
15:39:30 <lambdabot> Title: A Neighborhood of Infinity: The Trivial Monad
15:39:36 <dmhouse> drigz: how about my question?
15:39:53 <drigz> dmhouse: with the fmap and bind i guess
15:39:54 <ddarius> dmhouse: You don't need it, but I do believe it is the spirit of the problem or perhaps what the spirit should be.
15:40:31 <ddarius> dmhouse: And I have read it, and don't much care for it.
15:40:52 <dmhouse> drigz: well, fmap lets you modify the value, but bind actually lets you get at it. E.g. m >>= \a -> ..., a is the value within m.
15:40:54 <drigz> i know that you can 'modify' it by doing fmap (modify)
15:41:39 <dmhouse> dcoutts: aha! build errored before it completed, so the build wasn't complete.
15:41:55 <dmhouse> shapr: ping, do you know anything about HaskellNet or have you just used it?
15:43:27 <dmhouse> drigz: does that help at all?
15:43:42 <drigz> dmhouse: i don't know, i'm trying
15:44:04 <drigz> fmap and bind seem so unary
15:44:29 <dmhouse> Well, use them more than once :)
15:44:44 <ddarius> drigz: All functions in Haskell are unary.  This is somewhat relevant to your problem.
15:44:47 <Botje> :t (>>=) . (>>=)
15:44:49 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m a -> (m b1 -> (a -> m b1) -> b) -> (a -> m b1) -> b
15:44:55 <drigz> i may nearly be there
15:44:58 <dmhouse> You need to get at the values within both the wrapped (monadic) values.
15:45:04 <drigz> and am trying not to look at what botje just psoted :p
15:45:21 <ddarius> Botje is posting craziness.
15:45:30 <dmhouse> It won't help much, it's a horrendously looking type that doesn't seem to correspond that closely to a solution.
15:45:32 <dmhouse> :)
15:45:34 <Botje> you can never have enough craziness.
15:45:43 <ddarius> Indeed.
15:45:43 <dmhouse> Correct. And with a view to that:
15:45:51 <dmhouse> :t (>>=) . (>>=) . (>>=)
15:45:53 <lambdabot> forall b b1 (m :: * -> *) a b2. (Monad m) => m a -> (((a -> m b2) -> b1) -> (m b2 -> (a -> m b2) -> b1) -> b) -> (m b2 -> (a -> m b2) -> b1) -> b
15:45:58 <Botje> I wasn't aware there was a monad question up in the air, i just watned to know the type of that expression
15:49:16 <ddarius> :t fix (>>= .)
15:49:19 <lambdabot> parse error on input `.'
15:49:34 <ddarius> :t fix ((>>=) .)
15:49:36 <lambdabot>     Occurs check: cannot construct the infinite type:
15:49:36 <lambdabot>       m = (->) (a -> m b)
15:55:24 <chessguy> hi haskellers
15:56:28 <drigz> i think i worked it out but i don't think i took the most admirable route...
15:56:51 <drigz> i just screwed around with types like algebra and :type until i got a right looking answer
15:57:52 <ddarius> Which is exactly what I thought would happen from the way it is presented.
15:58:15 <quicksilver> @seen CosmicRay
15:58:16 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
15:58:34 <drigz> my answer looks like the kind of thing you would expect from @pl
15:59:10 <drigz> i got bind . (flip (fmap . (+)))
15:59:10 <sorear> hello.
15:59:10 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:59:10 <CosmicRay> hi, I have just a minute
15:59:10 <sorear> @messages'
15:59:10 <sjanssen> greetings
15:59:10 <lambdabot> Maybe you meant: messages messages?
15:59:10 <ddarius> :t (>>=) . flip (fmap . (+))
15:59:10 <sorear> @messages
15:59:10 <dmhouse> drigz: do you want the 'real' answer?
15:59:10 <lambdabot> dcoutts said 14h 21m 24s ago: I'd rather just fix it than add FAQs
15:59:10 <lambdabot> forall b (f :: * -> *) a. (Functor f, Num a) => f a -> (f a -> a -> b) -> a -> b
15:59:27 <drigz> :t (flip (>>=)) . flip (fmap . (+))
15:59:30 <lambdabot> forall (f :: * -> *) a. (Monad f, Functor f, Num a) => f a -> f a -> f a
15:59:39 <drigz> dmhouse: hit me
15:59:56 <ddarius> liftM2 (+)
16:00:14 <dmhouse> drigz: h m n = m >>= \x -> n >>= \y -> return (x + y)
16:00:38 <ddarius> Or in do notation, h m n = do x <- m; y <- n; return (x+y)
16:00:44 <ddarius> @src liftM2
16:00:45 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:01:22 <drigz> @pl \m n -> m >>= \x -> n >>= \y -> return (x+y)
16:01:22 <lambdabot> liftM2 (+)
16:01:32 <drigz> grr
16:01:39 <dmhouse> drigz: you use >>= to extract the values from their monadic wrapping, do your processing with the values (the x + y bit), then rewrap (with return).
16:03:03 <drigz> dmhouse: ok, that makes sense
16:03:58 <drigz> :t bind (\x -> bind (\y -> return (x+y)))
16:04:01 <lambdabot> Not in scope: `bind'
16:04:01 <lambdabot>  
16:04:01 <lambdabot> <interactive>:1:12: Not in scope: `bind'
16:04:15 <drigz> :t let bind = flip (>>=) in bind (\x -> bind (\y -> return (x+y)))
16:04:17 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
16:04:17 <lambdabot>     Probable cause: `bind' is applied to too few arguments
16:05:02 <dmhouse> drigz: remember you need you pass a wrapped value to bind too (and that bind is called (>>=) in real Haskell).
16:06:47 <LoganCapaldo> :t flip (>>=)
16:06:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
16:06:51 <LoganCapaldo> :t (=<<)
16:06:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:08:31 <drigz> @type (=<<) (\x -> (=<<) (\y -> return (x+y)))
16:08:34 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => (m a -> a) -> m a -> m a
16:08:38 <drigz> @type (=<<) (\x -> (=<<) (\y -> return (x+y)))
16:08:40 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => (m a -> a) -> m a -> m a
16:08:55 <drigz> @type \m n -> m >>= (\x -> n >>= (\y -> return (x+y)))
16:08:58 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => m a -> m a -> m a
16:09:05 <drigz> i can't see why those two have different types
16:09:51 <ddarius> :t (=<<) (return . (1+))
16:09:53 <lambdabot> forall b (m :: * -> *). (Num b, Monad m) => m b -> m b
16:10:04 <sorear> grr, where's mnislaih when I have karma for her? :)
16:10:38 <ddarius> Achieving nirvana
16:11:41 <ddarius> :t \x -> (=<<) (return . (1+))
16:11:43 <lambdabot> forall t b (m :: * -> *). (Num b, Monad m) => t -> m b -> m b
16:11:48 <ddarius> :t \x -> (=<<) (return . (x+))
16:11:51 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => a -> m a -> m a
16:12:21 <sorear> So should I release this binary search program I just wrote?
16:12:34 <sorear> it's only 33 lines and all that
16:12:39 <ddarius> sorear: Elaborate.
16:12:45 <monochrom> 33 is a lot.
16:12:50 <sorear> ddarius: it's a binary search program
16:12:58 <sorear> stefan@stefans:~/bsearch$ bsearch Ana /usr/share/dict/words
16:12:58 <sorear> Anabel
16:13:03 <sorear> *instantaneously*
16:13:19 <LoganCapaldo> I wrote isInfixOf today. I'm pretty sure its O(m + n)
16:13:36 <LoganCapaldo> Should I release that?
16:13:42 <sorear> LoganCapaldo.isInfixOf "aaaaaaaaaaaab" "aaaaaaaaaaaaaaaaaaaaaaaaaa"
16:13:47 * LoganCapaldo checks # of lines
16:13:47 <sorear> eh?
16:14:37 <LoganCapaldo> did you want me to time it?
16:14:40 <LoganCapaldo> or what?
16:14:52 <LoganCapaldo> it was too fast for ballpark "Oh crap its slow"
16:14:58 <sorear> LoganCapaldo: I actually needed a binary search program.  I'm sure you wrote isInfixOf just because coding is fun.
16:15:04 <LoganCapaldo> lol
16:15:06 <LoganCapaldo> probably
16:15:21 <sorear> LoganCapaldo: yeah, time it for long values of both strings
16:15:24 <LoganCapaldo> Aaaaan it's 27 lines
16:15:36 <sorear> LoganCapaldo: I gave you the worst case for naive code
16:15:40 <sorear> @src isInfixOf
16:15:41 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
16:15:51 <sorear> 1 line
16:15:59 <LoganCapaldo> heh
16:16:35 <sorear> So, is it likely anyone else needs binary search on the command line?
16:17:16 <LoganCapaldo> sorear: seems like something that should have been in the unix toolbox from the get go.
16:17:58 <hpaste>  LoganCapaldo pasted "isInfixOf (warning, identifier choices may offend)" at http://hpaste.org/1709
16:18:45 <monochrom> I don't need binary search on the command line. But if it's haskell, I want to know how you got that speed.
16:19:17 <ddarius> LoganCapaldo: Why not type Optimistic a = Either a a
16:19:19 <sjanssen> LoganCapaldo: I think optimisticFoldl is actually foldM in the Either Monad
16:19:29 <monochrom> For the purpose of playing The Eleventh Hour I need anagram search instead. :)
16:19:32 <LoganCapaldo> Oh goody
16:19:34 <sorear> monochrom: really really easily
16:19:47 <sorear> monochrom: and I can search a 100MB file just as instantly
16:20:01 <sorear> within the bounds of perception
16:20:18 <sorear> monochrom: this is, after all, an O(log n) algorithm!!
16:20:19 <LoganCapaldo> So how do I time this sucker? is there a Debug.Benchmark or something I can import?
16:20:28 * ddarius doesn't think he ever played the Eleventh Hour.  Seventh Guest yes.
16:20:40 <monochrom> Do you slurp the dict into an array, then bsearch over it?
16:20:54 <sorear> monochrom: No.  I binary search it in place.
16:21:01 <ddarius> Random access the file.
16:21:05 <sorear> monochrom: My text file is sorted as a precondition
16:21:05 <monochrom> How to do that in Haskell?
16:21:11 <sorear> hSeek!
16:21:13 <sjanssen> @hoogle hSeek
16:21:14 <lambdabot> IO.hSeek :: Handle -> SeekMode -> Integer -> IO ()
16:21:26 <LoganCapaldo> hSeek and ye shall hFind
16:21:38 <sjanssen> this would be even easier if ByteString still had mmapFile
16:21:38 <sorear> you seriously thought haskell couldn't do random access IO?  I sense a misunderstanding.
16:21:40 <monochrom> But how do you "seek to a line" instead of "seek to a byte position"?
16:21:48 <sorear> monochrom: I don't
16:21:53 <int-e> LoganCapaldo: try isInfixOf "aab" "aaab"
16:21:56 <sorear> monochrom: I seek to byte position
16:22:04 <sjanssen> monochrom: you can always seek backwards/forwards to a newline
16:22:52 <LoganCapaldo> int-e: you're a clever one
16:23:04 <monochrom> So, seek to a character position. This is somewhere in the middle of a line. I want to find the beginning of that line. Do I do a linear search backwards?
16:23:08 <LoganCapaldo> Now how did I screw this up?
16:23:12 <ddarius> hSeek ... >> hGetLine ... >> hTell
16:23:17 <sorear> monochrom: Yes.
16:23:19 <LoganCapaldo> because its deterministic that's how I screwed it up
16:23:22 <int-e> LoganCapaldo: if you continue on this way you'll probably reinvent the KMP algorithm.
16:23:36 <sorear> monochrom: Actually a linear search forward with a special case to make it work, but same principle.
16:23:39 <LoganCapaldo> int-e: Sounds fun :)
16:24:00 <sorear> monochrom: my motivating input is 8 million lines of 15 chars each, so linear doens't hurt at all
16:24:04 <LoganCapaldo> dinner
16:24:13 <LoganCapaldo> I'll isInfixOf you guys later
16:24:14 <monochrom> Yes, I understand that.
16:24:23 <ddarius> Presumably they aren't 15 chars each.
16:24:30 <sorear> ddarius: it's an average
16:24:40 <ddarius> Precisely.
16:26:40 <ddarius> *sigh* I should download and install a C++ compiler so I can rebuild my full-text database and software.
16:28:19 <ddarius> 8 million lines ... hmm
16:29:59 <ddarius> sorear: What are you bsearching?
16:31:55 <sorear> ddarius: a wikipedia database dump
16:32:32 <ddarius> What do the entries look like?
16:32:48 <sorear> the apt-file database will probably get the same treatment, I'd use it more often if it didn't take five minutes a run
16:33:05 <sorear> after grep and sed, Cyclic group|536089906
16:33:35 <ddarius> And the number is?
16:33:48 <sorear> Offset into the original file.
16:33:55 <ddarius> Ah.
16:34:17 <sorear> I'm pretty sure what I've done is reinvent database indices :)
16:34:35 <ddarius> Simple ones.
16:35:12 <ddarius> So, the number is an offset into a file containing the whole article (among all others) or what?
16:36:23 <sorear> yes.
16:36:44 <ddarius> Are you just doing this to have it be offline?
16:37:34 <sorear> yes.
16:38:06 <ddarius> Okay.
16:39:20 * ddarius considers enticing sorear into implementing a next-word inverse index so he can search it a la Googling 'site:wikipedia.com "Cyclic group"' and get -all- articles mentioning the phrase "cyclic group".
16:44:17 <ddarius> Heh.  My query program binary searches the word lexicon.
16:44:45 <ddarius> (My entries, however, are quite a bit more involved.
16:44:46 <ddarius> )
16:47:40 <LoganCapaldo> Where is Either monadified?
16:47:48 * Saizan feels bad about hacking Data.Set to get O(log n) indexing of elements
16:48:10 <Saizan> ?docs Control.Monad.Error
16:48:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
16:48:50 <LoganCapaldo> Bah
16:49:04 <LoganCapaldo> Not that, thanks Saizan
16:49:28 <LoganCapaldo> @instances Error
16:49:33 <lambdabot> IOError, [Char]
16:49:38 <LoganCapaldo> mmm
16:51:06 <Saizan> instance (Error e) => Monad (Either e) -- Defined in Control.Monad.Error
16:51:17 <LoganCapaldo> No no :)
16:51:24 <LoganCapaldo> I was saying "Left []"
16:51:47 <LoganCapaldo> I'm using failure for success :)
16:52:23 <Saizan> but you are using it to quit the computation
16:52:42 <LoganCapaldo> yep
16:52:43 <Saizan> i suppose you could just instance Error with what you need
16:52:49 <LoganCapaldo> but [] was [a]
16:53:00 <LoganCapaldo> I just used "", lazy
16:55:34 <ddarius> Stupid fail.
16:56:50 <chessguy> so, if you try to succeed and fail, what did you do?
16:56:58 <chessguy> uh
16:57:06 <chessguy> ok, i totally screwed up that joke
16:57:18 * chessguy goes off to crawl into a hole somewhere
16:57:19 <monochrom> Haha
16:57:39 <hpaste>  LoganCapaldo annotated "isInfixOf (warning, identifier choices may offend)" with "Still not correct, but more monady" at http://hpaste.org/1709#a1
16:57:51 <chessguy> it was supposed to be "if you try to fail and succeed, what did you do?"
16:58:15 <Wild_Cat> everything I say is a lie.
16:58:48 <LoganCapaldo> foldM++
16:58:54 <LoganCapaldo> @karma foldM
16:58:54 <lambdabot> foldM has a karma of 1
16:59:50 <ddarius> The case can, ironically, be replaced with 'either null null'
17:00:20 <LoganCapaldo> That is ironic
17:00:46 <ddarius> If you never actually use the Left to hold anything, you can replace the use of Either with Maybe.
17:02:01 <LoganCapaldo> Yeah
17:02:35 <LoganCapaldo> I was thinking that
17:02:35 <LoganCapaldo> :t maybe
17:03:02 <ddarius> That would be a lot cleaner, and then the case becomes 'maybe True null' which is less quirkiness dependent.
17:03:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:03:41 <chessguy> ?src maybe
17:03:42 <lambdabot> maybe n _ Nothing  = n
17:03:42 <lambdabot> maybe _ f (Just x) = f x
17:03:58 <chessguy> oh, that's right
17:04:43 <LoganCapaldo> wow
17:04:51 <LoganCapaldo> its the incredible shrinking function
17:05:00 <chessguy> @quote melt
17:05:00 <lambdabot> dons says:  its like you can really see the guy's brain melting
17:05:11 <chessguy> ok, not what i was looking for
17:05:14 <chessguy> @quote fashion
17:05:15 <lambdabot> No quotes match. You type like i drive.
17:05:18 <chessguy> @quote melt
17:05:19 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
17:05:22 <chessguy> there we go
17:06:51 <ehird`> is haskell's lazyness just achived by "everything's a function" or is there more to it than that?
17:07:03 <chessguy> there's more to it than that
17:07:20 * chessguy crosses his fingers:
17:07:24 <chessguy> ?wiki Lazy_Evaluation
17:07:25 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_Evaluation
17:07:34 <ehird`> nope
17:07:49 <ehird`> ?wiki Lazy_evaluation
17:07:50 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_evaluation
17:07:55 <chessguy> i was close
17:08:00 <ehird`> nope, too
17:08:03 <chessguy> http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
17:08:05 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
17:08:10 <ddarius> Hmm, you can replace the two branches with one and an irrefutable match.
17:08:43 <LoganCapaldo> ddarius: Yeah i tried to do that before, I could't figure out how to say needle@~(a:as) in a way it liked
17:08:49 <ddarius> (Or alternatively use head and tail rather than an irrefutable match as I would probably do.
17:08:57 <ddarius> Probably extra parens
17:09:22 <ddarius> > let f a@(~(x:xs)) = x in f x
17:09:23 <lambdabot>   Not in scope: `x'
17:09:28 <ddarius> > let f a@(~(x:xs)) = x in f "ab"
17:09:29 <lambdabot>  'a'
17:09:39 <LoganCapaldo> ok
17:10:24 <ddarius> You get isInfixOf needle@(~(n:ns)) = null needle && (maybe True null $ foldM ...)
17:10:47 <ddarius> Er s/&&/||
17:10:56 <LoganCapaldo> I didn't bother with null needle
17:11:17 <LoganCapaldo> since the foldM is immediately gonna get Nothing
17:11:30 <ehird`> Hmm haskell seems to optimize away recursive calls
17:11:33 <ehird`> How does it do that?
17:11:46 <hpaste>  LoganCapaldo annotated "isInfixOf (warning, identifier choices may offend)" with "Shrinking" at http://hpaste.org/1709#a2
17:12:11 <ddarius> LoganCapaldo: True.
17:12:43 <ddarius> ehird`: What do you mean?
17:12:50 <drigz> ehird`: which recursive calls?
17:12:57 <ehird`> drigz: Well, any recursive function.
17:12:58 <chessguy> ehird`: first of all, haskell doesn't "do" anything
17:13:03 <ehird`> The stack never seems to overflow
17:13:07 <drigz> do you mean tail recursion?
17:13:19 <ehird`> drigz: nope, not with tail recursion
17:13:24 <emu> what are you doing to try to make it overflow
17:13:26 <ehird`> since it does something with the result
17:13:28 <ehird`> emu: i'm not
17:13:34 <drigz> ehird`: what code?
17:13:42 <ehird`> drigz: various recursive functions
17:13:45 <emu> laziness helps a lot, only compute what is necessary
17:13:47 <ehird`> i just noted that it never seems to, so it must be optimizing it
17:14:06 <ddarius> LoganCapaldo: You can make go a one-liner, but it's kind of ugly.
17:14:06 <drigz> ehird`: i think there are flags you can use to see how it optimises
17:14:26 <ddarius> @oldwiki StackOverflow
17:14:26 <lambdabot> http://www.haskell.org/hawiki/StackOverflow
17:14:45 <LoganCapaldo> ddarius: that's a little too much I think. Also I need to figure out how to deal with "aab" "aaab"
17:14:49 <ddarius> ehird`: In certain cases, the function is not actually recursive.
17:15:08 <ehird`> ddarius: I was doing the simple fac n = if n == 0 then 1 else n * fac (n-1)
17:15:13 <ehird`> which isn't tail recursive.
17:15:27 <ddarius> ehird`: And Haskell will overflow on that.
17:15:35 <ddarius> Unless you have a weird instance of Num.
17:15:47 <ehird`> I'm handing it continously larger numbers and it isn't overflowing.
17:15:58 <ddarius> Hmm, Integer might be lazy too.
17:16:00 <emu> > let nfac n = if n == 0 then 1 else n * nfac (n-1) in nfac 10^10
17:16:02 <lambdabot>  395940866122425193243875570782668457763038822400000000000000000000
17:16:05 <emu> > let nfac n = if n == 0 then 1 else n * nfac (n-1) in nfac 10^100
17:16:06 <lambdabot>  9468981927959600839432476822138015871317739921581874932436951555097892359178...
17:16:14 <mauke> > let nfac n = if n == 0 then 1 else n * nfac (n-1) in nfac (10^10)
17:16:18 <lambdabot>  Exception: stack overflow
17:16:30 <emu> aye
17:16:32 <emu> silly me
17:16:37 <mauke> > let nfac n = if n == 0 then 1 else n * nfac (n-1) in nfac 1e9
17:16:39 <lambdabot>  Exception: stack overflow
17:16:57 <ehird`> yeah, that happens
17:17:04 <ehird`> it just takes an awful long time to overflow  then
17:17:10 <drigz> ehird`: use
17:17:12 <drigz> oops
17:17:31 <drigz> use +RTS -K1K if it's taking too long
17:17:43 <drigz> that might be a bit small
17:17:43 <ehird`> just experimenting :P
17:18:02 <ehird`> ghci +RTS -K1K immediately overflows, hehe!
17:26:21 <mdmkolbe|home> @type 1
17:26:24 <lambdabot> forall t. (Num t) => t
17:26:36 <ddarius> go ~(a:as) b = msum $ map (\(p,xs) -> guard (not (null as) && p) >> return xs) [(a==b,as),(n==b,ns),(True,needle)]
17:26:42 <ddarius> I'm sure I can do better.
17:27:42 <mdmkolbe|home> ddarius: what is the problem being solved?
17:28:33 <ddarius> http://hpaste.org/1709#a2 Making this smaller for the heck of it.
17:28:39 <ddarius> Correctness be damned!
17:31:55 <mdmkolbe|home> ddarius: is this trying to figure out if one string is a substring of another?
17:32:30 <ddarius> mdmkolbe|home: Efficiently, yes.  Note that LoganCapaldo is the one writing the function.
17:32:49 <hpaste>  LoganCapaldo annotated "isInfixOf (warning, identifier choices may offend)" with "Well it'scorrect now, afaik but I think its not so fast anymore" at http://hpaste.org/1709#a3
17:33:22 * mdmkolbe|home begins meditating on the nature of the problem
17:34:25 <LoganCapaldo> I think that might be the first time I used the list monad  "for real"
17:36:50 <mdmkolbe|home> I think it should be able to be done in linear time.  What is the current algorithms performance? (it's so small as to be inscrutible to me)
17:36:59 <LoganCapaldo> yep
17:37:02 <LoganCapaldo> I broke it
17:37:10 <LoganCapaldo> the latest version is equivalent to the naive one
17:37:18 <LoganCapaldo> but written funnier looking :)
17:37:32 <LoganCapaldo> actually it might be ever so slightly better than the naive one
17:37:33 <sorear> mdmkolbe|home: it can definitely be done in linear time, since grep is linear time!
17:37:54 <monochrom> cf. the KMP algorithm
17:38:10 * LoganCapaldo doesn't want to peek
17:38:34 <monochrom> I know. I'm telling mdmkolbe|home.
17:38:34 <LoganCapaldo> I'm thinking I need to make my fsm more explicitly. ick
17:38:47 <monochrom> heh
17:39:25 <mdmkolbe|home> monochrom: is KMP lazy matrix exploration? (I'm thinking along those ideas)
17:39:41 <sorear> mdmkolbe|home: No. (iirc)
17:40:06 <sorear> mdmkolbe|home: IIRC KMP is a specialized (constant factor faster) version of the Thompsonian DFA-grep
17:40:57 <mdmkolbe|home> sorear: does it blow up withen the string being searched for is about (or maybe half) the size of the string being searched in?
17:41:40 <sorear> mdmkolbe|home: no, it's a simple O(lenneedle^2 + lenhaystack) or similar
17:42:09 <sorear> mdmkolbe|home: my editor of choice crashes on a >128 character needle, so ... :)
17:43:03 <mdmkolbe|home> sorear: hmm, for grep that's fine.  But I wonder if there is a O(lenneedle + lenhaystack)
17:43:34 <LoganCapaldo> I see what's wrong with my original
17:43:44 <LoganCapaldo> I tried to cheat too much
17:43:54 <sorear> mdmkolbe|home: it can certainly be done in O(lenneedle + lenhaystack * log lenhaystack)
17:44:12 * mdmkolbe|home does more meditation but still can't descide whether the problem has Buddha nature
17:44:37 <sorear> mdmkolbe|home: interestingly, the second term is not data-dependant on the needle, so you can precompute a structure allowing O(lenneedle) searching
17:45:01 <mdmkolbe|home> sorear: is it dependant on the haystack?
17:45:19 <sorear> Yes.
17:50:26 <mdmkolbe|home> sorear: I want to think about this problem, but in case I don't come up with anything, could you maybe paste the answer (so I can look at it later)?
17:50:49 <sorear> mdmkolbe|home: i remember the url
17:52:04 <sorear> (should I give it? the url is spoily)
17:52:39 <LoganCapaldo> eureka. I misconstructed my fsm
17:52:41 <hpaste>  int-e pasted "functional kmp" at http://hpaste.org/1710
17:53:00 <LoganCapaldo> but now I can't use just a plain old list anymore
17:53:01 <mdmkolbe|home> sorear: sure if LoganCapaldo doesn't mind
17:53:24 <LoganCapaldo> tinyurl it? I don't see how much of a spoiler a url can be
17:53:24 <sorear> there, no worries :)
17:53:29 <LoganCapaldo> heh
17:53:36 <mdmkolbe|home> LoganCapaldo: he msged it
17:55:04 <int-e> there that's O(n+m) (n=length(needle), m=length(haystack))
17:57:15 <sorear> int-e: are you sure it's linear in the needle length?
17:57:25 <int-e> sorear: yes.
17:57:28 <sorear> looks at least quadradic to me
17:58:04 <int-e> sorear: for every step backwards (iteration of skip), there must have been a step forward earlier (iteration of phase1 or phase2)
17:58:26 <int-e> sorear: that's the basic reasoning behind the kmp algorithm's complexity.
18:08:28 <ddarius> Let A be a subcategory of B and b an object of b, then r:b->a is an A-reflection of b if forall f:b -> a' there exists a unique f':a -> a' such that r;f'=f.  Quickly now, reword that using representability and then using an adjunction (assuming the construction is natural in b for the latter).
18:08:45 <ddarius> s/an object of b/an object of B
18:09:01 <mdmkolbe|home> sorear: yeah, that technique is how the OED used to do it's searching
18:09:19 <mdmkolbe|home> that technique == the one you msg'ed me
18:11:23 * chessguy gets a straitjacket for ddarius
18:12:27 <int-e> sorear: and the recursive call of optimize in optimize is actually superfluous; that backlink has already been optimized by an earlier call.
18:12:46 <mdmkolbe|home> ddarius: r;f' = f === r.f' = f?
18:13:11 <ddarius> You mean f' . r = f, then yes.
18:14:37 <kpreid> Is there a name for something like a monoid without associativity?
18:15:05 <mdmkolbe|home> kpreid: functor, arrow, applicative?
18:15:16 <ddarius> magma with unit
18:15:57 <mdmkolbe|home> @go magma
18:16:00 <lambdabot> http://www1.magma.ca/
18:16:00 <lambdabot> Title: Magma Communications
18:16:07 <ddarius> @google magma "abstract algebra"
18:16:14 <lambdabot> http://web.usna.navy.mil/~wdj/book/
18:16:14 <lambdabot> Title: Applied Abstract Algebra
18:17:14 <ddarius> http://en.wikipedia.org/wiki/Magma_%28algebra%29
18:17:15 <lambdabot> Title: Magma (algebra) - Wikipedia, the free encyclopedia
18:18:17 <ddarius> A unital magma according to that page.
18:18:37 <mdmkolbe|home> awsome diagram on that page
18:18:38 <kpreid> Aha, thanks.
18:19:26 <ddarius> kpreid: That said, if you are trying to communicate, most people are going to be like "magma? wtf?".  So it may be best just to expand the definition.
18:20:02 <kpreid> I'm not sure what I'm doing yet.
18:22:14 <araujo> hello
18:22:20 <mdmkolbe|home> ddarius: I *really* like that diagram.  Have you seen anything like it but for other things, e.g. Rings, etc.?  I never did "get" group theory mostly b/c I could never keep the relationships and properties of group, semi-group, etc in my head
18:23:28 <ddarius> I probably have, but I wouldn't be able to point you to it.  It would be easy enough to make one by trawling around e.g. wikipedia.
18:23:40 <ddarius> The graph is probably not planar though.
18:24:27 <mdmkolbe|home> ddarius: true, but something like the complexity zoo for category theory would be nice
18:24:55 <mdmkolbe|home> I hope I'm not incorrect to conflate category theory with group theory
18:25:40 <ddarius> They're related in many ways, but far from identical.
18:25:52 <ddarius> Category theory can be viewed from many perspectives.
18:28:20 <dons> http://programming.reddit.com/info/1npkx/comments
18:28:21 <lambdabot> Title: A Scheme parser in Haskell (reddit.com)
18:28:53 * ddarius would not be surprised if there are well over 100 Scheme-ish parsers written in Haskell.
18:29:21 <dons> I'd say that's a conservative estimate
18:29:50 <johanatan> hello
18:30:36 <dons> this is nice, http://programming.reddit.com/info/1nplf/comments
18:30:37 <lambdabot> Title: Atom: a hardware description language embedded in Haskell (reddit.com)
18:31:07 <johanatan> quick newb question...  i've searched all the docs i can find, but this particular combination of data structures and desired combinations has me stumped
18:31:37 <dons> yep? do tell.
18:32:51 <johanatan> ok..  i have a func whose type is: Integer -> [ ( Integer, [ Integer ] ) ]
18:33:47 <johanatan> and i want another function that will group a list of Integer's (which come from the fst of the tuple above) that have identical [ Integer ] that come from the snd of the tuple above
18:34:07 <johanatan> producing [ ( [ Integer ], [ Integer ] ) ]
18:34:09 <kpreid> groupBy snd?
18:34:20 <kpreid> (plus some nesting tweaking)
18:34:29 <kpreid> er
18:34:31 <kpreid> @type groupBy
18:34:33 <johanatan> ahh..  groupBy ..  is this part of Prelude?
18:34:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
18:34:43 <kpreid> @type groupBy (\x y -> snd x == snd y)
18:34:46 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [[(a, b)]]
18:34:48 <dons> ?hoogle groupBy
18:34:49 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
18:34:53 <dons> in Data.List
18:35:04 <johanatan> ahh..  ok .. much thx
18:35:52 <kpreid> @type map (\((n,t):xs) -> ([n:map fst xs],t)) . groupBy (\x y -> snd x == snd y)
18:35:55 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [([[a]], b)]
18:36:28 <kpreid> @type map (\((n,t):xs) -> (n:map fst xs,t)) . groupBy (\x y -> snd x == snd y)
18:36:30 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [([a], b)]
18:36:57 <kpreid> there you go
18:37:38 <johanatan> wow.. that'll take a minute to digest
18:37:50 <johanatan> what's the dot operator?
18:37:56 <kpreid> function composition
18:37:59 <mauke> @type (.)
18:38:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:38:14 <mauke> @src (.)
18:38:15 <lambdabot> (.) f g x = f (g x)
18:38:34 <johanatan> ahh
18:40:46 <johanatan> and what's the @ ?
18:41:04 <notsmack> @help
18:41:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:41:08 <ddarius> I : A >-> B, Hom_B(b,I-) ~ Hom_A(a,-), setting a = R b and assuming naturality, R -| I
18:41:16 <johanatan> @ type
18:41:18 <johanatan> @type
18:41:21 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
18:41:21 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
18:41:21 <lambdabot>  
18:41:51 <mauke> haha
18:41:57 <mauke> @help type
18:41:58 <lambdabot> type <expr>. Return the type of a value
18:42:10 <johanatan> @help type
18:42:10 <lambdabot> type <expr>. Return the type of a value
18:42:45 <johanatan> help @type
18:43:08 <liquidengineer> Hi
18:43:14 <johanatan> hello
18:43:32 <liquidengineer> This isn't exactly a haskell question, but my program parses URLs, and I'm having URL difficulties, so it's sort of on topic
18:44:07 <liquidengineer> Inputting the url http://127.0.0.1/~jtdavis/ceohp-svn/include/../ into a browser will send the user to http://127.0.0.1/~jtdavis/ceohp-svn/
18:44:47 <liquidengineer> However, inputting http://127.0.0.1/~jtdavis/ceohp-svn/include/../file.php, with the expectation that the file is in the ceohp-svn directory, sends the user to http://127.0.0.1/~jtdavis/file.php
18:44:51 <liquidengineer> What gives?
18:46:40 <hpaste>  LoganCapaldo annotated "isInfixOf (warning, identifier choices may offend)" with "int-e, got any more edge cases that'll break this?" at http://hpaste.org/1709#a4
18:49:17 <ddarius> LoganCapaldo: Slap some quickcheck on it and use the library isInfixOf (or the one-line definition) to verify.
18:50:24 <ddarius> prop_correct substring string = substring `isInfixOf` string == substring `Data.List.isInfixOf` string
18:50:40 <ddarius> @hoogle isInfixOf
18:50:41 <lambdabot> No matches found
18:50:47 <ddarius> @index isInfixOf
18:50:47 <lambdabot> bzzt
18:50:54 <ddarius> Too new.
18:51:24 <LoganCapaldo> It's in Data.List
18:51:36 <LoganCapaldo> cuz it yelled at me, when I imported that for group
18:52:32 <LoganCapaldo> So now I just gotta figure out how to use quickcheck w/o @check :)
18:52:53 <int-e> LoganCapaldo: isInfixOf "ababc" "abababc"
18:53:33 <LoganCapaldo> I'm sensing a theme
18:53:37 <LoganCapaldo> mmm
18:54:17 <johanatan> liquidengineer:  sounds like a bug in the webserver
18:57:03 <johanatan> (or the browser)
18:59:38 <liquidengineer> I'll bug the #apache people them
18:59:44 <liquidengineer> *then
18:59:46 <liquidengineer> :)
18:59:47 <liquidengineer> thanks
19:02:42 <notsmack> liquidengineer: a packet capture would tell you which end the bug's on
19:03:54 <liquidengineer> notsmack: ?
19:04:03 <liquidengineer> howso?
19:04:29 <notsmack> check what the browser GETs when you type in that url
19:06:42 <int-e> LoganCapaldo: your state (in go) is basically a prefix of the needle; the example "abc...zabc...z*" shows that you have to make arbitrarily long jumps between prefixes - after seeing "a..za..za", you have to jump from the prefix "a..za..z" to "a..za".
19:07:43 <LoganCapaldo> int-e: yeah I figured that out finally (after ababa)
19:07:54 <LoganCapaldo> Now I'm jsut trying to decide how to do it
19:30:58 <dons> ?uptime
19:30:58 <lambdabot> uptime: 11d 19h 44m 51s, longest uptime: 11d 19h 44m 51s
19:31:02 <dons> ?users
19:31:02 <lambdabot> Maximum users seen in #haskell: 336, currently: 277 (82.4%), active: 30 (10.8%)
19:34:25 * araujo throws a lambda at dons 
19:34:50 <dons> yikes!
19:36:56 <sorear> hello.
19:37:37 <araujo> hello dons sorear
19:37:39 <araujo> how it goes?
19:37:41 <Adamant> lambdas = ninja stars for CS majors
19:37:48 <araujo> @yarr!
19:37:49 <lambdabot> Shiver me timbers!
19:39:21 <sorear> @quote @pointless
19:39:22 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
19:39:28 <sorear> aww, not there
19:40:33 <monochrom> @quote pointfree
19:40:33 <lambdabot> No quotes match. The more you drive -- the dumber you get.
19:40:37 <monochrom> @quote point-free
19:40:38 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
19:41:41 * araujo kind of bored
19:42:26 <SamB_XP> @quote point-free
19:42:26 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
19:42:31 <SamB_XP> same one again?
19:42:35 <SamB_XP> @quote point'
19:42:36 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
19:42:39 <SamB_XP> @quote point
19:42:40 <lambdabot> dylan says: <EvilRanter> perl, python etc will pointer all over the place, too  <dylan> they'll pointer on the carpet too!
19:42:51 <SamB_XP> @quote
19:42:52 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
19:43:28 <geezusfreeek> any good articles/tutorials/whatever about how to best go about actually designing a program in haskell (or functional languages in general)?
19:43:35 * araujo watching a program about life outside the planet
19:45:16 <SamB_XP> geezusfreeek: the types are crucial
19:47:40 <chessguy> any calender geeks here? i'm trying to figure out how to calculate how many fridays there are in an arbitrary month
19:48:09 <geezusfreeek> i have a mostly OO background, and i want to avoid tainting my functional programming experience with the OO design patterns and habits i have
19:48:29 <SamB_XP> geezusfreeek: don't worry about it
19:48:31 <geezusfreeek> and it's already clear to me that most of my habits are going to lead me straight to confusion
19:48:36 <dons> geezusfreeek: hmm. various blog articles on building applications
19:48:42 <SamB_XP> the language will stop you if it doesn't work ;-P
19:48:59 <dons> geezusfreeek: start with a core data structure, get it right with QuickCheck, layer a monadic skin on top
19:49:00 <notsmack> (such as dons's)
19:49:01 <geezusfreeek> SamB_XP: of course, but i'm talking about design, not semantics
19:49:23 <SamB_XP> no, I mean, on the type level
19:49:25 <araujo> geezusfreeek, read people code
19:49:49 <LoganCapaldo> soylent green code? :)
19:50:01 <araujo> Plus Haskell encourages good code design
19:50:04 <notsmack> http://cgi.cse.unsw.edu.au/~dons/blog
19:50:05 <lambdabot> Title: Haskell hacking
19:50:22 <dons> geezusfreeek: yes, emerse yourself in the culture, and you'll start to run away from mutable state, side effects, and towards higher-order functions, combinator sets, QuickCheck properties, purely functional data structures, hylomorphisms, applicative functors ...
19:50:56 <dons> but yes, reading code from applications is probably the fastest way to get a sense of 'style' in haskell land
19:51:09 <dons> xmonad's a good example, imo, of a unixy tool done "the haskell way"
19:51:35 <geezusfreeek> dons: actually, the reason i've started more seriously looking into functional languages is because i have been gradually using functional techniques in my OO code without realizing until a few weeks ago
19:52:17 <dons> yeah, I think that makese sense though. good style encourages abstraction, and once you do that you're in FP land anyway.
19:52:53 <dons> the land of refactoring
19:52:56 <SamB_XP> geezusfreeek: don't worry about *good* design yet
19:53:03 <SamB_XP> just learn how to do *something*
19:54:33 <dons> geezusfreeek: do you know where to start?
19:54:48 <dons> geezusfreeek: possibly some of the functional pearl, and design-ish, papers from ICFP would be a good read
19:55:10 <dons> basically replacing going to oxford or chalmers, and having Richard Bird teach you how to think like a lambda :-)
19:55:45 <SamB_XP> dons: does that mean that all you can do is search/replace?
19:55:54 <dons> hmm. I should make a collection of all the 'functional pearl' papers
19:56:28 <dons> start here, http://www.google.com.au/search?hl=en&q=functional+pearl&btnG=Google+Search&meta=
19:56:30 <lambdabot> Title: functional pearl - Google Search, http://tinyurl.com/2ayfgg
19:56:41 <dons> these are basically good fp design papers
19:57:35 <geezusfreeek> i already have learned the lambda calculus and most of haskell
19:58:07 <geezusfreeek> maybe all i need is some decent exercises
19:58:34 <SamB_XP> I think you should ride a unicycle up the side of a mountain
19:59:02 <SamB_XP> what did we say our mascot animal should be?
20:02:44 <geezusfreeek> alright thanks guys, i'll take a look at stuffs
20:03:13 <SamB_XP> I think it should be a unicycling whatever-it-was-we-said. if we figured anything out.
20:04:08 <twanvl> A unicycling lambda?
20:04:43 <SamB_XP> lambda is an animal now?
20:04:51 <twanvl> If you want it to be
20:05:09 <geezusfreeek> it should be
20:05:16 <geezusfreeek> it would be proof of the existence of God
20:05:23 <sphynx> by the way, is 'functional pearl' some tag applied to articles?
20:05:26 <SamB_XP> didn't someone else already take the lambda for o'reilly covers?
20:05:29 <geezusfreeek> well.... intelligent design anyway
20:05:42 <ddarius> "How to write a functional pearl" at http://icfp06.cs.uchicago.edu/ Richard Bird teaches you how to think like a lambda
20:05:44 <lambdabot> Title: 11th ACM SIGPLAN International Conference on Functional Programming (ICFP 2006)
20:06:13 <olsner> I think Lambda could be some kind of obscure marsupial
20:06:29 * SamB_XP can't see a lambda being able to reach the pedals of a unicycle
20:07:09 <geezusfreeek> it could be a big lambda
20:07:20 <geezusfreeek> just think of it as a guy with no arms and a really droopy neck
20:07:22 <SamB_XP> no, I mean the legs go off at such an angle
20:07:41 <geezusfreeek> well, allow them to be slightly malleable
20:08:13 <SamB_XP> why is this talk upside down?
20:09:10 <sphynx> ddarius, thanks
20:10:32 <mutjida> @users
20:10:33 <lambdabot> Maximum users seen in #haskell: 336, currently: 282 (83.9%), active: 31 (11.0%)
20:10:59 <LoganCapaldo> why doesn't (\x -> x + 1) desugar into (\->) x (x + 1) ? I'm very upset that (\->) isn't a first class function :)
20:11:38 <ddarius> Because Haskell is not intensional.
20:12:04 <twanvl> Then what would x be?
20:12:54 <LoganCapaldo> a metaphor?
20:12:56 <mauke> ?x
20:12:57 <lambdabot> Maybe you meant: . v
20:13:13 <LoganCapaldo> ?v
20:13:13 <lambdabot> "\""
20:13:24 <LoganCapaldo> ?v foo
20:13:25 <lambdabot> Just 'J'
20:13:36 <LoganCapaldo> ?v random?
20:13:37 <lambdabot> "\"#$%&'()*+,\""
20:13:38 <int-e> LoganCapaldo: you can desugar (\x -> x + 1) into  let foo x = x+1 in foo
20:13:49 <int-e> LoganCapaldo: where 'foo' is a fresh identifier.
20:14:16 <LoganCapaldo> (gensym)? <g>
20:14:32 <twanvl> That is more like resugaring
20:14:40 <LoganCapaldo> i'm just causing trouble :)
20:15:02 <ddarius> LoganCapaldo: Perhaps you want to look at the postscript language.
20:15:05 <int-e> twanvl: maybe. but I'm quite happy with let and case as primitives.
20:15:11 <sioraiocht> ?v
20:15:11 <lambdabot> Exception: <<loop>>
20:15:18 <sioraiocht> what does that meeeeeeeeeaaaannn
20:15:32 <LoganCapaldo> imagine the possibilities: flip (\->) (x + y) ;)
20:15:44 <ddarius> That message or ?v?
20:15:44 <LoganCapaldo> will it be a closure over x, or y?
20:15:49 <LoganCapaldo> Who knows? :)
20:15:56 <SamB_XP> ?help v
20:15:57 <lambdabot> let v = show v in v
20:16:07 <sioraiocht> what does -> do, anything?
20:16:10 <SamB_XP> ?v
20:16:11 <lambdabot> "\""
20:16:12 <SamB_XP> ?v
20:16:13 <lambdabot> Just 'J'
20:16:15 <int-e> ?v just prints some stupid random message.
20:16:16 <lambdabot> "\"#$%&'()*+,\""
20:16:19 <sioraiocht> s/anything/anyway
20:16:22 <SamB_XP> ah.
20:16:24 <sioraiocht> @src (->)
20:16:25 <lambdabot> Source not found. My mind is going. I can feel it.
20:16:29 <sioraiocht> @type (->)
20:16:31 <SamB_XP> I guess the help is out of date?
20:16:31 <ddarius> sioraiocht: Separates syntactical constructs.
20:16:32 <lambdabot> parse error on input `->'
20:16:36 <ddarius> It's also a binary type constructor.
20:16:45 <SamB_XP> > fix show
20:16:47 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:16:59 <SamB_XP> that is what it ought to do ;-P
20:17:01 <int-e> @yhjulwwiefzojcbxybbruweejw
20:17:01 <sioraiocht> ddarius: I just always saw it as something used in type signatures, I dunno what else I could possibly use it for
20:17:02 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:17:32 <SamB_XP> @unpl fix show
20:17:32 <lambdabot> fix show
20:18:08 <sorear> int-e: I presume you are old enough to know/not care about the story of @v?
20:18:14 <SamB_XP> hmm. perhaps "unlambda" would be a better name, if it didn't already refer to something...
20:18:25 <SamB_XP> @unlambda i
20:18:25 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:18:36 <SamB_XP> @unlambda i x
20:18:36 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:18:40 <SamB_XP> @unlambda i xxxxxx
20:18:40 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:18:45 <SamB_XP> @help unlambda
20:18:46 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
20:18:54 <sorear> SamB_XP: the bot is STILL broken!
20:18:58 * ddarius forgets the application operator of unlambda.
20:19:03 <SamB_XP> `
20:19:03 <sorear> lambdabot needs a way for @admins to log in and fix the system!
20:19:03 <skew> `
20:19:20 <ddarius> That's what I thought, but wasn't sure.
20:19:23 <int-e> sorear: I know it :)
20:19:27 <olsner> @unlambda `skk
20:19:28 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:19:34 <SamB_XP> does lambdabot even check if you are identified?
20:19:38 <skew> @unlambda ``skk
20:19:39 <lambdabot> Plugin `unlambda' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:19:45 <ddarius> @. lambda unlambda ``skk
20:19:46 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "lambda"
20:20:11 <syntaxfree> oh boy.
20:20:17 <sorear> SamB_XP: Do you think that trying again will spontaneously install a fixed version of regex-compat?
20:20:36 * sorear checks p.h.o
20:20:38 <SamB_XP> sorear: ... no
20:20:44 <olsner> you never know... it *might* happen ;-)
20:20:56 <cdsmith> Is there a good way to make ghci use -fglasgow-exts by default, but accept -fno-glasgow-exts on the command line?
20:21:02 <SamB_XP> maybe *dons* could?
20:21:24 <olsner> if nothing else, it could annoy the one who has the power to fix it enough to fix it
20:21:27 <monochrom> environment variable or .file
20:21:27 <ddarius> My C# regex impl has beaten my Haskell one.  The good news is that it C# does use a backtracking implementation in System.Text.RegularExpressions so mine tromps it.
20:21:48 <sorear> ddarius: Parse error
20:21:57 <sorear> ... is that it C# does ...
20:22:04 <sorear> uncorrectable, I might add
20:22:08 <SamB_XP> dons: we will flood the channel if you don't fix it!
20:22:17 <ddarius> s/it//
20:22:19 <SamB_XP> sorear: you could maybe be more creative
20:22:23 <cdsmith> monochrom: I have :set -fglasgow-exts in my .ghci file now; but -fno-glasgow-exts doesn't work now.
20:22:29 <SamB_XP> but I never understood those papers about correcting parsers
20:22:48 <mauke> cdsmith: alias ghci='ghci -fglasgow-exts'?
20:22:56 * ddarius really hates programs that try to guess what he wants.
20:24:05 <cdsmith> mauke: great, that seems to work.
20:24:07 <ddarius> Or at least, when not asked to.
20:25:09 <monochrom> Some programming languages are designed to guess what you want. I fleed to haskell because I don't want that.
20:25:44 <cdsmith> Thanks for that.  I normally use glasgow extensions, but I was trying to teach someone else Haskell and the forall qualifiers for :t were getting in the way.
20:27:10 <SamB_XP> probably :set -fno-glasgow-exts
20:27:14 <SamB_XP> would also be usefull?
20:27:36 <cdsmith> SamB_XP: that's what I had; but the .ghci file options apparently supercede the command line.
20:27:59 <SamB_XP> I mean, in GHCi you could run that...
20:28:05 <cdsmith> SamB_XP: once the flag is set, ghci won't clear it.
20:28:14 <SamB_XP> ah.
20:28:43 <cdsmith> Or never mind.  It take -fno-glasgow-exts, but not :unset -fglasgow-exts, which is what I was trying.
20:29:27 <cdsmith> Prelude> :unset -fglasgow-exts
20:29:28 <cdsmith> can't unset GHC command-line flags
20:29:42 <sorear> wierd!
20:29:48 <sorear> you should file a bug
20:29:58 <sorear> since it was confusing - it is at least a doc bug
20:30:00 <sorear> @bug
20:30:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:30:11 <sorear> login as guest, password guest
20:30:13 <mauke> @blog
20:30:14 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:30:18 <mauke> huhu
20:31:05 <syntaxfree> new post on http://syntaxfree.wordpress.com
20:31:07 <lambdabot> Title: Data.Syntaxfree
20:31:10 <syntaxfree> i wonder if that's spamming.
20:31:13 <cdsmith> sorear: I will do that.
20:31:56 <merus> syntaxfree, yay!
20:32:05 <syntaxfree> (I'm kinda drunk. Feel free to kick me out of the channel, but please don't ban me)
20:32:11 <sorear> I'll be lazy and wait for PHO.
20:32:14 <syntaxfree> (I'm really really drunk actually)
20:32:35 * merus wishes he was drunk ;_;
20:32:48 <sorear> @karma syntaxfree
20:32:48 <lambdabot> syntaxfree has a karma of 2
20:32:53 <sorear> too high to ban.
20:33:48 <sorear> syntaxfree: I don't think you actually posted it :)
20:34:06 <syntaxfree> sorear: I posted that when I was sober earlier today.
20:34:08 <sorear> syntaxfree: the newest thing I see on your blog is still the regression thing
20:34:23 <syntaxfree> ah, yes.
20:34:25 <syntaxfree> you saw that.
20:34:27 <sorear> oh, I was expecting somethign brand new.  nm then
20:34:32 <syntaxfree> soorry.
20:34:35 <syntaxfree> sorry, too.
20:35:22 <dolio> Was that first one Canadian?
20:36:16 <sorear> @seen TuringTest
20:36:17 <lambdabot> I saw TuringTest leaving #haskell 2d 19h 4m 53s ago, and .
20:37:03 <syntaxfree> @seen my life
20:37:04 <lambdabot> I haven't seen my.
20:39:18 <goban> @seen my_keys
20:39:19 <lambdabot> I haven't seen my_keys.
20:39:34 <goban> i need lambda bot IRL
20:55:24 <dons> wow. how long has JFP had article available online?
20:55:32 <dons> e.g. http://www.journals.cambridge.org/action/displayIssue?jid=JFP&volumeId=17&issueId=01
20:55:36 <lambdabot> Title: Cambridge Journals Online - Journal of Functional Programming Vol. 17 Iss. 01, http://tinyurl.com/2gkxsq
21:02:52 <chessguy> ?hoogle integerpart
21:02:53 <lambdabot> No matches found
21:02:59 <chessguy> ?hoogle intpart
21:03:00 <lambdabot> No matches found
21:03:15 <chessguy> ?hoogle Double -> Int
21:03:16 <lambdabot> No matches, try a more general search
21:03:22 <int-e> > truncate 4.6
21:03:24 <lambdabot>  4
21:03:28 <chessguy> that's what i wanted
21:03:29 <chessguy> thanks
21:03:33 <int-e> > truncate (-3.7)
21:03:34 <lambdabot>  -3
21:03:37 <int-e> maybe you want floor
21:03:54 <chessguy> i'm not concerned about negatives
21:05:37 <LoganCapaldo> @check (\x -> (floor . ceiling) x == ceiling x)
21:05:39 <lambdabot>  Add a type signature
21:05:51 <LoganCapaldo> @check (\x -> (floor . ceiling) x == ceiling x) :: Double -> Bool
21:05:52 <lambdabot>  Add a type signature
21:06:07 <LoganCapaldo> I thought I did
21:06:26 <LoganCapaldo> @type (\x -> (floor . ceiling) x == ceiling x) :: Double -> Bool
21:06:29 <lambdabot>     Ambiguous type variable `b' in the constraints:
21:06:29 <lambdabot>       `Integral b' arising from use of `ceiling' at <interactive>:1:16-22
21:06:36 <int-e> heh. no. it doesn't know what to use in the middle of floor . ceiling
21:06:43 <LoganCapaldo> @type (\x -> (floor . ceiling) x == ceiling x)
21:06:46 <lambdabot>     Ambiguous type variable `b' in the constraints:
21:06:46 <lambdabot>       `Integral b' arising from use of `ceiling' at <interactive>:1:16-22
21:06:53 <LoganCapaldo> gah
21:07:12 <LoganCapaldo> @type (\x -> (floor . ceiling) x == ceiling x :: Integer)
21:07:15 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Bool'
21:07:15 <lambdabot>     In the expression: ((floor . ceiling) x) == (ceiling x)
21:07:28 <LoganCapaldo> @type (\x -> (floor . ceiling) x == (ceiling x :: Integer))
21:07:29 <int-e> @type let cast :: Integer -> Double; cast = fromInteger in \x -> (floor . cast . ceiling) x == ceiling x
21:07:30 <lambdabot>     Ambiguous type variable `b' in the constraints:
21:07:31 <lambdabot>       `Integral b' arising from use of `ceiling' at <interactive>:1:16-22
21:07:32 <lambdabot> Integer -> Double; cast = fromInteger in \x -> (floor . cast . ceiling) x == ceiling x :: forall a. (RealFrac a) => a -> Bool
21:08:19 <LoganCapaldo> @check let cast :: Integer -> Double; cast = fromInteger in \x -> (floor . cast . ceiling) x == ceiling x
21:08:20 <lambdabot>  Add a type signature
21:08:28 <LoganCapaldo> @check let cast :: Integer -> Double; cast = fromInteger in \x -> (floor . cast . ceiling) x == ceiling x :: Double -> Bool
21:08:30 <lambdabot>  Couldn't match expected type `Double -> Bool'
21:08:42 <LoganCapaldo> @check let cast :: Integer -> Double; cast = fromInteger in (\x -> (floor . cast . ceiling) x == ceiling x ):: Double -> Bool
21:08:44 <lambdabot>  OK, passed 500 tests.
21:08:50 <LoganCapaldo> hooray
21:09:51 <dons> :)
21:10:31 <LoganCapaldo> oh duh
21:10:38 <LoganCapaldo> I'm sucha  putz
21:10:55 <LoganCapaldo> clearly no one is gonna bother to define floor for integers
21:11:01 <LoganCapaldo> @type floor
21:11:03 <chessguy> umm, the calender we usually use is the gregorian calendar, right?
21:11:04 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:14:03 <cdsmith> chessguy: yes
21:14:16 <chessguy> ugh, calendars are confusing
21:14:30 <chessguy> ?hoogle date
21:14:31 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
21:14:31 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
21:14:31 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
21:14:40 <cdsmith> Well, I guess it really depends on the "we".  But almost certainly yes.
21:15:36 <johanatan> hey guys
21:15:41 <johanatan> gals
21:16:13 <johanatan> one thing about Haskell -- all the information on it i have to pick up in sparse quantities spread out all over the internet
21:16:34 <johanatan> is there a good consolidated syntax guide
21:16:37 <johanatan> somewhere?
21:16:54 <johanatan> maybe not to the level of a specification
21:17:00 <cdsmith> johanatan: the "right" answer is the haskell report, if you want a definitive and complete guide.
21:17:24 <johanatan> ok, cool.. thx
21:17:26 <cdsmith> http://www.haskell.org/tutorial/ is good, though.
21:17:27 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
21:17:31 <skew> for other information, the GHC user's guide plus Simon Peyton-Jones publication pages should have just about everything
21:17:57 <ventonegro> dcoutts_: hi, got time to help with gtk2hs?
21:18:04 <johanatan> yea, i've read the gentle introduction, but i need something that tells you what each symbol does
21:18:31 <skew> well, everyting about the language proper anyways, libraries can be harder to find
21:19:00 <skew> The specification is good
21:19:06 <johanatan> oh..  oops, that was the lambdabot.
21:19:30 <johanatan> cool.
21:20:04 <dpiponi> Anyone know if the Lava/Lego stuff from TMR7 is available online?
21:20:57 <sioraiocht> @src subtract
21:20:58 <lambdabot> subtract x y = y - x
21:21:22 <ventonegro> dcoutts: nevermind, solved :-)
21:21:48 <sioraiocht> (-4) :: Word8
21:21:55 <sioraiocht> > (-4) :: Word8
21:22:00 <lambdabot>  252
21:22:58 <dons> dpiponi: nope, but if you find out something, do let us know.
21:25:41 <dpiponi> Will do. I'd like to pott the code for the Make Controller. Should be almost trivial judging by the C code it generates.
21:31:39 <syntaxfree> it's a wonderful world where people like me can be in the same chatroom as people like sigfpe.
21:31:49 <syntaxfree> but hey, is there a decimal float type in Haskell?
21:32:54 <ddarius> There is a library referenced on haskell.org
21:34:44 <syntaxfree> cool.
21:43:20 <sioraiocht> @type liftIO . char
21:43:23 <lambdabot>     Couldn't match expected type `IO a' against inferred type `Doc'
21:43:24 <lambdabot>     In the second argument of `(.)', namely `char'
21:43:28 <sioraiocht> @type liftIO . getChar
21:43:31 <lambdabot>     Couldn't match expected type `a -> IO a1'
21:43:31 <lambdabot>            against inferred type `IO Char'
21:45:05 <johanatan> @type
21:45:07 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
21:45:07 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
21:45:07 <lambdabot>  
21:45:31 <johanatan> @type map (\((n,t):xs) -> (n:map fst xs,t)) . groupBy (\x y -> snd x == snd y)
21:45:34 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [([a], b)]
21:46:21 <johanatan> hmm.. i'm getting 'parse error on input '\' for the statement above
21:47:35 <johanatan> i'm assuming it's the first '\'
21:50:02 <johanatan> @type map (\((n,t):xs) -> (n:map fst xs,t)) . groupBy (\x y -> snd x == snd y)
21:50:04 <lambdabot> forall a b. (Eq b) => [(a, b)] -> [([a], b)]
21:50:31 <dolio> Is that the whole expression?
21:50:32 <johanatan> @type map (\(([n],t):xs) -> (n:map fst xs,t)) . groupBy (\x y -> snd x == snd y)
21:50:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
21:50:34 <lambdabot>       Expected type: [(a, b)]
21:50:39 <johanatan> yea
21:50:39 <dolio> Maybe you can paste some more context.
21:50:54 <dolio> @paste
21:50:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:51:08 <johanatan> well, that's it... someone gave that earlier.. but, i can paste what i'm trying to do with that statement
21:51:46 <dolio> It's possible that could help. I don't see anything wrong with it in itself.
21:51:57 <dolio> Obviously lambdabot doesn't either. :)
21:52:15 <johanatan> true, but ghci does...  i'll try it in an empty file by itself
21:52:23 <LoganCapaldo> could you be having layout issues?
21:52:29 <LoganCapaldo> oh not in ghci I guess
21:52:54 <johanatan> well, with the '@' it gets parse error on it.. without the @, parse error on '\'
21:53:08 <johanatan> (in a file by itself)
21:53:15 <dolio> Well, in ghci it'd be ':type'.
21:53:57 <johanatan> :type produced 'Not in scope: groupBy'
21:54:04 <mauke> :m +Data.List
21:54:16 <LoganCapaldo> :m +Da...er nvm
21:54:33 <johanatan> ahh .. that did it
21:54:53 <johanatan> what if i wanted to put the statement in a file instead of directly in the cli
21:55:09 <mauke> import Data.List
21:55:09 <dolio> If you just put in 'type' it'd probably get confused because that's a keyword.
21:55:29 <dons> sorear: can you follow up your mail explaining 'Debug.trace', and then how to actually get hold of the ghci breakpoint stuff?
21:55:37 <dons> since the original poster won't have any idea what you did.
21:55:48 <dons> its good to be helpful :-)
21:55:50 <johanatan> oh.. so i just need to give it a func def?
21:56:43 <johanatan> i don't really fully understand the statement.. i guess that's part of the problem
21:57:08 <johanatan> the groupBy part is no problem
21:58:17 <johanatan> what's the Eq though in the result?
21:58:56 <LoganCapaldo> Means the type must be an instance of the Eq type class
21:59:03 <LoganCapaldo> (support ==, /=)
21:59:12 <johanatan> ahh.. ok
22:01:17 <LoganCapaldo> @src Eq
22:01:17 <lambdabot> class  Eq a  where
22:01:18 <lambdabot>     (==), (/=)   :: a -> a -> Bool
22:02:28 <dons> mm, nice, http://www.informatik.uni-bremen.de/~cxl/papers/jfp03.pdf
22:02:33 <dons> (Haskell in Space, or Asteroids for learning FP)
22:02:45 <LoganCapaldo> is it a comonad tutorial?
22:02:53 <dons> hehe. no.
22:02:55 <LoganCapaldo> (asteroids instead of spacesuits...)
22:02:55 <dons> just basic FP design
22:02:56 <RyanT5000> how small can a reasonable haskell runtime be made?
22:03:06 <dons> RyanT5000: hmm. good question!
22:03:18 <RyanT5000> i'm working for one laptop per child this summer, and i'd love it if i could use haskell for some stuff
22:03:25 <RyanT5000> but the total budget for OS + runtimes is 100 MB
22:03:27 <dons> you could compile down to lambda calc, then have a maybe 500 line C runtime implementing S and K
22:03:38 <skew> need gc in there somewhere
22:03:39 <dons> oh, well well well under that.
22:03:52 <RyanT5000> yeah, i know, it's well under 100
22:03:58 <dons> so i'm thinking about the compiled unlambda approach
22:04:25 <RyanT5000> but that 100 also has to fit, you know, linux, and stuff
22:04:27 <skew> and after that it depends what primitives you want
22:04:32 <RyanT5000> could you compile down to python?
22:04:36 <dons> RyanT5000: nhc might be a good target
22:04:41 <RyanT5000> (although, python isn't exactly fast, is it?)
22:04:44 <dons> RyanT5000: since its already designed for embedded systems
22:04:53 <dons> with very tight resources constraints
22:04:54 <RyanT5000> i know they've got a python runtime already
22:05:07 <dons> and nhc's runtime comes in way way under python
22:05:16 <RyanT5000> right, but python is already in the budget
22:05:30 <RyanT5000> as are a few other languages (i'll get a list at some point)
22:05:39 <LoganCapaldo> Plus children need to learn about static typing too
22:05:40 <dons> (we use it on 4MB embedded Arm cards)
22:05:42 <RyanT5000> lol
22:06:06 <RyanT5000> yeah, well it can't be a super-minimalist system either
22:06:10 <dons> well, for tight resources, nhc is still the best option. you could just have hugs too, if the idea is just to give them something to use.
22:06:36 <RyanT5000> no, the idea is that i have to write some stuff for them and i don't want to write in languages that annoy me :P
22:06:46 <LoganCapaldo> dons: you were supposed to say "you could just give them hugs too"
22:06:49 <dons> ah right. then why not ship stripped ghc binaries?
22:06:59 <sorear> RyanT5000: I've written a SK interpreter in <100 *bytes*
22:07:09 <RyanT5000> what's the overhead for ghc binaries?
22:07:19 <dons> well, hello world is about 200k
22:07:24 <RyanT5000> ah, that's probably fine
22:07:25 <sorear> RyanT5000: about 2M heap, 200k code
22:07:26 <dons> binari size.
22:07:30 <dons> yeah
22:07:37 <sorear> <20ms startup time
22:07:37 <skew> is that statically linked?
22:07:43 <dons> sorear: though there's shootout programs with 700k heap
22:07:44 <RyanT5000> can that 200k be put in a dynamically linked library?
22:07:45 <sorear> skew: there is no alternative :(
22:07:47 <dons> skew: yeah.
22:07:52 <dons> dyn linked you get 10k (on the Mac)
22:08:04 <RyanT5000> hm, that sounds fine
22:08:06 <skew> OLPC is what, ARM?
22:08:09 <RyanT5000> Geode
22:08:12 <sorear> RyanT5000: No.  GHC does not support dynamic linking, unless you can get OLPC to switch to Macintosh.
22:08:19 <dons> right.
22:08:20 <RyanT5000> ah, i think not
22:08:25 <dons> so not dyn linked.
22:08:29 <RyanT5000> hm, that sucks
22:08:30 <RyanT5000> how come?
22:08:35 <dons> 200k hello world is a stripped, statically linked binary
22:08:39 <sorear> RyanT5000: that said, can you wait four months
22:08:42 <dons> that has about 195k of runtime
22:08:57 <sorear> RyanT5000: implementing dynamic linking on linux is one of our SoC projects
22:08:58 <dons> nhc98 binaries are a fair bit small, iirc.
22:09:03 <sorear> so, September
22:09:09 <dons> RyanT5000: you could just try a few things out.
22:09:09 <RyanT5000> 4 months is about when it will be actually shipping
22:09:17 <RyanT5000> yeah, i will
22:09:21 <dons> since we don't really know precisely what you need to do
22:09:31 <dons> if its just system tools, then nhc would be a good choice (and you'd get small binaries)
22:09:32 <RyanT5000> yeah, neither do i yet
22:09:42 <RyanT5000> alright, i'll look into that
22:09:46 <dons> but it sounds col!
22:09:46 <RyanT5000> i'm sure i'll be back here over the summer
22:09:48 <dons> cool
22:09:50 <sorear> dons: is nhc portable to non-VAXist systems?
22:09:57 <dons> sorear: to arm, certainly.
22:09:59 <RyanT5000> i still can't believe i'm in law school, lol
22:10:01 <dons> any 32 bit machine should be ok
22:10:07 <RyanT5000> it's the most ridiculous thing
22:10:10 <dons> hehe
22:10:28 <dons> sorear: nhc used to be the preferred compile for embedded applications (maybe still is?)
22:10:35 <sorear> so, Haskell will be on the OLPC systems.
22:10:47 <sorear> I might lose my place as Very Young Haskeller :)
22:10:49 <RyanT5000> i have two summer jobs: writing a paper (or several papers) on software patents for law journals and writing some stuff for OLPC (both legal and coding work)
22:10:55 <RyanT5000> lol
22:11:03 * sorear learned at 15
22:11:11 <RyanT5000> i'm so jealous
22:11:13 <RyanT5000> i was 19 :(
22:11:51 <dons> I was 18.
22:12:07 <sorear> I would say "yhc/ayhi" but I guarantee you I won't finish in four months :)
22:12:11 <RyanT5000> (then again, i'm only 20 now :P)
22:12:17 * sorear is 16 nwo
22:14:43 <dons> sorear: so you really think Message is overkill?
22:15:38 <sorear> dons: It depends.  How long is the patch?
22:15:57 <sorear> now that I've seen more of it, I don't think so.
22:16:03 <dons> about 5 lines.
22:16:13 <dons> ok. good :-)
22:16:17 <sorear> aw, that's fine.
22:16:24 <dons> I though you must have replied to the GADT patch.
22:16:33 <sorear> I expected more like 30 for a decent typeable implementation.
22:16:44 <dons> and before I had my coffee this morning, I was thinking "oh man, what's going on!"
22:16:46 <sorear> didn't realize att you were using Data.Typeable
22:17:02 <dons> nah, it just takes Typeable for the type hiding, then constrains it with an existential
22:17:15 <dons> not reimplementing Typeable
22:17:25 <dons> class Typeable a => Message a
22:17:38 <dons> data SomeMessage = forall a. Message a => SomeMessage a
22:17:42 <dons> fromMessage :: Message m => SomeMessage -> Maybe m
22:17:42 <dons> fromMessage (SomeMessage m) = cast m
22:17:43 <dons> done.
22:18:07 <dons> obvious really, combining type classes, existentials, and dynamic typing.
22:18:11 * dons <3 Haskell
22:29:17 <araujo> @yarr!
22:29:17 <lambdabot> Gangway!
22:30:04 <blackdog> man, i just got the shock of my life
22:30:15 <blackdog> i searched for haskell on a jobs board and got some hits. how freaky is that?
22:30:55 <sorear> OMG!!!
22:31:25 <blackdog> did haskell somehow get commercially viable while i wasn't looking?
22:31:27 <sorear> hello araujo. RyanT5000 has been talking about the space overheads of Haskell.
22:31:27 <skew> quick, /leave #haskell ; /join #epigram
22:31:38 <blackdog> *grin*
22:31:54 <blackdog> like rats leaving a floating ship
22:31:59 <RyanT5000> lol
22:32:31 <araujo> sorear, interesting ....
22:32:39 <sorear>      * Shared Libraries for GHC
22:32:39 <sorear>  
22:32:39 <sorear>      Clemens Fruhwirth, Simon Marlow { BryanOS }
22:32:44 <sorear> Er, nevermind.
22:32:44 <dons> blackdog: url?
22:32:57 <blackdog> simplyhired.com
22:32:59 <sorear> No idea how I managed to confuse therp with araujo!
22:32:59 <dons> blackdog: yeah, we got jobs now. pretty crazy stuff.
22:33:08 <araujo> haha
22:33:10 <RyanT5000> yeah; i'm working for One Laptop Per Child, which has really tight budgets, but i want to convince them to use haskell
22:33:14 <RyanT5000> (for some stuff)
22:33:20 <dons> blackdog: any we haven't heard of?
22:33:22 <blackdog> dons: yeah, you're the reason i went searching - i was sure you were pulling my leg about that
22:33:35 <blackdog> one was DSLs in the financial markets, which is probably someone familiar
22:33:42 <sorear> CS?
22:33:42 <RyanT5000> they have a total budget of 100 MB for the OS and all the runtimes and (i think) most of the included software
22:33:44 <blackdog> i was just so shocked to see it at all
22:34:02 <dons> yeah, sounds like CS, or maybe one of the other banks.
22:34:16 <sorear> RyanT5000: don't bother - I directed you at the wrong person
22:34:17 <dons> Jane Street, perhaps.
22:34:20 <sorear> @seen therp
22:34:20 <lambdabot> I saw therp leaving #haskell-soc and #haskell 8h 52m 46s ago, and .
22:34:28 <blackdog> but Jane street is an ocaml shop, isn't it?
22:34:39 <dons> wow. actually, there's quite a few hits.
22:34:44 <dons> http://www.simplyhired.com/index.php?ds=sr&q=haskell&l=&sl=save
22:34:45 <sorear> haskell, ocaml, FAIAP no difference.
22:34:46 <lambdabot> Title: Haskell jobs | SimplyHired
22:35:07 <dons> Haskell/C++ is probably all CS (?)
22:35:25 <stepcut> Nurse Practitioner
22:35:25 <stepcut> Haskell County Healthcare System
22:35:26 <stepcut> ;)
22:35:28 <sorear> Strongly typed higher order FP is strongly typed higher order FP.
22:35:40 <blackdog> yeah, there's a "haskell company" too
22:35:46 <dons> yeah, the first two jobs look like credit suisse
22:35:48 <blackdog> damn namespace collisions
22:36:45 <stepcut> this company: http://seeker.dice.com/jobsearch/servlet/JobSearch?op=101&dockey=xml/f/3/f3f9f1e3dfcd249cfb39c55349bd1650@activejobs0&c=1&source=2021&spon=shpaid
22:36:46 <skew> sorear: it seems like Haskell/GHC addresses most of the issues with O'Caml that Yaron Minsky listed for TMR
22:36:48 <dons> then one at the end just says haskell experience would be good
22:36:48 <lambdabot> http://tinyurl.com/cza2x
22:37:00 <stepcut> is looking for unlambda developers!
22:37:11 * sorear applies!
22:37:12 <dons> and the last one says "Programming experience with more esoteric and powerful languages for data manipulation (Ruby, Python, Haskel"
22:37:32 <sorear> not much competition in THAT field ;)
22:38:10 <blackdog> right. resume's getting polished and sent in. one can hack RoR only so long :)
22:38:31 <sorear> RoR?
22:38:37 <blackdog> ruby on rails
22:38:40 * sorear likes rotate right instructions
22:41:34 <thedatabase> hey folks -- CS is definitely looking to hire some haskellers in NY and London
22:42:02 <thedatabase> they hosted a FP meet a couple of days ago, I think they've got about 2-3 positiona
22:42:04 <thedatabase> s
22:42:16 <dons> yeah, that sounds about right from what I've heard.
22:43:21 <thedatabase> seems like a nice system they have -- at least the sound very impressed
22:44:50 <thedatabase> i think they're using a haskell DSL to generate spreadsheet apps
22:45:09 <dons> yep. spreadsheet frontend, haskell transformer to dump C++. something like that.
22:45:58 <thedatabase> i'm not so much of a haskell expert.... is using specialized instances of type classes a standard way to implement DSLs in haskell?
22:46:25 <dons> hmm, it could be one technique used.
22:48:12 <thedatabase> so they redefined a bunch of operators over the numeric type classes.  Instead of performing the calculation, they blurt out generated code to do it in a spreadsheet instead.  Seemed like a powerful technique and I was wondering how widespread it was
22:48:37 <thedatabase> ?\
22:48:38 <lambdabot> Maybe you meant: . v
22:49:12 <dons> oh hmm. probably not that common. but Lennart is a bit of a uber-hacker, so he can get away with it :-)
22:49:27 <dons> overloading on Num isn't too common, but its rather powerful
22:50:28 <thedatabase> ha -- he definitely seems to be; they seemed quite blown away.  Vindication of a good hiring strategy -- speak softy, and carry a Lennart
22:50:42 <thedatabase> (softly)
22:52:31 <Cale> Well, in some sense, most DSLs are specialised instances of a few typeclasses, but Num is a bit uncommon. :)
22:52:53 <dons> its uncommon, but very powerful, and underexploited.
22:52:54 <Cale> There are a bunch of typeclasses which are specifically for structuring DSLs.
22:53:09 <thedatabase> which are they?
22:53:16 <dons> I mean, what kind of stuff could we encode, say, using overflow behaviour Num. the mind boggles.
22:53:23 <dons> > (-4) :: MyType
22:53:24 <lambdabot>   Not in scope: type constructor or class `MyType'
22:53:26 <Cale> Monad, Functor, Applicative, Arrow
22:53:27 <dons> > (-4) :: Word8
22:53:28 <lambdabot>  252
22:53:36 <Cale> (Comonad, but it's not in the libraries)
22:53:49 <skew> It's more common, for EDSLs at least, to have something like a monad that monstly builds up a symbolic expression
22:54:16 <skew> but if you are trying to compile to something different entirely you can't allow general Haskell functions at all
22:55:05 <thedatabase> skew: not even if you redefine the general haskell function for a new instance of some type class?
22:55:40 <dons> Cale: do you know if "Red-black trees with types" is online somewhere?
22:55:47 <dons> I'm sure I've read it as pdf, but can't find it.
22:55:59 <skew> A special instance of Num is one way to allow standard expressions, but get an AST
22:55:59 * dons is building up a complete collection of published 'functional pearl' papers
22:56:36 <Cale> thedatabase: the problem skew's referring to is that >>=, which is one of the combining functions in the Monad typeclass, takes a function as a parameter, and functions are opaque in Haskell, so you won't be able to serialise values of most monads.
22:57:02 <Cale> (though, you can usually serialise the results of the computation)
23:01:11 <thedatabase> Cale: ok... OK I *think* I get this, but I'm still struggling a bit.  So what does that new serialization library (forget the name) serialize?  What is most characteristic about "result" as opposed to function?
23:03:37 <Cale> thedatabase: Well, it's the difference between computing a result in Haskell, and compiling code to compute a result somewhere else.
23:04:21 <narain> are "where" clauses allowed for declarations only or for expressions?
23:04:33 <Cale> narain: decls only
23:04:51 <narain> aww. so i have to do let..in instead?
23:05:00 <narain> for expressions i mean
23:05:04 <Cale> narain: That's what it's for
23:05:23 <narain> ok. i just liked the postfixity of where
23:05:44 <Cale> thedatabase: You might write code in some monad which generates an expression of the other language, but compiling monadic computations directly to another language is usually impossible.
23:06:21 <Cale> narain: well, most every expression is part of a declaration, except on the ghci/hugs prompt
23:07:08 <narain> that's true, i should have thought of that
23:07:37 <narain> sometimes using a where isn't possible because of locals in the expression, but it'll work for what i'm doing right now
23:07:46 <narain> thanks Cale
23:08:04 <thedatabase> Cale/skew: thanks!  Something to chew on while I sleep
23:08:49 <thedatabase> it's something that feels it ought to be familiar from the C++ world I usually inhabit
23:09:39 <skew> maybe a bit
23:09:59 <skew> like using a wierd operator overloading that builds up an AST
23:11:21 <skew> as compared to taking an arbitrary function pointer for a callback
23:12:04 * thedatabase chews thoughtfully
23:12:31 <thedatabase> ok -- thanks guys, i'm off to bed.  (Deutsche Bank are also looking for a haskeller or two in their prop group btw)
23:14:04 <dons> yeah, though i've not seen any advertisements yet?
23:14:05 <thedatabase> dons:  btw were you looking for a relevant functional pearl...?  Bet you got diverted reading them! :)
23:14:13 <dons> sure do.
23:14:19 <dons> though i've got about 50 found and linked now.
23:14:22 <dons> i'll post the list soon
23:15:37 <thedatabase> heh -- ok, i'll look in the morning.  I've not seen any advertisements either -- chap at FP meet says he was looking tho, but I don't think he's nearly as far on as Lennart has taken CS
23:16:39 <dons> yeah.
23:16:49 <zeeeeee> anybody seen this error before? "internal error: interpretBCO: unknown or unimplemented opcode 43296"
23:16:58 <zeeeeee> (GHC version 6.6 for i386_unknown_linux)
23:17:07 <zeeeeee> maybe it's fixed in latest
23:17:09 <dons> that's a (fixed?) ghci bug
23:17:15 <dons> I think it got fixed just recently
23:17:20 <dons> check the bug tracker:
23:17:21 <dons> ?bug
23:17:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
23:17:24 <zeeeeee> ok
23:17:48 <skew> 6.6.1 is officially released
23:18:17 <narain> > join (,) [-1,1]
23:18:23 <lambdabot>  ([-1,1],[-1,1])
23:18:44 <narain> > join (liftM2 (,)) [-1,1]
23:18:45 <lambdabot>  [(-1,-1),(-1,1),(1,-1),(1,1)]
23:27:58 <narain> ?hoogle (a -> Bool) -> [a] -> a
23:27:59 <lambdabot> No matches, try a more general search
23:30:01 <narain> > ((head .) . dropWhile . (not .)) (> 0) [-3,-1,0,4]
23:30:03 <lambdabot>  4
23:30:26 <narain> wow, i got a complicated sequence of compositions right on the first try
23:31:48 <dons> nice.
23:32:10 <narain> thanks!
23:58:48 <narain> ?pl con . f . decon
23:58:49 <lambdabot> con . f . decon
23:58:52 <narain> ?pl \f -> con . f . decon
23:58:53 <lambdabot> (con .) . (. decon)
23:59:27 <narain> cute
