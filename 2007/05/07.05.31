00:00:36 * Cale implements the plactic monoid ring in Haskell :)
00:00:41 <Cale> *Main> (pr [[1,2]] + pr [[1,3]])^2
00:00:41 <Cale> 1 * pr [[1,1],[2],[3]] + 1 * pr [[1,1,2],[2]] + 1 * pr [[1,1,3],[2]] + 1 * pr [[1,1,3],[3]]
00:02:59 <dons> ?yow
00:02:59 <lambdabot> You mean you don't want to watch WRESTLING from ATLANTA?
00:03:02 <dons> hey Cale
00:03:04 <Cale> hi
00:11:31 <dan_> ?losers
00:11:31 <lambdabot> Maximum users seen in #haskell: 342, currently: 297 (86.8%), active: 22 (7.4%)
00:11:49 <thoughtpolice> are there any recent haskell ssl/tls bindings? I found hopenssl and hsgnutls, but both seem somewhat unmaintained
00:19:17 <dons> thoughtpolice: double check on hackage
00:21:24 <osfameron> Apocalisp: cool! ta
00:25:22 <quicksilver> osfameron: woo! I'm in the blogosphere!
00:25:29 <quicksilver> osfameron: (you mentioned me on your blog)
00:25:46 <dons> we prefer the term 'blargh-o-drome'
00:26:43 * quicksilver does a little dance to celebrate his first appearance on planet.haskell
00:27:07 <dons> hehe
00:27:13 <osfameron> quicksilver: hehe
00:27:38 <osfameron> quicksilver: of course I'm not sure if being mentioned by a C-list tech-blogger is your only claim to fame
00:27:54 <quicksilver> what about 'Tube-O-Blogs' ?
00:28:09 <dons> yeah, that's good.
00:28:33 <quicksilver> osfameron: it's a different kind of fame from starring in Pirates of the Carribean, though.
00:28:42 <quicksilver> osfameron: I know which I'm mopre proud of.
00:28:45 <dons> "so i logged onto the blarghotubes today. they were talking about lolcats"
00:29:06 <osfameron> can I has lollambdas?
00:29:21 <quicksilver> O HAI IM IN UR CULTURE STELLIN UR NEOLOGISMS
00:35:18 <earthy> lollambdas... omgwtfbbq!
00:35:22 <dons> O HAI IM IN UR BLAGOBOOX STELLIN UR LOLCATS
00:35:27 <dons> (oh i wish ;)
00:36:07 <earthy> liek lolcode wi funk, i want, pleez?
00:36:46 <dons> we need a lolcats plugin for lambdabot, plez
00:36:49 <earthy> (you guys do know about lolcode, right? :))
00:37:28 <dons> data PLZ a = AWSUM_THX a | O_NOES String
00:37:43 <dons> instance Monad PLZ where ..
00:38:08 <earthy> hmmm... :)
00:38:53 <dmead> i'm in ur instance, stealin ur monads
00:39:34 <earthy> case PLZ openFiel of AWSUM_THX -> visible openFiel; O_NOES -> invisible "Error1"
00:39:38 <earthy> nah. don't work.
00:39:52 <Japsu> :D
00:40:20 <earthy> im in yr dicshunary, converting to english. kthxbye.
00:42:00 <dons> i like how a monad instance for PLZ with do notation automatically hides the lolcode
00:42:10 <earthy> ;)
00:42:26 <dons> so @undo becomes a lolcode producer
00:42:55 <earthy> 'haskell, for those times that you want to ignore the LOL kiddies'
00:43:10 <dons> heh
00:43:52 <dons> "Scrap your Lolcode"
00:51:10 <emile> :pl (concat .) . map
00:51:35 <dons> ?pl (concat .) . map
00:51:35 <lambdabot> (=<<)
00:51:40 <dons> ?unpl (concat .) . map
00:51:41 <lambdabot> (\ d g -> concat (map d g))
00:51:45 <dons> ?. pl unpl (concat .) . map
00:51:46 <lambdabot> (=<<)
00:52:26 <osfameron> that's, er, compact
00:54:22 <fuzan> (parsec), is there a safeway to use manyTill in instances in which it may eat the eof and error?
00:54:57 <fuzan> i tried something along the lines of: manyTill foo (try foo2) <|> return "the end!"
00:55:02 <fuzan> yet, it's not catching :(
00:58:38 <Mitar> if I am seeing correctly pressing ctrl-c does not throw some exception which could be cought? so bracket does not call clean-up action on ctrl-c?
00:59:09 <quicksilver> Mitar: not by default, no
00:59:22 <Mitar> how could i do that?
00:59:23 <dons> you can catch that event with signal handlers though.
00:59:24 <quicksilver> Mitar: but you can catch signals and cause them to throw exceptions
00:59:34 <quicksilver> which is a sensible thing to do, probably
00:59:41 <Mitar> posix.signals?
01:00:02 <quicksilver> installHandler sigINT (Catch (throwTo mainthread (ErrorCall "sigint"))) Nothing
01:00:13 <quicksilver> (excerpt from some code of mine)
01:00:17 <ivanm> is it possible to have a where statement for multiple pattern-matching functions?
01:00:42 <ivanm> i.e. foo [] = bar 2, foo (x:xs) = bar x; where bar n = n*2 ?
01:00:50 <quicksilver> you need to set up 'mainthread' first, that's the ID of the thrad you want to send the exceptions to
01:00:58 <quicksilver> ivanm: only by factoring it out as a 'case', I believe
01:01:21 <ivanm> yeah, that's what I figured
01:01:22 <Mitar> hmm, this throwing to thread should be there? or would some throw be enought ...
01:01:23 <Mitar> ?
01:01:31 <ivanm> thanks quicksilver
01:01:33 <Mitar> and in which cases ErrorCall is used?
01:02:28 <quicksilver> Mitar: errorcall is the exception corresponding to (error "sigint")
01:02:39 <quicksilver> Mitar: that was simpler/lazier than defining my own exception type
01:02:45 <Mitar> ok :-)
01:03:09 <Mitar> but why not use ExitException ?
01:07:07 <quicksilver> Mitar: well because I wanted to catch it and not exit, I think :)
01:07:07 <Mitar> hmm, only doint throw does not work ...
01:07:26 <Mitar> currently i successfully disabled it ...
01:07:35 <Mitar> installHandler sigINT (Catch (throw $ ExitException ExitSuccess)) Nothing
01:07:47 <Mitar> but bracket will still cleanup?
01:07:58 <Mitar> if ExitEsception is used?
01:08:58 <quicksilver> yes, bracket should cleanup
01:09:15 <notsmack> $ cat yi.strace | grep -c "No such file"
01:09:15 <notsmack> 2218
01:09:21 <Mitar> but now it just prints ^C and does nothing ...
01:09:25 <notsmack> seems excessive.
01:10:08 <quicksilver> Mitar: I believe you should throwto the mainthread
01:10:24 <Mitar> where do i get mainthread?
01:10:28 <Mitar> or is this global?
01:10:31 <Mitar> (global in haskell?)
01:11:13 <quicksilver>   mainthread <- myThreadId
01:12:03 <Mitar> thanks ...
01:13:23 <Mitar> but this is not portable code anymore? only ghc?
01:22:00 <osfameron> can you call lexical inner subs in haskell?
01:22:32 <osfameron> I was just thinking about this in Perl "this would be so much easier to test if I had lexical subs", and then I realised that there might not be a way to get access to the inner function
01:24:01 <quicksilver> yes, you can call lexcial inner subs
01:24:05 <quicksilver> I'm not sure what you mean :)
01:24:41 <osfameron> like, functions defined in a where or a let
01:24:49 <osfameron> if you wanted to test that those on there own Do The Right Thing
01:24:53 <quicksilver> my $fun = sub { $_[0] + 1 }
01:24:58 <quicksilver> $fun->(5);
01:25:02 <quicksilver> that's a lexical sub....
01:25:16 <quicksilver> oh, sorry
01:25:19 <osfameron> oh... yeah... but that's evil and my colleagues will think I am more insane than they already do if I do that :-)
01:25:23 <osfameron> but yeah, that's a good idea
01:25:30 <quicksilver> I do that sometimes in perl
01:25:33 <quicksilver> when it's the right thing
01:25:39 <ivanm> @hpaste
01:25:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:25:41 <osfameron> it's a good way to factor out a little piece
01:25:50 <quicksilver> or my %dispatch = ( foo => sub { this } , bar => sub { that } )
01:26:05 <quicksilver> I still don't know what you meant by your initial quesiton, though
01:26:10 <ivanm> is hpaste down?
01:26:10 <quicksilver> < osfameron> can you call lexical inner subs in haskell?
01:26:24 <osfameron> of course, it's actually the lexicality that makes it harder to test
01:26:33 <osfameron> I mean "from outside the function in which they're defined"
01:26:41 <osfameron> as in, to test just that little piec
01:26:43 <osfameron> e
01:27:08 <quicksilver> no
01:27:09 <quicksilver> you can't :)
01:27:21 <quicksilver> this is the natural of lexicality, they might have context you'd need to supply
01:27:26 <quicksilver> it's annoying, though
01:27:32 <osfameron> yes, on both counts
01:27:39 <quicksilver> ivanm: appears to be, yes
01:27:41 <osfameron> :-)
01:27:46 <ivanm> :(
01:28:10 <quicksilver> osfameron: you also can't ask ghci for their type
01:28:22 <quicksilver> osfameron: although that is the subject of requests, sometimes
01:28:31 <quicksilver> osfameron: there was a long thread on it recently
01:28:34 <osfameron> quicksilver: oh!  yeah, that a) makes sense, b) is annoying
01:29:06 <osfameron> of course, I guess my newbie practise of writing the type and *then* asking ghci to supply the signature for me, is probably less helpful than thinking it out..
01:29:51 <quicksilver> I don't supply signatures very often, I must admit
01:29:53 <quicksilver> I like type inference
01:30:10 <ivanm> http://pastebin.ca/525176 <-- since hpaste is down :(
01:30:12 <quicksilver> I normally add signatures rather late in the development process, as a piece of documenetation
01:30:17 <quicksilver> and only where I think it's useful
01:30:39 <osfameron> or when ghc has supplied an overly general signature
01:30:52 <osfameron> I do with you could name the parameter at the signature level too
01:30:52 <quicksilver> ivanm: that's the nature of exceptions in lazy code
01:31:00 <quicksilver> ivanm: they're only generated when the value is forced
01:31:06 <ivanm> is there anything I can do to have it print the error message first?
01:31:16 <ivanm> i.e. force the value earlier?
01:31:23 <quicksilver> yes, you could seq force the value
01:31:46 <quicksilver> looks like forcing 't' might be enough
01:31:56 <ivanm> where?
01:32:05 <quicksilver> t `seq` putStrLn
01:32:10 <quicksilver> for example
01:33:02 <Mitar> thanks for all help ... we will see what will profesor say about my homework :-)
01:33:08 <ivanm> quicksilver: k
01:33:29 <quicksilver> ivanm: putStrLn $ printf looks a bit clumsy, I'd just use printf
01:33:34 <ivanm> yup, that works
01:33:38 <quicksilver> ivanm: (although you would then have to add the newline at the end)
01:33:51 <ivanm> quicksilver: will printf go directly to standard out though?
01:33:58 <quicksilver> yes
01:34:25 <ivanm> cool
01:34:31 <ivanm> you learn something new everyday! :D
01:34:33 <ivanm> @botsnack
01:34:33 <lambdabot> :)
01:35:31 <quicksilver> printf returns a magic typeclasse
01:35:36 <quicksilver> this partly allows the varargs magic
01:35:50 <quicksilver> but it also allows it to return a String or an IO (), as required
01:35:59 <ivanm> *nod*
01:36:05 <ivanm> just thought it returned a string
01:36:28 <ivanm> so how would you tell printf to go to a file rather than standard out?
01:36:34 <quicksilver> hPrintf
01:37:07 <ivanm> k, thanks
01:45:42 <dons> signs Sven was getting lazy, IO (Bool, Window, Window, CInt, CInt, CInt, CInt, Modifier)
02:18:13 <mdmkolbe|work> Is there a page explaining the fields for bug reporting? (e.g. priority, severity, etc.)
02:18:32 <dons> no, but most are unused.
02:18:36 <dons> use your judgement
02:24:16 <dons> ?yoyo
02:24:16 <lambdabot> Maybe you meant: todo yow
02:24:18 <dons> do
02:24:21 <dons> ?yowyow
02:24:21 <lambdabot> Unknown command, try @list
02:24:25 <dons> bah
02:24:28 <dons> ?yow yow!
02:24:28 <lambdabot> HELLO KITTY gang terrorizes town, family STICKERED to death!
02:24:34 <dons> oh noes!
02:24:38 <nominolo> > listToMaybe [1,2,3]
02:24:41 <lambdabot>  Just 1
02:24:58 <dons> very useful functions.
02:25:05 <dons> s/s//
02:25:23 <dons> > listToMaybe []
02:25:24 <lambdabot>  Nothing
02:25:32 <notsmack> basically just a safe head?
02:25:38 <notsmack> @src listToMaybe
02:25:38 <lambdabot> listToMaybe []        =  Nothing
02:25:38 <dons> yeah
02:25:38 <lambdabot> listToMaybe (a:_)     =  Just a
02:25:42 <notsmack> yeah, cool
02:25:46 <dons> the natural safe version of head.
02:26:05 <dons> pity we need to import Data.Maybe to get it
02:28:10 <quicksilver> it's normally easy + natural to do your own pattern matching when you need a safe 'head' though
02:28:17 <quicksilver> I guess that reduces the push
02:29:19 <dons> yeah
02:29:45 <quicksilver> otherwise you end up composing listToMaybe with either (a) a pattern match on Just or (b) a use of the combinator 'maybe'
02:29:48 * quicksilver grins
02:29:54 <quicksilver> which hasn't really moved you forward
02:30:15 <quicksilver> it's like pushing down the bubble in 'tackyback' book coverings
02:30:22 <quicksilver> it only moves elsewhere
02:30:28 <dons> yeah, i use maybe
02:30:34 <dons> maybe x y . listToMaybe
02:30:47 <quicksilver> the reason I would use listToMaybe most often, would be in a 'do' expression
02:30:55 <notsmack> @src maybe
02:30:55 <lambdabot> maybe n _ Nothing  = n
02:30:55 <lambdabot> maybe _ f (Just x) = f x
02:30:55 <quicksilver> (a do expression of Maybe type, obviously)
02:31:51 <quicksilver> "maybe x y . listToMaybe l" "case l of [] -> x ; (ll:_) -> y l"
02:31:59 * quicksilver shrugs
02:32:08 <quicksilver> it is a few chars shorter :)
02:32:10 <notsmack> dons: great zipper article, by the way
02:32:21 <dons> oh, thanks.
02:32:30 <dons> yes, i'm about to add the new floating layer, as yet another zipper
02:32:34 <dons> it makes focus handling so natural!
02:32:45 <notsmack> yep
02:32:48 <dons> really a great way of looking at data structures
02:33:25 <dons> quicksilver: shorter, and you get pointfree karma points from Bird
02:33:28 <quicksilver> xmonad: a practical example in Punk programming
02:33:46 * quicksilver devises a new combinator called the safetyping to further dons' cause
02:33:54 <notsmack> what i'd like to read about is the thought process behind making X monadic, i feel like that's the piece of the puzzle i'm missing
02:33:56 <dons> oh, that's an interesting phrase. `Punk programming'
02:33:57 <quicksilver> interesting typo
02:34:06 <dons> notsmack: that's the next article :-)
02:34:07 <quicksilver> 'safety-pin' I meant
02:34:12 <dons> heh
02:34:20 <notsmack> dons: sweet.
02:34:28 <notsmack> dons++
02:34:40 <takamura> hi
02:35:01 <dons> quicksilver: hmm, xmonad is a bit punk, isn't it. kick out the jams^h^h^h bloat
02:35:31 <dons> hi takamura . welcome
02:36:11 <dons> hehe, i like the very haskell replies to the thing on why is Bool in Ord.
02:36:54 <quicksilver> dons: :)
02:38:46 <DRMacIver> quicksilver: Is dons' the strict version of dons?
02:39:19 <Botje> yes, so PLEASE don't ask him the size of the universe
02:39:27 <Botje> we need this dons to keep working!
02:39:53 * dons ^C Termiated
02:40:06 <quicksilver> dons' is the new version of dons, actually
02:40:13 <quicksilver> implemented in pure parallel haskell
02:40:27 <quicksilver> we've taken some of the best features of ndm, too, and incorporated them
02:40:48 <quicksilver> we estimate that when complete it will be able to complete 1 major hierarchical library component per day
02:41:05 <Botje> how much is that in olegs/fortnight?
02:41:09 <dons> oh, that would be good.
02:41:15 <quicksilver> dons: ironically none of the answers was actually the 'simple, correct answer' that False < True because the type is defined as False | True
02:41:44 <dons> yea, I was sitting here with my fromEnum handy, too!
02:42:02 <quicksilver> Botje: we haven't attempted the hardcore type class hackery needed to get a decent number of olegs/fortnight
02:42:03 <osfameron> quicksilver: does "|" in a data type imply ordinality ?
02:42:10 <quicksilver> Botje: we might introduce that in dons''
02:42:15 <quicksilver> osfameron: not in itself, no
02:42:21 <quicksilver> osfameron: but that's how deriving Ord works
02:42:32 <quicksilver> osfameron: (left-to-right across constructors)
02:42:39 <dons> > fromEnum False
02:42:40 <lambdabot>  0
02:42:44 <dons> > fromEnum True
02:42:45 <lambdabot>  1
02:42:49 <dons> gives you the constructor orderings
02:42:55 <dons> (scary, yes!)
02:43:00 <quicksilver> of course you can derive Ord without deriving Enum
02:43:04 <osfameron> ah.  there are magic things about parameter lists and data contents and contructor lists, none of which are really lists, that I dimly perceive as interesting but don't understand
02:43:19 <quicksilver> osfameron: it's basically a limited amount of metaprogramming
02:43:28 <quicksilver> osfameron: which comes for free in the 'deriving' stuff
02:43:31 <dons> the interaction of deriving and constructor ordering is interesting
02:43:35 <quicksilver> osfameron: in a sense it's "outside" the language
02:43:40 <dons> it all makes sense, but its implicit
02:43:46 <quicksilver> dons: and it breaks invariants
02:43:52 <dons> yes!
02:44:06 <quicksilver> dons: the extent to which deriving breaks natural language invariants is underemphasised
02:44:10 <dons> you can radically break code by swapping data Bool = False | True
02:44:11 <quicksilver> (because it's bloody useful)
02:44:15 <dons> the world falls apart there. very scary
02:45:04 <Cale> Constructing polynomial rings in Haskell via a general monoid ring constructor is rather nice.
02:45:07 <dons> perhaps the derivings that are required should be stated explicitly, if they're not
02:45:17 <osfameron> quicksilver: cool, interesting and... I have to get back to work :-(  (damn work!)
02:45:51 <quicksilver> dons: I think it's fair to say that it's bad style to write code that depends on the details of derivings
02:46:07 <quicksilver> dons: would be interesting to have some assessment of how much of the library, or applicaton code, does
02:46:11 <takamura> there is some data type that belongs to Enum and not Ord, in some library?
02:46:23 <dons> Cale: oh, oleg's post on free term algebra is nice
02:46:28 <quicksilver> E.g. it's perfectly fine to depend on *some* kind of Ord instance, e.g. to make Maps
02:46:41 <quicksilver> but it's bad style to depend on the details of a particular ord instance
02:46:47 <quicksilver> (for, e.g., Bool)
02:46:52 <dons> quicksilver: yeah. so fromEnum is not so safe..
02:47:05 <quicksilver> unless it has precise semantics
02:47:08 <quicksilver> fromEnum for Char is fine
02:47:12 <quicksilver> we know what it means
02:47:13 <dons> yeah
02:47:15 <quicksilver> unicode points
02:47:26 <dons> needs to be stated, yes, the precise derivings
02:47:32 <Cale> dons: yeah, this is the case where it's not quite free -- when you multiply the base terms, you use mappend
02:48:02 <flux-_> yeah, I think the developer is very happy he doesn't need to enter 64 -> '@'; 65 -> 'A'; etc ;)
02:48:48 <flux-_> (well, I suppose a string converted to a map would work too..)
02:49:00 <takamura> @help mappend
02:49:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:49:13 <flux-_> ((with the one extremely long string listing all unicode characters))
02:49:44 <quicksilver> damn, I love oleg sometimes
02:49:47 <quicksilver> that's a lovely post
02:50:58 <dons> yeah. very.
02:51:01 <dons> http://programming.reddit.com/info/1uvne/comments
02:51:03 <lambdabot> Title: Haskell mailing list gem: an embedded free term algebra (reddit.com)
02:51:06 <dons> ^^ mod that :-)
02:52:53 <dons> oh no. someone posted my lol monad mailing list item
02:53:08 <dons> `
02:53:16 <dons>  LOLmonad? AWSUM_THX' :}
02:53:47 <Botje> we should totally use that when we implement lolcode.
02:54:18 <dons> i think so.
03:00:34 <Cale> I should at some point write a brief article about the part of what I've been doing which might be useful to other people :)
03:01:15 <earthy> dons: shouldn't that have been 'OH NOES. SUM1 P0STd MAH LOLMONAD MAILING LIST THINGY' ? :)
03:01:26 <dons> heh
03:01:30 <mrsolo> you know.. hopefully this will blow over
03:01:35 <earthy> yah
03:01:48 <mrsolo> you don't want this year's ICFP to implement that
03:01:57 <earthy> it's reasonably fun for now, just as All Your Base was reasonably funny back when
03:02:12 * earthy has a strong feeling this year's ICFP will not be quite ideally suited for lolcode
03:02:16 <earthy> ;)
03:02:34 <quicksilver> I'm susceptible to cute pictures of cats, so lolcats caught me on one of my vulnerable points
03:02:44 <earthy> ofcourse, I has can nothing of knowledge of icfp contests
03:02:56 <quicksilver> if it had been 'loldogs' in the first place I would have hated it, surely
03:03:01 <dons> haha. "not be quite ideally "
03:03:09 <dons> but surely a prize for entering in lolcode..
03:03:14 <earthy> quicksilver: heck, even my (quite non-nerdy) gf loved the lolcats. :)
03:03:47 <dons> yay, order is restored to the haskell-cafe@ universe:
03:03:48 <earthy> (she loved tinkering around with the musical movement in the puppet we bought for our baby-to-be though)
03:03:49 <dons> "   Thanks all. I just found this list is very nice. Everybody
03:03:49 <dons>    are so friendly.
03:03:49 <dons> "
03:04:36 <quicksilver> earthy: mine (well, wife) too. lolcats are powerful
03:04:40 <earthy> heh. 'LOLCODE is the choice of determining hackers'? :)
03:04:49 <earthy> the horror. :)
03:05:08 <dons> heh
03:05:13 <earthy> (or what was it, discriminating? discerning? I forget)
03:05:24 <dons> yes, lolcats are serious business.
03:05:42 <dons> `discriminating'. you sure you want to organise this? :-)
03:05:48 * earthy isn't. ;)
03:05:58 * earthy doesn't know nothing about the ICFP contest
03:06:03 <dons> hmm, i really wouldn't be surprised if someone tried to submit lolcode
03:06:10 * earthy is not even employed at Utrecht University anymore.
03:06:14 <dons> ah of course. yes.
03:06:38 <earthy> (that is to say, Johan Jeuring still is my direct boss...)
03:06:52 <dons> ah, insider trading, no doubt.
03:06:56 <earthy> (so I don't get to enter anyhow ;))
03:07:35 <ivanm> @pl Int -> Ord a
03:07:35 <lambdabot> (line 1, column 5):
03:07:35 <lambdabot> unexpected ">" or "-"
03:07:35 <lambdabot> expecting variable, "(", operator or end of input
03:07:47 <ivanm> @pl (Ord a) => Int -> a
03:07:47 <lambdabot> (line 1, column 16):
03:07:48 <lambdabot> unexpected ">" or "-"
03:07:48 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
03:07:54 <ivanm> @hoogle (Ord a) => Int -> a
03:07:55 <ivanm> duh
03:07:55 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
03:07:55 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
03:07:55 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
03:08:09 <quicksilver> ivanm: no such function
03:08:10 <ivanm> @hoogle Int -> Bool
03:08:10 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
03:08:11 <pejo> earthy, does he have a company on the side, or did you change university?
03:08:19 <quicksilver> ivanm: consider the definition of 'Ord'
03:08:20 <earthy> the latter
03:08:22 <quicksilver> ivanm: no constants
03:08:24 <dons> btw, xmonad 0.2 is released to the world, for those who didn't see. http://xmonad.org/
03:08:26 <lambdabot> Title: xmonad : a tiling window manager
03:08:29 <superfrog> Hi! My GHC/GHCi doesn't find Control.Monad.State. Any ideas?
03:08:31 <dons> and a patch for floating mode is now in the darcs branch.
03:08:40 <ivanm> @type ord
03:08:42 <lambdabot> Char -> Int
03:08:44 <quicksilver> superfrog: you haven't installed mtl?
03:08:51 <dons> ivanm: you wanted floating mode, didn't you? --> http://www.cse.unsw.edu.au/~dons/tmp/float.png
03:08:51 <earthy> he's a full prof (and currently dean) at Open University The Netherlands
03:09:01 <earthy> and an associate prof at UU
03:09:02 <quicksilver> superfrog: what OS?
03:09:03 <superfrog> let me see
03:09:13 <superfrog> Ubuntu, Feisty Fawn.
03:09:20 <quicksilver> dons: interesting. placement is a bit odd
03:09:21 <ivanm> dons: excellent! how does it work?
03:09:25 <ivanm> floating frames?
03:09:32 <quicksilver> superfrog: there is some package called something like libghc6-mtl-dev
03:09:40 <ivanm> quicksilver: I'm after a function that will turn 0 -> False, 1 -> Bool
03:09:42 <quicksilver> superfrog: or some rearrangement of those letters :)
03:09:43 <dons> yeah, there's a set of windows that are tiled using their own hints, and moved with the mouse
03:09:47 <quicksilver> ivanm: toEnum ?
03:09:48 <dons> floating on top of the tiled layer
03:09:49 <superfrog> ghc-pkg doesn't list mtl, so it probably isn't installed
03:09:54 <TSC> ivanm: fromEnum
03:09:59 <dons> quicksilver: placement?
03:10:02 <ivanm> @type fromEnum
03:10:04 <lambdabot> forall a. (Enum a) => a -> Int
03:10:05 <superfrog> ok, thanks. I'll try that.
03:10:07 <quicksilver> toEnum
03:10:09 <ivanm> @type toEnum
03:10:11 <lambdabot> forall a. (Enum a) => Int -> a
03:10:11 <ivanm> that's it...
03:10:15 <quicksilver> superfrog: yes, tehre should be an ubuntu pacakge for it
03:10:16 <ivanm> I was after enum, not ord :s
03:10:17 <ivanm> stupid me
03:10:21 <ivanm> thanks quicksilver++
03:11:19 <ivanm> oh, wait, is there an even function?
03:11:21 <ivanm> @hoogle even
03:11:21 <lambdabot> Prelude.even :: Integral a => a -> Bool
03:11:22 <lambdabot> GHC.ConsoleHandler.ConsoleEvent :: data ConsoleEvent
03:11:22 <lambdabot> System.Console.Readline.setEventHook :: Maybe (IO ()) -> IO ()
03:11:33 <ivanm> thats what I was trying to get anyway :s
03:11:39 * ivanm didn't even think of that...
03:13:17 <dons> http://enhyper.blogspot.com/2007/05/functional-programming-beer-in-evening.html
03:13:19 <lambdabot> Title: Enhyper, http://tinyurl.com/yu2y2u
03:13:25 <earthy> weird. ten years ago you were almost a pariah when you did functional programming, firmly relegated to academia
03:13:30 <dons> "I'm setting up a beer around Smithfield in London, tentatively on the 7th June 2007, with Dominic
03:13:33 <dons> Steinitz"
03:13:48 <earthy> these days, it's almost as if you're to be shunned if you don't at least have an interest in it...
03:13:53 <dons> earthy: things are looking up! :-)
03:14:18 <dons> earthy: lisp ruined the 90s for us.
03:14:23 <dons> lisp and the ai bubble
03:14:27 <quicksilver> earthy: even 10 years ago, the value of things like Z was recognised
03:14:34 <quicksilver> earthy: (for specification, not programming)
03:14:39 * earthy knows
03:14:41 <quicksilver> but it's not an unrelated thing
03:14:49 <earthy> but still
03:15:06 <earthy> I do recall the glaring failure that was HILT
03:15:09 <quicksilver> c.f. good work done by 'praxis critical systems' and its predecessor companies
03:15:29 <dons> and it helps that there's not much innovation happening on the imperative side of the fence. all the good new stuff coming out is functional
03:15:53 * earthy nods
03:16:36 <earthy> methinks Java actually killed the second half of the 90s for functional programming
03:16:41 <quicksilver> dons: it might look like that from where you're standing
03:16:56 <quicksilver> dons: but there is plenty of innovation happening in Java and .NET from where some other people are standing
03:17:06 <dons> yeah, things like LINQ ;)
03:17:09 <quicksilver> (all depends what kind of thing qualifies as innovation)
03:17:10 <earthy> .NET, yes. Java? not so much
03:17:22 <dons> but true, my field of view is biased
03:17:24 <superfrog> quicksilver: works like a charm, thanks
03:17:30 <quicksilver> superfrog: good stuff :)
03:17:36 <quicksilver> superfrog: really mtl should be default
03:17:40 <quicksilver> superfrog: IMO
03:17:55 <superfrog> quicksilver: I tend to agree ;-)
03:19:16 <araujo> morning
03:19:18 <notsmack> whoa, since when does gtk2hs work from ghci?
03:19:27 <siti> .11 release?
03:19:30 <dcoutts> yep
03:19:34 <notsmack> beautiful.
03:19:42 <dcoutts> and prior to ghc-6.4.1 as well
03:19:55 <DRMacIver> earthy: I think there's rather a lot of innovation happening on the Java front. It's just mostly not in the PLT side of things (Stuff like AOP aside)
03:20:05 <dcoutts> it was ghc-6.4.1 that made ghci use the threaded rts that causes us so much trouble
03:20:14 <quicksilver> note that there are caveats with threads and ghci even when it works
03:20:21 <dcoutts> yes, don't use them :-)
03:20:26 <quicksilver> you get your prompt back when the 'main thread' of your computation terminates
03:20:35 <quicksilver> but the other threads don't get killed at that point
03:20:40 <quicksilver> unlike a true 'main' RTS
03:20:46 <quicksilver> which reaps threads when main dies
03:20:57 <yakov> hi
03:20:58 <quicksilver> dcoutts: I think it's OK as long as you understand how it works, isn't it?
03:20:59 <dcoutts> at least don't use threads with gtk2hs in ghci
03:21:07 <dcoutts> quicksilver: right
03:21:37 <notsmack> noted.
03:27:02 <takamura> hi yakov
03:32:28 <quicksilver> actually, maybe that's a feature request for ghci
03:32:47 <quicksilver> a command to run an IO () 'as if it was main' <--- i.e. killing off other threads when it terminates
03:35:51 <ivanm> dons: in that floating screenshot, what are you using for the panel?
03:39:38 <siti> with using the ffi how do I have a variable in haskell that retrieves the result via a ptr
03:39:39 <siti> e.g.
03:39:55 <siti> some_functinon(int *outp);
03:42:03 <ClaudiusMaximus> @hoogle alloca
03:42:03 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
03:42:04 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
03:42:04 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
03:42:50 <siti> hmm ok
03:43:12 <ClaudiusMaximus> something like that, or something else in Foreign.Marshal.Array
03:43:46 <siti> yep
04:01:26 <quicksilver> hmm
04:01:50 <quicksilver> lots of people consistently confusing reimplementing something *in* haskell, with reimplementing something *within* haskell
04:02:10 <notsmack> quicksilver: for instance?
04:02:38 <quicksilver> notsmack: in the mathematica thread
04:02:51 <quicksilver> notsmack: confusing how easy it would be to implement a mathematica-like language in haskell
04:03:02 <quicksilver> notsmack: with wheter or not haskell's pattern-matching is like mathematicas
04:03:08 <notsmack> haha
04:03:10 <quicksilver> confusing source language and implementation language
04:03:14 <notsmack> yeah
04:06:33 <fasta> Is there some function somewhere that given a list of numbers and a base returns that number in an Integer? (easy to write, otherwise)
04:07:52 <TSC> Should be easy to write with a fold
04:09:32 <Jaak> > (\base -> foldl (\m n -> n + base*m) 0) 2 [1,0,0,0]
04:09:33 <lambdabot>  8
04:15:34 <Jaak> > (\base -> reverse . unfoldr (\n -> if n == 0 then Nothing else Just ((\(x,y) -> (y,x)) $ n `divMod` base))) 2 8 -- terrible!
04:15:36 <lambdabot>  [1,0,0,0]
04:16:47 <Botje> > take 5 $ unfoldr (Just . (flip divMod 2)) 42
04:16:49 <lambdabot>  [21,0,0,0,0]
04:16:53 <Botje> heh. :P
04:17:20 <Botje> > take 5 $ unfoldr (Just . (\(a,b)->(b,a)) . (flip divMod 2)) 42
04:17:21 <lambdabot>  [0,1,0,1,0]
04:17:29 <Botje> would that help, somehow? :P
04:17:31 <int-e> fasta: if your numbers are huge, you'd be better off with combining the list in pairs and then treat the result as base m^2 numbers. (just because then you'll be multiplying numbers of similar size every time)
04:17:49 <int-e> fasta: but I know of no library function that does that.
04:17:56 <sieni> @pl (\base -> reverse . unfoldr (\n -> if n == 0 then Nothing else Just ((\(x,y) -> (y,x)) $ n `divMod` base)))
04:17:56 <lambdabot> (reverse .) . unfoldr . ap (flip if' Nothing . (0 ==)) . ((Just . uncurry (flip (,))) .) . flip divMod
04:18:08 <opqdonut> nice
04:18:58 <int-e> @type Numeric.readInt
04:19:00 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
04:19:17 <int-e> I think that's as close as it gets, functionality wise.
04:19:45 <fasta> int-e: I only needed it for testing purposes.
04:19:53 <fasta> int-e: i.e. no huge numbers.
04:20:28 <int-e> > readInt 2 (const True) ord (map chr [1,0,0,0])
04:20:30 <lambdabot>  [(8,"")]
04:20:44 <int-e> [obviously ;-)]
04:22:36 <quicksilver> > readInt 300 (const True) ord (map chr [2,150])
04:22:38 <lambdabot>  [(750,"")]
04:22:41 <quicksilver> interesting
04:22:44 <fasta> > readInt 26 (const True) ord (map chr [1,0,0,1])
04:22:45 <quicksilver> works with bases > 256 too :)
04:22:45 <lambdabot>  [(17577,"")]
04:24:13 <fasta> How about with the LSB at the head?
04:24:15 <int-e> > maxBound :: Char
04:24:16 <lambdabot>  '\1114111'
04:24:26 <quicksilver> fasta: reverse it? :)
04:24:38 <int-e> fasta: use foldr instead of foldl?
04:24:41 <fasta> quicksilver: Already did that, I meant something better :)
04:24:45 <fasta> int-e: also did that
04:24:46 <quicksilver> ". Zipper can be viewed as a delimited continuation reified as a data structure" (oleg)
04:24:50 <int-e> fasta: really I wasn't serious about using readInt
04:24:55 <quicksilver> interesting
04:25:11 <quicksilver> somehow this ties up neatly with the observation that lazy evaluation lets you use data structure as control
04:25:30 <quicksilver> (although zippers remain useful in strict languages)
04:29:42 <Cheery> "this little computer went to sleep"
04:29:54 <Cheery> "THIS LITTLE COMPUTER OUTPUTTED ALL CAPS"
04:30:26 <Cheery> "This little computer costed like hell and does not work"
04:30:38 <Cheery> ..
04:31:13 <Igel> @users
04:31:14 <lambdabot> Maximum users seen in #haskell: 342, currently: 311 (90.9%), active: 39 (12.5%)
04:31:24 <Cheery> map play computers
04:33:04 <fasta> Ok, found another bug in GHC-6.6.1
04:33:30 <fasta> I wonder why it's always me with the problems :?
04:33:42 <quicksilver> bug-magnet
04:36:08 <Cheery> uugh, I didn't know learning can be this painful.. I just learned how C procedure calling conventions work
04:36:34 <fasta> Cheery: and how do they work?
04:36:38 <Cheery> they don't
04:36:48 <opqdonut> :D
04:37:22 <Cheery> heh, just kidding. it's just incredibly myriads of tasks it goes through per each function call
04:39:26 <Cheery> after playing with forth for a while, it looks a lot like the stack would be razed each time when C-procedure is called
04:40:30 <Cheery> or well, razed AND raped
04:40:44 <fasta> Ok, no bug in GHC-6.6.1 :) That's good.
04:40:59 <opqdonut> usually it isn't a bug
04:41:07 <fasta> It only kills the HEAD.
04:47:15 <quicksilver> Cheery: you say that as if razing the stack is a problem?
04:47:22 <quicksilver> Cheery: that's what frame pointers are for, after all
04:47:41 <quicksilver> although in practice, of course, real C compilers put arguments in registers not on the stack
04:47:49 <quicksilver> especially on modern register-heavy CPUs
04:53:35 <Cheery> quicksilver: it's not a problem, it's just so incredibly cumbersome
04:54:18 * roconnor wonders if people are talking about the evil mangler
04:54:20 <Cheery> couple of instructions must be executed just because of procedure call
04:54:38 <fasta> Cheery: I would be surprised if it would be more complicated than needed.
04:54:41 <quicksilver> procedure calls are a handy abstraction though
04:55:03 <quicksilver> and the feature that parameters are 'fresh copies' is essentially for sensible re-entrance, e.g. recursion
04:55:21 <fasta> Cheery: The last time I played with a disassembly from gcc it didn't have real surprises for me.
04:55:24 <quicksilver> how would you do it different?
04:55:47 <Cheery> fasta: I neither think it'd be more cumbersome than needed, it just changes my view on such things
04:56:06 <Cheery> not sure how would I do it different
04:56:15 <fasta> Cheery: so it isn't cumbersome, your temporal opinion is that way :)
04:56:42 <quicksilver> note that, as I said before, optimising compilers skip the stack frame when they can
04:56:50 <quicksilver> and just stuff params in registers
04:57:12 <Cheery> I've used to see much simpler things than that, it was a bit of surprise that it was there
04:58:21 <Cheery> quicksilver: yes, that's obvious, it's quite simple way to remove some redundant instructions
04:59:29 <quicksilver> of course, you can't do that and still call it 'C calling conventions'
04:59:35 <quicksilver> so you can't use it over library boundaries
04:59:51 <quicksilver> although I vaguely remember that old versions of Mac OS had a hybrid calling convention
04:59:52 <Cheery> yeh, that's also obvious
05:00:04 <quicksilver> which explicitly said that if there was only one argument it was passed in a register
05:00:10 <quicksilver> or maybe the first arg always was
05:00:11 <quicksilver> I don't remember
05:01:20 <Cheery> only thing I hope is that the most functions from standard library are inlined into the code
05:01:31 <quicksilver> in C, or in haskell?
05:01:35 <Cheery> in C
05:01:39 <quicksilver> in C, no standard library functions can be inlined
05:01:54 <Cheery> things like powering, getchars, min and max etc.
05:01:55 <quicksilver> you can't do 'cross-module inlining' in C
05:02:04 <ibid> quicksilver: sure they can
05:02:07 <quicksilver> some of these things are compiler macros, though
05:02:15 <quicksilver> min and max are, certainly
05:02:26 <ibid> quicksilver: that is, the compiler can. the user is not allowed to, but who wants to?
05:02:43 <quicksilver> ibid: in the standard setup, the compiler doesn't have access to the source of the function
05:02:57 <quicksilver> ibid: so it physically can't inline
05:03:17 <quicksilver> inline stuff is mostly macroed
05:03:51 <quicksilver> Occasionally you see code in .h files but that's fiddly. IIRC it requires compiler/linker support and only really became popular after C++ came out
05:04:00 <quicksilver> C++ puts lots of code in its .h files for efficiency
05:04:13 <ibid> quicksilver: ah, but that's an implementation deficiency, the standard does not forbid it
05:04:13 <quicksilver> (but this breaks modularity of shared libraries completely)
05:04:24 <quicksilver> ibid: ah yes, absolutely
05:04:28 <Cheery> it's funny that in the stdio you have much of procedure calls in critical places
05:04:37 <quicksilver> ibid: I'm speaking of the particular implementation that I'm familiar with, not the standard
05:04:59 <quicksilver> Cheery: at lot of the things you think are procedure calls are macros for that reason
05:05:00 <ibid> Cheery: stdio actually includes unsafe macros in critical places :)
05:05:07 <Cheery> if you've seen plan9's bio or some of game-programmers' roundarounds for those problems, they are interesting
05:05:30 <quicksilver> but losing shared library modularity is a fairly high price to pay
05:05:34 <Cheery> plan9's bio is mostly macros for IO
05:05:36 <quicksilver> (but that is the price we pay in haskell, too)
05:05:43 <ibid> quicksilver: i just have this thing about people claiming stuff about a language when they're really talking about particular implementations :)
05:06:16 <quicksilver> ibid: it's a very good point
05:06:40 <quicksilver> ibid: although that confusion already existed when we began talking about 'C calling conventions'
05:06:47 <quicksilver> ibid: since that is also an implementation thing obviuosly
05:07:12 <fasta> @photontorpedo
05:07:13 <lambdabot> cmon Im asking cool questions
05:07:29 <fasta> @girl17
05:07:29 <lambdabot> I'm in Moscow, Russia
05:09:14 <fasta> Where is QuickCheck in 6.6.1?
05:10:15 <Igloo> It's an extralib, if that's what you mean
05:10:40 <fasta> It is Test.QuickCheck in 6.7.something
05:10:49 <fasta> Is it the same in 6.6.1?
05:10:56 <fasta> (in extra libs)
05:10:56 <Igloo> Yes
05:11:06 <ibid> quicksilver: well, "C calling convention" is a term that's meaningless in a language context, so it obviously talks about implementation strategies :)
05:11:09 <fasta> Ok, that means I don't have the package installed. Thanks
05:14:54 <quicksilver> ibid: agreed, but that was the context in which I started talking about C optimisers :)
05:16:14 <ibid> quicksilver: yeah, and i jumped in without reading the backlog, typical me :)
05:16:52 <quicksilver> really code should be half-compiled
05:17:05 <quicksilver> and a final 'optimise-and-inline' step could be performed just before launch
05:17:17 <quicksilver> or, perhaps, performed whenever a new library is installed
05:17:20 <quicksilver> depending how slow it is
05:17:27 <quicksilver> this is the solution to modularity + optimisation
06:28:08 <nominolo> @hoogle (a -> m [b]) -> [a] -> m [b]
06:28:08 <lambdabot> No matches, try a more general search
06:28:35 <nominolo> :t \f xs -> mapM f xs >>= return . concat
06:28:39 <lambdabot>     Ambiguous occurrence `mapM'
06:28:39 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:28:51 <nominolo> :t \f xs -> Control.Monad.mapM f xs >>= return . concat
06:28:52 <quicksilver> nominolo: looks like concat . sequence . map ?
06:28:53 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m [a1]) -> [a] -> m [a1]
06:29:00 <quicksilver> :t concat . sequence . map
06:29:02 <lambdabot>     Ambiguous occurrence `sequence'
06:29:02 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
06:29:11 <quicksilver> :t concat . Control.Monad.sequence . map
06:29:13 <lambdabot>     Couldn't match expected type `[m a]'
06:29:13 <lambdabot>            against inferred type `[a1] -> [b]'
06:29:16 <jfoutz> @src mapM
06:29:16 <lambdabot> mapM f as = sequence (map f as)
06:29:31 <nominolo> i was looking for concatMapM
06:30:04 <jfoutz> :t sequence . concatMap
06:30:06 <lambdabot>     Ambiguous occurrence `sequence'
06:30:06 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
06:30:19 <SamB_XP> hmm, why does Control.Monad.Writer export a different `sequence'?
06:30:37 <quicksilver> SamB_XP: I don't know, it's annoying
06:30:38 <nominolo> jfoutz: d'oh.  thanks
06:30:44 <SamB_XP> @type Control.Monad.Writer.sequence
06:30:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:30:46 <jfoutz> i don't know if that'll work...
06:30:55 <SamB_XP> WTH!
06:31:00 <quicksilver> \f -> concat . sequence . map f
06:31:04 <quicksilver> :t \f -> concat . sequence . map f
06:31:06 <lambdabot>     Ambiguous occurrence `sequence'
06:31:06 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
06:31:09 <jfoutz> i need the same thing though. i have a list of maybe lists... and i want maybe list.
06:31:10 * quicksilver screams
06:31:23 <quicksilver> :t \f -> concat . Control.Monad.sequence . map f
06:31:26 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:32:01 * quicksilver goes to try in his private ghci before spamming the channel more :)
06:32:29 <SamB> @index sequence
06:32:29 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:32:37 <nominolo> jfoutz: yes, it will
06:32:54 <jfoutz> heh, good to know :)
06:33:12 <SamB> arg. the web interface has no lambdabot process!
06:33:43 <quicksilver> :t \f -> (liftM concat) . mapM f
06:33:46 <lambdabot>     Ambiguous occurrence `mapM'
06:33:46 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:33:53 <quicksilver> :t \f -> (liftM concat) . Control.Monad.mapM f
06:33:55 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
06:33:56 <nominolo> > Control.Monad.sequence.concatMap [[Just 3],[Just 2]]
06:33:57 <lambdabot>  Couldn't match expected type `a -> [b]'
06:34:07 <quicksilver> nominolo: theres one fairly simple version
06:34:12 <nominolo> > Control.Monad.sequence . concatMap $ [[Just 3],[Just 2]]
06:34:12 <lambdabot>  Couldn't match expected type `[m a]'
06:34:36 <quicksilver> reasoning: you want to do a mapM, and then do a concat 'inside the monad'
06:34:40 <nominolo> > Control.Monad.sequence . concatMap return $ [[Just 3],[Just 2]]
06:34:41 <lambdabot>  [[Just 3,Just 2]]
06:34:59 <quicksilver> i.e. [a] -> m  [[b]] -> m [b]
06:35:13 * SamB greps for sequence...
06:35:14 <nominolo> quicksilver: actually it should make a difference if i concat inside or outside the monad
06:35:21 <quicksilver> nominolo: yes, it could :)
06:35:27 <nominolo> s/should/shouldn't/
06:35:28 <nominolo> how?
06:35:37 <nominolo> in the list monad maybe?
06:36:07 <nominolo> liftM concat is essentially non-monadic
06:36:11 <nominolo> it just pretends to be
06:36:16 <quicksilver> hmm
06:36:19 <quicksilver> no, you're right
06:36:25 <quicksilver> well I think you only can concat 'inside the monad'
06:36:34 <quicksilver> because you only ever have a list-of-lists 'inside the monad'
06:37:01 <nominolo> > Control.Monad.sequence . concatMap Just $ [[1..3],[6]]
06:37:02 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Maybe a'
06:37:10 <quicksilver> if you had, e.g., [[m b]] at some point, then you could compare concatting before to concatting afterward
06:37:15 <quicksilver> but you never have that
06:37:22 <quicksilver> you have [m [b]] and m [[b]]
06:37:25 <quicksilver> but never [[m b]]
06:37:55 <SamB> oh, is the other sequence from TH?
06:38:14 <SamB> > Language.Haskell.TH.Syntax.sequence
06:38:15 <lambdabot>   Not in scope: `Language.Haskell.TH.Syntax.sequence'
06:38:33 <nominolo> > concatMap Just $ [[1..3],[6]]
06:38:34 <lambdabot>  Couldn't match expected type `[b]' against inferred type `Maybe a'
06:38:55 <SamB> nah...
06:38:56 <nominolo> > concatMap (map Just) $ [[1..3],[6]]
06:38:57 <lambdabot>  [Just 1,Just 2,Just 3,Just 6]
06:39:14 <nominolo> > Control.Monad.sequence . concatMap (map Just) $ [[1..3],[6]]
06:39:15 <lambdabot>  Just [1,2,3,6]
06:39:31 <Jaak> hrm. hpast is down
06:39:36 <quicksilver> SamB: nope
06:40:22 <nominolo> > Control.Monad.sequence . concat $ [[Just 1, Just 2, Nothing],[Just 42]]
06:40:24 <lambdabot>  Nothing
06:40:40 <SamB> :t Control.Arrow.sequence
06:40:42 <lambdabot> Not in scope: `Control.Arrow.sequence'
06:41:25 <quicksilver> SamB: it is the same sequence, re-exported via a different route
06:41:32 <quicksilver> SamB: I'm not sure why the hiccup occurs
06:41:39 <SamB> ah.
06:41:47 <quicksilver> > Control.Monad.sequence [[1],[2]]
06:41:49 <lambdabot>  [[1,2]]
06:41:55 <SamB> GHC bug, then?
06:41:58 <quicksilver> > Control.Monad.Writer.sequence [[1],[2]]
06:42:00 <lambdabot>  [[1,2]]
06:42:04 <quicksilver> no, lambdabot bug
06:42:15 <SamB> how could it be a lambdabot bug?
06:42:21 <nominolo> re-export if Control.Monad in Control.Monad.Writer
06:42:27 <quicksilver> it's lambdabot's automatic module import magic that screws it up
06:42:28 <nominolo> s/if/of/
06:42:46 <SamB> I imported all those modules in GHCi and sequence worked fine...
06:42:52 <quicksilver> exactly
06:42:56 <quicksilver> it's a lambdabot bug :)
06:43:19 <quicksilver> ghc normally understands when a same module is imported twice 'its the same'
06:43:24 <quicksilver> I'm not sure why LB doesn't
06:43:27 <SamB> or maybe it is a GHC bug
06:43:32 <quicksilver> maybe an infelicity in hs-plugins?
06:43:37 <SamB> where somehow the libraries got built funny
06:44:19 <ivanm> @seen dons
06:44:19 <lambdabot> dons is in #rwh, #ghc, #haskell-overflow, #xmonad, #haskell-soc and #haskell. I last heard dons speak 16m 23s ago.
06:44:25 <SamB> we should get someone with an account on lambdabot's box (i.e. dons) to try that in GHCi
06:45:00 <SamB> and then ask dons to make the extreme error-shortening only apply to in-channel requests
06:45:21 <ivanm> dons: I'm trying to configure a dualhead setup using xmonad, but whenever I use my dualhead server layout, I get xmonad: fatal error: request code=2, error code=10
06:45:22 * fasta finds it annoying that when quickcheck tests code that throws an exception does't show the input to generate that exception
06:45:56 <fasta> But probably that already is possible in some way I am not aware of....
06:46:01 <quicksilver> SamB: you do actually get long error messages on queries
06:46:04 <quicksilver> SamB: sometimes, at least
06:46:05 <fasta> Is it?
06:47:10 <SamB> fasta: hmm, well, I know the streams-based Data.List implementation has some testing framework that does tests involving bottom...
06:47:56 <SamB> also istr some dirty library for replacing bottoms with values?
06:48:58 <SamB> uses unsafePerformIO, seq, and catch to do it
06:53:16 <quicksilver> what is a 'delimited' continuation, as distinct from an ordinary continuation?
06:54:51 <dcoutts> quicksilver: it has an end point, check google for more detail
06:54:51 <jfoutz> is that the down the stack only type continuation? scheme would call it an escape continuation? just a guess...
06:55:19 <quicksilver> dcoutts: and end point after which you 'rejoin normal flow' ?
06:55:37 <dcoutts> quicksilver: I'm a bit hazy on it
06:55:57 <fasta> jfoutz: no
06:56:53 <fasta> Delimited continuations aren't as "main-stream" as normal continuations.
06:57:24 <jfoutz> that's a pretty amusing thing to say, given the popularity of continuations in the general programming world :)
06:57:27 <fasta> Maybe someone could use dolphins to explain them ;)
06:57:43 <fasta> jfoutz: yes, that's why I put it in quotes.
07:00:18 <kilimanjaro> quicksilver, an escape procedure escapes and never comes back
07:00:33 <SamB> http://lambda-the-ultimate.org/node/606#comment-5152
07:00:34 <lambdabot> Title: How to remove a dynamic prompt: static and dynamic delimited continuation operat ...
07:00:39 <SamB> is this usegul?
07:00:51 <quicksilver> kilimanjaro: and what is the relationship between escapes and delimited?
07:01:24 <SamB> s/g/f/
07:02:26 <kilimanjaro> hmm let me think about the best way to explain
07:03:04 <kilimanjaro> a full continuation will basically plug a value into the expression currently waiting to be evaluated (in the call stack)
07:03:08 <kilimanjaro> and it never comes back to the callee
07:03:16 <fasta> AFAIK, a standard continuation is a delimited continuation, but with a reset at infinity.
07:03:20 <kilimanjaro> yes
07:03:41 <quicksilver> kilimanjaro: ok, I understand that much
07:06:14 <fasta> I wonder how many people found applications of del. cont. I'd be surprised if it would be more than 500.
07:06:23 <jfoutz> so rather than abandoning the work you've done when you call the continuation, you can jump back to that execution point?
07:07:07 <fasta> I think #scheme knows this better.
07:07:28 <fasta> The PLT manual also says some things about them.
07:07:39 <quicksilver> fasta: oleg compares zippers to delimited continuations
07:07:45 <quicksilver> fasta: that is, in fact, why I was asking
07:07:57 <quicksilver> to try to understand the comparison he was making
07:08:52 <kilimanjaro> sorry I was buy moving stuff
07:08:52 <fasta> quicksilver: I know you did.
07:09:55 <fasta> quicksilver: have you seen his implementation?
07:10:27 <fasta> quicksilver: it uses reified delimited continuations, AFAIK, in the same way as callCC is implemented in Haskell.
07:10:51 <quicksilver> fasta: yes, I read through it
07:11:02 <quicksilver> fasta: but now I want to know what the 'delimited' bit means:)
07:11:13 <quicksilver> are all ContT-style continuations delimited, then?
07:11:29 <fasta> quicksilver: when you read the Scheme implemention too, you will understand, maybe.
07:11:33 <dolio> No, they're full continuations.
07:11:37 <fasta> quicksilver: I don't fully understand it myself.
07:11:55 <fasta> quicksilver: not enough to explain in any way.
07:11:59 <quicksilver> ;)
07:12:41 <nominolo> quicksilver: the "delimiting" part is specified by some kind of prompt
07:13:03 <dolio> I'm not sure I fully grasp them either...
07:13:18 <nominolo> "fully", me neither
07:13:30 <quicksilver> so if a classic model of continuation is (a -> r) -> r
07:13:31 <fasta> This would be an interesting "Ask Reddit" question ;)
07:13:35 <quicksilver> where does the prompt go?
07:13:42 <nominolo> quicksilver: it depends
07:13:45 <dolio> But, I think the idea is that with full continuations, when you capture a continuation, it's essentially a reification from where you were, to the end of the program.
07:13:50 <nominolo> that's why there are 4 variants
07:14:01 <nominolo> -F- +F+ -F+ and +F-
07:14:14 <quicksilver> be careful with those flouride ions
07:14:17 <dolio> Whereas when you capture a delimited continuation, you only capture a segment up to the marker.
07:14:19 <quicksilver> they're very reactive
07:14:31 <nominolo> depending on the continuation includes the prompt or not, and whether the prompt will be consumed or not when the continuation is run
07:14:36 <quicksilver> dolio: ah, ok. that makes some sense in a 'hand-wavy' intuitive way at least :)
07:14:52 <dolio> quicksilver: Yeah. :) I'm not sure how accurate that is.
07:16:43 <nominolo> http://www.cs.indiana.edu/~sabry/papers/contFoundationLong.pdf
07:17:00 <fasta> What is the meaning of "prompt", btw?
07:17:07 <nominolo> is the description of the implementation DCs in haskell
07:17:17 <nominolo> fasta: like in a shell
07:17:28 <nominolo> it's a marker
07:17:33 <quicksilver> nominolo: invalid UR, apparently
07:17:37 <nominolo> and a first-class value
07:17:57 <quicksilver> nominolo: oops, copy-paste error
07:17:58 <nominolo> quicksilver: works fine here
07:18:02 <fasta> nominolo: ok, why is it called a prompt?
07:18:20 <nominolo> fasta: because it was derived from shell-lingo
07:18:25 <nominolo> (i guess)
07:18:57 <fasta> nominolo: I mean why are prompt in del. cont. called prompts?
07:19:00 <fasta> prompts*
07:19:17 <nominolo> fasta: they were introduced originally to avoid that programs started from the repl to capture the part that invoked the prompt.
07:19:49 <nominolo> modulo grammar
07:20:13 <fasta> nominolo: but normal continuations can't do that, AFAIK.
07:20:29 <fasta> nominolo: they can only capture the return to the interpreter.
07:20:54 <nominolo> fasta: yes, but if you're REPL/shell runs *in* the interpreter?
07:21:02 <nominolo> s/you're/your/
07:21:32 <fasta> nominolo: then you are exposing implementation details
07:21:40 <fasta> nominolo: and you did a hacky job
07:21:47 <nominolo> huh?
07:21:55 <nominolo> imagine a scheme compiler
07:22:05 <nominolo> new you write your repl and compile it
07:22:43 <nominolo> now, programs started from this one, may capture _all_ of the continuation
07:23:22 <nominolo> i.e. including the part that started the REPL
07:23:47 <nominolo> (if you REPL just compiles the code it gets and executes it)
07:23:58 <fasta> nominolo: but when the REPL is started those continuations don't exist anymore, right?
07:24:18 <nominolo> it depends, on how you implment it
07:24:36 <fasta> nominolo: I guess this is just a bad example then ;)
07:24:46 <nominolo> and if you can't delimit the continuation, then you lost one part of freedom in your design space
07:25:00 <nominolo> fasta: yes, it were just the original reasons
07:25:11 <nominolo> fasta: there're way better uses
07:25:41 <fasta> nominolo: In a very fuzzy way I understand what you mean.
07:25:46 <nominolo> fasta: lighter-weight exceptions, generalized zippers, ... ;)
07:26:16 <nominolo> i have yet to understand the haskell implementation
07:27:02 <nominolo> not that prompts.  are first-class.  so you can dynamically decide up to which prompt you want to capture a continuation
07:27:21 <nominolo> *note
07:28:20 <sjanssen> @quote
07:28:20 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
07:29:28 <sjanssen> @tell dons xmonad irc logs are gone?
07:29:28 <lambdabot> Consider it noted.
07:33:41 <Inamabilis> Hey - anyone got a moment to help with a (i think) really simple thing that i just cant get right?
07:33:55 <Botje> sure, put it on hpaste and we'll take a look at it :)
07:34:14 <quicksilver> or not, since hpaste is down
07:34:18 <quicksilver> but put it somewhere :)
07:34:23 <Botje> oh. heh :p
07:34:56 <Botje> http://sial.org/pbot springs to mind
07:34:58 <lambdabot> Title: sial.org Pastebot - pasteling
07:35:23 <thoughtpolice> well, after learning to love Data.Map and a few hours (actually I think most of the night), I have somewhere around, maybe %5 of my app I guess I'll work on over the summer done.
07:35:39 <thoughtpolice> given many of those hours were ones spent wrestling with ConfigFile to get it to work appropriately
07:35:50 <thoughtpolice> well, at least for what I wanted. :(
07:36:29 <kfish> thoughtpolice, so it should be finished in 19 days? ;-)
07:36:47 <Inamabilis> http://pastebin.ca/525774
07:36:59 <thoughtpolice> kfish: seems like a good goal. :p
07:37:27 <Inamabilis> need to get a list of words in a book using list comprehension
07:37:34 <thoughtpolice> but I like the results at least.
07:37:56 <fasta> Is there a way to evaluate an expression in ghci and then automatically reset ghci s.t. it does the complete computation again if you give it the same expression?
07:38:06 <Botje> nope
07:38:09 <Botje> reload?
07:38:30 <fasta> That's _really_, _really_ annoying, imho.
07:38:32 <Botje> Inamabilis: look at the "lines" and "words" functions
07:38:47 <thoughtpolice> I used Map as my internal configuration structure; I had to get to a Map from my command line args, which wasn't hard. it was going from config file -> Map that was the annoying part.
07:38:51 <Botje> fasta: but if it's a pure function, the results won't change anyway! :)
07:39:25 <Botje> Inamabilis: oh wait, you don't need those at all. sorry. you should use "concat"
07:39:30 <fasta> Botje: the Debug.trace calls are stripped.
07:39:45 <Inamabilis> was trying to do something like this - wrds x = [[b|b <- a]|a<-x]
07:39:49 <Inamabilis> but its just not working at all
07:39:55 <Inamabilis> am i going down the wrong route?
07:40:33 <quicksilver> no, that's the right route
07:40:45 <Botje> Inamabilis: that'll just recreate the same structure, though :]
07:41:08 <quicksilver> but as botje says, your packaging it back up in a list of lists
07:41:23 <Botje> Inamabilis: the trick is to put two statements in the second part
07:41:24 <quicksilver> fortunately, you can put multiple generators in a list comp
07:41:37 <quicksilver> [ b | a <- x , b <- a ]
07:43:40 <Japsu> hmm?
07:44:03 <Japsu> > [ b | a <- [[1,2,3],[4,5,6]] , b <- a ]
07:44:04 <lambdabot>  [1,2,3,4,5,6]
07:44:07 <Japsu> yay
07:44:30 <Inamabilis> thanks!
07:46:42 <quicksilver> ndm: can your Derive also derive data types, or only classes?
07:47:01 <ndm> quicksilver: hmm, give me an example of what you are after?
07:47:05 <Jaak> @pl \xss -> [x | xs <- xss, x <- xs]
07:47:06 <lambdabot> (: [x <- xs]) . ((x | xs) <-)
07:47:13 <Jaak> wtf
07:47:30 <ndm> quicksilver: some of the derivings (Is, Has) derive functions, not classes - I guess no reason it can't be Data, its just Template Haskell syntax
07:47:44 <Botje> rofl
07:47:48 <Botje> that's .. pretty broken :)
07:47:56 <quicksilver> ndm: given a Data Foo = Bar Int | Baz String, I want to automatically produce the corresponding 'type of constructors' data CTFoo = CTBar | CTBaz
07:48:27 <ndm> quicksilver: not only can it do that, you could even express it with example deriving, i think
07:48:43 <quicksilver> ndm: and then make them members of a 2-element TC with appropriate 'flatten' method
07:48:45 <ndm> quicksilver: if you can't express it with example deriving, let me know and i'll fix it so you can
07:49:02 <quicksilver> ndm: nice. I will play.
07:49:15 <ndm> quicksilver: if you come up with anything, submit a patch, and we'll add it in
07:49:18 * quicksilver nods
07:49:42 <ndm> quicksilver: ideally you could write some documentation for what it can be used for, or a blog post, or something
07:50:39 <quicksilver> ndm: unfortunately I have abstracted the problem in my mind. I can no longer recall why I wanted it :)
07:50:44 <quicksilver> ndm: I'm sure it was a good reason, though!
07:51:01 <ndm> quicksilver: cool, well if you write a note stating its cool that will work for me :)
08:02:45 <chessguy> 'morning haskellers
08:02:50 <Botje> hello!
08:04:54 <chessguy> anybody know who james graves is on here?
08:05:07 <fasta> How do you use the ghci debugger/
08:05:27 <fasta> When I evaluated a pure expression once, it skips the break point next time.
08:05:53 <fasta> I cannot imagine the debugger to me more useless.
08:06:07 <fasta> me -> be
08:08:03 <quicksilver> I've never used the debugger
08:08:08 <quicksilver> and I don't fully understand your comment
08:08:20 <quicksilver> but of course it doesn't evaluate the same expression twice...
08:08:26 <quicksilver> so why would you expect it to break, again :)
08:10:29 <quicksilver> if you call the same function with a different argument, though, I would expect it to stop again
08:12:40 <fasta> quicksilver: I mean this sequence:
08:12:50 <fasta> > a
08:12:51 <lambdabot>   Not in scope: `a'
08:12:53 <fasta> > a
08:12:53 <lambdabot>   Not in scope: `a'
08:13:19 <fasta> It remembers that it has evaluated a
08:13:34 <Botje> but why would re-evaluating a give a different answer?
08:13:38 <fasta> It shouldn't do that unless the user asks for it, imho.
08:13:41 <quicksilver> this reflections the operational semantics it uses
08:13:50 <quicksilver> the thunk that used to represent 'a' has gone forever
08:13:51 <Botje> you need to explicitly reload to load new code anyway
08:13:57 <quicksilver> instead there is just a value in that location
08:14:06 <fasta> Botje: no, :r doesn't work
08:14:06 <quicksilver> Botje: he's trying to debug it again, not run it again
08:14:30 <fasta> quicksilver: yes, I know that's how it works now. I claim that's a very broken way.
08:14:43 * quicksilver shrugs
08:14:45 <fasta> quicksilver: Unless my use-case is silly.
08:14:54 <quicksilver> it's not a debugger with a brand new operational semnatics
08:15:02 <quicksilver> it's a peek under the hood of the existing operational semantics
08:15:13 <quicksilver> probably you can do what you want by giving it a dummy argument
08:15:32 <fasta> quicksilver: yes, I used that workaround in the past.
08:16:00 <fasta> quicksilver: observing what it does now, doesn't make it a sane debugger.
08:16:27 <fasta> It makes it a simple Google SOC debugger.
08:16:34 <fasta> (that is of little to no use)
08:16:45 <fasta> A.k.a. toy.
08:16:54 <quicksilver> no, I disagree entirely
08:17:00 <quicksilver> it makes it less user-friendly
08:17:04 <quicksilver> in that you need to understand the semantics
08:17:08 <quicksilver> it doesn't make it un-useful
08:17:25 <quicksilver> it is still useful, it enables you to step through code
08:17:30 <fasta> quicksilver: you just said you haven't used the debugger.
08:17:32 <quicksilver> and see how the lazy evaluation unrolls
08:17:37 <quicksilver> yes, I did :)
08:17:48 <quicksilver> nonetheless, unless the manual lies, I know what it does
08:17:52 <quicksilver> and I can see that it is not useless
08:17:55 <fasta> quicksilver: the stepping doesn't work for that long or never did
08:18:07 <fasta> quicksilver: my version doesn't support it
08:18:12 <fasta> "DISABLED"
08:18:21 <quicksilver> that's odd
08:18:30 <quicksilver> maybe ask the ghci folks which versions do work
08:18:42 <fasta> 20070402
08:18:47 <quicksilver> the transcripts in the manual pages demonstrate a working single-step
08:18:54 <fasta> Nah, I am not interested in single-stepping.
08:19:03 <fasta> I know the manual says that.
08:19:32 <quicksilver> OK. Well I can't agree with " < fasta> (that is of little to no use)" or "< fasta> A.k.a. toy."
08:19:42 <fasta> Another thing a sane debugger should support is going back to a previous break-point.
08:20:00 <quicksilver> I do think it's an interesting challenge how to map imperative debugging techniques to a functional program
08:20:15 <fasta> It's not useable in practice unless your time is worthless, so, imho, it's a toy.
08:20:21 <quicksilver> I must admit, in many years of (admittedly not full-time) functional programming in several languages I've never really wanted one
08:20:46 <quicksilver> neither have I ever used, or wanted to use, unsafePerformIO or Trace.trace
08:21:14 <fasta> quicksilver: that strikes me as odd, you always write your programs correct the first time?
08:21:21 <quicksilver> no
08:21:25 <quicksilver> but I debug in the REPL
08:21:27 <sjanssen> fasta: the ghci debugger is still under heavy development
08:21:34 <quicksilver> by manipulating sub-expressions
08:21:40 <quicksilver> until I observe where behaviour is wrong
08:21:50 <sjanssen> fasta: have you tried a newer version? (yours is nearly two months old)
08:22:03 <fasta> sjanssen: no
08:22:24 <sjanssen> how 'bout you do that before complaining?
08:22:27 <quicksilver> and write regression tests/unit test for correct behaviour of 'relatively small' component functions
08:23:21 <fasta> sjanssen: I admit I am complaining a bit.
08:23:26 <sjanssen> :)
08:23:43 <sjanssen> fasta: that, or complain where GHC HQ can hear you
08:23:52 <fasta> quicksilver: I know where the problem is, but inserting traces to see what values variables have is no fun.
08:23:55 <fasta> sjanssen: already did
08:24:06 <quicksilver> fasta: I don't insert traces
08:24:11 <quicksilver> fasta: I just run the sub-expressions
08:24:21 <fasta> quicksilver: and what if that is not possible?
08:24:28 <quicksilver> how can that not be possible?
08:24:31 <fasta> quicksilver: what if the logic is inherently complicated?
08:24:42 <quicksilver> then the test cases become complicated
08:24:48 <quicksilver> but that's true whether you have a debugger, or not
08:25:07 <quicksilver> foo x y = bar (baz x) (bam y)
08:25:18 <quicksilver> I first check (baz x) looks ok, then I check (bam y) looks ok
08:25:25 <quicksilver> then I check if 'bar' does the right thing
08:25:46 <quicksilver> of course, the more complicated a program's logic is, the more fiddly it is to set up the test case
08:26:02 <fasta> I will show an example
08:26:04 <quicksilver> but, then, you need to set up an appropriate test case with failing behaviour to have anything useful to step through with a debugger, too
08:26:12 <fasta> Since this is meaningless with small examples
08:26:29 <kfish> though setting up the test cases usually helps with understanding the problem :-)
08:26:41 <quicksilver> kfish: absolutely
08:26:54 <fasta> http://pastebin.ca/525843
08:26:56 <quicksilver> kfish: and factoring large monolithic functions into smaller modular functions often does, too
08:27:17 <fasta> This code still contains a bug. With a debugger you will find it within a few minutes.
08:27:31 <fasta> Without it, it takes much longer.
08:28:41 <sjanssen> > length "     current_rank = compute_rank rank_parent direction x_reversed parent_reverse_state size_left_node size_right_node"
08:28:46 <lambdabot>  117
08:29:55 <quicksilver> fasta: well, I'd set up some example parameters and copy-paste subexpressions from the code until I understood
08:30:16 <quicksilver> fasta: I could certainly see that some of that could usefully be automated, but not really with anything like an imperative debugger
08:30:20 <chessguy> jgraves, ping
08:30:32 <jgraves> I'm here.
08:30:36 <chessguy> hiya
08:30:49 <chessguy> i'm the one that just emailed you
08:30:55 <jgraves> chessguy: Got it.
08:31:05 <jgraves> What's on your mind?
08:31:22 <chessguy> well, i'm still looking at your code somewhat
08:31:51 <jgraves> I'm sure my code could stand a lot of improvement.
08:31:51 <chessguy> but, for example, your map2 is just zipWith, i think
08:31:59 <chessguy> @type zipWith
08:32:01 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
08:32:17 <chessguy> ?src zipWith
08:32:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:32:18 <lambdabot> zipWith _ _      _      = []
08:32:43 <jgraves> OK, I tried using Hoogle with that function signature... and it didn't turn up anything.
08:32:58 <chessguy> oh really?
08:33:02 <chessguy> wierd
08:33:17 <jgraves> Well... I thought I did...
08:33:21 <chessguy> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
08:33:21 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:33:21 <lambdabot> Control.Parallel.Strategies.parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
08:33:45 <jgraves> Hmph.  I was using the web browser version...
08:34:00 <chessguy> ok
08:34:02 <jgraves> Anyway, that's fine.
08:34:08 <jgraves> I'll replace it.
08:34:18 <chessguy> the other once i noticed right there is add_tail
08:34:42 <chessguy> addtail x ys === ys:[x]
08:34:52 <chessguy> err
08:34:57 <chessguy> addtail x ys === ys ++ [x]
08:35:27 <chessguy> though it's really not a good idea to be adding to the tail of lists a lot anyway. i haven't gotten around to figuring out why you're doing that
08:35:28 <DRMacIver> I like the way the function definition is shorter than the function name.
08:35:32 <jgraves> Whoops, gotta run into a meeting.
08:35:50 <jgraves> I'll have to talk w/ you later.
08:35:55 <jgraves> But thanks for the feedback.
08:36:00 <chessguy> ok, i'll put together some thoughts and email you
08:36:06 <chessguy> if you want
08:37:25 <jgraves> OK, I'm back for a couple minutes...
08:37:40 <jgraves> The guy who wanted a meeting is back on the phone.  :-)
08:38:10 <chessguy> lol
08:38:14 <jgraves> For the add_tail, my only defense is that I'd been recently watching the video lectures, and had recusion on the mind.
08:38:23 <quicksilver> :)
08:38:36 <chessguy> well, more important than how you implemented it is *why* you implemented it
08:38:39 <quicksilver> you don't need a 'defense' for not being familiar with the standard library :)
08:39:05 <quicksilver> there's no god-given talent which enables you to know there is already a cute function out threre with a fixed name
08:39:40 <jgraves> There isn't?  Dammit.
08:39:49 <jgraves> I was soo hoping.
08:39:52 <quicksilver> there is however a god-given IRC channel :)
08:39:58 <quicksilver> which is remarkably co-operative in these matters
08:40:36 <chessguy> jgraves, are you using the bottom of each column as the end of the list?
08:41:22 <jgraves> It is the way I did it for the Common Lisp version... Hadn't thought about it much.
08:41:26 <ivanm> @doc printF
08:41:26 <lambdabot> printF not available
08:41:32 <ivanm> @hoogle printf
08:41:36 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
08:41:36 <lambdabot> Text.Printf :: module
08:41:36 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
08:41:42 <ivanm> @doc Text.PrintF
08:41:43 <lambdabot> Text.PrintF not available
08:41:48 <chessguy> jgraves, you would do much better to flip that
08:41:50 <ivanm> @doc Text.Printf
08:41:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
08:41:55 <chessguy> use the list as a stack
08:42:06 <chessguy> O(1) access instead of O(n)
08:42:49 <jgraves> Yeah, but then the data representation doesn't match what you'd see on the screen.  :-)
08:43:18 <chessguy> i guess that's a matter of perspective
08:43:47 <chessguy> if you see the list as a pile, the card on top is at the beginning
08:44:19 <jgraves> OK, I really have to go in the meeting now... He's off the phone.
08:44:22 <chessguy> ok
08:45:30 <fasta> sjanssen: yes, it's long, any suggestions other than vertical alignment of parameters?
08:49:19 <chessguy> @pl c x = s $ m l x
08:49:19 <lambdabot> c = s . m l
08:50:02 <sjanssen> fasta: well, typical Haskell style would have those long variable names as short names, like one or two characters
08:50:41 <fasta> sjanssen: yes, but since I use Haskell as long as I do I stopped doing that.
08:51:00 <fasta> sjanssen: it makes my code horrible to read
08:51:06 <jgraves> Chessguy, I'm back for a little while.
08:51:10 <chessguy> lol
08:51:12 <chessguy> short meeting
08:51:29 <sjanssen> fasta: 'r' and 'l' are record selectors?
08:51:33 <jgraves> That's the way it is sometimes.
08:51:42 <fasta> sjanssen: left and right children
08:51:50 <jgraves> So yeah, we could use a stack instead.
08:51:52 <fasta> sjanssen: I use those very often so they may be short names./
08:51:57 <chessguy> jgraves, what does this mean?
08:51:59 <chessguy> [01;37;41m10H
08:52:51 <fasta> sjanssen: I think the names are sensible. If one sees the whole program one would conclude the same, I think.
08:53:30 <jgraves> That's me being lazy.  Instead of using the terminfo library...
08:53:37 <sjanssen> fasta: is it expensive to compute l t?
08:53:45 <jgraves> I just cut and pasted the escape sequences into my code.
08:53:55 <sjanssen> or is it just a single dereference?
08:53:56 <jgraves> That's how I get the colors.
08:54:29 <fasta> sjanssen: no, but I use left multiple times.
08:54:41 <fasta> sjanssen: single dereference
08:54:43 <jgraves> How many people _aren't_using VT100-compatible terminal windows anymore?
08:55:19 <fasta> jgraves: Ask that question in #freebsd and I am sure someone will tell _you_, you aren't using one :)
08:55:22 <jgraves> Or more properly, ANSI-compatible terminal windows.
08:55:43 <fasta> sjanssen: why?
08:55:58 <jgraves> Yeah, at any rate, if that doesn't already have a FIXME, it should.
08:56:16 <ndm> @hoogle toDyn
08:56:20 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
08:56:29 <ndm> hmm, is haskell.org down, or just hoogle?
08:56:30 <sjanssen> fasta: I'd use (l t) rather that left
08:56:41 <sjanssen> fasta: it's just one more variable for the user to track down
08:56:50 <sjanssen> s/user/reader
08:57:49 <chessguy> jgraves, i'm still looking for it
08:57:49 <jgraves> Chessguy: I'm still thinking about the stacks...
08:58:24 <maik> hi, i'm new to haskell and i'm trying to implement a simple 1 to n relation of datastructures, where it should be able to update both parts.
08:58:40 <maik> So my question: how should i store the "TheOne" datastructure in "TheN" datastructure ?
08:58:56 <chessguy> jgraves, ok
08:59:08 <chessguy> jgraves, it really makes a lot of sense
08:59:29 <maik> Doing data TheN = TheN { one :: TheOne} makes it impossible to update the TheOne data.
08:59:54 <chessguy> jgraves, the only part of a stack you're going to change is the top, and the beginning of a list is the easiest part to change
09:00:19 <fasta> sjanssen: Hmm, I try to compress my programs such that I don't have patterns that occur twice.
09:00:34 <chessguy> maik, perhaps you can paste some code that shows what you're trying to do?
09:00:35 <chessguy> !paste
09:00:44 <chessguy> @paste
09:00:44 <quicksilver> maik: strictly speaking you don't update anything in haskell
09:00:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:00:53 <maik> yes i know
09:01:00 <quicksilver> chessguy: hpaste is down today
09:01:06 <chessguy> oh, sorry
09:01:08 <sjanssen> fasta: I'd agree, if (l t) was a larger expression
09:01:25 <sjanssen> fasta: but (l t) says exactly what it means, left child of t
09:01:30 <quicksilver> maik: but 1 to n relationship sounds a bit like a list
09:01:32 <quicksilver> maik: or an array
09:02:16 <fasta> sjanssen: if tool support was better, I think you are right.
09:02:17 <jgraves> chessguy: I guess I just need a function that allows me to pop off N items, and push them on another stack, stored in the same order.
09:02:42 <chessguy> jgraves, that's easy
09:02:45 <fasta> sjanssen: I can't say "replace all calls to "l t" with "r t" reliably.
09:02:52 <chr1s_> hey all :)
09:02:57 <sjanssen> fasta: which tool (or lack) causes that?
09:03:02 <sjanssen> fasta: ah
09:03:38 <chr1s_> I'm trying to generate some haskell-code based on datatypes. Suppose I want to generate folds, for example.
09:03:44 <chessguy> moveN n fromStack toStack = (drop n fromStack, (take n fromStack) ++ toStack)
09:04:04 <chr1s_> I was looking at the typeOf function in Data.Generics.Basics, but that doesn't seem to help yet.
09:04:08 <chr1s_> any thoughts on this?
09:04:14 * kolmodin has a quick look at SPJ's "Constructor specialisation for Haskell programs"
09:04:17 <jgraves> OK, right.
09:04:32 <kolmodin> it must be one of the very first papers I've read that has a color image! :D
09:05:12 <maik> say i have 2 structures with a n to n relation. a medium contains software and every software can be in 1+ mediums.
09:05:24 <maik> simply written: : data Software = Software String    and   data Medium = Medium [Software]
09:05:38 <sjanssen> fasta: you're passing a lot of parameters, are some of them used enough to put them in a Reader or StateT?
09:05:54 <maik> this would be okay if i don't want to change the String in the Software structure.
09:06:24 <quicksilver> then you have to have your mediums refer to your software by some kind of 'identifier' which doesn't change
09:06:37 <maik> yeap, i thought of some Int Ids
09:06:38 <quicksilver> and then store the maybe-changing thing somewhere else
09:06:49 <quicksilver> (or, you just go through and update all the mediums when you change)
09:07:02 <maik> but isn't here a "haskell" way to do this :)
09:07:09 <mdmkolbe|work> what is the timeline for 6.6.2?
09:07:20 <fasta> sjanssen: I am not sure. I think it's better in this case not to use any *T.
09:07:23 <quicksilver> data Software = Data.Map Int String ; data Medium = Medium [Int]
09:07:32 <quicksilver> or possibly wrap a type around the Int
09:07:40 <quicksilver> data SoftwareID = SoftwareID Int
09:07:42 <quicksilver> if you prefer
09:07:46 <maik> may MVar help here
09:07:46 <maik> ?
09:07:49 <allbery_b> *sigh* "you want to use onMap" "Not in scope: onMap"
09:07:54 <quicksilver> not really
09:07:58 <sjanssen> fasta: what monad is this?
09:08:01 <Igloo> mdmkolbe|work: The plan is not to release 6.6.2
09:08:03 <jgraves> chessguy: I can probably chat more this weekend.  But I should get back to actually working this morning.  :-)
09:08:03 <quicksilver> MVar is about communication between threads
09:08:19 <chessguy> ok
09:08:20 <jgraves> I have not, _yet_, made Haskell part of my day job.
09:08:23 <fasta> sjanssen: It's in MonadST
09:08:37 <jgraves> But I'm the CTO, so it is within the realm of possibility.
09:08:55 <mdmkolbe|work> Igloo: ok, then what is the timeline for the next release? (also is there a page with that info?)
09:09:04 <jgraves> It's mostly a matter of convincing everyone else.  I don't get to play dictator, unfortunately.
09:09:08 <chessguy> jgraves, feel free to ping me any time
09:09:19 <chessguy> i'll be moving this weekend, but i may be in and out
09:09:33 <jgraves> OK, thanks again for the feedback.  I'll try to push out a new release in the next week or so.
09:09:53 <jgraves> Good luck on the move.  Remember to lift with the legs.
09:10:00 <chessguy> lol, will do
09:10:11 <monochrom> You could set aside 5% of your employee time for them to learn haskell.
09:10:31 <Igloo> mdmkolbe|work: This summer, tentatively
09:10:46 <chessguy> monochrom, hmm. 24 minutes a day. not much
09:11:23 <maik> quicksilver: ok thx i'll try it with ids
09:11:26 <monochrom> Why don't you put it as "3 seconds a minute, not much"?
09:11:35 <fasta> sjanssen: (I know MonadST isn't a monad, but I am sure you know what I mean)
09:11:36 <Igloo> mdmkolbe|work: http://hackage.haskell.org/trac/ghc is where information would be
09:11:38 <lambdabot> Title: GHC - Trac
09:12:37 <chessguy> monochrom, 24 minutes a day makes much more sense to me
09:12:48 <mdmkolbe|work> Igloo: thx.
09:12:57 <monochrom> I mean what's wrong with 120 minutes a week, or 500 minutes a month?  Do you *have* to disrupt it to "24 minutes a day" or "3 seconds a minute" to make it sound like ineffective?
09:13:58 <chessguy> oh, 2 hours a week would make sense too
09:16:29 * chessguy sighs. wireless does have its annoyances
09:16:46 * zbrown agrees
09:16:57 <sjanssen> fasta: http://pastebin.ca/525918 -- this is how I'd write that
09:17:10 <sjanssen> fasta: modulo long identifiers, but I understand that's a matter of taste
09:17:25 <monochrom> I used to teach my friends Haskell at the rate of 2 hours per week, for something like 10 weeks.  At least they saw the beauty of Haskell, if not the practicality. (I didn't showcase libraries or case studies. But that could be easily fixed.)  http://www.cs.toronto.edu/~trebla/fp/
09:17:26 <lambdabot> Title: Albert's Functional Programming Course
09:18:25 <chessguy> oh wow
09:18:29 <chessguy> monochrom++ very cool
09:18:52 <monochrom> thanks
09:19:14 <olsner> sjanssen: why not a "case t of" instead of introducing a nested function with a nested where-clause?
09:19:51 <sjanssen> olsner: because where clauses are generally more readable
09:20:52 <quicksilver> one of the reasons I don't like long variable names, and this is really trivial, is the way they screw up source code formatting
09:21:11 <quicksilver> the body of 'aux' is pushed a long way to the right by the lenght of 'min_cost_in_this_tree'
09:21:19 <chessguy> monochrom, oops, bug
09:21:20 <sjanssen> right
09:21:22 <quicksilver> and to me that makes the whole thing a bit awkward
09:21:38 <monochrom> what bug?
09:21:44 <chessguy> seven = x + y where x = 3
09:21:44 <chessguy> ; y = x + 4
09:21:58 <chessguy> bah, the formatting gut messed up
09:22:12 <monochrom> My friends spotted it too.  Too lazy to correct. :)
09:23:06 <chessguy> this is definitely bookmarkable though
09:23:12 <fbuilesv> Hello, when trying to install Cabal on Mac OS X I'm getting a "x library is out of date, rerun ranlib(1)". How exactly should I rerun ranlib?
09:28:10 <chessguy> @type []
09:28:14 <lambdabot> forall a. [a]
09:30:41 <thermoplyae> hpaste is down, but here's a particular segment of YAHT I'm trying to digest http://pastebin.ca/525956
09:31:08 <thermoplyae> I understand everything except the line with 'where' in it -- specifically, what is st doing there?
09:31:28 <sjanssen> thermoplyae: it's an argument to run'
09:31:41 <sjanssen> run :: st -> (st, a)
09:31:44 <olsner> fbuilesv: ranlib /path/to/file.a
09:31:47 <sjanssen> run', that is
09:32:02 <thermoplyae> hmm
09:32:28 <fbuilesv> lets see...
09:32:28 <thermoplyae> So is where defining run' for a particular argument?
09:32:29 <thermoplyae> Rather
09:32:42 <thermoplyae> Is it the same as saying where run' = And then wrapping that block in (\st -> )
09:33:00 <sjanssen> not quite, because of the scoping of where
09:33:05 <fbuilesv> olsner, sure its runlib instead of ranlib, runlib doesnt exist O.o
09:33:35 <sjanssen> thermoplyae: do you find this less confusing:  where run' = \st -> ...
09:34:03 <thermoplyae> Yes, that's what I was trying to communicate with the last line
09:34:12 <thermoplyae> The (\st -> ) belonged inside the where block, not around it
09:34:16 <thermoplyae> Right, thanks :)
09:35:12 <fbuilesv> olsner, it was ranlib and worked but with a bunch of "Library.a (something.o) contains no symbols
09:35:18 <fbuilesv> hope this isnt too problematic.
09:39:08 <RyanT5000> what's the correct pronunciation of haskell?
09:39:44 <ddarius> RyanT5000: There are arguably two.
09:40:10 <RyanT5000> the two obvious ones? HASK-ull and hask-ELL?
09:40:29 <ddarius> More or less, yes.
09:40:39 <ventonegro> harrop is on haskell cafe! comp.lang.lisp is safe now!
09:40:57 <chessguy> monochrom, you should polish this up and add it to the wikibook
09:41:02 <EvilTerran> I think i tend to say HA-sk*ll
09:41:08 <EvilTerran> (where * is the neutral vowel)
09:41:29 <quicksilver> I assume that's what RyanT5000 was denoting with the 'ull' version
09:41:34 <RyanT5000> EvilTerran: yeah, that's a much better way of writing what i was trying to write with my first one
09:41:43 <quicksilver> certainly I say HASKuhl
09:42:00 <quicksilver> short 'a'
09:42:03 <quicksilver> but I'm english
09:42:18 <quicksilver> that's *probably* how I heard SPJ say it, but it might not be
09:42:18 <RyanT5000> that seems to be the MIT pronunciation too
09:42:30 <EvilTerran> it's the oxford pronunciation
09:42:57 <olsner> I pronounce it more like Hah-skell
09:43:12 <DRMacIver> I pronounce it Haskell.
09:43:13 <ddarius> I pronounce it like Pascal.
09:43:33 <olsner> is that PAScal or pasCAL?
09:43:37 <EvilTerran> but do you say pascAl, or pasc*l?
09:43:41 <Excedrin> I pronounce it Jah-vah
09:43:47 <Excedrin> oh wait what
09:43:52 <arcatan> I pronounce it like.. damn Excedrin was faster
09:44:00 <RyanT5000> ddarius: that's what i've been doing - pasCAL
09:44:41 <quicksilver> no, pascal is definitely pasCAL
09:45:01 <quicksilver> that's less arguable, since pascal is a moderately common french name
09:45:07 <quicksilver> and so, how to pronounce it is well known
09:45:16 <quicksilver> whereas haskell is a very obscure name :)
09:45:34 <byorgey> quicksilver: and yet, whenever I say HA-sk*ll, people think I said Pascal... =P
09:45:57 <vlm> guys, whoever worked with SYB & Monads?
09:46:10 <quicksilver> well clearly they think you are ignorant and are not only saying pascal, but saying it wrong :)
09:46:10 <Excedrin> I wonder if they teach Haskell at http://www.haskell.edu/
09:46:12 <lambdabot> Title: Haskell Indian Nations University - Lawrence, Kansas
09:46:21 <monochrom> chessguy: the wikibook already has too much stuff, in particular very comprehensive on introductory things. if I add, there will be a too-many-chefs problem. It already has the too-many-chefs problem.
09:46:22 <RyanT5000> so if i were to put a pronunciation on Wikipedia, should i put the HA-skuhl pronunciation as first and the other as second?
09:46:32 <olsner> I actually hadn't noticed until now that pascal was also a french name ;-)
09:46:51 <olsner> programming languages are in their own namespace for me
09:46:58 <byorgey> RyanT5000: presumably, the "canonical" pronunciation is however Haskell Curry pronounced his first name
09:47:31 <chessguy> mmm, maybe
09:47:33 <byorgey> not that I would know...
09:47:55 <quicksilver> I believe he preferred it to be pronounced 'lambdabunny'
09:47:55 <byorgey> chessguy: it depends if you're a prescriptionist or a descriptionist, I suppose =)
09:47:55 <RyanT5000> byorgey: true; however, i'm not sure if he has access to irc :P
09:48:11 <byorgey> RyanT5000: yes, that is unfortunate
09:48:51 <olsner> @quote curry
09:48:51 <lambdabot> emu says: what would be the ingredients in a Haskell curry?
09:49:04 <monochrom> I find that I'm incompatible with other authors' takes.  I hate analogies; they love analogies.  I go from concrete to abstract; they go from abstract to concrete.
09:49:35 <byorgey> @seen jfredett
09:49:35 <lambdabot> I saw jfredett leaving #haskell 15h 27m 6s ago, and .
09:49:48 <byorgey> @help tell
09:49:49 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
09:50:02 <byorgey> @seen jfredett_
09:50:02 <lambdabot> jfredett_ is in #haskell. I don't know when jfredett_ last spoke.
09:50:26 <byorgey> jfredett_: you were right about that paper =P
09:50:44 <byorgey> jfredett_: but check out http://paste.lisp.org/display/42070
09:51:08 <pharm> /quit
09:51:40 <pharm> that's better
09:52:13 <pharm> Is there a simple way to spit Word8s to Stdout?
09:52:39 <olsner> print?
09:52:42 <monochrom> Example. A newbie asks, "what is fix f?"  My reply begins with: "rewrite x = fix f to x = f x, or back".  Their reply begins with: "fixed points are from CPO theory and is of great importance to Haskell".
09:52:50 <pharm> doesn't that convert them to strings?
09:53:15 <pharm> like 1::Word8 prints as "1" which isn't the same thing at all...
09:53:50 <olsner> ah, you mean like writing a binary file ;-)
09:53:55 <pharm> yup :)
09:54:13 <pharm> converting to a Bytestring is possible, but seems a bit overkill.
09:54:30 <RyanT5000> is anyone near boston?
09:54:48 <RyanT5000> (or want to come to boston for the 8th through the 10th)
09:55:03 <chessguy> @seen procyon112
09:55:03 <lambdabot> procyon112 is in #haskell-blah, #gentoo-haskell and #haskell. I last heard procyon112 speak 17h 18m 52s ago.
09:55:04 <pharm> I could do hPutBytes, but that involves allocating a placeholder for the output, which seems overkill for this purpose...
09:55:18 <monochrom> (Of course my reply will get to CPO theory, but at the end.  Of course their reply will get to x = f x, but at the end.)
09:55:18 <RyanT5000> the One Laptop Per Child project is having a game jam, and i was thinking of forming a haskell team
09:55:32 <olsner> monochrom: you're saying the the innocent sentence "rewrite x = fix f to x = f x, or back" brought someone from newbie to arguing about CPO theory?
09:55:35 <pharm> I just want to output the raw data. It shouldn't be this hard!
09:56:21 <olsner> ah, lol... now I see what you were referring to with my reply/their reply
09:57:31 <pharm> maybe Data.Binary is what I need?
09:57:39 * pharm rootles around.
09:58:10 <sjanssen> pharm: you want to write single bytes?
09:58:34 <byorgey> @tell jfredett_ http://paste.lisp.org/display/42070
09:58:34 <lambdabot> Consider it noted.
09:58:37 <pharm> sjanssen: yes
09:58:51 <pharm> looks like theres a putWord8 in Data.Binary which should dtrt
09:59:35 <sjanssen> pharm: in GHC's current implementation (putChar . fromEnum . fromIntegral) will write a single byte
10:00:01 <sjanssen> pharm: it prints the lowest 8 bits of Char
10:00:11 <sjanssen> but this could change at any time, and might not work in hugs
10:00:35 <pharm> sjanssen: I *want* the lowest 8 bits of Char (that's why I've got a [Word8])
10:01:05 <pharm> sjanssen: so I can just write putChar (at the moment)
10:01:06 <pharm> ?
10:01:07 <pharm> hmm
10:01:12 <olsner> @type putWord8
10:01:14 <lambdabot> Not in scope: `putWord8'
10:01:14 <int-e> pharm: yes
10:01:27 <sjanssen> pharm: so, you can do: putStr . map (fromEnum . fromIntegral) $ list_of_word8s
10:01:42 <sjanssen> pharm: remember that this is neither portable nor permanent!
10:01:42 <int-e> @type Data.Char.chr
10:01:44 <lambdabot> Int -> Char
10:01:52 <sjanssen> ah, I want toEnum
10:01:54 <pharm> Eww
10:01:55 <sjanssen> or chr
10:02:12 <int-e> actually I do hope it's permanent, and the whole encoding/decoding mess goes to separate libraries
10:02:22 <mdmkolbe|work> dons: do I infer correctly that the Yi package on hackage is just the kernel which could target any kind of application and that Yi-vty contains the application specific code?
10:02:30 <sjanssen> int-e: you're wrong :)
10:02:38 <int-e> sjanssen: sigh
10:02:43 <fasta> sjanssen: I noticed you removed the mapM call. Is that because of efficiency reasons?
10:02:52 <sjanssen> int-e: the fact that putStrLn doesn't output in the users locale is clearly a bug, IMO
10:02:55 <fasta> sjanssen: Or do you think it's clearer?
10:03:02 <sjanssen> fasta: it's clearer, IMO
10:03:10 <pharm> hmm putWord8 in Data.Binary is Word8 -> Put
10:03:14 <fasta> sjanssen: Heh, ok, then we disagree on that point :)
10:04:34 <vlm> has anyone experienced a specific space leak with recursive SYB & Monads?
10:04:39 <pharm> OK, so putChar is entirely type incorrect for this, but will dtrt. Here's me trying to be all type correct as well...
10:05:20 <sjanssen> int-e: one of two things should happen: we use Word8 instead of Char in every IO prim; or we make Handles encoding aware
10:05:35 <sjanssen> pharm: yes, some simple binary primitives are missing
10:05:51 <sjanssen> putByte, putBytes would be really handy
10:06:22 <int-e> sjanssen: ok, I guess I could live with added primitives that return Word8
10:06:33 <int-e> and [Word8]
10:06:55 <sjanssen> int-e: I say the Char prims should be gone
10:07:05 <sjanssen> or we fix Handle
10:07:16 <pharm> I'd just like the ability to spit out a Word8 as raw data. If I wanted a Char, I'd be asking for one...
10:07:17 <olsner> Char prims should be Word8 prims + recoding
10:07:24 <pharm> olsner: exactly
10:07:32 <sjanssen> olsner: recoding?
10:07:47 <olsner> yeah, locale -> unicode, unicode -> locale
10:07:57 <sjanssen> right
10:09:55 <int-e> sjanssen: oh so all you want to fix is the type? then we're more in agreement than I thought.
10:10:21 <sjanssen> int-e: what I really want is to make handles encoding aware
10:10:38 <sjanssen> but if people refuse to do that, then we should stop lying in the type of putChar :: Char -> IO ()
10:10:54 * ndm wants to teach everyone english and remove unicode...
10:11:31 <ndm> sjanssen: remember that putChar does do line ending destruction on windows, so calling it Word8 isn't right either
10:11:53 <sjanssen> ndm: hmm, true
10:12:10 <sjanssen> anyway, I think it's sad that Hugs DTRT, but GHC doesn't
10:12:19 <ndm> DTRT?
10:12:33 <sjanssen> does the right thing
10:12:45 <olsner> putAsWord8WithLocalLineEndings :: Char -> IO ()
10:12:53 <ndm> i think its sad that there is no right thing
10:13:00 <ndm> on Windows, you are screwed either wya...
10:13:12 <sjanssen> ndm: I think locale encoding for stdin/out is pretty clearly correct
10:13:13 <ndm> cabal files with \r break when run on Linux
10:13:26 <olsner> you are always screwed in some circumstances, when it comes to these issues
10:13:43 <int-e> sjanssen: only if input/output without recoding is possible
10:13:52 <sjanssen> int-e: oh, of course
10:13:54 <ndm> olsner: not if you blow away backwards compatability, demand everything is unicode, and demand \r goes away and dies
10:14:08 <sjanssen> we'd need a 'raw' setting, or some such
10:14:10 <int-e> sjanssen: otherwise you need some bijective mapping, and the only obvious one is doing no recoding at all
10:14:19 <int-e> sjanssen: yep
10:15:02 <olsner> ndm: good luck ;-)
10:15:12 <ndm> olsner: not practical, but a dream...
10:17:16 <vlm> am I being seen at all?
10:17:29 <SamB> ndm: I think you will be hard pressed to find any unicode GIF files
10:17:39 <olsner> if nothing else, you'd like to have a DTRT-mode for text, applying all kinds of fuzzy translations to try and get text out of a file as the user intended it, as well as a raw mode for binary I/O
10:18:09 <SamB> olsner: not too many kinds of fuzzy translations...
10:20:34 <quicksilver> well there is an openBinary thing
10:20:42 <quicksilver> which turns off the newlibe conversion I believe
10:20:54 <quicksilver> at which point, putChar really does become putWord8
10:21:45 <olsner> "in the current implementation of GHC", right?
10:22:28 <quicksilver> well since System.IO doesn't give you any *other* putWord8
10:22:42 <quicksilver> and yet binary file writing is clearly an absolutely vital feature
10:22:53 <quicksilver> you're pretty much forced to use putChar
10:23:08 <quicksilver> certainly, that's what I have done
10:23:17 <quicksilver> if there was a better way I missed I'd like to know about it :)
10:23:31 <LoganCapaldo> Is there really no provision for "raw" IO in the report?
10:23:38 <LoganCapaldo> @where report
10:23:39 <lambdabot> http://www.haskell.org/onlinereport/
10:23:41 <quicksilver> yes, and it's putChar :)
10:23:46 <quicksilver> or at least, that's how I see it
10:23:51 <quicksilver> it's just badly named (and badly typed)
10:24:29 <sjanssen> LoganCapaldo: that is correct
10:24:46 <sjanssen> quicksilver: there are implementations (Hugs) where putChar isn't putWord8
10:25:42 <quicksilver> sjanssen: but haskell contains no primitive which actually does what I want
10:25:50 <quicksilver> sjanssen: so I'm forced to (ab)use putChar
10:25:58 <LoganCapaldo> Is this (going to be) addressed in Haskell' ?
10:26:02 <quicksilver> or use a higher livel library
10:26:09 <quicksilver> LoganCapaldo: it's not really a language issue, just a library one
10:26:35 <LoganCapaldo> quicksilver: well the report for haskell defines some libraries
10:26:44 <LoganCapaldo> I jsut presumed it would be similar for the next iteration
10:26:53 <quicksilver> it would be a pretty uncontroversial change, in my mind, to add puTWord* and putWords8 to System.IO
10:26:55 <LoganCapaldo> I agree that it is a lib issue
10:26:58 <quicksilver> bah sorry for the bad typing
10:27:53 <quicksilver> then the decision can be made whether to deprecarte, or change, putChar
10:29:03 <pharm> wow, that is spectacularly slow.
10:29:10 <pharm> time to profile...
10:29:26 <quicksilver> pharm: if you're doing something speed crtiical with bytes then I imagine you do, in fact, want to use ByteString
10:29:31 <sjanssen> pharm: use ByteString if you want to write bytes quickly
10:29:39 <quicksilver> I win!
10:29:39 <quicksilver> :)
10:30:04 * dcoutts has an iconv binding in the works that uses lazy bytestring and is as fast as the iconv standalone prog
10:30:06 <pharm> :)
10:30:36 <pharm> Yeah, but I'm generating a list of Word8s...which I'm not dying to convert to a Bytestring just so I can output the damn things.
10:30:59 <quicksilver> even the generation may be faster in bytestring
10:31:45 <pharm> psosibly: I'm trying to take a list of doubles, floor them and spit out the results as raw binary word8s
10:32:06 <pharm> ideally, I'd like to preserve laziness at this point, rather than make things needlessly strict.
10:32:12 <quicksilver> depending what kind of geenration it is is
10:32:12 <quicksilver> and, 'pack' is only 4 characters...
10:32:24 <LoganCapaldo> I thought bytestring was lazy?
10:32:27 <dcoutts> for that you'd want Data.Binary, however the released version doesn't support doubles in ieee format
10:32:36 <pharm> dcoutts: Ngggg.
10:32:42 * pharm beats head on table.
10:32:59 * pharm contemplates going off and writing Erlang instead
10:33:07 <dcoutts> my unreleased test code supports that, but it's a tad bleeding edge
10:33:26 <dcoutts> however it's much faster than Erlang :-)
10:33:29 <pharm> dcoutts: actually, I don't want to serialise the Doubles, just the floored values.
10:33:37 <LoganCapaldo> but if you write it in erlang that it will be _really- strict :)
10:33:41 <pharm> :)
10:33:47 <dcoutts> pharm: oh, then use Data.Binary
10:34:28 <pharm> dcoutts: any chance of a quick guide? putWord8 is Word8 -> Put. What do I do with a Put to output it?
10:34:47 <dcoutts> you want put at type Int
10:35:59 <pharm> dcoutts: so the Word8 autoconverts to Int? OK...
10:36:15 <dcoutts> pharm: so if you've got a list of [Int] then just use encode to get a lazy ByteString
10:36:30 <quicksilver> pharm: using bytestrings needn't be needlessly strict
10:36:49 <dcoutts> yes, this will be serialised lazily
10:37:07 <pharm> [Word8] in fact, but it could be a list of anything integral: I want a list of Word8s as output
10:37:21 <dcoutts> pharm: do you care what the output format is exactly? outputting a list adds a length prefix
10:37:27 <pharm> yes
10:37:39 <dcoutts> oh, then use put directly
10:37:46 <pharm> it's a binary format: pgm image in fact.
10:38:03 <pharm> Data.Binary.put ?
10:38:18 <dcoutts> so if the primitive you want it bytes then just use putWord8
10:38:44 <dcoutts> pharm: yes, look at the Data.Binary.Put module
10:39:17 <pharm> which is of type (Word8 -> Put). What do I do with a Put to print it?
10:39:26 <dcoutts> runPut
10:39:32 * pharm has never used Data.Binary...
10:39:35 <dcoutts> which gives you a lazy ByteString
10:39:48 <dcoutts> which you can write to a file or whatever
10:39:48 <pharm> It's monadic then?
10:39:51 <pharm> OK.
10:42:00 <Saizan_> i've code for creating pgms with Data.Binary, but starting from an Enum b ,Bounded b => Array (Int,Int) b
10:42:36 <pharm> Saizan_: pointer?
10:42:54 <pharm> sounds useful
10:43:31 <quicksilver> dcoutts: what is the chunksize in a runPut bytesting?
10:43:50 <dcoutts> quicksilver: nearly 32k iirc
10:43:59 * quicksilver nods
10:44:25 <quicksilver> so it does 'strictify' your code in 32k lumps, then. Not that I'm suggesting that's a bad thing.
10:44:45 <dcoutts> right
10:45:07 <dcoutts> and you can flush whenever you like
10:45:13 <dcoutts> to get smaller chunks
10:45:49 <Saizan_> what happened to hpaste?
10:45:59 <pharm> hmm. maping (runPut . putWord8) over [Word8] seems like the wrong thing somehow. It's type correct though...
10:46:03 <quicksilver> you can flush from inside the Put monad?
10:46:31 <quicksilver> pharm: yes, that is wrong
10:46:43 <dcoutts> quicksilver: yes
10:47:02 <quicksilver> pharm: you want to mapM putWord8 over [Word8], and then runPut the whole thing
10:47:18 <pharm> I thought I'd tried that. Hold on..
10:47:30 <dcoutts> pharm: runPut (sequence_ putWord8 words)
10:48:56 <pharm> I'm in the IO Monad here.
10:49:36 * pharm wrestles with type system
10:49:51 <dcoutts> pharm: B.writeFile "output" (runPut (sequence_ putWord8 words))
10:51:02 <pharm> :t runPut (sequence_ putWord8 words)
10:51:05 <lambdabot> Not in scope: `runPut'
10:51:05 <lambdabot>  
10:51:05 <lambdabot> <interactive>:1:18: Not in scope: `putWord8'
10:51:21 <pharm> Couldn't match expected type `[t -> a]' against inferred type `Word8 -> Put'
10:51:23 <takamura> hi
10:51:33 <pharm> oops
10:51:38 <Saizan> mapM_?
10:51:43 <pharm> sorry lambdabot
10:51:58 <dcoutts> oh yes
10:52:05 <dcoutts> pharm: B.writeFile "output" (runPut (mapM_ putWord8 words))
10:52:06 <pharm> ah ha
10:52:18 <pharm> yes, mapM_ is the relevant magic incantation\
10:52:23 <sjanssen> doesn't pack make more sense there?
10:52:25 <olsner> :t (\x -> Data.Binary.runPut (sequence_ Data.Binary.putWord8 x))
10:52:27 <lambdabot> Not in scope: `Data.Binary.runPut'
10:52:35 <olsner> :t (\x -> Data.Binary.Put.runPut (sequence_ Data.Binary.putWord8 x))
10:52:37 <lambdabot>     Couldn't match expected type `[t -> a]'
10:52:37 <lambdabot>            against inferred type `Word8 -> Data.Binary.Put.Put'
10:52:59 <sjanssen> @type Data.ByteString.Lazy.putStr . Data.ByteString.Lazy.pack
10:53:01 <lambdabot> [Word8] -> IO ()
10:53:09 <pharm> maybe: I could just pack the [Word8] and then output the bytestring...
10:53:32 <dcoutts> pharm: I thought you started with a list of Int, not Word8
10:54:54 <pharm> I start with a [Double] which I floor to get integers of some type: I want to spit out a bunch of raw bytes. The value of the integers won't exceed 255
10:57:21 <quicksilver> pharm: yes, hence my comment some screens back saying that 'pack is only 4 chars' :)
10:57:35 <arcatan> huh, isn't there a darcs package for OpenBSD...
10:58:30 <arcatan> apparently not prebuilt for sparc64...
10:59:17 <hstenstrom> Is there a better way to calculate the length of a list? I used ghci to calculate the length of [1..2^23]. I got the right answer after quite a while, but then the screen was locked, and there was a spontaneous logout. In languages such as C++, Python, Matlab or LabView, it's instantaneous. Can it be fast in Haskell too?
10:59:17 <lambdabot> hstenstrom: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:37 <quicksilver> hstenstrom: no
10:59:52 <mux> hstenstrom: the default list type in Haskell is lazy, thus you have no way to tell the length of a list before having completely traversed it
10:59:52 <quicksilver> hstenstrom: it is the very nature of 'list' that its length is not stored anywhere
10:59:56 <pharm> quicksilver: It just seems overkill to convert to a bytestring (and pay the overhead of allocation & serialisation into the bytestring) when all I want to do is output a simple [Word8]
11:00:00 <mux> hstenstrom: this is what allows infinite lists
11:00:01 <hstenstrom> That's sad. So it's a fundamental limitation, then?
11:00:12 <quicksilver> hstenstrom: it's not sad, at all
11:00:12 <mux> hstenstrom: if you need a fast length function, you should use another data structure
11:00:21 <quicksilver> hstenstrom: it's a consequence of what 'list' means
11:00:25 <quicksilver> (in this sense)
11:00:26 <mux> hstenstrom: there are other data structures that will give you O(1) length
11:00:36 <quicksilver> I should say, it's a consequence of what that type [a] means
11:00:53 <quicksilver> pharm: it's morally equivalent to do buffer IO instead of char-based IO
11:01:08 <quicksilver> pharm: calling putchar lots of times in C will be pretty slow too
11:01:22 <pharm> quicksilver: true
11:01:55 * pharm discoveres that the code is still gruesomely slow, only the 32kb buffer size means the output takes longer to start appearing...
11:02:06 <quicksilver> I don't think B.write . B.pack is all that exessive
11:02:09 <hstenstrom> I was reading some C code for FFT, which involved spacing N kind of equidistant complex numbers, where N is often large, like 2^20. Perhaps I don't need to construct the list...
11:02:23 <mux> hstenstrom: for instance, in the case of Strings ([Char]), Data.ByteString provides you with O(1) length
11:02:42 <quicksilver> hstenstrom: I'm not familiar with the algorithm, but it's unlikielyt that a list of length 2^20 is what you want
11:02:48 <quicksilver> hstenstrom: perhaps an array
11:03:17 <mux> hstenstrom: Data.Sequence also offers O(1) length
11:03:20 <pharm> time for some profiling...
11:03:31 <quicksilver> pharm: yeah, sounds like the IO wasn't your problem anyhow :)
11:03:48 <hstenstrom> Thank's for the advice. I'll be back later.
11:04:17 <pharm> quicksilver: From an IO POV, I just wanted some output!
11:04:50 <quicksilver> nod :)
11:04:58 <quicksilver> well it's been an interesting diversion anyhow...
11:06:05 <pharm> Indeed.
11:08:09 <pharm> As a mattter of form, if I know I'm going to need all the results, should I always replace foldl with foldl' ?
11:08:31 <pharm> Thanks for the pointers everyone anyway...
11:08:46 <sjanssen> pharm: yes, you almost always want foldl' over foldl
11:23:33 <pharm> Hmm. profiling reveals that I'm calling a function 10x as often as I should be!
11:33:39 <pharm> Oh wait, that's probably laziness in action isn't it...
11:34:29 <olsner> 10x as often? I thought laziness should only be able to decrease the number of calls?
11:36:06 <pharm> I'm calling a function which returns a list of values on each pixel.
11:36:08 <Baughn> Indeed. If it's being called more often, that's something else wrong.
11:36:40 <pharm> Profiling is showing ~10x NxN calls to 'pixel_vals' for an NxN image
11:37:33 <Baughn> pharm: Then your code is inefficient, but laziness is decidedly /not/ the culprit. As olsner says, it only decreases the number of calls, never increases. (Though it does increase the cost of each call)
11:38:04 <Baughn> Hang on. pixel_vals returns a list of pixels? And it's being called repeatedly?
11:38:15 <Saizan> i don't think entries == number of calls
11:38:16 <Baughn> Why would you even need to call it more than once?
11:38:46 <pharm> No, a list of values for each pixel. Which I then sum to get the value for the pixel in question.
11:39:06 <pharm> so the code looks like: map sum $ liftM2 pixel_vals [0..N] [0..N]
11:39:53 <Saizan> what's the length of each list?
11:40:20 <pharm> About 9 IIRC.
11:40:58 <pharm> yup
11:40:59 <Saizan> so map has to enter inside each list ~10 times
11:41:31 <Saizan> but i'm just pseculating on what "entries" means inside .prof
11:41:34 <pharm> which is why I presumed that the 'calls' were down to lazy evaluation of the result lists...
11:41:41 <pharm> likewise.
11:42:10 <pharm> the ghc manual says: The number of times this particular point in the call graph was entered.
11:42:49 <Baughn> It should be possible to test. Something like foo = [1..100]; main = print $ sum foo
11:43:09 <Baughn> I'm inclined to think that will only show one entry to foo
11:43:09 <pharm> I appear to be spending most of my time on floating point calculations. But it really shouldn't be taking this long. Perhaps it's boxing and unboxing the Floats?
11:43:25 <Baughn> Probably.
11:43:29 <pharm> Nggg.
11:43:32 <pharm> Hate.
11:43:46 <Baughn> pharm: Have you tried compiling with -O2?
11:43:51 <pharm> Time to refactor then.
11:43:56 <pharm> Yes.
11:44:03 <Saizan> adding some bang patterns?
11:44:34 <pharm> I'm doing a spot of vector arithmetic, but currently the types look like V {x,y,z::Float}
11:44:48 <pharm> maybe I should just make them tuples...
11:44:50 <sjanssen> pharm: add a ! in front of Float
11:44:59 <sjanssen> and compile with -funbox-strict-fields
11:45:22 <pharm> parse error on input `::!'
11:45:34 <Baughn> In front of the x,y and z, rather
11:45:37 <pharm> data Vector = V {x,y,z::!Float} deriving (Eq,Show) is not happy
11:46:07 <pharm> it hates that as well.
11:46:20 <sjanssen> data V = V { x, y, z :: ! Float }
11:46:28 <pharm> weird. Surely I should be able to make named fields strict?
11:46:55 <Baughn> Certainly, but.. hmm, /after/ the x, y and z?
11:47:09 <pharm> nope
11:47:22 <pharm> that doesn't work either (I have actualy tried all these already!)
11:47:23 <sjanssen> pharm: space after ::
11:47:46 <pharm> ah ha
11:47:55 <pharm> data Vector = V {x,y,z :: !Float} works
11:47:58 <pharm> now that's evil.
11:48:06 <sjanssen> otherwise it lexes as a ::! operator
11:48:11 <pharm> does it think ::! is supposed to be an operator
11:48:15 <pharm> you beat me to it...
11:49:06 <jmg_> hi
11:50:57 <jmg_> anybody tried to compile yi from darcs lately?
11:51:05 <Baughn> pharm: Given that you can defined operators, yes. It makes sense, in retrospect.
11:51:08 <Baughn> *define
11:51:20 <Procyon112> ping chessguy
11:51:25 <pharm> indeed.
11:51:29 <pharm> confused me though.
11:52:25 <pharm> OK. Strictness is not helping. How odd.
11:54:43 <Lemmih> Adding strictness at random is like fishing without bait.
11:55:10 <pharm> It seemed like a good idea at the time...
11:55:18 <davidL> by enabling daily digest on a mailing list does that reduce the number of emails to 1 per day, or is that 1 email in addition to everything else?
11:55:30 <Baughn> davidL: Former.
11:55:45 <Baughn> Quite useless, these days, but it used to be handy when network connections were slow.
11:55:52 <davidL> Baughn: thank you
11:55:53 <pharm> I'm spending most of my time doing simple vector arithmetic & it's *very* slow.
11:56:08 <davidL> well I dislike having hundreds of emails in my inbox ;)
11:56:20 <Baughn> davidL: So filter them into another mailbox. ;)
11:56:37 <Lemmih> pharm: -ddump-simpl ?
11:56:40 <Baughn> pharm: http://www.haskell.org/ghc/docs/latest/html/users_guide/sooner-faster-quicker.html might be handy
11:56:42 <lambdabot> Title: Chapter 6. Advice on: sooner, faster, smaller, thriftier, http://tinyurl.com/2hz2fc
12:07:19 <pharm> I'll have a prod.
12:13:55 <Excedrin> is there something like "views" in Haskell? I don't know if it's basically the same as typeclasses
12:14:07 <Excedrin> I was reading about them here http://www.ps.uni-sb.de/hamlet/README-succ.txt
12:14:46 <ibid> no, there isn't. there was a proposal but it was rejected, many many years ago
12:14:56 <DRMacIver> They're vaguely proposed for Haskell', but no one seems to know how they should work. :)
12:15:07 <DRMacIver> Or they were at one point.
12:15:25 <ibid> i believe there was a concrete proposal in the early days
12:15:32 <DRMacIver> Oh, was there? Ok
12:16:05 <Excedrin> is there a "better" description of what views are somewhere?
12:16:09 <chr1s_> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
12:16:11 <lambdabot> Title: ViewPatterns - GHC - Trac
12:16:37 <chr1s_> there's lots of info there.
12:17:23 <ibid> DRMacIver: early days = 1990 or so :)
12:18:24 <Excedrin> chr1s_: thanks
12:19:37 <DRMacIver> ibid: Oh, right. :)
12:21:56 <Mind7> Free calls - http://callfree.point-serv.com/en/
12:21:59 <lambdabot> Title: Free phone calls all around the world | Free Calls
12:23:55 <int-e> lambdabot: shame on you.
12:24:02 <Japsu> :D
12:26:12 <chessguy> hmm, someone probably oughta +b that guy
12:26:28 <int-e> he got k-lined
12:26:44 <dmead> > la la la la laaaaaaaaaaaaa
12:26:45 <lambdabot>   Not in scope: `laaaaaaaaaaaaa'
12:27:01 <Japsu> :t la
12:27:03 <lambdabot> Not in scope: `la'
12:27:06 <timlarson_> k-lined -> stuck in a klein bottle ;)
12:27:10 <Japsu> haha
12:27:31 <pharm> OK. So the ghc optimisation page says strictness is good.
12:28:26 <pharm> If I have a datatype Vector = V {x,y,z :: !Float} and a function dot (V x y z) (V x2 y2 z2) = ... why isn't that strict in its arguments? Do I have to sprinkle $! everywhere|?
12:30:23 <int-e> pharm: how do you know that it's not strict? it looks like a case where the compiler should be able to figure that out
12:31:29 <pharm> -ddump-simpl says its lazy
12:31:43 <pharm> with -O2 -funbox-strict-fields
12:31:52 <dmwit> ?src read Data.Map
12:31:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:31:58 <dmwit> ?src Data.Map read
12:31:58 <lambdabot> Source not found. It can only be attributed to human error.
12:32:13 <dmwit> ?where source
12:32:13 <lambdabot> I know nothing about source.
12:32:28 <chessguy> @source Data.Map
12:32:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
12:32:38 <dmwit> Thanks.
12:34:26 <int-e> pharm: I'm assuming something like dot (V x y z) (V a b c) = x*a + y*b + z*c
12:35:07 <int-e> pharm: and the simplifier output here gives something that it wants to inline. (which ought to be better than strictness even)
12:37:33 <pharm> maybe
12:37:44 <pharm> (yes, it's dot product on vectors...)
12:37:53 <pharm> it's still *very* slow.
12:37:57 <pharm> humph.
12:44:14 <pharm> OK. Something odd is going on. Calculating a*a is using half the time that a^2 is. Ick.
12:44:58 <int-e> pharm: oh. ^ doesn't get unfolded by ghc because it's recursive, even if the exponent is a constant
12:45:44 <pharm> !
12:46:12 <int-e> at least that's what I think - look at the generated core, it still contains calls to the library (^) function
12:46:26 <int-e> sadly.
12:46:50 <sjanssen> pharm: a ^ (2::Int) should be a bit faster
12:47:01 <SamB_XP> int-e: does it depend at all on the exponent?
12:47:09 <int-e> sjanssen: but it still won't get optimized to a*a I think.
12:47:16 <sjanssen> no, probably not
12:47:29 <SamB_XP> GHC can be so stupid
12:47:35 <int-e> SamB_XP: in my last experiment it didn't, even a^0 didn't get optimized to 1. My methodology may have been flawed though.
12:47:59 * pharm beats head on table. 
12:48:07 <SamB_XP> I wonder if a ^ (2::Nat) is any better?
12:48:16 <int-e> SamB_XP: adding a wrapper around (^) that explicitely unfolds small exponents and only calls (^) for large exponents helped.
12:48:45 <int-e> SamB_XP: so I blame ghc's failure on the fact that (^) is calling itself recursively.
12:48:51 <pharm> Isn't there a power instruction for floats on x86?
12:49:00 <SamB_XP> pharm: try **
12:49:08 <SamB_XP> if you want that
12:49:24 <int-e> pharm: hmm. no, not really - it has to be done with logs and exponentiation.
12:49:37 <SamB_XP> int-e: really?
12:49:54 <SamB_XP> my CPU uses log tables for powers?
12:50:02 <SamB_XP> well, probably sans tables ;-)
12:50:07 <pharm> Yeah, floating point exponentiation is what I'm after...
12:50:16 <int-e> SamB_XP: really. what did you expect? it has builtin 2^x and e^x instructions.
12:50:18 <SamB_XP> > exp 2
12:50:19 <int-e> (IIRC)
12:50:20 <lambdabot>  7.38905609893065
12:50:46 <int-e> hmm. no, 2^x only.
12:51:02 <SamB_XP> you can't be serious
12:51:02 <int-e> and they have builtin constants like log_2 e :)
12:51:18 <SamB_XP> oh.
12:52:18 <pharm> OK a**2 is slightly faster than a*a. Why can't ghc specialise ^ to ** for floats?
12:52:20 <SamB_XP> and this kind of thing is why we aren't allowed to bind #-kinded things at the top level?
12:52:40 <SamB_XP> pharm: it isn't quite accurate?
12:52:57 <sjanssen> @check \x -> x**2 == x*x
12:52:58 <lambdabot>  Add a type signature
12:53:06 <int-e> @check \a -> a**2 == (a*a :: Double)
12:53:07 <lambdabot>  OK, passed 500 tests.
12:53:25 <bd_> @check \a -> a**4 == (a*a*a*a :: Double)
12:53:26 <lambdabot>  Falsifiable, after 10 tests: -0.6666666666666667
12:53:31 <pharm> SamB_XP: If you're using Floats at all, then you don't care about absolute accuracy anyway...
12:53:34 <sjanssen> @check \x -> x**2 == (x*x :: Float)
12:53:35 <lambdabot>  OK, passed 500 tests.
12:54:07 <int-e> @check \a -> a**4 == (a*a)*(a*a :: Double)
12:54:08 <SamB_XP> @check \x y -> x**(fromInteger y :: Float) == x^y
12:54:09 <lambdabot>  Falsifiable, after 6 tests: 2.3333333333333335
12:54:10 <lambdabot>  Exception: Prelude.^: negative exponent
12:54:14 <SamB_XP> hmm.
12:54:27 <SamB_XP> @check \x y -> y > 0 ==> x**(fromInteger y :: Float) == x^y
12:54:28 <lambdabot>  Falsifiable, after 16 tests: 6.142857, 4
12:54:34 <vlm> why one would use Float instead of Double?
12:54:38 <pharm> Float ^ Int is going to be a Float...
12:54:44 <SamB_XP> vlm: tests fail sooner
12:54:49 <pharm> :)
12:55:17 <int-e> > exp 4 ** 2 == exp 4*exp 4
12:55:18 <lambdabot>  False
12:55:21 <vlm> SamB_XP: why? Double is faster on Intel
12:55:23 <SamB_XP> @scheck \x y -> y > 0 ==> x**(fromInteger y :: Float) == x^y
12:55:24 <lambdabot>   Completed 1027 test(s) without failure.  But 553 did not meet ==> condition.
12:55:39 <SamB_XP> vlm: but precision problems crop up more frequently
12:56:03 <SamB_XP> I guess smallcheck needs better generators for floats...
12:56:09 <vlm> SamB_XP: so one is supposed to test with Floats and work with Doubles?
12:56:16 <pharm> Your going to tell me that sqrt isn't specialised on Float/Double either next aren't you...
12:56:22 <pharm> s/Your/You're/
12:56:37 <SamB_XP> vlm: when it comes to simple properties like these, Floats are faster for testing...
12:56:44 <SamB_XP> pharm: hah
12:56:55 <SamB_XP> @doc Floating
12:56:55 <lambdabot> Floating not available
12:57:07 <SamB_XP> arg.
12:57:11 <int-e> oh the processor does have an sqrt instruction :)
12:57:18 <int-e> (x87)
12:57:27 <SamB_XP> @doc Data.Real
12:57:27 <lambdabot> Data.Real not available
12:57:30 <SamB_XP> @doc Data.Float
12:57:30 <lambdabot> Data.Float not available
12:57:33 <vlm> SamB_XP: I don't understand why are they faster. Haskell thing?
12:57:36 <SamB_XP> @hoogle Real
12:57:37 <lambdabot> Prelude.Real :: class (Num a, Ord a) => Real a
12:57:37 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
12:57:37 <lambdabot> Prelude.RealFloat :: class (RealFrac a, Floating a) => RealFloat a
12:57:48 <vlm> SamB_XP: or again, fail faster?
12:57:52 <int-e> vlm: lower precision, hence more likely to exhibit rounding erros
12:57:56 <int-e> *errors
12:57:58 <vlm> ok, got it finally
12:58:28 <SamB_XP> @hoogle Float
12:58:29 <lambdabot> Prelude.Float :: data Float
12:58:29 <pharm> incidentally, why doesn't RealFloat contain delta & min/maxBound?
12:58:29 <lambdabot> System.Win32.Types.FLOAT :: type FLOAT
12:58:29 <lambdabot> Text.PrettyPrint.HughesPJ.float :: Float -> Doc
12:58:40 <SamB_XP> @doc Prelude
12:58:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
12:58:58 <SamB_XP> pharm: hmm?
12:59:15 <pharm> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ARealFloat
12:59:17 <lambdabot> http://tinyurl.com/ovjef
12:59:38 <pharm> There's no (easy) way to get the smallest representable number for a floating point representation.
12:59:54 <pharm> Which is kind of necessary for some algorithms: you need to know it.
13:00:17 <pharm> You can calculate it of course, with the aid of floatRange
13:00:34 <SamB_XP> > logBase
13:00:35 <lambdabot>  <Double -> Double -> Double>
13:00:36 <int-e> > last $ takeWhile (/=0) $ iterate (/2) 1
13:00:37 <lambdabot>  5.0e-324
13:00:39 <SamB_XP> oh.
13:00:40 <SamB_XP> oops
13:03:11 <SamB_XP> > decodeFloat 0
13:03:12 <lambdabot>  (0,0)
13:03:19 <dolio> I suppose they don't have min/maxBound because of infinities.
13:04:00 <dolio> As far as the Bounded typeclass goes.
13:04:18 <SamB_XP> > encodeFloat (1, (fst (floatRange 0)))
13:04:18 <lambdabot>  Couldn't match expected type `Integer'
13:04:48 <SamB_XP> > encodeFloat 1 (fst (floatRange 0))
13:04:49 <lambdabot>  4.450147717014403e-308
13:05:00 <SamB_XP> > encodeFloat 1 (fst (floatRange 0)) / 2
13:05:00 <roconnor> @type floatRange
13:05:01 <lambdabot>  2.2250738585072014e-308
13:05:02 <lambdabot> forall a. (RealFloat a) => a -> (Int, Int)
13:05:12 <roconnor> > floatRange 0
13:05:13 <lambdabot>  (-1021,1024)
13:06:16 <SamB_XP> > decodeFloat (encodeFloat 1 (fst (floatRange 0)) / 2)
13:06:17 <lambdabot>  (4503599627370496,-1074)
13:07:35 <quicksilver> pharm: you should probably use Double, it is likely to be much faster
13:07:46 <quicksilver> pharm: and if you get stuck, post your program to haskell-cafe
13:07:56 <quicksilver> pharm: smart people on there have practice with fast floating point code
13:08:10 <SamB_XP> > dropWhile (not . (==0) . (/2)) (iterate (/2) (encodeFloat 1 (fst (floatRange 0)))
13:08:10 <lambdabot>  Parse error
13:08:12 <quicksilver> dons in particular spent quite a while poking at some benchmarks
13:08:13 <SamB_XP> arg
13:08:23 <quicksilver> and learnt what tricks
13:08:33 <SamB_XP> :t dropWhile (not . (==0) . (/2))
13:08:35 <lambdabot> forall a. (Fractional a) => [a] -> [a]
13:08:46 <SamB_XP> > dropWhile (not . (==0) . (/2)) (iterate (/2) (encodeFloat 1 (fst (floatRange 0))))
13:08:47 <lambdabot>  [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0...
13:09:21 <SamB_XP> > head (dropWhile (not . (==0) . (/2)) (iterate (/2) (encodeFloat 1 (fst (floatRange 0))))) == 0
13:09:22 <lambdabot>  True
13:09:34 <SamB_XP> arg.
13:10:06 <SamB_XP> @check isIEEE
13:10:07 <lambdabot>  Add a type signature
13:10:20 <SamB_XP> @check (isIEEE :: Double -> Bool)
13:10:22 <lambdabot>  OK, passed 500 tests.
13:10:26 <chessguy> ?hoogle isIEEE
13:10:26 <lambdabot> Prelude.isIEEE :: RealFloat a => a -> Bool
13:10:37 <chessguy> ?src isIEEE
13:10:38 <lambdabot> Source not found. Do you think like you type?
13:10:41 <pharm> quicksilver: ta
13:10:54 * SamB_XP wonders if isIEEE is allowed to look at its argument
13:11:06 <roconnor> > isIEEE undefined
13:11:07 <lambdabot>  True
13:11:15 <SamB_XP> I guess it doesn't in this case
13:11:22 <SamB_XP> but does that prove anything? not really.
13:11:38 <quicksilver> isn't it static, really?
13:11:47 <quicksilver> it's a function on types
13:11:49 <quicksilver> not values
13:12:03 <quicksilver> > isIEEE (undefined :: Float)
13:12:04 <lambdabot>  True
13:12:09 <quicksilver> > isIEEE (undefined :: Double)
13:12:10 <lambdabot>  True
13:12:18 <quicksilver> @instances RealFloat
13:12:19 <lambdabot> Double, Float
13:12:32 <quicksilver> just means that lambdabot's platform is using IEEE reps, I think
13:12:35 <chessguy> @isntances-importing RealFloat
13:12:36 <lambdabot> Double, Float
13:12:59 <ari> @help instances-importing
13:12:59 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
13:13:11 <quicksilver> so, putatively, on an ARM version you'd get isIEEE (undefined :: Float) = False
13:13:48 <fasta> How can I use ' in CPP macros? E.g. Foo("''")
13:14:36 <quicksilver> Foo(''), I think
13:14:45 <quicksilver> don't think CPP interprets single quotes
13:15:49 * int-e ponders suggesting m4
13:16:13 <int-e> (m4 may be evil and awful, but at least it has a proper quoting mechanism)
13:17:06 <pharm> ta everyone: got to go.
13:19:52 <Procyon112> ping chessguy
13:20:00 <chessguy> pong
13:20:06 <chessguy> you're interrupting my poker game though
13:20:13 <Procyon112> hehe
13:20:22 <dolio> Heh, "This is a little challenge to test the expressive power of your favorite programming language:" coerce a double into the platform-specific bits representing it.
13:20:39 <Procyon112> thoughts on that randomization/state monad rant?
13:20:56 <chessguy> Procyon112, well, your tell got cut off
13:21:01 <Procyon112> oh
13:21:21 <chessguy> are you suggesting that we thread the generator through all the functions that need it?
13:21:40 <Procyon112> no.. that's what we are currently doing.
13:21:49 <SamB> hmm, GHC's floatRange is apparantly based on the foo_{MIN,MAX}_EXP from <float.h>
13:21:50 <Procyon112> (via state monad)
13:21:53 <Vulpyne> dolio: char a[sizeof(double)]; memcpy(a, &thedouble, sizeof(double));
13:21:54 <Vulpyne> Heh.
13:22:14 <SamB> which is the range of exponents in *normalized* floating-point numbers
13:22:20 <Procyon112> I'm thinking more along the lines of having a generator generator.
13:22:49 <int-e> doubleToBits (D# d) = W64# (unsafeCoerce# d)
13:23:26 <chessguy> how would that work?
13:23:32 <dolio> int-e: That's the sort of thing I was thinking, but evidently I lack GHC.Prim.
13:23:40 <Procyon112> right now, lets say I want to generate 3 trees... I need to pass the randstate to tree1, wait for completion, then to tree2, wait for completion, then tree3, because tree generation requires the randstate to be updated multiple times.  This serializes the computation.
13:23:55 <sjanssen> @hoogle split
13:23:57 <int-e> dolio: hmm. you can use System.Unsafe.unsafeCoerce then, I think.
13:23:59 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
13:23:59 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
13:23:59 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
13:24:14 <sjanssen> Procyon112: use System.Random.split?
13:24:20 <int-e> dolio: or use ghc 6.6.1
13:24:29 <Procyon112> I'm wondering if there isn't a way to generate 3 generators, and pass 1 to each tree generation.
13:24:39 * SamB really wishes they wouldn't change the library API between GHC patchlevels
13:24:50 <Procyon112> sjanssen: yeah!  like that!
13:24:56 <dolio> int-e: I have 6.7.20070503. I must not have build correctly.
13:24:59 <int-e> I'm not sure whether Ghc.Prim is even supposed to be hidden like that.
13:25:03 <quicksilver> it's an interesting challenge, because it is actually a metric of how *bad* your programming language is
13:25:07 <chessguy> like a lazy list of generators?
13:25:11 <int-e> dolio: it is currently not available in ghc head.
13:25:11 <SamB> int-e: is that even the real name?
13:25:16 <quicksilver> i.e., the extent to which implementation details leak out
13:25:17 <dolio> Ah. That explains it, then.
13:25:24 <int-e> SamB: no, it's GHC.Prim
13:25:37 <Procyon112> That way evaluation of tree 2 doesn't have to wait for generation of tree 1 to be completed.
13:25:38 <SamB> @hoogle Prim
13:25:39 <lambdabot> Text.ParserCombinators.Parsec.Prim :: module
13:25:39 <lambdabot> Language.Haskell.TH.PrimTyConI :: Name -> Int -> Bool -> Info
13:25:39 <lambdabot> System.Win32.NLS.PrimaryLANGID :: type PrimaryLANGID
13:25:44 <SamB> @hoogle GHC.Prim
13:25:44 <lambdabot> No matches, try a more general search
13:25:46 <dolio> quicksilver: Yeah, I thought it was amusing for that reason.
13:25:48 <SamB> @hoogle I#
13:25:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
13:25:50 <int-e> SamB: oh the unsafe... hmm.
13:26:01 <chessguy> @source GHC.Prim
13:26:01 <lambdabot> GHC.Prim not available
13:26:06 <chessguy> @source GHC
13:26:06 <lambdabot> GHC not available
13:26:08 <SamB> anyway, what about the PrimopWrappers
13:26:17 <quicksilver> so the GHC developers should not be proud that it's expressible in GHC :)
13:26:22 <int-e> is System.IO.Unsafe
13:26:27 <chessguy> Procyon112, hmmmm. i'm not sure how that would look
13:26:34 <quicksilver> it is, of course, possible to write a doubleToIEEERep :: Double -> [Word8]
13:26:35 <SamB> :t GHC.PrimopWrappers.unsafeCoerce#
13:26:40 <lambdabot> Not in scope: `GHC.PrimopWrappers.unsafeCoerce#'
13:26:42 <quicksilver> but that's not what the code asks for
13:26:48 <quicksilver> because your machine might not be IEEE
13:26:52 <int-e> quicksilver: why not? all bets are off if unsafeCoerce# is involved
13:27:11 <quicksilver> int-e: I'm joking ;)
13:27:16 <SamB_XP> > decodeFloat (0/0)
13:27:17 <lambdabot>  (-6755399441055744,972)
13:27:27 <SamB_XP> thats a pretty odd decoding
13:27:43 <Procyon112> chessguy: so, instead of passing the state monad down to the generator function, and require the generator to return a state, we do something like Random.split and pass the new generator down to the tree generation function, and get back just the tree, not the tree in a state monad containing the updated generator.
13:27:51 <largos> are there any haskell libraries for image manipulations? (eg: something like perlmagick)
13:28:06 <int-e> oh, hpaste is down? sniff.
13:28:11 <chessguy> oh
13:28:35 <quicksilver> largos: no, I don't think so
13:28:37 <chessguy> so then we have something like generateTree :: Gen -> Program
13:28:40 <quicksilver> largos: it's a bit of a hole
13:28:47 <roconnor> > encodeFloat (-6755399441055744,972)
13:28:48 <lambdabot>  Couldn't match expected type `Integer'
13:28:55 <quicksilver> largos: there are fragments of image loading + writing stuff in the gtk library, and possibly elsewhere
13:28:59 <roconnor> > encodeFloat (-6755399441055744) 972
13:29:00 <lambdabot>  -Infinity
13:29:48 <Procyon112> chessguy: right.  Random.split has some discouraging commentary on the statistical properties though: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html#v%3Asplit
13:29:50 <lambdabot> http://tinyurl.com/eu3xo
13:30:25 <vlm> is there any problems invoking SYB everywhere recursively? It space-leaks on each throwError in my custom monad.
13:30:28 <dmwit> ?src parens
13:30:28 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:30:35 <int-e> unsafeCoerce# even allows stuff like this: http://paste.lisp.org/display/42083
13:30:37 <Procyon112> I'm not sure what that says about the default implementation.
13:30:42 <dmwit> ?hoogle parens
13:30:43 <lambdabot> Text.PrettyPrint.HughesPJ.parens :: Doc -> Doc
13:30:43 <lambdabot> Text.ParserCombinators.Parsec.Token.parens :: TokenParser st -> CharParser st a -> CharParser st a
13:30:43 <lambdabot> Language.Haskell.TH.Ppr.parensIf :: Bool -> Doc -> Doc
13:30:50 <chessguy> hmm, perhaps they're being overly cautious?
13:31:20 <quicksilver> chessguy: I'd be inclined to  aim for elegance first
13:31:32 <quicksilver> chessguy: and worry about detailed randomness afterwards :)
13:31:37 <quicksilver> chessguy: and split is nice and elegant
13:31:40 <Procyon112> chessguy: could be... we aren't interested in cryptographically secure generators anyway.
13:31:42 <chessguy> not a bad idea
13:31:54 <chessguy> also true
13:32:46 <Syzygy-> quicksilver: Why don't you care for cryptographically secure generators?
13:32:52 <Procyon112> Switching to split alone would eliminate a huge reliance on our state monad.
13:33:03 <chessguy> @hoogle split
13:33:03 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
13:33:03 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
13:33:03 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
13:33:42 <Procyon112> Syzygy: It's not that I don't care FOR them.. it's that I don't care if they are secure for the purposes of generating random syntax trees for genetic programming.
13:33:54 <Syzygy-> Ah.
13:34:02 <chessguy> Procyon112, well, we'll still want the state for the sake of our config options
13:34:45 <Procyon112> chessguy: not neccissarilly... we can use Reader for that, which doesn't serialize anything.
13:35:13 <chessguy> i'm not sure what you mean by "doesn't serialize anything"
13:35:27 <int-e> dolio: oh btw, unsafeCoerce# is also exported by GHC.Base
13:36:40 <Procyon112> chessguy: get and put in State need to be serialized because (obviously) you want to get what was the most recent put. since Reader never puts, the order of evaluation doesn't have to be set at all.
13:36:47 <dolio> quicksilver: The real joke is that their example C++ program is like 20 lines, and the equivalent haskell is probably like 5. So I guess it does show Haskell's expressiveness. :)
13:36:51 <chessguy> Procyon112, though, really, if my DSL approach is successful, hopefully we won't really need too much config stuff
13:36:56 <dolio> int-e: Ah. That works. :)
13:37:25 <chessguy> Procyon112, oh, i thought you meant serialization in the sense of serializable objects
13:37:39 <chessguy> like Jav-...uhhh, some other languages
13:37:48 <monochrom> Java!
13:38:53 <dmwit> ?source Text.Read
13:38:53 <lambdabot> http://darcs.haskell.org/packages/base/Text/Read.hs
13:39:22 <chessguy> dolio, even funnier is that C++ is supposedly a lower-level language
13:39:25 <Procyon112> chessguy: hehe.. no.. I'm talking about order of evaluation.  By our current use of the State monad to thread around the random generator, we are forcing our evalutaion to be strict... and worse, we are forcing it to be non-parallizeable.
13:39:37 <chessguy> Procyon112, yes
13:39:43 <quicksilver> dolio: yeah :)
13:41:29 <chessguy> Procyon112, that makes more sense now
13:44:17 <roconnor> Since when does using the state monad force evaluation to be strict?
13:45:06 <roconnor> @type evalState
13:45:10 <lambdabot> forall s a. State s a -> s -> a
13:45:17 <Procyon112> roconnor: If you put a value, then vet a value in the State monad, the get forces the put to be evaluated.
13:45:34 <roconnor> @type runState
13:45:35 <lambdabot> forall s a. State s a -> s -> (a, s)
13:46:18 <roconnor> > runState (do put undefined; x<- get; put 5; return 6) 0
13:46:20 <lambdabot>  (6,5)
13:46:21 <Procyon112> roconnor: If every operation a function does does a get .. mutate value .. put, then that string of function calls ends up evaluating strictly.
13:46:29 <roconnor> what's the problem?
13:47:00 <Procyon112> roconnor: not purely strict, but definately serialized.
13:47:25 <monochrom> No problem for some applications.  Not the best for random, since Random.split offers an alternative.
13:48:06 <chessguy> Procyon112, i gotta get pack to work here
13:48:09 <chessguy> *back
13:48:20 <Procyon112> roconnor: The problem is, when the only thing you are interested in threading through the state monad and mutating is a random number generator, and you don't care what order the numbers come out, as long as they are random, then you are forcing strictness you don't need.
13:48:26 <Procyon112> see ya!
13:48:31 <chessguy> soon i'll be moved to an area where i don't know anyone, so i suspect i'll get a lot more coding done for a few weeks!
13:49:57 <Procyon112> roconnor: which really bites us when we decide that we want to do all these otherwise purely functional operations in parallel, but we are stuck in a serialized algorithm that we don't even need.
13:50:24 <roconnor> Hmm, I wonder if MonadRandom is an instance of MonadPlus
13:50:26 <SamB> Procyon112: split all the way
13:50:41 <Procyon112> yup.. split looks like a good solution.
13:50:47 <monochrom> Not yet. It's State.
13:51:00 <sjanssen> roconnor: I doubt it, what would mzero be?
13:51:06 <roconnor> crap
13:51:09 <roconnor> damn zero
13:51:28 <monochrom> mzero is when the generator runs dry.
13:51:45 <Procyon112> sjanssen++ -- for pointing out spli :)
13:51:51 <monochrom> err nevermind, take that as a joke, I'm not thinking.
13:52:45 <SamB> that octal syntax is really funny looking...
13:53:00 <roconnor> what's the current status of the correlation in various splits of the random generator?
13:53:04 <Procyon112> monochrom: or when it reaches it's period
13:53:05 <monochrom> Like \o0 you're referring to?
13:53:20 <SamB> > 0o777777
13:53:21 <lambdabot>  262143
13:54:00 <monochrom> > 0b0011
13:54:00 <lambdabot>   Not in scope: `b0011'
13:55:44 <scodil> what is a context reduction stack overflow?
13:57:14 <SamB> scodil: you're using fundeps?
13:57:27 <Procyon112> So, Random.split :: g -> (g, g) Are the g's in the tuple both distinct from the g's in the input?  I don't see that as an guarantee in the docs...
13:57:38 <SamB> are you trying to run a turing machine at compile time, by any chance?
13:57:44 <scodil> samb: yes
13:57:48 <scodil> no
13:57:53 <SamB> hehe
13:57:54 <scodil> wait... fundeps yes, turing machine now
13:57:56 <scodil> no
13:57:59 <scodil> ack
13:58:01 <scodil> can't type
13:58:06 <SamB> well, make sure you aren't going into infinite loops
13:58:27 <monochrom> Most likely. I think after (h,i) = split g you're expected to throw away g and just use h and i.
13:58:28 <SamB> it means your types are really complicated to check
13:58:39 <Saizan> > let g =(mkStdGen 1) in (g,split g)
13:58:41 <lambdabot>  (2 1,(3 40692,80028 2147483398))
13:59:01 <SamB> interesting output
13:59:09 <roconnor> > mkStdGen 1
13:59:10 <lambdabot>  2 1
13:59:23 <monochrom> h and i may be independent of each other (if the lib is implemented well) but g may still have correlation with both h and i.
13:59:41 <monochrom> The above are my guesses. No evidence.
13:59:52 <SamB> hey
14:00:18 <SamB> how do you squeeze an Integer into a 1's complement representation of a certain width?
14:00:44 <pharm> Ah. getting there. -fexcess-precision makes a 30% different to my floating point app.
14:00:55 <SamB> ... assuming it is positive
14:00:56 <Procyon112> monochrom my concern is implementations where (h,i) = split g then (j,k) = split h, and you end up with k==i because h==g
14:01:20 <Procyon112> I'll test it before using :)
14:01:39 <SamB> Procyon112: I'm pretty sure split is supposed to do something
14:01:49 <roconnor> Procyon112: I vaguely recall hugs behaving like that at some point in time
14:03:01 <SamB> http://haskell.org/onlinereport/random.html
14:03:02 <lambdabot> Title: The Haskell 98 Library Report: Random Numbers
14:03:45 <SamB> Procyon112: just write a quickcheck property and add it to your tests?
14:04:10 <monochrom> Hahaha, using a random generator to test certain random generators... :)
14:04:14 <Procyon112> "all we require is that split deliver generators that are (a) not identical and (b) independently robust in the sense just given."
14:04:25 <Procyon112> So they could do exactly as I described above.
14:04:34 <SamB> true
14:04:55 <SamB> are they going to address this in Haskell'?
14:05:56 <SamB> say, has anyone got some quickcheck properties for Num lying about?
14:07:02 <Procyon112> I think they should add: "(c) both robustly generated from the parameter"
14:07:41 <SamB> well, for some value of "robust"
14:07:59 <Procyon112> "robust in the sense just given"  :)
14:08:29 <Procyon112> which is: "at least as statistically robust as the "Minimal Standard Random Number Generator" described by [2,3]"
14:08:50 <SamB> well, the references for robustness of split are [1,4]
14:09:01 <SamB> now that I look at it
14:09:45 <Procyon112> I can see that h and i may not be robust in relation to each other... I'm not concerned about that though, since I'm not using it for crypto
14:10:00 <int-e> > (-5) ** (-3)
14:10:08 <lambdabot>  -8.0e-3
14:10:18 <SamB> say, isn't this lovely?
14:10:20 <SamB> *Arith> -0 :: Pdp1Word
14:10:20 <SamB> 0o777777
14:11:29 <kpreid> > 0o777777 + 1
14:11:30 <lambdabot>  262144
14:11:51 <Procyon112> SamB: AHH! it's covered later on, at the end of 27.1: A superficially attractive implementation of split is
14:11:53 <kpreid> > (0o777777 + 1) `logBase` 2
14:11:54 <lambdabot>  5.555555555555555e-2
14:11:59 <Procyon112> split g = (g, variantOf g)
14:12:15 <SamB> kpreid: hint: the PDP-1 uses 1's complement
14:12:20 <Procyon112> SamB: The spec says this is not acceptable.
14:12:29 <SamB> ah.
14:12:33 <kpreid> SamB: oh, okay.
14:14:24 <int-e> The crazy thing is that posix requires integer exponents to work with negative bases in pow().
14:16:21 <SamB> int-e: what's so crazy about that?
14:16:29 <SamB> pow = (**)
14:16:49 <SamB> oh. wait.
14:16:50 <int-e> SamB: you can't evaluate that with the exp(e*log(b)) formula so you need to test for integer exponents.
14:16:52 * SamB understands now
14:17:02 <SamB> > -1**4
14:17:04 <lambdabot>  -1.0
14:17:07 <SamB> > (-1)**4
14:17:08 <lambdabot>  1.0
14:18:12 <SamB> man, fromInteger for 1's complement looks really inefficient
14:20:38 <pitecus> Im trying to compile code which uses C code which uses some Fortran code, and I get the following:
14:20:40 <pitecus> $ ghc -lstdc++  -o xxx IntModel.o c_maxentmodel.o libmaxent.a -lz -lm  -lgfortranbegin -lgfortran -lm -lgcc_s/usr/lib/gcc/i386-redhat-linux/4.1.1/libgfortranbegin.a(fmain.o): In function `main':
14:20:40 <pitecus> (.text+0x23): undefined reference to `MAIN__'
14:20:40 <pitecus> collect2: ld returned 1 exit status
14:21:02 <pitecus> Any idea what might be going wrong?
14:24:59 <SamB> perhaps you've confused GCC into thinking that your main function is in FORTRAN?
14:25:23 <SamB> well, maybe you should just take out -lgfortranbegin
14:26:47 <Jaggederest> snarky suggestion: try not using fortran?
14:27:48 <dmwit> > fromList [(3,"hi"),(4,"there")]
14:27:53 <pitecus> SamB, thanks that worked
14:27:56 <lambdabot>   Not in scope: `fromList'
14:28:06 <dmwit> > Data.Map.fromList [(3,"hi"),(4,"there")]
14:28:07 <lambdabot>   Not in scope: `Data.Map.fromList'
14:29:49 <drigz> where's unsafeCoerce in GHC?
14:30:11 <SamB> @hoogle unsafeCoerce
14:30:11 <lambdabot> No matches found
14:30:49 <rashakil> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index-U.html
14:30:51 <lambdabot> http://tinyurl.com/ysgxz3
14:31:17 <drigz> rashakil: thanks!
14:31:35 <scodil> what's the story with hpaste? will it be up soon?
14:34:31 <monochrom> Again?  Why are ISPs so stupid these days?
14:35:05 <lispy> why does it go down?
14:35:28 <monochrom> Sorry, I guess I know the answer. Because too many people think they're ready to operate ISPs.
14:35:31 <drigz> why does this code get the following error?
14:35:43 <drigz> main = print ((unsafeCoerce# (2.0 :: Double# )) :: Word64# )
14:35:50 <drigz> test.hs:3:45: parse error on input `)'
14:36:12 <monochrom> Do you have -fglasgow-exts or the like?
14:36:12 <drigz> i feel so stupid right now...
14:36:17 <mauke> > length "main = print ((unsafeCoerce# (2.0 :: Double# "
14:36:19 <lambdabot>  45
14:37:07 <drigz> monochrom: ok, that got me closer... now i get 'Couldn't match kind '*' against '#''
14:37:29 <dolio> drigz: That's going to be Double# not being a Num instance, I think.
14:37:46 <dolio> Or, Rational, or whatever 2.0 is.
14:37:49 <drigz> dolio: ok. i think i need box and unbox functions...
14:38:02 <Heffalump> you box and unbox by pattern-matching/constructing with the appropriate constructor
14:38:08 <Heffalump> D# and W64#, IIRC
14:38:20 <Heffalump> I have some code somewhere that does what you are trying to do, I'll just find it.
14:39:56 <SamB> so, show of hands: who has ever pattern matched on (-0)?
14:40:14 <mauke> what the
14:40:15 <Jaggederest> ... ow my brain
14:40:33 <monochrom> You people make me sleepy. :)
14:40:33 <norpan> negate (-0) = 0
14:40:42 <norpan> i have now
14:40:51 <SamB> actually my negate looks like this
14:40:58 <SamB>     negate (P1 x) = P1 (x `xor` 0o777777)
14:41:03 <monochrom> > let negate (-0) = 0 in negate 0
14:41:05 <lambdabot>  0
14:41:25 <Jaggederest> it's not an identity already? ooh my head
14:41:33 <monochrom> > let negate (-0) = 0 in negate 0 :: Double
14:41:34 <lambdabot>  0.0
14:41:41 <sjanssen> > let negate (-0.0) = 0.0 in negate 0.0
14:41:42 <lambdabot>  0.0
14:41:51 <monochrom> I suppose I see what's going on.
14:41:53 <Jaggederest> how do you even store that?
14:42:02 <Heffalump> do W64# x# <- readItem :: Read m => m Word64
14:42:10 <Heffalump>    return (D# (unsafeCoerce# x#))
14:42:20 <Heffalump> does the Word64 -> Double conversion
14:42:34 <Jaggederest> let negate 0 = (-0) in negate 0
14:42:37 <monochrom> > let {f (-0) = 0; g x = -x} in f (g 0) :: Double
14:42:38 <mauke> :k Read
14:42:39 <lambdabot>  0.0
14:42:40 <lambdabot> Class `Read' used as a type
14:42:49 <monochrom> > let {f (-0) = 0; g x = -x} in f (g (-0)) :: Double
14:42:50 <lambdabot>  0.0
14:43:07 <monochrom> Now I don't see what's going on. But ok, it's unimportant.
14:43:12 <SamB> hmm.
14:43:15 <SamB> something's wrong.
14:43:29 <SamB> I get 0o040000 for (-1) * (-1) :: Pdp1Word
14:44:03 <drigz> Heffalump: i get 'not in scope' for D# and W64#
14:45:00 <Heffalump> I think it's GHC.Exts you need
14:45:24 <ddarius> @index D#
14:45:24 <lambdabot> GHC.Exts
14:45:44 <drigz> @index W64#
14:45:44 <lambdabot> bzzt
14:46:03 <dolio> W64# is in GHC.Word
14:46:40 <drigz> @index readItem
14:46:40 <lambdabot> bzzt
14:47:16 <SamB> ah that's better.
14:47:21 <SamB> I was comparing at the wrong level :-(
14:47:24 <Heffalump> readItem is part of my code
14:47:45 <drigz> oh does it actually do something
14:47:46 <Heffalump> if you don't want to be in a monad, rejig the code accordingly
14:47:49 <Heffalump> yes
14:47:59 <Heffalump> it's the pattern-match, unsafeCoerce#, and reconstruct operations you need
14:48:16 <scodil> so I need some help with my context reduction stack overflow problem... where can I paste?
14:48:27 <drigz> Heffalump: i see, sorry i just copy-pasted before without thinking
14:48:32 <mauke> @pasta
14:48:32 <SamB> you know what would be really nasty?
14:48:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:48:44 <SamB> if I had signum (-0) = -0
14:48:54 <scodil> 504
14:49:04 <scodil> er, 503 even
14:49:22 <scodil> i should have said, where _else_ can I paste?
14:49:39 <ddarius> There are plenty of other paste bins.
14:49:48 <mauke> http://rafb.net/paste
14:49:55 <mauke> http://tnx.nl/scribble
14:49:55 <scodil> thanks
14:49:58 <dolio> Is there a hierarchical module with the stuff in Numeric? Or is that name just being kept?
14:49:58 <lambdabot> Title: TNX
14:51:35 <SamB> dolio: it seems as if Numeric somehow stayed where it is
14:52:06 <SamB> perhaps someone mistook it for the root of a heirarchy ;-)
14:52:12 <scodil> http://rafb.net/p/PKOBHm11.html   can someone tell me whats wrong with my Num instance? the error is at the bottom of that paste
14:52:16 <dolio> :)
14:52:32 <sjanssen> Numeric is on okay prefix
14:52:41 <sjanssen> we don't need yet another Data.* module
14:52:59 <SamB> sjanssen: well, it isn't a prefix
14:53:09 <SamB> is it?
14:53:16 <sjanssen> well, not yet
14:53:33 <Jaggederest> Data.Math.Numeric too verbose?
14:53:45 <mauke> irc.hs:4:0: parse error on input `module'
14:54:03 <sjanssen> I'd be happy if the standard module hierarchy stripped one layer
14:54:10 <sjanssen> Data.Map -> Map
14:54:15 <mauke> scodil: compiles here (after moving the module line up)
14:54:18 <sjanssen> Control.Concurrent -> Concurrent
14:54:31 <dolio> Numeric mostly isn't math, actually.
14:54:38 <Excedrin> Data.Math.Numbers.OddsAndEnds.Numeric.Misc
14:54:41 <dolio> It's mostly for showing and reading numbers.
14:54:46 <scodil> mauke: did you try to do anything with it? i don't get the error until i try to evaluate something in ghci
14:55:02 <mauke> holu
14:55:09 <mauke> I see
14:56:17 <haskellnew> http://rafb.net/p/7SEL9u20.html         my small test program does not terminate in GHCI , it just hangs , can someone explain why plz ?
14:56:18 <lambdabot> Title: Nopaste - Program does not terminate in GHCI
14:56:26 <SamB> hmm. how would you implement Enum for a type with two zeros?
14:56:36 <SamB> skip -0?
14:56:44 <dolio> You could stick most of the stuff in, say, Text.Show.Numeric if you wanted to, although that'd leave some leftovers.
14:57:17 <dolio> And Text.Read.Numeric
14:57:33 <dolio> Of course, that creates two new modules out of one.
14:57:52 <SamB> a fairly small module as it is, isn't it?
14:58:20 <dolio> Yeah.
15:00:09 <mauke> scodil: I think the problem is fromInteger = unsafeVector . replicate (dim (undefined::v)) . fromInteger
15:00:44 <scodil> what's wrong with it? I can't tell
15:00:44 <mauke> [v] fromInteger immediately calls [s] fromInteger
15:01:02 <mauke> but s is underspecified; it could be any Num
15:01:25 <mauke> hmm, or maybe that's a problem with the instance in general
15:01:48 <drigz> oh, Heffalump, i got it working by the way. thanks!
15:03:37 <scodil> i wrote another instance not unlike it, and it worked fine
15:04:11 <mauke> it can be reduced to
15:04:20 <mauke> class C a b | a -> b
15:04:20 <mauke> instance (Eq a, Show a, C a b, Num b) => Num a
15:04:54 <haskellnew> "readTChan tsomething " will block until something is there to read rt ?
15:04:56 <mauke> Num b => Num a is something like infinite recursion
15:05:36 <scodil> is that from the fundep?
15:05:47 <mauke> huh?
15:06:00 <scodil> sorry.. i'm trying to figure out what you've said
15:06:10 <mauke> I think of instances as function definitions
15:06:36 <SamB> > isNegativeZero (-0)
15:06:37 <lambdabot>  True
15:06:38 <mauke> the part after the => is the function head, the (...) before it is the function body
15:06:41 <SamB> > isNegativeZero (0)
15:06:43 <lambdabot>  False
15:06:59 <mauke> so this says: to compute Num a, call Eq a, Show a, C a b and Num b
15:07:12 <mauke> and the Num b recurses back into the generic Num a case
15:07:36 <scodil> why?
15:08:12 <mauke> because it doesn't know anything more about a or b
15:09:11 <scodil> lets be concrete, class Vector v s says that v is a vector of the scalar type s, so to provide a Num instance for v, we need to rely on the Num instance for s... why would that then loop back and rely on the Num instance for v?
15:09:49 <mauke> why not?
15:09:53 <mauke> s could be another vector
15:10:01 <scodil> oh
15:10:02 <scodil> i see
15:10:04 <mauke> so the typechecker has to make sure
15:10:25 <scodil> i did this before though... lemme paste it
15:11:13 <scodil> http://rafb.net/p/tjLMJL17.html
15:11:14 <lambdabot> Title: Nopaste - Vector class
15:11:40 <scodil> sorry its kind of verbose... scan for instance Num s => Num (Vec3 s) where
15:11:46 <mauke> that's different
15:12:01 <mauke> there the call to Num first pattern matches against Vec3 s
15:12:10 <mauke> then it calls Num for s
15:12:22 <mauke> but there are no infinitely big types, so this has to stop somewhere
15:12:28 <dmwit> ?index liftM
15:12:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:12:50 <scodil> i see... so do you have any suggestions on how to make it work?
15:13:18 <sorear> hello.
15:13:37 <mauke> no :/
15:14:49 <haskellnew> http://rafb.net/p/7SEL9u20.html        can anyone test , why this program does not terminate in ghci
15:14:50 <lambdabot> Title: Nopaste - Program does not terminate in GHCI
15:16:30 <sorear> @topic-tell #haskell
15:16:31 <lambdabot> ["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","
15:16:31 <lambdabot> The language of ICFP winners 3 years running"]
15:16:44 <sorear> ^^^ we have a private pastebin, for future reference
15:16:55 <scodil> its down
15:17:11 <sorear> not again :/
15:17:20 <monochrom> I hate stupid ISPs.
15:17:22 <Heffalump> what's the actual problem with it?
15:18:04 <davidL> hmm I just got a PM saying "are you good with linguistics? i need to create a tool that can rewrite text, like replacing certain words and phrases in a text with other words and phrases and come up with something completely unique, but still looking like real english and saying the same thing..."
15:18:14 <Heffalump> how about we make subdomains of hpaste.org and run multiple versions in different places?
15:18:36 <Heffalump> (I could provide one place)
15:19:01 <SamB> how hard would it be to make a distributed pastebot?
15:19:16 <Heffalump> actually distributing the pastebot would be a bit icky
15:19:29 <Heffalump> as you'd have to make sure everyone was in communication with everyone else to transfer the pastes
15:19:40 <Heffalump> though it might be a fun project
15:21:38 <DRMacIver> Hmm. Well I've been wondering how hard it would be to implement a Haskell AMQP clinet. :) (And the answer is: Not the foggiest notion. I can't even get an AMQP server working at the moment :) )
15:21:49 <sorear> AMQP?
15:21:56 <DRMacIver> It's a messaging protocol.
15:22:16 <DRMacIver> Advanced Message Queuing Protocol.
15:22:43 <DRMacIver> (And thus a decent backbone for distributing stuff)
15:23:26 <Saizan>  /j #haskell.it
15:25:12 <Heffalump> just the acronym gives my buzzword detector a headache, and then looking at the top google hit sends it into overdrive
15:25:22 <DRMacIver> Heh
15:26:11 <JohnMeacham>  anyone have some vim magic to make it automatically go to the errors as reported by ghc when doing a :make?
15:26:19 <DRMacIver> Heffalump: Yeah. There are lots of banks mentioned as contributers, and you know what banks are like. ;)
15:26:47 <monochrom> Banks are like they cross-sign every message sent and received.
15:27:10 <monochrom> And then never check the signatures. :)
15:27:23 <DRMacIver> Heffalump: As these things go, it doesn't strike me as too bad. Messaging systems are useful and deserve to be a) Wider spread and b) Standardised. This seems a good attempt at achieving both.
15:28:43 <monochrom> My question about its name is: if one day we come up with a protocol more advanced than this Advanced Protocol, what do we call it?  Or do we anticipate civilization to never see that day?
15:29:05 <DRMacIver> We call it Advanceder MQP obviously.
15:29:20 * Heffalump is not sure if one size fits all is the way to go, though.
15:29:56 <ddarius> Super Alpha Mega Duo AMQP
15:29:57 <Excedrin> HAMQP the 'H' stands for 'Hyper'
15:30:50 <monochrom> In the TV spectrum there was first VHF, then UHF, then there was nothing beyond because we went digital.
15:31:15 <DRMacIver> Heffalump: I think (though I'm currently far from knowledgeable about it) that this isn't so much a 'one size fits all' as a low level protocol which makes certain guarantees for building higher level abstractions on top of.
15:31:57 <Excedrin> actually, past UHF is SHF and EHF
15:32:50 <monochrom> E = extraordinary?
15:33:04 <Excedrin> extremely
15:33:17 <DRMacIver> Heffalump: Hm. In fact, I see CS are on this bandwagon already. :)
15:33:36 <ddarius> Everybody are so friendly! Yay!
15:37:06 <SamB> Heffalump: I was kinda thinking of something with failover
15:37:23 <SamB> i.e. the whole point would be that not everyone would be in communication all the time
15:39:20 <Heffalump> SamB: but then you lose pastes when one fails
15:39:32 <Heffalump> and you have the difficulty of deciding when to wrest control
15:39:41 <SamB> well, not that kind of failover
15:39:53 <Heffalump> if you go for explicit subdomains then people on channel just decide by using a different one
15:40:03 <SamB> anyway, couldn't pastes be replicated retroactively
15:40:10 <SamB> ?
15:40:11 <Heffalump> how?
15:40:31 <SamB> well... how does usenet work?
15:40:39 <SamB> it's pretty much the same thing
15:40:49 <ddarius> What's the line count on xmonad nowadays?
15:41:11 <Heffalump> a usenet style thing was what I was thinking for the distribution option
15:41:17 <Heffalump> but that's hardly "retroactive"
15:41:23 <SamB> well.
15:41:33 <SamB> I mean, if one server goes down, it catches up later.
15:42:36 <sorear> ddarius: ~600
15:42:45 <ddarius> Cool.
15:42:47 <sorear> ddarius: with all syntactic whitespace stripped
15:43:20 <Heffalump> oh, right, so you do proactively push the pastes around when they are made?
15:43:24 <Heffalump> That was what I was thinking   too.
15:43:28 <Inamabilis> can anyone help me with this?
15:43:29 <Inamabilis> http://pastebin.ca/526717
15:43:38 <SamB> Heffalump: well I don't know how usenet actually works...
15:43:41 <Inamabilis> its meant to be higher order insertion sort
15:44:03 <Inamabilis> but it's erroring - inferred type is not general enough
15:44:19 <Heffalump> you are missing an 'f' in the recursive call to inssortBy
15:44:40 <Heffalump> SamB: unique message ids, redundant links
15:44:51 <SamB> well, yes
15:44:53 <SamB> I know that much
15:44:53 <Heffalump> I forget whether it's push or pull but either way everything propagates down every path until it's gone everywhere
15:45:00 <SamB> I bet its push and pull
15:45:16 <SamB> varying from link to link, probably...
15:45:30 <Heffalump> sure
15:46:02 <Inamabilis> im such an idiot - thanks - doesnt fix the error though :S
15:47:01 <Inamabilis> *** Expected type : (a -> b) -> Int -> [Int] -> [Int]
15:47:01 <Inamabilis> *** Inferred type : (Int -> a) -> Int -> [Int] -> [Int]
15:47:13 <SamB> so how many lines is usenet in Haskell/
15:47:23 <SamB> s|/|?|
15:47:27 <ddarius> SamB: I say under 50 for something basic.
15:47:41 <SamB> the basic thing, I mean
15:47:49 <SamB> not all that hairy networking...
15:48:01 <SamB> certainly not the RFC protocols
15:48:22 <Excedrin> how do things like R and J compare to Haskell?
15:48:38 <SamB> apparantly R has a CLOSy OO system
15:48:39 <Heffalump> Inamabilis: oh, your type signature is too general about the type of f, or too specific about the type of the list
15:48:48 <SamB> and J is that APL variant?
15:49:05 <Heffalump> and it's missing an Ord constraint on the result type of f
15:49:14 <emu> R is a scheme-ish language i believe
15:49:32 <emu> schemy?
15:49:39 <SamB> I don't actually know much about R, syntaxfree knows more...
15:49:47 <bos> R looks kind of like python, to read.
15:49:59 <bos> never looked at it in any depth, though.
15:51:18 <fnord123> Hi all, gtk2hs question: are there any examples of a curried signal handler? when I connect the signal, my GtkContainer argument wont compile when I then pass it to castToContainer
15:52:16 <fnord123> fwiw, hpaste is down
15:54:41 * SamB thinks GHC could use better 64-bit on i686
15:55:07 <newsham_> ?seen glguy
15:55:07 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
15:56:25 <SamB> okay, so I want to write an assembler that consumes text and produces a list of output words...
15:56:30 <SamB> it needs a symbol table...
15:56:37 <SamB> what monad stack do I want...
15:57:22 <SamB> (FYI I believe the original used paper tape for input and output)
15:58:16 <mauke> I'd probably use a Reader and a Writer to resolve symbols
15:58:21 <fnord123> nm. if i neglect to use castToContainer, it all works
15:59:54 <sorear> SamB: better 64bit?
15:59:55 <ddarius> Down with Writer!
16:00:30 <mauke> no, Writer rocks
16:04:03 <SamB> sorear: it doesn't have a proper Word64#
16:04:08 <SamB> on 32-bit systems
16:04:10 <SamB> at all
16:04:16 <SamB> it uses GMP, IIRC
16:05:22 <sorear> SamB: unsafeCoerce# :: Double# -> Word64# doesn't crash on my 32 bit system - it would if Word64# was GMP
16:13:08 <desp> is it possible to import vararg C functions using the FFI?
16:13:43 <bos> no.
16:14:14 <desp> ok.
16:15:03 <edwardk> I just tripped over http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf ... Neat!
16:19:26 <chessguy> edwardk, that looks nice indeed
16:19:43 <chessguy> @tell Procyon112 http://www.cs.rutgers.edu/~ccshan/prepose/p1214-kiselyov.pdf looks nice for dealing with our parameters problem
16:19:43 <lambdabot> Consider it noted.
16:19:47 <chessguy> @seen Procyon112
16:19:48 <lambdabot> Procyon112 is in #haskell. I don't know when Procyon112 last spoke.
16:20:00 <chessguy> @seen Procyon
16:20:00 <lambdabot> Procyon has changed nick to procyon112.
16:20:00 <edwardk> chessguy: thats exactly what i needed it for =)
16:20:00 <lambdabot> procyon112 is in #haskell. I don't know when procyon112 last spoke.
16:20:24 <Inamabilis> @seen Inamabilis
16:20:24 <lambdabot> You are in #haskell. I last heard you speak just now.
16:20:26 <chessguy> edwardk, for Procyon112 and i's parameter problem? :)
16:20:43 <edwardk> ya, i just didn't know you guys needed it for your problem too, or I would have told you ;)
16:20:49 <chessguy> lol
16:20:59 <chessguy> i had no idea it was such a well-known problem
16:21:12 <edwardk> =)
16:21:20 <jfoutz> so, what should i go read to get a grip on arrows? i have a ... medium level of understanding of monads, i feel pretty comfortable with maybe and list, but am a little shakey on transformers.
16:21:43 <edwardk> jfoutz: the haskel.org arrows page links right to the first paper on them, its a good start
16:22:05 <jfoutz> ok. thanks.
16:23:35 <chessguy> edwardk, oh, we don't need multiple sets of configurations though, i think
16:26:45 <chessguy> @hoogle mod
16:26:45 <lambdabot> Prelude.mod :: Integral a => a -> a -> a
16:26:46 <lambdabot> Prelude.module :: keyword
16:26:46 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
16:28:03 <Procyon112> chessguy: yo
16:28:03 <lambdabot> Procyon112: You have 1 new message. '/msg lambdabot @messages' to read it.
16:28:13 <chessguy> yo!
16:29:15 <Procyon112> That paper deals with setting up configurations?
16:30:31 <chessguy> indeed
16:30:32 <Procyon112> chessguy: Is there anything Oleg can't do?
16:30:41 <chessguy> hmm, walk on water?
16:30:54 <mauke> has anyone written a typechecker in the typesystem yet?
16:30:57 <Pseudonym> He can't implement actual code, only type-level metacode.
16:31:09 <jfoutz> hahaha
16:31:18 <Procyon112> I think he resolved water walking as a special case of 6th order intuitional logic...
16:31:36 <Pseudonym> But you need GADTs and HLists.
16:31:38 <chessguy> Pseudonym, have you seen his generalized zipper? looks like real code to me
16:32:09 <sorear> mauke: Yes, I did it a while back
16:32:12 <Pseudonym> chessguy: You may think that from a superficial inspection, but in fact, it's mostly algebraic data type hackery.
16:32:18 <Pseudonym> :-)
16:32:48 <chessguy> Pseudonym, envy will get you nowhere
16:32:49 <Procyon112> Why use the language when the type system is turing complete?
16:32:54 * sorear keeps meaning to finish off his embeedding of the Calculus of Inductive Constructions in haskell.  We don't need no steenking external proof assistants!
16:33:45 <sorear> actually if you squint right, the assistant part can be expressed in TH
16:34:07 <dolio> He can also write code that's at least 70% delimited continuations, which explains the zipper stuff. :)
16:35:31 <chessguy> Procyon112, i haven't gotten through the whole paper yet, but i suspect it'll solve our problem nicely
16:37:27 <SamB> sorear: oh, well, it still doesn't seem to have primops for dealing with Word64#s here
16:38:02 <sorear> SamB: It's not GMP, it's plain old rts __ccalls
16:38:20 <SamB> so slow!
16:39:00 <sorear> no, faster
16:39:15 <sorear> GMP is optimized for numbers quite a bit bigger than 2 limbs
16:39:24 <sorear> that's why we have the S#/J# split
16:39:24 <dmhouse> Procyon112: Haskell's type system isn't turing-complete, is it?
16:39:26 <SamB> I meant compared to primops
16:39:30 <sorear> dmhouse: it sure is
16:39:39 <dmhouse> I mean, for one thing, the compiler doesn't get into a loop.
16:39:47 <chessguy> Procyon112, hmm. it may actually be overkill though
16:39:56 <sorear> SamB: Almost all primops are function calls
16:41:01 <dolio> dmhouse: It's Turing complete given some extensions.
16:41:11 <sorear> SamB: some of the really simple ones are open-coded, but primops are not inherantly cheap.  look at say newArray#
16:41:39 <dolio> dmhouse: And just because it's Turing complete doesn't mean it won't terminate, just that you could write something that causes it to not terminate.
16:41:39 <sorear> dmhouse: With a few extensions, GHC *does* get into loops!
16:42:20 <SamB> sorear: well, it's hard to optimize FFI calls
16:42:27 <dmhouse> Which extensions?
16:42:32 <sorear> SamB: "FFI calls" /= "__ccalls"
16:42:39 <dmhouse> dolio: yes, I meant "the compiler never goes into a loop".
16:42:44 <SamB> sorear: even worse!
16:42:54 <sorear> SamB: __ccall is a very lightweight mechanism
16:42:55 <dolio> dmhouse: -fallow-undecidable-instances, multiparameter type classes and fundeps, I think.
16:43:09 <sorear> dolio: You can do it with just the first.
16:43:16 <sorear> (crash the compiler that is)
16:43:18 <dolio> Ah. Noted.
16:43:25 <SamB> sorear: I meant it doesn't say "oh gee this would be simpler if I used a shift instead"
16:43:30 <mauke> :
16:43:34 <SamB> or anything like that
16:43:41 <sorear> SamB: Sure it does.
16:43:53 <SamB> sorear: how?
16:43:55 <sorear> SamB: {-# RULES #-}
16:44:25 <SamB> how do you put a __ccall on the lhs of a rule?
16:44:50 <SamB> do they have prelRules for it?
16:45:05 <sorear> i mean like mulInt64#
16:45:22 <sorear> note that I have no evidence they actually DO use rules, just that they could
16:50:32 <Procyon112> chessguy: http://haskell.org/haskellwiki/New_monads/MonadRandomSplittable
16:50:33 <lambdabot> Title: New monads/MonadRandomSplittable - HaskellWiki
16:53:18 <siti> is there a haskell type that corresponds to size_t  e.g. an int at the native word size?
16:53:38 <SamB> siti: usually we use Int...
16:53:44 <mauke> CSize?
16:54:00 <SamB> mauke: I think that isn't the correspondence he meant
16:54:26 <siti> nah csize is good :)
16:54:30 <siti> thanks
16:54:36 <SamB> in that case, the type corresponding to int would be CInt
16:54:41 <jcreigh> siti: Well, there's CInt, which is used in the FFI system and is supposed to corresspong to C's int type.
16:54:50 <siti> yep
16:55:31 <SamB> siti: if you wanted to know a type for use in FFI, you might have said so ;-)
16:56:14 <siti> yep...
16:56:31 <siti> writing bindings is so much fun ;)
16:56:34 <halassocracy> the final fantasy 1 system
16:56:36 <sorear> siti: Int /= CInt on just enough systems to bite you exactly when you ungrok your code
16:56:47 <SamB> sorear: Int /= CInt ever
16:57:02 <SamB> 'tis the beauty of newtype!
16:57:08 <siti> yeah isn't int +/-2^29
16:57:12 <sorear> siti: for a long time the X11 bindings assumed Int = CInt, and didn't work on AMD64
16:57:31 <kfish> sorear, ungrok?
16:57:34 <sorear> SamB: the FFI negates newtypes
16:57:37 <siti> yeah I use amd64 so I am extra careful because I hate it when software does not work on it.
16:58:06 <SamB> sorear: now, Int may semi-occasionally be the same size as CInt...
16:58:11 <sorear> kfish: you know how when you've found no bugs in your code for six months, then someone comes complaining?
16:58:20 <jfoutz> :t [1]
16:58:22 <lambdabot> forall t. (Num t) => [t]
16:58:26 <kfish> sorear, heh
16:58:30 <sorear> SamB: Int is the same type as CInt on x86, for the ffi
16:58:40 <SamB> (What I meant is that at least your program won't suddenly cease to typecheck when you try it on a system where CInt and Int aren't implemented the same)
16:58:48 <sorear> ok.
16:59:02 <SamB> also, you are assuming the use of mainline GHC
16:59:19 <SamB> some systems use tagged Ints
16:59:26 <jfoutz> :t Just 1
16:59:28 <lambdabot> forall t. (Num t) => Maybe t
16:59:59 <jfoutz> is there a list data declaration? like List 1
17:00:15 <Excedrin> [1] ?
17:00:19 <jfoutz> ...
17:00:31 <jfoutz> foral t. (Num t) => List t
17:00:36 <SamB> @src []
17:00:36 <lambdabot> data [] a = [] | a : [a]
17:01:02 <jfoutz> i guess, the type List, is spelled []
17:02:02 <jfoutz> it's strange, because the type, and the constructor have the same name. Maybe vs Just, [] vs []
17:02:33 <SamB> jfoutz: not all that uncommon for newtypes...
17:02:58 <jfoutz> yeah, i guess data F = F is ok.
17:03:08 <SamB> the really funky thing is that the type constructor is outfix, and you can put comments inside the data constructor
17:03:19 * jfoutz nods
17:03:44 <SamB> of course, the data constructor is just a trivial instance of list syntax, so maybe that isn't so funky after all ;-)
17:04:03 <davidL> is GHG-6.6.1 broken on freeBSD?
17:04:20 <SamB> davidL: why do you ask?
17:04:33 <davidL> I got an error building it just now
17:04:53 <davidL> buidling Cabal actually
17:04:58 <jfoutz> it's funky in that it has special syntax. most of my functional reasoning comes from scheme.
17:05:11 <chessguy> hey any suggestions for a tutorial, or example library to look at for writing combinators for DSLs?
17:05:18 <SamB> jfoutz: scheme lists have special syntax too
17:05:27 <SamB> but for some reason it gets used for programs also
17:05:28 <jfoutz> hehehe.
17:05:37 <davidL> no hpaste :(
17:06:09 <SamB> chessguy: what sort of DSL do you desire?
17:06:28 <SamB> SOE seems to have combinator libraries as a theme...
17:06:33 <chessguy> SamB, i'm writing a DSL for genetic programming
17:06:45 <SamB> chessguy: what do you do in genetic programming?
17:06:52 <chessguy> i'm not entirely sure what the combinators should be
17:07:01 <SamB> well, I don't think there can be a tutorial for it
17:07:04 <chessguy> SamB, evolve algorithms
17:07:06 <SamB> its mostly a matter of thinking
17:07:07 <SamB> ;-)
17:07:33 <chessguy> bah, thinking's for thinkers
17:07:40 <SamB> you should know what abstractions you have to choose from, but other than that...
17:07:57 <jfoutz> chessguy, an old oo trick is to split up your problem into nouns and verbs, verbs *might* be combinators
17:08:04 <SamB> well, I mean, the usual abstractions, like Monads and Arrows
17:08:30 <SamB> jfoutz: and nouns might be type constructors
17:08:47 * jfoutz nods
17:09:12 <SamB> but then again maybe not.
17:09:24 <SamB> chessguy: why do you want to write a combinator library?
17:09:33 <SamB> how do you *want* to combinate things?
17:09:52 <jfoutz> the beauty of a DSL is using the domain language. so if you can say something you want to do in terms of, mutation crossover genes, gentics words, you'll have some hope of identifying the language
17:10:52 <davidL> my ghc-6.6.1 build error --> http://paste.lisp.org/display/42093
17:10:54 <chessguy> samB, i'm not sure yet
17:11:09 <chessguy> this looks promising though: http://www.cs.chalmers.se/~rjmh/Combinators/
17:11:11 <lambdabot> Title: Designing and Using Combinators:
17:11:12 <chessguy> john Hughes
17:11:37 <ddarius> chessguy: Start writing the code you need in the language you would want if it existed.
17:11:55 <chessguy> ddarius, good idea
17:12:03 <SamB> chessguy: well, you'll probably want a way to build crossover & mutation strategies for your programs
17:12:20 <chessguy> SamB, indeed
17:12:34 <SamB> so, um, what classes of programs are you building?
17:12:48 <jfoutz> chessguy, heh, i'm reading the arrows paper right now. There's a simple interpreter implemented in arrows and again in monads. not exactly genetic combinators, but an example of a little dsl using combinators.
17:12:48 <SamB> s/build/evolv/
17:12:58 <jfoutz> http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
17:13:20 <chessguy> SamB, the idea is to write a library that will allow me to evolve any kind of program i want
17:13:38 <SamB> chessguy: cool course you've found
17:13:51 <SamB> nice of him to put all of that on the net
17:14:06 <chessguy> definitely
17:14:24 <SamB> chessguy: does this include, er, what's that crazy language from the ICFP 2006 contest?
17:14:39 <chessguy> the Universal Machine?
17:14:42 <SamB> no!
17:14:52 <SamB> the one where every opcode does two things...
17:15:00 <chessguy> oh, i didn't see that
17:15:30 <SamB> yango: U+262F
17:15:43 <SamB> that's the username: password pair
17:15:47 <Procyon112> SamB: potentially, yes.  The idea is that the list of primitive opcodes are configurable, as is the typechecking.
17:16:06 <SamB> Procyon112: but it seems like that particular system is very challanging...
17:16:28 <Procyon112> SamB: are the "does 2 things" random, or deterministic?
17:16:29 <SamB> the PC uses modular arithmatic!
17:16:35 <SamB> Procyon112: deterministic
17:17:21 <Procyon112> SamB: Then it should be able to handle such a beast.  The Evaluator would just keep state and execute the opcodes in the defined order.
17:17:21 <SamB> Procyon112: do you have a copy of the codex, along with a key?
17:17:45 <Procyon112> SamB: no
17:18:22 <SamB> how does a keygen sound?
17:18:34 <SamB> I think there is one on the Cult of the Bound Variable site
17:18:47 <SamB> http://www.boundvariable.org/register.shtml
17:18:51 <lambdabot> Title: ICFP Programming Contest, 2006 : Registration
17:18:52 <jfoutz> chessguy, it seems like you need a couple of things. 1. a way to make up new programs, 2. a way to modify programs, 3. a way to test the fitness of a given program. I'd bet those are good combinators to start with.
17:19:10 <SamB> the task is at http://www.boundvariable.org/register.shtml
17:19:11 <lambdabot> Title: ICFP Programming Contest, 2006 : Registration
17:19:14 <SamB> arg
17:19:17 <chessguy> jfoutz, yes, among others
17:19:18 <SamB> the task is at http://www.boundvariable.org/task.shtml
17:19:19 <lambdabot> Title: ICFP Programming Contest, 2006 : Contest Materials and Task
17:19:43 <SamB> Don't worry -- they've re-opened the "registration"
17:19:49 <jfoutz> chessguy, so... what's stopping you at this point?
17:20:14 <chessguy> hmm. i think it's not knowing what i want my final DSL to look like
17:20:20 <SamB> Procyon112: then you can use that username: password pair to see what I'm talking about
17:20:24 <Procyon112> ok
17:20:27 <SamB> and maybe your head will start to hurt ;-)
17:20:40 <chessguy> which means i probably need to write some programs in the DSL first :)
17:20:44 <SamB> yango: U+262F
17:21:17 <jfoutz> chessguy, one of the beautys of combinator style, you can add on more combinators at any time... yeah, i was getting to that :)
17:21:50 <chessguy> @quote SamB.oh
17:21:50 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:21:57 <chessguy> @quote SamB.why
17:21:57 <lambdabot> No quotes match. It can only be attributed to human error.
17:22:06 <chessguy> @quote SamB
17:22:06 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
17:22:10 <chessguy> @quote SamB
17:22:11 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
17:22:13 <chessguy> @quote SamB
17:22:13 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
17:22:16 <chessguy> grr
17:22:28 <SamB> the rng is broken?
17:22:35 <SamB> @quote dons
17:22:39 <lambdabot> dons says: Haskell: The language that never sells out!
17:22:40 <SamB> @quote dons
17:22:45 <lambdabot> dons says: C++: creating blub programmers since 1985
17:22:51 <SamB> or someone deleted all my quotes
17:22:58 <SamB> @quote SamB
17:23:01 <lambdabot> SamB says: I was just saying that encasing poeple in concrete is not the best solution to that problem
17:23:09 <SamB> or ... not
17:23:28 <chessguy> found it in /msgs
17:23:30 <chessguy> SamB says: * SamB wonders why oh
17:23:38 <chessguy> that's the one i was looking for
17:25:39 <chessguy> Procyon112, my Koza GP bible was packed up. good thing it was on top :)
17:25:50 <Procyon112> hehe
17:27:48 <Procyon112> So, anyone, let's say I have a list of primitive combinators in a variable-free language who's types are all known explicitly (no inference required)...
17:28:20 <Procyon112> Let constructs are not allowed (no variables).  Lambda terms are not allowed (same)
17:29:36 <Procyon112> Ignore subtyping, typeclasses, etc for the moment.  Is there any functional difference between unification based Hindley-Milner typing and System F?
17:30:59 <Procyon112> :/  Where's my majestic stereo?
17:32:27 <ddarius> Yes
17:32:39 <jcreigh> 8Khz mono is going to have to do. :)
17:33:12 <user317> hehe, from the GADT wiki: So now that we know what we want, safeHead, how do we actually go about getting it?
17:33:43 * ddarius works on that.
17:34:08 <Procyon112> ddarius++
17:37:50 <Procyon112> ddarius: in other terms, I have SK-calculus (with a couple base types, no subtyping).  I want to type it.  Does System F buy me anything?
17:38:14 <ddarius> Yes.
17:39:13 <Procyon112> OK.  Now, are non-terminating terms typeable in System F without a fixed point combinator as a primitive.
17:39:16 <Procyon112> ?
17:39:20 <ddarius> No.
17:39:43 <Procyon112> sweet... but damn your terse :)
17:39:51 <dons> moin
17:40:11 <chessguy> hiya dons
17:40:32 <chessguy> is the book done yet?
17:40:38 <Procyon112> heh
17:40:47 <ddarius> And are we there yet?
17:41:34 <chessguy> lol, nice timing
17:43:24 <lispy> how about now?
17:43:40 <dibblego> ddarius hit me!
17:44:16 <chessguy> Procyon112, so what did you decide, does split return 2 new generators or the old one and a new one?
17:48:49 <chessguy> ...
17:49:47 <Procyon112> chessguy: it returns 2 new generators
17:49:59 <chessguy> interesting
17:50:13 <SamB> ddarius: have we even decided where it is that we want to go?
17:50:22 <chessguy> hmm, you still need sequencing though don't you?
17:50:23 <Procyon112> And it's spec'ed to do that.
17:50:34 <SamB> and would it be the same place every day?
17:51:44 <chessguy> i mean suppose we have generate :: Gen -> Genes -> Genes -> Program
17:51:49 <Procyon112> chessguy: no.. every time you need to pass a generator down to a potentially parallelizeable function, you can split off a generator tuple, use fst for the next split, and pass snd to the function.
17:52:13 <chessguy> (one set of Genes is the functions, the other is the terminals)
17:52:22 <chessguy> how would you use that to generate, say, 5 programs
17:54:43 <Procyon112> you would need to sequence the splits, but not the calls to generate.
17:56:03 <chessguy> ...
17:56:52 <Choko> Does anybody of you have an polynomial mod (n,P) algoritm where n is an integer for the coefficients ?
17:57:37 <chessguy> i'm not seeing what that would look like, sorry
17:58:41 <Choko> i'm neither, then i need to think about it :(
17:58:56 <chessguy> Choko, i was talking to Procyon112
17:59:05 <Procyon112> chessguy: generateN g n funcs terms = let (h,i)=split g in (generate h funcs terms) : generateN i (n-1) funcs terms -- generateN _ 0 _ _ = []
17:59:05 <Choko> ah
17:59:43 <chessguy> oh'
17:59:54 <chessguy> ok, that's easy :)
17:59:59 <sorear> ...
18:00:27 <chessguy> but i don't see how you get parallelization then
18:01:32 <sorear> chessguy: Parallelization!?
18:01:55 <sorear> chessguy: Are you one of those people who doesn't know the truth about the purity->parallel tooth fairy?
18:02:03 <chessguy> uh
18:02:28 <chessguy> you're kind of walking in in the middle of a several-day discussion :)
18:02:36 <sorear> ah good
18:02:53 <Procyon112> generate2 g f t = let (h,i)=split g in par (gen h f t) (gen i f t) -- where par returns a tuple... purely speculative
18:03:49 <Procyon112> chessguy: The point being, by using split, there is now no dependancy between seperate calls to generate.
18:04:22 <Procyon112> chessguy: so conceivably generate can be called in parallel... not that we have to on first iteration :)
18:04:30 <chessguy> fair enough
18:04:46 <dino-> I'm having a problem doing something. And it may be that it's a dumb way to even try to approach what I want to do..
18:05:07 <MarcWebe1> Do you know wether I can make cpp create some text containing a line break? I want to create a data and an instance definition at once
18:05:23 <dino-> What I think I want is two modules whose exposed functions are named the same..
18:05:39 <dino-> And the caller can be possibly calling functions in one or the other of them without any code change.
18:06:50 <MarcWebe1> dino: This is done by quolified import. Example : Module A defines f and module B defines f
18:07:41 <MarcWebe1> Then you can use A.f  or B.f after importing both. You can also define aliases: import A as SomeShortStr and use SomeShortStr.f
18:07:46 <dino-> MarcWebe1: I started going down the road of an empty-constructor data type instanced into a type class with the functions declared... It hasn't been working.
18:08:35 <MarcWebe1> dino-: You can't control importing instances. They are imported anytime when importing a module.
18:09:42 <MarcWebe1> Then I have to learn how to use template haskell..
18:10:47 <dino-> So, what you're saying is that *is* the way this type of thing is done. I may have a function say, that evaluates to either A.f or B.f at eval time, to programmatically direct to one or the other.
18:10:55 <ddarius> MarcWebe1: ;
18:12:05 <dino-> It's with a queasy feeling that I can't force my mind away from some kind of OO interface type defining methods that two classes implement. :/
18:12:07 <dino-> I'm contaminated by objects.
18:14:56 <dibblego> dino-, it's called 'ad hoc polymorphism'
18:15:31 <dons> so, who's a package manager in here? :-)
18:15:38 <dons> anyone want to package up xmonad for the distros?
18:15:49 * sorear manages several cabal packages
18:16:06 <sorear> dons: is xmonad already on hackage?
18:16:19 <dons> it is
18:16:32 <dons> there's experimental .debs for it, iirc , but not in any system
18:16:38 <dons> i think its in netbsd too
18:17:07 <Procyon112> It's in gentoo
18:17:25 <Procyon112> er.. rather it's in the gentoo overlay ;)
18:17:33 <dons> stable release?
18:17:33 <dino-> dibblego: But is that the right way to approach this, is what I'm unsure of.
18:17:35 <dons> or darcs version?
18:17:38 <sjanssen> dons: darcs
18:17:41 * davidL is making the Makefile for x11-extras for FreeBSD
18:17:48 <dons> great!
18:17:54 <dibblego> dino-, you can't emulate interfaces in Haskell anyway - the closest you'll get is type-classes
18:18:15 <dibblego> dino-, why do you want to?
18:18:16 * sorear has a fully automatic hackage -> apt-get mirror on his TODO list!
18:18:34 <dibblego> dino-, ask yourself why you even have two implementations of an interface anyway
18:19:01 <dino-> dibblego: Two modules who have a function with the same name. Like handlers for something that we won't know which we want until runtime..
18:19:02 <dibblego> dino-, isn't each implementation just missing a function argument e.g. the IO monad?
18:19:35 <dibblego> dino-, how is it discovered?
18:20:32 <dino-> dibblego: As in how will the caller-side know which it needs? For the moment, some data passed into the program.
18:20:48 <dibblego> dino-, how does the implementation discover what it needs to complete its computation?
18:22:04 <dibblego> dino-, typically, it accesses the file system or network
18:23:48 <jfredett> q
18:30:57 <dino-> MarcWebe1, dibblego: thanks. I don't think I'm describing (or even understanding) what I really need here.
18:31:59 <dibblego> dino-, I find it helps to identify why people *really* use those silly interface things
18:32:38 <dibblego> dino-, you'll notice no interfaces here: http://code.google.com/p/pure-functional-java/ because they make no sense (there are no missing function arguments)
18:32:38 <lambdabot> Title: pure-functional-java - Google Code
18:39:05 <ddarius> dibblego: ?
18:39:28 <dibblego> yes?
18:40:15 <ddarius> http://pure-functional-java.googlecode.com/svn/trunk/src/java/main/com/workingmouse/pfj/F.java
18:40:18 <lambdabot> http://tinyurl.com/2d9y9x
18:40:25 <dibblego> except that one :)
18:42:48 <dino-> I got out of Java before all the generics and annotation business really took hold, boy does it look noisy these days. :o
18:43:36 <ddarius> I was never really "in" Java, but yes, the last I really dealt with it was pre-generics.  But now I deal with C#.  Luckily, it still seems a lot better than modern Java.
18:45:24 <dibblego> hpaste.org is gone?
18:51:08 <Choko> yes
18:51:24 <dibblego> can you make it come back?
18:51:53 <Choko> no :(
18:52:00 <ddarius> dibblego: Just use a different paste bin for now.
18:52:09 <Choko> i don't even know who has it :(
18:52:12 <dibblego> ddarius, I was looking for some code I put there yesterday
18:52:21 <ddarius> Ah
18:52:24 <Choko> it's just an observation from my side :P
18:52:27 <dibblego> I've rewritten it anyway
18:59:35 <dmwit> dibblego: Even if it were made to come back, that code would be lost forever.
18:59:49 <dmwit> hpaste keeps all its state in memory!
19:00:02 <dibblego> oh
19:00:44 <sorear> dmwit: Nah, it's flushed to disk.
19:00:58 <sorear> dmwit: Of course, glguy keeps incompatibly changing the format :P
19:01:08 <dmwit> heh
19:03:13 <davidL> Does `ghc-pkg unregister' take care of removing package.conf.old ?
19:03:46 <Weremanatee> join #haskell-blah
19:03:49 <Weremanatee> bah!
19:10:20 <mauke> hey, what do you think about this exercise: http://rafb.net/p/GMyYQ457.html ?
19:10:21 <lambdabot> Title: Nopaste - No description
19:10:43 <mauke> I blame dibblego
19:11:06 <dibblego> what I do?
19:11:18 <dibblego> oh heh :)
19:13:41 <dibblego> mauke, you don't like headTail :: s a -> Maybe (a, s a)
19:13:42 <dibblego> ?
19:13:52 <mauke> no
19:14:07 <dolio> Catamorphisms are sexier.
19:14:09 <mauke> deCons is awesomer
19:14:23 <mauke> it's like pattern matching in a box
19:14:48 <mauke> :t maybe
19:14:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:14:59 <mauke> ^ that's deMaybe
19:15:16 <dibblego> yeah, I'm just trying to decide why one is better
19:15:47 <mauke> deCons is mechanically derivable
19:16:46 <mauke> it's obvious how it works :-)
19:16:54 <dibblego> I understand how it works
19:17:28 <mauke> headTail needs thinking
19:17:37 <dibblego> does it?
19:17:41 <dino-> dibblego: Thanks again from earlier. You guys helped me to stop trying to do what I was trying to do. :)
19:17:47 <dibblego> dino-, no problem
19:17:50 <mauke> and it doesn't solve the problem, it just shifts it over to Maybe and (,)
19:18:35 <mauke> the problem is that you can't pattern match on Sequences, so you need some kind of destructuring function
19:18:58 <dibblego> you can in my language (which started this)
19:20:02 <dibblego> shouldn't it be deCons :: a -> (a -> s a -> a) -> s a -> b
19:20:15 <dibblego> and your description says f h t - I think you mean f t h
19:20:28 <dibblego> er, nothing
19:20:40 <dibblego> I am too used to my language :)
19:20:45 <dolio> Where would the 'b' come from?
19:20:52 <dibblego> no, my mistake
19:22:45 <dolio> What's your language? Scala?
19:22:50 <dibblego> yes
19:22:59 <dibblego> I was trying to do reverse as mauke describes it
19:23:17 <dibblego> I write little prototypes in Haskell all the time
19:24:04 <dolio> :) Shouldn't you be prototyping in a language made for it, like Python?! :)
19:24:43 <dibblego> much of my Scala looks like very verbose Haskell
19:25:22 <siti> haskell is great for prototyping :p
19:25:34 <dibblego> you could probably even write a Haskell to Scala compiler, so long as you used only a subset of the language
19:27:12 <ddarius> dibblego: And vice versa with the same constraints...
19:27:41 <Excedrin> dibblego: have you looked at CAL? I'm curious what Scala and Haskell user(s) think of it
19:27:53 <dibblego> Excedrin, only briefly - I hope to spend some more time with it soon
19:28:19 <dibblego> Excedrin, it is extremely Haskell-like; but without do-notation
19:29:37 <Excedrin> it's not pure, but they have some very neat stuff; it's possible to see an expression with unevaluated thunks in the debugger for example
19:29:47 <dibblego> it's as pure as unsafe*
19:30:03 <dibblego> the impurity comes from the ability to call Java stuff
19:30:34 <dibblego> if you invoked java.io.File, you'd be encouraged to wrap it in the IO monad for example
19:30:58 <Excedrin> hm, yea I guess that's right
19:33:12 <dons> dibblego: they give up purity to allow easy calls to stateful Java code?
19:33:23 <dibblego> dons, pretty much
19:33:32 <dons> the interaction with laziness sounds a bit scary
19:33:57 <dons> well, anyway, the fact its given up on referential transparency makes it hmm, odd.
19:34:04 <dons> pragmatic, but odd.
19:34:10 <SamB_XP> we have too, silly ;-P
19:34:12 <dibblego> I wouldn't suggest that it has
19:34:17 <Korollary> For some reason I was totally uninterested in CAL.
19:34:25 <dibblego> you are strongly encouraged to keep your side-effects local
19:34:35 <dons> via convention?
19:34:39 <dibblego> correct
19:34:44 <SamB_XP> also floggin?
19:34:46 <dibblego> much like a unsafe* call
19:34:47 <SamB_XP> er. flogging?
19:34:53 <dibblego> wtf is flogging?
19:34:54 <dons> but the compiler can't rely on purity the.
19:34:57 <dons> so no fusion :-)
19:35:22 <Korollary> How do you sequence these side effects?
19:35:35 <SamB_XP> dibblego: i.e. whipping
19:35:43 <dibblego> I don't know; like I said, I've only looked briefly
19:35:43 <dons> hello hhuu. welcome
19:35:50 <SamB_XP> @web1914 flogging
19:35:52 <lambdabot> *** "Flogging" web1913 "Webster's Revised Unabridged Dictionary (1913)"
19:35:52 <lambdabot> Flogging \Flog"ging\, a. & n.
19:35:52 <lambdabot>    from {Flog}, v. t.
19:35:52 <lambdabot>  
19:35:52 <lambdabot>    {Flogging chisel} (Mach.), a large cold chisel, used in
19:35:54 <lambdabot> [12 @more lines]
19:35:56 <SamB_XP> hmm.
19:36:00 <dibblego> SamB, oh right - I thought there was a paper on flogging I needed to read
19:36:01 <SamB_XP> not quite it
19:36:07 <SamB_XP> dibblego: heh
19:36:07 <Korollary> Lol
19:36:19 <dons> cold chisel eh.
19:37:14 <dibblego> I wrote deCons in Scala and I like it better; I don't know why
20:03:07 <cdsmith> When I build GHC, where in the build directory does it put resulting binaries?
20:03:49 <sorear> cdsmith: You don't want to know.
20:04:03 <sorear> cdsmith: If i'm second guessing you correctly - it won't work
20:04:03 <cdsmith> Oh?  I'm hoping I can test changes without make install.
20:04:24 <sorear> cdsmith: Yeah, the regular ghc binary needs to be installed and will not work in place
20:04:30 <cdsmith> Drat!
20:04:36 <sorear> cdsmith: conversely, ghc builds contain an inplace only ghc
20:05:08 <cdsmith> So if I make install, do I lose all my packages in the package database?
20:05:26 <sorear> cdsmith: No, because there is a separate package database for each ghc version
20:05:33 <sorear> cdsmith: use find . -name '*in*place*'
20:05:43 <sorear> cdsmith: that should tell you the name of the in-place build
20:06:03 <cdsmith> Is there an in-place GHCi?  Cuz that's what I was hacking at now.
20:06:59 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
20:06:59 --- topic: set by dons on [Sun May 27 19:49:12 2007]
20:07:09 <sorear> cdsmith: Huh?
20:07:24 <sorear> cdsmith: Doesn't find tell you where the inplace ghc is?
20:08:03 <cdsmith> Maybe I'm missing something, but I tried running a ghc-inplace, and it wouldn't run with --interactive
20:08:34 <sorear> cdsmith: probably you're trying to use the stage1 ghc-inplace
20:08:51 <sorear> cdsmith: stage2 or higher is needed for --interactive and -fth to work safely
20:09:07 <sorear> they are disabled in stage1 builds to protect your feet
20:09:20 <cdsmith> Okay.  Well, unfortunately I just started to rebuild... so I'll try again in 15 minutes or so
20:10:01 <Korollary> You should be able to Ctrl-C out of it
20:11:01 <cdsmith> Korollary.  No, because I did make clean first; I needed to re-run configure to add a prefix, and IME builds break with ./configure ; make unless you make clean first.
20:12:47 <cdsmith> Well, when I decided to have a crack at GHC's Trac  ticket #1378, I didn't expect it to be this much of a pain. :)
20:18:28 <xpika> #join asadsh
20:19:35 <cdsmith> Interesting... so ghc doesn't build with ghc HEAD?  Or is this more weirdness on my part?
20:19:58 <dolio> cdsmith: Error on 'pretty'?
20:20:02 <cdsmith> yes
20:20:18 <dolio> Yeah. I was getting that earlier. It seems to be building with 6.6, though.
20:20:32 <cdsmith> Good, because that's what I'm building with now.
20:21:03 <cdsmith> I remember those modules got moved to a new package, so I at least knew what the problem was.
20:28:03 <newb_prog> why are haskell mondas often compared with lisp macros; the two seemt to solve entirely different problems; what's this magicaly duality that I'm not seeing?
20:28:41 <SamB_XP> ???
20:28:44 <SamB_XP> news to me
20:28:47 <dibblego> where do you see it?
20:28:55 <SamB_XP> I though it was the lazy HOFs that were compared with macros
20:30:07 <Korollary> For things like Parsec, monadic syntax also serves as DSL, which is why they may be compared with macros
20:30:17 <dolio> I think Cale often includes monads in with those two into the 'create your own control structures' camp.
20:30:43 <dolio> Which would be one use of macros.
20:31:59 <Cale> Actually, I like to compare laziness with macros. It solves most of the real programming problems that macros do.
20:32:25 <Korollary> I wouldnt say most
20:32:31 <SamB_XP> Korollary: I would
20:32:54 <SamB_XP> notice the "real" part
20:32:57 <Korollary> SamB_XP: I don't think lazyness gives you, say, an object system and such.
20:33:05 <chessguy> hmm, i'm trying to figure this line out. newtype Dist a = D {unD :: [(a,Probability)]}
20:33:09 <SamB_XP> Korollary: so?
20:33:24 <Korollary> SamB_XP: Metaprogramming is a real programming task
20:33:25 <chessguy> so unD :: Dist a -> [(a,Probability)] ?
20:33:27 <sioraiocht> chessguy: it's a record, imo?
20:33:36 <SamB_XP> Korollary: yeah, now you need to notice the "most" part
20:33:40 <sioraiocht> chessguy: you got it
20:33:47 <Korollary> I do notice the most part.
20:33:59 <Korollary> I'm done with this subject.
20:34:00 <chessguy> hmm, i've never seen a named field in a newtype
20:34:11 <chessguy> why is it a newtype and not just a type
20:34:28 <sioraiocht> chessguy: now that you mention it, me neither
20:34:39 <SamB_XP> @hoogle run
20:34:40 <lambdabot> Test.QuickCheck.Batch.run :: Testable a => a -> TestOptions -> IO TestResult
20:34:40 <lambdabot> Data.Graph.Inductive.NodeMap.run :: (DynGraph g, Ord a) => g a b -> NodeMapM a b g r -> (r, (NodeMap a, g a b))
20:34:40 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
20:34:43 <SamB_XP> @hoogle runState
20:34:43 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
20:34:44 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
20:34:48 <SamB_XP> @hoogle runWriter
20:34:49 <lambdabot> Control.Monad.Writer.runWriter :: (Writer w a -> a, w)
20:34:49 <lambdabot> Control.Monad.Writer.runWriterT :: WriterT w m a -> m (a, w)
20:35:04 <SamB_XP> @src Reader
20:35:04 <lambdabot> Source not found. Are you on drugs?
20:35:08 <SamB_XP> aww.
20:35:12 <SamB_XP> @hoogle runReader
20:35:13 <lambdabot> Control.Monad.Reader.runReader :: Reader r a -> r -> a
20:35:13 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
20:35:17 <SamB_XP> @hoogle runRWS
20:35:17 <lambdabot> Control.Monad.RWS.runRWS :: RWS r w s a -> (r -> s -> (a, s, w))
20:35:17 <lambdabot> Control.Monad.RWS.runRWST :: RWST r w s m a -> (r -> s -> m (a, s, w))
20:35:28 <SamB_XP> these are all named fields in newtypes, btw ;-)
20:35:40 <sioraiocht> > @src State
20:35:40 <lambdabot>  Parse error
20:35:44 <sioraiocht> @src State
20:35:44 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:35:47 <SamB_XP> except that first batch
20:35:57 <sioraiocht> @src Control.Monad.State.Lazy.State
20:35:58 <lambdabot> Source not found. Are you on drugs?
20:36:02 <kfish> lambdabot: be nice
20:36:04 <sioraiocht> *growls*
20:36:13 <sioraiocht> chessguy:  newtype State s a = State {
20:36:13 <sioraiocht> runState :: (s -> (a, s))
20:36:13 <sioraiocht> }
20:36:28 <chessguy> oh good point
20:36:38 <sioraiocht> heh, I hadn't thought of it either
20:36:56 <sioraiocht> I dunno WHY you'd want a named field in a newtype
20:36:59 <sioraiocht> but whatever floats your boat
20:37:15 <SamB_XP> sioraiocht: it is a handy way to invoke your monadic computation, in these cases
20:37:22 <dolio> sioraiocht: It's a way to define the newtype and its destructor all on one line.
20:37:45 <sioraiocht> I'm sorry, it's WHAT, dolio?
20:37:46 <chessguy> but why newtype and not type?
20:37:53 <SamB_XP> ... destructor?
20:37:59 <SamB_XP> chessguy: type is inconvenient
20:38:10 <chessguy> SamB, why?
20:38:21 <dolio> Instead of 'newtype State s a = State (s -> (a, s)) ; runState (State st) = st'
20:38:27 <chessguy> err, SamB_XP
20:38:28 <SamB_XP> chessguy: you still have the same type as before
20:38:30 <sioraiocht> dolio: ohhhh
20:38:34 <sioraiocht> thanks =)
20:38:56 <SamB_XP> chessguy: and I don't particularly want you to call me SamB_XP -- I respond to both fine
20:39:15 <chessguy> why can't you nuke the one you're not using?
20:39:18 <chessguy> it's quite annoying
20:39:29 <SamB_XP> I'm too lazy to learn irssi?
20:39:35 <SamB_XP> also I like the gui...
20:39:45 <chessguy> just do it with irc commands
20:39:49 <bd_> irssi has a proxy mode. I've not used it myself, though.
20:39:52 <chessguy>  /ghost SamB <password>
20:39:53 <bd_> there's also things like dircproxy.
20:40:41 <SamB_XP> but I tend to switch between computers erratically, and they share a monitor :-(
20:40:54 <dolio> And you need a newtype because you can't declare 'instance Monad (s -> (<hole>, s)) where ...', nor can you partially apply a type synonym like 'type State s a = s -> (a, s)'.
20:41:05 <sioraiocht> SamB_XP: there's no need for XP in your life
20:41:28 <SamB_XP> I don't think much of Extreme Programming myself
20:41:47 <dolio> And even if you could, you might run into overlapping instances without newtype.
20:41:52 <bd_> SamB_XP: irssi proxy mode supports multiple connections, I think, but again I've not used it much myself :)
20:42:05 <sioraiocht> SamB_XP: it's a fad, imo =p
20:42:07 <SamB_XP> bd_: well, I'll look into that then...
20:42:43 <SamB_XP> the XP stands for, um, Windows 5.1
20:43:02 <sioraiocht> haha, i figured that
20:43:04 <sioraiocht> windows is evil
20:43:05 <sioraiocht> and gross
20:45:02 <ddarius> Windows -NT- 5.1
20:45:35 <SamB_XP> ddarius: well, x-chat doesn't seem to be smart enough to figure out that it is NT ;-)
20:45:50 <SamB_XP> also I haven't heard of 9x 5
20:46:11 <ddarius> I don't know what version ME was.
20:46:30 <SamB_XP> probably 4
20:47:45 <sorear> 95 is 4.0  98 is 4.1   ME is 4.9
20:47:52 <sorear> 2000 is NT5.0
20:50:17 <kfish> @quote
20:50:17 <lambdabot> narain says: [on finger trees] that's gotta be one of the most disturbing names in computer science
21:04:57 <dons> so here's an idea of anyone who's bored.
21:05:09 <dons> we're thinking of allowing user-definable monad *transformers* in config files, for xmonad
21:05:19 <dons> so you could, um, add your own ContT layer over the whole app.
21:05:34 * dons ponders time travelling window manager checkpointing, via config files
21:09:01 <ddarius> So what's the question?
21:09:27 <Excedrin> does schwarzwald hang out here? (maybe he's in #lisp.. I don't remember)
21:09:48 <dons> ddarius: just an idea. sounds pretty hmm, amazing?
21:09:56 <ddarius> Easy enough.
21:10:25 <dons> right. easy, and ridiculously powerful
21:10:38 <ddarius> dons: This is Haskell.
21:10:48 <dons> the user provides something of kind (* -> *) -> *
21:10:53 <dons> which wraps the underlying monad stack
21:11:02 <dons> so it could be IdentityT by default
21:11:10 <dons> sorry, -> * (missing one arg)
21:11:24 <thoughtpolice> pretty soon you'll just end up writing a DSL and using that to code xmonad. your LOLcode one looks like a prime example. :)
21:11:46 <SamB_XP> lolcode here too>?
21:12:07 <dons> we actually have a bit of a DSL for doing tiling, based on pretty printing
21:12:24 <ddarius> I see the connection.
21:13:18 <dons> yeah, filling a plane with rectangles is quite similar
21:13:34 <thoughtpolice> dons: I like the idea though; of course, I'd have to figure out how to write a monad transformer (or a monad for that matter) and start using xmonad before I could have fun with it (I just ssh to my bsd/linux boxes normally.)
21:13:53 <dons> well, the simplest use is to use StateT to thread private state around the app
21:17:18 <SamB_XP> @quote lego
21:17:18 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
21:17:24 <SamB_XP> @quote lego
21:17:24 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
21:17:28 <SamB_XP> aww.
21:17:33 <SamB_XP> @quote monad.*lego
21:17:33 <lambdabot> No quotes match. Do you think like you type?
21:17:38 <SamB_XP> @quote monad
21:17:38 <lambdabot> inv2004 says: lambdabot: monads ?
21:17:41 <SamB_XP> @quote monad
21:17:41 <lambdabot> kyevan says: Monads seem like the Mt. Doom of haskell. Looming in the distance and scareing the shit out of me.
21:17:47 <SamB_XP> hmm.
21:17:55 <SamB_XP> @quote mtl
21:17:55 <lambdabot> No quotes match. I feel much better now.
21:18:09 * SamB_XP was hoping for something about the MTL or
21:18:12 <SamB_XP> something
21:18:36 <SamB_XP> I almost always build my monads from the MTL transformers
21:18:53 <SamB_XP> since if I don't I usually just end up reinventing them ;-)
21:19:06 <ddarius> SamB_XP: As does everyone else.
21:19:15 <mauke> @quote
21:19:16 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
21:19:37 <SamB_XP> newtypes are good for letting toy get all the benefits of reinvention with none of the hastle ;-)
21:19:47 <SamB_XP> wow
21:19:53 <SamB_XP> @quote
21:19:53 <lambdabot> NO says: HABIA PARCIALES
21:19:59 <SamB_XP> @quote
21:19:59 <lambdabot> nocotigo says: if you can't tell what encoding the code is in, i'd say you've gone too far
21:20:08 <SamB_XP> hahaha
21:21:31 <jfredett>  why the frak does floor have to have type RealFrac
21:21:46 <jfredett> This whole number Type system is unbelievable... :/
21:22:40 <SamB_XP> jfredett: well, if it isn't Real it doesn't make sense to talk about "the largest n such that n <= x"
21:22:48 <ddarius> jfredett: It is annoying to the mathematically-inclined.
21:23:06 <SamB_XP> however, I'll admit that a lot of stuff is irksome...
21:23:22 <SamB_XP> for instance, I wrote some PDP-1 arithmatic code earlier today ;-)
21:23:47 <jfredett> SamB, I understand that there are needs for different types- but there is no interaction between two effectively equal types.
21:23:54 <ddarius> SamB_XP: floor makes sense for many other types, i.e. many subsets of the "real" numbers.
21:24:17 <jfredett> for instance
21:24:21 <SamB_XP> ddarius: like what?
21:24:36 <jfredett> floor(logBase b k)
21:24:39 <jfredett> doesn't work
21:24:43 <ddarius> SamB_XP: The rationals, the integers, ints
21:24:50 <jfredett> :t floor(logBase b k)
21:24:53 <lambdabot> Not in scope: `b'
21:24:53 <lambdabot>  
21:24:53 <lambdabot> <interactive>:1:16: Not in scope: `k'
21:24:56 <ddarius> :t logBase
21:24:58 <lambdabot> forall a. (Floating a) => a -> a -> a
21:25:00 <jfredett> :t floor(logBase 2 5)
21:25:02 <lambdabot> forall b. (Integral b) => b
21:25:19 <jfredett> well, it doesn't work on my machine, at least
21:25:20 <SamB_XP> anyway, there didn't seem to be much provision for two-zeroed types...
21:25:26 <ddarius> jfredett: ...
21:25:33 <jfredett> lol
21:25:37 <SamB_XP> at least, not if I don't want -0 and 0 to be ==
21:26:01 <ddarius> SamB_XP: Nor should there be.
21:26:04 <jfredett> it's saying that theres no instance of RealFrac Integers
21:26:15 <jfredett> and no instance for Floating Integers
21:26:24 <mauke> jfredett: you're doing it wrong
21:26:25 <SamB_XP> ddarius: well how the hell am I supposed to implement my PDP-1 emulator properly then?
21:26:26 <ddarius> jfredett: Then you probably need a fromIntegral somewhere.
21:26:46 <jfredett> right, but I shouldn't have to sprinkle my code with fromIntegrals
21:26:55 <ddarius> SamB_XP: Any way you want, or lie, but it's still no reason for Num to support things that aren't numbers.
21:26:56 <jfredett> or any other such nonsense
21:27:02 <mauke> I shouldn't have to sprinkle my code with read/show
21:27:12 <mauke> putStr ("25" + 3) should just work
21:27:13 <SamB_XP> ddarius: how is it not a number just because it has two zeroes?
21:27:25 <Philippa> jfredett: yes, yes you should
21:27:31 <ddarius> jfredett: Actually, most Haskellers prefer it that way, especially the more mathematically inclined ones in my experience.
21:27:38 <dibblego> wasn't there a proposal for implicit type conversions?
21:27:47 <SamB_XP> I have a suggestion
21:27:49 <SamB_XP> try
21:27:53 <SamB_XP> fI = fromIntegral
21:27:53 <jfredett> If there is, I support it
21:27:58 <SamB_XP> if you need that a lot
21:28:13 <Philippa> dibblego: there're prelude replacements that use MPTCs and fundeps to do it
21:28:22 <ddarius> mauke: And what should the output be.
21:28:24 <jfredett> SamB_XP, oh my jake, why the frak didn't i think of that...
21:28:35 <Pseudonym> Explicit type conversions do remove some fairly important classes of bug.
21:28:49 <jfredett> at least now I can sprinkle my code in a tiny way
21:28:51 <ddarius> Which Haskellers are fond of removing.
21:28:55 <mauke> ddarius: 28, obviously!
21:29:05 <jfredett> see, I don't mind the occasional explicit type conversion
21:29:13 <jfredett> but at one point I had seven of them
21:29:21 <jfredett> and I couldn't tell what my code was doing anymore
21:29:23 * ddarius waits for someone to say "253, obviously!"
21:29:24 <Pseudonym> Seven in a decent-sized module isn't a huge deal.
21:29:27 <dibblego> jfredett, every function call is a 'type conversion'
21:29:32 <jfredett> function
21:29:32 <Pseudonym> Seven in one function is a problem.
21:29:33 <mauke> I mean, Perl can do it, so when is haskell going to follow?
21:29:37 <jfredett> not module
21:29:46 <chessguy> @hoogle a -> a
21:29:47 <Pseudonym> dibblego: Not true.
21:29:47 <lambdabot> Prelude.id :: a -> a
21:29:47 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:29:47 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
21:29:49 <ddarius> mauke: Haskerl
21:29:51 <jfredett> dibblego, I understand that, but i mean within the function
21:30:01 <jfredett> Pseudonym, In a way, it is
21:30:04 <Philippa> jfredett: that suggests you were doing something silly
21:30:11 <Pseudonym> Type conversions are retractions.
21:30:37 <ddarius> jfredett: What Philippa said.  Usually when you have ugly code in Haskell you are doing something "wrong".  Not always.
21:30:39 <jfredett> Philippa, I figured; Pseudonym I guess thats true- i dunno
21:31:01 <Pseudonym> It may suggest that your code needs refactoring.
21:31:08 <ddarius> A conversion should be an embedding.
21:31:18 <ddarius> (To say what Pseudonym said another way)
21:31:24 <jfredett> heres what I'm trying to do
21:31:29 <Pseudonym> The most type conversions I think I've ever used in one function is when I wanted to compute a CRC of a String.
21:31:36 <Pseudonym> Which needed conversions to various Word* types.
21:31:37 <jfredett> this is the nth time I've rethought the implemenation
21:31:57 <jfredett> logk  is supposed to tell me if a logarithm in base b
21:32:01 <jfredett> of some number k
21:32:03 <jfredett> is integral
21:32:12 <jfredett> so its type is therefore:
21:32:21 <jfredett> Integer -> Integer -> Bool
21:32:37 <Pseudonym> And you should be able to implement that using only Integers, surely.
21:32:48 <jfredett> it wouldn't make sense to do it over Float's or anything else, because it'd have to be nonintegral
21:32:59 <jfredett> so- my implementation is as follows
21:33:35 <jfredett> b ^ (floor $ logBase b k) == k
21:33:55 <Pseudonym> http://cr.yp.to/papers/powers-ams.pdf  -- Here's an interesting paper on that topic.
21:34:05 <jfredett> that is, if the base raised to the floor of the exponent is the value, then the thing must be integral
21:34:11 <jfredett> Pseudonym, Read it.
21:34:16 <jfredett> :P
21:34:19 <Pseudonym> :-)
21:34:38 <jfredett> I actually am (trying) to implement AKS in Haskell
21:34:45 <Pseudonym> There you go!
21:34:46 <jfredett> to compare it to a scheme version i did
21:34:51 <jfredett> regardless.
21:35:27 <jfredett> i then run this
21:35:36 <jfredett> and it yells at mean "Floats!"
21:35:43 <Pseudonym> Essentially, what you want to do is keep dividing k by b until you get either 1 or a nonzero remainder.
21:35:44 <jfredett> s/mean/me
21:35:51 <Pseudonym> Conceptually speaking.
21:35:51 <ddarius> :t \b k -> b ^ floor (logBase (fromIntegral b) (fromIntegral k)) == k
21:35:57 <lambdabot> forall a. (Integral a) => a -> a -> Bool
21:36:03 <ddarius> jfredett: ?
21:36:08 <jfredett> see, that totally didn't happen to me
21:36:24 <jfredett> then again, I didn't have the fI's
21:37:38 <jfredett> anyway, i suppose that solves it
21:37:48 <jfredett> i dunno...
21:37:54 <sorear> 2/wg 5
21:37:55 <jfredett> Types can be frustrating
21:39:14 <ddarius> Once you get used to the type errors, they almost always tell you exactly what's wrong and, more or less, what to do about it.  When some of the other "type debugging" stuff gets more mainstream, things will be looking very up.
21:39:31 <jfredett> yah- i suppose
21:39:58 <jfredett> It just seems like all the number types could be made to be alot simple
21:39:58 <jfredett> r
21:40:23 <jfredett> but I'm a newb, so maybe my vision is limited
21:40:49 <ddarius> Num and co. could be cleaned up, but it wouldn't exactly "simplify" things.
21:42:40 <dolio> Writing typeclasses that do implicit conversion definitely isn't simpler.
21:44:19 <ddarius> dolio: The issue is whether it is simpler for the end user.
21:44:48 <dolio> Yeah. I'm not certain how that'd work out, either.
21:45:00 <Pseudonym> Anyone know what's up with hpaste?
21:45:12 <dibblego> blurken
21:45:16 <SamB_XP> Pseudonym: you mean, what is *down* with hpaste?
21:45:17 <ddarius> dolio: Me neither.  Probably about the same, only fromIntegral would be written ( ... :: SomeFloatingType)
21:45:21 <Pseudonym> Indeed.
21:45:36 <dolio> ddarius: Yeah.
21:45:52 <Pseudonym> http://nomorepasting.com/paste.php?pasteID=80375
21:45:57 <SamB_XP> this reminds me of why I gave up on writing my own collection classes ;-)
21:46:02 <ddarius> jfredett: As a rule, Haskellers tend to like things explicit.
21:46:04 <Pseudonym> My attempt at a fast logk.
21:46:04 <brad_> have a question about HaXml
21:46:09 <Pseudonym> Note: Didn't try very hard.
21:46:23 <SamB_XP> I couldn't figure out how to get map to map from one collection to another collection of the same sort!
21:46:49 <ddarius> "New! If you're new to programming and would like to read some introductory tutorials for Visual Basic 2005, visit the new NMP Learning Center."
21:46:50 <SamB_XP> (i.e. Data.Sets to Data.Sets, Data.Maps to Data.Maps, etc.)
21:47:00 <brad_> the xmlParse function returns a type Document, described as Document Prolog (SymTab EntityDef) Element [Misc]. how would i just get the Element out of that?
21:47:04 <jfredett> ddarius, I understand that, and I'm okay with being explicit, but there are limits- I can deal with explicit projections(?) a few times in my function, but it seems to just add a ton of clutter after a while
21:47:47 <davidL> is Cabal responsible for generating the .buildinfo file?
21:47:52 <jfredett> someday I'll gain enlightenment
21:47:56 <jfredett> and all will be well
21:47:57 <ddarius> jfredett: -Projections- should always be explicit.  But there is no real reason to have more conversions that arguments at the most except for weird stuff.
21:48:04 <SamB_XP> jfredett: not precisely.
21:48:29 <SamB_XP> you'll just grumble about the compiler not being able to read your mind, and the compiler will grumble about how you are unable to make up yours
21:48:47 <ddarius> But still, ironically, Haskellers tend to hide these things.  They like to be explicit only to hide it later.
21:48:55 <jfredett> SamB_XP, I'm not trying to grumble, I'm trying to understand the compiler
21:49:09 <jfredett> to achieve oneness with ghc
21:49:32 <SamB_XP> frankly, I'm not certain that that is a good idea
21:49:38 <SamB_XP> you might become buggy
21:49:46 <Pseudonym> Or your brain might explode.
21:49:47 <jfredett> well, someone's gotta try it to figure that out
21:49:51 <SamB_XP> the impossible will start to happen on a regular basis
21:49:51 <ddarius> Damn Pseudonym
21:49:56 <SamB_XP> and yes, your brain will explode
21:50:00 <jfredett> Pseudonym, that would be awesome
21:50:04 <SamB_XP> @ghc brain
21:50:04 <lambdabot> ghc says: My brain just exploded.
21:50:09 <SamB_XP> @ghc impossible
21:50:09 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
21:50:19 <SamB_XP> @ghc impossible
21:50:19 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
21:50:21 <SamB_XP> @ghc
21:50:21 <lambdabot> ghc says: Can't represent a guarded lambda in Template Haskell
21:50:24 <SamB_XP> @ghc
21:50:25 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
21:50:26 <Pseudonym> The impossible no longer happens under 6.6, just the merely improbable.
21:50:26 <jfredett> SamB_XP, Don't we already get buggy?
21:50:34 <jfredett> Congenital defects and whatnaught?
21:50:35 <SamB_XP> jfredett: ... true
21:50:46 <jfredett> so really, its a lateral move
21:50:50 <SamB_XP> well, I was thinking more like "thinko, typo"
21:50:51 <SamB_XP> etc.
21:51:05 <jfredett> i suppose
21:51:13 <ddarius> As long as you reproduce, to some that would be not buggy enough.
21:51:38 <jfredett> wow, this conversation has changed considerably
21:51:41 <Pseudonym> My genes aren't selfish, I try to give them to as many people as possible.
21:52:19 <SamB_XP> Pseudonym: are you saying that "the `impossible' happened" doesn't appear in 6.6 error messages?
21:52:30 <Pseudonym> No, I'm making a lame quip.
21:52:33 <SamB_XP> I'm pretty sure the version number was just there to make sure you don't blame the wrong version
21:52:36 <Pseudonym> It does specify 6.4.
21:52:38 <SamB_XP> @ghc
21:52:38 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
21:53:08 <SamB_XP> ... is that what happens when you play with that array wraparound bug?
21:53:14 <Pseudonym> I don't think I'd like it if my brain had an evil mangler.
21:53:19 <SamB_XP> @ghc
21:53:19 <lambdabot> ghc says: All the type patterns for a generic type constructor must be identical
21:53:23 <SamB_XP> @ghc
21:53:23 <lambdabot> ghc says: does not have the required strict field(s)
21:53:31 <SamB_XP> @ghc
21:53:32 <lambdabot> ghc says: internal error: EVACUATED object entered!
21:53:45 <Pseudonym> Eeeuw.
21:53:47 <SamB_XP> oh, that one definately happens when you play with the array wraparound bug
21:54:09 <SamB_XP> I remember I've seen lambdabot say that one
21:56:05 <SamB_XP> @quote
21:56:06 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
21:56:08 <SamB_XP> @quote
21:56:08 <lambdabot> PaulAJ says: Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what
21:56:09 <lambdabot> other part of the program might have been using it.
21:56:30 <SamB_XP> @quote
21:56:31 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
21:56:40 <SamB_XP> @quote
21:56:41 <lambdabot> malcolmw says: i want a book "Lax monoidal functors and coalgebraic specification for dummies"
21:56:52 <SamB_XP> hahhaahah
21:57:16 <SamB_XP> maybe "for non-eggheads"
21:58:57 * dolio likes Joe Celko's '... for Smart People' books.
21:59:11 <dolio> Although that's partially because he looks like an evil magician.
21:59:42 <SamB_XP> heh
21:59:49 <SamB_XP> is he black-hat or grey-hat?
21:59:53 <SamB_XP> @quote
21:59:53 <lambdabot> nilsi says: #haskell is better than google
22:00:03 <SamB_XP> @quote
22:00:03 <lambdabot> fantasma says: i'll change my nick and everything once I learn haskell
22:00:03 <ddarius> lax monoidal functors and coalgebraic specifications are (each at least) more or less straightforward.
22:00:26 <Weremanatee> Celko is a twaddle!
22:00:30 <SamB_XP> ddarius: don't you need to teach mathematicses first?
22:01:00 <dolio> Weremanatee: The title and his picture are probably better than the books themselves.
22:01:00 <ddarius> SamB_XP: It depends on what you mean by mathematics and what you expect to do with them, but not really.
22:02:04 <Weremanatee> dolio: Agreed. The pictures are very nice.
22:02:06 <Weremanatee> :-)
22:02:47 * SamB_XP can see it now... "Haskell for Smart People"
22:02:48 <dolio> His examples amuse me, too. He's always creating databases to catalogue his fictional relationships with pop idols and such.
22:02:49 <Weremanatee> Joe celko and Anton Szandor LaVey might be the same person.
22:04:06 <Weremanatee> Their books are similar.
22:04:30 <dolio> Hehehe.
22:05:49 <Weremanatee> Celko is in Austin though, to his defense.
22:08:14 <Weremanatee> http://www.dbdebunk.com/page/page/1490837.htm
22:08:15 <lambdabot> Title: (NOT) MORE ON CELKO, PLEASE!
22:09:15 <Pseudonym> Oh, man, Fabian Pascal is just as bad.
22:09:33 <Weremanatee> How's that? Pascal has one book.
22:09:39 <Pseudonym> "Relational modelling can solve ANY problem!  Not that anyone has ever actually implemented it..."
22:09:40 <Weremanatee> and it's useful!
22:09:57 <Pseudonym> Am I close
22:09:57 <Pseudonym> ?
22:10:00 <dolio> Hahahaha. "Shit. You're right."
22:10:10 <Weremanatee> dolio: :-)
22:11:06 <scodil> can I use # to make operators? or does GHC reserve this?
22:11:25 <dolio> > let (#) = (+) in 1 # 2
22:11:26 <lambdabot>  3
22:11:43 <Weremanatee> Pseudonym: No, I don't think so. His claim is that nobody has implemented a relational DBMS correctly (i.e. in a way that supports a consistent relational algebra). He's correct on that, aside from a few hobby DBMSs, nothing out there is relational in that sense.
22:11:53 <stepcut> > #
22:11:53 <lambdabot>  Parse error
22:12:01 <scodil> let (#:) = (+) in 1 #: 2
22:12:05 <scodil> > let (#:) = (+) in 1 #: 2
22:12:06 <lambdabot>  3
22:12:40 <stepcut> in ghci, # on a line by itself (or # followed by digits), does nothing
22:13:15 <scodil> is :) a token?
22:13:39 <dolio> No, it's two.
22:13:39 <ddarius> scodil: No.
22:13:49 <stepcut> scodil: if he is wearing is hat, (:)
22:13:50 <stepcut> ;)
22:13:55 <scodil> how about (# ?
22:14:06 <scodil> oh yeah it is huh.. thats an unboxed tuple
22:14:07 <ddarius> Yes.
22:14:10 <ddarius> Yep
22:14:12 <scodil> ok i get it
22:14:31 <scodil> ghc doesn't parse (#:) = ... but ghci does
22:14:57 <SamB_XP> scodil: I bet you aren't doing it right
22:15:00 <SamB_XP> -fglasgow-exts
22:15:02 <Weremanatee> Pseudonym: However, pascal's a bit of a commie (and a cranky bastard too).
22:15:02 <ddarius> Well, unboxed tuples are an extension, so it should parse with extensions turned off.
22:15:11 <SamB_XP> ddarius: oh?
22:15:16 <SamB_XP> OFF you say?
22:15:23 * SamB_XP thought # was an extension
22:15:25 <scodil> ddarius: yeah thats it.. i have exts on
22:15:38 <ddarius> SamB_XP: Not for operators.
22:15:42 <SamB_XP> ddarius: ah.
22:16:05 <SamB_XP> it is still used for primitiveness, so I guess that's where I went wring ;-)
22:16:49 <Pseudonym> True.  Perhaps its his devotees that are the problem, not him.
22:17:52 <skew> I think # is not an allowed identifier character according the the real standard, but it's allowed as a GHC extension
22:18:29 <skew> to make sure you don't accidentally mention stuff like Int# or unsafeCoerce# in code that is supposed to be H98
22:18:36 <ddarius> Indeed.  No "operator characters" are allowed as a (non operator) identifier in the standard.
22:20:27 <skew> _ and ' are the non-alphanumeric characters allowed in an identifier in H98, I think
22:21:14 <ddarius> I don't believe they are allowed in operators though, so that doesn't invalidate my point.
22:21:21 <ddarius> (Unless, of course, I'm wrong)
22:24:57 <skew> I suppose I could look it up
22:24:59 <scodil> so # is a valid operator character in the standard, right?
22:25:23 <skew> I was surprised to find Bool didn't seem to be an instance of any class by default in the Haskell 1.0 standard
22:26:00 <ddarius> > let x # y = x:y in 1#2#3#[]
22:26:01 <lambdabot>   add an instance declaration for (Num [[t]])
22:26:14 <ddarius> Bloody associativity
22:29:22 <dmead> ghc should really handle the precedence for : better
22:31:34 <Cale> dmead: oh?
22:32:49 <cdsmith> > let { infixr # 5 ; x # y = x:y } in 1#2#3#[]
22:32:49 <lambdabot>  Parse error
22:33:19 <cdsmith> > let { infixr 5 # ; x # y = x:y } in 1#2#3#[]
22:33:20 <lambdabot>  [1,2,3]
22:51:37 <dfranke> woot, looks like my computer stuff is going to make it here tomorrow after all.
22:51:43 <dfranke> eight-core pwnage.
22:52:00 <chessguy> only 8? :)
22:52:08 <SamB_XP> "only"?
22:52:15 <dfranke> I'll make it a GHC build save :-)
22:52:17 <dfranke> slave*
22:52:20 <ddarius> dons has 40 in one box and 16 in another
22:52:33 <skew> what is dons using?
22:52:47 <skew> how many dice?
22:52:52 <skew> dies?
22:52:58 <dfranke> what's the cutoff for passing as an entry-level supercomputer?
22:52:59 <SamB_XP> dice!
22:53:13 <SamB_XP> dfranke: it has to take up a whole room?
22:53:13 <chessguy> @help die
22:53:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:53:17 <chessguy> @help dice
22:53:17 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
22:53:22 <SamB_XP> ... probably larger than a closet?
22:53:25 <chessguy> dice 3d62
22:53:29 <chessguy> dice 3d6+2
22:53:32 <chessguy> @dice 3d6+2
22:53:32 <lambdabot> 3d6+2 => 12
22:53:43 <stepcut> dfranke: can it deflect bullets ?
22:53:45 <SamB_XP> @dice 3d6
22:53:45 <lambdabot> 3d6 => 9
22:55:26 <dfranke> I can't wait until EC2 comes out of beta.
22:56:38 <dfranke> stepcut, well, it's a pretty heavy case.  It might be able to deflect a .22 but I'd rather not find out :-)
23:00:51 <dfranke> is there anything analogous to distcc for ghc?
23:00:59 <chessguy> @hoogle split
23:01:00 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
23:01:00 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
23:01:00 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
23:01:47 <dan_> Cale, yea i think x:xs should be recognized as (x:xs)
23:01:58 <dan_> just me .02
23:02:00 <Cale> It is.
23:02:06 <dmead> it isn't
23:02:17 <Cale> It isn't?
23:02:19 <dmead> if you have x:xs in a pattern it won't parse correctly
23:02:47 <Cale> let f (x:xs,y) = (x+y):xs in f ([1,2,3],4)
23:02:47 <skew> that is a bit funny
23:02:50 <Cale> > let f (x:xs,y) = (x+y):xs in f ([1,2,3],4)
23:02:51 <lambdabot>  [5,2,3]
23:03:01 <skew> an incompletely applied constructor can't be a valid pattern
23:03:18 <skew> on the other hand, it would make reading code harder
23:03:19 <dmead> let f x:xs = xs in f [1,2,3]
23:03:23 <dmead> > let f x:xs = xs in f [1,2,3]
23:03:23 <lambdabot>  Parse error in pattern
23:03:33 <dmead> > let f (x:xs) = xs in f [1,2,3]
23:03:34 <lambdabot>  [2,3]
23:03:42 <skew> rebol totally infers grouping from arity
23:03:42 <ddarius> dmead: Application should always bind most strongly.
23:03:56 <Cale> dmead: but that's (f x):xs
23:04:17 <Cale> Which makes it look like a definition of :
23:04:19 <dmead> Cale, I don't think thats what people see when they read that
23:04:30 <Cale> no?
23:04:36 <dmead> no
23:04:40 <dmead> but f x : xs
23:04:46 <dmead> or matbe
23:04:49 <dmead> maybe
23:04:53 <Cale> Maybe I've been programming in Haskell too long, I always see function application happening first.
23:04:54 <dmead> f x :xs
23:05:06 <dmead> yea i've just got a year under my belt
23:05:13 <dmead> and a few weeks of ML before that
23:05:58 <Cale> If you were to want to call f with x:xs as a parameter, it would need the parens.
23:06:24 <Cale> map f (x:xs) = f x : map f xs
23:06:43 <dmead> yea
23:06:45 <Cale> which is not  f (x : map f xs)
23:06:46 <Cale> :)
23:06:48 <dmead> but in a top level pattern
23:07:06 <dmead> f x:xs can't meann (f x):xs
23:07:11 <dfranke> ddarius, you mentioned dons had a bigger array.  How does one even buy a mobo that can handle more than eight cores?
23:07:15 <dmead> it has to be f (x:xs) right?
23:07:34 <dmead> dfranke, tigerdirect?
23:07:39 <Cale> It almost could. The only reason that it can't is that (f x) isn't itself a valid pattern.
23:07:48 <dmead> right
23:07:50 <dmead> thats what i mean
23:07:56 <Cale> F x, however, would be okay
23:08:01 <dmead> aye
23:08:13 <dmead> i guess i'm saying
23:08:19 <dmead> f x:xs = stuff
23:08:24 <dmead> f (x:xs) = stuff
23:08:30 <dmead> should be overlapping patterns
23:08:41 <skew> F x:xs = stuff would definitely be a pattern for :
23:08:50 <skew> saying what happens if the first argument is F x
23:08:50 <Cale> right
23:08:56 <dmead> hmm
23:09:16 <dfranke> dmead, I don't think they sell anything bigger than two-socket.
23:09:20 <dmead> i thought : is a regular constructor, not an operator?
23:09:36 <skew> well, maybe : is a bit wierd
23:09:45 <skew> hmm
23:09:50 <dmead> dfranke, meh.. i know their commonly available
23:09:53 <skew> F x :+ y
23:09:54 <Cale> F x:xs = ... would be a pattern binding
23:11:04 <Cale> but if : was a function symbol, it would be a function binding for :
23:11:10 <skew> so : is like any infix constructor
23:11:34 <Cale> yeah
23:11:44 <Cale> All infix constructors start with :
23:12:05 <Cale> I suppose : is a "capital" symbol :)
23:12:22 <dolio> > let Just x:y = map return [1..10] in x
23:12:23 <lambdabot>  1
23:13:21 <Cale> So f x:xs = foo starts out looking like a pattern binding matching a list, but then f x isn't a valid pattern.
23:14:20 <takamura> hi
23:14:37 <Cale> (Perhaps in a really clever system, it could check to see if it knew an inverse for f and the matching could apply that)
23:14:41 <Cale> hello
23:17:12 <chessguy> @pl c g l = l !! (f $ (r (1, le l) g))
23:17:13 <lambdabot> c = ap (!!) . (f .) . flip (r . (,) 1 . le)
23:20:20 <chessguy> @yow
23:20:21 <lambdabot> I just remembered something about a TOAD!
23:24:34 <jessta__> I'm trying to learn haskell, but I'm having trouble with understanding the the function type signatures.
23:25:02 <roconnor> a -> b -> c means a -> (b -> c)
23:25:21 <roconnor> this is a curried function
23:25:33 <chessguy> jessta__, can you give an example of a type signature you're struggling with?
23:26:22 <jessta__> I want a signature for a function that two Nums and returns a Num
23:26:40 <notsmack> Num a => a -> a -> a
23:26:58 <notsmack> jessta__: presuming you want them to be the same sort of Num
23:27:11 <chessguy> or, more generally, (Num a,b,c) => a -> b -> c
23:27:28 <ddarius> That's not legal syntax
23:27:56 <chessguy> ugh. is it (Num a, Num b, Num c) => a -> b -> c ?
23:28:06 <ddarius> Ayuh
23:28:26 <roconnor> @info Num
23:28:27 <lambdabot> Num
23:28:33 <roconnor> @src Num
23:28:33 <lambdabot> class  (Eq a, Show a) => Num a  where
23:28:33 <lambdabot>     (+), (-), (*)           :: a -> a -> a
23:28:33 <lambdabot>     negate, abs, signum     :: a -> a
23:28:33 <lambdabot>     fromInteger             :: Integer -> a
23:29:02 <notsmack> ddarius: mine isn't?
23:29:14 <roconnor> @type (\a b -> fromInteger ((toInteger a) + (toInteger b))
23:29:16 <lambdabot> parse error (possibly incorrect indentation)
23:29:20 <roconnor> @type (\a b -> fromInteger ((toInteger a) + (toInteger b)))
23:29:22 <lambdabot> forall a a1 a2. (Integral a, Integral a1, Num a2) => a -> a1 -> a2
23:29:27 <roconnor> damn
23:29:57 <notsmack> @type (\a b -> a + b)
23:29:59 <lambdabot> forall a. (Num a) => a -> a -> a
23:30:07 <notsmack> (again, presuming)
23:30:08 <ddarius> notsmack: Yours is fine.
23:32:09 <chessguy> @hoogle (Num a, Num b, Num c) => a -> b -> c
23:32:11 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
23:32:11 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
23:32:11 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c
23:33:00 <roconnor> @type (\a b -> const (-a) (const (-b) 0)
23:33:02 <lambdabot> parse error (possibly incorrect indentation)
23:33:05 <roconnor> @type (\a b -> const (-a) (const (-b) 0))
23:33:07 <lambdabot> forall a a1. (Num a, Num a1) => a -> a1 -> a
23:33:40 <roconnor> @type (\a b -> const 0 (const (-b) (-a)))
23:33:43 <lambdabot> forall t a b. (Num t, Num a, Num b) => b -> a -> t
23:36:31 <chessguy> > map (*2) []
23:36:32 <lambdabot>  []
23:37:48 <chessguy> > length [1..0[
23:37:49 <lambdabot>  Parse error
23:37:54 <chessguy> > length [1..0]
23:37:55 <lambdabot>  0
23:45:27 <jessta__> areaOfRectangle :: (Num a, Num b, Num c) => a -> b -> c
23:45:27 <jessta__> areaOfRectangle h w = h*w
23:45:59 * notsmack was right
23:46:03 <notsmack> @type (*)
23:46:05 <lambdabot> forall a. (Num a) => a -> a -> a
23:46:20 <ddarius> You don't really (ever) want a type like that jessta__
23:47:00 <notsmack> jessta__: keep in mind that each instance in the Num class defines its own way of doing multiplication, so you can only multiply two values of the same type, resulting in an answer of that same type
23:47:20 <notsmack> you can convert between types if you need to, but (*) itself is a -> a -> a
23:47:57 <notsmack> jessta__: (another thing you can do is define the function without specifying the type, then ask ghci by loading it and saying ":type areaOfRectangle"
23:48:27 <notsmack> @type (\ h w = h*w) -- or ask lambdabot
23:48:29 <lambdabot> parse error on input `='
23:48:33 <notsmack> @type (\ h w -> h*w) -- or ask lambdabot
23:48:35 <lambdabot> forall a. (Num a) => a -> a -> a
