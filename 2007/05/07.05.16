00:01:39 <LeCamarade> ulfdoz: It is x86-specific, Unix-specific, and wrong. :o)
00:05:40 <Cheery> does haskell some day get active patterns?
00:06:00 <Cheery> they seems like neat
00:10:58 <ski> ?
00:11:54 <Cheery> I saw them in inductive graphs -paper
00:12:04 <ski> erwig ?
00:12:11 <Cheery> ye
00:13:21 <Cheery> they are such that pattern matching done depends from the value given to the pattern
00:24:21 <osfameron> earthy: dazzle looks nice.  I read the first half of the paper, seems very reasonable.  Though then it started to get into code examples and I was really tired so I gave up...
00:28:29 <Cheery> I wonder whether database tables can be represented inductively
00:29:06 <QtPlatypus> Cheery: How do you mean inductively in this case?
00:29:38 <Cheery> like how lists, trees and now graphs can be represented
00:30:03 <QtPlatypus> Normally databases are thought of as sets of sets of tupples.
00:30:05 <ibid> do you mean the actual data, or the table schemata?
00:30:25 <QtPlatypus> Normally -> One way of
00:30:39 <ibid> well, that's the theoretical view anyway
00:31:03 <Cheery> ibid: not understanding what you ask
00:31:11 <Cheery> terms unknown
00:31:30 <ibid> Cheery: well, *i* don't understand what *you* wondered, and i'm trying to figure it out :)
00:32:00 <QtPlatypus> Cheery: The data in the database, or the meta-data about the data.
00:32:06 <ibid> Cheery: a database schema defines the names and types of the fields in each data
00:32:16 <ibid> in each *table*, sorry
00:32:35 <ibid> (schemata is the plural)
00:33:33 <Cheery> I mean the data
00:33:41 <ibid> (in sql-speak, it's the collection of the CREATE TABLE statements)
00:34:19 <ibid> Cheery: well then, as QtPlatypus said, a table is really just a set of tuples (or set of finite maps if you like); it can certainly be defined inductively (but why bother?)
00:34:41 <ibid> (set of *records*, not finite maps, actually)
00:34:51 <ibid> but i need to catch the bus, bbl :)
00:35:03 <Cheery> k
00:35:19 <QtPlatypus> ibid leaves SIGBUS
00:51:19 * osfameron had a lot of problem with the SOE exercise to work out the principal type of functions like "map map" and "map foldl"
00:51:42 <osfameron> I can't even reason about it... it made me want to cry (haskell quite regularly has this effect on me)
00:54:04 <mauke> well, map takes a function, so map map takes a list of functions
00:54:50 <hpaste>  ku pasted "lala" at http://hpaste.org/1864
00:54:53 <osfameron> but map takes a function (a->b) whereas map is (a-b)->[a]->[b]
00:55:06 <osfameron> does that mean a is (a->b)   and b is [a]->[b]  ?
00:55:16 <osfameron> (perhaps I shouldn't have reused a and b...)
00:56:59 <Cheery> I read the paper but this Data.Graph.Inductive is still quite hebrew
00:57:13 <mauke> osfameron: a -> b -> c is a -> (b -> c)
00:57:23 <osfameron> ok
00:57:26 <mauke> so, yes
00:58:04 <osfameron> when I eventually gave up and did  :t map map  it gave a very nice simple type signature which I couldn't in any way relate to the horror I'd managed to get to...
00:59:04 <mauke> map takes a function (a -> b) and upgrades it to ([a] -> [b])
00:59:12 <Cheery> :t map map
00:59:15 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
00:59:46 <mauke> therefore map map upgrades map to [a -> b] -> [[a] -> [b]]
00:59:58 <_mysty_> hello
01:00:06 <Cheery> ok, that's interesting
01:00:12 <Cheery> :t map
01:00:15 <DRMacIver> I find one is generally more likely to want map . map than map map
01:00:16 <_mysty_> could someone please help me out with the following compilation error
01:00:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:00:24 <DRMacIver> :t map . map
01:00:25 <Cheery> :t map . map
01:00:27 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
01:00:40 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
01:00:40 <osfameron> I actually can't think of a situation I'd want to use map map
01:00:41 <_mysty_> (.text+0x38e):fake: undefined reference to `mtlzm1zi0zi1_ControlziMonadziStateziLazzy_zdf12_closure'
01:00:56 <mauke> _mysty_: hmm, try --make?
01:01:02 <_mysty_> ok
01:01:13 <_mysty_> wow
01:01:17 <_mysty_> thanks!
01:01:20 <_mysty_> I love you!
01:01:22 <_mysty_> :P
01:01:57 <Cheery> :t map map [(+), (*), (-)]
01:02:03 <lambdabot> forall a. (Num a) => [[a] -> [a -> a]]
01:02:20 <Cheery> :t map map [(+2), (*2), (-2)]
01:02:36 <lambdabot> thread killed
01:02:39 <Cheery> lambdabot: you are slow today
01:02:56 <Cheery> :t map map [(+2)]
01:03:00 <lambdabot> forall a. (Num a) => [[a] -> [a]]
01:03:07 <_mysty_> but can I actually get an executable out of it?
01:03:13 <Cheery> :t map map [(+2),(-2)]
01:03:16 <Cheery> _mysty_: yes
01:03:25 <Cheery> your module needs to be called Main
01:03:28 <lambdabot> forall a. (Num a, Num (a -> a)) => [[a] -> [a]]
01:03:36 <Cheery> and it must have main :: IO () in it
01:03:53 <_mysty_> Ah, I see. Thank you.
01:04:00 <dmwit> Heh, Num (a -> a) is a tricky constraint to satisfy.
01:04:21 <mauke> but not impossible
01:04:25 <Cheery> hmm, so, where would I use this weird [[a] -> [a]] ?
01:04:55 <osfameron> I think the SOE exercise is in the wrong place in the book.   It's followed by other more sensible exercises...
01:05:03 <Cheery> :t map ($[5,3,2]) (map map [(+2),(-2)])
01:05:07 <lambdabot> forall a. (Num a, Num (a -> a)) => [[a]]
01:05:12 <Cheery> map ($[5,3,2]) (map map [(+2),(-2)])
01:05:28 <Cheery> > map ($[5,3,2]) (map map [(+2),(-2)])
01:05:36 <lambdabot>   add an instance declaration for (Num (a -> a))
01:05:36 <lambdabot>     In the expression: (- 2)
01:05:50 <dmwit> Cheery: use "subtract 2" instead of "(-2)".
01:05:57 <Cheery> > map ($[5,3,2]) (map map [(+2),(substract 2)])
01:06:04 <lambdabot>   Not in scope: `substract'
01:06:08 <osfameron> hang on... how come (-2) isn't parse as unary -2 in that case ?
01:06:14 <Cheery> > map ($[5,3,2]) (map map [(+2),(subtract 2)])
01:06:16 <dmwit> osfameron: It is. ;-)
01:06:19 <osfameron> ah, ok
01:06:25 <lambdabot>  [[7,5,4],[3,1,0]]
01:06:34 <osfameron> pesky inconsistent consistency... we were talking about that yesterday
01:07:04 <osfameron> it would be nice if -2 was unary and (- 2) was the section
01:07:38 <Cheery> I don't know, I'd like to give unary it's own mark
01:09:44 <Cheery> ?src Data.Graph.Inductive.Example
01:09:45 <lambdabot> Source not found. Are you on drugs?
01:09:48 <Cheery> yes
01:09:53 <Cheery> @src Data.Graph.Inductive.Example
01:09:53 <lambdabot> Source not found. Where did you learn to type?
01:09:57 <Cheery> in school
01:10:02 <Cheery> @src Example
01:10:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:10:13 <Cheery> ..
01:10:29 * osfameron spanks lambdabot for being so rude
01:10:31 <jmg_> hi
01:10:37 <arcatan> lo
01:10:39 <dmwit> I wouldn't mind if there was something like _2 for the numeric literals, to make parsing less ambiguous.
01:11:17 <jmg_> can anybody tell me whether it is possible to catch failed assertions?
01:15:18 <quicksilver> dmwit: agreed, but it's not just numeric literals
01:15:28 <quicksilver> dmwit: it's a genuine prefix operator, too
01:15:36 <quicksilver> > (\x -> -x) $ 5
01:15:48 <lambdabot>  -5
01:15:51 <dmwit> Ooo, ouch.
01:16:12 <quicksilver> dmwit: personally, I'd rather the 'real' prefix operator had an alpha name, like 'negate'
01:16:17 <quicksilver> and '-' was binary
01:16:25 <quicksilver> this is more consistent, since all other symbolic operators are binary
01:16:32 <quicksilver> and alpha operators are prefix
01:16:44 <sphynx> hi all!
01:16:44 <Cheery> ok, so now I know about bunch of stuff about inductive graphs
01:16:52 <quicksilver> but given the choice between an alpha name for 'subtract' and an alpha name for 'negate'
01:17:09 <quicksilver> I'd rather 'negate' was alpha and 'subtract' was symbolic '-'
01:17:16 <dmwit> Yeah.
01:17:19 <Cheery> just not how do I bust non-acyclic graphs?
01:17:21 <sphynx> I'm doing last excercise in "All about monads" tutorial
01:17:33 <sphynx> this one : http://www.haskell.org/all_about_monads/html/solution4.html
01:17:34 <lambdabot> Title: Solution to exercise 4
01:17:46 <dmwit> > let (#) = (-) in 3 # 5
01:17:56 <lambdabot>  -2
01:18:07 <sphynx> there is 'maybeToMonad' function which converts Maybe a to MonadPlus m => m a
01:18:49 <sphynx> I'm trying to write similar function listToMonad, which will have signature (MonadPlus m) => [a] -> m a
01:19:10 <quicksilver> sphynx: that's a bit tricky
01:19:22 <quicksilver> sphynx: since lists contain 'more information' than a generic MonadPlus
01:19:23 <sphynx> I've finally got such function:
01:19:26 <dmwit> :t msum
01:19:33 <sphynx> listToMonad :: MonadPlus m => [a] -> m a
01:19:33 <sphynx> listToMonad [] = mzero
01:19:33 <sphynx> listToMonad (x:xs) = return x
01:19:36 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:19:52 <quicksilver> sphynx: that's one way, certainly
01:19:54 <sphynx> quicksilver, yeah, so I've reduced this information to head only )
01:20:01 <quicksilver> sphynx: you're giving preference to the head of the list
01:20:05 <quicksilver> :t mappend
01:20:09 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:20:12 <quicksilver> :t mplus
01:20:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
01:20:25 <dmwit> How about
01:20:32 <quicksilver> sphynx: another approach is to use mplus
01:20:37 <quicksilver> sphynx: to 'add' together all the elements of the list
01:20:37 <dmwit> listToMonad (x:xs) = return x `mplus` listToMonad xs
01:20:51 <quicksilver> sphynx: this approach reduces to the identity on the list monad
01:20:56 <quicksilver> sphynx: which feels like a nice property
01:21:06 <dmwit> :t foldr
01:21:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:21:29 <sphynx> quicksilver, dmwit Yeah, it looks better
01:21:42 <dmwit> :t foldr mplus mzero
01:21:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:21:55 <sphynx> I will try to play with msum and mappend
01:22:04 <sphynx> :src msum
01:22:12 <mux> morning haskellers
01:22:22 <dmwit> :t foldr (\x y -> return x `mplus` return y) mzero
01:22:27 <lambdabot>     Occurs check: cannot construct the infinite type: b = m b
01:22:27 <lambdabot>       Expected type: b
01:22:54 <quicksilver> :t foldr mplus mzero . map return
01:22:58 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
01:23:06 <quicksilver> dmwit: that's what you're after, I think :)
01:23:21 <dmwit> Of course, that's nicer.
01:23:34 <dmwit> msum . map return has a nice ring to it.
01:23:37 * quicksilver nods
01:23:52 <sphynx> > msum . map return $ "asd"
01:23:59 <lambdabot>   add an instance declaration for (Show (m Char))
01:24:14 <sphynx> > (msum . map return $ "asd")::Maybe Char
01:24:29 <lambdabot>  Just 'a'
01:24:38 <sphynx> > (msum . map return $ "asd")::[Char]
01:24:41 <dmwit> :t foldr (\x y -> return x `mplus` y) mzero -- does it work?
01:24:48 <lambdabot>  "asd"
01:24:54 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
01:25:01 <sphynx> cool, msum works fine ^)
01:25:36 <sphynx> hm, I'm not so familiar with this forall quantor and kninds...
01:25:43 <sphynx> kinds *
01:26:20 <dmwit> > foldr (mplus . return) mzero "gnirtS" :: String
01:26:30 <lambdabot>  "gnirtS"
01:27:34 <joelr1> good morning
01:28:17 <mauke> sphynx: just ignore them
01:28:41 <sphynx> mauke, yeah, I'm doing so right now :)
01:29:03 <sphynx> mauke, and in my GHCi there is no such types with quantors, it seems I need extensions for this
01:29:32 <mauke> type variables are top-level forall'd by default
01:29:57 <mauke> it only matters for higher-ranked types
01:30:00 <mauke> :t runST
01:30:02 <lambdabot> Not in scope: `runST'
01:30:23 <mauke> :t Control.Monad.ST.runST
01:30:28 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
01:30:56 <quicksilver> sphynx: lambdabot is set up to more explicit about the foralls than GHCi is
01:31:13 <quicksilver> sphynx: GHCi doesn't bother to forall at the top level, and it doesn't show you the kind annotations
01:31:51 <mux> unless you pass it -fglasgow-exts
01:32:46 <sphynx> quicksilver, OK, lack of forall at the top level is good for now )
01:33:01 <dmwit> ?djinn (MonadPlus m) => m a
01:37:58 <mux> > nubBy (\x y -> gcd x y > 1) [2..]
01:38:00 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:38:55 <quicksilver> mux: that algorithm gives an incorrect answer around the 4 billionth prime
01:39:40 <dmwit> quicksilver: Because of the size of an Int, or what?
01:40:26 <quicksilver> no, it's an Integer algorithm
01:40:37 <quicksilver> you just have to go and look! and see if you can see what's wrong
01:40:51 <mux> hum
01:41:41 <mux> nubBy compares any element with any other element, right?
01:41:47 <dmwit> yes
01:44:06 <mux> I don't see what's wrong then, and running genericDrop 4billon $ ... is surely going to take me some time :-)
01:44:39 <mux> and also eat all my RAM, most likely
01:44:57 <mux> @src nubBy
01:44:58 <lambdabot> nubBy eq []             =  []
01:44:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:45:38 <mux> quicksilver: please explain
01:46:34 <quicksilver> mux: I just wanted you to think about how easy it is to assume something works from looking at the first 80 chars of the output :P
01:46:51 <mux> hah.
01:47:10 <mux> I fully agree with that :-) so this algorithm is actually correct?
01:48:06 <mux> you scared me :-P
01:50:04 <quicksilver> incidentally, genericDrop in principle doesn't waste ram
01:50:15 <quicksilver> but nubBy does, of course
01:50:20 <mux> but nubBy is going to need the full list in AM
01:50:22 <mux> yeah.
01:50:29 <quicksilver> it's worse than that
01:50:34 <quicksilver> nubBy doesn't hold the list
01:50:40 <quicksilver> it holds a massive complex closure
01:50:46 <quicksilver> that chain of filters
01:50:52 <LoganCapaldo> @check (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..] ==> all (\z -> x `mod` z /= 0) [2..(x-1)])
01:50:57 <lambdabot>  Add a type signature
01:51:12 <mux> quicksilver: *nods*
01:51:15 <quicksilver> which I suspect takes more space than a list would
01:51:15 <LoganCapaldo> @check (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..] ==> all (\z -> x `mod` z /= 0) [2..(x-1)]) :: Integer -> Bool
01:51:21 <lambdabot>  Couldn't match expected type `Bool'
01:51:23 <quicksilver> although I'm not sure of the storage details
01:51:30 <LoganCapaldo> @check (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..] ==> all (\z -> x `mod` z /= 0) [2..(x-1)]) :: Integer -> Property
01:51:35 <mux> quicksilver: I guess a strict-ified nubBy could be less memory expensive
01:51:46 <lambdabot>  thread killed
01:51:49 <LoganCapaldo> :(
01:52:02 <LoganCapaldo> @scheck (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..] ==> all (\z -> x `mod` z /= 0) [2..(x-1)]) :: Integer -> Property
01:52:18 <lambdabot> thread killed
01:53:41 <LoganCapaldo> @scheck (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..100] ==> all (\z -> x `mod` z /= 0) [2..(x-1)]) :: Integer -> Property
01:53:49 <mux> poor LB :-)
01:53:51 <lambdabot>   Completed 13 test(s) without failure.  But 10 did not meet ==> condition.
01:54:01 <LoganCapaldo> @check (\x -> x `elem` nubBy (\x y -> gcd x y > 1) [2..100] ==> all (\z -> x `mod` z /= 0) [2..(x-1)]) :: Integer -> Property
01:54:08 <sphynx> quicksilver, now I'm reading about foldM function, it seems it is similar to foldl, right?
01:54:17 <lambdabot>  thread killed
01:54:25 <quicksilver> sphynx: yes, it's a generalisation of it in a sense
01:54:29 <quicksilver> :t foldM
01:54:30 <LoganCapaldo> 3 tests is good enough for me :)
01:54:44 <lambdabot> thread killed
01:54:46 <mux> it's a monadic fold isn't it? I would call that a specialization rather than a generalization
01:55:03 <mux> I guess it's a matter of how you're looking at it though
01:55:18 <sphynx> mux, yeah, it is monadic fold
01:55:33 <mux> zipWithM > *
01:55:34 <quicksilver> it's a generalisation because a list is a kind of monad
01:55:39 <quicksilver> and foldM works over any monad :)
01:55:55 <quicksilver> so foldM :: [a] is actually foldl
01:55:57 <mux> foldM still takes a list, no matter what monad
01:56:04 <quicksilver> oh
01:56:04 <LoganCapaldo> foldM always folds over a list
01:56:10 <quicksilver> hangon, I'm not thinking straight
01:56:13 * quicksilver nods
01:56:23 <sphynx> :t foldM
01:56:23 * mux go makes self another coffee
01:56:24 <quicksilver> yes, you're quite right, it's a specialisation
01:56:25 <mux> want one? :-)
01:56:34 <quicksilver> it's approximately foldr (>>=)
01:56:38 <lambdabot> thread killed
01:56:41 * mux is all happy because he's in week-end tonight
01:56:42 <quicksilver> with a bit of fiddling to make the types match
01:57:10 <LoganCapaldo> I can no longer sleep
01:57:17 <sphynx> I like this explanation from tutorial:
01:57:18 <LoganCapaldo> perhaps I should go make coffee
01:57:21 <sphynx> -- this is not valid Haskell code, it is just for illustration
01:57:21 <sphynx> foldM f a1 [x1,x2,...,xn] = do a2 <- f a1 x1
01:57:21 <sphynx>                                a3 <- f a2 x2
01:57:21 <sphynx>                                ...
01:57:21 <sphynx>                                f an xn
01:58:06 <LoganCapaldo> Haskell' should understand ...
01:58:08 * mux hands a nespresso to LoganCapaldo 
01:58:09 <LoganCapaldo> :)
01:58:45 <LoganCapaldo> also 'a' should be valid constructor syntax
01:58:59 <dmwit> Why?
01:59:11 <LoganCapaldo> so that those examples that go -- this is not valid syntax: data Char = 'a' | 'b' | ... become valid :)
01:59:27 <dmwit> Oh, yeah. =)
01:59:36 <dmwit> Are you a Gentle Intro survivor, too?
02:00:19 <LoganCapaldo> Is that where I read tha?
02:00:22 <LoganCapaldo> 8that
02:00:28 <LoganCapaldo> arg
02:00:57 <dmwit> You type like a monkey.  Grow up!
02:01:06 <dmwit> </lambdabot impression>
02:01:21 <MyCatVerbs> dmwit: well, it's valid syntax to patter match against, so it's not really different from a normal data constructor in practice, heh. Just that you can't define your own with quite the same lexical rules. =)
02:01:28 <MyCatVerbs> s/patter/pattern/
02:01:44 <dmwit> Yes...
02:02:00 <dmwit> I demand a new syntax for wrapper constructors!
02:02:23 <dmwit> data Char = _'_ Char
02:02:42 <dmwit> data String = _"_ String
02:02:44 <LoganCapaldo> outfix (')
02:02:52 <dmwit> heh
02:04:43 <mdmkolbe|work> but what would be the slice syntax?
02:04:47 <sphynx> hm, what is FiniteMap, I've enciuntered it in this tutorial, but I've got 404 when trying to follow link from lambdabot ":docs Data.FiniteMap"
02:05:01 <mauke> finitemap is deprecated
02:05:08 <dmwit> Use Data.Map instead.
02:05:20 <sphynx> ok
02:05:27 <dmwit> (Many of the function names will even be the same.)
02:06:17 <sieni> http://bash.org/?762681
02:06:23 <dmwit> Well, minus the FM business at the end, if I remember it well.
02:06:24 <lambdabot> Title: QDB: Quote #762681
02:06:45 <dmwit> Hey, I made bash.org!
02:07:01 * osfameron congratulates dmwit 
02:07:04 * dmwit does the famous dance
02:08:11 * earthy doesn't think that's a good way to become famous though
02:08:14 <sieni> http://bash.org/?761884
02:08:18 <lambdabot> Title: QDB: Quote #761884
02:11:38 <dmwit> earthy: http://bash.org/?761380 seems to agree with you.
02:11:39 <lambdabot> Title: QDB: Quote #761380
02:13:12 <mauke> dmwit: http://www.ghastlycomic.com/d/20050220.html
02:13:15 <lambdabot> Title: Ghastly's Ghastly Comic - Tentacle Monsters And The Women Who Love Them.
02:13:39 <LoganCapaldo> visual aids RULE!
02:13:43 <dmwit> heh heh
02:13:51 * dmwit pretends he came up with the joke all on his own
02:17:21 <dmwit> "...where do you register to become a sex offender?"
02:17:59 <mux> GMap > Data.Map
02:18:54 <dmwit> mux: ?index GMap
02:19:21 <mux> dmwit: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsExamples
02:19:23 <lambdabot> Title: TypeFunctionsExamples - GHC - Trac
02:20:43 <LoganCapaldo> GSpot > Data.Spot ?
02:20:52 <mux> heh
02:20:56 <dmwit> gah
02:21:14 * dmwit hasn't learned about associated types yet
02:24:06 <dmwit> Oh, you can kind of almost guess the meaning of some of the things.
02:24:13 <dmwit> This looks intriguing.
02:27:56 <dmwit> mux: So basically, GMap can have different implementations of the map for each key type?
02:29:06 <mux> dmwit: yes
02:29:30 <mux> dmwit: and optimized implementations; ie, we could have GMap use Data.IntMap behind the scenes when the key is Int
02:29:36 <mux> though in that example they don't do that
02:29:39 <dmwit> Right, that's nifty.
02:29:52 <dmwit> I assume that's the idea behind associated types in general?
02:30:00 <mux> yes
02:30:12 <mux> what I find real nice about them is that they subsume functional dependencies
02:30:29 <dmwit> huh
02:30:34 <dmwit> This is a very cool area.
02:30:40 <LoganCapaldo> I consume dysfunctional suspendencies
02:30:45 <LoganCapaldo> woah
02:30:52 <LoganCapaldo> I definitely need some coffee
02:31:09 <dmwit> ?quote LoganCapaldo I consume dysfunctional suspendencies
02:31:10 <lambdabot> No quotes match. That's something I cannot allow to happen.
02:31:12 <mux> dmwit: also, it gets completely desugared into plain System F
02:31:17 <dmwit> ?remember LoganCapaldo I consume dysfunctional suspendencies
02:31:17 <lambdabot> Done.
02:31:54 <dmwit> mux: Oh, but it isn't just a preprocessor, right?
02:32:55 <mux> dmwit: if you mean that it needs other things than a translation to system f to work, then no
02:33:05 <mux> as far as I know, it's really 100% translatable in system f
02:33:12 <mux> they say that in the paper at least :-)
02:33:28 <mux> I can't pretend to understand that translation though
02:34:09 <quicksilver> dmwit: being translatable into system F doesn't make it 'just a preprocessor'
02:34:10 <dmwit> These papers have some big names on them.
02:34:21 <quicksilver> dmwit: the point being that System F is strictly more powerful than haskell
02:34:35 <quicksilver> dmwit: so adding new features which translate into System F can still be adding genuinely new stuff
02:34:59 <mux> I though the core language of haskell really was System-F, with coercions now, system Fc
02:35:15 <quicksilver> the core language is system Fc
02:35:17 <dmwit> Oh, I guess I don't know what System F is.  Sorry, I speak in ignorance.
02:35:23 <quicksilver> but the core language is more expressible than haskell
02:35:30 <mux> system F is just the second order lambda calculus
02:35:39 <mux> quicksilver: ah, yeah, okay.
02:35:43 <quicksilver> for example, the core language has applications at the type level
02:35:52 <quicksilver> (explicitly0
02:35:59 <quicksilver> and type level lambdas, etc
02:36:19 <quicksilver> actually I don't know if core does have type-level lambdas. But system Fc does
02:36:20 <mux> \X. \x:X. x
02:36:25 <mux> fear my system F skillz :D
02:36:31 <quicksilver> so core could have it if it wanted to
02:37:38 <quicksilver> oh actually, I might be wrong there
02:37:38 * quicksilver = a bit rusty
02:37:38 <quicksilver> do you need F\omega for type-level lambdas?
02:37:55 <mux> I don't even understand your question, heh.
02:38:19 <quicksilver> Suppose "State Int Bool"
02:38:31 <quicksilver> and I want to 'abstract' on the type of state, not the type of return
02:38:46 <quicksilver> I might right, in psuedocode \x -> State x Bool
02:38:52 <quicksilver> but here 'x' is a type, not a value
02:38:56 <mux> I understand the bit about type-level lambdas
02:39:06 <mux> but what is F\omega?
02:39:21 <quicksilver> It's a more powerful variant of system F than Fc
02:39:25 <mux> hmmm
02:39:25 <quicksilver> but I can't remember the hierarchy
02:39:30 <danigm> hello!
02:39:31 <mux> I should read about that
02:39:50 <mux> quicksilver: is it the lambda calculus with dependent typing?
02:40:34 <dmwit> heyo danigm!
02:40:44 <danigm> i have this problem, and i don't know how to solve "Instance of Fractional Int required for definition of porcentaje". I'm trying to show a simple division i*100/h where i and h are Int
02:40:44 <quicksilver> mux: maybe
02:40:52 <quicksilver> mux: I don't think so though
02:41:05 <mux> okay, I'll lookup papers on it, sounds interesting
02:41:14 <quicksilver> danigm: / is the fractional division
02:41:23 <quicksilver> danigm: `div` is the integer one if that's what you want
02:41:29 <danigm> oh
02:41:37 <quicksilver> :t (/)
02:41:37 <danigm> thanks
02:41:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:42:04 <mux> doing arithmetic is the only thing that I know is tedious sometimes in haskell
02:42:08 <dmwit> danigm: You may also be interested in fromIntegral or some such.
02:42:14 <dmwit> :t fromIntegral
02:42:19 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:42:24 <quicksilver> I'm not sure why (/) doesn't have the type b -> b -> a, for any Num b
02:42:39 <mux> there are talks on refactoring the numeric type classes
02:42:41 <quicksilver> :t (+)
02:42:45 <lambdabot> forall a. (Num a) => a -> a -> a
02:42:46 <mux> maybe they can solve those problems
02:43:05 <mux> also, implicit coercions might be useful sometimes
02:43:14 <mux> like if I want to add an Int to, say a Double
02:43:27 <danigm> div works ok
02:44:02 <mux> @quote
02:44:03 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
02:44:25 <quicksilver> that's interesting
02:44:30 <quicksilver> I didn't know Havoc was a haskell fan
02:45:16 <_roconnor> @hoogle comonad
02:45:16 <lambdabot> No matches found
02:45:24 <dcoutts_> quicksilver: I've tried to get him interested in Gtk2Hs, not much luck, he's a busy man.
02:45:33 <quicksilver> mux: but you can get implicit coercions
02:45:41 <quicksilver> mux: that's the whole point of the Num stuff, isn't it?
02:46:11 <mux> can you?
02:46:16 <mux> > 1 + 2.3
02:46:16 <quicksilver> yes
02:46:24 <lambdabot>  3.3
02:46:25 <mux> > (1 :: Int) + 2.3
02:46:33 <lambdabot>   add an instance declaration for (Fractional Int)
02:46:36 <mux> see
02:46:37 <quicksilver> they chose to give (+) a type which doesn't permit that
02:46:48 <quicksilver> you could imagine a (+) of type a -> b -> c
02:46:53 <mux> yeah, I've heard it is a choice
02:46:55 <quicksilver> with suitable constraints on all
02:47:00 <mux> and also because doing otherwise would imply problems
02:47:03 <quicksilver> my point is, implicity coercions exist and they work
02:47:10 <quicksilver> it just happens that (+) isn't using them
02:47:14 <mux> yes, right
02:47:24 <mux> I didn't mean to imply that there are no implicit coercions at all
02:47:27 <quicksilver> for reasons of its own
02:47:42 <quicksilver> e.g. if I newtype Interval = Interval Int
02:47:45 <roconnor> isn't that more of a parsing thing than an implicit coercion?
02:47:46 <quicksilver> and derive Num
02:48:01 <quicksilver> my whole intention was that Intervals not be able to be aded to normal numbers
02:48:09 <quicksilver> (i.e. something liek a 'units') system
02:48:26 <quicksilver> for this to work, you need (+) to force the same type on both its arguments
02:48:40 <quicksilver> a putative different (+) which coerced its arguments would be different
02:48:50 <mux> right, it would be annoying if you couldn't have this restriction when you want to
02:48:56 <mux> .+ ? :-)
02:50:05 * quicksilver nods
02:50:08 <quicksilver> roconnor: no
02:50:21 <quicksilver> roconnor: muxes point is that sometimes he wants to be able to add Ints to Doubles
02:50:33 <quicksilver> roconnor: my point is that it's possible to imagine a (+) which supports that
02:50:40 <quicksilver> roconnor: it's just the the one we have, doesn't
02:50:58 <mux> would having such a (+) imply undecidable type inference?
02:51:03 <mux> I seem to remember reading that
02:51:14 <mux> it's okay if all what's needed are a few type annotations here and there, though
02:51:23 <quicksilver> not necessarily
02:51:31 <quicksilver> I mean, no worse than we're already used to
02:51:34 <roconnor> ah okay
02:51:36 <mux> yeah, ok
02:51:42 <quicksilver> haskell already fails to infer types quite often with typeclasses
02:51:48 * mux nods
02:51:55 <quicksilver> but in some sense it's "right"
02:51:58 <mux> > minBound
02:52:02 <lambdabot>  Add a type signature
02:52:03 <roconnor> @pl \x -> not x && x
02:52:04 <lambdabot> (&&) =<< not
02:52:07 <mux> > minBound `asTypeOf` 1
02:52:08 <quicksilver> i.e. when it can't infer that is because there is genuine ambiguity there
02:52:15 <lambdabot>  Add a type signature
02:52:18 <mux> heh
02:52:23 <mux> I thought it would default to Int here
02:52:25 * mux shrugs
02:52:29 <mux> > minBound :: Int
02:52:34 <quicksilver> > minBound `asTypeOf` True
02:52:41 <lambdabot>  -2147483648
02:52:44 <lambdabot>  False
02:52:45 <mux> LB looks quite slow today
02:52:48 * quicksilver nods
02:52:50 <quicksilver> very very slow
02:52:54 <quicksilver> no idea why
02:53:45 <LoganCapaldo> > minBound `asTypeOf` IO
02:53:52 <lambdabot>   Not in scope: data constructor `IO'
02:54:02 <LoganCapaldo> mwhaahahahaha
02:54:03 <mux> now that's an interesting concept
02:54:45 <quicksilver> not well-kinded though
02:54:48 <dmwit> ?instances Bounded
02:54:49 <quicksilver> IO isn't a type
02:54:50 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
02:55:13 <dmwit> > minBound `asTypeOf` print 3
02:55:16 <dmwit> ;-)
02:55:23 <lambdabot>   add an instance declaration for (Bounded (IO ()))
02:55:43 <dmwit> Even putting a type on the right side isn't well-kinded, you need a value.
02:57:34 <LoganCapaldo> You're too kind
02:58:07 <quicksilver> my mate jez, he's well kind and stuff
02:58:33 <roconnor> @hoogle xort
02:58:34 <lambdabot> No matches found
02:58:34 <roconnor> @hoogle xor
02:58:35 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
02:59:26 <quicksilver> > 'A' xor '@'
02:59:32 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
02:59:33 <quicksilver> > 'A' `xor` '@'
02:59:40 <lambdabot>   add an instance declaration for (Bits Char)
02:59:40 <lambdabot>     In the expression: 'A' `xor...
02:59:50 <quicksilver> ? no instance for Bits Char?
02:59:52 <quicksilver> hmph
03:00:12 <Baughn> > (Char.ord 'A') `xor` (Char.org '@')
03:00:19 <lambdabot>   Not in scope: `Char.org'
03:00:23 <Baughn> > (Char.ord 'A') `xor` (Char.ord '@')
03:00:33 <Baughn> @hoogle Int -> Char
03:00:35 <lambdabot> Char.chr :: Int -> Char
03:00:35 <lambdabot> Char.intToDigit :: Int -> Char
03:00:35 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
03:00:36 <lambdabot>  1
03:00:43 <Baughn> ..1? *1*?
03:00:54 <quicksilver> yup
03:01:00 <quicksilver> '@' is 'A' minus 1, in fact
03:01:03 <Baughn> Hmm. Well, at least the instance should be easy to write.
03:01:05 <quicksilver> they are the same in every other bit
03:01:19 <LoganCapaldo> > ord 'A' `xor` ord '@'
03:01:24 <lambdabot>  1
03:01:29 <Baughn> map Char.chr [20..]
03:01:29 <LoganCapaldo> too much typing
03:01:33 <Baughn> > map Char.chr [20..]
03:01:48 <lambdabot>  "\DC4\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>...
03:01:59 <mux> > filter isPrint $ map chr [1 .. maxBound]
03:02:00 <Baughn> Ah. This seems familiar.
03:02:09 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
03:02:10 <Baughn> Somehow I thought unicode would have a different setup..
03:02:14 <Baughn> > chr 2000
03:02:29 <lambdabot>  '\2000'
03:02:49 <mux> > filter isPrint . map chr . enumFrom 1
03:02:57 <lambdabot>  Couldn't match expected type `a -> [Int]'
03:03:32 <quicksilver> Baughn: unicode coincides with ascii on the first 126 or 127 places
03:03:39 <mux> > filter isPrint . map chr . enumFrom $ 1
03:03:51 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
03:04:01 <mux> quicksilver: you mean utf-8
03:04:01 <raxas_> I doubt lambdabot will pass unicode to irc protocol. try it local
03:04:02 <LoganCapaldo> If my understanding is correct, while the report specifies unicode, I don't think ghc actually does unicodedly beyond storing chars as ucs4 (or something like that)
03:04:05 <mux> not quite the same thing as unicode
03:04:07 <Baughn> quicksilver: I suppose that's the pragmatic thing to do
03:04:20 <quicksilver> mux: but it's true of unicode too, is it not?
03:04:30 <Baughn> mux: Lambdabot certainly seems to think so
03:04:39 <earthy> uhm, unicode code points do coincide with ascii code points of the same number for the first, say 127 characters
03:04:50 <mux> I think unicode is just a character set standard
03:04:57 <mux> it's not a character representation
03:05:01 <mux> so you can't say that of unicode
03:05:13 <mux> there are various representations for unicode
03:05:14 <Baughn> mux: Unicode certainly does number characters
03:05:18 <mux> utf-8 is one of those
03:05:34 <mux> Baughn: yes, but it doesn't say how to represent those characters
03:05:51 <Baughn> mux: True, but Char.chr doesn't care how you represent them
03:05:53 <quicksilver> well, by 'the first 127' I mean \U0000 to \U0099
03:06:00 <quicksilver> erm
03:06:03 <quicksilver> 79 there at the end
03:06:22 <mux> people keep on confusing character set standards and encoding standards
03:06:38 <quicksilver> mux: but unicode does number the characters it defines
03:06:40 <raxas_> people keep confusing irc and console
03:06:47 <mux> quicksilver: those numbers are just abstract
03:06:51 <quicksilver> mux: and, therefore, my comment about the first 127 makes sense
03:06:59 <mux> no, it doesn't, really
03:06:59 <quicksilver> mux: *shrug* it's still 0 to 127
03:07:03 <quicksilver> mux: and it still coincides
03:07:05 <Baughn> mux: Those numbers are what Char.chr uses for input, which was my original point
03:07:22 <mux> quicksilver: your comment only applies to utf-8
03:07:22 <Baughn> mux: They also coincide with the first 128 characters in utf-8
03:07:48 <mux> I could very well have an encoding that represent some character X whose unicode number is 12345 with a byte containing 54321
03:07:57 <quicksilver> mux: no
03:08:05 <quicksilver> mux: my comment applies to the unicode NUMBERS
03:08:21 <mux> yes, and they don't mean anything with respect to encoding
03:08:30 <quicksilver> mux: the first 127 unicode numbers correspond to the first 127 char of ascii
03:08:32 <mux> obviously, in practice, they do
03:08:38 <mux> quicksilver: yes
03:08:42 <mux> that I agree with
03:08:47 <mux> in some way
03:08:49 <earthy> good. that is precisely the point he was trying to make ;)
03:08:49 <quicksilver> and, as it happens in most of the common encodings, thos numbers are mapped as you would expect
03:08:52 <mux> actually, the crux of the problem is
03:09:03 <mux> when you mean they coincide
03:09:07 <mux> do you mean their encoding coincide?
03:09:08 <earthy> is there an ebcdic encoding of unicode?
03:09:10 <quicksilver> certainly they are in UCS32, UCS16 and UTF8
03:09:14 <earthy> no, the code points coincide
03:09:14 <mux> if so you can't tell that about unicode
03:09:19 <mux> but about specific encoding
03:09:37 <quicksilver> Unicode numbers happen to map in an EXTREMELY simple way to the common encodings
03:09:41 <quicksilver> especially on the first 127
03:09:42 <mux> quicksilver: yes, in practice, of course, the unicde numbers are "reused" in the encodings
03:09:50 <quicksilver> so what I said was perfectly clear and also accurate
03:09:52 <mux> which makes most sense
03:09:59 <earthy> ASCII also is about both which set of characters and which numbers to give them
03:10:04 <mux> well, see what I just said
03:10:14 <mux> it depends on the sense you put to 'coincide' here
03:10:29 * earthy smells trollfeet
03:10:30 <quicksilver> < quicksilver> Baughn: unicode coincides with ascii on the first 126 or  127 places
03:10:36 <quicksilver> is what I said
03:10:40 <quicksilver> and I stand by it
03:10:41 <mux> that's not right
03:10:44 <mux> unicde != ascii
03:10:49 <mux> your sentence doesn't even typecheck :-)
03:10:56 <earthy> how is
03:10:57 <quicksilver> it's english, not haskell
03:10:59 <LoganCapaldo> decoding :: Bytestream -> [Codepoints], encoding :: [Codepoints] -> Bytestream :)
03:11:01 <mux> you're talking character set standards on the LHS and encoding on the RHS :-P
03:11:02 <earthy> 'coincide' an instance of 'Eq'?
03:11:03 <quicksilver> certain conversions are understood
03:11:13 <quicksilver> ASCII is a numbering system
03:11:16 <quicksilver> unicode is a numbering system
03:11:20 <mux> ASCII is an encoding
03:11:23 <quicksilver> the two numbering systems coincide
03:11:26 <mux> oh well
03:11:28 <earthy> ASCII is *not* just an encoding
03:11:32 <quicksilver> ASCII is also a numbering system
03:11:35 * earthy nods
03:11:38 <quicksilver> 'A' gets the number 64
03:11:39 <mux> earthy: yes, but UNICODE is not at all an encoding
03:11:40 <quicksilver> that's a numbering system!
03:11:44 <mux> so you can't say that
03:11:47 <earthy> and a selection of which characters to define
03:11:49 <quicksilver> a numbering system gives numbers to thing
03:11:50 <quicksilver> s
03:11:58 <earthy> mux: ever heard of duck typing?
03:12:05 <earthy> (or ebcdic for that matter?)
03:12:21 <mux> oh well, I think my point is valid and quite clear, but whatever :-)
03:12:34 <earthy> your point is that unicode does not specify an encoding
03:12:38 <earthy> that is quite well understood
03:12:43 <quicksilver> by all of us
03:12:50 <quicksilver> and had no particular relevance to the comment I made
03:12:54 <earthy> however, that does not invalidate quicksilver's remark. :)
03:12:54 <quicksilver> which was about numbering systems
03:12:55 <quicksilver> and was true
03:13:04 <quicksilver> and was well understood by everyone except apparently you
03:13:16 <mux> it does, depending on the sense you attach to 'coincide' but whatever
03:13:22 <mux> I've already said that
03:13:31 <mux> it was just a remark, and a valid one me thinks
03:13:43 * earthy nods
03:13:50 <earthy> it does depend on the meaning you give to 'coincide'
03:13:55 <quicksilver> if in doubt, you may assume that the 'sense' I'm attaching to a 'word' is the 'obvious' sense which makes the sentence ture
03:13:56 <mux> ah, finally, thanks.
03:13:58 <quicksilver> true
03:14:07 <earthy> if you mean 'coincide in the encoding', then you are absolutely right
03:14:09 <quicksilver> rather than assuming that I have chosen a sense which makes my statement false :)
03:14:10 <mux> I think we can stop at this pointt
03:14:15 <earthy> I just took qs to mean 'coincide in code points'
03:14:17 <mux> earthy: that's how I understood it initially
03:14:23 <mux> quicksilver: don't assume I'm being mean
03:14:28 <mux> it would be just wrong
03:14:33 <mux> I'm not trying to nitpick you here
03:14:38 <earthy> but communication is hard :)
03:14:46 <mux> I initially attached the "encoding" sense to your sentence, that's all
03:14:56 <Baughn> ..this is a rather long discussion just to establish that Char.chr does, in fact, use ASCII-like input for 0-127
03:15:01 <mux> because one remarkable feature of UTF-8 is that it's backwards compatible for ASCII
03:15:06 <mux> and I though you were talking about that
03:15:13 <quicksilver> Char isn't UTF8, though
03:15:21 <quicksilver> Char is, I think, supposed to be UCS-4
03:15:29 <Baughn> Doesn't matter what it is
03:15:30 <earthy> baughn: Char.chr does not, in fact, have anything to do with UTF or Unicode, in GHC, IIRC
03:15:31 <quicksilver> although there is little support arounf for using it that way
03:15:44 <quicksilver> > maxBound :: Char
03:15:51 <lambdabot>  '\1114111'
03:15:59 <quicksilver> is that UCS-4's max?
03:16:15 <earthy> could well be
03:16:17 <Baughn> earthy: Then what is it? I assumed it took unicode point numbers as input
03:16:17 <LoganCapaldo> > ord $ maxBound :: Char -- should be 4b
03:16:18 <earthy> looks sane at least
03:16:23 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
03:16:28 <LoganCapaldo> err
03:16:34 <quicksilver> > ord maxBound
03:16:38 <earthy> baughn: I seem to recall it's still slightly ill-defined
03:16:48 <lambdabot>  1114111
03:17:00 <quicksilver> well in the context of abstract types
03:17:01 <Baughn> earthy: Haskell'98 specifies unicode, does it not?
03:17:06 <quicksilver> clearly the compiler can choose how to store it
03:17:14 <quicksilver> but what I certainly mean is that Char is supposed to be a 'single character'
03:17:16 <LoganCapaldo> acutally I guess it shouldn't be 4b
03:17:17 <earthy> that's exactly where it's ill defined. :)
03:17:23 <LoganCapaldo> it should be the actual highest code point
03:17:44 <quicksilver> and it's supposed to be able to store any (most?) unicode chars
03:17:44 <Baughn> earthy: Haskell'98', then?
03:17:50 <quicksilver> but it's also an Enum
03:18:00 <quicksilver> and so its Enum instance rather suggests an encoding behind the scenes :)
03:18:03 <earthy> baughn: checking as we speak
03:18:07 <quicksilver> and I was guessing at UCS-4
03:18:16 <Baughn> quicksilver: Probably can; that's not very hard. But what of toLower?
03:18:20 <LoganCapaldo> I see to recall hearing UCS-4 in here before
03:18:33 <LoganCapaldo> s/see/seem
03:18:35 <quicksilver> Baughn: toLower is supposed to 'do the right thing' with unicode character properties
03:18:40 <quicksilver> Baughn: but in practice it may well not
03:18:49 <roconnor> @pl \l -> zip3 l (tail l) (tail (tail l))
03:18:49 <lambdabot> ap (ap zip3 tail) (tail . tail)
03:18:53 <Baughn> > toLower 'Ã˜'
03:18:54 <lambdabot>  Improperly terminated character constant
03:19:15 <Baughn> I see what you mean.
03:19:16 <earthy> baughn: the problem is that 'Char' should represent Unicode characters
03:19:17 <quicksilver> Baughn: you can't get a unicode char into lambdabot that way, I'm afraid
03:19:25 <quicksilver> Baughn: it doesn't have a unicode lexer
03:19:32 <earthy> according to the Haskell '98 report
03:19:33 <quicksilver> Baughn: you'll have to use 'chr' to get the cahr in
03:19:36 <Baughn> > chr 247
03:19:40 <lambdabot>  '\247'
03:20:33 <quicksilver> looking at the source of 'isLower'
03:20:36 <quicksilver> that is unicode-sane
03:20:56 <earthy> however, GHC does not specify exactly how chr interprets it's argument as a Unicode code point
03:21:06 <roconnor> which debian package has Control.Monad.Reader?
03:21:14 <quicksilver> roconnor: mtl
03:21:23 <quicksilver> roconnor: well, ghc-mtl-dev or whatever it's called
03:21:39 <Baughn> > toLower (chr 0xc5)
03:21:39 <quicksilver> but I don't see the source to toLower
03:21:44 <lambdabot>  '\229'
03:21:50 <int-e> @src toLower
03:21:50 <lambdabot> Source not found. You speak an infinite deal of nothing
03:21:51 <quicksilver> looks like it might be in GHC.Unicode
03:22:12 <Baughn> Well, I see it works with /my/ letters at least
03:22:13 <int-e> oh indeed
03:22:18 <araujo> morning
03:22:27 <int-e> toLower c = chr (fromIntegral (towlower (fromIntegral (ord c))))
03:23:16 <quicksilver> int-e: and what's towlower/
03:23:18 <int-e> and towlower is u_towlower from ... WCsubst.h?
03:23:20 <quicksilver> ah
03:23:23 <int-e> a foreign call.
03:24:06 <nominolo> hm, is there a way to draw Gtk widgets inside a OpenGL widget in gtk2hs?
03:24:47 <quicksilver> I think the enumeration is probably actually the unicode code point, then
03:25:00 <quicksilver> I.e. it's "unicode numbers" rather than any particular encoding
03:25:09 <int-e> nominolo: does gtk+ even support that?
03:25:20 <quicksilver> in practice if it's using the wc stuff then it's UCS-4, though, behind the scenes
03:26:15 <nominolo> int-e: i'm looking
03:27:44 <roconnor> let g x = let y = (x++[False]) in [(a<b&&c)||(b/=c)|(a,b,c)<-zip3 (False:False:y) (False:y) y] in iterate g [True]
03:27:49 <roconnor> > let g x = let y = (x++[False]) in [(a<b&&c)||(b/=c)|(a,b,c)<-zip3 (False:False:y) (False:y) y] in iterate g [True]
03:27:58 <lambdabot>  [[True],[True,True],[True,True,True],[True,True,False,True],[True,True,True,...
03:28:31 <nominolo> int-e: hm, seems i just have to write a wrapper for glTexImage2D()
03:28:51 <nominolo> then i can render to some bitmap and use that as an OpenGL texture
03:29:28 <roconnor> > let g x = let y = (x++[False]) in [(a<b&&c)||(b/=c)|(a,b,c)<-zip3 (False:False:y) (False:y) y] in map (map (\x -> if x then '1' else '0')) $ iterate g [True]
03:29:38 <lambdabot>  ["1","11","111","1101","11111","110001","1110011","11010111","111111101","11...
03:29:54 <Baughn> ..I'd kinda like to rewrite ghc to use utf-8 or utf-16 internally. Any particular reasons not to do that?
03:30:17 <LoganCapaldo> Baughn: it would be a lot of work?
03:30:33 <quicksilver> Baughn: any reason *to* do that?
03:31:04 <Baughn> quicksilver: Space considerations. UTF-16, in particular, almost never needs to use more than 2 bytes in reality
03:31:09 <quicksilver> Baughn: using wc internally lets it use all the existing C-language support for unicode properties and stuff whilst being reasonably fast
03:31:23 <int-e> > map (show . fromEnum) [False..]
03:31:23 <lambdabot>  Parse error
03:31:24 <ToRA> nominolo: are you trying to load arbitary images (from files) into gl textures, or something else?
03:31:26 <quicksilver> Baughn: it's a minority of programs that use vast string constants
03:31:34 <quicksilver> Baughn: those programs can use CompactString
03:32:11 <int-e> > map (show . fromEnum) [False ..]
03:32:14 <lambdabot>  ["0","1"]
03:32:16 <int-e> subtle
03:32:35 <quicksilver> (in fact the overhead of the fact that strings are lists vastly dwards the overhead of the fact that they are 32bit chars)
03:34:31 <roconnor> > let g x = let y = (x++[False]) in [(a<b&&c)||(b/=c)|(a,b,c)<-zip3 (False:False:y) (False:y) y] in map (concatMap (show . fromEnum)) $ iterate g [True]
03:34:46 <lambdabot>  thread killed
03:36:11 <roconnor> > concatMap (show . fromEnum) [False ..]
03:36:26 <lambdabot>  "01"
03:36:44 <ndm> does GHC transform seq into case in Core?
03:37:13 <Igel> hi there,
03:37:16 <int-e> that wouldn't work for functions, right?
03:37:23 <Igel> is there a good html-parser in haskell?
03:37:55 <ndm> int-e: no, but it does seem that it has - maybe because it knows it got data
03:38:26 <nominolo> ToRA: sort of
03:39:23 <ejt> what's the incantation to list package names ?  (for adding to a cabal Build-Dependencies field)
03:39:28 <int-e> ndm: oh wait. in Core that works actually - case is defined to evaluate to WHNF there
03:39:38 <nominolo> ToRA: not from files though.  more like a OpenGL-based windowmanager
03:39:47 <ToRA> nominolo: ah ok
03:39:55 <ndm> int-e: i know, i was just wondering if it was an optimisation, or a translation rule or what
03:40:07 <nominolo> ToRA: though, window mangager is not the right word
03:40:24 <ToRA> nominolo: oh...for a minute there i thought you were doing some crazy xmonad extension...
03:40:38 <int-e> ndm: I mean, even  case x of x' -> ...  will evaluate x in Core. At least if I remember that correctly.
03:40:59 <ndm> int-e: yes, it does
03:41:46 <nominolo> ToRA: it's more of an experiment
03:41:58 <int-e> hmm. I should reread some of the relevant papers. My memory is hazy.
03:42:25 <Si> can anyone tell me what the error "Main: internal error: stg_ap_v_ret" means wrt. hs-plugins-1.0-rc0 with GHC 6.4.2?
03:43:56 <malcolmw> Igel: HaXml has an error-correcting HTML parser, and I believe HXT has one too
03:44:21 <Igel> thank you malcolmw :)
03:45:03 <dozer> hi
03:45:16 <ejt> hello
03:45:28 <dozer> is there a haskell way to achieve something similar to java/c# annotations?
03:45:53 <dozer> would it just be a class with a member that returns a class-wide constant?
03:46:32 <ejt> what are you trying to do ?
03:46:57 <araujo> http://blogs.nubgames.com/code/?p=23
03:46:59 <lambdabot> Title: Nub Games » Pragmatic Haskell
03:48:05 <dozer> ejt: good question - I had a clear use-case yesterday evening, but that was in the pub
03:48:19 <LoganCapaldo> heh
03:48:49 <ejt> :)
03:49:57 <dozer> so, in Java, I can annotate a method with e.g. @WebServiceName("someName"), and then at run-time, if I get the method by introspection retrieve "someName"
03:50:18 <dozer> in haskell would I make the function inhabit a class with a method to retrieve "someName"?
03:50:49 <ejt> you certainly could do
03:51:00 <quicksilver> that's a very 'java-way' to do something, though
03:51:10 <ejt> I find translating C++/Java into haskell doesn't really work though
03:51:27 <quicksilver> if you're doing something like that, I'd be more likely to store all your 'methods' in a nice big dispatch table
03:51:41 <quicksilver> since you are defining the dispatch table yourself, you can put any kind of metadata you want in there
03:51:53 <quicksilver> so you can can 'annotation-like' fields of various kinds
03:52:37 <LoganCapaldo> type Service = Request -> Response; type Table = Data.Map String Service; lookup "someName" ... maybe
03:54:08 <quicksilver> that kind of thing is possible to
03:54:09 <quicksilver> too
03:54:22 <quicksilver> there isn't much difference between packagin up the data in one big table
03:54:26 <quicksilver> or separating it out
03:54:39 <LoganCapaldo> Course I don't know if you look up the service by the name or if you ask the service what its name is
03:54:53 <quicksilver> (that is ([a],[b]) is isomorphic to [(a,b)] if the lists are equal length)
03:55:42 <dozer> ok, thanks
03:57:12 <LoganCapaldo> it would be interesting if the Map was its own lookup function (just to go off on a tangent)
03:57:50 <LoganCapaldo> let foo = fromList [("a",1), ("b",2)] in case foo "a" of Just n -> ...
03:58:36 <LoganCapaldo> Although I supose that would make the type inferer cry
03:58:53 <LoganCapaldo> OH!
03:59:01 <quicksilver> LoganCapaldo: what you're saying is you want a map to actually have type Key -> Value
03:59:11 <quicksilver> LoganCapaldo: you can do that, but it makes very inefficient maps :)
03:59:21 <LoganCapaldo> instance Arrow Data.Map ... ??
03:59:32 <LoganCapaldo> arr x = lookup
03:59:51 <LoganCapaldo> That might have some possibilties
04:00:10 <quicksilver> you could also make the map-return ing functions overloaded
04:00:26 <quicksilver> so they can either return the 'full data structure' version or the 'function' version
04:00:33 <LoganCapaldo> quicksilver: ooo yeah that's cool
04:00:43 <quicksilver> I think you'd find it was a bit ugly in places :)
04:00:52 <quicksilver> it might make for some cute small examples though
04:01:12 <quicksilver> :t Data.Map.lookup
04:01:12 <LoganCapaldo> yeah
04:01:15 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
04:01:45 <quicksilver> note that you could use "let foo = flip lookup (fromList ...) in case foo "a" ....
04:01:49 <quicksilver> that would do what you want
04:01:56 <LoganCapaldo> mmm hmm
04:02:55 <LoganCapaldo> My use case was being able to switch from some lookup function that started becoming a giant case statement and refactor it to a map w/o having to change the rest of the code
04:03:39 <LoganCapaldo> although I guess you just do what you just did
04:04:06 <LoganCapaldo> heh
04:04:15 <LoganCapaldo> I seem to be trying to invent problems
04:04:37 <quicksilver> all helps the understanding process
04:04:50 <quicksilver> I don't much like flip actually
04:05:12 <quicksilver> I'd be more likely to do let foo x = lookup x (fromList ...) ...
04:05:15 <quicksilver> same difference though
04:05:38 <LoganCapaldo> although the concept of data structure w/ a lookup like an array or map being an instance of arrow seems liek it could be useful. For what I don't know
04:06:24 <quicksilver> intuitively it sounds like it, yes
04:07:15 <triplah_> can anyone tell me what multiplying a matrix by a vector means?
04:07:37 <triplah_> W x    matrix W, vector x
04:08:25 <quicksilver> triplah_: http://en.wikipedia.org/wiki/Matrix_multiplication
04:08:26 <lambdabot> Title: Matrix multiplication - Wikipedia, the free encyclopedia
04:09:01 <quicksilver> (it's a vector whose elements are the dot products between the original vector and the rows of W)
04:09:08 <int-e> consider the vector to be a m x 1 matrix.
04:09:15 <int-e> (for appropriate m)
04:09:17 <triplah_> quicksilver: ahh brilliant, thanks
04:09:23 <triplah_> int-e: right, that makes sense
04:09:35 <LoganCapaldo> and its fun!
04:10:42 <LoganCapaldo> [[ 0 0 0 1] [0 0 1 0] [0 1 0 0] [1 0 0 0]] times [1 2 3 4] is [4 3 2 1]
04:10:49 <quicksilver> FSOV 'fun'
04:10:54 <LoganCapaldo> reverse by multiplying, whee
04:12:13 <quicksilver> > map (sum . zipWith (*) [1,2,3,4]) [[0,0,0,1],[0,0,1,0],[0,1,0,0],[1,0,0,0]]
04:12:24 <lambdabot>  [4,3,2,1]
04:13:04 <quicksilver> @pl \w x -> map (sum . zipWith (*) x) w
04:13:05 <lambdabot> flip (map . (sum .) . zipWith (*))
04:15:54 <LoganCapaldo> FSOV?
04:18:06 <quicksilver> LoganCapaldo: For some values of
04:18:25 <LoganCapaldo> ah
04:18:40 <LoganCapaldo> FSVO or For SOme Values of ?
04:19:09 <LoganCapaldo> hey, I think you just insulted me! :)
04:19:33 <quicksilver> :)
04:19:49 <LoganCapaldo> So, I have a long bus ride today
04:19:57 <LoganCapaldo> what papers should I print to read?
04:20:00 <LoganCapaldo> Opinions?
04:20:03 <LoganCapaldo> Suggestions?
04:20:38 <quicksilver> the onion
04:21:07 <nominolo> LoganCapaldo: Modular Lazy Search
04:21:14 <nominolo> TAPL
04:21:20 <nominolo> ATTAPL
04:21:32 <ejt> LoganCapaldo: 'generalising monads to arrows' Hughes
04:22:07 <dcoutts_> nominolo: it depends on what you want to do with the gtk widget in the opengl widget
04:22:11 <LoganCapaldo> nominolo: I hought TAPL / ATTAPL were books? Books I do not have time or money to purchase today
04:23:13 <dcoutts_> nominolo: you can overlay a widget over an opengl area, but if you want to put the widget inside the 3D scene and transform it etc, that's harder.
04:23:46 <nominolo> dcoutts_: as a start i just want to want to just use gtk-drawn pictures as textures
04:23:50 <dcoutts_> nominolo: I don't think gtk currently supports rendering widgets to off-screen drawables, though I believe upcoming gtk versions will allow that.
04:24:22 <dcoutts_> nominolo: what kind of gtk-drawn picture? like something drawn with gdk or cairo drawing primitives? that should be easy.
04:24:52 <nominolo> yep
04:24:55 <nominolo> like: http://cairographics.org/OpenGL/
04:24:56 <dcoutts_> nominolo: just draw to an off-screen GdkDrawable and then turn that into an OpenGL texture
04:24:56 <lambdabot> Title: cairo - OpenGL
04:25:49 <nominolo> dcoutts_: exacly that last part is interesting to me.  The Gtk.OpenGL isn't that well-documented ;)
04:26:22 <nominolo> dcoutts_: glPixmapNew?
04:27:22 <dcoutts_> nominolo: you'd want renderWithDrawable to render to a Pixmap or a GLPixmap
04:29:36 <ndm> dcoutts_ - as the GHC Core optimising guru...
04:29:54 <ndm> dcoutts_ - http://hpaste.org/1862
04:30:18 <nominolo> dcoutts_: ok, thanks, I'll figure it out
04:30:44 <ndm> dcoutts_ - as far as i can see, eliminating v2_aVe would be handy, and if the FFI call didn't get FFI wrapped, then immediately unwrapped that would be good too - but no idea how to do that without CAF issues
04:32:12 <ndm> (i am just trying to learn from the master ;) )
04:32:32 <ndm> @karma+ GHC -- it really is very impressive at optimising
04:32:33 <lambdabot> GHC's karma raised to 2.
04:32:44 <dcoutts_> ndm: what did the FFI decl look like?
04:33:08 <ndm> dcoutts_: foreign import ccall safe "stdio.h getchar" getchar :: IO CInt
04:33:20 <dcoutts_> ndm: use unsafe
04:33:22 <ndm> if i remove the IO, then it CAF's the getchar, which isn't useful
04:33:44 <dcoutts_> foreign import ccall unsafe "stdio.h getchar" getchar :: IO CInt
04:34:10 <dcoutts_> ndm: and make sure that fii decl is in the same module as where you're using it
04:34:22 <ndm> dcoutts_ - it is, just benchmarking htat now..
04:34:34 <dcoutts_> ndm: otherwise the "stdio.h .." bit stops the ccall from being inlined across modules
04:34:59 <dcoutts_> ndm: since ghc does not track which header files are needed by c calls across module boundaries
04:35:23 <dcoutts_> ndm: if you want that, you have to supply the header differently, not in the ffi import.
04:35:32 * joelr1 is back
04:35:34 <ndm> dcoutts_ - fantastic, i'm now about 10% below C speed
04:35:58 <dcoutts_> ndm: compared to?
04:36:10 <joelr1> ndm: the speed of what? /apologies, missed the beginning of the conversation/
04:36:28 <ndm> joelr1: wc -c, my implementation in Haskell, with my super-optimiser is near C speed
04:36:38 <ndm> dcoutts_ - all working in a getchar() loop
04:37:05 <ejt> I thought dons had already acheived that with LazyBytestring ?
04:37:33 <dcoutts_> ndm: I mean how much did the unsafe buy you? it's now 10%, what did it used to be? 30% or what?
04:37:34 <ndm> ejt: this is with String = [Char]
04:37:46 <ndm> dcoutts_ - it bought me quite a lot, maybe 40% speed up
04:38:06 <ejt> ndm: !
04:57:12 <joelr1> ndm: super-optimizer? sounds awesome!
05:00:32 <ari> Lemmih: ping
05:01:06 <mux> http://blogs.msdn.com/hugunin/archive/2007/04/30/a-dynamic-language-runtime-dlr.aspx
05:01:09 <lambdabot> Title: Jim Hugunin's Thinking Dynamic : A Dynamic Language Runtime (DLR), http://tinyurl.com/3ckwho
05:01:10 <mux> sounds interesting
05:02:11 <ejt> I'm using haskells FFI stuff for the first time, does anyone know of a good explanation of how to unpack C structures ?
05:02:39 <mux> ejt: the best "explanation" I've found for now is some code from gtk2hs
05:02:51 <ejt> doesn't that use c2hs ?
05:02:53 <mux> yes
05:03:19 <mux> I think you'd have a hard time handling structs without c2hs
05:03:28 <ejt> ok, thx
05:03:42 <njbartlett> mux: yes DLR sounds interesting, I wonder if its any use in implementing Haskell in .NET
05:03:42 <mauke> what about hsc2hs?
05:05:11 <mux> ejt: http://darcs.haskell.org/gtk2hs/cairo/Graphics/Rendering/Cairo/Matrix.chs
05:05:14 <lambdabot> http://tinyurl.com/yxbpjc
05:05:33 <mux> ejt: the very first Storable instance in that file is quite enlightening
05:05:40 <mux> or at least it was to me
05:06:46 <ejt> downloading now thx
05:08:02 <osfameron> why would DLR be important to Haskell?  isn't Haskell largely static anyway ?
05:08:34 <njbartlett> osfameron: Yes, that's the conclusion I came to as well.
05:09:06 <njbartlett> It seems a shame that in both Java and .NET, the focus recently seems to be more on supporting toy languages like Ruby
05:09:34 <njbartlett> Eg still no tail calls in JVM
05:09:36 <osfameron> well, Ruby isn't a toy language.  "ruby" is a toy implementation
05:09:44 <mux> while I'm not a big fan of the dynamic language field, ruby isn't a toi language
05:09:50 <mux> yes
05:09:57 <mux> ruby2 is supposed to be vastly better though
05:10:05 <osfameron> does it exist already?
05:10:11 <mux> because as of now it's unbelievably slow
05:10:23 <mux> osfameron: there's ruby 1.9 already, it's supposed to be better
05:10:41 <mux> but I can't really tell, I only heard about it
05:10:41 <osfameron> I don't really follow it, it's one of those "If you program Perl you might like..." things
05:11:19 <ejt> I use Ruby a lot at work for scripting, it is surprisingly slow, but I don't need speed at that level
05:11:20 <Lemmih> ari: pong.
05:11:43 * mux is starting to get pissed at the constant roaring of helicopters in the sky
05:12:24 <lypanov> mux: shoot 'em
05:12:35 <Maddas> lypanov: Now *that* would be loud.
05:12:38 <mux> I wish I had enough firepower to do that
05:12:42 <lypanov> hehe
05:12:48 <quicksilver> Maddas: yes, but only for a short while
05:12:53 <quicksilver> Maddas: then it would be quiet again
05:12:56 <Maddas> yeah, you'd be deaf after that ;-)
05:13:01 <int-e> roconnor: btw, the &&c can be eliminated from that rule 110 implementation
05:13:04 <mux> they're making circles over the champs elysees
05:13:14 <mux> today is sarkozy's investiture in .fr...
05:13:26 <njbartlett> Is anybody still actively working on Haskell for .NET?
05:13:48 <ari> Lemmih: I'm using hs-plugins from darcs with ghc 6.6... it compiled but I'm having trouble with some stuff that depends on hs-plugins and don't yet know where the bug lies. I was told that you'd made hs-plugins compatible with ghc 6.6... is your code in http://www.cse.unsw.edu.au/~dons/code/hs-plugins?
05:13:49 <lambdabot> Title: Index of /~dons/code/hs-plugins
05:13:59 <osfameron> I also want to know if anyone is developing haskell for parrot...
05:14:32 <lypanov> mux: speed of iron* is pathetic anyway
05:14:43 <njbartlett> osfameron: Perl6 ;-)
05:14:57 <lypanov> oh!
05:14:58 <osfameron> harr! ;-)
05:15:11 <lypanov> mux: btw, just in case you hadn't seen, he actually have started blogging more info. so thanks for the link
05:15:16 <lypanov> s/have/has/
05:15:31 <Lemmih> ari: I believe so. However, my code isn't completely and only has enough fixes to pass through the testsuite. To my knowledge, hs-plugins still doesn't work with ghc-6.6.
05:16:19 * ari sees
05:17:43 <kombinator> Is there a standard function for generating unique identifiers, for instance unique ints?
05:18:25 <mux> the only standard thing I can think of are UUIDs
05:18:43 <mux> I don't know if haskell has an implementation for those
05:19:00 <mux> but they aren't really ints
05:19:08 <mux> % uuidgen                                                              ~
05:19:08 <mux> 7b8d39eb-03a7-11dc-9e89-0015c5bf1648
05:19:23 <quicksilver> maybe kombinator just wants successive numbers from 1
05:19:27 <quicksilver> as unique names
05:19:39 <mux> yeah, in that case UUIDs are useless :)
05:19:39 <kombinator> quicksilver: yes
05:20:00 <kombinator> quicksilver: don't have to be successive
05:20:14 <quicksilver> kombinator: unique supply is just a very simple state monad
05:20:27 <quicksilver> not sure if there is an example available as an easy library
05:20:39 <kombinator> I just want unique objects supporting (==) efficiently
05:21:11 <quicksilver> I'd use sequential Ints, personally
05:21:16 <quicksilver> easy to understand and debug
05:21:23 <quicksilver> (hide them under a newtype, sure)
05:21:26 <kombinator> quicksilver: right
05:22:14 <mux> an easy implementation is to use bitmaps, but that can only work if your id space isn't too big
05:22:50 <kombinator> quicksilver: but perhaps I would like to generate the ids in pure code as well...
05:23:41 <kombinator> I might try to do this using unsafePerformIO but could get hit by optimizations
05:23:48 <dons> SHAZAM!
05:23:48 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
05:23:51 <dons> as shapr would say.
05:24:22 <quicksilver> @type do { x <- get; put (x+1); return x }
05:24:25 <lambdabot> forall (t :: * -> *) t1. (Num t1, MonadState t1 t) => t t1
05:24:41 <quicksilver> kombinator: you don't need IO to use state, kombinator
05:24:52 <quicksilver> kombinator: the above is perfectly pure
05:25:07 <quicksilver> dons: welcome ack
05:25:14 <dons> ?uptime
05:25:14 <lambdabot> uptime: 9d 11h 3m 52s, longest uptime: 13d 18h 36m 21s
05:25:20 <dons> oh nice. the bot stayed up.
05:25:20 <quicksilver> dons: lambdabot is very slow at the moment. Lag problems?
05:25:21 <Syzygy-> Why on EARTH would you want to use unsafePerformIO anyway?
05:25:36 <quicksilver> > 1+2
05:25:40 <kombinator> quicksilver: I see, but I would need to thread the state monad, and as I'm working with arrows really a state arrow
05:25:45 <lambdabot>  3
05:25:56 <dons> quicksilver: ok. i'll have a look a bit later.
05:26:12 <quicksilver> kombinator: threading a monad isn't very hard, though. that's the whole point of monads, to enable you to thread stuff easily :)
05:26:47 <quicksilver> dons: maybe the machine is clogged up. You don't seem to have the same kind of lag that LB has
05:26:51 <kombinator> quicksilver: I guess I will start with an IO solution as I have IO all over the place anyway
05:27:06 <quicksilver> kombinator: why? my solution is much nicer than an IO one
05:27:09 <quicksilver> kombinator: and simpler
05:27:56 <kombinator> quicksilver: well, I already work with several arrow transformers and I would like not to add more
05:28:25 <quicksilver> sounds backwards to me, but it's your code
05:31:51 <kombinator> quicksilver: my code is already quite convoluted
05:38:42 <joelr1> bringert: any ideas re: that blog editing error?
05:39:44 <bringert> hi joelr1
05:42:06 <bringert> I was just looking at that
05:42:06 <joelr1> bringert: good day :-)
05:43:06 <bringert> joelr1: is it ok if I play around a bit? adding test entries etc?
05:43:26 <joelr1> bringert: sure but the same issues happened in my test install
05:43:29 <nominolo> dcoutts_: drawing with cairo on a GLWindow segfaults
05:47:09 <dcoutts_> nominolo: I think there's some synchronisation you're supposed to do between dawring to a gl surface via 2d and 3d methods
05:47:27 <dcoutts_> nominolo: but this will only give you an overlay anyway
05:47:52 <nominolo> dcoutts_: i'm now trying to draw to a pixmap and then somehow use this inside opengl
05:48:03 <dcoutts_> nominolo: and it might be better to draw to the Window of the GLWindow rather than the GLWindow directly, I don't quite trust the GtkGLExt GLWindow stuff
05:48:19 <dcoutts_> nominolo: yes, make a texture, that seems more robust
05:50:12 <dons> ?users
05:50:12 <lambdabot> Maximum users seen in #haskell: 336, currently: 308 (91.7%), active: 33 (10.7%)
05:59:54 <nominolo> dcoutts_: dies as well
06:00:08 <chessguy> 'morning haskellers
06:00:13 <dcoutts_> nominolo: hmm
06:00:20 <nominolo> dcoutts_: while creating the pixmap
06:00:23 <nominolo> !paste
06:00:23 <hpaste> Haskell paste bin: http://hpaste.org/
06:01:05 <quicksilver> Whilst that's a useful command, I'm surprised people find that URL hard to remember :P
06:01:18 <quicksilver> at least with my firefox I only have to type in 'hp' and it's guessed it
06:01:24 <quicksilver> many fewer characters than '!paste'
06:01:46 <osfameron> if you are on lots of irc channels you can sometimes forget which is which ?
06:01:59 <hpaste>  nominolo pasted "crashing gtk2hs + opengl + cairo" at http://hpaste.org/1865
06:02:11 <dcoutts_> nominolo: sorry, gotta go teach
06:02:29 <nominolo> dcoutts_: no problem
06:02:44 * nominolo has to go listen to someone teach
06:03:25 <osfameron> can anyone recommend a Computer Science degree that I can distance learn as a British citizen resident in Italy ?
06:03:53 <osfameron> I think OU becomes $$$stupid if you're not resident in UK, and in any case doesn't seem that interesting on the programming front
06:04:01 <osfameron> oops, I'll take it to -blah
06:12:21 <njbartlett> osfameron: How do they know you're not resident in the UK?
06:12:40 <osfameron> njbartlett: that's a good question.  But I think it's useful for me to *not* be resident, for tax purposes
06:12:50 <osfameron> if they later find out, then I could well be slightly buggered
06:13:16 <osfameron> I'm currently in the situation where gf is paying full council tax (cos I'm resident in UK) but I can't get other things sorted (because I'm not)
06:13:21 <osfameron> UK is, er, interesting like that
06:13:26 <njbartlett> Hmm I doubt the OU share their records with HMRC. But if you're being paranoid, then fair enough ;-)
06:18:04 <P4> Hi
06:18:29 <chessguy> hi P4
06:18:54 <P4> what is haskell dedicated to? i mean like perl is greate for playing with text strings, c is universal, php is dedicated for web, and haskell? :}
06:19:23 <norpan> haskell is dedicated to functional programming
06:19:36 <chessguy> purity, laziness, proper techniques of abstraction
06:19:37 <P4> oh...
06:19:51 <norpan> and elegance
06:20:00 <P4> is it good for beginners?
06:20:03 <njbartlett> P4, all of those languages are universal (possibly exception of PHP)
06:20:21 <norpan> haskell is good for beginners
06:20:24 <migraine> perl was really twisted into a univeral language
06:20:30 <LoganCapaldo> It's good for beginners in the sense that green vegetables are good for you :)
06:20:39 <Saizan> it's also very good for parallelization
06:20:50 * ddarius loves brocolli.
06:21:00 * LoganCapaldo likes brocolli
06:21:06 <migraine> its not good for seasoned C programmers... brought me to my knees
06:21:09 * LoganCapaldo can't stand brussel sprouts
06:21:26 <chessguy> migraine: it may not be good at first, but in the long run it will be
06:21:41 <migraine> yeah I toughed it out for 4 weeks or so and now I actually enjoy it
06:21:43 <njbartlett> Spinach is the One True Vegetable.
06:21:48 <migraine> although some concepts are still dim
06:22:15 <earthy> yummy, brussel sprouts
06:22:20 * malcolmw feels dim sometimes
06:22:46 <quicksilver> P4: haskell is good for writing programs which actually work
06:22:48 <ddarius> Brussel sprouts are good too.
06:22:50 <quicksilver> (as in, don't have bugs in)
06:23:08 <earthy> actually, haskell programs may still have bugs
06:23:15 <P4> oh that's whay, but isnt bugs connected to algorithms not implementation?
06:23:22 <malcolmw> yum, brussel sprouts with bugs in
06:23:23 <earthy> however, the occurence of said is *very* much lower
06:23:23 <migraine> well it can still have logic bugs...
06:23:31 <vincentk> but even green vegetables now and then have bugs in them
06:23:33 <quicksilver> I didn't say it guaranteed no bugs :)
06:23:36 <P4> :}
06:23:40 <quicksilver> I just said, that's waht it was good for
06:23:41 <araujo> P4, Haskell is very bad. It makes you hate other programing languages.
06:23:42 <quicksilver> i.e. it helps
06:23:46 <dons> earthy: yeah, Haskell + QuickCheck + ndm's 'catch' remove a pretty good portion, i've found
06:23:51 <araujo> So, please consider it until you get into it.
06:24:10 <P4> im just interested in new (for me) languages
06:24:12 <ndm> ESC/Haskell should remove the last ones floating around
06:24:15 <quicksilver> P4: large classes of bugs are cleared up by good, clear thinking about input and output types
06:24:17 <earthy> dons: quickcheck really really helps yeah. and catch simply mops up. ;
06:24:24 <dons> exactly.
06:24:30 <quicksilver> P4: and haskell gets you thinking clearly about your types
06:24:34 <ndm> once they are all done, Catch will be 100% automatic, QuickCheck gives you easy properties, ESC/Haskell gives you solid properties
06:24:43 <dons> in particular, catch helps reason about partial functions -- since it hates them soo much
06:24:49 <quicksilver> P4: whereas other languages encourage lazily designed data with inconsistencies
06:24:54 <ddarius> P4: Haskell will definitely be new to you.
06:25:14 <ddarius> Unlike anything you've ever programmed in before unless bizarrely you've programmed in Clean or Miranda or so.
06:25:31 * earthy doesn't think Clean is bizarre
06:25:41 <ddarius> earthy: I didn't say it was.
06:25:58 <earthy> (but I'm biased: I was taught Clean by its designers/implementors)
06:26:00 <vincentk> newbie question: class Ord key => GT map key | map -> key where   .... what does the "| map -> key" mean?
06:26:12 <ddarius> Clean is very similar to Haskell.
06:26:17 <mauke> oh, functional dependencies
06:26:25 <earthy> vincent: functional dependency. The type 'key' is uniquely defined by the type 'map'
06:26:44 <ddarius> I usually read map -> key as "map determines key"
06:26:52 <quicksilver> vincentk: any given 'map' type has a unique 'key' type associated with it
06:26:52 <earthy> so, while GT does have 2 type arguments, the first constrains the second
06:27:04 <P4> i've started to learn cpp in my university... if i pay some time to getting knowlegde about haskell would it helps me with undestanding cpp or not? (probably not?)
06:27:10 <vincentk> ok, thanks
06:27:16 <quicksilver> P4: initially it won't
06:27:27 <earthy> P4: C++ that is? yeah, it will help you understand C++ better
06:27:27 <quicksilver> P4: eventually knowing both will broaden your understanding
06:27:34 <LoganCapaldo> P4: Yes it would help
06:27:36 <earthy> but that's due to the contrast, really
06:27:41 <vincentk> i suppose googling for "functional dependency" will also help me further ;-) "| a -> b" did not turn up that much ;-)
06:27:42 <P4> ok thanks guys :}
06:27:53 <quicksilver> P4: but initially it will mean you are wrestling with more new stuff at once
06:27:59 <ddarius> If you get into the STL then it will certainly help.  It will certainly help you understand templates in general.
06:28:02 <malcolmw> cpp (the preprocessor) is a _very_ tiny language
06:28:04 <quicksilver> which may or may not be painful depending in your tolerance for such things
06:28:18 <quicksilver> malcolmw: I don't think that's what he meant, though :)
06:28:50 <P4> cpp i mean c++, i've not known cpp and c++ means different things ;P
06:28:56 <ddarius> vincentk: Functional dependencies come from relational database design, but I don't think many Haskellers realize/exploit that.
06:29:17 <vincentk> ;-)
06:30:09 <quicksilver> ddarius: it's not clear they're a very good match, though :)
06:31:20 <LoganCapaldo> P4: cpp is "C pre-processor". It's what handles things like #include and #define, etc.
06:31:57 <P4> yes yes, thanks for explaination
06:32:06 * P4 sorries about his english
06:32:07 <quicksilver> cpp was also an abbreviation for c++ though, I've seen it used in .cpp files long ago. .cc and .c++ won the battle for namespcace though
06:32:07 <vincentk> http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies ;-)
06:32:11 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac, http://tinyurl.com/32qu3g
06:32:43 <vincentk> btw, if a haskell.org web master is listening in:
06:32:44 <vincentk> http://programming.reddit.com/info/1qzjx/comments/c1r3ok
06:32:45 <lambdabot> Title: Pragmatic Haskell, a forthcoming book (reddit.com)
06:33:01 <vincentk> http://www.haskell.org/robots.txt
06:33:11 <vincentk> prohibits crawling of the current wiki
06:33:19 <vincentk> and indeed not much shows up in a google search
06:33:30 <vincentk> http://www.google.com/search?q=haskell+wiki
06:33:31 <lambdabot> Title: haskell wiki - Google Search
06:33:36 <quicksilver> vincentk: I'd noticed the symptoms of that
06:33:45 <quicksilver> vincentk: but not really understood why, or if it was deliberate
06:33:54 <vincentk> it might be
06:33:56 <quicksilver> vincentk: I think I mentioned it once or twice but no one took the bait
06:34:10 <quicksilver> well it's alsmost got to be deliberate :)
06:34:11 <vincentk> but then again, it might not -- in which case it would be severely harmful
06:34:21 <quicksilver> you can't really type Disallow: /haskellwiki/ by mistake
06:34:23 <quicksilver> but it does seem odd
06:34:42 <vincentk> any idea where one would report this?
06:34:47 <vincentk> haskell-cafe?
06:35:30 <quicksilver> Yes, I think so
06:35:56 <Saizan> it has been added because a not-identified crawler was killing the server following the many links in the wiki
06:35:57 <vincentk> will send a mail then, once i'm outside of this fine corporate firewall ;-)
06:36:21 <vincentk> ah
06:36:22 <vincentk> ok
06:36:32 <vincentk> so no reporting
06:37:14 <Saizan> last time i've seen a discussion on this they were searching a better solution ..
06:37:46 <Saizan> maybe if we complain enough it can be found earlier :)
06:38:40 <njbartlett> Saizan: It's not necessarily the Google crawler at fault. See http://eclipsewebmaster.blogspot.com/2007/05/dos-attacks-from-google-look-again.html
06:38:42 <lambdabot> Title: A WebMaster's view of Eclipse.org: DoS attacks from Google? Look again, http://tinyurl.com/ypdn3r
06:39:44 <Saizan> yeah, probably, can you allow a specific crawler in robots.txt? i'm not an expert
06:40:03 <vincentk> the robots.txt in question contains:
06:40:04 <vincentk> contains
06:40:04 <vincentk> User-agent: *
06:40:04 <vincentk> Disallow: /haskellwiki/
06:40:13 <vincentk> so, yeah, i guess you can specify the crawler
06:40:37 <malcolmw> the problem crawler was indexing all diffs between all versions of all pages of the wiki :-( Ouch
06:42:47 <quicksilver> malcolmw: is it not sufficient to 'nofollow' those links?
06:43:26 <malcolmw> quicksilver: if you know how to do that, tell Igloo
06:43:33 <SamB_XP> the crawler wasn't very full-featured
06:44:01 <SamB_XP> it didn't respect the robot-control META tags...
06:44:44 <SamB_XP> only http://haskell.org/robots.txt
06:45:01 <SamB_XP> (did anyone get the *name* of that crawler, so we can block just *it*?)
06:45:08 <quicksilver> Igloo: ping
06:45:15 <vincentk> it might be sufficient to replace <meta name="robots" content="index,follow" />
06:45:21 <vincentk> with <meta name="robots" content="index,nofollow" />
06:45:31 <vincentk> see http://moinmoin.wikiwikiweb.de/FeatureRequests/AlternativeSpiderControlFeatures
06:45:33 <lambdabot> Title: FeatureRequests/AlternativeSpiderControlFeatures - MoinMoin, http://tinyurl.com/yt4q8o
06:45:51 <SamB_XP> vincentk: I thought someone tried that.
06:46:00 <SamB_XP> did you look at our robots.txt?
06:46:22 <vincentk> just poking around a bit right now -- but i'm certainly no expert either
06:46:31 <SamB_XP> it is saying "don't anyone crawl /haskellwiki/"
06:46:39 <vincentk> yes
06:46:48 <SamB_XP> ... which includes, say, Google as well as the bot from china...
06:47:26 <SamB_XP> oh, yes, you pasted robots.txt above ;-)
06:47:58 <vincentk> what i'm saying is one should consider imitating indexing policies which seem to work just fine for other wikis ;-)
06:48:10 <SamB_XP> yeah.
06:48:42 <vincentk> but i'll better shut up now ;-)
06:48:55 <SamB_XP> but our History pages *already* have <meta name="robots" content="noindex,nofollow" />
06:50:58 <quicksilver> I thought you could individually 'nofollow' a single link, too
06:51:39 <SamB_XP> so, my point is that I think that someone ought to look in the logs and find the User-agent value for that bot
06:51:46 <SamB_XP> quicksilver: dunno
06:51:52 <Saizan> can you specify a different file for robots.txt with a meta?
06:52:00 <SamB_XP> but if it doesn't respect the meta tag, why would it respect that?
06:52:15 <vincentk> stupidity? ;-)
06:52:23 <vincentk> laziness? ;-)
06:52:28 <vincentk> need more reasons? ;-)
06:52:46 <SamB_XP> no, just the user-agent from that bus
06:52:50 <SamB_XP> would be sufficinet
06:52:52 <SamB_XP> er.
06:52:56 <SamB_XP> whatever ;-)
06:56:08 <SamB_XP> there is something called rel="nofollow", but it doesn't do what it sounds like
06:56:40 <chessguy> which of these is correct?
06:56:45 <chessguy> type Foo a = Bar a
06:56:49 <chessguy> type Foo = Bar
06:56:52 <chessguy> or both?
06:57:06 <mauke> I think both
06:57:24 <chessguy> (assuming i have somewhere defined data Bar a = ....)
06:58:59 <SamB_XP> hmm. it looks like on Wikipedia, scripty things are in a different path from articles?
06:59:15 <SamB_XP> http://en.wikipedia.org/w/index.php?title=Robots_Exclusion_Standard&diff=130296526&oldid=129038389
06:59:17 <lambdabot> http://tinyurl.com/2hts4c
06:59:36 <SamB_XP> see the little "w/"?
06:59:37 <LoganCapaldo> chessguy: empirically both appear to be acceptable
06:59:59 <Broady> dons
07:01:13 <chessguy> <dons> ok. i'm off to bed. all bug reports welcome
07:01:24 <chessguy> from #xmonad, about 20 minutes ago
07:01:39 <SamB_XP> someone should look in to reconfiguring mediawiki so that it puts scripty things in a subdirectory
07:02:03 <Broady> ta, chessguy
07:21:03 <Igloo> quicksilver: What's up?
07:25:13 <quicksilver> Igloo: we were discussing the reasons crawlers are disallowed from the haskellwiki
07:25:23 <ndm> whatever, its a bad reason...
07:25:36 <ndm> it means that people can't find useful information!
07:25:37 <quicksilver> Igloo: because tsome crawler started trying to crawl versions and diff pages
07:25:49 <quicksilver> Igloo: I asked if we couldn't jut 'nofollow' the offending links
07:25:57 <ndm> if an academic paper isn't on google, then it doesn't exist - same for a web page
07:26:40 <Igloo> If you can tell me exactly what needs doing and a brief explanation of why it's the right thing then I can probably do it
07:27:30 <ndm> not having google index haskell is clearly a bad thing
07:27:42 <ndm> not having it index the GHC manual makes the manual a lot less useful
07:27:57 <ndm> esp as there are lots of old copies of the manual online, which searches always turn up
07:28:06 <ndm> plus the Yhc manual is on the wiki, we want it searchable
07:28:12 <ndm> (as to what needs doing, i have no idea!)
07:29:09 <vincentk_> http://www.javascriptkit.com/howto/robots.shtml
07:29:11 <lambdabot> Title: Introduction to "robots.txt"
07:29:45 <vincentk_> in particular, example 4 looks like it's worth a try:
07:29:46 <vincentk_> User-agent: *
07:29:46 <vincentk_> Disallow: /
07:29:46 <vincentk_> User-agent: Googlebot
07:29:47 <vincentk_> Disallow: /cgi-bin/
07:29:47 <vincentk_> Disallow: /privatedir/
07:30:02 <vincentk_> if you don't know who the offending spider is...
07:31:53 <Igloo> Special casing to allow only Google doesn't sound like the right thing to me
07:33:12 <vincentk_> might be good enough for a safe quick fix
07:33:28 <vincentk_> also, you currently use: <meta name="robots" content="index,follow" />
07:33:44 <vincentk_> an you might want to try replacing it with: <meta name="robots" content="index,nofollow" />
07:34:06 <Saizan> it's noindex nofollow on history pages
07:36:51 <vincentk_> well yeah, the clean thing would certainly be to disallow the offending spider -- but that would mean knowing who it is... ;-)
07:37:01 <vincentk_> i don't. do you? ;-)
07:57:11 <ndm> @seen malcolmw
07:57:12 <lambdabot> malcolmw is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 1h 13m 45s ago.
07:57:21 <ndm> malcolmw: Void? i can't find that with Hoogle
08:09:54 <hpaste>  SamB pasted "funny error" at http://hpaste.org/1866
08:11:10 * Igloo reads the error and is not amused
08:11:23 <Igloo> Does the directory your shell is in still exist?
08:11:27 <SamB> no
08:11:32 <SamB> well. yes and no.
08:11:43 <SamB> it wasn't linked to the rest of the filesystem
08:11:51 <osfameron> poor wee orphan!
08:11:55 <Igloo> That's why then
08:12:05 <SamB> so why isn't that amusing?
08:12:18 * SamB thought it was amusing
08:13:27 * SamB wonders how you would get out of that kind of situation if "cd .." actually used the ".." link
08:13:49 <Igloo> cd
08:14:25 <quicksilver> or, cd /
08:14:39 <SamB> quicksilver: ah, yes, that would work right
08:14:58 <quicksilver> 'cd' is 2 fewer characters though
08:15:03 <quicksilver> so Igloo wins
08:15:04 <SamB> ooooh
08:15:08 <SamB> I get it now
08:17:49 <sjanssen> @quote
08:17:50 <lambdabot> Adamant says: Haskell makes my brain taste like burning
08:17:59 <shapr> malcolmw: Hey, is it possible that a WSDL description will fit into a DTD? That is, are all XML Schemas necessarily unable to fit into a DTD that I could use with Dtd2Haskell?
08:18:16 <Si> Can anyone tell me what "mkModid" in System.Plugins.Utils is supposed to do, because I'm not convinced it's behaving correctly.
08:18:46 <shapr> Si: Hey, does HAIFA handle WSDL?
08:18:52 <Si> I'm trying to use a plugin API called "Control.Process.ConCalc.API", but the check module is trying to import a module called "Control"
08:18:59 <Si> shapr: vaguely
08:19:12 <Si> but you wouldn't want to try using it...
08:19:20 <shapr> si: Why not?
08:20:17 <SamB> shapr: eww, XML Schema?
08:20:20 <Si> shapr: Well it's less half way there and I'm not convinced it works properly
08:20:21 <shapr> SamB: No choice
08:20:38 <shapr> si: Ah I see. Will a simple XML Schema fit into a DTD?
08:20:56 <shapr> I'm trying to parse the Amazon EC2 WSDL
08:21:15 <SamB> shapr: most likely you can devise a DTD that will accept a superset of the documents accepted by the XML Schema
08:21:54 <shapr> Will I have to handcode a DTD to match a give WSDL though?
08:22:02 <shapr> given*
08:22:08 <Si> shapr: sort of, but you'd have to throw away most of the data
08:22:27 <SamB> but, if it augments the infoset in any way...
08:22:35 <shapr> I'd really like to take the WSDL I get, and parse it with HaXml.
08:22:56 <Si> parsing an XML document is easy
08:23:08 <shapr> What's the hard part then?
08:23:16 <Si> converting it into Haskell types is awful
08:23:50 <shapr> The WSDL appears to be mostly string, bool, and int.
08:24:06 <Si> if you only want to do it once, you can do it by hand
08:24:19 <Si> fairly easily
08:25:00 <shapr> I need to do it automatically. I want to manage EC2 instances from Haskell.
08:25:32 <Si> I guess you could do it for a subset
08:25:39 <SamB> why do you need to translate the WSDL automatically?
08:25:48 <shapr> SamB: Because I don't want to do it by hand.
08:25:53 <shapr> I'm a non-strict programmer.
08:26:02 <SamB> ah, so you *want* to do it automatically
08:26:04 <shapr> And I'd rather get this code done, test it, and then go do something else.
08:26:33 <SamB> admittedly, if they change the WSDL, a program would be handy
08:26:40 <Si> the problem is I'm not convinced every XML Schema type is even representable in Haskell
08:26:58 <osfameron> how could something not be representable in Haskell ?
08:27:00 <SamB> Si: hmm?
08:27:20 <SamB> does XML Schema use dependant types?
08:27:27 <Si> maybe, I'm not sure
08:27:38 <SamB> ... that was a joke
08:27:46 <quicksilver> I'm sure by 'representable' what Si really means is 'conveniently representable'
08:27:48 <shapr> I think it really does use something like deptypes.
08:28:00 * osfameron notes that SamB's idea of funny may not correspond to his own
08:28:11 <quicksilver> clearly everything is 'representable' in one way or another ;)
08:28:28 <osfameron> apart from certain infinite things
08:28:44 <quicksilver> osfameron: yes, FSOV of 'everything'
08:28:53 <quicksilver> roughly 'everything computable'
08:28:58 <osfameron> rarr!
08:28:59 <SamB> well, I mean, it was *supposed* to be a joke
08:29:04 <SamB> I suppose I should have guessed
08:29:06 <quicksilver> cos if it ain't computable, what are you using this compter for?
08:29:17 * osfameron disappears in a puff of logic
08:31:13 <malcolmw> shapr: I'm pretty confident that schema -> DTD loses information
08:31:38 * Si thinks he'll keep his thoughts to himself next time ;)
08:31:39 <ndm> malcolmw: you mentioned Void type before, does that really exist?
08:31:40 <SamB> malcolmw: in general, yes
08:32:14 <malcolmw> shapr: because schema allows you to say that an element contains e.g. an Int, (even a range-constrained int I think), but in DTD, everything is text only
08:32:16 <SamB> malcolmw: it is possible that in certain instances an XML Schema might be exactly representable as a DTD
08:32:37 <SamB> well, you could try Relax NG
08:32:51 <SamB> now available in the lovely Compact flavour
08:33:03 <Si> the main problem from my point of view is that an XML Schema type is always open to expansion in every possible direction from another namespace
08:33:49 <malcolmw> However, I'm hoping that it might not be too much trouble to take a DTD, convert to Haskell, and back-patch some of the fields to be more accurately typed than just String
08:34:02 <Si> that's how WSDL works, you import another namespace to bind an abstract definition of a Web service to a concrete execution protocol
08:34:17 <beelsebob> warning: experimentation in progress
08:34:24 <beelsebob> can someone please explain to me what a monad is
08:34:27 <malcolmw> Of course, extending DtdToHaskell to become SchemaToHaskell would be the better approach
08:34:36 <beelsebob> and give a reasonably concise definition
08:36:14 * SamB wonders why LyX is using Andale Mono to display stuff
08:36:14 <Si> so basically everything in XML Schema is parametric over an undeterminable number of variables
08:37:04 <malcolmw> yeah, namespaces bugger everything up in XML, because you can drop a value of any type inside a value of any other arbitrary type
08:38:11 <beelsebob> damn, didn't get any definitions this time :(
08:38:19 <malcolmw> ndm: just looked - I think it might be called () rather than Void
08:38:24 <beelsebob> malcolmw: how would you define them?
08:38:44 <quicksilver> beelsebob: you know my answer, but: a monad is a way of abstracting computational effects, such as state, continuation, failure, and choice
08:39:07 <beelsebob> quicksilver: abstracting in what way?
08:39:09 <quicksilver> beelsebob: allowing you to manipulate computations as first-class objects, even though the computation may have a side-effect
08:39:11 <SamB> malcolmw: have you tried Relax NG?
08:39:17 <malcolmw> beelsebob: a monad is a type constructor, together with two characteristic operations, bind and return.
08:39:25 <quicksilver> beelsebob: abstracting in the sense of 'providing a common interface to all these different hings I've just listed)
08:39:28 <Si> and XML Schema also puts very few restrictions on recursion in types
08:39:34 <ndm> malcolmw: GHC says: "Unacceptable argument type in foreign declaration: ()"
08:39:49 <beelsebob> thanks quicksilver do you mind if I quote you at a future date?
08:39:56 <malcolmw> beelsebob: there are some additional constraints on the triple (m, return, >>=)
08:39:59 <shapr> beelsebob: I can explain, but I don't have time right now!
08:40:01 <Si> you can't even do a 1-1 mapping from module to schema because mutually recursive modules don't (can't?) work in Haskell
08:40:15 <Si> (well automatically at least)
08:40:21 <beelsebob> malcolmw: and to what purpose are these constraints/structures put?
08:40:29 <quicksilver> beelsebob: you may quote me, yes. Everything I say in this IRC channel is fair game.
08:40:29 <malcolmw> ndm: ah, maybe it was an extension only implemented in nhc98 then
08:40:36 <ndm> malcolmw: never mind then
08:41:08 <quicksilver> I have an extraordinarily short and elegant explanation of monads but it won't fit in the margin of this IRC channel.
08:41:13 <SamB> Si: tried JHC?
08:41:32 <beelsebob> quicksilver: thanks, that's an awesome quote
08:41:35 <SamB> I've heard it supports recursive modules in accordance with the report
08:41:50 <beelsebob> it's almost as good as "Monads are Neuclear Turds"
08:42:54 <Si> SamB: No I didn't know that.
08:43:14 <malcolmw> SamB: never tried RelaxNG, but from what I remember it looked hugely nicer than DTD or schema
08:43:43 <SamB> it looks especially nice in its syntaxful representation ;-)
08:45:52 <cdsmith> @remember quicksilver I have an extraordinarily short and elegant explanation of monads but it won't fit in the margin of this IRC channel.
08:45:53 <lambdabot> Done.
08:46:44 <Si> Has anyone used hs-plugins for types with a namespace longer than one word, because I tried setting the type of something to "Data.Int.Int" and it tries to import "Data", which of course doesn't work.
08:47:47 <quicksilver> Si: lambdabot works
08:47:55 <quicksilver> Si: and lambdabot uses hs-plugins...
08:48:00 <quicksilver> Si: so I suppose it must be possible
08:48:08 <quicksilver> > :t Control.Monad.foldM
08:48:09 <lambdabot>  Parse error
08:48:13 <quicksilver> :t Control.Monad.foldM
08:48:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:49:08 <Si> does it load a symbol with pdynload with such a type?
08:49:11 <malcolmw> The problem with DtdToHaskell's current implementation is that it converts from DTD to an incomplete representation of Haskell types, then pretty-prints that representation as both datatype decls and instance decls.  There really should be (a) a fuller representation of the Haskell types, and (b) some representation of the derived instances at all.
08:49:27 <quicksilver> Si: I don't know but the source is online and browsable
08:49:38 <quicksilver> Si: or you could ask dons yourself but I believe he's gone to bed
08:56:15 <kolmodin> ?tell waern sett zipper pÃ¥ http://www.cse.unsw.edu.au/~dons/code/xmonad/StackSet.hs och http://en.wikibooks.org/wiki/Haskell/Zippers ? har inte lÃ¤st allt Ã¤n men en fÃ¶rsta anblick verkaju lÃ¶sa det vi pratat om i nÃ¥gra Ã¥r typ :)
08:56:16 <lambdabot> Consider it noted.
08:58:12 <EvilTerran> > iterate not True
08:58:17 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
08:58:29 <osfameron> @src iterate
08:58:30 <lambdabot> iterate f x =  x : iterate f (f x)
08:59:06 <osfameron> > iterate (+1) 1
08:59:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:00:10 <quicksilver> > map ($1) (iterate ((+1).) id)
09:00:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:00:44 <osfameron> @src id
09:00:44 <lambdabot> id x = x
09:05:48 <osfameron> @src .
09:05:49 <lambdabot> (.) f g x = f (g x)
09:05:58 <osfameron> you can section on . ?
09:06:00 * osfameron faints
09:06:05 <quicksilver> you can section on anything
09:06:15 <quicksilver> you'll note I sectioned on ($) as well
09:06:26 <quicksilver> that's one of the most useful things about $, the ability to section it
09:06:27 <osfameron> yes, but you did that a couple of days ago too
09:06:31 <quicksilver> :)
09:06:34 <osfameron> so I was able to see that without fainting
09:06:38 <osfameron> I wasn't ready for .
09:06:46 <osfameron> is function application insanely fast in haskell ?
09:06:59 <osfameron> if you composed perl functions that small everything would grind to a halt
09:07:46 <quicksilver> not really, no
09:07:55 <quicksilver> faster than perl by 2 or 4 orders of magnitude
09:07:58 <quicksilver> but still pretty slow
09:08:08 <sjanssen> osfameron: it's fast enough
09:08:09 <osfameron> oh
09:08:12 <quicksilver> building really really long compositions like that is not a good performance technique :)
09:08:19 <quicksilver> but, it's cute
09:08:24 <osfameron> yeah
09:08:28 <sjanssen> and a good compiler will optimize the composition out
09:08:41 <quicksilver> you could imagine a long composition is comparable in resource usage to a list of similar length
09:08:49 <quicksilver> they'll be out by a small constant factor
09:08:57 <quicksilver> but should be similar
09:09:06 <osfameron> in fact a list is just a composition itself
09:09:11 <osfameron> @src :
09:09:12 <lambdabot> Source not found. Where did you learn to type?
09:09:17 <osfameron> @src (:)
09:09:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:09:23 <quicksilver> no, a list is a constructor application
09:09:26 <quicksilver> not a composition
09:09:34 <quicksilver> however, they're somewhat similar
09:09:47 <osfameron> good, so I'm only partially completely wrong
09:10:12 <quicksilver> there are two main kinds of 'thing' in a haskell runtime
09:10:20 <quicksilver> 'data' which is a constructor and some arguments
09:10:34 <quicksilver> and a 'thunk' which is a function name (pointer) and some argyments
09:10:40 <quicksilver> they're not really very different
09:10:57 <quicksilver> in both cases the arguments themselves might be more data or more thunks
09:11:09 <quicksilver> I've missed out some other cases like unboxed stuff, and lambda-expressions
09:11:15 <quicksilver> but the general picture looks like that
09:11:19 <sjanssen> I don't buy this notion that composition is slow
09:11:30 <quicksilver> sjanssen: did you see my initial code?
09:11:39 <quicksilver> sjanssen: building up very long thunks by composition is slow
09:11:40 <ndm> if you want to uncaf something cheaply, what should you use?
09:11:45 <ndm> (# #) ?
09:11:47 <sjanssen> no, I haven't
09:11:52 <ndm> i.e. as the argument you are passing in
09:12:00 <quicksilver> > map ($1) (iterate ((+1).) id)
09:12:02 <sjanssen> quicksilver: ah, now I see
09:12:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:13:14 <mdmkolbe|work> I think the slowness of that would be because you're creating lots of partial applications, not that function application is slow
09:13:22 <sjanssen> yeah, that's the same as: map sum $ iterate (++[1]) [1]
09:13:31 <sjanssen> unless the compiler does some really clever CSE
09:15:19 <quicksilver> sjanssen: it was just a higher-order example of iterate, to generalise something osfameron had just posted
09:15:29 <quicksilver> sjanssen: clearly not intended to be useful, just thought-provoking
09:15:36 * SamB wonders why fork# takes an a
09:15:57 <quicksilver> I could imagine a combinator library/DSL which built up quite big compositions, though
09:16:17 <quicksilver> but normally lazy evaluation means you don't *actually* ever have a big thunk in memory
09:16:22 <quicksilver> it just kind of unrolls as you go
09:16:26 <quicksilver> (clever stuff, that is)
09:17:13 <SamB> sjanssen: I think sum $ iterate (++[1]) [1] would be even slower...
09:17:49 <SamB> though, I suppose it might have the same heap layout
09:17:55 <quicksilver> very similar
09:18:00 <osfameron> eeeek!
09:18:08 <quicksilver> ((+1).) has one more operator in, though
09:18:15 <quicksilver> in (++[1]), the [1] would be shared
09:18:17 <quicksilver> at least, I believe it would
09:18:41 <SamB> oh.
09:18:59 <osfameron> by "heap layout" you're meaning the number and type of objects stored on the heap ?
09:19:02 <quicksilver> erm, come to think of it, the whole (+1) is probably shared as a lambda-expr, too
09:19:03 <SamB> try sum $ iterate (1:) [1]
09:19:05 <quicksilver> osfameron: yes
09:19:31 <SamB> osfameron: I meant boxes and arrows
09:19:38 <SamB> possibly even sizes
09:19:48 <quicksilver> it's a very similar picture in every case
09:19:58 <quicksilver> a long spine of '.', '++' or ':'
09:20:01 <SamB> anyway, [1..] is much better
09:20:05 <quicksilver> the last I *think* is more compact
09:20:17 <quicksilver> since I think constructors are more compact that partially applied functions
09:20:24 <quicksilver> but I'm really not sure (this could easily differ between compilers)
09:20:37 <mux> quick poll: [1..] or repeat 1 or cycle [1] ?
09:20:37 <SamB> quicksilver: it depends!
09:20:42 <mux> or let ones = 1 : ones
09:20:46 <quicksilver> all the 'bones' on the spine would point back to the same single cell
09:20:53 <SamB> I bet the literal (+1) is pretty compact
09:21:10 <quicksilver> SamB: you realise (+1) is not a literal?
09:21:11 <osfameron> roight.  I think my boss has woken up (it's 6.20pm), so I think it's time to run away from the office...
09:21:20 <quicksilver> samb:it's a section of a binary operator
09:21:35 <ndm> dcoutts - do you not want lunch tomorrow?
09:21:47 <SamB> quicksilver: I say literal because, you know, it doesn't have any variables
09:21:58 <SamB> er, that come from arguments
09:21:59 <dcoutts_> ndm: I'm sure I do want lunch tomorrow, why?
09:22:06 <SamB> I guess I meant CAF
09:22:18 <ndm> dcoutts_ - are you on the FITA list? you aren't listed as one of the ones getting a free MS buffet
09:22:23 <quicksilver> SamB: it's no different from (++[1])
09:22:32 <quicksilver> SamB: it's a binary function applied in the second but not first argument
09:22:37 <dcoutts_> ndm: I've not seen any list, where's that?
09:22:42 <quicksilver> SamB: the rep will be very similar
09:22:48 <SamB> quicksilver: lets see
09:22:59 <quicksilver> SamB: (unless there are special optimisations that apply to one, of course. but in principle)
09:23:14 <ndm> dcoutts_ - are you subscribed to the fun in the afternoon list? there was an email about free food tomorrow, sponsored by MS
09:23:14 <SamB> that, too, is a CAF
09:23:38 <dcoutts_> ndm: oh, I'm probably not subscribed, well never mind
09:24:13 <ndm> dcoutts_ - you should subscribe, that way you get 9 days notice for FITA, instead of 6 :)
09:24:22 <ndm> plus you get to see a guest list in advance
09:25:06 <SamB> are we dealing in Ints or Integers or what?
09:25:16 <ndm> GHC really likes to CAF stuff...
09:25:32 <SamB> yeah, it even CAFd my 1
09:25:59 <SamB> well not quite
09:26:10 <SamB> lifted it to the top...
09:26:58 <quicksilver> doesn't everythiing get lifted in core, though?
09:27:26 <mdmkolbe|work> SamB: IIRC, small integers and characters already have constant definitions so that's why you see it lifted to the top
09:29:40 <SamB> hmm.
09:31:18 <SamB> anyway, GHC can make lambdas of partial applications...
09:31:41 <SamB> especially when you apply only the *second* argument
09:32:20 <quicksilver> well that's what I expected it to do
09:32:29 <quicksilver> but I would also expect it to share that lambda
09:32:42 <quicksilver> so that the spine is all 'bent aronud' one common bone
09:32:46 <quicksilver> to stretch an analogy rather
09:33:31 <shapr> hej bringert!
09:35:54 <njbartlett> Who's going to Fun in the Afternoon then?
09:36:04 <earthy> not me
09:37:23 <dpiponi> I programmed my first robot in Haskell last night. I modified Lava to generate code for the Make Controller.
09:37:31 <mdmkolbe|work> njbartlett: I'll be there
09:37:40 * mdmkolbe|work is interning at MSR right now
09:38:17 <njbartlett> Cool. I'll be there in my London HUG T-shirt :-)
09:38:48 <ndm> njbartlett: i am
09:39:52 <njbartlett> ndm: Too many Neils
09:39:54 <njbartlett> ;-)
09:40:10 <Igloo> mdmkolbe|work: What are you working on?
09:42:02 <mdmkolbe|work> Igloo: refactoring codeGen by using a CPS on the C--
09:42:03 * SamB wonders how long before a compiler can optimize map ($1) $ iterate (+1) 0
09:42:54 <malcolmw> > map ($1) $ iterate (+1) 0
09:42:56 <lambdabot>   add an instance declaration for (Num (a -> b))
09:43:02 <Saizan> SamB: by executing it?
09:43:08 <malcolmw> SamB: type incorrect :-(
09:43:21 <sjanssen> s/0/id
09:43:27 <SamB> oh, right
09:43:44 <SamB> and add the .
09:43:46 <malcolmw> map ($1) (iterate ((+1).) id)
09:44:49 * malcolmw thinks the full laziness transformation might be able to take of that little optimisation problem
09:44:57 <ddarius> SamB: foldr/unfoldr does it.
09:45:20 <ndm> SamBmine can already
09:45:31 <shapr> dpiponi: AWESOME!
09:45:44 <shapr> dpiponi: Tell me you're going to put up a blog entry about that!
09:45:53 <SamB> ddarius: oh?
09:45:54 <shapr> dpiponi: Or at least that you'll release the source?
09:46:11 <dpiponi> I'll write it up, with video. But I need to continue development.
09:46:12 <SamB> dpiponi: where did you get Lava?
09:46:21 <mdmkolbe|work> @seen dpiponi
09:46:22 <lambdabot> dpiponi is in #haskell. I last heard dpiponi speak 11s ago.
09:46:33 <dpiponi> To be frank, it was easier to adapt the code than understand it so I need to get to grips with Lava first.
09:46:38 <malcolmw> dpiponi: is your robot based on the article in TMR?
09:46:57 <dpiponi> The code is based on the TMR article. I just emailed the author and asked him for the code.
09:47:21 <mdmkolbe|work> shapr: what did dpiponi do that was "AWESOME" (I seriously can't find it in the scroll back)
09:47:24 <malcolmw> actually the entire code is in the article itself too :-)
09:47:41 <chessguy> <dpiponi> I programmed my first robot in Haskell last night. I modified Lava to generate code for the Make Controller.
09:48:09 <mdmkolbe|work> dpiponi: AWESOME!
09:48:09 <dpiponi> The TMR article only contains part of the code. And the actual code I got from Matthew Naylor was different to the article.
09:48:10 <chessguy> about 10 minutes ago
09:48:37 <dpiponi> Porting was really easy.
09:49:37 <mdmkolbe|work> dpiponi: which article are you refering to? (TMR = ?)
09:49:45 <chessguy> ?where tmr
09:49:46 <lambdabot> http://www.haskell.org/haskellwiki/TheMonadReader
09:50:10 <dpiponi> TMR=7. Article my Matthew Naylor on Lego programming with Lava
09:50:17 <dpiponi> s/my/by/
09:50:32 <chessguy> specifically http://www.haskell.org/sitewiki/images/0/03/TMR-Issue7.pdf , starting on page 5
09:51:10 <kolmodin> ?tell waern hepp.. bara access till en punkt i datastrukturen
09:51:11 <lambdabot> Consider it noted.
09:52:02 <shapr> mdmkolbe|work: He generated code for the make controller from Lava
09:52:22 <dpiponi> Lava produces pretty tight code. I think this might be a practical way to use functional programming on devices with memories as small as 256 bytes.
09:52:22 <shapr> mdmkolbe|work: Since I didn't think Lava was available, and I have a MAKE subscription, I'd like to do that too.
09:53:20 <dpiponi> Actually, lava is available.
09:53:26 * SamB thought lava made circuits
09:53:50 <dpiponi> http://www.cs.chalmers.se/~koen/Lava/download.html
09:53:52 <lambdabot> Title: The Lava Homepage: Download
09:54:06 <dpiponi> You don't need 'prover' or any of that stuff
09:54:52 <dpiponi> SamB: In effect Lava can generate C code that corresponds to a circuit
09:55:20 <ndm> does GHC have the empty tuple (# #) ?
09:55:40 <dpiponi> ndm: () :: () ?
09:55:49 <ndm> dpiponi: the unboxed empty tuple
09:55:50 <SamB> dpiponi: oh, for hardwareC or whatever they call it?
09:55:58 <ndm> i want something which takes no runtime space, ideally
09:55:58 <Igloo> RealWorld# might be what you want, but it might be too magical for you
09:56:17 <ndm> Igloo: low level hacky magic is fine at this point - is that realWorld# as exported as a value?
09:56:35 <dpiponi> SamB: Real C actually. I'm generating stuff for the ARM port of gcc.
09:56:44 <ndm> "Top-level bindings for unlifted types aren't allowed:"
09:56:46 <SamB> ... doesn't that hardwareC thing use real C?
09:56:50 <ndm> when doing: token = realWorld#
09:56:53 <ndm> whats the error there?
09:57:34 <sengan> Anyone know if this http://blogs.nubgames.com/code/?p=23 is for real? The dude says he's got only a few months experience with Haskell... Kinda  light to write a book on it.
09:57:35 <lambdabot> Title: Nub Games » Pragmatic Haskell
09:57:58 <dpiponi> I think hardwareC is compiled straight to whatever FPGAs use, or maybe goes via some other hardware description language.
09:59:14 <Igloo> ndm: Hmm, maybe the value you want doesn't actually exist
09:59:32 <ndm> Igloo: once you use an unboxed type, do you loose all type inference?
09:59:49 <SamB> ndm: you aren't allowed to make your own variables for that, apparantly
09:59:56 <ndm> SamB, seems so
10:00:11 <sengan> You don't lose type inference. You lose dynamic dispatch IIRC.
10:00:37 <ndm> but you cannot pass RealWorld# to a function, unless you annotate that RealWorld# is the only expected type
10:00:43 <sphynx> hi all!
10:01:07 <Igloo> ndm: No
10:01:51 <ndm> Igloo: ok, i think i understand where i'm going wrong - the root function is polymorphic - so if i make the root function RealWorld#, i should get it back
10:02:12 <ndm> any idea where the type of realWorld# is exported from, and what it is called?
10:02:18 <chessguy> hi sphynx
10:02:24 <sphynx> I have started to get into State monad today. Could please someone give me some easy task, which can be done using State monad for studying purpose?
10:02:49 <chessguy> sengan: his blogs are really good though
10:02:55 <ndm> @src GHC.base
10:02:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:02:59 <ndm> @src GHC.Base
10:03:00 <lambdabot> Source not found. Wrong!  You cheating scum!
10:03:00 <sphynx> I've tried to make some pop function for stack (we've discussed this task with dons somehow)
10:03:15 <SamB> ndm: GHC.PrimOps
10:03:19 <SamB> er.
10:03:20 <chessguy> sphynx: that should be quite easy
10:03:22 <SamB> maybe .Primops
10:03:32 <chessguy> sphynx: you wouldn't need a State monad for that, but you could use one
10:03:36 <SamB> @type GHC.PrimopWrappers.realWorld#
10:03:40 <lambdabot> Not in scope: `GHC.PrimopWrappers.realWorld#'
10:03:44 <sphynx> It's easy thing, something like: let pop = do (x:xs )<- get ; put xs ; return x in runState (do pop; pop; pop) "haskell"
10:03:49 <SamB> @type GHC.Primops.realWorld#
10:04:03 <lambdabot> Couldn't find qualified module.
10:04:17 <SamB> oh, right, GHCi and all :-(
10:04:31 <ndm> SamB, apparently its GHC.Base, but its type RealWorld
10:04:33 <chessguy> > let pop = do (x:xs )<- get ; put xs ; return x in runState (do pop; pop; pop) "haskell"
10:04:38 <sphynx> chessguy, I would like some examples, where State monad maybe will be an overkill, but I think that real life examples is too difiicult for beginners?
10:04:40 <SamB> ndm: hmm?
10:04:42 <sengan> chessguy: well... I started Haskell in 1993 IIRC, and it's easy to teach the easy stuff, but good luck doing the full monty (space leaks and so on) which is what I would expect for a Pragmatic Programmers book like the Erlang one (written by their equivalent to SPJ)
10:04:44 <lambdabot>  ('s',"kell")
10:04:51 <SamB> @hoogle RealWorld
10:04:52 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
10:04:58 <SamB> @doc GHC.Base
10:04:59 <lambdabot> GHC.Base not available
10:05:46 <SamB> ndm: but that isn't unlifted...
10:05:55 <chessguy> sengan: <shrug> i see your point, but i've seen very experience programmers who are very impressed with his blogs
10:06:00 <ndm> SamB, the type is State# RealWorld apparently
10:06:03 <chessguy> sengan: i figure, it can't hurt
10:06:11 <ndm> but now the question, how do I do _anything_ to a realWorld#
10:06:16 <ndm> just enough to make it be required
10:06:20 <ndm> since seq doesn't work on it
10:06:28 <sphynx> chessguy, I have tried 'Understanding monads' from Wikibooks (with all these 'bind robots' :) - funny article) and 'All about monads'. But this State monad still can't find right place in my head :)
10:06:49 <sengan> chessguy: I guess the proof of the pudding is in the eating.
10:06:55 <chessguy> sengan: indeed
10:07:31 <chessguy> sphynx: are you familiar with RPN - Reverse Polish Notation?
10:07:55 <sphynx> chessguy, yeah, I've wrote evaluator and converter from infix to RPN :)
10:08:03 <sphynx> also I've blogged about this )
10:08:10 <chessguy> sphynx: did you use a state monad?
10:08:20 <chessguy> link?
10:08:27 <sphynx> chessguy, no, pattern matching only
10:08:47 <chessguy> might be instructive to re-write it using a state monad then
10:08:47 <sphynx> chessguy, Unfortunately, my article is in Russian only. I will translate later..
10:09:31 <sphynx> chessguy, It's a bit hard for me to write in blog in English directly. Translation seems to be easier
10:09:48 <chessguy> fiar enough
10:09:53 <chessguy> *fair
10:10:42 <chessguy> another simple problem would be to use a state monad to write a little tic-tac-toe game
10:11:43 <sphynx> what part of this postfix stuff is quite good for rewriting - evaluation, translation or all of these?
10:12:55 <chessguy> sphynx: well, i was thinking you could write a general stack, and then use that in the evaluation of RPN expressions
10:13:51 <MyCatVerbs> Oh wow, ghci makes a *really* good pocket calculator.
10:13:53 <sphynx> oh, ok. So I can implement Stack using State monad
10:14:07 <chessguy> i actually want to write a tutorial about monad transformers this way, but unfortunately i think it's going to have to wait until i'm not moving, changing jobs, and making wedding plans
10:14:16 <chessguy> sphynx: yeah, you can. it's overkill, but can be done
10:14:50 <sphynx> chessguy, I see, that general way of writing State-programs is in using "put" and "get" widely
10:15:03 <ddarius> sphynx: No.
10:15:08 <ddarius> Or at least not explicitly.
10:15:23 <chessguy> there's also modify
10:15:35 <sphynx> ddarius, , But they are present in "All about monads" and in that dons' little example
10:16:09 <ddarius> sphynx: Well, they are the primitives you have to work with, but usually you want to wrap them in higher-level, more meaningful, functions.
10:16:43 <ddarius> Even going so far as newtyping the monad to enforce that only your high-level functions can be used.
10:17:16 <sphynx> ddarius, and these meaningful functions usually have type like f :: State s a, yes?
10:17:25 <chessguy> ddarius: a la Cale's monad transformer article?
10:17:33 <ddarius> chessguy: Link?
10:17:37 <chessguy> ?where cale
10:17:38 <lambdabot> I know nothing about cale.
10:17:44 <chessguy> @go calewiki
10:17:47 <lambdabot> http://cale.yi.org/index.php/HRSS
10:17:47 <lambdabot> Title: HRSS - CaleWiki
10:17:47 <ddarius> sphynx: Usually s will be fixed to some particular type.
10:17:50 <MyCatVerbs> > let { x = [x|x<-[2.5,2.501..4],((sin x)+1) ~= 1]; (~=) a b = ((abs (a-b)) < ((max a b)/50)); } in (sum x) / (fromIntegral $ length x)
10:17:52 <lambdabot>  3.141499999999929
10:18:19 <chessguy> ddarius: this one: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
10:18:21 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
10:18:21 <shapr> dpiponi: But that's not the 'real' Lava that Xilinx had up for download for a few days.
10:18:32 <MyCatVerbs> List comprehensions are more fun when you realise you can do numerical analysis with them. ^^
10:18:37 <ddarius> sphynx: And it may well take parameters, but necessarily it will be A -> B -> ... -> State S X or MyMonad X
10:19:29 <ddarius> chessguy: Yes, that gives a simple example of what I'm talking about.
10:19:39 <sphynx> ddarius, OK, so generally I should think abouth what the State will contain and how should I work with state in my functions
10:20:16 <chessguy> ?seen cale
10:20:17 <lambdabot> I saw cale leaving #oasis, #ghc, #haskell-overflow and #haskell 1d 22h 36m 51s ago, and .
10:20:27 <chessguy> haven't seen him around much these days
10:20:50 <ddarius> Clearly you have to think about what the state will be, but you want to think about what are you actually doing.  State is likely primarily supporting whatever it is you are doing.
10:20:57 <ddarius> Anyways, I've got to go.
10:21:35 <sphynx> ddarius, ok, thank you!
10:22:19 <dpiponi> shapr: real  lava?
10:23:25 <dpiponi> shapr: oh right, "Currently, there are two versions of Lava in use...We hope to merge these two version soon."
10:25:46 <sphynx> chessguy, well, I will try to play with stack, thank you for good advice!
10:26:29 <chessguy> sure thing, good luck
10:30:01 <matthew_-> so, any wide spread schemes for reflecting the values of an enumeration ADT as types?
10:30:19 <shapr> generic haskell?
10:31:21 <pejo> Is Data.Binary totally standalone, or included in some (6.6.1?) ghc?
10:32:38 <ndm> pejo: standalone
10:33:15 <matthew_-> shapr: ooo! that's something I know nothing about. Yay, three papers for the journey home...
10:40:14 <beelsebob> Warning: Experiment in progress
10:40:14 <beelsebob> Can you guys please explain to me what a monad is, and what it's for
10:40:38 <matthew_-> beelsebob: never heard of it. sorry
10:41:55 <dcoutts_> beelsebob: I think I recall some crazy drunk category theorist mention that word once
10:42:05 <cdsmith> beelsebob: "The Monad is the spark of god within each person. In the beginning the Monads were the divine sparks of the Creator. Each Monad created twelve souls."  www.spiritual.com.au/dictionary/dict_m.html
10:42:17 <beelsebob> o.O
10:42:25 <beelsebob> cdsmith: preferably relevant to Haskell :P
10:42:34 <cdsmith> :)
10:43:00 <migraine> that definition would leave monads and gonads meaning almost the same thing
10:43:06 <beelsebob> lol
10:43:29 <shapr> beelsebob: A monad is an abstraction just like an object is an abstraction.
10:43:46 <matthew_-> beelsebob: it's a cottege industry
10:43:49 <shapr> beelsebob: It's a way to separate parts of the code so you can focus on just the parts that you're working on right now.
10:44:04 <beelsebob> shapr: okay, that's an interesting one
10:44:05 <beelsebob> thanks
10:44:31 <cdsmith> I agree, shapr, that's a great way to look at it.  Thanks!
10:45:06 <shapr> beelsebob: A monad is a piece of code that replaces a repetitive pattern in code. The simplest example is a monad that replaces nested if-then-else statements, and it's called 'Maybe'
10:45:09 <beelsebob> shapr: what exactly *is* the abstraction, can you describe it to me?
10:45:23 <migraine> I like the container/factory analogy
10:45:25 <mauke> monads are too simple to describe
10:45:33 <shapr> mauke: Sometimes I think you're right
10:45:59 <vegai> sequencing?
10:46:11 <mauke> understanding the Monad interface is hard because there's so little to work with
10:46:12 <shapr> beelsebob: For example, if you have a webshop, you'd have a bunch of conditions that each need to be checked, and if any one of those conditions fails, the whole stack of checks should fail.
10:46:14 <beelsebob> vegai: was that an answer to exactly what the monad abstraction is?
10:46:29 <vegai> beelsebob: it's my uneducated guess
10:46:29 <postalchris>  beelsebob: if someone successfully explained Monads to you via IRC, then P=NP
10:47:04 <shapr> beelsebob: Some conditions could be: isItemInStock, doesCustomerCreditCardExist, doesCreditCardHaveEnoughMoney
10:47:17 <cdsmith> beelsebob: a particular monad - say, the State monad for example, is an abstraction.  The general concept of monads is ... well, also an abstraction, but not in the same way! :)
10:47:20 <postalchris> Er, oops, P /== NP
10:47:43 <pejo> postalchris, he's not exactly working from scratch without any understanding to begin with.
10:48:01 <shapr> beelsebob: Do you want me to go on?
10:48:09 <shapr> beelsebob: I've explained monads lots on #haskell
10:48:21 <beelsebob> shapr: if you want to, but I think that you've provided me with some really good material there
10:48:25 <beelsebob> more interesting than the average
10:48:51 <beelsebob> postalchris: this is in some way a rigged question -- I know what a monad is (well, as well as many other people), but I'm trying to understand what the prevailing understanding is
10:49:11 <shapr> I usually give the motivation for Maybe (replacing nested if-then-else), then I show how it's implemented.
10:49:23 <beelsebob> shapr: okay, that's a neat point
10:49:44 * beelsebob goes to eat his dinner
10:49:51 <postalchris> beelsebob: well, you've got my answer: it's got something to do with complexity classes ;-)
10:49:55 <shapr> Once the audience understands Maybe, I show them how you can report an error instead of just dying by upgrading to Either
10:49:58 <shapr> bah, he's gone
10:50:29 <shapr> Once they understand how the Error monad can be built from Either, and how closely it's related to Maybe, then I go on to the State monad.
10:50:52 <shapr> Which I usually describe by showing how a pure hand calculator with a single value memory would be implemented
10:51:39 <shapr> You start out by explicitly passing the single value around to each function. Then you show how that can be replaced with a monad to automate the plumbing.
10:52:17 <migraine> I like the idea that it is just a container with methods, that apply tranformations, to get stuff in/out...
10:52:28 <cdsmith> @tell SamB http://www.pphsg.org/safeghc/ (please comment)
10:52:29 <lambdabot> Consider it noted.
10:52:31 <shapr> At which point, the audience usually says "Gee, I can do this in (Java/Python/etc)." and I say "Yup, monads are just a convention that makes it easy to predict how your code will mix with other code that uses the same convention.
10:52:44 <cdsmith> @tell sjanssen http://www.pphsg.org/safeghc/ (please comment)
10:52:45 <lambdabot> Consider it noted.
10:53:20 <Saizan> the fact that abstracts away a *repetitive* pattern seems the most fondamental and most unstressed feature
10:53:21 <shapr> And the monad laws make predictable concatenation a reality!
10:53:49 <shapr> Monad : It's just an Abstraction.
10:54:33 <shapr> And honestly, it's no harder than learning the object abstraction.
10:55:04 <shapr> Took me several weeks to figure out objects the first time. (by myself)
10:56:05 <TomMD> If that is your belief then you should write "Yet another Yet another Monad Tutorial" (YAYAMT)
10:56:13 <migraine> well took me a few days to get objects and only needed one reference, but I had to read 3-4 papers on monads and I still don't fully understand them although I seem to be able to use them
10:56:29 <shapr> migraine: What about them do you understand?
10:57:49 <migraine> shapr: well maybe it's not that I don't understand them... perhaps I don't understand all of their usefullness
10:58:26 <TomMD> migraine:  That is well put and I believe it applies to many people.
11:00:39 <shapr> migraine: Yeh, took me awhile too. Simple pattern, complicated implications.
11:01:02 <chitin> ?ty 5^^2
11:01:04 <lambdabot> forall t. (Fractional t) => t
11:01:57 <tibbe> anyone have time to talk me through how to best install ghc on mac os x?
11:02:17 <migraine> I used a package
11:02:24 <LoganCapaldo> I used an installer
11:02:28 <migraine> but I had to use one version older
11:02:36 <migraine> the latest version was missing the mac package
11:10:00 <tibbe> migraine: yes, I guess I'll use the older one
11:10:05 <ndm> http://neilmitchell.blogspot.com/2007/05/13-faster-than-ghc.html
11:10:06 <ndm> yay!
11:11:58 <andrei> Is there any information about GHC on the Cell?
11:14:38 <Igloo> ndm: That looks very broken to me
11:14:52 <Igloo> ndm: The particular benchmark I've been working on is "print . length =<< style="font-style: italic;">must use the C getchar
11:15:19 <ndm> Igloo: fixed
11:17:44 <dcoutts_> andrei: someone got it working, I think someone reported that a generic ppc linux build worked on the PS3
11:17:59 <dcoutts_> andrei: that does not take advantage of the SPUs of course
11:18:29 <dcoutts_> check the ghc-users list, I recall someone reported a few weeks ago that it worked
11:18:43 <ndm> Igloo: blogger got confused by the <, it really isn't that clever...
11:19:46 <ari> @. elite yarr
11:19:47 <lambdabot> G4Ngw4y!
11:20:51 <monochrom> @yarr
11:20:52 <lambdabot> I want me grog!
11:22:04 <chessguy> @quote
11:22:05 <lambdabot> hakko says: most programmers have a lot of religious issues about their work, yes.
11:22:35 <chessguy> @quote work
11:22:35 <lambdabot> PaulGraham says: An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers
11:22:36 <lambdabot> you should have cited.
11:22:48 <Syzygy-> Hahaha!
11:22:48 <monochrom> hahaha
11:22:49 <andrei> dcoutts, Thanks
11:22:53 <Syzygy-> Sounds like a plan!
11:32:17 <moonlite> I need to write the EOF char to a socket. How do i access the EOF char?
11:32:28 <MyCatVerbs> moonlite: control-D.
11:32:47 <moonlite> MyCatVerbs: and as a char?
11:32:49 <savanni> I think that is done solely by closing a socket.
11:32:56 <MyCatVerbs> moonlite: I -think- '\004' if you want it as a character constant.
11:33:09 <MyCatVerbs> moonlite: but you really ought to do hClose instead.
11:33:31 <savanni> Control-D should only have meaning in a unix shell since character 4 could easily be a valid character in a binary stream.
11:33:37 <monochrom> There is no EOF character. (It's an illusion.)  hClose it.
11:34:01 <SamB> lambdabot: @messages
11:34:01 <lambdabot> cdsmith said 41m 32s ago: http://www.pphsg.org/safeghc/ (please comment)
11:35:41 <moonlite> hm. I'm implementing a simple ftp server and the spec says (i think) that when sending ASCII data (LIST etc) i need to tell the client that the stream is finished by appending an eof-char. When in binary mode i should instead close the connection.
11:36:07 <moonlite> so, from what you are saying i guess there is a difference between "closing the connection" and "closing the socket"?
11:36:28 <moonlite> (if not, i'll have to reread the spec :))
11:36:28 <quicksilver> you'll need to read the spec to find out what they mean by eof-char
11:36:36 <quicksilver> could be ctrl-z
11:37:00 <quicksilver> > chr 26
11:37:02 <lambdabot>  '\SUB'
11:38:52 <monochrom> OK I lied.
11:38:58 <monochrom> > chr 4
11:39:09 <lambdabot>  '\EOT'
11:39:46 <monochrom> close connection = close socket, that's the easy part.
11:40:03 <quicksilver> however, you were right in that hitting ^D in a unix shell does not, in fact, tell the shell to transmit a ^D
11:40:06 <monochrom> try a "man ascii" on your computer.
11:40:17 <quicksilver> that's just a shell signal to 'close this input'
11:41:01 <monochrom> The whole story about ^D is complicated.
11:41:05 <norpan> > '\EOT'
11:41:19 <lambdabot>  '\EOT'
11:42:03 <moonlite> hm '\EOT' seems to do the trick
11:42:19 <quicksilver> End Of Transmission ,you see :)
11:42:25 <moonlite> yep :)
11:42:48 <quicksilver> ctrl-Z was the tradition in some other OSes though
11:42:55 <quicksilver> I wasn't sure which the FTP sepc was thinking of
11:43:55 <moonlite> thanks a lot btw
11:44:26 <monochrom> The FTP spec definitely gives the ascii code concerned.
11:44:58 <MyCatVerbs> quicksilver: Mess-Doss used ^Z by (incorrect) convention
11:45:32 <monochrom> The ^Z story is less complicated than the ^D story, but that's only because DOS dumbs it down.
12:00:24 <chyntia> need some help
12:00:45 <pitecus> shoot
12:03:10 <chyntia> i have to implement a function which input is an automat and it must return the accesible state
12:03:40 <chyntia> i don't know how to do it:|
12:04:27 <pitecus> people won't do homework for you so you have to try to come up with smth if you want help. chyntia
12:05:05 <monochrom> It is a formidable task. DFS from the start state(s) finds all and only accessible states.
12:05:56 <chyntia> i don't want the homework,just some ideas
12:06:09 <monochrom> Data.Graph does almost everything for you.
12:06:32 <ndm> chyntia: do you have a representation for an autoatma?
12:13:17 <JohnMeacham_> hrm. floating point in haskell is very annoying.
12:13:26 <MyCatVerbs> JohnMeacham_: ?
12:13:44 <JohnMeacham_> mainly, the class hierarchy makes it tricky to perform operations i would like to.
12:13:50 <atp> hey, can anyone point me to a discussion of how the Array type is defined in Haskell?
12:13:54 <MyCatVerbs> JohnMeacham_: how so? The typechecker is whining at you when you try to multiply a float by an integer?
12:14:07 <JohnMeacham_> like, rounding a floating point number requires going through an Integral type.
12:14:19 <MyCatVerbs> JohnMeacham_: fromIntegral / fromInteger, truncate...
12:14:29 <MyCatVerbs> JohnMeacham_: properFraction, perhaps?
12:14:58 <MyCatVerbs> > (\(x,y)->x) $ properFraction $ (pi + 0.5)
12:14:59 <lambdabot>  3
12:15:00 <eumenides> atp: http://darcs.haskell.org/ghc-6.6/packages/base/Data/Array/Base.hs ?
12:15:13 <JohnMeacham_> I added things like 'decodeFloatf' 'truncatef', etc to jhc which retain the floating point type rather than converting to integers, those integer/rational conversions were a performance bottleneck.
12:15:28 <TomMD> > (\(x,y)->x) $ properFraction $ (pi - 0.2)
12:15:29 <atp> eumenides: hm, yeah, maybe the source is the best way to grok it
12:15:30 <MyCatVerbs> JohnMeacham_: ahhhh.
12:15:40 <lambdabot>  2
12:15:54 <TomMD> 13 seconds for lambdabot to respond?
12:16:03 <TomMD> @karma- lambdabot
12:16:03 <lambdabot> lambdabot's karma lowered to 49.
12:16:06 <MyCatVerbs> TomMD: the .5 is there 'cuz properFraction acts like floor.
12:16:17 <eumenides> atp: it does seem to be commented somewhat. i'm not sure where you'd find a proper discussion
12:16:38 <JohnMeacham_> still not great.. I am not sure what the best solution is. perhaps another class for IEEE finite floating point types with more operations. though, it is really converting between types that has no good solution at the moment...
12:17:05 <atp> eumenides: i'm mainly just curious as to how one gets O(1) access in a purely functional setting, because i'd been trying to think of a way and failing... of course in the imperative space where you have control over memory layout, O(1) is trivial to get
12:18:13 <eumenides> atp: it seems to import the ST monad. maybe they use that to make it more... imperative
12:18:50 <JohnMeacham_> MyCatVerbs: indeed, but the intermediate integer representation requires allocating memory, calling gmp functions and all sorts of stuff, when truncate should be a single assembly instruction. Perhaps I will propose truncatef and friends for Haskell' once i get some more experience with them.
12:19:15 <TomMD> atp: I find that in algorithms in 'C' I tend to have a structure that might store an index number for related information in an array.  In haskell I don't bother with index numbers and I just store the related information as an entry in the data structure.
12:19:48 <MyCatVerbs> JohnMeacham_: it sounds like what you really want to do is add a few native floating point truncations, rounds, etc to the Num class from <math.h>.
12:19:51 <TomMD> This works because no matter how many structures hold the same 'related information' entry, it will only take up the 1 memory location (closure).
12:20:02 <atp> TomMD: in C i generally use pointers for that sort of thing, saves on the add
12:20:29 <TomMD> atp: this is the same concept without the hassle of pointers.
12:20:48 <MyCatVerbs> JohnMeacham_: then submit default definitions of them for the Real class (in terms of the usual, slow, through-integer conversions, so that nobody's old code breaks).
12:20:52 <atp> TomMD: still, fast access arrays are convenient if you're dealing with very large values of n... in this case i'm operating on an array of data that has around 60 thousand elements, so using a list or similar would incur a substantial performance hit when indexing things far along in the tail
12:21:00 <Baughn> atp: You might not use that /same/ data structures in Haskell as in C, but you can still get O(1). See DiffArray for a neat example
12:21:03 <MyCatVerbs> JohnMeacham_: and get ghc, hugs and nhc to adopt them already.
12:21:35 <JohnMeacham_> yup. that is what I did :) http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/lib/base/Jhc/Float.hs  and http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/lib/base/Jhc/Num.hs
12:21:36 <atp> TomMD: the problem is, what i'm talking about here i wouldn't solve that way, even in C :)
12:21:41 <lambdabot> Title: darcs - jhc, http://tinyurl.com/2bs6cy
12:21:58 <hstenstrom> (\(x,y)->x) $ properFraction $ (pi - 0.2)
12:22:32 <bluestorm_> atp:
12:22:35 <sieni> atp: I don't understand why a Haskell array wouldn't have O(1) access? An array is an array.
12:22:37 <bluestorm_> did you read the Wadler paper ?
12:22:44 <bluestorm_> there is a large part about array updating
12:22:47 <atp> sieni: it *does* have O(1) access
12:22:49 <bluestorm_> and it's accessible
12:22:54 <atp> sieni: i just don't understand how they did it :)
12:22:57 <mux> monadic arrays do have O(1) access
12:23:07 <mux> actually, pure arrays too
12:23:14 <mux> but they suck at updating
12:23:23 <atp> mux: yeah, but i don't need updating
12:23:30 <Baughn> atp: The same way C does it. For something like DiffArray, accessing the newest version is O(1) for read/write and older version get increasingly slow
12:23:33 <mux> Array is just fine then
12:23:43 <mux> if you don't use // too much, they're just nice
12:23:43 <JohnMeacham_> but converting between floating point types is still an open issue. I basically don't ever want to go through Rational or Integer.. I added 'toDouble' and 'fromDouble' alongside 'toRational' and 'fromRational'
12:24:02 <Baughn> atp: To a large extent, this is done by cheating - there might be destructive updates internall, but so long as you can't /tell/, nobody minds
12:24:17 <atp> mux: yes, i know ... i am using Array, i just wasn't sure how it worked
12:24:23 <atp> Baughn: ah.. cheating :(
12:24:33 <sieni> atp: well, you just calloc(N, sizeof(the haskell representation of your element type))
12:24:36 <atp> Baughn: here i thought someone crazy had come up with something purely functional
12:24:48 <atp> sieni: sigh... no, in Haskell... i can do it in C just file
12:24:51 <atp> sieni: fine
12:24:53 <bluestorm_> hm
12:25:00 <Baughn> atp: They have. Seriously, see the documentation for DiffArray
12:25:02 <bluestorm_> what's "functionnal" for you ?
12:25:10 <Baughn> atp: The "cheating", hopefully, involves making the compiler smarter
12:25:25 <bluestorm_> isn't something that is side-effect free functional ?
12:25:30 <atp> bluestorm_: no destructive updates, not just allocating a chunk of memory and then accessing with a pointer add
12:25:49 <atp> Baughn: hm, ok, let me check it out.
12:26:01 <Baughn> atp: Take a function such as f x = x + 1
12:26:13 <bluestorm_> it seems me that what you call "destructive updates" are side-effect free when monadic
12:26:26 <JohnMeacham_> atp: that is how all arrays are implemented internally eventually, functional is a quality of an API (and its semantics), not an implementation.
12:26:30 <bluestorm_> ( http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf was the paper )
12:26:33 <lambdabot> http://tinyurl.com/zhxow
12:26:40 <Baughn> atp: Theoretically that makes a copy, but the compiler can tell if you're keeping the older version around and use destructive updates if you don't. There's a lot of that going around.
12:26:53 <monochrom> Using uniqueness types you can be functional at the high level and update at the low level.
12:28:02 <atp> right, right, i understand this, but for example, the haskell list is a nil | cons datatype internally, which essentially means that it is implemented as a linked list, right?  i can understand how one can talk about linked lists with recursive, functional language
12:28:06 <sieni> atp: so in Haskell, you create your array with e.g. array
12:28:09 <bluestorm_> monochrom: btw, do you have an hm easy introduction to uniqueness types, that does not looks like "learn Clean and come back" ?
12:28:41 <monochrom> I don't.
12:28:50 <bluestorm_> hm
12:29:03 <bluestorm_> maybe i'll end up trying to learn Clean
12:29:09 <Saizan> the main problem here is not update, it is allocating memory and pointer aritmetic, that is done through lowlevel C-ish calls i think
12:29:21 <atp> what i was having trouble understanding was how one would implement a datastructure with O(1) access using high level haskell, and not just having ghc do optimizations during compile
12:29:49 <Baughn> atp: Basically, you'd implement it using predefined datastructures such as Array
12:29:59 <Baughn> atp: Same as C, if you think a little
12:30:07 <Saizan> atp: using a very large tuple :)
12:30:30 <atp> well, no, because in C i can create an array without any of the language semantics... it's just a block of memory (call to brk()) and then pointer arithmetic
12:30:42 <atp> all the rest is syntactic sugar
12:30:49 <Baughn> atp: That /is/ part of the language semantics
12:31:05 <Baughn> atp: If you like, you can consider malloc() to be the equivalent of Array.new
12:31:07 <monochrom> That's just semantics.  (duck)
12:31:08 <sieni> atp: and in Haskell you can create an array by calling array: http://www.zvon.org/other/haskell/Outputarray/array_f.html
12:31:09 <lambdabot> Title: Haskell : array
12:31:20 <atp> it's so low level that it's basically a part of the computer's architecture.
12:31:34 <atp> it's exactly the same as how i'd do it in machine language.
12:31:44 <Baughn> atp: And haskell's a high-level language. What are you asking for, exactly?
12:31:55 <Baughn> atp: Array exists. It does the same thing as malloc. Why not use it?
12:32:02 <atp> i *am* using it
12:32:13 <atp> i have no problem using it
12:32:18 <atp> it's just that, when i was learning haskell,
12:32:26 <JohnMeacham_> Well, it is certainly simple to do that in haskell in a purely functional way via Foreign.Storable
12:32:56 <JohnMeacham_> the IO monad is pure functional, that is the trick you are looking for. :)
12:33:17 <Baughn> That's stretching it a bit. ^_^;
12:33:30 <atp> the gentle tutorial made a point of saying that haskell types were not special, and went on to define lists with a data List a = Nil | Cons (List a), for example
12:33:36 <monochrom> The whole bloody cosmos is pure functional.
12:33:39 <atp> which it thought was really neat
12:33:54 <atp> obviously the compiler does all sorts of optimizations, and also
12:34:03 <atp> there's the monad bit of lists on top of that...
12:34:17 <atp> i just wanted to know if a similar construction could be made for Array
12:34:21 <Baughn> atp: The haskell type system only allows you to define constant-sized chunks for O(1) access. That's a fundamental limitation.
12:34:42 <Baughn> atp: Which means that things like Array are implemented outside Haskell, yes
12:35:15 <JohnMeacham_> ah, they arn't special still, if you look at the GHC library sources, Array and IO are defined just like other haskell types, their internals just arn't exposed in the standard to allow leeway for compilers to choose their best representaion.
12:35:16 <monochrom> unboxed arrays are pretty optimized.
12:35:29 <atp> Baughn: that's really all i was curious about... because the haskell report talked about functions that are bijective to a subset of the natural number line and i thought, hm, maybe there's some voodoo that you can do to get O(1) with just elementary haskell
12:36:04 <monochrom> the haskell report doesn't talk about implementation.
12:36:23 <SamB> JohnMeacham_: not just like other Haskell types
12:36:35 <SamB> they use primitives that aren't in the Report
12:36:51 <JohnMeacham_> for instance, in jhc, IO is newtype IO = IO (World -> (World,s))
12:37:01 <atp> ghc as well, i think
12:37:06 <atp> according to peyton-jones
12:37:19 <monochrom> Too many chefs.
12:37:19 <Heffalump> Peyton Jones, not Peyton-Jones
12:37:30 <atp> sorry, thanks.
12:37:39 <SamB> that is a very odd last name
12:37:49 <atp> pretty smart guy though...
12:38:01 <SamB> how is one supposed to tell that Peyton isn't a middle name?
12:38:08 <Saizan> ?src Data.Array.Base
12:38:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:38:14 <JohnMeacham_> SamB: hrm? that is still just like in the report, just like including a library that provides things not in the report doesn't make a haskell program no longer haskell.
12:38:18 <Saizan> ?source Data.Array.Base
12:38:19 <lambdabot> Data.Array.Base not available
12:38:33 <SamB> JohnMeacham_: have you seen Addr# in the report?
12:38:53 <atp> it's not really about whether it's haskell or not... i just wanted to understand the math
12:39:37 <JohnMeacham_> SamB: no, but Word32 isn't in there either, but we use it. It doesn't matter if it is in the report or not, what matters is that it behaves in the way the type system demands it does and that the haskell compiler doesn't treat it specially in any way.
12:40:07 <JohnMeacham_> Addr is no more special than Int, just because it isn't in the report, it doesn't bestow it some magical powers.
12:40:17 <SamB> JohnMeacham_: Word32 is at least de-facto standard
12:40:34 <sjanssen> Addr# is more special -- it's an entirely different kind!
12:40:35 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
12:40:44 <sjanssen> not to mention the # suffix
12:40:57 <SamB> Addr# is the same kind as Int#, but I think Addr# is even more specialer
12:41:08 <monochrom> JohnMeacham_ states "IO defined just like other haskell types". SamB states "they use primitives not in the report". Is there supposed to be a contradiction? I don't see a contradiction. IO is defined just like other haskell types, the RHS of the definition uses RealWorld# which is not in the report. What is the disagreement?
12:41:23 <JohnMeacham_> sjanssen: indeed. but that is just the way ghc happens to do it.
12:41:36 <SamB> monochrom: well, in a standard program you can't do that ;-)
12:42:25 <monochrom> No, no one refutes that.
12:43:02 <JohnMeacham_> jhc also supports the unboxed types type extension. It is quite a nice extension and fairly straightforward, thouhh, I don't think it should go in haskell'. perhaps unboxed tuples though, there isn't much disagreement about how those should work.
12:43:08 <atp> at some point though, you have to recognize that you're on a von neumann architecture and that programs are ultimately about side effects... you can't be purely functional all the way to the bottom
12:43:30 <atp> so it should surprise no one that in the compiler there's a lot of strange voodoo :)
12:44:09 <Baughn> atp: That's what IO is for. Composing nice, imperative programs.
12:44:27 <Baughn> Haskell's not that badly off even if you interpret it. :)
12:44:35 <monochrom> Can computing be freed from the von Neumann architecture?
12:44:37 <JohnMeacham_> atp: actually, grin is purely functional, which is the lowest level of code in jhc. I wrote a mailing list post about how to extend the pure functionality all the way to assembly.. but I have not implemented it yet, I am avoiding writing my own C-- compiler so far.
12:44:37 <atp> yeah, Haskell is pretty bloody crazy
12:44:52 <atp> monochrom: were those old symbolics lisp machines von neumann on the inside?
12:45:18 <Baughn> Depends on what parts of the architecture you consider essential
12:45:39 <Baughn> Technically, /nothing/ is von neumann, seeing as they uses the same memory for code and data
12:45:48 <monochrom> I am beginning to consider a G-machine at the physical level.
12:45:52 <atp> i thought that was the point of von neumann architectures
12:46:00 <atp> perhaps i'm getting my terminology wrong?
12:46:20 <JohnMeacham_> atp: Yes, I believe they just had special hardware-checked tag-bits for deciding what was a pointer, a cons cell, or a value or whatnot. so, it was a pretty straight shot from lisp to the symbolics lisp architecture... though. hmm.. I can't remember if they has special support for atoms..
12:46:42 <JohnMeacham_> though. I could be getting my crazy architectures confused.
12:47:13 <Baughn> atp: ..you're right. I wonder what I'm remembering?
12:47:35 <monochrom> I'm going to describe my imaginative realization of the G-machine on the haskell-cafe mailing list. May chaos be with you.
12:47:45 <atp> Baughn: i don't know... i really don't know much about that low level stuff, unfortunately :/
12:47:50 <Saizan> you could have data Array i e = A1 e | A2 e e | A3 e e e | A4 e e e e | A5 e e e e e | ....., not as efficient as using memory directly but i'd say it's O(1) indexing
12:47:56 <Baughn> Still, I can point to I/O not going directly to the ALU's accumulator as evidence for modern computers not being von neumann. ^_^;
12:48:02 <JohnMeacham_> you are thinking of 'harvard architecture' like the PIC micros.
12:48:18 <Baughn> Saizan: Problem is, that's an infinite type
12:48:24 <Baughn> Haskell not like such
12:48:32 <atp> JohnMeacham_: those lisp machines were pretty cool :)
12:48:52 <atp> we should make a haskell machine
12:48:53 <Saizan> nah, you just go up till 2^30 or such :)
12:48:56 <atp> *grin*
12:49:18 <JohnMeacham_> we had a few in the lab at caltech. i should have grabbed one when they were throwing them out. I am sure someone claimed them and brought them to  a good home.
12:49:18 <Heffalump> yeah, just get the hardware to synthesise more hardware for all those suspended computations :-)
12:49:49 <Baughn> The same optimizations done in lisp machines would apply. It's mostly tag bita
12:49:51 <Baughn> *bits
12:49:54 <Saizan> we have nanomachines for a reason, no?
12:50:05 <atp> JohnMeacham_: my stepdad used to have one, but he donated it to the computer history museum here in silicon valley... it was the first or second off the assembly line so it's on display there
12:50:09 <Baughn> Saizan: We do?
12:50:24 <JohnMeacham_> atp: I have thought about that.. with an FPGA, it wouldn't be that hard to prototype. but I am not sure what you would need/want. I suppose some tag bits would be nice.
12:50:35 <Baughn> Saizan: Actually, given the presumed ~75kWh energy cost to make a /single/ kg of processors, I don't think that's very practical. ;)
12:50:57 <Baughn> JohnMeacham_: Tag bits are so nice, intel's planning to add them to their next architecture overhaul
12:50:58 <JohnMeacham_> atp: and perhaps something for the GC memory barriers that is less heavyweight than mprotect and paging, but that is more of an OS issue.
12:51:07 <atp> JohnMeacham_: yeah... tag bits would be necessary, i'm sure... but i'll freely admit that i don't know nearly enough to manage something like that
12:51:49 <Heffalump> you probably want the architecture to be clever about pre-fetching based on the pointers in tagged words, too
12:51:54 <atp> well listen guys, thanks for the great conversation, ima have lunch :)
12:52:06 <atp> see you all later, and thanks for the info on Array
12:52:08 <JohnMeacham_> jhc's 'fgrin' back end does a sort of semi-tagging, but only to avoid things that would be memory indirections otherwise (or in ghc) so it is a guarenteed win. the type system guides where they are used so it isn't an all or nothing thing.
12:52:26 <Baughn> Heffalump: x86 already prefetches anything that looks like a pointer. It'd have to be clever about /not/ prefetching instead
12:52:45 <JohnMeacham_> http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/data/jhc_rts2.c
12:52:48 <lambdabot> Title: darcs - jhc, http://tinyurl.com/2zml3q
12:52:56 <pitecus> i just updated GHC from 66 to 661 and it can no longer find the binary library i had installed
12:53:01 <pitecus> is that normal?
12:53:10 <SamB> Baughn: yes, but what if you have tags in the upper bits of a pointer?
12:53:14 <Igloo> pitecus: Yes
12:53:16 <Baughn> pitecus: Yes. It isn't binary-compatible
12:53:34 <Baughn> SamB: A very good argument for using tag 0 for pointers
12:53:36 <pitecus> *sigh*
12:53:56 <SamB> Baughn: true
12:54:01 <Baughn> pitecus: Don't worry. Your problems have only just started.
12:54:16 <pitecus> Baughn, what do you mean?
12:54:27 <Saizan> it's normal in the sense that each instance of ghc needs its own installation of each library, you just have to reinstall it
12:54:42 <Baughn> pitecus: A lot of things aren't source-compatible either. ^_^;;
12:54:56 <Baughn> And lambdabot fails because the version #define hasn't been bumped
12:55:04 <pitecus> Baughn, i think its the only library i use which doesnt come with GHC
12:55:06 <JohnMeacham_> Baugn: yup, exactly why I use tag 0 for pointers :) well, most pointers at least. but the tags are in the bottom bits anyway, since arches like the x86-64 have signed addresses making the top bits inconvinient to use.
12:55:22 <Baughn> pitecus: You might be okay then. Good luck once you start wanting dozens.
12:55:41 <pitecus> Baughn, I always try to resist the temptation
12:55:52 <Baughn> JohnMeacham_: Only problem is, you also want tag-0 for integers to make arithmetic faster
12:56:07 <Baughn> The solution is to aggressively optimize to unboxed types
12:56:15 <Saizan> (most notably programs that import Data.Binary don't link with HEAD)
12:56:22 <bringert> hej shapr
12:56:23 <SamB> I wish they would either (a) quit breaking source compatibility in point releases or (b) quit refusing to bump the version #define
12:57:04 <Baughn> SamB: It's got too few digits. I prefer (c) Add a new version #define based on the patch count
12:57:29 <SamB> Baughn: hmm?
12:57:47 <Baughn> SamB: The current version is 606. That works for 6.6, but what would you call 6.6.1?
12:58:10 <JohnMeacham_> Baugn: no need in jhc, the tag is only used when a lazy thunk would have been otherwise, so the cost of taged arithmetic is still way way less than otherwise. unboxed things are not taged in any way, just like ghc. a nice advantage of having strong types right up to code generation.
12:58:22 <Baughn> SamB: A patch counter has the distinct advantage that arithmetic keeps working
12:58:39 <Igloo> SamB: What change is causing you problems?
12:59:06 <SamB> Igloo: nothing right now
12:59:19 <SamB> but Baughn just said lambdabot has some
12:59:43 <Baughn> Yes. Actually, I've got a large number of local patches, let me see.
13:00:56 <Baughn> The #if __HASKELL_GLASGOW__ bits in Lib/Parser.hs need to all be on in 6.6.1; one of them goes "if higher than 606"
13:01:24 <Baughn> scripts/RunPlugs.hs includes Monad.Writer instead of Control.Monad.Writer for no apparent reason
13:01:49 <Baughn> I had to remove a duplicate instance from ShowQ.hs - no idea what that will cause, but it seems to work
13:01:52 <Igloo> Baughn: What changed between 6.6 and 6.6.1 to cause a problem in Lib/Parser.hs?
13:02:44 <Baughn> Igloo: I have no idea. The code works around it, but the #if fails because there was no version bump
13:03:01 <Baughn> Anything that breaks source compatibility really should at least bump the minor version. :/
13:03:31 <Igloo> Well, I can't comment without actual examples of problematic changes
13:03:45 <Baughn> I only know how to fix it, not why it breaks
13:04:34 <SamB> Baughn: how do you fix it?
13:04:42 <SamB> and what happens if you don't?
13:04:50 <Baughn> SamB: By removing the #if on line 8236
13:05:06 <Baughn> If I don't, I get a missing symbol error - as_name and friends
13:05:39 <Baughn> Said #if is clearly meant to cover changes since 6.6, though
13:06:36 <pitecus> cabal seems to recompile every library for each executable thats included int he cabal file...
13:09:54 <JohnMeacham_> yeah... cabal needs some serious overhauling.
13:10:37 <Baughn> Perhaps, but changing defaultMain's signature wasn't nice. :/
13:11:34 <Heffalump> does cabal have any way to change the name of the .setup-config file?
13:15:09 * ski just misread 'mutated' as 'mutilated' ..
13:43:21 <sphynx> chessguy, are you still here?
13:43:27 <chessguy> ya
13:43:39 <sphynx> could you please take a look on my realization with State?
13:43:59 <sphynx> it seems that it is a bit ugly and hackerish :)
13:44:06 <chessguy> !paste
13:44:07 <hpaste> Haskell paste bin: http://hpaste.org/
13:44:10 <sphynx> ok
13:44:33 <dcoutts> ndm_: see you tomorrow! :-)
13:44:39 * dcoutts -> Cambridge
13:44:40 <quicksilver> ski: Haskell, the language without mutilateable data structures? :)
13:45:15 <hpaste>  sphynx pasted "Postfix evaluator with State monad" at http://hpaste.org/1867
13:46:22 <sphynx> I have implemented push, pop and evalOne functions (evalOne is based on push and pop) with State monad
13:52:37 <sphynx> chessguy, have you seen?
13:52:55 <chessguy> sorry, i'm in the middle of something right now. i'll look shortly
13:54:50 <sphynx> chessguy, sure, no problem
13:55:33 <mux> heh, no wonder haskell scares newbies, when you read the description of Control.Applicative for instance :-)
13:55:39 <Saizan> sphynx: what do you find hackerish?
13:55:52 <mux> [...] (Technically, a strong lax monoidal functor.)
13:56:52 <Saizan> ?docs Control.Applicative
13:56:53 <lambdabot> Control.Applicative not available
13:57:36 <chessguy> you can handle the case statement with pattern-matching
13:57:43 <chessguy> that would probably be more idiomatic
13:58:28 <sphynx> Saizan, hm, maybe its overstatement, I simply don't know how it should be :) Cause it's my first program using State monad :)
13:58:55 <chessguy> otherwise, the only comment i would make is that it could of course be more polymorphic
13:59:33 <chessguy> i.e. data Stack a = Stack [Token a]; data Token a = Atom a | Op (a -> a -> a)
13:59:41 <sphynx> chessguy, do you mean case in evalOne? Sure, you're right
13:59:48 <chessguy> yes
14:00:16 <olsner> omg, chekov is about to hand over Auxiliary Control to the bad guys!
14:00:47 <Saizan> and push x = modify (\(Stack xs) -> Stack (x:xs)), actually iy would be easier with just a list, push x = modify (x:)
14:01:35 <sphynx> chessguy, OK, it soungs good - about polymorhic
14:01:42 <ndm_> dcoutts yep, see you then, although i get a free lunch
14:02:01 <ndm> Heffalump will be there too
14:02:15 <sphynx> Saizan, modify is something like combined get and put, yeah?
14:02:49 <Saizan> yeah, modify f = do { s <- get; put (f s) }
14:03:47 <Saizan> or = do { s <- gets f; put s } :)
14:03:55 <sphynx> Saizan, chessguy but general way of using State is correct in my code, am I right?
14:04:07 <Saizan> i think so
14:04:20 <sphynx> Saizan, cool! :) I'm very glad )
14:04:29 <chessguy> sure
14:05:16 <sphynx> and it seems that runState needs to be called only once in general case?
14:05:48 <sphynx> when all helper functions are set and called in right order
14:06:09 <Heffalump> indeed.
14:06:14 <sphynx> by 'helper functions' I mean pop, push, evalOne here
14:06:21 <chessguy> sphynx: i'm assuming you've tested it. i didn't really look for bugs
14:06:26 <chessguy> i was more looking for style
14:06:54 <sphynx> chessguy, yeah, there is some bugs with handling of Incorrect expression, but it doesn't matter for now
14:07:02 <sphynx> it works good for correct expressions
14:07:26 <sphynx> chessguy, your opinion about style was quite interesting for me
14:24:11 <Saizan> ?type \m1 m2 f ->  m1 >>= \x -> m2 >>= f -- is there a nicer way to write this?
14:24:26 <lambdabot> thread killed
14:24:32 <Saizan> ?pl \m1 m2 f ->  m1 >>= \x -> m2 >>= f
14:24:33 <lambdabot> (. ((const .) . (>>=))) . (.) . (>>=)
14:24:44 <Saizan> ?pl \f m1 m2 ->  m1 >>= \x -> m2 >>= f
14:24:45 <lambdabot> flip ((.) . (>>=)) . (const .) . (=<<)
14:24:53 <Heffalump> do { x <- m1 ; y <- m2 ; f y }
14:25:05 <Heffalump> with the lambdas, obviously
14:25:19 <Heffalump> and presumably the x is actually ignored
14:25:29 <Saizan> oh
14:25:38 <Saizan> forgot it..
14:25:43 <cdsmith> @redo \f m1 m2 ->  m1 >>= \x -> m2 >>= f
14:25:45 <lambdabot> \ f m1 m2 -> do { x <- m1; a <- m2; f a}
14:25:47 <Saizan>  \m1 m2 f ->  m1 >>= \x -> m2 >>= f x
14:25:58 <Heffalump> oh, I didn't know about redo :-)
14:26:04 <cdsmith> @redo \f m1 m2 ->  m1 >>= \x -> m2 >>= f x
14:26:04 <lambdabot> \ f m1 m2 -> do { x <- m1; a <- m2; f x a}
14:26:06 <Heffalump> well, make the obvious modification
14:26:38 <Saizan> yeah, i'll just give a name to this
14:29:02 <Heffalump> @redo \f m1 m2 -> liftM2 (,) m1 m2 >>= uncurry f
14:29:03 <lambdabot> \ f m1 m2 -> do { a <- liftM2 (,) m1 m2; uncurry f a}
14:29:22 <Heffalump> that expression should be the same too, if you like it more
14:29:40 <Heffalump> @pl \m1 m2 f -> liftM2 (,) m1 m2 >>= uncurry f
14:29:40 <lambdabot> flip flip uncurry . (((.) . (>>=)) .) . liftM2 (,)
14:29:52 <Heffalump> and if you just reorganise your arguments a bit, you get that beauty ;-)
14:57:26 <jmanson> Hello. I have a question.
14:57:32 <stepcut> in HaXml, how do I make a filter that just appends an element to a list of elements ?
14:58:28 <Saizan> jmanson: ask yours too, we like to parallelize! :)
14:58:54 <Mayreel> stepcut: isn't it (|||)?
15:00:18 * stepcut looks
15:02:54 <stepcut> :t (|||)
15:02:58 <jmanson> I have a program where I want to read a number of files, and the files will never be modified during the running of the program. Any given file will also (if written naively) be read in multiple times. Since this is the case, it seems like what would make the most sense is to leverage Haskell's lazy evaluation to have the file read in only the first time that the function to read a particular file is called. It see
15:02:58 <jmanson> ms to me that what is required then is to have the function not return the IO monad, but to use it internally. Is that the correct solution to my problem? If so, how does one go about solving it (unsafePerformIO)?
15:03:02 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
15:04:54 <stepcut> jmanson: I would just use readFile, do { contents <- readFile ; return (somePureFunction contents) }
15:05:52 <jmanson> stepcut: That isn't really an option I think. I am using a library function to read in am image. (I may be horribly confused though)
15:06:11 <sorear> hello.
15:06:12 <lambdabot> sorear: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:06:16 <sorear> @messages
15:06:17 <lambdabot> kc5tja said 6h 20m 18s ago: Wow, dude, (digit>int) is completely unnecessary. That IS pretty brute-force code. :D
15:06:17 <lambdabot> kc5tja said 5h 19m 26s ago: I need your e-mail address so I can darcs send you a patch or two.
15:06:17 <lambdabot> kc5tja said 4h 43m 45s ago: Your resolve, word is weird to me; I would have defined words like .ifcc or .ifeq, .then, and .else too if necessary. Just me though. :)
15:07:03 <jmanson> Specifically, I am using loadBMP from the hsSDL library.
15:07:07 <ddarius> sorear: Are you doing things in crackheaded ways?
15:07:24 <sorear> apparently?
15:07:55 <ddarius> jmanson: If you are in IO already maybe just throw things into a HashTable (or a hash set if there is one and it is appropriate).
15:11:45 <Mayreel> ghc-6.6: unknown package: text
15:11:48 <Mayreel> that's a bad thing, right
15:11:54 <jmanson> I am in IO already. That sounds like a good solution. I just thought that there might be a cleaner way to handle the problem in Haskell to not have to explicitly specify how to be efficient about storage.
15:11:58 <mux> can someone clue me in as to what are the meaning of the different Strategy r0, rwhnf, rnf?
15:12:14 <Igloo> Mayreel: The thing you're trying to compile is very out if date
15:12:16 <jmanson> err.. ddarius /\
15:12:35 <sorear> mux: Yes.
15:12:42 <sorear> mux: it's all in the type
15:12:52 <sorear> type Strategy a = a -> ()
15:13:00 <sorear> rwhnf x = x `seq` ()
15:13:02 <ddarius> :t r0
15:13:02 <mux> a -> Done yeah
15:13:04 <mux> with Done = ()
15:13:08 <mux> aaah
15:13:12 <lambdabot> forall a. a -> Done
15:13:20 <mux> @src rnf
15:13:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:13:24 <sorear> mux: so rhwnf seqs its arg;  rnf deepSeqs it; ....
15:13:32 <mux> okay
15:13:33 <sorear> @src NFData
15:13:33 <lambdabot> Source not found. That's something I cannot allow to happen.
15:13:35 <mux> what does r0 do?
15:13:38 <sorear> mux: Nothing
15:13:43 <mux> ok, lazy
15:13:44 <ddarius> rwhnf = reduced to weak head normal form rnf = reduce to normal form
15:13:50 * mux nods
15:13:51 <mux> thanks guys
15:14:06 <ski> > r0 undefined
15:14:12 <lambdabot>  ()
15:14:20 * ptolomy is wasting company time trying to do phantom types in C++.
15:14:30 <ddarius> ptolomy: It should be trivial...
15:14:55 <sorear> Wow.  I just got chinese spam and I can actually see the characters!
15:15:06 * sorear likes working UTF8
15:15:26 <mux> sorear: we receive an insane amount of image spam at my company :-/
15:15:30 <ptolomy> ddarius: Well, I've been avoiding template-trickery because I want readable error messages, but I think I"m just being silly.
15:15:56 <sorear> mux: My email client doesn't support images
15:15:58 <mux> maybe 90% of all the emails going through are spam
15:16:21 <ddarius> ptolomy: It shouldn't require trickery (or at least the trickery is application specific), but it does require templates.
15:16:24 <mux> SA does a decent job though
15:16:43 <sorear> @seen kc5tja
15:16:43 <lambdabot> kc5tja is in #haskell. I last heard kc5tja speak 4h 54m 12s ago.
15:16:47 <ddarius> My email client doesn't display images unless requested.
15:18:13 <jmanson> Also, the thing I originally suggested, if I understand correctly lets me just store the image wherever I want an image. With the hash table solution, I would need to store the file name to look up the image which both adds another level of indirection, and disallows getting loading the images from diverse locations. For example, what if I want to define a function to generate the images within the program. How wou
15:18:13 <jmanson> ld I store that in the hash table as a string?
15:19:08 <mux> sorear: do you know how rnf is implemented? I saw someone using "when (foo == foo)" for that once but that's monadic
15:19:09 <ddarius> Well, why would you be loading the same image multiple times?
15:19:19 <mux> sorear: I could look it up, but in case you don't mind.. :)
15:19:29 <ddarius> mux: The main problem with that is that it adds an Eq constraint.
15:19:36 <ddarius> rnf is a member of a class
15:19:40 * mux nods
15:19:41 <mux> that too
15:19:58 <sorear> mux: think == - how do you implement that for all types/
15:20:04 <jmanson> The images are going to be used for tiles in my game. I will have far more spaces in my tile grid than different images to fill the grid with.
15:20:13 <sorear> mux: it can't be done (w/o violating various nice properties)
15:20:33 <ddarius> jmanson: So why would you be reloading tiles?  Just load the tiles and reference them.
15:20:37 <mux> yeah, I agree this way is bad, or at least bad in that it can't cover the generic case
15:20:51 <sorear> mux: ocaml's == dies with a runtime error if there are any functions in the objects you pass it
15:20:53 <mux> but I'm not sure how you could deepSeq anything without having a notion of the type
15:20:59 <ddarius> rnf is done on a type by type basis.
15:21:06 <ddarius> @src NFData
15:21:06 <mux> oh
15:21:07 <lambdabot> Source not found. Where did you learn to type?
15:21:07 <sorear> mux: do you know how == is implemented in Haskell?
15:21:12 <mux> sure, type classes
15:21:15 <mux> ddarius: ok, thanks
15:21:21 <sorear> mux: that's how rnf is implemente.d
15:21:28 <mux> yeah, got it now, thanks
15:21:36 <jmanson> ddarius: but how would I reference them? give each tile a unique id and then have to keep track of ids?
15:21:48 <mux> @instances NFData
15:21:57 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
15:22:01 <ddarius> jmanson: loadBMP returns something, just keep track of that.
15:22:20 <jmanson> It returns something of type Surface.
15:22:35 <ddarius> So have tiles contain the Surfaces that display them.
15:23:30 <jmanson> That is what I want to do. But, I am afraid that if I do so and just call loadBMP "tile1.bmp" 10 times that I will wind up with 10 copies of the image.
15:24:20 <jmanson> Since it is in IO, doesn't Haskell have to assume that the file contents could have changed since last call?
15:25:06 <sorear> Don't call loadBMP ten times.
15:25:36 <sorear> Even if it was pure GHC does *not* memoize
15:25:53 <sorear> Ever.  It's a win too infrequently to be worth trying
15:26:12 <jmanson> sorear: Really? That makes me sad :(
15:26:21 <sorear> really
15:27:09 <jmanson> So, fib x = (fib x-1) + (fib x-2) takes exponential time?
15:27:10 <monochrom> Hahahahaha, I have unleashed a monster to the haskell-cafe mailing list.
15:27:35 <Saizan> jmanson: exactly
15:27:39 <ddarius> jmanson: Why would you call loadBMP multiple times?
15:27:39 <sorear> jmanson: No, it takes infinite time.
15:27:44 <DRMacIver> monochrom: What have you done? :)
15:27:48 <jmanson> right, no base case...
15:27:48 <TSC> Can anyone tell me how to change the shape of the mouse cursor in gtk2hs?
15:27:53 <mux> a G machine?
15:27:56 * mux reads on
15:28:01 <monochrom> A biological G machine.
15:28:15 <sorear> TSC: use a magnet?
15:28:21 <monochrom> Err, a fantasy about a biological G machine.
15:29:06 <TSC> sorear: I'd like to do it with software
15:29:08 <jmanson> So, there isn't some sort of flag to force memoization? Like a strictness flag?
15:30:13 <sorear> jmanson: Nope.  other than "use arrays"
15:30:53 <ddarius> monochrom: Have you looked at Amorphous computing and Regiment?
15:31:16 <jmanson> Ok, off the topic of memoization, is the hash table in Haskell constant time insertion and lookup?
15:31:40 <sjanssen> Data.HashTable is
15:31:46 <monochrom> No, I haven't.
15:31:56 <sjanssen> but it has some bad constant factors
15:32:08 <jmanson> sjanssen: how bad is bad?
15:32:43 <sjanssen> jmanson: Data.Map (or Data.IntMap) is usually faster
15:33:43 <jmanson> sjanssen: How costly is it to use a string as a key vs. an Int?
15:33:53 * mux guesses r0 is const ()
15:35:01 <Saizan> There may also be better but totally different ways to
15:35:04 <Saizan> realize a native G-machine.
15:35:09 <Saizan> :D
15:35:54 <sorear> A native G machine is an *intrinsically bad idea*
15:36:13 <sorear> Since, the G machine is not the work of lazy FP.
15:36:25 <SamB> sorear: I suppose this is unrelated to the fact that it wouldn't run videogames?
15:37:00 <sorear> The G machine is the work of the devil Johnsson, and it was created specifically for use on von neumann computers.
15:37:36 <SamB> so, what kind of machine would you suggest?
15:37:41 <sorear> If you can control the hardware, you can do better and avoid G's many hacks
15:37:47 <SamB> von neumann computers are so passe
15:37:55 <sorear> SamB: Parallel graph reduction?
15:38:15 <SamB> speaking of which, what is that new kind of computer called anyway?
15:38:23 <monochrom> Vista
15:38:28 <SamB> ...
15:38:32 <monochrom> hehehehe
15:38:49 * SamB impersonates Crono
15:38:53 <SamB> !
15:40:42 <mux> sorear: what about that spineless tagless G-machine SPJ wrote a paper about?
15:42:21 <DRMacIver> Hm. There's a webterface for the haskell mailing list, right?
15:45:09 <sorear> mux: that's even more VN specific
15:46:39 <ddarius> CHAM
15:46:58 <monochrom> DRMacIver: try http://www.haskell.org/pipermail/haskell-cafe/2007-May/025503.html
15:47:00 <lambdabot> Title: [Haskell-cafe] Imagining a G-machine, http://tinyurl.com/26stha
16:02:39 <davidL> is "" foldl' (*) 1 (flip replicate 3948 5372) "" faster than 3948^5372
16:02:59 <ddarius> It shouldn't be, but it might be.
16:03:02 <ddarius> :t foldb
16:03:05 <lambdabot> Not in scope: `foldb'
16:03:27 <davidL> binary folding would be faster
16:04:17 <davidL> eh, about the same
16:05:03 <sorear> (^) uses squaring
16:05:22 <davidL> what do you mean?
16:05:35 <davidL> ?src (^)
16:05:35 <lambdabot> Source not found. My mind is going. I can feel it.
16:05:42 <sorear> davidL: what is your obsession with 3948^5372 ?
16:05:54 <davidL> have I done that before?
16:05:56 <ddarius> 2^2n = (2^n)^2
16:06:03 <sorear> davidL: Yes.
16:06:09 <davidL> wow
16:06:42 <davidL> I'm going to search the irc logs
16:06:47 <davidL> ?logs
16:06:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:06:54 <davidL> ...
16:06:57 <davidL> @where log
16:06:58 <lambdabot> I know nothing about log.
16:07:00 <davidL> @where logs
16:07:01 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
16:07:17 <jmanson> I've got a quick question. I want to use the result from an IO operation in something else. Right now, the only solution I have come up with is to store the result in an intermediate variable with <-, then use that. How can I do the same thing without using an intermediate? The only thing that matches IO a -> a is unsafePerformIO, but I somehow doubt that is what I'm looking for.
16:07:20 <emu> > 66792 / 3600
16:07:32 <lambdabot>  18.553333333333335
16:07:39 <emu> jmanson: >>=
16:08:04 <emu> v <- ioOp is short for ioOp >>= \v -> ...
16:08:38 <jmanson> emu: I'll try that. Thanks.
16:08:54 <emu> getLine >>= putStrLn
16:10:35 <jmanson> emu: I'm having trouble still. Does >>= work when I want to pass into a data constructor?
16:10:57 <sorear> Data constructors are ordinary functions!
16:11:09 <sorear> besides, >>= is the primive.  do is sugar
16:11:43 <sorear> and there is a vocal minority that says do is just too obfuscatory to be taught to newbies
16:11:52 <sorear> @google do notation considered harmful
16:11:54 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
16:11:55 <lambdabot> Title: Do-notation considered harmful « Data.Syntaxfree
16:12:03 <SamB> @go considered harmful considered harmful
16:12:05 <lambdabot> http://meyerweb.com/eric/comment/chech.html
16:12:05 <lambdabot> Title: "Considered Harmful" Essays Considered Harmful
16:12:43 <DRMacIver> Metahumour considered harmful
16:12:46 <gwern> now we need an essay arguing against that one, with the view that pointing out harmful things is a useful thing to do
16:12:53 * sorear thinks SamB has that on a script
16:13:05 <dibblego> @google knob heads considered hamrful
16:13:06 <lambdabot> No Result Found.
16:13:11 <monochrom> getChar >>= liftM Just >>= print   -- try this
16:13:11 * dibblego gets writing
16:13:15 <gwern> it would be entitled ""Considered Harmful" Essays Considered Harmful" Considered Harmful", if I may modestly suggest so
16:13:21 <SamB> sorear: what? it would take longer to remmber what the script was called than it would to type that
16:13:35 <sorear> SamB: I meant automatic.
16:13:39 <SamB> gwern: you have unbalanced quotes
16:13:55 <SamB> sorear: and *that* would be too much work
16:14:08 <sorear> besides, what good does it do if syntaxfree isn't here to hear it?
16:14:41 <procyon112> Higher order harmful calculi
16:14:42 <SamB> well, it is useful to warn the reader ;-P
16:15:17 <monochrom> Programming languages considered harmful.
16:15:22 <gwern> SamB: I don't believe in nesting ' and ", and damn the consequences!
16:15:32 <monochrom> Hell, programming language tutorials considered harmful.
16:15:42 <SamB> gwern: and three on the right match two on the left?
16:15:47 <sorear> SamB: how does the reader need to be warned?
16:16:03 <jmanson> Ok, lets say I have data Data = Data {elem :: Int}, and want to get a Data
16:16:23 <gwern> SamB: hmm. good point.
16:16:41 <jmanson> would: getData = return (getInt >>= Data) work?
16:16:47 <gwern> """Considered Harmful" Essays Considered Harmful" Considered Harmful" <-- there, better?
16:17:14 <nominolo> @seen dcoutts
16:17:14 <lambdabot> dcoutts is in #haskell, #ghc, #haskell-overflow and #gentoo-haskell. I last heard dcoutts speak 2h 32m 35s ago.
16:17:21 <jmanson> where getData :: IO Data
16:18:28 <sorear> jmanson: Data `fmap` getInt
16:18:35 <procyon112> data Harmful a = Harmful a | Metaharmful a Harmful deriving (Show, Considered) -- that oughtta cover it.
16:19:01 <Saizan> kind error!
16:19:01 <sorear> Harmful essays metaconsidered Show
16:19:16 <jmanson> sorear: no >>= is used?
16:19:23 <gwern> > data Harmful a = Harmful a | Metaharmful a Harmful deriving (Show, Considered)
16:19:23 <lambdabot>  Parse error
16:19:42 <gwern> (guess metaharmful isn't defined)
16:19:44 <sorear> jmanson: you don't need it here, you can use the less general form fmap
16:20:16 <ddarius> > fix (++" Considered Harmful")
16:20:20 <Saizan> jmanson: you could have used getInt >>= (return . Data) but you can substitute with fmap or liftM
16:20:22 <lambdabot>  Exception: <<loop>>
16:20:39 <procyon112> Make it a Monad, then we can just shove anything into the Harmful Monad and isolate it.
16:20:42 <sorear> CURRY!
16:21:36 <edwardk> Metaharmful?
16:21:52 <davidL> :t getInt
16:21:56 <lambdabot> Not in scope: `getInt'
16:22:11 <jmanson> Saizan: liftM? Oh man. feel like i may have been close when I was tring lift earlier.
16:22:24 <DRMacIver> ddarius: Presumably you meant > fix ("Considered harmful" ++)
16:22:39 <Saizan> lift is very different from liftM
16:22:44 <int-e> DRMacIver: that wouldn't be harmful ;)
16:23:11 <Saizan> and for a Monad which is also a Fuctor, liftM = fmap
16:23:22 <int-e> > 'C' : cycle "onsidered harmful "
16:23:36 <lambdabot>  "Considered harmful onsidered harmful onsidered harmful onsidered harmful on...
16:23:44 <Saizan> (lift is used with monad transformers)
16:24:18 <DRMacIver> > fix ("considered harmful" ++)
16:24:26 <lambdabot>  "considered harmfulconsidered harmfulconsidered harmfulconsidered harmfulcon...
16:24:29 <DRMacIver> Oops
16:25:02 <int-e> > 'C' : cycle "onsidered harmful c"
16:25:10 <lambdabot>  "Considered harmful considered harmful considered harmful considered harmful...
16:25:13 <int-e> that's what I wanted
16:26:14 <gwern> hee hee
16:28:45 <sioraiocht> is the endianness of haskell dependent upon the platform?
16:29:26 <ndm> sioraiocht: yes, but you'll rarely see it seeping through
16:29:35 <sioraiocht> okay, thanks
16:32:03 <dons> > 1+@
16:32:07 <dons> > 1+2
16:32:10 <lambdabot>  Parse error
16:32:16 <lambdabot>  3
16:32:17 <dons> > 1
16:32:21 <dons> ok. good.
16:32:26 <lambdabot>  1
16:32:32 <ndm> dons, did you get my xmonad report?
16:32:39 <Igloo> @version
16:32:44 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
16:32:48 <dons> ndm, I did!
16:32:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:32:51 <sorear> dons: Hello!
16:32:55 <Igloo> Oh, not testing a 6.6.1 upgrade then
16:32:55 <dons> hey everyone.
16:33:04 <dons> Igloo: nah, just had been up too long :}
16:33:09 <sorear> what's new?
16:33:26 <ddarius> "Hi, everybody!" "Hi, Dr. Nick!"
16:33:27 <dons> xmonad is a zipper :)
16:34:26 <sorear> ndm: Did we get the entry for derive to HCAR in time?
16:34:58 <ddarius> Great case study: "Even grungy programs are the pretty theoretical things Haskell programmers ogle."
16:35:04 <twobitsprite> this is kind of like walking into mcdonalds and asking where the nearest burger king is, but... is there an IRC channel somewhere for the Clean langauge?
16:35:08 <ndm> sorear, we did, plenty of time
16:35:38 <ndm> sorear, i still want a proper release, but other things have priority for me right now...
16:35:58 <gwern> twobitsprite: clean is dead to us! DEAD
16:36:23 <twobitsprite> gwern: who killed it?
16:36:24 <ndm> Clean is a very cool language
16:36:39 <sorear> Clean doesn't compete with us.  It is Too Small
16:36:44 <gwern> twobitsprite: I did, with my little bow and arrow. I killed Clean.
16:36:47 <ndm> the ABC machine is very nice, as good as the G-Machine, if not better
16:36:55 <ddarius> Clean is about as cool a language as Haskell that a lot of cool work is done in.
16:37:26 <dons> s/is/was/ mwhaha
16:37:27 <sorear> Do they have anything like hackage?
16:37:38 <twobitsprite> ya know... I would love haskell if it wasn't for the laziness... for some reason that really bothers me... ohh, and the purism...
16:37:53 <dons> twobitsprite: grab some ! and you get strict and lazy eval.
16:37:54 <ddarius> twobitsprite: So you want to go to Clean?
16:38:01 <procyon112> Isn't clean lazy and pure??
16:38:02 <sorear> twobitsprite: Clean is lazy and almost pure.
16:38:09 <twobitsprite> is it?
16:38:14 <dons> yeah.
16:38:14 <monochrom> Clean is clean.
16:38:18 <twobitsprite> see, I don't know, which is why I was looking for a place to ask
16:38:18 <gwern> uniqueness types don't make it pure?
16:38:33 <sorear> gwern: Clean doesn't use them enough.
16:38:43 <twobitsprite> anyways... I'm looking for ocaml with haskell syntax and libs :P
16:38:50 <ddarius> twobitsprite: Clean is about the only other significant living pure functional programming language.
16:38:52 <littledan> sorear, when is clean impure when it's not isolated in a uniqueness type?
16:38:57 <dons> isn't that haskell? with strict types? :-)
16:39:09 <sorear> gwern, littledan: If you have two handles to the same file, and read and write on both, won
16:39:11 <dons> there's no reason not to just use fully strict types in haskell, if you want :) Data.Strict*
16:39:12 <twobitsprite> dons: eh?
16:39:21 <sorear> 't the values read depend on the order of evaluation?
16:39:23 <dons> twobitsprite: i presume you meant ocaml, due to strictness?
16:39:31 <twobitsprite> dons: yeah... and speed
16:39:37 <littledan> sorear, I thought, for IO, you explicitly pass around the world
16:39:50 <twobitsprite> dons: and the fact that it isn't all caught up in some methematicians pipe dream of a "pure" system
16:40:07 <ddarius> twobitsprite: Which mathematicians?
16:40:10 <sorear> littledan: You pass around the world for some operations, but they have small worlds IIRC
16:40:13 <dons> that's a bit inflammatory. purity is massively important. we get proofs of safety :)
16:40:20 <jcreigh> methematicions? Sounds dangerous. :)
16:40:24 <dons> > readfile "/etc/passwd" -- thanks
16:40:25 <lambdabot>   Not in scope: `readfile'
16:40:29 <SamB> twobitsprite: we happen to like pipes
16:40:30 <dons> > readFile "/etc/passwd" -- thanks
16:40:32 <lambdabot>  <IO [Char]>
16:40:34 <littledan> small worlds?
16:40:34 <SamB> isn't the internet a series of pipes?
16:40:38 <gwern> sorear: what? 'won'?
16:41:01 <procyon112> A Mathematician once bit my sister.
16:41:08 <dons> twobitsprite: anyway, re. performance, they're pretty comparable, both native code optimising compilers (ghc v ocaml). and just throw ! around if you need strictness. I do.
16:41:09 <ddarius> sorear is presumably not using Dvorak so ' is close to Enter.
16:41:22 <dons> f !x = ... x .... like that.
16:41:37 <twobitsprite> dons: I thought haskell only got comparable performance with bazaar strictness hacks....
16:41:46 <sorear> dons: why do you keep redefining (!) like that?
16:41:52 <ddarius> twobitsprite: Sometimes lazy Haskell is best.
16:41:58 * sorear wishes people would stop equating haskell with ghc
16:41:59 <SamB> bizarre?
16:41:59 <twobitsprite> dons: see... I want a haskell that implies "!" all the time :)
16:42:01 <gwern> I heard that Clean performed surprisingly better than ghc on the programming language shootout...
16:42:09 <SamB> sorear: that be a new syntax
16:42:15 <dons> twobitsprite: hmm? ! is  bang pattern.
16:42:17 <ddarius> gwern: Clean is well implemented.
16:42:19 <dons> sorear: you don't use bang patterns?
16:42:32 <SamB> dons: they give him a headache
16:42:37 <dons> they're pretty useful, particularly for precise control of the optimiser
16:42:39 <sorear> dons: No, I use haskell 98 + hier libs extension
16:42:39 <jcreigh> dons: Won't that parse as an infix function declaration in H98? I think that's what sorear is hinting at.
16:42:41 <SamB> (being so loud)
16:42:43 <twobitsprite> gwern: it did,,, one of the reasons I was looking at it
16:42:56 <dons> oh, sorear is a trooll :} I forget.
16:43:16 <sorear> @all-dicts trooll
16:43:17 <lambdabot> No match for "trooll".
16:43:27 <littledan> what's a bang pattern?
16:43:38 <sorear> I thought you could only be a troll deliberately :)
16:43:42 <jcreigh> a trooll is a methematicion gone bad. :)
16:43:45 <dons> f !x = 1 + f (x-1) -- like that.
16:44:11 <procyon112> twobitsprite: Don't fear the laziness for performance.  Like any other language, make it clear, concise and correct, then profile it, then tweak the slow spots.
16:44:25 <dons> for example,
16:44:25 <dons> foldl' f z0 xs0 = go z0 xs0
16:44:26 <dons>   where
16:44:26 <dons>     go !z []     = z
16:44:26 <dons>     go !z (x:xs) = go (f z x) xs
16:44:34 <gwern> ddarius: implementation eh. I had heard that it was just easier to optimize with uniqueness types than monads
16:44:50 <dons> its different. you don't optimise with monads :}
16:44:55 <sorear> gwern: GHC uses uniqueness types
16:45:09 <dons> well, not really, sorear. its not really in the type system.
16:45:37 <twobitsprite> maybe I'll just never be happy with a language
16:45:43 <littledan> dons, is that a strictness annotation?
16:45:48 <twobitsprite> I always want to just write my own, but that's just silly
16:45:50 <sorear> 'Monads' are not in the optimizer any more then Num is.  it's inlined and deforested to State# RealWorld -> (# State# RealWorld, a #)
16:45:53 <dons> littledan: right.
16:46:04 <sorear> twobitsprite: do it, it's very enlightening
16:46:07 <ddarius> twobitsprite: So write your own.
16:46:33 <procyon112> Are uniqueness types comparable with Monads?  I mean, can you do things other than sequenceing with them, like Backtracking and such, or are they more of a one-trick pony?
16:46:39 <jcreigh> yeah. in a language that's suited to writing compilers, like Haskell. :)
16:46:44 <dons> monads are far more general.
16:46:44 <twobitsprite> sorear, ddarius: I've thought about it many times... even got so far as firing up a text editory every now and then... :P
16:46:45 <ddarius> procyon112: No.
16:46:58 <dons> but uniqueness gives you the sequencing you want for simple IO-style monads
16:47:04 <dons> not a programmable semicolon though.
16:47:06 <ddarius> dons, procyon112: They are orthogonal.
16:47:15 <dons> so you'd want monads in Clean anyway
16:47:17 <twobitsprite> jcreigh: I was actually thinking of doing it in ocaml... being as it has parsers and streams built in
16:47:41 <littledan> IIRC they also help with mutable data structures, which (I think) can be done with monads too
16:48:04 <jcreigh> twobitsprite: "parsers" and "streams"? Like Parsec?
16:48:27 <ddarius> And lazy lists...
16:48:47 <twobitsprite> ddarius: well.. streams are lazy in ocaml... so they're much like lazy lists
16:49:31 <twobitsprite> ddarius: i.e.: let rec nums n = [< 'n; nums (n + 1) >] in nums 0
16:50:01 <ddarius> > let nums = 0:map (1+) nums in nums
16:50:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:50:21 <ddarius> > let nums = [0..]
16:50:21 <lambdabot>  Parse error
16:50:25 <ddarius> > let nums = [0..] in nums
16:50:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:51:01 <twobitsprite> right... anyways...
16:51:30 <ddarius> Crap, bunch of cool sounding new papers at the Amorphous computing site.
16:52:19 <mcspiff> Hello, would this be an acceptable place to ask for help getting haskell-mode setup?
16:53:21 <Saizan> what's the problem?
16:53:38 <sorear> mcspiff: Just ask.  Asking to ask is a peeve of mine.
16:53:40 <mcspiff> Im wondering how to set the path to ghci
16:53:47 <sorear> M-x customize
16:54:13 <sorear> M-x customize-group  <RET>  haskell
16:54:22 <SamB> or even M-x customize-apropos ghci
16:54:45 <sorear> Then if you scroll down, you'll see The name of the command to start the inferior Haskell process.
16:57:03 <mcspiff> awesome, thanks
17:02:25 <sorear> @seen kc5tja
17:02:25 <lambdabot> kc5tja is in #haskell. I don't know when kc5tja last spoke.
17:02:28 <hpaste>  asl pasted "install failiure of vty 3.0.0" at http://hpaste.org/1868
17:03:02 <asl> hello!  I've had some trouble installing vty.  I see the hpaste bot has caught it
17:03:22 <asl> I'm on the latest Kubuntu - any tips would be appreciated
17:03:25 <sorear> asl: I don't think that's my fault?
17:03:39 <asl> sorear: proabably not!  it's aweird error
17:03:53 <asl> but maybe someone had seen it before
17:03:59 <sorear> I haven
17:04:10 <sorear> 't seen it before, and I'm the main contact.
17:04:46 <sorear> @users
17:04:46 <lambdabot> Maximum users seen in #haskell: 336, currently: 317 (94.3%), active: 18 (5.7%)
17:04:58 <asl> sorear: well, you have now.  I guess that's something.  maybe the build is really okay and checkinstall is being weird for no reason
17:05:18 <koala_man> which gui toolkit would be the standard choice for a noob?
17:05:18 <sorear> what is checkinstall?
17:05:27 <sorear> koala_man: gtk2hs or wxhaskell
17:05:40 <sorear> most people use gtk2hs
17:05:48 <koala_man> thanks
17:05:59 <stepcut> hrm, I still can't figure out how I am supposed to append an element to a list of elements in HaXml. I think I have to hack it
17:06:10 <asl> sorear: checkinstall hooks into debian package management
17:07:36 <asl> sorear:  I'm not sure how it works, I think i sits in front of the syscalls that would be writting things out to the filesystem, and instead puts them into a debian package
17:08:11 <sorear> oh, you're trying to package vty?
17:08:26 <sorear> asl++
17:09:18 <asl> sorear:  it's not really suitable for distributable packages - it's mainly so that the package system doesn't clobber things I install
17:09:47 <sorear> asl: just install into /usr/local then, that's what it's there for
17:10:05 <ddarius> stepcut: A HaXml filter is Content -> [Content], no?  So it isn't immediately clear what you mean by "a list of elements"
17:10:15 <shapr> jiihaa!
17:10:22 <sorear> hi!
17:10:38 <shapr> hiya sorear!
17:10:42 <asl> sorear:  good point!  I'm not much of a sysadmin, but I should be able to make that work.  thanks for taking a look at my problem.
17:11:20 <ddarius> Look http://hebb.mit.edu/people/jkwerfel/ a unicyclist.
17:11:22 <lambdabot> Title: Justin Werfel
17:11:22 <stepcut> ddarius: well, let's say I want to use mkElem to create a new xml node that is a parent of the top-most xml node
17:11:31 <shapr> ddarius: yay!
17:12:17 <ddarius> stepcut: Wouldn't you just apply mkElem to the whole XML tree?
17:12:34 <shapr> ddarius: Did you see that dpiponi used Lava to program the Make controller for a robot?
17:13:06 <ddarius> shapr: Yes.
17:13:12 <ddarius> Where's the blog article?
17:13:17 <shapr> I don't think he's written it yet.
17:13:25 <stepcut> ddarius: the probably I am having is that I get a new node for every child element of the parent node
17:13:45 <stepcut> ddarius: I think I may not be describing the operation I want exactly correctly
17:14:30 <shapr> stepcut: Hey, the asterisk interface is coool! I've just started using asterisk and voicepulse as a landline replacement.
17:14:41 <stepcut> shapr: cool
17:14:51 <ddarius>  "Symplectic Correctors for Canonical Heliocentric N-Body Maps"! Sounds exciting!
17:14:52 * sorear misread that as "landmine"
17:14:59 <stepcut> shapr: did you get the version from Saturday or Sunday? I completely rewrote it ;)
17:15:14 <shapr> stepcut: I'm not sure, I'll re-pull.
17:15:30 <shapr> I seem to have the latest version.
17:15:59 <stepcut> shapr: ok, the first version was horrible and very broken, the current version is almost respectable :)
17:16:34 <stepcut> shapr: I'll take any patches you submit ;)
17:16:56 * stepcut imagines asterisk+HAppS
17:17:25 <ddarius> Please tell me that I'm not the only one that finds the following deeply disturbing "The deeper I look at how live action roleplaying runs distributed simulations, the more surprises I find. I think there's something here for computer scientists to pay attention to."
17:17:30 <cdsmith> @where asterisk
17:17:30 <lambdabot> I know nothing about asterisk.
17:17:40 <cdsmith> @google asterisk haskell
17:17:43 <littledan> off-topic poll: do people pronounce it asteriks or asterisk?
17:17:45 <lambdabot> http://www.nabble.com/ANNOUNCE:-AGI-library-(Asterisk-Gateway-Interface)-t3733931.html
17:17:45 <lambdabot> Title: Nabble - ANNOUNCE: AGI library (Asterisk Gateway Interface)
17:17:55 <littledan> I was having an argument with a friend about this
17:18:50 <littledan> well, nevermind
17:19:16 <stepcut> littledan: I prefer the former, especially in the plural, either way is correct
17:19:31 <littledan> me too
17:20:03 <stepcut> ddarius: hrm, I think I see my problem now, thanks
17:20:59 <cdsmith> ddarius: You don't agree that computer scientists have a lot to learn from weirdos who play Vampire? ;)
17:22:17 <shapr> stepcut: asterisk + HAppS would be nifty!
17:22:36 <ddarius> http://www-swiss.ai.mit.edu/users/hal/misc/msad.jpg
17:23:11 <monochrom> I think people has a lot to learn from computer scientists.
17:23:26 <Binkley> I think computer scientists have a lot to learn from people.
17:23:50 <ddarius> If only computer scientists were people, then the problem would be solved.
17:24:12 <Binkley> yeah, that's what I was trying to imply :-)
17:24:29 <monochrom> Anyway, I did not find that statement disturbing, ddarius. I do not understand it.
17:27:21 <falconair> if one has lots of data being processed by GHC, does its garbage collector ever stop for more a few hundred milliseconds to do its job?  i'm wondering if GHC will have issues in an environment of fast streaming data ...
17:28:28 <DukeDave> Hey, if any of you nice guys who always help me are idling in ##C++, there's a fun question there ;)
17:28:49 <ddarius> falconair: If you generate garbage fast, but don't hold on to it long, then all should be well.  If you hold on for it a while things should still work, but may get slow.
17:29:12 <DukeDave> (p.s. The last 48 hours of my life (working on some C++) have made every Haskell issue seem like a summers day :)
17:30:52 <falconair> ddarius: I may hold on to some data for hours (but that data will be small in size) ... i just can't afford to have GHC stop for half a second every 20-30 minutes
17:31:11 <ddarius> falconair: GHC's garbage collector is not real-time.
17:31:13 <stepcut> falconair: look for papers on 'non-stop haskell', they are a bit out of date, but might have some reasonable numbers
17:31:45 <ddarius> stepcut: The GC described in those papers was never put into a mainstream branch of GHC.
17:31:56 <falconair> i did come across non-stop haskell a long while ago (don't remember the contents) ... that was never brought into ghc?
17:32:03 <falconair> :) got it
17:32:09 <stepcut> ddarius: right, but I assume they have the numbers for the garbage collector that is ?
17:32:21 <stepcut> ddarius: though, I should have been more clear about that ;)
17:32:50 <ddarius> stepcut: I'm pretty sure it has bitrotted away, so the numbers would be both out of date and useless.
17:32:56 <ddarius> And probably meaningless.
17:32:57 <falconair> so was there a problem with non-stop haskell or is it just not a big priority for the GHC folks?
17:33:18 <ddarius> falconair: Not enough manpower was thrown at it.
17:33:34 <ddarius> And I think it was slow.
17:34:07 <ddarius> And I don't think it would have been the kind of thing you could easily toggle with a switch.
17:34:22 <stepcut> falconair: I think it was pretty complex, and only worked moderately well. So, they did not want to maintain a mediocre solution that was hard to work with
17:34:26 <ddarius> kernel-sex/panic-machines
17:35:04 <stepcut> falconair: I suspect they are still interested, if someone came up with the manpower and money :)
17:36:07 <falconair> ok, another questions, if i want to use bytestring to communicate with several streams of asynchronous data (through tcp sockets) ... should I use different threads for each bytestring connection?
17:40:49 <ddarius> falconair: As opposed to?
17:41:40 <falconair> i don't know ... i thought haskell might have some magical way  :)
17:46:14 <davidL> anyone here ever program in J?
17:51:21 <ddarius> @dice 1d8
17:51:21 <lambdabot> 1d8 => 1
17:51:24 <ddarius> @dice 1d8
17:51:24 <lambdabot> 1d8 => 6
17:55:18 <sorear> davidL: Yes, kc5tja (who has been suspiciously absent the last few days)
17:55:50 <davidL> kc5tja: ping!
17:56:13 <sorear> davidL: Good luck.  I pinged him three hours ago
17:56:21 <sorear> (it's about 6 for him)
17:56:50 <davidL> @localtime kc5tja
17:56:52 <lambdabot> Local time for kc5tja is Wed May 16 17:53:35 2007
17:56:52 <sorear> he also seems to be a devout Bicyclist
17:57:11 <sorear> and I suspect much of his absences are travel time
17:57:37 <davidL> It's good to go outside once in awhile ;)
17:58:17 <monochrom> or time travel
17:58:48 <jcreigh> monochrom: I read it that way initially. :)
17:59:00 <procyon112>  Yes but with time travel "once in a while" loses meaning.
17:59:02 <monochrom> me too :)
18:19:20 <migraine_> so with throwDynTo and catchDyn I can throw a socket to another thread asynchronously?
18:20:18 <migraine_> muwhahaha
18:20:53 <dons> yeah
18:20:57 <dons> you could do that.
18:21:02 <sorear> migraine_: you could just use MVars
18:21:09 <migraine_> yeah but I don't want to poll
18:21:15 <sorear> migraine_: poll!?
18:21:27 <sorear> migraine_: just use takeMVar
18:21:27 <migraine_> the mvar...
18:21:38 <dons> MVars don't poll. they select.
18:21:52 <migraine_> well I don't want to block either
18:21:56 <sorear> migraine_: takeMVar doesn't poll - it puts the current thread to sleep
18:22:02 <migraine_> correct
18:22:02 <sorear> migraine_: why not?
18:22:25 <sorear> migraine_: if you never block, there's not much point in having threads
18:22:35 <migraine_> well I am thinking the server module accepts connections and throws them to my main module
18:22:45 <migraine_> which is busy doing other stuff
18:22:54 <dons> using throwDyn for this is a bit scary and unhaskellish.
18:23:00 <sorear> Why does the main module have to do both things?
18:23:02 <dons> might be better to just feed events over a message-passing Chan ?
18:23:08 <sorear> Make a main thread and a compute thread.
18:23:26 <dons> yeah, that might be sensible. one thread for one job.
18:23:29 <migraine_> thought about the channel too... and could throw an exception to check the channel...
18:23:46 <migraine_> just don't want to waste time polling
18:23:56 <migraine_> or blocking
18:24:16 <sorear> blocking doesn't waste time
18:24:18 <ddarius> Why not spawn a new thread for each connection accepted?
18:24:35 <migraine_> well I am going to wrap the handle up into another type that lives in a tvar
18:24:42 <dons> using exceptions for events is urksome. i'd just toss more haskell threads at the problem.
18:24:43 <migraine_> and spawn a thread for those
18:25:16 <dibblego> s/urk/irk :)
18:31:09 <dons> dibblego: no, they make me say 'urk' :)
18:31:23 <dibblego> dons, I thought that on second thought :)
18:34:59 <fuzan> yo
18:35:28 <Korollary> that was quick
18:35:42 <fuzan> err, pidgin on windows is amazingly unstable.
18:35:58 <fuzan> i'm running into a mental block trying to handle user-input in a multi-threaded application
18:36:52 <fuzan> it uses readerT and MVars, and i'm trying to construct a little handler for each packet that is received
18:37:55 <fuzan> however, i've already rigged the putMVars/takeMvars enough to avoid deadlocks and now I need to handle user input, yet I can't fork it onto another thread since i'll lose the monad-ness.
18:40:25 <HairyDude> Warning: Accepting non-standard infix type constructor `:~='
18:40:35 <HairyDude> hmm, is :~= not really legal then?
18:41:12 <HairyDude> or not haskell 98 at any rate
18:44:20 <monochrom> :-E
18:44:54 <monochrom> "Warning: Accepting emoticon type constructor :~=" :)
18:44:59 <HairyDude> heh
18:45:12 <monochrom> "Are you sure it is not a comment?" XD
18:45:45 <HairyDude> what's :~= as an emoticon then?
18:46:07 <ddarius> --> is a perfectly legitimate operator
18:47:57 <HairyDude> suppose I could use :<> or something instead
18:48:13 <monochrom> runny nose
18:48:51 <HairyDude> oh, :<> isn't legal either...
18:49:09 * HairyDude looks up the lexical syntax in the report
18:49:37 <migraine_> alright so channels and polling it is, I guess
18:50:07 <migraine_> well may as well use non blocking socket on accept
18:50:42 <migraine_> thanks
18:56:15 <HairyDude> oh, apparently infix type constructors aren't H98 at all
18:56:18 <HairyDude> apart from (->)
19:01:35 <ptolomy> Is it at all unheard of to hire graduate students to do a quick code review and offer pointers on amateur leisure projects?
19:02:33 <migraine_> I would probably hire undergrads for that purpose first...
19:03:00 <migraine_> but then again I think graduate degrees are overrated
19:03:03 <migraine_> so don't listen to me
19:06:42 <Korollary> I don't think grad students are good reviewers for pedestrian code.
19:07:10 <Binkley> yeah, grad students tend to get encouraged to write "research-quality" code
19:07:18 <Binkley> it depends on the grad student, though
19:07:42 <ptolomy> well, I'm not thinking just any graduate students, and I'm thinking specifically of fairly abstract haskell code.
19:08:02 <Korollary> That makes it non-pedestrian.
19:08:11 <Korollary> I suppose it makes sense.
19:08:25 <dons> grad students will do code reviews for free :-)
19:08:29 <dons> some of them.
19:08:35 <cdsmith> Binkley: just curious: what is "research quality code"?  A good thing or a bad thing?
19:08:42 <Binkley> cdsmith: it's thought of as a bad thing
19:08:53 <Binkley> in that research code generally doesn't require long-term maintenance
19:08:55 <Korollary> Latex oriented programming.
19:08:58 <Binkley> yeah
19:09:01 <dons> doesn't have to be that way.
19:09:06 <dons> but helps if the code is in public.
19:09:10 <Binkley> depends on the individual, of course
19:09:11 <dons> that lifts the research quality a bit.
19:09:17 <Korollary> If the dept has a running project, the quality is somewhat better.
19:09:19 <cdsmith> Right.  Gotcha.  Thanks!
19:09:38 <dons> i've found i produce the best code when its in public, in a visible proejct, and i'm blogging about the code :)
19:09:54 <dons> when i'm forced to explain->revise->polish
19:09:55 <Korollary> and evangelizing
19:10:03 <dons> yeah, got to keep it clean.
19:10:16 <Korollary> so that the <insert other language> crowd can pooh-pooh it
19:10:20 <migraine_> I find that a lot of grad students forget how to program, although their theory is quite excellent, at least in interviews thats what I have noticed
19:10:30 <Korollary> It's an adversarial system like law, actually.
19:11:24 <Korollary> @spell adverserial
19:11:53 <dons> not sure I have aspell on that machine.
19:12:35 <ptolomy> I'm actually somewhat reluctant to make some of my code public just because I know it isn't as good as I can make it, and I know people will be looking at it.
19:12:52 <Binkley> if you wait for it to be perfect, you'll never make any code public at all :-)
19:12:54 <dons> life is short, put the code up and you'll make it good now :-)
19:13:15 <Binkley> and anyway, so long as you don't write (if (boolean == True)...), it's all good
19:13:15 <dons> don't blog tomorrow what you could blog today
19:13:18 <Korollary> That sounds like you wouldn't be up for online dating either
19:13:32 <dons> hey Binkley btw, haven't seen you around in recently :)
19:13:35 <sorear> hello.
19:13:48 <Binkley> dons: yeah, I've been experiencing really-bad-code-induced depression
19:13:50 <Binkley> or something like that
19:14:02 <dons> yeah, bad code can do that.
19:14:05 <Korollary> Binkley: this is group therapy then?
19:14:12 <Binkley> Korollary: heh, yes, I think so
19:14:24 <ptolomy> hehe. well, the other half is that I tend to code when $job gets boring, so posting it and doing the work required to nicen it might blow my cover. :-P
19:15:12 <Korollary> ptolomy: People at M$ used to set up emails to be sent out at 1am to give the impression that they had stayed up late to finish the work. You just need a scheduler.
19:16:20 <ptolomy> What's a good place for anonymous haskell project hosting?
19:16:46 <dons> anonymous. hmm. you can host the tarballs on hackage, of course.
19:16:57 <dons> otherwise, we do have a community server planned, but its not set up yet.
19:17:11 <dons> google's code site is used by yhc. (but i think requires svn :/)
19:17:20 <dons> otherwise, there's darcs.haskell.org, but we're trying to phase that out
19:18:21 * ptolomy checks the wiki.
19:20:04 <cdsmith> Whoa!  What just happened?
19:20:11 <jcreigh> cdsmith: netsplit
19:20:14 <sorear> cdsmith: it's called a netsplit
19:20:22 <mauke> -!- Netsplit over, joins: ed1t, Uz_, ptolomy, stef_, nornagon, nominolo, sorear, Pastorn, slipstream, nich (+27 more)
19:20:49 <sorear> ptolomy: Don't bother - if anyone starts an anon project soon we'll know it's you.
19:20:58 <jcreigh> heh
19:21:53 <Korollary> until the anonymous cowards conspire and flood the net with projects
19:23:20 <dons> sorear: heh
19:24:56 <clanehin> I'm not sure I would feel comfortable running an anonymous program, even one in haskell.
19:25:34 * sorear runs multiple nonymous projects
19:25:57 <migraine_> ...
19:26:07 <shapr> !!!
19:26:20 <sorear> ???
19:26:49 <clanehin> Please, take it to #haskell-punctuation.
19:26:51 <SamB_XP> anne onymous has a webcomic
19:27:31 <sorear> @remember clanehin <migraine_> ... <shapr> !!! <sorear> ??? <clanehin> Please, take it to #haskell-punctuation.
19:27:31 <lambdabot> Done.
19:30:09 <dons> heya shapr
19:30:14 <dons> shazam!
19:31:36 <shapr> hiya dons! Wassup?
19:32:04 <dons> back in syd now after a week up in far north queensland.
19:32:14 <dons> with the crocs and stingers in the sea. much fun!
19:32:20 <shapr> Sounds exciting!
19:32:46 <dons> some great road signs up there...
19:32:58 <dons> i like the one of a giant jellyfish dragging a swimmer underwater
19:34:46 <dons> ha , "Baby, if they made you in Haskell, it would infer that you were just my type"
19:35:42 <dons> Guido v R sez:
19:35:43 <dons> "Q(me). What other language technologies interest you?
19:35:44 <dons> A. No time now, but Haskell seems important."
19:35:58 <dons> "Languages like Haskell and ML are great for people with
19:35:59 <dons> 150+ IQ, though, and Python will never be that"
19:36:31 <shapr> hah
19:36:41 <SamB_XP> That figure seems a bit high to me.
19:36:45 <dons> he goes on to say  " BTW, Haskell has been up on my radar
19:36:45 <dons> also, and I recently found a full video course on FP using Haskell here"
19:36:59 <dons> oh, that's the questionner, actually.
19:37:10 <thetallguy> dons: have an image of that sign?
19:37:26 <dons> yeah, on my camera. i'll upload them in a sec.
19:37:39 <thetallguy> dons: the best in San Diego reads: Cruise Ships use Airport Exit
19:37:57 <shapr> I love reading old sci-fi "Quote from DEC for voice-channel add-ons to PDP-130"
19:38:22 <wolverian> dons, where's that from?
19:39:24 <dons> wolverian: http://flights5i.tharryi.com/Guido-NYC/
19:39:25 <dons> I think
19:39:25 <lambdabot> Title: Guido-NYC
19:39:53 <dons> i only checked it briefly though -- might have mixed up the authors.
19:39:54 <MyCatVerbs> shapr: heehee.
19:40:21 <MyCatVerbs> shapr: second biggest mindfuck I've ever experienced was reading Edgar Allen Poe for the first time.
19:40:29 <wolverian> dons, thanks!
19:41:05 <MyCatVerbs> shapr: and realising that I was holding in my hands actual, nineteenth-century science fiction.
19:41:23 <Korollary> ML shouldn't require 150 IQ wtf
19:41:43 <dons> programming requires training in language concepts. that's what we don't teach :/
19:41:49 <MyCatVerbs> Korollary: errr. Creating ML probably did. =D
19:41:56 <SamB_XP> Korollary: nor should Haskell
19:41:58 <dons> MyCatVerbs: yeah :)
19:42:09 <lispy> 150 IQ is a meaningless term
19:42:10 <MyCatVerbs> dons: please elaborate?
19:42:27 <dons> Milner, Tofte, Harper == pretty smart guys
19:42:34 <Korollary> Writing an ML-like language today shouldn't require 150.
19:42:47 <dons> nah, we do it as a tutorial exercise for undergrads
19:42:48 <Korollary> No offense to Don Syme
19:42:51 <MyCatVerbs> lispy: well yeah, IQ tests are total bunk, but it's still useful enough (even if crap) for discussion.
19:42:57 <dons> who only need 115 IQ :}
19:43:04 <MyCatVerbs> dons: sorry, I mean, please elaborate on tha language concepts thing?
19:43:46 <dons> oh, how many of us did a 'principles of programming languages' course? that taught basic things like equational reasoning, sum , product types, recursive types, continuations, higher order functions. that kind of thing.
19:44:17 <dons> i.e. the basics of our discipline, and of modern languages, aren't taught widely.
19:44:24 <MyCatVerbs> lispy: sure, you don't actually use IQ tests for anything practical, but it's still handy to be able to make sweeping statements along the lines of "this is only comprehended by people twice as smart as the average bear^Whuman being"
19:45:19 <MyCatVerbs> dons: I'm not sure what you mean by equational reasoning, but the second half of that list all sounds fun.
19:45:30 <MyCatVerbs> Oh wait, I has a google. *pokes mozilla*
19:45:51 <MyCatVerbs> dons: ER is the mechanism theorem provers use?
19:46:22 <dons> more that its the basic mechanism we use for doing proofs on haskell code, and what actually underlies things like refactoring.
19:46:47 <dons> no, not like theorem proving. just doing simple proofs on code, using equivalences.
19:47:42 <gwern> IQ tests are not bunk... IQ has a pretty good correlation with G and G has a even better correlation with a lot of stuff
19:47:54 <Korollary> What is G?
19:48:14 <MyCatVerbs> dons: hrmn. Is hoisting counted in that?
19:48:26 <gwern> g stands for general intelligence, the common factor all the various IQ tests try to measure
19:48:59 <Korollary> Then what does "General intelligence has an even better correlation with a lot of stuff" mean?
19:49:16 <clanehin> Assuming "general intelligence" even exists as a legitimate concept . . .
19:49:46 <QtPlatypus> And how is "general intelligence" tested and mesured for?
19:51:59 <gwern> well, general intelligence is what keeps coming out the statistics
19:52:02 <HairyDude> hmm. I see = defining record fields is not the same as = defining variables elsewhere
19:52:21 <gwern> attempts to break down into the various multiple intelligences hypothesis sort of work but not as well
19:52:31 <HairyDude> you can't make it a function by putting args on the left
19:52:52 * MyCatVerbs smash HairyDude with a newspaper.
19:52:59 <HairyDude> why?
19:53:00 <MyCatVerbs> *smacks
19:53:00 <QtPlatypus> gwern: Isn't that circular resonsing?
19:53:04 <MyCatVerbs> HairyDude: variables!?
19:53:15 <MyCatVerbs> HairyDude: no such thing!
19:53:16 <HairyDude> yes?
19:53:22 <HairyDude> no mutable variables, no
19:53:30 <HairyDude> I didn't say mutable variables
19:53:52 <gwern> QtPlatypus: no. you take people doing stuff with various levels of success, you take some pen and paper tests, and try to match them up
19:54:08 <MyCatVerbs> HairyDude: but common usage is that "variable" means "mutable variable" and "immutable variable" is denoted by "constant" >>
19:54:16 <QtPlatypus> The statistics are corralated with general intelegence.  But we can only find general intelegence via the statistics.
19:54:19 <HairyDude> it is? news to me
19:54:23 <MyCatVerbs> HairyDude: (I'm whining, aren't I? Just ignore me.)
19:54:50 <HairyDude> no such thing as mutable variables in the language of mathematics, but there are still variables :)
19:54:59 <_andre> hello
19:55:34 <gwern> QtPlatypus: no. one kind of statistics (life, people doing stuff, how long they live, etc.) is correlated with general intelligence, and that's correlated with another set of statistics (performance on various reasoning and mental manipulation exercises as part of long varied tests)
19:55:41 <MyCatVerbs> HairyDude: parameters! ;_;
19:56:04 <HairyDude> MyCatVerbs: what do you call the names you bind using let/where then?
19:56:17 <_andre> when i create a function that has the same name as one in from the prelude, and load it from ghci, it prints an error saying that the call is ambiguous. is there a way to specify which function i want?
19:56:47 <jcreigh> I tend to refer to named bindings in Haskell as "variables" even though they do not, technically, vary.
19:56:57 <ski> import Prelude hiding (foo,bar)
19:57:08 <MyCatVerbs> HairyDude: touché. Dammit.
19:57:11 <HairyDude> :)
19:57:21 <MyCatVerbs> I don't usually refer to them at all except by name.
19:57:23 <HairyDude> jcreigh: "variables don't, constants aren't"
19:57:26 <dibblego> I see you get voted *down* on reddit for a your/you're mixup.... ah the good ol' days, when it was voted up /me reminisces
19:57:28 <MyCatVerbs> But I can't actually think of any other term.
19:57:30 <jcreigh> HairyDude: heh heh
19:57:39 <dibblego> *for calling someone on a your/you're mixup
19:57:46 <MyCatVerbs> HairyDude: Alan Perlis was a legend. ^^
19:57:54 <HairyDude> Alan Perlis?
19:57:56 * HairyDude googles
19:58:13 <MyCatVerbs> HairyDude: the name of the famous CS researcher you just quoted. x_x
19:58:30 <HairyDude> I didn't know he came up with it :)
19:58:32 <MyCatVerbs> http://www.cs.yale.edu/quotes.html
19:58:33 <lambdabot> Title: Perlisisms - "Epigrams in Programming" by Alan J. Perlis
19:58:51 <MyCatVerbs> lambdabot rules, by the way.
19:58:56 <TomMD> Am I the only one who has trouble compiling the network6 package? (darcs get --partial http://darcs.serpentine.com/network6)
19:58:58 <lambdabot> Title: Index of /network6
19:59:05 <HairyDude> MyCatVerbs: it does indeed
19:59:34 <ski> "data structures induce binding" ?
19:59:47 <MyCatVerbs> HairyDude: really, what other bots do people ever think of adding those sorts of features? Eggdrop? I cackle!
20:00:05 <MyCatVerbs> *features to. (I'm starting to hate myself right now, dammit.)
20:00:09 <HairyDude> tbh I'm not familiar with other bots, I just know lambdabot is great :)
20:00:11 <_andre> ski: thanks!
20:00:47 <ski> _andre : 'import qualified Prelude as P' could also be useful (possibly in conjunction with the other)
20:00:49 <HairyDude> incidentally, I must get round to trying out xmonad some day
20:00:50 <MyCatVerbs> HairyDude: most people instead spend all day teaching their bots to roll dice for D&D games, play stupid quiz games (albeit with clever regexps), kick people out of channels, etc.
20:01:32 <sorear> @dice 2d10
20:01:32 <lambdabot> 2d10 => 9
20:01:56 <ski> @dice 3d0
20:01:56 <lambdabot> 3d0 => 1
20:02:04 <HairyDude> sorear: now, can you get it to roll using the Vampire rules and tell you how many successes it gets?
20:02:08 <TomMD> HairyDude: My thoughts exactly, but I've got to wait until I get a spare system that I can afford to blow away.
20:02:25 <sorear> HairyDude: we have #xmonad now :)
20:02:34 <HairyDude> sorear: oooh
20:02:56 <sorear> TomMD: What, you think xmonad could blow away your system?
20:03:01 <HairyDude> oh btw, I've had dons' blog post on xmonad stickied for ages. I want to read it but can never find time :(
20:03:02 <MyCatVerbs> TomMD: ...xmonad wouldn't require blowing a system away!
20:03:04 <TomMD> You can aways find out about the new channels by doing @seen {sorear,don}
20:03:06 <dons> MyCatVerbs, what features where you thinking of? thaare the best features of lambdabot?
20:03:14 <TomMD> *dons
20:03:47 <MyCatVerbs> dons: no clue, I can't actually think of any more that'd be good to add. I just think the featureset already in lambdabot rocks. ^^
20:03:47 <sorear> I'm not in a lot of them.
20:04:01 <TomMD> MyCatVerbs: I intend to mess with xmonad when I get a new Debian installed, until then I am not messing with my current system due to lack of time to reconfigure ANYTHING and a great need for the system.
20:04:07 <HairyDude> wow, there's a #haskell-overflow now
20:04:17 <MyCatVerbs> TomMD: dude. Back up your .xinitrc. It's not risky. =)
20:04:34 <c> i intend to mess with it when om stuck on a desert island and only GHC and the dwm hg server is down
20:04:54 <jcreigh> so far we have had no reports of xmonad blowing away hard drives. :)
20:04:56 <c> i think itd be neat to abstract its management away from X, so it can be used on OSuX, Windoze, DirectFB
20:04:58 <sorear> @slap c
20:04:58 <lambdabot> why on earth would I slap c
20:05:02 <c> heh
20:05:15 <MyCatVerbs> c: that's not... even remotely feasible.
20:05:17 <c> windows sorely lacks a proper wm. balckbox is kind of close, but doesnt tile for crime
20:05:19 <SamB_XP> lambdabot: because C is an uncouth language
20:05:25 <SamB_XP> MyCatVerbs: are you certain?
20:05:44 <c> MyCatVerbs: defeatist much? blackbox is pretty good. i guess apple dosent liek 3rd party WMs tho
20:05:56 <MyCatVerbs> SamB_XP: pretty much. Definately not within that 400 line limit. ;)
20:06:02 <SamB_XP> MyCatVerbs: well, yeah.
20:06:08 <SamB_XP> it would blow the 400 line limit away.
20:06:22 <jcreigh> well, we're around 500 these days anyway. :)
20:06:26 <sorear> MyCatVerbs: lambdabot is already *well* over 400loc
20:06:32 <MyCatVerbs> c: but neither Windows not OS X give you the same level of freedom to write your own WMs as X11. Plus they both work pretty differently.
20:06:49 <SamB_XP> MyCatVerbs: this is true, at least in the case of windows.
20:07:17 <sorear> MyCatVerbs: if you use the same code metric dwm does, xmonad is over 900 lines - about half of dwm
20:07:20 <MyCatVerbs> sorear: do I look like I care? (Answer, no, I look like text from this vantage point.) It's still orders of magnitude less than if you tried the same in a C-like.
20:07:43 <MyCatVerbs> sorear: including that tiny menu program written in C, I guess so.
20:07:45 <SamB_XP> in the case of windows, to redo the titlebars you need to inject a DLL into all of the app processes and alter the class of the frames, I think...
20:07:50 <sorear> Orders of magnitude only in bases less than sqrt(2)
20:08:39 <MyCatVerbs> sorear: betcha could get OOM with a library for transformable regexes. ;)
20:09:13 <dons> how is xmonad 900 loc? dwm is 1700 without comments, xmonad is 450 (in my branch).
20:09:55 <sjanssen> yeah, it isn't fair to penalize xmonad for actually documenting things :)
20:09:57 <sorear> dons: Sorry, I saw your wc -l earlier and thought it said dwm was 1700locÂ with whitespace
20:10:09 <sorear> dons: and comments, still included
20:10:09 <MyCatVerbs> sorear: and if you're talking xmonad vs. dwm, I think xmonad still wins.
20:10:25 <sorear> yeah, but if you use the same metric only by 2x
20:10:37 <dons> nah, that's with  my comment-stripping, whitespace stripping count_lines code. 450/1700.
20:10:39 <MyCatVerbs> sorear: I thought it had xinerama support, though.
20:10:46 <jcreigh> MyCatVerbs: it does
20:10:51 <jcreigh> and dwm doesn't
20:10:53 <MyCatVerbs> jcreigh: thanks.
20:10:57 <MyCatVerbs> And dwm doesn't, right.
20:11:12 <dons> we do have 700 comments to 450 code lines, while dwm is more like 1700 code, 200 comments.
20:11:23 <sorear> MyCatVerbs: And xmonad lacks a floating layer and size hint support.
20:11:27 <MyCatVerbs> Adding xinerama to dwm would be at least another five hundred lines or so. So I think xmonad gets at least 3:1.
20:11:31 <ddarius> C is inherently clearer than Haskell.
20:11:41 * HairyDude bursts out laughing.
20:11:46 <dons> hehe
20:11:52 <MyCatVerbs> ddarius: if that's the case, what the Hell are you doing here?
20:12:10 <sorear> MyCatVerbs: Corrupting youth.
20:12:13 <ddarius> MyCatVerbs: Why do people program in Intercal?
20:12:18 <MyCatVerbs> sorear: good answer.
20:12:21 <jcreigh> MyCatVerbs: I don't know...it's hard to speculate how hard Xinerama would be in dwm...500 seems high, though. It's not *that* hard.
20:12:27 <ddarius> I am also corrupting youth, yes.
20:12:37 <SamB_XP> ddarius: because that other language is entirely unusable?
20:12:38 <MyCatVerbs> ddarius: because Intercal has a really awesome optimizer which produces code that crashes 10^3 times faster than C?
20:12:44 * sorear has been seriously tempted to bootstrap INTERCAL
20:12:58 <MyCatVerbs> sorear: please don't. That's profane.
20:13:31 <sorear> MyCatVerbs: I'll ignore that, since it's just a comment.
20:13:36 <ddarius> I am also corrupting not youths.
20:13:58 <MyCatVerbs> sorear: -- that's profane
20:14:14 <MyCatVerbs> sorear: {- that's seriously frightening -}
20:14:30 <MyCatVerbs> sorear: /* you scare me occasionally, etc */
20:14:41 <ddarius> @dice 1d5
20:14:41 <lambdabot> 1d5 => 3
20:14:48 <sorear> (please don't  is intercal comment syntax)
20:14:55 <bos> @seen dons
20:14:55 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 3m 9s ago.
20:15:07 <MyCatVerbs> sorear: ...I didn't know that. Heh.
20:15:10 <SamB_XP> sorear: heh
20:15:15 <MyCatVerbs> sorear: now I wish I'd made that pun on purpose. :(
20:15:38 <bos> does john goerzen ever show up here?
20:15:52 <sorear> Yeah, quite recently
20:16:04 <sorear> 19:43 -!- CosmicRay [n=jgoerzen@63-245-179-205.kitusa.com] has quit ["Leaving"]
20:16:06 <ddarius> CosmicRay
20:16:12 <ddarius> @seen CosmicRay
20:16:12 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 31m 15s ago, and .
20:16:27 <HairyDude> and . ?
20:16:32 <dons> and .
20:16:32 <sorear> and .!
20:16:37 <bos> d'oh!
20:16:45 <dons> we just missed him.
20:16:52 <sorear> d'oh?
20:16:58 <bos> i wanted to have a chat.
20:16:58 <dons> thetallguy: jelly fish signs, http://www.cse.unsw.edu.au/~dons/images/daintree/
20:16:59 <lambdabot> Title: Index of /~dons/images/daintree
20:19:04 * HairyDude wonders why fundeps came about instead of dependent types.
20:20:07 <sorear> Because dependant types smash inference.  Fundeps merely crack it.
20:20:28 <monochrom> fundep is easier than dependent types
20:21:20 <HairyDude> easier to implement
20:21:27 <monochrom> yes, I mean that.
20:21:31 <HairyDude> I find dependent types easier to understand :)
20:21:46 <monochrom> ideally, yes
20:29:15 <Korollary> dons: Why does Yi have this Makefile+cabal kind of a build system?
20:30:01 <sioraiocht> are there any RSS parsing libs for Haskell?
20:30:12 <sioraiocht> or do I have to crack open teh Parsec user manual and get programming?
20:30:21 <falconair> are there any plans to add ByteString (and other libraries) to hoogle?
20:32:06 <bos> falconair: ndm has that planned, but he's rewriting hoogle first. again :-)
20:32:25 <falconair> bos: what's going to be in the new hoogle?
20:32:40 <dons> Korollary: its just cabal these days, iirc. the makefile is legacy
20:33:04 <bos> falconair: um, it goes up to 11?
20:33:07 <SamB_XP> dons: legacy as in "we forgot to darcs rm it"?
20:33:10 <Korollary> dons: I darcs-got it yesterday. The readme said to mess with the makefile to pick yi-vty or yi-gtk etc.
20:33:17 <bos> ndm has talked about it several times, but i don't recall what he has in mind.
20:33:30 <dons> Korollary: ah ok. i'm not the developer of yi anymore, so talk to jyp.
20:33:45 <ddarius> @where hrss
20:33:45 <lambdabot> I know nothing about hrss.
20:33:50 <ddarius> @google hrss
20:33:50 <falconair> bos: ok, hoogle is pretty useful for newbies such as my self
20:33:53 <lambdabot> http://www.hrss.net/
20:33:53 <lambdabot> Title: Welcome to the House Rabbit Society of Singapore
20:33:55 <Korollary> dons: Is it hosted elsewhere?
20:34:13 <bos> falconair: oh sure. and for everyone else, too.
20:34:17 * ddarius had forgotten about the House Rabbit Society of Singapore
20:34:34 <bos> that's hilarious.
20:36:41 <sorear> Korollary: cabal is a pretty minimalist system, and under jyp yi has become too complicated to be built with cabal
20:36:47 * sorear is a fan of simple software
20:40:05 <MyCatVerbs> sorear: hells yes. Simplicity for the win.
20:40:18 <sorear> Wow.  It sure is embarrassing when you forget the syntax for the assembler you wrote a week ago...
20:40:22 <monochrom> and simcity too
20:40:53 <Korollary> That's a bit of an A -> B and B -> C kind of argument. What are the details?
20:41:30 <SamB_XP> monochrom: what does this have to do with simcity?
20:41:52 <monochrom> Bad pun, but simplicity -> simcity
20:41:59 <SamB_XP> ah.
20:42:09 <dibblego> ?editDistance simplicity simcity
20:42:09 <lambdabot> Unknown command, try @list
20:42:15 <MyCatVerbs> sorear: :)
20:42:20 <Sgeo> Is that as bad as my pun?
20:42:24 <SamB_XP> that *was* the best link I could come up with to tie that comment into the conversation
20:42:25 <monochrom> delete 3 characters
20:42:26 <Sgeo> @fact goldilocks
20:42:26 <lambdabot> goldilocks: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
20:42:36 <SamB_XP> but I thought simcity was for the DOS
20:43:16 <sorear> And windoze.
20:43:30 <monochrom> Gosh, what did I do? :)
20:43:55 <SamB_XP> but, most importantly, it is for FUN. and POPULATION.
20:45:02 <Sgeo> Why is my pun not on the Humor page?
20:45:17 <Sgeo> I should be *famous* by now >.>
20:45:21 <Korollary> We have it in for you.
20:46:52 * ski played SimCity on the Amiga
20:46:52 <ddarius> This is a good pun: <jlouis> Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat
20:46:52 <ddarius>  <jlouis> or when he tries to fix a relationship by passing himself as a continuation
20:47:34 <Korollary> How much Haskell code has continuation passing?
20:47:46 <Korollary> I think jlouis was just into continuations.
20:48:47 <dibblego> when he wraps himself in a new relationship and sequences from the old one (I think dibblego is into monads)
20:50:39 <TomMD> How high quality is GHCs fusion? If I perform the following actions: fileOpen, hGetContents, parseAllContentsForSpecificConfigurationSettings, parseAllContentsAgainForDifferentInformation.  Will it fuse the two parse operations into one loop?
20:50:56 <sjanssen> depends on how the parsers are written
20:51:00 <dons> only if they're implemented in terms of fusible list combinators.
20:51:32 <sjanssen> TomMD: probably not (hard to imagine writing a full on parser with foldr)
20:52:03 <Sgeo> When he sees, in another language, code that changes a variable, and explodes from confusion
20:56:36 <araujo> hello
21:06:33 <HairyDude> mmm, netsplit
21:15:14 <MyCatVerbs> Y'know judiciously wielding $! and seq over a program can sometimes roughly double its CPU execution speed?
21:15:55 <MyCatVerbs> Could the costs associated with laziness be made negligible if you implemented a Haskell machine and did the laziness in hardware instead of in software? ¬¬
21:16:44 <dons> here you go, xmonad is a zipper, http://programming.reddit.com/info/1rczs/comments
21:16:45 <lambdabot> Title: Roll your own window manager: implementing a Zipper in Haskell (reddit.com)
21:17:21 <araujo> hi dons
21:17:39 <araujo> dons, is there any plan to include floating window support to xmonad?
21:17:51 <dons> there is yes.
21:18:22 <araujo> yeay!
21:18:39 <araujo> dons, with that .. i would be happy :-)
21:19:00 <araujo> xmonad is indeed terrific
21:31:01 <TomMD> When trying to build network6 I can fix a couple errors up till I find Network.hs failing with many missing symbols.  I notice that the symbols are all defined by the Network/Socket.hsc.  I think the build system might be importing the installed (GHC 6.6.1) Network.Socket, not the one in the local directory, ment for use by Network.hs.  how do I fix this?
21:40:00 <dons> this is interesting, http://programming.reddit.com/info/1rd33/comments
21:40:01 <lambdabot> Title: Erlang: how syntax can discourage good programming practices (reddit.com)
21:45:01 <jcreigh> I should look seriously at some reasonable side-effecting FP language. (So far my FP experience has been pretty much limited to Haskell)
21:45:28 <TomMD> Argh, I hacked it out.  I seriously hate all build systems.
21:50:32 <jcreigh> yes, build systems typically suck almost as much as real life
21:51:03 <cdsmith> @quote
21:51:03 <lambdabot> procyon says: Just to be different I wrote fizzbuzz in windows batch file.  It took me 10 minutes because I had to stretch my brain expressing my fold in terms of goto ;)
21:51:21 <monochrom> Welcome to real life, where there is no academic pipe dream, and that's supposed to be a good thing.
21:52:26 <TomMD> Hey, some of us can have pipedreams in real life.
21:52:54 <Apocalisp> jcreigh: and Maven doubly so. Maven 2.0 a power of 2 higher than that.
21:53:11 <jcreigh> "Maven"?
21:53:26 <cdsmith> dons: that is interesting.  Probably more so if I knew erlang.  From that post, erlang looks absolutely horrid.
21:53:30 <Apocalisp> It's a Java build system. At least... I think it's a build system.
21:53:34 <cdsmith> maven is a common build system for Java
21:53:48 <jcreigh> cdsmith: well, look at the third post. somebody gives an example using list comps.
21:53:49 <cdsmith> oops, too late.
21:53:51 <dons> cdsmith: well, its a fun interpreted fp language hacked up by some phone system engineers :}
21:54:03 <Apocalisp> You won't find the Maven documentation say that it's a build system though.
21:54:24 <jcreigh> cdsmith: although of course that doesn't fix it in the general case.
21:54:31 <Apocalisp> "Maven is this... thing. It's cool."
21:54:36 <jcreigh> "Maven is a software project management and comprehension tool."
21:54:44 <jcreigh> What the heck is a comprehension tool?
21:54:59 <Apocalisp> It's bullshit.
21:55:00 <cdsmith> Well, I'll withhold judgement on erlang until I actually learn it, though.
21:55:44 <jcreigh> erlang is in my forever-expanding list of languages that would be interesting to learn someday.
21:56:01 <monochrom> monad is a computation comprehension tool   (duck)
21:56:26 <jcreigh> I bet Maven uses XML as a config format...
21:56:32 <Apocalisp> oh, you bet.
21:56:37 <cdsmith> jcreigh: of course!
21:57:19 <sieni> jcreigh: yeah, I had a problem once. Then I decided to use Java and XML to solve it. Now I have three problems.
21:57:42 <cdsmith> @remember sieni yeah, I had a problem once. Then I decided to use Java and XML to solve it. Now I have three problems.
21:57:43 <lambdabot> Done.
21:57:43 <Apocalisp> "Maven is a thingamajig". Seriously, it's nothing less than a (piss-poor) programming language implemented in XML syntax. Very Java.
21:57:48 <monochrom> which three problems?
21:58:00 <sorear> monochrom: you're kidding, right?
21:58:03 <jcreigh> I heard somewhere "XML is like violence: If it doesn't work, use more.", which seems pretty accurate to me.
21:58:15 <sorear> Apocalisp: wow, worse than XSLT?
21:58:25 <Apocalisp> oh god no
21:58:30 <sorear> @quote pager
21:58:30 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
21:58:47 * SamB_XP thinks darius may have been confused with a two pager
21:59:08 * Pseudonym thinks SamB_XP hasn't discovered 75-line terminals yet.
21:59:17 <SamB_XP> oh
21:59:21 <EliasAmaral> XSLT?
21:59:26 <monochrom> sorear: It's a pun!  monad generalizes from list to computation.  "comprehension" is as in "list comprehension".
21:59:40 * Apocalisp used to be able to write elaborate and extremely obtuse XSLT.
21:59:58 * Japsu does Java and XML too
22:00:00 <Pseudonym> With all that Lisp practice, I'm not surprised.
22:00:02 <sorear> 21:56 < monochrom> which three problems?
22:00:07 <sorear> I meant that.
22:00:07 <jcreigh> Apocalisp: but you've been better since you got out of the institution, right? :)
22:00:07 <Japsu> :D
22:00:17 <sorear> You seem unfamiliar with the jwz quote.
22:00:17 <monochrom> That one is a sincere question.
22:00:24 <Apocalisp> Yes, now they let me outside to talk to the ordinary people.
22:00:40 <sorear>      Some people, when confronted with a problem, think "I know, I*ll use regular expressions." Now they have two problems. --Jamie Zawinski, in comp.lang.emacs
22:00:46 <monochrom> I'm only familiar with the "every software evolves to do email" rule.
22:01:03 <Pseudonym> Something, by the way, which lambdabot can't yet do.
22:01:06 <monochrom> So, when will GHC do email? :)
22:01:18 <Japsu> @hoogle mail
22:01:19 <lambdabot> No matches found
22:01:22 <Japsu> @hoogle email
22:01:22 <monochrom> Because darcs already does email... :)
22:01:23 <Apocalisp> Monad.Email
22:01:23 <lambdabot> No matches found
22:01:30 <Japsu> monochrom: There. Monad.Email.
22:01:33 <Apocalisp> haha
22:01:39 <jcreigh> > readFile "/var/spool/mail/dons"
22:01:40 <lambdabot>  <IO [Char]>
22:02:04 <Japsu> haha
22:02:32 <monochrom> No one comprehends my comprehension pun.
22:02:53 <sorear> Actually, if you're an admin, lambdabot *can* read mail - @rc /var/spool/mail/dons
22:02:54 <dons> i think lambdabot actually did send email at one piont
22:02:57 <dons> but we backed it out.
22:03:06 <monochrom> Cale would probably love it. He may change it to container comprehension.
22:03:21 <sorear> however I won't do it, since I expect there are a few valid lambdabot commands in dons' mailbox :)
22:03:30 <Pseudonym> @spam dons
22:03:30 * lambdabot smacks dons about with a large trout
22:03:35 <sorear> maybe a line or two starting 'quit'
22:03:36 * Pseudonym laughs
22:03:37 <monochrom> haha
22:03:42 <dons> :}
22:04:30 <Apocalisp> Now... can I curry a function f x y by saying (f _ y) or similar?
22:04:42 <jcreigh> oh, does dons actually have a mailbox on that machine? I was just guessing.
22:04:46 <monochrom> No. Try (flip f)
22:04:50 <Apocalisp> ooh
22:05:33 <sieni> @spam sieni
22:05:33 * lambdabot slaps sieni
22:05:37 <Pseudonym> @pl \x -> f x y
22:05:37 <lambdabot> flip f y
22:05:42 * sieni slaps lambdabot back
22:06:08 <monochrom> lambdabot slaps those who don't slap themselves.
22:06:13 * sorear slaps lambdabot's hand
22:06:46 * sorear consumes lambdabot's entire supply of trout
22:07:06 <SamB_XP> @slap me
22:07:07 * lambdabot beats up SamB_XP
22:07:09 <SamB_XP> @slap me
22:07:09 <lambdabot> why on earth would I slap SamB_XP
22:07:17 <monochrom> that's an infinite list of trouts.
22:07:31 <SamB_XP> hey, that actually works!
22:08:17 <sieni> @slap SamB_XP
22:08:17 * lambdabot slaps SamB_XP
22:08:19 <sieni> @slap SamB_XP
22:08:19 * lambdabot beats up SamB_XP
22:08:21 <sieni> @slap SamB_XP
22:08:21 <lambdabot> why on earth would I slap SamB_XP
22:08:41 <sieni> @botsnack
22:08:41 <lambdabot> :)
22:08:45 <sieni> good bot
22:08:57 <SamB_XP> @bo
22:08:58 <lambdabot> :)
22:09:03 <EliasAmaral> jcreigh, if you are looking for a functional programming language that has side-effects, you may want to look at some variant of ml. i like ocaml
22:09:28 <sieni> there is also _standard_ ml :-)
22:10:09 <monochrom> I like all of them. I like all of you too.
22:10:28 <EliasAmaral> yes, but my first programming professor used ocaml instead of sml :( :)
22:10:32 <SamB_XP> monochrom: all of the trouts?
22:10:50 <monochrom> Yes, that too.
22:10:53 <sieni> monochrom: but that's only because you haven't met me in person
22:10:56 <SamB_XP> what did you mean?
22:11:14 <sorear> The standard impure FP languages are and probably always will be lisp/scheme.
22:11:20 <monochrom> I like all ml's, all of you, and all trouts.
22:11:55 <sorear> Which is not to say they are the best!
22:12:09 <EliasAmaral> sorear, the standard impure fp language with static type discipline may be sml
22:12:32 <sorear> EliasAmaral: Definitely.
22:19:43 <dons> i'd suspect ML would be a strict, pure language, were it to be designed today.
22:24:15 <emu> why?
22:24:30 <emu> be hard to do circular data structures?
22:26:06 <sorear> @seen kc5tja
22:26:06 <lambdabot> kc5tja is in #haskell. I don't know when kc5tja last spoke.
22:31:21 <dons> emu, because purity and correctness matter a lot to the ML guys.and they dig type systems. so I suspect they'd go for static separation of effects ,now we know how to do it.
22:31:59 <monochrom> A strict language designed today will definitely include a lazy annotation.
22:32:24 <sorear> Define annotation.  Scheme has had one for decades
22:32:42 <monochrom> Like LazyML.
22:32:59 <dons> like ~ :-)
22:33:17 <dons> ones = 1 : ~ones -- my proposal ;-)
22:33:35 <dons> or conversly, a lazy language will include a strict annotation
22:33:54 <dons> f !x = x * f (x-1)
22:33:56 <dons> cute huh?
22:35:48 <dibblego> Scala is getting a lazy annotation next release
22:36:10 <sorear> dons: Uh, * is already strict, if your compiler has anything resembling a strictness analyser you just wasted a character
22:36:57 <dons> sorear, i'm not sure that's the point here ;-)
22:37:22 <dons> sorear: good lesson for teaching: lie about details to get your point across. the student can find out the full details later
22:37:42 <EliasAmaral> dons, hahahaha
22:37:57 <dons> for example, "the compiler has a strictness analysis of its own, so you don't need to annotate every strict site"
22:38:06 <dons> "but for teaching purposes, let's ignore that"
22:38:54 * sorear doesn't think students should be exposed to strictness (instead give them 4GB of memory and simple problems)
22:39:11 <sorear> Well, not very early
22:52:06 <bos> hey, the haskell book market is growing massively!
22:52:25 <bos> we've gone from 0.01% of the computer book market to 0.08! in just one year!
22:52:50 <Pseudonym> 0.12%, here we come!
22:53:17 <bos> clearly, with a growth curve like this (i'm going to choose a nice curve to fit those two points, like say that of ackermann's function), world domination is practically an instant away.
22:53:55 <bos> haskell is now on par with tcl and scheme, just about.
22:54:11 <dons> hehe, I did see that the number of units shipped jumped fairly well from Hutton's book.
22:54:18 <bos> yes.
22:54:26 <dons> and ocaml crashed..
22:54:35 <dons> lesson: don't write bad books
22:54:49 <dons> and erlang doesn't rate a mention (?)
22:55:03 <bos> i'm not sure there are any erlang books in print at the moment.
22:55:14 <dons> ah yes. just the hint of one.
22:55:55 <bos> it was interesting to see the frisson of excitement in the comments to eric's prag haskell blog posting.
22:56:20 <bos> i got the impression the poor fellow hadn't the half of the requested topics in mind.
23:00:46 <dons> yeah, the market is aching for some practical haskell.
23:21:16 <Apocalisp> How do I make show display doubles rounded to 3 decimal places?
23:21:34 <dons> > printf "%0.3f" (pi :: Double)
23:21:38 <lambdabot>  Add a type signature
23:21:42 <dons> > printf "%0.3f" (pi :: Double) :: String
23:21:44 <lambdabot>  "3.142"
23:22:02 <dons> ?hoogle showFFloat
23:22:02 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
23:22:13 <dons> > showFFloat pi (Just 3) []
23:22:14 <lambdabot>        add an instance declaration for (Floating (Maybe Int))
23:22:28 <dons> > showFFloat (Just 3) pi  []
23:22:29 <lambdabot>  "3.142"
23:22:33 <dons> is the other way
23:22:58 <Apocalisp> very cool
23:29:47 <Brain2> what is the extra F standing for?
23:29:54 <Brain2> showFFloat
23:30:15 <Pseudonym> There's also showEFloat and showGFloat
23:30:21 <Pseudonym> They're the same as %f, %e and %g in C.
23:30:29 <EliasAmaral> bos, where you saw those book market statistics?
23:30:36 <Pseudonym> e == scientific notation, f == no scientific notation, g == whichever is better
23:30:49 <Brain2> ah i see, thanks
23:31:42 <Brain2> hoogle printf
23:31:47 <Brain2> @oogle printf
23:31:47 <lambdabot> Maybe you meant: google hoogle
23:31:54 <Brain2> lol
23:31:57 <Brain2> @hogle printf
23:31:58 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
23:31:58 <lambdabot> Text.Printf :: module
23:31:58 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
23:32:03 <Brain2> who turned off my insert
23:33:50 <hpaste>  HairyDude pasted "memoization" at http://hpaste.org/1870
23:34:00 <HairyDude> muahaha! it works!
23:34:25 <HairyDude> (testing with a naive fibonacci function)
23:35:34 <HairyDude> still blows stack though
23:37:50 <LordBrain> i miissed your source
23:39:05 <HairyDude> ah, compiling with -O fixes the stack blowing
23:39:23 <HairyDude> ... kind of
23:39:48 <HairyDude> LordBrain: I didn't post it
23:41:30 <HairyDude> is there a quicker way of parsing ints than 'read'?
23:41:40 <Heffalump> quicker in the sense of running time?
23:42:11 <HairyDude> well, yes
23:42:28 <HairyDude> istr read was rather slow
23:42:42 <Heffalump> have you actually verified that?
23:42:52 <Heffalump> I'd expect it to be reasonably fast, given that it's a fairly trivial problem.
23:42:57 <Heffalump> But you could try writing your own.
23:42:57 <HairyDude> hm
23:43:13 <LordBrain> istr ?
23:43:18 <LordBrain> what's istr?
23:43:19 <Heffalump> "I seem to recall"
23:43:21 <LordBrain> oh
23:43:25 <HairyDude> well anyway, it's coffee o'clock :)
