00:09:29 <narain> can you get ghc to warn about non-comprehensive pattern matches? i.e. when the set of clauses doesn't cover all cases
00:10:22 <ari> -fwarn-incomplete-patterns
00:10:46 <narain> ah, thanks
00:12:10 <mauke> -Wall
00:14:16 <narain> wow, -Wall gives me a boatload of warnings
00:14:33 <jcreigh> well, they do call it -Wall :)
00:19:03 <Cheery> @hoogle [(a,b)] -> a -> b
00:19:05 <lambdabot> No matches, try a more general search
00:19:05 <brianski> what's the best haskell interpreter/compiler for beginning to intermediate usage?
00:19:19 <Cheery> @hoogle [(a,b)]
00:19:20 <lambdabot> Data.FiniteMap.fmToList :: FiniteMap key elt -> [(key, elt)]
00:19:20 <lambdabot> Data.Map.assocs :: Map k a -> [(k, a)]
00:19:20 <lambdabot> Data.Map.toAscList :: Map k a -> [(k, a)]
00:20:03 <mauke> brianski: ghc :-)
00:20:24 <narain> :t find
00:20:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:20:39 <mauke> :t lookup
00:20:42 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:21:21 <brianski> mauke, that's about what i figured, altho hugs looks interesting (i'm a perl coder by day)
00:21:23 <Cheery> hmm, I'd like to get something like (!!) inversed
00:21:48 <Cheery> :t (!!)
00:21:50 <lambdabot> forall a. [a] -> Int -> a
00:22:09 <Cheery> @hoogle [a] -> a -> Int
00:22:10 <lambdabot> No matches, try a more general search
00:22:19 <mauke> brianski: what's interesting about hugs?
00:22:39 <brianski> pugs, perl6, etc.
00:22:56 <mauke> huh?
00:23:06 <mauke> hugs has nothing to do with perl6
00:23:08 <skew> pugs uses lots of GHC extensions
00:24:05 <narain> i'm curious about Cheery's question too. is there a better way than zipping with [0..]?
00:24:59 <mauke> :t elemIndex
00:25:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
00:25:40 <brianski> oh... i figured pugs was based on hugs somehow
00:25:47 <brianski> is that wrong?
00:25:55 <skew> only the name, I think
00:25:59 <dons> there we go, http://haskell.org/haskellwiki/Research_papers/Functional_pearls
00:26:00 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
00:26:28 <mauke> hugs is a haskell interpreter written in C
00:35:36 <skew> Does anyone know offhand if 6.6.1 fixes that bug where the coverage checker whines about missing patterns, but if you add them GADT checking decides they are inaccessible?
00:36:10 <brianski> hrm... the code snippets in the gentle intro to haskell don't run in ghci
00:36:30 <skew> the ghci prompt is like the inside of a do block
00:37:38 <dons> brianski: yeah, put them in a source file, Foo.hs , then :load Foo.hs in ghci
00:37:47 <dons> individual expressions may be entered directly into ghci, though.
00:37:55 <brianski> hrm
00:38:07 <dons> Prelude> let f x = x ^ 2
00:38:08 <dons> Prelude> map f [1..10]
00:38:08 <dons> [1,4,9,16,25,36,49,64,81,100]
00:38:26 <dons> since you're sitting inside a 'do' block, normal do-notation syntax and semantics apply
00:38:43 <brianski> Prelude> blainc n          = n+1
00:38:46 <brianski> <interactive>:1:18: parse error on input `='
00:38:48 <dons> let
00:38:51 <brianski> oh
00:39:02 <dons> since its like being in:     main = do ....
00:39:06 <brianski> do ihave to do let because i'm in a do loop ?
00:39:13 <mauke> it's not a loop
00:39:19 <brianski> err sorry do block
00:39:22 <skew> yeah, pretty much
00:39:26 <dons> its not a 'do' loop, just a do 'block', i.e. sequential statements
00:39:33 <dons> so yeah, because of that.
00:39:36 <brianski> right, ok.
00:39:38 <brianski> thanksya
00:39:43 <mauke> except when it is
00:39:53 <dons> the examples from the tutorial are expected to be written into a file, and loaded, I think.
00:39:58 <kc5tja> dons: But, the analogy doesn't hold 100%; returning 4 in a do block will yield a type error, while typing 4 and hitting ENTER will print the number 4.  Unless there is some extra magic I'm missing.  :)
00:40:13 <mauke> > do x <- [1 .. 10]; return (x * 2, x * 3)
00:40:15 <lambdabot>  [(2,3),(4,6),(6,9),(8,12),(10,15),(12,18),(14,21),(16,24),(18,27),(20,30)]
00:40:16 <kc5tja> Wow, I'm tired.
00:40:18 <mauke> do loop!
00:40:22 <dons> there's a little bit of magic, not much (basically, values are printed)
00:40:27 <kc5tja> That sentence just doesn't make a lick of sense.
00:40:29 <dons> mauke: hehe
00:40:42 <dons> Prelude> 4
00:40:42 <dons> 4
00:40:42 <dons> Prelude> it
00:40:42 <dons> 4
00:40:42 <kc5tja> OK, just as long as the point was conveyed.  :)
00:40:46 <dons> and they're bound ot 'it'
00:41:51 <brianski> hmm so "it" is kind of like $_ in perl?
00:42:16 <dons> yeah, but its purely ghci only. just for a nice interface.
00:42:19 <dons> its not a haskell thing.
00:44:25 <Cheery> I'm wondering, since this is so common behavior, whether there's standard action for this:
00:44:53 <brianski> gotcha
00:45:48 <Cheery> read -action which first looks from one place, then from another, then from third, and so on
00:48:27 <Cheery> ie: getAvailable ["./myconfigfile", "~/.myconfigfile"] >>= readFile
00:48:38 <Cheery> @hoogle FilePath
00:48:42 <lambdabot> Distribution.Compat.FilePath :: module
00:48:42 <lambdabot> Prelude.FilePath :: type FilePath
00:48:42 <lambdabot> Distribution.Compat.FilePath.breakFilePath :: FilePath -> [String]
00:50:01 <Cheery> it could also be direct like: readAvailableFile ["./myconfigfile", "~/.myconfigfile"]
00:50:51 <Cheery> point is, is there something like this readily available?
00:53:56 <Spark> can someone with winrar give me the files from http://people.freenet.de/steve-m/binipl.rar in a more sensible archive format
00:54:11 <Spark> linux "unrar" seems to think it's corrupt
00:55:07 <mauke> works for me
00:55:10 <therp> spark: try the binary that comes as "rar". I think it supports more decompression algorithms
00:56:01 <Spark> ubunu only has "unrar-free"
00:56:11 <Spark> mauke: can you send it me?
00:56:20 <Spark> the text file might be small enough to pastebin
00:56:29 <mauke>  can you access http://mauke.ath.cx/tmp/binipl.txt.bz2 ?
00:56:36 <sorear> therp: RyanT5000 came in asking about low-disk-overhead compiled haskell for OLPC
00:56:42 <Spark> yep, thanks :)
00:58:58 <therp> sorear: we should see improvements with on this front with shared libraries
00:59:32 <sorear> therp: Hence my addressing it to you :)
01:07:25 <therp> what's the timeline for OLPC shipping?
01:08:18 <sorear> <sorear> RyanT5000: that said, can you wait four months
01:08:19 <sorear> <sorear> RyanT5000: implementing dynamic linking on linux is one of our SoC projects
01:08:19 <sorear> <sorear> so, September [22:07]
01:08:19 <sorear> <*RyanT5000> 4 months is about when it will be actually shipping
01:15:59 <dons> if we got hold of one of these machines, there's nothing that would stop us writing haskell programs on it, is there?
01:17:54 <sorear> Do you insist on automatic compilation?
01:49:11 <fridim> >let fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]; take 10 fibs
01:49:28 <mauke>  
01:49:57 <fridim> (this is awesome, magic)
01:50:16 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:50:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:51:03 <fridim> mauke, nice
01:51:20 <dolio> > fix ((0:) . (1:) . ap (zipWith (+)) tail)
01:51:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:51:30 <Botje_> > let fibs = scanl (+) 1 fibs in fibs
01:51:32 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
01:51:48 <opqdonut> :D
01:51:48 <sieni> not quite fibs
01:51:50 <opqdonut> fail
01:51:51 <Botje_> > let fibs = 1: scanl (+) 0 fibs in fibs
01:51:52 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
01:51:54 <Botje_> pfft.
01:52:07 <sorear> > fix ((1:) . scanl (+) 0)
01:52:09 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
01:52:09 <Botje_> i'm still groggy from waking up so early :P
01:52:15 <fridim> haha
01:52:20 <sorear> > fix ((0:) . scanl (+) 1)
01:52:21 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:52:25 <sieni> Botje_: http://www.except.nl/overig/uploads/kittens/fail.jpg
01:52:36 <opqdonut> :)
01:52:43 <sorear> > nubBy(((>1).).gcd)[2..]
01:52:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:52:58 <sieni> sorear: O_O
01:53:28 <sieni> sorear: can you make that even smaller? :-)
01:53:54 <Botje_> filter isPrime [2..]
01:54:00 <Botje_> but that'd be cheating :)
01:54:13 <sieni> yeah :-)
01:54:44 <dolio> Why not just 'primes' then? :)
01:54:53 <sieni> > primes
01:54:54 <lambdabot>   Not in scope: `primes'
01:55:02 <mauke> where primes = ...
01:55:05 <sorear> because it isn't standard!
01:55:22 <dolio> Neither is 'isPrime'
01:55:27 <mauke> :m +Data.Primes
01:59:22 <dolio> Maybe that will be included in the nebulous, mathematically sound Haskell prelude/library rewrite.
02:02:57 <therp> totally unrelated (except for the kittens http://kittenwar.com/ :)
02:02:58 <lambdabot> Title: Kittenwar! May The Cutest Kitten Win!
02:31:46 <tcr> I think you cannot create helper functions local to an instance declaration, can you?
02:35:09 <sorear> right.
02:41:51 * lispy implements darcs pre-hooks
02:58:39 <lispy> you could hear a pin drop in here
02:58:53 <lispy> and i thought this was all haskell all day
02:59:49 <mauke> :t drop ?pin
02:59:58 <lambdabot> forall a. (?pin::Int) => [a] -> [a]
03:00:17 <lispy> :t drop ?pin ?list
03:00:20 <lambdabot> forall a. (?pin::Int, ?list::[a]) => [a]
03:00:24 <lispy> oh neat
03:00:37 <lispy> so it lets you name them? but why does it put them in a tuple?
03:01:07 <lispy> er, actually it's doing more than that
03:05:17 <ibid> there's no tuple there
03:05:46 <lispy> yeah, i realized it was different too late
03:05:50 <lispy> but, what is it?
03:05:56 <mauke> pure evil
03:06:07 <lispy> it's not optional params is it?
03:06:08 <ibid>  ?pin is an implicit parameter, iirc
03:06:31 <ibid> the type says (in the context part of it) that the caller must provide said implicit parameters
03:09:30 <quicksilver> they seem like a nice idea
03:09:33 <quicksilver> but they're aren't
03:09:36 <quicksilver> they're *nasty* :)
03:09:37 <ibid> i suppose you could translate "drop ?pin" to english as "drop _the_ pin"
03:09:38 <ibid> yep
03:09:44 <ibid> and not as useful as they would seem
03:47:43 <dons> can anyone see the content on this,  http://hackety.org/2007/05/05/preludeInH.html
03:47:44 <lambdabot> Title: hackety org » Prelude in Haskell
03:47:59 <dons> something about music and haskell? (/me is flash devoid atm)
03:49:40 <tcr> lambdabot: help
03:49:56 <tcr> Alright, how can I obtain instructions on how to use lambdabot?
03:50:04 <dmhouse> ?where lambdabot
03:50:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:50:11 <dmhouse> ?commands
03:50:12 <lambdabot> Unknown command, try @list
03:50:14 <dmhouse> ?list
03:50:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:51:36 <dons> ?help
03:51:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:51:42 <dons> ?help where
03:51:42 <lambdabot> where <key>. Return element associated with key
03:51:46 <dons> ?where lambdabot
03:51:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:06:03 <dmhouse> Anyone got any recommendations for a POP3 server I could install locally?
04:09:00 <drigz> from those in gentoo portage, dovecot has the best name :)
04:38:20 <dmhouse> Would the following code be correct to open a connection to the localhost on port 110? connectTo "127.0.0.1" (PortNumber $ PortNum 110)
04:38:40 <dmhouse> I gives me an error: 'connect: does not exist (Connection refused)' despite the fact that I can telnet to that port just fine.
04:45:07 <dons> dmhouse: you found the zipper paper!? :-)
04:45:26 <dmhouse> dons: yeah! I knew I'd read that online somewhere.
04:45:37 <dons> wow. good work,  I couldn't find it.
04:45:41 <dmhouse> Well, I knew I'd read it, and I've never even _seen_ a real-life journal.
04:46:00 <dmhouse> Google Scholar found the paper and 4 locations for it, one of them worked.
04:46:11 <dons> ah I don't think I used scholar for huet.
04:46:26 <dons> I did for some of the others. now its mostly just Bird's papers not found
04:46:40 <mahogny> I am *extremely* tempted to write a competitor to ImageJ unless someone else is up for the job. imagej has so many flaws that I've stopped counting them
04:47:11 <dmhouse> Anyone got any idea how the PortNumber type is meant to work?
04:47:33 <dons> PortNum is in Num, iirc
04:47:39 <dons> check the IRC roll your own tut.
04:47:45 <dons> there's an example there
04:47:50 <dmhouse> I get oddities like this:
04:47:51 <dmhouse> *Fetchmail Network.BSD> getServicePortNumber "pop3"
04:47:51 <dmhouse> 110
04:47:51 <dmhouse> *Fetchmail Network.BSD> fmap (== PortNum 110) $ getServicePortNumber "pop3"
04:47:54 <dmhouse> False
04:47:58 <eumenides> Prelude Network> connectTo "localhost" (PortNumber 80)
04:47:58 <eumenides> {handle: <socket: 8>}
04:48:28 <dmhouse> Aha! That makes it easier to use.
04:48:56 <dmhouse> I was using (PortNumber $ PortNum 110), which didn't work. There's some weirdness in how the PortNum argument is stored.
04:49:09 <dmhouse> (As shown by the second output from GHCi.)
05:00:38 <Saizan> how is Test.QuickCheck.Poly supposed to work?
05:03:56 <dons> check the paper. no idea , personally, i've never used it.
05:04:03 <dons> it *is* mentioned in the paper though
05:11:51 * dmhouse fixes a stack of bugs in HaskellNet
05:25:42 <dmhouse> How would I block until I read a CRLF sequence from a given handle?
05:41:24 <dmhouse> The problem I'm having is that I'm trying to read output from my POP server. I send it my USER and PASS credentials, then it prints "+OK", waits a bit, and follows up with " Logged in." If I use hGetLine, it just reads the "+OK", sees the EOF and stops there.
05:41:35 <dmhouse> Can I get it to block until it sees a CRLF
05:41:40 <dmhouse> s/$/?/
05:43:16 <Igloo> If it gets an EOF then there isn't going to be a CRLF
05:43:57 <Igloo> Are you keeping the stdin handle alive?
05:44:04 <Igloo> If not the connection might be getting closed
05:44:23 <dmhouse> Igloo: well, I can use a second call to hGetLine which reads the rest...
05:44:24 <Igloo> Sorry, not stdin - the handle with which you send stuff to the server
05:45:04 <Igloo> Are you sure it isn't getting a CRLF then (or at least, either a CR or an LF)?
05:45:42 <dmhouse> If telnet to the server and give it the USER and PASS lines, "+OK Logged in" gets printed on a single line.
05:46:57 <Igloo> Hmm, can you file a bug with a minimal Haskell program and a description of what the server sends please?
05:47:08 <dmhouse> I'll give it a go.
06:01:17 <dmhouse_> Igloo: never mind, I found the problem. :) When you connect to the server, it sends a greeting line which I'd forgotten about. So I sent my "USER" line then read a line, assuming I was reading the server's response, but in fact I was reading the greeting line. So when I read the line after sending "PASS", I was in fact reading the line the server prints after sending "USER", which is correctly just "+OK".
06:01:24 <dmhouse_> Bit of a forehead-slap moment. :)
06:02:03 <Igloo> dmhouse_: OK, thanks for letting me know  :-)
06:02:34 <erider> good morning
06:09:01 <ehird`> what on earth is the point of n+k patterns?
06:09:16 <perspectival> to be confusing?
06:09:18 <ehird`> it seems that paramname+any number here, no expression though subtracts the number from paramname
06:09:24 <dmhouse> ehird`: they make certain function definitions very pretty.
06:09:27 <ehird`> and then... you can add it back on for...something...i guess
06:09:31 <ehird`> i don't see the point
06:10:13 <dmhouse> E.g. n * 0 = 0; n * (m + 1) = n * m + n
06:10:35 <ehird`> Meh
06:10:37 <dmhouse> For recursing over the naturals, 0 and (n+1) become the two cases, like [] and (x:xs) in lists.
06:11:04 <dmhouse> (Or like Z and (S n) in the Peano encoding.)
06:11:09 <DRMacIver> Views would probably be a more natural way of doing this.
06:11:12 <helmut> Has anyone worked with distract yet? (unfortunately I currently cannot try it as cabal is uninstallable in sid)
06:11:17 <DRMacIver> But oh well. :)
06:11:49 <ehird`> i mean it may make slightly more sense if k could be an expression like:
06:12:12 <ehird`> subtract a (b+a) = b
06:12:14 <ehird`> or something
06:12:24 <DRMacIver> Except that matches need to be resolveable at compile time...
06:12:27 <dmhouse> That'd complicate pattern matching significantly.
06:12:33 <ehird`> DRMacIver: true
06:12:52 <ehird`> but then, n+k patterns seem to then have barely any use, so...
06:13:00 <dmhouse> Free variables in patterns are quite against the current grain.
06:14:14 <dolio> They look slightly nicer if you can write 'f (n+1) = ...' where '...' contains 'n' a bunch of times.
06:14:29 <dolio> Instead of writing (n-1) a bunch of times, or 'where n' = n-1'.
06:14:30 <ehird`> True, though I cant quite imagine why you'd need to
06:15:07 <dmhouse> ehird`: they are something of a wart, no-one really uses them, and they have confusing implications. E.g. consider the following top-level declarations:
06:15:17 <dmhouse> n + 1 = 10
06:15:20 <dmhouse> (n + 1) = 10
06:15:39 <dmhouse> The first defines the (+) function, the second the 'n' variable.
06:15:40 <ehird`> dmhouse: now that IS confusing
06:16:23 <dolio> There's a ticket for removal in haskell' as I recall, although I don't know how popular it is.
06:16:25 <ehird`> i mean, why just +? why not other operators? :)
06:17:14 <DRMacIver> dolio: Well, nominally if Haskell' acquires view then this could be replaced with something slightly nicer.
06:17:20 * dmhouse would love to see prefix patters for lists.
06:17:21 <DRMacIver> views
06:17:22 <Heffalump> it's just so you can have a partial illusion of integers behaving like inductively defined naturals
06:17:34 <dmhouse> E.g. f ("hello"++x) = blah.
06:17:44 <Heffalump> dmhouse: yeah
06:17:46 <Heffalump> save a lot of typing
06:17:48 <DRMacIver> dmhouse: That would be nice.
06:18:15 <dmhouse> At the moment the best you can get is f x | "hello" `isPrefixOf` x = let x' = drop 5 x in blah
06:18:18 <ehird`> dmhouse: that looks neat
06:18:41 <Heffalump> dmhouse: or f ('h':'e':'l':'l':'o':x) = blah
06:18:42 <DRMacIver> dmhouse: Well you could also desugar it to 'h' : 'e' : 'l' : 'o' : x couldn't you?
06:18:43 <dolio> Epigram allows you to do something like that, as I recall. You can define custom structural recursion operators or something.
06:18:44 <Heffalump> which is ugly
06:18:47 <DRMacIver> Bah. Heffalump beat me to it.
06:18:57 <dmhouse> Well, sure, but that's not much nicer :)
06:19:01 <DRMacIver> But the point is that this way it's something which the compiler can trivial desugar in the same way it does literals.
06:19:08 <DRMacIver> trivially
06:19:21 <Heffalump> right
06:19:27 <ehird`> well haskell isn't really very easy to implement by now anyway is it ;)
06:19:36 <ehird`> parsing layout,lazy evaluation, all that
06:19:51 <dmhouse> n+k patterns can be desugared too.
06:19:52 <DRMacIver> Sure. But things should be kept as simple as possible and no simpler. :)
06:20:00 <DRMacIver> dmhouse: They can, but it's not a direct desugaring.
06:20:05 <dmhouse> If Haskell had a built-in Nat type, it would be.
06:20:19 <DRMacIver> dmhouse: The point is that here a pattern match desugars to a pattern match.
06:20:22 <DRMacIver> True
06:20:24 <dmhouse> n+2 -> S(S(n))
06:20:26 * ehird` wonders what haskell parsers look like
06:20:47 <dmhouse> ehird`: Language.Haskell :)
06:20:59 <DRMacIver> I'm currently plotting a syntax which is even harder to parse than Haskell's. :-/
06:21:05 <DRMacIver> At least in some ways.
06:21:17 <dmhouse> DRMacIver: what's it like?
06:21:18 <dolio> DRMacIver: Is it called C++? :)
06:21:33 <DRMacIver> dmhouse: It basically takes the idea of user defineable fixity much much too far.
06:21:36 <ehird`> DRMacIver: Are you adding C++'s syntax to a malbolge interpreter?
06:21:43 <DRMacIver> Ha
06:21:53 <DRMacIver> It's not quite as bad as malbolge or C++.
06:22:19 <ehird`> malbolge is easy to parse
06:22:21 <ehird`> one-char-at-a-time
06:22:33 <ehird`> it's the cryptography part that's hard :)
06:22:40 <DRMacIver> The idea is to allow arbitrary fixity declarations mixed in with the code, and to be able to prefix, postfix, etc. expressions as well as symbols.
06:23:02 <DRMacIver> e.g. <- is a high precedence binary operator such that foo <- bar is a postfix operator.
06:23:44 <DRMacIver> So record update is myRecord #foo <- bar, and this isn't special syntax. Just normal operators in the language.
06:23:45 <dmhouse> Does that mean you need first-class patterns, too?
06:24:00 <DRMacIver> I don't think so.
06:24:19 <DRMacIver> I'm not sure how far I'm going to take this. I suspect I'll wuss out on the precedence, to start with at least.
06:24:29 <DRMacIver> So that you need to liberally apply brackets to make the syntax work.
06:24:46 <dmhouse> Ah okay. I was thinking along the lines of 'do Just x <- lookup "foo" table'. If <- is a normal function...
06:24:59 <DRMacIver> Oh, sorry. <- isn't intended to be a monadic operator here.
06:25:08 <DRMacIver> Or whatever the damn thing is called. :)
06:25:31 <DRMacIver> This isn't really for a Haskell like language, although it will have a number of inspired features.
06:25:36 <ehird`> "They exploit a loophole that, although a function cannot directly cause a side effect, it can construct a value describing a desired side effect that the caller should apply at a convenient time." Ahh. NOW I understand monads. They're... complete lies so haskell can claim fully-functionalness
06:26:19 <pitecus> @djinn f a -> f (Int, a)
06:26:20 <lambdabot> -- f cannot be realized.
06:26:33 <dmhouse> ehird`: err... not really.
06:26:45 <ehird`> dmhouse: I was half-joking :)
06:26:53 <dmhouse> ehird`: I thought as much. :)
06:26:57 <dmhouse> Although the IO monad _is_ a lie
06:27:04 <pitecus> @hoogle f a -> f (Int, a)
06:27:05 <lambdabot> No matches, try a more general search
06:27:10 <DRMacIver> dmhouse: In what sense?
06:27:31 <ehird`> DRMacIver: Well, it produces side-effects at one point in the chain - executing it multiple times does not produce the same result.
06:27:33 <dmhouse> DRMacIver: in that it doesn't in actual fact update a RealWorld state parameter which represents the state of the real world.
06:27:43 <ehird`> DRMacIver: So that seems...non-funciontal to me
06:28:00 <ehird`> dmhouse: that would be a rather big task, I imagine
06:28:22 <dmhouse> ehird`: yes, one would hope for O(1) access and update.
06:28:22 <DRMacIver> ehird`: Sure it does. You're just calling it with different values of the RealWorld type. ;)
06:28:25 <DRMacIver> dmhouse: True
06:29:06 <ehird`> dmhouse: I'm working on getting the source code of the universe, maybe then ;)
06:29:11 <DRMacIver> Anyway, I sortof agree. But from another perspective, who cares? :)
06:29:19 <dmhouse> The fact remains that a completely pure language can't perform IO.
06:29:27 <dmhouse> The fact also remains that who cares. :)
06:29:38 <DRMacIver> They do a good job of isolating and structuring the side effects, which is what really matters.
06:29:45 <dmhouse> Yeah, exactly.
06:29:45 * Heffalump doesn't think that the IO monad is a lie at all, since as DRMacIver says, you can never call it with the same RealWorld twice
06:29:53 <dolio> :) What if it's implemented under the hood with continuation or stream based IO, or one of the other purely functional mechanisms? :)
06:30:00 <Heffalump> but if you could, it would produce the same result
06:30:08 <ehird`> Maybe, functional computers. I don't know how that would work but it'd make IO not a lie
06:30:55 <DRMacIver> In the same way that you can never cross the same river twice? :)
06:31:49 <DRMacIver> On which note, I'm going shopping.
06:31:51 <DRMacIver> Bye
06:32:16 <dmhouse> Have fun. :)
06:32:27 <Heffalump> I still don't accept that IO is a lie.
06:32:47 <dons> Heffalump: do you know why Richard Bird has so few of his papers online?
06:33:44 <dons> i've been luck in tracking down a couple that appear in the oxford eprint online library, but most of his functional pearls aren't online, http://haskell.org/haskellwiki/Research_papers/Functional_pearls
06:33:45 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
06:34:07 <Heffalump> dons: probably because he's just not used to putting them there.
06:34:10 <Heffalump> I'd suggest emailing him.
06:36:05 <dons> mmm. yes ok. maybe he will just put them up if someone asks.
06:36:05 <dons> its a bit incongruous that almost every pearl is online, except the Bird-style ones :-)
06:37:44 <pitecus> I'm trying to write a function like (zip [1..]) except it should work for all functors and not just lists, and can't quite figure out how ...
06:38:22 <dons> mmm fzip eh?
06:38:36 <dons> :t zip
06:38:40 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:38:57 <dons> zipWithM          :: (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:39:40 <pitecus> zipWithM is quite that is it
06:39:45 <pitecus> isn't
06:40:47 <dmhouse> It's an interesting challenge.
06:41:19 <dolio> It might need to be an applicative functor?
06:41:25 <dmhouse> I don't see any obvious reason why it should be impossible, but I can't think of a definition.
06:41:40 <pitecus> hm
06:42:02 <dolio> :t ZipList
06:42:05 <lambdabot> forall a. [a] -> ZipList a
06:42:06 <dmhouse> Based on the latter, I'd be tempted to say that it needs more structure. Applicative functors would certainly be sufficient.
06:42:28 <pitecus> is Map an applicative functor?
06:43:05 <dolio> If you want to do it with Map I think unionWith would suffice.
06:43:28 <pitecus> I want a function which works for maps and lists
06:43:33 <dolio> Or, no, perhaps not.
06:44:15 <dolio> intersectionWith.
06:44:27 <pitecus> I can just define my own Zippable typeclass or smth
06:44:41 <pitecus> but i thought Functor should be enough...
06:45:20 <fmar> I have question about the internal memory use of Word types. Does a Word8  have word size internally (i.e. 4 bytes on a 32 bit machine)?
06:45:41 <ehird`> fmar: probably has overhead of haskells  tuff
06:45:54 <dolio> > getZipList $ pure (,) <*> ZipList [1..5] <*> ZipList [6..10]
06:46:37 <fmar> Would it matter memory wise if i use a [Word8] instead of [Word]?
06:46:40 <pitecus> ouch
06:46:42 <dmhouse> fmar: I think Word8 is 8 bits long ;)
06:47:37 <fmar> dmhouse: i know,  i am asking about the internal memory use.
06:49:17 <dolio> > getZipList $ (,) <$> ZipList [1..5] <*> ZipList [6..10]
06:49:19 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
06:50:05 <pitecus> dolio, would it work with Map?
06:50:42 <dolio> It would probably work if you could define an Applicative instance for Map, but I don't think you can the way it's currently structured.
06:51:02 <pitecus> sigh
06:51:37 <dolio> Because the relevant Map functions require an 'Ord a =>' instance.
06:52:44 <pitecus> that business with Ord a => messing up stuff is really annoying in Haskell. Its the same thing that prevents Set from being a Functor right?
06:52:47 <dolio> Or, context, that is.
06:53:09 <dolio> Yes, that's correct.
06:53:41 <Saizan> ?type intersectionWith
06:53:43 <lambdabot> Not in scope: `intersectionWith'
06:53:50 <Saizan> ?type Data.Map.intersectionWith
06:53:52 <lambdabot> forall a b c k. (Ord k) => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
06:54:05 <dolio> You can make Set a Monad if you change the class around and use GADTs (there may be other ways as well), but I'm not sure about Functor.
06:54:39 <LeCamarade> #haskell is the best-equipped channel on Freenode, no? I mean, with hpaste and a very, very well-made bot.
06:54:46 <ehird`> LeCamarade: lol?
06:54:51 <ehird`> lisppaste is everywhere, for one
06:54:54 <ehird`> and that's a capable bot
06:55:03 <ehird`> lambdabot is neat, yes
06:55:06 <ehird`> but parallels exist
06:55:26 <Heffalump> dolio: change the class around?
06:55:51 <Saizan> with Map the Ord contraint is only on k, so you can make instance Ord k => Monad (Map k) if you have a suitable definition
06:55:55 <LeCamarade> ehird`: I am only in #haskell and #ocaml, so I am not too exposed. And #ocaml is very, very threadbare.
06:56:27 <LeCamarade> I'm 'pposed to be getting them an IRC bot, but ... my loyalties seem to have shifted. :o(  :o) :oD
06:56:44 <dolio> Heffalump: class Monad m a where { return :: a -> m a ; (>>=) :: (Monad m b) => m a -> (a -> m b) -> m b }
06:56:46 <dolio> As I recall.
06:57:11 <dolio> That's one way.
06:57:24 <ehird`> ocaml is neat i just... wish it was pure
07:00:03 <LeCamarade> ehird`: My problem with it that I want a language that provides only the right ways as the available options. OCaml lets me do impure stuff. I no longer trust myself with impurity. I've come to depend on Haskell that much.
07:00:11 <tarantoga> I'm trying to install HaRe.  make fails with "ghc-6.6: unknown package: lang".  where do I find that package?
07:00:32 <LeCamarade> tarantoga: What OS/distro?
07:01:04 <tarantoga> LeCamarade: debian sid
07:01:38 <LeCamarade> Go to the root prompt (sudo su) and then apt-cache search. Lemme try them out as we go.
07:02:34 <ehird`> LeCamarade: Yeah.
07:02:40 <ehird`> Pure functional programming is amazing
07:03:03 <LeCamarade> tarantoga: What does it say in GHCi when you try to load the Language.Haskell module?
07:03:31 <tarantoga> Could not find module `Language.Haskell'
07:03:54 <dolio> Heffalump: Example here: http://hpaste.org/1449
07:04:30 <tarantoga> maybe it's libghc6-haskell-src-dev
07:04:46 <LeCamarade> tarantoga: Okay, in GHCi, try typing :m Langauge and tab three times. Does it try to open a list?
07:04:52 <ehird`> i find haskell's syntax, though, can be a bit obscure
07:04:57 <ehird`> ocaml's is clearer
07:05:24 <LeCamarade> ehird`: Not at all. Nothing uglier than OCaml in the functional world. Nothing.
07:05:37 <tarantoga> LeCamarade: yes, indeed
07:05:38 <ehird`> Not IMO
07:05:43 <psykotic> LeCamarade, come on, double semicolons are the best! :)
07:05:55 <ehird`> psykotic: i was about to say something like that heh
07:05:59 <LeCamarade> ehird`: I just can't stop the wet dreams about Haskell syntax. God bless significant whitespace.
07:06:01 <ehird`> but thats the only ugly bit about it imo
07:06:09 <LeCamarade> psykotic: :oD
07:06:21 <ehird`> well... i hate the non-operator-overloading too :P
07:06:45 <LeCamarade> ehird`: And the very worst REPL under the sun. No readline, even though ledit(1) is written in OCaml.
07:07:14 <LeCamarade> tarantoga: So, if you get a list of other modules in Language.Haskell, then ...
07:07:26 <ehird`> chicken scheme uses just plain stdin
07:07:31 <ehird`> that doesn't make it lame
07:08:33 <LeCamarade> Try: apt-get install libghc6-haskell-src-dev --yes --force-yes --fix-missing
07:08:36 <LeCamarade> :oD
07:09:10 <LeCamarade> ehird`: There is no space in the world for a REPL where I can't use the back arrow key!
07:09:31 <ehird`> rlwrap
07:09:32 <ehird`> use it
07:09:39 <LeCamarade> I'd ban such things from my country, if I were president. Only Haskell for the revolution. :oD
07:09:47 <ehird`> rlwrap
07:10:11 <Cheery> too bad one doesn't have plan9-style stdin&stdout
07:10:29 <ehird`> Cheery: what's special about it? just implement it in the terminal
07:10:31 <ehird`> that's what p9 does
07:10:34 <sioraiocht> is (++) O(min(m,n)) or O(n)
07:10:40 <LeCamarade> ehird`: Let me apt-get it and see ...
07:10:49 <ehird`> LeCamarade: usage: rlwrap command
07:10:55 <ehird`> tried it with ocaml jsut now, works perfectly
07:11:16 <Cheery> ehird`: well, what's special about it is that the actual 'terminal' is a bit like text-out/text-in, it's not a kitchen sink
07:11:22 <ehird`> Cheery: i know
07:11:31 <LeCamarade> ehird`: Woo!!!!
07:11:35 <LeCamarade> Yay!
07:11:36 <ehird`> i use plan 9 very often :)
07:12:08 <ehird`> iirc 9term is a few hundred lines long, and leaves the line editing to rio's text-windows
07:12:11 <LeCamarade> I use House. :oD
07:12:15 <Cheery> I don't use, but I would like to
07:12:23 <sioraiocht> @src (++)
07:12:24 <lambdabot> (++) []     ys = ys
07:12:24 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
07:12:27 * LeCamarade is kidding.
07:12:31 <ehird`> well. i use it in qemu :P
07:12:54 <dolio> sioraiocht: (++) most likely duplicates the first list, so it should be proportional to the length of that.
07:12:55 <ehird`> +plan9port
07:13:06 <LeCamarade> ehird`: Yeah, in qemu. And it is pure suckage. Only positive is the language used. :oD
07:13:20 <ehird`> LeCamarade: plan9?
07:13:21 <Cheery> ehird`: does haskell have plan9 port?
07:13:33 <ehird`> Cheery: no, are you allergic to compiling c software? :)
07:13:34 * LeCamarade has this in .bashrc: alias ocaml='rlwrap ocaml'
07:14:00 <LeCamarade> ehird`: HURD?
07:14:20 <Cheery> ehird`: I don't know that I'd be allergic to anything, I just get very bad itch to my back when somebody mentions C
07:14:40 <ehird`> Cheery: some of ghc is written in C
07:14:41 <ehird`> mwahaha
07:15:05 <LeCamarade> @remember Cheery I don't know that I'd be allergic to anything, I just get very bad itch to my back when somebody mentions C
07:15:05 <lambdabot> Done.
07:15:49 <Cheery> thought, there's a cure to that itch
07:18:00 <Cheery> I think the C in plan9 does not look too bad
07:18:55 <Cheery> if I'd concentrate on making myself clear how the variables and different memory locations would behave, I'd actually understand it
07:19:23 <vegai> hugs at least used to be ported to plan9
07:20:04 <vegai> yhc might be easy to port
07:20:12 <vegai> ghc... perhaps not, I don't know
07:23:16 <DRMacIver> ehird`: Which parts?
07:23:29 <ehird`> DRMacIver: The basic core, iirc
07:23:56 <DRMacIver> Any particular reason?
07:24:18 <ehird`> For bootstrapping?
07:25:07 <LeCamarade> yhc should be easy to port. We have GCC, you know. That's portability embodied.
07:25:16 <DRMacIver> Ah, that makes sense.
07:25:21 <ehird`> Plan 9's gcc sucks
07:25:28 <ehird`> The reccomended compiler is 9c
07:28:47 <vegai> yeah, Plan 9 doesn't really support gcc
07:28:58 <ehird`> plan 9 doesn't really support gnu.
07:29:04 <vegai> that too
07:33:21 <LeCamarade> HURD! HURD!
07:33:34 <ehird`> LeCamarade: stfu
07:33:37 * LeCamarade likes that an OS' name can be a recursive data type!
07:33:39 <dmhouse> Anyone know if HaskellNet has any kind of SSL support?
07:33:53 <ehird`> i am an internet-enabled recursive data type, then
07:34:23 <LeCamarade> dmhouse: My efforts to get HaskellNet are always frustrated. Ne'er tried it. How do I get it? Need POP, here.
07:34:38 * dmhouse is playing around with it.
07:34:43 <LeCamarade> dmhouse: Sorry that I don't answer your question and just badger in with my own ...
07:34:58 <dmhouse> I have some simple POP access working, but any kind of encryption doesn't seem to be supported...
07:35:32 <LeCamarade> dmhouse: How do I get the blerry thing?
07:35:38 <dmhouse> ?where HaskellNet
07:35:39 <lambdabot> I know nothing about haskellnet.
07:35:55 <dmhouse> ?where+ haskellnet http://darcs.haskell.org/SoC/haskellnet/
07:35:56 <lambdabot> Done.
07:36:01 <dmhouse> LeCamarade: darcs get that address.
07:37:13 * LeCamarade opens a new terminal.
07:38:16 <dmhouse> In fact, does anyone know of any Haskell libraries to facilitate SSL communication in general?
07:39:06 <mahogny> hm. AFAIK hackage is rather thin on crypto in general
07:40:45 <dons> sometwo: hey, re. type constructors with variable numbers of args, see 'Build' on oleg's page.
07:40:56 <dons> you can use a recursive typeclass to gather up the arguments
07:40:59 <dons> in the  style of printf
07:41:09 <dons> grr. s/sometwo/sorear/
07:42:39 <bla123> is "someMonadicValue >>= return . (* b)" the shortest code for "someMonadicValue * b"?
07:42:55 <Heffalump> how's that give you a type constructor with variable arguments?
07:43:06 <Heffalump> bla123: liftM (* b) someMonadicValue
07:43:22 <bla123> thx, that looks neat
07:43:57 <wy> Hi, I'm trying HOpenGL. Can it run under windows?
07:44:13 <dons> ?pl someMonadicValue >>= return . (* b)
07:44:14 <lambdabot> (b *) `fmap` someMonadicValue
07:44:25 <dons> wy, I think so, yeah.
07:44:49 <dons> Heffalump: it doesn't, its just a trick for building types of variable length
07:44:55 <dons> so, related work.
07:44:59 <wy> dons: I got an error: Could not find module `GL' from the first example BezMesh.hs
07:45:19 <dons> :t printf "%d %c %s" (7 :: Int)
07:45:21 <dons> :t printf "%d %c %s" (7 :: Int) 'x'
07:45:21 <lambdabot> forall t. (PrintfType (Int -> t)) => t
07:45:23 <lambdabot> forall t. (PrintfType (Int -> Char -> t)) => t
07:45:24 <dons> :t printf "%d %c %s" (7 :: Int) 'x' "String"
07:45:27 <lambdabot> forall t. (PrintfType (Int -> Char -> [Char] -> t)) => t
07:45:56 <wy> It seems I need more setup
07:46:06 <Heffalump> dons: ah, ok.
07:46:06 <TomMD> Is this printf actually safe?
07:46:22 <dons> the format string isn't statically checked
07:46:30 <dons> but it is checked.
07:46:40 <wy> Isn't it included in the ghc distribution? I saw a glut folder.
07:46:44 <dons> :t printf "%d %c %s" (7 :: Int) 'x' "foo" :: String
07:46:47 <lambdabot> String :: String
07:46:50 <dons> > printf "%d %c %s" (7 :: Int) 'x' "foo" :: String
07:46:51 <lambdabot>  "7 x foo"
07:46:53 <dmhouse> TomMD: yes, with the proviso that you give it the right type arguments.
07:46:56 <dons> > printf "%d %c %s" (7 :: Int) 'x' (Just 'x') :: String
07:46:57 <lambdabot>        add an instance declaration for (PrintfArg (Maybe Char))
07:46:58 <lambdabot>     In the ex...
07:47:04 <dons> > printf "%d %c %s" (7 :: Int) 'x' 'y' :: String
07:47:06 <lambdabot>  Exception: Printf.printf: bad argument
07:47:07 <dmhouse> > printf "%d" "hello" -- this will be a runtmie error.
07:47:08 <lambdabot>  Add a type signature
07:47:27 <dmhouse> TomMD: see the documentation of printf :)
07:47:30 <wy> dons: Can you help me?
07:47:35 <dons> the statically checked variants of printf involved encoding the format string as a GADT, or using TH to generate specialised typechecked prinft
07:47:57 <dons> wy, I'm not familiar with windows. but check you have the OpenGL package installed?
07:48:10 <dmhouse> Hrm, darcs uses SSL, right? Maybe I should check its cabal file to see which package it uses for that.
07:48:17 <dons> it uses curl, I think
07:48:39 <wy> dons: I think they will be the same. I have a dir "C:\ghc\ghc-6.6\imports\Graphics\Rendering\OpenGL\GL". I guess that is it.
07:48:59 <dmhouse> Oh. So it outsources all the SSL stuff to curl? Or is there a curl Haskell package?
07:49:46 <dons> wy, oh, are you using --make then?
07:50:25 <ehird`> why is ghc --help,
07:50:27 <ehird`> giving ghci help
07:51:12 <wy> dons: I just used ghc and ghci without switches. The same error message.
07:57:00 <dons> ghc --make is required. (though, hmm, if ghci is failing, then maybe GL isn't registered?)
07:57:08 <dons> ehird`: they're the same program.
07:57:18 <dons> ghci == ghc --interactive
07:57:19 <ehird`> dons: right, but ghc --help shouldn't start with:
07:57:27 <dons> right. there's a bug report about this.
07:57:27 <ehird`> Usage:
07:57:27 <ehird`>     ghci [command-line-options-and-input-files]
07:57:31 <ehird`> In addition, ghci accepts most of the command-line options that plain
07:57:31 <ehird`> GHC does.  Some of the options that are commonly used are:
07:57:33 <ehird`> etc
07:57:44 <ehird`> because, uh, i want the option list of ghc, and apparently i have no manpages
07:58:29 <dons> they do. the main reference is the ghc user's guide.
07:58:37 <ehird`> i see no manpages
07:58:52 <dons> whether the man page is installed depends on the local package system, but the comprehensive user guide is here:
07:59:05 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
07:59:07 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.6.1, http://tinyurl.com/y4o7nt
07:59:51 <dons> here's the flag reference, http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
07:59:53 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
08:00:06 <wy> dons: I used "ghc --make BezMesh.hs". The same error
08:00:29 <dons> wy, seems like your OpenGL install is broken somehow.
08:00:38 <dons> perhaps ask for help on haskell-cafe@ from other windows users?
08:00:46 <dons> ndm might know the answer.
08:01:34 <wy> dons: It shouldn't be. It's simply unpacked in a directory. Are there any environment variables to set except path?
08:04:37 <dons> you didn't build and install the opengl package from source then, just untarred a binary package?
08:04:51 <dons> or just unpacked a ghc build?
08:05:11 <dons> use ghc-pkg to list the available, registered haskell packages
08:07:07 <wy> Cabal-1.1.6, GLUT-2.0, HUnit-1.1, OpenGL-2.1, QuickCheck-1.0,
08:07:07 <wy> Win32-2.0, base-2.0, cgi-2006.9.6, fgl-5.2, (ghc-6.6),
08:07:07 <wy> haskell-src-1.0, haskell98-1.0, html-1.0, mtl-1.0, network-2.0,
08:07:07 <wy> objectio-1.0, parsec-2.0, readline-1.0, regex-base-0.71,
08:07:07 <wy> regex-compat-0.71, regex-posix-0.71, rts-1.0, stm-2.0,
08:07:08 <wy> template-haskell-2.0, time-1.0, xhtml-2006.9.13
08:07:49 <sorear> 07:40:45 <dons> sometwo: hey, re. type constructors with variable numbers of args, see 'Build' on oleg's page.
08:07:49 <sorear> 07:40:56 <dons> you can use a recursive typeclass to gather up the arguments
08:07:49 <sorear> Except that only works with data constructors.  To do it with type constructures would require kind classes and bounded kind polymorphism.
08:07:55 <wy> dons: Do I need greencard?
08:08:08 <dons> wy, ah, no. you're using a different api.
08:08:14 <dons> that's OpenGL 2.*, which has Graphics/Rendering/OpenGL/GL.hs
08:08:23 <dons> sorear: certainly. just pointing out a related trick
08:08:56 <dons> wy, so you're using SOE or something, which need sthe OpenGL 1.* api?
08:09:18 <wy> How do you know?
08:09:42 <dons> because the program was asking for module 'GL'
08:09:50 <dons> not 'Graphics.Rendering.OpenGL.GL' ?
08:10:04 <dons> and a couple of other people doing old tutes have raised this issue
08:10:12 <wy> Because the example program used "import GL"
08:10:18 <dons> yeah, that's the old api.
08:10:27 <hpaste>  dmhouse pasted "c2hs erros when building hsgnutls" at http://hpaste.org/1711
08:10:30 <dons> try changing it to 'import Graphics.Rendering.OpenGL.GL'
08:10:35 <sorear> hopengl predates hiermods!?
08:10:40 <dons> sure does.
08:10:41 <dmhouse> Hey all. Anyone familiar with c2hs that could have a look at that paste?
08:10:56 <sorear> @seen dcoutts
08:10:57 <dons> sorear: the textbook from which SoE comes is late 90s.
08:10:57 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 16h 35m 51s ago.
08:11:02 <sorear> @seen dcoutts_
08:11:03 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 19h 49m 11s ago.
08:12:03 <wy> dons: It seems I need more recent examples. The program still has errors.
08:12:30 <dons> sorear: I guess my point is answering 'no' to a random newbie is not as helpful as explaining what the alternatives are. probably the guy was just trying to do the YAHT tut, and needed to know about sum types
08:12:46 <dons> wy, yeah. that seems likely.
08:13:10 <dons> wy, there are updated tutorials on graphics programming. perhaps check the new nehe tuts, or the gtk2hs site
08:13:25 <sorear> dons: His question was too low level for me to suggest alternatives.
08:13:40 <sorear> dons: should I have added a what-are-you-trying-to-do?
08:13:41 <wy> dons: But it seems HOpenGL hasn't been updated for years.
08:13:55 <sorear> wy: HOpenGL has been updated in the last year
08:14:04 <dons> sorear: I'd have said, 'ah, if you're trying to do this, maybe you meant to use sum types, here's an example: ...'
08:14:11 <sorear> wy: with support for opengl 2.x (read: shader programming)
08:14:23 <dons> sorear: since it looks suspiciously like the infamous 'Tuple' problem from YAHT
08:14:42 <sorear> wy: however it's in GHC now.  dunno what the state of the external one is
08:14:43 <wy> sorear: Is the latest release HOpenGL-1.05  (09/09/03)?
08:15:01 <dons> nah, the 'OpenGL' package is updated externally. check hackage.haskell.org
08:15:29 <dons> wy, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL-2.1
08:15:32 <lambdabot> http://tinyurl.com/2cjvrd
08:15:36 <sorear> wy: My most recent patch in my HOpenGL repo is dated Apr 30 2007
08:15:56 <Cheery> wait, do you mean it is updated often?
08:15:58 <sorear> altough that's just Igloo struggling with the extralibs build system
08:16:12 <Cheery> ?where HOpengGL
08:16:13 <lambdabot> I know nothing about hopenggl.
08:16:18 <dons> well, its moderately maintained
08:16:20 <Cheery> ?where HOpenGL
08:16:21 <lambdabot> http://haskell.org/HOpenGL/
08:16:25 <Cheery> nice
08:16:26 <dons> and the glut layer on top
08:16:38 <sorear> Tue Apr 24 04:38:31 PDT 2007  Ian Lynagh <igloo@earth.li>
08:16:38 <sorear>   tagged Version 2.2.1
08:16:41 <sorear> wy: ^^^
08:16:46 <dons> ah, for 6.6.1
08:16:59 <Cheery> do they accept minor modifications into API?
08:17:14 <dons> yeah, if there's real users. please dive in on libraries@
08:17:27 <Cheery> or hmm, wait, this is not HOpenGL -thing I'm wondering
08:17:35 <dons> some killer applications that use OpenGL would be a good start :-)
08:17:44 <dons> worked for the X11 package.
08:18:17 <sorear> I know how to write a hardware accelerated fractal flame renderer.
08:18:37 <jcreigh> I can make popcorn!
08:18:53 <dons> well, we'll need that for XMonadContrib.FlamingGlassEffect
08:18:57 <sorear> I might just debug and release it if it weren't for a 5-year-old crash bug in X.org which renders my GLX unusable
08:19:08 <LeCamarade> dcoutts: HaskellNet must have SSL, because I am asked for Crypto when running configure.
08:20:25 <Cheery> do you know whether there's something interesting happening, ie. stuff which has chances of changing the society?
08:20:58 <Philippa> "the society"?
08:21:03 <sorear> seems like every five minutes dons is commenting about this "lambda revolution" thing
08:21:07 <dons> "something"?
08:21:51 <dons> C# got a list monad, that's something
08:22:03 <Cheery> dons, Philippa, sorear, breakthroughs on their way
08:22:12 <jcreigh> lambdas are cropping up everywhere.
08:22:27 <dons> hmm. new breakthroughs? DPH might be one, I suppose.
08:22:28 <Cheery> jcreigh: I know that
08:22:32 <dons> need a crystal ball
08:22:38 <Philippa> there's both a pile of ongoing breakthroughs in what's possible and a big shift in what's on the edge of the mainstream
08:22:43 <LeCamarade> F# for .NET.
08:22:52 <dons> there's lots of interesting multicore research going on, related to pure FP languages.
08:23:06 <Philippa> the ongoing type system developments're part of a pretty huge shift, too
08:23:29 <Philippa> mmm. shapr and I were brainstorming in PM last night about STM and caching on NUMA systems
08:24:04 <Cheery> dons: where? do you have more references about results this far?
08:24:18 <dons> ?where DPH
08:24:18 <jmg_> hi
08:24:18 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
08:24:38 <dons> Cheery: nested, transparently parallel arrays. new, can't do it anywhere else.
08:24:49 <wy> sorear:  It seems http://haskell.org/HOpenGL/ is not updated?
08:24:50 <lambdabot> Title: HOpenGL
08:25:02 <dons> so maybe. but 'changing society' is a bit to megalomanical even for me.
08:25:04 <sorear> wy: afaik too
08:25:05 <Cheery> I didn't know that ppl still have stuff to do at those type systems
08:25:14 <sorear> Oh sure!
08:25:22 <dons> wy, yeah, probably not updated.
08:26:03 <wy> dons: Then how can I find the latest documentation and tutorials?
08:26:10 <sorear> @docs
08:26:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:26:11 <dons> the type system work is about extending the type system continually to handle more and more static proofs, while remaining usable. lots of cool stuff happening there.
08:26:22 <dons> wy, maybe on the 'Blog page' ? or the wikibook?
08:26:49 <Cheery> dons: does that mean the type system will become even more expressive?
08:26:54 <sorear> Cheery: I think the new thing that is the most likely to crop up in actual haskell programs, is the new type family infrastructure.
08:27:20 <sorear> Cheery: in GHC HEAD you can define datatypes and newtypes as members of classes, as well as functions
08:27:20 <dons> Cheery: yeah, that's been a continuing trend since , well, forever.
08:27:37 <dons> yeah, associated types and indexed type families radically increase expressiveness
08:27:43 <sorear> Cheery: there is ongoing work to implement type synonyms, but this is harder for obvious reasons
08:27:46 <dons> we'll spend the next 10 years working out what we can do wit hthat.
08:28:18 <Cheery> wait, you mean even functions will get classes?
08:28:28 <sorear> Cheery: ?
08:29:01 <wy> dons: It seems I need more knowledge about the system. Although I can program in Haskell somewhat, I know nothing about Cabal, ...
08:29:03 <Cheery> ie. instance somefunction
08:29:22 <sorear> Cheery: class Keyable a where data Set a ; insert :: a -> Set a -> Set a ; member :: a -> Set a -> Bool
08:29:32 <dons> wy, hmm. perhaps start with a tutorial that doesn't involved using an old api. or maybe take the current docs, and try to write a small program for opengl?
08:29:46 <dons> Cheery: hmm, no, more like type level functions
08:29:53 <dons> so even more programming in the type system than we currently do
08:30:00 <dons> meaning even more stuff proved at compiled time.
08:30:06 <sorear> instance Keyable Int where newtype Set Int = IntSet ; insert = IS.insert ; member = IS.member
08:30:12 <sorear> ...
08:30:31 <Cheery> ah
08:30:37 <dons> yes, and new optimisation opportunities, as more things are availabel statically to the compiler
08:30:48 <fmar> I've found the answer to the question i asked earlier. In GHC Word8, Word16 and Word are implemented as primitive type Word# which indeed has the word size of the processor, i.e. 32 bits on 32-bit machines and 64 bits on 64-bit machines.
08:31:07 <sorear> fmar: Indeed.
08:31:52 <sorear> fmar: it is *such* a shame that the ghc code generator does not support subword types
08:31:55 <drigz> isn't that really memory inefficient?
08:32:20 <sorear> fmar: also, [Word8] costs up to 20 bytes per word
08:32:38 <sorear> 12 bytes for the cons cell, 8 bytes for the Word8
08:33:22 <dons> packed structures of Word8's et al use the native type.
08:33:28 <sorear> fmar: look at Data.ByteString
08:33:37 <fmar> Thanks for the info. No wonder ByteString is far more efficient.
08:33:39 <dons> and other types, like UArray Bool, use bit packing
08:33:42 <sorear> dons: you mean with {-# UNPACK #-} ?
08:33:44 <jcreigh> why 12 bytes for a cons cell? head, tail and...?
08:33:49 <sorear> jcreigh: tag
08:33:51 <dons> sorear: yeah, unboxed types.
08:33:57 <jcreigh> ah
08:34:03 <sorear> dons: unboxed types are all at least 1 word
08:34:19 <sorear> dons: and ghc can't pack multiple source fields into one rts field
08:35:03 <dons> "packed structures"
08:35:25 <sorear> jcreigh: of course SML/lisp can cheat by saying a distinguished pointer is NIL and everything else is CONS, but we don't have that luxury because as a result of laziness our lists have hundreds of constructors.
08:35:32 <dons> so a UArray of Word8 will happily use byte packing.
08:35:33 <jcreigh> hmm. what if there are more than 2^wordsize types? :)
08:36:03 <Cheery> Is it huge sin if I put some cabal packaged code into SVN repository?
08:36:15 <sorear> jcreigh: # of types doesn't matter, but you do need separate closure code for each constructor and thunk
08:36:22 <sorear> and info tables
08:36:24 <Botje_> not if you reimplement svn in haskell first :)
08:36:45 <Cheery> what if I don't?
08:37:20 <dons> hmm,
08:37:20 <dons> typedef signed   char            StgInt8;
08:37:21 <dons> typedef unsigned char            StgWord8;
08:37:25 <sorear> Then you will be haunted by visions of sad David Roundy for the rest of your life.
08:37:31 <jcreigh> Cheery: Haskell people tend to prefer darcs, so that would probably be nicest if you don't have some compelling reason to use svn.
08:37:42 * ehird` uses Mercurial
08:37:47 <ehird`> it's python, so it's not too bad
08:38:33 <dons> Cheery: yeah, its a sin. cabal will self immolate when it is run inside svn
08:39:09 <ehird`> ghc --make is cool
08:39:14 <ehird`> if only there was a ghc --clean
08:39:20 <dons> in practice though, it'll just be a little bit harder to get patches from haskellers, since they often don't have svn.
08:39:48 * sorear has svn because yhc depends on it.
08:39:57 <dons> so who's read all 64 functional pearls today?
08:40:00 <Cheery> jcreigh: my other stuff is in SVN -server
08:40:15 <Heffalump> and with darcs you can easily make patches locally and then think about submitting them
08:40:22 <dons> and do you know code like the child of Bird and Wadler?
08:40:26 <dons> s/now/
08:40:52 <ehird`> Cheery: why do you use svn?
08:40:53 <dmhouse> Could anyone familiar with c2hs take a look at http://hpaste.org/1711, please?
08:41:19 <Cheery> ehird`: it originates from trac and it's settings
08:41:26 <sorear> is dcoutts still on dons time?
08:41:39 <dons> nah. he's back home.
08:41:47 <Cheery> thus I'm bit on air since I don't yet have my own repos (just a very good friend who provided it)
08:41:55 <ehird`> Cheery: ah
08:42:08 <Cheery> if I could get darcs repo from somebody, I could use that too
08:42:17 <ehird`> Cheery: i'd imagine plenty of people are willing to host <hip vcs here> repos
08:42:21 <sorear> $ darcs init
08:42:37 <ehird`> sorear: that too.
08:42:48 <jcreigh> sorear: so that "tag" in GHC is which constructor the heap object is?
08:42:55 <sorear> also, darcs.haskell.org will host for people (at least they have ~sjanssen)
08:43:07 <sorear> jcreigh: yes, fsvo constructor.
08:43:15 <ehird`> darcs dies on huge projects
08:43:22 <ehird`> and it's quite slow otherwise
08:43:24 <ehird`> so i use hg
08:43:26 <dons> so we hear.
08:43:41 <sorear> ehird`: your project is seriously bigger than GHC?
08:43:54 <dons> haven't run into slowness, other than occasional large merges in ghc
08:44:04 <dons> but, then again, who has 15k patches lying around.
08:44:07 <sorear> stefan@stefans:/usr/local/src/ghcfull$ du -sh ghc
08:44:07 <sorear> 195M    ghc
08:44:07 <ehird`> sorear: it's not haskell-based, and it isn't "my" project, but it is a project that i immerse in a non-svn VCS for private hacking
08:44:23 <ehird`> let's put it this way - combined trees of Qt and KDE.
08:44:29 <ehird`> 400mb, or so, unpackaed.
08:44:50 <dons> the size alone should be fine. I have 400M of #haskell logs in darcs
08:44:57 <ehird`> darcs sees it and decides it wants to sit there, cry, and eat up 100% cpu
08:45:02 <dons> it would be more the interleaving of patches and their history
08:45:08 <jcreigh> dons: in darcs? What, in case you need to change it?
08:45:12 <ehird`> hg finishes importing it within 5 minutes
08:45:17 <Cheery> who should I mail at to get a darcs repository hosting from darcs.haskell.org ?
08:45:17 <dons> i just record patches each day.
08:45:22 * jcreigh submits a patch against dons's logs to cast himself in a better light.
08:45:25 <dons> jcreigh: yeah, sometimes, to keep the irc scripts working
08:45:48 <jcreigh> but the logs themselves?
08:45:57 <dons> ehird`: so, though, "it's quite slow otherwise" doesn't seem to be the experience. the huge project issue is known.
08:45:57 <sorear> jcreigh: darcs is also a quick-n-dirty replication scheme.
08:46:08 <ehird`> dons: slower than hg, for certain
08:46:08 <Cheery> I'd like to put it up on darcs to make sure ppl who likes to contribute wouldn't need to do much
08:46:10 <jcreigh> sorear: ah
08:46:17 <ehird`> hg is competitive with git, in some cases faster
08:46:22 <jcreigh> so the problem with darcs is size of patch, not size of repo?
08:46:31 <dons> ehird`: but not noticeable for the 98% of small projects, and for that, the expressivity win is worth it.
08:46:36 <sorear> Cheery: go on the haskell wiki, Haskell.org domain
08:46:40 <ehird`> hg is pretty expressive...
08:46:42 <Cheery> k
08:46:46 <sorear> Darcs has a niche.
08:46:55 <ehird`> easier to use than svn, for sure
08:47:08 <sorear> I doubt anything could improve on darcs in its role as small project RCS killer.
08:47:11 <LoganCapaldo> darcs feels slow. This speaking from trying out darcs before I heard any anti-darcs propaganda. Just saying, it does feel slow :)
08:47:12 <dons> ehird`: also, helps that the entire community has standardised on darcs. so we all just 'darcs send' code to each other all day long :-)
08:47:39 <ehird`> "standardized" on a vcs? that doesn't really make sense
08:47:40 <sorear> darcs has never felt slow to me.
08:47:49 <ehird`> different projects, different systems
08:47:54 <Heffalump> ehird`: not through any formal process. Just everyone has started using it.
08:48:09 <dons> ehird`: many many small projects. common vcs. easier contributions from outsiders.
08:48:23 <dons> like having a common build system.
08:48:52 <ehird`> yes, well, many many small projects will never be true
08:48:53 <dons> just having public darcs repos browsable directly as file systems is a producitivity improvment
08:48:57 <ehird`> people like kitchen sinks, and build them
08:49:39 <Cheery> hmm kitten sinks...
08:49:49 <ehird`> kitten...sinks...
08:49:52 <ehird`> i..see
08:50:12 <Philippa> I think haskell does better for avoiding that than many languages
08:50:24 <Philippa> it's probably the approach to polymorphism
08:50:56 <sorear> Philippa: Are you messaging the channel you meant to?
08:51:07 <dons> it has become a lot easier to break out common code into small libraries, host them on hackage, and then continue hacking
08:51:11 <Philippa> the kitchen sink tendency
08:51:14 <Philippa> yeah, yeah I am
08:51:30 <dons> so we've ended up with 100s of smallish (10-300 patch) darcs repos and libraries.
08:51:43 <dons> with cabal dependencies on 1-5 other things
08:53:57 <Cheery> sorear: not finding the place
08:54:56 <ehird`> what does ghc use as an intermediate language?
08:54:58 <ehird`> it seems to be asm
08:55:10 <LeCamarade> C--?
08:55:21 <dons> ehird`: hehe. are you crazy?
08:55:21 <sorear> ehird`: Multiple.
08:55:39 <dons> its Haskell -> Core -> C-- -> [C,Asm,ByteCode]
08:55:47 <LeCamarade> ehird`: Hexadecimal (for SPARC).
08:55:48 <ehird`> ah, right
08:55:50 <ehird`> i was looking at -v output
08:55:51 <sorear> ehird`: Core (a variant of system Fw), STG, C--, what dons is saying
08:55:53 <dons> the intermediate language (high level) is 'Core', the intermediate language (low) is C--
08:55:53 <ehird`> LeCamarade: 1337
08:56:01 <ehird`> and it only showed removing a .s file
08:56:06 <sorear> dons: we also have stg-level optimizations
08:56:14 <dons> stg is a normal form of Core.
08:56:16 <drigz> i want to find out about how the (->) monad works, where should i look?
08:56:29 <sorear> @source Control.Monad.Instances
08:56:29 <lambdabot> Control.Monad.Instances not available
08:56:38 <sorear> @slap lambdabot
08:56:39 * lambdabot slaps lambdabot
08:56:40 <mauke> @source Control.Monad.Reader
08:56:41 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
08:56:51 <dons> ehird`: right. the .s file is one of the few things written to disk
08:56:54 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/Control/Monad/Instances.hs
08:56:58 <lambdabot> http://tinyurl.com/25qyth
08:56:59 <dons> since there are separate assembly and linking phases
08:57:13 <sorear> Core is inprocess by default.
08:57:21 <dons> ehird`: for the full story, try ghc -v9 or so, to see all intermediate structures
08:57:33 <drigz> sorear: thanks, i'll have a look
08:57:36 <sorear> You can write it out using -fext-core (machine readable) or -ddump-simpl (human readable)
08:57:53 <LeCamarade> ghc -v9 | less, you mean?
08:58:06 <sorear> You can't read it in, the relevant code hasn't worked since 6.0.x (but Aaron Tomb is fixing that)
08:58:30 <dons> LeCamarade: when I want to read core, I use:   ghc -O -ddump-simpl Foo.hs | less
08:58:35 <ehird`> -v9 is VERBOSE!
08:58:58 <dons> ehird`: right. "to see *all* intermediate structures" (my emphasis)
08:59:03 <ehird`> :P
08:59:13 <dons> ehird`: usually -ddump-simpl is enough, perhaps -ddump-cmm for the lower levels
08:59:21 <sorear> I'm sure hat ghc would be even more verbose :p
08:59:30 <dons> when trying to understand optimisations, -ddump-simpl-iterations is useful
08:59:39 <dons> as you can see the result of each optimisation pass
09:01:52 <LeCamarade> @quote tm Miranda (tm) is a trademark of Research Software
09:01:52 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
09:02:06 <LeCamarade> @remeber tm Miranda (tm) is a trademark of Research Software
09:02:07 <lambdabot> Done.
09:02:13 <dons> heh
09:02:42 * LeCamarade won't stand people forgetting that. And lambdabot is too forgiving. QuickCheck remeber == remember. Fails after 1 test.
09:02:57 * LoganCapaldo plans to name child Miranda
09:03:17 <LoganCapaldo> We'll see if theres a trademark dispute then!!
09:03:19 <dons> but that's a trademark of Research Software. I hope you have a good lawyer.
09:03:19 <jcreigh> @googel edit distance
09:03:22 <lambdabot> http://en.wikipedia.org/wiki/Levenshtein_distance
09:03:25 <LeCamarade> LoganCapaldo: And will you put that on her passport, as well?
09:03:27 <jcreigh> very handy.
09:03:54 <LeCamarade> What algorithm does the spelling corrections?
09:04:14 <jcreigh> LeCamarade: see the linked wikipedia article.
09:04:24 <dons> LeCamarade: standard Levenshtein
09:04:28 <jcreigh> (I believe lambdabot uses Levenshtein...)
09:04:35 <dons> with edit cut off of 3 edits, iirc.
09:04:43 <dons> to avoid bizarre rebindings
09:05:13 <araujo> morning
09:05:57 <LeCamarade> Oh. Three edits.
09:06:03 <LeCamarade> @beer dons
09:06:04 <lambdabot> dons is in #xmonad, #haskell, #ghc, #haskell-overflow and #haskell-soc. I last heard dons speak 1m 21s ago.
09:06:15 <jcreigh> haha
09:06:21 <mauke> @blog
09:06:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:06:37 <dons> now everyone knows the trick. what fun we shall have.
09:06:53 <LeCamarade> Yeah. Fun.
09:06:53 <jcreigh> trac is *like* a blog. :)
09:07:20 <jcreigh> most blogs, after all, just issue bug reports against the world at large.
09:07:29 <LeCamarade> @weed LeCamarade
09:07:29 <lambdabot> Maybe you meant: read seen
09:07:58 <LeCamarade> But that takes less that three edits! Or is it because of the second match?
09:08:13 <sorear> snd
09:08:21 <LeCamarade> @gongle Haskell
09:08:21 <dons> depends also on what edit operations you allow
09:08:24 <lambdabot> http://www.haskell.org/
09:08:24 <lambdabot> Title: Haskell - HaskellWiki
09:08:30 <LeCamarade> :oD
09:08:50 <sorear> @smash
09:08:51 <lambdabot> Unknown command, try @list
09:08:54 <LeCamarade> @spit dons
09:08:55 <lambdabot> Not enough privileges
09:09:01 <LeCamarade> :oD
09:09:05 <LeCamarade> @spit LeCamarade
09:09:06 <lambdabot> Not enough privileges
09:09:08 <wy> sorear: Have you heard of transactional memory work on Haskell?
09:09:12 <Heffalump> @spit LeCamarade
09:09:12 <lambdabot> Not enough privileges
09:09:17 <dons> wy, yeah, the STM module.
09:09:21 <jcreigh> spit -> quit?
09:09:25 <sorear> I think so.
09:09:27 <dmhouse> Is Network.BSD only available on Linux?
09:09:28 <Heffalump> bah, and I thought lambdabot liked me :-)
09:09:29 * LeCamarade thinks this should move to #haskell-blah and become a party.
09:09:33 <dons> Heffalump: yeah, dangerous..
09:09:34 <sorear> hence me not trying it :)
09:09:44 <Heffalump> oh, right.
09:10:06 <mauke> @shapr LeCamarade
09:10:07 <lambdabot> why on earth would I slap LeCamarade
09:10:09 <dons> ?docs Control.Concurrent.STM
09:10:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
09:10:16 <hpaste>  eumenides pasted "IO () computation timeout" at http://hpaste.org/1712
09:10:16 <wy> dons: Good! Thanks.
09:10:21 <Heffalump> oh, it's doing closest match?
09:10:24 <Heffalump> that's quite scary
09:10:36 <dons> wy, you'll want to read the STM paper probably, and check the (many) examples on haskell.org
09:10:45 <dons> Heffalump: yeah, when people try to abuse it. :-)
09:10:59 <eumenides> http://hpaste.org/1712 that works for stuff like loop = putStr "" >> loop, but not loop = loop in return loop. how could do the latter too?
09:11:18 <LeCamarade> Must be really intensive figuring out the distances and all. Isn't it? Who wrote the [module|code] responsible for the Leve*ein stuff?
09:11:31 <sorear> eumenides: let loop = loop in return loop terminates almost instantly!
09:11:36 <dons> its a pretty simple algo
09:11:52 <sorear> eumenides: it may return _|_, but it itself terminates
09:11:57 * dmhouse adds muchos Haddock comments to HaskellNet.POP3
09:11:57 <dons> given a string, and a dictionary, permute the string with up to 3 edit ops, check if they match something in the dictionary.
09:12:04 <wy> dons: I still can't make the HOpenGL examples work. I downloaded a game from http://www.cin.ufpe.br/~haskell/hopengl/examples.html, but it still uses the old API. Do you have any new examples?
09:12:06 <lambdabot> Title: HOpenGL Tutorial - Andre W B Furtado - 2002
09:12:20 <sorear> eumenides: were you expecting it to time out?
09:12:26 <dons> wy, hmm, there should be some demos in the OpenGL or GLUT library itself?
09:12:29 <eumenides> sorear: are you sure? because it doesn't seem to
09:12:29 <dmhouse> Anyway, is Network.BSD only available on Linux?
09:12:41 * LeCamarade breaks down under the strain of torture and confesses to having soied on #haskell for #ocaml. But is asking for pardon.
09:12:41 <dons> or the recently translated nehe tuts (google will find them)
09:12:48 <wy> dons: I found none in my distribution.
09:12:54 <LeCamarade> s/soied/spied/gi
09:12:55 <sorear> eumenides: it doesn't time out because it runs in microseconds!
09:13:26 <sorear> eumenides: the returned value takes forever to evaluate, but you're only timing out the action
09:13:29 <dons> LeCamarade: spied on us for them? did you find out our secrets and clues?
09:13:44 <sorear> eumenides: remember _|_ is perfectly legitimite value in haskell
09:13:45 <eumenides> sorear: ah. right
09:13:47 <dons> wy, maybe here, http://haskell.org/haskellwiki/Blog_articles#Graphics
09:13:48 <lambdabot> Title: Blog articles - HaskellWiki
09:14:28 <LeCamarade> dons: Find out? Man, I am selling out! :oD Actually, just the bot. And I have to ask you how you enabled modularisation. FFI? Runtime recompilation? Hmm?
09:14:54 <dons> modularisation of lambdabot?
09:15:22 <LeCamarade> dons: Yeah. The stuff you talk of in the Yi paper. (Most practical ... January '07).
09:15:27 <eumenides> sorear: how would i make pure stuff... timeoutable?
09:15:32 <dons> yeah, uses dynamic linking.
09:16:13 * LeCamarade wishes he knew at all how to get that done ... because the paper refers to it (as a lib), and no real explanation of how it was made to work.
09:16:25 <dons> hs-plugins, check the hs-plugins paper.
09:16:37 <dons> that's the 04 paper, iirc.
09:16:48 <LeCamarade> @where hs-plugins
09:16:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:16:56 <dons> at the bottom layer its an ffi binding onto the runtime linker
09:17:05 <dons> then just haskell for implementing the rest of the linking glue
09:17:35 <LeCamarade> By the way, I think I have the smallest Haskell program (by name and lines of code) that has the most utility.
09:17:44 <ehird`> LeCamarade: what?
09:17:48 <dons> main=interact id-- ?
09:17:51 <ehird`> also. which editors can yi emulate right now/
09:18:01 <LeCamarade> It's called comma. (Name is ,).
09:18:17 <drigz> sorear: when you directed me to Control.Monad.Instances, did you just know that was the place for the (->) monad? is there an easy way to find the definition of a given monad?
09:18:30 <dons> drigz: hmm. good question.
09:18:35 <LoganCapaldo> @src (->)
09:18:35 <lambdabot> Source not found. Do you think like you type?
09:18:37 <ehird`> LeCamarade: and it does
09:18:41 <LoganCapaldo> heeeey
09:18:42 <LeCamarade> It just does the thinking for me. I make a shell call like:
09:18:46 <LoganCapaldo> that so used to work
09:18:46 <LeCamarade> , http://www.cse.unsw.edu.au/~dons/hs-plugins/
09:18:47 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
09:18:48 <dons> drigz: no, we don't have a nice way to find where instances are defined
09:18:51 <LoganCapaldo> did I type it wrong?
09:18:54 <wy> How do I deal with literate programs in Haskell? How do I compile them?
09:18:58 <dons> @src Monad (->)
09:18:58 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:19:03 <ehird`> wy: just compile them with ghc
09:19:07 <LeCamarade> And it loads that page with $BROWSER or w3m. And many other things.
09:19:11 <dons> @src (>>=) (->)
09:19:11 <lambdabot> Source not found. Do you think like you type?
09:19:21 <dons> i can never remember class syntax for @src
09:19:22 <LoganCapaldo> @src (->) (>>=)
09:19:23 <lambdabot> f >>= k = \ r -> k (f r) r
09:19:27 <dons> ah there we go
09:19:33 <ehird`> Does ghc use its own C-- compiler?
09:20:21 <dons> ehird`: yeah.
09:20:24 <LeCamarade> It just takes a list of programs in its conf, and runs each of them for a potential replacement command. If any program in the list returns a string, that is the command to run. So, there is one for opening URLs.
09:20:32 <dons> it compiles Core to C--, and C-- to C / asm / bytecode
09:20:33 <drigz> dons: ok, thanks. do you know where the list monad is defined?
09:20:41 <ehird`> LeCamarade: sounds like os x open(1)
09:20:42 <dons> some bits of the runtime are implemented in C-- too
09:20:53 <dons> drigz: in GHC.Base, iirc
09:20:56 <dmhouse> drigz: best bet in GHC.List
09:20:59 <ehird`> dons: is it seperated from ghc?
09:21:01 <dons> or you mean, the List monad.
09:21:04 <ehird`> i.e. can it be used as a c-- compiler
09:21:24 <dons> ehird`: not really. its a subset of C--, that can be parsed. but in general you can't just hand arbitrary C-- to ghc
09:21:35 <LeCamarade> ehird`: No. Better. Extensible in any language. And a short name. ,. And in Haskell. (The last is the best feature of any program.)
09:21:35 <dons> just the parts of C-- that ghc targets are supported
09:21:52 <ehird`> LeCamarade: alias ,="open"
09:22:10 <wy> ehird`: Thanks.
09:22:13 <drigz> dons: you're right, thanks
09:22:47 <LeCamarade> ehird`: open(1) of Mac OS X has extensibility? As in, can I set what program should do what when I type , give me all my new haskell  ?
09:22:49 <dmhouse> LeCamarade: like , in #emacs? :)
09:22:51 <wy> What's Addr?
09:23:02 <LeCamarade> dmhouse: I'm insulted, but yeah.
09:23:03 <LeCamarade> :oD
09:23:24 <ehird`> LeCamarade: it uses OS X's application bindings
09:24:23 <LeCamarade> ehird`: That's the problem. There is no app binding for aribitrary commands. I often type stuff like , ? Lichtenstein
09:24:33 <LeCamarade> That opens a Google search for `Lichtenstein'.
09:24:51 <LeCamarade> ?? goes to Wikipedia. ??? Goes to `I am feeling lucky'.
09:25:00 <ehird`> LeCamarade: alias ", ?"="open http://www.google.com/search?q="
09:25:01 <lambdabot> Title: Google
09:25:08 <wy> I got an example program with "import Addr" and the system can't find the module. Any ideas where does this come from?
09:25:21 <drigz> hoogle's Did you mean: thing screws up if you search for (>>)
09:25:47 <hpaste>  tcr pasted "withUpdatedContext, need some help wrt strict evaluation." at http://hpaste.org/1713
09:26:17 <Saizan> @hoogle >>
09:26:20 <mcnster> wy, Addr would be "Addr.hs" in the current directory (or search path of ghc)
09:26:21 <lambdabot> Prelude.(>>) :: Monad m => m a -> m b -> m b
09:26:21 <lambdabot> Prelude.(>>=) :: Monad m => m a -> (a -> m b) -> m b
09:26:21 <lambdabot> Control.Arrow.(>>>) :: Arrow a => a b c -> a c d -> a b d
09:26:37 <LeCamarade> ehird`: Yeah, only ... I may want to keep it from Googling before going through my PDFs ...
09:26:52 <drigz> @hoogle (>>)
09:26:53 <lambdabot> Did you mean: (>>)
09:26:54 <lambdabot> Prelude.undefined :: a
09:26:54 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:27:00 * LeCamarade has many unread PDF papers. Including all the Functional Peals. :o(
09:27:35 <ehird`> LeCamarade: So basically you're implementing a "do this" program.
09:27:41 <ehird`> Guess what? It's called a shell.
09:27:55 <tcr> I'd like to receive some help with my paste, if you've got some time.
09:28:03 <wy> mcnster: It's supposed to be a standalone program. It's from http://www.dcs.gla.ac.uk/~sof/hello.lhs
09:28:46 <LeCamarade> ehird`: Yeah, but with a small name, and with easy re-programmability. I first failed to tweak ash(1), because it wasn't in Haskell. So, this is a shell that is more-extensible than a usual shell. And it passes QuickCheck.
09:29:09 <LeCamarade> A shell with events, so to speak.
09:29:15 <ehird`> LeCamarade: Shells have events.
09:29:32 <ehird`> zsh is more extensable than your program, almost by defintion
09:29:50 <mcnster> wy, try commenting it out and see what happens
09:29:53 <ehird`> And small name...? Your shell is open all the tinme
09:30:08 * LeCamarade can't justify a program that doesn't expose events -- that can be reprogrammed in Haskell, for example. Oh! Goes off to apt-get install zsh --yes --force-yes
09:30:28 <ehird`> zsh-devel.
09:30:34 <ehird`> And make sure to run the new user tutorial to configure it.
09:30:46 <ehird`> It's almost more complete (bloated) than emacs, but i like it
09:30:57 <wy> mcnster: many errors
09:31:01 <LeCamarade> ehird`: You mean I will not be able to extend it with a shell script? Only C?
09:31:13 <ehird`> LeCamarade: when the hell did i say that
09:31:23 <dons> ehird`: please be polite here.
09:31:34 <LeCamarade> zsh-devel connotes .so files ...
09:31:41 <mcnster> wy, sorry, you'll need to find Addr.hs then
09:31:48 <dons> LeCamarade: its a cute idea, a light haskell layer in front of the shell, so you can extend it in Haskell directly.
09:31:59 <ehird`> LeCamarade: So?
09:31:59 <Saizan> tcr: evaledResult <- result >>= \r -> return $! r is a typechecking version of what you have there
09:32:12 <wy> mcnster: OK. Let me just ignore this program and work on...
09:32:36 <LeCamarade> dons: Yeah, with a /usr/bin/runghc script. I script in Haskell. Even though I am an #ocaml spy. ;oD
09:32:55 <dons> LeCamarade: .so files would be fine (if i'm following), and if ehird` is actually suggesting extending zsh with haskell code. though not nearly as light as a thin layer in front of the shell
09:33:12 <LeCamarade> ehird`: Will I need to write C to extend it? Because I have really had enough of for(;;).
09:33:16 <dons> LeCamarade: that's fine. its not #ocaml we're worried about ;-)
09:33:20 <tcr> Saizan: Just to make sure I parse that correctly, does the >>= have a higher fixity than <-?
09:33:40 <dons> LeCamarade: you'd be able to extend it in haskell, but you'd need to work out the glue layer from zsh C to Haskell
09:33:46 <dons> :)
09:33:58 <Saizan> tcr: yes, "<-" is just syntactic sugar
09:34:21 <dons> @undo do x <- getChar ; return (toUpper x)
09:34:22 <lambdabot> getChar >>= \ x -> return (toUpper x)
09:34:39 <dons> tcr: ^^ that's the translation of the do/<- syntax
09:34:43 <LeCamarade> , hpaste.org/new
09:35:01 <tcr> dons: Yeah I know that, actually. :) Thanks anyway.
09:35:06 <LeCamarade> Sorry, wrong place. :o( But it shows youmy proggie! :oDDDD
09:35:22 <ehird`> LeCamarade: You can extend it with shell scripts.
09:35:35 <ehird`> The zsh scripting language has been used to write an irc client, a web server...with no external commands
09:35:38 <ehird`> i think that says it all
09:36:02 <LeCamarade> ehird`: It sure does. It certainly does.
09:36:07 <ehird`> dons: nah - i'm just replying to his "much more extendable than the average shell"
09:36:16 <Saizan> we want a shell scriptable in haskell, that's it.
09:36:28 <tcr> Saizan: Now, is what I'm trying to do ok? (From a meta perspective)
09:36:38 * LeCamarade is done apt-getting. Goes off to read stuff.
09:37:33 <ehird`> LeCamarade: some zsh trivia: "Attesting to the sheer size of this shell is the now famous[citation needed] first sentence of the shell's manual page, which reads "Because zsh contains many features, the zsh manual has been split into a number of sections", and then goes on to list thirteen items."
09:37:44 <ehird`> it also autocompletes ssh hosts and command-line options and the like
09:38:20 <LeCamarade> ehird`: =^O
09:38:47 <ehird`> and has an option parser built in as a a command
09:39:48 <LeCamarade> ehird`: First thing I ran was a command and three tabs. And it is already better than bash at completing stuff. Doesn't keep spilling on the screen. Schweet.
09:40:15 <Saizan> tcr: i'm not sure how much strictness that $! adds, i think it still depends on the strictness of your parrticular >>=
09:41:04 <ehird`> LeCamarade: Have you run the new user command?
09:41:43 <ehird`> If not, run:
09:41:44 <ehird`> autoload -Uz zsh-newuser-install; zsh-newuser-install -f
09:41:52 <ehird`> and go through the various steps. it only takes 5 or so minutes
09:41:55 <LeCamarade> ehird`: I'm having fun as it is. Lots. apt-get remove bash --yes --force-yes
09:41:57 <LeCamarade> :oD
09:42:16 <ehird`> (that command has 10 sections, and each subsection has about 5 subsubsections :P)
09:42:53 <Saizan> tcr: if m >>= f is strict in m than $! imposes it to reduce r to its outer layer before continuing on the next action
09:43:25 <Heffalump> if function f returns some function that I think is quite expensive to apply, and g is the one to actually apply the function, profiling will attribute the cost to g, right?
09:45:36 <tcr> Saizan: My >>= is defined as is typically for a state monad; I'd think it's strict in m therefore.
09:46:27 <Saizan> yes
09:48:13 <tcr> I wonder how withFoo style things are typically done in Haskell? Is there something like Lisp's unwind-protect? (I read about bracket in the IO module, but it seems to be tied to IO?)
09:48:46 <dons> yeah, bracket is used.
09:49:05 <dons> withFile name mode = bracket (openFile name mode) hClose
09:49:40 <dons> or say,
09:49:42 <dons> withServerX :: X () -> X ()
09:49:42 <dons> withServerX f = withDisplay $ \dpy -> do
09:49:42 <dons>     io $ grabServer dpy
09:49:42 <dons>     f
09:49:44 <dons>     io $ ungrabServer dpy
09:49:48 <ehird`> ...
09:49:50 <ehird`> whew
09:49:59 <dons> just higher order functoins and laziness.
09:50:28 <tcr> In my case I'm not doing any IO, though.
09:50:43 <dons> ok. so what are you protecting against? :-)
09:50:58 <sorear> drigz: I just knew.
09:51:06 <int-e> > fix (((1 :: Rational):) . (>>= \n -> [(n+1), 1/(n+1)]))
09:51:09 <tcr> transfer of control?
09:51:09 <lambdabot>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
09:51:31 <dons> you can't catch exceptions in pure code. and pure code shouldn't really be throwing anything but bottom
09:51:44 <dons> so there's no scary transfer of control that's not in IO anyway
09:51:53 <dons> that's cute, int-e
09:52:22 <tcr> Ah, ok.
09:52:25 <Cheery> How many of you need to do something else for a while to keep good programming pace?
09:52:53 <dons> tcr: its the side effects in lisp that mean you have to expect trouble^h^h^h effects at any time
09:53:29 * thedatabase wakes up, sees a load of functional pearls, picks Scrap your Nameplate, feels faint
09:53:43 <dons> that's a hard one. i'd go for the old school early days ones.
09:53:55 <dons> then work your way towards modern techniques
09:54:01 <dons> maybe we should reorder them by date.
09:54:16 <thedatabase> i thought they already were?  (reverse order)
09:54:29 <Saizan> tcr: btw, if your only concern is to return an evaledResult computed inside the updated context, you don't need extra strictness, the referential transparency is enough :)
09:55:02 <dons> thedatabase: yeah, just that people will probably pick from the top of the list
09:55:06 <dons> but the easier ones are at the bottom
09:55:11 <tcr> Saizan: Well, yeah I pondered if I need that at all... So why don't I after all?
09:55:26 <dons> thedatabase: but yes, as you see, we have a list now :-)
09:55:30 <thedatabase> dons: :-) yes, i thought there's nothing like diving straight in --- ouch!
09:56:03 <thedatabase> dons: absolutely!  :)
09:56:26 <Cheery> dons: now I'm doing the 'something else' pretty much randomly
09:56:27 <gravity> dons: Thanks for the reply on reddit. I was thinking about trying the lazy event list option too, so I'm glad to know I wasn't totally off-base with the idea
09:56:32 <therp> so when can I replace ion with xmonad? :)
09:57:11 <dons> gravity: yeah, works fine for a few apps I've done. and you can have the events list generated by another thread sending events over a Chan
09:57:25 <dons> then just toList the Chan, to get the contents lazily as they appear
09:57:27 <gravity> Cool
09:57:32 <tcr> Saizan: Is it because the implit >>, which is based on >>= and which, in turn, is strict in its first argument?
09:57:33 <dons> therp: now?
09:57:36 <Saizan> tcr: because evaledResult can only see the state that is passed to result by chaining it with the other actions, every "snapshot" of the state is a pure immutable vlaue
09:58:16 <tcr> Saizan: Right.
09:58:33 <Cheery> I think whether I could get more code or get betterly directed code if I'd start coordinating slightly and become less work-oriented
09:58:36 <tcr> Saizan: It's just me having been paranoid, heh. Thanks!
09:58:52 <dons> gravity: of course, I always forget that not everywhere recursion is a goto
09:59:12 <dons> then i just smack my forehead and say "oh, right... yes." :-)
09:59:16 <Cheery> ie. whether I could get better programmer now by slackering occassionally
09:59:24 <Saizan> tcr: explaining this actually made it clearer for me too :)
09:59:43 <gravity> hehehe
10:02:24 <Cheery> I've tried to not hurry, but there's a problem in this strategy - it is darned hard to not hurry
10:02:54 <Cheery> in other hand, it'd be the most efficient state for getting things done like I want them to be done
10:05:25 <Heffalump> hi ndm
10:05:26 <Cheery> what is the key in not hurrying (and fucking it all upwhile trying to 'do it to tomorrow'), but still not getting bored of not having a pace?
10:05:43 <ndm> hi Heffalump
10:05:44 <Heffalump> be a really good programmer :-)
10:06:18 <Cheery> with haskell I've gotten really good pace, but I want always more. It simply does not work
10:07:17 * DRMacIver is started to come around to the "Do it badly, fix it later" point of view. :)
10:07:36 <Heffalump> and yeah, that too
10:07:40 <DRMacIver> The problem is that you need the self discipline, circumstances and tool support to be there that you actually *will* fix it later.
10:07:43 <Heffalump> I try to focus on getting stuff working.
10:07:44 * ndm is debating between reading TAPL, writing Hoogle 4, writing a super-optimiser and sleeping
10:07:52 <dons> Cheery: hmm. I pace somewhat now.
10:08:00 <dons> whereas I used to just hack till I collapsed.
10:08:13 <sorear> hello
10:08:18 <dons> now I put problems aside for a day or two, and have some spare cycles to do the upfront design
10:08:19 <tcr> I wonder how it's possible to update a field of record dynamically? In record { foo = bar }, foo may not be a variable, afaics.
10:08:24 <Heffalump> having a job makes hacking until you collapse tricky
10:08:37 <Heffalump> tcr: correct. You can make a function that does the update, instead.
10:08:39 <DRMacIver> e.g. I know damn well that if I adopted that strategy at work then it would never get fixed.
10:08:45 <ndm> hacking til you collapse often gets a lot of stuff done, but rarely stuff that is later useful
10:09:27 <Philippa> ndm: read TAPL in bed?
10:09:41 <ndm> Philippa: thats what i'm currently thinking...
10:09:48 <Cheery> I know it'd increase my global pace if I wouldn't try do things too fast
10:09:51 <Philippa> my late night/early morning code often does turn out to be viable, but I'm probably a bit of a special case there
10:09:52 <tcr> Heffalump: This is stupid, because this way I'd have to both pass the query function and the update function. :/
10:10:13 <Cheery> but I somehow just can't turn it uside down like that
10:10:15 <Philippa> amongst other things, I'm pretty picky about writing shit coding
10:10:16 <dons> updateFoo s r = s { foo = r }, yeah?
10:10:30 <ndm> Philippa: my code tends to be used, but not as good as if i'd written it by hand
10:10:34 <sorear> {-! Set !-}
10:10:40 <ndm> or rather while still concious
10:10:54 <Cheery> I tend to just write code, then improve it gradually to the direction I need it
10:10:58 <DRMacIver> Even my hacky code isn't exactly 'shit'. It tends to need organising and commenting more than anything else.
10:10:59 <Philippa> by the time I'm yawning uncontrollably I tend to've stopped
10:11:15 <Philippa> *nod* - a willingness to refactor often helps
10:11:15 <tcr> dons: I decided that in my withUpdatedContext foo I don't want to save the whole context, but just the field that I'm going to update.
10:11:19 <DRMacIver> It by and large works in the cases I need it to work. :)
10:11:38 <dons> wow,"This page has been accessed 1,008 times"(functional pearls page, created about 9 hrs ago.
10:11:58 <ndm> dons: i've checked it out a few times already
10:12:03 <Philippa> and yeah, my code can usually use a refactoring sometime I've not been up all night - but usually it's nothing too nasty
10:12:13 <Cheery> but I've noticed that less I hurry, more often my code will be already what I want, and I need to refine it less
10:12:25 <dons> ndm, yeah, about 5-10 hits a minute currently. nice.
10:12:31 <tcr> dons: So I don't know the foo upfront (actually it is known at compile time, so a macro would be a perfect fit.)
10:12:34 <DRMacIver> Hm. I guess the distinguishing feature of what I consider my good code and my bad code is whether anyone except me is likely to be able to maintain it.
10:12:35 <ndm> dons: has it hit reddit or anywhere?
10:12:41 <dons> yeah, on reddit.
10:12:42 <Philippa> *nod* - hurry encourages you to just do it now and factor later
10:12:53 <Cheery> I just realised
10:12:55 <Philippa> heh, yeah. I can generally handle my own code several years later now...
10:12:56 <dons> tcr, so a switch that branches to the right update function?
10:13:04 <Philippa> but I should run it past others more often
10:13:07 <ndm> dons: shame, otherwise we'd have a reader count of haskell-cafe
10:13:15 <DRMacIver> Speaking of which, are there any good refactoring tools for Haskell?
10:13:16 <Cheery> I could try increase the speed to produce code yet a bit further! :)
10:13:26 <Heffalump> tcr: yeah. Haskell records aren't particularly good.
10:13:44 <tcr> dons: So the next time I add something to the Context datatype, I'd also have to add a line to that function, too?
10:13:45 <Cheery> I currently rely completely on the features in haskell
10:13:46 <Heffalump> trying to make them better isn't easy because the type system issues aren't trivial to deal with
10:13:58 <Cheery> I use gvim and ghci
10:14:02 <DRMacIver> I saw a refactoring tool for Java recently which made me go "Wow, that could work even better with a functional language" and I was wondering if something like that actually existed. :)
10:14:05 <tcr> dons: (Besides, are functions comparable?)
10:14:07 <Heffalump> DRMacIver: the only one I know of is HaRe, and I've never used it
10:14:16 <DRMacIver> (It was basically a pattern matching and transformation language for typed abstract syntax trees)
10:14:22 <ndm> DRMacIver: the hard bit is user interface, not transformations
10:14:24 <Heffalump> it's a project at the University of Kent
10:14:25 <dons> ndm, there's 1900 subscribers to haskell-cafe@
10:14:32 <Heffalump> DRMacIver: what tool, OOI?
10:14:41 <DRMacIver> Heffalump: It's called Jackpot. It's a Netbeans plugin.
10:14:47 <Heffalump> ah, the Sun one
10:14:54 <dons> and 1700 on haskell@
10:15:08 <ndm> hmm, so who subscribes to cafe, but not haskell?
10:15:14 <dons> beginners
10:15:28 <tcr> Cheery: The secret to getting things done even if you don't feel particularly like working on some project, is to save the low hanging fruits for these days.
10:15:38 <Heffalump> the lists are badly named, we should have haskell-announce and haskell
10:15:44 <Heffalump> that'd stop people chatting on haskell@
10:15:48 <dons> yeah
10:15:52 <Heffalump> or rather the list that is supposed to be the announce list.
10:15:52 <ndm> indeed, often users email haskell since thats obvious
10:16:04 <Heffalump> is renaming them out of the question?
10:16:13 <DRMacIver> Actually I'm having trouble getting much home time hacking done these days. Lack of motivation.
10:16:15 <kc5tja> Is this for mailing lists?
10:16:24 <Cheery> tcr: sounds a bit trick to master, how do you do it?
10:16:38 * Heffalump is getting quite a bit done at the moment. Partly due to having two 40 minute train journeys a day.
10:16:52 <ndm> Heffalump: work hacking, or play hacking?
10:16:56 <Heffalump> play hacking
10:17:02 <ndm> yay! on what?
10:17:10 <Heffalump> I don't have access to work stuff on the train
10:17:19 <ndm> (yay since i suspect your work hacking will remain private for years to come)
10:17:36 <dons> Heffalump: no access, due to security? (i.e. can't take work home?)
10:17:50 <Heffalump> dons: I can get remote access at home, but have no connectivity on the train.
10:17:56 <Heffalump> and since it's my laptop it doesn't have work stuff on it
10:18:04 <dons> ah right.
10:18:26 <tcr> Cheers: For example, do different things that are programming related, but not hardcore hacking... like updating the documentation, or updating the test suite, or doing some kind of lame refactoring that mostly needs manual repetition.
10:18:33 <Heffalump> ndm: Two main projects atm - One is analysing GPS traces, and the other is a reconciliation system for personal accounts that pulls in info from online bank statements.
10:18:36 <dons> ok. bed. night all.
10:19:00 <Cheery> assuming one writes mostly haskell, what kind of easy improvements into toolset would increase the speed I get code written?
10:19:15 <Cheery> mostly I'd like to lower the amount of typing I need to do
10:19:21 <Heffalump> though the latter is partly written in perl, for a mixture of historic reasons and the fact that I thought the ad-hoc parsing would be less hassle
10:19:55 <ndm> Heffalump: perl, yuk!
10:20:00 <dons> Cheery: ah good question, just before I disappear. learn identifier completion in your editor, install the ghc library source and read that when you need to find a function. use the typeOf type insertion script, use hasktags :-)
10:20:13 <Heffalump> it's not so bad. I even have a binding to call it from Haskell :-)
10:20:15 * dons `throwTo` sleepThread
10:20:20 <Philippa> identifier completion and a "gimme a case per constructor for the relevant type" would probably do the most to save you typing
10:20:22 <Heffalump> though it's a bit broken, it segfaults when it runs for too long
10:20:25 <ndm> GPS traces, i have a friend who does that
10:20:33 <Heffalump> in Haskell?
10:20:37 <ndm> a cyclist, who analyses them
10:20:47 <ndm> no, with an online site - he uploads, they graph it
10:20:52 <Heffalump> most of my code so far is just to pull in the traces from the PDB files they are in
10:21:01 <ndm> i think his are in XML format files
10:21:25 <ndm> of course, the bank reconciliation stuff isn't that interesting to students, since we have no money to reconcile...
10:21:27 <Heffalump> I'm mostly concentrating on the accounting stuff cos I want to use it to figure out my tax for last year.
10:21:30 <Heffalump> :-)
10:21:46 <ndm> that and my mum is a Sage tutor, so she takes care of that stuff
10:21:59 <Heffalump> my first plan for the GPS stuff is to have it guess when my train will arrive.
10:22:07 <ndm> how?
10:22:17 <ndm> based on previous days, or using other info?
10:22:20 <Heffalump> based on previous days
10:22:29 <Heffalump> I trace every journey I make.
10:23:00 <ndm> how hard can it be to do that calculation manually?
10:23:01 <thetallguy> Be interesting to graph the velocities over time
10:23:10 <ndm> i would have thought it was easy to guess by hand
10:23:13 <Heffalump> not all that hard, but much less fun :-)
10:23:18 <Heffalump> thetallguy: right
10:23:22 <ndm> fair enough :)
10:23:40 <Heffalump> if national timetable data was freely available, it'd be really cool
10:23:47 <ndm> isn't it?
10:23:52 <ndm> can't you screen scrape?
10:23:57 <Heffalump> You could just turn on your GPS when on a train, and it'd tell you what service you were on.
10:24:00 <Heffalump> in bulk, I mean
10:24:16 <ndm> i have a program that bulk screen scrapes the national rail website...
10:24:39 <Heffalump> presumably only a subset of the entire national UK rail timetable, though :-)
10:24:42 <ndm> i am even the author of a Mac train timetable widget, that i am informed makes over 100,000 scrapes a day :)
10:25:05 <Heffalump> who informed you of that?
10:25:08 <ndm> (despite never having actually used a mac, or seen my creation running)
10:25:14 <ndm> i wrote it for some guy
10:25:17 <ndm> he informed me
10:25:30 <Heffalump> do the national rail site admins not care?
10:25:41 <ndm> he got over 1000 emails in the day between the national rail site changing, and me producing an update
10:25:43 <ndm> seem not to
10:25:50 <ndm> if they even realise
10:26:22 <ndm> they updated their site once, but it would be easy for them to deliberately break the scrape, but no such action so far
10:26:36 <Heffalump> interesting
10:26:48 <Heffalump> I have some code to scrape the live departure boards, but that's years old so probably broken now
10:26:52 <Heffalump> is your scraping code Haskell?
10:26:56 <tcr> Let's say you want to have a function withUpdatedFoo that works within a state monad, where Foo is a record data type. Within the extent of withUpdatedFoo, a field of Foo should be temporarily set to an argument of withUpdateFoo. and between the setting and resetting another thing should be computed inside the state monad. How do you that?
10:26:57 <ndm> nope, javascript
10:27:18 <ndm> but tagsoup is based on a (proprietory) javascript library i wrote which does the basics of it
10:27:28 <Heffalump> tcr: just use get and put
10:27:56 <Heffalump> is Foo the state type of the state monad?
10:28:14 <tcr> Heffalump: Foo is the record type, FooM the state monad.
10:28:26 <tcr> Heffalump: http://hpaste.org/1713
10:28:27 <ndm> (of course, closed source javascript where you distribute the source with every client isn't very closed source)
10:28:29 <Heffalump> ah, FooM isn't Control.Monad.State?
10:28:52 <Heffalump> tcr: why do you think you need a strict >>= ?
10:28:55 <tcr> Heffalump: (This is what I have, I know just want to save the record field that I update, not the whole context)
10:29:02 <tcr> Heffalump: Ah that got fixed already
10:29:08 <sorear> I think the main question is the contents of the paragraph after the copyright notice.
10:29:58 <wy> I noticed that most people doing functional programming has moved out of the large universities of the US. Why?
10:30:18 <Heffalump> wy: like whom?
10:30:58 <wy> Heffalump: Like some professors in Yale... And it seems Java has occupied most of my professors attention.
10:31:05 <tcr> Heffalump: So no another way than doing the thing essentially manually every time?
10:31:44 <tcr> vy: I don't think they're a lot of professors who particularly like Java.
10:31:56 <Heffalump> tcr: I don't follow what you mean by manually.
10:32:44 <ndm> wy: isn't Paul Hudak still at Yale?
10:33:02 <hpaste>  DukeDave pasted "A monad opportunity " at http://hpaste.org/1715
10:33:07 <wy> ndm: It seems he is still at Yale.
10:33:10 <DukeDave2> Hey guys,
10:33:10 <tcr> Heffalump: do oldthingie <- queryContext thingie; updateContext updateNewthingie; result <- foo; updatecontext restoreOldthingie; return result
10:33:24 <DukeDave2> Would love it if someone could take a look at the question I've posted
10:33:32 <ndm> DukeDave2: which question?
10:33:47 <DukeDave2> I just hPaste'd it :)
10:34:12 <DukeDave2> Started typing it down in IRC client but it got a little unmanagable ;)
10:34:14 <Heffalump> tcr: why can't you abstract most of that?
10:34:28 <Heffalump> you should be left just with a pair of the record query and updater functions
10:34:28 <tcr> Heffalump: Uh well that is what I'm asking.
10:34:29 <ndm> DukeDave2: i'm not sure what the question is? you can just use hte maybe monad with no extra work
10:34:44 <wy> ndm: He is very old, isn't he?
10:34:54 <Heffalump> tcr: well, it should be possible.
10:35:03 <DukeDave> ndm, I just can't see how to express it  :|
10:35:16 <ndm> DukeDave: what do you want to expess
10:35:17 <tcr> Heffalump: the updateContext restoreOldThingie is the problem.
10:35:30 <ndm> wy: depends on you definition of old, i have no idea how old he is, but don't think he's that old
10:35:52 <DukeDave> the linesIntersection function, as a combination of planesIntersection & pointOnLine
10:35:56 <Heffalump> tcr: what does restoreOldThingie do?
10:36:22 <tcr> Heffalump: \c -> c { thingie = oldthingie }
10:36:39 <Heffalump> tcr: right, that's the updater function you'll need to abstract.
10:36:55 <Heffalump> well, you'll need to make oldthingie a parameter to it too
10:37:00 <tcr> Heffalump: No updateNewthingie is the updater function I'd like to abstract.
10:37:48 <tcr> Heffalump: Wait, I'll annotate to let you see what I want.
10:38:08 <wy> ndm: So there is just one person there.
10:38:22 <ndm> wy: i don't know, i just wasn't aware of anyone flocking out of the US
10:40:13 <Heffalump> I don't think Yale is that active any more.
10:40:15 <ndm> @seen dcoutts
10:40:16 <lambdabot> dcoutts is in #haskell, #haskell-overflow, #ghc and #gentoo-haskell. I last heard dcoutts speak 19h 5m 14s ago.
10:40:23 <Heffalump> But the Portland State people (who moved en-masse from OGI) are.
10:40:33 <wy> ndm: It seems they just went to some small unknown colleges. And professors in main universities just work on static checking for languages like C or exteding Java. That sounds not so good.
10:40:40 <Heffalump> and outside the Haskell world there's CMU, all the Scheme people, etc.
10:40:47 <hpaste>  tcr annotated "A monad opportunity " with "(no title)" at http://hpaste.org/1715#a1
10:40:52 <ndm> wy: everyone is more interested in C/Java, it just a shame...
10:41:01 <ehird`> ndm: haskell is  growing
10:41:22 <ndm> ehird`: i know, but growing from 0 to 1, compared to C which is closer to 10000000
10:41:28 <Heffalump> tcr: did you mean to annotate DukeDave's post?
10:41:30 <wy> ndm: I think even C# could be better.
10:41:42 <ndm> wy: i like C#, its a great language
10:41:52 <tcr> Heffalump: Ooops, silly me! Pardon!
10:41:55 <Heffalump> tcr: as I said, you can't abstract out the record field name directly. You have to do it by a function.
10:42:08 <Heffalump> So you should abstract out something of type (Foo -> a, Foo -> a -> Foo)
10:42:13 <wy> ndm: Do you think that's because Microsoft Research hired some Haskell people like Simon Peyton Jones?
10:42:13 <ehird`> ndm: not really
10:42:22 <ehird`> more like from 50 to 100, when c is 500,000
10:42:24 <Heffalump> where the first element is the query function and the second element is the update function
10:42:55 <DukeDave> Haha, that confused the hell out of me :)
10:43:11 <davidL> any projecteuler doers around?
10:43:20 <tcr> Heffalump: but I'd have to abstract out the field accessor (for queryContext), the updater for the newvalue (for the first updateContext), and the updater for restoring the old value (the second updateContext).
10:43:22 * DukeDave was thinking abstraction is getting ridiculous  ;)
10:43:32 <tcr> DukeDAve: heh, excuse me. :)
10:43:36 <Heffalump> tcr: no
10:43:47 <ndm> wy: no, i don't think he had anything to do with C# - although other FP programmers didi
10:43:53 <Heffalump> \c thingval -> c { thing = thingval }
10:43:59 <Heffalump> that's your updater function
10:44:08 <ndm> ehird`: to say Haskell is meremly 10,000 times less than C is wishful thinking
10:44:24 <Heffalump> actually you probably want to swap the arguments for your application
10:44:24 <ehird`> ndm: not really are you judging it based on how many people come into this channel
10:44:28 <ndm> ehird`: although, of course, i wish it was true!
10:44:29 <wy> Heffalump: I'm confused about the purpose of universities.
10:44:32 <ehird`> anyway, i said 100,000 times
10:44:42 <Heffalump> then your first use is updateContext (updater newthing)
10:44:51 <tcr> Heffalump: Well, yeah, that would still need three parameters.
10:44:52 <Heffalump> and your second use is updateContext (updater oldthing)
10:45:01 <ndm> ehird`: 500,000 / 50 = 10,000
10:45:12 <mauke> > 461 / 299
10:45:14 <lambdabot>  1.5418060200668897
10:45:38 <Heffalump> is Context your record type?
10:45:45 <Heffalump> tcr: no it wouldn't.
10:45:48 <tcr> Heffalump: Right
10:46:09 <Heffalump> and what's the field type?
10:46:17 <Heffalump> why is "update" a function from Context -> Context?
10:46:31 <ehird`> > let 500000 / 50 = 100000 in 500000 / 50
10:46:33 <lambdabot>  100000
10:46:37 <ehird`> qed
10:46:53 <tcr> Heffalump: So that I can update an arbitrary field: \c -> c { foo = newfoo }
10:47:28 <hpaste>  (anonymous) annotated "withUpdatedContext, need some help wrt strict evaluation." with "(no title)" at http://hpaste.org/1713#a1
10:47:38 <Heffalump> that was me. I added the type signature I think you should use.
10:47:58 * LoganCapaldo turns Haskell into perl, Data.Map String Dynamic
10:47:58 <Heffalump> can you write the body now?
10:48:15 <ehird`> LoganCapaldo: tell the hugs people they've been beaten to it
10:48:17 <tcr> Heffalump: what is field supposed to be?
10:48:22 <Heffalump> the type of a field
10:48:25 <Heffalump> it's a type variable
10:48:27 <LoganCapaldo> I mean Data.Map String (STRef Dynamic)
10:48:38 <ndm> ehird`: thats just proof that haskell doesn't have to be defined by the laws of maths
10:48:44 <tcr> Heffalump: The fields have different types.
10:48:52 <Heffalump> tcr: that's why it's a type *variable* :-)
10:48:57 <LoganCapaldo> ehird`: I think you mean pugs
10:48:59 <Heffalump> note the lower-case initial letter
10:49:00 <ehird`> ndm: :)
10:49:38 <tcr> Heffalump: Heh. Alright, I'm only used to reading single letter type variables; you completely beat me with using a word.
10:49:53 <Heffalump> sorry, I was trying to make it clearer :-)
10:49:55 <LoganCapaldo> @docs Data.Map.Trie ?
10:49:56 <lambdabot> Data.Map.Trie ? not available
10:50:00 <ehird`> tcr: *g*
10:50:46 <Heffalump> anyway, my point is that my first tuple is a surrogate for having first-class field names.
10:51:22 <tcr> Heffalump: what's the purpose of (field -> field) ?
10:51:40 <Heffalump> tcr: that's the function that actually gives you a modified field value
10:51:54 <Heffalump> you might just want a field, rather than a field -> field, if you don't need to make it depend on the old one
10:53:36 <tcr> Heffalump: Very nice idea with the surrogate! This way I can have a data type ContextField = Field1 | Field2 | ...; and a function that dispatches from that to the correct surrogate.
10:54:55 <Heffalump> if you want lots of syntactic overhead, sure
10:55:00 <Heffalump> Why not just pass around the tuple directly?
10:55:09 <Heffalump> make a type alias if you don't want it cluttering up your type
10:57:47 <tcr> Heffalump: I don't want to have to specify the tupel and the functions each time; however, I could use global variables instead of dispatching on a specific type.
10:58:14 <Heffalump> tcr: right
10:58:34 <tcr> Heffalump: Yeah like that even more. :) Thanks!
10:58:34 <Heffalump> just do it when you declare a datatype with fields.
11:01:33 <LoganCapaldo> global variables?
11:01:43 * LoganCapaldo runs screaming into the nearest wall
11:05:31 <therp> I need a database of good excuses. "No, I can't go out with you tonight, babe, because I have to go climbing tomorrow at 6am" -- "Despite the 13degree forecast?!" -- "Duh!.. Did I say climbing?"
11:06:23 <LoganCapaldo> You coudl just use lb's insult db.
11:06:37 <LoganCapaldo> "Come out with me tonight?" You: "you type like you drive!"
11:08:31 <therp> I'm not sure if this is going to work
11:23:09 <eumenides> is there some way to hide the loaded module names from the ghci prompt? it gets kinda crowded...
11:23:50 <sorear> does :set -v0 help?
11:23:50 <dmhouse> eumenides: make a module that imports and reexports those modules, then load that module.
11:24:00 <sorear> er, nm.
11:26:15 <eumenides> dmhouse: hmm indeed. i thought that wouldn't work, but it does.
11:26:57 <dmhouse> Actually, the modules need not even be reexported if you :load the module.
11:28:08 <eumenides> ah actually, it seems just putting :module ... in .ghci works as well
11:30:23 <tcr> Uhm, can't you create a type synonym for a type that contains type variables?
11:31:11 <dmhouse> tcr: sure you can, but the type synonyms need to have parameters.
11:31:19 <dmhouse> type Foo a = Maybe a -- this will work.
11:32:07 <Heffalump> LoganCapaldo: not global mutable variables
11:32:11 <Heffalump> just global values
11:32:26 <LoganCapaldo> Heffalump: sure sure. I was just fooling around :)
11:32:29 <tcr> dmhouse: Ah, right, of course.
11:40:08 <tcr> Heffalump: Re: the solution that you proposed with the type variable field; I think I'm getting some compilation error because a few of my fields are functions, and this is causing some kind error. Could that be?
11:46:33 <hpaste>  tcr annotated "withUpdatedContext, need some help wrt strict evaluation." with "(no title)" at http://hpaste.org/1713#a2
11:47:26 <tcr> Could anyone explain the error message to me, please?
11:51:51 <Cheery> @hoogle unsafePerformIO
11:51:52 <sorear> tcr: wait, your record has polymorphic functions for fields?
11:51:52 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
11:52:08 <Cheery> hmm, it wasn't this
11:52:08 <sorear> Cheery: it's also in System.IO.Unsafe
11:52:22 <Cheery> @hoogle unsafeInterleaveIO
11:52:23 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
11:52:29 <tcr> sorear: Yeah
11:52:44 <Cheery> ok, so this one
11:52:45 <DRMacIver> Hm. For some reason I find the type signature of unsafePerformIO really disturbing.
11:53:10 <ibid> tcr: i *think* the problem is that you want type inference to infer more than it can. the lambdas in the two lines in question require quantified-typed parameters
11:53:11 <eumenides> @type unsafeCoerce
11:53:14 <lambdabot> Not in scope: `unsafeCoerce'
11:53:40 <ddarius> :t unsafeCoerce#
11:53:42 <DRMacIver> eumenides: Yes, I know about that one. But that's not so much really disturbing as obviously wrong. :)
11:53:43 <lambdabot> Not in scope: `unsafeCoerce#'
11:53:45 <ibid> tcr: iirc you need to give explicit type signatures in that case
11:53:49 <sorear> @type GHC.Prim.unsafeCoerce#
11:53:52 <lambdabot> forall t b. t -> b
11:53:59 <ibid> tcr: but i could be wrong, i haven't looked at this before
11:54:14 <tcr> ibid: Well, I'm trying to generate the right type signature that I need.
11:54:16 <sorear> shouldn't that be forall (t :: ?) (b :: ?). t -> b  ?
11:54:20 <ibid> tcr: (correction) ... looked at this stuff recently
11:54:23 <ibid> tcr: hm?
11:54:50 <sorear> ibid: how's the story with Antonio's feed coming?
11:55:42 <tcr> ibid: I tried this one `convertFnQ :: (Convert a b) => ContextSurrogate (a -> ContextM b)', but it didn't work. Getting Expected type: a -> ContextM b, Inferred type: a1 -> ContextM b1
11:55:46 <ibid> sorear: huh?
11:56:10 <ibid> tcr: you need to give a type signature to the lambda, not convertFnQ
11:56:20 <ibid> tcr: in effect, you need to name that function
11:56:48 <tcr> ibid: I cannot annotate a lambda with a type?
11:57:22 <ibid> tcr: you can, though i don't know if that's enough
11:58:21 <tcr> ibid: Well I read in the report about difference between lambda abstraction and real function bindings, forgot the specifics... but you're talking about this difference?
11:59:47 <tcr> Nice I just produced a GHC internal error during compilation :)
12:00:48 <ibid> sorear: as i've explained before to some people, i'm currently cut off from access to the planet site, and expect to regain it in a couple of days (i'm waiting for a new laptop, so i can transfer the stuff in my old broken laptop's hard drive, including the ssh keys, there)
12:01:14 <ibid> tcr: i'm not sure if that difference matters
12:05:05 <Cheery> say, unsafeInterleaveIO ends up doing the things 'in need'..
12:05:14 <tcr> ibid: I still cannot get it working even when trying to moving out the lambdas to real functions. Could give a shot of how the relevant type would have to be for such a function?
12:05:48 <Cheery> I have a timer -action
12:06:10 <Cheery> Timer -> IO (Timer,timeDelta)
12:06:33 <Cheery> that's called 'capture'
12:07:43 <ibid> tcr: something like Context -> (forall a b. (Convert a b) => a -> ContextM b) -> Context (not sure about the syntax though; this for convertFnQ's lambda)
12:07:59 <Cheery> so then, if I'd do: (timer', dt) <- unsafeInterleaveIO timer ; stepSomething dt something
12:08:38 <Cheery> and inside stepSomething, the delta would be used for getting the new state of system
12:09:15 <Cheery> *unsafeInterleaveIO (capture timer)
12:10:43 <Cheery> would the 'capture' -action update the timer -structure after the stepSomething has computed with the current data and prepares for stepping forward?
12:12:56 <Cheery> hmm, maybe it's not a good idea
12:14:09 <Cheery> say, if dt would be ignored, and the timer loops into another this kind of thing, it'd eventually wipe out the whole timer -action
12:20:23 <tcr> ibid: While this annotation (with forall a b. ...)  seems to knock down that particular error message, it causes new errors with how I define my type class Convert.
12:21:17 <tcr> I wonder why having a type system so often implicates fighting the type system. :/
12:22:19 <Cheery> tcr: I don't know, this far I've never needed any of those unsafes
12:22:42 <ddarius> tcr: Well you certainly can't fight one without one.
12:22:45 <Cheery> I consider unsafeInterleaveIO useful thought
12:26:48 <Heffalump> tcr: having an expressive type system means you can do a lot with it. But you have to put some effort in to do that.
12:28:03 <tcr> Heffalump: Well, I don't think I'm trying to do a lot with it, but it makes it look as if I'm doing some awful lot.
12:29:20 <tcr> Heffalump: But nevermind, I'd appreciate your gracious help. :)
12:29:34 <Heffalump> what's the problem?
12:30:05 <tcr> Heffalump: http://hpaste.org/1713#a2
12:30:35 <DRMacIver> Could be worse. You could be trying to fight Java's type system. :)
12:30:52 * DRMacIver does that far too often
12:31:11 <ibid> tcr: the trouble is that once you go beyond basic HM, you can no longer ignore the type system
12:31:27 <ibid> tcr: and you need to learn what actually happens there
12:31:34 <ibid> tcr: it becomes less intuitive
12:31:40 <Heffalump> oh, right, you can't lambda-bind that value for the polymorphic field
12:32:04 <ddarius> tcr: The convertFn and barfFn are utilizing type system extensions.
12:32:11 <Heffalump> can't you just use a let?
12:32:14 * Heffalump is guessing a bit
12:32:54 <ddarius> let updateConvertFn c f = c { convertFn = f} in ... ?
12:32:56 <ibid> tcr: please post your latest code so Heffalump can see what you did with my annotation :)
12:33:01 <Heffalump> ddarius: right
12:33:18 <tcr> ddarius: Why does barfFn? convertFn uses (Convert a b) where as haskell98 does only allow one parameter in a type class.
12:33:50 <Heffalump> tcr: Haskell 98 doesn't allow you to have polymorphic fields anyway
12:33:55 <ibid> tcr: because you have an implicit forall there
12:34:21 <tcr> Oh, I didn't know that.
12:34:37 <ibid> tcr: notice how you have type variables on the right side that aren't parameters of the Context type
12:34:37 <Heffalump> IM polymorphic with the quantification where it is
12:34:40 <Heffalump> rather than at the top-level
12:35:02 <ibid> tcr: ... the right side of = in the data decl
12:35:25 <tcr> I have convertFn and barfFn in ContextM to have, essentially, dynamically scoped functions. I'm converting an AST of haskell to an AST of another language, and dynamically scoped functions would come handy there.
12:35:28 <ibid> i hate it that ghc allows one to do that without requiring explicit foralls
12:35:46 <Heffalump> ibid: yeah
12:36:15 <ibid> tcr isn't the first person i've personally seen bit by this
12:36:39 <ddarius> tcr: That's alright.  It's just that working with these rank-2 types is trickier.
12:36:44 <ibid> (though i *think* i never stumbled on it)
12:37:45 <tcr> ddarius: Are these "rank-2 types" gonna be introduced in the haskell prime?
12:38:00 <Heffalump> it looks likely
12:38:05 <ddarius> tcr: I haven't been following it.  Probably, higher-rank types in general will be.
12:38:28 <tcr> Ok, so I'll be able to afford using them.
12:38:59 <ddarius> tcr: But for higher rank types, type inference is no longer decidable soh you will need more type annotations to get things to type check.
12:39:20 <LoganCapaldo> Stupid decideability
12:39:29 <LoganCapaldo> Can't the typechecker flip a coin?
12:39:31 <LoganCapaldo> :)
12:39:38 <Heffalump> :-)
12:39:39 <LoganCapaldo> err type inferer
12:40:12 <ddarius> Whereas for Haskell 98's type system, you almost never need type annotations.
12:40:59 <tcr> Still, I'm completely lost on how to proceed.
12:43:42 <hpaste>  tcr annotated "withUpdatedContext, need some help wrt strict evaluation." with "a little more of my actual code" at http://hpaste.org/1713#a3
12:43:43 <ddarius> tcr: Try convertFnQ = let updateConvertFn c f = c { convertFn = f} in (convertFn,updateConvertFn)
12:44:15 <ddarius> Okay, what's the type error now?
12:46:07 <Cheery> hmm, the dailywtf -competition is interesting, after you evaluate it a bit
12:46:14 <Cheery> say, you usually try to code the best possible way you can think of
12:46:21 <Cheery> but what if you take the different part and code with the worst possible way you can think of?
12:46:27 <Cheery> since you haven't done that before, you suck at sucking
12:46:32 <Heffalump> tcr: have you tried the suggestion of using let instead of lambda?
12:47:20 <tcr> basically same error message
12:47:46 <Heffalump> can you show the code and error message?
12:48:03 <hpaste>  tcr annotated "withUpdatedContext, need some help wrt strict evaluation." with "new error message" at http://hpaste.org/1713#a4
12:48:06 <Cheery> I'm quite sure I lose that contest, but not sure about what is the end-result
12:48:44 <tcr> Heffalump: It's just the code I pasted, except for that I use ddarius' version of convertFnQ (and commented out the previous one)
12:49:17 <Heffalump> tcr: but there isn't an updateConvertFn in that code
12:49:21 <Heffalump> and the error message mentions it
12:50:29 <tcr> Heffalump: Yeah, as I said "except for that I use ddarius' version of convertFnQ (and commented out the previous one)"
12:51:34 <ddarius> Did you get the same error with your test? functions?
12:52:04 <Heffalump> I would like to see the code with a let/globally defined update function, and the error message that goes with it.
12:53:20 <tcr> Heffalump: What do you mean?
12:55:02 <balodja> how to reduce integer to bool?
12:55:06 <Heffalump> tcr: I just want to see code and the error message that goes with it, not some explanation of how they were changed.
12:55:10 <sorear> balodja: (==)
12:55:25 <balodja> amazing!
12:55:25 <sorear> > (/= 0) 3
12:55:27 <lambdabot>  True
12:55:36 <sorear> > 0 /= 3
12:55:37 <lambdabot>  True
12:55:39 <sorear> > 0 /= 0
12:55:41 <lambdabot>  False
12:55:58 <mauke> > toEnum 0 :: Bool
12:55:59 <lambdabot>  False
12:56:04 <mauke> > toEnum 2 :: Bool
12:56:06 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
12:57:12 <LoganCapaldo> > let trueInC  = (/= 0) in if trueInC 7 then () else () -- heh
12:57:14 <lambdabot>  ()
12:58:32 <hpaste>  tcr annotated "withUpdatedContext, need some help wrt strict evaluation." with "(no title)" at http://hpaste.org/1713#a5
12:58:50 <tcr> Heffalump: Alright.
12:59:07 <tcr> ddarius: I'l make an annotation with the result when using test1, test2.
12:59:50 <Heffalump> tcr: you need the test2 type signature to be uncommented
12:59:56 <Heffalump> and you need a signature for updateConvertFn too
13:00:42 <hpaste>  tcr annotated "withUpdatedContext, need some help wrt strict evaluation." with "(no title)" at http://hpaste.org/1713#a6
13:01:09 <ilyat> Prelude> (toEnum::Int->Bool) 1
13:01:09 <ilyat> True
13:01:09 <ilyat> Prelude> (toEnum::Int->Bool) 0
13:01:09 <ilyat> False
13:01:09 <ilyat> Prelude>
13:01:30 <tcr> Heffalump: In how far should that influence the first error message?
13:01:52 <ilyat> /who
13:01:52 <Heffalump> a lot.
13:02:00 * Heffalump is looking at your new one
13:03:54 * Heffalump --> try this himself
13:05:13 <tcr> Heffalump: If you got haskell-src-exts installed (Language.Haskell.Hsx), I could send you the whole thing.
13:05:28 <Heffalump> will that file compile on its own?
13:05:35 <Heffalump> apart from the type error, of course
13:05:49 <tcr> It's two files.
13:06:42 <tcr> I interactively load one of the files, and the other gets loaded automatically by the module system.
13:06:46 * Heffalump waits for his laptop to stop crawling
13:09:13 * Heffalump comments some stuff out and gets the type error
13:10:20 <tcr> Alright then
13:10:34 <tcr> Let the magic begin. :)
13:11:41 <Heffalump> what type does prettyShow' have?
13:12:34 <LoganCapaldo> I love ' in identifiers. Best language feature ever
13:12:42 <LoganCapaldo> well maybe not the best
13:12:59 <LoganCapaldo> best language feature implemented in the lexer, ever :)
13:13:18 <tcr> Heffalump: prettyShow' :: forall a. (Show a) => [Char] -> a -> String
13:17:57 <cdsmith> Wow, I just realized how many advertisements for Miranda IM they stuck in the program.  I think I got them all now.
13:18:10 <LoganCapaldo> @quote Miranda
13:18:10 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
13:18:34 <LoganCapaldo> I wanted the other one
13:18:38 <LoganCapaldo> @quote tm
13:18:39 <lambdabot> tm says: Miranda (tm) is a trademark of Research Software
13:18:53 <LoganCapaldo> @quote Miranda
13:18:54 <lambdabot> tm says: Miranda (tm) is a trademark of Research Software
13:18:59 <LoganCapaldo> ah I give up
13:19:07 <LoganCapaldo> one mor etime
13:19:09 <LoganCapaldo> @quote Miranda
13:19:10 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
13:19:24 <nominolo_> @quotes
13:19:24 <lambdabot> timthelion says: oh wait, I LOVE foldr!! and I have only been learning haskel for hours
13:24:00 <Heffalump> tcr: my head hurts.
13:24:12 <gmh33> it's supposed to
13:24:18 <Heffalump> I think all these higher-rank types of yours should be wrapped up in datatypes.
13:24:38 <Heffalump> gmh33: why?
13:24:42 <Saizan> foldr is wonderful, sometimes i fear that i need a left fold, but then i realize i can use foldr without any effort thanks to lazy eval
13:24:54 <Heffalump> left folds are bad, they always recurse to the end
13:25:38 <sphynx> LoganCapaldo, I've been confused by quotes in identifiers earlier :)
13:25:45 <tcr> Heffalump: Uh, am I using so many?
13:26:09 <sphynx> LoganCapaldo, When I was starting haskell studying I think that it is some special symbol denoting some magic :)
13:26:10 <Heffalump> no, but they're in difficult places
13:26:19 * Heffalump starts reworking them a bit
13:26:21 <Saizan> (i think ghc should give better error messages for rank-k gone bad)
13:27:08 <LoganCapaldo> Heffalump: na uh. foldM doesn't always reciurse to the end :)
13:27:28 <tcr> Heffalump: I'm open for suggestions.
13:27:29 <Saizan> ?src foldM
13:27:29 <lambdabot> foldM _ a []     = return a
13:27:30 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:27:31 <Heffalump> foldM is a right fold..
13:27:38 <LoganCapaldo> nope
13:27:54 <Heffalump> yes it is
13:27:58 <LoganCapaldo> can;t be
13:28:01 <nominolo_> > foldM (+) [1..5]
13:28:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
13:28:03 <lambdabot>       Expected...
13:28:05 <Saizan> it's a left fold
13:28:09 <LoganCapaldo> or else my code would not work :)
13:28:25 <Heffalump> oh, I see, sorry, yes, you're right.
13:28:36 <Heffalump> It's the monadic binding that stops it having to recurse to the end.
13:28:42 <Heffalump> it would in the identity monad.
13:28:53 <Heffalump> tcr: working on it.
13:29:02 <Saizan> from the source is clear that the result of the function is used as the accumulator for the recursive call
13:29:24 <Heffalump> Saizan: yes, I agree. I was just confused.
13:30:18 <tcr> Heffalump: I didn't know about higher-rank types alltogether; I just did what looked like the right thing. :) And everything actually worked until I tried to incorporate your surrogate idea.
13:30:43 <Heffalump> I hadn't realised you had higher-rank types until after that, I might have been a bit more careful if I had :-)
13:30:51 <Heffalump> s/careful/less likely to suggest them/
13:30:57 <Heffalump> but I think I know how to fix this
13:31:14 <LoganCapaldo> > foldM (liftM (+)) [1..5] [1..10]
13:31:15 <lambdabot>      Occurs check: cannot construct the infinite type: a1 = b -> a1
13:31:16 <lambdabot>     Proba...
13:31:20 <LoganCapaldo> mmm
13:31:25 <fridim> what is the wiki engine used at haskell.org ?
13:31:37 <Saizan> =type foldM
13:31:43 <Saizan> @type foldM
13:31:46 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:31:59 <LoganCapaldo> ooo
13:32:08 <LoganCapaldo> the initial acc isn't in the monad :(
13:32:09 <lispy> fridim: mediawiki
13:32:34 <fridim> I like the css
13:32:44 <Saizan> only the function is
13:33:23 <nominolo_> @pl \ x y -> return (x + y)
13:33:23 <lambdabot> (return .) . (+)
13:34:02 <Saizan> > foldM ((return .) . (+)) 1 [1..6] :: Maybe Int
13:34:04 <lambdabot>  Just 22
13:34:18 <LoganCapaldo> > do { x <- [1..5]; foldM ((return .) . (+)) x [1..10] }
13:34:19 <lambdabot>  [56,57,58,59,60]
13:34:23 <nominolo_> > foldM ((return .) . (-)) 10 [1..4]
13:34:24 <lambdabot>   add an instance declaration for (Show (m a))
13:34:30 <LoganCapaldo> that was the effect I was going for :)
13:34:36 <Saizan> > foldM ((return .) . (+)) 1 [1..6] :: [Int]
13:34:38 <lambdabot>  [22]
13:36:03 <Heffalump> tcr: ok, I've got it past the type checker
13:36:12 <nominolo_> > foldM ((return .) . (-)) 10 [1..4] :: Identity [Int]
13:36:13 <Heffalump> I'm not certain if there's a better way, but this was fairly simple
13:36:13 <lambdabot>        add an instance declaration for (Show (Identity [Int]))
13:36:23 <Heffalump> I just abstracted your polymorphic fields into data declarations
13:36:24 <nominolo_> > foldM ((return .) . (-)) 10 [1..4] :: Identity Int
13:36:25 <lambdabot>   add an instance declaration for (Show (Identity Int))
13:36:30 <Heffalump> and then went through adding the tagging/untagging code
13:36:47 <balodja> > map (/10) [-4..10]
13:36:48 <lambdabot>  [-0.4,-0.3,-0.2,-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
13:36:57 <balodja> is there more suitable way for that?
13:36:59 <tcr> Heffalump: Would mind making an annotation, and maybe marking each line you changed/added by some comment marker.
13:37:24 <cdsmith> balodja: no, that looks fine
13:37:34 <cdsmith> balodja: is there something you didn't like about it?
13:37:36 <Saizan> > [(-0.4),(-0.3)..1.0]
13:37:38 <lambdabot>  [-0.4,-0.3,-0.19999999999999996,-9.999999999999992e-2,1.1102230246251565e-16...
13:37:41 <hpaste>  Heffalump annotated "withUpdatedContext, need some help wrt strict evaluation." with "this passes the type checker" at http://hpaste.org/1713#a7
13:37:53 <Heffalump> I can't be bothered to mark the lines, use diff :-)
13:38:14 <balodja> cdsmith: i thought about something like [-0.4 .. 0.1 .. 1]
13:38:35 <TomMD> @quote glguy
13:38:35 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
13:38:41 <cdsmith> balodja: ah, then Saizan is right; except you'll run into rounding error as lambdabot just did
13:38:57 <balodja> ok, thanks
13:39:41 <Saizan> balodja: on Double division is less likely to produce rounding errors in general
13:39:47 <nominolo_> > [-1,-0.75..1]
13:39:47 <tcr> Heffalump: sure you uploaded the correct version? I just can't find any difference
13:39:48 <lambdabot>  [-1.0,-0.75,-0.5,-0.25,0.0,0.25,0.5,0.75,1.0]
13:40:13 <Botje_> > 2 ** 1024
13:40:14 <lambdabot>  Infinity
13:40:28 <nominolo_> @src (**)
13:40:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:40:33 <Botje_> looks fairly easy to recognize
13:41:07 <nominolo_> how much can 64 bit floating represent?
13:41:30 <cdsmith> Division isn't less likely to produce rounding error; the problem is that using the Enum method directly on Double accumulates rounding error by reusing intermediate results.
13:41:39 <lispy> Botje_: clever, but 2**1024 != 2^1024 :)
13:41:43 <ddarius> 53 bits of mantissa, 1 sign bit
13:41:51 <Saizan> 11 bit for the exponent
13:41:55 <lispy> > 2 ^ 1024
13:41:57 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
13:42:18 <Heffalump> oh, my cut-n-paste might have broken
13:42:29 <nominolo_> > 2 ** 1023
13:42:30 <lambdabot>  8.98846567431158e307
13:42:35 <LoganCapaldo> > let f xs  = do { x <- xs; return $ x / 10 } in f [-4..10]
13:42:36 <lambdabot>  [-0.4,-0.3,-0.2,-0.1,0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
13:42:45 <nominolo_> > 2 ** -1024
13:42:46 <lambdabot>      precedence parsing error
13:42:46 <lambdabot>         cannot mix `(**)' [infixr 8] and prefix...
13:42:52 <Heffalump> sorry, it did
13:42:54 <nominolo_> > 2 ** (-1024)
13:42:56 <lambdabot>  5.562684646268003e-309
13:43:02 <Saizan> cdsmith: subtraction between comparable operands gives a very large relative error
13:43:36 <sphynx> hmmm, could you please clear for me the difference between foldM  (return . (+))  1 [1..3] and foldM ((return .) . (+)) 1 [1..3]
13:43:38 <hpaste>  Heffalump annotated "withUpdatedContext, need some help wrt strict evaluation." with "the right version this time" at http://hpaste.org/1713#a8
13:43:48 <Heffalump> ok, I think that one's ok
13:44:11 <sphynx> I'm a bit confused about this ((f .) . g)
13:44:20 <nominolo_> :t return . (+)  -- sphynx
13:44:22 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m (a -> a)
13:44:46 <lispy> ?unpl ((f .) . g)
13:44:47 <lambdabot> (\ d i -> f (g d i))
13:44:58 <lispy> sphynx: ^^
13:45:15 <nominolo_> :t (+)
13:45:17 <lambdabot> forall a. (Num a) => a -> a -> a
13:45:22 <nominolo_> :t ((+) .)
13:45:24 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> b -> b
13:45:25 <Saizan> sphynx:  try to espand it using f . g = \x -> f (g x)  and you'll see :)
13:45:52 <sphynx> yeah, I'm tring to understand
13:45:56 <Heffalump> @pl \ f g a b c -> f (g a b c)
13:45:57 <lambdabot> (.) . (.) . (.)
13:46:14 <Heffalump> @pl \a b c -> f (g a b c)
13:46:15 <lambdabot> ((f .) .) . g
13:46:44 <lispy> ?unpl (.) . (.) . (.)
13:46:45 <lambdabot> (\ l b c f i -> l (b c f i))
13:47:02 <balodja> sphynx: keep in mind that (.) is a function too, that helped me to realize mistic @pl :)
13:47:05 <sphynx> @unpl (.) . (.)
13:47:05 <lambdabot> (\ i b c f -> i (b c f))
13:47:26 <kc5tja> ?unpl (((f .) .) . g) . (((f .) .) . g) . (((f .) .) . g)
13:47:26 <lambdabot> (\ k z ac -> f (g (\ af ai -> f (g (\ al ao -> f (g k al ao)) af ai)) z ac))
13:47:34 <cdsmith> @pl \f g a b c -> f (g a) (g b) (g c)
13:47:35 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
13:47:38 <lispy> (f . g) x = f (g x)
13:47:46 <cdsmith> That was ugly
13:49:13 <sphynx> hmm, so ((f .) . g ) is like applying g to args and then applying f
13:49:50 <sphynx> ?unpl ((f .) . g)
13:49:50 <lambdabot> (\ d i -> f (g d i))
13:49:57 <sphynx> ?unpl (f  . g)
13:49:57 <lambdabot> (\ c -> f (g c))
13:50:54 <sphynx> so ((f .) . g) expects two args, but (f .g) only one
13:51:22 <sphynx> ?unpl (((f .) .). g)
13:51:22 <lambdabot> (\ e j m -> f (g e j m))
13:51:41 <nominolo_> ?pl \f g x y -> f (g x) (g y)
13:51:41 <lambdabot> join . ((flip . ((.) .)) .) . (.)
13:52:09 <nominolo_> ?pl \g x y -> f (g x) (g y)
13:52:09 <lambdabot> flip =<< (((.) . f) .)
13:54:18 * lispy notices how this must look like line noise to non-haskellers
13:54:49 <nominolo_> it doesn't to haskellers?
13:55:19 <lispy> nominolo_: no it looks like some code i wrote a few hours agay ;)
13:55:22 <tcr> Heffalump: Wow, that's ugly. :) I wonder why it works this way, though.
13:55:26 <lispy> s/agay/ago
13:55:41 <Heffalump> tcr: the tagging and untagging operations give the type checker a bit more chance to figure out what's quantified where.
13:55:53 <Heffalump> At least, that's my intuition. I couldn't provide a proper explanation.
13:56:08 <Heffalump> And it's possible that your code could have been fixed without doing that. I just couldn't do it.
13:56:11 <nominolo_> lispy: i take it you do not intend this code to be maintainable? ;)
13:57:05 <lispy> nominolo_: why wouldn't it be maintainable? I wrote it in haskell :)
13:57:30 <ehird`> someone name a hacky oneliner prelude function
13:57:53 <lispy> ehird`: what do you mean by hacky?
13:57:56 <ddarius> A hacky one?
13:58:03 <nominolo_> lispy: well, if i were to maintain such code, i'd copy n pasted it to ?unpl lambdabot and replace it with the result
13:58:34 <ulfdoz> @hoogle (a -> a -> Bool) -> [a] -> Bool
13:58:34 <ddarius> And thus lambdabot's central role in Haskell development is revealed.
13:58:35 <lambdabot> No matches, try a more general search
13:58:47 <nominolo_> lispy: i mean, pipeline style code is ok.  but (x .) kind of code is just plain scary
13:58:53 <sphynx> today I was explaining folds to one imperative programmer and I use classic example, moving from recursive definition of sum and prod to folds. I use something like "sum [] = 0; sum list = head list + sum (tail list )"
13:59:02 <lispy> nominolo_: i've been teasing :)
13:59:34 <sphynx> then I've defined 'prod'  in such way too, but using 1 instead of zero and (*) instead of plus
13:59:54 <nominolo_> lispy: oh, well.  doesn't matter :)
14:00:38 <sphynx> then I've asked - what's common between these function? It seems that common is structure code, and difference is only in 0 and 1 and functions, so it was easy to him to understand folds after this :)
14:01:43 <sphynx> also I've noted that this is called "tail recursion" and this coincide good with (tail list) if these recursive definition, I've used at first
14:02:00 <Heffalump> how is it tail recursion?
14:02:02 <Saizan> it's not tail recursion
14:02:11 <sphynx> why not?
14:02:26 <Heffalump> because you need to do something with the result of the recursive call
14:02:29 <Heffalump> you can't just return it
14:02:32 <nominolo_> sphynx: because the recursive function is not the outermost call
14:02:38 <Heffalump> foldl is tail recursive, foldr isn't
14:02:40 <ddarius> sphynx: Tail recursion is what you get when the last thing you do is recurse.
14:03:04 <ddarius> The last thing you do in say, sum (x:xs) = x + sum xs is add, more clearly sum (x:xs) = add x (sum xs)
14:03:27 <sphynx> hm, I've got it :)
14:03:46 <lispy> sphynx: now, can you rewrite sum to be tail recursive?
14:03:57 <nominolo_> sum xs = sum' xs 0 where sum' [] acc = acc; sum' (x:xs) acc = sum' xs (x+acc)
14:04:04 <nominolo_> this one is tail-recursive
14:04:16 <sphynx> I remembered about tail recursion but I've thought this simply needs to be last operation in expression writing..
14:04:38 <sphynx> lispy, nominolo made this faster
14:04:40 <ddarius> sphynx: Reduce each of these definitions of sum with beta reduction and see the difference.
14:05:06 <nominolo_> oh, sorry :)
14:05:13 * lispy waits for the full release of reduction instead of using the potentially buggy beta reduction ;)
14:05:28 <sphynx> :))
14:05:58 <LoganCapaldo> But if everyone takes that attitude then the full realese of reduction will still be beta, it just won't say it on the box
14:06:09 <AStorm> Hello people.. does Lambdabot support new Google AJAX api?
14:06:09 <nominolo_> beta-reduction isn't buggy if you use de-bruijn style variable naming ..
14:06:33 <nominolo_> @protontorpedo = AStorm?
14:06:33 <lambdabot> how abut vs APL
14:06:44 <AStorm> nominolo, no
14:06:57 <lispy> AStorm: there is a webservice version of lambdabot
14:07:03 <lispy> ?where lambdaweb
14:07:03 <lambdabot> http://lambdabot.codersbase.com
14:07:07 <AStorm> lispy, hmmmm :>
14:07:09 <lispy> AStorm: ^^
14:07:16 <AStorm> lispy, I'm talking like - googling
14:07:21 <sphynx> and tail recursion can be optimized to loop (some iteration process) right?
14:07:37 <sphynx> I'm remembering something from SICP about this :)
14:07:45 <SamB> AStorm: what is wrong with @google?
14:07:51 <SamB> which is, of course, feeling lucky
14:07:53 <kc5tja> Tail recursion is just a jump, not a call, so it's imperative.
14:08:07 <kc5tja> s/recursion/recursion optimized/
14:08:14 <lispy> sphynx: because you don't need the intermediate stack frames you can write over them when you call the function again...and thus you get the same effect as iteration
14:08:20 <AStorm> SamB, does it use SOAP api, or no api?
14:08:46 <SamB> it uses HEAD api
14:08:47 <nominolo_> kc5tja: how is jumping imperative?
14:08:50 <SamB> iirc
14:09:17 <kc5tja> nominolo_: Because it turns function application into an imperative control structure.
14:09:24 <AStorm> SamB, and that is?
14:09:31 <Heffalump> kc5tja: only at the implementation level
14:09:38 <kc5tja> That's what was asked.
14:09:56 <AStorm> SamB, does it require any Google keys or something?
14:09:59 <lispy> AStorm: i don't think we (collectively #haskell) understand your questions
14:10:02 <kc5tja> In fact, if you look at the "imperative" version of sum above, you'll find most texts clearly describe it as imperative, not recursive.
14:10:27 <sphynx> so because one doesn't need to do something with result of tail-recursive function rather just returning - it doesn't need intermediate stack, right?
14:10:33 <Heffalump> sphynx: right.
14:10:33 <kc5tja> lispy: He's asking if Lambdabot uses the Google search API.
14:10:36 <nominolo_> kc5tja: no.  tail call just can be implemented easily.  you are confusing "iterative" with "imperative"
14:10:37 <SamB> HEAD http://www.google.com/search?hl=en&q=$QUERY&btnI=I%27m+Feeling+Lucky
14:10:40 <lambdabot> Title: Query - Wikipedia, the free encyclopedia, http://tinyurl.com/2cqz6s
14:10:42 <ddarius> Tail recursion -is- a loop.
14:10:55 <AStorm> SamB, hmmmmmmm, so no API.
14:10:56 <SamB> where $QUERY is whatever query you entered, suitably escaped
14:11:03 <kc5tja> nominolo_: Of course -- I use tail-call optimization in my Forth compiler.  I know what it is.  :)
14:11:14 <AStorm> lambdabot, Wouldn't Google kill you for being automated?
14:11:45 <nominolo_> kc5tja: i'm just complaining about your use of "imperative"
14:11:50 <lispy> AStorm: i think they probably could, but i doubt she generates enough traffic to be on the radar
14:11:59 <SamB> AStorm: it doesn't violate the terms of service
14:12:08 <AStorm> Heh, thanks for the info.
14:12:31 <DRMacIver> lambdabot is female?
14:12:36 <SamB> since there is a 1:1 relation between user requests and queries to them
14:12:38 <lispy> ?vixen are you a girl?
14:12:39 <lambdabot> <undefined>
14:12:51 <nominolo_> DRMacIver: yes, there are even pictures of her!
14:13:00 <AStorm> lispy, hmm, that's a definite answer
14:13:08 <SamB> the only reason they might ban it is if they didn't know that
14:13:20 <AStorm> ?where lambdabot
14:13:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:13:22 <DRMacIver> nominolo_: Uh huh...
14:13:26 <kc5tja> nominolo_: Meh -- I used the wrong word.  But my point remains.
14:13:57 <nominolo_> kc5tja: ;)
14:14:43 <nominolo_> kc5tja: you could label it "imperative" in the sense that it allows you to modify the stack frame, true
14:15:21 <nominolo_> kc5tja: but i have no good definition of imparative, either
14:16:34 <nominolo_> does anyone know where the other pictures of lambdabot are?
14:16:59 <sorear> SamB: I've read the Google Terms of Service.
14:17:08 <sorear> SamB: they are impossible to satisfy
14:19:03 <sorear> Oh, my...
14:19:21 <sorear> 1.1 Your use of Google's products, software, services and web sites (referred to collectively as the "Services" in this document and excluding any services provided
14:19:45 <sorear> 2.1 .... You may not use the Services if you do not accept the Terms.
14:20:02 <sorear> 2.3 You may not use the Services and may not accept the Terms if (a) you are not of legal age to form a binding contract with Google ...
14:20:06 <kc5tja> 1.1 was chopped off.
14:20:15 <sorear> 2.1 was an unnecessary paste
14:20:36 <sorear> kc5tja: It's a 11 page webpage.  I'm not gonna paste the whole thing!
14:20:42 <kc5tja> 1.1 chopped off at "...any services provided"
14:20:49 <kc5tja> So you're saying point 1.1 is 11 pages long?
14:20:52 <sorear> kc5tja: that's where I stopped pasting
14:20:57 <sorear> kc5tja: no, the whole thing
14:20:57 <kc5tja> I find that hard to believe.
14:21:11 * kc5tja had to read and sign a 16-page NDA when I got hired by Google.
14:21:15 <kc5tja> So I don't want to hear it.  :D
14:21:59 <sorear> In any case, those two clauses [1.1 + 2.3] seem to say "16-year-olds can't use google.com"
14:22:09 <sorear> guess I'll have to switch to yahoo ;)
14:22:46 <AStorm> sorear, uhm, you're right
14:24:13 <sorear> I was actually looking for a completely unrelated absurdity in the tos.
14:25:25 <Heffalump> they don't advertise the existence of any ToS on their front page
14:25:38 <Heffalump> so I reckon they'd have difficulty applying them to simple searches
14:25:42 <sorear> I found it somewhere else ... I forget where?
14:25:59 <Heffalump> kc5tja: do you still work for them?
14:26:24 <kc5tja> "still"?
14:26:31 <Heffalump> you said you got hired by them.
14:26:31 <kc5tja> Are you planning on having me fired or something?  ;D
14:26:37 <Heffalump> Did you mean "interviewed"?
14:26:45 <Heffalump> no :-p
14:26:48 <Heffalump> I was just wondering.
14:27:02 <kc5tja> Well, I don't work "for" Google, I actually work for Workforce Logic, rendering services TO Google.
14:27:19 <kc5tja> But while my paychecks come from WFL, everything else comes from Google.
14:27:36 <Heffalump> so they're doing the same thing M$ do?
14:27:38 <kc5tja> The intent is to transfer me to be a regular employee after my contract period is over.
14:27:42 <matthew-_> can you use GADT syntax with record types?
14:27:48 <Heffalump> matthew-_: I believe so.
14:27:58 <sorear> matthew-_: in head yes.
14:28:03 <kc5tja> Heffalump: It's not such a foreign concept.  Many companies use temp agencies to "try out" an employee before hiring full-time.
14:28:11 <matthew-_> sorear: oh bummer. not in 6.6 then?
14:28:12 <Heffalump> I vaguely remember Audrey Tang hacking that in during ICFP 2005 :-)
14:28:14 <sorear> long standing bug, iirc it affect 6.6
14:28:35 <matthew-_> any pointers as to what it's meant to look like?
14:28:57 <matthew-_> just normal gadt followed by { blah :: bloo ... } stuff?
14:29:01 <kc5tja> Looks like Microsoft may be trying to purchase Yahoo!.
14:29:16 <Heffalump> both sides getting desperate..
14:29:46 <kc5tja> You know you're desparate when you resort to filing patent applications for the IS NOT operator.
14:29:56 <kc5tja> (Let's conveniently ignore that C has had != for quite some time.)
14:30:02 <Heffalump> though I have to say a lot of people have mentioned that Google's search is losing it's edge slightly, so perhaps they have a chance
14:30:11 <Heffalump> s/it's/its/
14:30:36 <kc5tja> Google's search is losing its edge?  That's news to me.
14:30:58 <kc5tja> Whenever I search for anything at all, it's usually in the first page somewhere, which is quite definitely not the case of other engines.
14:31:14 <sorear> kc5tja: you do realize the wheel is patented in .au?
14:31:22 <AStorm> Huh, if I had the infrastructure Google has, I'd implement a much more sophisticated search engine than they have :P
14:31:25 <Heffalump> by edge I probably mean "magic touch". I used to expect what I wanted to be the top result :-)
14:31:45 <kc5tja> AStorm: We're already maxing out our infrastructure.  What do you have in mind?  Maybe you should consider applying for a job.
14:31:46 <c_> slightly-improved altavista/1995 technology with a highly efficient ad network
14:31:50 <c_> they could have done a lot in 12 years, but no
14:32:06 <Heffalump> Google was *much* better than Altavista when it first came out.
14:32:13 <Heffalump> Now, I have no idea, since I never use Altavista.
14:32:14 <ozzilee> Hey all, quick question. As I understand, I can use a tuple as the arguments to a function, but I can't find the syntax for it. Help?
14:32:24 <kc5tja> Heffalump: Well, let's all not forget a couple of things either.
14:32:24 <Heffalump> ozzilee: f (a, b) = ...
14:32:30 <sorear> ozzilee: just construct the tuple, then pass it.
14:32:41 <sorear> ozzilee: there is no special syntax for the combination.
14:32:44 <kc5tja> (A) Google has released publications on MapReduce, which is our core technology that makes our rapid response and accuracy possible.
14:32:48 <monochrom> People are learning how to get their pages ranked higher in Google.  "Their pages" are usually useless.
14:32:59 <AStorm> kc5tja, heh, maybe Google already uses what I thought about
14:33:00 <kc5tja> (B) It's been a few years since Google came on the scene.  That means competition requires others to keep up.  :)
14:33:02 <Heffalump> yeah, that's definitely a big problem
14:33:03 <AStorm> :>
14:33:18 <AStorm> But then, if it's maxed out, what I could propose wouldn't fit
14:33:22 <ozzilee> sorear: Um.. GHCi chokes on:   (+) (1,2)
14:33:30 <kc5tja> So, inevitably, our competitors will slowly acquire characteristics of Google, and occasionally may exceed us too.
14:33:32 <Heffalump> kc5tja: sure. I'm just saying that the aura of untouchability around Google is evaporating slightly.
14:33:32 <AStorm> too little CPU :>
14:33:37 <monochrom> > (+) (1,2)
14:33:39 <lambdabot>   add an instance declaration for (Num (t, t1))
14:33:39 <lambdabot>     In the expression: (+) (1...
14:33:41 <sorear> ozzilee: (+) takes two arguments.  it doesn't take a tuple!
14:33:46 <monochrom> Is that choking?
14:34:05 <sorear> ozzilee: if you want to pass two arguments, you have to pass two arguments
14:34:07 <sorear> > (+) 1 2
14:34:09 <lambdabot>  3
14:34:14 <ozzilee> sorear: Exactly, that's what I mean. I thought there was a way to expand the tuple out...
14:34:14 <DRMacIver> Or use uncurry.
14:34:15 <AStorm> monochrom, hehe
14:34:21 <AStorm> > (+) uncurry (1,2)
14:34:22 <lambdabot>  Couldn't match expected type `(a -> b -> c) -> (a, b) -> c'
14:34:27 <AStorm> blah :P
14:34:31 <monochrom> uncurry (+)
14:34:35 <DRMacIver> uncurry (+) $ (1, 2)
14:34:35 <AStorm> numbers aren't functions
14:34:35 <Heffalump> > uncurry (+) (1, 2)
14:34:37 <lambdabot>  3
14:34:39 <kc5tja> That is interesting; J has a "Curry" operator while Haskell has an Uncurry operator.  :)
14:34:45 <Heffalump> Haskell has both.
14:34:49 <DRMacIver> Haskell has a curry operator as well
14:34:52 <Heffalump> > curry (uncurry (+)) (1, 2)
14:34:53 <lambdabot>   add an instance declaration for (Num (t, t1))
14:35:00 <Heffalump> > curry (uncurry (+)) 1 2  -- doh
14:35:02 <lambdabot>  3
14:35:15 <lispy> it's not an operator
14:35:17 <sproingie> @type curry
14:35:18 <AStorm> add too much curry and it will be salty :>
14:35:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:35:26 <AStorm> lispy, nothing in haskell is an operator, so?
14:35:34 <lispy> AStorm: haskell has operators
14:35:35 <Heffalump> AStorm: operators in Haskell are infix.
14:35:36 <kc5tja> lispy: An operator is a function.
14:35:40 <monochrom> arrow notation (proc x -> ...) is syntactic curry.
14:35:49 <Heffalump> no, operators and functions are inter-convertible
14:35:49 <ozzilee> AStorm: I think that's exactly what I want. I have a function that needs to return two values, and I want to pass both of those to another function. So I could do:   uncurry secondFunction firstFunction
14:35:50 <kc5tja> > (+) `uncurry` (1, 2)
14:35:52 <lambdabot>  3
14:35:53 <sproingie> there are some non-function operators, no?
14:35:55 <Heffalump> using (..) and `...`
14:35:59 <sproingie> what about <- in do-notation?
14:36:01 <AStorm> exactly
14:36:03 <sproingie> or ``
14:36:06 <lispy> kc5tja: i just mean, it's not an operator in the strict technical sense of haskell...but it could be one, no problem
14:36:09 <Heffalump> that's syntax really
14:36:16 <monochrom> do-notation is syntactic sugar.
14:36:19 <Heffalump> though I could imagine thinking of it as an operator
14:36:30 <ozzilee> AStorm: Thanks.
14:36:50 * kc5tja considers do-notation a built-in macro expansion.
14:36:55 <AStorm> monochrom, not sugar, curry
14:37:02 <AStorm> add too much and it is too salty
14:37:08 <sproingie> sugary curry.  sounds like thai food
14:37:12 <AStorm> :>
14:37:16 <nominolo_> ?uses
14:37:17 <lambdabot> Maximum users seen in #haskell: 336, currently: 301 (89.6%), active: 40 (13.3%)
14:38:58 <AStorm> Hmm, Haskell should have some Encoding/Decoding library for text conversion purposes
14:39:26 <AStorm> maybe other random codecs too
14:39:35 <sorear> AStorm: we do, it's in the prelude!
14:39:42 <AStorm> sorear, hmm
14:39:43 <sorear> > show (1,2) -- encoding
14:39:44 <lambdabot>  "(1,2)"
14:39:53 <AStorm> sorear, uhm, not _that_ simple
14:39:54 <sorear> > read "(1,2)" :: (Int,Int) -- decoding
14:39:56 <lambdabot>  (1,2)
14:40:08 <AStorm> text conversion purposes, uhm
14:40:15 <AStorm> like ISO<->UTF
14:40:22 <DRMacIver> sorear: Cool, I didn't know you could do that second one.
14:40:26 <sorear> oh yeah.
14:40:28 <Igloo> AStorm: iconv in hackage
14:40:38 <AStorm> Igloo, so it's there, huh? :D
14:40:49 <drigz> they say that having recursive functions that call read for parsing is a Bad Thing. what's the alternative?
14:40:52 <sproingie> building in unicode conversion comes up every couple days here :)
14:41:16 <kc5tja> This is what sucks about software today.  All the truely useful apps have already been written.
14:41:22 <AStorm> drigz, Parsec
14:41:27 <sproingie> kc5tja: just not in haskell
14:41:30 <AStorm> or writing a proper parser yourself
14:41:44 * Heffalump doesn't think that's true at all, people are always coming up with new useful stuff
14:41:54 <c_> agreed
14:42:02 <drigz> is writing a parser in parsec quite a task? is it a lot to learn before you can get to where you were before with readL?
14:42:08 <kc5tja> Heffalump: Just not in Haskell.  :D
14:42:11 <AStorm> drigz, no, it's dead simple
14:42:16 <Heffalump> kc5tja: darcs
14:42:18 <c_> for every thing i want that doesnt exist, peple are rewriting the same app for the 1333th time, only this time in hasell
14:42:21 <sproingie> sometimes i wish for AI so my computer could tell me when i'm being an idiot
14:42:28 <kc5tja> Heffalump: OK, but that's already written. ; D
14:42:33 <Heffalump> kc5tja: and lots of internal projects at my workplace
14:42:42 <AStorm> kc5tja, hmmm, write a web browser in Haskell :>
14:42:52 <sproingie> i spent hours trying to figure out how to crop and set output formats for an xvid rip of a dvd so it would display the right aspect on my screen
14:42:54 <c_> would be nice
14:42:57 <c_> specify CSS etc as a formula
14:43:04 <norpan> all useful apps already written? surely you are joking
14:43:11 <sproingie> then i realized i should set my resolution to the movie's.  duh.  my computer should have told me what an idiot i was.
14:43:13 <sorear> nope, we're dead serious
14:43:19 <monochrom> If you learn how to implement your own Read instances, you effectively learn writing parsers in Haskell.  Then when you see Parsec you will actually feel relieved.
14:43:23 <kc5tja> AStorm: Funny, that was one of the ideas I had some time back.  However, that would be an utterly monumental task indeed.
14:43:46 <AStorm> kc5tja, start with JavaScript interpreter.... oh, it's already done! :P
14:43:55 <dylan> someone needs to write something like offline imap + imapfilter, so I don't have to run a local imap server to use both easily. ;)
14:43:56 <AStorm> So, go for layout engine instead.
14:44:17 <AStorm> dylan, it's called procmail/maildrop
14:44:32 <dylan> AStorm: procmail doesn't do what I do with imapfilter. :)
14:44:44 <AStorm> dylan, what do you want to do with it?
14:44:52 <kc5tja> procmail is also a piece of crap that tends to break on a whim, I've found out.
14:45:03 <dylan> currently it moves all mail older than 7 weeks out of my inbox, and about 10 other things.
14:45:10 <kc5tja> We used it while I was working at CariNet, and the doggone thing would work great for months, and then just "stop" working for unknown reasons.
14:45:28 <dylan> I use procmail too, to run spam assassin.
14:45:32 <AStorm> kc5tja, that's why I use maildrop :P
14:45:38 <AStorm> which is much much less sucky
14:45:57 <dylan> imapfilter is not all in the same niche as maildrop or procmail.
14:46:05 <sproingie> procmail is also the poster child for gratuitously arcane syntax
14:46:29 <AStorm> dylan, uhm, so you want a script doing mv, bah
14:46:30 <sproingie> it never had to be that complicated
14:46:40 <AStorm> dylan, anything more (that a cron can't do)
14:46:48 <kc5tja> sproingie: I thought that was Sendmail.cf.  :)  But, back in the late 90s, I remember implementing "pop-before-relay" by hand re-writing sendmail.cf and manually patching the POP3 server.
14:46:59 <dylan> AStorm: the syntax is quite a bit nicer?
14:47:19 <kc5tja> It was most informative, indeed.  I also learned, M4 really wasn't necessary once you understood the symbology.
14:47:40 <AStorm> M4 = teh suckiest language ever
14:47:51 <kc5tja> Concur.
14:47:51 <sorear> CPP sucks more
14:48:00 <kc5tja> No, I'd rather hack CPP than M4.
14:48:01 <sorear> it isn't even turing complete!
14:48:13 <aris18> why do you say cpp sucks ?
14:48:17 <Heffalump> sorear: that's a good thing
14:48:20 <AStorm> You mean the preprocessor? Yes, it's designed to be dumb.
14:48:20 <int-e> m4 has better quoting capabilities.
14:48:25 <sorear> aris18: Because of my mother.
14:48:44 <Heffalump> your mother programs in C? Poor you.
14:49:05 <Korollary> What's wrong with a mother with programming skills?
14:49:07 <DRMacIver> hm. It presumably becomes turing complete if you remove the restriction on recursive macros?
14:49:07 <AStorm> sorear has been programmed in C - now he overflows
14:49:08 <AStorm> :P
14:49:21 <Heffalump> it's not the programming, it's the language
14:49:35 <sorear> Actually mine doesn't.  I was poking fun at aris18's ELIZA mode.
14:49:40 <balodja> AStorm: but dcons has been programmed by lambdabot in haskel? :)
14:49:42 <Heffalump> yes, I guessed :-)
14:49:49 <monochrom> Hahahaha
14:50:03 <sorear> Hehe.  Dcons.
14:50:20 <monochrom> @remember balodja but dons has been programmed by lambdabot in haskel? :)
14:50:20 <lambdabot> Done.
14:50:27 <Heffalump> balodja: current thinking is that the first version of dons predated the first version of lambdabot
14:50:36 <sorear> it wasn't dcoutts?
14:50:48 <ventonegro> i wish there was a Haskell -> PIC asm compiler
14:50:51 <monochrom> dcoutts programmed lambdabot. lambdabot programmed dons
14:50:52 <sorear> or maybe dcons is his real name
14:51:04 <ventonegro> it's not done yet! anyone?
14:51:11 <Heffalump> has dcoutts actually written stuff for lambdabot?
14:51:16 <AStorm> ventonegro, write one :>
14:51:18 <balodja> oh, my poor english :)
14:51:27 <kc5tja> ventonegro: The PIC doesn't even have the resources to handle half of Scheme, let alone Haskell.  :)
14:51:28 <AStorm> Actually, there is native code emitter in GHC
14:51:39 * balodja was probably programmed in visual basic :(
14:51:43 <ventonegro> AStorm, damn, my quest for free labour didn't succeed
14:51:47 <kc5tja> (Unless you implement a bytecode interpreter in the PIC, and let the PIC run code from RAM).
14:52:36 <ventonegro> i guess ML would be more amenable
14:52:49 <sorear> kc5tja: How about jhc?
14:52:53 <AStorm> kc5tja, well, ASM is turing-complete, so...
14:52:59 <AStorm> it's definitely possible
14:53:06 <sorear> kc5tja: the jhc backend is famous for it's non-use of indirect jumps
14:53:07 <kc5tja> AStorm: It's the resources, not the instruction set.
14:53:08 <AStorm> just write C-- -> PIC ASM backend
14:53:18 <AStorm> and there you have Haskell :P
14:53:43 <drigz> AStorm: haskell can compile to c
14:53:45 <kc5tja> AStorm: Dude, on x86, GHC produces 600kB executables for my _simple_ programs.  PICs don't even have 32kB of ROM.
14:53:57 <AStorm> kc5tja, uhm, whoops
14:54:05 <kc5tja> :)
14:54:16 <drigz> also it tends to assume >=32bit wordsize i think
14:54:18 <kc5tja> Like I said, you'll have to implement a VM interpreter, and run from external RAM.
14:54:38 <kc5tja> drigz: The GCC for ATmega controllers emits fairly efficient >8bit code.
14:54:38 <sorear> Or just use staged interpretation.
14:54:43 <kc5tja> Not sure about PICs though.
14:54:50 <sorear> Write a pseudo-arrow that generates PIC code.
14:54:50 <ozzilee> AStorm: Sorry to bug you, is there a trick for using uncurry with three arguments, or a better way. (uncurry (uncurry foo)) gives me type :: ((A,B),C), instead of the (A,B,C) I want.
14:54:50 <sioraiocht> @hoogle (%)
14:54:52 <lambdabot> Did you mean: (%)
14:54:52 <lambdabot> Prelude.undefined :: a
14:54:52 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:55:07 <kc5tja> sorear: I'm not sure I fully understand you.
14:55:09 <Heffalump> ozzilee: no, there's no way to do that
14:55:15 <Heffalump> you need to write your own uncurry3
14:55:26 <kc5tja> Also, note that microcontrollers typically have 8:1 ROM-to-RAM ratio.
14:55:28 <Heffalump> (yes, it's a nuisance)
14:55:47 <kc5tja> So if you have an 8kB ROM device, you'll have ready access to 1kB of RAM (typically; not always, but close enough for a good generalization).
14:55:51 <AStorm> ozzilee, well, write your own function
14:55:54 <Heffalump> sorear: "pseudo-" arrow?
14:55:56 <petekaz> I just wrote my own implementation of 'transpose' and came up with a nice (at least for a newbie) one-liner: foldr (zipWith (:)) (repeat [])
14:56:06 <Heffalump> petekaz: yeah, that's nice.
14:56:07 <petekaz> I'm quite excited.
14:56:19 * Heffalump did roughly the same thing when learning Haskell and was also quite pleased with himself :-)
14:56:33 <AStorm> petekaz, it's almost the way it is implemented :P
14:56:38 <AStorm> ?src transpose
14:56:38 <lambdabot> transpose []             = []
14:56:39 <lambdabot> transpose ([]   : xss)   = transpose xss
14:56:39 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:57:17 <dolio> > transpose [[1, 2], [3, 4], [5]]
14:57:19 <lambdabot>  [[1,3,5],[2,4]]
14:57:21 <Heffalump> there was some other exercise where I had a one or two line solution that the instructor had to type into hugs to convince herself it was right
14:57:28 <ulfdoz> wow, my avl-tree is 15 times worse than Data.Set.
14:57:40 <ozzilee> Ok, thanks guys.
14:57:40 <AStorm> ulfdoz, you rock man :>
14:58:40 <AStorm> I've to build a real lambdabot
14:59:01 <AStorm> I'd have to pick a proper chasis, and of course program her in Haskell
14:59:10 <AStorm> using Lambdabot's core :P
14:59:33 <kc5tja> You'll have to name it "Steiny".
14:59:39 <AStorm> kc5tja, ?
14:59:45 <kc5tja> STEINY!  FETCH ME A DANISH!
15:00:03 <wy> What's a good way to report fatal errors in a program?
15:00:03 <kc5tja> (Strongbad humor)
15:00:13 <ulfdoz> error?
15:00:27 <sproingie> if they're fatal?  print and exit
15:00:31 <AStorm> First, I've to implement sme kNN matching for video edge/area detection. In Haskell.
15:00:43 <LoganCapaldo> putStrLn "Everything is a-OK"
15:00:46 <AStorm> That's for later
15:00:48 <wy> ulfdoz: Error will only print a message. Is there a way to dump stack or something?
15:01:03 <kc5tja> I prefer to dump fatal errors into a log file as well as printing them, if at all possible.  I've had programs that just printed to the console, only to have the errors scroll off before I could read it.
15:01:18 <AStorm> I hate when I've to write a MIPS VM in C, when in Haskell it takes 1/100th the time
15:01:18 <sproingie> kc5tja: then you should be logging it
15:01:19 <Heffalump> wy: no, getting a stack trace in Haskell is hard
15:01:27 <AStorm> and I actually don't have to write test cases :P
15:01:27 <Heffalump> lazy evaluation means that it's not obvious what you should dump
15:01:30 <ulfdoz> wy: and return undefined afaik.
15:01:35 <kc5tja> Case in point: Linux kernel panics, where the panic codes are at the TOP of the display, not at the bottom, and so therefore, the cause of the panic is completely off the screen before the computer locks hard.  >:(
15:01:36 <monochrom> Can use "assert" to dump line number.
15:01:46 <kc5tja> sproingie: I don't always have the choice.
15:01:53 <wy> Heffalump: Then can I give the line number and file name automatically?
15:02:04 <Heffalump> wy: yes, using assert as monochrom mentioned
15:02:07 <Heffalump> (GHC only)
15:02:25 <AStorm> Heh, write some logging monad instead
15:02:33 <AStorm> (or use what's there already)
15:02:34 <sproingie> solaris on sun boxen panic by printing in a nice big font then dropping to the boot rom prompt
15:02:51 <kc5tja> sproingie: YAY for Forth!!
15:03:13 <sproingie> yay for l1-a
15:03:24 <LoganCapaldo> Real operating systems don't panic. They remain calm in the face of an emergency :)
15:03:31 <kc5tja> Sun uses Open Firmware, which is a Forth environment.
15:04:00 <sproingie> can't say i've ever had cause to use bootforth
15:04:05 <LoganCapaldo> @lines xmonad
15:04:06 <lambdabot> Unknown command, try @list
15:04:06 <kc5tja> LoganCapaldo: I'll write my own OS as a goth OS.  I'll call system faults DGAFs (Don't Give A ****!!).  :)
15:04:13 <AStorm> LoganCapaldo, yeah, they hide the failure :P
15:04:16 <LoganCapaldo> eh I can dream :)
15:04:23 <wy> monochrom: Can you give me an example of assert? I looked up Hoogle and can't find an example.
15:04:29 <LoganCapaldo> about how many lines is xmonad now?
15:04:30 <sproingie> kc5tja: sounds too strong for goth.  a goth os would just sigh and quit
15:04:41 <kc5tja> sproingie++
15:05:02 <sproingie> "error.  figure it out, i don't see the point."
15:05:03 <monochrom> Control.Exception.assert
15:05:06 <AStorm> sproingie, sigh and die actually
15:05:18 <kc5tja> @remember sproingie <kc5tja> I'll write my own OS as a goth OS.  I'll call system faults DGAFs (Don't Give A ****!!).  <sproingie> sounds too strong for goth.  a goth os would just sigh and quit
15:05:18 <lambdabot> Done.
15:05:43 <wy> monochrom: Why does it take three arguments?
15:05:51 <wy> oh no. two
15:05:55 <AStorm> :>
15:06:03 <sproingie> i think DGAF errors would be for emoOS
15:06:07 <monochrom> Because haskell is a functional language.
15:06:19 <kc5tja> emOS -- I like it.
15:06:36 <wy> monochrom: What's the other argument I should pass it?
15:06:47 <AStorm> ?hoogle assert
15:06:48 <lambdabot> Control.Exception.assert :: Bool -> a -> a
15:06:48 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
15:06:48 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
15:07:05 <kc5tja> "Just *** it!  I give up!  Too many type errors!  I'm rebooting -- nobody likes me, YOU don't like me.  You'll never have to deal with me again.  Until I finish rebooting that is."
15:07:18 <yip> can ghc cross compile for ARM?
15:07:23 <AStorm> wy, what you want to check, heh
15:07:28 <sorear> yip: No.
15:07:38 <sorear> yip: Infact, GHC can't cross compile period.
15:07:42 <wy> AStorm: That's the first argument
15:08:00 <sorear> yip: it does support running natively on arm - get yourself an emulator and a arm-linux distro
15:08:09 <monochrom> The normal thing to do.
15:09:01 <yip> sorear: that will work for both GHC's native code generator, and GHC's gcc compilation path?
15:09:30 <sorear> yip: probably, I've never tried it
15:09:39 <sorear> might be unreg-C-only
15:10:06 <yip> what's that?
15:10:56 <wy> I still think dumping the stack can be meaningful
15:11:19 <sorear> Certainly.
15:11:39 <sorear> Point is, GHC doesn't even *keep* a useful call stack, unless you use -prof.
15:12:06 <Heffalump> gaah.
15:12:20 <monochrom> dumping something is meaningful. I wouldn't be too sure something is stack.
15:12:20 * Heffalump is trying to profile some code and getting nowhere
15:12:23 <wy> sorear: What type of machine is the compiler using?
15:12:33 <kc5tja> sorear: I remember reading in the GHC manual that -prof -auto-all should be used whenever you have intractible errors, so that you get more correct exception reports.
15:12:39 <Heffalump> wy: the spineless tagless G-machine
15:13:24 <wy> Heffalump: I'm currently hacking Peyton Jones book about G-machine. It seems it has a stack. Is that a different one?
15:13:42 <Heffalump> wy: sorear said "useful"
15:13:45 <kc5tja> The G-machine has an _evaluation_ stack, but not a return stack.
15:14:26 <kc5tja> (not strictly true -- it DOES have a return stack by virtue of using subroutines and C function calls)
15:14:45 <wy> Does it just lack debugging information?
15:14:46 <kc5tja> The thing is, though, is when the exception occurs, it could be in a function that you completely don't expect.
15:14:59 <kc5tja> No, it's because things aren't evaluated until they're actually needed.
15:15:11 <kc5tja> By which time, debugging information you're looking for may simply not exist anymore.
15:15:17 <sorear> wy: because of lazy evaluation, the physical call stack often contains no information at all
15:15:27 <sorear> it's worse than TCO
15:15:38 <kc5tja> I see TCO and think Total Cost of Ownership.
15:15:48 <sorear> So do I
15:16:14 <sorear> but I have to conform, and on #haskell TCO means tail call optimization.
15:16:15 <wy> So I guess I should spent more time on G-machine. Is the three instruction machine useful?
15:16:47 <kc5tja> o_O?  3-instruction machine?
15:17:03 <monochrom> Actually, the evaluation stack (actually, dereferencing the pointers stored on the evaluation stack) tells you execution context.
15:17:31 <kc5tja> How so?
15:17:53 <kc5tja> The items on the stack are references to thunks or raw integers.  They tell you nothing about how those thunks _got_ there, which is often more useful than what they actually are.
15:18:00 <wy> kc5tja: Maybe it's another abstract machine. I haven't got to that at the time.
15:18:56 <wy> I see. Thanks.
15:19:21 * kc5tja will need to research the 3-instruction machine.
15:19:29 <kc5tja> It's news to me; yet another thing on my to-do list.  :)
15:20:04 <wy> What's the roll of Simon Peyton Jones in Haskell? I saw his name on the Haskell report.
15:20:32 <kc5tja> I seem to recall he was the very first to conceive of the language.
15:21:08 <zinf> spj begat god, god begat haskell
15:21:13 <zinf> or something like that
15:21:22 <LoganCapaldo> zinf: you following me?
15:21:22 <wy> kc5tja: I think the language was inspired from Miranda, whose creator was a very clever guy.
15:21:25 <Heffalump> he was one of the several people who decided to design the language
15:21:26 <zinf> hehe
15:21:34 <zinf> LoganCapaldo: i'm everwhere
15:21:40 <sorear> wy: David Turner, specifically
15:21:48 <yip> is there any particular reason why ghc can't cross compile?
15:22:01 <sorear> yip: it squares the size of the compiler
15:22:14 <LoganCapaldo> Not everywhere, just the subset of channel;s I happen to be in :)
15:22:15 <sorear> at least if you do it badly
15:22:25 <LoganCapaldo> you, me jcreigh
15:22:29 <LoganCapaldo> maybe some others
15:22:34 <Heffalump> sorear: most compilers do it by having you build a cross-compiler specially
15:22:46 <Heffalump> or do you mean it squares the size of the source?
15:22:55 <LoganCapaldo> Start a club, Ruby programmers who are closet Haskell freaks. Or vice versa.
15:23:03 <sorear> Heffalump: yeah.
15:23:29 <sorear> since you have to account for both host FS/toolset and target libs/machine
15:23:29 <zinf> LoganCapaldo: ex ruby coders who are really bored in my case mostly
15:23:33 <kc5tja> OK, I have to get back to work on my Kestrel.  I've let it sit for entirely too long.
15:23:49 <sorear> "sit"?  it's tangible already?
15:24:20 <wy> Anyone has written partial evaluators here?
15:24:34 <Heffalump> sorear: hmm. I think it'd improve the code for it to factor that out properly.
15:24:50 <Heffalump> obviously if you started writing case analysis on the pair of (host, target) then you'd be in trouble
15:25:07 <sorear> wy: probably ... let me see if I can construe anything I've written as a partial evaluator
15:25:53 <ddarius> wy: Why do you ask?
15:25:59 <sorear> wy: I think the GHC optimizer qualifies, so JaffaCake may qualify
15:26:33 <wy> Because I want to know more about it. I'm reading about on it and it give me a lot insight into compilers.
15:27:10 <wy> Thanks sorear. Will he come here some time?
15:27:45 <sorear> wy: yeah.  but the simplifier is a really borderline case
15:28:19 <sorear> wy: it partially evaluates individual functions, so if you say foldl' (+) it will generate specialized sum-like code
15:28:40 <davidL> @src sum
15:28:41 <lambdabot> sum = foldl (+) 0
15:29:15 <wy> sorear: That's a kind of partial evaluation.
15:30:47 <nominolo_> :t stream
15:30:50 <lambdabot> Not in scope: `stream'
15:30:58 <sorear> well, the ghc version is interesting because it's not actually written, it falls out naturally of the inliner and Core's handling of letrecs.
15:31:11 <sorear> nominolo_: nonstandard, indeed not (yet) in Base
15:31:13 <wy> sorear: Have you seen Augustsson here recently?
15:31:21 <sorear> @seen augustss
15:31:22 <lambdabot> I saw augustss leaving #haskell 15h 23m 4s ago, and .
15:31:36 <wy> Core?
15:31:40 <sorear> Lennart I assume you meant.
15:31:57 <sorear> Core is GHC's intermediate language.
15:32:05 <sorear> so, foldl' basically looks like
15:32:17 <wy> sorear: Ah! So the same as what I'm looking at!
15:32:39 <nominolo> sorear: oh, it will be in base?  how well does that work with hugs and other less optimizing compilers/interpreters?
15:33:48 <wy> sorear: Have you read some compiler books? such as the Dragon book?
15:33:52 <sorear> nominolo: I imagine it will be a no-op since hugs doesn't apply rewrite rules.
15:33:55 <sorear> wy: No.
15:34:15 <Heffalump> wy: he's around a fair bit, generally.
15:34:21 <Heffalump> (augustss, that is)
15:34:42 <sorear> foldl' f z xs = go z xs
15:34:43 <sorear>   where
15:34:43 <sorear>     go !a [] = a
15:34:43 <sorear>     go !a (x:xs) = go (f a x) xs
15:34:58 <sorear> desugared
15:35:11 <wy> Heffalump: Good. I'll try to catch him.
15:36:10 <wy> sorear: I found normal compiler books a mess. So I started reading a functional one. That's really nice.
15:36:41 <sorear> foldl' = \ f z xs -> let rec { go = \a xs -> case a of { _ -> case xs of { [] -> a ; (x:xs) -> go (f a x) xs } } } in go z xs
15:36:42 <nominolo> @djinn Maybe (a,b) -> (Maybe a, Maybe b)
15:36:43 <lambdabot> f a =
15:36:43 <lambdabot>     case a of
15:36:43 <lambdabot>     Nothing -> (Nothing, Nothing)
15:36:43 <lambdabot>     Just (b, c) -> (Just b, Just c)
15:36:46 <ddarius> wy: There isa book available online about partial evaluation
15:36:55 * Heffalump goes mad with SCC annotations
15:37:02 <ddarius> typing when one of your hands is asleep is tricky
15:37:04 <sorear> now, look at foldl' (+) (0::Int)
15:37:05 <wy> ddarius: I guess you found the same one as mine.
15:37:18 <sorear> we can apply the function, just by inlining
15:37:25 <nominolo> @hoogle Maybe (a,b) -> (Maybe a, Maybe b)
15:37:26 <lambdabot> No matches, try a more general search
15:37:28 <sorear> foldl' is non-recursive and inlinable
15:37:34 <sorear> (it's go that recurses)
15:37:37 <sorear> so we have
15:37:38 <ddarius> wy: It's a pretty significant book, but I started reading it years ago.
15:37:45 * ddarius doesn't think he actually read the whole thing.
15:37:55 <wy> ddarius: How far have you got?
15:37:55 <Syzygy-> @hoogle Maybe (a,b) -> Maybe a
15:37:56 <lambdabot> No matches, try a more general search
15:38:00 <sorear> sum = \ xs -> let rec { go = \a xs -> case a of { _ -> case xs of { [] -> a ; (x:xs) -> go (a + x) xs } } } in go 0 xs
15:38:11 <int-e> @type lift
15:38:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:38:17 <sorear> now go is strict, so the unboxing transformation applies
15:38:21 <ddarius> wy: I don't remember.  A decent chunk into it, but I got distracted and never finished it.
15:38:30 <wy> ddarius: I'm currently stuck at the first PE, because I don't got the actual code.
15:38:39 <Syzygy-> > lift fst Just (3,5)
15:38:40 <lambdabot>  Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
15:38:48 <sorear> sum = \ xs -> let rec { go = \a xs -> case xs of { [] -> I# a ; (x:xs) -> case x of { I# x# -> go (a #+ x#) xs } } } } in go 0# xs
15:38:50 <int-e> @type liftM fst &&& liftM snd
15:38:52 <Syzygy-> > lift fst Just (3,5) :: Maybe Int
15:38:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a, b) -> (m a, m b)
15:38:53 <lambdabot>  Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
15:39:00 <sorear> and look, a fully PE-ified sum.
15:39:14 <sorear> and all we had to do was inline!
15:39:21 <sorear> (and optimize normally)
15:39:22 <Syzygy-> > liftM fst &&& liftM snd $ Just (3,5):: Maybe (Int, Int)
15:39:22 <lambdabot>  Couldn't match expected type `Maybe (Int, Int)'
15:39:35 <Syzygy-> > liftM fst &&& liftM snd $ (Just (3,5):: Maybe (Int, Int))
15:39:36 <lambdabot>  (Just 3,Just 5)
15:39:51 <Syzygy-> > liftM fst &&& liftM snd $ (Nothing :: Maybe (Int, Int))
15:39:52 <lambdabot>  (Nothing,Nothing)
15:40:00 <nominolo> Syzygy-: how would you call this kind of function?
15:40:33 <Syzygy-> I dunno. I wasn't asking for it.
15:40:43 <LoganCapaldo> @type liftIO
15:40:46 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:40:57 <LoganCapaldo> Huuuuuh?
15:41:09 <nominolo> LoganCapaldo: what?
15:41:23 <LoganCapaldo> @instances MonadIO
15:41:24 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
15:41:29 <LoganCapaldo> aha
15:41:34 <LoganCapaldo> it all becomes clear
15:41:54 <LoganCapaldo> but whyfor provide an IO specifc version of lift?
15:42:31 <nominolo> LoganCapaldo: because it works at an arbitrary nesting
15:42:53 <nominolo> :t lift
15:42:54 <LoganCapaldo> aha
15:42:55 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:43:02 <LoganCapaldo> of course it does!
15:43:32 <LoganCapaldo> and its useful because IO is the most privileged of monads :)
15:43:40 <davidL> ?palomer
15:43:41 <lambdabot> I have news for you, it's pointless
15:44:06 <monochrom> The State operations also transcend nesting.
15:44:45 <nominolo> hm, in principle, any operation could transcend nesting, doesn't it?
15:44:52 <monochrom> Yeah.
15:45:20 <nominolo> @src MonadTrans lift
15:45:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:46:08 <sproingie> i love the insults
15:46:20 <mux> @arr
15:46:21 <lambdabot> Shiver me timbers!
15:46:30 <ventonegro> sproingie, mention perl
15:46:59 <sproingie> @perl
15:46:59 <lambdabot> Maybe you meant: keal part pl spell tell url vera
15:47:06 <monochrom> essentially: instance (MonadXXX m, MonadTrans t) => MonadXXX (t m) where xxx = lift xxx.  Then xxx transcends nesting.
15:47:37 <Heffalump> that instance looks rather undecidable to me :-)
15:47:41 <yaxu> my haskell music has returned to reddit i see :)
15:47:41 <monochrom> I cannot decide whether this is nice or evil. But I have no moral.
15:47:43 <sproingie> the MTL stuff is all lift-less, isn't it?
15:48:13 <SamB> ... with O(n^2) instances, yes
15:48:36 <yaxu> http://doc.gold.ac.uk/~ma503am/alex/canntaireachd2 # more haskell music dorkiness
15:48:40 <lambdabot> Title: Canntaireachd synthesis part two | Alex McLean
15:49:27 <mdmkolbe|home> Does GHC have a trace functionality?
15:49:34 <sorear> No.
15:49:38 <SamB> like Debug.Trace?
15:49:49 <monochrom> Ah, usually we do what sorear says.  instance (MonadXXX m, ReaderT t) => MonadXXX (t m) where xxx = lift xxx.  Repeat for every ____T.
15:49:59 <sorear> You have to fake it with Debug.Trace, but that is very intrusive and completely unsatisfactory.
15:50:21 <Heffalump> is ghc 6.6.1 in Debian yet?
15:51:52 <mdmkolbe|home> sorear: I don't understand what you mean.  Debug.Trace.trace at least looks like what I want. (Other than not being referentially transparent, but I think thats a nessisary cost for any trace on a lazy language)
15:52:01 <ehird`> "Shoot, *I* don't know Haskell, and I've already learned it several times." -- Larry Wall
15:52:05 <mux> maybe I'm being a troll but I wouldn't Debian to even have ghc 6.6 yet
15:52:22 <mux> expect
15:52:29 <ventonegro> Heffalump, nope
15:52:35 <nornagon> yes, you're being a troll, mux
15:52:45 <ehird`> nornagon: debian has a reputation
15:52:48 <nornagon> (unless you're running etch)
15:52:55 <nornagon> actually
15:52:56 <drigz> the unstable versions aren't too bad are they?
15:52:58 <nornagon> etch might have 6.6
15:53:02 <nornagon> I run sid :)
15:53:04 <kaol> etch does have 6.6
15:53:05 <mux> I guess etch is unstable?
15:53:09 * mux doesn't run Debian
15:53:10 <nornagon> nope
15:53:13 <nornagon> etch is stable atm.
15:53:16 <ventonegro> drigz, i've been using sid for ages
15:53:17 <nornagon> recently released.
15:53:19 <nominolo> mdmkolbe|home: but it's hard to turn on/off.  also, you have to be really careful about forcing stuff
15:53:20 <Heffalump> I'm a bit surprised it's not in sid, given that Igloo maintains it and did the 6.6.1 release.
15:53:38 <mux> aah, that explains why it's up-to-date unlike most of the other packages :-)
15:53:50 <ventonegro> Heffalump, i wish it was
15:54:08 <Heffalump> has anyone else encountered -O0 -prof -caf-all  leading to multiply defined symbols in the assembler with ghc 6.6?
15:54:15 <ventonegro> mux, actually, you're talking non-sense
15:54:28 <ventonegro> mux, sid has very up-to-date packages
15:54:30 <sorear> mdmkolbe|home: It forces you to change obscene amounts of code.
15:54:30 <mux> yeah, sure
15:54:32 <mdmkolbe|home> nominolo: do you mean like missing traceIf flag str x = if flag then trace str x else x?
15:54:41 <sorear> Heffalump: Yes - and it's even on Trac.
15:54:55 <mdmkolbe|home> @type trace
15:54:56 <Heffalump> sorear: doh, I was just looking at that for something else, too :-)
15:54:57 <lambdabot> Not in scope: `trace'
15:55:03 <mdmkolbe|home> @type Debug.Trace.trace
15:55:05 <lambdabot> forall a. String -> a -> a
15:55:18 <nominolo> mdmkolbe|home: well, idially, you'd have a commandline option :trace <function>
15:55:34 <nominolo> mdmkolbe|home: that way you wouldn't have to change any code
15:55:56 <mdmkolbe|home> nominolo: true
15:56:11 <Heffalump> ok, so it's fixed. Now I really want 6.6.1 in Debian :-)
15:56:26 <lypanov> mux: fwiw. debian testing kinda works
15:56:54 <lypanov> no idea about haskell support
15:56:55 * Heffalump gives up on profiling for now and goes to bed. Bloody higher-order stuff is impossible to annotate sensibly.
15:57:12 <mux> I'm not really interested in some kind of flamewar debate over Debian - there was a smiley attached to my earlier remark
15:57:17 <Heffalump> (at least, I seem unable to do it)
15:57:29 <lypanov> mux: i know, just wanted to say :)
15:57:33 <mux> okay :-)
15:58:29 <mdmkolbe|home> ugh, I just realized that Debug.Trace requires me to have a (Show a) in my scope.  Now I see how much code would have to be changed.
15:59:00 <davidL> is there a way to use suffix parsing as opposed to prefix or infix?
15:59:14 <ehird`> davidL: are you kidding?
15:59:16 <ehird`> this isn't forth
15:59:26 <ehird`> cr 2 dup + .
15:59:43 <mdmkolbe|home> davidL: do you mean parsing or function application?
15:59:57 <davidL> I mean function application
16:00:24 <davidL> > 1 1 (+)
16:00:25 <lambdabot>        add an instance declaration for (Num (t -> (a -> a -> a) -> a1))
16:00:25 <lambdabot>     I...
16:00:41 <ehird`> > let 1 1 x = "hello" in 1 1 x
16:00:41 <lambdabot>  Parse error in pattern
16:00:45 <ehird`> as, you can see...
16:00:49 <ehird`> that won't work
16:00:58 <ehird`> because 1 1 x is "1 applied with args (1, x)"
16:01:01 <ehird`> which...makes no sense
16:01:41 <ddarius> @google typed quote antiquote
16:01:42 <mdmkolbe|home> davidL: if you really need it you might be able to make some combinators, it will probably end up awkward and slow
16:01:44 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
16:02:14 <mdmkolbe|home> davidL: or template haskell is another possible option (I think)
16:02:35 <davidL> I will just use prefix if that's the case
16:02:42 <ehird`> davidL: why do you want it?
16:02:45 <ehird`> i'm curios
16:02:46 <ddarius> ^ Embed LL(1) languages in Haskell
16:02:47 <ehird`> *curious
16:02:56 <mdmkolbe|home> davidL: e.g you could do: a `push` b `push` c `apply` f
16:03:50 <davidL> ehird`: no reason really, I was wondering if it could be done
16:04:22 <mdmkolbe|home> @type \a b c f -> let ppa = flip ($) in a `ppa` (b `ppa` f)
16:04:24 <lambdabot> forall t a a1 b. a -> a1 -> t -> (a1 -> a -> b) -> b
16:04:27 <ddarius> @faq
16:04:27 <lambdabot> The answer is: Yes! Haskell can do that.
16:04:53 <monochrom> hahaha that one's great!
16:05:22 <lypanov> lol
16:05:48 <mdmkolbe|home> davidL: define a flipped ($) is is right associative and you've got it (other than that awkward part about every argument needing to be seperated by the operator)
16:07:29 <nominolo> > let ( ) a f = f a in True not
16:07:30 <lambdabot>  Couldn't match expected type `(Bool -> Bool) -> t'
16:07:37 <nominolo> too bad ..
16:09:41 <mdmkolbe|home> hmm, come to think of it circumfix operators could be a nice addition to haskell.  When writting interpreters mathematically we might use [[expr]] to mean (eval expr), it might be nice to embed that more directly (it would probably make the hasekll parser blow up though)
16:10:20 <monochrom> I like that idea!
16:10:28 <nominolo> mdmkolbe|home: that's used by template haskell, it's written: [| .. |]
16:10:47 <monochrom> Yes, we're now dreaming about user-defined brackets.
16:11:35 <LoganCapaldo> > let E [x] = x in E[2 + 4]
16:11:40 <lambdabot>   Not in scope: data constructor `E'
16:11:44 <LoganCapaldo> oops
16:11:55 <LoganCapaldo> > let e [x] = x in e[2 + 4]
16:12:05 <lambdabot>  6
16:12:13 <LoganCapaldo> eh
16:12:15 <mdmkolbe|home> nominolo, monochrom: Perl6 is trying something like that, so anyone wanting to implement this should take a look at what they have done
16:12:26 <LoganCapaldo> it looked better with a captial E
16:12:46 <LoganCapaldo> data E where E :: a -> Eval a ? :)
16:13:17 <mdmkolbe|home> LoganCapaldo: nice, though that is just a (still nice) trick to make [] do the same as ()
16:13:35 <LoganCapaldo> yep, yep. didn't claim it was anything more :)
16:13:57 <LoganCapaldo> I mean hypotehtically e would be more like (eval . head) and not just head
16:14:24 <LoganCapaldo> but still doesn't buy much
16:15:15 <mdmkolbe|home> I wonder though, how far can Haskell syntax be stretched before the parser starts having problems.  E.g. would adding a trinary operator (?:) make the language ambiguous?
16:15:53 <davidL> > (read . reverse . show) 39
16:15:55 <lambdabot>  93
16:15:56 <ddarius> The OBJ3 language has many many types of fixities.
16:16:06 <ddarius> Infix, outfix, mixfix, prefix, presumably postfix
16:16:30 <mdmkolbe|home> ddarius: mixfix ~~ trinary operator?
16:16:44 <LoganCapaldo> ddarius: and it lets you def operators of all those fixities? That's pretty ridiculous
16:16:50 <ddarius> mdmkolbe|home: It can be any arity.
16:16:55 <ddarius> LoganCapaldo: Yes.
16:17:03 <dmhouse> > let True ? (x, _) = x; False ? (_, x) = x in 6 > 5 ? ("yes!", "sadly not")
16:17:04 <lambdabot>   add an instance declaration for (Num Bool)
16:17:21 <dmhouse> Well, yeah, with the right fixities, that works.
16:17:27 <dmhouse> > let True ? (x, _) = x; False ? (_, x) = x in (6 > 5) ? ("yes!", "sadly not")
16:17:28 <lambdabot>  "yes!"
16:17:53 <mdmkolbe|home> ddarius: how did it avoid ambiguous parsings?
16:18:05 <LoganCapaldo> ddarius: Woah. Looks like OBJ(3) came with the kitchen sink http://en.wikipedia.org/wiki/OBJ
16:18:06 <lambdabot> Title: OBJ - Wikipedia, the free encyclopedia
16:19:00 <monochrom> > let True ? (x, _) = x; False ? (_, x) = x; x $$ y = (x,y) in (6 > 5) ? ("yes!" $$ "sadly not")
16:19:02 <lambdabot>  "yes!"
16:19:14 <dmhouse> Perhaps (|) instead of ($$)?
16:19:28 <dmhouse> That might clash with guard syntax, I suppose.
16:19:30 <monochrom> After fixing fixities you can write 6>5 ? "yes" $$ "no"
16:19:35 <ddarius> mdmkolbe|home: I never actually used it.
16:19:52 * mdmkolbe|hom1 's network cable fell out
16:19:54 <dmhouse> > let True ? (x, _) = x; False ? (_, x) = x; (|) = (,) in (6 > 5) ? ("yes!" | "sadly not")
16:19:54 <lambdabot>  Parse error
16:20:02 <dmhouse> Yep, syntax clash.
16:20:23 <monochrom> After defining "data MyPair x y = x ::: y" and changing "?" to work on that instead of (,), you can write 6>5 ? x ::: y
16:20:24 <LoganCapaldo> dmhouse: I think you're trick is cooler than mine :)
16:20:28 <LoganCapaldo> eek
16:20:34 <LoganCapaldo> s/you're/your/
16:21:15 <monochrom> | is special for "data Blah = A | B" and "f x | x==5 = ..."
16:21:32 <LoganCapaldo> monochrom: shouldn't it be data MyPair a a ?
16:21:40 <LoganCapaldo> err
16:21:41 <monochrom> OH!
16:21:43 <LoganCapaldo> just a :)
16:21:47 <dmhouse> LoganCapaldo: it needn't be.
16:21:56 <ddarius> op _ _ : Int List -> NeList [id: nil] .
16:22:02 <dmhouse> It's just that it'd be (?) :: Bool -> MyPair x x -> x
16:22:12 <dmhouse> MyPair can still be parametrised over two types.
16:22:15 <monochrom> It's ok either way.
16:22:21 <dmhouse> monochrom: 'OH!'?
16:22:57 <LoganCapaldo> (?) :: Bool -> MyPair a b -> Either a b :)
16:23:46 <ddarius> op _(_) : Lambda Lambda -> Lambda .
16:24:07 <dmhouse> How lovely, a natural transformation between the sum and product bifunctors.
16:25:04 <ddarius> Two of them.
16:25:20 <LoganCapaldo> indeed
16:25:47 <ddarius> :t (Left . fst,Right . snd)
16:25:49 <lambdabot> forall b a b1 a1 a2 b2. ((a, b1) -> Either a b, (a2, b2) -> Either a1 b2)
16:27:39 <nominolo> : Left &&& Right
16:27:46 <davidL> > let reverseInt n = (read . reverse . show) n in reverseInt 3954
16:27:47 <nominolo> :t Left &&& Right
16:27:48 <lambdabot>  4593
16:27:50 <lambdabot> forall a b a1. a -> (Either a b, Either a1 a)
16:28:18 <dmhouse> :t Left *** Right
16:28:20 <lambdabot> forall a b b1 a1. (a, b1) -> (Either a b, Either a1 b1)
16:28:55 <dmhouse> davidL: eta-reduce! et reverseInt = read . reverse . show in ...
16:29:00 <dmhouse> s/et/let/
16:29:09 <nominolo> :t (first . Left) &&& (second . Right)
16:29:11 <lambdabot>     No instance for (Arrow Either)
16:29:11 <lambdabot>       arising from use of `first' at <interactive>:1:1-5
16:29:13 <ddarius> leta-reduce!
16:29:20 <nominolo> :t (&&&)
16:29:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:29:42 <nominolo> :t (***)
16:29:45 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:29:49 <dmhouse> ?instances Arrow
16:29:51 <lambdabot> (->), Kleisli m
16:29:58 <dmhouse> ?src Arrow (->)
16:29:59 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:30:03 <dmhouse> Aww, that should work.
16:30:07 <davidL> dmhouse: what?
16:30:16 <dmhouse> Fetching the source for an instance declaration.
16:30:36 <davidL> what is leta-reduce?
16:30:36 <ventonegro> @where Arrow
16:30:37 <lambdabot> I know nothing about arrow.
16:30:40 <ventonegro> @where Arrows
16:30:40 <lambdabot> http://www.haskell.org/arrows/
16:30:48 <nominolo> ?src (->) (***)
16:30:49 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
16:31:17 <ventonegro> what do arrows give you beyond monads?
16:31:33 <dmhouse> davidL: eta reduction allows you, if you have f x = g x, to write f = g. In your case, you have reverseInt n = (read . reverse . show) n, so you can write reverseInt = read . reverse . show
16:31:45 <dmhouse> ?src (->) (&&&)
16:31:45 <lambdabot> Source not found. You speak an infinite deal of nothing
16:31:49 <dmhouse> Bah.
16:32:06 <davidL> dmhouse: ah I see
16:32:46 <dmhouse> Night all.
16:32:47 <davidL> why does GHCi give the error: "`Read a' arising from use of `reverseInt'" when I do reverseInt as done above?
16:32:51 <nominolo> @djinn a b c -> a b c' -> a b (c, c')
16:32:52 <lambdabot> -- f cannot be realized.
16:33:16 <ddarius> davidL: me poking fun at dmhouse
16:33:28 <SamB> @djinn (Arrow a) => a b c -> a b c' -> a b (c, c')
16:33:29 <lambdabot> Cannot parse command
16:33:35 <nominolo> davidL: because the problem lies where it is _used_
16:33:47 <nominolo> or, no, wait ..
16:34:09 <davidL> I just do reverseInt 32 in GHCi and it gives that error
16:34:18 <nominolo> :t read . reverse . show
16:34:20 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
16:34:27 <nominolo> davidL: ^^^
16:34:34 <davidL> I tried adding that type and the same error =(
16:36:06 <ddarius> davidL: It doesn't know the output type.  Presumably you want the more strict (Read a, Show a) => a -> a
16:36:22 <hpaste>  LoganCapaldo pasted "reverseInt, no strings involved" at http://hpaste.org/1716
16:36:34 <ddarius> That or you need to provide a type signature to tell it what type to try to parse.
16:39:01 <davidL> that worked ddarius, thanks
16:57:49 <fridim> > let tt = 0:[a | a <- (sum (map (+a) tt)):tt]
16:57:49 <lambdabot>  Parse error
16:58:17 <sorear> let ... in what?
16:58:27 <sorear> you need an in
16:58:39 <sorear> > let x = 2 in x
16:58:40 <lambdabot>  2
16:58:46 <norgul> hi folks
16:58:47 <fridim> > let tt = 0:[a | a <- (sum (map (+a) tt)):tt] in take 10 tt
16:58:48 <lambdabot>   Not in scope: `a'
16:59:03 <norgul> is haskell a good programming language to develop compilers in?
16:59:09 <ddarius> Hah
16:59:13 <sjanssen> very much so
16:59:21 <sorear> norgul: Yes.
16:59:26 <norgul> ah, nice
16:59:45 <sjanssen> norgul: Haskell was built by language and compiler geeks, essentially
17:00:04 <norgul> key
17:00:17 <ddarius> > let tt = 0: mdo a <- sum (map (+a) tt):tt; return a in take 10 tt
17:00:18 <lambdabot>  Parse error
17:00:28 <sorear> norgul: haskell has very powerful features for definitions of data types and operations between them.
17:00:43 <norgul> cool
17:00:43 <ddarius> :t mdo return 3
17:00:46 <lambdabot> forall t (t1 :: * -> *). (Num t, MonadFix t1) => t1 t
17:00:50 <sorear> norgul: not a great help if you're writing a raytracer, but that's basically all compilers are
17:00:58 <norgul> i have concidered taking a look at it
17:01:06 <ddarius> > let tt = 0 : mdo { a <- sum (map (+a) tt):tt; return a } in take 10 tt
17:01:06 <lambdabot>  Parse error
17:01:25 <LoganCapaldo> lambdabot: wheeeeree!?!?!!
17:02:21 <sorear> haskell is also a very effective tool for cycle wasting.  one of the expirimental compilers needs more than five minutes on hello world...
17:02:21 <sorear> s/is also/can also be/
17:03:14 <sjanssen> ddarius: the pre-parser doesn't understand mdo
17:03:28 <ddarius> Most whole program optimizers like that.  My understanding is that most of that time is spent optimizing the Prelude and such.
17:03:39 <ddarius> sjanssen: I just realized I used :t to test that.
17:05:21 <ddarius> > let tt = 0 : mfix (\a -> sum (map (+a) tt):tt) in take 10 tt
17:05:22 <hpaste>  cdsmith pasted "bug in lambdabot?" at http://hpaste.org/1717
17:05:23 <lambdabot>  Exception: stack overflow
17:06:16 <ddarius> cdsmith: What does that have to do with lambdabot?
17:06:26 <cdsmith> The unpl command is lambdabot
17:06:38 <ddarius> oh goa
17:06:38 <sjanssen> :t (flip $ (flip take) . (map toUpper))
17:06:41 <lambdabot> Int -> [Char] -> [Char]
17:07:00 <sjanssen> cdsmith: the parser unpl doesn't handle infix operators correctly
17:07:03 <kpreid> cdsmith: unpl doesn't know precedence
17:07:35 <cdsmith> so...
17:07:45 <cdsmith> @unpl (flip ((flip take) . (map toUpper)))
17:07:45 <lambdabot> (\ b c -> take b (map toUpper c))
17:07:58 <sjanssen> cdsmith: so unpl is parsing that statement incorrectly
17:08:09 <cdsmith> Ah, much better!
17:08:27 <LoganCapaldo> @botsnack
17:08:28 <lambdabot> :)
17:08:52 <sjanssen> somebody should add a pass to Language.Haskell's parser that fixes precedences
17:09:02 <sjanssen> and then fix undo and unpl
17:09:08 <sjanssen> because I'm too lazy :)
17:09:23 <kpreid> the hard part is finding the precedence info
17:09:58 <sjanssen> hardcoding all the Prelude operator predences is a good start
17:11:27 <cdsmith> Say I was bored and wanted to do this.  Where would I start?
17:11:41 <sjanssen> @version
17:11:41 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
17:11:42 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:11:49 <SamB> cdsmith: its supposed to be a friend
17:11:51 <sjanssen> cdsmith: execute that last line :)
17:12:03 <sjanssen> @docs Language.Haskell
17:12:04 <lambdabot> Language.Haskell not available
17:13:01 <cdsmith> Patch 1 of 1540 !
17:13:08 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Syntax.html -- then write a function that manipulates these data structures
17:13:11 <lambdabot> http://tinyurl.com/2xfxsf
17:13:17 <sjanssen> cdsmith: darcs get --partial will go much faster
17:15:16 <kpreid> write a function PrecedenceData -> HsExp -> HsExp
17:15:49 <cdsmith> Gotcha... I'll hack at this and see what happens.
17:16:04 <sjanssen> and once you've finished these steps, you can bug kpreid and I for help with integrating this with @unpl and @undo (if you so desire)
17:16:16 * kpreid wrote unpl
17:16:27 <fridim> >let tt = 0:[a | a <- 1:0:(zipWith (+) tt (tail tt) )] in take 20 tt
17:16:27 <sjanssen> finally, 'darcs send', and receive much glory!
17:16:47 <fridim> > let tt = 0:[a | a <- 1:0:(zipWith (+) tt (tail tt) )] in take 20 tt
17:16:49 <lambdabot>  [0,1,0,1,1,1,2,2,3,4,5,7,9,12,16,21,28,37,49,65]
17:17:01 <SamB> kpreid: wouldn't you need more than one of those?
17:17:11 <kpreid> SamB: ?
17:17:52 <SamB> one to handle normal post-parsing, and one to get rid of un-needed parens after some automatic processing?
17:17:57 <sjanssen> SamB: for descending the different parts of the AST?  perhaps, or you could use Data.Generics
17:19:00 <kpreid> SamB: oh, sure
17:19:13 <sjanssen> paren pruning is less necessary (and can probably be done in the pretty-printer)
17:19:46 <SamB> true
17:22:49 <foones> Hi
17:23:08 <sjanssen> hi
17:23:28 <foones> I'm tyring to use the Data.Map module
17:23:35 <foones> in Hugs
17:23:49 <foones> but a single file with
17:23:53 <foones> import Data.Map
17:24:07 <foones> says "Can't find imported module Data.Map"
17:24:34 <foones> the file seems to exist in packages/base/Data/Map.hs
17:25:53 <sorear> strace hugs MyFile.hs
17:26:17 <sorear> does that give any hints?
17:26:43 * sorear looks for an actual verbose option
17:42:56 <br1> @paste
17:42:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:43:26 <hpaste>  br1 pasted "state machine boiler plate" at http://hpaste.org/1718
17:44:22 <br1> I'm making a game in C++, and I found a problem, so I started up ghc to think more clearly.
17:44:56 <br1> I have some characters that are in some state.
17:46:19 <br1> Not all state transitions are legal, so eacho state has a list of the states it can reach.
17:46:38 <br1> Given these rules, the controller of the character can do whatever he wants.
17:47:07 <br1> I came up with a solution in haskell, but it has a lot of boilerplate code in it.
17:48:24 <br1> I was wondering which aproach would be best to solve this problem. I have read about SYB, polyp and generic haskell before, but I don't know which to delve into.  Any thoughts?  The code is just 30 lines, please take a look.
17:48:34 <monochrom> The state transition table must be handcoded since in general there is no discernable trend.
17:48:46 <br1> monochrom: yes
17:49:14 <br1> what becomes burdensome is the boxing unboxing necesary between different data types
17:49:17 <sorear> you probably want something dsly
17:49:42 <br1> dsly?
17:49:53 * kc5tja was having substantial problems with finding a bug in some Forth code for the Kestrel; I'm not using Haskell, but I am using a functional thought process to model a new rewrite of the code.  In the process, I've accidentally re-invented abstract state machines.  :)
17:49:53 <monochrom> However, such table can be handcoded as a list like [ (State, [State]) ].  List of pairs.  Each pair (s,[s', t', ...]) says "if current state is s then next we allow s' or t' or ...
17:50:26 <monochrom> Then you just write a small function to do the lookup.
17:51:08 <monochrom> You may like to add "deriving Eq" to your State so that the small function can just walk through the list and do == tests.
17:51:11 <br1> monochrom: the problem is that the states are all different types. Now that I think about it, maybe HList is for me. I was using boost::variant in the c++ code originally.
17:51:30 <monochrom> Alright, should be just as easy in C++.
17:52:19 <monochrom> In c++ may use "array" instead of "list" for the support of handcoding syntax.
17:52:25 <br1> sorear: what's dsly?
17:52:38 <LoganCapaldo> Of, or relating to a dsl :)
17:52:58 <littledan> kc5tja, doesn't forth naturally lend itself to functional thinking?
17:53:08 <br1> LoganCapaldo: Oh, I see.
17:53:37 <br1> The problem is that I need a dsl on types, or something.
17:53:48 <littledan> (at least the way I think of it)
17:54:22 <br1> monochrom: I can't use an array in C++ for the same reason I can't use lists in Haskell; because I need to store different types.
17:54:27 <kc5tja> littledan: Overall yes, but Forth allows not only variadic inputs, but also variable numbers of returns per word as well.  As a result, my target compiler was producing correct code output for the target, but the _host_ environment had a substantial "stack leak" somewhere.  After compiling a modest program, I had 182 items on the data stack, and debugging wasn't able to isolate the word that caused it.
17:55:21 <kc5tja> littledan: Yet, testing the testable words in isolation all produced correct results and were stack-balanced, so it had to be in the untestable words (e.g., the words that took in input in the input stream)
17:55:39 <LoganCapaldo> class IsState a where validTransistion :: (IsState b) => b -> a -> Bool ... ?
17:55:59 <kc5tja> But interactively testing them seemed to indicate everything was good too.  So, instead of wasting my life away trying to find out what it was, I'm just rewriting from scratch.
17:56:10 <monochrom> I am tempted to add some typeclass hackery. That will translate to subclassing in c++.  But LoganCapaldo beats me to it. :)
17:56:56 <br1> hehe. I don't think that would work, because the validity of transitions is not available in compile time.
17:57:35 <littledan> kc5tja, did you know there are some typed forth-like languages?
17:57:41 <LoganCapaldo> Oooo that's the real problem then, isn't it?
17:57:54 <LoganCapaldo> stupid run time information
17:58:32 <kc5tja> littledan: Yes, I'm aware of Factor (dynamically typed) and StrongForth (statically typed), but neither is suitable is suitable for my application (developing the firmware to be placed in the Kestrel's ROM)
17:58:42 <littledan> oh
18:00:51 <br1> LoganCapaldo: yes, that's the problem
18:05:20 <foones> Cat is an statically typed stack-based language
18:05:40 <foones> http://www.cat-language.com/
18:05:41 <lambdabot> Title: The Cat Programming Language
18:06:05 <sorear> foones: we don't need statically typed stack-based languages atm
18:06:11 <littledan> cat is even less suitable for systems programming
18:07:01 <ozzilee> br: I haven't done much with games or C++, and maybe it's completely overkill, but would that kind of problem be solved more easily by an embedded scripting language on top of a C++ base?
18:07:08 <kc5tja> I think the only thing I really would want from a Forth compiler is stack balance checking.
18:07:56 <LoganCapaldo> kc5tja: So what your saying is we need someone to bring balance to the Forth?
18:08:47 <kc5tja> LoganCapaldo: Har har.  ;)
18:08:56 <kc5tja> If only I had a nickle for everytime I had heard THAT one.  ;D
18:09:15 <LoganCapaldo> How many nickles would you have?
18:09:24 <kc5tja> Oh, about 15.
18:09:24 * LoganCapaldo thought it was pretty original
18:09:33 <kc5tja> But, that's a pack of gum.
18:09:52 <littledan> how about, if you had $100 for every time you heard that?
18:09:59 <kc5tja> Now, "Use the Forth" ... I'd probably have about $300 in nickles then.  :)
18:10:09 <br1> ozzilee: A scripting language would be quite different. I'm trying to have all checking at compile time.
18:10:10 <kc5tja> nickels even.
18:10:33 * littledan uses Factor, but the Factor community generally looks up to you Haskellers
18:11:01 <sorear> up?  you sure?
18:11:13 <littledan> well, more like we think we're both good
18:11:15 <erider> littledan: is forth
18:11:31 <littledan> sorear, have any Factorers trolled here?
18:11:46 <littledan> erider, what?
18:12:01 <ozzilee> br1: Ok. Just wondering if it was something you had thought of.
18:12:01 <erider> factor is forth
18:12:09 <kc5tja> No, it's most definitely not.  :)
18:12:30 <sorear> in factor, almost every word can crash!
18:12:32 <littledan> erider, sorta. Factor's like Forth+Scheme with weird twists in a bunch of places
18:13:02 <kc5tja> Yeah, Factor is much more like a RPN scheme.
18:13:14 <kc5tja> Superficially it looks like Forth, but Forth is quite different once you get to the nitty gritty of it.
18:13:23 <littledan> yeah, that's true
18:13:36 <erider> the same for Toka then
18:13:50 <erider> but the bottom line its still forth
18:14:09 <kc5tja> Forth is a machine language for a stack virtual machine.
18:14:12 <erider> and the guys who made the language hang out in #forth
18:14:16 <littledan> sorear, it's dynamically typed, but there's a bit of static checking, and full optional static type checking is planned for version 2.0 (which'll be many years from now)
18:14:32 <littledan> if that's what you meant by "almost any word can crash"
18:14:33 <kc5tja> You can happily crash the system with something like : FOO ; 0 ' FOO ! FOO.  You can't do that with other languages.
18:14:47 <kc5tja> erider: Well, Slava hangs out in #Forth.  Nobody else does.
18:14:55 <littledan> I should
18:15:18 <erider> kc5tja: you should have a look a toka
18:15:23 <littledan> erider, what's toka?
18:15:46 <erider> http://charleschilders.com:9812/
18:15:58 <kc5tja> Another refinement on Forth's basic concept, including conservative garbage collection and a few other diddies.  I especially like its Word Classes.
18:16:14 <kc5tja> However, I'm shooting for simplicity of implementation for the Kestrel.
18:16:14 <erider> kc5tja: I used take to you in another channel right?
18:16:23 <erider> oops talk*
18:16:30 <kc5tja> Maybe in #Forth many eons ago.
18:16:36 * kc5tja hangs out in ##Forth and #c4th-ot now.
18:16:57 <erider> no it was in ray's channel
18:17:02 <kc5tja> i440r, papavic, and numerous others had a falling out with me, and I decided to just not bother hanging out there any more.
18:17:22 <kc5tja> That'd be #c4th-ot then.
18:17:27 <kc5tja> Or #burke.
18:17:35 <erider> burke is
18:17:56 <erider> how is it going on the west coast btw
18:18:07 <kc5tja> It is going well so far.
18:18:14 <sorear> kc5tja: void foo() { *((int*)foo) = 0; foo(); }
18:18:37 <erider> kc5tja: I think you should have a look at toka
18:18:37 <sorear> #concatenative is a channel dedicated to factor.
18:18:41 <kc5tja> I'm in gross violation of my renters agreement by having a clothesline in my patio with clothes drying on it right now.  But, I saved $2.00 in drying expenses.  The line has already paid for itself.
18:18:54 <LoganCapaldo> hehehehhee
18:19:22 <kc5tja> LoganCapaldo: Hey, it adds up.  Especially when gas costs $4/gal (approx).
18:19:33 <kc5tja> (closer to $3.50/gal now, but I've seen it lower and I've seen it higher)
18:19:47 <littledan> sorear, I tried to get them to move the factor discussion to #factor, but no one really supported me on that
18:20:06 <LoganCapaldo> Yeah you say that now, just wait until the rental police catch on
18:20:24 * LoganCapaldo envisions littledan in #factor, alone
18:20:34 * kc5tja has even purchased the "WonderWasher" (a hand-cranked washing machine) so that I can wash my gi, and not have to spend $3.75 in washing every week.
18:20:51 <LoganCapaldo> Nice.
18:21:00 <erider> littledan: if you like factor you will like toka
18:21:10 <kc5tja> That way, I can go to aikido more than twice a week (since I only own two gis).
18:21:10 <littledan> erider, I'm reading about it know
18:21:14 <erider> its nice little tool
18:21:15 <littledan> s/know/now/
18:21:27 <littledan> I don't understand what's so cool about word classes
18:21:49 <kc5tja> Traditional Forth has two classes of words: non-immediate and immediate.
18:22:08 <kc5tja> Toka and other Forth dialects (e.g., RetroForth) which support word classes can support additional word classes, as you see fit.
18:22:10 <LoganCapaldo> googling for toka seems to result in all second hand references
18:22:27 <littledan> it's the albanian word for earth, apparently
18:22:32 <sorear> kc5tja: but what does it *do*?
18:22:51 <kc5tja> A word class determines a word's behavior at interpretation, compile-, and run-times.
18:22:54 <sorear> kc5tja: I can't envision a different setting for the compiler?
18:23:08 <erider> littledan: http://retroforth.com/paste/?id=330
18:23:30 <kc5tja> So, for example, a non-immediate word has an interpret and run-time semantic that is the same (the action of the word), and a compile-time semantic of stuffing the run-time address into the current definition.
18:23:32 <erider> that is some more practical to look it
18:23:41 <davidL> > length [1..10^9]
18:23:45 <lambdabot> Terminated
18:24:30 <davidL> why does it take ghci 31.75 secs to find the length of [1..10^9] ?
18:24:42 <mdmkolbe|home> Is there a list difference operator?
18:24:47 <kc5tja> If S" had its own class, for example, it could have: (A) an interpret-time semantic of using one of several available PAD buffers, (B) a run-time semantic of pushing a string's address and length on the stack, and (C) a compile-time semantic of inlining the string into the current definition.
18:25:03 <sorear> davidL: does that seem unreasonable?  I think 120 cycles is really good for a lazy deref...
18:25:06 <kc5tja> Another class could be a generalization of a defining word of some kind.
18:25:52 <davidL> sorear: but that should take less than a second
18:26:14 <mdmkolbe|home> nm, I found it.  (\\)
18:26:16 <kc5tja> Because ghci is interpreted at the bytecode level, while ghc compiles to native code.
18:26:19 <littledan> kc5tja, that's an interesting idea. But when is runtime used if interprettime and compiletime are each specified?
18:26:23 <sorear> davidL: to loop through a one billion element list?!
18:26:50 <kc5tja> Interpret-time is when you type something interactively on the command-line, OR, if you execute code while a program is being loaded from storage.
18:27:02 <kc5tja> Compile-time is when you're in the middle of a colon-definition.
18:27:08 <LoganCapaldo> @src length
18:27:08 <davidL> sorear: sure, computers can do 1 billion calculations in a second
18:27:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:27:11 <kc5tja> Run-time is when you're executing a previously compiled definition.
18:27:33 <littledan> oh
18:27:36 <sorear> kc5tja: It seems like it would be so much cleaner to not have a separate interpret, and run everything in a trivial colon?
18:28:17 <LoganCapaldo> Maybe have interpreter time semantics is good for things like debugging?
18:28:22 <kc5tja> You mean having the outer interpreter function inside an implied :-definition, just like ghci is in an implied do-block?
18:28:41 <littledan> sorear, often it's disadvantageous to do an optimized compile at runtime (if toka optimizes)
18:28:50 <kc5tja> It turns out to have some pretty bad consequences -- for starters, it'd require you to have the ability to nest :-definitions, which Forth's semantics don't allow for.
18:28:57 <sorear> davidL: pulling an element out of [1..10^9] is not one calculation; it requires two indirect jumps, two allocations, and an update (updates of existing data are expensive in a generational gc system)
18:29:35 <sorear> kc5tja: Actually I was thinking that + is processed as :NONAME + ; EXECUTE
18:30:02 <kc5tja> sorear: Isn't that what I just described?  1 2 3 + ==> :NONAME 1 2 3 + ; EXECUTE
18:30:03 <erider> littledan: I could never get factor to run on my 64 bit linux system
18:30:24 <littledan> erider, have you tried the most recent version?
18:30:27 <sorear> kc5tja: My system has no lookahead and would make 4 defs, not 1.
18:30:38 <erider> yeah
18:31:04 <kc5tja> Well, it's doable, but the problem is, you run out of dictionary space just by interpreting.
18:31:05 <littledan> in factor, all of the code between colon defs is collected during parsing into a quotation, which is run after compilation is complete
18:31:10 <erider> I do the ./f and it doesn't launch
18:31:22 <littledan> erider, which version do you have?
18:31:43 <littledan> probably the problem is that you have to specify an image file with the version you have
18:32:16 <littledan> try ./f -i=factor.image, and if that doesn't work, ./f factor.image
18:32:33 <sorear> Image files?  why isn't f the image?
18:32:35 <kc5tja> -i=?  Maybe without the equals?
18:32:41 <littledan> f is the executable
18:32:44 <erider> I remove it is was taking space specially if I could use it
18:32:47 <kc5tja> f is the virtual machine.
18:32:50 <littledan> kc5tja, no, with the equals
18:32:56 <kc5tja> huh, weird.
18:32:57 <littledan> kc5tja, right, the vitual machine
18:33:04 <littledan> it's like smalltalk
18:33:15 <sorear> Last time I wrote a persistant forth the virtual machine and the image saved as one.
18:33:25 <littledan> erider, look at you README
18:33:26 <sorear> S" foo" SAVE      ./foo
18:33:29 <littledan> *your
18:33:49 <kc5tja> sorear: I openly challenge you to do that on Linux.  :)  It's much more difficult than you realize.  Doable, but hard.  Especially if you want to exploit dynamically linked libraries.
18:33:57 <kc5tja> You need to emit dynamic ELF images.
18:33:58 <kc5tja> Sucky.
18:34:00 <erider> I'm happy with toka but I may have another look at factor
18:34:06 <sorear> kc5tja: I did it on linux.
18:34:12 <sorear> kc5tja: no shlibs though
18:34:22 <SamB> ah.
18:34:26 <littledan> erider, join #concatenative so I don't spam this channel with any more instructions
18:34:26 <kc5tja> Yeah, I've done static ELF too.  But, even static is not an easy matter.
18:34:30 <SamB> how do you load them?
18:34:49 <sorear> SamB: "load"?
18:34:52 <SamB> hmm.
18:34:59 <SamB> how do you upgrade the VM?
18:35:32 <sorear> uh, this is forth, you would add new definitions :)
18:35:38 <kc5tja> SamB: You download the latest VM implementation, and re-import your changes into the new VM.  Your "changes" (aka source code) exist as separate files usually.
18:35:47 <sorear> actually I was back at the reassemble and rebootstrap stage
18:36:05 <SamB> ... assemble?
18:36:18 <sorear> SamB: yes, assembling.
18:36:24 <SamB> as in NASM?
18:36:32 <sorear> SamB: exactly.
18:36:40 * kc5tja did his assembly in Forth itself.
18:36:45 <kc5tja> I used gforth to bootstrap.
18:37:03 <erider> kc5tja: how is your project coming btw
18:37:09 <kc5tja> But the project didn't get very far, precisely because I needed access to shared libraries, and didn't want to go through the expense.
18:37:30 <kc5tja> erider: Right now, it's stagnant because I'm having difficulty keeping the firmware in my head.
18:37:40 <kc5tja> I must be getting old, because I can't even keep a basic Forth system in my head.  :(
18:37:46 <sorear> kc5tja: How did you convince gforth to assemble something you could write to disk (as opposed to assemble-into-dictionary)
18:37:47 <sorear> ?
18:38:04 <kc5tja> sorear: CREATE outBuffer BUFSIZE ALLOT
18:38:17 <kc5tja> : SAVE (open-file) (write-buffer-to-file) (close-file) ;
18:38:29 <kc5tja> VARIABLE ptr   outBuffer ptr !
18:38:39 <kc5tja> : `allot   ptr +! ;
18:38:52 <kc5tja> : 1,   ptr @ c! 1 `allot ;
18:38:53 <kc5tja> ..etc..
18:39:43 <sorear> kc5tja: so you weren't using the builtin gforth assembler.  more sense now
18:39:46 <kc5tja> No, I did the Machine Forth thing, where I just hardcoded opcodes (provided graciously from fasm).
18:39:47 <Saizan> wow a languange with a syntax worse than lisp :O
18:40:03 <kc5tja> Saizan: What syntax?  There *IS* no syntax.
18:40:06 <sorear> Saizan: do tell?
18:40:16 <kc5tja> Saizan: What you mean is, "WOW!  A language which I don't know what the symbols mean!"
18:40:20 <sorear> kc5tja: he obviously isn't talking about forth, forth is pretty
18:40:25 <littledan> kc5tja, really? redefine spaces for me!
18:40:26 <kc5tja> Yup.
18:40:47 <kc5tja> littledan: I can do so by re-defining the colon compiler.
18:40:52 <Saizan> kc5tja: UPPERCASE COMMANDS OR WHAT THEY ARE, are not pretty
18:40:53 <kc5tja> Are you *REALLY* sure you want me to do that?
18:41:00 <littledan> kc5tja, on yeah
18:41:06 <littledan> *oh yeah
18:41:08 <kc5tja> Saizan: Uppercase is for readability.
18:41:14 <kc5tja> Saizan: And, yes, it IS pretty.
18:41:23 <kc5tja> If *YOU* don't like using them, then don't.
18:41:26 <Saizan> i don't what to see unreadable forth :D
18:41:32 <Saizan> *wnat
18:41:37 <Saizan> oh wel..
18:41:42 <littledan> you just need to learn what each word means and then it's perfectly readable
18:42:20 <kc5tja> My convention is that any word defined by ANSI is uppercase, because ANSI prefers uppercase notation (for backward compatibility with case-sensitive Forth systems).
18:42:23 <sorear> kc5tja: without knowing the format of dictionaries, how do you redefine the compiler?
18:42:27 <kc5tja> My own local definitions are lowercase.
18:42:43 <kc5tja> DEFER spaceHandler
18:43:28 <littledan> someone who doesn't know what foldr means would find Haskell unreadable
18:43:29 <sorear> well, you can't assume an arbitrary forth system will let you   spaceHandler DEFER!
18:43:32 <kc5tja> : ]  BEGIN parse-word handleWord ( going to be a space here, guaranteed ) ['] spaceHandler whileWhiteSpace AGAIN ;
18:43:50 <kc5tja> : : placeHeader ] ;
18:44:17 <kc5tja> sorear: If it's an ANSI Forth, and it supports the core-ext words, it will have DEFER and IS.
18:44:22 <kc5tja> ' myHandler IS spaceHandler
18:44:45 <sorear> kc5tja: ANS forth doesn't have spaceHandler though :)
18:44:59 <kc5tja> 18:36 < littledan> kc5tja, really? redefine spaces for me!
18:45:05 <sorear> and I challenge you to write placeHeader portably.
18:45:11 <kc5tja> That's the point.  ANSI Forth doesn't have it.  I just added it.
18:45:18 <littledan> kc5tja, yeah, well once you mentioned redefining : I realized I was wrong
18:45:34 <sorear> I'm perfectly willing to believe it's possible to do this, if you can make environmental dependencies.
18:45:46 <littledan> but just because you can redefine the syntax doesn't mean it doesn't exist, I think
18:45:55 <sorear> I just don't recall reading about the building blocks needed to write your own :
18:46:12 <kc5tja> It takes more thought than I've given it here, but it is doable.  :noname would need to be overridden as well.
18:46:42 <kc5tja> So that: : placeHeader   create :noname , does> @ execute ;
18:46:55 <kc5tja> it's slower, but doable.
18:46:58 <LoganCapaldo> erm, but what can you usefully do with the ability to change the meaning of spaces? turn forth into a whitespace compiler?
18:47:15 <Saizan> littledan: i didn't say that forth is unreadable, i said that is ugly :) i was just flaming, however
18:47:29 <littledan> LoganCapaldo, it's a proof of concept showing Forth doesn't have a fixed syntax
18:47:39 <kc5tja> Saizan: You want unreadable?  Look at half the Haskell code out there that is needlessly written in pointless.
18:47:44 <kc5tja> THAT is unreadable.  :)
18:47:47 <kc5tja> And ugly, to boot.
18:48:09 <LoganCapaldo> if it becomes useless after you alter that mutable syntax, I would suggest maybe that the syntax is _fixed_, effectively
18:48:23 * Saizan writes in pointless quite happily
18:48:23 <kc5tja> LoganCapaldo: Why would it become useless?
18:48:44 <kc5tja> Saizan: Yes, and I'll spit your code back at you as being thoroughly unreadable.  I won't even invest the time.
18:49:02 <LoganCapaldo> kc5tja: see previous question. I'm willing to belief theres a use for changing the defn of whitespace, I'm just curious what it is :)
18:49:08 <Saizan> fine, you're just missing the point again :D
18:49:28 <kc5tja> Saizan: ... err ... OK.
18:50:16 <kc5tja> LoganCapaldo: There is a lot of things you can do in Forth that rarely has any applicable value.  But that doesn't change the fact that Forth _does_ allow you to do it _if_ you need to.
18:50:26 <kc5tja> Just because I cannot think of a use doesn't mean someone else can't.
18:50:53 <LoganCapaldo> kc5tja: Ok. But I think this particular example is extra extra extra hard to come up with a good use for
18:50:56 <sphynx> hm, I'm trying to get 'length' using folds
18:51:12 <sphynx> I've get something like this:
18:51:16 <sphynx> >  foldr (\_ y -> y + 1) 0 [1,7,4,9]
18:51:17 <lambdabot>  4
18:51:21 <kc5tja> LoganCapaldo: That's not the point!  The challenge was, "Can I do it?"  The answer: "Yes."  Nothing, absolutely nothing, was said about value added to a project.
18:51:26 <sorear> sphynx: yes!
18:51:47 <LoganCapaldo> kc5tja: _I_ said something about the value added to a project :)
18:51:55 <kc5tja> You didn't pose the challenge.
18:52:06 <dons> http://programming.reddit.com/info/1ny8w/comments
18:52:08 <lambdabot> Title: The Homeland Security Threat Level Monad (reddit.com)
18:52:08 <sphynx> @pl (\x y -> y +1)
18:52:09 <lambdabot> const (1 +)
18:52:17 <kc5tja> And we repeatedly said, "It has no real value; it's just to show you we can do it."
18:52:39 <sorear> LoganCapaldo: stop anthropomorphising _I_
18:52:44 <sphynx> by the way, what does 'const' keyword mean?
18:52:51 <kc5tja> constant
18:52:56 <sorear> LoganCapaldo: it's just a value in a cpo
18:53:00 <littledan> kc5tja, woudln't it be cool if there were a language with Forthish syntax and Haskellish semantics? I hope Cat ends up like that
18:53:36 <LoganCapaldo> sorear: cpo?
18:53:39 <sphynx> but what's difference between (1 +) and const (1 +)?
18:53:47 <kc5tja> Well, anything you can describe in applicative syntax, you can describe in reverse polish notation, though with some difficulty for collections of things.
18:53:54 <sorear> LoganCapaldo: continuous partial order
18:54:06 <sorear> LoganCapaldo: the field of math we get _|_ from
18:54:27 <LoganCapaldo> Ah, but that was an italic capital I, not _I_ :)
18:54:58 <mutjida> cpo generally stands for complete partial order
18:55:04 <sphynx> oh, I've got it, soory for stupid questions :)
18:55:06 <kc5tja> littledan: In fact, the language you'll end up with will look amazingly like Joy or Factor.  :)
18:55:33 <littledan> kc5tja, yeah, but with laziness and typeclasses; that's the gap
18:56:17 <mutjida> i think continuity is just assumed for most programming language semantics applications
18:56:18 <sorear> Haskell style is pretty much impossible to implement with anything other than a batch compiler.
18:56:44 <kc5tja> Ditto for Joy, actually.
18:57:02 <sorear> Forth is the epitome of nonbatch.
18:57:05 <kc5tja> To get it to be interactive, you'll need to structure it more like Postscript.
18:57:06 <monochrom> Yes, continuity is assumed. There is also proof that continuity = bounded nondeterminism.
18:58:27 <mutjida> i think conitnuity is necessary for fix points.
18:58:36 <littledan> Factor actually has what amounts to a batch compiler (though the interpreter is used fairly often)
18:58:53 <littledan> I think
18:59:28 <littledan> and, of course, you could redefine : to make a batch compiler in Forth!
18:59:31 <monochrom> continuity is sufficient, but not necessary.
18:59:52 <kc5tja> : is already a batch compiler.
18:59:57 <kc5tja> It just so happens that ; terminates it.  :)
19:00:03 <mutjida> how do you prove existence of fixed points without conitnuity?
19:00:19 <mutjida> i mean continuity
19:00:58 <monochrom> monotonicity is also sufficient.  tarski-knaster or something.
19:01:39 <mutjida> oh yes you're right. monotinicity is necessary. tarski's fixpoint theorem.
19:02:17 <kc5tja> GAWD, this is so monotonous!  ;D
19:02:21 <monochrom> If f is continuous, it is a bonus, because f^omega(_|_) is the least fixed point.  Without continuity, may have to replace omega by an even larger ordinal.
19:02:32 <kc5tja> (sorry, it was just begging to be said)
19:04:03 <littledan> where could i read about stuff like the theory behind fixed points?
19:04:32 <monochrom> I recommend Davey & Priestley "introduction to lattices and order".
19:04:51 <monochrom> You can also wait for me to write it up on haskell wiki and haskell wikibook. :)
19:05:05 <monochrom> Right now I'm writing a Parsec example instead.
19:05:21 <sorear> monochrom: even LARGER ordinals?  ouch!
19:05:58 <mutjida> wikipedia has some stuff, but perhaps not introductory. many graduate level programming language texts also cover it (e.g. pierce or mitchell)
19:06:28 <monochrom> I can make it sound very simple. I just don't have time to write it up.
19:06:31 <kc5tja> OK, back to my modeling.  I was hoping to have new code out by today, but I'm wasting too much time on IRC.
19:07:08 <mutjida> with just monotinicity, you can still construct a fixed point by starting with bottom.. right?
19:07:29 <sorear> mutjida: you'll never get close enough
19:07:31 <monochrom> Yeah, f^(huge ordinal here)(_|_).
19:07:57 <littledan> monochrom, thanks, Google Books apparently has that in full
19:08:15 <monochrom> W H A T ??!!!
19:09:03 <monochrom> N I C E !!!111
19:09:21 <littledan> there's no PDF, though
19:09:28 <littledan> (which would be better)
19:09:55 <littledan> also, I'm too stupid to understand it
19:10:12 <sorear> meh, google books needs javascript or something
19:10:33 <sorear> <img/> forever :(
19:11:26 <monochrom> It's very convenient if you have already bought and read the book but you left it at your ex's place and you're with a new guy/girl and you just want to look up one page for bragging rights on IRC.
19:12:06 <littledan> how do you brag about having read a book?
19:12:22 <mutjida> but if you start with _|_,  won't you'll eventually have to get to a fixpoint by monotinicity and completeness?
19:12:25 <sorear> littledan: not a book.
19:12:30 <kc5tja> Dude, *I* read SICP in two weeks flat.  Nyeeahh!
19:12:33 <sorear> littledan: the almighty TAPL
19:12:42 <monochrom> Not about reading the book.  About some argument over IRC and you want to appeal to authority by pointing at a page.
19:14:11 <littledan> kc5tja, yeah? well I read it in 30 minutes, while programming a solution to the halting problem
19:14:28 <kc5tja> littledan:  :(
19:14:29 <kc5tja> :)
19:17:06 <Korollary> Chuck Norris roundhouse-kicked SICP into Design Patterns in UML
19:19:38 <kc5tja> There are no failed computer projects; there are only projects Chuck Norris allows to market.
19:20:03 <SamB> ... what the heck?
19:20:16 <SamB> why are we talking about Chuck Norris in smartland?
19:21:15 <littledan> your mom and I talked about chuck norris LAST NIGHT
19:21:19 <littledan> </stupid>
19:22:25 <kc5tja> One of the signs of intelligence is the creature's capacity to play.  Geeks, _especially_, sometimes need to goof off a little.
19:23:46 <dolio> @yow
19:23:46 <lambdabot> I had pancake makeup for brunch!
19:23:57 <littledan> @yow
19:23:58 <lambdabot> Where's th' DAFFY DUCK EXHIBIT??
19:24:01 <monochrom> Let X = { (0,n) | n nonneg int } U { (1,0), (1,1) }.  Use lexicographical ordering on X.  This is a CPO.  _|_ is (0,0).  Let f (0,n) = (0,n+1), f(1,0) = (1,1), f (1,1) = (1,1).  f is monotonic but discontinuous.  f^omega(0,0) = (1,0) not fixed point.  f^(omega+1)(0,0) = (1,1) now this is the least fixed point.
19:24:42 * kc5tja never used to like Zippy -- but it's been growing on me.
19:25:15 <SamB> kc5tja: yes but chuck norris is not even a sign of intelligent life
19:27:32 <kc5tja> That's irrelavent, since Chuck isn't playing with his own concept.  Oh, never mind.
19:28:15 <mutjida> i see. i think perhaps my use of the word "construct" was wrong.
19:28:18 <wy> What type of grammar does Haskell have?
19:28:41 <dons> a strongly typed one :-)
19:28:53 <dons> ?where report
19:28:54 <lambdabot> http://www.haskell.org/onlinereport/
19:29:17 <dons> check page 13.
19:29:52 <wy> dons: I mean... such things as LL(1), LR, LALR...
19:30:35 <kc5tja> wy: It has the feel of an LR grammer, though I don't know if it's LR(inf) or LR(k), for some finite k.
19:31:35 <wy> kc5tja: I'm currently writing a parser. I wonder if I can write a parser for Haskell by hand...
19:32:08 <dons> "neither a pure top down LL
19:32:09 <dons> (1) nor a pure bottom up LALR(1) generator is sufficient to parse the standard grammar"
19:33:23 <dons> I think it would be hard to write a full haskell parser by hand.
19:33:58 <wy> dons: Is it from page 13 of the report? Which chapter?
19:34:20 <dons> no, from a adv. fun. programming course on writing parsers in haskell
19:35:02 <kc5tja> Personally, I'd never write a language that couldn't be parsed by a very simple grammer.  Even if the notation didn't match pure mathematics, I'm a fan of systemwide simplicity.
19:35:05 <wy> dons: It seems that its grammar is not so "standard"? So how did you finish your project?
19:36:18 <wy> kc5tja: Agree with you. Most of the students are confused at the beginning of a compiler class because of the automatas and grammars.
19:46:27 <mutjida> @users
19:46:27 <lambdabot> Maximum users seen in #haskell: 336, currently: 285 (84.8%), active: 31 (10.9%)
19:46:44 <wy> a long silence?
19:49:34 <kc5tja> Doing laundry, but also coding on my Forth project too.
19:51:49 <wy> kc5tja: Forth?
19:53:54 <kc5tja> Forth is an imperative, reverse polish notation programming language.
19:54:34 <wy> kc5tja: I heard that Postscript learnt something from it. Why do you do that?
19:54:50 <olsner> postscript is somewhat forth-ish, yeah
19:55:02 <kc5tja> Compared to writing compilers for other languages, Forth is substantially simpler.
19:55:40 <kc5tja> Forth has an interpreted and compiled mode of operation, and the runtime environment is trivially small.
19:56:03 <kc5tja> (Forth systems with a source code editor, assembler, and basic disk I/O have appeared for 8-bit platforms in as little as 8KB of space).
19:56:08 <olsner> IMO, the most important thing about forth is using RPN, which is dirt simple - something anyone could do after a couple of weeks of BASIC
19:56:29 <SamB> what is FPN?
19:56:34 <kc5tja> Indeed, it is RPN that allows Forth to be so simple.
19:57:08 <littledan> RPN is postfix, 2+3 => 2 3 +
19:57:09 <kc5tja> SamB: Reverse Polish Notation -- a notation of expressing mathematical operations without parentheses.
19:57:11 <wy> kc5tja: But it's not for human to read, is it?
19:57:24 <littledan> wy, of course it's for humans to read!
19:57:27 * kc5tja can read it almost more naturally than infix notation.
19:57:41 <wy> littledan: So what's Forth for?
19:57:47 <olsner> wy: yeah, humans write forth that way too :P
19:58:09 <littledan> wy, for programming. Forth in particular is good at systems programing while allowing a high degree of abstraction
19:58:36 <littledan> the great thing about using RPN is that everything can be point-free, in theory
19:58:43 <kc5tja> Forth, although an imperative languages, shares many qualities with FPLs.
19:58:43 <SamB> yeah, but what is Forward Polish Notation?
19:58:48 <wy> littledan: Why is there abstraction in Forth?
19:58:50 <kc5tja> SamB: Lisp.
19:58:52 <SamB> littledan: unfortunately it is lower-order
19:59:12 <kc5tja> SamB: Lower-order in what sense?
19:59:21 <Pseudonym> It's just Polish Notation, and it's obviously prefix rather than postfix.
19:59:44 <sorear> Forth has an extremely powerful type system and functional objects.
19:59:56 <sorear> The only feature forth really LACKS is GC.
20:00:06 <kc5tja> OK, now ThAT I disagree with.  :)  What type system are you thinking of?  ;)
20:00:16 <olsner> isn't that more an implementation issue than a language issue?
20:00:24 <Pseudonym> There is a Forth standard.
20:00:35 <olsner> I could very well see Haskell in RPN with GC and not be all that different
20:00:42 <sorear> kc5tja: Cells!  It can express every program that is well typed in the calculus of constructions.
20:00:50 <littledan> wy, because you can define words (functions) in Forth, and extend the parser
20:01:06 <sorear> it's extremely dangerous, but still powerful
20:01:18 <Pseudonym> XJ34 is the ANSI Forth committee.
20:01:18 <wy> littledan: But C also can do that
20:01:18 <sorear> don't forget about XTs
20:01:22 <kc5tja> Indeed, why is there abstraction in ANY language?  For the same reason -- to break big problems into managable chunks.
20:01:29 <Pseudonym> X3J14
20:02:21 <sorear> now THAT's line noise :p
20:02:22 <kc5tja> wy: Yeah, but what would you rather write for a project -- your own C compiler including its standard library, OR, 8K to 16K of pure run-time including editor, assembler, and basic I/O facilities, and maybe 200 bytes of language implementation?
20:02:39 <olsner> Pseudonym: thanks for giving us the facts that would never be given in any other channel than #haskell :P
20:02:53 <Pseudonym> Is there no #forth?
20:03:11 <kc5tja> There are several -- ##forth and #c4th-ot are the ones I hang in.
20:03:24 <olsner> c4th-ot?
20:03:25 <littledan> wy, C isn't as flexible. You can't extend the parser, and there's a stupid type system, and function inputs and outputs are more flexible
20:03:34 <wy> kc5tja: What I've learnt yesterday is that compilers are essentially translating in to RPNs
20:03:37 <littledan> s/more/less/
20:04:18 <olsner> wy: *some* compilers use RPN in the back-end, but there are many other representations
20:04:33 <sorear> Some compilers use RPN?
20:04:37 <Pseudonym> For my project, I'd rather write something Greenspun-compliant, obviously.
20:04:47 <kc5tja> wy: Modern compilers rarely compile into RPN.  However, no compiler to date has really been able to compile into Forth (a pity, because stack CPUs which execute Forth code _natively_ use 3 orders of magnitude fewer transistors than their RISC/CISC counterparts).
20:04:50 <sorear> Wow, I thought they all used higher level formats...
20:04:54 <Pseudonym> Ad hoc, informally-specified, bug-ridden slow Lisp.
20:05:16 <kc5tja> sorear: That's a recent phenomenon.
20:05:27 <olsner> ... but "compilers use RPN internally" might be a usable simplification to learn about compilers
20:05:30 <dons> wy, my project? the grammar is well specified, and you just use a parser generator with a preprocessor for layout
20:06:11 <wy> kc5tja: Amazing to hear that. There is a lot to learn from each language. I guess there will be some ultimate theory about them.
20:06:14 <sorear> A compiler is nothing more than an interpreter with support for dynamic generative specialization.
20:06:56 <olsner> indeed, but that's probably not how compilers are taught :P
20:07:29 <jfredett> which is unfortunate, because its probably a better way of teaching them.
20:07:45 <wy> sorear: I learnt that the G-machine code sequence is RPN.
20:08:01 <jfredett> once you can get it to the interpreter stage, getting the code generation part is easy-ish. IMO
20:08:13 <kc5tja> wy: Yup -- in fact, the G-machine is a dual-stack architecture, just like Forth specifies.
20:08:28 <kc5tja> (at least conceptually)
20:08:39 * littledan wonders if it's possible to have just one stack
20:08:47 <littledan> and be usable
20:09:00 <SamB> well, where do you store the arguments?
20:09:06 <wy> kc5tja: I think it has only one stack, and a heap.
20:09:13 <kc5tja> littledan: And have it still be Forth?  No.  But if you alter the language a bit (such that words return finite numbers of results and accept finite numbers of inputs), then yes.
20:09:46 <olsner> I'd like a compiler/interpreter hybrid for C++ - there's really a need for a) dirt-fast compilation for developers, and b) slow, static optimization for "the release"
20:10:10 <kc5tja> wy: According to SPJ's paper, it's dual stack, having an evaluation stack (which itself is also two stacks: one for pointers and one for non-pointers) and the CPU-supplied return stack for partial continuations.
20:10:23 <ddarius> And stack CPUs are slower than register based ones.
20:10:30 <kc5tja> ddarius: Like hell they are.
20:10:37 <kc5tja> ddarius: Where do you get that crack-pottery from?
20:10:47 <ddarius> @google RAFTS RISCs are faster than stack machines
20:10:51 <lambdabot> http://www.complang.tuwien.ac.at/papers/ertl&pirker96.ps.gz
20:10:59 <olsner> or are they just not as wide-spread and thus not subject to the same amount of attention?
20:11:11 <sorear> Give us both an ounce of silicon.
20:11:17 <kc5tja> RAFTS is a compiler for RISC platforms.
20:11:22 <sorear> You can have your 1k riscs.
20:11:33 <olsner> the less common way is bound to be less efficient
20:11:40 <sorear> I'll have 1M stack machines and outcompute you ten-to-one.
20:11:42 <kc5tja> Let's talk about, oh, F21 or M17.  Or PTSC 1000.
20:11:55 <wy> ddarius: but stacks can be implemented as windows in a pile of registers.
20:12:09 <kc5tja> One clock per instruction.  True, it's not superscalar, but the core is so small you can have tens of cores on the chip and still take less space than the register file of a RISC.
20:12:13 <sorear> registers are absolute nonsense.
20:12:44 <sorear> it's totally pointless to have all these signals drifting around and all this wasteful synchronization and routing
20:12:51 <littledan> kc5tja, an optimizing Forth compiler could make efficient use of a set of registers
20:13:13 <sorear> by my calculations a P4 makes 0.00000001% or so efficient use of silicon
20:13:15 <kc5tja> Yup.  The small size of the stack core allows it to be driven into the 10s of GHz, while modern CPUs are "only" at 2 to 3GHz mark.
20:13:27 <olsner> less is more, when it comes to silicon
20:13:30 <wy> kc5tja: Maybe what I'm working on is a siplification of G machine
20:13:49 <olsner> at least if you have some efficient way of modelling parallelism
20:13:57 <kc5tja> littledan: To some extent, yes.  I've done some think-tank work on this, and the results are promising.  But RAFTS already documents how to do it.
20:14:00 <sorear> someday I really ought to actually build the machine I've been designing
20:14:09 <kc5tja> Commercial Forth implementations are also performance competitive with optimized C, so they must already be doing it.
20:14:33 <sorear> I'm pretty sure I'll be able to reach P1 speeds - with discrete components - the secret - maximum pipelining
20:14:51 <kc5tja> The thing is, stack CPUs use no pipelining.
20:14:55 <sorear> keep every gate computing something every cycle
20:15:19 <RyanT5000> sorear: i'm pretty sure that's actually impossible
20:15:21 <SamB> sounds slow
20:15:34 <SamB> you mean *many* of the gates, I hope?
20:15:34 <kc5tja> That's also why stack CPUs kick the ever loving snot out of RISCs and even CISCs when it comes to embedded uses, because interrupt latency is, essentially, zero to five instruction cycles PERIOD.
20:16:01 <sorear> sure, it'll be impossible to compile from imperative languages
20:16:26 <ddarius> kc5tja: I see a very promising future for stack machines.
20:16:27 <sorear> even STG is probably too focused on the von neumann paradigm
20:16:44 <olsner> so, you're talking VLIW with a "sufficiently smart compiler"?
20:16:53 <sorear> we'll need another Augustsson for any of my brainstorming to be practical
20:16:55 <SamB> olsner: ... what?
20:16:58 <kc5tja> ddarius: See Intellsys' website.  They're working on an FPGA-like chip with 24 MISC cores on a chip, interconnected.  Intended for signal processing applications from what I can see.
20:17:33 <brad_> here's a silly question - why does haskell not have an elseif statement?
20:17:35 <sorear> olsner: My sufficiently smart compiler will be a human for now.
20:17:42 <sorear> ... else if ....
20:17:44 <Pseudonym> It doesn't have any statements,.
20:18:09 <brad_> sorry i mispoke Pseudonym
20:18:17 <Pseudonym> Actually, that's half the answer.
20:18:17 <SamB> Pseudonym: what do you call x <- foo?
20:18:20 <olsner> the "keep every gate computing something every cycle" idea relies on finding something for every gate to do, somewhat like what current VLIW architectures (e.g. Itanium) require of the compiler
20:18:23 <kc5tja> As far as superscalar is concerned, _I_ have some ideas on that front involving using multiple cores in synchrony.  Since superscalar allows multiple micro-threads of execution, I was going to devote one core per microthread and have a master micro-thread fork and join as appropriate.  But I need an FPGA get-up to test my hypothesis.
20:18:27 <SamB> or maybe I should say what do you call x = 1
20:18:33 <Pseudonym> SamB: x = 1 is a binding.
20:18:37 <Pseudonym> x <- foo is a generator
20:18:44 <brad_> oh - sorear, i was unqaware i could put them on one line like that
20:18:44 <wy> Pseudonym: A few days ago peole in ##java told there are no functions in Java ;-)
20:18:52 <SamB> how about let x = 1
20:18:57 <ddarius> kc5tja: Something along the lines of amorphous computing will come to pass, and in that situation low transistor counts and energy usage will be much more important than raw speed.
20:19:06 <brad_> any openbsd usres here?
20:19:10 <Pseudonym> SamB: A let-binding
20:19:11 <sorear> dons
20:19:21 <kc5tja> ddarius: Personally, I can't wait.  :)
20:19:30 * kc5tja abhores wasteful computing.
20:19:30 <brad_> i see dons is the maintainer for the ghc port, yet it is only 6.2.2
20:19:50 <brad_> surprised it is that outdated considering how productive he is!
20:19:56 <SamB> so is it wastefull for me to have a 1.7 GHz P4 instead of a 450 MHz PII?
20:20:02 <Pseudonym> Basically, if-then-else is like a function.
20:20:30 <Pseudonym> It doesn't have elsif partly because it's not obvious how that's a function.
20:20:31 <ddarius> wy: There are no functions in Jawa.
20:20:45 <SamB> if' True x y = x; if' False x y = y
20:20:47 <Pseudonym> But also because if you want something like that, there are always guards.
20:20:48 <kc5tja> SamB: For most of the things you do, quite likely yes.  CMOS transistors consume power on signal changes.  Since you're changing your clock state 3 times as fast as before, assuming the _same_ CPU, you're actually drawing 3x the power, to do the same things you were doing before.  Yes.  That's inefficient.
20:20:53 <wy> ddarius: only methods?
20:20:58 <ddarius> wy: Exactly.
20:21:05 <kc5tja> Compounded, modern CPUs actually have _MORE_ transistors than their predecessors.
20:21:07 <SamB> kc5tja: it isn't the same CPU
20:21:13 <SamB> and now I can also watch DVDs
20:21:17 <dons> brad_: I don't maintain it. Matthias Killain is currently updating the port to 6.6.1.
20:21:18 <SamB> and stuff
20:21:24 <ddarius> kc5tja: That's not surprising at all... (?)
20:21:28 <dons> brad_: you can just build ghc from haskell.org/ghc on openbsd though. go for it.
20:21:28 <sorear> OTOH, energy is ridiculously cheap.
20:21:31 <wy> ddarius: I mean these are just word games.
20:21:40 <sorear> and i do mean *ridiculously*
20:21:47 <ddarius> wy: Not necessarily.
20:21:49 <kc5tja> SamB: Yes, you "can" watch DVDs.  But unless you use that as your primary computer's function, then you're not using your box to its fullest potential.
20:22:05 <SamB> kc5tja: I'm pretty sure even then I'm not.
20:22:12 <SamB> but I think it compiles Haskell faster, too ;-P
20:22:15 <kc5tja> Possibly.
20:22:23 <wy> ddarius: I do think methods are functions.
20:22:37 <dons> for future reference, to create a statically linked xmonad, -optc-static -optl-static
20:22:39 <kc5tja> It's gotten so bad that chips now include logic to selectively shut down (as in POWER OFF) chunks of the chip so that it doesn't destroy itself with heat.
20:22:43 <brad_> dons : http://ports.openbsd.nu/lang/ghc
20:22:44 <lambdabot> Title: ports.OpenBSD.nu | The OpenBSD package collection
20:22:47 <ddarius> wy: functions are not attached to objects and do not support being overridden.
20:22:58 <brad_> not sure if that is definitive, says you are the maintainer
20:23:20 <wy> ddarius: They can be, as long as there are closures.
20:23:31 <kc5tja> There are research programs designed to measure "software versus power consumption," meaning how you write code impacts the power consumed by a processor.
20:23:37 <dons> it does say that. but i'm not the maintainer now. Kili is. he'll update the ports field when 6.6.1 comes out.
20:23:46 <brad_> dons - i am considering moving from freebsd to openbsd for no real real whatsoever (to be honest)...is this worthwhile?
20:23:56 <kc5tja> When you maintain thousands of servers (e.g., as Google does), inefficiencies can add up.
20:24:07 <kc5tja> (I do not know if Google has a R&D program on power management through code though.)
20:24:26 <ddarius> Morale of the story we should all be chipping in to some distributed computing effort.
20:24:41 <dons> brad_: it is a smaller cleaner system. otherwise, much the same.
20:24:49 <brad_> kc5 - the big users of colos also buy power direct from sources they choose
20:24:56 <ddarius> The computing cycles that go to waste all the time certainly could be used.
20:24:59 <kc5tja> ddarius: I'm down with that.  As long as its productive (folding@home, etc), I'm all for it.
20:25:11 <brad_> hmm, maybe i will give it a go dons, does it use ufs?
20:25:19 <kc5tja> brad_: I know, I used to work for Complex Drive Business Internet.
20:25:21 <ddarius> kc5tja: Yeah, I was part of one for cancer research some years ago.
20:25:40 <ddarius> kc5tja: The RSA challenge things, though, are pointless in my opinion.
20:26:04 <kc5tja> Agreed.  Let the NSA deal with those -- they've got the funds to pour into that on their own massively super-parallel supercomputers.
20:27:06 <sorear> It *appalls* me how inefficient general computers are.
20:27:29 <sorear> I'm really looking forward to the dynamic generative specialization^W^W^Wreconfigurable computing work.
20:27:33 <brad_> true sorear, but i blame the software that drives people to overbuy and overpower their systems
20:27:50 <brad_> i use a celeron with 256mb, runs faster than my wife's core2duo woth igb
20:27:52 <sorear> brad_: Even if you ignore all that
20:28:02 <kc5tja> After the Kestrel is done, I'm thinking of going with an all-FPGA successor that uses a multi-core stack architecture (for the R&D benefit) for its processor.
20:28:07 <brad_> i use freebsd, she uses vista
20:28:17 <kc5tja> FPGAs aren't known for power savings, but at least we can get useful science from the CPU.
20:28:19 <brad_> so much waste, all these people buying more than they need
20:28:30 <sorear> brad_: compare software MPEG on your 30A processor with hardware mpeg on a <1A ASIC.
20:28:30 <ddarius> brad_: An imaginary amount of memory! Impressive!
20:28:36 * olsner blames Vista for it all
20:28:52 <ddarius> Mmmm, ASIC.
20:28:59 <brad_> indeed ddarius!
20:29:03 <brad_> :)
20:29:25 <brad_> then again, i also run xmonad
20:29:36 <RyanT5000> what would it take for open cores to become remotely practical?
20:29:41 <brad_> so i am tuning for simplicity
20:29:54 <sorear> RyanT5000: Self-replicating nanoassemblers
20:29:54 <kc5tja> RyanT5000: Open-source FPGAs and open programming information.
20:29:58 <SamB> so, how do you use the imaginary part of your memory?
20:30:12 <kc5tja> Opencores.org is actually already quite practical.
20:30:14 <sorear> Actually what I want is nanobots transassembling my computer into whatever architecture best suits my current compute load :)
20:30:17 <brad_> samb - digg!
20:30:20 <RyanT5000> kc5tja: aren't FPGAs fairly expensive
20:30:28 <RyanT5000> ?
20:30:31 <kc5tja> RyanT5000: Depends on the size of the FPGA.
20:31:24 <kc5tja> Prices are coming down pretty significantly.  I can get an FPGA board, pre-populated with 32MB of SDRAM, a 9-bit VGA port, a parallel port, and a PS/2 port for keyboard or mouse for about $200, complete with a 1-million gate-equivalent FPGA and 2MB of Flash ROM.
20:32:20 <kc5tja> A good design will be able to use about 80% of the chip's resources so better bet more on 800,000 gates.
20:32:27 <RyanT5000> let's say i wanted a machine about as powerful as the one i have now (a 4-month-old P4 machine)
20:32:29 <kc5tja> Still, that is a long way from the 4000 to 8000 gates of yesteryear.
20:32:59 <RyanT5000> what's going to need to change before i can get the CPU for that for less than double the price of the P4 as a custom chip?
20:33:27 <RyanT5000> (i don't care about the chip technology, just the price)
20:33:39 <RyanT5000> clearly you can't use a whole wafer for one chip
20:33:49 <ddarius> sorear: Have you read "Designing Analog Chips"?
20:33:50 <RyanT5000> and i assume making the masks, etc., is really, really expensive
20:34:03 <kc5tja> Quite.
20:34:10 <sorear> I want to be able to get a reasonable (lets say ~100x the price per unit of intel's) fabricator for less than a year's salary.
20:34:18 <kc5tja> Intel's chips are mad expensive because of low yields, since as chip size increases, chances for defects increase.
20:35:06 <sorear> kc5tja: Obviously they should be using massively parallel stack machines with factory initialized working-subunit vectors.
20:35:14 <kc5tja> RyanT5000: However, I'm still left wondering about certain details.  Are you looking for something that runs at the same clock speed?  That's not going to happen, because the FPGA is a pre-wired arrangement of gates.
20:35:50 <kc5tja> sorear: My micro-threading processor design idea would be ideal to apply towards Haskell, I think.
20:36:12 <sorear> kc5tja: what is the (number_of_gates * virtual_clock_speed * outputs_per_gate) for your $200 FPGA?
20:36:27 <sorear> s/gate/virtual_gate/g
20:36:32 <RyanT5000> kc5tja: i don't care about details, really
20:36:44 <kc5tja> Remember, it's the _whole board_ for $200, not just the chip.  The cost of the chip itself would probably be somewhat less; I'm _guessing_ about $40 for the chip.
20:36:49 <RyanT5000> i'm thinking about this from a "when will society be able to make use of it"
20:36:52 <RyanT5000> perspective
20:37:11 <sorear> kc5tja: I'd just like a ballpack for "raw computational power"
20:37:53 <sorear> like for p4-type processes 100m * 4g * 1 = 4 * 10^17 boolean operations per second
20:38:02 <kc5tja> RyanT5000: To do what though?  What is the application?  People are already using FPGAs for custom processors (usually coprocessors, but still), but it's usually for purpose-specific applications.
20:38:02 <sorear> if it were perfectly efficient
20:38:30 <kc5tja> Well, I don't know what you mean by outputs_per_gate.
20:38:30 <sorear> now, how many actual boolean operations per second can you pull off the entire top500 combined?
20:38:43 <sorear> less than 1000 times that
20:38:54 <sorear> kc5tja: an and gate has one output
20:38:59 <kc5tja> Most logic blocks on an FPGA has two outputs (a true-logic and negative-logic output), with four to five inputs.
20:39:01 <sorear> kc5tja: a half adder has two
20:39:01 <RyanT5000> kc5tja: i want dell to be able to offer you a bunch of options on the chip itself
20:39:21 <sorear> I'll count that as '1'
20:39:29 <kc5tja> RyanT5000: Never gonna happen.  The CPU-as-ASIC will always outperform FPGAs.
20:39:49 <kc5tja> sorear: FPGAs use RAM look-up tables for their logic blocks.
20:39:55 <sorear> kc5tja: I know
20:40:10 <sorear> kc5tja: but virtually they are gates
20:40:27 <sorear> kc5tja: it simulates a large synchronous circuit, right?
20:40:41 <kc5tja> Yes.  The smaller the circuit, the faster it goes too.
20:40:42 <RyanT5000> kc5tja: really? in this industry, "never gonna happen" seems to usually mean it's 5 years out
20:41:05 <sorear> as I see it, GPCPU : FPGA : ASIC ~~ AST walker / bytecode interpreter / compiler
20:41:08 <RyanT5000> (and "it's 5 years out" usually means it's never gonna happen :P)
20:41:14 <sorear> i'd like a cheap compiler
20:41:34 <jfredett> Probably offtopic, But since the Ackermann function is not primitive recursive, and thereby requires a TM to compute, would writing an implementation of the Ackermann function in a language thereby imply that the Language is Turing Complete?
20:41:42 <sorear> jfredett: No.
20:41:46 <jfredett> damn
20:41:50 <kc5tja> RyanT5000: Positive -- you can't break the laws of physics.  The FPGA architecture is a mesh of AND/OR/INVERT logic blocks and RAM look-up-tables for complex logic.  CPUs are hardwired, with logically related parts placed next to each other (as space permits), to minimize propegation delays.
20:42:03 <RyanT5000> oh yeah i know that
20:42:08 <RyanT5000> i wasn't specificying fpga, though
20:42:19 <littledan> jfredett, imagine a language that only allowed you to do the ackermann function and write number literals
20:42:20 <RyanT5000> what if you could make a no-setup-cost ASIC factory?
20:42:28 <RyanT5000> i.e.: every wafer could be different
20:42:45 <sorear> kc5tja: how fast does your fpga clock, how many logic blocks do you have?
20:42:52 <sorear> or is that a trade secret :p
20:42:56 <jfredett> littledan, i see, that does cause problems.
20:43:17 <RyanT5000> then you'd just need to aggregate a couple hundred orders and make a custom wafer
20:43:25 <kc5tja> RyanT5000: OOHH...kind of what MOS Technology had with Commodore Electronics (since Commodore bought them out).  In that case, costs would be relatively cheap for the larger processes, getting more expensive for each progressive run.  Commodore was able to fab out chips at a rate of one spin  per two weeks.
20:43:25 <jfredett> littledan, that sucks. so necessary but not sufficient, meh...
20:43:47 <kc5tja> That's why VIC-20 blew away the competition in 1981, and the Commodore 64 sealed Commodore's fate as the reigning champion of the 8-bit world forever.
20:43:49 <SamB_XP> RyanT5000: aren't masks a bit expensive?
20:43:53 <littledan> if a language allows conditionals, recursion, and some sort of data, it's generally turing-complete, though
20:44:05 <SamB_XP> also what about misprints?
20:44:12 <sorear> SamB_XP: Masks are bits
20:44:14 <RyanT5000> SamB_XP: yeah, but my question was "what needs to happen before this is possible"
20:44:17 <sorear> SamB_XP: Bits are free
20:44:18 <kc5tja> sorear: Unknown -- it apparently can handle up to 100MHz though, since the main clock on the board is 100MHz.  I'm going to conservatively guess 50MHz for the CPU and on-board logic though (piping permitting).
20:44:23 <RyanT5000> not "how do we do it with today's technology"
20:44:39 <SamB_XP> well, some kind of digital projection for masks...
20:44:47 <RyanT5000> i just wanted to hear everyone's opinion on the near and mid future of chip fabrication technology
20:44:50 <SamB_XP> I guess...
20:45:06 <kc5tja> RyanT5000: More and more automation is definitely needed.  Cleanroom time needs to be minimized.
20:45:15 <RyanT5000> yeah
20:45:21 <kc5tja> Not sure how long it takes to dope though.  That may also be a factor.
20:45:35 <RyanT5000> hm
20:45:58 <sorear> ISTR having a book on the subject.
20:46:21 <RyanT5000> i always thought it'd be cool if you could submit a design for everything on the motherboard, and the motherboard wiring itself, and get the whole thing back as a working computer
20:46:23 <sorear> I definitely have a book on high vacuum technology, but I doubt that will go into too much detail :)
20:46:39 <kc5tja> RyanT5000: There are places that will do that . . . for a price.  :D
20:46:54 <RyanT5000> yeah, i mean for something similar to the price of a mass market computer :P
20:46:56 <kc5tja> Many PCB Fab places will also provide or contract out to parts-placement joints too.
20:47:00 <kc5tja> Ahh
20:47:06 <kc5tja> I keep forgetting those things.  :)
20:47:06 <RyanT5000> i think that's when open-source hardware will become a "real thing"
20:47:12 <jfredett> hmm, I guess i'll just have to try something else then, the issue I have is that the language in question is somewhat resilient against normal methods of TC proof, so I'm trying to figure up a easier way.
20:47:22 <kc5tja> Really, what we need to do is become a proper technocracy so that everything can be automated to hell and back.
20:47:33 <Adamant> technocracy?
20:47:42 <Adamant> like the political movement?
20:47:54 <kc5tja> Adamant: Quasi-political/mostly-technological movement, yes.
20:48:12 <Adamant> ah. those guys are nuts and don't even have a grip on basic economics.
20:48:13 <sorear> kc5tja: Mass production will always be cheaper, I accept that.  For the sake of arbitrary numbers - When can I have a 1-batch ASIC with Fixed_Costs <= 10 * Mass_produced_unit_cost
20:48:30 <kc5tja> Because until that happens, we'll have money.  And as long we have money, that's the biggest problem to seeing "easily attainable, fully customized" gizmos.
20:48:32 <sorear> where by 1-batch I mean batch of 1
20:48:38 <RyanT5000> sorear: certainly some cheaper, but how much?
20:48:52 <RyanT5000> what's the price diffential between a pressed CD and a burnt CD?
20:48:56 <RyanT5000> a factor of 5?
20:49:00 <sorear> RyanT5000: One of the many variables of life.
20:49:05 <kc5tja> Adamant: They made sense in 1930s.  And I've not seen any satisfactory counter-examples to their claims.
20:49:17 <littledan> I'm just wondering, how often do you guys talk about haskell in here?
20:49:17 <kc5tja> However, their failing was that they didn't keep up with the times.
20:49:20 <sorear> Nanotech will make the differential go way down, but won't destroy it.
20:49:25 <RyanT5000> if i could buy a 100% custom machine for 2x as much, i probably would
20:49:30 <kc5tja> They kept crying, "The sky will be falling!!" instead.
20:49:43 <sorear> littledan: We're either OT or quiet about 103.2% of the time
20:50:06 <kc5tja> However, it's interesting to note that as time goes on, we become more and more like a technocracy every day.  Massive automation, destructive technologies, etc.
20:50:19 * kc5tja was going to write an article on just how much of the "Star Trek" universe that everyone yearns for is _already here_.
20:50:36 <RyanT5000> especially when you consider the fact that i could get only the features i want, so it'd probably be somewhat less than 2x
20:51:00 <sorear> hehe.
20:51:10 <olsner> kc5tja: write that article, get it slashdotted, and make me read it tomorrow ;-)
20:51:30 <RyanT5000> another example: what's the difference between a laser-printed page and a mass-produced page?
20:51:39 * olsner is away for as much shuteye he can get
20:51:47 <RyanT5000> certainly something, but certainly nothing like the difference between a gudenberg-press page and a handwritten page
20:51:51 <sorear> kc5tja: when the history channel did the "How William Shatner Changed the World" program my first reaction was "They misspelled Shockley!"
20:52:09 <kc5tja> olsner: I don't do the slashdot thing.
20:52:45 <kc5tja> Well, the only thing that I hope _won't_ become true from the Star Trek world is the decided lack of basic fuses.  :)
20:52:53 <Adamant> kc5tja, they try to replace money with energy credits. which in the end, are subject to economic laws unless coercive force is applied to prevent it.
20:53:05 <kc5tja> Adamant: negative.
20:53:22 <kc5tja> How can you apply economic laws on something that is non-transferrable and non-storable by definition?
20:53:23 <Adamant> kc5tja, why do economic laws not apply to energy credits?
20:53:34 <kc5tja> Adamant: Because energy credits _aren't_ money.
20:53:45 <sorear> My room is filled with stable condensed energy.
20:53:51 <Adamant> they are a means to get a good or service, correct?
20:53:51 <kc5tja> ECs are allotments of energy used by production capacity, assigned to an individual.
20:53:58 <sorear> And I can give it to people at will.
20:54:09 <kc5tja> Adamant: Yes.
20:54:17 <Adamant> then they are, in the end, money.
20:54:32 <ddarius> Money isn't particularly relevant to economics.
20:54:33 <kc5tja> Adamant: But, you cannot save it in banks, you cannto collect interest on it, you cannot give it to someone else, you cannot ... need I go on?
20:54:39 <Adamant> you can try to impose a hierachical system that prevents them from being used as money.
20:54:54 <Adamant> why can't you? who prevents it?
20:55:08 <Adamant> I would feel free to trade them.
20:55:10 <kc5tja> Adamant: You obviously haven't read their literature very well -- because it clearly states this in no uncertain terms in their basic text.  I'm not going to repeat the contents here.
20:55:15 <littledan> in the US we already have a system where the government coerces people to not use anything other than dollars as money
20:55:19 <kc5tja> Who prevents it?  The technocracy.
20:55:28 <Adamant> with what?
20:55:47 <kc5tja> I don't understand the question.  How can I delete a file if I have no command to delete a file?
20:56:04 <kc5tja> How can I transfer ECs to someone else if there is no infrastructure to support that operation?
20:56:16 <kc5tja> This is really, really basic stuff.
20:56:32 <kc5tja> And until you understand that, you just can't understand the precepts of technocracy.
20:56:34 <sorear> littledan: Barter is illegal?  I never noticed!
20:56:36 <Adamant> how are the EC's allocated in the first place? obviously, they can be given.
20:56:47 <kc5tja> Barter isn't illegal.  You just can't do it with ECs.
20:56:48 <Adamant> they are allocated by a state.
20:57:04 <kc5tja> Adamant: You have so many factories in the technate, right?
20:57:06 <littledan> sorear, not barter, but alternative currency systems are often harassed or banned by the government
20:57:08 <Adamant> you can use EC to produce things?
20:57:14 <Adamant> then you can trade those.
20:57:14 <sorear> littledan: I'm well aware of the impracticality of it .. O(n) prices vs O(n^2) exchange rates
20:57:21 <kc5tja> Adamant: NO!
20:57:27 <kc5tja> You use energy to produce something.
20:57:35 <Pseudonym> BBS
20:57:38 <kc5tja> The amount of energy that goes into production is tallied.
20:57:46 <kc5tja> That tally is divided amongst everyone in the technate evenly.
20:58:09 <kc5tja> So if I use 100W to make a Frobnicator, and there are 1000 people in the technate (say), then my producing a Frobnicator contributes 0.1W to everyone's EC pool.
20:58:19 <sorear> AAAAAH!
20:58:37 <Adamant> who controls the Frobnicator?
20:58:38 <sorear> Pet peeve of the day: people using W as a unit of energy.
20:58:47 <kc5tja> Adamant: Irrelavent question.
20:58:55 <sorear> Watts are *power*!
20:59:17 <Adamant> it takes a lot of energy to make a diamond, right? let's say people can make diamonds.
20:59:21 <kc5tja> sorear: for the purposes of this discussion it's immaterial, but whatever.  I meant J.
20:59:23 <wchogg> sorear:  I figure people are just used to thinking of their energy usage in kWh.
20:59:26 <Adamant> already happening now.
20:59:37 <Adamant> it takes less energy to make bread.
20:59:46 <Adamant> which is worth more?
20:59:48 <ddarius> kWh is energy
21:00:25 <Adamant> if you're starving, the bread is.
21:00:26 <kc5tja> Adamant: Food is obviously a critical requirement.
21:00:27 <sorear> Hm.
21:00:42 <sorear> @google 2 watts + 2 watts
21:00:43 <Adamant> right, but the person who produced the diamond added more EC's
21:00:44 <lambdabot> (2 watts) + (2 watts) = 4 watts
21:00:52 <kc5tja> Yup!
21:00:53 <sorear> @google 2 kilowatt hours + 2 watts
21:00:55 <lambdabot> http://en.wikipedia.org/wiki/Watt-hour
21:00:55 <lambdabot> Title: Watt-hour - Wikipedia, the free encyclopedia
21:00:57 <kc5tja> he sure did.
21:01:00 <Adamant> but did he actually add anything of value to the community?
21:01:07 <sorear> aww, I wanted to see "Type error"
21:01:10 <kc5tja> Who cares?
21:01:19 <kc5tja> Value is HIGHLY subjective.
21:01:25 <kc5tja> You economist types need to learn this.
21:01:29 <kc5tja> You cannot objectify value.
21:01:37 <ddarius> kc5tja: They know this.
21:01:40 <kc5tja> What is valuable to YOU may not be valuable to me.
21:01:52 <merus> Economist types are pretty damn smart.
21:02:05 <littledan> kc5tja, economists know that
21:02:11 <kc5tja> merus: I didn't imply that they were dumb -- but they need to open their minds a bit, I think.
21:02:18 <kc5tja> Heh, they could have fooled me.
21:02:19 <sorear> I'm in first semester high school econ and I knew this - entirely from class books
21:02:21 <Adamant> why do we care about EC's?
21:02:31 <jfredett> I wonder if google could handle unit dimensional analysis, like  x kw/hr * y hr
21:02:32 <Adamant> then?
21:02:33 <jfredett> hmm
21:02:36 <Adamant> why have such a system?
21:02:46 <sorear> @google 2 watts * 3 seconds
21:02:47 <lambdabot> (2 watts) * 3 seconds = 6 joules
21:02:54 <kc5tja> Because it allows you to account for who or what is using the most energy and to optimize accordingly.  Money CANNOT do this.
21:02:57 <Adamant> it doesn't help to allocate production any better, it seems.
21:02:58 <jfredett> kickass
21:03:03 <kc5tja> it's like profiling.
21:03:10 <littledan> sorear, you're in high school?
21:03:14 <kc5tja> You can't optimize your code unless you know where all your time (energy) is being spent.
21:03:16 <sorear> littledan: yes.
21:03:19 <littledan> me too!
21:03:21 <cdsmith> @seen kpreid
21:03:22 <jfredett> @google 2 kilowatt-hours * 3 hours
21:03:22 <lambdabot> kpreid is in #haskell. I last heard kpreid speak 3h 44m 26s ago.
21:03:24 <lambdabot> http://www.cga-ontario.org/secure/students/reprints/ma2/ma2s05.pdf
21:03:39 <Adamant> energy is already spent in the production of goods and services and factored into the prices
21:03:40 <jfredett> lol, I guess its not perfect.
21:03:58 <kc5tja> Adamant: But it's not an accurate reflection.
21:04:03 <kc5tja> I pay almost $4/gal of gas.
21:04:13 <kc5tja> THERE IS A REFINERY JUST DOWN THE FREEWAY FROM HERE.
21:04:17 <littledan> @seen lambdabot
21:04:17 <lambdabot> Yes, I'm here. I'm in #xmonad, #haskell, #parrot, #scannedinavian, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-soc, #haskell.dut, #haskell.hac07, #haskell-overflow
21:04:17 <lambdabot> and #haskell-blah
21:04:18 <Pseudonym> ?google 1 gallon in litres
21:04:19 <lambdabot> 1 US gallon = 3.7854118 litres
21:04:23 <merus> ECs wouldn't be an accurate reflection, either.
21:04:24 <kc5tja> But my parents pay only $2/gal back in NYS.
21:04:28 <sorear> kc5tja: Obviously you value being at your destination more than you value $4
21:04:32 <kc5tja> They have to have gas SHIPPED to them.
21:04:37 <kc5tja> So where's the disconnect?
21:04:43 <Adamant> kc5tja, you are in Canada?
21:04:43 <Pseudonym> > 4 / 3.7854118
21:04:45 <lambdabot>  1.0566882049662338
21:04:51 <kc5tja> Adamant: Mountain View, California.
21:04:54 <kc5tja> sorear: I bike mostly.
21:04:54 <Adamant> ah.
21:05:14 <sorear> Strange.
21:05:30 <Pseudonym> $2 / galllon is very cheap.
21:05:33 <Pseudonym> On the world stage.
21:05:37 <sorear> The day we have this huge economy debate - the professional economist isn't here :)
21:05:38 <Pseudonym> $4 is on par.
21:05:39 <merus> $4/gal is very cheap
21:05:41 <kc5tja> Pseudonym: We've always been super cheap.
21:05:42 <sorear> @seen syntaxfree
21:05:42 <lambdabot> I saw syntaxfree leaving #haskell 21h 43m 4s ago, and .
21:05:55 <Pseudonym> It's cheap compared to some places, sure.
21:06:04 <Pseudonym> But it's on par with Singapore refining prices.
21:06:10 <Adamant> the thing is though, I don't see what EC's get you. Energy prices are already factored in to market prices. you then replace market prices with EC's that do not help you allocate production any more efficently.
21:06:11 <kc5tja> Nonetheless, my point stands.  How is it cheaper to pay for gas in NY state than it is here, when we have refineries _right_ in our own back yards?  It doesn't make sense.
21:06:30 <Adamant> because there are refineries elsewhere
21:06:33 <Adamant> and gas lines
21:06:35 <dino-> http://money.cnn.com/pf/features/lists/global_gasprices/price.html
21:06:38 <lambdabot> Title: CNN/Money: Gas prices around the world, http://tinyurl.com/2y5n2
21:06:39 <merus> kc5tja, just because the reasons are hidden doesn't mean they don't exist.
21:06:40 <kc5tja> Adamant: We're going to just agree to disagree.  I'm not going to get involved with this further.
21:06:41 <littledan> kc5tja, because there are extra taxes and regulations in NYS
21:06:44 <cdsmith> @seen sjanssen
21:06:45 <lambdabot> sjanssen is in #xmonad, #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard sjanssen speak 3h 43m 41s ago.
21:06:55 <sorear> kc5tja: Let's just return to the whole technocracy concept.
21:06:56 <kc5tja> littledan: More taxes == CHEAPER?
21:07:15 <littledan> oh, well it's more expensive then neighboring states
21:07:23 <littledan> there are less taxes here than in other countries, though
21:07:33 <kc5tja> Non sequitor.
21:07:34 <sorear> kc5tja: If proletariat production of capital goods is cheap and easy, competition will increase --> cheaper gas
21:07:49 <Pseudonym> The worst thing about Australia is we pay sales tax on the fuel excise.
21:07:59 <Pseudonym> I think it's highly immoral to charge tax on a tax.
21:08:02 <littledan> and there are probably more taxes and regulations in CA than NYS, which is why gas costs more there
21:08:02 <Adamant> the biggest problem with refineries is they aren't letting them build any more.
21:08:05 <kc5tja> What I was asking was, if energy is factored into the price, then why is it $4 here, where transport costs are negligable, while it's half the cost in New York, where transport costs are _hardly_ negligable?  There's a skewment of the price.
21:08:06 <merus> Highly immoral?
21:08:25 <Adamant> I agree with Pseudonym.
21:08:37 <Pseudonym> merus: The moral equivalent of attacking a ship.
21:08:43 <merus> What?
21:08:43 <Pseudonym> As RMS would say.
21:08:45 <Adamant> it's like how they got Al Capone... you have to pay taxes on ill-gotten gains?
21:08:57 <monochrom> It is a good time to limit supply or something.  It is a good rehearsal for things to come in 20 years.
21:09:10 * sorear wonders how long he'll last in america now that he has spontaneously used "proletariat"
21:09:11 <littledan> of all the unfair things about the tax structure, that one seems really trivial
21:09:17 <Pseudonym> Apparently on US tax forms they actually have a question about bribes and such, precisely so nobody could claim they didn't know to pay tax on them.
21:09:23 <Pseudonym> On some of them, anyway.
21:09:26 <Pseudonym> Is that rumour true?
21:09:35 <Adamant> haven't seen it myself.
21:09:39 * littledan reports sorear to the House Committee for Un-American Activities
21:09:46 <ddarius> kc5tja: Because energy costs are not the only factor.
21:09:51 <Pseudonym> THe idea being, not only do get get you for taking bribes etc, they get you for not paying tax on them too.
21:09:53 <kc5tja> Pseudonym: I've never seen that question, but there is a field for "Other Income."
21:09:59 <Pseudonym> Right.
21:10:04 <sorear> Isn't it the House Un-American Activities Commission?
21:10:04 <Pseudonym> It might depend on the form.
21:10:11 * sorear has heard the acronym HUAC
21:10:11 <littledan> sorear, probably
21:10:12 <ddarius> Pseudonym: I haven't seen anything like that.
21:10:13 <kc5tja> ddarius: Precisely my point.  The price is skewed because of greed (for the most part).
21:10:16 <merus> I'm still lost on how paying sales tax on an excise tax is highly immoral
21:10:19 * Pseudonym nods
21:10:23 * Pseudonym will check snopes later
21:10:36 <Adamant> the price is skewed because of limited refinery supply and increased summer demand
21:10:36 <kc5tja> merus: Double-dipping.
21:10:46 <Pseudonym> That's right.
21:10:50 <kc5tja> merus: You're paying a tax on money that is already alloted for tax purposes.
21:11:00 <Adamant> the enviromentalists and "not in my backyard"'ers are preventing new refineries from being built.
21:11:06 <littledan> there's nothing fair about taxes in the first place. why is this more unfair? It's just a way of organizing the taking of money
21:11:08 <sorear> Now, I've had enough whining about human vice for today :)  /me -> type theory
21:11:15 <littledan> (not that taxes aren't justified)
21:11:25 <Pseudonym> Modern Western tax systems generally go to a lot of trouble to avoid money being taxed twice.
21:11:39 <littledan> ok, so that's an exception. So what?
21:11:41 <ddarius> Incidentally, re economists knowing value is subjective: Section "Social Welfare and the Arrow Impossibility Theorem" on http://www.daviddfriedman.com/Academic/Price_Theory/PThy_Chapter_15/PThy_Chap_15.html
21:11:43 <lambdabot> Title: David Friedman, _Price Theory: An Intermediate Text, Ch 15, http://tinyurl.com/2ojcnc
21:11:45 <kc5tja> A tax, by definition, is money paid relative to something you receive.
21:11:59 <Pseudonym> ?dict tax
21:11:59 <kc5tja> If there ever was a tax on a tax, you should get cash BACK, not pay more.
21:11:59 <lambdabot> Supported dictionary-lookup commands:
21:12:00 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
21:12:00 <lambdabot> Use "dict-help [cmd...]" for more.
21:12:03 <Pseudonym> ?wn tax
21:12:06 <lambdabot> *** "tax" wn "WordNet (r) 2.0"
21:12:06 <lambdabot> tax
21:12:06 <lambdabot>      n : charge against a citizen's person or property or activity
21:12:06 <lambdabot>          for the support of government [syn: {taxation}, {revenue
21:12:06 <lambdabot>          enhancement}]
21:12:08 <lambdabot> [8 @more lines]
21:12:42 <littledan> ok...
21:12:47 <littledan> so
21:12:47 <littledan> ?
21:13:02 <sorear> kc5tja: In the US some taxes, such as sales tax, are transfered to the payer as the rule rather than the exception.
21:13:38 <kc5tja> littledan: If the government is receiving a tax on another tax of its own creation, then by the strictest definition of the word "tax", the original money is its property.  Ergo, the government should be paying taxes _back_ to the tax payer.
21:13:56 <merus> Yeah, that doesn't make much sense either.
21:14:09 <kc5tja> Pseudonym: We get double-dipped here too -- we pay sales tax, and income tax is paid both upon paycheck receipt and on April 15th.
21:14:15 <Pseudonym> Right.
21:14:22 <littledan> the definition has nothing to do with what the government should be doing
21:14:29 <Adamant> Social Security tax is paid from the paycheck
21:14:35 <Pseudonym> Although, technically speaking, if you saved instead of spending, you wouldn't be double dipped.
21:14:36 <Adamant> IIRC
21:14:43 <littledan> the government is charging you based on your activity. Your activity is causing you to be taxed, and the government is charging you based on that
21:14:59 <kc5tja> Pseudonym: Nope -- you get taxed when you withdraw your money too.
21:15:16 <kc5tja> littledan: No.
21:15:25 <Pseudonym> I don't know how it works there, but in Australia, businesses get tax credits for sales tax that they pay, if they then charge it to their customers.
21:15:34 <Pseudonym> So money going through the system only gets taxed once.
21:15:45 <kc5tja> The _GOVERNMENT_ is placing a TAX on some franchise, and then is TAXING ITS OWN TAX.  Do you not see the mutual recursion here?  Caps for emphasis, not yelling.
21:16:03 <littledan> whatever
21:16:18 <Pseudonym> Yeah.  The problem here is not the tax on whatever you're buying or doing.
21:16:18 <Adamant> kc5tja, we see, but the problem is in the end, governments want money
21:16:31 <kc5tja> Yup.
21:16:48 <merus> kc5tja, it's functionally equivalent to them charging two taxes. From a consequentialist point of view, it's not highly immoral or whatever.
21:16:53 <Adamant> and it doesn't really matter what the letter of the law or a definition is, they'll just redefine
21:17:05 <kc5tja> But if the government is taxing its own property, then IT should be paying out the taxes (it's _already_ its property!), not the reverse.  That's why the double-dipping is so stupid.
21:17:12 <Pseudonym> It's equivalent to them doing that at a higher tax rate.
21:17:20 <Pseudonym> So it's a stealth tax.
21:17:31 <merus> Whatever you mean by that.
21:17:53 <Pseudonym> Although, if it's the state imposing one tax and the federal government imposing the other...
21:17:57 <Pseudonym> But that's another topic.
21:18:00 <kc5tja> I have no probem paying 50% of my income to taxes provided (a) I know what the money is being used for, (b) I can vote on future budgeting, (c) the tax is _flat_.  I don't want these complicated rules anymore.
21:18:11 <Pseudonym> merus: What I mean by that is that you set a statutory sales tax at, say, 10%.
21:18:24 <Pseudonym> Taxing the tax effectively makes the tax rate, I dunno, 12% or something.
21:18:31 <merus> If you don't understand composition of percentages, I guess it's a stealth tax.
21:19:01 <Pseudonym> So they're effectively charging a 12% sales tax when the law says 10%.
21:19:08 <Pseudonym> I'm making up the figures, of course.
21:19:14 <merus> No, the law says 10% after the application of whatever other tax.
21:19:36 <Pseudonym> I'm not sure what the law actually says on this point, of course.
21:20:05 <merus> Then maybe you shouldn't claim to the contrary?
21:20:22 <Pseudonym> I know that the fuel excise has sales tax charged on it.
21:20:32 <Pseudonym> That's all I'm claiming.  I'm not claiming any exact figures.
21:20:53 <merus> You claimed it was a stealth tax, again, whatever that means.
21:21:16 <Pseudonym> Yes.  It's a way of charging higher than 10% sales tax.
21:21:42 <Pseudonym> I don't think you should be charged tax for the tax that you pay.  That's all.
21:21:55 <kc5tja> It's like when you realize C lacks an until() construct, so you just #define it away in some obscure header file.  ;D
21:21:55 <merus> It's a pointless difference.
21:23:53 <kc5tja> Awesome, I got involved with a really complex discussion on really complex matters, and I never blew my cool.  I _MUST_ be getting to be an old fart.
21:25:29 <littledan> kc5tja, but you failed to argue a coherent decision
21:25:35 <littledan> s/decision/position/
21:25:42 <littledan> how did I make that mistake?
21:26:06 <kc5tja> Yes I did.
21:26:43 <kc5tja> If you think it's incoherent, that sounds like a personal problem.  But my arguments were cogent.  You may not have agreed with them, and that's fine.
21:26:52 <littledan> ok
21:29:50 * kc5tja shrugs -- if I were so incoherent, responses like "ok" and "whatever" wouldn't be offered.  But I digress.  I'm not trying to slander anyone, and I'm certainly not intending on offending.  But it's clear someone is.  It sure ain't me.
21:30:17 <Adamant> it's cool. lets talk Haskell.
21:30:36 <Adamant> I just got one of the Simon's pdfs on type theory.
21:31:50 <Shimei> Adamant: Cool. I'm reading a Hudak paper on functional reactive programming. Yay robots. :)
21:32:37 <littledan> kc5tja, it's incoherent because you're relying on logical fallacies like deriving a moral argument from a dictionary definition
21:32:55 <littledan> (I keep not deciding whether I want to pursue this, that's why I keep saying OK)
21:33:11 <littledan> and you're pulling ideas about fairness out of nowhere
21:33:33 <littledan> sorry, don't be mad at me
21:34:26 <dons> wow guys. maybe take this to #haskell-blah?
21:34:35 <littledan> oops, sorry, I'll stop
21:34:55 * merus has been neglecting his blog :/
21:35:08 <dons> merus: have you written something today?
21:35:29 <merus> dons, I haven't written anything in more than a week.
21:35:33 <merus> Stupid senior essays
21:35:46 <merus> in stupid fields of mathematics totally unrelated to Haskell.
21:35:51 <ray> i have a channel?
21:36:17 <Pseudonym> What part of mathematics could possibly be totally unrelated to Haskell?
21:36:49 <cdsmith> Yay, I fixed a bug in lambdabot's unpl. :)
21:36:58 <merus> cdsmith, yay!
21:37:02 <merus> cdsmith++
21:37:18 <dons> cdsmith: sweet!
21:37:50 <cdsmith> @unpl (flip $ (flip take) . (map toUpper)) -- this now works on my local system
21:37:51 <lambdabot> (\ i c -> take (map toUpper i) c)
21:38:40 <NichardRixon> what should it be?
21:39:03 <ddarius> ?type take
21:39:05 <lambdabot> forall a. Int -> [a] -> [a]
21:39:07 <cdsmith> (\ b c -> take b (map toUpper c))
21:39:27 <dons> cdsmith: patch and send?
21:39:37 <cdsmith> I don't know how to do that.
21:39:44 <ddarius> merus: Which fields of mathematics?
21:40:05 <dons> cdsmith: ah ok. darcs whatsnew -s
21:40:09 <dons> darcs record ModifiedFiled.hs
21:40:17 <dons> darcs send -o /tmp/cool.patch
21:40:22 <dons> mail me /tmp/cool.patch
21:40:44 <merus> non-standard analysis, model theory, that sort of thing.
21:40:52 <cdsmith> dons: These are commands to type?
21:41:05 <dons> cdsmith: yeah, 'darcs whatsnew -s' to see your changes
21:41:12 <dons> or 'darcs whatsnew' to get the full list
21:41:16 <NichardRixon> cdsmith, all except the last one
21:41:25 <NichardRixon> I doubt `mail me` would go through
21:41:26 <dons> then 'darcs record File.hs' to record a new patch of your changes to File.hs
21:41:46 <dons> then 'darcs send -o /tmp/foo.patch' to create a patch file to mail to me
21:41:55 <cdsmith> Hmm... Apparently I have to figure out how to get darcs to recognize a new file.
21:42:02 <dons> darcs add Foo.hs
21:42:09 <dons> so you have created a new plugin?
21:42:15 <dons> or just modified the existing pl plugin?
21:42:27 <dons> darcs whatsnew -sl
21:42:30 <cdsmith> A new file in Lib/.  Modified the existing Pointful.hs to use it
21:42:31 <dons> will hunt for new files as well
21:42:39 <dons> ok. nice.
21:42:49 <dons> darcs add Lib/KoolThing.hs
21:42:59 <dons> then it will show up in 'whatsnew'
21:43:09 <cdsmith> So how to I tell darcs to ignore changes to ./State/system and ./testsuite/logpp?
21:43:34 <dons> either darcs record Foo.hs BAr.hs -- i.e. give it a list of just the changed files you care about
21:43:40 <dons> or press 'n' to the hunks that touch those files
21:43:47 <cdsmith> okay, cool
21:43:48 <dons> or, 3, darcs revert State/system
21:43:50 <dons> first.
21:44:16 <dons> yay. new contributors! new darcs users! :-)
21:44:29 * dons boings like a shapr
21:44:42 * merus is concerned for dons' mental health.
21:44:56 <dons> come on ... patches!
21:44:59 <dons> :D
21:45:11 <dons> also, i'm going on holidays, so in a good mood :-)
21:45:14 * kc5tja cuts up some old t-shirts and throws them dons' way.
21:45:35 <Pseudonym> Dammit, if dons goes on holidays, Haskell development will grind to a halt.
21:46:01 <dons> oh, i should get a hwn out before i go. thanks for reminding me.
21:46:22 <kc5tja> hwn?
21:46:29 <dons> ?google hwn
21:46:31 <lambdabot> http://www.hwn.org/
21:46:31 <dons> let's see..
21:46:31 <lambdabot> Title: The Hurricane Watch Net
21:46:36 <kc5tja> Ahhh.
21:46:37 <dons> grr oh well
21:46:53 <dons> ?google haskell weekly news
21:46:54 <Pseudonym> Time to start link bombing.
21:46:58 <lambdabot> http://sequence.complete.org/hwn
21:46:58 <kc5tja> Well, that's probably a good idea too, even if it wasn't what you intended.  :)
21:46:58 <lambdabot> Title: Haskell Weekly News | The Haskell Sequence
21:46:58 <dons> yeah.
21:47:26 * kc5tja should set up his ham radio -- still in the box.
21:49:27 <cdsmith> dons: what should I do with the patch file now?
21:49:44 <sjanssen> cdsmith: you @seen'ed?
21:50:08 <cdsmith> sjanssen: yeah, you said to bug you when I got the precedence thing working.
21:50:40 <sjanssen> cdsmith++ for fixing bugs nobody else wanted to fix :)
21:51:00 <sjanssen> cdsmith: so you've plugged it in to unpl?
21:51:13 <cdsmith> sjanssen: it's not entirely working; it works as long as you don't use let expressions or infix operators in pattern matching.
21:51:21 <cdsmith> sjanssen: yes, that was no problem.
21:51:25 <sjanssen> cdsmith: what about undo?
21:51:28 <dons> cdsmith: mail it to me :-)
21:51:38 <cdsmith> sjanssen: no undo yet.  Where would I make that change?
21:51:49 <sjanssen> Plugins/Undo.hs
21:52:11 <cdsmith> dons: oops, I just realized I left in an error for something I didn't get to.  I'll still send it if you like, but you shouldn't apply it.
21:56:20 <dons> cdsmith: thanks. ok.
21:56:23 <sorear> cdsmith: while you're motivated...
21:56:29 <sorear> @pl \fix -> let a = 2 in a
21:56:30 <lambdabot> ($ const 2)
21:56:36 <sorear> @. type pl \fix -> let a = 2 in a
21:56:37 <dons> sjanssen: you applying the QC patches ?
21:56:39 <lambdabot> forall b t b1. (Num t) => ((b1 -> t) -> b) -> b
21:56:45 <sorear> @type \fix -> let a = 2 in a
21:56:48 <lambdabot> forall t t1. (Num t1) => t -> t1
21:57:12 <sorear> Introducing a lambda binding named 'fix' makes @pl go boom.
21:57:38 <sorear>  @pl renames all OTHER identifiers:
21:57:46 <sorear> @pl \const x -> 2
21:57:47 <lambdabot> const (const 2)
21:58:22 <sorear> so all you need to do is perform alpharenaming before dep-analysis.
21:59:31 <sjanssen> dons: yeah, I will in a moment
21:59:43 <cdsmith> sorear: Hmm... I'll look at it, perhaps.
22:00:45 <dons> sjanssen: yeah, droundy's spotted an issue with the StackSet Arbitrary instance.
22:00:54 <dons> sjanssen: focus is always left on the master window in the generated stack sets
22:01:11 <dons> so we don't test the delete/insert property
22:01:15 <cdsmith> sjanssen: okay, I think I see where the entry point for undo and redo are...  I will change them.
22:01:52 * sorear goes back to kestrel interactive ml
22:04:07 <sorear> suprisingly cvs-ghc@ is one of the most active haskell lists out there.
22:04:23 <sjanssen> makes sense
22:04:42 <sorear> main topic of discussion - Galois' buildbot complaining that SyntaxNinja forgot to install perl.
22:04:55 <sorear> how did he ever managed to do that
22:04:56 <dons> heh
22:04:58 <sjanssen> at least one email per patch of an actively developed compiler
22:04:59 <dons> new machine.
22:05:21 <sjanssen> yeah, Perl is a dep of practically everything
22:05:25 <sjanssen> including GHC!
22:05:29 <sorear> dons: on debian, perl is classified with the same importance rank as kernel-image
22:05:35 <sorear> dons: and libc6
22:06:00 <sorear> well, perl-base anyway (a minimal package)
22:07:19 <sorear> sjanssen: Perl is required for -fasm too now, since they've started rewriting parts of the GHC build system in it.
22:07:44 <sorear> not the makefiles, just the big shell scripts
22:08:46 <sjanssen> sorear: just a build dependency?
22:08:58 <cdsmith> sjanssen: you have a broken test case for operator precedence in undo or redo?
22:09:13 <sorear> sjanssen: yeah
22:09:14 <sjanssen> ah, but of course it's required for a buildbot :)
22:09:26 <sorear> sjanssen: and there's the EM too
22:09:34 <sjanssen> cdsmith: hmm
22:10:33 <sorear> for a long time they've been saying the EM will die, and your choices will be GhcUnregisterised=YES or -fasm.  I wonder when this will happen.
22:12:55 * sjanssen wishes Cabal had -j support while building lambdabot
22:13:27 <cdsmith> @undo do { f $ x >>= y }
22:13:28 <lambdabot> f $ x >>= y
22:13:48 <cdsmith> @redo f $ x >>= y
22:13:48 <lambdabot> do { a <- f $ x; y a}
22:13:55 * sorear wishes he had more things to -j onto
22:14:21 <sorear> can't exactly run GHC on my IDE controller :)
22:15:44 <sjanssen> cdsmith: @redo \f g h -> f >>= g . h -- is broken
22:16:05 <cdsmith> @redo \f g h -> f >>= g . h
22:16:05 <lambdabot> \ f g h -> do { a <- f; g a} . h
22:16:19 <sjanssen> @undo do {f $ x; y}
22:16:20 <lambdabot> f $ x >> y
22:16:33 <sjanssen> cdsmith: ^^^ is your other broken test
22:16:57 <cdsmith> lambdabot> redo \f g h -> f >>= g . h
22:16:57 <cdsmith> \ f g h -> do { a <- f; g . h a}
22:17:30 <sjanssen> ah, that's my bug (I think)
22:17:30 <cdsmith> sjanssen: I don't know the right answer.  Is that right?
22:17:56 <sjanssen> it's close.  If you send the patches to dons, I think I can fix it
22:18:23 <cdsmith> sjanssen: but my patches break other things at the moment. :(
22:18:26 <sorear> Hmm.  I think I see how to combine SystemFw's functional polymorphism and GHC's logical polymorphism in one type system.
22:19:44 <cdsmith> lambdabot> unpl \ (x:xs) -> x -- I broke this
22:19:44 <cdsmith> Plugin `pointful' failed with: IRCRaised Prelude.undefined
22:20:31 <ddarius> Have a functional logic language at the type level?
22:21:48 <sorear> ddarius: I'm abusing terminology pretty heavily.
22:22:05 <sorear> ddarius: in sys-fw polymorphism works using functions
22:22:09 <ddarius> The "f1ow of data"?  How the heck did that happen.
22:22:13 <sorear> [a : *] ...
22:22:28 <sorear> ddarius: in GHC polymorphism works using logic variables
22:23:11 <sorear> ddarius: OCR
22:23:31 <cdsmith> It is late and my brain is fried.  I think I'll try to clean things up and send a working patch in the morning.
22:23:31 <sorear> I assume you are reading a paper :)
22:23:36 <ddarius> That's what I would think, but it definitely isn't that.
22:23:40 <cdsmith> Thanks very much for everyone's help!
22:24:03 <sorear> > fromEnum 'l' `xor` fromEnum '1'
22:24:05 <lambdabot>  93
22:24:48 * sorear has experienced single bit corruption
22:24:49 <ddarius> Nevermind.  It has been OCRed.
22:25:28 <ddarius> Of course, I could still wonder how it happened, by wondering why there isn't a post-processing pass to fix obvious errors such as this one.
22:36:48 <ddarius> "the newest traditional languages"
22:48:16 <ddarius> Oh the joys of mutable state.
22:49:59 <dons> where f x == f x isn't true :-)
22:50:44 <mauke> > let x = x; f _ = 0./0. in f x == f x
22:50:45 <lambdabot>  Parse error
22:50:55 <dons> close.
22:50:57 <mauke> > let x = x; f _ = 0.0/0.0 in f x == f x
22:50:59 <lambdabot>  False
22:51:02 <dons> hehe
22:51:26 <dons> ?check \f x -> let _ = f :: Int -> Int ; in    f x == f  x
22:51:28 <lambdabot>  OK, passed 500 tests.
22:51:41 <dons> ?check \f x -> let _ = f :: Double -> Double ; in    f x == f  x
22:51:42 <lambdabot>  Exception: Prelude.(!!): negative index
22:51:50 <dons> oh, cute.
22:52:04 <mauke> wtf
22:52:08 <sorear> dons: f x == f x can be made true, we just need to change the meaning of == on stateful actions.
22:52:17 <dons> yeah. f x y == f x y
22:52:49 <sorear> > arbitrary
22:52:51 <lambdabot>   Not in scope: `arbitrary'
22:53:15 <mauke> OCaml: x == x && not (x = x)
22:54:49 <dons> sorear: read the operational semantics of monadic code in awkward squad?
22:55:02 * monochrom finishes the monumental http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements :)
22:55:05 <lambdabot> Title: Parsing expressions and statements - HaskellWiki, http://tinyurl.com/2g23lg
22:55:16 <dons> that's one of the best introductory presentatoins on reasoning about side effecting code, imo.
22:55:40 <monochrom> operational semantics makes baby monochrom cry!
22:55:42 <dons> and also makes it clear just why side-effects-by-default are so hard to reason about
22:56:27 <monochrom> At that level you use bisimulation instead of equality.
22:56:29 * dons subscribes to the school of "complexity of formal specification corresponds to difficulty of human grokking of said code"
22:57:51 <monochrom> Yes. Mutation and interaction have never been easy. Conventional wisdom just hides it under the rug.
22:59:56 <dons> computer science/engineering is so immature as a discipline.
23:00:22 <dons> did I say "discipline"? maybe that's the problem. mwhaha cult of the lambda! you will be controlled!
23:01:00 <monochrom> It is still searching for a self-image.
23:02:20 <sorear> I'm still fond of whats-his-name's tetrapartite graph on p.h.o
23:05:38 <ddarius> sorear can't just say four-part
23:12:10 <sjanssen_> @localtime sjanssen
23:13:44 <sorear>  /whois + whois --> Virginia (3:12 am)
23:13:51 <sorear> but you probably knew that :)
23:14:16 <sorear> (or maybe that's the global rr hq.)
23:15:56 <sjanssen_> my box kernel panicked :(
23:16:53 <sorear> Ouch.
23:17:37 <sorear> Only type of kernel panic I've ever had was a can't-find-init from an improperly prepped bootdisk.
23:18:21 <dons> habanero$ uptime
23:18:22 <dons>  4:17PM  up 126 days
23:18:45 <sorear> After 2 years of bad ram, a hard drive that failed badly enough to "cannot load shared libraries: cannot open /lib/libc.so.6: Input/output error", spilling a full glass of water on the ventilation system, ...
23:18:52 <dons> :-) i can't remember the last panic since I switched to bsd. there were some a long long time ago, but its been years.
23:19:00 <sjanssen> dons: yeah, I was at about 120
23:19:17 <dons> sjanssen: Int overflow? ;)
23:20:13 <sorear> is habanero your main dev box?
23:21:31 <dons> nah, gfs desktop/firewall
23:21:43 <dons> main dev box is a laptop, $ uptime
23:21:44 <dons>  4:19PM  up 15 days
23:21:59 <dons> on battery power :-)
23:22:43 <sorear> gfs lexes as possessive form of GF?
23:22:52 <dons> it does.
23:23:27 * sjanssen parsed it as g-something file system
23:23:36 * sjanssen needs to get out more :)
23:23:44 <monochrom> girlfriend file system
23:23:54 * sorear initially parsed it as google/gmail file system
23:23:59 <monochrom> keeps your money safe and secure
23:24:06 <sjanssen> mount -t girlfriend
23:24:12 <dons> oh dear.
23:26:02 <ddarius> "I've heard guys with 10 MB hard disks complain of feeling cramped."
23:30:41 <dmead> sup losers
23:30:43 <dmead> ?losers
23:30:44 <lambdabot> Maximum users seen in #haskell: 336, currently: 279 (83.0%), active: 19 (6.8%)
23:30:47 <dmead> hot
23:30:55 <dons> btw, everyone should use the phase 'Haskell programming' in their blog posts..
23:31:00 <DRMacIver> Morning
23:31:12 <DRMacIver> dons: Hm, why?
23:31:24 <dons> since this is the search   term TIOBE uses when it queries google to work out hte most popular and growing languages
23:31:34 <DRMacIver> Ah
23:31:35 <dons> currently, 42k hits for the phrase "haskell programming"
23:31:58 <dons> ~52 for "programming haskell"
23:32:05 * DRMacIver normally just uses "haskell"
23:32:06 <dons> > 42 / 52
23:32:07 <lambdabot>  0.8076923076923077
23:32:18 <dons> so we'd jump 20% in popularity if they searched the other way around
23:32:46 <dons> hehe, so I changed my title, http://cgi.cse.unsw.edu.au/~dons/blog
23:32:46 <lambdabot> Title: Haskell hacking
23:32:49 <DRMacIver> ITYM 24%.
23:33:11 <DRMacIver> > 52 / 42
23:33:12 <lambdabot>  1.2380952380952381
23:33:24 <dons> so just need to seed the blogosphere with the secret phrase :-)
23:33:31 <dmead> today
23:33:34 <dons> that phase is Haskell programming Mr. Google.
23:33:36 <dmead> haskell blogging
23:33:37 <dmead> tomorrow
23:33:39 <dmead> THE WORLD
23:33:46 <sorear> dons: but why do you want to drop your hitcount 1000x? :)
23:34:08 <sorear> erm, that wasn't funny, I'm just tired...
23:34:15 <dons> ah good, we have 'Haskell programming' in the topic here too
23:34:24 <Lemmih>  -h
23:34:30 * DRMacIver doesn't actually blog about Haskell much anyway.
23:34:41 * sorear doesn't blog.  He probably ought to.
23:35:08 <DRMacIver> I just use it as an opportunity to brain dump really.
23:35:44 * ddarius doesn't blog.  He probably ought not to.
23:36:53 * Cale doesn't blog just because he hates the word 'blog'.
23:37:29 <dons> its an ugly word.
23:38:05 * DRMacIver doesn't mind it
23:45:48 <DRMacIver> Haskell has corrupted me. I keep looking for opportunities to be lazy in other languages. :)
23:46:32 <DRMacIver> (I just got very annoyed when I found out that some methods in the Scala standard library are strict where they should clearly be lazy)
23:53:44 <Cale> DRMacIver: See? I keep telling everyone who uses strict languages that lazy-optional sort of defeats the purpose of laziness because you'll be stuck in a language with strict library functions.
23:54:40 <DRMacIver> Well, that's an issue of using a strict language with optional laziness and bad library design. :)
23:54:50 <jfredett> I tell you, I just started messing around with haskell, and I really really with I'd learned it a long time ago.
23:54:58 <jfredett> Laziness is wonderful.
23:55:04 <arcatan> just say blagh
23:55:09 <gmh33> Lazy and Strict have their places :/
23:55:19 <DRMacIver> But this is somewhere where laziness is almost easier to introduce than to make it strict - it's for dealing with iterators.
23:55:30 <DRMacIver> Basically the map and filter functions on Iterables are strict in Scala.
23:55:35 <Cale> DRMacIver: It's just that when laziness is optional, people get lazy and don't use it.
23:55:37 <DRMacIver> Which is awful. :-/
23:55:47 <DRMacIver> Cale: Heh. I suppose.
23:56:21 <Shimei> Cale: "Blog" doesn't bug me as much as "blogosphere".
23:56:22 <ariks> you mean when laziness isn't default. it's just as option for us too.
23:56:31 <Shimei> Makes me think of a swamp-planet like Dagobah.
23:56:32 <jfredett> gmh33, I agree, but Lazy eval is so liberating, I can't tell you the number of times I've written code I wish I didn't have to run through Curry functions.
23:56:49 <ddarius> Most programmers, being unfamiliar with (and usually completely ignorant of) laziness, never even think to apply it in the first place.
23:57:11 <Cale> Shimei: haha, yeah
23:57:24 <ddarius> "blog" "bog"
23:57:31 <Cale> Also, the fact that a 'blog' is nothing more than a poorly-organised website.
23:57:32 <DRMacIver> Honestly, most of the time I still want strict evaluation. It's just that I want laziness to be easily available when I need it. :)
23:57:56 <Cale> Well, at least it's organised somehow, I suppose I've seen worse.
23:58:27 <DRMacIver> Mmph. Partial application is another thing I miss.
23:58:37 <Cale> DRMacIver: oh yeah :)
23:58:47 <jfredett> ddarius, I tend to agree, I think programmers tend not to be in the correct mindset for laziness. However, I've noticed that Mathematicians (such as I) tend to grasp it far better, to the point where I've been the only one capable of explaining it to my CS friends.
23:58:58 <Cale> jfredett: hehe, yeah
23:59:03 <DRMacIver> Although that's not Haskell specific. If I try hard enough (and I sometimes do) I can write code which does partial application in Java. :)
23:59:12 <DRMacIver> It's just nice to be able to do it easily.
23:59:17 <Cale> jfredett: I was like, "this is great, it's exactly how I think"
23:59:56 <Cale> jfredett: Though I still ran into one thing which lazy evaluation couldn't evaluate. product [1,1..]
