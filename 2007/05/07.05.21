00:00:02 <slava> is there a fixed number of optimizer passes in ghc?
00:00:12 <slava> factor's optimizer loops until it reaches a fixed point. this can be inefficient
00:00:16 <dons> no, it repeats until fixpoint for ome things
00:00:20 <slava> heh
00:00:43 <dons> if you use lots of tricky rewrite rules, you can significantly increase compile times
00:00:52 <slava> i know! its terrible
00:01:10 <monochrom> It's fantastic.
00:01:27 <slava> i've found that optimizing compile time is harder than optimizing the generated code
00:01:48 <monochrom> haha
00:02:58 <slava> i found that a word to compute the MD5 checksum took 20 seconds to compile, which is longer than it takes to compute the MD5 checksum of some inputs. so, run time > compile time.
00:03:03 <slava> does this ever happen with haskell? :)
00:03:12 <slava> err, compile time > run time.
00:03:17 <sjanssen> http://hpaste.org/1926#a1 -- much shorter when I remove the memoization cleverness
00:03:33 <slava> if i change : to MEMO:, i get memoized words
00:03:38 <dons> slava: yeah, plenty of times.
00:03:52 <dons> our binary serialisation lib uses some wacky rewrite rules to lift bounds checks out of inner loops
00:04:05 <dons> this basically extends the optimiser, and uses massive inlining
00:04:14 <dons> the result is huge compile time, for tiny runtime
00:04:17 <monochrom> main = return ()   is already longer to compile than run.
00:04:21 <slava> i remember in java once, i had a case where using binary serialization was slower than my own parser/printer for a text format
00:04:56 <slava> dons: my compiler inlines all words which takes quotations as input
00:05:27 <dons> the Data.Binary lib goes to great lengths (with inlining) to ensure aligned, unchecked sequences of writes, but it takes a lot of compiler thinking to get there. fun :-)
00:05:29 <sjanssen> slava: how exactly does that work?  Can't a word potentially touch/modify the entire stack?
00:05:32 <slava> i guess some ML compilers do this too
00:05:41 <slava> inline agressively to elimineate closure consing
00:06:11 <slava> sjanssen: stack effects can be inferred, in the same way that haskell type checks point-free expressions
00:07:04 <dons> oh you mean, how it infers variables from point free code
00:07:12 <dons> ?unpl flip map . map flip
00:07:13 <lambdabot> (\ i c -> map c (map (\ d e f -> d f e) i))
00:07:15 <slava> no, how it infers the function type
00:07:35 <dons> ah ic.
00:07:43 <slava> think about it, the stack effect is just the type of the function, if you consider each stack word as a map from tuples to tuples
00:07:49 <dons> yeah.
00:07:55 <slava> where a tuple represents the stack
00:08:50 <dons> yeah, i'd imagine there's a pretty reasonable type system you can give to a stack language
00:08:59 <slava> there's a language 'cat'
00:09:07 <dons> it'd be fairly simple, i'd think (?), the type system.
00:09:08 <slava> it's statically typed, stack-based, and targets the Microsoft CLR.
00:09:19 <dons> yep.
00:09:21 <edwardk> don: there are a few of them out there
00:09:50 <dons> so why doesn't slava retro fit one :P
00:09:59 <dons> actually, what kind of bugs are most common in factor code, slava ?
00:10:26 <dons> does untype stack manipulation lead to mixing up arguments to functions ? like , an untyped 'flip' would in haskell.
00:10:27 <edwardk> http://ttic.uchicago.edu/~amal/papers/stack-logic.pdf leaps to mind as i recall
00:11:16 <slava> type errors occur frequently when i'm prototyping code, but i rarely find type errors in code that has been in place for a while. most are logic errors
00:12:09 <slava> the thing that annoys me the most rght now is that if you remove a definition from a file, and reload it, the definition is not removed from the dictionary
00:12:27 <slava> so files modify the environment, they don't roll back what hte previous version did first
00:12:50 <dons> how are complex data structures defined?
00:12:53 <slava> this leads to mistakes because as i move words between vocabularies, sometimes i end up calling the wrong version
00:13:03 <slava> and eventually, i have to restart factor
00:13:08 <slava> to clean things up
00:13:41 <slava> dons: i think you should ask further questions in #concatenative
00:13:43 <slava> its offtopic here ;)
00:13:57 <dons> heh. its #haskell, we like language design and impl. :-)
00:14:03 <slava> ok.
00:14:17 <slava> data structures are built from tuples, which are records with named slots
00:14:29 <dons> right, that's what I was imagining.
00:14:32 <slava> and a tuple can delegate to another tuple, in which case all unhandled methods are passed to the delegate. the delegate cna be changed at run time
00:14:49 <slava> slot readers and writers are implemented as methods too, so they're passed on to the delegate.
00:15:03 <kaol> and don't haskellers make domain specific languages on the fly?
00:15:12 <edwardk> i just read far enough back to find the link you put up, factor is some form of forth?
00:15:17 <slava> delegation is really ad-hoc. you have to be careful
00:15:27 <dons> so you have products data types, and things built up from them, and I presume slots can be recursive, so you've got say, recursive lists fairly naturally ?
00:15:29 <slava> but its implementation as part of an object system is literally 10 lines of code.
00:15:37 <slava> compare with the logic that CLOS requires to, eg, handle multiple inheritance.
00:16:04 <dons> how would you implement a sum type, data T = A Char | B Int ?
00:16:07 <slava> dons: sure. in addition to tuples, you have sequences and hashtables
00:16:11 <dons> tags in pairs?
00:16:12 <slava> dons: sum types are not expressed in the language
00:16:32 <aleator> Hello, anyone seen: "internal error: interpretBCO: unknown or unimplemented opcode 34448 (GHC version 6.6 for i386_unknown_linux)"
00:16:41 <dons> oh, built in hashtables, with runtime support?
00:16:55 <dons> aleator: i think that's a ghci bug fixed in the head (maybe even 6.6.1)
00:17:00 <slava> a hashtable is really a tuple with some slots, one of them being a big array
00:17:08 <slava> but it makes no sense to think of it as a tuple, in this sense
00:17:10 <aleator> dons: Ok, cool, thanks.
00:17:46 <slava> dons: i used to have cons cells with runtime support. 8 bytes per cons cell on x86
00:17:56 <slava> the gc was designed to not require a header for cons cells
00:18:08 <slava> does ghc do that? you need to do tricks tagging
00:19:03 <dons> I don't know of any special support for the list cons cells, other than possible unboxing of strict element types.
00:19:14 <dons> there's probably some tricks in there i don't know about though.
00:19:26 <dons> small lists of Int and Char are packed as strict unboxed arrays, iirc.
00:19:31 <dons> [1,2,3,4] :: [Int]
00:19:57 <dons> string literals aren't [Char], as well.
00:20:51 <slava> over the period of about two years, i gradually migrated from using cons cells for essentially everything, to the point where the cons cell type moved to the optional library
00:21:09 <slava> i found arrays worked better with the stack
00:21:21 <slava> and the sort of operations which were cheap on arrays were easy to express
00:21:42 <slava> so i guess not many languages use arrays, but treat them as immutable 90% of the time
00:23:51 <slava> dons: ByteStrings take advantage of fusion optimization right?
00:24:59 <dons> yeah.
00:25:22 <dons> can be a big win, actually.
00:25:34 <dons> more so than for list fusion (since lazy list cells are fairly cheap to allocate)
00:25:44 <slava> the way i see it, compiler optimizations allow me to write more generic code.
00:26:06 <dons> yeah. you can work at a higher level, and the the compiler sort out the optimal version
00:26:15 <dons> fusion in particular encourages a high level combinator style of coding
00:26:22 <slava> yes!
00:26:22 <dons> foldr . map . filter . unfoldr
00:26:29 <dons> will compile much better than manual recursive loops
00:26:47 <dons> so you lose if you try to prematurely think about how to optimise it :-)
00:28:18 <dons> slava: in particular, domain specific optimisations, you wouldn't add to a compiler, but would ship with a library, let you stay on the DSL level
00:28:37 <slava> well, i think having a generally extensible compiler is still a research problem
00:28:41 <dons> so ghc's rewrite rules get used for, e.g. , fusion on bytestring. something you wouldn't hard code into the library.
00:28:41 <slava> generally, optimizations are not composable
00:28:45 <dons> yeah.
00:28:48 <dons> definitely
00:28:52 <slava> rewrite rules are one thing
00:29:00 <slava> allowing arbitrary operations on the compiler's internal IR(s) is another
00:29:02 <dons> a lot of work on the fusion stuff has been talking to SPJ about which things to rerun after which phase
00:29:24 <dons> right. LLVM takes one approach , where you plugin optimisations, and specify what runs before and after.
00:29:28 <dons> but its all a bit hairy
00:29:47 <pejo> dons, does he make an educated guess about what to rerun, or do you do an exhaustive search for the order?
00:30:02 <dons> pejo: there's some specific things we expect to need to clean up.
00:30:05 <pejo> Well, he, or you. Both of you I guess. :-)
00:30:18 <dons> so no exhaustive searches.
00:30:42 <dons> heuristics. actually , for fusing inner loops of concatMaps we needed to sit in a loop switching between two optimisations
00:30:49 <dons> that was a custom hack for the list fusion paper.
00:31:28 <slava> dons: i found 5 lines of code which produces a 1578-line prettyprinted compiler IR
00:32:02 <dozer> is it possible to put theorems/proofs in haskell code, and get it validated against your functions?
00:32:52 <dons> dozer: using Isabelle, yes. but not in ghc directly :-)
00:33:06 <dons> its ongoing research to provide arbitrary static checking
00:33:30 <dons> oh, unless you "put" your theorem in terms of a type
00:33:37 <dons> in which case the type checker will check it.
00:33:39 <dozer> oh? does isabelle include some sort of haskell syntax? I've only used it with FOL and lambda
00:33:43 <dons> doing any interesting theorems this way will be hard.
00:33:46 <slava> haskell is too weakly typed for this :)
00:33:53 <dons> dozer: no, people tend to translate haskell to isabelle, first.
00:33:54 <quicksilver> or, unless by 'theorem' you mean property and you're happy with QC/SC as a 'proof'
00:34:08 <quicksilver> in which case, yes, use QC or SC :)
00:34:25 <dozer> well, start with simple things like proving that a qucksort that takes a list and returns a list, does in fract return a sorted list
00:34:28 <dons> yeah, QuickCheck is the #1 tool used in practice to provide extended checking
00:34:35 <dons> its like theorem proving on a skinny skinny diet.
00:34:52 <dons> dozer: ok, getting a true proof of that is rather non trivial
00:35:00 <dons> specifying it as a QC property is easy though
00:35:52 <dons> ?check \xs ->  head (sort xs) == minimum xs
00:35:53 <lambdabot>  Add a type signature
00:35:58 <dons> ?check \xs ->  head (sort xs) == minimum (xs :: [Int])
00:36:00 <lambdabot>  Exception: Prelude.head: empty list
00:36:09 <dons> ?check \xs -> not (null xs) ==> head (sort xs) == minimum (xs :: [Int])
00:36:10 <lambdabot>  OK, passed 500 tests.
00:36:13 <dons> ?scheck \xs -> not (null xs) ==> head (sort xs) == minimum (xs :: [Int])
00:36:15 <lambdabot>   Completed 25059 test(s) without failure.  But 1 did not meet ==> condition.
00:36:27 <dons> dozer: is that the kind of checking you were thining of?
00:36:32 <slava> isn't fialure to meet a condition a failure?
00:36:51 <dozer> dons: that's good enough for unit testing
00:37:06 <dons> slava: well, it means something (in this case []) didn't pass the precondition. not always failure
00:37:14 <dons> in QC2 we use more sophisticated generators to avoid this, actually
00:37:26 <dons> you say,  \(x :: NonEmptyList Int) -> ...
00:37:42 <dons> dozer: right, its a generalisation of unit testing to arbitrary parameters.
00:37:43 <dozer> dons: I was hoping for something where I had my code, it's spec and a proof it meets the spec in a single file
00:37:55 <dons> theorem proving for programs is hard. :-)
00:38:02 <dons> how much time / money do you want to spend
00:38:02 <quicksilver> ?check \xs -> all (/= GT) (zipWith compare (sort xs) (tail . sort $ (xs :: [Int])) )
00:38:04 <lambdabot>  OK, passed 500 tests.
00:38:09 <dons> the QC properties can go in the src file
00:38:09 <quicksilver> a much better specification :)
00:38:22 <dons> quicksilver: heh. good. but it doesn't use mapAccumL !
00:38:28 <dozer> dons: I realise :) I've done a bunch in isabelle for part of a hardware compiler
00:38:53 <dons> dozer: ah ok. well, there's no standard tool, there's research tools.
00:39:01 <dons> so depends on what you're looking for.
00:39:14 <dons> actually, i think Agda lets you put theorems to check in src directly
00:39:47 <quicksilver> microsoft have some pretty clever model checking stuff
00:43:29 <dozer> yeah, ms seems to be getting very keen about proof-carrying code
00:44:58 <dons> dozer: if you find out any nice tools, do let us know.
00:45:04 <dons> i'm keen for more practical checking.
00:45:26 <dozer> dons: will do
00:51:24 <osfameron> matthew-_: yes, sometimes beer helps you think!  (sadly, this is by no means a universal rule)
00:51:31 <fuzan> Hey -- Vty question. I've never quite used a ncurses/vty package. if i wanted to build a sort of irssi-like input, what would the general procedure look like? (get vertical height, draw text for all but two lines, then draw status/input lines? )
00:52:32 <fuzan> or maybe a text image and an input image, and then compose both?
00:52:41 <osfameron> related vty question - how do you install vty on debuntu?  (not the haskell package, the actual Linux thingy)
00:52:43 <dons> fuzan: maybe have a look at hmp3?
00:52:49 <dons> you basically generate a [String] to draw
00:52:54 <dons> them map drawLine or similar over them.
00:53:11 <osfameron> that's the next missing link in trying to install yi - "vty" doesn't appear in the ubuntu repos for edgy
00:53:31 <fuzan> dons: i'll take a look, thanks.
00:54:13 <dons> osfameron: it'd be on hackage.
00:54:48 <fuzan> dons: is there any compatibility between bytestring types?
00:55:52 <fuzan> dons: ie, for something that requires a ByteString.Char8, would there be any simpler way to get it to accept an Lazy.Char8 other than to use String as a middleman ?
00:56:05 <osfameron> dons: oh!  I'm a numpty, you're quite right.  For some reason I was convinced "vty" was an OS package rather than a haskell one. Sorry to bother you.
00:56:44 <dons> fuzan: yes, toChunks/fromChunks lets you efficiently convert between the two
00:56:46 <dons> never go via String.
01:18:04 <Lemmih> @seen bringert
01:18:04 <lambdabot> I saw bringert leaving #ghc and #haskell 9h 51m 56s ago, and .
01:18:27 <kaol> what's supposed to be after "and ."?
01:20:18 <Lemmih> And I've missed X minutes.
01:20:34 <dons> it used to say some other things, which i removed. the pretty printer was too complex to bother, and now I find it amusing.
01:20:41 <dons> and .
01:20:54 <dons> its a little zen moment brought to you by lambdabot.
01:21:09 <osfameron> :t and .
01:21:17 <osfameron> hrmpf
01:21:18 <lambdabot> parse error (possibly incorrect indentation)
01:21:21 <dons> :t and (.)
01:21:23 <lambdabot>     Couldn't match expected type `[Bool]'
01:21:23 <lambdabot>            against inferred type `(b -> c) -> (a -> b) -> a -> c'
01:21:33 <dons> :t flip and (.)
01:21:35 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
01:21:36 <lambdabot>     In the first argument of `flip', namely `and'
01:21:38 <dons> ah well
01:25:29 <babao> hi, did somebody install ghc 6.6.1 under Vista lately?
01:31:21 <osfameron> Apocalisp: hi - I'm about to post on Ex 2.2 of SOE, I was hoping to quote your version, would that be OK ?
01:31:47 <Lemmih> Hiya bringert.
01:31:54 <kolmodin> hey
01:32:16 <Lemmih> bringert: Network.CGI.Multipart isn't as lazy as it should be.
01:32:17 <bringert> hi
01:32:30 <bringert> Lemmih: I've suspected that
01:32:40 <bringert> Lemmih: feel free to fix
01:44:34 <marscher> hi
01:45:01 <marscher> whats the difference between the types [a] -> a and [a -> a] -> a -> a?
01:45:32 <lome> @djinn-add data Test a b c = Test (a -> b -> (a,b,c))
01:45:38 <lome> @djinn Test a b c -> (c -> Test a b d) -> Test a b d
01:45:53 <lambdabot> Plugin `djinn' failed with: IRCRaised Prelude.init: empty list
01:46:02 <lome> oops
01:46:38 <int-e> djinn doesn't know about fixpoints
01:46:59 <lome> ok, thanks
01:47:12 <Lemmih> bringert: Fixed and pushed.
01:48:12 <DRMacIver> marscher: Err. Your question doesn't make a lot of sense.
01:48:18 <int-e> @type fix id
01:48:22 <lambdabot> forall a. a
01:48:31 <lome> int-e: but I dont see any fixpoint here
01:48:36 <int-e> otherwise it could derive that, and that would be completely useless :)
01:50:44 <int-e> @type \f -> (\(a,b,c) -> c) (fix (\(a,b,c) -> f a b))
01:50:47 <lambdabot> forall t t1 t2. (t -> t1 -> (t, t1, t2)) -> t2
01:51:11 <marscher> mhm
01:51:22 <int-e> that's how you get a  c  from  a -> b -> (a,b,c)  (you'd usually write it with let of course)
01:51:33 <marscher> whats the difference between [a] and [a -> a]?
01:51:49 <int-e> @type \f -> let (a,b,c) = f a b in c
01:51:56 <lambdabot> forall t t1 t2. (t -> t1 -> (t, t1, t2)) -> t2
01:52:24 <int-e> marscher: [a -> a] is a list of functions (mapping a type to itself)
01:52:26 <lome> oh, I see
01:52:26 <quicksilver> marscher: [a->a] is a list of functions,  [a] is a l ist of values :)
01:53:48 <marscher> ahh ;)
01:54:31 <Syzygy-> > let applyMost (f:fs) (x:xs) = (f x):(applyMost fs xs); applyMost [] _ = []; applyMost _ [] = [] in applyMost [(+1),(-1),(*2)] [2,3]
01:54:32 <lambdabot>   add an instance declaration for (Num (a -> a))
01:54:32 <lambdabot>     In the expression: (- 1)
01:54:41 <Syzygy-> > let applyMost (f:fs) (x:xs) = (f x):(applyMost fs xs); applyMost [] _ = []; applyMost _ [] = [] in applyMost [(+1),(subtract 1),(*2)] [2,3]
01:54:43 <lambdabot>  [3,2]
01:54:59 <Syzygy-> Does that one actually already have a name somewhere?
01:55:05 <int-e> Syzygy-: zipWith id
01:55:09 <Syzygy-> Ah.
01:55:25 <int-e> or zipWith ($) if you prefer that.
01:55:38 <Syzygy-> > zipWith ($) [(+1),(subtract 1),(*2)] [2,3]
01:55:40 <lambdabot>  [3,2]
01:55:58 <dons> osfameron: btw, do you have your blog on planet.haskell.org ?
01:56:08 <osfameron> dons: yeah
01:56:37 <osfameron> Antti-Juhani put it on for me the last time
01:56:40 <dons> cool
01:56:52 <dons> just came up in my rss feeds, and I wasn't sure if I'd seen it on p.h.o
01:57:03 <osfameron> doesn't look like it's updated there yet
02:20:16 <fuzan> i'm doing something bad with Vty: user error (clrscr realloc)
02:38:38 <dozer> @hoogle (a, m b) -> m (a, b)
02:38:39 <lambdabot> Prelude.snd :: (a, b) -> b
02:38:39 <lambdabot> Prelude.fst :: (a, b) -> a
02:38:39 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
02:38:50 <fuzan> ah, one must draw their entire window.
02:40:00 <dozer> @hoogle Monad m => (a, m b) -> m (a, b)
02:40:00 <lambdabot> Prelude.snd :: (a, b) -> b
02:40:00 <lambdabot> Prelude.fst :: (a, b) -> a
02:40:10 <quicksilver> dozer: it's not there :)
02:40:14 <fuzan> :t liftM
02:40:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:40:18 <dozer> lol, I was reaching that conclusion
02:40:32 <quicksilver> dozer: not hard to right, though
02:40:36 <quicksilver> s/right/write/
02:43:07 <fuzan> > let tup t = liftM (\x -> (fst t, x)) (snd t) in tup (5, return 6)
02:43:08 <lambdabot>   add an instance declaration for (Show (m (t, t1)))
02:43:21 <fuzan> > let tup t = liftM (\x -> (fst t, x)) (snd t) in tup (5, return 6) :: IO (Int,Int)
02:43:23 <lambdabot>  <IO (Int,Int)>
02:43:32 <fuzan> ugh, i hate lambdabot.
02:44:04 <fuzan> there's probaly a far prettier way to write that, tho :)
02:44:24 <quicksilver> :t \x -> let (a,mb) = x in do { b <- mb ; return (a,b) }
02:44:27 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => (t, t1 t2) -> t1 (t, t2)
02:45:14 <fuzan> :t let tup t = liftM (\x -> (fst t, x)) (snd t)
02:45:16 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
02:45:16 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
02:45:16 <lambdabot>  
02:45:25 <fuzan> hmm.
02:45:34 <fuzan> i further state; i hate lb.
02:45:41 <fuzan> @botpoison
02:45:41 <lambdabot> Unknown command, try @list
02:46:12 <quicksilver> :t let tup t = liftM (\x -> (fst t, x)) (snd t)
02:46:14 <lambdabot> [1 of 2] Compiling ShowQ            ( scripts/ShowQ.hs, interpreted )
02:46:14 <lambdabot> [2 of 2] Compiling L                ( L.hs, interpreted )
02:46:14 <lambdabot>  
02:46:17 <quicksilver> that is odd
02:46:23 <quicksilver> :t let tup t = liftM (\x -> (fst t, x)) (snd t) in tup
02:46:26 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a, m a1) -> m (a, a1)
02:46:46 <fuzan> ah
02:48:13 <roconnor> what software runs planet.haskell.org?
03:00:02 <roconnor> > recip 1.0851
03:00:02 <lambdabot>  0.921574048474795
03:00:13 <roconnor> @google 1 CAD in USD
03:00:14 <lambdabot> 1 Canadian dollar = 0.912575 U.S. dollars
03:00:57 <opqdonut> ?src recip
03:00:58 <lambdabot> Source not found. Are you on drugs?
03:01:02 <opqdonut> :O
03:01:44 <opqdonut> > fix recip
03:01:45 <lambdabot>  Exception: <<loop>>
03:01:51 <opqdonut> > fix recip 1.0
03:01:52 <lambdabot>   add an instance declaration for (Fractional (t -> a))
03:02:02 <opqdonut> ah yes nvm
03:02:56 <quicksilver> opqdonut: these are not the fixed points you are looking for :)
03:03:13 <opqdonut> yeah noticed that
03:03:32 <quicksilver> unfortunately, _|_ is the least f.p. of recip in that order
03:03:36 <quicksilver> 1 is higher up
03:03:46 <opqdonut> how come?
03:04:10 <quicksilver> I don't quit ehave the spare brain bandwidth to grok CPOs just now
03:04:34 <quicksilver> hopefully someone brighter will come along :)
03:04:39 <opqdonut> > fix (\x -> 1+ recip x)
03:04:40 <lambdabot>  Exception: <<loop>>
03:04:50 <dons> @seen dcoutts
03:04:50 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 12h 11m 11s ago.
03:04:52 <osfameron> eeek!  fix!
03:05:09 <osfameron> I have some gnashing of teeth to do about the exercise on fix in SOE chapter 8, when I get to blogging that
03:06:07 <osfameron> saying "this is a bit tricky!" isn't really all that helpful as the only guidance you're given to just invent anonymous combinators or whatever they're called
03:08:21 <mdmkolbe|work> Is there a haskell syntax for multiple cases in a case statement that all go to the same branch?  (i.e. the C equivalent would be "switch (expr) { 1: 2: 3: run(); break; 4: stop(); break; }")
03:09:41 <quicksilver> mdmkolbe|work: no
03:09:48 <pjd> factor it into a where or let?
03:09:53 <quicksilver> mdmkolbe|work: it is occasionally discussed or suggested
03:09:56 <int-e> mdmkolbe|work: you could use guards. case expr of x | x `elem` [1,2,3] ->
03:10:06 <quicksilver> mdmkolbe|work: SPJ said he wasn't aware of any particular reason it's not allowed
03:11:44 <mdmkolbe|work> ok, thx all
03:22:47 <kolmodin> ?yarr!
03:22:47 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
03:23:20 <dcoutts_> hia dons
03:26:28 <marscher> does a function exists which does concat a list of Strings to single String?
03:26:50 <int-e> @type concat
03:26:59 <lambdabot> forall a. [[a]] -> [a]
03:27:00 <int-e> > concat ["abc", "def"]
03:27:01 <lambdabot>  "abcdef"
03:27:14 <int-e> String is a type alias for [Char], and thus a list.
03:33:02 <marscher> where do i find the prelude src?
03:34:05 <gleb> marscher: what haskell implementation you are using?
03:35:37 <quicksilver> marscher: http://haskell.org/ghc/docs/latest/html/libraries/
03:35:49 <quicksilver> marscher: as with the source of many of the libraries :)
03:36:03 <quicksilver> marscher: there's also a version of it as an appendix to the report, IIRC
03:37:01 <gleb> marscher: prelude src is bundled with hugs, and GHC prelude can be seen online at http://darcs.haskell.org/ghc-6.6/packages/base/
03:37:02 <lambdabot> Title: Index of /ghc-6.6/packages/base
03:37:19 <gleb> @source map
03:37:19 <lambdabot> map not available
03:38:18 <marscher> thx
03:53:08 <thorkilnaur> @src map
03:53:08 <lambdabot> map _ []     = []
03:53:09 <lambdabot> map f (x:xs) = f x : map f xs
03:53:23 <marscher> @src concatMap
03:53:23 <lambdabot> concatMap f = foldr ((++) . f) []
03:53:35 <marscher> @src concat
03:53:35 <lambdabot> concat = foldr (++) []
03:56:41 <marscher> how do i check which type a parameter has?
03:56:56 <marscher> like the instanceof operator in java
03:57:10 <quicksilver> you don't :)
03:57:19 <marscher> i need to :)
03:57:22 <quicksilver> at least, that's a rather clumsy programming style
03:57:33 <quicksilver> typically parameters can only have one type
03:57:42 <quicksilver> that's the guarantee the type system gives you
03:57:47 <quicksilver> what are you trying to do?
03:58:26 <marscher> mhm BinTree = Leaf a | Node a (BinTree a ) (Bintree a)
03:58:34 * quicksilver nods
03:59:02 <quicksilver> at any particular time, there's only one type in the tree, though
03:59:08 <quicksilver> since all those 'as' are the same
03:59:13 <marscher> i want to traverse it
03:59:35 <quicksilver> f (Leaf x) = something_with x
03:59:37 <marscher> how do i check if i'am on a leaf or on a node?
03:59:56 <quicksilver> f (Node x left right) = somethi_with x something_with left right
04:00:04 <quicksilver> by pattern matching
04:00:11 <marscher> ah alright ;)
04:00:11 <marscher> thx
04:00:16 <quicksilver> either an explicit case, or just by putting the pattern in the func defn
04:00:53 <kosmikus> marscher: note that "Leaf" and "Node" are not "types".
04:01:20 <marscher> ???
04:01:44 <kosmikus> because you said in the beginning that you want to check which "type" a parameter has.
04:02:03 <kosmikus> they all have the same type, namely "BinTree a" for a suitable "a".
04:02:23 * marscher is confused
04:02:36 <quicksilver> BinTree a is a type
04:02:42 <quicksilver> Leaf is a particular constructor
04:02:53 <quicksilver> so yo're "checking which constructor a parameter is"
04:03:00 <quicksilver> not "checking which type it is"
04:04:45 <gleb> marscher: have you ever used smth like C++ enums?
04:05:10 <gleb> marscher: like enum Color { red, green, blue };
04:05:29 <gleb> marscher: constant red has type color
04:06:01 <gleb> marscher: you can view haskell algebraic datatypes as enums on steroids
04:06:48 <marscher> its a simple sumtype isnt it?
04:06:50 <DRMacIver> Hm. I always view enums as algebraic datatypes with all the useful bits removed. :)
04:07:33 <marscher> hehe
04:08:25 <gleb> marscher: well I'm not too deep into PLT, but Haskell ADTs are really sums of products I guess
04:09:37 <gleb> DRMacIver: yeah, everything except constructors is actually removed. My point was that different constructors belong to the same type. Sorry if this was confusing
04:11:36 <earthy> gleb: almost. there's recursion in the datatypes as well
04:12:45 <DRMacIver> gleb: I knew what you meant. :)
04:13:03 <gleb> earthy: good point
04:13:31 <earthy> I mean, sums of products, that's almost trivially implemented in C
04:13:39 <earthy> given structs, unions and enums
04:13:58 <osfameron> and how much more trivial could you get than a union of structs of enums!
04:14:03 <earthy> recursion is slightly harder. ;)
04:15:50 <gleb> earthy: Well things like data List a = Nil | Cons a (List a) are easily translated into C, using pointers.
04:16:12 <earthy> gleb: and how would you represent [1..] ?
04:17:12 <osfameron> obviously you can do it in C, as I guess some part of the core of haskell is implemented in C
04:17:16 <gleb> earthy: Not sure what you mean here. Lazy evaluation is great, but does it have smth to do with recursive types?
04:17:36 <osfameron> you'd just need a struct with a pointer to a function that fills in the next value of the linked list
04:17:59 <quicksilver> osfameron: the core of haskell is all written in haskell
04:18:06 <quicksilver> osfameron: nontheless, of course, you're right :)
04:18:24 <earthy> ofameron: yeah, but now you're not talking trivial anymore. :)
04:18:36 * earthy knows how to do it
04:19:15 <quicksilver> well indeed, lazy evaluation is, in C terms, essentially making everything a union { struct A * ; A*func(); }
04:19:32 <quicksilver> not that I can quite remember the odd C syntax for function pointers
04:19:42 <quicksilver> but you do need some kind of tag to make a union useful
04:20:04 * gleb nods
04:20:22 <earthy> struct { tagType t; union { struct A*; A (*func) (); } f; }
04:20:52 <earthy> that doesn't look completely valid though
04:21:04 <earthy> struct { tagType t; union { struct A* struc; A (*func) (); } f; }
04:21:07 <earthy> that's better
04:21:51 <quicksilver> ISTR you can make 'f' anonymous
04:21:56 <earthy> and then for an a of that structtype:  a.f.func()  or   a.f.struc
04:21:56 <quicksilver> or is that a gcc extension?
04:22:05 <earthy> that's an extension, afaiui
04:22:26 <gleb> quicksilver: I agree. I was trying to understand earthy's point about type recursion. Actually almost every language with records (structs) or objects has recursion at type level, since you are allowed to have struct node { node* next; };
04:22:40 <earthy> that's not recursion though
04:23:12 <earthy> each struct node is finitely sized
04:23:49 <earthy> whereas with adt's with recursion you can specify possibly infinitely sized data values
04:25:04 <quicksilver> I disagree; it *is* recursion
04:25:10 <kolmodin> dons: pingeling
04:25:10 <quicksilver> it's just always conditional
04:25:19 <quicksilver> there's always "| Null" hidden in there
04:25:26 <quicksilver> due to the semantics of C pointers
04:26:45 <earthy> yeah, well, I was brought up in the Algol tradition
04:26:55 <gleb> earthy: if it's possible to use _name_ of the type in its definition, it's already type recursion
04:26:56 <earthy> where infinite values are *explicitly* forbidden
04:27:12 <earthy> but reference values are allowed
04:27:34 <dons> kolmodin: yo?
04:28:06 <osfameron> quicksilver: really?  bootstapmungous!
04:28:52 <quicksilver> osfameron: indeed :)
04:29:34 <quicksilver> osfameron: haskell is a good language for writing langauges in
04:29:49 <quicksilver> osfameron: many of its features can be understood that way (not to suggest they're not good for other things too)
04:29:50 <dons> pattern matching and algebraic data types forever! :-)
04:31:40 <osfameron> what's the bootstrapper written in? Perl?
04:32:32 <quicksilver> osfameron: I dont' know the history; I imagine it was probably Gofer
04:32:39 <quicksilver> osfameron: which is a very similar language
04:32:52 <quicksilver> osfameron: these days, there is no seperate bootstrapper as such
04:33:09 <quicksilver> osfameron: but you can run ghc on another machine to compile haskell-to-C a bootstrap compiler
04:33:23 <quicksilver> osfameron: which you then compile C-to-native on target machine
04:33:43 <kolmodin> dons: hey, would you like to discuss the binary paper?
04:34:09 <kolmodin> dcoutts_: looks like we're all here now
04:34:36 <dons> kolmodin: i'm about to head off. we could go via email ?
04:34:46 <dcoutts_> ok
04:34:49 <kolmodin> dons: ah, ok
04:36:00 <osfameron> ah, of course, you need ghc to build ghc.  that hurts my feeble BRANE
04:36:00 <dons> or discuss in -overflow, and i'll check it in the morning.
04:36:06 <osfameron> I think I'm going to run away to lunch instead :-)
04:36:43 <kolmodin> right
04:41:02 <babao> hi, did anybody try to install latest ghc 6.6.1 binaries under Windows?
04:43:06 <marscher> :t Maybe
04:43:08 <lambdabot> Not in scope: data constructor `Maybe'
04:43:27 <pjd> :t Maybe foo
04:43:29 <lambdabot> Not in scope: data constructor `Maybe'
04:43:29 <lambdabot>  
04:43:29 <lambdabot> <interactive>:1:6: Not in scope: `foo'
04:49:31 <quicksilver> Maybe is a type constructor, not a data constructor
04:49:40 <quicksilver> thus it does not have a type itself, although it has a kind
04:49:42 <quicksilver> 'Just' has a type
04:49:43 <quicksilver> :t Just
04:49:45 <quicksilver> :k Maybe
04:49:46 <lambdabot> forall a. a -> Maybe a
04:49:48 <lambdabot> * -> *
04:51:58 <roconnor> @google 100 zimbabwe dollars in euros
04:52:00 <lambdabot> http://en.wikipedia.org/wiki/Zimbabwean_dollar
04:52:00 <lambdabot> Title: Zimbabwean dollar - Wikipedia, the free encyclopedia
04:54:06 <pjd> roconnor: maybe "euros" is optomistic
04:54:23 <roconnor> it doesn't like it for some reason
04:54:33 <roconnor> @google 100 ZWN in EUR
04:54:35 <lambdabot> http://coinmill.com/EUR_ZWN.html
04:54:35 <lambdabot> Title: Convert Euros (EUR) and New Zimbabwe Dollars (ZWN): Currency Exchange Rate Conve ...
04:56:15 <roconnor> > 0.30/1000
04:56:17 <lambdabot>  3.0e-4
04:56:33 <roconnor> > 0.30/10
04:56:34 <lambdabot>  3.0e-2
04:58:29 <roconnor> If my calculations are correct my 100 zimbabwe dollar note is worth 3/100 of a euro cent.
05:00:29 <pjd> roconnor: you are going to have to explain how you ended up with said note :)
05:00:48 <roconnor> I was in Zimbabwe in 2001
05:00:57 <roconnor> it was worth more back then
05:02:02 <kolmodin> roconnor: so how many dollars would it be for a coffee and biscuit? :)
05:03:44 <roconnor> lots
05:04:17 <roconnor> It's probably worth more as paper than as money
05:05:40 <kolmodin> :/
05:06:01 <boegel> roconnor: I saw some documentary on money in Congo a few months ago... they exchanged a $100 bill for a whole plastic bag filled with Congolese money...
05:06:16 <kolmodin> that makes forgery a bit hard
05:07:19 <kolmodin> think of all unexpected things you could do with the money just becase it's worthless
05:07:52 <roconnor> shit, I only had 21 days to exchange my old note for their new revalued currency
05:07:55 <roconnor> that was last year
05:08:05 <kolmodin> like taking notes on it.. use it as a napkin. put it in your printer when you run out of paper. use it "elsewhere" when you run out of paper...
05:08:26 <roconnor> At one point I was considering using it for toilet paper when I was in Turkey
05:08:41 <roconnor> I decided I wasn't quite desparate enough yet
05:08:47 * earthy still laments losing his wallet once
05:08:54 <kolmodin> yes. iirc the turks aren't that fond of toilet paper
05:09:18 <earthy> it had a brazilian cruzeiro, minted the year that I found it... worth .125 cents at the time I found it.
05:11:37 <roconnor> ``In February 2007, the central bank of Zimbabwe declared inflation "illegal"..
05:11:41 <roconnor> perfect
05:11:47 <roconnor> why didn't they think of doing that before.
05:13:33 <earthy> because they didn't think people trusted law, what with their track record in trusting currency? :)
05:14:03 <kaol> that doesn't look quite right: http://haskelldb.sourceforge.net/guide/selCols.html
05:14:04 <lambdabot> Title: Select columns
05:14:46 <Baughn> earthy: Pegging a currency to the dollar usually works.. if you can get enough dollars. Why didn't they try that?
05:19:04 <marscher> > (\x -> x*x) . succ 3
05:19:06 <lambdabot>   add an instance declaration for (Num (a -> b))
05:19:50 <marscher> succ 3 . ( \x -> x*x)
05:19:55 <marscher> > succ 3 . ( \x -> x*x)
05:19:56 <lambdabot>   add an instance declaration for (Num (a -> c))
05:21:15 <marscher> > (.) succ . (\x -> x*x) 3
05:21:16 <lambdabot>   add an instance declaration for (Num (a1 -> a -> b))
05:31:11 <gleb> > (succ . \x -> x*x) 3
05:31:20 <lambdabot>  10
05:32:30 <marscher> grml
05:33:07 <gleb> marscher: grml?
05:34:44 <marscher> just a german exclamation...
05:34:53 <marscher> foo :: (a -> b) -> (b -> c) -> (a -> c)
05:35:10 <marscher> may somebody give me an example function body for this type signature?
05:35:23 <DRMacIver> foo = (.)
05:35:32 <DRMacIver> Or was that not what you wanted? :)
05:35:34 <marscher> no
05:35:40 <marscher> its not that type :P
05:35:46 <marscher> @type (.)
05:35:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:35:58 <marscher> returns a -> c
05:36:05 <marscher> no
05:36:05 <marscher> c
05:36:14 <gleb> @type flip (.)
05:36:14 <DRMacIver> @type flip (.)
05:36:16 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
05:36:18 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
05:36:24 <kosmikus> ?djinn (a -> b) -> (b -> c) -> (a -> c)
05:36:24 <lambdabot> f a b c = b (a c)
05:36:27 <marscher> @type flip
05:36:29 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
05:36:42 <gleb> @src flip
05:36:42 <lambdabot> flip f x y = f y x
05:37:15 <marscher> O_o
05:38:55 <klemm> what it does if we ask lambdabot to perform some infinite computation? :p
05:39:01 <araujo> morning
05:39:18 <byorgey> > repeat 1
05:39:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:39:29 <klemm> ha :)
05:39:31 <byorgey> klemm: it's too smart to fall for that =)
05:39:33 <gleb> araujo: good afternoon
05:39:34 <Syzygy-> klemm: It terminates.
05:39:47 <klemm> byorgey: I suspected so. :p
05:39:57 <Syzygy-> The things that really trick lambdabot out get terminated with something along the lines of "Terminated long calculation."
05:40:01 <marscher> cya all
05:40:06 <araujo> hi gleb
05:40:45 <byorgey> > foldl' (+) $ repeat 1
05:40:46 <lambdabot>   add an instance declaration for (Num [t])
05:41:07 <byorgey> > foldl' (+) 0 $ repeat 1
05:41:12 <lambdabot> Terminated
05:46:44 <mnislaih> dcoutts: there ?
05:46:51 <dcoutts_> @arr!
05:46:52 <lambdabot> Shiver me timbers!
05:47:01 <mnislaih> I finally finished (err..got sick of) testing the filepath patch for Cabal.
05:47:10 <mnislaih> mostly on Linux, but also a bit on Windows
05:47:21 <dcoutts_> ah great
05:47:27 <mnislaih> is it ok if I push it then ?
05:47:36 <mnislaih> it's a big patch
05:47:39 <dcoutts_> if you think it's ok then yes
05:47:55 <ari> @seen bringert
05:47:56 <lambdabot> I saw bringert leaving #ghc and #haskell 2h 36m 33s ago, and .
05:47:56 <dcoutts_> and ask ndm to have a quick go at breaking it for us :-)
05:47:58 <mnislaih> I can send it to you for review first if you have the time
05:48:09 <mnislaih> ah, on Windows, that would help
05:48:18 <mnislaih> I can build all the libraries with it, on Linux
05:48:27 <mnislaih> but don't really know how it will work on Win
05:48:30 <dcoutts_> mnislaih: if you want me to look at it first then I can do, if you're happy with it then you can just push
05:48:48 <mnislaih> I'll just push it and wait for complains to come
05:49:00 <dcoutts_> heh ok :-)
05:49:27 <dcoutts_> ndm: time to complain
05:49:41 <mnislaih> we agreed on dumping Compat.Filepath, right ?
05:49:47 <dcoutts_> mnislaih: yes
05:50:04 <dcoutts_> so no longer exported, removed fully
05:50:10 <mnislaih> ok
05:50:27 <ndm> dcoutts_ i'm happy you're moving to proper filepath code, and upset i still can't release any of my libraries...
05:50:43 <dcoutts_> ndm: that's the tar issue right?
05:51:19 <ndm> dcoutts_ - yes
05:51:36 <mnislaih> I found a tar with gzip support for Windows in the gnuWin32 project
05:51:47 <dcoutts_> ndm: doing a separate tar and gzip invocations would fix it for you, but it doesn't help generally
05:52:26 <mnislaih> the normal tar there is broken, but the 'bsdtar' one works
05:52:30 <ndm> dcoutts_ - it helps me though...
05:52:31 <dcoutts_> ndm: but I'm happy to accept a patch that uses separate tar & gzip calls, it shouldn't be a difficult change
05:52:54 <ndm> dcoutts_ - maybe after my HW and YDS papers
05:53:12 <dcoutts_> YDS?
05:53:29 <ndm> http://www.cs.york.ac.uk/yds/wiki/index.php?title=York_Doctoral_Symposium
05:53:30 <mnislaih> YHC Dsomething Symposium?
05:53:31 <lambdabot> Title: York Doctoral Symposium - York Doctoral Symposium, http://tinyurl.com/2aszjl
05:53:36 <ndm> the free food symposium
05:53:37 <dcoutts_> ah
05:53:39 <dcoutts_> heh
05:53:41 <ndm> :)
05:53:48 <ndm> free £35 buffet meal
05:53:58 <ndm> plus its free to all york students, so a great (free) date
05:54:03 <mnislaih> :)
05:55:01 <mnislaih> dcoutts_: I'm trying to find a new home for exeExtension,objExtension,etc. any suggestion ?
05:55:21 <dcoutts_> hrm
05:55:50 <mnislaih> Distribution.Simple.Utils ?
05:56:04 <mnislaih> after all they are always used inside Distribution.Simple
05:56:59 <dcoutts_> mnislaih: yes, I was just going to suggest that
06:02:12 <mnislaih> there it goes, patch pushed
06:06:52 <timbod> I'm just browsing the cabal manual - does it build optimised by default? or must I pass a flag?
06:08:17 <ari> Gah, who let a text editor flamewar into haskell-cafe? I thought those things were supposed to be kept in their cages at all times :(
06:08:23 <fasta> Do mutual recursive modules work already in GHC in some sane way?
06:08:37 <george--> hi, im revising for an exam on haskell (introduction level) and a past paper asks: how does haskells type system support higher order functions?
06:08:53 <ddarius> review
06:09:12 <ddarius> Um, by having types representing them...
06:09:20 <george--> i dont really program any other languages so i dont know how a type system WOULDNT support hof
06:09:30 <fasta> What a vague question
06:09:31 <ndm> ari: yeah, i know - everyone needs a group bug
06:10:05 <ddarius> george--: By not having a type of higher order functions...
06:10:15 <george--> can you give me an example possibly?
06:10:29 <fasta> george--: how about a language with no functions at all
06:10:42 <fasta> george--: (yes, they exist and have applications)
06:11:04 <fasta> george--: Dijkstra's Guarded Command Language is an example
06:11:15 <kolmodin> ?karma george--
06:11:15 <lambdabot> george-- has a karma of 0
06:11:30 <kolmodin> ?karma george
06:11:31 <lambdabot> george has a karma of -1
06:12:03 <kolmodin> george--: your nick is bad for poor george :)
06:12:17 <Syzygy-> ?karma george
06:12:17 <lambdabot> george has a karma of -1
06:12:39 <fasta> Ok, let me ask a more constructive question: is it possible to keep using ghci with mutual recursive modules?
06:12:44 <george--> how does it judge ones karma?
06:13:08 <kolmodin> george--: saying george-- will give george one less karma
06:13:08 <fasta> george--: it analyses your behaviour
06:13:09 <Syzygy-> george--: It modifies by parsing when one writes <nick>-- or <nick>++
06:13:31 <fasta> Hmm, now all the magic is gone for george--
06:13:45 <Syzygy-> Sorry.
06:13:48 <kolmodin> so it's ok when you say "george--:" but not "george--"
06:13:51 <george--> ?karma test
06:13:51 <lambdabot> test has a karma of 2
06:13:56 <george--> test--
06:13:59 <Syzygy-> test--: blah
06:14:01 <george--> ?karma test
06:14:02 <Syzygy-> ?karma test
06:14:02 <lambdabot> test has a karma of 1
06:14:02 <lambdabot> test has a karma of 1
06:14:07 <kolmodin> :)
06:14:13 <george--> lol :P
06:14:17 <Syzygy-> Note: <nick>-- lowers, but <nick>--: doesn't.
06:14:24 <george--> george is already registed to someone else
06:14:42 <kolmodin> yes, he should have thought of that :)
06:14:53 <george--> george--++ ?
06:14:56 <george--> ?karma george
06:14:57 <lambdabot> george has a karma of -3
06:15:05 <george--> ?karma george--
06:15:05 <lambdabot> You have a karma of 0
06:15:14 <george--> my karma went down :(
06:16:59 <george--> so anyway.. I have a question: how does haskells type system support higher order functions? use examples to illustrate your answer
06:17:06 <george--> how would you guys suggest i answer this?
06:17:43 <fasta> george--: I would suggest you read your book better
06:17:59 <integral> george--: That would be obvious things like map and foldl
06:18:19 <george--> i dont have a book
06:18:25 <fasta> george--: ?
06:18:44 <fasta> george--: ok, so this is "independent study"?
06:18:54 <george--> i had lectures?
06:19:24 <fasta> george--: lectures without any kind of support text cannot be taken seriously.
06:19:50 <integral> You took notes, yes?
06:19:58 <george--> there were of course suggested books to read, and i studied them some at the time, now i am practicing past exam papers
06:20:04 <george--> but i dont have the books
06:20:12 <george--> integral, i have notes yes
06:20:13 <integral> george--: Go to the library and get them?
06:20:18 <integral> Read your notes?
06:20:42 <george--> well... i am asking this question not because it is the first on the paper, but its the first my notes dont answer
06:21:11 <fasta> integral: have you used mutual recursive modules in ghci?
06:21:28 <integral> fasta: No, I avoid them as I don't grok boot files
06:23:12 <fasta> integral: I avoided them until now, but I would be ready to use them if someone could point me to a resource that claims it works in the first place for ghci. The docs seem to indicate it doesn't by not stating explicitly that it does.
06:24:19 * integral isn't the person to ask.
06:25:43 <fasta> integral: yes, I noticed. Thanks, anyway.
06:42:41 <petter_> good afternoon
06:44:06 <petter_> if I call a function with the same arguments twice, it will only be evaluated once, right?
06:44:51 <flux> nope.
06:45:07 <roconnor> the compiler must optimize for that to happen
06:45:17 <petter_> ok
06:45:39 <chrismbrown_> if I declare a pattern in a where clause, will it override any other definitions in scope?
06:45:45 <roconnor> GHC will in general do common subexpression elimination
06:46:03 <roconnor> so if you call (f x) twice in the same body, that subexpression will be unified.
06:46:10 <chrismbrown_> suppose I have:
06:46:17 <chrismbrown_> f :: MyData1  -> Int
06:46:17 <chrismbrown_> f (ComplexExpr1 a b (ComplexExpr2 Null))
06:46:17 <chrismbrown_>  = ComplexExpr1 a b (ComplexExpr2 Null)
06:46:17 <chrismbrown_>      where
06:46:18 <chrismbrown_>        a = 42
06:46:33 <chrismbrown_> ghci and programatica give different results, which is quite worrying
06:46:47 <quicksilver> chrismbrown_: the first 'a' is a binder, it won't be affected
06:46:49 <petter_> I think I understand, I was writing a graph-search and was hoping for that to take care of keeping track of visited nodes
06:47:03 <chrismbrown_> f ... = a    that should read
06:47:12 <quicksilver> oh
06:47:14 * quicksilver nods
06:47:15 <chrismbrown_> ghci gives me 42
06:47:17 <quicksilver> I'd expect 42
06:47:18 * quicksilver nods
06:47:22 <roconnor> petter_: are you aware of the graph library for haskell?
06:47:28 <chrismbrown_> programatica gives me the value of 'a' in the LHS of f
06:47:45 <quicksilver> the where is grammatically 'closer' than the LHS of the defn
06:47:48 <quicksilver> in haskell, at least
06:47:52 <chrismbrown_> thats what I thought
06:47:56 <chessguy> 'morning haskellers
06:47:56 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
06:47:58 <chrismbrown_> perhaps it's another bug in Programatica
06:47:59 <petter_> roconnor: I saw something like that in the docs, but this is for my own enjoyment
06:48:10 <roconnor> okay, good then.
06:49:02 <petter_> so now I'm thinking about using State to carry around a list of visited nodes as i traverse the graph
06:49:45 <roconnor> the usual function solution for graphs seems to be to use inductively defined graphs.
06:50:10 <roconnor> so a graph is either a single node
06:50:26 <chrismbrown_> Programatica is really broken
06:50:37 <chrismbrown_> even if I have f a = let a = 42 in a
06:50:38 <roconnor> or a single node and a graph with a list of nodes of that graph that this new nodes connects to
06:50:42 <chrismbrown_> f 1 = 1
06:51:17 <quicksilver> chrismbrown_: what is programatica?
06:51:28 <petter_> roconnor: I think I'm using something like that: data Graph a = Graph a [Graph a] deriving Show
06:51:53 <petter_> roconnor: Is this an inductively defined graph?
06:51:57 <chrismbrown_> quicksilver: it's a (fairly oldish) haskell implementation, that has support for verification of haskell programs almongst a variety of other things...
06:52:07 <chrismbrown_> quicksilver: we use the front end for the haskell refactorer
06:52:25 <chrismbrown_> quicksilver: http://www.cse.ogi.edu/PacSoft/projects/programatica/
06:52:27 <lambdabot> Title: The Programatica Project
06:52:31 <roconnor> petter_: I'm not sure, but it does seem pretty close.
06:52:46 <roconnor> petter_: certainly seems better than a list of vertices and edges
06:52:47 <petter_> roconnor: I did this to understand the "knot tying" stuff
06:53:52 <petter_> roconnor: writing a function from a list of vertices to a graph in the form mentioned above
06:54:06 <roconnor> it seems hard to properly process circular data structures.
06:54:35 <quicksilver> chrismbrown_: an, interesting
06:54:35 <roconnor> I wonder if circular data structures ought to be avoided in general.
06:54:46 <quicksilver> chrismbrown_: apparently buggy, but still interesting :)
06:54:53 <quicksilver> roconnor: I think they probably should
06:55:02 <quicksilver> roconnor: or, they're fine as models for infinite data structures
06:55:09 <chrismbrown_> quicksilver: it's annoying because it's so buggy!
06:55:16 <quicksilver> roconnor: but not if you want to explicitly 'cope with' their circularity
06:55:29 <quicksilver> roconnor: e.g. cycle [1,2] is fine as an infinite list
06:55:40 <quicksilver> roconnor: but it's hopeless as a circular list (impossible to prove it's circular)
06:55:58 <roconnor> quicksilver: exactly.
06:57:18 <quicksilver> roconnor: if you want to play that sort of game you have to give the nodes identity yourself
06:57:27 <quicksilver> roconnor: tuple them up with some kind of UUID or whatever
06:59:05 <roconnor> I really like how you put that.  You cannot treat a circular structure as a finite structure.
06:59:17 <roconnor> so your induction (recursion) principle goes out the window
06:59:20 <petter_> "knot tying" is very interesting, I didn't understand it at first from looking at the wiki, but as I experimented I found out I had done it before
07:00:41 <roconnor> petter_: have you read my article in the monad reader :)
07:00:49 <roconnor> or the article in the latest issue?
07:00:59 <petter_> no I haven't
07:01:32 <roconnor> I think there have been some very nice articles and blog entries in recent months on the topic
07:02:53 <petter_> Monad.Reader Issue 7, April 30, 2007?
07:03:17 <roconnor> there is one article in that issue, and my article is in the previous issue
07:05:15 <petter_> yes, I found it
07:07:25 <osfameron> heh, http://lambda-the-ultimate.org/node/2254 "It is felt that ease of formal verification should not dominate program language deisgn."
07:07:26 <lambdabot> Title: Social Processes and Proofs of Theorems and Programs | Lambda the Ultimate
07:07:58 <osfameron> I'm sure that the most "important" languages are being designed with barely a thought that formal verification even exists
07:08:56 <chessguy> hmm, i think whether or not formal verification should dominate depends on the domain, doesn't it?
07:09:43 <roconnor> ``Furthermore, the absence of continuity, [...] make the formal verification process difficult to justify''
07:09:55 <roconnor> but all computation is continuous
07:10:08 <migraine> most people operate on the good enough principle
07:10:26 <osfameron> most programming is done even without testing...
07:11:10 <petter_> but maybe ease of formal verification makes ease of informal verification as well?
07:11:43 <petter_> or informal reasoning...
07:11:49 <osfameron> maybe...
07:12:11 <osfameron> I think Haskell needs formal verification because it's so compact that you think about a shorter program as much as you would a longer one in another language
07:12:24 <mux> dcoutts_: ping
07:12:36 <quicksilver> osfameron: incidentally http://www.haskell.org/ghc/docs/6.6/html/building/sec-porting-ghc.html
07:12:39 <lambdabot> Title: 9. Porting GHC, http://tinyurl.com/247m3s
07:12:41 <dcoutts_> hia mux
07:12:44 <quicksilver> osfameron: answers your questions from earlier
07:12:51 <roconnor> osfameron: too bad haskell doesn't have formal semantics
07:12:57 <quicksilver> my tail recursion thread made it onto the first page of reddit
07:13:04 <migraine> but I also believe that Haskell might push people to not do any verification because it just works after compile...
07:13:25 <mux> dcoutts_: hey :) I just wanted your confirmation on this: if I have FunPtr types, the only way to call the function is to use dynamic import FFI stubs?
07:13:28 <roconnor> migraine: the fact that a program type-checks is a partial proof of correctness
07:14:30 <dcoutts_> mux: so you're trying to call through a C function pointer
07:14:59 <mux> dcoutts_: yes
07:15:01 <dcoutts_> mux: I've not done that, but import dynamic sounds sensible, check the FFI spec
07:15:07 <ndm> has the Editor flamewar poster now tried to turn it into an OS flamewar?
07:15:17 <ndm> trying to insult Emacs/VIM/Mac/Windows users
07:15:21 <mux> dcoutts_: I've found that dynamic thing in a FFI tutorial; it works but it's largely inconvenient
07:15:30 <ndm> which only leaves Linux users who like GEdit left...
07:15:44 <quicksilver> ndm: I clearly didn't handle it quite right
07:15:53 <osfameron> roconnor: eeeek!  I don't even know what that means ;-)
07:16:03 <ndm> quicksilver: real name?
07:16:08 <quicksilver> ndm: his given reasons for disliking the editors he dislikes were so shortsighted that I felt I had to ask for a bit more explanation
07:16:17 <mux> the only right way to deal with an editor flamewar is to stay silent
07:16:59 <ndm> quicksilver: yeah, i understand - the original poster now seems to have trolled in new directions...
07:17:29 <quicksilver> and if I was feeding the troll; I do also think it's an interesting debate
07:17:44 <quicksilver> I care about good editors and I genuinely want to know what people are looking for that isn't out there now
07:17:50 <osfameron> quicksilver: ta
07:17:58 <pjd> structure editing!
07:17:59 <quicksilver> I'm really surprised if the answer is 'shiny quartz-like UI widgets'
07:18:12 <quicksilver> because to me that doesn't seem a key requirement although they're cute enough :)
07:18:27 <osfameron> stuff that knows about structure and syntax highlighting, rather than pretending to like vim
07:19:08 <ndm> he's looking for Visual Haskell, even if he doesn't know it
07:19:17 <ndm> but he's also looking for the Linux port of VH
07:19:27 <quicksilver> or maybe Yi
07:19:32 <quicksilver> which isn't ready yet
07:19:43 <migraine> I need an editor with a one way nueral uplink
07:19:56 <pjd> one way?
07:20:14 <migraine> I don't want feedback... and avoids virii...
07:20:19 <Saizan> so that it can't segfault in your brain, i presumo
07:20:33 <chrismbrown_> I would quite like an editor that would do all my coding for me, without me even having to lift a finger, is that too much to ask I wonder?
07:20:50 <Saizan> hire a codemonkey!
07:21:24 <chrismbrown_> :p
07:21:38 <quicksilver> roconnor: what about 'A Static Semantics for Haskell', JFP 1998?
07:23:46 <nattfodd> is there a "central database" of cabal packages of some sort?
07:24:19 <nattfodd> I get an error when trying to build a project because it seems to retain an old dep to binary-0.2, while the new version uses 0.3
07:24:36 <nattfodd> and grep -ri binary-0.2 * in the sources return nothing
07:24:58 <roconnor> quicksilver: I hadn't heard of that paper
07:25:56 <roconnor> I had understood from reading the history of haskell paper that haskell never got formal semantics.
07:27:29 <quicksilver> I rather suspect most of the implementors felt that the formal semantics was 'fairly obvious'
07:27:41 <quicksilver> GHC works by compiling into System Fc
07:28:00 <quicksilver> which, assuming the representation of System Fc is faithful, makes GHC itself a formal semantics
07:28:08 <quicksilver> albeit a rather unpleasant one to read :)
07:29:07 <roconnor> quicksilver: well, that provides a short proof that GHC is correct :P
07:29:41 <roconnor> quicksilver: which version of GHC?
07:29:49 <roconnor> and which optimization level ;)
07:30:27 <kfish> nattfodd, HackageDB? http://hackage.haskell.org/packages/hackage.html
07:30:28 <lambdabot> Title: HackageDB: introduction
07:30:34 <quicksilver> roconnor: optimization turned off
07:30:40 <quicksilver> roconnor: whichever version had the least bugs :)
07:30:51 <nattfodd> kfish: that wouldn't leave old deps on my system, would it?
07:31:13 <roconnor> quicksilver: but the number of bugs depends on the deviation from the specification, which is what we are trying to define :P
07:31:32 <quicksilver> yup
07:31:37 <quicksilver> I agree it's a bit circular
07:31:49 <quicksilver> but there is a bit of a feeling 'hmm well we all know what the formal semantics is...'
07:31:49 <roconnor> maybe we can do a sliding window average of  versions
07:31:57 <roconnor> ;)
07:32:13 <nattfodd> http://rafb.net/p/AmTDvM45.html ← this happens even though Agda-2.0.0 has been successfully compiled and installed
07:32:15 <lambdabot> Title: Nopaste - No description
07:32:16 <roconnor> too bad the details are devilish
07:33:40 <kfish> nattfodd, what if you hack Agda's cabal file to depend on binary-0.3? ;-)
07:33:50 <nattfodd> kfish: it already does
07:34:06 <nattfodd> binary >= 0.3
07:35:28 <kfish> nattfodd, just a warning i guess ... what does "ghc-pkg list binary" give you?
07:35:57 <nattfodd> /usr/lib/ghc-6.6/package.conf: binary-0.3
07:36:02 <nattfodd> and no, it's an error, not a warning
07:36:06 <nattfodd> hence my issue :)
07:36:37 <kfish> ah, i thought you said it built ok ...
07:37:07 <nattfodd> Agda-2.0.0 build ok, Agda-executable-2.0.0 doesn't
07:37:14 <nattfodd> *builds
07:37:29 <kfish> ah ok -- I only just realized they were two separate packages :-)
07:37:47 <nattfodd> the first one has the dep on binary-0.3, the other just depends on Agda-2.0.0
07:39:11 <nattfodd> ah, just found it with the ghc-pkg command
07:39:26 <nattfodd> somehow, an old version of agda was installed in ~/.ghc/
07:39:42 <kfish> :-)
07:39:56 <quicksilver> always rm -rf ~ before installing a new package
07:39:58 <quicksilver> :P
07:40:04 <nattfodd> huh
07:40:16 <quicksilver> [ if you have a sense of humour deficit, please don't do that :P ]
07:40:39 <nattfodd> should I do that before or after uninstalling my libc?
07:41:06 <kfish> that's a very deep question, I'd suggest first setting fire to your computer, just to be sure
07:41:07 <mux> holy photon!
07:41:46 * earthy is reminded of the 'isComputerOn' and 'isComputerOnFire' calls in the BeOS API
07:50:35 <Baughn> earthy: isComputerOnFire never worked for me, and debugging the applications using it was way too expensive. >_<
07:50:44 * earthy laugsh
07:51:11 <earthy> isComputerOnFire at least always returned false for me ;)
07:51:11 <Baughn> Oh.. why does this happen?
07:51:15 <Baughn> > (- 4) 3
07:51:17 <lambdabot>   add an instance declaration for (Num (t -> a))
07:51:17 <lambdabot>     In the expression: (- 4)...
07:51:28 <sjanssen> @keal
07:51:29 <lambdabot> i want to invent white dye
07:51:32 <Syzygy-> > let isComputerOnFire = false in isComputerOnFire
07:51:33 <lambdabot>   Not in scope: `false'
07:51:35 <EvilTerran> ?type (- 4)
07:51:37 <matthew-_> > ((-) 4) 3
07:51:37 <lambdabot> forall a. (Num a) => a
07:51:38 <lambdabot>  1
07:51:41 <Syzygy-> > let isComputerOnFire = const False in isComputerOnFire
07:51:42 <lambdabot>  Add a type signature
07:51:47 <Syzygy-> > let isComputerOnFire = False in isComputerOnFire
07:51:48 <lambdabot>  False
07:52:05 <bringert> nominolo`, would you be interested in turning your HTTP work into the next version of the HTTP package?
07:52:21 <EvilTerran> Baughn, congrats, you've hit the one big stinker in the haskell syntax. - is the only prefix punctuation operator.
07:52:23 * earthy notes that matthew-_'s haskell-cafe mail got answered.
07:52:51 <EvilTerran> so (- 4) is -4, not (\x -> x-4)
07:52:54 <Baughn> EvilTerran: I thought it might be that, but why does it allow spaces between - and the number?
07:53:09 <EvilTerran> because it's an operator, not part of the number syntax.
07:53:22 <EvilTerran> i think there's a plan afoot to make it part of the number syntax in haskell'.
07:53:27 <Baughn> If that parse failed, it should fallback to the next one, namely (-)
07:53:30 <EvilTerran> meanwhile
07:53:44 <Baughn> Ah..
07:53:49 <ptolomy> Arg. http://tempe.st/2007/05/erlang-ruby-and-php-battle-it-out/ <- this is one of the silliest microbenchmarks ever, yet I couldn't resist. Also, C is still beating me by a factor of 10.
07:53:51 <lambdabot> Title: Erlang, Ruby and PHP battle it out! -- A Tempest of Thoughts
07:53:52 <Baughn> Hmm, - is read as negate?
07:54:02 <Baughn> Yes, it *should* be part of the number syntax.
07:54:20 <EvilTerran> ?src subtract
07:54:20 <lambdabot> subtract x y = y - x
07:54:35 <sjanssen> ptolomy: I took a shot at writing that in Haskell
07:54:50 <EvilTerran> Baughn: meanwhile, use subtract (as above) instead
07:54:53 <Baughn> *shudder*
07:54:57 <Baughn> > 4 `subtract` 3
07:54:59 <lambdabot>  -1
07:55:02 <sjanssen> ptolomy: I had performance issues because of a lack of truncate :: Double -> Double
07:55:05 <Baughn> As I said, *shudder*.
07:55:19 <sjanssen> ptolomy: I have a feeling that the standard truncate is slow
07:55:24 <EvilTerran> it's not meant to be used infix...
07:55:26 <matthew-_> earthy: it did indeed! You were clearly right - SPJ must have been enjoying the weekend ;)
07:55:39 <ptolomy> sjanssen: is that where we're taking a hit? I hadn't bothered profiling yet, I've just tried some obvious stuff and timed.
07:55:43 <Baughn> EvilTerran: I can see how it'll work here, but this is a major wart. :/
07:55:58 <sjanssen> ptolomy: I haven't run any numbers, but that's my guess
07:56:07 <sjanssen> s/numbers/profiling
07:56:13 <EvilTerran> Baughn, I agree totally. I guess SPJ must've wanted to leave _something_ for future generations to improve. :P
07:56:24 <Baughn> Okay, second. (Is there a tool to autoconvert C headers to FFI code?) :: Bool
07:56:32 <george--> other than in lists where i can think of countless examples... are there any simple examples of parametric polymorphism in haskell that come to mind for anyone?
07:56:48 <SamB_XP> Baughn: subtract isn't supposed to be infix...
07:56:54 <ptolomy> I was assuming that "fromIntegral (truncate x)" would end up being a trivial operation.
07:56:58 <ptolomy> but I make lots of stupid assumptions.
07:57:01 <Baughn> george--: Trees. Tables. Any arbitrary ADT, really.
07:57:26 <matthew-_> george--: Numbers
07:57:32 <george--> i keep seeing this 'adt' what is the difference between an ADT and a DT?
07:57:36 <Baughn> SamB_XP: It seems to exist for the sole purpose of working around (- 4), so indeed.
07:57:40 <sjanssen> ptolomy: the fromIntegral takes a fast path, don't know about truncate
07:57:47 <george--> what makes something abstract?
07:57:52 <SamB_XP> Baughn: true.
07:57:58 <Baughn> george--: Only specifying the interface
07:58:13 <mux> george--: const
07:58:18 <mux> @type const
07:58:20 <mux> @src const
07:58:21 <lambdabot> forall a b. a -> b -> a
07:58:21 <lambdabot> const x _ = x
07:58:28 <EvilTerran> the other alternative, btw, is
07:58:30 <mux> id
07:58:31 <EvilTerran> > (-4 +) 2
07:58:33 <lambdabot>  -2
07:58:34 <matthew-_> george--: all the monads stuff
07:58:47 <george--> would you consider IO as a abstract data type consisting of a list of commands?
07:58:55 <EvilTerran> but then it starts looking like a bastard child of perl and lisp
07:59:40 <matthew-_> george--: no, because there's not a finite number of commands.
07:59:51 <matthew-_> george--: but that's a weird reason I think.
08:00:23 <Baughn> george--: Yes, with the caveat the "command" is a typeclass and can be instanced for an infinite number of them
08:00:42 <mdmkolbe|work> I've never had to use records before, can you pattern match on them?  (I just need to examine one of the fields).  I tried "foo { field_name = 'A' } = True; foo _ = False", but the parser didn't like that.
08:01:10 <sjanssen> ptolomy: http://hpaste.org/1928 -- this is what truncate does.  There's a SPECIALIZE pragma for Double -> (Int, Double)
08:01:37 <ptolomy> yikes.
08:01:45 <EvilTerran> mdmkolbe|work: records meed to be a parameter to a type
08:02:01 <sjanssen> ptolomy: truncate = fst . properFraction
08:02:09 <george--> caveat = premise?
08:02:13 <mdmkolbe|work> EvilTerran: example?
08:04:17 <EvilTerran> mdmkolbe|work: you have to say "newtype RecordType { field::Type, ... }" (or data RecordType), and then patternmatch via foo (RecordType { field = Blagh })
08:04:39 <Baughn> george--: I suppose
08:05:00 <george--> would we consider the function that can be applied to any form of list (e.g. take or head) as parametric polymorphism or lists themselves?
08:06:05 <ptolomy> sjanssen: Hmm.. if I get a few minutes free from work, I'm going to try it with FFI C math stuff..
08:06:37 <Baughn> george--: I'm not sure what you mean by "lists themselves"
08:06:49 <Baughn> george--: take certainly is polymorphic, though
08:07:31 <mdmkolbe|work> EvilTerran: thx, now it works :-)
08:07:33 <mux> and it's indeed parametric polymorphism
08:07:38 <EvilTerran> mdmkolbe|work: no probs
08:07:45 <george--> ok. if i am asked: give an example of polymorphism... would it be valid to say: lists are polymorphic because they can be a list of any data type... or would i say: take is polymorphic because it doesnt matter what type of data type it is run on
08:07:59 <george--> s/polymorphism/parametric polymorphism
08:08:45 <matthew-_> george--: they're both polymorphic. Eg if I define a tree "data Tree a = Empty | Node (Tree a) a (Tree a)" then that is polymorphic. But I don't have any functions to work on it. Any function with an arguement of (Tree a) will be parametrically polymorphic.
08:09:21 <matthew-_> and one day I'll learn to spell argument!
08:10:05 <george--> so would one say that Tree or Lists are a polymorphic data type, and any function that can be applied to them is polymorphic also?
08:10:07 <mdmkolbe|work> george--: those examples are the same b/c (:) and [] are functions just like 'take'
08:10:12 <george--> sorry i just saw a flaw in what i said
08:10:25 <george--> some functions on lists apply only to numbers
08:10:50 <mdmkolbe|work> george--: in that case those functions over lists are not polymorphic
08:11:22 <george--> what if they work on a few data types
08:11:32 <george--> say they work on the numerical types
08:11:35 <Baughn> They're still polymorphic, just.. less so
08:12:02 <matthew-_> it's polymorphic unless it specifies a ground type
08:12:13 <george--> could we consider that ad hoc polymorphism... in the case it has a numerical type it runs... in the case it doesnt it fails :P
08:12:21 <mdmkolbe|work> george--: if you mean by a (Num a) => [a] -> [a] sort of qualification then it's called "qualified polymphism"
08:12:45 <desp> would you recommend any documents/webpages describing threads in Haskell?
08:13:09 <matthew-_> desp: there's "tackling the awkward squad"
08:13:16 <george--> so qualified polymorphism is a subset of parametric polymorphism allowing for example anything under the umbrella title of Num?
08:13:27 <desp> matthew-_: thanks, got it, it's quite helpful
08:14:18 <mdmkolbe|work> george--: yes, but technically the polymorhpisms are techniques which aren't nessiary subsets of each other, but you have the right idea
08:15:18 <mdmkolbe|work> george--: if it's specified for specific types (e.g. foo :: [Int] = implementation1; foo [Double] =implementation2) then it's ad hoc polymorphism (ad hoc = for this specific type here is this specific implementation).  It is the kind of polymorphism you see in C++, but I don't think haskell supports it (at least not directly)
08:16:01 <matthew-_> well, that's what type classes are for
08:16:08 <quicksilver> mdmkolbe|work: sure it does; type classes give you ad hoc polymorphism
08:16:45 <mdmkolbe|work> quicksilver, matthew-_: true
08:19:24 <mdmkolbe|work> george--: to avoid confusion, note that the ad hoc polymorphism provided by type classes (e.g. instance F A where foo = implementation), is on the functions in the class (e.g. foo), but when the class is used as a qualifier for another function (e.g. bar :: (F a) => a -> a)) we are talking about qualified polymorphism
08:22:18 <quicksilver> mdmkolbe|work: but interestingly, the type system can't tell them apart
08:22:25 <quicksilver> :t (+)
08:22:31 <lambdabot> forall a. (Num a) => a -> a -> a
08:22:47 <quicksilver> mdmkolbe|work: (+) is actually part of the definition of Num, so it would be ad-hoc, in your terminology
08:23:02 <quicksilver> mdmkolbe|work: but it gets the same type signature as 'mere qualified' polymorphism
08:23:14 <quicksilver> I do understand the point you're making, though
08:23:15 <mdmkolbe|work> quicksilver: heh, I'd never thought about that
08:23:34 <quicksilver> we can only actually 'write a specialised definition' for methods
08:23:46 <quicksilver> in other functions all we can do is combine methods
08:23:55 <quicksilver> so all the ad-hocness has to be 'packaged up' in those methods
08:24:23 <quicksilver> this is something which causes confusion quite often to people using typeclasses IME
08:25:51 <byorgey> so I'm reading a Functional Pearl (McIlroy, "Enumerating strings of regular languages") which claims (++) belongs to the class MonadPlus
08:26:03 <byorgey> clearly it doesn't anymore... anyone know the history of that?
08:26:17 <mdmkolbe|work> @type (++)
08:26:20 <lambdabot> forall a. [a] -> [a] -> [a]
08:26:23 <quicksilver> my understanding is the motivation was errors for newbies
08:26:32 <mdmkolbe|work> @type mplus
08:26:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:26:36 <quicksilver> some people felt that, by typeclassing 'everything'
08:26:43 <quicksilver> you got hard-to-understand errors
08:26:52 <mdmkolbe|work> byorgey: mplus == ++ for lists
08:26:54 <quicksilver> so some things were 'specialised' to list
08:27:04 <mdmkolbe|work> > "abc" `mplus` "def"
08:27:06 <lambdabot>  "abcdef"
08:27:16 <byorgey> ah, ok
08:27:19 <byorgey> thanks, that makes sense
08:27:29 <quicksilver> I think it was probably a mistake
08:27:46 <quicksilver> that is, I think it would have been better to solve the error reporting issue some other way :)
08:27:49 <quicksilver> but maybe that's not easy
08:28:23 <byorgey> I see your point
08:28:51 <quicksilver> I suppose it's not 100% clear if (++) is 'mappend' or 'mplus'
08:28:59 <quicksilver> > "abc" `mappend` "def"
08:29:00 <lambdabot>  "abcdef"
08:29:03 <quicksilver> :t mappend
08:29:06 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:29:11 <quicksilver> Monoid, MonadPlus, so many choices..
08:29:21 <Syzygy-> > "abc" `mplus` "def"
08:29:23 <lambdabot>  "abcdef"
08:29:23 <byorgey> indeed =)
08:29:27 <Syzygy-> So it's both.
08:29:40 <quicksilver> Syzygy-: right. but if you're going to make (++) a method instead of a function
08:29:45 <quicksilver> Syzygy-: which class shall you move it to?
08:29:55 <Syzygy-> Oh, bugger.
08:30:02 <Syzygy-> That's so not obvious.
08:30:07 * quicksilver grins
08:30:27 <quicksilver> of course, MonadPlus m does make 'm a' a Monoid
08:30:31 <quicksilver> using mappend = mplus
08:30:39 <quicksilver> so these things are not totally different
08:31:35 <byorgey> McIlroy defines a new data type which is basically lists with a non-standard ordering
08:31:47 <byorgey> lists are ordered first by length, then item-by-item
08:32:03 * quicksilver nods
08:32:07 <byorgey> so he defines (++) on this by just applying it to the underlying lists
08:32:15 <george--> mdmkolbe|work, i believe ad hoc polymorphism is in haskell... let me find a concrete example if i can in my notes
08:32:34 <quicksilver> george--: yes, it is, we had some discussion of it after your last comment :)
08:32:36 <byorgey> so if I wanted to translate this into the currently existing framework, how should I do it?
08:32:38 <quicksilver> george--: scroll up and read it all
08:32:56 <quicksilver> byorgey: you can redefine ++ if you want, or you can make a new function (+++) ?
08:33:18 <quicksilver> byorgey: or you can choose to use MonadPlus and `mplus`
08:33:23 <george--> will do. sorry i took a phone call since i last spoke
08:33:31 <quicksilver> byorgey: maybe that would match the book expositiion of it
08:33:43 <byorgey> quicksilver: how would I redefine ++? I tried that and ran into ambiguity errors
08:34:19 <byorgey> quicksilver: although it might be a good exercise for me to try using MonadPlus and `mplus` =)
08:34:57 <george--> so do you call qualified polymorphism ad hoc polymorphism>
08:37:00 <george--> i would say when i write my own 'show' definition for a data type i have written that this is ad hoc polymorphism... is that correct?
08:37:07 <LoganCapaldo> byorgey: you'll have to do something like import Prelude hiding ( (++) )
08:37:17 <LoganCapaldo> to avoid the ambiguity errors
08:37:19 <mdmkolbe|work> george--: I would generally consider the two different.  About 'show' you would be correct
08:37:19 <quicksilver> george--: yes, that's right
08:37:22 <pejo> quicksilver, type error reporting is non-trivial, and we all agree it should be solved. :-)
08:37:38 <int-e> > "a" Prelude.++ "b"
08:37:40 <hkBst> how can I provide command line arguments, like "do args <- getArgs" expects through inferior ghc interpreter?
08:37:41 <quicksilver> george--: ad-hoc polymorphism is when you are free to wriet completely different methods for different types
08:37:46 <lambdabot>  "ab"
08:38:01 <quicksilver> george--: the type system has no way to trying to keep you 'honest' and write 'the same meaning' for each type
08:38:06 <int-e> you *can* use infix operators with qualified names. but it's very ugly.
08:38:10 <LoganCapaldo> int-e: well I meant the case of a ++ b where he wants ++ to be his overloaded ++
08:38:16 <earthy> Bastiaan Heeren and Jurriaan Hage are working towards that goal of improving type error reporting
08:38:31 <earthy> Helium actually already is a lot better at it than say GHC
08:38:37 <quicksilver> george--: what mdmkolbe|work is calling 'qualified' polymorphism, is the same code for each type, it's just the code uses methods, so it works on various types
08:38:46 <pejo> earthy, nods, but had Heeren even started his phd at the time they chose to specialize a bunch of things for lists?
08:38:52 <int-e> LoganCapaldo: hiding ++ is better.
08:38:57 <earthy> not sure
08:39:06 <byorgey> LoganCapaldo, int-e: ok, thanks, I see.  I think I will just go with MonadPlus instead.  seems more elegant.
08:39:13 <earthy> I think he had
08:39:18 <pejo> earthy, Helium still avoids type classes though?
08:39:21 <george--> could you possibly epand on 'its just the code uses methods'?
08:39:28 <earthy> avoids, in a sense, yeah
08:39:38 <earthy> it knows about them though, and can handle them, after a fashion
08:39:47 <Syzygy-> @let (++) (a:as) (b:bs) = (++) (a:b:as) bc; (++) [] as = as; (++) as [] = as
08:39:48 <lambdabot> <local>:2:21:     Ambiguous occurrence `++'     It could refer to either `++'...
08:40:06 <earthy> and Atze Dijkstra and Jeroen Fokker are working on implementing the Helium stuff in EHC
08:40:09 <quicksilver> george--: methods are those ad-hoc polymorphic things
08:40:09 <Syzygy-> @let (++) (a:as) (b:bs) = (L.++) (a:b:as) bc; (L.++) [] as = as; (L.++) as [] = as
08:40:10 <lambdabot>  Parse error in pattern
08:40:13 <Syzygy-> Bah.
08:40:20 <quicksilver> george--: i.e. those functions defined in type class instances
08:41:12 <mdmkolbe|work> @src Monad
08:41:13 <lambdabot> class  Monad m  where
08:41:13 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:41:13 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:41:13 <lambdabot>     return      :: a -> m a
08:41:13 <lambdabot>     fail        :: String -> m a
08:41:31 <mdmkolbe|work> george--: return, >>, >>=, fail are the methods of the class Monad
08:41:38 <kaol> @src MonadPlus
08:41:38 <lambdabot> Source not found. stty: unknown mode: doofus
08:41:50 <mdmkolbe|work> @src Control.Monad.MonadPlus
08:41:51 <lambdabot> Source not found. That's something I cannot allow to happen.
08:42:10 <kaol> @src Functor
08:42:10 <lambdabot> class  Functor f  where
08:42:10 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:42:11 <george--> right... so you are in effect saying that qualified polymorphism runs the same code... but some sub function in the code is ad hoc function hence it can be considered ad hoc or qualified parametric
08:42:11 <mdmkolbe|work> @index MonadPlus
08:42:11 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:43:11 <quicksilver> george--: in your show example, 'show' is ad-hoc polymorphism
08:43:22 <hkBst> The first example in http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps works when I compile it but with inferior GHC interpreter I get "Hello, *** Exception: Prelude.(!!): index too large"
08:43:22 <quicksilver> george--: if you write another function *using* show
08:43:24 <lambdabot> http://tinyurl.com/2ejbd7
08:43:44 <quicksilver> george--: then that other function is qualified polymorphism
08:43:46 <kaol> @karma george
08:43:47 <lambdabot> george has a karma of -3
08:44:02 <pejo> Heh.
08:44:14 <george--> quiksilver and mdmkolbe|work, thanks for clearing this up in my head :)
08:45:13 <kaol> @src Arrow
08:45:13 <lambdabot> class Arrow a where
08:45:13 <lambdabot>     arr, pure   :: (b -> c) -> a b c
08:45:13 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
08:45:13 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
08:45:13 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
08:45:15 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
08:45:17 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
08:46:01 <LoganCapaldo> hkBst: you need to pass the program a command line argument
08:46:18 <LoganCapaldo> if you want to do it from within ghci
08:46:30 <LoganCapaldo> use the :set args command
08:47:00 <hkBst> LoganCapaldo: thanks, it worked
08:47:59 <ndm> hkBst: or :main argument
08:48:07 <LoganCapaldo> hkBst: notta problem
08:48:23 <LoganCapaldo> ndm: that's a neato one that I was unaware of
08:48:52 <ndm> LoganCapaldo: yeah, its relatively new - I added it to Hugs first and GHC copied
08:49:10 <hkBst> ndm: what version of GHC supports that?
08:49:18 <ndm> hkBst: GHC 6.4.2, i think
08:49:23 <LoganCapaldo> ndm: well i doubt its newness involves my surprise, me being probably newer to haskell than :main <g>
08:50:06 <mdmkolbe|work> ndm: would that be different than 'main [arg1, arg2]'?
08:50:18 <mdmkolbe|work> ndm: nvm
08:50:24 <ndm> mdmkolbe|work: yes, main :: IO (), you only get the args through getArgs
08:50:33 <george--> does anyone know a good link for a page which explains haskells class system?
08:50:37 <LoganCapaldo> I love types!
08:50:57 <ndm> you could do setCommandLineArguments ["arg1","arg2"] >> main, but its not really very nice
08:51:14 <george--> i feel im getting a bit bogged down in definitions of class type, data type, data class... etc
08:51:53 <mdmkolbe|work> george--: the only thing that helped me figure those out when I was learning haskell was the book "The Haskell School of Expression", but that was 2 yr ago, there may be better online tutorials now
08:52:05 <SamB_XP> is there some cheap book I should buy instead of Purely Functional Data Structures?
08:52:09 <earthy> LoganCapaldo: especially if seasoned with a bit of parslay? :)
08:52:12 <earthy> parsley
08:52:40 <earthy> samb: nope. then again, pfds is available online.
08:52:44 <LoganCapaldo> earthy: I think I missed the joke :)
08:53:00 <SamB_XP> earthy: pdfs aren't fun to read. and aren't those of the thesis version?
08:53:12 <earthy> those are of the thesis version, yeah
08:53:31 <mux> @hoogle octal
08:53:31 <lambdabot> Text.ParserCombinators.Parsec.Token.octal :: TokenParser st -> CharParser st Integer
08:53:49 <earthy> logancapaldo: it was almost as if you loved types as you love steaks. :)
08:53:55 <LoganCapaldo> heh
08:53:58 <earthy> (assuming you eat meat :))
08:54:00 <LoganCapaldo> I do love steaks
08:54:05 <LoganCapaldo> but which do I love more?
08:54:12 <LoganCapaldo> Hmmm
08:54:16 <mux> hmmm, there is no way to write literal octal digits in haskell?
08:54:28 <SamB_XP> > 010
08:54:29 <lambdabot>  10
08:54:33 <earthy> ghe ;)
08:54:33 <SamB_XP> I guess not
08:54:41 <earthy> no, there is none
08:54:45 <earthy> octal is deprecated
08:54:49 <SamB_XP> that would be how you would do it if there was a way, I'm pretty sure
08:55:00 <osfameron> octal is horrid
08:55:00 <SamB_XP> earthy: how can it be deprecated?
08:55:02 <earthy> > 0x10
08:55:04 <lambdabot>  16
08:55:12 <byorgey> > 0o10
08:55:13 <lambdabot>  8
08:55:16 <SamB_XP> octal is very nice when dealing with 18-bit systems
08:55:18 <earthy> oh, right. :)
08:55:20 <byorgey> not deprecated!
08:55:28 <osfameron> 18-bit?
08:55:30 <flux> or unix file permissions :)
08:55:31 <quicksilver> SamB_XP: ?
08:55:34 <SamB_XP> okay, that is disgusting...
08:55:38 <earthy> 18 bit. or 36 bit.
08:55:43 <mux> ooo, 0oXXX
08:55:44 <SamB_XP> quicksilver: like the pdp-1
08:55:44 <byorgey> hm, I knew reading the Haskell Report would come in handy someday =)
08:55:53 <quicksilver> SamB_XP: but how does octal help?
08:55:54 <mux> byorgey: thankies
08:55:59 <quicksilver> SamB_XP: 8 doesn't divide 18...
08:56:06 <osfameron> I was thinking that
08:56:09 <earthy> 3 does however
08:56:10 * quicksilver blinks
08:56:13 <quicksilver> 3 does though
08:56:15 <SamB_XP> quicksilver: and 16 doesn't divide 8
08:56:19 <quicksilver> quicksilver-- ; can't add up!
08:56:20 <LoganCapaldo> was it 18bits flat or were those 2bits tags or something?
08:56:31 <earthy> 18 bits flat existed
08:56:38 <earthy> as did 36 bit flat
08:57:06 <SamB_XP> I don't quite understand the addressing... the manual says that it can have up to 64k words...
08:57:08 <flux> octal is a more compressed way to deal with bitmasks, hex is a bit more difficult to think out in the head
08:57:18 <earthy> samb: what machine?
08:57:24 <SamB_XP> pdp-1
08:57:29 <earthy> ah. yah, makes sense
08:57:52 <earthy> 16 bit adressing into memory of 18 bit words with 2 bits for tags
08:58:11 <Modius> Have some questions - note - I am not trolling nor starting a language pi**ing match.  I know a fair bit of CL, and program stateless/lazy in other languages.  I'm pretty handy with CL macroes; but in looking at higher order functions/what people do in Haskell I'm wondering if Macros and full-powered functional aren't at some point analogous - and was wondering if anyone here has a link to something that may explore this or compare them.
08:59:00 <Modius> My goal is that regardless of what I program in, understanding of some similarity at the mathematical level (if any) would help me.
08:59:08 <SamB_XP> but... it looks like the easiest addressing mode uses only 12 bits?
08:59:33 <quicksilver> Modius: there is a strong analogy, yes
08:59:42 <quicksilver> Modius: but higher order haskell is type-checked for you
08:59:47 <quicksilver> Modius: which is an important different
09:00:18 <earthy> the electrologica x1 had 27 bit accumulators and 15k words of 28 bit memory
09:00:28 <Modius> Do you have any links to articles/papers that explore the analogue?
09:01:09 <earthy> samb: yeah, could well be
09:01:48 <quicksilver> Modius: no, not off hand. Note that Template Haskell has 'macro-like' abilities
09:01:53 <SamB_XP> Modius: I have no link, but I've noticed that lazy higher-order functions *do* seem to reduce the desire for macros...
09:02:15 <quicksilver> Modius: http://lambda-the-ultimate.org/classic/message9532.html
09:02:17 <lambdabot> Title: LtU Classic Archives
09:02:35 <quicksilver> Modius: but that thread is pretty much populated by macro fans and doesn't have many lazy-higher-order people giving their side
09:02:40 <byorgey> where can I find the source code for the list version of (>>=) ?
09:02:53 <LoganCapaldo> @src [] >>=
09:02:53 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:03:05 <LoganCapaldo> ah well
09:03:07 <quicksilver> byorgey: Data.List, I suspect
09:03:11 <LoganCapaldo> its concatMap anyways
09:03:13 <SamB_XP> @type (>>=)
09:03:17 <Modius> I don't mind a language pi**ing match between people who know what they're talking about
09:03:21 <Modius> But I don't have a "side".
09:03:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:03:26 <Philippa> For those interested: I'm attempting to organise an AngloHaskell 2007, there's an update on the AngloHaskell wiki page and #anglohaskell is once again open for business
09:03:32 <Modius> If I trick myself with a dumb rationalization, I lose.
09:03:36 <Philippa> @wiki AngloHaskell
09:03:36 <lambdabot> http://www.haskell.org/haskellwiki/AngloHaskell
09:03:43 <SamB_XP> @djinn [a] -> (a -> [b]) -> [b]
09:03:43 <lambdabot> -- f cannot be realized.
09:03:47 <SamB_XP> no lists yet?
09:03:57 <SamB_XP> @hoogle [a] -> (a -> [b]) -> [b]
09:03:58 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
09:03:58 <lambdabot> Control.Parallel.Strategies.parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
09:04:19 <earthy> instance Monad [ ] where
09:04:19 <earthy>     (x:xs) >>= f = f x ++ (xs >>= f)
09:04:19 <earthy>     []     >>= f = []
09:04:19 <earthy>     return x     = [x]
09:04:19 <earthy>     fail s       = []
09:05:15 <LoganCapaldo> @type flip concatMap
09:05:17 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
09:05:37 <drigz> @pl \f g (a,b) -> (f a, f b)
09:05:38 <lambdabot> const . (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
09:05:44 <quicksilver> Modius: well TH gives you something rather like 'type-checked macros'
09:05:52 <quicksilver> Modius: although not exactly the same
09:06:28 <drigz> what does the first entry in the /topic mean?
09:06:35 <Modius> Samb:  I understand - macroes give ability to add a language feature, part of what I'm looking into is whether ultimately HOF are an implementation of something one would want as a language feature, what one would want to contstrain (not perjorative meaning) oneself to as a language feature, or at a higher mathematical sense themselves represent the building blocks of language features
09:06:52 <Modius> TH?
09:06:57 <quicksilver> Modius: template haskell
09:07:36 <quicksilver> Modius: macros are more expressive than HOFs in the sense that a macro can do stuff like move around variable bindings
09:07:50 <Modius> I lack expertise in Haskell enough to evaluate this, I'd imagine that A:  Macroes aren't as big a deal to haskell due to having lots of features already, B:  Can't have as much impact due to non-trivial decomposition of code. . .
09:07:51 <quicksilver> Modius: that doesn't mean they're more expressive in the sense of 'can actuall do more', though
09:08:00 <mdmkolbe|work> @type forall e1 e2. e1 -> v1 && e2 -> v2 => (e1,e2) -> (v1,v2)
09:08:03 <lambdabot> Parse error in pattern
09:08:07 <SamB_XP> quicksilver: what is "do more"?
09:08:13 <osfameron> well, a macro can't *do* anything can it?
09:08:19 <SamB_XP> sure it can
09:08:27 <SamB_XP> it can reformat your hard drive
09:08:32 <osfameron> really?
09:08:34 <quicksilver> I'm being intuitive, not accurate
09:08:42 <quicksilver> obviously HOFs are turing complete and so are macros
09:08:44 <osfameron> I bet it can recompose itself into a function that can reformat your harddrive
09:08:52 <quicksilver> so in comparing expressivitivity
09:09:00 <quicksilver> we need to be a bit more careful
09:09:02 <SamB_XP> osfameron: why bother waiting for you to run the program?
09:09:17 <quicksilver> I'm asserting that HOFs can do 'the same tricks' you'd use macros for
09:09:23 <quicksilver> but they are often slightly more verbose
09:09:27 <LoganCapaldo> drigz: I think it means given a function from e1 to v1 and a function from e2 to v2 there exists a function from a pair (e1, e2) to a pair (v1, v2)
09:09:40 <quicksilver> :t (&&&)
09:09:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:10:02 <quicksilver> no, that's not it
09:10:05 <quicksilver> :t (***)
09:10:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:10:13 <quicksilver> that's the one :)
09:10:33 <osfameron> SamB_XP: a macro can call code while it's being compiled?  eeek!
09:10:34 <SamB_XP> quicksilver: well, macros can do things that HOFs cannot do, anyway. see, they have different output...
09:10:38 <Modius> Thanks, this  LTU thread seems titled as what I'm after - aside from the body-count of one "team" vs another, do you believe the haskell methodologies are represented in this thread?
09:10:44 <SamB_XP> different input, too.
09:11:39 <kfish> drigz, it's a universal quantification across the type of "Reasons that Haskell rocks"
09:11:47 <SamB_XP> but, in the cases where what you wanted to do was something that lazy HOFs are good for, it is probably easier to use a lazy HOF...
09:13:15 <drigz> LoganCapaldo: but, why? kfish: ?
09:13:31 <drigz> maybe it's something i'll understand after a few years of haskell
09:13:33 <Modius> As pointed out, since a macro can format a hard drive during compile and a HoF (to my knowledge anyway) cannot, they are mechanically different within their respective language implementations.  However, this is not the property of intersection I'm interested in.
09:14:02 <Modius> Quicksilver:  Does someone on this thread represent the haskell aspects of this question accurately?
09:14:24 <quicksilver> Modius: I read it fairly fast, I didn't see a good summary though
09:14:47 <SamB_XP> osfameron: well, how else are you supposed to read text files?
09:15:41 <osfameron> SamB_XP: I'm not understanding you
09:16:22 <kfish> drigz, dunno, I just made up that reason -- actually it looks like something to do with graph duality, but what graph? therefore Haskell rocks, QED
09:19:19 <edwardk> anyone here played around with any type system that has quotient types in it?
09:20:42 <edwardk> i was playing around with my toy language's subset types and realized that nuprl style quotient types fit in nicely as well and i was curious if anyone had found them all that useful
09:21:31 <swiert> edwardk: Yes!
09:21:50 <edwardk> swiert, cool =)
09:21:59 <swiert> There's a whole lot of cool stuff I'd like to do with quotient types.
09:22:10 <edwardk> i was thinking about adding them in because they nicely complement subset types, you can use them in the opposite cases
09:22:25 <mdmkolbe|work> edwardk, swiert: paper? link? language?
09:22:33 <edwardk> uh
09:22:38 <swiert> Write an implementation of sets using lists, ...
09:22:52 <swiert> I can't remember where they came up the recently.
09:23:23 <edwardk> basically a quotient type would look something like u,v : A // E u v, where x == y iff E x y, so you basically define a new equality over the base type.
09:24:18 <swiert> Oh now I remember. You need quotient types to compute the coproduct of monads nicely.
09:24:31 <swiert> Well, reasonably nicely at least.
09:24:44 <edwardk> so in contrast to a subset type, { x : T | P x } where you can always pass a subset type into a function where a base type was expected, and you can always treat a result that returns a subset type as the base type, with quotient types the opposite holds, you can always treat a value of the base type as the quotient, and you can always transform a function that accepts the quotient type into one that accepts the base type
09:26:03 <swiert> edwardk: but how do you ensure that functions from a quotient respect the equivalence relation?
09:26:20 <edwardk> so, you could say that basically you have some sort of operator like (//) :: Pi t : type. (t -> t -> bool) -> Quotient t  which takes a type, and a boolean function over that type, and returns a newtype
09:26:23 <swiert> Otherwise, I could decide on what to do, depending which element of the equivalence class I get to see.
09:27:37 <edwardk> its probably true that you'd need some form of canonicalization or proof obligation for the last part.
09:28:03 <edwardk> but if you can't inspect a value of the quotient type with the equality operator of the base type, then you have no issues there
09:28:24 <quicksilver> but then what *can* you do on the quotient type?
09:28:27 <quicksilver> this is the question
09:28:31 <edwardk> heh
09:28:33 <edwardk> not sure yet =)
09:28:35 <quicksilver> what operations are there that you can use on it?
09:28:41 <quicksilver> can you pattern match it, and if so, how?
09:28:42 <edwardk> thats why i'm in here asking questions =)
09:28:48 <quicksilver> (if not, it's going to be hard writing functions)
09:29:35 <quicksilver> obviously one way is to allow pattern matching against a 'representative' of the equivalence class
09:29:43 <quicksilver> but then you need to ensure well-definedness
09:29:51 <edwardk> yeah
09:30:12 <quicksilver> I'm sure there's work out there on it
09:30:13 <edwardk> this is my first day really thinking about them
09:30:14 <quicksilver> not my area, though
09:30:18 <edwardk> there is, in nuprl, etc.
09:31:01 <quicksilver> I see there is a ghani-mcbride paper on it
09:31:08 <quicksilver> first thign I'd do is go read that :)
09:31:10 <edwardk> right now i'm thinking of them as blind except for equality checking, but i think you need a wider class of base functions perhaps
09:31:14 <Modius> Quicksilver:  The macro stuff was well represented; but comprised stuff I already knew :(  I'm starting to back away from my original premise though as I think about it - a statically typed and dynamically typed "best of breed" languages may both be fundamentally different even while being high on the expressive power chain.
09:31:15 <edwardk> i did =)
09:31:41 <quicksilver> Modius: I think that's true
09:31:50 <quicksilver> Modius: I'd encourage you to investigate template haskell
09:32:02 <Modius> Quicksilver:  Probably more important for me to investigage plain haskell ;)
09:32:05 <quicksilver> Modius: and see to what extent you'd agree with my assertion that it amounts to 'type-safe macros'
09:32:21 <Modius> Type-safe macros ain't macros ;)
09:32:31 <quicksilver> I question that
09:32:44 <quicksilver> I suspect most 'sane' uses of macros admit a typing discipline
09:32:47 <Modius> Tongue-in-cheek, an irrelevant statement on my part.
09:32:54 <quicksilver> (although it may be a tricky one to formalise)
09:33:04 <quicksilver> most 'sane' lisp programs admit a typing discipline
09:33:10 <quicksilver> but, again, it may be a subtle one
09:33:12 <Modius> I've taken advantage of static typing (albeit in lower languages than haskell), taken advantage of dynamic typing (including in lisp macros).
09:33:22 <LoganCapaldo> when are they type-safe though? Do they get type checked before or after the macro gets expanded?
09:33:43 <Modius> I think he meant the mental exercise of saying:  "Okay, this is typeless but I'm writing it to only work with numbers"
09:34:05 <quicksilver> LoganCapaldo: they are type safe in a higher type system
09:34:15 <quicksilver> LoganCapaldo: they are type safe in the sense that they produce admissible haskell programs
09:34:22 <Modius> Although it lets you "bend" the rule without extra syntax:  "This function takes and emits lambdas and associates them with parameter lists - god knows what's in those lambda lists, though, as this macro acommodates whatever the user's twisted little mind decides"
09:34:23 <quicksilver> LoganCapaldo: rather than broken chunks of code
09:34:34 <Modius> "This list contains lambdas each of which may have any parameter count"
09:34:43 * quicksilver nods
09:35:04 <quicksilver> macros are often used to bypass weaknesses in particular lisp variants
09:35:07 <LoganCapaldo> quicksilver: Ok, so can they emit "non-broken" chunks of code that don't type check? I'm just curious
09:35:15 <quicksilver> (or, things which would be weaknesses without macros)
09:35:44 <Modius> Macros are ultimately part of the language.  Wtihout macros lisp wouldn't be worth discussing; but they are part and parcel of the whole picture.
09:35:51 <quicksilver> absolutely
09:35:56 <quicksilver> that's why I qualified
09:36:01 <Modius> Macroless lisp is only discussed to compare the non-macro language with other languages
09:36:10 <quicksilver> obviously those aren't really "weaknesses", because macros were always in mind
09:36:44 <Modius> Haskell is in my future.  It's apples and oranges comparing dyn typed with stat typed in lower statically typed languages.
09:36:57 <quicksilver> LoganCapaldo: well you never really get to see the code thats emitted
09:37:01 <quicksilver> LoganCapaldo: and you get the type errors
09:37:10 <Philippa> haskell is a fair way away from the totality of what we know's possible with static typing even now, too
09:37:22 <quicksilver> LoganCapaldo: I'm not familiar with the details of which stage emits which errors
09:37:35 <LoganCapaldo> quicksilver: ok
09:37:52 <quicksilver> Modius: nonetheless, someone who wants to make a nice fruit salad must understand the relative merits of apples and oranges, as well as exotic fruits
09:37:54 <flux> is type information available during the template haskell-stage?
09:37:54 <Modius> (I appreciate Haskell also for its forced segregated state)
09:37:56 <quicksilver> Modius: :)
09:38:08 <Modius> By apples and oranges  I meant C# vs. Lisp - I should have qualified that.
09:38:14 <quicksilver> flux: yes, you can manipulate types explicitly
09:38:39 <DRMacIver> I have mixed feelings about the forced segregated state.
09:38:40 <Modius> What I meant to say was to properly understand the pros/cons of dynamic vs. static typed I have to compare CL with Haskell of near equivalent.
09:38:52 <quicksilver> Modius: I understand your point
09:39:06 <flux> can template haskell do something like 'write sql statement here and it'll be checked from the sql server that it'll work'?
09:39:11 <quicksilver> I'm very strongly biased, so I don't think I can satisfactorily answre it
09:39:15 <Modius> Segregating state is something I've done for a long time even in C++ (const and such); but it can likely be explored better where there's language backup for the idea.
09:39:22 <SamB_XP> flux: that sounds a bit over-the-top
09:39:26 <quicksilver> flux: I don't believe so; I don't think it can do IO at compile time
09:39:34 <quicksilver> SamB_XP: it's actually a very powerful thing
09:39:38 <quicksilver> SamB_XP: see LinQ
09:39:41 <DRMacIver> SamB_XP: Seems entirely reasonable to me. :)
09:39:46 <SamB_XP> mostly because you'd need to access the SQL server to compile your program
09:39:49 <flux> I'm just thinking how it's different from ocaml's camlp4
09:40:08 <SamB_XP> but you could if you wanted
09:40:18 <quicksilver> SamB_XP: well you need access to your SQL schema at compile time, not necessarily your production server
09:40:26 <LoganCapaldo> SamB_XP: but wouldn't it be worth it?
09:40:27 <EvilTerran> quicksilver: Language.Haskell.TH.runIO ?
09:40:35 <SamB_XP> yeah, accessing the schema would be smarter
09:40:40 <flux> samb_xp, well, the information could be stored to a file if no sql server was available
09:40:43 <Philippa> flux: you can do arbitrary IO from the quotation monad
09:40:44 <SamB_XP> -- you do have a seperate schema right?
09:40:44 <quicksilver> SamB_XP: and that is a great thing to have, if it gives you compile-time query safety without boilerplate
09:40:57 <quicksilver> I stand corrected, thanks to EvilTerran and Philippa  :)
09:41:34 <edwardk> so basically the resulting quotient type doesn't permit much except checking equality, not sure thats terrible in all cases. maybe provide an additional method to extract a canonical form if you want more?
09:49:27 <LoganCapaldo> Hmm, is there a way to (usefully) pattern match on arrays?
09:50:55 <Jessehk> I think I finally get State monads, and I wrote a contrived example. Looks good? http://hpaste.org/1930
09:52:13 <mdmkolbe|work> Jessehk: at first glance it looks right
09:52:27 <mdmkolbe|work> Jessehk: but I've a few annotations
09:53:07 <Jessehk> mdmkolbe|work: I'd love to see them. :)
09:53:24 <LoganCapaldo> Jessehk: in takeTest, theres no reason to use return $ testScore h
09:53:42 <LoganCapaldo> you can just let (s, h') = testScore h
09:54:13 <Jessehk> LoganCapaldo: I thought so, but here http://www.haskell.org/all_about_monads/html/statemonad.html at the bottom of the page, they used the extra return
09:54:14 <lambdabot> Title: The State monad
09:54:23 <Jessehk> I thought it was just necessary for some reason.
09:54:26 <mdmkolbe|work> Jessehk: working on them ;-)
09:55:04 <LoganCapaldo> So they do.
09:55:09 <LoganCapaldo> I wonder why
09:57:13 <LoganCapaldo> Could you always use let like that in do blocks?
09:57:40 <mdmkolbe|work> http://hpaste.org/1930#a1
09:58:24 <mdmkolbe|work> Jessehk: you might also want to consier useing 'modify', but that would require changing your testScore function
09:58:26 <mdmkolbe|work> @type modify
09:58:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
09:58:37 <mdmkolbe|work> @src modify
09:58:38 <lambdabot> Source not found. Take a stress pill and think things over.
09:58:56 <mdmkolbe|work> modify f = do { s <- get; put (f s) }
10:00:31 <LoganCapaldo> modify (snd . testScore)
10:00:45 <byorgey> couldn't "juneExam <- takeTest; return juneExam" also be replaced by just "takeTest"?
10:01:01 <int-e> byorgey: yes
10:01:05 <mdmkolbe|work> LoganCapaldo: yeah, but you'd need some way to get the test score not just the state
10:01:31 <LoganCapaldo> mdmkolbe|work: trueness
10:02:02 <mdmkolbe|work> Hmm hpaste doesnt' seem to anounce annotations
10:02:16 <LoganCapaldo> it used to, I thought
10:02:47 <Jessehk> mdmkolbe|work: Thanks for the tips. :)
10:03:10 <chessguy> Jessehk: cute example
10:03:11 <mdmkolbe|work> LoganCapaldo: I just pasted, and it didn't anounce.
10:03:19 <int-e> @. pl undo do juneExam <- takeTest; return juneExam
10:03:19 <lambdabot> takeTest
10:03:25 <LoganCapaldo> mdmkolbe|work: I know
10:03:25 <mdmkolbe|work> could someone else test a paste and see if it announced
10:03:31 <LoganCapaldo> I was jsut saying it used to, I thought
10:03:36 <int-e> @seen hpaste
10:03:36 <lambdabot> I saw hpaste leaving #haskell 2d 13h 39m 59s ago, and .
10:03:54 <int-e> mdmkolbe|work: won't work without the announcer bot.
10:04:10 <chessguy> well, that could be why :)
10:04:22 <mdmkolbe|work> lambdabot: go fetch hpaste
10:04:29 <mdmkolbe|work> oh, well
10:04:38 <chessguy> sjanssen: can you revive hpaste?
10:05:15 <sjanssen> chessguy: I don't think I have that power
10:05:19 <sjanssen> @seen glguy
10:05:20 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
10:05:21 <chessguy> sjanssen: ok
10:05:28 <chessguy> i think glguy is off in the Caribbean
10:05:33 <sjanssen> ah
10:05:38 <sjanssen> maybe shapr can do it?
10:05:53 <chessguy> shapr: do you have the ability to resuscitate hpaste?
10:06:00 <shapr> Er, maybe
10:06:00 <chessguy> @seen shapr
10:06:00 <lambdabot> shapr is in #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 1s ago.
10:06:16 <shapr> seems to be running
10:06:49 <chessguy> maybe a kill/restart?
10:06:50 <mdmkolbe|work> shapr: I think chessguy is refering to the hpaste bot, not the page
10:07:06 <chessguy> yeah, sorry
10:10:12 <chessguy> !paste
10:10:31 <shapr> I'll try kill/restart.
10:10:32 <shapr> Hm, what's the direct all pipes to dev/null?
10:10:33 <Jessehk> So what could other situations be? Maybe in a game, you have to figure out the speed of an object after an "n" number of collisions with different parts of its environment?
10:10:33 <shapr> Is it 2&>1 ?
10:10:33 <Jessehk> stuff like that?
10:10:33 <LoganCapaldo> 2>&1
10:10:33 <int-e> >/dev/null 2>&1 (order matters I think)
10:10:33 <shapr> LoganCapaldo: Thanks,
10:10:33 <shapr> int-e: you too :-)
10:10:34 <LoganCapaldo> or you can just 2>/dev/null 1>/dev/null
10:10:34 <timthelion> @scr unwords
10:10:34 <lambdabot> Maybe you meant: arr rc src
10:10:34 <timthelion> @src unwords
10:10:34 <lambdabot> unwords [] = ""
10:10:34 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
10:10:34 <sjanssen> @seen hpaste
10:10:34 <sjanssen> @botsnack
10:10:34 <lambdabot> I saw hpaste leaving #haskell 2d 13h 45m 51s ago, and .
10:10:34 <lambdabot> :)
10:10:36 <int-e> uh wow.
10:10:36 <shapr> grr
10:10:48 <chessguy> what the...
10:11:14 <mdmkolbe|work> Jessehk: what are you asking?
10:11:14 <shapr> For some reason I can't start screen.
10:11:21 <timthelion> where would I find a list of functions in a modual?  Say Directory
10:11:33 <Jessehk> mdmkolbe|work: I don't even know anymore. :)
10:11:37 <mdmkolbe|work> @docs
10:11:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:11:45 <Jessehk> Thanks for the advice all. :)
10:11:46 <int-e> timthelion: in ghci type :browse <module name> - or browse the docs
10:11:51 <mdmkolbe|work> timthelion: do you mean http://haskell.org/ghc/docs/latest/html/libraries/index.html ?
10:11:56 <ndm> @remember mnislaih When one of the Simons says that he is having trouble reading your code, you ought to listen!
10:11:56 <lambdabot> Done.
10:12:13 <sjanssen> hmm, is freenode angry at hpaste?
10:12:34 <mnislaih> did I think that loud or actually write it publicly ?
10:13:11 <shapr> sjanssen: Nah, just that I'm having problems starting it. The /dev/null stuff didn't work, and screen won't start, so I'm pulling the latest HAppS that  uses hslogger instead.
10:13:11 <ndm> mnislaih: did i mind read it or did i copy and paste it?
10:13:35 <mnislaih> ok, the mail had copy to ghc-cvs,
10:13:52 <mnislaih> btw neil, I want my karma points for fulfilling my promise of filepath'ing Cabal
10:13:56 <mnislaih> :)
10:14:38 <Jessehk> Wait a second. Can't my takeTest function just be:  takeTest = State testScore
10:15:06 <ndm> @karma+ mnislaih
10:15:06 <lambdabot> mnislaih's karma raised to 6.
10:15:07 <int-e> shapr: were you missing a nohup maybe?
10:15:11 <ndm> mnislaih: you deserve them
10:15:23 <mdmkolbe|work> Jessehk: perhapse, but that isn't the usual way to write them
10:15:31 <ndm> mnislaih: if you take the next step and convert GHC (as Simon opened a bug for it) you get more karma...
10:15:46 <ndm> although its probably an ideal beginner bug, so best if someone new tries it, to get experience
10:15:49 <mnislaih> that would be a whole truck of karma !
10:16:16 * mnislaih is too busy faking work
10:16:33 <Saizan> convert ghc to filepath?
10:16:34 <mdmkolbe|work> Jessehk: because the type of monad often changes as the project grows, you want to try to only use the functions in a monad *class* without refering to the specific monad data type.  that way when it comes time to upgrade to monad transformers the transition will be easier
10:17:02 <mdmkolbe|work> Jessehk: e.g. get and put are in the class MonadState
10:17:09 <Jessehk> yup
10:18:24 <ashish> I am a Haskell newbie. Just wanted to know if there is any GUI DSL written in Haskell that I can use?
10:19:49 <araujo> ashish, DSL?
10:20:08 <chessguy> ashish: if you mean a binding of a popular graphics toolkit, you want gtk2hs
10:20:11 <mdmkolbe|work> ashish: there are a number of them, but not any thing that has taken over.  just to check you're asking for a DSL and not and IDE right?
10:20:11 <chessguy> ?where gtk2hs
10:20:11 <lambdabot> http://haskell.org/gtk2hs/
10:20:41 <timthelion> is there an unwords that would leave any newlines, at the end of words?
10:20:58 <timthelion> I mean words, not unwords
10:21:11 <chessguy> ?src words
10:21:11 <lambdabot> words s = case dropWhile isSpace s of
10:21:11 <lambdabot>     "" -> []
10:21:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:21:34 <timthelion> hmm,
10:21:35 <cjeris> can somebody point me to a good book or paper to understand what is codata?
10:21:43 <mdmkolbe|work> ashish: the DSL's I was refering to are more researchy like Yampa, FRAN, Fruit, etc.  But as chessguy points out there are wxWindows, and gtk bindings for Haskell
10:21:46 <chessguy> timthelion: you mean at the end of each individual word, or at the end of the line?
10:22:09 <ashish> Yes, that's right. I want a DSL and GUI.
10:22:13 <timthelion> well, I have some text, and putting it through my program it looses all newline chars
10:22:14 <chessguy> and gtk is the only binding (i think) in the standard library
10:22:26 <timthelion> and that is the only thing I can think of that would be stripping it.
10:22:50 <chessguy> timthelion: are you using lines and unlines?
10:22:51 <byorgey> timthelion: try map words . lines
10:23:08 <timthelion> no I am not using lines and unlines
10:23:28 <chessguy> timthelion: you probably want to
10:23:38 <timthelion> > words "hello \n hi"
10:23:39 <lambdabot>  ["hello","hi"]
10:23:42 <chessguy> timthelion: pasting your code would make it a lot easier for us to help you
10:23:49 <timthelion> you see that is the problem
10:23:54 <timthelion> it discards the \n
10:24:13 <ashish> I have taken a brief look at gtk2hs and wxWindows. However, they are more like API than DSL.
10:24:19 <chessguy> > map words . lines "hello \n hi"
10:24:20 <lambdabot>  Couldn't match expected type `a -> [String]'
10:24:25 <ashish> you need create a window, then set its title, etc.
10:24:32 <chessguy> > map (words . lines) "hello \n hi"
10:24:33 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
10:24:41 <ashish> What I want is more declaratative language for GUI programming.
10:24:48 <dcoutts_> ashish: they are 'medium level' GUI apis, not high level ones which is perhaps what you are looking for.
10:24:59 <psnl> ashish: a la glade?
10:25:00 <chessguy> > lines "hello \n hi"
10:25:02 <lambdabot>  ["hello "," hi"]
10:25:04 <timthelion> hpaste is down for me.
10:25:08 <mdmkolbe|work> ashish: higher level DSL's are an active research area.  Best example right now is probably Yampa (but it's kind of heady)
10:25:11 <mdmkolbe|work> @where yampa
10:25:12 <lambdabot> http://www.haskell.org/yampa/
10:25:12 <ashish> psnl: yes, similar to glade
10:25:14 <byorgey> > (map words . lines) "hello \n hi"
10:25:16 <lambdabot>  [["hello"],["hi"]]
10:25:21 <mdmkolbe|work> @where fran
10:25:22 <lambdabot> I know nothing about fran.
10:25:26 <mdmkolbe|work> @help fruit
10:25:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:25:27 <dcoutts_> ashish: however there are currently no mature high level gui apis for Haskell
10:25:30 <mdmkolbe|work> @where fruit
10:25:31 <lambdabot> http://haskell.org/fruit/
10:25:33 <psnl> ashish: you can use glade with haskell, but I haven't seen a replacement yet.
10:25:33 <timthelion> > (map words . lines) "hello \n hi yo"
10:25:34 <lambdabot>  [["hello"],["hi","yo"]]
10:25:46 <dcoutts_> ashish: there are several less mature ones
10:26:01 <timthelion> I guess I'll use that.
10:26:12 <byorgey> timthelion: then unlines puts the newline characters back in
10:26:22 <int-e> hmm, type family question: is http://paste.lisp.org/display/41542 supposed to work? (it gives a compile error with darcs ghc of yesterday)
10:26:25 <timthelion> ok, thankyou
10:26:28 <ashish> thanks a lot for pointers to Yampa nad Fruit. I will try them out.
10:26:28 <byorgey> > unlines ["blah", "2", "4"]
10:26:29 <lambdabot>  "blah\n2\n4\n"
10:26:52 <dcoutts_> ashish: you can use glade with Gtk2Hs, it's a good combo
10:26:55 <Speck> I am interested in writing my first haskell program after ~1 yr of lurking and reading. It's a XQuery processor/compiler in the spirit of Pathfinder-XQuery. I want to start with an XQuery parser that normalizes into XQuery core. The compilation phase will involve lots of optimizations which I was hoping to accomplish  in the style of Yampa/GADT -- basically I am wondering what would be a...
10:26:56 <Speck> ...good starting point for me. Should I start parsing with Parsec or something else? Should I use a GADT as the data type for the XQuery (and Core) language ASTs?
10:27:10 <dcoutts_> ashish: glade 2, or 3 or probably gazpatcho
10:28:31 <Philippa> Speck: If Parsec can't solve your parsing problem and it's not because you need ambiguity, odds are none of the other libs will. Other libs may yield faster parsers
10:28:34 <jmob> Anyone have suggestions for building Haskell projects?  Makefiles?
10:28:39 <Philippa> A GADT is a good start, yeah
10:28:51 <shapr> jmob: cabal
10:29:34 <jmob> Is it easy to use? :)
10:29:47 <sjanssen> jmob: yeah, pretty easy
10:30:16 <sjanssen> http://darcs.haskell.org/~sjanssen/xmonad/xmonad.cabal -- is a trivial .cabal file
10:30:27 <mdmkolbe|work> is Cabal more building oriented or packaging oriented?
10:31:16 <sjanssen> mdmkolbe|work: it has features for both
10:31:54 <Speck> Philippa: thanks, the parsing doesn't need to be lighting fast, because future plans include compiled queries to skip the parsing phase during query execution -- do you know of a reference I could refer to that uses GADTs in this way?
10:32:23 <Speck> Philippa: i.e., using GADTs to encode ASTs and the functions to translate between GADTs
10:32:52 <Philippa> algebraic datatypes're a natural way to encode ASTs anyway
10:33:07 <Philippa> functions to translate from one AST type to another sound like compilers to me :-)
10:33:50 <Speck> Philippa: in this context it's just expanding syntax sugar into a simpler core dialect, so not quite a compiler
10:34:49 <Speck> but I mostly wanted to know whether I was right to start with Parsec/GADTs -- I won't have any questions of value until I start coding.
10:36:36 <mdmkolbe|work> Speck: have you ever written at least a lambda calulus interpreter (or compiler)?  If not I would recommend you start with writting a micro-ML only then move up to XPath/XQuere
10:37:20 <Philippa> Speck: it's still technically a compiler. But yes, you're starting in the right place
10:37:40 <Philippa> mdmkolbe|work: good advice
10:37:48 <mdmkolbe|work> Speck: it shouldn't take more than a couple weeks and afterwards you should have a good understanding of Parsec/GADTs which will help you in designing how you will use them in XPath/etc.
10:38:10 <Speck> mdmkolbe|work: that's a good idea -- though I have read through many tutorials on that subject (and the write-your-own-scheme tutorial) so I hope I can skip ahead to this. We'll see though. Writing the code itself may force me to step back and do something simpler.
10:38:44 <Philippa> where plausible I'd advise doing an interpreter before doing anything that smells like a compiler
10:39:23 <george--> length [1..]
10:39:31 <george--> > length [1..]
10:39:38 <lambdabot> Terminated
10:41:00 <mdmkolbe|work> george--: that function goes on forever (it doesn't terminate), dispite what lambdabot says.  (Terminated means it forcably stopped the thread)
10:41:24 <george--> yeah :) i just wondered how he would deal with it
10:42:13 <mdmkolbe|work> george--: if you did that in GHCi, it would probalby just keep going until you hit Ctrl-C
10:42:19 <mdmkolbe|work> > let f = f in f
10:42:21 <lambdabot>  Exception: <<loop>>
10:42:29 <mdmkolbe|work> > let f () = f () in f ()
10:42:31 <lambdabot>  Exception: <<loop>>
10:42:43 <mdmkolbe|work> let f x = f (x+1) in f 0
10:42:46 <mdmkolbe|work> > let f x = f (x+1) in f 0
10:42:52 <lambdabot> Terminated
10:43:22 <kaol> > let f x = f (x*2) in f 0
10:43:28 <lambdabot> Terminated
10:43:35 <mdmkolbe|work> george--: haskell can sometimes detect loops, but don't count on it
10:43:52 <mdmkolbe|work> > undefined
10:43:54 <lambdabot>  Undefined
10:44:05 <kaol> shouldn't lambdabot see that the above is 0? ;-)
10:44:16 <chessguy> @karma george
10:44:17 <lambdabot> george has a karma of -3
10:44:21 <chessguy> muahaha
10:44:51 <mdmkolbe|work> > let f x = f (x*#2#) in f 0#
10:44:52 <lambdabot>  Parse error
10:45:03 <chessguy--> hi
10:45:13 <mdmkolbe|work> kaol: it's ghc really, not lambdabot
10:45:38 <int-e> kaol: that is not 0
10:46:11 <int-e> > let f x = f (x*2) in f 0 :: Bool
10:46:17 <lambdabot> Terminated
10:46:22 <chessguy> @karma
10:46:23 <lambdabot> You have a karma of 6
10:49:32 <int-e> I have a type family question (playing with ghc head): http://paste.lisp.org/display/41542 -- should this code work? as far as my understanding goes the compiler should generate a type coercion from Int to BB Int.
10:50:00 <int-e> ghc doesn't like it though.
10:52:59 <mdmkolbe|work> Does there exists a good intro to type families?  (They sound scary)
10:53:18 <kaol> > if all (\(x,y,z) -> x+y/=z) ([(a^2,b^2,c^2) | a <- [1..], b <- [1..a], c <- [1..a]]) then 1 else 0
10:53:24 <lambdabot> Terminated
10:53:28 <george--> im reading on haskell.org/tutorial and one line is: Here is an example of a type with just one data constructor:
10:53:28 <george--> data Point a            = Pt a a
10:53:37 <george--> what possible use does this have?
10:53:47 <kaol> lambdabot won't prove fermat's last theorem for me :-/
10:53:52 <LoganCapaldo> george--: a pedagogical example?
10:54:09 <george--> please
10:54:12 <mdmkolbe|work> george--: it's like a tuple, but can't be confused with a tuple b/c it's of different type
10:54:32 <ptolomy> sjanssen: I checked. When I used CDouble and an imported 'trunc' from math.h, the runtime went down from 13.6 seconds to 1.3. Truncate considered slow.
10:54:32 <LoganCapaldo> that's true too
10:54:45 <LoganCapaldo> you'll never accidently pass an (a, a) that isn't a point
10:54:49 <george-->  idont know what a tuple is
10:54:52 <int-e> mdmkolbe|work: http://haskell.org/haskellwiki/GHC/Indexed_types and http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions is what I found so far
10:54:53 <lambdabot> Title: GHC/Indexed types - HaskellWiki
10:55:06 <mdmkolbe|work> george--: have you seen pairs?
10:55:11 <george--> yea
10:55:28 <sjanssen> ptolomy: good to know :)
10:55:35 <mdmkolbe|work> george--: a tuple is the generalization of pair to more than two elements
10:55:41 <mdmkolbe|work> > (1, 2, 3)
10:55:42 <lambdabot>  (1,2,3)
10:55:44 <mdmkolbe|work> @type (1, 2, 3)
10:55:47 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
10:55:50 <ptolomy> FFI + unsafePerformIO is a dark seductive evil.
10:55:56 <george--> (1,2,3) is a tuple?
10:56:00 <mdmkolbe|work> george--: yes
10:56:09 <mdmkolbe|work> george--: all pairs are also tuples
10:56:10 <LoganCapaldo> yes, its a 3-tuple
10:56:10 <george--> as is (1,2,3,4)?
10:56:14 <sjanssen> ptolomy: and that 1.3s includes the overhead of making a call into C.  That's probably expensive in this test case
10:56:16 <mdmkolbe|work> george--: yes
10:56:30 <george--> ok :)
10:56:38 <mdmkolbe|work> george--: but they are differently typed tuples.  you can't use a 3-tuple in place of a 4-tuple
10:56:43 <int-e> mdmkolbe|work: oh. I should've read the implementation status page. it lists, as todo: "Type checking of type functions (and hence, associated type synonyms)"
10:56:53 <sjanssen> ptolomy: how quick does the C version run on your machine?
10:57:10 <LoganCapaldo> > (3, "I am also a tupe", Just True)
10:57:11 <lambdabot>  (3,"I am also a tupe",Just True)
10:57:16 <ptolomy> sjanssen:  0.6 seconds, roughly.
10:57:22 <mdmkolbe|work> > f x = if x then (True, 1, 2) else (3, 1, 2)
10:57:22 <lambdabot>  Parse error
10:57:35 <mdmkolbe|work> > let f x = if x then (True, 1, 2) else (3, 1, 2) in f
10:57:36 <lambdabot>   add an instance declaration for (Num Bool)
10:57:36 <lambdabot>     In the expression: 3
10:57:36 <lambdabot>     In ...
10:57:54 <LoganCapaldo> type classes really make those error messages confusing
10:57:57 <ptolomy> 2.1 times faster than raw C is pretty reasonable for a simple numeric iterative program as far as I'm concerned.
10:58:18 <mdmkolbe|work> LoganCapaldo: heh, yeah
10:58:39 <LoganCapaldo> Did anyone really ever say "Oops! I totally forgot to make my type an instance of Blah! Let me go do that now..."
10:58:54 <mdmkolbe|work> george--: so anyway, any place I said tuple in my original reply you can just mentally substitute 'pair' for now
10:58:57 <byorgey> LoganCapaldo: I have...
10:59:23 <LoganCapaldo> byorgey: more often than the alternative scenario?
10:59:36 <byorgey> LoganCapaldo: well... ;-)
10:59:59 <george--> what advantages and disadvantages do you consider from haskells type system (other than to me what is obvious is that type errors dont get compiled)?
11:00:18 <george--> i dont know if type errors getting compiled is a proble in other languages or not
11:00:30 <mdmkolbe|work> george--: compared to what? C? Scheme? Javascript?
11:00:48 <george--> for example purpose... C or Java?
11:01:43 <nattfodd> george--: if your code passes compilation, it has good chances to be reasonably bug-free
11:02:13 <mdmkolbe|work> I second nattfodd's optionon
11:02:20 <Speck> has parsec been integrated with bytestring or is that still in progress?
11:02:28 <int-e> it also makes refactoring code easier - most mistakes that you can make there are also caught while type checking.
11:02:34 <mdmkolbe|work> For a while Haskell ruined by debugging skills b/c I never needed to use them
11:03:13 <george--> does anyone see any disadvantages with haskells type system?
11:03:26 <titusg> nattfodd: it has a (very) good chance of being well-typed. it's still eminently possible to make mistakes of course.
11:03:26 <ptolomy> Haskell makes it easier for me to reason about code, because often times the type of the function is about as good as its name (especially with good type aliases).
11:03:42 <sjanssen> george--: nope.  The type system is perfect. ;)
11:03:48 <ptolomy> george--: Sloppy one-off programs still require thought.
11:03:51 <byorgey> george--: it's difficult for 5-year-olds to understand.
11:04:16 <nattfodd> titusg: yes of course, but a rough estimate from my C / Ocaml experiences shows about 60% of bugs were caught by type system
11:04:18 <george--> sjanssen, is this just the opinion of an advocate?
11:04:20 <LoganCapaldo> Those poor five year olds
11:04:21 <mdmkolbe|work> george--: it can lead to a false sence of security if you use it wrong.  and sometimes it makes you have to think a lot harder about the problem (good in the long run, but sometimes things that are easy in other languages become research topics in Haskell)
11:04:21 <int-e> the only disadvantage that I can think of is that it's sometimes verbose and occasionally gets in the way for "obviously safe" code.
11:04:36 <int-e> oh and I occasionally miss implicit conversions for numbers.
11:04:39 <sjanssen> george--: I'm just joking
11:04:50 * mux nods at int-e 
11:04:56 <titusg> nattfodd: indeed
11:04:58 <george--> mdmkolbe|work, what type of thing would be easy in another language and a research topic in haskell?
11:05:07 <nattfodd> ptolomy: heh tell me about it, in agda 80% of my code is just types
11:05:14 <nattfodd> and usually the function itself is completely trivial
11:05:36 <mdmkolbe|work> george--: oh, and you want to put type signatures on all top level functions otherwise GHC will tell you there is a type error in one function when it's really another functions fault
11:05:56 <nattfodd> george--: IO ?
11:05:58 <george--> i put type signatures on all my functions :D
11:06:17 <mdmkolbe|work> george--: well most of the trouble is b/c Haskell doesn't allow side effects (e.g. IO, editable data types, etc.)
11:06:36 <int-e> george--: yes, that's a good habit. it improves the type checker's error messages dramatically.
11:06:45 <LoganCapaldo> george--: ALL of them? even the ones like (snd . (+1)) ?
11:06:49 <LoganCapaldo> err
11:07:00 <LoganCapaldo> I mean ((+1) . snd)
11:07:08 <nattfodd> mdmkolbe|work: certainly you meant "great thing" instead of "trouble" ?
11:07:11 <titusg> george--: a lot of data structures have a naturally imperative flavour, and translating them into pure code makes them seem more complicated (to me). The opposite is true of lots of other data structures also.
11:07:37 <int-e> LoganCapaldo: I usually limit it to top level declarations
11:07:54 <ptolomy> Huh. "x^2" looks to be notably slower than "x*x" in GHC.
11:07:57 <mdmkolbe|work> george--: other things that you might do in C++/Java like the visitor pattern require a bit more tooling and thought in Haskell (though great work has come of it (e.g. Scrap your boilerplate))
11:07:59 <LoganCapaldo> int-e: yeah I was asking george-- since he said he did it for all his functions
11:08:07 <mdmkolbe|work> @type (^)
11:08:09 <mdmkolbe|work> @type (*)
11:08:11 <george--> i put a type signature on every little bit of haskell i write. im only learning and i get marked down if i dont :)
11:08:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:08:15 <lambdabot> forall a. (Num a) => a -> a -> a
11:08:17 <int-e> @src (^)
11:08:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:08:23 <int-e> @source (^)
11:08:23 <lambdabot> (^) not available
11:08:26 <shapr> I thought upgrading hpaste to the latest version of HAppS would take ten minutes, boy was I wrong!
11:08:30 <mux> right, arrays a bit harder to deal with in haskell than in other languages (several kind of arrays, no brackets notation), but things like trees are stunningly simple and beautiful in haskell
11:08:43 <int-e> ptolomy: did you compile with -O?
11:08:53 <ptolomy> Yep.
11:09:18 <int-e> ptolomy: I'm not sure if that helps, but for a small constant exponent it's worth a try.
11:09:23 <mdmkolbe|work> george--: in real projects stuff like an inline argument to 'map' doesn't (usually) need to be marked with a type, but I guess whatever your teacher wants
11:10:17 <mdmkolbe|work> int-e: I'm guessing that (^) is implemented using C's "pow" function which would be much slower than an inline instruction
11:10:24 <george--> what data structure would you say has a naturally imperative flavour?
11:10:24 <int-e> mdmkolbe|work: it's not
11:10:42 <mdmkolbe|work> george--: a text field in a text editor
11:11:25 <int-e> george--: hash tables, and the clever O(a(n)) union find data structure
11:11:25 <shapr> I'll work on hpaste tonight, but in the meantime it's just down.
11:11:41 <george--> im not familiar with either of these int-e
11:11:55 <george--> i dont understand why the text field in a text editor would be naturally imperative
11:12:18 <int-e> how is that a data structure?
11:12:40 <george--> sorry?
11:12:44 <mdmkolbe|work> george--: it's imparative b/c it's mutable and changing.  In a pure fuctional world, mutation isn't allowed
11:12:47 <mux> george--: most data structure that rely on assignments to perform well are likely to be slightly harder to deal with in haskell, or to even to be bad for haskell and another data structure might be better
11:12:47 <titusg> george--: because destructive updates are a practical way to deal with it
11:13:06 <int-e> mdmkolbe|work: oh but (^) (as defined in GHC.Real) is a specialized function - if I remember correctly that interacts badly with inlining.
11:13:42 <int-e> (^) source (from GHC.Real): http://paste.lisp.org/display/41548
11:13:51 <SamB_XP> probably you want to use ** if you want to raise a floating-point number to a power of the same type...
11:14:19 <mdmkolbe|work> @type (**)
11:14:22 <lambdabot> forall a. (Floating a) => a -> a -> a
11:14:28 <george--> mutation isnt allowed because it effects the world?
11:14:42 <mdmkolbe|work> george--: yes
11:15:04 <int-e> SamB_XP: what I'm wondering about is whether the compiler has a reasonable chance of optimizing x^2 to x*x
11:15:06 <george--> what is a 'destructive update' ?
11:15:28 <mdmkolbe|work> george--: in a functional world, all we have are abstract unchanging mathematical values.  Afterall, today's pi needs to be the same as yesterdays pi
11:15:37 <SamB_XP> @src (^)
11:15:37 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:15:39 <int-e> george--: replacing a value in a variable by a new one.
11:15:43 <int-e> @quote variable
11:15:44 <lambdabot> ghc says: A lazy (~) pattern connot bind existential type variables
11:16:05 <int-e> @quote back
11:16:05 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
11:16:05 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
11:16:12 <mdmkolbe|work> george--: it means to update a data structure in a way that destroys the old copy of the data structure.  (Usually by overwritting it's location in memory)
11:16:19 <SamB_XP> int-e: I'd guess that it depends on what patterns the ^ function has in its definition...
11:16:59 <SamB_XP> also, we need more homework.
11:17:04 <george--> would a function : set_to_one x; x = 1; be considered desctructive?
11:17:15 <mdmkolbe|work> george--: yes
11:17:27 <SamB_XP> mdmkolbe|work: how so?
11:17:45 <SamB_XP> x is private, and doesn't even have a value before "x = 1"
11:17:49 <mdmkolbe|work> george--: (that's actually a bit of a lie on my part, but you'll find out once you get to monads about the rest)
11:17:54 <george--> haskell deals with that without a problem? so where does this problem arise?
11:18:12 <SamB_XP> or...
11:18:16 <SamB_XP> maybe I misread it...
11:18:29 <mdmkolbe|work> george--: maybe I missunderstood your syntax
11:18:31 <SamB_XP> x_x
11:18:42 <mdmkolbe|work> george--: could you write that as a more haskell style function?
11:19:03 <george--> a function that takes an integer and assigns it to one
11:19:23 <george--> if we a assume the integer had an initial non-one value then the previous one has been 'destroyed' ?
11:19:37 <george--> im just trying to understand 'destructive update'
11:19:45 <mdmkolbe|work> george--: that can't be done in Haskell b/c haskell is pure functional (modulo my previous qualification about monad)
11:20:01 <mdmkolbe|work> george--: yes, it would have been desctoryed in that sence
11:20:05 <Philippa> george--: you'd just write let x = 1 in ...
11:20:06 <mux> george--: "assignment" may be a more understandable term
11:20:11 <Philippa> the previous "undefined" value is gone
11:20:21 <gwern> so I was reading the old total functional programming papers. are there currently any practical benefits to that besides the warm fuzzy feelings of being able to show some proofs for some things? Like, does GHC do extra optimizations etc.?
11:20:55 <mdmkolbe|work> gwern: you mean besides knowing that your program will terminate under any input?
11:21:09 <gwern> mdmkolbe|work: yes
11:21:22 <mdmkolbe|work> gwern: not that I know of
11:21:29 <george--> ok so we can say the disadvantage of haskells type system is it has soe problems with data types which are inherently more natured towards imperative programming styles e.g. an editable text box?
11:21:38 <EvilTerran> let x = [1..100000]; y = 0:x... -- only one copy of x necessary here
11:22:12 <gwern> that's a little disapointing. oh well.
11:22:17 <LoganCapaldo> updateability is unrelated to the type system is it not?
11:22:20 <mdmkolbe|work> george--: that is more of a dissadvantage of haskell's functional purity, not it's type system, but otherwise yes
11:22:21 <mux> george--: there is a whole world of data structures specially tailored for functional programming though
11:22:25 <EvilTerran> another thing: laziness is much more difficult in an imperative language
11:22:41 <mux> george--: that wouldn't wory as nicely in imperative languages
11:23:06 <LoganCapaldo> You could have some imaginary language with the same type system as haskell that let you do destructive updates couldn't you?
11:23:43 <mdmkolbe|work> LoganCapaldo: I think you could (in fact I've often wanted to port Haskell classes to C)
11:24:29 <Philippa> LoganCapaldo: to a first approximation, it's called ML
11:24:56 <mdmkolbe|work> the advantage of haskell's type system is that it requires you to be very precise.  the disadvantage of haskell's type system is that is requires you to be very precise.
11:25:43 <george--> hhmmmm xchat just crashed in a big way
11:26:16 <mdmkolbe|work> the advantage of haskell's type system is that it requires you to be very precise.  the disadvantage of haskell's type system is that is requires you to be very precise.
11:26:30 <george--> can anyone who responded to my last question about disadvantage being that some data classes are poorly supported by haskells type system repeat?
11:26:51 <george--> i think the advantage is it helps with debug :)
11:27:09 <george--> where in say C or Java would you not be required to be precisE?
11:27:50 <mdmkolbe|work> george--: consider the return codes in C, what type are they usually?
11:28:19 <george--> i dont code in C.. i imagine numerical
11:28:19 <mdmkolbe|work> george--: or better consider what would strlen return if you handed it a null pointer?
11:28:35 <george--> err zero?
11:28:42 <mux> it returns bottom :)
11:28:49 <george--> 'bottom'?
11:29:07 <mux> just kidding, bottom is a special haskell value
11:29:12 <LoganCapaldo> Lemme try it out, looks liSegmentation fault
11:29:16 <stepcut> LoganCapaldo: BitC is pretty close. It has a fairly haskell-like type system (including type classes), but also has mutable values
11:29:17 <LoganCapaldo> ;)
11:29:18 <EvilTerran> well, concept rather than value
11:29:34 <EvilTerran> metavalue :P
11:29:34 <mdmkolbe|work> george--: it returns -1 as a special flag value
11:29:48 <mux> it doesn't
11:29:50 <migraine> depends on the compiler/platform as to what it would return/do
11:29:55 <mdmkolbe|work> george--: so the int it returns isn't always an it
11:30:00 <mux> strlen() on NULL is UB
11:30:23 <mdmkolbe|work> mux, migraine: ok, ok. so pick me another C function that pays the same tricks if you want
11:30:34 <mux> mdmkolbe|work: gettimeofday()
11:30:51 <mux> this one is a good example because thanks to it (and thanks to POSIX), time_t needs to be signed
11:31:27 <mux> read() and ssize_t also come to mind, what a hack.
11:31:34 <migraine> on some unix platforms dereferencing NULL returns 0 which would cause string handling routines to stop successfully
11:31:37 <mdmkolbe|work> mux: um, I think you mean one of the other time functions
11:31:46 <mux> nope
11:32:06 <mdmkolbe|work> RETURN VALUE: gettimeofday and settimeofday return 0 for success, or -1  for  failure
11:32:08 <mux> err, well, do you mean gettimeofday() can't fail?
11:32:10 <mux> that's right
11:32:18 <george--> and this a disadvantage in haskell that you cannot return your -1 value ?
11:32:19 <mux> well, pick read() as your example then
11:32:26 <mdmkolbe|work> mux: I don't see how that connects with signed time_t
11:32:31 <mux> it's especially icky
11:32:54 <mdmkolbe|work> george--: you could, but it's better to use the types Haskell allows you to use like 'Maybe Int'
11:33:05 <mux> mdmkolbe|work: that was an entirely bad example
11:33:10 <mux> let's pick read()
11:33:31 <olsner> read() used to return a simple int, and then it's just idiomatic to return -1 for failure, since -1 is no "number of characters"
11:33:53 <olsner> that's just DTSTTCPW+KISS ;-)
11:34:00 <mux> mdmkolbe|work: I think I probably meant time(), but whatever
11:34:08 * mdmkolbe|work hands the mic to mux (to tired typing)
11:34:18 <migraine> although that would mean if you read a file of size UINT_MAX you would see it as a failure
11:34:40 * mux taps on the mic.. one two
11:34:56 <fasta> What does <a,b,c,d><c,d,e,f> mean in a stack trace?
11:35:06 <LoganCapaldo> migraine: I think you left your can of worms open. You should do somethingabout that :)
11:35:23 <fasta> AFAIK, I only have seen stack traces of the form: <a,b,c,d,e,f>
11:35:40 <migraine> c == worms
11:35:53 <mux> george--: I think what mdmkolbe|work meant to say is that for instance, many C functions encode failure as returning -1
11:36:12 <mux> george--: thus using a magic value to indicate failure
11:36:16 <pitecus> is there no way to make smth like IntSet or Set an instance of Traversable?
11:36:31 <fasta> pitecus: use the Source
11:36:36 <george--> ok, but equivalently the maybe in haskell could be used to denote failure?
11:36:43 <mux> george--: in haskell, you would probably have a function returning a Maybe type, for instance and in the end it's relatively hard for someone to ignore the error
11:36:46 <pitecus> fasta, ?
11:36:50 <fasta> pitecus: and without source it might also be possible
11:36:51 <mux> george--: while in C, people could not check for -1
11:36:54 <george--> or you could return a pair where first value contains an error code (if applicable) or whatever?
11:36:55 <mux> or NULL, or whatever
11:37:13 <george--> people cannot check a -1?
11:37:21 <mux> george--: for instance, a function returning an Int but that can fail, you would probably use a type Maybe Int
11:37:38 <mux> george--: and Maybe Int can either be Nothing (in our case, failure) or Just x where, x is an Int
11:37:55 <int-e> george--: they could forget to do it, although it's required.
11:38:01 <LoganCapaldo> george--: people can check a -1, but people cannot NOT check a Maybe
11:38:03 <mux> george--: in Haskell, you can't use a Maybe Int as an Int, they are different
11:38:03 <mdmkolbe|work> george--: in C you can forget to check a -1, but in Haskell, you are forced to check a Maybe
11:38:25 <mux> george--: and in the process of extracting the Int from the Maybe Int, you would _have_ to handle the failure case
11:38:28 <mdmkolbe|work> heh, 4 replys saying the same thing
11:38:34 <mux> unless you're a bastard and you're using fromJust
11:38:38 <mux> and ruining my argument :-P
11:38:41 <olsner> @quote stereo
11:38:41 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
11:38:42 <LoganCapaldo> its quadraphonic stereo
11:39:02 <mux> fromJust considered evil
11:39:06 <olsner> @quote surround
11:39:06 <lambdabot> No quotes match. Wrong!  You cheating scum!
11:39:13 <mdmkolbe|work> Just a few more and we could do 5.1 surround sound
11:39:22 <LoganCapaldo> fromJust is still better than forgetting the negative one
11:39:33 <LoganCapaldo> because at least then you'll get an exception
11:39:36 <mux> right, at least it throws an exception
11:39:49 <mux> not sure if he got the point though, we kinda flooded him
11:39:54 <mux> heh
11:40:20 <mdmkolbe|work> LoganCapaldo: and you have to go to the effort of typing it so you have to spend a couple seconds thinking about the fact that you are ignoring a possible error
11:40:37 <LoganCapaldo> heh
11:40:50 <LoganCapaldo> it should be renamed to fromJustIAmAFool
11:40:59 <LoganCapaldo> :)
11:41:03 <mux> and it requires you to import Data.Maybe, while all the other functions are readily available from the Prelude
11:41:06 <mux> that's good :-)
11:41:42 <mdmkolbe|work> LoganCapaldo: only after wer rename unsafePreformIO to unsafePerformIOAndIPromiseNeverToUseThis just to keep the difficulty hierarchy right
11:41:52 <george--> ok, this was meant to be an argument why haskell typesystem has a disadvantage... it has turned into an advantage :P
11:41:56 <LoganCapaldo> mdmkolbe|work: absolutely
11:42:16 <mux> george--: weirdly, that kind of things happen a lot with haskell :-)
11:42:32 <fasta> george--: there are some disadvantages, but it's meaningless to talk about it, I guess.
11:43:35 <george--> ok, i have to cook supper, thanks alot everyone helping my questions, i will surely come up with more later:)
11:43:44 <mux> oh no!!!
11:43:45 <mux> ;-)
11:44:02 <olsner> unsafePerformIO... in the so-called pure functional language
11:44:16 <LoganCapaldo> Aren't people complaining about what a pain in the neck it is to turn code that uses a single Monad into monad transformer code a lot in here? Is that a disadvantage?
11:44:50 <mux> LoganCapaldo: it's not really a problem if you had defined all the primitives through functions already
11:45:15 <mux> LoganCapaldo: trying to limit the amount of code that really_ touches the innards of the monad you are using
11:45:25 <fasta> I think it's pretty pointless to tell in what monad you want to execute something.
11:46:16 <LoganCapaldo> mux: so its back to the "preciseness" advantage/disadvantage
11:46:19 <fasta> A programming language in an interface to the computer. If the amount of lift . lift .lift can be computed, it shouldn't be asked.
11:46:32 <mux> LoganCapaldo: I guess
11:46:44 <LoganCapaldo> i dunno :)
11:47:18 * mux longs for the day where GHC will say "you miss one lift, you scum!"
11:47:29 <int-e> fasta: that's why we have MonadIO and MonadState and friends
11:48:10 <nominolo> @seen ndm
11:48:11 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1h 26m 40s ago, and .
11:48:33 <int-e> (I guess classes like that are only a partial solution. but they help.)
11:49:24 <nominolo> @seen dcoutts_
11:49:24 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts_ speak 1h 22m 13s ago.
11:49:26 <chessguy> ?seen kowey
11:49:26 <lambdabot> kowey is in #darcs and #haskell. I don't know when kowey last spoke.
11:49:36 <chessguy> kowey: ping
11:49:42 <kowey> hi, chessguy
11:49:42 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:49:49 <chessguy> lol
11:49:53 <chessguy> you have a message from me :)
11:50:16 <fasta> int-e: I use ST with ContT, how can I avoid the "lifts"?
11:51:06 <kowey> chessguy: have i stepped into something subtler than I expected with this Risk thing?
11:51:25 <int-e> fasta: you can limit it to one liftXX instead of several lift . lift . lift.
11:51:27 <chessguy> kowey: probably
11:51:36 <chessguy> kowey: depends on what question you're actually asking
11:51:42 <Saizan> .
11:51:50 <chessguy> kowey: i don't know how hard-core of mathematics you want, but http://www.rose-hulman.edu/mathjournal/archives/2002/vol3-n2/paper3/v3n2-3pd.pdf is pretty readable, for the most part
11:51:53 <lambdabot> http://tinyurl.com/25ruzg
11:52:06 <kowey> oh my!
11:52:36 <kowey> (for people who didn't go look at that, the title is 'RISKy Business: An In-Depth Look at the Game RISK '
11:53:12 <kowey> math goes quickly over my head, but this is intriguing enough to look into... thanks for that
11:53:20 <int-e> fasta: it's hard. Monad transformers aren't as nicely composable as I'd like. But the idea is that you could use liftST for, say, ContT ReaderT StateT ST (never mind the sillyness) without having to worry about how many transformers you stacked on top of ST.
11:53:45 <chessguy> kowey: let me know if you decide what question you actually want to ask, and i'll try to translate the math into a usable answer
11:54:07 <fasta> int-e: ok, I see, I thought by XX you meant a number
11:54:15 <int-e> fasta: this is only really implemented for IO (and liftIO) I think.
11:54:17 <fasta> int-e: which was apparently wrong
11:54:31 <Saizan> ?src MonadIO
11:54:31 <lambdabot> Source not found. My mind is going. I can feel it.
11:54:43 <fasta> int-e: but even the liftST is redundant, imho.
11:55:11 <int-e> fasta: oh and in theory you could wrap the whole IO library into something that just calls liftIO on everything.
11:55:29 <int-e> fasta: it's a lot of boilerplate code to write though. I'm not really happy with that.
11:56:06 <kowey> chessguy: thanks! i'll read that and then see whether I can formulate my thinking in a more precise manner
11:56:13 <int-e> @type liftIO getLine
11:56:15 <lambdabot> forall (m :: * -> *). (MonadIO m) => m String
11:56:16 <chessguy> kowey: sounds good
12:01:25 <mwolak> @type (.&.)
12:01:27 <lambdabot> forall a. (Bits a) => a -> a -> a
12:04:13 <chessguy> > 2 .&. 3
12:04:14 <lambdabot>  Add a type signature
12:04:18 <chessguy> > 2 .&. 3 :: Int
12:04:20 <lambdabot>  2
12:12:34 <timthelion> how do you comment in haskell?
12:13:20 <migraine> -- for lines, {- -} for blocks
12:14:13 <LoganCapaldo> Or change the extension to .lhs, and do nothing at all to comment :)
12:14:24 <migraine> yes but then you have to uncomment your code
12:14:37 <LoganCapaldo> details, details :)
12:15:04 <roconnor> \begin{code} to uncomment code
12:15:10 <roconnor> \end{code} to comment
12:16:04 <timthelion> why the freek would you do that?
12:16:18 <timthelion> are there docstrings in haskell?
12:16:41 <roconnor> timthelion: mostly so that you can begin your haskell file with #!/usr/bin/runhaskell
12:16:53 <timthelion> lol
12:16:59 <timthelion> that seems silly
12:17:05 <roconnor> it is silly
12:17:16 <roconnor> but it works
12:17:26 <Philippa> you'd do that because then your code is also a LaTeX document
12:17:45 <migraine> ugh latex, my arch nemesis
12:17:47 <Philippa> which is really good if you're in fact covering an algorithm that needs something akin to a small paper to document effectively, on account of doing novel and/or tricky stuff
12:18:02 <roconnor> damn you LaTeX!
12:18:16 <Philippa> LaTeX stole your children?
12:18:28 <sioraiocht|sleep> I <3 latex
12:18:32 <sioraiocht|sleep> to the point where I don't own MS word
12:18:34 <migraine> it hasn't found them yet, but when it does it will scramble their brains
12:18:37 <sieni> not quite, but my youth!
12:19:06 <migraine> actually, I just never spent the time to learn it
12:19:10 <Philippa> sioraiocht: not owning MS word is easy if you built your own comp though
12:19:20 <Philippa> it's pretty easy to get started with
12:19:30 <Philippa> if you can do HTML, you can do basic LaTeX
12:19:35 <migraine> yeah but there are so many other things to get started with
12:19:39 <Philippa> (not because they're the same thing, but because you've met enough concepts)
12:19:41 <sioraiocht> migraine: the learning curve just gets steep when you want to modify a lot of defaults
12:19:42 <migraine> that are more interesting
12:20:00 <sioraiocht> Philippa: I don't believe in WYSIWIG word processors anymore.  Ever. lol
12:20:18 <savanni> I think it was in modifying defaults that I started considering ritual suicide.
12:20:24 <Philippa> tried LyX?
12:20:28 <Philippa> heh
12:20:31 <stepcut> groff ?
12:20:54 <timthelion> so, there are no docstrings in haskell?
12:20:56 <nominolo> @tell bringert no, it would require quite a lot of work to make it stable and SoC starts next week.
12:20:56 <lambdabot> Consider it noted.
12:21:05 <olsner> after entire lines of combinations of the characters \{[]}, latex gets somewhat tiring
12:21:19 <savanni> When should I use latex over haddock?
12:21:38 <Philippa> 'internal' docs
12:21:57 <nominolo> @tell bringert er, the previous message was related to making HTTP+Bytestrings be the next version of HTTP lib
12:21:57 <lambdabot> Consider it noted.
12:22:08 <Philippa> haddock covers interface stuff effectively, it's less good at explaining what code's actually doing bit by bit
12:22:20 <Philippa> if you like, for implementation docs
12:22:26 <savanni> hmmm... interesting.
12:22:40 <Spark> that goes for most documenting systems, no?
12:22:52 <Spark> the best you get is "click here for the source code"
12:23:14 <nominolo> @tell dcoutts do you think gtk2hs would be a good test case for Cabal-configs (my SoC project)?
12:23:14 <lambdabot> Consider it noted.
12:23:30 <Philippa> well, both literate haskell and haddock allow you to add extra info
12:23:45 <chessguy> anyone here familiar with Wolfram's "A New Kind Of Science"?
12:23:54 <Philippa> but haddock's not as effective as literate haskell for doing the implementation docs with - it's geared towards interface stuff
12:23:54 <byorgey> chessguy: yeah
12:24:12 <roconnor> chessguy: I've glanced through the book
12:24:19 <Philippa> whereas literate haskell is designed to be intermingled with the source and read as a kind of souped up comment
12:24:24 <chessguy> i'm wondering about the correspondence between his point that "simple rules can produce complex results" and calculi like lambda calculus
12:24:27 <timthelion> how do I test : do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; foo in hugs
12:24:30 <Philippa> only with the comment getting more focus than the code
12:24:32 <timthelion> or ghci?
12:24:34 <timthelion> it errors
12:24:51 <Philippa> chessguy: "well duh"
12:24:56 <Philippa> that's the correspondance :-)
12:25:02 <pjd> chessguy: and complexity theory in general
12:25:02 <timthelion> > do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; foo
12:25:03 <lambdabot>   Not in scope: `Directory.doesFileExist'
12:25:11 <LoganCapaldo> um guys
12:25:17 <roconnor> chessguy: his simple rules are even simpler than the lambda calculus
12:25:21 <LoganCapaldo> I hate to bring this up
12:25:23 <pjd> and combinatorics, and information theory...
12:25:45 <roconnor> for some definition of simple
12:26:23 <byorgey> roconner: perhaps you mean that implementing his rule systems directly with lambda calculus would make them more complicated-looking?
12:26:29 <timthelion> how come doesFileExist doesn't work on a string?
12:26:38 <byorgey> I'm not sure they are really simpler than lambda calculus
12:26:40 <nominolo> chessguy: i read some really bad critiques of that book
12:26:47 <LoganCapaldo> but it looks like #!/... works with runhaskell anyway
12:26:51 <LoganCapaldo> .lhs or no
12:26:53 <Lemmih> timthelion: A FilePath is a String.
12:26:58 <roconnor> byorgey: rule 110 is pretty simple
12:27:10 <roconnor> no dealing with alpha conversion or de bruijn substitution
12:27:17 <byorgey> roconnor: which one is that now?
12:27:18 <Saizan> timthelion: your code is ill-typed
12:27:19 <timthelion> Lemmih: then why doesn't it work? and why is hpaste down?
12:27:29 <roconnor> @google rule 110
12:27:31 <lambdabot> http://mathworld.wolfram.com/Rule110.html
12:27:31 <lambdabot> Title: Rule 110 -- from Wolfram MathWorld
12:27:36 <Saizan> timthelion: do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; return foo
12:28:01 <timthelion> Saizan: in ghci, that did nothing
12:28:11 <pjd> byorgey, roconnor: SKI calculus
12:28:31 <byorgey> roconnor: well, yes... I guess it depends on what you mean by "simple" =)
12:28:31 <roconnor> I think rule 110 is even simpler than the SKI calculus
12:29:05 <Saizan> timthelion: Prelude>  do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; return foo
12:29:05 <timthelion> @hpaste
12:29:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:29:09 <Saizan> timthelion: Prelude>  do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; retuFalse
12:29:31 <Saizan> gah, silly client, however it printed False.
12:29:39 <byorgey> roconnor: ok, I think I understand your point now... you mean that rule 110 as a formal system is simpler than SKI calculus (or whatever) as a formal system?
12:29:42 <Philippa> how complicated do we consider a single-instruction "subtract and branch if not zero" machine?
12:29:54 <roconnor> although rule 110 has some issus with having to start out with an infinite repeating pattern.
12:30:07 <roconnor> byorgey: that's the idea
12:30:31 <pjd> it's debatable that Turing equivalence makes the simplicity thing kind of moot anyhow
12:30:54 <Philippa> is rule 110 actually notably simpler than Life?
12:31:35 <timthelion> Saizan: it's just echoing out do foo <- Directory.doesFileExist "/home/timothy/.emacs" ; return foo again
12:31:36 <byorgey> Philippa: not really, IMO
12:31:39 <timthelion> it's not doing anythnig
12:32:52 <roconnor> Philippa: I think so
12:33:10 <roconnor> I suppose it is debatable
12:34:50 <roconnor> @logs
12:34:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:36:37 <roconnor> the core of rule 110 is \a b c -> (a<b&&c)||(b/=c)
12:36:56 <roconnor> maybe there is a simpler way of stating it
12:39:01 <Saizan> > do foo <- (const False) "/home/timothy/.emacs" ; return foo  -- it's equivalent to this, if it doesn't work there something broken
12:39:08 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Bool'
12:39:18 <Saizan>  > do foo <- (return $ const False) "/home/timothy/.emacs" ; return foo
12:39:26 <Saizan> > do foo <- (return $ const False) "/home/timothy/.emacs" ; return foo
12:39:27 <lambdabot>  Add a type signature
12:39:49 <Saizan> right, lb doesn't unpack monads..
12:42:55 <george--> im looking at a past exam paper and a question comes up 'give two examples of class use, explaining for each what the specific problem is'... now that seems horribly vague to me? does it have a specific meaning that i missing?
12:43:49 <byorgey> george--: that does sound pretty vague
12:44:32 <george--> i missed a bit before that: haskell's class system was invented because not all operations can be parametrically possible
12:44:54 <LoganCapaldo> I think its supposed to be vague. I imagine it is intended to gauge your understanding as opposed to knowledge
12:44:58 <george--> still to me doesnt bring any light
12:45:31 <byorgey> hrm... that's not what I read about why the class system was invented.  what does that even mean?
12:46:07 <george--> maybe its looking for an example of ad hoc polymorphism?
12:46:22 <DRMacIver> Surely the class system was invented because previous attempts at overloading of operators sucked horrifically?
12:46:37 <roconnor> I thought the class system was invented so that + and == could be overloaded
12:46:40 <byorgey> oh, wait, maybe by "not all operations can be parametrically possible" it means, e.g. that you wouldn't want (+) :: a -> a -> a since not all types can be added
12:46:40 <DRMacIver> Yeah
12:47:42 <george--> so you would consider that as a problem? seems to me more a feature
12:47:59 <george--> i think i may email my lecturer, it seems very ambiguous
12:48:23 <DRMacIver> Write in OCaml for a while and see how much of a 'feature' the way it handles + and = is. ;)
12:48:46 <byorgey> george--: consider what as a problem?
12:49:17 <george--> byorgey: the question asks: give two examples of class use and explain what the specific problem is
12:49:51 <byorgey> george--: right, I know, but you said "so you would consider that as a problem?" and I wasn't sure what you were referring to
12:50:07 <george--> oh
12:50:14 <george--> the fact that + wont add all types
12:50:26 <byorgey> oh, no, that is a feature
12:51:22 <byorgey> i.e. the class system was invented to avoid the problem of having unrestricted polymorphism for things like (+)
12:52:03 <george--> ahh
12:52:06 <george--> i see what you mean :)
12:53:09 <byorgey> I think that's what the problem means when it says "haskell's class system was invented because not all operations can be parametrically possible"
12:55:31 <george--> yeah :) i am writing him an email now asking this
12:55:39 <george--> but i think you are correct
13:04:02 <cinimod> @help
13:04:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:04:22 <cinimod> @list
13:04:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:05:37 <cinimod> @pl \x y x -> ((x,y),z)
13:05:37 <lambdabot> const (flip flip z . ((,) .) . flip (,))
13:06:25 <Botje> eval: (\x y x -> y) 1 2 1
13:06:29 <Botje> err
13:06:31 <Botje> > (\x y x -> y) 1 2 1
13:06:33 <lambdabot>      Conflicting definitions for `x'
13:06:33 <lambdabot>     In a lambda abstraction
13:06:36 <Botje> thought so
13:06:37 <cinimod> @tell
13:06:38 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
13:06:52 <Botje> @pl \x y z -> ((x,y),z)
13:06:52 <lambdabot> ((,) .) . (,)
13:07:01 <Botje> that's a much nicer expression *G*
13:07:58 <cinimod> Never try these things after a couple of beers I'd say
13:11:21 <cinimod> @pl \x1 x2 x3 x4 -> (((x1,x2),x3),x4)
13:11:21 <lambdabot> ((((,) .) . (,)) .) . (,)
13:11:56 <DRMacIver> Hm. anglohaskell looks interesting.
13:12:13 <byorgey> @pl \x y z -> (x,(y,z))
13:12:13 <lambdabot> (. (,)) . (.) . (,)
13:12:32 <pitecus> is it possible to serialize an opaque pointer obtained via FFI from C?
13:12:38 <Heffalump> last year's was pretty good
13:13:19 <byorgey> 'anglo' == 'in England'?
13:13:39 <Heffalump> yes
13:15:34 <nominolo> ping bringert
13:16:00 <byorgey> ah.  sad.  (for people like me across the ocean, that is)
13:16:51 <Heffalump> bit harder to organise a US Haskell meet.
13:18:25 <byorgey> yah, everything's too far apart =P
13:19:15 <bringert> nominolo: hi
13:19:15 <lambdabot> bringert: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:19:43 <bringert> nominolo: I have a baby on my lap, so I may be a bit unresponsive
13:19:48 <bringert> @messages
13:19:48 <lambdabot> nominolo said 58m 52s ago: no, it would require quite a lot of work to make it stable and SoC starts next week.
13:19:48 <lambdabot> nominolo said 57m 51s ago: er, the previous message was related to making HTTP+Bytestrings be the next version of HTTP lib
13:20:23 <bringert> now, where's that HTTP strike team?
13:20:27 <Baughn> Does GHC partially evaluate functions if I supply some of their arguments at compile-time? How about runtime?
13:21:19 <nominolo> bringert: it's a SoC project, isn't it?
13:21:40 <nominolo> though that project's plan is to replace it completely using libcurl bindings
13:21:43 <bringert> nominolo: isn't the SoC project to write a libcurl binding?
13:21:47 <bringert> right
13:22:05 <bringert> I think that there should also be a pure haskell solution
13:22:41 <bringert> JaffaCake mentioned that compling against libcurl on Wndows is a bitch
13:22:47 <nominolo> yes.  the main problem with this implementation is, that, according to the ghc-lib sources socketToHandle won't work in a multithreaded environment
13:23:05 <bringert> why do you need that?
13:23:07 <nominolo> so i guess we'd have to port bytestrings to work on sockets first
13:23:10 <bringert> for BS.hGet?
13:23:16 <nominolo> yep
13:23:21 <bringert> that should be easy enough
13:23:38 <cinimod> Does BS do putBit / getBit yet?
13:23:41 <nominolo> and I have to tell hGetContents what to do when it reaches EOF
13:23:50 <nominolo> i.e. close the socket / handle or not
13:24:11 <sjanssen> cinimod: the IO system only supports byte-aligned IO
13:24:29 <ejt_> @seen dons
13:24:30 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 8h 9m 39s ago.
13:25:11 <cinimod> sjanssen: NewBinary could do this. Any plans for BS?
13:25:37 <sjanssen> cinimod: something like this might be in Data.Binary at some point
13:25:52 <nominolo> bringert: i was planning to summarize the problems in a blog post (now that i'm on planet haskell).
13:26:13 <nominolo> though, obviously, i didn't so far ;)
13:27:24 <bringert> nominolo: sendBufTo and recvBufFrom + Data.ByteString.Base.createAndTrim should allow you to write a recvByteString :: Socket -> ByteString
13:27:29 <bringert> or something like that
13:29:26 <bringert> nominolo: a blog post with the current problems sounds like a good starting point for someone else
13:29:32 <bringert> good plan
13:33:14 <george--> does anyone have a good online reference location for list comprehension (beginner -> intermediate level)
13:34:39 <Baughn> george--: The gentle introduction to haskell?
13:35:00 <george--> im reading that currently
13:35:09 <george--> unless i missed something the section on list comp is very small
13:35:16 <Baughn> Well, there's not a lot to it
13:35:45 <george--> i guess, i would look for something that maybe sets a few exercises with model answers ::)
13:36:01 <Baughn> It's a pattern match and a map. That's pretty much it.
13:36:02 <therp> am I supposed to capitalize 'lambda calculus' in papers?
13:37:27 <Baughn> Before I write one, is there a libpng binding out yet?
13:39:13 <Baughn> @where png
13:39:14 <lambdabot> I know nothing about png.
13:39:17 <Baughn> @where libpng
13:39:18 <lambdabot> I know nothing about libpng.
13:39:31 <pitecus> hpaste is down...
13:41:03 <pitecus> i wrote some code that uses FFI. One of the functions has to do memory allocation and freeing. Could someone check if Im doing the right thing there? I dont know much about such low-level things.
13:41:07 <sjanssen> pitecus: 11:11:25 <shapr> I'll work on hpaste tonight, but in the meantime it's just down.
13:41:29 <pitecus> can i paste here? its about 10 lines...
13:41:46 <sjanssen> pitecus: probably better to use paste.lisp.org
13:43:12 <pitecus> OK
13:43:19 <pitecus> Its at http://paste.lisp.org/display/41559
13:43:27 <byorgey> therp: probably not
13:43:51 <pitecus> Am I calling free correctly there?
13:44:28 <sjanssen> pitecus: looks okay to me
13:44:40 <sjanssen> @hoogle allocaArray
13:44:41 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
13:44:41 <lambdabot> Foreign.Marshal.Array.allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
13:44:59 <sjanssen> pitecus: you should consider using allocaArray -- then you can't forget to free
13:45:33 <pitecus> sjanssen, does allocaArray call free automatically?
13:45:48 <LoganCapaldo> pitecus: it uses stakc allocation IIRC
13:45:52 <LoganCapaldo> *stack
13:45:52 <sjanssen> pitecus: yeah
13:46:12 <sjanssen> pitecus: it's also exception safe (your malloc/free combination isn't)
13:46:34 <sjanssen> @hoogle withArray
13:46:34 <lambdabot> Foreign.Marshal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
13:46:34 <lambdabot> Foreign.Marshal.Array.withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
13:46:34 <lambdabot> Foreign.Marshal.Array.withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
13:46:35 <pitecus> sjanssen, LoganCapaldo I have to allocate two arrays to pass to the same function
13:47:27 <pitecus> im not sure how to do that with withArray or allocaArray
13:47:42 <Saizan> allocaArray n (\a1 -> allocaArray n' (\a2 -> func a1 a2 ..)) ?
13:48:14 <pitecus> Saizan, ya makes sense, thanks
13:48:30 <sjanssen> pitecus: http://paste.lisp.org/display/41559#1
13:49:47 <Baughn> pitecus: If you have any cleanup to do, you'll want to add a finalizer
13:50:05 <pitecus> sjanssen, with your modification i shouldnt need lines 7 and 8 or 12, 13?
13:50:20 <pitecus> Baughn, what sort of cleanup?
13:50:38 <sjanssen> pitecus: ah yes, you can delete those.  I forgot
13:50:50 <pitecus> cool cheers
13:51:09 <Baughn> pitecus: Such as freeing memory. In this case you're fine with allocaArray, but for C functions that do their own allocation..
13:52:21 <pitecus> Baughn, im importing C functions wrapping C++ functions. Im not sure what those C++ functions do with memory actually...
13:52:57 <pitecus> I guess i'll find out if it crashes for no apparent reason...
13:53:00 <Baughn> pitecus: If there's a destructor function of any sort that should be called, then you're the one who gets to call them in a finalizer.
13:53:09 <Baughn> pitecus: It wouldn't crash, though. It'd just leak memory.
13:53:50 <pitecus> Baughn, I think there are no destructors that the user is supposed to call
13:53:52 <monochrom> Yeah, begin with no deallocation. Then "optimize". :)
13:54:13 <pitecus> But my C++ is non-existent so I may be wrong
13:55:00 <Baughn> pitecus: C++ objects have implicit destructors, but unless there's a call to new involved in making said object, it'll get called before Haskell resumes control anyway.
13:55:01 <Saizan> well the only "objects" exchanged are the two arrays here
13:55:43 <Baughn> pitecus: Otherwise you just have to make sure to call whatever functions the API tells you to call. If that's none, lucky you.
13:55:44 <pitecus> Saizan, there are more functions Im importing
13:56:01 <pitecus> Baughn, what is the thing with calling new again?
13:56:07 * Baughn is currently combining unsafePerformIO, unsafeInterleaveIO and foreign functions that allocate memory. Hairy.
13:56:30 <LoganCapaldo> So using FFI with this kind of function is this a legitimate use of unsafePerformIO ?
13:56:53 <Saizan> it's the intended use of it
13:57:02 <pitecus> Baughn, one of the C wrapper functions doesn smth like: ME_Model * m = new ME_Model();
13:57:03 <Baughn> pitecus: It's a version of malloc that automatically runs an initializer based on some (very complex, but you don't need to care) rules. The point is, unlike malloc, calling new /in your own code/ can allocate memory you don't know about.
13:57:23 <LoganCapaldo> Saizan: Got it
13:57:28 <Baughn> pitecus: Then the ME_Model pointer should be deleted at some point, calling the destructors
13:58:09 <pitecus> I guess I should learn C++ before I try to use FFI ...
13:58:13 <Baughn> LoganCapaldo: unsafePerformIO is safe in very tightly defined circumstances
13:58:38 <Baughn> LoganCapaldo: Which, among other things, include things such as "perform a HTTP GET operation on an arbitrary URL and return the data lazily"
13:58:54 <Baughn> Doing it right can be hard, though
13:59:12 <Heffalump> new is no more complicated than malloc, surely? You just have to match new/delete like you match malloc/free.
13:59:47 <Saizan> random question: how do you build an object in C++ without new?
13:59:53 <Baughn> Heffalump: It's more complicated in that a malloc can be replaced with a garbage-collected version (usually), but the same isn't true for new
14:00:05 <pitecus> The example code for this library just declares "ME_Model model;" and then uses model. Does that avoid the problems with calling new??
14:00:06 <Baughn> Saizan: Brokenly. Please don't try it.
14:00:12 <Modius> Saizan:  new (mymemorylocaation) MyClassType();
14:00:18 <LoganCapaldo> Heffalump: well unless you use the variant where you bring your own memory :)
14:00:30 <Baughn> pitecus: In that case the model is allocated on the stack and deallocated once it goes out of scope
14:00:54 <pitecus> Baughn, so I can use the same thing in the C wrapper no?
14:01:03 <Baughn> pitecus: The effect is the same as saying "ME_Model *m=new..; ....;....;; delte m; return;", but more convenient. Especially with multiple return points.
14:01:04 <LoganCapaldo> in which case pairing it with a dlete is not the thing to do, and you should manaually call the destructor
14:01:28 <Baughn> pitecus: You can, given that C wrappers have to be written in extern "C" bits of C++ code
14:01:42 <Heffalump> Baughn: or exceptions
14:01:54 <Baughn> Heffalump: Oh, right.. C++ has those...
14:01:56 <pitecus> Lemme try this
14:02:05 <Baughn> Heffalump: I always considered exceptions without finalizers and a GC to be broken
14:02:49 <Heffalump> why? You just need to make sure you use appropriate wrappers.
14:03:29 <Baughn> Not all resources can be allocated using a stack discipline
14:04:15 <Heffalump> I don't see what difference exceptions make to that.
14:05:10 <sieni> Baughn: you can catch, call the destructor and rethrow the exception
14:05:44 <Heffalump> sieni: that happens automatically
14:05:51 <Baughn> sieni: Yes, but that makes code rather more cluttered
14:06:03 <pitecus> OK one last C++ question. The C wrapper has to return a pointer to the C++ object, but when I try "return (C_ME_Model *)(&model);" it gives a warning: address of local variable ‘model’ returned
14:06:12 <pitecus> So I guess it won't work...
14:06:13 <Baughn> For resources that don't have to be deallocated in any specific order, I'd rather have a finalizer take care of the odd corner cases.
14:06:18 <sieni> Heffalump: for heap allocated objects?
14:06:18 <Heffalump> pitecus: right, cos it's on the stack
14:06:27 * Baughn vanishes in a poof of logic
14:06:27 <Heffalump> sieni: oh, you mean "call delete".
14:06:35 <Heffalump> sieni: that's what I meant about appropriate wrappers.
14:06:39 <sieni> Heffalump: yeah
14:06:39 <Heffalump> e.g. std::auto_ptr
14:06:46 <pitecus> Heffalump, so I have to use new?
14:06:51 <Heffalump> pitecus: yes
14:06:54 <pitecus> and then call delete, is it?
14:06:57 <Heffalump> pitecus: yes
14:07:13 <stepcut> is there a (freely available) haskell implementation of longest commen subsequence matching that would be suitable for implementing a diff clone ?
14:07:13 <pitecus> So I call delete from haskell?
14:07:36 <stepcut> (or, perhaps a diff/diff3 clone in haskell)
14:07:40 <pitecus> stepcut, i think darcs has smth like that
14:07:47 <sjanssen> stepcut: hpaste has some diff code
14:09:16 <stepcut> I have seen this assigned as homework, so I figure there must be hundreds of (buggy) implementations :)
14:09:57 <emu> that's a dynamic programming algo?
14:09:58 <stepcut> hpaste looks promising
14:10:14 <stepcut> i see functions titled, dp, longest, and lcs ;)
14:10:19 <pitecus> So if i want to use a C++ object in haskell, I write a C wrapper which calls new, import that into Haskell, and then write a finalizer in haskell which calls delete on the pointer to the object? But where do I put the finalizer in my code?
14:10:30 <stepcut> and it's BSD3 ;0
14:11:09 <fasta> How can one write a function that does the same as: () <- assert p (return ()), but doesn't need the forcing as used in this way?
14:11:37 <monochrom> _ <- assert p (return ())
14:11:45 <monochrom> assert p (return ())
14:12:08 <fasta> monochrom: and why would p be evaluated now?
14:12:22 <fasta> monochrom: ah, nm
14:12:41 <quicksilver> let () = (assert p) `seq` ()  ?
14:12:48 <monochrom> I don't know. The original question says only about avoiding a forcing, not enforcing a forcing.
14:13:52 <fasta> quicksilver: right, but can one capture that abstraction without using CPP?
14:14:10 <fasta> quicksilver: you don't need the seq btw.
14:14:38 <stmartin> How does one do binary and, or, xor etc in Haskell? I see | and & don't seem to be understood.
14:14:50 <quicksilver> fasta: I don't really understand what you're trying to do
14:14:53 <quicksilver> stmartin: import Data.Bits
14:15:02 <quicksilver> stmartin: .|., .&. etc
14:15:08 <stmartin> Ah. Thanks
14:15:11 <jmob> how do I tell lambda bot to make something point free?
14:15:16 <fasta> All I want is that the assertion is not being ignored, because it's not "needed".
14:15:21 <monochrom> @pl \f -> f
14:15:21 <lambdabot> id
14:15:31 <jmob> @pl join tok s = foldr (++) "" (intersperse tok s)
14:15:31 <lambdabot> join = (foldr (++) [] .) . intersperse
14:15:38 <fasta> I suppose in pure code there's no way to avoid it.
14:16:00 <quicksilver> fasta: the only way to make sure it isn't ignored, is to 'seq' it with something you know will be evaluated
14:16:07 <fasta> In monadic code, I don't know any way other than using a CPP macro (or maybe template haskell)
14:16:28 <emu> @src join
14:16:28 <lambdabot> join x =  x >>= id
14:16:29 <gkr> How can I tell lambdabot to find a function of X type?
14:16:39 <emu> @hoogle a -> b -> a
14:16:41 <lambdabot> Prelude.const :: a -> b -> a
14:16:41 <lambdabot> Prelude.seq :: a -> b -> b
14:16:41 <lambdabot> Control.Parallel.par :: a -> b -> b
14:17:19 <gkr> Great, thank you.
14:17:27 <fasta> quicksilver: AFAIK, that's saying "it's impossible".
14:17:51 <quicksilver> fasta: well yes, code isn't evaluated until needed, as you pointed out
14:17:54 <fasta> quicksilver: you still need something to make sure the result is being used (ala () <-)
14:18:14 <fasta> quicksilver: clearly that model is not perfect everywhere.
14:18:33 <quicksilver> fasta: right, hence "...with something you know will be evaluated"
14:18:47 <pitecus> would defining a "withModel :: (Model -> a) -> IO a" function which deletes the pointer to the model be a good idea to deal with the cleanup?
14:19:14 <fasta> quicksilver: but that gives nesting which complicates the program.
14:20:01 <Saizan> pitecus: i think there's a fucntion to register a finalizer for a value in ghc
14:20:04 <stmartin> Can you specify binary notation in Haskell?
14:20:11 <quicksilver> fasta: you can do things like case () of () | (not p) = error "assertion failed" | otherwise = ..
14:20:12 <fasta> quicksilver: Imho, the only solutions available are hacky solutions.
14:20:21 <pitecus> Saizan, where would i look for it?
14:20:39 <quicksilver> fasta: guards have an implicit order you can exploit
14:20:44 <quicksilver> pitecus: it's part of the foreignptr stuff
14:20:57 <quicksilver> pitecus: your 'withModel' thing is cleaner if it's feasible
14:21:27 <quicksilver> fasta: but yes, assertions in that sense are a poor match with lazy code. can't say it bothers me much :P
14:21:46 <fasta> quicksilver: I am not sure whether you made an error or use syntax that I have never seen. I know guards, I know case, but I haven't see that combination.
14:21:59 <fasta> quicksilver: can you paste to hpaste.org something that compiles?
14:22:14 <pitecus> quicksilver it would be a bit of a pain to use that withModel thing. Itd be better if the model was destroyed once noone is using it
14:22:48 <monochrom> fasta: I did this test.  main = do { assert False (return ()); putStrLn "hello" }.  It works.  You may like to review your mental model.
14:24:43 <quicksilver> > case () of () | (not (3==4)) -> error "assertion failed" | otherwise -> 42
14:24:44 <lambdabot>  Exception: assertion failed
14:24:47 <quicksilver> fasta: like that
14:25:29 <fasta> monochrom: ok, hmm, maybe that has changed then? I am fairly sure it didn't work like that some time ago.
14:25:39 <quicksilver> mind you, it's not actually any different from just if (not p) then error "assertion failed" else 42
14:25:49 <quicksilver> but it might look neater in some contexts
14:25:54 <fasta> monochrom: no, I remember: it was Debug.Trace.trace
14:26:13 <fasta> monochrom: I used the () <- hack to get trace to work as wanted.
14:27:51 <monochrom> main = do { trace "x" (return ()); putStrLn "hello" }  also works.
14:28:16 <monochrom> main = do { return (trace "x" ()); putStrLn "hello" }  is a different story.
14:28:50 <monochrom> Everything I said is invalidated if you use another monad.  It's >>= definition dependent.
14:32:53 <quicksilver> quite
14:33:00 <quicksilver> IO is almost completely strict
14:33:17 <quicksilver> except to the extent that you can define custom IO actions which ignore their arguments and stuff
14:33:23 <fasta> It was probably State
14:33:41 <quicksilver> state is, AFAIK, totally lazy in values
14:33:50 <quicksilver> only evaluates the value if you actually use it
14:33:58 <monochrom> IO forces the action but leaves the return value alone.  trace "x" (return undefined)  gets through.
14:34:45 <quicksilver> monochrom: all monads will let that through, won't they? isn't that parametricity?
14:34:54 <quicksilver> monochrom: no monad should do anythign to a 'plain return' ?
14:35:07 <monochrom> Control.Monad.State has gone through some changes in forcing. It began maximally lazy, but people gradually wanted it more strict.
14:35:29 <monochrom> Yes, monads should leave return values alone.
14:36:04 <fasta> alt 	 -> 	 pat -> exp [where decls] | 	pat gdpat [where decls]
14:36:16 <fasta> I never used this second production.
14:36:43 <monochrom> Oleg loves it.
14:37:23 <fasta> I am only not sure what the semantics of an empty alternative are.
14:37:31 <fasta> > case () of () |
14:37:31 <lambdabot>  Parse error
14:37:47 <monochrom> > case () of () | -> True
14:37:48 <lambdabot>  Parse error
14:37:55 <monochrom> maybe disallowed
14:38:01 <fasta> http://www.haskell.org/onlinereport/syntax-iso.html
14:38:02 <lambdabot> Title: Haskell 98 Syntax
14:38:15 <fasta> Third productions of "alt"
14:38:16 <quicksilver> that's not an empty alternative
14:38:20 <quicksilver> that's an empty guard
14:38:21 <fasta> er production
14:38:24 <quicksilver> what are you trying to do?
14:38:47 <fasta> Oh, never mind
14:38:51 <fasta> > case () of ()
14:38:52 <lambdabot>  Parse error
14:39:03 <quicksilver> > case () of () -> 42
14:39:05 <lambdabot>  42
14:39:39 <fasta> quicksilver: why would that match the third production rule?
14:40:33 <quicksilver> oh that
14:40:36 <monochrom> I'm too lazy to look it up, but "case () of () -> 42" most definitely match a rule without |
14:40:43 <quicksilver> that's jsut to allow a trailing ';' isn't it?
14:41:34 <fasta> quicksilver: that might be the reason
14:42:11 <fasta> quicksilver: I know there's a difference between the parse tree and the AST. Maybe this is one such a difference.
14:42:12 <quicksilver> or
14:42:19 <quicksilver> it could be to match no case at all
14:42:20 <quicksilver> as in
14:42:25 <quicksilver> case Void of { }
14:42:38 <fasta> > case () of
14:42:38 <lambdabot>  Parse error
14:42:42 <fasta> > case () of {}
14:42:42 <lambdabot>  Parse error
14:43:00 <fasta> case exp of { alts }  (case expression)
14:43:01 * ddarius wants empty cases.
14:43:14 <quicksilver> > case x of { }
14:43:15 <lambdabot>  Parse error
14:43:18 <fasta> A never mind
14:43:24 <monochrom> Me empties ddarius's computer case.
14:43:26 <wilx> > case () of { _ -> () }
14:43:27 <lambdabot>  ()
14:43:36 <fasta> alts  ->  alt1 ; ... ; altn  (n>=1)
14:43:47 <monochrom> heh heh heh! n>=1
14:43:53 <fasta> Note the n>=1 :)
14:44:01 <quicksilver> yes, but
14:44:08 <quicksilver> alt1 = (empty alternative)
14:44:11 <ddarius> There is no reason to disallow empty cases for the same reason there is no reason to disallow empty data declarations.
14:44:19 <quicksilver> > case x of { ; }
14:44:19 <fasta> quicksilver: oh, right.
14:44:19 <lambdabot>  Parse error
14:44:20 * monochrom furthermore pumps out air from ddarius's empty computer case.
14:44:35 <quicksilver> I've see people casing over empty types
14:44:38 <quicksilver> but I can't remember why
14:44:42 <monochrom> Now the only thing left is quantum fluctuation virtual particles.
14:44:43 <quicksilver> some silly forcing thing IIRC
14:45:21 <fasta> I have seen people whine on all knowing IDEs for Haskell.
14:45:30 <fasta> This morning, even.
14:45:37 <quicksilver> augustss would know
14:45:42 <quicksilver> but he's not here :)
14:45:42 <monochrom> That was a dream, not a whine.
14:45:59 <fasta> monochrom: when you put it on the mailing lists, it is. :)
14:46:13 <fasta> Or "troll"
14:46:22 <monochrom> err I was serious!
14:46:36 <monochrom> OH! "you" doesn't mean me.
14:46:55 <fasta> I read the HCI docs and it would seem Emacs even passes it.
14:47:19 <ddarius> data Void;  void :: Void -> a;void v = case Void of {}
14:48:39 <ddarius> Void is "the" initial object and the empty case is the mediating arrow.
14:49:16 * fasta first needs to download extra libs package to check
14:49:38 <raxas> fasta: the reality is, kdevelop 3.4 removed support for haskell and haskell plugin. reason: haskell is useless
14:49:45 <fasta> Although, it makes sense.
14:49:52 <raxas> http://www.kdevelop.org/index.html?filename=3.4/ChangeLog.html
14:50:40 <fasta> raxas: the spelling mistake on that page in my native language make my eyes burn.
14:50:45 * monochrom never installs the KDE suite. Reason: KDE is useless.  (duck)
14:51:06 <fasta> I still have it installed, but don't use it.
14:51:20 <fasta> I know a nice k3b trick
14:51:29 <fasta> (to lose all your data)
14:51:38 <fasta> (well, all data on one disk)
14:51:39 <monochrom> k3b = ?
14:51:51 <fasta> Some hyped burn program
14:52:04 <ddarius> How do you hype a burn programL
14:52:15 <monochrom> Oh you can hype anything.
14:52:23 * psnl hypes #haskell
14:52:31 <fasta> Take 1000 zealots and scream "OMFG, it's FANTASTIC".
14:52:35 <monochrom> I even know how to hype up structured programming.
14:52:57 <monochrom> http://www.vex.net/~trebla/humour/book_for_sale.html
14:52:58 <lambdabot> Title: Book For Sale
14:54:11 <fasta> Anyway, when you insert a cd, make a new data project, drag the files from the cd, start the burn process, it erases the cd (although it asks), and then finds that the files your dragged don't exist anymore...
14:54:24 <fasta> Duh...
14:54:24 <monochrom> Two thirds of the authors are dead now. :(
14:55:42 <fasta> Gnome OTOH, does the right thing.
14:55:48 <monochrom> OK that's a minor sillyness and can be improved.
14:56:02 <fasta> People clamoring that KDE is superior is hereby debunked.
14:57:06 <monochrom> Only a brain implant is superior.
14:57:07 <DRMacIver> There's one irrefutable proof of KDE's inferiority as far as I'm concerned.
14:57:25 <DRMacIver> The number of virtual desktops allowed is limited to 9. :)
14:57:46 <psnl> DRMacIver: wha?
14:57:58 <DRMacIver> Or maybe it was 16, I forget.
14:58:02 <fasta> How is the Debian package for extra libs called?
14:58:07 <DRMacIver> Some similar unacceptably small number.
14:58:11 <fasta> I need Control.Monad.State in 6.6.1
14:58:19 <psnl> DRMacIver: how many do you need?
14:58:24 <dmwit> DRMacIver: Oh no, xmonad is doomed!
14:58:28 <dmwit> =P
14:58:31 <fasta> I only use 4 virtual desktops
14:58:45 <DRMacIver> psnl: n. :)
14:58:52 <DRMacIver> dmwit: Yep. :)
14:59:19 <psnl> DRMacIver: I think you need to hack xmonad for a while to get that
14:59:34 <DRMacIver> psnl: My default number of virtual desktops is 25. This is usually sufficient.
14:59:51 <DRMacIver> (To be honest I rarely need more than 16)
15:00:24 <fasta> DRMacIver: how many physical screens do you have?
15:00:44 <DRMacIver> Just the one at the moment. I have two, but I never get around to setting up the second to work.
15:00:57 <DRMacIver> (I don't really understand X very well)
15:01:06 <fasta> Ok, Debian split extra-libs into tons of pieces. How very Debian.
15:03:23 <stepcut> xmonad is configured by default to 9 virtual desktops. But, it's just a config file, you can change it.
15:03:29 <monochrom> fasta: libghc6-mtl-dev maybe?
15:04:09 <fasta> monochrom: yes, I found it already
15:04:19 <fasta> monochrom: but I can't install it, since it requires <6.6
15:04:29 <monochrom> It is a bad sign I can generate those package names. I don't even use debs.
15:04:34 <monochrom> OH!
15:06:49 <dmwit> > succ '9'
15:06:51 <lambdabot>  ':'
15:07:19 <dmwit> I would say the xmonad keyboard shortcuts for getting to workspaces above 9 would be a bit... odd... by default.
15:08:34 <monochrom> 1.0.1-1 requires >= 6.6.1
15:10:13 <fasta> monochrom: ok, then it were some other libghc6-libs
15:10:40 <raxas> having 3 physical screens and 18 kde desktops on a single machine, without xinerama support xmonad is useless for me
15:11:32 <ddarius> xmonad has xinerama suport...
15:11:32 <fasta> I can imagine xmonad to be useless anyway, since it's not mature software.
15:12:16 <raxas> ddarius: if it has, it certainly does not work on my setup
15:12:18 <fasta> It's just a marketing project, as far as I am concerned.
15:12:20 <nominolo> bringert: http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html  let's see what kind of (if any) responses i get :)
15:12:21 <lambdabot> Title: nominolo's Blog: Network.HTTP + ByteStrings
15:12:28 <monochrom> It seems that debian unstable is the most consistent and updated for ghc and friends.
15:12:52 <fasta> monochrom: yes, I think so too. Ubuntu is hell in that area.
15:13:01 <ddarius> http://www.xmonad.org/\
15:13:42 <fasta> (if it wouldn't be a marketing project, it wouldn't have "Haskell" in the first sentence)
15:13:54 <ddarius> raxas: If it doesn't work on your setup and you've checked the documentation etc. bug the developers.
15:14:44 <dmwit> raxas: Hop over to #xmonad, there's at least three people there who are currently using xmonad on xinerama.
15:15:35 <raxas> ddarius: no problem for me. anyway, I need no 1990 MS Windows-286 alike window manager in 21 century
15:16:00 <stepcut> raxas: xmonad has xinerama support (has since < 0.1). The xinerama support is under going a major rewrite for the next few days though
15:16:02 <ddarius> I wish 1990's windows had been like that.
15:17:23 <raxas> ddarius: it was, Windows 2.0 and Windows 286, a "revolutionary" tiling window manager.
15:17:48 <raxas> looking and behaving exactly just like xmonad
15:17:49 <fasta> I think Windows is a toy everytime I work with it.
15:18:36 <raxas> unfortunately for haskell's future, lot of haskellers are bound to Microsoft
15:18:50 <ddarius> Perhaps I didn't use that specific version, but I don't recall windows looking like it nor do I recall it working all that similarly.
15:18:53 <stepcut> like Simon and Simon ?
15:19:18 <ddarius> raxas: ? Wtf?  How does that impact Haskell's future at all?
15:19:44 <fasta> raxas: if everyone decides to stop developing GHC, someone will write a compiler to compile it to some other language that is being developed.
15:20:16 <fasta> (and not to mention the other existing compilers)
15:20:29 <raxas> while visual studio support grows and kdevelop support dropped, and no one sees a problem?
15:20:43 <monochrom> xmonad does some modern things, even ahead of other window managers.
15:20:45 <rashakil_> I need no 1990 programming language in the 21 century
15:20:46 <fasta> raxas: no, almost everyone uses Emacs/Vim
15:20:58 <ddarius> Most Haskell software is either multiplatform (i.e. *nix and Windows) or *nix only.
15:21:09 <fasta> raxas: I installed Visual Studio, the interface is daunting.
15:21:30 <Eelis> does xmonad have (ion3-style-)tabbing yet?
15:21:38 <fasta> raxas: if you work years with it, it probably is good, though.
15:21:39 <shapr> I bought visual studio once, the price daunted me.
15:22:03 <monochrom> Why are we feeding the whiner?
15:23:14 <raxas> yes, leave me alone, I am coding some Qt4<->Haskell stuff
15:24:17 <fasta> ddarius: your Void example doesn't seem to work here.
15:24:20 <fasta> ddarius: did you test it?
15:24:21 <shapr> raxas: Be nice
15:24:56 <ddarius> fasta: I know it doesn't work.  I'm just saying it is perfectly reasonable.  (Incidentally, data Void will work with -fglasgow-exts but I still think empty cases are disallowed.)
15:24:57 <monochrom> The Void example is not legal Haskell yet.
15:25:49 <ddarius> shapr: Meh, just use the principle of revealed preference.  Nothing need be said.
15:25:58 <fasta> Ok, so the grammar is more general then the set of legal expressions (which isn't surprising).
15:26:19 <shapr> ddarius: I'm talking about the general tone of comments by raxas.
15:26:34 <fasta> shapr: Everyone can use /ignore
15:27:07 <ddarius> Indeed.  No one need reply to raxas (about this stuff).  Despite what he says, he is nevertheless here.
15:27:10 <shapr> fasta: Yes, but I strongly believe that /ignore is bad for communities, because unless it's a channel-wide ignore, newbies get subjected to objectionable people.
15:27:14 <fasta> (not that that solved everything)
15:27:22 <shapr> Ergo, I have a better way to do channel-wide ignore.
15:28:04 <monochrom> The only way to steer newbies away from objectionable people is /ban
15:28:47 <fasta> An intelligent ignore command would be nice. (e.g. if you talk to someone who I have ignored)
15:29:16 <DRMacIver> fasta: You can get pretty close by ignoring all lines which contain that person's name.
15:29:21 * DRMacIver has done it in the past
15:29:24 <fasta> It only requires that people talk to trolls using the troll: hi troll syntax
15:29:56 <fasta> DRMacIver: I programmed a similar thing for rcirc s.t. I hear a sound when my name is mentioned.
15:31:19 <monochrom> How about this. If someone whines, to the point of giving FUD to newcomers, we just say, "that's an unjustified over-generalization out of emotion, and you know it".
15:31:51 <EvilTerran> i much prefer the term "pink fluffy bunnies"
15:32:24 <fasta> @where+ whine that's an unjustified over-generalization out of emotion, and you know it.
15:32:24 <lambdabot> Done.
15:32:30 <nominolo> I am still confused why people think overlapping-windows based UIs are "modern"
15:32:34 <fasta> @where whien
15:32:34 <lambdabot> I know nothing about whien.
15:32:38 <fasta> @where whine
15:32:38 <lambdabot> that's an unjustified over-generalization out of emotion, and you know it.
15:32:47 <Binkley> nicely done
15:33:15 <fasta> Do we also have an "is also" command like fsbot?
15:33:25 <shapr> I think primarily negative emotional statements detract from a community. There are rare cases where such statements can be used to motivate a community to improve, but this is not one of those cases.
15:33:45 <nominolo> getting to the right window is a PITA in overlapping windows
15:33:50 <jmob> @pl map (takeWhile (not . (==) '.'))
15:33:50 <lambdabot> map (takeWhile ('.' /=))
15:34:37 <fasta> Is there better software than gv for viewing ps?
15:34:43 <fasta> gv is buggy
15:34:48 <shapr> acroread has advantages sometimes.
15:34:57 <Baughn> Hmm. That's the first time I've seen @pl unequivocally /simplify/ an expression.
15:35:01 <nominolo> fasta: acroread possibly.  though it's a beast
15:35:09 <monochrom> acroread can do ps?
15:35:17 <yaxupaxo> i used evince
15:35:22 <shapr> monochrom: No, I think I need food.
15:35:23 <monochrom> Anyway, I'm on a gnome setup and I use its evince.
15:35:25 * shapr sighs
15:35:28 <monochrom> heh heh
15:35:37 * monochrom feeds trolls to shapr
15:35:40 * shapr laughs
15:35:52 <Binkley> Mm, trolls
15:35:53 <dmwit> shapr is evil
15:35:56 <Binkley> high in vitamin W for whining
15:36:05 <fasta> nominolo is evil too
15:36:07 <shapr> dmwit: It's true, I just hide it well most of the time.
15:36:16 <jmob> monochrom: convert is to a pdf
15:36:21 <nominolo> me? evil?  why?
15:36:28 <shapr> But I'm actually an elitist, intolerant ... something.
15:36:33 <monochrom> I believe there is something even better than evince. I forgot what it is. I think it's on Mac.
15:36:36 <fasta> nominolo: because acroread doesn't do ps?
15:36:52 <nominolo> fasta: oh that. no that was plain confusion.  no evil.
15:37:05 <nominolo> fasta: i wish it would, though
15:37:09 <fasta> nominolo: there are more people with power who claim the same :)
15:37:25 <nominolo> oh, and if it halps the gnome ps viewer sucks bad
15:37:30 <fasta> "I am so sorry about that nuke, I pressed the wrong button!"
15:37:31 <monochrom> convert ps to pdf is usually not nice. there are font problems. some rare cases are free from this problem.
15:37:31 <nominolo> i prefer ghostview
15:38:24 <fasta> I zoomed 10* and gv crashed
15:38:37 <nominolo> oh
15:38:53 <nominolo> is that the gnome default viewer?  or is that a shortcut for ghostview?
15:38:53 <fasta> and evince has a built-in limit
15:39:02 <fasta> How very annoying
15:39:16 <fasta> nominolo: evince is default gnome
15:39:20 <monochrom> evince is the gnome default viewer.
15:39:49 <fasta> One would expect that after this many years one would have produces something that can do arbitrary operations with ps files.
15:40:07 <stmartin> Any idea when hpaste is going to be available again.
15:40:30 <nominolo> no they spent there energy developing uselessly flashy window managers like beryl
15:40:47 <nominolo> *their
15:40:55 <fasta> I don't understand why people use beryl.
15:41:26 <fasta> I tried it a month ago for the second time and none of the issues were solved that I had when I tried it a year or so ago.
15:41:46 <stmartin> They want to feel that their machines are capable of looking good and being nicely functional in that at the same time. One out of two ain't bad I suppose... ;^)
15:41:54 <ddarius> fasta: There is no hope of sanely being able to do arbitrary operations with ps files depending on what all you are including in "operations".
15:42:46 <fasta> ddarius: ok, zooming then.
15:42:48 <dmwit> I found changing workspace with the mouse occasionally useful, and live previews in Alt+Tab is nice, too.
15:42:58 <fasta> ddarius: zooming to arbitrary levels should be possible, AFAIK
15:43:00 <dmwit> So there are some things that improve usability.
15:43:22 <ddarius> fasta: I think it should be.  I'm not 100% sure though.
15:43:26 <nominolo> dmwit: though, wobbly windows definitely isn't one of them
15:43:35 <dmwit> nominolo: No.  Cute, though. =)
15:43:57 <nominolo> dmwit: search based window navigation is even more effective though
15:44:14 <dmwit> ?
15:44:50 <nominolo> well, think of an interface where you type part of the window's title and it becomes active
15:44:55 <monochrom> If I have 20 gimp windows editing 20 pictures, they are all unnamed yet, how do I search?
15:45:00 <nominolo> of course with autocompletion
15:45:12 <ddarius> Less mouse, more keyboard... no scratch that.  Less mouse, less keyboard!
15:45:25 <nominolo> monochrom: well, for those things visual nav is better of course
15:46:03 <dmwit> Have you ever used a system that allowed this??
15:46:53 <nominolo> dmwit: no.  it was suggested by jef raskin.  his son has a company and a windows-based product that does similar kind of stuff.
15:47:20 <fasta> nominolo: Emacs does about the same on the buffer level
15:47:29 <nominolo> dmwit: tha last video --> http://www.humanized.com/products/enso/launcher/
15:47:31 <lambdabot> Title: Humanized > Our Products > Enso Launcher
15:47:31 <fasta> I would be surprised if you could "patent" that.
15:47:41 <nominolo> fasta: yes i know.  i use ido-mode
15:48:32 <nominolo> fasta: that's why i'm convinced of its effectiveness :)
15:48:46 <fasta> "Humanized", LOL
15:49:29 <fasta> http://paste.lisp.org/display/40381 <- this level of integration is also nice.
15:49:34 <nominolo> fasta: jef's book is called "The Humane Interface"
15:49:35 <stmartin> Don't anthropomorphise computers. They hate that.
15:50:05 <fasta> Too bad it doesn't work.
15:50:36 <dmwit> nominolo: Hum, seems interesting.
15:50:41 <nominolo> fasta: you mean slime fuzzy completion?
15:51:23 <nominolo> dmwit: aza also gave a google talk: http://video.google.com/videoplay?docid=-6856727143023456694
15:51:24 <lambdabot> Title: Away with Applications: The Death of the Desktop - Google Video
15:51:37 <nominolo> pretty long, but gives you some ideas what this is about
15:52:46 <nominolo> it's a long way to go though
15:54:09 <nominolo> i like his comparision of 1977 UIs (Xerox PARC) against 2007 UIs (MacOSX).  looks scarily similar
15:54:27 <fasta> nominolo: I mean clicking on a link to a function and getting to the GNU Elisp docs.
15:56:26 <jmob> Is it possible to merge two monads?
15:56:41 <nominolo> jmob: yes, using Monad transformers
15:56:47 <jmob> I have the following error:
15:56:48 <jmob>     Couldn't match expected type `CGIT IO CGIResult'
15:56:48 <jmob>            against inferred type `IO CGIResult'
15:57:05 <nominolo> what kind of monad is CGIT?
15:57:06 <jmob> So, I think I want to "lift" one of my results in tot the CGIT monad
15:57:32 <Saizan> ?type liftIO
15:57:34 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:57:45 <nominolo> jmob: yes, but to do this you have to "embed" IO into your monad
15:57:54 <jmob> http://www.haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html
15:57:56 <lambdabot> http://tinyurl.com/yq53cj
15:58:36 <nominolo> jmob: ok, then you just have to wrap you IO-function in liftIO
15:59:15 <jmob> hooray, compilation
15:59:37 <nominolo> or, I guess in your case, you might also have to call runCGI
15:59:48 <nominolo> :t Network.CGI.runCGI
15:59:51 <lambdabot> forall (m :: * -> *). (MonadIO m) => Network.CGI.Monad.CGIT m Network.CGI.Protocol.CGIResult -> m ()
16:00:10 <jmob> I don't completely understand, I thought my IO function already return an IO monad?
16:00:25 <jmob> Or is liftIO lifting it in to the current monad?
16:00:35 <nominolo> no, i don't know your code, so i can just guess
16:00:40 <nominolo> liftIO might be enough
16:00:41 <ddarius> :t liftIO
16:00:43 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
16:01:19 <nominolo> jmob: you use liftIO if you want call an IO action inside CGIT
16:02:06 <nominolo> er CGI
16:02:12 <jmob> ah, the type sig makes more sense now
16:04:09 <Apocalisp> Okay, Haskell is officially awesome.
16:04:16 <Apocalisp> @pretty isConvex = let zipc f l = zipWith f l (tail l ++ [head l]) in (0 ==) . sum . map signum . zipc crossProduct . zipc diff
16:04:16 <lambdabot>  isConvex = let zipc f l = zipWith f l (tail l ++ [head l]) in
16:04:16 <lambdabot>                      (0 ==) . sum . map signum . zipc crossProduct . zipc diff
16:04:50 <Apocalisp> How many lines of C code does that replace?
16:05:03 <Binkley> a metric crapload?
16:05:16 <Apocalisp> An imperial crapload, even.
16:05:40 <Apocalisp> It's just so... pretty.
16:05:43 <nominolo> did you compare perforamance also? ;)
16:05:57 <jmob> Apocalisp: not really a far comparison I'd say
16:06:05 <jmob> fair even
16:06:13 <ddarius> tail l ++ [head l] suggests a different data structure should be used.
16:06:24 <Apocalisp> oh yea?
16:06:33 <dibblego> ?where DList
16:06:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
16:06:34 <Apocalisp> I did find that a bit awkward
16:06:38 <nominolo> or maybe a reverse on the outside
16:06:39 <dibblego> maybe one of those
16:07:06 <ddarius> Data.Seq
16:08:32 <Apocalisp> Makes sense. A polygon is a sequence and not a list.
16:08:53 <Apocalisp> Can I still use zipWith?
16:08:59 * ddarius always considered polygons geometrical figures...
16:09:16 <ddarius> Apocalisp: There should be a zipWith equivalent somewhere
16:09:20 <Apocalisp> well, in the current context it is a sequence of cartesian coordinates.
16:09:27 <ddarius> If not, it's not hard to write.
16:09:50 <ddarius> @doc Data.Seq
16:09:50 <lambdabot> Data.Seq not available
16:11:44 <Binkley> @yow
16:11:45 <lambdabot> My pants just went to high school in the Carlsbad Caverns!!!
16:11:48 <Apocalisp> Right, zipWith would be easy to write.
16:12:49 <Apocalisp> jmob: not a fair comparison to C, no. s/C/Java.
16:14:20 <Binkley> @quote
16:14:20 <lambdabot> kzm says: I therefore propose that all functions should either be of type '() -> ()', or non-terminating.
16:14:40 <dmwit> nominolo: (re: Enso) It's like they're converging on the terminal (although of course with different command names).
16:14:52 <Saizan> java can only have zipWith in her wettest dreams
16:15:09 <ddarius> @google Transfold
16:15:13 <lambdabot> http://bioinformatics.bc.edu/clotelab/transFold/
16:15:13 <lambdabot> Title: transFold: transmembrane protein structure prediction
16:15:22 <ddarius> Hmm... not what I wanted.
16:15:30 <ddarius> @google Transfold programming
16:15:32 <lambdabot> http://nar.oxfordjournals.org/cgi/content/full/34/suppl_2/W189
16:15:32 <lambdabot> Title: transFold: a web server for predicting the structure and residue contacts of tra ...
16:15:41 <ddarius> One last go.
16:15:49 <ddarius> @google Transfold "Design Patterns"
16:15:51 <lambdabot> http://www.mm.informatik.tu-darmstadt.de/staff/kuehne/fps/
16:15:52 <lambdabot> Title: FPS - Functional Pattern System
16:16:02 <Apocalisp> Useful, though, if you ever need to predict transmembrane protein structure.
16:16:52 <ddarius> One always needs to predict transmembrane protein structure.
16:17:04 <Apocalisp> ...as one does.
16:20:04 <nominolo> dmwit: yes.  the idea is that's a more usable command line interface
16:20:28 <dmwit> Yeah, there's a lot of nice things that don't really fit onto a Linux-style command line.
16:20:50 <ddarius> Like bonsai trees.
16:21:27 <nominolo> dmwit: i'm doing some experiments with those ideas myself.  but very low priority
16:21:32 <Apocalisp> is that like a b-tree?
16:22:09 <nominolo> no, b*-tree
16:23:20 <Apocalisp> The next time somebody asks me what B stands for in B-tree, I'm going to say "bonsai".
16:24:41 <nominolo> dmwit: basic realization:  point and click is hopelessly inefficient for many applications.  command line is good, though in it's current incarnation very hard to learn, because, for efficiency reasons it uses wird shortcuts
16:25:33 <nominolo> dmwit: also folders are bad.  humans are better at spacial navigation and optical recognition - so let's use a zoomable interface
16:25:50 <nominolo> dmwit: and to allow effictient navigation add ubiquitous search
16:25:52 <dmwit> Yeah, but that argument doesn't convince me yet.
16:26:12 <dmwit> ... where "that argument" refers to the "remove all hierarchies" argument.
16:26:32 <migraine> eureka my IO brain works in haskell
16:26:46 <nominolo> dmwit: no, i mean "bury in folders".  you can organize stuff spacially
16:27:06 <nominolo> dmwit: and by tags
16:27:49 <nominolo> of course, to actually understand if this will work or not you'd have to implement it. effiently.
16:28:42 <dmwit> I don't think this is better.  The biggest projects I worked on felt most natural when I used a tree-based mental model like packages/modules/files/functions.
16:29:20 <raxas> nominolo: if you want something simple and special, try navigation in flat isometric space, it is more natural to human brain than full 3d
16:29:34 <nominolo> well, they had a good example, where they organized patient data in a hospital by putting it onto a zoomable map of the hospital
16:29:58 <nominolo> so if you wanted to access the patient's data you'd just zoom to the room and there it was
16:30:08 <nominolo> 5 seconds learning time to use this interface
16:30:55 <nominolo> raxas: i'm not talking about real 3d like in shooters or sth.
16:31:04 <nominolo> more like the ability to "take a step back"
16:31:28 <nominolo> like in a planning room where you pin your stuff on the wall (not that i ever been in one)
16:32:11 <nominolo> The biggest problem i see with those kinds of interfaces is to make the data accessable to automation.
16:33:56 <davidL> does Data.IntSet.difference work with infinite IntSets?
16:34:15 <dmwit> Int is not infinite...
16:34:39 <dmwit> > (maxBound, minBound) :: (Int, Int)
16:34:41 <lambdabot>  (2147483647,-2147483648)
16:34:54 <davidL> I know, which is why I said IntSet :P
16:34:58 <nominolo> davidL: also, yes, it requires all of the elements to be in memory
16:35:11 <Binkley>  > Data.IntSet.difference (Data.IntSet.fromList [1,2]) (Data.IntSet.fromList [1..])
16:36:03 <davidL> ?bot
16:36:04 <lambdabot> :)
16:36:18 <davidL> > Data.IntSet.difference (Data.IntSet.fromList [1,2]) (Data.IntSet.fromList [1..])
16:36:24 <lambdabot> Terminated
16:36:26 <nominolo> there was a " " too much
16:36:41 <dmwit> How do you propose to build an infinite subset of a finite set?
16:36:59 <ddarius> raxas: You mean like tiles?
16:37:03 <nominolo> using a predicate?
16:37:03 <dmwit> Or do you mean something like (fromList . cycle $ [1,2])?
16:37:58 <davidL> Nevermind, you are right.
16:42:45 <raxas> ddarius: isometric tiles, boxes, roads, pipes...
16:44:12 <raxas> ddarius: better human brain perception than 2d but still almost the same simplicity of handlng as 2d
16:44:47 <dcoutts> nominolo: gtk2hs would be a good test case of cabal-configs however it also needs several other cabal features first
16:44:48 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:44:56 <raxas> ddarius: and already proven in games for decades
16:46:48 <nominolo> dcoutts: well, i have 3 months ;)
16:47:09 <dcoutts> nominolo: I think cabalising gtk2hs will take longer than that :-(
16:47:24 <dcoutts> nominolo: but the base lib split up is a great test case
16:47:43 <dcoutts> nominolo: just the issue of tracking which deps we need
16:47:57 <nominolo> uh
16:47:59 <nominolo> k
16:48:09 <dcoutts> eg base-2.0 or base-2.x + bytestring-1.0
16:54:54 <nominolo> thanks, i take a look
17:02:54 <dainanaki> hey is anyone in here using ghc 6.6.1 on an intel mac?
17:06:16 <nominolo> me
17:06:50 <nominolo> whaddoyouwannaknow?
17:07:01 <ChilliX> dainanaki: me, too, works fine
17:20:18 <dainanaki> well i get the following error: ian$ /usr/local/bin/ghci
17:20:20 <dainanaki> dyld: Library not loaded: GNUreadline.framework/Versions/A/GNUreadline
17:20:20 <dainanaki>   Referenced from: /usr/local/lib/ghc-6.6.1/ghc-6.6.1
17:20:20 <dainanaki>   Reason: image not found
17:20:20 <dainanaki> Trace/BPT trap
17:24:37 <nominolo> yes, you have to install that separately
17:24:49 <nominolo> isn't there a link on the homepage?
17:25:01 <dainanaki> not that i saw...
17:25:52 <dainanaki> and as a side note, how do i set PATH?
17:26:03 <Binkley> dainanaki: that depends what shell you're using
17:26:43 <dainanaki> the standard whatever that comes with os x?
17:26:48 <nominolo> dainanaki: ok, it's buried in a link to a mail message. not quite obvious
17:26:52 <dainanaki> looks like bash
17:27:16 <nominolo> i had 6.6 installed before, so i got that
17:27:28 <dainanaki> nominolo, could you post the link perhaps?
17:28:25 <Binkley> dainanaki: declare -x PATH=$PATH:[whatever]
17:28:51 <dainanaki> thank you Binkley
17:29:08 <nominolo> dainanaki: i'm looking.  i think i installed libreadline when ghc wasn't a macports package yet.
17:29:50 <dainanaki> would i have to install via macports now?
17:31:15 <dainanaki> well it looks like it'll let me get the GNUreadline-framework, but I'm getting a 404 on the GMP.framework
17:32:22 <nominolo> uh.
17:33:03 <nominolo> ok, my first ghc installation was the 6.5.20060608 that installed GMP for me
17:33:29 <nominolo> since then i no longer had to care. i assume macports now takes care of this
17:34:09 <illusionalSin> hi
17:34:09 <dainanaki> well i installed 6.6 thinking that would take care of it since 6.6.1 is a more incremental relaese, but for some reason it won't recognize the 6.6 data?
17:34:27 <dainanaki> when i install 6.6.1 again, that is
17:35:30 <nominolo> hm, that shouldn't make a difference for the installed frameworks
17:35:55 <Igloo> The 6.6 bindist included some frameworks, I think
17:36:14 <dons> ?users
17:36:15 <lambdabot> Maximum users seen in #haskell: 340, currently: 285 (83.8%), active: 43 (15.1%)
17:36:37 <nominolo> maybe this helps?  http://www.haskell.org/pipermail/glasgow-haskell-users/2007-May/012576.html
17:36:39 <lambdabot> Title: ghc-6.6.1 Mac (Darwin) Binary Dists, http://tinyurl.com/2hya9r
17:36:40 <chessguy> @quote
17:36:40 <lambdabot> SamB says: * SamB wonders why oh.
17:37:21 <dainanaki> nominolo, that third link gives me a 404
17:38:03 <chessguy> and a bunch of german cursing
17:38:04 <nominolo> yeah, it should be "GMP-Framework"
17:38:14 <nominolo> ie, s/./-/
17:38:28 <nominolo> the first link has a link to the correct address
17:38:40 <nominolo> http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/hets/mac/GMP-framework.zip
17:38:44 <lambdabot> http://tinyurl.com/265yrp
17:39:09 <nominolo> chessguy: no, that's no cursing
17:39:25 <dainanaki> awesome, so where do i stick these frameworks
17:39:30 <chessguy> technically, s/./-/ wouldn't work in this case, but i guess i shouldn't be pedantic about it...
17:39:31 <dibblego> > let fac = \n -> if n == 1 then 1 else n * fac (n -1) in fac 5 -- how do I write this without referring to fac?
17:39:33 <lambdabot>  120
17:39:38 <ChilliX> IMHO, the easiest way to get GHC on an intel mac is to install macports and type "sudo port install ghc" (the rest is automatic)
17:39:49 <chessguy> > product [1..5]
17:39:50 <lambdabot>  120
17:39:57 <dibblego> good poit
17:40:14 <chessguy> > let fac n = product [1..n] in fac 5
17:40:15 <lambdabot>  120
17:40:19 <dainanaki> ok is X11 installed when i install xcode?
17:40:32 <chessguy> @pl f n = p [1..n]
17:40:32 <lambdabot> f = p . enumFromTo 1
17:40:45 <chessguy> cute
17:40:49 <nominolo> dibblego: /Library/Frameworks
17:40:56 <ChilliX> dainanaki: no, you need to install X separately from the install disks that came with yoru mac
17:40:58 <nominolo> i think it's described on the first link
17:41:21 <dibblego> nominolo, I don't know what you mean
17:41:26 <nominolo> uh, sry, dibblego
17:41:37 <nominolo> meant to address dainanaki
17:41:45 <dibblego> ok
17:43:48 <dainanaki> ok well for macports i don't see on the install disk where the X11 stuff is
17:45:02 <nominolo> no it's on the macosx dvd
17:45:17 <ChilliX> dainanaki: you should have got some DVDs with your mac
17:45:25 <dainanaki> yeah i have os x install disk 1 and 2
17:45:30 <nominolo> same as where xcode is on, i think
17:45:38 <ChilliX> put disk 1 into your mac
17:45:43 <dainanaki> oh lemme look
17:45:58 <ChilliX> the macports page has a description of how to do it
17:46:09 <ChilliX> (there is X11 in macports, but they recommend to not use it)
17:46:25 <ChilliX> ( but use the Apple one instead)
17:49:08 <zorg0f> hey, im having some problems getting my head around wildcards / pattern matching and i was hoping someone could help explain
17:49:29 <Binkley> we're all ears
17:50:08 <zorg0f> for example: tail x:xs = xs . what's the difference with tail(_:xs):xs
17:50:20 <zorg0f> sorry, that last colon should be an equals
17:50:59 <dmwit> nothing
17:51:24 <dmwit> well
17:51:29 <zorg0f> just a different method?
17:51:48 <Binkley> zorg0f: in the first one, you're giving a name to the first element of the list, and in the second, you're saying "I don't care what the first element is"
17:51:48 <Eelis> the _ makes it more explicit that the term is not used
17:51:50 <dmwit> The only difference is that 'x' is bound on the right-hand side of the '='; but since it is not used there, in practice there is no difference.
17:51:54 <Binkley> but the two versions are equivalent because x isn't used
17:52:10 <zorg0f> so, basically using the _ wildcard "bins" *whatever*?
17:52:22 <Eelis> within the bounds of the type, yes :)
17:52:55 <zorg0f> ah ok. i think it was just the example that was confusing me. i assumed there would be more of a difference
17:52:58 <zorg0f> cheers
17:54:29 <zorg0f> im not sure haskell could ever become my daily language of choice - but im beginning to get the hang of it :D
17:54:45 <Eelis> give it time ;)
17:55:31 <Binkley> ?quote vending
17:55:31 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
17:55:31 <lambdabot> of insight hits and it all makes sense.
17:55:50 <zorg0f> heh
17:56:34 <zorg0f> unfortunately i have an exam coming up, so i gotta tip the vending machine a little :P
17:56:47 <illusionalSin> heh, i had a haskell test 2day...just thought id say
17:57:09 <zorg0f> how did it go?
17:57:21 <illusionalSin> well i past :D
17:57:36 <illusionalSin> got A, worth 20% tho overall
17:58:08 <zorg0f> nice
17:58:28 <illusionalSin> ta :)
18:05:28 <chessguy> @quote machine
18:05:28 <lambdabot> tibbe says: I will definately check it out, the thing is that someone turned on the laundry machine in the room next door so my internet connection isn't working well ;)
18:05:42 <chessguy> @quote rock.machine
18:05:42 <lambdabot> No quotes match. stty: unknown mode: doofus
18:05:45 <zorg0f> [x|x<-[1..10],x 'mod' 3 == 0]
18:05:52 <chessguy> @quote tip.machine
18:05:52 <lambdabot> No quotes match. Do you think like you type?
18:05:55 <zorg0f> i'm getting: Improperly terminated character constant
18:06:01 <monochrom> @quote machine.tip
18:06:02 <lambdabot> No quotes match. You speak an infinite deal of nothing
18:06:07 <monochrom> @quote machine.*tip
18:06:07 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
18:06:15 <monochrom> @quote rock
18:06:15 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
18:06:15 <lambdabot> of insight hits and it all makes sense.
18:06:21 <monochrom> THat one!
18:06:26 <chessguy> > [x|x<-[1..10],x `mod` 3 == 0
18:06:26 <lambdabot>  Parse error
18:06:32 <chessguy> > [x|x<-[1..10],x `mod` 3 == 0]
18:06:37 <lambdabot>  [3,6,9]
18:06:53 <chessguy> zorg0f: ^^ you need back-ticks
18:07:30 <zorg0f> oh right
18:07:32 <zorg0f> tta
18:07:35 <zorg0f> ta*
18:08:06 <zorg0f> :)
18:10:00 <zorg0f> that's quite a nice bot, actually.
18:10:55 <monochrom> @botsnack
18:10:55 <lambdabot> :)
18:13:38 <chessguy> @quote bot
18:13:38 <lambdabot> SamB says: [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
18:14:15 <SamB_XP_> @quote bot
18:14:15 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
18:14:36 <SamB_XP_> @quote bot
18:14:37 <lambdabot> Lemmih says: Two lambdabot days is probably like 8 human days.
18:15:12 <mlh> @quote vending
18:15:12 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
18:15:12 <lambdabot> of insight hits and it all makes sense.
18:15:27 <mlh> as long as it doesn't fall on you I guess
18:20:14 <nominolo> @quote human
18:20:14 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
18:20:14 <lambdabot> entire human race would have to be rewritten!
18:22:53 <migraine> ugh I need it to be more lazy...
18:24:45 <dainanaki> haskell, where laziness is a good thing
18:25:25 <augustss> but with a sprinkle of strictness
18:29:09 <zorg0f> i should really go to bed. thanks for the help folks.
18:29:11 <zorg0f> nite
18:33:38 <migraine> i <- hGetContents hndl >>= sequence (map (hPutStr hndl) ((processInput . lines) i))
18:33:48 <migraine> if processInput is "Somestring" : somefunc
18:33:56 <migraine> shouldn't somestring get printed before somefunc is called?
18:35:57 <stmartin> How can I cast a Char to an Int? Char seems not to be an Integral, and I need to use Data.Bits ops on it.
18:36:14 <Igloo> Use ord and chr
18:36:42 <stmartin> Ah, of course.
18:36:52 <augustss> fromEnum
18:36:55 <dainanaki> string manipulation = fun
18:37:18 <dons> heya augustss. how's code?
18:37:27 <stmartin> augustss: excellent. Thanks
18:37:47 <augustss> oh, same same
18:37:50 <stmartin> dainanaki: not exactly. Making a UTF8 encoder for the fun of it.
18:38:50 <dons> hey ndm. up late.
18:39:03 <dons> i wonder if localtime works on cgi interfaces...
18:39:05 <dons> ?time ndm
18:39:06 <lambdabot> Local time for ndm is Mon May 21 20:37:56 2007
18:39:08 <dons> yeah
18:39:17 <ndm> hi dons, yeah, couldn't sleep
18:39:36 <ndm> i talked to my supervisor, and he said i shouldn't release Catch until after the ICFP reviewing result
18:39:46 <ndm> since they specifically say "don't introduce new results in"
18:39:58 <dons> hmm.
18:40:09 <dons> that's in the review rebuttal though.
18:40:19 <dons> i guess that does stop you saying, 'yo, look here'
18:40:31 <ndm> yeah, but i guess it holds until after they've made the decision
18:40:45 <dons> but that doesn't really prevent you from releasing.
18:40:47 <ndm> especially now its no longer anonomous
18:40:51 <dons> you just can't cite stuff that was released.
18:41:03 <ndm> it doesn't really, but my supervisor says its probably best - given its only a month to wait
18:41:15 <dons> was that colin's opinion? that we shouldn't release during the review period?
18:41:27 <dons> or do you have a new supervisor ? :-)
18:41:42 <ndm> yes - since it can give the impression that you are trying to sneak in new results - even if you aren't
18:41:49 <ndm> always colin :)
18:41:50 <dons> yeah, i see.
18:41:54 <ndm> (for 5 years now)
18:42:03 <ndm> i was going to make a pre-release, to you and a few others, private but not particularly secret
18:42:18 <augustss> i can't say i agree with colin on this
18:42:19 <ndm> and then as soon as the review is done, i can fully release that - treat you lot as alpha testers
18:42:20 <dons> yeah, i'd like to get a bit more catch into the xmonad dev cycle
18:42:29 <dons> i.e. run it on every commit, like with QC.
18:42:38 <dons> but i need a widely available tarball for that
18:42:52 <ndm> i don't particularly agree either, but it is only a month to wait, so its not that big an issue
18:42:57 <dons> yeah
18:43:17 <ndm> dons, it still depends on Yhc being installed, which may be too much to ask of everyone
18:43:31 <dons> yeah, that's a bit problematic
18:43:47 <ndm> i do have an agreement that my Haskell Workshop paper will be based on code already in hackage before i submit the paper
18:43:48 <dons> so it uses yhc as a compiler frontend library?
18:43:51 <ndm> yep
18:44:02 <ndm> could just as easily use GHC, if they didn't have a broken Core library
18:44:11 <dons> i wonder if you could break off the frontend as a standalone. or yeah, fix core.
18:44:34 <dons> it would be ideal to just cabal-install yhc-frontend ; cabal-isntall catch
18:44:57 <dons> to be used widely, the yhc dep has to be avoided somehow
18:44:58 <ndm> Yhc front end will be cabal-install'able in about 2 months, after Andrew finishes his phd
18:45:03 <dons> ah ok.
18:45:23 <ndm> and once the GHC.Core thing is done, I can map GHC.Core -> Yhc.Core trivially
18:45:38 <dons> yeah, i can't really adopt it as a foundational tool in xmonad, till basic hackage install works for the toolchain.
18:45:50 <dons> ah so you could -fext-core, and then process that with catch (and no yhc?)
18:46:29 <ndm> yep, easily
18:46:33 <dons> augustss: btw, do you know of any other useful static checkers done for haskell? we're using QuickCheck and Catch (ndm's pattern match verifier). but there must be some other good extended static checking tools we could dig up, to apply to xmonad.
18:47:23 <ndm> dons, my research turned up a few tools, but none that ever supported H98 even...
18:47:37 <dons> hmm. what kind of things?
18:47:44 <dons> (oh ,they're in the paper?)
18:47:45 <ndm> there were strictness analysers
18:48:00 <ndm> no, none of them were within a million miles of practical enough to get into the paper
18:48:08 <dons> ah yes, there's julian sewards anna.
18:48:13 <ndm> plus there are crazy types
18:48:25 <dons> there's Agda, of course. ghc core + proof checking.
18:48:31 <dons> but that's hmm, maybe that's too much.
18:48:37 <ndm> ESC/Haskell is the perfect one to use
18:48:40 <ndm> (if it worked...)
18:48:48 <dons> yeah. that's what we want.
18:48:59 <ndm> me too!
18:49:00 <dons> we need to get dana on here, so we can pester her about it.
18:49:19 <ndm> she's years away from a practical tool, from what i saw
18:49:26 <dons> there's HPC as well. that's pretty practical.
18:49:36 <ndm> but the tool is exactly what you want, when it arrives
18:49:41 <dons> so we could use that to check that QC tests exercise the code we think it does.
18:49:52 <ndm> yep, HPC is cool
18:50:08 <ndm> although the integrated one is 6.8 only
18:50:15 <dons> yeah.
18:50:19 <ndm> you can of course use the stand alone hpc
18:50:56 <dons> any other checkers floating around your research group?
18:51:02 <dons> colin has some secret tools?
18:51:37 <ndm> yes, there is one secret tool floating around our group, but i'm not allowed to tell you what it is...
18:51:44 <dons> heh
18:51:53 <ndm> its a really good one as well
18:51:53 <dino-> The generators in list comprehensions, are those "drawn from" actions in the list monad?
18:52:14 <ndm> dons, you've changed StackSet - it now uses pattern guards again!
18:52:31 <dons> yeah, sorry, i mean to h98 it again.
18:52:45 <dainanaki> oh to be more knowledgable in the ways of haskell :|
18:52:49 <ndm> plus the comment in view reads a bit like "pain for neil"
18:52:56 <ndm>     -- 'Catch'ing this might be hard. Relies on monotonically increasing
18:53:01 <ndm>     -- workspace tags defined in 'new'
18:53:07 <dons> ndm. yeah. hmm. i'm thinking of replacing error with 's'
18:53:20 * ndm suspects thats not true, and not an automatic proof even if it was
18:54:03 <ndm> dons, actually - i was talking to Matt today and he says he's aiming to release Reach (the cool verifier) within a few weeks, so may you can have more super-funky proofs
18:55:24 <dons> ooh. oo. well, let him know we're keen for more checking, and will happily try out alpha software.
18:55:52 <ndm> will do
18:56:03 <Nomius> Can I do? case (something that gives me maybe) of Nothing -> Nothing Just x -> if x then ?
18:56:38 <dons> yeah
18:56:58 <dons> > case Just 2 of Nothing -> Nothing ; Just x | x == 2 -> Just 7 | otherwise -> Nothing
18:57:00 <lambdabot>  Just 7
18:57:24 <Nomius> Thanks dons
18:57:41 <dons> the guard could just as easily be an if/then/else or arbitrary expression
18:59:22 <ndm> dons, are you willing to move to abort x = error x in xmonad?
18:59:28 <migraine> nevermind, I found the problem... g'night
18:59:40 <dons> ndm, yeah.
18:59:44 <dons> ndm, if you want to patch that.
18:59:58 <ndm> ok, i'll make sure i hack that in to the release of Catch
19:00:13 <ndm> not right now - it doesn't Yhc compile for me
19:00:27 <ndm> if you are happy though i'll send in a patch once i've got the Catch supported sorted
19:00:58 <dons> ok.
19:02:58 <dainanaki> so what are you guys working on anyways?
19:03:56 <dons> dainanaki: we're using ndm's pattern match verifier to check that the xmonad window manager core contains no unhandled patterns
19:04:34 <ndm> did we come to any end decision as to where the SOC projects would be hosted?
19:04:46 <dons> i think maybe we can use the new community server!
19:04:56 <dons> otherwise, d.h.o/soc/ again seems reasonable
19:05:02 <dainanaki> oh i heard about xmonad
19:05:14 <dainanaki> that sounds like a neat project you guys have going
19:05:24 <dons> its quite fun.
19:05:43 <dainanaki> perhaps once i learn things about haskell i can help out
19:12:41 <ndm> dons, if i suggested doing guihaskell with hs-plugins, what would you say?
19:12:51 <ndm> its too bitrotted and you'd be in for a world of pain?
19:13:07 <dons> hmm. i'd suggest going with ghc-api
19:13:16 <dons> works for yi 0.2
19:13:19 <ndm> and if it was developed with clean separation between components, how hard would it be to hs-plugins/ghc-api it afterwards
19:13:24 <dons> and is likely to be maintained into the future
19:13:32 <dons> whereas hs-plugins will be bare bones, I think.
19:13:42 <dons> hmm. good question.
19:13:55 <dons> dynamicity really influences the app architecture
19:14:11 <dons> i think unless you're really careful, best to start with the ghc-api model, first, rather than try to retrofit it
19:14:25 <ndm> i can see that guihaskell will merely parameterise by allow buttons to be added, i doubt it will be much more
19:14:37 <dons> we tried hIDE on h-splugins, if you recall. too heavyweight.
19:14:46 <ndm> yes, i remember
19:14:49 <dons> and yi 0.2 on ghc-api has got much further, much faster.
19:14:57 <dons> in particular, full expression eval on the fly works
19:15:07 <dons> somethiing difficult to do with module-based hs-plugins
19:15:13 <ndm> yeah
19:15:22 <ndm> thats something that we don't require for guihaskell though
19:15:25 <dons> the downside is that hs-plugins gives optimised native code
19:15:39 <dons> so for rarely changing components, optimised native code is probably an advantage
19:16:53 <dons> ndm, i wonder if asking for more static checking tools on haskell-cafe@ is worthwhile?
19:16:54 <ndm> hmm, i think i'll recommend guihaskell goes without hs-plugins/ghc-api for now
19:16:59 <dons> maybe it'll uncover some other secret tools
19:17:16 <dons> ndm, probably best to get something working :-)
19:17:19 <ndm> dons, perhaps, who knows whats out there and secret - i bet the programmatica people have something hidden
19:17:20 <mdmkolbe|home> I'd like to try Yi, but don't have darcs and only a minimal GHC (university machine).  The only snapshots I could find are at least a year old.  Are there any options for installing it?
19:17:38 <dons> ndm, yeah, those guys have stacks of code we don't see.
19:17:49 <dons> mdmkolbe|home: hmm. its on hackage now.
19:18:44 <ndm> i bet galois also have something
19:21:18 <dainanaki> how long would i reasonably wait for ghc to compile before deciding it has frozen on a macbook pro
19:23:05 <ndm> dainanaki: 1 day
19:23:21 <Korollary> heh
19:23:29 <ndm> dainanaki: compiling GHC, or using GHC to compile a program?
19:23:39 <dainanaki> compiling GHC
19:23:40 <ndm> 1 day or 1 minute, depending on the question
19:23:52 <dainanaki> its been sitting here for like an hour
19:24:00 <ndm> no new messages?
19:24:00 <Korollary> on the same module?
19:24:04 <dainanaki> yeah
19:24:13 <dainanaki> oh wait
19:24:21 <dainanaki> i just killed it and cleaned the dir
19:24:23 <dainanaki> and restarted
19:24:28 <dainanaki> woosh its past
19:24:32 <dainanaki> nvm
19:27:50 <ndm> anyway, sleep time now
19:27:55 <ndm> night all!
19:29:39 <mdmkolbe|home> dons: ok, I found it
19:30:08 <mdmkolbe|home> does Setup install default to my home directory if I'm not root?
19:31:08 <Korollary> are you talking about cabal?
19:31:19 <mdmkolbe|home> Korollary: yeah, I've never used Cabal before
19:32:14 <Korollary> you need to pass a --prefix arg to configure
19:36:08 <dainanaki> i've heard mixed reviews of hopengl
19:36:13 <dainanaki> is it any good?
19:37:48 <mdmkolbe|home> foiled ... no alex preprocessor available
19:38:43 <dons> is that just a cabal warning?
19:38:48 <dons> not actually a requirement?
19:39:05 <mdmkolbe|home> $ runghc Setup.hs build
19:39:05 <mdmkolbe|home> Preprocessing library yi-vty-0.2...
19:39:05 <mdmkolbe|home> Setup.hs: Yi/Syntax/Haskell.x: no alex preprocessor available
19:39:08 <mdmkolbe|home> it's a build error
19:39:15 <Korollary> yi-vty requires it
19:39:25 <SamB_XP_> huh.
19:39:27 <Korollary> @where alex
19:39:27 <lambdabot> http://www.haskell.org/alex/
19:40:55 * mdmkolbe|home builds alex
19:43:51 <mdmkolbe|home> hmm, it seems cabal doesn't mkdir a prefix directory that doesn't exist yet (I noticed b/c I use stow)
19:44:17 <Korollary> that sounds right. does autoconf's configure create it?
19:47:42 <mdmkolbe|home> aha! cabal dosn't expand the ~ in a prefix
19:53:26 <mdmkolbe|home> yi haw, it built
19:56:55 <mdmkolbe|home> does yi have a tutorial yet? (other than the paper)
19:58:22 <monochrom> ~ is expanded by the shell
19:59:27 <mdmkolbe|home> monochrom: not if I do '--prefix=~/stow/yi', I had to do '--prefix=`echo ~/stow/yi`'
20:00:17 <monochrom> ' tells the shell to not expand
20:00:33 <monochrom> err nevermind
20:00:50 <mdmkolbe|home> monochrom: the ' was meta syntax (I only typed it in IRC)
20:01:02 <monochrom> some shells don't expand ~
20:01:10 <mdmkolbe|home> it was bash
20:01:44 <monochrom> fun. it may have something to do with = immediately preceding ~
20:02:37 <LoganCapaldo> yep its the equal sign
20:02:41 <LoganCapaldo> or at least IME
20:03:07 <LoganCapaldo> or not the equal sign per se but the lack of a space
20:04:57 <LoganCapaldo> an alt. method is to do --prefix=$HOME/stow/yi instead of ~
20:05:14 <mdmkolbe|home> LoganCapaldo: good idea
20:07:53 <dibblego> what does "Catch (Neil's pattern match verifier)" do? makes sure your pattern matching is exhaustive?
20:08:47 <monochrom> Makes sure if your pattern matching is not exhaustive, no usage triggers the missing cases.
20:09:09 <dibblego> how can you do that? it seems impossible
20:09:44 <TSC> I guess can you figure out which constructors are used, and follow their possible existence around
20:11:06 <monochrom> It is as possible as writing correct programs.
20:11:29 <dons> dibblego: static analysis (i.e. the same way the human reader knows there's no pattern failures :)
20:11:40 <dibblego> I guess
20:11:45 <dons> an exapmle:
20:11:45 <dons> with :: b -> (Stack a -> b) -> StackSet i a s -> b
20:11:45 <dons> with dflt f s = case stack (workspace (current s)) of Empty -> dflt; v -> f v
20:12:01 <dons> catch was able to check that the function 'f' only ever gets a non-Empty Stack value
20:12:13 <dons> so that this code is fine:
20:12:14 <dons> index = with [] $ \(Node t l r) -> reverse l ++ t : r
20:12:22 <dons> even though the right hand side only matches on Node, not on Empty.
20:12:35 <dibblego> I see
20:12:51 <dons> you interested in more static checking too , eh?
20:13:11 <dibblego> it certainly interests me
20:13:25 <dibblego> I had a debate with a Lisper this morning, but felt most inept at defending my position
20:13:30 <monochrom> Half a year of studying static checking or model checking or formal methods will rewrite your mind forever.
20:14:01 <monochrom> You will never look at program bugs the same way again.
20:14:16 <dons> definitely.
20:14:29 <dibblego> I have a feeling that I already look at them that way
20:14:35 <dons> i boggle now when I see comments such as " a fully developed human being with moderate programming experience should be able to verify correctness without resorting to convulved automatic checking."
20:14:36 <jfredett> monochrom, rewrite my mind? sounds like fun, where do I sign up?
20:14:39 <dibblego> or tend toward that way anyway
20:14:40 <dons> :-)
20:14:51 <monochrom> U of Toronto has formal method courses.
20:14:56 <dons> monochrom: it teaches you not to trust humans to get things right. :-)
20:15:01 <dibblego> dons, I find that quite audacious
20:15:09 <jfredett> monochrom, hmm, too far for me... know any good books?
20:15:20 <dons> dibblego: yeah, only someone who never verified code would say that :-)
20:15:42 <dons> and it helps to subscribe to the view that difficult of formal verification, corresponds to difficulty of human reasoning about the same code
20:15:59 <monochrom> It depends on program structure.
20:18:48 <monochrom> My interpretation of that statement is: A program should be so well modularized that a fully developed human being with moderate programming experience should be able to verify correctness without resorting to convulved automatic checking.  This is a requirement of program compartmentalization clarity rather than an assertion of the ease of verification of pathalogically convolved programs.
20:18:57 <byteshack> in reading the xmonad 2 article, not sure why a doubly linked list would not have done what the zipper is doing
20:19:08 <byteshack> can someone enlighten me?
20:19:28 <dons> byteshack: how do we track focus?
20:19:51 <dons> the zipper is a doubly linked list (since we traverse left and right) with a hole punched in it, recall.
20:20:29 <dons> and the hole is used to denote focus, so there's no possibility of focus being on a non-visible window
20:20:46 <LoganCapaldo> Zippers are cool
20:20:57 <dons> byteshack: btw, what would the doubly linked data type look like?
20:21:33 <byteshack> I have no idea what it would look like in haskell, but I guess you would have to have that extra pointer to the "focused" window
20:21:33 <mdmkolbe|home> byteshack: doubly linked lists get tricky in Haskell especially if you want to change it
20:21:43 <byteshack> which is what you where wanting to get rid of
20:22:07 <dons> byteshack, right. the idea was not to track focus with a separate index.
20:22:19 <dons> previously, we used a (cycled) list, [a], with an index for focus
20:22:25 <dons> which i think is what you're proposing.
20:22:32 <dibblego> yeah how do you write one of those anyway? I've tried to write one in my head several times and failed
20:22:42 <byteshack> I see how that is what I was thinking
20:22:48 <dons> but that then requires dynamic consistency checks to force the focus index to always be valid. == too much bookkeeping.
20:23:00 <dons> dibblego: a zipper for a structure?
20:23:13 <dons> dibblego: probably easiest to start with a list, then imagine punching a hole in it, to make the current spot.
20:23:15 <dibblego> no a double-linkred list (I don't know what a zipper even is)
20:23:26 <dibblego> ?where zipper
20:23:26 <lambdabot> I know nothing about zipper.
20:23:33 <dons> ?google The Zipper
20:23:36 <lambdabot> http://inventors.about.com/library/weekly/aa082497.htm
20:23:36 <lambdabot> Title: The History of the Zipper
20:23:40 <byteshack> nice article again dons :)
20:23:41 <dons> ?google The Zipper site:wikipedia.org
20:23:43 <lambdabot> http://en.wikipedia.org/wiki/Zipper
20:23:43 <lambdabot> Title: Zipper - Wikipedia, the free encyclopedia
20:24:10 <dons> dibblego: sorry, the best article is on the haskell wikibook
20:24:15 <byteshack> I very much appreciate the insides and the walk through on why things where chosen
20:24:15 <dibblego> ok
20:24:32 <dons> byteshack: cool, that's the idea :-)
20:27:24 <syntaxfree> how does Mercury compare to Mozart/Oz and Prolog?
20:27:30 <dibblego> is that tree supposed to represent the labyrinth on the left of it?
20:27:37 <dibblego> http://en.wikibooks.org/wiki/Haskell/Zippers (that tree)
20:27:38 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
20:28:27 <dons> dibblego: the one that says "An example labyrinth and its representation as tree." ?
20:28:40 <dibblego> yes
20:28:43 <dibblego> :)
20:31:49 <lokadin> when I try to compile using cabal I'm told "Could not find module `System'"
20:32:13 <byteshack> from the article
20:32:15 <byteshack> delete :: -> StackSet a -> StackSet a
20:32:27 <byteshack> did you eat a: :: a ->   in there?
20:32:44 <dons> oh oops.
20:32:45 <dons> yes.
20:32:46 <lokadin> if I am to remove import System, then it states that getArgs not found
20:32:53 <dons> byteshack: it should not have the ->
20:33:00 <dons> byteshack: since it deletes the window currently in focus only.
20:33:03 <lokadin> so what do I import?
20:33:07 <byteshack> ah, ok
20:33:13 <dons> lokadin: System.Environment
20:33:16 <dons> ?index getArgs
20:33:16 <lambdabot> System.Environment
20:33:21 <lokadin> kk thanks :)
20:38:34 <jfredett> hmm, I need a good problem to solve. any suggestions?
20:39:02 <monochrom> Add arrows to HaXML
20:39:21 <jfredett> okay, something less substantial?
20:39:28 <bos> @seen cosmicray
20:39:28 <lambdabot> I saw cosmicray leaving #haskell 6h 37m 19s ago, and .
20:39:38 <monochrom> learn arrows
20:39:48 <ddarius_> monochrom: HXT...
20:39:56 <mdmkolbe|home> jfredett: what kind of problem do you want?  there a nice list of improvements for GHC
20:40:26 <jfredett> hmm, i guess thats the real problem that needs solving, what kind of problem do I want.
20:40:47 <jfredett> something along the lines of N-queens I guess, just something to hack on for a while
20:41:13 <jfredett> I just finished an N-queens and a sudoku solver, so I've had enough covering problems for one day.
20:41:24 <mdmkolbe|home> jfredett: solve substring in linear time
20:41:39 <mdmkolbe|home> (or maybe it's n log n)
20:41:41 <jfredett> been there, suffix trees for life.
20:41:48 <jfredett> i dont know if it was linear
20:41:53 <jfredett> but it was fun.
20:42:06 <jfredett> though, i did it in scheme, so maybe i could do it in haskell
20:42:07 <jfredett> hmm
20:42:23 <mdmkolbe|home> jfredett: write a unification algorithm or a type checker
20:42:35 <jfredett> holy crap, that sounds awesome,
20:42:41 <jfredett> whats a unification algorithm.
20:42:47 <jfredett> *stares blankly*
20:42:58 * jfredett is a mathematician...
20:43:04 <dibblego> something that makes General Relativity and Quantum Mechanics co-exist
20:43:07 <bos> @google unification algorithm
20:43:08 <monochrom> Many people like HaXML. Lazy parser. Bridge haskell data types to DTDs. It would be nice if arrows are brought to HaXML too. In fact even, exactly the same XML DOM combinators for both, i.e., HaXML implements HXT's ArrowXML type class too. I'm a big fan of HXT because of arrows.
20:43:08 <mdmkolbe|home> jfredett: do you know anything about type inference (not checking) or maybe about prolog or logic programming
20:43:10 <lambdabot> http://www.cs.rpi.edu/~freems/proj3/Unification_and_Variables.htm
20:43:10 <lambdabot> Title: Unification and Variables
20:43:13 <dibblego> just kidding
20:43:43 * mdmkolbe|home switches to scheme notation
20:44:08 <jfredett> I tried learning prolog once, and I've messed around with Coq, but I've only just started learning haskell, so I was aiming for something less awesome,
20:44:16 <jfredett> I guess I could just learn about type calculus
20:44:17 <Korollary> whats that website for math puzzles?
20:44:23 <jfredett> Mathschallenge.net
20:44:24 <TSC> projecteuler.net ?
20:44:29 <Korollary> yeah euler
20:44:35 <mdmkolbe|home> if I have literals `(a (,b)) and `(,c (d)) then the only substituion that makes them the same is b |-> d, c |-> b
20:44:58 <mdmkolbe|home> jfredett: have you written a lambda calculus interpreter?
20:45:05 <jfredett> no- that could be fun
20:45:06 <ddarius_> Unification = (categorical) limits
20:45:27 <ddarius> How involved a problem do you want?
20:45:32 <jfredett> I think i'll try that
20:45:54 <mdmkolbe|home> jfredett: writting a lambda calculus interpreter and a type checker (and if you're advanced a type inferencer with unification) is a right of passage for Haskell programers
20:46:11 <monochrom> rite
20:46:15 <ddarius> And takes about five minutes unless you write a parser as well.  Then it takes 15.
20:46:20 <mdmkolbe|home> jfredett: but it would help if you have a good prof. to help you
20:46:27 <jfredett> oh, rite of passage, *grabs his wizard hat and peace pipe* I'm ready
20:46:27 <monochrom> You will never think of mathematical notations the same way again.
20:46:48 <jfredett> sounds like fun to me
20:46:58 <Korollary> write a new DRM scheme. wait. scratch that.
20:47:12 <jfredett> Haskell has already blown my mind in terms of math + programming
20:47:16 <monochrom> write a new DRMacIver
20:47:17 <mdmkolbe|home> Benjerman Peirce (sp?) has a read book on it
20:47:23 <Korollary> Pierce
20:47:30 <ddarius> Benjamin
20:47:35 <Korollary> Benjermam needs a trademark
20:47:42 <monochrom> hehehehe
20:47:58 <jfredett> I was working in Scheme for quite some time, and someone said, "Joe! Learn Haskell" I said, "okay" and at that moment I was enlightened.
20:48:22 <Korollary> there are actually a few online books that cover pretty much the same basics as TaPL. Of course TaPL goes quite a bith further.
20:48:53 <ddarius> Depressingly there are almost no languages that combine Haskell practicality and closeness to mathematics.
20:49:23 <jfredett> ddarius, my ultimate goal in haskell is to do just that
20:49:31 <Korollary> Concoqtion sounds interesting
20:50:00 <jfredett> add all the brilliance of a CAS and Matlab-esque numerical system, with the power and syntax of haskell
20:50:34 <jfredett> basicly, Haskell + CAS + Matlab as one language, with a unified syntax, etc.
20:50:59 <monochrom> That's a hell of a type system.
20:51:04 <jfredett> yep,
20:51:06 <Korollary> I don't know if matlab is a good model.
20:51:13 <araujo> it isn't
20:51:27 <jfredett> well, I really just want to have the numerical capabilitys
20:51:39 <monochrom> Take it to mean "something that fills the same niche as matlab but sane like haskell"
20:51:44 <jfredett> yah
20:51:49 <jfredett> monochrom, exactly
20:52:09 <dainanaki> i hate not having precompiled ghc binaries
20:52:12 <ddarius> Matlab sounds more and more interesting every day.
20:52:20 <syntaxfree> the Mercury tutorial is amazing. A Haskell tutorial could be modelled against it, at least the type system chapter.
20:52:21 <Korollary> dainanaki: which platform?
20:52:25 <jfredett> the final goal would be something that does what Mathematica, Matlab, and Haskell all at once
20:52:27 <dainanaki> os x
20:52:36 <monochrom> When someone expresses a dream of unification of X+Y+Z, don't take him too literally about X,Y,Z!  The true dream is beyond speech.
20:52:40 <syntaxfree> for one, Haskell should have a matrix data type by now.
20:52:55 <dainanaki> well it's not that there aren't it's just that they don't seem to work for me
20:53:00 <ddarius> syntaxfree: Why?
20:53:05 <jfredett> syntaxfree, I totally agree, maybe I'll write that after I do the lambda calc interpreter
20:53:16 <Korollary> dainanaki: ah. Try the haskell-cafe mailing list.
20:53:29 <syntaxfree> ddarius: because from matrix algebra most other scientific stuff present in Matlab is trivial to construct.
20:53:54 <syntaxfree> I'd like to be able to do my econometric modelling in Haskell instead of R/Stata.
20:54:06 <ddarius> syntaxfree: Are you talking about a built-in or standard matrix type?  If not, I'm sure there are libraries.  If so, I mostly disagree.
20:54:06 <dainanaki> thanks Korollary, but i've already had the bootstrap and source code stuff going for like 2 hours, so might as well let it finish
20:54:15 <jfredett> from Matrix Algebra, just about all other algebras follow
20:54:24 <ddarius> Not in a very sane way.
20:54:35 <jfredett> ddarius, granted, but it does follow
20:54:36 <syntaxfree> ddarius: there are probably three or four half-baked matrix algebra libraries out there.
20:54:48 <syntaxfree> Having a proper Data.Matrix should be a priority GHC project.
20:54:56 <syntaxfree> optimized, etc. etc.
20:54:59 <Korollary> It wouldnt be my priority
20:55:12 * mdmkolbe|home is actually a specialist in that area
20:55:27 <jfredett> syntaxfree, I don't know about priority, It's still kind of a valence thing, but it should be on the list of things to do
20:55:28 <ddarius> syntaxfree: There may recently be the tools to make that a worthwhile endeavor...
20:55:31 <mdmkolbe|home> any particular requeists?
20:55:35 <syntaxfree> for what I know of scientific computing, it's pretty much what's holding the larger scientific community from adopting Haskell.
20:55:47 <jfredett> mdmkolbe|home, which area?
20:56:04 <syntaxfree> Even crazy stuff like numerically solving hyperbolic PDEs ends up boiling down to matrix algebra.
20:56:05 <mdmkolbe|home> jfredett: high performance matrix computation
20:56:12 <syntaxfree> with the appropriate sparse matrix optimizations.
20:56:21 <jfredett> syntaxfree, I think whats holding (at least the Mathematical) community back, is the lack of understanding of how to program period, much less in haskell
20:56:34 <ddarius> Haskell wasn't and may still not be particularly good for scientific computing.  At least the mass number crunching knid.
20:56:51 <mdmkolbe|home> jfredett: I've written kernels that are faster than any other vendor's libraries, but that was in C and I like haskell much better
20:56:55 <syntaxfree> there's a lot of mid-sized number-crunching where Haskell would be helpful.
20:57:00 <dainanaki> its kind of sobering to realize that any program may be basically converted into an equation
20:57:12 <jfredett> My advisor at school can hardly send emails, and she's got a pair of Phd's, its kinda sad.. :(
20:57:22 <Korollary> Ow
20:57:22 <ddarius> dainanaki: Why?
20:57:26 <syntaxfree> Maybe not inverting a 10^5x10^5 matrix, but hell, do I need more code reusability than R and Stata afford on my day-to-day work,.
20:57:39 <jfredett> dainanaki, I live to do that to CS students... :) I solved Nqueens like that w/ GAP
20:57:50 <jfredett> mdmkolbe|home, That sounds like fun,
20:57:53 <ddarius> dainanaki: We've known since the 30's that you can program with "arithmetic".
20:57:58 <dainanaki> i know
20:58:16 <dainanaki> but i'm talking like thinking what the "pdf format" algorithm would be for example
20:58:21 <monochrom> Kleene's recursion theorem
20:58:24 <jfredett> mdmkolbe|home, It would be neat to write a kernel in haskell... though it probably lacks the appropriate memory access abilities.
20:58:42 <syntaxfree> there is an entire bootable OS in Haskell.
20:58:45 <syntaxfree> @google house haskell
20:58:46 <mdmkolbe|home> jfredett: by kernel I ment matrix math kernel
20:58:47 <dainanaki> are there any plans for haskell' to have better memory access stuff?
20:58:48 <lambdabot> http://programatica.cs.pdx.edu/House/
20:58:48 <lambdabot> Title: House
20:58:50 <ddarius> jfredett: You'd be surprised what you can do with Haskell.
20:58:52 <syntaxfree> with a GUI and all.
20:59:19 <jfredett> mdmkolbe|home, ah, I see. mea culpa
20:59:24 <syntaxfree> and I mean, not a GUI based on X or anything. Everything built from the ground up.
21:00:15 <jfredett> ddarius, I'm surprised by haskell alot. I died of happiness when I saw some of the stuff I'd been missing out on when I started w/ it
21:00:33 <Korollary> jfredett: what kind of stuff?
21:01:18 <jfredett> The completely different take on Type Checking, for one. I'd always viewed types as a passive thing
21:01:37 <jfredett> but Haskell makes them active, and with great effect.
21:02:26 <Korollary> I don't quite follow. What's the difference?
21:03:11 <ddarius> Korollary: I can think of a difference that would not be completely ill-described by that terminology, but I don't think it is what jfredett had in mind.
21:03:35 <jfredett> Well, When I used Java, My view was that the type I assigned to data was relatively arbitrary, It only classified a small amount of information about the data type
21:03:44 <mdmkolbe|home> Korollary: I think what jfredett is saying is that in C, types are just a consession to the machine having to choose a representation, but in Haskell types are more than memory representation
21:03:58 <jfredett> mdmkolbe|home, exactly
21:04:16 <ddarius> Types are not a memory representation.
21:04:26 <dibblego> jfredett, would you argue the same way against a Lisp proponent who has never used Haskell?
21:04:28 <mdmkolbe|home> ddarius: in C they are
21:04:38 <jfredett> I saw the types in haskell and thought "Type Calculus" and not "32 bit int"
21:05:00 <jfredett> dibblego, Well, I am a lisp proponent, so I really cant be objective about that,
21:05:04 <ddarius> mdmkolbe|home: I worded what I said poorly, but nevertheless I was objecting to "in Haskell types are more than memory representation".
21:05:20 <dibblego> jfredett, at least, you see some value to type checking?
21:05:21 <dons> dainanaki: better memory access than the current FFI?
21:05:21 <Korollary> it is said that types correspond to algebras and what matters is their behavior. However, some other languages make it look like types are sets. That's as close as I can get.
21:05:29 <jfredett> dibblego, absolutely
21:05:32 <dainanaki> dons, yes
21:05:48 <dons> dainanaki: what's wrong with the current api? how could it be improved?
21:06:06 <dibblego> jfredett, my knowledge of Lisp is limited, so I was not able to argue very well in a particular debate I had with a Lisp proponent
21:06:29 <jfredett> There are benefits to both lisp and haskell
21:06:30 <ddarius> dibblego: You must learn all languages.
21:06:38 <dibblego> I've come to realise that
21:06:38 <ddarius> @where Liskell
21:06:38 <lambdabot> http://clemens.endorphin.org/liskell
21:06:41 <dainanaki> dons, idunno i just hear that it is the one thing haskell lacks in comparison to c is low level memory access as far as performance ability
21:06:41 <Korollary> dibblego: and quit arguing with lisp proponents ;)
21:06:43 <jfredett> I love lisp for its syntax, mostly.
21:07:02 <dibblego> Korollary, it was friendly banter more than anything
21:07:05 <jfredett> I often write lisp programs that construct lisp programs on the fly
21:07:08 <ddarius> @where Liskell jfredett
21:07:08 <lambdabot> http://clemens.endorphin.org/liskell
21:07:13 <jfredett> not like, function passing
21:07:40 <jfredett> I mean actually constructing a list w/ functions- its the best fun in the world. :)
21:07:46 <jfredett> ddarius, I read about that
21:07:59 <jfredett> ddarius, it looked interesting
21:08:07 * ddarius has no interest in it.
21:08:20 <Korollary> I feel for the author, though.
21:08:33 <jfredett> I think everything looks interesting, though--
21:08:50 <jfredett> "interesting till proven stupid", thats my motto
21:08:58 <monochrom> Yeah!
21:09:04 <ddarius> @where+ liskell http://liskell.org/
21:09:05 <lambdabot> Done.
21:09:10 <Korollary> Proving stupidity is hard.
21:09:19 <jfredett> Korollary, thats the point
21:09:26 <ddarius> Korollary: About ideas... ...
21:09:41 <dibblego> @where+ zippers http://en.wikibooks.org/wiki/Haskell/Zippers
21:09:41 <lambdabot> Done.
21:10:21 <jfredett> brb
21:11:35 <Korollary> I've been reading some database theory. It's interesting. I have a feeling that nulls correspond to _|_, but they don't use the same terminology. Although they do say things like 'type constructor'.
21:13:32 <allbery_b> nulls sometimes correspond to _|_
21:13:48 <allbery_b> they're kind of overloaded
21:14:19 <Korollary> When don't they?
21:14:34 <allbery_b> they can mean "no value", "any value", or "failure" depending on context
21:14:40 <MyCatVerbs> Korollary: nulls are a surprisingly controversial topic of discussion around databases.
21:14:53 <allbery_b> ("no value" meaning "uninitialized")
21:15:01 <MyCatVerbs> Korollary: you won't find a single (competent) Haskell programmer on Earth who thinks _|_ is silly or unneccessary =)
21:16:07 <MyCatVerbs> (Well, unless they believe that the features of Haskell which make _|_ a mathematically neccessary concept are silly. Which is fair game, whether one agrees with the proposition or not.)
21:17:01 <allbery_b> admittedly I'm not talking about database *theory*, I'm talking about what SQL oes in practice
21:17:11 * allbery_b is kinda short on theory
21:17:27 <Korollary> allbery_b: The theory is not that deep. It's about two midsized chapters.
21:17:51 <Korollary> minus the database-specific things like integrity, security, etc.
21:17:59 <allbery_b> much as I'm not much on the theory behind FP in genral or Haskell in particular, but I'm somewhat proficient at using it in practice
21:18:27 <Korollary> Does Xquery have bottom?
21:19:52 <allbery_b> and I've let the database bits rot a bit since I haven't used them in over 10 years, once upon a time I knew the difference between 3nf and bcnf...
21:24:25 <ddarius> Bah I forget that everytime I learn it.
21:24:37 <Korollary> Maybe it's not worth remembering.
21:24:47 <ddarius> It isn't really.
21:27:50 <allbery_b> yeh, I have the vague recollection that it wasn'tpractically useful
21:28:34 <ddarius> There is no difference except for some crazy off the wall cases.
21:30:25 <davidL> > read $ concatMap show [1,2,3] --is this the best way of going from [1,2,3] to 123::Int ?
21:30:27 <lambdabot>  123
21:30:51 <Korollary> that's one way
21:31:35 <Korollary> I'd normally go the 1*10^2 + ... route.
21:37:58 <sieni> > foldl (+) 0 $ zipWith (\x y -> 10^x * y) [0..] $ reverse [1,2,3]
21:38:00 <lambdabot>  123
21:38:42 <sieni> @pl \x y -> 10^x * y
21:38:42 <lambdabot> (*) . (10 ^)
21:39:26 <davidL> > (sum . zipWith ((*) . (10 ^)) . reverse) [1,2,3]
21:39:27 <lambdabot>  Couldn't match expected type `[a]'
21:39:42 <dons> some people might be interested in this,
21:39:43 <dons>   http://www.handbook.unsw.edu.au/undergraduate/courses/2007/COMP4181.html
21:39:45 <lambdabot> Title: UNSW Handbook Course - Language-based Software Safety - COMP4181, http://tinyurl.com/2ez5ba
21:39:52 <dons> "Language-based Software Safety" -- in Haskell
21:40:06 <sieni> @pl foldl (+) 0 $ zipWith (\x y -> 10^x * y) [0..] $ reverse
21:40:06 <lambdabot> foldl (+) 0 (zipWith ((*) . (10 ^)) [0..] reverse)
21:40:13 <davidL> > (sum . zipWith ((*) . (10 ^)) [0..] . reverse) [1,2,3]
21:40:14 <lambdabot>  123
21:40:24 <sieni> oh sum :-D
21:40:29 <davidL> thanks sieni
21:40:37 <chessguy> ...
21:47:14 <chessguy> > 135 / 3630
21:47:15 <lambdabot>  3.71900826446281e-2
21:47:39 <chessguy> hmm, i beat 96% of the field in that tourney
21:48:28 <Korollary> > 1 - 135/3630
21:48:30 <lambdabot>  0.9628099173553719
21:48:45 <Korollary> you are being humble
21:49:35 <chessguy> :)
22:08:02 <lispy> chessguy: sorry, 97% or better for an A
22:08:38 <chessguy> i'll have to try again tomorrow :)
22:08:59 <dibblego> what tourney?
22:16:50 <jmob> Is Data.Time.Clock part of the standard ghc 6.6 distribution?
22:17:32 <lispy> jmob: hmm...i think so
22:17:38 <dons> hmm? really?
22:17:41 <dons> isn't that in the 'time' package?
22:17:49 <dons> ?hackage time
22:17:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/time
22:18:02 * lispy stands corrected
22:18:09 <dons> yes, that's it.
22:18:11 <dons> http://hackage.haskell.org/packages/archive/time/1.0/doc/html/Data-Time-Clock.html
22:18:15 <lambdabot> http://tinyurl.com/28tdzs
22:18:44 <jmob> thanks, guess google can't find everything
22:18:58 <Korollary> hoogle it
22:19:24 <ddarius> Google can't find everything?!
22:19:55 <lispy> google can't find my keys :(
22:20:17 <jmob> lispy: my dog can find my keys
22:20:17 <dons> ?google where are my keys?
22:20:20 <lambdabot> http://them.ws/keys/index.php
22:20:20 <lambdabot> Title: Where Are My Keys?
22:20:35 <dons> ?google who ate the last donut?
22:20:38 <lambdabot> http://answers.yahoo.com/question/index?qid=20070328092503AA0zQe2&show=7
22:20:38 <lambdabot> Title: Yahoo! Answers - Whats the last donut u ate?
22:20:46 <dons> doesn't know very much at all
22:20:46 <Korollary> If you can't find your keys, then you're not worth targeting with ads anyway.
22:20:50 <dons> heh
22:21:38 <lispy> does google still use ads? i guess ad-block plus beats them
22:21:49 <kaol> has anyone planned on adding ByteString support for hdbc?
22:22:09 <ddarius> kaol: You?
22:22:12 <Korollary> This is why there ought to be project wikis
22:22:13 <lispy> kaol: i'd venture a guess that it's not that hard if you're interested
22:22:34 <Korollary> There are eight billion things that could use bytestring support.
22:22:56 <lispy> heh, yeah when well bytestring be the default string for ghc?
22:23:03 <jfredett> gnite folks
22:23:06 <kaol> would it be possible to change Strings to be ByteStrings everywhere?
22:23:22 <Korollary> you mean automatically
22:23:33 <lispy> kaol: if you're going to do something that sweeping you can use the lazy version and sometimes get good results
22:23:42 * kaol wants his cake and eat it too
22:24:23 <lispy> kaol: to do it *right* you need to also look at the way the strings are created/consumed...but, just converting everything to lazy bytestrings isn't always a bad way to go
22:24:59 <dons> yeah, that often makes sense, since the complexity of operations are the same (always?)
22:25:13 <lispy> kaol: i added bytestring support to HaXml by doing this naive approach and receive significant improvements...10x memory reduction for example
22:25:22 <dons> whereas changing naively to strict bytestrings can change complexity (in particular, concat!) confusing some people
22:25:42 <Korollary> and there's the unicode thing
22:25:50 <kaol> if I ever get rid of the feeling that I can't yet code anything in Haskell...
22:26:06 <dons> maybe you should code something in haskell :)
22:26:07 <Korollary> even hello world?
22:26:11 <lispy> yes and the unicode thing could be quite important...so it's best if people still have the traditional interface when they need it
22:26:26 <dons> don't worry, i think it takes hmm, 3 years full time to get competent in the full range of haskell idioms.
22:26:38 <Korollary> the idioms also change as you go
22:26:43 <dons> yeah.
22:27:06 <lispy> kaol: how do you feel about the m word?
22:27:28 * lispy goes to bed
22:27:32 * lispy &
22:28:43 <dons> here's my conjecture: after 3 years you should be able to write (mostly) bug free code, using the right libraries, using QuickCheck, with static separation enforced with monad transformers, and some data type checking with GADTs. it should be efficient, solve real problems, and be shorter than competiting products. it should also be easier to maintain. I think getting to that point takes at least 3 years with the language.
22:29:42 <bos> not all that different from any other language, really.
22:29:58 <dons> of course, if we had a book that taught these techniques, you could get there faster.
22:30:03 <dibblego> how is "(mostly) bug free" not different from any other language?
22:30:15 <dons> dibblego: mostly bug free in the strong sense
22:30:19 <kaol> well... so-so. I think I understand some aspects about them, but I still couldn't use something like State, Reader or Writer on my own. And I'm still too scared to even look at monad transformers.
22:30:27 <dons> only spec errors.
22:30:28 <bos> "optimal bug-free haskell in 21 days! for dummies!"
22:30:43 <dibblego> in other languages, I see mostly bug-ridden code
22:30:54 <dons> well, ok. that's true. :-)
22:31:00 <Korollary> It depends on where you look.
22:31:13 <dons> considering it took the first generation of haskellers 10 years to get to this position,
22:31:19 <dibblego> I look in the pits of software hell
22:31:20 <Korollary> You can write high quality C. It just needs more foreplay.
22:31:29 <dons> and i'm saying for those starting at h98, it takes 3 years. with a good book, we could bring that down to 12 months perhaps ? :-)
22:31:53 <bos> someone ought to write one.
22:31:58 <dons> yeah.
22:32:12 <Korollary> I don't think books are the future anyway.
22:32:26 <thoughtpolice> pragmatic programmers apparently signed on for a 'pragmatic haskell' book
22:32:30 <dibblego> yes, there needs to be a book that doesn't necessarily appeal to the beginner
22:32:34 <Korollary> I kinda wish for a more interactive method for learning.
22:32:34 <bos> the neural shunts aren't working yet.
22:33:05 <ddarius> Korollary: You mean like the various classes that use Haskell?
22:33:29 <Korollary> ddarius: Oh no, I mean for self study. Classes are better of course.
22:33:39 <bos> it'll be interesting to see how that prag book turns out.
22:33:52 <ddarius> Probably depressing.
22:34:13 <bos> why do you think?
22:34:20 <dons> its better than it used to be. in the 90s you had to go to Oxford or Glasgow or Chalmers, and have Richard Bird teach you programming pearls to get the "haskell way" . now you can hang out here, and get it on the cheap.
22:34:31 <Korollary> For instance, every learner runs into what's foldr and foldl, why do I have a space leak, why doesn't this typecheck etc. Those could all be guided in a IDE/teaching env. Something like DrScheme, but better.
22:34:39 <cdsmith> dons: and thank goodness for that.
22:34:51 <dons> yeah
22:34:56 <cdsmith> (Though I wouldn't mind taking classes at oxford. ;)
22:35:02 <dons> and just in the last 6 months we've suddenly started you know, writing on the web.
22:35:06 <dons> that helps.
22:35:21 <dons> these intertubes are good for documenting how to do things.
22:35:22 <thoughtpolice> the internet is a wonderul thing.
22:35:24 * bos remembers being plunged into the icy waters of ghc internals in 1993. there was a way to learn!
22:35:34 <dons> yeah, bos was lucky. :-)
22:36:06 <dons> I think Chalmers is just about haskell central now, though. the number of undergrads who can use ContT they turn out is amazing.
22:36:19 <Korollary> What? You know haskell since 1993 and don't have your own compiler?
22:36:35 <cdsmith> dons: Chalmers, you say?  I need to figure out which grad schools to apply to.
22:36:43 <dons> actually, the SoC has been useful.
22:36:57 <dons> that's brought in a number of longer term contributors, outside the grad school crowd
22:37:02 <dons> thanks google!
22:37:21 <dons> cdsmith: chalmers wouldn't be bad, at all.
22:38:04 * cdsmith also needs to do something work being accepted to a grad school for; but that's a minor detail.
22:38:23 <Speck> I'm looking to collect code examples of Parsec's token lexer on complex languages (as in not simple expressions). Does anyone know of any tutorial/paper/repository with this kind of Haskell code?
22:38:45 <dons> Speck: hmm, there's a number of parsec examples on the blog articles page on haksell.org
22:39:00 <dons> and on hackage, look for libs that use 'parsec' dependencies
22:39:07 <dons> there's a java script parser there, iirc (?)
22:39:23 <dons> c2hs's huge C parser isn't in parsec, though, notably.
22:39:32 <Speck> dons: I'll check that out. Most uses of Parsec don't use the tokenizer.
22:40:35 <dons> btw, guys, xmonad now supports the xrandr extension.
22:40:37 <Korollary> Maybe someone who uses bytestrings
22:40:40 <dons> so you can rotate screens on the fly
22:40:42 <Speck> how do I search hackage?
22:41:06 <dons> might be nice for the quants here, with their 8 screen tiling setups, using haskell ;-)
22:41:19 <dons> or anyone who happens to be at fermilab
22:41:39 <Korollary> What kinda monitor do you need for that?
22:41:54 <dons> or if you're involved in putting up info screens in public places like airports, and wondering how best to tile data displays on a single rotated monitor
22:41:54 <kaol> @google haskell programming pearls
22:41:54 <Korollary> They should just get 2 or more LCDs
22:41:57 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
22:41:58 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
22:42:44 <dons> Korollary: sure, but then you want to display the lcd rotated 90 degrees, you use randr for that.
22:43:03 <Korollary> Yay
22:43:06 <dons> so i think it should even be possible to bind xmonad to screen rotation functoins. hmm.
22:43:17 <Korollary> it is a good thing for reading pdfs
22:43:41 <dons> yeah, you could have a dedicated rotated lcd for pdfs
22:43:50 <dons> mmm. tasty
22:44:10 <Korollary> But it's solving the wrong problem.
22:44:37 <Korollary> Why don't the current pdf readers show the pdf sans margins?
22:45:00 <bos> rotated lcds are great for xterms, too.
22:45:08 <dons> ah yes. nice idea bos.
22:45:20 <dons> yeah, i'd love a couple of rotated lcds side by side. that'd be perfect
22:45:28 <bos> i can fit 8 big xterms on mine, and my twin emacs windows are 80 cols x 160 rows.
22:45:54 <Korollary> Why do you have two emacs windows?
22:46:18 <sebell> Korollary: Editor and REPL!
22:46:42 <Korollary> Not two buffers. Two windows. You can split the single window if you want.
22:47:23 <bos> i like having a permanent split. it's too easy to C-x 0 away a buffer.
22:47:24 <sebell> Actually, you would have two windows. You'd be splitting the frame
22:47:29 <quicksilver> two 'frames' (which is the emacs word for window) is useful
22:47:48 <quicksilver> manual page in one, code in other; repl in one, code in other, etc
22:48:01 <sebell> I'm chatting in one frame, for example.
22:48:08 <quicksilver> as box says, you don't want the C-x {0,1} stuff to kill them
22:48:20 <quicksilver> you still want to be able to split them individually
22:48:26 <quicksilver> s/box/bos/ (sorry!0
22:48:37 <Eelis> dons: i see the current TODO has no mention of tabs. has that idea been dropped?
22:48:39 <Korollary> Is C-x 0 the only way to get rid of a buffer?
22:48:44 <dons> morning quicksilver, btw.
22:48:55 <dons> Eelis: its likely that will be done by contrib modules, not in the core.
22:48:57 <quicksilver> morning dons
22:49:04 <Eelis> dons: i see. interesting
22:49:22 <dons> all the experimental layout strategies, bindings, tiling systems, are done via contrib extensions
22:49:36 <sebell> Korollary: Well, C-x 0 doesn't kill a buffer, it kills a window. And no, there are other ways. C-x 1 for example, kills all other windows in the frame and keeps the current one only
22:49:36 <Eelis> sounds good
22:51:42 * cdsmith keeps misreading "command" as "comonad" in the book I'm reading.
22:52:15 <Korollary> I know what they do. I'm just trying to point out to the braindead practice of, say, M-x man's splitting the current window. If it didn't do that, I'd have very little need to C-x 0 stuff. I switch between buffers easily otherwise.
22:53:35 <sebell> Korollary: Ah. Yes, I agree -- Emacs still behaves as though a user had a single frame on an 80x24 terminal
22:54:15 * bos digs the xmonad screenshot with hmp3 playing sonic youth. it all fits nicely :-)
22:55:55 <dons> hah
23:06:08 <arcatan> xmonad isn't easy to recognize in screenshots
23:06:42 <kfish> perhaps it needs an anime mascot?
23:06:56 <ddarius> Sure it is.  It's a computer screen without any non-essential clutter.  Just content.
23:07:40 <Korollary> It's like a good referee.
23:07:48 <bos> this is a great essay: http://www.lambdassociates.org/Blog/bipolar.htm
23:07:49 <lambdabot> Title: The BiPolar Lisp Programmer
23:08:51 <edwardk> bos was good, though i'd s/Lisp/Haskell/ig
23:09:52 <Korollary> I don't necessarily agree with a lot of that essay
23:10:38 <Korollary> There are a lot of lazy bums who'd like to think that they're actually brilliant and it's the 'system', etc.
23:10:47 <edwardk> hahhahaha
23:10:50 <edwardk> there is that factor too
23:11:13 <JohnMeacham> @seen dons
23:11:13 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 45s ago.
23:11:22 * edwardk is a lazy bum. I only work when forced by a suitable demand signature.
23:11:43 <dons> JohnMeacham: ?
23:12:19 <JohnMeacham> Ah, I made a bunch of changes to jhc recently, I was wondering if you could update the nobench page with the latest tag.
23:12:29 <dons> ah yes, i plan to this week sometime.
23:12:38 <JohnMeacham> cool.
23:14:21 <JohnMeacham> it will probably be slower, but should actually compile more of them.
23:15:39 <ddarius> Valuing correctness over speed?  What kind of programmer are you?
23:18:44 <monochrom> That is a type, not a kind.   (duck!)
23:22:02 <JohnMeacham> don't worry, I'll get back to breaking things soon enough.
23:24:32 <dons> ddarius: hah
23:51:21 <dblhelix> dons: do you know anything about phrac?
23:52:38 <dons> yeah, a little
23:53:39 <dblhelix> dons: all my attempts to use it seem to result in "phrac: <stdin>: hGetLine: end of file" :-(
23:53:42 <stmartin> I should be able to use fromIntegral to convert from Word8 to Char, right?
23:54:25 <dons> stmartin: no :-)
23:54:35 <dblhelix> dons: that is, if I try input from stdin... passing it a file works fine
23:54:39 <stmartin> awww, why not?
23:54:51 <dons> stmartin: well, sort of, w2c = chr . fromIntegral
23:55:21 <dons> dblhelix: ok. no idea. i'd suggest looking at the src
23:55:31 <dblhelix> stmartin: because Char is not an instance of Num
23:55:47 <dblhelix> dons: yeah, I'll have a look---thanks
23:56:01 <dblhelix> dons: btw, how's xmonad going?
23:56:03 <stmartin> But it is an Enum right?
23:56:12 <dblhelix> stmartin: it is
23:56:27 <dons> dblhelix: flying along. lots of stuff happening.
23:57:01 <dons> xrandr support (rotate monitors), 3rd party contribs keep landing, entire core rewritten to be a Zipper. the code makes me happy. all good
23:57:20 <dons> > fromEnum 'a'
23:57:28 <dons> > toEnum 'a'
23:57:28 <lambdabot>  97
23:57:29 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
23:59:50 <kosmikus> dons: do you still try to impose a line limit?
