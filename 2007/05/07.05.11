00:00:46 <ClaudiusMaximus> sjanssen: /window 11
00:00:50 <ClaudiusMaximus> oops
00:03:34 <joelr1> what is the current consensus on xslt? is anyone actively using it?
00:05:56 <Korollary> I think so.
00:05:59 <ClaudiusMaximus> joelr1: i dislike it, but i use it for a human-readable version of an rss feed
00:06:17 <lispy> joelr1: it's terrible, messy, and a headache to get it right...and yet it is flexible and sometimes easier than hand writing the code to do the transformation
00:06:39 <ChilliX> joelr1: Well, I know at least one person who thinks its crap and got paid pretty well to rewrite a big xslt app in Haskell
00:07:55 <joelr1> hmm
00:08:17 <joelr1> my dilemma is with regards to templating
00:08:22 <joelr1> and web apps
00:08:37 <joelr1> there's no template system that i can use with happs/hope, for example
00:08:50 <joelr1> so i can either generate xhtml with either or use xslt with happs
00:09:35 <joelr1> plus, i probably want to generate chunks of pages and combine them into a page whole
00:09:54 <joelr1> i.e. combine a navbar with a top "banner", with header and footer, etc.
00:10:26 <joelr1> i'm not sure how this can be done with xslt but it can clearly be done by programmatically generating html
00:10:29 <ChilliX> joelr1: the system I was talking about didn't have anything to do with web apps, so maybe it is useful there
00:10:37 <joelr1> ChilliX: ok
00:11:23 <joelr1> the drawback to programmatically generating html from haskell is that things need to be recompiled everytime which, I assume, slows down development of html generators
00:11:36 <joelr1> tweak html, recompile, tweak html, etc.
00:11:54 <joelr1> xslt would avoid that, i would think
00:11:56 <bd_> What about runhaskell/ghci? :)
00:12:19 <joelr1> bd_: that would work i guess
00:14:14 <ChilliX> joelr1: And also plugins that transparently compile if the source changes
00:14:22 <ChilliX> The Yi paper talks about that
00:15:00 <joelr1> ChilliX: right
00:15:17 <bd_> @where gentoo-haskell
00:15:18 <lambdabot> I know nothing about gentoo-haskell.
00:15:49 <ClaudiusMaximus> > let cuu o f g = curry (uncurry f `o` uncurry g); (&&&&) = cuu (&&&); (>>>>) = cuu (>>>) in ((max &&&& min) >>>> ((-) &&&& (/))) 6 66  -- any merit in this approach?
00:15:51 <lambdabot>  (60.0,11.0)
00:19:24 <DRMacIver> Hm. Perhaps "Maybe Bool" was a bad choice of representation for trivalued logic.
00:20:05 <DRMacIver> It would be nice if Bool followed the same route as num and had overloaded literals and a type class for its core functions.
00:20:35 <joelr1> bringert: bjorn!
00:20:51 <bringert> joelr1: did you get the URLs working?
00:21:24 <bringert> I should have remembered to tell you before that the URLs might be a bit of working with non-apache servers
00:21:34 <bringert> a bit of work
00:21:51 * bringert makes 100th note to self to read what he types
00:22:31 <joelr1> bringert: i have it working but it doesn't find the style sheets and complains about permission all the time
00:23:03 <joelr1> bringert: i have everything running as /hope.fcgi/{entry, about, static}, etc
00:23:45 <joelr1> bringert: the problem is that when hope tells the browser to look for stylesheets it says /hope.fcgi/style/...
00:23:51 <joelr1> and there's no such thing
00:23:53 <bringert> the base URI comes from Hope.Module.baseURI
00:24:07 <joelr1> bringert: i looked at it but it's calculated
00:24:11 <bringert> yeah
00:24:24 <joelr1> bringert: whereas in your htaccess* you are saying that some variable needs to be set in Config.hs
00:24:36 <bringert> ah, yes, that was before
00:24:41 <joelr1> bringert: so what's the proper workaround then?
00:25:08 <bd_> @paste
00:25:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:25:27 <bringert> hmm, you could hack baseURI for now, just make it return http://localhost/hope.fcgi/ or whatever
00:26:38 <bringert> maybe there should be a setting for it, and it could default to the calculated value
00:26:42 <joelr1> bringert: you probably mean the above _without_ hope.fcgi, do you?
00:26:50 <bringert> ah
00:26:51 <bringert> hmm
00:28:22 <bringert> tricky
00:28:35 * ChilliX is off...
00:30:16 <bringert> joelr1: maybe you could use this: http://trac.lighttpd.net/trac/wiki/Docs:ModRewrite
00:30:18 <lambdabot> Title: Docs:ModRewrite - lighttpd - Trac
00:30:28 * bringert takes a shower
00:31:42 <joelr1> bringert: what do i rewrite, though?! i mean from what to what?
00:32:10 <joelr1> bringert: strip hope.fcgi from urls generated by hope? but then how do i know to direct stuff to hope.fcgi?
00:32:51 <joelr1> bringert: i have a rewrite rule now. it says everything should go under /hope.fcgi/
00:32:54 <dobblego> it seems I am being targetted by a reddit bot that automatically votes down everything I do; anyone else seen this?
00:33:11 <DRMacIver> Hm. Censorship. Hoogle doesn't show unsafeCast. :)
00:33:15 <DRMacIver> :type unsafeCast
00:33:20 <DRMacIver> Oops. Wrong syntax.
00:33:33 <dmwit> ?hoogle unsafe
00:33:34 <lambdabot> Language.Haskell.TH.unsafe :: Safety
00:33:34 <lambdabot> System.IO.Unsafe :: module
00:33:34 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
00:33:44 <dmwit> Oh, so it does have some unsafe things
00:33:45 <dmwit> .
00:34:29 <DRMacIver> Not that I actually intend to use it, I just wanted to check if something would work.
00:35:11 <joelr1> bringert: i think i just figured it out. with apache you apply the rewrite to _non existent_ urls whereas with lighty i'm applying it to everything
00:35:34 <Cheery> @hoogle home
00:35:35 <lambdabot> Distribution.InstalledPackageInfo.homepage :: InstalledPackageInfo -> String
00:35:35 <lambdabot> Distribution.PackageDescription.homepage :: PackageDescription -> String
00:35:35 <lambdabot> System.Directory.getHomeDirectory :: IO FilePath
00:37:21 <DRMacIver> Is there any standard module to look in for tuple manipulations?
00:40:43 <bringert> joelr1: yes, that's it
00:41:03 <joelr1> right
00:41:13 <joelr1> bringert: any clue as to why i always get no permissions?
00:42:22 <skew> DRMacIver: just Prelude, I think
00:43:06 <skew> there are not too many easy ways to manipulate tuples
00:43:24 <DRMacIver> ok
00:43:35 <DRMacIver> Or at least not too many well typed easy ways to manipulate tuples. :)
00:43:36 <skew> oh, some of the arrow stuff might apply to pairs
00:44:35 <DRMacIver> (I was looking for functions which take (a1,...,an) -> (a1, (a2, ..., an)) for a reasonable range of values of n. They're trivial to write, I just didn't want to do it if it was already there)
00:44:55 <bringert> joelr1: /user/role/edit ?
00:45:11 <kilimanjaro> DRMacIver, why not use lists?
00:45:17 <skew> that seems like the sort of thing that ought to go with HList, but I don't think they're around anywhere
00:45:33 <DRMacIver> kilimanjaro: Because that wouldn't do what I want in any way, shape or form. :-p
00:46:02 <DRMacIver> kilimanjaro: I needed these as a utility step in extending a type class to cover tuples of elements of that type class.
00:46:32 <kilimanjaro> ahh
00:47:27 <skew> that's what I wanted them for
00:48:59 <DRMacIver> In the end I only bothered for tuples of 2 and 3 elements. I don't have an obvious use case for anything larger than that, so I'm going to be lazy about it until I do. :)
00:53:13 <joelr1> bringert: let me try
00:54:53 <joelr1> bringert: no permission to edit user roles :D
00:57:00 <joelr1> bringert: is there some sort of a default admin user?
01:03:44 <joelr1> .
01:03:47 <joelr1> hmm
01:03:48 <TSC> What does the second element of the tuple returned by Data.ByteString.Base.toForeignPtr mean?
01:04:01 <joelr1> ah, i thought i was deaf
01:10:37 <dmead> TSC whats it look like?
01:10:44 <joelr1> @seen alexj
01:10:45 <lambdabot> I saw alexj leaving #haskell 13d 16h 37m 44s ago, and .
01:14:07 <Svrog> could anyone clue me in on how to correctly use finalizers with ForeignPtr-s?
01:14:27 <Svrog> it appears the finalizers never get called, even when i use System.Mem.performGC
01:14:56 <hpaste>  Svrog pasted "Problem with finalizers" at http://hpaste.org/1792
01:16:59 <sm> hmm, what could ~[fname] mean ?
01:17:11 <Svrog> the finalizer only gets called if i call it explicitly with finalizeForeignPtr fptr
01:17:36 <hpaste>  sm pasted "in this" at http://hpaste.org/1793
01:19:02 <dmead> ~ is a lazy evaluation thing
01:19:21 <dmead> maybe, lazily constructing a list?
01:20:02 <DRMacIver> Isn't that an irrefutable pattern?
01:20:26 <ski> yes it is
01:21:26 <Svrog> sm: try this: let f ~(l:ls) = putStrLn "test" in f []
01:21:33 <Svrog> then try the same thing without ~
01:21:35 <ski> (but i don't see why to use it there, since presumably 'parseFromFile' is 'IO'-strict in second argument)
01:23:36 <sm> right, it complains about irrefutable pattern
01:23:40 <sm> (and ks)
01:23:42 <sm> thanks
01:24:36 <ski> TSC : possibly offset and length
01:30:10 <sm> I wonder if there's as more complete CSV lib than http://www.xoltar.org/old_site/2002//oct/17/haskellCSV.html
01:30:12 <lambdabot> Title: A Haskell CSV parser
01:30:57 <DRMacIver> It's surprisingly difficult to find CSV libraries for anything. :) I had trouble even when I was looking for some for Java. (Although I've since found a few)
01:32:23 <sm> no problem with python :)
01:32:26 <sm> hmm, missingh looks as if it might have one
01:32:38 <Jaak> correct CSV parser is not trivial thing to write...
01:33:05 <sm> so, I have ghc 6.6 built from source; what's the best way to get missingh installed  ? do I need to download and built it from source also ?
01:33:13 <sm> there are debian packages..
01:34:10 <sm> in fact.. how do I check if my other self already did this
01:35:32 <sm> ghc-pkg list doesn't show it, so I guess I did not
01:38:46 <sm> hmm. ./setup build of missingh complains: Could not find module `Text.Regex': it is a member of package regex-compat-0.71, which is hidden
01:39:20 <sm> yet it's using /usr/local/bin/ghc, and I can see very well that package is not hidden, and can import Text.Regex in test script
01:40:48 <baboa> hi, does anybody here know something about Graphics.UI.GLUT?
01:41:38 <baboa> where do I find relevant package?
01:42:32 <Korollary> baboa: It's in the standard libraries
01:42:44 <baboa> are you sure?
01:42:49 <Svrog> baboa: are you asking where to find glut itself? or the haskell interfaces?
01:43:10 <baboa> just installed ghc 6.6.1 under Windows and it seems to be missing :(
01:43:20 <Svrog> http://www.xmission.com/~nate/glut.html
01:43:21 <lambdabot> Title: Nate Robins - OpenGL - GLUT for Win32
01:44:18 <baboa> hmm, so this is glut.dll, and the relevant Haskell/GHC parts?
01:44:42 <Svrog> the relevant ghc parts come with ghc
01:44:52 <Svrog> this should be all you need
01:46:06 <baboa> hmmm, how do I *install* glut.dll?
01:46:44 <baboa> ghc says currently Could not find module 'Graphics.UI.GLUT': Use -v to see a lis of the files searched for.
01:47:45 <Svrog> hmm.. that warning is related to the haskell wrappers for glut, not the dll
01:48:00 <baboa> yes, I know
01:48:18 <baboa> it seems I don't not have either of them currently
01:48:20 <ClaudiusMaximus> baboa: are you using ghc --make   or  ghc -package opengl  or something similar?
01:48:31 <baboa> ghc --make
01:48:54 <baboa> actually I'm trying to compile frag :)
01:49:00 <Svrog> oh
01:50:10 <baboa> IIRC ghc 6.6 worked without any tweaking
01:50:18 <Svrog> hmm.. ive compiled it not long ago - didnt seem to have any problems finding the glut wrappers - i might still have the sources unzipped somewhere, ill check
01:50:30 <baboa> might be it was only dropped by installer
01:50:36 <Svrog> yeah - i havent tried compiling it with 6.6.1
01:52:56 <Svrog> baboa: do a search for *glut* in your ghc directory
01:53:25 <baboa> the documentation which comes installed doesn't say anything about GLUT
01:53:44 <baboa> the one available on haskell.org has it listed
01:54:03 <Svrog> then it probably wasnt built as part of the distribution
01:54:15 <baboa> no *glut* in ghc-6.6.1 :(
01:54:52 <Svrog> no its still in 6.6.1 - but it's part of the optional packages
01:55:03 <baboa> ok, shame, but I can live with that
01:55:10 <baboa> what do you mean optional?
01:55:57 <Svrog> http://haskell.org/ghc/download_ghc_661.html <-- if you're building from sources you only need ghc-6.6.1-src.tar.bz2 - glut is part of ghc-6.6.1-src-extralibs.tar.bz2 i think
01:55:58 <lambdabot> Title: GHC: Download version 6.6.1
01:56:07 <baboa> how do I install it myself on top of current installion?
01:56:20 <baboa> I'd rather not recompile everything.... ;)
01:57:08 <liber> I am actually starting to like haskell alot...
01:58:48 <bringert> joelr1: did you figure out the permissions?
01:59:06 <bringert> joelr1: the first user you add is the super user, which has all permissions automagically
02:00:52 <Svrog> baboa: try darcs get --partial http://darcs.haskell.org/packages/GLUT
02:00:54 <lambdabot> Title: Index of /packages/GLUT
02:01:20 <baboa> I just downloadded the extralibs.tar.bz2 from page above
02:01:29 <baboa> extracted, and now:
02:01:33 <Svrog> then check the readme or install files for instructions on how to build it
02:01:40 <baboa> runhaskell Setup.hs configure:
02:02:06 <Svrog> or you can use the one in extralibs
02:02:07 <baboa> Couldn't match expected type 'UserHooks' against 'Maybe UserHooks'
02:02:11 <ulfdoz_> Why must the type variables in an instance-declaration be distinct, i.e. why fails "instace Foo (a, a) where ..."?
02:02:45 <baboa> I have the standard Cabal-1.1.6.2 that comes preinstalled
02:03:28 <joelr1> bringert: didn't figure it out yet. maybe i need to recreate my db
02:04:41 <bringert> joelr1: did you log in after creating the user account?
02:05:41 <joelr1> bringert: yes, i did/have
02:05:51 <quicksilver> http://www.timestretch.com/FractalBenchmark.html
02:05:53 <lambdabot> Title: Ruby, Io, PHP, Python, Lua, Java, Perl, Applescript, TCL, ELisp, and C Fractal B ...
02:06:03 <quicksilver> someone should help this guy get a haskell version that works
02:08:36 <Svrog> baboa: probably the easiest thing to do is just to download ghc6.6 and compile frag with that
02:09:02 <baboa> Svrog: I'l not give up so easily :)
02:09:28 <baboa> I just added a 'Maybe' in one place, and Setup.hs worked
02:09:46 <baboa> now looking for some C header I don't have, but will find soon :)
02:10:08 <Svrog> i wouldnt if it was some important lib - but glut is pretty horrible really
02:10:48 <Svrog> i think its a good thing its part of optional packages
02:11:16 <baboa> I'm doing this for fun, so no problem
02:11:22 <Svrog> fair enough
02:11:41 <baboa> but GLUT is ok for showing off some OpenGL in Haskell for friends
02:11:51 <joelr1> bringert: why did you decide not to use xslt?
02:12:21 <baboa> just open a window, get some clicks to it and that is all
02:12:40 <baboa> what do I use instead of GLUT to show OGL window?
02:14:48 <Svrog> well.. for quick and easy (but ugly) solutions you pretty much only have glut - there may be an sdl interface for haskell as well but id imagine it would be just as bad
02:15:21 <baboa> whare do I put glut.h so that Setup.hs can find it?
02:15:31 <Svrog> for my own projects i write my own wrappers around opengl in c and haskell and then use that rather than the interfaces that come with ghc
02:15:35 <baboa> or how do I tell Setup.hs where to find headers?
02:16:14 <baboa> there is include/mingw/GL directory, but it doesn't seem to be the right one... (?)
02:18:16 <joelr1> alexj: long time
02:18:43 <alexj> joelr1: indeed.
02:19:20 <alexj> Is the point of s3 for you that you will have durability, but that you don't care about uptime?
02:19:35 <alexj> I mean if your server goes down, then you are willing to wait to restart a new instance?
02:20:02 <joelr1> alexj: yes, at least for now
02:20:11 <alexj> ah ok.  different target need.
02:20:22 <joelr1> alexj: it's more important for me to store blog entries, md5 hashes of translated source code, etc.
02:21:13 <alexj> you know that ec2 instances are relatively stable.  you can reboot them and keep the disk.
02:21:43 <alexj> you don't want that to be your only copy but it is nice.
02:22:18 <joelr1> alexj: keep the disk? the disk goes away i always thought
02:22:31 <joelr1> alexj: otherwise everybody would be running regular databases on ec2
02:22:33 <alexj> How about this interim deal.  I'll look at the s3 code tomorrow (I really need to sleep soon it is 5:20AM here and I have yet to sleep)
02:23:12 <alexj> the ec2 story is ambiguos here -- you don't want to rely on the reboot.  in any case, you don't reboot very often.
02:23:44 <joelr1> alexj: the interim deal...
02:24:30 <alexj> how about this: i'll look at the s3 code tomorrow.  you take a look at remote recovery.  if you get remote recovery working, I'll maintain a backup store on one of my servers.
02:24:45 <moonlite> I need to write the EOF ascii-code. Is it defined in soem datastructure somewhere or is there some backslash-thing (like for example '\eof'?) i could use?
02:24:57 <alexj> when your instance restarts, it can pull state from my server.
02:25:12 <joelr1> alexj: i don't even need to go that far. i just need s3.
02:25:23 <joelr1> alexj: i do not need remote recovery
02:25:32 <joelr1> alexj: or want remote recovery at this point
02:25:33 <alexj> you are doing remote recoery if you are using s3.
02:25:47 <joelr1> alexj: nope. i'm storing data in a database/hash table
02:25:58 <alexj> in memory or on disk?
02:26:05 <joelr1> alexj: s3 :D
02:26:24 <alexj> you are already saving stuff on s3?
02:26:35 <dmead> what about frag hacking?
02:26:39 <joelr1> alexj: no, but tht is what i want!
02:26:58 <joelr1> alexj: otherwise i would not be talking to you
02:27:02 <joelr1> shapr: ping
02:27:28 <alexj> I really doubt shapr is awake he is 1 timezone west of me and I really shouldn't be up either.
02:27:39 <dmead> @seen shapr
02:27:40 <lambdabot> shapr is in #haskell. I last heard shapr speak 3h 39m 47s ago.
02:27:48 <alexj> ok.
02:28:06 <alexj> anyway, s3 means two very different things depending on how you want to use it.
02:28:34 <alexj> if you are accessing s3 from within side-effects I believe that code is actually reasonably usable.
02:28:53 <alexj> if you want transaction logging to s3 (and maintainance of your HAppS state in S3) then that is not ready yet.
02:29:06 <alexj> does that make any sense?
02:29:12 <joelr1> alexj: i'll do transactions with STM
02:29:17 <joelr1> alexj: i just need the basic code
02:29:29 <alexj> happs already does all the transactions with STM.
02:29:39 <alexj> but if you want your transactions to be durable STM doesn't help yuo.
02:29:51 <alexj> ACID requires durabilty.
02:30:07 <joelr1> alexj: i'll take a look, thanks. i may just roll my own transactions. what i don't want to roll is the s3 interface
02:30:48 <alexj> the main value of using HAppS is the MACID monad which encapsulates transactions in a nice monadic framework.
02:31:31 <joelr1> alexj: ok
02:31:39 <alexj> if you just want GET/PUT to s3 code that is probably usable.
02:31:50 <joelr1> alexj: yes, please
02:32:01 <joelr1> alexj: i'll fix errors if i find them and send patches
02:32:04 <alexj> the code to do write ahead transaction logging to s3 is what is not ready yet.
02:32:21 <alexj> are you using HAppS for in memory state?
02:32:40 <joelr1> alexj: and i assume you won't be working on that since it no longer fits your bisiness model,r ight? the S3 charges don't fit that is
02:32:40 <alexj> from this conversation I am not sure I understand what yuo are doing with HAppS.
02:32:51 <joelr1> alexj: i'm just rolling out a basic web app
02:32:53 <alexj> haven't decided completely yet.
02:32:53 <joelr1> very basic
02:33:16 <alexj> if you are rolling a basic web app then the s3 stuff is probably very much overkill.
02:33:36 <joelr1> alexj: do you hold a consulting job by chance?
02:33:37 <alexj> keep all your state in memory and let happs take care of making that memory durable.
02:33:43 <joelr1> alexj: on wall st?
02:33:50 <alexj> no I am a startup entrepreneur.
02:34:00 <alexj> using HAppS for projects I want to build.
02:34:06 <joelr1> alexj: ok
02:34:09 <alexj> Years ago, I did shop.com.
02:34:24 <alexj> finance is not my world despite living in NYC.
02:34:27 <joelr1> alexj: because i'm, basically, explaining what i need ;) which is S3
02:34:48 <joelr1> alexj: whereas you are telling me that what i want is not what i need :D
02:35:06 <alexj> :- )
02:35:29 <alexj> the whole point of happs is to make web apps simple.  it seems like you not taking advantage of the services it provides.
02:35:59 <alexj> I feel like we have a communications gap because there are easier ways to do what I think you are trying to do.
02:36:06 <joelr1> alexj: lets just say i haven't graduated to letting happs persist my state. i just want a web app that stores stuff in s3 instead of a database. most likely i'll just write haskelldb-s3 which will enable HOPE to work
02:36:23 <alexj> ah ok.
02:36:36 <alexj> well I'll dig through the s3 code when I wake up and see where it stands.
02:36:48 <joelr1> alexj: yes, there's agap. yes, there are likely easier ways. i don't know them yet. will learn.
02:36:53 <joelr1> alexj: thanks
02:37:25 <alexj> just FYI, s3 is an asynchronous store.  if you use it as a database store directly, you are in for trouble.
02:37:55 <alexj> in particular s3 does not guarantee that the last read reflects the last write in finite time.
02:38:44 <alexj> your gets and puts get load balanced across disks in multiple data centers and there is no guarantee that their internal replication will reach the disk you happen to be reading.
02:38:48 <alexj> before you get there.
02:39:52 <alexj> does that make sense?
02:41:02 <joelr1> alexj: yes, i'm aware
02:41:09 <joelr1> alexj: reads don't become available right away
02:41:14 <joelr1> alexj: i'll deal with that
02:41:35 <alexj> ok.  just making sure because that detail breaks a lot of stuff.
02:41:38 <alexj> good night.
02:42:01 <joelr1> alexj: good night
02:47:51 <roconnor> I wish google would stop giving me pages in dutch!
02:48:03 <roconnor> I said I wanted english in my HTTP request
02:48:45 <mux> you lost your cookie :-)
02:49:35 <roconnor> I lose my cookies every time I restart my browser
02:49:48 <sm> hmm, what's the simplest way to convert a string to a float ?
02:50:15 <Wild_Cat> > read "0.5"
02:50:17 <lambdabot>  Exception: Prelude.read: no parse
02:50:21 <roconnor> google: what part of ``Accept-Language: en-ca,en-us;q=0.7,en;q=0.3'' don't you understand!
02:50:34 <mux> roconnor: then you're fucked
02:50:39 <Wild_Cat> :t read
02:50:41 <lambdabot> forall a. (Read a) => String -> a
02:50:43 <mux> google retains the settings in a cookie
02:50:55 <Wild_Cat> > read "30"
02:50:56 <lambdabot>  30
02:50:57 <roconnor> damn you google!
02:51:04 <Wild_Cat> > read ".5"
02:51:06 <malcolmw> > read "0.5" :: Float
02:51:06 <lambdabot>  Exception: Prelude.read: no parse
02:51:07 <lambdabot>  0.5
02:51:19 <Wild_Cat> ah. Okay.
02:51:24 <mux> > read "()" :: ()
02:51:25 <lambdabot>  ()
02:51:26 <malcolmw> without a type sig, read is defaulting to Int
02:51:51 <malcolmw> > read "0.5" :: Rational
02:51:52 <lambdabot>  Exception: Prelude.read: no parse
02:52:14 <Svrog> > read "0.5" :: Float
02:52:16 <lambdabot>  0.5
02:53:01 <Svrog> oh right.. didnt see you already typed that heh
03:00:53 <roconnor> > read "1/2" :: Rational
03:00:58 <lambdabot>  Exception: Prelude.read: no parse
03:01:03 <roconnor> > read "1%2" :: Rational
03:01:05 <lambdabot>  1%2
03:01:28 <roconnor> % is a stupid name for that operator
03:01:38 <earthy> hy?
03:01:45 <earthy> why, even?
03:01:52 <Svrog> could be worse - like the unary minus operator in sml hehe
03:02:10 <roconnor> well, maybe it is better than % meaning `mod`
03:02:27 <earthy> one would want ÷ possibly
03:02:41 <earthy> but % isn't a bad approximation
03:03:33 <DRMacIver> I don't mind the unary minus operator in SML.
03:03:42 <earthy> I think it's quite ugly
03:03:46 <Svrog> yeah
03:04:06 <DRMacIver> It's moderately ugly, but removes an annoying source of ambiguity in the syntax.
03:04:21 <quicksilver> ':/' might be a nice constructor for rational
03:04:51 <DRMacIver> I'd rather have - as a binary operator and ~ as a unary minus operator than Haskell's solution.
03:05:03 <DRMacIver> quicksilver: Thus enforcing Haskell's reputation as the smiley language. ;)
03:05:48 <DRMacIver> (however the fact that I think SML syntax handles operators way better than Haskell's does is nothing new. :) )
03:07:53 <TSC> Gtk2hs question: Is there any way to tell if a widget has been realized yet?
03:10:36 <bringert> joelr1: I didn't see any reason to add the complexity of having an XSLT interpreter just to be able to write templates in a crappy functional language (XSLT), when I already have a good one (Haskell) :-)
03:10:51 <LeCamarade> DRMacIver: Nothing will ever save ML from the shame of ~ as unary minus. Nothing.
03:11:19 <joelr1> bringert: i thought xslt is done in the browser
03:11:31 <joelr1> bringert: but i understand your point of view
03:11:45 <bringert> I produce generic XHTML, and use CSS for layout and styling, even hiding parts of the page. When that isn't enough, I tweak the Haskell "template" code.
03:12:00 <bringert> joelr1: some browsers do xslt, but you can't rely on that
03:12:17 <bringert> you have to resort to hacks like including a javascript xslt interpreter in the page
03:12:17 <joelr1> bringert: i googled and, apparently, all but opera 8 do
03:12:39 <bringert> even oldish IE version?
03:12:41 <bringert> s
03:13:28 <bringert> anyway, to me, it feels much better to have the intelligence on the server side when possible
03:14:11 <bringert> and produce plain xhtml+css, with a bit of javascript for behavior when needed
03:15:25 <joelr1> bringert: right. i also like how you are putting together the page from "components"
03:15:56 <joelr1> bringert: my concern is that it's harder to write html as haskell code as opposed to writing regular html and previewing it and tweaking it without recompiling code
03:16:32 <bringert> true, but the goal is to generate very simple html, and use css for all the fancy stuff
03:16:47 <bringert> which makes it not so big a problem I think
03:17:18 <bringert> I decide on a logical html structure, and only after that about how I want it to look in a browser
03:18:12 <joelr1> bringert: so you are sort of generating xml then?
03:18:22 <bringert> yeah
03:18:34 <bringert> no presentational tags
03:19:34 <DRMacIver> LeCamarade: I don't see any shame in it.
03:19:40 <DRMacIver> LeCamarade: It's a perfectly sensible decision.
03:20:31 <bringert> there are some layout-related class names (like bottomBanner), but those come from the template, not the normal code
03:25:26 <dmead> jesus
03:25:35 <dmead> open office's behavior makes NO sense
03:30:33 <quicksilver> dmead: it's software. what did you expect?
03:30:43 <dmead> not sure really
03:30:47 <dmead> anytime you press enter
03:30:54 <dmead> it might just decide to stop numbering a list
03:31:04 <dmead> or start
03:31:08 <dmead> or indent wildy
03:31:31 <quicksilver> ah, it copies that almagalm of misbehaviours from another more expensive office suite I think
03:31:33 <joelr1> mnislaih: hi pepe
03:31:37 <quicksilver> annoys the f*** out of me
03:31:44 <mnislaih> hey joelr1
03:32:29 <dmead> i don't know about that
03:32:39 <dmead> IIRC word never acted like this
03:32:50 <matthew-_> lyx doesn't either ;)
03:33:08 <DRMacIver> Open Office is basically an inferior copy of one of my least favourite pieces of software ever. Its existence offends me. :)
03:34:24 * olsner agrees
03:35:48 <matthew-_> !Impression and !OvationPro were probable the last two wysiwyg word processors I used that I actually liked, and they were on Acorn RiscPCs
03:38:06 <quicksilver> DRMacIver: Or, it is a tool for reading files produced by other people who use that peice of software. In that context, it's a good tool.
03:49:59 <dcoutts> TSC: hmm, there ought to be, lemme check...
03:55:16 <DRMacIver> quicksilver: Sure. And I use it for such. That doesn't change that the fundamental characteristic of its existence is offensive. :)
04:02:37 <dmead> DRMacIver, yea, it can't save properly to anything but ODF
04:02:48 <dmead> if you want to send a document to somebody you have to use pdf
04:03:27 <sm> night all
04:06:42 <nornagon> is there a perl-esque 'split' in the prelude?
04:07:29 <nornagon> @src words
04:07:30 <lambdabot> words s = case dropWhile isSpace s of
04:07:30 <lambdabot>     "" -> []
04:07:30 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:07:48 <nornagon> why is there no general-case of that?
04:08:22 <quicksilver> nornagon: because it's not obvious how to do it
04:08:30 <quicksilver> nornagon: it's not obvious if it should take a string, or  char
04:08:42 <quicksilver> nornagon: it's not obvious if delimeters should be absorbed, or returned
04:09:07 <quicksilver> nornagon: it's not obvious if consecutive delims should be 'combined' or should give rise to null items
04:09:10 <nornagon> hmm
04:09:11 <quicksilver> nornagon: etc :)
04:09:25 <quicksilver> at least, that's why I've always assumed there isn't one
04:09:27 <nornagon> alack :(
04:09:35 <quicksilver> just because there are at least 4 obvious, but different, thinigs you might need
04:09:51 <Saizan> what words do is a nice default, we could just have wordBy pred and use pred where isSpace is used
04:10:11 <quicksilver> actually, I don't think so
04:10:21 <quicksilver> I think what words does is obscure, and mostly only useful for words
04:10:22 <quicksilver> :)
04:10:48 <quicksilver> words loses information about which delimeters were used, and condenses adjacent ones without creating null items
04:10:53 <quicksilver> that's not what you normally want
04:11:28 <nornagon> I guess you can use Parsec for anything much more complicated.
04:11:56 <quicksilver> I think the 'most useful' general case is the one that returns the delimeters, and doesn't condense them
04:12:11 <quicksilver> but then you wonder if you should 'tag' them as being delimeters, with an 'Either' type, or :)
04:18:23 <quicksilver> > let splitOn p x = (map Left . takeWhile p $ x) ++ (case dropWhile p x of { [] -> [] ; l -> Right (takeWhile (not.p) l) : splitOn p (dropWhile (not.p) l) }) in splitOn isSpace "foo  bar baz"
04:18:25 <lambdabot>  [Right "foo",Left ' ',Left ' ',Right "bar",Left ' ',Right "baz"]
04:18:30 <quicksilver> nornagon: something like that, perhaps
04:18:39 <quicksilver> :t let splitOn p x = (map Left . takeWhile p $ x) ++ (case dropWhile p x of { [] -> [] ; l -> Right (takeWhile (not.p) l) : splitOn p (dropWhile (not.p) l) }) in splitOn
04:18:41 <lambdabot> forall a. (a -> Bool) -> [a] -> [Either a [a]]
04:18:41 <nornagon> mm :)
04:18:58 <quicksilver> nornagon: see the delimeters pulled out as 'lefts' and the content as 'rights'
04:19:09 <nornagon> ye :)
04:19:15 <quicksilver> and note the bizarre type Either a [a] because delimeters are by definition 1 element but contents are many
04:19:29 <nornagon> *nod*
04:19:56 <quicksilver> then of course you can pull only the contents with a simple application of 'catRights'
04:20:02 <quicksilver> if you happen not to care about the delims
04:23:22 <DRMacIver> Sigh
04:23:27 <DRMacIver> My brain just maliciously punned at me.
04:24:14 <DRMacIver> I was having a discussion about constraints driving creative expression in the context of Haskell, and an analogy to vegetarian cooking came up.
04:24:26 <DRMacIver> So I've been running through the theme and thinking of writing a post on it.
04:24:36 <DRMacIver> What to call the post? "Haskell and Curry" of course. :)
04:25:10 * SamB_XP_ likes his haskell with meat
04:28:29 <roconnor> has the ICFP backstory already begun?
04:28:37 <earthy> what backstory? :)
04:28:54 <roconnor> http://johanjeuring.blogspot.com/search?updated-min=2007-01-01T00%3A00%3A00%2B02%3A00&updated-max=2008-01-01T00%3A00%3A00%2B02%3A00&max-results=6
04:28:54 <SamB_XP_> well, last time it was a dig
04:28:56 <lambdabot> Title: Johan Jeuring's blog, http://tinyurl.com/2zhb2a
04:29:13 <SamB_XP_> they dug up the codex
04:29:29 <earthy> owh. ;) they're trolling!
04:37:10 <wilx|wrk> Is foo.cabal file valid YAML document?
04:37:34 <SamB_XP_> if it is, it is just a coincidence
04:37:59 <joelr1> bringert: i finally managed to get it running. the permissions thing was permissions on my flatdb directory
04:38:12 <bringert> oh
04:38:24 <joelr1> bringert: why am i getting a different look from yours and shapr's?
04:38:31 <bringert> I guess I should have asked for what the error message looked like
04:38:35 <bringert> joelr1: different theme
04:38:43 <joelr1> bringert: how do i change?
04:38:59 <bringert>  /setting/hope
04:39:07 <bringert> set theme to "hope"
04:39:29 <joelr1> bringert: oooooh!
04:40:09 <bringert> joelr1: look in theme/{hope,default} for the differences
04:40:28 <bringert> if you want to make your own theme, just copy one of those dirs to a new name
04:40:47 <joelr1> bringert: neato!
04:41:26 <joelr1> bringert: do you think it makes any sense to port hope to happs?
04:44:00 <joelr1> bringert: to have two in one, so to speak
04:44:07 <joelr1> bringert: join the projects
04:51:40 <pejo> Does anyone know who might have been asking about improving the NCG and where to start? Probably about a week ago, but I might be pretty off with that time estimate.
04:53:41 <bringert> joelr1: hmm, it might be useful. I don't really know enough about happs to be sure how much could be carried over easily.
04:55:25 <joelr1> bringert: ok
04:56:16 <joelr1> bringert: i think my debate is coming to an end. more likely than not i'll sign up for regular hosting instead of ec2. there's no advantange for me to be on ec2 right now and the disadvantage is that i loose out on the existing hope functionality
04:56:50 <joelr1> bringert: and have to grapple with s3 instead of keeping my eyes on the crystal ball and improving my compiler
04:58:14 <bringert> joelr1: ok, sounds good.
04:58:40 <bringert> joelr1: if you want to run multiple hope instances, try to get something with a database, so that you can use PostgreSQL or MySQL. I'm not sure if concurrent access to an SQLite db works.
04:59:40 <bringert> joelr1: or if you keep using lighttpd, you could try runFastCGIConcurrent and only have one instance. I'd be very interested in seeing how that works out.
05:00:17 <bringert> joelr1: if you go with Haskell threads, you may need to synchronize access to the DB handle, or have one handle per thread
05:00:48 <bringert> joelr1: the latter breaks persistent db connections though, unless you implement connection pooling
05:02:15 <SamB_XP_> bringert: it isn't very hard to implement that, is it?
05:02:23 <Saizan> ?where hope
05:02:24 <lambdabot> http://hope.bringert.net/
05:05:24 <SamB_XP_> data PoolRequest a = GetFromPool (MVar a) | ReturnToPool a; type PoolChan a = Chan (PoolRequest a)
05:06:46 <joelr1> bringert: i'll start with multiple instances and postgresql i think
05:07:15 * joelr1 goes for a nap (up since 4am today)
05:07:53 <joelr1> bringert: how long are you going to be around?
05:08:13 <bringert> joelr1: maybe three more hours
05:11:02 <joelr1> bringert: i meant to ask you
05:11:24 <joelr1> does all the output always go to the main box?
05:12:06 <joelr1> bringert: i think you already said yes but i wanted to confirm
05:12:25 <bringert> joelr1: I said that, but that's not completely accurate.
05:13:02 <bringert> joelr1: it's only if you use outputBox in your resource handler, and you can control where it goes by changing Config.boxes
05:13:24 <joelr1> bringert: ah, that's right. latest entries in the blog module does it different
05:13:28 <joelr1> ly
05:13:31 <bringert> joelr1: notice the m argument to boxes? that's the argument given to outputBox
05:14:09 <fasta> Emacs completes foo_bar_zork to foorbarzork sometimes. Is there any way to always get foo_bar_zork?
05:14:21 <bringert> yeah, that too. But that's a box that is not the result of a resource handler, it's included statically in boxes
05:14:43 <joelr1> bringert: i also see calls to outputBox from within modules
05:15:01 <bringert> joelr1: yes, in resource handlers
05:15:17 <bringert> that's the only place they are used I think
05:15:32 <joelr1> bringert: what determines that a static page shows up as the front page?
05:15:34 <bringert> joelr1: you can have arbitrary code in Config.boxes to decide what to include in the different boxes, and what boxes to have
05:15:42 <joelr1> bringert: when you look at the homepage
05:16:05 <bringert> joelr1: that's a setting: /setting/front
05:16:56 <joelr1> so the front module gets displayed first?
05:16:58 <bringert> joelr1: it doesn't have to be a static page. it could for example be the list of blog entries, or even the blog entries with a given tag
05:17:17 <joelr1> bringert: i don't see how front gets pulled in, though. it's not in Config.hs
05:17:18 <bringert> joelr1: yes, because the front module is the only one with a handler for the empty path
05:17:30 <bringert> joelr1: it is in mine
05:17:50 <joelr1> bringert: aha, that's how! i meant it's not in the list of boxes
05:18:05 <joelr1> bringert: so modules can define boxes, correct?
05:18:15 <joelr1> bringert: boxes and resource handlers
05:18:42 <bringert> joelr1: yes
05:19:01 <bringert> defining boxes just means exporting a function which creates the box
05:19:41 <bringert> defining a resource handler is done by putting it in the moduleResources field of the Module
05:20:09 <joelr1> bringert: themeLogo = liftM (maybe noHtml (\p -> image ! [src p, alt "Logo"])) $ themeFile "logo.png"
05:20:29 <joelr1> bringert: what determines if there is or there's not a logo here?
05:20:34 <bringert> joelr1: if logo.png exists in the current theme
05:20:54 <bringert> joelr1: look at Hope.Theme.themeFile
05:21:04 <bringert> joelr1: it returns Nothing if the file doesn't exist
05:21:21 <joelr1> bringert: ah, ok, because the result of themeFile gets passed to the lambda
05:21:30 <bringert> joelr1: we should publish these logs as a Hope internals manual :-)
05:22:25 <joelr1> bringert: well, i hope to be posting as i make progress. ibid added me back to planet haskell, i believe
05:23:01 <joelr1> bringert: i have grand plans of world domination and hope looks like the platform that will get me there
05:23:18 <bringert> sweet
05:23:24 <joelr1> bringert: overall, i'm very pleased so far with the clarity of your code. it's very easy to understand and follow.
05:24:03 <bringert> joelr1: thank you
05:24:29 <joelr1> bringert: so now i have to implement a module for my translator
05:25:00 <joelr1> bringert: one more question... what controls the labels assigned to modules in the settings box
05:25:11 <bringert> the moduleName field
05:25:23 <joelr1> ok
05:25:38 <joelr1> thanks. over and out!
05:25:48 <joelr1> Zzzzz.....
05:28:36 <Saizan> ?where crypto
05:28:36 <lambdabot> http://www.haskell.org/crypto
06:08:06 <ohmega_> if i have a matrix represented as a list of lists, is there a clever way to rotate it?
06:08:54 <kpreid> rotate?
06:09:02 * LoganCapaldo thinks theres a transpose
06:09:08 <LoganCapaldo> @hoogle transpose
06:09:12 <lambdabot> List.transpose :: [[a]] -> [[a]]
06:09:12 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
06:09:13 <mauke> > transpose ["abc","def"]
06:09:18 <lambdabot>  ["ad","be","cf"]
06:09:28 <kpreid> some combination of transpose, reverse, and map reverse
06:09:30 <integral> Still no matrix library?
06:09:32 <ohmega_> oh nice thanks
06:09:59 <kpreid> I should say, some combination of transpose and reverse
06:10:27 <kpreid> > transpose . reverse $ ["abc","def"]
06:10:28 <lambdabot>  ["da","eb","fc"]
06:11:00 <ohmega_> thanks :)
06:11:47 <LoganCapaldo> > let zip' a b = transpose [a, b] in (zip [1,2,3] [0,-1,-2], zip' [1,2,3] [0, -1, -2])
06:11:49 <lambdabot>  ([(1,0),(2,-1),(3,-2)],[[1,0],[2,-1],[3,-2]])
06:13:59 <LoganCapaldo> > let zipWith' f a b = map (foldr1 f) $ transpose [a, b] in zipWith' (+) [1,2,3] [-1,-2,-3]
06:14:03 <lambdabot>  [0,0,0]
06:14:43 <LoganCapaldo> who needs tuples? :)
06:15:05 * LoganCapaldo conviently ignores zip [a] [b] scenarios
06:17:44 <mdmkolbe|work> What does ~ mean? (explainations or keywords for me to google welcome)
06:18:18 <kpreid> 'svn help status' knows
06:18:24 <Saizan> mdmkolbe|work: used in a pattern makes it lazy and so irrefutable
06:18:26 <mauke> mdmkolbe|work: lazy binding
06:18:31 <kpreid> oops, wrong channel
06:18:39 <kpreid> gah, sorry about that
06:18:52 <Saizan> > (\~(Just a) b -> b) Nothing 1
06:18:53 <lambdabot>  Parse error
06:19:13 <Saizan> > let foo ~(Just a) b =  b in foo Nothing 1
06:19:15 <lambdabot>  1
06:19:16 <mauke> > (\ ~(Just a) b -> b) Nothing 1
06:19:18 <lambdabot>  1
06:19:52 <mdmkolbe|work> > (\ f ~(Just a) = f a) (const 1) Nothing
06:19:53 <lambdabot>  Parse error
06:20:07 <mdmkolbe|work> > (\ f ~(Just a) -> f a) (const 1) Nothing
06:20:09 <lambdabot>  1
06:20:20 <mdmkolbe|work> > (\ f ~(Just a) -> f a) (id) Nothing
06:20:22 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just a)
06:20:36 <LoganCapaldo> > let f a@(~(_:xs)) = if null a then "empty" else xs in (f "", f "qbz")
06:20:38 <lambdabot>  ("empty","bz")
06:20:57 <sioraiocht> (,) is the tuple constructor, right?
06:21:10 <LoganCapaldo> irreputable patterns are fun
06:21:21 <sioraiocht> except they get angry with you, lol
06:21:28 <LoganCapaldo> sioraiocht: its the 2-tuple constructor
06:21:31 <mdmkolbe|work> @type (,)
06:21:33 <LoganCapaldo> > (,,) 2 3 4
06:21:34 <lambdabot> forall a b. a -> b -> (a, b)
06:21:35 <lambdabot>  (2,3,4)
06:21:40 <sioraiocht> ahahaha
06:21:43 <sioraiocht> err
06:21:44 <sioraiocht> ahhhhhhh
06:21:49 <sioraiocht> <----- out of sleep
06:22:07 <mdmkolbe|work> sioraiocht: that's better than in sleep
06:22:22 <sioraiocht> i disagree
06:22:26 <sioraiocht> but it's okay
06:22:32 <sioraiocht> <----- done with undergrad
06:22:39 <sioraiocht> <----- knows...things...
06:23:03 <mauke> @type uncurry (,)
06:23:05 <lambdabot> forall a b. (a, b) -> (a, b)
06:23:22 <sioraiocht> is a tuple a monad?
06:24:08 <quicksilver> only in a rather boring way
06:24:09 <mdmkolbe|work> sioraiocht: It can be the implementation of a writer monad
06:24:31 <sioraiocht> haskell never ceases to surprise me
06:24:36 <quicksilver> or a state monad, indeed
06:24:36 <mdmkolbe|work> @src MonadWriter
06:24:37 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:24:43 <mdmkolbe|work> @src Writer
06:24:44 <lambdabot> Source not found. Do you think like you type?
06:25:02 <quicksilver> technically the implement of a state moand is a function though, so I'm being a bit sloppy there
06:25:54 <ddarius> Sx- -| S -> - , State is the monad determined by that adjunction.
06:25:57 <mdmkolbe|work> @src runWriter
06:25:58 <lambdabot> Source not found. My pet ferret can type better than you!
06:26:27 <mauke> @src Control.Monad.Writer.runWriter
06:26:28 <lambdabot> Source not found. My mind is going. I can feel it.
06:27:00 <sioraiocht> ddarius: just used a bunch of symbols in an order i don't understand
06:28:56 <LoganCapaldo> adjunction junction, what's your function? Monadically tracking state and faking imperative
06:29:08 <LoganCapaldo> adjunction junction hows that function?
06:29:15 <sioraiocht> i want to stab my eyes out, now, LoganCapaldo
06:29:19 <LoganCapaldo> oh lord
06:29:25 <mdmkolbe|work> LoganCapaldo: I loved that song
06:29:30 * merus wants to draw retro cartoon accompaignment
06:29:30 <LoganCapaldo> I think I want to stab my own eyes out
06:29:52 <mauke> @quote
06:29:53 <lambdabot> procyon_ says: Emacs built a time machine once and went back in time to stop the JFK assassination. As Oswald shot, Emacs met all three bullets with M-x bullet-mode-hook, deflecting them. JFK's head
06:29:53 <lambdabot> exploded out of sheer amazement.
06:30:33 <DRMacIver> LoganCapaldo: ...
06:30:57 <LoganCapaldo> Did I win the channel?
06:31:22 <DRMacIver> LoganCapaldo: No, but you made the baby jesus don his kitten stomping boots.
06:32:39 <Wild_Cat> @quote
06:32:39 <lambdabot> fr30n says: <fr30n> php? eso es para vrutos
06:33:29 <Japsu> what's that in english?
06:33:33 <ventonegro> @quote
06:33:33 <lambdabot> robreim says: I'm in your base hacking all your lambdas
06:47:05 <nominolo> @quote
06:47:05 <lambdabot> bfulgham says: I now have trained-monkey-level skills in Haskell.  I can write really bad shootout code (that the real people rewrite correctly), and build stuff like darcs.
06:56:52 <nominolo> @quote A-normal form
06:56:53 <lambdabot> No quotes for this person. Take a stress pill and think things over.
06:58:34 <ndm> has anyone got much experience with de Bruijn indexes?
06:59:39 <nominolo> there was a JFP paper
06:59:50 <ndm> i'm wondering why GHC doesn't use them
07:00:03 <ndm> if there is any reason not to? or advantages/disadvantages?
07:00:17 <nominolo> you need to special-case global vars
07:00:38 <nominolo> but that paper talked about some hybrid variant
07:00:39 <ndm> that doesn't fuss me, in Yhc there are no global variables
07:00:58 <ndm> in Yhc local variables are a different category from top-level functions
07:02:02 <ndm> one thought i had is that let x = y in z, removing the x binding will require the indexes to change
07:02:22 <kolmodin> ?tell dons could you please make lambdabot to join #kedja on quakenet?
07:02:23 <lambdabot> Consider it noted.
07:05:53 <LoganCapaldo> @go de Bruijn indexes
07:05:57 <lambdabot> http://www.cs.cornell.edu/Info/Projects/NuPrl/cs611/fall94notes/cn14/section3_4.html
07:05:57 <lambdabot> Title: de Bruijn indices
07:14:38 <nominolo> ndm: "Functional Pearl: I am not a Number—I am a Free Variable"
07:14:48 <nominolo> that was the paper
07:14:59 <nominolo> i haven't read it completely, though
07:15:12 <LoganCapaldo> you fp guys are weird
07:15:16 <ndm> nominolo++
07:15:24 <LoganCapaldo> I wish I was that weird
07:15:38 <LoganCapaldo> Or maybe I wish I was less weird
07:16:03 <nominolo> LoganCapaldo: you'll get there soon, young lampadawan
07:16:42 <pejo> ndm, Leroy has some excellent slides from some summer school online iirc. Dont' remember if there were any more material available though.
07:17:16 <LoganCapaldo> Someone how I don't think a diagram was what was meant by de Bruijn indexes in this context
07:17:35 <LoganCapaldo> oh wait
07:17:41 <LoganCapaldo> I didn't look carefully enough
07:17:53 <LoganCapaldo> now that paper title becomes more comical
07:17:57 <LoganCapaldo> hehe
07:18:04 <LoganCapaldo> it was funny before, but its hilarious now
07:18:05 <ndm> pejo: thanks, i'll look those up
07:18:14 <fasta> Is there anyone who implemented something non-trivial with STRef that I can read?
07:18:46 <pejo> nominolo, was it you who asked about improving code generation in GHC the other day?
07:18:54 <LoganCapaldo> wow that's one of the mos tinteresting datastructures I've never had to use
07:20:30 <swiert> ndm: Have you seen Lennart Augustsson's note:
07:20:31 <swiert> http://www.augustsson.net/Darcs/Lambda/top.pdf
07:20:40 <nominolo> pejo: not sure.  maybe a very long time ago.
07:20:51 <nominolo> pejo: but certainly not recently
07:21:56 <ndm> swiert: i hadn't seen that, thanks
07:25:00 <mauke> A Very Modal Model of a Modern, Major, General Type System
07:26:49 <LoganCapaldo> Modal type system?
07:27:08 <LoganCapaldo> major-mode-static minor-mode-dynamic
07:28:13 <shapr> "I am the very model of a modern Major-General" - http://en.wikipedia.org/wiki/Major_General's_Song
07:28:15 <lambdabot> Title: Major-General's Song - Wikipedia, the free encyclopedia
07:28:28 <shapr> mauke: That title is a such a great bit of humor!
07:29:33 <nominolo> LoganCapaldo: Modal logics talks about possible worlds.  I.e., "which mode are we in" (veery roughly said)
07:29:52 <LoganCapaldo> nominolo: that completely cleared it up :)
07:30:29 <daniel_larsson> between 3am and 10am, it's an integer. over lunch a string
07:30:35 <LoganCapaldo> is it related to my undergraduate understanding of the logical interpretation of probability?
07:31:27 <nominolo> no, idea, but it allows you to treat integers as pointers, given the right context/mode
07:31:31 <quicksilver> that might be an example of it
07:31:46 <quicksilver> actuall modal logics are more or less just logics with one or more unary operators
07:31:51 <quicksilver> it's a pretty general field
07:32:21 * fasta finds that everyone talking about modal logic and programming is always talking vaguely.
07:32:27 <quicksilver> (well, that's the syntactic direction)
07:32:49 <quicksilver> from a philosophical direction, modal logics were intended to model things other than absolute truth
07:32:55 <quicksilver> like possibility, or belief
07:33:02 <LoganCapaldo> nominolo: so it lets you formailze things like *(foo + 4) in C?
07:33:24 <nominolo> LoganCapaldo: given the right type-system ;)
07:33:41 <LoganCapaldo> ya huh
07:34:18 <nominolo> the tricky part is to make it correct and decidable, i guess
07:34:26 <fasta> I understand Kripke semantics, I understand programming, but I don't see the connection. (yes, I know there's no absolute "understanding")
07:34:31 <LoganCapaldo> quicksilver: So does "not" count as a unary operator? And if so does that mean regular first-order predicate logic is a modal logic?
07:34:39 <quicksilver> LoganCapaldo: in a sense, yes
07:34:44 <quicksilver> LoganCapaldo: it's really not very precise (any more)
07:35:03 <quicksilver> certainly the embeddings between classical and constructive aremuch like modalities
07:35:17 <quicksilver> and they use "not not"
07:35:37 <quicksilver> haskell's logic is full of unary operators any way. Like 'Maybe'
07:36:12 <roconnor> *sigh* I wish Coq was written in Haskell.
07:36:18 <roconnor> Then undo would probably work
07:37:03 <quicksilver> LoganCapaldo: http://en.wikipedia.org/wiki/Modal_logic emphasises the philosophy and so on
07:37:05 <lambdabot> Title: Modal logic - Wikipedia, the free encyclopedia
07:37:11 <mattam> roconnor: It would probably be slow as hell though :)
07:37:20 <roconnor> :)
07:37:22 <quicksilver> but the kind of mathematician who is building a type system is more interested in syntax and model theory
07:37:28 <fasta> Oh, no recommending Wikipedia.
07:37:32 <quicksilver> and less in the 'meaning' of the prepositions
07:37:39 <quicksilver> fasta: I read the article before recommending it. It's fine.
07:37:42 <mattam> More seriously, it should work
07:37:57 <mattam> But i'm off.
07:38:02 <fasta> quicksilver: ok, then it must have been improved since the last time I looked.
07:38:15 <roconnor> undoing side-effects is hard
07:38:36 <quicksilver> roconnor: the easiest way is normally just to remember old states
07:38:40 <mattam> Undo works by taking snapshots
07:38:40 <quicksilver> roconnor: if it's remotely complex
07:39:01 <mattam> later
07:39:02 <fasta> roconnor: disregarding IO?
07:40:00 <LoganCapaldo> quicksilver: interesting, thanks
07:40:02 <roconnor> fasta: yep.  by undo I mean backing up the proof editor.
07:40:18 <roconnor> fasta: so really there is no conceptual problem.
07:40:31 <roconnor> but because they used Ocaml, the use all sorts of destrucive updating.
07:40:44 <roconnor> then then hack on an undo on top of that
07:40:51 <roconnor> and of course it doesn't always work
07:41:16 <roconnor> If it was written in haskell, they probably would have made all proof operations reversable, or something like that.
07:41:40 <roconnor> Of course, they could have done it right in Ocaml
07:41:57 <roconnor> and you could maybe use STrefs in Haskell and do it wrong
07:42:11 <roconnor> but the Haskell philosophy would have affected the development.
07:44:25 * quicksilver nods
07:44:27 <quicksilver> yes, it's funny that
07:44:36 <quicksilver> they *could* have done it right in ocaml
07:44:37 <quicksilver> but they didn't
07:44:56 <quicksilver> they ocaml code I have written (which isn't much) is all "like I would have written it in haskell"
07:45:02 <quicksilver> I.e. without destruction
07:45:12 <quicksilver> but the 'vibe' of the language affects how people write it
07:45:13 <Cheery> is there smarter way to type (-20)?
07:45:29 <Cheery> ie: n * (-20)
07:45:31 <roconnor> Cheery: not to my knowledge
07:46:07 <Cheery> sometimes I think haskell should have prefixes. :)
07:46:39 <Cheery> ie. prefix would be defined like: - a = ...
07:46:51 <Cheery> ie: - a = negate
07:46:58 <fasta> My experience is that sooner or later you need something like STRefs
07:46:58 <Cheery> + a
07:47:18 <fasta> How can you do that in OCaml without using mutable state?
07:47:23 <roconnor> fasta: you could be write.  I only write toy programs.
07:47:24 <roconnor> er
07:47:25 <roconnor> right
07:47:28 <roconnor> *sigh*
07:47:44 <roconnor> my brain just doesn't ever connect to the keyboard properly
07:47:48 <quicksilver> fasta: you'd reimplement STM in ocaml :)
07:47:54 <quicksilver> fasta: using mutable state to implement it, obviously
07:48:01 <quicksilver> fasta: but presenting a pure interface
07:48:31 <Cheery> prefix could separate from infix so that it'd be required to precede it's parameter without whitespacse
07:48:34 <Cheery> *whitespaces
07:48:34 <fasta> quicksilver: yes, but I meant to imply that you didn't use mutability then, since writing such a system probably is non-trivial.
07:49:02 <Cheery> you never write anything like 20+4*3-2/5
07:49:18 <Cheery> or hmm, you write actually..
07:49:33 <fasta> E.g. now I have the problem to point from a set of objects X to another set of structures Y s.t. Y forms a partition of X.
07:49:44 <Cheery> I wonder, if there would be prefixes in haskell, how to separate them from infixes?
07:49:56 <fasta> You simply cannot do that efficiently in a purely functional way (without STRef)
07:50:33 <Wild_Cat> Cheery: Haskell doesn't require prefix operators, it has curried functions.
07:50:57 <Cheery> Wild_Cat: explain
07:50:59 <fasta> (One of the operations should be to move one element of Y to another partition)
07:51:31 <LoganCapaldo> > let (<+>-) x = x + 2 in (<+>-) 3 -- almost a prefix operator
07:51:33 <lambdabot>  5
07:51:56 <quicksilver> fasta: people's experiences of programming vary enormously depending on the constraints they've had to labour under
07:52:07 <Wild_Cat> Cheery: in some way, prefix operators are a special case of curried functions.
07:52:09 <quicksilver> fasta: non of my ocaml or sml code required minutes to run
07:52:12 <Wild_Cat> > (+) 2 2
07:52:14 <lambdabot>  4
07:52:19 <fasta> quicksilver: yes, I notice that with web programmers.
07:52:23 <quicksilver> fasta: so I never had to think of more efficient destructive algorithms
07:52:27 <LoganCapaldo> those extra parens are a bit of an irritant though if you really really really want prefix operators
07:52:34 <quicksilver> fasta: of course, if I had had to, I would have had to confront that problem
07:53:01 <fasta> I think optimal solutions are quite "cool".
07:53:06 <quicksilver> yes, they are
07:53:11 <quicksilver> I can appreciate them :)
07:53:24 <quicksilver> but that alone wouldn't make me pick a destructive language as my first choce of language :)
07:53:29 <fasta> (That doesn't mean it's the best in practice)
07:53:56 <fasta> I wish Haskell would get augmented with e.g. Pascal syntax.
07:54:15 <roconnor> fasta: are you sure about your claim?  I've never seen a proof that any problem exists that a purely function lazy language cannot perform as well as a language with side effects in ammortized time.
07:54:38 <fasta> Haskell is a great _functional_ programming language. It's just not that good for mutable algorithms.
07:55:14 <hpaste>  Cheery pasted "lesson03 in 44 lines" at http://hpaste.org/1795
07:55:32 <roconnor> fasta: true, but often problems that can be solved with mutable algorithms can also be solve with lazy non-mutable algorithms in the same ammortized time.
07:55:33 <shapr> fasta: Yeah, I would also be interested in why you think that.
07:55:41 <fasta> roconnor: No, I have not seen such a proof.
07:55:44 <LoganCapaldo> what we need is a magical program that automatical transforms inefficient no destructive updates code into efficient destructive updates code :)
07:55:55 <mauke> ghc
07:55:59 <shapr> LoganCapaldo: I think some of that is already done in GHC.
07:56:26 <LoganCapaldo> shapr: The really interesting thing about that statement was I wasn't even sure how ironic I was being :)
07:56:27 <roconnor> and of course there is the difference between amortized time and the time it actually takes. :)
07:56:40 <fasta> roconnor: yes, often, but I think not always.
07:56:54 <Wild_Cat> just because the language you use to express a problem has no side effects doesn't mean the machine code it's compiled to doesn't have any either ;)
07:57:15 <mauke> huhu, purely functional assembler code
07:57:16 <shapr> Many amortized algorithms can be turned into deterministic algorithms.
07:57:26 <shapr> mauke: Actually, I think that would have a lot of advantages for NUMA.
07:57:27 <roconnor> fasta: cool, I think that it is always.  But I don't beleive there is a known proof or counter example.
07:57:28 <fasta> shapr: ?
07:57:31 <emu> amortized doesn't mean randomized
07:57:34 <ski> whether there's side effects or just effects depends on the point of view
07:57:48 <fasta> roconnor: I would find it _very_ interesting if you are right.
07:57:54 <shapr> emu: Er, maybe 'guaranteed worst case' is what I mean?
07:57:55 <roconnor> fasta: me too
07:58:04 <shapr> I can't remember what Okasaki calls them.
07:58:18 <emu> hmm
07:58:35 <emu> amortized means that cheap operations can balance out the rarer costly operations
07:58:41 <mauke> 'worst-case time'
07:59:00 <quicksilver> typically amortized involves making an assumption about use case
07:59:12 <quicksilver> 'any application which calls this, will also call this thing here 'n' times'
07:59:14 <quicksilver> or something
07:59:20 <fasta> roconnor: does this purely functional language have DiffArray?
07:59:30 <Wild_Cat> for example, appending to a Java-style ArrayList runs in O(1) amortized time.
07:59:30 <quicksilver> sometimes the assumptions are more natural than others
08:00:47 <Wild_Cat> (appending to a linked list, however, runs in guaranteed O(1) time)
08:01:11 <fasta> roconnor: ?
08:01:15 <roconnor> fasta: Is DiffArray special?  (I've never used it)
08:01:18 <emu> if you track the last element and are willing to modify it =)
08:01:40 <fasta> roconnor: it has constant time update and is implemented under the hood with an IOArray.
08:01:54 <roconnor> by IOArray do you mean STArray?
08:02:10 <fasta> roconnor: it provides a purely functional interface, but cannot AFAIK be implemented without mutable memory.
08:02:27 <roconnor> I beleive this pure language does not have ST nor DiffArray.
08:02:41 <ski> 'DiffArray' is a quotient type, roughly ..
08:02:53 <LoganCapaldo> That's a clever trick. I wonder if its applicable to other datastructures? Is there a DiffMap for instance?
08:03:06 <roconnor> but I believe a DiffArray abstract data type can be implemeneted so that it's operates in the same ammortized run time as DiffArray.
08:03:14 <roconnor> (although probably slower in practice).
08:03:22 <fasta> roconnor: can you sketch one?
08:03:25 <roconnor> and I have no proof of this
08:03:52 <ski> (fasta : i suspect with a powerful enough language, one could define things like 'DiffArray' "purely")
08:04:16 <roconnor> I'd have to go digging around and look at what the various purely function array implementations are like.
08:04:19 <shapr> fasta: Isn't a purely functional algorithm with GC roughly equivalent to a mutable algorithm?
08:04:25 <fasta> ski: "powerful enough"?
08:04:50 <ski> roconnor : the old references to the 'DiffArray' will get slower to use, when a new one is made ..
08:04:51 <roconnor> @docs DiffArray
08:04:52 <lambdabot> DiffArray not available
08:05:34 <fasta> shapr: I am not sure what you mean.
08:05:50 <roconnor> ski: is that the way DiffArray currently works?
08:05:51 <ski> fasta : a way to create a quotient type, giving an underlying representation type, and an equivalence relation on that, and also a way to change the underlying representation of a value, when *reading* the value
08:06:00 <ski> roconnor : iirc, yes
08:06:18 <DRMacIver> ski: Or you could create some sort of data structure which encapsulate side effects. But what would we call it?
08:06:19 <roconnor> ski: oooh good. That gives me leverage to make my ammortized time just as fast :)
08:06:22 <fasta> ski: ok
08:07:30 <ski> roconnor : how can you change the old references to reference the new version, through indirections ? (or maybe you weren't to ?)
08:07:59 <fasta> roconnor: it would be interesting if you could pose a sufficiently precise question and put it on the wiki.
08:08:10 <roconnor> ski: Well, I just need to implement the API,  I'm free to use a totally different representation.
08:08:14 <ski> DRMacIver : you're thinking of monads or friends, yes ?
08:08:33 <ski> DRMacIver : i was more thinking of something alike uniqueness in Clean and Mercury
08:08:39 <shapr> fasta: I mean that a recursive algorithm can generate iterative machine code, yeah?
08:08:52 <fasta> shapr: yes
08:09:13 <shapr> So a purely functional algorithm can be compiled to a mutable implementation.
08:09:32 <fasta> shapr: recursion doesn't make the algorithm slower when implemented naively.
08:09:33 <shapr> I'm not entirely awake yet, am I missing something about what you said?
08:09:47 <fasta> shapr: slower in Big Oh terms
08:10:01 <Saizan> LoganCapaldo: you don't need a DiffMap because you can share the structure between first and the derived map
08:10:06 <roconnor> fasta: basically we need to list the operations for a DiffArray and the time it takes for them to operate.
08:10:07 <shapr> It can if you need to do longjmp and stuff.
08:10:24 <LoganCapaldo> Saizan: Zipper?
08:11:21 <Saizan> LoganCapaldo: Data.Map.Map is a balanced tree, so you can share the subtrees/nodes that are common
08:11:38 <fasta> shapr: that is only of interest when you have self-modifying programs.
08:11:54 <fasta> shapr: if you assume a constant program it disappears in the Big Oh.
08:12:07 <LoganCapaldo> Saizan: What happens when you go to rebalance though?
08:12:25 <LoganCapaldo> Although now I'm getting off the idea of a DiffMap I suppose
08:12:28 <shapr> Recursion can also blow the stack, as I often do in Python.
08:12:29 <fasta> roconnor: That has already been done in the documentation of DiffArray, I guess.
08:12:45 <fasta> shapr: This is a theoretical discussion.
08:12:50 <fasta> shapr: not a practical one.
08:12:52 <hpaste>  ndm pasted "C++ hello world" at http://hpaste.org/1796
08:13:16 <hpaste>  ndm annotated "C++ hello world" with "(no title)" at http://hpaste.org/1796#a1
08:13:16 <LoganCapaldo> ndm: what no new line?
08:13:28 <roconnor> fasta: Anyhow, I came to have this belief after reading: http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html
08:13:29 <lambdabot> Title: Research Highlights - More Haste Less Speed
08:13:41 <ndm> LoganCapaldo: no working either...
08:13:51 <roconnor> ``Nicholas Pippenger showed that under certain simple restrictions, problems that can be solved in linear time in a language with assignments must take longer (by a logarithmic factor) in an eagerly evaluated purely functional language. Our paper (Journal of Functional Programming, 7(5):541-547, September 1997) shows that a lazy functional program solves Pippenger's problem in linear time. This demonstrates that lazy evaluation is strictly more
08:13:51 <roconnor> efficient - in asymptotic terms - than eager evaluation, and that there is no general complexity-preserving translation of lazy programs into an eager functional language.
08:13:57 <roconnor> oh sorry
08:14:01 <fasta> roconnor: I saw the article earlier.
08:14:01 <roconnor> that was bigger than I thought
08:14:16 <LoganCapaldo> ndm: was ghc a typo for g++ or am I just not getting a joke?
08:14:22 <shapr> fasta: Well... Theoretically, purely functional algorithms can always be compiled to an equivalent mutable form.
08:14:33 <ndm> LoganCapaldo: nope, i'm testing GHC's c++ support
08:14:43 <LoganCapaldo> waaaaaaaa?
08:14:51 <LoganCapaldo> @go GHC C++
08:14:53 <lambdabot> http://www.nabble.com/ANNOUNCE:-GHC-version-6.6.1-t3651052.html
08:14:54 <lambdabot> Title: Nabble - ANNOUNCE: GHC version 6.6.1
08:15:06 <fasta> shapr: yes, but that doesn't mean that for every mutable algorithm there is an purely functional algorithm that is as fast.
08:16:07 <ski> roconnor : hm .. caching lazy thunks could also be thought of in terms of quotient types, i think
08:16:12 <LoganCapaldo> ndm: -lstdc++ no?
08:16:23 <ndm> LoganCapaldo: people just figured that out #ghc
08:16:26 <roconnor> ski: I don't see the relationship
08:16:48 <LoganCapaldo> ndm: figured out what?
08:16:51 <shapr> fasta: Er, why not? From a theoretical viewpoint, mutable code can be generated.
08:16:58 <ndm> LoganCapaldo: why it wasn't working
08:17:03 <LoganCapaldo> ah
08:17:39 <LoganCapaldo> this is coolness. You got C++ in my GHC! You got GHC in my C++!
08:18:16 <DRMacIver> Does the C++ actually use any of the rest of GHC, or is it a separate compiler bundled for convenience?
08:19:19 <olsner> GHC's c++ support?
08:19:44 <DRMacIver> Yeah
08:19:51 <fasta> shapr: if the relation would be so obvious, why do we have STRef?
08:19:56 <shapr> fasta: From one viewpoint, neither functional nor imperative algorithms are efficient. The CPU does reordering and pipelining for us. Our algorithms are particularly fast, but compiler tricks make them faster.
08:20:06 <ski> roconnor : each equivalence class contains two terms 'NonForced <thunk>','Forced <value>' .. when passing in a thunk to some function, if the thunk is forced, then thay opens up the equivalence class, gets the current representant, executes the non-forced code (if non-forced) and replaces the representant of the equivalence class by the new forced representant (update-in-place) .. since it doesn't matter which representant of
08:20:17 <shapr> er "are not"
08:20:17 <olsner> aah, compiling and linking C++ and Haskell code, is it?
08:20:27 * LoganCapaldo is really excited about C++ + GHC for some reason
08:20:35 <LoganCapaldo> I don't have a use case
08:20:36 <ski> (roconnor : that is that idea, anyway .. i dunno yet if it really works or not :)
08:20:42 <DRMacIver> LoganCapaldo: It's probably a sign of insanity.
08:20:47 <LoganCapaldo> but I'm almost manically thrilled by the idea
08:21:04 <LoganCapaldo> DRMacIver: Almost certainly
08:21:15 <roconnor> ski: I see
08:21:21 * olsner only sees ABI incompatibility, runtime library incompatibilities, GCC version dependencies, and problems ad infinitum
08:21:59 <ski> (roconnor : i.e. lazy memoing thunks could be made to fit into some kind of more general framework for quotients)
08:22:02 <shapr> roconnor: What's that pippenger quote from?
08:22:13 <olsner> words ending with -tibilities are fiendishly difficult to spell
08:22:26 <shapr> sensitibilities!
08:22:35 <shapr> hillitibilities!
08:22:53 <olsner> and is it compatIbilities or compatAbilities?
08:23:10 <shapr> compatibilities
08:23:13 <olsner> I seem to remember both existing but having slightly different meanings
08:23:35 <ski> @spell compatibilities
08:23:54 <ski> @arr ?
08:23:54 <lambdabot> Keelhaul the swabs!
08:24:10 <Japsu> @yarr
08:24:11 <lambdabot> This is the END for you, you gutter-crawling cur!
08:24:15 <ski> :D
08:24:19 <Japsu> right.
08:24:20 <roconnor> shapr: http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html
08:24:21 <lambdabot> Title: Research Highlights - More Haste Less Speed
08:24:31 <shapr> roconnor: thanks
08:25:29 <olsner> @quote
08:25:29 <dcoutts_> ndm: what's the name of your deriving lib ?
08:25:30 <lambdabot> tackling says: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
08:25:40 <ndm> dcoutts_ derive
08:25:43 <ndm> @where derive
08:25:44 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
08:25:45 <dcoutts_> @where derive
08:25:45 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
08:25:49 <dcoutts_> ta :-)
08:25:59 <ndm> dcoutts_ what are you wanting it for?
08:26:13 <dcoutts_> ndm: deriving deepseq
08:26:20 <roconnor> Working with dependent types is hard.  Have convertable types really screws with unification.
08:26:34 <dcoutts_> ndm: I want to benchmark a simple traversal with a binary serialising traversal
08:26:50 <ndm> dcoutts_ i think there is rnf in there already, and you should definately be able to do it with the example guessing
08:26:54 <dcoutts_> ndm: I want to get withing 2x of the speed of a simple traversal
08:28:06 <shapr> fasta: I think that STRef is for cases where the user doesn't want to rely on the implementation, much like unsafePerformIO or runGC (or whatever it's called). But from a theoretical viewpoint, you don't need it.
08:28:33 <quicksilver> roconnor: yes, but very clever people are giving it plenty of thought
08:28:40 <ndm> dcoutts - i can't find such a class in the library, feel free to send a patch :)
08:28:52 <dcoutts_> ndm: deepseq = nfdata
08:28:58 <shapr> fasta: But I'd like to hear your opinion on STRef.
08:29:22 <ndm> dcoutts_ ah, missed it :)
08:29:38 * ski thinks 'STRef' is for cases when you want (newable) copyable references into unique state
08:29:40 <Cheery> it'd be cool to have a decompiler which outputs as readable code as what haskell is
08:29:45 <dcoutts_> shapr: I thought that was still undetermined, whether mutation actually buys better asymptotic complexity
08:29:49 <fasta> shapr: I can't implement an STRef type myself without using STRef or IO, so I don't consider it purely functional/
08:30:10 <joelr1> g'day
08:30:11 <fasta> shapr: it might be possible that other people can implement it, but it seems non-trivial.
08:30:13 <dcoutts_> fasta: you can, just not in the same time bounds.
08:30:13 <Cheery> ie. inventing the relevant names for procedures and variables, and so on. :)
08:30:25 <fasta> dcoutts_: that's what I meant.
08:30:31 <shapr> fasta: You can't implement IO without IO.
08:30:36 <fasta> dcoutts_: roconner thinks you can.
08:30:47 <fasta> roconnor*
08:30:52 <dcoutts_> roconnor: I'd be interested to see that, it seems hard.
08:31:14 <quicksilver> roconnor argued it was possible in the same amortized time complexity
08:31:15 <roconnor> dcoutts_: I don't have a proof, I'm far from an expert.
08:31:24 <quicksilver> but I think he's going on intuition
08:31:30 <roconnor> dcoutts_: but I don't have a proof that you can't either. :)
08:31:32 <fasta> roconnor: but roconnor it would be nice if you could pose a precise question on the wiki.
08:31:34 <quicksilver> I know what he's getting at, the intuition is tempting
08:31:44 <fasta> roconnor: I am currently writing up a nice problem.
08:31:53 <dcoutts_> fasta, roconnor: the obvious way is O(log n) rather than O(1), using a finite map to hold the STRefs
08:32:08 <dcoutts_> roconnor: what's the basic idea then?
08:32:11 <fasta> dcoutts_: yes, but that's of no interest for this discussion.
08:32:15 <roconnor> dcoutts_: for what operations?
08:32:32 <dcoutts_> roconnor: creating and updating STRefs, particularly updating.
08:33:29 <roconnor> dcoutts_: I'm not saying I can implement STRefs purely, I'm saying I can implement DiffArrays purely.
08:33:43 <roconnor> well, someone can...
08:33:58 <dcoutts_> hmm
08:35:10 <roconnor> And it is still an acacdemic questions since I still expect the pure solution to be slower in practice.
08:35:49 <ski> (faste : .. imo, just because something can't be implemented in haskell doesn't mean it can't be "purely functional")
08:36:13 <roconnor> ski: ?
08:36:23 <fasta> ski: oh, I agree with that.
08:36:38 <ski> roconnor : sorry ?
08:36:46 <roconnor> but haskell gives you direct access to the pure lambda calculus.
08:37:04 <roconnor> how could there be a purely function function that you cannot write in haskell?
08:37:35 <ski> possibly if you consider efficiency
08:37:47 <fasta> People should write a paper about this subject.
08:38:05 * ski is thinking about things like uniqueness in Clean
08:38:10 <roconnor> ski: but haskell has the same reduction semantics as the lazy lambda calculus.
08:38:16 <Saizan> is Array implemented purely?
08:39:59 <roconnor> Saizan: I assume so
08:40:25 <shapr> fasta: Go for it!
08:40:26 <ski> roconnor : first, this above is just a hunch i have .. second, then maybe the lazy lambda calulus isn't the last word (wrt efficiency)
08:40:32 <shapr> fasta: How many papers have you published?
08:40:45 <Saizan> mmh you need a pure way to allocate a certain quantity of memory
08:42:16 <shapr> fasta: I haven't published anything outside of TMR.
08:42:48 <chitin> :t readList
08:42:51 <lambdabot> forall a. (Read a) => String -> [([a], String)]
08:43:20 <roconnor> ski: fair enough
08:44:13 <chitin> > readList "hello"
08:44:14 <lambdabot>  []
08:44:57 <fasta> Purely functional: There is no function s.t. after evaluation of the function the value contained in some other data structure changed.
08:45:04 <chitin> how do you use readList?
08:45:23 <fasta> Would you accept that definition for the purely functional programming language used in the problem I am describing?
08:45:48 <joelr1> bringert: you wouldn't mind if i used mercurial, would you? i don't even know if i'll make any changes but a patch bomb could surely be sent regardless
08:45:59 <ski> (roconnor : to clarify .. i meant before : "just because something can't be implemented in haskell, with a certain efficiency doesn't mean it can't be "purely functional" (i.e. some other language, (maybe with the kind of quotients i was hypothesizing above, or some other things), could possibly implement this .. and also be "purely functional")")
08:46:06 <flux> fasta, wouldn't that exclude lazy evaluation?
08:46:28 <ski> flux : depends on what "change" means here :)
08:46:48 <bringert> joelr1: you are of course free to use whatever version control system you want for your code
08:47:10 <bringert> joelr1: it might make it a little harder for you to pull in any bugfixes that I make though
08:47:26 <LoganCapaldo> flux: if you insert observable before value, does that cover lazy?
08:47:50 <fasta> "Change" means that the value before and after are not Eq when fully evaluated.
08:48:04 <bringert> joelr1: did you get the fix I made yesterday(?) for exiting cleanly on some exceptions?
08:48:06 <flux> I suppose so, but what's wrong with the definition \forall f \forall arg1 \forall arg2: arg1 = arg2 => f(arg1) = f(arg2), or something..
08:48:24 <flux> (I guess that's a circular definition, though ;-))
08:48:41 <joelr1> bringert: nope, haven't pulled yet
08:49:05 <joelr1> bringert: i'll leave it a darcs repo
08:49:15 <chitin> does there exist an IO function that parses double quotation marks (") and returns strings? (I have a file with the format "string","string")
08:49:20 <joelr1> bringert: meaning it's gonna be both :D
08:49:32 <LoganCapaldo> flux: because that can be true and not take into consideration asking for the value of arg1 afterwards
08:49:54 <joelr1> bringert: mercurial is wicked fast, i recommend it
08:49:59 <LoganCapaldo> or a third value arg3
08:50:12 <ski> (flux : what's that supposed to define ?)
08:50:13 <flux> logancapaldo, well the value of arg1 is arg1. I think if that changed, it would be akin to the number 5 changing into number 6
08:50:35 <LoganCapaldo> flux: Couldn't you do that in fortran?
08:51:03 <flux> maybe syntactically
08:51:06 <ski> > read "\"string\"" :: String
08:51:08 <lambdabot>  "string"
08:51:19 <flux> I doubt it can change all instances of 5 into 6 in a single step?
08:51:29 <flux> or, maybe it can, by the magic of indirection
08:51:47 <flux> but even in that the '5' would only be a label to the 'true' value
08:52:11 <chitin> thanks ski
08:52:52 <ski> chitin : you may want to look at 'reads' and 'readIO', too (e.g. in case you want to handle the case with parse-error)
08:52:57 <ski> @type read
08:52:58 <ski> @type reads
08:53:00 <ski> @type readIO
08:53:00 <lambdabot> forall a. (Read a) => String -> a
08:53:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:53:03 <lambdabot> forall a. (Read a) => String -> IO a
08:53:34 <chitin> ski: well I am trying to use readList but Hugs is giving me type errors
08:53:43 <ski> > (reads :: ReadS String) "\"string0\",\"string1\""
08:53:44 <lambdabot>  [("string0",",\"string1\"")]
08:53:58 <ski> > (reads :: ReadS String) "_\"string0\",\"string1\""
08:54:00 <lambdabot>  []
08:54:05 <chessguy> hi all
08:54:07 <ski> (that's a parse error)
08:54:19 <ski> @type readList
08:54:21 <lambdabot> forall a. (Read a) => String -> [([a], String)]
08:54:35 <ski> reads :: Read a => ReadS a
08:54:40 <ski> readList :: Read a => ReadS [a]
08:54:49 <ski> type ReadS a = String -> [(a, String)]
08:54:54 * ski leaves
08:55:03 <chitin> thanks again
08:59:15 * SamB wonders why SamB_at_friends is still here
08:59:31 <tom_> Hi all
08:59:38 <chessguy> hi tom_
09:00:08 <tom_> is there any reason why (,1) isn't valid syntax? By that I mean the (,) operator partially applied on it's right side
09:00:20 <chessguy> @type ((,) l)
09:00:23 <lambdabot> Not in scope: `l'
09:00:28 <emu> > ((,)1)
09:00:28 <chessguy> @type ((,) ?l)
09:00:29 <lambdabot>  Add a type signature
09:00:31 <lambdabot> forall a b. (?l::a) => b -> (a, b)
09:00:42 <emu> the type is uncertain
09:00:50 <SamB> tom_: probably to avoid tuple-parsing headaches for compiler authors?
09:01:04 <tom_> ghci says "<interactive>:1:2: parse error on input `1'"
09:01:11 <emu> that too
09:01:25 <chessguy> you need the parens around the (,)
09:01:43 <LoganCapaldo> wouldn't (,1) be (flip (,) 1) not ((,) 1)?
09:01:43 <Igloo> Two reasons: Confusing errors if it's a typo, and conflict with allowing trailing commas
09:01:48 <SamB> @type (flip (,) 1)
09:01:50 <lambdabot> forall a b. (Num b) => a -> (a, b)
09:01:52 <SamB> LoganCapaldo: quite
09:02:16 <tom_> Ah, trailing commas are allowed in tuples like in python? That explains it then
09:02:27 <Igloo> No, they aren't
09:02:31 <chessguy> well, ok. i was unclear what he wanted
09:02:37 <edwardk>  trailing commas?
09:02:39 <Igloo> But it could cause confusion because that's another thing that might be allowed
09:02:53 <edwardk> weird =)
09:03:04 <Igloo> edwardk: Allowing (a, b, c, ) to mean (a, b, c)
09:03:09 <edwardk> yeah
09:03:13 <edwardk> still weird =)
09:03:20 <Igloo> We have them in module import/export lists (or perhaps any redundant commas are allowed there, I don't recall)
09:03:36 <edwardk> should be a section (a,b,c,) d = (a,b,c,d) =)
09:03:37 <Igloo> It's really handy when you want to be able to comment out random elements
09:03:40 <LoganCapaldo> well you definitely couldn't have tuple sections and optional trailing tupes
09:03:45 <edwardk> ah
09:03:49 <LoganCapaldo> *trailing commas
09:03:55 <Igloo> (more in lists than in tuples)
09:04:41 <LoganCapaldo> definitely. without legal trailing commas in lists you get people writing ugly things like [ 1 \n ,2 \n ,3 ...
09:04:50 <edwardk> yeah
09:05:04 <edwardk> audreyt convinced me to start doing that
09:05:19 <Igloo> But that gives you the same problem with the first element  :-)
09:05:43 <edwardk> took me a while to get used to, though you could argue that also makes diffs cleaner
09:06:25 * shapr waves at edwardk
09:06:31 <edwardk> heya shapr
09:07:03 <shapr> I asked SPJ about the trailing commas idea, he said that GHC used to do that, but it was removed to follow the spec.
09:08:09 <LoganCapaldo> Igloo: catMaybes [ Nothing \n ,Just foo \n ,Just bar ... There. solved! :)
09:08:11 <mdmkolbe|work> Does any one know of a DSEL for describing graph algorithms? (e.g. say I want to do CKY parsing, there should be a 5 line way to express it in terms of nodes and edges (my actual task is much more complicated than CKY but has the same flavor))
09:08:31 <koala_man> what's a decent way to learn haskell if you already know scheme?
09:08:42 <Cheery> @google CKY wikipedia
09:08:44 <lambdabot> http://en.wikipedia.org/wiki/CKY
09:08:45 <lambdabot> Title: CKY - Wikipedia, the free encyclopedia
09:08:53 <Cheery> (just for my own curiosity, not an answer)
09:09:34 <fasta> mdmkolbe|work: until I show my solution to the world, that's an open problem :)
09:09:35 <mauke> koala_man: play around with ghci and read tutorials
09:09:49 <koala_man> any specific tutorials?
09:10:03 <mauke> @where yaht
09:10:03 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:10:12 <chitin> how come map doesn't work on an IO [String]?
09:10:15 <mdmkolbe|work> fasta: might you be able to show it to me?  (otherwise, I'll end up reinventing what you did)
09:10:21 <mauke> chitin: because IO a is not a list
09:10:31 <edwardk> @type map
09:10:33 <Cheery> there's also a 'write scheme in haskell -tutorial'
09:10:39 <chitin> mauke: but sum works on IO [Int]
09:10:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:10:49 <mauke> chitin: no
09:10:54 <Cheery> ups, implement scheme in haskell*
09:10:54 <koala_man> mauke: ok, thanks
09:11:24 <fasta> mdmkolbe|work: It's not like it's an easy thing to show.
09:11:25 <edwardk> @type liftM2 map
09:11:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m [a] -> m [b]
09:11:31 <Cheery> @google write scheme in haskell
09:11:33 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
09:11:33 <lambdabot> Title: Write Yourself a Scheme in 48 hours
09:11:38 <Cheery> :P
09:11:39 <fasta> mdmkolbe|work: It's a few KLOC
09:11:44 <Cheery> my brains google
09:11:50 <chitin> :t readIO
09:11:50 <edwardk> er
09:11:52 <lambdabot> forall a. (Read a) => String -> IO a
09:12:06 <fasta> mdmkolbe|work: I doubt you will reinvent it if it is for "work".
09:12:10 <LoganCapaldo> @ty return . read
09:12:12 <lambdabot> forall b (m :: * -> *). (Monad m, Read b) => String -> m b
09:12:13 <mauke> > let chitin :: IO [Int]; chitin = chitin in  sum chitin
09:12:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO [Int]'
09:12:20 <fasta> mdmkolbe|work: it takes non-trivial amounts of time to understand the real problem.
09:12:34 <LoganCapaldo> @ty readM
09:12:36 <lambdabot> Not in scope: `readM'
09:12:40 <LoganCapaldo> drat
09:13:13 <mdmkolbe|work> fasta: it's actually for both work and hobby
09:13:20 <fasta> http://haskell.org/haskellwiki/OpenProblem <- if you are up for a challenge.
09:13:22 <lambdabot> Title: OpenProblem - HaskellWiki
09:13:36 <LoganCapaldo> Sometimes I wish . had higher precedence than application
09:14:01 <fasta> mdmkolbe|work: the last thing that was published on it was from '97 and can be used for small applications.
09:14:11 <fasta> mdmkolbe|work: google FGL
09:14:44 <olsner> could be fun to experiment with whitespace-sensitive precedence, like f g.h = f (g.h) and f g . h = (f g).h
09:15:11 <mdmkolbe|work> fasta: I plan on looking at FGL later tonight
09:15:28 <fasta> mdmkolbe|work: If you want to have an efficient algorithm don't bother to look
09:15:46 <fasta> mdmkolbe|work: (if you have instances > 100,000)
09:15:56 <fasta> (or even smaller)
09:16:14 <emu> don't you suppose okasaki's work answers that open problem to some extent?
09:16:18 <LoganCapaldo> olsner: stuff like that looks nice, but I always get this niggling doubt when I think about the possibilty of actually having that.
09:16:53 <olsner> yeah, coming up with a heuristic that does the wrong thing seldom enough and works reliably is probably not easy
09:16:57 <mdmkolbe|work> fasta: in this case, efficency isn't that big a concern (as long as the asymtotic complexity can be managed) and at least the prototype only has to work on small problems
09:17:40 <fasta> mdmkolbe|work: the asymptotic complexity is log n or more worse.
09:18:55 <fasta> emu: like how? Before Okasaki people have done much more complicated things
09:19:41 <LoganCapaldo> fasta: I'm not sure I understand what the example problem is asking for, esp. with regards to the use of the word "structure". If the data type is a list, would a "structure" be a cons cell?
09:20:20 <mdmkolbe|work> fasta: the biggest concern is how easy it is to express these algorithms.  some of these algorithms are actively being redesigned.  It's usually simple to state them in English (e.g. CKY) but putting them in code often ends up nasty.  I'm looking for something that makes implementing them as easy as their plain english statements.
09:22:16 <mdmkolbe|work> for example in CKY, one of the steps is: find any contiguous set of parsings with a total length of n that are of kinds that match a known production and apply the production to that set and add it to the test of availible parsing.  When I wrote that in Haksell it was plenty more than 4 lines.
09:22:43 <fasta> LoganCapaldo: a structure can be any value (including function values)
09:23:45 <LoganCapaldo> fasta: I'm still not clear exactly. Was my example relevant or am I totally missing the point?
09:24:34 <fasta> LoganCapaldo: Cons 5 Nil would be a structure
09:24:57 <shapr> dcoutts_: Hey, did you find the state format change stuff about erlang?
09:25:00 <LoganCapaldo> Ok
09:25:08 <dcoutts> shapr: yes
09:25:15 <fasta> LoganCapaldo: but a in data Foo = Foo {bar::a->a}; a= Foo id would also be one.
09:25:29 <LoganCapaldo> fasta: sure
09:25:59 <LoganCapaldo> So a structure is an instance (if I can use the word) of the data type
09:26:11 <fasta> LoganCapaldo: yes
09:26:16 <dcoutts> shapr: erlang "external term format" defined in erts/emulator/internal_doc/erl_ext_dist.txt  in the src distribution.
09:26:22 <LoganCapaldo> fasta: thanks
09:26:54 <shapr> dcoutts: Thanks
09:30:57 <joelr1> where does cabal-install put the haskell packages that it downloads?
09:31:45 <chitin> is there an easy way to go from [(a,b,c)] to [a,b,c]?
09:32:03 <quicksilver> chitin: is that a value or a type?
09:32:07 <LoganCapaldo> chitin: certainly not in general
09:32:16 <quicksilver> chitin: the first looks like a type but the second doesn't....
09:32:19 <chitin> quicksilver: a, b, c are values
09:32:29 <quicksilver> is there definitely only one tuple in the list?
09:32:33 <chitin> yeah
09:32:48 <mauke> foo [(a,b,c)] = [a,b,c]
09:32:50 <quicksilver> > let fun unpack [(a,b,c)] = [a,b,c] in unpack [(1,6,122)]
09:32:51 <lambdabot>   Not in scope: `unpack'
09:32:55 <quicksilver> > let unpack [(a,b,c)] = [a,b,c] in unpack [(1,6,122)]
09:32:57 <mdmkolbe|work> > concatMap (\(a,b,c) -> [(a, b, c)]) [(1, 2, 3), (4, 5, 6)]
09:32:57 <lambdabot>  [1,6,122]
09:32:58 <lambdabot>  [(1,2,3),(4,5,6)]
09:33:09 <mdmkolbe|work> > concatMap (\(a,b,c) -> [a, b, c]) [(1, 2, 3), (4, 5, 6)]
09:33:11 <lambdabot>  [1,2,3,4,5,6]
09:33:15 <LoganCapaldo> > concatMap (\(a,b,c) -> [a,b,c]) [(1,2,3),(4,5,6)]
09:33:17 <lambdabot>  [1,2,3,4,5,6]
09:33:23 <LoganCapaldo> I'm too slow
09:33:29 <mdmkolbe|work> chitin: is that kind of what you're looking for?
09:33:36 <chitin> yeah, thanks all
09:34:13 <quicksilver> > unzip3 [(1,2,3),(4,5,6)]
09:34:15 <lambdabot>  ([1,4],[2,5],[3,6])
09:34:27 <mauke> @djinn [(a,a,a)] -> [a]
09:34:28 <lambdabot> -- f cannot be realized.
09:34:36 <quicksilver> djinn can't do lists, mauke :P
09:34:41 <olsner> > concatMap unzip3 [(1,2,3),(4,5,6)]
09:34:42 <lambdabot>  Couldn't match expected type `[b]'
09:34:59 <LoganCapaldo> olsner: need an uncurry or something in there
09:35:24 <olsner> yeah, I didn't notice that unzip produced a tuple of lists rather than list of lists
09:35:31 <Saizan> how do you intepret [] in the logic?
09:35:56 <LoganCapaldo> > unzip3 [(1, "a", True)] -- it has to use tuples
09:35:57 <lambdabot>  ([1],["a"],[True])
09:35:59 <mauke> @djinn a -> [a]
09:36:00 <lambdabot> -- f cannot be realized.
09:36:00 <mdmkolbe|work> now the real challange is to figure out how to do the reverse
09:37:14 <LoganCapaldo> > let f (x:y:z:zs) = (x,y,z):f zs in  f [1,2,3,4,5,6]
09:37:16 <lambdabot>   Non-exhaustive patterns in function f
09:37:29 <LoganCapaldo> > let f (x:y:z:zs) = (x,y,z):f zs; f [] = [] in  f [1,2,3,4,5,6]
09:37:32 <lambdabot>  [(1,2,3),(4,5,6)]
09:38:26 <mdmkolbe|work> > unfoldr (\x -> case x of a:b:c:xs -> Just ((a, b, c), xs); _ -> Nothing) [1, 2, 3, 4, 5, 6]
09:38:27 <lambdabot>  [(1,2,3),(4,5,6)]
09:38:29 <chitin> how can I do that when there is an unknown number of elements in the tuple?
09:38:40 <mdmkolbe|work> chitin: you can't
09:38:47 <LoganCapaldo> chitin: you can't. theres no such thing as an unknown number of elements tuple
09:39:16 <mdmkolbe|work> chitin: b/c that would mean the type is unknown and Haskell's polymorphism isn't strong enough for that
09:39:18 <LoganCapaldo> Not unless you want to break out the type class foo anyway
09:39:43 <chitin> :t readS
09:39:45 <lambdabot> Not in scope: `readS'
09:39:48 <chitin> :t reads
09:39:50 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:40:02 <joelr1> bringert: ping
09:40:56 <quicksilver> actually you can do it
09:41:01 <quicksilver> but you really, really don't want to
09:42:15 <mdmkolbe|work> @pl \xs -> let f (x:y:z:zs) = (x,y,z):f zs; f [] = [] in  f xs
09:42:16 <lambdabot> (line 1, column 43):
09:42:16 <lambdabot> unexpected "["
09:42:16 <lambdabot> expecting pattern or "="
09:42:42 <LoganCapaldo> mdmkolbe|work: I think you need to use case with pl
09:43:33 <mdmkolbe|work> @pl \xs -> let f a = case a of (x:y:z:zs) -> (x,y,z):f zs; [] -> [] in  f [1,2,3,4,5,6]
09:43:34 <lambdabot> (line 1, column 39):
09:43:34 <lambdabot> unexpected ">"
09:43:34 <lambdabot> expecting variable, "(", operator, ";" or "in"
09:43:51 <LoganCapaldo> squiggly brackects
09:44:02 <mdmkolbe|work> @pl \xs -> let f a = case a of { (x:y:z:zs) -> (x,y,z):f zs; [] -> [] } in  f [1,2,3,4,5,6]
09:44:03 <lambdabot> (line 1, column 28):
09:44:03 <lambdabot> unexpected "{"
09:44:03 <lambdabot> expecting variable, "(", operator, ";" or "in"
09:44:11 <LoganCapaldo> case foo of { bar -> baz; fizz -> quuz }
09:44:23 <LoganCapaldo> so yeah
09:44:27 <LoganCapaldo> I'm outta ideas :)
09:44:37 <dmwit> ?pl f (x:y:z:zs) = (x,y,z):f zs
09:44:41 <lambdabot> f = fix (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . ((.) .)) .
09:44:41 <lambdabot> ) . (((:) .) .) . (,,)))
09:44:41 <lambdabot> optimization suspended, use @pl-resume to continue.
09:45:09 <LoganCapaldo> dmwit: that's quite evil
09:45:10 <dmwit> I don't think you want to use the point-free style on that function.... =P
09:45:23 <mdmkolbe|work> @pl-resume
09:45:24 <shapr> dcoutts: Does erl_ext_dist say something about how to convert from one state version to another?
09:45:28 <lambdabot> f = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . (((.) . (:)
09:45:28 <lambdabot> ) .)) .) . (,,)))
09:45:43 <mdmkolbe|work> there isn't that so much better ;-J
09:46:08 <dmwit> mdmkolbe|work: If you put that in code, you deserve to maintain it. ;-)
09:46:20 <mauke> @. unpl pl f (x:y:z:zs) = (x,y,z):f zs
09:46:24 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 23}: Parse error
09:46:47 <mdmkolbe|work> @unpl fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . (((.) . (:)) .)) .) . (,,)))
09:46:48 <lambdabot> fix (\ bj -> (\ dr -> (\ r -> (\ aq be -> ((:)) (((,,)) (head dr) (head r) (head aq)) (bj be)) >>= \ cp -> tail >>= \ co -> return (cp co)) >>= \ bu -> tail >>= \ bt -> return (bu bt)) >>= \ er ->
09:46:48 <lambdabot> tail >>= \ eq -> return (er eq))
09:47:27 <dmwit> A few more pl/unpl cycles, and you could have a page-long function!
09:48:07 <quicksilver> the main cause of this explosion is that 'pl' sometimes uses specific monad instances (especially ->, but also list) and then @unpl takes them in their general case, not the specific case
09:48:14 <quicksilver> or that's the most painful part IMO
09:48:56 <kpreid> what unpl would need to fix that is:
09:49:16 <kpreid> a type inferrer which annotates the parse tree with the types of its elements
09:49:43 <kpreid> then it could see that a use of >>= is a reader
09:49:46 <dcoutts> shapr: no, that's just an erlang thing, you simply interpret the S-expression differently
09:49:54 <dcoutts> shapr: since in erlang it's untyped.
09:49:57 <SamB> @type fix (\ bj -> (\ dr -> (\ r -> (\ aq be -> ((:)) (((,,)) (head dr) (head r) (head aq)) (bj be)) >>= \ cp -> tail >>= \ co -> return (cp co)) >>= \ bu -> tail >>= \ bt -> return (bu bt)) >>= \ er -> tail >>= \ eq -> return (er eq))
09:49:59 <quicksilver> kpreid: agreed
09:50:06 <lambdabot> forall a. [a] -> [(a, a, a)]
09:50:39 <mdmkolbe|work> @src ap
09:50:40 <lambdabot> ap = liftM2 id
09:50:40 <LoganCapaldo> > runWriter (tell "foo" >> tell "bar") []
09:50:42 <lambdabot>  Couldn't match expected type `[a] -> t'
09:50:55 <LoganCapaldo> > runWriter (tell "foo" >> tell "bar" >> return ()) []
09:50:56 <lambdabot>  Couldn't match expected type `[a] -> t'
09:50:57 <mdmkolbe|work> @src liftM2
09:50:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:51:01 * SamB was just checking to make sure the type hadn't been overgeneralized
09:51:10 <LoganCapaldo> @type runWriter
09:51:11 <mauke> > runWriter (tell ["foo"] >> tell ["bar"]) []
09:51:13 <lambdabot> forall w a. Writer w a -> (a, w)
09:51:13 <lambdabot>  Couldn't match expected type `[a] -> t'
09:51:18 <mdmkolbe|work> @type ap
09:51:19 <mauke> > runWriter (tell ["foo"] >> tell ["bar"])
09:51:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:51:21 <lambdabot>  ((),["foo","bar"])
09:51:26 <quicksilver> SamB: no it hasn't, but some of the transformations that @pl will do if you iterate it, are over-generalised
09:51:31 <quicksilver> SamB: even if the type is not
09:51:33 <LoganCapaldo> mauke: thanks
09:51:43 <quicksilver> SamB: or, that's how it looks to me
09:51:46 <mdmkolbe|work> @type zipWith ($)
09:51:48 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
09:51:57 <SamB> quicksilver: how would the transformation be overgeneralized if the type isn't?
09:51:59 <mauke> LoganCapaldo: remember, Writer always uses mzero
09:52:06 <mauke> that got me a few times
09:52:11 <quicksilver> SamB: because @pl's transformations aren't typed
09:52:13 <LoganCapaldo> ah
09:52:18 <mdmkolbe|work> @unpl let ap = zipWith ($) in fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . (((.) . (:)) .)) .) . (,,)))
09:52:19 <lambdabot> let { ap = zipWith (\ a b -> a b)} in fix (\ bl -> (\ dt -> (\ t -> (\ as bg -> ((:)) (((,,)) (head dt) (head t) (head as)) (bl bg)) >>= \ cr -> tail >>= \ cq -> return (cr cq)) >>= \ bw -> tail >>=
09:52:19 <lambdabot> \ bv -> return (bw bv)) >>= \ et -> tail >>= \ es -> return (et es))
09:52:19 <dmwit> @type ap :: [a -> b] -> [a] -> [b]
09:52:22 <lambdabot> [a -> b] -> [a] -> [b] :: forall a b. [a -> b] -> [a] -> [b]
09:52:38 <quicksilver> SamB: so it might not spot a neat simplificatio in []. because it's working in Monad m
09:52:43 <SamB> I mean, you can't expect unpl to use type info that isn't there
09:52:55 <LoganCapaldo> mauke: So you have to be a MonadPlus to be a Writer? (of course you do, how can you log without mplus?)
09:52:55 <quicksilver> SamB: but the type info *is* there, as you just proved by :t'ing it
09:53:01 <SamB> quicksilver: yeah.
09:53:08 <SamB> thats why I checked ;-)
09:53:11 * quicksilver nods
09:53:36 <mdmkolbe|work> @type fix ((flip (zipWith ($)) tail) . (. head) . flip flip tail . ((zipWith ($)) .) . flip flip head . ((.) .) . flip flip tail . ((flip . ((zipWith ($)) .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip . (((.) . (:)) .)) .) . (,,)))
09:53:38 <lambdabot>     Couldn't match expected type `[a]'
09:53:39 <lambdabot>            against inferred type `[a1] -> [a1]'
09:53:52 <mauke> LoganCapaldo: oops, I'm wrong
09:54:10 <mauke> LoganCapaldo: it's actually mempty/mappend
09:55:28 <LoganCapaldo> @type mappend
09:55:30 <lambdabot> forall a. (Monoid a) => a -> a -> a
09:55:42 <LoganCapaldo> @type mempty
09:55:45 <lambdabot> forall a. (Monoid a) => a
09:55:54 <LoganCapaldo> So you just needs be a Monoid
09:56:34 <mauke> @instances Monoid
09:56:36 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
09:56:37 <LoganCapaldo> Category theory makes all this type class stuff way more interesting than, lets say interfaces in Java
10:05:39 <LoganCapaldo> OMG!
10:05:49 <LoganCapaldo> I just got the Streams thing!!
10:07:17 <LoganCapaldo> list -> stream -> unfoldr means that foldr stream + theorums for free equals simple imperative loop !
10:07:54 <LoganCapaldo> Its not like I read that paper weeks ago or anything :)
10:08:08 * LoganCapaldo does the lambda dance
10:09:42 * kc5tja sings, "That ain't workin' -- that's the way you do it!  Pick up the compil'r, and get your theorems for free."
10:10:21 <hpaste>  sm pasted "instance declaration error" at http://hpaste.org/1797
10:10:33 <sm> morning all.. what's the right way to do that ?
10:11:04 <dmwit> instance (Show f) => Show (Measurement f) where...
10:11:18 <dmwit> Or better
10:11:40 <hpaste>  dmwit annotated "instance declaration error" with "use deriving" at http://hpaste.org/1797#a1
10:12:28 <sm> ohhh.. thank you dmwit!
10:13:56 <LoganCapaldo> deriving maybe the biggest little feature in all of Haskell
10:14:41 <sm> I wanted that in the first place, but must have misspelled
10:16:06 --- mode: irc.freenode.net set +o ChanServ
10:16:21 <tapi> how would you implement an algorithm that looks for a specific file in a directory _and_ all of its subdirectories ?
10:16:44 <dmwit> ls **/filename
10:16:51 <dmhouse> tapi: this homework, by any chance?
10:17:01 <tapi> dmhouse: sorry ?
10:17:01 <mauke> find . -name file
10:17:07 <LoganCapaldo> find dir -name file
10:17:10 <tapi> i mean, in haskell
10:17:23 <eumenides> oooo unfoldTreeM!
10:17:33 <dmhouse> tapi: it sounded like a typical programming class assignment, sorry.
10:17:41 <greenrd> any ideas about how to write a pretty printer that supports precedences with Text.PrettyPrint.Leijen?
10:17:56 <mauke> ReaderT IO
10:17:59 <qwr> @doc System.Directory
10:17:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html
10:18:00 <LoganCapaldo> eumenides: you're scaring people
10:18:03 <dmhouse> (If it had been homework, I'd have directed you to http://haskell.org/haskellwiki/Homework_help).
10:18:04 <lambdabot> Title: Homework help) - HaskellWiki
10:18:24 <greenrd> i.e. I have my pretty-printer (for a non-Haskell "programming language"), but it inserts unnecessary parentheses because it doesn't know about precedence
10:18:47 <dmhouse> tapi: anyway, I'd grab the list of files and subdirectories, see if it's in this directory, and if not, recurse one by one into each of the subdirectories.
10:19:06 <dmwit> eumenides: Wow, that's a nice-looking function.
10:19:12 <greenrd> is there any way I can bolt on precedence support to  Text.PrettyPrint.Leijen, or would I have to redesign it?
10:19:17 <tapi> dmhouse: the problem is that this results in a list of lists of lists...
10:19:30 <dmhouse> tapi: it does? Why?
10:19:52 <tapi> dmhouse: because i don't know how to "unroll" the list
10:19:53 <dmwit> tapi: Use (>>=) from the list monad to do the recursing.
10:20:01 <tapi> hum
10:20:09 <dmhouse> dmwit: you're going to have to do IO, so that's not such good advice.
10:20:12 * dmhouse has to go
10:20:21 <dmwit> mmm
10:20:35 <dmwit> yeah, you're right.
10:20:52 <quicksilver> tapi: 'concat' unrolls lists of lists
10:20:59 <quicksilver> :t concat
10:21:02 <lambdabot> forall a. [[a]] -> [a]
10:21:07 <dmhouse> (I'm not sure he should be getting lists of lists at all.)
10:21:18 <tapi> quicksilver: omg, exactly what i needed, thx :)
10:21:21 <quicksilver> you will something a bit like this
10:21:44 <quicksilver> fileshere ++ concat ( map recurse dirshere )
10:21:59 <tapi> dmhouse: each subdirectory introduces a new list sublevel
10:21:59 <quicksilver> this is such a common pattern that concatMap is a shortcut
10:22:11 <dmwit> ...or (>>=)...
10:22:15 <quicksilver> which saves you a might 4 chars worth of type, or seomthing
10:22:24 <tapi> quicksilver: thanks a lot ;)
10:22:25 <dmwit> fileshere ++ (dirshere >>= recurse)
10:22:57 <quicksilver> I fear you will be back in 10 minutes with an IO-lreated problem, but that's OK :)
10:22:59 <dmwit> But again, that doesn't really play well with IO, does it?
10:23:02 <quicksilver> you're down the right path at least
10:23:44 <quicksilver> dmwit: depends on the types, doesn't it?
10:23:54 <greenrd> I am excited about ShowS-style, which reduces the number of concatenations when you're recursing down a tree and building a list
10:24:04 <quicksilver> dmwit: you can imagine a version which produces a [IO String]
10:24:06 <greenrd> but ShowS-style is an optimisation - bit much for a beginner
10:24:07 <dmwit> quicksilver: Not too much.  The problem is he'll need a mapM instead of a map.
10:24:13 <quicksilver> dmwit: and then you just add one sequence at the end
10:24:27 <dmwit> mmm...
10:24:28 <dmwit> maybe
10:24:40 <quicksilver> more than one way to do it :)
10:24:46 <quicksilver> let's allow tapi to find out what happens with his way
10:25:09 <tapi> ^^
10:26:07 <tapi> all i want to do is to recursively search into a directory to get a list of files ending in ".pid"
10:27:39 <tapi> and this is the most tricky thing i've had to do for now
10:29:27 <dmwit> ?where filepath
10:29:28 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
10:30:06 * mdmkolbe|work starts thinking about that problem, but preditcs it can be done in less than 100 (key) strokes (of golf)
10:30:42 <LoganCapaldo> "GHC 6.6.1 onwards will be shipped with all major compilers" does this mean that type FilePath != String anymore?
10:30:57 <dmwit> ?info FilePath
10:30:57 <lambdabot> FilePath
10:31:16 <dmwit> :t "hi there!" :: FilePath
10:31:22 <Igloo> LoganCapaldo: No
10:31:25 <lambdabot> FilePath :: FilePath
10:31:40 <dmwit> It seems like FilePath = String still.
10:31:43 <LoganCapaldo> Igloo: ok
10:31:53 <LoganCapaldo> @version
10:31:54 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
10:31:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:32:07 <LoganCapaldo> She's not 6.6.1 one yet though
10:32:13 <LoganCapaldo> is she?
10:32:14 <dmwit> Oh, I see.
10:32:40 <LoganCapaldo> Doens't matter cause Igloo already answered the question :)
10:32:47 <emu> says type FilePath = String in 6.6.1
10:45:51 <joelr1> what does this mean? Hope/Module/Haskell.hs:27:29: Not in scope: `CSS.hscolourFragment'
10:45:51 <joelr1> the file has "import Language.Haskell.HsColour.CSS as CSS"
10:45:51 <emu> mispelled?
10:45:51 <kc5tja> Case is sensitive in Haskell symbol names.
10:45:51 <kc5tja> That might be an issue too.
10:45:51 <hpaste>  chitin pasted "Need some help with IO" at http://hpaste.org/1798
10:45:51 <Saizan> different version of hscolour i think
10:45:51 <Saizan> _darcs/inventory: Note that the library API has changed: hscolourFragment (for CSS and
10:45:51 <tapi> this looks like what i'm looking for : http://darcs.serpentine.com/filemanip/dist/doc/html/FileManip/System-FilePath-Find.html
10:45:51 <Saizan> _darcs/inventory- LaTeX) has been removed, since hscolour now takes a boolean argument
10:45:51 <lambdabot> http://tinyurl.com/yvdaw5
10:45:51 <Saizan> _darcs/inventory- indicating partiality of the output.
10:45:51 <Saizan> grepping the repo
10:45:51 <emu> > read "[\"A\"]" :: [String]
10:45:51 <eumenides> > words "word1 word2 word3 word4"
10:45:51 <lambdabot>  ["A"]
10:45:51 <lambdabot>  ["word1","word2","word3","word4"]
10:45:51 <emu> > read "[\"A\",\"B\"]" :: [String]
10:45:51 <lambdabot>  ["A","B"]
10:45:51 <chitin> hmm
10:45:51 <emu> how about: readFile "words.txt" >>= (read :: String -> [String])
10:45:51 <emu> er
10:45:51 <LoganCapaldo> read $ (("[" ++) . (++ "]")) file
10:45:51 <emu> gotta add "
10:45:51 <emu> yea what he did
10:45:51 <dmwit> liftM words $ readFile "words.txt" -- why not this?
10:45:51 <joelr1> Saizan: hmm... i tried to do a pull from the hscolor directory but didn't get any changes
10:45:51 <eumenides> dmwit: commas
10:45:51 <emu> dmwit: because it is comma sep
10:45:51 <dmwit> oh
10:45:51 <quicksilver> tapi: yes, it is, although you can do with the stnadard library too
10:45:51 <quicksilver> tapi: System.Directory should be enough
10:45:51 <Saizan> joelr1: i think your Home.Module.Haskell was intended for an earlier version of hscolour, so pulling won't help
10:45:51 <shapr> dcoutts: Any ideas for how to handle state format changes in serialization?
10:45:51 <tapi> quicksilver: what do you think would be the simplest for a beginner like me ?
10:45:51 <hpaste>  emu annotated "Need some help with IO" with "(no title)" at http://hpaste.org/1798#a1
10:45:51 <quicksilver> tapi: well, I'd think installing a  new library is a bit of a hssle
10:45:51 <quicksilver> tapi: so I'd go with System.Directory
10:45:51 <joelr1> Saizan: i did a pull and didn't get any changes either :-(
10:45:51 <shapr> dcoutts: Right now HAppS has something like ("1",state format one),("2",state format two)
10:45:51 <joelr1> Saizan: i mean, no changes in the hope dir. i guess i need to rollback changes to hscolor
10:45:51 <Saizan> or patch hope :)
10:45:51 <mdmkolbe|work> tapi: I'll have a solution for you in a bit
10:45:51 <joelr1> Saizan: i think bringert has left for the weeked
10:45:51 <tapi> mdmkolbe|work: great :)
10:45:51 <chitin> emu: thank you so much, works great ;)
10:45:51 <tapi> quicksilver: the biggest problem for me is to deal with the IO monad thing, i'm not really friendly with monads...
10:46:01 <mdmkolbe|work> tapi: do you want a solution with System.FilePath or without?
10:46:25 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1799
10:46:47 <tapi> mdmkolbe|work: a solution with System.directory interets me much ^^
10:46:51 <tapi> ...
10:47:04 <tapi> well, you understand :P
10:48:25 <joelr1> Saizan: any suggestions on how to fix that bit in Hope?
10:48:51 <hpaste>  mdmkolbe|work pasted "Find solution" at http://hpaste.org/1800
10:49:50 <mdmkolbe|work> tapi: there it is.  If you don't have System.FilePath installed, you can use "x </> y = x ++ "/" ++ y" to fake it
10:50:22 <tapi> hum ok
10:50:29 <mdmkolbe|work> tapi: also you have to provide a function that returns true, only when the argument is the kind of file name you are looking for
10:51:18 <mdmkolbe|work> > and (zipWith (==) (reverse ".pid") (reverse "myfile.pid")
10:51:19 <lambdabot>  Parse error
10:51:24 <mdmkolbe|work> > and (zipWith (==) (reverse ".pid") (reverse "myfile.pid"))
10:51:32 <lambdabot>  True
10:51:34 <mdmkolbe|work> > and (zipWith (==) (reverse ".pid") (reverse "myfile.exe"))
10:51:35 <lambdabot>  False
10:51:40 <LoganCapaldo> mdmkolbe|work: isSuffixOf ?
10:51:50 <mdmkolbe|work> @type isSuffixOf
10:51:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
10:51:59 <mdmkolbe|work> LoganCapaldo: yeah, I guess
10:52:09 <mdmkolbe|work> LoganCapaldo: what module is that in?
10:52:10 <sm> what's the easiest way to do something like: map print somelist, and print each element on a new line ?
10:52:13 <LoganCapaldo> > ".pid" `isSuffixOf` "myfile.pid"
10:52:14 <lambdabot>  True
10:52:15 <tapi> hum...
10:52:24 <LoganCapaldo> @index isSuffixOf
10:52:25 <lambdabot> Data.List
10:52:46 <kpreid> @src isSuffixOf
10:52:47 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
10:52:50 <dmhouse> LoganCapaldo: you should use the filepath package for that kind of thing.
10:52:57 * sm is getting hung up on print $ (intersperse "\n" $ map show somelist)
10:52:58 <kpreid> @src isPrefixOf
10:52:59 <lambdabot> isPrefixOf [] _          = True
10:52:59 <lambdabot> isPrefixOf _  []         = False
10:52:59 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
10:53:00 <dmhouse> sm: mapM_ print somelist
10:53:06 <sm> yeah! thanks
10:53:11 <mdmkolbe|work> sm: mapM_ putStrLn somelist
10:53:30 <LoganCapaldo> dmhouse: I'm not doing it at all. Did you see what mdmkolbe|work was using? :)
10:53:31 <sm> ah! that too
10:54:06 <dmhouse> sm: if the mapping function does IO, you nearly always want mapM_. There is also a mapM which is similar. mapM_ won't return the results of the function, the function is just called on each element for its side-effects, whereas mapM will return the results.
10:54:27 <JohGro> Hi, I build arrays from lists using a list comprehension as suggested in ghc documentation. I would instead like to avoid allocating the intermediate list by creating an array from the bounds and a function fom indices to values. I would like a function of type (Ix ix) => (ix,ix) -> (ix -> e) -> Array i e to generate this array.
10:54:42 <dmhouse> So if you did s <- mapM print [1, 2, 3], s would be [(), (), ()], not very useful, you might as well use mapM_ here.
10:55:05 <LoganCapaldo> JohGro: you could use unfoldr
10:55:11 <dmhouse> JohGro: have you checked the Haddock documentation for Data.Array?
10:55:20 <dmhouse> I'm pretty sure there's a function that does that.
10:55:22 <mdmkolbe|work> @docs Data.Array
10:55:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
10:55:41 <dmhouse> (Although the intermediate list would probably get deforested anyway.)
10:56:11 <mdmkolbe|work> dmhouse: odd, it doesn't look like Data.Array has a function for that
10:56:48 <mdmkolbe|work> oh, wait.  JohGro, I think you want accumArray
10:57:09 <kpreid> @type accumArray
10:57:11 <mdmkolbe|work> oh, wait again.  No you don't want accumArray
10:57:11 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
10:57:55 <sjanssen> JonGro: GHC most likely optimizes out the intermediate list
10:58:04 <dmhouse> JohGro: okay, there isn't a function that does it. :) I wouldn't worry about it. Is there a particular reason you'd like to avoid the list, or is it just for neatness?
10:58:11 <sjanssen> JonGro: look for "list deforestation" in the user's manual
10:58:18 <tapi> mdmkolbe|work: it seems to work perfectly, thx a lot :)
10:58:32 <JohGro> I thought aAccumArray does not perform anything new, but only deals with repeated indices in a more flexible way.
10:59:06 <JohGro> I do not know how to know if the list is deforestated. I can only see that the function performs most of my programs allocation.
10:59:34 <kpreid> JohGro: are you telling ghc to optimize?
10:59:37 <mdmkolbe|work> tapi: it does have a bug though.  it won't return any directories. (excersize left to reader)
10:59:40 <sjanssen> JonGro: for example, listArray (n, m) . map f $ [n .. m] -- will produce no lists if 'n' is the right type (Int or Integer, will work, for example)
11:00:05 <mdmkolbe|work> JohGro: I was wrong about accumArray, I was miss-reading the type
11:00:12 <tapi> mdmkolbe|work: that's exactly what i need ;)
11:00:32 <sm> dmhouse: thanks
11:00:36 <dmhouse> Anyone know of any SMTP libraries with STARTTLS support?
11:00:40 <joelr1> what is the -Wall-less-warnings-about-type-signatures flag?
11:00:54 <JohGro> sjanssen: Is tehre a good way to cinfirm if this happens in a program.
11:00:57 <dmhouse> joelr1: my guess is all warnings except those about type signatures?
11:01:11 <joelr1> dmhouse: yes, but what's the incarnation?
11:01:16 <dmhouse> joelr1: which could be stuff like "Warning: definition but no type signature for blah"
11:01:31 <joelr1> dmhouse: i want all warnings but the ones you are mentioning above
11:01:48 <dmhouse> joelr1: oh, I see what you mean. I dunno.
11:01:58 <mdmkolbe|work> dmhouse: wouldn't that be redundant if you can say "-Wall -Wno-warn-type-signature"?  (I hope you can say that)
11:02:51 <dmhouse> I have no idea.
11:03:16 <sjanssen> JonGro: you can look at the core with -ddump-simpl -- but it's a bit difficult to read
11:03:20 <JohGro> kpreid: The program is a factor fo 3 faster using -O2, so that might do deforestation. I do not know how to know that
11:03:38 <sjanssen> JonGro: you can also look at the output of -ddump-simpl-stats to see which RULES fire
11:04:35 <tapi> mdmkolbe|work: add a little "try" not to raise an exception when trying to get the contents of a directory without permissions, and that's perfect
11:04:38 <tapi> mdmkolbe|work: again, thanks a lot
11:04:48 <tapi> i added*
11:05:29 <JohGro> sjanssen: I tried it and it "fires" the rules unpack (2) and unpack-list (1). Are they the ones I want?
11:07:03 <ed1t> let insert x [] = x; insert x (y:ys) = if x < y then insert x ys else
11:07:16 <ed1t> im trying to insert an int in right place
11:07:27 <ed1t> assuming list is already sorted
11:07:47 <ed1t> how can i write like x:(y:ys)
11:08:54 <quicksilver> ed1t: in your first case you want insert x [] = [x]
11:09:04 <ed1t> ooo
11:09:34 <dmhouse> ed1t: there's something wrong with the 'then' bit of your if statement, too.
11:10:26 <dmhouse> ... it's a bit hard to think of a hint, so I'll just tell you: you need "if x < y then y : insert x ys else ..."
11:10:28 <ed1t> damn i did it inversely
11:10:35 <ed1t> yea
11:10:40 <ed1t> i just realized it
11:10:52 <dmhouse> Now for the else bits, what you wrote will pretty much work but I think you've got it the x and y the wrong way around.
11:11:46 <beelsebob> dmhouse: o.O the x and y look the right way round to me
11:12:01 <JohGro> sjanssen: -ddump-dimpl looks wierd. I used ti with -pro -auto-all and then I can see where the cost centers are inserted and identify my functions. Something is different between default and using -O2, and it seems to me that it may include a deforestation.
11:12:24 <JohGro> sjanssen: sorry. with -prof -auto-all
11:12:29 <dmhouse> beelsebob: it's sorted lowest to highest, and we know x > y, so x should go after y.
11:12:42 <sjanssen> JonGro: yes, reading core is a dark art :)
11:13:16 <beelsebob> dmhouse: but x<y in the condition implies we're sorting highest to lowest, not lowest to highest
11:13:35 <JohGro> sjanssen: the unoptimized includes  ds_d1K9 :: [ix_a12y] -> [(ix_a12y, val_a12z)] which it seems to me may create a list, whereas the optimized does not.
11:13:54 <sjanssen> JonGro: I'd say that is a good sign
11:14:01 <JohGro> sjanssen: Thanks for the tip. I willassume that deforestation is done.
11:14:17 <dmhouse> beelsebob: oh, sorry, my thinking was backwards.
11:14:19 <ed1t> it just adds in the front
11:14:32 <desp> http://venturebeat.com/2007/05/10/live-ink-offers-better-way-to-read-text-online
11:14:33 <beelsebob> dmhouse: hehe, I took a while to think about it too
11:14:36 <lambdabot> Title: VentureBeat  Live Ink offers better way to read text online, http://tinyurl.com/27qms7
11:14:43 <sjanssen> JonGro: core for -O0 and -O will almost always be radically different -- ghc produces pretty dumb code for -O0
11:15:19 <desp> click at the before/after image.  anyone else gets reminded of C/Java vs Lisp/Haskell? ;)
11:15:21 <mdmkolbe|work> reading GHC core is a bit like reading a real core file.
11:15:32 <mdmkolbe|work> i.e. it needs patience
11:15:34 <desp> s/at/on/
11:15:35 <sjanssen> JonGro: did you see the list of good producers/consumers in the user's manual?
11:15:40 <sm> for data Value = ACCURACY Float | RMSE Float | ROC Float , how would I write a fn like same_constructor (c _) (c' _) = c==c' ?
11:15:53 <ed1t>  let insert x [] = [x]; insert x (y:ys) = if x > y then y : insert x ys else x:(y:ys)
11:15:55 <ed1t> this works
11:16:09 <sm> (to test two Values are of the same.. type ?)
11:16:26 <dmhouse> ed1t: great :) By the way, you can just write x:y:ys, no need for those parentheses.
11:16:34 <ed1t> oo k
11:16:35 <ed1t> thx
11:16:56 <ed1t> haskell is great!
11:17:02 <shapr> yay!
11:17:04 <dmhouse> sm: you'd have to do it the long way:
11:17:21 <ed1t> 1 line compared to 10 lines in java
11:17:28 <shapr> ed1t: It gets better!
11:17:29 <dmhouse> fn (ACCURACY _) (ACCURACY _) = True; fn (ACCURACY _) _ = False; ... repeat for the othe constructors
11:17:30 <JohGro> sjanssen: No, I do not know what good consumers/producers refere to.
11:18:06 <sm> dmhouse: ok, I see
11:18:09 <dmhouse> sm: and 'type' isn't correct here, the two arguments both have type Value. You mean 'have the same constructor' or something.
11:18:37 <sm> right.. I just noticed as I was typing that maybe I should be using separate types
11:18:48 <sjanssen> JonGro: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3159016
11:18:50 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
11:18:54 <dmhouse> sm, be careful, that might make things trickier.
11:18:59 <sm> yes indeed
11:19:05 <mdmkolbe|work> desp: what is amazing is how well it worked for me.  in their example I could read the right about 4x faster than the left.  (Ok, so no publisher would have formatted the left like that (b/c the farmatting was hard to read) and I read the right one second so I knew what to expect, but still)
11:19:40 <dmhouse> sm, i.e. you wouldn't be able to put two of those Values in a list together.
11:19:47 <dmhouse> (If they were seperate types.)
11:19:48 <JohGro> sjanssen: thanks!
11:20:24 <sm> exactly, which would (probably) be a pain.. so it feels like I'm doing a sort of "soft typing" here instead
11:21:01 <dmwit> sm: But you could still make a tuple with them, if you knew the exact number/order of them at compile time.
11:21:14 <desp> mdmkolbe|work: here's a much better article about this: http://www.readingonline.org/articles/art_index.asp?HREF=/articles/r_walker/
11:21:17 <lambdabot> Title: Reading Online, http://tinyurl.com/279r69
11:21:18 <dmwit> In (many) cases, that's what you want anyway.
11:21:37 <dmhouse> sm, depends what you'll be using them for.
11:21:44 * Cale wonders what people here think about the whole "definition of closure" issue. I've been arguing with pjdelport on reddit for a few days now.
11:22:06 <dmhouse> Cale: what are the main camps?
11:22:29 <Cale> He seems to think that for something to be a closure, the set of environment bindings *must* be those of some lexically-defined scope.
11:22:40 <sm> one bad sign is I seem to be hardcoding these three value constructors/soft types all over the place, and new ones might be added
11:22:55 <sm> ah never mind.. YAGNI
11:23:00 <Cale> Whereas I'm saying that a closure is just a pair consisting of some code with free variables and an arbitrary environment.
11:23:27 <Cale> (which binds those free variables to values)
11:24:22 <dmwit> sm: It's possible that you should examine your architecture and redesign a little.
11:24:27 <dmwit> sm: How are you using these things?
11:24:38 <Apocalisp> Is there a generic precise number type? One that includes only (and both) ratios and roots?
11:25:23 <Cale> Apocalisp: no, but I suppose you could invent an algebraic number type
11:25:31 <Cale> That is a good idea actually.
11:25:59 <sm> well, right now I'm parsing csv records with these three values in each row: data CsvRecord = CsvRecord {acc::Float, rms::Float, roc::Float }
11:26:17 <CosmicRay> sm: fyi, MissingH has a CSV parser
11:26:20 <sm> into a list of Result {r_dataset::Dataset, r_method::Method, r_value::Value}
11:26:20 <shapr> desp: It's interesting that text reformatting you linked to looks much like significant whitespace in Haskell / Python.
11:26:25 <shapr> hiya CosmicRay!
11:26:26 <sm> CosmicRay: thanks! I found it
11:26:30 <Cale> Operations and simplification of algebraic numbers are tricky though.
11:26:31 <CosmicRay> hey shapr!
11:26:34 <mdmkolbe|work> desp: yeah, I was looking at that.  (Some of their stats seem suspicous though, I'd like to see them publish in an actual journal.)  There may be some ideas in there that apply to formatting styles for code, but I'm not sure b/c the goals for prose and code are so different.
11:26:39 <dmwit> sm: Yeah, you probably want a tuple with three values rather than a data type with three constructors.
11:27:03 <tom__> does anyone know anything about ByteStrings and the garbage collector?
11:27:10 <dmhouse> dmwit: won't really help one way or the other if you wish to add extra fields
11:27:19 <bos> tom__: a bit, yes.
11:27:20 <sjanssen> tom__: what about them?
11:27:32 <Cale> dmhouse: Basically, I'm saying that it's silly to identify 'closure' with 'function capturing lexically bound variables'
11:27:35 <dmwit> dmhouse: False.  It helps a lot!  You don't have to add things to any of the instances you make, for example.
11:27:36 <desp> shapr: that's exactly what I said before :)
11:27:41 <sm> dmwit: but I want to break the data up by acc/rmse/roc and analyze each set of results separately
11:27:47 <tom__> If I split up a big ByteString using splitAt will a reference to one of the returned parts keep the whole thing from being collected?
11:27:49 <shapr> desp: Ah, I missed that.
11:27:55 <tom__> or is it smarter than that?
11:27:58 <dmwit> sm: Yes, you have the right idea with using records
11:28:00 <sjanssen> tom__: yes
11:28:00 <dmwit> .
11:28:01 <bos> tom__: yes
11:28:03 <Cale> Because closures are just an implementation mechanism for that. (at least, as I see it)
11:28:12 <Apocalisp> Hmm. Ratio only allows Integrals. I also want ratios between roots. Do you know of an algebraic number type like that, already constructed in a library?
11:28:17 <quicksilver> tom__: this is why you use lazy bytestings
11:28:19 <dmhouse> dmwit: you'd have to change every single function that uses them to change an n-tuple into an (n+1)-tuple.
11:28:20 <dmwit> (Records are just tuples behind the scenes.)
11:28:23 <tom__> thanks
11:28:25 <quicksilver> tom__: se each chunk can be separately gced
11:28:26 <desp> shapr: although I had primarily Lisp in mind
11:28:37 <sm> that's a good insight
11:28:45 <Cale> Apocalisp: no, but I think it's something well worth writing.
11:28:49 <bos> tom__: iow, if you read in 1 MByte of strict bytestring, and keep 1 byte, the whole MByte lives on even if you don't explicitly refer to it. lazy bytestrings retain only max 64KB chunks.
11:28:55 <Cale> Apocalisp: actually, I'm not sure, there might already be one
11:28:59 <Apocalisp> Drat.
11:29:01 <dmwit> dmhouse: Or alternatively make accessor functions, in which case you need to change only one.
11:29:08 <desp> and I think the reason is obvious -- they're reformatting the text to make the hierarchy of language units explicitly visible
11:29:11 <Apocalisp> I suppose I'll get cracking then!
11:29:19 <dmwit> dmhouse: (Or change n+1 functions to move from an n-tuple to an n+1-tuple.)
11:29:25 <desp> and good Lisp formatting is exactly that
11:29:28 <dmwit> dmhouse: Which is essentially what records do.
11:29:32 <tom__> That sounds like what I want, what are the disadvantages of lazy bytestrings?
11:29:36 <dmhouse> dmwit: assuming you don't use the plain pattern anywhere.
11:29:43 <dmwit> right
11:29:47 <bos> tom__: lazy bytestrings are a bit slower for very small strings.
11:29:51 <shapr> desp: It's also interesting that they use syntax highlighting. I've found that my speed of comprehension is very fast for painfully obvious color schemes like http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html , but that may be related to my ADHD diagnosis.
11:29:53 <lambdabot> Title: Test_TutorRing.hs
11:29:58 <dmwit> Anyway, it's better than having three constructors.
11:30:24 <desp> shapr: ouch, that's painful all right :)
11:31:10 <desp> looks like classic Amiga formatting?
11:31:12 <shapr> desp: It works extremely well for me though. I can't ignore flashing lights (or cute blondes) in my peripheral vision, so I figured I'd try to exploit that as a good point.
11:31:26 <dmhouse> shapr: I can't see anything but the highlighted bits.
11:31:28 <Cale> Apocalisp: Having an implementation of something like Mathematica's Root objects would be very very nice.
11:31:31 <desp> I prefer not being startled by my source code, thankyouverymuch
11:31:55 <desp> shapr: here's what I use: http://desp.night.pl/tmp/glow.png
11:32:56 <shapr> desp: I'd have a lot of trouble with that. Right now I'm using the infodoc emacs color theme, but I also use sandalwood that I got from the author of misty day.
11:32:57 <mdmkolbe|work> desp, shapr: I notice the main difference is whether the background color changes often.  For some reason background color changes seem very jarring to me
11:33:01 <Eelis> shapr: i hope you haven't given up on withResource ;)
11:33:25 <shapr> Eelis: I haven't I've just been busier than I expected.
11:33:35 <Eelis> alright
11:33:43 <dmhouse> Gah, it seems HaskellNet.SMTP doesn't support STARTTLS, so I can't connect to Gmail.
11:34:35 <shapr> dmhouse: Have you tried the infodoc color-theme?
11:34:39 <shapr> I can upload sandalwood.
11:34:53 <tom__> Will I have any problems interspersing calls to hGet from ByteString with calls to hGet from IO? Sometimes it makes more sense to read a String and sometimes a ByteString
11:35:17 <sm> hmm, I think it's about to stop and eat breakfast.. just one more q - how to print a 3d list nicely, one item per line ?
11:35:22 <dmhouse> shapr: I use a heavily customised colour theme. Can I see a screenshot of infodoc anywhere?
11:35:47 <sm> I want an n-dimensional map
11:36:08 <shapr> dmhouse: Why not save it as a color theme and then I can try it out?
11:36:45 <dmhouse> shapr: how do I do that? Just mail you my (custom-set-faces) call?
11:37:04 <shapr> dmhouse: Nah, install color-theme and color-theme-maker. It files out the calls for you.
11:37:20 <shapr> But make sure to backup your custom.el or whatever that file is called.
11:38:31 <dmhouse> shapr: http://download.gna.org/color-theme/ that one?
11:38:33 <lambdabot> Title: Index of /color-theme
11:38:44 <shapr> I dunno, I always get it from emacswiki.org
11:38:53 <dmhouse> That was linked to from emacswiki.
11:39:57 <Cale> Apocalisp: http://algo.inria.fr/flajolet/Publications/BoFlSaSc02.pdf looks interesting in this regard.
11:40:01 <shapr> Then that's probably the place.
11:40:13 <Apocalisp> let's see
11:40:56 <dmhouse> shapr: right, give me a while to read through this all.
11:42:17 <sm> woohoo! mapM_ (mapM_ (mapM_ print)) dat
11:44:33 <LoganCapaldo> @type fix mapM_ print
11:44:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:44:36 <lambdabot>       Expected type: (a -> m b) -> a -> m b
11:44:41 <LoganCapaldo> ah well
11:45:05 <dmhouse> shapr: ah, infodoc is pretty horrendously ugly.
11:46:06 <LoganCapaldo> @pl mapM_ (mapM_ (mapM_ print))
11:46:07 <lambdabot> mapM_ (mapM_ (mapM_ print))
11:46:11 <LoganCapaldo> no!
11:46:14 <kc5tja> Wow.  I found another person here at Google who digs Haskell.  Spread the virus!
11:46:16 <LoganCapaldo> shorter version!
11:47:20 <LoganCapaldo> > @type mapM_ $ ap mapM_ (mapM_) print
11:47:21 <lambdabot>  Parse error
11:47:37 <LoganCapaldo> @type mapM_ $ ap mapM_ mapM_ print
11:47:40 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
11:47:40 <lambdabot>       Expected type: (a1 -> a -> b1) -> [a1] -> a -> m b
11:47:51 <LoganCapaldo> wait that's not what I meant
11:48:19 <Apocalisp> Cale: Interesting paper, but goes well beyond what I want to do.
11:48:56 <LoganCapaldo> @typelet dot3 f = f . f . f in dot3 mapM_ print
11:48:57 <lambdabot> Unknown command, try @list
11:49:04 <LoganCapaldo> @type let dot3 f = f . f . f in dot3 mapM_ print
11:49:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:49:06 <lambdabot>       Expected type: (a -> m b) -> a -> m b
11:49:22 <LoganCapaldo> @type let dot3 f = f . (f . f) in dot3 mapM_ print
11:49:23 <Cale> Apocalisp: would you be happy with just representing nth roots abstractly? You can construct expression types and make them instances of Num.
11:49:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:49:25 <lambdabot>       Expected type: (a -> m b) -> a -> m b
11:49:31 <LoganCapaldo> boooo
11:49:39 <hpaste>  dmhouse pasted "My Emacs colour scheme" at http://hpaste.org/1801
11:49:44 <dmhouse> shapr: ^^
11:49:51 <Cale> Apocalisp: I'd sort of figured that if you want nth roots, you probably want all algebraic numbers.
11:50:10 <LoganCapaldo> @type let dot3 f x = f (f (f x)) in dot3 mapM_ print
11:50:12 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:50:13 <lambdabot>       Expected type: (a -> m b) -> a -> m b
11:50:13 <Apocalisp> Cale: I guess it's a slippery slope!
11:50:48 <Cale> It would be extremely nice to have algebraic numbers in the Prelude :)
11:50:53 <LoganCapaldo> @type mapM_ (mapM_ (mapM_ print))
11:50:55 <lambdabot> forall a. (Show a) => [[[a]]] -> IO ()
11:51:09 <LoganCapaldo> I must be missing something
11:51:58 <LoganCapaldo> @type let dot3 f x = f (f (f x)) in dot3 mapM_ print :: [[[a]]] -> IO ()
11:52:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
11:52:01 <lambdabot>       Expected type: (a -> m b) -> a -> m b
11:52:06 <LoganCapaldo> avast
11:52:08 <LoganCapaldo> @arr
11:52:09 <lambdabot> Yo ho ho, and a bottle of rum!
11:52:18 <LoganCapaldo> I give up
11:54:55 <shapr> dmhouse: I think it got cut off.
11:55:18 <dmhouse> shapr: ooh, looks like it.
11:55:24 <sm> > groupBy (==) [1,2,1]
11:55:26 <lambdabot>  [[1],[2],[1]]
11:55:32 <sm> why is that ?
11:55:43 <dmhouse> sm: it doesn't sort first.
11:55:46 <shapr> > groupBy (==) [1,1,2,1]
11:55:48 <sm> ohh!
11:55:48 <lambdabot>  [[1,1],[2],[1]]
11:55:55 <Apocalisp> Cale: To start with I could define a Num instance of the form Pow Ratio Ratio.
11:56:28 <thetallguy> sm: works just like shell uniq and sort
11:57:10 <LoganCapaldo> and the reason it doesn't sort first is...
11:57:21 <LoganCapaldo> @type groupBy
11:57:23 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:57:48 <LoganCapaldo> @type groupBy (==)
11:57:50 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
11:57:55 <LoganCapaldo> @type sort
11:57:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:58:22 <dmhouse> shapr: http://pastebin.ca/483435
11:58:53 <sm> hmm perhaps I want sortUnique from http://www.haskell.org/haskellwiki/Reference_card
11:58:55 <lambdabot> Title: Reference card - HaskellWiki
11:59:23 <dmhouse> sm: what do you want it to do?
11:59:43 <LoganCapaldo> > group .sort  $ [1,2,1]
11:59:44 <lambdabot>  [[1,1],[2]]
11:59:47 <Apocalisp> No, that doesn't give me 1%(sqrt 2)
12:00:03 <sm> what LoganCapaldo said, except I'll need a custom sortBy
12:00:09 <LoganCapaldo> > map head . group . sort  $ [1,2,1]
12:00:11 <lambdabot>  [1,2]
12:00:11 <sm> I wondered if the snippet on the wiki does that
12:00:22 <dmhouse> > nub [1, 2, 1]
12:00:24 <lambdabot>  [1,2]
12:00:38 <LoganCapaldo> @ty nubBy
12:00:40 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
12:00:41 <liber> excuse me.. But is "spinAscii" invalid as a function name? When I change the name, it works fine..
12:01:11 <kpreid> liber: it is not
12:01:59 <liber> kpreid: than why does the function work when I change the name from "spinAscii" to "inRange"? (wait. ill paste)
12:02:06 <liber> It is all very confusing
12:03:11 <liber> dang. Now it works.. I somehow managed to make a fool of myself again! :)
12:04:18 <sm> ah, now here's an issue with my 3-constructor Value type.. to group results by their Value type, I need to sort on the Value constructor
12:04:32 <sm> is that a reasonable thing to do, or nuts ?
12:04:44 <LoganCapaldo> sm: if you only have one constructor...
12:04:46 <dmhouse> Seems reasonable.
12:04:52 <LoganCapaldo>  think you can just deriving Ord
12:04:52 <dmhouse> LoganCapaldo: he has three.
12:04:57 <LoganCapaldo> oh
12:05:17 <sm> I have data Value = ACCURACY Float | RMSE Float | ROC Float deriving (Show, Eq, Ord) .. hmm that'll do, won't it
12:05:56 <sm> I believe Values will sort first by constructor, then by the float, automatically
12:06:37 <yango> hi, is this the best for a total beginner who just grabbed a copy of hugs and is trying to enter his "Hello World"?
12:06:43 <yango> http://www.haskell.org/tutorial/goodies.html <== this
12:06:44 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
12:07:30 <sjanssen> yango: have you done functional programming before?
12:07:31 <dmhouse> yango: no.
12:07:34 <liber> yango: no
12:07:48 <dmhouse> yango: what's your programming background?
12:07:53 <liber> yango: I found the wikibook quite nice (recently started)
12:08:13 <sjanssen> @quote stereo
12:08:14 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:08:36 <yango> sjanssen: a bit of scheme a few years ago. Quite versed in non functional programming langs (C, Java, Python, Perl, and a few others)
12:09:00 <dmhouse> yango: I'd recommend Yet Another Haskell Tutorial.
12:09:01 <yango> which is probably worse :)
12:09:03 <dmhouse> ?where yaht
12:09:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
12:09:32 <dmhouse> yango: the Wikibook (which I've contributed quite a lot to) is written for people new to programming in general. By all means try it out, but it may be a bit patronising :)
12:09:36 <dmhouse> ?where wikibook
12:09:36 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:09:37 <sjanssen> yango: the "Gentle Introduction" isn't really gentle.  It's pretty terse, and moves quickly -- that may or may not be good for you
12:10:04 <DRMacIver> I find the wikibook rather pleasant, but I admit I don't so much read it as dip into it at random when I realise a hole in my knowledge. :)
12:10:33 <yango> DRMacIver: what are you doing here! :P
12:10:43 <dmhouse> If there is a hole, feel free to email wikibook@haskell.org.
12:11:17 <DRMacIver> dmhouse: No, a hole in *my* knowledge. :)
12:11:28 <dmhouse> DRMacIver: yes, I was making a different point. :)
12:11:29 <DRMacIver> yango: Err. Is this a trick question? :)
12:11:32 <DRMacIver> dmhouse: ok
12:11:57 <yango> okay got a few resources to get started now... indeed the gentle is a bit too discreet for me
12:12:01 <yango> thanks!
12:12:01 * dmhouse really wants to finish the Existentially Quantified Types and Continuations sections of the wikibook, but isn't sure how to go about it
12:12:10 <dmhouse> yango: good luck, and be sure to call back here!
12:12:29 <yango> okay, will do
12:14:59 <liber> What do you guys thiink of "Helium"? ghc has me confused sometimes with bad messages. How much better is this in helium?
12:15:24 <DRMacIver> yango: I'm not clear on why my presence in #haskell should be surprising. :)
12:16:02 <dmhouse> DRMacIver: my guess is he's surprised to see you here after knowing your nick from #math or somewhere.
12:17:11 <ohmega> I've found that I need a tutorial on writing real programs in Haskell ;)
12:17:13 <DRMacIver> More likely ##java
12:17:22 <shapr> liber: Helium doesn't have typeclasses and some other important features. But if you're just starting out, it might be worth trying.
12:17:34 <shapr> Ah, I haven't been back to ##java in a long time.
12:17:41 <shapr> How's cheeser these days?
12:17:46 <DRMacIver> Grouchy. :)
12:17:46 <shapr> I hear he shaved off his beard!
12:17:52 <shapr> hah
12:17:55 <shapr> Too many newbies?
12:17:57 <ohmega> Hi shapr
12:18:13 <DRMacIver> I sortof assumed it was just a function of being cheeser to be honest.
12:18:32 <ptolomy> Hey, so I've made what is  essentially a peephole optimizer for a list of opcodes, and it is a bit ugly. Generally speaking, is there a better way to apply all transformations to matching sequences of datum other than using a list of functions with pattern matches? I mean, I'd love to be able to do regexey stuff like matching one or more of a certain constructor or something..
12:18:37 <DRMacIver> The smiley still has a beard. Don't know if the real life version does. :)
12:18:44 <shapr> hej ohmega! Tack för många skjortor! Jag använder dem så mycket att min flickvänn vill köpa ny kläder för mig ;-)
12:18:53 <shapr> er, nya?
12:19:09 <shapr> DRMacIver: Nah, cheeser used to be cheerful and really helpful.
12:19:12 <ohmega> shapr: I hope she isn't mad at me for sending you all those shirts ;)
12:19:15 <ptolomy> Wow. My question was essentilally, "I'm writing some code. Can anyone suggest some magic?".
12:19:17 <ptolomy> Nevermind.
12:19:17 <DRMacIver> shapr: ...
12:19:26 <DRMacIver> shapr: I... find that hard to imagine.
12:19:32 <shapr> It's true! Really!
12:19:49 <shapr> Admittedly, I think that was about when Java 1.2 came out.
12:19:49 <DRMacIver> You, sir, have broken my mind.
12:19:52 <DRMacIver> Ha ha
12:20:10 <DRMacIver> Mind if I quote you on that in ##java?
12:20:20 <shapr> Hm, it may have been 1.3
12:20:22 <LoganCapaldo> ptolomy: that doesn't seem like it would be too hard
12:20:50 <LoganCapaldo> you'd need a regexp impl that worked on [a] instead of [Char]
12:21:04 <ptolomy> I suppose I could make a combinator sublanguage for expressing potential sequences of opcodes..
12:21:05 <LoganCapaldo> it could look like Parsec
12:21:42 <emu> i wrote a DFA class that could be parameterized to any kind of input list heh
12:21:47 <LoganCapaldo> many fooCon >> barCon
12:22:04 <ptolomy> LoganCapaldo:  Well, I'd also be interested in matching based on (or not based on) components of the constructor.. like (SomeOpp x 0 0) for some value o f x..
12:22:05 <emu> mostly to implement generalized NFAs with the same code
12:22:57 <kc5tja> ptolomy: It'd still be a regex implementation; just not one that relied on characters.
12:23:18 <shapr> DRMacIver: I'm on ##java saying hi to cheeser
12:23:19 <LoganCapaldo> (\(SomeOpp x 0 0) -> Just x ; _ -> Nothing) ?
12:23:29 <kc5tja> But, the question is, what takes more work?  The list-regex, or the list-of-pattern-matched-functions?  :)
12:24:02 <DRMacIver> shapr: So I see. :)
12:26:04 <ptolomy> I'm probably better off just generalizing my optimizer and doing more sophisticated data flow analysis.
12:26:12 * ptolomy might be taking his brainfuck compiler a little too far.
12:26:50 <LoganCapaldo> an optimizing brainfuck compiler? wow. That's twisted :)
12:27:00 <kc5tja> If the end result is just to have the fastest BF compiler/programs on the planet, maybe.
12:27:20 <kc5tja> Otherwise, I think self-education by participating in projects like these is great.
12:28:15 <ptolomy> LoganCapaldo: The interpreted version is already faster than a naive-but-optimized C interpreter.
12:29:12 <edited> lambdabot, ?
12:29:12 <lambdabot> Maybe you meant: . activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-clr
12:29:13 <lambdabot> djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc forecast fortune
12:29:13 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma karma+
12:29:13 <lambdabot> karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on offline oldwiki palomer
12:29:15 <lambdabot> part paste pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read reconnect redo
12:29:18 <lambdabot> [3 @more lines]
12:29:36 <Apocalisp> maybe...
12:29:44 <LoganCapaldo> ptolomy: although I see why recognizing runs of byte codes could be useful now
12:29:51 <LoganCapaldo> ++++ -> Plus 4
12:29:58 <ptolomy> Well, run-recognition is done in the parser.
12:30:01 <ptolomy> that's merely the first step.
12:30:22 <ptolomy> I've got some basic power reduction, side-effect analysis, some lifting.
12:30:48 <ptolomy> Most simple programs end up optimzing down to non-looping sequences of opcodes.
12:31:08 <DRMacIver> ptolomy: That's really silly, but very cool. :)
12:31:26 <LoganCapaldo> nice
12:31:37 <ptolomy> Well, I wanted to make a compiler, and Bf seemed like the simplest start.
12:31:56 <LoganCapaldo> yeah I suppose a lot of BF optimization amounts to trying to determine intent
12:32:09 <ptolomy> then I moved onto a tcl interpreter, but that was less fun because tcl is not as elegant as I hoped.
12:32:09 <LoganCapaldo> "intent
12:32:11 <LoganCapaldo> "
12:32:28 <shapr> The hells are alive! with the sound of coding! (I don't like PHP)
12:32:52 <ptolomy> Yeah. it's tricky, because though the original writer of the program may not have cared what value ended up in location x, it is hard to be sure that the rest of the program won't depend on it somehow.
12:33:36 <ptolomy> I really should release some of the stuff I've crapped together. It's not A-grade material, but it is better than a lot of stuff.
12:35:13 <shapr> Yeah, release it!
12:37:12 <Cale> Hmm, what do people think about the monad section of the Haskell Wikibook?
12:37:42 <Apocalisp> It's not very clear.
12:38:12 <monochrom> Too many analogies.
12:38:14 <Cale> It's nicely done with the graphics and all, but I kind of think I ought to rewrite it.
12:38:24 <monochrom> Too many graphics.
12:38:26 <Apocalisp> Go for it.
12:38:40 <monochrom> It should be shorter and more to the point.
12:38:57 <hpaste>  sm pasted "ordering a multi-constructor type" at http://hpaste.org/1803
12:38:58 <DRMacIver> "A monad is a thingy."
12:39:18 <sm> I'm having trouble with the "otherwise" case..
12:39:26 <Apocalisp> Please include a precise definition of the concept, in 13 words or fewer.
12:39:40 <sm> and it's quite verbose, any better suggestions welcome
12:39:47 <Cale> Nuclear waste is a horrible analogy, and it's also being used to analogise the non-'dangerous' part of the thing, which is annoying.
12:39:50 <monochrom> This is a programming book, not a child's introduction to Greek mythology. There is no need for fables.
12:40:33 <DRMacIver> I think using analogies to introduce monads is a stupid idea frankly.
12:40:44 <Cale> Monads are a particular way of structuring a domain specific language so that common control structures can be shared between many DSLs.
12:41:00 <DRMacIver> There's no shortage of handwavy explanations of what a monad is, but they don't help you get to grips with how to actually use or think about them.
12:41:05 <Binkley> Using analogies to introduce monads is almost as bad as trying to change a tire with a tennis racket.
12:41:20 <DRMacIver> @remember Binkley Using analogies to introduce monads is almost as bad as trying to change a tire with a tennis racket.
12:41:20 <lambdabot> Done.
12:41:21 <Cale> well, that was 22.
12:41:44 <Cale> I still think my container analogy is appropriate for many monads.
12:41:50 <binary42> How about monads to introduce analogies?
12:41:53 <monochrom> Do not try to answer "what is a monad?" directly.  My approach is: "I will not answer that question. It's distracting. I'll show you how they can be used and later implemented."
12:42:14 <DRMacIver> Cale: I'm not arguing about the appropriateness of the analogy. I'm arguing that even a highly appropriate analogy is not useful.
12:42:30 <kowey> Cale: please do! I won't be able to support with diagrams, but surely somebody would step up
12:42:30 <Cale> DRMacIver: Without a proper definition, I'll agree.
12:42:42 <monochrom> My sentiment too. No analogy. No fable. No gimmick.
12:42:44 <Cale> kowey: I can manage diagrams if I need any :)
12:42:59 <kowey> (for what it's worth, paul j. suggested the nuclear waste because he thought the space suits thing was a little far-fetched)
12:43:33 <Cale> Also, the first paragraph of this is "wrong" in my opinion.
12:43:49 <monochrom> containers are a special case of monads. that is not an analogy.
12:44:19 <Cale> monochrom: Well, it starts being an analogy when you take the state monad and think of computations in it as containers :)
12:44:31 <Cale> (indexed by possible states)
12:44:33 <SamB_XP_> monochrom: this is a sound approach
12:44:41 <Cale> But yeah.
12:44:55 <SamB_XP_> because I have no really useful answer to "what is a monad"
12:45:08 <SamB_XP_> I have some answers to "what are some monads", though ;-)
12:45:19 <kowey> you might want to keep in mind that the uses of monads are supposed to be presented earlier on in the book, with IO introduced as actions
12:45:23 <Cale> My answer to "what is a monad" is that it's a convention for structuring combinator libraries.
12:45:29 <kowey> and a state monad module
12:45:38 <sm> so, I want to derive Ord but override compare, only for certain kinds of argument - can I do this ? maybe with -fallow-overlapping-instances ?
12:46:07 <Cale> sm: You either derive, or provide your own instance.
12:46:21 <sm> can't mix them eh
12:46:49 <Cale> I actually don't know how it works with -fallow-overlapping-instances
12:47:00 <Binkley> well, why would you derive Ord if you want to provide your own compare function? IIRC, compare gives you the minimal instance
12:47:02 <Cale> but using deriving is like providing an instance
12:47:28 <Apocalisp> Actually, the "Understanding Monads" section is quite awful now that I look at it again.
12:47:29 <liber> lol: http://hpaste.org/1799
12:47:31 <Cale> Is this a parametric type we're talking about?
12:47:44 <Binkley> er, the minimal complete definition, I meant
12:47:45 <Cale> liber: haha
12:48:07 * raxas_ is asking himself a serious philosophical question: is human mind a monad?
12:48:24 <monochrom> what is human mind?
12:48:26 <Cale> raxas_: over what category?
12:49:00 <emu> Leibniz monads?
12:49:11 <raxas_> Cale: over category of Turing complete machines
12:49:22 <sm> Cale, Binkley: I'm talking about http://hpaste.org/1803 - I'd like to alter the behaviour of >, only for certain values of this type
12:49:29 <sm> (depending on the constructor)
12:49:31 <Cale> hmm, what are the objects and arrows of that category?
12:49:43 <Binkley> raxas_: if so, that would explain this mysterious error message that appeared to me the other day when I tried to think an impure thought
12:49:48 <sm> and I found it hard to write the full instance myself
12:50:04 <edited> where can i get Network package?
12:50:39 <Cale> sm: Isn't the definition you provided, minus the last line, complete?
12:50:45 <Cale> er
12:50:50 <emu> edited: comes with ghc presumably
12:50:53 <Cale> oh, not quite :)
12:50:57 <sm> no
12:51:06 <sm> ghc is so picky.. :)
12:51:22 <Cale> You want to compare ACCURACY values with RMSE's
12:51:26 <Cale> and so on
12:51:32 <sm> actually no, it's fine if that's illegal
12:51:37 <sm> I'll only compare like values
12:51:38 <edited> emu,  i did run the .hs with ghc and it said could not find module Network
12:51:53 <edited> emu,  i got ghc 6.6
12:52:03 <emu> edited: -package network
12:52:11 <emu> better yet, ghc --make file.hs
12:52:21 <sm> I was surprised that the last line's pattern is not allowed
12:52:50 <emu> i pretty much use ghc --make exclusively.  is there any reason not to use --make?
12:53:00 <emu> (when invoking ghc)
12:53:22 <edited> emu,  i did use ghc --make l.hs
12:53:26 <kowey> sigh...
12:53:27 <edited> it cant find Network package
12:53:42 <Cale> sm: hmm, it sort of would be nice to allow things like that, but there would be cases where it would be ambiguous
12:53:43 <sebell> edited: are you on Debian?
12:53:51 <edited> sebell, ubuntu
12:53:56 <emu> perhaps you need ghc extras
12:54:00 * kowey is disappointed in the awfulness of the understanding monads chapter
12:54:18 <Cale> kowey: Don't worry, we'll rewrite it :)
12:54:36 <kowey> although the thing about nuclear waste being a bad metaphor makes me feel somewhat vindicated
12:54:41 <Cale> kowey: I think my "Introduction to IO" on the Haskell wiki is a good model of what to generalise.
12:54:42 <kowey> thanks!
12:55:09 <emu> hmm debian calls it libghc6-network-dev ?
12:55:33 <emu> the advanced monad chapter isnt too bad
12:55:36 <sm> I suppose I could write out every combination.. ugh
12:56:03 <edited> sebell, do i need to download extras?
12:56:08 <sm> the rest of this program is mostly one-line functions, so that would be bad :)
12:58:41 <sebell> edited: No, I would imagine you need the network package: libghc6-network-dev
12:58:42 <edited> emu,  ?
12:59:11 <emu> edited: i dont have ubuntu, but in debian there is a package called libghc6-network-dev
12:59:23 <emu> perhaps it is the same in ubuntu
12:59:29 <edited> cool
12:59:43 <emu> i'm sure you can use APT to search for ghc related packages
13:00:58 <edited> it worked!
13:00:59 <edited> thx
13:01:03 <Apocalisp> The ACID Monad is mind-bogglingly useful.
13:01:12 <hpaste>  sm annotated "ordering a multi-constructor type" with "actually, not too bad" at http://hpaste.org/1803#a1
13:01:26 <Apocalisp> Almost as useful as Monad.Babelfish...
13:02:23 <Cale> One major hurdle in writing an introduction to monads is that people aren't used to thinking of computations as values.
13:02:30 <Cale> I think that's probably the hardest part.
13:02:36 <emu> functions?
13:02:49 <Cale> Well, they might even be used to functions.
13:03:03 <Cale> But more general computations are still awkward :)
13:03:04 <Apocalisp> Cale: That's a good insight.
13:03:12 <ptolomy> I always feel a little naughty using infix type constructors.. like I'm secretly thinking of functions while I'm making out with types or something.
13:03:18 <Cale> It's one of the biggest reasons why I used the container analogy.
13:03:51 * Heffalump reads about Harpy and looks most impressed
13:04:09 * dmwit was just reading about that, too
13:04:21 <Cale> It might be a good idea to introduce some combinator libraries before a chapter on monads, though that's a lot of work :)
13:04:41 <emu> type classes perhaps?
13:04:44 <kowey> the wikibook is hard
13:04:49 <kowey> huge constraints problem
13:05:30 <kowey> have to figure out what the right order to introduce things in...
13:05:56 <Cale> Types and values is a problem I haven't managed to sort out completely.
13:06:31 <Cale> I'd really like to start my book with types. But it's hard to talk about types without values, and you can't talk about values without introducing lots of syntax.
13:06:47 <bos> Cale: you're writing a book?
13:06:59 <Cale> bos: I have a couple of chapters, yeah.
13:07:01 * Heffalump has been recommending the wikibook at work
13:07:18 <bos> must be the season :-)
13:07:38 * Heffalump still can't get over actually being able to say stuff like that :-)
13:07:49 <DRMacIver> It's unusual actually. I've found most wikibooks really unimpressive.
13:08:02 <Heffalump> I meant the "at work" bit :-)
13:08:02 <Apocalisp> Heffalump: What's Harpy?
13:08:14 <Heffalump> a runtime generator of x86 machine code
13:08:23 <Heffalump> http://uebb.cs.tu-berlin.de/harpy/
13:08:27 <DRMacIver> Heffalump: Yeah, I know. it was an unrelated comment.
13:08:36 <bos> Cale: got a particular audience in mind?
13:08:45 <DRMacIver> Oh, neat.
13:08:51 <kowey> well. the wikibook is like darcs... it suffers from a lack of people with lots of time to dedicate to it
13:09:14 <Heffalump> you seem to be doing a pretty good job of both :-)
13:09:38 <kowey> yes, the too-many-cooks problem can be an issue, but for now, we're trying to go from zero to something, even a really bad something
13:09:40 <DRMacIver> kowey: No, I mean the Haskell wikibook *is* good. This is unusual for a wikibook.
13:09:52 <Cale> bos: Well, ideally, it would go from beginner up to dealing with things like STM.
13:10:11 <Heffalump> yes, indeed. I wouldn't be recommending it if I didn't think it was good.
13:10:50 <DRMacIver> I think it's probably better for using like I do (dipping in to specific sections when I need to brush up on something) than it is for learning from scratch though.
13:10:55 <kowey> ah! /me stops apologising
13:12:00 <bos> Cale: are you looking for a publisher, or what's your notion around that kind of thing?
13:12:03 <DRMacIver> Heffalump: Harpy looks really cool.
13:12:34 <Cale> bos: I don't have enough written to look for a publisher at this point. My plan was mostly to write it and then sort out what I wanted to do with it :)
13:12:54 <bos> Cale: fair enough.
13:13:03 <Apocalisp> Cale: You can talk about types and values in the abstract at first.
13:13:12 <Apocalisp> And then go into Haskell
13:13:22 <Heffalump> does anyone know if HSQL is maintained these days?
13:13:24 <Cale> That's true.
13:13:26 <bos> Cale: are you looking at a more abstract, or practically-oriented, approach?
13:14:04 <greenrd> I am planning to create a page on the haskell wiki containing a table of alternatives and extensions for haskell libraries
13:14:17 <Cale> bos: Abstract, but with a view toward how things influence practical work.
13:14:25 <bos> ok.
13:15:07 <greenrd> for each package or module listed, it would list (a) alternatives to do the same or similar tasks (or link to a wiki page with that list), (b) links to extensions and code snippets to extend the functionality of that package or module
13:15:08 <Cale> I certainly won't introduce concepts earlier than I think I can treat them well.
13:15:15 <greenrd> does anything like this already exist?
13:15:38 <greenrd> it's hard to know for sure because the haskell wiki is still excluded from google indexing by haskell.org/robots.txt :(
13:15:49 <dmwit> Wow, really?
13:15:51 <dmwit> I wonder why.
13:15:55 <greenrd> yeah
13:15:56 <greenrd> odd
13:16:14 <sieni> is it hard to fix that?
13:16:20 <dmwit> No!
13:16:21 <Cale> Uh, it is?
13:16:35 <greenrd> at least it's an improvement from the previous situation not too recently, where the entire DOMAIN was excluded!
13:16:37 <Cale> My Introduction to IO page is indexed.
13:16:39 <dmwit> Googlebot has its own user-agent string, it should be really easy.
13:16:58 <greenrd> er, s/not too//
13:17:44 <greenrd> Cale: It is now - probably yours was indexed when it wasn't
13:19:03 * dmwit is unsure that Google respects robots.txt
13:19:14 <dmwit> http://www.google.com/search?complete=1&hl=en&safe=off&q=functional+inurl%3Ahaskell.org%2Fhaskellwiki&btnG=Search
13:19:16 <lambdabot> Title: functional inurl:haskell.org/haskellwiki - Google Search, http://tinyurl.com/ywlnd2
13:19:29 <dmwit> Isn't the Functional Pearls page fairly recent?
13:19:44 <dmwit> But then, it is a bit odd that there's only one result...
13:20:53 <dmwit> greenrd: I think it just means they don't cache the page.
13:25:21 <Apocalisp> Cale: What's your contention with values and types?
13:26:33 <emu> the zipper chapter is cute
13:35:17 <Cale> Apocalisp: hm?
13:36:35 <Cale> Apocalisp: Basically just that it's difficult to fully understand one without the other in Haskell, so you have to spiral around between them to bootstrap things at the beginning.
13:36:56 <Heffalump> Cale: yeah, I've found that.
13:37:18 <DRMacIver> Really?
13:37:43 * DRMacIver finds the core Haskell type system totally intuitive.
13:37:53 <DRMacIver> Although I won't pretend to understand the various enhancements. :)
13:38:06 <Cale> It's natural if you're already a mathematician :)
13:38:29 <Apocalisp> It's natural to anyone.
13:38:42 <DRMacIver> I guess. Or maybe it's that I've had prior exposure to Hindley Milner type systems. But I found that totally intuitive the first time as well. :)
13:38:47 <Cale> I don't know if I'd go that far. :)
13:38:52 <Apocalisp> Types are concepts and values are their particular referents.
13:40:34 <DRMacIver> Well, when you put it like THAT it all suddenly stops making sense. ;)
13:42:26 <Apocalisp> Babies and animals grok values. Ball, food, mom. They divide the universe into particulars. Then we start using concepts to group them toys, edibles, people. I find that this is how most people understand values and types intuitively.
13:43:01 <DRMacIver> Are you sure you're not monochrom in disguise?
13:43:26 <Apocalisp> why?
13:43:33 <Apocalisp> And yes.
13:43:59 <Apocalisp> @quote monochrom
13:44:00 <lambdabot> monochrom says: "m a -> (a -> m b) -> m b" is much more to the point than "mumble computation mumble computation mumble computation mumble"
13:44:00 <DRMacIver> It just sounds rather like the sort of thing he'd say. :)
13:44:16 <Cheery> actually, values <=> local name -association is excellent
13:44:50 <Cheery> that rarely happens with imperative software, where names tend to be global and not referring to a static thing in place and time
13:45:20 <Cheery> so I fully agree, values are very intuitive
13:45:53 <Cheery> it's one of foundational things in haskell
13:46:06 <Apocalisp> Values are one-and-only. Types are some-but-any.
13:46:29 <Apocalisp> B-)
13:46:29 <monochrom> haha
13:46:34 <Cheery> I believe that any language which would follow that example would increase it's readibility by a magnitude
13:46:59 <Cheery> *readability
13:47:17 <Cale> Some values are different depending on what their types are.
13:47:50 <Apocalisp> Totally agree. Haskell has a most consistent and eminently graspable type system.
13:48:13 <Apocalisp> Cale: What do you mean? Example?
13:48:17 <Cale> Apocalisp: 5
13:48:40 <monochrom> id
13:48:53 <Cale> indeed, id
13:49:11 <Cale> But at least id only has one implementation :)
13:49:21 <Apocalisp> isn't id of every type?
13:49:30 <DRMacIver> But how many arguments does id take? ;)
13:49:35 <sjanssen> @where harpy
13:49:35 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
13:49:46 <Cale> It's of type forall a. a -> a
13:49:47 <emu> as many arguments as you are willing to start
13:49:49 <greenrd> Apocalisp: no, it's from every type to itself
13:49:57 <monochrom> id is a value too
13:50:03 * lispy eyes Harpy longingly...oh to work on helisp again and integrate Harpy
13:50:07 <lispy> ?where Harpy
13:50:08 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
13:50:10 <greenrd> a function type from every type to itself, I meant to say
13:50:19 <Cale> So in a sense, it's of one type, but that type unifies with lots of types.
13:50:36 <DRMacIver> helisp?
13:50:48 <Cale> 5 is an Integer and a Float and a Rational, but not all at once :)
13:51:12 <emu> well it should be an Integer, a Rational, a Real, and a Complex number all at once
13:51:14 <Apocalisp> Sure it is all at once. Maybe not to the machine though.
13:51:41 <monochrom> Nevermind the machine.
13:51:42 <Cale> The difference matters to the Haskell programmer as well.
13:51:48 <Cheery> uuuuuuuuuughh, I'm shocked by harpy :)
13:51:56 <Cale> 5 :: Double behaves very differently from 5 :: Integer
13:52:00 <DRMacIver> Cheery: Why?
13:52:01 <Cale> with regard to operations
13:52:07 <Cheery> I didn't know such existed at all
13:52:32 <Cheery> even it's not very interesting looking, one can substantially change that by doing something with it
13:52:51 <Apocalisp> Yes, well as such a Double 5 and an Integer 5 aren't the same value. Not in Haskell.
13:52:57 * Cheery stores it for further looking
13:54:12 * Apocalisp imagines if Haskell can be extended for specialization-by-constraint.
13:54:58 <emu> @where harpy
13:55:00 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
13:55:30 <yango> Hugs.Base> map Char.toUpper "hello"
13:55:33 <yango> ERROR - Undefined qualified variable "Char.toUpper"
13:55:44 <yango> ? tried map toUpper "hello" too
13:55:57 <sjanssen> yango: you need to load Data.Char
13:56:05 <sjanssen> IIRC, :load Data.Char
13:56:33 <yango> where do I check that? ie a list of available modules (or whatever they're called)
13:56:39 <sjanssen> @docs
13:56:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
13:56:52 <yango> thanks
13:56:54 <Apocalisp> In an ideal type system, 5.0 and 5 are the same value, and therefore of the same exact type. An Ellipse 4 4 _is_ a Circle 4.
13:57:03 <sjanssen> yango: ^^^ documentation for every library released with GHC/Hugs
13:57:04 <Cheery> I'm wondering seriously whether you could use haskell as a reference for implementing languages for writing assembly code as well
13:57:50 <Cheery> ie. assembly language which will consist from graphs which will be reduced
13:58:10 <Cheery> and type-checked
13:58:29 <Cheery> then translated into sequences of instructions
13:58:41 <Cheery> and same thing backwards as well. :)
13:59:06 * Cheery hates copy protections
13:59:07 <lispy> DRMacIver: haskell elisp
13:59:33 <lispy> DRMacIver: i'd like to make a non-emacs implementation of elisp.  This would allow, for example, using elisp with Yi
13:59:48 <lispy> at which point, either Yi would explode or take over the world
13:59:59 <lispy> ?quote sky.net
13:59:59 <lambdabot> No quotes match. My mind is going. I can feel it.
14:00:02 <lispy> ?quote skynet
14:00:03 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
14:00:11 <emu> creating an implementation of elisp requires human sacrifice, i think
14:00:35 <lispy> emu: it can't be that had considering there is a gpl'd reference implementation
14:00:48 <lispy> when it doubt, check it out
14:00:59 <emu> there's one for perl too, artistic even :)
14:01:53 <Binkley> lispy: that doesn't mean that there was no human sacrifice involved :-)
14:01:59 <MyCatVerbs> You can implement LISP flavours in one another just using macros, can't you?
14:02:07 <emu> heh
14:02:45 <emu> well i won't rule out suitably clever macros.  but elisp has significantly different semantics than common lisp, for example.
14:02:59 <emu> i suppose if you declared every  variable special, it might come close =)
14:04:19 <yango> haha, this exercise rocks : "Do the following function <function description>. Explain to yourself why it works" :)
14:05:09 <MyCatVerbs> yango: YAHT? Or was that in SICP?
14:06:42 <kc5tja> Looks like something out of SICP.  :)
14:07:42 <MyCatVerbs> It sounds familiar, I've read some of both. But still.
14:07:49 * kc5tja would rather use Scheme for an editor's language, I think.  Other dialects of Lisp seems to be, if I may, semantically bloated (too much for a coder to remember at any given time).
14:07:59 <shapr> Ya know, I'd like to do regular blog posts that collect together cool Haskell-ish papers.
14:08:07 <shapr> For example, the Harpy paper is way cool.
14:10:12 <shapr> Any other cool papers I should mention in a blog post?
14:10:20 <MyCatVerbs> shapr: go for it. Just publish an entry every other day or something with anything spiffy off reddit, etc in it.
14:10:34 <MyCatVerbs> Yay, echo chamber!
14:11:01 <MyCatVerbs> Plus add absolutely anything you hear of anywhere else, with a short explaination of its relevance or lack thereof.
14:12:19 <dmwit> shapr: I've been looking at http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf which is pretty interesting.
14:13:43 <shapr> Yeah, that's a cool paper.
14:13:53 <shapr> MyCatVerbs: I hear of a lot of stuff!
14:13:56 <DRMacIver> lispy: Ah
14:14:14 * merus has neglected his blog on account of finals :(
14:14:49 <dmwit> Finals?  We're just getting into midterms!
14:14:51 <dmwit> =(
14:15:08 <merus> my school has a wacked out schedule.
14:15:38 <lispy> kc5tja: yes, that would be great if there didn't exist so much useful legacy elisp
14:16:09 <Heffalump> what is a midterm?
14:16:13 <DRMacIver> Write an elisp -> human readable Haskell compiler. :)
14:16:30 <dmwit> Heffalump: It's an exam in the middle of a quarter/semester.
14:16:50 <Heffalump> does it count towards your final grade?
14:16:59 <kilimanjaro> in most cases, yes
14:17:04 <edited> finals? midterms? its summer here!
14:17:09 <Heffalump> evil!
14:17:10 <yango> MyCatVerbs: YAHT
14:17:14 <edited> im done with school
14:17:20 <kilimanjaro> edited, time to get out the skis
14:17:30 <SamB_XP_> Heffalump: ... what would be the point of an exam that didn't count towards your grade?
14:17:38 <Binkley> learning? :-)
14:17:39 <Heffalump> SamB_XP_: progress check?
14:17:42 <kilimanjaro> SamB_XP_, humiliation
14:17:46 <Binkley> that too
14:17:57 <edited> torture!
14:18:06 <merus> We need more humiliation in higher education :D
14:18:07 <SamB_XP_> Binkley: don't they call those practice tests?
14:18:10 <MyCatVerbs> yango: ahhh. Thought it sounded familiar.
14:18:13 <Heffalump> Oxford has exams that don't count all the time.
14:18:26 <kilimanjaro> Theology exams?
14:18:28 <edited> i wouldnt take any then
14:18:38 <Heffalump> well, they might kick you out if you do really badly
14:18:42 <edited> if i knew it doesnt count i wouldnt take it
14:18:52 <edited> that sucks
14:18:56 <edited> then u might as well count it
14:18:59 <Heffalump> but you'd annoy your tutor a lot, and they don't count for anything else
14:19:00 <kilimanjaro> edited, I bet you wouldn't pay taxes if you weren't force too, huh?
14:19:14 <edited> thats a different story
14:19:14 <kilimanjaro> forced*
14:20:16 <sjanssen> who would pay their taxes if they weren't forced?
14:20:44 <SamB_XP_> wouldn't they be called something else if they were optional?
14:20:49 <SamB_XP_> like "donations"?
14:20:53 <sjanssen> I recognize the value of taxes -- but I'm quite certain I wouldn't pay if there were no penalties
14:20:54 <dobblego> some people would; Jehovah's Witnesses for example
14:28:09 <njbartlett> dobblego: I think they believe that there will be penalties in the next life, even when there are none in this.
14:33:53 <Cheery> Fastest way to add .png -textures to OpenGL -app?
14:34:00 <Cheery> ie. least effort
14:35:31 <dobblego> njbartlett, that's incorrect
14:36:49 <njbartlett> Oh. Well, shows what I know about JWs
14:37:19 <Heffalump> I just know that they're a bloody nuisance :-) At least the door-knocking ones.
14:37:22 <Apocalisp> Taxes schaxes.
14:37:32 <fuzan> what exactly are the differences between statet and readert?
14:38:18 <Heffalump> StateT allows you to write to the state whenever you want.
14:38:35 <Heffalump> ReaderT just lets you change the "reader value" temporarily for the scope of a subcomputation
14:39:00 <Philippa> if you like, ReaderT just gives you an 'environment' which has to follow a lexically-scoped discipline
14:39:20 <Heffalump> don't you mean dynamically-scoped?
14:39:24 <fuzan> Philippa: so there'd be no method to modify the state elsewhere?
14:40:34 <davidL> > maxBound::Float
14:40:35 <lambdabot>   add an instance declaration for (Bounded Float)
14:40:36 <lambdabot>     In the expression: maxB...
14:40:44 <davidL> > maxBound::Int
14:40:45 <lambdabot>  2147483647
14:40:57 <ehird`> > maxBound::Int + 1
14:40:57 <lambdabot>  Parse error
14:41:40 <fuzan> hmm, i think I need to read more about monad transformers.
14:41:49 <DRMacIver> > (maxBound + 1) :: Int
14:41:51 <lambdabot>  -2147483648
14:42:08 <fuzan> i think my understanding is a little flawed. I dont' see a point of having a reader transformer.
14:42:41 <sjanssen> fuzan: generally Reader is used to reduce parameter passing
14:43:28 <sjanssen> for example, in xmonad we have to carry around some values that never change (like the X display handle).  So we wrap a (ReaderT XConf) around IO
14:43:46 <sjanssen> (XConf is a data type that holds these non-changing bits)
14:44:33 <fuzan> sjanssen: ah. i'm not sure what ReaderT is then :) i'm reading http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html now hoping that it sheds some light.
14:44:37 <lambdabot> Title: Monad Transformers Step by Step
14:47:04 <Saizan> StateT s (Reader r) a =? ReaderT r (State s) a
14:48:01 <sjanssen> Saizan: yeah, I think those are equivalent
14:48:35 <sjanssen> @unmtl StateT s (Reader r) a
14:48:36 <lambdabot> s -> r -> (a, s)
14:48:51 <sjanssen> @unmtl ReaderT r (State s) a
14:48:52 <lambdabot> r -> s -> (a, s)
14:48:55 <fuzan> so a readerT is just a monad transformer on top of state?
14:49:11 <sjanssen> fuzan: no, ReaderT is a transformer on *any* monad
14:49:11 <Saizan> you can use ReaderT on top of any monad
14:50:17 <Saizan> @unmtl ReaderT r (Writer w) a
14:50:18 <lambdabot> r -> (a, w)
14:50:29 <sjanssen> @unmtl ReaderT r IO
14:50:30 <lambdabot> err: Unknown MTL(1)
14:50:41 <sjanssen> bleh
14:51:01 <sjanssen> fuzan: you know the State monad well?
14:51:48 <sjanssen> Reader is just like State, except there's no 'put' operation
14:51:50 * emu goes drinking with the State monad
14:52:05 <Heffalump> sjanssen: I don't think State has "local"
14:52:10 <Heffalump> though you could simulate it
14:52:45 <sjanssen> yeah
14:52:53 <Saizan> ?type local
14:52:56 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
14:53:31 <joelr1> where does cabal-install put the haskell packages that it downloads?
14:53:51 <Saizan> there's localState in happs, it needs bot an accessor and a setter function :)
14:55:20 <davidL> > denominator (toRational (sqrt 49)) == 1 --is there a better way to check if a square root is an integer?
14:55:22 <lambdabot>  True
14:56:25 <Sgeo> Anyone mind if I swear?
14:56:51 <Heffalump> go ahead
14:56:56 <Sgeo> @fuck lambdabot
14:56:57 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
14:57:02 <Sgeo> @fact lambdabot
14:57:03 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
14:57:09 <Sgeo> >.>
14:57:20 <sjanssen> the spellchecker beat you
14:57:23 <fuzan> @fghi lamdabot
14:57:23 <lambdabot> No quotes match. It can only be attributed to human error.
14:57:33 <sjanssen> Sgeo: are you still trying to build lambdabot?
14:57:34 <emu> i think you just beat the spellchecker
14:57:38 <Sgeo> sjanssen, I built it
14:57:51 * sjanssen senses a "but"
14:58:10 <Sgeo> And it works, mostly
14:58:19 <Sgeo> Some haskell-specific stuff doesn't work
14:58:30 <fuzan> sjanssen: nope. my only real experience with the heavier monads are with StateT
15:00:01 <Saizan> joelr1: /var/cache/cabal-install/packages
15:01:35 <sorear> hello.
15:01:36 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:01:40 <sorear> @messages
15:01:41 <lambdabot> kc5tja said 5h 5m 56s ago: Cool -- congrats.
15:03:19 <Heffalump> sorear: morning
15:05:33 <fuzan> i'm not a fan of the tex-ified haskell code. \verbatim ftw.
15:06:06 <Heffalump> I can never remember the expansion of "ftw"
15:06:23 <Nafai> "For the Win"
15:06:41 <fuzan> Heffalump ftl?
15:06:47 <Nafai> Heh
15:06:52 <Heffalump> hmph.
15:07:14 <Heffalump> Nafai: ah, yes. That's why I find it so hard to remember, it being such awful grammar.
15:07:20 * ddarius -never- heard "ftw" before returning to #haskell.
15:07:50 <fuzan> ddarius: you need to play more videogames.
15:07:58 * sorear -neither-
15:07:58 * ddarius comes back and everyone is like ftw this and ftw that, and I'm like wtf?
15:08:30 <ddarius> fuzan: I should pull out Bubble Bobble again.
15:08:31 <sorear> @remember ddarius * ddarius comes back and everyone is like ftw this and ftw that, and I'm wtf?
15:08:32 <lambdabot> Done.
15:08:33 <mattam> ftwwtf
15:08:37 <mattam> i like tha
15:08:38 <mattam> t
15:08:42 <jcreigh> ftw ftl!
15:08:53 <kc5tja> When I first saw ftw, I always read it as, "#*$* the world!"
15:08:56 <fuzan> ddarius: try a modern and popular online game :)
15:09:08 <kc5tja> It took some time to internalize "for the win."
15:09:26 <kc5tja> (I still sometimes read it as For The World, but at least that's better than my initial reading of it.  :D)
15:09:54 <ddarius> sorear: You dropped the last "like"
15:10:05 <sorear> kc5tja: What kinds of debugging faculties exist in k2, beside wdm#, 2 ,1 ?
15:10:28 <kc5tja> That's it.
15:10:53 <kc5tja> WDM codes are as follows: 0 == quit emulator, 1 = turn tracing off, 2 = turn tracing on, 3 = stack dump
15:10:55 <sorear> oh, well..
15:11:11 <sorear> stack as in S?
15:11:16 <kc5tja> Yes
15:11:51 <sorear> ok.
15:11:53 <sorear> ty
15:12:01 <kc5tja> sorear: I'd like to see your code and compare it with what I have at some point in time.  But I still need to implement the line editor interface.  (See, I told you I am king of procrastination.)
15:12:44 <sorear> I just have a cross compiler, I don't even have a working mgia driver.
15:13:00 <davidL> can someone tell me why isPentagonal n = denominator(toRational((sqrt(24*n+1)+1)/6)) == 1 can't have the type Int -> Bool?
15:13:06 <sorear> kc5tja: I can run code (witnessed by wdm, 0 ,1  having an effect)
15:13:25 <sorear> kc5tja: I suspect debugging will be *much* easier once . is working ;)
15:13:48 <kc5tja> sorear: Well, my goal was to get it running some kind of outer interpreter, so that I can run unit tests.  :)
15:13:53 <fuzan> what are the advantages of using State over MVars?
15:14:02 <beelsebob_> :t denominator(toRational((sqrt(24*n+1)+1)/6)) == 1
15:14:04 <lambdabot> Not in scope: `n'
15:14:06 <beelsebob_> @type denominator(toRational((sqrt(24*n+1)+1)/6)) == 1
15:14:08 <lambdabot> Not in scope: `n'
15:14:15 <beelsebob_> @type \n -> denominator(toRational((sqrt(24*n+1)+1)/6)) == 1
15:14:18 <lambdabot> forall t. (Floating t, Real t) => t -> Bool
15:14:24 <Binkley> fuzan: MVars are for synchronizing between multiple threads
15:14:27 <beelsebob_> davidL: there's why
15:14:29 <sorear> fuzan: type level proofs of purity, faster
15:14:30 <beelsebob_> it expects a float
15:14:31 <Heffalump> davidL; sqrt won't take an Int
15:14:31 <fuzan> it seems to me that one could thread mvars with a reader elegantly and not have to rewrite code later to allow for thread safety.
15:14:54 <beelsebob_> @type \n -> denominator(toRational((sqrt(fromInteger (24*n+1))+1)/6)) == 1
15:14:54 <fuzan> sorear: state is faster than mvar?
15:14:57 <lambdabot> Integer -> Bool
15:14:59 <davidL> Heffalump: can I write my own sqrt that will take an int?
15:15:02 <beelsebob_> there you go
15:15:05 <davidL> oh thanks
15:15:07 <sebell>  /quit
15:15:07 <davidL> ;)
15:15:16 <sorear> fuzan: MVar requires atomic operations.  (but benchmark!)
15:16:50 <sorear> kc5tja: Right now my issue is that I can't seem to get the mcia-irq called...   so something like bochs' extensive set of info commands would be useful.
15:17:07 <sorear> kc5tja: (I'll just force tracing on and filter the results with grep)
15:17:42 <sorear> kc5tja: I do have to say one thing though - after a year with runghc, gforth is *ludicrously* fast :)
15:21:47 <_magus_> hmm, is there an obvious reason, that I've missed, why typing 'sleep' into Hoogle doesn't turn up the function in System.Posix.Unistd?
15:22:47 <sorear> yes
15:23:02 <_magus_> sorear: hmmm, and that reason would be?
15:23:02 <sorear> er, no
15:23:25 <ddarius> If compiling was lookup in Haskell, GHC would be ludicrously fast too.
15:23:34 <sorear> but sleep in System.Posix.Unistd should not be used unless you have a good reason, it's rather more expensive than the alternatives
15:24:19 * ddarius assums sorear means memory-wise and such.
15:24:25 <sorear> _magus_: sleep is a safe foreign call, so it forks an OS thread, calls sleep in it, and waits for the thread to finish
15:24:42 <sorear> ddarius: No, ludicrously fast was refering to time
15:24:45 <_magus_> sorear: yes, I know... that's stated in its entry so I ended up using threadDelay... however, searching for a sleep-function using the term 'sleep' seems a bit more natural than using the term 'delay'
15:24:59 <sorear> Ah good!
15:25:10 <ddarius> sorear: You are confusing my referrents.  The first comment was re gforth the second re you response to _magnus_
15:25:26 <sorear> ddarius: Ok, sorry.
15:25:55 <_magus_> sorear: I was just wondering why Hoogle didn't show me sleep in System.Posix.Unistd when I search for 'sleep'... it did turn up the function in System.Win32.Process however
15:27:14 <_magus_> sorear: it seems Hoogle has a problem with everything under System.Posix in fact... 'installhandler' doesn't show the function in Posix.System.Signals... am I missing something here?
15:29:06 <sorear> _magus_: Neil Mitchell, author of hoogle and builder of the database, uses Windows.
15:29:16 <sorear> I suspect that may be the problem.
15:30:34 <_magus_> sorear: ah, that could explain it... I'll have to send him an email and ask :-)
15:30:56 <davidL> doesn't he go by ndm on IRC?
15:31:12 <_magus_> davidL: yes, apparently he does
15:40:36 <greenrd> I started the alternatives/extensions page on the wiki: http://www.haskell.org/haskellwiki/Alternatives_and_extensions_for_libraries
15:40:39 <lambdabot> Title: Alternatives and extensions for libraries - HaskellWiki, http://tinyurl.com/yw4yd9
15:41:21 <greenrd> Please feel free to edit or add links to any that you know about - including code snippets, however small
15:41:36 <greenrd> if a table row gets too long the list of links can be factored out onto another page
15:42:40 <greenrd> I didn't add all those XML modules because I don't know much about them
15:42:48 <greenrd> (and due to laziness :)
15:46:33 <Saizan> mmh i know only of HaXml and HXT
15:46:52 <Saizan> are there many more?
15:48:07 <sorear> hxml, hsxml,
15:48:36 <sorear> hsxml mostly doesn't count however (because it was written by oleg)
15:48:45 <Saizan> ?where hsxml
15:48:45 <lambdabot> I know nothing about hsxml.
15:49:00 <Saizan> is it full of oleg-isms?
15:49:06 <greenrd> haha
15:49:49 <Saizan> xml in the type system feels scary..
15:50:29 <greenrd> someone'll need to sift through MissingH and add stuff from there, but I've had enough for tonight
15:51:26 <greenrd> the idea is that people can link to their blog posts, wiki pages etc. btw
15:52:07 <greenrd> things like "here's a useful function I wrote to extend/illustrate FooModule"
15:52:45 <greenrd> only the links should be more concisely-titled, obviously
15:53:36 <Saizan> greenrd: you want to make a post to the mailing list, maybe?
15:53:49 <greenrd> yeah, will do that tomorrow
16:00:11 <kc5tja> sorear: Hehehe -- meanwhile, GHC snows GForth if code is written well.
16:00:27 <kc5tja> Unless GForth now plays the same tricks as BigForth, but I doubt that.
16:04:35 <sorear> kc5tja: GForth has a crazy scheme which copies primitives for every call site.  No optimizations of any kind are used, but it makes all of the NEXT branches predictable.  (Still won't be as fast as a true compiler, of course)
16:06:34 <fuzan> hmm, if i have a class of type A, and i'd want to make a list of objects of type a, how could i do that?
16:07:04 <fuzan> not sure how to do handle polymorphism in type declarations.
16:07:07 <sorear> fuzan: huh?  sounds like you're talking oo
16:08:45 <Saizan> data A a = A [a] ?
16:08:47 <sorear> @uptime
16:08:48 <lambdabot> uptime: 4d 21h 47m 38s, longest uptime: 13d 18h 36m 21s
16:09:06 <fuzan> sorear: well, there's no way to build a collection of objects belonging to a type class? i'm pretty sure that's how BNFC handles parse trees for compositional operations
16:09:38 <sorear> fuzan: Objects don't belong to type classes.
16:09:49 <sorear> fuzan: as the name implies, type classes hold types
16:09:58 <sorear> fuzan: in haskell types are not objects
16:10:41 <sorear> @uptime
16:10:42 <lambdabot> uptime: 4d 21h 49m 32s, longest uptime: 13d 18h 36m 21s
16:17:23 <fuzan> ah
16:17:37 <fuzan> what i'm asking for is heterogeeous lists
16:17:48 <fuzan> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
16:17:50 <lambdabot> http://tinyurl.com/f9umb
16:18:38 <kc5tja> sorear: err...I don't think so.  GForth uses "call" threading (primitives are invoked via C function pointers), last I checked.
16:19:39 <sorear> kc5tja: the info file I have says direct threading (could be out of date)
16:20:29 <kc5tja> OK -- sounds like they're using computed-goto in GCC.
16:20:56 <kc5tja> Still, though, I don't see how inlining primitives is of any use in a direct threaded environment.
16:21:08 <sorear> Not inlining, duplication.
16:21:18 <kc5tja> Same thing.
16:21:44 <sorear> : foo 2 + ;  ->   header  ptr  ptr  ptr   copy-of-code-for-lit  copy-of-code-for-+  copy-of-code-for-exit
16:22:23 <sorear> the advantage being that the computed goto in the copy of lit will *always* vector into +, etc.  so branch prediction works a little better.
16:22:45 <kc5tja> errr
16:22:49 <kc5tja> that's just DUMB.
16:22:58 <kc5tja> Why not go with a full RAFTS implementation then?
16:23:33 <kc5tja> I'd suggest it, but unfortunately, Anton can be a pompous moron.
16:24:42 <sorear> Anton == maint of gforth?
16:24:59 <kc5tja> Yes.
16:25:32 <kc5tja> He thinks he's pretty much God's Gift to the Forth Community because, Oooh, look at him, he wrote GNU Forth, and is on the ANSI committee.
16:25:36 <kc5tja> pffft.  Whatever.
16:25:47 <kc5tja> He's fine as long as you pretend to be his disciple.
16:26:01 <kc5tja> As soon as you've an opinion of your own, though, you're not worth his time to talk to.
16:26:45 <sorear> What's the generally nicest (i386-linux) hosted forth?
16:27:27 <kc5tja> GForth.  I don't have problems with the product.  Only the maintainer's attitude.  :)
16:27:52 <sorear> OK.  I just understand people like that tend to induce stagnation :)
16:28:18 <kc5tja> Well, GForth has been in the 0.x range since it was first introduced in 1995 or so.
16:28:21 <kc5tja> (give or take a year)
16:28:34 <kc5tja> So you might as well just drop the initial 0. prefix.
16:31:05 <davidL> > let {p n = n*(3*n-1)`div`2; isP n=(\x->x^2==24*n+1&&x`mod`6==5)$floor(sqrt(24*(from Integral n)+1))} in head [p1 - p2|n1<-[1..], n2<-[1..n1-1], p1<-[p n1],p2<-[p n2],isP$p1-p2,isP$p1+p 2]
16:31:06 <lambdabot>   Not in scope: data constructor `Integral'
16:31:26 <davidL> > let {p n = n*(3*n-1)`div`2; isP n=(\x->x^2==24*n+1&&x`mod`6==5)$floor(sqrt(24*(fromIntegral n)+1))} in head [p1 - p2|n1<-[1..], n2<-[1..n1-1], p1<-[p n1],p2<-[p n2],isP$p1-p2,isP$p1+p 2]
16:31:32 <lambdabot> Terminated
16:35:15 <ariep> is hs-plugins known to work with ghc-6.6 on amd64?
16:35:36 <sorear> Yes.
16:35:52 <sorear> don't bother with the tarball on ghc-6.6 on anything
16:36:09 <ariep> i tried hs-plugins-1.0_rc0
16:36:37 <ariep> but i get unknown symbols when running my program
16:37:59 <ariep> should i use another version?
16:39:30 <Saizan> i'd try to get from the darcs repo
16:40:19 <ariep> ok
16:47:56 <jcreigh> hmm. What's my best bet for a Haskell curses binding? It doesn't look like there's a library proper, but bindings seems to be included in hmp3 and ginsu (http://repetae.net/john/computer/ginsu/)
16:47:57 <lambdabot> Title: Ginsu
16:49:02 <jcreigh> but looking at the code, they don't seem to be derived from one another...so which one should I use? Or is there a real library somewhere?
16:51:26 <sorear> jcreigh: hscurses
16:51:38 <sorear> @where hscurses
16:51:38 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
16:52:18 <jcreigh> sorear: thank you!
16:52:28 <sorear> you're welcome?
16:52:44 <jcreigh> hmm, hscurses is not in hackage.
16:52:57 <jcreigh> which explains why I didn't find it.
16:54:32 <jcreigh> oh, wow, hpodder is written in Haskell? I had no idea. I was using it strictly on its merits.
16:55:45 <dmwit> ?users
16:55:46 <lambdabot> Maximum users seen in #haskell: 336, currently: 303 (90.2%), active: 38 (12.5%)
17:01:52 <dmwit> ?botsnack
17:02:01 <lambdabot> :)
17:02:57 <araujo> hello :-)
17:03:02 <sorear> hello!
17:06:35 <lispy> hpodder?
17:06:53 <lispy> oh
17:17:37 <greenrd> d'oh
17:17:59 <greenrd> I am trying to use zeroTH (a little-known tool) on my template haskell code
17:18:24 <greenrd> but I am getting: Template Haskell error: Can't do `reify' in the IO monad
17:18:40 <drigz> @users
17:18:41 <lambdabot> Maximum users seen in #haskell: 336, currently: 304 (90.5%), active: 38 (12.5%)
17:18:56 <greenrd> I guess it's because I'm using reify, and zeroTH tries to run my TH code in the IO monad
17:19:21 <drigz> how can i eliminate the subexpression a*b in [a*b | a <- as, b <- bs, a*b < limit]?
17:19:43 <drigz> i was thinking make aTimesB <- [a*b] but it's not very pretty
17:19:51 <drigz> *maybe
17:22:18 <davidL> > Data.IntSet.intersection (Data.IntSet.fromList [1..50]) (Data.IntSet.fromList [24..43])
17:22:20 <lambdabot>  fromList [24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]
17:22:57 <lispy> greenrd: hmr
17:23:13 <drigz> @src (\\)
17:23:14 <lambdabot> (\\) = foldl (flip delete)
17:23:20 <lispy> greenrd: maybe you need to unsafePerformIO something :)
17:23:27 <greenrd> heh
17:23:57 <Botje> drigz: [ab | a <- as, b <- bs, let ab = a*b, ab < limit]
17:24:13 <davidL> do I need to import anything if I do statements such as Data.IntSet.intersection ?
17:24:45 <lispy> greenrd: but actually, i never knew TH had a refiy constraint on the IO monad
17:24:47 <Apocalisp> Hey, that looks kind of cool ^^^
17:24:48 <drigz> Botje: ah, thanks!
17:24:59 <lispy> greenrd: i'm far from a TH expert, but i've used it before...
17:25:03 <drigz> should have tried that before i asked, really. oh well
17:25:58 <greenrd> well, of course, usually TH code is run by GHC
17:26:03 <greenrd> during compilation I mean
17:26:15 <LoganCapaldo> davidL: you need to import Data.IntSet
17:26:15 <greenrd> which causes no problems
17:26:33 <greenrd> but zeroTH tries to use runQ, which isn't compatible with reify
17:27:08 <davidL> LoganCapaldo: thanks
17:27:15 <greenrd> d'oh
17:27:20 <greenrd> I don't think there's any solution for this
17:27:39 <greenrd> short of hacking on template-haskell
17:30:12 <greenrd> I guess qReify in the IO monad could start a GHC session using the GHC API(!)... but wait
17:30:33 <greenrd> how would it know what the imports were? it wouldn't
17:30:57 <greenrd> this is a basic problem with the phase distinction - zeroTH breaks the phase distinction
17:31:07 <greenrd> tries to run compile-time code at runtime
17:32:31 <greenrd> hmm
17:33:28 <lispy> greenrd: maybe it's time to talk to the author :)
17:33:33 <lispy> what does zeroTH do?
17:33:39 <lispy> maybe i should just look it up
17:33:46 <greenrd> it has two purposes
17:34:17 <lispy> ?where zeroth
17:34:18 <lambdabot> I know nothing about zeroth.
17:34:19 <greenrd> removes the necessity of linking to the template-haskell package; and makes it possible to run haddock on your source code
17:34:26 <lispy> Oh
17:34:34 <lispy> i don't think you need zeroTH to do the second one
17:34:40 <greenrd> really?
17:34:43 <lispy> seems like i had a hack for that
17:34:56 <lispy> i used a preprocessor
17:34:59 <lispy> the cpp
17:35:09 <greenrd> interesting
17:35:19 <lispy> haddock just needs the function signatures
17:35:22 <greenrd> what, you disabled the th code if running haddock?
17:35:26 <lispy> yeah!
17:35:29 <greenrd> ok
17:36:03 <lispy> my ideas aren't always good but they're often resourcefull ;)
17:36:07 <greenrd> but I'm generating instances
17:36:23 <lispy> well, maybe you should be using DriFT
17:36:25 <greenrd> not that important, but I'd like the haddock docs to be correct
17:36:35 <greenrd> maybe
17:36:39 * LoganCapaldo thinks it would be immensely useful if these *doc apps were part of the compiler for the given language, and if comments were kept in the AST
17:36:56 <lispy> LoganCapaldo: there was some work last year to make haddock part of ghc
17:36:59 <lispy> i thought anyway
17:37:05 <lispy> i wonder what happened with that
17:37:15 <hpaste>  ptolomy pasted "haskell-made compiler braggary" at http://hpaste.org/1804
17:37:32 <LoganCapaldo> If I ever design a language (hah!) that will certainly be one of the features
17:37:47 <lispy> ptolomy: cool
17:38:10 <lispy> ptolomy: i made an optimizing bf compiler for lambdabot, we should compare notes
17:38:37 <lispy> ptolomy: my optimizes at the instruction level...you're look to be a bit more powerful
17:38:40 <LoganCapaldo> ptolomy: Wow.
17:38:50 <LoganCapaldo> that's pretty awesome
17:39:20 <ptolomy> I'm having a hard time convincing my girlfriend that a (somewhat) sophisticated optimizing brainfuck compiler in haskell is an interesting or worthwhile thing for me to do, particularly on a friday night. :-P
17:39:44 <sjanssen> @remember ptolomy I'm having a hard time convincing my girlfriend that a (somewhat) sophisticated optimizing brainfuck compiler in haskell is an interesting or worthwhile thing for me to do, particularly on a friday night. :-P
17:39:44 <lambdabot> Done.
17:39:51 <LoganCapaldo> ptolomy: how bad does the generated code get once you start throwing in input?
17:39:51 <ptolomy> I should note that the non-"puts" lines are boilerplate. I don't check to verify that the buffer is needed, because it pretty much always is.
17:40:25 <LoganCapaldo> presumably the C compiler will handle that biolerplate :)
17:40:47 <drigz> doesn't puts automatically append a newline on its own?
17:41:17 <drigz> maybe that code is meant to double space, i don't feel like reading the bf :p
17:41:54 <ptolomy> LoganCapaldo: Pretty ugly.. I'll give an example in a C-aware pastiebot.
17:42:56 <jcreigh> ptolomy: that's seriously cool.
17:43:01 <jcreigh> unless your yanking our chains. :)
17:43:06 <jcreigh> *you're
17:43:42 <hpaste>  sorear pasted "for kc5tja: copy bytes at 4 cycles each (mvn is 7cy/ea)" at http://hpaste.org/1805
17:44:42 <ptolomy> LoganCapaldo: http://paste.lisp.org/display/41090  (There are still some pretty obvious optimizations available.. I need to rework my data flow analysis entirely)
17:44:58 <ptolomy> Still, it is an example with IO.
17:46:16 <LoganCapaldo> ptolomy: if theres no io at all does it optimize the code to nothing?
17:46:54 <ptolomy> LoganCapaldo: Hah. No, not yet. I considered doing as much partial evaluation as I can managed, but I still don't have the dependency handling worked out enough to make it non-clumsy.
17:47:37 <LoganCapaldo> Have you fed it bf-in-bf yet?
17:47:48 <ptolomy> The compiler also includes a high-speed interpreter that runs about 2x faster (for complicated code) than a naive C interpreter. total weight (including blanks, comments, commented-out nonsense) is 500 lines.
17:47:57 <ptolomy> ooh. no, I should try that. It'll be a good benchmark.
17:48:43 <Sgeo> "Note that there is no function:
17:48:44 <Sgeo> unsafe :: IO a -> a
17:48:44 <Sgeo> as this would defeat the referential transparency of Haskell -- applying unsafe to the same IO action might return different things every time, and Haskell functions aren't allowed to behave that way. "
17:48:48 <Sgeo> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:48:49 <lambdabot> Title: Introduction to IO - HaskellWiki
17:48:49 <Sgeo> LIES!
17:49:08 <ddarius> Sgeo: There isn't in Haskell 98 - the FFI Addendum.
17:49:11 <Sgeo> @ty unsafePerformIO
17:49:13 <lambdabot> Not in scope: `unsafePerformIO'
17:49:54 <sjanssen> @palomer
17:49:54 <lambdabot> That's nuts!
17:49:55 <jcreigh> Sgeo: I don't know...unsafePerformIO is a convienient kludge. Newbies don't need to know about it right away.
17:50:18 <LoganCapaldo> well there really is no functuion unsafe :: a -> IO a :)
17:50:27 <sorear> Experienced assembly hackers with a history of stack pointer abuse, though ...
17:50:40 <LoganCapaldo> unless you type something like let unsafe = unsafePerformIO
17:50:56 <Korollary> I like this inline assembly monad
17:51:17 <sorear> LoganCapaldo: I think the Forth types put it best.  As soon as you enter a definition, you're using a different languages.
17:51:19 <sorear> -s
17:51:50 <miky> why programming in haskell ?
17:52:10 <mauke> why not?
17:52:11 <rashakil> because it's there
17:52:12 <sorear> miky: I don't understand?
17:52:36 <sorear> miky: 'why' does not apply to noun phrases
17:52:56 <sorear> programming in haskell is a noun phrase (specifically a gestund)
17:53:20 <miky> i read that is a functional language
17:53:41 <ariep> hs-plugins now works for me again, so i've succesfully migrated to ghc-6.6 :)
17:53:46 <ariep> thanks sorear and Saizan
17:54:25 <miky> what area is indicated this language ?
17:56:19 <MyCatVerbs> miky: read YAHT. That should explain it pretty decently.
17:57:00 <kilimanjaro> @google yet another haskell tutorial
17:57:03 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
17:57:18 <MyCatVerbs> miky: y'know how, in C, lots of functions have side effects? Like, make a call to fwrite(...), it returns the number of bytes successfully written, and it writes some bytes to a file. That's an example of a side effect.
17:57:33 <ddarius> "gestund" ?
17:57:42 <ddarius> gerund you mean
17:57:53 <sorear> Probably.
17:58:23 * LoganCapaldo was just gonna say what ddarius said
17:58:32 * LoganCapaldo is a slowpoke
17:58:34 <sorear> Yep.
17:58:44 * olsner could also have said it
17:59:01 <LoganCapaldo> But I also googled to make sure my memory wasn't faulty heh
17:59:01 <greenrd> lispy: now, even worse, I turned off zeroTH, and reify doesn't work at all for me
17:59:22 * ddarius googled too.
17:59:24 <miky> MyCatVerbs: in haskell there isn't side effect ?
17:59:30 <LoganCapaldo> wow I really am slow
17:59:47 <greenrd> lispy: maybe I'll just do [| () :: (Type1, Type2, Type3) |] - ugh
17:59:51 * ddarius only google to see if "gestund" was some crazy grammar term he hadn't heard of.
17:59:59 <drigz> i wish @pl could handle tuples of size greater than 2
18:00:07 <LoganCapaldo> yeah i googled for gestund, and then gerund
18:00:08 <ddarius> drigz: Hack it.
18:00:08 <greenrd> at least that should work to input my types into the th function
18:00:10 <drigz> that should have been a SoC project
18:00:42 <Sgeo> @djinn RealWorld -> ((), RealWorld)
18:00:42 <lambdabot> f a = ((), a)
18:00:49 <Sgeo> >.>
18:00:56 <ddarius> drigz: It's been done a long long time ago.  Just not for @pl.
18:01:15 <drigz> ddarius: i looked at @pl once, but i was completely baffled
18:01:19 <olsner> (gerund is sometimes more commonly known as "ing-form", at least when talking about english)
18:01:20 <MyCatVerbs> miky: no. That's the idea. Functions don't have side effects, ever.
18:01:23 <drigz> still, it's something to work towards
18:01:49 <LoganCapaldo> there are side effects in haskell.
18:02:02 <ddarius> drigz: From what I hear, @pl is poorly or at least crazily written.
18:02:02 <sorear> LoganCapaldo: shhh!
18:02:06 <LoganCapaldo> they're just quarrantined
18:03:01 <sjanssen> nope, no side effects in Haskell
18:03:25 <sjanssen> but most compilers are packaged with a handy IO-value interpreter :)
18:03:47 <sorear> GHC's IO-value interpreter is DEFORESTED!
18:04:04 <LoganCapaldo> sjanssen: even w/o a handy IO value interpreter don't you still have things like IORefs ?
18:04:06 <miky> umhh i think that i read YAHT
18:04:40 <sjanssen> LoganCapaldo: IORefs don't necessarily mean side effects.  See IOSpec
18:04:43 <sjanssen> @where iospec
18:04:44 <lambdabot> I know nothing about iospec.
18:05:07 <sjanssen> @where+ iospec http://www.cs.nott.ac.uk/~wss/repos/IOSpec/
18:05:08 <lambdabot> Done.
18:05:20 <LoganCapaldo> I feel liek I've come across this before
18:05:33 <sorear> it was on the ML
18:05:43 <LoganCapaldo> ah this cool
18:05:44 * sjanssen adds this to his favorites http://www.cs.nott.ac.uk/~wss/repos/IOSpec/www/unsafe.jpg
18:05:47 <LoganCapaldo> ok you win :)
18:06:48 * ptolomy gives in to the woman and steps away from the terminal.
18:06:50 <ptolomy> later.
18:06:55 <sjanssen> that sign is almost as good as the EuroHaskell signs
18:06:57 <LoganCapaldo> nooooo!
18:07:34 <LoganCapaldo> ah I didn't see IOSpec, I skimmed the "A functional semantics for the awkward squad" paper at some point
18:13:44 <ariep> bye
18:20:34 <davidL> does Data.IntSet.filter ever "miss" anything?
18:24:16 <jcreigh> @hoogle [a] -> [a] -> Bool
18:24:17 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:24:17 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:24:27 <jcreigh> hmm. Is there no isInfixOf?
18:24:33 <mauke> there is in 6.6
18:26:17 <jcreigh> mauke: thank you
18:26:39 <drigz> mauke: do you know how it is implemented?
18:27:02 <sorear> do we CARE how it is implemented?
18:27:11 <drigz> sorear: speed-wise
18:27:37 <sorear> isInfixOf               :: (Eq a) => [a] -> [a] -> Bool
18:27:37 <sorear> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
18:28:13 <drigz> thanks :(
18:28:30 <drigz> i guess i can't expect the world from a standard library
18:40:55 <beelsebob> @dice 3d6 + 1d10
18:40:55 <lambdabot> 3d6 + 1d10 => 17
18:41:24 <LoganCapaldo> drigz: I have a faster broken one :)
18:41:25 <ddarius> @dice 3d6 * 1d10
18:41:26 <lambdabot> unexpected "*": expecting digit, "+" or end
18:41:43 <LoganCapaldo> the broken part kind of ruins it though
18:41:57 * ddarius has an even faster broken one, \a b -> True
18:43:02 <LoganCapaldo> ddarius: that is faster its true
18:43:14 <LoganCapaldo> and its right 50% of the time
18:43:28 <LoganCapaldo> I'm not sure mine has that high of a success rate
18:44:04 <LoganCapaldo> although I'm pretty sure mine never gives false positives only false negatives
18:44:26 <ddarius> Fine, \a b -> False
18:45:15 <LoganCapaldo> heh
18:45:45 <drigz> @src delete
18:45:46 <lambdabot> delete = deleteBy (==)
18:45:49 <drigz> @src deleteBy
18:45:50 <lambdabot> Source not found. My pet ferret can type better than you!
18:45:57 <drigz> :(
18:46:08 <LoganCapaldo> its a conspiracy
18:46:09 <Pseudonym> lambdabot: You do not have a pet ferret, liar.
18:46:10 <drigz> @source List
18:46:11 <lambdabot> List not available
18:46:16 <drigz> @source Data.List
18:46:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:48:15 <ddarius> @index delete
18:48:16 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
18:48:18 <ddarius> @index deleteBy
18:48:19 <lambdabot> Data.List
18:48:37 <LoganCapaldo> pretty: xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
18:52:18 <drigz> optimisation is so addictive
18:52:36 <drigz> i just spent 2 hours doing it, but i sped this program up 20x
18:53:06 <drigz> i said 'i'll just try this one thing, then i'll go to bed' at the start of those 2 hours
18:53:35 <chessguy> what kind of program
18:53:43 <sorear> > let { isInfixOf a b = let { bl = length b ; bm = 31^bl ; a' = map ord a ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (drop (length a')  b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*bm) ih b' } in elem ih (drop 1 hashes) } in isInfixOf "aaa" "fooaaaabbb"
18:53:45 <lambdabot>  Couldn't match expected type `(Int, Int)'
18:53:52 <drigz> chessguy: something for project euler
18:54:27 <ddarius> drigz: "I'll just try this one thing..." that's how it always starts.
18:54:43 <drigz> if anyone has a faster permutations than:
18:54:48 <drigz> concat [map (x:) (permutations (delete x xs)) | x <- xs]
18:54:56 <drigz> i'd love to hear
18:55:40 <sorear> > let { isInfixOf a b = let { bl = length b ; bm = 31^bl ; a' = map ord a ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (drop (length a')  b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*bm) ih pairs } in elem ih (drop 1 hashes) } in isInfixOf "aaa" "fooaaaabbb"
18:55:42 <lambdabot>  False
18:55:58 <sorear> :)
18:56:32 <beelsebob> how do I resolve Could not find module `Data.ByteString.Char8': it was found in multiple packages: fps-0.8 base
18:57:26 <sorear> beelsebob: uninstall fps
18:57:37 <beelsebob> sorear: I have a virgin ghc-6.6 install
18:58:15 <sorear> beelsebob: You haven't installed *anything* for this version of ghc?
18:58:32 <beelsebob> only thing I've added is zlip-0.3
18:59:22 <beelsebob> ghc-pkg unregister fps does seem to have done the trick though :/
19:01:10 <beelsebob> @where arrows
19:01:10 <lambdabot> http://www.haskell.org/arrows/
19:02:13 <beelsebob> o.O
19:02:23 <beelsebob> the Setup.hs for arrows doesn't work
19:02:58 <sorear> > let { isInfixOf a b = let { al = length a ; am = 31^al ; a' = map ord a :: [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf "oba" "foobar"
19:03:04 <lambdabot>  True
19:03:05 <sorear> > let { isInfixOf a b = let { al = length a ; am = 31^al ; a' = map ord a :: [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf "oba" "foobir"
19:03:07 <lambdabot>  False
19:03:21 <sorear> There, Karp-Miller
19:03:34 <beelsebob> anyone know where I can get a working version of arrows?
19:03:35 <LoganCapaldo> Nooooo
19:03:44 * LoganCapaldo has been spoiled
19:03:47 <LoganCapaldo> ah well
19:03:51 <LoganCapaldo> :)
19:04:27 <sorear> Er, Rabin-Karp
19:04:37 <sorear> LoganCapaldo: eh?
19:05:03 * ddarius has been spoiled as well.
19:05:26 <beelsebob> anyone?
19:05:28 <LoganCapaldo> sorear: I was trying to come up with it myself, as you may recall :)
19:05:29 <beelsebob> noone?
19:05:37 <ddarius> beelsebob: GHC
19:05:47 <monochrom> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows-0.2
19:05:50 <lambdabot> http://tinyurl.com/2z6ftm
19:06:00 <beelsebob> o.O
19:06:16 <beelsebob> so why is lambdabot complaining that it has no arrows
19:06:17 <sorear> LoganCapaldo: You were trying to implement KMP, iirc.
19:06:28 <sorear> KMP and RK are *very* different
19:06:43 <beelsebob> Setup.hs: cannot satisfy dependency arrows-any
19:07:04 <LoganCapaldo> sorear: well actually I was trying to come up with an efficient infixof, not any specifc one. Plus I'm sort of joking anyway
19:07:15 <LoganCapaldo> It's not like I memmorized that "one-liner"
19:07:18 <drigz> sorear: you manage it yet?
19:09:07 <drigz> oh my bad, you did
19:09:16 <drigz> i should have checked scrollback
19:09:34 <beelsebob> @paste
19:09:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:09:37 <sorear> drigz: My algorithm is subtly wrong.  I assume  hash(X)=hash(Y)  <->   X = Y
19:10:07 <hpaste>  beelsbob pasted "hnuh?" at http://hpaste.org/1806
19:10:22 <beelsebob> anyone got any good ideas why that fails?
19:10:51 <drigz>  > let { isInfixOf a b = let { al = length a ; am = 31^al ; a' = map ord a :: [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf "ooo" "ooa"
19:11:10 <drigz> sorear: you just need to change 31 to 256 :p
19:11:20 <drigz> oh, there's a :: [Int] now
19:11:50 <LoganCapaldo> @type let { isInfixOf a b = let { al = length a ; am = 31^al ; a' = map ord a :: [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf
19:11:54 <drigz> sorear: it sure concise, though, which outweight a little bit of inaccuracy
19:11:58 <lambdabot> [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf :: [Char] -
19:11:59 <lambdabot> > [Char] -> Bool
19:12:12 <drigz> > let { isInfixOf a b = let { al = length a ; am = 31^al ; a' = map ord a :: [Int] ; b' = map ord b ; ih = foldl (\a b -> a * 31 + b) 0 a' ; pairs = zip b' (a' ++ b') ; hashes = scanl (\h (i,o) -> h*31 + i - o*am) ih pairs } in elem ih (tail hashes) } in isInfixOf "ooo" "ooa"
19:12:13 <lambdabot>  True
19:12:21 <drigz> goodnight
19:23:17 <Sgeo> If I declare the compare thing when making an instance of Ord, do I need to define (==) and make the thing an instance of Eq?
19:23:25 <Sgeo> Or does making it Ord do it automatically?
19:24:23 <ddarius> You need to define Eq.
19:24:41 <ddarius> Though I guess you could define it as a == b = a <= b && b <= a
19:24:47 <ddarius> That should work...
19:26:21 <Sgeo> ty
19:28:57 <beelsebob> surely compare a b == EQ would be better
19:29:37 <ddarius> Whatever floats your boat.
19:30:17 <beelsebob> I tend to use compare as much as I can, because using the others is not 100% reliable
19:30:28 <beelsebob> wheras if you have compare you're guarenteed to have the others
19:35:12 * Sgeo is practicing making Peano numbers
19:35:26 * Sgeo fears that some of what he wrote is inefficient
19:35:35 * ddarius is cursing the fast growth of the exponential function.
19:36:13 * LoganCapaldo is confused.
19:36:26 <LoganCapaldo> Wouldn't efficient Peano numbers be a contradiction?
19:37:09 <ddarius> No.  No one says you have to use the "free" model.
19:37:34 <skew> newtype Peano = Peano Integer ...
19:38:04 <skew> some of the epigram papers talk about how they optimize at least the data representation
19:43:36 * ddarius -really- doesn't want to know how many stitches the next round would be...
19:45:20 <Sgeo> show (Succ a) = show $ 1 + read (show a)
19:45:23 * Sgeo shoots self
19:47:35 <skew> show peano = show (toInteger peano) is a bit better
19:47:47 <skew> toInteger (Succ n) = 1 + toIntger n
19:47:48 <Sgeo> Where do I define toInteger ?
19:48:23 <skew> that name is actually a method of Num, but you could define another function
19:48:40 <Sgeo> Can I define the function in a where clause?
19:48:49 <skew> the first is just O (n log n), but the constant's pretty awful
19:48:55 <skew> yeah, that works too
19:48:56 <ddarius> Not as an instance of Num, but sure...
19:49:13 <skew> you have to call it something else if you are not making a Num instances
19:49:28 <ddarius> Not in a where clause.
19:49:29 <Sgeo> It is a Num instance
19:49:42 <Sgeo> just not an Integral instance
19:50:03 <skew> oops, toInteger is a method of Integral
19:50:12 <ddarius> @src Integral
19:50:13 <lambdabot> class  (Real a, Enum a) => Integral a  where
19:50:13 <lambdabot>     quot, rem, div, mod :: a -> a -> a
19:50:13 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
19:50:13 <lambdabot>     toInteger           :: a -> Integer
19:51:03 * Sgeo thinks it would be cheating to use toInteger to define quotRem
19:51:31 <ddarius> Yes, arguably it would.  However, you can define them "directly".
19:52:17 * Sgeo doesn't know how
19:53:31 * Sgeo decides to just define a toI
19:56:40 <Sgeo> numbers = iterate Succ Zero
19:57:18 <LoganCapaldo> that doesn't type check does it?
19:57:36 <Sgeo> @ty iterate
19:57:38 <lambdabot> forall a. (a -> a) -> a -> [a]
19:57:42 <jcreigh> LoganCapaldo: given data N = Zero | Succ N I believe it does
19:57:52 <LoganCapaldo> ahar
19:58:09 <Sgeo> Succ :: Peano -> Peano
19:58:15 <Sgeo> Zero :: Peano
19:58:22 <LoganCapaldo> I was thinking data Zero. data Succ a = Succ a
19:58:29 <LoganCapaldo> silly me
19:59:22 <Flaran> you guys may get this a lot, but do you have any good suggestions for haskell tutorials or intros to the language?
20:00:26 <sorear> yaht?
20:00:49 <sorear> never actually read it, but I've heard a lot of praise
20:00:57 <Korollary> the metatutorial
20:01:03 <Korollary> @where metatutorial
20:01:04 <lambdabot> I know nothing about metatutorial.
20:01:06 <Korollary> lies
20:01:10 <sorear> @google haskell metatutorial
20:01:13 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
20:01:13 <lambdabot> Title: Meta-tutorial - HaskellWiki
20:01:13 <Sgeo> http://www.haskell.org/haskellwiki/Meta-tutorial
20:01:14 <lambdabot> Title: Meta-tutorial - HaskellWiki
20:01:33 <Sgeo> @help url
20:01:33 <lambdabot> url <key>. Return element associated with key
20:01:35 <sorear> @where+ metatutorial http://www.haskell.org/haskellwiki/Meta-tutorial
20:01:36 <lambdabot> Done.
20:01:37 <Flaran> aah, I would have googled it, but that's pretty cool.
20:01:42 <sorear> @where meta-tutorial
20:01:42 <lambdabot> I know nothing about meta-tutorial.
20:01:46 <sorear> @where+ meta-tutorial http://www.haskell.org/haskellwiki/Meta-tutorial
20:01:47 <lambdabot> Done.
20:02:16 <Flaran> well if you didn't read it, sorear, how did you go about learning?
20:02:37 <Sgeo> YAHT > Haskell for C Programmers imo
20:02:39 <Korollary> average haskell learner reads 3-4 different tutorials.
20:02:45 <sorear> Flaran: I do not know how this brain of mine works.
20:03:09 <MyCatVerbs> Sgeo: but YAHT is full of gaps. :/
20:03:11 <sorear> In any case, I didn't know there would be a test :)
20:03:41 <Flaran> all tutorials have gaps, mycat
20:03:53 <MyCatVerbs> Flaran: gaping, explicit holes.
20:03:57 <Flaran> i'll be looking at more than one.
20:04:06 <MyCatVerbs> Referred-to sections which do not exist.
20:04:20 <Korollary> if you are patient enough, the language report is worth reading along/
20:04:40 <MyCatVerbs> Korollary: !!!
20:04:48 <Korollary> It's too detailed, but there are no gaps at least
20:04:55 <skew> Or, read the Gentle Introduction and refer to the report for details
20:04:56 <MyCatVerbs> Korollary: sure thing, assuming you're talking R5RS. :P
20:05:23 <Korollary> Not really. Ocaml tutorials pissed me off, so I went for the language definition directly. Didn't regret that choice.
20:05:24 <MyCatVerbs> skew: the Gentle Introduction seems like a decent follow up to YAHT and HHGH.
20:05:34 <MyCatVerbs> Korollary: oh, fair enough.
20:05:53 <MyCatVerbs> Korollary: though I think R5RS ought to be mentioned as a special case. Awesome language spec. ^_^
20:06:10 <Korollary> Yes, R5RS is good.
20:06:51 <ddarius> MyCatVerbs: The Haskell Report is pretty readable throughout most of it.
20:07:10 <Korollary> If you already know scheme, you're likely to go through things easier. The tricky bits will be about the type system mostly.
20:07:13 <Sgeo> Wha's R5RS?
20:07:23 <ddarius> @google r5rs
20:07:26 <lambdabot> http://www.schemers.org/Documents/Standards/R5RS/
20:07:26 <lambdabot> Title: schemers.org: Documents: Standards: R5RS
20:07:30 <MyCatVerbs> Sgeo: Revised^5 Report on Scheme
20:08:20 <hpaste>  petekaz pasted "could all of the DB arguments be eliminated in this example by using ReaderT?" at http://hpaste.org/1807
20:08:28 <MyCatVerbs> Sgeo: it's the current standard for Scheme implementations. All actual implementations extend on it, some quite a lot, but anyway. It's awesome. Only fifty pages long, and that's fifty pages of well-written, largish font PDF. ^^
20:08:40 <ddarius> petekaz: Sure.
20:08:58 <Sgeo> ew ew ew PDF
20:09:04 <Korollary> There are html versions
20:09:09 <Sgeo> ah
20:09:11 <petekaz> I'm reading a blog entry from planet haskell, and I've been learning about monad transformers, but I tried to make it work with ReaderT, but I got stumped.
20:09:17 <Korollary> plt scheme distribution has it in html iirc
20:09:21 <shapr> What's the advantage of PDF over PostScript? I mean, other than DRM?
20:09:42 <skew> easier to view on windows
20:09:51 <MyCatVerbs> shapr: a little more compact. Also, PostScript is Turing-complete, PDF isn't.
20:09:54 <ddarius> Acrobat Reader is a -much- nicer experience than any PS reader I've used on Windows.
20:10:00 <Korollary> shapr: I think I saw somethings on wikipedia as to technical merits. Don't remember off the top of my head.
20:10:08 <shapr> MyCatVerbs: Is ps.gz more compact than pdf?
20:10:28 <Korollary> ps.gz is slightly more compact in my experience, but it doesn't really matter in this day and age eh?
20:10:28 <shapr> ddarius: Acrobat Reader is pretty painful on Linux.
20:10:29 <MyCatVerbs> shapr: not sure. I think they're roughly on-par, usually.
20:10:34 <ddarius> shapr: ps can be arbitrarily more compact than pdf and technically should only be worse by a constant factor.
20:10:36 <ddarius> shapr: I know.
20:10:57 <ddarius> "arbitrarily" within the bounds of information theory.
20:11:11 <ddarius> PDF -is- PS.
20:11:14 <shapr> It is?
20:11:28 <shapr> Huh, I'll have to read up on this.
20:11:33 <ddarius> The PDF format is a subset of postscript.
20:11:41 <ddarius> I.e. it's implementable by implementing a library in postscript
20:11:42 <Korollary> "PDF (starting from version 1.4) supports true transparency while PostScript does not"
20:12:31 <petekaz> ddarius: I got stumped on the forkIO line.  It needs to take a IO action, but I want loginServer to be of my ReaderT type.  Do I have to call runReader again at that point?  It seems strange that I'd first have to extract the db var at the start of the 'handler' function, and then call runReader and pass it as an arg.
20:13:41 <ddarius> petekaz: That should work fine and seems reasonable.
20:14:26 <petekaz> Ok .. I'll try to modify it and paste what I have, perhaps you could take a peek after I finish.
20:15:07 <sorear> PDF is more structured, and simpler.
20:15:17 <sorear> You can do random access on PDF's easier.
20:15:30 <ddarius> Ah... patching the xref table...
20:16:23 <skew> Is it possible to implement withDynamic :: Dynamic -> (forall t . (Typeable t) => t -> a) -> a?
20:16:49 <sorear> skew: Yes.
20:17:14 <skew> It's quite easy with the existential definition data Dynamic = forall t . (Typeable t) => Dynamic t
20:17:32 <sorear> skew: it won't be pleasant though - you'll need unsafeCoerce#
20:18:03 <skew> I don't see how to do it even with that - the idea is that the continuation will be applied at the type of the thing in the dynamic
20:18:14 <sorear> Right.
20:18:20 <skew> unless you plan to use unsafeCoerce# to expose dictionary passing?
20:18:24 <skew> eww
20:18:32 <sorear> is right.
20:18:41 <skew> does that even work?
20:19:21 <ddarius> skew: Sure, if you make enough assumptions about the representation the compiler uses.
20:19:23 <sorear> it should, provided you know what you are doing
20:19:34 <sorear> ddarius: we have -cpp :)
20:20:01 <skew> well, I did implement addressOf with unsafeCoerce#
20:20:06 <ddarius> jhc
20:20:27 <Sgeo> What's unsafeCoerce#?
20:20:33 <skew> black magic
20:20:38 <skew> run away
20:20:39 <ddarius> Sgeo: You really really don't want to know.
20:20:51 <MyCatVerbs> Sgeo: it's marked unsafe.
20:20:53 <Sgeo> ddarius, can it be any worse than unsafePerformIO?
20:21:00 <MyCatVerbs> Sgeo: in most languages, that means, "mousetraps."
20:21:00 <sorear> Sgeo: No.
20:21:07 <MyCatVerbs> Sgeo: in Haskell, that means, "nukes."
20:21:10 <ddarius> Sgeo: Yes and no.  You can implement it with unsafePerformIO (and IORefs)
20:21:27 <ddarius> And you can implement unsafePerformIO with it...
20:22:08 <skew> sorear: well, and Eq dict is apparently not just ==
20:22:11 <ddarius> But unsafeCoerce# is much more likely to lead to segfaults and memory errors and all the other joys of C programming than unsafePerformIO.
20:22:15 <LoganCapaldo> ddarius: you can meaningfully do unsafePerformIO w/ it?
20:22:18 <ddarius> skew: Obviously.
20:22:23 <sorear> skew: Right.  You need a box too!
20:22:30 <Sgeo> Oh, the joys of IO a -> a!!
20:22:32 <skew> Ah, I forgot about /=
20:22:32 <sorear> LoganCapaldo: Sure!
20:22:37 <ddarius> LoganCapaldo: If you know enough about IO.
20:22:47 <skew> sorear: I think ghc optimizes single-argument dictionaries
20:22:54 <ddarius> unsafeCoerce# :: IO a -> a won't work.
20:22:56 <skew> single-member dictionaries, that is
20:22:59 <sorear> skew: -ddump-simpl and remove all doubt.
20:23:10 <Sgeo> Are IORef's like C pointers?
20:23:20 <ddarius> Sgeo: No.
20:23:21 <LoganCapaldo> ddarius: yeah thats what I mean. I can't conceive of how to do it
20:23:21 <sorear> Sgeo: More like ML 'ref's .
20:23:32 <Jessehk> Could anyone help me with the correct syntax in this short snippet? http://hpaste.org/1808
20:23:37 <sorear> Sgeo: PLT-scheme's boxes
20:23:38 <skew> ddarius: yeah, but you can coerce it to something like (World -> (a, World)) and apply a fake World
20:23:41 <LoganCapaldo> but I'm probably just ignorant
20:23:51 * Sgeo doesn't know ML
20:24:02 <sorear> skew: Well, GHC's worlds are not pointers ;)
20:24:03 <Sgeo> or PLT-scheme boxes
20:24:03 <skew> LoganCapaldo: er, that was for you
20:24:20 <LoganCapaldo> skew ah ar
20:24:24 <LoganCapaldo> that works
20:24:25 <sorear> Sgeo: what languages do you know?
20:24:30 <LoganCapaldo> thanks
20:24:31 <Sgeo> Python, mostly
20:24:36 <ddarius> Jessehk: Add parens.
20:24:39 <Sgeo> and I know what a C pointer is >.>
20:24:47 <Sgeo> LSL
20:24:51 <Jessehk> ddarius: Where? :)
20:25:01 <ddarius> Shape (Circle a)
20:25:06 <LoganCapaldo> Sgeo: its like the x=[0] trick for closures in python
20:25:20 <sorear> Sgeo: Imagine if you want an out parameter in python, and won't use tuple returns for whatever reason.  What do you do?
20:25:20 <Sgeo> ..ok, maybe I'm not that advanced with Python
20:25:29 <LoganCapaldo> readIORef being x[0] and writeIORef being x[0]=
20:25:33 <Jessehk> ddarius: Lots of new errors. :(
20:25:38 <Sgeo> out parameter?
20:25:53 * sorear covers his face
20:26:03 <jbauman> a parameter you can write to, and the caller can get output from
20:26:17 <jbauman> more useful in C than python...
20:26:17 <SamB_XP_> tuples!
20:26:26 <jbauman> no, no, no tuples
20:26:38 <Jessehk> ddarius: Any other ideas?
20:26:38 <SamB_XP_> they are what you use instead, in both Python and Haskell
20:26:59 <ddarius> Jessehk: Well your code has other type errors.  That part needs to be written that way.
20:27:04 <Sgeo> ???
20:27:19 <SamB_XP_> sorear: you silly
20:28:31 <Jessehk> ddarius: Could you enlighten me on the type errors?
20:28:46 <ddarius> :t pi
20:28:49 <lambdabot> forall a. (Floating a) => a
20:30:02 <jbauman> Sgeo, an ML ref is a changable pointer to an immutable object
20:30:12 <jbauman> oops, too late
20:30:23 <ddarius> Jessehk: Presumably GHC is telling you what it thinks is wrong.
20:31:43 <ddarius> Bloody heck.  An IORef is a mutable variable, only we're being more explicit in the type.
20:34:37 <LordBrain> Jessehk, your area function in the instance is less polymorphic than the one in the class definition
20:34:43 <hpaste>  petekaz annotated "could all of the DB arguments be eliminated in this example by using ReaderT?" with "does this look okay?" at http://hpaste.org/1807#a1
20:35:01 <ddarius> petekaz: Does it compile and do what it's supposed to do?
20:35:10 <petekaz> ddarius: yes.
20:35:27 <petekaz> ddarius: but my question was more along the lines of is it idiomatic?
20:35:34 <ddarius> petekaz: Ok.
20:36:09 <petekaz> And I couldn't figuer out how to carry the reader part to the last 2 functions.
20:37:32 <skew> sorear: with that predicativity, GHC wants to resolve the type before applying unsafeCoerce#
20:37:35 <petekaz> And I think 'handler' looks strange to me, but this could be my unfamiliarity.  In addition, loginServer looks really ugly too.  I'm wondering if the passing of 'db' around explicitly actually looked nicer.
20:37:50 <ddarius> You need a lift instance for STM to ReaderT I believe.
20:38:13 <petekaz> And then call runReaderT again?
20:38:43 <ddarius> No, then just lift e.g. readTVar
20:38:56 <petekaz> so the line atomically $ pushDB name pass db, would become atomically $ runReaderT (pushDB ...) db?
20:39:00 <ddarius> petekaz: What would help a lot is prelifting some functions.
20:39:16 <Jessehk> LordBrain: I don't usually ask for answers, but I don't really know how to fix it in this case.
20:39:22 <ddarius> petekaz: Oh, yes for that, only because of atomically's type.
20:39:45 <petekaz> I don't follow your recommendation about prelifting.
20:39:54 <ddarius> myHPutStr = liftIO hPutStr, e.g.
20:40:01 <petekaz> oh.
20:40:19 <ddarius> That or push the liftIO's inwards or factor out the IO only blocks.
20:40:50 <skew> you might also define MySTM = ReaderT STM
20:41:09 <ddarius> You aren't really using the Reader functionality because you just immediately ask for the db argument and treat it as before.
20:41:28 <ddarius> Ideally, you want to hide ask in helper functions.
20:42:05 <skew> that's what the funky mapReaderT function is for
20:42:05 <petekaz> This is why I am asking.  I am just learning about these transformers.  Could you provide an example?
20:42:16 <ddarius> Actually those three recommendations above (prelifting and such) are not mutually exclusive.
20:42:52 <petekaz> What would be the right way of hiding the db args in the original paste?
20:45:14 <hpaste>  ddarius annotated "could all of the DB arguments be eliminated in this example by using ReaderT?" with "looks like the original create without the db arg" at http://hpaste.org/1807#a2
20:45:51 <ddarius> That said, often explicit passing/scoping is actually nicer than using the Reader monad.
20:46:41 <ddarius> Reader is better when you have different functions spread about that do this kind of thing that need to be combined together or when used in conjunction with other monad (transformers).
20:46:53 <hpaste>  LordBrain pasted "Example for Jessehk" at http://hpaste.org/1809
20:47:16 <petekaz> so MyAtomically is defined as 'lift atomically'?
20:48:01 <LordBrain> Jessehk, that's using -fglasgow-exts
20:48:04 <ddarius> myAtomically m = ask >>= atomically . runReaderT m
20:48:27 <Jessehk> LordBrain: Thanks for the snippet. I'll try to figure it out. :)
20:48:33 <skew> or, mapReaderT atomically
20:48:37 <Jessehk> the snippet, that is
20:48:42 <petekaz> ddarius: hmm .. I need to think about that one
20:49:36 <ddarius> In general with monads, you want to hide the monad operations under a veil of higher-level functions usually producing a DSL like effect.
20:51:14 <petekaz> Someday I'll get to that point ... I'm just happy that I was actually able to even get my crappy version working!
20:52:01 <skew> petekaz: how about just looking at your handler
20:52:50 <petekaz> I should clarify, this isn't my code, its from some recent blog article on planet haskell, but I thought it might be good practice to see if I colud try this monad transformer thing on it.
20:52:57 <petekaz> skew: what do you mean?
20:52:59 <ddarius> petekaz: For a fairly extreme example, look at the tutorial on Harpy http://uebb.cs.tu-berlin.de/harpy/  The end result is beautiful.
20:53:17 <skew> so you get the db with ask, then feed it right back in with runReaderT
20:53:35 <skew> with is pretty much what >>= does
20:54:06 <skew> like do x <- ask; runReaderT stuff x
20:54:08 <petekaz> skew: yes, I got that part now, it just took me a minute to understand it.
20:54:36 <skew> ReaderT arg m a is almost the same thing as arg -> m a
20:54:42 <skew> you're just hiding an argument
20:55:25 <skew> so it's hardly even worth doing unless you're passing the argument around everywhere, and only rarely using it
20:56:10 <petekaz> which is why I thought this might be a good example as the arg is only really used in the last 2 functions.
20:56:30 <skew> ah, well then just make sure you don't mention the argument outside of those last twoo
20:56:42 <petekaz> but my code seemed to force me to extract it everywhere just so I could call runReaderT again.
20:57:06 <petekaz> skew: I couldn't figure that part out!
20:57:15 <skew> then something is wrong, because that's what the plain sequenceing ought to be doing
20:57:24 <skew> monads are all about hiding that sort of plumbing
20:57:35 <skew> did you say you read r5rs?
20:58:07 <petekaz> me? no, isnt' that scheme?
20:58:26 <skew> yeah, I was going to talk about their denotational semantics
20:58:40 <skew> it has a lot of arguments passed around all over the place and rarely used
20:59:28 <petekaz> skew: how would you take the example and write it with ReaderT?
20:59:43 <ddarius> Denotational semantics is where monads (used the way Haskell uses them) arose and R5RS is a model example of what they handle and how typical ones work underneath.
21:00:49 <skew> petekaz: forkIO and atomically are trouble, if you don't use mapReaderT
21:01:00 <skew> and by trouble I mean you would have to use ask and runReaderT
21:02:04 <petekaz> ok ... so one does have to extract the arg everywhere and then call runReaderT again (or mapReaderT as you suggest) in this small example.
21:02:45 <ddarius> petekaz: No.  Just wrap those.
21:02:52 <skew> actually, you can use mapReaderT forkIO
21:02:56 <ddarius> Push the use of ask downwards.
21:03:24 <skew> ddarius: using forkIO :: IO a -> IO ThreadId on ReaderT DB IO a requires some juggling of the state
21:04:19 <petekaz> ddarius: as you showed before right?  When I said my last comment, I was intending to say, although a wrapper maay be used, one still has to extract and run runReaderT again.
21:05:11 <ddarius> petekaz: Inside the wrapper.  It's hidden.
21:05:41 <ddarius> Or use mapReaderT as skew suggests which just does the same thing.
21:06:10 <petekaz> ddarius: right, but I was just trying to understand skew's comment about something not working if I only need the arg is two functions.
21:06:54 <petekaz> If it weren't for forkIO or atomically, then it would have been much simpler I see now.
21:07:43 <petekaz> Thanks for all of the help again.
21:08:02 <skew> where is the network module?
21:08:12 <skew> I've just about got it together
21:08:21 <goltrpoat> what was the name of that prolog-in-haskell paper again?  had the slick combinators that made it look like prolog.
21:08:23 <skew> but apparently debian packages ghc in a million little pieces
21:08:34 <skew> as if you could use Haskell without the mtl
21:08:47 <petekaz> aptitude install libghc6-network-dev
21:09:01 <ddarius> goltrpoat: I can think of several, but I don't think I remember one that made it look like Prolog.
21:09:47 <goltrpoat> yeah, i remember reading several of them, but one had this incredibly slick frontend, as i recall
21:10:53 <ddarius> The Typed Logic vars one was pretty clean.
21:10:56 <goltrpoat> i wrote a backend while waiting for a p4 sync on something else, and couldn't quite figure out how to separate constants and variables (plus instantiation) in a clean manner
21:11:19 <goltrpoat> so then i remembered that paper, but i can't find it in my repository
21:11:36 <ddarius> @google Typed Logical Variables in Haskell
21:11:37 <ddarius> ?
21:11:46 <goltrpoat> i don't think that's the one
21:11:48 <lambdabot> http://citeseer.ist.psu.edu/claessen00typed.html
21:12:30 <ddarius> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages#Logic_programming maybe
21:12:33 <lambdabot> Title: Research papers/Domain specific languages - HaskellWiki, http://tinyurl.com/2e9pgq
21:13:12 <goltrpoat> i think i might be thinking of hinze's paper, come to think of it.
21:13:13 <goltrpoat> lemme check.
21:14:32 <hpaste>  skew annotated "could all of the DB arguments be eliminated in this example by using ReaderT?" with "all clean" at http://hpaste.org/1807#a3
21:14:41 <goltrpoat> i think that's it, actually.  sorry, shouldve checked the wiki first
21:16:05 * ddarius recommends the indentation style for 'do' that is in petekaz's code.
21:16:07 <petekaz> skew: I see.
21:17:13 <petekaz> ddarius: what is the differenec, I don't see it.
21:17:35 <ddarius> It's just in readDB and writeDB
21:17:48 <petekaz> ah.
21:17:56 <goltrpoat> didn't ghc in debian head use to be 6.2 or some such until recently, btw
21:18:16 <ddarius> (Actually, in those cases, I'd probably write them point-free because I'm crazy like that.)
21:18:49 <ddarius> :t mapReaderT
21:18:52 <lambdabot> forall (m :: * -> *) a (n :: * -> *) b w. (m a -> n b) -> ReaderT w m a -> ReaderT w n b
21:19:12 <skew> I've seen suggestions that most IO operations should be qualified over MonadIO
21:19:26 <skew> if you did that, all those liftIO would go away
21:19:29 <ddarius> MissingH, I think, does essentially that.
21:20:46 <skew> I see something that makes a class for handles
21:20:59 <skew> but not generalizing the monad
21:21:56 <ddarius> Maybe I'm thinking of something else or just misremembering.
21:22:40 <petekaz> thanks again for the help ...
21:22:45 <petekaz> this was helpful.
21:22:55 <petekaz> I'm headed to bed now.
21:34:20 <goltrpoat> so i was thinking of writing a simplex algorithm tutorial while using haskell as the specification+implementation language, essentially.  i think simplex is described in a rather roundabout and obtuse manner in most optimization textbooks, so i figured there was a bit of a gap
21:34:38 <goltrpoat> am i correct in assuming that i wouldn't be duplicating much work there?  i don't see anything regarding that on the wiki
21:34:45 <lispy> goltrpoat: i'd be interested in reading your article
21:35:01 <goltrpoat> ah cool.
21:35:19 <lispy> simplex is one of those things i'd like to know more about but i've never studied
21:35:40 <lispy> and to have a tutorial in haskell showing how simple/elegant it is would be really nice
21:36:09 <lispy> goltrpoat: are you on planethaskell?
21:36:47 <goltrpoat> not really.  HWN links to my blog now and again, which almost causes more traffic than there really is content, so eh
21:37:27 <lispy> okay, i don't usually read HWN or planethaskell, but i'll try to watch for this article
21:38:09 * lispy would lke to have time enough to read both
21:38:10 <goltrpoat> cool, i'm sure i'll run into you here so i can let you know if i manage to release it
21:38:17 <lispy> thank you
21:38:26 <goltrpoat> np
21:39:02 * lispy is really happy with the sharing and generosity in the haskell community
21:39:16 <lispy> people know things and do things and they share those
21:39:42 <goltrpoat> at this point it's like.. well, do i use arrays and make the presentation less transparent, or do i go with lists and make the specification extremely obvious, but the end result isn't exactly useful in production
21:39:53 <lispy> people tend to do even useful things just trying to transform from newbie to intermediate
21:40:26 <goltrpoat> so far i've been going with the former, but NA folk are so performance-oriented that it almost doesn't make sense to present a practically useless but readable implementation
21:40:37 <goltrpoat> or.. more readable, rather
21:40:38 <lispy> goltrpoat: maybe you could develop it by starting with the lists and develop that into the more 'production' version
21:41:02 <lispy> as the tutorial develops
21:41:17 <goltrpoat> -nod-
21:41:48 <lispy> also, you might be suprised by the performance of lists
21:42:00 <lispy> my list code usually out performs my array code
21:42:06 <Korollary> wtf
21:42:07 <lispy> (with some notable exceptions)
21:42:54 <lispy> (my bf interpreter is much faster with arrays, but my opengl code wasn't)
21:43:03 <goltrpoat> it's fairly weird.  you can make it fairly clean, and, i imagine, efficient, by passing around (m, transpose m).
21:43:21 <goltrpoat> but, memory requirements for large systems end up doubling.
21:44:04 <lispy> yeah, and from what i've observed at work, scientific models usually end up requiring as much memory as you have
21:44:17 <goltrpoat> there were a bunch of papers on LA in haskell had fairly ingenuous ways of serializing these things, so i should probably revisit those
21:44:27 <lispy> where i work, the physical memory determines the fidelity of your model...so people always use as much as they have
21:44:36 <goltrpoat> ah right
21:44:39 <Korollary> they should use databases then
21:45:09 <goltrpoat> what i work with, it's runtime first and foremost, followed by memory requirements, followed by accuracy
21:45:10 <goltrpoat> heh
21:45:24 <lispy> Korollary: performance is an issue as well...people will wait a day or two to run a simulation but not much longer
21:45:30 <goltrpoat> (generally speaking)
21:45:59 <lispy> if it doesn't finish overnight they start looking for things to improve the run time
21:46:00 <goltrpoat> my case -- the simulation runs in 1/60th of a second, if it doesn't, it runs in 1/30th of a second, if it doesn't, it gets polished until it does :)
21:46:15 <goltrpoat> freaking amazing how much you can fit into that.
21:46:16 <lispy> heh
21:48:28 <lispy> it would be interested to store two large matrices in a database and then develop an api to multiply them with constant memory overhead and good performance
21:49:06 <lispy> (when i say memory i mean ram, don't care that much about disk space...some models are already 8-10 GB)
21:53:20 <BRS_Runaro> How do I find the zero of a function?
21:53:56 <lispy> the zero?
21:54:02 <lispy> like the roots of a polynomial?
21:54:08 <BRS_Runaro> find the x where f (x) = 0
21:54:11 <BRS_Runaro> yea
21:54:23 <BRS_Runaro> exactly like the roots of a polynomial
21:54:24 <lispy> there is no general way
21:54:40 <BRS_Runaro> alright then
21:54:43 <lispy> there are some pretty general approximations though
21:55:06 <SamB_XP_> what properties does this function have?
21:56:17 <BRS_Runaro> spoly 0 s = 0
21:56:24 <BRS_Runaro> spoly 1 s = s
21:56:29 <BRS_Runaro> spoly n s = 2 * (1 - 2 * s) * (spoly (n - 1) s) - (spoly (n - 2) s) + 2 * s
21:57:00 <BRS_Runaro> I need the s for an n > 2
21:59:54 <BRS_Runaro> The coefficient of s^n in (spoly n s) is a power of 4, so the degree of the polynomial is n.
22:02:17 <goltrpoat> do you know that this converges
22:02:44 <SamB_XP_> goltrpoat: what do you mean by that?
22:03:12 <BRS_Runaro> I think it's wrong, actually.
22:03:17 <BRS_Runaro> :-)
22:04:00 <Cale> Ugh, how do I get myself into these arguments? :)
22:04:23 <SamB_XP_> Cale: well, you could start by being of some type "a"
22:04:34 <Cale> heh :)
22:04:58 <SamB_XP_> ... then, I could pass you to id :-)
22:05:26 <olsner> > id SamB_XP_
22:05:27 <lambdabot>   Not in scope: data constructor `SamB_XP_'
22:05:33 <goltrpoat> ok.  S_0(s) = 0, S_1(s) = s, S_k(s) = S_{k-1}(s)(1-2s) - S_{k-2}(s) + 2s.  we're looking for a particular s such that S_n(s) = ... ?
22:05:40 <Cale> pjdelport seems to insist that in order to be a closure, in addition to being a pair consisting of some code with free variables together with an environment mapping those free variables to values, the values for the free variables have to come from capturing the bindings from some lexically-defined scope in a program.
22:05:44 <goltrpoat> or am i misreading something.
22:05:57 <olsner> no luck... you're out of scope!
22:06:02 <sorear> don't use the word closure.
22:06:07 <sorear> it's too vage
22:06:12 <sorear> *vague
22:06:21 <Cale> I think that makes about as much sense as saying that to be a list, the entries have to come from sequentially asking the user for input.
22:06:28 <BRS_Runaro> Finally we're getting a closure to Java, eh?
22:06:30 <BRS_Runaro> badoom!
22:06:33 <SamB_XP_> Cale: oh?
22:06:44 <SamB_XP_> well have you ever encountered a closure where that wasn't true?
22:07:02 <BRS_Runaro> ok, sorry .. the function is correct
22:07:05 <Cale> Sure. One that's had some of its bindings mutated, for instance.
22:07:07 <BRS_Runaro> the arguments are not
22:07:11 <SamB_XP_> ... nevermind whether the program in question is the one that was actually in some source file
22:07:30 <SamB_XP_> Cale: ... what nonsense are you prattling on about?
22:07:52 <BRS_Runaro> I need an s such that 0 < s < 1 for any n > 2
22:08:27 <Cale> SamB_XP_: Well, closures are typically used to implement functions which capture bindings in some lexical scope, which is where this confusion is coming from.
22:08:38 <Cale> SamB_XP_: But they're just a data structure, right?
22:08:45 <goltrpoat> brs:  are you sure that's what you want? :)
22:08:47 <SamB_XP_> Cale: I mean, what is this "mutated" you speak of ?
22:09:04 <Cale> SamB_XP_: Well, it doesn't have to be actual mutation.
22:09:14 <BRS_Runaro> goltrpoat: yea, sorry. s is always between 0 and 1
22:09:28 <SamB_XP_> so you would violate the abstraction?
22:09:33 <Cale> SamB_XP_: It could be a closure which came from constructing a new closure from an old one by replacing one of the bindings.
22:10:07 <Cale> You can do that, because a closure is just a pair consisting of some code and a finite map from free variables of that code to values.
22:10:26 <SamB_XP_> what unholy language are you speaking of?
22:10:29 <Cale> (at least, that's what *I* think the word means)
22:10:34 <Cale> any language.
22:10:47 <Cale> Closures are a means of implementing functions.
22:11:16 <goltrpoat> brs:  if we're looking for s, then S_0(s) = 0, S_1(s) = 0, S_2(s) = S_1(s)(1-2s) - S_0(s) + 2s = 0 - 0 + 0 = 0, and so forth by induction.
22:11:28 <Cale> That is, for me at least, they're something which occurs inside an interpreter or compiler or runtime.
22:11:44 <Cale> Is that not how other people use the term?
22:11:47 <SamB_XP_> well, maybe this dude is thinking that closures *are* functions or thunks?
22:11:51 <goltrpoat> brs:  oh, sorry.  0 < s, not 0 <= s, misread.
22:12:17 <Cale> SamB_XP_: Not quite.
22:13:02 <Cale> SamB_XP_: He agrees that they consist of code together with an environment, but that the thing is only a closure if that environment came from capturing bindings in some lexical scope (whatever that means)
22:13:32 <BRS_Runaro> goltrpoat: I'm thinking I need to write this another way to find my s.
22:13:37 <Cale> That is, we can't just *specify* an environment and get a closure.
22:13:40 <goltrpoat> so if the bindings come from divine intervention, it's no longer a closure?
22:13:42 <SamB_XP_> I suppose, if you are thinking of what might happen if you did [(lambda: i) for i in range(10)], and then called each of those functions...
22:13:50 <Cale> goltrpoat: yeah, that seems to be what he's saying.
22:14:00 <Cale> Which one of us is crazy? :)
22:14:06 <SamB_XP_> then you may have a point
22:14:14 <SamB_XP_> (that is, of course, Python code)
22:14:32 <SamB_XP_> so, what do you think each of those functions would return?
22:15:00 <Cale> This all started from me complaining that people shouldn't use the word "closure" to mean "function that captures bindings in lexical scope".
22:15:19 <goltrpoat> reasonable thing to complain about.
22:15:24 <SamB_XP_> any takers?
22:16:05 <Cale> SamB_XP_: The obvious thing to *think* is that they return their index in the list, but I'm guessing that's not true, or it wouldn't be interesting :)
22:16:25 <Cale> They probably all return 9 or something.
22:16:29 <BRS_Runaro> goltrpoat: So, I can readily figure out that S_3(s) = s(3-4s)^2, for example. But how can I get Haskell to perform that calculation?
22:16:53 <SamB_XP_> Cale: depends on what value i has when you call them
22:17:02 <SamB_XP_> that is one of the chief reasons to use Haskell
22:17:10 <Cale> Oh, they're dynamically scoped?!
22:17:21 <Cale> That's even more interesting :)
22:17:32 <SamB_XP_> well, I mean, *in the scope you built them in*
22:17:38 <BRS_Runaro> Oh yea, ruby does that too.
22:17:45 <SamB_XP_> like, the same function
22:17:50 <goltrpoat> brs:  didn't you just define it right now?  return the intermediates in a list if you want.
22:17:58 <BRS_Runaro> You can pass scope around. Funny stuff.
22:17:59 <Cale> SamB_XP_: does the list comprehension not create a new scope for i?
22:18:18 <SamB_XP_> Cale: maybe it will in 3k!
22:18:34 <Cale> >>> [(lambda: i) for i in range(10)] [3] ()
22:18:34 <Cale> 9
22:18:36 <Cale> haha
22:18:45 <BRS_Runaro> goltrpoat: I'm not sure what you mean.
22:18:45 <Nafai> >>> [(lambda: i)() for i in range(10)]
22:18:45 <Nafai> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
22:18:45 <Nafai> >>> [j.__call__() for j in [(lambda: i) for i in range(10)]]
22:18:45 <Nafai> [9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
22:18:48 <Nafai>  
22:19:11 <Cale> >>> [j () for j in [(lambda: i) for i in range(10)]]
22:19:11 <Cale> [9, 9, 9, 9, 9, 9, 9, 9, 9, 9]
22:19:32 <goltrpoat> brs:  i'm seriously confused about the idea of asking for any s in [0,1] from S though.  i'm guessing it bounces between 0 and 2 without converging.
22:19:41 <Cale> Lots of fun.
22:20:00 <SamB_XP_> so if that is what you meant about mutating bindings, sure ;-)
22:20:14 <Cale> So here we see that there are closures where the thing being captured is not the value of the mutable cell, but the mutable cell itself, and then that's changing.
22:20:28 <Cale> (the value is)
22:20:39 <SamB_XP_> I hear in the latest versions you can even *update* that value
22:20:46 <jbauman> Cale, no i is in the parent scope
22:20:50 <SamB_XP_> not just see changes to it
22:22:21 <SamB_XP_> 'k, sleepytime
22:22:28 <SamB_XP_> well actually that was a while ago
22:23:22 <Cale> (lambda () (set! x (+ x 1)))
22:23:34 <goltrpoat> in a smalltalk environment, the closure mutates YOU.
22:23:55 <BRS_Runaro> I see!
22:24:14 <Cale> goltrpoat: yeah, I was also thinking about that -- a natural way to implement user mutation of objects is just to allow the user to change the environments more or less directly.
22:24:34 <goltrpoat> sure.
22:24:47 <BRS_Runaro> goltrpoat: Instead of passing n to this function, I should be constructing a list and getting the nth element from it.
22:24:52 <Cale> But it seems like nonsense to stop calling them closures once that happens.
22:26:13 <Cale> http://programming.reddit.com/info/1oooq/comments/c1ounl -- if anyone wants to actually read that thread of insanity.
22:26:15 <lambdabot> Title: Ask reddit: What&#39;s the exact meaning of &#39;closure&#39; (reddit.com)
22:26:27 <skew> I think it's more like you're closing a term with free variables
22:26:30 <goltrpoat> brs:  that's literally the same thing, but you get more insight into the intermediate values.
22:26:37 <skew>  usually you "close over" and environment
22:26:49 <skew> but maybe you did something more interesting
22:27:04 <skew> like, any optimizations that happen after closure conversion
22:27:45 <skew> Or, I imagine an extra-fancy hot upgrade system might patch closures
22:27:47 <Cale> I take an "environment" to mean a finite map from free variables to (appropriately typed) values.
22:28:15 <goltrpoat> what's this "implementation strategy" business.
22:28:18 <Cale> That is, it's something distinct from a "lexical scope"
22:28:35 <Korollary> The environment is something slightly different iirc
22:28:39 <BRS_Runaro> goltrpoat: if I do, I can stop at 0
22:28:47 <BRS_Runaro> brute force method
22:28:54 <Cale> Korollary: or perhaps just a set of definitions, if you want
22:29:13 <BRS_Runaro> nooo wait
22:29:36 <BRS_Runaro> that's an infinite search. heh
22:29:45 <goltrpoat> uh huh :)
22:29:49 <Cale> goltrpoat: "functions which bind variables in their lexical scope" is a language feature, "closures" are a data structure which is often part of an implementation of that language feature.
22:29:53 <skew> on the other hand, making it from a nested function is the only reason you call it a closure at all
22:30:15 <skew> as distinguished from any other data structure containing some code and some values
22:30:17 <Cale> skew: Would you not call it a closure if I just specified the environment by hand?
22:30:30 <BRS_Runaro> Drat.
22:30:50 <jbauman> could call it an object...
22:30:56 <goltrpoat> would you call <V,E> a graph if V came from bob, and E came from harold
22:30:59 <BRS_Runaro> I also know for a fact that every s is a root
22:31:07 <BRS_Runaro> a square root, in fact.
22:31:23 <Cale> For example, I would think that (\z -> x y z, {x = (+), y = 5}) is a closure, regardless of where I got it.
22:32:43 <BRS_Runaro> nope, doesn't help. I need this for reals.
22:32:44 <Cale> Is that not correct?
22:32:54 <goltrpoat> cale:  i agree with you, it just seemed like "implementation strategy" somehow got weaselled into the discussion, and i'm not sure how that even applies.
22:33:05 <Korollary> Cale: http://okmij.org/ftp/Scheme/closures-assignment.txt
22:33:09 <Cale> goltrpoat: It's more to do with the surrounding discussion.
22:33:56 <Cale> Korollary: thanks :)
22:33:57 <goltrpoat> ah.
22:34:34 <BRS_Runaro> What I really want is for spoly to return a function for me to calculate s.
22:35:03 <Cale> goltrpoat: There was a huge argument about whether closures were really synonymous with first-class functions that capture all bindings in lexical scope.
22:35:18 <BRS_Runaro> @pl spoly n s = 2 * (1 - 2 * s) * (spoly (n - 1) s) - (spoly (n - 2) s) + 2 * s
22:35:21 <lambdabot> spoly = fix (flip flip (2 *) . (liftM2 (+) .) . ap (ap . ((ap . ((-) .) . ap ((*) . (2 *) . (-) 1 . (2 *))) .) . (. subtract 1)) (. subtract 2))
22:35:33 <BRS_Runaro> nice
22:35:34 <Cale> goltrpoat: The whole reason why one might think that is that closures are almost always used to implement such functions.
22:36:00 <Cale> goltrpoat: But it's not actually a requirement of the definition of a closure that you go ahead and do that.
22:36:21 <Cale> Let's see what ski thinks :)
22:36:33 <goltrpoat> cale:  that's just a lack of understanding of the terms though.
22:36:51 <goltrpoat> surely there's a decent article or fifty that explains the distinction.
22:36:55 <Cale> ski: Does a closure's environment *have* to come from collecting the definitions available in some lexically-defined scope?
22:37:56 <Cale> http://programming.reddit.com/info/1oooq/comments/c1pxh4 -- I heartily urge all who agree with my viewpoint that the environment can be arbitrary to help me out and reply to this post :)
22:37:58 <lambdabot> Title: Ask reddit: What&#39;s the exact meaning of &#39;closure&#39; (reddit.com)
22:38:06 <Svrog> Cale: about that reddit thread, imo the best thing is to just let it go - arguing in threads like that just wastes your time and it's too easy for people to miss or misinterpret your points or conveniently ignore them
22:38:40 <Cale> Svrog: That's true, and I was about to drop it, but it would be nice to actually get through to this guy.
22:39:14 <Cale> He does seem to *mostly* know what he's talking about, but he's just missing this fine distinction.
22:39:49 * ski hrms
22:40:16 <Korollary> holy crap
22:40:20 <jbauman> http://img109.imageshack.us/img109/4622/ia3yp.jpg
22:40:33 <Cale> Korollary: what? :)
22:40:50 <Korollary> That's a fine Friday night nerd-off
22:40:54 <Cale> jbauman: That's an excellent picture :)
22:40:59 <Cale> Korollary: haha
22:41:14 <Cale> Korollary: it's been slowly going back and forth for a few days
22:41:24 <goltrpoat> im fairly certain the yak can take the kid
22:41:34 <goltrpoat> i mean, the kid is ferocious looking and all, but the yak has teeth.
22:41:35 <Korollary> the kid's got technology
22:42:17 <goltrpoat> yeah well.  the yak has a bucket.
22:42:36 <Korollary> on loan from the kid
22:42:45 <ski> Cale : the environment in a closure is an optimization .. the important point is that the function occurs in a context where variables are in scope .. then as to *how* they are in scope, i think that's not as relevant
22:42:54 <BRS_Runaro> I think that's a gnu
22:42:56 <goltrpoat> as if that kid could carry that bucket.
22:43:22 <Korollary> all the kid needs to carry is an ak47
22:43:33 <Cale> ski: My definition of a closure is that it's a pair consisting of some code, together with a finite map from the free variables of that code to values (of appropriate types).
22:43:51 <Cale> (and it doesn't matter at all where that finite map comes from)
22:44:35 <ski> type a -> b = exists x. (x,(x,a) -> b) -- is how i think of it
22:44:35 <Cale> Does the kid represent Microsoft?
22:44:40 <ski> er
22:44:45 <ski> type a -> b = exists x. (x,(x,a) #-> b)
22:45:10 <ski> '#->' being roughly strict implication, i think
22:45:17 <Cale> hmm
22:45:30 <Cale> I'm not sure I understand that notation :)
22:45:38 <ski> which part of it ? :)
22:46:09 <Cale> ski: Oh, here's a better question: is there a difference between "closures", and "functions which bind the variables in lexical scope"
22:46:34 <ski> i don't know what the latter is
22:46:46 <Cale> The latter is a language feature.
22:46:51 <goltrpoat> the kid clearly represents the failed tribal expansionalism of the sarmatians in the 4th century, while the yak represents the ostrogoths
22:46:54 <Cale> (lambdas, essentially)
22:47:14 <ski> closures is an implementation technique
22:47:26 <Cale> ski: yeah, that's what I think too
22:47:59 <ski> you could evaluate by substition .. or you could optimize to evaluate by environment, and then you get closures, if you want the semantics to agree
22:48:19 <ski> (otherwise you get ELisp)
22:48:41 <Cale> I'd also think that you could use closures to get entirely different language features.
22:49:20 <Cale> For example, objects, where you use the environment portion to hold instance variables and methods, and allow for direct updates to those.
22:49:31 <Korollary> goltrpoat: the kid represents South Jersey, yo
22:50:44 <Cale> (which is something which we don't tend to do with functions)
22:50:48 <ski> Cale : you can do that in haskell as well ..
22:51:24 <Cale> Well, when you have a lambda that's captured some bindings, you can't update the bindings in its environment to get a new function.
22:51:30 <ski> x :: IORef T |- \y -> ..x.. :: Y -> IO U
22:51:33 <Cale> Functions are totally opaque in that respect.
22:51:44 <Cale> You can bind IORefs, but you can't change what IORef you have there.
22:52:12 <Cale> (because it makes no sense to do that)
22:52:31 <ski> "you can't update the bindings in its environment to get a new function" .. does "you" here mean something outside the function ? or inside ?
22:53:06 <Cale> Both, simply because functions don't have side effects in Haskell.
22:53:47 <Cale> In scheme, you can update the environment.
22:53:54 <Cale> (from inside)
22:53:59 <Cale> (at least)
22:54:28 <falconair> i just read in an older #haskell log that binary serialization in ByteString is an applicative functor ... is that true of de-serialization as well? (
22:54:48 <Cale> But from inside, say, the Haskell interpreter, you'd be free to do that, because you'd have direct access to the closures.
22:55:24 <ski> (and by "new" do you mean update-in-place (destructive), or copy-update (nondestructive) ?)
22:55:34 <Cale> ski: either one
22:55:53 <Cale> ski: actually, I should probably have worded all that better
22:55:57 <goltrpoat> someone should take http://en.wikipedia.org/wiki/Image:%27Destroy_this_mad_brute%27_WWI_propaganda_poster_%28US_version%29.jpg and replace the "KULTUR" on the club with "C++"
22:55:59 <lambdabot> http://tinyurl.com/23gfrt
22:56:00 <goltrpoat> that'd be cool.
22:56:37 <ski> Cale : i seem to recall some Scheme compiler(s) transforming use of 'set!' on non-local variables into setting the contents of a box (i.e. basically 'IORef')
22:56:52 <Cale> ski: yeah, that's possible
22:57:19 <ski> so then that compares to closure in haskell capturing references
22:58:16 <Cale> In any case, from the language user's perspective, you're not really dealing with a closure, because you can't actually observe the parts directly.
22:58:33 <Cale> Like, I can't take a function and ask "what is the free variable x bound to in this?"
23:00:32 <Cale> hmm, my lan connection dropped for a second.
23:00:37 <ski> Cale : but that is because of the existential quantification, i'd say
23:00:58 <ski> (Cale : btw, i'm not sure what you're arguing atm :)
23:01:04 <Cale> (re: my remark on not being able to ask about the value of the free variable)
23:01:06 <Cale> ?
23:01:27 <ski> yes
23:02:03 <Cale> ski: Oh, I'm not really arguing with you, just seeing what you think. :) pjdelport on reddit insists that in order to be a closure, the environment must come from taking the bindings in a lexical scope.
23:02:59 <ski> and what is meant by that ?  any examples of things not being closures, then ?
23:03:17 * ski probably ought to read the thread ..
23:03:32 <Cale> Well, something where you just set the environment by hand, for example.
23:04:09 <Cale> It seems ridiculous to me, because it seems to imply that bits have some kind of 'colour' :)
23:05:20 <Cale> http://programming.reddit.com/info/1oooq/comments/c1ounl is where that thread starts.
23:05:22 <lambdabot> Title: Ask reddit: What&#39;s the exact meaning of &#39;closure&#39; (reddit.com)
23:05:37 <Cale> It's been growing slowly over a few days.
23:05:50 <Cale> It's pretty long, but also pretty compressible.
23:14:16 <goltrpoat> cale:  you seem to care.
23:14:47 <Cale> goltrpoat: Well, I do care that people actually understand :) Especially people who seem to almost but not quite understand.
23:16:23 <Cale> This also has to do with a convention which seems to be growing among people coming from non-functional-language backgrounds of referring to "closures" as a language feature, which is really something I'd like to put an end to because it's the wrong way to think about language design.
23:16:54 <Cale> You start with how you'd like the language to behave, and then figure out how to implement that.
23:17:59 <Cale> If you start with an implementation and try to figure out how to shoe-horn it into your language, then you're going to end up with a mess.
23:18:18 <Svrog> sadly thats how most languages are made
23:19:16 <Svrog> by picking features they think are useful and putting them into a language
23:20:05 <Cale> Svrog: Even that's not as bad as picking implementations of features and figuring out how to add them to their language implementations to get new features.
23:20:22 <Svrog> but i suspect many language designers do just that
23:20:47 <Cale> Oh, I'm sure it happens all the time.
23:26:02 <Cale> It's fine if you're doing something which is intended as an experiment, I suppose. To see how things might interact if you take a naive approach to things, and better understand how you might want them to interact, but I don't think there's enough of that going on.
23:26:15 <Cale> (at least in mainstream languages)
23:26:59 <Svrog> i have no desire to convert oo people to functional languages anymore - id much rather have my competition draw uml diagrams than write haskell :)
23:27:05 <Cale> heh :)
23:28:19 <Cale> Er, what I was trying to say above there is that I don't think that it's treated as an experiment often enough, and it seems like languages will just get put into production with features that interact in awkward ways.
23:28:44 <Svrog> yeah
23:28:49 <goltrpoat> any specific languages?
23:29:28 <goltrpoat> other than c++ and arguably python
23:29:35 <Cale> I've seen things in ruby and python which seemed like they lacked the extra bit of foresight required to make them look nice.
23:30:04 <goltrpoat> ah
23:31:36 <Cale> Java is full of them too. It's just growing and growing now, well after the basic language became popular, and way too late to change basic things, so basically you're forced to hack new features in around the rest of it if you want them.
23:32:07 <Cale> Look at the difference between Java and Scala, for example.
23:32:25 <Cale> Scala is what Java would have been, if more thought had been put into it.
23:33:18 <Svrog> i think python and ruby and lua and similar languages should have never been created - they are smalltalk derivatives without the elegance of smalltalk
23:34:03 <rhythm> yeah haskell shouldnt have been created either. brought all sorts of math/calculus nuts out of the creepy Lisp woodwork they belonged in
23:34:05 <nornagon> I miss my Maybe in C++ :(
23:34:18 <Cale> rhythm: calculus?
23:34:27 <Cale> rhythm: Like, the lambda calculus?
23:34:28 <jbauman> lambda and pi
23:34:29 <goltrpoat> python is a smalltalk derivative now?
23:34:43 <jbauman> goltrpoat: it has objects :)
23:34:50 <goltrpoat> ah.
23:35:02 <Cale> Ruby certainly is.
23:35:03 <rhythm> theres a placein the world for a decent smalltalk clone with nice C integration. maybe lua with ruby's syntax?
23:35:17 <Cale> Why can't it be smalltalk?
23:35:29 <goltrpoat> ruby looks/feels like a smalltalk derivative, but i don't have enough experience with it, which is why i keep refraining from comment on it
23:35:42 <Svrog> well what i meant is that python is like an ugly inconsistent version of smalltalk
23:35:46 <goltrpoat> cale:  because there aren't any decent implementations.
23:36:02 <Cale> goltrpoat: yeah, but if you're going to design a new language... :)
23:36:07 <goltrpoat> oh, sure.
23:36:19 <goltrpoat> but then it wouldn't be all new, and stuff.
23:37:26 <Cale> The problem with smalltalk is that implementations either have the nice GUI environment, or you get a traditional compilation process.
23:37:37 <Cale> It would be nice to have both at the same time.
23:37:52 <ski> Cale : you and pjdelport seem to be arguing naming ..
23:37:54 <goltrpoat> yeah.
23:37:59 <njbartlett> Cale: Scala is nice, although the rules about when semicolons are automatically added at the ends of lines seems rather arbitrary
23:39:07 <Cale> ski: yeah, that's what the argument grew out of. There was a whole other flamewar which occurred between kawa and him that wouldn't have happened if they weren't using two different colloquial meanings of the word "closure"
23:40:14 <Cale> njbartlett: yeah, I wasn't really referring to the syntax -- it mostly looks like Java in that regard, which is to say, terrible :) (But that's a matter of taste.)
23:40:42 <njbartlett> Cale: agreed
23:41:02 * ski is still reading two days ago .... (hm, deep threads get uncomfortably shallow/flat text)
23:41:09 <njbartlett> Regarding closures, there's an interesting discussion here: http://www.eclipsezone.com/forums/thread.jspa?messageID=92099076
23:41:11 <lambdabot> Title: EclipseZone - When is a closure not a closure? ...
23:41:17 <Cale> njbartlett: It's the semantics which seem to be rather nice about Scala. It's obvious that lots of thought went into the type system and such.
23:41:40 <njbartlett> Various language designers give their own opinions on what a closure really is. Prof Wadler included
23:42:49 <njbartlett> Cale: Yup. Also with the JVM integration, there's a chance I can actually use it for real work!
23:43:18 <njbartlett> By real work, I mean the work I get paid for as opposed to the work I enjoy...
23:44:28 <Cale> njbartlett: yeah
23:45:16 <Cale> njbartlett: I have mixed feelings about the idea of Scala becoming successful. It would certainly be a whole lot better than what we have now.
23:46:59 <njbartlett> True, after all I'd much rather be using Haskell... hmm I wonder if Credit Suisse are still hiring? ;-)
23:48:15 <Svrog> i found funnel more interesting than scala - it's a shame that no work is likely to ever be done on funnel though
23:48:32 <Cale> The incompetence of most of the mainstream languages just makes Haskell look all that much more attractive though :)
23:49:13 <Cale> I wonder if we'd have an easier time, or a harder time getting new Haskell programmers if Scala was what people used instead of Java
23:54:40 <Vq^> Cale: do we know why people abondon Java for Haskell today? (if such people exists)
23:54:49 <Svrog> if more people were using scala instead of java they'd probably wonder what does haskell give them that scala doesnt - majority would i suspect conclude that its not worth learning a new language, possibly a small number of those who would have otherwise been tempted to find a better language would even give up considering they'd be content with scala
23:55:38 <Svrog> and finally a very small number would try out haskell - im guessing the same ones that are right now likely to give it a go as well
23:56:15 <Cheery> I don't believe people abandon java for haskell today
23:56:41 <Cheery> at least I need statistics to believe that
23:56:45 <Philippa> it was C++ I dropped, but then Java was a much weaker language at the time
23:57:17 <goltrpoat> i'm not sure if the people who use java as their primarily language are the target audience you want to go for.
23:57:29 <Cheery> first problem is that java is a corporate language
23:57:31 <goltrpoat> no offense to any java people present, but they don't seem like the sharpest bunch.
23:57:39 <Svrog> goltrpoat: but they are the majority
23:57:41 * Vq^ came from the C world, so Haskell filled a quite big hole
23:57:50 <goltrpoat> svrog:  depends on the industry.
23:58:01 <Svrog> true
23:58:25 <Svrog> but overall the number of java, c++ and c# programmers in the world dwarfs all others
23:58:32 <Cheery> second problem is that java programmers haven't got used to quality
23:58:40 <sieni> Svrog: the majority tend not to consist solely of the brightest people :-)
23:58:48 <Svrog> yes
23:59:05 <Vq^> @karma+ sieni
23:59:06 <lambdabot> sieni's karma raised to 4.
23:59:29 <Cheery> how big hole haskell actually fills?
23:59:37 <goltrpoat> people who are interested in pushing the envelope, will explore all possibilities.  people who are interested in collecting a paycheck, will not.
23:59:49 <Cheery> for me, it made python and all other 'dynamic languages' obsolete
