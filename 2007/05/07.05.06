00:00:11 <jfredett> I typically just say, "It's algebra" you have variables that aren't plugged in till way later. Like differential equations, you've got your pattern matching, synthesis of solution...
00:00:19 <Cale> (it came up in an otherwise evaluable infinite product of generating series :)
00:00:24 <jfredett> Cale: See, Thats where I wish haskell was a bit smarter,
00:00:25 <ddarius> Cale: You just need the right instance of Num
00:00:42 <qwr> DRMacIver: kind of lazyness is easy in java. you just get a awfully lot of anonymous classes...
00:00:43 <ddarius> jfredett: I don't.
00:00:50 <Cale> ddarius: no, the problem is that you can't tell that the list doesn't contain a non-1-number.
00:01:30 <Cale> You really need to be much smarter :)
00:01:32 <mauke> length [1..] > length [1..10]
00:01:41 <jfredett> Call me bias and color me pink, but I want more mathematical smarts w/ those infinite lists, some ability in evaluating infinite series would be awesome.
00:02:03 <Cale> You can actually do quite a lot with generating series.
00:02:14 <Cale> (as infinite lists)
00:02:21 <ddarius> @google "Power series, power serious"
00:02:24 <lambdabot> http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
00:02:33 <dons> hehe.
00:02:40 <Cale> It's just when it comes to infinite sums or products of them, you need to be a little more careful than you would in mathematics.
00:02:46 <jfredett> Combinatorics == Power Series, aka infinite list of algebraic statements.
00:02:53 <ddarius> It's like it's trying to be Wadler-esque and failing miserably.
00:03:07 <Hirvinen> Combinatorics != Power series.
00:03:24 <jfredett> Hirvinen, I know its a sweeping generalization
00:03:35 <ddarius> All math and physics is the Z-transform!
00:03:37 <Hirvinen> Its not even that.
00:03:38 <jfredett> Hirvinen, my point was that it is a terribly important part of Combinatorics
00:03:49 <Cale> It's pretty surprising just how close to true that statement is.
00:04:02 <jfredett> you can do quite a bit with Power series, but then again, my thesis is all about them, so I'm probably bias.
00:04:17 <jfredett> biased? What is the proper use there?
00:04:20 <jfredett> I dunno.
00:04:23 <ddarius> biased
00:04:29 <jfredett> ddarius, thanks.
00:04:44 <DRMacIver> qwr: I do it quite a lot actually, using iterators (or, by preference in my home code, generators). It's a pain in the ass.
00:04:59 <Hirvinen> jfredett: Well, there are power series in some combinatorial problems, when some of their parameters approach infinity but it's not really fundamental to the field.
00:05:00 <Cale> I'm from Waterloo, so I had quite a lot of algebraic enumerative stuff :)
00:05:27 <ddarius> @google generatingfunctionology
00:05:29 <lambdabot> http://www.math.upenn.edu/~wilf/DownldGF.html
00:05:30 <lambdabot> Title: Download generatingfunctionology
00:05:33 <Cale> Hirvinen: oh, I'd totally disagree that it's not fundamental
00:05:56 <Cale> generatingfunctionology is not very good, unfortunately
00:06:02 <Cale> I wish I could say that it's better.
00:06:09 <jfredett> Hirvinen, I'll defer to you, I only touch on Combinatorics here and there, mostly I'm dealing with automated reasoning about power series, so my work is more in logic, than combinatorics.
00:06:14 <ddarius> Cale: I never read all of it.
00:06:42 <ddarius> In fact, I don't think I read past the first chapter or two.
00:06:52 <Cale> It actually managed to make me confused about things which I already understood rather well, by introducing needless concepts.
00:07:11 <Shimei> Cale: Ah, so there are some Canadian Haskellers. Cool. :p
00:07:17 <Cale> (especially in the treatment of exponential generating series)
00:07:19 <ddarius> Cale: E.g. ?  (Not that I disagree, I'm mostly just pointing at generating functions)
00:07:49 <sjanssen> @remember Oleg So, `bind' is `let' and monadic programming is equivalent to programming in the A-normal form. That is indeed all there is to monads.
00:07:49 <lambdabot> Done.
00:07:53 <Cale> It introduces all this crap about decks and hands, which I never quite bothered to figure out, and seemed needlessly complicated.
00:08:08 <ddarius> Cale: Yeah.  I mostly ignored that crap.
00:08:22 <Cale> Exponential generating series are really a beautiful thing.
00:08:36 <ddarius> Cale: Yes, they are.
00:08:36 <Cale> But you need to define things properly to see that :)
00:08:55 <ddarius> sjanssen: That is very very well know and usually a 'let' like notation is used in non-language-specific papers.
00:09:39 <Cale> In the Waterloo school, we define a product on sets of labelled combinatorial structures (called the star product) which mimics the Cartesian products on unlabelled structures.
00:10:04 <Cale> It's essentially equivalent to Joyal's approach, but without all the category theory.
00:10:14 <Cale> *grin*
00:10:33 <jfredett> Bah! its 3am. shizzle, time for bed.
00:10:43 <jfredett> Goodnight Ladies and Gentlemen
00:11:20 <Cale> g'night
00:11:28 <Cale> Same here, I should sleep.
00:13:34 <Cale> I also found that there's a really nice combinatorial interpretation for the product of polynomials in the falling factorial basis.
00:13:51 * ddarius hasn't ever really got into combinatorics.
00:17:45 <ddarius> But that whole area (generating functions) is very close to a nexus in mathematics.
00:20:59 <Cale> The basic idea is to send combinatorial structures to the elements of some ring (usually with some sort of simple topology, so you can talk about convergence of infinite sums in some trivial way), and extend that to sets by summation over the elements. You arrange so that the product of elements in the ring corresponds to some nice operation on the combinatorial structures, such as taking pairs, or making whole sets o
00:20:59 <Cale> f pairs in some methodical way.
00:22:11 <Cale> Disjoint union always corresponds to summation, and product corresponds to some nice "product" on structures.
00:23:17 <Cale> Then you start looking at sets of combinatorial structures, and their corresponding ring elements, and go back and forth between the algebra and the combinatorics to find evidence of combinatorial bijections, and prove algebraic things.
00:23:53 <Cale> Usually, that ring is the ring of formal power series.
00:24:46 <Cale> But quite often, it's nice to work in another ring, like rings of formal power series in noncommuting indeterminates modulo some identities.
00:25:07 <Cale> Or even just the ring of integers can be handy.
00:25:52 <Cale> You can also often map things to the ring of power series in more than one way, which makes the product have different interpretations in the combinatorics.
00:28:53 <ddarius> I understood identifying + and * with operations on the structures, generatingfunctionology got that across.  One of the things that I often thought, though, was I don't just want numbers, I want these things to actually -be- the operations on the data structures in some sense.
00:29:26 <ddarius> "Scaling" with a parameter should get this.
00:30:02 <ddarius> The end result being somewhat like algebraic data types.
00:30:18 <Cale> hmm
00:30:21 <ddarius> However, most of my uses of generating functions have lied into areas more related to analysis.
00:30:32 <Cale> Well, it is, sort of.
00:30:58 <Cale> When you read combinatorial identities on the algebraic side, you can often picture combinatorial structures to go with them.
00:31:46 <ddarius> Combinatorial structures, as I see them, tend to only specify "shape"
00:32:20 <Cale> For instance, I would look at  product over k >= 1 of (1 + x^k) = 1 + sum over m >= 1 of x^(m(m+1)/2) / product over k = 1 to m of (1 - x^k)
00:32:53 <Cale> and I'd see partitions of an integer on the left, displayed as Ferrers' diagrams (rows of *'s)
00:33:41 <Cale> and on the right, a maximal triangle is being chopped out of each one, and the remainder is a partition where each part occurs at most once
00:34:33 <Cale> er, sorry, the partitions on the left have distinct parts
00:34:51 <Cale> (as well)
00:36:32 <Cale> because it's product over k >= 1 of (1 + x^k) -- which corresponds to  Cartesian product over k >= 1 of {0,k}, restricted to finitely many nonzero parts.
00:37:35 <Cale> So you end up with lots of crazy-looking formulas which are justified primarily by combinatorial means.
00:38:29 <Cale> Where you might see the combinatorics as only representing the "shape" of containers, it might just be that you need to consider composition of generating series. :)
00:38:48 <ddarius> And crazy-looking identities justified primarily by combinatorial means is what I want to fold back into programming as data structure design.
00:39:01 <Cale> :)
00:40:56 <Cale> You might be interested in the stuff that they've been doing with Zippers
00:41:03 <Cale> and polynomial functors
00:41:19 <ddarius> Would composition be like decorating the leaves of the outer function with the shapes of the inner?
00:41:25 <Cale> yes
00:41:28 <ddarius> Cale: I am.
00:41:54 <Cale> Yeah, that's entirely equivalent, and I was very very surprised to see a paper dated 1990 about it. :)
00:42:04 <Cale> Well, perhaps not *entirely*
00:42:22 <Cale> but Joyal's approach to combinatorics is extremely close
00:42:58 <Cale> (it just uses a little more category theory to hasten the development of certain combinatorial products)
00:43:13 <ddarius> In this regard, Containers are also interesting to me as they separate a data structure into a shape and a mapping to values.
00:43:33 <Cale> People have been thinking of derivatives as marked deletion of an element for a long time though.
00:43:53 <ddarius> Cale: That's natural considering, d1 = 0
00:43:57 <ddarius> and dx=1
00:44:05 <Cale> yeah
00:44:11 <dons> mmm. have to sit down and try the xmonad-is-a-zipper idea swiert suggested
00:44:20 <Cale> and it corresponds to nice combinatorial operations :)
00:44:36 <ddarius> Also, with containers, they've described quotient types with them.
00:44:41 <Cale> hehe, D x^3 = 3 x^2 because there are three ways to delete an x and each gives you x^2 :)
00:44:42 <dons> i think there might be a natural encoding of the 2-level workspace/window structure, much like the natural zipper fs
00:44:51 <binil> Hi all, I am working through the code samples in "Programming in Haskell". Chapter 8 is on parsers, and I am trying the code. My code can be found at http://hpaste.org/1719. But Hugs reports a type error for the last function p'. Can anyone help, please?
00:45:27 <ddarius> So, you can vaguely argue, [a] = 1+a+a^2+... =? 1/(1-a).  Quotient types may allow that to be more sensible.
00:45:31 <Cale> binil: hmm, you actually need a Monad instance for Parser in order to use do-notation.
00:45:53 <Cale> ddarius: yeah
00:46:14 <binil> Cale: Sutton hasn't mentioned a word on Monad yet - and my primary reason for buying the book itself was to see if someone can help explain all that to me in plain English :)
00:46:19 <Cale> ddarius: 1/(1-a) is looked at more as a fundamental "thing"
00:46:28 <binil> Cale: I meant, Hutton. :)
00:46:39 <Cale> ddarius: As (1 - a) doesn't mean much combinatorially.
00:46:51 <Cale> binil: okay
00:47:01 <Cale> binil: it's definitely moving in that direction...
00:47:10 <ddarius> Cale: I agree with that view that that thing is just a "primitive thing".  1-a doesn't mean much for algebraic data structures either.
00:47:19 <binil> Cale: So do you suggest that I play along, and I will eventually get there?
00:47:41 <ddarius> I think the next chapter explains monads generally.
00:47:42 <Cale> binil: well, did it define a 'bind' for parsers yet?
00:47:49 <ddarius> No, it's IO then monads generally.
00:47:54 <binil> Cale: not yet
00:48:11 * ddarius should call Sutton some time...
00:48:19 <Cale> binil: okay, I'm not sure that we can get that code into a working shape without actually defining that.
00:48:37 <Cale> binil: I could tell you how to do that, and how to desugar the do-block though...
00:48:45 <Cale> binil: is that directly in the book?
00:49:27 <ddarius> Hmm, Cale Sutton.  One of those minor coincidences that people tend to think are far less likely than they are.
00:49:32 <Cale> binil: p' is written in a style which is only available once you know that Parser is a monad :)
00:49:44 <binil> Cale, ddarius: OK, maybe I am jumping the gun here. I will continue reading and try this code a lil later
00:50:21 <ddarius> No, Caleb.
00:50:49 <ddarius> That's what I get for knowing people primarily by last name.
00:50:52 <Cale> hm?
00:52:04 <Cale> binil: If you want, I could write that so that the do-block will roughly work, but perhaps it's not actually meant as executable code, but something more suggestive.
00:52:42 <ddarius> binil: If the code is directly from the book and meant to be executable something is wrong.
00:52:48 <Cale> binil: the main idea being that you'll have ways to string parsers together, and build larger parsers from them
00:52:58 <binil> Cale: Yes, I think so too. My impatience! :)
00:53:10 <binil> Cale: yes, the sequencing is what the author is explaining about
00:55:05 <ddarius> "Go back to what the problem was before the customer tried to solve it."
00:55:26 <binil> Cale: He first mentions the >>== construct to sequence parsers, and quickly continues to "Haskell provides a special syntax for such parsers ..." and mentions the do notation. I did not quite understand the >>==, so I typed this code and tried it when I got the error. As I said, I should wait, I guess. Thanks folks!
00:55:58 <Cale> binil: the >>== corresponds to the operation >>= in Haskell, which you need to define for the do-notation to work
00:56:10 <Cale> >>= is pronounced "bind"
00:56:33 <binil> Sorry, that was >>= I meant .. the extra = was my mistake!
00:57:21 <binil> Cale: the book mentions that >>= is read as "then".
00:57:25 <Cale> If x is some sort of data representing a computation, and f is a function from possible results of that computation to further computations, then x >>= f puts that together in the obvious way, into a computation which runs x, gets the result passing it to f, and then runs the result of that.
00:57:41 <Cale> yeah, "then" is fairly natural as well.
00:57:58 <Korollary> wait. I thought >> was then.
00:58:08 <Cale> "bind" has more to do with the fact that x >>= f binds the result of x and passes it to f
00:58:37 <Cale> Korollary: I don't think there's a standard
00:59:13 <Korollary> Well, the language already has a 'then'. So I don't like it in any case.
00:59:28 <Cale> binil: Understanding >>= is basically equivalent to understanding monads. :)
00:59:37 <mauke> clearly 'then' needs to be overloaded to mean >>=
00:59:47 <binil> Cale: OK, I dont understand monads then :)
01:00:06 <Cale> binil: don't worry, it's not really all that bad :)
01:00:32 <ddarius> @quote oleg a.normal
01:00:32 <lambdabot> No quotes for this person. stty: unknown mode: doofus
01:00:49 <Cale> binil: for example, in the case of parsers, suppose that x is a parser, and f is a function from results of that parser to parsers.
01:01:11 <binil> Cale: OK, and?
01:01:16 <ddarius> @quote A.normal
01:01:16 <lambdabot> Oleg says: So, `bind' is `let' and monadic programming is equivalent to programming in the A-normal form. That is indeed all there is to monads.
01:01:20 <Cale> binil: Then x >>= f is the parser which will parse x, takes the result and passes it to f to get another parser, then parses with that one.
01:01:28 <Cale> (returning its result)
01:02:01 <Cale> So you can dictate what to parse next based on the result of x
01:02:36 <binil> Cale: OK
01:03:00 <Cale> of course, the parser which is the result of f, starts off with whatever's left of the string after parsing x
01:03:42 <Cale> and this is nondeterministic -- if x gives a list of possible results, then each one will be tried in turn to build up an even longer list of possible parses
01:04:19 <Cale> If x fails to parse, giving an empty list, then there will be nothing to do, and the computation will stop, producing an empty list.
01:06:37 <binil> Cale: OK. So x >>= f is a function which take an input, parses it with x first, take that result and applies f on it, takes the parser returned from that, and parses the remaining input as returned by the application of x on the original input. Am I right?
01:07:04 <Cale> yes
01:07:20 <Cale> of course, x actually is going to return a list of results
01:07:47 <Cale> so it'll really map over that list and concatenate the results from each resulting parser
01:08:19 <Cale> which is perhaps brain-exploding, but results in the operation doing the obvious thing in the end
01:08:27 <ddarius> "Everything takes longer than you think, including thinking."
01:09:12 <Pseudonym> ?google "hofstadter's law"
01:09:14 <lambdabot> http://en.wikipedia.org/wiki/Hofstadter's_law
01:10:00 <mauke> "It is therefore impossible to ever fully take Hofstadter's Law into account, at least in finite time, unless one has a rudimentary understanding of calculus."
01:10:12 <ddarius> "You have expletives for such moments."
01:10:40 <vegai> well, what if I decide that doing X will take forever, but I will do it anyway
01:10:52 <binil> Cale: Hmm. Let me ignore the part where x returns multiple results .. but what is the real significance of x >>= f?
01:10:57 <vegai> I know, it's a joke law...
01:11:26 <mauke> run x, call f on result, continue with the parser returned by f
01:11:37 <binil> Cale: I mean, I seem to realise what it means ... but am I missing something?
01:12:01 <Cale> binil: if you're missing something, it's only in what >>= generalises to
01:12:31 <ddarius> binil: Don't add complexity.
01:12:35 <binil> Cale: You mean, >>= has some broader significance beyond parsing?
01:12:38 <Undertaker> testing
01:12:43 <Cale> ah, yeah :)
01:12:44 <mauke> huhu
01:12:47 <ddarius> binil: Are you in for a treat.
01:12:53 <dons> hehe. yay
01:12:57 <binil> ddarius: Nope. Lemme read more of the book
01:13:12 <ddarius> binil: It was a statement.
01:13:13 <dons> binil: you're about to read a wonderful novel for the first time... :-)
01:13:14 <mauke> binil: it's used for I/O, exceptions, state, logging, non-determinism, ...
01:13:20 <Cale> >>= in general, is essentially the basic idea of monads.
01:13:32 <Undertaker> test
01:13:38 <Cale> It's the main operation implemented by all monads.
01:13:44 <Cale> the other is called "return"
01:13:51 <Cale> (which you also have an example of)
01:14:21 <Cale> In general, you have some computation, and a function taking results of that computation and returning what to do next, and >>= sticks them together.
01:14:35 <Cale> (In a way which depends on which monad you're talking about)
01:14:57 <Cale> IO is a monad
01:15:18 <Cale> So you can write things like  getLine >>= putStrLn
01:15:32 <Cale> which is the program which gets a line of text from the user and prints it back out again.
01:16:00 <Cale> The do-notation desugars into a chain of applications of >>=
01:17:59 <Undertaker> test
01:18:34 <Undertaker> test
01:18:37 <binil> getLine reads from System.in and returns a pair of (whatever the user typed, System) and putStrLn takes that pair decides what to type and where to? (I am trying to make up a story which convinces myself on what seems to be happening with getLine >>= putStrLn) :)
01:18:58 <binil> Cale: Am I right there, or was it absurd?
01:19:44 <Cale> binil: well, sort of, if you want to picture it that way. >>= for IO should really be thought of as primitive
01:19:46 <mauke> m >>= f takes an IO action m and a callback f, and bakes them into a new IO action
01:20:00 <Cale> You can't actually implement >>= for IO in Haskell itself.
01:20:00 <mauke> that when executed runs m, calls f on the result, etc
01:20:41 <Cale> For basically every other monad, >>= is just an ordinary function though.
01:21:10 <Cale> Also, I suppose you could implement >>= for IO if IO was actually a datatype which abstractly represented I/O actions.
01:21:58 <binil> Cale: I C. IO is special because it has this notion of "the outside world" the program interacts with and is hence baked into the system - is that right?
01:22:03 <Cale> yeah
01:22:27 <Cale> So there are a bunch of primitive IO actions, and all the rest are built up from using >>=
01:23:07 <Cale> which is itself primitive, because it needs to know how to hook IO actions together, even though those are otherwise inert, opaque things.
01:23:23 <ddarius> IO is special because it encapsulates side-effectful things; without side-effects there is no way to implement IO.
01:23:38 <Cale> In the end, 'main' is an IO action which the runtime system executes.
01:23:57 <mauke> haskell is just a fancy macro language for IO actions
01:23:59 <Cale> You can't actually look at an IO action from the Haskell-world and tell what it's going to do.
01:24:16 <Cale> But you can put them together.
01:24:31 <mauke> the result of running your haskell program is an IO action, which is then really executed by the system
01:24:36 <Cale> (because you have >>= and other combiners built from >>=)
01:27:03 <Cale> does that make sense?
01:28:57 <binil> Cale: Well, that much does.
01:29:40 <binil> binil: Thanks guys!
01:29:48 <binil> OOPS ..
01:30:00 <binil> Cale & mauke: Thanks guys!
01:30:06 <binil> :-)
01:30:08 <Cale> no problem
01:30:17 <Cale> let us know if you have any more questions
01:30:29 <Cale> You now basically get the main idea about monads :)
01:30:55 <ulfdoz> how can I set default config-dir for cabal-install?
01:38:06 <ulfdoz> ah, ktrace helps to fix the error.
01:48:09 <Cheery> haskell is a bit like blended macroprocessor and evaluator
01:48:35 <Cheery> 'macros' it can't 'process' will drop down to code
01:49:21 <Cheery> thought, the lambda calculus -view is much more useful than this
01:49:24 <cinimod> I'm getting Possible fix: add (Show b) to the existential context for `Intersect'
01:49:41 <cinimod> Can someone point me at what the syntax is for an existential context?
01:49:52 <mauke> what's an existential context?
01:50:06 <cinimod> That was sort of my question
01:51:17 <cinimod> I could guess it would forall b . Show b => ... but I'd rather not play guessing games with the compiler
01:52:08 <mauke> why not?
01:52:19 <mauke> if it compiles, it must be correct
01:52:46 <cinimod> Welll not necessarily  and  it could take me a long time to guess
02:01:32 <cinimod> My first guess didn't work: forall a b . (Show a, Show b) => show (Intersect x y) = show x ++ "^" ++ show y
02:01:56 <mauke> what is Intersect?
02:02:10 <cinimod> Just a data constructor
02:02:20 <ddarius> cinimod: Obviously.
02:02:20 <mauke> yeah, for what type?
02:02:31 <mauke> or rather, what does your instance Show line look like?
02:02:52 <ddarius> What mauke is trying to say is, paste your code.
02:03:06 <cinimod> How do I paste?
02:03:15 <mauke> @paste
02:03:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:03:59 <ulfdoz> haskell.org down?
02:05:53 <dons> hmm.
02:05:55 <dons> sunday again.
02:06:05 <dons> why does this always happen on sunday
02:06:19 <cinimod> What does announce do on hpaste?
02:06:21 <mauke> cronjob?
02:06:27 <mauke> cinimod: try it :-)
02:06:37 <hpaste>  cinimod pasted "Existential Context Problem" at http://hpaste.org/1720
02:06:45 <dons> it does that :-)
02:06:55 <mauke> holy GADT
02:07:31 <tcr> I'm looking for a function with type: Monad m => (a -> b) -> (a -> m b); liftM is close but it would turn it to -> (m a -> m b)
02:07:45 <dons> ulfdoz: it does seem down. yes.
02:08:03 <dons> ?hoogle (a -> b) -> a -> m b
02:08:04 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:08:04 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:08:04 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:08:08 <dons> ?hoogle+
02:08:08 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
02:08:09 <lambdabot> Control.Parallel.Strategies.($||) :: (a -> b) -> Strategy a -> a -> b
02:08:09 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
02:08:15 <mauke> ?type (return .)
02:08:16 <dons> ?hoogle Monad m => (a -> b) -> a -> m b
02:08:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
02:08:21 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
02:08:21 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
02:08:21 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
02:08:28 <mauke> tcr: (return .)
02:08:39 <dons> mauke wins
02:08:40 <therp> yeah sunday.
02:08:52 <mauke> FATLITY
02:09:22 <tcr> Ah, but of course! Thanks!
02:10:06 <cinimod> mauke: it's show (Intersect x y) that seems to want an existential context
02:10:22 <dons> ?unpl (return .)
02:10:22 <lambdabot> (\ a d -> return (a d))
02:10:29 <dons> ?. pl unpl (return .)
02:10:30 <lambdabot> (return .)
02:11:01 <mauke> cinimod: sorry, I don't know anything about GADTs
02:14:08 <tcr> Would you just use (return .), or give it a name?
02:15:02 <TSC> How do you use it?
02:16:23 <tcr> (return .) Constr =<< mapM foo list
02:16:33 <eumenides> > let o = (return .) in (+1) `o` 1
02:16:35 <lambdabot>   add an instance declaration for (Show (m a))
02:17:07 <eumenides> > let o = (return .) in (+1) `o` 1 :: Maybe Int
02:17:09 <lambdabot>  Just 2
02:19:49 <TSC> I'd leave it like that, I reckon
02:20:56 <ddarius> tcr: That combination is just liftM Constr $ mapM foo list
02:21:41 <mauke> whenever you see >>= return ., think liftM
02:21:42 <tcr> ddarius: Right.
02:22:02 <tcr> Well I thought about liftM :) but it didn't work well with the >>=
02:22:38 <ddarius> The point of liftM? is to get rid of the >>=s and make your code more applicative looking.
02:22:57 <tcr> Yeah, makes sense.
02:23:13 <tcr> Thanks!
02:28:37 <hpaste>  cinimod pasted "Simpler Existential Context Problem" at http://hpaste.org/1721
02:29:54 <mauke> where ... G :: (Show b) => a -> b -> A (a, b) maybe?
02:30:41 <cinimod> Yes I thought of that just as I hit the paste button.
02:31:06 <cinimod> Actually it's forall a b . (Show a, Show b) => G :: a -> b -> A (a,b)
02:33:09 <cinimod> I meant    G :: (Show a, Show b) => a -> b -> A (a,b)
02:34:37 <cinimod> GADTs get a bit of getting used to!
02:37:05 <dons> ulfdoz: haskell.org is up now
02:37:15 <dons> cinimod: i had a lot of fun this week encoding non-empty lists as GADTs
02:37:17 <ulfdoz> thx
02:37:38 <dons> their power is not yet fully exploited, GADTs. lots of fun to be had
02:39:03 <dons> cinimod: http://article.gmane.org/gmane.comp.lang.haskell.xmonad/59 was how I used them in xmonad.
02:39:05 <lambdabot> Title: Gmane -- Mail To News And Back Again
02:39:14 <ddarius> data NEList a = Nil a | Cons a (NEList a)
02:39:20 <cinimod> dons: I put a page up on quickchecking GADTs http://haskell.org/haskellwiki/QuickCheck_/_GADT
02:39:21 <lambdabot> Title: QuickCheck / GADT - HaskellWiki
02:39:36 <cinimod> dons: I'll have a look thanks
02:39:52 <dons> oh nice.
02:44:38 <bitwiseshiftleft> question: suppose I have a GADT like so
02:44:46 <bitwiseshiftleft> data WrapMap k v where WrapMap :: Ord k => Map.Map k v -> WrapMap k v
02:44:54 <bitwiseshiftleft> (wrapping the Data.Map type)
02:45:21 <bitwiseshiftleft> why can I then not call
02:45:22 <bitwiseshiftleft> lookup :: Monad m => k -> WrapMap k v -> m v
02:45:23 <bitwiseshiftleft> lookup k (WrapMap wm) = Map.lookup k wm
02:45:28 <bitwiseshiftleft> I get an error
02:45:36 <bitwiseshiftleft> Could not deduce (Ord k) from the context (Monad m)
02:45:37 <bitwiseshiftleft>       arising from use of `Map.lookup' at Foo.hs:7:24-38
02:45:38 <bitwiseshiftleft> any ideas?
02:46:05 <bitwiseshiftleft> ... for that matter, is anyone actually here, or should I just post to the mailing list?
02:46:11 <dons> the Ord constraint isn't propagated.
02:46:12 <dons> ?users
02:46:12 <lambdabot> Maximum users seen in #haskell: 336, currently: 289 (86.0%), active: 28 (9.7%)
02:46:26 <cinimod> I'm here I'm just a slow reader
02:46:32 <bitwiseshiftleft> i see.  is there a good way to make it propagate?
02:46:33 <dons> you'd have to use a proper existential to hide the Order constraint, perhaps.
02:46:45 <dons> :t Data.Map.lookup
02:46:47 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
02:46:58 <bitwiseshiftleft> a proper existential?
02:47:11 <dons> so you're trying to hide the Ord constraint, with the wrapper?
02:47:23 <dons> or are you wrapping it for another reason?
02:47:24 <bitwiseshiftleft> well, the real wrapper has other constructors
02:47:35 <dons> ok. then just add the Ord constraint, as for Data.Map
02:47:36 <bitwiseshiftleft> but part of the reason is to hide the Ord constraint
02:47:59 <bitwiseshiftleft> the other constructors are things like
02:48:07 <bitwiseshiftleft> Cat  :: MetaMap k1 (MetaMap k2  v) -> MetaMap (k1,k2) v
02:48:17 <bitwiseshiftleft> and you can't deduce Ord k1 from Ord (k1,k2) of course
02:48:29 <bitwiseshiftleft> so i can't put the ord on the outside
02:48:30 <dons> it might be possible, using some existential typing tricks, to hide the Ord constraint. but it's not obvious. sounds like a good challenge for the haskell-cafe@ mailing list
02:48:38 <dons> right
02:49:04 <dons> its a good question, bitwiseshiftleft
02:49:11 <bitwiseshiftleft> heh
02:49:17 <bitwiseshiftleft> well, good to know that i'm not just being stupid
02:49:26 <bitwiseshiftleft> is there a particularly good reason why the ord isn't propagated?
02:49:27 <tcr> I'm trying to split my file into several modules. the current directory contains the following: Foo.hs and Foo (a directory), then there's Foo/Bar.hs and Foo/Quux.hs. in Foo.hs, I import Foo.Bar, and in Bar.hs, I import Foo.Quux. This doesn't work: "Foo/Bar.hs: file name does not match module name `Bar'"
02:49:27 <dons> interaction between GADTs, typeclasses, existential types.
02:50:00 <bitwiseshiftleft> tcr: you need to name the module Foo.Bar
02:50:00 <TSC> It should be called Foo.Bar ?
02:50:04 <cinimod> bitwiseshiftleft: Are you going to post a small example?
02:50:19 <bitwiseshiftleft> cinimod: i did.
02:50:57 <tcr> bitwiseshiftleft, TSC: Oh, indeed!
02:51:34 <bitwiseshiftleft> cinimod: if you want the whole source file i'm hacking on
02:51:50 <bitwiseshiftleft> i'll upload it
02:52:14 <bitwiseshiftleft> http://shiftleft.org/tmp/MetaMap.hs
02:53:29 <dons> bitwiseshiftleft: yeah, i'd post the problem as a challenge to haskell-cafe@
02:53:35 <cinimod> bitwiseshiftleft: I'll have a look later on
02:53:37 <bitwiseshiftleft> dons: sounds like fun
02:53:37 <dons> should get some interesting responses, hopefully
02:53:41 <bitwiseshiftleft> yeah
02:53:56 <dons> if you post it just right, Oleg might take a look.
02:54:25 <bitwiseshiftleft> i mean, what i'm really trying to do is to make a Map type that supports constant time (or at least sublinear) "concat" and "append" like operations
02:54:32 <bitwiseshiftleft> without reimplementing Data.Map
02:55:33 <bitwiseshiftleft> so if there's a better way to do this, that would work too
03:13:24 <bitwiseshiftleft> thanks dons, posted to haskell-cafe
03:15:57 <dons> cheers.
03:16:16 <bitwiseshiftleft> and the same to you.
03:16:22 <dons> hmm, nice haskell blog I didn't know about, http://therning.org/magnus/index.php?tag=haskell
03:16:23 <lambdabot> Title: therning.org/ magnus
03:17:38 <kolmodin> yeah, I've stumbled upon that too. must have been part of a few HWN letters?
03:18:00 <dons> no, i don't think i've ever included his site.
03:18:05 <dons> since it doesn't come up in my rss feed.
03:18:13 <dons> anyway, i contacted Magnus, to get it on planet.haskell.org
03:18:15 <kolmodin> right, ok
03:18:23 <kolmodin> yeah, he should
03:19:23 <kolmodin> I've even put my blog on planet.haskell.org, even if only 1 out of 7 posts seems to have been about haskell. hmmm
03:19:26 <kolmodin> :)
03:20:35 <kolmodin> I had several haskell post lined up, but I never get around to writing them
03:21:21 <dons> i liked the post about capsicums :-)
03:21:34 <dons> and the one about keyboards that grow grass
03:21:43 <kolmodin> hah, yes :D
03:24:56 <kolmodin> I'd like to write a few lines about design patterns in haskell. people say they don't exist, you just "do it". but I don't think that's true
03:25:45 <kolmodin> there are clearly different styles of doing things. it'd be helpful for newbies of how to use the strength of haskell, ie lazyness and continuations and such
03:26:05 <kolmodin> I'll come around to it any day now.. :) er...
03:31:04 <kolmodin> dons: do you agree, or is it just to "do it"
03:31:06 <kolmodin> ?
03:31:34 <andun> kolmodin: i'd definately read it =)
03:31:46 <kolmodin> it seems that there aren't as obvious patterns as in java and the like
03:31:51 <kolmodin> andun: great :)
03:32:06 <kolmodin> it'll show up on planet.haskell.org when it's posted
03:39:15 <dons> there are certainly design patterns. they're a bit more precise, sometimes more abstract
03:39:28 <kolmodin> aye
03:39:58 <dons> like, "oh, that's a zipper" :-)
03:40:05 <kolmodin> hah :)
03:40:24 <dons> "ah, I should use an applicative functor"
03:40:26 <kolmodin> I meant more like list of success, list of progress etc
03:40:49 <dons> yeah, one I was thinking about was using a lazy list to model event streams
03:40:59 <dons> i.e. to do event handlers as pure functions
03:41:09 <dons> sequence_ . handle =<< stream-of-events
03:41:25 <kolmodin> yeah, that too
03:54:58 <njbartlett> Can anybody help me with a question related to Lennart Augustsson's Data.Number.Fixed library? He talked about it recently on his blog
03:56:28 <njbartlett> It uses something similar to Oleg's number parameterised types for the precision part of a fixed-precision number
04:01:34 <njbartlett> The problem I have is that I'm reading data from an external source, which has the precision encoded as a field in the stream. This doesn't seem to be compatible with something that uses the type system to represent the precision
04:02:39 <Heffalump> because it's a type class, I think this is actually possible
04:02:48 <Heffalump> actually, is it a type class
04:02:49 * Heffalump forgets
04:03:02 <Heffalump> oh, but the point is that you can use a type class to sort it out, IIRC
04:03:27 <Heffalump> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf # bring in Oleg
04:04:47 <Saizan> i suppose he use a type encoding, so you should be able to convert your precision value to the corresponding type?
04:04:54 <njbartlett> Thanks Heffalump. Will take a look at this
04:13:27 <LeCamarade> Suggestion for Prelude: indeed :: Bool -> Bool -- not not.
04:13:50 <LeCamarade> let indeed = not not in if indeed True then "Yay!" else "Nay!"
04:13:56 <LeCamarade> > let indeed = not not in if indeed True then "Yay!" else "Nay!"
04:13:57 <lambdabot>  Couldn't match expected type `Bool'
04:14:08 <Saizan> not . not?
04:14:32 <LeCamarade> Yes. :o(
04:14:33 <LeCamarade> > let indeed = not . not in if indeed True then "Yay!" else "Nay!"
04:14:35 <lambdabot>  "Yay!"
04:15:13 <Saizan> and why not just id?:)
04:15:28 <LeCamarade> > let indeed = not . not in filter indeed [z < 10 | z <- [1 .. 10]]
04:15:30 <lambdabot>  [True,True,True,True,True,True,True,True,True]
04:15:44 <LeCamarade> Oh. id. :oD
04:16:19 <LeCamarade> So that's why we have id? It looked useless ...
04:17:05 <ndm> hello!
04:17:07 <Heffalump> a better question is why we have $ given we have `id` :-)
04:17:13 <Heffalump> (yes, I know it's shorter and less confusing)
04:17:29 <Heffalump> hi ndm
04:17:49 <LeCamarade> > filter id [z < 5 | z <- [1 .. 10]]
04:17:51 <lambdabot>  [True,True,True,True]
04:18:28 <Saizan> > map (flip id 1) [(*2),(+5)]
04:18:30 <lambdabot>  [2,6]
04:20:46 <kolmodin> hia ndm
04:21:25 <drigz> > [z <- [1..10], z < 5] >> [True]
04:21:26 <lambdabot>  Parse error
04:21:41 <drigz> > [z | z <- [1..10], z < 5] >> [True]
04:21:43 <lambdabot>  [True,True,True,True]
04:22:21 * drigz just started with monads, can you tell?
04:22:52 <ndm> Haskell type classes are way too complex!
04:23:05 <Heffalump> drigz: mixing list comprehensions and monads isn't that basic :-)
04:23:11 <Heffalump> ndm: oh?
04:23:11 <ndm> i'm trying to implement "lots of the useful bits" for Hoogle 4, and its way confusing
04:23:54 <ndm> Heffalump, the rules for instance resolution, the unification, co-inductive instances, MPTC, and termination
04:24:14 <ndm> its easy enough to understand, but hard to implement in a simple way
04:42:54 <fasta> I get 'foo' is not a (visible) method of class `Foo', the foo class is defined in a module A which module B imports. The error I get in is module B. Module A exports Foo in its explicit export list.
04:43:30 <Igloo> Export Foo(..) or Foo(foo)
04:44:19 <fasta> Thanks
05:04:31 <Heffalump> Igloo: when is 6.6.1 likely to appear in Debian?
05:06:13 <Igloo> Couple of weeks I guess. I have to finish updating the extralibs, and then I'll probably give people some time to get their packages ready.
05:06:42 <Baughn> More importantly, when is 6.6.1 likely to appear on osx?
05:08:10 <Heffalump> how can OSX be more important than Debian ;-)
05:10:38 <Baughn> The debian users can always install the binary package.
05:10:42 <Baughn> So can I, but it won't run...
05:16:58 <Mitar> i was editing the http://haskell.org/hawiki/HaskellGoPeople
05:17:00 <lambdabot> Title: HaskellGoPeople - The Haskell Wiki
05:17:26 <Mitar> and after I added myself, i got an error about permission denied from python (some internals)
05:17:55 <Mitar> http://haskell.org/hawiki/MitarMilutinovic
05:17:57 <lambdabot> Title: MitarMilutinovic - The Haskell Wiki
05:19:09 --- mode: ChanServ set +o dons
05:19:14 --- topic: set to '["The Haskell programming language: Summon Iron Coder FUNCTIONAL!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
05:19:20 --- mode: ChanServ set -o dons
05:19:25 <dons> (kowey's blog post today :)
05:19:40 <dons> and with that, I bid you all a good night!
05:20:20 <Heffalump> Baughn: true.
05:20:38 <Pseudonym> Night.
05:22:24 <fasta> Will bad things happen when I make something a Monoid that doesn't obey the laws?
05:22:48 <integral> apart from mysterious bugs?
05:23:00 <Pseudonym> Mysterious bugs are the likeliest.
05:23:27 <Pseudonym> Which laws were you planning to break?
05:23:55 <integral> .oO( You risk prosecution by the monad police )
05:24:04 <fasta> It's more like me being a bit careless whether I really obey to them.
05:24:41 <fasta> I.e. like taking a gun in your suite case to a strange country and assume everything will be fine.
05:24:54 <Pseudonym> Let me put it this way.
05:24:59 <Pseudonym> Whenever you see this:
05:25:09 <Pseudonym> instance (Foo a) => Bar a where { ... }
05:25:13 <Pseudonym> That's an implication.
05:25:27 <Pseudonym> If a is a Foo, then a is a Bar, and here's why...
05:25:52 <Pseudonym> If a isn't a Foo, but there's a Foo class instance for it anyway, then a isn't a Bar, either.
05:25:55 <Pseudonym> In general.
05:26:21 <Pseudonym> In other words, if you break one thing, other things also break.
05:26:52 <fasta> In fact:... what are the monoid laws?
05:26:57 <fasta> Data.Monoid doesn't mention them.
05:27:05 <Pseudonym> Zero identity, and associativity.
05:27:36 <ulfdoz> Is there a module for vector algebra?
05:27:40 <nominolo> what's it called if we have commutativity, too?
05:28:05 <fasta> Oh, ok, then I am not breaking anything :)
05:28:05 <nominolo> a group?
05:28:13 <Pseudonym> You need inverses to be a group.
05:28:20 <Pseudonym> Abelian monoid, probably.
05:29:00 <fasta> Can't a lot of monoid instances be derived automatically?
05:29:15 <Pseudonym> Want to know a secret?
05:29:24 <fasta> That's already possible?
05:29:25 <Pseudonym> There are actually only two monad laws.
05:29:31 <Pseudonym> Oh, you said monoid.
05:29:32 <Pseudonym> Sorry.
05:29:38 <Pseudonym> fasta: Yes, kinda.
05:29:56 <Pseudonym> There are ways to derive implementations such that they automatically obey the laws.
05:30:07 <fasta> Pseudonym: also in GHC?
05:30:16 <Pseudonym> No, by hand.
05:30:31 <fasta> Yes, I figured that out. :)
05:30:53 <fasta> Any mechanical process should be automated
05:31:04 <Pseudonym> I didn't say it was mechanical.
05:31:16 <Pseudonym> The Hughes method requires one creative step.
05:31:33 <fasta> E.g. now I have a Thingie{field::Int*} and for that type it can be done automatically.
05:31:34 <cdsmith> fasta: I know some factory workers who disagree. :)
05:31:41 <hpaste>  (anonymous) pasted "Haskell Wiki error" at http://hpaste.org/1722
05:31:46 <Mitar> http://hpaste.org/1722
05:32:36 <fasta> Except Int isn't an instance of monoid
05:32:42 <fasta> (that's nit-picking)
05:32:52 <fasta> Since for the application I have it is :)
05:32:55 <erider> good morning
05:33:14 <Pseudonym> Ah.
05:33:33 <Pseudonym> Int is close enough to Monoid that it should be fine.
05:33:41 <fasta> In general if all the type elements of the structure are instances of monoid it can be done automatatically
05:33:45 <Pseudonym> Yes.
05:33:59 <fasta> I think that's a fairly common case.
05:34:00 <Pseudonym> TThis is like statistics collection, right?
05:34:15 <fasta> Pseudonym: ?
05:34:43 <Pseudonym> Actually,k I suspect it's one of thbe least common cases.  But when it's what you want, it's EXACTLY what you want.
05:35:10 <Pseudonym> Statistics collection.
05:35:17 <Pseudonym> Like you're counting the number of certain types of event.
05:35:36 <Pseudonym> And you're collecting them using a Writer/WriterT or similaar.
05:35:40 <Pseudonym> Bleah.
05:35:45 <Pseudonym> Sorry, machine froze briefly.
05:36:11 <fasta> Pseudonym: I combine values in a traversal of a tree.
05:36:17 <Pseudonym> Right.
05:36:35 <fasta> Pseudonym: I.e. from top to the item I am interested in.
05:36:52 <fasta> Pseudonym: but isn't that an aggregate value and not statistics?
05:37:20 <Pseudonym> Statistics is one scenario where this is used.
05:37:42 <Pseudonym> I had a guess what you were doing and I guessed wrong. :-)
05:38:25 <pozorvlak> Hi everyone.
05:39:08 <erider> Norm!
05:40:00 <pozorvlak> I'm having a newbie problem with my code running out of memory, and wondered if you guys could help...
05:40:02 <fasta> Pseudonym: In the case that combining two value doesn't make sense (but parts of that value do), is the best thing I can do to use error in those locations?
05:40:35 <Pseudonym> fasta: I guess it'd depend on your application.
05:40:53 <Pseudonym> If it's something you can't predict in advance, and it signals a bug in the program, then error is fine.
05:41:00 <fasta> Pseudonym: I could also refactor the data type, s.t. it can aggregate elements and non aggregate elements, but I think that's overkill
05:41:10 <fasta> Pseudonym: can have*
05:41:18 <Pseudonym> Right.
05:41:25 <Pseudonym> It depends on your application, as I say,.
05:43:20 <TSC> pozorvlak: If you paste your code (if it's small) and make it look like an interesting puzzle, everyone will want to help
05:45:15 <pozorvlak> I get a "ERROR - Garbage collection fails to reclaim sufficient space" error when I try to run the following code:
05:45:34 <pozorvlak> logistic k x = k * x * (1-x)
05:45:34 <pozorvlak> ks = takeWhile (< 1.005) $ iterate (+0.005) 0
05:45:34 <pozorvlak> attractors k = take 100 $ drop 100 $ iterate (logistic k) 0.1
05:45:34 <pozorvlak> ys = map attractors ks
05:45:34 <pozorvlak> showAttractors (k, xs) = unlines $ map (((show k ++ "   ") ++).show) xs
05:45:36 <pozorvlak> main = sequence $ map (putStrLn.showAttractors) $ zip ks ys
05:46:28 <fasta> pozorvlak: it's easier if you paste that
05:46:30 <pozorvlak> I'm trying to mess around with the logistic mapping and bifurcation, and this is meant to produce a .dat file for gnuplot.
05:46:30 <fasta> !paste
05:46:30 <hpaste> Haskell paste bin: http://hpaste.org/
05:46:48 <pozorvlak> Great, thanks!
05:46:58 <fasta> pozorvlak: some people don't have rectangular selection in their IRC clients
05:47:23 <hpaste>  pozorvlak pasted "Logistic mapping out-of-memory" at http://hpaste.org/1723
05:47:35 <pozorvlak> http://hpaste.org/1723
05:47:38 <fasta> pozorvlak: did you compile it?
05:47:56 <pozorvlak> Ah, there's another problem there...
05:48:34 <TSC> It ran for me
05:48:38 <pozorvlak> GHC gives me an "4.1.0/../../../../i586-suse-linux/bin/ld: cannot find -lgmp" error
05:48:47 <pozorvlak> so I've been using ghci and hugs.
05:50:21 <Saizan> how did you get your ghc?
05:50:21 <pozorvlak> Messing around with $LD_LIBRARY_PATH hasn't helped.
05:50:31 <pozorvlak> RPM, IIRC.
05:50:46 <pozorvlak> Version 6.4, if that helps.
05:50:48 <mauke> ah, hugs gives me that error
05:50:58 <TSC> It ran under ghci for me too
05:51:00 <mauke> ghc and runghc work fine
05:51:47 <pozorvlak> Oops, runghc works for me, now I try it - I wasn't aware of it.
05:52:04 <pozorvlak> But still, that algorithm really shouldn't need much memory - is there a way of getting its memory use down?
05:52:19 <pozorvlak> Thanks, mauke!
05:53:25 <Saizan> you could install the 6.6.1 generic-linux package from http://www.haskell.org/ghc/download_ghc_661.html
05:53:27 <lambdabot> Title: GHC: Download version 6.6.1
05:53:56 <mauke> runhugs -h10M irc.hs also works
05:54:10 <Saizan> for the space leak maybe those iterate are allocating many thunks without forcing them?
05:54:16 <TSC> It doesn't seem to take much memory here
05:54:27 <Saizan> espacially since you drop the first 100s
05:55:05 <pozorvlak> Saizan: yeah, I'd assumed it was something like that, but wasn't sure and don't know how to fix it...
05:55:47 <mauke> -h2M seems to be sufficient
05:58:23 <pozorvlak> I just realised there's another bug there - ks should run from 0 to 4 rather than 0 to 1. -h2M isn't enough in that case, but -h10M is.
05:59:11 <Saizan> i'd try with: attractors k = take 100 $ drop 100 $ iterate (\x -> x `seq` logistic k x) 0.1
05:59:30 * fasta would like to have a programming language implementation with free abstractions
05:59:44 <pozorvlak> Wouldn't we all...
06:00:59 <pozorvlak> Saizan: what does seq do? Make it strict somehow?
06:01:14 <fasta> pozorvlak: do you have the documentation installed?
06:02:29 <pozorvlak> Saizan: nah, still space-leaking
06:05:21 <pozorvlak> fasta: I've got some HTML files in /usr/share/doc/ghc, but all it says on seq is the type.
06:05:32 <fasta> pozorvlak: that's odd
06:05:49 <pozorvlak> Hang on, being dumb. Found it.
06:05:55 <fasta> seq :: a -> b -> b
06:05:56 <fasta> The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness.
06:07:00 <fasta> I personally am not sure of what happens with seq (f x) (g(f x)), though
06:07:18 <Heffalump> fasta: the f x gets thrown away
06:07:25 <Heffalump> unless the compiler CSEd it, which I doubt it would
06:07:38 <fasta> Heffalump: what do you mean by thrown away?
06:07:40 <Heffalump> actually, it might. I dunno.
06:07:50 <fasta> Heffalump: you mean it gets evaluated completely before being passed to g ?
06:07:50 <pozorvlak> Heffalump: OK, so the idea is to throw the x away, so only (logistic x) is held in memory?
06:07:58 <Heffalump> fasta: well, seq does enough to verify it's non _|_, then chucks it away and recomputes it to pass to g.
06:08:07 <Heffalump> let y = f x in seq y (g y)
06:08:14 <Heffalump> would be kept
06:08:43 <fasta> Heffalump: recomputed it? Why?
06:08:52 <Baughn> Heffalump: Wouldn't CSEing it be the obvious thing to do?
06:09:06 <Heffalump> fasta: for the same reason that (without CSE) (f x) + (f x) sees f x computed twice
06:09:11 <Heffalump> Baughn: perhaps. I'm not sure.
06:09:13 <Igloo> It wouldn't recompute it, it would pass it uncomputed
06:09:33 <Baughn> Heffalump: Pretty sure it is, and by the definition of seq, ..
06:09:53 <Baughn> seq (f x) (g (f x)) would evaluate f x strictly before invoking h
06:09:55 <Baughn> *g
06:10:14 <Baughn> ..not sure why you'd want that, though
06:10:15 * Igloo doesn't think GHC will CSE that
06:11:00 <fasta> It seems Haskell is not the right language to write compilers in if that's too much work to do.
06:11:35 <Heffalump> Baughn: sure, but then the partially computed value of f x is not kept to pass to g
06:11:38 * Heffalump --> lunch
06:12:08 * Baughn checks the compiler output to confirm
06:12:58 <DRMacIver> It really does seem like GHC does a lot less of the magic that one often hears advocated as reasons why pure functional code is good.
06:14:19 <triplah_> anyone know how to get a newline in math mode in latex?
06:14:36 <triplah_> i need to split an equation over a couple of lines
06:14:37 <DRMacIver> (This isn't a problem as such. There are plenty of non magic reasons why pure functional code is good. I just wish the magic wasn't promised and then denied)
06:14:44 <fasta> The memory thing (stack vs heap) that came up on the mailing lists is also completely ridiculous.
06:14:58 <DRMacIver> fasta: Hm?
06:15:12 <dolio> DRMacIver: Which ones? Auto-parallelization?
06:15:43 <fasta> DRMacIver: your program can run out of stack or heap, while there's lots of memory available
06:16:08 <fasta> Another weakness is that GHC never gives back memory to the OS.
06:16:14 <DRMacIver> dolio: Auto parallelization, auto memoization and/or extensive CSE due to lack of side effects in expressions.
06:16:15 <pozorvlak> triplah_: put it in an array environment, then use \\
06:16:19 <DRMacIver> fasta: Ouch. How?
06:16:35 <triplah_> pozorvlak: ah ok, thanks
06:16:36 <fasta> DRMacIver: on 64 bits architectures this is less of a problem, but it still is.
06:17:01 <fasta> DRMacIver: I don't know the details, Igloo told me.
06:17:19 <fasta> DRMacIver: the stack vs heap thing can be found on the mailing lists.
06:17:24 <DRMacIver> fasta: ok. Thanks.
06:17:45 <pozorvlak> triplah_: if you're doing that a lot, be aware of the AMSLaTeX macro \allowdisplaybreaks, which lets it break pages in the middle of displayed eqn arrays.
06:18:08 <triplah_> pozorvlak: thanks again
06:18:11 <dolio> DRMacIver: Ah. Well, the first isn't a solved problem anywhere to my knowledge.
06:18:22 <pozorvlak> Very very handy if you're putting out long calculations.
06:19:05 <dolio> DRMacIver: The latter two are done by some compilers (not Haskell), but it's not always a win, and I don't know how hard it is to decide when it is.
06:19:33 <pozorvlak> Sorry to be selfish, as this sounds very interesting, but seq didn't actually help with my problem...
06:19:37 <DRMacIver> dolio: Sure. I'm not really objecting to their absence so much as to people saying "Pure functional code is really cool because it lets the compilers do X" where X is somethign that the compilers don't actually do.
06:19:59 <dolio> DRMacIver: Yeah, I understand. :)
06:20:57 <DRMacIver> I mean, it would be *nice* if GHC could be infinitely clever and do those exactly when appropriate (or even just have pragmas for telling it when it's appropriate), but there are obviously higher priorities.
06:21:35 <pejo> DRMacIver, the reason for avoiding CSE with Haskell is to avoid space leaks. With a different evaluation strategy the CSE would be easy.
06:22:41 <Saizan> pozorvlak: compiled with ghc -O2 your code runs in 2mb
06:23:10 <DRMacIver> pejo: Hm. I'm not clear why that would cause space leaks. Is it because e.g. if I have foo +++ foo and this evaluates an awful lot of the first expression then is done with it but hasn't finished with the second expression, this would prevent the garbage collector from collecting the things its evaluated in evaluating foo?
06:24:06 <DRMacIver> Hm. That was poorly explained.
06:24:30 <dolio> It's something like that.
06:24:34 <DRMacIver> Ah, here's what I mean. let ones = 1 : ones in ones ++ ones
06:24:37 <beelsebob> any LaTeX wizards about?
06:25:02 <pozorvlak> beelsebob: not a wizard, but possibly a hedge-magicking conjurer...
06:25:10 <DRMacIver> If this is evaluated to use the same 'object' for both sides of the arguments then taking the head of it repeatedly will cause you to try to build up an arbitrarily long list of 1s in memory
06:25:14 <Saizan> pozorvlak: well, even with -O0, but you waste more time in GC :)
06:25:26 <beelsebob> pozorvlak: do you know if there's a command to make another command a binary/relational operator?
06:25:39 <pozorvlak> \mathrel, if memory serves.
06:26:28 <beelsebob> cool, thanks
06:29:43 <pozorvlak> Saizan, so basically, install a modern GHC and give up on Hugs?
06:31:43 <Saizan> or hand-optimize :)
06:32:29 <pozorvlak> I was really hoping for some advice on the latter...
06:33:06 <Saizan> mmh has hugs some profiling support?
06:33:56 <dolio> DRMacIver: The 'ones' example won't quite do it (for me at least). Try: 'pow [] = [[]] ; pow (x:xs) = map (x:) (pow xs) ++ pow xs'
06:34:28 <dolio> DRMacIver: That runs in constant space, but if you do CSE, it chews up memory.
06:34:43 <DRMacIver> Interesting
06:34:47 <DRMacIver> Thanks
06:36:32 <dolio> But the idea is the same as what you were saying, I think. With CSE, it produces 'pow xs' in the first expression, and holds onto it until the second is done being used in the second.
06:38:48 <dolio> And, plus, (++) copies the first argument, so it will have to produce a copy of pow xs when you inspect the list, but won't be able to throw away the original, because it's being used later.
06:40:55 <dolio> In an eager language, I guess it wouldn't make a difference, because it'd construct the whole list in memory no matter what you do (unless you use some explicit laziness).
06:41:50 <tcr> Is there something in the Prelude that splits a string into a list of words? (i.e. splits a list delimited by some delimeter into chunks
06:42:17 <dolio> words will split by white space.
06:42:32 <dolio> If you want some other delimiter, I think the answer is 'no'.
06:42:36 <DRMacIver> Isn't there wordsBy or something?
06:42:44 <DRMacIver> Hm, no
06:43:31 <Saizan> ?src words
06:43:32 <lambdabot> words s = case dropWhile isSpace s of
06:43:32 <lambdabot>     "" -> []
06:43:32 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:43:50 <pozorvlak> tcr: gds wrote something about this in his blog recently...
06:43:59 <dolio> There isn't a lot of string splitting stuff in the standard libraries.
06:44:03 <pozorvlak> http://totherme.livejournal.com/3845.html
06:44:05 <lambdabot> Title: totherme: "Thinking in types" or "The mind of a programmer"
06:44:08 <dolio> Unless you go for regexes or parsers.
06:44:14 <pozorvlak> You could always shell out to perl :-)
06:46:45 * pozorvlak kills conversation with incredible faux pas...
06:47:25 <dolio> As long as you use Perl 6, it will be fine, I'm sure. :)
06:49:52 <Saizan> it's very strange that we have groupBy nubBy sortBy etc.. but just words and lines
06:51:39 <pozorvlak> tcr: what do you want to split on?
06:52:03 <tcr> words & lines just fit my case, thank you. :)
06:52:27 <Saizan> ?src lines
06:52:27 <lambdabot> Source not found. Take a stress pill and think things over.
06:52:41 <Saizan> > words "foo\nbar" -- test
06:52:45 <lambdabot>  ["foo","bar"]
06:53:25 <pozorvlak> What's the preferred way of doing GUI stuff in Haskell?
06:54:01 <pozorvlak> Continuing on from the logistic mapping stuff, it would be fun to play with other fractals, and constantly switching to gnuplot is no fun.
06:54:12 <qwr> @search gtkhs
06:54:13 <lambdabot> Unknown command, try @list
06:54:21 <Saizan> ?where gtk2hs
06:54:22 <lambdabot> http://haskell.org/gtk2hs/
06:55:37 <pozorvlak> Thanks!
06:57:45 <Syzygy-> Oh my goodness. Pozorvlak was here!
06:57:48 <Syzygy-> And I missed him. DAMN.
07:00:44 <nornagon> @remember pozorvlak You could always shell out to perl :-)
07:00:45 <lambdabot> Done.
07:02:54 <fasta> Syzygy-: Pozorvlak is famous?
07:03:18 <Syzygy-> fasta: Nah, just an old friend of mine.
07:04:52 <ehird`> gtk :(
07:12:43 <cdsmith> The docs on Haskell.org have HsForeignImport and HsForeignExport as constructors for HsDecl.  My ghc doesn't know about them.  What's going on there?
07:12:54 <cdsmith> Language.Haskell.Syntax
07:13:52 <kpreid> you have ghc 6.4?
07:13:57 <cdsmith> 6.6
07:14:09 <cdsmith> I think...
07:14:22 <cdsmith> yeah, 6.6
07:14:31 <kpreid> well, try reading the docs for the version you have, not /latest/
07:15:45 <cdsmith> Ah, okay.  That makes sense, then.
07:16:14 <Heffalump> does 6.6.1 have interface changes?
07:17:02 <Saizan> 6.6.1 has HsForeignImport
07:17:25 <Saizan> ?type Language.Haskell.Syntax.HsForeignImport
07:17:34 <lambdabot>     Not in scope:
07:17:34 <lambdabot>       data constructor `Language.Haskell.Syntax.HsForeignImport'
07:17:57 <kpreid> LB is still 6.4 last I knew, because hs-plugins doesn't work under 6.6 yet
07:18:05 <Saizan> ?version
07:18:06 <lambdabot> lambdabot 4p517, GHC 6.6 (Linux i686 2.66GHz)
07:18:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:18:38 <Saizan> hs-plugins works on 6.6
07:21:31 <hpaste>  matthew-_ pasted "getting good at exploding ghc!" at http://hpaste.org/1724
07:21:43 <matthew-_> silly, silly ghc...
07:23:07 <vegai> Saizan: whoa, finally?
07:23:30 <vegai> Saizan: but not in any released version of hs-plugins?
07:24:16 <sorear> vegai: yeah
07:24:23 <sorear> they should release soon
07:26:48 <matthew-_> how useable are the ghc 6.7 heads?
07:27:15 <Heffalump> matthew-_: fairly, if you can get them to build
07:27:52 <hpaste>  pitecus pasted "runInteractiveCommand" at http://hpaste.org/1725
07:27:53 <Heffalump> augustss keeps having problems with that (on Windows), but I haven't heard complaints about language bugs once it does build and run
07:28:03 <matthew-_> Heffalump: is there a list of features that have been added to them since 6.6?
07:28:12 <pitecus> Can someone explain why what i just pasted doesnt work?
07:28:26 <Heffalump> the recent mailing list post about whether to focus on 6.8 had a list, IIRC
07:28:27 <pitecus> Sometimes it just prints Answer1
07:28:37 <matthew-_> I'm on a slow laptop (x86) running debian - I don't really want to compile!
07:28:38 <pitecus> an d sometimes Answer1
07:28:38 <pitecus> *** Exception: fd:7: hGetLine: end of file
07:28:53 <matthew-_> Heffalump: ok, cheers, I'll have a read
07:29:21 <tcr> is there already something shorter for `case foo of Constr -> true; _ -> false'? Otherwise, I'd write an `is Constr foo' myself.
07:30:12 <sorear> matthew-_: well, you're in luck
07:30:34 <Heffalump> tcr: nope
07:30:36 <sorear> matthew-_: GHC6.7 compiled everything -O about three times faster
07:30:53 <sorear> matthew-_: including itself - full HEAD builds take 90 mins
07:31:05 <Heffalump> is the generated code much faster?
07:31:21 <sorear> a few percent.
07:31:27 <sorear> if was on nobench
07:31:31 <sorear> emphasis on was
07:31:50 <sorear> dons thinks stream fusion is more important than other compilers now
07:31:59 <Heffalump> I don't follow.
07:32:14 <Wild_Cat> <n00b> what's stream fusion?
07:32:37 <sorear> A pathetic little thing dons has been working on
07:32:39 <sorear> Heffalump:
07:32:39 <nominolo> ?where stream fusion
07:32:40 <lambdabot> I know nothing about stream.
07:32:47 <sorear> @where nobench-results
07:32:48 <lambdabot> I know nothing about nobench-results.
07:32:54 <matthew-_> sorear: err, sorry, what do you mean I'm in luck? the last build for x86 on http://www.haskell.org/ghc/dist/current/dist/ is 2070404
07:32:55 <lambdabot> Title: Index of /ghc/dist/current/dist
07:33:06 <sorear> http://www.cse.unsw.edu.au/~dons/nobench/results.html
07:33:07 <lambdabot> Title: nobench: Haskell implementation shootout
07:33:21 <sorear> @where+ nobench http://www.cse.unsw.edu.au/~dons/nobench/results.html
07:33:22 <lambdabot> Done.
07:33:31 <Heffalump> sorear: I mean that I don't understand what you mean about it being "more important than other compilers".
07:33:38 <pejo> Is this the ordinary lambdabot? And why does it keep forgetting facts?
07:33:39 <sorear> As you can see, it contains no useful information.
07:33:44 <sorear> @uptime
07:33:45 <lambdabot> uptime: 13d 7h 48m 12s, longest uptime: 13d 7h 48m 12s
07:34:01 <sorear> Heffalump: As you can see nobench only lists GHC
07:34:24 <Heffalump> right..
07:34:41 <sorear> Heffalump: in the old days it compared ghc/ghc-head/ghc-fasm/jhc/hbc/yhc/nhc98/hugs
07:34:59 <Heffalump> and now it just compares different ghcs?
07:35:17 <sorear> and now it just compares one ghc with different versions of base.
07:35:34 <pitecus> Im sure it's something simple, maybe someone can point me to a tutorial on how to run interactive processes from haskell...
07:35:47 <Heffalump> ah, right
07:35:49 <sorear> runInteractiveProcess maybe?
07:35:57 <sorear> in System.Process
07:36:09 <Heffalump> so what you're trying to tell me is that we don't know how much faster GHC HEAD is because we don't measure it any more?
07:36:10 <pitecus> ya im having problems with it
07:36:12 <pitecus> http://hpaste.org/1725
07:36:14 <sorear> Heffalump: yes.
07:36:31 <matthew-_> sorear: in a recent post, you said gadts and type classes are broken everywhere but head. Can you give me an example of the brokenness?
07:36:55 <Heffalump> well, a few percent overall isn't that big a deal anyway, I guess. Specific major improvements for certain usages sound more interesting.
07:37:03 <Heffalump> matthew-_: I thought they were only broken in edge cases.
07:37:14 <sorear> matthew-_: read the post I was replying to
07:37:39 <matthew-_> sorear: ok.
07:38:08 <matthew-_> Heffalump: I have some really weird issues going on which I suspect are edge cases.
07:39:35 <pitecus> I can't figure out how to send a line to a process and read back the answer sequentially
07:44:05 <matthew-_> pitecus: I wouldn't use the hSetBuffering. I'd use hPutStr .. hFlush, then hPutStr .. hFlush, then (l1:l2:_) = lines (hGetContents ..)
07:44:26 <matthew-_> pitecus: lazy IO takes a little practise to get used to! ;)
07:45:58 <pitecus> mathew the thing is i can't get all the answers at the end. I need the first answer to ask the second question etc
07:46:11 <der_eq> gtk2hs question: in Graphics.UI.Gtk.ModelView.IconView.iconViewSetTextColumn, what does the Int parameter refer to?
07:46:23 <pitecus> hFlush doesn seem to change anything anyway
07:46:29 <sorear> pitecus: you might want to use a language that was designed for this, like expect...
07:46:53 <pitecus> sorear, sorry i dont follow?
07:47:55 <sorear> 'expect' is a Tcl library with control structures and stuff for scripting programs that weren't designed to be scripted.
07:48:06 <sorear> very old, very well established
07:48:16 <matthew-_> pitecus: err, ok, so there is the possibility that without the hFlush inp, the output isn't actually arriving at the child process
07:50:34 <pitecus> matthew-_, even when i change the program to do what you said it juts prints an empty string
07:50:44 <matthew-_> pitecus: also, do you mean to use hPutStr rather than hPutStrLn ?
07:51:25 <pitecus> ya right
07:51:28 <sioraiocht> @src sequence_
07:51:29 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:51:43 <pitecus> matthew-_, still the result is the same...
07:51:56 <sioraiocht> @src sequence
07:51:57 <lambdabot> sequence ms = foldr k (return []) ms
07:51:57 <lambdabot>     where
07:51:57 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:53:36 <matthew-_> pitecus: ok, after the answer1 <- ..., try length answer `seq` return ()
07:53:50 <matthew-_> err, s/answer /answer1 /
07:56:17 <pitecus> matthew-_, doesnt work. In any case, shouldn't trying to print the answer force it anyway?
07:56:32 <matthew-_> yes, it should
08:00:05 <matthew-_> pitecus: bizarre, I can't make it work, it terminates ghci here!
08:00:40 <pitecus> yes i saw that. Im running it with runghc but it doesn't work either
08:01:50 <pitecus> haskell wasnt made for IO ;-)
08:02:03 <Heffalump> it does IO pretty well, IMO
08:02:30 <pitecus> well except in this case i guess
08:02:32 <matthew-_> Heffalump: yeah, I've had few issues with IO in the past, but this one is odd...
08:02:44 <Heffalump> I wasn't following the details.
08:02:51 * Heffalump reads scrollback
08:03:42 <Heffalump> I would avoid using hGetContents if you are trying to interact with a process
08:03:56 <Heffalump> I can't see how it could work sanely.
08:04:08 <pitecus> Heffalump, y wasn't using that, just hGetLine
08:04:15 <Heffalump> ah, ok
08:04:27 <Heffalump> I still don't quite understand what the problem is.
08:04:37 <pitecus> http://hpaste.org/1725
08:04:37 <matthew-_> Heffalump: it doesn't work ;)
08:04:44 <sorear> pitecus: GHC proces control *sucks*
08:05:00 <sorear> pitecus: that's the cost of having support for lightweight threads
08:05:09 <Heffalump> why are you running echo?
08:05:16 <Heffalump> and then feeding it stuff on stdin?
08:05:16 <sorear> pitecus: I'd suggest using a well established system like Expect
08:05:34 <Heffalump> are you confusing echo and cat?
08:05:37 <pitecus> Heffalump, its just an example
08:05:48 <sorear> pitecus: a broken example
08:05:51 <Heffalump> but echo doesn't read from stdin, AFAIK...
08:05:57 <sorear> pitecus: you will get empty every time
08:06:14 <matthew-_> pitecus, try running cat with as runInteractiveProcess with the first arg set to "-" and every other param Nothing
08:06:31 * matthew-_ kicks himself for not noticing that!
08:07:03 <sorear> matthew-_: cat with no arguments will cat stdin
08:07:30 <ehird`> is  there a way to tell prelude to go away
08:07:48 <sorear> import Prelude()
08:07:48 <pitecus> OK sorry , Ill try with cat
08:08:00 <Heffalump> I don't think you want - as the first argument.
08:08:07 <Heffalump> (as sorear says)
08:08:25 <matthew-_> Heffalump, oh ok. I often do cat - > foo to build a file with foo.
08:08:54 <matthew-_> and pitecus: there's not a chance it'll work as cat won't start spewing out until it sees eof
08:08:58 * ehird` pasted http://pastie.textmate.org/59359
08:09:01 <ehird`> taking "haskell stdlib written in haskell" too far :)
08:09:04 <ehird`> by god they're slow
08:09:18 <matthew-_> which it won't until inp is closed
08:09:35 <matthew-_> so you won't be able to hGetLine with inp still open
08:10:08 <pitecus> matthew-_, in reality i have to interact with a process which read a line and writes an answer immediately
08:10:40 <matthew-_> um, I'll just be quite now, because I think all of that was wrong anyway...
08:10:53 <sorear> matthew-_: Cat starts catting immediately.
08:11:04 <sorear> matthew-_: buffered input will still bite you
08:11:20 <matthew-_> sorear: yeah, so my tests just showed me... grr!
08:11:35 <matthew-_> now, is there any way of using the do syntax without it being in a monad?
08:11:43 <sorear> matthew-_: no, why?
08:12:15 <matthew-_> sorear, because I need to define something that's a bit more than a Monad and I want to allow it to be used with do syntax
08:12:30 <sorear> matthew-_: like a non-parametric monad?
08:12:53 <sorear> matthew-_: will you accept ghc exts?
08:13:13 <matthew-_> sorear: no, too many parameters eg instance Monad (Foo a) where ... where Foo :: * -> * -> * and the 'a' varies
08:13:18 <pitecus> It still doesnt work, either with cat or with a program which repeats each line and flushed
08:13:28 <matthew-_> sorear: oh, I have many extensions turned on already!
08:13:41 <sorear> matthew-_: -fno-implicit-prelude
08:13:51 <sorear> matthew-_: then define your own (>>=) and return
08:14:30 <matthew-_> sorear: yikes! That seems scary and slightly hacky! Is that safe?
08:14:36 <sorear> without -fno-implicit-prelude, do notation uses Prelude.>>= and Prelude.return, regardless of imports
08:14:55 <sorear> matthew-_: it is the reason -fno-implicit-prelude was added
08:16:00 <matthew-_> would that work as a library? I.e. could you, in the library use -fno-implicit-prelude and then when you import the library make use of "normal" monads and "funky" monads?
08:16:20 <rad7> hi
08:16:24 <sorear> GHC allows most kinds of built-in syntax to be rebound by the user, to facilitate replacing the Prelude with a home-grown version, for example.
08:16:24 <sorear> You may want to define your own numeric class hierarchy. It completely defeats that purpose if the literal "1" means "Prelude.fromInteger 1", which is what the Haskell Report specifies. So the -fno-implicit-prelude flag causes the following pieces of built-in syntax to refer to whatever is in scope, not the Prelude versions:
08:16:43 <sorear> matthew-_: no, you'd have to give -fno-implicit-prelude in the user module
08:17:07 <matthew-_> damn, ghc HEAD build failed in the arrows lib.
08:17:09 <rad7> I have compiled lambdabot and I can't run this... I don't know how to confogure it... :/ I have darcs version
08:17:30 <sorear> ./lambdabot -e offline
08:17:51 <rad7> ok
08:17:59 <sorear> btw, I'm the person responsible from making ./lambdabot with no args immediately exit
08:18:05 <sorear> s/from/for
08:18:10 <rad7> radek@house ~/irc/lambdabot $  ./lambdabot -e offline
08:18:10 <rad7> Initialising plugins .....................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
08:18:10 <rad7> .................. done.
08:18:10 <rad7> IrcMessage {msgServer = "offlinerc", msgLBName = "offline", msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["offline",":@offline"]}
08:18:11 <rad7> Exception: all servers detached
08:19:14 <sorear> That's weird...
08:19:32 <sorear> stefan@stefans:/usr/local/src/lbbuild$ ./lambdabot -e offline
08:19:32 <sorear> Initialising plugins .....................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
08:19:32 <sorear> .................. done.
08:19:32 <sorear> lambdabot>
08:20:21 <rad7> hmm... maybe Config.hs is bad ?
08:20:30 <sorear> If you do ./lambdabot -e yow  does it do something appropriate/
08:21:09 <rad7> Exception: all servers detached
08:21:34 <sorear> rad7: Aside from changing the command prefixes, I don't see anything in Config.hs that could do this.
08:22:51 <sorear> rad7: Are you using the default command prefixes? (@ and ?)
08:23:40 <sorear> rad7: try ./lambdabot -e '!+'offline       substitue + for your command prefix
08:24:29 <sorear> mnislaih++ ghci debugger is nice
08:24:54 <mnislaih> that's only because Simon has been pouring hours on it lately :)
08:25:05 <mnislaih> not to say Bernie
08:25:35 <mnislaih> I only take care of the :print command now
08:26:18 <sorear> How much control over the debugger can you exercise using the GHC-API?
08:26:39 <mnislaih> plenty. The plan is to allow for easy integration
08:26:53 <mnislaih> I wanted to integrate it in Shim, for example, but didn't get around to it yet
08:27:07 <mnislaih> but anyway, it should be perfectly possible
08:27:48 <sorear> I don't want to use it as a debugger.
08:28:08 <sorear> I'd like to see it twisted and abused to generate Hat traces.
08:29:12 <rad7> radek@house ~/irc/lambdabot $  ./lambdabot -e '!+'offline
08:29:12 <rad7> Initialising plugins .....................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
08:29:12 <rad7> .................. done.
08:29:12 <rad7> IrcMessage {msgServer = "offlinerc", msgLBName = "offline", msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["offline",":+offline"]}
08:29:13 <rad7> Exception: all servers detached
08:29:31 <sorear> rad7: what command chars are you using?
08:29:40 <mnislaih> sorear that's interesting
08:29:47 <Saizan> ?where binary
08:29:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
08:30:12 <mnislaih> maybe you should try to convince the SoC project guy
08:30:17 <sorear> mnislaih: So, perfectly trivial if I can hook my own code into the tick handler.
08:30:37 <sorear> mnislaih: Or I can fake it (probably much slower) using :step's code
08:30:58 <mnislaih> no, I don't think you can hook directly on the tick handler
08:31:15 <mnislaih> but I'm not very familiar with how it works now, better ask Bernie or Simon
08:31:53 <rad7> sorear: command chars?
08:33:33 <sorear> rad7: I think you edited Config.hs and changed the value of commandPrefixes
08:34:13 <rad7> yes i choose .
08:34:17 <rad7> dot
08:34:37 <sorear> then try ./lambdabot -e '!.offline'
08:34:50 <sorear> it should autodetect, but it doesn't
08:34:56 <beelsebob> yay, the BBC wins again... http://www.cs.kent.ac.uk/people/rpg/tatd2/silly.png
08:35:12 <rad7> ok
08:36:32 <sorear> @where hat
08:36:33 <lambdabot> http://www.haskell.org/hat/
08:36:54 <rad7> sorear: done :):) thanks :) and what next?
08:37:00 <beelsebob> yay, someone using hat!!!!
08:37:01 <beelsebob> *g*
08:38:42 <rad7> sorear: yes :) I see console :D
08:39:24 <sorear> rad7: it won't quite work, though, since offline wants to send everything with a .
08:39:28 <sorear> s/./@
08:39:59 <sorear> feed msg = let msg' = case msg of '>':xs -> "@run " ++ xs
08:39:59 <sorear>                                   '!':xs -> xs
08:39:59 <sorear>                                   _      -> "@"     ++ dropWhile (== ' ') msg
08:40:07 <sorear> you'll want to change that to
08:40:40 <sorear> feed msg = let msg' = case msg of '>':xs -> head (commandPrefixes config) ++ "run " ++ xs
08:40:40 <sorear>                                   '!':xs -> xs
08:40:40 <sorear>                                   _      -> head (commandPrefixes config) ++ dropWhile (== ' ') msg
08:40:53 <sorear> you may need to add an import Config
08:41:01 <sorear> in Plugin/OfflineRC.hs
08:41:18 <rad7> hm.. i'm beginner in lambdabot
08:41:43 <sorear> what you've found I'd call a bug...
08:42:28 <rad7> sorear: how I can enter server parametrs?
08:42:59 <sorear> rad7: look at online.rc
08:43:05 <rad7> ok
08:43:11 <sorear> it's a file full of commands to connect to freenode
08:43:14 <beelsebob> sorear: out of interest, what are you interested in poking hat for?
08:43:34 <sorear> beelsebob: I think it would be neat to have it work
08:43:41 <beelsebob> hehe :P
08:43:46 <beelsebob> define "work"
08:43:52 <sorear> <sorear> How much control over the debugger can you exercise using the GHC-API?
08:43:52 <sorear> <sorear> I don't want to use it as a debugger.                            [08:26]
08:43:52 <sorear> <sorear> I'd like to see it twisted and abused to generate Hat traces.
08:44:07 <sorear> well, be usable :)
08:44:09 <beelsebob> sorear: ah, I see
08:44:12 <beelsebob> a fun idea
08:44:14 <beelsebob> it is usable
08:44:19 <beelsebob> as long as you write Haskell
08:44:40 <sorear> how hard is it to install?
08:44:47 <beelsebob> usually not hard
08:44:56 <beelsebob> but some platforms have odd problems occasionally
08:45:07 <rad7> hmm... any command doesn't work in lambdabot
08:45:39 <sorear> rad7: yeah, the bug you've stumbled on means that every command must be prefixed with '!.'
08:45:48 <rad7> heeheh
08:45:59 <rad7> yezs
08:46:01 <rad7> yes;)
08:47:52 <sorear> beelsebob: it managed to misconfigure itself
08:47:59 <beelsebob> oh?
08:48:35 <beelsebob> which platform, and in what way?
08:48:35 <sorear> i386-debian-linux
08:48:35 <sorear> (this is not the original error) MkProg: hmake: the compiler 'ghc' is not known.
08:48:36 <sorear> aiee.
08:48:43 <ehird`> hmake exists?
08:48:53 <ehird`> damn. i had it aliased to ghc --make
08:48:57 <beelsebob> lol
08:49:12 <beelsebob> hmake --version?
08:49:13 <sorear> the original error was
08:49:15 <sorear> stefan@stefans:/usr/local/src/hat$ grep -C1 LINE lib/ix86-Linux/config
08:49:15 <sorear> CC=gcc
08:49:18 <sorear> GHCSYM={-# LINE 1 "ghcsym.hs" #-}
08:49:21 <sorear> 607
08:49:25 <beelsebob> ahhhh!
08:49:29 <beelsebob> I see what's happened
08:49:30 <sorear> beelsebob: I'm using Debian hmake, which I assume knows about Debian ghc
08:49:33 <beelsebob> same bug as happens on OS X
08:49:42 <sorear> but I fixed THAT one.
08:49:50 <sorear> now I need to fix my hmake problem
08:49:55 <ehird`> what's hmake
08:49:58 <beelsebob> how did you fix that one?
08:50:04 <sorear> beelsebob: mg
08:50:08 <beelsebob> ehird`: hmake is a make program for Haskell
08:50:23 <ehird`> ah
08:50:27 <ehird`> ghc --make has problems or something?
08:50:36 <beelsebob> ehird`: it didn't exist when hmake was written
08:50:44 <ehird`> ah
08:50:56 <beelsebob> sorear: mg??
08:51:05 <sorear> beelsebob: Yeah, it's a text editor.
08:51:15 <beelsebob> yeh, where did you fix that error?
08:51:24 <beelsebob> there's two places it needs fixed
08:51:29 <sorear> beelsebob: Oh?
08:51:32 <beelsebob> yep
08:51:39 <sorear> beelsebob: I just edited one file
08:51:46 <beelsebob> two secs
08:51:58 <sorear> lib/ix86-Linux/config  specifically
08:52:07 <beelsebob> yeh, that and...
08:52:14 <sorear> did you think I fixed the configscript itself?
08:52:18 <sorear> sorry :)
08:52:33 <beelsebob> targets/ghcsym
08:52:47 <jfredett> are there any good  IDE's for Haskell, I'm really missing a Dr. Scheme ala haskell, and the Eclipse plugin seems to be broken...
08:52:59 <beelsebob> jfredett: there's an XCode plug in
08:53:07 <ehird`> jfredett: vim, emacs
08:53:11 <ehird`> are the main choices. it seems
08:53:28 <jfredett> I love Vim /Emacs, I do not however love them for interpreted languages
08:53:34 <ehird`> ummm
08:53:36 <ehird`> why the hell not
08:53:39 <ehird`> there's a c interpreter you know
08:53:43 <ehird`> better stop using them for c
08:53:48 <jfredett> but its not designed that way
08:53:53 <ehird`> wtf
08:53:57 <ehird`> haskell has many compilers
08:54:05 <ehird`> it wasn't designed with either compiler or interpreter in mind
08:54:37 <sorear> no, haskell was designed for compilers.
08:54:39 <jfredett> ehird, I understand that, but when I write C, I don't need to think as hard, so I don't need to do a step by step test and retest
08:54:50 <beelsebob> Haskell really was designed to be compiled
08:54:55 <sorear> it's syntactically impossible to make an interactive interpreter for haskell
08:54:57 <beelsebob> otherwise it wouldn't need multiple passes
08:55:02 <jfredett> whereas w/ fp, I typically write a line, make sure it runs, write a line, etc.
08:55:02 <ehird`> jfredett: you don;t need to think as hard! oohhhhhhhhh
08:55:13 <ehird`> that makes sense then!
08:55:18 <jfredett> lol, typically because of the task I'm working on
08:55:19 <sorear> beelsebob: how do I tell hmake about ghc?  strace -eopen hmake -hc=ghc isn't telling me
08:55:22 <ehird`> i suggest ed. it has less features, so you think less
08:55:41 <shapr> Non-strictness makes you think.
08:55:48 <sorear> jfredett: usually I write 200 lines, test, repeat.  it's with C that I have to go a function at a time
08:55:53 <jfredett> in FP, I'm writing Automated Theorem provers, In C, I'm writing some predefined librarys.
08:56:01 <jfredett> implementing some algos
08:56:06 <jfredett> that I need to run fast
08:56:06 <beelsebob> sorear: not sure, is it still bitching about not seeing ghc?
08:56:13 <sorear> beelsebob: yeah
08:56:14 <beelsebob> did ./configure pick up ghc as your compiler?
08:56:21 <beelsebob> as just about the first thing it did
08:57:07 <sorear> /etc/ld.so.cache /lib/libncurses.so.5 /lib/i686/cmov/libdl.so.2 /lib/i686/cmov/libc.so.6 /dev/tty /proc/meminfo /usr/bin/hmake
08:57:11 <jfredett> if the algo is already implemented, Theres not typically a ton of thinking on my part, just cut and paste, so Vi is fine- when I'm trying to invent an algorithm, theres more thinking involved.
08:57:12 <sorear> all the files open(2)ed
08:57:20 <sorear> beelsebob: yeah
08:57:52 <beelsebob> sorear: which ghc?
08:58:17 <sorear> Aha!
08:58:32 <beelsebob> hmm?
08:58:38 <sorear> I need to give hmake valid arguments before it will even try to open its config!
08:58:40 <shapr> mmm, code
08:58:47 <beelsebob> I see
08:58:52 <shapr> jfredett: Were you porting an algorithm to Haskell?
09:00:04 * shapr reads the logs
09:00:06 <ehird`> vim has many ide-like features
09:00:07 <ehird`> note: not vi
09:00:17 <jfredett> shapr, hmm? whatdya mean? I was trying to say that occasionally I need code to run really fast, So i write it in C, using Vim (or emacs, depending on my mood)
09:00:23 <sorear> /usr/lib/hmake/debian
09:00:37 <jfredett> well, C + assembler
09:00:41 * beelsebob tends to use SEE and a terminal window
09:00:47 <Baughn> dmwit: Did you ever figure out the CFG thing?
09:00:49 <jfredett> and Vim/Emacs is wonderful for that,
09:00:56 <dmwit> Baughn: Yeah, are you interested?
09:01:03 <jfredett> it fits the way my brain is working at that time.
09:01:06 <shapr> I just throw more hardware at a tuned Haskell program, I don't want to maintain C code.
09:01:07 <ehird`> jfredett: your arguments are illogical
09:01:12 <shapr> But if it fits your head, that's good for you.
09:01:26 <sorear> /var/lib/hmake/debian/hmakerc
09:01:44 <Baughn> dmwit: Yes, though on second thought this is a bad time. Though if you /msg it, I'll read it later. ;)
09:01:58 <ventonegro> jfredett, I edit in vim and test with ghci
09:02:15 <sorear> beelsebob: how is compiler name specified in hmakerc?
09:02:15 <jfredett> shapr,  right, the issue I have is, Vim/Emacs doesn't fit my brain as much for writing haskell
09:02:16 <shapr> I edit with emacs and test in ghci.
09:02:28 <shapr> Er, how do you write Haskell code then?
09:02:34 <ehird`> i edit with cat> and test with as
09:02:37 <beelsebob> sorear: not sure -- I've never looked at that
09:02:39 <sorear> aha.  I have -hc=ghc6
09:02:45 <beelsebob> looks likely
09:02:52 <beelsebob> so do "which ghc6" and see what happens
09:02:58 <jfredett> ehird`, I'm not trying to make an argument, I'm trying to ask if anyone knows of good IDEs other than Vim/Emacs.
09:03:13 <sorear> ghc-6.6: unknown package: lang
09:03:18 <sorear> wth is that?
09:03:23 <shapr> jfredett: I think Eclipse has some Haskell support.
09:03:26 <ventonegro> i thought it was possible to run ghci from within emacs
09:03:38 <shapr> ventonegro: It is, C-c C-l from inside haskell-mode.
09:03:40 <sorear> ventonegro: you can run anything within emacs.
09:03:47 <shapr> That dumps the current buffer into ghci.
09:03:50 <sorear> ventonegro: it is a terminal emulator after all :)
09:03:53 <ehird`> jfredett: there isn't many
09:03:57 <beelsebob> sorear: ahhh, that's a known one due to new ghc
09:04:09 <beelsebob> which unfortunately needs you to bugger about with a lot of files
09:04:10 <ventonegro> i know, it's actually an elisp interpreter, so...
09:04:22 <jfredett> shapr, I know, I tried it, it failed miserably :(, Eclipse is making me angrier by the day
09:04:27 <sorear> beelsebob: okay, three strikes, hat's out :p
09:04:34 <beelsebob> sorear: fair enough :)
09:04:36 <beelsebob> :P
09:04:51 <shapr> jfredett: Your best choice may be to jump into Yi :-)
09:04:56 <sorear> gee someone needs to cabalize hat :)
09:04:57 <ventonegro> someday i'm gonna write a vi replacement scriptable in scheme, the best of both worlds! :-)
09:05:08 <sorear> ventonegro: it already exists
09:05:17 <ventonegro> sorear, damn!
09:05:21 <tcr> Is there a way to trace a whole function? (I know about Debug.Trace.trace, but I'd like to have something more like Lisp's TRACE.) (I'm using Ghci)
09:05:22 <ventonegro> sorear, where is it?
09:05:24 <sorear> ventonegro: you may even have heard of it.  it's called 'vim'
09:05:36 <ventonegro> sorear, :-P
09:05:44 <ventonegro> sorear, you mean the mzscheme integration?
09:05:50 <sorear> ventonegro: yes
09:06:00 <shapr> Wow, I'm down to 14th on the #haskell lines ranking for 2007.
09:06:24 <mauke> QUICK DO SOMETHING
09:06:31 <shapr> oh NO!
09:06:38 <shapr> I'm still 1st overall though..
09:06:46 <ventonegro> sorear, nah, most of the scripts are written in the ugly-as-hell vim script lang
09:06:48 <shapr> Still beating lambdabot by fifteen thousand lines! Yow!
09:07:05 <ventonegro> mine is gonna be PURE! bwahahahaha
09:07:08 <shapr> No wonder people thought I was a bot for a few years.
09:07:15 <shapr> Anyway, what cool code is floating around #haskell the past few days?
09:08:02 <tcr> Is there a way to turn off tail-call-optimization in ghci?
09:08:17 <Heffalump> tcr: why would you want to?
09:08:29 <tcr> Heffalump: Debugging, obviously.
09:08:41 <Heffalump> ah, right
09:08:46 <beelsebob> tcr: define debugging
09:09:11 <tcr> well the next question would have been if it was possible to get a backtrace after a stack overflow :)
09:09:24 <beelsebob> it is, you need to turn profiling on
09:09:34 <beelsebob> and run it with +RTS -xc
09:11:16 <sorear> beelsebob: won't work
09:11:21 <sorear> <tcr> Is there a way to turn off tail-call-optimization in ghci?          [09:06]
09:11:25 <beelsebob> it has done for me before/
09:11:33 <sorear> beelsebob: -prof is incompatible with --interactive
09:11:43 <beelsebob> so don't use --interactive :P
09:12:33 <shapr> Has anyone gotten Haskore to work with SuperCollider?
09:18:43 <tcr> I'm trying to use ghc, but it fails with "Failed to load interface for ...", although it perfectly works from within ghci.
09:19:54 <shapr> Can you hpaste the entire error?
09:20:21 <tcr> how am I supposed to use the ghc binary?
09:20:33 <shapr> To do what?
09:20:36 <sorear> ghc --make program.hs
09:21:00 <sorear> without --make you need to list all source files, or use an external make program
09:21:07 <shapr> Yeah, --make is the most common use. That turns a Main module into an executable program.
09:22:13 <Saizan> sorear: can you compile a program that imports Data.Binary with ghc head? i get linking errors
09:23:26 <sorear> Saizan: --make
09:23:41 <Saizan> sorear: i'm using it
09:23:54 <sorear> Saizan: oh, nice, what link errors?
09:24:50 <sorear> stefan@stefans:/tmp$ ghc-6.7.20070402 -package binary X.hs
09:24:50 <sorear> stefan@stefans:/tmp$ cat X.hs
09:24:50 <sorear> import Data.Binary
09:24:50 <sorear> main = encode (2::Int) `seq` return ()
09:25:05 <sorear> works fine with my most recent head that has binary installed.
09:25:10 <hpaste>  Saizan pasted "link errors" at http://hpaste.org/1726
09:25:36 <sorear> hpaste: there was a bug report about that very recently
09:26:09 <tcr> ghc --make Main.hs +RTS -xc
09:26:30 <tcr> doesn't work, I must be misunderstanding something
09:26:32 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1282
09:26:34 <lambdabot> Title: #1282 (binary package wants uncheckedShift functions to be exported from base) - ...
09:26:50 <sorear> tcr: +RTS options are for the *run time system*
09:26:56 <sorear> tcr: not the compile time!
09:27:19 <tcr> sorear: Ah, I see. Do I have to pass some flag to the compiler to enable profiling?
09:27:22 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/runtime-control.html
09:27:24 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/2hoaa9
09:27:25 <sorear> -prof -auto-all
09:28:43 <shapr> tcr: Can you hpaste your code?
09:28:49 <shapr> Ah, I see
09:29:12 <shapr> hej bringert!
09:29:25 <bringert> hej shapr
09:29:29 * bringert is taking off again
09:29:36 * Heffalump recommends -caf-all too, except that it doesn't work with -O0.
09:29:57 <Heffalump> lots of things seem to end up in CAFs even if you didn't put them there, as far as I can tell.
09:31:05 <Saizan> sorear: so the problem is that i've a too recent version of ghc where the names are different?
09:33:53 <dmwit> > 15*16*16+10*16+11
09:33:57 <lambdabot>  4011
09:34:08 <sorear> > 0xFAB
09:34:10 <lambdabot>  4011
09:34:21 <dmwit> bah
09:34:27 <tcr> Can I tell the compiler not to try to look for the profiling stuff for all the libraries that I'm using?
09:34:35 <shapr> bye bringert!
09:34:43 <sorear> tcr: yes, disable -prof
09:34:57 <shapr> tcr: Debian has prof packages for some of the libs.
09:35:01 <sorear> tcr: profiling modules are not binary compatible with non-profiling modules
09:35:44 <sorear> for cabal packages installing profiling versions is as simple as -p for configre
09:36:31 <Saizan> aren't them installed bydefault?
09:36:45 <sorear> Sadly, no.
09:37:01 <tcr> Well, I'm using the ubuntu haskell-src-exts package, which doesn't come with that profiling stuff.
09:37:37 <tcr> Quite a lot of work just to get some backtrace, isn't it? :)
09:37:39 <Heffalump> I had to install hsql from cabal thanks to a similar problem with the Debian package.
09:37:42 <sorear> tcr: it would be in a separate package, like libghc6-mtl-dev / libghc6-mtl-prof
09:37:48 <Heffalump> you're expecting a backtrace out of this?
09:37:58 <tcr> Heffalump: So I was told.
09:38:15 <sorear> tcr: Fortunately it's all one time work.
09:38:52 <sorear> Once you have all the proflibs installed getting a backtrace is so easy that it is standard procedure.
09:39:30 <tcr> So how can I install haskell-src-exts with cabal?
09:47:14 <rad7> hi
09:47:31 <rad7> i've problem with lambdabot
09:47:33 <thoughtpolice> anybody know of an openbsd package for ghc 6.6.1? if not, anybody mind helping me with some build errors? :/
09:48:17 <rad7> i don't know howto configure any pligins in lambdabot.... do you have any howto, manual?
09:48:26 <rad7> plugins*
09:48:30 <SamB_XP_> configure plugins?
09:48:35 <dmwit> ?index StateT
09:48:36 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
09:48:37 <SamB_XP_> they have configuration?
09:56:10 <Heffalump> sorear: as in a backtrace of a single error?
10:16:39 <dmwit> Okay, I'm finally trying to convert from type RandomMonad a = State StdGen a to type RandomMonad a = StateT StdGen [] a.
10:16:46 <dmwit> But I'm stuck at the same position I was last time.
10:17:05 <dmwit> Namely, I want to write permute :: [a] -> RandomMonad a, and I just don't see how to do it.
10:17:24 <dmwit> (I.e. permute should pick a single random permutation of the list.)
10:18:44 <Heffalump> can you paste what you've tried so far?
10:18:47 <dmwit> So, the question is... any clues?
10:19:06 <dmwit> ?paste
10:19:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:19:07 <Heffalump> do you have an implementation that works for State StdGen a ?
10:19:20 <dmwit> Heffalump: Yes, but the semantics are wrong in that one.
10:19:26 <Heffalump> wrong how?
10:20:30 <dmwit> To evaluate the state, it must create the entire permutation.
10:20:53 <dmwit> I want to be able to run the state monad and grab the head of the list without evaluating the rest of the list.
10:21:12 <Heffalump> that doesn't sound possible
10:21:49 <hpaste>  dmwit pasted "Trying to write permute" at http://hpaste.org/1727
10:21:50 <Heffalump> at least, not if you want proper randomness
10:22:09 <dmwit> Heffalump: I don't need proper randomness.
10:22:42 <Heffalump> the thing is, you are forking StdGen across each element of the list
10:22:51 <dmwit> Exactly!
10:22:53 <dmwit> That's what I want.
10:23:20 <Heffalump> so doesn't that mean that each choice would come from the same underlying random number?
10:23:36 <hpaste>  dmwit annotated "Trying to write permute" with "withRange definition" at http://hpaste.org/1727#a1
10:23:49 <Heffalump> I guess you could manually thread it through the list you produce, so that the second element's state depends on the first element's, but not vice-versa.
10:24:17 <dmwit> Hmmm, wait.
10:24:33 <dmwit> I think I may have a think-o in here somewhere.
10:26:08 <dmwit> Oy, what I really need is way different and possibly easier.
10:26:21 <dmwit> But also more annoying. =P
10:26:43 <Heffalump> I think you were abusing the [] monad in your above signature, anyway.
10:27:07 <dmwit> Heffalump: Which signature?
10:27:11 <Heffalump> well, perhaps not. I guess non-determinism and randomness kind of go together
10:27:16 <Heffalump> the one for RandomMonad
10:27:52 <dmwit> Heffalump: Anyway, I'll be doing something non-monady as a solution, and thinking about how to make it actually a monad.
10:27:54 <dmwit> =(
10:28:01 <dmwit> This is harder than I thought it would be.
10:28:26 <Heffalump> can you specify what you want?
10:28:51 <dmwit> Yes, but I have to go; I'll ask again some other time.  Thanks for your help!
10:28:57 <monochrom> Have fun.
10:50:28 <cdsmith> If I write an infixr or infixl inside an instance declaration, what is the effect?  I can't find a clear answer in the report, but ghc allows it and it doesn't seem to do anything.
10:51:23 <Heffalump> I wouldn't have expected it to be allowed.
10:51:29 <Heffalump> They're not allowed in random scopes, are they?
10:51:33 <ddarius_> Does it affect the fixity within the instance declaration?
10:51:52 <cdsmith> Hmm, I'll check.  I was checking effect in code that used the instance.
10:52:14 <Igloo> They're allowed anywhere a variable declaration is allowed
10:52:23 <Igloo> And apply to the variable being declared
10:52:25 <Heffalump> oh, the report says they're allowed in class declarations
10:52:52 <Heffalump> and it also says they're not allowed in instance declarations
10:53:19 <Heffalump> (section 4.3.2, "The declarations may not contain any type signatures or fixity declarations, since these have already been given in the class declaration"
10:53:28 <cdsmith> Heffalump: Oh; I wonder why ghc allows it, then.
10:53:49 <cdsmith> ddarius_: no, no effect on precedence even for code in the instance decl.
10:53:50 <Heffalump> probably just a bug
10:54:10 <cdsmith> Heffalump: okay, cool.  One less thing for me to worry about, then.
11:06:51 <sorear> .
11:07:26 <DRMacIver> parse error on input `.'
11:07:49 <ndm> i see that xmonad has a wikipedia article already!
11:08:02 <sorear> yup, thank Gwern
11:08:14 <DRMacIver> Bet you people will be whining about notability within a week. :)
11:08:21 <ndm> and i spot that the screenshot has both dons paper, and hmp3 in it :-)
11:08:37 <sorear> ./2007-04-30.txt:01:03:42 <Gwern> ACTION may not be able to code haskell too well, but if there's one thing I can do it is write wikipedia articles
11:10:01 <Heffalump> DRMacIver: rightfully so, IMO :-)
11:10:21 <DRMacIver> Heffalump: No comment. :)
11:10:51 <Heffalump> well, actually, it's probably more notable than some of the crap on wikipedia
11:11:46 <DRMacIver> I've long suspected "Not notable" to be a wiki euphemism "Not about star wars, no matter how hard I try."
11:12:05 <sorear> Heffalump: agreed.
11:12:14 * ibid has decided to not do wikipedia stuff any more
11:12:26 <sorear> Heffalump: My parents refuse to believe that there even is a notability policy
11:12:37 <sorear> (they apparently don't read WP: pages)
11:12:43 <ddarius> There's a notability policy?
11:12:59 * DRMacIver has had at least two articles deleted on grounds of non-notability.
11:13:12 <DRMacIver> I mean, granted neither was exactly on a mainstream topic.
11:13:47 <Heffalump> as in you wrote the articles and they got deleted, or you caused them to be deleted?
11:13:56 <sorear> I just need to finish writing my distributed wiki engine, then they'll have no excuse to not cover everything :)
11:13:56 <DRMacIver> I wrote the articles and they got deleted.
11:14:14 <Heffalump> I think stuff like Xmonad fits better on some kind of specialised programming/software-related wiki.
11:14:29 <sorear> haskell is faster than php, right?
11:14:37 <DRMacIver> (Both on mildly unusual programming languages)
11:14:50 <DRMacIver> Heffalump: Sure. Know of one? :)
11:14:54 <Heffalump> deleting articles on programming languages sounds slightly more unreasonable
11:15:01 <Heffalump> DRMacIver: no :-)
11:15:16 <DRMacIver> These were at least slightly obscure programming languages it has to be admitted.
11:15:20 <ddarius> sorear: It damn well better be.
11:15:45 <DRMacIver> So it's not like there was no grounds for claiming non notability.
11:15:46 <sorear> DRMacIver: I think haskell.org/haskellwiki would be a good fit
11:15:50 <DRMacIver> sorear: True
11:16:01 <DRMacIver> sorear: But it would be nice to have something of a more in between scope.
11:16:59 <DRMacIver> Another pet irritation of mine with wiki's notability policy is that a while ago there were a lot of notability fanatics running around trying to get the entries deleted for all webcomics with less than a bajillion readers.
11:18:54 <cdsmith> > let { infixr 5 -=-; (-=-) = (-) } in 3 -=- 4 -=- 5
11:18:55 <lambdabot>  4
11:19:24 <cdsmith> I'm pretty sure the report doesn't allow that either. :)
11:19:43 <sorear> fixity is perfecly legal in let and where.
11:20:05 <sorear> indeed, allowing fixity in where is what makes haskell virtually impossible to parse
11:20:31 <sorear> honestly, I'm still not convinced haskell is context-sensitive
11:20:31 <ddarius> cdsmith: It doesn't make much sense to have fixity in an instance declaration.
11:20:32 <cdsmith> oh, well I have to go fix something then.
11:21:18 <cdsmith> sorear: so fixity in where clauses affects the code BEFORE them?
11:21:34 <ddarius> "Let's have the lexing depend on the types!"
11:21:56 <sorear> cdsmith: Yes!
11:22:15 <sorear> is haskell context sensitive?
11:22:58 <cdsmith> sorear: Luckily, I have the whole parse tree already, so that's really not a problem for me.
11:23:49 <cdsmith> sorear: in the sense of "does there exist a CFG that accepts precisely the legal Haskell programs", of course not.  No typed language is.
11:24:03 <cdsmith> Oh, never mind
11:24:10 <cdsmith> I thought you said "context free"
11:25:15 <sorear> Proving the haskell grammar turing complete sounds fun.
11:25:42 <monochrom> No, not turing complete.
11:26:28 <monochrom> If you add -fallow-undecidable-instances that's another story.
11:27:17 <ddarius> I'm pretty sure just parsing Haskell is context sensitive.
11:27:41 <ddarius> But I'd have to look up the definitions again to even start to be sure.
11:30:11 <monochrom> The moment you require "names you use must be declared somewhere" you leave CFG territory.
11:31:18 <sorear> The haskell grammar does not have that property.
11:31:44 <ddarius> monochrom: The question isn't whether Haskell leaves CFG territory.
11:32:31 <monochrom> I don't believe you.
11:32:47 <sorear> There is a terminating (exponential time) algorithm for parsing haskell without layout.
11:32:58 <sorear> I'm wondering if the same can be said for full Haskell.
11:33:44 <cdsmith> sorear: You mean that resolving layout may be undecidable?  That seems tough to believe.
11:33:59 <Heffalump> it might be double-exp
11:35:41 <sorear> I'm flexible.
11:36:02 <sorear> I'm wondering "not context sensitive" ...
11:37:02 <monochrom> OK, I believe you. I read too little.  (I'm context-free?)
11:37:26 <Heffalump> I don't see how it can be worse than double exp if Haskell without layout is exp.
11:39:22 <sorear> Heffalump: the layout rule is in P with an oracle for (\x -> is x a valid prefix of haskell-sans-layout)
11:39:34 <sorear> general prefix smells undecidable
11:58:17 <sorear> @seen kc5tja
11:58:18 <lambdabot> kc5tja is in #haskell. I last heard kc5tja speak 14h 11m 13s ago.
11:58:42 <sorear> kc5tja: ping?
12:00:28 <cdsmith> ?hoogle [k] -> a -> Data.Map k a -> Data.Map k a
12:00:29 <lambdabot> No matches, try a more general search
12:00:59 * beelsebob comes in hunt of LaTeX wizards again
12:01:23 <cdsmith> > map (flip (,) 5) [1, 2, 3, 4]
12:01:24 <lambdabot>  Couldn't match expected type `(a -> (a, b)) -> [t] -> a1'
12:01:40 <cdsmith> bleh
12:02:00 * beelsebob wonders why that doesn't type check
12:02:19 <ventonegro> :t (flip (,) 5)
12:02:21 <lambdabot> forall a b. (Num b) => a -> (a, b)
12:02:50 <ventonegro> :t map (flip (,) 5)
12:02:52 <lambdabot> forall a b. (Num b) => [a] -> [(a, b)]
12:03:08 <beelsebob> :t map (flip (,) 5) [1,2,3,4]
12:03:10 <lambdabot> forall a b. (Num b, Num a) => [(a, b)]
12:03:16 <cdsmith> huh
12:03:17 <beelsebob> okay... so what's wrong then?
12:03:19 <ventonegro> o.O
12:03:28 <beelsebob> > map (flip (,) 5) [1,2,3,4]
12:03:30 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:03:32 <beelsebob> o.O
12:03:33 <beelsebob> O.o
12:03:47 <beelsebob> is there a mistype?
12:03:54 <cdsmith> Maybe it likes you better than me.
12:03:54 <beelsebob> > map (flip (,) 5) [1, 2, 3, 4]
12:03:56 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:03:59 <beelsebob> wtf
12:04:04 <beelsebob> that's copied and pasted from earlier
12:04:16 <beelsebob> when it rejected you
12:04:19 <sorear> > map (flip (,) 5) [1, 2, 3, 4]
12:04:21 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:04:22 <sorear> > map (flip (,) 5) [1, 2, 3, 4]
12:04:24 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:04:25 <sorear> > map (flip (,) 5) [1, 2, 3, 4]
12:04:26 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:04:28 <sorear> > map (flip (,) 5) [1, 2, 3, 4]
12:04:28 <beelsebob> crazy
12:04:29 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:04:31 <sorear> > map (flip (,) 5) [1, 2, 3, 4]
12:04:33 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:04:36 <sorear> dons!!
12:04:41 <Korollary> There must be a conspiracy
12:04:41 <beelsebob> completely unduplicatable and crazy
12:04:47 <cdsmith> That settles it, then.  After all I've done for it, lambdabot hates me.
12:04:52 <beelsebob> cdsmith: try again, see if it doesn't like you?
12:04:52 <jfredett> lol
12:05:05 <kc5tja> sorear: Good morning.  Good sleep.  But, I need to haul my sorry butt over to Trader Joe's before the sun peaks, so I can do some solar cooking in time.
12:05:05 <cdsmith> > map (flip (,) 5) [1, 2, 3, 4]
12:05:07 <lambdabot>  [(1,5),(2,5),(3,5),(4,5)]
12:05:12 <kc5tja> I'll probably be back within an hour.
12:05:14 <Korollary> The error message was strange anyways.
12:05:15 <beelsebob> >.<
12:05:19 <beelsebob> indeed
12:05:44 <sorear> kc5tja: how quickly can you tell me how to build k2?
12:05:58 <sorear> cmake . && make  succeeds (exit 0) and does nothing
12:06:06 <sorear> I have lib65816 installed
12:06:13 <beelsebob> can any of you tell me how to have two theorem environments in LaTeX that both use the same counter
12:06:27 <cdsmith> ?hoogle [(a, b)] -> Data.Map a b -> Data.Map a b
12:06:27 <lambdabot> No matches, try a more general search
12:06:29 <beelsebob> thus producing something like Proof 1, Lemma 2, Proof 3, Proof 4, Lemma 5
12:06:59 <sorear> @typ M.union . M.fromList
12:07:01 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a -> M.Map k a
12:07:05 <sorear> cdsmith: ?
12:07:07 <beelsebob> cdsmith: \x y -> fromList x (some operation) y
12:07:13 <beelsebob> sorear: great minds
12:07:14 <cdsmith> sorear: thamls
12:07:28 <cdsmith> bleh again
12:07:34 <cdsmith> thanks, is what I meant.
12:07:35 <Heffalump> sorear: can't you just consider the rest of the actual program you have, for the general prefix thing?
12:08:50 <sorear> Note 5. The side condition parse-error(t) is to be interpreted as follows: if the tokens generated so far by L together with the next token t represent an invalid prefix of the Haskell grammar, and the tokens generated so far by L followed by the token "}" represent a valid prefix of the Haskell grammar, then parse-error(t) is true.
12:09:02 <kc5tja> sorear: Don't -- I couldn't get cmake to work with it at all on my new Linux installation (I'm not sure why).  darcs pull the latest patches, and just use make.
12:09:23 <sorear> hmm, didn't see a makefile, pulled today
12:09:32 * sorear looks again
12:09:48 <kc5tja> I just tried pulling it before posting it, to see if I was giving bad advice.  It works for me.
12:10:09 <sorear> kc5tja: No makefile in the repo.
12:10:09 <kc5tja> You can try doing another darcs get on it too.
12:10:20 <kc5tja> darcs get http://www.falvotech.com/content/kestrel/2/emulator/repo
12:10:22 <lambdabot> Title: Index of /content/kestrel/2/emulator/repo
12:10:25 <sorear> ah, new patches
12:10:42 <sorear> I was so sure I got it <10m ago ...
12:11:03 <kc5tja> I uploaded the new patches some time yesterday or the day before.
12:11:24 <kc5tja> Not sure why it didn't report having patches.  :/
12:11:35 <kc5tja> Anyway, I gotta cruise, or dinner won't be done.
12:11:38 <kc5tja> bbiab.
12:11:38 <sorear> bye
12:14:12 <cdsmith> Let's play "clean up the ugliest line of code Chris has written in his life!"
12:14:13 <cdsmith> pd' = ((M.union . M.fromList) (map (flip (,) prec) nms)) pd
12:14:19 <Heffalump> sorear: fair enough. Though I don't think that's undecidable.
12:15:27 <Heffalump> though dealing with fixities to decide whether a valid parse might exist could prove tricky
12:16:07 <Saizan> cdsmith: do you miss a (.) ?
12:17:00 <cdsmith> Saizan: Don't think so.  The code works.  I just wouldn't be able to understand it if I hadn't just written it cooperatively with two other people on IRC.
12:17:33 <Saizan> ah ok, now i see
12:17:40 * Heffalump suddenly realises that swap = uncurry $ flip (,)
12:17:50 <Japsu> :o
12:18:10 <Heffalump> (it always pissed me off to have to write it out when I need it :-)
12:18:21 <hpaste>  dfranke pasted "Existentially quantified named fields" at http://hpaste.org/1728
12:18:25 <dfranke> ^^^ help
12:18:52 <Saizan> pd = M.union pd . M.fromList . map (flip (,) prec) $ nms
12:19:11 <Saizan> (is union commutative?)
12:19:17 <ddarius> > (length "uncurry $ flip (,)",length "\\(x,y) -> (y,x)")
12:19:18 <lambdabot>  (18,15)
12:19:30 <vegai> Heffalump: swap (a,b)=(b,a) pisses you off?
12:19:32 <Heffalump> dfranke: use a data type
12:19:38 <Heffalump> vegai: yes :-)
12:19:41 <vegai> whoa :)
12:19:46 <Heffalump> the lambda expression is a fairer comparison.
12:19:56 <Heffalump> but I find it really ugly :-)
12:20:05 <Heffalump> it only pisses me off slightly ;-)
12:20:16 <dfranke> Heffalump, as in a type synonym?
12:20:27 <Heffalump> dfranke: no, as in wrap it in a data declaration
12:20:31 <cdsmith> Saizan: that seems to work, and is definitely nicer.  Thanks much.
12:20:45 <Heffalump> tcr had a similar problem yesterday and that was the only fix I could figure out
12:20:52 <dfranke> Heffalump, I don't understand.  Example please?
12:20:54 <ddarius> Haskell trivia of the day:  For f xs@(x:??) = ... what is the "customary" name for the ?? ?
12:20:56 <Heffalump> although I never quite figured out what the type checker was doing there
12:21:17 <Baughn> ddarius: xs
12:21:28 <ddarius> Baughn: Look closer.
12:21:30 <Heffalump> data LockC m = LockC (forall lockc . LockClient lockc m => lockc)
12:21:39 <Korollary> ddarius: I use rest sometimes
12:21:47 <Baughn> ddarius: rest, then
12:21:59 <Heffalump> ddarius: I wouldn't name xs that way if I wanted to name the tail too, probably.
12:22:17 <dfranke> Heffalump, oh I see.  That could work.
12:22:18 <Heffalump> data LockC m = LockC { unLockC :: forall lockc . LockClient lockc m => lockc }
12:22:19 <dfranke> thanks.
12:22:28 <Heffalump> (actually, the second one is nicer for untagging purposes)
12:22:29 <twanvl> I use xxs@(x:xs)
12:23:02 <dfranke> I just drop the outside and re-cons if I need the whole thing.
12:23:12 <ddarius> That's what I usually do (use rest), but according to this paper "According to custom, sequence variables are suffixed with s.  When both a sequence and its tail are named, the latter is given suffix t."
12:23:28 <Heffalump> hmmm.
12:23:32 <dfranke> meaning xs@(x:xt)?
12:23:34 <Heffalump> not a custom I've run into :-)
12:23:37 <ddarius> Yes
12:23:41 <ddarius> Heffalump: Indeed.
12:23:42 <Heffalump> but I guess it makes sense
12:23:46 <Heffalump> I might use it now :-)
12:23:55 <earthy> I won't. :)
12:23:57 <Korollary> they love these cryptic variable names
12:24:13 <ddarius> This is circa 2003, so not that long ago.
12:25:06 <Heffalump> hi njbartlett, did you get anywhere with that runtime configurations stuff?
12:25:41 <njbartlett> Hi Heffalump. No, had to take my kids to the park :-)
12:25:47 <njbartlett> Will look at it again tonight
12:27:15 <sorear> Testing X - anyone have a >255 character for me?
12:27:46 <TomMD> > (toEnum 256) :: Char
12:27:55 <lambdabot>  '\256'
12:27:55 <ibid> 
12:28:23 <sorear> ibid: Yum, a BOX!  beats Linux's question mark I suppose :)
12:28:28 <Heffalump> > putStrLn "\256"
12:28:30 <lambdabot>  <IO ()>
12:28:52 <Heffalump> > "\256"
12:28:54 <lambdabot>  "\256"
12:28:57 <Heffalump> bah.
12:29:11 <ventonegro> > show (toEnum 256)
12:29:13 <lambdabot>  "256"
12:29:59 <Heffalump> show would wrap it in more quotes, not fewer
12:30:10 <ibid> sorear: your font is lacking :)
12:30:29 <ibid> sorear: or else one of us has broken utf-8 support in our clients
12:30:31 <ddarius> Of course this paper also has: "The expression [0,2..] \/ [1,3..] == [1..] though true, involves infinitely many comparisons; its evalution will not terminate." Where \/ is the (set) merge function.
12:30:41 <sorear> ibid: Emacs says that was 300000-something, well beyond the BMP
12:30:55 <ibid> sorear: it was supposed to be small lambda
12:31:04 <ibid> sorear: i copypasted it direct from an xterm
12:31:08 <sorear> *grumble*
12:31:11 <Heffalump> ddarius: a merge function that assumes sorted inputs?
12:31:15 <ibid> sorear: and it shows right to me here
12:31:19 <ventonegro> it appears here as a lambda
12:31:29 <Baughn> Heffalump: Still wouldn't terminate.
12:31:38 <Heffalump> Baughn: sure, was just wondering
12:31:53 <ddarius> Heffalump: Yes.
12:32:04 <Heffalump> oh. It's not true. Duh :-)
12:32:16 <Baughn> On that note, I wonder if union functions usually sort the input, or if they do something more interesting
12:32:20 <ddarius> Baughn: It does terminate.  Quite quickly.
12:32:35 <ibid> sorear: i've noticed that emacs sometimes does weird stuff with copypasted unicode
12:32:38 <Heffalump> Baughn: union functions on what?
12:32:50 <Baughn> Heffalump: Eq a >= a
12:33:15 <ibid> Baughn: i believe they generally assume the input is sorted
12:33:24 <ddarius> Baughn: Well if they are only in Eq, then they can't sort the input.
12:33:24 <Baughn> Heffalump: ..okay, maybe Ord a
12:33:28 <ibid> (and produce sorted output if so)
12:33:39 <Heffalump> DYM Ord a => [a] ?
12:33:41 <ddarius> The "set" operations in Data.List work that wa.
12:34:18 <Baughn> Let's just say integers. For two /unsorted/ sets of integers, is there a better way to merge them than sorting them first?
12:35:23 <ddarius> Yes.  You can sort them as you merge.  But if you don't care about having the sorted afterwards you could do other things.
12:36:04 <ibid> Baughn: it really depends on what invariants you want to impose on the data
12:36:16 <Heffalump> Baughn: what representation of "set"?
12:36:22 <ibid> Baughn: for example, if you don't care about order or number, you can just concatenate
12:36:45 <Heffalump> it just depends what operations you want to be cheap
12:36:45 <ibid> Baughn: but if you care about having at most one representative of each element, you need to be more careful
12:36:49 <Baughn> The sets should not contain any duplicates. Otherwise, no restrictions
12:37:33 <Baughn> ..yeah, I don't suppose there's any universal solution. I'll just have to wait for a problem that fits. ;)
12:38:06 <ddarius> Well, if you could shove them into a hash table you could do it in O(n1+n2) time.
12:39:28 <Heffalump> are hash tables really O(n)?
12:39:52 <Heffalump> or is it just in the same sense that (+) is O(1)?
12:40:00 <ddarius> I'm considering the hash tables to essentially be O(1) heer.
12:40:14 <Heffalump> yes, sorry, O(1) was my question
12:40:28 <ddarius> But with collisions, technically they aren't.
12:40:36 <Baughn> They can be. Implementing one in hash table could be interesting..
12:40:40 <Heffalump> well, collisions or increasing the key size
12:40:41 <Baughn> Er, in haskell
12:40:47 <Heffalump> Haskell has hash tables
12:40:51 <Heffalump> just in IO (or perhaps ST too?)
12:41:05 <ddarius> I think it's just IO for no good reason.
12:41:09 <Heffalump> with a pure type you might as well just use a tree
12:41:28 <Heffalump> oh, I guess a DiffArray might be ok
12:41:33 <Baughn> In ST should be fine, but for the impossibility of implementing one
12:41:39 <ehird`> hash table lookup O(n) where n is the amount of duplicates in the hash
12:41:44 <ehird`> normally, 1
12:41:46 <Heffalump> why would it be impossible? You've got STArray
12:41:49 <ddarius> With a balanced binary search tree you would get O(n1+n2logn1)
12:42:10 <Heffalump> ddarius log (max (n1, n2)) surely?
12:42:20 <ddarius> ehird`: We drop dups so that's not a problem, collisions are though.
12:42:51 <ddarius> Heffalump: Sure, if you want to do it the easy way.
12:42:59 <Heffalump> what's the hard way?
12:43:50 <ddarius> The algorithm I had in mind for the hash table was stick the first list in it as we traverse it to append, and filter the second list with it as we append it.
12:44:10 <ddarius> I was just dropping a binary search tree into the place of hash table there.
12:44:10 <Cheery> What infix my function should have, it combines two functions into a signal transformer (which is an arrow)
12:44:15 <Cheery> ?
12:44:30 <ddarius> Cheery: Fixity or operator?
12:44:35 <hpaste>  assl0r pasted "whats wrong?" at http://hpaste.org/1729
12:44:42 <Heffalump> ddarius: but as it gets bigger, the log factor will follow the size of the combined thing
12:44:43 <Baughn> Heffalump: You're right. I see it's implemented with Magic(tm), but that's okay.. I'll just have to write a hash-table, then.
12:45:20 <Cheery> ddarius: f -& g = SF { evalSF = f &&& g }
12:45:23 <Heffalump> Baughn: I suggest just fixing the existing one in the stdlibs
12:45:29 <ddarius> Heffalump: As it gets bigger?  The elements of the second list are only compared against it not added to it.
12:45:32 <Heffalump> though it might be it has that type cos they didn't want to use an MPTC
12:45:52 <assl0r> may somebody take a look please? http://hpaste.org/1729
12:45:53 * Heffalump reads ddarius's explanation again
12:46:15 <ddarius> Heffalump: We already have the assumption that each list is individually dup free.
12:46:26 <Heffalump> I don't quite follow your algorith, I think.
12:46:29 <Cheery> ddarius: what's the difference between fixity and operator?
12:46:53 <Heffalump> oh, I see, sorry
12:46:55 <ddarius> Cheery: fixity is what precedence it has and associativity, operator is what symbol you should use for it.
12:46:56 <Heffalump> yep, ok.
12:47:02 <dmwit> > (,1) 0
12:47:03 <lambdabot>  Parse error
12:47:19 <dmwit> > (,) 0 1
12:47:21 <Heffalump> @type (,)
12:47:22 <lambdabot>  (0,1)
12:47:23 <lambdabot> forall a b. a -> b -> (a, b)
12:47:24 <Heffalump> @type (,,)
12:47:27 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
12:47:35 <Heffalump> it's a shame that operator can't be sectioned.
12:47:46 <dmwit> yeah
12:47:55 <Cheery> ddarius: I put infixr 3 for it
12:48:10 <Cheery> that seems most correct, since I compose it from (&&&) anyways
12:49:44 <ddarius> Cheery: I'd match &&&'s fixity and further I'd probably choose a more symmetric operator unless it isn't as symmetric as it seems.
12:51:59 <hpaste>  dmwit pasted "Creating a new StateT "primitive" -- is there a cleaner way?" at http://hpaste.org/1730
12:52:14 <dmwit> Here's installment two of the question I had earlier today.
12:52:28 <Heffalump> dmwit: I'm busy right now, but I'll take a look later if noone else helps
12:52:38 <dmwit> Heffalump: Okay, thanks.
12:53:05 <dmwit> everyone else: I'm just wondering if manually threading state this way is reasonable.
12:53:11 <Korollary> Wow. ghc: "...In the scrutinee of a case expression:". Never seen that before.
12:53:14 <dmwit> It's only in one function that I have to do it, so it isn't too painful.
12:53:21 <dmwit> I'm just curious.
12:55:40 <araujo> hi hi!
12:56:02 <Heffalump> dmwit: my suspicion is that you'll have to do it manually, given that you're changing the way that monad "ought" to work (which is to fork the state)
12:56:15 <dmwit> Right.
12:56:33 <dmwit> Okay, that's probably fair.
12:57:30 <sorear> hello araujo
12:57:42 <araujo> sorear, hola!
13:01:03 <Cheery> ddarius: ok
13:02:26 <cdsmith> @unpl (+)
13:02:26 <lambdabot> (+)
13:05:22 <ddarius> cdsmith: I believe unpl just expands the combinators that pl compiles to.
13:06:11 <sorear> It also does limited beta reduction.
13:06:54 <cdsmith> ddarius: I was just making sure *I* didn't break that with my local changes.
13:07:13 <ddarius> sorear: Clearly, otherwise the output would be horrible.
13:10:00 <Cheery> @pl aux (tf, (tg, c)) = (\dt -> tf dt >>> tg dt, c)
13:10:01 <lambdabot> aux = uncurry ((`ap` snd) . (. fst) . ((,) .) . liftM2 (>>>))
13:10:13 <Cheery> @unpl aux (tf, (tg, c)) = (\dt -> tf dt >>> tg dt, c)
13:10:13 <lambdabot> aux (tf, (tg, c)) = (\ dt -> (tf dt) >>> (tg dt), c)
13:12:55 <Cheery> @unpl aux = uncurry ((`ap` snd) . (. fst) . ((,) .) . liftM2 (>>>))
13:12:56 <lambdabot> aux = uncurry (\ k -> (\ t -> ((,)) (k >>= \ e -> (fst t) >>= \ d -> return (e >>> d))) >>= \ y -> snd >>= \ x -> return (y x))
13:15:25 <Cheery> @hoogle (a -> b -> c) -> (a, (b, d)) -> (c, d)
13:15:26 <lambdabot> No matches, try a more general search
13:15:47 <Cheery> @genie (a -> b -> c) -> (a, (b, d)) -> (c, d)
13:15:48 <lambdabot> Unknown command, try @list
13:16:05 <Cheery> @djinn (a -> b -> c) -> (a, (b, d)) -> (c, d)
13:16:06 <lambdabot> f a (b, (c, d)) = (a b c, d)
13:16:27 <Cheery> but what would be good name for this kind of thing?
13:16:56 <Cheery> it corresponds to making a somewhat this kind of trick for list:
13:17:43 <Cheery> fun f (x:xs:xss) = f x xs:xss
13:17:47 <ddarius> @. pl djinn (a->b->c) -> (a,(b,d)) -> (c,d)
13:17:48 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . (((.) . ((,) .)) .)
13:17:55 <ddarius> Maybe not.
13:18:33 <Cheery> ddarius: what do you think?
13:19:00 <Cheery> @pl fun f (x:xs:xss) = f x xs:xss
13:19:00 <lambdabot> fun = (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . ((:) .)) .)
13:19:06 <Cheery> :D
13:19:36 <nominolo> Hm, what are hidden packages in GHC?
13:23:35 <Heffalump> evening
13:24:17 <dmwit> nominolo: Not sure, but I assume you know about ghc-pkg list?
13:26:16 <sorear> nominolo: Hidden packages are packages that, while perfectly good, are not depended on by the current program.
13:26:59 <sorear> nominolo: in order to completely and permanently solve the scourge of undeclared dependencies, GHC prevents you from using modules in hidden packages.
13:27:30 <ddarius> :t \f -> uncurry f *** id
13:27:39 <lambdabot> forall a b c a1. (a -> b -> c) -> ((a, b), a1) -> (c, a1)
13:27:42 <Heffalump> "completely and permanently"? Bit optimistic there :-)
13:27:48 <sorear> :t uncurry ?f *** id
13:27:50 <lambdabot> forall a b c a1. (?f::a -> b -> c) => ((a, b), a1) -> (c, a1)
13:30:46 <sorear> kc5tja: back yet?
13:37:57 <Baughn> Is there some obvious reason why do file <- readFile "md5sums"; return $ filter ((> 1) . length) $ List.group $ List.sort $ map words $ lines file should take 1.2 GB of memory just to handle a 28MB file?
13:38:52 <Laney> If I have a list, how can I get all possible combinations of its elements (an infinite list)? --- i.e. combs [1, 2] = [], [1], [1, 1], [1, 1, 1], ... [1, 2, ...]. Is this even possible?
13:39:39 <dmwit> Baughn: No, but there are some suggestions I could make...
13:39:44 <ddarius> Baughn: 1.2 GB of resident?  (Also, not . null . tail is more efficient than (>1) . length
13:39:55 <dmwit> ((> 1) . length) === not . null . tail
13:40:01 <dmwit> Whoops, too late. =)
13:40:06 <Baughn> ddarius: 1.7GB and into swap now. Well, I'll try /compiling/ it first.
13:40:11 <augustss> Baughn: 1.2G sounds too much.  300M sounds moe likey
13:40:43 <dmwit> Laney: Yes, it's possible.
13:41:01 <dmwit> But the order you suggest is just a bit whacky...
13:41:19 <dmwit> You could simulate that order with "combs = cycle . head"
13:41:19 <Laney> dmwit: The order doesn't matter
13:41:19 <ddarius> Baughn: You are looking at about a 12:1 ratio for the memory taken up by the String containing the whole file.
13:41:28 <dmwit> (i.e. it never gets to mixing elements)
13:42:08 <ddarius> Laney: It kind of does if you ever want to get, [2,1]
13:42:13 <dmwit> Oh, actually ((> 1) . length) /== not . null . tail for length-0 lists.
13:42:17 <nominolo> sorear: hm, I get this error message when compiling pandoc: src/Text/Pandoc/HtmlEntities.hs:10:7:
13:42:17 <nominolo>     Could not find module `Text.Regex':
13:42:17 <nominolo>       it is a member of package regex-compat-0.71, which is hidden
13:42:26 <Laney> I mean it doesn't matter to me the order in which elements are generated
13:42:29 <ddarius> dmwit: group never produces empty lists
13:42:33 <Baughn> ddarius: I'll try some optimizations. If I sort the file on disk (removing the sort call) it won't need to read in the whole file before it starts working, right?
13:42:33 <sorear> nominolo: Obviously pandoc is very old.
13:42:45 <nominolo> possible
13:42:51 <sorear> nominolo: regex-compat was split out of base 6.4->6.6
13:43:00 <sorear> so you'll need to edit the cabal file.
13:43:06 <nominolo> I guess I should at it to the dependencies in the .cabal?
13:43:11 <nominolo> heh
13:43:13 <int-e> dmwit: even with empty lists, you can use  drop 1  instead of  tail
13:43:20 <dmwit> yeay
13:43:23 <dmwit> *yeah
13:44:24 <nominolo> oh, cool. that was simple
13:44:41 <nominolo> @karma++ ghc-error-messages
13:44:41 <lambdabot> ghc-error-messages's karma raised to 1.
13:44:56 <dmwit> > let prepend xs x = map (x:) xs in [1, 2] >>= prepend [[1, 2]]
13:44:57 <lambdabot>  [[1,1,2],[2,1,2]]
13:46:29 <dmwit> > let combs xs = [[]] : xs >>= prepend (combs xs); prepend xs x = map (x:) xs in combs [1,2]
13:46:30 <lambdabot>   add an instance declaration for (Num [[a]])
13:46:31 <lambdabot>     In the expression: 2
13:46:49 <dmwit> What did I do that requires Num there??
13:46:58 <dmwit> > let combs xs = [[]] : (xs >>= prepend (combs xs)); prepend xs x = map (x:) xs in combs [1,2]
13:46:59 <lambdabot>   add an instance declaration for (Num [a])
13:46:59 <lambdabot>     In the expression: 2
13:47:13 <Heffalump> you've got your level of lists messed up somewhere
13:47:21 <Heffalump> so it's trying to unify [a] with a numeric literal
13:47:28 <Heffalump> (I can't see exactly where, but that's what that error message really means)
13:47:37 <dmwit> Oh, okay, I can work with that.
13:47:43 <ddarius> xs is expected to be a list of lists
13:47:47 <dolio> > let prepend xs x = map (x:) xs in [1, 2] >>= prepend [1, 2]
13:47:48 <lambdabot>   add an instance declaration for (Num [t])
13:47:48 <lambdabot>     In the expression: 2
13:47:51 <Heffalump> oh, x = map (x:) xs
13:47:54 <kc5tja> sorear: Kind of.  I need to get a new tube for my rear tire though.  >:(
13:47:58 <Heffalump> oh, sorry, that was linewrapping confusing me
13:48:14 <kc5tja> sorear: Thinking of just having the bike shop change the tube for me, since I really don't feel like getting all dirty myself.
13:48:22 <ddarius> er nevermind... maybe
13:48:30 <monochrom> :t \xs -> map (True:) xs
13:48:33 <lambdabot> [[Bool]] -> [[Bool]]
13:48:45 <monochrom> It does force xs to be [[...]]
13:49:06 <dmwit> No, it forces (combs xs) to be [[...]].
13:49:08 <dmwit> Which is fine.
13:49:24 <dmwit> Oh, I see.
13:49:27 <dmwit> Hmmm.
13:49:43 <monochrom> You are right.
13:49:57 <Baughn> ddarius: The sort call is the culprit; it appears to be seriously inefficient.
13:50:38 <dmwit> :t \x -> map (x:) xs
13:50:41 <lambdabot> Not in scope: `xs'
13:50:49 <dmwit> :t \x -> map (x:) (xs :: [[Int]])
13:50:52 <lambdabot> Not in scope: `xs'
13:51:03 <dmwit> :t \x -> map (x:) [[1, 2]]
13:51:05 <lambdabot> forall a. (Num a) => a -> [[a]]
13:51:18 <ddarius> Baughn: Well it's certainly not in-place.  It probably uses 2n cons cells.
13:52:15 <dmwit> Oh, (>>=) is the problem.
13:52:56 <dmwit> > let combs xs = [[]] : map (prepend (combs xs)) xs; prepend xs x = map (x:) xs in combs [1,2]
13:52:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:52:58 <lambdabot>       Expected...
13:53:05 <Baughn> ddarius: This time, it would be an advantage to copy first and then sort in-place. I wonder how often that is..
13:53:40 <dmwit> :t \xs x -> map (x:) xs
13:53:42 <ddarius> I have a quicksort implementation that presents a pure or impure interface to an inplace quicksort.
13:53:43 <lambdabot> forall a. [[a]] -> a -> [[a]]
13:54:13 <Baughn> ddarius: Sorting [String] is bad enough, but [[String]] (after words) never finished. Crashed, in fact. (OOM killer)
13:54:15 <ddarius> But it's (obviously) for arrays.
13:54:42 <ddarius> [String] is an extremely inefficient representation.
13:54:42 <sorear> kc5tja: The emulator starts prints Ok and echoes my keypresses, but 2 2 + . does nothing (not even Ok)
13:54:45 <dmwit> Hmmm...
13:55:31 <ddarius> http://www.haskell.org/haskellwiki/Introduction/Direct_Translation
13:55:34 <lambdabot> Title: Introduction/Direct Translation - HaskellWiki, http://tinyurl.com/ytokyh
13:56:17 <augustss> Baughn: why do you sort after words?
13:56:38 <nominolo> hm, any idea why ghc ... -package Cabal might not work?
13:58:15 <matthew-_> ahh, I love haskell so much. It's so warm and cuddly.
13:58:31 <ddarius> If only.
13:58:32 <Heffalump> except for the profiling. That's not.
13:58:38 <matthew-_> Heffalump: agreed.
13:58:39 <Baughn> augustss: Good question. Sorting before worked just as well.
13:58:47 <dmwit> > let preps xs ys = map (:ys) xs; combs xs = [[]] : map (preps xs) (combs xs) in combs [1,2]
13:58:49 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:58:49 <lambdabot>       Expected...
13:59:07 <Baughn> augustss: Though in the end I used /usr/bin/sort
13:59:13 * Heffalump is still bitter about the profiler continually attributing loads of time to the top level of a declaration despite me sprinkling SCC annotations all over the inside
13:59:19 <monochrom> yyy = [[]] : (xs >>= \x -> map (x:) yyy).  From yyy = [[]] : blah, get yyy :: [[[y]]].  From map (x:) yyy, get x :: [[y]].  From xs >>= \x -> blah, get xs :: [[[y]]].  xs cannot look like [1,2].
13:59:38 <dmwit> > let preps xs ys = map (:ys) xs; combs xs = [[]] ++ map (preps xs) (combs xs) in combs [1,2]
13:59:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:59:39 <lambdabot>       Expected...
14:00:05 <matthew-_> Heffalump: yeah, I find -ddump-simpl's probably more use for tracking down why stuff's slow
14:00:26 <sorear> Baughn: bravo!  it takes rare wisdom to delegate work like that
14:00:49 <Heffalump> I just want to know what's slow. I can imagine several things that would be, I just want to know what to focus on.
14:00:53 <sorear> although gnu sort is pretty slow :(
14:01:16 <njbartlett> Heffalump: Still haven't figured out that fixed precision number stuff... but noticed that Rational does what I need and is a lot easier for me to understand :-S
14:01:23 <Heffalump> njbartlett: :-)
14:01:34 <Heffalump> I'm not sure if the polymorphic recursion trick would have worked, but I think it would have.
14:01:56 <Heffalump> you should just tempt augustss into trying it instead ;-)
14:02:05 <Baughn> sorear: I have now replaced a two-line haskell program with a one-line sed-awk-sort-sed-sort-less monster.
14:02:06 <njbartlett> I'll ask him at the HUG
14:02:21 <augustss> njbartlett: what was it you wanted?
14:02:35 <Heffalump> he wants to be able to pick the precision of his fixed-point numbers based on a runtime value
14:02:44 <njbartlett> Oh hi, didn't know you were online
14:03:00 <ddarius> Polymorphic recursion? Where?
14:03:02 <augustss> like the fixed precision I had in my blog?
14:03:04 <njbartlett> Yeah, got some serialized data from an external source which has a precision value encoded into it
14:03:19 <Heffalump> ddarius: to pick a type class instance
14:03:23 <augustss> you can do that.  it just needs some oleging
14:03:25 <njbartlett> Trying to use the Data.Number.Fixed stuff that you blogged about, but obviously don't know the precision at compile time.
14:03:29 <Heffalump> the runtime configurations paper at the HW from a few years back
14:03:36 <kc5tja> sorear: Right.  That's because the Forth environment isn't finished.
14:03:46 <sorear> kc5tja: *sigh of relief*
14:03:51 <matthew-_> today, I've managed to implement stuff in Haskell that I initially thought I could only do in Epigram. Using instantiation of classes to represent type level computations is /so/ powerful...
14:04:18 <ddarius> matthew-_: Indeed...
14:04:35 <augustss> I thought I'd blog about how to have a runtime precision, but my macbook is still dead :(
14:04:52 <Heffalump> you can't write Haskell without it
14:04:53 <ddarius> But soon we will feel cramped in our Turing-complete boxes...
14:04:53 <Heffalump> ?
14:04:55 <dmwit> Ah, finally!
14:04:59 <njbartlett> Oh dear. I keep hearing that about MacBooks. I hope mine doesn't go the same way!
14:05:17 <kc5tja> The input functionality of the machine is also very, very rough.
14:05:19 <dmwit> > let preds xs ys = map (:ys) xs; combs xs = [[]] ++ (combs xs >>= preps xs) in combs [1, 2]
14:05:20 <Heffalump> get a nice PC instead. Much better all round ;-)
14:05:20 <lambdabot>   Not in scope: `preps'
14:05:25 <dmwit> > let preds xs ys = map (:ys) xs; combs xs = [[]] ++ (combs xs >>= preds xs) in combs [1, 2]
14:05:27 <lambdabot>  [[],[1],[2],[1,1],[2,1],[1,2],[2,2],[1,1,1],[2,1,1],[1,2,1],[2,2,1],[1,1,2],...
14:05:30 <njbartlett> Heffalump: I'm trying to read that paper, but it;s slow going. I'm still a bit new at this stuff!
14:05:35 * kc5tja was thinking of writing a Forth cross-compiler so that I can rewrite the firmware in Forth, but I'm having second thoughts now.
14:05:45 * kc5tja is thinking it'll be faster if I just complete it as an assembly language program.
14:05:47 <Laney> dmwit: You hero!
14:05:48 <augustss> Heffalump: it's just not comfortable to code staring at my TV as a monitor
14:06:07 <dmwit> But that's probably a fairly unreadable way to do it.
14:06:14 <Heffalump> augustss: ah, you only have a laptop?
14:06:25 <Heffalump> IM for a screen.
14:06:49 <augustss> Heffalump: a laptop and "media pc".  and 3 desktop computers in sweden
14:06:54 <augustss> umm, 4
14:07:18 <njbartlett> Well, flights are cheap these days...
14:07:40 <Heffalump> perhaps you should commute from Sweden every week :-)
14:08:00 <augustss> I just got back
14:08:45 <augustss> i might write a blog entry tomorrow anywway.  we'll see
14:09:21 <njbartlett> I'll look forward to that
14:10:54 <augustss> but i also have interval arithmetic and real numbers to write about
14:11:30 <njbartlett> Well you have to go where your muse takes you, of course. But I really hope you write about my problem first :-)
14:13:03 <augustss> and lots of other kinds.  like affine arithmetic...  there is no end
14:13:11 <ddarius> "There's a definite sense of rightness when you've done it right.  It may be that feeling distinguishes Forth from other languages, where you never feel you've really done well."
14:13:23 <ddarius> Mmm, affine arithmetic.
14:15:02 <Heffalump> the basic point of the runtime configurations trick is that you construct a value that wraps up a specific typeclass instance, right?
14:15:42 <augustss> yes, but you might never need the value, just the instance
14:15:48 <Heffalump> yeah.
14:16:05 <Heffalump> but the value holds the dictionary (or whatever other implementation of instances there is)
14:16:30 <dmwit> > let combs xs = [0..] >>= flip replicateM xs in combs [1,2,3]
14:16:38 <lambdabot>  [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3],[1,1,1...
14:16:59 <dmwit> Laney: That's much nicer, and quite a bit more readable in my opinion. =)
14:17:26 <matthew-_> this is the stuff on data Foo r = Foo forall a. a (a -> r) stuff ? GHC manual section on existentials?
14:19:11 <kc5tja> brb -- errands to run.
14:19:11 <augustss> Heffalump: the most common implementation is to have the instance separate from the value.   since in general you might  not have a value (r.g., fromInteger)
14:20:37 <ddarius> @pl comb xs = fromEnum 0 >>= flip replicateM xs
14:20:37 <lambdabot> comb = (fromEnum 0 >>=) . flip replicateM
14:21:10 <augustss> nice!
14:22:08 * dmwit prefers [0..] to fromEnum 0
14:22:31 <matthew-_> oh yeah, is there a type class for finite enums?
14:22:33 <ddarius> I wasn't completely sure pl handled it.  I think it does, but I didn't want to mess around.
14:22:34 <Heffalump> augustss: I don't follow, but never mind.
14:22:42 <dmwit> matthew-_: Bounded
14:22:50 <matthew-_> dmwit: many thanks.
14:22:53 <ddarius> @pl comb xs = [0..] >>= flip replicateM xs
14:22:53 <lambdabot> comb = ([0..] >>=) . flip replicateM
14:26:29 <matthew-_> is it just me or are other PhD students here slightly nervous about posting code that'll form part of their PhD?
14:26:41 <Heffalump> ndm does it all the time
14:26:46 <njbartlett> Heffalump: this goes so far over my head, it's a danger to aviation
14:26:53 <njbartlett> ;-)
14:27:07 <monochrom> dons even cabalizes his PhD code :)
14:27:17 <Heffalump> and dcoutts, of course
14:28:08 <matthew-_> ok, well I'll stop worrying about that then...
14:28:30 <Heffalump> what would you be worried about? Losing publication priority?
14:28:48 <monochrom> To prevent other people stealing your stuff, you go to either of two extremes.  You hide it like crazy.  Or you make it public like crazy, the idea is that so many people knows it's yours that a potential stealer can't lay claim on your stuff.
14:29:09 <matthew-_> monochrom: yep.
14:29:42 <matthew-_> I'd still be worried that other people can take it to the "next step" faster than me...
14:29:57 <matthew-_> mmm. paranoia at this young age is worrying.
14:30:21 <njbartlett> Remember the Tom Lehrer song about Lobachevsky?
14:30:47 <njbartlett> "In one word the great Lobachevsky taught me the secret of success in mathematics"
14:30:53 <njbartlett> "Plagiarise!"
14:31:02 <matthew-_> lol.
14:31:12 <monochrom> There is an advantage of the latter over the former.  If you rush to make public early, then the guy who is secretly working on the same subject goes "damn, now I can't claim originality, even though I independently invented it, even though I'm actually earlier!"
14:31:41 <matthew-_> monochrom: yep, true. But what if you /know/ you're behind and are trying to catch up and overtake?!
14:31:53 <matthew-_> gah, I think academia's totally corrupt anyway.
14:32:01 <augustss> switch to something different
14:32:27 <monochrom> Yes, other people can be inspired by your stuff made public.  Then they can only claim "building on your stuff" rather than "completely original".  You easily reduce other people's potential PhD theses to mere MSc theses.
14:32:57 <merus> Besides, keeping stuff secret sucks.
14:33:06 <augustss> exactly!
14:33:19 <Korollary> unless you are working as a spy
14:33:28 <cdsmith> If I were really interested in something I'm doing, I don't think I could avoid talking about it for years!
14:33:37 <monochrom> It comes down to a ratrace. Who gets there first.
14:34:30 <matthew-_> yep. No, I totally agree. And I'm a big fan of the release early, release often strategy too.
14:34:50 <monochrom> If you are already behind, there is nothing new you can publish anyway. :)
14:35:25 <sorear> If you release often and early enough you might become like SPJ.
14:35:38 <matthew-_> monochrom: well, it depends - if you approach the same problem from a completely different angle which gives better results anyway, that's worthwhile.
14:35:51 <sorear> Trivia: SPJ has no doctorate.  He's been offered plenty of them without obligation, though!
14:35:54 <matthew-_> sorear: I doubt I'll ever be like SPJ ;)
14:36:28 <sorear> Everyone just knows he's a genius.  He's so famous he doesn't need a certificate.
14:36:41 <Heffalump> yes, but getting an academic job these days without a doctorate might be harder
14:37:13 <monochrom> Ha! There is also a bluffing game. If you publish or even just post like crazy, other people may go "damn, too much competition here, I should switch to something else". Then you get less competition!
14:37:42 <nominolo> sorear: do you also know if GetOpt used to be bundled with Cabal only?
14:38:11 <sorear> nominolo: AFAIK getopt has always existed somewhere.
14:38:24 <matthew-_> monochrom: you've been thinking about this for some time haven't you?!
14:38:35 <sorear> nominolo: but remember cabal needs to have no deps, since it is used to build everything else.
14:38:50 <monochrom> I have been immersed in this business for some time!
14:39:06 <nominolo> sorear: yes.  the weird thing is that pandoc uses Distribution.GetOpt instead of the default thing
14:39:24 <matthew-_> monochrom: lol, sounds like it. What year PhD or have you finished?
14:39:36 <monochrom> I have not finished.
14:39:39 <nominolo> sorear: probably because the default GetOpt is pretty lame
14:40:09 <Heffalump> have you started? :-)
14:40:14 <nominolo> @hoogle GetOpt
14:40:15 <lambdabot> Distribution.GetOpt :: module
14:40:15 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
14:40:15 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
14:40:35 <matthew-_> monochrom: do you just push work onto a blog or mailing lists or quite what?
14:40:48 <monochrom> I actually haven't posted my work.
14:41:40 <nominolo> @info System.Console.GetOpt
14:41:40 <lambdabot> System.Console.GetOpt
14:42:04 <nominolo> btw, the hoogle link is broken
14:42:12 <nominolo> (for the latter)
14:42:24 <nominolo> @seen ndm
14:42:25 <lambdabot> I saw ndm leaving #haskell 3h 11m 21s ago, and .
14:51:20 <ddarius> monochrom: To get that to work (posting like crazy) you need to make it completely incomprehensible BS that looks legitimate.
14:52:02 <njbartlett> Oops, SPJ isn't a Dr? I've been addressing him as Dr Peyton Jones in my emails about the user group
14:52:07 <ddarius> Or it can be legitimate, but the key is to be completely incomprehensible.
14:52:29 <olsner> just phrase it in monads and category theory, and no-one except haskell people will understand it
14:53:12 <ddarius> http://research.microsoft.com/~simonpj/bio.html
14:53:13 <lambdabot> Title: Simon Peyton Jones
14:53:55 <njbartlett> Well I did read that but I guess I didn't READ it
14:54:28 <mux> ugh! wikipedia has some crufty one-liners for haskell
14:54:30 <mux> The following Haskell program is a one-liner, except for the two import statements. It sorts its input lines asciibetically.
14:54:33 <mux> import IO
14:54:36 <mux> import List
14:54:38 <mux> main = (sequence . map putStrLn . sort . lines) =<< getContents
14:54:47 <mux> it could use mapM, or be even smarter and use interact
14:54:55 <mux> interact (unlines . sort . lines)
14:55:06 <mux> this is on: http://en.wikipedia.org/wiki/One-liner_program
14:55:08 <lambdabot> Title: One-liner program - Wikipedia, the free encyclopedia
14:56:05 <ddarius> So change it.
14:56:10 <augustss> mux: fix it! :)
14:56:29 <mux> yeah, I'm doing it right now
14:56:36 <mux> just wanted to share the fun
14:56:54 <mux> or maybe it's just that I'm feeling down with Sarkozy having just been elected and I need #haskell love
14:57:46 <monochrom> I know how to make my work incomprehensible but awe-inducing.
14:57:53 <mux> here
14:58:10 * ddarius should start coding something, anything.
15:00:47 <ddarius> mux: Just get rid of the other ones unless they do something differently.
15:01:31 <ddarius> Incidentally, you could put it all on one line.
15:02:28 * ddarius downloads an assembler.
15:06:52 <matthew-_> mux: oh, he got elected did he? What's that Chinese proverb about it being a blessing to live in interesting times?
15:08:36 <monochrom> I'm Chinese and I don't know of a Chinese proverb to that effect. But I offer you a tautology. "It's interesting to live in interesting times." Works just as well!
15:08:52 <ddarius> "But most likely you don't."
15:09:04 <njbartlett> I think it's an apocryphal Chinese proverb.
15:09:31 <njbartlett> When people think they heard a saying once, but can't remember where, they assume it must be an old Chinese proverb.
15:09:45 <augustss> matthew-_: it's a (alledgedly) Chinese curse: "May you live in interesting times!"
15:10:07 <monochrom> haha
15:10:23 <njbartlett> http://en.wikipedia.org/wiki/May_you_live_in_interesting_times
15:10:24 <lambdabot> Title: May you live in interesting times - Wikipedia, the free encyclopedia
15:10:24 <Visual_E> it was created as an apocryphal chinese curse
15:11:30 <njbartlett> I like the next two worst curses: "may you come to the attention of those in authority" and "may you find what you are looking for" :-)
15:11:38 <ddarius> "Tick Tock" was horrible.
15:13:24 <matthew-_> right. Too much type theory for one day, I need bed. nn.
15:18:49 <kc5tja> I rather like the curse that our "curse generator" program in C class produced for me one day: "May your Frigidaire stick to your face."
15:18:53 <kc5tja> Wow, that's powerful.
15:24:25 <monochrom> Hahahaha
15:24:48 <ddarius> And people complain about lambdabot.
15:25:40 <olsner> "Digital's search engine AltaVista has indexed over 1500 Web sites that mention the phrase." - google now gives 80 million hits for "may you live in interesting times"
15:27:37 <kc5tja> I get 122,000 hits with AltaVista (using quotes around the phrase)
15:28:03 <olsner> aah, forgot the quotes - 142k with quotes
15:28:09 <kc5tja> 143,000 in Google (also with quotes)
15:28:31 <ehird`> lambdabot odd quine: ((++) >>= \ b -> show >>= \ a -> return (b a)) "((++) >>= \ b -> show >>= \ a -> return (b a)) "
15:28:54 <olsner> whut, how can we get a different number of hits for the same query?
15:29:52 <sorear> better
15:30:01 <sorear> > ap(++)show"ap(++)show"
15:30:03 <lambdabot>  "ap(++)show\"ap(++)show\""
15:30:20 <kc5tja> olsner: Although I work for Google, I do not work in the search engine department.  I couldn't tell you.  But, I cut-n-paste the numbers in (too lazy to type).
15:30:28 <ddarius> > ((++) >>= \ b -> show >>= \ a -> return (b a)) "((++) >>= \ b -> show >>= \ a -> return (b a)) "
15:30:29 <lambdabot>  Illegal character in string gap
15:30:55 <sorear> you need to double the \s
15:31:01 <ddarius> I know.
15:31:59 * ddarius tends to speak with @run, @type, @pl, @djinn, @hoogle, or @google.
15:36:45 <Heffalump> olsner: probably because the queries hit different machines with differently out-of-date databases
15:38:25 <sorear> somehow I doubt google has enough disk to keep a copy of the index on every machine ... caching would make sense, but for semi-obscure queries being haskelldotted they should all cachefill at about the same time ...
15:39:42 <sorear> kc5tja: does the 85816 have any notion of proper alignment?
15:40:14 <sorear> kc5tja: I'm trying to read the firmware and all these odd offsets are making me wonder if I'm missing something
15:42:29 <nominolo> :t (<++)
15:42:32 <lambdabot> Not in scope: `<++'
15:43:29 <sorear> iirc that's a special pappy (readp?) combinator
15:43:37 <sorear> @docs Text.ParserCombinators.ReadP
15:43:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
15:43:47 <Saizan> ?hoogle <++
15:43:48 <lambdabot> Text.ParserCombinators.ReadP.(<++) :: ReadP a -> ReadP a -> ReadP a
15:43:48 <lambdabot> Text.ParserCombinators.ReadPrec.(<++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
15:43:59 <nominolo> k, thanks
15:56:59 <kc5tja> 65816 you mean?  No -- it has an 8-bit wide bus, so it's comfortable with stuff aligned arbitrarily.
15:57:49 <kc5tja> sorear: The odd offsets exist because the S register behaves like a text cursor; it points to where the next datum _will be_ pushed, not where the last pushed item is.
15:58:06 <kc5tja> The data stack uses the same convention, if memory serves me correctly.
15:58:19 <sorear> I did suspect that it wouldn't be an issue.
15:58:27 <sorear> ah yes.  silly me
15:58:41 <sorear> I was thinking at the time "Oh, 24 bit returnaddress"
15:58:44 <kc5tja> Yeah; it's just different.  Also, only positive offsets are supported, which explains why the data stack is mroe bizarre still.
15:59:05 <kc5tja> Oh, and return addresses have a -1 bias on them.
15:59:06 <kc5tja> :)
15:59:07 <sorear> I now remember the 0-bank-only thing
15:59:29 <kc5tja> Fortunately, I almost never tinker with return addresses, so it is isn't really an issue.
15:59:34 <sorear> Actually, Intel chips have the postincrement/predecrement nature too.
15:59:46 <sorear> Come to think of it, so do 680x0...
15:59:54 <kc5tja> No, what I mean is *(S+1) = v where v is one less than the actual address.
16:00:21 <sorear> Sorry, I'm still on the S+1 :)
16:00:27 <kc5tja> Oh.
16:00:40 <kc5tja> 65816 has post-decrement.
16:00:42 <sorear> anyway funky return addresses are something I almost expect now...
16:01:01 <sorear> Blech, blech
16:01:11 <sorear> Stefan, stacks grow *down*
16:01:16 <sorear> how did I forget that...
16:01:25 <ddarius> As do trees
16:02:39 <sorear> It'd be nice if the firmware had doc comments ;)
16:04:30 <kc5tja> sorear: ??  The firmware is written using noweb.  You can't get better documentation than that.  :)
16:04:46 <kc5tja> Is there a file called FIRMWARE.pdf or BOOK.pdf?
16:04:54 * ddarius whips out dpans94.pdf
16:05:15 <kc5tja> ddarius: Forth doesn't specify which direction stacks grow, but in my code, the data stack also grows downward.
16:05:34 <ddarius> I'm whipping that out for totally different reasons.
16:05:48 <kc5tja> Ahh
16:05:57 <sorear> kc5tja: Bah.  I was trying to read the .aw file
16:06:08 <kc5tja> Ahhh....  that would explain it.  :)
16:06:19 <sorear> kc5tja: when an undecorated integer is used as an address, what mode is it?
16:06:26 <kc5tja> absolute.
16:06:33 * sorear only read the datasheet like ten minuetes ago...
16:06:39 <kc5tja> Hehehe :)
16:07:01 <sorear> Trying to understand code is hard enough when you have docs and know the language! :)
16:07:55 <kc5tja> Yeah.
16:08:39 <sorear> kc5tja: does the 85816 have the property that interrupts are disabled in interrupt handlers?  (your cursor code looks racy)
16:09:11 <kc5tja> Yes, IRQs are disabled for all exception types.
16:10:00 <kc5tja> Also, you must be a real fan of Commodore to keep using 85816.  ;)
16:10:28 <kc5tja> (since Commodore later switched to the 85xx numbering scheme after WDC came into existance, as WDC maintains the 65xx registry numbers)
16:11:03 <sorear> No, I've never even seen a commodore...
16:11:18 <sorear> oldest computer I've used was a Vectrex
16:11:33 <lucca> mmm, 2A03
16:15:22 <hugs98> Hi, I'm playing around with WriterT in the form "WruterT (State st Char) (State st) Char
16:15:44 <sorear> kc5tja: On entry to Integer_unsignedMultiply16Bits, are the numbers to be multiplied on the top of the stack?
16:15:56 <hugs98> do i need to create a Monoid instance for State st Char?
16:16:26 <sorear> Yes.
16:16:53 <monochrom> I ask you to reconsider. You may be doing something wrong.
16:16:54 <sorear> Why are you building actions, by the way?
16:17:14 <sorear> That's either an error or you trying something far too advanced :)
16:19:52 <dmwit> > 0x2a03
16:19:54 <lambdabot>  10755
16:20:11 <sorear> kc5tja: I think I've found a bug in your integer multiply routine.
16:20:11 <hugs98> I am trying to define a function :  f :: WriterT (State st Char) (State st) Char
16:20:18 <sorear> hugs98: Why?
16:20:34 <hugs98> Want to get grips with Writer Transformers
16:20:44 <hugs98> simplest example I can think of
16:20:45 <sorear> That type is suspicious.
16:20:50 <hugs98> in what way?
16:20:57 <monochrom> Start with WriterT String (State st) Char.
16:21:04 <hugs98> ok
16:21:28 <monochrom> Imagine you're logging things to the "String" part.
16:21:51 * dons yawns
16:21:56 <dons> another day, another monad.
16:22:42 <Saizan> btw, you can't make (State st a) a monoid with >>=, right?
16:22:51 <monochrom> No.
16:22:56 <hugs98> The first example I tried was WriterT [Char] [] Integer
16:23:43 <monochrom> You can harp on the "WriterT [Char] ..." part for quite a while, using different "..."s.
16:25:21 <monochrom> The next step is "WriterT [something else] ..." but still a list there.
16:26:09 <monochrom> There are other fun and useful things in place of [something else], but State x y is not one of them.
16:27:20 <hugs98> this is fun :p
16:27:29 <hugs98> I mean playing around with this
16:27:30 <hugs98> :p
16:28:27 <Saizan> now i want to write a program that uses WriterT (State st Char) (State st) Char
16:28:50 <Saizan> ?instances MonadPlus
16:28:52 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:32:17 <dmwit> ?hoogle StdGen -> IO ()
16:32:18 <lambdabot> Random.setStdGen :: StdGen -> IO ()
16:33:55 <dmwit> ?hoogle Bool -> m () -> m ()
16:33:56 <lambdabot> No matches, try a more general search
16:34:18 <dmwit> ?hoogle m Bool -> m () -> m ()
16:34:18 <lambdabot> No matches, try a more general search
16:35:49 <nominolo> :t unless
16:35:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:36:17 <nominolo> :t when
16:36:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:36:24 <dmwit> ?hoogle (Monad m) => Bool -> m () -> m ()
16:36:25 <lambdabot> No matches, try a more general search
16:36:31 <dmwit> hoogle--
16:36:39 <nominolo> @slap hoohle
16:36:39 * lambdabot slaps hoohle
16:36:45 <kc5tja> sorear: No bug in multiply; there is a bug in divide though.
16:36:49 <nominolo> @slap hoogle
16:36:50 <lambdabot> why on earth would I slap hoogle
16:37:34 <sorear> kc5tja: How are values passed into multiply?
16:37:55 <kc5tja> sorear: You push the multiplicands onto the CPU's stack, kind of like how you'd call a C function.
16:38:00 <sorear>     sta 3,s
16:38:00 <sorear>     lda #0
16:38:00 <sorear>     sta 5,s
16:38:11 <sorear> looks like code that will erase the stack
16:38:17 <kc5tja> Nope.
16:38:32 <kc5tja> It's a 16-bit by 16-bit multiply, so the output will be a 32-bit value.
16:38:44 <kc5tja> Gotta clear the upper 16-bits for the result to make any kind of sense.
16:39:37 <sorear> So 3,s is the 32-bit result?
16:39:56 <kc5tja> I don't remember, but it looks like it.
16:42:24 <sorear> kc5tja: Now, the code makes sense if I mentally substitute 5 with 5,s , etc.
16:42:50 <sorear> kc5tja: the inner loop is using odd absolute addressess when it seems to want stack?
16:43:03 <kc5tja> sorear: Ahh, no, it's using "direct page."
16:43:18 <sorear> Ah ok.
16:43:20 <kc5tja> Addresses between 0..255 inclusive are, unless notated otherwise, considered to be direct page.
16:43:24 <sorear> See - learning the language!
16:43:31 <sorear> So 256 /= 255 + 1
16:43:33 <kc5tja> The D register points to the direct page in bank zero.
16:43:33 <sorear> Wow.
16:43:37 <kc5tja> Right.
16:43:48 <kc5tja> You will occasionally see something like 0:a
16:43:55 <kc5tja> that ":a" means "force absolute mode."
16:44:36 <kc5tja> The 6502's direct page literally _is_ zero page (it cannot be moved), so once upon a time 0..255 really was $0000..$00FF.  It was just treated specially.
16:44:56 <kc5tja> The 65816 allows direct page to be relocated, and in this case, I overlap it with the stack to get greater convenience and a wider variety of addressing modes.
16:45:07 <sorear> Muahaha...
16:47:12 <dmead> oooh monads make my head hurt
16:49:18 <Pastorn> dmead: what are you reading?
16:49:30 <dmead> done reading
16:49:37 <dmead> trying again to use the supply monad
16:49:40 <ddarius> Apparently not.
16:50:51 <dmead> ooo a
16:50:53 <dmead> a compile
16:50:54 <dmead> :)
16:51:07 <ventonegro> funny to see all the php bashing on debian-devel, since several debian tools are written in... perl
16:51:26 <dmead> but php isn't perl based anymore
16:51:35 <dmead> sounds like c++ people bashing straight C though
16:51:41 <zomb> paludis ;)
16:51:42 <ventonegro> i never thought it was
16:51:49 <dmead> it was
16:51:50 <dmead> at first
16:52:14 <gravity> ventonegro: Very few new tools are written in perl though. Pretty much all that was written when perl was still the best thing around.
16:52:15 <ventonegro> that's why both sucks! :-)
16:52:37 <ventonegro> gravity, actually, i'm not against perl or php
16:52:39 <gravity> And php is a nightmare to maintain on a scale far greater than perl
16:52:54 <ventonegro> i've *defended* php on that thread :-)
16:52:59 <gravity> geez
16:53:04 <gravity> You should maintain php then
16:53:10 <dmead> tell them to get a clue and use haskell
16:53:21 <gravity> dmead: Tell all of Debian's PHP users to use haskell?
16:53:30 <dmead> yes!
16:53:37 <gravity> riiiiiiiiiight
16:53:40 <kc5tja> That's kickban material right there.
16:53:45 <dmead> also to quit debian and use gentoo
16:53:46 <dmead> :P
16:53:55 * kc5tja remembers asking folks in #debian a question, even indicating I RTFM'ed, and I was _kickbanned_ for asking.
16:53:57 <ventonegro> gravity, i'm not talking about implementation bugs, but the choice of language
16:54:01 <monochrom> bashing is unhealthy
16:54:15 <dmead> #ishing?
16:54:33 <dmead> or does that mean pounding
16:54:34 <dmead> hmm
16:54:42 <kc5tja> #ing you mean?
16:55:07 <ventonegro> anyone is free to choose any language they want, and not be called names like "putrid programming"
16:55:17 <dmead> yes
16:55:18 <ventonegro> that did it for me
16:55:20 <dmead> #ing
16:55:29 <olsner> ooh, this is fun! "a #table is indexed by #es"
16:55:44 <kc5tja> Yeah, if it weren't for all these inferior languages, we wouldn't have something to boast about.  ;D
16:55:47 <kc5tja> (j/k)
16:56:16 <njbartlett> Phantom type parameters make my head hurt!
16:56:20 <ventonegro> i don't even like php, do most web programming in chicken scheme
16:56:34 <dons> njbartlett: hehe.
16:56:51 <dons> ?users
16:56:52 <lambdabot> Maximum users seen in #haskell: 336, currently: 294 (87.5%), active: 36 (12.2%)
16:56:53 <dons> ?uptime
16:56:53 <lambdabot> uptime: 13d 17h 11m 35s, longest uptime: 13d 17h 11m 35s
16:56:58 <monochrom> Nothing makes my head hurt!  Just 0 is ok though.
16:57:11 <dons> Just (-1) is even better
16:58:32 <moozilla> Hi, I'm new to Haskell, and I have a question
16:58:46 <siti> just ask it
16:58:51 <ddarius> njbartlett: Phantom types are your friend.
16:59:06 <moozilla> Alright I'm using Hugs and I can't get things like Char.toUpper to work
16:59:07 <dons> when they're not trying to kill you.
16:59:11 <agocorona> I heard about a parser library for byteString similar to Parsec...
16:59:27 <siti> moozilla: what's the error?
16:59:30 <dmwit> moozilla: :l Char
16:59:32 <dons> moozilla:
16:59:33 <dons> Hugs.Base> :l Char
16:59:33 <dons> Char> toUpper 'x'
16:59:33 <dons> 'X'
16:59:42 <agocorona> hi
16:59:46 <dmead> hi dons
16:59:53 <moozilla> Undefined variable "toUpper"
16:59:54 <ddarius> Or just don't use Hugs!
16:59:59 <dons> hey dmead
17:00:04 <njbartlett> ddarius: I think you're right, but my friends also give me headaches.
17:00:04 <dmwit> agocorona: I think that's a SoC project.
17:00:09 <dons> yeah
17:00:14 <moozilla> Is there another Windows option?
17:00:19 <dmead> about the supplymonad stuff
17:00:23 <dons> GHC, moozilla
17:00:24 <dmead> x <-get
17:00:27 <dmead> is how you grab from the state?
17:00:43 <moozilla> There is a Windows version of GHC?
17:00:44 <ndm> what is the complaint about Hugs? its great!
17:00:46 <dons> > runState( do x <- get ; put (x+1) ; return 7) 4
17:00:47 <lambdabot>  (7,5)
17:00:57 <ndm> moozilla, yes, try GHC 6.6 - no 6.6.1 yet
17:01:03 <moozilla> Oh, thanks
17:01:03 <ddarius> Don't all implementations, theoretically, run on all the major OSes?
17:01:07 <dmead> ah
17:01:46 <ndm> ddarius, nhc doesn't run on Windows
17:01:46 <dmead> variable you arrow are always inferred as the proper type?
17:01:46 <dmead> *variables
17:01:50 <sorear> I'll bet hbc doesn't either.
17:02:12 <agocorona> thanks
17:02:20 <ndm> hbc is virtually before windows was written though, so you have to forgive it
17:02:36 <ddarius> ndm: Didn't it?
17:02:49 <sorear> ndm: nhc wasn't too?
17:02:51 <ndm> plus i get the feeling hbc is better designed and implemented than nhc
17:03:02 <ndm> sorear, it was before, but it has persisted til well after
17:03:19 <ndm> ddarius, it may have half worked on cygwin once, but it was never actually on windows
17:03:26 <ndm> GHC only runs on Mingw
17:03:37 <ndm> Yhc is the only truely native Windows haskell compiler
17:04:07 <sorear> And there's always the high memory issue...
17:04:07 <dons> native windows bytecode compiler ;-)
17:04:31 <ndm> dons - its not bytecode only anymore :-)
17:04:40 <dons> with the ghc backend?
17:04:42 <ndm> it just is as far as the world has seen ;)
17:04:45 <sorear> yeah, even hugs is a bytecode compiler.
17:04:57 <ndm> the GHC back end, the Javascript back end, the Clean back end and the C back end
17:05:04 <ventonegro> @where yhc
17:05:04 <dons> which ones are used?
17:05:05 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
17:05:18 <ndm> dons i'm using the GHC, Clean and C one most days
17:05:28 <agocorona> and.. what about the ghc runtime debugger?
17:05:32 <sorear> ndm: ISTR you yourself saying "it won't work except on nobench, it's building on a foundation of quicksand"
17:05:32 <dons> maybe you guys should have ported hbc, instead of nhc. hmm.
17:05:36 <ndm> dons for benchmarking and optimisation work - not real work
17:05:42 <dons> ah right.
17:06:19 <dons> if i was starting my phd now, i'd think seriously about improving hbc
17:06:28 <ndm> sorear, the Yhc.Core language is a rock solid foundation - it just so happens the only Yhc.Core implementation is in a compiler that stinks
17:06:58 <ndm> once GHC.Core isn't broken, I can implement Yhc.Core on top of it, and suddently everything I do is Yhc/GHC compatible, and ideally works with bhc
17:07:01 <sorear> ndm: -O11 is part of yhc?
17:07:16 <dons> sorear: did we work out if TuringTest put the patched versions of the regex libs on hackage?
17:07:31 <sorear> dons: he anned it on the ml
17:07:37 <ndm> sorear, it builds on Yhc.Core - it uses the underlying Core language, and requires Yhc to compile the code to begin with, but is entirely portable to other implementations
17:07:43 <dons> hey, would WikipediaFS work for other mediawiki sites, like um, haskell.org ?
17:07:55 <dons> yes! http://wikipediafs.sourceforge.net/
17:07:56 <lambdabot> Title: WikipediaFS, view and edit Wikipedia articles as if they were real files
17:08:07 <sorear> ndm: that's what I thought.  so therefore your comment must apply to -O11 not yhc
17:08:10 <dons> just needs linux.
17:08:33 <ndm> sorear which comment?
17:09:16 <ndm> the quicksand one is Yhc only - the optimisations will be solidly on Yhc.Core
17:09:42 <ndm> i.e. i should get 100% GHC coverage simply by porting Yhc.Core
17:09:56 <sorear> dons: The fixed version is 0.72
17:10:00 <sorear> what's on hackage/
17:10:03 <dons> sorear: ok.
17:10:09 * dons does a lambdabot build
17:10:16 <sorear> dons++
17:10:32 <ddarius> Yay!
17:12:26 <cdsmith> dons: sorry for all the emails.  I would've sent only the final patch; but I thought I was done each of the first two times.
17:13:14 <ndm> how much do you think it would take to bribe ross to add GHC pattern guards to Hugs?
17:13:37 <ddarius> ndm: A patch.
17:14:07 <ndm> ddarius, patching Hugs doesn't sound like a fun thing to start doing...
17:14:24 <ddarius> Well, no.
17:14:31 <ndm> i know some of it quite well, but deliberately avoid the type checker and code gen bits
17:14:38 <ndm> C really is a truely horrid language...
17:14:58 <dons> cdsmith: that's fine.
17:15:28 <dons> ndm, and writing in C kills collaboration with haskell people :/
17:15:51 <dons> whereas writing a new project in haskell *attracts* developers
17:15:55 * gravity splits his time writing C and learning haskell
17:15:58 * ddarius really needs to get around to downloading a C compiler.
17:16:20 * dons notes xmonad has 4x the developers of dwm and ion, purely due to the src language choice :-)
17:16:31 * cdsmith uses a text editor I wrote in C to write Haskell
17:16:36 <ndm> dons, i know!
17:16:47 <dons> cdsmith: heh
17:16:48 <ddarius> Okay. I have downloaded it.  Just need to install it.
17:17:00 <ndm> dons - but a lot of projects will never attract any developers - some do, some don't - and its hard to know before hand
17:17:15 <siti> what about the guy that said sawfish was bad enough being made in lisp ;)
17:17:27 <dons> yeah. the more general the utility, the more you get, i think is a rough rule
17:17:42 <dons> siti: yeah, that was cute.
17:18:33 <sorear> kc5tja: What is the Kestrel's nominal CPU clock rate?
17:18:49 <olsner> cdsmith: now you just have to bootstrap yourself onto a Haskell-written editor :P
17:19:08 <dons> sorear: oh, the regex on hackage is 0.91
17:19:11 <ddarius> @where yi
17:19:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:19:12 <dons> 2 versions after 0.72
17:20:42 <cdsmith> olsner: really?  I was thinking of just hacking together some HaRe integration for lpe.
17:20:57 * cdsmith was only thinking that because I REALLY don't want to study for finals.
17:21:39 <dons> heh
17:21:51 <dons> i used to go on lambdabot benders before my exams
17:21:57 <olsner> http://cdsmith.twu.net/professional/opensource/screenshots.html <- 404
17:22:28 <sjanssen> @remember dons i used to go on lambdabot benders before my exams
17:22:29 <lambdabot> Done.
17:22:39 <cdsmith> olsner: http://cdsmith.twu.net/professional/opensource/lpe/screenshots.html
17:22:41 <lambdabot> Title: Lpe Screen Shots, http://tinyurl.com/ytxjrg
17:22:52 <olsner> yeah, found it.. the menu hade the correct URL
17:23:09 <olsner> but the text on the front-page doesn't
17:23:34 <cdsmith> Well, I haven't really updated my web site since 1999 or so.
17:24:41 <cdsmith> I should probably delete parts of it wholesale.  People are actually reading it, and that worries me.
17:25:47 <olsner> ah, the beauty of the internet ;-)
17:29:09 <ndm> woo, Hoogle 4 just did a monomorphic precise matching type search!
17:30:27 <dons> ndm, any hoogle updates i should suck into lambdabot yet?
17:30:40 <cdsmith> Looks like HaXml doesn't do XML Schema validation?  Is that accurate?
17:30:51 <ndm> dons - no, please stay away from the repo for a while yet
17:30:55 <dons> ok
17:31:01 <ndm> it possibly doesn't build...
17:31:02 * dons runs far far away
17:35:32 <TSC> dons: I got wikipediafs to work with haskellwiki
17:35:47 <sorear> ndm: you said catch takes <2s on all of hscolour
17:36:00 <TSC> It seems that you can't put a comment with your changes, though
17:36:01 <ndm> sorear, excluding time to compile with Yhc - yes
17:36:04 <dons> TSC: nice. screenshot? :-)
17:36:06 <sorear> ndm: that's less than the lambdabot subprocess timeout
17:36:07 <dons> TSC: ah interesting.
17:36:25 <ndm> time to compile with Yhc is a few seconds, maybe 8 seconds
17:36:31 <dons> TSC: "Haskell mode for Emacs; 10:30 . . TSC (Talk)" :-)
17:36:33 <dons> that was from the fs?
17:36:36 <TSC> Yes
17:36:39 <dons> sweet.
17:36:41 <ndm> soear, what could people give as the input though?
17:37:00 <sorear> ... good point.
17:37:04 <dons> ?where darcs
17:37:04 <lambdabot> http://darcs.net/
17:37:04 <TSC> Ah!
17:37:10 <ndm> sorear - other than @catch hscolour as the standard operation, which would be cool in itself
17:37:14 <dons> ?where djinn
17:37:14 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
17:37:18 <TSC> dons: You can add a summary (it explains how in the man page)
17:37:28 <dons> TSC: anything you find out, could you send the haskell-cafe@ ?
17:37:47 <TSC> Yep, I'll do that
17:38:16 <sorear> ndm: how about @catch <url>  does a darcs get, cabal build --yhc, ... :)
17:38:47 <sorear> but I'm just in craziness now
17:38:54 <ndm> sorear, would be lovely - unfortunately darcs get, then building with yhc gives you about a 0.001% chance of working
17:38:56 <dons> yes. :-)
17:39:27 <ndm> rising to about 3% if you restrict to programs that malcolm wrote and are haskell 98 and work on nhc
17:40:58 <sorear> kc5tja: is the FIRMWARE.pdf file up to date?
17:41:31 <dons> ndm, idoc, Manuel's haddock clone, works in nhc.
17:41:44 <dons> so that's an optoin :-)
17:43:18 <ndm> dons, that is probably feasible
17:43:37 <ndm> i did look at haddock, but fast mutable int's scared me off...
17:44:02 <dons> yeah.
17:48:18 <dons> oh, there's a nice case of overloading on Num in djinn. hadn't seen that.
17:48:26 <dons> ----- The type naturals + infinity
17:48:26 <dons> data Ninf = I !Integer | Inf
17:55:51 <sorear> Wadler and Augustsson are on pho... how long until all of them are?
18:02:13 <mutjida> pho?
18:05:32 <dolio> planet.haskell.org?
18:08:56 <kc5tja> sorear: On the website?  No.  In the darcs repo, it _should be_.
18:09:03 <kc5tja> If not, let me know, and I'll send you an update.
18:13:27 <sorear> Oh, there was a pdf in the repo?  *oops*
18:13:44 * sorear just installed eight hundred megabytes of LaTeX
18:15:10 <olsner> what kind of overloading is possible in haskell? could I for example have a function that works on both lists and tuples?
18:15:30 <dons> sure
18:15:39 <dons> > id (1,2,3)
18:15:40 <lambdabot>      Failed to load interface for `Monad.Writer':
18:15:41 <lambdabot>       Use -v to see a list ...
18:15:43 <dons> > id [1,2,3]
18:15:44 <lambdabot>      Failed to load interface for `Monad.Writer':
18:15:45 <lambdabot>       Use -v to see a list ...
18:15:47 <olsner> so I just write something like f (x:xs) = ...; f (x,y) = ...?
18:15:49 <dons> assuming i don't break lambdabot in the meantime :-)
18:16:08 <dons> olsner: no. you can't overload like that
18:16:19 <dons> either you are fully parametrically polymorphic in an argument
18:16:22 <dons> like id
18:16:23 <dons> :t id
18:16:26 <lambdabot> forall a. a -> a
18:16:33 <dons> or you use a typeclass for bounded polymorphism.
18:16:35 <ddarius> @uptime
18:16:35 <lambdabot> uptime: 13d 18h 31m 19s, longest uptime: 13d 18h 31m 19s
18:16:40 <dons> where your tuple and list are both in the typeclass
18:16:51 <dons> ddarius: i'm in the process of doing a (biggish) upgrade
18:17:19 <dons> olsner: so to be polymorphic in lists and tuples (very rare) you need to find an interface they both support
18:17:25 <dons> and then write a typeclass for that
18:17:38 <dons> so, for example, lists and non-zero tuples both support a notion of 'head', I suppose
18:17:44 <olsner> so I'd like create a HasHeadAndTail type class, implement it for types of interest, and use that restricted interface in the function
18:18:02 <dons> so you could have a class Headable t where head :: t a -> a
18:18:13 <cdsmith> olsner: the "tail" of a tuple, though, would be of a different type than the tuple itself.
18:18:14 <dons> ok, that's the Monoid class, almost.
18:18:38 <dons> but yeah, in general, you can't use tuples like this
18:18:49 <dons> since they encode the type of the elements and the length, in the ytpe.
18:18:57 <dons> they're quite different structures to recursive lists
18:19:44 <dons> olsner: but have a look at Data.Monoid
18:19:52 <olsner> what I really want to do is create a monad that has a number of "atoms" that aren't monads - and I don't want the user to have to lift or otherwise bother
18:19:52 <dons> ?src Monoid
18:19:52 <lambdabot> class Monoid a where
18:19:53 <lambdabot>     mempty  :: a
18:19:53 <lambdabot>     mappend :: a -> a -> a
18:19:53 <lambdabot>     mconcat :: [a] -> a
18:20:53 <dons> > 1+2
18:20:55 <lambdabot>  3
18:20:59 <chowmeined> What is the form to define a datatype to take two first units of one type and the second two to be another type?
18:21:17 <chowmeined> I tried: Item :: a -> a -> b -> b -> Item a a b b
18:21:26 <ddarius> data AType a b = Item a a b b
18:21:36 <dons> ?quit back in a sec.
18:21:48 <chowmeined> oh.. like that
18:21:48 <ddarius> type Item a b = (a,a,b,b)
18:22:03 <dons> > 1+2
18:22:09 <lambdabot>  3
18:22:19 <dons> ?let x = 8
18:22:21 <ddarius> @let there be = light
18:22:25 <lambdabot> <local>:2:0:     Multiple declarations of `L.x'     Declared at: <local>:1:0 ...
18:22:30 <dons> ?undefine
18:22:33 <lambdabot> <local>:2:11: Not in scope: `light'
18:22:39 <lambdabot> Undefined.
18:22:42 <dons> ?let x = 8
18:22:47 <lambdabot> Defined.
18:22:50 <dons> > x + 2
18:22:51 <lambdabot>  10
18:22:59 <dons> ?version
18:22:59 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
18:23:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:23:25 <dons> also features an updated djinn
18:23:36 <dolio> @type on
18:23:39 <lambdabot> Not in scope: `on'
18:23:49 <ddarius> @djinn f :: Eq a => a -> a -> Bool
18:23:50 <lambdabot> Cannot parse command
18:24:07 <dolio> @let on g f a b = f a `g` f b
18:24:08 <lambdabot> Defined.
18:24:09 <dons> :t Data.Function.on
18:24:11 <lambdabot> Couldn't find qualified module.
18:24:19 <dons> oh, its in ghc head only
18:24:38 <dolio> > sortBy (compare `on` snd) $ zipWith [1..10] [10, 9 .. 1]
18:24:39 <lambdabot>  Couldn't match expected type `a -> b -> c'
18:24:59 <dolio> > sortBy (compare `on` snd) $ zip [1..10] [10, 9 .. 1]
18:25:00 <lambdabot>  [(10,1),(9,2),(8,3),(7,4),(6,5),(5,6),(4,7),(3,8),(2,9),(1,10)]
18:25:33 <dolio> Will that stick around for a while?
18:26:02 <ddarius> @uptime
18:26:02 <lambdabot> uptime: 4m 24s, longest uptime: 13d 18h 36m 21s
18:26:31 <cdsmith> @unpl 2^3^4
18:26:32 <lambdabot> (2 ^ (3 ^ 4))
18:26:43 <cdsmith> dons: you put in my patches, then?
18:26:46 <dons> yeah
18:26:55 <cdsmith> @karma+ dons
18:26:55 <lambdabot> dons's karma raised to 145.
18:27:30 <sjanssen> @redo m >>= f . g
18:27:31 <lambdabot> do { a <- m; f . g a}
18:27:40 <sjanssen> hmm, I should see about fixing that one
18:28:06 <sjanssen> @undo do { a <- m; f . g a}
18:28:07 <lambdabot> m >>= \ a -> f . g a
18:29:07 <ddarius> Freshly upgraded lambdabot, shapr.
18:29:18 <dolio> @vixen
18:29:19 <lambdabot> <undefined>
18:29:42 <shapr> yay
18:29:57 <ddarius> @uptime
18:29:58 <lambdabot> uptime: 8m 20s, longest uptime: 13d 18h 36m 21s
18:30:19 <cdsmith> dolio: what's @vixen?
18:30:44 <dolio> cdsmith: lambdabot will flirt with you.
18:30:49 <dolio> Or something like that.
18:30:56 <dolio> If you're not cool enough she'll shoot you down.
18:31:13 <dons> vixen's still out.
18:31:32 <dons> but @let is fixed, and we have a new djinn. but not sure what new features we get (??)
18:32:55 <dolio> @djinn Ord a => a -> a -> a
18:32:56 <lambdabot> Cannot parse command
18:33:12 <dolio> Doesn't seem to be liking type classes.
18:33:46 <dons> yeah investigating...
18:34:27 <dons> I thought that was the feature that was added, but seems not to be the acse
18:35:08 <dolio> @djinn (Eq a) => a -> b -> b -> b
18:35:09 <lambdabot> f a b c =
18:35:09 <lambdabot>     case a == a of
18:35:09 <lambdabot>     False -> c
18:35:09 <lambdabot>     True -> b
18:35:14 <dolio> There we go.
18:35:18 <dons> ah ha
18:35:28 <dons> sweet.
18:36:12 <ddarius> @djinn (Eq a) => a -> a -> Bool
18:36:12 <lambdabot> f = (==)
18:36:19 <kpreid> @djinn (Monoid a) => a -> a -> a -> a
18:36:28 <dons> not sure we have many classes predefined
18:37:07 <dons> just Eq, in fact.
18:37:15 <kpreid> silence?
18:37:17 <ddarius> ?!
18:37:18 <lambdabot> Maybe you meant: . v
18:37:23 <dons> silence = failure
18:37:36 <dons> you can probably add more classes somehow
18:37:46 <ddarius> @djinn (Functor f) -> (a -> b) -> f a -> f b
18:37:46 <lambdabot> -- f cannot be realized.
18:37:51 <agocorona> anyone of you have used lambdaVM? It woul be greath to run haskell programs in mobile phones!
18:37:54 <ddarius> @djinn (Functor f) => (a -> b) -> f a -> f b
18:38:10 <ddarius> Argh
18:38:21 <dons> agocorona: for some reason its very rarely mentioned. i think the author doesn't promote it much.
18:38:34 <agocorona> I think so
18:38:37 <kpreid> dons: it never was silent on failure before
18:38:50 <cdsmith> On m,y local build, it hangs on those.
18:38:51 <sorear> @djinn a
18:38:52 <lambdabot> -- f cannot be realized.
18:38:56 <sorear> still isn't.
18:39:09 <agocorona> the market for mobile java applications is huge
18:39:16 <kpreid> sorear: but on an unknown typeclass, it is
18:39:50 <kpreid> @djinn (Eq a) => a -> a -> Maybe a
18:39:51 <lambdabot> f a b =
18:39:51 <lambdabot>     case a == a of
18:39:51 <lambdabot>     False -> Nothing
18:39:51 <lambdabot>     True -> Just b
18:39:59 <dolio> @djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
18:40:17 <kpreid> well, it didn't DWIM :)
18:40:19 <sjanssen> I don't think djinn can handle that class
18:40:39 <dolio> @djinn (Functor f) => (a -> b) -> f a -> f b
18:40:40 <lambdabot> f = fmap
18:40:44 <ddarius> Sweet
18:41:13 <sjanssen> handy
18:41:15 <kpreid> @djinn-add class Monad m where (>>=) :: m a -> (a -> m b) -> m b
18:41:17 <ddarius> @djinn (Functor f) => ((b -> a) -> f a) -> f b
18:41:17 <lambdabot> -- f cannot be realized.
18:41:18 <kpreid> er
18:41:32 <kpreid> @djinn-add class Monad m where (>>=) :: m a -> (a -> m b) -> m b; return :: a -> m a
18:42:06 <ddarius> @djinn (Functor f) => f b -> (b -> a) -> f a
18:42:06 <lambdabot> -- f cannot be realized.
18:42:35 <sorear> Remember, people, functor and monad are impossible in djinn.
18:42:51 <sorear> djinn implements typeclasses using dictionary desugaring
18:43:11 <sorear> the FunctorDict f is (forall a b. (a -> b) -> f a -> f b)
18:43:22 <sorear> and djinn still doesn't handle rank2 polymorphism
18:43:44 <ddarius> That's no fun.
18:51:20 <dolio> @djinn (Monoid a) => a
18:51:20 <lambdabot> f = mappend mempty mempty
18:52:26 <sjanssen> that's an interesting artifact
18:52:32 <twb> @hoogle [a] -> b
18:52:33 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
18:52:33 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
18:52:33 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
18:53:15 <sjanssen> djinn searches for functions that use every argument it's given, so it chooses "mappend mempty mempty"
18:55:05 <sorear> sjanssen: not true!
18:55:22 <sorear> @djinn (a -> a -> b) -> (c -> a) -> c -> c -> b
18:55:23 <lambdabot> f a b c _ = a (b c) (b c)
18:55:29 <sorear> that's 'on'
18:55:33 <dons> hmm. i wonder what reddit's 'initial position for new submissoins' algo is.
18:55:44 <dons> i just submitted a .ps.gz and it is inserted at position 9.
18:55:53 <dons> which seems unusually high.
18:56:22 <dolio> The real question is: what do spiders living in a kid's ear have to do with programming.
18:56:33 <dons> heh
18:56:40 * dons stricks to the programming subreddit
18:56:55 <dons> though I wish I could kick articles that are dual-submitted to the frontpage
18:57:24 <dons> Cale: we're winning when .ps.gz makes the front page ;-)
19:08:00 <littledan> dons, are there any useful programming languages (or haskell libraries) that implement the bird-meertens formalism?
19:08:16 <ddarius> HYLO?
19:08:33 <dons> hylo, yeah.
19:08:36 <dons> let me find the url
19:08:41 <dons> ?help hylo
19:08:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:08:54 <sorear> ha ha
19:09:02 <dons> hehe
19:09:05 <dons> sorear: :p
19:09:20 <dons> http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
19:09:54 <dons> sometimes sorear reminds me of Nelson Muntz
19:11:11 <littledan> that looks interesting
19:11:25 <dons> ?wiki Pointfree
19:11:25 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
19:11:27 <dons> has some references too
19:11:35 <ddarius> "Alcino" totally maken be think "alnico"
19:12:50 <ddarius> Yay, thunderstorm.  I could use something going my way.
19:13:01 <dons> he's a nice guy, met him at popl
19:14:01 <littledan> @pl \x -> x+1
19:14:02 <lambdabot> (1 +)
19:14:06 <ozzilee> Hi all, quick question: Any way to make backspace work for getLine? Specifically in GHCi on OS X.
19:14:33 <dons> hmm, xmodmap?
19:14:57 <dons> does 'delete' work?
19:16:26 <ozzilee> Well.. the key is labeled 'delete', but it's backspace.  I can't try forward delete, as the arrow keys don't work either.
19:17:08 <dons> dcoutts_: hmm, strikes me our approach to (hard core) optimisation with QuickCheck is a form of mechanised/supported 'transformational approach to program construction'
19:17:23 <dons> i.e. program construction and optimisation, from naive to (heavily) optimised, but with mechanical support.
19:17:42 <ozzilee> backspace gives me "^?". It sort of works, characters are actually deleted when I read the input, but it doesn't work interactively.
19:18:01 <dons> that is, we use QuickCheck to check equations beyond those that could be done by hand
19:18:07 <kpreid> ozzilee: the "problem" is that for some reason ghc changes the terminal settings when reading
19:18:28 <ozzilee> No, strike that, it doesn't actually work. Interactively or not.
19:18:52 * monochrom guesses crtl-h
19:19:25 <littledan> maybe GNU Readline?
19:19:42 <ozzilee> ctrl-h gives me "^H"
19:19:47 <kpreid> IMO, this is a bug in ghc (until I hear a good reason for it)
19:20:26 <dons> how could it be?
19:20:30 <dons> its a readline issue, isn't it?
19:20:35 <kpreid> no
19:20:35 <dmwit> ?index setLineBuffering
19:20:36 <lambdabot> bzzt
19:20:42 <monochrom> are characters actually deleted when you read the input?
19:20:43 <dons> or yeah, a setline buffering call
19:20:51 <dons> kpreid: do explain.
19:21:01 <kpreid> the kernel line editor is disabled
19:21:03 <kpreid> dons: try an ordinary unix app. you'll be able to backspace
19:21:06 <kpreid> this should not happen by default
19:21:09 <kpreid> and use ^D, too
19:21:17 <kpreid> try a haskell program. you lose that
19:21:53 <dmwit> No, setting the line buffering to NoBuffering doesn't fix it either.
19:22:20 <dmwit> kpreid: I get backspace (but not ^D) in ghc-compiled apps.
19:22:29 <dmwit> But in ghci, backspace seems to insert '\DEL'.
19:22:41 <qwr> you could try to trace syscalls and watch, what it does?
19:23:34 <kpreid> hSetBuffering stdin LineBuffering -- fix
19:23:46 <dmwit> Did you try it?  It doesn't fix anything here.
19:23:56 <kpreid> worked for me ...in ghci 6.4
19:23:59 <dmwit> (In ghci 6.4.1.)
19:24:05 <kpreid> er, 6.4.2
19:25:22 <kpreid> "The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered."
19:25:39 <kpreid> -- hey, at least it's documented to default to sane operation! too bad the implementation fails
19:26:44 <monochrom> or sanity has gone insane
19:27:35 <dons> kpreid: don't whinge, submit a patch
19:27:40 <dons> the hackers code.
19:28:17 <kpreid> touche
19:28:26 <kpreid> I'll shut up
19:29:00 <dons> well, if its a bug, submit a patch, or at least record it as such:
19:29:01 <dons> ?bug
19:29:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:29:01 <dons> !
19:29:10 <dons> g'day thedatabase.
19:29:12 <dons> how's code?
19:29:24 <littledan> dons, in that paper you posted on reddit, what does the small square box mean? I don't see where it is defined.
19:29:39 <thedatabase> haha --- alright dons.  Still chasing the plot!
19:29:46 <littledan> as in f*.{box}.a
19:30:20 <dons> littledan: what page?
19:30:32 <littledan> 5
19:31:07 <dons> is it a 'hold', to fill in with an argument?
19:31:10 <dons> s/hole/
19:31:40 <dons> ah ,no, see s3.4
19:31:55 <dons> 'the function that takes a to [a]'
19:32:04 <littledan> oh, how could I miss that
19:32:06 <dons> i.e. 'box', or 'return' or (:[]) -- nija monkey
19:32:16 <dons> ?let box = (:[]) -- ninja monkey
19:32:17 <lambdabot> Defined.
19:32:19 <dons> > box 8
19:32:21 <lambdabot>  [8]
19:32:40 <littledan> heh
19:33:17 <dons> my goal today is to get a .ps.gz to the top of programming.reddit.com
19:33:24 <dons> its in #2 currently. can we get there!!
19:33:37 <dons> mod mod !
19:33:40 <monochrom> what is in the .ps.gz ?
19:33:40 <dons> up up!
19:34:09 <dons> monochrom: deriving programs from specs  via equational reasoning
19:34:17 <littledan> this looks like a really vague way to program, though I guess it must not be
19:34:29 <dons> its basically how haskell programs are written though
19:34:43 <dons> you start with the super-clean, don't-care-about-efficiency, correct versoin
19:34:51 <dons> then optimise via equational transformatoins
19:34:52 <monochrom> ?data ForCond x = x ::: x
19:34:53 <lambdabot> Unknown command, try @list
19:34:56 <littledan> yeah, but pattern matching on ++ ?
19:35:02 <littledan> I shoudl finish it first
19:35:28 <dons> its really one of the corner stones of development in haskell.
19:35:35 <dons> should be taught more widely, than just at oxford :}
19:35:51 <monochrom> People hate correctness. You know that?
19:36:10 <dons> our industry sucks. let's fix it!
19:36:15 * dons channels shapr
19:36:19 <dons> boing!
19:37:08 <dmwit> ForCond x === (x,x)?
19:38:05 <monochrom> Yes. The plan is to write "a>0 ? "Good" ::: "Bad"
19:38:32 <dons> its sad that equational reasoning isn't even taught at most unis.
19:38:36 <dmwit> Hoo hoo hoo!
19:38:57 <littledan> dons, what is equational reasoning?
19:39:08 <ddarius> littledan: Replacing equals with equals.
19:39:32 <monochrom> map f . map g = map (f . g)   for example
19:39:34 <dons> and in this context, using that as a method for transfroming programs based on equalities
19:40:43 <monochrom> Jeremy Gibbons is good.
19:41:02 <littledan> oh, I didn't know there was a word for that...
19:41:22 <dons> yeah. really good. those oxford math guys have a bit of a monopoly on the haskell ethos.
19:42:40 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/9a4a844e63d6feed   yours truly learned that from Bird's papers (there is a mistake but it's mine).
19:42:42 <lambdabot> Title: problems with IO - comp.lang.functional | Google Groups, http://tinyurl.com/y32pju
19:42:48 <ddarius> Well it's kind of helpful with Richard Bird there.
19:43:24 <littledan> but how could this program derivation be decidable in the general case?
19:43:58 <monochrom> not intended to be decidable
19:44:12 <dons> nah, though there's some work on 'automating the bird-meertens formalism'
19:44:20 <dons> see nipkow. but that's um ,.... isabelle :-)
19:45:16 <monochrom> mechanize what you can. heuristize the rest, or even brute-force it. "human intelligence" is just a special case of heuritize and brute-force.
19:45:16 <ddarius> Hinze does good stuff with program derivation too.
19:45:33 <dons> yeah. in particular, with data structure stuff. him and Okasaki
19:45:33 <littledan> oh, I thought this was supposed to be the basis of a programming language, but it's more for thinking about compiler optimizations, sorta
19:45:40 <ddarius> monochrom: A lot of people seem to disagree with that last sentence.
19:45:45 <dons> littledan: optimiations, transformations, derivatoins, yes.
19:45:51 <monochrom> Yeah, Bird, Gibbons, Hinze, ... all belong to the same gang.
19:46:19 <dons> littledan: in fact, the recent stream fusion stuff is all about equational reasoning. and ghc even has an extension whereby you can specify equations in the src, to extend the optimiser on the fly!
19:46:25 <monochrom> ddarius: That is why those people have not made progress in programming.
19:46:44 <dons> RULE forall f g . map f . map g = map (f.g) -- equational reasoning as optimisation, in ghc's rewrite rules
19:47:28 <dons> but forget it if you've abandoned referential transparency in your code.
19:47:41 <josiah> Hello
19:47:44 <dons> when f x == f x doesn't hold, abandon all hope.
19:48:06 <dons> hey josiah. welcome
19:48:48 <josiah> I am new to Haskell, and am having some very basic problems in getting some example code to work. Namely, GHC seems to hang.
19:48:52 <ddarius> map f . map g = map! f . map g is the best you can hope for (where map! writes over it's list)
19:48:53 <dolio> Heh, that reminds me of a recent comp.lang.functional post...
19:49:17 <dons> josiah: how so?
19:49:20 <dolio> A guy asked if exceptions and non-termination were allowed by 'pure' functional languages.
19:49:21 <dons> ?paste <--
19:49:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:49:23 <dmwit> josiah: We'll need more information.
19:49:31 <dons> dolio: heh.
19:49:37 <josiah> Well, I can give you the output and source code.
19:49:42 <dons> yeah, we restrict ourselve to terminating recursive programs only
19:49:44 <josiah> First, the output
19:49:49 <josiah> C:\data\code\other\haskell\glut>ghc --make HelloWindow.hs
19:49:50 <josiah> [1 of 1] Compiling Main             ( HelloWindow.hs, HelloWindow.o )
19:49:52 <dons> josiah: stick it on paste.
19:49:56 <ddarius> You can generate all the exceptions you want, you just can't catch them.
19:49:57 <dolio> And one of the responses was, "don't listen to these other guys, in scheme you can use continuations to have the same function return different values for the same arguments.'
19:50:01 <monochrom> littledan: It is also a programming language and a programming methodology. Squiggol can be translated to Haskell 1-1. One can also do the derivation by hand or by human-computer combination "CAD".
19:50:29 <josiah> I'm not sure what stick it on paste means. I'm also new to IRC.
19:50:41 <dons> ?paste <--
19:50:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:50:43 <dons> hpaste.org
19:50:48 <dons> :-)
19:50:50 <sorear> josiah: rule #1: don't paste anything long directly into the channel
19:51:09 <sorear> josiah: where 'long' is min(months_here / 2, 5)
19:51:14 <dolio> I guess his position was that the implicit continuation argument, if you think of Scheme that way, lets you call such a thing pure.
19:51:39 <hpaste>  josiah pasted "(no title)" at http://hpaste.org/1731
19:51:41 <ivanm> is the IO monad the only one that allows (implicit) side effects?
19:51:51 <josiah> http://hpaste.org/1731
19:51:53 <sorear> ivanm: No.
19:51:56 <dmwit> ivanm: No, most of them do.
19:52:01 <ivanm> oh, OK
19:52:04 <ivanm> thanks
19:52:20 <_frederik_> ivanm: what do you mean by implicit?
19:52:30 <sorear> josiah: hmm, do you need to show the window?
19:52:52 <josiah> Well, I want it to compile at all first
19:52:52 <ivanm> _frederik_: well, with the IO Monad, you can print stuff to file/standard out/etc, as well as return a value...
19:53:01 <ivanm> which the calling function can then just extract out
19:53:24 <josiah> As far as I know, the code is fine since I just copied it from a web page.
19:53:30 <monochrom> Is it obvious that before one can discuss referential transparency, one should define equality, and there are a variety of definitions leading to a variety of conclusions?
19:54:26 <littledan> yes, if that's directed at me
19:54:32 <josiah> The problem has occured for other code too, but that was just a program I had at hand that exhibited the problem.
19:54:52 <monochrom> Oh, that one is directed to the collective.
19:54:52 <ivanm> josiah: maybe the indentation?
19:55:25 <ivanm> josiah: for the functions with "do" statements, alighn them all up so that they all start underneath each other
19:55:37 <ivanm> ignore that
19:58:24 <moozilla> How come something like this doesn't work
19:58:52 <josiah> What is interesting is that GHC hangs completely, and when I run the program in GHCi and type main it says that it is loading GLUT etc. and opens a window, but nothing is drawn to the window.
19:59:52 <moozilla> showNum n = putStrLn ("test: " ++ show n)
19:59:53 <moozilla> map showNum [1..5]
19:59:54 <josiah> If I kill GHC when it is hung, then an executable is created named HelloWindow.exe.
20:00:17 <ddarius> moozilla: It does work, it just doesn't do what you think it does.
20:00:36 <moozilla> It gives an error
20:00:38 <littledan> moozilla, to make the program do anything, you have to sequence the IO actions
20:00:42 <ddarius> :t let showNum n = putStrLn ("test: "++show n) in map showNum [1..5]
20:00:51 <lambdabot> [IO ()]
20:00:58 <josiah> If I run the executable that was created, then it behaves in the same way as when interpreted.
20:01:00 <monochrom> why not mapM_ showNum [1..5]
20:01:03 <ddarius> :t let showNum n = putStrLn ("test: "++show n) in mapM_ showNum [1..5]
20:01:05 <lambdabot> IO ()
20:01:38 <moozilla> I have another idea
20:01:42 <ivanm> josiah: when I run it, I get a blank window
20:01:49 <ivanm> blank as in the whole screen is black
20:01:58 <ivanm> but ghc doesn't hang...
20:02:12 <ivanm> ghci quits when I close the window, but otherwise seems to be fine
20:02:17 <littledan> moozilla, have you read about monads?
20:02:21 <moozilla> Yeah
20:02:33 <josiah> Maybe it is a problem just on my computer?
20:02:44 <ivanm> you do have glut installed, don't you?
20:02:45 <josiah> GHC definitely ihangs for me
20:03:01 <josiah> Yes, GLUT is installed.
20:03:13 <josiah> A window is created for me.
20:03:16 <ivanm> what's it meant to show?
20:03:24 <ivanm> because I just get an all-black window
20:03:43 <moozilla> What I'm trying to do is given a list of numbers display something like this:
20:03:44 <moozilla> 1 factorial is 1
20:03:46 <moozilla> 2 factorial is 2
20:03:46 <lispy> josiah: you're experimenting with HOpenGL?
20:03:47 <moozilla> 3 factorial is 6
20:03:53 <josiah> I imagine it should show a set of points
20:04:04 <ivanm> moozilla: try mapping the who operation, then using lines
20:04:05 <lispy> josiah: have you seen the nehe-tuts in haskell?
20:04:10 <lispy> ?where nehe-tuts
20:04:10 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
20:04:18 <josiah> I'm experimenting with Haskell, and intend to use OpenGL with it.
20:04:19 <moozilla> who operation?
20:04:22 <josiah> So, yes?
20:04:29 <dons> woo. ps.gz #1 on programming.reddit.com
20:04:34 <monochrom> s/who/whole/   I guess
20:04:40 <josiah> I don't know if there are other bindings than HOpenGL.
20:04:42 <dons> the end of the universe is delayed for another 6 months.
20:04:48 <ivanm> showNum n = "test: " ++ show n; putStrLn . lines . map showNum $ [1..5]
20:05:07 <ivanm> :t let showNum n = "test: " ++ show n in putStrLn . lines . map showNum $ [1..5]
20:05:10 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
20:05:10 <lambdabot>       Expected type: [a] -> String
20:05:14 <lispy> josiah: okay, well those examples in the nehe tutorial are verified to work on several machines and OSs so try them...if they don't work you may have a configuration problem
20:05:32 <monochrom> This will drive lots of programmers crazy, dons. :)
20:05:33 <lispy> josiah: if they do work, then maybe you have a bug in your example program
20:05:43 <dons> monochrom: let's hope.
20:05:49 <ivanm> dons: what's this?
20:05:53 <dons> oh, down mod. back to #2. easy come, easy go.
20:06:02 <littledan> moozilla, what you have to do is explicitly sequence and compose your IO actions. When you use map, there is no defined order
20:06:05 <monochrom> See? They hate it.
20:06:19 <dmwit> dons: Ousted by WikipediaFS.
20:06:26 <dons> damn them!
20:06:26 <syntaxfree> in a nutshell, what's the relationship between a monad and a monoid again?
20:06:28 <monochrom> They hate everything that says "here is a bugless way to program but you have to do math"
20:06:34 <syntaxfree> (I know the definitions and the laws)
20:07:00 <littledan> moozilla, mapM_ is like map but it puts each action in order, ignoring the results. This is what you want
20:07:15 <moozilla> Okay, I'll try that
20:07:48 <monochrom> The most obvious retort they bring out is "this is Cathedral; in RL you go Bazaar, no one nails down the spec first because the next minute it changes"
20:09:12 <monochrom> Maybe you can position it as "this is one good way to do code optimization, and no we are just aiming at best effort not completeness", but then maybe they'll reply "ok good for you".
20:09:24 <dons> yeah, I wouldn't write entire programs this way
20:09:31 <dons> but I sure would optimise using this as the basic method
20:09:37 <monochrom> The thing is, well, I would. :)
20:09:47 <dons> start with naive but correct, optimise with equations.
20:09:59 <dons> people should at least be aware that this is a technique. :}
20:10:14 <olsner> why use f.g.a = f(g(a)) instead of either f g a = (f g) a = f(g,a) or simply f(g(a))?
20:10:17 <moozilla> littledan: Awesome, thanks
20:10:23 <josiah> I just got the examples from: darcs get http://projects.codersbase.com/repos/nehe-tuts
20:10:25 <lambdabot> Title: Index of /repos/nehe-tuts
20:10:31 <dons> olsner: all different.
20:10:34 <josiah> The first two work at least
20:10:38 <lispy> josiah: great
20:10:42 <josiah> hmm
20:10:49 <dmwit> olsner: f . g . a /== (f g) a
20:11:03 <dmwit> olsner: And /== f (g, a)
20:11:09 <littledan> olsner, in the bird-meertens notation . is defined differently
20:11:12 <ddarius> syntaxfree: A monoid is a set, a monad is a functor.
20:11:14 <littledan> err, that was for dmwit
20:11:24 <olsner> that second example was juxtaposition and not x.y - i.e. haskell-ish
20:11:25 <dmwit> Oh, sorry.
20:11:27 <dons> (f . g) a == f (g a)
20:11:48 <ddarius> That said, a monad is a monoid object in Cat.
20:12:35 <syntaxfree> ddarius: hmm. Haskell monoids aren't really monoids, then?
20:13:08 <ddarius> syntaxfree: They are monoid objects in the category of Haskell types and functions (assuming the laws hold).
20:13:12 <olsner> ah, okay, it is a convention in the Bird-Meertens Formalism then
20:13:38 <monochrom> Oh I see your problem with the notation of the paper.  "." is fun app, "o" is fun comp.  Haskell "(f.g) a" = Squiggol "(fog).a".  Hope this helps.
20:13:40 <syntaxfree> a monoid is a set *with* an operation?
20:13:57 <syntaxfree> . is fun app in the lambda calculus. that's where they get it from.
20:14:08 <ddarius> syntaxfree: Yes, I was being lazy.
20:14:21 <monochrom> Dijkstra championed writing "sin.x" instead of "sin x".
20:14:26 <josiah> What I wonder is, "Why did those examples not hang when my code did?"
20:14:38 <syntaxfree> so what's the monoidal operation of a monad?
20:14:50 <syntaxfree> monochrom: why?
20:14:54 <josiah> All 12 compiled and ran fine for me.
20:14:56 <ddarius> join : T o T -> T
20:15:07 <syntaxfree> ah, yes, join.
20:15:14 <syntaxfree> in Haskell, join is defined in terms of bind, yes?
20:15:23 <sorear> Yes.
20:15:25 <syntaxfree> (I do know join is a fundamental operation in cat theory monads)
20:15:29 <syntaxfree> @src join
20:15:29 <lambdabot> join x =  x >>= id
20:15:30 <monochrom> There are many factors. The main one is "it's an operator, immoral to leave it blank".
20:15:57 <sorear> syntaxfree: you missed it yesterday - huge debate incl. people bashing the intelligence of economists-in-general
20:15:59 <ddarius> syntaxfree: Also, a monoid can be viewed as a 2-monad and is also related to monads simply from how monads are related to all algebras.
20:16:08 <littledan> is there something like @src that can be used from ghci/
20:16:13 <littledan> ?
20:16:14 <sorear> No.
20:16:21 <ddarius> GOA?
20:16:21 <sorear> the best you'll get is :info
20:16:23 <syntaxfree> sorear: the intelligence of economists-in-general is quite bashable, but not for the reasons most people think.
20:16:35 <littledan> I miss that
20:16:38 <lispy> josiah: cool, well so maybe your previous example has a bug?
20:16:40 <syntaxfree> basically, the bar is set too low. We let pretty much anyone get away with calling themselves an economist.
20:16:54 <monochrom> String is the stereotypical monoid.  ++ is the monoid operator.  Note (a++b)++c = a++(b++c)
20:17:01 <josiah> OK. I have another example of code that causes GHC to hang for me. This time there is no OpenGL involved.
20:17:04 <syntaxfree> The current state of the science affords _and_ necessitates a much higher bar.
20:17:17 <sorear> @paste
20:17:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:17:21 <syntaxfree> just pick up a random issue of the Journal of Economic Theory.
20:17:26 <hpaste>  josiah pasted "(no title)" at http://hpaste.org/1732
20:17:34 <monochrom> Monoid is not intended to be deep. Think of it as a design pattern! Something totally shallow and we give it a name.
20:17:41 <syntaxfree> it's scary that most people with a doctorate in economics can't even read one of these to the fullest, let alone write something of that worth.
20:18:03 <syntaxfree> Well, Haskell monoids aren't deep, I know.
20:18:13 <syntaxfree> I'm thinking of writing a monad pre-tutorial explaining Haskell functors.
20:18:18 <ddarius> Monoids are really simple things.
20:18:22 <sorear> josiah: also look at 'signum'
20:18:24 <syntaxfree> I could then follow up with monoids.
20:18:27 <sorear> > signum 3.2
20:18:30 <syntaxfree> (Haskell monoids)
20:18:32 <lambdabot>  1.0
20:18:42 <syntaxfree> I was more interested in the cat theory relation between monoids and monads.
20:18:56 <ddarius> There is little difference between monoids in Haskell and monoids in abstract algebra.
20:19:02 <sorear> *Main> main
20:19:02 <sorear> 1.570796326794897
20:19:07 <sorear> works fine for me
20:19:08 <syntaxfree> anyway, I know monoids are these simple structures.
20:19:26 <syntaxfree> I can read source code and Haddock documentation. I'm not *that* much of an idiot.
20:19:27 <sorear> @bug
20:19:27 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:19:39 <monochrom> I theorize that josiah's ghc installation is glitched.
20:19:40 <andygill> does anyone know how tags work on darcs? Can I tag a version (specific set of patches)?
20:20:00 <josiah> signum?
20:20:05 <syntaxfree> andygill: I'm not saying this channel is inappropriate for that, but I believe there's a #darcs
20:20:21 <andygill> Good point..
20:20:23 <monochrom> Sorry syntaxfree
20:20:38 <josiah> I see. I rewrote signum with the sign function.
20:20:56 <olsner> hmm... so this "list catamorphism" stuff is foldl, for commutative binary operators?
20:21:19 <olsner> ... or am I thinking associative
20:21:21 <dino-> andygill: You can tag, yes.
20:21:31 <lispy> andygill: http://www.darcs.net/manual/node6.html#SECTION00634000000000000000
20:21:34 <lambdabot> Title: Best practices, http://tinyurl.com/2yrexg
20:21:43 <ddarius> olsner: Probably associative and in that case foldr==foldl more or less, but a catamorphism is a foldr.
20:21:57 <dino-> The tag is on the whole tree and depends on all the patches up to that point.
20:22:01 <josiah> That is fine and well, but for some reason GHC hangs on this code for me but not for others. Could it be because I am using a dual core machine?
20:22:22 <syntaxfree> it'd be a fun, if pointless, project to write a Squiggol-to-Haskell compiler.
20:22:51 <dino-> From the online manual: http://darcs.net/manual/node6.html#SECTION00634000000000000000
20:22:53 <lambdabot> Title: Best practices
20:23:01 <ddarius> GHC has compiled stuff for 16 core machines...
20:23:27 <littledan> syntaxfree, I thought we just said that's undecidable in the general case
20:23:37 <sorear> ddarius: Lambdabot has run on a 16 core machine.  > included.
20:23:39 <andygill> Thanks for the pointers.
20:23:40 <monochrom> GHC has compiled itself for 16 core machines. :)
20:23:43 <dons> for 40 cpu machines too.
20:23:52 <monochrom> Yeah, ask dons :)
20:23:53 <ddarius> littledan: It would be trivial.
20:24:06 <littledan> oh, then I'm really misunderstanding this paper
20:24:24 <sorear> dons is no stranger to this - he administers serenity.cse.unsw.au, the aforementioned 16 core box
20:24:31 <josiah> What could be going wrong then?
20:24:32 <syntaxfree> littledan: oh. nevermind.
20:24:49 <monochrom> Translating from Squiggol notation to Haskell notation is straightforward.  Program derivation is another story and invariant under change of notation.
20:24:58 <dons> so yeah, more cores == no problem. josiah, if you're still stuck, perhaps ask on haskell-cafe@ with details about the program, the libraries, the ghc versoin and the operating system details.
20:25:01 <syntaxfree> I haven't seen Bird-Merteens formalism proper.
20:25:07 <dons> there may be someone with a similar machine who can test.
20:25:12 <syntaxfree> I've seen the version that Erik Meijer uses in the Bananas series.
20:25:23 <dons> syntaxfree: google for 'bird-merteens' on scholar.google.com
20:25:28 <syntaxfree> sp. "FP with bananas, lenses, etc . etc."
20:25:34 <dons> there's been books(!) on it.
20:25:42 <syntaxfree> dons: I have a good idea of what Bird-Merteens formalism is :)
20:25:51 <josiah> Is haskell-cafe another irc group?
20:25:59 <jcreigh> josiah: no, a mailing list
20:26:02 <syntaxfree> I'm just saying I've seen a specific dialect/heir of it.
20:26:10 <sorear> josiah: try compiling with -dcore-lint -debug and running with +RTS -DS
20:26:17 <sorear> josiah: max sanity checking
20:26:29 <jcreigh> josiah: http://www.haskell.org/mailman/listinfo/haskell-cafe
20:26:30 <lambdabot> Title: Haskell-Cafe Info Page
20:26:32 <syntaxfree> the one that's full of [(xs, f)]-like symbols.
20:26:43 <monochrom> Up to notation change, BMF is equivalent to bananas lenses etc.
20:26:52 <syntaxfree> Which I don't believe is Bird-Merteens proper since it wasn't a paper by Bird or Merteens.
20:26:59 <syntaxfree> but it's some heir of it, anyway.
20:27:26 <dmwit> ?pl \f (a, b) -> (f a, f b)
20:27:27 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
20:27:33 <syntaxfree> anyway, I read that entire paper, and even understood a lot of it :)
20:28:23 <dmwit> ?pl \f -> (f a, f b)
20:28:23 <lambdabot> liftM2 (,) ($ a) ($ b)
20:28:31 <scodil> is there anything like gmake's -j to go along with ghc's --make option?
20:28:38 <josiah> Running with -dcore-lint -debug produces no further output and still hangs.
20:29:39 <syntaxfree> ?pl \(a, b, c, d) -> c
20:29:40 <lambdabot> (line 1, column 7):
20:29:40 <lambdabot> unexpected ","
20:29:40 <lambdabot> expecting letter or digit, operator or ")"
20:29:40 <lambdabot> ambiguous use of a non associative operator
20:29:54 <syntaxfree> ?
20:30:05 <syntaxfree> ?pl \(a,b) -> a
20:30:06 <lambdabot> fst
20:30:09 <dons> scodil: nope. you can use ghc -M to dump a makefile out though, that will work with -j
20:30:16 <syntaxfree> ?pl \(a,b,c) -> a
20:30:17 <lambdabot> (line 1, column 6):
20:30:17 <lambdabot> unexpected ","
20:30:17 <lambdabot> expecting letter or digit, operator or ")"
20:30:17 <lambdabot> ambiguous use of a non associative operator
20:30:30 <syntaxfree> ?pl f (a,b,c) = c
20:30:30 <lambdabot> (line 1, column 11):
20:30:30 <lambdabot> unexpected "="
20:30:30 <lambdabot> expecting variable, "(", operator or end of input
20:30:31 <scodil> ah cool. that's close enough
20:30:33 <scodil> thanks
20:30:42 <syntaxfree> ?pl \(,,) a b c -> c
20:30:42 <lambdabot> (line 1, column 3):
20:30:42 <lambdabot> unexpected ","
20:30:42 <lambdabot> expecting pattern
20:30:46 <syntaxfree> GRRRRRR.
20:30:50 <dmwit> :t \f -> f &&& f
20:30:53 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
20:31:02 * syntaxfree goes into a dutch fugue.
20:31:19 <dons> ?pl \f -> f &&& f
20:31:19 <lambdabot> join (&&&)
20:31:22 <dons> oh nice.
20:31:24 <josiah> When I try to compile with +RTS -DS it just spits out a list of RTS options.
20:31:26 <dons> ah obvious
20:31:33 <dons> though it understood &&& for a second
20:31:38 <dons> thought.
20:31:59 <dmwit> :t join
20:32:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:32:08 <josiah> -DS isn't one of the options it allows.
20:32:16 <syntaxfree> > join [[2,3,4],[5,6,7]]
20:32:17 <lambdabot>  [2,3,4,5,6,7]
20:32:45 <syntaxfree> > join $ do { return (do { return 2})}
20:32:46 <lambdabot>   add an instance declaration for (Show (m a))
20:32:59 <syntaxfree> @type join $ do { return (do { return 2})}
20:33:01 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => m a
20:33:23 <dmwit> ?src join
20:33:24 <lambdabot> join x =  x >>= id
20:33:28 <syntaxfree> @type join $ do { return (do {putStr "Hey"; return 2})}
20:33:30 <lambdabot> forall a. (Num a) => IO a
20:33:31 <ddarius> :t join $ return $ return 2
20:33:33 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
20:33:43 <syntaxfree> @type join $ do { return (do {putStr "Hey"; return (2 :: Int)})}
20:33:44 <lambdabot> IO Int
20:33:48 <olsner> hmm... why are lookup and findWithDefault not consistently named?
20:33:53 <syntaxfree> > join $ do { return (do {putStr "Hey"; return (2 :: Int)})}
20:33:55 <lambdabot>  <IO Int>
20:34:08 <syntaxfree> > unsafePerformIO $ join $ do { return (do {putStr "Hey"; return (2 :: Int)})}
20:34:09 <lambdabot>   Not in scope: `unsafePerformIO'
20:34:55 <ddarius> :t \m f -> join . fmap f $ m
20:34:57 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
20:35:57 <josiah> Thanks for your help everyone.
20:36:03 <josiah> \quit
20:36:54 <ddarius> This was a day meant for me to actually read my novel.
20:37:08 <syntaxfree> you're writing one?
20:37:51 <syntaxfree> I'm thinking now that I have graphviz I should begin drawing ways of shoehorning together all the hair-thin plots I come up with and string them together into a proper novel.
20:38:15 <ddarius> syntaxfree: It wouldn't be all that enjoyable for me if I had written it.  No, Chuck Palahniuk wrote it.
20:38:20 <syntaxfree> It'll end up being this baroque universe, but critics & the public tend to love huge yet consistent baroque universes.
20:38:29 <syntaxfree> the name doesn't ring a bell.
20:38:39 <ddarius> Author of "Fight Club"
20:39:43 <gavino> hm
20:39:52 <gavino> http://www.youtube.com/watch?v=XhgVHTVi_h4
20:40:31 <syntaxfree> the fight club is a thoroughly forgettable movie.
20:40:33 <hpaste>  dmwit pasted "I'm new at class/instance declaration" at http://hpaste.org/1733
20:40:47 <kc5tja> heh, I loved that movie.
20:41:14 <syntaxfree> and I *like* the first Matrix movie.
20:41:22 <syntaxfree> so I'm not an eurosnob or anything :)
20:41:29 <Adamant> FIght Club was a great movie.
20:42:41 <monochrom> dmwit: I think one of the glasgow extensions allow it.
20:43:08 <gavino> fight club zzzzz
20:43:12 <gavino> matrix++
20:44:34 <desp> Fight Club is primarily a book.
20:44:47 <desp> which is why ddarius said "wrote".
20:45:08 <ariks> happy makes me happy.
20:45:11 <ariks> i'm so witty
20:45:39 <dons> :)
20:45:45 <dons> how does 'frown' make you feel?
20:45:48 <dons> ?where frown
20:45:49 <lambdabot> I know nothing about frown.
20:45:52 <dons> grr
20:45:56 <dons> ?google frown parser generator haskell
20:45:59 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/frown/index.html
20:45:59 <lambdabot> Title: Frown - an LALR(k) parser generator for Haskell
20:46:03 <ozzilee> Does Haskell have built-in serialization?
20:46:09 <dons> ?where+ frown http://www.informatik.uni-bonn.de/~ralf/frown/index.html
20:46:09 <lambdabot> Done.
20:46:12 <dons> ozzilee: yeah, Read/Show
20:46:14 <jcreigh> ozzilee: yeah, Read/Show
20:46:22 <dons> or you can use Data.Binary for high performance serialisation
20:46:27 <dons> ?hackage binary
20:46:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
20:46:29 <dons> here ^^
20:46:32 <dmwit> Wow, that was eerily identical.
20:46:33 <kc5tja> jcreigh: Quickest cut-n-paste in the west, I tell ya...
20:46:34 <dons> read/show is simplest though
20:46:46 <dons> heh
20:46:53 <desp> is there some sort of quote lambdabot should say in the event of identical speakage?
20:47:03 <ddarius> Oh god.
20:47:03 <ozzilee> Heh thanks. I'll look into that.
20:47:04 <dons> jcreigh and I approximate each other in the limit.
20:47:05 <kc5tja> @quote stereo
20:47:06 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:47:13 <scodil> how do you catch pattern match exceptions? 'finally' isn't catching them
20:47:23 <desp> he should do that automatically.
20:47:31 <ddarius> @hoogle catch
20:47:31 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
20:47:32 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
20:47:32 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
20:47:35 <dons> scodil: Control.Exception.handle/catch
20:47:39 <ddarius> Use the Control.Exception stuff
20:47:41 <littledan> the bird-meertens formalism looks sorta like generalized partial evaluation
20:47:45 <scodil> ah ok. thanks
20:47:50 <littledan> is that inaccurate?
20:48:01 <jcreigh> kc5tja: yeah, I have a script running that looks for messages that looks like questions, and then a reply to that question. if the reply is on a certain list of nicks, it automatically echos. :P
20:48:09 <ddarius> littledan: It sounds inaccurate.
20:48:11 <jcreigh> (not really)
20:48:50 <kc5tja> jcreigh: Sounds reasonable.  :D  And believable.  It's written in Haskell too, right?
20:48:56 <kc5tja> j/k
20:49:07 <ddarius> Of course you're kidding.  It's written in Perl.
20:49:23 <kc5tja> ddarius: Not in Common Lisp?
20:49:27 <monochrom> "BMP looks like generalized ___" is a tautology. :)
20:49:36 <littledan> oh, I guess that's true
20:49:39 <kc5tja> Wow.  What a wonderful way to open a song.
20:49:50 <kc5tja> 'I've been chasing ghosts -- and I don't like it!'
20:50:04 <jcreigh> kc5tja: well, it *could* be done. I'm slightly tempted now, actually. :)
20:50:06 <syntaxfree> for one, BMF stops short of generalized recursion.
20:50:25 <littledan> BMP looks like generalized deodorant
20:50:43 <kc5tja> BMP looks like a generalized line of undergarments.
20:51:23 <hpaste>  dons pasted "Catching pattern match errors" at http://hpaste.org/1734
20:51:29 <dons> scodil: exapmle ^^
20:51:41 <monochrom> Another true example. "BMP looks like generalized testing". Proving is generalized testing.
20:51:48 <syntaxfree> ?unpl (,,,)
20:51:48 <lambdabot> (,,,)
20:51:59 <dmwit> monochrom: Thanks.
20:52:13 <syntaxfree> monochrom:  I'll never understand why people think unit testing is a good substitute for program verifiability.
20:52:14 <ddarius> syntaxfree: pl's parser just doesn't support n-tuples for n>2
20:52:21 <dolio> littledan: Skimming through the article, it appears to just be programming in a style you might come up with if you spent too much time studying the output of pl.
20:52:24 <kc5tja> BMP looks like a generalized industry failure.
20:52:49 <ddarius> dolio: Squiggol -inspired- pl.
20:53:07 <dons> yeah
20:53:13 <ddarius> Albeit Category Theory was one of the inspirations of Squiggol.
20:53:13 <scodil> dons: ok what I don't get is... if you take the PatternMatchFail bit out, how is that different from 'bracket', which supposedly is what finally is built from?
20:53:15 <littledan> syntaxfree, because some programs can't be verified, and verification fails in most languages that aren't haskell
20:53:39 <syntaxfree> littledan: some programs can't be verified at all? is that a fact?
20:54:05 <syntaxfree> and isn't hoare logic supposed to cover procedural programmer's generalized buttocks?
20:54:06 <littledan> no, I can't back that up
20:54:10 <monochrom> syntaxfree: I can understand why. Actually I can see test-driven programming as a finite approximation to specifying and verifying. So I don't position them as rivals. Instead, I pretend to be friendly and say, "hey, look at what you do now, if you take that to the limit..." :)
20:54:19 <littledan> but it can be impractical
20:54:28 <kc5tja> I guess it depends on the scope of verification.  I'm a proponent of unit tests mostly, and even I don't believe the lack of verifyability claim.  :)
20:54:31 <littledan> or at least the tools don't exist yet
20:54:34 <syntaxfree> (is Hoare logic/predicate transformer calculus Turing-complete or something like that? I do know BMF isn't)
20:54:47 <dons> scodil: bracket is quite different
20:54:52 <kc5tja> Ah, now that I can believe.  :)
20:55:11 <ddarius> If you can stick (| |) together with [( )], then it is.
20:55:45 <monochrom> Hoare logic and predicate transformer calculus are Turing-complete, in fact Godel-complete.  BMF can be made Godel-complete once you throw in an unfold, which Bird does in "Algebra of Programming" and many papers.
20:56:03 <scodil> dons: right, but I can't see why bracket shouldn't catch PatternMatchFail exceptions
20:56:18 <hpaste>  dons annotated "Catching pattern match errors" with "bracket and finally" at http://hpaste.org/1734#a1
20:56:22 <monochrom> (I use Godel-complete when the subject is a theory rather than a programming language.)
20:56:46 <dons> scodil: bracket rethrows.
20:56:54 <dons>        (\e -> do { after a; throw e })
20:57:06 <dons> as does finally,          (\e -> do { sequel; throw e })
20:57:11 <monochrom> (I guess if you unify both as "proof systems" there is no difference.)
20:57:13 * syntaxfree luvs theoretical computer science.
20:57:15 <dons> you can perform an actoin prior to rethrowing
20:57:45 <scodil> yeah that's what I want... I'm using readline and it messes up the terminal, and I need to reset the terminal before exiting... basic resource-release type stuff
20:58:06 <dons> right. I've got code for that somewhere. let me see..
20:58:09 <dons> using 'finally'
20:58:37 <dons>     `finally`
20:58:37 <dons>     (do isXterm <- getsST xterm
20:58:37 <dons>         UI.end isXterm
20:58:51 <dons> so yeah, you can stick a finaliser in the `finally` code to clean up the terminal
20:59:15 <dons> so let's try that.
20:59:32 <syntaxfree> stupid question.
20:59:45 <syntaxfree> What is really *new* in "FP with bananas, lenses, envelopes and barbed wire"?
21:00:03 <ddarius> syntaxfree: With respect to...?
21:00:04 <syntaxfree> I mean, I read it as an introduction to this program construction calculus.
21:00:10 <dons> sc	works.
21:00:10 <monochrom> compared to... its predecessors?
21:00:14 <syntaxfree> With respect to the previous state of art.
21:00:23 <syntaxfree> As in, if the guy got published, he had new results, right?
21:00:34 <gavino> hm
21:00:36 <syntaxfree> or did he just charm the editors into publishing his BMF tutorial?
21:00:48 <monochrom> I don't actually know.
21:01:00 <syntaxfree> I pretty much read it as a program calculation tutorial.
21:01:01 <dons> scodil:    (case [] of (x:xs) -> putStrLn xs)
21:01:01 <dons>    `finally`
21:01:01 <dons>    (print "done ok")
21:01:10 <syntaxfree> I never stopped to think what it means as an actual research paper.
21:01:29 <monochrom> A research paper must contain much new stuff, yes.
21:01:55 <syntaxfree> it's such a great introduction, though.
21:02:04 <syntaxfree> maybe he was just putting forward a notation.
21:02:49 <dolio> Were all the various x-morphisms presented in previous papers?
21:03:24 <dons> syntaxfree: you're referring to "Functional programming with bananas, lenses, envelopes and barbed wire - group of 9 
21:03:28 <dons> E Meijer, M Fokkinga, R Paterson - Proceedings of the 5th ACM conference on Functional , 1991"
21:03:31 <dons> ?
21:03:32 <scodil> ok that works... this seems to be a GLUT thing. I'm bracketing glut's mainLoop, and the exception handler is not being called. maybe the haskell glut interface installs its own exception handler...
21:03:38 <dons> hehe, as "Cited by 319 "
21:03:41 <gavino> woa
21:03:42 <syntaxfree> if i recall correctly, he attributes every x-morphism to a previous reference.
21:03:46 <ddarius> syntaxfree: The authors say there newness is applying it to lazy FP.
21:03:59 <gavino> is y a h t best way learn haskell?
21:03:59 <syntaxfree> dons: hell, I cite it in informal conversation with young nubile women :)
21:04:08 <dons> hello gavino
21:04:09 <ddarius> The last paragraph of section 1.
21:04:22 <ddarius> dolio: No.
21:04:57 <ddarius> gavino: It depends.  I have no idea though, I haven't even read it.
21:04:59 <kc5tja> gavino: It's certainly helped me significantly.
21:05:02 <syntaxfree> dons: but yes, yes.
21:05:40 <monochrom> syntaxfree: If the author's own claim is to be trusted, it contains new stuff. Page 2 before section 2 lists how this paper extends previous work.
21:06:01 <ddarius> "The current version is PEARL-90, which was standardized in 1998"
21:06:35 <syntaxfree> monochrom: hmm. I must have somehow forgotten that.
21:06:44 <monochrom> For example BMP used just list and this paper shows how to do the same to all algebraic data structures.
21:06:48 <syntaxfree> or skipped the introduction into the juicy bits.
21:06:48 <gavino> now is it best to read SICP b4 that haskell tutorial?
21:06:55 <syntaxfree> monochrom: OH.
21:06:57 <gavino> or jump right into that tut?
21:07:01 <syntaxfree> yes, yes.
21:07:14 <syntaxfree> Of course. "FP with bananas" is *very* general.
21:07:19 <dons> its fun watching you work, gavino
21:07:43 <monochrom> Also it adds unfold, hylo, etc. to make the whole thing Turing-complete.
21:07:50 <syntaxfree> gavino: SICP is not a tutorial, it's a 6-month long exercise in torture.
21:07:51 <gavino> I am not meaning to be a bugger
21:07:56 <dons> gavino: i'd suggest next, "and haskell is not a lisp. correct?"
21:08:01 <syntaxfree> It's supposed to make you a strong man, but it requires testicles.
21:08:04 <gavino> no no
21:08:08 <ozzilee> Does anyone know where I could start looking if I wanted to call out to vi or emacs in the middle of an interactive Haskell program? For example, something like an email program that could go out to vi to edit messages.
21:08:18 <gavino> I read fisrt 20 pages, but fold left made my brain hurt
21:08:26 <dons> ah, even better!
21:08:33 * dons notes this down.
21:08:36 <kc5tja> gavino: SICP should be required reading no matter what.  I don't think it matters if you read it before or after -- either way, you'll learn something new.
21:08:37 <dons> ozzilee: yeah, got code for you. hang on.
21:08:43 <dons> ?protontorpedo
21:08:43 <lambdabot> what makes haskell more fun than say clisp?
21:08:44 <gavino> ok
21:08:47 <dons> hehe
21:08:48 <gavino> dons please
21:08:52 <dons> other great works of gavino.
21:08:53 <syntaxfree> @remember dons "and haskell is not a lisp. correct?"
21:08:54 <lambdabot> Done.
21:08:57 <gavino> give me a break I am trying to learn programming
21:08:57 <dons> ?protontorpedo
21:08:58 <lambdabot> no I cant read online for long my eyes get fuzzy
21:09:04 <gavino> :(
21:09:09 <gavino> I did get drunk few times
21:09:09 <syntaxfree> man, they made a protontorpedo bot!
21:09:14 <dons> gavino: cool. keep at it. at this rate you might get left fold by hmm, 2012
21:09:31 <kc5tja> And I read SICP in two weeks, cover to cover, but I've had extensive computer programming experience.  A total newbie is likely to find SICP thick with new concepts, BUT, it's well worth it if you can master it.
21:09:32 <syntaxfree> gavino = protontorpedo?
21:09:40 <syntaxfree> ?protontorpedo
21:09:40 <lambdabot> can haskell be used to develop databases?
21:09:46 <dons> yeah, and gschuett et 50 al.
21:09:46 <syntaxfree> hahahaaa
21:09:50 <syntaxfree> ?protontorpedo
21:09:50 <lambdabot> can haskell be used to develop databases?
21:09:55 <gavino> lol
21:09:58 <syntaxfree> pot luck!
21:10:00 <gavino> I am fameous
21:10:00 <syntaxfree> everyone pays me a beer.
21:10:03 <syntaxfree> ?protontorpedo
21:10:03 <lambdabot> does huge or ghc have more stuff?
21:10:09 <syntaxfree> hahaha
21:10:13 <gavino> lol
21:10:19 * syntaxfree goes on  a private window enjoy ?protontorpedo.
21:10:20 <gavino> ?protontorpedo
21:10:21 <lambdabot> that dude is selling u  a book
21:10:28 <gavino> ?protontorpedo
21:10:29 <lambdabot> is haskell able to outdo perl or python for web?
21:10:44 <dons> see, no need to even start. we already have a bot clone of you.
21:11:19 <dons> does it get disappointing when you're so well known, you're recognised immediately?
21:11:55 <scodil> so is the reason I can't catch exceptions thrown from inside the GLUT mainLoop because it crosses the C barrier? Or is there something else I need to do?
21:11:58 <syntaxfree> "so if I learn haskell i can make cool interactive websites  and get rich right?
21:12:01 <dons> just from the style, "I am fameous" or "I read fisrt 20 pages, but fold left made my brain hurt"
21:12:01 <syntaxfree> hahaaha
21:12:08 <dons> syntaxfree: that's cool, eh?
21:12:22 <gavino> I am trying to learn.
21:12:29 <gavino> I guess I pissed few people off.
21:12:32 <syntaxfree> "so is haskell a new and improved c"?
21:12:33 <gavino> how can I make amends?
21:12:35 <dons> heh.
21:12:40 <dons> gavino: nice try.
21:12:47 <dons> well, no, just boring.
21:12:50 <syntaxfree> gavino: first you get elected to the congress.
21:12:57 <syntaxfree> then you can make ammendments.
21:12:57 <gavino> hm
21:13:12 <merus> heh.
21:13:36 <dons> gavino: your credibility is so damaged, there's really not many options.
21:13:40 <syntaxfree> " wil I make mroe $$ than learning java or APL or smalltalk or
21:13:42 <merus> actually you can make amendments through something called a constitutional convention, but no one really knows what that would entail.
21:14:02 <dons> given that all we have online i reputation, and yours certainly precedes you , i'm not sure what you could do.
21:14:09 <syntaxfree> why isn't he banned or something?
21:14:12 <syntaxfree> ?karma protontorpedo
21:14:12 <lambdabot> protontorpedo has a karma of 0
21:14:16 <gavino> wow
21:14:19 <syntaxfree> ?karma dons
21:14:20 <lambdabot> dons has a karma of 145
21:14:24 <dons> syntaxfree: its a 2 second operation, so its fun to just wait :-)
21:14:30 <gavino> holy crap dons=jesus
21:14:30 <syntaxfree> ?karma syntaxfree
21:14:30 <lambdabot> You have a karma of 2
21:14:34 <gavino> lol
21:14:41 <gavino> ?karma gavino
21:14:42 <lambdabot> You have a karma of 0
21:14:45 <gavino> doh
21:14:50 <Cale> gavino: have a specific question?
21:14:53 <kc5tja> ?karma kc5tja
21:14:53 <lambdabot> You have a karma of 1
21:14:56 <gavino> yes
21:14:57 <kc5tja> Hah.  :)
21:14:58 <ddarius> @karma audreyt
21:14:59 <lambdabot> audreyt has a karma of 635
21:15:11 <gavino> has anyone done something like prevayler in haskell?
21:15:12 <dons> ddarius: audrey has a bot karma spammer ;-)
21:15:17 <dons> heh.
21:15:22 <gavino> audreyt is all time scorere WOW
21:15:22 <Cale> I don't know what prevayler is
21:15:35 <syntaxfree> Cale: it's a trap.
21:15:35 <gavino> an in memory database
21:15:39 <syntaxfree> @quote trap
21:15:39 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
21:15:47 <dons> syntaxfree: Cale knows.
21:15:57 <dons> I just can't believe gavino would even try.
21:15:59 <Cale> gavino: well, there's stuff like that in HAppS.
21:16:03 * dons laughs hysterically.
21:16:10 <monochrom> I recommend gavino to amend by stop talking and start working in solitude. Come back with results.
21:16:26 <gavino> yet my ignorance is why I coem here
21:16:31 <Cale> I'd rather answer programming questions though.
21:16:41 <olsner> so, is protontorpedo actually gavino quotes?
21:16:44 <syntaxfree> I recommend gavino to amend by paying us all monetary bribes to tolerate him.
21:16:50 <dons> gavino: come on. its a great game. do you have a specific question about programming?
21:16:50 <syntaxfree> everyone message them with their personal price.
21:16:53 <dons> please construct one.
21:16:59 <gavino> ok
21:17:09 <gavino> how do I create and save procedures in haskell?
21:17:16 <dons> ha! great!
21:17:19 <gavino> something liek defun in lisp
21:17:31 <merus> I wonder if programming questions are decidable.
21:17:32 <jcreigh> double x = x + x
21:17:35 <syntaxfree> dons: can you add new stuff to the protontorpedo bot easily?
21:17:36 <gmh33_> with mad haxx0r skillz
21:17:37 <dons> gavino: do you have a script, or is it just a style you can think in?
21:17:41 <dons> syntaxfree: yeah.
21:17:48 <gavino> script?
21:17:58 <monochrom> I wonder if programming questions are recursively enumerable
21:18:01 <gavino> ok
21:18:07 <dons> because the style changes so little over the last 3 or so years
21:18:08 <ddarius> monochrom: Sure they are.
21:18:18 <ddarius> monochrom: Every question in any language is.
21:18:18 <dons> i can't help but wonder if you have a fixed set of questions you permute from a script?
21:18:19 <Cale> I could believe these are honest questions, it's just a little misdirected, often :)
21:18:20 <gavino> I'll shut up now
21:18:24 <gavino> no
21:18:24 <syntaxfree> dons: it'd be a very smart script.
21:18:31 <gavino> I wish to learn to program on linux
21:18:40 <gavino> I wish to have my own company and make profits
21:18:40 <monochrom> Like "how do I add 0 numbers? how do I add 1 numbers? how do I add 2 numbers? how do I add 3 numbers? ..."
21:19:02 <dons> gavino: don't we all.
21:19:06 <gavino> I am curious how problems at my company would be solved in functional languages.
21:19:25 <olsner> monochrom: I challenge you to write a program that recognizes programming questions and only programming questions
21:19:27 <gavino> I read about some cool things, for example, tuplespaces
21:19:30 <gavino> lol
21:19:33 <dons> gavino: I know! as you said a couple of years ago, "Im wondering if there are uncharted business waters that haskell can enable"
21:19:33 <olsner> that's probably AI-complete
21:19:33 <syntaxfree> why do we feed the torlls?
21:19:37 <ddarius> Using some code from today:
21:19:38 <merus> profits don't yield good philosophy.
21:19:49 <dons> gavino: tuplespace is good. I like that
21:20:02 <Cale> gavino: Check out the Haskell wikibook, and let us know when you get stuck :)
21:20:06 <syntaxfree> why do we feed the trolls?
21:20:13 <ddarius> > [1..] >>= flip replicateM (' ':['a'..'z'])
21:20:15 <merus> syntaxfree, because they're hungry
21:20:15 <lambdabot>  [" ","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
21:20:16 <dons> syntaxfree: hang on. killing him off is too easy :-)
21:20:24 <monochrom> I think dons is taking a break from all the paper authoring last month. :)
21:20:34 <Cale> gavino: The simplest way to answer all these questions is to just learn the language, then you'll be able to decide for yourself what it would be useful for :)
21:20:45 <dons> Cale: you're so honourable.
21:20:55 <olsner> > let f (x:xs) = f xs; f [] = profit; in f [1..]
21:20:56 <lambdabot>   Not in scope: `profit'
21:20:56 <syntaxfree> > reverse  "?sllort eht deef ew od yhw"
21:20:58 <lambdabot>  "why do we feed the trolls?"
21:21:08 <dons> I wonder if it is possible gavino is a megamonad, fed on basic terms from foldoc?
21:21:09 <olsner> see! there's no profit in haskell
21:21:20 <gavino> ok
21:21:23 <gavino> Ill leave
21:21:29 --- mode: ChanServ set +o dons
21:21:29 <jcreigh> gavino: YAHT is good to start
21:21:31 <jcreigh> @where yaht
21:21:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:21:34 <jcreigh> too late
21:21:35 --- mode: ChanServ set -o dons
21:21:41 <dons> chanServ got him though.
21:21:41 <syntaxfree> he ran away!
21:21:45 <jcreigh> assuming he even cared.
21:21:47 <gmh33_> you scared him
21:21:54 <gmh33_> :P
21:21:55 <merus> dons is pretty scary ;)
21:22:06 <gmh33_> yeah, ask him a question about types, watch out!
21:22:07 <syntaxfree> dons: gavino answers people.
21:22:19 <syntaxfree> @kind Profit
21:22:21 <lambdabot> Not in scope: type constructor or class `Profit'
21:22:23 <dons> you can always tell if its gavino by a combination of "lsanca" domain, a set of fixed nicks he uses, and the random mispelling/lower case
21:22:29 <dons> also, the content is almost invariably the same.
21:22:46 <syntaxfree> what country is he in?
21:22:50 <gmh33_> my first name is Gavin :P
21:22:51 <syntaxfree> @quote trolls
21:22:51 * ddarius found that unusual.
21:22:51 <lambdabot> No quotes match. stty: unknown mode: doofus
21:22:52 <dons> but, blowing his cover neuters him fairly well.
21:22:55 <jcreigh> not there's anything *wrong* with lowercase. :)
21:22:58 <syntaxfree> @quote troll
21:22:58 <lambdabot> qwe1234 says: are you really this dense, or just trolling me?
21:23:17 <lispy> I LIKE LOWERCASE :)
21:23:24 <syntaxfree> ?quote wrong with
21:23:24 <lambdabot> No quotes for this person. My mind is going. I can feel it.
21:23:30 <syntaxfree> ?quote wrong
21:23:30 <lambdabot> metaperl says: Haskell is like the lady who never gets married because there is something wrong with every potential suitor
21:23:32 <jcreigh> SOME OF MY BEST FRIENDS ARE LOWERCASE. :)
21:23:36 <gmh33_> oh no, lispy's caps lock key is brokened
21:23:47 <kc5tja> i prefer UPPERCASE only for STANDARD-defined KEY words.  ;D
21:23:58 <ddarius> ?quote wrong.with
21:23:58 <lambdabot> metaperl says: Haskell is like the lady who never gets married because there is something wrong with every potential suitor
21:24:00 <dons> for his other great works, see http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
21:24:01 <lambdabot> http://tinyurl.com/mkqad
21:24:03 <sieni> gmh33_: surely you mean "brokerened"
21:24:12 <dons> scroll down to "A troll going "
21:24:18 <gmh33_> sieni: that's the one
21:24:20 <syntaxfree> ?remember 01:23 < lispy> I LIKE LOWERCASE :) 01:24 < gmh33_> oh no, lispy's caps lock key is brokened
21:24:20 <lambdabot> Done.
21:24:21 <dons> then its pretty easy to get a sense of his style.
21:24:29 <syntaxfree> ?quoted
21:24:29 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
21:24:34 <dons> and an informed irc channel is a troll-free channel
21:24:40 <jcreigh> speaking of upcase, does anyone else find the "functions/values must start with a lowercase letter" thing slightly annoying when wrapping C libraries? you end up with stuff like fOOBAR
21:24:55 <syntaxfree> dons: informedness is next to trollfreeness?
21:25:09 <lispy> jcreigh: well, iirc win32 lib has a nice convention for this
21:25:09 <dons> something like that. you can only fool part of the channel part of the time.
21:25:17 <monochrom> Yes, slightly annoying to begin lowercase.
21:25:27 <lispy> jcreigh: iirc they append c_ to all the imported indentifiers
21:25:38 <jcreigh> prepend, surely
21:25:43 <lispy> jcreigh: then they could mke the haskell version anything they wanted and only export taht
21:25:46 <syntaxfree> @quote prepend
21:25:47 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
21:25:51 <lispy> jcreigh: prepend yes
21:26:03 <syntaxfree> lispy: that sounds like gavino!
21:26:19 <olsner> @quote lisp
21:26:20 <lambdabot> mux says: "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
21:26:29 <syntaxfree> @quote lispy
21:26:29 <lambdabot> lispy says: it's like java, it gets cross on any platform :)
21:26:39 <syntaxfree> @quote lispy
21:26:39 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
21:26:57 <syntaxfree> @quote lispy
21:26:57 <lambdabot> lispy says: glguy: some of us just like to get bent
21:27:02 <syntaxfree> @quote lispy
21:27:02 <lambdabot> lispy says: someday when they read the murder note they'll link it to me by the mispellings
21:27:08 <syntaxfree> quite the character, this lispy.
21:27:09 * lispy doesn't remember saying some of these
21:27:25 <syntaxfree> @quote lispy
21:27:26 <lambdabot> lispy says: someday when they read the murder note they'll link it to me by the mispellings
21:27:32 <syntaxfree> @quote
21:27:32 <lambdabot> LeCamarade says:  Vi is to editing what Haskell is to hacking. And Emacs is like the C++ of editing.
21:27:38 <lispy> ?quote alarm clock
21:27:39 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
21:27:44 <lispy> hmm
21:27:46 <lispy> how do you search?
21:27:55 <dmwit> ?quote alarm\ clock
21:27:55 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
21:27:57 <jcreigh> @quote alarm.clock
21:27:58 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
21:27:59 <syntaxfree> @quote alarm
21:27:59 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
21:28:02 <syntaxfree> :/
21:28:10 <lispy> that's my best quote :)
21:28:16 <syntaxfree> @quote syntaxfree
21:28:17 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
21:28:19 <monochrom> hehe
21:28:19 <kc5tja> WTF?
21:28:23 <syntaxfree> @quote syntaxfree
21:28:24 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
21:28:27 <syntaxfree> @quote syntaxfree
21:28:28 <lambdabot> syntaxfree says: * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
21:28:44 <syntaxfree> bah, my quotes aren't any good.
21:28:46 <syntaxfree> @quote syntaxfree
21:28:46 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
21:28:55 <syntaxfree> @quote syntaxfree
21:28:56 <lambdabot> syntaxfree says: * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
21:29:00 * syntaxfree drops dead.
21:29:13 <monochrom> haha
21:29:19 <lispy> syntaxfree: i like your quote about left-associative $
21:29:31 <syntaxfree> @quote syntaxfree
21:29:31 <lambdabot> syntaxfree says: yes, The Wadlerman. the Prince of Funktions.
21:29:38 <syntaxfree> I like that one!
21:29:45 <syntaxfree> @quote syntaxfree
21:29:46 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
21:29:54 <syntaxfree> there's an older one I like
21:29:57 <syntaxfree> @quote Gnomes
21:29:58 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
21:29:58 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
21:29:58 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
21:30:02 <gmh33_> @quote gmh33
21:30:02 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
21:30:08 <gmh33_> ;)
21:30:11 <gmh33_> mine suck too :P
21:30:23 <olsner> @quote olsner
21:30:23 <merus> @quote merus
21:30:23 <lambdabot> No quotes match. Take a stress pill and think things over.
21:30:24 <lambdabot> merus says:  Mathematics is totally full of women.
21:30:29 <merus> ahaha
21:30:33 <merus> I don't remember saying that.
21:30:36 <merus> heh.
21:30:41 * olsner hasn't been quoted yet!
21:30:46 <kc5tja> So far, I've only had one good quote.
21:30:48 <kc5tja> @quote kc5tja
21:30:48 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
21:31:01 <jcreigh> oh, but that's a good one.
21:31:11 <gmh33_> lol
21:31:13 <syntaxfree> that's a good one.
21:31:16 <syntaxfree> @quote
21:31:16 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
21:31:21 <gmh33_> @quote gmh33
21:31:21 <lambdabot> gmh33 says: Haskell makes so much more sense now and all I did was figure out the typing thing
21:31:22 <kc5tja> jcreigh: Yeah, but it just shows I'm a whole lot less "with it" humor-wise than most others.  :)
21:31:28 <gmh33_> eh, that's the only one for that one
21:31:32 <gmh33_> @quote gmh33_
21:31:32 <lambdabot> 01:23 says: < lispy> I LIKE LOWERCASE :) 01:24 < gmh33_> oh no, lispy's caps lock key is brokened
21:31:33 <ozzilee> dons: I'm back, did you happen to find that code you mentioned?
21:31:44 <syntaxfree> @quote
21:31:44 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
21:31:59 <syntaxfree> @quote haskeel
21:31:59 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:32:04 <olsner> ... how else would one talk to someone?
21:32:09 <syntaxfree> @quote simon
21:32:10 <lambdabot> LoganCapaldo says: Haskell: "Simon Says" applied to programming
21:32:15 <kc5tja> Funny; "Money for Nothin'" is playing on Pandora now.  :)
21:32:30 <syntaxfree> @quote money
21:32:30 <lambdabot> sieni says: let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
21:32:45 <kc5tja> OK, I have to know...
21:32:51 <kc5tja> > let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
21:32:51 <monochrom> > let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
21:32:53 <lambdabot>  "\"$$$\""
21:32:54 <lambdabot>  "\"$$$\""
21:33:00 <kc5tja> nice.
21:33:00 <merus> @quote stereo
21:33:01 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
21:33:07 <syntaxfree> that's a classic.
21:33:12 <monochrom> @quote Syzygy-
21:33:13 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
21:33:17 <monochrom> @quote Syzygy
21:33:18 <lambdabot> No quotes match. Wrong!  You cheating scum!
21:33:21 <monochrom> @quote Syzygy.
21:33:22 <lambdabot> No quotes match. Do you think like you type?
21:33:24 <syntaxfree> I was there when that was pronounced.
21:33:25 <monochrom> @quote Syzygy-
21:33:25 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
21:33:29 <monochrom> @quote Syzygy-
21:33:30 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
21:33:30 <syntaxfree> @quote pirate
21:33:31 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
21:33:35 <syntaxfree> @quote dead
21:33:36 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
21:33:41 <syntaxfree> @quote dead
21:33:42 <lambdabot> syntaxfree says: * syntaxfree often uses (&) = flip (.)  for additional clarity.   <nmessenger> @src (->) (>>>)   <lambdabot> f >>> g = g . f   * syntaxfree drops dead.
21:33:46 <syntaxfree> @quote dead
21:33:46 <lambdabot> ghc says: internal error: Invalid object in processHeapClosureForDead
21:33:47 <monochrom> @quote dons.Syzygy
21:33:48 <lambdabot> No quotes match. My mind is going. I can feel it.
21:33:59 <syntaxfree> @quote shapr
21:34:00 <lambdabot> shapr says: I am hexed and vexed ;-)
21:34:07 <syntaxfree> @quote timtoady
21:34:08 <lambdabot> No quotes match. It can only be attributed to human error.
21:34:16 <syntaxfree> @quote wadler
21:34:16 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
21:34:52 <syntaxfree> @quote lisp
21:34:53 <lambdabot> ray says: some people claim everything is lisp. one time i was eating some spaghetti and someone came by and said "hey, nice lisp dialect you're hacking in there"
21:34:58 <scodil> if forcing a thunk throws an exception, which handler gets called, the one active when the thunk was created, or the one active when it was forced?
21:35:28 <fridim> I don't understand > (+2) map [1..10]
21:35:32 <monochrom> @quote Paris
21:35:32 <lambdabot> No quotes match. I've seen penguins that can type better than that.
21:35:37 <syntaxfree> oh noes. a valid question. there's a fun leak! fun is leaking into the void!
21:35:39 <fridim> why is it the same as  map (+2) [1..10]  ?
21:35:41 <gmh33> ? (+2) map [1..10]
21:35:47 <gmh33> > (+2) map [1..10]
21:35:48 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
21:35:57 <syntaxfree> @quote free
21:35:57 <lambdabot> monochrom says: "Software Faults for Free!"
21:36:00 <syntaxfree> @quote free
21:36:00 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
21:36:06 <syntaxfree> @quote free
21:36:06 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
21:36:09 <gmh33> > map (+2) [1..10]
21:36:10 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
21:36:17 <fridim> > (+2) `map` [1..10]
21:36:18 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
21:36:21 <syntaxfree> @quote map
21:36:21 <lambdabot> jcreigh says: it seems silly that map isn't (Functor f) => (a -> b) -> f a -> f b; what's the point of a rich type system if you don't use it?
21:36:22 <jcreigh> hey, guys, maybe go /msg if you want more @quote fun?
21:36:32 <syntaxfree> @quote map
21:36:33 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
21:36:36 <gmh33> back quotes make anything infix ;D
21:36:50 <fridim> what does "infix" mean?
21:36:51 <kc5tja> fridim: By definition, an infix operator is a dyadic function (a function with two arguments).  So a `f` b = f a b.  By extension, (+2) `map` xs = map (+2) xs
21:37:02 <monochrom> scodil: the one active when the thunk is forced.
21:37:06 <fridim> ok!
21:37:13 <jcreigh> fridim: 2 + 2 (+ is infix) f 2 2 (f is prefix)
21:37:20 <syntaxfree> otoh,
21:37:23 <gmh33> and 2 2 f is postfix
21:37:23 <syntaxfree> > (+) 2 2
21:37:25 <fridim> understood, thanks
21:37:25 <lambdabot>  4
21:37:32 <gmh33> > mod 10 3
21:37:34 <lambdabot>  1
21:37:38 <gmh33> > 10 `mod` 3
21:37:39 <lambdabot>  1
21:37:47 <gmh33> > 10 mod 3
21:37:48 <syntaxfree> > ((*) 2 ((+) 3 5))
21:37:49 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
21:37:49 <lambdabot>     I...
21:37:49 <lambdabot>  16
21:38:01 <kc5tja> syntaxfree: See, Haskell *IS* a kind of Lisp!  :)
21:38:07 <jcreigh> yes, many functions, such as div, elem, mod, etc. are usually written in the infix form with backticks.
21:38:09 <gmh33> syntaxfree: you just want your math to look like lisp with extra parens :P
21:38:24 <olsner> too bad backtick is Shift-Backtick,Space on my keyboard
21:38:28 <dons> sometimes I want infix syntax for ternary functions
21:38:29 <kc5tja> Those crazy Lispers were right!!
21:38:39 <jcreigh> dons: how would that work? Define two symbols?
21:38:39 <dons>            x `op n` y
21:38:45 <jcreigh> oh
21:38:51 <syntaxfree> > 10 `flip mod` 3
21:38:51 <lambdabot>  Parse error
21:38:52 <monochrom> OH!
21:38:58 <dons> infix expressions, basically
21:39:01 <syntaxfree> > 10 `(flip mod)` 3
21:39:01 <lambdabot>  Parse error
21:39:05 <jcreigh> yeah, that would be fun
21:39:26 <dons> its been proposed for H', but needs getting into GHC to get acceptance.
21:39:27 <gmh33> 10 `flip . mod` 3
21:39:28 <jcreigh> now you'd have to say x `foo` y where foo = op n
21:39:30 <syntaxfree> Infix data constructors are fun.
21:39:34 <dons> right.
21:39:36 <gmh33> > 10 `flip . mod` 3
21:39:37 <lambdabot>  Parse error
21:39:37 <dons> syntaxfree: we have those
21:39:39 <gmh33> doh
21:39:41 <syntaxfree> dons: I know!
21:39:46 <dons> syntaxfree: and infix classes!
21:39:51 <syntaxfree> dons: oh?
21:39:55 <jcreigh> oh, does Haskell' only accept things that are actually implemented?
21:39:59 <dons> yeah, once you show people x `foo bar` y
21:40:04 <syntaxfree> I used infix dacons, but not infix classes!
21:40:07 <dons> everyone seems to think tis very natural
21:40:26 <dons> I know I never used to accidentally write that, till I saw the proposal, now I sometimes just assume it exists :}
21:40:30 <syntaxfree> show me an example of infix typeclasses?
21:40:40 <kc5tja> I think it makes more sense if `foo bar` evaluates to a dyadic function, thus preserving the dyadic relationship.
21:40:40 <dons> find me a binary type class
21:40:46 <monochrom> Arrow!
21:40:48 <syntaxfree> Foo a b
21:40:50 <syntaxfree> ;)
21:41:09 <dons>  class a :=: b where
21:41:22 <dons> f :: (a :=: b) => a -> b
21:41:23 <jcreigh> kc5tja: more sense than...? (I agree; I think that's how it should work. but I don't see how it could work otherwise.)
21:41:31 <dons> liftA2 :: Arrow (~>)
21:41:35 <syntaxfree> what's the syntax?
21:41:39 <dons> => (a -> b -> c) -> (e ~> a) -> (e ~> b) -> (e ~> c)
21:41:41 <dons> :-)
21:41:45 <gmh33> squiggle arrow :O
21:41:49 <kc5tja> jcreigh: If I understood correctly, previous comments above indicated a desire to make it work for arbitrary arity.
21:41:56 <kc5tja> I probably misunderstood.
21:41:58 <dons> :k Int `Either` Bool
21:42:00 <lambdabot> *
21:42:04 <syntaxfree> WHAT?
21:42:14 <dons> :t Left 7 :: Int `Either` Bool
21:42:16 <gmh33> what's the squiggle arrow do, I haven't seen it before o_o
21:42:16 <lambdabot> Int `Either` Bool :: Either Int Bool
21:42:16 <syntaxfree> WAIT, WAIT, WAIT.
21:42:22 <syntaxfree> stop.
21:42:25 <syntaxfree> stop! that works?
21:42:30 <dons> gmh33: that's just a user defined type
21:42:37 * syntaxfree drops really dead this time.
21:42:42 <monochrom> Oh my omnipotent God
21:42:50 * merus gives syntaxfree mouth-to-mouth
21:42:50 <dons> you can declare fixities for type level stuff too
21:43:03 <kc5tja> @remember syntaxfree syntaxfree drops really dead this time.
21:43:03 <lambdabot> Done.
21:43:14 <dons> data a :*: b = a :*: b, infixl 7 :*:
21:43:16 <ozzilee> dons: Did you say something about having code to call out to another process from Haskell? I can muddle though it myself, but if you've got something that could get me started, that's be great. Otherwise no big deal, but I'm going to be heading out.
21:43:19 <syntaxfree> that lacks ontext, man.
21:43:24 <dons> ozzilee: oh right. hang on..
21:43:26 <syntaxfree> @quote syntaxfree
21:43:26 <lambdabot> syntaxfree says: syntaxfree drops really dead this time.
21:43:37 <olsner> @hoogle system
21:43:38 <lambdabot> System.system :: String -> IO ExitCode
21:43:38 <dons> ozzilee: run $ "xterm -e vim -o " ++ txtfile
21:43:39 <lambdabot> System :: module
21:43:39 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
21:43:54 <dons> ozzilee: where run' is
21:43:54 <dons> run s = do
21:43:55 <dons>     v <- system s
21:43:55 <dons>     when (v /= ExitSuccess) $ error $ s ++ ": returned non-zero status"
21:44:12 <dons> uses System.Cmd
21:44:17 <cdsmith> dons: AAAAH  Fixities for types?  So I've failed after all.
21:44:27 <kc5tja> syntaxfree: That's what makes it funny.  :)
21:44:44 <syntaxfree> @quote funny
21:44:44 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
21:44:57 <olsner> :type Either
21:45:01 <syntaxfree> @quote spj
21:45:01 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
21:45:05 <syntaxfree> :/
21:45:07 <gmh33> @quote really\ dead
21:45:07 <lambdabot> No quotes for this person. Take a stress pill and think things over.
21:45:17 <ddarius> @google infix expressions haskell
21:45:20 <kc5tja> @quote dead
21:45:21 <lambdabot> http://blog.moertel.com/articles/2005/08/27/power-parsing-with-haskell-and-parsec
21:45:21 <lambdabot> Title: Power parsing with Haskell and Parsec
21:45:21 <lambdabot> syntaxfree says: syntaxfree drops really dead this time.
21:45:24 * dons skools #haskell on the GHC user's guide: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons
21:45:27 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
21:45:48 <ozzilee> dons: Awesome, thanks, that will get me started at least. Some things are just hard to google for...
21:46:11 <dons> " A type variable can be an (unqualified) operator" (didn't know that)
21:46:18 <ddarius> @oldwiki InfixExpression
21:46:19 <lambdabot> http://www.haskell.org/hawiki/InfixExpression
21:46:24 <scodil> monochrom: this code i've got here is acting like its using the exception handler active when the thunk is created, not the one active when it's forced... what else could be making it look like it was doing that?
21:46:47 <monochrom> Hmm let me experiment
21:46:51 <dons> hmm. could glut be just exiting?
21:46:54 <dons> or doing some other evil?
21:47:16 <scodil> no i don't think so
21:47:27 <jcreigh> GHC has lots of interesting features above Haskell98, I've noticed. "You can take the red pill or the blue pill..." "Hmm. What's the green pill?" "What? Oh. That's GHC."
21:48:04 <syntaxfree> ?remember jcreigh GHC has lots of interesting features above Haskell98, I've  noticed. "You can take the red pill or the blue pill..." "Hmm.                  What's the green pill?" "What? Oh. That's GHC."
21:48:05 <lambdabot> Done.
21:48:14 <olsner> parser combinator libraries should be able to left-factor automagically... buildExpressionParser kludges shouldn't even be necessary
21:49:01 <kc5tja> This is something that's been eating away at me for some time: is there a technical difference between combinator and function?  They both seem to be the same in my eyes.
21:49:06 <monochrom> Hmm exception handler must be in IO?
21:49:13 <ddarius> kc5tja: Yes and no.
21:49:21 <scodil> wait nevermind. yeah glut is doing something stupid. if I throw an error inside the redraw function, the handler I installed for glut.mainLoop doesn't get called
21:49:28 <syntaxfree> a combinator is just a function that eats functions and return functions, isn't?
21:49:37 <ddarius> @foldoc combinator
21:49:39 <lambdabot> *** "combinator" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
21:49:39 <lambdabot> combinator
21:49:39 <lambdabot>  
21:49:39 <lambdabot>         <theory> A function with no {free variables}.  A term is
21:49:39 <lambdabot>         either a constant, a variable or of the form A B denoting the
21:49:41 <lambdabot> [28 @more lines]
21:49:54 <syntaxfree> @more
21:49:54 <lambdabot>         {application} of term A (a function of one argument) to term
21:49:55 <lambdabot>         B.  {Juxtaposition} associates to the left in the absence of
21:49:55 <lambdabot>         parentheses.  All combinators can be defined from two basic
21:49:55 <lambdabot>         combinators - S and K.  These two and a third, I, are defined
21:49:55 <lambdabot>         thus:
21:49:56 <lambdabot> [23 @more lines]
21:50:32 <olsner> isn't the "combinator" part just referring to the style of building/combining larger parsers from smaller parsers?
21:50:49 <ddarius> However, the way it is often used has the connotation of their being a lot of little "things" and ways of combining them v. say a framework.
21:51:35 <scodil> so if haskell calls out to c, and then c calls back into haskell, is the exception handler reset?
21:51:46 <syntaxfree> I always thought map, foldr, etc. were combinators
21:52:02 <kc5tja> So with, "let sum a b = a+b; in sum 2 3", sum is "technically" a combinator, while "let incr n = (\x -> x+n) in ..." the function returned by incr is _not_ a combinator.
21:52:27 <ddarius> Yes.
21:52:32 <ddarius> Er no.
21:52:39 <kc5tja> Now, the tricky part: would incr be considered an incr in this case?
21:52:42 <kc5tja> err
21:52:45 <kc5tja> be considered a combinator?
21:52:58 <syntaxfree> the fun thing about haskell is that's the same as incr n x = x + n
21:53:14 <syntaxfree> so incr = flip sum. Which is sum, because of comutativity :)
21:53:55 <kc5tja> syntaxfree: Right, but I wanted to make it explicit for the purposes of pointing a finger at it and making fun of it if necessary.  :)
21:54:15 <ddarius> let x = 3; f y = x+y in ... f is not a combinator
21:54:38 <ddarius> The lambda term \x -> x + n is not a combinator.
21:54:57 <gmh33> dons, that big quote file that you linked ealier is making me dumber
21:54:59 <ddarius> (Actually, I guess we can consider (+) to be a free variable...
21:55:02 <gmh33> reading through the keal quotes
21:55:03 <dons> gmh33: heh
21:55:14 <dons> gmh33: yeah, it should come with a health warning
21:55:24 <kc5tja> ddarius: But x+y is, since + relies only on its parameters.
21:55:28 <gmh33> I wonder if that guy knew that T was a "real" scheme dialect/implementation? :P
21:55:58 <ddarius> dons: Have you seen the InfixExpression page on the old wiki?
21:56:11 <syntaxfree> is foldr a combinator?
21:56:17 <gmh33> "with KealDigit quantum crackproof encryption possible"
21:56:18 <gmh33> brain
21:56:24 <syntaxfree> ?keal
21:56:24 <lambdabot> my proof show math is broken right now
21:56:31 <gmh33> ?keal
21:56:32 <lambdabot> actually it bug in math
21:56:33 <kc5tja> syntaxfree: I would be inclined to believe it is, with the definition given above.
21:56:35 <gmh33> ?keal
21:56:35 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
21:57:00 <dons> ddarius: not on the old wiki. on the H' proposal.
21:57:11 <dons> ddarius: hmm. I'd actually like this extension. should try to hack it into ghc.
21:58:19 <gmh33> I like the one about open source, and where can I dl haskell for windows ;)
21:58:22 <kc5tja> See, you don't get this kind of entertainment with channels for other languages, because the language isn't based on algebra, and therefore, you nobody really knows _how_ numbers are supposed to work.  Here, at least, one can use the language itself to explore the concepts.
21:58:40 <kc5tja> Maybe that's why channels for other languages are filled with bigots and dolts.  ;)
21:58:47 <kc5tja> (j/k, but with an aire of truth)
21:58:57 <syntaxfree> @quote bigots
21:58:57 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
21:59:02 <syntaxfree> @quote dolts
21:59:02 <lambdabot> No quotes match. Just what do you think you're doing Dave?
21:59:10 <syntaxfree> @quote numbers
21:59:10 <lambdabot> monochrom says: All numbers just sit there doing nothing.
21:59:30 <dons> kc5tja: hmm. yes. i've thought about this previously. its easier to spot when people are trolling, since its trivial to point out what the correct result of something would be.
21:59:35 <dons> "dude, your types don't match. try again."
21:59:36 <kc5tja> It'd be bad form for me to @remember myself.
21:59:49 <sorear> @quote remember
21:59:49 <lambdabot> glguy says: I don't remember saying that
21:59:55 <sorear> @quote remember
21:59:56 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
21:59:57 <sorear> @quote remember
21:59:58 <lambdabot> jcreigh says: Sometimes I say something witty hoping that someone will @remember it...pathetic, I know. :)
22:00:29 <gmh33> lol "Keal angry @ dons"
22:00:39 <gmh33> he did a lot of work in only 3 days :P
22:01:01 <monochrom> @quote JaffaCake
22:01:01 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
22:01:04 <monochrom> @quote JaffaCake
22:01:05 <lambdabot> JaffaCake says: I don't remember a recruitment process where the interviewees all talk to each other before, it's kind of scary :)
22:01:11 <monochrom> @quote JaffaCake
22:01:12 <lambdabot> JaffaCake says: I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
22:01:20 <syntaxfree> I actually went to a recruitment process where candidates spent quite some time socializing.
22:01:23 <dmwit> Bah.
22:01:34 <dmwit> How do I capture clicks to a drawing area in Gtk2Hs?
22:02:33 <syntaxfree> @quote lion
22:02:34 <lambdabot> lispy says: if you generate 1 billion patches per second, what maintainer will review them?
22:02:41 <ddarius> dons: Where is the ticket for the infix expressions?
22:02:49 <syntaxfree> @quote infix
22:02:49 <lambdabot> No quotes match. My pet ferret can type better than you!
22:03:06 <sorear> dmwit: set a tra[
22:03:18 <kc5tja> heh, Linus Torvalds come close with 4 to 5 merges per day.  Does that count?
22:03:22 <_frederik_> @quote the
22:03:23 <lambdabot> the says: DP concept would never have been "invented" if functional languages had been there in the beginning :)
22:03:24 <araujo> dmwit, onButtonPress ?
22:03:27 <dons> ?where haskell-prime
22:03:27 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
22:03:37 <_frederik_> @quote http
22:03:38 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
22:03:38 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
22:03:46 <dmwit> araujo: Thanks.
22:03:58 <araujo> welcome dmwit
22:04:17 <dons> ddarius: hmm. maybe there's no ticket. maybe it only came up on h' ml?
22:05:28 <_frederik_> the execution times for certain functions of mine are quite erratic
22:05:51 <_frederik_> it seems unlikely that garbage collection could be the reason
22:06:04 <dons> profile, or use +RTS -s
22:06:13 <dons> to watch the GC kick in
22:06:18 <_frederik_> oh ok
22:06:22 <dons> >15% GC time could be to blame?
22:06:23 <_frederik_> can i do that in ghci?
22:06:30 <dons> oh, you're using ghci?
22:06:33 <_frederik_> yeah
22:06:35 <dons> then well, all bets off. bytecode
22:06:40 <dons> try compiled native code
22:06:52 <_frederik_> that has the same problem
22:06:55 <dons> with -O. much more reliable than worrying about what the bytecode interpreter is doing.
22:07:03 <dons> right. but you can at least profile and count GCs :-)
22:07:05 <ddarius> The InfixExpression thing on hawiki is doable today and gets you almost all of what you would want.
22:07:14 <_frederik_> i don't see why the bytecode interpreter shouldn't do the same thing every time though
22:08:02 <_frederik_> i will try +RTS -s
22:08:06 <ddarius> SyntaxNinja wants to get rid of (.)?
22:08:18 <dons> its just that you can't easily measure bytecode interpreting, since you've got the rest of ghci as overhead
22:08:33 <sorear> well, nhc is a non-interactive bci
22:08:40 <sorear> it's just as slow as ghci :)
22:09:01 <_frederik_> by the way the times are like, generally around 7.5e-4 seconds, but sometimes around 5e-3 seconds
22:09:49 <gmh33> ?gavino
22:09:49 <lambdabot> Unknown command, try @list
22:09:54 <gmh33> ? gavino
22:12:14 <ivanm> my program generates a list, and then outputs them to a file incrementally as well as printing the total number produced
22:12:40 <ivanm> would it be better to keep a running total of how many items are in the list as I print them, or to get the length of the list after I've printed them all?
22:13:43 <monochrom> running total
22:16:17 <ivanm> monochrom: yeah, I thought so, just that it seemed a tad slower when I did it that way
22:16:41 <ivanm> *shrug* might be because the running time for those input values is that small its hard to tell...
22:17:07 <monochrom> The second way holds on to the whole list until the end for the length.
22:17:40 <monochrom> Holding on to the list until the end may or may not be bad.
22:17:47 <ivanm> *nod*
22:17:59 <monochrom> "length" is somewhat optimized, for sure.
22:19:25 <ivanm> optimized in what way?
22:19:41 <ivanm> I thought it was just length [] = 0, length (x:xs) = 1 + length xs
22:19:46 <ivanm> or a folded version of that
22:20:24 <dons> length xs0 = len xs0 0#
22:20:24 <dons>   where
22:20:24 <dons>     len :: [a] -> Int# -> Int
22:20:24 <dons>     len []     a# = I# a#
22:20:24 <dons>     len (_:xs) a# = len xs (a# +# 1#)
22:20:40 <dons> a sufficiently smart compiler should get that , though
22:20:56 <dons> with a bang on the accumulator, anyway
22:21:03 * dons checks this..
22:21:10 <ddarius> dons: From the foldr version?
22:21:15 * ddarius doubts that.
22:21:18 <ivanm> oh, so its iterative rather than recursive?
22:21:29 <ivanm> and using unboxed types?
22:21:31 <ddarius> ivanm: Length doesn't mean much on infinite lists...
22:21:31 <dons> from a foldl' + stream fusion, I reckon..
22:21:33 * dons tries this
22:22:04 <ivanm> ddarius: obviously ;-)
22:24:12 <ivanm> OK, another question then, if you would all be so kind ;-)
22:24:51 <ivanm> I'm storing a (sparse) matrix as a list of lists, with the empty elements represented by 0s (though I'll probably use Maybe down the track)
22:25:27 <monochrom> That is still not sparse, actually.
22:25:40 <ivanm> well, I"m just calling it sparse
22:26:02 <ivanm> its just a bunch of values, with some cells I'm designating as empty
22:26:17 <ivanm> I want to write a function that takes a matrix m and an int u, and give me every possible way of setting u of the cells in m empty
22:26:19 <kilimanjaro> what do you mean by a matrix with empty elements?
22:26:38 <ivanm> kilimanjaro: like you have empty cells in a sudoku puzzle
22:26:40 <dons> foldl' (const . (+1) 0
22:26:45 <dons> in the stream fusion branch, compiles to:
22:26:46 <dons> go :: Int# -> [a] -> Int#
22:26:47 <dons> go a xs = case xs of
22:26:47 <dons>              []     -> a
22:26:49 <dons>              _ : ys -> go (1 +# a) ys
22:26:54 * dons declares victory over Data.List!
22:27:21 <ivanm> heh
22:27:32 <kilimanjaro> ivanm, ahh, ok. Use Maybe, that way it is polymorphic rather than just a matrix of Nums
22:27:35 <ivanm> but Data.List is easier to use AFAIK than stream fusions :p
22:27:47 <kilimanjaro> ohh, nvm, it is supposed to be a matrix of integers
22:27:53 <dons> ivanm: same interface.
22:27:56 <ivanm> kilimanjaro: yeah, I will be, though I'm only using it to store Ints anyway, and I don't want 0 in there
22:27:57 <Pseudonym> dons: Good.  Now do Data.Map.toAscList.
22:28:01 <dons> just optimised differently.
22:28:04 <dons> Pseudonym: argh :}
22:28:17 <ivanm> dons: is it? so I can just replace Data.List with the stream fusioni for instant performace increase?
22:28:22 <Pseudonym> dons: How well does merge do?
22:29:07 <Pseudonym> I found a bug in a Ralf Hinze library this morning.
22:29:14 * Pseudonym was disappointed
22:29:22 * ivanm might find that more shocking if he knew who Ralf Hinze was
22:29:46 <ddarius> Hinze is a closet cowboy coder.
22:30:00 <dons> Pseudonym: merge as in merge sort?
22:30:20 <Pseudonym> dons: Yeah.
22:30:30 <dons> ivanm: roughly. needs a head branch of ghc.
22:30:36 <monochrom> Ralf Hinze is one of those program derivation people we talked about earlier. :)
22:30:40 <ivanm> head as in development?
22:30:41 <Pseudonym> I have a library that's very sorted-list-manipulation heavy.
22:30:52 <dons> Pseudonym: oh, interesting. might be a nice candidate .
22:31:02 <Pseudonym> That's why I asked, yeah.
22:31:15 <dons> generally, the more list combinations you use, the better the code, under stream fusion.
22:31:19 <dons> combinators.
22:31:21 * Pseudonym nods
22:31:33 <Pseudonym> So if you've written your own sorted-list-set-difference...
22:31:37 <Pseudonym> I'm guessing it won't help.
22:31:40 <dons> right.
22:31:43 <ivanm> forgive my ignorance, but what's a list combinator?
22:31:51 <dons> no pass to turn general recursive defns into a fusible combinator form.
22:31:56 <Pseudonym> Right.
22:31:59 <dons> ivanm: functions on lists with magic names.
22:32:04 <ivanm> heh
22:32:05 <dons> like foldr.
22:32:11 <ivanm> *nod*
22:33:48 <Pseudonym> Need to fix this library, first.
22:33:52 <Pseudonym> I might Cabalise it.
22:34:00 <Pseudonym> It's the priority search queue library.
22:34:26 <Pseudonym> Occasionally handy.
22:35:24 <dons> yeah, that gets requested here regularly
22:35:35 <Pseudonym> Really?
22:36:07 <ivanm> well, using length is definitely faster than incrementally keeping track
22:37:10 <ddarius> ivanm: Are you forcing the accumulation variable?
22:37:26 <ivanm> ummm..... no....
22:37:29 * ivanm tries that
22:37:55 <ivanm> just put $ in front of it?
22:38:11 <ivanm> what I have is:
22:38:51 <ivanm> lprint c _ [] = return c; lprint c f (x:xs) = do f (show x); lprint (succ c) f xs
22:38:57 <ivanm> and initialise c to 0 when calling it
22:39:09 <ivanm> f is of type String -> IO ()
22:39:23 <ivanm> it lets me choose if I should output to file or standard out
22:39:40 <Cale> ivanm: you might want to make it strict in c
22:39:52 <ivanm> Cale: how do I do that?
22:40:16 <dons> i'd write it like:
22:40:17 <dons> lprint !c f xs = go c xs
22:40:17 <dons>   where
22:40:17 <dons>     go !c []     = return c
22:40:17 <dons>     go !c (x:xs) = do f (show x)
22:40:19 <dons>                       go (succ c) xs
22:40:21 <Cale> If you're using a new ghc, use a bang pattern, which is, put a ! before c
22:40:27 <dons> but then this whole loop/show business is fishy.
22:40:34 <ivanm> well, its 6.6 ... is that new enough?
22:40:37 <Cale> yep
22:40:40 <ivanm> dons: in what way is it fishy?
22:40:41 <dons> yep, ! and -fbang-patterns
22:40:49 <dons> what's 'f'? String -> IO () ?
22:40:54 <Cale> Or you can just use seq directly
22:40:56 <dons> so its just mapM_ f [... ] ?
22:41:06 <ivanm> oh... didn't know that...
22:41:10 <dons> a mapAndAccum ?
22:41:15 <ivanm> I wrote that function a couple of months ago
22:41:31 <dons> you wan the length, after displaying the list somehow?
22:41:36 <ivanm> yeah
22:41:37 <dons> i.e. two things in one go== fishy ;-)
22:42:02 <ivanm> dons: well, I was asking about that, and someone said that it was better than using length afterwards
22:42:17 * ivanm is trying to get every little bit of speed boost he can
22:42:27 <dons> lprint c f xs = do
22:42:28 <dons>         mapM_ (f . show) xs
22:42:28 <dons>         return $! c + length xs
22:42:53 <dons> maybe. how big is the list? if the list is big enough that two traversals matter, its better not to use 'show'
22:43:11 <dons> you're doing manual fusion. always fishy :)
22:43:12 <ivanm> well, the list itself isn't that big...
22:43:28 <ivanm> but its the result of a large scale filtering, so I wanted the incremental output
22:43:35 <dons> so probably no benefit from combining the impure and pure loops.
22:43:39 <dons> ok.
22:43:43 <ivanm> and then I just thought today that rather than traversing the list twice, it might be better to do it just once
22:43:58 <ivanm> so you reckong stick to printing it, then finding the length?
22:44:01 <dons> only if it matters for real speed.
22:44:18 <dons> then do the manual fusion. otherwise, keep the length separate, as it has nothing to do with the printing pass, logically.
22:44:30 <ivanm> yeah
22:44:47 <ivanm> I don't know how much of an effect it will have, but I'm wanting every boost I can
22:44:57 <dons> profile first :-)
22:44:57 <ivanm> then again, I don't expect the list to be > 10 elements...
22:45:02 <ivanm> probably nowhere near that
22:45:03 <dons> ah ok.
22:45:07 <dons> then don't bother.
22:45:09 <dons> keep them separate.
22:45:13 <ivanm> yeah, I've profiled... that bits hardly a blip
22:45:24 <ivanm> yeah, I just wanted to try it to see if it made a difference
22:45:45 <ivanm> this is that same latin squares problem I was working on, but I made an improvement to the algorithm
22:45:56 <ivanm> so order 5 has gone from 5 days to 1.5 hours! :D
22:46:17 <ivanm> but the filtering function used to take only 5% of the run time, so I didn't care about its efficiency...
22:46:26 <ivanm> but now it takes 30%, so I have to re-write that :(
22:47:01 <dons> that just means you improved other parts of the code :-)
22:47:06 <dons> so you shift the hotspot around
22:48:55 <ivanm> yeah
22:56:55 <dons> http://programming.reddit.com/info/1o8q1/comments
22:56:57 <lambdabot> Title: Haskell Weekly News: Hardware Description, Databases, Photo and File Manipulatio ...
23:00:33 <sjanssen> dons: already sent out the mails for the HWN?
23:01:57 <dons> sjanssen: I did, but they've not arrived :/
23:02:07 <dons> mailman down?
23:02:09 <sjanssen> s/Goerzon/Goerzen
23:02:23 <dons> oh. right oops.
23:02:35 <dons> yeah, my spell checker doesn't spot those.
23:05:03 <dons> ah , now they arrive
23:06:33 <ivanm> @type printf
23:06:35 <lambdabot> forall r. (PrintfType r) => String -> r
23:06:50 <ivanm> what is PrintfType ?
23:07:31 <dons> a recursive typeclass for accumulating printf parameters
23:07:42 <dons> :t printf "%c%s%c" 'x'
23:07:44 <lambdabot> forall t. (PrintfType (Char -> t)) => t
23:07:46 <dons> :t printf "%c%s%c" 'x' "foo"
23:07:48 <lambdabot> forall t. (PrintfType (Char -> [Char] -> t)) => t
23:07:48 <dons> :t printf "%c%s%c" 'x' "foo"  'y'
23:07:50 <lambdabot> forall t. (PrintfType (Char -> [Char] -> Char -> t)) => t
23:07:56 <dons> see how it builds up the type constraint on printf?
23:08:06 <dons> > printf "%c%s%c" 'x' "foo"  'y' :: String
23:08:08 <lambdabot>  "xfooy"
23:08:24 <ivanm> Think so...
23:08:45 <ivanm> :t printf "%c%s%c"
23:08:47 <lambdabot> forall r. (PrintfType r) => r
23:09:12 <ivanm> but when you pass 'x' afterwards, it constrains the first one to be of type Char ?
23:09:20 <ivanm> then recursively for the rest?
23:09:30 <dons> basically
23:09:36 <ivanm> @doc Printf
23:09:36 <lambdabot> Printf not available
23:09:42 <ivanm> @doc Text
23:09:42 <lambdabot> Text not available
23:09:53 <dons> google finds updates to HWN really quickly. its already in my blog feed.
23:10:06 <ivanm> see? google knows whats good :p
23:10:14 <ivanm> and its making ammends for blocking LB that time
23:10:16 <ivanm> @doc Text.Printf
23:10:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
23:10:36 <dons> the source is where it's at
23:11:24 <ivanm> ?
23:11:59 <dons> ?source Text.Printf
23:11:59 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
23:12:23 <ivanm> ahh... nah, I just wanted the docs because I forget the different format types for printf :s
23:12:31 <ivanm> but thanks for explaining that to me dons
23:12:53 <ivanm> I presume printf is one of those extension libraries that aren't officially part of H98?
23:13:15 <sjanssen> right
23:13:29 <sjanssen> the implementation isn't Haskell '98 either
23:13:36 <ivanm> *nod*
23:13:41 <dons> I think it is H98.
23:13:47 <dons> at least, Lennart always assures us that it is.
23:13:51 <ivanm> so is it only in ghc, or do any of the other compilers have it as well?
23:14:01 <ivanm> dons: you mean the implementation is?
23:14:15 <dons> Text.Printf> printf "%c%s" 'x' "foo" :: String
23:14:15 <dons> "xfoo"
23:14:15 <dons> Text.Printf> [Leaving Hugs]
23:14:26 <ivanm> ahh, OK
23:14:26 <dons> yeah, its not part of H98, but its written in H98.
23:14:30 <ivanm> *nod*
23:14:54 <ivanm> in Haskell, is it possible to split lines of text without explicitly using ++ ?
23:15:50 <dons> ivanm: unlines ["foo","bar"
23:15:51 <dons> ]
23:15:55 <dons> or use string gpas
23:16:04 <ivanm> string gpas?
23:16:16 <dons> > "some \          {-with a big gap! -}  \string"
23:16:16 <lambdabot>  Illegal character in string gap
23:16:28 <ivanm> heh, yeah, that's what I was after
23:16:40 <ivanm> but lambdabot doesn't seem to like it...
23:16:40 <dons> > "foo \   \bar"
23:16:42 <lambdabot>  "foo bar"
23:16:48 <ivanm> ahh, it was the comment
23:16:50 <dons> > "foo \  {- magic -} \bar"
23:16:50 <lambdabot>  Illegal character in string gap
23:16:54 <dons> huh
23:17:54 <ddarius> ? Sure.
23:17:56 <sjanssen> wow, Text.Printf *is* H98
23:18:10 <dons> sjanssen: we don't understand typeclasses :-)
23:18:14 <sieni> > concat $ concat $ map (\x -> [x,"foo"]) ["bar", "baz"]
23:18:16 <dons> that's what Text.Printf tells me.
23:18:16 <lambdabot>  "barfoobazfoo"
23:19:05 <ivanm> OK, is there a definitive online guide about how I should do indentation, specifically for where statements?
23:19:15 <ivanm> preferably something simipler than the report ;-)
23:19:34 <ivanm> s/specifically/especially
23:20:05 <sieni> @pl \x -> [x,"foo"]
23:20:06 <lambdabot> (: ["foo"])
23:20:17 <dons> ivanm: there's a style guide on haskell.org
23:20:17 <sieni> <3
23:20:23 <dons> search for 'style'
23:20:26 <ivanm> thanks dons
23:20:49 <sieni> @src unlines
23:20:50 <lambdabot> unlines = concatMap (++ "\n")
23:21:15 <sieni> @src concatMap
23:21:15 <lambdabot> concatMap f = foldr ((++) . f) []
23:23:17 <ivanm> dons: well, I searched for style, and a lot of items came up, but nothing I can find that's relevant...
23:25:15 <olsner> stupid occurs-check... just let me construct infinite types already!
23:29:58 <dmwit> Cairo is beautiful.
23:32:20 <dons> ivanm: there's a large style guide. keep looking!
23:42:37 <ivanm> dons: I am! I've found the style category, but nothing about indentations, etc
23:46:16 <dons> i noticed the lisp style guide a couple of days ago, by Riastradh, has some good advice for haskell too
23:56:33 <ivanm> dons: still can't find it :(
23:58:58 <ivanm> you don't mean this, do you? http://haskell.org/onlinereport/lexemes.html#sect2.7
23:58:59 <lambdabot> Title: Haskell 98 Lexical Structure
