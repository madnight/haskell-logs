00:26:26 <fuzan> slow night?
00:26:47 <fuzan> i'll propose a question!
00:26:55 <fuzan> Is there any difference in the ordering of monad transformers?
00:27:16 <fuzan> ie, ErrorT ( ReaderT foo ) as opposed to say, ReaderT ( ErrorT foo)
00:27:36 <fuzan> in anything other than the order of the type
00:33:03 <roconnor> persumably one is Either String (R -> A) and the other is R -> Either String A
00:41:14 <fuzan> roconnor: sure, but in usage -- does anything differ? throwing errors or asking state works identically -- correct?
00:50:20 <osfameron> darcs source for yi is broken at http://cgi.cse.unsw.edu.au/~pls/cgi-bin/darcs.cgi/yi
00:50:21 <lambdabot> Title: darcs repository
00:50:40 <osfameron> the link from http://www.cse.unsw.edu.au/~dons/yi.html suggests it's a web frontend to see the source.  But you can't.
00:50:40 <lambdabot> Title: yi text editor
00:52:22 <osfameron> or am I missing something?  There are annotate and patches links, but no apparent view source
00:52:36 <fuzan> darcs get it, then look at it :)
00:53:03 <osfameron> well, yes, but a) that would involve me downloading darcs and learning how to use it, and b) it's advertised as having an html source view
00:53:15 <osfameron> it's not a big deal, I'll dl darcs if I really need to at some point
00:54:10 <fuzan> osfameron: http://www.cse.unsw.edu.au/~dons/yi/
00:54:10 <lambdabot> Title: Index of /~dons/yi
00:55:15 <osfameron> fuzan: ah, thanks.  Was that linked from the front page?
00:55:22 <fuzan> it's the darcs url
00:55:35 <fuzan> which is a just a folder with a special _darcs directory
00:55:48 <osfameron> ah, ok
00:56:34 <fuzan> osfameron: i'm not entirely sure how the darcs.cgi works, heh.
00:56:57 <Korollary> darcs is super easy anyway. just get it.
00:56:59 <osfameron> as far as I can tell from that page, not particularly well
00:57:13 <osfameron> but that would be the same for svnweb and various other tools in my experience :-)
00:59:50 <Korollary> I poo on web based tools
01:04:41 <danigm> hi all, I need a function for convert from Char to Word8, someone know something?
01:07:44 <sieni> > c2w 'a'
01:07:45 <lambdabot>   Not in scope: `c2w'
01:08:10 <sieni> > Data.ByteString.c2w 'a'
01:08:13 <lambdabot>   Not in scope: `Data.ByteString.c2w'
01:08:18 <sieni> > Data.ByteString.Base.c2w 'a'
01:08:25 <lambdabot>   Not in scope: `Data.ByteString.Base.c2w'
01:08:50 <sieni> @src c2w
01:08:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:08:53 <Korollary> ?type fromIntegral
01:08:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
01:10:17 <danigm> from integral do the opposite
01:10:20 <sieni> > ord 'a'
01:10:31 <sieni> lambadabot?
01:10:31 <lambdabot>  97
01:11:27 <sieni> > map ord "Yeah!"
01:11:37 <lambdabot>  [89,101,97,104,33]
01:11:43 <danigm> ord 'a' convert from a Char to an Int, but Int and Word8 is not hte same
01:11:55 <danigm> ok, now from int to word8
01:12:24 <olsner> Char's are probably unicode, so you have to either UTF-8 encode or filter all values>255
01:13:08 <danigm> I read this Chars from a binary file
01:14:02 <danigm> and i have a String, but when I want to write it again, i don't find nothing to write a string like binary, but if i write a [Word8] it work well
01:16:12 <sieni> > (map (fromIntegral . ord) "Yeah!") :: [Word8]
01:16:14 <lambdabot>  [89,101,97,104,33]
01:17:27 <olsner> such a hack probably works for now - but if it's a binary file you probably should read it as Word8 from the start
01:18:20 <olsner> if the byte->Char conversion is done with different charsets, you'll get different results
01:18:31 <danigm> yes,
01:18:58 <danigm> i will read to word8 and then work with this
01:26:37 <Cheery> after reading PNG specs for a while, I just can't avoid getting the sensation that it was meant to be written in haskell
01:26:58 <osfameron> I get that looking at xpath
01:28:18 <sieni> danigm: can't you use bytestrings?
01:28:57 <danigm> yes
01:29:07 <danigm> but i don't know how
01:29:15 <Cheery> I think it'll take longer time to write a haskell FFI than it is to implement the encoder for PNG
01:29:28 <danigm> i use the first thing i found
01:30:39 <danigm> i want to read a BMP image, convert to a Pixel data, data Pixel = Pix (Red,Green,Blue) deriving Show, apply filter to this and then write again to a new BMP image
01:31:11 <Cheery> darn, this spec even has a directed acyclic graph I can directly translate into haskell if I wish to
01:31:56 <Cheery> combining Parsec with Data.Binary should really kick this thing's ass
01:32:30 <Cheery> *graph for depedencies of certain chunks
01:40:28 <Cheery> thought I believe there may be easier way to do it. :)
01:43:04 <TSC> Has anyone written a binding for the ImageMagick library?
01:43:12 <DRMacIver> Hm.
01:43:28 <DRMacIver> I've just noticed that a surprising number of people have asked me "What's a monad?" as a job interview question. :)
01:44:00 <ejt> sounds like you're going to the right sort of job interviews
01:44:06 <Wild_Cat> heh. I guess that's because that's the one thing you need to understand in order to "get" Haskell.
01:44:28 <osfameron> I don't think it's the "one" thing ;-)
01:44:44 <Wild_Cat> most of the rest of the language seems obvious, in hindsight.
01:44:52 <osfameron> I'm learning a *lot* while still being very far away from understanding monads...
01:45:05 <DRMacIver> Wild_Cat: Probably. I think it's more likely that it's the thing that everyone has heard about Haskell. ;)
01:45:07 <Cheery> if somebody asks me What's a monad, I'm not able to answer to that with anything else but a question
01:45:22 <Cheery> "what do you want to know about monads?"
01:45:39 <quicksilver> osfameron: you're not very far away at all, you're just looking the wrong direction
01:45:46 <DRMacIver> I think the first time I mumbled something about sequencing, yesterday I basically gave my official "It's a thingy!" answer and... I can't remember what I said the other time.
01:45:47 <quicksilver> <calls out> the best monads are just over this hill
01:45:51 <osfameron> :D
01:46:16 <osfameron> I have a sneaky suspicion that when I understand it I'll think "Oh, that was obvious"
01:46:31 <Cheery> monad is one of those things I'm not simply able to explain with just one sentence
01:46:47 <Wild_Cat> osfameron: so am I. But the thing is, with the exception of monads, Haskell is about asking for what you want.
01:46:48 <Cheery> it's more like a map of concepts rather than one concept
01:47:41 <DRMacIver> osfameron: I've arbitrarily declared myself to understand monads so I can get it over with. ;)
01:47:51 <earthy> that's the spirit. :)
01:47:53 <osfameron> DRMacIver: good strategy!
01:47:54 <Wild_Cat> that's the really groundbreaking thing in FP: your program doesn't describe a way to achieve a result. It describes that result, period.
01:48:34 <DRMacIver> Wild_Cat: Until you realise that writing code that way makes your performance blow goats and that you need to think about how to achieve it after all. ;)
01:48:56 <osfameron> how do you do 'trace' in haskell btw?
01:49:04 <Wild_Cat> DRMacIver: I'm a firm believer of the first rule of optimization.
01:49:14 <quicksilver> osfameron: the ghci debugger looks interesting
01:49:15 <osfameron> not that I need it yet, but I'd like to play with it
01:49:25 <quicksilver> osfameron:
01:49:29 <quicksilver> :)
01:49:34 <quicksilver> the profiler is useful, too
01:49:46 <DRMacIver> Wild_Cat: I'm a firm believer in the 0th rule. "Don't write stupid code."
01:50:01 <osfameron> I'm not sure where the ghci debugger is documented.  The output to :? is rather cursory
01:50:32 <DRMacIver> I'm not proposing you should micro optimise everything of course. :) But you need to be at least somewhat aware of how the code will be run in order to write good code.
01:50:57 <Wild_Cat> DRMacIver: depends on your definition of "stupid". I aim to write simple, elegant code. I find that as a bonus, it usually works well.
01:51:25 <jmg_> hi
01:51:56 <DRMacIver> Wild_Cat: It's a nice goal. A better one is to write code which is as simple and elegant as possible, and no simpler. ;)
01:52:32 <DRMacIver> Wild_Cat: Classic example being fibonacci numbers. The simple, elegant, way to write it has exponential running time.
01:52:48 <DRMacIver> (Example maliciously stolen from yesterday's interview)
01:53:00 <jmg_> is anybody here who can help me with a problem with quickcheck and assertions?
01:53:36 <DRMacIver> Wild_Cat: More importantly, you're confusing 'functional' with 'declarative' :)
01:53:41 <danigm> when i open a file, how can i know its length in bytes? it's possible?
01:53:57 <Wild_Cat> DRMacIver: indeed. But depending on what you do with the Fibonacci sequence, it may not be an issue just yet. When it does become one, just rewrite that particular function to the cryptic but rather cool fib = zipWith (+) [1..] (tail fib) ;)
01:54:37 <Wild_Cat> I mean, you may only want to use the 10 or so first numbers in the sequence.
01:54:49 <DRMacIver> Wild_Cat: Right. But that's exactly my point. When you do that you're concerning yourself with what the code does rather than what the code achieves.
01:55:41 <DRMacIver> It's all very well to say "Everything should be completely declarative and not concern itself with the actual implementation - let the compiler do that for me", but the problem is that if you try to do that for anything more than toy examples it will not work.
01:55:56 <Wild_Cat> true. My point, I guess, was that you only have to start worrying about what the code does when you're optimizing it, if you ever need to.
01:56:39 <Wild_Cat> and OptimizeLater says that most of the time, you don't need to.
01:56:58 <DRMacIver> 'worrying' and 'being aware of' are not the same thing.
01:57:35 <DRMacIver> It is very often the case that if you know what you're doing then the code you write by habit is no longer than the code you would write if you don't know what you're doing and will run better.
01:58:20 <DRMacIver> Sure, this isn't where the performance bottleneck is. But automatically speeding up / reducing the space useage all the non bottleneck areas is not to be sneered at.
01:59:00 <DRMacIver> I'm not advocating writing 100 lines where 10 would do in the name of efficiency. I'm advocating writing 10 more efficient lines instead. :)
01:59:03 <Wild_Cat> absolutely. As long as it doesn't involve any significant extra effort, I'm all for it.
01:59:19 <DRMacIver> The significant extra effort it involves is learning how it all works in the first place. :)
01:59:26 <DRMacIver> And keeping that in the back of your mind.
01:59:47 <Wild_Cat> some of the things I've seen being done in the name of (premature) optimization still scare me to this day.
02:00:13 <DRMacIver> Indeed. Performing evil in the name of optimisation when you don't need to is clearly a bad plan. :)
02:00:14 <araujo> hello
02:00:26 <DRMacIver> Anyway, I should be at work already. Back in a bit.
02:01:56 <EvilTerran> danigm, getFileStatus :: FilePath -> IO FileStatus; System.Posix.Files.fileSize :: FileStatus -> FileOffset
02:02:13 <danigm> thanks
02:02:19 <EvilTerran> (the first is System.Posix.Files also; curse my ill-coordinated copy-and-pasting)
02:03:07 <EvilTerran> there's probably something horrible in System.Win32.File too, but i don't see it
02:13:49 <danigm> I don't know how haskell convert the types, i have a function which recieve an Int, but i can pass it an Integer, how can i convert from an Integer to an Int, what is the diference?
02:14:12 <int-e> use  fromIntegral  to convert from one to the other
02:14:12 <danigm> i can't pass it an Integer
02:15:46 <danigm> ok, it work now
02:16:17 <int-e> Integer is an arbitrary precision integer; Int is often a machine word (a range of -2^29 to 2^29-1 is guaranteed in Haskell 98.)
02:16:23 <int-e> so
02:16:29 <int-e> > 2^32 :: Int
02:16:33 <lambdabot>  0
02:16:34 <int-e> > 2^32 :: Integer
02:16:43 <lambdabot>  4294967296
02:18:27 <Wild_Cat> I guess at that point you can just define your function as taking Integral arguments, right?
02:20:04 <osfameron> out of interest, why does unary minus bind so loosely?  It's annoying to have to type (-2) when you mean -2.
02:21:02 <int-e> to allow using it as an infix operator
02:21:54 <osfameron> other languages manage both without the parens: I guess this falls out of some other desired behaviour though?
02:22:04 <int-e> which basically means that unary minus must bind with lower precedence than binary minus.
02:23:03 <quicksilver> osfameron: they wanted the syntax to be regular
02:23:10 <int-e> with contrived Num instances, both 0 (-1) and 0 - 1 could be defined
02:23:19 <quicksilver> osfameron: other languages have an exception for -
02:23:31 <quicksilver> osfameron: to correctly parse 2-1 and 2 - -1
02:23:45 <quicksilver> of course, haskell has an exception for - as well :(
02:23:50 <quicksilver> but it's somehow 'less' of an exception
02:24:07 <osfameron> ok, so the design goal is parsability over usability in this case?
02:24:21 <quicksilver> can't help feeling that, since they were in teh business of exceptions, they coul dhave just fixed it in the lexer
02:24:32 <quicksilver> osfameron: I think the design goal is uniformity with user-defined operators
02:24:34 <int-e> I'd be much happier with - being part of the lexical syntax, and have 0 -1 and 0 - 1 mean different things.
02:24:46 <quicksilver> osfameron: and user over-ridable classes
02:25:02 <quicksilver> int-e: yeah, fixing it in the lexer would have been 'less of a hack' and yet more effective :)
02:25:09 <quicksilver> int-e: easy to ahve hindsight though
02:25:29 <int-e> of course you'd lose being able to write (-x) for negating arbitrary expressions
02:25:32 <quicksilver> personally I'd be happy with ~ as a unary minus if it meant I could write (-2) as a section
02:25:33 <int-e> quicksilver: right
02:27:29 * DRMacIver likes ~ as unary minus
02:28:39 <int-e> sadly the position of ~ varies from font to font - here it's at the top of the line (it aligns with ") which makes ~1 look very funny.
02:29:28 <Wild_Cat> ~1 makes me think of DOS.
02:30:53 <quicksilver> int-e: wasn't that an old notation for -1 anyway? (minus sign written at the top of the line)
02:31:29 <int-e> dunno. it's none I've ever used though ;)
02:32:07 <osfameron> ah, sections vs unary minus
02:32:47 <int-e> @type (-1+)
02:32:49 <lambdabot> forall a. (Num a) => a -> a
02:32:57 <int-e> [warning: Hugs doesn't like this.]
02:33:18 <int-e> @type (+ -1)
02:33:23 <lambdabot>     The operator `+' [infixl 6] of a section
02:33:23 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
02:33:51 <quicksilver> stupid special cases everywhere
02:33:51 <int-e> that one works in hugs. ((-1)+) works in both.
02:34:53 <int-e> and the unary minus handling in the grammar is so complicated that I'm not sure who is right, although I believe it's ghc.
02:35:29 <int-e> (well. the whole precedence handling is complex. and unary minus had to bet fit in there soemwhere.)
02:35:43 <int-e> bet -> be
03:03:50 <danigm> hi,
03:04:02 <danigm> i have this error with hugs: ERROR - Garbage collection fails to reclaim sufficient space
03:05:57 <quicksilver> means you ran out of memory, I would guess
03:08:48 <ski> danigm : possibly you have an infinite loop ..
03:25:51 <Si> If I want to use plugins in GHC 6.6, is hs-plugins still the best way, because someone told me there was now a better alternative in GHC itself or something?
03:28:00 <quicksilver> Si: hs-plugins is the only way I know of to load .hs code at runtime
03:28:08 <Si> ok
03:28:11 <Si> thanks
03:28:20 <quicksilver> Si: if you're just talking about compiled code as plugins it might be possible to dynload() it directly
03:28:29 <quicksilver> not sure about the details or the x-platformness
03:40:17 <ToRA> bit of a vague question, but does anyone know if there were any known issues with the openg/glut bindings under ghc-6.6 that were fixed under 6.6.1?
03:40:22 <bringert> Si: you can use the GHC API instead of hs-plugins
03:43:32 <bringert> Si: I have an example here: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/
03:43:35 <lambdabot> Title: Index of /~bringert/darcs/dyn-cgi
03:43:40 <Si> bringert: does that have any advantages?
03:44:20 <bringert> Si: with the GHC API you can interpret code, instead of compiling and loading
03:44:34 <bringert> Si: you also don't need an extra-library
03:44:46 <bringert> Si: but I think hs-plugins has better documentation
03:45:29 <Si> does hs-plugins work well with existentially quantified types?
03:46:55 <quicksilver> bringert: Oh, I didn't know that
03:47:04 <quicksilver> bringert++
03:48:40 <bringert> Si, quicksilver: here's a demo of a wab app that dynamically interprets haskell code: http://csmisc14.cs.chalmers.se/~bjorn/dynhs/examples/wiki/wiki.hs
03:48:44 <lambdabot> Title: Main
03:48:59 <Cheery> does haskell have some sort of universal library for handling compressed Binary?
03:49:35 <Cheery> in Data.Binary itself, there seemed to be compression for gz
03:49:36 <ndm> @where binary
03:49:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
03:49:51 <Cheery> does it also have such for zlib and deflate?
03:50:23 <ndm> ask dons or dcoutts, i think dcoutts was investigating this stuff
03:50:51 <dblhelix> ndm: have you already decided on de bruijn indices and such?
03:51:25 <ndm> dblhelix: no, i think i may stick without them - just names as strings
03:51:59 <bringert> Cheery: Igloo has implemented deflate in pure haskell
03:53:00 <bringert> Cheery: see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bzlib and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/compression
03:53:08 <bringert> the first two are by dcoutts
03:54:40 <danigm> i have a new type problem, IO Bool does not match with Bool, how can i solve it?
03:54:50 <nornagon> a <- foo
03:54:59 <nornagon> :t (>>=)
03:55:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:55:22 <nornagon> in IO, that's IO a -> (a -> IO b) -> IO b
03:57:25 <bringert> danigm: see http://www.haskell.org/tutorial/io.html
03:57:26 <lambdabot> Title: A Gentle Introduction to Haskell: IO
04:10:23 <gleb> Hi all! Has anyone tried integrating Djinn with Emacs? I have no experience with Emacs-lisp at all but I thought it should be easy to start with some simple inferior-djinn-mode, using inf-haskell.el as example. However, I quickly stumbled on the following problem: on Win32, if I run Djinn in emacs buffer using make-comint function, Djinn crashes after any input (BTW, is this place appropriate for such kind of questions?)
04:19:20 <ndm> gleb: fine place for that sort of question
04:19:34 <ndm> gleb: and no idea as to the answer :)
04:20:05 <gleb> ndm: thanks anyway ^)
04:20:40 <ndm> gleb: if you ask at the right moment, the author of djinn may even respond ( augustss )
04:22:46 <gleb> ndm: Yes, it seems he's online now. I'm just not sure, where to start for narrowing down the problem: emacs or djinn. It seems to be djinn-related, because I have a bunch of inferior-mode's that work fine
04:23:00 <ndm> gleb: can you crash djinn?
04:23:23 <gleb> no, if I start it from cmd.exe or Cygwin's bash, it just works
04:24:38 <gleb> ndm: my previous reply was addressed to you. I'm an IRC newbie
04:24:55 <ndm> gleb: thats fine, i have no idea really - i'm not an emacs person
04:27:19 <gleb> ndm: thanks for answering. I'll be waiting for emacs person
04:27:48 <ndm> gleb: you can always ask on the haskell-cafe mailing list if none show up
04:28:25 <gleb> ndm: Seems like a good idea
04:34:03 <hpaste>  arcatan pasted "Parsec: is there an nicer way to say this?" at http://hpaste.org/1852
04:34:55 <beelsebob> arcatan: don't use monadic parser combinators?
04:35:42 <arcatan> what then?
04:35:52 <beelsebob> chris occosaci's ones?
04:36:02 <beelsebob> or you could code your own non monadic ones in 5 mins
04:36:05 <beelsebob> I've got some somewhere
04:36:19 <beelsebob> not sure what other non-monadic ones there are
04:36:21 <chrismbrown> beelsebob: what are chris occosaci's?
04:36:46 <beelsebob> chrismbrown: Chris Occosaci's evil 6th order parser combinators?
04:37:35 <chrismbrown> sounds interesting
04:38:20 <hpaste>  beelsebob pasted "Some non-monadic parser combinators" at http://hpaste.org/1853
04:38:30 <beelsebob> arcatan: note the <*> combinator
04:38:49 <beelsebob> the idea is that your first parser returns a function that combines itself with the other half
04:40:04 <chrismbrown> nea
04:40:06 <chrismbrown> *neat
04:40:24 <beelsebob> arcatan: they do you?
04:40:51 <chrismbrown> I'm guessing <|> is option and <*> is sequencing
04:40:56 <beelsebob> yep
04:41:26 <chrismbrown> does he have a paper about this?
04:41:44 <beelsebob> that's not Chris's
04:41:52 <beelsebob> that's some that Olaf and I bodged together
04:41:57 <beelsebob> Chris's are much more efficient
04:42:01 <beelsebob> let my try and find the paper
04:42:15 <chrismbrown> great, thanks.
04:42:26 <beelsebob> http://journals.cambridge.org/download.php?file=%2FJFP%2FJFP8_02%2FS095679689800300Xa.pdf&code=42a001c22fb9cb6ee4a6c55bf429b91c
04:42:29 <lambdabot> http://tinyurl.com/yunukk
04:43:18 <arcatan> looks nice. I think I'll stick with Parsec, though.
04:43:44 <chrismbrown> arcatan: this way you don't need monads at all though, surely thats a good thing?
04:44:06 <beelsebob> it's not necessarily not needing monads that is useful
04:44:20 <beelsebob> it's the way the combinators end up wirtten out
04:44:20 <edwardk> not sure why ditching monads is a win ;)
04:44:32 <chrismbrown> beelsebob: well, exactly
04:44:34 <beelsebob> in that example you get rid of the phony sequencing
04:44:45 <beelsebob> and replace it with essentially just written out BNF
04:44:49 <beelsebob> which has got to be a win
04:44:56 <arcatan> I'm just trying to keep LOC down
04:45:07 <beelsebob> arcatan: yeh, that example would be reduced to 1 LoC
04:45:14 <quicksilver> For me, the attraction of parser combinators was always to write code which looks like BNF
04:45:17 <beelsebob> 1 LoC that accurately reflects the BNF of your grammar
04:45:22 <chrismbrown> beelsebob: I might play around with this a bit further, I wonder if I can incorporate it into some of my refactorings actually
04:45:23 <quicksilver> in that light, parsecd is quite a disappointment
04:45:31 <quicksilver> parsec syntax is a long way from that goal
04:45:36 <edwardk> personally, i tend to like the sweirstra & duponcheel style arrow parsers
04:45:51 <beelsebob> edwardk: do you have a link to that?
04:45:55 <chrismbrown> i usually just use good old primitive recursion ;)
04:46:02 <beelsebob> don't think I've met that one
04:46:36 <edwardk> one second
04:47:22 <edwardk> http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf talks about it quite a bit
04:47:37 <beelsebob> cool, thanks
04:47:40 <beelsebob> I'll get staring at that
04:47:44 <edwardk> which is where arrows were introduced ;)
04:47:48 <beelsebob> indeed
04:47:53 <beelsebob> so it's good reading material anyway :)
04:48:01 <edwardk> so if you need to understand arrows thats also good starting material for that =)
04:48:13 <quicksilver> http://scholar.google.com/scholar?hl=enq=%20swierstra%20duponcheel
04:48:15 <lambdabot> Title: Google Scholar, http://tinyurl.com/38xol4
04:48:16 <quicksilver> it's the first hit
04:48:21 <beelsebob> edwardk: my principal reason for non-monadic ones is that I tend to find that monads are used in a lot of places they shouldn't
04:48:27 <quicksilver> bah, that didn't work
04:48:29 <beelsebob> for example, logically, parsing is not a sequential operation
04:48:32 <quicksilver> http://scholar.google.com/scholar?hl=en&client=firefox-a&rls=org.mozilla:en-US:official&hs=OHv&resnum=0&q=%20swierstra%20duponcheel&ie=UTF-8&oe=UTF-8&um=1&sa=N&tab=ws
04:48:34 <lambdabot> Title: swierstra duponcheel - Google Scholar, http://tinyurl.com/2l47rv
04:48:42 <beelsebob> so I don't see any reason to use an abstraction that's principally about sequencing
04:48:52 <beelsebob> quicksilver: thanks :)
04:49:11 <earthy> beelsebob: there is a fundamental thing you cannot do with parser combinators unless you have a monadic bind for your parsers
04:49:27 <beelsebob> earthy: what's that?
04:49:29 <beelsebob> fail?
04:49:33 <earthy> nope
04:49:38 <earthy> the complement parser
04:49:46 <beelsebob> which is what?
04:50:05 <earthy> pNotSymbol 'a'  which should parse anything which is *not* an 'a'
04:50:07 <quicksilver> on the other hand, if you *do* have a monad, then you can't possibly make it invertible
04:50:15 <quicksilver> and invertible parsing is neat
04:50:27 <earthy> this requires either an instance of bounded so that you can enumerate all symbols
04:50:34 <beelsebob> uhhuh
04:50:34 <earthy> or a monadic bind on your parsers
04:50:39 <beelsebob> okay
04:50:46 <beelsebob> why do you need one of them?
04:50:48 <earthy> (and this is just an exmaple)
04:50:52 <beelsebob> it doesn't need to be bounded
04:50:54 <Cheery> bringert: seems like it'd lack inflate
04:51:02 <chrismbrown> I don't see why you need a monad to do that
04:51:06 <beelsebob> it can be dynamically bounded based on what is in the input stream
04:51:10 <earthy> beelsebob: if you don't have bounded you need to be able to inspect the value under the parser
04:51:17 <beelsebob> (you don't need to try and parse things that aren't there)
04:51:22 <olsner_> quicksilver: invertible as in backwards, or as in matching all that's not in the language?
04:51:22 <earthy> and change the parser behaviour based on that
04:51:33 <quicksilver> olsner_: invertible as in backwards
04:51:40 <quicksilver> olsner_: as in, pretty-printer comes for free
04:51:41 <earthy> this you cannot do unless you have something that allows you to implement bind
04:52:03 <olsner_> aah, unparsing
04:52:18 <beelsebob> earthy: I suspect if I looked at this (guessing here), I'd probably end up implementing bind, but never calling it bind
04:52:24 <beelsebob> i.e. I wouldn't call it a monad
04:52:27 * earthy nods
04:52:35 <beelsebob> because I don't think calling it a monad is useful in terms of thinking about it
04:52:41 * earthy nods
04:52:58 <earthy> given e.g. pSucceed :: a -> Parser a
04:53:15 <earthy> (which parses the empty string returning value of type a in the parser)
04:53:21 <olsner_> aka return ;-)
04:53:22 <beelsebob> in that so far your description of it does not involve sequencing
04:53:37 <earthy> and e.g. <*> :: p (a -> b) -> p a -> p b
04:53:44 <earthy> with p a parser
04:53:45 <quicksilver> I don't really think monads are about sequencing, either, earthy
04:53:58 <earthy> you might want to also have pLookahead :: p Symbol
04:54:15 <beelsebob> quicksilver: the problem I hit here is that I have met two kinds of people in here
04:54:15 <earthy> which would give you the current lookahead symbol
04:54:24 <beelsebob> those who say monads are a "sequencing abstraction"
04:54:33 <earthy> however, there is no way to get the Symbol 'out' from under the parser
04:54:36 <beelsebob> and those who cannot accurately describe what the monad abstraction is about
04:54:47 <earthy> so there's not really much you can do with the lookahead symbol
04:54:49 <beelsebob> i.e. those who just say "well, they're things with return and bind"
04:55:10 <edwardk> heh
04:55:16 <beelsebob> and seeing as the latter is not a useful abstraction
04:55:20 <beelsebob> I concentrate on the former
04:55:24 <earthy> ah, but monads *are* about sequencing
04:55:27 <beelsebob> which is a useful abstraction
04:55:30 <beelsebob> just not in this case
04:55:34 <earthy> however, the they do not state *what* they sequence
04:55:51 <beelsebob> earthy: yeh, my point is that parsing is not logically a sequential process
04:56:03 * earthy nods
04:56:03 <quicksilver> I would say, monads are about hiding plumbing
04:56:03 <beelsebob> you do not describe your language in a sequential way
04:56:13 <quicksilver> the reader monad has nothing to do with sequencing
04:56:15 <beelsebob> quicksilver: you can hide plumbing without monads
04:56:19 <quicksilver> of course
04:56:21 <quicksilver> I don't deny it
04:56:32 <edwardk> they can be used for sequencing, they aren't always about sequencing though
04:56:32 <earthy> but there may be points in which you want to make a sequential choice
04:56:36 <quicksilver> however they turn out to be a surprisingly powerful way of hiding common plumbins under one roof
04:56:58 <earthy> 'if you have parsed up to here and x is in the input, continue with y, else continue with z'
04:56:59 <beelsebob> quicksilver: true
04:57:01 <earthy> e.g.
04:57:14 <beelsebob> but often they are not the only way of hiding that plumbing
04:57:16 <beelsebob> nor are they the best way
04:57:26 <beelsebob> because they introduce some idea of sequencing to the programmer's head
04:57:27 <edwardk> sure, but the sugar is convenient ;)
04:57:48 <quicksilver> they don't introduce any idea of sequencing into my head
04:58:01 <beelsebob> quicksilver: you appear to be one of very very few people who say that
04:58:03 <quicksilver> however, they do unfortunately introduce some sequence into my code
04:58:12 <quicksilver> which is a shame, but then again code is linear
04:58:23 <beelsebob> code is not necessarily linea
04:58:23 <earthy> a >>= b   really *does* induce sequencing in my mind
04:58:32 <chrismbrown> the problem I see with Monads is that they are often an unnecessary complication.
04:58:33 <earthy> 'first do a, and with the results under a, do b'
04:58:57 <quicksilver> earthy: right, but that's a data dependency
04:59:06 <earthy> oh, yeah, not a control flow dependency
04:59:07 <edwardk> that is an artifact of how the IO and ST monads work though earthy
04:59:18 <quicksilver> earthy: what that really means is 'do enough of a to get the results needed by b'
04:59:23 <olsner_> I'd like a parser monad that generates grammars that can be modified programmatically, rather than parsers that can be run
04:59:25 <quicksilver> earthy: it is no more (or less) sequenced than f(g(x))
04:59:27 <earthy> edwardk: is it, really? there is *no* way for b to work unless a has done work
04:59:38 <beelsebob> quicksilver: which is a bit misleading
04:59:42 <quicksilver> earthy: in the sense that f needs the result of g before it can run
04:59:44 <earthy> quicksilver: I know, but that is sequenced as well
04:59:46 <beelsebob> because you may need to do none of a to do all of b
04:59:47 <quicksilver> earthy: except that it might not :)
05:00:11 <quicksilver> in a lazy language, a >>= b may never inspect its value
05:00:14 <quicksilver> and a may never 'be done'
05:00:14 <earthy> it might throw away all that a does which results in a not being evaluated
05:00:17 * earthy knows
05:00:35 <beelsebob> quicksilver: actually, that definition of bind is slightly out
05:00:49 <beelsebob> it actually means "construct a computation, that when execute does enough of a to do b"
05:01:11 <earthy> however, if a ever gets evaluated, b is always evaluated after
05:01:25 <earthy> anyway, that's just my view
05:01:26 <beelsebob> earthy: depends if a is a shared constant or not
05:01:29 <quicksilver> beelsebob: yes
05:01:40 <quicksilver> earthy: you're confusing two things
05:01:55 <quicksilver> earthy: >>= implies (but does not mandate) a data dependency
05:02:08 <quicksilver> earthy: and data dependencies sequence evaluation, in  a lazy language
05:02:32 <earthy> but if it doesn't mandate the dependency, the presence of the >>= is unnecessary
05:02:37 <quicksilver> earthy: it *may* also enforcing sequence *because* of the properties of *this* *particular* monad
05:02:55 <quicksilver> earthy: and, IO, for example, emphatically does have a sequencing thing going on there
05:02:59 <quicksilver> but not all monads are like that
05:03:02 * earthy knows
05:03:07 <earthy> [] is a prime example
05:03:53 <quicksilver> right. There is no particular evaluation order in [1,2,3]>>[4,5,6]
05:04:00 <quicksilver> either could in principle be done first
05:04:08 <Baughn> Trying to compile hs-plugins, I get a parse error in src/AltData/Typeable.hs:452
05:04:11 <earthy> anyway, intuitively, I get more from reading sequencing into >>= than I get from reading 'it's a monad' into >>=
05:04:13 <edwardk> data Blackhole a; instance Monad Blackhole where return a = Blackhole; a >>= b = Blackhole is a pretty boring monad but should meet all the laws, never even peeks at a or b
05:04:27 <Baughn> I see it isn't a new problem, but I can't find a solution. What /does/ it compile right under?
05:04:41 <edwardk> er data Blackhole a = Blackhole
05:05:04 <earthy> that's a pretty shitty monad, edwardk.
05:05:04 <earthy> :)
05:05:07 <edwardk> =)
05:05:16 <edwardk> its not one i find in literature =)
05:06:17 <earthy> looks to me like it's the constant functor to 1
05:06:33 <earthy> with the monadic operators defined on it
05:06:38 <earthy> which will obviously work
05:06:43 <earthy> but is not very interesting
05:06:52 * beelsebob sits back and watches everyone argue over what the meaning of bind is, smug in the knowledge that monads are a bad abstraction
05:07:02 <beelsebob> :P
05:07:06 <chrismbrown> ;)
05:07:08 <edwardk> yeah
05:07:14 <DRMacIver> Trivial instances are often interesting because they're useful for providing counterexamples. ;)
05:07:15 <earthy> beelsebob: for some things: yes! they are a very bad abstraction
05:07:17 * Baughn tries and fails to compile hs-plugins
05:07:22 <earthy> for others, not so
05:07:28 <beelsebob> earthy: yeh, sorry, I should have qualified that a bit
05:07:36 <beelsebob> they're a fucking excellent abstraction for IO
05:07:39 <beelsebob> and for State
05:07:49 <beelsebob> but less good for parsers imho
05:07:52 <chrismbrown> yes, but in my opinion the wrong way to model it
05:07:53 <edwardk> i like them as an abstraction for DSELs
05:07:55 * earthy fully agrees
05:08:07 <chrismbrown> in imperative languages you get the IO monad for free, look at Erlang
05:08:15 <LoganCapaldo> but but Parsec makes me giddy
05:08:16 <edwardk> they are fairly easy to get your head around, and they admit transformers
05:08:18 <earthy> however, there is 1 thing that monadic parsers can do that parsers that do not allow bind cannot
05:08:24 <LoganCapaldo> how can they be a bad abstraction for parsers?
05:08:49 <ClaudiusMaximus> Baughn: hs-plugins-rc0 + ghc-6.6 == ouch; tried the darcs version of hs-plugins?
05:08:53 <earthy> logancapaldo: they encourage a non-grammatical style of parsing
05:09:00 <beelsebob> edwardk: I think the discussion here by a group of experienced Haskell programmers indicates that they are in no way easy to get your head around
05:09:04 <edwardk> logan: well, for example the optimizations for a sweirstra/duponcheel parser combinator library can't be used in a monadic framework
05:09:29 <earthy> edwardk: there's a certain S. D. Swierstra that doesn't fully agree with that
05:10:02 <edwardk> earthy: hrmm
05:10:06 * earthy is going to pressure him into writing all this shit down this summer
05:10:17 <edwardk> would be glad to read it
05:10:17 * earthy might even help :)
05:10:20 <edwardk> heh
05:10:28 <beelsebob> some day I'll write my parser tutorial
05:10:34 <earthy> (depending on if my current boss will allow me to)
05:10:40 <Baughn> ClaudiusMaximus: I have not. It seems illogical that it would work with 6.6, when the older -rc0 works with 6.6.1 and not 6.6
05:10:41 <beelsebob> that I think unlike all the other 1000000 out ther will concentrate on when not to use them
05:10:49 <edwardk> heh
05:11:02 <Baughn> ClaudiusMaximus: I'll be trying to get a system based on 6.6.1 working now, though. Lambdabot is as annoying as usual. :/
05:11:10 <LoganCapaldo> well you can have my monadic parser combinators when you pry it from my cold dead fingers, figuratively speaking :)
05:11:41 <ClaudiusMaximus> Baughn: oh, i only tried rc0 with 6.4.2, and darcs with 6.6; haven't tried 6.6.1 on anything yet
05:12:11 <Baughn> ClaudiusMaximus: Everything seems to work with 6.6.1, except lambdabot. OTOH, lambdabot doesn't work with 6.6 either. >_<
05:13:43 <earthy> beelsebob: such as when, exactly? :)
05:14:12 <beelsebob> earthy: whenever your computation is not logically thought of as sequential
05:15:55 <earthy> that's when you don't want monads, but you just said something about parsers...
05:16:16 <beelsebob> hmm?
05:16:22 <earthy> 14:09 < beelsebob> some day I'll write my parser tutorial
05:16:28 <beelsebob> fail
05:16:32 <beelsebob> s/parser/monad
05:16:35 <earthy> ah ;)
05:16:36 <beelsebob> brain fail
05:16:43 <DRMacIver> beelsebob: If you pardon the somewhat wossname answer, I think that monads are an excellent abstraction for things other than sequencing. The problem, which I think you are seeing indirectly, is that the concept which they abstract is 'monad' :)
05:17:13 <Baughn> ClaudiusMaximus: IMO, the various devs are far too fond of breaking API compatibility
05:17:22 <beelsebob> DRMacIver: the problem with that is that there is no intuative understanding of a 'monad'
05:17:35 <beelsebob> in order for an abstraction to be useful the programmer has to gain something from it
05:17:40 <earthy> well, I do have another intuitive understanding that is other than 'sequencing'
05:17:41 <beelsebob> usually an understanding of what's going on
05:17:55 <earthy> but that is the concept of 'carrying baggage'
05:18:14 <DRMacIver> beelsebob: Intuition arises through familiarity. Therefore a lack of intuition about something is not inherently a problem with that something.
05:18:14 <beelsebob> yes, but monads are not the only way of carrying baggage about
05:18:31 <edwardk> i still like sigfpe's statement of it as a form of taint
05:18:39 <beelsebob> DRMacIver: yes, but if I come along trying to maintain your code
05:18:46 <beelsebob> I am not familiar with it
05:18:53 <earthy> no, but they are the only way of carrying baggage around that lets you basically calculate with the things without baggage unharmed
05:18:54 <DRMacIver> beelsebob: Then you'd better know what an if statement does too. ;)
05:18:56 <beelsebob> the point of an abstraction is to give me some familiar things to grab onto
05:19:02 <edwardk> http://sigfpe.blogspot.com/
05:19:04 <lambdabot> Title: A Neighborhood of Infinity
05:19:06 <quicksilver> The most convincing example of monad, for me
05:19:15 <earthy> for abstract values of 'unharmed'. :)
05:19:16 <quicksilver> is the 'gubbins' you carry around when type-checking a language
05:19:20 <DRMacIver> Maths is full of abstract definitions which you can handwave all you like to provide justification for, but ultimately the meaning of them is simply their definition.
05:19:22 <beelsebob> the if abstraction for example gives me something to grasp onto -- the way "if" works in my human language
05:19:23 <quicksilver> that includes unique number supply
05:19:26 <matthew-_> earthy: they're not the only way, and in fact, they're not usable if you have constraints with monads can't cope with, eg arrows
05:19:29 <quicksilver> a free variable environment
05:19:31 <edwardk> the top couple of articles use some trivial monads to describe a monad in terms of a taint that you can't remove
05:19:33 <quicksilver> and a current set of constraints
05:19:37 <quicksilver> and *yet*
05:19:38 <DRMacIver> Expecting other equally abstract disciplines to lack this feature is at best naive.
05:19:39 <mux> I found the metaphor to be most enlightening to imperative programmers is 'programmable semi-colon'
05:19:45 <quicksilver> there is nothing remotely sequential about that
05:20:02 <beelsebob> DRMacIver: so what exactly does using the monad abstraction give you
05:20:04 <mux> many other metaphors fall short quickly
05:20:09 <beelsebob> if it doesn't give you understanding
05:20:23 <edwardk> mux heh nicely phrased
05:20:25 <mux> like, monads are for sequencing, or for side-effects which are both wrong
05:20:43 <mux> even though they are useful for those things
05:21:08 <earthy> matthew-: there are certain calculations that you cannot do with non-monadic arrows that you can with monads though
05:21:21 <osfameron> yes, but you should start with those abstractions until they fall short, no?
05:21:28 <Laney> ..
05:21:33 <mux> not sure about that
05:21:38 <DRMacIver> beelsebob: It encapsulates a common pattern which one can prove and understand general things about. Note that I didn't say 'people shouldn't try to understand monads'. I'm just saying that natural language handwaving isn't the way to do so.
05:21:39 <osfameron> well, like learning Chemistry at school
05:21:40 <earthy> basically what the monad laws guarantee is that you have injection and function application and that those behave nicely with regard to eachother
05:21:56 <osfameron> every year you go back and they tell you "what you learnt last year was bollocks"
05:22:06 <edwardk> osfameron: hehehe
05:22:23 <earthy> but anyway, back to preparing for class this evening
05:22:26 <beelsebob> DRMacIver: except that 100% of the times I've seen monads used it's actually been harder to reason about the program with monads than it is without them
05:22:35 <matthew-_> earthy: right. Sorry, all I was trying to say is that I've recently had a case where it felt like a monad, and behaved like a monad, yet wasn't a monad because I needed a monad class with an awful lot more type params
05:22:49 <beelsebob> because sequencing stuff instantly gives you problems in maths
05:23:00 <mux> osfameron: except that it's not really that what you learnt previously was bollocks, it was just simplifications that were still true assuming a few things
05:23:04 <quicksilver> beelsebob: that just sounds like FUD, to be honest
05:23:06 <chrismbrown> I only ever find Monads useful when I need to do I/O. I have found no other use for them.
05:23:11 <mux> osfameron: a bit like newton theory vs einstein theory
05:23:15 <earthy> matthew-: ah, yeah, but that *is* a monad given a context
05:23:19 <quicksilver> beelsebob: just unroll the definitions of return and bind
05:23:24 <quicksilver> beelsebob: it's all pure functional
05:23:24 <earthy> it's just that you cannot make it an instance of Control.Monad
05:23:25 <osfameron> mux: well, yeah, I'm, er, simplifying for (dubious) comedic value a little
05:23:30 <matthew-_> earthy: absolutely
05:23:36 <beelsebob> quicksilver: certainly, but not all functional programs are equal
05:23:36 <mux> newton's theory isn't bollocks, it's an approximation of the truth that is relatively right with some specific assumptions
05:23:41 <edwardk> matthew: did you see oleg's trick for that?
05:23:44 * earthy has hit that problem a couple of times as well
05:23:47 <mux> osfameron: right, I see your point
05:23:48 <quicksilver> (people used to program in monadic style before explicit monad support existing in languages)
05:23:53 <beelsebob> quicksilver: I can write hard to reason about functional programs, and easy to reason about ones
05:23:56 <matthew-_> earthy: but I noticed that what I ended up with was closer to (>>>) than (>>)
05:24:03 * earthy nod
05:24:06 <earthy> s
05:24:09 <matthew-_> ;)
05:24:13 <DRMacIver> beelsebob: Given that monads aren't about sequencing, I don't see how "sequencing stuff instantly gives you problems in maths" is an issue for reasoning about them. ;)
05:24:28 <earthy> edwardk: I'd rather not increase my oleg-reading too quickly ;)
05:24:37 <mux> heh
05:24:42 <beelsebob> DRMacIver: because 99% of the time monads are used for sequencing (whether it's needed or not)
05:24:48 <edwardk> earthy actually iirc it was written up by someone non-oleg, looking...
05:24:49 <DRMacIver> But I admit I've not tried to do heavy duty reasoning about monadic programmings.
05:25:01 <matthew-_> edwardk: no, I'd love to see that
05:25:10 <edwardk> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
05:25:13 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
05:25:35 <edwardk> i had a similar issue when i wanted to be able to require Read and Show on terms i was carrying around with arrows
05:25:35 <mux> oh, the thing about restricted monads
05:25:38 <edwardk> yeah
05:25:43 * osfameron will work through the monad tutorial onces he's worked through SOE
05:25:43 <mux> which aren't 100% polymorphic in their 'a'
05:25:52 <edwardk> *nods*
05:25:59 <osfameron> assuming that I don't just magically get it from doing exercises in SOE
05:26:21 <edwardk> they are monads over a more restricted category than the category of all types
05:26:39 <earthy> osfameron: I've never went through SOE :)
05:27:18 <osfameron> earthy: it's well worth the time.  Reading it gave me an overview of syntax and potential, but actually doing the exercises is giving me an idea that I could use it to do real stuff
05:27:27 <dcoutts_> nominolo: hia, sorry we got cut off last night, my net connection disappeared
05:27:41 <nominolo> dcoutts_: hi. np
05:28:07 <ekidd> Morning.
05:28:12 <nominolo> dcoutts_: was any of it helpful?
05:28:24 <dcoutts_> nominolo: I'm just reading the logs
05:28:26 <nominolo> @localtime ekidd
05:28:28 <lambdabot> Local time for ekidd is 2007-05-15 08:27:38 -0400
05:28:47 <ekidd> Hah. It's clever, lambdabot is.
05:28:50 * nominolo has "fika"
05:29:38 <earthy> osfameron: do you know about http://www.cs.uu.nl/dazzle/ ?
05:29:39 <lambdabot> Title: Dazzle
05:29:40 <matthew-_> edwardk: ok, my case doesn't fit under there. I have (>>) :: (Blah a -> m (r, Blah b)) -> (Blah b -> m (r', Blah c)) -> (Blah a -> m (r', Blah c)). And return :: r -> Blah a -> m (r, Blah a). So the problem is the extra param in Blah
05:29:55 <earthy> I did maintenance on that :)
05:30:01 <edwardk> ah
05:30:33 <dcoutts_> nominolo: so have you tried getting a gdm trace from a simple gtk2hs hello world?
05:30:46 <nominolo> dcoutts_: no, a ktrace
05:30:52 <nominolo> dcoutts_: i guess that's less useful
05:31:08 <dcoutts_> nominolo: we'd like a C stack trace to identify which lib is at fault
05:31:23 <nominolo> dcoutts_: maybe i should re-familiarize with gdm
05:31:27 <dcoutts_> nominolo: a really really minimal hello world, like just making a window and widgetShow
05:31:28 <matthew-_> edwardk: i.e. if you drop the r then it becomes very similar to >>>. and in practise, the m is always IO. But there didn't seem to be any choice other than to roll my own.
05:31:39 <nominolo> yep, that would certainly more useful
05:31:48 <nominolo> dcoutts_: yes, the error happens withing showAll
05:32:04 <earthy> oh, right, *that* oleg trick as written up by ekidd ;)
05:32:06 <dcoutts_> nominolo: just gdb a.out; then in gdb say run; when it segfaults the command you want is 'bt' for backtrace
05:32:11 <earthy> I'd seen that yeah
05:32:23 <edwardk> hrmm
05:32:28 * earthy feels dirty from reading it again
05:32:33 <dcoutts_> nominolo: I suspect the error happens in the font code but probably because of corruption caused by ghc or gtk2hs.
05:32:35 <ekidd> Heh.
05:32:35 <edwardk> what is the r carrying about?
05:32:45 <edwardk> earthy: =P
05:32:47 <ekidd> Poor earthy. :-)
05:32:48 <nominolo> dcoutts_: k, i'll give it a shot
05:33:16 * earthy should just learn epigram or something ;)
05:33:27 <edwardk> just more burden for the type system, and it lets you build monads over restricted categories
05:34:08 <edwardk> i cobbled something together for arrows that way, but it was too messy for me to release because i had to break 'arrow' up into soo many pieces
05:34:18 <matthew-_> edwardk: r is the "actual" result, a la a in m a where m is Monad
05:34:29 <matthew-_> edwardk: everything else is plumbing
05:34:40 <nominolo> !paste
05:34:40 <hpaste> Haskell paste bin: http://hpaste.org/
05:34:41 <edwardk> hrmm
05:35:27 <hpaste>  nominolo pasted "gtk2hs helloworld gdb backtrace" at http://hpaste.org/1854
05:35:30 <edwardk> so its something like wadler's parameterized monads?
05:35:38 <edwardk> and your (>>) is changing the parameter?
05:35:46 <matthew-_> it's really no big deal - I've written my own >~>, >~>= and returnS and they behave as I want, and I can lift any IO function in, it's just I never made it fit under haskell's basic Monad
05:35:56 <edwardk> yeah
05:36:17 <matthew-_> edwardk: err, I've not read wadler's parameterized monads, but it sounds like it might be it
05:36:33 <matthew-_> the param is basically the type of the state
05:37:09 <matthew-_> so (Blah a -> m (r, Blah b)) is really saying "I'm a funtion that takes state Blah a and transforms it to state Blah b and produces a result r"
05:37:44 <dcoutts_> nominolo: right, as I suspected. You see the error is happening deep inside gtk->pango->fontconfig
05:37:49 <edwardk> *nods*
05:37:54 <matthew-_> so >> has to be transitive - (Blah a -> Blah b) -> (Blah b -> Blah c) -> (Blah a -> Blah c)
05:38:02 <edwardk> i can see how that wouldn't fit the monadic plumbing
05:38:19 <matthew-_> yeah, I could either make return work or >>= work, but not both at the same time!
05:38:26 <dcoutts_> nominolo: this is probably caused by memory corruption, and we need to find the offender.
05:38:37 <nominolo> dcoutts_: maybe a confused argument order?
05:38:42 <nominolo> dcoutts_: oh
05:39:11 <dcoutts_> nominolo: so a couple test cases we could try, a C Gtk hello world, and a minimal ghc Gtk hello world (ie ffi importing only the functions we need, not using gtk2hs)
05:39:57 <dcoutts_> nominolo: I'll try and prepare some test cases and get back to you.
05:40:10 <nominolo> dcoutts_: ok, thanks
05:54:59 <nominolo> anyone know how to forward the stderr output to a file?
05:55:05 <nominolo> (in bash)
05:55:11 <ibid> 2>file
05:56:15 <nominolo> ah, thanks, i tried ">2" :)
05:57:44 <ibid> what i never seem to remember is 2>&1 or 2&>1 :)
05:59:21 <shapr> me too
05:59:37 <quicksilver> break it down
05:59:45 <quicksilver> '2>' means 'redirect fd 2'
05:59:46 * shapr starts beatboxing
05:59:48 <shapr> oh
06:00:00 <quicksilver> '2>file'  --> fd 2 goes to file
06:00:07 <quicksilver> '2>&1' --> fd 2 goes to fd 1
06:00:37 <ibid> (my directories are full of files called "1")
06:00:43 <shapr> So & means fd?
06:02:16 <joelr1> good day
06:02:29 <joelr1> folks, how do you give extra -I arguments to cabal?
06:02:46 <chessguy> 'morning haskellers
06:02:52 <shapr> hiya joelr1
06:02:57 <shapr> g'mornin chessguy
06:03:09 <Apocalisp> moin
06:03:12 <chessguy> hiya shapr
06:03:15 <bringert> morning joelr1
06:03:25 <chessguy> nice nick, Apocalisp
06:03:27 <bringert> joelr1, you can set $CPATH
06:03:56 <joelr1> bringert: i'm deploying my app at my hosting provider now. note that i removed the link to hope from the bottom but i plan to put the credits in the technology or about section a little later /once i have that section/
06:04:04 <joelr1> bringert: do you mind?
06:04:08 <bringert> joelr1, no problem
06:04:13 <olsner_> dons: did you ever start on that shell/terminal/other misc haskell project?
06:05:19 <bringert> joelr1: did you pull the sessions patch?
06:05:49 <bringert> joelr1: without it, your sessions table can become pretty big, which slows down everything
06:06:32 <quicksilver> shapr: in the limited context of 'how to refer to a field descriptor when the shell is expecting a file name', & is the sign for fd
06:06:40 <joelr1> bringert: when did you post the patch? i pulled this morning
06:06:54 <joelr1> bringert: can you put two paths into CPATH?
06:08:11 <joelr1> hmm... googling for CPATH is pointless
06:09:21 <shapr> quicksilver: ok, thanks.
06:09:27 <joelr1> actually, i think using ':' as a separator works fine
06:09:46 <migraine> too many XML parser choices...
06:09:59 <Apocalisp> Thanks, chessguy.
06:11:03 <Apocalisp> It's a scheme to end all lisp.
06:11:28 <LoganCapaldo> groooooooan
06:13:22 <dcoutts_> nominolo: http://haskell.org/~duncan/gtk2hs/testcases/
06:13:23 <lambdabot> Title: Index of /~duncan/gtk2hs/testcases
06:13:41 <joelr1> bringert: is there a CPATH for libraries?
06:13:53 <dcoutts_> nominolo: so these should be the same program, one in C, one in Haskell (not using gtk2hs)
06:14:27 <Apocalisp> migraine: I have one piece of advice for parsing XML: don't.
06:14:30 <dcoutts_> nominolo: and we want to see if the Haskell one segfaults in show_all
06:16:11 <nominolo> dcoutts_: let's see if i can build the C program.  the /opt/local/include dir is not flattened
06:16:23 <nominolo> dcoutts_: i.e. i have to specift
06:16:42 <nominolo> * specify all the stuff included from gtk/gtk.h
06:17:00 <dcoutts_> nominolo: in both cases it should be: gcc/ghc $source -o $output $(pkg-config --cflags --libs gtk+2.0)
06:17:13 <dcoutts_> erm $(pkg-config --cflags --libs gtk+-2.0)
06:17:19 <dcoutts_> with the '-'
06:17:52 <joelr1> dcoutts_: how do you pass LIBDIR to ghc?
06:17:59 <ndm> migraine: what do you want to do?
06:18:08 <dcoutts_> joelr1: -L$LIBDIR
06:18:11 <gleb> Hello everyone. I already asked earlier today about my problem: Djinn crashes, if I try to run it in Emacs buffer (it gives prompt, waits for input, and dies on any input).  I hacked Djinn's sources a bit to add some wuick & dirty logging, and now I have a suspect: System.Console.readline. Has anyone any idea why readline crashes (Win32, GHC-6.6, Cygwin) when the program is run from Emacs? It works fine under shell.
06:18:27 <osfameron> earthy: nope, not come across that, bookmarking for later - you involved in it?
06:18:33 <nominolo> hm, wait, "gtk+"?
06:19:03 <earthy> osfameron: was, not currently
06:19:03 <joelr1>  dcoutts_: is ther e a way to supply that using cabal?
06:19:11 <joelr1> dcoutts_: i.e. to runhaskell Setup.. build
06:19:18 <earthy> (they are kinda low-ish on funding)
06:19:21 <SamB_XP_> nominolo: isn't that GTK 1.2 or something?
06:19:38 <osfameron> earthy: it's a bayes network browser for Spam and general classification tasks ?
06:19:40 <dcoutts_> joelr1: you can put library dirs in the .cabal file, there's a field for it
06:19:52 <earthy> it's a general bayes network editor
06:19:53 <nominolo> dcoutts_: i just realized, i have gtk-2.0 installed using macports, and gtk+ installed using fink
06:20:04 <earthy> it probably won't deal with spam based networks too well though ;)
06:20:06 <joelr1> dcoutts_: right! will lok
06:20:12 <nominolo> dcoutts_: or not gtk+. can this be the issue?
06:20:17 <dcoutts_> joelr1: see the cabal manual
06:20:22 <earthy> but it wasn't meant to, so that's fine
06:20:37 <dcoutts_> nominolo: gtk+/gtk it's the same thing, but you do probably have two different versions installed
06:21:14 <dcoutts_> nominolo: 10 years ago there was a gtk that was distinct from gtk+, but now people often contract gtk+ to gtk as an alias.
06:22:23 <dcoutts_> SamB_XP_: even gtk 1.2 was "GTK+" GTK without the + was the thing developed for the GIMP.
06:23:11 <quicksilver> gleb: maybe Console.readline doesn't like TERM=DUMB?
06:23:50 <dcoutts_> nominolo: I've also added a HelloGtk2Hs.hs to the collection at http://haskell.org/~duncan/gtk2hs/testcases/
06:23:50 <lambdabot> Title: Index of /~duncan/gtk2hs/testcases
06:24:08 <gleb> quicksilver: well maybe. I wonder what can I do about that (sorry for lame questions, never used readline myself)
06:24:31 <quicksilver> gleb: which OS are you using?
06:24:42 <gleb> Windows 2003 Server
06:24:45 <quicksilver> hmm
06:24:54 <quicksilver> not sure then, sorry :(
06:25:17 <dcoutts_> nominolo: so if HelloGtk2Hs.hs segfaults but Hello.hs doesn't then I'll make another version half way in between the two, by pulling out the bits of Gtk2Hs that are used by the test case.
06:25:20 <gleb> quicksilver: do you have any ideas for any OS?
06:25:35 <nominolo> dcoutts_: ok, i'll give it a try
06:32:00 <quicksilver> gleb: well OSX comes with a rather limited (somewhat broken, indeed) version of readline which has caused me troubles in the past
06:32:07 <quicksilver> gleb: I doubt that's the problem you're seeing though
06:33:52 <hpaste>  gleb pasted "readline + win32 + emacs = crash" at http://hpaste.org/1855
06:37:50 <Saizan> hpaste: does it work if you compile that program and you run it from a cmd.exe loaded in a buffer?
06:38:13 <Saizan> s/hpaste/gleb/
06:38:53 <nominolo> dcoutts_: hello.c and Hello.hs work, but don't terminate when i close the window.  no segfaulting, though
06:39:26 <gleb> Saizan: just tried it. Yes, it crashes
06:40:44 <nominolo> dcoutts_: HelloGtk2Hs.hs doesn't build
06:40:54 <nominolo> /usr/bin/ld: Undefined symbols: _gtkzm0zi9zi11_GraphicsziUIziGtkziAbstractziContainer_containerAdd_closure _gtkzm0zi9zi11_GraphicsziUIziGtkziAbstractziWidget_widgetShowAll_closure [...]
06:40:54 <nominolo>  
06:41:05 <dcoutts> nominolo: use -package gtk
06:41:16 <dcoutts> or --make
06:41:49 <mux> dcoutts: hi there :-)
06:42:01 <dcoutts> hia mux
06:42:02 <nominolo> dcoutts: ok, they all work
06:42:37 <dcoutts> nominolo: oh, so what failed then? the slightly less trivial gtk2hs hello world?
06:42:47 <dcoutts> nominolo: what was it that was failing originally?
06:42:59 <mux> dcoutts: just one quick question: if I need to call a C API that expects a pointer on pointer, because it is allocating some structure itself and setting the pointer to point to it, how would you do that?  should I malloc the pointer?
06:43:03 <nominolo> dcoutts: the demo/hello/ program
06:43:11 <dcoutts> nominolo: and that still fails?
06:43:21 <mauke> mux: yes
06:43:37 <mauke> s/malloc/alloca/, though
06:43:45 <mux> I'd need to keep it
06:43:49 <dcoutts> mux: yes, alloca as mauke says
06:43:55 <mux> alloca allocates on the stack?
06:44:06 <gleb> Saizan, quicksilver: thanks for responding, I'll try posting to cafe
06:44:07 <mux> so I would lose it after returning from the function or something?
06:44:10 <dcoutts> mux: then you read the ptr out of the space allocated by alloca
06:44:23 <mux> oh, ok
06:44:31 <mux> I guess this is more efficient
06:44:33 <mux> cheers guys!
06:44:39 <dcoutts> @hoogle with
06:44:40 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
06:44:40 <lambdabot> Network.withSocketsDo :: IO a -> IO a
06:44:40 <lambdabot> Distribution.PackageDescription.withExe :: PackageDescription -> (Executable -> IO a) -> IO ()
06:45:28 <quicksilver> gleb: yes, that's the best plan I suspect
06:46:55 <gleb> quicksilver: it's a bit of pain to use open-source tools coming from unix world on windows.
06:47:05 <jbauman> 2
06:47:08 <jbauman> ooops
06:47:52 <nominolo> d'oh
06:48:00 <quicksilver> gleb: I believe it is, no personal experience of that though :)
06:48:00 <nominolo> dcoutts: the problem was the makefile
06:48:08 <dcoutts> nominolo: oh?
06:48:14 <nominolo> if i compile it the same way i compiled the others, it works
06:48:24 <nominolo> i got no link errors, though
06:48:33 <dcoutts> what makes it break then?
06:48:47 <nominolo> no idea
06:49:03 <nominolo> i assume one lib is missing
06:51:35 * koeien just found out how useful literate haskell is
06:51:44 <dcoutts> nominolo: that would not cause segfaults, only linker errors
06:52:01 <dcoutts> nominolo: can you reproduce the segfault with anything now?
06:53:13 <nominolo> dcoutts: yes, if I remove all the $(pkg-config ...) stuff it builds and then breaks
06:53:13 <nominolo> i.e. using the original makefile
06:53:13 <nominolo> if I build it with the pkg-config stuff it works
06:53:57 <dcoutts> nominolo: you mean doing "ghc --make World.hs -o helloworld" in the gtk2hs/demo/helloworld builds and links ok but then segfaults?
06:54:33 <quicksilver> you get segfaults sometimes if you have conflicting libraries linked indirectly together
06:54:46 <quicksilver> if A links to B version 1.0, and A links to C which links to B version 1.1
06:54:53 <quicksilver> then two copies of B are pulled in and *bang*
06:54:55 <nominolo> !paste
06:54:55 <hpaste> Haskell paste bin: http://hpaste.org/
06:55:05 <quicksilver> didn't nominolo say earlier he thought he had two versions of gtk around?
06:55:06 <dcoutts> yes, I expect if we had some strange mix of versions going on it'd all fall apart
06:55:12 <dcoutts> he did, yes
06:55:28 <dcoutts> and I wonder which one gtk2hs was built against and which it is using
06:55:33 <hpaste>  nominolo pasted "gtk2hs makefile" at http://hpaste.org/1856
06:56:15 <nominolo> quicksilver: i don't think so.  it were just the package infos (i *think*)
06:56:27 <dcoutts> nominolo: ah, so you're linking against a different version of gtk
06:56:47 <dcoutts> nominolo: your failing case you're pulling in, possibly two versions by using the pkg-config stuff
06:57:11 <nominolo> no the pkg-config thing _works_
06:57:16 <dcoutts> nominolo: you don't want to use the pkg-config flags when using the test cases that import Graphics.UI.Gtk
06:57:28 <nominolo> it's when i don't pull anything in that it fails
06:57:37 <dcoutts> nominolo: oh well, that's probably because it's using a different version of gtk from the one that ghc -package gtk is using
06:58:06 <dcoutts> nominolo: can you @paste the output of both pkg-config --cflags --libs and also ghc-pkg describe gtk
06:58:24 <dcoutts> nominolo: you can annotate your existing paste
06:58:36 <dcoutts> rather than creating a new one
06:59:08 <nominolo> k
07:00:40 <hpaste>  nominolo annotated "gtk2hs makefile" with "describe gtk output" at http://hpaste.org/1856#a1
07:01:13 <nominolo> arg, cut off
07:02:00 <hpaste>  nominolo annotated "gtk2hs makefile" with "ghc-pkg second try" at http://hpaste.org/1856#a2
07:02:33 <dcoutts> nominolo: try pruning the huge exposed-modules list, that bit isn't interesting anyway
07:02:46 <hpaste>  nominolo annotated "gtk2hs makefile" with "part 2" at http://hpaste.org/1856#a3
07:04:23 <hpaste>  nominolo annotated "gtk2hs makefile" with "pkg-config" at http://hpaste.org/1856#a4
07:04:52 <dcoutts> nominolo: the main difference I see is that pkg-conf gtk+-2.0 --libs gives us -L/opt/local/lib but that's not included in the gtk package info
07:05:01 <Si> I'm having trouble with hs-plugins, it's giving me "internal error: stg_ap_v_ret" when I try and load a plugin within my Main program.
07:05:08 <dcoutts> nominolo: which means we may be linking to the wrong gtk libs
07:05:36 <Si> Setup I've got is a type defined in a module API, with a module Plugin generating a value of this type and Main trying to load the plugin
07:05:48 <dcoutts> nominolo: try one of the simple hello test cases but edit the flags you get from pkg-config to leave off -L/opt/local/lib and see if you get the segfault
07:06:16 <dcoutts> nominolo: so you built gtk2hs from source yourself or via ports/fink?
07:06:33 <nominolo> gtk2hs was built from source
07:06:45 <nominolo> and all the haskell stuff goes to /usr/local/
07:06:55 <nominolo> (the hand built stuff)
07:07:03 <dcoutts> nominolo: I'm wondering why the gtk package info would be missing the -L/opt/local/lib as that seems likely to be the source of the problem, that we're picking up the wrong gtk libs out of the two sets you've got installed.
07:07:04 <nominolo> the ports stuff goes to /opt/local/
07:07:34 <nominolo> dcoutts: actually, i'm not sure i have two versions installed
07:08:21 <euzxx> http://magegame.ru/?rf=53617264656c6b61
07:08:25 <lambdabot> Title: -    
07:09:14 <nominolo> dcoutts: do you know the command to find out if a package is installed with apt-get?
07:09:25 <dcoutts> nominolo: no, sorry
07:10:03 <kombinator> dcoutts: Is there any quick cabalisation guide?
07:10:11 <Wild_Cat> random question (probably an FAQ, at that): are Haskell Strings unicode?
07:10:52 <dcoutts> kombinator: I think there's one in the wikibooks collection
07:11:23 <koeien> nominolo: dpkg --status PACKAGE
07:11:44 <dcoutts> kombinator: http://en.wikibooks.org/wiki/Haskell/Packaging
07:11:45 <kombinator> dcoutts: it's a bit thorough, but well, will go through it
07:12:07 <koeien> nominolo: then second line, "Status: install ok installed" for example
07:12:17 <kombinator> dcoutts: oh, that I didn't see
07:13:34 <kombinator> dcoutts: thanks
07:13:53 <nominolo> dcoutts: ok, i do have two versions
07:15:15 <nominolo> koeien: thanks, i used finkcommander ;)
07:18:20 <Si> am I to take it that hs-plugins doesn't work properly on GHC 6.6 (or at least on amd64)?
07:19:05 <DRMacIver> Nothing works properly on amd64 :)
07:19:16 <ndm> Si - no GHC 6.6 at all
07:21:02 <dcoutts> Si: I think Lemmih fixed it up to work with 6.6, but I'm not sure it's been released
07:22:05 <Si> http://darcs.haskell.org/~lemmih/hs-plugins/?
07:22:07 <lambdabot> Title: Index of /~lemmih/hs-plugins
07:25:59 <hpaste>  nominolo annotated "gtk2hs makefile" with "verbose output diff" at http://hpaste.org/1856#a5
07:27:37 <syntaxfree> you can't persuade someone to change THEIR minds or to change HIS mind?
07:27:44 <syntaxfree> syntax question. Tee hee.
07:28:07 <quicksilver> 'their mind'
07:28:10 <quicksilver> not 'their minds'
07:28:14 <syntaxfree> thanks.
07:28:15 <quicksilver> (only one person, I presume)
07:28:35 <quicksilver> (if it was multiple people it would be their minds)
07:28:36 <syntaxfree> I'm doing this job application and it requires writing a few answers in english.
07:28:45 <quicksilver> (damn it I'm trapped in these parentheses again)
07:28:45 <syntaxfree> My english grammar is 99% okay, but I didn't want to slip that one.
07:29:28 <quicksilver> some english teachers will tell you that 'their' may not be singular
07:29:28 <quicksilver> these english teachers are wrong
07:29:28 <quicksilver> however, they will say it :)
07:29:28 <quicksilver> so you have to choose your battles a bit on that point
07:29:39 <sjanssen> @pl (damn it I'm trapped in_ these parentheses again)
07:29:40 <dcoutts> nominolo: and what were the command lines for those two?
07:30:01 <nominolo> dcoutts: my two makefile targets, with ghc -v
07:30:07 <sjanssen> @botsnack
07:30:17 <lambdabot> damn it I'm trapped in_ these parentheses again
07:30:17 <lambdabot> :)
07:30:21 * ndm hands quicksilver an operator prescendence rule
07:30:42 <nominolo> dcoutts: AFAICS they're the same modulo argument order/duplication
07:31:05 <dcoutts> nominolo: aye, we should try and narrow it down
07:31:44 <dcoutts> nominolo: so the gtk package info gives rise to some of the final linker flags, and the $(COPTS) you pass give rise to some of the others
07:31:55 <dcoutts> nominolo: we need to figure out which are significant
07:32:06 <dcoutts> nominolo: we could start by just comparing the two
07:32:24 <dcoutts> nominolo: how about the glib package info?
07:32:43 <dcoutts> nominolo: since gtk deps on glib and so the flags from both packages get used
07:33:34 <syntaxfree> a drive to minimal effort solutions or a drive to minimal-effort solutions?
07:34:17 <dcoutts> nominolo: you could try wit just ghc -package gtk $< -o $@ -L/opt/local/lib
07:34:47 <nominolo> dcoutts: k
07:36:13 <nominolo> YAY!
07:36:48 <nominolo> dcoutts: good hunch
07:36:55 <nominolo> now both work
07:37:36 <dcoutts> nominolo: so where do the other gtk libs live? presumably without -L/opt/local/lib the other broken versions are being picked up first
07:37:52 <syntaxfree> @botsnack
07:37:53 <lambdabot> :)
07:37:55 <syntaxfree> @botsnack
07:37:55 <lambdabot> :)
07:37:59 <syntaxfree> @protontorpedo
07:38:00 <lambdabot> waht is this D&D
07:38:04 <syntaxfree> @protontorpedo
07:38:04 <lambdabot> that dude is selling u  a book
07:38:26 <syntaxfree> @protontorpedo
07:38:26 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
07:38:39 <sjanssen> @keal
07:38:40 <lambdabot> all i know is i have experienced my own death unhappening...
07:39:50 <SamB_XP_> paul graham is sometimes pretty silly...
07:40:17 <SamB_XP_> if he's dead, then why was he bothering #ai a bit back
07:40:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1857
07:40:52 <mauke> isLecturerOf :: String -> Lehrveranstaltung -> Bool
07:40:53 <mauke> :(
07:41:17 <mux> gah, I know C full well, I know a fair bit of haskell, but c2hs/FFI still manages to confuses me much
07:41:25 <quicksilver> awesome
07:41:26 <dcoutts> nominolo: so actually what we want to figure out is why isn't the standard gtk build process picking up these flags correctly from pkg-config
07:41:40 <nominolo> dcoutts: hm, fink stuff is in /sw/lib/
07:41:47 <dcoutts> nominolo: can you also paste the 'ghc-pkg describe glib' output
07:42:57 <dcoutts> nominolo: we need to track down if the -L/opt/local/lib is missing from gtk/glib ghc package descriptions and if so why.
07:44:16 <nominolo> dcoutts: no, it's there
07:44:25 <dcoutts> nominolo: I'll be back a bit later
07:44:43 <hpaste>  nominolo annotated "gtk2hs makefile" with "describe glib" at http://hpaste.org/1856#a6
07:46:44 <SamB_XP_> mux: what are you having trouble with
07:50:56 <mux> SamB_XP_: I'm trying to sort it all in my head, currently fighting with {#pointer #}, not sure I should use two separate types Foo and FooPtr or if I should just have Ptr Foo, etc
07:51:53 <mux> also, the c2hs docs mention some use of the pointer hooks which end up defining stuff such as
07:51:56 <mux> newtype Object = Object (Ptr Object)
07:51:59 <mux> which I can't make much sense of
07:53:07 <SamB_XP> what would *you* do for pointers to incomplete types?
07:53:44 <mux> SamB_XP: I don't understand that question
07:53:51 <mux> pointers to incomplete types?
07:54:04 <SamB_XP> have you heard of FILE?
07:54:12 <mauke> s/FILE/void/
07:54:15 <mauke> :-)
07:54:20 <mux> ah, yes, of course
07:54:26 <mux> so?
07:55:30 <SamB_XP> probably there is a "typedef struct _FILE FILE;" in a header, but no definition of "struct _FILE".
07:55:41 <mux> I know all this
07:55:44 <mauke> there probably is
07:55:49 <mux> the C part is not what's confusing me
07:56:33 <mux> could you rather explain me the meaning of the Object newtype I pasted erlier?
07:56:36 <SamB_XP> yeah. so what kind of Haskell type would *you* use for a FILE?
07:57:09 <mux> I'd probably just use Ptr (), I don't know
07:57:15 <mux> I'm not even dealing with such kind of types here.
07:57:42 <SamB_XP> well, this is also usefull when the identity matters...
07:58:39 <SamB_XP> actually, I think the use of Object in Ptr Object is just because Object is a handy unique type...
07:58:44 <shapr> Is there a way to change a chunk in darcs? For example, I want the first line of one chunk to be the last line of the chunk before it.
07:59:29 <ejt> hi, anyone here got xmonad working ?
07:59:33 <mux> oh well
07:59:54 <SamB_XP> mux: you could just as well use a newtype over () ...
07:59:58 * osfameron gets depressed wanting to rewrite some horrid perl code a minion is wrangling with haskell lazy lists...
08:00:00 <arcatan> o/
08:00:01 <SamB_XP> for the argument to Ptr
08:00:08 <arcatan> ejt: #xmonad might be more helpful regarding xmonad
08:00:14 <ejt> thx
08:00:21 <mux> SamB_XP: sure.
08:00:28 <mux> SamB_XP: that's not really answering my question :-P
08:00:55 <SamB_XP> mux: what was the question again?
08:01:03 <mux> the recursiveness of the definition of the newtype Object confuses me
08:01:09 <mux> my question was could you explain this to me :-)
08:01:23 <SamB_XP> well, okay. I didn't remember before, but...
08:01:29 <SamB_XP> it isn't actually recursive ;-P
08:01:43 <mux> I hope it isn't, but how does this work then?
08:01:53 <SamB_XP> @src Ptr
08:01:53 <lambdabot> data Ptr a = Ptr Addr#
08:02:03 <SamB_XP> see, Ptr doesn't actually use its parameter for anything
08:02:12 <mux> aah, that's the bit
08:02:14 <mux> thanks
08:02:27 <quicksilver> the parameter is there for type checking
08:02:29 <SamB_XP> now, if Object were an instance of Storable...
08:02:32 <quicksilver> but it doesn't 'exist' as such
08:02:46 <mux> now that makes a lot more sense
08:02:54 <mauke> struct Object { struct Object *Object; };  // OMG RECURSION
08:03:52 <SamB_XP> now, I don't have any idea why Object isn't a newtype...
08:04:24 <_frederik_> does anyone use newForeignPtrEnv?
08:04:30 <_frederik_> it doesn't work for me
08:04:57 <mux> SamB_XP: hmm? it is a newtype
08:08:39 <SamB_XP> mux: oh nevermind
08:08:47 <SamB_XP> you mentioned data earlier
08:09:11 <mux> so, given that I'm going to need to peek/poke at the structure's internals, I think I don't need to use {#pointer #}, its only use would be to have an alias for Ptr Foo such as FooPtr
08:09:15 <mux> am I correct?
08:09:42 <SamB_XP> mux: I have no idea about c2hs ;-)
08:09:49 <mux> damn :-)
08:10:44 <mux> SamB_XP: you know about FFI though? is there no CUInt32 ?
08:10:57 <mux> or, more generally speaking, are there no C99 fixed-width types in the FFI?
08:12:11 <mux> the structure I'm dealing with has uint32_t fields - well, u_int32_t but that doesn't really matter
08:12:25 <olsner> isn't that Word32?
08:14:18 <mux> olsner: well that would be the Haskell side of it, I guess
08:32:49 * shapr boings cheerfully
08:32:58 <shapr> ejt: xmonad works for me!
08:33:06 <ejt> y, got it working thx
08:33:11 <ejt> using it now, very nice
08:33:19 <ejt> just the thing to run in a VM
08:42:42 <araujo> shapr, yeah!
08:42:58 <araujo> shapr, just started using it?
08:52:22 <ejt> @seen dmhouse
08:52:23 <lambdabot> I saw dmhouse leaving #haskell-blah and #haskell 21h 40m 41s ago, and .
08:56:51 <Wild_Cat> okay, I must be missing something obvious. Is there a way to do some simple pattern matching on a String? Something in the lines of foo "hello":xs = xs ?
08:57:23 <Igloo> No
08:57:30 <ejt> only 'h':'e':'l':'l':'o':x
08:57:35 <ejt> which isn't nice
08:57:57 <ejt> You could just use a guard and isPrefixOf
08:58:02 <Wild_Cat> hmm... That's too bad. :/
08:58:36 <Igloo> ejt: But then you have to do more work to find xs
08:58:58 <Igloo> You can use pattern guards and a dropPrefix :: String -> String -> Maybe String. I should really put that in a library, I keep on defining it
09:00:06 <ejt> case splitAt 5 of; ("hello", xs) -> etc
09:00:35 <Igloo> Yeah, but then you have to keep 5 and "hello" in sync
09:01:01 <Igloo> | Just xs <- dropPrefix hello s    doesn't have that problem
09:01:42 <ejt> true
09:05:59 <quicksilver> Igloo++
09:06:01 <quicksilver> that's nice
09:08:48 <MyCatVerbs> @pl (\x->(*x))
09:08:49 <lambdabot> (*)
09:09:14 <MyCatVerbs> @pl (\x l->l ++ map x l)
09:09:14 <roconnor> @pl \x -> (x*)
09:09:14 <lambdabot> ap (++) . map
09:09:15 <lambdabot> (*)
09:09:29 <MyCatVerbs> :t ap
09:09:29 <roconnor> @pl flip (*)
09:09:34 <lambdabot> (*)
09:09:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:10:56 <kpreid> @pl knows that (*) is commutative
09:10:57 <lambdabot> knows that (*) is commutative
09:12:05 <kpreid> @pl flip that demonstrates English text can be valid Haskell
09:12:06 <lambdabot> that English demonstrates text can be valid Haskell
09:12:11 <kpreid> er
09:12:25 <kpreid> @pl pl demonstrates flip English that text can be valid Haskell
09:12:25 <lambdabot> pl demonstrates flip English that text can be valid Haskell
09:12:32 * kpreid gives up
09:13:22 <roconnor> @pl pl demonstrates flip $ English that text can be valid Haskell
09:13:23 <lambdabot> pl demonstrates flip (English that text can be valid Haskell)
09:13:37 <roconnor> @pl pl demonstrates $ flip English that text can be valid Haskell
09:13:38 <lambdabot> pl demonstrates (English text that can be valid Haskell)
09:13:42 <norpan> is it really a requirement on * that it is commutative
09:16:07 <kpreid> I don't find such a requirement in the http://www.haskell.org/onlinereport/
09:16:08 <lambdabot> Title: The Haskell 98 Language Report
09:16:54 <arcatan> @pl <3
09:16:54 <lambdabot> (line 1, column 1):
09:16:55 <lambdabot> unexpected "<"
09:16:55 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:17:05 <arcatan> :)
09:17:14 <kpreid> @pl (<3)
09:17:15 <lambdabot> (< 3)
09:17:25 <kpreid> pl breaks hearts!
09:18:12 <Syzygy-> Hehe
09:20:02 <chessguy> @remember kpreid @pl (<3) -- pl breaks hearts!
09:20:02 <lambdabot> Done.
09:24:37 <edwardk> @pl this is pointless
09:24:37 * shapr boings cheerfully
09:24:37 <lambdabot> this is pointless
09:24:48 <edwardk> heya shapr
09:24:57 <shapr> Hiya edwardk! What's up?
09:25:07 <Syzygy-> Hey shapr
09:25:21 <edwardk> not much
09:25:57 <edwardk> spotted a nice little application rule for polymorphic records and variants to annihilate each other in my language project
09:26:08 <edwardk> so my core calculus got a lot simpler again
09:26:37 <kpreid> @pl let not = id in this (is not pointfree)
09:26:38 <lambdabot> this (is id pointfree)
09:26:49 <kpreid> @pl let not = id in this is (not pointfree)
09:26:49 <lambdabot> this is pointfree
09:28:50 <edwardk> which basically fits in nicely with the value/continuation application rules
09:33:03 <edwardk> G |- E1 : { l1 : ~T1, ..., ln : ~Tn }  G |-  E2 : <l1 T1, ... ln Tn>  ==>  G |- E1 E2 : _|_ (substitute an arbitrary function type (->r) for ~ if you want and r for _|_ if you don't like thinking about continuations is variant case analysis. and G |- E3 : <l1 ~T1, ..., ln ~Tn>     G |- E4 : {l1 : T1, ..., ln : Tn }   ===>  G |- E3 E4 : _|_ is lookup by field name
09:34:01 <edwardk> so record polymorphism gives extensible cases, and in the dual gives extensible variants ala MLPolyR but only one elimination and introduction form needed for each
09:34:05 <edwardk> makes a clean core
09:36:17 <edwardk> also gives me the weird ability to carry around named properties on 'function-like' things by side-effect, which i'm not sure about how it would work
09:36:27 <shapr> hiya Syzygy-
09:36:45 <shapr> edwardk: Do you have any blog posts or full descriptions of your language project?
09:36:54 <edwardk> not yet
09:37:05 <edwardk> i really should start writing some stuff up
09:37:08 <shapr> edwardk: I'm sure you've described it to me completely if I could fit together all the different times we've talked, but I forget stuff..
09:37:11 <edwardk> but the syntax has been so fluid its been hard
09:37:28 <edwardk> mostly been focusing on getting the core right
09:37:40 <edwardk> surface syntax has been completely replaced 3-4 times ;)
09:37:43 <shapr> I'm not interested in syntax as much as I am in stuff like substructural type systems and nifty tricks like variants/records mix.
09:43:46 <shapr> edwardk: I didn't really get that application rule. I should probably go through TaPL again..
09:44:03 <edwardk> pretty much all (if not all) of the substructural type stuff i'm doing could be tracked in wadler/thiemann style effect monad (er, thats how i'm rewriting it now) over a simple type system with the lattice of substructural type annotations carried as a parameter on the monad, which is a pretty obvious monad using min over the lattice of substructural types as the monoid operation, but you'd need a weaker basic type so you can track things li
09:44:05 <edwardk> hrmm
09:44:11 <edwardk> ok lets look at the first one
09:44:48 <edwardk> what i want is something that behaves like a haskell case statement, i need to perform different cases based on what constructor i see, lets do something like 'sum'
09:46:31 <edwardk> sum = { cons (x,xs) = x + sum xs, nil () = 0 }               and then, (using the TaPL variant syntax)     mylist = <cons (1,<nil=()>)>    so sum mylist looks uses the 'label' of the constructor as the label in the polymorphic record to figure out what function to pass the arguments to the constructor to
09:47:05 <edwardk> if i had k-arity constructors (which pose an awkward problem of syntax) there is a similar construction i could use for those
09:48:55 <edwardk> sum :  fix a. { cons : (Int,a) , nil : () }     and mylist : fix a. <cons (Int,a), nil ()>
09:49:27 <edwardk> so the fields of the record are the names of the constructors it expects to annihilate with
09:49:55 <shapr> oh
09:50:03 <edwardk> by duality you can build a 'field lookup' operation the same way
09:50:15 <sjanssen> bos++ nice blog article
09:50:46 <david48> hello everyone.
09:51:04 <bos> sjanssen: thanks. bit embarrassing with the foldl/foldl' flub early on, though :-)
09:51:18 <shapr> edwardk: That's cool.
09:51:59 <david48> I need help on HSQL. Can I bother you guys ?
09:52:10 <edwardk> head = <x = \value -> value> { x = 10, y = 13 }  would be 'desugared' { x = 10, y = 13}.x
09:52:13 <bos> just ask away.
09:53:04 <edwardk> before i fully transformed it to CPS and lose the ability of lambda to return non-bottoms
09:53:27 <david48> I installed GHC 6.6.1 from the binary package. I downloaded and installed HSQL 1.7 ( I build HSQL and HSQL-mysql only ). I try a little program and it chokes on "import Database.HSQL.mysql".
09:54:03 <david48> module Main where
09:54:04 <david48> import Control.Exception
09:54:04 <david48> import System.Environment (getArgs)
09:54:04 <david48> import Database.HSQL
09:54:04 <david48> import Database.HSQL.mysql
09:54:05 <bos> are you using "ghc --make"?
09:54:11 <david48> no, ghci
09:54:16 <bos> hmm.
09:54:22 <david48> the error is :
09:54:26 <sjanssen> david48: "mysql" is the problem
09:54:36 <edwardk> head : <x (Int -> Int)>     { x = 10, y = 13} : { x : Int, y : Int } which by width subtyping is also { x = 10, y = 13 } : { x : Int }
09:54:39 <david48> db2.hs:6:7: parse error on input `Database.HSQL.mysql'
09:54:50 <edwardk> if that makes sense
09:54:53 <sjanssen> parts of module names start with capitol letters
09:55:41 <david48> right, if I capitalize mysql here's what I get :
09:55:41 <david48> db2.hs:6:7:
09:55:41 <david48>     Could not find module `Database.HSQL.Mysql':
09:55:41 <david48>       Use -v to see a list of the files searched for.
09:55:41 <david48> Failed, modules loaded: none.
09:55:58 <sjanssen> david48: check the docs for the correct spelling
09:55:59 <david48> the thing is, I build HSQL following cabal instructions.
09:56:08 <sjanssen> might be MySql, or MySQL, or something
09:57:06 <quicksilver> yay for capitalisation errors!
09:57:08 <edwardk> internally i take that and then transform it into lookup in a record at a fixed offset with a passed index parameter, stole the trick from Blume's MLPolyR, but i'm thinking about leaving it very close to my surface syntax rather than burying it in ML-like cruft
09:57:24 <david48> tryed with MySQL and it works. sorry to bother you with such a stupid question :(
09:58:06 <sjanssen> no problem
09:59:15 * allbery_b sighs at yet another gtk2hs snag
10:00:02 <dcoutts> allbery_b: mm?
10:00:18 <allbery_b> how do I use inputAdd?  I see no way to go from Handle or Fd to FD
10:00:24 <bos> dcoutts: how much work went into gtk2hs?
10:00:48 <allbery_b> (maybe grotting around to drag the CInt out of the Fd, if sufficient information is exported)
10:00:48 <dcoutts> bos: about 8 years by 10+ people on and off, why?
10:00:50 <bos> i've been looking at writing gstreamer bindings, but i feel The Nameless Dread of a project that will fill all of my spare time.
10:01:25 <dcoutts> bos: well it's much easier than it used to be
10:01:50 <dcoutts> bos: partly because we spent a long time understanding FFI and developing infrastructure
10:01:51 <bos> yeah. it's just that gstreamer is pretty big and complicated, much as gtk itself is.
10:02:26 <dcoutts> bos: though it's also quite regular and based on GObject
10:02:31 <bos> yes
10:02:51 <dcoutts> bos: and we have a code gen for C libs based on GObject
10:03:10 <bos> ooh, nice.
10:03:34 <dcoutts> bos: it was developed for gtk+ of course but works for other GObject based libs, with a little fiddling. It'd probably need extending to work with GStreamer
10:03:51 <dcoutts> bos: but it's pretty modular
10:04:52 <bos> dcoutts: good to know, thanks
10:05:05 <migraine> haxml or xml toolbox...
10:05:57 <malcolmw> migraine: depends on who you talk to
10:10:48 <shapr> I want a Serializer DSL!
10:11:25 <nominolo> @go pickler combinators
10:11:28 <lambdabot> http://lambda-the-ultimate.org/node/2243
10:11:29 <lambdabot> Title: Pickler Combinators | Lambda the Ultimate
10:11:40 <shapr> I want something that lets me write a mapping to/from Haskell and Data.Binary, SOAP, XML, ASN1, etc
10:11:47 <malcolmw> shapr: aren't there several candidates already?
10:11:57 <shapr> malcolmw: Like what?
10:12:20 <nominolo> shapr: maybe that paper can serve as a starting point?
10:12:47 <shapr> nominolo: Could be, I'll check it out, tack
10:13:02 <malcolmw> shapr: I seem to recall writing a set of binary serialisation combinators back in 1997, which several people have created variations on since. :-)
10:13:07 <shapr> malcolmw: For totally reversible mappings, the bi-directional arrows would be nice.
10:13:19 <shapr> What's the right word for totally reversible?
10:13:29 <malcolmw> invertible?
10:13:36 <shapr> Probably
10:13:42 <malcolmw> one-to-one and onto
10:13:46 <edwardk> or bijective
10:13:55 <shapr> I thought there was a word like idempotent that meant totally reversible.
10:13:55 <edwardk> brb
10:14:30 <shapr> Ah, bijective is exactly that, one-to-one and onto
10:14:42 <ari> Doesn't idempotent mean that one application == n applications?
10:14:56 <malcolmw> idempotent means self-applicable, with same result as if not-applied
10:15:16 <shapr> Yeah, but idempotent is (in my head) one of a group of words that have specific meanings like bijective.
10:15:26 <shapr> Ya know, associative, transitive, idempotent, etc.
10:15:34 <mdmkolbe|work> I think ari is correct, but I've sometimes seen it mean two applications are the same as no applications (i.e. it's self inverting)
10:15:34 <edwardk> idempotent f means f (f x) = f x
10:15:55 <edwardk> thats not self-inverting
10:16:00 <shapr> mdmkolbe|work: I don't think that's right.
10:16:01 <edwardk> self inverting would say that f (f x) = x
10:16:19 <mdmkolbe|work> edwardk: I agree, I've just seem some places miss-use it to mean that
10:16:20 <shapr> mdmkolbe|work: As in, idempotent means repeated applications of f are same as one application of f
10:16:38 <edwardk> idempotent would be something like full constant folding on a syntax tree, once its donem, if you do it again you get back the same tree
10:17:05 <edwardk> or 'floor', floor (floor x) = floor x
10:17:08 <shapr> nominolo: Oh, this looks good, thanks for the pointer!
10:17:15 <edwardk> afk
10:17:51 <mdmkolbe|work> Does ghc have a good syntax that allows a parameter to be unused (without emiting a warning) but still have a documented name?  "const value ignored = value" will generate a warning (as it should).  But "const value _ = value" hides potentially useful documentation (i.e. the name of the argument) (not useful in this case but in some it is).
10:17:52 <_frederik_> self-inverting? surely there is a better name
10:17:52 <mdmkolbe|work> In C99, I would solve this problem with "void const(int value, int /* ignored */) { return value; }", but the haskell equivalent, "const value _ {- ignored -} = value", makes it look like there was once an extra argument.
10:18:00 <kc5tja> @seen sorear
10:18:00 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 11h 18m 38s ago, and .
10:18:04 <shapr> _frederik_: Probably, but what?
10:18:40 <kc5tja> @tell sorear Make sure it's in the darcs repo, and I'll take a look tonight if I'm reminded.  I'll probably forget.  I also have Aikido too, so I won't be back until after 9PM or so.
10:18:40 <lambdabot> Consider it noted.
10:18:45 <emu> periodic
10:19:08 <emu> that's more  general though
10:19:45 <mdmkolbe|work> from #math, http://en.wikipedia.org/wiki/Involution
10:19:46 <lambdabot> Title: Involution - Wikipedia, the free encyclopedia
10:19:51 <_frederik_> shapr: involution
10:20:14 <_frederik_> ah, scooped
10:20:19 <mdmkolbe|work> quote from link, "In mathematics, an  involution, or an involutary function, is a function that is its own inverse, so that  f(f(x)) = x for all x in the domain of  f."
10:20:30 <mdmkolbe|work> _frederik_: yeah, but I cheated (asked on #math)
10:20:39 <shapr> Does anyone know if the pickler combinators source is available?
10:20:40 <_frederik_> nothing is cheating these days
10:21:11 <_frederik_> so, the identity is the only idempotent involution
10:22:14 <quicksilver> yes, htat's true :)
10:22:46 <mdmkolbe|work> _frederik_: sounds right (well excluding "const undefined"). x = f (f x) = f x => f = id
10:25:37 <quicksilver> mdmkolbe|work: const undefined is not an involution
10:27:01 <mdmkolbe|work> quicksilver: Heh, I guess you're right
10:30:03 <quicksilver> mdmkolbe|work: you might argue it's a 'weak involution' or something. A 'partial involution'.
10:35:09 <tom___> hi all, I've got a bit of a problem compiling Data.Binary from http://www.cse.unsw.edu.au/~dons/binary.html which I wonder if someone could help me with
10:35:10 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
10:35:46 <bos> tom___: wha's the problem?
10:35:55 <tom___> When I try to compile it using "runhaskell ./Setup.lhs build" I get "Could not find module `Data.ByteString':
10:35:57 <tom___>   use -v to see a list of the files searched for
10:35:59 <tom___>   (imported from src/Data/Binary.hs)
10:36:00 <tom___> "
10:36:12 <bos> did you run Setup configure beforehand?
10:36:13 <tom___> But I have got Data.ByteString installed
10:36:21 <tom___> yes, I did run configure first
10:36:29 <bos> what version of ghc?
10:36:42 <tom___> I canstart ghci in the same directory and type ":m +Data.ByteString" and it works fine
10:36:52 <tom___> 6.4.2
10:36:55 <bos> ah.
10:37:05 <tom___> Should I upgrade to 6.6?
10:37:16 <bos> i've never had any problems with 6.6.
10:37:23 <bos> (but use 6.6.1 instead, if you can.)
10:37:24 <tom___> (6.4.2 is where unbuntu's repositories are at right now)
10:37:29 <bos> i see.
10:37:39 <tom___> Ok, I'll go grab the soruce and compile
10:37:40 <bos> well, that's quite a lot out of date.
10:37:43 <tom___> thanks for the help
10:37:57 <bos> it could be that the version of Cabal included in 6.4.2 isn't up to snuff.
10:38:40 <Saizan> tom___: compiling ghc is quite a long task, you can get a generic-linux binary package on the download page instead
10:38:56 <tom___> thanks Saizan just saw that :p
10:39:03 <Saizan> k :)
10:43:50 <TomMD> Has anyone tried to build off the darcs repo lately?  I've had no luck getting a good build the other week.
10:49:31 * shapr grumbles at EC2
10:53:53 <encryptio> > fmap (1+) (Just 3)
10:53:59 <lambdabot>  Just 4
10:55:24 <quicksilver> > fmap (1+) (1+) $ 3
10:55:32 <lambdabot>  5
10:55:46 <encryptio> o.O
10:55:57 <quicksilver> ;)
10:55:57 <encryptio> :t fmap (1+)
10:56:01 <lambdabot> forall t (f :: * -> *). (Num t, Functor f) => f t -> f t
10:56:45 <nominolo> @src Functor (->)
10:56:46 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:57:08 <Saizan> @src ((->) r) fmap
10:57:08 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:57:18 <Saizan> @src fmap ((->) r)
10:57:19 <lambdabot> Source not found. That's something I cannot allow to happen.
10:57:33 <arcatan> @src elem
10:57:34 <lambdabot> elem x    =  any (== x)
10:57:37 <encryptio> huh
10:57:50 <nominolo> i assume it's (.) ?
10:58:03 <nominolo> no
10:58:04 <davidL> does there exist a faster `elem` ?
10:58:06 <Saizan> ?type (.)
10:58:11 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:58:19 <Saizan> nominolo: the types match ;)
10:58:55 <Saizan> davidL: you can have a O(log n) one if you use a Set
10:59:01 <encryptio> davidL: no, but you might want to look into alternative representations if that's your major need
10:59:04 <quicksilver> davidL: there is no way to write a general one for any Eq
10:59:11 <quicksilver> davidL: but there are other ways of doing it
10:59:15 <quicksilver> e.g. Data.Set
10:59:36 <davidL> is there a way to make a set without using fromList?
10:59:48 <nominolo> Saizan: yes it is
10:59:49 <quicksilver> yes; but why don't you like fromList?
10:59:59 <chessguy> ?src elem
10:59:59 <nominolo> does lambdabot have Google Code Search?
11:00:00 <lambdabot> elem x    =  any (== x)
11:00:12 <quicksilver> (you can make a set using singleton and union, for example)
11:00:22 <quicksilver> however this is no 'better' than fromList
11:00:27 <davidL> ah
11:00:41 <davidL> so fromList is not a bottleneck?
11:00:45 <quicksilver> nope
11:00:54 <davidL> I see
11:01:00 <quicksilver> remember in haskell a list is a control strcuture, too
11:01:17 <quicksilver> using 'fromList' is just 'using a loop' (by analogy to an imperative language)
11:01:28 <davidL> how much faster is IntSet than Set when dealing with [Int] ?
11:01:37 <quicksilver> much faster
11:01:51 <quicksilver> it has a really cute represenetation using bitmasks and bit arithemtic
11:02:28 <davidL> I will use IntSet then, thanks
11:02:37 <chessguy> ?hoogle intset
11:02:38 <lambdabot> Data.IntSet :: module
11:02:39 <lambdabot> Data.IntSet.IntSet :: data IntSet
11:02:43 <quicksilver> davidL: in particular, if you use fromList on the output of (say) a 'map'
11:02:53 <quicksilver> davidL: GHC will not actually create hte intermediate lists
11:03:01 <quicksilver> davidL: they're mostly optimised away
11:03:31 <davidL> quicksilver: is it better to do operations before fromList or after fromList using IntSet's functions?
11:03:44 <quicksilver> depends on the kind of operation
11:03:53 <davidL> say filter
11:03:53 <quicksilver> certain ones are very fast using intset's own operations
11:04:02 <quicksilver> so, if on doubt, prefer the intset ones
11:04:12 <quicksilver> without checking the sources I don't know exactly which are faster
11:05:00 <encryptio> > [1,2,3] >>= \x -> [x,-x]
11:05:01 <lambdabot>  [1,-1,2,-2,3,-3]
11:05:28 <nominolo> :t fmap (1+) (1+)
11:05:33 <lambdabot> forall t. (Num t) => t -> t
11:05:50 <nominolo> :t fmap (+)
11:06:06 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
11:06:13 <chessguy> > concatmap [1,2,3] $ \x -> [x,-x]
11:06:20 <lambdabot>   Not in scope: `concatmap'
11:06:22 <davidL> quicksilver: are there ever cases where performing an operation on a list is faster then performing the same operation on a Set?
11:06:26 <chessguy> > concatMap [1,2,3] $ \x -> [x,-x]
11:06:32 <shapr> How hot does it get in .au? Does it get over 45 C?
11:06:34 <lambdabot>  Couldn't match expected type `a -> [b]'
11:06:36 <Saizan> flip?
11:06:47 <chessguy> > flip concatMap [1,2,3] $ \x -> [x,-x]
11:06:54 <lambdabot>  [1,-1,2,-2,3,-3]
11:07:09 <nominolo> davidL: head ?
11:07:52 <Saizan> well, Set has a O(n) toList  :)
11:08:18 <nominolo> davidL: head, tail, insertAtHead, ..
11:08:23 <davidL> is head O(1) for a list?
11:08:30 <Saizan> yes
11:08:36 <nominolo> @src head
11:08:37 <lambdabot> head (x:_) = x
11:08:37 <lambdabot> head []    = undefined
11:08:53 <davidL> and O(n) for a Set?
11:09:00 <nominolo> O(log n)
11:09:13 <nominolo> though, head is not really defined
11:09:28 <nominolo> you can take the leftmost (min) and rightmost (max) element
11:09:57 <encryptio> :t join seq
11:09:59 <lambdabot> forall a. a -> a
11:10:03 <nominolo> @src Set.findMin
11:10:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:10:12 <nominolo> @src findMin
11:10:12 <lambdabot> Source not found. Where did you learn to type?
11:10:35 <davidL> ?src Data.Set.filter
11:10:36 <lambdabot> Source not found. Are you on drugs?
11:10:44 <Saizan> ?docs Data.Set
11:10:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
11:11:41 <nominolo> davidL: one pretty important limitation is, though, that Data.Set needs an Ord instance (actually a _total_ order)
11:11:47 <Saizan> if you can choose i'd filter before using fromList
11:13:31 <davidL> alright
11:14:19 <nominolo> dcoutts: what would be the benefit of finding out what caused my problems with gtk2hs?  i have the feeling it's something completely stupid and would rather not bother searching for it.
11:14:36 <davidL> I haven't read the docs yet but is the basic difference between a list and a Set that with a Set all data is stored in memory?
11:15:03 <sjanssen> not really
11:15:11 <sjanssen> Set is a binary tree, [] is a linked list
11:15:17 <nominolo> davidL: a list is a linear structure.  a set is implemented as a balanced binary tree
11:15:45 <davidL> oh
11:15:48 <nominolo> and may not have duplicates (i think).  other than that it's mainly different tradeoffs
11:15:50 <chessguy> and a Set won't allow duplicates, right?
11:15:57 <sjanssen> right
11:16:06 <davidL> well my memory spiked when I used a Set
11:16:15 <nominolo> > S.insert 2 (S.singleton 2)
11:16:16 <lambdabot>   Not in scope: `S.insert'
11:16:20 <sjanssen> that could be for a number of reasons
11:16:31 <sjanssen> davidL: but yes, Set is a fairly strict data structure
11:16:49 <TomMD> Adding [n..m] for m >> n to a set could do that.
11:16:55 <chessguy> > Data.Set.insert 2 (Data.Set.singleton 2)
11:17:06 <lambdabot>  fromList [2]
11:17:18 <chessguy> eh?
11:17:26 <chessguy> ?hoogle fromList
11:17:27 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
11:17:27 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
11:17:27 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
11:17:34 <nominolo> chessguy: that's how sets are printed
11:18:15 <nominolo> > read $ show $ Data.Set.insert 2 (Data.Set.singleton 2)
11:18:26 <lambdabot>  Exception: Prelude.read: no parse
11:19:47 <tom___> I've just reinstalled ghc (6.4 ubuntu package to 6.6.1 downloads from haskell.org) and I've been reinstalling libraries but I think I've messed up a bit.
11:20:05 <tom___> Getting this message "Could not find module `Data.ByteString.Lazy.Char8':
11:20:07 <tom___>       it was found in multiple packages: fps-0.8 base"
11:20:30 <tom___> Any one got any ideas how I sort that out?
11:22:23 <davidL> ?hoogle Data.IntSet.member
11:22:24 <lambdabot> No matches, try a more general search
11:22:33 <davidL> ?hoogle Data.Set.member
11:22:34 <lambdabot> No matches, try a more general search
11:22:51 <davidL> ?hoogle member
11:22:52 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
11:22:52 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
11:22:52 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
11:23:32 <Cheery> Does haskell X-bindings allow you to get input from any peripheral devices available at time?
11:25:37 <_frederik_> what is X-bindings? X11?
11:26:59 <Cheery> yes
11:27:22 <_frederik_> AFAIK it's just a binding to xlib, so it can do whatever xlib can do
11:27:39 <Cheery> yes, so can xlib do that?
11:27:51 <_frederik_> you'll have to be more specific
11:27:54 <Saizan> tom___: you don't need fps in 6.6.x Data.ByteString is in base
11:28:03 <Cheery> ie. I'd want to get input from my wacom tablet
11:28:41 <_frederik_> Cheery: i don't know, special support for tablets is probably not part of xlib
11:28:57 <sjanssen> sure, if your tablet already works with other X11 programs (like a mouse, I suppose?)
11:29:25 <Cheery> yeh, but I'd want more input from it
11:29:47 <Cheery> for instance, I'd want to see how high acceleration does the stylus have
11:29:51 <_frederik_> Cheery: you should probably ask X people how to do that with xlib, and then add the bindings to Haskell's X11 package
11:29:59 <Cheery> and whether you use mouse or stylus
11:30:54 <_frederik_> or use 'nm' to look at the symbols used by a program which already does it (does gimp?) to see which functions are called
11:32:36 <Cheery> I've heard gimp does it crappily, does not support all of the features in more advanced tablets, etc.
11:33:02 <_frederik_> anyway that's all the help i can offer i'm afraid
11:34:04 <Cheery> thank you anyway
11:34:10 <_frederik_> np
11:55:16 <nominolo> shapr: I'm now reading the paper myself.  The basic scheme seems quite nice, the explanation is rather not "functional pearl" style.  Anyways, I guess it could be turned into something very useful.
12:00:05 <Cheery> Why somehow it feels that more I know about haskell's standard libraries and internals, better programmer I become - unlike with imperative languages and libraries?
12:00:55 <Cheery> has anyone else noticed the same?
12:01:06 <monochrom> Perhaps haskell libraries are more inspiring.
12:01:18 <chessguy> they're more properly abstracted
12:01:53 <monochrom> Take parsing for example. The imperative story is "yacc", pretty dull.  Who would think that you could learn monads from parsing? Yet Haskell does exactly that.
12:02:30 <nominolo> Cheery: They work on the right level of abstraction, so they're very simple.  So it's mostly an optimum.
12:03:31 <Cheery> so the observation is correct?
12:04:02 <monochrom> Haskell attract authors who like to abstract and think up the best abstractions.
12:04:11 <nominolo> Cheery: well, I'd say, reading well-written libraries makes you a better programmer in general.
12:04:55 <Cheery> I don't read the libraries themselves, I mostly read the papers and interesting parts
12:04:56 <monochrom> The only imperative language that has the same trait is Modula-3 or Oberon.
12:05:04 <nominolo> Cheery: of course, language features define which abstractions are possible / reasonable.
12:05:27 * mux had to rewrite a Modula-3 program into C, and that wasn't very nice
12:05:51 <mux> the language is nice though, I just don't like the Pascal-touch of it
12:05:56 <nominolo> Cheery: well, I guess, few libraries are developed with the purpose of writing a paper about them, are they?
12:06:08 <monochrom> It's far easier to translate Haskell<->Modula-3.  They have similar type systems.  Or at least ML<->Modula-3.
12:06:15 <tom___> I'm trying to profile my application but ghc complains that libraries (Data.Binary to be specific) don't have profile information. Do I need to recompile them to have profiling working?
12:06:20 <mux> monochrom: I guess
12:06:37 <monochrom> My only gripe is "begin end". I prefer "{ }". :)
12:06:40 <mux> monochrom: Haskell would have been a perfect fit actually, but "oh well":-)
12:06:51 <mux> wasn't an option
12:07:13 <Cheery> nominolo: well yes, but then there's that stuff which actually shines like a hell
12:07:41 <Cheery> monads, parsers, graphs, different list implementations...
12:07:52 <shapr> nominolo: I sent an email to the author requesting source, hopefully it's available.
12:07:59 <Cheery> ..graph reducers, constraint systems...
12:08:03 <Cheery> and so on.
12:08:19 <monochrom> tom___: you may need to.
12:08:41 <nominolo> Cheery: yes, Haskell (and it's community) seems to encourage good designs :)
12:08:47 <tom___> How would I do that with cabal though? And will it effect performance too much?
12:09:10 <Cheery> thus it's not only that those libraries would help in learning haskell or show how to program better in functional languages
12:09:27 <mux> I think it's fair to say that the kind of people willing to invest some of their time in Haskell, just for the sheer beauty and elegance of it clearly aren't the type of programmers who like quick hacks
12:09:28 <Cheery> I've also noticed I can think of better designs in imperative languages as well
12:09:49 <nominolo> tom___: hard to say.  ByteStrings heavily relies on compiler optimizations to kick in which might be inhibitet by profiling
12:09:51 <mux> so it doesn't strike me as odd that the average haskell code quality is far superior to, say, PHP :-P
12:09:52 <Cheery> thus capable to understand specs faster than ever before
12:10:31 <nominolo> tom___: I think though it doesn't make a difference if profiling is turned off (IIRC it creates two versions)
12:11:03 <sm> Cheery: agreed.. my python programs are much better since working with haskell
12:11:16 <ThinkRusty87> ./server 67.184.254.124
12:11:18 <ThinkRusty87> ./server 67.184.254.124
12:11:20 <ThinkRusty87> ./server 67.184.254.124
12:11:52 <mux> was that a poor attempt at spamming?
12:11:59 <shapr> sm: yay!
12:12:17 <tom___> "runhaskell Setup.lhs configure --runghc-args='-prof'" is that the way to do it?
12:12:29 <sm> how about you shapr ? or have you left python behind entirely ?
12:12:34 <sjanssen> tom___: --enable-library-profiling
12:12:35 <mux> tom___: there's just a -p flag
12:12:52 <mux> sjanssen: that's verbose :-)
12:13:10 <cinema> tggggggggggggggggggggggggg
12:13:16 <tom___> Thanks, but where do I use that option?
12:13:38 <Cheery> I think haskell gives some sort of extra capability&tokens for thinking about programming
12:13:48 <sjanssen> tom___: during configure
12:15:14 <tom___> thanks
12:15:39 <Cheery> haskell benefits today similar way to how better understanding of time helped hundred years ago
12:16:00 <Philippa> mux: myself, I think it's fair to say that many haskell coders like quick hacks but like them to be of high quality
12:16:20 <mux> high quality quick hacks is an interesting concept :-)
12:17:05 <nominolo> Philippa: please define "high quality quick hack" ;)
12:17:07 <Cheery> I believe what I've gained is the ability to reason my code and the quality of seam between language and my work
12:17:55 <hpaste>  ari pasted "I wrote a permute function by accident :(" at http://hpaste.org/1859
12:17:59 <monochrom> unsafePerformIO is often used as a hack. Such a hack can be made high quality if you wrap an abstraction around it and prove it safe.
12:18:03 <Cheery> you see, for prodecural-only people it's mostly empiristic stuff
12:18:23 <shapr> sm: Yup, haven't done any Python in six months or so. I seriously doubt I'll do more.
12:18:46 <Cheery> how can it be a hack if it's high quality? :)
12:19:03 <shapr> sm: For me at least, Haskell is a better choice for everything.
12:19:10 <Philippa> nominolo: it was written quickly, it qualifies as a hack in general, and it meets a certain minimum standard re being well-behaved
12:19:24 <Philippa> Cheery: when "hack" stops being nothing but a perjorative
12:19:43 <Nafai> Cheery: What do you mean by "seam between language and my work"?
12:20:32 <Cheery> Nafai: I mean the seam which connects your creation to other's
12:20:53 <sm> I wrote a python script for someone last week; haskell would have been better, but they wouldn't have been able to extend it themselves
12:21:03 <Cheery> first, that seam is entirely visible in haskell
12:21:14 <Cheery> second, it's type-checked automatically
12:21:32 <kpreid> mux: it *was* spam; it was an attempt to get people to connect to that IRC server
12:21:33 <Cheery> neither of those happens with procedural languages I've been at contact with
12:21:41 <nominolo> Philippa: I never managed to create this kind of hack.  My code usually grows, get complicated, and the finally falls back down to something extremely simple/elegant.  Then I'm done. :)
12:22:00 <Philippa> *nod*
12:22:04 <mux> kpreid: yeah I know, I was trying to make him feel miserable, but it might have been a bot
12:22:19 <Philippa> sometimes I get lucky and all that happened while it was just an idea rather than actual code - in which case the code itself constitutes a "quick hack"
12:22:39 <DRMacIver> Relevant phrase from an earlier email: "The code for this is a bit awful. It's currently in the 'hacking it until it works' stage and has yet to move into the 'hacking it until it's pretty' stage."
12:22:56 <kowey> ?seen lispy
12:22:57 <lambdabot> lispy is in #darcs, #ghc, #haskell-blah, #haskell and #oasis. I last heard lispy speak 4h 18m 10s ago.
12:23:27 <nominolo> Philippa: In general, I wouldn't call that a hack.  A hack, to me, rather is something that leaks abstraction or only works under hard to define conditions.
12:23:51 <kowey> lispy: if you're around, did you say you had a friend who wrote a haskell syntax file for geshi?
12:23:59 <kowey> it would be interesting for the wikibook
12:24:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1860
12:24:07 <Philippa> yeah, you use the perjorative-only definition. To me, a hack can be a clever piece of code - the ones you're describing are arguably wannabe hacks
12:24:27 <Cheery> hah, all shell scripts are wannabe hacks! ;)
12:24:31 <dcoutts> nominolo: so it may well be that gtk2hs's build system is picking up the pkg-config flags in a way that means it breaks for systems that have more than one instance of gtk installed. If that's the case, it's a good bug to fix.
12:24:31 <kowey> lispy: oh, nevermind, found it!
12:24:32 <nominolo> A hack, e.g., is STM outside Haskell's purity and typechecker
12:25:06 <mux> heh right
12:25:18 <Philippa> the ugly cousin of the code that breaks abstraction internally but preserves it on the outside, or the highly specialised piece of code that performs shockingly better than the general-purpose stuff in a well-defined case
12:25:41 <nominolo> dcoutts: yes.  I'll have to postpone it a little though.  I have to design some hardware first ;)
12:25:51 <dcoutts> nominolo: ok, np
12:28:20 <chessguy> bos++
12:28:24 <chessguy> nice spell-checker article
12:28:34 <bos> thankee
12:29:52 <chessguy> would have been nice if you had put the code all together at the end, for convenience, or stuck it in a repo somewhere, though
12:30:09 <bos> the posting is literate haskell :-)
12:30:34 <chessguy> well, ok
12:30:43 <chessguy> i personally don't like literate haskell
12:31:14 <Philippa> I'm starting to realise that there's code I should probably write as literate haskell
12:31:33 <chessguy> especially when the comments include code in another language
12:31:48 <Philippa> there're times when that's appropriate
12:31:56 <Philippa> for example, when the code's supposed to be a direct translation of it
12:32:26 <monochrom> I write lhs when the comment is html or wiki :)
12:33:15 <Philippa> I figure lhs is appropriate when the sensible way to read the code is with attention on the commentary first and the code largely incidentally
12:34:05 <chessguy> i don't know, i guess i see lhs as the lazy way to write documented code
12:35:01 <monochrom> My lazy way to write documented code is leave the document empty.
12:35:58 <chessguy> ?hoogle insertWith'
12:35:59 <lambdabot> No matches found
12:36:16 <chessguy> @type Data.Map.insertWith'
12:36:19 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
12:39:44 <chessguy> ?src Data.Map.insertWith'
12:39:45 <lambdabot> Source not found. Are you on drugs?
12:41:09 <TomMD> ?src lambdabot
12:41:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:41:14 <TomMD> @where lambdabot
12:41:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:41:46 <TomMD> @version
12:41:47 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
12:41:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:46:01 <Philippa> chessguy: we're lazy programmers, it's a good thing
12:46:35 <Philippa> also, it encourages a style of documentation that's IMO a good thing for 'internal' docs - as in "how does this stuff work?"
12:48:51 <TomMD> ?src Philippa
12:48:51 <lambdabot> Source not found. Take a stress pill and think things over.
12:49:02 <TomMD> Oh, he's not a bot?  ;-)
12:50:06 <Philippa> TomMD: she
12:52:11 <TomMD> My apologies.
12:56:16 <quicksilver> by convention, bots are all 'she'
12:56:19 <quicksilver> Philippa: ;)
12:56:19 <nominolo> hehe, LtU users female : male -> 10 : 672
12:57:21 <chessguy> like ships
12:57:28 <davidL> ?hoogle XOR
12:57:29 <lambdabot> Data.Bits.xor :: Bits a => a -> a -> a
12:57:42 * shapr cheers for lambdabot 
12:57:44 <chessguy> @quote ship
12:57:45 <lambdabot> ndm says: outside of haskell i know roughly as many satan worshipers as christians.
12:58:02 <chessguy> hm, that's a new quote
12:58:06 <monochrom> "I hang out at #haskell for the girls."
12:58:12 <shapr> sm: Yeah, but I don't write code for people who know Python, only those who know Haskell or nothing at all.
12:58:26 <SamB_XP> @quote ship
12:58:26 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
12:59:10 <chessguy> nah, it's not so bad until he starts using == and /= in everyday talking
12:59:17 <edwardk> I usually think of it as when you go 'I have just the monad for that' ;)
13:18:19 <davidL> [ [chr a, chr b, chr c] | a <- [97..122], b <- [97..122], c <- [97..122] ] -- is there a more idiomatic way to do this?
13:18:39 <Heffalump> just use characters directly
13:18:45 <Heffalump> they're in Enum too
13:18:51 <dmhouse> Also use a triple instead of a list.
13:19:02 <davidL> actually, I shouldnt have the chr in there
13:19:04 <dmhouse> (Unless you have some special reason to do the latter.)
13:19:08 <Heffalump> > [[a,b,c] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z']]
13:19:12 <Heffalump> ok, then use ord
13:19:19 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
13:19:25 <LoganCapaldo> > let a = [
13:19:26 <lambdabot>  Parse error
13:19:42 <davidL> dmhouse: any reason why?
13:19:45 <LoganCapaldo> nvm
13:20:00 <Heffalump> well, if there will always be three, a triple is more strongly typed
13:20:05 <dmhouse> davidL: it'll catch more type errors.
13:20:09 <Heffalump> but you may have wanted String as output or something
13:20:21 <LoganCapaldo> I was going for the zipWith3 solution, but then I realized you wanted the cart prod.
13:20:34 <davidL> > [ (a,b,c) | a <- [97..122], b <- [97..122], c <- [97..122] ]
13:20:45 <dmhouse> I.e. the compiler will accept something like do [a,b] <- [[x,y,z] | ... ] even though it will be a runtime pattern match error
13:20:45 <lambdabot>  [(97,97,97),(97,97,98),(97,97,99),(97,97,100),(97,97,101),(97,97,102),(97,97...
13:21:09 <cdsmith> Woohoo!  I just got approval to do a proof-of-concept reimplementation of our web app at work in Haskell. :)
13:21:37 <fuzan> cdsmith: congrats :)
13:21:48 <davidL> LoganCapaldo: cart prod?
13:21:50 <nominolo> cdsmith: any framework in mind?
13:22:08 <LoganCapaldo> cartesian product
13:22:20 <cdsmith> nominolo: Nope.  I have HApps and Hope in mind sorta; I understand HApps doesn't agree with databases, though.
13:22:26 <davidL> ah
13:22:30 <LoganCapaldo> > [ (a,b) | a <- [1..3], b <- [1..3] ]
13:22:40 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:22:43 <LoganCapaldo> > zip [1..3] [1..3]
13:22:54 <lambdabot>  [(1,1),(2,2),(3,3)]
13:23:09 <davidL> ?index zip3
13:23:10 <lambdabot> Data.List, Prelude
13:23:19 <davidL> thanks ;)
13:24:31 <cdsmith> My first concern is to find a Haskell equivalent to the Java's SecurityManager stuff.
13:25:00 <Heffalump> what does that do?
13:25:13 <LoganCapaldo> Manages security.
13:25:16 <LoganCapaldo> I hope.
13:25:19 <dcoutts> heh heh
13:25:26 <cdsmith> Let's you load and run arbitrary code, and it can't do "bad" stuff
13:25:33 <cdsmith> where "bad" is defined by a policy file.
13:25:51 <dcoutts> cdsmith: to some extent we can use types to do that
13:26:10 <dcoutts> cdsmith: if you can't do any IO then you can't do anything bad (except use cpu and memory)
13:26:29 <cdsmith> dcoutts: Right, and the CPU/mem problem exists in Java as well.
13:26:33 <dcoutts> and one can build limited versions of IO that do additional checks
13:26:38 <Heffalump> who will be writing the "arbitrary code"?
13:26:44 <sjanssen> > readFile "/etc/passwd" -- restricted by the type system
13:26:46 <lambdabot>  <IO [Char]>
13:26:55 <cdsmith> Heffalump: our customers (or anyone who signs up for a 30-day free trial)
13:27:11 <Heffalump> so what will they be uploading? In your prototype, Haskell code?
13:27:18 <cdsmith> Heffalump: yep :)
13:27:32 * Heffalump made a start on writing something like that (for a specialised use) some time back
13:27:35 <cdsmith> Probably hs-plugins or something
13:27:38 <sjanssen> cdsmith: the first step is to make sure that code can't use known holes in the type system: unsafePerformIO and unsafeInterleaveIO
13:27:46 <Heffalump> I spent quite a while thinking about how to partition them off. hs-plugins was one part of it.
13:27:58 <sjanssen> presumably you could do this by checking the imports in the source
13:28:04 <Heffalump> Also, to avoid them being able to exhaust CPU you have to fork a new process. Cos of the let foo () = foo () in foo () problem.
13:28:06 <cdsmith> I was thinking this is much like lambdabot!
13:28:38 <cdsmith> sjanssen: If I just don't call anything in the IO monad, wouldn't that prevent this?
13:29:04 <sjanssen> @type unsafePerformIO (readFile "/etc/passwd")
13:29:07 <lambdabot> Not in scope: `unsafePerformIO'
13:29:23 <sjanssen> anyway, you see the point
13:29:27 <timlarson_> I was reading about monads...as unpacker-passers of additional data with the machines being plumbed this way being monad-data producers...
13:29:29 <cdsmith> It's not in the IO monad?  That sucks!
13:30:08 <sjanssen> cdsmith: unsafePerformIO is a hole in the type system -- it's supposed to be used for implementing new primitives
13:30:19 <timlarson_> why are the 'machines' monad data producers instead of having the monad plumbing doing pack-unpack all on its own?
13:30:30 <cdsmith> sjanssen: it there a comprehensive list of such holes?
13:30:43 <sjanssen> cdsmith: not that I'm aware of
13:30:48 <cdsmith> Ew!
13:31:01 <Philippa> there aren't any such holes in Haskell 98
13:31:06 <Philippa> so they're implementation-specific
13:31:16 <dmhouse> cdsmith: anything with 'unsafe' in the title is a good bet.
13:31:19 <timlarson_> that is, why are not bare machines the default, with monad-aware machines being not-double-wrapped via some escape syntax?
13:31:19 <SamB_XP> Philippa: not really
13:31:24 <dcoutts> sjanssen: ghc needs a 'safe' mode
13:31:36 <sjanssen> unsafeCoerce#, unsafePerformIO, several things in GHC.* and unsafeIOToST -- is that list complete?
13:31:37 <SamB_XP> the FFI addendum isn't implementation-specific, is it?
13:31:42 <sjanssen> dcoutts: yeah, that'd be really handy
13:31:47 <cdsmith> dmhouse: Okay.  I'll keep a lookout for something better than a safe bet, though.
13:31:51 <Philippa> SamB: fair point
13:32:11 <dmhouse> cdsmith: well, if in doubt, check the haddocks. They should list if something's unsafe
13:32:18 <Heffalump> presumably unsafeCoerce# lets you do IO by coercing an IO type to a non-IO type?
13:32:20 <dcoutts> sjanssen: or we need some way of annotating functions as safe, so if you trust the base package then you trust the implementations of everything that can be inferred or is annotated safe.
13:32:45 <Philippa> Heffalump: that, and more generally it lets you screw with internals by casting words
13:32:54 <sjanssen> cdsmith: rather than blacklisting bad functions, it might be easier to whitelist certain modules
13:33:09 <Philippa> so if you know enough about the target machine you can actually inject machine code that way
13:33:10 <sjanssen> this is what lambdabot does -- it has a fixed set of imports, and import statements are not allowed
13:33:14 <cdsmith> sjanssen: yep, definitely
13:33:34 <dcoutts> sjanssen: and the point of annotation is for the cases where something really is safe but internally is implemented using unsafe primitives. So most things are inferred safe simply because they use safe components, and you annotate other bits.
13:33:36 <Heffalump> Philippa: right, but I was looking for an easy way :-)
13:34:10 <Heffalump> dcoutts: how do you define "safe"?
13:34:17 <dcoutts> Heffalump: sjanssen: then safe mode just means that you list explicitly which packages you trust to have correct safe annoations.
13:34:18 <cdsmith> The other half of my problem is to allow certain kinds of IO, but only to certain places (e.g., files in a certain directory).  I suppose this means just providing an alternative IO library.
13:34:30 <Philippa> Heffalump: "doesn't make the universe stop making sense" :-)
13:34:37 <Heffalump> dcoutts: I don't follow that.
13:34:47 <sjanssen> cdsmith: yep, you'd make an opaque wrapper around the IO monad
13:34:51 <Heffalump> what's the specification of a "correct safe annotation"?
13:34:55 <dcoutts> Heffalump: back later, dinner calls
13:35:08 <sjanssen> cdsmith: you might want to check out IOSpec -- it is a pure implementation of the IO monad
13:35:20 <dcoutts> Heffalump: basically it amounts to trusting the base package, but after that pure code that uses safe things in base can be trusted.
13:35:20 <cdsmith> dcoutts: If GHC had a safe mode, then I'd trust it to decide.
13:35:38 <dcoutts> cdsmith: but it's got to be extensible
13:35:55 <Heffalump> trusting it (not) do *what*?
13:35:57 <cdsmith> dcoutts: right; because I'd need it to trust my opaque IO wrapper, for exa,mple
13:36:06 <timlarson_> is having default being to have the statements in a monad be monad-aware monad-producers the best design?  (i.e. forcing lifting on other statements)
13:36:44 <timlarson_> forcing *explicit* lifting on other statements
13:39:37 <timlarson_> an example of an alternate design would be to have lifting be the default, and using some escape semantics to prevent lifting already-monad-aware statements.
13:39:57 <timlarson_> could anyone experienced comment on this?
13:41:16 <Philippa> it isn't necessarily, but the alternatives require careful thought
13:41:28 <sjanssen> you'd like to make this a valid program: readFile "foo" ++ readFile "bar"?
13:41:46 <sjanssen> I find that a little bit scary
13:41:54 <Philippa> also, you're probably best off adopting the usual terminology: a value :: "m a" is a 'computation', a function "foo -> m a" is a 'function yielding a computation', or often just an 'impure function' or a 'function in m'
13:42:27 <Philippa> sjanssen: how about do readFile $ "foo" ++ readFile $ "bar"?
13:42:40 <Philippa> (probably another char in place of $)
13:42:58 <Philippa> with the do being mandatory, and the $ marking out "no, I really mean plain function application and not ap"
13:43:16 * beelsebob considers doing something evil
13:43:22 <timlarson_> I am pretty new to haskell, so the syntax quickly throws me, but I would like to explore the semantics.
13:43:38 <TomMD> Has anyone here done an extensive network based project in Haskell?
13:43:52 <TomMD> Like a routing protocol, or at least a web server?
13:43:58 <DRMacIver> beelsebob: And now you have learned the consequence of evil!
13:44:09 <beelsebob> drbean: :P
13:44:10 <DRMacIver> TomMD: We have a number of HAppS people in here.
13:44:11 <beelsebob> DRMacIver: :P
13:44:13 <beelsebob> damn tabbing
13:45:17 <pejo> TomMD, Simon Marlow has written an article about a webserver, for JFP iirc. Think it's on his homepage.
13:45:26 <timlarson_> in "do" notation, the monad wraps each line how it wants, not subexpressions in a line, right?
13:45:52 <dmhouse> timlarson_: what do you mean? Could you give an example?
13:45:56 <Philippa> almost. The layout rule's inserting ;s
13:46:17 <Philippa> and then those do get translated mechanically into something where each statement appears as a subexpression
13:46:24 <TomMD> How is HAppS going anyway?  I haven't heard news in a while.
13:47:03 <timlarson_> each line as a whole has to be of type func -> m a (if I got the syntax right)
13:47:06 <LoganCapaldo> timlarson_: you can also ask lambdabot about how a paritcular expression in do notation gets transformed
13:47:25 <LoganCapaldo> @undo do { x <- readLine; putStr x }
13:47:26 <lambdabot> readLine >>= \ x -> putStr x
13:47:41 <monochrom> "x <- getLine" cannot be said to have type "func -> m a".
13:48:10 <davidL> > readParen ("hello","world")
13:48:11 <timlarson_> so I think I am asking what tradeoffs would happen by making the requirement be func -> a instead, with the monad providing the change to func -> m a,
13:48:17 <lambdabot>  Couldn't match expected type `Bool' against inferred type `(a, b)'
13:48:25 <monochrom> tradeoff?
13:48:26 <davidL> ?ty readParen
13:48:30 <timlarson_> and with things that already are func -> m a having some escape syntax to prevent re-wrapping.
13:48:32 <lambdabot> forall a. Bool -> ReadS a -> String -> [(a, String)]
13:48:54 <monochrom> This question has better left unanswered and forgotten.
13:48:55 <SamB_XP> @undo removeFile "/etc/passwd"
13:48:56 <lambdabot> removeFile "/etc/passwd"
13:50:03 <timlarson_> binding is a separate issue, please don't confuse the issue with that just yet ;)
13:50:26 <timlarson_> I am asking about the other lines, not the binding lines.
13:51:10 <timlarson_> does my question make more sense to you then?
13:51:29 <monochrom> The type is m a.  No func->.
13:51:50 <Philippa> and if you loosened that to a, you'd break everything
13:52:24 <SamB_XP> @undo do let x = 1; y <- readFile "/etc/passwd"; print (x + read y :: Int)
13:52:25 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 17}) "Parse error"
13:52:38 <SamB_XP> @undo do { let x = 1; y <- readFile "/etc/passwd"; print (x + read y :: Int) }
13:52:39 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 19}) "Parse error"
13:52:39 <timlarson_> how does it break if the monad itself supplies the change to "m a"? (sorry that this is a haskell-beginner question)
13:52:55 <cdsmith> SamB: let {x = 1}
13:53:07 <SamB_XP> @undo do let {x = 1}; y <- readFile "/etc/passwd"; print (x + read y :: Int)
13:53:08 <lambdabot> let { x = 1} in readFile "/etc/passwd" >>= \ y -> print (x + read y :: Int)
13:53:20 <SamB_XP> ... okay...
13:53:35 <timlarson_> I don't expect this modified syntax/semantics to pass as valid haskell...it is a language design question.
13:54:02 <SamB_XP> timlarson_: yeah, but I don't think I'd like what the code would look like
13:54:42 <timlarson_> what else would be forced to change besides the relative number of lifts versus escapes?
13:55:43 * SamB_XP doesn't really get the question
13:57:37 <timlarson_> I am asking what would break/change semantically if the default for lines in a "do" were to hand type lines of type "a" and let the monad auto-lift them to type "m a", and of course provide an escape mechanism so lines already of type "m a" would not get over-lifed.
13:57:47 <monochrom> First I would correct the wording "monad supplies change" to "computer supplies change".  "do { 1; 2; 3 }" you are saying let's have the computer automatically turn it to "do { return 1; return 2; return 3 }".  I don't like that idea. It is sensible for a corner case only.
13:58:14 <timlarson_> but sadly I have to run now to pick up my daughter at school, will be back later.
13:58:23 <Heffalump> I really don't see the point
13:58:33 <timlarson_> thanks for beginning to think this through with me, gotta run now.
13:58:48 <dmhouse> TomMD: if no-one answered your question, perhaps try #happs
14:01:07 <joelr1> good evening
14:01:48 <monochrom> I believe the point is a telepathic interface for programmers.
14:03:48 <dcoutts> cdsmith: yes, exactly.
14:04:14 <dcoutts> Heffalump: so 'safe' is about preventing IOish things appearing in pure types.
14:04:48 <SamB_XP> dcoutts: it is also about preventing, say, buffer overflows or segfaults
14:05:07 <dcoutts> SamB_XP: yes, I guess so. So no unsafe indexing.
14:05:37 <dcoutts> SamB_XP: but those again are defined in terms of unsafe primitives and then we'd not annotate the unsafe indexing functions as safe.
14:06:10 <SamB_XP> you'd need to be able to annotate some things as safe despite their implementation
14:06:35 <sjanssen> right
14:06:48 <SamB_XP> of course, this would have to be in *trusted* code...
14:06:52 <dcoutts> Heffalump: so we'd start by saying that all the ghc primops are unsafe, the IO constructor is unsafe. Then we want to annotate as safe the things we build on top.
14:07:03 <sjanssen> maybe you'd have {-# SAFE (!) #-}
14:07:29 <SamB_XP> dcoutts: not all primops are unsafe...
14:07:30 <sjanssen> then build programs with flags like: --trust base --trust mtl, etc.
14:07:31 <dcoutts> now we only believe the safe annotations in packages that we explicitly list as trusted
14:07:36 <dcoutts> sjanssen: exactly
14:07:52 <beelsebob> I have an experiment
14:07:54 <beelsebob> define monad
14:08:02 <beelsebob> and tell me what the abstraction means
14:08:03 <dcoutts> SamB_XP: ok, then we mark as safe the ones that are ok
14:08:15 <SamB_XP> beelsebob: it means whatever you want it to mean
14:08:25 <SamB_XP> as long as that meaning is consistant with the rules
14:08:45 <dcoutts> so you can still use other packages, but we do not believe any safe annotations in those packages, we only allow functions which are built out of safe functions.
14:08:47 <sjanssen> Haskell's Monad class is a common interface to many types of computation.
14:09:17 <beelsebob> sjanssen: which types of computation?
14:09:26 <sjanssen> beelsebob: oodles of them
14:09:42 <SamB_XP> dcoutts: so, how would you store the safety info in a package?
14:09:43 <sjanssen> computations that support: return, which is some sort of injection operation
14:09:58 <sjanssen> and >>=, which is a special type of composition
14:10:21 <davidL> can I do this (92 < a < 122) or do I have to do (a > 92) && (a < 122) ?
14:10:33 <sjanssen> davidL: snd
14:10:47 <davidL> so the latter?
14:10:49 <joelr1> bringert: it's out
14:10:51 <dcoutts> SamB_XP: it's not a property of a package, it's a property of the client code, if it trusts certain packages.
14:10:59 <sjanssen> davidL: right
14:11:02 <SamB_XP> dcoutts: hmm.
14:11:02 <davidL> sjanssen: thanks
14:11:02 <beelsebob> sjanssen: what is special about >>= specifically?
14:11:04 * joelr1 just released an early version of his EasyLanguage to C# translator
14:11:14 <joelr1> written in haskell and using bringert's HOPE
14:11:24 <joelr1> Hope CMS that is
14:11:30 <joelr1> http://algokit.com
14:11:41 <sjanssen> beelsebob: umm, it has the type m a -> (a -> m b) -> m b? ;)
14:11:44 <joelr1> it's raw and full of bugs so be gentle :-)
14:12:05 <SamB_XP> dcoutts: what if a function in package z is declared as safe, but also could be proved safe if you trust packages x and y?
14:12:40 <sjanssen> SamB_XP: "proved" how?
14:12:47 <dcoutts> SamB_XP: then it's safe if you trust (z || (x && y))
14:12:59 <SamB_XP> sjanssen: well, you have to trust the .hi anyway
14:13:05 <dcoutts> sjanssen: because it uses only safe components
14:13:31 <SamB_XP> dcoutts: so, couldn't it get more complicated than that?
14:13:32 <bringert> joelr1: what rss link did you mean?
14:13:44 <dcoutts> SamB_XP: dunno :-)
14:13:52 <SamB_XP> like, what if you have another function in package w that uses that one... and is also declared safe...
14:13:54 <joelr1> bringert: the default rss link, the one that your rss module uses
14:14:08 <SamB_XP> well, I guess you could store it as a boolean expression anyways...
14:15:05 <beelsebob> SamB, sjanssen: do you mind me quoting you if I do some writing about monads
14:15:19 <SamB_XP> beelsebob: what would you quote that I said?
14:15:24 <SamB_XP> but no, I don't mind
14:15:31 <beelsebob> SamB_XP: beelsebob: it means whatever you want it to mean
14:15:31 <beelsebob> SamB_XP: as long as that meaning is consistant with the rules
14:15:33 <sjanssen> I imagine that each function would be annotated (in the .hi) with Either InherentlyUnsafe [SafetyAssumption]
14:15:37 <sjanssen> beelsebob: feel free
14:15:42 <beelsebob> cool :)
14:16:02 <bringert> joelr1: do you mean the <docs>http://www.rssboard.org/rss-specifica
14:16:03 <bringert> tion</docs>
14:16:04 <SamB_XP> except, call me "SamB" or my real name, not SamB_XP
14:16:15 <joelr1> bringert: no, pull up the source for the page
14:16:27 <bringert> ah, the <link rel="alternate" type="application/rss+xml" title="RSS" href="http://hope.bringert.net/entry?type=rss"
14:16:27 <bringert>      />
14:16:29 <joelr1> bringert: you will see a link to subscribe to the rss feed, it's in head
14:16:47 <joelr1> bringert: i always replace that with a link to feedburner, where i store the real link
14:17:13 <SamB_XP> sjanssen: so is SafetyAssumtion a kind of boolean expression?
14:17:18 <joelr1> bringert: this way my subscribers subscribe at feeburner which keeps stats and tracks things, and i'm free to change the url i use internally
14:17:22 <SamB_XP> over packages?
14:17:31 <sjanssen> SamB_XP: it'd be a descriptor of the source code origin
14:17:40 <sjanssen> eg. a package's name
14:17:49 <bringert> joelr1: it comes from rssHeader in Hope.View
14:17:54 <SamB_XP> wait a minute, that isn't right...
14:17:58 <byteshack> no haskell weekly news this week?
14:17:59 <bringert> joelr1: I guess there should be a setting for it
14:18:13 <SamB_XP> how do you represent (z || (x && y)) in that scheme?
14:18:46 <sjanssen> I don't see how you could ever generate (z || (x && y))
14:19:03 <sjanssen> a function either uses an unsafe function or it doesn't
14:19:03 <joelr1> bringert: so no way to replace it at the moment?
14:19:11 <SamB_XP> sjanssen: not really
14:19:13 <bringert> joelr1: not without editing the code
14:19:56 <SamB_XP> see...
14:20:44 <joelr1> bringert: right... ok
14:20:52 <bringert> joelr1: you can add a setting to Hope.Config, and use that in Hope.View.
14:21:10 <bos> byteshack: dons is on holiday
14:21:11 <SamB_XP> module X where f = unsafePerformIO ...; {-# SAFE f #-}
14:21:24 <SamB_XP> module Y where g = unsafePerformIO ...; {-# SAFE g #-}
14:21:26 <joelr1> bringert: i'll try to tackle that tomorrow morning
14:21:57 <SamB_XP> module Z where h = f + g; {-# SAFE h #-}
14:22:03 <SamB_XP> er.
14:22:07 <SamB_XP> add imports ;-)
14:22:12 <sjanssen> sure
14:22:13 <bringert> joelr1: maybe I'll do it now
14:22:24 <joelr1> bringert: i would be forever greatful
14:22:32 <SamB_XP> but, the safety of Z.h depends on what is trusted.
14:22:39 <joelr1> bringert: let me create an account for you so that you can see the blog edit issue
14:23:05 <SamB_XP> if you trust Z, it is trusted. but even if you don't trust Z, but do trust X and Y, it is trusted.
14:23:17 <SamB_XP> er.
14:23:18 <SamB_XP> safe.
14:25:22 <sjanssen> I suppose there are two options
14:25:45 <joelr1> bringert: please let me know if you got the message with the user/pass
14:25:47 <sjanssen> option 1: a SAFE pragma throws out the transitive assumptions
14:26:20 <sjanssen> so supplying --trust Z means you trust every one of Z's pragmas unconditionally
14:26:59 <sjanssen> option 2: you must add --trust for every package that Z uses
14:27:06 <sjanssen> I'd say 1 is more workable in general
14:27:17 <SamB_XP> you mean that librarys have to trust eachother?
14:27:54 <SamB_XP> I'm not saying it should be bad for a library to be allowed to trust another, but say Z doesn't trust either X or Y. Then what?
14:28:06 <sjanssen> SamB_XP: option 1 is trusting trust
14:28:29 <sjanssen> ie. if by saying --trust Z, I believe that Z has made good decisions about which packages to trust too
14:29:06 <SamB_XP> where would you be saying --trust Z?
14:29:24 <sjanssen> SamB_XP: Z doesn't have to trust X or Y, the SAFE pragma says that it believes 'z' is safe, unconditionally
14:29:44 <SamB_XP> yeah. but what if you *don't* trust Z?
14:30:17 <sjanssen> then you can't call 'z'
14:30:27 <SamB_XP> even if you trust X and Y?
14:31:00 <sjanssen> oh, another thing: z only calls functions that are marked as SAFE
14:31:07 <sjanssen> that probably shouldn't be allowed
14:31:12 <SamB_XP> why not?
14:32:12 <sjanssen> SAFE means that a function uses functions that are known to be unsafe (unsafePerformIO, etc.) but validates that their *local* use is safe
14:32:33 <sjanssen> imagine that ByteString adopted this system
14:32:58 <SamB_XP> yeah. but, Z hasn't made a statement about whether it trusts X and Y...
14:33:56 <SamB_XP> it does seem like it would make sense to at least warn about using SAFE where it adds no information
14:34:10 <dcoutts> probably so
14:34:11 <erider> good evening
14:34:38 <SamB_XP> but I still think you should store some kind of boolean expression over package names...
14:35:58 <SamB_XP> SAFE would then be flagged as useless if the calculated safety expression evaluates to true when the current package is trusted
14:36:14 <dcoutts> sjanssen: SamB_XP: making it transitive seems to make some sense
14:37:16 <SamB_XP> that sounds kinda confusing.
14:37:55 <dcoutts> sjanssen: SamB_XP: so if we trust the package author to have marked things as safe correctly, then we probably trust their judgement about the safety of the functions they use from the other package
14:38:37 <SamB_XP> what... if we decide that we don't trust the package author about safety?
14:38:51 <dcoutts> SamB_XP: then just don't list it as trusted
14:39:03 <bringert> joelr1: no user/pass yet
14:39:23 <SamB_XP> but we do trust X and Y?
14:40:10 <dcoutts> sjanssen: SamB_XP: so you had the example, package X uses functions marked safe from package Y. Suppose for a min that X does not mark anything as safe, then the safety of functions in it depends on whether we think Y is kosher.
14:40:34 <SamB_XP> yeah.
14:40:50 <bringert> joelr1: RSS URL setting in darcs now, see /setting/hope
14:41:18 <dcoutts> SamB_XP: now, if X marks things as safe and we don't trust Y then we can't use those functions from X. If we do trust X but not Y, then we can use those functions in X (but we still cannot use Y directly)
14:41:23 <SamB_XP> so we have {-# SAFETY X.f :: Y #-}
14:41:43 <bringert> joelr1: I probably won't have time to look at the edit issue today
14:41:46 <SamB_XP> dcoutts: hmm?
14:41:53 <dcoutts> SamB_XP: so by that reasoning, I don't think we need anything to be transitive.
14:42:18 <joelr1> bringert: woohoo!
14:42:34 <joelr1> bringert: it's your nick for user and name for pass
14:42:39 <dcoutts> SamB_XP: and it's then not so easy to say that something is marked safe redundantly, because it depends on the final context of what packages are deemed ok.
14:42:44 <joelr1> bringert: thanks!
14:43:01 <SamB_XP> dcoutts: that sounds about right
14:43:30 <shapr> gwahr!
14:44:13 <dcoutts> SamB_XP: so I think it's quite simple then, we explicitly list the set of packages we trust, functions annotated safe from safe packages are then safe. The safety of everything else is determined simply by whether they call only safe functions.
14:44:52 <SamB_XP> dcoutts: well, you don't keep the source around long enough to figure that out
14:45:09 <sjanssen> dcoutts: you'll want non-safety to be transitive, I think
14:45:13 <dcoutts> SamB_XP: it can be propagated through .hi files.
14:45:28 <SamB_XP> dcoutts: what, the functions that a function calls?
14:45:52 <sjanssen> unsafeIOToST = unsafePerformIO -- unsafeIOToST should automatically be marked unsafe
14:46:06 <sjanssen> and it should never have a SAFE pragma attached
14:46:10 <dcoutts> SamB_XP: oh, hmm.
14:46:30 <SamB_XP> you could do that
14:46:31 <dcoutts> sjanssen: you want to mark safe things, not unsafe things.
14:46:44 <dcoutts> sjanssen: you want to find proofs of safety, not unsafety.
14:47:10 <davidL> how can I apply the following formatting (x ++ ", " ++ y ++ "\n") to a list of doubles?
14:47:20 <SamB_XP> instrinsically safe things would have a safety of True...
14:48:54 <monochrom> Like "2.1, 3.5, -0.2, 43.8"?
14:48:58 <Saizan> > (++"\n") . concat . intersperse ", " . map show $ [1.0..10]
14:49:02 <lambdabot>  "1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0\n"
14:49:12 <SamB_XP> monochrom: well, that isn't a function exactly
14:49:15 <nominolo> > map (printf "%8.3f") [1.0..10]
14:49:15 <sjanssen> so you annotate every function with a potential proof of it's safety
14:49:24 <lambdabot>  Add a type signature
14:49:39 <nominolo> > map (printf "%8.3f") [1.0..10::Double]
14:49:40 <sjanssen> which is essentially: all safe functionsCalled
14:49:40 <davidL> thanks Saizan
14:49:41 <monochrom> No, it is not a function.
14:49:45 <lambdabot>  Add a type signature
14:50:02 <SamB_XP> sjanssen: you mean like ((x && y) || z) ?
14:50:06 <sjanssen> but you aggressively optimize the logic expression to avoid space blow ups
14:50:14 <Saizan> > map (printf "%8.3f") [1.0..10] :: [String]
14:50:25 <lambdabot>  ["   1.000","   2.000","   3.000","   4.000","   5.000","   6.000","   7.000...
14:50:34 <nominolo> :t printf
14:50:39 <lambdabot> forall r. (PrintfType r) => String -> r
14:50:44 <sjanssen> SamB_XP: some sort of logic expression
14:50:53 <nominolo> oh, the _result_ type of printf is generic
14:51:02 <sjanssen> just make sure to optimize things like True && True, etc.
14:51:17 <joelr1> how do i view the code of the last change in darcs?
14:51:29 <nominolo> > printf "%8.3f") 'a' :: String
14:51:30 <lambdabot>  Parse error
14:51:34 <sjanssen> joelr1: darcs changes --interactive is your friend
14:51:43 <nominolo> > printf "%8.3f" 'a' :: String
14:51:43 <joelr1> sjanssen: thanks
14:51:51 <lambdabot>  Exception: Printf.printf: bad argument
14:51:56 <SamB_XP> sjanssen: okay. that sounds good ;-)
14:52:20 <nominolo> ?where LP
14:52:21 <lambdabot> I know nothing about lp.
14:53:02 <joelr1> bringert: do i correctly understand that the hope rss url will be as before but you can now control what goes into Head?
14:53:30 <davidL> Saizan: oops, I meant tuples not doubles, but I'll figure it out ;)
14:53:36 <bringert> joelr1: yes
14:55:02 <joelr1> bringert: awesome, thanks!
14:57:04 <bringert> joelr1: weird, I get just half the HTML page, it starts at Please use the [http://groups.google.com/group/topdog Discuss link] on the left side of the screen to join the discussion forum.
14:57:04 <bringert> </textarea>
14:57:05 <lambdabot> Title: topdog | Google Groups
14:57:35 <bringert> joelr1: is that what you do to?
14:58:16 <joelr1> bringert: mmm... i probably messed something up with the markup
14:58:36 <bringert> that still shouldn't happen though
14:58:48 <joelr1> bringert: i know, that's why i brought it up
14:59:12 <bringert> if you add another empty entry, can you edit that?
15:00:36 <joelr1> bringert: let me try on my local copy. will take a few minutes since i just blew away my hope repo after it complained about not finding cbits/ghc_rts_opts.c
15:00:46 <joelr1> bringert: i'm re-getting the repo and will rebuild
15:01:28 <joelr1> bringert: rebuilding now
15:07:15 <gwern> has anyone had any experience getting emac's flymake to work with haskell-mode or haskell files in general?
15:08:33 <davidL> why can't I do this: map (\(x,y) -> x ++ ", " ++ y ++ "\n" ++) list --where list is a list of tuples [(a,b)] ?
15:09:18 <ddarius> You can't section things like that, Just throw in some parens or eta-expand.
15:09:22 <gwern> davidL: what's the last ++ doing?
15:09:40 <davidL> gwern: haha no idea but it wasn't working without it either
15:09:43 * gwern wonders what the fold for that would look like
15:10:05 <davidL> I tried doing that verbatim except with foldr and that didnt parse
15:10:38 <LoganCapaldo> concat $ map (\(x,y) -> x ++ ", " ++ y ++ "\n") list perhaps ?
15:10:49 <ddarius> concatMap
15:10:55 <LoganCapaldo> oh sure
15:11:05 <LoganCapaldo> save some extraneous characters
15:11:28 <LoganCapaldo> list >>= (\(x,y) -> x ++ ", " ++ y ++ "\n") :)
15:11:41 <davidL> well if map didn't work I don't see why concatMap would work
15:11:57 <LoganCapaldo> well are x and y strings?
15:12:02 <davidL> yeah
15:12:07 <ddarius> do (x,y) <- list; x++", "++y++"\n"
15:12:20 <ddarius> What is the exact code you are entering and the exact error message?
15:12:44 <davidL> test.hs:11:1: parse error (possibly incorrect indentation)
15:13:07 <davidL> printNice = map (\(x,y) -> (x ++ ", ") ++ (y ++ "\n")) alphaDecrypts
15:14:56 <ddarius> davidL: The problem is elsewhere.  And get rid of those parens around the (++) expressions.
15:15:22 <davidL> someone said throw in parens ;)
15:15:45 <monochrom> This is misguided.
15:15:49 <ddarius> Well thought out ones and that was when I thought you were trying to create sections.
15:16:32 <Saizan> davidL: is alphaDecrypts :: [(String,String)] ?
15:16:38 <davidL> Saizan: yeah
15:16:47 <ddarius> It's not even reaching the typechecker.
15:17:07 <monochrom> > map (\(x,y) -> (x ++ ", ") ++ (y ++ "\n")) [("a","b"), ("c","d")]
15:17:10 <ddarius> You have some sort of syntax error most likely in the declaration immediately preceding printNice.
15:17:11 <lambdabot>  ["a, b\n","c, d\n"]
15:17:16 <monochrom> Works for me.
15:17:31 <ddarius> monochrom: I wasn't saying that that was the problem.
15:17:45 <ddarius> But without the parens is better (cleaner looking and more efficient)
15:17:47 <davidL> so my original map statement had nothing wrong with it?
15:18:04 <monochrom> ddarius: I agree. I'm demoing.
15:18:14 <ddarius> davidL: The one with the extra ++ at the end quite definitely did.
15:18:23 <ddarius> But the problem you are having is located elsewhere.
15:18:34 <davidL> I'll try debugging the line above
15:22:36 <davidL> :r
15:22:58 <monochrom> module reloaded
15:23:02 <davidL> thanks
15:23:12 <sorear> hello.
15:23:13 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:23:19 <sorear> @messages
15:23:20 <lambdabot> kc5tja said 5h 4m 39s ago: Make sure it's in the darcs repo, and I'll take a look tonight if I'm reminded. I'll probably forget. I also have Aikido too, so I won't be back until after 9PM or so.
15:25:02 <joelr1> bringert: looking
15:26:25 <nominolo> @quote something funny
15:26:26 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
15:26:33 <nominolo> @quote something
15:26:34 <lambdabot> dons says: shapr said something once about how we developed our weapons in secret for 20 years, then launched a surprise attack
15:26:50 <nominolo> @quote funny
15:26:51 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
15:26:55 <joelr1> bringert: i'm able to edit an empty entry that i add
15:27:27 <joelr1> bringert: but i added a new one where i just said "this is just a test entry" and i wasn't able to edit it, came up blank
15:27:47 <sorear> @quote something.funny
15:27:48 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
15:27:53 <sorear> @quote that's.odd
15:27:54 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
15:28:45 <nominolo> heh
15:38:15 * ClaudiusMaximus compiles ghc-6.6.1
15:40:03 <ClaudiusMaximus> anyone working on anything multimedia/art related in Haskell?
15:40:11 <sorear> yeah
15:40:25 <sorear> yaxu is active
15:40:34 <sorear> ("Alex McLean" iirc)
15:40:48 <ClaudiusMaximus> yeah
15:42:29 <ClaudiusMaximus> i found some nice haskell/art stuff on www.slavepianos.org , too
15:42:43 <ClaudiusMaximus> bindings for supercollider3
15:55:48 <Nafai> w00t "Practical Haskell"
15:55:52 <Nafai> Er
15:55:57 <Nafai> "Pragmatic Haskell"
15:56:23 <dibblego> wtf is Pragmatic Haskell?
15:56:41 <Nafai> http://blogs.nubgames.com/code/?p=23
15:56:44 <lambdabot> Title: Nub Games  Pragmatic Haskell
15:58:34 <shapr> interesting
16:00:16 <thoughtpolice> neaot
16:00:18 <thoughtpolice> *neato
16:00:41 <thoughtpolice> now i have two pragmatic books to look forward to :)
16:01:11 <Nafai> thoughtpolice: What's the other one?  The Erlang book?
16:01:47 <thoughtpolice> Nafai: yep.
16:02:04 <Nafai> Yeah, that one sounds interesting as well
16:03:24 <thoughtpolice> so far the beta book has been getting doubleplusgood reviews, and I always liked the pragmatic series.
16:05:26 <ndm> @seen dcoutts
16:05:26 <lambdabot> dcoutts is in #ghc, #haskell-overflow, #gentoo-haskell and #haskell. I last heard dcoutts speak 3s ago.
16:05:29 <ndm> @seen dcoutts_
16:05:29 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts_ speak 9h 40m 11s ago.
16:05:33 <dcoutts> @yarr!
16:05:34 <lambdabot> Aye
16:05:36 <ndm> dcoutts - oh, you seem quite active :)
16:05:49 <ndm> dcoutts - i am trying to optimise low level Core, what flag was it you suggested?
16:06:00 <dcoutts> -ddump-simpl
16:06:04 <ndm> i can now deforest length =<< getContents, entirely automatically
16:06:18 <dcoutts> or -ddump-simpl-iterations -dump-simpl-stats | less
16:06:23 <ndm> i.e. defined in terms of foldl', but no knowing what any type of fold is
16:06:33 <dcoutts> the | less is essential, as it produces lots of output :-)
16:07:13 <ndm> i'm not actually faster than GHC when using GHC as a back end, but i suspect thats something low level in their screwing it up
16:07:30 <dcoutts> ndm: so how do you define >>= now? solved the data dependency issue?
16:08:11 <ndm> dcoutts, the data dependency issue was never an issue, it was always a CAF issue, since i do data IO a = IO a
16:08:36 <ndm> its all working quite well :)
16:08:59 <ndm> i can reduce length =<< getContents to a static loop that reads a character, and increments a number
16:09:07 <dcoutts> sounds good
16:09:18 <ndm> i've decided to define the problem as "how would you write getContents only using a ffi call to getchar"
16:09:32 <ndm> that way i can benchmark GHC vs Yhc vs C without having buffering effect it
16:09:47 <sorear> hello
16:09:52 <ndm> with the knowledge that good buffering can improve them all roughly the same, but is hardest to do in the C version
16:10:05 <dcoutts> ndm: so >>= is just function application since it's the identity monad?
16:10:53 <ndm> dcoutts, no, its: (IO a) >>= f = f a
16:11:05 <ndm> so i guess it is just application, but that data box is important
16:11:05 <sorear> ndm: why don't you have any kind of world?  I mean ghc does it so it can't hurt performance too badly :P
16:11:10 <ndm> to get the strictness write
16:11:26 <ndm> sorear, worlds are functions, functions are higher order - and Catch requires first order
16:11:38 <ndm> plus my optimisation does some crazy HO vs FO stuff
16:12:30 <sorear> Well, you would have to firstify after substituting World -> a.
16:13:25 <sorear> ISTR reading about a proof that any compiler which is (a) correct on pure programs and (b) never duplicates redexes, is correct on IO programs using World -> (a, World)
16:13:28 <ndm> the problem is either you thread the world directly into the primitives, or not
16:13:58 <ndm> if you don't, then my optimisation removes them
16:14:09 <ndm> if you do, then they get left over, which breaks my optimisation
16:15:03 <sorear> You can unbox, right?  so why can't you say "these primitives are strict in the World"
16:15:24 <ndm> i can't unbox, but i have a little bit of seq available
16:15:25 <sorear> since data World = World  unboxes to 0 bytes of overhead
16:15:40 <ndm> and GHC will probably unbox
16:16:08 <ndm> i'm pretty sure i can't go to world -> as the IO type, for various complex reasons
16:16:16 <sorear> So you aren't up to generating C anymore?
16:16:18 <ndm> i'll explain them seriously in my thesis though
16:16:27 <ndm> i'm currently hitting GHC as the back end
16:16:40 <ndm> but my program is nearly entirely strict, and very low level
16:16:41 <ndm> depends what i get time for
16:17:37 <ndm> dcoutts, it didn't inline unsafePerformIO - can that be a big issue?
16:18:06 <dcoutts> ndm: unsafePerformIO never gets inlined
16:18:29 <dcoutts> ndm: if you want inlinePerformIO then grab the source from the ByteString.Base module
16:18:35 * ndm grabs
16:18:51 <sorear> I thought it was INLINE [0], so it was inlined, but after everything dangerous/productive?
16:18:56 <ndm> @src ByteString.Base
16:18:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:19:06 <dcoutts> but remember that it's even less safe :-)
16:19:19 <sorear> @source Data.ByteString.Base
16:19:20 <lambdabot> Data.ByteString.Base not available
16:20:01 <dibblego> ?where yaht
16:20:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:20:17 <ndm> dcoutts, by this stage i'm infinitely unsafe...
16:21:30 * ddarius goes back to hacking assembler where he calls functions with ret.
16:25:06 <sorear> Yay.  I love deep asm hacks
16:25:35 * sorear is implementing a globally optimizing forth compiler
16:25:47 * sorear is stuck on, of all things, read :: String -> Int
16:28:11 * ndm is now 30% faster than GHC on the benchmark with inlinePerformIO - yay!!!!
16:28:19 <ndm> @karma+ dcoutts
16:28:19 <lambdabot> dcoutts's karma raised to 51.
16:29:16 <sorear> Wow, dcoutts has more karma than me
16:29:43 <LoganCapaldo> @karma sorear
16:29:44 <lambdabot> sorear has a karma of 44
16:30:09 * dcoutts sits cross-legged on a straw mat, pondering a co-inductive proof
16:31:03 <ndm> sorear++
16:38:41 <TomMD> Can you get negative karma?
16:38:48 <LoganCapaldo> everyone has more karma than me :)
16:38:50 <TomMD> @karma TomMD
16:38:51 <lambdabot> You have a karma of 0
16:38:53 <nominolo> so dcoutts = dalai coutts ?
16:38:54 <TomMD> Nope - see
16:39:04 <littledan> @karma+ TomMD
16:39:05 <lambdabot> TomMD's karma raised to 1.
16:39:15 <dcoutts> nominolo: heh heh
16:39:36 <TomMD> Well thanks, littledan, not sure if I earned it, but I'll work hard to make sure I have.
16:39:59 <nominolo> @karma- TomMD
16:39:59 <lambdabot> TomMD's karma lowered to 0.
16:40:06 <TomMD> AH, damn ;-)
16:40:11 <nominolo> ;)
16:40:19 <dcoutts> nominolo: actually, the bit about the cross-legged and straw mat wasn't true, but I am trying to do a co-inductive proof of a fusion rule
16:40:31 <LoganCapaldo> lambdabot giveth and lambdabot taketh away
16:40:48 <TomMD> I'm curious...
16:40:48 <TomMD> @karma- TomMD
16:40:49 <lambdabot> You can't change your own karma, silly.
16:40:55 * nominolo has to get co-induction first.  The TAPL "explanation" was a joke ..
16:40:56 <sorear> @karma- TomMD
16:40:57 <lambdabot> TomMD's karma lowered to -1.
16:41:02 <TomMD> So it is signed.
16:41:06 <sorear> @karma java
16:41:07 <lambdabot> java has a karma of -16
16:41:11 <nominolo> lol
16:41:12 <TomMD> WOW!
16:41:21 <TomMD> I figured at -1 I would be the lowest
16:41:29 <dcoutts> nominolo: google for co-induction tutorial functional programming
16:41:30 <nominolo> @karma cobol
16:41:30 <lambdabot> cobol has a karma of 0
16:41:43 <LoganCapaldo> everybody loves java
16:41:44 <nominolo> @karma perl
16:41:45 <lambdabot> perl has a karma of 0
16:42:15 <TomMD> Any chance of a correction to 0, or do I deserve this -1?
16:42:29 <Binkley> @karma+ TomMD
16:42:30 <lambdabot> TomMD's karma raised to 0.
16:42:32 <sorear> TomMD++
16:42:37 <Binkley> heh
16:43:00 <sorear> btw,
16:43:09 <coward> @karma+ java
16:43:10 <lambdabot> coward's karma lowered to -1.
16:43:20 <Binkley> heh
16:43:23 <TomMD> Oh, I see
16:43:36 <Tchakkazulu> Brilliant :D
16:43:37 <TomMD> Don't complement the java, got it.
16:43:49 <ddarius> @karma java
16:43:49 <lambdabot> java has a karma of -16
16:43:50 <Binkley> @karma- java
16:43:50 <lambdabot> java's karma lowered to -17.
16:43:57 <ddarius> @google co-induction tutorial functional programming
16:44:00 <lambdabot> http://homepages.inf.ed.ac.uk/dts/fps/papers/gordon.ps.gz
16:44:37 <sorear> Oh, and it's an Integer, so don't bother trying to overflow it :)
16:44:58 <nominolo> dcoutts: oh, cool. thanks.  no i have to figure out where to insert it in my to-read list.  length toReadList ~~ _|_
16:45:22 <Botje> hmm
16:45:24 <Botje> about bottom
16:45:33 <ddarius> sorear: I don't think anyone has the wherewithal to type @karma+ foo 2 billion times...
16:45:47 <Botje> isn't deciding if a function is strict or not akin to solving the universal halting problem?
16:45:55 <ddarius> Yes.
16:46:02 <dcoutts> nominolo: a slightly simpler paper is "Proof Methods for Corecursive Programs" by Gibbons and Hutton
16:46:04 <SamB_XP> ddarius: I think he means don't keep typing java--
16:46:07 <Botje> ah. yay :)
16:46:08 <Botje> thanks
16:46:16 <SamB_XP> ddarius: becuase it isn't going to wrap around to a positive value
16:47:22 <nominolo> dcoutts: well i know what bisimulation and contextual equivalence is
16:48:33 <nominolo> @go "Proof Methods for Corecursive Programs"  Gibbons  Hutton
16:48:37 <lambdabot> http://www.cs.nott.ac.uk/~gmh/bib.html
16:48:37 <lambdabot> Title: Graham Hutton: Publications
16:49:27 <waern> hi nominolo! we're in the same classes
16:50:22 <nominolo> waern: d'oh
16:50:50 <nominolo> THIS is weird
16:50:53 <waern> nominolo: congrats to the SoC project
16:51:04 <nominolo> oh, heh, thanks
16:51:04 <ndm> dcoutts - anything i can do to inline away the FFI wrapper>
16:51:33 <SamB_XP> do you have a really really l33t C compiler?
16:51:56 <hpaste>  ndm pasted "Low level Core for counting characters" at http://hpaste.org/1862
16:52:21 <ndm> dcoutts - if you have any tips for that Core, its quite short, but looks like it could be shorter :)
16:53:07 <davidL> ?index maximumWith
16:53:08 <lambdabot> bzzt
16:53:23 <davidL> :(
16:53:45 <SamB_XP> @type maximumBy
16:53:51 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
16:53:59 <SamB_XP> @type compare
16:54:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:54:10 <ndm> GHC is a really impressive optimiser :)
16:54:28 <SamB_XP> ndm: well, just try doing bit-shifting
16:54:36 <SamB_XP> or, worse, rotating
16:54:48 <davidL> ?index maximumBy
16:54:49 <lambdabot> Data.List
16:55:24 <nominolo> we had that guys.  That's deliberate; since low-level code is slow we force people to write high-level code, since this is properly optimized ;)
16:55:46 <nominolo> otherwise we'd end up with o'caml-style code ..
16:55:54 <SamB_XP> nominolo: but sometimes low-level things are needed
16:56:28 <nominolo> we, for the time being, FFI is an acceptable workaround, isn't it?
16:56:43 <nominolo> s/we, //
16:57:03 <ndm> does GHC change seq to an explicit case?
16:57:28 <sjanssen> I don't think that is possible
16:57:30 <ClaudiusMaximus> is mtl in ghc-extralibs?
16:57:41 <sjanssen> ClaudiusMaximus: yes
16:57:47 <ClaudiusMaximus> great :)
16:58:17 <LoganCapaldo> Transformers! More than meets the eye
17:00:11 <nominolo> g'nite #haskell
17:00:13 <kilimanjaro> LoganCapaldo, robots... in disguise?
17:01:33 <SamB_XP> @type (:[])
17:01:58 <SamB_XP> ...
17:02:33 <lambdabot> forall a. a -> [a]
17:06:34 <SamB_XP> so, is a robot a function that matches exists m. Monad m => a -> m a?
17:06:46 <Botje> only monkey robots.
17:06:58 <SamB_XP> hmm. I guess those would be "return" functions ;-P
17:07:03 <Botje> m is for monkey, obviously.
17:07:25 <chessguy> @quote ate
17:07:26 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
17:07:26 <lambdabot> Haskell.
17:07:32 <Botje> actually.
17:07:44 <Botje> replacing "monad" with "monkey" makes haskell much more easy to understand
17:08:05 <chessguy> @remember Botje replacing "monad" with "monkey" makes haskell much more easy to understand
17:08:05 <lambdabot> Done.
17:08:08 <Botje> you have an IO monkey, a reader monkey, a writer monkey, a state monkey, .. :)
17:08:10 <Binkley> heh, you beat me to it
17:08:17 <chessguy> :)
17:09:17 <chessguy> and you can feed the monkey values, you just can't get them back...
17:09:31 <Botje> yep
17:09:41 <Botje> monkeys can give their stuff to other monkeys
17:09:42 <chessguy> but he'll give it to another monkey of the same in
17:09:55 <chessguy> s/in/kind/
17:10:21 <Botje> yeah, we're assuming monkeys of the same kind live in the same cage/jungle/..
17:10:44 <chessguy> naturally
17:10:57 <chessguy> mixing up your monkeys would be too confusing
17:11:11 <Botje> well, it's possible
17:11:17 <Botje> but you need monkey transformers for that.
17:11:28 <Botje> (/me envisions a zookeep changing a monkey's shirt)
17:11:45 <chessguy> or hat?
17:11:50 <SamB_XP> mechas!
17:11:57 <Botje> hahah :)
17:12:00 <Botje> monkeys with silly hats!
17:12:22 <chessguy> of course, the question is, if a monad is a monkey, then what's an arrow?
17:12:32 <monochrom> monsters
17:12:42 <chessguy> bah, that's worn out
17:12:45 <Botje> all monkeys are also kleisly arrows.
17:12:46 <monochrom> I mean monads are monsters.
17:12:49 <Botje> *klesli
17:13:02 <Botje> which is just jargon for a pointy hat
17:13:05 <Saizan> an ape!
17:13:10 <Botje> hahah
17:13:12 <Botje> brilliant!
17:13:20 <monochrom> gosh
17:13:20 <Botje> and spears can be symians!
17:13:35 <monochrom> arrows are alligators
17:13:53 <chessguy> bah, you guys are ruining the metaphor now
17:14:04 <monochrom> I like alligators
17:14:30 <monochrom> http://worrydream.com/AlligatorEggs/
17:14:32 <lambdabot> Title: Alligator Eggs!
17:14:35 <chessguy> maybe so, monochrom, but you're nuts :). we have to market haskell to non-nuts people too
17:14:45 <monochrom> or kids
17:14:49 <Botje> monkeys like nuts.
17:14:54 <chessguy> yes, that's a cool little toy
17:14:59 <chessguy> for LC
17:15:49 <monochrom> Perhaps you can set up: function = alligator, monad = mutant alligator
17:28:19 <davidL> I don't suppose this is valid: maximumBy (\(x,y) -> compare howManySpaces) [(a,b)] ?
17:28:20 <SamB_XP> what about kleisli alligators
17:29:29 <kpreid> davidL: what are you trying to do?
17:30:19 <davidL> return the tuple which has the most spaces (ascii 32) in a -> [(a,b)]
17:30:36 <triplah_w> anyone played with SVD in haskell?
17:30:50 <triplah_w> i'm just wondering what the maximum dimensionality is
17:30:52 <kpreid> davidL: but [(a, b)] is a list with one element, so there's only one maximum
17:31:16 <davidL> kpreid: that was just a generalization, there a more tuples
17:31:35 <kpreid> ignoring that for the moment, you want 'maximumBy (comparing howManySpaces)'
17:32:17 <davidL> I just made a compareBy function and now I get the error: "Couldn't match expected type `([Char], [Char]) -> Ordering'' against inferred type `Ordering'
17:33:23 <kpreid> you'll have to show us the code that type error arose from
17:34:07 <davidL> let message = unzip $ maximumBy (\(x,y) -> compareBy howManySpaces x y) tuplelist
17:34:57 <kpreid> hmm
17:35:39 <kpreid> Data.List.maximumBy wants an a -> a -> Ordering, but you've given it an (a, a) -> Ordering
17:36:09 <davidL> I thought the lamda abstraction took care of that
17:36:14 <kpreid> also, your 'compareBy' is (or should be) the same as Data.Ord.comparing
17:36:29 <davidL> compareBy f x y = compare (f x) (f y)
17:36:35 <davidL> ?src comparing
17:36:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:36:50 <kpreid> ?src Data.Ord.comparing
17:36:51 <lambdabot> Source not found. You speak an infinite deal of nothing
17:36:53 <davidL> ?src Ord.comparing
17:36:53 <lambdabot> Source not found. Take a stress pill and think things over.
17:36:57 <kpreid> :t comparing
17:37:01 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:37:11 <kpreid> looks like not all of lambdabot's data is updated to ghc 6.6
17:37:22 <sorear> yeah.
17:37:26 <davidL> ?docs Data.Ord.comparing
17:37:26 <lambdabot> Data.Ord.comparing not available
17:37:56 <Saizan> davidL: if tuplelist is :: [(String,String)] you need to pass a function of type (String,String) -> (String,String) -> Ordering to maximumBy
17:38:31 <Saizan> that is, you ahve to compare two tuples, not the 2 elements of a tuple
17:39:18 <davidL> but by using the lambda abstraction can't I compare the elements?
17:40:14 <Saizan> yes, but maximumBy still requires you to return a comparison between tuples
17:40:57 <Saizan> maximumBy (\(x,y) (x',y') -> ...)
17:41:46 <davidL> is (x',y') equivalent to the next tuple in the list?
17:42:02 <Saizan> yes
17:42:25 <Saizan> well, another tuple of the list
17:42:34 <Saizan> ?src maximumBy
17:42:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:42:53 <Saizan> ?src maxBy
17:42:54 <lambdabot> Source not found. Wrong!  You cheating scum!
17:45:04 <Saizan> > let maximumBy f list = foldr1 (\a b -> case f a b of { GT -> a; _ -> b;} ) list in maximumBy compare [1..10]
17:45:14 <lambdabot>  10
17:45:44 <davidL> > let compareBy f x y = compare (f x) (f y) in maximumBy (\(x,y) (x',y') -> compareBy howManySpaces x x') [("adfa asdf asdf","adf"), ("asdf d d d d", "df")
17:45:45 <lambdabot>  Parse error
17:45:53 <davidL> > let compareBy f x y = compare (f x) (f y) in maximumBy (\(x,y) (x',y') -> compareBy howManySpaces x x') [("adfa asdf asdf","adf"), ("asdf d d d d", "df")]
17:46:00 <lambdabot>   Not in scope: `howManySpaces'
17:46:05 <davidL> oh
17:46:27 <davidL> > let howManySpaces x = length (elemIndices ' ' x); compareBy f x y = compare (f x) (f y) in maximumBy (\(x,y) (x',y') -> compareBy howManySpaces x x') [("adfa asdf asdf","adf"), ("asdf d d d d", "df")]
17:46:33 <lambdabot>  ("asdf d d d d","df")
17:46:41 <davidL> ;) thanks
17:46:55 <Saizan> :)
17:47:01 <Saizan> ?type elemIndices
17:47:15 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
18:06:36 <EvilRanter> oops
18:07:04 <monochrom> evil twins
18:07:51 <EvilTerran> evil alter ego...
18:20:21 <dainanak1> hey guys I'm a haskell noob on linux and I'm looking for an ide for linux that uses ghc for a backend. I mostly need it for synatx error underlining and stuff so i can figure out what I'm doing wrong. any suggestions?
18:20:49 <dibblego> eclipse
18:20:59 <SamB_XP> underlining... thats an idea.
18:21:26 <SamB_XP> maybe not for syntax errors, but for other kinds it would work nicely
18:22:02 <dainanak1> i tried to figure out eclipsefp before, but I couldn't get it to do much
18:22:19 <SamB_XP> emacs does some things
18:22:27 <dainanak1> emacs and vim scare me
18:22:36 <SamB_XP> why does everyone say that?
18:22:42 <dibblego> they lack goolies
18:22:45 <gravity> There was a post about using vim as a haskell ide recently
18:22:58 <monochrom> For the same reason math scares people.
18:23:03 <gravity> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html
18:23:07 <lambdabot> Title: Vim as a Haskell IDE, first steps, http://tinyurl.com/yvxl52
18:23:32 <SamB_XP> monochrom: er, I think they are more justified being scared of vim than of math...
18:23:34 <MyCatVerbs> monochrom: AIIIIEEEE, MODUS PONENS! RUN FOR YOUR LIVES!
18:23:36 <dainanak1> i'm alright at math. i started figuring out discrete math and stuff on my own, it's just an irrational fear of something ugly
18:23:58 <monochrom> Please don't call emacs and vim ugly.
18:24:00 <SamB_XP> you don't like emacs... because you think it is *ugly*?
18:24:06 <gravity> jedit might be good
18:24:06 <SamB_XP> why don't you change the font ;-)
18:24:10 <dainanak1> no it just frightens me
18:24:21 <SamB_XP> try out the online help
18:24:31 <gravity> It's pretty friendly as well as powerful. Nothing special for haskell though, aside from syntax hilighting
18:24:32 <monochrom> Fear doesn't not have to be explained. :)
18:24:36 <SamB_XP> hasn't it got a menu bar?
18:25:06 <monochrom> There is only one explanation of fear.  It happens to neural networks.  It just happens.
18:25:46 <dainanak1> well actually the reason i got interested in haskell is for a paper about ai that i'm working on
18:26:15 <sorear> There are plenty of other editors usable with Haskell.
18:26:23 <sorear> tsp, for instance, uses Ed.
18:26:44 <dainanak1> yeah i know plain old gedit has haskell highlighting for syntax
18:27:32 <dibblego> intellij idea does if you download it
18:29:14 <dainanak1> is it freeware?
18:29:23 <emu> emacs is probably the easiest editor to learn to use and customize ... if you aren't prejudiced against old-school UI
18:29:25 <dibblego> the syntax highlighting is
18:29:37 <emu> vim is ok too
18:31:38 <dainanak1> so i decided to peek at haskellfp for eclipse
18:32:10 <TomMD> @where osker
18:32:10 <lambdabot> I know nothing about osker.
18:32:20 <TomMD> Any Osker team members here?
18:34:02 <raxas_> kdevelop supports haskell projects quite well, in 3.3.6
18:34:33 <dainanak1> really? i heard it did but could never locate anything in the docs about it
18:35:08 <raxas_> I am just using it
18:42:54 <dainanak1> raxas_ , i got 3.4.0 installed and i can't find the project type for haskell. where would i find it?
19:23:05 <raxas_> dainanak1: unfortunately, in kdevelop 3.4 haskell support was removed for being a "useless language". evidently it needs much more useres to become acceptable again
19:23:16 <raxas_> meanwhile, I am using 3.3.6
19:23:31 <dainanak1> what a pain
19:23:44 <dainanak1> ok well i'll go hunt that down then
19:24:52 <MyCatVerbs> raxas_: that's stupid. Does it even cost them any effort to leave it in? oO
19:24:59 <raxas_> it would be great if all those smart people here could stop write academic papers about haskell and start actually meaningfull projects acceptable for wide public community
19:25:16 <MyCatVerbs> raxas_: got any suggestions on what to write?
19:25:48 <raxas_> I am working on multiplayer strategy game, in the design phase
19:26:01 <sm> hsgame
19:26:05 <sm> a la pygame
19:26:10 <MyCatVerbs> raxas_: wouldn't that be more suited to Erlang?
19:26:22 * MyCatVerbs cackles, hides under a sofa, etc.
19:27:18 <raxas_> it would be more suited even to c++ perhaps, but I am willing to dedicate myself for haskell for few next years
19:27:29 * ClaudiusMaximus is working on embedding haskell in a stateful-objects-with-message-passing dataflow environment most commonly used for multimedia/art purposes ( http://puredata.info )
19:27:31 <lambdabot> Title: About Pure Data &mdash; PD Community Site
19:27:52 <davidL> > 632382^518061 --lambdabot show me what ya got
19:27:52 <MyCatVerbs> raxas_: bzzt, nah. *Nothing* is well suited to C++. Bum-arsefecking toilet of a language.
19:28:08 <lambdabot>  thread killed
19:28:15 <davidL> aw
19:28:22 <MyCatVerbs> raxas_: objC maybe, or even pure C, but C++ is total bollocks.
19:28:31 <sorear> davidL: thread killed has nothing to do with the timeout
19:28:40 <dainanak1> i'm using my ai research to rewrite a c++ ai module in haskell with improvements
19:28:44 <sorear> davidL: Terminated is the timeout
19:28:59 <sorear> davidL: in other words, the problem is that lambdabot is b0rken
19:29:06 <sorear> (if only dons wasn't on vacation)
19:29:12 <davidL> sorear: oh, so my GHCi might do it?
19:29:20 <sorear> yea
19:29:24 <ddarius_> davidL: Your GHCi will do it.
19:29:29 <MyCatVerbs> dainanak1: that is frightening.
19:29:30 <sorear> very, very, fast
19:29:37 <davidL> I'm scared.
19:29:58 <davidL> it crashed
19:30:06 <sorear> davidL: it only took my ghci 1 second
19:30:18 <davidL> hmm
19:30:46 <sorear> davidL: *ALL* crashes are @bug worthy!!!
19:31:00 <dainanak1> MyCatVerbs, i feel that for a neural network representing nodes as monads lends itself to fuzzy logic situations more so than c++ oo
19:31:07 <davidL> actually it only crashes on windows
19:31:12 <raxas_> MyCatVerbs: piling dirty words on c++ would not help to haskell. Whole qt/kde stuff is c++. And it is an industrial success, unlike haskell. we shall adapt to existing stuff
19:31:15 <sorear> well, assuming you don't unsafeCoerce#
19:31:38 <MyCatVerbs> dainanak1: not what I was thinking. More along the lines of, "since when does C++ lend itself to *anything*" rather than "does Haskell lend itself to that?"
19:31:47 <davidL> my linux box which is half as powerful did it in a second (three seconds to print)
19:31:51 <sorear> davidL: Much as I think it is stupid, the GHC team is committed to supporting windows.  Thus, you should report windows bugs.
19:31:53 <MyCatVerbs> dainanak1: besides, isn't FFI a total pain?
19:32:19 <davidL> ?bugs
19:32:20 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:32:38 <MyCatVerbs> raxas_: hey, be fair. I *like* pure C, for some restricted variant of "like". But C++ is just unwieldly.
19:32:42 <raxas_> so, a good interface Qt <-> Haskell should be a priority. Kdevelop support will be reborn as side effect
19:33:22 <raxas_> MyCatVerbs: thing about templates as generic programing and higher order functions
19:33:49 <dainanak1> MyCatVerbs, I'm not intending to use ffi. i'm compiling the haskell modules into separate assembly chunks that may simply be loaded in place of the c++ compiled files of the same function
19:34:03 <MyCatVerbs> raxas_: compile-time only, and not *nearly* worth the insane increase in build time and compiler complexity.
19:34:03 <raxas_> MyCatVerbs: so you can do fp in c++ today quite easily. but objects in haskell?
19:34:30 <MyCatVerbs> raxas_: code generation of plain C is a much nicer solution. See: yacc, flex, etc.
19:35:10 <MyCatVerbs> dainanak1: spiffy, but isn't that all going to be fairly difficult to orchestrate with the RTS?
19:35:53 <raxas_> MyCatVerbs: yes, I know haskell _is_ better than c++. I used c/c++ for 15+ years. but we need more standard "classical" technology in haskell to push it into industry
19:36:28 <raxas_> that's what happend with python, and python had a success by this
19:36:30 <MyCatVerbs> raxas_: whut. You can fake inheritance if need be by composition of records and making the child datatypes members of the same classes as the parents. No biggue.
19:37:34 <MyCatVerbs> And OO is not the be-all and end-all of actually getting shit done. Especially not the restricted, godawfully fugly subset of true OO that C++ gives you.
19:37:58 <dainanak1> MyCatVerbs, i'm pretty sure that it won't be hard to redirect the haskell assembly files to utilize a return statement at the end. then i could just inline the files in a c wrapper if all else fails
19:37:58 <raxas_> inheritance or any other theory stuff is not a problem at all. we need just libraries to complement and match the existing stuf, like python did
19:38:52 <MyCatVerbs> raxas_: what else needs adding? Enumerate, slave! Er, more to the point...
19:39:27 <MyCatVerbs> raxas_: we have libraries for accessing most of Posix and churning out GUI apps. What next?
19:39:27 <dainanak1> it's little pauses in conversation that always make me want to flamebait...
19:39:33 <raxas_> 1. Qt  2. OpenGL is aged, not in par with 2.0
19:39:37 <MyCatVerbs> dainanak1: flamebait is fun. ^^
19:39:44 <dainanak1> haskell sucks!
19:39:46 * dainanak1 ducks
19:40:17 <MyCatVerbs> dainanak1: you'll still need to worry about the RTS. Haskell's generated code needs the alloc() functions and the garbage collection provided by the RTS, nu?
19:41:16 <dainanak1> MyCatVerbs, i don't quite understand why that would conflict?
19:41:36 <raxas_> 3. by design, haskell runtime is unpredictable in terms of memory consumption. that makes large haskell projects fragile
19:42:01 <MyCatVerbs> dainanak1: sorry, do you actually have this Haskell-C++-crossover up and running yet?
19:42:09 <MyCatVerbs> dainanak1: if so, just ignore me, please.
19:42:10 <TomMD> How do you make default functions for classes?  IOW, I have a class in which most instances will want 1 behavior, but I would like that to be overrideable.
19:42:34 <ddarius> TomMD: You can just add default definitions in the class definition.
19:42:44 <TomMD> Wahoo!
19:43:03 <dainanak1> MyCatVerbs, i'm still just making stubs right now
19:43:07 <MyCatVerbs> TomMD: classes don't neccessarily specify behavoir, just a set of functions which any instance of them must export. It's up to the person writing the instance code to worry about the semantics of it.
19:43:48 <MyCatVerbs> (Unless you add default definitions, in which case they may well do specify default behavoir. Which can be overridden by any instance.)
19:44:10 <MyCatVerbs> dainanak1: I presume you've read all the "inside ghc" sections of the GHC userguide then?
19:44:23 <dainanak1> no
19:44:36 <dainanak1> i'm kind of learning as i go really
19:44:49 <MyCatVerbs> Oh, yikes. You might have a few nasty shocks in store, then.
19:45:50 <dainanak1> argh
19:46:48 <dainanak1> may end up rewriting more than i thought then
19:47:36 <raxas_> ClaudiusMaximus: puredata looks interesting
19:47:40 <MyCatVerbs> dainanak1: trust me, read the relevant stuff first. x_x
19:48:03 <dainanak1> it's so confusing though!
19:48:18 <MyCatVerbs> dainanak1: some of ghc's guts can be classed as "scarily clever". There might not be any cause for alarm, but if there is you'll have some more work to do to make it run.
19:50:05 <dainanak1> i'll just take it as it comes i guess
19:50:16 <MyCatVerbs> Good luck, then.
19:50:20 <dainanak1> right now i gotta become more proficient at haskell as it is
19:50:22 <dainanak1> thank you
19:50:26 * MyCatVerbs nods.
19:51:03 <dainanak1> i really need some starter projects to build up in difficulty. anyone have some ideas?
19:51:23 <MyCatVerbs> >_> <_<
19:51:33 <MyCatVerbs> dainanak1: go help raxas_? :)
19:53:23 <raxas_> dainanak1: what about 3d reactive animation library?
19:53:43 <dainanak1> haha let's try something slightly simpler
19:53:54 <raxas_> some basic ideas are already in frag
19:53:57 <dainanak1> i get haskell concepts, but i have no practical experience
19:54:16 <dainanak1> it follows calculus simply enough
19:54:35 <dainanak1> guards are pretty much piecewise functions
19:54:39 <dainanak1> etc
19:54:50 <andrei> Hi, is there a way to override the an instance of a monad in my code? (I want a different show function for something)
19:56:34 <ClaudiusMaximus> raxas_: puredata is interesting, but it has a nightmarishly crufty API, and it's a nightmare to write plugins for in anything but C...  wish i picked a simpler task, but i've got a Haskell embedding working well enough to not give up now..
19:58:12 <sorear> allbery_b: Oh, well, in that case it was a simple typo.  there should be ) -> res  appended to the end
19:58:20 <dibblego> is there a formal name for the property of two functions such that the same arguments always produce the same result? \forall x. f x == g x -- the relationship between f and g?
19:58:31 <sorear> allbery_b: in any event, it's a lot nicer than my earlier unicode-free env :)
19:58:36 <sorear> dibblego: "is a function"
19:58:49 <dainanak1> hooray i finally got kdevelop with haskell
19:59:09 <sorear> dibblego: Oh, sorry, didn't catch the 'f' /= 'g'
19:59:11 <dibblego> sorear, wtf?
19:59:13 <sorear> dibblego: "equality"
19:59:23 <dibblego> f is equivalent to g?
19:59:24 <Binkley> dibblego: extensional equality
19:59:41 <sorear> Binkley: what other kinds exist?
19:59:49 <sorear> (serious question)
20:00:10 <Binkley> well, there's also intensional equality
20:00:11 * sorear has his math hat on, if it makes a difference
20:00:30 <ddarius_> Things can be extensionally equal without being intentionally equal.
20:00:50 <ddarius_> In so far as that makes sense.
20:02:19 <raxas_> ClaudiusMaximus: crufty api is a reality of large scale real world projects. I was forced to live on crufty apis for the past 25 years. prepare for the future will not be any better
20:02:40 <sorear> google page1 didn't explain it.  guess(a): string equal code?  guess(b): {alpha,beta,eta} convertable
20:02:56 * raxas_ is pragmatist, not pessimist
20:03:40 <ddarius_> sorear: Intensional equality is what you get if you can "look inside" a function.  So (a) though obviously it doesn't have to be that similar.
20:04:14 <sorear> ok.
20:04:16 <sorear> ty
20:04:59 <ddarius_> Pointer equality can be considered one form of intensional equality.
20:20:19 <dainanak1> ?party
20:20:20 <lambdabot> Not enough privileges
20:20:30 <dainanak1> just like my parents say
20:20:35 <dainanak1> :(
20:25:02 <sorear> Nice one.
20:25:11 <sorear> ?party--  what is it?
20:25:11 <lambdabot> Unknown command, try @list
20:25:14 <sorear> ?party-  what is it?
20:25:34 <sorear> *gulp* I wonder what I did...
20:25:53 <sorear> Oh, duh.
20:25:58 <sorear> ?party #haskell
20:26:02 <Binkley> heh
20:28:44 <dainanak1> erm why did the bot leave the room?
20:29:07 <Binkley> the ?party command means ?part
20:29:20 <Binkley> or that's my guess
20:31:44 <sorear> Mine too.
20:32:01 <sorear> (and I *do* have privleges to tell the bot to part)
20:32:35 * sorear can never spell priviledges
20:32:48 <ddarius> @spell privileges
20:33:00 <Binkley> apparently you can append up to 2 extra characters to any command and still have it work
20:33:02 <Binkley> but not more
20:33:08 <sorear> @activity 90
20:33:09 <lambdabot> 3*total 3*private
20:33:22 <sorear> @activity-full 90
20:33:23 <lambdabot> 4*total 3*Binkley 1*#haskell
20:33:37 <sorear> Binkley: Actually, it's edit distance max 2
20:33:42 <Binkley> ah
20:33:43 <sorear> @past #haskell
20:33:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:34:00 <sorear> with confusing disambiguation rules :)
20:34:01 <ddarius> @bot
20:34:02 <lambdabot> :)
20:34:05 <Binkley> but of course
20:34:06 <sorear> @pirt #haskell
20:35:00 <dibblego> speaking of edit distance, how does something like google know what alternatives to suggest when I mispel? surely it hasn't calculated the edit distance for all possibilities, or does it somehow restrict the set of possibilities using a tree?
20:35:32 <dainanak1> i think its a statistic-based algo
20:35:51 <ddarius> It looks for a word close to what you typed that is very common.
20:35:58 <dibblego> yes, but how does it look?
20:36:09 <dibblego> what is it keyed on? commonness?
20:36:28 <dainanak1> think so
20:36:42 <sorear> dibblego: I'm guessing it's a trade secret.  (Life was so much nicer before the IPO)
20:36:43 <dainanak1> that's why it thinks you made an error when you enter 'she invented'
20:36:57 <dainanak1> it's how common things come up
20:37:01 <dibblego> maybe it is several keys
20:37:20 <dibblego> calculating the edit distance is not cheap; so I can't imagine it happens with lots of words each time I do a search
20:37:22 <thoughtpolice> i'd think so. google having large list of common mistypes is probably a biproduct of this. some of them are pretty funny, though
20:37:32 <sorear> dibblego: sure it
20:37:46 <dibblego> sure it?
20:37:49 <dainanak1> does
20:37:55 <sorear> 's pretty cheap - esp since you only have to do it O(log n) times
20:38:14 <dibblego> how do you do it O(log n) times?
20:38:22 <sorear> I forget the details, but there exists a tree search that works with arbitrary metrics
20:38:28 <dibblego> ah, that was my guess
20:39:17 <ddarius> I imagine you can easily tweak the database search algorithms to return nearby matches.
20:39:23 <dibblego> I just finished writing LCS delta compression in Scala
20:40:00 <dibblego> using DPA (which made it fun!)
20:40:18 <ddarius> For example, if you had stuff stored in a trie decorated with likelihood you could check for very high probability paths close to the one you're exploring.
20:40:33 <ddarius> I think a similar approach could be used for inverted indexes.
20:41:34 <dainanak1> kind of a tree categorization with references to words varying within 2 or 3 chars or something
20:41:50 <dibblego> I'll have to find a paper on it, thanks
20:47:48 <edwardk> @seen shapr
20:47:49 <lambdabot> shapr is in #haskell and #scannedinavian. I last heard shapr speak 4h 49m 13s ago.
20:51:39 <dainanak1> thats a cool trick
20:55:25 <dibblego> hi slava
20:58:25 <slava> hi dibblego
20:59:28 * sorear hi's slava too
21:02:23 <desp> http://adi.stav.org.il/sesame-street-explains-tcp/main.htm
21:02:25 <lambdabot> Title: Sesame Street Explains TCP
21:04:35 <MyCatVerbs> desp: that is awesome, but I still think somebody was smoking something while making it.
21:09:34 <dainanak1> wish all my cs classes were like that
21:10:34 <RyanTM> Is there a standard Haskell package manager?
21:10:50 <sorear> cabal
21:11:13 <sorear> but I like apt more
21:12:03 * jcreigh dislikes the idea of language specific package managers
21:12:09 <slava> why?
21:12:09 * sorear does too
21:12:28 <sorear> slava: it hurts interoperability, and raises the learning curve
21:12:34 <RyanTM> sorear: so it says it's built into ghc, how do I use it to search what's available
21:12:47 <sorear> RyanTM: you can't.  cabal is like rpm
21:12:53 <RyanTM> oh
21:12:55 <sjanssen> @hackage
21:12:55 <lambdabot> http://hackage.haskell.org
21:12:57 <jcreigh> @where hackage
21:12:58 <lambdabot> http://hackage.haskell.org/trac/hackage
21:13:04 <sorear> RyanTM: it can install from directories, it doesn't use the web
21:13:08 <sjanssen> RyanTM: visit ^^^ for 90% of your library needs
21:13:18 <RyanTM> sjanssen: Thank you.
21:13:21 <SamB_XP> sorear: well, you can figure out how to debianize cabal
21:13:27 <SamB_XP> if you like
21:13:55 <SamB_XP> you'll need to come up with some way to automatically generate all the debian packages from hackage
21:17:37 <sengan> norvig.com explains google's spelling algorithm. programming.reddit.com linked to someone's haskell implementation a few days ago.
21:18:13 <sjanssen> you can probably catch that post on planet.haskell.org
21:19:09 <RyanTM> Wow 1010 patches for cabal-install?
21:22:01 <desp> MyCatVerbs: :)
21:22:06 <cdsmith> SamB, sjanssen, and dcoutts: sorry I got pulled away from #haskell earlier; I read the safety stuff in the logs, and it generally seemed right.
21:22:25 <SamB_XP> mmm.
21:22:36 <MyCatVerbs> desp: I think that's probably evidence enough to have _someone_ arrested on suspicion of controlled substance abuse.
21:23:01 <desp> cookie abuse!
21:24:09 <MyCatVerbs> Cocaine and hemlock in the cookies.
21:24:25 <cdsmith> SamB: was that 'mmm' to me?
21:24:36 <SamB_XP> yeah.
21:24:44 <cdsmith> okay, I'm not sure what it means
21:25:46 <SamB_XP> well, when you figure it out, be sure and tell me ;-)
21:26:33 <cdsmith> SamB: alrighty then.
21:28:06 <cdsmith> I know next to nothing about GHC development; is that the sort of thing that, if I took a week to develop it, has a chance in hell of being applied?
21:28:40 <SamB_XP> it might depend on whether or not it was optional
21:28:55 <SamB_XP> but it seems like a neat idea
21:29:10 <SamB_XP> would simplify some of what lambdabot does
21:29:24 <cdsmith> Well, yeah; I next to need it, and yes I think it would simplify lambdabot as well.
21:30:15 <cdsmith> I hate to contemplate maintaining my own modified GHC and trying to keep up with bug fixes.
21:30:28 <sorear> cdsmith: what is the change?
21:30:32 <SamB_XP> too bad dons is on vacation
21:30:52 <SamB_XP> @localtime dcoutts
21:30:55 <lambdabot> Local time for dcoutts is Wed May 16 05:15:47
21:31:06 <cdsmith> sorear: adding a safety mode, where it will refuse to compile code that uses stuff like unsafePerformIO, basically
21:31:09 <sorear> cdsmith: generally people in haskell communtity are extremely friendly; even the great SPJ emails me respectfully
21:31:39 <SamB_XP> cdsmith: you could email the libraries@ list about it I guess
21:31:47 <sorear> can't guarantee it will be applied, but I will guarantee your intelligence will not be insulted
21:31:49 <SamB_XP> it seems like a libraries@ kind of thing, somehow
21:32:06 <sorear> wouldn't glasgow-haskell-users@ or cvs-ghc@ be better?
21:32:12 <cdsmith> sorear: I don't mind being insulted, really. ;)
21:32:23 <SamB_XP> sorear: well, maybe.
21:33:00 <sorear> cdsmith: /join #ghc  and ask Igloo: directly, if you want a yes/no answered quickish
21:33:10 <sorear> (messages without nick: are ignored ime)
21:33:39 <cdsmith> sorear: I might do that.  But I want to think it through more, first.
21:34:00 <SamB_XP> it will definately change the .hi format
21:34:13 <cdsmith> Yep, that's true.
21:34:42 <MyCatVerbs> sorear: people in the Haskell community are frighteningly friendly. Y'all scare the bejeesus outta me.
21:35:46 <cdsmith> SamB: I'm thinking of the trust dependencies as basically a type addition.  I.e., "seq :: (trusted base) => b -> a -> a"
21:35:56 <SamB_XP> hmm?
21:36:09 <SamB_XP> I wouldn't quite do it like that...
21:36:23 <cdsmith> SamB: how would you do it?
21:36:45 <SamB_XP> good question...
21:36:54 <sjanssen> IMO it makes the most sense as a phase right after name resolution
21:37:03 <cdsmith> I think deep scanning the entire possible call tree at compile time won't work.
21:37:26 <SamB_XP> cdsmith: well, sort of like what you say
21:37:31 <SamB_XP> but not as part of the type
21:37:52 <cdsmith> SamB: ok, so it's conceptually a type; maybe doesn't appear as part of the type
21:38:19 <sjanssen> I don't think you want to treat this like a type
21:38:44 <sjanssen> it is hard to tell whether (a -> b -> b) needs to trust the 'a' argument
21:39:19 <cdsmith> sjanssen: I'm not following
21:40:04 <SamB> cdsmith: it would be stored alongside strictness info and type and unfolding and so forth
21:40:25 <SamB> I suppose
21:40:47 <SamB> but it would only be stored for exported names
21:40:56 <cdsmith> okay; by "type", I only meant that it's computed by rules that infer the trust requirements of each expression from its subexpressions.
21:41:13 <SamB> k.
21:41:18 <sjanssen> allright
21:41:38 <cdsmith> That is true that it would only need to be stored for exported names.
21:41:40 <SamB> and from {-# SAFE f #-} pragmas
21:41:41 <sjanssen> I still say this is just a simple step after name resolution
21:41:57 <sjanssen> the general algorithm:
21:43:01 <sjanssen> to compute the safety assumptions for an expression, compute 'all satisfied safetyAssumptionsForSubexpressions'
21:43:41 <sjanssen> assume formal parameters are automatically safe
21:43:51 <SamB> yeah.
21:44:00 <sjanssen> cache the safety assumptions for each name in the .hi
21:44:11 <SamB> after simplifying them
21:44:11 <cdsmith> So it's okay to assume formal parameters are safe because... ?
21:44:27 <cdsmith> oh, never mind.
21:44:32 <SamB> cdsmith: the actual parameters would be flagged as unsafe if they were ;-)
21:45:00 <sjanssen> right, flagged as unsafe elsewhere in the program
21:45:06 <SamB> I suppose you'd call this process "safety inference"
21:46:05 <SamB> it would be rather a like type inference, but totally orthoganal and with a simpler minimal implementation
21:46:19 <sjanssen> now, SOURCE is a bit special
21:46:29 <cdsmith> So the result of safety inference will be a formula in disjunctive-normal form, with packages acting as variables.
21:46:30 <SamB> of course, you *would* want to optimize the assumption trees somewhat
21:46:36 <sjanssen> s/SOURCE/SAFE
21:46:41 <SamB> cdsmith: disjunctive-normal form?
21:46:44 <SamB> I missed that part
21:47:08 <cdsmith> SamB: or conjunctive; but disjunctive is more useful I think, in this case.
21:47:54 <SamB> You shouldn't need any "nots", either
21:47:58 <cdsmith> right
21:48:05 <sjanssen> {-# SAFE f #-} means that there exists a proof of the safety of f in the package authors head -- ie. a promise that f is safe *regardless of unsafe functions that are called*
21:48:14 <SamB> but you would need a True
21:48:42 <cdsmith> SamB: Yes, I suppose you do.
21:48:56 <sjanssen> therefore we forget the safety assumptions in the subexpressions of f, and simply give it a single assumption: a trust in the package itself
21:49:04 <SamB> well, I suppose one way to represent these things would be Set (Set PackageName)
21:49:12 <SamB> hmm?
21:49:21 <MyCatVerbs> sjanssen: that is going to be hilarious if there's a bug somewhere in there.
21:49:29 <SamB> er, excluding the case of True
21:49:33 <cdsmith> sjanssen: I don't think we forget; just augment
21:49:44 <sjanssen> cdsmith: I'm convinced forgetting is better
21:49:54 <MyCatVerbs> sjanssen: but, Hell, what better excuse is there for using .lhs and bundling a large proof-of-correctness in TeX format? ^^
21:50:08 <SamB> sjanssen: oh?
21:50:09 <cdsmith> sjanssen: how so?  If I don't trust the package author, but there exists a proof using package I do trust, why shouldn't I use the function?
21:50:10 <SamB> why?
21:50:51 <sjanssen> our options are: AssumptionsInSubexpressions || TrustPackageFoo
21:50:56 <sjanssen> or: TrustPackageFoo alone
21:51:21 <sjanssen> in the common case, the first branch is essentially useless
21:51:46 <cdsmith> sjanssen: it's useless even if I don't trust Foo?
21:51:55 <sjanssen> and just overcomplicates the algorithms and representations of the formula
21:52:13 <SamB> oh, I suppose you might need a False as well...
21:52:34 <cdsmith> SamB: why would you need a false?  I don't think you do.
21:52:37 <SamB> hmm.
21:52:44 <SamB> no, right, you wouldn't
21:52:50 <SamB> not internally anyway.
21:52:59 <sjanssen> cdsmith: yes, the downside is that you must trust Foo to use the SAFE marked functions in Foo -- because the info is thrown away
21:53:06 <SamB> if you wanted to print them out nicely you would, though.
21:53:13 <sjanssen> but I think this is the right decision in practice
21:53:31 <cdsmith> sjanssen: it seems so very wrong to me. :(
21:53:44 <SamB> sjanssen: how about we try it the other way first?
21:53:55 <SamB> if it wastes too much space, we'll reconsider.
21:54:03 <sjanssen> cdsmith: do you see how it never turns a non-trusted program to a trusted one?
21:54:17 <SamB> sjanssen: of course we see that
21:54:28 <cdsmith> sjanssen: umm, I don't understand the question
21:54:29 <SamB> but we also see how it turns trusted programs into untrusted ones
21:54:39 <sjanssen> yes, it rejects more programs
21:54:44 <SamB> cdsmith: he is saying that his idea doesn't let you get away with anything
21:55:02 <cdsmith> sjanssen: right; I agree your strategy is safe.  It's just unnecessarily conservative.
21:55:21 <SamB> necessity will be determined after implementation
21:55:54 <sjanssen> meh, this is mostly inconsequential to the rest of the system
21:56:17 <sjanssen> so we need ||, &&, and True
21:56:43 <cdsmith> sjanssen: Yep, pretty much.
21:56:43 <sjanssen> consider unsafePerformIO and friends to be a member of a magic UNSAFE_PRIMS package
21:57:00 <cdsmith> sjanssen: Why?  They will just be non-safe members of base.
21:57:16 <SamB> so, we have data Safety = Safe | SafeDNF (Set (Set PackageName)), where I just made up the name PackageName
21:57:48 <sjanssen> cdsmith: we don't have a concept of 'non-safe' right now -- we're constructing proofs of safety, not the other way around
21:58:12 <cdsmith> sjanssen: I don't see why that's necessary.  Just don't mark them safe.
21:58:13 <sjanssen> SamB: drop 'Safe' -- safe functions are represented by SafeDNF Set.empty
21:58:24 <SamB> sjanssen: no, those are the unsafe functions
21:58:46 <cdsmith> SamB: SafeDNF $ singleton Set.empty
21:59:01 <SamB> true
22:01:43 <cdsmith> sjanssen: Are we still disagreeing about the magic package?
22:02:06 <SamB> I guess you'd need to remove any supersets from the outer set?
22:02:33 <cdsmith> SamB: Yes.  Well, it's a good idea, anyway.
22:02:37 <sjanssen> I think making "SafeDNF Set.empty" mean False isn't quite right
22:03:07 <SamB> sjanssen: it means that there aren't any sets of packages that, if they are all trusted, prove this function safe
22:03:16 <SamB> so that this function is assumed to be unsafe
22:03:36 <SamB> sensible?
22:03:59 <sjanssen> yeah
22:04:29 <cdsmith> whereas singleton Set.empty means that there is one such set, and it's empty; so all its packages are trusted, trivially
22:06:30 <sjanssen> so we also need a pragma (or special compiler knowledge) to mark things as unsafe
22:06:41 <cdsmith> no, I don't see why.
22:07:54 <cdsmith> or maybe I do.  What does the implementation of unsafePerformIO look like?
22:08:05 <sjanssen> @src unsafePerformIO
22:08:06 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
22:08:07 <SamB> compiler knowledge, perhaps
22:08:11 <sjanssen> just pattern matching
22:08:21 <SamB> oh.
22:08:24 <SamB> hmm.
22:08:39 <cdsmith> So anything of kind # is unsafe, obviously.
22:08:47 <sjanssen> not really
22:08:48 <SamB> cdsmith: yeah right
22:08:52 <SamB> Int# isn't
22:09:01 <SamB> @kind Int#
22:09:09 <lambdabot> Not in scope: type constructor or class `Int#'
22:09:13 <SamB> aww
22:09:20 <SamB> @kind GHC.Base.Int#
22:09:26 <lambdabot> #
22:09:29 <sjanssen> and there are other kinded things that are unsafe IIRC
22:10:01 <sjanssen> so you could mark realWorld# as unsafe
22:10:19 <SamB> hmm.
22:10:25 <SamB> @index realWorld#
22:10:26 <lambdabot> bzzt
22:10:31 <SamB> @hoogle realWorld#
22:10:32 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
22:10:34 <SamB> @hoogle realWorld
22:10:35 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
22:10:41 <SamB> not quite...
22:10:42 <int-e> @src IO
22:10:42 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:10:56 <SamB> @source GHC.IO
22:10:57 <lambdabot> GHC.IO not available
22:10:59 <SamB> @source GHC.IOBase
22:10:59 <lambdabot> GHC.IOBase not available
22:11:05 <SamB> @google GHC.IOBase
22:11:08 <lambdabot> http://www.cis.upenn.edu/~bcpierce/courses/advprog/resources/base/GHC.IOBase.html
22:11:48 <cdsmith> So yeah, I'm unclear on how things become unsafe at a really low level.
22:12:20 <SamB> well, I guess you'd need an {-# UNSAFE #-} pragma
22:12:30 <SamB> or something
22:12:38 <sjanssen> right, or compiler knowledge
22:12:49 <cdsmith> Well, I'm still unconvinced.  Unsafeness has to come FROM somewhere.
22:13:03 <sjanssen> the things that you really want to mark unsafe probably don't even have source code
22:13:28 <cdsmith> Okay, so FFI stuff has to be unsafe, right?
22:13:35 <sorear> No.
22:13:41 <SamB> I think realWorld# is your best bet...
22:13:55 <sorear> If you trust the foreign functions, and check the types are correct, FFI is safe.
22:13:56 <SamB> cdsmith: only if it hasn't got an IO type
22:14:00 <sjanssen> FFI stuff that doesn't have an IO type should require a SAFE pragma
22:15:18 <cdsmith> sorear: How could FFI be safe, if it's written in a different language?
22:15:42 <SamB> cdsmith: well, how is removeFile safe?
22:15:59 <SamB> hint: it isn't a backdoor
22:16:09 <sorear> cdsmith: "If you trust the foreign functions"
22:16:09 <int-e> cdsmith: obviously the haskell compiler can't tell; it'll have to trust the programmer.
22:16:23 <cdsmith> SamB: it isn't, clearly.  If it were, then this whole exercise would be pointless.
22:16:25 <sorear> int-e: it only needs to trust the *c* programmer.
22:16:30 <SamB> cdsmith: sure it is
22:17:02 <cdsmith> Right, okay.  Then I agree that FFI needs to have IO type, or be unsafe.  In fact, anything with IO type should be implicitly safe, I gues.
22:17:14 <sorear> int-e: Suppose the C programmer is $LIBC_MAINTAINER.  you have to trust him (who's fopen is called on your secret key?)
22:17:36 <sjanssen> cdsmith: I disagree
22:17:55 <SamB> cdsmith: if things with IO type are unsafe, how are we supposed to print the output of lambdabot's template program?
22:17:58 <sorear> int-e: In practice, it is probably better just to have trusted haskell libs,  but in theory nothing stops the haskell taint checker from knowing what foreign functions are safe
22:18:08 <int-e> sorear: and the c compiler writer, and the kernel writer.
22:18:37 <int-e> sorear: obviously any notion of safety we're discussing right now is fairly limited.
22:18:40 <SamB> int-e: and the c compiler compiler
22:18:50 <SamB> in more sense than one
22:18:58 <sorear> There will be no reflections on trusting trust in #haskell, please :)
22:19:10 <SamB> heh
22:19:15 <SamB> exactly!
22:19:16 <int-e> SamB: diverse compilation breaks the trusting trust dilemma, I thought? or at least makes it far less of an issue.
22:19:41 <SamB> int-e: well. sure, if you compile your compiler with tcc that does make things less worrisome
22:19:54 <cdsmith> So I'm still completely lost on where unsafe code comes from.
22:19:57 <sorear> I sidestep the whole issue by explicitly trusting RMS!
22:20:13 <SamB> sorear: so RMS personally bootstrapped your GCC?
22:21:41 <int-e> cdsmith: but you can implement pure functions in C. those shouldn't require an IO type when used from Haskell.
22:21:57 <SamB> oooh, they fixed the unsafePerformIO race condition?
22:22:02 <int-e> cdsmith: unsafe code comes from unsafe primitive operations
22:22:03 <cdsmith> int-e: but they'd need some trusted person to attest to their safety.
22:22:07 <SamB> I see unsafeDupablePerformIO
22:22:13 <int-e> SamB: yeah
22:22:25 <SamB> int-e: you have to trust that C code, though
22:22:34 <SamB> so you'd need to mark those as SAFE explicitly
22:22:35 <int-e> cdsmith: right. that would be the person who writes the FFI binding, and the C code writer.
22:22:58 <cdsmith> int-e: and they could add an explicit SAFE directive, which resolves everything.
22:23:13 <SamB> I'm thinking realWorld# is a primitive
22:23:21 <SamB> a dangerous one
22:24:06 <int-e> @type GHC.Base.unsafeCoerce#
22:24:15 <lambdabot> forall t b. t -> b
22:24:17 <sjanssen> I'm sure a GHC expert could compile a list of unsafe primops
22:24:57 <cdsmith> sjanssen: did you disagree earlier that anything with IO type can be considered safe?
22:25:06 <SamB> they'd probably generate functions to test for primop unsafety in the usual manner
22:25:13 <SamB> cdsmith: I did!
22:25:28 <SamB> well, maybe not anything with IO type
22:25:43 <SamB> but certainly IO type is not a reason to consider it unsafe
22:25:50 <cdsmith> SamB: Huh?  You disagreed?
22:26:09 <SamB> for instance, main kinda has to have type IO ()
22:26:17 <cdsmith> SamB: No, I mean I now believe that anything of IO type can be considered SAFE.
22:26:26 <SamB> cdsmith: also false!
22:26:32 <dibblego> cdsmith, not necessarily
22:26:45 <cdsmith> okay, how so?
22:26:47 <dibblego> cdsmith, better might be, you should not elevate the "safeness status" of IO
22:27:03 <SamB> say you have...
22:27:08 <sjanssen> unsafePerformIO badStuff `seq` return () :: IO () -- is unsafe
22:27:28 <sjanssen> hrm, maybe it isn't
22:27:34 <cdsmith> It's only unsafe if you unwrap it, though...
22:27:43 <SamB> unsafePerformIO (removeFile "/etc/passwd" >> return (return ()))
22:27:55 <dibblego> cdsmith, I once read a blog post that made the claim that IO qualifies Haskell as impure, then the author of that blog had the nerve to come to my blog and tell me that I don't know what referential transparency means - I had a big laugh that day :)
22:28:20 <sjanssen> cdsmith: all it takes is another 'seq' to execute badStuff
22:28:29 <SamB> @type unsafePerformIO (print "boo!" >> return (return ()))
22:28:33 <lambdabot> Not in scope: `unsafePerformIO'
22:28:42 <SamB> oh. right ;-)
22:29:05 <int-e> dibblego: heh. as if it's Haskell's fault that the Evil RTS takes the IO action main produces and *executes* it.
22:29:10 <SamB> @type let unsafePerformIO :: IO a -> a; unsafePerformIO = undefined in unsafePerformIO (print "boo!" >> return (return ()))
22:29:14 <lambdabot> IO a -> a; unsafePerformIO = undefined in unsafePerformIO (print "boo!" >> return (return ())) :: forall (m :: * -> *). (Monad m) => m ()
22:29:35 <SamB> well. that could be restricted to type IO ()
22:30:19 <sjanssen> cdsmith: anyway, we shouldn't need type info to determine safety
22:30:26 <cdsmith> Hmm...
22:30:39 <int-e> @let safe _ = False
22:30:43 <lambdabot> Defined.
22:30:47 <dibblego> int-e, I'll dig it up :)
22:31:04 * dibblego procrastinates
22:32:20 <cdsmith> Okay, then.  I'm getting lost here.
22:33:27 <int-e> @quote bad
22:33:27 <lambdabot> Binkley says: Using analogies to introduce monads is almost as bad as trying to change a tire with a tennis racket.
22:33:35 <cdsmith> SamB: That creates a value of type IO () that encapsulates an unsafePerformIO; but will the unsafePerformIO ever be run if the expression never makes it back to something that runs IO actions?
22:34:00 <SamB> cdsmith: `seq` () and see!
22:34:24 <int-e> maybe `seq` should be considered unsafe ;)
22:34:33 <SamB> int-e: yeah right
22:34:34 <cdsmith> Okay, yeah you're right.
22:34:35 <dibblego> http://kawagner.blogspot.com/2007/02/why-monads-are-evil.html "But even Haskell isn't [functional]. The reason is the IO-monad." http://blog.tmorris.net/strong-type-systems/ "I really have ask myself, if Tony [the author] even knows the meaning of pure in this context."
22:34:37 <lambdabot> Title: Karsten Wagner's Blog: Why monads are 'evil'
22:35:12 <sjanssen> IO a is a perfectly respectable pure data type
22:35:18 <int-e> and pattern matching, of course.
22:35:26 <dibblego> sjanssen, tell kawagner.blogspot.com that :)
22:35:32 <cdsmith> So I guess I agree with sjanssen: ignore types.
22:35:33 <int-e> soon you'll not be able to evaluate anything but that's ok - it would be perfectly safe.
22:35:47 <sjanssen> it's the IO-value interpreter packaged with your Haskell system that isn't referentially transparent :)
22:36:01 <SamB> sjanssen: sure it is
22:36:04 <SamB> all black boxes are
22:38:02 <int-e> haha. "So it's the bind-function which isn't really referential transparent: If you apply it to the same action twice, it can call it's 'to-do' function with a different value." - so  f g = (g 1, g 2) is not referentially transparent? funny. I always thought it was.
22:38:18 <SamB> hehe
22:38:52 <SamB> > "Hello" >>= return
22:39:01 <lambdabot>  "Hello"
22:39:14 <SamB> that runs its second argument with 5 different values ;-)
22:39:26 <SamB> well, okay, so two of them are actually the same value
22:50:55 * araujo just realized he is programming Haskell using Python
23:34:21 <LeCamarade> Why does GHC pack Perl with it? (Specific use? Don't give me monadic answers - `because it uses it'. :oD)
23:35:49 <sjanssen> the Evil Mangler is written in Perl
23:36:25 <sjanssen> it massages gcc's assembly output in various ways
23:37:56 <LeCamarade> Hmm ... very pragmatic. I've never agreed with having malloc(3) in compiler code. More like s/#$%%$#$%#@/$2$5$2/gi.
23:37:57 <LeCamarade> :oD
23:38:39 <ulfdoz> malloc is the most error-prone thing I've ever used.
23:41:19 <QtPlatypus> LeCamarade: How to you allocate memory otherwise?
23:41:51 <QtPlatypus> (And yes the language should take care of that for you.  but C is for boostrapping)
23:50:09 <LeCamarade> QtPlatypus: This is how :o) ...
23:50:19 <LeCamarade> mov 200, ax
23:50:35 <LeCamarade> mov 1, bx
23:50:39 <LeCamarade> int 80
23:50:52 <LeCamarade> push ax
23:51:11 <LeCamarade> ; Mem pointer is on stack.
23:51:26 <LeCamarade> push cx ; Put ret pointer back
23:51:28 <LeCamarade> ret
23:51:30 <LeCamarade> :oD
23:52:39 <QtPlatypus> Is that just for Compiler code, or for all code?
23:53:58 <ulfdoz> I think, that's even x86-specific.
23:55:43 <MyCatVerbs> ulfdoz: duh, nobody else uses ax, bx, cx, etc.
23:55:55 <MyCatVerbs> ulfdoz: all the cool MIPSing kids use $0-$31 instead.
23:56:48 <ulfdoz> MyCatVerbs: I know mips only from spim, and that is several years ago.
23:58:37 * MyCatVerbs ponders sleep.
23:59:12 <LeCamarade> MyCatVerbs: I hate AT&T syntax for the same reason I love Haskell syntax. Decoration sucks.
23:59:16 <encryptio> @where hmp3
23:59:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
