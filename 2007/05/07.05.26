00:13:02 <dons> ""multitask" allows Python programs to use generators (aka coroutines) to perform cooperative multitasking and asynchronous I/O"
00:13:08 <dons> sounds suspiciously like a monad, imo..
00:13:43 <edwardk> generator based multitasking is pretty lame ;)
00:14:13 <edwardk> but its the only inversion of control primitive they have i guess
00:15:05 <dons> yeah
00:15:25 <dons> edwardk: my python's not great. is it just laziness? or a deformed list monad by stealth?
00:15:48 <dons> shapr: hey, i reckon we should wear suits like this for the next haskell hackathon, whaddya think? --> http://www.cse.unsw.edu.au/~ignjat/Mercury_Seven.jpg
00:16:12 <dons> Lambda-nauts of the Cosmos!
00:16:18 <edwardk> well, basically it 'yields' values one at a time, storing and restoring state on subsequent requests. its closer to 'dynamic wind' than either
00:16:54 <edwardk> you jump back into the generator more or less where you were when you left, poor man's coroutines
00:17:32 <dons> ad hoc continuations?
00:17:38 <edwardk> not as powerful
00:17:52 <sorear> dons: a generator monad can be built trivially in haskell vvv
00:18:00 <edwardk> you can only return a value and bake your state into a continuation that when reinvoked you can feed back another one
00:18:00 <dons> yeah, i know :-)
00:18:06 <sorear> newtype Gen r a = Cont [r] a
00:18:12 <sorear> + deriving(Monad)
00:18:17 <dons> ah right, good point sorear
00:18:20 <sorear> yield x = Cont (x:)
00:18:34 <sorear> there, 2 lines of ghc haskell :)
00:18:38 <edwardk> =)
00:18:47 <dons> sorear: why don't you write a little blog article countering the use of generators in python, by showing what is really going on.
00:19:15 <edwardk> well, the javascript committee actually went with generators rather than continuations explicitly
00:19:18 <sorear> dons: Because I don't have one? :)
00:19:29 <sorear> stack nazis
00:19:35 <edwardk> partially because they are better understood by the programming community at large
00:19:38 <dons> this is the link, http://programming.reddit.com/goto?id=1tje3, that just makes my inner language guy cringe with thoughts of "ad hoc"
00:19:40 <lambdabot> Title: multitask - O2S Wiki
00:19:46 <sorear> er, mutable stack nazis
00:19:51 <edwardk> and partially because they didn't want to affect the stack model their implementations were using
00:20:04 <sorear> purely functional stacks give you continuations for free!
00:20:22 <sorear> (aka defunctionalized CPS)
00:28:18 <fuzan> sorear: ping ?
00:28:51 <sorear> fuzan: pong!
00:29:21 <fuzan> are you aware of any odd VTY drawing issues?
00:30:24 <fuzan> sorear: http://www.fuzan.org/before.PNG http://www.fuzan.org/after.PNG
00:30:25 <sorear> fuzan: For $TERM == "linux", no.
00:30:57 <fuzan> my app does this when the text reaches the info bar
00:31:03 <fuzan> refresh/resize clears the anomalies
00:31:04 <sorear> ah yes, urxvt had trouble earlier
00:31:11 <sorear> I think I've fixed it
00:31:15 <fuzan> it's also xterm and plain console
00:31:35 <fuzan> i'm probably doing something wrong, but i'm not entirely sure :)
00:32:50 <sorear> fuzan: the api is so restricted I don't think it's *possible* to cause that problem...
00:33:06 <sorear> fuzan: double check that you are always passing the correct size image
00:33:25 <sorear> fuzan: and vty is looking for a new maintainer *hint hint hint*
00:33:36 <fuzan> sorear: i'm not skilled enough yet :)
00:34:32 <fuzan> sorear: http://fuzan.org/repo/fzbot/Interface.hs
00:35:06 <fuzan> botDraw is where I render the image
00:36:32 <fuzan> i was suspicious of image length, so i forced all code to be of the form (take sx ... )
00:37:53 <sorear> *sigh*
00:38:05 <Excedrin> bnet chat bot? neat
00:38:20 <sorear> we need better combinators and a more robust core...
00:38:39 <fuzan> :)
00:39:15 <fuzan> it uses a 3rd party for returning checksums / client verification
00:41:44 * sorear takes a deep breath, rolls up his metaphorical sleeves, sets the Kestrel-forth project aside, and starts work on vty4
00:42:20 <fuzan> sorear: so you're not sure what the issue is?
00:45:26 <sorear> not at all.  I'd run myprog | tee dump  and look for suspicious codes
00:47:50 <fuzan> kk
00:47:59 <fuzan> the odd thing is that it disspears on redraw
00:49:39 <sorear> definitely.
01:06:49 <ivanm> where's a good guide/example on how to get Read working for a custom data type?
01:07:13 <Heffalump> presumably you can't just derive it?
01:07:28 <ivanm> Heffalump: well, the datatype is [[Maybe Int]]
01:07:38 <Heffalump> that should already have an instance
01:07:44 <ivanm> but, to make it use current conventions so other non-haskell people could read it
01:07:54 <ivanm> I want to replace all Nothings with 0, and all Just x with just x
01:07:58 <Heffalump> ah
01:07:58 <ivanm> since x >= 0
01:08:11 <Heffalump> you'll need a newtype wrapper, then
01:08:14 <fuzan> s/Nothing/NULL
01:08:15 <Korollary> dont you need x > 0
01:08:17 <ivanm> yeah, I've got that
01:08:24 <Heffalump> but I suggest what you do is wrap Maybe Int, not [[Maybe Int]]
01:08:25 <Excedrin> why not remove "just" and have a list with some zeros?
01:08:28 <ivanm> Korollary: yeah... whoops
01:08:34 <Heffalump> unless you want to change the list syntax too
01:08:38 <ivanm> Excedrin: I spent ages getting rid of that!!! :D
01:09:01 <ivanm> since Maybe Int makes more sense for what I'm doing (a sparse matrix) than Int with 0s representing empty
01:09:33 <ivanm> Heffalump: well, if I wrap Maybe Int, then I'll have to go through and continuosly wrap/unwrap it
01:09:39 <Excedrin> well, you could always bust out some Gtk2hs...
01:09:49 <Korollary> wouldnt a pair type be better for sparse matrices?
01:09:52 <ivanm> and I'm going to have other [[Maybe Int]] -> String functions that pretty-print the matrix
01:10:03 <ivanm> Excedrin: why? its not a gui...
01:10:30 <Excedrin> if end-users are using it, why force them to learn some funky matrix format?
01:10:31 <ivanm> Korollary: its not quite a sparse matrix... it's for latin squares, so I don't know how many will be empty
01:10:39 <ivanm> and the operations I use are list based
01:10:48 <ivanm> Excedrin: because that's how they already use it?
01:10:53 <Excedrin> o, ok
01:10:55 <ivanm> well, actually, they just use it as numbers...
01:11:08 <ivanm> Excedrin: its not a user interactive program
01:11:26 <ivanm> you pass it in inputs at the command line, and it prints results to file
01:12:15 <Heffalump> ivanm: well, you could just define a map function to do it
01:12:22 <Heffalump> it's no worse than having to unwrap the newtype itself
01:12:40 <Heffalump> (map (map Wrapped)) / map (map (unWrap)) versus Wrapped / unWrap
01:13:08 <Heffalump> there's no significance to my weird bracketing
01:13:10 <ivanm> Heffalump: the problem is, I have no idea how to define readsPrec :s
01:13:44 <ivanm> Heffalump: I'm not always using it as Maybe Int...
01:13:54 <ivanm> sometimes it becomes Maybe [Int]
01:13:55 <Heffalump> I usually just pattern match against the first characters
01:14:01 <ivanm> other times I want just the Ints themselves
01:14:08 <ivanm> Heffalump: ?
01:14:20 <ivanm> with Show, it was easy... just define show
01:14:32 <ivanm> but for Read I can't just define read, though I know how to do that :(
01:14:56 <Heffalump> the point is to pass on all the possible tails after you've finished your parse
01:15:05 <ivanm> huh?
01:15:06 <Heffalump> @type readsPrec
01:15:10 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
01:15:19 <Heffalump> ok, so ignore the precedence parameter for now
01:15:23 <ivanm> *nod*
01:16:04 <Heffalump> readsPrec _ ('j':'u':'s':'t':' ':rest) = [(Wrapped (Maybe n), rest') | (n, rest') <- reads rest]
01:16:16 <Heffalump> s/Maybe/Just/
01:16:24 <Heffalump> and then another clause to handle the case where there's no just
01:17:09 * ivanm still doesn't get it...
01:17:18 <Heffalump> what don't you get about that definition?
01:17:20 <ivanm> is readsPrec meant to do it character by character or something?
01:17:34 <ivanm> I don't get what you're actually doing...
01:17:34 <Heffalump> it doesn't have to, I just find it easier for short prefixes
01:17:38 <Heffalump> you could use isPrefixOf instead
01:17:54 <Heffalump> I'm looking for "just " at the beginning, then parsing the string after it for an Int
01:19:56 <ivanm> OK...
01:20:01 <ivanm> but I'm not reading in Just...
01:21:06 <ivanm> its going to be reading in something like "[[0,1],[2,0]]" and wanting to turn it into [[Nothing,Just 1],[Just 2,Nothing]]
01:22:43 <Heffalump> oh, I thought you meant "just x" literally above
01:22:53 <ivanm> no...
01:23:18 <ivanm> my show function converts Nothing to 0 and Just x to x, to make it more like the standard method
01:23:19 <Heffalump> readsPrec _ str = [(case n of 0 -> Nothing ; _ -> Just n, rest) | (n, rest) <- reads str]
01:23:32 <ivanm> though normally they don't have the brackets, just space-separated numbers
01:23:40 <Heffalump> you have an odd definition of "standard"
01:23:45 <Heffalump> but fair enough
01:23:50 <Heffalump> try my new definition
01:24:10 <ivanm> Heffalump: not really.... because most people who write software for Latin Squares don't use Haskell ;-)
01:24:21 <ivanm> @type readsPrec _ str = [(case n of 0 -> Nothing ; _ -> Just n, rest) | (n, rest) <- reads str]
01:24:29 <lambdabot> parse error on input `='
01:24:36 <ivanm> heh
01:24:48 <ivanm> @type readsPrec n str = [(case n of 0 -> Nothing ; _ -> Just n, rest) | (n, rest) <- reads str]
01:24:50 <lambdabot> parse error on input `='
01:25:30 <TSC> @type \ n str -> [(case n of 0 -> Nothing ; _ -> Just n, rest) | (n, rest) <- reads str]
01:25:32 <lambdabot> forall t a. (Read a, Num a) => t -> String -> [(Maybe a, String)]
01:26:20 <ivanm> Heffalump: its reading in something that is the String form of [[Int]] and converting it to [[Maybe Int]]
01:26:44 <ivanm> e.g. I want: read "[[0,1],[2,0]]" = [[Nothing,Just 1],[Just 2,Nothing]]
01:26:56 <ivanm> I have a function that will turn 0 -> Nothing and x -> Just x
01:31:33 <Heffalump> well, the general idea is that you parse a string from left to right
01:31:46 <ivanm> *nod*
01:32:02 <ivanm> so it
01:32:07 <Heffalump> look for the characters that are specific to your type, then use sub-read functions from contained types to parse their bits, and get the tails back from those, and keep going
01:32:15 <ivanm> so it's not as easy as reading in the string as [[Int]] and converting it?
01:32:23 <ivanm> :(
01:32:25 <Heffalump> oh, yes, that would work
01:32:26 <Heffalump> sorry :-)
01:32:33 <Heffalump> just map your conversion function over it
01:32:35 <ivanm> heh, that's what I'm trying to do
01:32:41 <Heffalump> well, roughly
01:33:08 <Heffalump> readsPrec _ str = [(map (map conv) res, rest) | (res, rest) <- reads str]
01:34:38 <ivanm> yay, it works!!!
01:34:43 <ivanm> thanks Heffalump++ ! :D
01:35:04 * ivanm didn't think to have a readsPrec for the string, was trying to use normal read :s
01:35:07 <ivanm> @botsnack
01:35:08 <lambdabot> :)
01:35:31 <Heffalump> @karma
01:35:32 <lambdabot> You have a karma of 9
01:35:48 * Heffalump tries to remember what his karma was before to figure out if lambdabot parses embedded ++s
01:36:02 <ivanm> heh
01:36:09 <ivanm> what do you mean, Heffalump++ ?
01:36:12 <Heffalump> yes
01:36:13 <ivanm> @karma Heffalump
01:36:13 <lambdabot> Heffalump has a karma of 10
01:36:18 <Heffalump> apparently so..
01:36:32 <ivanm> lets try this, Heffalump--
01:36:34 <ivanm> @karma Heffalump
01:36:34 <lambdabot> Heffalump has a karma of 9
01:36:46 <Heffalump> that's good in some ways, but bad in others cos you can't talk about how to change karma without obfuscating it
01:37:01 <ivanm> right, now that I've got read working, its time for dinner
01:37:32 <Heffalump> what timezone are you in?
01:37:40 <Heffalump> ah, Australia
02:36:48 <BleSS> Hi! it would be interesting that somebody would write the version in haskell for Fractal Benchmark - http://www.timestretch.com/FractalBenchmark.html
02:36:50 <lambdabot> Title: Ruby, Io, PHP, Python, Lua, Java, Perl, Applescript, TCL, ELisp, and C Fractal B ...
02:39:07 <ivanm> Heffalump: yup, I'm an aussie like dons
02:39:19 <ivanm> well, not _quite_ like dons... he's a southerner
02:39:20 <ivanm> ;-)
02:39:22 <opqdonut> BleSS: i have an ascii-mandelbrot oneliner
02:39:33 <opqdonut> i can hand you the source if you want to modify it
02:40:28 <opqdonut> but yeah, if it's supposed to be written "in the same way" as the others...
02:40:32 <opqdonut> imperative haskell
02:40:50 <BleSS> opqdonut: thanks, you could sed it to the original author - erik@timestretch.com
02:41:20 <dolio> I have one that does pictures somewhere, I think...
02:41:46 <opqdonut> that page wants an ascii one
02:41:54 <opqdonut> BleSS: can't be bothered to :P
02:41:55 <ivanm> BleSS: don't know what I'm doing wrong, but I can't even get the C code that's there to work... :s
02:42:02 * ivanm hasn't had much experience with C
02:42:18 <dolio> Ah. It might do that, too. It's how I was originally showing the output. :)
02:42:34 <opqdonut> http://opqdonut.users.paivola.fi/mandel.hs <-- there ya go
02:44:24 <BleSS> I'm not the author of that page, but I thinked that would interesting to add another languages to make a reasonable performance comparison - to contact with the author: erik@timestretch.com
03:05:58 <dons> > map (^2) [1..]
03:05:59 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
03:06:08 <dons> > readFile "/etc/passwd"
03:06:10 <lambdabot>  <IO [Char]>
03:06:11 <dons> > ord
03:06:13 <lambdabot>  <Char -> Int>
03:06:32 <opqdonut> )
03:08:21 <Syzygy-> ?pl (\x,y -> 2^x+3^y)
03:08:21 <lambdabot> uncurry ((. (3 ^)) . (+) . (2 ^))
03:09:35 <BleSS> opqdonut: thanks for the code
03:11:52 <mauke> yow
03:11:58 <mauke> newtype W c a = W {unW :: Ctx -> IO ((a -> IO c) -> IO c)} is a monad
03:13:40 <dons> looks a bit like a ContT ?
03:14:22 <mauke> yeah
03:14:55 <dons> @unmtl ContT Ctx (IO a) c
03:14:55 <lambdabot> err: Unknown MTL(1)
03:15:09 <dons> @unmtl ContT b (IO a) c
03:15:10 <lambdabot> err: Unknown MTL(1)
03:15:12 <dons> hmm
03:15:22 <dons> ?unmtl State Int Double
03:15:23 <lambdabot> Int -> (Double, Int)
03:15:35 <cinimod> @djinn
03:15:35 <lambdabot> Cannot parse command
03:15:39 <dons> ?unmtl ContT A (ContT B IO) C
03:15:39 <lambdabot> (C -> (A -> IO B) -> IO B) -> (A -> IO B) -> IO B
03:15:46 <cinimod> @help
03:15:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:15:56 <dons> ?unmtl ContT A (IO B) C
03:15:56 <lambdabot> err: Unknown MTL(1)
03:15:58 <mauke> ?unmtl ContT c IO a
03:15:58 <lambdabot> (a -> IO c) -> IO c
03:16:05 <dons> there we go.
03:16:07 <dolio> Mmm, double continuations.
03:16:19 <dons> ?mtl Ctx -> IO ((a -> IO c) -> IO c)
03:16:19 <lambdabot> Maybe you meant: ft map msg pl unmtl url
03:16:21 <dons> hah
03:16:25 <dons> too hard :-)
03:16:25 <cinimod> @help djinn
03:16:26 <lambdabot> djinn <type>.
03:16:26 <lambdabot> Generates Haskell code from a type.
03:16:26 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
03:16:42 <dons> so its a Ctx -> IO (ContT c IO a)
03:16:46 <dons> fun
03:16:50 <cinimod> @djinn a -> a
03:16:51 <lambdabot> f a = a
03:16:58 <mauke> now I need to find out if it's useful
03:17:02 <dons> @unmtl Ctx -> IO (ContT c IO a)
03:17:03 <lambdabot> err: No applications
03:17:03 <cinimod> @djinn a -> b -> (a,b)
03:17:03 <lambdabot> f a b = (a, b)
03:17:18 <dons> you can compose @djinn with @pl too, for fun
03:17:23 <dons> @. pl djinn a -> b -> (a,b
03:17:24 <lambdabot> Cannot parse command
03:17:26 <dons> @. pl djinn a -> b -> (a,b)
03:17:26 <lambdabot> f = (,)
03:17:40 <cinimod> like this? @pl . @djinn a -> b -> (a,b)
03:17:48 <dons> no, like above.
03:17:56 <cinimod> aah
03:17:57 <dons> (prefix '.' )
03:17:59 <mauke> @pl W $ \c -> k c >>= \k' -> return $ \e -> k' ((>>= ($ e)) . ($ c) . unW . f)
03:18:00 <lambdabot> W (liftM2 (>>=) k ((return .) . flip (.) . flip ((.) . (=<<) . flip id) . flip (unW . f)))
03:18:14 <dons> @redo \c -> k c >>= \k' -> return $ \e -> k' ((>>= ($ e)) . ($ c) . unW . f)
03:18:15 <lambdabot> \ c -> do { k' <- k c; return $ \ e -> k' ((>>= ($ e)) . ($ c) . unW . f)}
03:21:53 <jeffz> hmm, why can't I do putStrLn("args !! 0 + args !! 1" ++ read args !! 0 + read args !! 1) - it says that it couldn't match expected type `Char' against inferred type `String'
03:22:55 <mauke> :t \args-> "" ++ read args !! 0 + read args !! 1
03:22:56 <hpaste>  jeffz pasted "I'm a newbie." at http://hpaste.org/57
03:23:01 <lambdabot>     No instance for (Num [Char])
03:23:01 <lambdabot>       arising from use of `+' at <interactive>:1:14-44
03:23:12 <mauke> :t \args-> "" ++ (read args !! 0 + read args !! 1)
03:23:14 <lambdabot>     No instance for (Num [Char])
03:23:14 <lambdabot>       arising from use of `+' at <interactive>:1:15-45
03:24:00 <hpaste>  mux annotated "I'm a newbie." with "should work" at http://hpaste.org/57#a1
03:24:37 <dons> :t jeffz or,
03:24:38 <dons>     let n = (read args !! 0) + (read args !! 1)
03:24:39 <dons>     putStrLn $ "args !! 0 + args !! 1" ++ show n
03:24:39 <lambdabot> parse error on input `,'
03:25:02 <dons> :t do args <- getArgs ; let n = (read args !! 0) + (read args !! 1) in putStrLn $ "args !! 0 + args !! 1" ++ show n
03:25:05 <lambdabot> Not in scope: `getArgs'
03:25:14 <dons> :t do args <- System.Environment.getArgs ; let n = (read args !! 0) + (read args !! 1) in putStrLn $ "args !! 0 + args !! 1" ++ show n
03:25:15 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
03:25:16 <lambdabot>       Expected type: String
03:25:39 <mux> you want read (args !! x)
03:26:14 <dons> Prelude> :info (!!)
03:26:14 <dons> (!!) :: [a] -> Int -> a
03:26:21 <dons> yes, no special binding powers for list indexing :}
03:26:37 <jeffz> thanks :)
03:28:27 <dons> or to be tricksy,
03:28:28 <dons> import Text.Printf
03:28:28 <dons> import System.Environment
03:28:28 <dons> import Control.Monad
03:28:28 <dons> main = do
03:28:30 <dons>     [a,b] <- liftM (map read) getArgs :: IO [Int]
03:28:33 <dons>     printf "1: %d, 2: %d\n" a b
03:28:41 <dons> (yes, pattern matching, lifting read, and printf :)
03:28:48 <mux> yum yum
03:30:14 <Saizan> uhm is the RTS smart enough to don't print anything if redirected to /dev/null? i notice a drastic performance difference
03:30:50 <dolio> Compared to what?
03:31:02 <dons> nope, but the IO devices will like you.
03:31:03 <Saizan> compared to let it print on the shell
03:31:18 <dolio> Displaying characters takes more time than dumping to a file.
03:31:28 <dons> you're just measuring IO buffering and the like, slow terminals .
03:31:41 <dons> compare > /dev/null   with   > /tmp/x
03:34:02 <Saizan> yeah, same time, i was surprised because it seemed faster than C (both on /dev/null) but repeating the bench C is still faster
03:36:02 <dons> what kind of IO are you doing?
03:36:06 <dons> [Char] or ByteString?
03:36:16 <Saizan> [Char]
03:36:50 <Cheery> how newtype worked again? my connection seems having some trouble right now
03:36:59 <Cheery> not even google opens
03:37:02 <Cheery> @go foobar
03:37:03 <lambdabot> http://www.foobar2000.org/
03:37:03 <lambdabot> Title: foobar2000
03:37:52 <mauke> newtype is like data, only restricted
03:37:52 <Saizan> newtype Foo = Foo Int, newtype Foo a = Foo (Maybe a) etc..
03:42:12 <sebell> Is newtype derivation in Haskell'?
03:44:11 <dolio> "52  Generalised deriving for newtype"
03:45:26 <ivanm> @src words
03:45:26 <lambdabot> words s = case dropWhile isSpace s of
03:45:26 <lambdabot>     "" -> []
03:45:26 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:45:36 <ivanm> @type words
03:45:38 <lambdabot> String -> [String]
03:45:44 <ivanm> dammit, I meant unwords
03:45:48 * ivanm always gets them mixed up :s
03:45:51 <ivanm> @src words
03:45:51 <lambdabot> words s = case dropWhile isSpace s of
03:45:51 <lambdabot>     "" -> []
03:45:51 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
03:45:57 <ivanm> arrgghhH!!!
03:46:00 <ivanm> @src unwords
03:46:00 <lambdabot> unwords [] = ""
03:46:01 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
03:46:25 <ivanm> @type intersperse
03:46:27 <lambdabot> forall a. a -> [a] -> [a]
03:49:36 <mauke> @pl \a b -> ($ a) . ($ b)
03:49:37 <lambdabot> flip (flip . flip id)
04:02:59 <ivanm> @src mapM_
04:02:59 <lambdabot> mapM_ f as = sequence_ (map f as)
04:04:23 <rabid> hello
04:05:01 <ivanm> hi rabid
04:05:31 <ivanm> @type sequence_
04:05:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:05:50 <ivanm> @type sequence
04:05:52 <lambdabot>     Ambiguous occurrence `sequence'
04:05:52 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
04:06:03 <ivanm> or?
04:06:05 <dmhouse> ?hoogle sequence
04:06:05 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
04:06:05 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
04:06:05 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
04:06:12 <ivanm> ahhh
04:06:27 <mauke> ?unmtl ReaderT Ctx (ContT () IO) a
04:06:27 <lambdabot> Ctx -> (a -> IO ()) -> IO ()
04:06:28 <ivanm> sequence_ just ignores the result from sequence?
04:06:49 <dmhouse> ivanm: yeah, pretty much.
04:06:56 <roconnor> @type sequence_
04:06:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:06:58 <ivanm> *nod*
04:07:02 <greentea> It discards the individual results in the sequence, i think.
04:07:03 <dmhouse> ivanm: it runs the actions for their side-effects, and ignores their results.
04:07:10 <ivanm> *nod*
04:07:24 <roconnor> sequence_ is often used on objects of type [m ()]
04:07:44 <dmhouse> So a correct implementation of sequence_ could be sequence_ xs = sequence xs >> return ()
04:07:48 <ivanm> *sigh* do I take small, simple one-liner function, or the slightly longer and possibly slightly faster do-notation function?
04:08:01 <ivanm> dmhouse: *nod*
04:08:03 <dmhouse> ivanm: take the one that's clearer.
04:08:22 <ivanm> well, the do-based one isn't unclearer...
04:08:30 <dmhouse> ivanm: what are the two options?
04:08:51 <ivanm> I'm printing a list of elements to a file, but rather than printing in one go I'm printing each element as soon as it occurs
04:09:04 <ivanm> My original function was:
04:09:06 <ivanm> > listPrinter      :: (a -> String) -> (String -> IO() ) -> [a] -> IO ()
04:09:06 <ivanm> > listPrinter _ _ []     = return ()
04:09:06 <ivanm> > listPrinter s f (x:xs) = do f (s x)
04:09:06 <ivanm> >                             f "\n"
04:09:06 <ivanm> >                             listPrinter s f xs
04:09:07 <lambdabot>  Parse error
04:09:07 <lambdabot>  Parse error
04:09:07 <lambdabot>   Not in scope: `f'
04:09:08 <lambdabot>   Not in scope: `listPrinter'
04:09:08 <lambdabot>   Not in scope: `xs'
04:09:11 <dmhouse> ?where paste
04:09:12 <lambdabot> http://hpaste.org/new
04:09:16 <ivanm> oh, yeah :s
04:09:20 <ivanm> right, I'll do that
04:10:04 <hpaste>  ivanm pasted "Incrementally performing IO on lists" at http://hpaste.org/58
04:10:29 * ivanm forgot about hpaste, or that he should be careful about copying from his lhs file to IRC
04:10:32 <dmhouse> ivanm: the latter is almost certainly better.
04:10:36 <ivanm> *nod*
04:10:53 <dmhouse> ivanm: it's 1) clearer, 2) conciser, 3) more idiomatic. I doubt it's much slower.
04:10:54 <ivanm> even though it's type sig is longer than the actual function ;-)
04:11:07 <ivanm> well, as for speed, I'm having trouble measuring it...
04:11:08 <rabid> I like listPrinter, easy to read and understand
04:11:18 <ivanm> but it looks like it _might_ be slightly faster
04:11:33 * ivanm thinks this is great... two people respond, each with a different opinion :s
04:11:35 <dmhouse> Moreover I doubt it'll become a bottleneck in your program. If it does, and not before, consider changing to listPrinter
04:11:45 <dmhouse> "Premature optimisation is the root of all evil."
04:11:52 <ivanm> oh, yeah, there's a small problem with printList I haven't fixed yet...
04:12:02 <ivanm> printing a newline between each element...
04:12:06 <ivanm> dmhouse: how would I do that?
04:12:17 <ivanm> true, its not the bottleneck
04:12:21 <dmhouse> ivanm: do what?
04:12:25 <ivanm> so speedgains will be minimal
04:12:45 <ivanm> dmhouse: the problem with printList is that I want to print a newline between each element..
04:12:58 <ezraburgh> @type intersperse
04:12:58 <ivanm> with listPrinter, I could just do an extra statement in the do..
04:13:00 <lambdabot> forall a. a -> [a] -> [a]
04:13:07 <ivanm> ezraburgh: no, I want it done incrementally
04:13:11 <Cheery> do you guys have a variation of a list that'd be always sorted?
04:13:14 <dmhouse> ivanm: perhaps mapM_ f . intersperse "\n" . map s?
04:13:14 <ivanm> see hpaste.org/58
04:13:38 <ezraburgh> ivanm, incrementally?
04:13:38 <ivanm> dmhouse: won't that lose the incremental factor though?
04:13:47 <dmhouse> ivanm: not sure. Try it!
04:13:53 <ivanm> ezraburgh: as in, I have a function that gradually generates values
04:13:59 <ivanm> and as soon as I get a value, I want to print it
04:14:51 <ezraburgh> oh i see, intersperse will wait to see if it gets another value before sticking something in between?
04:15:03 <ivanm> dmhouse: the other thing would be, how could I convert putFile = appendFile filename to print a newline?
04:15:06 <ivanm> a do statement?
04:15:12 <ivanm> ezraburgh: yeah, I think so
04:15:16 <roconnor> Cheery: how about FSet?
04:15:38 <dmhouse> ?src intersperse
04:15:39 <lambdabot> intersperse _   []     = []
04:15:39 <lambdabot> intersperse _   [x]    = [x]
04:15:39 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
04:15:53 <int-e> @unpl (msum .) . flip map . appFToList
04:15:53 <lambdabot> (\ g m -> msum (map m (appFToList g)))
04:18:54 <ivanm> dmhouse: arrghh... I can't tell... for one set of inputs, the program is that fast it doesn't seem to make a difference (< 1 s runtime)
04:19:06 <ivanm> for the next set of inputs, it takes 90 minutes, so I can't tell :(
04:22:03 <ezraburgh> ivanm, don't you want to print a newline *after* each item, rather than "between" them?
04:22:42 <ivanm> yeah...
04:22:47 <ivanm> same diff though
04:23:17 <ezraburgh> @type \s f -> mapM_ f . (map ((\x -> x ++ "\n") . s))
04:23:19 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> [Char]) -> ([Char] -> m b) -> [a] -> m ()
04:23:41 <ezraburgh> @type \s f -> mapM_ f . (map ((\x -> x ++ "\n") . s)) :: (a -> String) -> (String -> IO() ) -> [a] -> IO ()
04:23:43 <lambdabot>     Couldn't match expected type `a -> String'
04:23:43 <lambdabot>            against inferred type `[a1]'
04:29:03 <ivanm> dmhouse: well, it _appears_ to work to have intersperse in there like that...
04:29:15 <ivanm> I suppose because of the laziness in haskell, it works
04:31:04 <int-e> intersperse isn't as lazy as it could be, sadly :/
04:32:15 <int-e> intersperse _|_ (x:_|_) evaluates to _|_, while it could sensibly evaluate to x:_|_.
04:35:31 <ivanm> well, I meant lazy as in it's call by need ;-)
04:36:02 <int-e> > let intersperse _ [] = []; intersperse t (x:xs) = x:is' t xs; is' _ [] = []; is' t (x:xs) = t:x:is' t xs in fix ((1:) . intersperse 1 . map (1+))
04:36:03 <lambdabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,6,1,2,1,3,1,2...
04:36:16 <int-e> > fix ((1:) . intersperse 1 . map (1+)) -- :(
04:36:17 <lambdabot>  Exception: <<loop>>
04:36:35 <ezraburgh> i'm suprised it meets your need, ivanm... i'd think it needs to see whether the following element is [] to decide between the last two of its cases.
04:36:39 <ivanm> gahhh.... what are you doing?
04:36:59 <ivanm> ezraburgh: well, its probably slightly less efficient due to that...
04:37:01 <Igloo> int-e: If you want it changed, propose it: http://www.haskell.org/haskellwiki/Library_submissions
04:37:02 <lambdabot> Title: Library submissions - HaskellWiki
04:37:24 <ivanm> rather than waiting for one to finish, it requires two before it prints anything
04:38:10 <dmhouse> int-e: would your version have any other functional differences?
04:38:23 <ezraburgh> i thought you were looking for interactivity, as where the program has to print something before I can type the next thing, then it prints something, etc.
04:38:31 <int-e> Igloo: I've considered it but it's different from the Haskell 98 report. So I'm doubtful it'd be successful.
04:39:00 <int-e> dmhouse: no, it'll just produce the element immediately after each separator sooner.
04:39:09 <Igloo> int-e: haskell-prime, then
04:42:26 <ivanm> ezraburgh: no, its generating particular values
04:47:18 <LeCamarade> Comrades, know of any sane Haskell hosting? I found a link on Phil Wadler's blog, and I like what I see ...
05:04:00 <mattam> hosting a website running with a haskell server ?
05:05:32 <mattam> LeCamarade: have a look at hcoop.net
05:16:08 <Cheery> what would be the best way to represent formatted text in haskell?
05:17:00 <earthy> what about the ways that the various pretty print libraries represent it?
05:18:07 <Cheery> well, you could rely on old style by representing them as certain symbols
05:19:32 <Cheery> but I'm interested about what would be the best data format for them
05:20:41 <earthy> I don't thinkg there is such a thing, really
05:21:03 <earthy> basically, the data format is directly influenced by the ways in which you want to use the data
05:21:34 <earthy> but for inspiration, do look at say UU.Pretty and Text.PPrint
05:21:38 <earthy> oh, and WASH/HTML
05:27:00 <erider> good morning
06:00:13 <ivanm> @pl \ x -> (f . s $ x) >> (f "\n")
06:00:14 <lambdabot> (>> f "\n") . f . s
06:02:54 <ivanm> dmhouse: btw, with the list printing function I had earlier using mapM_... I worked out how to use (>>) to put in the newlines, so its even better than before :p
06:02:59 <ivanm> @seen dmhouse
06:02:59 <lambdabot> dmhouse is in #haskell-blah and #haskell. I last heard dmhouse speak 1h 24m 48s ago.
06:03:06 <dmhouse> ivanm: ah, cool. :)
06:03:21 <ivanm> so yeah, its still a one-liner
06:03:43 <nominolo> @hoogle reset
06:03:43 <lambdabot> Text.Html.reset :: String -> String -> Html
06:03:43 <lambdabot> Text.ParserCombinators.ReadPrec.reset :: ReadPrec a -> ReadPrec a
06:03:43 <lambdabot> Foreign.C.Error.resetErrno :: IO ()
06:03:52 <nominolo> @hoogle shift
06:03:52 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
06:03:53 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
06:03:53 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
06:07:29 <ivanm> dmhouse: you were right about how its efficiency isn't important...
06:07:45 <ivanm> going back through my profiling results, it doesn't even have a % listed to it
06:07:53 <ivanm> so its runtime is negligible anyway
06:26:44 <fourbissime> Hi there. I'm trying to create a very simple datagram socket to get a grip on how haskell handle network. all I want to do is to open a socket which can receive UDP packets and display them. but when I try to bind the socket I got "unsupported operation (Cannot assign requested address)"
06:26:55 <hpaste>  fourbissime pasted "(no title)" at http://hpaste.org/59
06:27:11 <Jaak> > foldr (>>>) id [(*2), (+1)] 5
06:27:15 <lambdabot>  11
06:30:45 <Lemmih> fourbissime: SockAddrUnix is a unix file socket. Use SockAddrInet instead.
06:34:18 <fourbissime> Lemmih: and how do I express an IP address with a Word32 ,
06:34:20 <fourbissime> ?
06:35:14 <Lemmih> fourbissime: inet_ntoa
06:35:18 <Lemmih> @docs Network.Socket
06:35:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
06:35:29 <fourbissime> great ! thanks.
06:35:31 <Lemmih> Err, inet_addr
06:40:39 <fourbissime> damn. It seems I still have troubles to wrap my mind around the idea of manipulating things wrapped into IO ...
06:42:17 <fourbissime> as usual I'm getting IO HostAddress and I want to put it into SockAddrInet
06:44:22 <Botje> @hoogle HostAddress -> IO SockAddrINet
06:44:27 <lambdabot> No matches, try a more general search
06:44:33 <Botje> buh?
06:44:43 <Lemmih> fourbissime: Generate the HostAddress in main.
06:45:50 <fourbissime> that's what I'm trying to do. But I still have troubles to understand how to make "imperative code" in haskell.
06:46:30 <Lemmih> fourbissime: You did fine with 'socket' and 'bindSocket'.
06:47:26 <Lemmih> fourbissime: do host <- inet_addr "localhost"; let local = SockAddrInet (PortNumber 1234" host) ...
06:47:59 <fourbissime> ok
06:49:48 <fourbissime> great ! But I'm not sure to understand the reason why it works with the "let local = ..." and not with "local <- ..."
06:50:38 <kpreid> because SockAddrInet ... is a plain value, not a monadic one
06:54:07 <fourbissime> ok. so now I have a socket bound to a port. i'd like to listen through it and print whatever comes in. I guess I will have to use "recvFrom". the second argument is an Int, but it doesn't say what it is ...
06:55:03 <fourbissime> @doc recvFrom
06:55:04 <lambdabot> recvFrom not available
06:55:15 <fourbissime> @doc Network.Socket.recvFrom
06:55:15 <lambdabot> Network.Socket.recvFrom not available
06:55:33 <fourbissime> (ok I don't know how to talk to the lambdabot :))
06:56:00 <Lemmih> fourbissime: I'm not sure writing a UDP server is the best way of learning Haskell.
06:56:41 <fourbissime> well, yes, you are probably right ... :D
06:57:06 <fourbissime> but in fact I already built a few things next to it which are much more "functional"
06:57:23 <fourbissime> I'm trying to implement Kademlia protocol.
06:57:41 <fourbissime> there is only this core revolving around the socket.
06:58:25 <fourbissime> ok I figured out the Int is the simply the packet size
07:02:50 <fourbissime> IT WORKS !!! :D
07:02:53 <fourbissime> sorry :)
07:26:08 <fourbissime> how do I convert a String to integer ?
07:26:38 <twanvl> > read "123"
07:26:46 <lambdabot>  123
07:26:59 <fourbissime> ... thanks -_-
07:29:11 <sorear> Also look at reads.
07:29:17 <sorear> > read "Not a number!"
07:29:19 <lambdabot>  Exception: Prelude.read: no parse
07:29:28 <sorear> > reads "Not a number!" :: [(Int,String)]
07:29:30 <lambdabot>  []
07:30:03 <sorear> read/reads is overloaded so I need to give the type explicitly
07:30:15 <sorear> > reads "22" :: [(Int,String)]
07:30:17 <lambdabot>  [(22,"")]
07:34:07 <ndm> @seen dons
07:34:07 <lambdabot> dons is in #haskell, #haskell-overflow, #ghc, #haskell-soc and #xmonad. I last heard dons speak 3h 4m 30s ago.
07:34:44 <dons> ndm?
07:34:49 <dons> quick!
07:34:52 <dons> ?time
07:34:54 <lambdabot> Local time for dons is Sun May 27 00:33:30 2007
07:34:58 <ndm> dons: are you still doing the shootout?
07:35:09 <ndm> and how easy would it be to add "Supero" to the benchmark?
07:35:14 <dons> nope. got too depressing, as they disqualified entry after entry.
07:35:16 <ndm> looking at sumfile, i should beat everyone
07:35:18 <dons> hmm, not sure.
07:35:25 <dons> no, it wouldn't be added, i think
07:35:31 <dons> they don't like anything that's not in debian packages
07:35:35 <ndm> shame
07:35:42 <dons> ndm, does it beat my custom bytestring version?
07:35:53 <ndm> dons: looking at it, it should - i don't have the numbers yet
07:36:06 <dons> be worth checking.
07:36:13 <ndm> using a custom-defined readInt, rather than read :: Int
07:36:17 <dons> you know the code i'm talking about?
07:36:25 <ndm> yeah, the quickest entry in the test
07:36:32 <dons> that's the one.
07:36:38 <dons> there's a faster strict bytestring on the wiki
07:36:43 <dons> (uses O(n) space though)
07:36:51 <dons> its a 10 instruction asm loop in the end, iirc
07:37:02 <ndm> i won't get quite to that
07:37:04 <int-e> > read ('"':repeat ' ') :: Int
07:37:10 <lambdabot> Terminated
07:37:11 <ndm> but will do the buffering properly
07:37:22 <dons> yeah, it fuses the IO stuff, right?
07:37:22 <ndm> i can reduce it to something similar, i think
07:37:26 <ndm> yep
07:37:35 <ndm> and will fuse the lines/readInt into one test
07:37:55 <dons> yeah, my fast shootout versoin is basically a manual optimal fusion
07:38:05 <ndm> should fuse it  into a really small state machine, accumulating as you see digits, adding once you see \n
07:38:15 <dons> its what we'd hope a stream fusion bytestring with SpeCConstr would produce, in fact.
07:38:36 <ndm> i hope i can do it from print . sum . map readInt . lines =<< getContents
07:38:40 <ndm> sticking only to lists
07:38:46 <dons> that'd be amazing.
07:38:48 <ndm> although my fusion will remove all traces of lists
07:39:11 <dons> the bytestring stuff, with ghc head, should get pretty close -- but requires bytestrings of course.
07:39:16 <ndm> yeah
07:39:44 <dons> it requires the new constructor specialistion though, to spot and take off the strict head of the lazy bytestring
07:40:00 <ndm> ah, yeah
07:40:12 <ndm> i've had SpecConstr in my optimiser for at least 2 years :)
07:40:32 <ndm> (but SPJ's implementation is a million times neater than mine)
07:40:42 <dons> its pretty subtle I think, in all its details.
07:40:47 <dons> thresholds have to be just right
07:40:56 <ndm> yeah, i had some of those details worked out, but not all
07:41:04 <ndm> i was slightly more conservative
07:41:19 <ndm> only doing it when it was a guaranteed win
07:45:37 <sorear> ndm: You mentioned that catch requires 1.5GB on xmonad, which is 4x more than I have .... is this just correct-first-optimize-later or something more intrinsic?
07:46:04 <ndm> sorear: no, you misread, 1.5Mb
07:46:24 <sorear> *phew*
07:46:27 <ndm> and this is still with correct-first-optimise-later
07:46:40 <dons> sorear: hah
07:46:43 <ndm> my computer has 128Mb of RAM and most of them are busy playing music and running firefox
07:47:02 <ndm> plus I always develop Catch/Supero in Hugs, makes them incredibly fast once you compile them
07:47:50 <dons> ah yes.
07:48:03 <dons> its like training for running by wearing big heavy shoes
07:48:13 <dons> take them off, and you feel light and fast
07:48:20 <ndm> 0.1 second compile times really help for development
07:48:40 <dons> :r StackSet.hs
07:48:42 <ndm> but once GuiHaskell comes along, it should be possible to flip between GHCi and Hugs keeping context
07:48:42 <dons> yes.
07:49:33 <ndm> i do way too much work deep in libraries, which with GHC would set off way too many long build dependencies
07:49:54 <sorear> ndm: you can already do that, using hi
07:50:07 <ndm> a tweak in Play can cause about 25 modules to recompile in Supero
07:50:59 <ndm> sorear: i was hoping to put out a "derive" release this weekend, or very early next week
07:51:05 <sorear> well in hugs a tweak in play will cause ALL of supero to recompile, along with the entire standard library
07:51:24 <sorear> given that there is no bytecode cache, 0.2s startup time is ... dumbfounding
07:52:03 <ndm> yeah, i know it recompiles everything, but what i love is that even with that its really fast
07:54:46 <sorear> it'll be fun running superoized ghc on ghc itself.  deforest the Simplifier into a single tree walk!
07:56:19 <nominolo> hm, how expensive are zippers based on delimited continuations compared to direct implemenations?
07:56:44 <nominolo> has anyone tested something like this?
07:56:47 <bos> CosmicRay: ping
08:02:51 <dons> nominolo: hmm. oleg might have looked at it. but there's been very little research on performance stuff, afaik.
08:02:57 <dons> nominolo: there's a paper there, surely :-)
08:03:55 <nominolo> dons: yes, i'am just reading zippers = delimited conts as data.  my reason for doing so is, that i want to know how hard concurrent zippers on the same data structure are
08:04:35 <ndm_> nominolo: wouldn't that be easy, since the zippers shouldn't conflict in any way?
08:04:37 <ndm_> being pure and all
08:04:58 <dons> nominolo: so Oleg's workshop talk on the zipper FS was about concurrent access
08:05:07 <nominolo> ndm_: what if one of them updates in a subpart of the other?
08:05:16 <dons> multiple users, with various writing semantics
08:05:26 <nominolo> dons: oh, interesting.
08:05:32 <dons> and then how that related to various transactoin semantics in database systems
08:06:19 <dons> his notes 'Zipper1.lhs' and 'Zipper2.lhs' on his web site explain this a bit, iirc
08:06:35 <sorear> ndm_: 07:53 < sorear> it'll be fun running superoized ghc on ghc itself.  deforest the Simplifier into a single tree walk!
08:06:58 <dons> sorear: yeah, sure ;)
08:07:35 <ndm_> sorear: it should be good, a bit too big for the moment :) - I think SpecConstr should do well on GHC's simplifier
08:08:06 <nominolo> dons: yes, i'm currently reading part one.  maybe i'll should finish first ..
08:08:07 <ndm_> since Supero evolved from something quite similar to SpecConstr, and has similar behaviour in some places
08:21:00 <hpaste>  Dominic Steinit pasted "Typeclass & GADT" at http://hpaste.org/60
08:22:27 <cinimod> Given Range only works on things in Ord why do I get a type error if I use min / max?
08:23:02 <fourbissime> hi again. I must miss something in the conversions between intergers and word16. here is the thing:
08:23:06 <hpaste>  fourbissime pasted "(no title)" at http://hpaste.org/61
08:24:23 <Lemmih> fourbissime: fromIntegral
08:25:21 <roconnor> @type fromIntegral
08:25:22 <fourbissime> right. thanks.
08:25:30 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:25:46 <bos> fourbissime: you're not wrapping the second one in a PortNum either
08:25:57 <ndm> roconnor: Dimitry fixed up Yhc Javascript yesterday
08:26:01 <bos> er, i mean you are, but you're not doing that with the first
08:26:06 <roconnor> ndm: cool!
08:27:30 <fourbissime> bos: it seems that passing an Integer do the trick ... there must be some automatic conversion done at a moment, I suppose ?
08:32:00 <sorear> hi jyp
08:32:12 <jyp> hey sorear!
08:32:45 <Ogedei> on ghc 6.6, when I do _writeFile "test" "\x2015"_, I get a file with one byte, 15, in it. why not the UTF-8 encoding of 0x2015? is there a way to set the encoding of output?
08:33:06 <sorear> Ogedei: No.
08:33:16 <sorear> Ogedei: GHC always truncates on output
08:33:34 <Ogedei> sorear: oh, that's bad. can i trick it into outputting utf-8 somehow?
08:33:42 <sorear> Ogedei: the best you can do is encoding it manually
08:34:37 <sorear> writeFile "test" "\xD2\x80\x95"
08:35:17 <Ogedei> sorear: ugh, it even seems to truncate stuff above 128
08:35:33 <Igloo> It doesn't
08:36:15 <Ogedei> Igloo: hah, you are right, I was being dumb (entering hex instead of decimal)
08:37:06 <Ogedei> woops, closed wrong buffer
08:37:26 <Ogedei> is there maybe a library that does this manual encoding? wouldn't be hard to do
08:37:33 <sorear> sure
08:37:58 <sorear> nobody's packaged it though, so you'll have to copy a file into your project :(
08:38:06 <sorear> @google UTF8.lhs darcs
08:38:08 <lambdabot> http://lists.osuosl.org/pipermail/darcs-users/2004-October/003452.html
08:38:08 <lambdabot> Title: [darcs-users] ghci hints?
08:38:15 <sorear> @google UTF8.lhs url:darcs
08:38:16 <lambdabot> No Result Found.
08:38:38 <sorear> http://members.cox.net/stefanor/vty/UTF8.lhs
08:38:47 <sorear> ^^ a copy I happen to know exists
08:38:48 <Ogedei> sorear: thanks!
08:43:23 <Ogedei> okay, another stupid question -- how do I get from a GHC.Word.Word8 to a Char or Int?
08:44:02 <sorear> fromIntegral
08:44:12 <Saizan> and chr
08:44:16 <sorear> Word8 is an integral type
08:45:45 <Ogedei> great, now I have decent UTF8 output
08:47:10 <sorear> now if only it was easier :(
08:49:14 <sorear> JohnMeacham: ping?
08:56:31 <Jessehk> Is there an evironmental variable I can set for ghc similar to PYTHONPATH and RUBYLIB?
08:56:54 <sorear> like the -i option?
08:57:17 <Jessehk> sorear: ya
08:57:57 <Jessehk> but is there a a way to specify a directory that is always searched, without using the -i option?
09:10:39 <fourbissime> I have a "identifier" type which is supposed to be a 160 bits unsigned integer. the main operation I have to do on it is bitwise XOR. at the present time I'm simply using Integer type, but I have to send this data in UDP packets. So I'm wondering how I could make conversions Integer -> 160 bits field and reverse. Or if there would be another way to define my identifier so it would always be a 160 bits field.
09:12:16 <sorear> perhaps [Word8] and zipWith xor ?
09:13:30 <roconnor> fourbissime: http://darcs.haskell.org/crypto/Data/LargeWord.hs
09:13:39 <roconnor> in particular Word160
09:13:46 <fourbissime> oooohhhhh
09:18:06 <pchiusano> hello!
09:21:43 <fasta_> What's the best way to divide X by 2 and if the resulting value is of the form X.5 returns X+1 and otherwise X? A combination of `div` (/) and (-)? Or is there something where I don't need to specify that logic anymore?
09:22:35 <cdsmith> Enlighten me here.  Why does newtype exist?  Is there any reason you can't just global search-and-replace newtype to data, and still have an equally correct program?
09:22:40 <ibid> fasta_: so, 3.5 goes to 4 but 3.6 should be truncated to 3?
09:22:41 <cdsmith> fasta_: (x + 1) `div` 2?
09:22:45 <int-e> (X+1)`div`2  or -(-X `div` 2)
09:22:47 <Saizan> > roudn(3/2)
09:22:54 <Saizan> > round (3/2)
09:22:57 <lambdabot>   Not in scope: `roudn'
09:22:58 <lambdabot>  2
09:23:18 <fasta_> ibid: My spec was incorrect.
09:23:41 <opqdonut> X is an integer, i take it
09:23:41 <roconnor> @check \x -> (x+1) `div` 2 == ceiling (fromIntegral (x::Integer)/2)
09:23:43 <lambdabot>  OK, passed 500 tests.
09:23:46 <sorear> pchiusano: Hi!
09:24:02 <roconnor> @check \x -> -(-x `div` 2) == ceiling (fromIntegral (x::Integer)/2)
09:24:03 <lambdabot>  Falsifiable, after 1 tests: 3
09:24:05 <sorear> ghc 6.6.1 is using 300mb ...
09:24:19 <int-e> argh
09:24:22 <roconnor> :)
09:24:25 <int-e>  @check \x -> -(-x `div` 2) == ceiling (fromIntegral
09:24:27 <opqdonut> fasta_: so you want to round up to the closest even dumber
09:24:28 <fasta_> ibid: 3.6 should also be 4.
09:24:36 <opqdonut> *number
09:24:39 <int-e> @check \x -> -((-x) `div` 2) == ceiling (fromIntegral (x::Integer)/2)
09:24:41 <lambdabot>  OK, passed 500 tests.
09:24:43 <opqdonut> hehe "even dumber" :>
09:24:49 <int-e> I should really use negate there.
09:25:49 <opqdonut> > let f x = if odd x then x+1 else x in (f 1, f 2, f 3, f 4) -- fasta_ is this what you want?
09:25:50 <lambdabot>  (2,2,4,4)
09:26:07 <fasta_> opqdonut: no, you missed the division
09:26:18 <int-e> (especially given my opinion about unary minus. hehe.)
09:26:29 <opqdonut> fasta_: so X needn't be an integer?
09:26:37 <cdsmith> int-e: what's your opinion?
09:26:47 <fasta_> opqdonut: X is Integer or Int
09:27:04 <int-e> cdsmith: it should be part of the lexical syntax, and not exist in the grammar
09:27:10 <opqdonut> fasta_: or did you mean, Y=X/2, return Y+1 or Y?
09:27:19 <opqdonut> or did you mean what you actually said?-)
09:27:34 <cdsmith> int-e: Ah, okay.  So it could only be applied to literals?
09:27:37 <fasta_> opqdonut: if you rebind X, what I said, was correct.
09:27:51 <opqdonut> fasta_: breaks referential transparency :)
09:27:56 <int-e> cdsmith: yes. which covers 80% or more of all uses, I think.
09:28:07 <fasta_> opqdonut: yes, I should have used Y, but I was not wrong.
09:28:20 <opqdonut> > let f x = if odd x then (x+1)/2 else x/2 in (f 1, f 2, f 3, f 4) -- fasta_ is this what you want?
09:28:21 <lambdabot>  Add a type signature
09:28:24 <opqdonut> gah
09:28:29 <cdsmith> int-e: I don't disagree.  Something is confusing about unary - anyway; I haven't thought much about it.
09:28:30 <int-e> cdsmith: (but of course I pulled that number out of my hat. I don't know if there are any statistics about this.)
09:28:33 <opqdonut> > let f x = if odd x then div (x+1) 2 else div x 2 in (f 1, f 2, f 3, f 4) -- fasta_ is this what you want?
09:28:34 <lambdabot>  (1,1,2,2)
09:28:51 <roconnor> @check \x -> if odd x then div (x+1) 2 else div x 2 == ceiling (fromIntegral (x::Integer)/2)
09:28:52 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Bool'
09:29:12 <fasta_> opqdonut: yes, that's the best way to do it.
09:29:17 <roconnor> @check \x -> (if odd x then div (x+1) 2 else div x 2) == ceiling (fromIntegral (x::Integer)/2)
09:29:19 <lambdabot>  OK, passed 500 tests.
09:29:27 <opqdonut> fasta_: yep, the even and odd predicates are quite efficient, too
09:29:27 <hpaste>  Weremanatee annotated "How to proceed?" with "rephrased cotangent in terms of sin and cos" at http://hpaste.org/55#a6
09:29:38 <roconnor> @check \x -> (x+1) `div` 2 == (if odd x then div (x+1) 2 else div x 2)
09:29:39 <lambdabot>  Add a type signature
09:29:40 <fasta_> roconnor: or your solution
09:29:46 <roconnor> @check \x -> ((x::Integer)+1) `div` 2 == (if odd x then div (x+1) 2 else div x 2)
09:29:47 <lambdabot>  OK, passed 500 tests.
09:29:56 <opqdonut> oh yeah, div truncates for me :)
09:29:59 <roconnor> quickcheck is transitive :)
09:30:57 <cdsmith> opqdonut: yep; toward -inf ; I don't know if fasta_ cares about negative numbers.
09:31:00 <int-e> @check \x -> ((x::Integer) `div` 2 == (x+1) `div` 2) == even x
09:31:01 <lambdabot>  OK, passed 500 tests.
09:31:09 <opqdonut> cdsmith: :)
09:31:44 <roconnor> @check \x y z -> ((x == y) == z) == (x == (y == z))
09:31:45 <lambdabot>  OK, passed 500 tests.
09:31:48 <roconnor> @scheck \x y z -> ((x == y) == z) == (x == (y == z))
09:31:49 <lambdabot>   Completed 8 test(s) without failure.
09:32:03 <opqdonut> what is scheck?
09:32:07 <opqdonut> speedy check?
09:32:08 <roconnor> == is associative
09:32:17 <int-e> 'small' check - check small cases exhaustively
09:32:34 <opqdonut> ok
09:32:47 <cdsmith> Any comments on the newtype question?  Does s/newtype/data/g ever break a program?
09:33:00 <fasta_> cdsmith: no, I don't care about negative numbers
09:33:01 <roconnor> cdsmith: it can affect strictness
09:33:15 <cdsmith> roconnor: how so?
09:33:22 <roconnor> and presumably affect fixed points
09:33:37 <roconnor> cdsmith: data Foo = Foo Int
09:33:41 <opqdonut> cdsmith: it will break if you have for example functions snewtype and sdata :------D
09:33:55 <Bourbaki> moin
09:33:56 <roconnor> in this case (Foo undefined) is a value
09:33:57 <cdsmith> opqdonut: yeah. :)
09:34:09 <roconnor> but for a new type
09:34:18 <opqdonut> Foo undefined = undefined right?
09:34:19 <roconnor> Foo undefined == undefined
09:34:22 <opqdonut> yeah  :)
09:34:28 <TomMD> > undefined == undefined
09:34:29 <lambdabot>  Undefined
09:34:32 <opqdonut> :)
09:34:33 <cdsmith> roconnor: so (newtype Foo = Foo a) == (data Foo = Foo !a) ?
09:34:51 <roconnor> cdsmith: good question
09:34:51 <Bourbaki> is there any good computational algebra lib for haskell?
09:34:52 <opqdonut> not exactly, i think
09:35:08 <Bourbaki> and or differential topology and geometrical algebra
09:35:09 <int-e> cdsmith: no.
09:35:22 <roconnor> cdsmith: If there is a difference, I don't know it
09:35:33 <opqdonut> well consider Foo undefined
09:35:39 <int-e> cdsmith: with newtype Foo, you can do this:  a (Foo _) = 42; and  a undefined  will evaluate to 42.
09:35:42 <opqdonut> with data and !a it'd just break
09:35:43 <ndm> there is a difference in the FFI spec
09:35:48 <opqdonut> with newtype it'd work
09:35:51 <int-e> cdsmith: with the data it'll fail.
09:36:02 <opqdonut> yeh
09:36:51 <cdsmith> int-e: OH!  I think I get that now.  Because data assumes that it has to match the constructor, even though there's only one in this case.
09:37:37 <int-e> cdsmith: yep
09:37:50 <cdsmith> int-e: Okay, that makes a lot of sense, actually.  int-e++
09:37:59 <int-e> cdsmith: that's the other aspect of newtype - it makes pattern matching on the constructor a no-op.
09:38:56 <int-e> I wonder how jhc deals with that, hmm.
09:39:13 <cdsmith> @google jhc
09:39:15 <lambdabot> http://www.jhc.com/
09:39:29 <sorear> int-e: what about jhc?
09:39:30 <cdsmith> John Henry Online? :)
09:39:30 <int-e> @where jhc
09:39:31 <lambdabot> http://repetae.net/john/computer/jhc/
09:39:48 <fasta_> int-e: but can't it be optimized away in the case for data where there's only one case?
09:40:17 <cdsmith> fasta_: only if you want to change the behavior of some code.
09:40:21 <fasta_> Hmm, never mind, I suppose the extra lazyness helps in some cases.
09:40:33 <int-e> no, a haskell compiler. but it has an atypical type class implementation which makes it necessary to have actual constructor tags for newtypes in some cases (to deal with some arbitrary size types with associated type classes)
09:40:34 <Saizan> which is faster between Parsec and ReadP?
09:40:54 <int-e> fasta_: you still need to distinguish undefined  from <constructor> undefined
09:40:58 <sorear> Saizan: benchmark!
09:41:14 <fasta_> int-e: yes, that's what I meant by "extra lazyness"
09:41:22 <fasta_> Saizan: In my experience Parsec is "fast enough".
09:41:34 <fasta_> Saizan: I know that's not what you asked.
09:41:37 <sorear> int-e: Huh?  it has tags, but only in the type of types - not the values (I do not know this for sure)
09:41:42 <int-e> fasta_: so I don't see how you could optimize it away, without doing strictness analysis.
09:42:02 <fasta_> int-e: I understand
09:42:07 <int-e> sorear: ah, that could be.
09:43:27 * int-e should play with jhc again, hmm.
09:43:59 <sorear> @seen JohnMeacham
09:43:59 <lambdabot> JohnMeacham is in #darcs, #haskell and #haskell-blah. I last heard JohnMeacham speak 1d 21h 35m 17s ago.
09:44:33 <int-e> right, or ask. but he rarely says anything.
10:15:19 <int-e> hmm. when darcs says 'Unapplicable patch' when pulling a repository - is there any cure? (trying to get DrIFT)
10:15:47 <nominolo> did you get conflicts?
10:16:45 <fasta_> Meh, looking at 2 pages of types is not fun :(
10:16:58 <hpaste>  int-e pasted "darcs error" at http://hpaste.org/62
10:17:43 <int-e> (--partial didn't make any difference.)
10:18:22 <dcnstrct> Hi.  I'm looking for a timeout mechanism to control potentially long running threads in my application.  I found the "developing a high-preformance webserver in concurrent haskell" paper where a timeout function is provided which makes use of asynchronous exceptions, and I'd like to use it, but I'm having a difficult time getting it to compile.  Could someone lend me a hand real quick or suggest a different way to achieve timeouts in
10:18:23 <sorear> int-e: the drift repo is corrupt, and has been for months
10:18:23 <dcnstrct> http://hpaste.org/48
10:18:25 <fasta_> int-e: paste the url and I will try here too
10:18:31 <fasta_> int-e: ok, never mind
10:19:00 <sorear> int-e: i pinged john long ago, he won't/can't fix it
10:19:09 <fasta_> IMO, they should stop distributing it until they have it fixed.
10:19:14 <int-e> sorear: I see, ok. I'll use the release then.
10:21:18 <Saizan> dcnstrct: do you use -fglasgow-exts ?
10:21:59 <ndm> @src Monad []
10:21:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:22:34 <sorear> @src [] >>=
10:22:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:22:38 <sorear> @src [] (>>=)
10:22:38 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:22:42 <sorear> @src [] return
10:22:42 <lambdabot> return x    = [x]
10:22:46 <dcnstrct> Saizan, I have not tried using that, I'll try it
10:23:36 <opqdonut> @src [] mplus
10:23:36 <lambdabot> mplus = (++)
10:23:43 <opqdonut> @src Maybe mplus
10:23:43 <lambdabot> Nothing `mplus` ys  = ys
10:23:43 <lambdabot> xs      `mplus` _ys = xs
10:23:57 <opqdonut> @src IO mplus
10:23:57 <lambdabot> m `mplus` n = m `catch` \_ -> n
10:24:08 <opqdonut> ?src catch
10:24:08 <lambdabot> catch m k = catchException m handler where handler (IOException err) = k err
10:24:22 <dcnstrct> Saizan, it compiles now with that option.  Thank you sir.
10:24:23 <opqdonut> ahhh
10:24:58 <Saizan> dcnstrct: the (# a,b #) are unboxed tuples, a GHC extension, that's why you need that flag
10:25:13 <Botje> foldr ((++) . k) [] m -- seems like a horrible way to write concatMap k M to me
10:25:24 <dcnstrct> Saizan, I see.. I'll go read about them, thanks.
10:25:25 <Saizan> ?src ConcatMap
10:25:26 <lambdabot> Source not found. My mind is going. I can feel it.
10:25:29 <Saizan> ?src concatMap
10:25:29 <lambdabot> concatMap f = foldr ((++) . f) []
10:25:50 <Botje> oh. heh.
10:34:01 <Saizan> is there a better way than (many (satisfy (const True))) to get the remaining input in ReadP?
10:34:32 <gh_> hello
10:34:51 <gh_> is it possible to pass the IO monad to a function inside a runST ?
10:35:58 <fasta_> gh_: if you mean a value of type IO <something>, yes.
10:36:38 <fasta_> gh_: "The IO monad" itself cannot be passed to any function, since it has no meaning.
10:36:57 <gh_> sorry, i mean, i have a function that returns a IO <...> object, and i'd like to run it inside a runST
10:37:16 <fasta_> gh_: what makes you think that would work?
10:37:31 <fasta_> gh_: IO computations can only be executed in the IO monad.
10:38:07 <gh_> i don't know, i need to be inside a runST , and at the same time , my function returns a IO <..> object because it is executed by a runStateT
10:38:17 <gh_> i'm tidying a minimal example of this to paste
10:38:59 <fasta_> gh_: you want to use monad transformers
10:40:21 <ndm> @seen waern
10:40:21 <lambdabot> waern is in #haskell. I don't know when waern last spoke.
10:40:26 <waern> hey
10:40:40 <ndm> are you anything to do with the quickcheck 2 patch for derive that i got?
10:40:54 <waern> yes, sorry for not giving a proper address
10:41:01 <ndm> its darcs send stuff :)
10:41:14 <ndm> why is this needed? does quickcheck 2 not support coarbitrary?
10:41:22 <waern> the class is splitted
10:41:26 <sorear> stefan@stefans:/usr/src/putty-0.60$ grep EMAIL ~/.bashrc
10:41:26 <sorear> export EMAIL='stefanor@cox.net'
10:41:29 <sorear> not hard :)
10:41:43 <ndm> fair enough, i'll get that applied
10:41:52 <ndm> but the new class is still Arbitrary?
10:41:59 <waern> yep
10:42:02 <int-e> echo 'Name <email>' > ~/.darcs/author
10:42:03 <ndm> can can we have a derivation for the new CoArbitrary class?
10:42:19 <waern> probably. haven't looked at it
10:42:27 <ndm> fair enough, i'll apply that later
10:42:56 <ndm> did you actually run the guessing program, or just copy the results from the QuickCheck 1 thing?
10:43:06 <waern> I ran the guessing program
10:43:10 <ndm> yay!
10:43:25 <ndm> that guessing program was a lot of work, and its nice to see someone using it other than me :)
10:43:48 <waern> I think the output of the guess consited of both arbitrary and coarbitrary so I had to do that
10:43:59 <ndm> yeah, it would do
10:44:05 <waern> that's how it works right? the guess is done for all methods in the class
10:44:09 <ndm> but you could just about feasibly tweak it to work
10:44:12 <ndm> yep, it guesses everything
10:44:24 <ndm> since you could have the methods iductively defined by the data
10:44:34 <ndm> (not that Haskell would like that, but hey)
10:45:26 <gh_> fasta_, ok, i'll check monad transformers
10:45:46 <gh_> fasta_, thank you
10:56:35 <Saizan> ?ty runState
10:56:37 <lambdabot> forall s a. State s a -> s -> (a, s)
10:56:38 <Saizan> ?ty runStateT
10:56:40 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
10:57:00 <hpaste>  lpenz pasted "idlelog with bytestrings, not working" at http://hpaste.org/63
10:58:02 <Saizan> gh_: do (a,s') <- runStateT actStateIO s; return $ runST (actST a) <-- you can use something like this, i think
10:59:53 <mux> I can't seem to find documentation on how to create binary bundles for GHC
11:00:07 <mux> wit hthe binary-dist target
11:00:15 <mux> I only found some very old documentation on the subject
11:00:38 <mux> the more recent documentation only says that using binary bundles is recommended etc, but no work on how to create those
11:01:55 <mux> the other documents talking about sources are about how to port GHC on an unsupported architecture
11:06:46 <takamura> hi
11:07:43 <araujo> hello
11:21:24 <Weremanatee> @djinn [(a->b)] -> (a->[b])
11:21:25 <lambdabot> -- f cannot be realized.
11:21:29 <Weremanatee> ah well
11:23:21 <Weremanatee> @djinn Monad m => [m a] -> m [a]
11:23:22 <lambdabot> Cannot parse command
11:23:37 <int-e> oh right. sequence.
11:23:42 <takamura> that isnt sequence?
11:23:49 <Weremanatee> oh yea
11:23:51 <int-e> > sequence [(+1), (*2)] 3
11:23:51 <lambdabot> Terminated
11:24:06 <int-e> > Control.Monad.sequence [(+1), (*2)] 3
11:24:07 <lambdabot>  [4,6]
11:24:17 <int-e> (what's up with sequence and lambdabot anyway?)
11:25:55 <jyp> @djinn b -> [b]
11:25:55 <lambdabot> -- f cannot be realized.
11:29:27 <opqdonut> :t sequence
11:29:29 <lambdabot>     Ambiguous occurrence `sequence'
11:29:29 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
11:29:39 <opqdonut> :t Control.Monad.sequence
11:29:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:38:10 <int-e> > sequence
11:38:15 <lambdabot> Terminated
11:38:35 <Weremanatee> So, what do you think of this: http://hpaste.org/55#a6 ... what's a good strategy for proving these equivalent?
11:45:59 <byorgey> Weremanatee: hmm, induction on n is what comes to mind...
11:46:46 <byorgey> Weremanatee: I don't even think they are equivalent for non-positive values of n
11:47:21 <byorgey> > sum []
11:47:26 <lambdabot>  0
11:47:32 <opqdonut> ?src sum
11:47:33 <lambdabot> sum = foldl (+) 0
11:47:34 <opqdonut> :)
11:48:05 <byorgey> opqdonut: that's what I figured, just checking =)
11:48:10 <opqdonut> yeh
11:48:23 <opqdonut> foldl1 (+) would be kinda dumb
11:48:36 <opqdonut> > foldl1 (+) [0]
11:48:38 <lambdabot>  0
11:48:39 <opqdonut> > foldl1 (+) []
11:48:40 <lambdabot>  Exception: Prelude.foldl1: empty list
11:48:46 <byorgey> oh noes! an empty list!
11:48:54 <opqdonut> yup
11:48:57 <byorgey> > product [] == 1
11:48:58 <lambdabot>  True
11:49:16 <opqdonut> that's pretty standard mathematic semantics for those
11:49:29 <byorgey> opqdonut: yup
11:55:00 <int-e> Weremanatee: well, you can argue geometrically, or you can use Euler's formula to turn the messy sum in 'area' into a sum of geometric series. (or use another way of deriving sum formulas for sums of the form sum sin(a*i+b))
12:03:17 <nominolo> man, that delimted continuations paper is a tough cracker.  that just screams for a vivid metaphora reified in the form as a topofthenotch action comic
12:08:08 <fasta_> nominolo: I found the alligators to be more boring than the real thing.
12:09:04 <nominolo> ok, agreed, that seemed to make things more complicated than they are
12:09:46 <nominolo> i was think more of something like http://www.lisperati.com/casting.html
12:11:01 <nominolo> if i can come up with a good theme, i conjecture that this would ly within my capabilities
12:11:22 <opqdonut> lie?
12:11:22 <nominolo> *lie
12:11:46 <nominolo> ;)
12:12:09 <opqdonut> i think SICP is much a better intro to lisp/scheme than that one :)
12:12:31 <nominolo> but it's cool!
12:13:09 * nominolo learned lisp with "On Lisp"
12:16:50 <opqdonut> actually i guess SICP is the best thing since K&R
12:16:57 <opqdonut> ?quote SICP
12:16:57 <lambdabot> No quotes match. My mind is going. I can feel it.
12:17:01 <opqdonut> :/
12:17:29 <lispy> that's a great error message for that command
12:17:50 <opqdonut> yep
12:21:22 <lispy> ?pl drop 1 $ sort $ nub $ concatMap inits $ perms x
12:21:22 <lambdabot> drop 1 (sort (nub (inits =<< perms x)))
12:21:28 <lispy> whoa
12:21:40 <lispy> that's not at all what i would expect
12:22:03 <mauke> why not?
12:22:20 <lispy> i'm really surprised it came up with (=<<) in there
12:22:26 <lispy> :t (=<<)
12:22:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:22:58 <nominolo> @src [] (>>=)
12:22:58 <lispy> ?pl \x -> drop 1 $ sort $ nub $ concatMap inits $ perms x
12:22:58 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:22:58 <lambdabot> drop 1 . sort . nub . (inits =<<) . perms
12:23:10 <mauke> =<< is concatMap for Monad []
12:23:16 <lispy> oh right
12:23:31 <lispy> i've been away from serious haskell coding for too long :)
12:24:29 <mauke> because join = concat and liftM = map and >>= = liftM + join
12:24:49 <dangb> ?pl
12:24:49 <lambdabot> (line 1, column 1):
12:24:49 <lambdabot> unexpected end of input
12:24:49 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:25:52 <opqdonut> ?src [] (>>=)
12:25:52 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:26:27 <mauke> @src concatMap
12:26:28 <lambdabot> concatMap f = foldr ((++) . f) []
12:35:41 <lygaret> Hey, could anyone answer this question for me? I'm having some trouble constraining a datatype... what I want is a list of a typeclass, so like
12:35:55 <lygaret> data Container = (Eq a) => Container [a]
12:35:57 <lygaret> but
12:36:07 <lygaret> that's not right and I can't really figure out what I need to do.
12:37:33 <dmwit> data (Eq a) => Container a = Container [a]
12:38:03 <nominolo> lygaret: i think it's better not to constrain the datatype directly
12:38:17 <nominolo> lygaret: just add it to the functions that actually need it
12:38:24 <lygaret> Hmm
12:38:41 <lygaret> dmwit, that would make the kind * -> * though, wouldn't it?
12:38:43 <Weremanatee> byorgey: You are right, they are only equivalent for positive ns.
12:38:58 <lygaret> and nominolo, but then you could have Containers that help invalid things, no?
12:39:28 <dmwit> lygaret: You bet it would.
12:39:45 <lygaret> Ok, thanks - I'm getting this, but slowly.
12:39:48 <nominolo> lygaret: well, make Container an abstract type, i.e. don't export the constructor
12:40:55 <lygaret> Hmm - ok, thanks y'all
12:41:28 <lygaret> dmwit: is there a way to say that I really don't care what type a is, only that it's constrained on the class?
12:41:58 <dmwit> lygaret: That's exactly what that declaration says.
12:42:06 <dmwit> lygaret: What are you really trying to do?
12:42:14 <lygaret> ooooh wait I think I got that
12:42:30 <lygaret> Ok, I got it
12:42:34 <lygaret> whoa, headrush
12:42:39 <dmwit> =)
12:43:06 <lygaret> ok, thanks a lot dmwit, nominolo
12:49:08 <fuzan> lygaret: those are existential types.
12:49:44 <Dr_Foo> is there a way to export all a datatype's constructors without having to specify them all in the export list
12:49:56 <Dr_Foo> (hello all btw)
12:50:02 <Korollary> Dr_Foo: If you dont specify anything, everything's exported.
12:50:56 <sorear> Korollary: Not true
12:51:17 <sorear> module Foo(MyType) where  -- exports none of MyType's constructors
12:51:25 <sorear> module Foo(MyType(..)) where  -- exports nall of MyType's constructors
12:51:37 <fuzan> lygaret: data Container a = forall a. Ord a => Container [a]
12:51:54 <dmwit> fuzan: I don't think he's quite at that level of type hackery yet.
12:52:00 <lygaret> lol
12:52:13 <lygaret> so the point of this
12:52:25 <lygaret> I've got a typeclass Component
12:52:33 <lygaret> class Component a where render :: a -> String
12:52:33 <Korollary> sorear: Heh. I meant 'nothing at all within parens'
12:52:54 <lygaret> and Container is a recursive container of other components
12:53:16 <lygaret> data (Component a) => Container a = Container [a]
12:53:33 <Dr_Foo> sorear: exactly what i wanted thanks
12:54:25 <byorgey> lygaret: what do you mean that Container is 'recursive'?
12:54:29 <dmwit> lygaret: Check out the Show class.  It can be automatically derived by ghc, which could save you a bit of work, depending on how picky you are about output.
12:54:58 <fuzan> lygaret: you can do this with existentials, but you must remember, you can't go from type a to the exact type that's implementing Component
12:55:01 <lygaret> byorgey, the point being that I can nest Containers
12:55:01 <fuzan> :t show
12:55:03 <lambdabot> forall a. (Show a) => a -> String
12:55:14 <dmwit> ?src Show
12:55:14 <lambdabot> class  Show a  where
12:55:14 <lambdabot>     showsPrec :: Int -> a -> ShowS
12:55:14 <lambdabot>     show      :: a   -> String
12:55:14 <lambdabot>     showList  :: [a] -> ShowS
12:55:38 <dmwit> (But just implementing "show" gets you the rest for free.)
12:55:41 <lygaret> since a Container holds instances of Component, and Container is an instance
12:55:43 <fuzan> lygaret: (unless you know the type exactly)
12:55:45 <byorgey> lygaret: OK, so you have some sort of 'instance Component Container' declaration?
12:55:49 <lygaret> yeah
12:55:51 <lygaret> though
12:55:57 <lygaret> that's my next syntax hurdle
12:56:28 <lygaret> ok
12:56:30 <nominolo> not rather:  instance Component a => Component (Container [a]) wher
12:56:41 <nominolo> this way you don't need the constraint on the container
12:57:04 <lygaret> Because then I can containers which aren't components
12:57:08 <lygaret> but
12:57:12 <lygaret> to be a component
12:57:19 <lygaret> it has to contain nothing but components?
12:57:27 <nominolo> yes
12:57:52 <nominolo> if you write it like above
12:58:03 <lygaret> and data Container a = Container [a]
12:58:09 <lygaret> ?
12:58:22 <nominolo> exactly
12:58:27 <lygaret> hmmm
12:59:29 <lygaret> If I do it that way nominolo
12:59:37 <lygaret> Would it be worth it to just say
12:59:42 <byorgey> nominolo: don't you mean: instance Component a => Component (Container a)?
12:59:50 <byorgey> or am I missing something?
12:59:50 <lygaret> instance Component a => Component ([a])
12:59:51 <lygaret> ?
12:59:57 <lygaret> And then just say
13:00:04 <lygaret> lists of components are components?
13:00:11 <nominolo> oh, yes, sure
13:00:12 <dmwit> lygaret: Yes, that's a very reasonable idea.
13:00:24 <lygaret> hmm, hot
13:00:25 <lygaret> ok
13:00:50 <lygaret> thanks!
13:01:38 <lygaret> oh wait
13:01:42 <lygaret> So...
13:01:54 <lygaret> That won't work unless the list is homogenous
13:02:00 <lygaret> Will it?
13:02:07 <dmwit> That's correct.
13:02:16 <dmwit> Homogeneous lists are the rule in Haskell.
13:02:18 <sorear> @where hlist
13:02:19 <lambdabot> http://homepages.cwi.nl/~ralf/HList
13:02:21 <lygaret> So, if I have different types that are all instances of Component, the list won't accept them.
13:02:23 <dmwit> There is a heterogenous list, but...
13:02:41 <dmwit> Now we get to fuzan's territory: existential types.
13:02:48 <lygaret> Yeah...
13:02:49 <lygaret> ok
13:02:51 <fuzan> which i was sure he wanted ;)
13:02:54 <dmwit> Another possibility:
13:03:07 <lygaret> fuzan, you're psychic
13:03:09 <lygaret> :)
13:03:23 <dmwit> data ListableComponents = Foo ComponentA | Bar ComponentB | Quux ComponentC
13:03:31 <lygaret> yeah
13:03:36 <lygaret> Except,
13:03:42 <dmwit> That will put off having to learn existentital types for a little while. =)
13:03:45 <lygaret> I'd like to be able to arbitrarily add Components
13:03:46 <lygaret> lol
13:03:57 <dmwit> yeah
13:04:08 <dmwit> I'm always fascinated by the demand for heterogeneous lists.
13:04:13 <dmwit> I've never needed them yet.
13:04:16 <fuzan> lygaret: i suggest you play a little with existential types :)
13:04:21 <dmwit> Maybe I'm not doing anything worthwhile. =P
13:04:39 <fuzan> they're key in building modular and reusable code.
13:04:46 <lygaret> no dmwit
13:04:47 <fuzan> more industrial-level applications
13:04:55 <lygaret> you're helping me!
13:04:58 <lygaret> :)
13:05:17 <fuzan> dmwit: was your coding background imperative or functional?
13:05:21 <lygaret> so fuzan, taking your datatype declaration from earlier
13:05:33 <dmwit> fuzan: I started with C, so imperative.
13:05:35 <lygaret> data Container a = forall a. Component a => Container [a]
13:05:50 <lygaret> What would an instance declaration of Container to Component be?
13:05:59 <fuzan> dmwit: i think the ones of us with huge polymorphic backgrounds are more akin to existentials
13:06:01 <lygaret> instance Component a => Component (Container [a])
13:06:02 <lygaret> ?
13:06:17 <lygaret> fuzan: I'd probably agree - I'm a smalltalker
13:07:16 <fuzan> i'd just do: instance Component a => Container [a], still.
13:07:29 <fuzan> that doesn't change, cept you'd probably want Typeable as well
13:08:15 <byorgey> fuzan: you mean instance Component a => Component [a]?
13:08:59 <fuzan> yah, that looks better :)
13:09:06 <lygaret> But
13:09:19 <lygaret> That won't pick up the type declaration?
13:09:35 <lygaret> For the forall. a Component a => [a]?
13:10:21 <Saizan> is there a function like dropThis :: String -> String -> Maybe String; dropThis x y = if x `isPrefixOf` y then Just $  drop (lenght x) y else Nothing ?
13:11:29 <fuzan> lygaret: i would change a few things. if you have your class Component
13:12:10 <fuzan> lygaret: i would make my datatype look like this: data Container = forall a. Component a => a deriving (Typeable)
13:12:17 <mauke> @hoogle (Eq a) => [a] -> [a] -> Maybe [a]
13:12:21 <lambdabot> No matches, try a more general search
13:12:42 <lygaret> What is Typeable?
13:12:45 <fuzan> and now, we can make our list dataypes just be of [Container]
13:12:47 <Saizan> ?docs Data.List
13:12:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:12:58 <fuzan> @go Typeable Haskell
13:13:00 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
13:13:04 <fuzan> hmm
13:13:33 <fuzan> read some papers on it ;)  it exists to provide the compiler enough information about types to do some cool things.
13:13:40 <fuzan> :t cast
13:13:42 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
13:13:56 <lygaret> Huh.
13:13:59 <fuzan> > cast ("5"::Int)
13:14:00 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
13:14:04 <fuzan> hehe
13:14:05 <fuzan> dur
13:14:18 <fuzan> > cast "5" :: Maybe Int
13:14:19 <lambdabot>  Nothing
13:14:20 <fasta_> Is using return when you use it as a Maybe obfuscation? I.e. return instead of Just, fail "foobar" instead of Nothing?
13:14:25 <fuzan> > cast "5" :: Maybe String
13:14:27 <lambdabot>  Just "5"
13:15:18 <fuzan> lygaret: i'd suggest putting code on hiatus, and reading some papers and building spike solutions ;)
13:15:28 <fuzan> lygaret: existentials are rewarding, they're just tricky.
13:15:31 <lygaret> hah, spike?
13:15:32 <fasta_> Or even more so: tail (mplus (return 1) (return 2))
13:15:37 <byorgey> > cast 5 :: Maybe String
13:15:39 <lambdabot>  Nothing
13:15:42 <fasta_> > tail (mplus (return 1) (return 2))
13:15:43 <lambdabot>  [2]
13:16:04 <fuzan> lygaret: spike solutions = simple tests :)
13:16:17 <lygaret> yeah, that's pretty mch what this is
13:16:37 <fasta_> Existentials are only worth the effort when you understand the interface you want to offer to all your Component like things.
13:16:51 <lygaret> Which I do
13:16:56 <lygaret> right now, only render
13:17:08 <lygaret> Maybe I'm looking at this too OOish
13:18:19 <fasta_> lygaret: from a software point of view, it's good, it is maybe not very practical.
13:18:24 <fuzan> @go haskell heterogenus lists
13:18:25 <lambdabot> No Result Found.
13:18:33 <fuzan> soemone spell heterogeneus correctly
13:18:35 <sorear> heterogeneous
13:18:39 <lygaret> haha
13:18:41 <sorear> @spell heterogeneous
13:18:48 <fuzan> @go haskell heterogeneous lists
13:18:50 <lambdabot> http://haskell.org/hawiki/ExistentialTypes
13:18:50 <lambdabot> Title: ExistentialTypes - The Haskell Wiki
13:19:02 <fasta_> @goo boo
13:19:04 <fuzan> rtfm :)
13:19:05 <lambdabot> http://www.boo.com/
13:19:05 <lambdabot> Title: boo.com - a new type of travel site that's all about you!
13:19:20 <fasta_> @g foobar
13:19:21 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
13:19:37 <lygaret> :) ok, thanks everybody
13:20:04 <lispy> what is the ByteString version of lines?
13:20:06 <lispy> ?hoogle lines
13:20:07 <lambdabot> Prelude.lines :: String -> [String]
13:20:07 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
13:20:07 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
13:20:07 <fuzan> lygaret: i also use existentials in one of my projects, you can take a look. im still learning as well, so i can't claim i'm doing it "correctly". http://fuzan.org/repo/fzbot   ; you can see the declarations in Bnet.hs
13:20:09 <lambdabot> Title: Index of /repo/fzbot
13:20:26 <fuzan> lygaret: lines ;)
13:20:26 <lygaret> ok
13:20:33 <lygaret> though, in the wiki page
13:20:35 <fuzan> err
13:20:37 <lygaret> there is an example of
13:20:39 <fuzan> lispy: lines :)
13:20:41 <lygaret> class Renderable a
13:20:42 <lygaret> :D
13:21:11 <lispy> fuzan: i can't find it here: http://www.cse.unsw.edu.au/~dons/fps/Data-ByteString.html
13:21:52 <lygaret> thanks everyone!
13:22:00 <fuzan> lispy: check the char8 or lazy
13:22:19 <lispy> ah, in char8, thanks
13:25:53 <roconnor> fuzan: In some cases deeply nested pairs can act as a hetorgenous list
13:26:14 <roconnor> this works if you only ever care about a few things on top of the stack
13:26:25 <fuzan> roconnor: what do you mean by deeply nested?
13:26:40 <sorear> roconnor: Look at hlist
13:26:45 <roconnor> (((String,Int),Integer),(Int -> Int))
13:26:47 <sorear> roconnor: it IS nested pairs!
13:27:01 <roconnor> @where hlist
13:27:02 <lambdabot> http://homepages.cwi.nl/~ralf/HList
13:27:22 <sorear> (Int->Int , (Integer , (Int , (String , ()))))
13:27:34 <fuzan> isn't that someone inefficient? :)
13:27:42 <sorear> fuzan: eh?
13:27:52 <sorear> fuzan: no more so than []
13:27:54 <roconnor> fuzan: seems no worse than lists themselves
13:28:14 <sorear> fuzan: indeed better, since it can be unpacked more often
13:28:20 <fuzan> i mean if your goal is heteroginity(sp?)
13:28:42 <roconnor> fuzan: use usually use parametric types when processing them
13:28:53 <roconnor> er
13:29:05 <roconnor> one usually uses ...
13:29:20 <roconnor> where is that nice example of a stack calculator?
13:29:52 <fuzan> ?hoogle either
13:29:56 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
13:29:56 <lambdabot> Prelude.Either :: data Either a b
13:30:00 <lispy> i was thinking pack turns a string into a ByteString, but the types are not right...
13:30:03 <lispy> what am i missing?
13:30:42 <lispy> i need to go from Char to Word8
13:30:42 <Lemmih> lispy: import Data.ByteString.Char8?
13:31:03 <lispy> oh, i see
13:31:03 <fuzan> lispy: is your as binding to ByteString or ByteString.Char8 ?
13:31:06 <lispy> now i feel silly
13:31:18 <roconnor> @seen stef_
13:31:18 <lambdabot> stef_ is in #haskell and #perl6. I don't know when stef_ last spoke.
13:31:22 <jcreigh> roconnor: I wrote a simple one a while back: http://jcreigh.blogspot.com/2006/11/simple-rpn-calculator-in-haskell.html (check out the comments; dons links to a refactor he did, and some anonymous commented posted the obvious-in-retrospect even simpler 8 line version...)
13:31:24 <lambdabot> Title: Jason Creighton's Blog: A Simple RPN Calculator in Haskell, http://tinyurl.com/trg44
13:32:34 <stef_> roconnor?
13:33:12 <roconnor> stef_: did you write a hetrogenous stack calculator?
13:33:39 <roconnor> jcreigh: Unfortunatly that isn't the one I'm looking for
13:34:20 <stef_> nope
13:34:53 <stef_> in the Haskell world, I am just a lurker so far
13:35:08 <roconnor> Oh, I thought you might be Stefan Ljungstrand
13:35:12 <lispy> interesting, this program does worse with bytestrings
13:37:05 <roconnor> ah found it: http://haskell.org/hawiki/HaskellIrcPastePage
13:37:10 <roconnor> not a very clear place
13:37:12 <roconnor> ?paste
13:37:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:38:13 <hpaste>  roconnor pasted "someone else's stack calculator" at http://hpaste.org/64
13:38:21 <roconnor> let me see if I can remember how to use it
13:40:21 <roconnor> *Main> start push 5 push 6 add end
13:40:21 <roconnor> 11
13:40:32 <roconnor> heh
13:40:36 <roconnor> it's clever
13:43:20 <roconnor> *Main> start push 5 push 6 push (^2) app add end
13:43:21 <roconnor> 41
13:45:10 <sorear> Do not confuse O'Rear, Ljungstrand, Payratd, Monnier, Wehr, Holdermann, 'stefanha', ... amazing how many Stefans there are in haskell community
13:56:19 <takamura> hi
13:56:29 <Korollary> konichiwa
13:57:09 <takamura> konnichiwa
13:59:07 <sorear> muahahaha
14:20:42 <hpaste>  scodil pasted "STUArray matrix multiplication" at http://hpaste.org/65
14:20:54 <scodil> can someone tell me why that function is incompatible with runST?
14:21:26 <mauke> no, but what's the error message?
14:22:25 <sorear> return =<< unsafeFreeze s  is redundant
14:23:01 <scodil> "couldn't match expected type `forall s. ST s a` against inferred type `a1 b` in (body of function)...
14:23:38 <mauke> a1 b? whoa
14:23:47 <scodil> sorear: right of course... i took it out but it still won't compile
14:24:10 <scodil> originally i was trying to use runSTUArray which would make it end with "return m"
14:24:20 <scodil> then I tried to use runST so I just stuck the unsafeFreeze in there
14:24:33 <scodil> same error for both
14:24:44 <scodil> it works with unsafePerformIO
14:26:18 <mauke> @index unsafeAt
14:26:18 <lambdabot> bzzt
14:27:07 <hpaste>  scodil annotated "STUArray matrix multiplication" with "(no title)" at http://hpaste.org/65#a1
14:27:28 <nominolo> hm, so if the zipper is the derivative of a data structure, can't i derive by a second var and get a 2-zipper?
14:27:29 <scodil> there's the full thing if you want to try it in ghc
14:28:18 <mauke> oh, that's just the $ problem
14:28:43 <sorear> scodil: $ is not compatible with runST
14:29:14 <scodil> ah
14:29:16 <scodil> why not?
14:29:33 <mauke> because the types don't match
14:33:34 <fasta_> "The last statement in a 'do' construct must be an expression" <- error message optimized for do-blocks of 5 lines.
14:35:31 <sorear> huh?
14:36:11 <roconnor> zippers aren't quite the same as derivatives.
14:36:35 <nominolo> > do x <- return 5
14:36:36 <lambdabot>  Parse error
14:36:44 <nominolo> > do {x <- return 5}
14:36:44 <lambdabot>  Parse error
14:38:50 <nominolo> well, derivatives are the types of one-whole contexts, right?
14:39:00 <nominolo> s/whole/hole/
14:40:05 <fuzan> > do x <- return 5 ; return x
14:40:06 <lambdabot>   add an instance declaration for (Show (t1 t))
14:41:03 <nominolo> roconnor: is there any work on concurrent zippers?  or is it possible at all?
14:41:26 <nominolo> oleg's ZipperFS needs commit and refresh
14:41:35 <nominolo> and this updates the whole state
14:41:57 <nominolo> or, rather, every attached shell has its own state and commits that
14:45:32 <nominolo> the only thing i can think of is to embed a zipper into the lifted tree and make the cursor active you want
14:46:11 <nominolo> but this defeates the purpose of a zipper
15:03:04 <roconnor> nominolo: zippers trace from the current location to the root
15:03:21 <roconnor> while derivatives trace from the root to the current location
15:22:07 <drigz> how can you get profiler results for functions in the standard library (Prelude, Data.* etc)
15:22:13 <drigz> *?
15:22:57 <Heffalump> I'm not aware of any standard builds of them that are built for profiling them
15:23:05 <Heffalump> (as opposed to just supporting profiling of client code)
15:23:10 <Heffalump> so you probably need to build your own
15:24:13 <drigz> is there an easy way to do that?
15:25:31 <Heffalump> not that I know of
15:26:02 <Lemmih> drigz: Why do you want to profile the standard libraries?
15:26:23 * Heffalump would quite like to be able to do that too
15:26:40 <Heffalump> give me some sense of what things are expensive to call
15:26:52 <Heffalump> (yes, I know it depends on how often and what parameters you call them with too)
15:26:52 <drigz> Lemmih: there's a post on the mailing list about code taking longer with Data.BS than normal string
15:27:07 <matthew-_> eek. I have a type class where I have instances which compile fine, until I implement the class functions, and only then do I get the requirement for -fallow-incoherent-instances.
15:27:13 <drigz> and i was wondering where the time is going
15:27:27 <Lemmih> drigz: map = Prelude.map    and so on... ?
15:27:29 <drigz> the program is just a couple of library functions put together
15:28:04 <drigz> Lemmih: i suspect that a lot is in (==) for bytestrings, and i wasn't sure how to do that
15:29:11 <Heffalump> matthew-_: and what flags do you have before that?
15:29:21 <Heffalump> (before adding -fallow-incoherent-instances, that is)
15:29:23 <matthew-_> Heffalump: undecideable
15:29:34 <matthew-_> Heffalump: (though spelt correctly, and glasgow)
15:29:40 <Heffalump> interesting
15:29:59 <Heffalump> what if you implement them as "undefined"?
15:30:06 <matthew-_> indeed. And the args on the class function mirror the fundeps on the classes too
15:30:07 <Heffalump> I'm wondering if a call you are making is the problem.
15:30:30 <matthew-_> yeah, I think it is - undef makes it compile
15:30:53 <matthew-_> I'll try some explicit sigs in the func
15:31:08 <matthew-_> it is recursive (+ in the instances, hence the undecidable)
15:31:21 <int-e> matthew-_: ghc checks for inconsistencies rather late I think - are you using the type class anywhere (or did you, before you added the class methods, which must be type checked and trigger the check)?
15:31:49 <tga> hrm, ghc took 2.43 hours to compile on my MacBook
15:32:27 <int-e> matthew-_: hmm. I should ask that question about the the offending instances instead of the type class.
15:32:33 <matthew-_> int-e: well, no, but ghci works fine with them (just :t stuff)
15:33:04 <matthew-_> so, I can use the instances with ghci and :t with no function calls fine.
15:34:11 <int-e> hmm, weird.
15:34:25 <matthew-_> yeah. I'll try 6.7
15:37:24 <int-e> personally I'd assume that I've done something wrong if the compiler says it needs incoherent instances.
15:38:03 <matthew-_> int-e: well. I really don't want to have to turn it on. I was encouraged by the fact that I didn't have to have it on with just the type classes and instances
15:39:11 <xpika> tga: did you get command completion on your ghci on mac?
15:40:08 <tga> xpika: yup
15:40:19 <matthew-_> ahh! 6.7 blows up compilation elsewhere
15:42:15 <xpika> tga: must get myself a mac
15:42:33 <tga> xpika: yup :)
15:42:37 <fasta_> Wow, I am just amazed with the crap that makes it to addons.mozilla.org
15:43:19 <fasta_> The FSF should start writing those, then maybe in 20 years we have something that works ;)
15:43:58 <c_> anyone compiled firefox on hurd??
15:44:25 <matthew-_> c_: anyone use hurd??
15:45:13 <fasta_> matthew-_: of course there are people that use it.
15:45:33 <fasta_> matthew-_: but the probability of your grandma using it would be quite low.
15:47:26 <SimonRC> I think I found a bug in Hoogle...
15:47:36 <SimonRC> I wanted to look up   (^) :: (Num a, Integral b) => a -> b -> a
15:47:54 <mauke> @hoogle ^
15:47:54 <lambdabot> Prelude.(^) :: (Num a, Integral b) => a -> b -> a
15:47:55 <SimonRC> so I typed in (^), and got some results, with the message:
15:47:55 <lambdabot> Prelude.(^^) :: (Fractional a, Integral b) => a -> b -> a
15:47:55 <lambdabot> Control.Arrow.(^<<) :: Arrow a => (c -> d) -> a b c -> a b d
15:48:03 <SimonRC> "Hoogle says: Did you mean: (^)"
15:48:30 <SimonRC> however I *should* have typed in just ^, which gets the right results
15:48:51 <SimonRC> (^) isn't useful at all
15:49:14 * SimonRC mails the maintained
15:49:16 <SimonRC> *r
15:57:41 <int-e> @index runSTUArray
15:57:41 <lambdabot> Data.Array.ST
15:57:50 <int-e> @type Data.Array.ST.runSTUArray
15:57:56 <lambdabot> forall i e. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
15:58:23 <xpika> what is (* -> * -> *) ?
15:58:42 <Heffalump> a kind
15:58:44 <fasta_> xpika: there's also "?" :)
15:58:52 <Heffalump> it's a type of types
15:59:07 <dmwit> It says that the thing in question takes two types and yields a new type.
15:59:29 <dmwit> (Much like (a -> a -> a) means that the thing takes two values and yields a new value.)
16:00:24 <xpika> whats the difference between a and * then?
16:00:57 <dmwit> In this case, "a" is a type, and "*" is a kind.
16:01:06 <dmwit> ...
16:01:15 <dmwit> "a" is the type of a value, and "*" is the kind of a type.
16:01:38 <Igloo> It's actually more like "Int" than "a", as something of kind "*" is always fully applied
16:02:01 <dmwit> :k [a]
16:02:03 <lambdabot> Not in scope: type variable `a'
16:02:07 <dmwit> huh
16:02:15 <Igloo> xpika: Would it help to say that   Maybe :: * -> *   and   Just :: Int -> Maybe Int   ?
16:02:42 <Igloo> :k forall a . [a]
16:02:44 <lambdabot> *
16:02:58 <stepcut> s
16:03:44 <Igloo> xpika: The "Maybe :: * -> *" there says Maybe takes a type (e.g. Int) and returns a type (e.g. Maybe Int)
16:04:11 <mauke> :k ContT
16:04:13 <lambdabot> * -> (* -> *) -> * -> *
16:04:27 <dmwit> :k State
16:04:29 <lambdabot> * -> * -> *
16:05:37 <fasta_> What was "?" and "??"? Meta-kinds, IIRC?
16:07:23 <SimonRC> I don't think you can name kinds, therefore meta-kinds are useless or nearly so
16:09:24 <nominolo> hm, is parsec distributed with all haskell compilers or only with ghc?
16:09:38 <xpika> what is the difference between a type and a kind?
16:10:12 <fasta_>  then what is the reason for using "??"?
16:10:48 <dmwit> xpika: Do you understand the difference between data constructors and type constructors?
16:11:04 <dmwit> If you do, the difference between types and kinds is analogous.
16:11:12 <nominolo> xpika: a kind is the type of a type ;)
16:12:12 <sorear> fasta_: Pure evil.
16:12:32 <nominolo> xpika: a type of kind * -> * needs one more type as a parameter to become a normal type (of kind *)
16:12:34 <mauke> :k Int#
16:12:42 <lambdabot> Not in scope: type constructor or class `Int#'
16:12:47 <sorear> fasta_: Specifically, it's part of the hack GHC uses to make unboxing safe.
16:13:12 <dmwit> ?hoogle Int#
16:13:12 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
16:13:25 <sorear> if you must...
16:13:32 <sorear> :k GHC.Prim.Int#
16:13:33 <lambdabot> #
16:13:41 <nominolo> :k []
16:13:41 <fasta_> sorear: oh, right, that was it.
16:13:43 <lambdabot> * -> *
16:13:51 <fasta_> sorear: It's in the GHC User Guide, IIRC
16:13:57 <nominolo> oh, nice.  didn't know of :l
16:20:00 <int-e> @kind (->)
16:20:02 <lambdabot> ?? -> ? -> *
16:20:37 <emu> @kind ?
16:20:39 <lambdabot> parse error on input `?'
16:23:12 <int-e> fasta_: (->) is the reason I think. functions can take unboxed (kind #) or boxed (kind *) values; they can return both and also unboxed tuples (kind (#)). The function themselves are boxed values (*).
16:23:34 <augustss> ? is a kind, so its would have a "superkind", whatever you want to call it
16:24:42 <augustss> For GHC's kind system you only need one "superkind", and it is never mentioned nor checked by the compiler
16:24:54 <int-e> there are two :)
16:25:03 <augustss> there are?
16:25:31 <int-e> hmm. No. I didn't understand what you just wrote.
16:25:36 <augustss> ok, i'm seriously out of date then
16:26:18 <Heffalump> does the type families stuff require another level?
16:26:51 <augustss> Ghc has a system with values, types, and kinds.  There is no explicit level above kinds (as far as I know)
16:27:14 <Igloo> I think int-e is mixing up kinds that are the union of 2 other kinds, and superkinds, which are the "types" of kinds
16:27:17 <augustss> Heffalump: No, I don't think so
16:27:39 <int-e> Igloo: indeed.
16:32:38 <sorear> augustss is right - he's just talking about an unrelated subject.
16:33:24 <int-e> ah. he was talking about @kind ? ... I missed that. :)
16:34:03 <augustss_>  I've not checked, but I would think that Omega has another level
16:34:21 <Igloo> Omega can go arbitrarily deep IIRC
16:34:37 <Igloo> Or should that be high?
16:35:00 <augustss_> that would make sense
16:35:11 <augustss_> high, i think :)
16:35:22 <fasta_> low? ;)
16:35:35 <dolio> @pl \dx -> join (***) $ first (+dx)
16:35:35 <lambdabot> join (***) . first . (+)
16:36:37 <augustss_> Cayenne has arbitrary kind levels too, but it gets uninteresting very quickly.
16:39:01 <xpika> is there a tutorial on reading advanced type signatures?
16:39:36 <mauke> yeah, for C
16:40:05 <xpika> mauke: C?
16:40:36 <Igloo> C is the only language I know of whose type signatures are so confusing that there is a program to explain what they mean
16:40:49 <xpika> im looking for a tutorial
16:41:04 * Igloo doesn't know of a tutorial on that
16:41:12 <Igloo> What do you mean by "advanced", though?
16:41:37 <xpika> http://en.wikibooks.org/wiki/Haskell/Type_basics
16:41:44 <xpika> is too easy
16:42:25 <int-e> @type return
16:42:27 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:42:41 <int-e> is that hard? or still easy?
16:42:59 <int-e> [you can ignore the forall a (m :: * -> *). part]
16:43:22 <lacrimosa> Viva Haskell!
16:43:43 <Igloo> The above is about as advanced as Haskell type signatures, and only the "(Monad m) => a -> m a" bit is in Haskell 98
16:43:45 <xpika> i dont know what the difference between a kind and a type
16:44:02 <mauke> you can ignore kinds for now
16:44:14 <sorear> lacrimosa: ...hello?
16:44:23 <int-e> but kinds are types of types, so to say.
16:45:12 <dmwit> xpika: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/14#type-inference-by-hand
16:45:13 <xpika> int-e: so IO Int and IO Bool are kinds?
16:45:14 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7oock
16:45:26 <int-e> xpika: no. these are types.
16:46:00 <Igloo> xpika: Roughly speaking, kinds only contain * and ->
16:46:33 <mauke> xpika: kinds are why '[]' and 'Int Int' aren't valid types
16:46:35 <Igloo> xpika: You could probably write Haskell all your life without ever actually writing a kind in any source code
16:47:08 <int-e> xpika: kinds distinguish type constructors (IO) from types - * is a simple type. * -> * is a single argument type constructor, * -> * -> * a two argument type constructor.
16:49:34 <int-e> xpika: trying to write IO IO  will give a kind error because the kind of the second IO (* -> *) doesn't match the first argument kind of IO (*).
16:50:27 <Jedai> And IO IO Int
16:50:40 <int-e> is (IO IO) Int
16:50:56 <int-e> so it should give the same error.
16:51:25 <int-e> or maybe not.
16:51:36 <dmwit> :k IO IO Int
16:51:38 <lambdabot>     Kind error: `IO' is applied to too many type arguments
16:51:45 <int-e> :k IO IO
16:51:47 <lambdabot>     `IO' is not applied to enough type arguments
16:51:47 <lambdabot>     Expected kind `*', but `IO' has kind `* -> *'
16:51:53 <dmwit> :k IO (IO Int) -- is okay, though
16:51:55 <lambdabot> *
16:52:03 <Jedai> Ok so the type of return getLine is (Monad m) => m IO String
16:52:11 <Jedai> Ok so the type of return getLine is (Monad m) => m (IO String)
16:52:18 <dmwit> right
16:58:06 <xpika> ok so ContT takes a type and a (type taking a type) and returns a type taking a type
16:58:43 <xpika> :k ContT
16:58:44 <lambdabot> * -> (* -> *) -> * -> *
16:58:58 <xpika> no
16:59:01 <george--> what are the advantages of higher order functions?
16:59:18 <george--> it seems REALLY obvious to me but I cant think of a nice way to answer this question
16:59:21 <fasta_> george--: you asked a similar question earlier, IIRC.
16:59:31 <xpika> takes a type a type taking a type a type and returns a type
17:00:12 <george--> fasta: apologies :) i use haskell revision as a relaxation from physics revision. my mind is a little fried
17:00:29 <george--> i am honestly taking alot of notes from what you people say i dont mean to be wasting your time
17:00:38 <fasta_> george--: You did ask the same or related question earlier, right?
17:00:40 <augustss_> george--: with higher order function you can abstract over specialized "control structures"
17:00:59 <george--> fasta_, very likely :) higher order functions comes up alot in these past exam papers im practicing
17:01:30 <fasta_> george--: oh, it was you with the undefined bad exam questions.
17:01:33 <george--> i do understand the advantages... i just am now trying to get succinct descriptions in my hjead :)
17:01:36 <george--> fasta_, indeed :)
17:02:26 <fasta_> I question the educational methods used in that place if you are doing that.
17:03:19 <george--> hah. well. in fairness to my lecturer i think this is just my exam technique more then his suggested revision method :)
17:04:03 <george--> compared to physics (my main subject) this is much better tought :)
17:04:06 <george--> taught*
17:04:45 <fasta_> The difference between physics and computing is that computing is better understood, I guess.
17:05:11 <jbauman> cs can have lots of nice axioms, true
17:05:30 <araujo> hello
17:05:41 <george--> for me: computing is a class of 20 and the lecturer replies my emails in 1 hour max normally (even at 1am), physics is a class of 300 with often ignored emails
17:05:50 <fasta_> There will always be questions for which we won't know the answer in CS.
17:06:04 <george--> physicists are also horribly arrogant
17:06:17 <fasta_> But those questions are often not asked on exams.
17:09:39 <olsner> what's the simplest way to do nothing in a monad? (i.e. instead of inserting turds like return [] or return 0 or something like that)
17:10:06 <emu> return () ?
17:10:21 <emu> that is a value of m ()
17:10:28 <mauke> whatever :: (Monad m) => m (); whatever = return ()
17:11:16 <augustss_> 'return undefined' is also a good one
17:11:27 <mauke> or just 'undefined'
17:11:59 <augustss_> but that might fail
17:12:09 <fasta_> Or return (error "Don't touch this")
17:12:10 <Korollary> how do you stop doing nothing?
17:12:11 <augustss_> when used with >>=
17:12:19 <jfredett> is there a way to, within a program, check the type of something? (that is, I want to do something like isInteger 2/3, and get back a false
17:12:37 <Korollary> jfredett: there's a cast in Data.Generics
17:12:55 <augustss_> jfredett: no, not really
17:13:10 <jcreigh> jfredett: but you probably don't actually want to do that. What are you trying to do that you think you need check stuff at runtime like that?
17:13:16 <jfredett> I don't think cast is what I need...
17:13:26 <jfredett> well, I'm trying to redo all of PE in Haskell
17:13:33 <augustss_> 2/3 is never an Integer
17:13:35 <jcreigh> PE == Project Euler?
17:13:36 <jfredett> specifically literate Haskell
17:13:38 <jfredett> yah
17:13:42 <mauke> > cast (2/3) :: Int
17:13:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `Maybe b'
17:13:46 <mauke> > cast (2/3) :: Maybe Int
17:13:48 <lambdabot>  Nothing
17:13:49 <jcreigh> jfredett: what problem are you on?
17:13:53 <mauke> > cast (2/3) :: Maybe Double
17:13:54 <lambdabot>  Just 0.6666666666666666
17:14:04 <jfredett> I'm on 9
17:14:25 <fasta_> I find it amazing people work on PE.
17:15:11 <jfredett> I don't want to give away how to do it, if people haven't around here
17:15:17 <Korollary> I think glguy did it all
17:15:36 <jfredett> but basicly, it involves some filtering based on type.
17:15:47 <Korollary> why based on type?
17:15:48 <jcreigh> jfredett: I don't see that at all
17:16:55 <jfredett> Well, hmm, how to say this. It's not so much based on type, as it is checking a consequence of how division returns one of two types
17:17:03 <jfredett> an Integer or Double
17:17:35 <jfredett> I did it using scheme, so I had the benefit of (integer? x)
17:17:57 <mauke> division returns what the division function you use returns
17:18:08 <fuzan> :t (/)
17:18:10 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:18:16 <mauke> div returns an integer, / a fraction
17:18:18 <fuzan> always returns type implementing fractional
17:18:30 <jfredett> right, so my method won't work
17:18:39 <jfredett> so I need to rethink how to do it
17:18:42 <mauke> :t divMod
17:18:44 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
17:19:26 <fuzan> you could check to see if the floor of the value is equal to itself, in which case it's a whole number
17:19:35 <jfredett> divMod a b  returns (a `div` b, a `mod` b)?
17:19:37 <fuzan> i'm sure there's probably a function around that' more elegant than that
17:19:45 <jfredett> I'd bet that'll do it.
17:19:56 <augustss_> jfredett: you want something like 'snd (properFraction (x/y)) == 0'
17:20:05 <augustss_> there are many ways to do it
17:20:12 <jfredett> yah
17:20:13 <george--> is  depth first search traversal always left to right? is this some unwritten standard or just the case in all examples i read so far?
17:20:25 <fasta_> george--: no
17:20:30 <jfredett> It'll be good, I'll get replay value out of PE
17:20:45 <jbauman> george--: depends on how you write the tree, which side is left
17:20:59 <fuzan> hmm,
17:20:59 <sorear> george--: Everyone uses it, but only out of simplicity.  It isn't required by the definition of DFS
17:21:07 <fuzan> > cast 12.4 :: Maybe Integer
17:21:09 <lambdabot>  Nothing
17:21:36 <fasta_> jbauman: well, a tree with left and right pointers has an obvious interpretation of left and right.
17:21:56 <Korollary> It's a leftist conspiracy
17:22:12 * jfredett puts on his tinfoil hat
17:22:14 <jbauman> true, but DFS is more general than that specific case
17:22:18 <fasta_> It's Open-Sores ;)
17:22:28 <jbauman> > cast 12.0 :: Maybe Integer
17:22:30 <lambdabot>  Nothing
17:23:30 <mauke> > cast 12.0 :: Maybe Float
17:23:31 <lambdabot>  Nothing
17:23:49 <fasta_> george--: if the authors of whatever you read about DFS don't mention that fact, you are either reading something too advanced or your book stinks :)
17:23:55 <fuzan> i'm not sure why that doesn'twork
17:24:05 <fuzan> > cast (12.0 :: Float) :: Maybe Float
17:24:06 <lambdabot>  Just 12.0
17:24:13 <jfredett> hmm
17:24:19 <augustss_> why what doesn't work?
17:24:28 <george--> fasta_, quick google search and randomm pages :)
17:24:36 <LoganCapaldo> @type 12.0
17:24:38 <lambdabot> forall t. (Fractional t) => t
17:24:46 <LoganCapaldo> @type (12.0 :: Float)
17:24:48 <lambdabot> Float
17:24:52 <fasta_> george--: the web stinks for advanced concepts, imho.
17:24:58 <LoganCapaldo> That's why
17:24:59 <augustss_> but the 12.0 used in the cast defaults to Double
17:25:03 <fuzan> thats what i figured :)
17:25:17 <george--> well, all other pupils in this module im sure were taught it in first year... but im just doing this one comp sci module and no previous knowledge
17:25:30 <george--> means stuff is expected in exam questions that sometimes i dont know
17:25:33 <fasta_> george--: there are some journals online, which are sometimes good.
17:26:22 <fasta_> george--: but "wikipedia" and everything derived from it is often of very low quality.
17:26:44 <sorear> If you know how to fill the gaps yourself, you can learn a lot from the web.
17:27:34 <fasta_> sorear: I am not disputing that.
17:32:10 <jfredett> meh, I find that wikipedia is often of relatively good quality, at least on the articles I read. It certainly isn't a textbook
17:32:26 <jfredett> but it aint bad either, and it's a hell of a lot cheaper
17:32:37 <Heffalump> I think the quality of the writing is often a good guide to the quality of the information, too.
17:33:12 <jfredett> yah, I mean, you can very easily tell if you should be looking somewhere else within the first few sentences
17:34:05 <Baughn> For a C -> ByteString conversion, what do I do if I want to convert a binary (may contain 0s) array to a ByteString and associate a finalizer with it?
17:34:39 <jfredett> wow, that was about the geekiest sounding thing I've heard all day.
17:36:15 <Baughn> Actually, never mind. I think I'd better use a DiffArray.
17:40:02 <nominolo> Baughn: bytestrings aren't zero-terminated
17:40:38 <nominolo> to attach a finalizer you need access to the ForeighnPtr, though
17:40:55 <Baughn> nominolo: They aren't, but packMallocCString only works with 0-terminated C arrays
17:41:24 <nominolo> there's createAndTrim (I think)
17:41:33 <gravity> ls
17:41:35 <Baughn> Right. I already have access to the pointer, but.. I'd rather copy the whole thing into a DiffArray. It'll be far more useful for my purposes.
17:41:36 <gravity> shit, sorry
17:41:48 <MyCatVerbs> There should also be stabInTheEyeWhicheverSillyBastardCameUpWithASCIIZ
17:41:56 <MyCatVerbs> But I'm opinionated like that.
17:42:33 <nominolo> i guess it was useful at the time :)
17:44:46 <MyCatVerbs> nominolo: not really. There aren't any uses which a Pascal type string is slower for, so. :/
17:44:49 <Baughn> nominolo: Not very. It existed to save one byte.
17:45:19 <MyCatVerbs> nominolo: oh and it didn't even actually save that one byte in practice unless you had a string somewhere in between 65536 and 256 characters.
17:45:38 <dons> ?yow
17:45:39 <lambdabot> Are you mentally here at Pizza Hut??
17:45:49 <Baughn> Sure it did - pascal strings used 16 bits regardless of whether or not the first 8 were 0
17:46:00 <nominolo> oh, I was referring to ASCII
17:46:04 <nominolo> not ASCIIZ
17:46:13 <MyCatVerbs> Baughn: I thought early Pascal implementations stuck to 255 character strings.
17:46:36 <Baughn> However, C strings do have the advantage of being easily sliced. Doing the same with a pascal string would require... two lines of code, yes, but a lot of cycles.
17:46:52 <MyCatVerbs> To test the length of a Java string: one subtraction between two integers. To test the length of a Pascal string, one memory access. To test the length of an ASCIIZ string, O(n) with a goddamn looping construct that plays merry havok with pipelining.
17:46:54 <Baughn> MyCatVerbs: The C code they were considering wouldn't have
17:47:23 <Heffalump> is the implementation of a Java string defined?
17:47:27 <MyCatVerbs> Baughn: but you can't easily and nondestructively slice a C string anyway. :/
17:47:48 <Baughn> MyCatVerbs: You can, if you're only interested in the tails
17:47:51 <MyCatVerbs> Baughn: well, you can cut the end off easily enough, but Pascal strings have exactly the same advantage, just at the beginning instead of the tail.
17:48:26 <mauke> no, they don't
17:48:37 <mauke> pascal strings require destructive update
17:48:41 <fasta_> Problem 16 of Project Euler: sum $ map (\x->read [x]) (show (2^1000))
17:48:48 <mauke> wait, this is #haskell?!
17:49:03 <MyCatVerbs> And struct { char* string; unsigned short length; } has all the runtime speed advantages of both and the pitfalls of neither, except for a few bytes memory overhead.
17:49:09 <MyCatVerbs> mauke: yeah, well.
17:49:23 <fasta_> It appears it's even possible with current technology to write a program that finds on it's own all the programs solving the problems itself.
17:49:28 <sorear> MyCatVerbs: Which, to a 1st approximation, is what ByteString uses.
17:49:40 <MyCatVerbs> mauke: linked-list strings aren't even up for discussion, y'see, because everyone here knows that they're obviously the correct solution for absolutely everything.
17:50:05 <nominolo> except memory saving
17:50:06 <mauke> C strings are very efficiently packed linked lists
17:50:22 <Heffalump> without any of the properties of linked lists, like common tails
17:50:25 <jql> implicitly linked lists. yay. :)
17:50:26 <MyCatVerbs> mauke: (maybe I was joking? :P)
17:50:48 <sorear> Actually, ByteString uses  struct { char* array; unsigned int length; unsigned int offset; } for the benefit of the GC...
17:50:53 <mauke> Heffalump: well, you get cheap suffixing
17:51:05 <Heffalump> yes, like with any array
17:51:18 <mauke> er, no
17:51:46 <nominolo> ?yarr
17:51:47 <lambdabot> Yarrr!
17:52:04 <nominolo> @. ?yarr ?yow
17:52:04 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "?yarr"
17:52:14 <nominolo> @. yarr yow
17:52:15 <lambdabot> Aye Aye Cap'n
17:52:23 <mauke> @. elite yow
17:52:24 <lambdabot> T|-|3rE'$ 4 lItt|3 PIc7ur3 0F Ed mC/\/\4|-|0n doing bad THINgz0rz tO jOAN RIVERz0rz IN 4 $200,000 /\/\alibU 83Ach |-|0u$e!!
17:52:56 <nominolo> wow, even readabl
17:54:28 <Korollary> $200k Malibu Beach house? What year is this?
17:54:55 <olsner> http://worrydream.com/AlligatorEggs/ <-- beautiful!
17:54:56 <lambdabot> Title: Alligator Eggs!
17:55:27 <MyCatVerbs> sorear: so identical to Java strings, then?
17:55:40 <sorear> MyCatVerbs: Yeah.
17:56:23 <Heffalump> is the char* shared between multiple ByteStrings then?
17:56:24 <dons> its kind of disappointing that joel seems to consistently fail with his haskell projects.
17:56:42 <sorear> mind you, this is *strict* bytestrings we are talking about - to the best of my knowledge NOBODY can match the awesomeness of lazybs.
17:56:44 <gravity> haskell wasabi will just have to wait
17:56:46 <dons> well, 2/2 he's decided to reimplement in some other language.
17:56:53 <pchiusano> hello
17:56:58 <fasta_> dons: his poker stuff and now?
17:56:59 <sorear> hi.
17:57:14 <sorear> Heffalump: Yes.  fex - tail is O(1)
17:57:16 <dons> fasta_: a compiler for some language he wants.
17:57:20 <Korollary> dons: is it disappointing that he failed, or that he decided to write about it?
17:57:31 <dons> he wrote two versions, one in haskell, and one in ocaml.
17:57:39 <MyCatVerbs> Heffalump: can be, jah. Same reason Java strings can be so fast if you use 'em properly. Taking substrings is (almost) free.
17:57:48 <dons> Korollary: hmm, that he failed. i mean: we seem to be able to write good systems in haskell, why does joel give up?
17:58:12 <Korollary> dons: that may be just joel's problem. You can't fix everyone.
17:58:21 <dons> i think though, this time, his main complaint is that the ocaml compiler has faster turn around
17:58:27 <dons> so that's probably not too bad.
17:58:40 <pchiusano> yo, if I have my own custom list, something like (Cons 1 (Cons 2 (Cons 3 Nil)))
17:58:40 <dons> he did seem to get both working at least.
17:58:50 <pchiusano> and I want to conver it to a regular list...
17:58:52 <Korollary> dons: url?
17:59:01 <dons> its on planet haskell
17:59:07 <pchiusano> is there some function I could use for that... like an unfold?
17:59:12 <CosmicRay> what joel are we talking about?
17:59:21 <dons> Joel Reymont
17:59:27 <sorear> joelr1
17:59:32 <fasta_> dons: I think he has a point with compile times.
17:59:39 <dons> definitely.
17:59:43 <CosmicRay> oh.
17:59:54 * fasta_ reads the rest
18:00:00 <sorear> haskell compilers can be very fast indeed.
18:00:01 <dons> he tends to pick unusual techniques though.
18:00:02 <MyCatVerbs> pchiusano: let { fu (Cons a b) = a:(fu b); fu (Nil) = []; }
18:00:05 <dons> for example, 'transforming ASTs with monads and type classes'
18:00:11 <sorear> hugs can compile all of base in 200ms
18:00:14 <dons> which isn't hmm, the moost concise way.
18:00:15 <mauke> pchiusano: did you write a foldr for your List?
18:00:17 <CosmicRay> fasta_: I would point out that any time saved by ocamlcc is more than made up by frustration with n different ocaml build systems, all different, most broken on various platforms
18:00:22 <sorear> otoh, the interpreter sucks compared to ghci's
18:00:27 <MyCatVerbs> pchiusano: or something along those lines. Lazy method, anyway.
18:00:30 <CosmicRay> but if nobody else has to use your code, hey, maybe that's ok
18:00:53 <MyCatVerbs> sorear: I thought ghci didn't have an interpreter, it compiled statements down to bytecode or something?
18:01:00 <dons> last time he wrote his own inefficient binary library, then blamed it on haskell's speed. so hmm, picking unusual techniques (he seems to like the edgy technology), but then having it not work, seems to happen to Joel fairly often.
18:01:06 <sorear> MyCatVerbs: Right. Bytecode, not native code.
18:01:09 <pchiusano> ah, no, suppose it is fully evaluated
18:01:12 <MyCatVerbs> sorear: or does it only actually perform compilation on files that you deliberately load in?
18:01:16 <CosmicRay> dons: heh
18:01:24 <MyCatVerbs> sorear: yeah, but bytecode still usually gets you halfway there anyway.
18:01:36 <dons> so then, generalising from his funny techniques failing, to judgements about the language in general, that's a dodgy bit.
18:01:48 <CosmicRay> oh geez, "ocaml is the practical haskell"
18:01:48 <MyCatVerbs> sorear: (depending on how well you've designed it, of course )
18:02:12 <sorear> MyCatVerbs: Hugs and ghci are both non-optimizing bytecompilers, I reckon they are about equivalent in the frontend.  But ghci's bytecode interpreter is 2-10x faster than hugs's
18:02:22 <dons> and he compares different techniques, SYB versus a preprocessor.  :/
18:02:42 <pchiusano> MyCatVerbs, okay, I understand your example
18:03:00 <pchiusano> toList (Cons a b) = a:(toList b)
18:03:02 <sorear> MyCatVerbs: Now if only we could get hugs to generate GHCI-compatible bcos :)
18:03:02 <fasta_> CosmicRay: what's Haskell's "build system"? Cabal?
18:03:09 <pchiusano> toList Nil = []
18:03:10 <george--> pchiusano, you want to write a function that flattens a tree?
18:03:10 <CosmicRay> fasta_: yup
18:03:25 <CosmicRay> fasta_: every time I hear someone complain about cabal, I want to send them a url to ocamlmake
18:03:33 <MyCatVerbs> pchiusano: jah, except I'm worse at variable & function names than you are. But pattern matching makes this trivial, jah. Awesome, don't you think? =D
18:03:50 <CosmicRay> let's not forget that to build a library on most ocaml platforms, you have to compile it twice.  once to native code, once to bytecode.
18:04:02 <Korollary> CosmicRay: There's something new now. ocamlbuild or something.
18:04:03 <MyCatVerbs> sorear: what, then we'd have hugs-ish compilation speed and ghci-ish running speed?
18:04:04 <CosmicRay> but your makefile must handle systems that don't have the ocaml native code compiler (ocamlopt)
18:04:06 <pchiusano> yes, pattern matching rules :)
18:04:12 <mauke> pchiusano: foldR f z Nil = z; foldR f z (Cons x xs) = f x (foldR f z xs)
18:04:20 <pchiusano> but is there some general 'unfold' function in the prelude?
18:04:23 <mauke> pchiusano: toList = foldR (:) []
18:04:25 <sorear> CosmicRay: To build a library on GHC you need to compile it twice and link it THREE times! :)
18:04:39 <dons> sorear: no FUD, thanks.
18:04:48 <dons> it is tedious.
18:05:03 <CosmicRay> sorear: heh
18:05:16 <sorear> at least it's automated
18:05:19 <dons> sorear: btw, "Actually, there exists no interpreter for Haskell.  Period." isn't terribly helpful either. its melodramatic.
18:05:29 <MyCatVerbs> sorear: we know you were joking but DAMMIT the walls have EARS, man! Out of context quoting is not your friend.
18:05:48 <MyCatVerbs> dons: so what's Hugs, chopped liver? o_O
18:05:51 <jbauman> pchiusano: unfoldr...
18:05:56 <sorear> MyCatVerbs: Um, who was I quoting?
18:06:18 <MyCatVerbs> sorear: not who are you quoting but who might quote you.
18:06:32 <dons> or take your expression literally.
18:06:35 <pchiusano> :t unfoldr
18:06:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:06:43 * MyCatVerbs stuffs a tinfoil hat on sorear's head and starts polishing rifles, waaaaaiting for the commies...
18:06:44 <sorear> MyCatVerbs: No, I was being serious.
18:07:10 <MyCatVerbs> sorear: well, you probably want to compile the *compiler* twice, but aside from that s'all good.
18:07:35 <scodil> whats the margin of error on the profilier? I've got a handful of different implementations of the same function and they all bounce around between 8% and 20% each so I can't tell which is the fastest. does that mean there's no difference?
18:07:36 <pchiusano> jbauman: can you give an example of unfoldr?
18:07:37 <sorear> MyCatVerbs: Once for profiling, with link to .a;  once for non-profiling with link to .a; then link non-profiling again to a ghci-compatible .o file
18:07:38 <fasta_> CosmicRay: Does Cabal solve the same problem as autoconf?
18:07:41 <MyCatVerbs> sorear: shurely? I didn't notice much repetition while compiling bits and pieces for stuff.
18:07:43 <mauke> toList = unfoldr f where f Nil = Nothing; f (Cons x xs) = Just (x, xs)
18:08:09 <dons> MyCatVerbs: because sorear is counting a profiled build as a second build.
18:08:12 <CosmicRay> fasta_: no.  i have never found the need for autoconf to build my haskell code.
18:08:20 <MyCatVerbs> sorear: hrmn. I'm tempted to write those off as compiler stages, which don't really count.
18:08:24 <CosmicRay> fasta_: cabal solves the same problem as make.
18:08:33 <sorear> dons: it takes just as long as the first one - what more need it have?
18:08:58 <MyCatVerbs> sorear: nobody does 1-pass compilers, dude. Except for assembly language (been there, done that, for a laugh, no clue how many bugs I introduced in the process).
18:09:08 <dons> sorear: you're worse than Joel, comparing 3 ghc outputs against 2 ocaml outputs, and saying the ghc has more steps..
18:09:19 <pchiusano> mauke: so unfoldr uses returning Nothing to determine when to stop, er, unfolding?
18:09:51 <sorear> dons: I don't think I'm being any worse than CosmicRay
18:09:58 <fasta_> CosmicRay: ok, suppose I make a package based on some existing C lib. How do I check for the existence of that lib? Do I just need to write out a bunch of paths and check whether it's there or is there already somethign like that in place?
18:09:59 <sorear> 18:02 < CosmicRay> let's not forget that to build a library on most ocaml platforms, you have to compile it twice.  once to native code, once to bytecode.
18:10:14 <sorear> dons: ^^^ how is that less fuddy than what I wrote?
18:10:31 * fasta_ is with sorear 
18:10:42 * fasta_ loves picking sides
18:11:10 <fasta_> something*
18:11:47 <MyCatVerbs> sorear: so, profiled vs non profiled builds with ghc. Do both get done automatically or is this something that is done exclusively by sane people, on purpose?
18:12:51 <MyCatVerbs> sorear: because I can't see there being any point in building an executable with profiling built in unless you actually *run* it, several times, with a real luser at the helm to observe real behavoir. Surely there's no non-AI-complete way to substitute for that.
18:13:01 <sorear> MyCatVerbs: ghc doesn't do it, but cabal does
18:13:22 <fasta_> sorear: by default? Since when?
18:13:42 <sorear> MyCatVerbs: This is only for libraries, since you need separate library builds in order to build apps with profiling
18:13:59 <sorear> fasta_: No, at the drop of a two-character option
18:14:00 <MyCatVerbs> sorear: ahhhhh.
18:14:01 <dons> sorear: you added a profiling phase, comparing apples to oranges. and you have a long history of melodrama, like "there's no Haskell interpreter." , so i reflexively expect fuddish statements now. :/
18:14:04 <CosmicRay> fasta_: why would you need to check for its existence? is that not merely moving the error from one point to another?
18:14:21 <MyCatVerbs> sorear: that's only building twice though, not three times. :P
18:14:43 <sorear> MyCatVerbs: Building twice, and linking three times
18:14:44 <MyCatVerbs> sorear: and that still only technically requires that you do the emission stage twice, not neccessarily the whole damn compilation chain.
18:15:22 <dons> to produce bytecode-ready and native code, from ghc, you compile once, and link twice.
18:15:36 <fasta_> CosmicRay: I like it when ./configure tells me: "we detected you need lib-foobar (it finds that I am on Fedora and points to the right package)"
18:15:38 <dons> avoiding a native code compilation step, required on the ocaml side.
18:15:44 <fasta_> CosmicRay: that's called polish.
18:15:54 <dons> that compares the process required to produce the same results from both systems.
18:16:10 <dons> which sorear chose not to do, to be melodramatic.
18:16:23 <MyCatVerbs> dons: I thought ghc didn't *have* a to-bytecode compiler? Just native code emission? oO
18:16:26 <CosmicRay> fasta_: I call it verbose.  it tells me nothing more than "couldn't find libldap"
18:16:29 <sorear> dons: No, because ocaml can do profiling with ordinary builds.
18:16:51 <dons> MyCatVerbs: indeed. its bytecode interpreter can mix bytecode and native code (in a particular format)
18:17:00 <fasta_> CosmicRay: I think there was a time when those name schemes weren't so standardized.
18:17:02 <CosmicRay> fasta_: if you're talking about locating a library, that's a different question; that can be done with cabal already.
18:17:31 <CosmicRay> fasta_: lib{whatever}.a goes back way before ELF even, and not just on linux
18:17:33 <MyCatVerbs> dons: I don't have the first flying fuckstain of a clue how to go about using that. 
18:17:34 <CosmicRay> hell, even AIX does it.
18:17:54 <fasta_> CosmicRay: I mean in the names of packages of distributions
18:18:01 <CosmicRay> but anyway.  if you want that error, use configure.
18:18:29 <dons> MyCatVerbs: ghci does it by default, if it finds a .o or package for your code.
18:18:40 <fasta_> CosmicRay: So, Cabal doesn't support user-define error messages when the check for libX fails?
18:19:00 <dons> only via configure scripts
18:19:03 <fasta_> user-defined*
18:19:23 <CosmicRay> fasta_: that is not true.  if you want to code your check using cabal, fine.
18:19:30 <CosmicRay> fasta_: why are you trolling?
18:19:31 <MyCatVerbs> dons: .o files being native obe
18:19:43 <CosmicRay> fasta_: I simply stated that cabal does not solve the same problem as autoconf.
18:19:53 <fasta_> CosmicRay: I am not, I am inexperienced with Cabal.
18:19:54 <MyCatVerbs> dons: argh. .o files being native object code in ELF format, that's whether the native/bytecode mixing comes in?
18:20:17 <dons> MyCatVerbs: yes, it will mix interpreted bytecode with calls into previously compiled native code
18:20:34 <dons> fasta_: btw, xmonad is a serious window manager. not a useless toy ;)
18:20:47 <CosmicRay> fasta_: which, I should think, is pretty much objectively true.  autoconf provides a set of tools to help you detect things about your environment.  there are other ways to detect those things -- homegrown shell scripts, for instance.  it is possible to do that detection in Setup.hs if you wish.  it may or may not be as easy as with autoconf.
18:20:49 <dons> i meant to discuss this with you a few days ago, but you weren't around.
18:20:55 <CosmicRay> it is also possible to use autoconf and cabal together.
18:20:56 <MyCatVerbs> fasta_: and just WHAT in the HELL is wrong with TOYS!?
18:21:21 <MyCatVerbs> CosmicRay: noooooo, autoconf blows donkeys. :(
18:22:30 <gravity> autoconf isn't so bad. automake is horrific though
18:22:55 <fasta_> I find it annoying that I need to learn M4 for autoconf.
18:22:56 <dons> fasta_: btw, i'm referring to "15:11:32 <fasta> I can imagine xmonad to be useless anyway, since it's not mature software. It's just a marketing project, as far as I am concerned.".
18:23:03 <fasta_> dons: yes, I know.
18:23:14 <dons> which is a incorrect analysis.
18:23:45 <fasta_> dons: I said that I can imagine it to be that case.
18:24:00 <fasta_> dons: I browsed the source code this afternoon.
18:24:05 <gravity> Heh, xmonad has become my backup wm as of tonight
18:24:41 <fasta_> dons: maybe a window manager is a really easy piece of software and in that case my analysis is wrong.
18:25:07 <dons> they're not terribly easy, X is a very tedious, complex protocol.
18:25:12 <fasta_> dons: there's so little amount of code, that I can't imagine it to have covered all the cases.
18:25:18 <dons> and making a usable system is certainly not trivial.
18:25:44 <davidL> can different data types be stored in the same array?
18:25:52 <fasta_> dons: I will have another look.
18:25:55 <dons> i'm not sure what that means. it covers its spec. producing a tiling window manager.
18:26:09 <Baughn> davidL: No
18:26:11 <dons> fasta_: it might be best to actually use it. rather than try to infer from the code whether it works.
18:26:30 <Baughn> davidL: (So define one that covers all your cases)
18:26:36 <dons> it doesn't attempt to use all of the X protocol, of course, because we don't want to use the majority of events or features.
18:26:39 <fasta_> dons: you know what? I will try now. What's the easiest way to install?
18:27:00 <davidL> Baughn: what do you mean?
18:27:06 <dons> i'd grab xmonad from darcs, after first ensuring you have X11-1.2 from hackage, and X11-extras from darcs
18:27:07 <fasta_> dons: Does it everything Metacity does?
18:27:13 <Baughn> davidL: The data statement?
18:27:14 <sorear> haha, no way
18:27:15 <dons> no. its a tiling wm.
18:27:23 <fasta_> dons: ok
18:27:31 <dons> fasta_: its a tiling wm. check the screenshots to see why you're comparing vi to emacs :-)
18:27:36 <sorear> metacity's *problem* is not the same as xmonad's, so the code isn
18:27:41 <sorear> 't directly comparable
18:27:46 <fasta_> dons: I saw some screenshots.
18:27:55 <dons> yes, its like comparing Java to sed, and saying sed is unusable.
18:27:57 <davidL> Baughn: I'm not using a data statement. I just want my array to store ints and doubles
18:28:11 <Baughn> davidL: Well, you ned to..
18:28:15 <LoganCapaldo> davidL: so use a Either Int Double
18:28:29 <davidL> ?ty Either
18:28:31 <lambdabot> Not in scope: data constructor `Either'
18:28:36 <LoganCapaldo> @kind Either
18:28:38 <lambdabot> * -> * -> *
18:28:46 <sorear> davidL: seems kinda odd - what use could you have for either an int or a double?
18:28:46 <dons> fasta_: drop by #xmonad for advice , darcs repo urls
18:28:50 <LoganCapaldo> @type Left (1 :: Int)
18:28:52 <lambdabot> forall b. Either Int b
18:29:03 <LoganCapaldo> @type Right (2.0 :: Double)
18:29:05 <lambdabot> forall a. Either a Double
18:29:09 <Baughn> davidL: data Either a b = Left a | Right b
18:29:21 <sorear> davidL: remember that on most platforms Double strictly contains Int, so exactness is no issue
18:29:45 <Baughn> sorear: IS that so?
18:29:55 <davidL> sorear: are you saying I should convert my ints to doubles?
18:30:05 <Baughn> sorear: I'd be very, very worried if I saw code that assumed that
18:30:15 <sorear> Baughn: Yes, on any platform where Int is 32 bits and Double is double precision
18:30:34 <sorear> Baughn: most code doesn't need a great range of integers anyway
18:30:55 <Baughn> sorear: It's nice being able to use ==, though
18:30:55 <sorear> Baughn: it's just that Int wraps on overflow, while Double gradually loses precision
18:31:06 <sorear> Baughn: You can use == on Double just fine.
18:31:19 <Baughn> sorear: The thought gives me the willies
18:31:35 <sorear> Baughn: As long as your numbers are within -2^31 .. 2^31-1, there will be no rounding error and == will work fine
18:31:50 <sorear> more like -2^52..2^52 actually
18:32:13 <davidL> > 2^52
18:32:14 <lambdabot>  4503599627370496
18:32:20 <sorear> this is one of the Lua design decisions.  Lua has no ints, all numbers are C double's
18:32:30 <sorear> > 2^52+1 :: Double
18:32:32 <lambdabot>  4.503599627370497e15
18:32:32 <mauke> how do they do bit ops?
18:32:45 <sorear> mauke: Temporary cast to int, I think
18:33:09 <LoganCapaldo> I believe javascript is the same way as well, including the temporary cast to insts for bitwise ops
18:33:58 <sorear> mauke: that said, Lua's bit ops are very inconvienient to use.  number.bitwise_or(a,b) or something similarly nasty
18:44:17 <scodil> is there a way to increase the accuracy of the profiler? I end up having to run my program or ever to get stable values out of it... or does that have to do with something else?
18:44:30 <scodil> gc maybe?
18:44:45 <emu> gc should be separate
18:44:55 <emu> what do you mean specifically by unstable
18:45:20 <sorear> scodil: You want your program to run a fairly long time. 10sec cpu time is good
18:45:36 <scodil> i'm trying to find the fastest way to do this one thing, so i wrote a few different functions to do it, but they bounce around in the profiling rankings
18:45:40 <sorear> scodil: Also, don't make it interactive.  Use a repeatable input source like a file
18:45:54 <sorear> scodil: How many ticks does the profiler give?
18:46:02 <sorear> scodil: ~5 is BAD, ~500 is GOOD
18:46:38 <scodil> 300
18:47:16 <scodil> is there a way to increase the sampling rate? (thats what the ticks are, right?)
18:47:20 <sorear> Is that the total, or the number listed for one of your functions?
18:47:25 <sorear> @where manual
18:47:26 <lambdabot> I know nothing about manual.
18:47:46 <sorear> @where+ manual http://haskell.org/ghc/dist/current/docs/users_guide/
18:47:46 <lambdabot> Done.
19:05:06 <newsham> anyone know if current hpaste and current happs go together?
19:07:54 <Saizan> http://zzodici.yi.org/s/hpaste-devel <-- this builds with current happs
19:08:22 <newsham> ty
19:08:35 <newsham> 403 forbidden
19:08:53 <Saizan> darcs get ?
19:08:59 <newsham> http
19:09:37 <Saizan> use darcs get :)
19:10:30 <Saizan> i haven't bothered to get directory listing with happs..
19:12:24 <newsham> i need to make hpaste work with poker hand histories (basically just change things like [7d] into <img src=7d.png>)
19:12:37 <newsham> cause someone domain sniped pokerhand.org which used to do that
19:14:45 <hpaste>  jfredett pasted "Parse Error in Pattern" at http://hpaste.org/66
19:14:53 <jfredett> anyone want to help? :)
19:15:09 <Saizan> poker hand histories?
19:15:43 <Saizan> jfredett: findT x (p:ps) ...
19:15:55 <jfredett> damn, i knew it was simple
19:16:35 <jfredett> Saizan gets 10^100 points for pointing out my dumb error, brilliant!
19:16:49 <Saizan> also, you can use otherwise instead of your second comparison
19:17:04 <sorear> > otherwise
19:17:06 <jfredett> I know, but I like the second comparison
19:17:12 <lambdabot>  True
19:17:27 <jfredett> it makes me feel more mathematical.
19:18:11 <Saizan> oh, well :)
19:21:54 <Saizan> sorear: does lambdabot reconnects when dropped by the server?
19:22:28 <dons> > 1+@
19:22:28 <lambdabot>  Parse error
19:25:35 <sorear> Saizan: No.
19:29:24 <dons> if it realises it was dropped, it will.
19:29:34 <dons> sorear: i've not noticed a silent drop in a long time, actually.
19:29:42 <dons> i wonder if that's been dealt with?
19:33:40 <Saizan> a simple approach is to ping yourself regurarily and assume you are disconnected after x time without traffic, i need to switch to non-blocking IO though
19:36:13 <sorear> dons: I actually removed that feature when I rewrote the IRC interface
19:36:32 <sorear> dons: Kinda suprising nobody has noticed :)
19:36:42 <Saizan> ?docs Control.Concurrent
19:36:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:36:48 <dons> or that it hasn't had any obvious effect.
19:41:41 <jfredett> hmm...
20:12:11 <dons> Igloo: around?
20:12:12 <dons> "Trac detected an internal error:
20:12:13 <dons> database is locked"
20:12:14 <dons> ?
20:18:54 <cdsmith> Recently dons was telling people they should write more.  So I wrote something.  Comments welcome. http://cdsmith.wordpress.com/2007/05/27/snapshotting-a-neat-problem-and-solution-in-haskell/
20:18:57 <lambdabot> Title: Snapshotting: A neat problem and solution in Haskell  Sententia cdsmithus, http://tinyurl.com/2h6zk3
20:20:41 <sorear> Are you on p.h.o ?
20:20:51 <cdsmith> sorear: What's pho?
20:21:24 <sorear> http://planet.haskell.org
20:21:25 <lambdabot> Title: Planet Haskell
20:21:41 <cdsmith> sorear: no, then.
20:27:51 <xpika> hello has anyone here used lambdavm?
20:30:33 <cdsmith> sorear: okay, I requested that it be added.  Are they choosy, or just want to be sure something is Haskell-related?
20:32:10 <stepcut> cdsmith: I suspect they just want to make sure it is haskell related
20:32:47 <stepcut> perhaps just to keep out spam bots
20:35:21 <jfredett> is there a handy way to turn a number into a list?
20:35:35 <nburlett_> anyone tried to compile the HAppS examples lately? I'm getting errors
20:35:44 <allbery_b> what kind of list?
20:35:48 <allbery_b> > repeat 0
20:35:52 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
20:35:59 <stepcut> > return 0 :: [Int]
20:36:00 <lambdabot>  [0]
20:36:10 <jfredett> i want effectively 123 -> [1,2,3]
20:36:18 <ari> > show 123
20:36:20 <lambdabot>  "123"
20:36:20 <stepcut> > show "123"
20:36:21 <lambdabot>  "\"123\""
20:36:27 <jfredett> brilliant
20:36:29 <stepcut> oops.
20:36:37 <jfredett> i should have thought of that
20:36:40 <stepcut> > show 123 :: [Char]
20:36:41 <lambdabot>  "123"
20:36:43 <allbery_b> > map charToDigit (show 123)
20:36:44 <lambdabot>   Not in scope: `charToDigit'
20:36:44 <dmwit> > digitToInt '1'
20:36:46 <lambdabot>  1
20:36:55 <allbery_b> > map digitToInt (show 123)
20:36:56 <dmwit> > map digitToInt . show $ 123
20:36:57 <lambdabot>  [1,2,3]
20:36:57 <lambdabot>  [1,2,3]
20:37:03 <allbery_b> that was what I meant.  feh
20:37:12 <jfredett> and reverse reverses a list, right? so...
20:37:16 <jfredett> > reverse show 123
20:37:17 <lambdabot>  Couldn't match expected type `[a]'
20:37:22 <dmwit> > reverse . show $ 123
20:37:24 <lambdabot>  "321"
20:37:34 <jfredett> brilliant
20:37:46 <hpaste>  nburlett_ pasted "(no title)" at http://hpaste.org/67
20:38:57 <jfredett> how about going from [1,2,3] to 123?
20:39:01 <ari> (\radix -> reverse . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` radix, n `div` radix))) 10 123
20:39:14 <ari> > (\radix -> reverse . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` radix, n `div` radix))) 10 123
20:39:16 <lambdabot>  [1,2,3]
20:39:18 <joe_k> Is there a way to use unicode symbols, say, as a function name
20:39:30 <allbery_b> in ghc 6.6 and later, sure
20:39:37 <cdsmith> @type intToDigit
20:39:39 <lambdabot> Int -> Char
20:39:52 <joe_k> great, can I just input utf-8 or do i need to set some option?
20:39:56 <cdsmith> > read $ map intToDigit [1, 2, 3]
20:39:57 <lambdabot>  123
20:39:57 <nburlett_> > map intToDigit [1,2,3]
20:39:59 <lambdabot>  "123"
20:40:11 <byorgey> > foldl' (\x y -> 10*x + y) 0 [1,2,3]
20:40:12 <lambdabot>  123
20:40:21 <allbery_b> > let  = pi in cos 
20:40:21 <lambdabot>  Illegal character ''\128''
20:40:34 <allbery_b> hm, right, ghci and lambdabot both have issues
20:41:01 <byorgey> jfredett: that will take you the other way
20:41:04 <allbery_b> > map intToDigit [1.2.3]
20:41:05 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> c'
20:41:08 <allbery_b> oops
20:41:29 <allbery_b> > map intToDigit [1,2,3]
20:41:30 <lambdabot>  "123"
20:41:54 <jfredett> doesn't look like i have intToDigit
20:41:59 * allbery_b has been screwing up all evening and should probably take the hint and go to bed...
20:42:02 <ari> @index intToDigit
20:42:02 <lambdabot> Data.Char
20:42:05 <allbery_b> @index intToDigit
20:42:05 <lambdabot> Data.Char
20:42:07 <byorgey> > read . map intToDigit $ [1,2,3]
20:42:08 <allbery_b> heh
20:42:09 <lambdabot>  123
20:42:15 <byorgey> jfredett: that works too
20:42:35 <ari> @quote stereo
20:42:35 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:42:44 <byorgey> heh
20:45:51 <nburlett_> yargh, why won't my HAppS examples compile?
20:48:08 <allbery_b> hm, didn't someone mention here some time back that the HAppS examples were out of date?
20:48:22 <nburlett_> I think I saw something to that effect on Google
20:48:34 <nburlett_> but they still seem to be borked
20:48:43 * allbery_b doesn't use HAppS so wouldn't really kjnow
20:51:16 * nburlett_ doesn't use HAppS yet either ;-<
21:06:11 <allbery_b> have you tried #happs yet?
21:12:29 <nburlett_> hm, no
21:15:15 <nburlett_> there appears to be non one there :-<
21:15:16 <nburlett_> oh well
21:15:53 <sorear> nburlett_: #haskell is the only channel I've seen where questions are answered within the hour.
21:16:14 <sorear> nburlett_: Everywhere else, you should stay a day or two before moving on :(
21:16:21 <nburlett_> sorear: only channel on the entirety of IRC? ;->
21:16:35 <sorear> nburlett_: Yes.
21:16:46 <sorear> nburlett_: Note the "I've seen" qualifier :)
21:16:55 <nburlett_> heh
21:17:06 <nburlett_> I find #twisted is pretty responsive
21:18:39 <dons> hey nburlett_
21:18:41 <dons> ?users
21:18:41 <lambdabot> Maximum users seen in #haskell: 340, currently: 291 (85.6%), active: 34 (11.7%)
21:18:50 <dons> ?users #happs
21:18:51 <lambdabot> Maximum users seen in #happs: 1, currently: 0 (0.0%), active: 0 (NaN%)
21:18:52 <nburlett_> hey dons
21:18:59 <dons> ah, lambdabot isn't in #happs
21:19:02 <dons> @join #happs
21:19:18 <nburlett_> yeah, #happs is pretty empty
21:20:27 <Excedrin> with Gtk2hs and the Ciaro SVG stuff, using svgRender is somewhat slow, so I'd like to render to an imagesurface then draw that instead of the svg
21:21:04 <Excedrin> any advice on how I can cache rendered SVGs cleanly?
21:21:27 <dons> hang on to them in a Map String SVGImage ?
21:26:26 <Excedrin> what's a SVGImage ?
21:27:47 <stepcut> Is there anyway to make this work in ghc:
21:27:48 <stepcut> defaultAudioType :: CString
21:27:48 <stepcut> defaultAudioType = "32 bit float mono audio"
21:28:03 <stepcut> or do I have to wait till 6.8 ?
21:28:27 <sorear> no, just install 6.7 (available now) and use -foverloaded-strings
21:28:53 <stepcut> but, in 6.6, there is no way ?
21:28:54 <sorear> actually, erm, that won't work
21:30:31 <stepcut> maybe something like, defaultAudioType = unsafePerformIO (newCString "32 bit float mono audio")
21:38:33 <edwardk> what ever happened with sjanssen's data bytestring utf8 stuff?
21:38:55 <edwardk> i kinda forgot about it, and now i'm getting around to needing it again ;)
21:41:03 <dmwit> urg
21:41:12 <dmwit> I'm writing this game, and I honestly want to keep working on it.
21:41:19 <dmwit> But I can't stop playing!
21:41:23 <edwardk> =)
21:43:25 <Excedrin> what game?
21:43:48 <dmwit> Dunno if it has a categorical name, but it was called nyetwork on the TI-89. =)
21:44:17 <dmwit> Basically,
21:44:35 <dmwit> There's some wires in a grid, and you have to rotate them to connect the server to all the clients.
21:44:51 <dmwit> It's really very simple and kind of mindless... =P
21:46:03 <sorear> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/puzzles.tar.gz
21:46:06 <lambdabot> http://tinyurl.com/32yc79
21:46:06 <sorear> dmwit: ^^^
21:46:29 <sorear> http://www.chiark.greenend.org.uk/~sgtatham/puzzles/doc/net.html#net
21:46:31 <lambdabot> Title: Net, http://tinyurl.com/yvq25y
21:48:06 <dmwit> Yeah, that sounds like it.
21:49:38 <dmwit> That's okay, I'm going to keep meaning to work on it anyway.
21:49:45 <hpaste>  nburlett_ pasted "HAppS error" at http://hpaste.org/68
21:49:53 <nburlett_> hmm.. that should have pasted to #happs
21:49:55 <nburlett_> oh well
21:50:37 <dmwit> (Mine uses Cairo to be more beautiful. =)
21:51:30 <dmwit> Oh, actually, mine is slightly different than that.
21:51:33 <dmwit> But yeah, same basic idea.
22:38:18 <stepcut> how should I make bindings to C functions that use varags ? I am using hsc2hs.
22:38:30 <stepcut> do I just export non-vararg C wrappers, and call those ?
22:39:47 <dons> I always use non-vararg wrappers.
22:39:58 <dons> e.g.
22:39:59 <dons> foreign import ccall unsafe "static stdio.h snprintf"
22:40:00 <dons>     c_printf2d :: Ptr Word8 -> CSize -> Ptr Word8 -> CInt -> CInt -> IO CInt
22:41:38 <stepcut> ok, i believe I understand
22:42:33 <stepcut> but, I am too tired to implement it today :)
23:03:12 <scodil> is there a reason why unsafeArray would be slower than newArray followed by some unsafeWrites followed by unsafeFreeze?
23:06:56 <dons> not really, other than optimisations getting in the way
23:07:10 <dons> you can't argue at a high level: it all depends on the core
23:07:20 <ari> Is there a way to succinctly group pattern matches together or otherwise achieve the same effect in order to say "if this value was constructed with one of these five data constructors here, then return this value, or if it was constructed by one of the ten here, do this other thing..."
23:07:51 <dons> yes, there's an idiom, let me find it...
23:07:57 <edwardk> hrmm. is there any parsing library (other than the little packrat parser used in haskellnet) that is designed to work over Data.ByteStrings?
23:07:58 <dons> you want fall through case matching, basically?
23:08:14 <ari> dons: That'd work, I think
23:08:17 <dons> edwardk: there's bytestringparser, a parsec hack
23:08:20 <scodil> dons: bummer cause its about half the speed (still very fast) with unsafeArray, but using a mutable array is much more cumbersome with the type of the mutable array getting involved, especially for unboxed arrays
23:08:31 <edwardk> @where bytestringparser
23:08:32 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
23:08:54 <edwardk> very nice. i was just about to write that ;)
23:09:19 <stepcut> I think it's funny to see other people use my code :)
23:09:42 <edwardk> well thank you very much jeremy =)
23:09:49 <scodil> oh wait i misread the profiling data. it allocates twice as much, but runs almost as fast
23:10:20 <stepcut> edwardk: make sure to compile with -O2, that gives about 50x performance :)
23:11:13 <stepcut> i think it is even funnier when people send my darcs patches for things I never put in darcs
23:11:41 <stepcut> I'm like, "thanks! where can I find the darcs repo for my code?"
23:12:11 * stepcut goes to bed
23:12:28 <dons> ari, you have to use == though
23:12:29 <dons> f x |  x == Just (7,2)
23:12:29 <dons>     || x == Just (8,1) = True
23:12:29 <dons>     | otherwise        = False
23:12:33 <dons> for example.
23:12:46 <dons> there's a few other ways, but they all mean cascading == I think
23:12:58 <ari> dons: I see
23:14:04 <dons> here's an interesting extension, using pattern guards.
23:14:23 <dons> for the conjunction of pattern tests (not the disjunction, like above)
23:14:24 <dons> f x |  Just (7,y) <- x
23:14:24 <dons>     ,  7          <- y = True
23:14:25 <dons>     | otherwise        = False
23:15:04 <dons> I think you were looking for a syntax for sets of disjunctive patterns, though?
23:18:13 <ari> dons: Actually, after untangling the types in my mind, I realised that all I needed was... elem :|. But thanks anyway :)
23:20:12 <dons> hehe
23:20:40 <dons> > let vowel x = x `elem` "aeiou" in    vowel 'e' -- i suppose something like that?
23:20:49 <lambdabot>  True
23:23:31 <ari> ... pretty much, yes
