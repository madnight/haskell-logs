00:06:10 <Bourbaki> moin
00:06:23 <Bourbaki> can anyone point me to a good paper that shows the advantages of lazyness?
00:06:44 <cinimod> Why functional programming matters maybe
00:07:55 <cinimod> Bourbaki: http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
00:07:57 <lambdabot> Title: Why Functional Programming Matters
00:08:04 <Bourbaki> thanks found it already :)
00:08:47 <Bourbaki> do you happen to know if there is anything stl or boost like that features concepts like monads etc in c++ through templates?
00:09:10 <DRMacIver>  Ick.
00:09:34 <fuzan> @go c++ monad
00:09:37 <lambdabot> http://kerneltrap.org/node/7488
00:09:37 <lambdabot> Title: Maybe monad in C++ | KernelTrap
00:09:56 <fuzan> lambdabot is an example of something lazy that is cool.
00:10:06 <fuzan> if it were eager, it would have googled that 5 times sooner.
00:10:18 <fuzan> wait... that's a bad thing :)
00:10:37 <int-e> nono, overeager bots would only spam the channel
00:10:51 <int-e> it should wait until it is explicitely asked to do something
00:10:54 <int-e> perfect lazyness.
00:11:00 <fuzan> touche
00:11:10 <Olathe> I hate it when bots predict what I'll ask five seconds from now.
00:12:39 <fuzan> Bourbaki: you may want to look up "Call-By-Need" as well, which is somewhat synonmous with lazy-evalutation.
00:12:52 <int-e> Bourbaki: lazy evaluation is probably a pain to implement well in C++ - in full generalization it really requires garbage collection to work.
00:12:55 <Bourbaki> thanks
00:13:18 <Bourbaki> well id even consider writing a garbage collector if it really helps in the end
00:13:19 <sorear> also look up call by name
00:13:30 <sorear> which is almost synonymous with laziness
00:13:58 <int-e> Bourbaki: monads - the boring monads (State, Maybe, Either, and actually also IO and ST) are pointless for C++; it might be fun to see how far implementing a list monad can go.
00:14:11 <int-e> (all my opinion)
00:14:52 <Bourbaki> well id like to implement something monad like in c++ and make all data accesses streams even the memory access
00:14:59 <DRMacIver> Well, there's already at least one garbage collector for C++
00:15:16 <sorear> Quite a few.  I know of at least 2
00:15:27 <DRMacIver> Although the Boehm-Wieser garbage collector does describe their C++ support as "The least portable part of the entire system"
00:15:29 <fuzan> i'm sure there's a ton. Is boehms the most popuar?
00:15:34 <int-e> any non-conservative GCs?
00:15:35 <Cheery> I'd like to rename c++ to something like: readability00
00:15:36 <Bourbaki> are they platform independant?
00:15:39 <sorear> it certainly depends on how much nativeness you need.
00:15:42 <sorear> int-e: Yes!
00:15:59 <DRMacIver> I'd like to rename C++ to UseD
00:16:02 <Cheery> or even better: readability--
00:16:13 <sorear> int-e: the garbage collector in golly's hashlife engine is written in C++.
00:16:20 <fuzan> DRMacIver: nice. that actually took a second to parse :)
00:16:32 <Bourbaki> sorear : can you point me to the GCs websites?
00:16:46 <sorear> int-e: it requires extensive mutator cooperation, but that was never a requirement
00:16:55 <DRMacIver> fuzan: I realised its ambiguity after I wrote it. :) Never mind.
00:16:59 <sorear> @google gc faq
00:17:07 <int-e> sorear: yes, that's no surprise.
00:17:07 <lambdabot> http://www.iecc.com/gclist/GC-faq.html
00:17:07 <lambdabot> Title: GC FAQ -- draft
00:17:32 <Cheery> it's somehow boring that there's no variant of lambdabot you could use from the browser
00:17:44 <Cheery> @g lambdabot
00:17:44 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google gsite gwiki . v
00:17:46 <fuzan> @quote DRMacIver I'd like to rename C++ to UseD
00:17:47 <lambdabot> No quotes match. My mind is going. I can feel it.
00:18:02 <fuzan> oh well, i can enver remember lb's syntax
00:18:08 <Cheery> @get-shapr
00:18:08 <lambdabot> shapr!!
00:18:15 <sorear>  @remember
00:18:17 <Cheery> interesting. :)
00:18:24 <Cheery> @girl19
00:18:25 <lambdabot> I have been into not actually hacking, but social engineering
00:18:28 <sorear> Cheery: google lambdaweb
00:18:30 <fuzan> @remember DRMacIver I'd like to rename C++ to UseD
00:18:30 <lambdabot> Done.
00:18:37 <sorear> @quote UseD
00:18:37 <lambdabot> emu says:  people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
00:18:39 <Cheery> @go lambdaweb
00:18:40 <sorear> @quote UseD
00:18:41 <lambdabot> http://www.lambdaweb.org/
00:18:41 <lambdabot> Title: Benvingut al Casal Lambda - Centre associatiu de gais i lesbianes
00:18:41 <lambdabot> sorear says: UnusedNick: nobody here knows, I'm sure.  corners this dark are not suitable for IRC
00:18:51 <sorear> @quote UseD
00:18:52 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
00:18:56 <sorear> @quote UseD
00:18:57 <lambdabot> dons says:  ah, it *is* like haskell, I see: Jiffy Pop is the family fun treat. No other brand of popcorn offers a self-contained popping pan. It can even be used outdoors.
00:19:02 <sorear> @quote to.used
00:19:03 <lambdabot> DRMacIver says: I'd like to rename C++ to UseD
00:19:18 <fuzan> :)
00:20:17 <Cheery> so, why did I google at lambdaweb?
00:20:29 <skew> Bourbaki: about laziness there's also "modular lazy search for constraint satisfaction problems"
00:20:33 <DRMacIver> (Although given that I still haven't bothered getting D working on my system, maybe the above is unjustified. :) )
00:20:57 <skew> that's about using laziness in tree search
00:22:23 <Wild_Cat> Is D still only available for Windows?
00:22:34 <DRMacIver> There's a GCC backend.
00:22:51 <DRMacIver> But it requires you to do annoying rebuilds of GCC from source.
00:23:00 <DRMacIver> Hence I haven't bothered.
00:24:09 <DRMacIver> (And yes, the difficulty of getting it to work under a nix is the big disadvantage in comparison to C++ :) )
00:25:07 <skew> Bourbaki: it's cool, in the end it's trivial to combine a bunch of different optimizations, in many combinations which had only previously been done incompletely or incorrectly if at all
00:25:42 <Bourbaki> skew : uh?
00:26:12 <skew> that paper I mentioned
00:26:42 <Bourbaki> ah ok sorry
00:27:05 <Cheery> I wonder, how many ways there are to express subleq-instruction -code in lambda calculus?
00:27:54 <Cheery> and which one of them could be used in reverse manner as well?
00:36:13 <fuzan> what manners exist for debugging haskell code?
00:37:22 <int-e> Debug.Trace is useful.
00:37:46 <int-e> @type Debug.Trace.trace
00:37:49 <lambdabot> forall a. String -> a -> a
00:39:25 <fuzan> Bot: {handle: <socket: 3>}: hGetBuf: invalid argument (illegal buffer size (-4))
00:39:47 <fuzan> this one's irritating me :)
00:40:33 <int-e> huh. something is trying to read -4 bytes from a socket?
00:41:31 <fuzan> i'm not sure how...
00:41:33 <fuzan> or where
00:43:08 <fuzan> oh...
00:45:13 <skew> has anyone here used C--?
00:53:41 <fuzan> ma
01:27:22 <cinimod> @type (.).(.)
01:27:25 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:29:31 <Olathe> And that's what breasts are made of.
01:32:40 <cinimod> @type (.).(.).(.)
01:32:43 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
01:33:28 <skew> @type ((.) .)
01:33:32 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
01:33:41 <skew> @type (. (.))
01:33:46 <lambdabot> forall c b c1 a. (((a -> b) -> a -> c1) -> c) -> (b -> c1) -> c
01:39:05 <sorear> @users
01:39:06 <lambdabot> Maximum users seen in #haskell: 336, currently: 295 (87.8%), active: 25 (8.5%)
01:55:54 <yango> howdy
01:56:02 <yango> @users
01:56:03 <lambdabot> Maximum users seen in #haskell: 336, currently: 290 (86.3%), active: 26 (9.0%)
02:10:42 <DRMacIver> Oh, nice.
02:10:47 <DRMacIver> I've just noticed the hoogle firefox support
02:30:15 <dmhouse> Is there any way to programmatically find out which package a function is defined in?
02:30:32 <dmhouse> (I'm allowed to consult GHCi.)
02:32:25 <sorear> Uh, I don't think your question makes much sense - why do you *care* where functions are defined?
02:32:36 <sorear> System.exitWith is defined in base
02:32:53 <sorear> but if you import it - System, the module, is from haskell98
02:33:06 <sorear> but it is defined in base, since it is just a reexport
02:33:18 <dmhouse> Well, I want to grab the haddock documentation for a function. As packages are encoded into Haddock URLs, I need to know the package for the module a function is defined in.
02:33:26 <dmhouse> I can get the module a function is defined in quite easily:
02:33:40 <dmhouse> *Main> :info find
02:33:40 <dmhouse> find :: (a -> Bool) -> [a] -> Maybe a 	-- Defined in Data.List
02:33:47 <sorear> @docs Data.List
02:33:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
02:33:56 <sorear> consult the lambdabot source code.
02:33:58 <dmhouse> But that doesn't tell me that Data.List comes from base.
02:34:05 <sorear> yes it does
02:34:08 <dmhouse> Yeah, I think lambdabot just uses a big lookup table, perhaps that's the only option.
02:34:23 <dmhouse> sorear: it does? How?
02:35:25 <sorear> sorear: yeah, it uses a lookup table.  but it can be done askingly
02:36:31 <sorear> stefan@stefans:~$ ghc -v1 -e 'seq Language.Haskell.TH.reify ()' | grep Load
02:36:31 <sorear> Loading package base ... linking ... done.
02:36:31 <sorear> Loading package template-haskell ... linking ... done.
02:36:42 <sorear> perhaps you can use that.
02:36:57 <dmhouse> Right, so I know it's in one of base or template-haskell. :)
02:37:43 <sorear> base is always loaded.  look at the bottommost - that should always be it
02:38:05 <sorear> also, the ghc-pkg database contains a mapping PackageName -> [Module]
02:38:15 <sorear> you could generate a reverse lut from that
02:38:18 <dmhouse> Aha. That's nice.
02:38:32 * dmhouse consults ghc-pkg --help
02:39:12 <sorear> stefan@stefans:~$ ghc-pkg describe template-haskell | grep -C1 exposed-modules
02:39:12 <sorear> exposed: True
02:39:12 <sorear> exposed-modules: Language.Haskell.TH.Syntax Language.Haskell.TH.PprLib Language.Haskell.TH.Ppr
02:39:45 <dmhouse> ~ $ ghc-pkg field template-haskell exposed-modules
02:39:46 <dmhouse> exposed-modules: Language.Haskell.TH.PprLib Language.Haskell.TH.Lib
02:39:46 <dmhouse>                  Language.Haskell.TH.Ppr Language.Haskell.TH.Syntax
02:39:46 <dmhouse>                  Language.Haskell.TH
02:39:48 <sorear> parsing will be a tad tricky.  it might be easier to parse the ghc-pkg db directly, since it's in deriving Read syntax
02:39:57 <sorear> Oh, that's easier :)
02:40:05 <dmhouse> Well, this will be written in Emacs Lisp.
02:40:48 <sorear> stefan@stefans:~$ ghc-pkg field template-haskell exposed-modules | cut -c18- | tr ' ' '\012'
02:40:52 <sorear> Language.Haskell.TH.Syntax
02:40:52 <dmhouse> Parsing shouldn't be that tricky. You just slurp out the 'exposed-modules: ', then split on whitespace.
02:40:54 <sorear> Language.Haskell.TH.PprLib
02:40:56 <sorear> Language.Haskell.TH.Ppr
02:40:59 <sorear> Language.Haskell.TH.Lib
02:41:02 <sorear> Language.Haskell.TH
02:41:11 <dmhouse> cut?
02:41:16 <earthy> cut. ;)
02:41:20 <sorear> dmhouse: yeah, cut
02:41:28 <sorear> dmhouse: one of my favorite unix filters
02:41:35 <sorear> it's standard!
02:41:39 <dmhouse> Ah, that's like drop 18?
02:41:40 <earthy> no it isn't
02:41:56 <earthy> it's an extension
02:42:08 <earthy> but it does occur on most linuxen and bsd's
02:42:40 <dmhouse> Well, I can just not do the cut, and skip the first line (which will be 'exposed-modules:').
02:43:03 <sorear> dmhouse: Then you'll have a LOT of blank modules ;)
02:43:26 <dmhouse> sorear: ?
02:43:31 <earthy> sorear: not if you transform all whitspeace into newlines *first*
02:43:54 <sorear> earthy: 18 spaces makes 18 newlines makes 18 blank lines.
02:44:47 <dmhouse> ghc-pkg field template-haskell exposed-modules | tr ' ' '\012' | grep "."
02:45:08 <earthy> sed -e 's/[ \011]*/\012/'
02:45:11 <earthy> dunno...
02:45:47 <ocram> what is the meaning of a (->) in a type expression?
02:46:14 <dmhouse> ocram: Int -> String is the type of functions that take an Int as a parameter and return a String.
02:46:26 <ocram> yep i know
02:46:32 <dmhouse> Int -> Bool -> String is the type of the function that take an Int and a Bool as a parameter and return a String.
02:46:36 <skew> (->) is the function type constructor
02:46:37 <dmhouse> Oh, then what exactly are you asking?
02:47:24 <skew> what type classes have a parameter at kind * -> * -> *?
02:47:33 <dmhouse> skew: Arrow?
02:47:59 <ocram> data T0 a = a; data T1 a b = T1 (a b); :t T1 T0 = T1 T0 :: T1 ((->) a) (T0 a)
02:48:16 <skew> ((->) a b) is another way to write a -> b
02:48:38 <blinkenman> Salut, mes amis!
02:48:46 <ocram> lut blinkenman
02:49:34 <ocram> skew, in my case I've got only ((->) a), it means a -> a ?
02:49:43 <dmhouse> ocram: nope.
02:49:58 <dmhouse> ocram: that's a section, just like (+ 2) doesn't mean 2 + 2, it means \x -> x + 2.
02:50:11 <skew> ocram: no, it's like "Maybe", by itself
02:50:44 <dmhouse> ocram: if you expand it:
02:50:50 <dmhouse> T1 a b = T1 (a b)
02:51:10 <dmhouse> T1 ((->) a) (T0 a) = T1 (((->) a) (T0 a))
02:51:21 <dmhouse> = T1 (a -> T0 a)
02:52:46 <ocram> uh
02:53:15 <skew> T1 a b = (T1 a) b
02:53:18 <skew> so no
02:53:40 <dmhouse> skew: see definition of T1 though
02:53:50 <dmhouse> It's not quite 'expanding'.
02:54:21 <dmhouse> Okay, let me phrase it differently.
02:54:33 <LeCamarade> ...
02:54:40 <skew> the constructor T1 takes an argument of type (a b)
02:54:42 <dmhouse> You ask for the type of T1 T0. It looks at the definition of the T1 constructor and sees that the type of T1 (a b) is T1 a b.
02:55:43 <skew> ocram: do you understand how type definitions and classes can mention unapplied type constructors?
02:55:55 <skew> like class Functor f where fmap :: (a -> b) -> (f a -> f b)
02:56:02 <dmhouse> So it tries to match the type of (a b) against the type of T0. The type of T0 is a -> T0 a, so a = ((->) a), and b = T0 a, because ((->) a) (T0 a) is another way of writing (a -> T0 a).
02:56:26 <dmhouse> So we have a = ((->) a) and b = T0 a. Therefore, the type of T1 T0 is T1 a b, or T1 ((->) a) (T0 a).
02:58:02 <ocram> dmhouse, ok
02:59:05 <ocram> dmhouse, so, if I've something of type ((->) a) (b -> c) it can be viewed as a -> b -> c?
02:59:34 <dmhouse> ocram: yep. ((->) a) (b -> c) means a -> (b -> c), which is the same as a -> b -> c.
02:59:47 <ocram> and the parenthesis around (-> a) are used only for precedence matters
03:00:01 <dmhouse> ocram: just as (+ 2) means \x -> x + 2, ((->) a) means /\T -> a -> T, where /\ is a kind of 'type lambda'.
03:00:16 <ocram> yep i know a little of lambda calculus
03:00:20 <dmhouse> ocram: ah, be careful, ((->) a) isn't the same as (-> a).
03:00:42 <ocram> ouch
03:00:42 <dmhouse> ocram: ((->) a) means (a ->), but the latter isn't standard syntax I don't think.
03:00:59 <ocram> ok
03:01:15 <dmhouse> Because (->) a b = a -> b, so ((->) a) means /\T -> (a -> T).
03:07:45 <ocram> dmhouse, but.. in your opinion what is the aim of a datatype as T1 ?
03:08:30 <dmhouse> ocram: a value of type T1 a b will contain a value of type (a b), so T1 serves as a kind of wrapper around type application.
03:08:51 <dmhouse> ocram: where did these types coming from? Are you struggling to understand some more general program?
03:09:41 <ocram> dmhouse, I'm trying to understand an advanced article about xml schema translation to generic haskell
03:10:02 <araujo> morning
03:10:40 <ocram> but I have no experience of haskell (I know ml better)
03:11:59 <ocram> so I'm reading a book about haskell but it doesn't treat examples like the T1 one
03:12:56 <dmhouse> ocram: well, I hope what I've said helps to illuminate things a bit. Feel free to ask more questions.
03:14:37 <ocram> the only similar thing I know is the definition of recursive types like lists or trees.. e.g. data List a = Nil | Elem a (List a) .. in T1 in place of (List a) there's (a b), so I think this is a way to parameterize constructor names
03:15:49 <Cheery> I found an interesting thing: http://quesoglc.sourceforge.net/
03:15:50 <lambdabot> Title: QuesoGLC
03:16:05 <ocram> thank you dmhouse I appreciated
03:16:12 <Cheery> has anyone made haskell ffi bindings for this?
03:16:46 <TomMD> I'm trying to make a Haskell program that will visually display the molecular structure for a chemical that vaccinates against allergies, can someone help by providing such a chemical?
03:17:02 <ocram> (and sorry for my bad English :))
03:19:53 <Codex_> tom: sounds like pretty difficult task (visually display the structure...)
03:21:20 <Syzygy-> TomMD: First off, vaccinate against allergies is so far as I can tell not the way you do it.
03:21:36 <Syzygy-> Furthermore, why not start with displaying molecular structures for -any- organic compound.
03:22:25 <TomMD> Syzygy: It was a joke due to my getting up at 0500h on a Sunday after not sleeping all night.
03:22:26 <Syzygy-> That said, I use fexofenadine against my allergies.
03:22:33 <TomMD> :-)
03:22:52 <LeCamarade> TomMD: You mean, to provide you with the formula?
03:23:05 <TomMD> LeCamarade: Yep
03:23:08 <Syzygy-> And you get a structure for instance here: http://www.rxlist.com/cgi/generic/fexofen.htm
03:23:09 <lambdabot> Title: Allegra (Fexofenadine Hcl) drug description - prescription drugs and medications ...
03:23:53 <LeCamarade> TomMD: I'm afraid these guys are more into monads and stuff.
03:24:01 <LeCamarade> It will be tricky.
03:24:20 <LeCamarade> :oD
03:24:29 <Syzygy-> Tricky, tricky, tricky!
03:24:40 <LeCamarade> They'll give you piles of monads. Only monads. Monads, monads, monads.
03:24:56 <LeCamarade> > repeat "Monads"
03:25:00 <lambdabot>  ["Monads","Monads","Monads","Monads","Monads","Monads","Monads","Monads","Mo...
03:27:50 <LeCamarade> I've always wondered how I could classify everything.
03:28:51 <Cheery> > unwords $ repeat "monads"
03:28:57 <lambdabot>  "monads monads monads monads monads monads monads monads monads monads monad...
03:29:11 <phoniq> mush room MUSH ROOM
03:29:14 <LeCamarade> Chemicals, animals (many chemical put together that live), sounds, ideas (communism, atheism, Hinduism), emotions (anger, happiness), et cetera.
03:29:27 <Cheery> > unwords $ repeat "chemical animals mush room"
03:29:39 <lambdabot>  "chemical animals mush room chemical animals mush room chemical animals mush...
03:31:08 <mux> LeCamarade: I'm tempted to tell you all those are strings! But that would be going a bit too far at least for ideas :-)
03:31:22 <mux> strings as in the superstring theory
03:31:28 <mux> or even the M theory
03:32:29 <dmhouse> > concat $ intersperse "mushroom mushroom " $ repeat (replicate 12 "badger ")
03:32:30 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
03:32:45 <dmhouse> > concat $ intersperse ["mushroom mushroom "] $ repeat (replicate 12 "badger ")
03:32:50 <LeCamarade> mux: :oD
03:32:52 <lambdabot>  ["badger ","badger ","badger ","badger ","badger ","badger ","badger ","badg...
03:33:09 <beelsebob> > unwords $ concat $ intersperse ["mushroom mushroom "] $ repeat (replicate 12 "badger ")
03:33:18 <lambdabot>  "badger  badger  badger  badger  badger  badger  badger  badger  badger  bad...
03:33:34 <LeCamarade> <lambdabot> Enough!
03:33:37 <LeCamarade> :oD
03:33:38 <bwerf> hehe
03:34:11 <LeCamarade> @quote lambdabot Enough!
03:34:12 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
03:34:25 <LeCamarade> @remember lambdabot Enough!
03:34:25 <lambdabot> Done.
03:34:32 <TurboSlav> so ppl
03:34:38 <TurboSlav> have a question about haskell
03:34:40 <LeCamarade> @quote lambdabot
03:34:41 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
03:34:44 <TurboSlav> prog. language
03:36:18 <TomMD> TurboSlav, just ask
03:37:32 <TurboSlav> I just saw for this prog. language and it works on *nix,windoze so is it possible to code a simple 3d game in haskell ?
03:37:46 <TurboSlav> I'm downloading a compiler right now
03:37:49 <TomMD> ?where frag
03:37:50 <lambdabot> http://www.haskell.org/haskellwiki/Frag
03:37:59 <TomMD> Its been done, see above
03:38:09 <Cheery> TurboSlav: haskell is turing complete, it is possible
03:38:16 <TurboSlav> thank you
03:38:20 <skew> you need to know OpenGL
03:38:35 <TurboSlav> hmm yeah
03:38:39 <Cheery> thought, it's also beneficial I think
03:38:47 <TurboSlav> can I use API funcs in haskell ?
03:39:04 <Cheery> ?where HOpenGL
03:39:05 <lambdabot> http://haskell.org/HOpenGL/
03:39:30 <LeCamarade> TurboSlav: You are writing the 3D game on Windows?
03:39:50 <TurboSlav> nop, I just want to see what could I do with haskell
03:39:59 <TurboSlav> I prefer system coding
03:40:07 <TurboSlav> security
03:40:16 <LeCamarade> With OpenGL you can do all your graphics hackery.
03:40:16 <TomMD> If you ask Simon (any of them) the first thing they would say is "You can write a compiler"
03:41:50 <TurboSlav> ppl
03:42:01 <TurboSlav> is it possible to use APIS in haskell progie ?
03:42:11 <TurboSlav> you know to code a network application
03:42:19 <TurboSlav> maybe some mail client
03:42:24 <TurboSlav> something like that
03:42:56 <Cheery> haskell has foreign function interface for that
03:42:59 <TomMD> ?where apis
03:42:59 <lambdabot> I know nothing about apis.
03:43:02 <TomMD> ?google apis
03:43:03 <lambdabot> http://en.wikipedia.org/wiki/API
03:43:04 <lambdabot> Title: Application programming interface - Wikipedia, the free encyclopedia
03:43:16 <TomMD> Oh, APIs, doh
03:43:27 <TurboSlav> I know what's the API ;)
03:43:39 <TurboSlav> but can I use it in my haskell progies
03:43:42 <DRMacIver> ?where ffi
03:43:43 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
03:43:51 <TomMD> I was thinking it was some four letter acronym I didn't know, not a TLA I did know.
03:44:13 <beelsebob> is dons about today?
03:44:27 <TomMD> Haven't seen him, ask the bot.
03:44:51 <arcatan> @seen dons
03:44:51 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 4d 11h 21m 35s ago.
03:44:54 <beelsebob> damn it
03:44:55 <LeCamarade> TurboSlav: lambdabot, the IRC bot here, was coded in Haskell. Network stuff is easier in Haskell than in just about every other language under the sun.
03:45:12 * beelsebob wanted to poke him about lambdabot
03:45:17 <arcatan> Erlang's network stuff is pretty easy
03:45:24 <LeCamarade> @stab lambdabot
03:45:25 * lambdabot beats up lambdabot
03:45:36 <LeCamarade> No! I meant _stab_.
03:45:52 <TomMD> beelsebob - I saw sorears not long ago.
03:45:59 <arcatan> stab the source
03:45:59 <LeCamarade> arcatan: Not as easy as Haskell's. It takes one func call. One.
03:46:05 <arcatan> to do what?
03:46:12 <arcatan> or stab the mallard
03:46:13 <beelsebob> the source at the moment does this...
03:46:14 <beelsebob> http://hpaste.org/1806
03:46:18 <beelsebob> which is completely uselels
03:46:42 <LeCamarade> arcatan: To write telnet(1).
03:46:57 <TurboSlav> lol, haskell is similiar to C
03:47:08 <TurboSlav> it doesn't support inline asm ?
03:47:09 <TomMD> Ummm... how?
03:47:19 <beelsebob> o.O
03:47:20 <TomMD> Lol - have you used ML before?
03:47:20 <TurboSlav> I mean on syntax
03:47:26 <beelsebob> TurboSlav: how?
03:47:29 <dmhouse> LeCamarade: really? You'd need connectTo, then presumably an interact routine of some sort.
03:47:34 <arcatan> beelsebob: umm.. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/arrows-0.2
03:47:34 <beelsebob> when is Haskell syntax anything like C syntax?
03:47:36 <LeCamarade> TurboSlav: People have been stabbed for saying such things ...
03:47:37 <lambdabot> http://tinyurl.com/2z6ftm
03:47:40 <LeCamarade> @stab TurboSlav
03:47:40 * lambdabot beats up TurboSlav
03:47:56 <TurboSlav> haha =)
03:47:56 <beelsebob> arcatan: the build of that fails at the moment
03:48:02 <arcatan> damn
03:48:11 <beelsebob> plus... it's meant to be in ghc
03:48:32 <skew> LeCamarade: The network libraries I've seen are not too much nicer than you'd find in e.g. Python
03:49:01 <skew> I suppose cheap threads make things nicer than many languages
03:49:38 <hpaste>  beelsebob annotated "hnuh?" with "Arrows doesn't work either" at http://hpaste.org/1806#a1
03:50:01 <LeCamarade> dmhouse, skew: Um ...
03:50:16 <dmhouse> beelsebob: paste the Setup.hs of that packages.
03:50:21 <dmhouse> s/packages/packages/
03:50:37 <skew> LeCamarade: things like "interact" are nice for little programs, but if you want to write a webserver or whatever it gets messier
03:50:49 <LeCamarade> Network.connectTo "irc.freenode.org" (PortNumber 6667) >>= IO.hGetContents >>= putStrLn
03:50:49 <hpaste>  beelsebob annotated "hnuh?" with "Setup.hs" at http://hpaste.org/1806#a2
03:50:53 <Saizan> beelsebob: you need Cabal 1.1.7, or remove the type signatures in Setup.hs
03:51:09 <beelsebob> @where cabal
03:51:09 <lambdabot> http://www.haskell.org/cabal
03:51:18 <LeCamarade> skew: telnet(1) is as simple as they get, really. A simple telnet(1).
03:51:24 <Saizan> beelsebob: if you are on debian there's libghc6-arrows-deb
03:51:28 <beelsebob> Saizan: the latest version is 1.1.6.2
03:51:33 <Saizan> s/deb/dev/
03:51:34 <beelsebob> Saizan: OS X
03:51:39 <dmhouse> beelsebob: use the darcs version.
03:51:47 <dmhouse> (Of Cabal.)
03:51:49 <Saizan> or remove the typesignatures :)
03:52:29 <dmhouse> LeCamarade: that's not really telnet, you can't send anything to the server...
03:54:41 <Saizan> beelsebob: also, to build lambdabot you don't start with configure, you ahve to run a .sh script, it's called build.sh iirc
03:54:51 <LeCamarade> dmhouse: Yeah. But it is that simple. interact ...
03:55:03 <beelsebob> Saizan: k, that'll teach me to not read the README
03:55:14 <LeCamarade> Trap args et cetera ... in short, I dunno an easier way to do it.
03:55:27 <LeCamarade> _That is `standard'_.
03:56:19 <LeCamarade> Nothing angers more than having to port utility functions about. If I find them useful enough to be porting them, someone else does, too. Language shouldn't just come with batteries installed, but also with nice batteries.
03:56:50 <skew> @where MissingH
03:56:51 <lambdabot> http://software.complete.org/missingh
03:58:31 <beelsebob> man \bot has a lot of deps
03:58:38 <skew> That's supposed to be a place you can stick little things
04:00:03 <LeCamarade> A little ashaming that Distribution doesn't handle dependencies, don't you think?
04:00:35 <dmhouse> LeCamarade: as in, automatically install the depencies?
04:00:40 <fax> LeCamarade: ideally yes
04:00:41 <dmhouse> *dependencies
04:00:46 <dmhouse> ?google cabal-install
04:00:49 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
04:00:49 <lambdabot> Title: CabalInstall - Hackage - Trac
04:00:51 <LeCamarade> dmhouse: Something of the sort.
04:00:59 <dmhouse> LeCamarade: ^^ work is underway.
04:01:01 <LeCamarade> :oD
04:01:18 <LeCamarade> hapt-get ...
04:01:40 * LeCamarade claps
04:02:05 <beelsebob> gyah
04:02:10 <beelsebob> hs-plugins doesn't build
04:06:16 <nominolo> hm, anyone tried OpenGL on OSX?
04:06:36 <nominolo> i get: /usr/bin/ld: can't locate file for: -lHSOpenGL_cbits
04:06:40 <Saizan> beelsebob: have you tried the darcs version?
04:06:55 <beelsebob> Saizan: where is it, the hackage page doesn't have a link to it
04:07:03 <Saizan> ?where plugins
04:07:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:07:52 <Saizan> darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
04:07:53 <lambdabot> Title: Index of /~dons/code/hs-plugins
04:10:21 <beelsebob> wow, lambdabot got through configure!
04:12:33 <beelsebob> nope lambdabot build failed compiling Plugin/Version.hs
04:14:10 <hpaste>  beelsebob annotated "hnuh?" with "splode?" at http://hpaste.org/1806#a3
04:14:21 <beelsebob> anyone any ideas how to fix that one?
04:17:47 <beelsebob> the relevant things are #defined
04:17:52 <hpaste>  yaxu pasted "Is this a reasonable way to count occurences of things?" at http://hpaste.org/1826
04:17:57 <beelsebob> it just evidently isn't invoking the prepocessor
04:19:21 <Syzygy-> yaxu: It's pretty much the way I implemented the LookSay
04:21:16 <yaxu> thanks Syzygy-, and interesting application of it
04:21:35 <mux> @version
04:21:35 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
04:21:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:21:45 <mux> @let x = 42
04:21:49 <lambdabot> Defined.
04:21:53 <mux> hmm.
04:22:09 * mux wonders why @let isn't working for his LB
04:23:02 <DRMacIver> @let mux's_lambdabot = "broken"
04:23:09 <lambdabot> Defined.
04:23:25 <matthew-_> nice - taking a risk with that ' in there!
04:23:35 <DRMacIver> Hm?
04:23:43 <DRMacIver> What risk?
04:23:46 <matthew-_> well, it could have got confused with the quoting
04:23:46 <dmhouse> ?let mux's lambdabot = "broken"
04:24:00 <lambdabot> Defined.
04:24:04 <matthew-_> or not...
04:24:15 <dmhouse> matthew-_: you can use ' in Haskell names, e.g. foldl'.
04:24:19 <DRMacIver> > mux's
04:24:20 <Syzygy-> > L.mux's
04:24:26 <lambdabot>  Add a type signature
04:24:30 <lambdabot>  Add a type signature
04:24:39 <dmhouse> > L.mux's ()
04:24:39 <DRMacIver> > lambdabot
04:24:47 <lambdabot>   Not in scope: `lambdabot'
04:24:50 <lambdabot>  "broken"
04:24:56 <beelsebob> @vixen asl?
04:24:56 <lambdabot> <undefined>
04:25:11 <Syzygy-> > L.mux's_lambdabot
04:25:22 <lambdabot>  "broken"
04:25:26 <matthew-_> wow, I didn't know that one.
04:25:41 <Syzygy-> > L.mux's 42
04:25:55 <lambdabot>  "broken"
04:26:15 <beelsebob> beelsebob: > 2 + 3
04:26:15 <beelsebob> doombot:     Failed to load interface for `Monad.Writer':
04:26:15 <beelsebob> doombot:       Use -v to see a list ...
04:26:16 <beelsebob> o.O
04:26:17 <Arisko> hallo@all
04:26:25 <Arisko> who can help me?
04:26:27 <matthew-_> mmm. does anyone else think that cabal should have fields and an understanding of changelogs?
04:26:39 <Arisko> I need an coder
04:26:48 <Botje> jobs.haskell.org
04:27:08 <TomMD> ?where frp
04:27:09 <lambdabot> I know nothing about frp.
04:27:09 <Arisko> I`ve got my design finish with photoshop, but now i need an coder
04:27:25 <Arisko> i want to go today online...
04:27:37 <DRMacIver> ...
04:27:47 <Botje> Arisko: and you think #haskell will do that *WHY* ?
04:27:51 <Arisko> can me help someone
04:27:51 <DRMacIver> Arisko: You're not really askign in remotely the right channel.
04:28:09 <Syzygy-> Arisko: So, basically, you want someone to do a project of undefined size in a couple of hours.
04:28:14 <Arisko> can you say me what the right channel for coders
04:28:20 <Botje> > fix ("code":)
04:28:23 <lambdabot>  ["code","code","code","code","code","code","code","code","code","code","code...
04:28:28 <Arisko> lol
04:28:53 <matthew-_> Arisko: well, you want to hire someone to do some haskell programming for you?
04:28:55 <moglum> @type fix
04:29:03 <matthew-_> (a -> a) -> a
04:29:07 <Arisko> yes...html
04:29:09 <lambdabot> forall a. (a -> a) -> a
04:29:18 <Botje> html isn't programming ..
04:29:19 <dmhouse> Arisko: try #web.
04:29:22 <skew> @google contract web programmer
04:29:24 <lambdabot> http://www.programmingbids.com/
04:29:24 <lambdabot> Title: Programming Bids: Freelance IT Programming, Web Design, CGI,Perl,PHP,ASP Program ...
04:29:27 <Botje> and how is haskell ~~ html ?
04:29:32 * matthew-_ beats λb at it's own game...
04:29:33 <skew> something like that
04:29:44 <Syzygy-> Botje: Don't try to understand the weird employer.
04:29:51 <Arisko> i need an html coder...only for html
04:29:54 <Arisko> nothing more
04:30:01 <DRMacIver> Try #web
04:30:08 <Syzygy-> Arisko: Then #haskell is the wrong place. Please leave.
04:30:15 <matthew-_> Arisko: this is the wrong channel - no one here enjoys html ;-)
04:30:17 <Arisko> sorry for my bad english...i can`t speak good english
04:30:24 <beelsebob> hmm, anyone mind if I join my  λb to #haskell so people can see what's wrong with it?
04:30:37 <mux> notes darcs only has LB p522 while there is p525 here
04:30:37 <Arisko> #web
04:30:39 <skew> beelsebob: as long as they don't fight
04:30:50 <Botje> heh heh
04:30:53 <DRMacIver> Bots are very territorial.
04:30:54 <Botje> @fight doombot
04:30:55 <beelsebob> skew: I'll change her line start symbol
04:30:55 <lambdabot> Couldn't run the figlet command.
04:30:55 <skew> Arisko: like "/join #web"
04:31:13 <Arisko> ok thanks bye
04:31:31 <DRMacIver> They'll probably just tell him to bugger off there as well. :) But at least it will be an on topic annoyance.
04:31:43 <Syzygy-> And not our problem any longer
04:32:00 <skew> or just "sure, X $/hr"
04:32:30 <Botje> "what? no way! my nephew does it in Y $/hr" "go talk to you nephew then. kthxbai"
04:32:42 <matthew-_> but Y > X
04:32:49 <matthew-_> > 'Y' > 'X'
04:32:51 <lambdabot>  True
04:33:00 <matthew-_> I only want to pay X!
04:33:01 <skew> I sure wouldn't want to try repoducing an arbitrary photoshop drawing with HTML
04:33:20 <Botje> skew: pfft. <img src="blah.jpg">
04:33:24 <Botje> "there, it's done."
04:33:30 <matthew-_> skew: I've seen many website walk-throughs done that way
04:33:55 <matthew-_> skew: and I know of people whos jobs are to make sure that the implementation is pixel perfect wrt the walkthrough
04:33:59 <Saizan> and many websites done the Botje way
04:34:07 <skew> yeah, I just don't want to try that
04:34:07 <DRMacIver> Hm. From the HAppS job ad linked from haskell.org: "We are looking for people who live in any of these places: * The Internet"
04:34:12 <skew> tables with rounded corners, and such
04:34:46 <matthew-_> it's all microsoft's fault. people only do the Botje way because you can't do platform neutral css easily
04:35:00 <Saizan> it's not hard with the right js toolkit
04:35:00 <matthew-_> and because css is just crazy in a few places.
04:35:02 <skew> depends what's in the image
04:35:07 <DRMacIver> WHat's the botje way?
04:35:14 <matthew-_> <Botje> skew: pfft. <img src="blah.jpg">
04:35:39 <DRMacIver> Oh, heh
04:35:48 * Botje boots up smalltalk
04:35:53 <Botje> time to get this damn project done.
04:36:07 <Syzygy-> Oh come on. At least it should be <img src="blah.jpg" alt="blah.jpg" />
04:36:19 <Syzygy-> There you go. XHTML compliant -and- accessible
04:36:28 <Botje> no no no. the alt should be "sorry, you need internet explorer 7.0 to continue"
04:36:36 <matthew-_> yeah - the /> would be ideal with the html doctype and a http mimetype of text/xhtml
04:36:44 <matthew-_> just to really confuse IE
04:38:30 <matthew-_> now, some more off topic-ness, bitchx annoys me now. So, I would like a text-based irc client (no fancy gui) which supports connections to multiple servers and is a bit nicer than bitchx. What would people reccomend?
04:38:38 <DRMacIver> irssi
04:39:04 <fax> man write it in an interpreted language
04:39:10 <fax> somthing you can just telnet in and chaneg bits of the code
04:39:20 <Botje> matthew-_: irssi or weechat
04:39:21 <fax> compiling then running an IRC client is a terrible idea :/
04:39:40 * araujo wonders what smalltalk implementation Botje uses
04:39:41 <Botje> or you could write your own, of course.
04:39:49 <fax> (how can you add/enhance features without shutting it down?)
04:39:50 <Botje> araujo: visualworks.
04:39:51 <skew> I'm using irssi, but I don't use multiple servers
04:40:02 <skew> fax: depends on the compiler
04:40:05 <DRMacIver> It works fine with multiple servers.
04:40:06 <araujo> Botje, nice, i just installed the 7.5 version yesterday
04:40:19 <fax> skew: well C is certainly a terrible choice
04:40:20 <matthew-_> Botje: I'm saving that until I've finished my implementation of Session Types in Haskell. Then I can get Haskell to prove at compile time that I've implemented IRC correctly!
04:40:27 <fax> the thing will just crash :p
04:40:43 <skew> fax: it's just trickier to compile things to effecient code and support replacing things
04:41:07 <fax> I suppose so
04:41:09 <skew> I think self does that quite extensively
04:41:18 <fax> SBCL does very well in that regard
04:41:27 <fax> soon as I get cocoa integration sorted..... :/
04:41:30 <skew> even lambdabot can be upgraded somewhat
04:41:32 <DRMacIver> Java does that for some values of 'support' :)
04:41:36 <fax> oh really? :D
04:41:44 <skew> hs-plugins
04:41:46 <fax> WHat kind of stuff can you do to lambdabot?
04:41:57 <DRMacIver> Anyway, I'm off. Bye
04:42:04 <fax> DRMacIver: oh yeah thats true isnt it, theres stuff to load up bytecode
04:42:14 <beelsebob> o.O
04:42:20 <beelsebob> now the damn thing wont even connect
04:42:22 <DRMacIver> fax: Yeah. It's the unloading that's hard. :)
04:42:24 <skew> you can load up new code - but you have to handle migrating state to the new code yourself
04:42:26 <fax> hehe
04:42:37 <fax> (thankfully I havent had to deal with java load/unloding bytecode)
04:42:49 <fax> skew: how does it run it or compile it?
04:43:10 <Saizan> using hs-plugins
04:43:19 <Saizan> ?where plugins
04:43:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:43:33 <skew> heck, you can do that sort of thing with C if you try hard enough
04:43:39 <fax> ohhh
04:43:44 <fax> its just using C's dlopen?
04:43:52 <mux> dons: ping
04:43:53 <beelsebob> how do you clean a lambdabot build?
04:44:06 <skew> fax: yeah, with various wrapping around it
04:44:28 <skew> like, you can have it automatically run ghc, and check up types when it's loading cod
04:44:34 <skew> or code
04:44:38 <fax> neat :)
04:56:06 <mux> my LB is all broken :-(
04:56:15 <mux> even > doesn't work anymore
04:56:48 <beelsebob> mux: yep, mine is completely fuxored too
04:58:27 <beelsebob> okay...
04:58:32 <beelsebob> mine won't even work in offline mode now
04:58:37 <beelsebob> it won't even get as far as a prompt
04:58:50 <mux> okay, I could fix eval
04:59:15 <beelsebob> does lambdabot save a startup file somewhere?
04:59:15 <mux> changing Monad.Writer into Control.Monad.Writer in scripts/RunPlugs.hs
04:59:20 <mux> yes, online.rc
04:59:26 <mux> but that is broken too at the moment
04:59:27 <beelsebob> mux: no, elsewhere
04:59:41 <beelsebob> if I just run ./lambdabot it tries to join freenode
04:59:49 <beelsebob> even if I don't specify -e 'rc online.rc'
05:00:37 <hpaste>  beelsebob pasted "wtf lambdabot?" at http://hpaste.org/1827
05:01:04 <beelsebob> wth is going on with it?
05:01:20 <Botje> it's sulking.
05:01:28 <Botje> lure it out with a pretzel stick
05:01:40 <beelsebob> but I can't botsnack it until it loads!
05:03:07 <mux> actually, online.rc works for me now
05:03:16 <mux> @let still doesn't
05:03:17 <lambdabot>  Parse error
05:03:20 <mux> heh
05:03:58 <beelsebob> any idea what went wrong with my one there?
05:04:10 <mux> dunno, I don't use it in offline mode
05:04:22 <beelsebob> I get the same explosion if I try it in online mode
05:05:06 <mux> well I don't have this problem then
05:05:12 <hpaste>  beelsebob annotated "wtf lambdabot?" with "doom" at http://hpaste.org/1827#a1
05:05:26 <beelsebob> have I buggered up the online.rc file?
05:09:18 <Saizan> beelsebob: have you changed the command prefix?
05:09:33 <beelsebob> Saizan: yes, to '%'
05:09:44 <Saizan> i think there's a bug with it being hardcoded in the code that loads the .rc
05:09:55 <beelsebob> ah, I see
05:10:32 <Saizan> "i think" == "i recall sorear saying something like this"
05:10:49 <beelsebob> any idea what file loads the rc?
05:11:11 <Saizan> no, sorry :\
05:13:50 <fax> Saizan: lolol
05:36:43 <TomMD> how long has 'sh boot' been needed from a darcs copy of ghc?
05:36:50 <drigz> is it generally considered good or bad form to use things like the S combinator in programs?
05:37:16 <skew> S is a bit much
05:37:22 <skew> const is pretty common
05:37:36 <skew> the Reader monad is actually quite a lot like S
05:37:48 <skew> S = liftM2 ($)
05:41:03 <Saizan> which is ap
05:41:15 <drigz> @type ap
05:41:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:41:36 <drigz> @type ap (&&)
05:41:40 <lambdabot> (Bool -> Bool) -> Bool -> Bool
05:42:01 <drigz> @type liftM2 ($)
05:42:06 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m a -> m b
05:42:11 <drigz> @type liftM2 ($) (&&)
05:42:16 <lambdabot> (Bool -> Bool) -> Bool -> Bool
05:42:22 <Cheery> ?where ffi
05:42:22 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
05:42:36 <drigz> oh wait i got what the s combinator is wrong :s
05:44:11 <Saizan> what were you meaning then?:)
05:55:03 <erider> good morning
05:58:06 <EvilTerran> anyone about who knows their way around TH?
05:58:47 <EvilTerran> I'm trying to devise a function that can operate on n-tuples...
05:59:46 <fax> > (,,,,,,,,,) [1..10]
05:59:48 <lambdabot>        add an instance declaration for (Typeable7 ((,,,,,,,,,) [t] b c))
05:59:53 <fax> :(
06:01:03 <fax> > (,,,,,,,,) 1 2 3 4 5 6 7 8 9
06:01:13 <lambdabot>  (1,2,3,4,5,6,7,8,9)
06:01:18 <Saizan> EvilTerran: a function like?
06:01:58 <fax> > ((,),(,)) 1 2 3 4
06:02:05 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
06:02:24 <EvilTerran> ((a1,Int),(a2,Int),...,(aN,Int)) -> (a1 -> a2 -> ... -> aN -> b) -> (b, Int)
06:02:49 <EvilTerran> this function combines the Ints appropriately, and passes thru the aNs
06:03:08 <EvilTerran> (that second parameter could also be (a1,a2,...,aN) -> b)
06:03:49 <fax> > ((1,2),(3,4))
06:03:57 <lambdabot>  ((1,2),(3,4))
06:04:13 <fax> > (,) (,) (,) 1 2 3 4
06:04:20 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t3 -> t4 -> t'
06:04:33 <fax> > (,) (,) 1 2 (,) 3 4
06:04:37 <lambdabot>  Couldn't match expected type `t1
06:04:40 <fax> :(
06:04:47 <EvilTerran> @pl \a b c d -> ((a,b),(c,d))
06:04:47 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
06:04:56 <fax> > (,) ((,) 1 2) ((,) 3 4)
06:05:04 <lambdabot>  ((1,2),(3,4))
06:05:44 <fax> > zipWith (,) [1..] [10..]
06:05:55 <lambdabot>  [(1,10),(2,11),(3,12),(4,13),(5,14),(6,15),(7,16),(8,17),(9,18),(10,19),(11,...
06:06:19 <fax> :D
06:07:27 <EvilTerran> > unfoldr (\xs -> do x:y:rest <- return xs; return ((x,y), rest)) $ [1..20] -- =D
06:07:36 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
06:08:34 <fax> woaaa
06:08:38 <fax> what?
06:09:10 <fax> how can you make list [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[........ in haskell?
06:09:30 <EvilTerran> > unfoldr (\x:y:rest -> Just ((x,y), rest)) [1..] -- clearer (but wrong)
06:09:30 <lambdabot>  Parse error
06:09:39 <EvilTerran> > unfoldr (\(x:y:rest) -> Just ((x,y), rest)) [1..] -- clearer (but wrong)
06:09:42 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
06:09:58 <EvilTerran> fax, you can't; that would have an infinite type
06:10:00 <Cheery> I'm going to make opengl character renderer bindings for haskell
06:10:04 <fax> > unfoldr (\(x:y:z:rest) -> Just ((x,y,z), rest)) [1..]
06:10:19 <lambdabot>  [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18),(19,20,21),(22,23,...
06:10:37 <EvilTerran> > unfoldr (\(x:y:rest) -> Just ((x,y), rest)) [1..10] -- this is why it's wrong
06:10:47 <lambdabot>   Non-exhaustive patterns in lambda
06:10:53 <Saizan> EvilTerran: mac 2 = LamE [TupP [TupP [VarP (mkName "a1"),VarP (mkName "i1")],TupP [VarP (mkName "a1"),VarP (mkName "i1")]],VarP (mkName "f")] etc ...
06:11:27 <haskellnew> Please consider this : "data SS a b= SS a b"  then  instance Show (SS a b)  where  Show (SS a b) = Show (a,b)   if a,b is a type parameter then how do i pattern match or display  (SS 1 "hello")  to (1,"hello")
06:11:28 <Cheery> What module path should I create for it?
06:11:37 <EvilTerran> Saizan, i see... i'll see what I can do to interpret that... :)
06:11:58 <Saizan> EvilTerran: i'd use [| |] notation or Language.Haskell.TH.Helper to write that in a more reasonable way :)
06:12:23 <EvilTerran> I was trying to work out how to do it with [||]s
06:13:19 <Saizan> it's not easy because you can't define your macro inductively
06:13:44 <Saizan> unless you use nested 2-tuples instead of n-tuples
06:13:48 <EvilTerran> how would it even start?
06:13:58 <fax> :t [||]
06:14:00 <lambdabot> parse error on input `]'
06:19:35 <Saizan> mac n = return ([tup (zip (vars 'a' n) (vars 'i' n)),vr "f"] :-> tup [app (vr "f") (vars 'a' n), something_with_(vars 'i' n)]) <-- using Language.Haskell.TH.Helper
06:20:17 <Saizan> the return is there so you can splice mac
06:20:37 <Saizan> Language.Haskell.TH.Helper can be found in the derive package
06:20:40 <Saizan> ?where derive
06:20:41 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
06:21:26 <EvilTerran> hm
06:24:06 <EvilTerran> i'm getting horribly confused now O.o
06:24:19 <Saizan> mmh, by what?
06:24:35 <EvilTerran> i think i'm missing some vital piece of groundwork wrt understanding TH
06:25:12 <EvilTerran> tell me, how would one write, say, a TH function that took any n-tuple and returned n?
06:25:35 <Saizan> the lenght of the tuple?
06:25:38 <EvilTerran> yeah
06:25:58 <EvilTerran> i can roughly see how to do it with Data.Typable, i think, but that doesn't help with understanding TH
06:26:31 <Saizan> you can't write that, when you write a macro you can't see the runtime parameters, you have to generate a function that uses them
06:27:12 <EvilTerran> so if you wanted something that could operate on all n-tuples, you'd have to have an "n" parameter?
06:27:18 <Saizan> yeè
06:27:21 <EvilTerran> i see
06:27:43 <skew> an n parameter to the macro, that is
06:27:59 <EvilTerran> yes
06:28:10 <skew> perhaps you could do something tricky with typeclasses
06:28:10 <Cheery> how haskell finds out what libraries it needs to link at?
06:28:17 <skew> Cheery: ghc-pkg
06:29:12 <Cheery> uh, I mean in ffi
06:29:22 <skew> oh, ffi things you have to tell it about
06:29:38 <Cheery> how can I tell it the dynamic library to link at?
06:30:01 <Cheery> just ghc -lglc
06:30:02 <Cheery> ?
06:30:12 <skew> I think there are some options like that
06:31:20 <skew> at the very least you can get -L and -l options to gcc with -optc
06:31:26 <skew> ghc uses gcc for linking
06:36:40 <Cheery> you need to first do -optc?
06:44:38 <haskellnew> In case of "data SS a b= SS a b"  we can't use "instance Show (SS a b) where ...."   rt ?
06:44:59 <mauke> I think you can
06:45:28 <Saizan> you can but you probably need instance (Show a,Show b) => Show (SS a b) where ..
06:45:46 <Saizan> unless you are going to ignore the values inside your constructor
06:52:12 <haskellnew> hurray !, it works , thanks Saizan ,
06:52:14 <Cheery> I'd like to test the bindings I'm writing while I'm doing them
06:52:30 <Cheery> thought I don't know how do I do it without cabalising and installing that stuff
06:53:21 <Saizan> haskellnew: need an explanation of why?
06:53:25 <haskellnew> yes
06:53:33 <haskellnew> plz
06:54:25 <Saizan> well, writing your instance you have done something like show (SS a b) = "SS " ++ show a ++ show b, right?
06:54:37 <haskellnew> yes
06:54:45 <haskellnew> show (a,b)
06:55:07 <Saizan> to be able to use show on a and b you have to know that their types are instances of the Show class
06:55:20 <Saizan> ?type show -- you can see that from the type of show
06:55:23 <lambdabot> forall a. (Show a) => a -> String
06:56:46 <Saizan> and instance (Show a, Show b) => Show (SS a b), means exactly that this is an instance of Show for (SS a b) only if a and b instances Show
06:57:50 <Saizan> you are requesting a prerequisite to use this instance and so you are allowed to use what follow from it
07:01:11 <Saizan> it's just like adding a context to your function, only that here is not inferred
07:01:37 <Saizan> s/only/the only difference is/
07:02:42 <haskellnew> so it means that  a and b in (SS a b) a placeholder for type variable like Int,String  etc but we tell that this type variable also must be instance of Show
07:03:07 <mauke> it makes sense
07:03:10 <Saizan> yes
07:03:18 <mauke> how can you print (a,b) if a alone is not printable?
07:03:39 <Botje> (<CANNOT PRINT>, 42)
07:03:48 <Botje> that's not terribly helpful, of course.
07:04:01 <mauke> blargh lisp
07:04:14 <fax> is that a new type of lisp?
07:04:59 <Saizan> haskellnew: to be precise  a and b are type variables, Int and String are concrete types (or constant types maybe?:)
07:05:27 <mauke> (#<SYSTEM-FUNCTION CAR> . 42)
07:06:43 <Saizan> *type constants
07:07:38 <haskellnew> ok , i got it a and b can be another data types just like SS a b and these types must also be instance of Show
07:12:10 <haskellnew> thanks for the detailed explanations  :)  bye
07:13:45 <fourbissime> Hi there.
07:18:23 <nominolo> man .. building ghc 6.6.1 from source *really* takes a long time ..
07:18:55 <skew> why are you building it?
07:19:15 <nominolo> there's no binary for macosx
07:19:23 <nominolo> and my current seems broken
07:19:34 <skew> ah, that can take a while
07:20:42 <skew> You can build an unoptimized compiler and libraries a lot faster, if you were working on the compiler
07:20:56 <skew> make -j N helps, if you have an SMP system
07:21:22 <nominolo> yes, i have ghc head lying around.  but i want a workable, optimized compiler for regular work
07:21:37 <nominolo> and my binary seems to miss some opengl-related files
07:21:59 <nominolo> skew: yes, i tried -j with HEAD, but it had some weird error
07:22:10 <nominolo> oh
07:22:13 <nominolo> just finished
07:22:26 <skew> I get weird errors with HEAD whether or not I use -j
07:22:52 <skew> but the wierd ones with -j do seem like it might be trying to build libraries out of order and so on
07:24:11 <nominolo> yes, i didn't investigate further.  i was just trying associated types, and found a bug.
07:24:24 <nominolo> That got fixed recently, though.
07:35:16 <gkr> Is there any function that does "(\x y -> (x,y))" already defined in Haskell?
07:35:38 <joelr1> g'day
07:35:41 <ibid> @type uncurry
07:35:42 <mauke> @pl (\x y -> (x,y))
07:35:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:35:44 <lambdabot> (,)
07:35:49 <mauke> it's called (,)
07:35:54 <joelr1> bringert: trying to build with hope as a library now
07:36:07 <bringert> bringert: ok, let me know how it goes
07:36:13 <bringert> eh joelr1
07:36:43 <gkr> mauke what does @pl do?
07:36:43 <joelr1> bringert: question... do i make createdb part of my project?
07:36:46 <gkr> (thanks)
07:36:52 <mauke> gkr: it obfuscates code :-)
07:36:56 <joelr1> bringert: i guess so since it imports Config.hs
07:36:59 <mauke> by removing all named arguments
07:37:26 <bringert> joelr1: yes
07:38:43 <joelr1> bringert: Hope.hs (top) seems to import Config.hs as well. this is the one that has hopeMain. what do i do about it?
07:39:05 <bringert> huh
07:39:09 <fax> what is @pl?
07:39:14 <mauke> @help pl
07:39:15 <lambdabot> pointless <expr>. Play with pointfree code.
07:39:19 <bringert> joelr1: mine doesn't
07:39:37 <joelr1> bringert: oh, i'm just trying to remove old bits of hope. let me go the other way.
07:45:13 <Saizan> "__utma=172229864.2068985467.1179004129.1179004129.1179004129.1; __utmc=172229864; __utmz=172229864.1179004129.1.1.utmccn=(direct)|utmcsr=(direct)|utmcmd=(none)" <-- given this cookie string, what's the right way to parse __utmz ? just ("__utmz",<rest>) ?
07:46:16 <mauke> my %data = $str =~ /(\w+)=([^;]*)/g; my $wanted = $data{__utmz};
07:46:37 <EvilTerran> gkr, @pl re-expresses the function you give it in a form with no named arguments.
07:48:08 <EvilTerran> @paste
07:48:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:49:12 <gkr> Interp> (: []) ((,) 5 6)
07:49:13 <gkr> [(5,6)]
07:49:13 <gkr> Interp> ((: []) . (,)) 5 6
07:49:13 <gkr> ERROR - Type error in application
07:49:17 <gkr> Why :-(
07:49:37 <mauke> because (f . g) x y == (f (g x)) y == f (g x) y
07:49:54 <gkr> Oh, right.
07:50:02 <mauke> [(,) 5] 6
07:50:04 <gkr> Grr.
07:50:11 <mauke> add more .
07:50:26 <mauke> @pl \x y -> f (g x y)
07:50:26 <lambdabot> (f .) . g
07:51:15 <gkr> Thanks :-D
07:51:29 <gkr> This @pl thing is cool.
07:52:30 <mauke> huhu, wait until someone gives it code that uses arguments non-linearly
07:53:37 <EvilTerran> @pl \ ((a,b),(c,d)) -> ((d,c),(a,b))
07:53:38 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . flip (flip . ((,) .) . flip (,))) .) . (,)))
07:53:56 <mauke> ok, that's also pretty bad
07:54:17 <EvilTerran> you know something's not good when you see "flip flip"
07:54:43 <mauke> @pl \(a,b) -> ((b,a),(a,b))
07:54:43 <lambdabot> uncurry (ap (ap . ((,) .) . flip (,)) (,))
07:54:50 <skew> swap (a,b) = (b,a) would clean that up a lot
07:54:58 <skew> the first, at least
07:55:08 <skew> swap &&& swap >>> swap
07:55:08 <mauke> @. unpl pl \ ((a,b),(c,d)) -> ((d,c),(a,b))
07:55:09 <lambdabot> uncurry (uncurry (\ ad f -> (\ p v -> ((,)) ((,) v (fst p)) (((,)) ad f)) >>= \ ai -> snd >>= \ ah -> return (ai ah)))
07:56:10 <EvilTerran> > let swap = uncurry (flip (,)) in swap . (swap *** swap) $ ((1,2),(3,4))
07:56:16 <lambdabot>  ((4,3),(2,1))
07:56:51 <EvilTerran>  /\ is probably the defn i'd use
07:56:54 <roconnor> @pl flip flip
07:56:54 <lambdabot> flip flip
07:56:59 <roconnor> @pl flip  . flip
07:56:59 <lambdabot> id
07:57:10 <roconnor> @type flip flip
07:57:10 <EvilTerran> maybe use (<<<) in place of (.), but basically that
07:57:10 <Saizan> @unpl flip flip
07:57:25 <lambdabot> thread killed
07:57:26 <lambdabot> (\ b c f -> c f b)
07:57:34 <roconnor> hey
07:57:41 <roconnor> why was my thread killed?
07:57:54 <roconnor> @karma- lambdabot
07:57:55 <lambdabot> lambdabot's karma lowered to 48.
07:58:20 <mauke> @type flip flip
07:58:24 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:58:27 <Saizan> it's a though world for the threads
07:58:35 <roconnor> @karma+ lambdabot
07:58:35 <lambdabot> lambdabot's karma raised to 49.
07:58:39 <mauke> @. djinn type flip flip
07:58:55 <lambdabot> -- f cannot be realized.
07:59:06 <joelr1> dcoutts: thank you!
07:59:06 <skew> @type flip flip
07:59:06 <mauke> what
07:59:12 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:59:24 <skew> @djinn (a -> b -> c) -> a -> c
07:59:24 <lambdabot> -- f cannot be realized.
07:59:24 <roconnor> @djinn b -> (a -> b -> c) -> a -> c
07:59:24 <dcoutts> joelr1: np
07:59:25 <lambdabot> f a b c = b c a
07:59:30 <mux> I think djinn doesn't grok the forall
07:59:55 <mauke> @djinn forall a b. a -> (a -> b) -> b
07:59:56 <lambdabot> f a b = b a
08:00:03 <mux> hmmm
08:00:04 <roconnor> flip flip seems like part of a cypher
08:00:14 <dcoutts> joelr1: btw, the ghc users guide is actually fairly comprehensive, it'll usually get you answers quicker than asking someone else (who afterall is just going to look it up in the ghc users guide)
08:00:30 <roconnor> @pl (flip flip) . (flip flip) . (flip flip)
08:00:30 <lambdabot> flip flip . flip flip . flip flip
08:00:45 <opqdonut> haha
08:00:48 <roconnor> oh wait, compose doesn't work like that
08:00:53 <mauke> @pl \flip -> (flip flip) . (flip flip) . (flip flip)
08:00:54 <lambdabot> ap ((.) . join id) (ap ((.) . join id) (join id))
08:01:07 <mauke> join id?
08:01:18 <roconnor> @type join id
08:01:20 <mauke> you must be kidding me
08:01:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
08:01:21 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:01:30 <opqdonut> ?t join
08:01:30 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:01:35 <opqdonut> :t join
08:01:37 <opqdonut> gah
08:01:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:01:51 <mauke> join id = \f -> f f
08:01:58 <joelr1> dcoutts: mea culpa. this is what i did, in fact, before you answered.
08:02:08 <joelr1> dcoutts: but after i asked
08:02:14 <dcoutts> joelr1: :-)
08:02:23 <roconnor> mauke: that doesn't seem type sound
08:02:51 <opqdonut> ?pl \f -> f f
08:02:51 <lambdabot> join id
08:02:52 <joelr1> dcoutts: i usually leave type signatures out, though, unless i'm trying to troubleshoot an error or need to constraint something
08:02:54 <roconnor> @type b -> (a -> b -> c) -> a -> c
08:03:08 <opqdonut> roconnor: what are you trying to do?
08:03:09 <lambdabot> parse error on input `->'
08:03:14 <dcoutts> joelr1: I just routinely think in types.
08:03:15 <roconnor> @type ap ((.) . join id) (ap ((.) . join id) (join id))
08:03:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b -> c
08:03:20 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:03:37 <joelr1> dcoutts: :-)
08:03:42 <roconnor> @ type (flip flip) . (flip flip) . (flip flip)
08:03:46 <roconnor> @type (flip flip) . (flip flip) . (flip flip)
08:03:58 <lambdabot> forall a c a1 c1 a2 b c2. -> (a -> ((a1 -> ((a2 -> b -> c2) -> a2 -> c2) -> c1) -> a1 -> c1) -> c) -> a -> c
08:04:07 <mauke> wtf
08:04:09 <roconnor> @type \flip -> (flip flip) . (flip flip) . (flip flip)
08:04:16 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> b -> c
08:04:16 <lambdabot>     Probable cause: `flip' is applied to too many arguments
08:04:17 <mauke> why does this type start with ->?
08:04:20 <roconnor> oh yeah
08:04:26 <roconnor> that totally makes sense now
08:04:33 <hpaste>  EvilTerran pasted "template haskell -- it works, but how's my style?" at http://hpaste.org/1828
08:04:58 <skew> EvilTerran: I think that's about as good as it gets
08:05:18 <arjanoosting> Hmm, the link is not updated in http://alioth.debian.org/mail/?group_id=31040
08:05:19 <lambdabot> Title: Alioth: pkg-haskell: Mailing Lists for pkg-haskell
08:05:56 <joelr1> i used to consider TH evil
08:06:07 <joelr1> until I looked at camlp4
08:06:28 <EvilTerran> is there something [||]-esque for patterns? i couldn't find such a thing
08:06:32 <mauke> haha, do you know perl source filters?
08:06:35 <joelr1> i think the TH syntax is more verbose but also easier to understand
08:06:47 <skew> EvilTerran: no, that's one of the most annoying things
08:06:57 <EvilTerran> ah, perl filters. "be careful with these, the magic's not quite as clever as it first appears to be"
08:07:25 <EvilTerran> they're in the C preprocessor camp of macrolangauge
08:07:36 <mauke> no, source filters are one level below cpp
08:07:38 <skew> patterns are just hard to play with, in general
08:07:40 <EvilTerran> while TH seems to be very much in the lisp-macro camp
08:07:52 <skew> you can't abstract over them in normal code either
08:07:53 <mauke> cpp works on a stream of tokens
08:07:59 <mauke> perl source filters are just string processing
08:08:00 <EvilTerran> ahh. oh lord, that's even worse
08:08:20 <EvilTerran> i hear perl6 will have parse tree macros
08:08:29 <EvilTerran> (along with every other feature under the sun)
08:08:36 <mauke> I hear perl6 will have *
08:08:58 <skew> and * -> * ?
08:10:07 <EvilTerran> i've got mixed feelings about perl6. i appreciate that they seem to be removing the ambiguity from the syntax, but they're introducing an awful lot of fluff
08:10:44 <EvilTerran> I'm tempted to devise a minimalist, rigorously-defined subset of perl
08:10:52 <mauke> huhu, good luck
08:10:57 <EvilTerran> ...and then implement it. all when i can be bothered.
08:11:09 <EvilTerran> (not really a subset, just something that looks mostly like it)
08:12:28 * wolverian thinks the perl6 spec isn't that long
08:12:49 <olsner> since the empty set is a subset of any set, any language is an augmented subset of any other language
08:12:58 <olsner> "Haskell is an augmented subset of Perl6"
08:13:28 <skew> just start the file with Inline::GHC(
08:13:34 <mux> mmm, fgl-5.4 lacks a Setup.hs file
08:13:37 <beelsebob> olsner: must be a superset -- otherwise the Perl 6 interpretter couldn't be written in Haskell
08:13:37 <joelr1> bringert: it works just fine, thanks!
08:14:03 <olsner> a superset is also an augmented subset :P
08:14:08 <EvilTerran> i think, if you can have the same file with different semantics in two languages, then they can't be considered true super/subsets
08:14:11 <mauke> olsner: http://rafb.net/p/cDHODn57.html
08:14:12 <lambdabot> Title: Nopaste - No description
08:14:35 <bringert> joelr1: great! I'm working on docs and build system now. I've changed the version number to start with 0 now, so if you upgrade, make sure to nuke the old version first.
08:15:15 <joelr1> bringert: just as i adopted the date-version system :)
08:16:21 <bringert> joelr1: it's still date-based, just that it has a leading 0., to allow switching to major.minor later. I want to avoid the silly 3000.x.x version numbers some of my libs have.
08:16:44 <joelr1> bringert: right
08:16:51 <haskellnew> i defined  data Bobj= BI Int | BS String | BL [Bobj]  and
08:17:05 <joelr1> bringert: got a question for you re: forms and their action url
08:17:10 <hpaste>  joelr1 pasted "hope form" at http://hpaste.org/1829
08:17:16 <joelr1> bringert: ^^^
08:17:25 <haskellnew> func :: [Bobj]
08:17:41 <haskellnew> func = [BI 1,BS "2",BL [BS "hmm"]]
08:17:45 <joelr1> bringert: in this scenario clicking the translate button downloads some executable under the name of Unknown :D
08:19:03 <joelr1> bringert: so how do i make it go to the ["topdog", "translate"] resource that i defined in my module?
08:19:39 <bringert> joelr1: the argument to resform is the path to send it to
08:19:51 <bringert> return $ resform ["topdog", "translate"]  << formContents fs cs
08:20:01 <joelr1> bringert: gotcha!
08:20:51 <joelr1> bringert: one more question re: returning html...
08:21:18 <joelr1> bringert: i'm sending this to simpleBox: morpherResultForm r = return $ pre << "Some code"
08:21:45 <joelr1> bringert: my intent is to plug in actual C# code (string) in place of "Some Code". does that look right to you?
08:22:17 <bringert> joelr1: I think it looks right
08:22:39 <joelr1> bringert: awesome!
08:30:21 <hpaste>  joelr1 annotated "hope form" with "any reason for the warning?" at http://hpaste.org/1829#a1
08:30:35 <joelr1> folks any idea why ghc is giving me this warning?
08:30:44 <bringert> joelr1: Text.XHtml exports a function called p
08:30:52 <joelr1> bringert: ah!
08:31:11 <joelr1> that certainly explains it
08:37:06 <joelr1> bringert: have you seen the app offering you to download a binary when you do something?
08:37:26 <Cheery> hmm... say, if you have C procedures like: geti, getf, getfv, (glc has this kind of commands).. what's the most straightforward way of doing just one 'get'?
08:37:33 <bringert> joelr1: yes, can't remember why though
08:37:42 <joelr1> hmm...
08:37:43 <bringert> joelr1: check the HTTP response headers
08:38:05 <mauke> what's a fv?
08:38:26 <Cheery> an array of floats
08:38:45 <joelr1> bringert: good idea /headers/
08:38:50 <mauke> class C a where get :: a
08:38:58 <mauke> instance C Int where get = geti
08:39:25 <joelr1> bringert: how do you check the headers?
08:39:39 <joelr1> bringert: can you do it using curl or wget?
08:40:04 <bringert> joelr1: curl -D/dev/stderr
08:40:06 <bringert> I think
08:40:59 <Cheery> mauke: is that really the simplest way?
08:41:06 <joelr1> bringert: that just dumps the 5Mb binary to stderr. i think it's offering me to download self
08:41:11 <joelr1> itself
08:41:32 <bringert> oh, web server setup problem?
08:41:56 <nominolo> bringert: any opinions on this one?  http://www.dtek.chalmers.se/~tox/site/http.php4
08:41:58 <joelr1> bringert: it didn't exist before! before i did something in my module. i think
08:41:58 <lambdabot> Title: Jonas - Haskell HTTP Library Improvement
08:42:05 <Cheery> can't you just do something like: instance C GLint where foreign import ccall unsafe "glcGeti" get ?
08:42:28 <EvilTerran> TH seems to not like [| \f -> $(foldl appE f args) |]... gives a stage error. is this a mistake on my part or a limitation of the system?
08:43:00 <mauke> Cheery: try it :-)
08:43:03 <bringert> nominolo: looks great
08:43:10 <hpaste>  joelr1 annotated "hope form" with "my handler chain" at http://hpaste.org/1829#a2
08:43:24 <joelr1> bringert: i have an extremely simple chain of handlers ^^^
08:44:12 <joelr1> bringert: and i'm trying to hit http://localhost which would be the top of the app since everything that does not exist is redirected to the hope app
08:44:51 <joelr1> bringert: this used to happen when my form handler was "" and i tried to submit the form
08:46:38 <joelr1> bringert: indeed, must be my bad since it only happens when http://localhost is hit. which also happens when you have a form with not submit link
08:48:48 <Cheery> mauke: ok, I'll try, thought not now
08:52:30 <joelr1> bringert: hehe, it's funny. my rewrite rules are set up such that if the file is not found it redirects to dispatch.fcgi (hope app). but when going to / it's rewritten as /dispatch.fcgi which is found and thus returned!
09:21:00 <erider> hi all
09:21:17 <ndm> hi erider
09:21:21 <dcoutts> @yarr!
09:21:22 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
09:24:00 <ehird`> @yarrrrr
09:24:01 <lambdabot> Unknown command, try @list
09:24:06 <ehird`> @yarr rrrrrr
09:24:06 <lambdabot> Avast!
09:30:19 <opqdonut> @. elite yarr
09:30:19 <lambdabot> z|-|iveR M3 7I/\/\bERz!
09:30:26 <ihope> :-)
09:30:38 <mauke> @. elite keal
09:30:38 <lambdabot> i tHiNx I kNoW WHA7 code d03s Bu+ c0de |0oxz0rz t0 zi/\/\P|E TO a(Tua|1Y d0 it
09:30:39 <Cheery> @arr
09:30:40 <lambdabot> Yo ho ho, and a bottle of rum!
09:31:03 <ihope> I got lost as "|0oxz0rz".
09:31:20 <Cheery> I've always wondered what LOLCATS means
09:31:32 <ihope> I think I know what code does but code looks too simple to actually do it?
09:31:39 <mauke> yes
09:32:50 <kolmodin> @. elite quote
09:32:51 <lambdabot> Dariu$ sAyS: \/\/e|| prophilING D0eS 4dD A bit 0ph REf|3c7IOn, bu7 iT sHOULd |-|4\/E +h3 90oD sEnz3 nOt 7o0 go n3AR The baRB3d wIr3 F3nc3s AnD 4rMEd 9UaRDs.
09:33:00 <kolmodin> um...
09:40:34 <yaxu> > toLower 'ü'
09:40:34 <lambdabot>  Improperly terminated character constant
09:42:09 <yaxu> hmf
09:43:50 <yaxu> does toLower not work with umlauts?
09:44:09 <davidL> > chr 'ü'
09:44:09 <lambdabot>  Improperly terminated character constant
09:44:13 <skew> it should, I think it's the parser that doesn't like them
09:44:16 <ndm> yaxu: its not toLower, its the character constant itself
09:44:22 <fourbissime> Hi there. I'm struggling with this monad thing. I have a very concrete case I will explain. If anyone can give me his/her insight on the subject, I would apreciate.
09:44:28 <skew> what's the unicode?
09:44:59 <yaxu> the same as the ascii
09:45:10 <yaxu> for utf8
09:45:11 <Heffalump> fourbissime: I'll try.
09:45:20 <fourbissime> I would like to create a module in order to store/retrieve some informations. the idea is simply to use a Data.Map Int String for example.
09:45:24 <skew> umlauts are not ASCII
09:45:30 <yaxu> ah
09:45:32 <yaxu> ok
09:45:40 <skew> it's just 7-bit ascii that's the same in UTF-8
09:45:53 <skew> Data.Char really sounds like it's supposed to do all the right unicode stuff
09:45:59 <yaxu> ndm: i'm getting a problem with ghc as well, although not that problem
09:46:10 <yaxu> skew: ok i'll look into converting to unicode
09:46:10 <fourbissime> What I wonder is, would it be possible to make the module behave in a way you never have to access directly the data structure. for example, a function insert :: Int -> String -> IO ()
09:46:46 <Heffalump> so you want the same data structure to be used for all invocations of things in the module?
09:46:58 <skew> fourbissime: you should probably make some type to work with, otherwise it gets tricky when you have threads and stuff like that
09:47:11 <skew> even if it's just a totally opaque handle
09:47:25 <fourbissime> do you mean, for Int and String ?
09:47:48 <skew> like, insert :: MyType -> Int -> String ()
09:47:53 <skew> newMyThingy :: IO MyType
09:47:55 <skew> etc.
09:48:07 <skew> like you pass Handle to all the h* IO functions
09:48:21 <skew> but you can't pattern match a handle and look in it
09:48:54 <hpaste>  fourbissime pasted "(no title)" at http://hpaste.org/1831
09:49:45 <skew> how about adding another argument to everything but load, and making the result of load IO Dict
09:50:02 <skew> otherwise you will be sad if you want to open several of these things
09:50:32 <yaxu> hm, umlauts are in latin-1 so there shouldn't be any unicode issues
09:50:43 <Heffalump> and it's tricky in implementation terms because Haskell doesn't really support truly global variables with a globally accessible name.
09:50:50 <skew> yaxu: are you sure you and lambdabox are both using latin-1?
09:50:55 <Heffalump> there are hacks you can use but they are not pleasant
09:50:59 <matthew-_> is there any way to get ghc to tell me what it's trying to do in terms of deducing instances during compilation?
09:51:19 <skew> check $LANG
09:51:23 <Heffalump> global mutable variables, that is
09:51:25 <fourbissime> skew: true. But here the point is also to understand how I can avoid threading such information in every call.
09:51:48 <skew> oh, if you want to hide in the monad then you'd use State
09:51:58 <skew> like StateT Dict IO
09:52:04 <skew> instead of IO everywhere
09:52:16 <yaxu> skew: i'd have thought we'd both be using either utf-8 or latin-1, which have the same umlauts afaict
09:53:06 <skew> try making an umlaut with chr
09:53:30 <skew> I think there's something silly with the ecoding of the standard IO functions
09:53:59 <fourbissime> skew: ok, StateT. But I still don't grasp how to use it in my code.
09:54:06 <fourbissime> (sorry for the lame questions)
09:57:07 <eumenides> you state <- get your state, change it somehow, then put new_state
09:57:26 <skew> and lift (some_IO_expression)
09:58:40 * ndm thinks pure languages suck as implementation back ends
09:58:58 <yaxu> > Char.chr(246)
09:58:58 <ddarius> ndm: Once we get purely functional processors we'll be set!
09:59:02 <lambdabot>  '\246'
09:59:14 <skew> ndm: as compilation targets?
09:59:20 <yaxu> > Char.toLower Char.chr(246)
09:59:27 <lambdabot>  Couldn't match expected type `Char'
09:59:27 <skew> I thought that was called "denotational semantics"
10:00:01 <yaxu> > Char.toLower $ Char.chr(246)
10:00:10 <eumenides> i've found haskell to be a very good imperative language, except for the lack of global variables (but there's some magic to make those too)
10:00:11 <lambdabot>  '\246'
10:00:22 <ndm> skew: yes
10:00:29 <sanka> quit
10:01:07 <skew> what are you trying to compile?
10:01:51 <ndm> skew: Yhc Core, but i have to do it at a very low level - essentially i'm trying to write hPutChar without any data structures other than Int, and no seq
10:01:53 <yaxu> > putStrLn $ (Char.chr 246):[]
10:02:06 <lambdabot>  <IO ()>
10:02:29 <ddarius> ndm: Things like administrative normal form are very close to SSA.
10:02:49 <ndm> ddarius: i'm trying to compile at the Core level, i.e. haskell-like
10:02:50 <yaxu> > ((Char.chr 246):[])
10:02:53 <skew> you need a primitive operation in there somewhere
10:03:01 <lambdabot>  "\246"
10:03:12 <ndm> skew: yes, but after you put the primitive operation in, you find the Haskell lazily doesn't bother doing it...
10:03:44 <skew> that's why you thread the "world"
10:04:48 <ddarius> Or you could use CPS, which is also very close to SSA.
10:04:48 <skew> and perhaps mark the primitive strict in it - don't think that's even necessary, though
10:05:35 <ndm> yes, the problem is that Yhc threads a world, the optimiser breaks the threading, and i'm left with something i know has a world thread, but can't tell the compiler about
10:05:48 <ndm> its worse for something like hPutChar - especially when i don't have either IO or ()
10:05:48 <skew> why does the optimizer break it?
10:05:53 <skew> how does the optimizer break it?
10:06:08 <ndm> ddarius: yeah, cps is the most likely solution, but may blow some of the optimisers gains
10:06:23 <ndm> skew: the optimiser does some very crazy things,  it breaks everything
10:06:43 <skew> say you have \w -> let w2 = putChar w 'c'; (c,w3) = getChar w2 in (ord c, w3))
10:07:12 <skew> it should't be able to mess with the world threading, if those primitives are abstract
10:07:19 <skew> unless it's doing unsound optimizations
10:07:34 <ndm> it does mess with everything
10:07:38 <ndm> and the world isn't quite like that
10:08:07 <skew> why not? That's more or less the only way a world works
10:08:09 <ndm> plus it means putChar/getChar have to be strict on the world, and the world doesn't exist by this stage
10:08:22 <skew> you have to chain it through everything to get data dependencies to order stuff
10:08:39 <ndm> you can do it other ways, i.e. data IO a = IO a, then have >> do the magic
10:08:50 <ndm> and ensuring primitives return IO <value> at the same time
10:08:55 <dcoutts_> hmm
10:08:56 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
10:09:01 <skew> sure, but that doesn't involve a world at all
10:09:14 <ndm> skew: but it has to when you hit the GHC target
10:09:26 <mux> do you guys use c2hs when you have to write bindings that involve C enums?
10:09:29 <skew> oh, you're making core?
10:09:37 <dcoutts_> mux: yes.
10:09:55 <mux> dcoutts_: okay, I guess I need to familiarize myself with c2hs then :-)
10:10:03 <mux> it chokes on my header files
10:10:17 <ndm> skew: very much so
10:10:23 <dcoutts_> mux: use latest darcs c2hs, it doesn't choke on anything (or I want to hear about it)
10:10:34 <mux> dcoutts_: is there some good c2hs doc? I've only found very limited tutos and such
10:10:35 <dcoutts_> mux: it's less good for 'enums' defined with CPP macros, but for C enums it's fine.
10:10:38 <skew> well, if you've kept the ordering somehow you should be able to reestablish it
10:10:45 <mux> dcoutts_: no, I really mean enums
10:11:01 <dcoutts_> mux: there's the manual on the c2hs site.
10:11:11 <mux> the manual I've just read
10:11:15 <dcoutts_> ok
10:11:17 <mux> maybe two times :-) it doesn't contain much
10:11:20 <dcoutts_> that explains enums
10:11:29 <mux> well it explains {#enum yes
10:11:34 <dcoutts_> right
10:11:38 <ndm> skew: not a chance! its a really crazy optimisation
10:11:45 <mux> I'm already using (or trying to use) that
10:12:00 * mux fetches c2hs HEAD
10:12:04 <dcoutts_> mux: if you want an example, see cairo
10:12:13 <mux> dcoutts_: funny, I've been reading that too :-)
10:12:16 <skew> ndm: I mean if you've kept sequencing with IO and >>, you should be able to turn that into explicit world threading
10:12:23 <dcoutts_> mux: heh heh :-)
10:12:38 <dcoutts_> mux: sounds like you're doing just the right things then :-)
10:12:39 <ndm> skew: it does things to >> and IO, removing the IO data type entirely, and blasting >> into little pieces
10:12:39 <skew> ndm: and if you don't have any visibile thing representing ordering, how are you sure the optimizer doesn't break the order of IO operations?
10:12:54 <mux> dcoutts_: but if my c2hs chokes on the header, there is no quick workaround for it?
10:13:04 <ndm> skew: its safe with respect to that, the IO isn't safe with respect to sharing, but my compiler is aware of that
10:13:06 <mux> things I could write myself, or something?
10:13:20 <dcoutts_> mux: the darcs version really really shouldn't choke on anything that gcc can compile
10:13:37 <skew> ndm: what sharing breaks? like running IO actions several times?
10:13:41 <dcoutts_> mux: I've parsed the whole kernel and every core package on my system with it.
10:13:42 <mux> dcoutts_: ok, well darcs get running
10:13:43 <Botje> mux: you could partially run it through the preprocessor.
10:13:54 <EvilTerran> if your header's, say, MSVC, you may need to preprocess it a bit manually
10:13:57 <dcoutts_> Botje: c2hs uses cpp anyway.
10:14:06 <Botje> oh, nm then :)
10:14:13 <ndm> skew: IO (get_char h) >> IO (get_char h) can be commoned up
10:14:15 <mux> bah, now I need alex
10:14:25 <skew> ndm: given optimized code and two indicated primitive IO operations, could you way which happens first?
10:14:31 * mux portinstall's it
10:14:44 <ndm> skew: i think so, yes
10:15:03 <skew> ndm: if so you ought to be able to introduce a new world, threaded in that order (splitting at ifs and stuff)
10:16:07 <ndm> skew: i doubt it, it really is very confusing optimisation
10:16:29 <skew> can you put an ordering on your primitive operations, or not?
10:17:00 <skew> however the optimizer has messed things up you just care about the results, right?
10:17:29 <skew> it's not like you have to run the optimizer again halfway through translating to GHC Core, is it?
10:17:33 <mux> dcoutts_: ETA on next c2hs release? I'll try to update the FreeBSD port
10:17:44 <ndm> true, there is an order, but i doubt it could be reconstructed automatically
10:18:03 <dcoutts_> mux: no certain date yet, there are a few fixes needed yet. Not all the tests are working.
10:18:06 <mux> omg, we're still at 0.13.6
10:18:06 <skew> Ah, well in that case why do you think the optimizier doesn't break the order?
10:18:13 * mux blushes
10:18:33 <ndm> because its well designed :)
10:18:35 <skew> and whatever that reason is, perhaps there's some way to preserve it
10:18:48 <ndm> the optimiser is *super mega brain blowing*
10:19:15 <skew> tag primitives with a unique number and have a graph  on the side listing their order, or something like that
10:19:21 <mux> reading the Core language is like being fed into the Total Perspective Vortex
10:20:01 <skew> Totally, the universe exists for my benefit ;)
10:20:46 <skew> this is the YHC optimizer you're talking about, right?
10:20:52 <ndm> yeah
10:21:00 <ndm> i'll see if i can fake things with universal cases etc
10:21:03 <mux> so YHC is on its way to become an optimizing compiler?
10:21:07 <skew> universal cases?
10:21:09 <mux> that sounds cool
10:21:13 <ndm> case x of _ -> ...
10:21:15 <Heffalump> grmph. Why isn't everywhere as helpful as #haskell?
10:21:22 <ndm> in Core its somewhat like seq, but not quite
10:21:33 <skew> Heffalump: grumpy from late nights debugging?
10:21:40 <Syzygy-> Heffalump: Because most other places have a higher density of idiots?
10:21:46 <ddarius> Heffalump: Everywhere else people are bitter at the tools they have to use?
10:21:52 <ndm> mux: Yhc has an optimiser inside it, and has for ages, we're just one of the few (if not hte only) optimising compiler where the output DOESN'T run through the optimiser
10:22:02 <kombinator> dcoutts_: hello
10:22:07 <skew> ndm: huh?
10:22:21 <ndm> we are wanting a super-optimiser, which does optimisation to beat GHC by lots
10:22:38 * Heffalump goes with all of the above :-)
10:22:41 <beelsebob> skew: I believe he means that it optimises the tree, not the resulting byte code
10:22:46 <skew> ndm: what do you mean the output doesn't run through the optimizer? you don't optimize by default?
10:22:54 <ndm> skew: we have an optimiser, a standard simplification/inlining pass one, which is in the source tree
10:23:07 <dcoutts_> kombinator: hia
10:23:08 <Heffalump> heh. And as if by magic, just after I said the above:
10:23:09 <ndm> skew: we don't optimise _ever_ - we can't
10:23:14 <kombinator> dcoutts_: long time ago we you told me about some high-level interface laying in gtk2hs codebase but I can't seem to find it ATM
10:23:16 <Heffalump> >> [18:21] * ben_goodger checks that BOFH mode has not
10:23:16 <Heffalump> >> gone to "off" accidentally [18:21] <ben_goodger>
10:23:16 <Heffalump> >> nope, we're good.
10:23:43 <dcoutts_> kombinator: hmm, can you be more specific? what are you looking for?
10:23:47 <ndm> Yhc has PosLambda and Yhc.Core, Yhc.Core has an optimiser, we can convert PosLambda to Yhc.Core, and PosLambda to ByteCode
10:23:50 <skew> beelsebob: that's also how GHC does it - well, maybe it optimizies the results too
10:24:01 <ndm> which means once we've optimised, we can't convert to bytecode output...
10:24:14 <ndm> i.e. an optimising compiler which can't optimise anything
10:24:19 <beelsebob> hehe
10:24:22 <kombinator> dcoutts_: well, I'm experimenting with making a high-level GUI toolkit
10:24:22 <beelsebob> that's silly
10:24:33 <beelsebob> why can Yhc.core not be output to bytecode
10:24:37 <kombinator> dcoutts_: and any code that claims to be high-level is of interest;)
10:24:41 <ddarius> So as I was going to say, Yhc has on optimizer that is there to just look pretty.
10:24:42 <ndm> beelsebob: history, past, things
10:24:45 <dcoutts_> kombinator: what would you count as high level? We generally don't consider Gtk2Hs as high level, but sort of mid-level.
10:25:07 <skew> Heffalump: what channel is that?
10:25:14 <mux> dcoutts_: woot, works. cheers!
10:25:15 <dcoutts_> kombinator: someone has some arrow based stuff that's implemented on Gtk2Hs, ndm has something too.
10:25:20 <dcoutts_> mux: great.
10:25:22 <kombinator> dcoutts_: well, gtk2hs is an imperative callback soup;)
10:25:26 <ndm> ddarius: pretty much, i think it might get turned on for the javascript back end
10:25:34 <ndm> kombinator: have you seen PropLang?
10:25:34 <Heffalump> skew: #debian on OFTC.
10:25:37 <ndm> @where proplang
10:25:37 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
10:25:42 <kombinator> ndm: no
10:25:50 <mux> gtk2hs has some parts I would call rather high-level
10:25:56 <skew> ndm: so what fancy things are you doing to optimize?
10:25:57 <ndm> kombinator: a high level GUI toolkit based on Gtk2hs
10:26:01 <dcoutts_> kombinator: right, we don't abstract state management, just memory management and provide type safety etc etc.
10:26:04 <mux> the new interface to the MVC models of TreeView and others is quite high level
10:26:09 <skew> ndm: sounds like GHC is pretty fancy already
10:26:17 <mux> the rest I would indeed call mid-level
10:26:22 <kombinator> ndm: that's interesting
10:26:27 <ndm> skew: everything, its a one pass, confluent, deforesting/specialising optimiser
10:26:48 <ndm> skew: i'll tell you more once i beat GHC into the ground on the current benchmark (or if...)
10:26:59 <kombinator> I've implemented a base for an arrow-based toolkit sitting on gtk2hs
10:27:13 <ndm> i wanted a monadic based one
10:27:14 <kombinator> and I'm going to experiment with it
10:27:17 <dcoutts_> kombinator: cool
10:27:20 <ndm> with properties and update paths between them
10:27:33 <ndm> in practice, i find it really natural and easy to use - but that may be because i designed it
10:27:57 <mux> that sure is likely to help a lot :-P
10:28:12 <dcoutts_> kombinator: eventually you'll want to generate your high level stuff, so it can cover the wide range of widgets, properties, signals that Gtk2Hs covers. We've got the infrastructure to be able to do that.
10:28:44 <ddarius> e += putStrLn "event fired" C# inspired?
10:28:51 <kombinator> dcoutts_: however, connecting gtk widgets to my toolkit is quite hairy
10:29:06 <kombinator> dcoutts_: there is no 1:1 equivalence
10:29:10 <mux> dcoutts_: I suppose more high-level GUI toolkits aiming at being declarative and such use Gtk2Hs as a backend?
10:29:17 <dcoutts_> kombinator: right.
10:29:26 <kombinator> dcoutts_: I need to use multiple callbacks for one thing
10:29:44 <dcoutts_> mux: we aim to be a platform for high level toolkits.
10:30:01 <dcoutts_> ie we'll deal with the lower level issues
10:30:04 <ndm> dcoutts_ it was very easy for me to layer mine over yours
10:30:05 * mux nods
10:30:26 <mux> I really like gtk2hs
10:30:46 <dcoutts_> the main thing I think we're lacking for high level layers is the notification of property changes
10:30:51 <kombinator> ndm: aren't you afraid that a monadic toolkit would be too slow and impossible to optimize?
10:30:53 <mux> it's as fast and easy as when I was using Perl to quickly prototype UIs (ugh), and obviously lots more robust :-)
10:30:54 <dcoutts_> but that's in the pipeline
10:31:10 <ndm> kombinator: no, not at all - i've never had UI speed be a problem at all
10:31:19 <ndm> dcoutts_ - oh, that would have been handy for me :)
10:31:31 <mux> UI spend most of their time blocking for things to happen
10:31:42 <ndm> kombinator: in fact, i've deliberately designed it to be slow and stupid at all possible choices
10:31:47 <ddarius> Humans are slow.
10:31:49 <dcoutts_> kombinator: you're thinking of the issue of which things to update when some UI state element changes?
10:31:58 <kombinator> yes
10:32:06 <mux> ddarius: right, it may become a problem when robots use computers :-)
10:32:12 <mux> we may need to optimize UIs more at that point
10:32:23 <ddarius> Not if they use the same interface humans use.
10:32:25 <kombinator> arrows give opportunity to do some caching
10:32:25 <dcoutts_> kombinator: and the point is that the arrows gives you a little more introspection on the event dep graph I suppose?
10:32:37 <kombinator> dcoutts_: yes
10:33:33 <kombinator> and to do tricks like in Nilsson's paper
10:33:48 <dcoutts_> kombinator, ndm: btw, if you want to advertise your wares on the Gtk2Hs website then get in touch, eg blog articles on the development page on how your toolkits work.
10:34:17 <dcoutts_> it'd get syndicated on planet.h.o
10:34:18 <kombinator> dcoutts_: as soon as my work becomes publishable, you'll hear about it :)
10:34:21 <ndm> dcoutts_ give me a few months, i'm not sure if GuiHaskell will develop PropLang further, or port out of it - so i won't know what state its in till then
10:34:29 <dcoutts_> right'o
10:34:34 * mux notes using gtk2hs directly is also very easy when you use glade
10:34:47 <kombinator> what's GuiHaskell?
10:34:52 <ndm> mux: take a look at hte PropLang wrapper - it has some interface wrappers
10:34:53 <ndm> @where guihaskell
10:34:54 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
10:35:01 <dcoutts_> mux: you don't want to help with our intro/glade tutorial do you? :-)
10:35:07 <ndm> kombinator: WinHugs s/Win/any/, s/Hugs/any/
10:35:12 * mux coughs
10:35:16 <dcoutts_> heh
10:35:26 <mux> dcoutts_: I can supply .glade files :D
10:35:38 <dcoutts_> mux: heh heh
10:36:13 <kombinator> haskell's response to drscheme? :)
10:37:51 <mux> dcoutts_: there's a new gtk tool to create .glade files, written in python - only I cannot remember the name
10:37:58 <ndm> kombinator: some what, my response to not having WinGHCi, and my response to Hugs's coding scheme being 4 spaces is an indent, 8 is a tab
10:38:04 <mux> dcoutts_: do you know about it?
10:38:05 <dcoutts_> mux: gaspatcho or similar
10:38:08 <mux> ah yes
10:38:11 <mux> ever tried it?
10:38:13 <dcoutts_> mux: I prefer glade 3 I think.
10:38:17 <mux> okay
10:38:17 <dcoutts_> mux: I did try it once
10:38:40 <mux> rofl
10:38:50 <mux> I was thinking 'how was it named already? paprika?'
10:38:55 <mux> I knew it has something to do with food.
10:38:59 <dcoutts_> heh
10:44:01 <betatesting> How do I detach a process from TTY? (And literally send the bugger to the background)? In code. Unix system call ... setsid(3) doesn't seem to work.
10:44:31 <Heffalump> have you looked at the source of hws?
10:44:35 <Heffalump> I presume that must do it
10:44:39 <Heffalump> (hws = Haskell Web Server)
10:44:43 <pejo> betatesting, fork?
10:45:21 <mauke> daemon(3)
10:45:34 * Heffalump looks at the source and decides that it doesn't seem to do that.
10:46:08 <betatesting> pejo: fork will keep the current guy alive - I don't want that, though.
10:46:29 <olsner> betatesting: just do exit(0) in the left side of the fork
10:46:40 <betatesting> mauke: I don't seem to have daemon(3) ...
10:46:47 <olsner> let it become the "dark side of the fork"
10:46:53 <pejo> mauke, how portable is that?
10:47:00 <betatesting> olsner: Won't the death of the parent kill the children?
10:47:19 <mauke>        Not in POSIX.1-2001.  A similar function appears on the BSDs.  The daemon() function first appeared in 4.4BSD.
10:47:44 <olsner> betatesting: that's what daemon does internally, according to my manpage, so apparently not
10:48:07 * betatesting goes off to try that ...
10:48:28 <Saizan> no the child will be adopted by the grandfather or init at least
10:48:30 <mauke> yeah, you're supposed to fork, exit the parent, setsid, chdir to /, redirect stdin/out/err to /dev/null
10:53:05 <qwr> betatesting: fork and setsig. ignoring sighup wont hurt either
10:53:55 <qwr> betatesting: children of tty process die only because tty usually sends SIGHUP to the process group, when it is closed
10:54:21 <qwr> s/setsig/setsid
10:54:32 <betatesting> qwr: I'm trying to ... let's say ... manually detach from TTY.
10:55:02 <qwr> betatesting: it's pointless - you are never really attached to it :)
10:55:02 <betatesting> I want to call some func and return the shell prompt to the user while I keep running down there.
10:55:52 <qwr> then you fork, setsid and let the parent die so shell wait will awake
10:58:09 <bluestorm_> hm
10:58:27 <bluestorm_> there is something i don't really understand about type classes
10:58:38 <bluestorm_> :t (+1)
10:58:38 <bluestorm_> (+1) :: (Num a) => a -> a
10:58:41 <lambdabot> forall a. (Num a) => a -> a
10:58:51 <bluestorm_> let inc = (+1)
10:58:57 <bluestorm_> :t inc
10:58:58 <bluestorm_> inc :: Integer -> Integer
10:59:01 <mauke> @where mr
10:59:01 <lambdabot> I know nothing about mr.
10:59:02 <lambdabot> Not in scope: `inc'
10:59:12 <bluestorm_> seems hmm
10:59:28 <betatesting> bluestorm_: What exactly?
10:59:43 <mauke> bluestorm_: http://haskell.org/hawiki/MonomorphismRestriction
10:59:44 <lambdabot> Title: MonomorphismRestriction - The Haskell Wiki
10:59:45 <bluestorm_> ok
10:59:49 <betatesting> qwr: I need a sample of what you mean.
11:00:11 <betatesting> qwr: Like, can you do a prog that detaches from TTY? Please ...
11:00:47 <betatesting> Monomorphism prob will be gone in Haskell', right?
11:00:53 <lispy> ?users
11:00:54 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 46 (14.6%)
11:01:00 * betatesting goes off to try again ...
11:01:10 <qwr> betatesting: if (fork()) exit(0); setsid(); while (1) { puts("xxx"); sleep(1); }
11:01:37 <pejo> @google Unix Daemon Server Programming
11:01:40 <lambdabot> http://www.enderunix.org/docs/eng/daemon.php
11:01:40 <lambdabot> Title: Unix Daemon Server Programming
11:06:08 <kombinator> ndm: what are logical meanings of (=<=), (=<) etc. ?
11:06:08 <sch> @google Haskell Unix System-daemon
11:06:11 <lambdabot> http://software.complete.org/missingh/static/doc/System-Daemon.html
11:06:53 <kombinator> ndm: I'm going through your code, I guess I will need to reverse-engineer their meanings as they are not described...
11:16:24 <sorear> hello
11:16:52 <betatesting> qwr, pejo, Thanks a lot. It worked.
11:17:09 <betatesting> 'Twas my first time to have to do such obscene hackery. :oD
11:22:00 <sorear> @users
11:22:01 <lambdabot> Maximum users seen in #haskell: 336, currently: 316 (94.0%), active: 48 (15.2%)
11:22:04 <sorear> @uptime
11:22:05 <lambdabot> uptime: 6d 17h 50s, longest uptime: 13d 18h 36m 21s
11:24:44 <syntaxfree> I think I understand what a "semantics" means in logic.
11:24:56 <syntaxfree> You're basically "compiling" your logic system into another logic.
11:25:12 <syntaxfree> So, say, modal logic can be given a semantics in terms of predicate logic.
11:25:42 <Heffalump> so what's the machine code of logic?
11:25:55 <ddarius> When I think "semantics" in logic, I think model theory.
11:25:56 <syntaxfree> that's a philosophical question.
11:25:56 <sorear> Yes, that's a valid way to look at semantics.
11:26:15 <syntaxfree> "Native" logic to me is set theory. Philosophy majors see predicate logic as more primitive.
11:26:52 <sorear> "Native" is pretty meaningles.
11:27:19 <sorear> You can give i386 machine code a semantics in terms of haskell, and if you want formalism it wouldn't be a bad idea.
11:27:27 <syntaxfree> :)
11:27:31 <skew> syntaxfree: how many large cardinals?
11:27:32 <syntaxfree> yay!
11:27:41 <sorear> But if your goals are execution, you usually want to go the other way!
11:27:47 <Heffalump> but i386 machine code is in some way axiomatic, and Haskell isn't
11:28:04 * syntaxfree still doesn't quite grok the "proofs are programs" part, but it's a step.
11:28:29 <Igloo> Why isn't Haskell axiomatic?
11:28:42 <Heffalump> I was just thinking about that.
11:28:44 <ddarius> Types are propositions and proofs of those propositions are terms that inhabit the types (i.e. programs).
11:28:56 <Heffalump> I guess it is, really.
11:29:33 <syntaxfree> ddarius: yeah, I read Wadler's article.
11:29:37 <syntaxfree> It just didn't 'sink'.
11:30:17 <ddarius> How familiar are you with logic?
11:30:50 <syntaxfree> ddarius: that's not an easy question.
11:31:01 <syntaxfree> I know bits & ends here and there. It's all a disorganized mess, though.
11:31:06 <syntaxfree> Same as my overall CS knowledge.
11:31:32 <ddarius> If you are more or less handy with Haskell, you know enough about CS for the Curry-Howard correspondence.
11:31:55 <syntaxfree> well, I'm more or less knowledgeable in Bird-Merteens formalism.
11:31:58 <ddarius> If you know what intuitionistic propositional logic is or could understand it if you saw it, then you have enough logic.
11:32:02 <syntaxfree> at least from Erik Meijer's papers.
11:32:13 <mux> @djinn a -> b
11:32:14 <lambdabot> -- f cannot be realized.
11:32:28 <MyCatVerbs> @djinn Char -> [Char]
11:32:28 <lambdabot> -- f cannot be realized.
11:32:31 <syntaxfree> I keep reading _and_ forgetting how intuitionistic logic is different from classical logic.
11:32:45 <ddarius> syntaxfree: It lacks the law of the excluded middle, that is all.
11:32:47 <nominolo> syntaxfree: no LEM
11:33:00 <nominolo> and not (((a -> b) -> b) -> b)
11:33:07 <nominolo> not sure, why the latter, though
11:33:08 <syntaxfree> hmm.
11:33:12 <Olathe> Intuitionistic car lots have no lemons.
11:33:16 <mux> there is no way to prove any given proposition 'b', given that another arbitrary proposition 'a'holds
11:33:22 <mux> so the a -> b type can't be inhabited
11:33:25 <nominolo> ah, yes
11:33:27 <mux> there is no expression with this type
11:33:44 <syntaxfree> wouldn't LEM-less logic be paraconsistent, as in, propositions can be both true and false?
11:33:48 <nominolo> you need a proof of a -> b.  which you can't have
11:33:52 <ddarius> nominolo: Are you thinking of ((a -> b) -> a) -> a ?
11:34:03 <nominolo> ddarius: wait
11:34:28 <mux> @djinn a -> b -> a
11:34:29 <lambdabot> f a _ = a
11:34:35 <syntaxfree> -> here is implication?
11:34:39 <ddarius> syntaxfree: There's true and then there are things other than true.
11:34:41 <ddarius> syntaxfree: Yes.
11:34:59 <mux> if 'a' and 'b' hold, you can easily prove 'a', obviously
11:35:11 <mux> so this type can be inhabited
11:35:43 <nominolo> ddarius: possibly
11:36:00 <syntaxfree> @djinn ((a -> b) -> a) -> a
11:36:00 <lambdabot> -- f cannot be realized.
11:36:10 <syntaxfree> one thing I can't see is the role of values in logic.
11:36:11 <sorear> Another view of the big thing about intuitionistic  is that NOT NOT a  isn't the same as a
11:36:12 <ddarius> ((a -> b) -> a) -> a is Pierce's law and is equivalent to the law of the excluded middle.
11:36:13 <syntaxfree> values and types.
11:36:38 <mux> @djinn (a -> b) -> a -> b
11:36:39 <ddarius> syntaxfree: values = proofs, propositions = types.
11:36:39 <lambdabot> f a = a
11:36:46 <nominolo> ddarius: ah, because it's the type of call/cc
11:36:52 <ddarius> nominolo: Yes.
11:36:59 <sorear> So, looking at haskell as a (poor) model of intuitionistic logic  -  you have  (a -> V) -> V, you can't get a.
11:37:05 <ddarius> syntaxfree: But "values" and "types" are the CS side.
11:37:09 <nominolo> ddarius: do you have any reference?
11:37:31 <sorear> you know that if you could proove a doesn't exist, you could derive a contradiction
11:37:33 <syntaxfree> hmm. but I keep hearing about the "typed" and the "untyped" lambda calculus.
11:37:42 <sorear> but can't not exist  isn't the same as  exists
11:37:50 <mux> syntaxfree: yes there are many lambda calculus
11:37:56 <mux> untyped, simply typed, second-order
11:37:57 <matthew-_> right, I need to get ghc to tell me, with UndecidableInstances and IncoherentInstances turned on, the grounds for picking certain instances over others
11:38:01 <sorear> intuitionistic logic rejects proof by contradiction
11:38:02 <matthew-_> any ideas?
11:38:07 <mux> calculi, I should have said
11:38:08 <ddarius> It would take some looking, but if you google for things like classical logic and curry-howard and the lamda-mu calculus and others you'll find plenty of papers along those lines.
11:38:12 <syntaxfree> so how is a logic "typed"?
11:38:17 <sorear> why is why it is also called constructive logic
11:38:21 <sorear> s/why/which/
11:38:32 <syntaxfree> ddarius: I have a pile of unread papers about the CS-logic connection :)
11:38:36 <nominolo> oh, according to wikipedia it's "peirce's law"
11:38:38 <mux> syntaxfree: every lambda calcul or so has a corresponding logic
11:38:43 <syntaxfree> I just came to confirm an intuition that 'clicked'.
11:38:53 <syntaxfree> mux: so a lambda-calculus isn't a logic per se.
11:38:57 <syntaxfree> It just can be given a semantics in a logic.
11:39:05 <ddarius> No.
11:39:19 <syntaxfree> No @ what? : P
11:39:38 <ddarius> Well, I guess it could be given abstract semantics in a logic...
11:39:57 <syntaxfree> why do I see theoretical logicians in philosophy departments that study the lambda calculus?
11:40:19 <ddarius> syntaxfree: Because Type Theory uses the notation of the lambda calculus.
11:40:21 <sorear> syntaxfree: Yes, {xor, {0, 2}} and {xor, {0, 4}} aren't the same philosophically.  but us working mathimaticains pretend they are, because of the trivial isomorphism.
11:40:48 <mux> dcoutts_: if I use {#call ...} I'm not supposed to pass marshalled parameters such as a CString, but I should just pass a String?
11:41:08 <ddarius> They can be viewed as notational variations of each other (or rather the lambda calculus is a notation variation of the proof theory of a logic).
11:41:17 <syntaxfree> and type theory is a branch of logic?
11:42:24 <nominolo> syntaxfree: yes, it evolved as one
11:42:34 * DukeDave having read the backlog of chat on proofs, is exactly *not* going to get distracted :)
11:42:59 <syntaxfree> hmm.
11:43:07 <syntaxfree> from a logic point of view, what /is/ type theory?
11:43:11 <cinimod> matthew_: others may differ but I'd say that those options should only be used when you really can't solve the problem any other way
11:43:34 <DukeDave> So I just read that:  For the data statement, the values Room _|_ and _|_ are different, whereas for the newtype statement, they are considered the same."      Can anyone recommend a nice way I can see this for me self in Haskell?
11:43:38 <ddarius> The most usual one is related to higher order logic.
11:43:46 <syntaxfree> I understand type theory as in embedded in category theory, as in Erik Meijer's papers.
11:44:01 <syntaxfree> I'm having a hard time connecting it to logic.
11:44:25 <ddarius> DukeDave: data/newtype Room = Room Int,   print (Room undefined `seq` "foo")
11:44:34 <nominolo> syntaxfree: it was started to solve the problem of the barber's paradox
11:44:46 <nominolo> (or something like this)
11:44:55 <syntaxfree> @wikipedia barber's paradox
11:45:00 <lambdabot> No Result Found.
11:45:06 <nominolo> it's along the lines:
11:45:30 <nominolo> "The barber shaves everyone that doesn't shave himself."
11:45:39 <DukeDave> Ah, I've never used undefined before... The function which returns _|_ ?
11:45:45 <nominolo> "Does the barber shave himself?"
11:46:04 <ddarius> nominolo: There is no barber, so no paradox.
11:46:04 <nominolo> DukeDave: _|_ can mean many things
11:46:29 <ddarius> Many things can mean bottom.  But, due to undefined's type, it -must- be bottom.
11:47:04 <syntaxfree> nominolo: that sounds like a special case of the liar paradox.
11:47:25 <nominolo> DukeDave: let x = x in x is also _|_
11:47:38 <syntaxfree> @type let x = x in x
11:47:43 <swiert> The barber's a woman!
11:47:43 <lambdabot> forall t. t
11:48:00 <syntaxfree> @type undefined
11:48:08 <nominolo> syntaxfree: Yes, it came up when people tried to axiomize sets.
11:48:15 <lambdabot> forall a. a
11:48:33 <ddarius> Russell's paradox came up.
11:48:53 <syntaxfree> doesn't the liar paradox come from ancient greece?
11:48:55 <DukeDave> Is it fair to say   head []    is bottom?
11:48:56 <nominolo> ddarius: isn't that the same just with sets and membership?
11:48:58 <syntaxfree> "All cretan generals are liars", etc?
11:49:06 <ddarius> No.
11:49:35 <DukeDave> I mean, can I put erroneous, bottom, and _|_ in the same box in my head?
11:49:42 <DukeDave> No to me ddarius ?
11:49:49 <cinimod> Russell's paradox shows that no set contains everything
11:49:52 <nominolo> ddarius: yes, it is.
11:50:28 <ddarius> DukeDave: Yes re bottom.
11:50:38 <mux> russell's paradox stems for the definition of the set that contains all sets who do not contains themselves as members
11:50:40 <DukeDave> Magic, cheers :)
11:50:56 <kolmodin> using workrave? wondering how many keystrokes you've typed since you installed it? liftM (sum . map (read . last . words) . filter ("m" `isPrefixOf`) . lines) (readFile "historystats") -- neat?
11:51:21 <nominolo> ddarius: ok, modulo the "no barber exists" escape path
11:51:28 <syntaxfree> hmm.
11:51:37 <syntaxfree> ok. wait, wait, wait.
11:51:45 <balodja> what is the use of 'fix'?
11:52:01 <mux> balodja: it's the most powerful obfuscating tool known on earth
11:52:02 <kolmodin> > fix ("fix":)
11:52:09 <lambdabot>  ["fix","fix","fix","fix","fix","fix","fix","fix","fix","fix","fix","fix","fi...
11:52:14 <mux> it allows you to write anonymous recursive functions
11:52:17 <kolmodin> balodja: that's about it
11:52:17 <syntaxfree> > fix (\x->if x == 1 then 1 else (\x->x*(x-1)))
11:52:22 <syntaxfree> > fix (\x->if x == 1 then 1 else (\x->x*(x-1))) 5
11:52:23 <kolmodin> balodja: j/k :D
11:52:27 <lambdabot>   add an instance declaration for (Num (a -> a))
11:52:27 <lambdabot>     In the expression: if x ...
11:52:30 <lambdabot>   add an instance declaration for (Num (a -> a))
11:52:30 <lambdabot>     In the expression: if x ...
11:52:36 <mux> > fix ((1:) . scanl (+) 1)
11:52:45 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:52:49 <syntaxfree> > fix (\x->if x == const 1 then 1 else (\x->x*(x-1))) 5
11:52:55 <lambdabot>   add an instance declaration for (Num (b -> b))
11:52:56 <lambdabot>     In the expression:
11:52:56 <lambdabot>      ...
11:53:00 <balodja> > fix (\x -> log(x+2))
11:53:03 <syntaxfree> > fix (\x->if x == 1 then (const 1) else (\x->x*(x-1))) 5
11:53:09 <lambdabot>  Exception: <<loop>>
11:53:11 <lambdabot>   add an instance declaration for (Num (b -> b))
11:53:17 <mux> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 5
11:53:26 * syntaxfree dies
11:53:28 <lambdabot>  120
11:53:29 <syntaxfree> @quote dies
11:53:30 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
11:53:30 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
11:53:31 <mux> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) $ 6
11:53:33 <nominolo> balodja: it passes the argument as an argument to itself ;)
11:53:44 <lambdabot>  720
11:54:01 <nominolo> > fix (\x -> show x)
11:54:10 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
11:54:23 <nominolo> sort of ..
11:55:31 <syntaxfree> > fix (\x-> max 1 (x/2)) 9
11:55:38 <lambdabot>   add an instance declaration for (Fractional (t -> a))
11:56:00 <syntaxfree> > fix (\x-> max 1 (x `div` 2)) 9
11:56:07 <lambdabot>   add an instance declaration for (Integral (t -> a))
11:56:10 <syntaxfree> > fix (\f x-> max 1 (x `div` 2)) 9
11:56:19 <lambdabot>  4
11:56:28 <syntaxfree> I didn't add a recursive case :P
11:56:37 <syntaxfree> > fix (\f x-> max 1 (f (x `div` 2))) 9
11:56:53 <lambdabot>  thread killed
11:56:57 <syntaxfree> @quote drops dead
11:56:57 <lambdabot> No quotes for this person. Are you on drugs?
11:57:03 <syntaxfree> @quote dead
11:57:04 <lambdabot> syntaxfree says: syntaxfree drops really dead this time.
11:57:17 * syntaxfree laments his tiny peacock brain.
11:57:20 <mux> > fix (\f x -> if null x then 0 else 1 + f (tail x)) "lala"
11:57:34 <lambdabot>  4
11:57:37 <mux> > fix (\f x -> if null x then 0 else 1 + f (tail x)) "lalala"
11:57:42 <balodja> hm-m-m
11:57:45 <balodja> so
11:57:45 <lambdabot>  6
11:58:00 <mux> @pl \f x -> if null x then 0 else 1 + f (tail x)
11:58:01 <lambdabot> ap (flip if' 0 . null) . ((1 +) .) . (. tail)
11:58:03 <balodja> > fix (\f x -> log (x+2)) $ 2
11:58:04 <mux> heh.
11:58:13 <lambdabot>  1.3862943611198906
11:58:28 <syntaxfree> > log 4
11:58:37 <lambdabot>  1.3862943611198906
11:58:43 <mux> don's CPU must be heating
12:00:12 <nominolo> @pl let x = x in x
12:00:13 <lambdabot> fix id
12:00:38 <nominolo> :t mfix
12:00:51 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
12:01:11 <nominolo> @pl let x = return x in x
12:01:11 <lambdabot> fix return
12:01:25 <nominolo> @pl let x = x in return x
12:01:25 <lambdabot> return (fix id)
12:01:30 <mux> @src mfix
12:01:31 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:01:34 <mux> @rc fix
12:01:35 <lambdabot> Maybe you meant: rc src
12:01:39 <mux> oops
12:01:40 <mux> @src fix
12:01:41 <lambdabot> fix f = let x = f x in x
12:01:41 <nominolo> @instances MonadFix
12:01:43 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:01:47 <EvilTerran> @hoogle Pat -> PatQ
12:01:47 <lambdabot> No matches, try a more general search
12:01:53 <nominolo> @src Either mfix
12:01:53 <lambdabot> mfix f = let a = f $ case a of
12:01:53 <lambdabot>                         Right r -> r
12:01:53 <lambdabot>                         _       -> error "empty mfix argument"
12:01:53 <lambdabot>          in a
12:02:14 <EvilTerran> @hoogle Pat -> Q Pat
12:02:15 <lambdabot> No matches, try a more general search
12:02:18 <Jaak> > map ((+1) . length . snd) .  filter fst . zip (cycle [False, True]) . group $ fix show
12:02:30 <merus> @hoogle (a -> a) -> a
12:02:32 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
12:02:32 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
12:02:32 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
12:02:34 <lambdabot>  thread killed
12:03:00 <balodja> > fix (\f x -> log ((f x)+2)) $ 2
12:03:10 <lambdabot>  Exception: <<loop>>
12:06:26 <syntaxfree> > undefined * 2
12:06:28 <lambdabot>  Undefined
12:06:49 <syntaxfree> doesn't undefined make the entire Haskell environment isomorphic to a Maybe type?
12:06:56 <syntaxfree> Where values are Just values and undefined is Nothing?
12:07:48 <syntaxfree> balodja: that goes to infinity man.
12:08:02 <Heffalump> syntaxfree: not really, because in your Maybe type you could still get an infinite loop
12:08:04 <syntaxfree> > fix (\f x -> max 1 (log ((f x) - 2))) $ 2
12:08:12 <lambdabot>  Exception: <<loop>>
12:08:14 <Heffalump> and the equivalence between Just (infinite loop) and Nothing wouldn't be decidable
12:08:28 <syntaxfree> > fix (\f x -> max 2 (log ((f x) - 2))) $ 10
12:08:35 <syntaxfree> Heffalump: ok!
12:08:38 <Heffalump> but conceptually that's a good way of thinking about it
12:08:39 <lambdabot>  Exception: <<loop>>
12:08:45 <Heffalump> if you understand the limitations of doing so too
12:09:01 <mux> syntaxfree: you need a path that terminates in your function
12:09:15 <syntaxfree> mux: I thought "max 2" would take care of it.
12:09:27 <Heffalump> and certainly all the causes of failure that aren't non-termination could be modelled that way
12:09:37 <mux> max 2 still needs to know what's the value of the second argument to return the max
12:09:44 <syntaxfree> hmm.
12:09:45 <mux> so it'll always call f
12:09:53 <mux> so it'll indefinitely recurse
12:10:05 <syntaxfree> > fix (\f x -> f (max 2 (log x - 2)) $ 10
12:10:06 <lambdabot>  Parse error
12:10:13 <syntaxfree> > fix (\f x -> f (max 2 (log x - 2))) $ 10
12:10:19 <mux> that's also always calling f
12:10:23 <lambdabot>  Exception: <<loop>>
12:10:41 <mux> compare with my definition of length in terms of fix earlier
12:10:42 <syntaxfree> > fix (\f x -> x: f (max 2 (log x - 2))) $ 10
12:10:47 <mux> > fix (\f x -> if null x then 0 else 1 + f (tail x)) "lalala"
12:10:58 <lambdabot>  6
12:10:58 <lambdabot>  [10.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2.0,2....
12:10:59 <syntaxfree> yes, yes.
12:11:09 <syntaxfree> I see how to get fix to terminate with case analysis.
12:11:16 <syntaxfree> I was trying to break free of explicit case analysis.
12:11:21 <mux> okay
12:11:38 <syntaxfree> > fix (\f x -> x: max 2 (log ((f x) - 2))) $ 10
12:11:46 <lambdabot>   add an instance declaration for (Floating [a])
12:11:56 <syntaxfree> of course.
12:12:50 <Heffalump> > fix (\f x -> x: max 2 (log ((f (head x)) 02 ))) $ 10
12:12:51 <mux> dcoutts_: help! :-)
12:12:54 <jbauman> that's a bit silly
12:12:54 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:12:54 <lambdabot>       Expected...
12:13:04 <Heffalump> doh, that'd never work
12:13:07 <syntaxfree> > fix (\f x -> x : map (/2) (f x)) $ 10
12:13:16 <Heffalump> iterate (\f x -> x:max 2 (log ((f x) - 2))) $ 10
12:13:17 <lambdabot>  [10.0,5.0,2.5,1.25,0.625,0.3125,0.15625,7.8125e-2,3.90625e-2,1.953125e-2,9.7...
12:13:17 <Heffalump> > iterate (\f x -> x:max 2 (log ((f x) - 2))) $ 10
12:13:20 <syntaxfree> > fix (\f x -> x ++ map (/2) (f x)) $ 10
12:13:20 <ddarius_> To use fix, write the definition out recursively than abstract out the name, then apply fix, e.g. let ones = 1:ones -> \ones -> 1:ones -> fix (\ones -> 1:ones) -> fix (1:)
12:13:27 <lambdabot>   add an instance declaration for (Num (a -> [a]))
12:13:28 <lambdabot>   add an instance declaration for (Num [a])
12:13:43 * Heffalump gives up his ability to write code as a bad job
12:13:51 <balodja> hm-m
12:14:10 <balodja> > fix (\f x -> x:(log x+2)) $ 2
12:14:17 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
12:14:17 <lambdabot>       Expected...
12:14:26 <balodja> > fix (\f x -> x:(f (log x+2))) $ 2
12:14:37 <lambdabot>  [2.0,2.6931471805599454,2.9907104653475316,3.0955109730055064,3.129952988795...
12:14:53 <ihope_> Now, I don't suppose there's any way to create a type that has no constructors but still is populated.
12:15:04 <balodja> syntaxfree: that's not infinite :)
12:15:08 <Heffalump> you can hide the constructors when you export the type
12:15:10 <ddarius> Every type with no constructors still is populated.
12:15:12 <DRMacIver> ihope_: No, but you can hide the constructors.
12:15:29 <ihope_> Well, yes, every type is populated.
12:16:24 <ihope_> But... ah, I'm not thinking in Haskell lately. I'd been pondering the usefulness of such a thing.
12:16:47 <syntaxfree> can I use guards in lambdabot?
12:16:59 <ddarius>  > just goes out to GHC
12:17:11 <syntaxfree> > f | x> 2 = "Big" | otherwise = "Small"  in f 3
12:17:12 <lambdabot>  Parse error
12:17:15 * EvilTerran wonders if $(canFail [| \... -> ... |]) is superior to the alternatives, where canFail digs into the recieved lambda and adds a (_ -> fail "pattern match failure") clause
12:17:19 <ihope_> > let f x | even x = 3; f x = 4; map f [1..10]
12:17:19 <lambdabot>  Parse error
12:17:27 <ihope_> > let f x | even x = 3; f x = 4 in map f [1..10]
12:17:29 <syntaxfree> > f | x> 2 = "Big"; | otherwise = "Small"  in f 3
12:17:30 <lambdabot>  Parse error
12:17:38 <lambdabot>  [4,3,4,3,4,3,4,3,4,3]
12:17:47 <syntaxfree> > f {| x> 2 = "Big"; | otherwise = "Small"}  in f 3
12:17:48 <lambdabot>  Parse error
12:17:56 <syntaxfree> :~
12:18:07 <ddarius> > let f x | x > 2 = "big" | otherwise = "small" in f 3
12:18:16 <lambdabot>  "big"
12:18:22 <ihope_> > let f x | even x = 3; f x | otherwise = 4 in map f [1..10]
12:18:32 <lambdabot>  [4,3,4,3,4,3,4,3,4,3]
12:18:40 <syntaxfree> >let f x = case (even x) of { True -> "Even"; False -> "Weird";}  in map f [1..10]
12:18:50 <Jaak> @src otherwise
12:18:50 <lambdabot> otherwise = True
12:19:00 <syntaxfree> > let f x = case (even x) of { True -> "Even"; False -> "Weird";}  in map f [1..10]
12:19:03 <ihope_> > f x | x > 2 = "Big"; f x | otherwise = "Small" in f 3
12:19:03 <lambdabot>  Parse error
12:19:15 <EvilTerran> > let f x | x > 2 = "Big" | otherwise = "Small" in f 3
12:19:15 <lambdabot>  thread killed
12:19:21 <ihope_> Whew.
12:19:22 <lambdabot>  "Big"
12:19:37 <ihope_> So yes, as you can see, you can use guards in lambdabot.
12:19:40 <EvilTerran> ihope_, you need "let". also no semicolon between guards.
12:19:51 <ihope_> > let f x | x > 2 = "Big"; f x | otherwise = "Small" in f 3
12:20:00 <lambdabot>  "Big"
12:20:07 <ihope_> Where did it work without semicolons between them?
12:20:24 <ihope_> > let f x | x > 2 = "Big" | otherwise = "Small" in f 3
12:20:32 <lambdabot>  "Big"
12:20:35 <ihope_> I see.
12:22:08 <jmanson> hello
12:22:53 <jmanson> hmm. this ircatwork site is a bit slow
12:23:00 <jmanson> i'll be back
12:23:19 <syntaxfree>  > let  zhow x | (x `mod` 3) == 0 = "Fizz"; zhow x | (x `mod`                    5) == 0 = "Buzz"; zhow x | (x `mod` 15) ==0  = "FizzBuzz";
12:23:22 <syntaxfree>                    zhow x | otherwise = show x  in fix (\f x -> zhow x : f
12:23:25 <syntaxfree>                    (x+1)) $ 1
12:23:27 <syntaxfree> aww sucks.
12:23:31 <syntaxfree> my grand premiere was ruined.
12:23:48 <syntaxfree>                    zhow x | otherwise = show x  in fix (\f x -> zhow x : f (x+1)) $ 1
12:23:52 <syntaxfree> hahahaha
12:24:11 <syntaxfree> > let  zhow x | (x `mod` 3) == 0 = "Fizz"; zhow x | (x `mod` 5) == 0 = "Buzz"; zhow x | (x `mod` 15) ==0  = "FizzBuzz"; zhow x | otherwise = show x  in fix (\f x -> zhow x : f (x+1)) $ 1
12:24:22 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
12:24:29 <merus> Yay!
12:24:30 <syntaxfree> sorry about the big flood.
12:24:31 <merus> I <3 that game
12:24:38 <merus> syntaxfree++
12:25:00 <syntaxfree> the hard part was getting guards to work :P
12:25:31 <syntaxfree> the fun part is getting away with calling that "corecursive fixed-point combinator solution".
12:26:29 <ihope_> What game, now?
12:26:52 <syntaxfree> I wonder if I can get a programming job, now that I've demonstrated I can write fizzbuzz.
12:27:10 <ihope_> Is 15 FizzBuzz?
12:27:17 <ihope_> ...Yes, indeed, it is.
12:27:18 <syntaxfree> yes.
12:27:26 <syntaxfree> by explict case analysis, but it is.
12:27:49 <ihope_> Now make the multiples of 5 Fizz and the prime numbers Buzz, and start at 6.
12:28:07 <syntaxfree> I just have to paste the sieve I have in a file somewhere :)
12:28:16 <Korollary> but is it an enterprise, scalable fizzbuzz?
12:28:18 <syntaxfree> > let  zhow x | (x `mod` 3) == 0 = "Fizz"; zhow x | (x `mod` 5) == 0 = "Buzz"; zhow x | (x `mod` 15) ==0  = "FizzBuzz"; zhow x | otherwise = show x  in fix (\f x -> zhow x : f (x+1)) $ 100
12:28:28 <ihope_> Enterprise, scalable?
12:28:28 <syntaxfree> Korollary: it's corecursive! And employs a fixed-point combinator.
12:28:29 <lambdabot>  ["Buzz","101","Fizz","103","104","Fizz","106","107","Fizz","109","Buzz","Fiz...
12:28:39 <syntaxfree> Now just need a Wadlerbeard.
12:28:51 <ihope_> You do have to change three things to make the numbers different.
12:28:57 <moconnor> Is it possible to have a data type of the form: "data Foo = V String | F (V String) Foo" ?  Basically, I want to restrict the first parameter of F to be "V String", and not any arbitrary "Foo".
12:28:57 <syntaxfree> s/Now just/Now I
12:29:39 <syntaxfree> moconnor: I don't see why not. It doesn't compile?
12:29:47 <moconnor> syntaxfree: yeah, got a syntax error
12:29:55 <syntaxfree> then ignore me. I'm the village idiot.
12:30:13 <syntaxfree> @kind data Maybe a = Just a | None
12:30:19 <lambdabot> parse error on input `data'
12:30:22 <stepcut> Interestly enough, the trick of (x `mod` 15) actually produces slower code when compiled with ghc -O2 than doing (x `mod` 3) && (x `mod` 5)
12:30:27 <syntaxfree> @kind  Just a | None
12:30:29 <olsner> V isn't a type, it's a constructor... I guess what you really want is .. | F String Foo
12:30:32 <lambdabot> parse error on input `|'
12:30:36 <Korollary> moconnor: Why not F String Foo
12:30:54 <jmanson> hello
12:31:04 <moconnor> Korollary: I dumbed down the example to make it tractable for IRC.  The actual construct is more complicated.
12:31:08 <Korollary> > "hello"
12:31:09 <Jaak> > mapM (\n -> callCC $ \k -> do {when (n `mod` 3 == 0) (when (n `mod` 5 == 0) (k "FizzBuzz") >> k "Fizz"); when (n `mod` 5 == 0) (k "Buzz"); return (show n) }) [1..100]
12:31:10 <matthew-_>     Context reduction stack overflow; size = 20
12:31:13 <lambdabot> Terminated
12:31:17 <matthew-_> yay, I beat ghc again
12:31:19 <Jaak> rr
12:31:22 * matthew-_ groans
12:31:23 <lambdabot>  "hello"
12:31:25 <MyCatVerbs> Hrmn. Isn't foldl supposed to be faster than foldr?
12:31:39 <syntaxfree> not at all.
12:31:46 <syntaxfree> foldl' is supposed to be faster than foldl though.
12:32:03 <syntaxfree> > foldr (/2) 1 [1..10]
12:32:11 <lambdabot>   add an instance declaration for (Enum (b -> b))
12:32:13 <syntaxfree> > foldr (/) 1 [1..10]
12:32:19 <MyCatVerbs> I just tried "main = putStr fold[lr] (*) [1..25000]" on an old laptop a few times. foldr keeps taking ~8.8s, foldl 9.4s.
12:32:23 <lambdabot>  0.24609375
12:32:28 <MyCatVerbs> :t foldl'
12:32:30 <syntaxfree> > foldl (/) 1 [1..10]
12:32:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:32:34 <lambdabot>  2.7557319223985894e-7
12:32:35 <jmanson> i'm new to haskell, and wrote little program to multiply matrices together. I was wondering if there is a clearer way to express the program than I used. Could someone take a glance at it?
12:32:47 <syntaxfree> foldl' is the same as foldr, but it's evaluated strictly.
12:32:57 <olsner> @paste
12:32:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:33:03 <syntaxfree> anyway, you've just seen how foldr and foldl have different results, right?
12:33:09 <kpreid> syntaxfree: ITYM same as foldl
12:33:20 <MyCatVerbs> syntaxfree: of course. But it doesn't seem to be in Prelude.
12:33:24 <syntaxfree> > (foldr (/) 1 [1..10], foldl (/) 1 [1..10])
12:33:26 <EvilTerran> jmanson, stick it in that thar "haskell psatebin"
12:33:32 <lambdabot>  (0.24609375,2.7557319223985894e-7)
12:34:04 <Jaak> > let l = [1..3] in (foldl (-) l, foldr (-) l)
12:34:12 <lambdabot>   add an instance declaration for (Num [t])
12:34:14 <hpaste>  jmanson pasted "(no title)" at http://hpaste.org/1832
12:34:15 <kpreid> > take 30 $ show $ foldr (,) (undefined,undefined) [1..30]
12:34:22 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
12:34:23 <lambdabot>       Expec...
12:34:28 <Jaak> > let l = [1..3] in (foldl (-) 0 l, foldr (-) 0 l) -- eh
12:34:30 <syntaxfree> > let tryout f = (foldr1 f  [1..10], foldl1 f  [1..10]) in tryout (-)
12:34:38 <lambdabot>  (-6,2)
12:34:41 <lambdabot>  (-5,-53)
12:34:50 <syntaxfree> tryout will be the same if the function is commutative.
12:34:53 <syntaxfree> > let tryout f = (foldr1 f  [1..10], foldl1 f  [1..10]) in tryout (*)
12:35:08 <lambdabot>  (3628800,3628800)
12:35:15 <EvilTerran> @src replicate
12:35:16 <lambdabot> replicate n x = take n (repeat x)
12:35:24 <syntaxfree> @pl f a b = (log a)/(log b)
12:35:25 <lambdabot> f = (. log) . (/) . log
12:35:27 <EvilTerran> jmanson, that /\ may be of use to you
12:35:41 <syntaxfree> > let tryout f = (foldr1 f  [1..10], foldl1 f  [1..10]) in tryout $ (. log) . (/) . log
12:35:52 <lambdabot>  (NaN,NaN)
12:36:07 <jmanson> what is /\ ?
12:36:21 <liber> can I select what to import from a module?  Like: import only ord and chr from Data.Char?
12:36:22 <EvilTerran> that is an up arrow
12:36:32 <syntaxfree> liber yes.
12:36:35 <EvilTerran> I was referring to the previous thing i said
12:36:39 <syntaxfree> import Data.Char (ord, chr)
12:36:44 <syntaxfree> :)
12:36:46 <liber> thx
12:36:55 <liber> That wasn't to hard to get
12:37:07 <EvilTerran> jmanson, there's a standard function called replicate, defined as replicate n x = take n (repeat x)
12:37:31 <jmanson> EvilTerran: ah, i will try it out then
12:37:49 <syntaxfree> Haskell has even less syntax than Common Lisp, in a few important senses.
12:38:23 <syntaxfree> outside infixr/infixl/module/import, all lines are this = that equations.
12:38:42 <syntaxfree> (um, and typeclasses.)
12:39:02 <jmanson> EvilTerran: is my use of list comprehensions to create the matrix clear enough?
12:39:30 <EvilTerran> yes, that looks fine. however,
12:39:32 <syntaxfree> lists won't enforce line lengths, though.
12:39:33 <olsner> might be more readable with maps though
12:39:38 <EvilTerran> > transpose [[1,2],[3,4]]
12:39:43 <EvilTerran> is worth a look
12:39:48 <lambdabot>  [[1,3],[2,4]]
12:39:59 <syntaxfree> why doesn't Haskell have a decent matrix data type implemented on arrays by now?
12:40:08 <liber> how come my simple haskell program get around 320kb, when the only thing it does is a simple ceasar cipher? How come a hello world app gets ~300kb?
12:40:12 <syntaxfree> I mean, it has 234567890136483 graph types.
12:40:30 <syntaxfree> liber: I once wrote a caesar auto-decipher.
12:40:42 <syntaxfree> it /guesses/ what the rotation key is!
12:40:54 <jmanson> so, is transpose a standard function as well?
12:40:57 <EvilTerran> yup
12:40:59 <liber> syntaxfree: I am not quite at that level yet :)
12:41:04 <MyCatVerbs> liber: there's a thingummy. A chunk of runtime library embedded in thar.
12:41:04 <syntaxfree> I'll post to the new blog.
12:41:20 <MyCatVerbs> liber: if you look through ghc's user guide for a thing called the RTS? That'll be it.
12:41:25 <EvilTerran> jmanson, you'd need to add the line "import List (transpose)" to the top of your file
12:42:06 <jmanson> so, for example i could use row a n = (transpose a) !! n
12:42:16 <olsner> innerprod = sum $ zipWith (*) u v
12:42:18 <MyCatVerbs> liber: AFAIK, the bit that does all the hard work with FFI, garbage collection and so on is actually embedded into your program. I do not know why the RTS is not instead a shared library.
12:42:50 <jbauman> MyCatVerbs: then you would have to make sure you distribute the library if you distribute the program, i think
12:42:54 <EvilTerran> jmanson, yes, or you could express your matrix multiplication more elegantly using transpose too, i suspect
12:43:10 <liber> MyCatVerbs: okay. That explains quite a bit. When haskell has reached eternal glory, it will be removed hopefully
12:43:20 <jbauman> like all the fun with Vb40032.dll
12:43:51 <jbauman> EvilTerran, adding dot product makes it easy
12:43:52 <sorear> liber: the rts will probably always exist, the fun features it allows are sometimes very very useful.
12:44:24 <sorear> liber: but hopefully by summer's end therp's GSoC project to implement dynamic linking support will have come to fruition
12:44:45 <EvilTerran> jbauman, yes, i can see it would. also, as someone mentioned earlier, the Array type might be worth a look
12:44:53 <liber> sorear: What i meant to say was "When haskell has reached eternal glory, every operating system will include it as a library"
12:44:59 <MyCatVerbs> jbauman: jah... it'd still be nice to be able to shove the RTS off into a .so as an option to the compiler, though. It's not like adding a .so or a .dll is actually difficult in either Unix or Windows.
12:45:01 <sorear> liber: Ah ok :)
12:45:11 <EvilTerran> @docs Data.Array
12:45:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
12:45:45 <EvilTerran> jbauman, that url was for you
12:45:56 <MyCatVerbs> liber: hmmmmno. When Haskell has reached eternal glory, every operating system will have everything except for its kernel and the RTS written in Haskell, of course. =)
12:46:09 <jbauman> let dotp = zipWith (*) in \x y -> map (\l -> map (\r dotp l r) y) (transpose x)
12:46:18 <sorear> The GHC RTS *is* an OS
12:46:36 <liber> MyCatVerbs: why not live dangerously and write the kernel in haskell too? :D
12:46:40 <jbauman> err, almost
12:46:40 <sorear> Normally it runs in a parasitic mode not that different from user mode linux
12:46:52 <sorear> but it does support native operation
12:46:55 <sorear> @where House
12:46:56 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
12:47:06 <MyCatVerbs> sorear: yes, but if I was writing an OS with the intention to have everything possible in Haskell, I'd still put the RTS into userspace rather than kernel space.
12:47:34 <MyCatVerbs> sorear: more like libc than lkm, y'know?
12:48:03 <Heffalump> sorear: why would you call it an OS?
12:48:03 <jbauman> @pl \x y -> sum $ zipWith (*) x y
12:48:03 <lambdabot> (sum .) . zipWith (*)
12:48:04 <sorear> MyCatVerbs: Why bother with privledge rings?
12:48:19 <sorear> MyCatVerbs: Damas-Milner isn't good enough for you? ;)
12:48:38 <olsner> :t (sum .)
12:48:43 <jmanson> sorry, how do i include transpose again? i'm using an irc client that I can't figure out how to scroll up with
12:48:46 <lambdabot> forall a a1. (Num a) => (a1 -> [a]) -> a1 -> a
12:48:46 <MyCatVerbs> sorear: I'm not familiar.
12:49:24 <MyCatVerbs> sorear: and priviledge rings can be done in hardware with an asymptomatic cost of approximately O(zero). :P
12:49:25 <jmanson> wait.. i figured it out
12:49:56 <syntaxfree> http://syntaxfree.wordpress.com/2007/05/13/magic-caesar-autodecipher/
12:50:00 <lambdabot> Title: Magic Caesar autodecipher  Data.Syntaxfree, http://tinyurl.com/yw2uvs
12:50:01 <Heffalump> MyCatVerbs: do you mean asymptotic?
12:50:21 <syntaxfree> liber: there it is.
12:50:26 <Heffalump> in any case, I don't think privilege switches are that cheap, because of the need to copy data to avoid security issues
12:50:33 <MyCatVerbs> Heffalump: whooopsy. Heehee.
12:50:42 <MyCatVerbs> Thanks.
12:50:44 <liber> syntaxfree: Well.. instead of my deciphering the app: how does it work? :)
12:50:49 <Heffalump> though I'm not much of an expert
12:51:00 <syntaxfree> take a look at the code. it's the easiest way :)
12:51:03 <syntaxfree> i gotta go now.
12:51:13 <jbauman> @t True
12:51:13 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
12:51:18 <sorear> @ty True
12:51:20 <MyCatVerbs> Heffalump: still O(n) at worst. Inference can be bloody expensive.
12:51:24 <lambdabot> Bool
12:51:29 <jbauman> thanks, forgot what it was
12:51:44 <jbauman> @ty let dotp = (sum . ) . zipWith (*) in \x y -> map (\l -> map (\r -> dotp l r) (List.transpose y)) x
12:51:49 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
12:52:13 <jbauman> @pl let dotp = (sum . ) . zipWith (*) in \x y -> map (\l -> map (\r -> dotp l r) (List.transpose y)) x
12:52:13 <lambdabot> flip (map . flip (map . (sum .) . zipWith (*)) . (List .) . transpose)
12:53:06 <Heffalump> MyCatVerbs: true, but type inference is compile-time, not runtime.
12:53:21 <Heffalump> I guess in an OS you might need to do it at load-time for security
12:53:40 <Heffalump> and type inference also makes it possible to do all sorts of optimisations across the call boundary
12:54:08 <MyCatVerbs> I'm not entirely sure on the particulars of how you plan to extend type inference to the task of ensuring priviledges aren't exceeded.
12:54:24 <kc5tja> Inferencing isn't required even at load time either.
12:54:39 <MyCatVerbs> You plan to put a program to prove that a given program will never exceed its priviledges in the program loader?
12:54:55 <Heffalump> MyCatVerbs: yeah, ok. I guess that's not a trivial problem.
12:55:00 <kc5tja> When compiling, you embed type descriptors into your binary.  The loader would compare the type descriptors against the interface's requirements (also expressed as a type descriptor structure of some kind), and if they match, great.  if not, load-time error.
12:55:05 <jbauman> well, one could have privileged types, like priveleged pages/ segments
12:55:14 <MyCatVerbs> kc5tja: at compile time, wouldn't work. Someone could attach a removable storage device with a deliberately evil program on it.
12:55:26 <jbauman> kc5tja, proof carrying code
12:55:49 <kc5tja> MyCatVerbs: Whoa -- how does removable storage affect anything at all?
12:56:10 <MyCatVerbs> kc5tja: because people can bring arbitrary data on to the machine on removable media.
12:56:18 <kc5tja> Yeah.
12:56:19 <kc5tja> and?
12:56:20 <MyCatVerbs> kc5tja: same problem as adding a network to the box.
12:56:35 <jbauman> MyCatVerbs: you can check the proof before you run it
12:56:48 <jbauman> also, use a static version of Perl's taint system
12:56:57 <jmanson> is there a standard function like range n = [0 .. n-1] ?
12:56:59 <MyCatVerbs> jbauman: which puts you back to putting a program prover in the program loader.
12:56:59 <kc5tja> See the ETH Oberon System -- it pretty much does what you're looking for already.
12:57:19 <MyCatVerbs> jbauman: (I'm not entirely convinced that that isn't a pretty goddamn awesome idea, though.)
12:57:34 <koeien> enumFromTo 0 . (-1)
12:58:00 <olsner> @pl \n -> [0 .. n-1]
12:58:01 <lambdabot> enumFromTo 0 . subtract 1
12:58:04 <jbauman> MyCatVerbs: a verifier can be much simpler than a prover - no type inference for example
12:58:19 <MyCatVerbs> Okay, secondary problem. What if some sumbitch of a cosmic ray comes along, flips a bit in RAM and changes a previously verified-safe instrucion to one that will overwrite important bits of the system - interrupt vectors, whatever.
12:58:35 <MyCatVerbs> s/r\./r?/
12:58:36 <jbauman> what if that happens in kernel memory anyway?
12:58:51 <jbauman> on current systems
12:58:57 <MyCatVerbs> jbauman: the kernel has pretty low exposure, only being a few hundred kilobytes in size.
12:58:58 <jmanson> hmm. it sounds like it is simple enough that people just reqire it each time
12:59:11 <jmanson> rewrite i mean
12:59:30 <kc5tja> Cosmic rays have been known to kill Unix systems before.  You just reboot and carry on.
12:59:36 <MyCatVerbs> jbauman: whereas, that system would be vulnerable to a flipped bit in *any* loaded program.
12:59:38 <mux> hmmm, c2hs really loses me
12:59:56 <kc5tja> However, mainframes solve this with redundant RAM banks with ECC-corrected RAM paths and a voting algorithm in hardware to pick the correct 2 out of 3 words fetched.
13:00:12 <sorear> The *only* correct solution to cosmic rays is ECC.
13:00:22 <kc5tja> sorear: And redundant RAM banks.
13:00:36 <mux> for the overly paranoid :)
13:00:39 <sorear> kc5tja: Repetition is a ECC.
13:00:48 <MyCatVerbs> kc5tja: yes, but whereas with rings we were looking at a single program which can take the machine down if damaged, with verification there could be a dozen times the quantity of machine code to go wrong.
13:00:48 <kc5tja> sorear: Only to some extent.
13:01:28 <kc5tja> I guess I really just don't see the problem.
13:01:35 <MyCatVerbs> kc5tja: and both ECC and redundancy are bloody expensive. (Admittedly people will tend not to mind rebooting consumer hardware occasionally, especially thanks to the wonderful works of BillG.)
13:01:41 <kc5tja> If the hardware leaves you wide open to cosmic rays, you're totally at their mercy.
13:01:41 <jbauman> ECC is better than repetition
13:01:48 <sorear> MyCatVerbs: Also note that on a typical linux system (at least one without FF) 95+% of the memory is used by the kernel.
13:01:53 <kc5tja> sorear, jbauman -- read what I wrote.
13:02:00 <kc5tja> redundant RAM banks with EACH CHANNEL ECC-backed.
13:02:06 <MyCatVerbs> sorear: FF?
13:02:07 <kc5tja> ECC alone isn't sufficient.
13:02:24 <sorear> MyCatVerbs: Firefox
13:02:29 <kc5tja> For 1 or 2-bit errors, it's fine, but beyond that, it can only detect, not correct, errors.
13:02:38 <kc5tja> You still need the voting algorithm for burst errors larger than 2 bits.
13:02:51 <mux> which aren't really likely to happen anyways
13:02:54 <mux> or your RAM is faulty
13:03:02 <jbauman> especially due to cosmic rays
13:03:04 <sorear> I'd just like to point out there is *absolutely no way* to recover from *all* ram faults
13:03:21 <kc5tja> mux: Mainframes have this _nasty_ habit of claiming uptimes measured in decades.  It _will_ happen.
13:03:24 <jbauman> yeah, if your ram catches on fire, you're in trouble
13:03:47 <kc5tja> Mainframes also have hot-swappable CPUs and hot-swappable RAM slots too, also made possible with the redundant channels.
13:03:49 <sorear> So you should pick your uptime first.  You won't make it forevere.
13:03:53 <DRMacIver> sorear: I disagree. My program should keep running perfectly (albeit at reduced capacity) if I stick an axe through the motherboard. ;)
13:04:30 <DRMacIver> jbauman: Yeah, I've demonstrated that one in practice. :(
13:04:36 <sorear> DRMacIver: You can do that, for the right price.  But there is no limit to the amount of preparedness you can do.
13:05:04 <olsner> a box of wireless-connected, wireless-powered, dust-sized mini-CPU:s should survive axe attacks
13:05:04 <sorear> You can make a computer that will survive axes but not bombs.
13:05:07 <mux> kc5tja: a RAM stick getting broken surely will happen, it's not as likely for cosmic rays, even if you count into decades
13:05:14 * kc5tja notes that the Shuttle's computers exist in triplicate and also use voting algorithms for everything.  On RAM, on the core processor buses, -- everywhere.
13:05:38 <jbauman> of course, their incidence of cosmic rays is somewhat higher
13:05:57 <sorear> olsner: OK, you've raised your level of preparedness.  But not to infinity.  I bury your computer in lit thermite - does it still survive?
13:06:03 <DRMacIver> olsner: I agree. Smart dust is the way forwards. :)
13:06:18 <olsner> sorear: you forgot about the other 200 boxes of dust I have :P
13:06:23 <nominolo> in fact though, the CPU unit has an expected lifetime of 10000 years.  so it's not the weekest point ;)
13:06:30 <DRMacIver> sorear: Distribute your computer far enough and you'll be hard pressed to get enough thermite. :)
13:06:30 <kc5tja> sorear: It evolves into a higher being.  ;D
13:06:40 <jbauman> the smart dust magics away the aluminum and iron oxide from each other
13:07:01 <jbauman> DRMacIver: communication becomes a problem, though
13:07:25 <sorear> That said, Shannonnic preparedness functions have a strongly exponential bent.
13:07:35 <mux> erm, once I have used {#enum ...} with c2hs, how do I coerce the haskell type into the CInt expected by the C function?
13:07:42 <sorear> MTBF of ten trillion years is completely feasable.
13:07:53 <DRMacIver> jbauman: Not an insurmountable one, but yes.
13:08:01 <kc5tja> Shannonnic?  Sounds like a killer name for a band.  But I still prefer Holomorphism instead.
13:08:40 <kc5tja> MTBF of ten trillion years?  Easy.  Unfortunately, ALL of our last batch of equipment have had manufacturing defects which resulted in much shorter lifetimes.  :D
13:09:00 <DRMacIver> Anyway, this is silly. :) The only real point I'd like to make on this side of the argument is that while you can't prepare for everything, you can certainly prepare past the point where "What happend to my data??" is far from your biggest concern. :)
13:09:21 <kc5tja> Agreed.
13:09:30 <DRMacIver> My high profile banking app is not hardened against nuclear strike. I'll cope.
13:09:37 <kc5tja> If someone wants to write evil code, they _will_ write evil code, no matter what.
13:09:51 <kc5tja> DRMacIver: SHAME on you.
13:10:02 <mux> ah
13:10:07 <mux> fromIntegral.fromEnum it seems
13:10:16 <sorear> If someone wants to destroy the universe, OTOH, ...
13:10:17 <DRMacIver> kc5tja: In the event that a nuclear strike causes my code to fail, I promise I will take full and complete responsibility. ;)
13:10:26 <DRMacIver> sorear: Then they can sort their array in O(1) time!
13:10:34 <EvilTerran> catch (AlphaParticlesInTheFrontSideBusException) { ...
13:10:34 <kc5tja> DRMacIver: Or your money back!
13:10:49 <sorear> DRMacIver: No, you still need O(n lg n) iterations of a random number generator.
13:11:20 * kc5tja imagines QuickCheck simulating a nuclear blast against the code . . .
13:11:44 <DRMacIver> The other side of this is that once you've taken reasonable precautions you should assume things are going to go wrong anyway and prepare accordingly. :)
13:11:59 <sorear> Falsifiable; example: -1, GammaRayBurst, 0
13:12:13 <kc5tja> rotf!
13:12:20 <kc5tja> Yes, can't forget those GRBs.
13:13:02 <DRMacIver> sorear: Hm. O(n) time is presumably possible.
13:13:17 <kc5tja> You know, it would be interesting to correlate the relative rate of software failure on the day Supernova 1987A exploded versus days before or after.
13:13:27 <DRMacIver> sorear: In that you don't need to actually permute the array. You can just generate O(n) worth of random noise. :)
13:13:32 <kc5tja> (the idea being to measure the effect of neutrino bombardment on semiconductor technology)
13:13:36 <erider> hi kc5tja
13:13:38 * mux wonders why c2hs thinks the third parameter of some C function is CInt -> Ptr ()
13:13:46 <mux> it's an enum
13:13:56 <kc5tja> re erider
13:14:25 <erider> kc5tja: how is your project coming
13:14:42 <kc5tja> erider: Ask sorear -- he's making approximately 64x the headway with it than I am.  ;D
13:14:46 <mux> oooh, it's obviously me being stupid.
13:15:01 * kc5tja is thinking of just stea...er...using his code and attributing accordingly.  Hooray for open source.  :D
13:15:41 <kc5tja> Maybe I should just concentrate on the hardware design instead.
13:16:10 <jmanson> goodbye all. thanks for the help
13:17:43 <sorear> erider: http://members.cox.net/stefanor/x.png
13:17:53 <sorear> that's about what I've got atm ;)
13:18:26 <erider> sorear: are you and kc5tja working on the same thing
13:19:00 <dmwit> > pred 'A'
13:19:08 <lambdabot>  '@'
13:19:14 <dmwit> huh
13:19:22 <dmhouse> dmwit: in ASCII.
13:19:29 <dmwit> Yeah, I know.
13:19:29 <kc5tja> Sorear took an interest in the project independently of my working on it, but then he quickly surpassed me and made me look like a lazy bum (which I am).  ;D
13:19:40 <dmwit> I was trying to read something that was rot-1 encoded, but I was stuck on that one. ;-)
13:19:43 <dmhouse> > map toEnum [1..] :: String
13:19:52 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ET...
13:20:19 <dmwit> > map toEnum [64..] :: String
13:20:24 <Saizan> \EOT == End Of Time?
13:20:27 <erider> lol
13:20:30 <sorear> transmission
13:20:34 <lambdabot>  "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
13:20:38 <kc5tja> End Of Transmission actually, but I like End of Time better.
13:20:52 <Saizan> more dramatic.
13:21:04 <kc5tja> \ENQ = ENQuiring Minds want to Know.
13:21:07 <kc5tja> \ACK = Bill the Cat.
13:21:27 <dmhouse> Wow, there's an ACK character. Never knew that.
13:21:34 <kc5tja> And of course, \DCn for n={1, 2, 3, 4} is ANSI's preoccupation with airplanes at the time.
13:21:43 <kc5tja> There's also a \NAK too.
13:21:49 * dmhouse wonders how all these nonprinting characters managed to find its way into ASCII, but they couldn't fit £ in.
13:22:00 <dmwit> Americans.
13:22:02 * dmwit shakes his head
13:22:15 <dmhouse> kc5tja: what do those stand for?
13:22:16 <kc5tja> Actually, those characters exist only because the idea of a "network protocol" wasn't invented yet.
13:22:25 <kc5tja> SOH = Start of Header
13:22:28 <kc5tja> STX = Start of Text
13:22:32 <kc5tja> ETX = End of Text
13:22:35 <kc5tja> EOT = End of Transmission
13:22:41 <erider> sorear: are you using a layer of forth
13:22:44 <kpreid> dmhouse: iirc one was expected to use different encodings
13:22:44 <kc5tja> ENQ = HUH?  (Enquire -- specific meaning is application dependent)
13:22:50 <kc5tja> ACK = Acknowledge
13:22:56 <sorear> encryptio: huh?
13:23:01 <sorear> erider: huh?
13:23:06 <kc5tja> SO = Shift OUT -- go back to letters (for 5-bit teletype compatibility, I guess)
13:23:13 <davidL> syn/ack!
13:23:14 <kc5tja> SI = Shift IN -- Figures (see above)
13:23:15 <kpreid> there not being global networks at the time, local communication varying is reasonable
13:23:36 <kaol> if ASCII had , how many programming languages would use it as a special character?
13:23:37 <kc5tja> DLE = Data Link Escape -- an escape character for the ESC escape character (it gets confusing -- don't ask.)
13:23:44 <erider> I guess not
13:23:53 <kc5tja> DCn = One of four device modes of operation (kind of like USB's mode selection today)
13:24:08 <kc5tja> NAK = No Acknowledge/Negative/Go ask your father.
13:24:28 <sorear> DC2/4 are XON/XOFF.  go figure.
13:24:31 <jbauman> kaol: depends on whether keyboards have it
13:24:44 <sorear> erider: OK, you have me curious.  What's a "layer of forth"?
13:24:49 <jbauman> could fracture the programming community
13:25:01 <kc5tja> SYN = Synchronize -- this is the "link idle" character, sent whenever no actual data is being sent (remember, back in the day, before asynchronous communications, if you had nothing to send, machines were still whizzing their serial shift registers about.  SYN was the "I've nothing to send yet" character that filled these time gaps)
13:25:18 <sorear> Oh, I thought that was NUL
13:25:28 <kc5tja> NUL is a recent thing.
13:25:32 <jbauman> NUL might confuse the other computer
13:25:33 * sorear is a little mroe confused
13:25:38 <kc5tja> Yeah
13:25:43 <jbauman> think the connection had dropped, or something
13:26:00 <jbauman> depending on actual protocol
13:26:02 <kc5tja> See, this is what I mean -- these special codes all came about because of two things: (1) (R)TTY compatibility, and (2) lack of networking, but a clear need to network.
13:26:07 <sorear> Ah, so all bits zero looks like BREAK.
13:26:18 <kc5tja> Yes.
13:26:49 <kc5tja> What I find amazing, shocking even, is that Unix, DOS, and so forth all use different line ending characters.
13:27:21 <kc5tja> But, yet, there are \RS (Record Separator) and \FS (Field Separator) characters in there, which would do the job *PERFECTLY* and be completely agnostic of how text is actually rendered now-a-days.
13:27:26 <kc5tja> But, alas, oh well.
13:28:03 * kc5tja imagines pissing everyone off with the Kestrel, using \RS for line termination, and \FS for what Unix uses : for in /etc/passwd and shell environment variables.  :D
13:28:04 <jbauman> now we can use unicode line breaks as well
13:28:11 <jbauman> the question is which encoding
13:28:39 <kc5tja> There's also \US (Unit Separator) and one other, which i can't recall off the top of my head, but I'm not sure how to map those.
13:28:55 <kc5tja> Heh, Unicode is a mess, I think.
13:28:59 <sorear> what, CR (the word) isn't good enough?
13:29:14 <kc5tja> sorear: I'mtalking about storage and transmission formats.
13:29:43 <sorear> 64 character space padded lines!
13:29:44 <jbauman> paragraph separator, line separator, new lines, ...
13:30:16 <kc5tja> jbauman: Do they have section, chapter, and book separators too?  :)
13:30:23 <jbauman> probably
13:30:51 <sorear> Oh, you mean paragraph sepators aren't supposed to be inserted every 16 octets?
13:31:07 <kc5tja> Heh
13:31:18 <jbauman> depends on how long your paragraphs are
13:31:20 <kc5tja> Well, they certainly don't need page separators -- we have \FF for that.
13:31:31 <kc5tja> (I don't think he got it.  :D)
13:32:00 <sorear> I wonder what the best way to map Unicode onto BLOCKs is :)
13:32:09 <kc5tja> Heh, don't.  :)
13:32:31 <kc5tja> Define UBLOCKs instead, and ULOAD, UEDIT, etc. to edit the 16-bit wide equivalent of blocks.
13:32:58 <sorear> But then what will I do when the BMP is full? :)
13:33:09 <kc5tja> Although if Chuck Moore is any indication, it looks like he's going to surrender physical blocks in favor of logical blocks instead, choosing to let the editor do the work of translating representations.
13:33:34 <sorear> what are logical blocks?
13:33:43 <kc5tja> Whatever fits on the screen.  :D
13:34:17 <kc5tja> In the case of ColorForth, it's still 1024 bytes, but it's expressed as 256 32-bit words instead, each word containing a compressed representation of a word.
13:35:01 <davidL> > map (head &&& length) . group $ factors 2^2387
13:35:02 <lambdabot>   add an instance declaration for (Num [a])
13:36:00 <davidL> > factors 437
13:36:11 <lambdabot>  [19,23]
13:36:36 <davidL> > map (head &&& length) . group $ factors (2^2387)
13:36:46 <lambdabot>  [(2,2387)]
13:36:46 <dmwit> > [(2,2387)]
13:36:57 <lambdabot>  [(2,2387)]
13:37:02 <EvilTerran> @src factors
13:37:03 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:37:28 <davidL> dmwit: obviously ;)
13:41:06 <dmwit> > map (head &&& length) . group $ factors (2^2387+1)
13:41:22 <lambdabot>  thread killed
13:41:36 <EvilTerran> > unfoldr (return . join (,)) 1
13:41:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:42:18 <EvilTerran> ?src join
13:42:18 <lambdabot> join x =  x >>= id
13:42:46 <EvilTerran> i still don't quite get why  join f x = f x x
13:43:03 <Botje> ?src (>>=) ((->) r)
13:43:04 <lambdabot> Source not found. I feel much better now.
13:43:07 <Botje> bah.
13:43:25 <Botje> ?src ((->) r) (>>=)
13:43:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:43:26 <Jaak> @type join
13:43:29 <Saizan> it's the ((->) r) monad, join :: (r -> r -> a) -> (r -> a) here
13:43:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:43:30 <Botje> no. oh well.
13:43:37 <Jaak> @type \f x -> f x x
13:43:40 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
13:43:43 <Botje> EvilTerran: look up how >>= is defined for the ((->) r) monad, then work it out manually
13:43:46 <mux> dcoutts_: I think I'm hitting a bug in c2hs HEAD now
13:43:49 <EvilTerran> ah, okay
13:44:02 <EvilTerran> now I'm confused wrt (->) a being a monad O.o
13:44:10 <Saizan> :D
13:44:16 <Jaak> > join $ repeat [1]
13:44:17 <Botje> f >>= g is defined as \r -> g (f r) r
13:44:28 <Saizan> return = const
13:44:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:44:44 <Botje> if you take g = id
13:44:47 <Saizan> EvilTerran: you know the Reader monad?
13:44:51 <Botje> you get \r -> id (f r) r
13:45:00 <Botje> which is just f r r
13:45:01 <EvilTerran> Saizan, no...
13:45:12 <EvilTerran> but Botje's description is working well for me
13:45:18 <EvilTerran> (thanks Botje =])
13:45:27 <EvilTerran> > [1,1..]
13:45:28 <Botje> you're welcome.
13:45:35 <Botje> the ((->) r) monad can be tricky to get
13:45:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:46:02 <Saizan> well however the Reader monad in mtl is just a newtype over this
13:46:18 * EvilTerran should make a collection of all these different ways of doing (repeat 1)
13:46:40 <Saizan> > fix (1:)
13:46:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:47:00 <mux> > iterare (:1) []
13:47:05 <mux> > iterate (:1) []
13:47:09 <lambdabot>   Not in scope: `iterare'
13:47:13 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:47:14 <lambdabot>       Expected...
13:47:23 <dmwit> > iterate (1:) []
13:47:23 <EvilTerran> map (const 1) [1..]
13:47:34 <lambdabot>  [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1...
13:47:51 <dmwit> > iterate id 1
13:48:00 <sioraiocht> > :t const
13:48:00 <lambdabot>  Parse error
13:48:05 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:48:05 <sioraiocht> :t conste
13:48:08 <EvilTerran> > concat $ iterate (1:) []  -- =P
13:48:09 <sioraiocht> :t const
13:48:09 <lambdabot> Not in scope: `conste'
13:48:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:48:24 <lambdabot> thread killed
13:48:35 <EvilTerran> @type const
13:48:40 <lambdabot> forall a b. a -> b -> a
13:48:47 <sioraiocht> @src const
13:48:47 <lambdabot> const x _ = x
13:48:48 <dmwit> > fix . liftM . const $ 1
13:48:51 <sioraiocht> oh, lol
13:48:54 <lambdabot>   add an instance declaration for (Show (m a))
13:49:03 <dmwit> > fix . liftM . const $ 1 :: [Int]
13:49:09 <lambdabot>  Exception: <<loop>>
13:49:29 <kc5tja> gotta go for a bit.
13:49:31 <mux> const is the best function ever
13:49:36 <sioraiocht> so anyone have a good recommendation fo r abook on compilers?
13:49:37 <EvilTerran> no, id is!
13:49:50 * sioraiocht has pre-Masters reading to do.
13:49:54 <mux> I just love how it has two entirely different uses, both very valuable, when you only change the type signature
13:49:57 <LoganCapaldo> na uh
13:49:58 <dmwit> > liftM (const [1,1]) 32
13:49:58 <LoganCapaldo> S
13:50:03 <dmwit> > liftM (const [1,1]) [32, 33, 34]
13:50:05 <mux> @src asTypeOf
13:50:05 <lambdabot>   add an instance declaration for (Show (m [t]))
13:50:06 <lambdabot> asTypeOf = const
13:50:14 <lambdabot>  [[1,1],[1,1],[1,1]]
13:50:32 <EvilTerran> ...that's quite cunning, actually.
13:50:47 <dmwit> > fix (>>= const [1,1]) :: Int
13:50:53 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
13:51:02 <dmwit> > fix (>>= const [1,1]) :: [Int] -- geez, I suck
13:51:12 <lambdabot>  Exception: <<loop>>
13:51:56 <Adamant> sioraiocht, a good introductory general compiler book is "Engineering a Compiler"
13:52:08 <LoganCapaldo> > fix (>>= const [1])
13:52:15 <lambdabot>  Exception: <<loop>>
13:52:20 <Heffalump> sioraiocht: have you read the Dragon book?
13:52:28 <sioraiocht> Heffalump: the wha?
13:52:41 <Heffalump> google for it
13:52:48 <Heffalump> that's *the* starting compilers text
13:52:51 <Adamant> @google Engineering a Compiler
13:52:55 <lambdabot> http://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/155860698X
13:53:06 <Adamant> Heffalump, it's also older than dirt
13:53:21 <Adamant> Engineering a Compiler is newer and pretty good.
13:53:42 <sioraiocht> Adamant: a new edition of the dragon book was published in 06
13:53:47 <Heffalump> I've got that too and it's worth reading, but not over the dragon book.
13:53:50 <Adamant> sioraiocht, ah, it was?
13:54:10 <Adamant> ok, I did not know about that. I got Engineering a Compiler in '05
13:54:19 <Adamant> or so
13:54:26 <LoganCapaldo> Has <introductory level compiler knowledge> changed so much? I imagine they've been advances in compiler technology, but in the introductory stuff?
13:54:41 <Adamant> LoganCapaldo, nothing major, I think. just some things.
13:54:45 <LoganCapaldo> s/they've/there've/
13:54:47 <Heffalump> sorry, I'm wrong, I haven't got Engineering a Compiler, I just flicked through it some time ago. But it did look good.
13:54:49 <sioraiocht> Adamant: http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811/ref=pd_bbs_1/103-5428246-4885454?ie=UTF8&s=books&qid=1179089604&sr=1-1
13:54:53 <lambdabot> http://tinyurl.com/2zz8fv
13:55:10 <sioraiocht> LoganCapaldo: I think it's the reflex of any CS person that a book older than 5 years is too old, though ;)
13:55:43 <LoganCapaldo> sioraiocht: I don't seem to have that reflex. I must be flawed :)
13:55:45 <Adamant> sioraiocht, if there is a updated version of the Dragon book, it's probably worth getting
13:55:50 <Heffalump> that's a foolish reflex
13:55:56 <Heffalump> most good books in CS are >5 years old
13:56:23 <Adamant> well, the problem with the old Dragon book was that it was published in '86
13:56:28 <sioraiocht> Heffalump: I would say in terms of algorithms/math/complexity theory/theory of computation that's definitely the case
13:56:35 <Heffalump> Adamant: I don't see how that's a problem.
13:56:36 <Adamant> and compiler construction has advanced since then
13:56:44 <sioraiocht> Heffalump: I wouldn't conclude the same thing about an OS book
13:57:09 <edwinb> Computing, yes, 5 years may be too old, but not CS...
13:57:10 <sioraiocht> anyon read the compiler book written by Per Brinch Hansen?
13:58:10 <wolverian> stracing ghci shows a constant barrage of sigalrms. why?
13:58:19 <wolverian> or rather, what are they for?
13:58:22 <olsner> sioraiocht: "brinch hansen on pascal compilers"?
13:58:37 <davidL> stupid question but how can I keep track of how many times a function has run?
13:59:13 <wilx> Profiler?
13:59:16 <sioraiocht> olsner: I think he wrote another one, too..he teaches a compiler course at my uni and he uses his own textbooks exclusively
13:59:54 <wolverian> is it polling for user input instead of using select()?
14:00:23 <Heffalump> Adamant: the basics haven't really advanced, and the Dragon Book is an introductory text.
14:00:50 <Adamant> Heffalump, the front end hasn't changed much, but other parts have, IIRC.
14:01:08 <Adamant> not hugely
14:01:14 <Heffalump> Adamant: well, SSA is a major innovation that postdates it.
14:01:29 <Heffalump> But you still have to master the basics before you can understand that. And I don't think those have really changed.
14:01:39 <Adamant> just enough that some people would like to see an updated version.
14:05:05 <wolverian> looks like ghc compiled programs wake up on every tick
14:06:44 <Juerd> Hi - I have some processes running pugs that all get a constant flood of SIGALRMs. Is this normal GHC behaviour, and can anyone guess why this is done?
14:06:50 <Juerd> Approx. 18 signals per second
14:06:54 <Heffalump> it's normal behaviour, yes
14:07:02 <Heffalump> wolverian just mentioned it, in fact
14:07:13 <Juerd> Oh, heh, we were discussing the issue over at #perl6 indeed :)
14:07:32 <Heffalump> it's the interval timer, used for "context switching and profiling"
14:07:40 <Heffalump> quoting from http://hackage.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Rts
14:07:43 <lambdabot> Title: Commentary/SourceTree/Rts - GHC - Trac, http://tinyurl.com/ywq4ch
14:07:56 <Heffalump> if you google a bit you'll also find an acknowledgement from Simon Marlow that it's a bit of an abuse of SIGALRM
14:08:14 <Igloo> There's a bug open to replace it with another API
14:08:42 <Juerd> We have weird performance problems on a shared shell machine that happens to run a lot of pugs processes
14:09:03 <Juerd> And we were wondering if this could be causing it, as top, vmstat, iostat, etc. don't show any anomalies
14:09:14 <DRMacIver> I still find the idea of Perl6 implemented in Haskell really... odd. Not for any good reason though.
14:09:40 <Heffalump> I've never heard of it causing a problem.
14:09:48 <Heffalump> what are the performance problems?
14:10:17 <Juerd> Hard to describe :)
14:10:52 <Juerd> Most things go fast, but any substantial thing (compiling, apt-get, starting heavy processes, some CGI scripts like trac and jifty) goes very slow.
14:11:06 <Igloo> I don't think it should be a major performance problem; the problem comes if you want to use SIGALARM yourself
14:11:09 <Juerd> It's as if there's some threshold of activity above which things get slow.
14:11:36 <Igloo> I guess it's possible the kernel is task switching too much if you have lots of them
14:11:49 <jbauman> might be backgrounding your compiler
14:11:58 <jbauman> and lots of foreground haskell processes
14:11:59 <Juerd> There's about a dozen processes doing this constantly
14:12:04 <LoganCapaldo> Can you turn / does the SIGALRM get turned off?
14:28:02 <stepcut> yay! Finished updating my AGI library, now it is closer to being respectable
14:34:36 <Juerd> I'm sorry to say that killing a dozen "idle" pugses did seem to help
14:34:59 * Juerd doesn't know if that's a pugs trait or a ghc thing 
14:35:35 <jbauman> hmm, could try to comment out sigalrm in the source, as long as you're not threading or profiling
14:35:42 <jbauman> might even work
14:36:04 <Juerd> I think it's threading
14:36:13 <Juerd> audreyt: Does pugs thread?
14:36:17 <dcoutts_> mux: yeah? what's that?
14:36:38 <dcoutts_> mux: there are still plenty of c2hs bugs, just not in the C parser anymore I think.
14:36:54 <dmhouse> dcoutts_: when will the darcs version see a release?
14:37:06 <dcoutts_> dmhouse: dunno
14:37:25 <audreyt> Juerd: it does by default
14:37:34 <dmhouse> dcoutts_: moving from release -> darcs fixed my problem :)
14:37:44 <dcoutts_> good! :-)
14:37:59 <dcoutts_> dmhouse: it's mostly a matter of finding spare time to do testing and make a release
14:38:16 <dmhouse> dcoutts_: and do you have any plans to release the C parser as a seperate package? Having a rock-solid C parser would probably make lots of tasks more feasible.
14:38:30 <nominolo>  :t \f -> (++) *** (f.)
14:38:52 <dcoutts_> dmhouse: I did suggest on the libraries mailing list that someone should do just that, and gave a TODO list for such a project.
14:39:08 <nominolo> :t \f -> (++) *** (f.)
14:39:11 <lambdabot> forall a b c a1. (b -> c) -> ([a], a1 -> b) -> ([a] -> [a], a1 -> c)
14:40:04 <Juerd> audreyt: Okay, then I'll keep it as it is
14:40:19 <Juerd> audreyt: I've asked andara to make sure that his idle pugses get killed sooner
14:40:23 <nominolo> @pl \ys m' (xs,m) -> (xs ++ ys,m . m')
14:40:23 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (.)) . flip . (((.) . (,)) .) . flip (++)
14:40:23 <Juerd> audreyt: (runpugs)
14:40:30 <nominolo> wtf
14:41:03 <nominolo> @. unpl pl \ys m' (xs,m) -> (xs ++ ys,m . m')
14:41:04 <lambdabot> (\ ak f -> (\ p ad -> ((,)) ((fst p) ++ ak) (\ w -> ad (f w))) >>= \ aq -> snd >>= \ ao -> return (aq ao))
14:41:50 <nominolo> :t unpl pl \ys m' (xs,m) -> (xs ++ ys,m . m')
14:41:54 <lambdabot> parse error on input `\'
14:42:18 <nominolo> :t pl \ys m' -> (++ys) *** (.m')
14:42:22 <lambdabot> parse error on input `\'
14:42:29 <nominolo> :t \ys m' (xs,m) -> (xs ++ ys,m . m')
14:42:33 <lambdabot> forall a b c a1. [a] -> (a1 -> b) -> ([a], b -> c) -> ([a], a1 -> c)
14:42:34 <nominolo> :t \ys m' -> (++ys) *** (.m')
14:42:40 <lambdabot> forall a b c a1. [a] -> (a1 -> b) -> ([a], b -> c) -> ([a], a1 -> c)
14:49:12 <mux> dcoutts_: yeah, it's probably in c2hs -- it chokes everytime there's a "type" string in my .chs file
14:49:34 <dcoutts_> mux: @paste?
14:50:30 <mux> dcoutts_: I've had it when one of my function had a parameter named type, and also when I have a {#get Foo->type#} in the code
14:50:42 <mux> dcoutts_: what do you want to see? the error message?
14:50:56 <dcoutts_> mux: hmm, perhaps type is a token, lemme check...
14:51:37 <mux> because it's not really tied to the code, it seems it happens really everytime there's "type" in the file, wherever it is
14:51:41 <dcoutts_> mux: yeah, it's a c2hs reserved word so it gets confused
14:52:02 <mux> that's really annoying in the {#get Foo->type#} case
14:52:17 <dcoutts_> mux: it'd be good if it could accept it as an ordinary token in the helpful contexts
14:53:05 <dcoutts_> mux: it's the {# type ... #} hook.
14:53:18 <mux> dcoutts_: ?
14:53:45 <dcoutts_> mux: it's just one of the c2hs hook kinds, like {# call ... #} etc
14:54:00 <dcoutts_> mux: so to fix it...
14:54:40 <mux> what's a type hook and why are you talking about it? I'm lost once again :-)
14:55:07 <dcoutts_> mux: that's the reason that type is a keyword, because there's a type hook
14:55:15 <mux> oh, ok
14:55:22 <dcoutts_> mux: you probably want to hack C2HS.parsePath
14:55:47 <mux> this tokens should only get parsed as such when within {# ... #}
14:55:56 <Juerd>  /wc
14:55:58 <Juerd> hm
14:56:02 <Juerd> Ignore that :)
14:56:02 <dcoutts_> mux: add an extra clause for CHSTokType and treat it like CHSTokIdent "type"
14:56:46 <dcoutts_> mux: or yes, you could do something more sophisticated, I'm suggesting a 3 line hack.
14:56:59 <dcoutts_> mux: if you can make either work, send in the patch.
14:57:23 <mux> I have never used alex, so this is beyond me for now
14:57:37 <mux> were you suggesting to rename the "type" token to something else as a workaround?
14:57:38 <dcoutts_> mux: it's not alex, c2hs/chs/CHS.hs
14:58:05 <dcoutts_> mux: I was suggesting just interpreting the 'type' token as an ident inside the appropriate function
14:58:51 <mux> I don't get it, sorry :-)
14:58:54 <mux> an ident ?
14:59:07 <mux> oh
14:59:10 <mux> nevermind.
14:59:13 <dcoutts_> mux: actually it's this case you want to emulate:
14:59:14 <dcoutts_> parsePath' (CHSTokArrow pos:CHSTokIdent _ ide:toks)
14:59:26 <dcoutts_> mux: add a case for (CHSTokArrow pos:CHSTokType _ ide:toks)
14:59:43 <dcoutts_> and treat it like the case above
15:00:24 <dcoutts_> mux: see what I mean? it should be a quick & easy hack.
15:01:11 <ed1t> it just printed factorial of 100000!!!!!!!!!!!!!!
15:01:13 <mux> dcoutts_: I think I see what you mean WRT code hacking, but I don't get the code in question - not that I really need to
15:01:13 <ed1t> EUREKA!!!
15:01:24 <mux> dcoutts_: let me hack this and paste the patch so that you can tell me it's okay
15:02:16 <dcoutts_> mux: ok. That bit of code is just building an AST for C pointer derefencing expressions like: my_struct_ptr->field_name
15:02:58 <hpaste>  mux pasted "c2hs patch (broken)" at http://hpaste.org/1833
15:03:16 <mux> I just did a stupid code & paste somehow
15:03:17 <mux> c2hs/chs/CHS.hs:1116:28: Constructor `CHSTokType' should have 1 argument, but has been given 2 In the pattern: CHSTokType _ ide In the pattern: CHSTokType _ ide : toks In the pattern: CHSTokArrow pos : CHSTokType _ ide : toks
15:04:45 <hpaste>  dcoutts annotated "c2hs patch (broken)" with "simpler, and it might compile" at http://hpaste.org/1833#a1
15:04:59 <mux> cheers
15:05:02 <dcoutts_> np
15:05:21 <dcoutts_> mux: so try it, see if it works for you, if it does, send me the patch and I'll apply it.
15:05:41 <dcoutts_> you could add a comment saying what it's doing :-)
15:06:09 <mux> which I don't have the faintest clue about at this point, heheh
15:06:17 <mux> c2hs/chs/CHS.hs:1116:24: Conflicting definitions for `pos' In the definition of `parsePath''
15:07:01 <mux> there are two pattern matches with the same ident here
15:07:38 <mux> if not three, this code somewhat eludes me
15:09:26 <Saizan> CHSTokIdent takes 2 params, the first is the position maybe?
15:10:05 <Saizan> so: parsePath' (CHSTokArrow pos:CHSTokType pos':toks) = parsePath' (CHSTokArrow pos:CHSTokIdent pos' "type":toks)
15:12:23 <dcoutts_> Saizan: yes. mux ^^
15:13:03 <mux>     Couldn't match expected type `Ident' against inferred type `[Char]'
15:13:03 <mux>     In the second argument of `CHSTokIdent', namely `"type"'
15:14:11 <Saizan> :i Ident
15:15:46 <dcoutts_> ah, hmm, Ident
15:16:29 <dcoutts_> mux: use internalIdent
15:16:38 <dcoutts_> internalIdent :: String -> Ident
15:16:59 <dcoutts_> which you may need to import from Idents
15:17:21 <mux> so internalIdent "type" instead of "type" ?
15:18:48 <mux> that works
15:19:08 <mux> well that builds at least.
15:24:44 <mux> dcoutts_: I'm getting very weird errors now :-(
15:25:01 <dcoutts_> mux: oh :-(
15:25:22 <mux> it's not even finding the member name
15:28:36 <dcoutts_> mux: I'm not sure what's wrong, you could post the general problem of the 'type' token to the c2hs list.
15:29:36 <mux> dcoutts_: yeah, ok
15:33:35 <LoganCapaldo> @type let unmap f = (head . f) . (:[])
15:33:37 <lambdabot> <command line>:
15:33:38 <lambdabot>     Could not find module `L':
15:33:48 <LoganCapaldo> @type let unmap f = (head . f) . (:[]) in unmap
15:34:03 <lambdabot> thread killed
15:35:24 <LoganCapaldo> @type \f -> (head . f) . (:[])
15:35:39 <lambdabot> forall a a1. ([a1] -> [a]) -> a1 -> a
15:35:51 <szabi> Hi!
15:36:57 <szabi> I'm trying to compile GSLHaskell but it fails to build with: Not in scope: `getBounds'
15:37:10 <szabi> any idea whats the problem?
15:37:16 <LoganCapaldo> @type (\f -> (head . f) . (:[])) . map
15:37:30 <lambdabot> forall a b. (a -> b) -> a -> b
15:37:55 <dibblego> > let f = 42 in f
15:38:03 <lambdabot>  42
15:39:07 <dcoutts_> szabi: it's an incompatibility in the array lib between ghc-6.4 and ghc-6.6
15:39:22 * Philippa WTFs at a GHC error
15:39:42 <dcoutts_> szabi: so either you're using 6.4 and that prog wants 6.6, or the other way around.
15:39:56 <Philippa> correct me if I'm wrong, but: type synonyms are exactly that, and two type synonyms for String declared in different modules should still match okay, right?
15:40:34 <mauke> yeah
15:41:13 <Philippa> ...wait, the error message is even weirder than that
15:41:50 <Philippa> *aha*. Totally different error, but probably a bug to file re the error message
15:41:55 <szabi> dcoutts: I was worried that GSLHaskell is not maintained very well... Now it looks it's too well-maintained :)
15:41:59 <szabi> at least for me...
15:42:05 <Philippa> two different types with the same name from different modules, and it's not giving the qualifiers on them
15:43:01 <dcoutts_> szabi: just upgrade to 6.6, it's easy :-)
15:44:19 <matthew-_> does anyone know any more about this bug than is already in this bug?! http://hackage.haskell.org/trac/ghc/ticket/1241
15:44:21 <lambdabot> Title: #1241 (Functional dependency Coverage Condition is lifted, and should not be) -  ...
15:44:43 <matthew-_> in particulary, is -fallow-undecidable-instances not going to lift coverage condition?
15:45:06 <matthew-_> because if I turn it off in my code, I get /a lot/ of (the Coverage Condition fails for one of the functional dependencies)
15:46:16 <szabi> bye
15:46:32 <sorear> matthew-_: a way to relax the CC needs to stay, I told SPJ that myself a mother or two ago
15:46:42 <sorear> er, month.  what a typo
15:47:06 <sorear> since MTL fails with the CC
15:47:12 <matthew-_> yeah, I saw that
15:47:42 <matthew-_> right, and, (obviously, I must read the paper mentioned), the weak-coverage-condition - is that dependent on FDs of some sort?
15:49:42 * edwardk waves hello.
15:56:16 <Korollary> hi edwardk
15:59:04 <glen_quagmire> hi Korollary
16:06:14 <edwardk> heya korollary
16:06:21 <edwardk> went afk right after arriving =)
16:10:33 <edwardk> > let 1 + 1 = 3 in 1 + 1
16:10:39 <matthew-_> gah, what is it with recursive instance constraints and the coverage condition?
16:10:42 <lambdabot>  3
16:11:10 <Olathe> 2 + 2 = 5 is a much better one.
16:11:16 <edwardk> heh
16:12:22 <matthew-_> satisfying class constraints through induction on the structure of types and thus recursive constraints on instance declarations seems to really upset the coverage condition.
16:12:43 <kaol> > let 1 + 1 = 3 in 1 + 1 + 1
16:12:56 <lambdabot>   Non-exhaustive patterns in function +
16:13:20 <kaol> > let 1 + 1 = 3 in 1 + 1 - 1
16:13:25 <LoganCapaldo> > let _ + 1 = 3 in 1 + 1 + 1
16:13:32 <lambdabot>  2
16:13:37 <lambdabot>  3
16:17:25 <balodja> > let old_plus = (+); 1 + 1 = 3 in 1 `old_plus` 1
16:17:27 <sorear> matthew-_: ignore the CC
16:17:27 <lambdabot>  3
16:17:46 <sorear> matthew-_: use -fallow-undecidable-instances , for now
16:18:07 <sorear> matthew-_: having tasted turing completeness, I really doubt ghc will give it up
16:18:22 <edwardk> heh
16:19:37 <LoganCapaldo> > let old_plus = Prelude.+; 1 + 1 = 3 in 1 `old_plus` 1
16:19:37 <lambdabot>  Parse error
16:19:38 <edwardk> > let (.+.) = + in let 1 + 1 = 3; a + b = a .+. b in 1 + 1 + 1
16:19:38 <lambdabot>  Parse error
16:19:42 <edwardk> er
16:19:46 <LoganCapaldo> > let old_plus = Prelude.(+); 1 + 1 = 3 in 1 `old_plus` 1
16:19:47 <lambdabot>   Not in scope: data constructor `Prelude'
16:19:55 <edwardk> > let (.+.) = (+) in let 1 + 1 = 3; a + b = a .+. b in 1 + 1 + 1
16:20:00 <LoganCapaldo> > let old_plus = (Prelude.+); 1 + 1 = 3 in 1 `old_plus` 1
16:20:06 <lambdabot>  4
16:20:08 <lambdabot>  2
16:21:05 <LoganCapaldo> > let old_plus = (Prelude.+); 1 + 1 = 3 in (1 `old_plus` 1, 1 + 1)
16:21:15 <lambdabot>  (2,3)
16:24:03 <ozo> >let x+y=(Prelude.+ (Prelude.+ x y) 1) in 2+2
16:24:10 <ozo> > let x+y=(Prelude.+ (Prelude.+ x y) 1) in 2+2
16:24:12 <lambdabot>   add an instance declaration for (Num (t -> a))
16:24:38 <ozo> > let x+y=((Prelude.+) ((Prelude.+) x y) 1) in 2+2
16:24:46 <lambdabot>  5
16:26:02 <balodja> ozo: (Accountant.+) = ((Prelude.+) ((Prelude.+) x y) 1) :)
16:26:08 <matthew-_> sorear: is the weak coverage rule actually implemented in ghc 6.6?
16:26:24 * matthew-_ has been reading the paper...
16:26:31 <ozo> :-)
16:33:19 <sorear> matthew-_: I don't even know what the weak coverage rule is.
16:35:00 <matthew-_> sorear: ok, it seems to be todo with being able to say "well, the coverage condition isn't directly satisfied, but if you look at the other constraints around then it is actually satisfied"
16:35:02 <sorear> I don't think you should be worrying that ghc will start trying to protect you from yourself tommorrow.
16:35:34 <sorear> (Am I correct that this is just a paranoid attempt to futureproof?)
16:35:38 <matthew-_> no
16:36:37 <matthew-_> I'd like to know why certain instances I have blow up without -fallow-undecidable-instances with Coverage Condition failure errors.
16:37:16 <matthew-_> I think I know. And I think that they do satisfy weak coverage condition would
16:37:26 <matthew-_> s/would$//
16:37:50 <matthew-_> so I'm curious as to how far ghc got with the implementation
16:38:07 <matthew-_> from reading that trac bug, it sounds like weakcc isn't implemented
16:58:28 <monochrom> joyful
16:59:00 <sorear> hello
17:02:56 <TomMD> hi
17:11:03 <moconnor> I have a datatype which inherits from Show and implements its own show method.  Is there anyway, in ghci, to get at what would've been returned by the default show method had the datatype just used deriving (Show)?
17:11:47 <moconnor> IOW, in Perl speak, I want to Data::Dumper a variable but (show) is printing out something fancy, and I just want the nuts and bolts.
17:12:06 <mauke> don't override the default show
17:12:11 <TomMD> I believe Data.Generics is good.
17:12:13 <sorear> "inherits" from Show?
17:12:23 <TomMD> I think he ment derive?
17:12:24 <mauke> implements Show
17:12:29 <moconnor> sorear: yeah, I mean implements
17:12:38 <sorear> ah ok...
17:12:57 <kpreid> yes, if you derive Data and use gshow, you'll get an odd but generic result
17:13:35 <kpreid> of course, you *can* also write what would have been the derived instances of Show, as some other function than show
17:13:37 <sorear> You could hack derive, rename the Show class to ShowRaw, and use derive to derive ShowRaw for your type
17:13:59 <sorear> but that's probably too much work for an isolated use
17:23:19 <sioraiocht> wow I don't know what to do with myself,  I'm done with undergrad..
17:23:42 <LoganCapaldo> go to grad school.
17:23:45 <ddarius> moconnor: Incidentally, the show method that would be generated by derive isn't stored anywhere or anything.  If you make an instance of Show yourself, that's the show function.
17:23:46 <LoganCapaldo> get a job
17:23:55 <LoganCapaldo> go on a bender
17:23:55 <ddarius> Get married, have kids.
17:23:59 <monochrom> get married
17:24:25 <benny_> become a pole dancer
17:24:31 <monochrom> Go to an undemocratic country and start a revolution.
17:24:42 <ddarius> Go to a democratic country and start a revolution.
17:26:42 <LoganCapaldo> Go to a democratic country and stop a revolution
17:26:58 <igli> sioraiocht: get a job ;)
17:27:05 <igli> ++LoganCapaldo
17:27:13 <sioraiocht> igli: I have grad school, but not until october :)
17:27:41 <monochrom> cabalise every haskell library in sight.
17:28:03 <monochrom> complete the haskell wikibook
17:28:28 <TomMD> sioraiocht: You have a job?
17:28:41 <sioraiocht> TomMD: google summer of code
17:28:58 <igli> ah ok
17:29:04 <TomMD> Oh?  Which one?  I guess I immediately assume you will tell me and it is Haskell based.
17:29:33 <olsner> @hoogle Monad m => m (a->b) -> m a -> m b
17:29:34 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:29:35 <lambdabot> Prelude.const :: a -> b -> a
17:29:35 <lambdabot> Prelude.seq :: a -> b -> b
17:29:40 <sioraiocht> ahah TomMD no, the project of mine that was selected as actually in OpenSolaris.org, optimising FFT's used for lucas-lehmer primality testing
17:29:54 <mauke> @type ap
17:29:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:32:56 <sioraiocht> TomMD: I more wish I were using haskell, though.  using other programming languages makes me sad, I'm a totally a fanboy
17:36:21 <_frederik_> is ghc 6.6.1 missing a bunch of packages...? i just installed it and nothing compiles due to missing mtl, network, etc.
17:37:33 <slowriot> what is the haskell equivalent of !=
17:37:36 <slowriot> ?
17:37:42 <mauke> /=
17:37:44 <slowriot> thanks
17:37:51 <dibblego> ?hoogle a -> a -> Bool
17:37:52 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
17:37:53 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
17:37:53 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
17:38:14 <_frederik_> has anyone installed 6.6.1?
17:38:31 <mauke> yes, but I also got the extra libraries
17:38:41 <mauke> ghc-6.6-src-extralibs.tar.bz2
17:38:48 <mauke> make that 6.6.1
17:39:27 <_frederik_> so a bunch of stuff has been split off into that?
17:40:36 <agoode> ?hoogle (a * b list) -> a
17:40:36 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* b list) '
17:40:49 <agoode> ?hoogle (a -> b list) -> a
17:40:50 <lambdabot> Did you mean: (a -> b List) -> a
17:40:50 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
17:40:50 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
17:40:59 <agoode> ?hoogle (a -> b List) -> a
17:41:00 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
17:41:00 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
17:41:00 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
17:41:12 <mauke>  Libraries are now divided into core libraries (those that are necessary to build GHC) and extra libraries. Decoupling the extra libraries means that they can release independently of GHC releases, and makes development builds of GHC quicker as they no longer need to build unnecessary libraries.
17:41:24 <_frederik_> i see
17:41:30 <_frederik_> that's good
17:41:39 <mauke> agoode: this isn't OCaml
17:41:56 <_frederik_> but what is the debian package for the extra libs?
17:42:03 <mauke> no idea
17:42:37 <_frederik_> great
17:42:52 <_frederik_> any idea what this means: ghc-6.6.20070420: /home/frederik/lib/vectro-0.2/ghc-6.6.20070420/HSvectro-0.2.o: unknown symbol `vectrozm0zi2_VectorziBase_polyzuzuzu_closure'
17:42:59 <_frederik_> ?
17:43:06 <agoode> mauke: I know :) I slipped into SML
17:43:33 <_frederik_> what am i supposed to do with linker error messages like that?
17:44:35 <mauke> hmm... use the --make option?
17:45:01 <_frederik_> i did
17:45:22 <_frederik_> i mean, when i see the error, how do i read it and figure out what to do?
17:46:24 <sorear> _frederik_: haskell uses funny characters in names, so just like C++ it uses Name Mangling
17:46:37 <_frederik_> sorear: i know
17:46:57 <sorear> vectrozm0zi2_VectorziBase_polyzuzuzu_closure  is  package vector  module Vector.Base  symbol poly'''
17:47:15 <sorear> @google ghc z encoding
17:47:18 <lambdabot> http://darcs.haskell.org/ghc/compiler/utils/Encoding.hs
17:47:24 <sorear> gr.
17:47:36 <_frederik_> ok
17:47:48 <_frederik_> so what do i do?
17:47:51 <sorear> Oh wait, that *is* correct
17:47:58 <sorear> _frederik_: Use --make
17:48:02 <_frederik_> i did
17:48:21 <sorear> Ouch.  Sounds like ghc's .hi files are out of step with reality.
17:48:52 <sorear> that can happen if you upgraded vectro ...  ghc doesn't track versions of depended packages well
17:49:02 <_frederik_> A=bayesian-sets; ghc --make $A.hs -package vectro -lstdc++ -fallow-incoherent-instances
17:49:11 <_frederik_> i deleted all the .hi files i could find
17:49:39 <sorear> Sorry, poly___
17:50:04 <sorear> if you can reproduce it, please @bug
17:50:06 <sorear> @bug
17:50:07 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:50:11 <_frederik_> i just don't understand what the message means. is the symbol expected to be in the package? in the module? there is no 'poly' in the module
17:50:25 <_frederik_> is it expected to be in the program I'm compiling?
17:50:49 <sorear> _frederik_: it's just a link error.  it's expected to be *somewhere*
17:50:53 <_frederik_> i have sent something to the bugs list but i thought irc might know
17:50:57 <_frederik_> hmm
17:51:18 <sorear> _frederik_: ghc encodes locations in names, so looking at that name it could only validly come from the package
17:51:49 <_frederik_> ok
17:52:02 <_frederik_> why isn't there a ghcbug command?
17:52:07 <sorear> _frederik_: don't send messages to glasgow-haskell-bugs@haskell.org
17:52:18 <_frederik_> why?
17:52:24 <sorear> _frederik_: anything sent there will be read and forgotten
17:52:38 <_frederik_> they have been helpful
17:52:42 <sorear> _frederik_: since there is no list of "things that have been mentioned"
17:52:43 <_frederik_> i don't have time to submit web bugs
17:52:54 <sorear> !?
17:53:04 <SamB_XP_> _frederik_: then the GHC team hasn't got time to fix them
17:53:36 <_frederik_> they should distribute a ghcbug program
17:53:52 <_frederik_> SamB_XP_: usually that is the case anyway
17:54:12 <sioraiocht> is there hex notation for numbers in haskell
17:54:25 <mauke> > 0x123
17:54:25 <_frederik_> SamB_XP_: and i don't see why i shouldn't report something that is wrong. it's either by mailing list or nothing at all, the former seems better. honestly
17:54:30 <lambdabot>  291
17:54:55 <sioraiocht> thanks
17:56:11 <SamB_XP_> _frederik_: how long does it take to write a web bug?
17:56:33 <sorear> it's just as easy as mailing for me
17:56:59 <sorear> then again my webbrowser has the amazingly cool feature of F4-to-open-textarea-in-$EDITOR
17:57:21 <LoganCapaldo> sorear: which browser is that?
17:57:23 <_frederik_> sorear: exactly. it's just not something i make a hobby of
17:57:24 <sorear> elinks
17:57:40 <LoganCapaldo> mm
17:57:55 <mauke> my browser has the amazingly cool feature of using $EDITOR for all textareas
17:58:07 <sorear> no javascript, though
17:58:13 <LoganCapaldo> mauke: what browser is that?
17:58:16 <mauke> w3m
17:58:34 <LoganCapaldo> mm
17:59:18 <cdsmith> mm?
17:59:46 <LoganCapaldo> cdsmith: it's a noise :) its means I really really like that
17:59:51 <LoganCapaldo> BUT
17:59:58 <LoganCapaldo> heh
18:00:20 <cdsmith> I guess I need to go read the logs.
18:00:36 <LoganCapaldo> huh?
18:00:56 <cdsmith> I just walked into the middle of something; that's all.
18:01:01 <LoganCapaldo> ah
18:01:06 <LoganCapaldo> oh
18:01:12 <LoganCapaldo> I just noticed when you joined
18:01:16 <LoganCapaldo> it was right before mm
18:01:22 <LoganCapaldo> that musta been really confusing
18:01:26 <cdsmith> :)
18:01:58 <mauke> the line before it was "w3m"
18:02:17 <cdsmith> ?go w3m
18:02:19 <lambdabot> http://w3m.sourceforge.net/
18:02:19 <lambdabot> Title: W3M Homepage
18:05:53 <_frederik_> ah, deleting the installed library directory seems to help
18:06:05 <_frederik_> it would be nice if dependency checking worked
18:08:05 <sioraiocht> is there any easy way to convert a string to a binary representation?
18:08:39 <TSC> sioraiocht: A string containing what?
18:08:51 <sioraiocht> TSC: Arbitrary text
18:09:24 <TSC> And what do you want the output to look like?
18:09:39 <sioraiocht> eventually organise it into 512-bit chunks
18:09:53 <sioraiocht> as a list
18:10:27 <TSC> > map ord "hello"
18:10:34 <lambdabot>  [104,101,108,108,111]
18:10:38 <TSC> Like that?
18:10:39 <sioraiocht> I figured that would be a good starting place
18:10:41 <sioraiocht> yeah
18:10:55 <cdsmith> ls
18:10:58 <cdsmith> oops
18:11:00 <sioraiocht> haha
18:11:04 * sioraiocht has so done that
18:11:13 <TSC> Then you could truncate the ints into Word8s, if you know they'll fit
18:11:18 * cdsmith has done it twice now
18:15:09 <sorear> Someone once did
18:15:10 <sorear> su root
18:15:21 <sorear> unfortunately, they caught on quicky :)
18:15:40 <sorear> another time someone did /me ickserv identify <password>
18:16:31 <cdsmith> Well, I'll never make that mistake again.
18:16:32 * cdsmith 's nose grows an inch longer.
18:17:37 <jcreigh> that's why I have an /alias idenity for that...
18:18:20 <sorear> I have it as an -autosendcmd
18:18:39 <jcreigh> sorear: sure, but sometimes my connection drops, and irssi reconnects me as jcreigh_
18:20:10 <sorear> I have sorear_ registered with the same password.
18:20:22 <sorear> so it all just works
18:20:28 <jcreigh> heh. one step ahead of me.
18:20:32 <sorear> actually it's a LINKd nick
18:20:40 <olsner> I'd like haskell to have a symbol that makes any expression into a lambda expression, i.e. (\x -> f x y z) becomes f _ y z or something
18:20:59 <sorear> olsner: that plays nasty with currying
18:21:08 <jcreigh> oh, so if you're a fan of the (silly IMO) _home or _away nicks, you can link it to your regular nick?
18:21:09 <slowriot> Is there a clean way of dealing with Maybes that you know are Justs?
18:21:19 <sorear> f X Y == (f X) Y  is true in haskell
18:21:21 <sorear> jcreigh: yeah
18:21:31 <sorear> slowriot: fromJust :)
18:21:35 <sorear> @quote unJust
18:21:36 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
18:21:49 <sorear> BUT, if we had olsner's _
18:22:08 <olsner> hmm, yeah, thinking about how it could play nice with currying
18:22:16 <slowriot> okay, thanks
18:22:17 <sorear> f _ 2 = \x -> f x 2   /=   (f _) 2 = (\x -> f x) 2 = f 2
18:23:02 <jcreigh> slowriot: be careful with that function. You can create hard to find bugs when your program starts failing with "fromJust: Nothing". So be sure that you really know that they are Justs.
18:24:33 <slowriot> jcreigh: okay
18:24:41 <olsner> it would probably require the parser to recognize groups of function applications as f(x,y,z) before recognizing implicit lambda or whatchamacallit, then going back to the form it's in now
18:25:19 <olsner> so f _ 2  => f(_,2) => (\x -> f x 2)
18:25:50 <igli> does that seem useful then sorear?
18:56:44 <TomMD> @seen lambdabot
18:56:44 <lambdabot> Yes, I'm here. I'm in #xmonad, #unicycling, #perl6, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #scannedinavian
19:01:36 <olsner> @users
19:01:36 <lambdabot> Maximum users seen in #haskell: 336, currently: 296 (88.1%), active: 33 (11.1%)
19:23:10 <cdsmith> With a browse, ghci says, error :: forall (a :: ?). [Char] -> a.  What does the "a :: ?" mean?
19:24:29 <sorear> Deep black magic
19:25:05 <cdsmith> Umm, does this magic have a name I could google for?
19:25:44 <ddarius> polymorphic kinds
19:25:52 <cdsmith> thanks
19:25:55 <igli> heh way to kill a discussion igli ;)
19:25:58 <sorear> nah, not polymorphic - subkinding!
19:26:18 <ddarius> But it would be better to just browse the GHC User Guide.
19:26:24 <sorear> normally type variables can only be 'normal' types, like Int
19:26:45 <sorear> since normal types are pointers, and pointer v. non-pointer needs to be consistent for the GC
19:26:51 <sorear> error is different
19:26:55 <cdsmith> So a can have a type constructor as its type?
19:27:27 <sorear> because error never returns, it can safely be instantiated at unboxed type!
19:27:28 <sorear> if it did return, the GC would crash.  but it doesn.t
19:27:33 <sorear> no, it's * or #
19:27:38 <sorear> * = regular types
19:27:41 <sorear> # = unboxed types
19:27:47 <cdsmith> Oh.  I don't know about #
19:28:02 <sorear> but instead of kind classes, we have a watered-down subtyping system
19:28:21 <sorear> if you're familiar with OOP, subtypes should make perfect sense
19:28:29 <sorear> ? is the common supertype of * and #
19:28:31 <cdsmith> I am familiar with oop and subtyping.
19:28:36 <sorear> ? is *not* a supertype of * -> *
19:28:51 <cdsmith> okay, I see.
19:28:51 <sorear> so (error "fpp" :: Maybe) is ill-kinded
19:29:11 <sorear> but (error "" :: Int#) is fine, as is (error "" :: [Char])
19:29:35 <igli> so boxed=ptr?
19:29:39 <sorear> yeah
19:29:43 <igli> ty
19:29:51 <cdsmith> So it's the # stuff I don't get yet, but I'll read the user guide.
19:29:55 <sorear> actually it's just a wee bit more subtle
19:29:57 <sorear> Int# is int
19:30:03 <sorear> Int is int(*)()
19:30:10 <igli> oic
19:30:21 <igli> makes sense
19:30:35 <sorear> all haskell types like Int are both boxed and lifted - they are function pointers, called when the value is needed
19:30:45 <igli> with the return part i mean ;)
19:30:48 <sorear> Int# is not boxed or lifted, it's just a machine int
19:30:53 <sorear> -but-
19:31:02 <sorear> ByteArray# is in the middle
19:31:09 <sorear> it is boxed, but not lifted
19:31:12 <sorear> it's a C char*
19:31:21 <sorear> so it's a pointer, and the GC should follow it
19:31:21 <igli> so not lazy eval?
19:31:24 <sorear> but not lazy
19:31:32 <igli> ok
19:31:56 <igli> man the impl sounds more basic than i thought
19:32:40 <sorear> one of the IMO most elegant tricks in GHC is that laziness is ONLY used for user defined types, and forcing is ONLY done using case analysis
19:32:57 <blackdog> hey, is there an implementation of 'read' that returns a result as a Maybe rather than just crapping out if it can't parse it?
19:32:57 <igli> what would you call olsner's _ operator?
19:33:05 <sorear> in Yhc, Int etc is lazy, so we need EVAL pseudoops and other kludgery
19:33:05 <ddarius> reads
19:33:18 <sorear> but in GHC, (+) just uses case
19:33:34 <ddarius> or more to the point fmap fst . listToMaybe . reads
19:33:46 <igli> but haskell types are called when needed?
19:33:48 <blackdog> cheers ddarius
19:33:48 <sorear> (+) x y = case x of { I# x# -> case y of { I# y# -> I# ((+#) x# y#) } }
19:33:50 <sorear> igli: yeah
19:34:08 <igli> but not lazy?!
19:34:15 * igli is confused
19:34:39 <sorear> GHC's basic types are not lazy - the standard library implements lazy wrappers.
19:34:49 <igli> ok
19:38:26 <igli> sorry got distracted by version request from freenode.connect (stats)
19:38:27 <cdsmith> > case 5 of I# x# -> I# (x# +# 1#)
19:38:27 <lambdabot>  Parse error
19:38:27 <cdsmith> Hmm.
19:38:27 * igli goes to read some more haskell docs
19:38:27 <sorear> cdsmith: lambdabot is set up to fail on seeing ghc magic
19:38:27 <cdsmith> Oh, okay.
19:38:27 <cdsmith> Ah, works in GHCi
19:47:19 <davidL> does haskell support the importing of files?
19:47:47 <sorear> "importing"?
19:47:53 <sorear> readFile ityw
19:47:57 <sorear> @ty readFile
19:47:59 <lambdabot> FilePath -> IO String
19:47:59 <davidL> no
19:48:13 <sorear> ITC, "import Foo"
19:48:32 <davidL> I have a haskell file with a bunch of functions that I want to import into another program
19:49:10 <cdsmith> @karma+ sorear
19:49:11 <lambdabot> sorear's karma raised to 44.
19:49:14 <sorear> use foreign export then?
19:49:43 <davidL> thanks
19:50:32 <davidL> actually
19:50:45 <davidL> I want to use it in another haskell program
19:51:58 <davidL> or do I have to compile it, install it as a package, and then import it normally?
19:52:18 <cdsmith> davidL: If it's in the same directory, you can just import it.
19:52:27 <davidL> hm
19:52:41 <cdsmith> or use -i option to GHC
19:52:50 <davidL> GHCi says parse error
19:52:57 <sorear> davidL: ?
19:53:45 <davidL> I have import "test.hs"
19:53:59 <sorear> davidL: ghci only takes expressions.  peyton-jones et al won't implement support for topdecls like 'import Foo', instead we have hacks like ':m + Foo'
19:54:08 <cdsmith> Call it Test.hs, then just: import Test
19:54:08 <sorear> davidL: you need import Test
19:58:37 <sorear> Woah!
19:58:48 <sorear> irssi accepted /wg kc5tja
19:58:50 <davidL> ah that worked thanks cdsmith and sorear
19:58:54 <sorear> yw.
19:59:08 <igli> wtf is /wg?
19:59:17 <falconair> it seems bytestring and binary serialization are not part of hoogle ... are they supposed to be added eventually?
19:59:21 <davidL> sorear: what irc client did you use before irssi?
19:59:31 <sorear> igli: /window goto, an alias...
19:59:36 <igli> ah ok
19:59:42 <sorear> davidL: ERC, then irssi, than ircii
19:59:46 <igli> gui ftw ;)
20:00:02 <sorear> hey, I use gui too
20:00:06 <davidL> ii is great
20:00:21 <davidL> you can write irc bash scripts
20:00:41 <sorear> i'm guessing it doesn't have a lot of my favorite features, like autologging :)
20:01:25 <igli> konversation rocks man
20:06:53 <sorear>  3987 stefan    15   0 11452 5016 2304 S  0.0  1.3   0:00.63 xterm
20:06:53 <sorear>  6980 stefan    15   0  7084 4912 2716 R  0.0  1.3   0:00.87 pterm
20:06:56 <sorear> nice...
20:08:04 <sorear> so, a GTK+ terminal emulator originally written to run on Windows uses almost 30% less memory than a native X11 one.
20:08:21 <olsner> that's just crazy
20:08:41 <TSC> chris     3625  0.2  2.1 123164 19184 tty1     Sl   13:00   0:01 gnome-terminal
20:08:48 <TSC> I win
20:08:58 <sorear> which of those numbers is VIRT?
20:09:04 <TSC> 123164
20:09:26 <sorear> Your terminal emulator wants 123M!?
20:10:25 <TSC> Apparently
20:10:36 <TSC> I guess that includes a lot of the shared gnomey things
20:10:53 <sorear> Something tells me shared mappings would be in SHR :)
20:11:07 <davidL> is there a better way of testing a list's uniqueness other than <psuedocode> all (1==) . map length. group . sort ?
20:11:28 <sorear> hmm I wonder what /proc/3625/smaps says
20:12:05 <cdsmith> davidL: lst == nub lst would be shorter, anyway.
20:12:40 <sorear> ap(==)nub ftw
20:12:53 <TSC> sorear: There are many shared things there
20:13:13 <sieni> sorear: was that Linux? I think VIRT includes all shared libraries and such, which might be quite a bit if the app uses quite a bit of gnome libraries
20:15:13 <sorear> 123MB of libs is still ridiculous.
20:15:21 <cdsmith> VIRT = The total amount of virtual memory used by the task.  It includes all code, data and shared libraries plus pages that have been swapped out.
20:15:27 <cdsmith> From 'man top'
20:15:37 <SamB_XP_> sorear: apparantly Visual Studio ships with gigabytes of libraries...
20:17:02 <sieni> sorear: try ldd /your/binary/here
20:17:52 <sorear> stefan@stefans:~$ cat /proc/6980/smaps | grep -A1 .w.p | grep Size | sed 's/Size: *\([0-9]*\) kB/\1/' | perl -e 'while(<>){$t+=$_}print $t,"\n"'
20:17:56 <sorear> 2312
20:17:58 <sorear> pterm
20:18:19 <sorear> stefan@stefans:~$ cat /proc/3887/smaps | grep -A1 .w.p | grep Size | sed 's/Size: *\([0-9]*\) kB/\1/' | perl -e 'while(<>){$t+=$_}print $t,"\n"'
20:18:19 * araujo next to give it a try to this xmonad thing
20:18:22 <sorear> 2968
20:18:25 <sorear> xterm
20:18:41 <sorear> so even if you just count private writable mappings, pterm comes out well ahead
20:19:12 <sorear> stefan@stefans:~$ ldd `which xterm` | wc -l
20:19:12 <sorear> 22
20:19:12 <sorear> stefan@stefans:~$ ldd `which pterm` | wc -l
20:19:12 <sorear> 14
20:19:49 <sorear> trading out a dozen X libs for gtk and gdk
20:22:01 <jmanson_> hello everyone
20:22:07 <olsner> gtk and gdk probably uses those same libs though
20:22:41 <jmanson_> how do you set the type of a variable in ghci?
20:23:08 <cdsmith> @ty let { x :: Int ; x = 5 } in x
20:23:10 <lambdabot> Int ; x = 5 } in x :: Int
20:23:44 <igli> omg sorear what is that line of sh?
20:24:00 <jmanson_> what does the @ty mean?
20:24:06 <cdsmith> jmanson: so you can specify the type in a let statement.  Is that what you wanted?
20:24:07 <ddarius> @type id
20:24:12 <lambdabot> forall a. a -> a
20:24:21 <sorear> igli: a pipeline.  feed the output of ldd into wc -l
20:24:31 <sorear> igli: it's like backward $ in haskell
20:24:48 <jmanson_> cdsmith: yes, that is what I wanted
20:25:09 <igli> sorear: useless use of cat, you could also prob'y do it all with sed or awk
20:25:33 <igli> sorry too much #bash :)
20:25:39 <jmanson_> I'm confused about what the in part means
20:25:40 <cdsmith> > let (|) = flip ($) in "test" | head | toUpper
20:25:41 <lambdabot>  Parse error
20:26:01 <cdsmith> > let ($|) = flip ($) in "test" $| head $| toUpper
20:26:02 <jmanson_> let x = 5 in x
20:26:16 <lambdabot>  'T'
20:26:28 <ddarius> jmanson_: It delimits the scope x is defined in.
20:26:54 <narain> ?seen syntaxfree
20:26:54 <lambdabot> I saw syntaxfree leaving #haskell 7h 35m 44s ago, and .
20:26:55 <jmanson_> ok, so if there is no in statement, x will be global?
20:27:21 <sorear> igli: I don't care.
20:27:28 <ddarius> For expressions, there can't be no in statement.
20:27:31 <sorear> igli: it's not like I'm going to maintain it!
20:27:41 <cdsmith> jmanson_: in GHCi, yes sort of.  Let without in only works in a monad.
20:27:48 <ddarius> Do notation has syntactic sugar that omits the 'in' but it desugars to a normal use of 'in'
20:27:50 <igli> sorear: ah man was gonna say sure
20:28:42 <jmanson_> so, in a monad will the thing defined in let be only available after the let statement?
20:29:01 <cdsmith> yes
20:29:13 <cdsmith> in do-notation, as ddarius said, is a better way to express it
20:29:55 <jmanson_> cool. does that mean that ghci commands are all enclosed within a monad?
20:30:02 <cdsmith> the IO monad
20:30:08 <ddarius> do let a = 3; x <- f a; return x <-> let a = 3 in do x <- f a; return x
20:30:13 <ddarius> Yes.
20:30:38 <cdsmith> @undo do { let x = 5; foo x }
20:30:39 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 23}) "Parse error"
20:30:43 <ddarius> It's a cheap way of getting some of the stuff you want in an interactive environment without doing a proper job.
20:30:53 <cdsmith> @undo do { let {x = 5}; foo x }
20:30:53 <lambdabot> let { x = 5} in foo x
20:31:27 <cdsmith> jmanson_: those are equivalent, basically
20:31:31 <jmanson_> what happens then when you evaluate a normal statement that has nothing to do with the IO monad in ghci?
20:31:44 <cdsmith> it adds a "print" automatically
20:31:50 <igli> sorear: i do hope you don't take that approach to all your code ;P
20:31:57 <narain> ?undo \f x -> do {y <- x; let {z = f y}; return z}
20:31:57 <lambdabot> \ f x -> x >>= \ y -> let { z = f y} in return z
20:31:58 <sorear> like I was saying; augustss perfected this ten years ago and spj apparently isn't even competent to clone
20:32:11 <ddarius> jmanson_: It can tell by the type.
20:32:47 <xDie> hi all
20:32:56 <sorear> Hello xDie
20:33:05 <xDie> hello sorear
20:33:06 <xDie> :)
20:33:10 <xDie> a question
20:33:29 <xDie> im fanatic of bot lambdabot
20:33:36 <sorear> ask it
20:33:56 <sorear> ask the question, I mean
20:34:06 <xDie> you can gimme space to server
20:34:19 <xDie> i have a channel about dreamlinux
20:34:28 <xDie> wen need a bot
20:34:34 <xDie> you can helpme
20:34:37 <sorear> Is it on freenode?
20:34:53 <jmanson_> what do you do if you want to set the type of multiple variables at the same time?
20:35:06 <sorear> xDie: where do you want lambdabot?
20:35:08 <xDie> sorear yes
20:35:11 <xDie> yes
20:35:44 <sorear> @join #dreamlinux
20:35:57 <xDie> aa
20:35:59 <xDie> okis
20:36:04 <xDie> thanks!!!
20:36:09 <gkr> @pl (\x y -> ((elem x) (fst (unzip y)))
20:36:10 <lambdabot> (line 1, column 36):
20:36:10 <lambdabot> unexpected end of input
20:36:10 <lambdabot> expecting variable, "(", operator or ")"
20:39:08 <xDie> sorear, the channel no is it
20:39:08 <narain> ?pl \x y -> elem x . fst $ unzip y
20:39:09 <lambdabot> (. unzip) . (. fst) . elem
20:39:16 <xDie> sorry i canfused
20:39:26 <xDie> the channel is #dreamlinux-es
20:39:32 <xDie> you can change?
20:39:36 <sorear> @join #dreamlinux-es
20:39:48 <sorear> @part #dreamlinux
20:40:05 <jmanson_> So, the reason I was asking about setting the type in ghci is that I was hoping that would help in a problem I was having to get a program to compile.
20:40:08 <xDie> sorear thanks
20:40:13 <sorear> yw.
20:40:32 <jmanson_> I'm trying to write a simple little game as a learning exercise for Haskell.
20:40:42 <cdsmith> jmanson_: hpaste the code?
20:40:47 <cdsmith> ?paste
20:40:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:41:07 <jmanson_> Ok. It uses hsSDL.
20:41:31 <cdsmith> ?where hsSDL
20:41:31 <lambdabot> http://darcs.haskell.org/~lemmih/hsSDL
20:41:52 <hpaste>  jmanson_ pasted "(no title)" at http://hpaste.org/1835
20:42:49 <jmanson_> I have a feeling I will need a lot of help as I work on this project :)
20:43:04 <jmanson_> Right now, the problem is with dividing by 2
20:43:07 <erider> good night all
20:43:39 <jmanson_> I want to place a bitmap in the center of the screen, and so want to divide the width,height by 2
20:43:53 <jmanson_> division doesn't work, but subtraction does!
20:44:33 <cdsmith> jmanson_: a guess, use `div` instead of / (note those are back ticks around div)
20:44:43 <jmanson_> what is the difference?
20:45:00 <jbauman> :t div
20:45:01 <cdsmith> '/' gives a Fractional result
20:45:02 <lambdabot> forall a. (Integral a) => a -> a -> a
20:45:08 <jbauman> :t (/)
20:45:17 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:45:34 <jmanson_> Oh... that makes sense with the error message I was getting
20:45:38 <jmanson_> thanks
20:45:58 <cdsmith> yw
20:46:23 <jmanson_> sweet. I just tried it and it worked
20:46:29 <cdsmith> I'm glad.
20:46:58 <jmanson_> HAHA. Now, is when my real problems are going to start.
20:47:21 <jmanson_> Somehow I need to add state to the game.
20:47:42 <jmanson_> Player position that can be modified would be a good start.
20:47:44 <jbauman> yay IORef
20:48:02 <jbauman> although using a main loop like you do...
20:50:00 <jmanson_> I'm not sure what other method there is other than a main loop. In the end I want to make sure that everything takes uniform time steps.
20:50:25 <jmanson_> For example, make sure that if I add physics of some sort that it goes at 100 physics steps per second.
20:51:36 <jbauman> yeah, the explicit main loop is normal with SDL
20:51:43 <cdsmith> jmanson_: 10 millissecond maximum delay might be asking a bit much of garbage collection.
20:52:11 <jmanson_> That isn't necessary. It just has to have 10 ms average delay.
20:52:20 <cdsmith> ok, good.
20:52:29 <jmanson_> It will be annoying if the game hiccups every once in a while, but isn't a big problem.
20:52:42 <igli> you're in the wrong lang if you are serious about a game imo
20:52:48 <jmanson_> Honestly, I doubt that this particular project will have physics concerns at all.
20:52:54 <igli> and if it's just a learning exercise..
20:53:25 <igli> k
20:53:46 <jmanson_> It's a learning exercise, but I want to exercise the language enough that I can know what I/it are capable of.
20:54:28 <jmanson_> I already have a fair bit of experience with C++, so it will mostly be about learning the language.
20:54:46 <ddarius> No.  It is the pair of you together.
20:54:58 <igli> heh
20:55:28 <ddarius> It's possible to produce high performance code with Haskell, but if you don't know what you're doing it's quite easy to produce ridiculously slow code as well.
20:55:33 <jmanson_> I have heard reports that Haskell is half the speed of C.
20:56:00 <jcreigh> jmanson_: it depends. it always depends.
20:56:12 <ddarius> Haskell is faster than C in some cases.
20:57:23 <igli> just treat it like java
20:57:39 <cdsmith> igli: you mean scream in frustration?
20:57:44 <igli> heh
20:57:55 <jmanson_> I like haskell because it really does seem more expressive for some domains. Specifically, I have played around with some fourier series and it just feels more natural.
20:57:57 <igli> i meant: which of course requires knowing when stuff will be instantiated
20:58:01 * cdsmith is an ex-java bigot.
20:58:12 <igli> (and released)
20:58:35 <dibblego> cdsmith, did you once post on JavaRanch a lot?
20:58:38 <jmanson_> The question to me though is if it can be used as a general purpose language
20:58:40 <dibblego> cdsmith, or was it usenet?
20:58:47 <cdsmith> dibblego: no, but yes usenet
20:58:48 * igli started writing a couple of java mobile games before divorce ;)
20:58:51 <ddarius> jmanson_: Of course it can.
20:58:52 <dibblego> cdsmith, I remember you :)
20:59:03 <ddarius> jmanson_: What domain do you think it targets?
20:59:16 <igli> jmanson_: it's more general purpose than any other
20:59:23 <cdsmith> dibblego: that could be good or bad...
20:59:29 <igli> lol
20:59:34 <dibblego> cdsmith, I only remember your name :)
20:59:43 <igli> he had a smiley ;)
21:00:09 <igli> i remember igli >:(
21:00:51 <jmanson_> Honestly, I'm not sure what it targets. It looks similar to mathematical notation, so I suppose mathy things :)
21:01:18 <igli> jmanson_: it's the best language for financial and legal apps imo
21:01:30 <igli> (get your head round that ;)
21:01:47 <ddarius> jmanson_: It's meant to be a general purpose language and has been applied to a wide variety of programs.
21:01:48 <shapr> I think it's the best language for web development.
21:02:21 <igli> how so shapr?
21:03:12 <shapr> I think Haskell is more general than Python or Java.
21:03:48 <jmanson_> Something that I don't understand is if you can't modify variables and have to create new ones instead all of the time, how is memory not filled up? I suppose old things aren't referenced any more, then garbage collected, but doesn't that put a big strain on memor9y allocation/deallocation?
21:04:07 <SamB_XP_> jmanson_: somewhat
21:04:08 <jmanson_> In C you just overwrite the variable, no extra mem needed.
21:04:11 <shapr> Also, Haskell is built so close to its essence that it's easy to modify it do whatever you want.
21:05:17 <shapr> Haskell lends itself well to domain specific languages, and I think that's about as powerful as you can get.
21:05:19 <davidL> > isPrime 123456789
21:05:22 <lambdabot>  False
21:05:34 <narain> ?index isPrime
21:05:35 <lambdabot> bzzt
21:05:50 <narain> isPrime is a library function??
21:05:58 <davidL> no
21:06:08 <dibblego> ?hoogle PublicKey -> PrivateKey -- go on!
21:06:09 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- go on!'
21:06:13 <jmanson_> I have heard of the State monad. Does that prevent copying of variables to modify them?
21:06:13 <ddarius> jmanson_: 1) Haskell compilers can sometimes optimize to use in-place update 2) deforestation eliminates some intermediate data structures 3) Haskell has always been a garbage collected language, it's not that much overhead.
21:06:25 <dibblego> jmanson_, no
21:06:34 <Olathe> Deforestation is a cute term.
21:06:35 <narain> davidL: then how did you do that?
21:06:39 <ddarius> jmanson_: What if you started counting all those stack frames as memory allocated in C/C++?
21:06:46 <davidL> narain: @let works
21:06:57 <shapr> In that case, 'programming' is split into 1. understanding the domain well enough to write a language that describes it, and 2. domain experts solving problems 'naturally'.
21:07:06 <narain> davidL: it does now? cool!
21:07:12 <ddarius> and 4) when you want/need to you can explicitly use mutable variables.
21:07:13 <narain> was lambdabot rebuilt?
21:07:24 <sorear> yes!
21:07:28 <sorear> @let x = 2
21:07:29 <lambdabot> <local>:13:0:     Multiple declarations of `L.x'     Declared at: <local>:10:...
21:07:29 <davidL> narain: just don't do @undefine it's really broken
21:07:40 <shapr> igli: How does that sound to you?
21:07:42 <sorear> davidL: How badly?
21:07:45 <narain> > x
21:07:48 <ddarius> davidL: It's not broken, it just is a poor interface.
21:08:01 <lambdabot>  thread killed
21:08:02 <davidL> oh, well either way..don't do it!
21:08:04 <shapr> igli: I'm not convinced I'm right.
21:08:06 <igli> er one sec was somewhere else let me read
21:08:16 <jmanson_> So, is it better to use IORef or to use State or StateT?
21:08:32 <dibblego> lambdabot is broken
21:08:34 <ddarius> jmanson_: It depends on the context.  State(T) if that's usable though.
21:08:42 <igli> nah i'm not either shapr tbh
21:09:12 <jmanson_> State(T) is the best? Most general?
21:09:14 <igli> thing is domain specific languages which already exist and have been worked on for years will win at this stage at least
21:09:28 <ddarius> jmanson_: IORefs and State(T) solve different problems.
21:10:25 <Olathe> What's a decent intro to Haskell book that covers all the neat data-rearranging-and-combining functions like folding and getting subsets of a certain size and Cartesian products and so on ?
21:10:42 <jmanson_> Ok. Lest say that I am going to want to store a game state with a number of actors and level data that will add up to something largish. Lets just say for the sake of argument that the state will take up to a meg of memory.
21:10:45 <shapr> igli: But they don't adapt well.
21:11:02 <shapr> igli: php is a great example for a DSL, but some people use it to build GUI apps.
21:11:07 <igli> yeah but for web dev you need html js and back end
21:11:24 <igli> and syntax is consistent with php and js
21:11:28 <narain> i don't think anyone would argue for replacing html with haskell
21:11:37 <igli> heh i'd hope not ;)
21:11:39 <narain> js, now that's another thing :)
21:11:42 <dmwit> Is there a standard trick (recipe? solution?) for doing stateful gtk2hs programming?
21:11:58 <igli> simple xml tho.. ;)
21:12:01 <narain> but js is actually a pretty capable functional language
21:12:10 <igli> yeah it's lovely
21:12:18 <ddarius> jmanson_: That's not exactly the axis that the choice between IORefs and State splits on.
21:12:35 <shapr> So it seems to me that a DSL written in Haskell has advantages because it can be easily extended and adapted. Look at the modular interpreters with monad transformers papers, for example.
21:12:35 <olsner> is there an uncurry for 3-tuples?
21:12:45 <jmanson_> What heuristic would you use to choose between them?
21:12:47 <ddarius> olsner: No.
21:12:56 <olsner> @hoogle (a -> b -> c -> d) -> (a,b,c)->d
21:12:58 <lambdabot> No matches, try a more general search
21:13:20 <igli> shapr: your original contention was: "I think it's the best language for web development."
21:13:30 <shapr> Yup
21:13:43 <igli> not the same as generic dsl
21:14:00 <igli> if such a thing exists ;)
21:14:13 <narain> a generic domain specific language? :P
21:14:16 <igli> hehe
21:14:31 <ddarius> jmanson_: It would depend on your pattern of use.  State is like adding a piece of "global" state to your program, IORefs are like pointers (very very roughly), i.e. you would use them for mutable linked data structures for example.
21:14:31 <igli> well you get the idea
21:14:35 <dmwit> In gtk2hs, all the event/signal functions take a callback that gives an IO () action.
21:14:40 <shapr> I've done webdev with Java, Python and Haskell so far. In my personal experience, Haskell is the obvious leader.
21:14:55 <shapr> Maybe I should try PHP and see how it compares? I've only played with PHP for a few hours at most.
21:14:56 <ddarius> Usually if you have a lot of data it's in the form of an array or hash table or some such.
21:14:57 <dmwit> I'm comfortable using partial application to send stateful things to those callbacks, but how do I let them modify it?
21:15:12 <igli> php ftw in that area (esp if you don't know fp)
21:15:24 <cdsmith> shapr: How do you do that -- just Network.CGI?
21:15:41 <ddarius> Oh god.  Why would someone use PHP over a real language if they knew better?
21:15:53 <igli> hmm was gonna say: it's so easy to switch between js and php, but it isn't :D
21:15:57 <igli> it's a PITA
21:16:02 <shapr> cdsmith: I've done some CGI stuff in Haskell, but since then I've used Hope a bit, and HAppS a lot.
21:16:27 <igli> shapr: yeah ok for backend you're right :)
21:16:29 <jmanson_> ddarius: Hmm. It sounds like for the thing I am thinking of it would make the most sense to use State then.
21:16:32 <cdsmith> shapr: cool; I need to figure out the best way to approach web development in Haskell, so opinions are appreciated.
21:16:51 <shapr> cdsmith: I like using HAppS, but I'm biased, since working on HAppS is my day job :-)
21:17:09 <cdsmith> shapr: ah; sounds good. :)
21:17:14 <igli> is that a framework?
21:17:20 <shapr> yup
21:17:21 <igli> `` ''
21:17:26 <igli> ok
21:17:46 <shapr> I've used J2EE and Zope as webdev frameworks, so I have some perspective.
21:17:54 <narain> ?where happs
21:17:55 <lambdabot> http://happs.org
21:18:01 <shapr> Nearly ten years of webdev :-)
21:18:05 <igli> heh i made an App Construction Kit in PHP a few years ago; must dig it out
21:18:34 <narain> shapr: ten years of webdev and you never touched php? lucky you
21:18:40 <shapr> I wandered around in drupal's source about a year ago, it seemed to have a desperated need for HOFs and monads.
21:19:02 <jmanson_> What's an HOF?
21:19:07 <narain> higher order function
21:19:16 <narain> e.g. map, fold, (>>=) etc
21:19:44 <igli> " Our goal was never to show that SEDA outperforms other server designs, but rather that acceptable performance can be achieved while providing a disciplined apporach to overload management." hmm
21:20:09 <igli> guess it deps what that approach brings
21:20:21 <shapr> For example, look at how 'hooks' are implemented in Drupal. That just screams out for higher order functions.
21:20:39 <igli> oh man don't start me off on CMS
21:22:09 * araujo using xmonad
21:22:16 * araujo rejoices
21:22:33 <Nafai> I feel kind of stuck; all I do is Java at work and I don't want to be stuck doing it forever :(
21:22:46 <ddarius> Nafai: So get another job.
21:22:58 <mlh> write a java code generator in haskell
21:23:01 <igli> heh i wonder if there is employment in haskell? there should be given the apps
21:23:11 <ddarius> igli: Have you not noticed it?
21:23:12 <jmanson_> If I have a whole bunch of data in a list that needs to be modified each frame is the State monad better than IORef?
21:23:13 <shapr> Nafai: Or spend your spare time learning something else well enough to change horses?
21:23:21 <igli> ddarius: never looked tbh
21:23:44 <ddarius> There have been several job advertisements on the Haskell lists and other places recently.
21:23:50 <ddarius> shapr just said he had a Haskell job.
21:24:06 <Nafai> shapr: Yes, this spare time thing :(  I guess I need to figure out what it is I want to do so I'm not stuck with Java
21:24:13 <ddarius> Quite a few people have been talking about having or just getting Haskell jobs here.
21:24:25 <igli> ok don't read the lists, sorry, and just figured you always get some professionals.
21:24:57 <igli> heh maybe when i finish this project i'll learn haskell properly..
21:25:06 <ddarius> They certainly aren't all over the place, but it's only going to grow.
21:25:23 <shapr> Nafai: If you want the change, make the time.
21:26:19 <igli> Nafai: is your nick based on the Card novels?
21:26:26 <Nafai> igli: Yes
21:26:30 <igli> heh
21:26:32 <ddarius> Which?
21:26:51 <Nafai> The Homecoming Series, "Ships of Earth" "Memory of Earth", etc
21:27:06 <igli> yeah  Call of Earth is first one?
21:27:09 <ddarius> Ah, I've read the other two series (I don't think he has a fourth).
21:27:18 <igli> man he's got loads
21:27:28 <Nafai> igli: I believe so
21:27:38 <igli> well the Ender set is two trilogies
21:27:40 <Nafai> I admit it's been a while since I last read 'em
21:27:45 <igli> heh me 2
21:28:04 <igli> so are you as self-righteous as our hero Nafai? ;)
21:28:18 <Nafai> I don't think so
21:28:34 <dmwit> jmanson_: It depends.
21:29:02 <dmwit> I would recommend State, it's pretty handy.
21:29:04 <igli> heh
21:29:07 <ddarius> Don't read Treasure Box.  It's horrid.
21:30:14 <dmwit> jmanson_: If you don't need an IORef, State will be nicer, because it doesn't force all your functions to be in the IO monad.
21:30:33 <dmwit> (Of course, State forces them to be in the State monad, but... =)
21:30:58 <jmanson_> dmwit: what might I need an IORef for?
21:31:45 <dmwit> Mmm, I think that I've run into my first use of them just tonight.
21:31:59 <jmanson_> I expect that I will have a level state that will basically be a 2d array, and that I will want to do some pathfinding on it.
21:32:02 <ddarius> It's actually fairly rare to want IORefs unless you are making a mutable linked structure.  Usually what gets you is IOArrays or HashTables.
21:32:06 <dmwit> I think (maybe!) that they are useful for libraries that use callbacks, like gtk2hs.
21:32:47 <ddarius> Alternatively, for concurrent applications, you want MVars, Channels, or TVars.
21:32:47 <dibblego> local side-effects such as updating arrays
21:32:56 <jmanson_> The level will rarely be updated, but often read from. While actors will always be modified.
21:33:31 <jmanson_> I think I will stay away from concurrency for a little while still :)
21:34:12 <ddarius> jmanson_: Actually, concurrency in Haskell is rather nice.  You can have it any way you want and then some.
21:34:26 <jmanson_> Although, with a dual core machine, I am somewhat eager to try it out someday...
21:34:38 <dmwit> jmanson_: If, conceptually, you need a container for state, then you probably want State.  If, conceptually, you *need* to pass a pointer around, then you probably want IORef.
21:35:11 <igli> shapr: "It follows SEDA's lesson that events should accumulate in their entirety in queues before they are processed." bothers me tbh
21:35:26 <dmwit> Although that is the opinion of someone who has used each of them only a little bit.
21:35:29 <jmanson_> dmwit: thanks. i think this is slowly sinking in.
21:35:59 <ddarius> jmanson_: Once you know what each is for, it is pretty clear when you want one or the other or some combination.
21:36:07 <ddarius> As I said, they really solve different problems.
21:36:42 <ddarius> But I'm not really sure how to make it completely clear when you want which; it's one of those things you know when you see it.
21:36:43 <igli> so play and find out :)
21:36:54 <ddarius> Yes, take igli's advice.
21:37:01 <jmanson_> What is the difference between State and StateT. The latter is a transformer, so does that mean that it takes something unstateful and turns it stateful to be used in stateful algorithms?
21:37:10 <igli> heh i'm just summarising ddarius :)
21:37:23 <ddarius> igli: Yes, that is what I was getting at in my long-winded way.
21:37:32 <igli> what does stateful mean jmanson_?
21:37:45 <ddarius> jmanson_: State is a monad, StateT is a monad transformer.
21:37:46 <igli> ddarius: #bash teaches me a lot too ;)
21:38:27 <jmanson_> Lets say that there is some tree structure you have. Then you want to traverse it and perform computations that involve state, but don't want that state attached to the tree outside of the function?
21:38:55 <igli> this doesn't feel like functional prog any more
21:39:12 <igli> sorry only have ML and looked at haskell
21:39:16 <ddarius> Monads let you effectively add an "effect" to Haskell, in State's case, it's a piece of mutable state.
21:39:23 <jmanson_> I remember seeing an example of when it was useful, but I forget what.
21:39:54 <igli> jmanson_: tbh i think you need to mess around with code a bit more at this stage
21:40:06 <igli> all the questions will just be you thinking ahead
21:40:09 <ddarius> Monad transformers take one monad and makes a new monad that combines the effects of the given monad with the effect represented by the monad transformer.
21:40:37 <igli> ooh nice
21:40:47 <igli> so merge monads kinda?
21:41:16 <igli> deps how effect of transformer is defined i guess
21:41:44 <ddarius> igli: Kind of, only if "merge" was append (i.e. ++ in Haskell) the effect of a monad transformer would be more like cons (i.e. : in Haskell)
21:41:45 <jmanson_> igli: You are right. I will try to get some sort of state working and come back once I have some code and a problem :)
21:42:04 <igli> ah ty ddarius
21:42:13 <igli> jmanson_: cool :)
21:42:24 <igli> but log this channel it really helps :D
21:42:53 <sorear> @where logs
21:42:53 <jmanson_> I'll just stay logged in. Sort of like a ghost. Here, but not here.
21:42:53 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
21:43:07 <igli> jmanson_: yeah that's what i normally do
21:43:12 <igli> heh nm
21:43:41 * jmanson_ fades out
21:44:05 <sorear> jmanson_: quit, and read the logs
21:44:19 <igli> 2nd one is friendlier
21:44:46 <igli> altho it has one of those stupid _utma cookies
21:45:04 <sorear> first is much nicer, you can read it offline
21:45:36 <igli> ah ic
21:46:29 <narain> meme.b9 always redirects me to ircbrowse
21:46:35 <narain> should the urls be updated?
21:47:12 <sorear> you can do it, @where+
21:48:07 <narain> ?where+ logs http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
21:48:08 <lambdabot> Done.
21:48:11 <narain> ?where logs
21:48:12 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://ircbrowse.com/cdates.html?channel=haskell
21:49:19 <narain> cool
22:01:18 <davidL> does anyone have a prime generator that generates 10,000 primes faster than 21.86 seconds?
22:05:50 <ddarius> 10000 shouldn't take that long.
22:06:09 <davidL> you mean it should take less than 21 seconds?
22:06:23 <ddarius> I mean it shouldn't take long at all.
22:06:32 <davidL> hmmm
22:07:07 <davidL> well sorears "nubBy(((>1).).gcd)[2..]" can't even generate 10,000 primes =(
22:07:24 <ddarius> I think I wrote a Java and C++ version of a prime sieve that was pretty quick.  I think I used much more than 10000 to test it or at least something comparable.
22:07:39 <ddarius> davidL: It's not written for efficiency...
22:08:10 <jmanson> I was looking at this page: http://www.haskell.org/hawiki/MonadState
22:08:12 <lambdabot> Title: MonadState - The Haskell Wiki
22:08:15 <davidL> is there any sieve written for haskell that's very efficient?
22:08:35 <jmanson> down near the bottom it gives an example of global state
22:08:47 <davidL> or does that entail very many small optimizations that no one bothers?
22:08:52 <jmanson> it seems to require writing a selector for each variable though.
22:09:06 <jmanson> is there a way of automating the selector writing
22:09:08 <jmanson> >
22:10:04 <jmanson> It's just as bad as writing a getter and setter for each variable in a class, which is just a pain in the ass usually.
22:10:11 <ddarius> There are fast ways to generate primes, and slow ways. http://groups.google.de/group/fa.haskell/msg/35eeadbc700078e5?dmode=source
22:10:14 <lambdabot> Title: Code and Perf. Data for Prime Finders (was: Genuine Eratosthenes sieve) - fa.has ..., http://tinyurl.com/2avnqx
22:10:59 <davidL> thanks ddarius
22:11:48 <ddarius> jmanson: There are ways of generating those... often though, I don't have such problems.
22:12:41 <jmanson> ddarius: could you explain why you don't have problems?
22:12:54 <davidL> ddarius: wow that is incredible, a zip file containing haskell code of almost every prime algorithm imaginable, thank you!
22:14:19 <ddarius> jmanson: Probably not very coherently.  One aspect is that usually you don't want to just get or set some value, you want to do something more high-level.  Also, you can use HOFs and record syntax and pattern matching to make doing such things pretty short.
22:16:05 <ddarius> davidL: There's a lot more to that thread, and I think a few more implementations or tweaks were mentioned after that email and there is also a paper about prime sieves written by the author of that email.
22:16:40 <emu> > nubBy (((>1).).gcd)[2..]
22:16:42 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
22:16:48 <emu> > nubBy (((>1).).gcd)[2..] !! 10000
22:17:00 <davidL> thread destroyed
22:17:04 <lambdabot>  thread killed
22:17:09 <emu> bzzt
22:17:25 <igli> lol
22:17:44 <davidL> > filter (\x -> factors x == 1) [2..] !! 10000
22:17:50 <lambdabot>   add an instance declaration for (Num [a])
22:17:56 <emu> > factors 100
22:17:57 <davidL> lol
22:18:07 <lambdabot>  [2,2,5,5]
22:18:14 <emu> @index factors
22:18:14 <lambdabot> bzzt
22:18:14 <dmwit> > filter (\x -> factors x == [x]) [2..] !! 10000
22:18:19 * emu cackles
22:18:30 <lambdabot>  thread killed
22:18:35 <davidL> oh oops
22:18:35 <sorear> stefan@stefans:~$ time primes 1 10000 > /dev/null
22:18:35 <sorear> real    0m0.012s
22:18:35 <sorear> user    0m0.000s
22:18:37 <emu> > factors 9
22:18:45 <lambdabot>  [3,3]
22:18:49 <emu> > factors 11
22:18:51 <sorear> stefan@stefans:~$ time primes 1 10000 > /dev/null
22:18:51 <sorear> real    0m0.012s
22:18:51 <sorear> user    0m0.000s
22:18:52 <davidL> sorear: which algo are you using?
22:18:59 <emu> learn new amazing functions
22:19:00 <lambdabot>  [11]
22:19:05 <sorear> grumble, --more--
22:19:19 <sorear> davidL: I dunno.  The standard BSD 'primes' utility
22:19:26 <emu> all we need now is a version of factors which runs in polynomial time
22:19:26 <davidL> oh lol
22:19:30 <sorear> I think it's in the bsdgames debian package
22:19:54 <dmwit> Primes are no game!  Serious business!  Internet argument!
22:20:03 <davidL> ftw ^
22:20:53 <ddarius> emu: factors is @let defined.
22:21:23 <sorear> why can't we @unlet?
22:21:35 <sorear> davidL: ?
22:22:06 <davidL> sorear: because that deletes them all due to bad implementation
22:22:21 <sorear> davidL: huh?
22:22:28 <sorear> davidL: it's SUPPOSED to delete them all
22:22:31 <sorear> @unlet
22:22:34 <lambdabot> Defined.
22:22:38 <davidL> damn you
22:22:46 <davidL> > factors 23
22:22:55 <lambdabot>  [23]
22:23:00 <davidL> what??
22:23:08 <ddarius> @help unlet
22:23:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:23:12 <sorear> @undefine
22:23:18 <ddarius> @help undefine
22:23:19 <lambdabot> Undefined.
22:23:19 <lambdabot> undefine. Reset evaluator local bindings
22:23:21 <jmanson> > factors 100
22:23:27 <lambdabot>   Not in scope: `factors'
22:23:35 <davidL> sorear ftl :P
22:23:39 <ddarius> sorear: People want to undefine individual definitions, not clear all bindings.
22:24:02 <sorear> Then that's a specification problem.
22:24:07 <sorear> @undefine is bug free.
22:24:11 <ddarius> That's what I said a long long time ago.
22:24:14 <lambdabot> Undefined.
22:24:23 <sorear> Well I didn't know to pay attention :)
22:25:03 <davidL> @let lala = error "I smell"
22:25:09 <lambdabot> Defined.
22:25:16 <davidL> > lala
22:25:22 <lambdabot>  Exception: I smell
22:25:30 <davidL> @undefine
22:25:36 <lambdabot> Undefined.
22:26:00 <ddarius> At the very least, @undefine should be removed or, preferably, made an administrator command.
22:26:50 <jmanson> i don't see why you would want to keep around definitions from ages ago anyways though
22:27:31 <sorear> @print-messages
22:27:32 <lambdabot> Unknown command, try @list
22:27:36 <sorear> @print-notices
22:27:36 <lambdabot> fromList [("audreyt:",(Nothing,[Note {noteSender = "fglock", noteContents = "have you registered the 'Pugs' namespace in CPAN? I need comaint in order to have the v6.pm modules indexed", noteTime = (
22:27:37 <lambdabot> 1178627870,751397000000), noteType = Tell},Note {noteSender = "fglock", noteContents = "actually, the problem is specific to Pugs::Grammar::P6Rule - you are the owner; I need comaint", noteTime = (
22:27:37 <lambdabot> 1178628101,874469000000), noteType = Tell}])),("clkao:",(Nothing,[Note {noteSender = "fglock", noteContents = "would you upload Sub::Multi to CPAN? I've made a small fix", noteTime = (1178629354,
22:27:37 <lambdabot> 782618000000), noteType = Tell}])),("'dons'",(Nothing,[Note {noteSender = "xDie", noteContents = "", noteTime = (1179115559,690171000000), noteType = Ask}])),("agentzh",(Nothing,[Note {noteSender = "
22:27:39 <lambdabot> Aankhen``", noteContents = "That's strange, the `load` handler should only be running once.", noteTime = (1179091411,117498000000), noteType = Tell}])),("araujo",(Just (1178502521,268838000000),[
22:27:42 <lambdabot> [15 @more lines]
22:27:45 <jmanson> administrator commands like kick and ban prevent people from abusing int already.
22:27:51 <sorear> audreyt: is an invalid nick
22:28:10 <sorear> that entry won't go away until some admin runs @purge-notices
22:28:36 <sorear> it used to be 200 @more lines, then I purged it
22:29:08 <arcatan> hehe, few days ago I tried to send a message but forgot the nick
22:29:39 <arcatan> hopefully somebody with nick "the" won't enter #haskell
22:30:30 <olsner> actually, I hope someone someday will, just for fun
22:31:15 <the> 'the' was already taken
22:31:16 <lambdabot> the: You have 1 new message. '/msg lambdabot @messages' to read it.
22:32:04 <the> <the> @messages
22:32:04 <the> <lambdabot> arcatan said 5d 18h 39m 36s ago: bug report isn't mine. latest version (just pulled) still has the bug. I also noticed that while neither mod-j or mod-k work, my mod-shift-j binding seems to work
22:32:04 <the> <lambdabot> but mod-shift-k doesn't
22:33:04 <olsner> strange that I could use the 'the' nick even though it was owned by someone else
22:33:29 <arcatan> I think you can use it for while
22:33:34 <ddarius> olsner: It's not going to stop you.
22:34:36 <davidL> you can use it until someone ghost kills you
22:36:26 * ddarius checks out what Luca Cardelli has been up to.
22:37:33 <davidL> ?src elem
22:37:33 <lambdabot> elem x    =  any (== x)
22:38:10 <davidL> > 739287 `elem` [1..10^6]
22:38:19 <lambdabot>  True
22:38:28 <davidL> > 7392877 `elem` [1..10^7]
22:38:43 <lambdabot>  thread killed
22:42:08 <mlh> @hoogle time
22:42:12 <lambdabot> System.Time :: module
22:42:12 <lambdabot> Time :: module
22:42:12 <lambdabot> System.Locale.time12Fmt :: TimeLocale -> String
22:42:26 <ddarius> @google time
22:42:31 <lambdabot> http://www.time.com/
22:42:31 <lambdabot> Title: Breaking News, Analysis, Opinions, Multimedia and Blogs | TIME
22:45:11 <Pseudonym> @google people
22:45:15 <lambdabot> http://www.people.com/
22:45:15 <lambdabot> Title: People.com : The #1 Celebrity Site on the Web
22:45:24 <Pseudonym> @google life
22:45:28 <lambdabot> http://www.life.com/Life/
22:45:28 <lambdabot> Title: Home | Life.com
22:45:40 <Pseudonym> Time-Warner have all the good names taken.
22:46:48 <sorear> @google Tom
22:46:51 <lambdabot> http://www.tomshardware.com/
22:50:05 <Pseudonym> @google death
22:50:08 <lambdabot> http://www.deathclock.com/
22:50:08 <lambdabot> Title: The Death Clock - When Am I Going To Die?
22:50:17 <Pseudonym> Oh, handy.
22:55:53 <ddarius> Conal Elliot was a PhD student of Frank Pfenning.  I didn't know that.
22:57:25 <dibblego> I didn't know I was going to live to be 70
22:57:36 <ddarius> Wow, that says I'll only live fifty years, and I thought I had some rather good traits in that regards.
22:57:50 <dibblego> fifty more years or fifty years old?
22:58:10 <ddarius> Luckily, fifty isn't too bad for me. (50 total)
22:58:23 <dibblego> why only 50?
22:58:41 <ddarius> I guess because I'm a pessimist.
22:59:06 <ddarius> And male.
22:59:27 <dibblego> the Mode section seems to sway the result a fair bit
22:59:54 <dibblego> if I were sadistic, I have 7 years left!
23:00:10 <ddarius> They don't have masochistic in there...
23:04:14 <dibblego> pessimism is often confused with scepticism and many sceptics are actually optimists
23:04:37 <sorear> How about cynicism?
23:04:46 <ddarius> I'm a bizarre mix of all of those.
23:05:37 <ddarius> I'm really optimistic-seeming about my (personal) future in many regards, but that mostly comes from a large amount of self-confidence.
23:06:37 <igli> heh you're a nutter then ;)
23:06:45 <igli> (jk)
23:06:51 * ddarius is a nutter.
23:07:16 <ddarius> Oh, and combined with self-confidence is a heaping helping of apathy.
23:08:12 <Pseudonym> You're really, really confident that you don't give a shit.
23:08:49 <ddarius> Pseudonym: That is true.
23:09:09 <igli> heh moodswings?
23:09:19 <ddarius> Incidentally, wtf? I just reclicked the button with the same information and it added 7 years.
23:09:34 <ddarius> igli: No, there is nothing conflicting there.
23:09:37 <dibblego> must be written in a language with uncontrolled side-effects
23:12:53 <Pseudonym> Use Haskell and don't shorten your lifespan!
23:13:13 <ddarius> And don't lengthen it either.
23:13:24 <Pseudonym> hey, at least it's predictable.
23:13:44 <ddarius> It would be nice to know when you were going to die.
23:30:42 <ddarius> Hmm... return as a subroutine call...
23:33:18 <dmwit> ?pl divide x y = fromIntegral x / fromIntegral y
23:33:19 <lambdabot> divide = (. fromIntegral) . (/) . fromIntegral
23:33:40 <dmwit> ?pl f x y = (fromIntegral x, fromIntegral y)
23:33:41 <lambdabot> f = (. fromIntegral) . (,) . fromIntegral
23:33:57 <dmwit> ?pl f (x, y) = (fromIntegral x, fromIntegral y)
23:33:58 <lambdabot> f = fromIntegral *** fromIntegral
23:34:14 <dmwit> ?pl \f -> f *** f
23:34:15 <lambdabot> join (***)
23:35:01 <dmwit> :t \x y -> curry (/) (join (***) fromIntegral x y)
23:35:09 <ddarius> uncurry
23:35:17 <lambdabot> thread killed
23:35:23 <dmwit> Anyway, it's not better or more readable, so I won't use it. =P
23:48:32 <ddarius> Unsurprisingly, I'm not the first to think of it.
23:50:19 <ddarius> But I should be going to sleep.
23:59:58 <LeCamarade> lambdabot: You have a cousin over at #ocaml. Name of desertbot. Only replies to @bot and @uptime, for now.
