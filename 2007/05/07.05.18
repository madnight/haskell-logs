00:03:11 <monochrom> Damn.
00:03:38 <monochrom> updateSM (\(C s) -> C (newdept : s))
00:03:46 <monochrom> need more parentheses.
00:06:05 <UUStudent> sweet..thanks. with the run of that, it returns ((),C [D "love" (E (P "MONO" "earth") (S 0.1)) []])
00:08:39 <osfameron> I managed to install ghc 6.6.1 (and my laptop only shut down from overheating once!)
00:08:56 <osfameron> but I couldn't isntall yi - it complained about needing mtl-any
00:09:00 <osfameron> where do I get that from?
00:09:19 <monochrom> I think you started building ghc yesterday. So now it's finally done?
00:09:36 <osfameron> no it finished yesterday, I just wasn't online
00:09:48 <osfameron> it took somewhere between 1 and 2 hours (I forgot to time it)
00:09:50 <monochrom> hackage.haskell.org has stuff
00:10:37 <osfameron> dons: the parser stuff for implementing yi key commands looks really interesting
00:11:23 <osfameron> dons: how do you deal with ambiguous commands (as in vim, where the mapped command times out after a certain time allowing the expected movement parameter definition to kick in)
00:11:37 <osfameron> er... that's really badly explained, I can elaborate if that's not clear.
00:11:57 <dons> iirc, you ^c to interrupt
00:11:57 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
00:12:06 <dons> or esc, to interrupt. we don't try to timeout, iirc.
00:15:01 <UUStudent> what do i do to add several employees/departments? use run/update inside a do?
00:15:45 <monochrom> runSM outside do. updateSM inside do.
00:15:50 <osfameron> dons: ok, fair enough.  vim does do timeout though - last time I tried to work out its algorithm I really hurt my head
00:16:01 <osfameron> (though admittedly I was trying to do it in VBA which didn't really help)
00:16:26 <monochrom> runSM initial_state (do ... )
00:20:35 <UUStudent> awesome
00:26:29 <encryptio> > (,2) 1
00:26:30 <lambdabot>  Parse error
00:26:37 <encryptio> > (2,) 1
00:26:37 <lambdabot>  Parse error
00:26:56 <encryptio> > (,) 2 1
00:26:57 <lambdabot>  (2,1)
00:27:45 <monochrom> > (2 , ) 1
00:27:45 <lambdabot>  Parse error
00:27:52 <monochrom> > (2 (,) ) 1
00:27:53 <lambdabot>        add an instance declaration for
00:27:53 <lambdabot>       (Num ((a -> b -> (a, b)) -> t ->...
00:28:12 <quicksilver> encryptio: (,) is magic
00:28:22 <quicksilver> encryptio: you can't section it
00:28:37 <quicksilver> it's not really clear to me why not, the syntax wouldn't be ambiguous that I can see
00:29:52 <UUStudent> is it possible to call updateSM with a function addDeptToCompany :: String -> Dept -> Company -> Ret Company .... or do i need to change updateSM to return a Ret monad type?
00:32:25 <monochrom> I don't think updateSM is intended to involve Ret.
00:34:06 <monochrom> Would be nice to have f :: String -> Dept -> Company -> Company.  Then you can updateSM (f "love" d).
00:34:39 <UUStudent> yes, but needs to return an error on failure
00:36:10 <encryptio> > (Right 1) >>= id
00:36:11 <lambdabot>   add an instance declaration for (Num (Either a b))
00:36:56 <encryptio> @instances Either
00:36:58 <lambdabot> Couldn't find class `Either'. Try @instances-importing
00:37:04 <monochrom> Well, for now, try to pretend or ensure all operations are valid.
00:37:21 <encryptio> is Either a monad?
00:37:33 <UUStudent> yes
00:37:46 <monochrom> updateSM (value . addDeptToCompany "love" d)
00:39:11 <UUStudent> d is some given department?
00:40:07 <monochrom> updateSM (value . addDeptToCompany "beginning" d)   should be better
00:40:31 <monochrom> d is some given department.
00:40:32 <UUStudent> great
00:41:09 <UUStudent> of course addDeptToCompany can't really error like some of the other functions :)
00:41:34 <jyp> Folks! Please test the Yi Editor release canditate!
00:41:37 <jyp> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor
00:41:40 <lambdabot> http://tinyurl.com/yqov7f
00:43:23 <UUStudent> but all right, at least i have haskell exceptions to tell me when it blows up for now
00:48:26 <UUStudent> about now i'm realizing it would have been helpful to have a Company as one of my inputs for all the add functions..must've misread the directions
00:54:14 <osfameron> eeeek!  mtl wants happy and alex too
00:54:25 <osfameron> is there a way of getting it to fetch dependencies for me, Ã  la CPAN ?
00:54:50 <Korollary> mtl?
00:55:05 <osfameron> monad transformer library apparently
00:55:07 <osfameron> yi needs it
00:55:09 <Korollary> it comes with ghc
00:55:15 <osfameron> oh
00:55:21 <osfameron> not with mine apparently
00:55:28 <Korollary> what does ghc-pkg -l say?
00:55:49 <monochrom> mtl wants happy and alex? I don't believe it.
00:56:08 <dons> it does? hmm??/
00:56:19 <dons> mtl is on hackage, and doesn't need them. though cabal will *test* for them.
00:56:23 <dons> it doesn't require them though.
00:56:32 <dons> cabal tests for heaps of things :-)
00:56:39 <dons> pfe, for example. who has that!?
00:56:41 <Korollary> mtl is apparently in the ghc extralibs
00:56:50 <hpaste>  osfameron pasted "ghc-pkg -l" at http://hpaste.org/1880
00:56:50 <dons> ?hackage mtl
00:56:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
00:57:07 <osfameron> oh, extralibs.  I didn't compile those
00:57:20 <dons> you can just grab mtl et al from hackage.
00:57:41 <osfameron> oh, you mean the runghc Setup.hs configure  output is just warnings?
00:57:50 <dons> yeah.
00:57:55 <Korollary> not even warnings
00:57:56 <dons> not even warnings, just logging
00:57:59 <Korollary> informative crap
00:58:12 <dons> crapomative forms.
00:58:25 <Korollary> It's a long "Did you know..." segment.
00:58:41 <stmartin> Can functions be compared in Haskell?
00:58:49 <quicksilver> stmartin: in general, no
00:58:53 <monochrom> red herrings
00:58:56 <quicksilver> stmartin: (in general, that's impossible)
00:59:23 <dons> or, more a reverse q/a session, A. "Happy", Q. "What is a parser generator for Haskell"
00:59:44 <Korollary> It doesnt actually say what Happy is, though.
01:00:12 <dons> ?check \f g x ->  let _=x::Int;_=f::Int -> Int; in   f x == g x  -- hah!
01:00:13 <lambdabot>  Falsifiable, after 0 tests: <Int -> Int>, <Int -> Int>, 2
01:00:17 <dons> :-)
01:00:24 <dons> ?check \f g x ->  let _=x::Int;_=f::Int -> Int; in   f x /= g x
01:00:25 <desp> @hoogle Char -> Int
01:00:25 <lambdabot>  Falsifiable, after 8 tests: <Int -> Int>, <Int -> Int>, 0
01:00:26 <lambdabot> Char.digitToInt :: Char -> Int
01:00:26 <lambdabot> Char.ord :: Char -> Int
01:00:31 <dons> ?scheck \f g x ->  let _=x::Int;_=f::Int -> Int; in   f x /= g x
01:00:32 <lambdabot>   Failed test no. 1. Test values follow.: {-3->0;-2->0;-1->0;0->0;1->0;2->0;3...
01:00:51 <dons> ?scheck \f g x ->  let _=f::Bool->Bool; in   f x == g x
01:00:52 <lambdabot>   Failed test no. 4. Test values follow.: {True->True;False->True}, {True->Tr...
01:00:53 <osfameron> cool, now I just need to upgrade my gtk
01:00:55 <osfameron> bah
01:00:59 <stmartin> Hmmm, I'm writing a simple table editor, and I have a infinite tail-recursive loop (ui_mainloop). One of the commands I've just added is 'q' (for quit). ui_mainloop calls get_command, which returns a function and a list of arguments. So it would be nice to have some way to see if the function that was passed back is the quit function.
01:01:17 <dons> you'd hvae to pair it with a key to compare on.
01:01:33 <dons> or i suppose, compare it for extensional equivalance. though that might be slow ...
01:03:30 <stmartin> perhaps each function should also pass back some flags that say things like whether the mainloop should print the current record, or if it should quit.
01:04:16 <monochrom> If the quit function is really the quit function, you can just execute it, then things will quit. There is no need to ask, "are you the quit function?"
01:04:20 <stmartin> Suddenly I'm wishing for Erlang atoms. Any simple equivalent in Haskell?
01:04:22 <Korollary> In UIs, the user typically passes a symbol of the UI language to the program, not arbitrary functions per se.
01:04:22 <Baughn> stmartin: Or, instead of making mainloop recurse into /itself/, you could have the command functions do all the work and then call mainloop again
01:04:58 <stmartin> But then that wouldn't be tail-recursive, surely.
01:05:28 <Baughn> stmartin: It's tail-recursive if it's the last thing your mainloop invocation does
01:05:38 <Baughn> stmartin: The tail-call doesn't need to be the same function each time
01:05:55 <stmartin> Oh, I see.
01:05:57 <quicksilver> who cares if it's tail recursive?
01:06:02 <quicksilver> tail recursion doesn't matter in haskell
01:06:28 <stmartin> I do. I don't want my mainloop consuming swags of memory on large inputs. I'm creating something that could use much like sed.
01:06:32 <Baughn> In IO, I expect it works about like normal
01:06:47 <quicksilver> stmartin: not being tail recursive will not make it consume large amounts of memory
01:06:50 <quicksilver> (not necessarily)
01:06:59 <stmartin> I'm thinking of stack space.
01:07:03 <quicksilver> and being tail recursive will not guarantee that it doesn't
01:07:06 <stmartin> Or am I missing something here.
01:07:08 <Baughn> stmartin: So something like getcommand -> doA -> getcommand -> doB -> getcommand -> quit
01:07:10 <quicksilver> lazy evaluation isn't like that
01:07:12 <roconnor> haskell has lazy evaulation, there is (almost) no stack
01:07:14 <Baughn> stmartin: Each of those being separate functions
01:07:17 <quicksilver> there isn't a stack in the same sense
01:07:43 <quicksilver> stmartin: to answer your initial question, I'd pass around some kind of 'function descriptor'
01:07:53 <quicksilver> stmartin: which contains whatever attributes you need to identifiy it
01:07:57 <quicksilver> along with the actual function itself
01:08:02 <stmartin> Thanks
01:08:06 <quicksilver> it might be as simple as a pair (Name,Function)
01:08:09 <Baughn> Yah, but you don't need to identify it if you can just call it
01:08:10 <quicksilver> but there might be more you want
01:08:27 <quicksilver> in fact, it might just be Name
01:08:30 <monochrom> If the last thing mainloop does is to call doB, that is a tail call. If the last thing doB does is to call mainloop, that's also a tail call. Isn't this enough?
01:08:41 <quicksilver> (you might look up the Function in some kind of registery)
01:08:55 <Baughn> monochrom: It.. depends. For pure functions, things can get crazy.
01:09:08 <stmartin> monochrom: That should be fine. Thanks
01:09:21 <quicksilver> Baughn: this is quite true. but sometime it's useful to be able to identify
01:09:31 <quicksilver> Baughn: it does depend exactly what stmartin is trying to achieve :)
01:10:24 <Baughn> quicksilver: I read a nice page a while ago that explained foldl/foldl'/foldr and tail-recursion issues at the same time
01:10:36 <Baughn> Happen to know what it might be? ^_^;
01:10:43 <Baughn> s/what/where/
01:11:31 <Baughn> monochrom: Oh, but you can see /some/ of the issues at http://www.mail-archive.com/haskell@haskell.org/msg08183.html
01:11:32 <lambdabot> Title: foldl, tail recursion, and strictness (was: stack overflow)
01:12:59 <monochrom> I know all the issues. I stated they are tail calls, no more no less.
01:13:05 <quicksilver> stmartin: as an example, by the way, foldr is not tail recursive
01:13:14 <quicksilver> stmartin: and yet it doesn't contain any essential  memory leak
01:13:30 <quicksilver> (it's possible to leak memory using foldr, but that's a different point)
01:13:32 <stmartin> That much I think I understand, because it has to recurse all the way to the end, right?
01:13:51 <quicksilver> stmartin: it's basically because the recursive call isn't actually called until it is need
01:14:02 <quicksilver> stmartin: by which time, the 'outer level' may all be garbage
01:14:05 <quicksilver> stmartin: (and can be collected)
01:14:23 <quicksilver> stmartin: so it's like your infinite stack doesn't matter, because the outer levels all being garbage collected as you go down
01:14:37 <monochrom> If mainloop :: IO a, then basically all of you are trying to cloud the issue.
01:14:52 <quicksilver> you could say that lazy evaluation simulates an infinite stack in finite space (under some conditions)
01:14:56 <stmartin> Interesting. I'll have to look further into that when the swelling in my head goes down.
01:15:12 <quicksilver> monochrom: thanks for that :P
01:15:14 <dons> that is quite normal.
01:15:19 <quicksilver> monochrom: I actually feel I'm making an important point here
01:15:27 <quicksilver> monochrom: people from a strict background are attached to tail recursion
01:15:38 <quicksilver> monochrom: it's important to note it doesn't matter in lazy evaluation in the same way
01:15:51 <quicksilver> monochrom: and that applies to IO actions just as much as pure functions
01:16:54 <LeCamarade> I always go here http://haskell.org/haskellwiki/Hac_2007/GroupPhoto to put faces on the nicks. :oD
01:16:55 <lambdabot> Title: Hac 2007/GroupPhoto - HaskellWiki
01:17:24 <monochrom> Could you demonstrate how your point applies to IO actions?
01:18:48 <quicksilver> foo =  if (somethiing) then return "done" else do { a <- foo ; return a }
01:18:52 <quicksilver> this is not tail recursive
01:19:06 <quicksilver> (although I could transform it so it was, by just make the else clause 'foo'0
01:19:12 <quicksilver> and yet, it has no space leak
01:19:39 <quicksilver> indeed the transformation would make no different to its space profile
01:19:56 <quicksilver> (might produce slightly different code depending on your optimiser, but no space profile change)
01:29:06 <quicksilver> in fact, now I come to think of it, monadic code is never actually tail recursive, of course
01:29:21 <quicksilver> even if it looks it, the 'top combinator' is in fact >> or >>=, not your 'tail call' at all
01:31:47 <Baughn> So.. how does it /not/ build up an infinite chain of invocation frames?
01:32:11 <quicksilver> Baughn: by not really using frames at all
01:32:12 <igli> recursion is bad mkay?
01:32:19 <quicksilver> Baughn: not in the sense you're thinking of
01:32:28 <igli> er sorry not trolling
01:32:37 <quicksilver> Baughn: you have a top level thunk which is (>>) (1st action) (2nd action)
01:32:47 <DRMacIver> igli: I agree. We should all be writing simple imperative Haskell. :)
01:32:49 <quicksilver> Baughn: when you 'force' the thunk, the first action gets evaluated
01:32:57 <quicksilver> Baughn: then the second
01:33:06 <quicksilver> Baughn: by now the (>>) is obsolete and can be GC'ed away
01:33:10 <igli> lol nah your compiler should just do it for ya :)
01:33:27 <quicksilver> Baughn: (and so is most of the first thunk, except for its 'side-effects' carried along by the monad)
01:33:36 <quicksilver> Baughn: and the (2nd action) is forced
01:33:44 <quicksilver> Baughn: because nothing is done before it's needed
01:33:55 <quicksilver> Baughn: and all the old stuff can be garbage collected behind you as you go
01:33:56 <DRMacIver> main = dwim -- Source code for my entire compiler.
01:34:17 <igli> which pkg is that then?
01:34:40 <DRMacIver> dwim is a language primitive. It's up to the compiler to infer the implementation. :)
01:35:13 <igli> @src dwim
01:35:13 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:35:17 <Baughn> quicksilver: I'm thinking of heap frames, not stack frames, but it still seems alien. Even while you're executing the second action, (>>) is still needed to return the value of that action once it's done...?
01:35:19 <igli> hehe
01:35:33 <DRMacIver> igli: It might help you to note that dwim stands for 'Do what I mean' :)
01:35:47 <igli> it does indeed :D
01:36:08 <quicksilver> Baughn: to be quite honest, you need to look at the definition of (>>) for that monad
01:36:12 <igli> DRMacIver: have you posted code anywhere?
01:36:22 <Baughn> quicksilver: ..figures.
01:36:25 <quicksilver> Baughn: but >> is unrolled, and it maybe pushes a constructor onto the currently-being constructed value
01:36:28 <quicksilver> Baughn: or something like that
01:36:38 <Baughn> quicksilver: It seems to me that, if I can think of a way to do it in constant space, it's done in constant space - and if I can't, half the time it is anyway.
01:36:44 <quicksilver> :)
01:36:57 <quicksilver> basically the source of memory leaks in haskell is keeping references to things you don't care about any more
01:37:00 <DRMacIver> igli: For what?
01:37:04 <quicksilver> (because then they can't be garbage collected)
01:37:15 <quicksilver> tail recursion, or not doing it, doesn't make any difference 'per se'
01:37:15 <igli> anything
01:37:15 <Baughn> I'll go with that.
01:37:23 <quicksilver> what matters is if you keep something alive you'd rather was dead
01:37:36 <quicksilver> the value of that action
01:37:36 <Baughn> Here I thought understanding how foldr doesn't leak was enough, but it's just the beginning..
01:37:41 <DRMacIver> igli: Well there's http://snippets.dzone.com/user/DRMacIver . Not much Haskell there though.
01:37:43 <lambdabot> Title: Drmaciver's Code Snippets
01:37:45 <quicksilver> foldr is a nice enough example though
01:37:48 <igli> ok
01:37:59 <quicksilver> Baughn: monadic notation is more-or-less foldr over (>>) and (>>=)
01:38:03 <quicksilver> Baughn: so the argument is the same
01:38:24 <DRMacIver> I also have two open source Java projects, but they're both in a dire state.
01:39:05 <igli> nah that's ok
01:39:10 <DRMacIver> (One is broadly speaking starting to work, the other I suspect is in principle in possible without manually writing out the type signatures from hell)
01:39:16 <igli> C FSM is very simple no?
01:39:17 <DRMacIver> err. in principle impossible
01:39:24 <DRMacIver> It's meant to be very simple. :)
01:39:43 <igli> no haven't looked at yours yet silly ;)
01:39:51 <DRMacIver> Oh. :)
01:39:57 <igli> hehe
01:40:14 <igli> my impl was hang on, 2 lines
01:40:14 <DRMacIver> But yes, writing FSMs (and finite state machines) in C is very simple.
01:40:22 <igli> yeah
01:40:36 <igli> well not impl sorry
01:40:39 <igli> data decl
01:40:54 <igli> it threw me for a while
01:42:51 <igli> DRMacIver: wtf is jason? parser looks like code i was after ty :)
01:43:33 <igli> nm silly q
01:44:59 <DRMacIver> JSON is JavaScript Object Notation. It's a lightweight text representation of simple objects. The parser there is very far from a faithful representation of the specification. :)
01:45:29 <igli> heh ok nice to know another buzzword (right)
01:45:34 <monochrom> quicksilver:  foo x = if x then return x else do { _ <- foo False ; putStrLn "hi" ; return False }  uses unbounded space
01:45:54 <igli> thanks for the code tho :)
01:47:23 <DRMacIver> It's a buzzword, but it's also a rather useful format. :)
01:47:53 <DRMacIver> It's about the most trivial object representation one can imagine, so it's good for cross language data interchange.
01:49:49 <igli> hmm sounds interesting
01:49:50 <quicksilver> monochrom: well yes, but that's because it loops without doing anything and the thunks can never be reduced
01:49:59 <quicksilver> monochrom: I don't think that's pathological behaviour...
01:50:08 <igli> @google JavaScript Object Notation
01:50:09 <lambdabot> http://www.json.org/
01:50:10 <lambdabot> Title: JSON
01:52:32 <quicksilver> monochrom: it's certainly not *because* it's not tail recursive. No monadic actions with more than 1 action are tail recursive
01:52:44 <quicksilver> monochrom: and plenty of them run in finite space
01:54:36 <ruzgaryilmaz> slm millet
01:55:49 <igli> looks nice DRMacIver
01:56:19 <igli> it'll be easy to translate to and from
01:56:42 <igli> (kk that's the point)
02:20:18 <jyp> Folks! Please test the Yi Editor release candidate! http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Editor
02:20:21 <lambdabot> http://tinyurl.com/yqov7f
02:22:36 <malcolmw> any Fun in the Afternoon attendees around?
02:22:49 * DRMacIver never managed to get Yi to work in the first place. :)
02:24:27 <jyp> DRMacIver: This release is easier to install
02:24:37 <jyp> you might want to give it a try
02:27:02 <DRMacIver> ok. I mighttake a look over the weekend.
02:38:14 <Cheery> ?where Zipper
02:38:14 <lambdabot> I know nothing about zipper.
02:38:18 <Cheery> :(
02:40:07 <LeCamarade> Cheery: You mean the one dons blogged about recently?
02:40:41 <Cheery> not sure what dons booged
02:40:43 <Cheery> @go haskell Generics
02:40:46 <lambdabot> http://www.cs.uu.nl/~johanj/publications/ComparingGP.pdf
02:44:12 <hpaste>  stmartin pasted "ui_mainloop" at http://hpaste.org/1881
02:44:38 <stmartin> I'm having trouble understanding how ghc is inferring something. Can someone take a look please?
02:46:05 <stmartin> In particular, I can't see how ([TableRow], t) is inferred.
02:46:46 <Lemmih> stmartin: You can't use IO from a non-IO function.
02:46:59 <quicksilver> your provlem is that 'c' isn't monadic
02:47:08 <quicksilver> (well one way of looking at your problem)
02:47:17 <stmartin> Hmmm, so what should I do?
02:47:28 <DRMacIver> Lemmih: Well, that's only true modulo evil. :)
02:47:34 <quicksilver> it may be that you want simply return (c rs args)
02:47:45 <quicksilver> DRMacIver: no it's true in haskell. Which is the primary topic of this channel :P
02:47:58 <quicksilver> DRMacIver: we may occasionally discuss other languages like GHC
02:47:59 <DRMacIver> quicksilver: It may be true in Haskell, but it's not true in most Haskell implementations.
02:48:02 <DRMacIver> Heh
02:48:20 <Lemmih> DRMacIver: Shhh, don't let the newbies know...
02:48:28 <quicksilver> stmartin: 'c' is simply a TableOp, right?
02:48:37 <stmartin> No, putting a return around it doesn't make any differenc.
02:48:38 <quicksilver> stmartin: and TableOp is (TableDoc -> Args -> TableDoc)
02:48:42 <quicksilver> stmartin: no IO there
02:48:48 <DRMacIver> Lemmih: :) I'm in some sense a newbie as well.
02:48:56 <stmartin> No, c is a TableOp
02:49:09 <quicksilver> isn't that what I said?
02:49:09 <stmartin> oh, so yes...
02:49:11 <quicksilver> :)
02:49:27 <Lemmih> DRMacIver: My machine for havesting their misery is almost complete. Next step, world domination!
02:49:43 <Lemmih> stmartin: return (c rs args)
02:49:59 <Lemmih> stmartin: And your type signature for 'ui_mainloop' is incorrect.
02:50:05 <stmartin> Ah, so I need to change the definition of TableOp?
02:50:14 <quicksilver> not necessarily
02:50:18 <quicksilver> can a tableop do IO?
02:50:24 <stmartin> It does now.
02:50:37 <quicksilver> in that case, you probably want TableDoc -> Args -> IO TableDoc
02:50:39 <quicksilver> I suspect
02:50:59 <quicksilver> oh yes
02:51:06 <stmartin> Out of curiosity, why that and not, for example  IO (TableDoc -> Args -> TableDoc)  ?
02:51:11 <quicksilver> the signature on ui_mainloop is the immediate cause of your error, actually
02:51:25 <quicksilver> and the wierd form of your error is caused by this:
02:51:36 <quicksilver> (a) the do statement says that ui_mainloop is a Monad, so
02:51:37 <Lemmih> stmartin: That would be an IO action that returns a function of type 'TableDoc -> Args -> TableDoc'.
02:51:38 <stmartin> I had put in some signatures to try and make more sence of the error messages.
02:51:52 <quicksilver> (b) ghc tries to make TableDoc -> TableDoc a monadd
02:51:59 <quicksilver> which it can, using the (->) Monad instance
02:52:06 <quicksilver> which gives rise to an odd message
02:52:19 <quicksilver> IMO the correct type for ui_mainloop is TableDoc -> IO TableDoc
02:52:38 <quicksilver> since it takes a TableDoc, then performs an IO computation which returns a TableDOc
02:52:50 <stmartin> I understand. Thank you.
02:59:22 <Cheery> ow nice, generics are something I've been looking for :)
03:01:52 <mux> the C guys won't give up with parallelism
03:01:59 <mux> have you guys looked at this OpenMP thing?
03:02:34 <quicksilver> with sun producing 64 'core' machines, it's not wonder they won't give up
03:02:43 <mux> it's ugly, tons of #pragma directives to tell the compilers what is sahred/private etc
03:02:51 <quicksilver> parallelism is obviously going to be really really important
03:03:00 <quicksilver> and they're not going to roll over and say 'nah, just use haskell' :P
03:03:06 <Baughn> C must have parallelism, or it'll become irrelevant
03:03:33 <mux> Baughn: that's precisely what I would have liked to see happening :-)
03:03:46 <kolmodin> to me C is already irrelevant :)
03:04:38 <mux> quicksilver: one can have dreams :-)
03:05:03 <kolmodin> :)
03:06:42 <quicksilver> mux: it's useful for everyone to have multiple players in the design space
03:06:44 <pejo> Um, one would guess Sun is in the Java camp, not in the C camp.
03:06:53 <quicksilver> mux: I learnt a lot from the way sun fucked up threads in Java, for example
03:06:58 <quicksilver> mux: I owe them for that mistake
03:07:08 <mux> heh, well that's an interesting way to look at things
03:07:22 <quicksilver> pejo: sun isn't really in the business of selling software
03:07:25 <quicksilver> pejo: not primarly
03:07:36 <mux> sun sells packs
03:07:51 <quicksilver> pejo: sun hardware is used to run solaris (which is free) and stuff like apache, zeus, oracle, etc etc
03:07:52 <mux> oracle + sun4v hardware + ... :)
03:07:58 <quicksilver> pejo: most of those things are written in C
03:08:41 <pejo> quicksilver, or Tomcat these days, that everything is in java..
03:09:26 <quicksilver> pejo: well that's true
03:09:36 <quicksilver> pejo: there are certainly popular app-servers written in jaca
03:09:49 <quicksilver> pejo: but sun kit is used to run all kinds of stuff, not just that
03:10:29 <stmartin> And its getting more and more into the embedded market now too.
03:10:37 <pejo> quicksilver, sure, I'm familiar with their hardware. But webservers for example scale pretty well sideways.
03:11:24 <stmartin> At least Java has improved it memory model, which fixes a lot of the screwed up threading stuff in the earlier Javas. There a Google Tech Talk video about on Google Video.
03:12:35 <stmartin> It occurred to me the other day how much shell scripting is like functional programming, and how | is essentially a bit like a lazy evaluation operator. My scripts look so much more maintainable now.
03:12:35 <mdmkolbe|work> there is a list syntax for 'iterate (+1) x' (i.e. [x..]), but is there a list syntax for 'repeat x'?
03:12:47 <araujo> morning
03:12:47 <quicksilver> stmartin: the threading stuff I was talking of was more fundamental
03:12:55 <quicksilver> > [5,5..]
03:12:57 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
03:13:07 <mdmkolbe|work> > [1, 2, 2..]
03:13:08 <lambdabot>  Parse error
03:13:12 <stmartin> Oh, you mean more like the shared memory semantics?
03:13:13 <quicksilver> stmartin: they implemented an unsafe 'thread.stop' construct
03:13:21 <stmartin> hahahaha
03:13:31 <quicksilver> stmartin: and then they had to deprecate it and post a rather good explanation of why that is inherently unsafe
03:13:32 <mdmkolbe|work> > 1 : [2, 2..]
03:13:34 <lambdabot>  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
03:13:43 <mdmkolbe|work> thx quicksilver
03:13:46 <quicksilver> (since any program of any size has critical regions and you can't tell when another thread might be in one)
03:14:08 <mux> STM is such a nice way to deal with synchronization issues
03:14:14 <DRMacIver> It's certainly my impression that "Nah, just use Haskell" *isn't* a good solution when you want something that's heavily parallel at the moment. :)
03:14:18 <quicksilver> stmartin: here you go
03:14:20 <quicksilver> stmartin: http://java.sun.com/j2se/1.4.2/docs/guide/misc/threadPrimitiveDeprecation.html
03:14:22 <lambdabot> Title: Java Thread Primitive Deprecation, http://tinyurl.com/2z6zb
03:14:36 <stmartin> That's what I like about Erlang (not that I know it particularly well yet). Message passing seems soooo much easier to get right.
03:14:41 <quicksilver> mux: and, if you need a little more explicity control, then MVars are
03:14:49 <mux> yes
03:14:58 <quicksilver> mux: MVars are a little fiddly to use raw, but you can build really powerful abstractions on them
03:15:14 <mux> yes, Chan's are built with MVars for instance, I think?
03:15:19 <mux> and quite easily
03:15:36 <quicksilver> mux: it's well known in the theory world that (something like) MVars is sufficient to implement "all" concurrency
03:15:52 <quicksilver> mux: given the right definition of 'all' :)
03:16:19 <mux> :)
03:16:19 <LeCamarade> levitation[A]: You seem in the sign-in-sign off mood ... :o)
03:16:25 <mdmkolbe|work> quicksilver: that is true of most concurancy primitives (signals, controlv values, etc.)
03:17:00 <Cheery> I've always dreamed about an architecture where every single bit in RAM would be a processor of one sort
03:17:04 <mdmkolbe|work> quicksilver: the hard question is (1) what can you prove about a problem that uses them and (2) can you implement the common cases fast (I don't know the answers to either of those for MVar)
03:18:28 <stmartin> Does    display_current_row rs >>= ui_mainloop  run display_current_row o
03:18:37 <stmartin> bother, said Poo. Ignore that.
03:23:10 <quicksilver> mdmkolbe|work: I know people who know the answers to some of those :)
03:23:15 <quicksilver> mdmkolbe|work: but I agree it's hard
03:23:20 <LeCamarade> ping levitation[A]
03:23:24 <LeCamarade> :P
03:23:31 <quicksilver> mdmkolbe|work: I have some hope that separation logic will prove very useful, but I declare a strong bias there
03:24:28 <pejo> quicksilver, did  you read that MSR technical report .. about some logic used for .. proving something!
03:24:43 <igli> "Most uses of stop should be replaced by code that simply modifies some variable to indicate that the target thread should stop running." hehe
03:25:39 <mdmkolbe|work> quicksilver: yeah.  The most famous of course is the compossible progress proof for STM
03:27:17 <quicksilver> igli: nonetheless, that is essentialy what you have to do
03:27:25 <pejo> quicksilver, doh, it's called "Local Reasoning for Storable Locks and Threads".
03:27:34 <quicksilver> igli: threads have to indicate their 'safe kill points'
03:27:47 <quicksilver> igli: although in some languages you might hope the compiler could 'infer' those in some sense
03:27:54 <quicksilver> (depending exactly what you're doing)
03:28:22 <igli> quicksilver: i just think it's funny; 30 years of development since C and the same probs which have already been solved are biting a lang implemented by a rich US corp
03:28:35 <igli> makes me wonder
03:28:37 <quicksilver> igli: yes, it was funny
03:28:43 <quicksilver> igli: and also instructive
03:28:44 <igli> :)
03:28:52 <quicksilver> igli: that page is quite a good description of the issue
03:29:02 <pejo> quicksilver, and isn't separation logic a rather hot research topic right now? Would be strange if nobody manages to do something interesting with it.
03:29:05 <igli> indeed saved for friendly-coders  ;)
03:29:34 <quicksilver> pejo: I think it's hot, yes
03:30:08 <quicksilver> pejo: no, I haven't read that, thank you
03:30:24 <quicksilver> pejo: it's very much the kind of thing I was talking about, but it's newer work than I was acquainted with
03:34:27 <stmartin> How can I import a module into ghci? import Text.Printf gives a parse error.
03:34:54 <mux> :m Text.Printf
03:35:03 <stmartin> Ahh, thanks
03:35:12 <mux> or :m +Text.Printf to just add it to the scope, and not removing those modules you previously :m'ed
03:36:53 <stmartin> Even more useful. Ta
03:37:31 <mux> I don't think it's possible to have qualified imports in ghci though, is it?
03:37:48 <stmartin> Hasn't complained.
03:38:20 <stmartin> Then again, I don't think its entirely worked either.
03:38:48 <mux> a qualified import is when you do import qualified Foo.Bar [as Baz]
03:38:56 <stmartin> I just went   let display_fields ....    but GHCi won't complete it at the prompt.
03:38:59 <mux> I don't think :m does that
03:47:56 <ndm> @seen dons
03:47:56 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 21m 25s ago.
03:48:09 <dons> ndm?
03:48:38 <ndm> dons: i checked out ESC/Haskell yesterday, its at least 2 years away from being useable on XMonad or similar projects, i suspect]
03:48:49 <dons> oh, that's a real pity.
03:48:58 <dons> i wish it was just open sourced, so we could start on it.
03:49:15 <dons> probably next i'll look at HPC, to get some coverage info from the QC tests
03:49:23 <pejo> Is that the project by Dana Xu(?)?
03:49:43 <dons> yep
03:50:05 <ndm> dons: the tree is hosted on darcs.haskell.org
03:50:17 <ndm> dons: but its way way too far off to be useful for anyone else to start on yet
03:50:33 <dons> ok
03:50:36 <ndm> it doesn't have rank-1 types, or "or" constraints
03:50:58 <ndm> although she has managed to get a lot of the GHC infrastructure stuff going, which is quite impressive
03:51:01 <mdmkolbe|work> @where ESC/Haskell
03:51:01 <lambdabot> I know nothing about esc/haskell.
03:51:07 <mdmkolbe|work> @go ESC/Haskell
03:51:09 <lambdabot> http://www.cl.cam.ac.uk/~nx200/
03:51:09 <lambdabot> Title: Dana N. Xu's homepage
03:51:23 <ndm> @where+ esc/haskell http://darcs.haskell.org/ghc-esc/
03:51:24 <lambdabot> Done.
03:51:49 <ndm> but i really wouldn't try it out, it was hitting bugs yesterday on even her small test suite
03:52:15 <koala_man> I have a [(Int,[Char])], how do I split them up giving me an [Int] and a [[Char]]?
03:52:22 <ndm> although on the plus side, it will rock once its done - you will be able to annotate your assumptions on Integral, unlike with Catch
03:52:35 <ndm> @hoogle [(a,b)] -> ([a],[b])
03:52:35 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
03:52:43 <ndm> koala_man: you ask hoogle ^^
03:52:43 <koala_man> yay. thanks
03:52:52 <mdmkolbe|work> @what ESC/Haskell
03:52:53 <lambdabot> http://darcs.haskell.org/ghc-esc/
03:53:38 <ndm> mdmkolbe|work: a static checker for haskell, HW2006 paper, equational reasoning machinery
03:54:01 <mdmkolbe|work> hmm, it looks like ESC/Haskell is being superceeded by Sound Haskell
03:54:06 <ndm> in some respects a competitor to catch, although catch is a more specific task done in an entirely automatic way
03:54:11 <ndm> mdmkolbe|work: i think they are the same thing
03:54:23 <ndm> mdmkolbe|work: actually, i know - i asked :)
03:54:47 <ndm> Sound Haskell is more like the next version of ESC/Haskell, using most of the same underlying ideas
03:55:27 * mdmkolbe|work adds the ESC/Haskell paper to his stack of papers to be read
04:02:06 <matthew-_> how did the Fun go yesterday at Cambridge?
04:02:33 <ndm> was cool :)
04:02:40 <ndm> free microsoft buffet, yum yum
04:02:55 <ndm> some interesting talks, some which confused me much
04:03:36 <matthew-_> lol - James McKinna speaking again? ;-)
04:06:02 <fons> hi all
04:06:41 <fons> does anybody know about a tool to generate a module dependency graph of a Haskell project?
04:08:01 <ndm> nah
04:08:10 <roconnor> sound like something that ought to exist
04:08:59 <mdmkolbe|work> fons: GHC might have a generate dependancies flags.  from that it would be some simple perl hacking to generate a 'dot' graph
04:10:09 <fons> mdmkolbe|work, uhm, it would be strange then that nobody did it already
04:10:29 <mdmkolbe|work> @where flags
04:10:30 <lambdabot> I know nothing about flags.
04:10:35 <malcolmw> matthew-_: if you know what an initial algebra and a final recursive coalgebra are, then you might have understood 2 minutes of one of the talks :-)
04:10:35 <mdmkolbe|work> @where+ flags http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
04:10:36 <lambdabot> Done.
04:11:24 <pejo> ndm/malcolmw, are these talks recorded?
04:11:35 <matthew-_> malcolmw: sounds good
04:12:40 <malcolmw> pejo: not that I know about
04:12:41 <mdmkolbe|work> fons: see 'ghc -M' (the data is there you just have to feed it to a graphing program) http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#sec-makefile-dependencies
04:12:43 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
04:16:13 <fons> bingo
04:16:16 <fons> http://www.loria.fr/~kow/download/ghcdep2dot.py
04:18:17 <fons> I just needed to search for "ghc -M" graphviz in google
04:21:01 <ADEpt> fons: i did the same thing (albeit simplier) in unix shell
04:22:09 <fons> ADEpt, url? the script I found doesn't seem to be working well
04:22:17 <Cheery> why deriving must be explicitly defined?
04:22:34 <Cheery> ie: data A = A deriving (Show,Eq,Ord) etc.
04:23:01 <quicksilver> Cheery: because you don't nessarily want everything to be a member of show,eq,ord ?
04:23:09 <Cheery> why can't it be automatic, for instance when you use (==), the compiler would derive the Eq for data type
04:23:35 <mdmkolbe|work> Cheery: you might want to write your own Eq or you might want a type not not support eq
04:24:23 <mdmkolbe|work> s/not not/ to not/
04:24:48 <Cheery> first thing is not a restriction, the second thing you said is something to consider
04:25:35 <Cheery> you might want a type not not support eq, you also might want not to care or get the deriving by inferring
04:25:55 <quicksilver> which implementation of Ord you use can totally change the meaning of your program
04:25:58 <matthew-_> ndm: you're at york right? How come you made it to the Cambridge Fun and not the Nottingham Fun?
04:25:59 <Cheery> *and *by inference
04:26:12 <quicksilver> therefore it is not unreasonable to make people be explicit about which instance they mean
04:26:22 <quicksilver> (same os true of Eq but it seems stronger with Ord)
04:27:29 <Cheery> can you derive Ord for your data type other way than: data A = A deriving (Eq,Ord)  ?
04:27:30 <mdmkolbe|work> Eq of Nan is a good case (b/c it's not Eq to anything)
04:27:49 <mdmkolbe|work> Cheery: you can always declare an instance
04:27:57 <mdmkolbe|work> @src Ord
04:27:57 <lambdabot> class  (Eq a) => Ord a  where
04:27:58 <lambdabot>     compare      :: a -> a -> Ordering
04:27:58 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:27:58 <lambdabot>     max, min         :: a -> a -> a
04:28:26 <mdmkolbe|work> instance Ord A where compare A A = Eq; A < A = False; ...
04:29:29 <Cheery> the whole point is why one can't have something like: data A = A derive implicitly
04:30:01 <Cheery> and then the ghc would automatically derive those in need, unless you have given instance already
04:30:09 <DRMacIver> Ord is a great example of why I want it to be possible to have a type be an instance of a type class in multiple ways.
04:30:56 <pejo> Cheery, and their point is that it might not be what you want. You might want a data type where (==) isn't defined.
04:31:03 <mdmkolbe|work> Cheery: we would want to also have a syntax to say *dont* do any deriving even without declaring an instance
04:31:42 <quicksilver> DRMacIver: I always find Monoid and Monad better examples personally, but yes :)
04:32:19 <quicksilver> Cheery: because the derivable Ord instance is a choice
04:32:26 <quicksilver> Cheery: and it violates data type abstraction
04:32:33 <quicksilver> Cheery: that's a choice you should be forced to make explicitly
04:33:07 <QtPlatypus> pejo: What type would the idenety property not be valid for?
04:35:12 <mdmkolbe|work> Cheery: probably the biggest problem is that data A = A deriving (Show) would have fewer classes for A than data A = A
04:43:21 <stmartin> Can a list carry strings AND numbers somehow?
04:43:47 <jyp> stmartin: [Either String Int]
04:43:56 <stmartin> Ah, thanks.
04:44:12 <jyp> np :)
04:44:38 <kaol> there's hlist too
04:44:50 <quicksilver> but that's probably not the right answer :)
04:45:22 <stmartin> And I would populate such a list like   [Right anum, Left astring]   correct?
04:45:28 <quicksilver> yup
04:45:50 <quicksilver> > [Right 5, Right 8, Left "boo", Right 12] :: Either String Int
04:45:51 <dons> > [Right 1, Left "foo", Right 7]
04:45:51 <lambdabot>  Couldn't match expected type `Either String Int'
04:45:52 <lambdabot>  [Right 1,Left "foo",Right 7]
04:45:59 <quicksilver> bah
04:46:38 <jyp> > let l = [Right 1,Left "foo",Right 7] in [x | Right x <- l]
04:46:39 <lambdabot>  [1,7]
04:46:49 <jyp> is quite a cool feature of haskell :)
04:46:52 <dons> stmartin: the runtime tags used implicitly in a dynamically typed langauge to implement heterogeneous lists are explicit in Haskell, and you can also constrain the set of types allowed
04:47:14 * quicksilver recoils from a Simon-slap
04:47:22 <stmartin> Can I match the type in a pattern?
04:47:29 <dons> the constructor, yes.
04:47:32 <dons> see the jyp example
04:47:43 <mdmkolbe|work> quicksilver: "Simon-slap"?
04:47:57 <stmartin> Excellent     (Steeple fingers!)
04:48:09 <quicksilver> mdmkolbe|work: SPJ told me to moderate my language :)
04:48:10 <kolmodin> dons: very interesting post about xmonad/zipper!
04:48:39 <quicksilver> mdmkolbe|work: not entirely unreasonably :)
04:48:53 <dons> > let onlyStrings [] = []; onlyStrings ((Left s):ss) = s : onlyStrings ss ; onlyStrings ((Right _):ss) = onlyStrings ss in    onlyStrings [Right 1, Left "foo", Right 7]
04:48:55 <lambdabot>  ["foo"]
04:49:01 <dons> kolmodin: cheers.
04:49:12 <dons> yeah, focus is a one hole context into a window stack. fun
04:49:42 <quicksilver> dons: the list comp version is a lot more attractive, isn't it? :)
04:49:51 <dons> by far, by far
04:50:05 <quicksilver> dons: although, admittedly, the long hand looks much neater over 3 lines than it does compressed into one
04:50:11 <dons> (and makes desugaring list comprehensions too complicated!)
04:50:29 <dons> just wanted to illustrate explicit pattern matching on tags.
04:52:43 <mdmkolbe|work> dons: I understand the ziper, but I'm not clear on the use here.  Is the tree fixed depth?
04:53:10 * mdmkolbe|work only just now skimed the blog
04:53:12 <dons> we use the zipper derivation of a list, i.e. a list with a focused element only, so not as a tree.
04:53:36 <dons> each workspace is a separate list zipper
04:54:21 <mdmkolbe|work> dons: ok, that makes sense now
04:54:48 <mdmkolbe|work> has anyone done a zipper for a cyclic data type?
04:55:02 <dons> not that i know of, but that's actually what i'd like :-)
04:55:14 <dons> since focus wraps on workspaces, complicating things a bit
04:56:30 <mdmkolbe|work> ask me about it when I'm at home and I'll give it a shot
04:57:44 <dons> jyp++ good work
04:58:12 <jyp> hey, thanks dons :)
05:00:13 <dons> yi 0.2 has been released. wonderful.
05:00:13 <dons> http://article.gmane.org/gmane.comp.lang.haskell.general/15260
05:00:13 <lambdabot> Title: Gmane -- Mail To News And Back Again
05:00:19 <dons> nice screenshot on the wiki page
05:01:14 <jyp> It's still a long road ahead; but it's an exiting milestone to pass for sure :)
05:02:07 <kolmodin> dons: tiny detail.. your zipperish 'index' uses a variable that doesn't exist. you mean 'ls' not 'l'
05:02:27 <dons> heh oops
05:02:32 <kolmodin> :)
05:03:17 <dons> ah yes, a tyvar that doesn't exist.
05:03:44 <dons> (though the real xmonad is polymorphic in the xinerma screen index, and the workspace index, the demo blog version is monomorphic on Int here.)
05:04:11 <stmartin> What's an easy way to replace item n in a list?
05:05:52 <jyp> stmartin: you might be better off using an array
05:05:54 <kolmodin> stmartin: it's thinking which data structure you really should be using
05:06:06 <kolmodin> jyp: :)
05:06:19 <mdmkolbe|work> jyp: does yi, have a well defined semantics for if two modes fight over how a file should be marked up?  (both the GNU-Emacs and the XEmacs models of how to format text are broken IMHO (I've given it considerable thought to how it ought to be))
05:06:19 <jyp> or even re-think the algorithm...
05:06:45 <quicksilver> stmartin: (take (n-1) l) ++ x ++ (drop n l)
05:07:00 <quicksilver> erm [x] instead of x, there
05:07:06 <stmartin> Thanks. That will do nicely.
05:07:15 <jyp> mdmkolbe|work: markup is really in its infancy now
05:08:00 <jyp> mdmkolbe|work: there is no way to compose markup styles for sure.
05:08:07 <stmartin> I had a vaguely Shwatzian thing going on with a [1..] and a lambda to know when to change it.
05:08:35 <kolmodin> kosmikus: has talked a bit about data structures... http://www.iai.uni-bonn.de/~loeh/afp-ds-1.pdf http://www.iai.uni-bonn.de/~loeh/afp-ds-2.pdf
05:08:48 <mdmkolbe|work> jyp: so are you using mutable state per character (GNU Emacs style) or start/end regions of markup (XEmacs style) or something else?
05:09:16 <jyp> mdmkolbe|work: I haven't worked on that bit myself
05:09:26 <dons> so stlil the original FastBuffer.hs ?
05:09:29 <jyp> Stephan O'Rear has
05:09:36 <stmartin> I ordered Chris Okasaki's book on Purely Functional Data Structures, but haven't had the time to read it yet.
05:09:39 <dons> oh, the markup. right.
05:09:52 <dons> mdmkolbe|work: start/end regions, iirc.
05:09:59 <jyp> mdmkolbe|work: If you have good ideas, please share them :)
05:10:18 <jyp> mdmkolbe|work: and if you have code, please send in patches :p
05:10:24 <kolmodin> stmartin: me neither. it's next to my bed :)
05:11:02 <mdmkolbe|work> jyp: I'll have to write it up, b/c it's somewhat complicated (which I can demonstrait is of nessesity).  To big for IRC.
05:11:44 <jyp> mdmkolbe|work: I can imagine ;) Copy me if you come up with anything though.
05:12:12 <quicksilver> mdmkolbe|work: I'd be interested in that too, it's something I often think about
05:12:22 <quicksilver> mdmkolbe|work: since I often have to edit mixed-mode or fragmentary files
05:16:28 <flux> hmm.. can you define new functions runtime in yi?
05:16:54 <jyp> flux: yes
05:17:37 <flux> how about redefine? what happens to functions that refer to the function?
05:18:17 <jyp> they keep referring to the old code; unless they are re-defined themselves
05:19:49 <mdmkolbe|work> I presume yi has interactive entry of new functions
05:20:03 <mdmkolbe|work> how do you deal with mutually recursive functions?  You couldn't define them one at a time (e.g. like GHCi does)
05:20:29 <jyp> mdmkolbe|work: I type them in a file and then load the file
05:20:36 <jyp> (same as ghci indeed)
05:21:12 <TSC> That sounds better than how Emacs works
05:22:23 <jyp> The general idea is: do the same as ghci. Mainly because that saves writing special code :)
05:22:24 <mdmkolbe|work> TSC: I'm just thinging some of my scheme friends would be very unhappy with having to type it into a file.  They like to type info a file, but just hit some key that runs the locally selected *expression* (not the entire file).  So they can hack around and experiment without requireing the entire file be valid scheme
05:22:46 <mdmkolbe|work> jyp: it is on top of GHCi
05:23:21 <mdmkolbe|work> jyp: sorry "is it on top of GHCi?"
05:27:20 <jyp_> mdmkolbe|work: Sorry for disconnecting.
05:27:25 <jyp_> :/
05:27:49 <jyp_> mdmkolbe|work: For one thing, you can run the selected expression without any problem;
05:28:20 <mdmkolbe|work> jyp: but only if it refers to things already defined?
05:28:32 <mdmkolbe|work> (1:22:22 PM) mdmkolbe|work: jyp: sorry "is it on top of GHCi?"
05:28:37 <quicksilver> mdmkolbe|work: of course such a workflow leads you into creating a state in the interpreter which can never be re-created
05:28:41 <jyp_> mdmkolbe|work: yes.
05:28:49 <quicksilver> mdmkolbe|work: (since it refers to old versions of functions since redefined)
05:29:00 <quicksilver> mdmkolbe|work: I've had this exact problem with ML repls in the past
05:29:04 <jyp_> the underlying engine in GHC api, which means GHCi really.
05:29:19 <quicksilver> mdmkolbe|work: so, this workflow may somewhat be 'to be discouraged'
05:29:47 <mdmkolbe|work> quicksilver: in scheme the old functions get updated, so it apearently works out ok for them
05:31:01 <mdmkolbe|work> quicksilver: (define foo (lambda () (print "x"))) (define bar (lambda () (foo))) (define foo (lambda () (print "y"))) (foo) ==> y
05:41:45 <quicksilver> mdmkolbe|work: I think you meant to call (bar) at the end? if you wanted to illustrate your point ?
05:45:03 <mdmkolbe|work> quicksilver: yes, you're right
05:45:40 <quicksilver> mdmkolbe|work: but yes, I see what you mean. I don't think this can be acheived in a 'naive ghci' kind of implementation
05:46:08 <quicksilver> mdmkolbe|work: you'd have to either reload the whole file each time or keep around parsed-but-not-compiled bits
05:52:59 <mdmkolbe|work> quicksilver: yeah, that's part of the reason I'm really currious to see whether Haskell can be dynamic enough to be used as the scripting language of an application
05:53:41 <cdsmith> I'm reading GHC commentary pages.  What is CoreTidy?
05:54:34 <cdsmith> Hi cheeseguy! :)
05:56:09 <quicksilver> mdmkolbe|work: I think so
05:56:29 <quicksilver> mdmkolbe|work: it's just y ou have to keep your 'scriptable functions' in a registry
05:56:43 <quicksilver> mdmkolbe|work: and access them by name, IYSWIM
05:57:05 <quicksilver> mdmkolbe|work: i.e. add another level of indirection, explicitly
05:57:42 <mdmkolbe|work> quicksilver: yeah, but we really don't want to add extra typing when scripting
05:58:01 <mdmkolbe|work> quicksilver: this is just one example of where Haskell has trouble bring a scripting language
05:58:36 <quicksilver> mdmkolbe|work: oh, I see
05:58:48 <quicksilver> mdmkolbe|work: well yes, I think the 'scripting' language would have a little bit of sugar
05:59:25 <mdmkolbe|work> quicksilver: another is that usually in a scripting lang, if the user wants to do it, the user should be allowed to do it even when it isn't type safe.  (Often it's still safe in "this particular case" and should be allowed)
05:59:32 <quicksilver> mdmkolbe|work: to automatically call those named functions in some convenient way
05:59:45 <quicksilver> mdmkolbe|work: ah, I disagree with that :)
05:59:53 <quicksilver> mdmkolbe|work: if it isn't type safe, it doesn't even make sense
06:00:03 <quicksilver> mdmkolbe|work: if it makes sense, you can rearrange your types so it's safe
06:00:58 <hpaste>  stmartin annotated "ui_mainloop" with "String vs ()" at http://hpaste.org/1881#a1
06:01:48 <stmartin> I'm getting better at tracking down the error messages. But this one seems to say that the result of a do expression isn't the last result inside of it.
06:01:50 <mdmkolbe|work> quicksilver: but when I'm scripting I don't want to do that much work.  I've got some task that needs to be accomplished (right now) and I'm not going to reuse the work, so stuffing String, Nums, Trees, etc into a single list and printing the whole thing out might be reasonable in some domains
06:02:52 <quicksilver> mdmkolbe|work: maybe.
06:03:06 <quicksilver> mdmkolbe|work: or maybe you're just used to doing it that way and haven't seen how convenient the other way can be
06:03:16 <quicksilver> mdmkolbe|work: strictly typed scripting is a rather unexplored field
06:03:27 <quicksilver> mdmkolbe|work: I'm reserving judgement until I've seen people try :)
06:04:49 <jyp> Well, I have tried, and I'm sure it works :)
06:04:51 <quicksilver> stmartin: you haven't really given me enough context
06:05:03 <quicksilver> stmartin: but it looks to me like filearg_command is returning ()
06:05:16 <quicksilver> stmartin: and so Left f is, in fact Left ()
06:05:19 <quicksilver> stmartin: which doesn't match
06:05:31 <quicksilver> jyp: did you observe my comments about a registry of named functions
06:05:38 <stmartin> Hmmm, something to think about.
06:05:44 <quicksilver> jyp: any comment ont hat? does that relate to the Yi approach?
06:06:02 <stmartin> Ahh, yes. Gotcha.
06:06:27 <mdmkolbe|work> stmartin: annotate p_write_file and write_file with types and the error will likely get more localized (i.e. closer to the cause).  When GHC has to infer types, the error can be a long way away from where it is reported (i.e. type errors roam)
06:07:39 <stmartin> I try not to annotate Parsec-related functions... makes my head spin. But I have done this in other places, particularly at API points. Thanks for the advice though.
06:07:54 <jyp> quicksilver: I considered doing something of that sort
06:08:35 <jyp> but I'd rather use bare-bones haskell
06:08:40 <stmartin> Great. Working now.
06:08:43 <jyp> (at least at the moment)
06:10:03 <jyp> If pure-haskell doesn't work for a scripting language, the solution has to be provided at the language level, i think.
06:10:18 <jyp> maybe the work on the GHC debugger can be applied in this area
06:10:26 <jyp> (in some rather distant future)
06:11:39 <quicksilver> jyp: you are not concerned about the 'redefining foo has no effect' problem, then?
06:11:51 <jyp> No.
06:12:02 <quicksilver> probably there are different ways to approach the problems that arise
06:12:08 <quicksilver> but in, e.g., an emacs-like-system
06:12:15 <quicksilver> you expect that if you redefine switch-to-buffer
06:12:21 <quicksilver> it immediately affects all old code
06:12:21 <jyp> effectful-redefine does not fit with haskell semantics at all
06:12:23 <quicksilver> IYWSWIM
06:12:47 <jyp> Yeah, but you can redefine+reload
06:12:56 <stmartin> FWIW, I think Haskell would make a very good sort of model for a scripting language, especially when you redefine much of the Unix toolbox commands to be in the same language, so you're not always having to re-parse data. This way, you would work around a lot of the weaknesses in the typical shell programming environment. I would have to be convinced of the usefulness of strict typing in this situation though.
06:13:08 <jyp> @go IYWSWIM
06:13:10 <lambdabot> http://teqkiller.livejournal.com/751260.html
06:13:10 <lambdabot> Title:
06:13:18 <mdmkolbe|work> jyp: that is only acceptable if you can reaload everything in less than 100ms
06:13:25 <quicksilver> I misspelt 'IYSWIM'
06:13:26 <mdmkolbe|work> IYSWIM = If you see what I mean
06:13:28 <quicksilver> If you see what I mean
06:13:34 <jyp> mdmkolbe|work: this seems to be the case.
06:13:40 <quicksilver> misspelt acronyms ftw!
06:13:53 <jyp> :)
06:13:58 <quicksilver> jyp: oh, interesting
06:14:08 <quicksilver> jyp: but as your library of editor functionality gets large
06:14:18 <quicksilver> jyp: you're talking about reloading *verything* each time you do that
06:14:33 <jyp> Only if you redefine stuff at "low-level" libraries
06:14:47 <jyp> which is tricky and to be avoided in any case :)
06:14:47 <quicksilver> oh, you can modularise reloading?
06:14:50 <flux> there could be a dependency graph so you only would reload functions that need to be?
06:14:52 <quicksilver> that helps
06:14:54 <jyp> GHCi does!
06:15:00 <quicksilver> ah yes, of course it does
06:15:02 * quicksilver nods
06:15:17 <quicksilver> good point, that man!
06:15:18 <jyp> (it's a great piece of software! :)
06:15:33 * quicksilver continues to ponder the issue
06:16:21 <jyp> it's a tough issue for sure; and I don't have a strong opinion myself.
06:16:32 <quicksilver> jyp: excuse my being lazy and asking you rather than consulting the source
06:16:41 <quicksilver> jyp: but how does, for example, the toolbar and menus get built?
06:16:49 <jyp> But the KISS approach has to be tried as a first step.
06:16:51 <quicksilver> jyp: if I reload just one module how would 'just its' items be reloaded?
06:17:15 <jyp> The question is easily answered by the absence of toolbar or menus :)
06:17:22 <jyp> But in the future, yes.
06:17:40 <chessguy> what are you guys talking about?
06:17:41 <jyp> Now, you say "reload-keymap" or something
06:18:13 <jyp> it would be extended by reload-menus/toolbar/everything
06:18:24 <quicksilver> chessguy: Yi
06:18:27 <quicksilver> chessguy: haskell editor
06:18:30 <chessguy> ah, ok
06:18:45 <quicksilver> jyp: and the keymap reloader somehow calls a hook in every loaded module?
06:18:51 <quicksilver> jyp: something along those lines?
06:19:01 <quicksilver> modules.give-me-your-keys?
06:19:08 <jyp> imagine you do a :r in ghci
06:19:26 <jyp> then: setKeymap newlyDefinedKeymap
06:19:49 <quicksilver> yes, but suppose 6 different modules all contribute to the keymap
06:19:56 <quicksilver> and I've only reloaded one of them
06:20:12 <jyp> this is not possible
06:20:34 <jyp> the top-level definition of the keymap will necessarily be reloaded
06:21:11 <jyp> it's quite a "functional" (ie. stateless) approach to configuration
06:21:21 <jyp> You have state;
06:21:31 <jyp> but just a little bit ...
06:21:38 <jyp> one variable for the keymap
06:21:42 <jyp> that's all :)
06:22:23 <quicksilver> hmm
06:22:43 <quicksilver> so modules can't contribute their own keybindings?
06:22:48 <quicksilver> that sounds a bit limiting...
06:23:08 <quicksilver> (surely there is other state too: buffers open, modes of buffers, cursor location, etc)
06:23:26 <jyp> It's limiting indeed
06:23:47 <jyp> but we have quite a convenient combinators library for combining keymaps
06:24:38 <jyp> For the other bits of state; they are treated differently because they are "data", not "code"
06:25:42 <jyp> for now "mode of buffer" = "keymap"
06:26:16 <stmartin> jyp: out of curiosity, will Yi have a nicely scriptable UI? I'd really like something that could present data in a graphical form, and be able to specify what that (GUI) form is, and how it relates to the data. Like a DocBook editor.
06:26:58 <stmartin> Or a blog-editor-view of an RSS document.
06:27:25 <chessguy> oh shapr's latest blog is a classic
06:27:32 <jyp> stmartin: This would be really nice indeed
06:27:45 <quicksilver> stmartin: generic scriptable UI is hard
06:27:46 <jyp> stmartin: but we are nowhere near that
06:27:52 <quicksilver> stmartin: would be nice though :)
06:27:56 <chessguy> @quote hilton
06:27:57 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
06:27:59 <chessguy> @quote hilton
06:27:59 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
06:28:14 <stmartin> And if you make it run on Psion 5, I would pay for that.
06:28:39 <Cf> can anyone shed some light on this problem for me please? why the differing type sigs:
06:28:41 <Cf> *Main> let bob = \x y -> x + y
06:28:41 <Cf> *Main> :t bob
06:28:41 <Cf> bob :: Integer -> Integer -> Integer
06:28:41 <Cf> *Main> :t \x y -> x + y
06:28:41 <Cf> \x y -> x + y :: (Num a) => a -> a -> a
06:28:51 <chessguy> @remember dons she wrote some nice papers in the late 80s on generational garbage collection, I think. there was one with Wadler, iirc. on removing intermediate lists. unless i'm thinking of the wrong paris hilton.
06:28:51 <lambdabot> Done.
06:28:56 <jyp> stmartin: do you mean something like http://www.cs.kent.ac.uk/projects/pivotal/
06:28:58 <lambdabot> Title: Pivotal home page
06:29:00 <quicksilver> Cf: that's defaulting for you
06:29:11 <quicksilver> Cf: it's just a weird effect of the ghci top-level
06:29:47 <Cf> i always include type sigs anyway so not really an issue
06:29:50 <Cf> i just found it weird :)
06:29:59 <stmartin> That looks really quite cool.
06:30:01 <quicksilver> Cf: it's related to the monomorphism restriction
06:30:20 <quicksilver> Cf: you'll find that let bob x y = x + y gets the general type
06:30:40 <Cf> indeed it does
06:30:53 <Cf> why's that then?
06:31:20 <jyp> @type let bob x y = x + y in bob
06:31:23 <lambdabot> forall a. (Num a) => a -> a -> a
06:31:45 <quicksilver> Cf: basically, bob = \x y -> x+y "looks like" a constant
06:31:53 <quicksilver> Cf: in the sense that bob takes no parameters
06:31:59 <quicksilver> Cf: so you'd imagine 'bob' is constant
06:32:14 <quicksilver> Cf: supposedly it's "less confusing" if such things are indeed constant
06:32:21 <quicksilver> Cf: (and not polymorphic)
06:32:33 <quicksilver> @where monomorphism
06:32:33 <lambdabot> I know nothing about monomorphism.
06:32:43 <Cf> i thought being able to do "bob x y" was just a syntactic niceness and was converted to the lambda form?
06:33:04 <quicksilver> @where+ monomorphism http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:33:04 <lambdabot> Done.
06:33:10 <quicksilver> Cf: yes, it is. almost
06:33:19 <quicksilver> Cf: except for this one silly point about the monomorphism restriction :)
06:33:31 <Cf> i shall have a read of that page :)
06:34:30 <Cf> first two there seem to be same as what i'm trying to do
06:37:11 <Cf> @type let bob = \ x y -> x + y in bob
06:37:14 <lambdabot> forall a. (Num a) => a -> a -> a
06:39:36 <quicksilver> Cf: LB doesn't appear to have the restriction
06:39:41 <quicksilver> Cf: it's not exactly like ghci
06:39:51 <petekaz> I'm confusing myself, if one uses foldl', but the function passed is not strict, is that just as bad as using the non-strict foldl?
06:39:53 <quicksilver> Cf: for a start, it has various options on
06:40:07 <Cf> aye, just wanted to test working it :)
06:44:47 <dons> petekaz: nope.
06:44:51 <dons> ?Src foldl'
06:44:52 <lambdabot> Maybe you meant: rc src
06:44:57 <dons> ?src foldl'
06:44:57 <lambdabot> foldl' f a []     = a
06:44:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:45:57 <swiert> Is there a workaround for getting haddock to parse infix type constructors?
06:45:57 <petekaz> So even if f is not strict, it will be evaluated because of the seq?
06:46:25 <petekaz> So there is no problem/worry using foldl' with a function that is not strict?
06:48:40 <chessguy> is the kowey of on here?
06:48:44 <chessguy> of http://koweycode.blogspot.com/2007/05/risk-and-recursion.html
06:48:45 <lambdabot> Title: koweycode: risk and recursion
06:49:06 <quicksilver> petekaz: it wil be evaluated to whnf, at least
06:49:50 <chessguy> ?seen kowey
06:49:50 <lambdabot> I saw kowey leaving #darcs and #haskell 1d 17h 29m 13s ago, and .
06:51:58 <kosmikus> jyp: I'm currently trying to install yi. Seems to be much easier than in the past, so far, so good ...
06:52:24 <jyp> kosmikus: thanks for the feedback :)
06:52:33 <kosmikus> jyp: I'm now at the point of opening yi (-gtk) and get a copmlaint that YiConfig cannot be found.
06:52:56 <jyp> Does the editor work besides?
06:53:02 <kosmikus> jyp: if I type a ranodom key, I get a message it isn't defined and that a README file might help me
06:53:07 <kosmikus> jyp: but there isn't any.
06:53:14 <jyp> oh gosh.
06:53:17 <jyp> Well,
06:53:30 <jyp> use the --as=vim option
06:53:38 <kosmikus> so I now can successfully quit the editor again with 'q', but don't know how to do anything else
06:53:50 <kosmikus> ah :)
06:53:56 <kosmikus> that's progress
06:54:58 <haskellnew> i have a "ht which is of type IO (HashTable String b) "  i.e (IO a)  now how do i extract "a" from (IO a) and do some operation on "a" eg insert some key values in hashtable
06:56:20 <quicksilver> haskellnew: using <-
06:56:50 <quicksilver> do \n  realht <- ht  \n  do_something_with realht
06:56:58 <Igloo> Is it just me, or is http://www.haskell.org/pipermail/haskell-cafe/2007-May/025565.html very suspicious looking?
06:57:00 <lambdabot> Title: [Haskell-cafe] haskell-lang.org, http://tinyurl.com/yqjyhs
06:57:30 <quicksilver> Igloo: definitely a bit odd
06:58:05 <psnl> Igloo: squatter?
06:58:14 <quicksilver> he's only asking a few dollars for it
06:58:23 <quicksilver> so he's not really making much profit out of it :P
06:58:45 <psnl> true. who owns haskell.org?
06:59:06 <roconnor> @who-is haskell.org
06:59:06 <lambdabot> Unknown command, try @list
06:59:09 <roconnor> damn
06:59:11 <Igloo> I'm not actually sure who pays for it
06:59:35 <psnl> Yale?
06:59:41 <Igloo> Could be
06:59:50 <psnl> Registrant Name:YaleUniversityComputer Science Department Haskell Group
07:00:07 <Apocalisp> Have you tried out Clean?
07:03:01 <psnl> Igloo: suggestting that MSR or someone looks after it isn't a bad idea.
07:04:03 <Igloo> psnl: Looks after what?
07:04:32 <psnl> Igloo: haskell-lang.org.
07:04:46 <Igloo> What do you mean by "looks after", then?
07:05:19 <psnl> holds it, has a cname to haskell.org. its not really needed at all.
07:05:38 * Igloo doesn't think it's worth spending tuppence on
07:05:44 * psnl shrugs
07:06:35 <quicksilver> Igloo: I wouldn't even spend a farthing
07:07:45 <chessguy> Igloo: even more suspicious that i saw a similar comment about a lisp site today
07:07:58 <Igloo> chessguy: Oh? Have you got a URL?
07:08:05 <greenrd> psnl: then what's next, haskelllang.org, haskell-lang.net, haskell-lang.info...?
07:08:11 <greenrd> where does it end?
07:08:11 <haskellnew> quicksilver : ok , thanks , but some error is there , i think i am trying to do another monadic computation inside original monadic computation ,
07:08:25 <quicksilver> haskellnew: actually you can do that
07:08:29 <quicksilver> haskellnew: if you want to :)
07:08:31 <chessguy> http://clemens.endorphin.org/weblog/archives/2007-05.shtml#e2007-05-18T10_53_19.txt
07:08:34 <quicksilver> haskellnew: why don't you hpaste the code
07:08:34 <lambdabot> Title: clemens.endorphin.org/weblog - May 2007 Archives - clemens.endorphin.org, http://tinyurl.com/284zvt
07:08:41 <quicksilver> haskellnew: and we'll look at it !
07:09:03 <haskellnew> quicksilver : ok
07:10:52 <psnl> greenrd: its not needed, so holding only one site is fine.
07:11:48 <therp> chessguy: that's my site
07:12:09 <chessguy> therp: ah, ok
07:12:10 <therp> chessguy: at least till 21/05 :)..
07:13:02 <chessguy> Igloo: ignore that then
07:14:41 <jyp> kosmikus: please check out http://haskell.org/haskellwiki/Yi#How_to_Configure_Yi
07:14:42 <lambdabot> Title: Yi - HaskellWiki
07:15:56 <hpaste>  haskellnew pasted "monadic problem ?" at http://hpaste.org/1883
07:16:31 * shapr boings
07:16:40 <haskellnew> quicksilver : i have pasted the code , problem is in keyval and bencDict functions
07:18:34 <Saizan> haskellnew: using HashTable there is going to be painful
07:18:59 <chessguy> hey shapr, i loved your latest blog
07:19:00 <Saizan> haskellnew: i'd use Data.Map.Map which has a pure API
07:19:17 <quicksilver> I think Saizan's advice will be good
07:19:29 <quicksilver> haskellnew: there is no sensible way of writing keyval with that type
07:19:48 <quicksilver> haskellnew: if it's going to use it's IO input, it will have an IO type itself
07:19:59 <quicksilver> haskellnew: otherwise the only thing it can possibly do is ignore it
07:20:11 <shapr> chessguy: Yeah, dons is very funny :-)
07:20:14 <haskellnew> Saizan : ok thanks i will look at it
07:20:15 <quicksilver> haskellnew: but Data.Map is better than HashTable unless you have really specific speed needs :)
07:20:17 <chessguy> @quote ilton
07:20:17 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
07:20:19 <chessguy> @quote ilton
07:20:19 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
07:20:20 <chessguy> @quote ilton
07:20:21 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
07:20:35 <SamB> @quote lton
07:20:35 <lambdabot> palomer says: Category theory is the Paris Hilton of mathematics
07:20:37 <haskellnew> qucksilver : thanks
07:20:40 <quicksilver> chessguy: it's not actually funnier three times than one time, though :P
07:20:42 <chessguy> @quote intermediat list
07:20:42 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
07:20:50 * SamB was hoping for an mlton quote
07:20:53 <chessguy> quicksilver: i was looking for a different quote
07:21:01 <quicksilver> ah
07:21:01 <SamB> @quote ton
07:21:02 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
07:21:02 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
07:21:02 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
07:21:13 <chessguy> @quote intermediate.lists
07:21:13 <lambdabot> dons says: she wrote some nice papers in the late 80s on generational garbage collection, I think. there was one with Wadler, iirc. on removing intermediate lists. unless i'm thinking of the wrong
07:21:13 <lambdabot> paris hilton.
07:21:57 <SamB> maybe paris hilton is a hotel
07:31:35 <Igloo> dcoutts__: Is there a good reason not to export simpleUserHooks from Distribution.Simple?
07:41:03 <migraine> #join /languages
07:41:08 <migraine> oops my bad
07:41:35 <osfameron> bad language?
07:41:56 <migraine> typo...
07:42:53 <minimal-criminal> no one in #languages
07:43:53 <shapr> If a metal-dielectric interface is used as a waveguide in asymmetric mode, is that the equivalent of a halbach array of permament magnets?
07:44:42 <dcoutts__> Igloo: probably not
07:44:48 <matthew-_> @slap shapr
07:44:48 * lambdabot slaps shapr
07:44:50 <matthew-_> ;-)
07:44:55 <shapr> matthew-_: Hey, it's a valid question!
07:45:09 <matthew-_> oh! I thought you were on drugs or something. Sorry!
07:45:19 <shapr> I've been reading about plasmonics.
07:45:28 <matthew-_> monads?
07:46:07 <shapr> And I think the metal-dielectric waveguide approach is the equivalent of a halbach array. But I'm not sure. And where else would I ask such a question?
07:46:17 <matthew-_> #plasmonics ?
07:46:35 <shapr> Hm, that channel is empty.
07:46:48 <matthew-_> I regularly tell the guys in there to go to #haskell when they want to discuss Monads...
07:47:38 <sdf> matthew is haskell programming language??
07:48:02 <sieni> sdf: are you trolling?
07:48:08 <shapr> sdf: Yes, Haskell is a programming language.
07:48:22 <shapr> sdf: Would you like to learn Haskell?
07:48:33 <sjanssen> @yow
07:48:33 <lambdabot> He is the MELBA-BEING ... the ANGEL CAKE ... XEROX him ... XEROX him --
07:48:44 <sdf> shapr i never heard about it
07:49:05 <shapr> sdf: Are you from Italy? Or Egypt maybe?
07:49:15 <sdf> egypt
07:49:28 <shapr> Oh, I don't know of an egyptian Haskell channel.
07:49:36 <sieni> > take 10 $ nubBy (((>1).).gcd) [2..]
07:49:37 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
07:49:41 <sdf> shapr why do you ask?
07:50:04 <shapr> sdf: Because there are lots of spoken-language-specific Haskell channels and I thought joining one that uses your native language might help.
07:50:19 <dons> ?seen lambdabot
07:50:20 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-
07:50:20 <lambdabot> haskell, #darcs and #scannedinavian
07:50:27 <shapr> hiya dons!
07:50:34 <dons> oh, that's not the language channels.
07:50:35 <osfameron> oh, is there an Italian haskell channel ?
07:50:38 <dons> they're on lambdabot2.
07:50:41 <dons> osfameron: yeah.
07:50:45 <dons> ?wiki IRC_channel
07:50:46 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
07:50:54 <Saizan> osfameron: yes, #haskell.it
07:51:13 <dons> 00:50 lambdabot2> Yes, I'm here. I'm in #haskell.de, #haskell.es, #haskell.fi, #haskell.fr,
07:51:17 <dons>                   #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru and #haskell.se
07:51:28 <sdf> shapr is haskell  similar to c or c++ ??
07:51:35 <shapr> sdf: No
07:51:36 <Apocalisp> No haskell.is?
07:51:40 <Apocalisp> bummer.
07:51:53 <shapr> sdf: Haskell is closer to Lisp than C or C++
07:52:03 <sjanssen> sdf: have you heard of OCaml?  Clean? ML?
07:52:07 <sdf> oh AI
07:52:13 <shapr> sdf: No, not AI
07:52:15 <sdf> no
07:52:19 <sjanssen> Haskell is closely related with all those
07:52:25 <sjanssen> sdf: the key word is "functional"
07:52:25 <shapr> @oldwiki HaskellDemo
07:52:26 <lambdabot> http://www.haskell.org/hawiki/HaskellDemo
07:52:51 <sdf> what are it applications?
07:53:01 <sieni> anything you wish
07:53:03 <dons> sjanssen: can you also reply to spj regarding the xmonad tutorial at oscon?
07:53:12 <sieni> Haskell is a general-purpose programming language
07:54:03 <dons> shapr: see the yi release?
07:54:20 <dons> jyp has done a great job, some 4 years on from our original hemacs idea :-)
07:54:21 <sjanssen> dons: yeah
07:54:22 <shapr> sdf: I've seen Haskell used for a mailing list archive webapp, a spam filter, an irc bot, a text editor, a window manager, an irc client, an automatic natural language translation system, compilers, interpreters, quake/doom clones, and lots more.
07:54:26 <shapr> dons: w00!
07:54:32 <shapr> Where do I get it?
07:54:40 <ndm> dons: spj said the main thing he was concerned about is can he change the algorithm or something and have the changes "appear", i.e. recompile and restart X quickly
07:54:49 <dons> shapr: hehe, 01.12.21:04:05:27 <shapr> man, I wish haskell had hemacs like python has pymacs
07:54:54 <sdf> oh wonderful
07:55:01 <dons> ndm, oh, that's certainly doable.
07:55:14 <dons> 02.11.07:08:06:22 <ayrnieu> I'm interested in tasks that require the kind of flexibility hemacs would need
07:55:18 <dons> (hah!)
07:55:30 <dons> 04.10.13:19:42:46 <dons> hemacs is born : darcs get http://www.cse.unsw.edu.au/~dons/code/hemacs
07:55:32 <ndm> dons: that was the one thing he asked if i knew, of course i've never actually run XMonad so had no idea,,,
07:55:33 <quicksilver> ndm: apropos of what, ndm?
07:55:36 <shapr> dons: Gee, that's more like six years, isn't it?
07:55:36 <Syzygy-> dons, ndm: fluxbox certainly is capable of just rebooting the windowmanager.
07:55:37 <dons> then 07.05, 0.2 is out :-)
07:55:49 <dons> yeah, same with xmonad
07:55:49 <Syzygy-> Shouldn't be THAT difficult to replicate the behaviour.
07:55:49 <quicksilver> ndm: tiling algorithm?
07:56:00 <shapr> sdf: You can see a simple demonstration of the Haskell syntax here - http://www.haskell.org/hawiki/HaskellDemo
07:56:02 <lambdabot> Title: HaskellDemo - The Haskell Wiki
07:56:09 <ndm> quicksilver: something so he can say "look, i can change this, and look, it changes!" - i suspect
07:56:09 <kolmodin> dons: I've heard that lambdabot can be online on several nets at the same time.. and I have a request :)
07:56:22 <kolmodin> dons: #kedja @ quakenet
07:56:35 <kolmodin> :)
07:56:53 <sdf> shapr i begin with c are you advise me to learn haskell with c??
07:57:36 <shapr> sdf: Learning Haskell is good for being a better programmer in any language. But if you have a job writing C code, then I would advise you to get good at that first.
07:57:38 <dons> kolmodin: i'll have a go...
07:57:46 <kolmodin> dons: thanks!
07:57:53 <dons> kolmodin: what's the server address?
07:58:07 <kolmodin> um.. something in .au preferable?
07:58:09 <shapr> sdf: Basically, it depends on your needs. Are you a student, a professional programmer, or a mathematician? What do you do with computers?
07:58:23 <sieni> sdf: http://norvig.com/21-days.html
07:58:23 <lambdabot> Title: Teach Yourself Programming in Ten Years
07:58:33 <dons> kolmodin: what are the quakenet servers? irc.quakenet.* ?
07:58:58 <sdf> shapr i studies mathematics and theortical physics
07:59:24 <kolmodin> dons: they are *.quakenet.org. nothing near .au it seems. you can use stockholm.se.quakenet.org
07:59:52 <dons> ok. let's try that.
07:59:57 <dons> what port?
08:00:09 <dons> the usual? 6667?
08:00:12 <sieni> isnt 6667 the standard one?
08:00:15 <kolmodin> dons: yes
08:00:51 <dons> ok. connecting...
08:01:00 <erider> hi all
08:01:09 <dons> kolmodin: is it there?
08:01:18 <kolmodin> dons: not yet
08:02:11 <shapr> sdf: In that case, I think you'll like Haskell very much!
08:03:23 <sdf> shapr i thought i will study c and c++ then c# and lisp,python
08:03:29 <dons> there you go, lennart.
08:03:31 <kolmodin> dons: excellent!
08:03:47 <sdf> shapr but when i hear about haskell i change my ideas
08:03:52 <kolmodin> dons: excellent! you've made my day! :D
08:03:56 <dons> :D
08:03:56 <shapr> sdf: I'd suggest you read http://sigfpe.blogspot.com/ and http://sigfpe.wordpress.com/
08:04:00 <lambdabot> Title: A Neighborhood of Infinity
08:04:04 <dons> the lambdabot world domination continues.
08:04:10 <dcoutts__> @arr!
08:04:10 <lambdabot> Smartly me lass
08:04:14 <dons> its on about 4 servers now, I think.
08:04:20 <shapr> sdf: In my opinion, it's worth knowing C and Python and Lisp.
08:04:22 <sieni> sdf: that sounds like a plan, although it can take several years and lots of programming to learn c++ well
08:04:25 <dons> and 30 or so freenode channels
08:04:32 <kolmodin> cool!
08:04:39 <shapr> sdf: I haven't learned C++ so I don't have any opinion there.
08:05:07 <dons> kolmodin, dcoutts__: we should have a talk /plan for the paper on say, Monday.
08:05:13 <kolmodin> great piece of software
08:05:24 <dons> i have some things to get out of the way this weekend, but then we should think hard about getting some writing done.
08:05:24 <dcoutts__> dons: yep
08:05:28 <sdf> sieni if you serious you can learn c++ in 6 years only
08:05:40 <migraine> C++ causes head explosions
08:06:08 <dons> ok. bed time. night all.
08:06:14 <dcoutts__> g'night dons
08:06:17 <stmartin> night
08:06:20 <sieni> migraine: your nick fits your comment somehow particularly well
08:06:47 <migraine> heh, thats where my migraines started
08:06:56 <kolmodin> dons: sounds like a plan
08:07:03 <kolmodin> dons: good night
08:07:26 <migraine> since my job is in C though, most of them have gone away
08:07:33 <sieni> sdf: but you can do fun stuff with C++ templates, like combinator parsing (see http://spirit.sourceforge.net/)
08:07:34 <lambdabot> Title: Boost.Spirit Home
08:08:29 <sdf> sieni are you student?
08:08:46 <sieni> sdf: not anymore
08:09:40 <sieni> sdf: got my Ph.D. 5 years ago (in mathematical physics actually). currently I'm working as a software architect.
08:10:21 <kolmodin> ari: you didn't like it? :)
08:10:41 <sdf> sieni mathematical physics   so i need you much
08:11:14 <bwerf> how does that qualify you as a software architect ?
08:11:59 <ari> kolmodin: I'm not a fan of the Swedish language :(
08:12:00 <shapr> I think both software and math are formalizations of our understanding of the world. It makes sense to me.
08:12:19 <joelr1> good day
08:12:20 <shapr> hiya joelr1
08:12:27 <kolmodin> ari: yeah. it's a channel for some chalmers guys and friends
08:12:32 * joelr1 high-fives shapr
08:12:33 <sieni> bwerf: well, I worked as a software engineer first, but since I wasn't the dimmest candle in the pack, I got promoted
08:12:37 <joelr1> bringert: ping
08:12:46 <bringert> hi joelr1
08:13:05 <bwerf> sieni: ah that works
08:13:13 <joelr1> bringert: i'm throwing in the towel on the haskell version of my translator
08:13:37 <DRMacIver> Besides, software engineering is easy once you've done maths. ;)
08:13:41 <sdf> shapr  where do you live?
08:13:56 <ari> kolmodin: I only wanted to see if you had anything particularly interesting to show to that channel with lambdabot...
08:14:09 <shapr> sdf: I live in Alabama, USA. I have also lived in Sweden and Finland.
08:14:19 <sieni> bwerf: and I think mathematical background helps in programming: you are accustomed to proving things, so you end up being very thorough about Making Things Work.
08:14:27 <kolmodin> ari: np. it's all good :)
08:15:03 <joelr1> bringert: i apologize for wasting your time :-(
08:15:12 <bringert> joelr1: np
08:15:15 <sdf> shapr i gues you are old enought to not be student?
08:15:19 <sdf> guess
08:15:36 <shapr> sdf: I'm 35 years old. I'll always be learning though!
08:15:54 <bringert> joelr1: so are you going to write new web front-end in OCaml?
08:16:05 <joelr1> bringert: still, you can count me in as hope's biggest promoter!
08:16:05 <sdf> shapr very great
08:16:11 <sieni> shapr: are you going back to sweden?
08:16:17 <shapr> sieni: If they let me, yes.
08:16:34 <joelr1> bringert: yes, using http://sandbox.merjis.com/
08:16:35 <lambdabot> Title: COCANWIKI - the OCaml wiki
08:16:37 <sieni> shapr: oh, you had visa/work permit problems
08:16:41 <kolmodin> shapr: great! let us know how/if/when
08:17:18 <joelr1> bringert: it turns out that i'll be spending far more time on the compiler itself than on the web front-end, even before i get to charging customers
08:17:26 <shapr> kolmodin: I will! If I get back to Sweden I'll drop by Chalmers and hang out some.
08:17:35 <joelr1> bringert: and this is the part that sucks the most for me in the haskell version
08:17:50 <kolmodin> shapr: neat!
08:18:01 <bwerf> sieni: just making things work causes alot of problems, but i'm assumign you mean making it work correctly ?
08:18:08 <sdf> shapr whar are the programming languages that you know?
08:18:34 <bringert> joelr1: "this" is the compiler or the web front-end?
08:18:36 <sieni> bwerf: yes
08:19:21 <shapr> sdf: I've been paid to use Visual Basic, Java, Python, Haskell, SQL, and Perl. I've spent fun time playing with Joy, PostScript, Smalltalk, C, elisp, and probably others that I can't think of right now.
08:19:58 <joelr1> bringert: this is the compiler. mostly my troubles have to do with parsec being harder to tweak than yacc-style grammar, the whole thing taking too long to to compile to be usable for quick tweaking and lots of extra code having to do with monads and type classes
08:20:05 <shapr> sdf: Which programming languages do you know?
08:20:15 <sdf> shapr hehe
08:20:29 <sieni> bwerf: doing thread programming with fine-grained locking is a bit of a PITA, but math background helps you with spotting all the possible ways things can go wrong
08:20:39 <kolmodin> shapr: I'm sure we can have some kind of minihackathon. waern and bringert are probably interested too
08:20:41 <bringert> joelr1: I guess you could still have a Haskell front-end, even if the compiler is O'Caml, but that would add some complexity
08:20:42 <sdf> shapr c and part of c++
08:20:48 <shapr> kolmodin: Yeah, EuroHaskell 2008!
08:20:54 <kolmodin> yeah!
08:21:05 <bringert> joelr1: well, just calling runInteractiveProcess really
08:21:07 <shapr> sdf: That's good! How do you like programming so far?
08:21:09 <joelr1> bringert: i could have switched to happy, for example, or your bnfc package but i already have the ocaml compiler working (in fact it was the first i developed) and i find that i have a much easier and faster time with ocaml
08:21:24 <kolmodin> I think I have yet to meet some of the new haskell guys at chalmers too
08:21:33 <joelr1> bringert: yes, i think that would be a fair bit of extra complexity
08:21:34 <bringert> joelr1: yeah, if it works, don't fix it
08:21:41 <joelr1> bringert: still, there's hope
08:21:45 <bringert> :-)
08:21:46 <sdf> shapr   programming is my life
08:21:57 <sdf> but i don t have any time
08:22:04 <joelr1> bringert: i flip-flop all the time and this is probably until i get stuck with ocaml again
08:22:06 <stmartin> Is there a standard method of transposing a two-dimensional list, considering the list elements will be of non-uniform length?
08:22:16 <joelr1> bringert: i can never say never
08:22:26 <sjanssen> stmartin: transpose
08:22:28 <sdf> shapr when did you begin programming?
08:22:33 <quicksilver> stmartin: yes, and in haskell it's called transpose
08:22:38 <sjanssen> > transpose [[1, 2, 3], [4, 5]]
08:22:45 <stmartin> funny, not in scope...
08:22:45 <lambdabot>  [[1,4],[2,5],[3]]
08:22:49 <sdf> shapr which language you begin?
08:22:51 <shapr> sdf: When I was eleven years old, I started with BASIC on a Sinclair Spectrum.
08:22:51 <ari> stmartin: Data.List
08:22:54 <sjanssen> stmartin: import Data.List
08:22:55 <quicksilver> stmartin: it ends up 'pushing things up-left', I think
08:22:58 <stmartin> thanks.
08:23:04 <bringert> joelr1: I'm sure you could find lots of people in here who would be happy to help you with the Haskell version if you ever want to pick it up again
08:23:12 <quicksilver> > transpose [[1,2],[3],[4,5]]
08:23:13 <lambdabot>  [[1,3,4],[2,5]]
08:23:27 <sdf> shapr i begin programing this year
08:23:28 <shapr> sdf: Twenty four years of programming, yay! When did you start programming? And with which language?
08:23:33 <sdf> shapr hehe
08:23:35 <quicksilver> (in the sense that the 5, which was in the 3rd row, is now in the second column)
08:23:42 <joelr1> bringert: i'll surely know who to talk to ;-)
08:23:50 <shapr> sdf: That's great, there's so much fun in programming!
08:23:58 * araujo boings around
08:24:07 * shapr boings around araujo
08:24:12 <araujo> haha
08:24:15 <sdf> shapr i begin with c
08:24:16 <quicksilver> shapr: by my reckoing, I also have 24 years of programming
08:24:16 <araujo> hola shapr !
08:24:25 <centrinia> (transpose $ transpose a) might not equal (a) :(
08:24:28 <quicksilver> shapr: I think 1983-4 must have been a good year for this!
08:24:32 <shapr> hola araujo! Â¿como est as?
08:24:35 <sieni> @src transpose
08:24:35 <lambdabot> transpose []             = []
08:24:35 <lambdabot> transpose ([]   : xss)   = transpose xss
08:24:35 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
08:24:40 <bwerf> sieni: experience is telling me to stay away from threading, requirements change and it is often too problematic to show that a program keeps working after the changes
08:24:42 <DRMacIver> centrinia: Huh, why not?
08:25:01 <sieni> bwerf: as if I had much choice
08:25:04 <quicksilver> > transpose $ transpose [[1,2],[3],[4,5]]
08:25:05 <lambdabot>  [[1,2],[3,5],[4]]
08:25:06 <kolmodin> araujo!!!!
08:25:08 <quicksilver> DRMacIver: like taht :)
08:25:14 <joelr1> bringert: gotta run, thanks again! hope is an awesome product!
08:25:16 <sieni> bwerf: but it has been an enlightening experience anyway :-)
08:25:18 <DRMacIver> Ah
08:25:22 <sdf> shapr can i complete c in two years?
08:25:41 <bwerf> sieni: libraries that enforce priority locking orders can also help with most deadlock related issues atleast
08:25:57 <kolmodin> sdf: learn the language?
08:25:57 <DRMacIver> You can complete C itself over a weekend. The rest is just detail. ;)
08:26:02 <sieni> bwerf: also proper design helps
08:26:09 <shapr> sdf: I don't know, programming is like math. There's much to know, and you learn as fast as you push yourself.
08:26:13 <migraine> sdf: you never really complete learning a language in my opinion
08:26:33 <centrinia> "You never really finish learning anything"
08:26:47 <bwerf> sieni: yes, but in the relality of my job requirements rarely remain stable enough for a design that needs to stay the same
08:26:51 <DRMacIver> migraine: I think you get to a point with a language where most of what you're learning about it can be abstracted away from the language proper.
08:26:54 <kolmodin> sdf: the language is easy enough, it's how you have to structure your code that takes time and experience
08:27:11 <bwerf> sieni: cowboy coding, heh :)
08:27:16 <araujo> kolmodin!!!!!!
08:27:28 <sdf> kolmodin experience
08:27:31 <araujo> shapr, buen , gracias y tu? :-)
08:27:36 <sdf> that is right
08:27:38 <araujo> shapr, bien , gracias y tu? :-)
08:27:39 <kolmodin> sdf: ah, well. then you never finish :)
08:27:40 <araujo> better
08:28:01 <sdf> kolmodin hehe
08:28:08 <shapr> araujo: bueno!
08:28:26 <kolmodin> sdf: although I don't really know how long it takes to learn it sufficently if you're motivated
08:28:44 <kolmodin> sdf: I try to avoid C whenever I can, so I'm not really that skilled either :)
08:29:17 <migraine> well you can always 'Teach yourself C in 24 hours'
08:29:29 <bwerf> eh
08:29:52 <araujo> :-)
08:30:20 <sdf> migraine  the code only
08:30:25 <migraine> yes syntax only
08:30:33 <kral> 'Teach yourself a *bad* C in 24 hours'
08:30:34 <centrinia> Where's my "Category Theory for Dummies" book?
08:31:04 <shapr> centrinia: The Schanuel book?
08:31:20 <centrinia> Thanks. :)
08:31:53 <shapr> Lawvere and Schanuel, specifically.
08:34:18 <sdf> shapr free ebook for learning haskell?
08:34:46 <shapr> You might want to start with the wikibook.
08:35:34 <shapr> Or check out "Yet Another Haskell Tutorial"
08:37:46 <migraine> I have a functional language disability called imperativeness
08:38:29 <phoniq> Type 1 Imperativitis
08:38:34 <phoniq> it's common.  know the facts.
08:38:47 <migraine> type 2 I think.. not the worst kind
08:39:11 <ToRA> ..at least it has a type...
08:39:40 <shapr> hah
08:45:20 <Baughn_> Is there a "teach Haskell to non-programmers" type book out there?
08:46:11 <stmartin> I think the 'Craft of Functional Programming' is fairly approachable.
08:48:04 <Apocalisp> <stmartin> I think the 'Craft of Functional Programming' is fairly approachable.
08:49:08 <Baughn> I'll look at it. I was thinking more for a mentor-student type situation, though.
08:49:10 <Apocalisp> The Haskell School of Expression is quite good. No programming experience is presumed, but algebra and trig are.
08:49:30 <Baughn> Got that one. It is, but I'll need to rewrite its graphics library. :)
08:49:46 <Apocalisp> hah. What do you mean?
08:50:05 <quicksilver> Baughn: why would you have to rewrite the graphics library?
08:50:16 <Baughn> quicksilver: Because the bundled one only works with windows?
08:50:42 <quicksilver> Baughn: I thought there was a .SOE package in the haskell libraries designed to provide compatibility?
08:50:44 <chessguy> the downside to haskell: writing code in perl makes you feel SO dirty
08:51:08 <Baughn> quicksilver: I see the situation has changed. Okay, so I won't need to rewrite it.. good thing.
08:51:08 <chessguy> Baughn: i got code from SOE working
08:51:10 * Apocalisp wipes the perl filth off chessguy
08:51:13 * araujo is writing Haskell using Python
08:51:26 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-SOE.html
08:51:28 <lambdabot> http://tinyurl.com/ymovqo
08:51:31 <quicksilver> Baughn: ^^ that one
08:51:37 <centrinia> Pugs.
08:51:38 <Baughn> Yay! ^_^
08:51:54 <chessguy> Baughn: there are still some small issues with some of the code
08:52:36 <Apocalisp> My only beef with SOE is that it seems to present exercises that would be difficult to solve with only what the book as introduced.
08:52:37 <chessguy> the code you download from the SOE site may need some lovin' before it'll run in modern GHC
08:53:22 <Baughn> I've got time for that, but I might be teaching a haskell class this fall. I'll.. also need to learn haskell first.
08:53:35 <Apocalisp> Good idea.
08:53:42 <osfameron> hehehe
08:53:48 <osfameron> Apocalisp: yes indeed!
08:53:50 <quicksilver> Apocalisp: it's surprisingly hard to write a book and never make that mistake :)
08:54:02 <osfameron> Apocalisp: not too many, I've found.  Only about one exercise per chapter makes me cry like a baby
08:54:06 <chessguy> Baughn: sounds like a good summer project
08:54:21 <chessguy> Baughn: what's the class?
08:54:28 <Apocalisp> I found it impossible to solve the regularPolygon exercise without something like iterate.
08:54:50 <osfameron> it's a dependency solving problem - he has no excuse, he should have written a haskell script to check the order of the exercises for him
08:54:52 <Baughn> chessguy: Advanced functional programming. There might or might not be any students, though; we'll see.
08:55:07 <osfameron> Apocalisp: I'm blogging my pain on osfameron.vox.com (but rather slowly, I have 2 chapters worth to update...)
08:55:30 <chessguy> wow. i wish my school had had cool classes like that
08:55:50 <Apocalisp> chessguy: I too!
08:55:51 <chessguy> i got 4 weeks of FP (in scheme) in a "principles of programming languages" class
08:56:23 <Baughn> chessguy: That's the same as mine. If I get the class, it'll be the /first/ one.
08:57:58 <chessguy> i think more and more companies are catching on to FP though. the web development company where i'm about to start is excited about my FP knowledge. they say it makes for a good javascript programmer
08:58:18 <shapr> Yeah, Javascript is a lot easier if you understand FP.
08:59:04 <centrinia> It feels like learning Latin in complement with English. You know where all grammar rules come from.
08:59:12 <quicksilver> as long as you also understand the closure variable sharing weirdness
08:59:27 <quicksilver> which will bite functional programmers for a while until they do :)
08:59:51 <flux> quicksilver, if you don't use mutable values, it should be alright?-)
09:00:09 <quicksilver> flux: not really, not
09:00:21 <quicksilver> flux: it's like using (\x -> ...) on 8 different values of x
09:00:32 <quicksilver> flux: and then finding they all get 'aliased' to the last value
09:00:36 <quicksilver> flux: because 'it's the same x'
09:03:16 * malcolmw wants a book "Lax monoidal functors and coalgebraic specification for dummies"
09:03:29 <Apocalisp> osfameron: The solution to 2.2 is quite simple. Rotate the first vertex n times and collect the intermediate results.
09:03:56 <phoniq> ahahah
09:07:25 <chessguy> ?remember malcolmw i want a book "Lax monoidal functors and coalgebraic specification for dummies"
09:07:25 <lambdabot> Done.
09:07:43 <osfameron> Apocalisp: ah, well I have an update to that exercise.  I relearnt what sin and cos do and wrote it.  It was relatively simple
09:08:11 <osfameron> I'll update at weekend I think
09:08:32 <Apocalisp> osfameron: Were you able to do it with just the tools from the book up to that point?
09:08:53 <osfameron> Apocalisp: er, well no, I had to relearn trigonometry...
09:09:03 <osfameron> but for the haskell part of it, can't remember
09:09:04 <Apocalisp> hah
09:09:21 <Apocalisp> I tried solving it using no trigonometric functions. Very hard.
09:09:25 <osfameron> I've skipped back and forth a lot.  I'm like a ninja master on some stuff, and a blithering idiot on other really simple stuff
09:09:34 <osfameron> ah, I tried that for something yeah
09:09:46 <osfameron> just using pythagoras, cos it was the only thing I could remember
09:10:06 <Apocalisp> it's possible, but you get into solving polynomials etc.
09:10:17 <osfameron> it's funny how 4 years of English lit, and 8 years in IT support->projects->testing->web dev doesn't do anything for your maths...
09:10:37 <Apocalisp> I hear that.
09:10:43 <Apocalisp> My math is quite flabby as well.
09:11:20 <hpaste>  osfameron pasted "answer to SOE 2.2" at http://hpaste.org/1884
09:11:44 <osfameron> Apocalisp: that's what I came up with - it's not quite to specification: I wrote another function to convert it from the side instead of radius
09:11:58 <chessguy> osfameron: but at least you can come back to math without it having changed (www.xkcd.com)
09:12:15 <osfameron> I think the only thing that hasn't been taught up to that point is $, but I could be wrong
09:12:27 <chessguy> sorry, i had to get a reference to xkcd in there :)
09:12:37 <osfameron> harrr!
09:14:42 <Apocalisp> osfameron: He hadn't taught where at that point. Nor multiple lets.
09:15:10 <osfameron> Apocalisp: funnily enough I found them quite intuitive, despite no programming langauge I know having lexical subs
09:15:16 <osfameron> ok, I could have made them wheres
09:15:27 <osfameron> I had to rewrite because some stuff could be a where and some couldn't
09:15:27 <Apocalisp> I suppose he gets a free pass by stating in the preface that you're free to skip back and forth etc.
09:15:46 <osfameron> hmmm.  I mean, I could have written that differently with the tools provided
09:16:04 <osfameron> whereas the "what's the principal type of 'map map'" made me want to fetch Mr Stabby
09:16:09 <osfameron> and some others
09:18:45 <chessguy> @type map map
09:18:46 <chessguy> :)
09:18:50 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
09:19:18 <quicksilver> a good exercise is comparing the types of map map and map.map
09:19:25 <quicksilver> that makes you think about polymorphism
09:21:54 <osfameron> quicksilver: yes.  but up until this part in the book, I don't think you really understand it
09:22:15 <osfameron> and also, I'm a perl programmer, I've used "map" at least for years, I don't think I have a problem with polymorphism
09:22:26 <hpaste>  apocalisp pasted "regularPolygon" at http://hpaste.org/1885
09:22:45 <Apocalisp> ooh, that's kinda cool.
09:22:48 <Apocalisp> announce
09:22:49 <osfameron> it's the complexity of curried higher order functions and the lack of enough BRANE to reasona bout thatm that's screwing me up
09:23:12 <osfameron> gosh, that's much shorter than mine :-)
09:23:31 <quicksilver> osfameron: composing maps is a real bugger in perl, though
09:23:37 <quicksilver> osfameron: what with $_ being magic and all
09:23:59 <osfameron> quicksilver: sure... maybe that's why I find composing them in haskell confusing :-)
09:24:15 <osfameron> I do do inline maps, but assigning my $outer = $_; first
09:24:37 <osfameron> Apocalisp: ah, you're using take and iterate.  nice - definitely not covered by that point
09:25:02 <quicksilver> osfameron: yes. me too, sometimes. but you have to admit that's fugly.
09:25:30 <Apocalisp> osfameron: I didn't know take and iterate until I found them in the prelude to solve this very exercise.
09:25:32 * osfameron blubs at quicksilver 
09:25:50 <osfameron> Apocalisp: ah, I haven't found the source to the prelude yet.  I should probably read that
09:26:30 <Apocalisp> osfameron: I wrote out my specification in english first, and was pleasantly surprised that it translated quite handsomely to haskell. ;-)
09:28:18 <kc5tja> And, once again, Firefox commits sepaku on me, right in the middle of reading a webpage.  *sighs*
09:28:42 * kc5tja notes that FF 2.0 is notoriously unstable.  :(
09:28:49 <Apocalisp> @wiki prelude
09:28:50 <lambdabot> http://www.haskell.org/haskellwiki/prelude
09:28:53 <osfameron> well, if you will expect Firefox to do something as weird as reading a *web* page!
09:28:56 <quicksilver> kc5tja: I heard rumours and stuck to FF 1.5
09:29:08 <osfameron> (There is currently no text in this page)
09:29:09 <Apocalisp> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
09:29:10 <quicksilver> kc5tja: I haven't had cause to regret that, yet
09:29:10 <lambdabot> Title: A Tour of the Haskell Prelude, http://tinyurl.com/ywhnjx
09:29:14 <kc5tja> quicksilver: I tend to use 2.0 because it's needed for work.
09:29:22 <kc5tja> I use 1.5 at home.
09:29:27 <osfameron> oh, actually, there's a tour in SOE isn't there?
09:29:33 <helmut> Could someone tell me why I have to delete *.hi before invoking ghci in order to use functions from imported modules?
09:29:37 <Apocalisp> there is?
09:29:54 <osfameron> at the end - might not be all of it, not got book here at work
09:30:40 <kc5tja> WHOA, HOLY CRAP!  All this time, it was taking its time _garbage collecting_.  Egads!  :(
09:31:11 * kc5tja wonders if they've ever heard of "generational, incremental collectors."
09:32:12 <quicksilver> helmut: I've not observed that problem
09:32:20 <quicksilver> helmut: could it be you're breaking the directory naming structure?
09:32:24 <kc5tja> Great, I now have to reboot the workstation.
09:32:35 * kc5tja cries -- Firefox killed a dual P4HT with 3GB of RAM!  WTF?!
09:32:40 <kc5tja> brb
09:33:45 <Apocalisp> kc5tja: It's an HTML parser, what do you want?
09:33:47 <helmut> quicksilver: how would I do that? To be concrete: Parser.hs imports Lexer when I run ghci Parser.hs without any *.hi files it works. once I compile Lexer.hs using ghc ghci doesn't find functions from Lexer.hs anymore.
09:33:54 <Apocalisp> :-)
09:34:07 <helmut> quicksilver: I can then type :l Lexer in ghci, which makes functions from Parser disappear.
09:34:25 <quicksilver> helmut: what does the module directive in Lexer.hs say?
09:34:48 <helmut> quicksilver: module Lexer where
09:35:07 <helmut> quicksilver: (generated by alex)
09:35:34 * helmut tries again.
09:35:39 <quicksilver> helmut: and the top of Parser.hs?
09:35:44 <quicksilver> and all files are in the same dir?
09:36:01 <helmut> quicksilver: all files in the same dir an module Parser where
09:36:09 <helmut> quicksilver: (generated by frown)
09:36:22 <byorgey> helmut: you'd probably want to type :m + Lexer instead of :l Lexer
09:36:33 <quicksilver> well just :l Parser.hs should work
09:36:37 <quicksilver> it should autoload Lexer.hs
09:36:39 <byorgey> but that doesn't solve the real problem
09:36:42 <quicksilver> when it sees the 'import Lexer'
09:36:45 <byorgey> right
09:36:49 <helmut> byorgey: that'll help, too. :-)
09:36:53 <sioraiocht> chessguy: you made my head hurt with (map map)
09:37:32 <chessguy> sioraiocht: blame osfameron , he brought it up
09:37:54 <helmut> (I just reproduced the behaviour using 6.6.1 (which just reached unstable).)
09:38:12 <sioraiocht> but then I came up with foldr1 (.) $ map map $ (+) [1..] to really hurt myself
09:38:30 <chessguy> @type foldr1 (.) $ map map $ (+) [1..
09:38:32 <lambdabot> parse error (possibly incorrect indentation)
09:38:34 <chessguy> @type foldr1 (.) $ map map $ (+) [1..]
09:38:36 <lambdabot>     Couldn't match expected type `[a -> b]'
09:38:36 <lambdabot>            against inferred type `[t] -> [t]'
09:38:50 <sioraiocht> oops
09:39:03 <sioraiocht> @type foldr1 (.) $ map map $ map (+) [1..]
09:39:05 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
09:39:48 <chessguy> > (foldr1 (.) $ map map $ map (+) [1..]) [1..]
09:39:52 <lambdabot>  Exception: stack overflow
09:39:57 * chessguy giggles
09:40:15 <Apocalisp> @type map.map
09:40:17 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:40:20 <sioraiocht> yeah, I was amused at generating an infinitely defined function
09:40:45 <helmut> quicksilver: Is it correct that the behaviour I observe is not technically correct?
09:40:53 <sioraiocht> > foldr1 (.) $ map map $ map (+) [1..10] $ [1..]
09:40:54 <lambdabot>  Couldn't match expected type `a -> b'
09:41:21 <sioraiocht> > (foldr1 (.) $ map map $ map (+) [1..10]) [1..]
09:41:22 <lambdabot>  [56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,...
09:41:24 <quicksilver> helmut: it soudns wrong to me
09:41:33 <quicksilver> helmut: unless I incompletely understood you :)
09:42:23 <helmut> quicksilver: Well I can then simply use reportbug and make a maintainer explain it to me. :-)
09:43:06 <kc5tja> Apocalisp: HTML parsers don't kill computers dead.  I know this because I've never had any web browser, IE included, nix a machine like this.
09:43:18 <kc5tja> Apocalisp: Until, that is, now.
09:43:44 <Apocalisp> Shoddy programming.
09:43:55 <kc5tja> Bingo.  That's the problem.
09:44:01 <kc5tja> Instead of fixing bugs, they're making more.
09:44:14 * kc5tja remembers, quite "fondly," the last time I attempted to contribute a bug fix to Mozilla.
09:44:19 <osfameron> chessguy, sioraiocht: hey, blame Hudak!  he's the one who set it as a (ridiculously advanced) exercise
09:44:29 <sioraiocht> lol
09:44:32 * osfameron wishes he had time to read the scrollback, looks interesting
09:44:34 * osfameron heads to the pub
09:44:50 <osfameron> beer being less twisty and confusing than haskell
09:45:07 <Apocalisp> haskell . beer :: great combo
09:45:13 <byorgey> map drink [beer..]
09:45:37 <quicksilver> kc5tja: software sucks
09:45:48 <vegai> I'm more of a red wine guy, should I be using O'Caml?
09:45:54 <sioraiocht> vegai: eww
09:46:01 <matthew-_> osfameron: after a few beers, Haskell gets simpler too!
09:46:09 <vegai> sioraiocht: eww @ red wine or O'Caml?
09:46:14 <sioraiocht> OCaml
09:46:20 * sioraiocht enjoys red wine as well.
09:46:29 <sioraiocht> though I prefer a good stout or cider most of the time
09:47:19 <vegai> then again, I like scotch, so ghc should work just fine!
09:47:20 <matthew-_> sioraiocht: mmm, you sound british ;-)
09:47:49 <Saizan> there's a quote about alcohol + static type checking
09:47:54 <sioraiocht> matthew-_: I'm actually American, lol
09:48:12 <sioraiocht> matthew-_: I'm moving to England in September, though
09:49:58 <matthew-_> sioraiocht: ahh. Well, as far as I know, we do make the best ciders
09:52:55 <nominolo> @seen dcoutts
09:52:55 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts last spoke.
09:53:00 <nominolo> @seen dcoutts__
09:53:01 <lambdabot> dcoutts__ is in #ghc, #haskell-overflow, #haskell and #gentoo-haskell. I last heard dcoutts__ speak 50m 24s ago.
09:54:13 <sioraiocht> matthew-_: is "we" the english? ;)  I dunno, I've had some pretty good American ones, too.
09:55:29 <matthew-_> sioraiocht: yeah. the "we" was mainly Somerset. Ok, I'm not really a Cider fan, so I'll bow to your judgement.
09:56:08 <kc5tja> sioraiocht: What's wrong with O'caml?  Besides the rediculous name, that is?
09:57:08 <savanni> I rather liked it until I started working with the objects, and then I got annoyed at how different object/method syntax was from regular functions.
09:57:19 <savanni> But O'caml *did* make transitioning to Haskell easier.
09:58:31 <kc5tja> The 'only thing 'I don't 'like about 'ML-'family 'languages is the 'crazy need for 'ticks for 'polymorphic types.  ':)
09:59:23 <savanni> heh
10:02:01 <cdsmith> Is there an option to ghc to see what something looks like in the core language?  I don't see one...
10:03:36 <cdsmith> Oops, never mind.  I missed it the first time.
10:05:08 <chessguy> isn't it like -ddump or something?
10:05:20 <cdsmith> -fext-core is what I found
10:05:31 <chessguy> oh. well ignore me then
10:05:57 <cdsmith> There are some dump options that look promising too...
10:13:33 <ndm> cdsmith: -ddump-simpl - much better than -fext-core
10:14:02 <cdsmith> Okay, thanks
10:14:40 <cdsmith> ndm: What's the difference?  They don't look anything alike.
10:15:02 <ndm> cdsmith: they basically convey the same information, just different syntax, and less type information
10:15:41 <cdsmith> Okay, well thank you.  Back to my long quest to understand ghc.
10:16:14 <helmut> Is there something I can use for modeling "memory cells"? using [a] is O(n) for "replacing" the nth element (i.e. Int -> a -> [a] -> [a]).
10:16:43 <quicksilver> kc5tja: I dislike the fact that constructors aren't firstclass functions
10:17:06 <quicksilver> kc5tja: and the clumsiness about defining combinators (the value restriction)
10:17:12 <quicksilver> helmut: arrays
10:18:20 <cdsmith> quicksilver: arrays still have O(n) updates, don't they?
10:18:46 <ndm> depends on which arrays
10:19:24 <quicksilver> cdsmith: depends on which arrays and how you use them :)
10:19:36 <helmut> quicksilver: uhm. arrays have a fixed width, right?
10:24:41 <quicksilver> helmut: well, when you allocate an array you have to specify how wide you want it
10:24:59 <quicksilver> helmut: the width isn't part of the type though...(not quite sure what you're after)
10:26:10 <quicksilver> helmut: if O(log n) update is goot enough, then perhaps Data.Map is for you
10:27:28 <helmut> quicksilver: I am about to implement the concept of memory (like used in java/python etc.). I need to created memory cells, retrieve values and update cells.
10:28:05 <quicksilver> Data.Map is a good model for this
10:28:22 <quicksilver> IntMap is optimised for certain operations
10:28:26 <helmut> so I should then be mapping Int to Value?
10:28:26 <quicksilver> it's just a question of how fast you need it to be
10:28:44 <helmut> I don't really need it fast, it only shouldn't be O(n)
10:29:32 <hstenstrom> I'm reading "The Haskell School of Expression" by Paul Hudak, and want to use the SOEGraphics module that is used in the book. I have a file called /usr/lib/hugs/oldlib/SOEGraphics.hs. How can it be imported?
10:29:51 * quicksilver nods
10:30:59 <helmut> quicksilver: Maybe I should just stick with a List and optimize later.
10:32:46 <cdsmith> helmut: using IntMap might actually be easier to read, though, depending on how you use it.
10:33:05 <SyntaxNinja> nominolo: check your msgs :)
10:33:07 <dmhouse> Anyone know of an online copy of "Dynamic tabbing for automatic indentation with the layout rule"? It's a paper covering the design principles behind haskell-indent.el, part of haskell-mode for Emacs.
10:33:30 <helmut> cdsmith: good point
10:33:45 <cdsmith> hstenstrom: using Hugs?
10:36:12 <hpaste>  stmartin pasted "pretty_printing a 2D list of strings" at http://hpaste.org/1887
10:36:53 <stmartin> My brains getty fried and needs sleep. Can anyone see what's the preblem with the code I just pasted?
10:37:25 <dmhouse> stmartin: yeah, you need to put brackets around n::Int
10:37:42 <hstenstrom> Yes, I'm using Hugs.
10:37:43 <stmartin> Ah, I see.
10:37:56 <dmhouse> Otherwise it thinks the result type of the entire printf call is Int. This would normally be an error, but printf uses funky typeclasses, so the compiler doesn't know this.
10:38:22 <stmartin> Hehe. That's one thing I sort of like about Lisp, never need to worry about precedence ;^)
10:39:23 <quicksilver> helmut: IntMap has constanttime insert and delete for maps larger than 64 elements, which is pretty clever
10:43:47 <stmartin> What's a good way of adding empty elements to a list (of lists) to ensure there is at least n elements in the list?
10:44:05 <dmhouse> stmartin: although Lisp has its downsides, too, I've just spent an appreciable amount of time wondering why my (mapc 'foo (fetch-list)) wasn't appearing to do anything, before I realised that it was actually (mapc 'foo) (fetch-list), with nothing but a single space of indentation to inform me of this fact. :)
10:44:34 <DRMacIver> stmartin: Well you could always bracket everything in Haskell. Then you wouldn't need to worry about it here either. :)
10:44:56 <dmhouse> > let addEmpty n xs = take n (xs ++ repeat []) in addEmpty 5 ["hello", "world"]
10:44:57 <lambdabot>  ["hello","world","","",""]
10:45:08 <dmhouse> stmartin: how's that look?
10:45:42 <stmartin> Ahh, yes that should do. I was attempting a similar thing with zipWith (++)...
10:45:45 <helmut> quicksilver: I'll only have lookup, update and append.
10:45:59 <helmut> quicksilver: (cells are never deleted)
10:46:01 <DRMacIver> dmhouse: Neat trick.
10:46:52 <dmhouse> DRMacIver: sweet, isn't it? I was thinking of using replicate and length before I realised you could use laziness to avoid multiple traversals of the list and make it neater :)
10:50:28 <koala_man> am I to understand that each IO() has exactly one IORef that you can muck about with?
10:50:40 <SamB> koala_man: what?
10:50:57 <koala_man> good question
10:51:32 <Cf> you mean a function that returns IO ()? you can play with as many as you want
10:51:36 <dmhouse> koala_man: "each IO()" doesn't make sense.
10:52:04 <koala_man> is there only one, err, instance of the IO monad then?
10:52:24 <dmhouse> koala_man: still doesn't make sense.
10:52:29 <koala_man> as you can tell, I don't know haskell yet
10:52:34 <dmhouse> koala_man: got an example or something to explain what's going on?
10:52:57 <dmhouse> koala_man: it's okay, Haskell and types can be pretty weird to try to get your head around.
10:53:48 <koala_man> I want to store some information in an IO monad for use with gtk2hs, but I can't figure out the api docs
10:54:42 <dmhouse> koala_man: which API docs? The Haskell ones or the Gtk2Hs ones?
10:54:53 <koala_man> the haskell ones
10:54:57 <SamB> koala_man: an IORef is like a variable, okay?
10:55:10 <koala_man> ok
10:55:35 <SamB> but you have to pass them around
10:55:45 <cdsmith> koala_man: the IO monad is a just type-level concept; it's not a value, so you can't have more than one of them.  You can have more than one IORef.
10:56:02 <koala_man> so you pass around the IORef, and use it as some kind of key/name to get the data from the IO monad?
10:56:30 <SamB> koala_man: well actually you use the IO monad to get the data from the IORef, in practice, but conceptually your description works too
10:56:54 <koala_man> ah, excellent, it's much clearer now. thanks for the hand holding ^^
11:10:11 <procyon112> @seen chessguy
11:10:11 <lambdabot> chessguy is in #haskell, #xmonad, #darcs, #haskell-soc and #haskell-overflow. I last heard chessguy speak 52m 48s ago.
11:10:19 <chessguy> 'ello
11:11:03 <procyon112> yo.  Get a chance to look at those changes I made?  I thought the copious documentation on the typing would do you good for understanding it.
11:11:21 <procyon112> (It did me good writing it) :)
11:11:59 <chessguy> ermmm
11:12:02 <chessguy> not really
11:12:09 <chessguy> sorry, things are a little crazy for me right now
11:12:15 <Baughn> @seen Baughn_
11:12:16 <lambdabot> I saw Baughn_ leaving #haskell 2h 26m 7s ago, and .
11:12:20 <procyon112> me too.. which is why things aren't done :)
11:12:42 <chessguy> i figured i'd wait to look at it much until you had the regression problem working
11:13:21 <procyon112> I have been commissioned to migrate a bunch of stuff into Win XP Service Pack 3.... *after* SP3 went code complete, so my commitment dates are insane.
11:14:48 <chessguy> yeesh
11:14:54 <procyon112> "So... how would you feel moving 50 MB of C++ code into a new tree... with a different build system and compiler... And a week to do it?"
11:15:04 <chessguy> ouch
11:15:37 <procyon112> Yeah, so the GPLib stuff has been a victim of some slack :)
11:16:21 <Apocalisp> 50 MB of code?
11:16:46 <procyon112> Yeah.. we're only moving over essentials..
11:16:59 <chessguy> that's windows for you...
11:17:11 <chessguy> ever heard the term 'monolithic kernel'?
11:18:42 <Apocalisp> a monowhosawhatnow?
11:18:51 <LeCamarade> chessguy: Is Win32 monolithic?
11:19:00 <Apocalisp> LeCamarade: Bwahaha.
11:19:19 <Apocalisp> @quote LeCamarade Is Win32 monolithic?
11:19:19 <lambdabot> No quotes match. Wrong!  You cheating scum!
11:19:26 <Apocalisp> @remember LeCamarade Is Win32 monolithic?
11:19:26 <lambdabot> Done.
11:19:36 <LeCamarade> Apocalisp: :o(
11:19:39 <Apocalisp> hehe
11:19:50 <LeCamarade> @quote win32
11:19:50 <lambdabot> LeCamarade says: Is Win32 monolithic?
11:19:54 <LeCamarade> :o(
11:19:55 <procyon112> WinNT is micro kernal.  Linux in monolithic... not that you can tell by looking at them in the wild :)
11:19:56 <Apocalisp> no, it's funny!
11:20:15 <ventonegro> winnt is as microkernel as mac os x
11:20:34 <procyon112> But I'm not working on kernel stuff... I'm working on services and apps at the moment.
11:20:40 <LeCamarade> Well, I am of the view that that is a downside of Linux. But I'm no OS pro.
11:20:42 <ventonegro> the ms attempt to a microkernel is called singularity
11:20:54 <procyon112> lol
11:21:10 <ventonegro> procyon112: yes, there are services, but they run in kernel space :-)
11:21:26 <procyon112> It wasn't supposed to be a singularity, but the code collapsed under it's own gravitational pull.
11:21:29 <Apocalisp> I've heard NT called many things. Never "microkernel".
11:21:46 <kc5tja> WinNT 3.5 was microkernel.
11:21:54 <kc5tja> WinNT 4.x and later was monolithic with kernel modules.
11:22:05 <Apocalisp> Interesting.
11:22:18 <kc5tja> That's why NT 4.x crashed more often due to video driver bugs.  :)
11:22:22 <Apocalisp> NT 3.5 was the first windows I kind of liked.
11:22:23 <chessguy> procyon112: i wasn't saying you were working on kernel, it was just to make the point of how monolithic windows code is in general
11:22:26 <ventonegro> http://en.wikipedia.org/wiki/Singularity_%28operating_system%29
11:22:43 <Nafai> Singularity sounds kind of cool
11:23:15 <procyon112> I believe that conceptually Win 6 is still a microkernel, but the required modules needed to run anything are huge and not unloadable, which pretty much eliminates most of the benefits.
11:24:42 <Apocalisp> Ooh, I remember Inferno
11:24:44 <stmartin> The interesting thing is that most RTOSs I've looked at are all microkernels. Even EPOC (Electronic Piece Of Cheese) which drives my circa 1997 Psion 5 (which runs Hugs by the way) is (to some extent at least) a microkernel.
11:24:54 <kc5tja> Singularity sounds like Oberon System.
11:25:07 <procyon112> chessguy: Actually, I think the level of code is more due to C++ than "windows" development.  There iasn't too much fat in this particular code base, but C++ is pretty verbose.  Especially when written in a C-style, as we do here.
11:25:21 <chessguy> bleah
11:25:30 <chessguy> most linux code is C/C++
11:25:40 <chessguy> but it's much more modularized
11:26:13 <kc5tja> stmartin: QNX is also a microkernel.
11:26:34 <dying_sphynx> hi all!
11:26:37 <ventonegro> stmartin: minix 3 is geared towards small devices
11:26:45 <stmartin> Yes, I was playing with the demodisk today. Very cool. Seemed much cooler back then.
11:27:05 <procyon112> yes.. linux code is *much* more modularized.  More than any C project I've ever seen.  Windows (OS) code is horribly tightly coupled.
11:27:08 <kc5tja> Heck, even AmigaOS was a (single address-space) microkernel.
11:27:32 <stmartin> Theres also L4, with a "Linux" distribution (meaning it can run Linux binaries without recompilation) -- L4Linux
11:27:38 <Apocalisp> AmigaOS!
11:27:43 <LeCamarade> Singularity Project is like House (of Haskell), but with corporate backing, right?
11:27:51 <kc5tja> Yes, I've done some simple work with L4, and I have nothing but excellent things to say about it.  Very nice system to code for.
11:28:07 <LeCamarade> kc5tja: So you'
11:28:11 <LeCamarade> d  love the HURD?
11:28:20 <LeCamarade> s/$//
11:28:24 <procyon112> House is native code I believe.  Singularity appears to be all managed.  That would be a major distinction.
11:28:46 <LeCamarade> House is not native. Only a very small part. IIRC.
11:29:03 <kc5tja> The problem I see with HURD is that they try very hard on the one hand to expose the microkernel architecture, and on the other hand, to abstract it away completely.  As a result, HURD is a highly schizophrenic operating system -- looking at it (I've never used it) from the outside, I'm not sure I'd like it.
11:29:08 <LeCamarade> OCaml had the Desert Spring-Time OS, an equivalent.
11:29:32 <psnl> shapr: can you do things like http://www.youtube.com/watch?v=l6atPaWStCo&NR=1 ?
11:29:36 <dylan> I was under the impression DST-OS was vaporware.
11:29:49 <stmartin> @goto House
11:29:49 <lambdabot> Maybe you meant: todo vote
11:29:50 <LeCamarade> dylan: Well, almost. :o)
11:29:54 <kc5tja> However, when I used QNX, I enjoyed it immensely.
11:30:01 <sphynx> I have coded Dijkstra algorithm for converting infix to postfix using stack indirectly (with help of pattern metching). But my code is a bit ugly and using recursion, so I want to rewrite it using folds. Could you please take a look on it if I would hpaste it and say if it would be reasonable change?
11:30:08 <stmartin> What did BeOS use?
11:30:15 <Botje> sphynx: sure, go ahead
11:30:56 <kc5tja> stmartin: BeOS was a bit bizarre, being written in a pure OO manner via C++.  I seem to recall it being a monolithic kernel, but because of its OOness, it had a lot of the attributes of a microkernel.
11:32:48 <hpaste>  sphynx pasted "Infix-to-postfix Dijkstra converter" at http://hpaste.org/1888
11:33:18 <LeCamarade> Hand up if you have wished that all Haskell type classes were automatic inheritors of Show, and a (mythical) type class that has the methods like toBool that if-then-else tests for.
11:33:26 <sphynx> I have pasted whole converter with parsing part too (it is done Parsec)
11:33:35 <LeCamarade> I want to count. Yours truly, ex-OO freak.
11:33:48 <sphynx> But I'm interested in translation part review
11:33:52 <sphynx> mostly
11:33:54 * kc5tja likes OO.
11:33:57 <kc5tja> But I value FP too.
11:34:02 <kilimanjaro> LeCamarade, maybe there could be a module declaration that specifies what type classes declared within get automatically
11:34:29 <kilimanjaro> I think OO within a FP framework is superior to FP within an OO framework
11:34:38 <kc5tja> My latest work here at the office combines OO and FP styles (using Python).
11:35:05 <pejo> kilimanjaro, how do you tell which part that is outside?
11:35:13 <LeCamarade> I don't know how to reconcile the importance of purity with the need for keeping arbitrary attributes against an object (à la JavaScript/Python/Perl object). :o(
11:35:38 <monochrom> automatic inheritance is evil.
11:35:53 * ventonegro does not remember the last project he used OO
11:35:55 <ndm> woohoo! http://neilmitchell.blogspot.com/2007/05/47-faster-than-ghc.html
11:35:55 <kilimanjaro> pejo, well, I took a class at a university and we had to work programming assignments using Java. The sort of problems that had absolutely nothing to do with OO programming
11:36:05 <ndm> now 47% faster than GHC
11:36:06 <procyon112> LeCamarade: Definately no on the toBool.  I'd be fairly neutral on the show, but I would probably fall on the no side of the fence.
11:36:07 <kc5tja> kilimanjaro: It seems to me that OO within an FP framework is complicated by trying to balance statelessness with statefulness.  I cannot see OO in Haskell as being very clear, since you run headlong into monads, and all state must exist _inside_ a monad.  Programming according to true OO principles would tend to get burdensome as a result.
11:36:08 <monochrom> But I'm a liberal.
11:36:42 <kilimanjaro> kc5tja, does object oriented programming need to be stateful?
11:36:47 <pejo> kilimanjaro, agreed. But take OOHaskell, or O'Haskell, is that FP in OO  or OO in FP?
11:36:52 <LeCamarade> kilimanjaro: I understand very, very well.
11:37:04 <procyon112> monochrome: hehe
11:37:30 <monochrom> OOP is more interesting if stateful.
11:37:31 <LeCamarade> Everyone shoves OO at us. X-(
11:37:41 <kc5tja> kilimanjaro: To be an object, it must have state and state-transitioning methods.  If you lack state, you cease to have objects.
11:37:47 <kilimanjaro> I don't really understand OO programming anyways. It seems a lot of stuff that is espoused as good design (composition, not inherentence. loose coupling. opaque structures) is handled just fine in a language like Haskell
11:38:05 <monochrom> subtyping is the hard part of OOFP.
11:38:05 <kc5tja> kilimanjaro: Don't give me this, "But we can fake state by nesting function calls, etc."  That's still state.  ;D
11:38:12 <Botje> sphynx: it's looking rather good to me
11:38:22 <kilimanjaro> kc5tja, ok, so can you give me an example of something that doesn't have state?
11:38:41 <DRMacIver> monochrom: It doesn't seem inherently hard to me.
11:38:44 <ndm> @seen dcoutts
11:38:44 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts last spoke.
11:38:46 <kilimanjaro> i'm just confused, because anything that exists at run time does have state
11:38:47 <ndm> @seen dcoutts__
11:38:48 <lambdabot> dcoutts__ is in #ghc, #haskell-overflow, #haskell and #gentoo-haskell. I last heard dcoutts__ speak 2h 36m 11s ago.
11:39:03 <sphynx> Botje, so do you think I don't need to rewrite it using folds?
11:39:04 <kc5tja> kilimanjaro: double x = 2*x
11:39:08 <monochrom> But I'm a humble guy. (yeah!)
11:39:18 <pejo> DRMacIver, subtyping in HM with typeclasses is far from trivial.
11:39:34 <sphynx> Botje, I have rewritten my postfix evaluator with folds and the code became much cleaner )
11:39:35 <kilimanjaro> kc5tja, so a lambda abstraction is not an object? I've been living my life all wrong :)
11:39:45 <kc5tja> kilimanjaro: Careful!!!!
11:40:02 <kc5tja> kilimanjaro: A lambda abstraction in and of itself is not necessarily an object.  A *CLOSURE*, however, *is*.
11:40:26 <monochrom> HM + subtyping is trivial if you mandate programmer-written type soundness proofs. In fact throw in intersection types and the problem is not harder.
11:40:28 <DRMacIver> pejo: No, but it is solved.
11:40:34 <kc5tja> kilimanjaro: A closure exists when you have references to variables outside of your local scope, but within your lexical scope.  As long as the reference to the "inner" lambda exists, the state for the "outer" lexical scope tags along.
11:40:38 <kilimanjaro> kc5tja,  ok, so (* 2) is an object
11:40:46 <ndm> @seen dons
11:40:46 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 3h 34m 38s ago.
11:40:47 <kc5tja> No, it's a function.
11:40:52 <kilimanjaro> kc5tja, it is a closure
11:40:54 <kilimanjaro> it closes over *
11:40:59 <kc5tja> No, because it accepts a formal parameter.
11:41:05 <procyon112> It depends on the definition of "object".  There are 5 million defininitions, of which "closure" satisfies only 3,532,435 of them.
11:41:06 <kc5tja> It does not refer to a variable outside it's scope.
11:41:10 <kilimanjaro> \x -> 2*x
11:41:13 <kc5tja> (x*2) is a closure.
11:41:23 <kilimanjaro> kc5tja, I think you are confused
11:41:31 <kc5tja> No.
11:41:35 <kc5tja> \x -> 2*x is a function.
11:41:38 <Botje> sphynx: I wouldn't know how to rewrite it.. if you think it's doable, go for it
11:41:43 <kc5tja> I can take is address if I had the ability to in Haskell.
11:41:47 <kc5tja> This is equivalent to:
11:41:54 <kc5tja> int double(int x) { return 2*x; }
11:42:07 <kc5tja> That is just a plain-vanilla function.
11:42:13 <kilimanjaro> kc5tja, (*) is free in \x -> 2*x
11:42:15 <kc5tja> No state is referenced outside of the scope of the function itself.
11:42:21 <LeCamarade> Part of why I said that stuff about auto inheritance was so each class could inherit a state-keeping mechanism, so I don't have to lose the only thing OO actually gives me - arbitrary state (via dicts and dict-based properties).
11:42:22 <sphynx> Botje, OK )
11:42:33 <kc5tja> err....no, * is defined by the compiler.
11:42:43 <DRMacIver> :type (*)
11:42:45 <kilimanjaro> * can be redefined
11:42:47 <DRMacIver> Oops
11:42:50 <DRMacIver> ?type (*)
11:42:51 <kc5tja> Sure, it can be, but so what?
11:42:52 <lambdabot> forall a. (Num a) => a -> a -> a
11:43:02 <kc5tja> What matters aren't the functions, what matters are the variables.
11:43:17 <DRMacIver> The point being made here is that (*) is a variable.
11:43:20 <monochrom> I think "class Myclass extends HasDict" is an acceptable alternative to "class Myclass".
11:43:27 <kilimanjaro> kc5tja, so the denotation of * depends on context, and \x -> 2*x closes over the lexically apparent (*) regardless of whether or not it is later defined in a call site
11:43:29 <kc5tja> I think you should read up Structured Interpretation of Computer Programs -- it explains this very clearly.
11:43:52 <kc5tja> kilimanjaro: By your logic, ALL CODE is a closure, including something as simple as "4".
11:43:56 <kilimanjaro> No
11:44:02 <kilimanjaro> a combinator has no free variables
11:44:08 <kilimanjaro> 4 is a literal
11:44:18 <kc5tja> But a combinator uses other functions to combine other functions, thus creating an open reference.
11:44:21 <monochrom> Actually some classes will not use HasDict and it would be annoying to have no way to remove it.
11:44:40 <kilimanjaro> kc5tja, err, I misspoke
11:44:48 <kilimanjaro> but anyways, a closure has free variables
11:44:57 <kilimanjaro> * is free in \x -> 2*x
11:44:59 <kc5tja> Which is what I've been arguing all along.
11:45:00 <kilimanjaro> hence socrates is mortal
11:45:17 <kc5tja> Unless you pass a function as a variable, however, functions do not count in the free variable context.
11:45:18 <shapr> psnl: Most of it yeah, not that spin drop at the very end though.
11:45:35 <kilimanjaro> kc5tja, what?
11:45:40 <kc5tja> Never mind.
11:46:16 <procyon112> socrates is comortal.
11:46:19 <monochrom> All points are circles. All squares are rectangles. All pieces of code are closures. You have a problem?
11:46:23 <psnl> shapr: I'm really quite impressed.
11:47:11 <kilimanjaro> \x -> (x 4) is not a closure
11:47:26 <kc5tja> monochrom: I don't know who that question is directed at, but that just brings me to the point I was about to make, which is, if all code is closures, then the whole exercise of distinguishing between stateful and non-stateful code is retarded.
11:47:55 <monochrom> I confess I don't actually know closures.
11:48:02 <kc5tja> \x -> x*4 is _also_ not a closure.
11:48:07 <kilimanjaro> Why not?
11:48:15 <kc5tja> Why is it?
11:48:42 <kc5tja> It is a function that takes an x, and returns 4x.
11:48:43 <kilimanjaro> * is free
11:48:45 <kc5tja> Period.
11:48:45 <kc5tja> No!
11:49:02 <LeCamarade> kc5tja: I think it is, because it encloses its scope, whether or not it uses it.
11:49:06 <kc5tja> * is a function that is bound at compile-time.
11:49:13 * LeCamarade is not SPJ or dons, though.
11:49:31 <kc5tja> If you're going to use that logic, then ALL CODE is a closure.
11:49:32 <kc5tja> ALL.
11:49:45 * LeCamarade or ndm (47% faster, woo!) or dcoutts or ... you know, the nice hackers here.
11:49:57 <kc5tja> At which point, we end up right back at square 1, which is, "What is the difference between stateful and stateless code?"
11:50:02 <procyon112> All abstractions are closures, not neccissarily all values.
11:50:38 <kc5tja> So identifying 4*x as a closure because "*" is considered a "free variable" becomes nonsensical in a practical discussion.
11:50:39 <ndm> LeCamarade: i agree with you, it is a closure, i think
11:50:46 <DRMacIver> * isn't bound at compile time any more than any other argument to a function is.
11:51:03 <DRMacIver> I mean, it is in C, etc. but it isn't in Haskell.
11:51:21 <kc5tja> DRMacIver: Sure it is.  If I execute that lambda both before and after defining "*" at run-time, I get the same value back, unless Haskell does a name-based lookup every function it invokes.
11:52:04 <DRMacIver> kc5tja: It's certainly a common implementation technique that it does effectively just that.
11:52:22 <kc5tja> Errr....no.
11:52:22 <DRMacIver> kc5tja: Functions which use type classes will often be turned into functions which accept a record realising that type class.
11:52:23 <Heffalump> I wouldn't call that name-based lookup
11:52:29 <kilimanjaro> kc5tja, well, a closure is a way to represent a function with free variables. whether or not an expression is strictly a closure depends completely on implementation
11:52:39 <kc5tja> I can't redefine (*) taking numbers because it's already defined elsewhere.
11:52:44 <LeCamarade> I am of the view that the only time a func def is not a closure is if it is in a `where' where it is not allowed to access its scope bindings.
11:52:45 <DRMacIver> I mean, it's not looking it up on the string literal. But that's a strawman argument.
11:52:49 <kc5tja> Type-based resolution is a compile-time activity.
11:53:38 <kc5tja> DRMacIver: Actually, it is quite relavent to the distinction.
11:53:40 <kilimanjaro> > ((let a * 4 = "red" in \x -> x*4) 3)
11:53:44 <Heffalump> are we talking Haskell 98 here?
11:53:48 <lambdabot>  "red"
11:53:48 <DRMacIver> kc5tja: 'fraid not. Some Haskell compilers agressively inline, but it really is the case that most implement this based on record passing.
11:54:03 <kilimanjaro> a modular compiler will implement it based on record passing
11:54:09 <kc5tja> Records which are compiler type-checked and enforced -- hence bound by the compiler.
11:54:12 <kilimanjaro> a whole program optimizing compiler can avoid such stuff
11:54:37 <kc5tja> kilimanjaro: Again proving it's bound by the compiler.
11:54:47 <Heffalump> are we talking Haskell 98 here?
11:54:48 <kilimanjaro> kc5tja, what does this have to do with it being a closure?
11:54:59 <Heffalump> (cos if we're not, it really can be runtime determined..)
11:55:02 <kilimanjaro> Heffalump, I think some of us are and some of us aren't. Feel free to pick sides without telling anybody
11:55:12 <Heffalump> good plan
11:55:18 <kc5tja> kilimanjaro: That's the question, isn't it?  You brought up that (*) in (4*x) is a free variable, and I claim quite the opposite.
11:55:30 * Heffalump picks the side against kc5tja on the basis that it was a good side to pick in the last pointless argument
11:55:39 <kc5tja> Fin.e
11:56:07 <Heffalump> wow.
11:56:22 <Heffalump> I only said 6 things, and two of those were repeats.
11:56:25 <kilimanjaro> I still don't understand his argument. Is it that the meaning of all free variables is statically determined in all Haskell programs?
11:56:32 <kilimanjaro> Heffalump, I think he needed a nap
11:57:52 <DRMacIver> I must admit, it's interesting to see that #haskell isn't *completely* immune to the kind of ridiculous arguments the rest of IRC gets. :)
11:57:53 <LeCamarade> @tell kc5tja Sorry.
11:57:53 <lambdabot> Consider it noted.
11:58:30 <kilimanjaro> DRMacIver, that's the high cost of reddit fame
11:58:39 <DRMacIver> Heh
11:58:48 <LeCamarade> DRMacIver: #haskell is a very oft-used channel, on par with #ubuntu. The Haskell community lives on IRC.
11:58:53 <DRMacIver> It's still a lot better than almost any other public IRC channel I've seen.
11:58:56 <chessguy> @pl argument
11:58:56 <lambdabot> argument
11:58:59 <kilimanjaro> I like #haskell
11:59:13 <mbishop> fun arguments?!
11:59:16 <ventonegro> utf-8 hearts anyone?
11:59:26 <ventonegro> I heart #haskell
11:59:27 <kilimanjaro> This channel is full of helpful geniuses
11:59:33 <chessguy> @quote heart
11:59:34 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
11:59:44 <LeCamarade> return <3 >>= #haskell
11:59:47 <chessguy> @quote break.heart
11:59:47 <lambdabot> No quotes match. stty: unknown mode: doofus
12:00:01 <chessguy> @quote breaks.heart
12:00:02 <lambdabot> kpreid says: @pl (<3) -- pl breaks hearts!
12:00:07 <chessguy> there we go
12:00:19 <chessguy> @pl (<3)
12:00:19 <lambdabot> (< 3)
12:00:22 <Apocalisp> <3 is a heart? I always thought it was an asshat.
12:00:25 <LeCamarade> :oD
12:00:26 <opqdonut> :D
12:00:36 <stmartin> How am I supposed to use  read  to parse a number from a string?
12:00:42 <LeCamarade> Apocalisp: :'oD
12:00:44 <chessguy> > read "3"
12:00:46 <lambdabot>  3
12:00:47 <sjanssen> @remember Apocalisp <3 is a heart? I always thought it was an asshat.
12:00:47 <lambdabot> Done.
12:01:00 <stmartin> I thought it ought to be that simple.
12:01:04 <sjanssen> it is a little bit evil that chessguy's example works
12:01:15 <LeCamarade> > read "NaN"
12:01:17 <lambdabot>  Exception: Prelude.read: no parse
12:01:22 <chessguy> sjanssen: how so?
12:01:30 <mbishop> Ü
12:01:31 <LeCamarade> stmartin: ^^ Watch it.
12:01:33 <Saizan> chessguy: defaulting
12:01:36 <mbishop> it's not a heart, but I think it's pretty
12:01:48 <chessguy> oh
12:01:57 <sjanssen> chessguy: in Haskell '98, that'd fail because you didn't choose the result type
12:01:58 <stmartin> I know its a string of digits, because I'm wanting to call  read on the result of a Parsec parser.
12:02:09 <chessguy> aha
12:02:15 <sjanssen> chessguy: ghc has some extended defaulting rules
12:02:22 <sjanssen> > return ()
12:02:22 <chessguy> > read "3" :: Integer
12:02:23 <lambdabot>   add an instance declaration for (Show (m ()))
12:02:24 <lambdabot>  3
12:02:32 <chessguy> > (read "3" ::) Integer
12:02:32 <lambdabot>  Parse error
12:02:37 * chessguy sighs
12:02:41 <chessguy> i can't type today
12:02:47 <chessguy> > (read "3") :: Integer
12:02:49 <lambdabot>  3
12:02:56 <sjanssen> stmartin: something like: do x <- myParser; return (read x), perhaps?
12:02:58 <mbishop> Think I'll go play more tremulous
12:03:03 <chessguy> stmartin: this is how you would (portably) want to use it
12:03:27 <LeCamarade> > read "3"::Int
12:03:28 <lambdabot>  3
12:03:57 <stmartin> Couldn't match expected type 'Int' against inferred type `m a'
12:04:06 <stmartin> number              =   do str <- many1 digit return (read str) :: Int
12:04:07 <LeCamarade> stmartin:
12:04:15 <Saizan> > (read . show $ 2^35) :: Int
12:04:17 <lambdabot>  0
12:06:06 <LeCamarade> getLine >>= (return . read) >>= putStrLn . show
12:06:23 <LeCamarade> That works ... maybe you miss a return?
12:06:28 <LeCamarade> Or a ... wait?
12:06:36 <LeCamarade> wait.
12:06:53 <Saizan> ..
12:07:25 <LeCamarade> X-(
12:07:37 <Saizan> number = do { str <- many1 digits; return (read str :: Int) }
12:07:50 <Saizan> s/digits/digit/
12:08:53 <stmartin> Thanks.
12:09:09 <stmartin> I really must read more about precedence in Haskell.
12:09:48 <Saizan> or number :: Parser Int \n number = read `liftM` many1 digit
12:11:57 <LeCamarade> @quote tm
12:11:57 <lambdabot> tm says: Miranda (tm) is a trademark of Research Software
12:12:18 <LeCamarade> @quote dons
12:12:18 <lambdabot> dons says: C++: creating blub programmers since 1985
12:12:27 <LeCamarade> :oD
12:12:37 <LeCamarade> @quoted dcoutts
12:12:37 <lambdabot> dcoutts says: Apparently that's only 200x faster than the faster of two common python serialisation libs, so we've got some way to go yet.
12:12:59 <LeCamarade> @quote ndm
12:12:59 <lambdabot> ndm says: Anyone who promotes the use of large tuples should be asked to manually infer the types of functions in Yhc, it will stop the tuple madness quite quickly
12:13:09 <LeCamarade> :oD
12:13:20 <LeCamarade> I @remembered that myself.
12:13:38 <Saizan> @quote LeCamarade
12:13:38 <lambdabot> LeCamarade says:  Vi is to editing what Haskell is to hacking. And Emacs is like the C++ of editing.
12:13:46 * LeCamarade is in Monologue Mode. Relax. It's about to pass.
12:14:10 <LeCamarade> Now my friends are offended. :o(
12:14:19 * nominolo disagrees
12:14:25 <LeCamarade> @quote Saizan
12:14:25 <lambdabot> Saizan says: the problem is that we still have a silicon chip under us
12:14:33 <LeCamarade> :oD
12:14:37 <LeCamarade> @quote nominolo
12:14:37 <lambdabot> bringert says: nominolo: as an exercise, implement type-level binary artihmetic
12:14:42 <LeCamarade> @quote nominolo
12:14:42 <lambdabot> bringert says: nominolo: as an exercise, implement type-level binary artihmetic
12:14:46 <LeCamarade> X-(
12:14:49 <nominolo> there no more
12:14:58 <nominolo> *are
12:15:23 * bringert can't spell arithmetic
12:15:42 <Apocalisp> @quote arithmetic
12:15:42 <lambdabot> edwardk says: been playing with type level 2s complement arithmetic
12:15:46 <LeCamarade> bringert: At least it still compiles. :oD
12:15:59 <LeCamarade> @quote factorial
12:15:59 <lambdabot> jcreigh says: <chessguy> i mean if someone says factorial should be of type String -> [(Float, Bool)], you should just tell them they're nuts  <jcreigh> > let fac n = map (\x -> (x, True)) $ scanl (*
12:15:59 <lambdabot> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:16:01 * shapr boings cheerfully
12:16:10 <nominolo> bringert: btw, exercise done (sort of)
12:16:35 <LeCamarade> @quote shapr -- I'm really looking forward to this one ...
12:16:35 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
12:16:39 <bringert> bringert: nice. is it fixed or variable width binary numbers?
12:16:42 <LeCamarade> @quote shapr
12:16:43 <lambdabot> shapr says: I encourage my competitors to use Windows.
12:16:48 <chessguy> > let fac n = map (\x -> (x, True)) $ scanl (*
12:16:49 <chessguy> ) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:16:49 <lambdabot>  Parse error
12:16:49 <LeCamarade> :oD
12:16:50 <nominolo> bringert: also, it might have been @remembered discorrectly
12:16:52 <LeCamarade> :'oD
12:16:59 <bringert> I only implemented fixed width
12:17:07 <shapr> psnl: It's not so hard for me to do that sort of mountain unicyling because I have the unicycle equivalent of an SUV.
12:17:15 <chessguy> > let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
12:17:16 <lambdabot>  [(1.0,True),(1.0,True),(2.0,True),(6.0,True),(24.0,True),(120.0,True)]
12:17:18 <nominolo> bringert: oh, binary arithmetic.. ok, no
12:17:25 <nominolo> bringert: i'll do it on the weekend
12:17:48 <nominolo> ;)
12:18:01 <bringert> nominolo: what did you do? unary?
12:18:14 <nominolo> yeah, Z | S x
12:18:32 <bringert> do you have multiplication?
12:18:42 <shapr> Are the newest Yi sources from jyp in don's Yi darcs repo?
12:19:38 <shapr> @quote
12:19:38 <lambdabot> dmhouse says: instance Lambdabot where { ?pl = xerox, ?where = shapr, ... }
12:19:44 <shapr> ??
12:19:55 <chessguy> haha
12:19:56 * shapr gets it and laughs
12:20:33 <nominolo> bringert: yes.  but i cheated
12:20:41 * shapr hugs bringert, for much good code
12:21:05 <shapr> Are associated types available in ghc 6.6.1?
12:21:16 <LeCamarade> @quote hilton
12:21:16 <lambdabot> dons says: she wrote some nice papers in the late 80s on generational garbage collection, I think. there was one with Wadler, iirc. on removing intermediate lists. unless i'm thinking of the wrong
12:21:16 <lambdabot> paris hilton.
12:21:22 <nominolo> bringert: i was trying to solve a different problem and didn't want to waste too much time, so I just googled for HList and HMult ;P
12:21:35 <nominolo> shapr: no
12:21:48 <shapr> LeCamarade: That's a great quote, dons says lots of funny things :-)
12:21:54 <Igloo> shapr: no
12:22:13 <shapr> nominolo, Igloo: Ok thanks.. are they available as a library, or is there a branch?
12:22:22 <bringert> @google paris hilton category theory
12:22:25 <nominolo> shapr: Head has it
12:22:25 <lambdabot> http://www.tmz.com/category/paris-hilton/page/2/
12:22:26 <lambdabot> Title: Posts from the Paris Hilton Category at TMZ.com
12:22:32 <shapr> nominolo: Spiffy
12:22:33 <bringert> grr
12:22:37 <Igloo> shapr: There is the HEAD
12:23:01 <Igloo> Hmm, I should really read more before replying  :-)
12:23:17 <shapr> It's okay, eager parallel responses are fine ;-)
12:23:26 <nominolo> shapr: i tried it a while ago but got bitten by some bug.  meanwhile, though, SimonPJ fixed it
12:23:27 <Igloo> They aren't completed yet, though
12:24:26 <nominolo> @go paris hilton "category theory"
12:24:29 <lambdabot> http://north.ecc.edu/alsani/catbib.html
12:24:29 <lambdabot> Title: BIBLIOGRAPHY about DESCENT and CATEGORY THEORY!
12:24:29 <shapr> As per http://www.scannedinavian.com/hope/entry/114 , I was thinking about how to convert a Haskell program into a multicore capable program via NDP and ATs. I figured a tutorial would be a good thing.
12:25:21 <shapr> Oh, I got asterisk working, yay! I can call Sweden for $0.02 a minute now! w00!
12:26:17 <nominolo> shapr: how do ATs help with parallelism (other than that DPH uses them)?
12:26:28 <LeCamarade> shapr: Nice blog post. I missed it ...
12:26:47 <LeCamarade> hey! It's for today, timezones considered!
12:26:48 <shapr> With ATs you could create a versions of a library that uses NDP.
12:27:30 <shapr> ATs mean you could create multiple versions of a library, tuned for arch (x86, ARM, etc), cache size, and whatever else.
12:28:03 <shapr> nominolo: Or do I misunderstand ATs?
12:28:29 <nominolo> shapr: hm, no, sounds reasonable.
12:28:41 <nominolo> shapr: i don't know all the details, either
12:28:49 <LeCamarade> shapr: We just need new operating systems, new idioms, new languages. It's not 1960 anymore. Don't karma me down, but ... I just feel like all this let's-get-ready-for-n-cores is like patching an old shirt. We need to think afresh. Kill all adults. :oD
12:29:00 * LeCamarade is kidding about the killing part.
12:29:18 <shapr> LeCamarade: Well, tell me about the new shirt?
12:29:29 <LeCamarade> Like 1-core thought never existed. Okay, I'm going #haskell-blah. :o)
12:30:00 <nominolo> LeCamarade: Von-Neumann tried that
12:30:22 <nominolo> LeCamarade: more successfully, we had the connection machine and the transputer
12:30:31 <LeCamarade> shapr: Well, where there is no writing to memory, but just communicating to the kernel like it is a web server - it takes care of syncing. I'm off a Robert Heinlein, so forgive me.
12:30:49 <shapr> LeCamarade: Isn't that how microkernels work?
12:31:09 <shapr> I'm more interested in exokernels at the moment.
12:31:58 <nominolo> shapr: i think exokernels are just another name to avoid the word "microkernel"
12:32:06 <LeCamarade> Nope. They don't go that far. I mean making the whole variable thing the concern of the kernel, so it knows the names of vars (see? I said _new_), and whoever needs that var ... just like a blog post with many contributors doesn't run into problems with .swp files.
12:32:09 <nominolo> and Mach certainly is a bad MK
12:32:15 * LeCamarade is naive, though. Not an OS guy.
12:32:27 <shapr> I've been thinking about how CPUs were tuned to make C programs execute speedily, and I've been trying to figure out how you'd tune a CPU to execute Haskell programs speedily. But I haven't come up with anything, does anyone have suggestions?
12:33:00 <Nafai> shapr: Would looking at the Lisp Machines give you any ideas?
12:33:07 <integral> shapr: What about the Lisp CPUs? They were designed to create cons cells very quickly
12:33:23 <nominolo> shapr: there's a paper on cache strategies for graph reduction systems
12:33:32 <shapr> Maybe, I don't know how the LispM CPUs are different from today's CPUs.
12:33:44 <nominolo> very different
12:33:45 <shapr> nominolo: Which paper? Or should ask scholar.google for those keywords?
12:34:03 <nominolo> shapr: yes, better ask scholar
12:34:21 <shapr> For one thing, purely functional machine code wouldn't need as much cache coherency.
12:34:22 <sdf> which language the assembly be wrote? with mathine language??
12:34:29 <shapr> sdf: Yes
12:34:54 <shapr> Though nowadays I'd guess it's done with cross compiling from an existing assembler.
12:34:55 <nominolo> shapr: but you need to update due to naming
12:35:33 <nominolo> i.e., to cache results
12:35:36 <sdf> can we write the new language better than assembly with machine language??
12:35:41 <procyon112> shapr: Isn't the spineless, tagless g-machine a machine architecture for fast haskell programs?
12:36:28 <shapr> procyon112: Good point
12:38:16 <sdf> can we?
12:38:43 <shapr> sdf: Yes, but I'm not sure it would make a big difference in the world of programming.
12:39:16 <sdf> shapr why?
12:39:38 <sdf> shapr language is easier than assembly
12:41:42 <sdf> i feel i vey stupid
12:41:48 <sdf> i m
12:42:02 <shapr> sdf: Nah, we all start at the beginning.
12:42:34 <shapr> sdf: When I first started learning programming I joined #perl and was kick-banned for months. Then I joined #python and got kickbanned for days...
12:42:56 <sdf> hehe
12:43:00 <kaol> how'd you manage that? if you don't mind me asking.
12:43:47 <shapr> kaol: On #perl I asked for an editor with syntax highlighting, and I was told that real programmers do not require such a thing. I said I wanted it anyway for my own understand, and I didn't care whether I was a real programmer or not. So I got kickbanned.
12:43:54 <LeCamarade> kaol: Asking in #perl what s/\$123876883458saasd@#%&^$%*/$0/gi means gets you kickbanned.
12:43:57 <stmartin> I don't suppose anyone knows the haskell equivalent of isatty()?
12:44:42 <shapr> On #python, there were only eleven people before I joined, and no conversation, so I started saying "Hi!" in as many languages as I could think of, just to spark some conversation. But I got kickbanned instead.
12:44:50 <LeCamarade> stmartin: Isn't it in System.Posix.IO ?
12:45:05 <kaol> I'm thinking that there should be a wikibook on HAppS
12:45:05 <koala_man> shapr: I hope that didn't surprise you
12:45:16 <shapr> koala_man: It did surprise me actually.
12:45:19 <shapr> kaol: Oh, good idea!
12:45:29 <LeCamarade> Hmm ... seems not.
12:45:38 <kaol> so go write one? heh.
12:45:46 <kaol> referring to me there
12:46:17 <shapr> koala_man: Because I still remember those experiences, when someone joins #haskell and acts in a way that does not fit into the community, I try to explain carefully to them what's considered acceptable behaviour. If they continue acting in an unacceptable manner, then they get removed.
12:47:24 <stmartin> Found it. System.Posix.Terminal, right at the bottom.
12:47:34 <stmartin> queryTerminal
12:48:05 <shapr> Most people try to fit into the community once they understand what's acceptable. Most of the rest disagree and leave. But those last few feel the LAMBDA HAMMER!!
12:48:09 <shapr> or something..
12:50:30 <dylan> #haskell's the only channel on freenode I'm aware of that is on-par with my friend's private irc network, in terms of quality discussion.
12:50:33 <procyon112> Lambda is more like a boomarang than a hammer.
12:50:50 <procyon112> :D
12:51:34 <dylan> I do occasionally like joining particularly harsh channels and helping newbies.
12:51:38 <shapr> True, Igloo once suggested that the first Haskell Workshop to be held in Australia should give out lambda boomerangs.
12:51:58 <dylan> I want a lambda shuriken.
12:52:06 <shapr> haha
12:53:02 <takamura> hi
12:53:32 <LeCamarade> Oceanians are avid lambdamen, I should note.
12:53:44 <LeCamarade> UNSW and all.
12:53:46 <shapr> hola takamura
12:53:47 <dylan> actually, wait. my lug's channel is on freenode and there's no harshness there either. But it has only 12 people on average, so it hardly counts.
12:53:53 <LeCamarade> Or something.
12:53:59 <takamura> hola, shapr :)
12:54:32 <takamura> i have a question: An if then else construction cannot be used in a do block?
12:54:50 <dylan> greetings, japanese-sounding name from spainish IP. :)
12:54:50 <shapr> Er, why not?
12:54:58 <takamura> haha
12:54:59 <stmartin> everyone++
12:55:15 <stmartin> Thanks for your help, you were all great.
12:55:15 <takamura> I'm trying to use it in my program but fails
12:55:29 <ventonegro> @where paste
12:55:29 <lambdabot> http:/hpaste.org/new
12:55:32 <dylan> takamura: try keeping the indentation of the then and else parts the same.
12:55:35 <shapr> What error does your program give?
12:56:00 <takamura> I got a lot of indentation errors, but couldn't correct it
12:56:12 <takamura> tried many indentations
12:56:17 <shapr> If you indent "then" and "else" one space more than "if" it might work.
12:56:27 <dmhouse> ?where+ paste http://hpaste.org/new
12:56:27 <lambdabot> Done.
12:57:06 <hpaste>  dylan pasted "for takamura" at http://hpaste.org/1889
12:57:14 <takamura> finally I defined a function f x y z = if x then y blahblah
12:57:35 <takamura> and sustitued it in the place of the if then
12:58:13 <monochrom> In the then branch and the else branch, if you plan to have several actions, start a new do block there. E.g. if x then do { a; b } else do {a;b}
12:58:14 <takamura> oh, if should go _before_ the do?
12:58:42 <takamura> i will try it
12:59:35 <monochrom> It is also necessary to have do before if.  do { c <- getChar; if c=='a' then do { a;b } else do {a;b}; return 0; }
13:01:43 <kosmikus> ?seen jyp
13:01:43 <lambdabot> I saw jyp leaving #haskell and #oasis 2h 23m 17s ago, and .
13:01:46 <LeCamarade> How long has lambdabot been around? And I don't mean uptime.
13:01:52 <LeCamarade> @uptime
13:01:52 <lambdabot> uptime: 1d 20h 30m 3s, longest uptime: 13d 18h 36m 21s
13:01:56 <shapr> LeCamarade: 2001 I think
13:02:30 <LeCamarade> Wow. Hence all the sexy modules. The language that sent me here to spy is just getting one. :o(
13:02:45 <shapr> What language is that?
13:03:02 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1890
13:03:03 <Heffalump> just getting one what?
13:03:04 <Saizan> so she's only six!? omg, she told me she was 18!
13:03:05 <LeCamarade> shapr: Classified information, I'm afraid.
13:03:13 <kosmikus> Heffalump: a bot, I think
13:03:14 <LeCamarade> Heffalump: A bot.
13:03:14 <Heffalump> you've told us before, haven't you?
13:03:14 <takamura> it is like this: http://hpaste.org/1890
13:03:21 <monochrom> She grows fast.
13:03:22 <Heffalump> as in a lambdabot, or a different one?
13:03:27 <LeCamarade> Saizan: ;'oD
13:03:31 <LeCamarade> :
13:03:32 <LeCamarade> oD
13:03:35 <LeCamarade> :'oD
13:03:42 <monochrom> You need else. You always need else.
13:03:44 <LeCamarade> Heffalump: A different one.
13:03:45 * Heffalump suspects it was #ocaml
13:03:50 <shapr> LeCamarade: I'm glad that good ideas from #haskell are gaining popularity in other language communities! Good stuff should always be popular.
13:03:55 <Heffalump> boting, that'd be the ultimate victory ;-)
13:03:59 <Heffalump> s/boting/boring/
13:04:06 <Heffalump> though we did use lisppaste for a long time
13:04:23 <monochrom> Think of haskell if-then-else as C ?:. You never omit :.
13:04:27 <LeCamarade> Heffalump: Why? Why #ocaml?
13:04:29 <takamura> I have an if then else in other place of the code and it also fails
13:04:44 <monochrom> Then it fails for another reason.
13:04:44 <Heffalump> LeCamarade: I just vaguely remember you mentioning a channel you were claiming to be spying for. I could be wrong.
13:05:03 <takamura> I will look again at it
13:05:08 <LeCamarade> Heffalump: I was under torture. Throw that evidence out.
13:05:18 <monochrom> Elementary! Elementary! Elimination...
13:05:23 <Heffalump> :-)
13:06:00 <Saizan> ?type when
13:06:03 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:06:30 <monochrom> Yeah, consider when
13:06:48 <sjanssen> 07.05.05:09:32:36 <LeCamarade> dons: Yeah, with a /usr/bin/runghc script. I script in Haskell. Even though I am an #ocaml spy. ;oD
13:07:05 <LeCamarade> sjanssen: sjanssen!!!
13:07:07 <sjanssen> having several years of #haskell logs turns out to be really handy :)
13:07:09 <Heffalump> he's not really a very good spy, is he?
13:07:10 * LeCamarade runs away
13:07:31 <mtahti> Hi! I've wrote a program that "should" execute in constant space but I'm observing huge space leak. (Obviously I'm doing something stupid.) Are there any good tutorials on how to deal with space leaks around?
13:07:36 <monochrom> You have to speak English to spy in England. You can't really run around saying "Chinese > English".
13:07:42 <Heffalump> mtahti: the wiki
13:07:50 <Heffalump> and what optimisation level are you using?
13:07:54 <sjanssen> mtahti: if the program is smallish, paste it
13:07:55 <sjanssen> @paste
13:07:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:08:12 <mtahti> Heffalump: thanks, i'll check that out
13:08:13 <Heffalump> monochrom: though LeCamarade seems to be mainly running around admitting English > Chinese :-)
13:08:29 <monochrom> That's a smart spy.
13:08:33 <shapr> LeCamarade: Hey, if you like OCaml, that's cool. I'm sure OCaml has some good ideas that Haskell could benefit from. If every language improves, and uses the good ideas from other languages, we'll all benefit!
13:08:39 <mtahti> sjanssen: Sorry, it isn't small or even smallish.
13:08:52 <IHAVEAGUN> shapr: So you won't execute me?
13:08:59 <Heffalump> well, only slowly
13:09:00 <shapr> No, but I might evaluate you!
13:09:14 <sjanssen> mtahti: you might try GHC's profiler
13:09:15 <shapr> Sorry, execution only happens in procedural channels.
13:09:24 <Saizan> we'll reduce you to normal form!
13:09:27 * IHAVEAGUN thinks that's not too painful ... it is lazy eval. :o)
13:09:38 * Heffalump deepSeqs LeCamarade
13:09:47 <sjanssen> > "IHAVEAGUN" `seq` ()
13:09:48 <lambdabot>  ()
13:10:09 <Heffalump> > 'I':undefined `seq` ()
13:10:10 <lambdabot>  ()
13:10:28 <sjanssen> > rnf "IHAVEAGUN" `seq` ()
13:10:29 <lambdabot>  ()
13:10:34 <Heffalump> hah, you see, it doesn't even matter what he's called ;-)
13:10:56 <ventonegro> WHNF
13:11:01 <sjanssen> > rnf ('I':undefined) `seq` ()
13:11:02 <lambdabot>  Undefined
13:11:17 <Heffalump> @type rnf
13:11:19 <lambdabot> forall a. (NFData a) => a -> Done
13:11:25 * LeCamarade came back to clear syntax error in exit messagem but will stick around/
13:11:30 <Heffalump> how does that differ from DeepSeq?
13:11:39 <Heffalump> you had a type error too.
13:11:40 <sjanssen> Heffalup: same thing, different name
13:11:48 <Heffalump> the Done looks different too
13:11:59 * shapr wants ShallowSeq for polite conversation.
13:12:18 <sjanssen> Heffalump: type Done = (), IIRC
13:12:36 <sjanssen> deepSeq a b = rnf a `seq` b
13:14:17 <dmhouse> ?src foldl
13:14:17 <lambdabot> foldl f z xs = lgo z xs
13:14:17 <lambdabot>     where lgo z []     =  z
13:14:17 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:14:29 <mtahti> sjanssen: I tried the profiler and it says that the program allocated about 250 Mb and 99% of allocations were made in two functions. I'll try paste them here.
13:15:09 <mtahti> @paste main = print "Spare with me, I'm just testing pasting"
13:15:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:15:36 <hpaste>  mtahti pasted "(no title)" at http://hpaste.org/1891
13:17:43 <hpaste>  mtahti pasted "Leaky functions" at http://hpaste.org/1892
13:19:37 <mtahti> sjanssen: I just pasted the two functions responsible for about 99% of the allocations.
13:20:58 <Heffalump> mtahti: what optimisation level?
13:21:10 <mtahti> Hmm, none I guess.
13:22:24 <Saizan> try compiling with -O2
13:24:01 <mtahti> Saizan: I just compiled it with -O and that brought total allocation down to 135 Mb which pretty much for just generating few thousand deviates. I'll try -O2.
13:24:13 <Saizan> also, i'd use strictness annotations like loop1 !g = ... and loop2 !g, because the space leak is probably caused by a huge math expression that's not evaluated
13:24:45 <Heffalump> is loop1 !g valid?
13:25:12 <Saizan> i think so, with -fbang-patterns
13:25:21 <hpaste>  sjanssen annotated "Leaky functions" with "bang patterns" at http://hpaste.org/1892#a1
13:25:26 <Heffalump> oh, right
13:25:33 * Heffalump is clearly ignorant :-)
13:26:24 <mtahti> sjanssen: I'll put those in place and see what happens, thanks.
13:29:42 <Saizan> @quote sprinkle
13:29:42 <lambdabot> No quotes match. It can only be attributed to human error.
13:33:05 <takamura> now the code works, thanks all :D
13:34:49 <mtahti> I'm afraid the bangs didn't solve my problem. The program is still allocating 135Mb. The function lngamma is doing alright now, though.
13:55:13 <Apocalisp> What does one have to do to set up a haskell.countrycode channel?
13:58:13 <kpreid> Join it.
14:10:39 <Apocalisp> Can I ask lambdabot to join?
14:12:28 <sjanssen> Apocalisp: which channel?
14:12:31 <sjanssen> @seen lambdabot
14:12:31 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-
14:12:31 <lambdabot> haskell, #darcs and #scannedinavian
14:12:45 <Apocalisp> I'm just curious really.
14:13:33 <sjanssen> dons is lambdabot's maintainer, and several people in #haskell have the permissions to do that too (I can)
14:13:46 <Apocalisp> cool
14:14:49 <sjanssen> lambdabot2: @part #haskell
14:15:07 <sjanssen> Apocalisp: would you like lambdabot2 to join your channel?
14:15:11 <stepcut> so, if I want to make a console application (e.g. nethack), Should I use the Curses.hsc from hmp3? vty? something else?
14:16:35 <thoughtpolice> stepcut: check out 'hscurses,' it's basically the same interface used in ginsu/hmp3, but it's cleaned up and packaged as a lib
14:17:16 <stepcut> thoughtpolice: ah, that does not seem to be on hackage yet ;)
14:18:12 <Apocalisp> nah, it would just be lambdabot and I
14:21:05 <thoughtpolice> stepcut: i haven't used it (yet, it's installed,) but as far as I can tell it's a fairly complete interface to ncurses, but I don't know about menu/panel support or similar
14:22:17 <andygill> does anyone know how to tell cabal to use a ghc-inplace when configuring? I can use -w, but cabal can not find package tool: ghc-pkg
14:32:27 <dcoutts__> andygill: you can tell cabal about both ghc and ghc-pkg iirc
14:32:59 <dcoutts__> andygill: and when using a ghc-inplace you have to specify both, as there's no way for cabal to find ghc-pkg based on knowing ghc-inplace
14:33:27 <andygill> Yes, but I could not find the inline version of ghc-pkg. I found it, though, in utils/ghc-pkg/ghc-pkg-inplac
14:33:39 <dcoutts__> andygill: someone should add a flag to ghc to tell us where ghc-pkg lives, then cabal would always be able to find it
14:33:52 <andygill> Good idea.
14:33:52 <dcoutts__> like we already have ghc --print-libdir
14:34:24 <dcoutts__> we currently do it by guesswork
14:35:03 <andygill> :-) But we get there..
14:38:38 <dcoutts__> nominolo: you were after me?
14:52:58 <fuzan> what would cause GHC/ghci to segfault immediately after calling?
14:53:21 <fuzan> my program ran into a pretty bad state and went kaput, now I can't even rebuild the project, heh.
14:55:09 <shapr> Are you using unsafe anything?
14:55:45 <fuzan> shapr: no, just Control.Concurrent and lightweight threads
14:55:59 <fuzan> i've just been too lazy to implement correct handling of threads in case of error
14:56:09 <fuzan> so it either deadlocks or blows up.
14:57:17 <shapr> I still don't think it should segfault.
14:57:27 <fuzan> it's ghc, though.
14:57:27 <shapr> How large is your program source?
14:57:32 <fuzan> so i'm figuring some runtime is broken.
14:57:36 <fuzan> just invoking ghci/ghc breaks.
14:57:41 <shapr> oh
14:57:51 <shapr> Are you using a binary package?
14:57:59 <fuzan> yup.
14:58:05 <fuzan> right now, at least.
14:58:06 <shapr> For which os/flavor?
14:58:28 <fuzan> archlinux, ghc6.6
14:59:02 <shapr> Can you check the binary against the package md5 sums?
14:59:12 <fuzan> it's been working. do you think it was corrupted?
15:00:00 <shapr> That would be my first guess.
15:00:15 <fuzan> i'll just remerge it.
15:00:20 <shapr> If ghc was working, and then suddenly started segfaulting, I'd suggest you check your partitions.
15:00:24 <shapr> Er, filesystems
15:00:42 <shapr> Because the problem might be corruption in one of the libs that ghc uses.
15:00:48 <fuzan> err, that did fix it.
15:00:54 <fuzan> no idea how it would have occured though.
15:01:10 <shapr> I'd recommend that you test your filesystems, and if you do find problems, check your ram as well.
15:01:42 <gwern> maybe reboot and use memtest86. distros usually install that along with grub, right?
15:02:23 <shapr> The debian memtest package can put that into grub, I haven't tried it on any other distros.
15:02:29 <fuzan> heh, i frankly don't care much about the stability of this system. I'm just being lazy and tunneling X to prevent os-switching too much.
15:02:45 <fuzan> i should just work in my stable linux environ :(
15:02:57 <shapr> I did find a bad stick of ram last time I had disk corruption.
15:12:25 <stepcut> shapr: me too
15:13:44 <sorear> @messages
15:13:44 <lambdabot> kc5tja said 3h 16m 54s ago: I will no longer be returning to #Haskell. It's evident that all my discussions are "pointless." This is a pity. The Haskell community is supposed to be better than this.
15:14:04 <opqdonut> :o
15:17:24 <Apocalisp> haha
15:17:50 <Apocalisp> #haskell humor is awesome.
15:18:32 <Binkley> I think that wasn't intentionally humorous
15:23:17 <Apocalisp> Unintentional functional puns are even better.
15:23:43 <Binkley> the pun being "pointless"?
15:23:49 <fuzan> ugh. my haskell battle.net bot is so unstable :D
15:23:56 <Philippa> yeah, I think someone's upset - and hasn't learned that usually when someone in here says 'pointless' about a technical issue and doesn't mean 'point-free', it's because there's an entire space of possible valid answers
15:25:07 <Philippa> * may or may not be a free variable depending on the language you're working in...
15:25:23 <Binkley> yeah, it doesn't seem important to me what you call it so long as you're consistent about your terminology
15:25:41 <Philippa> well, you get arguments about whether it's okay to call something a combinator next
15:25:57 <Philippa> and in practice that's a word that gets used pretty loosely in haskell
15:25:58 <Binkley> I thought it was well-defined what a combinator was?
15:26:20 <Philippa> depends how you think top-level bindings should be resolved
15:26:42 <fuzan> what is a general method to avoid polling with lightweight haskell threads? i'm having no problem with blocking, but i am having problems with deadlocks if packet order differs.
15:28:02 <sorear> Binkley: Yes, it's very well defined.  However nobody ever uses the word correctly :)
15:28:19 <Binkley> is it not just an expression with no free variables?
15:28:30 <Binkley> (and if anyone doesn't like my definition I'm picking up my toys and going home ;-)
15:28:41 <bos> fuzan: avoid polling? you mean you have to read from two different sockets in a specific order?
15:28:59 * sorear says something insensitive to Binkley
15:29:06 * Binkley is butthurt
15:30:53 <sorear> hello JohnMeacham, how's jhc?  I notice a lot of activity!
15:32:05 <JohnMeacham> indeed. it should pass a whole lot more of the shootout now.
15:32:20 <JohnMeacham> in particular, floating point now works for the most part.
15:32:40 <sorear> @seen dons
15:32:40 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 7h 26m 31s ago.
15:32:44 <fuzan> bos: well, i've got a thread that reads from a socket and populates a buffer (MVar). I also have threads that interact with this buffer. at certain times, I NEED specific packets, and i have to wait for them. at other times, I don't. for the other times, i'd like to have a more event-driven approach such that when i receive a specific packet, i do something.
15:33:17 <fuzan> bos: and i'm still trying to keep a lot of the functionality to the main thread running in my monad
15:33:53 <JohnMeacham> I decided to go through the list, and just try every one in order, and fix whatever bugs in jhc it exposed. I had to resist the urge to rewrite the code to work around the bug, and I regretably had to disable quite a few buggy optimizations, but it is a big push to make sure everything compiles and runs for now.
15:34:04 <ddarius> When/how do you know whether you need a packet or not?
15:34:04 <fuzan> bos: there's the "throwTo", function, but I'm afraid to try using it and have it not work :S
15:34:16 <JohnMeacham> then I can go back and debug the optimizations I had to disable afterwords, regression testing the whole time.
15:34:38 <sorear> JohnMeacham: Is it still at least faster than GHC?
15:34:58 <fuzan> ddarius: i have a logon sequence where hte order of packets are somewhat sane. i cannot progress authentication without a specific packet (S0x50, for example).
15:35:00 <bos> fuzan: sounds complicated.
15:35:02 <JohnMeacham> it is pretty random. some a lot faster, some a lot slower.
15:35:27 <fuzan> ddarius: past login, chat events, ping, etc. could occur in any order, and i want a more efficient solution other than polling.
15:35:28 <ndm> JohnMeacham, did you see my 47% faster than GHC result on one benchmark?
15:35:38 <JohnMeacham> but, there is no reason the optiminizations can't be turned back on after the current 'stability phase' is over. I just got tired of all those red boxes on the shootout. :)
15:36:02 <ndm> JohnMeacham, I'd be curious how JHC did on that particular one - see if my Yhc stuff is as good as yours, or not, or better
15:36:43 <Philippa> did you ever get any evidence of SM eating his keyboard, btw?
15:36:44 <sorear> JohnMeacham: Has there been any work yet on optimizing jhc proper?
15:36:50 <fuzan> not to mention i keep getting annoying buffer overflows polling in a monad
15:37:15 <JohnMeacham> ndm: no, a big issue is jhc doesn't do list fusion yet (but it does have RULES, so it isn't far off) so when that hits for ghc it can make it much faster.
15:37:16 <ndm> Philippa, he didn't technicallyl have to eat his keyboard, it wasn't in the original nofib suite
15:37:43 <ndm> JohnMeacham, mine is a lot more than just list fusion, its holistic mega-fusion
15:37:52 <ddarius> fuzan: Maybe look at Chans, but I have to go.
15:38:01 <ndm> you  can't do my mega-fusion with RULES, they aren't powerful enough
15:38:19 <ndm> (despite being turing complete)
15:38:33 <sorear> ndm: The example in the original GRIN paper was mega-fusion for free.
15:38:48 <JohnMeacham> sorear: occasionally, nothing major, but I will profile occasionally and fix bottlenecks. mainly it is high level algorithms, like, the simplifier makes more passes than it needs to for instance.
15:39:21 <sorear> ndm: I don't know if Jhc.grin is as powerful as Boquist's grin though
15:39:44 <JohnMeacham> sorear: I pay attention to speen when writing the lower level passes, so it shouldn't be too hard to speed up. and separate compilation will be a huge win in that regard, which is getting closer and closer. a lot of my back end work is to support that.
15:39:52 <ndm> sorear, i haven't read GRIN enough, mine is incredibly powerful for fusion
15:39:56 <sorear> @all-dicts speen
15:39:57 <lambdabot> No match for "speen".
15:40:04 <ndm> optimal, I think
15:40:30 <sorear> JohnMeacham: Am I correct in considering the possibility of "Jhc bootstrapping" completely implausible?
15:40:45 <fuzan> ddarius: i'll take a look; thanks.
15:40:46 <sorear> JohnMeacham: As in within a month or so, in the context of the ML post
15:41:05 <JohnMeacham> ndm: jhc has RULES and CATALYSTS, which are like rules but only fire if they enable a rule proper. it gets rid of most of the need for phasing on INLINE and RULES pragmas. in any case, this all happens at the jhc core not GRIN.
15:41:38 <JohnMeacham> jhc core is roughly equivalant to ghc core, as in system F. though, there are a few differences.
15:41:39 <ndm> I have no inlining in the core optimisation phase, which means i have no need for things that rely on inlining
15:43:07 <JohnMeacham> like, ghc uses type equality constraints for things like associated types and GADTS, while jhc does explicit case scrutinization of types in core. types have kind !, meaning they arn't lazy but are boxed, so the scrutinizations just disapper before code generation so there is no cost, but it simplifies my core a lot.
15:44:02 <ndm> i have untyped Core
15:44:16 <ndm> which means i have no unboxing stuff etc
15:44:17 <JohnMeacham> ndm: ah.
15:44:35 <ndm> makes my stuff very simple
15:45:01 <JohnMeacham> ndm: I wish I had unboxed types and tuples from the start, they make things a lot easier and I could have avoided a lot of work in the beginning.
15:45:41 <JohnMeacham> I have to retain types, as the types are eventually what allow efficient compilation to assembly eventually.
15:47:03 <mux> @check \x y z -> x > 0 && y > 0 && z > 0 ==> ((x :: Int) + (y :: Int)) `mod` (z :: Int) == x `mod` z + y `mod` z
15:47:04 <lambdabot>  Falsifiable, after 3 tests: 1, 1, 2
15:47:19 <ndm> ah, that will be interesting
15:47:39 <ndm> i suspect JHC may wish to pick up my Core optimisation stuff after i've finished it
15:47:47 <ndm> should mesh well with the rest of your stuff
15:47:58 <nominolo> dcoutts__: yes, I figured out what I need to do in order to use, e.g., cairo within gtkgl
15:48:19 <nominolo> dcoutts__: i believe it won't work with the current interface, though
15:48:29 <JohnMeacham> ndm: yeah, jhc was designed to be 'runtimeless' and it succeeds pretty well. almost all code that ends up in the final executable originates in haskell. making very small binaries.
15:48:39 <mux> @check \x y z -> x > 0 && y > 0 && z > 0 ==> ((x :: Int) + (y :: Int)) `mod` (z :: Int) == (x `mod` z) + (y `mod` z)
15:48:40 <lambdabot>  Falsifiable, after 5 tests: 2, 1, 3
15:49:41 <ndm> that is one thing that attracts me :)
15:49:41 <mux> oh, it gives the values in the reverse order
15:49:57 <JohnMeacham> like: http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/data/jhc_rts2.c is roughly it, and most of that compiles to NOPs when debugging is off.
15:49:59 <lambdabot> Title: darcs - jhc, http://tinyurl.com/2zml3q
15:49:59 <ndm> my optimisatinos are all Core, would work in a typed Core, but work fine in an untyped one, and are pretty fast
15:50:05 <mauke> mux: no, actually
15:50:06 <nominolo> mux: why, do you think that?
15:50:24 <nominolo> you have to `mod` z at the end
15:50:24 <JohnMeacham> ndm: sure. I incorperate stuff from pretty much everywhere.
15:52:04 <sorear> JohnMeacham: Why does jhc use so much memory?
15:52:28 <Philippa> ndm: are you doing anything that warrants leaving Core untyped beyond a case of cba now?
15:52:42 <JohnMeacham> sorear: space leaks probably.
15:52:42 <sorear> JohnMeacham: you said earlier that the sloth was due to excessive iterations, but that wouldn't explain space use
15:52:59 <JohnMeacham> well, if the iterations were leaking it would :)
15:53:37 <ndm> Philippa, no - my translations are all well typed now - some would be easier in a typed language
15:53:42 <JohnMeacham> If someone wants to modify IntSet to be an IntBag, that would help me out. basically, I want an IntMap specialized for Map Int Int, where the Int at the end is strict and unboxed.
15:53:46 <sorear> You have a GC.  Is this laziness type space leaks?
15:53:50 <greenrd> @pl ((.) . (.)) fst id
15:53:50 <lambdabot> (fst .)
15:54:18 <JohnMeacham> sorear: oh, do you mean why does the compiler take up so much memory? or the programs it generates?
15:54:52 <sorear> JohnMeacham: The compiler.  My hard drive isn't fast enough to actually compile anything bigger than hello world.
15:54:59 <sorear> JohnMeacham: Yes, hard drive :(
15:55:19 <Philippa> ndm: I might be a little hypocritical there though, as my own project's currently entirely untyped :-)
15:55:45 <JohnMeacham> sorear: yikes. yeah, I need to work on that at some point. once seperate compilation works, it should no longer be an issue.
15:55:51 <sorear> Philippa: is CBA a euphemism for laziness?
15:56:19 <sorear> JohnMeacham: Sounds interesting - I love data structures.  What do you need this for?
15:58:17 <sorear> JohnMeacham: Isn't whole program the *point* of jhc?
15:58:58 <Philippa> sorear: "can't be arsed". And I cba to find a "Call By ..." expansion that works :-)
15:59:05 <Philippa> oh, wait - "Call By Apathy"
16:00:27 <cdsmith> GHC/PrimopWrappers.hs:615:24:
16:00:27 <cdsmith>     Not in scope: `GHC.Prim.getStackFrame#'
16:00:40 <cdsmith> :(
16:01:32 <Igloo> cdsmith: What are you trying to do?
16:01:43 <drigz> @source Data.List
16:01:43 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:01:56 <cdsmith> Get a working, relatively recent GHC to work against when I change it.
16:02:36 <Igloo> cdsmith: So you're just building a HEAD with no local changes?
16:02:40 <cdsmith> Yeah
16:03:15 <Igloo> cdsmith: Hmm, it ought to Just Work at the moment
16:03:56 <cdsmith> Well, I'm trying again after reverting a change I did make; but I don't see how they'd be related.
16:05:02 <Binkley> famous last words
16:05:34 <sorear> JohnMeacham: I volunteer - Sounds interesting - I love data structures.  What do you need this for?
16:05:42 <Saizan_> if i pull now head should compile?
16:05:48 <cdsmith> Binkley: Yes, perhaps.
16:06:28 <stepcut> sorear: did you ever get around to doing that btree stuff ? (or am I misremembering what you were doing?)
16:06:36 <sorear> stepcut: No, and no.
16:08:08 <JohnMeacham> sorear: my 'Stats.hs'.
16:08:43 <Igloo> Saizan: AFAICT, yes
16:08:50 <JohnMeacham> which collects the staisticts from each pass, it should be called 'IntBag' actually, since a bag is a set that can contain multiple copies of each element.
16:08:54 <stepcut> sorear: ok, I think it will be a long time before by data set is that big anyway
16:09:07 <JohnMeacham> IntMap is signifigantly faster than plain Map I have found.
16:09:37 <JohnMeacham> sorear: I think a big part of space wastage is all these lazy additions building up since the values arn't forced until they are printed.
16:10:05 <sorear> JohnMeacham: What are you tracking?  It seems like statistics should be Map Measurement Int
16:11:34 <JohnMeacham> sorear: yes. but my measurements are encoded as Int's for speed. so I can use IntMap instead of Map. 'IntBag' would have the same interface as IntSet but keep a counter at the end. it might be easier to start with IntMap than IntSet though,
16:12:23 <JohnMeacham> sorear: I suppose both the Set and Map operations make sense on it.
16:12:46 <JohnMeacham> just going through IntMap and replacing the 'a' by !Int everywhere should do it acutally.
16:13:40 <sorear> JohnMeacham: Ah, cool.  So { RuleFired, RuleFired, CaseOfCase } kind of thing?
16:13:54 <JohnMeacham> yup.
16:14:22 <sorear> JohnMeacham: Actually I have a better data structure for dense functional maps that I've been sitting on for a while.  I'll have to implement and benchmark it
16:15:02 <JohnMeacham> sorear: If you know you have Int's I don't think you can do better than radix trees.
16:20:09 <sorear> JohnMeacham: Certainly.  But for certain types of data PATRICIA is a pessimization
16:21:19 <Vulpyne> This might seem like a dumb question, but I don't understand why my guards are generating a conflicting definitions error. Source and exact error at http://hpaste.org/1893
16:21:35 <Vulpyne> (Coord is (Int,Int), Bounds is (Coord,Coord).
16:21:59 <sorear> JohnMeacham: Why not just use IOUArray Int Int ?
16:22:19 <sorear> (or have you so far managed to keep your compiler pure)
16:22:24 <Binkley> Vulpyne: that's because your guards aren't mutually exclusive
16:22:33 <mauke> Vulpyne: remove the 'fixx's
16:22:40 <Binkley> or...
16:22:42 <Binkley> never mind, ignore me
16:23:00 <Binkley> mauke is right
16:23:00 <mauke> or, hmm
16:23:23 <Vulpyne> Well, the function is supposed to fix both X and Y coordinates (basically wrapping out of bounds values, that will be off by 1.)
16:23:49 <Vulpyne> So it has to return both values transformed.
16:24:07 <shapr> hiya Vulpyne, long time no see!
16:24:13 <Vulpyne> Hey, shapr!
16:24:16 <Vulpyne> How goes it?
16:24:42 <shapr> Life is busy, do you still have that job in the desert?
16:24:46 <Vulpyne> I've been trying to amuse myself (and learn some Haskell) by writing a simple implementation of Conway's Life.
16:24:57 <Vulpyne> Actually, no. I'm in Colorado now.
16:25:03 <Vulpyne> Working for a VOIP company.
16:25:08 <shapr> spiffy, which one?
16:25:14 <Vulpyne> TelIAX. Have you heard of it?
16:26:12 <shapr> I think so. I'm using voicepules at the moment.
16:26:17 <shapr> voicepulse*
16:26:24 <Vulpyne> *nod*
16:26:54 <shapr> Does TelIAX offer better prices for calling Sweden?
16:27:21 <Vulpyne> I'm not sure, but I think you can see the international rates at http://www.teliax.com
16:27:23 <lambdabot> Title: VOIP, voice over ip, telephony, SIP, IAX, asterisk []
16:27:59 <Vulpyne> I'm just a programmer, so I don't know a whole lot about the rates, but from I understand, the rates are a little more expensive than average but the quality is above average. :)
16:31:45 <kolmodin> ?tell dons what happens to lambdabot on ping timeouts? she has been gone for two hours now
16:31:45 <lambdabot> Consider it noted.
16:35:20 <Vulpyne> I don't really understand why http://hpaste.org/1894 compiles but http://hpaste.org/1893 does not.
16:35:38 <Vulpyne> Oh.
16:35:41 <Vulpyne> Duh.
16:39:28 <cdsmith> Drat!  Reverting didn't fix the error.  There really is an error in GHC HEAD
16:50:59 <Igloo> cdsmith: Are you fully up-to-date? What platform are you on?
16:53:50 <davidL> is it feasible to use Floyd-Warshall's algorithm on a graph consisting of aproximately 500,000 nodes?
16:54:58 <sorear> @google Floyd Warshall
16:55:01 <lambdabot> http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm
16:55:01 <lambdabot> Title: Floyd-Warshall algorithm - Wikipedia, the free encyclopedia
16:55:13 <byorgey> Looks like it's O(V^3)
16:55:27 <davidL> yeah
16:55:28 <byorgey> so, um... maybe?
16:55:34 <sorear> Just get a parallell computer
16:55:43 <byorgey> depends on the constant factor, and what computer you're running on
16:56:02 <davidL> most edges are of weight zero
16:56:43 <sorear> davidL: How much infomation do you want out?
16:56:47 <byorgey> I don't think that helps particularly
16:56:48 <davidL> 98.75% are weight zero to be exact
16:57:14 <davidL> sorear: sum of shortest path
16:58:11 <sorear> davidL: sum [ s_path_len x y | x <- graph , y <- graph ] ?
16:59:42 <davidL> ?index s_path_len
16:59:43 <lambdabot> bzzt
16:59:56 <sorear> davidL: pseudo code
17:00:02 <sorear> davidL: to clarify :)
17:00:07 <davidL> oh, well in that case yes
17:02:13 <byorgey> davidL: maybe this would work:
17:02:30 <byorgey> davidL: start by removing nonzero edges, then compute all the connected components
17:02:31 <davidL> I have FW algo implemented, I just can't think of how the array of the graph would look like
17:02:58 <byorgey> davidL: then you can "collapse" each such connected component (with all zero edges) to a single "node"
17:03:08 <byorgey> davidL: then run FW on the resulting graph
17:03:22 <sorear> davidL: Is there any more structure to this graph, or is it just a random sparse graph?
17:03:52 <byorgey> sorear: he didn't say it's sparse, just that most of the edges have weight 0
17:03:55 <davidL> it's very structured, I can try to draw a simplified image
17:05:04 <sorear> davidL: And how accurate does the answer need to be?
17:05:14 <davidL> exact
17:05:33 <davidL> I think I'm going about this the very wrong way actually
17:05:37 <Pastorn> xchat is trying to trick me...
17:06:07 <sorear> davidL: I think you have a virtual terrain, and you're trying to find the average distance between two arbitrary points.
17:06:28 <davidL> sorear: It's actually much simpler, hold on I will show you
17:07:31 <davidL> the graph is only 6400 nodes, does this mean the adjacency matrix is 6400^2?
17:08:08 <sorear> Yes.
17:08:23 <sorear> So why did you say 500,000 earlier?  Change of problem?
17:08:31 <davidL> I was mistaken
17:09:06 <sorear> so each node has exactly 80 neighbors.  Say more, say more!
17:09:21 <davidL> yes exactly
17:10:05 <sorear> is this projecteuler?
17:10:17 <davidL> and each nodes has exactly two edges, one to the node below it, and one to the node to the right
17:10:25 <davidL> yeah :P
17:10:57 <davidL> problem81
17:11:52 <byorgey> davidL: oh!  hehe
17:12:06 <byorgey> there are better ways to solve that one than FW =)
17:12:13 <sorear> MUCH MUCH better!
17:12:21 <davidL> dijsktra?
17:12:27 <sorear> for instance since you have no cycles at all, DP
17:12:38 <sorear> yes, even dijsktra would be MUCH better
17:12:44 <byorgey> I don't recall exactly, I'm not sure I used any graph algorithms at all
17:12:45 <davidL> DP?
17:12:50 <sorear> Dynamic Programming
17:12:58 <byorgey> yes, exactly
17:12:59 <cdsmith> Igloo: if you're still there, I'm on Linux and yes, I just did a darcs pull.
17:13:02 <davidL> I implemented FW using DP
17:13:19 <byorgey> well, have fun, I'm off to a jazz club =)
17:13:33 <davidL> cya and thanks
17:14:15 <davidL> I thought implementing dijsktra in haskell would be difficult due to immutability
17:16:05 <sorear> Haskell has monomutability, which is rather different from immutability.
17:16:23 <sorear> You can create circular structures, for instance.
17:27:12 <shapr> Is Yi really in hackage?
17:27:23 <shapr> oh, yi-gtk, duh
17:29:15 <pjd> monomutability?
17:30:30 <sorear> You can only set things once.
17:31:22 <pjd> sorear: but not any way that differs from immutability, innit?
17:32:33 <pjd> AFAIUI, circular structures are done with indirect reference
17:33:31 <pjd> not akin to something like Java's final (which sounds more like monomutation to me)
17:33:56 <pjd> or am i confused?
17:45:14 <stepcut> I downloaded the essential hugs tarball, http://cvs.haskell.org/Hugs/downloads/2006-09/hugs98-Sep2006.tar.gz, extracted it, ran ./configure && make && make install, but when I run hugs it says:
17:45:15 <stepcut> Prelude not found on current path: ".:{Home}/lib/hugs/packages/*:/usr/local/lib/hugs/packages/*"
17:45:16 <lambdabot> http://tinyurl.com/25kcky
17:45:29 <stepcut> did I do something wrong?
18:07:08 <Binkley> @yow
18:07:09 <lambdabot> if it GLISTENS, gobble it!!
18:09:59 <Binkley> @quote
18:09:59 <lambdabot> goltrpoat says: Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
18:20:30 <davidL> noob monader here...I'm attempting to do: ((!!)(r j) . (!!)(c j)) `liftM` nums  --where nums is of type IO [[Int]], yet I get the error that the expected type is IO Int (what's wrong?)
18:21:18 <Binkley> can you paste the full error message?
18:22:27 <hpaste>  davidL pasted "monad help" at http://hpaste.org/1895
18:22:33 <davidL> ^^
18:22:50 <kpreid> what is the type of r j?
18:22:59 <davidL> Int
18:23:15 <kpreid> is it supposed to be an index?
18:23:17 <kpreid> (!!)(r j) makes r j the *first* argument of !!, the array
18:23:19 <kpreid> (you want (!! r j)
18:23:20 <kpreid> er, the list
18:23:27 <kpreid> (this has nothing to do with monads)
18:23:56 <davidL> r j is an index
18:24:24 <davidL> I want (r j) to be the first argument of (!!)
18:24:34 <kpreid> @type !
18:24:37 <kpreid> @type (!!)
18:24:43 <lambdabot> parse error on input `!'
18:24:45 <lambdabot> forall a. [a] -> Int -> a
18:24:58 <kpreid> !!'s first argument is the list, and second is the index.
18:25:21 <davidL> how do I do that with liftM?
18:25:31 <kpreid> liftM is irrelevant
18:25:38 <davidL> do I need to use a lambda abstraction?
18:25:44 <kpreid> I said, use (!! r j)
18:25:55 <davidL> but r is not a list
18:26:00 <kpreid> righ!
18:26:00 <davidL> nums is a list
18:26:02 <kpreid> it's the index!
18:26:08 <kpreid> the second argument of !! is the index
18:26:10 <kpreid> ((!! r j) . (!! c j)) `liftM` nums
18:26:52 <davidL> r x = ceiling(x/sqrt(n))
18:27:31 <davidL> wouldnt (!! r j) just attempt to parse r as a list?
18:27:35 <kpreid> no
18:27:38 <kpreid> it's a section
18:27:56 <davidL> that is odd
18:28:15 <kpreid> (!! r j) is the same as \x -> x !! r j
18:28:16 <kpreid> > ("abc" ++) "def"
18:28:17 <lambdabot>  "abcdef"
18:28:20 <kpreid> > (++ "abc") "def"
18:28:21 <lambdabot>  "defabc"
18:28:58 <kpreid> whenever you have an infix operator adjacent to parentheses, that's a section
18:29:30 <kpreid> well, except for (++) which is just how you write the name non-infix
18:29:55 <davidL> that works, thanks
18:29:57 <kpreid> so your (!!)(r j) applies r j to !!; the *first* parameter of !!
18:31:18 <kpreid> > ((+ 1) . (10 /)) 2
18:31:20 <lambdabot>  6.0
18:35:20 <Jmax> does anyne know where to get a recent package for openbsd?
18:35:51 <davidL> dons might
18:36:26 <Jmax> the obvious (google, changing the Makefile, etc.) didn't work
18:37:00 <davidL> which package?
18:37:18 <Jmax> ghc-6.6.1; sorry, I should have been more clear
18:37:21 <dons> Jmax: for ghc?
18:37:29 <Jmax> yes
18:37:54 <dons> Jmax: we don't have a package yet, kill@ is working on it, however ghc builds out of the box on openbsd, so grab the ghc 6.2.2 package from ports, and use that to build ghc 6.6.1 from src from haskell.org/ghc
18:38:18 <dons> $ uname -ms
18:38:18 <dons> OpenBSD i386
18:38:18 <dons> $ ghc --version
18:38:18 <dons> The Glorious Glasgow Haskell Compilation System, version 6.6
18:38:19 <dons> :-)
18:39:05 <Jmax> dons: ok, thanks
18:39:06 <dons> yeah, the port is rather complex, as it attempts to bootstrap from C files.
18:39:13 <davidL> :( freebsd ports only has ghc 6.6
18:39:14 <dons> so simply changing the version number doesn't work.
18:39:39 <davidL> ...slow maintainers
18:39:52 <dons> busy maintainers :-)
18:41:34 <davidL> is bootstrapping 6.6.1 is much different from bootstrapping 6.6?
18:42:39 <dons> nope.
18:42:51 <dons> just takes time.
18:43:09 <davidL> to change a version number? :P
18:43:17 <dons> no. more work than that.
18:43:24 <dons> you need to regenerate a custom bootsrap compiler.
18:43:40 <dons> ports for compilers are significantly harder to keep going than normal applicatoins
18:43:46 <dons> since they have bootstrap problems.
18:44:06 <davidL> doesn't haskell.org create the bootstrap compiler?
18:44:27 <dons> so usually, for each update, you have to either regenerate a C src for the compiler, which might require build system changes, and is a lot of manual work, or you haveto create a custom bootstrap binary for your OS/arch combinaatoin. more work.
18:44:59 <dons> no, since it can't hope to cover the 10 OS, 20 archs, we attempt to run on.
18:45:14 <dons> binaries are available for linux x86 and windows.
18:45:21 <davidL> well simon marlow is the fbsd maintainer for ghc
18:45:29 <dons> not actively.
18:45:43 <dons> i'm not sure he still uses freebsd.
18:46:04 <dons> and while I still use openbsd, i don't have time to do the .hc bootstrap bundles for the 4 archs we want to support.
18:46:12 <davidL> http://www.haskell.org/ghc/dist/6.6/FreeBSD/
18:46:13 <lambdabot> Title: Index of /ghc/dist/6.6/FreeBSD
18:46:18 <davidL> bootstrap^^
18:46:23 <dons> maintaining compiler ports is hard.
18:46:34 <Binkley> ...let's go shopping!
18:46:38 <dons> and its harder on the bsds, since we have to bootstrap from src.
18:47:02 <dons> rather than just build a single binary. we need scriptable bootstrapping of ghc for arbitrary users. i'm not sure even gcc tries to do that ... :-)
18:47:15 <dons> davidL: right, that's the bootstrap binary. its a custom ghc build
18:47:42 <dons> you need one of those per OS/arch pair.
18:48:03 <davidL> ah yes, that explains ONLY_FOR_ARCHS=	i386
18:48:16 <dons> the alternative is to distribute a C src bundle, as we do on openbsd. but that's more work to prepare, imo. however, it does mean you get full src builds, without downloading binary blobs
18:49:05 <davidL> the whole Makefile is a mess, it should just use 6.2 to compile
18:49:49 <dons> how can it use 6.2?
18:50:16 <dons> you could depend on building an old version of the compiler first, but that lengthens the build chain.
18:50:55 <dons> also, you miss out on new optimisations, if you build with a very old compiler.
18:59:26 <shapr> Is gtk installable from hackage?
19:00:41 <shapr> Foo, libghc6-gtk-dev isn't a high enough version for Yi 0.2
19:01:51 <shapr> @where gtk
19:01:51 <lambdabot> I know nothing about gtk.
19:01:53 <shapr> @where gtk2
19:01:53 <lambdabot> I know nothing about gtk2.
19:02:04 <shapr> I want a subname search!
19:02:10 <shapr> @where gtkhs
19:02:10 <lambdabot> I know nothing about gtkhs.
19:02:14 * shapr kicks lambdabot 
19:03:06 <shapr> @where gtk2hs
19:03:06 <lambdabot> http://haskell.org/gtk2hs/
19:03:08 <shapr> ahh
19:03:14 <shapr> @where+ gtk http://haskell.org/gtk2hs/
19:03:15 <lambdabot> Done.
19:04:57 <dons> ah yes, the where file got zapped. hmm
19:06:13 <sorear> dons: serves you right for using a binary format :P
19:07:51 <dons> why, its in darcs? darcs revert isn't terribly difficult..
19:08:53 <atp> hey folks.  is there a monad equivalent of concatMap lurking around anywhere?
19:08:57 <sorear> join
19:09:08 <sorear> erm, (=<<)
19:09:13 <sorear> @type (=<<)
19:09:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:09:33 <sorear> dons: If a text file gets hit by a cosmic ray, one line is corrupted.
19:09:56 <sorear> imagine m = []  and you have concatMap
19:09:58 <sioraiocht> @src (=<<)
19:09:58 <lambdabot> f =<< x = x >>= f
19:10:05 <sioraiocht> thought so...
19:10:10 <dons> ?src (>>=)
19:10:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:10:17 <dons> ?src Monad
19:10:18 <lambdabot> class  Monad m  where
19:10:18 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:10:18 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:10:18 <lambdabot>     return      :: a -> m a
19:10:18 <lambdabot>     fail        :: String -> m a
19:10:24 <dons> ?src [] (>>=)
19:10:25 <lambdabot> m >>= k     = foldr ((++) . k) [] m
19:10:29 <dons> ?src concatMAp
19:10:29 <lambdabot> Source not found. Wrong!  You cheating scum!
19:10:32 <dons> ?src concatMap
19:10:32 <lambdabot> concatMap f = foldr ((++) . f) []
19:12:37 <skew> hi dons
19:12:57 <sioraiocht> ?src Maybe (>>=)
19:12:58 <lambdabot> (Just x) >>= k      = k x
19:12:58 <lambdabot> Nothing  >>= _      = Nothing
19:15:05 <sioraiocht> ?src IO (>>=)
19:15:05 <lambdabot> m >>= k     = bindIO m k
19:15:18 <sioraiocht> @type bindIO
19:15:20 <lambdabot> Not in scope: `bindIO'
19:18:51 <sorear> JohnMeacham: Are you aware of the GHC Trac?
20:10:55 <dons> ?users
20:10:55 <lambdabot> Maximum users seen in #haskell: 340, currently: 282 (82.9%), active: 25 (8.9%)
20:11:02 <dons> oh, 340 is a new high score. nice.
20:12:01 <sorear> dons: When will the fusion team be done with nobench?
20:14:04 <dons> the results got wiped by accident. i'll rerun them during the week, i suppose.
20:14:11 <dons> after a jhc rebuild.
20:14:26 <dons> ( i accidentally redirected the fusion results to the wrong file)
20:14:54 <dons> i'd imagine in the longer term i'll just update the results every few months.
20:15:03 <dons> or on demand,
20:16:18 <sorear> How much space do the nobench results take?
20:16:50 <sorear> I'm wondering if it would make sense to do a cron.weekly pull build and run, with indefinite historical results
20:18:23 <dons> space, not much.
20:18:30 <dons> its just a matter of writing infrastructure
20:23:37 --- topic: '["The Haskell programming language: Summon Iron Coder FUNCTIONAL!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
20:23:37 --- topic: set by dons on [Sun May 06 05:17:44 2007]
20:23:37 --- names: list (clog pejo nothingmuch mux ski__ znephf nelhage SimonRC klemm Lunchy petekaz kaol qz kenn savanni shachaf Nafai tessier SamB allbery_b arguile Codex_ QtPlatypus jql phoniq yosemite quicksilver araujo Lemmih dcoutts osfameron fnordus giraph gds jewel_ Mitar dany2k nnunley sieni psnl Eidolos mightybyte kpk ibid scw koala_man Spark TwigEther opqdonut cameron greenrd Tychom Japsu dino- profmakx kosmikus Si arcatan sjanssen lollicide Lunar^)
20:23:37 --- names: list (ulfdoz tarantoga mathrick olsner LoganCapaldo Vulpyne Heffalump cods Wallbraker ozone saccade robreim TSC ramkrsna Kattana Korollary liyang shoffsta lucca mornfall DRMacIver edwinb ray TomMD cmeme bd_ Nanar eno Philippa moconnor Syzygy- desp helmut cjay Shurique dvekravy MyCatVerbs Pegazuz ksandstr excellentjelly flux tuukkah pitecus joao dcoutts_ newsham emu jbalint magagr dons glguy fean felipe earthy kalven norpan JKnecht david48)
20:23:37 --- names: list (xerox bryanl _frederik_ eyck encryptio ari Igloo reverendP zamez Shimei vegai Maddas matthew_- goban kolmodin thorkilnaur xinming andun dinounix matthew-_ largos_ lispy NichardRixon agoode lambdabot erider tessier_ bdash mlh jmlin falconair drbean tsp wolverian rhythm flimbo jethrotcs wilx taruti_ dgriffi3_ raxas nich_ ariks thedward dylan jcreigh GNU\caust1c sabakas1 balodja noj Tigge toxic orbitz fxr pixel IvdSangen cdsmith elasticdog)
20:23:37 --- names: list (Hirvinen rashakil integral shapr astrolabe Eelis Apocalisp Vq^ rey_ tapi seancorfield fridim atsampson mbishop lokadin gkr tizoc slipstream-- Averell nornagon siti mattam gleb ozo mr_ank Plareplane levitation[A] sad0ur fons kpreid Shoragan decaf Cf meester geezusfreeek michaelr dcoutts__ Muad_Dib stef_ dblog Xgc alexj Baughn thetallguy benny ilyat ski jbauman_ Khisanth kilimanjaro sheepsy sioraiocht pjd qwr sisi Metabol dufflebunk GeoBesh)
20:23:37 --- names: list (dfranke eddyp_ Binkley stepcut yango mauke fuzan Saizan sorear PaulAJ sek JohnMeacham davidL tmoertel_ genneth prb SamB_XP Pastorn pragma_ koffein mwc nominolo sometwo Uz_ reitblatt mr_tenor johnnowak c Jmax nostrademons atp Jessehk jtoy kombinator ddarius skew Rebecca @ChanServ Laney)
20:26:18 <Weremanatee> Haskell books put a lot of emphasis on proving programs. Do haskell programmers do that in practice to any extent?
20:27:33 <ddarius> Yes for various values of "prove".  Though most don't, I would say.  However, most use libraries that have that approach applied to them.
20:28:06 <dons> Weremanatee: semi-formal methods are usually used, related to proof techniques. some automated provers for particular properties are also used.
20:28:26 <Binkley> I'd imagine the most common proof technique in practice is "it typechecks, so it works" :-)
20:28:40 <dons> for some commerical and research scenarios, proofs are indeed produced, (e.g. L4 /Haskell kernel, or various galois.com products)
20:28:42 <ddarius> I was about to say, you can get a lot of "proof power" out of the type system alon.
20:29:01 <dons> and QC is a semi-formal method too.
20:29:04 <ddarius> And (ab)using the type system in this manner is pretty common.
20:29:26 <ddarius> QC was one of the values of "prove" I was thinking of.
20:29:35 <Weremanatee> What is QC?
20:29:36 <dons> Weremanatee: so the general idea of reasoning about programs in terms of proofs is pervasive.
20:29:42 <ddarius> @where quickcheck
20:29:42 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
20:29:51 <Korollary> QC is about disproving of course, but it's got inductive stuff.
20:30:13 <ddarius> Other program transformation results get used every day silently by the compiler, e.g. fusion.
20:30:29 <dons> also though, the process of stating QC properties is similar to stating properties to prove.
20:30:54 <Korollary> You could also prove elsewhere and generate correspondig haskell code. Coq and Isabelle can do it.
20:31:00 <dons> in general QC generators are used to test for the same properties you'd try to prove, if theorem proving was cheaper.
20:31:16 <dons> yes, that's another (high-end) technique used.
20:31:17 <ddarius> And now we have Catch.
20:32:18 <ddarius> A lot of the "proving" or "transforming" programs stuff happens unconsciously and just kind of falls out from Haskell being pure.
20:32:28 <dons> on an unrelated topic, i just read a lovely definition of why pure FP is so nice. its because this holds:    e1 -> v1,   e2 -> v2  ==>  (e1,e2) -> (v1,v2).
20:32:38 <dons> that's it. compositionality.
20:32:51 <sorear> @check let prime p = all (\b -> p `mod` b /= 0) [2..p-1] in \num -> all (\b -> b^num `mod` b == b) (filter prime [2..b-1]) ==> prime b
20:32:52 <lambdabot>   Not in scope: `b'
20:33:09 <sorear> @check let prime p = all (\b -> p `mod` b /= 0) [2..p-1] in \num -> all (\b -> b^num `mod` b == b) (filter prime [2..num-1]) ==> prime num
20:33:09 <lambdabot>  Add a type signature
20:33:19 <sorear> @check let prime p = all (\b -> p `mod` b /= 0) [2..p-1] in \num -> all (\b -> b^(num::Int) `mod` b == b) (filter prime [2..num-1]) ==> prime num
20:33:20 <lambdabot>  OK, passed 500 tests.
20:33:22 <dons> ddarius: yeah, equational reasoning as used in refactoring is related to proof techniques.
20:33:41 <ddarius> @where HaRe
20:33:41 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
20:33:47 <sorear> that is the converse of Fermat's Little Theorem
20:34:07 <sorear> known to be FALSE, but only for a set of values so sparse QC can't find any
20:34:13 <sorear> (Carmichael numbers)
20:34:25 <Weremanatee> Refunctoring
20:35:04 <dons> yes, random walks are a testing technique that needs to be used wisely, sorear .
20:35:34 <dons> sorear: oh, what does scheck say there? (similar, i'd imgine -- the Int generators are roughly equivalent)
20:35:35 <Weremanatee> It all sounds a lot more rigorous than test-based development in the imperative world.
20:35:38 <sorear> QC is a silver bullet, not a magic bullet :)
20:35:54 <dons> Weremanatee: the basic level of testing is 1 level up from test-based dev, yes.
20:36:10 <dons> typically, in a haskell project, you'd use QuickCheck to generalise particular tests to universal properties.
20:36:28 <dons> so its midway between a simple unit testing approach, and a proper formal treatment of a particular property of the code.
20:36:28 <Korollary> I use QC for regular unit testing, too.
20:36:49 <dons> yes, it subsumes unit testing by abstractive over a set of variables in the test.
20:36:50 <Weremanatee> that's very nice.
20:36:59 <sorear> > let num = 561 ; prime p = all (\b -> p `mod` b /= 0) [2..p-1] in (all (\b -> b^(num::Int) `mod` b == b) (filter prime [2..num-1]), prime num) -- let's first make sure I typed it right
20:37:00 <lambdabot>  (False,False)
20:37:09 <dons> f [1,2,3] == g [1,2,3] -- unit test
20:37:11 <sorear> Apparently not ;)
20:37:16 <dons> forall x . f x == g x -- QC property.
20:38:08 <ddarius> Universally quantified properties and individual test cases are complementary, though, handily QC can do both.
20:38:25 <sorear> > let num = 561 ; prime p = all (\b -> p `mod` b /= 0) [2..p-1] in (all (\b -> b^(num::Int) `mod` num == b) [2..num-1], prime num) -- checking again
20:38:27 <dons> yes, individual test cases are just nullary QC properties.
20:38:27 <lambdabot>  (False,False)
20:38:50 <dons> as usual in FP. 1. abstract 2. profit ;-)
20:39:09 <igli> hi dons haven't been around; did someone kick lambdabot from #friendly-coders ? (they're all afk) if so, sorry
20:39:10 <lambdabot> igli: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:39:17 <sorear> > let num = 561 ; prime p = all (\b -> p `mod` b /= 0) [2..p-1] in (all (\b -> b^(num::Int) `mod` num == b) [2..num-1], prime num) -- checking again
20:39:18 <lambdabot>  (False,False)
20:39:19 <ddarius> There are still reasons to have individual test cases that are putatively covered by a "universal" property.
20:39:37 <sorear> igli: No, we're too lazy to implement persistent configuration for lambdabot.
20:39:43 --- mode: ChanServ set +o dons
20:39:46 --- topic: set to '["The Haskell programming language: Because e1 -> v1 && e2 -> v2 => (e1,e2) -> (v1,v2) !","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:39:48 <sorear> igli: You have to join after every restart
20:39:59 <igli> ok
20:40:01 <sorear> igli: (or add a join to the rc file)
20:40:08 <dons> igli: oh, i didn't add it to the rc file. oops.
20:40:10 <igli> huh?
20:40:12 --- mode: ChanServ set -o dons
20:40:14 <igli> np
20:40:19 <igli> dons: don't yet
20:40:24 <dons> ok.
20:40:28 <dons> do you want it to rejoin?
20:40:37 <sorear> dons: I don't understand the notation in the topic
20:40:51 <ddarius> Presumably -> is a big step reduction
20:40:59 <igli> I do, but the others won't have it with the url transl (msg in lambdabot)
20:41:01 <dons> right.
20:41:04 <Korollary> Presumably people reading that understand it.
20:41:11 <sorear> Korollary: Not I
20:41:17 <dons> sorear: -> is the big step evaluation.
20:41:19 <igli> <lambdabot> uberpinguin said 15h 1m 5s ago: Turn off that link translation please, or I will be forced to /kick lambabot square in the soft parts. # :D
20:41:31 <dons> so some expression e1 -> v1. means expression e1 reduces to value v1.
20:41:41 <Korollary> e1, e2 are lambda exprs and -> is big step reduction to normal forms v1, v2.
20:41:52 <dons> in pure fp, if e1 -> v1, and e2 -> v2, then we also get for free, (e1,e2) -> (v1,v2)
20:42:24 <dons> evaluatoin may occur in any order, or in parallel, and we thus get compositionality of FP code for free.
20:42:32 <dons> random code fragments don't mess with each other :-)
20:42:35 <sorear> igli: you can just use @url-off  (not sure if it's global though)
20:42:40 <dons> igli: hmm. ok.
20:42:44 <igli> ah ty
20:42:44 <ddarius> sorear: Big step operational semantics <=> denotational semantics  e -> v <=> [[e]] = v
20:42:51 <dons> the url translation isn't locally disable-able.
20:42:55 <igli> ah ok
20:43:15 <igli> nm - that was the msg i sent
20:43:16 <dons> sorear: make sense?
20:43:26 <igli> er what i meant anyhow
20:43:51 <sorear> Yes.
20:44:24 * igli downloads source
20:44:32 <dons> its really the foundation for why haskell is interesting :-)
20:45:00 <ddarius> No, the implicit universal quantifier in it is.
20:45:10 <dons> ah ha. yes. :-)
20:45:18 <Korollary> But, I think people who don't value purity in any shape or form are likely to be convinced of the merits of (e1, e2).
20:45:25 <Korollary> err "not likely"
20:45:54 <dons> Korollary: quite possibly. its just a nice concise statement of the argument ,though.
20:45:56 <ddarius> Korollary: That's far from surprising as I'm not sure the Haskell community did so much at first.
20:46:44 <cdsmith> @paste
20:46:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:46:50 --- mode: ChanServ set +o dons
20:46:53 --- topic: set to '["The Haskell programming language: because forall e1 e2. e1 -> v1 && e2 -> v2 => (e1,e2) -> (v1,v2)","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
20:47:38 --- mode: ChanServ set -o dons
20:49:15 <cdsmith> Any ideas on http://hpaste.org/1896?
20:49:36 <Korollary> buffering?
20:49:57 <cdsmith> Umm, let me try that.
20:50:40 <cdsmith> Aha!
20:50:45 <cdsmith> Korollary++
21:44:39 <shapr> Has anyone else tried "cabal-install install yi-gtk" ? I get a 404
21:52:12 <JohnMeacham> sorear: yeah, but it needs to be pure, as in, I take advantage of the persistance of the data structures. also, my keys arn't necesarily compact.
21:52:30 <sorear> "compact" ?
21:52:36 <atp> @src foldl
21:52:37 <lambdabot> foldl f z xs = lgo z xs
21:52:37 <lambdabot>     where lgo z []     =  z
21:52:37 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
21:52:48 <atp> @src foldM
21:52:48 <lambdabot> foldM _ a []     = return a
21:52:49 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
21:53:00 <JohnMeacham> sorear: yeah, perhaps something ilke that can be set up for jhc. I alreday have a mailing list. jhc@haskell.org
21:53:37 <sorear> JohnMeacham: "that" ?
21:53:40 <JohnMeacham> sorear: as in, they could be sparse.
21:53:50 <JohnMeacham> sorear: ghc's trac.
21:54:13 <JohnMeacham> sorear: sorry, just got home from work and am reading the history and catching up.
21:55:20 <sorear> JohnMeacham: You sent a bugreport to glasgow-haskell-users@, that's why I mentioned trac.
21:55:55 <JohnMeacham> sorear: ah. I see.
22:03:33 <Weremanatee> Hah. HSOE has as its first proving exercise, a property that is provably false about the program.
22:03:55 <Weremanatee> Only works by induction, because of lost precision.
22:07:00 <Weremanatee> An example of a program that can't be reliably tested to work, only proven.
22:09:14 <sorear> (addressing everyone) Do you think you understand Haskell IO?
22:09:34 <sorear> @pretty let { foo :: IO [Char] ; foo = getLine } in do x <- foo ; y <- foo ; return (x,y)
22:09:34 <lambdabot>  i = let
22:09:34 <lambdabot>          foo :: IO [Char]
22:09:34 <lambdabot>          foo = getLine
22:09:34 <lambdabot>        in
22:09:34 <lambdabot>        do x <- foo
22:09:36 <lambdabot>           y <- foo
22:09:38 <lambdabot>           return (x, y)
22:10:00 <sorear> Without trying it, how many lines does i read?
22:10:19 <dgriffi3_> 1?
22:10:22 <int-e> none ;)
22:10:27 <dgriffi3_> 42?
22:10:47 <sorear> int-e: OK, let's bind i to main then :)
22:11:19 <davidL> what would a bind of that sort look like?
22:11:33 <Weremanatee> does it not read two lines?
22:11:34 <int-e> it should read 2 of course.
22:11:37 <sorear> main = i >> return ()
22:12:11 <sorear> It should read two lines.  But the popular analogies lead people to believe it will read one
22:12:23 <bos> they do?
22:12:29 <Weremanatee> huh?
22:12:33 * atp looks confused.
22:12:42 * Weremanatee looks at atp confused
22:12:45 * bos sneaks a look inside sorear's cough medicine bottle
22:13:00 <int-e> people when new to haskell tend to think of IO actions as their resulting values. Or rather they tend to confuse the two.
22:13:03 <sorear> bos: dgriffi3_ and davidL, at least
22:13:39 <davidL> I said 1 :(
22:13:41 <int-e> (which I guess is partly to blame on using the  do  notation)
22:13:52 <Weremanatee> sorear has been drinking too much SyQuiL
22:13:54 <atp> i really don't understand how you could see 1 in that code?
22:14:27 <int-e> atp: I guess  let x = getLine  and  x <- getLine  look like they should do similar things. :/
22:15:00 <Weremanatee> ah!
22:15:02 <atp> oh, i see, because people think foo = getLine ?
22:15:02 <Weremanatee> no
22:15:30 <atp> calls getLine just once, instead of just defining a local function that takes no arguments and returns IO String ?
22:15:45 * atp scratches his head.
22:15:45 <Weremanatee> wait... foo = getLine (how to emphasise the equals sign?)
22:15:53 <int-e> davidL: the  let  in the  do  notation doesn't execute any IO (monadic actually - this is true for any monad) actions. Only  <-  does.
22:15:56 <sorear> Weremanatee: You were right all along - I'm just trying to disect davidL's thought process
22:16:07 <sorear> @spell disect
22:16:13 <atp> dissect
22:16:14 <int-e> dissect
22:16:16 <atp> not disect
22:16:32 <Weremanatee> is davidL a programmer?
22:16:33 <atp> (it's pronounced dis-sect, too, not dai-sect, despite what some may think)
22:16:45 <davidL> not a good one :P
22:16:52 <Weremanatee> an imperative one?
22:16:58 <davidL> yeah :(
22:16:59 <atp> i guess if you have an imperative background his thinking makes sense
22:17:05 <Weremanatee> that's yer problem right there.
22:17:17 <shapr> My imperative background?
22:17:18 * sorear has a 8-year imperative background
22:17:32 <Weremanatee> davidL: you're looking at let x = y as: take the result of y and assign it to the variable x.
22:17:39 <atp> i'm sure most of us do, but some of us aren't exactly beginners anymore
22:17:45 <int-e> sorear: did you learn do notation first or >>= and >>?
22:17:45 * atp coughs shapr, sorear.
22:18:10 <sorear> int-e: I don't recall.
22:18:19 * Weremanatee has an imperative background and is just learning haskell
22:18:19 <atp> i think >>= is more intuitive
22:18:33 <atp> Weremanatee: me too :)
22:18:41 <Weremanatee> \o/
22:18:48 <davidL> Weremanatee: I don't think it's that. I'm just having a difficult time understanding monads
22:18:48 <fuzan> i'm actually reading thorugh simon's paper on "oddities", i think it is a MUST read for more-advanced beginners
22:18:53 <int-e> at least >>= makes it clearer that something 'weird' is happening.
22:19:07 <atp> davidL: avoid the do notation until you understand them, i think that's best
22:19:16 <sorear> It's not weird at all.  it's just call by name, a la alog
22:19:18 <sorear> *algol
22:19:24 <atp> davidL: also, check out sigfpe's blog, it's got some great explanations.
22:19:36 <fuzan> http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/marktoberdorf.ps.gz
22:19:38 <lambdabot> http://tinyurl.com/2ckvha
22:19:49 <davidL> take a look at this for example: http://hpaste.org/1895#a1
22:20:00 <Weremanatee> davidL: It's not the monads. foo = getLine means: foo is the function getLine.
22:20:25 <atp> yeah, haskell has no destructive update... assignment doesn't do what it does in C
22:20:38 <fuzan> > let wtf = even in wtf 2
22:20:40 <lambdabot>  True
22:20:59 <davidL> how can I use data from an IO monad in a guard?
22:21:07 <davidL> (referring to the paste)
22:21:16 <Weremanatee> you're not even in the monad at that point (where you thought it was reading the line)
22:21:22 <int-e> davidL: I think you should make nums an argument to foo instead of clobbering foo with IO actions
22:22:37 <int-e> davidL: but if you want to go that route, foo i j will have type  Int -> Int -> IO Int -- and you need to use  return  for returning 0 or 10000.
22:23:01 <davidL> int-e: I figured that was the worst case and that I would be doing something wrong
22:23:10 <int-e> davidL: where 'that' route is the version you pasted.
22:23:27 <davidL> as soon as I use IO, it seems, I'm stuck in IO until the end
22:24:43 <Weremanatee> sorear,  I believe the thinking is "getLine means get the line, now". I.e. give the machine instructions to carry out, rather than thinking of functions as values.
22:25:11 <int-e> you can write: foo nums i j = ... nums !! c i !! r j ...; then in main do:  do nums' <- nums; and use  foo nums'  instead of foo.
22:25:30 <int-e> davidL: that way you'll avoid having to do IO in foo.
22:26:10 <int-e> davidL: and foo becomes more flexible at the same time. (it could be used for other matrices as well)
22:26:16 <davidL> ?ty (<-)
22:26:18 <lambdabot> parse error on input `<-'
22:26:34 <davidL> so I can use <- to extract data from a monad?
22:26:36 <int-e> <- is part of the syntax.
22:27:02 <dons> e.g.  do c <- getChar ; putChar (toUpper c)
22:27:10 <int-e> davidL: x <- y  binds  x to the result of y, at the time it is executed.
22:27:11 <dons> ?unpl do c <- getChar ; putChar (toUpper c)
22:27:11 <lambdabot> do { c <- getChar; putChar (toUpper c)}
22:27:23 <int-e> ?undo do c <- getChar ; putChar (toUpper c)
22:27:23 <lambdabot> getChar >>= \ c -> putChar (toUpper c)
22:27:24 <dons> ?undo do c <- getChar ; putChar (toUpper c)
22:27:25 <lambdabot> getChar >>= \ c -> putChar (toUpper c)
22:27:30 <dons> yes, just syntax for bind.
22:27:50 <atp> davidL: you're really going to want to understand >>= syntax i think, it makes things much easier to understand
22:27:52 <dons> which glues together small IO actions into larger ones, naming intermediate values.
22:28:06 <int-e> @type (>>=)
22:28:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:28:12 <dons> yes, its been suggested that understanding io code in terms of >>= is the best way forward.
22:28:39 <dons> ?undo do putChar 'x' ; putChar 'y'
22:28:39 <lambdabot> putChar 'x' >> putChar 'y'
22:29:10 <dons> that is, two seeminly sequential statements (in an imperative language) correspond to   f >> y, which is f >>= \_ -> y
22:29:24 <dons> (where we throw away the result of f)
22:29:47 <atp> davidL: check out http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
22:29:50 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
22:29:55 <atp> davidL: it helped me a lot
22:30:06 <davidL> thanks atp
22:30:22 <dons> >>= is basically a programmable semi-colon, its behaviour is programmable depending on which monad you're in, giving you different effects. (hmm, maybe i'm jumping too far ahead?)
22:30:46 <fuzan> :t (>>=)
22:30:47 <atp> davidL: then, what i did, is i worked through the little IO examples in yet another haskell tutorial and converted all the do blocks to >>= to make sure i understood what was happening
22:30:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:31:27 <fuzan> :t return
22:31:29 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:31:46 <fuzan> :t (>>= return)
22:31:46 <dons> atp, that is excellent advice.
22:31:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
22:32:02 <fuzan> davidL: stare at that relation till it makes sense :D
22:32:10 <dons> yes, manually rewriting small do blocks in >>= is a good way to understand how the sequencing is introduced, and how binding of results is achieved.
22:32:32 <atp> there are only 4 rules so you don't need to do it much to grok it
22:32:44 <atp> working through 4 or 5 examples is probably enough
22:36:27 <int-e> @undo do let x = getLine in a <- x; b <- x; return (a,b)
22:36:27 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 25}) "Parse error"
22:36:37 <int-e> @undo do let { x = getLine }; a <- x; b <- x; return (a,b)
22:36:37 <lambdabot> let { x = getLine} in x >>= \ a -> x >>= \ b -> return (a, b)
22:37:01 <dons> amazingly, before do notation, we used to write our monadic code manually this way :-)
22:37:14 <atp> we still have to if we're writing comonadic code :(
22:38:21 <dons> a small example from (current!) ghc,
22:38:22 <dons> corePrepBind env (NonRec bndr rhs)
22:38:23 <dons>   = etaExpandRhs bndr rhs               `thenUs` \ rhs1 ->
22:38:23 <dons>     corePrepExprFloat env rhs1              `thenUs` \ (floats, rhs2) ->
22:38:24 <dons>     cloneBndr env bndr                  `thenUs` \ (_, bndr') ->
22:38:27 <dons> :-)
22:38:33 <atp> hehe
22:38:35 <dons> so you really really make clear the sequencing.
22:38:46 <dons> yeah, comonad are second class citizens. boo hoo :/ !
22:38:56 <dons> we don't even have a canonical Control.Comonad lib.
22:39:14 <atp> yeah, it's kind of a pain.  but then, comonads aren't quite as useful as monads (yet)
22:39:28 <atp> smarter people than i are still figuring out ways to use them
22:39:39 <dons> right, given a lower barrier to entry, we'll more likely find useful uses.
22:39:44 <dons> i'd put zippers in a similar category.
22:39:51 <dons> if we had a derivable zipper tool, we'd have more zippers.
22:40:05 <atp> i was looking at that paper on zippers but all the examples were in o'caml, which i unfortunately don't speak
22:40:20 <dons> or even Data.Zipper for the standard types, list, stack, tree, and so on.
22:40:28 <atp> has anyone written anything haskell-y for zipper?
22:40:37 <dons> hmm. mondic zippers anyone? allowing arbitrary traversal of a computation.
22:40:39 <dons> scary.
22:41:00 <dons> atp, yeah, the 'The Web' (Hinze,Jeuring), and Oleg's Zipper OS.
22:41:13 <dons> there's also a truly excellent zipper page on the haskell wikibook
22:41:15 <atp> one of the things that's pretty cool about haskell is how quickly you end up reading current research
22:41:19 <dons> and , of course, xmonad uses a zipper
22:41:36 <atp> hm, let me check those out
22:41:46 <atp> i'm still a beginner, i've only been coding haskell for about two weeks now
22:42:00 <dons> hehe. its a gateway drug into PL research :-)
22:42:10 <dons> http://en.wikibooks.org/wiki/Haskell/Zippers
22:42:11 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
22:42:18 <atp> yeah, i don't think i've read so many journal articles since i was at uni
22:42:20 <dons> and the generalised zipper, http://www.informatik.uni-bonn.de/~ralf/publications/TheWeb.ps.gz
22:42:26 <atp> thanks dons
22:42:30 <dons> oleg's zipper filesystem, http://okmij.org/ftp/Computation/Continuations.html#zipper
22:42:31 <lambdabot> Title: Continuations and delimited control
22:43:58 <dons> yeah, haskell is kind satisfying for those into PL research, the gap between theory and production code is probably the smallest of any language community
22:44:04 <stepcut> Am I missing something, or does HaXml not support this operation cleanly ? -> http://hpaste.org/1897
22:46:53 <sorear> dons: I think it would be absolutely trivial to add zipper support to derive, if you were so inclined
22:47:45 <dons> i'm not sure its trivial, but we know how to derive the representation for regular types.
22:56:07 <int-e> naming the constructors of the context seems to pose a challenge.
22:56:58 <atp> whoa, this differentiation of datatypes stuff is deep
23:02:11 <bitwiseshiftleft> hey all, i have a silly fundeps question
23:02:41 <bitwiseshiftleft> suppose i have a class with no methods, which serves only to aggregate types
23:02:45 <bitwiseshiftleft> class Bar a b | a -> b
23:02:49 <bitwiseshiftleft> or rather, to associate types
23:03:07 <bitwiseshiftleft> and i want this so as to put it into a GADT:
23:03:09 <bitwiseshiftleft> data Food a where Food :: Bar a b => b -> Food a
23:03:26 <bitwiseshiftleft> but then when I try to write the reverse function
23:03:30 <bitwiseshiftleft> eat :: Bar a b => Food a -> b
23:03:31 <bitwiseshiftleft> eat (Food b) = b
23:03:42 <bitwiseshiftleft> ... I get an error:
23:03:54 <bitwiseshiftleft> couldn't match expected type 'b' against 'b1' ...
23:04:04 <bitwiseshiftleft> any idea why?
23:04:25 <fuzan> bitwiseshiftleft: i'm delving into existential types too. i think the only way to do that (that I know of) is to derive from Typeable
23:04:25 <dons> hmm.
23:04:31 <Weremanatee> is there a function like a fold that returns intermediate values? So that  foo (+) [1,2,3,4] = [1+2,2+3,3+4]  ?
23:04:32 <dons> hmm.
23:04:35 <int-e> that sounds awfully familiar
23:04:36 <dons> fuzan: scary.
23:04:43 <int-e> anyway, there's a good reason why the compiler can't do this.
23:04:44 <fuzan> dons: am i horribly wrong?
23:04:45 <sorear> Weremanatee: scanl
23:04:46 <dons> Weremanatee: scanl/scanr
23:04:50 <Weremanatee> yay!
23:04:54 <dons> :t scanl
23:04:56 <Weremanatee> Thank you
23:04:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
23:05:02 <dons> > scanl (+) 0 [1..]
23:05:04 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
23:05:12 <dons> > last $ scanl (+) 0 [1..10]
23:05:13 <lambdabot>  55
23:05:18 <dons> > foldl (+) 0 [1..10]
23:05:19 <int-e> the problem is that despite the functional dependencies, you can define conflicting instances for Bar - in separate modules, and use them simultaneously in a program.
23:05:20 <lambdabot>  55
23:05:30 <byorgey> I don't think scanl is exactly what Weremanatee is looking for
23:05:44 <bitwiseshiftleft> int-e: oh hm... i thought fundeps stopped that.  that's unfortunate
23:05:52 <dons> fuzan: it would be nasty if you need Typeable to (work around) unification of existentials. that just avoids the problem :-)
23:05:54 <int-e> thus, in eat :: Bar a b => Food a -> b, the compiler can't prove that the b you put into Food is the same as the one you want to take out, despite the functional dependency.
23:06:13 <dons> byorgey: ah yes, its more a fold
23:06:22 <bitwiseshiftleft> but what do functional dependencies mean then?
23:06:26 <sjanssen> int-e: you can only do that if you allow overlapping instances
23:06:28 <dons> which accumulates the last element and the result, in the state.
23:06:28 <int-e> bitwiseshiftleft: you can work around it with unsafeCoerce, which is relatively save in this context.
23:06:52 <int-e> sjanssen: the compiler will never find out about them I believe.
23:07:06 <fuzan> wouldn't Typeable and cast be safer to use? (and maybe more portable?)
23:07:10 <dons> > foldl (\a (b,rs) -> (b,(a+b):rs)) (0,[]) [1..10]
23:07:11 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
23:07:11 <lambdabot>       Expe...
23:07:14 <int-e> sjanssen: but I have to admit that I didn't really try.
23:07:25 <bitwiseshiftleft> well, it depends on whether the type inside is actually typeable
23:07:34 <bitwiseshiftleft> ... which it isn't, but it's probably Typeable2
23:07:52 <Weremanatee> would I use scanl over scanr for any reason?
23:08:04 <dons> > reverse . snd $ foldl (\(b,rs) a -> (a,(a+b):rs)) (0,[]) [1..10]
23:08:06 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
23:08:10 <dons> :-)
23:08:28 <byorgey> there we go =)
23:08:28 <bitwiseshiftleft> out of curiosity though, what is the point of functional dependencies if they aren't unique?
23:08:29 <atp> it seemed as though Weremanatee just wanted zipWith
23:08:38 <dons> which looks like a mapAccumL too
23:08:41 <dons> :t mapAccumL
23:08:43 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:09:17 <dons> > mapAccumL (\a b -> (b , a+b ) 0 [1..10]
23:09:18 <lambdabot>  Parse error
23:09:24 <atp> > take 5 (zipWith (+) [1 ..] [2 ..])
23:09:25 <lambdabot>  [3,5,7,9,11]
23:09:34 <dons> > mapAccumL (\a b -> (b , a+b )) 0 [1..10]
23:09:36 <lambdabot>  (10,[1,3,5,7,9,11,13,15,17,19])
23:09:44 <atp> or more generally zipWith (+) xs (tail xs)
23:09:48 <dons> ?pl (\a b -> (b , a+b ))
23:09:48 <lambdabot> ap (,) . (+)
23:10:09 <fuzan> i think his example was flawed, and he just wanted scan(l|r)
23:10:11 <fuzan> :)
23:10:23 <dons> i get a prize for using mapAccum* I think.
23:10:31 <atp> you're the man, dons
23:10:34 <atp> heh :)
23:10:35 <dons> most underappreciated list function, after unfoldr.
23:10:36 <bitwiseshiftleft> heh
23:10:39 <byorgey> probably =)
23:10:45 <fuzan> dons: you lost hte prize for erroring on first try, though.
23:10:46 <bitwiseshiftleft> yeah, unfoldr is pretty cool
23:10:51 <dons> > fix ((0:) . scanl (+) 1)
23:10:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:10:57 <dons> its all scanls ;-)
23:11:08 <dons> > unfoldr (\(f1,f2) -> Just (f1,(f2,f1+f2))) (0,1)
23:11:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:11:11 <dons> mwhaha
23:11:19 <atp> haha
23:11:20 <dons> should add a mapAccum version
23:11:41 <atp> haskell is just unreasonably cool
23:11:45 <atp> there ought to be a law
23:11:47 <byorgey> :t fix
23:11:47 <atp> damn kids
23:11:49 <sjanssen> int-e: I just double checked -- it looks like GHC doesn't complain about the overlap until you attempt to use the classes
23:11:49 <lambdabot> forall a. (a -> a) -> a
23:11:52 <sjanssen> int-e: very evil!
23:12:14 <bitwiseshiftleft> sjanssen: yeah, i've noticed that before too
23:12:36 <sjanssen> Hugs, on the other hand, rejects the program immediately
23:12:39 <bitwiseshiftleft> leads to weird error messages... "but it worked before..."
23:13:02 <byorgey> random silly question: is there any function other than id with type a -> a?
23:13:16 <dons> byorgey: we have a theorem prover to find these for us:
23:13:19 <dons> ?djinn a -> a
23:13:20 <lambdabot> f a = a
23:13:27 <dons> (think about error and undefined..)
23:13:28 <Weremanatee> scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:13:39 <dons> ?. pl djinn a -> a
23:13:39 <lambdabot> f = id
23:13:40 <byorgey> ah, cool
23:13:46 <dons> ?. pl djinn a -> a -> (a,a)
23:13:47 <lambdabot> f = flip (,)
23:13:51 <atp> byorgey: not counting constructors, presumably?
23:13:56 <sjanssen> even more stupid: when you include the overlapping instances in the same module, ghc rejects them
23:14:00 <Weremanatee> What I want is :: (a -> a -> b) -> [a] -> [b]
23:14:08 <int-e> sjanssen: http://hpaste.org/1898 is an exam,ple.
23:14:10 <byorgey> atp: right
23:14:24 <atp> Weremanatee: you can't use zipWith ?
23:14:26 <int-e> hmm. no hpaste bot today?
23:14:30 <atp> Weremanatee: what are you actually trying to do?
23:14:35 <bitwiseshiftleft> Weremanatee: [f a a' | a <- as | a' <- tail as]
23:14:40 <Weremanatee> zipwith... limmeluk
23:14:56 <atp> Weremanatee: because your last example was just zipWith (+) xs (tail xs)
23:15:19 <sjanssen> this is why we need associated types
23:15:42 <bitwiseshiftleft> yeah, associated types would be cool for this
23:16:03 <dons> well, anyone got ghc head there they can fire up?
23:16:06 <bitwiseshiftleft> my current problem is, i have these objects that can be updated, and possibly produce a delta which says how it was updated
23:16:17 <bitwiseshiftleft> dons: hm, actually, yes
23:16:28 <Weremanatee> > zipWith (+) [1,2,3] (tail [1,2,3])
23:16:30 <lambdabot>  [3,5]
23:16:38 <Weremanatee> that's it
23:16:41 <Weremanatee> thanks!
23:16:43 <atp> np
23:16:56 <int-e> dons hmm. is 14 days old recent enough?
23:16:57 <atp> (there are lots of other ways to do that, incidentally, hehe)
23:17:05 <Weremanatee> converting vertices to edges
23:17:10 <Weremanatee> haskell is nice!
23:17:28 <bitwiseshiftleft> not all objects produce a delta when updated, but the type of the delta (if it exists) depends on the type of the object
23:17:29 <atp> i don't know much haskell but already i find coding in other languages sort of annoying
23:17:32 <sorear> zi
23:17:34 <bitwiseshiftleft> so is there a nice way to express that?
23:17:34 <sorear> ap
23:17:52 <atp> i like how sigfpe implemented monads in C :)
23:18:01 <byorgey> atp: *sigh*. I know exactly what you mean.
23:18:05 <bitwiseshiftleft> My current try has a class ProducesDelta tr d | tr -> d with no methods, but that doesn't work as you've seen
23:18:15 <Weremanatee> My day job is Java, but by night I am Haskellr the destroyer!
23:18:48 <atp> java ... C# ... so ubiquitous ... so unfulfilling
23:19:04 <byorgey> Weremanatee: mine too.  I sit there writing 20-line methods and I think about how I could write it in one line of Haskell
23:19:04 <Weremanatee> ugh
23:19:23 <Weremanatee> byorgey: Are you writing functor classes yet?
23:19:41 <byorgey> Weremanatee: in Haskell, or Java?
23:19:52 <atp> it's like how spj and co implemented a webserver that implemented all of http 1.1 and then some in 1500 lines of haskell
23:20:07 <atp> hell, i can write 1500 lines of java in an hour
23:20:12 <atp> won't do anything
23:20:16 <int-e> relating to the recent global state thread - how composable are monad transformers really? I'd like to make every module a monad transformer - but what happens if two modules are based on another module and want to share its state?
23:20:17 <atp> but i can do it :)
23:20:18 <byorgey> In Haskell, I've never actually written one myself but I know what the Functor class is
23:20:44 <atp> i've never written just a functor... they're always either monads or comonads
23:20:50 <sorear> I can write 1500 lines of C in a week.  OTOH, it's very functional.
23:20:55 <Weremanatee> In java. I'm starting to write one-method interfaces for every kind of class.
23:21:02 <sorear> atp: different kind of functor
23:21:14 <sorear> atp: ML functor, not categorical functor
23:21:16 <bitwiseshiftleft> java would be so much nicer if interfaces could have methods
23:21:29 <atp> sorear: ah... i was confused :)
23:21:39 <int-e> @remember atp hell, i can write 1500 lines of java in an hour. won't do anything.
23:21:39 <lambdabot> Done.
23:21:40 <pjd> bitwiseshiftleft: then they'd just be classes, though
23:21:58 <bitwiseshiftleft> pjd: classes with multiple inheritance.  or mixins.  or something
23:22:08 <pjd> right
23:22:14 <Weremanatee> For example: Stringbuffers get passed around a LOT, and every time we have to call sb.append(foo) or new StringBuffer(foo).append(sb).append(bar)...
23:22:35 <pjd> you would have to hope for sane MI semantics, though
23:22:39 <int-e> @type mappend
23:22:41 <lambdabot> forall a. (Monoid a) => a -> a -> a
23:22:46 <Weremanatee> ... so I wrote generic StringBufferMutator and StringBufferFunctor interfaces! Haskell is seeping into my Java.
23:23:01 <atp> Weremanatee: it'll be better off for it i bet
23:23:14 <Weremanatee> it's less readable, but hey
23:23:19 <Weremanatee> we had a good laugh about it.
23:23:36 <bitwiseshiftleft> yeah, writing haskell in other languages is usually a bad idea... less readable, idiomatic, and fast
23:24:20 <atp> i heard somewhere that somebody is writing a .NET backend for haskell though, so if you're unlucky enough to work in a C# or VB house you may be able to "quietly" rewrite key parts in haskell
23:24:34 <Weremanatee> muhaha
23:24:45 <atp> "hey?! what the hell is a functor?!"
23:24:48 <bitwiseshiftleft> that would be really neat... i wonder how they integrate the object systems
23:25:10 <atp> no clue :)
23:25:11 <Weremanatee> there's also fortran.Net
23:25:42 <bitwiseshiftleft> and f#.net, aka ocaml.net
23:25:54 <atp> ok guys, i've got to run.  have a good evening or whatever locally appropriate day-period
23:26:03 <bitwiseshiftleft> gnight atp
23:26:07 <atp> night
23:26:12 <byorgey> night
23:27:21 <bitwiseshiftleft> so yeah, any idea on a portable, idiomatic way to say "this value produces a delta of type d when recomputed"?
23:31:05 <Weremanatee> bitwiseshiftleft: explain
23:31:25 <bitwiseshiftleft> so, i'm hacking on a library for reactive programming
23:32:10 <sorear> bitwiseshiftleft: The obvious approach with associated types works.
23:32:11 <bitwiseshiftleft> there's this class Reactor tr t, which means that the type tr represents a reactive t in some way
23:32:11 <int-e> bitwiseshiftleft: it works until you try to put it into an existential type - can you do without that?
23:32:25 <bitwiseshiftleft> int-e: not sure
23:32:48 <int-e> bitwiseshiftleft: i.e. how much would you lose by defining data Food a b = Food a ?
23:33:12 <bitwiseshiftleft> well, the problem is, i need to define callbacks for when a value changes
23:33:30 <bitwiseshiftleft> and some of them need to take a delta as an argument
23:33:46 <bitwiseshiftleft> but not all representations produce deltas
23:33:59 <sorear> bitwiseshiftleft: Can you use ATs?
23:34:27 <bitwiseshiftleft> sorear: possibly; is there documentation somewhere on the implementation of ATs in GHC?
23:35:10 <bitwiseshiftleft> the big problem is that, since not all representations produce a delta, they don't all have an associated type
23:36:38 <bitwiseshiftleft> the other issue is, it would be nice if my code worked in, say, Haskell'
23:36:52 <bitwiseshiftleft> and ATs are "probably no"t going into Haskell'
23:37:09 <dons> right.
23:37:29 <dons> though I suspect we'll see them become more and more mainstream in the coming umm... decade?
23:38:07 <bitwiseshiftleft> well, requiring GHC HEAD to compile might also be problematic
23:38:59 <bitwiseshiftleft> on the other hand, i'm not sure if there's any way to say "whenever you do x to a Y, you'll get a Z out" without ATs, given that the fundeps don't work
23:39:42 <lokadin> how do i convert a number to string?
23:39:49 <bitwiseshiftleft> show
23:39:54 <lokadin> thnks :)
23:41:22 <UUStudent> I'm trying to insert/search into date with state monads.. i have inserts working using runSM initial_state (do {updateSM (stuff); etc...   } ) ..... anybody know how to use readSM if I want to do a lookup?
23:42:32 <UUStudent> *into a data
23:43:13 <int-e> something like  liftM (lookup key) readSM  ?
23:44:08 <UUStudent> inside the do? i'm not sure what lift is, actually. i have readSM, updateSM, and runSM defined
23:44:19 <int-e> or simpler   do table <- readSM; let result = lookup key table
23:45:08 <int-e> If I understand what you're doing correctly. You've left out many details.
23:45:42 <int-e> @type liftM
23:45:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:46:23 <UUStudent> readSM :: SM (Ret Company)      updateSM :: (Ret Company -> Ret Company) -> SM ()       runSM :: Ret Company -> SM a -> (a, Ret Company)
23:46:30 <int-e> liftM takes a pure function and 'lifts' it into the monad - where it takes a monad action and returns the result of applying that function to the result of that action.
23:47:00 <int-e> @src liftM
23:47:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:47:56 <int-e> (you're using do notation so SM must be a monad)
23:51:34 <UUStudent> yes
23:52:44 <UUStudent> so table <- readSMM; findEmpInCompany "Name" table .... would i need to lift table into a monad?  expected type: SM a   inferred type: Ret Employee
23:53:08 <UUStudent> *readSM
23:53:28 <Weremanatee> http://hpaste.org/1900
23:53:56 <Weremanatee> Still having trouble with the cryptic compiler errors
23:56:22 <int-e> UUStudent: I guess you need   return (findEmpInCompany "Name" table) ...
23:58:03 <int-e> UUStudent: maybe you should paste some code and type signatures. (what is the type of findEmpInCompany?)
23:58:25 <int-e> @where paste
23:58:26 <lambdabot> http://hpaste.org/new
23:59:41 <UUStudent> findEmpInCompany2 :: String -> Ret Company -> Ret Employee
23:59:53 <int-e> Weremanatee: what is ((==) signum) supposed to do?
23:59:55 <UUStudent> the last thing you gave type-checked and ran
