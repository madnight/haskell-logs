00:00:28 <ibid> everybody knows that mathematicians are not interested (nor are they able) to calculate with numbers beyond 0, 1 and 2
00:01:02 <ibid> (when i studied to become a mathematician, simple arithmetic errors did not cause us to lose points in exams:)
00:01:19 <Korollary> A unique answer exists to the 4 + 5 problem. It's irrelevant what it is.
00:02:08 <Cale> Let's see, 4 + 5 = SSSS0 + SSSSS0 = S(SSS0 + SSSSS0) = SS(SS0 + SSSSS0) = SSS(S0 + SSSSS0) = SSSS(0 + SSSSS0) = SSSS(SSSSS0) = 9.
00:04:42 <Korollary> where's your proof that 4 = SSSS0?
00:05:03 <Cale> You have to make a notational definition of symbols like 4 somewhere.
00:05:12 <nmessenger> that last step, SSSS(SSSSS0) = 9, strikes me as 'unsavory'.  Real Mathematicians Always Use Peano (tm).
00:05:33 <Cale> well, I'm applying the definition of 9
00:08:07 <mauke> oh noes, it's GEB all over again
00:11:35 <lisppaste2> metaperl pasted "any way for the expression rootDocs srcs to start on the next line " at http://paste.lisp.org/display/33929
00:12:50 <mauke> metaperl: huh? where's the problem?
00:13:35 <metaperl> mauke - I will annotate
00:13:46 <nmessenger> metaperl: you get an error when you move to the next line?
00:14:00 <metaperl> nmessenger - no, I've just never done it
00:14:54 <nmessenger> metaperl: nothing there to enforce a particular indentation.  The whole right-hand-side should be completely free-form.
00:15:19 <lisppaste2> metaperl annotated #33929 with "oh nice, it worked" at http://paste.lisp.org/display/33929#1
00:18:13 <lisppaste2> metaperl pasted "did the type signature force the unit type to containerize in the IO monad here?" at http://paste.lisp.org/display/33930
00:20:22 <dibblego> > '.' > '-'
00:20:23 <lambdabot>  True
00:20:38 <Lemmih> metaperl: containerize?
00:21:06 <metaperl> Lemmih - Monads are containers :) just ask Cale
00:21:24 <Cale> The return is what did that.
00:21:39 <dibblego> > '.' > 'd'
00:21:40 <Cale> (and the fact that you're using do notation)
00:21:41 <lambdabot>  False
00:21:51 <metaperl> in other words, return :: a -> m a   ... but what made return choose IO as m as opposed to any other monad... I'm guessing it's the type signature
00:22:00 <Cale> oh, that would be the runX
00:22:06 <metaperl> no!
00:22:10 <metaperl> oh?
00:22:19 <nmessenger> ?type runX
00:22:21 <lambdabot> Not in scope: `runX'
00:22:21 <metaperl> did the type signature not control that?
00:22:30 <Cale> runX :: IOSArrow XmlTree c -> IO [c]
00:22:52 <Cale> oh, also the explicit type signature of course enforces that
00:23:02 <metaperl> the runX cant do it
00:23:05 <Cale> but the explicit type signature should be the same as the inferred one
00:23:09 <metaperl> IO [c] /= IO ()
00:23:10 <Cale> no, it certainly can
00:23:31 <Cale> runX (...) >> return ()
00:23:33 <metaperl> oh...dont tel
00:23:35 <nmessenger> but if it didn't, the fact that runX returns an IO blah causes the whole do-block to be in IO.
00:23:35 <metaperl> YES!
00:23:41 <metaperl> I knew it before I saw you type it!
00:23:51 <metaperl> yes
00:29:19 <allbery_b> hm
00:29:53 <allbery_b> > ([]) 0 -- yes, this is an error
00:29:54 <lambdabot>      The function `([])' is applied to one arguments,
00:29:54 <lambdabot>     but its type `[a]' ...
00:30:06 <allbery_b> ok, it gives more detail on /msg
00:30:22 * allbery_b got surprised by that yesterday and wondered if he'd found a bug
00:31:30 <opqdonut> > return () :: [Int]
00:31:31 <lambdabot>  Couldn't match `Int' against `()'
00:31:41 <opqdonut> ah
00:31:56 <opqdonut> > fail :: [Int]
00:31:56 <lambdabot>      Expecting a function type, but found `[Int]'
00:31:57 <lambdabot>       Expected type: [Int]
00:31:57 <lambdabot> ...
00:32:10 <opqdonut> > fail 'foo' :: [Int]
00:32:10 <lambdabot>  Improperly terminated character constant
00:32:16 <opqdonut> > fail "foo" :: [Int]
00:32:18 <lambdabot>  []
00:32:21 <opqdonut> :)
00:32:56 <mauke> > fail "fail" :: [fail]
00:32:57 <lambdabot>  Add a type signature
00:33:34 * allbery_b blinks
00:34:25 <do-gooder-77> functional programming
00:34:37 <nmessenger> ...is what we do here
00:34:37 <do-gooder-77> I thought lisp was for functional programming
00:34:57 <allbery_b> lisp is the elder statesman of the family
00:35:00 <mauke> no, lisp isn't very functional
00:35:35 <allbery_b> (FP originated there but it's not its real purpose)
00:36:19 <nmessenger> meh, I make it a rule not to assert 'better' or 'worse' without lots of experience, which I don't have, so no opinion.  I do however find myself liking what I've learned in Haskell.
00:36:54 <dibblego> nmessenger, have you lots of experience buying houses?
00:37:18 * nmessenger reels from the non-sequitur
00:37:29 <nmessenger> What?!
00:37:42 <dibblego> it's just a question
00:37:45 <sieni> nmessenger: http://norvig.com/21-days.html
00:37:46 <lambdabot> Title: Teach Yourself Programming in Ten Years
00:37:55 <nmessenger> not at all, actually
00:38:03 <dibblego> have you ever bought a house?
00:38:21 <nmessenger> No
00:38:38 <dibblego> suppose you did - how would you determine if one house is better than the other?
00:38:46 * johnnowak recently rented an apartment after decided it appeared better than the other candidates 
00:39:30 <nmessenger> I suppose I wouldn't really know unless I had several experiences to compare
00:39:44 <dibblego> but you'd end up buying a house
00:39:48 <allbery_b> presumably you have some experience with your needs and desires
00:40:25 * johnnowak wonders if Haskell is also full of german cockroaches 
00:41:06 <nmessenger> True, I would have  things I'd want, some wise, some foolish, and I'd have to start somewhere in order to gain experience.
00:41:06 <allbery_b> german lambda cockroaches :)
00:41:22 * LoganCapaldo wonders what the property taxes on Haskell are like
00:41:32 <nmessenger> (with house purchasing in particular)
00:42:01 <do-gooder-77> I tried haskell, but as soon as I got to the fold left fold right part of yet another haskell tutorial my brain fried
00:42:15 <do-gooder-77> ghc was simple to install
00:43:42 <johnnowak> do-gooder-77: yaht explicitly says to not worry if you don't fully understand it at that point
00:44:46 <do-gooder-77> heh
00:44:48 <do-gooder-77> oh
00:45:11 <do-gooder-77> see I know only bash and little scheme :) like rank amateur
00:45:12 <nmessenger> Hmm, I had a lot of false starts myself.  I just read a variety of things, having some concepts clear and others fuzzy, but I made the most progress by picking a small toy and *writing* Haskell.
00:45:43 <do-gooder-77> and bash I'm no expert
00:45:48 <LoganCapaldo> I think foldl and foldr are often over-explained.
00:46:13 <opqdonut> yep
00:46:39 <dons> ?src foldl
00:46:39 <lambdabot> Source for this function is not available.
00:46:45 <nmessenger> > foldr (+) 0 (1 : 2 : 3 : 4 : []) == (1 + 2 + 3 + 4 + 0) -- notice that (:) becomes (+) and [], 0.
00:46:46 <dons> ?src foldr
00:46:47 <lambdabot>  True
00:46:47 <lambdabot> Source for this function is not available.
00:46:48 <allbery_b> fold to the left!  fold to the right!  lift up!  map down!  byte!  byte!  byte!
00:46:53 <dons> hmm?
00:47:04 * allbery_b suspects the overexplaining has to do with people blowing out the stack
00:47:13 * allbery_b is insomniac and slightly weird
00:47:20 <opqdonut> :)
00:47:24 <opqdonut> familiar feeling
00:47:33 <opqdonut> i just usually grab a book and read it thru
00:47:36 <nmessenger> allbery_b, awesome!  Did you just now come up with that?
00:47:40 <allbery_b> yeh
00:47:54 <allbery_b> triggered by the "fold left fold right" comment
00:47:59 * allbery_b is free associating
00:48:14 <opqdonut> did herbert's dune series like that
00:48:26 <allbery_b> then left it in the message buffer, then sent the "overexplaining" thing.  whups
00:48:58 <opqdonut> during the days i progressed something like 20p, but then i just decided some sleepless nite "to the hell with it, i'm reading this"
00:49:16 <sieni> allbery_b: somehow that reminded me about Rocky Horror Picture Show :-)
00:49:21 <allbery_b> insomnia's about the only reason I'd read _Dune Messiah_ over again, I'll grant :)
00:49:25 <opqdonut> one book, one night, once a month
00:49:42 <LoganCapaldo> It's just a fold to the left, and then a fold to riiiiight.
00:49:45 <sieni> http://www.rockymusic.org/lyricscat/rocky-horror/#105
00:49:47 <lambdabot> Title: RockyMusic - Rocky Horror Picture Show Song Lyrics
00:49:59 <opqdonut> allbery_b: books 2, 3 and 4 are kinda boring imo
00:50:24 <opqdonut> great books, but as compared to 1 and 5
00:50:43 <allbery_b> I liked 1 and 3.  2 I initially read the first few chapters of, then set it down and read 3, and found I hadn't actually missed much.  4 and on the world could have done without
00:50:58 <opqdonut> i liked chapterhouse
00:51:05 * LoganCapaldo can't skip books
00:51:20 <nmessenger> Some toys that I tend to use to try out new languages: the 'Reverse' game at <http://e-scribe.com/news/193>, a generic tile sliding puzzle thingie, and implementing False <http://wouter.fov120.com/false/>
00:52:05 <opqdonut> oh, chapterhouse is 6
00:52:05 <opqdonut> pardon me
00:52:42 * allbery_b tends to just throw a new language at whatever his current personal or work project is, to see if it sticks
00:53:23 <opqdonut> i was doing a paper on genetic algorithms and stuff and decided to implement it all in haskell
00:53:25 <allbery_b> I kept thinking I'd read most of chapterhouse before, when I hadn't.
00:53:37 <opqdonut> great opportunity to learn the language
00:53:40 <opqdonut> allbery_b: hehe
00:54:02 <opqdonut> but yeah, the original dune is undoubtedly the highpoint of the series
00:54:02 <allbery_b> some new stuff, some stuff that seemed like I'd read it earlier in the series
00:54:05 <opqdonut> a shame really
00:59:29 <do-gooder-77> lynch movie tasty
00:59:31 <do-gooder-77> :)
00:59:42 <do-gooder-77> some weird tv series was sukin
01:01:25 <nmessenger> ?src foldr
01:01:38 <nmessenger> ?src foldr
01:01:39 <dons> hmm. weird.
01:01:51 <dons> something's not quite right
01:02:05 <lambdabot> Source for this function is not available.
01:02:17 <dons> ?src id
01:02:25 <lambdabot> Source for this function is not available.
01:02:28 <opqdonut> :)
01:02:53 <opqdonut> @djinn [a] -> [a]
01:02:54 <lambdabot> f a = a
01:03:08 <opqdonut> @djinn [[a]] -> [a]
01:03:08 <lambdabot> -- f cannot be realized.
01:03:32 <opqdonut> @djinn [(a,b)] -> ([a],[b])
01:03:32 <lambdabot> -- f cannot be realized.
01:03:59 <therp> good morning #haskell!
01:04:23 <nmessenger> Good morning!
01:08:36 <zeeeee> i'm seeking general advice on writing an hscurses application. i spent the past few days going through a lot of material on arrows, functional reactive programming, and UIs in haskell, but i still feel nowhere closer.
01:09:24 <zeeeee> just to use an existing example app in hscurses, say i'm writing a contact manager. i think all my problems relate to immutable state. any change in the state of the UI (eg highlighting the next row in a listbox) will result in the reconstruction of the entire tree of widgets, but i need to replace one single integer value somewhere deep in that tree.
01:10:11 <zeeeee> this isn't about performance - the resulting code is horrendous. (the current version of the contact manager was pretty terrible to force myself to understand.)
01:10:34 <opqdonut> see tuomov's riot
01:10:45 <zeeeee> but on the performance front as well: any change in the state of the data model (the set of contacts, say it's huge) will similarly rebuild everything. how in the world do i write such a simple app?
01:10:51 <opqdonut> a TODO list/note organizer done in haskell
01:10:54 <opqdonut> with a curses ui
01:11:09 <zeeeee> opqdonut: i'll have a look
01:11:34 <opqdonut> http://www.iki.fi/tuomov/riot btw
01:11:38 <lambdabot> Title: Riot
01:11:41 <dons> but the hscurse stuff is just in IO. nothing special there needing arrows or so on
01:11:44 <dons> see also yi or hmp3
01:11:46 <dons> ?where hmp3
01:11:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
01:12:23 <zeeeee> dons: yeah, i have no problems making calls to hscurses. i'm asking about how to design/architect the actual application and frontend code
01:12:37 <zeeeee> (and/or framework/toolkit/widget code)
01:13:50 <dons> i prefer to update a state value, and have a ui thread refresh the curses screen when the updates occur
01:14:04 <dons> so the application just modifies a shared state value
01:14:19 <dons> and the update thread waits on that value, repainting every now and then
01:15:01 <zeeeee> dons: i'll look at your apps in detail, but just to help me out - what exactly do you mean? you're using mvars?
01:15:07 <dons> yeah
01:15:18 <dons> put the state required to update the screen in an MVar
01:15:23 <dons> have the app putMVar on cchanges
01:15:40 <dons> and have the ui thread takeMVar (blocking) , for each refresh
01:15:45 <dons> check hmp3 in particular for this model
01:16:15 <dons> you can use pretty printer-ish combinators for generating the curses strings, which can then be drawn all in one go
01:17:13 <dons> ?bot
01:17:14 <lambdabot> :)
01:17:16 <dons> ?src foldr
01:17:16 <lambdabot> Source for this function is not available.
01:17:19 <dons> bah
01:17:27 <dons> something weird is going on
01:17:59 <zeeeee> dons: does 'state required to update the screen' == the entire 'model'? (list of tracks, current track, etc.)
01:18:19 <zeeeee> dons: and why do you need multiple threads? can't you just block on getch?
01:18:35 <dons> you could probably do it without threads
01:18:49 <dons> i find them convennient though. 1) getchar thread 2) update/refresh thread 3) main thread
01:18:55 <zeeeee> dons: nvm the last question, it's easy to imagine an app that updates its view without user input
01:19:09 <dons> yeah, like hmp3s progress bar
01:19:26 <opqdonut> "Threads are for people who can't program state machines" -Alan Cox
01:19:33 <dons> heh
01:19:42 <opqdonut> :)
01:19:48 <dons> or people with cheap threads in their runtime ;)
01:19:54 <zeeeee> yay CH
01:19:59 <opqdonut> i just avoid threads whenever possible for some reason
01:20:03 <opqdonut> ideological i guess
01:21:48 <dons> get an smp machine ;)
01:22:03 <dons> and all those forkIOs and parMaps suddenly pay off big :)
01:25:58 <dons> ?bot
01:26:25 <lambdabot> :)
01:26:27 <dons> ?src foldr
01:26:45 <lambdabot> foldr k z xs = go xs
01:26:47 <lambdabot>     where go []     = z
01:26:49 <lambdabot>           go (y:ys) = y `k` go ys
01:27:02 <mauke_> ?src (+)
01:27:03 <lambdabot> Source for this function is not available.
01:27:16 <dons> class methods are a bit hard to gather the src for
01:27:22 <dons> ?src const
01:27:23 <lambdabot> const x _ = x
01:27:25 <mauke_> ?src (/=)
01:27:26 <lambdabot> x /= y = not (x == y)
01:27:42 <kaol> ?src id
01:27:42 <lambdabot> id x = x
01:27:50 <zeeeee> dons: i did some benchmarking on CH's performance recently (on a couple different machines) - it seems to splay across all the cpu's but never utilizes them fully, only 'summing up' to 100% of a single cpu (was working on a project to implement simple parallel STM in haskell)
01:28:38 <zeeeee> we couldn't figure out what the problem was; we thought we might've had some app-level synchronization issue, but not as far as we looked
01:28:54 <dons> I've had over 350% on a 4 core box though
01:29:12 <dons> but could be worth a bug report I suppose?
01:29:20 <dons> you had the smp runtime?
01:29:24 <zeeeee> dons: really? are you using ghc 6.6?
01:29:28 <dons> yeah
01:29:54 <zeeeee> dons: i don't remember the details, but i think we did
01:30:21 <dons> i've had really good results with thte 4 or 5 smp programs i've written on the 4 core linux box
01:30:49 <zeeeee> i'll believe that - it's most likely something in our benchmark
01:30:52 <zeeeee> or our method
01:30:57 <dons> could be worth a discussion on haskell-cafe@ if you like
01:31:30 <dons> the DPH array programs seem to scale linearly up to 40 cores (that we've been able to test so far)
01:31:58 <dons> oh, one program that blocked on network IO only made 110% cpu or so
01:32:00 <mauke_> @index many
01:32:00 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
01:32:23 <mauke_> @src Text.ParserCombinators.Parsec.many
01:32:24 <lambdabot> Source for this function is not available.
01:32:26 <kzm> @tell JaffaCake Looks like you pegged the memory bug. I took the liberty of marking the trac entry as 'resolved'.
01:32:27 <lambdabot> Consider it noted.
01:32:36 <dons> ?src unsafePerformIO
01:32:37 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
01:32:39 <dons> :)
01:32:53 <mauke_> ?src lazy
01:32:53 <lambdabot> Source for this function is not available.
01:34:08 <dons> ?src unsafeInterleaveIO
01:34:09 <lambdabot> unsafeInterleaveIO (IO m)
01:34:09 <lambdabot>   = IO ( \ s -> let
01:34:09 <lambdabot> 		   r = case m s of (# _, res #) -> res
01:34:09 <lambdabot> 		in (# s, r #))
01:34:31 <shankys_> I keep on getting the following error and have no idea why ghc would be trying to look for parsec in the Takusen database library folder. Does anyone know why this might happen?
01:34:34 <shankys_> Compilation Error: unable to load package `parsec-2.0'
01:34:42 <do-gooder-77> how hard is ghc to install on linux?
01:34:49 <dons> hmm. shankys_ no parsec installed?
01:34:52 <shankys_> "/usr/local/lib/Takusen-0.6/ghc-6.6/HSTakusen-0.6.o: unknown symbol `_OCIAttrGet'"
01:34:58 <shankys_> that didn't paste right
01:35:04 <shankys_> there we go -- parsec is installed
01:35:06 <dons> do-gooder-77: easy as it gets. grab it from apt or your relevant package system
01:35:16 <dons> do-gooder-77: or grab a binary off haskell.org/ghc
01:35:17 <shankys_> I've successfully used it to do a routing system
01:35:27 <shankys_> for the haskell web framework
01:35:37 <dons> ghc-pkg list parsec says so too?
01:35:54 <shankys_> yeah
01:35:59 <dons> _OCIAttrGet doesn't look like a parsec error though...
01:36:15 <kzm> do-gooder-77, make sure to get at least version 6.4.2.
01:36:43 <kzm> (Although any current distribution should have it now)
01:36:52 <do-gooder-77> heh
01:36:59 <do-gooder-77> Im a crzy fucker
01:37:05 <do-gooder-77> I picked slackware based zenwalk
01:37:09 <shankys_> I'm trying to extend bringert's dyn-cgi to work with Takusen because Takusen needs a few extra options passed to ghci to work correctly, but the GHC API isn't very nice to deal with
01:37:35 <shankys_> I tried an ugly hack of just putting the following on top of files to see if this would work:
01:37:37 <shankys_> {-# OPTIONS_GHC -fglasgow-exts -fth -L/usr/local/pgsql/lib -lpq -i/www/pages/dyn-cgi/takusen #-}
01:38:03 <shankys_> But that gets me from can't find Takusen-0.6 errors to can't find parsec-2.0 errors
01:38:30 <shankys_> I think it's looking for parsec in the takusen folder, but I don't know why its doing that
01:38:39 <kzm> do-gooder-77, if you don't have a ready-built package, the binary snapshots have worked for me in the past.
01:46:37 <zeeeee> what's this strange ~ syntax? i saw it in the Arrows stdlib
01:48:41 <rahikkala> Do you mean lazy patterns? My brain's too fried to know what's actually going on, but that's the place where I've seen the tilde before
01:48:44 <zeeeee> it's here: http://darcs.haskell.org/packages/base/Control/Arrow.hs
01:48:47 <rahikkala> http://haskell.org/tutorial/patterns.html#sect4.4
01:48:47 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
01:49:42 <zeeeee> rahikkala: yeah, i think that's it
01:49:44 <zeeeee> thanks
01:53:58 <drain> does haskell have lisp-like macros?
01:58:27 <Cale> drain: there's an extension called template haskell which implements macros, but they're rarely used.
01:58:38 <_matthew_> ?where jhc
01:58:38 <lambdabot> http://repetae.net/john/computer/jhc/
01:58:43 <Cale> In practice, lazy evaluation gives you most of what macros are good for.
01:58:48 <_matthew_> mmm. how active is jhc?
01:59:10 <drain> macros can be good for a lot in theory, you could completely change the language you are working with using macros
02:00:14 <Cale> Well, if evaluation doesn't happen until something forces it to happen, you can use any data structures you want as programs, and interpret them with ordinary functions.
02:00:27 <anonfunc> drain: do you have experience in common lisp?
02:00:39 <drain> only a little
02:01:07 <Cale> So even though it's happening at runtime as opposed to compile time, the effect is generally the same.
02:07:00 <kzm> Is this 'top' output for real?:  10495 ketil     25   0 50.5g 2.7g 1368 R 99.8 35.1   1:15.21 rbr
02:07:14 <kzm> 50*G* virtual size?
02:07:58 <araujo> good morning
02:11:30 <zeeeee> anybody know what the 'lang' package was/was for? (re: http://www.mail-archive.com/haskell-cafe@haskell.org/msg18808.html)
02:11:32 <lambdabot> Title: [Haskell-cafe] GHC package lang not found, http://tinyurl.com/ykj732
02:42:44 <kzm> zeeeee, don't remember - why?  It's in base now, IIRC.
02:43:16 <timbod> I just read the "beautiful concurrency" draft - and have a question... anyone knowledgeable about STM around?
02:43:59 <dons> yeah, should be a few people
02:44:40 <timbod> Here it is anyway... in the context of lazy evaluation how do you control where the work doing the evaluation is done?
02:46:01 <timbod> When you are using it to allocated work to different threads (ie different cpus in GHC 6.6) It seems that you'd need to litter seq's or deepseq's about the place to make sure that the "workers" actually did the work.
02:52:16 <zeeeee> kzm: just curious, that's all
02:53:03 <zeeeee> is there any way to get hasktags to index functions whose type declarations are omitted? it seems to only index by type declarations...
02:54:52 <earthy> which version hasktags?
02:55:06 <earthy> ghci in version 6.6 will generate tags for you
02:55:18 <dmhouse> ?tell jcreigh I loved your quote in HWN :)
02:55:18 <lambdabot> Consider it noted.
02:55:35 <earthy> zeeee: plus, you do realize hasktags does not generate sorted tags lists?
02:55:38 <zeeeee> earthy: i'm using ghc 6.6
02:55:46 <zeeeee> earthy: yes
02:55:48 <earthy> which is sucky in the case you're using the tags with e.g. vi
02:55:56 <earthy> (it won't find them)
02:58:57 <zeeeee> earthy: do you know if you can generate tags using ghci but straight from the shell?
02:59:39 <earthy> echo ':tags' | ghci -v0 -w
02:59:46 <earthy> or something quite like it
03:00:09 <earthy> oh, add the filename ofcourse. ;)
03:00:53 <zeeeee> earthy: yeah i couldn't find the option to suppress the prompt
03:01:08 <earthy> the -v0 is magic. :)
03:01:29 <earthy> it's what I also use in the haskell ftplugin for vim
03:01:38 <calvins_> what would be an appropriate data structure for the following purposes:
03:02:04 <calvins_> collecting a large number of integers (millions), then printing them in the order they were collected. Nothing else is required.
03:02:20 <calvins_> I used list at first, but then have to reverse it before iterating.
03:02:38 <calvins_> I tried Data.Sequence, but it was actually slower than List, even though I didn't need to reverse.
03:02:42 <calvins_> Any other suggestions?
03:03:14 <opqdonut> circular linked list, i'd say
03:03:19 <zeeeee> earthy: argh, it craps out when it runs into #ifdef's
03:03:28 <opqdonut> dunno how you'd implement one in haskell tho :)
03:03:52 <calvins_> yeah, was hoping for a suitable data structure in the library that I just didn't find.
03:04:31 <calvins_> i was kind of surprised that sequence was slower than list, but it is a much more powerful data structure, so its other benefits apparently don't come for free, surprise surprise..
03:05:12 <dons> it probably doesn't fuse either
03:05:35 <zeeeee> earthy: oh are you the author of the haskell ftplugin?
03:09:51 <benja_> calvins_: how much slower is it?
03:09:57 <benja_> (sequence)
03:11:04 <calvins_> benja_: the list version was something like 0.15 sec (it was generating primes less than a million), and the Data.Sequence version was closer to 0.22, so a significant difference.
03:12:17 <calvins_> the prime code i ripped from the wiki, but modified it to accumulate the primes as they're found, either in a list or sequence...
03:14:03 <benja_> calvins_: I'm not sure you can avoid that sort of hit without using mutable data structures...
03:14:10 <zeeeee> calvins: could you write it as follows, where g&f are your generators? g n = f n : g (succ n); c (x:xs) = show x ++ " " ++ c xs
03:14:20 <zeeeee> calvins_: er that was to you
03:15:07 <norpan> if you're dealing with millions of numbers and know the amount in advance, then you can probably use a more memory efficient data structure, like an array or unboxed array
03:15:23 <calvins_> benja_: yeah, it's not a big deal. that prime generation code is so damned fast that i can afford to reverse the list a hundred times and it'll still faster than what i had before.
03:15:28 <benja_> any snoc data structure is going to have to do some additional work n times, and reverse also does a small amount of work n times
03:15:37 <benja_> calvins_: :)
03:16:03 <calvins_> zeeeee: i don't follow your suggestion, or don't see how i could make use of that in my little program.
03:16:40 * benja_ hadn't thought of it like this before, but 'reverse' is a pretty efficient strategy if you don't want to go to mutable data structures :)
03:17:34 <zeeeee> calvins_: my thinking was to use lazy lists as generators (in the python sense), assuming that your prime producer could be written in that fashion. where's the orig wiki src?
03:17:38 <benja_> calvins_: oh, of course if you know an upper bound on the number of elements you're going to need, using a mutable array (in a monad) would be fastest :)
03:18:04 <benja_> but if the lists work for you, that's probably easier to use :)
03:18:11 <calvins_> zeeeee: here's the original: http://haskell.org/haskellwiki/Shootout/Nsieve
03:18:12 <lambdabot> Title: Shootout/Nsieve - HaskellWiki
03:18:27 <calvins_> zeeeee: I'll paste my slightly altered code in paste
03:18:28 <calvins_> @paste
03:18:29 <lambdabot> http://paste.lisp.org/new/haskell
03:19:15 <lisppaste2> calvins_ pasted "prime numbers less than n" at http://paste.lisp.org/display/33938
03:20:22 <calvins_> benja_: yeah, i took out the reverse just to see the time difference, and can't notice any significant difference between reversing or not.
03:29:02 <zeeeee> i don't understand why the list solution has to undergo reversal; that sounds like you're cons-ing new elements after the recursive call (instead of before).
03:31:24 <calvins_> zeeeee: every time a new prime is found in while sieving, it gets consed onto the accumulator list; thus they end up in descending order.
03:31:41 <calvins_> s/in//
03:35:10 * dmhouse discovered haskell-decl-scan.el yesterday.
03:35:11 <dmhouse> Love it!
03:38:38 <zeeeee> calvins_: why not: findPrimes currentState = if isPrime currentState then currentState : findPrimes (next currentState) else findPrimes (next currentState)
03:40:07 <zeeeee> it sounds like the program is currently: findPrimes currentState list = if isPrime currentState then findPrimes (next currentState) (currentState : list) else findPrimes (next currentState) list
03:40:16 <zeeeee> where the base case returns list instead of []
03:41:29 <zeeeee> dons: what's snoc?
03:42:01 <sieni> zeeeee: opposite of cons
03:42:28 <zeeeee> sieni: thanks
03:52:41 <calvins_> zeeeee: that's a good suggestion, but i'm not comfortable enough with that yucky mutable unboxed array stuff to be able to change it that significantly
03:53:50 <calvins_> i'll play around though and see if i can get that to work, but i have a feeling i'll be back in the type-error hell that i was in earlier when i tried significantly changing that code
04:00:43 <lisppaste2> calvins_ annotated #33938 with "zeeeee's suggestion:" at http://paste.lisp.org/display/33938#1
04:01:23 <lisppaste2> calvins_ annotated #33938 with "primes in correct order" at http://paste.lisp.org/display/33938#2
04:02:19 <calvins_> zeeeee: thanks, changing it like that was not the massive pain that I imagined it would be, and your suggestion does exactly what I wanted. Thanks!
04:02:52 <Botje> @pl \x -> x*x
04:02:53 <lambdabot> join (*)
04:03:31 <ndm> Botje: thanks for the report, it does do some module name searching
04:03:34 <ndm> @hoogle Map
04:03:35 <lambdabot> Data.Map :: module
04:03:35 <lambdabot> Data.Map.Map :: data Map k a
04:03:35 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
04:03:41 <ndm> @hoogle Data.Map
04:03:42 <lambdabot> No matches, try a more general search
04:03:51 <ndm> but the . really confuses it - Hoogle 4 has that fixed
04:04:01 <ndm> you can also search Data.Map.map in Hoogle 4 as well
04:10:45 <calvins_> time for bed, good night all. thanks for the help!
04:16:06 <Botje> norpan: thanks!
04:16:24 <zeeeee> good night :)
04:29:13 <huschi> is there a way to express something like "type NumModifier = Num a => a -> a" in haskell?
04:29:14 <_matthew_> agh, I need an "and" version of mplus
04:29:27 <_matthew_> if mplus is "or", what's "and" ?
04:30:17 <lightstep> mmultiply?
04:30:27 <_matthew_> :t mmultiply
04:30:29 <lambdabot> Not in scope: `mmultiply'
04:30:34 <_matthew_> wish it was!
04:31:37 <_matthew_> or, no, you'd have to have mmultiplyBy
04:32:00 <_matthew_> else how do you combine eg: (Just 4) `mmulitply` (Just 3) ?
04:32:28 <lightstep> :t listM2
04:32:30 <lambdabot> Not in scope: `listM2'
04:32:31 <lightstep> :t liftM2
04:32:33 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:32:49 <_matthew_> ta, that looks good. thanks
04:41:28 <Syzygy-> BWAHAHAHAHAHAHAHA!
04:41:36 <Syzygy-> I LOVE the jcreigh quote in HWN
04:42:25 <_matthew_> ?hoogle forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
04:42:25 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a2'
04:42:39 <_matthew_> ?hoogle (Monad m) => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
04:42:40 <lambdabot> Did you mean: Monad m => (A1 -> A2 -> m r) -> m A1 -> m A2 -> m r
04:42:40 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
04:43:21 <_matthew_> I mean, like liftM2, but the result of the combinator is the monad rather than the value
04:43:37 <_matthew_> ?hoogle Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
04:43:38 <lambdabot> Did you mean: Monad m => (A1 -> A2 -> m r) -> m A1 -> m A2 -> m r
04:43:38 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
04:43:55 <_matthew_> ?hoogle Monad m => (A1 -> A2 -> m r) -> m A1 -> m A2 -> m r
04:43:56 <lambdabot> No matches, try a more general search
04:48:38 <lightstep> _matthew_, you can define it yourself
04:49:07 <_matthew_> err, I know. Someone else just pointed out join $ liftM2 (\x y -> return (x + y)) (Just 1) (Just 2) does what I want
04:49:30 <tora> Someone!?
04:49:37 <_matthew_> sorry honey
04:49:42 <_matthew_> ;)
04:50:09 <Syzygy-> > join $ liftM2 (\x y -> return (x+y)) (Just 1) (Just 2)
04:50:11 <lambdabot>  Just 3
04:52:43 <Syzygy-> _matthew_: Why not just liftM2 (+)
04:52:53 <Syzygy-> > liftM2 (+) (Just 1) (Just 2)
04:52:54 <lambdabot>  Just 3
04:53:39 <_matthew_> it's a more complex function than (+) and I need to be able to return Nothing
04:53:50 <Syzygy-> > liftM2 (+) (Nothing) (Just 2)
04:53:51 <lambdabot>  Nothing
04:54:34 <_matthew_> ok, pretend the function is (\x y -> if (x == y) then mzero else return (x+y))
04:54:39 <Syzygy-> My point being that if you write your 2-ary function strictly, and just feed it to liftM2 as I did here with + you don't need to bother about lambda abstracting and then blah.
04:54:54 <Syzygy-> Ok, that's a bit more work. :P
04:55:05 <_matthew_> oh, agreed, I'm just making it a oneliner for irc purposes ;)
04:56:38 <Syzygy-> Ah :)
05:10:29 <bakert> anyone done any SOAP in haskell?
05:11:53 <bakert> That's a "no", then!
05:12:02 <bakert> Anyone done any XML in haskell?
05:12:07 <bakert> Or any HTTP?
05:12:15 <bakert> Are there libraries?
05:14:08 <ibid> there are libraries
05:14:19 <metaperl> thhhhere are gttos kibraries
05:14:25 <bakert> Which is best?
05:14:25 <metaperl> there are http libraries
05:14:28 <metaperl> dons maintains it
05:14:46 <metaperl> for soap, see HXT- haskell xml toolbox ... probably have to roll your own...
05:14:47 <metaperl> ttyl
05:15:45 <bakert> ok ... going to check out the hxt tutorial.  ta.
05:16:26 <bakert> What is dons' http library called?
05:23:09 <baboa> ?hoogle hex
05:23:10 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
05:23:10 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
05:23:10 <lambdabot> Numeric.readHex :: Integral a => ReadS a
05:23:59 <bakert> ?hoogle http
05:24:00 <lambdabot> Text.Html.httpequiv :: String -> HtmlAttr
05:24:18 <bakert> ?hoogle xml
05:24:18 <lambdabot> No matches found
05:24:23 <bakert> ?hoogle XML
05:24:23 <lambdabot> No matches found
05:25:43 <ibid> ?google haskell http library
05:25:46 <lambdabot> http://homepages.paradise.net.nz/warrickg/haskell/http/
05:25:46 <lambdabot> Title: Haskell HTTP Implementation
05:25:56 <ibid> dunno which that is :)
05:26:01 <bakert> sounds good
05:26:04 <ibid> of course, check the library page of the wiki
05:26:23 <bakert> ah ... library page of the wiki?  sounds useful!  will check it out... ta
05:26:51 <ibid> @wiki libraries
05:26:51 <lambdabot> http://www.haskell.org/haskellwiki/libraries
05:28:02 <ibid> http://www.haskell.org/haskellwiki/Libraries_and_tools/Web_programming#HTTP
05:28:05 <lambdabot> Title: Libraries and tools/Web programming - HaskellWiki, http://tinyurl.com/m537m
05:28:17 <psnl> bakert: that library works, I have patches if you are behind a proxy
05:28:17 <jrockway> heh, http://en.wikipedia.org/wiki/Haskell_class_attack_transport
05:28:28 <jrockway> that's what you get when you google for "haskell class" :)
05:29:20 <bakert> thanks psnl ... no proxy currently
05:29:41 <bakert> cor that library page is great
05:36:59 <lightstep> in haddock, can i put headings in a module description?
05:37:13 <augustss> @src or
05:37:13 <lambdabot> or    =  foldr (||) False
05:37:28 <opqdonut> ?src any
05:37:28 <lambdabot> any p =  or . map p
05:37:35 <augustss> A @src command!  dons is fast
05:38:32 <augustss> @src join
05:38:33 <lambdabot> join x =  x >>= id
05:38:44 <jrockway> ?src >>=
05:38:45 <lambdabot> Source for this function is not available.
05:39:02 <lightstep> ?src (>>)
05:39:02 <lambdabot> Source for this function is not available.
05:39:05 <bakert> @src comparing
05:39:05 <lambdabot> Source for this function is not available.
05:39:17 <jrockway> ?src (1+)
05:39:17 <lambdabot> Source for this function is not available.
05:40:15 <augustss> @src map
05:40:15 <lambdabot> map _ []     = []
05:40:16 <lambdabot> map f (x:xs) = f x : map f xs
05:41:55 <opqdonut> dons: you here?
05:43:16 <opqdonut> ?tell dons I get the following error when compiling hmp3-1.1:
05:43:17 <lambdabot> Consider it noted.
05:43:33 <opqdonut> ?tell dons I get the following error when compiling hmp3-1.1: ./Tree.hs:30:77: Module `Data.ByteString.Char8' does not export `joinWithChar' (sry for that)
05:43:34 <lambdabot> Consider it noted.
05:45:48 <opqdonut> ?tell dons the version from darcs compiles fine tho
05:45:49 <lambdabot> Consider it noted.
06:02:37 <dblhelix> happy new year, #haskell !
06:04:26 <bakert> happy new year dblhelix
06:04:38 <bakert> Anyone know why I don't get any docs when I run the haddock command specified in http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
06:04:39 <bakert> ?
06:04:40 <lambdabot> Title: How to write a Haskell program - HaskellWiki
06:06:14 <lightstep> bakert, what does haddock print?
06:06:19 <bakert> no output
06:06:33 <bakert> runhaskell Setup.lhs haddock
06:06:47 <lightstep> did you run Setup.lhs configure?
06:06:55 <bakert> (have this with both projects i have set up ... so whatever mistake i am making i have made it twice!)
06:07:07 <bakert> yes ran configure with --prefix=/home/bakert
06:07:17 <lightstep> it's either that or your cabal file is not to its liking
06:07:19 <bakert> might they have appeared somewhere other than under dist because of that?
06:07:45 <bakert> does configure and build and install fine.  hmmm.
06:13:48 <vincenz> @yarr
06:13:48 <lambdabot> I want me grog!
06:13:52 <kowey> bakert: works for me... i'm using ghc 6.6 with haddock 0.8... how about you?
06:13:59 <vincenz> @localtime dons
06:14:00 <lambdabot> Local time for dons is Wed Jan  3 01:06:40 2007
06:18:25 <_matthew_> @pl maybe True (\_ -> False)
06:18:25 <lambdabot> maybe True (const False)
06:24:14 <bakert> kowey, 6.4.1 -- not sure how to get the haddock version (!)
06:24:32 <kowey> try haddock --version
06:25:06 <lightstep> ?type isJust
06:25:08 <lambdabot> forall a. Maybe a -> Bool
06:25:37 <ToRA> that function is isNothing isn't it?
06:25:57 <lightstep> oh, yes
06:26:23 <_matthew_> yep, ok. ta
06:29:38 <dmhouse> Hrm, why does ./Setup.hs haddock only run haddock on my Main.hs?
06:29:39 <lambdabot> dmhouse: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:30:34 <kowey> bakert: another thing to try is to see what happens when you run haddock -h Haq.hs
06:31:03 <bakert> i don't have a commandline haddock, i don't think (???) just "runhaskell Setup.lhs haddock"
06:31:22 <bakert> perhaps that is the problem!
06:31:23 <dmhouse> That almost certainly depends on commandline haddock.
06:31:31 <dmhouse> bakert: run 'which haddock'.
06:31:37 <kowey> yes... I suppose the tutorial could say something to that effect
06:31:39 <bakert> installing it now ... !
06:31:58 <bakert> i thought it was something in a library that was getting called somehow
06:32:00 <bakert> !
06:33:05 <bakert> ok now i have haddock 0.7
06:34:29 <bakert> however, runhaskell Setup.lhs haddock still doesn't create anything in dist
06:34:37 <kowey> you might have to re-run configure
06:34:47 <bakert> i tried that but no dice
06:34:58 <bakert> i CAN now try running haddock standalone though!
06:35:29 <dmhouse> Do haddock -h -odocs <files>
06:36:30 <bakert> various errors like:
06:36:30 <bakert> Warning: Utils: the following names could not be resolved:
06:36:31 <bakert>     Ord Ordering Int
06:36:41 <bakert> and then a different one on the end:
06:36:42 <bakert> haddock.bin: dcocs/index.html: openFile: does not exist (No such file or directory)
06:36:47 <lightstep> haddock always gives lots of warnings
06:37:11 <dmhouse> bakert: you need to create the directory first, haddock is silly.
06:37:19 <bakert> ah, and i did a typo too
06:37:20 <bakert> !
06:37:33 <dmhouse> The warnings are because you don't have a local copy of the GHC docs, so it doesn't know what 'Ord', 'Ordering' and 'Int' are.
06:37:51 <bakert> i see
06:38:07 <bakert> woohoo ... it worked
06:38:31 <kowey> ok, now for cabal, it's quite possible that the version of cabal that ships with ghc 6.4.1 doesn't know about haddock
06:38:35 <kowey> anybody remember?
06:38:43 <kowey> (or have a ghc 6.4.1 to test?)
06:38:53 <bakert> and now i've made the dir it works with runhaskell Setup.lhs haddock, too!
06:39:01 <kowey> oh :-)
06:39:07 <bakert> ah
06:39:09 <bakert> no it doesn't!
06:39:11 <bakert> ignore me
06:39:17 <kowey> oh :-(
06:39:21 <bakert> !
06:39:48 <dmhouse> bakert: what does it do?
06:39:59 <christos> hello, I am reading the haskell gentle introduction and it states that a->a is a correct type for head. Is that correct?
06:40:04 <bakert> no output, no files created.  perhaps it is making them in some weird other place.
06:40:07 <bakert> ?type head
06:40:13 <lambdabot> forall a. [a] -> a
06:40:20 <dmhouse> christos: no.
06:40:29 <dmhouse> christos: it should be [a] -> a.
06:41:12 <dmhouse> christos: by the way, the so-called 'Gentle Introduction' was designed for those people with functional programming experience already, so if you find it somewhat non-gentle, try starting with:
06:41:14 <dmhouse> ?where yaht
06:41:15 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:41:17 <vincenz> christos: where in greece are you from?
06:41:23 <dmhouse> Or, if you've never programmed before,
06:41:25 <dmhouse> ?where wikibook
06:41:25 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:41:57 <christos> It states that [a] -> a is the principal type, but [b]->a, a->a or even a are correct types but too general. I get why [b]->a and a are correct types but I think a->a is wrong. Thanks for the links, I look at them too
06:42:17 <bakert> dmhouse, i think 6.4.1 does know about haddock in some way because "runhaskell Setup.lhs mackarel" gives an error where as haddock just completes silently.
06:42:42 <dmhouse> christos: yes, I'd agree with you there.
06:43:53 <allbery_b> at a (fuzzy just-woke-up) guess, it meant b->a
06:45:08 <kowey> may be worth contacting one of the authors to get it fixed
06:45:58 <kowey> or maybe it's like that professor that deliberately (and openly) introduces one error per day into his lectures to keep his students on their toes
06:52:22 <kowey> bakert: it also works for me on a machine with ghc-6.4.1 and haddock 0.7
06:52:50 <kowey> does it give you any warnings when you do runhaskell Setup.lhs haddock?
06:56:05 <joelr1> good day
06:56:12 <joelr1> shapr: did you get in touch with galois?
07:05:55 <pierre1> hi all
07:06:21 <bakert> kowey, no, no warnings.
07:06:42 <bakert> kowey, do you think i need to tell runhaskell about haddock in some way??
07:07:04 <Saizan> bakert: does it find haddock when you run the configure?
07:07:13 <Saizan> s/the//
07:08:00 <pbx> @protontorpedo
07:08:00 <lambdabot> so there is no database, monitoring system, web browser, webserver, or scheduling ssytem in haskell?
07:08:15 <bakert> Saizan, yes it does ... configure: Using haddock: /usr/bin/haddock
07:08:35 <lightstep> web browser?
07:08:51 <Saizan> what's a languge without a web browser?
07:08:56 <vincenz> nothing
07:08:57 <dmhouse> bakert: have you set up your prj.cabal file?
07:09:14 <flux__> hmm.. how does STM work in the case, where I have a = newTVar 0, b = newTVar 1, and a transaction attempts to do { v1 <- readTVar a; v2 <- readTVar b; return 1 / (v1 + v2); } while other threads atomically store different values to a and b while always maintaining a + b <> 0 at the end of the transactions - can the transaction divide by zero? and if so, what happens..
07:09:21 <opqdonut> @protontorpedo
07:09:21 <lambdabot> or does it become a mishmash of code?
07:09:29 <bakert> I have a cabal file.  it doesn't mention haddock.  should it?
07:09:46 <bakert> @paste
07:09:47 <lambdabot> http://paste.lisp.org/new/haskell
07:10:00 <lightstep> flux__, this block won't finish executing if some other thread touches a and b
07:10:02 <lisppaste2> bakert pasted "My cabal file" at http://paste.lisp.org/display/33946
07:10:06 <kowey> bakert: the other thing is that i had upgraded my cabal to 1.16
07:10:49 <flux__> lightstep, hmm.. shouldn't such a block always finish?
07:10:57 <flux__> at some point of time atleast
07:11:25 <lightstep> only if the values of a and b in the end are the same as they were in the beginning
07:12:40 <dmhouse> Gah, why does ./Setup.hs haddock only build docs for my Main.hs?
07:14:06 <flux__> my picture of STM is that it goes like: attempt the transaction (reads, division), generate log, if atomically(check log and memory for errors) contains error then retry else continue
07:14:53 <flux__> in which world another transaction could perform (a, b) <- readTVars (a, b) after v1 <- readTVar
07:15:02 <flux__> uh
07:15:11 <flux__> I meant (a, b) <- (b, a)
07:16:00 <flux__> I suppose it doesn't matter, atleast not in haskell :)
07:24:44 <araujo> ok, i amhere
07:28:02 <kowey> ?tell dmhouse re: haddock only on main... maybe you have to set other-modules in cabal
07:28:02 <lambdabot> Consider it noted.
07:35:40 <araujo> mmm...
07:36:08 <araujo> The first hurd mailing list of the year is a proposal to write the microkernel in Haskell.
07:36:27 <araujo> first mail on the*
07:36:49 * araujo kind of surprised
07:37:24 <Saizan> aren't there yet 2 OSes in pure haskell?
07:37:48 <Saizan> or was referred to the runtime?
07:37:52 <vincenz> soon we will have an OS in the type system
07:37:57 <_matthew_> lol
07:38:03 <araujo> I only know House. Though some people considers that one as just a hack for using ghci as a kernel.
07:38:17 <Saizan> vincenz: how many Olegs?:D
07:38:25 <vincenz> Saizan: 2 milliOlegs
07:38:39 <_matthew_> araujo: there were plans to switch from mach to l4 the last time I looked at Hurd. I guess these have come to nothing
07:39:16 <flux__> araujo, does the post have an url? (an up-to-date archive for example..)
07:39:17 <araujo> _matthew_, That was long ago ; they switched from l4  to ... mmm ... they are trying to switch to something else now :-)
07:39:40 <flux__> does hurd still require 64bit host to access >4GB block devices?
07:39:48 <_matthew_> they switched *from* l4? As in, they made it to l4?
07:40:00 <flux__> or course, 64-bit machines are already commonly available, so maybe that's not really that much of a problem anymore..
07:40:02 <araujo> _matthew_, There has been proposal during the last few months. Someone also proposed Haskell as an alternative language to code a new kernel from scratch a few months ago.
07:40:45 <_matthew_> mmm. well, apart from the insanity of reinventing a wheel that big, it's not a bad idea I suppose
07:40:45 <araujo> flux__, http://lists.gnu.org/archive/html/l4-hurd/
07:40:47 <lambdabot> Title: l4-hurd Archives
07:40:54 <_matthew_> it'd at least make ghc faster!
07:40:54 <araujo> It should be updating within the few hours
07:41:00 <araujo> It's the first posting of the year.
07:41:16 <flux__> apparently no posts in 2006-12
07:41:19 <vincenz> Saizan: now if you want distributed, fault-tolerant, automated restarting webservices over multiple continents in the type system, that might be several Olegs, like 2 or so
07:41:42 <araujo> _matthew_, yes, you can boot the hurd from l4. But it is extremely alpha
07:42:02 <araujo> _matthew_, the code is in the cvs repo somewhere , i reallly never tested it.
07:42:02 * _matthew_ wonders which parts of the hurd ever made it out of alpha ;)
07:42:30 <araujo> _matthew_, 'extremely alpha'
07:42:46 <_matthew_> ahh! we're making that level of distinction then!
07:42:48 <Saizan> vincenz: like we can have erlang in the type system?
07:42:55 <vincenz> Saizan: :D
07:42:58 <araujo> the gnumach _can_ be used even as a web server.
07:43:08 <_matthew_> Saizan: actually, I'm working on something like that...
07:43:12 <araujo> So i guess it is kind of beta.
07:43:52 <araujo> flux__, no post in the december , it has been slow lately.
07:44:09 <araujo> They are trying to decide what kernel to use for the Hurd.
07:44:36 <joelr1> vincenz: someone should merge gdh and ghc 6.6
07:44:45 <vincenz> joelr1: what is gdh?
07:45:10 <bakert> ?randomRIO
07:45:10 <lambdabot> Unknown command, try @list
07:45:10 <joelr1> vincenz: that would give you distributed, fault-tolerant, etc. etc. gdh = glasgow distributed haskell, based on a much earlier version of ghc.
07:45:16 <bakert> ?src randomRIO
07:45:16 <lambdabot> Source for this function is not available.
07:45:17 <vincenz> ah right
07:45:35 <vincenz> Yes, that would be interesting :)
07:46:02 <araujo> _matthew_, they were thinking to use coyotos , but for some reason, they dropped it too.
07:46:39 <_matthew_> ooo. not come across that. /me googles
07:47:16 <_matthew_> araujo: oh right. interesting. successor of eros. mmmm
07:48:11 <araujo> yeah
07:50:07 <pierre1> where can i get the dynamic plugin library used in Yi and hIDE? does any darcs repo exists?
07:50:34 <psnl> hs-plugins?
07:50:49 <pejo> ?where hs-plugins
07:50:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:51:15 <pierre1> thanks
07:51:58 <fasta> What's the point of having "derived" operations in a type class?
07:52:38 <Saizan> so you can skip implementing them but you can implement them if have a better way to do it
07:52:40 <fasta> I thought the idea of a type class was to provide a minimal set of operations generic algorithms can use.
07:53:35 <fasta> Saizan: why wouldn't that be possible otherwise?
07:53:56 <Saizan> like how?
07:54:43 <fasta> Saizan: as a concrete example take Data.Inductive.Graph.noNodes
07:54:59 <Saizan> ?docs Data.Inductive.Graph
07:54:59 <lambdabot> Data.Inductive.Graph not available
07:55:15 <fasta> It is in the type class, but AFAIK, it can be implemented outside of the type class.
07:56:11 <fasta> This is the definition: noNodes = length . labNodes
07:56:13 <Saizan> by methods of the typeclass you mean?
07:56:21 <fasta> Saizan: yes
07:56:36 <joelr1> shapr: ping
07:56:43 <fasta> Saizan: it's just API pollution.
07:56:46 <arjanb> once you implemented it outside a typeclass you can't provide a more efficient specialization for some instances anymore
07:56:46 <Saizan> well it's like Eq, where (/=) = not . (==)
07:56:55 <Saizan> it's handy
07:57:16 <fasta> Saizan: I think it pollutes.
07:57:25 <xerox> Or like Monad, where join = (>>= id).
07:57:44 <Saizan> fasta: arjab point it's the reason i think
07:57:45 <fasta> xerox: join is not a part of the type class, right?
07:57:51 <xerox> fasta: is it part of it
07:57:54 <Saizan> join it is
07:58:27 <glguy> It would be lousy to have to always manually define an Enum instance on something like data Rank = Ace | Two | Jack | King...
07:58:31 <xerox> It's actually equivalent to define Monad with return and bind, with a default implementation of join, or define return and join, with a default implementation of bind (given the functor instance).
07:58:32 <fasta> class Monad m where (>>=) :: m a -> (a -> m b) -> m b (>>) :: m a -> m b -> m b return :: a -> m a fail :: String -> m a
07:58:37 <fasta> No, join there.
07:59:05 <fasta> or rather No join, there
07:59:18 <glguy> > let join = (>>= id) in join [[1,2],[3,4],[]]
07:59:19 <lambdabot>  [1,2,3,4]
07:59:48 <glguy> join doesn't need to be part of the class since it is based on bind, which is
07:59:49 <fasta> xerox: right, so any minimum set is ok
07:59:59 <fasta> glguy: and the same holds for noNodes
08:00:10 <Saizan> mmh true, no join, but there's (>>) for example
08:00:29 <glguy> >> is there for efficiency reason though (is that your point?)
08:00:31 <fasta> Saizan: which is a mistake imho
08:00:43 <fasta> glguy: interesting, why?
08:01:16 <glguy> fasta: for some monad's >> can be written in a more efficient way that f >> x = f >>= \_ -> x
08:01:23 <glguy> s/that/than
08:01:33 <glguy> s/monad's/monads
08:01:57 <fasta> glguy: ok, in that light, noNodes makes some sense.
08:02:11 <glguy> noNodes = "Number of nodes"?
08:02:15 <fasta> glguy: yes
08:02:23 <mauke> "good" name
08:02:52 <fasta> I don't really think that naming a set of methods to designate a class is a fantastic idea, though.
08:02:53 <glguy> yeah, so if you were to have an instance of your class that could solve the number of nodes without a linear search
08:03:15 <glguy> then you could use that fucntion in a generic way
08:03:23 <glguy> and not tie down to a specific instance
08:03:49 <fasta> The "model" C++ has seems better (disregarding the error messages and the abundance of type annotations)
08:04:51 <fasta> Yes, I put model in quotes because we all know it's a god evil hack ;)
08:06:03 <Saizan> c++'s model?
08:06:08 <glguy> is there something you like about it in particular?
08:06:52 <Lemmih> @karma c
08:06:53 <lambdabot> c has a karma of 18
08:07:04 <dmhouse> Okay, more Haddock/Cabal problems.
08:07:04 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
08:07:07 <wilx|wrk> @karma C++
08:07:07 <lambdabot> C++ has a karma of 0
08:07:13 <wilx|wrk> @karma c++
08:07:13 <lambdabot> c++ has a karma of -5
08:07:16 <wilx|wrk> HEh.
08:07:28 <wilx|wrk> @karma+ c++
08:07:29 <lambdabot> c++'s karma raised to -4.
08:08:02 <dmhouse> I've got a package which is an executable rather than a library. I want to build the Haddock docs for it.
08:08:37 <lisppaste2> dmhouse pasted "My .cabal file" at http://paste.lisp.org/display/33953
08:08:43 <dmhouse> That's my cabal file.
08:08:56 <dmhouse> My problem is that I'm getting docs for everything but the 'Main' module built.
08:09:02 <fasta> glguy: hmm, I did mean a different language after all ;) Never mind it.
08:09:51 <dmhouse> I.e. documentation for Views and Datatypes is built, but not Main.
08:12:09 <dmhouse> Even if I add Main to Other-Modules, which seems like the wrong thing to do, documentation isn't produced for it.
08:15:24 <dmhouse> I do also get a weird warning about the name 'err' not being resolvable, even though I don't think I'm using that anywhere.
08:16:25 <dmhouse> Scratch that last point, I found out what was causing that, but Main docs still aren't being built.
08:19:26 <emu> ha
08:19:46 <emu> stupid me. i tried -O2 to a library doing some heavy work, and i sped my program up by 40%
08:22:11 <pejo> fasta, what is the "model" that c++ has?
08:22:56 <fasta> pejo: I already said "never mind"
08:23:00 <Stinger__> what namespace do classes exist in?
08:23:09 <vincenz> global
08:25:41 <Stinger__> hmm so say I want to specialize (+) for a type would I have to make it an instance of Num?
08:26:03 <mauke> yes
08:26:08 <nornagon> :t (+)
08:26:10 <lambdabot> forall a. (Num a) => a -> a -> a
08:26:47 <spiffy> hmmm ive always wondered, whats the forall a. bit about anyways?
08:27:04 <mauke> it explicitly declares/scopes the type variable
08:27:29 <int-e> "for all types 'a', if a is an instance of Num, then the function has type a -> a -> a"
08:27:41 <spiffy> ahhh. I thought that was assumed?
08:27:53 <int-e> yes and no ...
08:28:21 <spiffy> or maybe a better qustion is, when is it not assumed?
08:28:33 <pejo> fasta, I'm just curious of C++, that's all.
08:28:42 <int-e> ghc makes the forall explicit when printing types and optional in type signatures. Haskell 98 only knows type signatures with implicit foralls.
08:29:13 <spiffy> can you have a type signature without an implicit or explicit forall?
08:29:16 <int-e> spiffy: if the forall spans the whole type, that's equivalent to an implicit forall
08:29:23 <mauke> forall a b. (forall c. c -> c) -> a -> b -> (a, b)
08:29:40 <int-e> spiffy: forall a b . a -> b  and  a -> b  denote the same type
08:30:12 <spiffy> int-e: so i guess im wondering why we bother to print the forall
08:30:24 <emu> because it is more clear and correct
08:30:25 <int-e> spiffy: whereas (forall a . a) -> b is a different one; the first argument of that function must inhabit all types (in other words, it must be  bottom)
08:30:49 <spiffy> ahhhh
08:31:01 <spiffy> now i follow, thanks
08:31:25 <metaperl> @tell Cale http://darcs.metaperl.com/hrss/
08:31:25 <lambdabot> Consider it noted.
08:31:52 <Stinger__> :t const 3
08:31:53 <lambdabot> forall a b. (Num a) => b -> a
08:32:02 <int-e> spiffy: (forall a . a) -> b is the same as forall b . (forall a . a) -> b  of course.
08:32:42 <nornagon> :t const
08:32:43 <lambdabot> forall a b. a -> b -> a
08:32:54 <spiffy> learn something new every day :)
08:33:11 <nornagon> so const is a function that creates a function that throws away any argument and returns something else?
08:33:32 <mauke> @. djinn type const
08:33:33 <Stinger__> yeah it returns the first argument
08:33:34 <lambdabot> f a _ = a
08:33:51 <spiffy> >const "string"
08:34:00 <spiffy> err
08:34:10 <spiffy> nvm
08:34:11 <nornagon> mauke: :)
08:34:11 <glguy> > const "string" --that should work ;)
08:34:11 <dmhouse> > const "foo" 57
08:34:11 <lambdabot>  Add a type signature
08:34:12 <lambdabot>  "foo"
08:34:20 <dmhouse> It takes two arguments.
08:34:23 <int-e> glguy: it's polymorphic
08:34:29 <glguy> yeah, I see that now :-p
08:34:30 <dmhouse> ?type const "foo"
08:34:32 <lambdabot> forall b. b -> [Char]
08:34:41 <mauke> @let unconst x = fix x
08:34:42 <lambdabot> Defined.
08:34:53 <mauke> > unconst (const "string")
08:34:53 <emu> > const "foo" "bar"
08:34:54 <lambdabot>  "string"
08:34:55 <lambdabot>  "foo"
08:34:59 <glguy> > putStrLn
08:35:00 <lambdabot>  <[Char] -> IO ()>
08:35:08 <int-e> > const "foo" . ('a':)
08:35:09 <glguy> ^^ behavior I was attempting
08:35:09 <lambdabot>  <[Char] -> [Char]>
08:36:02 <dmhouse> Y'know, it's only when you start learning other languages that you appreciate how complicated Haskell is.
08:36:06 <vincenz> > fix const
08:36:07 <lambdabot>      Occurs check: cannot construct the infinite type: t = b -> t
08:36:07 <lambdabot>       Expec...
08:36:19 <vincenz> > fix . const $ 1
08:36:21 <lambdabot>  1
08:36:35 <vincenz> > fix const fix
08:36:36 <lambdabot>      Occurs check: cannot construct the infinite type: t = b -> t
08:36:36 <lambdabot>       Expec...
08:36:44 <vincenz> > fix . const $ fix
08:36:44 <lambdabot>  Add a type signature
08:36:50 <mauke> you can't fix const, don't try
08:37:06 <dmhouse> > fix . const (fix . const) 1
08:37:07 <lambdabot>  Add a type signature
08:37:21 <spiffy> :t fix
08:37:23 <lambdabot> forall a. (a -> a) -> a
08:37:28 <dmhouse> > (fix . const) (fix . const) 1
08:37:29 <lambdabot> Terminated
08:37:37 <emu> > fix stupid
08:37:38 <lambdabot>   Not in scope: `stupid'
08:37:42 <SamB> heh
08:37:44 <fasta> dmhouse: you mean that other languages are even more complicated?
08:37:50 <mauke> > (fix . const) (fix . const) 1
08:37:52 <lambdabot>  1
08:37:56 <dmhouse> fasta: no,t he other way around. :)
08:37:58 <vincenz> > let problem = (1:) in fix problem
08:37:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:38:00 <Stinger__> > fix $ const 1
08:38:01 <lambdabot>  1
08:38:08 <dmhouse> > (fix . const) (fix . const) 1
08:38:09 <lambdabot>  1
08:38:16 <fasta> dmhouse: what's good about having a complicated language?
08:38:20 <dmhouse> Heh, I was wondering why that didn't work.
08:38:26 <mauke> dmhouse: my fault :/
08:38:29 <SamB> what part of Haskell is complicated?
08:38:34 <mauke> I temporarily broke (.)
08:38:40 <spiffy> so, what does fix do exactly?
08:38:47 <mauke> @src fix
08:38:47 <lambdabot> fix f = let x = f x in x
08:38:50 <Stinger__> crazy things that hurt my brain ;)
08:38:57 <dmhouse> spiffy: fix f = f (fix f)
08:39:00 * glguy immediately falls in love with @src
08:39:06 <fasta> I do know that interesting code is a lot more difficult to write...
08:39:12 <vincenz> @src const
08:39:12 <lambdabot> const x _ = x
08:39:15 <vincenz> woo
08:39:17 <vincenz> @src++
08:39:18 <lambdabot> Source for this function is not available.
08:39:19 <dmhouse> So, for example, fix (const 1) = const (const (const (const (const ...
08:39:22 <int-e> find a least fixed point (where 'least' is with respect to definedness - what's the proper name for this?)
08:39:33 <glguy> ?src sequence_
08:39:34 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:39:37 <glguy> ?src sequence
08:39:37 <lambdabot> sequence ms = foldr k (return []) ms
08:39:38 <lambdabot>     where
08:39:38 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:39:39 <vincenz> dmhhouse: no
08:39:40 <int-e> it's clearer operationally actually :)
08:39:49 <vincenz> fix (const 1) = const 1 (const 1 ( ....) = 1
08:39:52 <dmhouse> int-e: I use definedness too :)
08:40:00 <spiffy> >fix (1:)
08:40:00 <dmhouse> Err, yeah, I mant what vincenz said.
08:40:04 <pierre1> > fix (const 1)
08:40:05 <lambdabot>  1
08:40:06 <spiffy> > fix (1:)
08:40:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:40:11 <int-e> > fix ((1:) . map (1+))
08:40:11 <fasta> For example: did you know that deleting an edge from a graph in FGL takes time linear in the degree of an edge + the time to find the node ...
08:40:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:40:27 <glguy> > fix (\ ~(a,b) -> (1,a) )
08:40:28 <lambdabot>  (1,1)
08:40:35 <spiffy> hmm whats ~?
08:40:39 <fasta> In an imperative implementation that would take O(1)
08:40:40 <glguy> lazy pattern matching
08:40:46 <spiffy> ahhh right
08:40:54 <pierre1> why don't fix turns in the infinite loop in "fix (const 1)"?
08:40:57 <dmhouse> spiffy: x is a fixpoint of f if f x = x. So fix (1:) is an infinite list of 1s because that list remains itself when you add 1 to the front.
08:40:57 <vincenz> @src Data.Graph.stronglyConnComp
08:40:57 <lambdabot> Source for this function is not available.
08:41:04 <emu> yikes, just found some old ignore list patterns. no wonder some of the conversations in here seemed one-sided.
08:41:07 <dmhouse> pierre1: laziness.
08:41:13 <vincenz> @src Data.Graph.buildG
08:41:13 <mauke> pierre1: because (const 1) ignores its argument
08:41:13 <lambdabot> Source for this function is not available.
08:41:21 <glguy> fasta: fortunately, Haskell supports an imperative implementation
08:41:33 <fasta> glguy: you mean one based on an array
08:41:35 <vincenz> @src fork
08:41:36 <lambdabot> Source for this function is not available.
08:41:43 <vincenz> @help src
08:41:43 <mauke> @src forkIO
08:41:43 <lambdabot> src <id>. Display the implementation of a standard function
08:41:43 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
08:41:44 <lambdabot>     where action_plus = catchException action childHandler
08:41:48 <glguy> fasta: I mean that Haskell has imperative support
08:41:50 <spiffy> > fix (1+)
08:41:51 <lambdabot>  Exception: <<loop>>
08:41:52 <fasta> glguy: oh, right
08:41:54 <int-e> spiffy: in practice what you get is the limit of _|_, f _|_, f (f _|_), etc. (where _|_ denotes bottom)
08:42:00 <dmhouse> spiffy: because there is no fixpoint of that function.
08:42:02 <emu> i rewrote my FGL algorithm to use an STUArray
08:42:17 <vincenz> @src Data.Map.lookup
08:42:18 <lambdabot> Source for this function is not available.
08:42:19 <int-e> . o O ( last $ iterate f undefined ) *ducks*
08:42:20 <spiffy> hmmm That makes sense.
08:42:20 <fasta> emu: does it still use the same API?
08:42:22 <emu> well, i freeze it into a diffarray
08:42:25 <vincenz> @src lookup
08:42:26 <lambdabot> lookup _key []          =  Nothing
08:42:26 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
08:42:26 <lambdabot>                         | otherwise = lookup key xys
08:42:33 <dmhouse> spiffy: don't expect to understand it completely until you delve into denotational semantics.
08:42:33 <pierre1> @src reverse
08:42:34 <lambdabot> reverse = foldl (flip (:)) []
08:42:37 <emu> i present the same API from the module, the implementation is very different
08:42:51 <spiffy> is lambdabot smart enough to use a pastebin?
08:43:09 <fasta> emu: did you implement it like an adjacency matrix?
08:43:16 <pejo> dmhouse, I know nothing about denotational semantics, but I found the explaination of fixpoints in chapter 21 of Tapl rather clear.
08:43:24 <glguy> ?. djinn type lookup
08:43:25 <lambdabot> Cannot parse command
08:43:26 <emu> almost; that turned out to be too sparse -- i opted for an array of edge maps
08:43:43 <fasta> emu: edge map? You mean with log n lookup?
08:43:46 <nmessenger> @help .
08:43:47 <lambdabot> . <cmd1> <cmd2> [args].
08:43:47 <lambdabot> . [or compose] is the composition of two plugins
08:43:47 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
08:43:50 <emu> yep
08:43:57 <emu> but n is small in most cases
08:44:39 <emu> the adj matrix impl was no faster than FGL.  this one is at least an order of magnitude better.
08:44:47 <dmhouse> pejo: okay, so you know what fix does, but do you know how it works?
08:45:19 <spiffy> metatheory of recursive types....gotta love TAPL.
08:45:47 <vincenz> @src map
08:45:47 <lambdabot> map _ []     = []
08:45:48 <lambdabot> map f (x:xs) = f x : map f xs
08:46:12 <pierre1> @src lift
08:46:12 <lambdabot> Source for this function is not available.
08:46:18 <pierre1> @src liftM
08:46:18 <vincenz> @src liftIO
08:46:19 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:46:19 <lambdabot> Source for this function is not available.
08:46:25 <spiffy> @src return
08:46:26 <lambdabot> Source for this function is not available.
08:46:26 <dmhouse> pejo: actually, to tell the truth, it was TAPL that first explained the relationship between fixpoints and recursion to me.
08:46:29 <vincenz> @src elevator
08:46:29 <lambdabot> Source for this function is not available.
08:46:48 <dmhouse> pejo: then reading the wikibook's awesome article on Denotational Semantics explained how that links in.
08:47:00 <spiffy> @let spiffy a b = a + b
08:47:01 <lambdabot> Defined.
08:47:05 <spiffy> @src spiffy
08:47:06 <lambdabot> Source for this function is not available.
08:47:11 <spiffy> boo
08:47:14 <vincenz> @let spiffy a b = b
08:47:15 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
08:47:20 <vincenz> @unlet spiffy
08:47:21 <lambdabot>  Parse error
08:47:25 <vincenz> Eh
08:47:27 <vincenz> @help let
08:47:27 <glguy> undefine
08:47:28 <lambdabot> let <x> = <e>. Add a binding
08:47:31 <vincenz> @undefine spiffy
08:47:31 <dmhouse> ?undefined spiffy
08:47:32 <lambdabot> Undefined.
08:47:32 <lambdabot> Undefined.
08:47:36 <vincenz> @let spiffy a b = b
08:47:37 <lambdabot> Defined.
08:47:42 <vincenz> > fix spiffy
08:47:43 <lambdabot>  Add a type signature
08:47:45 <glguy> ?src L.spiffy
08:47:45 <lambdabot> Source for this function is not available.
08:47:47 <vincenz> > fix spiffy 1
08:47:48 <lambdabot>  1
08:48:00 <glguy> L. is not required now?
08:48:11 <spiffy> I bought tapl...I really should read it at some point.
08:48:34 <emu> i'm working my way through tapl
08:48:50 <mauke> @let a << b = do { x <- a; b; return x }
08:48:51 <lambdabot> Defined.
08:48:56 <vincenz> you're not a true haskell programmer unless you've read tapl
08:49:14 <dmhouse> vincenz: despite the fact it uses ML for its examples... ;)
08:49:24 <nmessenger> ?where tapl
08:49:24 <lambdabot> I know nothing about tapl.
08:49:38 <dmhouse> ?google types and programming languages
08:49:41 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
08:49:41 <lambdabot> Title: Types and Programming Languages
08:49:49 <nmessenger> ?define tapl http://www.cis.upenn.edu/~bcpierce/tapl/
08:49:50 <lambdabot> Undefined.
08:50:01 <dmhouse> ?where+ tapl http://www.cis.upenn.edu/~bcpierce/tapl/
08:50:01 <lambdabot> Done.
08:50:26 <pejo> dmhouse, I'd go the operational way instead, for an evaluation context C: C[fix \x:T.t] -> C[[(fix \x:T.t)/x]t].
08:51:08 <dmhouse> pejo: then why is it called 'fix'?
08:51:11 <pejo> Someone put in tapl in lambdabot the other day, I'm sure of. Also attapl. Could it have lost the database?
08:52:22 <glguy> ?where wrong
08:52:23 <lambdabot> http://adrinael.net/wrong.jpg
08:52:31 <glguy> (database is still there)
08:52:46 <xerox> dmhouse: because it fix the argument
08:52:59 <pejo> dmhouse, not sure I understand your question, but I take it as because fix returns the least fixed point of it's parameter.
08:53:35 <dmhouse> xerox: I know the answer, my point is that based solely on the operational definition you get no insight as to why fix f is the fixpoint of f, you need denotational semantics for that.
08:54:54 <pejo> glguy, http://tunes.org/~nef/logs/haskell/06.12.27, search for "attapl".
08:55:16 <spiffy> from the wiki page for fixpoint (mathematics) ....In mathematics, a fixed point (sometimes shortened to fixpoint) of a function is a point that is mapped to itself by the function.
08:55:23 <glguy> ?where ATTaPL
08:55:24 <lambdabot> I know nothing about attapl.
08:55:25 <emu> i originally got it for a class, when it first came out
08:55:31 <xerox> dmhouse: could you elaborate further?
08:55:32 <spiffy> I understand that, but im wonder if it has anything to do with the fix function
08:55:33 <dmhouse> spiffy: hence, x is a fixpoint of f if x = f x
08:55:34 <glguy> I guess it could have rolled back
08:55:46 <spiffy> yes
08:55:58 <dmhouse> spiffy: fix (1:) is an infinite list of ones, because that list is a fixpoint of (1:). Agreed?
08:56:48 <dmhouse> xerox: did you read the wikibook article on denotational semantics?
08:56:48 <spiffy> I agree but not because i see how the mathematical definition applies =)
08:56:52 <xerox> dmhouse: nope.
08:56:57 <dmhouse> xerox: do so :)
08:56:59 <dmhouse> ?where wikibook
08:57:00 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:57:16 <mauke> (1:) is a function that prepends 1 to any list
08:57:19 <spiffy> yup
08:57:21 <pierre1> > fix (\x -> (x*x))
08:57:23 <lambdabot>  Exception: <<loop>>
08:57:25 <dmhouse> spiffy: what do you get if you add a 1 to the front of an infinite list of ones?
08:57:34 <metaperl> For this type signature readDocument :: Attributes -> String -> IOStateArrow s b XmlTree
08:57:37 <mauke> the only list that's unchanged by that needs to be infinitely long
08:57:38 <spiffy> the same list...ooo
08:58:06 <dmhouse> spiffy: now convince yourself that [1,2,3,4...] is the fixpoint of (1:) . map (+1)
08:58:53 <fasta> Hmm, I am using let in a wonderfull lazy way :-)
08:58:55 <dmhouse> (I really should say 'a' rather than 'the' fixpoint, there can be more than one, but that's a technicality.)
08:59:08 <pejo> dmhouse, I have to go eat. I'm not sure the why is the most important question for that one actually.
08:59:27 <nmessenger> > fix id
08:59:28 <lambdabot>  Add a type signature
09:00:01 <pierre1> > fix id :: Int
09:00:02 <lambdabot>  Exception: <<loop>>
09:00:06 <glguy> ?type fix id
09:00:09 <dmhouse> fix can fail for two reasons: 1) there is no fixpoint of the function you're trying to find. 2) There are infinitely many.
09:00:12 <lambdabot> forall a. a
09:00:15 <emu> the least fix point
09:00:27 <dmhouse> emu: yes, there's no least fix point of id.
09:00:33 <spiffy> ahh I see it now
09:00:59 <dmhouse> spiffy: now, onto why you might want to use fix.
09:01:10 <dmhouse> Start with the definition of length:
09:01:20 <spiffy> @src length
09:01:20 <lambdabot> Source for this function is not available.
09:01:25 <dmhouse> length xs = if null xs then 0 else 1 + length (tail xs)
09:01:32 <spiffy> yup
09:01:38 <dmhouse> It's a slightly nonstandard definition anyway, but this is easiets.
09:01:40 <dmhouse> *easiest.
09:01:51 <spiffy> mmhmm
09:02:00 <dmhouse> Now, we transform length into a function that takes another function, removing it's recursiveness.
09:02:11 <dmhouse> length l xs = if null xs then 0 else 1 + l (tail xs)
09:02:22 <dmhouse> Actually, call that one length' to avoid confusion.
09:02:27 <dmhouse> length' l xs = if null xs then 0 else 1 + l (tail xs)
09:02:39 <spiffy> alright
09:02:59 <dmhouse> Now, I claim we can recover our original length by finding the fixpoint of this new length'. I.e. length = fix length'.
09:03:04 <dmhouse> The reason this works:
09:03:12 <spiffy> @src fix
09:03:12 <lambdabot> fix f = let x = f x in x
09:03:21 <dmhouse> Remember the definition of a fixpoint x as x = f x.
09:03:26 <spiffy> yes
09:03:32 <dmhouse> So we're looking for a function f, such that:
09:03:39 <dmhouse> f = length' f
09:03:46 <dmhouse> Expanding the right hand side,
09:04:00 <dmhouse> f = \xs -> if null xs then 0 else 1 + f (tail xs)
09:04:12 <dmhouse> But wait, that's precisely the same as our original definition of length!
09:04:17 <spiffy> oo...
09:04:32 <dmhouse> So fix lets you define recursion.
09:04:41 <pierre1> dmhouse: looks like magic :-)
09:05:02 <dmhouse> Technically speaking, the meaning of a recursive equation is the fixpoint of the transformed version (where we made it nonrecursive) of that function.
09:05:39 <spiffy> so fix lets us take any HOF and make it recurisve?
09:05:45 <dmhouse> This is called denotational semantics, whereby we explain how we should evaluate programs by modelling them using various mathematical objects (we used the fixpoint here).
09:05:55 <dmhouse> spiffy: yeah, I guess so.
09:06:03 <fasta> doesn'
09:06:12 <fasta> t fix only do primitive recursive functions?
09:06:18 <spiffy> denotational semantics...one more thing to look into
09:06:22 <emu> > let fix = \f -> (\x -> f (x x)) (\x -> f (x x)) in fix (1:)
09:06:23 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
09:06:23 <lambdabot>       Expe...
09:06:25 <dmhouse> Most of the time it's useless, though. It's really only interesting from this theoretical standpoint.
09:06:34 <dmhouse> fasta: oh, maybe, I can't remember.
09:06:47 <dmhouse> emu: that doesn't type in Haskell.
09:06:51 <emu> yea just remembered
09:06:51 <fasta> fix is one of Haskell's way of writing for loops
09:06:57 <emu> HM systtems wont accept that
09:07:03 <dmhouse> fix is built into the language, there's no way you can define it.
09:07:14 <fasta> fix (\loop loop_variable-><do_stuff>)
09:07:37 * nmessenger learned about fixed points when he tried to reason about the Y-combinator in Javascript.  <http://javascript.crockford.com/little.html>  Mentally breaking down the stack was instructional.  
09:07:37 <dmhouse> Well, you can define it using recursion or recursive let, but as we're trying to define recursion in terms of fix that's a little self-defeating.
09:07:40 <emu> > let fix = (let x = f x in x) in fix (1:)
09:07:40 <lambdabot>   Not in scope: `f'
09:07:47 <fasta> dmhouse: uh, no it isn't built in.
09:07:53 <emu> > let fix f = (let x = f x in x) in fix (1:)
09:07:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:08:02 <emu> yea i suppose
09:08:08 <dmhouse> So yeah, fix or recursion, make up your mind about which is the more fundamental.
09:08:16 <emu> fix!
09:08:21 <opqdonut> Y!
09:08:30 <dmhouse> emu: I meant they can both be used to define the other.
09:08:48 <mauke> @v
09:08:48 <lambdabot> "\""
09:08:48 <emu> can fix be defined without recursion in haskell type system?
09:08:58 <metaperl> @doc catA
09:08:58 <lambdabot> catA not available
09:09:01 <mauke> @v
09:09:01 <dmhouse> emu: no.
09:09:01 <lambdabot> Just 'J'
09:09:04 <fasta> dmhouse: I don't think that's true
09:09:06 <opqdonut> @src fix
09:09:07 <lambdabot> fix f = let x = f x in x
09:09:10 <opqdonut> :)
09:09:12 <metaperl> @doc ControlArrow
09:09:13 <lambdabot> ControlArrow not available
09:09:13 <dmhouse> fasta: which bit?
09:09:16 <mauke> what was the definition of v again?
09:09:22 <metaperl> @doc Control.Arrow
09:09:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
09:09:28 <fasta> dmhouse: that when you have fix, you also have recursion
09:09:38 <fasta> dmhouse: I thought you only had primitive recursion
09:09:42 <dmhouse> fasta: perhaps.
09:09:54 * dmhouse looks it up
09:09:56 <opqdonut> in haskell recursion is clearly more fundamental than fix
09:10:09 <emu> no you have general recursion
09:10:37 <emu> there is no reason why a fix point of a function will terminate
09:11:22 <fasta> Yeah, I suppose you are right
09:11:49 <dmhouse> opqdonut: why?
09:11:57 <opqdonut> ?src fix
09:11:57 <lambdabot> fix f = let x = f x in x
09:12:00 <opqdonut> because :)
09:12:06 <emu> because you can't define fix w/o it?
09:12:12 <emu> :/
09:12:17 <dmhouse> emu: You can define fix using recursion.
09:12:21 <dmhouse> fix f = f (fix f)
09:12:30 <emu> yea i mean, w/o recursion
09:12:38 <dmhouse> opqdonut: right, your argument is basically 'Because Lambdabot says so!'. :)
09:13:02 <dmhouse> emu: true.
09:13:03 <opqdonut> and if you think of how the stuff is implemented on the turing-machine level, it is recursive functions and not a Y combinator or something
09:13:05 <nmessenger> ?type (\f -> (\x -> f (x x)) (\x -> f (x x)))
09:13:07 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
09:13:07 <lambdabot>       Expected type: t
09:13:18 <dmhouse> opqdonut: why do you need to reduce to a turing-machine level?
09:13:20 <emu> lambda calculus is an equally valid model of computation
09:13:26 <opqdonut> dmhouse: well, as that's how fix is implemented in the Prelude, i'd say recursion is more fundamental
09:13:35 <dmhouse> There are many ways of defining the semantics of a program.
09:13:42 <opqdonut> dmhouse: because haskell runs on a turing machine
09:13:49 <dmhouse> opqdonut: yes, I'd probably agree with you for the case of Haskell.
09:13:53 <opqdonut> we are talking of the haskell case and not generically?
09:14:06 <dmhouse> Generically, neither are the more fundamental.
09:14:11 <dmhouse> IMO.
09:14:28 <opqdonut> yeah, of course generically not
09:14:59 <dmhouse> Recursion is certainly more natural in Haskell than fix, so it makes more sense to define fix in terms of recursion and not the other way around.
09:15:04 <opqdonut> i'd start by defining everything with combinators
09:15:13 <dmhouse> But that's not required, for example in TAPL Price uses fix throughout.
09:15:26 <opqdonut> yeah, of course
09:24:31 <Botje> @pl \x -> (x,True)
09:24:31 <lambdabot> flip (,) True
09:25:33 <glguy> ap (,) (const True)
09:25:57 <mauke> > let v_ f = fix (show . f) in v_ (take 10)
09:25:58 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\""
09:26:29 <pierre-> > foldr (,) [1..]
09:26:30 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
09:26:30 <lambdabot>       Expec...
09:26:39 <glguy> ?hoogle split
09:26:40 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
09:26:40 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
09:26:40 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
09:27:53 <mauke> > let v_ f = fix (show . f) in v_ (Just . head)
09:27:54 <lambdabot>  "Just 'J'"
09:28:03 <metaperl> @doc Data.Tree.Class
09:28:04 <lambdabot> Data.Tree.Class not available
09:29:12 <dmhouse> Botje: there are no nice sections for tuples, unfortunately. That lambda's probably the best you'll get.
09:31:01 <vincenz> am I ththe only one in thinking that factor is yucky/
09:31:22 <glguy> > map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:31:26 <lambdabot> Terminated
09:31:33 <glguy> > take 10 $ map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:31:34 <lambdabot>  [0,1,3,7,15,31,63,127,255,511]
09:32:25 <xerox> Those are the number of rank-1 matroids over S_n
09:32:25 <benja_> (moi tuukkah :))
09:32:28 <tuukkah> hello
09:32:49 <xerox> Numbers whose binary representation is 11..1
09:33:11 <xerox> Number of nonempty subsets of a set with n elements.
09:33:18 <glguy> > iterate (\x -> x * 2 + 1) 0
09:33:19 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
09:33:52 <xerox> (:
09:34:56 <ibid> tuukkah: hi :)
09:35:12 <dmhouse> xerox: rank-1 matroids over S_n?! They're 2^n - 1. :P
09:35:22 <dmhouse> Mersenne numbers, if you like.
09:35:47 <dmhouse> > take 3 $ filter isPrime map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:35:48 <lambdabot>   Not in scope: `isPrime'
09:37:19 <dmhouse> > take 3 $ filter (\z -> all ((/=0) . z `mod`) [2..floor(sqrt(fromIntegral z))] $ map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:37:19 <lambdabot>  Parse error
09:37:32 <dmhouse> > take 3 $ filter (\z -> all ((/=0) . z `mod`) [2..floor(sqrt(fromIntegral z))]) $ map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:37:32 <lambdabot>  Couldn't match `Bool' against `a -> Bool'
09:37:41 * dmhouse opens a query
09:38:22 <emu> have there been some significant improvements in ghc optimizer since 6.6?
09:38:44 <Botje> dmhouse: I agree. tuples are a PITA if you want all values
09:39:35 * benja_ is wondering how many keystrokes I could save by defining a short type constructor for (a -> a)
09:39:45 <mauke> BTDT
09:40:10 <mauke> type Id a = a -> a; type Filter a = Id [a]; type Combine a = a -> a -> a;
09:40:27 <benja_> category theory must have a spiffy name for an arrow from an object to itself :)
09:40:44 <benja_> mauke: hmm, I'd expect Id a to be the identity monad
09:40:52 <benja_> (whose actual name is Identity, of course)
09:41:03 <mauke> do you have a better name?
09:41:07 <benja_> no :(
09:42:34 <dmhouse> > take 6 $ filter (\z -> all (\y -> z `mod` y /= 0) [2..z-1]) $ map length $ unfoldr (\x -> let (a,b) = break (=='"') x in Just (a,tail b)) (fix show)
09:42:36 <lambdabot>  [0,1,3,7,31,127]
09:42:42 <dmhouse> There we go. Mersenne primes.
09:43:09 <dmhouse> mauke: Id is a bad name, it doesn't have to represent the identity function.
09:43:16 <dmhouse> (+1) :: Id Int
09:44:00 <mauke> I won't change it unless you have a better name
09:44:07 <dmhouse> Unless you meant it's identity morphism in the category of Haskell types and functional types as morphisms :)
09:44:25 <dmhouse> How about Endo?
09:44:44 <dmhouse> E.g. an endofunctor is one from some category to the same category.
09:44:44 <benja_> ah! knew there was a spiffy name :)
09:44:52 <mauke> that works
09:44:58 <dmhouse> Although is a bit longer.
09:45:52 <dmhouse> It'd only save characters for types less than 2 characters long.
09:46:13 <benja_> dmhouse: s/less/more/?
09:46:24 <benja_> or do you mean 'Id'?
09:46:33 <dmhouse> Err, sorry.
09:46:42 <chessguy> hi haskellers
09:46:48 <dmhouse> 'Endo' would only save characters for types greater than 1 character long.
09:47:09 <benja_> dmhouse: I have a few of those =)
09:47:31 <dmhouse> It's equal in the case of 2-character types, shorter for longer names.
09:47:40 <dmhouse> Yes, perhaps s/only// :)
09:48:09 <benja_> changeScene :: Endo (Scene k) -> Endo (Vob k)
09:48:35 <mauke> type Inject a m = a -> m a
09:49:21 <benja_> I turn out to have a lot of endos (which make sense to call endos, too)
09:51:00 <benja_> oh, that's not Endo (Vob k), that's Endo (Renderable k). more chars saved
09:51:06 <dmhouse> Hehe.
09:51:47 <SyntaxNinja> y0
09:51:47 <lambdabot> SyntaxNinja: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:51:57 <mauke> type Map m a b = m a -> m b
09:52:00 <chessguy> wow, popular guy
09:52:10 <mauke> changeScene :: Map Endo (Scene k) (Vob k)
09:52:12 <chessguy> must be the @galois.com :)
09:52:58 <dmhouse> mauke: ChangeSceneType :: (Scene k -> Scene k) -> (Vob k -> Vob k)
09:53:03 <dmhouse> changeScene :: ChangeSceneType :)
09:53:17 <SyntaxNinja> I just never get around to reading them.
09:53:21 <mauke> dmhouse: too much redundancy in the definition of ChangeSceneType
09:54:32 <SyntaxNinja> caml-get.  What a buncha lamers! ;)
09:54:42 <pierre-> mauke: maybe Mod? for modifications :-)
09:56:33 <benja_> the ones I briefly considered were Mod, Upd and Chg
09:58:08 <benja_> and Ref for reflexive
09:58:52 <benja_> but that would be a Bad Idea what with Ref sounding like reference and reflexive not being the category theoretical word I was looking for =)
09:59:49 <dmhouse> benja_: it's really a transformer.
10:00:14 <dmhouse> Not very CT, I suppose.
10:00:26 <benja_> hmm, but Trans is longer than Endo even and it's also really an endomorphism :)
10:00:45 <dmhouse> No, I meant in place of Map
10:00:59 <dmhouse> Oh, unless you mean Map is an endomorphism.
10:01:16 <benja_> oh, I misunderstood
10:01:26 <mauke> typwnd
10:03:14 <dmhouse> A stack is a linked list, right?
10:03:20 <xerox> dmhouse: the encyclopedia of integer sequences is fun :)
10:03:36 <dmhouse> (Or just a list if you're talking Haskell.)
10:03:36 <opqdonut> :)
10:03:55 <benja_> dmhouse: uh, I'd have thought the usual interpretation was as an array plus a 'top of stack' index
10:04:05 <benja_> s/interpretation/implementation/, sorry
10:04:34 <dmhouse> Assuming I just need push and pop, though, it'd more efficient to use a linked list.
10:05:05 <opqdonut> nyarrnyarr
10:05:17 <opqdonut> an array of pointers is more efficient
10:05:23 <opqdonut> but yes, nothing wrong with a list
10:05:33 <benja_> @arr
10:05:34 <lambdabot> Keelhaul the swabs!
10:07:18 <dylan> push being O(n) is not good
10:07:57 <benja_> dylan: push is O(1) (except if you have to grow the array
10:07:58 <benja_> )
10:07:59 <dmhouse> dylan: erm, it's not.
10:08:23 <benja_> oh, with lists. it's O(1) with that too, you use the first element as the top :)
10:08:40 <benja_> @hoogle Endo w -> Endo (Writer w a)
10:08:41 <lambdabot> No matches, try a more general search
10:09:03 <dylan> I'm presuming growing the array
10:09:04 <benja_> well, it was worth a try :)
10:09:07 <dmhouse> ?hoogle censor
10:09:08 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
10:09:11 <benja_> dylan: ok
10:09:27 <benja_> but if you grow it by a factor of 2, average push is O(log n)
10:09:43 <benja_> (it's true that that's more than O(1), though :))
10:09:55 <dmhouse> So surely a linked list is more efficient.
10:10:06 <dmhouse> You just allocate some space some where, link it up, and you're done.
10:10:47 <opqdonut> dmhouse: amortized O(1)
10:10:55 <opqdonut> an array stack
10:11:02 <dylan> a size-bounded stack as an array would be good.
10:11:20 <benja_> opqdonut: I think it's amortized O(log n)
10:11:24 <opqdonut> dmhouse: remember all the overhead with allocing
10:11:30 <opqdonut> benja_: of course not
10:11:31 <benja_> you have to copy the earlier elements again when you grow the stack again
10:11:40 <opqdonut> not necessarily
10:11:45 <benja_> hm?
10:11:46 <dmhouse> opqdonut: hrm, true.
10:12:00 <opqdonut> but given large enough starting size and increment it is amortized O(1)
10:12:13 <benja_> (allocating overhead is why I thought array was more efficient)
10:12:38 <benja_> opqdonut: I can't wrap my head around it, but I'll trust you =)
10:13:13 * dylan is implementing a stack based language atm
10:13:25 <benja_> (not with copying the earlier elements though. of course you have to copy them again (or make a linked list of arrays)! but I'll trust you if you say it averages out to O(1))
10:13:33 <mauke> dylan: False?
10:13:36 <xerox> > let push = modify . (:); pop = get >>= \(x:xs) -> put xs >> return x in runState (do push 1; push 2; push 3; x <- pop; pop; y <- pop; return (x,y)) []
10:13:37 <lambdabot>  ((3,1),[])
10:14:20 <opqdonut> benja_: we can make the resize interval as large as memory permits by increasing the size increment
10:14:27 <opqdonut> so it can be made am. O(1)
10:14:36 <psnl> liyang: do you look after gtk2hs for debian?
10:15:04 <dmhouse> ?hoogle modify
10:15:05 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
10:15:05 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
10:15:05 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
10:15:34 <dmhouse> xerox: pop = modify tail >> fmap head get, perhaps?
10:15:44 <dylan> Prelude> foldl (flip id) [] [lit 1, dup, add, dup, add]
10:15:44 <dylan> [4]
10:15:47 <dmhouse> Wait, ignore that.
10:16:04 <glguy> Why would you want pattern matching in your language when you can write pages of scaffolding and use a Vistor pattern? Why would you want a stronger type system when you can write a whole bunch of if statements that acn throw new ArgumentNullExceptions()? Hell, why do I even need functions, I have copy and paste!
10:16:08 <xerox> If you want, pop = ap (flip ((>>) . put) . return . head) tail =<< get.
10:16:18 <mauke> queues are fun, too
10:16:20 <dmhouse> Lovely. :)
10:18:45 <do-gooder-77> linux and haskell do they play well?
10:19:00 <opqdonut> yep
10:19:03 <vegai> yes
10:19:22 <benja_> changeContext :: Endo (RenderContext k) -> Endo (Renderable k)
10:19:27 <benja_> that one saved a newline
10:19:31 <opqdonut> \o/
10:19:34 <do-gooder-77> hmmmmm
10:19:40 <do-gooder-77> well lets install the bugger!!
10:23:20 <do-gooder-77> ghc hm ok generic linux binary ok, downlaoding
10:25:15 <do-gooder-77> ok
10:25:17 <do-gooder-77> now what
10:25:20 <do-gooder-77> yaht?
10:25:32 <glguy> are you asking us? or still talking to yourself/
10:25:34 <SyntaxNinja> do-gooder-77: sometimes Haskell is all like, "Why do I even need an OS, I've got a run time system, I don't need you anymore" but Linux is like, "oh yeah, right who is going to use you like that"
10:25:42 <SyntaxNinja> do-gooder-77: yaht is good.
10:26:07 <SyntaxNinja> do-gooder-77: I recommend reading yaht, playing with ghci and haskell-mode (if you're an emacs user)
10:27:02 <do-gooder-77> run time system meaning like os liek interrupts n stuff?
10:27:51 * nmessenger is not quite sure what SyntaxNinja meant, either.
10:28:31 <opqdonut> he meant that sometimes haskell itself seems enough
10:28:32 <glguy> GHC's RTS was used on bare metal in Hops or House
10:28:49 <mauke> gregory house?!
10:29:16 <opqdonut> no
10:34:36 <LoganCapaldo> from yaht: Saying that the type of fst is (a, b) -> a does not necessarily mean that it simply gives back the first element; it only means that it gives back something with the same type as the first element.
10:34:41 <LoganCapaldo> But doesn't it though?
10:34:57 <LoganCapaldo> Barring unsafePerformIO anyway?
10:35:37 <glguy> ?type let f (a,b) = undefined `asTypeOf` a
10:35:39 <lambdabot> not an expression: `let f (a,b) = undefined `asTypeOf` a'
10:35:41 <glguy> ?type let f (a,b) = undefined `asTypeOf` a in f
10:35:42 <lambdabot> forall a b. (a, b) -> a
10:36:11 <benja_> actually, barring only _|_
10:36:25 <pejo> Logan, the type alone doesn't convey that information, but of course fst returns the first element.
10:36:42 <pejo> dmhouse, still around?
10:36:43 <glguy> LoganCapaldo: I think that the point is that 'a' is a type var and not a value
10:36:52 <LoganCapaldo> glguy: I know
10:36:55 <benja_> pejo: it can only return the first element or bottom
10:36:56 <LoganCapaldo> err
10:37:03 <benja_> because of polymorphism
10:37:26 <glguy> ?hoogle a -> a
10:37:27 <lambdabot> Prelude.id :: a -> a
10:37:27 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:37:27 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:37:55 <benja_> lambdabot: 'put' seems a bit out of place there
10:38:04 <benja_> @no botsnack
10:38:05 <lambdabot> Maybe you meant: . bf ft id pl undo v wn yow
10:38:13 <benja_> @no, I didn't
10:38:13 <lambdabot> If elected, Zippy pledges to each and every American a 55-year-old
10:38:14 <lambdabot> houseboy ...
10:38:40 <glguy> ?yow --!
10:38:41 <lambdabot> All right, you degenerates!  I want this place evacuated in 20 seconds!
10:39:12 <xerox> :O
10:39:49 <vincenz> Lol
10:39:52 <vincenz> I read that as "evaluated"
10:39:57 <benja_> heh
10:40:02 <opqdonut> he
10:40:32 <benja_> lambdabot: sorry, we don't evaluate so eagerly here
10:42:35 <SyntaxNinja> nmessenger, do-gooder-77: yeah, glguy is right about what I meant.  with Haskell's run-time system, you hardly need an OS, and some folks have "ported" the RTS to very low-level code :)
10:43:18 <benja_> changeRender :: Endo (RenderContext k -> Render ()) -> Endo (Renderable k) -- !!!
10:44:48 <benja_> seems like I can really use this function and I might not have programmed it without Endo just because "its type is so ugly" =-]
10:45:44 <nmessenger> Hooray for user-defined types!
10:45:56 <benja_> =)
10:47:27 <DeliQ> Can you help me with a nice function definition for this pattern: http://prinse.host.sk/images/pattern.png, i was fiddling with intersperce and foldr, function must yield a String given n
10:47:44 <\z> Is anyone using HDBC-PostgreSQL here?
10:47:55 <\z> I'm having a really hard time debugging a module load error...
10:50:27 <glguy> DeliQ: you want to type: u 2 and have it generate the string?
10:50:34 <DeliQ> yup
10:50:37 <DeliQ> that would be evry nice
10:50:41 <Cale> > foldr (\x xs -> concat ["(P", show x, " <-> ", xs]) [] [1..3] ++ [1..3]
10:50:42 <lambdabot>   add an instance declaration for (Num Char)
10:50:42 <lambdabot>     In an arithmetic sequence: [...
10:50:42 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:50:44 <Cale> > foldr (\x xs -> concat ["(P", show x, " <-> ", xs]) [] ([1..3] ++ [1..3])
10:51:09 <Cale> slow lambdabot
10:51:17 <psnl> @seen liyang
10:51:18 <Cale> @bot
10:51:20 <DeliQ> let me test it in ghci
10:51:35 <Cale> er, forgot the )
10:51:40 <DeliQ> yep
10:51:41 <Cale> > foldr (\x xs -> concat ["(P", show x, " <-> ", xs, ")"]) [] ([1..3] ++ [1..3])
10:52:00 <Cale> and it should be foldr1
10:52:02 <DeliQ> "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> (P3 <-> ))))))"
10:52:06 <DeliQ> not quite...
10:52:16 <DeliQ> last <-> is spurious
10:52:52 <nmessenger> "P3" instead of [] ?
10:53:11 <DeliQ> it must be like this: "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> P3)))))"
10:53:21 <Cale> > foldr1 (\x xs -> concat ["(P", x, " <-> ", xs, ")"]) $ map show ([1..3] ++ [1..2]) ++ ["P3"]
10:53:33 <mauke> > let p i n s | i > n = s | otherwise = "(P" ++ show i ++ " <-> " ++ p (succ i) n s ++ ")"; f n = p 1 n (p 1 (pred n) ("P" ++ show n)) in f 3
10:53:37 <Cale> that works, but it's a little awkward
10:53:45 <glguy> > let f x xs = concat ["(P", show x, " <-> " , xs, ")"] in foldr f (foldr f "P3" [1..2]) [1..3]
10:53:54 <glguy> now just factor out the repitition
10:53:58 <glguy> repetition
10:54:24 <DeliQ> glguy: ty!!
10:54:25 <Cale> ah, that works well
10:54:33 <DeliQ> you're the best :P
10:54:41 <DeliQ> Cale: thank you!!
10:55:02 <LoganCapaldo> data P = P Int | P :<-> P deriving Show ;)
10:55:04 <glguy> > let f x xs = concat ["(P", show x, " <-> " , xs, ")"] in let u n = foldr f (foldr f ('P' : show n) [1..n-1]) [1..n] in u 3
10:55:27 <allbery_b> hmmmm
10:55:45 <glguy> so lambdabot died?
10:55:52 <nmessenger> ?bot
10:55:59 <nmessenger> :(
10:56:01 <allbery_b> still hnere, yet not
10:56:12 <allbery_b> and ignoring commands even in privmsg
10:56:18 <glguy> that code worked in WinHugs for u 1 and u 3, so...
10:56:26 <glguy> I guess it's okay if lambdabot doesn't show it
10:56:36 <DeliQ> in ghci it works with higher n also
10:56:44 <nmessenger> LAMBDABOT!!  WE NEED YOU!!
10:56:48 <pejo> benja, sure. Given small enough type we don't have that many alternatives.
10:57:03 <glguy> u 0 = "P0" -- is that "correct" ?
10:57:08 <DeliQ> nope
10:57:17 <DeliQ> (P1 <-> P1) is base case
10:57:21 <glguy> ah
10:57:23 <glguy> ok
10:57:32 <DeliQ> but it's for our theorem prover
10:57:35 <DeliQ> i need long formulas
10:57:37 <psnl> nmessenger: where we are going, we don't need lambdabot.....
10:57:38 <DeliQ> :P
10:58:12 <DeliQ> i guess "P0" is right
10:59:14 <mauke> my function also generates "P0"
10:59:22 <mauke> I guess that means it's right :-)
11:01:26 <glguy> OK, so what does U2 "mean"
11:01:45 <DeliQ> glguy: don't know
11:02:03 <DeliQ> glguy: it's just an artificial propostional logic problem generator
11:02:32 <DeliQ> glguy: to give our theorem prover a hard time :P
11:03:06 <yuesefa> if darcs get fail, how can i continue? my network sucks now
11:07:01 <paolino> @seen Cale
11:07:48 <glguy> aw man... paolino killed lambdabot
11:08:05 <yuesefa> @>
11:08:11 <benja_> @bot... @botbot... @botbotbot...
11:08:27 <yuesefa> @search
11:08:39 <LoganCapaldo> So, is there a way to make my version work without it turning into the actual version?
11:08:43 <lisppaste2> LoganCapaldo pasted "Trying to cheat on the U n thing" at http://paste.lisp.org/display/33962
11:08:57 <paolino> mmhh, I'm nervous ,sorry
11:09:17 <paolino> @pardon paolino
11:09:48 <conal> Does anyone know whether Id is in the standard/base lib, and if so where?  (newtype Id a = Id a)
11:10:16 <benja_> conal, there's Identity but not Id afaik
11:10:32 <conal> benja_: same thing?  where is it?
11:10:45 <benja_> conal: let me use the web to hoogle :)
11:11:00 <conal> ohh -- forgot about hoogle
11:11:05 <benja_> Control.Monad.Identity
11:11:31 <allbery_b> @taps
11:11:40 <conal> benja_: thanks!  (including the hoogle reminder)
11:11:46 <benja_> np :)
11:12:12 <paolino> anyone knows how to force
11:12:13 <paolino> getSome xs ns = map ((listArray (0,length xs -1) xs) !) ns
11:12:13 <paolino> to use DiffArray, without constraining  xs and ns ?
11:12:35 <pejo> conal, working on Phooey?
11:12:56 * nmessenger giggles at 'getSome'
11:13:12 <conal> pejo: i'm building onto phooey, bridging the gap between phooey and eros.
11:14:06 <glguy> paolino: why would you want that code to use a DiffArray?
11:14:17 <dmhouse> pejo: am now.
11:15:08 <lisppaste2> LoganCapaldo annotated #33962 with "Got it" at http://paste.lisp.org/display/33962#1
11:15:13 <pejo> conal, eros is Pan, formulated as arrows?
11:15:20 <paolino> glguy: because it doesn't make the memory consumption explode, in my program
11:16:26 <pejo> dmhouse, as for the why - why not ask the same question about Beta_n in that case?
11:16:47 <dmhouse> What's Beta_n?
11:17:02 <conal> pejo: much more than that.  eros is a "tangible programming".  a way to compose computational values in a direct, non-syntactic way.
11:17:22 <pejo> dmhouse, beta-reduction for a cbn-language.
11:18:11 <dmhouse> pejo: I've lost context, what point are you making?
11:19:25 <glguy> to borrow from LoganCapaldo
11:19:26 <glguy> let f x xs = concat ["(", x, " <-> " , xs, ")"] in let u n = foldr1 f (map (('P':).show) ([1..n-1]++[1..n])) in u 3
11:19:45 <paolino> glguy, that is not the actual function of my code, I made it to investigate this typing problem I have
11:19:56 <pejo> dmhouse,  we were discussing fix earlier, and you said you need denotational semantics for understanding why.
11:20:01 <glguy> paolino: that makes more sense
11:20:03 <nmessenger> s/ in let/;/
11:20:04 <lisppaste2> metaperl pasted "SF / runSF questions" at http://paste.lisp.org/display/33964
11:20:16 <paolino> :)
11:20:52 <glguy> metaperl: (SF f) >>> (SF g) maybe?
11:20:57 <benja_> I can't figure out why there is no Control.Monad.Maybe. perhaps it's because I haven't written and submitted it yet?
11:21:08 <paolino> yes, in that code I don't need DiffArray, as the array never change, right ?
11:21:10 <dmhouse> benja_: there's a Data.Maybe, that what you want?
11:21:13 <benja_> (containing a monad transformer, like Control.Monad.List)
11:21:21 <dmhouse> ?hoogle MaybeT
11:21:23 <metaperl> glguy - you comment doesnt make any sense to me...
11:21:41 <dmhouse> > 1 + 1
11:21:47 <dmhouse> Someone's tying up lambdabot.
11:21:51 <glguy> metaperl: I didn't know if SF f >>> SF g would pattern match or not
11:22:12 <nmessenger> dmhouse: she's been out of it for a few minutes now
11:22:13 <benja_> dmhouse: yes, it hasn't worked for a while. :-/ hoogle knows no MaybeT
11:22:14 <dmhouse> benja_: you're right, there doesn't appear to be a MaybeT around.
11:22:21 <metaperl> The first question is :   arr f = SF (map f)   -- binding runSF???
11:22:53 <dmhouse> dons: ping
11:26:00 <do-gooder-77> got ghci going on linux
11:26:12 <do-gooder-77> ok what now, give me something cool to type in!
11:26:20 <do-gooder-77> :)
11:26:38 <glguy> now follow along with YAHT
11:27:00 <nmessenger> 'l' : repeat "ol"
11:27:03 <do-gooder-77> :-D
11:27:15 <dmhouse> do-gooder-77: how about let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
11:27:18 <nmessenger> s/repeat/cycle/
11:28:36 <benja_> hmm, 'mplus' for MaybeT is interesting, there's the choice of whether to execute the second argument if the first one succeeds
11:28:45 <benja_> I'm pretty sure I shouldn't, any other opinions?
11:29:03 <SamB> ... why would you do that?
11:29:19 <dmhouse> What does, e.g. ErrorT (the Either monad transformer) do?
11:29:28 <conal> metaperl: not sure i understand your question.  are you wondering about pattern-matching and records?
11:29:33 <dmhouse> ?libsrc Control.Monad.Error
11:29:44 <dmhouse> Gah, I forgot.
11:29:52 <SamB> mplus for IO only runs the second one if the first one fails, right?
11:30:05 <conal> metaperl: does the code work and you want to understand it?  or does it not work?
11:30:13 <benja_> SamB: I don't know why you would, that's why I'm asking :)
11:30:20 <metaperl> conal - yes. I looked up named fields in YAHT.. and the answer is that the code is doing pattern matching when it had the option of doing pattern-matching or using named fields... thanks for the feedback
11:30:24 <nmessenger> LB becomes kinda like an extension of your own body after awhile.  Losing her is like losing a limb :(
11:30:28 <benja_> I didn't know that IO implemented MonadZero
11:30:35 <benja_> erm, MonadPlus
11:30:41 <SamB> hehe
11:30:48 <SamB> I didn't either...
11:30:53 <conal> metaperl: so your questions are cleared up now?
11:31:12 <do-gooder-77> ok
11:31:14 <metaperl> conal - yes. thanks... unless you understand how that first works
11:31:19 <glguy> SamB: runs the second if the first cause an exception
11:31:21 <do-gooder-77> that fib thing didnt work
11:31:23 <do-gooder-77> lol
11:31:23 <metaperl> i'm trying to figure out how the arrows fuse
11:31:27 <metaperl> @type unzip
11:31:28 <do-gooder-77> cuz i didnt try it
11:31:42 <SamB> glguy: yeah -- that is what it considers to be failure
11:31:43 <benja_> "No instance for (MonadPlus IO)"
11:31:55 <SamB> import Control.Monad.Instances
11:32:01 <SamB> ?
11:32:19 <benja_> ghci can't find such on my system
11:32:30 <dmhouse> ?instance MonadPlus
11:32:31 <opqdonut>  No instance for (MonadPlus IO)
11:32:33 <opqdonut> yeah
11:32:41 <dmhouse> Heh, forgot again.
11:32:53 <nmessenger> darnit, I almost did a ?seen dons to see if he's around to fix LB, but I'd need LB for ?seen :D
11:32:55 <benja_> I thought IO was the classical example of a monad not implementing MonadPlus :)
11:33:11 <SamB> benja_: yeah, me too...
11:33:12 <conal> metaperl: hm.  i'd expect "map (first f)" in place of "first f".
11:33:20 <SamB> oh well, it was a page on the old wiki...
11:33:28 <dmhouse> It's a slightly different MonadPlus, it obeys different rules.
11:33:31 <mauke> ?fix lambdabot
11:33:41 <conal> metaperl: make that "first (map f)"
11:33:50 <conal> metaperl: does this thing type-check?
11:34:09 <metaperl> conal - i dont know. it came from someone's PDF file (an M.S. thesis)
11:34:26 <metaperl> I guess I could import Control.Arrow and try it out
11:34:58 <conal> metaperl: yeah - do
11:35:15 <metaperl> roger :)
11:35:26 <benja_> anyhow, it just seems right not to run the second action when the first gives Just. I'll do it that way
11:35:40 <benja_> more useful that way, too
11:36:33 <conal> metaperl: let's type-analyze it here, with lambdabot
11:36:38 <lisppaste2> metaperl annotated #33964 with "conal - it type checks" at http://paste.lisp.org/display/33964#1
11:36:44 <dmhouse> conal: lambdabot's dead.
11:36:54 <conal> metaperl: for me too.
11:36:56 <metaperl> i can annotate the paste with type signatures
11:37:04 <conal> :type unzip
11:37:18 <conal> @type unzip
11:37:24 <dmhouse> conal: lambdabot's dead.
11:37:31 <conal> dmhouse: oh -- thanks.
11:37:45 * vegai sobs quietly
11:38:13 <dmhouse> + type unzip
11:38:26 <dmhouse> +type unzip
11:38:29 <hsbot> forall a b. [(a, b)] -> ([a], [b])
11:38:30 <lisppaste2> metaperl annotated #33964 with "ok type annotated" at http://paste.lisp.org/display/33964#2
11:38:31 <conal> metaperl: oh -- i see.
11:38:32 <dmhouse> Yay.
11:38:36 <xerox> > 2+2
11:38:40 <dmhouse> We're back in business.
11:39:00 <mauke> @bawt
11:39:06 <dmhouse> Use + as the command prefix
11:39:11 <benja_> +bot
11:39:12 <hsbot> :)
11:39:12 <dmhouse> > 2 + 2 -- this should work though.
11:39:12 <xerox> +runplugs 2+2
11:39:12 <hsbot> Unknown command, try @list
11:39:19 <xerox> +plugs 2+2
11:39:19 <hsbot> Unknown command, try @list
11:39:22 <dmhouse> Oh, sorry, seems eval isn't working.
11:39:23 <xerox> I never remember what is it.
11:39:27 <metaperl> conal - i'm not sure I do...
11:39:44 <dmhouse> I can try and fix that, or you can play with an eval-less lambdabot. Votes?
11:39:58 <dmhouse> +elite everything else should work
11:39:58 <hsbot> 3v3ryThIng ELze 5H0Uld w0Rk
11:40:06 <xerox> dmhouse: ghc6.6?
11:40:16 <dmhouse> With the exception of things like fortune that rely on exterior files.
11:40:20 <dmhouse> xerox: yep, why?
11:40:27 <xerox> Then it takes dons to fix that.
11:40:41 <dmhouse> xerox: hsbot is running on my box, what's the fix?
11:40:41 <mauke> +list
11:40:41 <hsbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:40:43 <xerox> hs-plugins does not work with 6.6.
11:40:44 <conal> metaperl:  f :: ([(a,a')] -> [(b,b')]
11:41:11 <pierre-> s
11:41:17 <pierre-> xerox: really?
11:41:26 <xerox> Yet.
11:41:44 <mauke> +run ()
11:41:45 <hsbot> eval module failed: IRCRaised Data.ByteString.last: empty ByteString
11:42:26 <SamB> +version
11:42:27 <hsbot> lambdabot 4p352, GHC 6.6 (Linux i686 1.70GHz)
11:42:27 <hsbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:42:35 <SamB> +yow
11:42:36 <hsbot> Couldn't find fortune file
11:42:45 <dmhouse> SamB: I did a darcs pull so it should be up to date.
11:42:50 <metaperl> conal - do you get private message?
11:43:01 <SamB> dmhouse: so why don't you have external files?
11:43:08 <dmhouse> I don't have fortune installed.
11:43:38 <dmhouse> It's a seperate program.
11:43:58 <SamB> I don't think you need the program installed
11:44:39 <dmhouse> I just installed a package that looks like it might have the fortune cookies in it.
11:44:53 <dmhouse> Also, the fortunePath is currently "/home/dons/fortune", I'll need to change that and recompile.
11:45:32 <SamB> yeah
11:45:52 <SamB> +spell boze
11:45:53 <hsbot> booze Bose bozo Bone Roze
11:46:54 <JKnecht> hsbot: @version
11:47:02 <dmhouse> JKnecht: + is the command prefix.
11:47:13 <JKnecht> hsbot: +version
11:47:13 <hsbot> lambdabot 4p352, GHC 6.6 (Linux i686 1.70GHz)
11:47:13 <hsbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:47:16 <mauke> +id di+
11:47:17 <hsbot>  di+
11:47:41 <dmhouse> All right kids, I'm going to recompile then +yow should work.
11:48:05 <vegai> Is it even possible to get eval working without hs-plugins?
11:48:48 <dmhouse> Hrm, it seems to be recompiling everything, which is odd, I only changed the config file.
11:49:14 <pierre-> vegai: i don't think so
11:50:05 <xerox> vegai: yep, if you mean the ?run command, just talk to ghci directly, like ?type does.
11:50:20 <dmhouse> +yow
11:50:25 <hsbot> Couldn't find fortune file
11:50:27 <dmhouse> Pfft.
11:50:29 <dmhouse> Ah well.
11:50:31 <do-gooder-77> 2+2 so haskell is not lispy
11:50:32 <xerox> vegai: I wouldn't do it on my box anyway :)
11:50:33 <mauke> +spell pwnd
11:50:34 <do-gooder-77> hm
11:50:34 <hsbot> pend pond pawned pends owned
11:50:41 <dmhouse> do-gooder-77: you can do (+) 2 2, if you want.
11:50:58 <vincenz> ((+) 2 2)
11:50:59 <vincenz> > ((+) 2 2)
11:51:10 * vincenz pokes Leffe_ 
11:51:13 * vincenz pokes lambdabot even
11:51:17 <dmhouse> vincenz: won't work, lambdabot's down.
11:51:21 <vincenz> Poor girl
11:51:32 <dmhouse> You can use my hsbot, but ?eval doesn't work on my box.
11:51:34 <xerox> Anybody has got GHC 6.4 and darcs? (:
11:51:36 <dmhouse> + is the command prefix.
11:51:38 <benja_> +bot
11:51:38 <hsbot> :)
11:51:48 <vincenz> + ((+) 2 2)
11:51:59 <mauke> still pulling
11:52:06 <xerox> --partial
11:52:16 <Botje> @pl \x y -> (length $ show x) == (length $ show y)
11:52:19 <dmhouse> Which plugin is +yow from?
11:52:20 <xerox> ah, pulling, nevermind
11:52:27 * Botje nudges lambdabot 
11:52:31 <dmhouse> +pl \x y -> (length $ show x) == (length $ show y)
11:52:31 <hsbot> (. (length . show)) . (==) . length . show
11:52:32 <xerox> Botje: join liftM (==) (length . show)
11:52:40 <xerox> Botje: join (liftM (==)) (length . show)
11:52:48 <Botje> thanks xeroxbot ;)
11:53:03 <xerox> ^_^
11:53:06 <do-gooder-77> ok
11:53:08 <Botje> and tahnks, dmhouse, didn't see it
11:53:26 <do-gooder-77> how do i do a function for the gains of capital x at rate of interest y for z years
11:53:28 <do-gooder-77> ;)
11:53:40 <pierre-> how the instance Read is automatically derived? i can read that i showed?
11:53:49 --- mode: ChanServ set +o dmhouse
11:53:49 <nmessenger> Interest formula?
11:53:51 --- topic: set to 'Lambdabot is currently dead, use hsbot instead, + is the command prefix, > doesn't work. ["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dmhouse
11:53:56 --- mode: dmhouse set -o dmhouse
11:54:18 <Cale> oh, I could've brought mbot in too
11:54:27 <dmhouse> Cale: that would have been easier :)
11:54:34 <dmhouse> Cale: if you would.
11:54:40 <dmhouse> hsbot: +quit
11:54:47 <Cale> % Integrate[Sqrt[Sin[x]],x]
11:54:50 <mbot> Cale: -2*EllipticE[(Pi/2 - x)/2, 2]
11:54:50 <dmhouse> > 2 + 2
11:54:52 <mbot>  4
11:54:53 <nmessenger> mbot: so how do I talk to you?
11:54:56 <dmhouse> Wonderful.
11:54:58 <dmhouse> ?yow
11:54:59 <mbot> Somewhere in DOWNTOWN BURBANK a prostitute is OVERCOOKING a LAMB CHOP!!
11:55:06 <dmhouse> Thanks Cale.
11:55:07 <Cale> > foldr (+) 0 [1..20]
11:55:08 <xerox> do-gooder-77: f x y z = iterate (ap (+) ((*y) . (/100))) x) !! z -- I think
11:55:09 <mbot>  210
11:55:26 --- mode: ChanServ set +o dmhouse
11:55:27 --- topic: set to '["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dmhouse
11:55:30 --- mode: dmhouse set -o dmhouse
11:55:37 <glguy> :t id
11:55:41 <dmhouse> ?type id
11:55:41 <nmessenger> xerox: gah! put some points in there for God's sake!
11:55:42 <mbot> forall a. a -> a
11:55:55 <glguy> dmhouse: I'm aware of ?type, but lambdabot was :t and :k
11:55:59 <glguy> has8
11:56:01 <glguy> has*
11:56:10 <dmhouse> glguy: no, you're thinking GHCi.
11:56:14 <glguy> dmhouse: nope
11:56:19 <dmhouse> No, really, you are.
11:56:26 <glguy> dmhouse: no, serious, dons added :k and :t
11:56:27 <dmhouse> ?kind Maybe
11:56:28 <mbot> * -> *
11:56:47 <nmessenger> I've used :t here in #haskell
11:56:50 <dmhouse> In which case Cale's mbot probably just isn't recent enough.
11:56:57 <glguy> dmhouse: which is what I was checking
11:57:03 <Cale> yeah, it's not recent
11:57:12 <dmhouse> glguy: okay.
11:57:15 <dmhouse> glguy: sorry. :)
11:59:38 <nmessenger> ?type \r n t P -> P * (1 + r/n) ^ (n * t)
11:59:39 <mbot> Not in scope: data constructor `P'
11:59:39 <mbot>  
11:59:39 <mbot> <interactive>:1:12: Not in scope: data constructor `P'
11:59:48 <nmessenger> ?type \r n t p -> p * (1 + r/n) ^ (n * t)
11:59:49 <mbot> forall a. (Fractional a, Integral a) => a -> a -> a -> a -> a
12:00:16 <nmessenger> should that use a different power function?
12:00:52 <mauke> great, it wants regexes
12:01:58 <do-gooder-77> why is haskell better than scheme?
12:02:04 <do-gooder-77> (im unwashed and ignorant)
12:02:13 <mbishop> take a bath hippy
12:02:15 <norpan> because the irc channel is better
12:02:31 <SamB> type checking!
12:02:33 <do-gooder-77> wells omeone said lazy eval better than macro
12:02:36 <vegai> I enjoy both, really.
12:02:48 <do-gooder-77> paul graham said type checking mean no exploratory progrmaming
12:02:49 <glguy> ?protontorpedo
12:02:49 <mbot> smalltalk is oo
12:02:49 <SamB> type checking is good for people with ADD
12:02:50 <norpan> the answer to your question is mu
12:02:52 <vegai> scheme for its simplicity
12:02:53 <mbishop> scheme has lazy evaluation, but you have to be explicit about it
12:02:57 <SamB> do-gooder-77: not a bit true!
12:02:57 <glguy> ?protontorpedo
12:02:57 <mbot> can haskell do same stuff as J2EE but nicer?
12:03:10 * vegai chuckles.
12:03:14 <do-gooder-77> oh?
12:03:25 <do-gooder-77> I dont know shit so i blieve crazy harvard men on first pass
12:03:27 <glguy> Is exploratory programming where you find out you have bugs when you are running your program?
12:03:29 <xerox> ?type ((.) (!!)) . iterate . ap (+) . (. (/100)) . (*) -- nmessenger, though f y x z not f x y but I also got a live even if it doesn't seem so
12:03:30 <mbot> forall a. (Fractional a) => a -> a -> Int -> a
12:03:48 <do-gooder-77> he said real macros mean you have to have code be data
12:03:52 <glguy> ?protontorpedo
12:03:53 <mbot> is it a form of lisp?
12:03:54 <do-gooder-77> or something
12:03:57 <mbishop> I too, like scheme and haskell, they have their uses
12:04:02 <norpan> if anybody tells you that a computer language is better than another you should question it
12:04:08 <do-gooder-77> hm
12:04:10 <glguy> ?protontorpedo
12:04:10 <mbot> how is haskell different than java?
12:04:16 <glguy> I'm glad you asked!
12:04:19 <mbishop> heh
12:04:29 <sieni> ?protontorpedo
12:04:30 <mbot> help please
12:04:32 <sieni> ?protontorpedo
12:04:32 <mbot> hakell is not lisp or ml right?
12:04:43 <glguy> more ML than lisp
12:05:17 <temujin> mlisp
12:05:26 <vincenz> no
12:05:30 <vincenz> if you place it on a scale
12:05:30 <vincenz> you have
12:05:34 <vincenz> lisp ... ML ... haskell
12:05:35 <dmhouse> class Monad m => MonadLisp where mlisp :: ...
12:05:40 <sieni> ?protontorpedo
12:05:43 <mbot> is haskell able to outdo perl or python for web?
12:05:52 <temujin> haskell does web?
12:05:58 <dmhouse> ?where happs
12:06:03 <mbot> http://happs.org
12:06:04 <dmhouse> temujin: yep :)
12:06:06 <norpan> i want haskell to do my dishes
12:06:13 <temujin> wow... this language amazes me even more
12:06:18 * dmhouse has written forum software in Haskell
12:06:38 <pierre-> dmhouse: with happs?
12:06:41 <temujin> of course... now that I have installed ghc 6.6 ... I dunno what to use it for
12:06:42 <vegai> dmhouse: did you use HAppS?
12:06:48 <dmhouse> pierre-, vegai: yes.
12:06:53 <dmhouse> Source isn't online yet.
12:07:01 <dmhouse> I need somewhere to host it, mostly.
12:07:03 <temujin> kinda like how I installed octave thinking holy crap its cool... but what do I use it for?
12:07:05 <xerox> temujin: take a tutorial/book and work through the exercises?
12:07:13 <vegai> somebody give that man a server!
12:07:22 <dmhouse> I may apply for a haskell.org account.
12:07:23 <temujin> dmhouse want a slow server?
12:07:29 <dmhouse> I have no idea how it'd be done.
12:07:31 <temujin> I can let you use mine
12:07:36 <dmhouse> temujin: if you give me shell access :)
12:07:48 <temujin> obviously... how else do you give someone a server?
12:08:25 <temujin> the first rootkit or other exploit I find... meh.. who am I kidding... I probably will be completely oblivious
12:08:26 <vegai> a pedantic would mail him some hardware
12:08:35 <temujin> hehe
12:08:53 <dmhouse> I don't have shell access to my personal website.
12:08:54 <glguy> a pedant?
12:08:54 <temujin> dmhouse before I do give y ou that... what content are you going to be serving off o it?
12:09:08 <temujin> how do you run an effective website without shell access?
12:09:12 <temujin> oh... IIS?
12:09:13 <temujin> hehe
12:09:14 <dmhouse> temujin: if this is going to be a hassle don't worry about it, there are plenty of other avenues I could persue.
12:09:42 <glguy> vegai: a pedant would correct your use of "pedantic" ;) if such a pedant existed
12:09:58 <dmhouse> glguy: a meta-pedant? :)
12:10:00 <temujin> indeed... I just will have to create a user for you on this box... just gotta make sure my access to the internet isn't slowed to a crawl
12:10:08 <nmessenger> There Are No Pedants Here, Really.
12:10:14 <temujin> hence my question on the content
12:10:15 <glguy> dmhouse: quite possibly...
12:10:20 <vegai> glguy: indeed
12:10:22 <dmhouse> temujin: well, what's your bandwidth like?
12:10:30 <temujin> 50kbyte/sec up
12:10:33 * vegai awards glguy a 'pedant' pendant.
12:10:37 <temujin> its a server sitting on a cable modem
12:10:41 <temujin> :)
12:10:55 <dmhouse> temujin: do you have darcs?
12:11:13 <glguy> temujin: seems like an unstable situation
12:11:24 <temujin> darcs?
12:11:38 <temujin> glguy it works well enough for me... I run mungbeanexpress.net off of it
12:11:44 <glguy> your server is balancing on your modem, and you don't even use darcs? sounds scary
12:11:49 <dmhouse> Hehe.
12:11:49 <temujin> oo distribution control system...
12:11:51 <temujin> no sir I do not
12:12:04 <dmhouse> Darcs is a modern revision control system, used in most Haskell projects.
12:12:17 <glguy> possibly because it is written in haskell
12:12:20 <temujin> ahh...
12:12:21 <temujin> hehe
12:12:27 <dmhouse> Could have something to do with it.
12:12:31 <nmessenger> ?where darcs
12:12:31 <mbot> http://darcs.net/
12:12:37 <temujin> http://en.wikipedia.org/wiki/Darcs
12:12:53 <temujin> One notable, aspect of darcs is that it is written in the Haskell programming language, <-- from the wiki
12:12:56 <vegai> a little bit of NIH there :P
12:13:19 <dmhouse> vegai: as in the Knights Who Say?
12:13:30 <dino-> Not Invented Here
12:13:33 <lisppaste2> metaperl annotated #33964 with "unzip >>> first f   -- for stream functions confuses me" at http://paste.lisp.org/display/33964#3
12:13:39 <vegai> whichever is funnier
12:13:42 <dmhouse> :)
12:13:58 <glguy> dmhouse: those would be some silly kuhniguts, wouldn't they
12:14:45 * dmhouse was briefly worried about how a Monty Python reference would go down in an international channel, but never mind. :)
12:15:03 <xerox> metaperl: (>>>) = flip (.)
12:15:26 <metaperl> @type (>>>)
12:15:27 <mbot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
12:15:34 <metaperl> it's not so simple
12:15:35 <xerox> Use a = (->).
12:15:37 <dmhouse> It connects two arrows together.
12:15:52 <metaperl> i know what it does
12:15:53 <glguy> I read an interesting criticism of people that quote Monty Python movies. it went something to the effect of monty python being so clever because everything that they did was so unexpected, so to honor them, people repeat their material over and over until it is old hat
12:15:54 <xerox> Or you're sticking to a different arrow?
12:16:04 * SamB wonders why his spheres are shadowing so wierdly...
12:16:23 <xerox> From that use of unzip I think you're using the (->) arrow.
12:16:26 <temujin> glguy hehe true true
12:16:43 <xerox> If that is correct, you just have first f (x,y) = (f x,y).
12:16:52 <nmessenger> glguy, Have you read maddox's rant on people who say "I'm Rick James, bitch!"?
12:16:53 <temujin> glguy unless of course you do your own random thing in the style of monty python
12:17:00 <olliej> > let y = \f x -> case x of [] -> 0; | (x:xs) -> f x * (y xs); in y [2,3,4]
12:17:00 <mbot>  Parse error
12:17:16 <xerox> olliej: | is not needed
12:17:22 <bd_> xerox: wouldn't that make f an infinite type?
12:17:24 <metaperl> xerox - I see your reasoning. How would you know that (->) is the arrow
12:17:32 <olliej> > let y = \f x -> case x of [] -> 0; (x:xs) -> f x * (y xs); in y [2,3,4]
12:17:33 <mbot>  Couldn't match `a -> [a] -> t' against `[a]'
12:17:39 <xerox> metaperl: is that a question?
12:17:41 <olliej> xerox: cheers
12:17:42 <dmhouse> olliej: you need to pass a function as well.
12:17:52 <dmhouse> olliej: what is this meant to be, anyway?
12:17:53 <xerox> bd_: nope.
12:17:55 <olliej> > let y = \f x -> case x of [] -> 0; (x:xs) -> f x (y xs); in y (*) [2,3,4]
12:17:56 <mbot>  Couldn't match `a -> ([a] -> t) -> t' against `[a]'
12:17:57 <metaperl> yes, how do you know what arrow is in use?
12:18:17 <olliej> dmhouse: am playing
12:18:24 <dmhouse> olliej: now you need to pass that function down when you recurse.
12:18:27 <olliej> dmhouse: i keep forgetting the case syntax :D
12:18:32 <dmhouse> > let y = \f x -> case x of [] -> 0; (x:xs) -> f x (y f xs); in y (*) [2,3,4]
12:18:33 <mbot>  0
12:18:36 <olliej> > let y = \f x -> case x of [] -> 0; (x:xs) -> f x (y f xs); in y (*) [2,3,4]
12:18:37 <mbot>  0
12:18:38 <bd_> xerox: f (x,y) = (f x, y) ; f :: p@(p, y) -> e@(e, y) ?
12:18:40 <xerox> metaperl: unify types
12:18:42 <olliej> i am a muppet
12:18:43 <dmhouse> olliej: that's basically a fold.
12:18:57 <olliej> dmhouse: hehe -- true
12:18:57 <dmhouse> > foldl (*) 0 [2..4]
12:18:59 <mbot>  0
12:19:01 <xerox> ?type (unzip >>>)
12:19:03 <mbot> forall a b d. (([a], [b]) -> d) -> [(a, b)] -> d
12:19:14 <olliej> > let y = \f x -> case x of [] -> 1; (x:xs) -> f x (y f xs); in y (*) [2,3,4]
12:19:15 <mbot>  24
12:19:37 <xerox> Dinner. BBL.
12:19:40 <bd_> :t let f = \ (x, y) -> (f x, y) in f
12:19:45 <bd_> oh
12:19:45 <metaperl> ok
12:20:05 <bd_> well, it's an infinite type anyway
12:20:18 <xerox> bd_: what is an infinite type?
12:20:30 <bd_> it's a type which occurs in itself
12:20:34 <nmessenger> ?type iterate head
12:20:34 <xerox> hehe
12:20:35 <mbot>   Occurs check: cannot construct the infinite type: a = [a]
12:20:35 <mbot>    Expected type: [a] -> [a]
12:20:40 <bd_> for example, a list of lists of lists of lists .....
12:20:42 <xerox> > first (*2) (100,0)
12:20:42 <do-gooder-77> monty python is funny
12:20:43 <mbot>  (200,0)
12:20:45 <bd_> or a function which returns itself
12:20:48 <xerox> what is infinite there?
12:20:51 <bd_> f@(a -> f)
12:20:52 <do-gooder-77> we are the knights who sayyyyyyyyyy
12:21:01 <bd_> f@ isn't legal haskell syntax, note
12:21:15 <dmhouse> bd_: it's legal in a pattern.
12:21:18 <xerox> bd_: I know what is an infinite type, but there's nothing infinite going on there.
12:21:20 <bd_> Not in a type
12:21:21 <dmhouse> Oh, sorry, I get what you mean.
12:21:30 <nmessenger> you can take the head of a list, but doing it recursively forever would require an infinitely nested list
12:21:41 <glguy> xerox: his example was not "first"
12:21:45 <bd_> xerox: You said: f (x, y) = (f x, y) which is infinite. If infinite types were permissibly the type would be:
12:21:55 <glguy> ?type let f (x, y) = (f x, y) in f
12:21:56 <mbot>   Occurs check: cannot construct the infinite type: a = (a, b)
12:21:57 <mbot>    Expected type: a
12:21:57 <bd_> f :: p@(p, y) -> e@(e, y)
12:21:59 <vincenz> dmhouse: !
12:22:04 <dmhouse> bd_: that's a typo.
12:22:05 <xerox> bd_: no. |first f (x,y) = (f x, y)|
12:22:06 <bd_> oh
12:22:08 <vincenz> dmhouse: come come, need to ask you something
12:22:12 <dmhouse> ?type let first f (x, y) = (f x, y)
12:22:13 <mbot> not an expression: `let first f (x, y) = (f x, y)'
12:22:15 <dmhouse> ?type let first f (x, y) = (f x, y) in first
12:22:16 <mbot> forall a a1 b. (a -> a1) -> (a, b) -> (a1, b)
12:22:33 <xerox> > (unzip >>> first sum) (zip [0..] "bd_")
12:22:34 <bd_> oh, I missed the first XD
12:22:34 <mbot>  (3,"bd_")
12:22:46 <xerox> Gotta run.
12:22:49 <Cale> :type let first' f (x,y) = first f (x,y) in first'
12:22:55 <Cale> @type let first' f (x,y) = first f (x,y) in first'
12:22:57 <mbot> forall a c b. (a -> c) -> (a, b) -> (c, b)
12:23:10 <_matthew_> grr, why can't you do guards in an anonymous func?
12:23:20 <glguy> _matthew_: you can: case
12:23:21 <Cale> you can, use case
12:23:31 <_matthew_> uses more file space though!
12:23:36 <LoganCapaldo> does hugs have a different syntax for import than GHC?
12:23:39 <glguy> are you running short?
12:23:47 <_matthew_> doesn't look as pretty on the screen!
12:23:54 <dmhouse> _matthew_: lambda guard is coming for haskell-prime I think.
12:23:57 <glguy> well, soon you will run out of "!"
12:24:13 <_matthew_> mmmm. /me refactors into a function...
12:24:25 <nmessenger> _matthew_, you might also give the lambda a name in a where or let, then you could use guards
12:24:33 <Cale> dmhouse: what?
12:24:35 <_matthew_> ahh, ok.
12:24:41 <Cale> dmhouse: is it implemented in GHC?
12:24:46 <LoganCapaldo> Specifically, is there something wrong with module Main where\nimport Random\nimport Data.List
12:24:52 <dmhouse> Cale: hang on, I definitely read something similar.
12:25:28 <LoganCapaldo> Cause I get unexpected symbol for Data.List
12:26:16 <dmhouse> Cale: okay, 'have been proposed for haskell-prime'.
12:26:20 <dmhouse> http://hackage.haskell.org/trac/haskell-prime/ticket/41
12:26:21 <mbot> Title: #41 (add LambdaCase) - Haskell Prime - Trac, http://tinyurl.com/y8hq2u
12:26:49 <Cale> ah, that sort of lambdacase
12:27:06 <nmessenger> I thought I remembered reading somewhere that lambda guards were removed eons ago because they were confusing
12:27:15 <shapr> @seen shapr
12:27:16 <mbot> You are in #haskell. I last heard you speak just now.
12:27:20 <shapr> hmm
12:27:22 <dmhouse> Cale: yeah, I was basically completely mistaken, it seems. :)
12:28:09 <nmessenger> oh, that ticket seems cool.
12:28:53 <nmessenger> like a multiple pattern lambda.
12:31:07 <_matthew_> wow, if monads and functors were the same then liftM and fmap would be the same
12:31:39 <Cale> yes
12:31:46 <dmhouse> Functor is a subclass of Monad (ish).
12:31:48 * _matthew_ states an obvious fact
12:31:57 <Cale> (.), map, fmap, liftM could all be unified
12:32:04 <dmhouse> _matthew_: they should be the same for anything which is both a functor and monad.
12:32:42 <nmessenger> ?wiki The Other Prelude
12:32:43 <mbot> http://www.haskell.org/haskellwiki/The Other Prelude
12:32:45 <_matthew_> dmhouse: I sponsor you to write a quickcheck that verifies that is indeed the case ;)
12:32:53 <nmessenger> ?wiki The_Other_Prelude
12:32:53 <mbot> http://www.haskell.org/haskellwiki/The_Other_Prelude
12:32:59 <dmhouse> Cale: well, you can't get rid of fmap as obviously there are monads which are not functors, and liftM is nice for symmetry with liftM{2,3,etc}.
12:32:59 <Cale> My recommendation is that they probably should be unified, leaving just (.) and map, which would be completely equivalent, and represent functor application.
12:33:09 <Cale> dmhouse: Every monad is a functor
12:33:18 <dmhouse> Cale: err, functors which aren't monads.
12:33:33 <Cale> well, right
12:33:57 <Cale> You might want to leave liftM in technically just to make it easier to define instances of Functor for monads
12:34:01 <dmhouse> _matthew_: but certainly using fmap instead of liftM saves you characters and having to import Control.Monad.
12:34:08 <dmhouse> Cale: right.
12:34:35 <_matthew_> mmm. does mzero work in the context of functors too then?
12:34:51 * _matthew_ seems to be combining loads of stuff he barely understands...
12:35:10 <LoganCapaldo> How does one unify (.) with fmap? (prepares to be terrified)
12:35:21 <Cale> It makes sense to define a functor with zero to some extent, but it's not as interesting as when the monad operations are present.
12:35:29 <kpreid> > ((+1) `fmap` (+1)) 0
12:35:30 <mbot>  2
12:35:33 <kpreid> LoganCapaldo:
12:35:45 <nmessenger> LoganCapaldo, read "The Other Prelude" page on the wiki
12:36:04 <eyck> em,
12:36:13 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in (*3) . (+5) . [1,2,3]
12:36:14 <mbot>  [18,21,24]
12:36:17 <conal> anyone have info/opinions on two monad transformer libs: mtl vs monads/monadLib ?
12:36:21 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in ((*3) . (+5)) . [1,2,3]
12:36:22 <mbot>  [18,21,24]
12:36:36 * LoganCapaldo proceedes to be terrified
12:36:59 <LoganCapaldo> this is almost making me feel like a list is a function ....
12:37:01 <LoganCapaldo> act
12:37:19 <_matthew_> is terrified by the fact that the following works:
12:37:20 <_matthew_>                                            vecFrom1HitsTop = isJust $ msum $
12:37:20 <_matthew_>                                                              map (join . fmap (\(d,_,_) -> if d > 0 then return True else mzero))
12:38:02 <_matthew_> presumeably that relies on Maybe being both a monad and a functor
12:38:57 <Cale> er, I don't see how that types
12:39:07 <_matthew_> well, you apply it to a list too!
12:39:14 <LoganCapaldo> arg
12:39:15 <shapr> conal: Isn't mtl mostly from Iavor?
12:39:17 <Cale> If you replace the $'s with (.)
12:39:25 <Cale> then it works :)
12:39:27 <LoganCapaldo> (+1) . Just 3
12:39:30 <LoganCapaldo> ACK!
12:39:35 <_matthew_> well, it compiles
12:39:39 <_matthew_> and runs!
12:39:46 <Cale> _matthew_: only if you stick a list on the end there
12:39:49 <LoganCapaldo> I want to go back to procedural land mommy
12:39:53 <Cale> not like you wrote it, it doesn't
12:40:03 <_matthew_> Cale: ahh, ok. I am sticking a list on the end
12:40:24 <_matthew_> ?yow
12:40:24 <mbot> This TOPS OFF my partygoing experience!  Someone I DON'T LIKE is
12:40:24 <mbot> talking to me about a HEART-WARMING European film ...
12:40:33 <_matthew_> agh - has lambdabot changed?
12:40:49 <nmessenger> LB's currently sleeping, mbot's filling in
12:40:51 <Cale> mbot is here while lambdabot is dead
12:41:14 <nmessenger> Cale!  At least use euphemisms, we don
12:41:18 <Cale> % Sum[1/2^n, {n,1,Infinity}]
12:41:20 <mbot> Cale: 1
12:41:24 <nmessenger> 't want to scare the poor lad
12:41:39 <Cale> % Sum[1/n^2, {n,1,Infinity}]
12:41:41 <mbot> Cale: Pi^2/6
12:42:05 <dmhouse> ?tell dons lambdabot's dead, you probably already know.
12:42:05 <mbot> Consider it noted.
12:42:18 <nmessenger> ?seen dons
12:42:18 <mbot> dons is in #haskell. I don't know when dons last spoke.
12:42:21 * shapr boings happily
12:42:51 <shapr> @seen joelr1
12:42:51 <mbot> I haven't seen joelr1.
12:43:19 <dmhouse> shapr: remember _ages_ ago I promised to make some forum software using HAppS? I spent some time with it over the holidays, it's getting pretty good.
12:43:32 <Cale> % Integrate[1/(1+x^5), x]
12:43:34 <mbot> Cale: (-2*Sqrt[10 - 2*Sqrt[5]]*ArcTan[(1 + Sqrt[5] - 4*x)/Sqrt[10 - 2*Sqrt[5]]] + 2*Sqrt[2*(5 + Sqrt[5])]*ArcTan[(-1 + Sqrt[5] + 4*x)/Sqrt[2*(5 + Sqrt[5])]] + 4*Log[1 + x] + (-1 + Sqrt[5])*Log[1 + ((
12:43:34 <mbot> -1 + Sqrt[5])*x)/2 + x^2] - (1 + Sqrt[5])*Log[1 - ((1 + Sqrt[5])*x)/2 + x^2])/20
12:44:02 <paolino> mmhh looks wrong
12:44:06 <Cale> Computer algebra is fun :)
12:44:09 <nmessenger> is that Mathematica syntax or something?  I've not used it.
12:44:12 <dmhouse> Cale: aren't there licensing issues making Mathematica available to the world free of charge?
12:44:16 <Cale> yeah, it's Mathematica
12:44:32 <Cale> dmhouse: I don't know. I figure the bot does less than their free demo does.
12:45:00 <Cale> If I ever got a complaint, I'd remove it.
12:45:09 <dmhouse> Fair enough.
12:45:18 * dmhouse fixes a glaring security hole in his software. :)
12:45:29 <Cale> It would be a little silly of them, given that it's such good advertising.
12:46:04 <dmhouse> temujin: ping, still around?
12:46:44 <shapr> dmhouse: Ooh, I want to see!
12:46:53 <thelsdj> i wrote a cellular automata that after running for a few billion years became stephen wolfram and the entire mathematica dev group, so really i own the intellectual property to mathematica anyways
12:46:56 <dmhouse> shapr: I'm currently trying to get myself a server.
12:47:06 <dmhouse> shapr: happen to know what I have to do to get a haskell.org account?
12:47:08 <shapr> You can run it on scannedinavian.com for demo purposes.
12:47:19 <shapr> You need to talk to JaffaCake or SyntaxNinja probably.
12:48:03 <Cale> % FactorInteger[473821903904904403278923217832174925665637231]
12:48:05 <mbot> Cale: {{2694202112473, 1}, {175867245338169787699271504487047, 1}}
12:48:19 <bringert> I think it's only JaffaCake who can give you an account
12:48:37 <shapr> hej bringert!
12:48:42 <bringert> hej shapr
12:48:56 <bringert> shapr: how's code?
12:49:09 <dmhouse> ?tell temujin don't worry, I'll sort a server out someplace else, it wouldn't be fair to crash on your ADSL :)
12:49:10 <shapr> Code is good, slow but fun.
12:49:10 <mbot> Consider it noted.
12:49:17 <shapr> I'm doing more organization than code lately.
12:49:34 <bringert> shapr: happs?
12:49:45 <shapr> How'd you guess?
12:50:10 <bringert> :-)
12:51:23 <lightstep> is sequence.complete.org down?
12:53:46 <mahogny> no
12:54:12 <Botje> +pl \k m -> Map.insert k True m
12:54:32 <Botje> @pl \k m -> Map.insert k True m
12:54:32 <mbot> ((Map .) .) . flip insert True
12:54:42 <Botje> @pl \k m -> insert k True m
12:54:42 <mbot> flip insert True
12:57:43 <glguy> ?pl \x y -> x + f y
12:57:43 <mbot> (. f) . (+)
12:58:15 <glguy> ?pl \x y -> f x + y
12:58:21 <mbot> (+) . f
12:58:39 <kpreid> @pl \x y -> y + f x
12:58:39 <mbot> (+) . f
12:59:01 <glguy> the other was: ap (+) f
12:59:03 <glguy> errr
12:59:04 <glguy> nope
12:59:08 <glguy> that's if it's x + f x
12:59:21 <thelsdj> @pl \x y -> y ++ f x
12:59:21 <mbot> flip (++) . f
12:59:45 <lightstep> ?pl \x y -> x + y - y
12:59:46 <mbot> join . ((-) .) . (+)
13:00:04 <lightstep> ?pl flip (+)
13:00:04 <mbot> (+)
13:00:20 <thelsdj> ?pl flip (++)
13:00:20 <mbot> flip (++)
13:00:34 <kpreid> ?pl mzero `mplus` mzero
13:00:34 <mbot> mzero `mplus` mzero
13:00:51 <glguy> I was playing with LoganCapaldo's datatype pertaining to the (p1 <-> (p2 ... question
13:00:54 <glguy> let u n = foldr ((:<->) . P) (P n) $ [1..n] ++ [1..n-1]
13:01:19 <glguy> data P = P Int | P :<-> P deriving Show
13:02:12 <glguy> causing u 3 -> P 1 :<-> (P 2 :<-> (P 3 :<-> (P 1 :<-> (P 2 :<-> P 3))))
13:07:54 <Botje> @pl m k -> insert k True m
13:08:05 <Botje> @pl \m k -> insert k True m
13:08:12 <Botje> is it dead again?
13:08:29 * Botje pokes mbot
13:08:36 <nmessenger> ?bot
13:09:03 <nmessenger> Today is not a good day to be a lambdabot
13:09:10 <svref> Is there some operator that takes a value, and spiders it, forcing strict eval of all its parts?
13:09:50 <Botje> deepSeq?
13:10:16 <glguy> deepSeq does what svref is describing, but isn't a standard library function
13:10:42 <glguy> maybe lambdabot isn't 2k7 certified
13:10:49 <glguy> and the timestamps are overflowing!
13:10:49 <nmessenger> :O
13:11:12 <svref> Basically, I'm construcing this big graph type, and I imagine it will pay to make it strict (though I haven't run tests yet).  Am I prematurely optimising?
13:11:54 <conal> shapr: oops -- missed your message.  monadLib appears to be iavor's.  mtl is marked as andy gill's.
13:13:18 <shapr> ah, ok
13:13:30 <mbishop> 2k7 bug? EVERYBODY PANIC
13:13:31 <shapr> I think I preferred Iavor's lib last time I compared them.
13:14:25 <conal> i used iavor's for Phooey but just today stumbled on mtl.  mtl is listed on the hierarchical libs page (http://www.haskell.org/ghc/docs/latest/html/libraries/).
13:14:52 <conal> it also uses Control.Monad, while iavor's uses Monad.  the former seems a better fit.
13:15:19 <conal> and mtl appears to be more recently updated in darcs.
13:15:21 <shapr> conal: I think you should ask on Haskell-cafe, I bet you'll get informed answers there. I don't remember what I came up with.
13:15:43 <fasta> svref: what graph library are you using?
13:15:52 <svref> homebrew
13:16:11 <conal> shapr: thanks.  i've asked on libraries@haskell.org.  if i don't get a clear answer, i'll use haskell-cafe.
13:16:15 <conal> shapr: how's the new job?
13:16:18 <svref> it seems like there are so many slight variants on the graph concept, that its best to make the one that fits perfectly
13:16:31 <emu> speaking of timestamps, i tried to compile some time lib using code with -O2 and got a weird error about HsTime.h being missing
13:16:31 <shapr> conal: Oh it rocks!
13:16:41 <Cale> svref: If you're representing it with an Array, then it's probably worthwhile just to use a UArray
13:16:42 <conal> shapr: wow!  lucky guy.  :)
13:16:46 <shapr> conal: I have a fulltime job writing BSD3 Haskell code! How can you beat that?
13:16:55 <fasta> svref: I would call it premature optimization
13:17:04 <conal> shapr: that's awesome.  way to go.  where?
13:17:55 <svref> fasta: ok, thanks.  This is my first big-data haskell project, and I'm a little scared that laziness is going to blow my heap.  We'll see....
13:18:05 <mbishop> oh god
13:18:13 <fasta> svref: define big
13:18:22 <mbishop> this scheme to CL compiler demo makes the ugliest code >_<
13:18:39 <emu> it has to be CPS transformed
13:18:44 <shapr> conal: I'm working for HAppS LLC, which is a company owned by Alex Jacobson.
13:19:51 <conal> shapr: that sounds great.  i'm glad to hear it.  where, geographically?
13:20:07 <shapr> I'm in Birmingham, AL and Alex is in NYC.
13:20:27 <conal> oh yeah.
13:20:56 <conal> i'm all for web tools in Haskell.
13:21:21 * fasta would like to see that not every language community made their own half-baked tools.
13:21:36 <emu> full-baked!
13:22:18 <shapr> fasta: There aren't any tools in any language that do what HAppS is doing.
13:22:36 <kilimanjaro> What does HAppS do?
13:22:48 <fasta> shapr: ok, interpret my statement regardless of the specific language Haskell
13:23:04 <shapr> Yeah, I agree with that.
13:23:35 <shapr> fasta: Though in my experience, C tends to have the tools that are completely 'baked' (in the sense of, smoking too much marijuana).
13:24:08 <shapr> I guess C is the lingua fracas of the OSS world for now.
13:24:23 <fasta> shapr: I have little practical experience with C, but I think one can make good software with C.
13:24:32 <mbishop> Paul Potts has shiingles IN his eye? that's hardcore
13:24:41 <fasta> shapr: it just takes more effort than with a modern language
13:24:45 <shapr> Yup, one can also make good software with Forth, or assembly.
13:25:01 <SamB> hmm.
13:25:02 <SyntaxNinja> fyi, I can also give accounts to darcs.h.o, but I tend to only do so for people I obviously know.
13:25:05 <shapr> Conversely, bad programs can be built with any language or system.
13:25:16 <SamB> what about NULL
13:25:37 <glguy> Haskell has bottom, which might as well be null
13:25:39 <mbishop> On project euler, some people use befudge
13:26:00 <SamB> (it has one program, an empty file, having semantics like true(1))
13:26:09 <mahogny> whoever makes a language that disallows crappy programs deserves the nobel peace price
13:26:11 <fasta> shapr: I meant in a "practical" way
13:26:33 <fasta> mahogny: how much is that price?
13:26:37 <fasta> mahogny: I can do it
13:26:46 <emu> mahogny: insert "good programmer" as frontend
13:26:54 <fasta> mahogny: since your specs are a bit simple
13:27:07 <mahogny> hm. nowadays the nobel price is mainly symbolic. not that much
13:27:16 <pejo> fasta, it's around $1M I think. Depends on the growth of the fund behind it iirc.
13:27:31 <kilimanjaro> how could a lkanguage disallow crappy programs?
13:27:36 <kilimanjaro> language*
13:27:45 <nmessenger> easy, just don't make it turing-complete :)
13:27:47 <fasta> kilimanjaro: just allow zero programs
13:27:48 <mahogny> kilimanjaro, that is the problem to be solved :)
13:27:55 <SamB> fasta: I say NULL qualifies
13:28:01 <mahogny> back in the days the price could be up to $10M or more
13:28:03 <kilimanjaro> fasta: true
13:28:15 <Philippa> glguy: no, you can't test for bottom. Also, strict languages effectively have /more/ bottom...
13:28:17 <nmessenger> SamB: NULL is a programming language?
13:28:42 <temujin> mmm haskell is not strict... at all
13:28:43 <kilimanjaro> nmessenger: turing completeness has nothing to do with "crappiness" (a term not even defined in this conversation, although I personally perceive it as some metric of aesthetics)
13:28:45 <pejo> kilimanjaro, the type system is there to filter out some of the bad programs, for example.
13:28:54 <glguy> Philippa: so what is the difference between: length (undefined) and null.length() ?
13:28:57 <emu> haskell has a nice bottom
13:29:15 <_frederik_> hehe
13:29:29 <mahogny> glguy, I find it a lot easier to cause a NULL than a bottom
13:29:41 <kilimanjaro> pejo: yea, but if windows 95 was written in haskell would you want to use it?
13:30:01 <LoganCapaldo> windows 95 or haskell?
13:30:08 <mbishop> heh
13:30:32 <kilimanjaro> LoganCapaldo: take a guess
13:30:53 <nmessenger> kilimanjaro: right, but TC implies that any sort of program can be written in it that can be written in any other TC language (with varying degrees of pain).  Without TC, you can impose any restriction you like. :)
13:31:04 <thelsdj> i'd initially want to use windows 95, but after seeing how crap it was i'd not want to use haskell
13:31:04 <SamB> if windows 95 had been written in Haskell, they wouldn't have needed NT
13:31:18 <kilimanjaro> nmessenger: not really, TC has to do with computability
13:32:01 <kilimanjaro> how a language interfaces with the rest of the world is not of interest to turing nor church
13:32:13 <kilimanjaro> and no systems have infinite memory either
13:32:20 <nmessenger> true
13:33:21 <Philippa> glguy: the latter could've been avoided by checking at the call-site for null
13:33:36 <monochrom> Windows 95 was specified to carry the baggage of backward compatibility.  No matter how you would implement it, it carried that baggage.  That was the cause of all problems.
13:33:44 <Philippa> also, null's just a pointer or reference, whereas bottom's in all types
13:34:06 <Philippa> ...not really
13:34:09 <olliej> dons: are you aware of any simple (open source) haskell parser + type inference engine?
13:34:18 <Philippa> I mean, they did get to define a win32 API from scratch and it still had problems of its own
13:34:32 <metaperl> @doc (<+>)
13:34:47 <kilimanjaro> presumably, given a particular system, there is a set of programs that can be interactive if written in C and not interactive if written in similar algorithmic style in a different language (ruby, for example)
13:34:48 <ndm> olliej: hatchet
13:34:56 <olliej> ndm: cheers
13:35:08 <fasta> kilimanjaro: interactive?
13:35:15 <SamB> monochrom: well. personally, I think it wasn't the cause of all problems...
13:35:32 <nmessenger> monochrom: very true, but what is baggage now began as bad design decisions.  Any sufficiently large system will have 'em.
13:35:34 <fasta> @karma- windows
13:35:46 <fasta> @karma-- windows
13:35:49 <SamB> see, they wouldn't have had to allow win32 programs to do so much
13:36:17 <Philippa> nmessenger: that's unfair
13:36:21 <kilimanjaro> fasta: certain sections of the program operate within certain soft time boundaries (the soft realtime constraints are imposed only by the mind of the observer)
13:36:25 <monochrom> OK, yeah, bottomline is bad design decisions.  Those couldn't be saved with Haskell.
13:36:27 <Philippa> some of the baggage was win16 baggage...
13:36:29 <metaperl> @doc Control.Arrow
13:36:43 <Philippa> ...and win16 was always going to bring some crap
13:36:46 <kilimanjaro> fasta: but 5 years ago, quake 3 could not have been successful in many languages
13:36:48 <SamB> well, sure
13:37:02 <SamB> but 9x has problems even when you don't run win16 programs on it
13:37:03 <kilimanjaro> or whenever it was released... 1999?
13:37:21 <Philippa> yeah. So by 2002 it could've done okay in many languages, because it leaves most of the work to the card
13:37:30 <monochrom> I was taken aback to learn that Windows 95 allowed every process to write to the memory space of each other.
13:37:36 <SamB> I think it was the DOS innards and lack of protection, more than the intended functionality...
13:37:37 <kilimanjaro> Philippa: right, but by 2002 people were working on other things
13:37:38 <fasta> kilimanjaro: yes, but games are not exactly top notch quality code
13:37:51 <kilimanjaro> fasta: what does that mean?
13:37:57 <Philippa> kilimanjaro: actually, there were a number of games licensing the Q3A engine at that point
13:38:18 <kilimanjaro> Philippa: right, why rewrite the engine in a nicer language?
13:38:21 <Philippa> at its release in late 1999, Q3A was one of the two top FPS engines (the other being Unreal)
13:38:27 <mahogny> kilimanjaro, much game code is just for throwing away. it is different for programs when you are supposed to maintain it for years
13:38:44 <fasta> kilimanjaro: see mahogny
13:38:59 <Philippa> kilimanjaro: ask Tim Sweeney, Epic've made a lot of money out of having gone well-designed C++ back when Carmack was C-only
13:39:24 <kilimanjaro> I have not made any contrary claims...
13:39:34 <kilimanjaro> I just said that TC is not everything
13:39:46 <nmessenger> I've read of some of the sophisticated designs the Windows team uses to isolate back-compat hacks.  They've had lots of practice ;)
13:39:47 <kilimanjaro> any my reasoning was that there are runtime properties and features of languages
13:40:06 <Philippa> kilimanjaro: this can be summed up a lot more simply and accurately...
13:40:09 <Philippa> "IO Matters"
13:40:15 <monochrom> TC is nothing.  It's trivial to make a language TC.  In fact it takes educated deliberation to avoid TC.
13:40:59 <fasta> TC==Time Critical>'
13:41:01 <fasta> ?
13:41:02 <kilimanjaro> Philippa: Not just IO, but a) complexity of evaluation, and b) that magical "constant" that is ignored by so many
13:41:04 <mahogny> btw I am soon going to make a proper implementation of my take-a-lot-of-haskell-monads-and-bake-it-to-c-and-compile-and-run-as-a-plugin library. before I start, has anyone done anything like this already?
13:41:07 <kilimanjaro> fasta: turing complete
13:41:13 <SamB> oh, hahaha
13:41:19 <Philippa> kilimanjaro: I'm using IO in the Haskell sense. Those come under it
13:41:34 <kilimanjaro> Can you explain the Haskell sense?
13:41:55 <kilimanjaro> (and how it pertains to runtime and memory use)
13:41:58 <Philippa> kilimanjaro: all haskell programs start in the IO monad
13:42:09 <monochrom> IO interfaces with the outside.
13:42:13 <Philippa> therefore, even pure haskell code *is being run by something that does IO*
13:42:23 <Philippa> where "the outside" means "the world" as opposed to "the reduction rules"
13:42:29 <Philippa> so merely interacting with the CPU is IO
13:42:45 <Philippa> it's just that pure code doesn't, in and of itself, do this - running it does
13:43:01 <Philippa> pure program, impure implementation
13:44:38 * mahogny extends his question: has anyone played with runtime self-optimizing programs in haskell?
13:44:54 <monochrom> Like my supervisor sometimes jokes, "what does this program do?  it just sits there, it can do nothing."
13:45:10 <Philippa> mahogny: yes, though not necessarily how you think. There's a set of parsing combinators that were one of the inspirations for arrows, for example
13:45:23 <shapr> fasta: What do you mean in a practical way?
13:45:25 <mahogny> Philippa, got reference?
13:45:55 <Philippa> http://citeseer.ist.psu.edu/164365.html
13:46:19 <mahogny> ah perfect. thx
13:46:20 <kilimanjaro> Well, if we define a term as broad as I/O then it is at least easier to ignore the rest of the world :)
13:46:33 <fasta> shapr: some programming languages make it arguably more difficult to write good code with. I think that Factor 2.0(if it ever releases) is easier to program with than x86 assembly.
13:46:53 <Philippa> kilimanjaro: it just means "things you'd have to be in the IO monad to observe"
13:47:21 <kilimanjaro> I live in an I/O monad :)
13:47:22 <shapr> fasta: I think Joy is easier than Factor...
13:47:47 <fasta> shapr: I didn't claim Factor was the easiest.
13:48:10 <benja_> whatShouldICallThis :: MaybeT m a -> MaybeT m (Maybe a)
13:48:20 <benja_> whatShouldICallThis = lift . runMaybeT
13:48:46 <LoganCapaldo> liftRunMaybeT ;)
13:49:01 <fasta> shapr: The difference between Joy and Factor, however, is that slava appears to get things done in Factor and Factor develops itself pretty fast. I haven't seen the same with Joy.
13:49:11 <shapr> fasta: true that.
13:49:26 <shapr> fasta: But I'm quite fond of purely concatenative, and Factor is not that.
13:49:37 <benja_> the intent is that (do whatShouldICallThis foo; bar) executes 'bar' even if 'foo' fails
13:49:45 <fasta> shapr: you seem to like the word "pure" ;)
13:50:00 <shapr> Do I/
13:50:01 <shapr> ?
13:50:03 * dylan is kicking around a syntax sugar for a concatenative language
13:50:04 * shapr thinks about that.
13:50:15 <fasta> shapr: what is more "pure" about Joy Factor?
13:50:25 <fasta> er strip Factor
13:50:33 <shapr> Factor can't be sliced at lexical boundaries to give legal programs. Joy can.
13:51:00 <benja_> I suppose it'll be callMaybeT
13:51:36 <fasta> shapr: Don't you mean tokens instead of "lexical boundaries"?
13:51:49 <shapr> Hm, maybe so.
13:52:34 <shapr> In any case, I like the balance that Joy has, and Factor seems a bit off-kilter to me. But as you say, Factor is developing into something real, and Joy is not.
13:52:45 <agocorona> according with the superstring theory,  the universe  seems to be the expression of a unique mathematical formula. So the universe has no side effects
13:54:31 <mahogny> feel free to implement SuperString for us
13:55:00 <Cale> and then you can use it to make some predictions of observable phenomena!
13:55:26 <agocorona> superstring theory is a field of theoretical phisics
13:55:28 <metaperl> can anyone answer a simple question about <+> ... I pasted it here - http://rafb.net/p/FZ9xcQ15.html  ... bottom line: how does <+> fuse?
13:55:44 <Cale> agocorona: It's barely science.
13:55:51 <agocorona> all forces and particles derive from a single equation not yet discovered
13:56:01 <agocorona> the M equation
13:56:25 <velco> module Data.SuperString where answer = 42
13:56:31 <metaperl> lol
13:56:32 <mahogny> am I the only one who abuses lambda notation in calculus? :/
13:56:40 <Cale> metaperl: it depends on the particular arrow
13:56:46 <monochrom> I'm thinking there is a more general version for benja_'s function.  How does this sound:  mono :: (Monad m) => m a -> m (Maybe a); mono k = liftM Just k.
13:57:16 <fasta> I imported qualified Node, I have a field called val in values of type node. How do I if I have a value of type Node.Node named foobar the val value using record syntax? And if that's not possible how else can I solve it except for of course exporting a function that does that from module Node?
13:57:19 <Cale> metaperl: for instance, in a list arrow, it might concatenate the resulting lists
13:57:27 <agocorona> really the universe can not have side effects if the law of matter + energy is constant in time
13:57:30 <xerox> monochrom: does that really work?
13:57:41 <monochrom> I have to investigate.
13:57:45 <metaperl> Cale - i've been struggling for hours to understand how <+> applied to two results of readDocument would fuse... wouldnt that look weird
13:58:12 <xerox> I think that the point for having a general "finally" is the (>>=) instance.
13:58:35 <Cale> agocorona: really, the universe can't have side effects because pretty much by definition there's no "side" for the effects to affect.
13:58:44 <monochrom> haha Cale
13:59:02 <fasta> s/How do I/How do I change
13:59:05 <benja_> Cale: there's "and everything"
13:59:33 <Cale> metaperl: Try it and see
14:00:00 <Cale> I'd expect it to concatenate the results of the arrows.
14:00:08 <lightstep> fasta, foobar {Node.val = newValue}
14:00:22 <metaperl> Cale - why cant I find the docs for <+> in HXT's implementation?
14:00:24 <monochrom> Every HXT arrow can be thought of as a function a->[b].  Note the [].  Thus <+> becomes ++.
14:00:27 <metaperl> I cant even find code for it
14:00:35 <fasta> lightstep: thanks :)
14:00:46 <agocorona> xerox, true, that was what I though, but I am not sure. there are strange phenomena like the dark energy, that icreases with time
14:01:02 <Cale> <+> is defined in Control.Arrow
14:01:03 <xerox> What?
14:01:11 <Cale> as a member of the ArrowPlus class
14:01:13 <monochrom> Example.  pure (\x -> [1]) <+> pure (\x ->[0,2])   you will expect [1,0,2].
14:01:32 <Cale> you'll find that (IOSLA s) is an instance of ArrowPlus
14:01:41 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-IOStateListArrow.html
14:01:42 <mbot> http://tinyurl.com/yf9rs4
14:02:02 <monochrom> See also http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml
14:02:03 <mbot> http://tinyurl.com/yyhmda
14:02:33 <metaperl> monochrom - thanks for the link
14:02:39 <metaperl>        readDocument :: Attributes -> String -> IOStateArrow s b XmlTree
14:02:46 <monochrom> Screw my example above.  See the webpage.  The webpage is correct.
14:02:47 <metaperl> what do we know about b?
14:02:53 <do-gooder-77> ok scheme or haskell help
14:02:55 <do-gooder-77> ;)
14:03:02 <do-gooder-77> both seem powrful
14:03:02 <monochrom> We know, from the free theorems, it is ignored.
14:03:40 <Cale> hehe, "New Friends" :)
14:03:53 <fasta> @users
14:03:54 <mbot> Maximum users seen in #haskell: 287, currently: 283 (98.6%), active: 14 (4.9%)
14:04:06 <SyntaxNinja> do-gooder-77: Haskell is statically typed, so in my opinion, it helps my confidence that my software is correct.
14:04:08 <fasta> Uh, didn't we have >300?
14:04:20 <monochrom> readDocument can be thought of as a side-effecting function b -> [XmlTree]
14:04:28 <SyntaxNinja> do-gooder-77: it also, IMO has a lot more built-in capabilities to work in abstractions.
14:05:10 <fasta> do-gooder-77: #haskell is biased towards Haskell
14:05:29 <SyntaxNinja> fasta: maybe it's just me ;)
14:06:47 <pejo> SyntaxNinja, nawww, we all like static typing.
14:07:02 <fasta> SyntaxNinja: People are generating Haskell (even outside Template Haskell), I think that's a bad sign. Otherwise, it doesn't make a huge difference what language(Scheme/Haskell) you pick.
14:07:31 <benja_> does anybody here have a deep understanding of why Swierstra and Duponcheel's parsers can allegedly not be implemented with monads?
14:07:52 * earthy has something of a guess
14:07:57 <benja_> I know two entirely different reasonings, one from their original paper and one from the arrows paper
14:08:07 <earthy> okay. shoot.
14:08:08 <benja_> but both seem to miss the fact that Haskell is lazy :)
14:08:12 <SyntaxNinja> fasta: I do think it makes a difference, but it depends on your use for a language; your application.  However, I'm not blessed with the time to have a useful discussion about it ;)
14:08:13 <shapr> fasta: Do I really use the word pure that much?
14:08:23 <monochrom> can't define app.
14:08:26 * SyntaxNinja spent his entire undergraduate career in language flame wars ;)
14:08:38 <fasta> SyntaxNinja: yes, it depends on the application.
14:08:49 <earthy> benja_: if you want I'll ask Swierstra friday.
14:08:52 <shapr> I spent my entire undergraduate in an art degree...
14:09:01 <benja_> earthy: oh cool
14:09:10 <benja_> so let me outline my reasoning =)
14:09:11 <shapr> My job here is to draw pretty pictures of lambdas, nothing more.
14:09:15 <SyntaxNinja> lots of time people work on scripts in Bash that would actually, IMO, be better in Haskell.  I like Hsakell for scripting, but I'm one of the few.
14:09:27 <shapr> SyntaxNinja: Linspire agrees with you.
14:09:40 <fasta> SyntaxNinja: we had Scheme and Haskell, not Bash
14:10:03 <benja_> ...actually let me quickly look up the original paper so that I'm not too far off on what they say =)
14:10:19 <lucca> does linspire still agree?  last I checked it looked like they were dropping haskell
14:10:27 <earthy> benja_: I'm reading at the moment ;)
14:10:29 <shapr> lucca: When was that?
14:10:31 <fasta> lucca: interesting, URL?
14:10:35 <pejo> earthy, is that the right Swierstra?
14:10:48 <shapr> lucca: A month or so ago they were pro-Haskell.
14:10:55 <monochrom> I forgot.  How is MaybeT defined?
14:11:04 <earthy> pejo: prof. S. D. Swierstra of Utrecht
14:11:11 <benja_> monochrom: it isn't
14:11:15 <fasta> They had an entry in the HCAR?
14:11:20 <benja_> in the standard library
14:11:25 <earthy> 3 doors on from my office.
14:11:33 <lucca> shapr: this was more than a month ago, so likely my reading skills are the source of confusion
14:11:36 <monochrom> Right, that's why I need help. :)
14:11:40 <earthy> (he was my advisor :))
14:11:44 * benja_ is writing an implementation as a utility for my code and may be submitting it for inclusion in the std lib
14:11:46 <lucca> I'll see if I can find what was causing me to think that.
14:11:47 <benja_> @paste
14:11:48 <mbot> http://paste.lisp.org/new/haskell
14:11:55 <pejo> earthy, oh. always handy to have an office nearby. :-)
14:11:59 <earthy> benja_: an implementation of the parser combinators?
14:12:04 <SyntaxNinja> fasta: I guess that was my way of saying that I think Haskell is good for everything.
14:12:09 <earthy> why?
14:12:22 <shapr> lucca: It's also possible that their corporate side is anti- and their geek side is pro- so I want to hear more of what you read.
14:12:37 <benja_> earthy: no, that was a reply to monochrom, an impl of MaybeT
14:12:41 <earthy> ah. :)
14:13:07 <monochrom> newtype MaybeT m a = MaybeT (m (Maybe a)) ?
14:13:17 <lisppaste2> benja_ pasted "My MaybeT (untested)" at http://paste.lisp.org/display/33976
14:13:48 <olliej> ndm: hatchet looks like it might be just what i want :D
14:14:29 <shapr> lucca: http://www.haskell.org/communities/11-2006/html/report.html has a section on Linspire that is pro-Haskell. It mentions Haskell tools such as a Debian package builder, installer CD, and package dependency checkers, as well as replacing bash tools.
14:14:30 <mbot> Title: Haskell Communities and Activities Report, http://tinyurl.com/y7xewz
14:14:39 <shapr> lucca: But that's two months ago...
14:15:32 <earthy> benja_: privmsg me, I'm called from my keyboard.
14:16:22 * shapr gives up and goes unicycling
14:18:08 <glguy> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } -- from the wikibook
14:18:37 <benja_> back
14:18:43 <SyntaxNinja> last I heard at the Commercial Users of FP conference a couple of months ago, Linspire was still very much *pro* Haskell.
14:18:45 <benja_> earthy: ok
14:19:33 <fasta> SyntaxNinja: how does one do generic traversals? Scrap your boilerplate is not truly generic since it has some "mkT" or "make traversal" function that you need to insert everywhere, also it doesn't work for types that don't have the right "deriving" incantation.
14:19:39 <glguy> ?bot
14:19:40 <mbot> :)
14:21:27 <do-gooder-77> http://www.youtube.com/watch?v=lHF483cuzuY&mode=related&search=
14:21:55 <glguy> ?seen ndm
14:21:56 <mbot> I saw ndm leaving #haskell 25m 57s ago, and .
14:22:05 <SyntaxNinja> fasta: :)
14:22:12 <lucca> shapr: I've been unable to locate the pages that lead me to that conclusion...
14:22:31 <glguy> fasta: have you seen ndm's play class?
14:22:36 <fasta> glguy: yes
14:22:41 <lucca> shapr: I recall I was trying to read more about this, and had done several searches on linspire, freespire, and haskell
14:23:09 <lucca> shapr: it seems plausible the "rewrite" I was seeing from some todo list was referring to their ocaml->haskell change...
14:24:30 <fasta> SyntaxNinja: :) is rather ambiguous
14:25:59 <SyntaxNinja> fasta: that's my polite way of reiterating that I'm not interested in arguing the finer points of languages ;)
14:29:01 <yaxu> i'll do it at college, i think i get the first 200 pages free anyway
14:29:18 <yaxu> oops, mistell
14:29:41 <fasta> SyntaxNinja: Does that mean you think that Data.Generic(or SYB in general) is a good enough solution or do you have some other proprietary way of dealing with it?
14:29:49 <glguy> ?fptools Control.Monad.State
14:29:50 <mbot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:30:39 <SyntaxNinja> fasta: nah, just that I don't feel like arguing about languages right now.
14:32:56 <tuukkah> i'm trying to access an rdf library using c2hs. is there something i should be doing differently to make this ffi stuff less tedious? http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/Raptor.chs
14:32:58 <mbot> http://tinyurl.com/y2pbol
14:38:09 <fasta> SyntaxNinja: last comment on generic traversals: when you do create some great solution, publish it somewhere.
14:39:06 <SyntaxNinja> fasta: will do.
14:42:36 <bakert> ?hoogle a -> Int -> [a]
14:42:49 <monochrom> My function mono k = liftM Just k  is different from benja_'s callMaybeT.
14:42:59 <mbot> A Hoogle error occured.
14:43:44 <bakert> is there a single function that does the same as "take 5 (repeat x)"
14:43:45 <bakert> ?
14:44:01 <fasta> bakert: replicate
14:44:09 <monochrom> fasta beat me to it
14:44:15 <bakert> thanks
14:44:18 <fasta> ^^
14:45:22 <benja_> ?hoogle liftM
14:45:23 <mbot> A Hoogle error occured.
14:46:34 <bakert> Do haskell programs have a preferred max column width for source code?
14:47:01 <fasta> bakert: I prefer 80, but people with bigger monitors will give you higher numbers
14:47:35 <yaxu> good question though, is there a style guide for haskell, like perlstyle(1) ?
14:47:58 <monochrom> After investigating the behaviour of callMaybeT, I suggest the names "reflect" or "introspect".
14:47:59 <yaxu> or is the style embedded in the language? :)
14:48:20 <bakert> i found this: http://www.cs.caltech.edu/courses/cs11/material/haskell/misc/haskell_style_guide.html
14:48:21 <mbot> Title: CS 11: Haskell track: coding style guide, http://tinyurl.com/yk9796
14:48:27 <benja_> monochrom: huh? why? :)
14:49:16 <monochrom> Hmm, nevermind.
14:49:18 <benja_> the idea is that MaybeT is a possibly-failing computation, and callMaybeT lets you go on doing things if the sub-computation fails
14:49:19 <fasta> "Not putting a space after the open-comment symbol" <- nothing wrong with that
14:49:45 <yaxu> i agree with 78 column limit in general, but occasionally go up to 80.  beyond that seems rude if you want others to work on the same code
14:49:47 <fasta> => style guide is arbitrary
14:50:11 <SamB> 80 is good
14:50:19 <monochrom> There is no style guide.  We are liberal people.
14:50:31 <bakert> i used 72 for a while but have gone back to 80 since i gave up on showing line numbers in vim
14:50:38 <monochrom> hehe
14:50:59 <yaxu> monochrom: how about wearing socks with sandals?
14:51:09 <monochrom> I do that all the time.
14:51:46 <monochrom> I have done all four: socks and sandals, socks no sandals, sandals no socks, no socks no sandals.  Four-valued logic ftw!
14:52:04 <fasta> "Never put more than one statement on a line. It makes for unreadable code." I don't think the person means import statements or default statements ;)
14:52:23 <yaxu> monochrom: always the same on both feet?  some liberal.
14:52:25 <bakert> interesting ... so you chain your imports with semicolons, do you?
14:52:27 <fasta> Haskell is _expression_ based
14:52:45 <fasta> bakert: me?
14:52:51 <bakert> fasta, yes!
14:52:57 <fasta> bakert: no, of course not
14:52:58 <monochrom> There are transitional states during which the two feets differ.
14:53:04 <svref> Is there a sumBy or is one supposed to generate intermediate lists with "sum (map getLength xs)"?
14:53:05 <fasta> bakert: there's little point in doing so
14:53:10 <yaxu> monochrom++
14:53:16 <monochrom> haha
14:53:30 <bakert> fasta, oh sorry i understand the point you were making now i read your  second line about expressions not statements!
14:53:40 <bakert> oop
14:54:06 <monochrom> svref: you can do that or you can foldl'
14:54:30 <svref> monochrom: not foldr?
14:54:31 <fasta> bakert: also, I recommmend you not to care about anyone and just write fantastic programs. You learn by doing, not by asking for a style guide.
14:55:08 <monochrom> foldl' is cheaper for this use.
14:55:18 <yaxu> to be fair, i was the one asking about the style guide
14:55:34 <svref> foldl goes right-to-left, no?
14:56:13 <bakert> fasta, true.  but sometimes a simple arbitrary choice can cause you to stick while you could just get on with it if you had someone else's arbitrary choice on an official-ish page.  and then everyone would feel more comfy with each other's source files.  it's not important, though, granted.
14:56:16 <svref> hm, been going the wrong direction all these folds.  :P
14:56:27 <fasta> yaxu: right, maybe I should actually read other peoples comments :P
14:56:34 <fasta> bakert: sorry
14:56:38 <monochrom> sum (map getLength xs) = foldl' (\acc x -> acc + getLength x) 0 xs
14:56:43 <bakert> fasta, nil prob
14:57:24 <bakert> if i have a function "round" i get a compiler warning about GHC.Real.round.  How can i say "don't worry about that" to the compiler?
14:57:38 <bakert> (and just use my round, ignoring GHC.Real.round)
14:58:28 <LoganCapaldo> import Prelude hiding ( round ) perhaps?
14:58:58 <yaxu> fasta: a good point though, style guides should probably be project specific rather than language specific
14:59:03 <bakert> LoganCapaldo, seems to work.  thanks.
14:59:45 * bakert quietly goes on still liking style guides
14:59:54 <fasta> yaxu: I think people should get a new editor and not bother with style guides.
15:00:14 <bakert> but you have to configure the editor to do something!
15:00:30 <fasta> yaxu: I am _not_ saying that such an editor currently exists, unfortunately.
15:00:37 <glguy> ?fptools Data.Maybe
15:00:38 <mbot> http://darcs.haskell.org/packages/base/Data/Maybe.hs
15:00:40 <bakert> ah .. .right.. yes very true
15:00:48 <bakert> vim 3000 we need you!
15:05:16 <lisppaste2> glguy pasted "is this a reasonable MaybeT?" at http://paste.lisp.org/display/33978
15:06:28 <benja_> glguy: fmap = liftM and you're done? :-)
15:07:19 <benja_> it makes no sense to me to propagate mplus to the wrapped monad
15:07:33 <glguy> that was onet hat I wasn't sure about
15:07:34 <benja_> MaybeT should handle mplus like Maybe does
15:07:37 <glguy> ok
15:07:47 <benja_> which still leaves two options
15:08:08 <benja_> namely whether to execute the right argument in the wrapped monad even if the left argument succeeds
15:08:28 <benja_> but I'm pretty sure not executing the right argument if the left one succeeds is the right thing to do
15:09:21 <benja_> I do like implementing MonadTrans with liftM :-)
15:09:55 <bakert> horrendous newbie question.  if i have a function that is defined twice, once for empty list and once for non-empty list in one of the parameters what do I do if the non-empty-list one needs a "do", add one to the empty list definition, too?
15:10:08 <bakert> @paste
15:10:08 <mbot> http://paste.lisp.org/new/haskell
15:10:23 <benja_> bakert: you use return () in the empty one
15:10:32 <benja_> and now I'm really off to bed. night :)
15:10:33 <lisppaste2> bakert pasted "Trying to work out if I need a "do", or what." at http://paste.lisp.org/display/33980
15:10:58 <bakert> but i need it to return the other argument
15:11:05 <bakert> in the case of the empty list
15:11:20 <benja_> (ok, 'return state' in your case)
15:11:33 <bakert> ah, it's the magic "return" that i'm missing is it?
15:11:43 <quazimodo> you know you are a tragic nerd when you want to write x `divMod` y and you say in your head "ill cast divMod on x and y
15:12:06 <bakert> quazimodo, only 10th level magic users and above can do such things
15:12:09 <quazimodo> i cant believe i actually said cast divMod... i feel like a dungeons and dragons nerd
15:12:21 <nmessenger> quazimodo, nerds come in many different flavors.  You sound like an MMORPG nerd.
15:12:45 <quazimodo> nmessenger, its because of my damn brother and damn friends becoming wow junkies... i hate wow :/
15:12:56 <temujin> wow > *
15:13:01 <temujin> wow pwns you
15:13:09 <temujin> in soviet russia wow plays you
15:13:16 * nmessenger has never played World of Warcraft
15:13:22 <mbishop> in soviet russia, this joke is still funny
15:13:28 <quazimodo> i was a d2 player... wow bores the hell out of me
15:13:39 * bakert daren't play World of Warcraft, for fear of disappearing from reality altogether
15:13:49 <vincenz> bakert: try second life then
15:13:49 * bakert hasn't even looked at a screenshot
15:13:54 <quazimodo> good policy
15:13:57 <quazimodo> dont play it
15:14:03 <temujin> I do not exist in reality any longer than I have to... whats more to life than wow pvp?
15:14:07 <quazimodo> it was designed to waste extreme amounts of time doing the simplest things
15:14:17 <wchogg> I can't justify paying the money for a MMORPG.  I'm still a mud fan.
15:14:20 <temujin> quazimodo yep pvp :) over and over and over again
15:14:21 <vincenz> yeah, play SL instead!
15:14:21 <LoganCapaldo> bakert: If you dissapear from reality you'll have escaped the monad into the pure functional realm ;)
15:14:24 <vincenz> At least SL has purpose!
15:14:39 <bakert> LoganCapaldo, i'm a long way off that, believe me :(
15:14:49 * SamB doesn't think MMORPGs are purely functional
15:15:00 * SamB doesn't think MMORPGs are even as functional as LISP
15:15:06 * vincenz doesn't think that MMORPG players are purely functional
15:15:10 <quazimodo> temujin, no, more like spend 25 minutes making bandages, walk to town for a further 20 minutes, then spend atleast 20 minutes running around town finding the right stores and THEN you MIGHT be able to pvp someone
15:15:19 <temujin> you know... when I got wow when it came out... I didn't know it was an mmo... didn't know what an mmo was...
15:15:20 * bakert thinks MMORPGs is pretty long considering it's an acronym
15:15:36 * mbishop thinks most MMORPG players are still "pure", *wink*
15:15:40 <vincenz> ol
15:15:42 <fasta> WYSIWYG is longer.
15:15:42 <vincenz> +l
15:15:51 <fasta> ^^
15:15:51 * nmessenger pronounces it 'morpy' sometimes just because he can.
15:15:53 <vincenz> WYSIWYG is WYSIWIG
15:15:55 <_matthew_> lol, just reading the quotes on HWN. How does the blogosphere noise get found?
15:16:09 <dons> rss
15:16:11 <fasta> _matthew_: I hope some simple algorithm
15:16:13 <quazimodo> oh gosh i fear i have "routed" the channel into a "nerdish" conversation about "wow"
15:16:20 <temujin> hahaha
15:16:22 <bakert> buy WYSIWYG is pronounceable though - quicker to say "wizziwig" than "ememoharrpeeegeee"
15:16:25 <vincenz> quazimodo: fail!
15:16:36 <_matthew_> dons: it's an rss aggregator?
15:16:43 <vincenz> _matthew_: google blog search
15:16:48 <quazimodo> i put those in " " because i should be swearing visciously
15:16:49 <glguy> ?pl MaybeT (runMaybeT m >>= \a -> liftM (mplus a) (runMaybeT n))
15:16:52 <quazimodo> viciously
15:16:52 <nmessenger> vincenz, Quaz is in a Monad?
15:16:53 <vincenz> _matthew_: dons uses that with an rss on haskell keywords
15:16:55 <temujin> quazimodo : 25mins of bandage making? I don't think have that much bagspace to make that many bandages
15:17:02 <vincenz> nmessenger: comonad
15:17:05 <_matthew_> right. ta
15:17:06 <koala_man> I say "more-pigs"
15:17:07 <quazimodo> temujin, Thats for ONE bandage!!
15:17:09 <temujin> 3mins of bandage making would give me more than I can carry
15:17:09 <quazimodo> haha
15:17:20 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> (P3 <-> "
15:17:22 <temujin> one bandage? what the hell kinda epic bandages are you making ;)
15:17:22 <lambdabot> liyang is in #haskell. I don't know when liyang last spoke.
15:17:24 * _matthew_ will be interested to see if an article appears in the next HWN...
15:17:24 <lambdabot> :)
15:17:30 <nmessenger> ?vixen Are you alive yet LB?
15:17:34 <quazimodo> dont try to argue that it isnt rediculously boring and slow
15:17:35 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> (P3 <-> ))))))"
15:17:35 <lisppaste2> glguy annotated #33978 with "Updated with example usage" at http://paste.lisp.org/display/33978#1
15:17:42 * bakert hasn't unlocked Epic Bandage Making
15:17:48 <glguy> ?bot -- ?
15:17:50 <quazimodo> they gave rogues spells with 1 day and 1 hour cool downs
15:17:51 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> P3)))))"
15:17:52 <quazimodo> laame
15:17:53 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> P3)))))"
15:17:54 <yaxu> hang on, i thought this was a mud
15:17:57 <quazimodo> boring, move on
15:17:57 * vincenz coreturns quazimodo 
15:17:57 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> P3)))))"
15:18:02 <yaxu> you mean we're talking about a real language here?
15:18:03 <fasta> I think we have another bot in the channel.
15:18:03 <glguy> lambdabot: is dealing with all the backlog now?
15:18:13 <quazimodo> vincenz, stop it i feel funny :/
15:18:13 <vincenz> coreturn feels like birthing.  coreturn :: c a -> a
15:18:13 <dons> apparently
15:18:21 <lambdabot>  "(P1 <-> (P2 <-> (P3 <-> (P1 <-> (P2 <-> P3)))))"
15:18:31 <lambdabot> :)
15:18:35 <liyang> Why is lambdabot stalking me?
15:18:35 <temujin> ?bot ~!
15:18:42 <temujin> ?bot ~
15:18:44 <temujin> ?bot ~
15:18:48 <temujin> damnit bot
15:18:49 <temujin> talk to me
15:18:52 <dons> temujin: I'd wait a bit...
15:18:59 <temujin> ooo crap bot spam
15:19:02 <glguy> dons: lambdabot is WAY behind :)
15:19:09 <quazimodo> reset it?
15:19:10 <nmessenger> EVERYBODY STOP! LB is catching up with all the earlier queries
15:19:10 <vincenz> glguy: she's downunder
15:19:11 <dons> yeah, it had blocked on something
15:19:17 <nmessenger> (I think)
15:19:22 <temujin> ahahaha
15:19:30 <dons> that's easier than waiting :)
15:19:35 <bakert> damn straight
15:19:40 <mbishop> murderer!
15:19:47 <vincenz> she's still slow
15:19:52 * fasta thinks the universe discovered #haskell, it's now taking appropriate measures to increase the entropy.
15:19:57 <dons> ?bot
15:20:00 <nmessenger> I suppose so.
15:20:05 * lambdabot stalks temujin
15:20:06 <vincenz> dons: she's having her period?
15:20:09 <quazimodo> fasta, omg!! entropy scary stuff!!
15:20:11 <temujin> ?bot <3
15:20:20 <quazimodo> fasta, infact, im scared now
15:20:31 <lambdabot> :)
15:20:32 <bakert> quazimodo, cast Protection from Evil
15:20:39 <lambdabot> :)
15:20:48 <Botje> is it safe to reference an array while you're still creating it?
15:20:52 <quazimodo> you cant stop entropy its inevitable ARGH *run away and hide*
15:21:01 <temujin> Botje sure
15:21:01 <bakert> oh dear, i don't understand what "return" does.  time to go read something.
15:21:03 <dons> woo hoo! http://shootout.alioth.debian.org/gp4/haskell.php
15:21:03 <Botje> or better: how do you make + nonstrict?
15:21:04 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ...
15:21:06 <dons> ghc 6.6 on the shootout
15:21:27 <dons> time to write some bytestring code!
15:21:30 <xerox> quazimodo: may I suggest an interesting conference video on the subject?
15:21:32 <nmessenger> ?vixen Vincenz called you slow.  What do you think of that?
15:21:32 <lambdabot> i do occassionally, i guess
15:21:46 <nmessenger> :)
15:21:51 <quazimodo> i asked a comp sci student from UWS what he thought of haskell, his immediate reply was that it made him lazy
15:22:00 <quazimodo> i like that
15:22:11 <_matthew_> err, do those benchmarks, on Java, include JVM startup time?
15:22:22 <temujin> what the hell? 90% of comp sci from where I graduated wouldn't know what haskell was if you asked em
15:22:35 <vincenz> dons: is there a parsec for LB?
15:22:49 <_matthew_> temujin: you went to the wrong uni? :)
15:22:50 <xerox> quazimodo: http://www.msri.org/communications/vmath/VMathVideosSpecial/penrose/ the first one.
15:22:52 <lambdabot> http://tinyurl.com/ya5y9q
15:22:56 <dons> vincenz: hmm?
15:22:56 <temujin> _matthew_ aparantly
15:22:56 <nmessenger> ?type many1
15:22:57 <lambdabot> Not in scope: `many1'
15:23:05 <temujin> ?type list
15:23:07 <lambdabot> Not in scope: `list'
15:23:12 <temujin> ?type <3
15:23:13 <lambdabot> parse error on input `<'
15:23:15 <vincenz> dons: does parsec work with LB?
15:23:20 <Cale> ?type (<3)
15:23:21 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
15:23:24 <_matthew_> it's reasonably common language in CS courses in the UK
15:23:27 <dons> what do you mean, vincenz ?
15:23:30 <temujin> I love you lambdabot
15:23:31 <dons> you mean in the prompt?
15:23:33 <_matthew_> and a few do it as the first language too
15:23:41 <dons> yeah, and in .au too
15:23:42 <vincenz> dons: no, as in can you write parsec that parses from LBs?
15:23:42 <Cale> ?type Text.ParserCombinators.Parsec.many1
15:23:45 <lambdabot> forall a st tok. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
15:23:47 <nmessenger> (<3) is an awesome function
15:23:51 <dons> vincenz: yeah
15:23:52 <vincenz> Cale: listbased
15:24:01 <vincenz> notice the [a]
15:24:18 <Cale> hm?
15:24:35 <vincenz> many1 (LB.pack "A")
15:24:43 <xerox> LB = lazy bytestrings
15:24:49 <_matthew_> mmm. dons, those benchmarks are always going to be a poor reflection on Java
15:24:50 <Cale> I was just looking up the type of many1 because nmessenger tried looking for it
15:24:58 <temujin> ahaha... I was wondering if I would spam the channel if I typed ?help or ?list
15:24:59 <vincenz> yes I know, my point is taht many of the combinators in parsec are list oriented, so I wonder how it will work with LBs
15:25:00 <lisppaste2> glguy annotated #33978 with "using MaybeT IO () to exit a for-loop" at http://paste.lisp.org/display/33978#2
15:25:03 <temujin> aparantly not
15:25:10 <Cale> oh, I don't have any conversation context :)
15:25:13 <nmessenger> I looked for it cause someone mentioned Parsec for LB
15:25:16 <quazimodo> temujin, UNSW here has alot of haskell taught in year one, i imagine he graduated in UNSW and did tutoring in UWS, they dont teach it there
15:25:23 <thelsdj> ?type (>'')
15:25:25 <lambdabot> lexical error in string/character literal
15:25:26 <Mynstral> I'm going through the yaht.pdf and having trouble with my implementation of a solution for exercise 3.10.  My code's at http://rafb.net/p/wAyrrF98.html (is there a paste site that does Haskell highlighting?)
15:25:28 <vincenz> For instance the regex entry for shootout uses parsec....
15:25:37 <thelsdj> ?type (>'.')
15:25:38 <lambdabot> Char -> Bool
15:25:41 <Mynstral> A parse error on line 38 (last line)
15:25:48 <nmessenger> Kirby function!
15:25:48 <vincenz> so I wonder hwo that'd work with LB
15:25:59 <lisppaste2> Botje pasted "a + too far .." at http://paste.lisp.org/display/33983
15:26:15 <bakert> Mynstral, paste.lisp.org
15:26:17 <bakert> @paste
15:26:18 <lambdabot> http://paste.lisp.org/new/haskell
15:26:23 <thelsdj> ?type (>**)
15:26:24 <lambdabot> Not in scope: `>**'
15:26:30 <_matthew_> dons: the fact that Java looses to C++ on those just shows how much the JVM startup, class loading, and hotspot optimisations cost. When warmed up, Java normally matches C++ for performance
15:26:34 <Mynstral> Thanks.
15:27:06 <vincenz> dons: I fail to see how...
15:27:12 <Botje> so, how do I make + lazy? (see paste)
15:27:15 <vincenz> dons: unless you just unpack
15:27:15 <shapr> koala_man: I like "more-pigs"
15:27:18 <Botje> just wrap it in a function?
15:27:39 <lisppaste2> Mynstral pasted "yaht ex 3.10" at http://paste.lisp.org/display/33984
15:27:52 <vincenz> Mynstral: what's the problem?
15:28:01 * vincenz convinced Mynstral to join and learn Haskell today \o/
15:28:07 <Mynstral> vincenz: I get a parse error when I load it in ghc
15:28:18 <vincenz> Mynstral: oh
15:28:18 <dons> _matthew_: my point was more that we now have ghc 6.6 on the shootout box :)
15:28:20 <nmessenger> Mynstral, line 37 should indent to the same level as the 'let'
15:28:23 <dons> java schmarva
15:28:33 <vincenz> Mynstral: what specifically?
15:28:33 <nmessenger> Mynstral, 38, too
15:28:51 <lisppaste2> metaperl pasted "trying to find a node in an HXT tree - Cale? :)" at http://paste.lisp.org/display/33985
15:28:57 <_matthew_> dons: oh I see! Well yes, brill! ;-)
15:29:14 * _matthew_ heads for bed.
15:29:26 <vincenz> dons: sounds like doner kebab
15:29:32 <vincenz> dons: doner kebab and java schwarma
15:29:46 <nmessenger> Mynstral, then put a 'do' between 'else' and 'let'
15:30:24 <vincenz> Mynstral: and you need a return in the "then branch" of showFactorials
15:30:25 <dmhouse> shapr: ping, around?
15:30:45 <shapr> dmhouse: pong, I'm about instead of around!
15:31:02 <nmessenger> Mynstral, 'then return []'
15:31:10 <dmhouse> shapr: I have that pubkey for you. I'll email it.
15:31:10 <Mynstral> hehe...  thanks
15:31:17 <shapr> dmhouse: spiffy!
15:31:38 <vincenz> Mynstral: you overuse "do"
15:31:41 <shapr> dmhouse: I'll ask Alex about HAppS project hosting, it might be something worthwhile.
15:31:45 <vincenz> Mynstral: only make those things monadic which need to be
15:31:48 <vincenz> Mynstral: too imperative
15:31:53 <dmhouse> shapr: good plan.
15:32:11 <Mynstral> vincenz: Yeah.  I get that feeling too.
15:32:27 <vincenz> let me fix it
15:32:48 <dmhouse> shapr: sent.
15:33:47 <kpreid> Botje: your paste seems to have broken line breaks
15:34:32 <pejo> dons, any obvious optimizations except bytestring that went in between 6.4 and 6.6?
15:34:38 <pejo> (That helps the shootout, that is).
15:34:53 <Botje> I HATE MYSELF NOW
15:35:02 <Botje> my input file had CRLF line endings
15:35:06 <vincenz> Mynstral: nearl done
15:35:10 * Mynstral nods
15:35:20 <Botje> so my code was fine, argh :(
15:35:45 <kpreid> Botje: 'undefined array element' usually means that you didn't specify all the elements when making the array
15:36:10 <sjanssen> pejo: strictness annotations might make some code look nicer
15:36:28 <Botje> kpreid: i'll keep that in mind for next time
15:38:16 <lisppaste2> vincenz annotated #33984 with "for Mynstral" at http://paste.lisp.org/display/33984#1
15:38:18 <vincenz> Mynstral: done
15:38:36 <Botje> Congratulations, the answer you gave to problem 81 is correct.
15:38:37 <Botje> yay!
15:38:43 <vincenz> Mynstral: it could still be cleaned somewhat, but that is more idiomatic
15:39:00 <Mynstral> vincenz: Thank you.  I'll look this over.
15:39:20 <vincenz> ideally you have functionality to do the data manipulation
15:39:24 <vincenz> and localize the monadic stuff
15:40:56 <yaxu> Mynstral: did you know there are solutions at the end of the yaht.pdf?
15:41:05 <nmessenger> I like 'num <- readLine' instead of 'input <- getLine; let num = read input'
15:42:08 <vincenz> nmessenger: good point
15:42:19 <yaxu> worth not looking
15:42:35 <Mynstral> yaxu: No, I didn't.
15:42:40 <yaxu> but i was pleased when i found them :)
15:42:45 <glguy> I like num <- readLn
15:42:48 <glguy> ?type readLine
15:42:49 <lambdabot> Not in scope: `readLine'
15:42:51 <glguy> ?type readLn
15:42:52 <lambdabot> forall a. (Read a) => IO a
15:43:12 <glguy> ?type System.Console.ReadLine.readLine --?
15:43:14 <lambdabot> Couldn't find qualified module.
15:43:31 <Mynstral> vincenz: Honestly, with as far as I've gotten in yaht, I can't read your changes.
15:43:36 <vincenz> Mynstral: ok
15:43:40 <vincenz> Mynstral: let's talk in oasis
15:43:41 <vincenz> less spam
15:43:49 <glguy> ouch
15:43:52 <quazimodo> do you guys usually sit there and bother to think of the types in your nested functions or do you cheat and use ghci to tell you?
15:43:59 <nmessenger> oops, /me should check function names before posting
15:44:10 <SamB> quazimodo: nested?
15:44:23 <sjanssen> quazimodo: I do a little of both
15:44:32 <quazimodo> SamB, thisFunc x = thatFunc x, thatFunc x = someotherFunc x etcetc
15:45:03 <nmessenger> well, type annotations make it easier ;)
15:45:11 <ClaudiusMaximus> quazimodo: i only figure out and explicitly state the types of functions in where clauses when it refuses to compile otherwise (errors like "cannot infer instance of IArray a Int")
15:45:35 <sjanssen> sometimes when I'm thinking about what a function should do I sketch out the type signature first
15:46:14 <nmessenger> yes!  What does it need, and what will it produce.
15:46:16 <sjanssen> I also frequently use the 'ty' vim script to insert type signatures
15:46:20 <nmessenger> ?quote LoganCapaldo
15:46:20 <lambdabot> LoganCapaldo says: I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do
15:46:43 <quazimodo> heh
15:47:08 <shapr> ?quote type
15:47:08 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
15:47:49 <nmessenger> "phantom existential witness types".  :O
15:49:10 * quazimodo thinks who is the wackiest guy here
15:49:25 <nmessenger> ?quote quazimodo
15:49:26 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:49:37 <quazimodo> temujin is odd
15:49:42 <quazimodo> ?quote temujin
15:49:43 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:49:45 <quazimodo> lol
15:49:46 <nmessenger> Haha.  LB got some sass.
15:49:59 <quazimodo> i thought i had a quote,
15:50:16 <dons> ?quote .*
15:50:18 <lambdabot> ghc says: My brain just exploded.
15:50:25 <dons> ?src flip
15:50:26 <lambdabot> flip f x y = f y x
15:50:32 <dons> ?src ($)
15:50:33 <lambdabot> f $ x = f x
15:51:01 <SamB> ?quote d.*
15:51:01 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
15:53:33 <emu> that is definitely my favorite ghc quote
15:54:08 <_frederik_> it should be "'sploded" tho
15:54:08 * sjanssen boggles at the 41 lambdabot patches since Dec 31
15:55:01 <hyrax42> :t flip M.insert
15:55:03 <lambdabot> Couldn't find qualified module.
15:55:10 <emu> well, keep in mind, australia is in the future
15:55:12 <hyrax42> :t flip Data.Map.insert
15:55:13 <lambdabot> forall a b. (Ord a) => b -> a -> Data.Map.Map a b -> Data.Map.Map a b
15:55:44 <SamB> @quote
15:55:45 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
15:56:43 <augustss> dons: you've implemented @src.  thanks!
15:56:46 <dons> :)
15:56:49 <dons> happy new year
15:57:01 <astrolabe> @help src
15:57:01 <lambdabot> src <id>. Display the implementation of a standard function
15:57:08 <astrolabe> ooh
15:57:19 <astrolabe> @src sequence
15:57:20 <vincenz> it's funky :)
15:57:20 <lambdabot> sequence ms = foldr k (return []) ms
15:57:20 <lambdabot>     where
15:57:20 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
15:57:28 <vincenz> @src unfoldr
15:57:28 <lambdabot> Source for this function is not available.
15:57:32 <vincenz> @src unfold
15:57:33 <lambdabot> Source for this function is not available.
15:57:39 <dons> oh, I thought I'd added unfoldr
15:57:40 * ndm hugs dons
15:57:40 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:57:50 <vincenz> dons: it's manual?
15:57:59 <astrolabe> happy new year ndm
15:58:00 <ndm> dons: how did you implement it? anything as a library hopefully? (i'd love to add it to hoogle)
15:58:07 <SamB> @src putStrLn
15:58:07 <lambdabot> putStrLn s =  do putStr s
15:58:08 <lambdabot>                  putChar '\n'
15:58:11 <SamB> @src putStr
15:58:11 <lambdabot> putStr s  = hPutStr stdout s
15:58:16 <SamB> @src hPutStr
15:58:16 <lambdabot> Source for this function is not available.
15:58:18 <dons> /win 4
15:58:31 <SamB> dons: what ARE you doing?
15:58:35 <ndm> @src @src
15:58:35 <lambdabot> Source for this function is not available.
15:58:37 <xerox> dons try M-4 or ESC 4 :)
15:58:39 <SamB> U+007F makes no sense to me
15:58:42 <vincenz> dons: what client is that?
15:58:44 <sjanssen> @src IO
15:58:44 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:58:58 <xerox> :O
15:59:03 <astrolabe> ug
15:59:07 <thelsdj> @src RealWorld
15:59:08 <lambdabot> Source for this function is not available.
15:59:11 <xerox> The Naked Truth.
15:59:29 <vincenz> @src Peace
15:59:29 <lambdabot> Source for this function is not available.
15:59:31 <quazimodo> what is wrong with this declaration
15:59:38 <quazimodo> getDigits :: (Eq (a, a), Integral a) => a -> [a]
15:59:40 <astrolabe> You mean there really is a representation of the 'real world' inside?
15:59:56 <dmhouse> astrolabe: no, it's a dummy.
15:59:56 <ndm> happy new year astrolabe
15:59:58 <dons> the matrix is not open source
16:00:07 <dmhouse> Hey, lambdabot's back.
16:00:13 <dons> yes, ghc does secretly embed the matrix in your monads
16:00:26 <astrolabe> that explains a lot
16:00:29 <dons> but you can learn to control it, then you can do whatever you want
16:00:37 <vincenz> with comonads
16:00:42 <ndm> you can even do impure things :)
16:00:45 <sjanssen> quazimodo: what sort of error do you get?
16:00:45 <SamB> vincenz: hah
16:00:51 <nmessenger> astrolabe, an 'IO Int' is a function that takes a RealWorld, changes it, and also produces an 'Int'.
16:00:55 * vincenz cojoins SamB 
16:01:18 <quazimodo> sjanssen  Non-type variables in constraint: Eq (a, a)
16:01:19 <quazimodo>     (Use -fglasgow-exts to permit this)
16:01:19 <quazimodo>     In the type signature: getDigits :: (Eq (a, a), Integral a) => a -> [a]
16:01:19 <quazimodo> Failed, modules loaded: none.
16:01:56 <astrolabe> nmessenger: I'm not mad keen on those semantics, isn't the real world changing at the same time?
16:02:11 <sjanssen> quazimodo: you can probably just give Eq a instead of Eq (a, a)
16:02:23 <astrolabe> of its own accord, if you see what I mean.
16:02:34 <ndm> astrolabe: no, because the monad means that you can't change the real world yourself (although if the real world is changing, in real life, then its a concurrency issue)
16:02:56 <syntaxfree> hmm.
16:03:03 <nmessenger> astrolabe, 'putStrLn :: IO ()' changes the state of the RealWorld, and produces no useful pure value.
16:03:06 <syntaxfree> @src fst
16:03:07 <lambdabot> fst (x,_) =  x
16:03:11 <syntaxfree> cool.
16:03:15 <syntaxfree> @src reverse
16:03:15 <lambdabot> reverse = foldl (flip (:)) []
16:03:18 <quazimodo> thanks sjanssen
16:03:24 <syntaxfree> @src map
16:03:24 <lambdabot> map _ []     = []
16:03:25 <lambdabot> map f (x:xs) = f x : map f xs
16:03:37 * syntaxfree hopes map was defined in terms of foldr.
16:03:41 <syntaxfree> s/hopes/hoped
16:03:44 <quazimodo> oh cool
16:03:49 <quazimodo> @src takeWhile
16:03:50 <lambdabot> takeWhile _ []                 =  []
16:03:50 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
16:03:50 <lambdabot>                    | otherwise =  []
16:03:58 <astrolabe> ndm,nmessenger:that's what I mean, it's a concurency issue, so it isn't really a function.
16:04:07 <ndm> syntaxfree: in Hugs its defined as a list comprehension
16:04:26 <ndm> syntaxfree: and foldr is a silly definition, only useful if you haven't got real defunctionalisation
16:04:49 <ndm> @src unsafePerformIO
16:04:50 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
16:05:11 <syntaxfree> defunctionalisation means turning stuff into ordinary loops?
16:05:14 <nmessenger> ?src RealWorld#
16:05:14 <lambdabot> Source for this function is not available.
16:05:16 <LoganCapaldo> lol
16:05:20 <vincenz> ndm: o.O
16:05:21 <dmhouse> ?src lazy
16:05:22 <lambdabot> Source for this function is not available.
16:05:22 <LoganCapaldo> thats shorter than I thought
16:05:39 <ndm> syntaxfree: no, it means removing higher order functions
16:05:42 <sjanssen> syntaxfree: GHC uses magic tricks to turn map to/from foldr for fusion purposes
16:05:46 <LoganCapaldo> @src lambdabot
16:05:46 <lambdabot> Source for this function is not available.
16:05:53 <nmessenger> LoganCapaldo, all it does is manufacture a RealWorld to run through the passed IO a
16:06:02 * ndm is defunctionalising Haskell code right this second
16:06:13 <sjanssen> ndm doesn't like foldr?
16:06:23 <astrolabe> Although, I think there is a point of view in quantum mechanics that the world isn't changing: the meaning of observations is changing which causes observables to change.
16:06:28 <syntaxfree> sjanssen: so, like, cata-ana compositions are actually fused by the compiler?
16:07:02 <sjanssen> syntaxfree: what is ana again?  is it unfoldr?
16:07:04 <ndm> sjanssen: its clearer, everyone can understand a map, foldr is harder
16:07:06 <syntaxfree> yes.
16:07:06 <nmessenger> astrolabe, well, questions of the *actual* implementation are moot.  I believe RealWorld is a synonym for ().  :)
16:07:23 <SamB> @hoogle RealWorld
16:07:24 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
16:07:31 <astrolabe> nmessenger: makes sense
16:07:33 <SamB> hmm, nope.
16:07:44 <bd_> ?src RealWorld
16:07:45 <lambdabot> Source for this function is not available.
16:07:55 <sjanssen> syntaxfree: the fusion is called foldr/build, you can express unfoldr with build, but last I checked GHC didn't
16:08:12 <thelsdj> ?src return
16:08:13 <lambdabot> Source for this function is not available.
16:08:24 <LoganCapaldo> :t let map f = foldr ((:) . f) [] in map
16:08:26 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
16:08:28 <SamB> Prelude> :i Control.Monad.ST.RealWorld
16:08:28 <SamB> data RealWorld  -- <wired into compiler>
16:08:30 <bakert> OK, here's a semi-interesting one.  I have a list of items, and a list of records.  I want to populate one of the fields of each record with one of the items from the first list.  What's the one-liner?
16:08:41 <sjanssen> ndm: I'd agree with that sentiment when teaching Haskell, but I think using foldr is better in the long run
16:08:41 <nmessenger> bd_, if we could find the source of RealWorld, philosophy would no longer matter so much :P
16:08:42 <bakert> Any help greatly appreciated by the newbie.
16:09:11 <sjanssen> why code up induction on lists n+1 times?
16:09:38 <ndm> sjanssen: i still don't use fold's, but use map/filter extensively - different brains understand folds differently
16:09:45 <LoganCapaldo> bakert: zipWith possibly?
16:10:05 <bakert> can i use that with records?
16:10:20 <LoganCapaldo> ?type zipWith
16:10:22 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
16:10:26 <bd_> nmessenger: What, you mean RealWorld isn't open source? :)
16:10:32 <SamB> if you pass a function that will populate a record with an item...
16:10:43 <bakert> yo
16:10:45 <SamB> bd_: it is *wired in*
16:10:46 <bakert> that sounds good
16:10:48 <vincenz> woah
16:10:50 <vincenz> anyone seen vital?
16:10:51 <thelsdj> @src zipWith
16:10:51 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:10:52 <lambdabot> zipWith _ _      _      = []
16:10:58 <nmessenger> ?type zipWith (\x r -> r { field <- x})
16:10:59 <lambdabot> parse error on input `<-'
16:11:06 <Cale> vincenz: yeah, it's been around for about a year :)
16:11:08 * nmessenger doesn't know record syntax
16:11:11 <vincenz> Cale: it's nifty
16:11:11 <sjanssen> vincenz: I've played with the Java version before
16:11:15 <vincenz> sjanssen: how is it?
16:11:16 <Cale> vincenz: it is :)
16:11:16 <LoganCapaldo> nmessenger: =
16:11:20 <LoganCapaldo> not <-
16:11:21 <vincenz> sjanssen: seems like mathematica on haskell
16:11:30 <vincenz> with great graphics
16:11:32 <sjanssen> vincenz: I thought it was very neat
16:11:34 <bakert>  ?type zipWith (\x r -> r { field = x})
16:11:35 <vincenz> :)
16:11:40 <SamB> Prelude> :i IO
16:11:40 <SamB> newtype IO a
16:11:40 <SamB>   = IO (GHC.Prim.State# GHC.Prim.RealWorld
16:11:40 <SamB>         -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
16:11:41 <vincenz> what compiler do they use
16:11:49 <bakert> ?type zipWith (\x r -> r { field = x})
16:11:50 <lambdabot> Not in scope: `field'
16:12:02 <LoganCapaldo> bakertIt doesn't know your types :)
16:12:05 <sjanssen> I found the idea of an infinite canvas that is lazily populated very neat
16:12:11 <bakert> !
16:12:12 * SamB notes that State# RealWorld isn't the same as RealWorld
16:12:17 <nmessenger> r should be of a record type that has a 'field' field
16:12:21 <bakert> that looks like the basis of the answer though.  thanks folks.
16:12:43 <vincenz> sjanssen: it's great caus eit seems to have easy ways of opening images and such, and easily seeing them
16:12:58 <bakert> every time i try i can replace one of my functions with a one liner.  where does it stop?  will eventually the entire program be one line?!!!
16:13:23 <bakert> with a lot of $s in it!
16:13:23 <xerox> bakert: and there's more, it also will have no formal paramters.
16:13:30 <bd_> bakert: Yes, but you'll need to meditate for ten years to understand it.
16:13:46 <SamB> bakert: eventually you will find that you have written something that isn't in the library ;-)
16:13:50 <LoganCapaldo> yes it shall have only informal parameters ;)
16:13:51 <bd_> Once you do, of course, you'll have transcended turing machines completely.
16:14:02 <nmessenger> xerox, yep, just a stream of transformations :D
16:14:09 <LoganCapaldo> They're lazy after all
16:14:21 <LoganCapaldo> No need to put on the tux :)
16:14:29 <bakert> i haven't felt this much at sea when programming since i learnt java in 2000.
16:14:37 <vincenz> sjanssen: not to mention right clicking on graphs and getting some cool popup menu
16:14:39 <bakert> its good!
16:14:43 <bakert> learning ...
16:14:44 <vincenz> sjanssen: just looking at the webpage, but it looks quite nie
16:14:46 <vincenz> s/nie/nice
16:14:59 <augustss> Doing :i on IO should not show anything.  The IO type is meant to be abstract.
16:15:20 <allbery_b> @quote true.Haskell.*functions
16:15:21 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
16:15:45 <nmessenger> Ooh!  Regexes?!
16:16:00 <sjanssen> augustss: I like ghci's behavior. :i is a nice way to poke around in ghc's internals
16:16:03 <bd_> what do all those #s mean in the :i IO? I know as a suffix it means a GHC builtin, but what about the first and last in (# GHC.Prim.State# GHC.Prim.RealWorld, a #) ?
16:16:05 <kpreid> bakert: less ($), more (.)!
16:16:17 <allbery_b> yeh, that was one of the recent upgrades to lambdabot
16:16:21 <vincenz> Cale: what does it use as backend?
16:16:21 <SamB> bd_: unboxed tuples
16:16:22 <sjanssen> bd_: unboxed tuple
16:16:31 <bakert> kpreid, haven't got my head around (.) yet.  its on my list of things to work out (right under "monads")
16:16:37 <bd_> oh
16:16:40 <augustss> sjanssen: but people might think it's part of Haskell, whereas it's veru GHC specific
16:16:53 <ndm> augustss: most of Haskell is now GHC specific...
16:16:59 <SamB> augustss: you'd think the #s would clue them in?
16:16:59 <Lunchy> is there a way to convert IO Bool to Bool?
16:17:14 <Saizan> >>=
16:17:17 <nmessenger> bakert, (.) is neat!  Think of it like command-line piping, 'f . g' sends g's output to f's input
16:17:43 <mahogny> Lunar^, the IO is there for a reason. you don't exactly "convert" it. you might want to read up on monads
16:17:58 <Saizan> nmessenger: only reversed :)
16:18:15 <vincenz> Cale: ping
16:18:18 <SamB> mahogny: s/Lunar%/Lunchy/
16:18:21 <SamB> er.
16:18:26 <mahogny> blech
16:18:27 <SamB> s/%/^/
16:18:33 <nmessenger> let pipe = flip (.) -- '|' is taken :(
16:18:35 <bakert> nmessenger, isn't that what $ does?  it's gone midnight here and my brain is melting!
16:18:51 <bakert> no $ adds invisible brackets
16:18:58 <bakert> not quite the same thing ... but similar
16:19:19 <vincenz> sjanssen: ping
16:19:20 <xerox> f . g = \x -> f (g x)
16:19:23 <bakert> i'll have to experiment
16:19:27 <xerox> f $ x = f x
16:19:28 <Lunchy> SamB: okay, thanks, I'm a newb (which I'm sure it obvious :))
16:19:42 <xerox> G'nite.
16:19:46 <nmessenger> bakert, they're a little different, 'f $ g x' versus '(f . g) x'.  (.) gives you the flexibility to hook functions together without regard to their arguments.
16:19:46 <sjanssen> vincenz: hmm?
16:20:14 <vincenz> sjanssen: what does it use as compiler/interpreter?
16:20:25 <LoganCapaldo> ($) :: I am become $, deleter of parentheses
16:20:32 <kpreid> bakert: f $ g $ x  ===  (f $ (g $ x))  ===  f . g $ x  ===  (f . g) $ x  ===  f (g x)
16:20:40 <dons> ?src ($)
16:20:40 <lambdabot> f $ x = f x
16:20:45 <nmessenger> ... and introducer of strange type errors!
16:20:46 <sjanssen> vincenz: I believe the Java version uses it's own interpreter that supports a subset of Haskell
16:20:51 <vincenz> sjanssen: oh right
16:20:54 <vincenz> sjanssen: well it's very impressive :)
16:21:09 <vincenz> sjanssen: if we got proper access to ghc internals, we could even do this in haskell with gtk2hs
16:21:17 <LoganCapaldo> ?i ($)
16:21:18 <lambdabot> Maybe you meant: id index instances instances-importing . v
16:21:18 <bakert> kpreid, now that's just mean ;)
16:21:45 <bakert> so actually (.) is much cooler than $ because it is more applicable.  but perhaps less readable?
16:21:49 <LoganCapaldo> No I didn't but thanks for trying :)
16:21:49 <vincenz> sjanssen: it's a funky idea, the Edit typeclass, cause in a way it ties the code to the environment (reminescent of smalltalk)
16:22:00 <kpreid> sjanssen: what are you discussing?
16:22:05 <vincenz> kpreid: vital
16:22:08 <sjanssen> vincenz: I think there is a rewrite of Vital going on ... mentioned in the communities and activities report
16:22:15 <kpreid> @google haskell vital
16:22:16 * vincenz nods
16:22:18 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
16:22:18 <lambdabot> Title: Vital homepage
16:22:38 <nmessenger> bakert, well, ($) is useful in sections:
16:22:41 <nmessenger> > map ($2) [negate, (+1), (^3)]
16:22:42 <lambdabot>  [-2,3,8]
16:22:55 <kpreid> that looks neat!
16:22:59 <LoganCapaldo> nmessenger: That's a neat trick
16:22:59 <ndm> bakert: different beasts for different purposes - after a while you figure out which one goes where
16:23:01 <xerox> > [negate,(+1),(^3)] `sequence` 2
16:23:02 <lambdabot>  [-2,3,8]
16:23:03 <bakert> goddamn this stuff is so dense!
16:23:06 <vincenz> kpreid: it's awesome
16:23:09 <bakert> i love it but it is hurting!
16:23:29 <bakert> (dense as in lots in a small space not as in "thicko"!)
16:23:29 <monochrom> Who says (.) is less readable?
16:23:34 * vincenz heads to bed
16:23:35 <vincenz> night
16:23:37 <bakert> night
16:23:39 <kpreid> ooh, sandboxed java web start !
16:23:44 <nmessenger> night
16:23:53 <vincenz> kpreid: check how easy it is to show images :)
16:23:56 <vincenz> kpreid: it's like mathematica on haskell
16:23:57 <bakert> monochrom, no you're probably right they can probably both be abused in much the same way
16:24:12 <glguy> nmessenger: or: sequence [negate, (+1), (^3)] 2
16:24:18 * kpreid runs it
16:24:22 * glguy just read the backlog
16:24:31 <monochrom> If you understand unix shell script "xxx < infile | yyy | zzz > outfile" you understand haskell "out = (zzz . yyy . xxx) in".
16:25:10 <LoganCapaldo> hehhe
16:25:20 <LoganCapaldo> that sounds like a new plugin for lambdabot
16:25:21 <monochrom> See also http://www.vex.net/~trebla/weblog/pointfree.html
16:25:22 <lambdabot> Title: The Point of Pointfree
16:25:25 <nmessenger> I'm only now starting to understand convoluted compositions of compositions, though
16:25:25 <LoganCapaldo> @sh and @unsh
16:25:26 <lambdabot> Maybe you meant: shootout show . ask bf ft ghc id msg pl src v wn
16:25:34 <glguy> ?shootout
16:25:35 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:25:45 <glguy> ?ghc
16:25:45 <lambdabot> ghc says: A lazy (~) pattern connot bind existential type variables
16:25:46 <SamB> you mean like...
16:25:51 <monochrom> True, things like ((f .) . g) are more exotic.
16:26:04 <mbishop> connot bind eh?
16:26:10 <glguy> ((f .) . g) is the one that everyone should know
16:26:11 <LoganCapaldo> yeah those make my brain melt out my ears
16:26:30 <kpreid> nmessenger: do you understand ap yet?
16:26:38 <nmessenger> kpreid, no
16:26:38 * allbery_b still hasn't quite gotten those yet either
16:26:46 <monochrom> ((.) . (.)) is the most, um, mysterious and intriguing :)
16:26:53 <xerox> monochrom: cheater
16:27:00 <glguy> ?unpl ((.) . (.))
16:27:01 <lambdabot> (\ i b c f -> i (b c f))
16:27:04 <kpreid> nmessenger: see if this helps:
16:27:06 <monochrom> I do not cheat.
16:27:13 <kpreid> > ap (,) (+1) 0
16:27:15 <lambdabot>  (0,1)
16:27:24 <xerox> > let (.:) = (.) . (.) in ((+1) .: (*)) 4 5
16:27:26 <lambdabot>  21
16:27:39 <xerox> > (((+1) .) . (*)) 4 5
16:27:40 <lambdabot>  21
16:27:49 <LoganCapaldo> Vital looks cool
16:27:54 <glguy> > ((+1) >>= (,)) 4
16:27:55 <lambdabot>  (5,4)
16:28:00 <LoganCapaldo> Only 1 question, does deriving Edit work?
16:28:01 <glguy> > ((,) =<< (+1)) 4
16:28:03 <lambdabot>  (5,4)
16:28:03 <xerox> I.e. they are the same thing.
16:28:13 <glguy> > ((,) `ap` (+1)) 4
16:28:15 <lambdabot>  (4,5)
16:28:32 <kpreid> First impression of Vital: needs a zoom *out* command
16:29:13 <vincenz> kpreid: yeah
16:29:17 <kpreid> the documents are wider than my screen
16:29:25 <vincenz> kpreid: but yeah, I think the most focus has been on semantics, not usability
16:29:33 <kpreid> yeah, yeah :)
16:29:34 <nmessenger> (concat .) . map -- map takes an (a -> b) and produces a ([a] -> [b]). When ([a] -> [b]) gets a [a], it passes it to 'concat' to produce a [b]
16:29:38 <vincenz> kpreid: funky ain't it?
16:29:50 <vincenz> with some work this could become a great teaching tool
16:29:51 <SamB> you have to admit it is easier to add usability given appropriate semantics, right?
16:29:55 <nmessenger> er, wait not quite
16:29:57 <vincenz> SamB: definitely
16:30:09 <vincenz> vital++
16:30:17 <vincenz> anyways
16:30:19 <vincenz> now I'm really off
16:30:24 <kpreid> haven't tried anything yet, I was too distracted by all the scrolling around
16:30:33 <vincenz> :D
16:30:37 <nmessenger> When the ([a] -> [b]) gets an [a], it produces a [b], which it passes to concat, which produces a 'b'
16:30:56 <bd_> hm, doesn't that make it the same as concat . map?
16:30:57 <vincenz> kpreid: nor I, but the webpage seems promisiing if you read what you should be able to do
16:31:10 <glguy> ?type concat . map
16:31:11 <vincenz> bd_: concatMap?
16:31:12 <lambdabot>     Expecting a function type, but found `b'
16:31:12 <lambdabot>       Expected type: (a1 -> b) -> [[a]]
16:31:23 <vincenz> @type \f -> concat . map f
16:31:24 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:31:26 <nmessenger> map produces a function, concat expects a list
16:31:29 <vincenz> @type concatMap
16:31:30 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
16:31:41 <glguy> ?type (concat . ) . map
16:31:43 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:31:46 <vincenz> you want concatMap
16:31:52 <vincenz> @src concatMap
16:31:53 <lambdabot> concatMap f = foldr ((++) . f) []
16:31:55 <vincenz> hmm
16:32:00 <nmessenger> yes I understand concatMap, I'm just laying out the composing compositions
16:32:01 <vincenz> concatMap f = concat . map f
16:32:32 <xerox> (f .) . g = \x -> (f .) (g x) = \x -> f . (g x) = \x y -> f (g x y)
16:32:49 * allbery_b thinks... (x . y) only works if y expects a single argument; if it needs two, you need to compose with ((x .) . y) to apply to the second argument?
16:32:56 <xerox> allbery_b: right.
16:33:10 <xerox> You compose together n (.) to get a composition of a n-ary function with an unary one.
16:33:11 <LoganCapaldo> concatMap = join . fmap ;)
16:33:31 <nmessenger> ?type join . fmap -- still doesn't type
16:33:31 <xerox> LoganCapaldo: (join .) . fmap or equivalently join .: fmap where .: = (.) . (.)
16:33:32 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
16:33:32 <lambdabot>       Expected type: (a -> b) -> f a -> f a -> a1
16:33:46 <xerox> ?pl \f g x -> f (g x)
16:33:47 <lambdabot> (.)
16:33:51 <xerox> ?pl \f g x y -> f (g x y)
16:33:52 <lambdabot> (.) . (.)
16:34:02 <xerox> ?pl \f g x y w z -> f (g x y w z)
16:34:02 <lambdabot> (.) . (.) . (.) . (.)
16:34:16 <dmhouse> shapr: still around?
16:34:20 <allbery_b> yay, i's making sense
16:34:24 <allbery_b> *it's
16:34:25 <nmessenger> for my own sake, I need to puzzle through what (.) . (.) does.
16:34:40 <SamB> ... besides making people giggle?
16:34:48 <nmessenger> right
16:35:07 <bd_> ?pl \f g x y z -> f (g x y z)
16:35:08 <lambdabot> (.) . (.) . (.)
16:35:16 <nmessenger> not even what it *does* so much as how it connect the parts together.
16:35:28 <dmhouse> nmessenger: expand it out.
16:35:34 <glguy> ((.).(.))f g x y -> ((.) ((.) f)) g x y -> (((.) f).)g x y -> ((f .) .) g x y -> ((f .) . g) x y
16:35:47 <dmhouse> Yeah, like that.
16:36:42 <glguy> concatMap = ((concat .) .) map
16:36:45 <nmessenger> oh yeah, that's right.  shapr made me CAPTAIN LAMBDA after all, so I should be able to beta-substitute ;)
16:36:46 <LoganCapaldo> this is what I get for not actualyl trying it out
16:36:53 <dmhouse> ((f .) . g) x y -> ((f .) g x) y -> (f . g x) y -> f (g x y)
16:37:01 <dmhouse> That's the end of what glguy wroke.
16:37:02 <dmhouse> *wrote
16:37:58 <glguy> f (g x y z) = (((f .) .) .) g x y z
16:38:07 <glguy> ?unpl (((f .) .) .) g x y z
16:38:07 <lambdabot> (f (g x y z))
16:38:24 <LoganCapaldo> heeey
16:38:53 <LoganCapaldo> nope
16:39:00 <LoganCapaldo> thought I had an ephinpahny
16:39:05 <LoganCapaldo> I was wong
16:39:08 <glguy> lol
16:39:16 <thelsdj> indigestion?
16:39:26 <SamB> who are you now?
16:39:27 <LoganCapaldo> Oh man typos all over the place
16:39:28 <glguy> power spike?
16:39:52 * nmessenger has had more ephishpthanyays toying with Haskell than he can remember with any language in years
16:40:27 <LoganCapaldo> Haskell is too powerful I think
16:40:39 <LoganCapaldo> I need a more dumbed down language :)
16:40:49 * allbery_b points to Logo :)
16:40:58 <nmessenger> There's always Java. :o)
16:41:17 <SamB> a language that doesn't let you within miles of the problem domain?
16:41:31 <nmessenger> exactly.  dumbed down
16:41:36 <allbery_b> a language which is challengng perl for baroqueness is hardly dumbed down :)
16:41:55 <bakert> baroqueness.  you heard it here first folks!
16:42:05 <allbery_b> (java, that is)
16:42:14 <bakert> baroquosity is surely the right word ;)
16:42:15 <SamB> hmm, if it is baroque, why doesn't somebody fix it?
16:42:22 <glguy> # Extravagant, complex, or bizarre, especially in ornamentation: "the baroque, encoded language of post-structural legal and literary theory" (Wendy Kaminer).
16:42:26 <shapr> dmhouse: You called?
16:42:30 <nmessenger> Though, java was my first real OOP.  I had quite a few epiphanys writing in it.
16:42:32 <allbery_b> (does anyone really understand all the interactions of type erasure?)
16:42:34 * LoganCapaldo groans
16:42:41 * glguy slaps the pun out of SamB 's mouth
16:42:41 <glguy> ;)
16:42:45 <bakert> nmessenger, me too. didnt get OO befor ehtat
16:42:53 <bakert> s/befor ehtat/before that/
16:43:04 <SamB> glguy: I still think it is a reasonable question!
16:43:09 <nmessenger> embraces teh missplelinigs!
16:43:15 <shapr> My sister had a shirt "Baroque, when you're out of Monet"
16:43:25 <dons> heh
16:43:37 * LoganCapaldo groans again
16:43:41 <glguy> I had some epiphanies writing C# code earlier "Why have a strong type system when you can write tons of if (arg == null) throw new ArgNullExcept()!
16:43:44 <glguy> or
16:44:01 <glguy> "Who needs pattern matching when you can work around that feature with lots of vistor pattern scaffolding?
16:44:04 <glguy> or
16:44:12 <glguy> "Why bother with functions when cut and paste works so well?
16:44:17 <shapr> ouch
16:44:44 <nmessenger> Don't be *too* harsh, I had to start somewhere to progress to where I am today.
16:45:00 * ndm thinks C# is better than Haskell for writing GUI's
16:45:13 <nmessenger> Doesn't mean I'd like to go *back*, though.  ;)
16:45:16 <LoganCapaldo> I thought C# was supposed to have the largest intersection of functionyness and mainstreamyness
16:45:25 <glguy> but not because the language is well designed
16:45:27 <sjanssen> glguy: I had to write tons of visitor pattern in my Java compilers course, it made me pretty grumpy
16:45:43 <SamB> is That like truthyness?
16:45:58 <glguy> And then I look at my bookshelf, and stare at hte "Design Patterns" book, and notice how each of those patterns describes a flaw in OO
16:46:09 <mahogny> it would be nice if someone sat down and whipped up a good standard way of doing haskell GUIs using traditional libraries
16:46:18 <LoganCapaldo> SamB: Likely
16:46:25 <mahogny> I find myself inventing new solutions all the time :/
16:46:27 <shapr> dmhouse: ping?
16:46:39 * sorear_ pokes ?seen
16:46:41 <LoganCapaldo> a GUI Monad of course!
16:46:53 <maskd> has anyone here written an haskell program to "test" collatz conjecture?
16:46:55 <Lunchy> has anyone used wxHaskell?
16:46:55 <sorear_> dumb command line completeion
16:46:56 * LoganCapaldo sticks everything in a Monad
16:46:58 <shapr> mahogny: Obviously that makes you the person to whip up the standard Haskel GUI way, right?
16:46:59 <mahogny> Lunchy, I have
16:47:02 <Cale> maskd: I have
16:47:03 <shapr> @seen dmhouse
16:47:04 * SamB wonders why amazon predicts his package to be delivered on the 8th, when it is already in philadelphia now?
16:47:04 <lambdabot> dmhouse is in #haskell-blah and #haskell. I last heard dmhouse speak 10m 1s ago.
16:47:06 <mahogny> shapr, no :(
16:47:06 <Lunchy> good/bad?
16:47:13 <pejo> glguy, did you read the link from Korollary yesterday, about oop?
16:47:14 <mahogny> shapr, I could give input though
16:47:19 <glguy> pejo no?
16:47:23 <maskd> Cale: do you have the source?
16:47:28 * sorear pokes ?seen
16:47:34 <shapr> mahogny: Well, you got tha itch, and you got the experience, so...
16:47:37 <pejo> glguy, http://etymon.blogspot.com/2006/04/what-is-object-oriented-programming.html
16:47:39 <lambdabot> Title: Etymon: What is Object-Oriented Programming, http://tinyurl.com/y63vqh
16:47:48 <Cale> maskd: I don't know. Maybe. I probably threw it away after. It's only a few lines.
16:48:00 <shapr> SamB: Amazon said my package shipped a coupla days ago from AZ, but I haven't heard anything since.
16:48:04 <Cale> (I didn't do anything nontrivial)
16:48:07 <mahogny> shapr, well. I guess unless someone else do it then I will have to. my next GUI app will be major so unless I find a standard I am doomed :P
16:48:11 <shapr> And it's that Hamming book I've wanted for YEARS!
16:48:19 <LoganCapaldo> @google collatz conjecture
16:48:21 <lambdabot> http://en.wikipedia.org/wiki/Collatz_conjecture
16:48:22 <shapr> mahogny: ergo, write the standard and you're not doomed!
16:48:26 <nmessenger> sorear: quit picking on @seen!
16:48:29 <mahogny> shapr, right
16:48:35 <shapr> @seen sorear
16:48:36 <lambdabot> sorear is in #haskell. I last heard sorear speak 1m 7s ago.
16:48:43 <SamB> hmm, its being shipped with the USPS apparantly
16:48:44 <shapr> @seen sorear_
16:48:44 <lambdabot> sorear_ has changed nick to sorear.
16:48:44 <lambdabot> sorear is in #haskell. I last heard sorear speak 1m 15s ago.
16:48:52 <shapr> @seen JaffaCake
16:48:53 <lambdabot> I saw JaffaCake leaving #ghc 13d 7h 56m 15s ago, and .
16:48:55 <shapr> aww
16:48:56 <sorear> If I knew what <3 #haskell meant, that seems to be the Standard
16:49:09 <SamB> so that might explain how it could take them so long once it has reached philadelphia
16:49:14 <pejo> sorear, <3 forms a heart, if you look sideways on it.
16:49:14 <maskd> Cale: i'm trying to think something here but the code seems too ugly in my mind
16:49:20 <mahogny> shapr, for a while the GUI part almost got me thinking in terms of using C++. but then I straightened myself out again. the vikings did not use C++ for their GUIs so there is no reason I should
16:49:23 <shapr> pejo: Still looks like testicles to me.
16:49:25 <SamB> also might explain why there are no times in these tracking entries...
16:49:37 <shapr> I guess I need to change fonts.
16:49:43 <glguy> (=3
16:49:44 <pejo> shapr, *cough* what do you usually see when they show the clouds? ;)
16:49:58 * nmessenger dies laughing
16:50:11 <sorear> > let f x = if odd x then 3*x+1 else div x 2 in all $ map (elem 1 . iterate f) [1..]
16:50:12 <lambdabot>  Couldn't match `a -> Bool' against `[b]'
16:50:28 <sorear> > let f x = if odd x then 3*x+1 else div x 2 in and $ map (elem 1 . iterate f) [1..]
16:50:32 <lambdabot> Terminated
16:50:59 <sorear> maskd: there, now someone has
16:51:11 <Cale> lisppaste2: url
16:51:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:51:29 <lisppaste2> Cale pasted "collatz" at http://paste.lisp.org/display/33997
16:51:35 <Cale> just wrote that right now :)
16:52:03 <Cale> There are some obvious ways to make it faster if you actually care :)
16:52:05 <nmessenger> oh, that thing is called collatz?
16:52:09 <dmhouse> shapr: you getting all those /msgs, yes?
16:54:26 <Cale> You can change it to read  check = takeWhile (/= 1) . iterate collatz
16:54:34 <Cale> if you'd like it to print the traces
16:55:40 <Cale> or   check n = 1 `elem` iterate collatz n
16:55:47 <Cale> if you just want the boolean result
16:56:30 <LoganCapaldo> And then feed it into quickcheck for all eternity?
16:56:54 <xerox> @let collatz n | even n = n `div` 2 | odd n = 3 * n + 1
16:56:55 <lambdabot> Defined.
16:57:35 <xerox> > map ((1 `elemIndex`) . iterate L.collatz) [1..]
16:57:37 <lambdabot>  [Just 0,Just 1,Just 7,Just 2,Just 5,Just 8,Just 16,Just 3,Just 19,Just 6,Jus...
16:57:44 <nmessenger> > takeWhile (/= 1) . iterate collatz $ 27
16:57:46 <lambdabot>  [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,...
16:58:00 <Cale> > length . takeWhile (/= 1) . iterate collatz $ 27
16:58:02 <lambdabot>  111
16:58:06 <nmessenger> wow
16:58:17 <Cale> > map (length . takeWhile (/= 1) . iterate collatz) [1..]
16:58:19 <lambdabot>  [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7,7,15,15,10,23,10,111,18,18,...
16:58:35 <Cale> You picked a winner :)
16:58:35 <maskd> haskell is too complex :(
16:58:35 <nmessenger> I kinda just poked in the dark there
16:58:55 <LoganCapaldo> > length . takeWhile (/= 1) . iterate collatz $ 1
16:58:56 <lambdabot>  0
16:59:04 <Cale> maskd: having trouble understanding the code?
16:59:09 <LoganCapaldo> Yes!
16:59:14 <nmessenger> maskd: do you not understand the collatz thingy?
16:59:16 <Cale> maskd: feel free to ask questions :)
16:59:20 <LoganCapaldo> That's a proof right?
16:59:31 <Cale> Of course, nobody *really* understands the collatz thingy :)
16:59:41 <LoganCapaldo> Cause of the Curry-Howard isomorphism.
16:59:43 <shapr> pejo: haha!
16:59:50 <LoganCapaldo> I'm a mathematical genius! :)
17:00:16 <Cale> LoganCapaldo: It's a Curry-Howard proof of something not so interesting :)
17:01:04 <nmessenger> (takeWhile (/= 1) . iterate anyFunction) 1 -- will always be []
17:01:05 <Cale> The expression you typed there has type Integer, so your program is a proof that the Integer type is nonempty.
17:01:32 <LoganCapaldo> Hmm, are there any interesting proofs in Haskell?
17:01:48 <sorear> (.) is a nice proof
17:01:49 <LoganCapaldo> (That are easy to understand by less than brilliant people)
17:01:56 <Cale> Well, mostly just of simple logical propositions.
17:02:27 <Cale> But if you include MPTCs/fundeps etc. there are probably real interesting things.
17:02:51 <glguy> pejo: this article speaks to me http://etymon.blogspot.com/2006/04/perils-of-avoiding-heresy-or-what-are.html
17:02:54 <lambdabot> Title: Etymon: The perils of avoiding heresy (or "What are Design Patterns"), http://tinyurl.com/y2dz3b
17:03:34 <nmessenger> ?let collatzList = takeWhile (/= 1) . iterate collatz
17:03:35 <lambdabot> Defined.
17:03:45 <mahogny> LoganCapaldo, I helped some people with this course: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/prove/    it seemed the labs were rather rewarding. check the lecture notes. some haskell is there
17:03:47 <lambdabot> Title: Program Verification
17:04:56 <nornagon> Hey, does anyone have a Parsec scheme parser lying around that they'd be able to show me? I've written something which seems to work, but is IMO very ugly; I'm looking for comparison. (Just the parser, mind, I'm not doing evaluation just yet.)
17:05:13 <glguy> nornagon: did you paste that one yesterday?
17:05:22 <nornagon> glguy: it was only part of one
17:05:38 <orbitz> i can do somethign like t f = foldl f is there a similar way to apply to an arbitrary arguments to foldl? for instance if i want to do t l = foldl ... l ?
17:05:38 <jcreigh> nornagon: I dunno, maybe look at "Write Yourself A Scheme in 48 hours"?
17:05:40 <glguy> nornagon: why did you treat dotted lists differently than normal lists?
17:05:49 <nornagon> jcreigh: that's what I'm going through
17:05:49 <Cale> glguy: has that been reddited, I want to mod it up
17:05:52 <Cale> ?
17:05:56 <nornagon> but the trick is in the exercises :P
17:06:04 <jcreigh> nornagon: hmm, okay. :)
17:06:20 <nornagon> Which the tutorial doesn't give solutions to, afaik
17:06:37 <nornagon> I'm really just looking for parsec examples
17:06:45 <LoganCapaldo> orbitz: t l a = foldl a l
17:06:50 <nornagon> because I'm very ignorant of most of its features :)
17:06:50 <jcreigh> (I haven't looked at that tutorial much; I assumed it contained a fairly complete parser, but I guess not.)
17:06:55 <orbitz> LoganCapaldo: i dont' ahve a yet
17:07:07 <orbitz> oh hrm
17:07:08 <LoganCapaldo> I know
17:07:10 <orbitz> i geus sit doens't matter
17:07:13 <glguy> http://programming.reddit.com/info/wsqx/comments -- Cale
17:07:15 <dmhouse> Cale: http://imagebin.org/6826 first 1000 collatz values.
17:07:15 <lambdabot> Title: The perils of avoiding heresy (or "What are Design Patterns?") (reddit.com)
17:07:16 <lambdabot> Title: Imagebin - A place to slap up your images.
17:07:27 <LoganCapaldo> you can say t l and it will give you back a function that takes a
17:07:28 <orbitz> LoganCapaldo: i was looking more fo ra point-free way
17:07:33 <nornagon> jcreigh: the exercises involve stuff like parsing weird R5RS float syntax
17:07:43 <LoganCapaldo> @type flip
17:07:45 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
17:07:51 <dmhouse> Cale: just a quick plot but it's quite interesting.
17:07:55 <Cale> dmhouse: lengths of the chains to 1?
17:07:58 <Cale> yeah
17:08:09 <nornagon> which look like #e#d1.125L2
17:08:12 <LoganCapaldo> t = flip foldl
17:08:29 <dmhouse> Cale: it's essentially a plot of y = check(x).
17:08:58 <LoganCapaldo> orbitz: Also, you can ask lambdabot
17:09:13 <LoganCapaldo> @pl (\x y z -> x (z y))
17:09:13 <lambdabot> (. flip id) . (.)
17:09:36 <orbitz> funky thang
17:09:38 <orbitz> thanks
17:09:44 <dmhouse> Cale: to make the plot I added a fromJust, got rid of the colon, compiled your code, ran it and redirected the output to a file, ran gnuplot, then plot "collatz-out". Really easy. :)
17:09:53 <dmhouse> Anyway, I really need to get to bed.
17:10:18 <Cale> dmhouse: It makes me wonder whether anyone's proved that given that the iteration terminates with 1, it does so in a number of steps which is logarithmically bounded
17:11:45 <glguy> has it been proven that the sequence *always* reaches 1??
17:11:49 <glguy> (single ?)
17:12:24 <glguy> oh "given that iteration terminates"
17:12:24 <Cale> no, it's one of the major open problems in mathematics
17:13:04 <astrolabe> I'm suprised at how ordered the plot looks
17:13:05 <jcreigh> Cale: oh, really? Hmm...for some reason I'd thought that had been proved.
17:13:24 <bakert> when there's no reason to choose one or the other do you go for foldl or foldr?
17:13:29 <LoganCapaldo> No proof for you!
17:13:36 <glguy> foldr
17:13:47 <jcreigh> (In this age of computers, I'm guessing people have tested it up to SOME_HUGE_NUMBER, but nobody has *proved* it...)
17:13:47 <glguy> if partial results don't make sense, foldl'
17:13:48 <astrolabe> Also, I'd assumed it was a curiosity rather than considered important.
17:15:09 <glguy> The Collatz algorithm has been tested and found to always reach 1 for all numbers <= 3*2^53
17:15:15 <thelsdj> a book i have says its been tested to 27*10^15
17:15:17 <glguy> > 3 * 2 ^ 53
17:15:19 <lambdabot>  27021597764222976
17:15:38 <thelsdj> > 27 *10 ^ 15
17:15:39 <lambdabot>  27000000000000000
17:15:50 <glguy> thelsdj: by Vardi? (Wolfram says that was outdone)
17:16:02 <glguy> ah
17:16:06 <glguy> Vardi was 10^15
17:16:22 <thelsdj> this book just has a quick mention with that #, doesn't say who by
17:16:43 <Cale> That was odd, X-Chat's editbox stopped allowing me to select text from it.
17:18:44 <astrolabe> http://www.ieeta.pt/~tos/3x+1.html gives 12 * 2^58
17:18:46 <lambdabot> Title: 3x+1 conjecture verification results
17:19:16 <bakert> when there's no reason to choose one or the other do you go for foldl or foldr?
17:19:20 <bakert> oops ignore me
17:19:37 <glguy>  /ignore bakert
17:19:39 <glguy> oops
17:19:40 <sorear> iirc 29 goes for >300 steps - not very well bounded at all
17:19:43 <jcreigh> heh
17:19:50 <monochrom> foldr f if f is non-strict, foldl' f if f is strict.
17:19:56 <bakert> up cursor, enter ... that runs my program in the terminal ... if i alt-tab to the right window!
17:20:05 <allbery_b> heh
17:20:34 <sorear> rm -r * deletes a program that I didn't actually have a use for ... in the right window!
17:20:53 <glguy> what does it do in the wrong window??
17:21:02 <monochrom> foldr f if f is non-strict, foldl' f if f is strict.
17:21:04 <glguy> (sends messages to irc? ;) )
17:21:07 <monochrom> (It does that.)
17:21:07 <nmessenger> EATS YOUR SOUL!
17:21:08 <sorear> My mouse-focus horror story is bumping my mouse and running that in /home/stefan.
17:21:09 <bakert> writes rm -r * to #haskell if you're lucky ;)
17:21:51 <sorear> Fortunately I had a lot of large files in a c dir, so I got to the reset switch by g.
17:21:57 <monochrom> up-arrow + return = repeat the last line
17:22:24 <glguy> monochrom: I don't think anyone was serious about not knowing...
17:22:41 <bakert> i have a type: data Card Suit Rank -- how can i pattern match that in a function definition?
17:22:48 * monochrom hides
17:22:58 <sorear> (Card _ King) -- match all kinds
17:23:01 <sorear> (Card _ King) -- match all kings
17:23:05 <monochrom> f (Card s r) = ...
17:23:12 <sorear> f card =
17:23:19 <thelsdj> check $ foldl1 lcm (filter even [1..100])
17:23:20 <thelsdj> Just 388
17:23:42 <bakert> oh.  drat.  that's what i thought.  i have some other problem then!
17:23:44 <bakert> thanks
17:23:57 <thelsdj> oh wait thats even
17:23:59 <thelsdj> ha
17:26:46 <thelsdj> hmm what i find interesting is how the number of steps stays the same for a while at certain points
17:26:48 <lisppaste2> metaperl pasted "the named field "runLA" is serving as a data constructor? how?" at http://paste.lisp.org/display/34004
17:27:12 <thelsdj> i wonder what the longest repeated sequence is
17:30:41 <sorear> 3, if (iff?) the Conjecture is correct.
17:31:52 <sorear> iff
17:32:35 <allbery_b> metaperl: I have no idea but I note that the documentation for the State monad refers to runState as a data constructor
17:32:50 <nmessenger> metaperl, I'm not familiar with the libraries at hand, but runLA looks to be a field *selector*.  Given an 'LA a b' and an 'a', produces a '[b]'
17:33:18 <monochrom> runLA, runState are not constructors.  Perhaps they are even destructors.
17:33:42 <metaperl> please look at http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Control-Arrow-ListArrow.html#v%3ArunLA and decide
17:33:45 <lambdabot> http://tinyurl.com/y7w9jg
17:33:50 <nmessenger> (isA isTwo) is what produces your 'Num a => LA a a'
17:34:13 <metaperl> ok, let me see
17:34:22 <monochrom> For a data type declaration newtype X = X { runX :: whatever },
17:34:35 <monochrom> it is a shorthand of these two lines of code:
17:34:41 <monochrom> newtype X = X whatever
17:34:42 <metaperl> I agree with that... ok so runLA basically takes that arrow, plus a datum to produce [b]
17:34:49 <monochrom> runX (X whatever) = whatever
17:35:19 <metaperl> ok thanks
17:35:32 <nmessenger> (except you also get special syntax for pattern matching and update)
17:35:35 <monochrom> So X (the second X in the newtype line) is the data constructor, and runX is the data destructor.
17:35:55 <monochrom> See the Haskell 98 report for details.
17:35:56 <metaperl> destructor? accessor I think
17:35:58 <metaperl> oh
17:36:17 <metaperl> runX on_an_x => datum_in_x
17:36:33 <nmessenger> I suppose the Haddock format does make it look like 'runLA' is a constructor.
17:36:51 <monochrom> If an accessor is an inverse of the constructor, it is a destructor too.
17:36:55 <metaperl> but ghci and nmessenger led me to the daylight :)
17:37:03 <monochrom> Yeah I don't like that formatting.
17:37:05 <allbery_b> "destructor" has a different meaning in haskell-speak; it's not like a C++ / Java destructor, more like an accessor with certain properties.  or at least it seems to be used that way
17:37:13 <glguy> monochrom isn't suggesting that runState isn't technically an accessor, just that when the data type only serves to wrap another type
17:37:26 <glguy> that the lone accessor does the opposite as construction
17:37:42 <allbery_b> nmessenger: yeh, tat threw me with State to.  I went back and looked again and realized it was a field accessor, and it made more sense
17:38:30 <bakert> thanks for all your help today folks i'm off to bed.  ta.
17:39:06 <monochrom> Haskell 98 Report ftw
17:39:15 * nmessenger thinks the Haddock styling and formatting are not ideal.
17:41:40 <metaperl> maybe, but Haddock is damned useful tool :)
17:42:16 * nmessenger does not disagree :D
17:48:51 <lisppaste2> metaperl pasted "syntax error in first line - the module stmt -- please help" at http://paste.lisp.org/display/34006
17:49:26 <heatsink> module names have to be in title case.
17:49:36 <metaperl> oh thanks heatsink ... ltns
17:49:47 <heatsink> ltns?
17:49:49 <heatsink> leetness?
17:49:55 <metaperl> long time no see
17:49:56 <metaperl> :)
17:49:59 <heatsink> ah :)
17:50:07 <metaperl> were you in #scheme also?
17:50:30 <heatsink> I was, a few years ago
17:50:51 <heatsink> I usually go to #haskell and #python nowadays
17:53:03 <shapr> Mr Nolan!
17:53:24 <shapr> Your first name is neat.
17:54:43 <nornagon> so, who wants to show me a happily neat and clean and cool scheme parser.
18:06:16 <nmessenger> Heh, I just noticed on the Haskell wikipedia page: "The direct predecessor of Haskell was Miranda, devised in 1985."  Haskell and I are the same age! :D
18:07:21 <psnl> ndm: ping?
18:07:30 <jcreigh> gah, I hate it when people start talking about their age in here. People who've been answering my questions turn out to be 11. :)
18:07:53 <glguy> I feel old here and I'm 22 q-:
18:08:04 <nostrademons> I feel older and I'm 25 :-)
18:08:12 <glguy> oh man... you *are* old
18:08:13 <glguy> ;)
18:08:20 <nostrademons> yeah.  even have a real job
18:08:20 <nmessenger> Geezer!
18:08:30 <psnl> nmessenger: when is your birthday?
18:08:37 <nmessenger> 5/19/85
18:09:23 <nmessenger> yours?
18:09:28 * psnl is the 28th of september, and I'm 21 too
18:09:57 <reppie> i'm 23 D:
18:10:39 <sorear> 16
18:10:42 <heatsink> whoah
18:10:50 <nmessenger> Cool.
18:11:15 <reppie> i used to be the youngest in most irc channels i was in, like 10 years ago
18:11:21 <reppie> but now i'm liek teh oldest D:
18:11:33 * allbery_b feels old
18:11:57 <glguy> I've have started learning Haskell younger if I'd have known about it sooner
18:12:08 <allbery_b> (42 :)
18:12:17 * nornagon <- 17
18:12:21 <nornagon> but sorear is scary :P
18:12:26 <mbishop> <- 21
18:12:32 <glguy> ?vixen a/s/l
18:12:33 <lambdabot> 19/f/California
18:12:35 <nmessenger> allbery_b is the answer to the question of life, the universe, and everything
18:12:36 <gvdm_other> 18
18:12:37 <dylan> http://midgetbutton.com/~spoony/freedog.jpg
18:12:40 <heatsink> <- return 23
18:12:42 <shapr> I'm 35
18:12:45 <allbery_b> as if!
18:12:53 <mbishop> shapr: one day closer to death
18:12:57 * mbishop laughs at shapr
18:13:10 <shapr> It's okay, my girlfriend is younger than you are.
18:13:18 <mbishop> hot :P
18:13:20 <nmessenger> who LB?
18:13:26 <gvdm_other> laughing at people because they are gray and wrinkly is mean
18:13:27 <nmessenger> :-P
18:13:53 <shapr> mbishop: I am 225 pounds of unicycling muscle, and most people think I look 25, so I'm not worried about aging.
18:14:04 <gvdm_other> like shapr, just because he's getting to his FOURTH decade doesn't mean you should point and laugh
18:14:25 <nmessenger> I like how you emphasized FOURTH there.
18:14:47 <mbishop> heh
18:15:07 <heatsink> Hey, remember that these people who have been around a long time have a lot to teach us.
18:15:07 * shapr grins
18:15:09 <gvdm_other> well, thats almost like twice my age, I mean gee, evolution acts in shorter time periods
18:15:18 <gvdm_other> (jokes)
18:15:25 <mbishop> I'm 120 pounds of skin and bones
18:15:27 <shapr> gvdm_other: You better evolve fast ;-)
18:15:33 <mbishop> and I still look like I'm a teenager :P
18:15:35 <gvdm_other> in case people miss the obvious in a text only medium
18:16:46 <nmessenger> when was LB written?
18:16:50 <gvdm_other> I have had bad cases of people missing humour, especially sarcasm, other IRC
18:16:54 <gvdm_other> over*
18:16:58 <shapr> What's LB?
18:17:03 <shapr> oh, lambdabot ?
18:17:06 * allbery_b presumes lambdabo
18:17:08 <allbery_b> t
18:17:10 <shapr> Hm, 2001 or so?
18:17:29 <nmessenger> so shouldn't @vixen a/s/l start with 5/ ?
18:17:45 <shapr> It's a Vixenlove plugin.
18:17:53 <shapr> But you have a point...
18:17:57 <shapr> man, talk about underage...
18:18:02 <allbery_b> what makes you think anyone tells the truth in a/s/l responses? :)
18:18:04 <jcreigh> well, if we're going for accuracy, what would s/l be? :)
18:18:15 <shapr> female, down under
18:18:17 <nmessenger> bot/#haskell
18:18:20 <shapr> heh
18:18:28 <shapr> nmessenger: good answer!
18:19:09 <nmessenger> or even, bot/all over freenode
18:20:01 <mbishop> Wait, so you mean lambdabot is only 5? what should
18:20:02 <SamB> the age reported is the psychological age
18:20:02 <allbery_b> IM IN UR CHANNELZ TYPING UR LAMBDAZ
18:20:08 <mbishop> I do with these naked pictures?
18:20:33 <shapr> allbery_b: bwahaa
18:20:34 <SamB> mbishop: of you, or of lambdabot?
18:20:43 <shapr> allbery_b: I want to see the pic of that :-)
18:20:43 <mbishop> SamB: Both!
18:20:48 <nmessenger> mbishop: that's nothing, I've seen her *source code*.  Now *that's* hot.
18:21:05 <jcreigh> @remember allbery_b IM IN UR CHANNELZ TYPING UR LAMBDAZ
18:21:09 <SamB> mbishop: not together?
18:21:19 * SamB wanted them if they were just lambdabot
18:21:49 <Saizan> is lambdabot the only female here?:D
18:21:55 <shapr> Nah, there are several.
18:22:00 <deadbeef> omg, where ?
18:22:10 <shapr> If you react like that, you think I'll tell you?
18:22:17 <heatsink> OMG a GIRL? HERE???
18:22:18 <psnl> shapr, for example
18:22:22 * shapr sighs
18:22:26 <SamB> psnl: shapr is not a girl
18:22:27 <nostrademons> there are no girls on the Internet
18:22:36 <shapr> SamB: On the other hand, psnl has met me, and you haven't!
18:22:46 <SamB> shapr: I have seen the pictures!
18:22:51 <shapr> bah, ok
18:22:59 <nmessenger> Oh that reminds me jcreigh...
18:23:14 <nmessenger> @quote shapr pejo: Still looks like testicles to me.
18:23:15 <lambdabot> No quotes match. Where did you learn to type?
18:23:20 <nmessenger> @remember shapr pejo: Still looks like testicles to me.
18:23:25 <shapr> :-P
18:23:26 * dylan knows more females online than males, or equal at least.
18:23:29 <shapr> @quote shapr
18:23:30 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
18:23:30 <lambdabot>  what you just said?"
18:23:36 <shapr> @quote shapr
18:23:36 <lambdabot> shapr says: The legal system is the ultimate denial of service attack.
18:23:45 <shapr> @quote nmessenger
18:23:46 <lambdabot> No quotes match. Take a stress pill and think things over.
18:23:47 <shapr> aww
18:24:00 <nmessenger> but I did have one!
18:24:01 <dylan> @quote dylan
18:24:01 <lambdabot> dylan says: I'm an IT department.
18:24:05 <glguy> ?quote doesntexist -- more sudo quotes?
18:24:06 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
18:24:20 <nmessenger> ?where logs
18:24:21 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
18:24:52 <glguy> Hmm (dons was talking about putting sudo quotes somewhere)
18:24:52 <psnl> @quote psnl
18:24:53 <lambdabot> psnl says: ndm: you should have stayed around for the part where Conor denied he was Conor.
18:25:09 <psnl> damn, doesn't lose the quotes on restart
18:25:19 <sorear> hehehe
18:25:31 <sorear> State/quote - automatic serialization!
18:25:50 <glguy> ?quote
18:25:51 <lambdabot> scodil says: you say sledgehammer like its a bad thing
18:26:05 <dylan> ?quote dons
18:26:06 <lambdabot> dons says: the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
18:26:55 <Saizan> we should implement a programmer in the type system
18:27:13 <nmessenger> shapr: search http://ircbrowse.com/channel/haskell/20061228 for 'ADMIRE'
18:27:15 <lambdabot> Title: Meme haskell IRC Log 2006/12/28
18:27:28 <deadbeef> hey guys, what's your opinion about the P=NP problem ?
18:27:35 <dons> sorear: you ever going to send me some patches? :)
18:27:46 * dons gets itchy about thousands of lines of uncommitted code
18:28:00 <sorear> No, only 990 this time :(
18:28:07 <dons> that's fine!
18:28:08 <reppie> @quote reppie
18:28:09 <lambdabot> No quotes match. Do you think like you type?
18:28:12 * sorear sends the patches
18:28:18 <dons> are they ready to go?
18:28:20 <reppie> @quote reffie
18:28:20 <lambdabot> No quotes match. Are you on drugs?
18:28:23 <reppie> @quote rep
18:28:24 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
18:28:24 <lambdabot> for your entire program.")
18:28:29 <reppie> hm
18:29:10 * Igloo wonders what these lines of code do
18:29:21 <nostrademons> somebody needs to implement a hyper-monad fluxbox list...
18:29:43 <nostrademons> no idea what it would be, but it'd be cool to answer someone's question with that and have it actually work
18:30:03 <Igloo> hyper-monad fluxbox lists are so 2006
18:30:14 <psnl> I can't believe I have been hacking on hat for 4 months and only now looked up what an S Expression is
18:30:27 <Igloo> uber-monad fluxbox finite maps are what all the cool kids are using
18:30:41 <nostrademons> oh, of course.  I'm so far behind the times
18:30:41 <sorear> does darcs send -s mean *you* generate the summary, or *darcs* does?  All --help says is 'summarize changes'.
18:31:04 <shapr> sorear: Probably that darcs only shows you a summary.
18:31:05 <jcreigh> In soviet Russia, darcs commit you
18:31:32 <Igloo> sorear: If you want to add a message then you need --edis-description
18:31:58 <Igloo> s/edis/edit/
18:32:51 <nmessenger> dons: how do @rememberings get saved?  Are they reviewed?  Did you lose any with the recent changes to LB?
18:33:45 <glguy> they go straight into the file
18:33:56 <dons> they shouldn't be lost, unless the bot actually crashes
18:33:57 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
18:34:05 <sorear> and dons fixed *that*
18:34:08 <sorear> @flush
18:34:21 <monochrom> fluxbox?
18:34:24 <sorear> @bot
18:34:24 <lambdabot> :)
18:34:31 <dons> sorear: so these 22 patches? they're ready to go?
18:35:18 <sorear> no, wait, sorry, forgot to add the part that prevents an incompatible change to the data store
18:35:27 <dons> oh, sounds good
18:35:39 * nmessenger was @quoted by somebody, but it's not there any longer
18:36:06 * sorear searches the logs
18:36:32 <nmessenger> look for 'ADMIRE' in http://ircbrowse.com/channel/haskell/20061228
18:36:34 <lambdabot> Title: Meme haskell IRC Log 2006/12/28
18:36:44 <sorear> grep 'remember.*nmessenger' /var/cache/stefan-downloads/irclogs/irclog.dated <-- turns up nil
18:36:54 <dons> i'm just pushing some of today's hacks, you might want to check for merge issues
18:37:17 <glguy> ?src fromJust
18:37:18 <lambdabot> fromJust Nothing  = undefined
18:37:18 <lambdabot> fromJust (Just x) = x
18:37:32 <sjanssen> *more* lambdabot patches?
18:37:37 * glguy is advertising this new command
18:37:38 <heatsink> shouldn't it be error "Prelude.fromJust"?
18:37:39 <jcreigh> oh, hey, @src in the flesh.
18:37:54 <jcreigh> dons++ I think @src it going to be handy.
18:37:59 <glguy> > fromJust Nothing
18:38:00 <lambdabot>  Add a type signature
18:38:01 <dons> yeah, I think so too
18:38:04 <glguy> > fromJust Nothing :: ()
18:38:06 <lambdabot>  Exception: Maybe.fromJust: Nothing
18:38:09 <dons> considering how often I manually look up src for people
18:38:19 * sjanssen notes that if sorear's patches are pushed, that will make something like 60 patches since Dec 26
18:38:25 <dons> good!
18:38:38 <dons> maybe now's the time to finally add the bytestring-only path through lambdabot
18:38:54 <sorear> bytestring-only path?
18:38:56 <glguy> what about 6.6 support ?
18:39:17 <dons> yeah, I want a way to write a plugin that does all communication via bytestrings only
18:39:33 <dons> so mesages read as bytestrings, used as keys into bytestrings maps, and written back to the network still packed
18:39:43 <dons> so not going via the String-based IRc types
18:39:53 <dons> the String plugins can then be written as 'pack's
18:40:09 <dons> then I can transition more and more handling to bytestrings only
18:40:22 * psnl wonders if error used to write to stdout, or something
18:40:43 * monochrom is evil
18:40:55 <dons> sorear: so I hold off on these patches till you send me another bundle?
18:41:03 <monochrom> ?src writeIORef
18:41:03 <lambdabot> writeIORef (IORef var) v = stToIO (writeSTRef var v)
18:41:23 <psnl> errorT s = unsafePerformIO (do hPutStrLn stderr s; return (error "")) <- this has me confused
18:41:25 <monochrom> ?src writeSTRef
18:41:26 <lambdabot> Source for this function is not available.
18:41:31 <kpreid> dons: why bytestrings in lamdabot?
18:41:33 <monochrom> Busted!
18:41:51 <nmessenger> ?src stToIO
18:41:51 <lambdabot> Source for this function is not available.
18:41:54 * monochrom has another idea
18:41:56 <dons> kpreid: it has some large state (think @src for example)
18:42:09 <dons> having to unpack these strings to write them to the network is slowre and more infficient than it needs to be
18:42:13 <kpreid> ah
18:42:56 <SamB>  @src is *state*?
18:43:04 <sorear> dons: ok, that last 3 line patch will keep State/ compatibility
18:43:47 <allbery_b> I presume it's doing a lookup in a data store of some kind, that is state
18:44:07 <dons> sorear: I wonder if it would be fun to hook dcoutt's gzip/bzip2 bytestring lib into lambdabot
18:44:20 <dons> so we can bzip state strings, lazily unpacking Map elems as they're needed
18:44:35 <allbery_b> (alternately it's constant strings in the binary, but that doesn't scale)
18:44:37 <dons> SamB: read-only
18:44:57 <sorear> allbery_b: he tried that once.  See "vixenstate"
18:45:06 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Source.hs
18:45:17 * allbery_b saw some discussion the of that other day
18:45:26 <allbery_b> *the other day
18:45:40 <allbery_b> wow, I mangled that pretty well :/
18:46:22 <shoffsta> GHC tells me: "My Brain just exploded."
18:46:26 * shoffsta chuckles
18:46:28 <SamB> @quote GHC
18:46:28 <lambdabot> shapr says: I don't know why the GHC team won't accept my spoonIO patch
18:46:32 <SamB> @quote ghc
18:46:32 <lambdabot> ghc says: Cannot unify a type variable with a type scheme
18:46:42 <dons> sorear: so this patch set of 23 is the one to use?
18:46:49 <nmessenger> (\[x,y,z] -> [z,x,y]) (words "of that the")
18:47:04 <nmessenger> > unwords $ (\[x,y,z] -> [z,x,y]) (words "of that the")
18:47:05 <lambdabot>  "the of that"
18:47:12 <SamB> @quote ghc
18:47:12 <lambdabot> ghc says: Malformed predicate
18:47:22 <allbery_b> @pl \[x,y,z] -> [z,x,y]
18:47:22 <lambdabot> (line 1, column 2):
18:47:23 <lambdabot> unexpected "["
18:47:23 <lambdabot> expecting pattern
18:47:29 <allbery_b> bah
18:47:31 <SamB> @quote ghc
18:47:32 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
18:47:38 <SamB> hah!
18:47:52 <sorear> yes, and I see at semantic if not darcs conflicts with fprocess_.
18:47:57 <Saizan> so basically all the specifics envs of each plugin are routed around in some monad and each plugin readMS its own?
18:48:00 <monochrom> Many evil things are not listed in ?src :)
18:48:11 <dons> sorear: " at semantic if not darcs conflicts " ?
18:48:24 <dons> monochrom: they have to be < 3 lines
18:48:27 <SamB> sorear: are you sure you didn't have conflicts in that sentance?
18:48:30 <dons> and I have to have been bothered finding them :)
18:48:33 <monochrom> Oh hah
18:48:52 <SamB> @src foldr
18:48:52 <lambdabot> foldr k z xs = go xs
18:48:52 <lambdabot>     where go []     = z
18:48:52 <lambdabot>           go (y:ys) = y `k` go ys
18:48:54 <dons> SamB: yeah
18:48:57 <dons> Saizan: yeah
18:49:07 <sorear> ok, I'll do it then... (find/fix conflicts)
18:49:20 <SamB> @src unsafePerformIO
18:49:20 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
18:49:25 <SamB> heh
18:49:38 <sjanssen> obvious defn.
18:49:46 <SamB> o rly?
18:49:51 <SamB> it doesn't work in hugs does it?
18:49:54 <sjanssen> :)
18:49:54 <dons> I wonder how I could use HsColour to dynamically colour each line in this channel...
18:50:05 <monochrom> This is poor^H^H^H^H excellent, we can examine unsafePerformIO but not scanl :)
18:50:15 <dons> ?src scanl
18:50:15 <lambdabot> Source for this function is not available.
18:50:20 <SamB> ?src scanr
18:50:21 <lambdabot> scanr _ q0 []     =  [q0]
18:50:21 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
18:50:21 <lambdabot>     where qs@(q:_) = scanr f q0 xs
18:50:24 <dons> I think it had a leading space or something. i'll fix that
18:50:31 <allbery_b> hm.  script over the h98 report's prelude to pull out definitions, reject all over a certain length
18:50:43 <psnl> dons: whats your irc clien? or is this for logs?
18:50:46 <nmessenger> ?src sort
18:50:46 <lambdabot> sort = sortBy compare
18:50:58 <nmessenger> ?src sortBy
18:50:58 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:51:15 <SamB> allbery_b: and another script to force some cheap PhDs to grind some more down to 3 lines?
18:51:38 <nmessenger> ?src insertBy
18:51:39 <lambdabot> insertBy _   x [] = [x]
18:51:39 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
18:51:39 <lambdabot>                                  GT -> y : insertBy cmp x ys'
18:51:39 <lambdabot>                                  _  -> x : ys
18:51:51 <nmessenger> slightly more spam :)
18:52:12 <nmessenger> But only 4 lines.  Can anyone do better?
18:52:43 <nmessenger> I wonder...
18:52:43 <sorear> ?src hSetBuffering
18:52:43 <lambdabot> Source for this function is not available.
18:52:44 <dons> psnl: i'm using irssi. I'd like to colour the terminal output dynamically
18:52:48 <nmessenger> ?let x = 1
18:52:48 <allbery_b> using braces instead of layout takes that to 2 :)
18:52:49 <lambdabot> Defined.
18:52:50 <nmessenger> ?src x
18:52:51 <lambdabot> Source for this function is not available.
18:53:02 <sorear> ?src L.x
18:53:03 <lambdabot> Source for this function is not available.
18:53:04 <allbery_b> dons: run in screen, you can define a filter it runs on output
18:53:07 <SamB> dons: why not colour lambdabot's output instead?
18:53:08 <sorear> :type x
18:53:15 <sorear> ?type x
18:53:16 <lambdabot> Not in scope: `x'
18:53:18 <nmessenger> \o/
18:53:27 <dons> allbery_b: ah, good. I do use screen already!
18:53:29 <sorear> aw, misread the commit message :(
18:53:39 <dons> SamB: since that will annoy most others
18:53:51 <dons> > x
18:53:52 <lambdabot>  1
18:54:00 <nmessenger> ?undefine
18:54:01 <lambdabot> Undefined.
18:55:26 <olliej> > let x = \y->x y in length (map x [1..10])
18:55:27 <lambdabot>  10
18:55:41 <SamB> :t x
18:55:42 <lambdabot> Not in scope: `x'
18:55:50 <SamB> :i x
18:56:09 <ryanburn> I'm in the process of trying to build "happy" and it doesn't look like it's updated for the most recent version of ghc. One of the files, for example, references the function Data.Array.MArray.indices which doesn't exist. Does anyone know what happened to this function?
18:56:38 <sorear> happy wouldn't build for me either
18:56:49 <SamB> mmm.
18:56:50 <dons> you need the tarball/snapshot/darcs version
18:56:53 <sorear> so I just use the binary package of the prerelease
18:57:23 <olliej> > let x = \y->if (y<4) then x y else x (y `div` 2 ) in (map x [1..10])
18:57:24 <lambdabot>  Add a type signature
18:57:44 <olliej> > let x = (\y->if (y<4) then x y else x (y `div` 2 )) in (map x [1..10])
18:57:45 <lambdabot>  Add a type signature
18:57:56 <olliej> > let x::Int->Int = (\y->if (y<4) then x y else x (y `div` 2 )) in (map x [1..10])
18:57:57 <lambdabot>  Parse error
18:58:02 <nmessenger> Ooh, I was reading http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase and wondered if them same could be done of 'if'
18:58:04 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
18:58:07 <olliej> > let (x::Int->Int) = (\y->if (y<4) then x y else x (y `div` 2 )) in (map x [1..10])
18:58:07 <lambdabot>  Parse error in pattern
18:58:11 <olliej> meh
18:58:31 <nmessenger> (if then a else b) = (\x -> if x then a else b)
18:58:39 <ryanburn> dons: do you know where I get the snapshot version?
18:58:52 <sorear> apt-get install happy?
18:58:55 <allbery_b> right, there it is.  "exec" screen command, with appropriate pattern.  exec !.. HsColour ...
18:59:11 <ryanburn> sorear: I'm using OS 10, though.
18:59:24 <sorear> oh
19:00:05 <Cale> I think one thing which might be worth serious consideration for a GHC extension if not haskell' is allowing for guards in do-blocks detected by type.
19:00:53 <Cale> (that is, boolean expressions in do blocks would automatically have guard applied)
19:01:07 <heatsink> @type guard
19:01:09 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:01:22 <Igloo> That would need some magic in the type inferer
19:01:23 <Cale> @src guard
19:01:23 <lambdabot> guard True  =  return ()
19:01:24 <lambdabot> guard False =  mzero
19:01:34 <nmessenger> neato!
19:02:06 <Igloo> And what should happen for (Foo a => a) where Foo (IO a) and Foo Bool both have instances?
19:02:08 <sorear> Cale: so, you want the typechecker fused with the desugarer?  (/me is still stuck in the pass mentality)
19:02:55 <Cale> Maybe it's a little too magical. You should be able to distinguish things of type Bool from monadic things by the structure of the type alone though.
19:03:20 <Cale> Igloo: well, yeah, that would be ambiguous
19:03:32 <Cale> I'd say it would generate an error.
19:03:44 <Cale> (but it's pretty unlikely that it will ever occur)
19:03:48 <kpreid> Cale: I think that's too magical
19:03:59 <sorear> Cale: haskell is not perl :)
19:04:32 <sorear> (I suppose the answer to that is 'and you think that's a good thing'...)
19:05:02 <jcreigh> it *is* a good thing...
19:05:15 <Cale> It is a good thing that Haskell's not perl, certainly :)
19:05:19 <monochrom> arrow's proc notation already knows when to use Arrow when to use ArrowApp etc.
19:05:27 <Cale> Yeah
19:05:36 <sorear> that's not type sensitive though
19:05:49 <glguy> It doesn't seem to obsurd when you consider it's what list comps do automatically
19:05:50 <allbery_b> although given Pugs you could claim that in some sense Perl is (in) Haskell...
19:06:14 <glguy> Cale: If you just had Monad comprehensions, you shouldn't need to change do notation ;)
19:06:17 <Cale> I also really really think that the translation for do-notation should translate <patt> <- <expr> differently based on whether <patt> is a refutable pattern.
19:06:20 <glguy> wouldn't
19:06:23 <Cale> glguy: that's true
19:06:42 <monochrom> Ah, I have to think about it.
19:06:47 <Cale> and in particular, it should use mzero when the pattern is refutable
19:07:03 <sorear> agreed.
19:07:14 <glguy> instead of fail?
19:07:17 <Cale> yes
19:07:20 <Cale> fail should die
19:07:31 <heatsink> I dunno, I'd prefer that it fail just like an irrefutable let-pattern.
19:07:35 <heatsink> *refutable
19:07:38 <sorear> fail must die
19:08:04 <heatsink> well, let would call 'error'.  error for refutable monad assignment would be okay too.
19:08:14 <Cale> heatsink: irrefutable patterns can be translated as lambda bindings
19:08:49 <glguy> I like that catMaybes xs = [x | (Just x) <- xs]
19:08:55 <Cale> do {p <- x; <stmts>} ==> x >>= \p -> do {<stmts>}
19:09:07 <glguy> ?src catMaybes
19:09:08 <lambdabot> catMaybes ls = [x | Just x <- ls]
19:09:40 <monochrom> Alright, sorear is right about see-Bool-insert-guard.  Probably problematic.
19:09:50 <heatsink> Cale: don't refutable patterns translate the same way?
19:10:05 <nmessenger> heatsink, no, there's a little magic
19:10:38 <nmessenger> heatsink, if the pattern is refuted, fail is called
19:10:45 <Cale> heatsink: presently
19:10:46 <heatsink> do {(Just x) <- return Nothing; return x}
19:10:50 <heatsink> > do {(Just x) <- return Nothing; return x}
19:10:51 <lambdabot>   add an instance declaration for (Show (m a))
19:11:01 <Cale> neither of them translate the way I just said
19:11:11 <nmessenger> ?undo do {Just x <- return Nothing; return x}
19:11:12 <lambdabot> return Nothing >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
19:11:24 <dons> sorear: btw, for big changes, ong comments explaining how the new system works are a good idea
19:11:29 <dons> s/long/
19:11:44 <monochrom> Yah, like that. Cale is is saying s/fail ""/mzero
19:11:44 <dons> so you said something about versioning of state?
19:11:52 <sorear> no
19:12:22 <Cale> The current translation looks like do { p <- x; <stmts>} ==> let ok p = do {<stmts>}; ok _ = fail "..." in x >>= ok
19:12:32 <Cale> but I think that sucks
19:12:46 <sorear> actually, I suppose you could think of it that way
19:13:00 <nmessenger> Wouldn't that force a MonadZero instance on all do-notations?
19:13:10 <sorear> old style saved nicks -> do NOT contain ':' ; new ones do
19:13:11 <Cale> Because it introduces this spurious fail into the Monad class which can't be properly implemented in most monads except to just die.
19:13:25 <dons> sorear: ah ok
19:13:29 <Cale> nmessenger: That's why refutable and irrefutable patterns should be treated differently.
19:13:38 <dons> sorear: so I have to reset the @seen state?
19:13:38 <Cale> The translation I'm proposing is this:
19:13:49 <dons> or you tag the state to pick between them?
19:14:01 <heatsink> Cale: why not make refutable do-patterns work like refutable let-patterns?
19:14:06 <Cale> If p is irrefutable: do {p <- x; <stmts>} ==> x >>= \p -> do {<stmts>}
19:14:11 <sorear> seen is the tricky one, it'll probably forget everything
19:14:19 <dons> that's ok
19:14:36 <sorear> tell, todo, karma, etc - should remember
19:14:43 <Cale> If p is refutable: do {p <- x; <stmts>} ==> let ok p = do {<stmts>}; ok _ = mzero in x >>= ok
19:15:05 <Cale> That way, usage of refutable patterns in do-notation generates a MonadZero constraint.
19:15:18 <nmessenger> For some reason I was thinking irrefutable patterns were just ~ patterns.  I forgot plain variable bindings.
19:15:22 <Cale> (I'd also split MonadZero and MonadPlus back the way they were before)
19:15:32 <Cale> nmessenger: right
19:15:58 <sorear> this block of changes, hopefully does most of the plugin-touching... ie the rest of the changes will touch the core, Base, Seen, and Log.
19:16:07 <allbery_b> we'll get monad comprehensions back in little by little? :)
19:16:21 <nmessenger> Binding on (Just x) I'd expect to be able to fail, so using a MonadZero does make sense.
19:16:34 <Cale> Right
19:16:44 <Cale> You want your monad to be able to handle that failure.
19:17:07 <Cale> If they *really* want the program to die, let them use case.
19:17:17 <Cale> (and error)
19:17:32 <Cale> Or other similarly dangerous constructions, like fromJust
19:18:07 * nmessenger is kinda nervous around partial functions
19:18:17 <dons> sorear: so this "fn" is the freenode tag?
19:18:23 <dons> where is "fn" == freenode defined?
19:18:45 <heatsink> I think refutable patterns are too easy to overlook.  I'm worried it'll produce unexpected behavior.
19:18:52 <dons> (I'd prefer something like data Server = Freenode | Slashnet | ...
19:18:54 <heatsink> What comes to mind is a mysteriously truncated list.
19:19:07 <dons> sorear: would that be sensible? FN | SN | .. ?
19:19:30 <monochrom> You forgot that fail for [] is mzero already.
19:19:32 <dons> and the server list can be defined in Config.hs
19:19:51 <heatsink> It does that already?
19:20:07 <nmessenger> > fail "Blah!" :: [Int]
19:20:08 <lambdabot>  []
19:20:16 <monochrom> Like that
19:20:25 <sorear> I imagined you specify the tag (an opaque string) at connect time.. ?irc-connect fn chat.freenode.net sorear-lambdabot from a couple days ago... bad idea?
19:20:30 <heatsink> huh.
19:20:51 <monochrom> By and large, Cale's idea is backward compatible!
19:20:54 <nmessenger> do {Just x <- Nothing; return x} :: [Int]
19:21:01 <nmessenger> > do {Just x <- Nothing; return x} :: [Int]
19:21:03 <lambdabot>  Couldn't match `[]' against `Maybe'
19:21:10 <heatsink> @src mzero
19:21:10 <lambdabot> Source for this function is not available.
19:21:15 <dons> sorear: so have you changed how the bot connects now?
19:21:15 <sorear> the tag is shortish because it is used in the user interface: fn:sorear refers to me, no matter what server you say it from.
19:21:20 <monochrom> Maybe Int, nmessenger
19:21:21 <sorear> not yet
19:21:23 <dons> or does ./lambdabot --online still work?
19:21:32 <monochrom> Err, ha, nevermind
19:21:35 <dons> (I need more docs for what is going on!)
19:21:38 <sorear> offline/online hasn't been touched yet
19:21:57 <nmessenger> monochrom, yeah, I'm not so experienced at mixing Monads together yet  :|
19:21:58 <sorear> oh, docs...  oooh...
19:22:03 <dons> ok
19:22:07 <monochrom> nmessenger: do { Just x < [Nothing]; return x } :: [Int]
19:22:21 <monochrom> and also s/</<-/
19:22:26 <nmessenger> > do { Just x <- [Nothing]; return x } :: [Int]
19:22:29 <lambdabot>  []
19:22:47 <heatsink> Cale: Okay, I guess that works!
19:23:11 <Cale> In fact, not only is my change backwards compatible, it's what Haskell 1.4 used to do!
19:23:33 <heatsink> Can I quote you as saying "let them eat case!"?
19:23:41 <Cale> heatsink: I was thinking that :)
19:23:42 <monochrom> haha
19:23:46 * nmessenger likes that
19:23:50 <heatsink> @remember Cale Let them eat case!
19:23:51 <dons> ?version
19:23:56 * allbery_b had that thought as well
19:24:04 <sorear> the only user visible changes of so-far is that fn: is ignored at the beginning of nicks
19:24:09 <dons> ok
19:24:17 <nostrademons> there was a big long discussion when Haskell 98 was standardized about MonadZero....
19:24:18 <nostrademons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg03267.html
19:24:20 <sorear> ?seen fn:dons
19:24:21 <lambdabot> lambdabot 4p388, GHC 6.5 (OpenBSD i386)
19:24:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:24:43 <lambdabot> Title: MonadZero
19:24:45 <lambdabot> fn:dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard fn:dons speak 11s ago.
19:24:46 <dons> does it default to using the current server if you leave off the fn: ?
19:24:49 <dons> if not, it should
19:24:51 <nmessenger> Cale did not actually *say* that, though.  Or did he earlier?
19:24:53 <sorear> yes
19:24:58 <sorear> ?seen dons
19:25:01 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 8s ago.
19:25:11 <monochrom> He said "let them use case".
19:25:20 <sorear> all that is centralized in Message.readNick
19:25:23 <dons> ok. looks good
19:25:29 <monochrom> But clearly that was a typo :D
19:25:29 <Cale> I didn't actually say it, but I did think it, and several other people were caused to think it by what I wrote :)
19:25:34 <sorear> ?seen efn:dons
19:25:35 <lambdabot> I haven't seen efn:dons.
19:25:37 <nostrademons> eh, Marie Antoinette didn't really say that either.  it's the nature of history to be misquoted
19:25:56 <monochrom> Marie Antoinette had a typo too. :)
19:26:14 <sorear> <Cale> If they *really* want the program to die, let them use case.
19:28:17 <glguy> Cale: The design patterns article on reddit isn't getting any comments.. I think that the words might be too big...
19:28:48 <glguy> (I'm kidding, there are plenty of articles without comments)
19:28:50 <nostrademons> maybe people are just sick of design patterns articles?
19:31:40 <SamB> nostrademons: that would be nice
19:31:59 <glguy> nostrademons: are there a lot of anti-design-pattern articles on reddit?
19:32:51 <nostrademons> uh, yeah: http://reddit.com/search?q=design+patterns&s=highscore
19:32:53 <lambdabot> Title: search: design patterns (reddit.com)
19:33:38 <nostrademons> also, the same people who read Reddit usually read Paul Graham, which means they read Peter Norvig, and he did a whole catalog of each design pattern and why it's irrelevant to dynamic languages
19:34:11 <nostrademons> http://www.norvig.com/design-patterns/ppframe.htm
19:34:12 <lambdabot> Title: Design Patterns in Dynamic Programming
19:34:24 * psnl has YA haskell epiphany
19:36:05 <Cale> psnl: which epiphany?
19:36:33 <mbishop> YA? Yet another? what is with people and their forced acronyms?
19:36:40 <psnl> which? there are standard haskell epiphanies?
19:36:49 <Cale> probably :)
19:37:43 <nmessenger> I'd buy it.  Now *which*?!
19:37:45 * monochrom names his writings not as Yet Another ___, but as The Canonical ___.
19:38:31 <nostrademons> YAHT at least it pronounceable, TCHT is pushing it....
19:38:53 <nostrademons> say it out loud and I'd think you were trying to sneeze while muttering obscenities
19:39:17 <nmessenger> *tchshit!*
19:39:43 <nmessenger> excuse me
19:39:51 <sorear> *tee* *cee* *eich* *tee*
19:40:40 <psnl> nmessenger: oh, the thought that reading in data then sending it down lots of channels isn't going to use lots of memory
19:43:58 <psnl> nmessenger: it sounds completely daft now
19:44:25 <nmessenger> how so?
19:44:51 <psnl> well, more a "duh"
19:46:36 <nmessenger> Hindsight 20/20 and all that?  What do you mean by 'sending it down lots of channels'?  getContentsing then passing the results all over the place?
19:48:43 <psnl> yeah, getContents then lots ofwriteChan
19:49:17 <nmessenger> ?type writeChan
19:49:19 <lambdabot> Not in scope: `writeChan'
19:49:43 <psnl> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html#v%3AwriteChan
19:49:45 <lambdabot> http://tinyurl.com/y6u2cy
19:49:53 <sorear> @tell dons quick braindump: http://members.cox.net/stefanor/MASTER_PLAN.multiserver
19:49:54 <lambdabot> Consider it noted.
20:09:09 <wy> Is there a way to do sequencing? for example print out something and return another value at last.
20:09:50 <nmessenger> (>>) or do-notation?
20:10:30 <nmessenger> print "something" >> return anotherValue
20:11:23 <sjanssen> @redo print "something" >> return anotherValue
20:11:24 <lambdabot> do { print "something"; return anotherValue}
20:12:15 <sjanssen> wy: these are monadic constructs, of course.  You'll need to use the IO monad to print something
20:14:56 <wy> sjanssen: It's a bit strange. Because as if I need strip one level of constructor for the thing I'm going to return?
20:15:18 <nmessenger> ?paste please
20:15:18 <lambdabot> http://paste.lisp.org/new/haskell
20:17:46 <sjanssen> wy: I don't quite follow you, can you elaborate?
20:18:05 <wy> sjanssen: I can't get the value out if I put it into the do block
20:18:24 <nmessenger> ah, you're looking for a (IO a -> a) ?
20:18:51 <wy> No. I just want to print out some information during execution
20:18:58 <nmessenger> to test pure code, you might use trace
20:19:01 <nmessenger> ?index trace
20:19:01 <lambdabot> Debug.Trace
20:19:08 <nmessenger> ?type Debug.Trace.trace
20:19:10 <lambdabot> forall a. String -> a -> a
20:19:19 <sjanssen> wy: you can't print things inside pure code
20:19:36 <wy> Oh. Is trace the easiest way to do that?
20:19:42 <sjanssen> pure code can't have any side effects
20:19:53 <nmessenger> > trace "blargh!" True
20:19:54 <lambdabot>   Not in scope: `trace'
20:19:59 <wy> I got an infinite loop and I'm trying to see what's going on
20:20:04 <sjanssen> wy: yes, it is the most direct.  It is only okay to use for debugging purposes, however
20:20:04 <nmessenger> > Debug.Trace.trace "blargh!" True
20:20:05 <lambdabot>   Not in scope: `Debug.Trace.trace'
20:20:22 <nmessenger> LB doesn't like IO
20:21:01 <augustss> trace can be indispensible for debugging
20:22:14 <wy> Where do I put trace "myfunc" ?
20:23:13 <nmessenger> trace ("a debugging message" ++ withMoreInformation) whenThisExpressionIsEvaluated
20:23:15 <dons> trace "foo" $ rest of code
20:23:15 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:24:27 <quazimodo> oo
20:24:33 <nmessenger> fp
20:25:04 <quazimodo> why did he quit?
20:25:15 <quazimodo> i was just figuring out how to send a msg to dons :/
20:25:16 <nmessenger> SHE was probably killed by dons
20:25:19 <sjanssen> s/he/she
20:25:26 <quazimodo> oo
20:25:44 <sorear> @bot
20:25:49 <quazimodo> its dead
20:25:53 <nmessenger> LB is out for the moment
20:25:53 <sorear> oooh
20:26:00 <quazimodo> dons killed it
20:26:02 <sieni> it's so nerdy to regard bots as females
20:26:06 <nmessenger> maybe
20:26:14 <nmessenger> totally!
20:26:14 <sorear> should I feel culpable?
20:26:18 <sieni> well, I prefer real females, I don't know about you guys
20:26:19 <quazimodo> probably
20:26:22 <dons> just merging in a tricky patch
20:26:25 <dons> (gzip compressed state files)
20:26:30 <nmessenger> sorear, did you @tell dons something?
20:26:34 <sorear> yes
20:26:40 <sorear> in channel
20:26:46 <nmessenger> then yes you should
20:27:00 <seliopou> dons, hello
20:27:05 <seliopou> I sent you the yi patch today
20:27:06 <sorear> did the message crash the bot?
20:27:08 <seliopou> are you accepting it?
20:27:25 <dons> sorear: nope
20:27:27 <nmessenger> no, I'm just kidding
20:27:30 <dons> seliopou: should be ok thanks!
20:28:11 <sorear> I just ran @seen and got a lambdabot: no such nick/channel, hence the coming in worried
20:28:11 <seliopou> It was my first time using darcs, so I didn't know if the send worked :P
20:30:34 <dons> yep, it worked :)
20:30:48 <dons> "darcs patch: Yi.Debug module added with file logging capabilities"
20:31:05 <seliopou> That's the one
20:31:32 <sorear> seliopou: how hard was it to get vty-yi displaying text?
20:31:36 <seliopou> As I noted in the description, it's a bit simple and hackish even, but it gets the job done
20:31:53 <seliopou> sorear: I haven't gotten that to work yet
20:32:02 <seliopou> it was part of the reason why I wrote the Debug module
20:32:30 <sorear> I can't see the GUI on my system because JPB set the default color scheme to black on black :(
20:32:46 <seliopou> I think that's the same problem that I have
20:32:55 <sieni> I wonder if there would be a need for a "native" haskell GUI toolkit that uses Cocoa, Windows APIs and e.g. Gtk+ directly
20:33:12 <sorear> Yi.Vty, halfway down, the = Color (0) line sets it
20:33:29 <seliopou> for default or black?
20:33:33 <sorear> it's a trivial fix, but I don't want to create a doppelganger patch
20:33:44 <sorear> the -- for now line
20:33:54 --- mode: ChanServ set +b *!*@69.106.58.193
20:34:16 <seliopou> good to know, thanks a lot
20:34:19 <sorear> what does 'zptao' stand for?
20:34:35 <dons> that's zptao, who's banned from here (check the logs for zptao and topaz)
20:35:03 <sorear> oh.  I thought it was one of those IRC abbreviations :)
20:35:08 <dons> nope :)
20:36:48 <dons> now I just need to add bytestring-based Binary
20:36:57 <dons> (to support gzip on the big binary state files)
20:37:07 <dons> ?src foldr
20:37:33 <lambdabot> foldr k z xs = go xs
20:37:41 <sorear> file*s* - there's more than Seen?
20:38:06 <dons> ?bot
20:38:06 * sorear was rather suprised after catting state files when he reached seen
20:38:06 <lambdabot> :)
20:38:11 <dons> ?src foldl
20:38:12 <lambdabot> foldl f z xs = lgo z xs
20:38:16 <dons> hmm :}
20:39:01 <sorear> BEEEXZEEZAXXXXP! no such command: <enq response>
20:39:35 <dons> ?quit bleeding edge
20:40:24 <thermoplyae> Anyone awake that's an op in #math?
20:40:36 <dons> Cale, around?
20:40:46 <sorear> dons: any thoughts on my plan?  (this is basically what I did the first time, just more confusedly and all at once)
20:41:00 <dons> yeah, it seems reasonable
20:41:16 * dons tries to work out why @src is now truncating 
20:41:17 <dons> but not in offline mode
20:41:48 <thermoplyae> Oh well
20:41:53 <thermoplyae> Eventually someone will wake up and kick him
20:41:56 <sorear> dons: I tawt I saw an ios80?
20:42:04 <jcreigh> when I first noticed @src was online, I did a "/msg lambdabot @src foldr", and it gave the full definition then...
20:42:17 <dons> jcreigh: yeah, it just broke in this last update
20:42:18 <sorear> that truncates in channel, right
20:42:24 <dons> sorear: you think maybe it was your ios80 patch?
20:42:52 <sorear> no
20:42:52 <dons> > flip fmap everything
20:42:53 <lambdabot>   Not in scope: `everything'
20:43:00 <dons> > fix scanl
20:43:01 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
20:43:02 <lambdabot>       Expected...
20:43:10 <dons> ok. so other things still work with >1 lines
20:43:52 <sorear> @pl \a b c d e f g h i j -> f a a b a g
20:43:53 <lambdabot> ((const . const . const . (((const . const . const) .) .)) .) . (flip =<< (flip .) . flip . (flip =<< flip id))
20:44:06 <sorear> @pl \a b c d e f g h i j -> f a a b a g a a b c d e f i j e c d
20:44:13 <dons> @src doesn't use ios80 anyway
20:44:21 <lambdabot> ((((((const .) .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .
20:44:22 <lambdabot> ) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip flip id . (
20:44:22 <lambdabot> flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) .
20:44:22 <lambdabot> (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (((flip .) .) .) . (flip .) . ((flip .) .) . flip ap id . (flip .) . ((
20:44:24 <lambdabot> flip .) .) . join (flip . (flip .) . ((flip .) .) . join (flip . (flip .) . ((flip .) .) . ap (flip . (flip .) . flip . ap (flip . flip id) id) id))
20:44:27 <lambdabot> optimization suspended, use @pl-resume to continue.
20:44:29 <lambdabot> Source for this function is not available.
20:45:03 <sorear> dons: does fprocess split lines?
20:45:20 <sorear> i.e. maybe the rest of the lines are being treated as IRC commands
20:45:30 <dons> yeah
20:45:47 <dons> ah, I think I see it
20:45:58 <quazimodo> interestingly annoying
20:46:11 <quazimodo> those parentheses are giving me a headache
20:46:45 <dons> ?quit gotcha
20:47:05 <dons> ?bot
20:47:32 <lambdabot> :)
20:47:34 <sorear> dons: do you know why lambdabot sometimes fails to use a quit message?
20:48:01 <sorear> (I thought I broke it back in take 1 ... I now see it was already)
20:48:02 <dons> I think its a race between the server closing, and the timeout
20:48:10 <dons> ?src foldr
20:48:11 <lambdabot> foldr k z xs = go xs
20:48:11 <lambdabot>     where go []     = z
20:48:11 <lambdabot>           go (y:ys) = y `k` go ys
20:48:51 <quazimodo> wow
20:48:54 <quazimodo> simple function :/
20:49:01 <dons> yup
20:49:22 <nmessenger> much of the Prelude is similarly lucid
20:49:22 <quazimodo> i am not much of a prgrammer anyway, but it seems to me that a similar functionw ould be alot longer to write in c or c++ :/
20:49:46 <dons> they're not languages with first class functions though, so they lose in brevity :)
20:49:55 <dons> e.g. y `k` go ys
20:49:59 <quazimodo> yeh
20:50:11 <quazimodo> i was surprised that worked, and somewhat pleased
20:50:35 <augustss> ?src foldl
20:50:35 <lambdabot> foldl f z xs = lgo z xs
20:50:36 <lambdabot>     where lgo z []     =  z
20:50:36 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
20:50:42 <nmessenger> ?src foldl'
20:50:42 <lambdabot> foldl' f a []     = a
20:50:43 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:51:03 <augustss> ?src filter
20:51:04 <lambdabot> filter _ []     = []
20:51:04 <lambdabot> filter p (x:xs)
20:51:04 <lambdabot>     | p x       = x : filter p xs
20:51:04 <lambdabot>     | otherwise = filter p xs
20:51:41 <quazimodo> ?power_of_quazimodo
20:51:42 <lambdabot> Unknown command, try @list
20:51:50 <quazimodo> i was hoping that function would exist
20:51:56 <augustss> ?src foldr1
20:51:57 <quazimodo> and would cause mysterious things to happen
20:51:57 <lambdabot> foldr1 _ [x]    = x
20:51:57 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
20:51:57 <lambdabot> foldr1 _ []     = undefined
20:51:59 <nmessenger> > (^quazimodo)
20:52:01 <lambdabot>   Not in scope: `quazimodo'
20:52:05 <dons> quazimodo: what type does it have?
20:52:11 <quazimodo> Hero
20:52:14 <quazimodo> -> Hero
20:52:18 <quazimodo> :D
20:52:25 <dons> ?djinn Hero -> Hero
20:52:26 <lambdabot> f a = a
20:52:29 <nmessenger> id :: Hero -> Hero
20:52:32 <dons> there you go
20:52:44 <monochrom> A sign of high-level languages is that you write little code to manipulate interesting data structures.
20:52:49 <quazimodo> now i need a secret identity
20:53:00 * nmessenger calls CAPTAIN LAMBDA
20:53:24 * quazimodo mysteriously cant be found, where is he?
20:53:28 <lambdabot> Lambda Man is here to save the day, with abstractions that won't get in your way!
20:53:32 * monochrom is hungry, wants to eat some of you.
20:53:49 <quazimodo> lol
20:53:52 <nmessenger> lambdabot: you say the craziest things.
20:53:53 <quazimodo> who the hell put that into the bot
20:54:06 <quazimodo> did you guys sit around and imagine this stuff, or is dons telling it now?
20:54:14 <monochrom> lambdabot is not the bot.  I am the bot.
20:54:21 <mbishop> Captain lambda
20:54:22 <monochrom> I AM YOUR FATHER!
20:54:33 <mbishop> doesn't seem to be a trigger :P
20:54:37 <monochrom> RESISTENCE IS FUTILE
20:54:42 <quazimodo> imagine that, the haskell programmers have time to sit around and put quotes into the bot that are used at most once a year
20:54:48 <quazimodo> :P
20:54:51 <quazimodo> funny guys
20:55:15 <quazimodo> can i ask ghci to print the source of a function?
20:55:15 <monochrom> Oh we thought the quotes would be used more often.
20:55:19 <jcreigh> dons: where is the source taken from? The Haskell report? GHC sources? Some combination thereof?
20:55:24 <monochrom> No, unfortunately.
20:55:27 <dons> jcreigh: the ghc srcs
20:55:39 <jcreigh> @src sequence
20:55:40 <lambdabot> sequence ms = foldr k (return []) ms
20:55:40 <lambdabot>     where
20:55:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
20:55:41 <dons> monochrom: well, with goa+lambdabot ...
20:55:52 <dons> suddenly ghci becomes interesting ;)
20:56:29 <nmessenger> it wasn't interesting before?
20:56:43 <monochrom> Interesting.  Eclipse's java plugin shows source from library too.
20:57:16 * nmessenger wonders...
20:57:27 <nmessenger> ?google Haskell Eclipse plugin
20:57:28 <lambdabot> http://eclipsefp.sourceforge.net/
20:57:29 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
20:57:30 <quazimodo> i think you guys ought to have put something into lambdabot regarding ursula mayes and how very pretty she is
20:57:33 <monochrom> ghci --- i stands for interesting :D
20:57:53 <monochrom> lambdabot is prettier.
20:58:22 <quazimodo> *super freak, super freak shes super freaky...*
20:59:04 <mbishop> ?vixen
20:59:05 <lambdabot> I don't think you are the one you say you are!
20:59:21 <quazimodo> ?stallman
20:59:22 <lambdabot> Unknown command, try @list
20:59:32 <mbishop> ?protontorpedo
20:59:32 <quazimodo> aww man stallman could have so many funny things
20:59:32 <lambdabot> hu me/
20:59:44 <nmessenger> quazimodo, try '/msg lambdabot @' followed by nothing
20:59:49 <monochrom> http://trappist.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html  has some lambdabot's pretty pictures :)
20:59:52 <lambdabot> Title: #haskell-blah: Everything but Haskell - Lambdabot contest, http://tinyurl.com/y949tc
21:00:06 <thelsdj> ?help djinn
21:00:12 <lambdabot> djinn <type>.
21:00:12 <quazimodo> eeeee
21:00:14 <lambdabot> Generates Haskell code from a type.
21:00:15 <quazimodo> lots
21:00:16 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:00:30 <quazimodo> what is the difference between the ? and the @ commands?
21:00:49 <nmessenger> none, mostly
21:00:54 <thelsdj> ? is cooler
21:00:59 * nmessenger agrees
21:01:27 <quazimodo> :/
21:01:29 <thelsdj> though : would be the coolest
21:01:40 * quazimodo is overdosing on eclipse mints
21:01:48 <nmessenger> though /me wants ':' for all the commands, so that he doesn't have to context-switch between #haskell and ghci
21:02:10 <thelsdj> oooh
21:03:05 <thelsdj> is it possible to access lambdabut commands from ghci? that would be nice too
21:03:12 <nmessenger> ?where goa
21:03:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
21:03:23 <nmessenger> ^^ there
21:03:42 <thelsdj> nice!
21:03:48 <thelsdj> ?where god
21:03:48 <lambdabot> I know nothing about god.
21:03:57 <quazimodo> heh
21:03:59 <quazimodo> funny
21:04:04 <quazimodo> catholics hate computers
21:04:10 <nmessenger> http://www.cse.unsw.edu.au/~dons/lambdabot.html has more information
21:04:11 <lambdabot> Title: lambdabot
21:04:13 <bd_> Is that like meta-atheism? Denying not just the existence of god, but the very concept?
21:04:34 <thelsdj> ?where stop making me choke on tortilla chips
21:04:34 <lambdabot> I know nothing about stop.
21:04:36 <ryanburn> Did Cabal for the most part replace the "fptools build system"?
21:04:36 <thelsdj> er
21:04:46 <nmessenger> I know nothing about Categories.  I do not assert their non-existance.
21:04:50 <thelsdj> there wasn't supposed to be a ?where there, forgot i had typed it and left it sitting there
21:05:17 <nmessenger> ?where anything
21:05:17 <lambdabot> I know nothing about anything.
21:05:38 <nmessenger> a humble bot, she is.
21:05:53 <monochrom> She can get a master degree.
21:06:16 <allbery_b> ?where everything
21:06:16 <lambdabot> I know nothing about everything.
21:06:25 <allbery_b> has a Ph.D?
21:06:36 <nmessenger> ?docs Ph.D
21:06:36 <lambdabot> Ph.D not available
21:06:49 <nmessenger> apparently not :(
21:07:53 * thelsdj hums "There's so much drama in the Ph.D"
21:08:24 <jcreigh> hmm, I have [Int], and I want to to take the sum of the list, but the result doesn't fit in Integer. Is there any way to sum a list of [Int] into an Integer?
21:08:42 <jcreigh> *"doesn't fit in Int"
21:08:59 <nmessenger> sum . map (fromIntegral :: Int -> Integer) ?
21:09:04 <dons> genericSum ?
21:09:49 <monochrom> I concur with nmessenger
21:09:56 <thelsdj> ?src genericSum
21:09:57 <lambdabot> Source for this function is not available.
21:10:05 <nmessenger> ?type genericSumm
21:10:07 <nmessenger> ?type genericSum
21:10:08 <lambdabot> Not in scope: `genericSumm'
21:10:09 <lambdabot> Not in scope: `genericSum'
21:10:15 <augustss> or 'sum . map toInteger'
21:10:19 <nmessenger> ?type Data.List.genericSum
21:10:21 <lambdabot> Not in scope: `Data.List.genericSum'
21:10:37 <dons> (there's no generic Sum :)
21:10:42 <monochrom> genericSum would not save you anyway.
21:10:43 <dons> ?src toInteger
21:10:44 <lambdabot> Source for this function is not available.
21:10:55 <jcreigh> nmessenger++ Thanks, that works
21:10:57 <jcreigh> @type toInteger
21:10:59 <lambdabot> forall a. (Integral a) => a -> Integer
21:11:02 <nmessenger> yay karma!
21:11:09 <thelsdj> ?karma
21:11:10 <lambdabot> You have a karma of 0
21:11:17 <thelsdj> ?karma lambdabot
21:11:17 <lambdabot> lambdabot has a karma of 39
21:11:31 <johnnowak> ?karma
21:11:32 <lambdabot> You have a karma of 0
21:11:35 <johnnowak> arr..
21:11:40 <thelsdj> ?karma nmessenger
21:11:40 <lambdabot> nmessenger has a karma of 1
21:11:59 <thelsdj> ?karma ghc
21:11:59 <lambdabot> ghc has a karma of 2
21:12:04 <thelsdj> ?karma hugs
21:12:04 <lambdabot> hugs has a karma of 3
21:12:16 <nmessenger> but just the other day my ?karma was 4.
21:12:55 <jcreigh> management not resposible for karma failure. :)
21:13:09 * nmessenger pouts
21:13:26 <thelsdj> mnessenger++
21:13:39 <jcreigh> s/mn/nm/
21:13:39 <olliej> thebug: now you're just rewarding pouting
21:13:46 <thelsdj> jcreigh: sssh
21:13:47 * mlh pouts
21:13:47 <olliej> gah
21:13:52 <jcreigh> heh
21:13:53 <nmessenger> mnessenger--
21:13:55 <olliej> thelsdj
21:14:10 <monochrom> karma leak haha
21:14:22 <thelsdj> free mnessenger
21:15:22 <nmessenger> ?karma somebodyThatDoesntExistYet
21:15:23 <lambdabot> somebodyThatDoesntExistYet has a karma of 0
21:16:11 <glguy> maybe you tried to modify java's karma?
21:16:32 <mauke> @bawt
21:16:33 <lambdabot> Maybe you meant: fact part
21:17:12 <nmessenger> ?. elite . elite . elite maybe you tried to modify java's karma
21:17:13 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "maybe"
21:17:20 <nmessenger> ?. elite . elite elite maybe you tried to modify java's karma
21:17:20 <lambdabot> /\/\4Y83 J00 +ri3D +0 M0DiFY Jav4'Z0Rs KAR/\/\4
21:20:18 <thelsdj> ?help .
21:20:18 <lambdabot> . <cmd1> <cmd2> [args].
21:20:18 <lambdabot> . [or compose] is the composition of two plugins
21:20:18 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
21:20:26 * nmessenger has an evil idea
21:20:42 <evil_nmess> nmessenger++
21:20:55 <nmessenger> ?karma
21:20:55 <lambdabot> You have a karma of 2
21:21:00 <nmessenger> Yay!
21:22:22 <thelsdj> ?. pl . unpl (.) . (.)
21:22:23 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "(.)"
21:22:42 <nmessenger> too many plugin compositions
21:22:59 <nmessenger> ?. pl unpl (.) . (.)
21:23:00 <lambdabot> (.) . (.)
21:25:03 <thelsdj> ?. djinn type map (+)
21:25:05 <lambdabot> Cannot parse command
21:25:23 <nmessenger> ?type map (+)
21:25:25 <lambdabot> forall a. (Num a) => [a] -> [a -> a]
21:25:29 <nmessenger> hmm
21:25:46 <thelsdj> ?djinn forall a. (Num a) => [a] -> [a -> a]
21:25:46 <lambdabot> Cannot parse command
21:25:52 <thelsdj> ?djinn (Num a) => [a] -> [a -> a]
21:25:53 <lambdabot> Cannot parse command
21:25:57 <nmessenger> ?dj
21:25:58 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver . bf ft id pl v wn
21:26:28 <nmessenger> ?djinn Num a => [a] -> [a -> a]
21:26:29 <lambdabot> Cannot parse command
21:26:31 <thelsdj> ?djinn [a] -> [a -> a]
21:26:31 <lambdabot> -- f cannot be realized.
21:26:47 <thelsdj> ?djinn [a] -> a
21:26:47 <lambdabot> -- f cannot be realized.
21:26:50 <nmessenger> djinn doesn't like constraints now?
21:27:07 <thelsdj> ?djinn Num a => [a] -> a
21:27:07 <lambdabot> Cannot parse command
21:27:16 <thelsdj> ?djinn a -> a
21:27:16 <lambdabot> f a = a
21:27:28 <augustss> no constraints, no recursive types
21:27:44 <nmessenger> s/ now//
21:27:49 <thelsdj> ?djinn a -> [a]
21:27:50 <lambdabot> -- f cannot be realized.
21:28:39 <nornagon> ?pl \a
21:28:40 <nornagon> er
21:28:41 <nornagon> ?pl \a
21:28:43 <nornagon> gr!
21:28:44 <lambdabot> (line 1, column 3):
21:28:47 <lambdabot> unexpected end of input
21:28:49 <lambdabot> expecting letter or digit, operator, pattern or "->"
21:28:49 <nornagon> ?pl \a -> a
21:28:54 <lambdabot> (line 1, column 3):
21:28:57 <lambdabot> unexpected end of input
21:28:58 <lambdabot> expecting letter or digit, operator, pattern or "->"
21:29:02 <lambdabot> id
21:29:04 <nornagon> @botsnack
21:29:12 <lambdabot> :)
21:29:45 <augustss> @src id
21:29:45 <lambdabot> id x = x
21:30:17 <nmessenger> ?src nub
21:30:17 <lambdabot> nub = nubBy (==)
21:30:22 <nmessenger> ?src nubBy
21:30:23 <lambdabot> nubBy eq []             =  []
21:30:23 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:31:00 <nmessenger> sexy
21:31:22 <augustss> @src not
21:31:23 <lambdabot> not True   =  False
21:31:23 <lambdabot> not False  =  True
21:32:46 <nmessenger> ghci doesn't like 'let .: = (.) . (.) in concat .: map', "parse error on input `.:'"
21:32:59 <glguy> (.:) maybe
21:33:03 <augustss> yes
21:33:08 <dons> > let (.:) = (.) . (.) in concat .: map
21:33:10 <lambdabot>  Add a type signature
21:33:11 * nmessenger slaps forehead
21:33:38 <thebug> olliej: yo
21:42:48 <dons> ?users
21:42:49 <lambdabot> Maximum users seen in #haskell: 266, currently: 264 (99.2%), active: 18 (6.8%)
21:42:56 <dons> oh boo
21:44:54 <emu> moo?
21:45:01 <nmessenger>  mu!
21:54:06 <sjanssen> that's an old users statistic, isn't it
21:56:45 <bos31337> @hoogle glob
21:56:46 <lambdabot> Language.Haskell.TH.global :: Name -> ExpQ
21:56:46 <lambdabot> System.Win32.Mem.globalAlloc :: GlobalAllocFlags -> DWORD -> IO HGLOBAL
21:56:46 <lambdabot> System.Win32.Mem.globalFlags :: HGLOBAL -> IO GlobalAllocFlags
21:56:57 <bos31337> @hoogle fnmatch
21:56:58 <lambdabot> No matches found
21:57:02 <bos31337> @hoogle readdir
21:57:03 <lambdabot> No matches found
21:57:11 <bos31337> wowie zowie.
21:57:20 <mauke> it's there, somewhere
21:57:37 <bos> yeah, the trick is finding it if you don't know what it's called :-)
21:58:07 <mauke> @hoogle FilePath -> IO [FilePath]
21:58:08 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
21:58:08 <dons> sjanssen: yeah, i reverted the wrong darcs state
21:58:09 <bos> just say no to gratuitous renamings of posix interfaces, kids!
21:58:18 <mauke> bos++
21:58:22 <bos> mauke: yay!
21:58:47 <bos> wow, that's a positively java-length name :-(
21:58:58 <mauke> bos: it's obviously somewhere in System.* so you can search it manually
21:59:03 <mauke> still, the name kind of sucks
21:59:26 <dons> ?index getDirectoryContents
21:59:27 <lambdabot> System.Directory, Distribution.Compat.Directory
21:59:37 <bos> "obviously" depends on your level of experience with the current state of the language, unfortunately.
21:59:51 <nmessenger> ?docs System.Directory
21:59:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html
21:59:53 <bos> actually, this isn't so much with the state of the language as the prelude and libraries.
21:59:59 <emu> > fix obviously
22:00:00 <lambdabot>   Not in scope: `obviously'
22:00:09 <bos> heh.
22:00:23 <mauke> bos: ok, rewriting OCaml's Unix library in Haskell helps :-)
22:00:25 <emu> > fix ("obviously":)
22:00:27 <lambdabot>  ["obviously","obviously","obviously","obviously","obviously","obviously","ob...
22:01:49 <bos> is there a corresponding library for haskell?
22:01:53 <emu> anyone tried Vital?
22:02:18 <mauke> bos: no, and the one I've written is mostly useless
22:02:42 <bos> wonderful. then i can write one, and finally get my teeth into something useful ;-)
22:02:54 <mauke> it bypasses the standard IO library, thus breaking threading
22:03:23 <bos> i don't quite understand.
22:03:32 <sachu> Hi. I am trying to do the second exercise (write a function that takes a Tuple and returns a Haskell type) in YAHT (http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Multiple_Constructors). The solution given online at (http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics/Solutions#Multiple_Constructors) does not seem to match what the problem asks for:  fromTuple(One 5) returns Left...
22:03:34 <sachu> ...(Left 5), while the problem seems to ask for a plain 5.
22:03:35 <lambdabot> http://tinyurl.com/y8w64d
22:03:35 <sachu> Is it possible to write a function that returns plain Haskell values, pairs, etc? Or is Left (Left 5) the same as 5 ?
22:03:56 <sorear> Left (Left 5) is not 5
22:04:02 <mauke> threading in ghc seems to depend on file ops being non-blocking
22:04:21 <bos> mauke: presumably this isn't an issue if you're not running something concurrent?
22:04:36 <mauke> well, ok
22:04:40 <AStorm> Hey. Is there some nice Haskell text encoding conversion library?
22:04:44 <bos> or is the threadedness cooked in somewhere?
22:04:49 <bos> AStorm: iconv?
22:04:57 <mauke> normal stuff seems to work fine
22:05:01 <bos> ok.
22:05:01 <AStorm> bos, non-Unix possibly? :P
22:05:15 <AStorm> I mean portable.
22:05:18 <mauke> (where normal stuff = "hello world" -- the rest is pretty much untested)
22:05:24 <mauke> it compiles, though :-)
22:05:48 <bos> AStorm: the iconv library exists for windows.
22:05:52 <sorear> AStorm: it should exist, but it doesnt
22:06:04 <sorear> AStorm: nobody is writing a library
22:06:11 <AStorm> bos, yeah, and I'll have to install it everywhere. Nifty
22:06:23 <AStorm> Also, is there a wrapper?
22:06:31 <AStorm> Or do I have to code it?
22:06:32 <sorear> AStorm: everybody is copying UTF8.lhs or similar from some other codebase
22:06:44 <AStorm> sorear, so google, hmm...
22:07:08 <AStorm> JHC?
22:07:22 <sorear> JHC notelem libraries.
22:07:29 <sorear> JHC is a haskell compiler
22:07:34 <AStorm> I know.
22:07:41 <sorear> JHC is a prime example of code copying.
22:07:56 <sorear> JHC is a place you can steal encoding modules from.
22:08:06 <AStorm> Well, maybe I'll do some nicer lib with multiple pluggable encodings... or not :>
22:08:23 <sachu> sorear: I tried writing a function that converts Left/Right types to values, pairs, etc, but it doesn't compile. Is it possible to write such a function?
22:08:51 <AStorm> sachu, you mean like fromLeft and fromRight? Yep.
22:08:53 <sorear> Left/Right types? there is only Either
22:08:54 <jcreigh> sachu: what do you mean, "values, pairs, etc"? Could you give an example of what you want this function to do?
22:09:24 <sachu> how do I do lisppaste?
22:09:26 <mauke> bos: http://83.189.31.242/tmp/Onyx.tar.bz2 if you're interested
22:09:30 <nmessenger> ?type \x -> case x of {Left _ -> "left!"; Right _ -> "right!"}
22:09:31 <AStorm> @paste
22:09:31 <mauke> ?paste
22:09:32 <lambdabot> forall a b. Either a b -> [Char]
22:09:32 <lambdabot> http://paste.lisp.org/new/haskell
22:09:32 <lambdabot> http://paste.lisp.org/new/haskell
22:09:47 <glguy> lisppaste2: url
22:09:47 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
22:09:49 <AStorm> nmessenger, -)
22:09:51 <bos> mauke: thanks
22:10:00 <sachu> thanks
22:10:31 <nmessenger> AStorm, :
22:11:05 <nmessenger> :-)
22:11:28 <AStorm> Yeah, vim destroyed my keyboard
22:12:07 <sorear> dons: is it a concern that darcs doesn't do deltas for binary files ... like gzipped statefiles?
22:12:24 <dons> well, it is a little, since it makes darcs changes to find the quote a bit hard
22:12:36 <dons> but playing with zlib is too much fun to stop now!
22:13:58 <ClaudiusMaximus> :t outer
22:14:00 <lambdabot> Not in scope: `outer'
22:14:08 <nmessenger> ?index outer
22:14:09 <lambdabot> bzzt
22:14:17 <ClaudiusMaximus> :t outer2
22:14:19 <lambdabot> Not in scope: `outer2'
22:14:21 <ClaudiusMaximus> hmm
22:14:42 <mauke> @hoogle outer
22:14:42 <lambdabot> No matches found
22:15:10 <ClaudiusMaximus> @hoogle [a] -> [b] -> [(a,b)]
22:15:11 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
22:15:34 <nmessenger> > zip [1,2,3] "abc"
22:15:36 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
22:17:25 <bd_> bleh, wxhaskell is broken on amd64, and gtkhs is broken on ghc 6.6
22:17:39 <bd_> and here I was wanting to play with phooey
22:17:40 <ClaudiusMaximus> > let outer a b = [(x,y) | x <- a, y <-b] in outer [1,2,3] "abc"
22:17:42 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
22:17:54 <ClaudiusMaximus> :)
22:18:49 <lisppaste2> sachu pasted "Converting from Tuple to Haskell types" at http://paste.lisp.org/display/34029
22:18:53 <AStorm> Hmm, that UTF8 decoder should be transformed to IO one too :>
22:19:07 <mauke> > sequence ["123", "abc"]
22:19:08 <lambdabot>  ["1a","1b","1c","2a","2b","2c","3a","3b","3c"]
22:19:24 <AStorm> E.g. IO ByteString -> IO String
22:19:25 <nornagon> :t sequence
22:19:27 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
22:19:30 <AStorm> and IO String -> IO String
22:19:40 <bd_> so, are there any haskell UI librarys that actually work at the moment? XD
22:19:52 <AStorm> Because it can fail. Should throw an IOError
22:20:53 <dons> bd_, gtk2hs ad wxHaskell
22:21:02 <dons> in particular, gtk2hs
22:21:09 <bd_> dons: neither build :)
22:21:18 <bd_> gtk2hs needs to be updated for ghc 6.6
22:21:19 <AStorm> Newest gtk2hs should build.
22:21:23 <bd_> wxHaskell has some unsafe casts to int
22:21:26 <bd_> breaking on amd64
22:21:28 <bd_> oh?
22:21:32 <AStorm> wxHaskell is broken with 6.6
22:21:39 <dons> gtk2hs should be fine, there was a release on Dec 20 iirc
22:21:45 <dons> wxHaskell has recently got a new maintainer
22:21:46 <AStorm> (also those unsafe casts)
22:21:47 <bd_> the gtk2hs blog didn't mention it I guess
22:21:50 <dons> so should be active( ?)
22:22:16 <sachu> jcreigh: I have pasted my code at http://paste.lisp.org/display/34029
22:22:52 <bd_> http://haskell.org/gtk2hs/ doesn't mention a new release? Rather it mentions they're /working/ on one :/
22:22:53 <lambdabot> Title: Gtk2Hs
22:22:54 <jcreigh> sachu: short answer: "You can't do that."
22:23:03 <nmessenger> sachu, I think fromTuple satisfies the exercise requirements.  You can't write a single function that returns different types.  eitherToHaskell would have to be split into four functions.
22:23:39 <nmessenger> that was the long answer :)
22:23:43 <glguy> nmessenger: you can't write a single function the returns different types?
22:23:55 <TSC> bd_: They released a new build pre-release that's supposed to work on 6.6
22:23:58 <sachu> nmessenger, jcreigh: thanks. then I guess I read the exercise incorrectly
22:24:09 <bd_> TSC: ah
22:24:09 <nmessenger> glguy, a function can return (Either a b), but that's one type.
22:24:12 <glguy> ?type fromInteger
22:24:14 <lambdabot> forall a. (Num a) => Integer -> a
22:24:18 <glguy> what type does that return?
22:24:23 <AStorm> nmessenger, what about pattern matching?
22:24:39 <AStorm> Ah, return. Now that's something different.
22:25:02 <TSC> bd_: http://haskell.org/gtk2hs/archives/2006/12/24/new-gtk2hs-pre-release-in-time-for-xmas/
22:25:05 <lambdabot> Title: Gtk2Hs » Blog Archive » New Gtk2Hs pre-release in time for xmas, http://tinyurl.com/ykk7z2
22:25:05 <nmessenger> glguy, well, yeah, but what kinda meaningful class could you put a (,) (,,) and (,,,) under?
22:25:23 <mauke> glguy: the type you expect it to return
22:25:23 <bd_> TSC: ah, ok, I'll check it out
22:25:40 <AStorm> Well, call it Tuples
22:25:41 <AStorm> :P
22:25:50 <TSC> I hope it works, I've been waiting for a 6.6-compatible version too
22:26:07 <AStorm> It does. (compiled here and works)
22:26:31 <AStorm> That was latest darcs though. The release should build too anyway.
22:26:53 <glguy> nmessenger: (I didn't answer because someone else handled the question)
22:28:37 <nmessenger> :/
22:29:07 <glguy> i was just raising the point because you are telling someone who is learning Haskell that a fucntion can't have more than one return type
22:31:37 <nmessenger> cheers, I goofed :-)
22:31:51 <kilimanjaro> can a function have more than one return type?
22:31:58 <kilimanjaro> ohh
22:32:01 <nmessenger> SomeClass a => a
22:32:20 <kilimanjaro> that's just a single, higher order return type :)
22:33:11 <nmessenger> 'a' is a variable that can take on any type in the SomeClass class.  Higher order types have to do with type constructors.
22:33:38 <nmessenger> I *think*.
22:34:27 <nmessenger> Then there's error.
22:34:43 <kilimanjaro> i don't know the exact terminology, the higher-order part was just a guess
22:34:43 <glguy> ?type Data.Map.lookup undefined Data.Map.empty :: Maybe Int -- one return type
22:34:45 <lambdabot> Maybe Int :: Maybe Int
22:34:53 <nmessenger> Which doesn't *actually* return, so it can have any return type.
22:34:55 <glguy> ?type Data.Map.lookup undefined Data.Map.empty :: [Int] -- another return type
22:34:57 <lambdabot> [Int] :: [Int]
22:35:56 <kilimanjaro> I'm tempted to write a game in haskell
22:36:04 <ClaudiusMaximus> :t unzip
22:36:06 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
22:37:24 <nmessenger> ?check (\xs -> let f === g = f xs == g xs in unzip . uncurry zip === id)
22:37:25 <lambdabot>      precedence parsing error         cannot mix `(.)' [infixr 9] and `(===)'...
22:37:36 <nmessenger> ?check (\xs -> let f === g = f xs == g xs in (unzip . uncurry zip) === id)
22:37:37 <lambdabot>  Add a type signature
22:37:41 <nmessenger> bleh
22:39:58 <nmessenger> ?check (\xs -> let f === g = f xs == g xs in (unzip . uncurry zip) === id) :: ([Int],[Int]) -> Bool
22:40:00 <lambdabot>  Falsifiable, after 0 tests: ([],[2,-1])
22:41:47 <glguy> ?check (\xs -> (xs :: [[Int]]) == transpose (transpose xs)) -- I don't expect this to work either
22:41:49 <lambdabot>  Falsifiable, after 1 tests: [[],[],[]]
22:42:47 <bos> mauke: what do you think is wrong with onyx as it stands? the approach looks reasonable to me.
22:43:08 <bd_> ?where fusion
22:43:09 <lambdabot> I know nothing about fusion.
22:43:12 <mauke> bos: it doesn't integrate with existing libraries
22:43:16 <glguy> ?check (\xs -> concat (xs :: [[()]]) == concat $ transpose (transpose xs)) -- I don't expect this to work either
22:43:17 <lambdabot>      Expecting a function type, but found `a'       Expected type: [()],     ...
22:43:20 <bos> mauke: oh.
22:43:31 <bos> seems like a non-problem.
22:43:50 <mauke> well, threading support would be nice
22:44:23 <glguy> ?check (\xs -> (concat xs :: [()]) == concat (transpose (transpose xs)))
22:44:26 <lambdabot>  OK, passed 500 tests.
22:44:31 <bos> presumably Posix.IO handles that, even with its peculiar naming conventions?
22:44:55 <mauke> yeah
22:45:02 <glguy> ?check (\xs -> not . null . concat xs => (xs :: [[()]]) == transpose (transpose xs)) -- I don't expect this to work either
22:45:03 <lambdabot>  Parse error
22:45:08 <glguy> ?check (\xs -> not . null . concat xs ==> (xs :: [[()]]) == transpose (transpose xs)) -- I don't expect this to work either
22:45:09 <lambdabot>      Expecting a function type, but found `[a]'       Expected type: a1 -> [a...
22:45:10 <mauke> but there's no select/poll in the standard lib
22:45:22 <glguy> ?check (\xs -> (not . null . concat ) xs ==> (xs :: [[()]]) == transpose (transpose xs)) -- I don't expect this to work either
22:45:24 <lambdabot>  Falsifiable, after 0 tests: [[],[()]]
22:45:28 <bos> mauke: and there aren't non-blocking versions of much of the posix interface, anyway.
22:45:38 <glguy> oops, sorry, thought I was in /query
22:47:18 <ClaudiusMaximus> @hoogle (Eq a) => Int -> [a] -> [[a]]
22:47:19 <lambdabot> No matches, try a more general search
22:47:54 <ClaudiusMaximus> @hoogle (Eq a) => [a] -> Int -> [[a]]
22:47:55 <lambdabot> No matches, try a more general search
22:48:34 <ClaudiusMaximus> @hoogle a -> [b] -> [[b]]
22:48:35 <lambdabot> No matches, try a more general search
22:50:40 <nmessenger> ?type (!!) -- ClaudiusMaximus, this?
22:50:42 <lambdabot> forall a. [a] -> Int -> a
22:52:22 <ClaudiusMaximus> nmessenger: nope
22:52:43 <ClaudiusMaximus> ?help pl
22:52:44 <lambdabot> pointless <expr>. Play with pointfree code.
22:52:50 <seliopou> @hoogle Int -> a -> [a]
22:52:51 <lambdabot> Prelude.replicate :: Int -> a -> [a]
22:53:15 <xpika> how is Debug.debug.trace anydifferent from (\x y-> putStrLn x >> putStrLn (show y))?
22:53:42 <seliopou> @hoogle trace
22:53:43 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:53:44 <lambdabot> Debug.Trace :: module
22:53:44 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
22:53:58 <bos> mauke: Onyx is very nice.
22:54:34 <nmessenger> ClaudiusMaximus, like 'foo "example" 3 == ["exa","mpl","e"]' ?
22:54:39 <seliopou> xpika: what you wrote has type: Show a => String -> a -> IO ()
22:55:00 <seliopou> trace returns its second argument
22:55:08 <ClaudiusMaximus> nmessenger: more like:  bar 2 [1,2,3,4] = [ [1,2], [1,3], [1,4], [2,3], [2,4], [3,4] ]   and now that i've calculated that example i think i know how to do it :)
22:55:32 <xpika> ohh
22:55:34 <xpika> i get it
22:56:05 <bos> ClaudiusMaximus: are you working on the 99 problems?
22:56:19 <bos> @hoogle tails
22:56:20 <lambdabot> List.tails :: [a] -> [[a]]
22:56:20 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
22:56:36 <bos> > tails "foo"
22:56:37 <lambdabot>  ["foo","oo","o",""]
22:57:04 <bos> you can use tails to construct your combinations.
22:57:08 <ClaudiusMaximus> bos: what are they?
22:57:13 <seliopou> > tail . inits "foo"
22:57:14 <lambdabot>      Expecting a function type, but found `[[a]]'
22:57:14 <lambdabot>       Expected type: a1 -> ...
22:57:19 <seliopou> poop
22:58:06 <bos> tails xs@(_:ys) = xs : tails ys
22:58:21 <bos> combi k xs = [ t:ts | t:ns <- tails xs, ts <- combi (k-1) ns ]
22:58:39 <glguy> > let f 0 _ = [[]]; f n xs = [a : rest | (a:as) <- tails xs, rest <- f (n-1) as] in f 2 [1..4]
22:58:42 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
22:58:53 <glguy> looks like bos and I were on the same track
22:59:12 <Cale> seliopou: that'd work if (.) was general functor application rather than just function composition
22:59:29 <ClaudiusMaximus> bos: i'm (trying) to implement this algorithm:   http://www.flowerfire.com/ADSODA/   (i'm at "To find corners, ADSODA iterates through every possible n-tuple of faces")
22:59:31 <lambdabot> Title: ADSODA: Arbitrary-Dimensional Solid Object Display Algorithm
22:59:58 <dons> ?where rdtsc http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/
22:59:59 <lambdabot> I know nothing about rdtsc.
22:59:59 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in tail . inits "foo"
23:00:01 <lambdabot>  Exception: Prelude.tail: empty list
23:00:06 <dons> ?where+ rdtsc http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/
23:00:07 <lambdabot> Done.
23:00:08 <Cale> well, it'd almost work :)
23:00:15 <ClaudiusMaximus> thanks bos, glguy
23:00:15 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in tail . drop 1 . inits "foo"
23:00:17 <lambdabot>  Exception: Prelude.tail: empty list
23:00:20 <Cale> er
23:00:23 <glguy> init
23:00:24 <seliopou> You just need parens
23:00:27 <dons> rdtsc is a nice little example of binding a haskell library to a chunk of asm...
23:00:29 <Cale> > inits "foo"
23:00:32 <lambdabot>  ["","f","fo","foo"]
23:00:37 <seliopou> > (tail . inits) "foo"
23:00:39 <lambdabot>  ["f","fo","foo"]
23:00:47 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in tail . (drop 1 . inits "foo")
23:00:49 <lambdabot>  Exception: Prelude.tail: empty list
23:00:52 <glguy> lol
23:01:01 <Cale> curious :)
23:01:14 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in drop 1 . (drop 1 . inits "foo")
23:01:16 <lambdabot>  ["","","","o"]
23:01:21 <seliopou> o_O
23:01:42 <Cale> ah, of course, I'm silly
23:01:43 <glguy> Cale: oH!
23:01:47 <glguy> drop1 $ inits
23:01:48 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in drop 1 . (drop 1 . inits $ "foo")
23:01:50 <lambdabot>  ["","o","oo"]
23:02:00 <Cale> > let (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap in tail . (tail . inits $ "foo")
23:02:01 <emu> could the Y combinator be expressed with existential types enabled?
23:02:02 <glguy> Cale: and that is why (.) is not fmap (generalized)
23:02:02 <lambdabot>  ["","o","oo"]
23:02:08 <emu> (without using let)
23:02:18 <Cale> Well, we're just not used to it :)
23:03:05 <bos> dons: did someone write an rdtsc example?
23:03:41 <dons> yeah, an entire new library :)
23:03:46 <dons> see the above url
23:04:05 <Cale> rdtsc?
23:04:17 <dons> so we can actually count cycles now
23:04:37 <glguy> rdtsc makes me thing of a timer
23:04:38 <dons> Cale: register on ia32 (and 64?) for counting cycles since boot
23:04:42 <glguy> ah, counting cycles
23:04:56 <bd_> ?src Data.ByteStream
23:04:56 <dons> so say, you can measure the cost of a call in terms of cycles
23:04:56 <lambdabot> Source for this function is not available.
23:04:59 <bd_> ?source Data.ByteStream
23:05:00 <lambdabot> Data.ByteStream not available
23:05:05 <glguy>  ?fptools
23:05:09 <emu> does it overflow?
23:05:14 <bos> yes.
23:05:39 <bos> rdtsc is nasty.
23:06:05 <dons> $ ./A
23:06:06 <dons> Cost of rdtsc (ffi call) in cycles 5606
23:06:07 <dons> :)
23:06:51 <dons> import Rdtsc.Rdtsc
23:06:51 <dons> main = do t1 <- rdtsc
23:06:51 <dons>           t2 <- rdtsc
23:06:51 <dons>           putStrLn ("Cost of rdtsc (ffi call) in cycles " ++ show (t2 - t1))
23:06:54 <dons> anyway, seems useful!
23:07:01 <xpika> does anyone here know how to paste from xterm?
23:07:06 <bos> it gives different results on different cpus, and changes with the cpu frequency.
23:07:30 <emu> xpika: middle click -- but send it to a paste bot not the channel
23:08:07 <dons> bos, ah, so it does!
23:08:51 <bos> yes. rdtsc looks like your friend, but it just wants to mess with your head.
23:09:17 <dons> :)
23:10:54 <bos> and it's not a serializing instruction, so it doesn't even necessarily measure the same thing twice if called in a loop.
23:29:03 <xpika> is there a way to break evaluation in GHCI without using <Ctrl-z>
23:29:19 <emu> ctrl-c?
23:29:32 <xpika> thx
