00:00:10 <dons> newtype ModuleT s m a = ModuleT { moduleT :: ReaderT (MVar s, String) m a }
00:00:10 <dons>     deriving (Functor, Monad, MonadTrans, MonadIO, MonadError IRCError, MonadState t)
00:00:27 <dons> way way too many classes being derived there ;)
00:00:29 <glguy> deriving IRCError?
00:00:44 <dons> yeah, someone apparently knew how to do this
00:00:46 <dons> not me
00:00:56 <sjanssen> just generalized newtype deriving
00:01:02 <dons> yup
00:01:18 <bd_> error "You are not supposed to call local"
00:01:19 <bd_> nice
00:01:22 <dons> one day I'll tear down this monad tower, and repalce it with a nice StateT
00:01:22 <glguy> I thought someone said today that you couldn't make user-defined classing "derivable"
00:01:29 <dons> yeah, so that means its just a StateT, not a ReaderT at all
00:01:40 <Cale> glguy: you can't
00:01:45 <dons> (I think we were going to use readerT for the module-local state, but never bothered)
00:01:56 <Cale> glguy: newtype-deriving just lets you derive classes already defined for the base type
00:02:03 <glguy> oh
00:02:04 <glguy> ok
00:02:18 <glguy> so there is an instance of IRCError for ReaderT is all
00:02:20 <dons> all the lambdabot tower of babel^h^h^h monads is just used as if it was a StateT
00:02:49 <nornagon> TOWER OF MONADS
00:02:55 * nornagon stacks them.
00:02:55 <glguy> ?yow
00:02:56 <lambdabot> If a person is FAMOUS in this country, they have to go on the ROAD for
00:02:56 <lambdabot> MONTHS at a time and have their name misspelled on the SIDE of a
00:02:56 <lambdabot> GREYHOUND SCENICRUISER!!
00:02:58 <dons> I wonder if we should be letting Heffalump near darcs after all...
00:03:08 <bd_> How dull. it'd be far mroe interesting to play such tricks with arrows :)
00:03:09 <dons> now he's got the GADT fever ;)
00:03:13 <dons> bd	heh
00:03:22 <bd_> or shouldn't I be giving people ideas >.>
00:03:31 <dons> we could do the asynchronous plugins that way, Frag style
00:03:34 <bd_> [hmm, running lambdabot's processing backwards...]
00:03:36 <bd_> Frag?
00:03:49 <dons> an arrow-based multi-agent 3D game in Haskell
00:03:56 <bd_> I need to reread the arrows paper, it didn't all sink in the first time...
00:03:58 <bd_> ooh
00:04:02 <bd_> is there a paper on that?
00:04:04 <dons> the characters in the games are arrows or something
00:04:06 <nornagon> heh, i heard about that
00:04:07 <dons> ?wiki Frag
00:04:08 <lambdabot> http://www.haskell.org/haskellwiki/Frag
00:04:31 <dons> turned out to be just the right abstraction for a game-literate haskell-newbie to write a full game in 10 weeks...
00:05:03 <bd_> hm, 45 pages... I think I'll safe this for tomorrow. 3am + 45 paper doth not comprehension make
00:15:33 <boulez> [00:56] (bd_): Frag?
00:15:33 <boulez> [00:56] (dons): an arrow-based multi-agent 3D game in Haskell
00:15:33 <boulez> [00:56] (bd_): I need to reread the arrows paper, it didn't all sink in the first time...
00:15:33 <boulez> [00:56] (bd_): ooh
00:15:33 <boulez> [00:56] (bd_): is there a paper on that?
00:15:33 <boulez> [00:56] (dons): the characters in the games are arrows or something
00:15:35 <boulez> [00:56] (nornagon): heh, i heard about that
00:15:37 <boulez> [00:56] (dons): ?wiki Frag
00:15:39 <boulez> [00:56] (lambdabot): http://www.haskell.org/haskellwiki/Frag
00:15:41 <lambdabot> Title: Frag - HaskellWiki
00:15:43 <boulez> errrr
00:16:07 <boulez> oops
00:16:55 <glguy> I always get a Bus Error when I try to run Frag
00:17:13 <dons> glguy: you need a decent card to run it
00:17:18 <dons> and opengl support
00:17:26 <glguy> so... not a powerbook?
00:17:36 <dons> hmm, not su
00:17:37 <dons> re
00:17:58 <dons> i only maintain it, i don't actually know the src :)
00:18:01 <sjanssen> I'd imagine it'd work under X11 if HOpenGL works
00:18:02 * bd_ wonders if Frag could be parallelized using the new GHC 6.6 smp support easily...
00:19:07 <bd_> on that note, sleepCC ()
00:24:36 * glguy &
00:24:58 * nornagon ->
00:26:33 * iah <- callCC (return . fix)
00:27:50 <nornagon> :t (return . fix)
00:27:51 <dons> :t callCC (return . fix
00:27:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> a) -> m a
00:27:52 <glguy> I just tried it on windows... glut32.dll not found
00:27:53 <lambdabot> parse error (possibly incorrect indentation)
00:27:56 <dons> :)
00:27:59 <glguy> anyone know how to get around that
00:28:06 <dons> > callCC (return . fix) (id)
00:28:08 <lambdabot>   add an instance declaration for (MonadCont ((->) (a -> a)))
00:28:08 <lambdabot>     In the defi...
00:28:43 <nornagon> @src fix
00:28:43 <lambdabot> fix f = let x = f x in x
00:29:04 <dons> ?src callCC
00:29:05 <lambdabot> Source for this function is not available.
00:29:10 <dons> oh, class function
00:29:14 <iah> ? callCC (return . fix) >>= id
00:29:22 <iah> > callCC (return . fix) >>= id
00:29:23 <lambdabot>   add an instance declaration for (Show (m b))
00:29:35 <dons> > callCC (return . fix) >>= id :: Maybe Int
00:29:37 <lambdabot>   add an instance declaration for (MonadCont Maybe)
00:29:40 <dons> heh
00:29:44 <iah> > flip runCont id $ callCC (return . fix) >>= id
00:29:45 <lambdabot>  Add a type signature
00:30:01 <iah> > flip runCont id $ callCC (return . fix) >>= id :: Cont () ()
00:30:02 <lambdabot>   add an instance declaration for (Show (Cont () ()))
00:30:11 <iah> flip runCont id $ callCC (return . fix) >>= id :: ()
00:30:15 <dons> I'm not sure we've ever actually used callCC in channel before
00:30:22 <iah> > flip runCont id $ callCC (return . fix) >>= id :: ()
00:30:24 <lambdabot>  Exception: <<loop>>
00:30:27 <iah> finally.
00:30:28 <dons> nice!
00:30:30 <nornagon> heh
00:30:55 <glguy> is there a flag to link statically
00:30:55 <dons> > flip runCont id $ callCC (return . fix) >>= (1:) :: [Int] -- random guess
00:30:57 <lambdabot>  Couldn't match `Cont a' against `[]'
00:30:57 <glguy> with ghc?
00:31:04 <dons> -static
00:31:24 <iah> id :: Cont () () -> Cont () () here
00:31:42 <iah> ?t callCC (return . fix)
00:31:43 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:31:51 <iah> ?type callCC (return . fix)
00:31:53 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
00:32:05 <iah> ?type (callCC (return . fix) >>=)
00:32:07 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => (m b -> m b1) -> m b1
00:32:42 * glguy is playing frag...
00:36:34 * glguy & for real now
00:37:54 <dons> ?src foldr
00:37:55 <lambdabot> foldr k z xs = go xs
00:37:56 <lambdabot>     where go []     = z
00:37:56 <lambdabot>           go (y:ys) = y `k` go ys
00:37:56 <dons> ?src foldl
00:37:57 <lambdabot> foldl f z xs = lgo z xs
00:37:57 <lambdabot>     where lgo z []     =  z
00:37:57 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:38:55 <pjd> does anyone know why Ord's default definitions make <= special, instead of defining all the operators circularly?
00:40:02 <dons> hmm
00:40:03 <dons> -- Instances of 'Ord' can be derived for any user-defined
00:40:03 <dons> -- datatype whose constituent types are in 'Ord'.  The declared order
00:40:03 <dons> -- of the constructors in the data declaration determines the ordering
00:40:03 <dons> -- in derived 'Ord' instances.  The 'Ordering' datatype allows a single
00:40:05 <dons> -- comparison to determine the precise ordering of two objects.
00:40:08 <dons> --
00:40:10 <dons> -- Minimal complete definition: either 'compare' or '<='.
00:40:13 <dons> -- Using 'compare' can be more efficient for complex types.
00:41:41 <Jaak> blast
00:41:50 <pjd> dons: someone had a question/problem yesterday where they defined <, and things went loopy
00:41:59 <Jaak> my slightly optimising brainfuck interpreter is dreadfully slow :\
00:42:30 <iah> > flip runCont id . runListT $ callCC (return . fix) >>= mplus (return 1) . mplus (return 1) :: [Int]
00:42:31 <lambdabot>  Exception: <<loop>>
00:42:47 <iah> hmm, listt is strict...
00:43:16 <dons> mm. I think that's the first time I've seen ListT here too :)
00:43:18 <dons> iah++
00:43:32 <Cale> ListT isn't a proper monad transformer either.
00:44:14 <iah> :(
00:44:16 <pjd> dons: it seems surprising to me that <= (or any of the others) is special this way
00:45:49 <pjd> when you could define the operators in a chain, so that implementing any one implements the rest too
01:01:22 <kzm> Off topic, but are there any cacert users here?
01:04:35 <Jaak> could somebody take a look if there is any obvious way to optimise this: www.ut.ee/~a51081/Progemine/Haskell/bf3.hs
01:04:47 <Jaak> "run" is clearly the bottleneck there
01:05:29 <Jaak> but darn, even the most naive bf interpreter is times faster than this one :P
01:05:43 <Jaak> in C
01:10:09 <ClaudiusMaximus> Jaak: doesn't the 'canonical' bf spec say the tape is bounded in [0,somelargenumber)? moreover, do you need laziness?  if you have bounded tape and code, and don't need laziness, i'd use http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-Unboxed.html
01:10:12 <lambdabot> http://tinyurl.com/yek2tz
01:15:01 <Jaak> yeah
01:16:07 <Jaak> i should try if it makes any difference. not very haskellish, but frell
01:28:17 <Jaak> whoa, now it's even slower
01:33:38 <Jaak> problem is now with the "setCurrent" function: setCurrent (Data i arr) x = Data i (arr // [(i, x)])
01:35:59 <Jaak> i don't think i can get around the incremental update in any way...
01:36:49 <iah> you could use ST and STUArray
01:37:05 <iah> or IO and IOUArray, I guess
01:37:29 <iah> ?hoogle STUArray
01:37:30 <lambdabot> Data.Array.ST.STUArray :: data STUArray s i a
01:37:31 <lambdabot> Data.Array.ST.castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
01:37:31 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
01:37:37 <iah> ?docs STUArray
01:37:38 <lambdabot> STUArray not available
01:37:51 <iah> ?docs Data.Array.ST.STUArray
01:37:51 <lambdabot> Data.Array.ST.STUArray not available
01:38:09 * iah shakes a fist at lambdabot
01:38:20 <wolfgangbeck> ?docs Control.Concurrent.STM.check
01:38:20 <iah> ?docs Data.Array.ST
01:38:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-ST.html
01:38:21 <lambdabot> Control.Concurrent.STM.check not available
01:38:45 <iah> ?docs Control.Monad.ST
01:38:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
01:39:57 <iah> either way you shouldn't be using lists...
01:40:21 <AtnNn> what about Data.Sequence ?
01:40:27 <iah> ?docs Data.Sequence
01:40:28 <lambdabot> Data.Sequence not available
01:41:08 <iah> that would be a bit better
01:41:16 <iah> lookup is still O(log(min(i,n-i)))
01:41:27 <iah> better than O(i) though
01:41:46 <iah> STUArray has O(1) lookup/update :D
01:42:18 <Jaak> sounds perfect
01:42:26 <Jaak> i bet there is a catch somewhere
01:42:39 <iah> well, you have to use it in an ST monad
01:42:54 <iah> once you leave the monad, you can't touch it
01:43:34 <iah> but it's a real destructive-update array, like in C
01:44:01 <iah> but typesafe so you don't shoot yourself in the foot, unlike in C :)
01:45:12 <iah> ST is actually secretly the same thing as the IO monad
01:45:32 <iah> or rather, IO is a special kind of ST
01:45:42 <iah> ?src IO
01:45:43 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:45:49 <iah> ?src ST
01:45:49 <lambdabot> newtype ST s a = ST (STRep s a)
01:45:58 <iah> ?src STRep
01:45:58 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
01:46:14 <iah> IO = ST RealWorld
01:47:09 <xerox> ?src runST
01:47:10 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
01:47:21 <iah> ?src runSTRep
01:47:22 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
01:47:25 <flux__> ?src show
01:47:26 <lambdabot> show x = shows x ""
01:47:43 <flux__> ?src shows
01:47:44 <lambdabot> Source for this function is not available.
01:47:51 <flux__> (sorry for divesion ;-))
01:47:51 <iah> :t shows
01:47:53 <lambdabot> forall a. (Show a) => a -> ShowS
01:48:08 <iah> shows is part of the Show typeclass
01:48:20 <iah> i think
01:48:21 <Jaak> @src shows :: Int -> ShowS
01:48:22 <lambdabot> Source for this function is not available.
01:48:26 <flux__> yeah, I was wondering what it would show in that case
01:48:56 <iah> or maybe not... hmm
01:49:03 <Jaak> oh well, i'll see if i can figure the ST monad out
01:51:29 <iah> you could use an IOUArray too
01:51:34 <iah> i guess you're already using IO
01:51:52 <iah> then you don't have to worry about ST
01:53:43 <MarcWeber> Does anybody have a clue when lookAhead from parsec library might be used?
01:58:58 <mux> can anyone recommend a good paper about F1?
01:59:24 <earthy> marcweber: whenever you want to decide which parse to make on the basis of the lookahead symbol
01:59:49 <Itkovian> I followed the guide on http://haskell.org/haskellwiki/How_to_write_a_Haskell_program to get a cabalised project going, but something went amiss: <no location info>: file name does not match module name `Main'
01:59:50 <lambdabot> Title: How to write a Haskell program - HaskellWiki
01:59:52 <Itkovian> Any ideas?
01:59:52 <earthy> e.g. when two alternatives start with the same parse.
02:06:03 <MarcWeber> earthy: Where ist the difference to  try( symbol1 >> continuation1) <|> try (symbol2 >> continuation2)  ?
02:07:26 <earthy> does there need to be? :)
02:07:30 <earthy> timtowtdi
02:07:43 <earthy> ofcourse, lookAhead is slightly faster
02:07:52 <MarcWeber> earthy: Thanks Got it
02:08:14 <earthy> btw: symbol1 == symbol2, ofcourse
02:08:45 <earthy> otherwise lookAhead is useless
02:10:00 <MarcWeber> Itkovian: Can you paste the output of find and cat *.cabal somwhere?
02:11:05 <MarcWeber> earthy: You benefit if you have more than 2 choices .. as lookahead will have to parse symbol and the following parser will have to do this again..
02:11:20 <Itkovian> @paste
02:11:20 <lambdabot> http://paste.lisp.org/new/haskell
02:11:27 <Itkovian> @pastebin
02:11:27 <lambdabot> Unknown command, try @list
02:13:07 <wolfgangbeck> @list
02:13:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
02:13:19 <lisppaste2> itkovian pasted "rdpmc cabal" at http://paste.lisp.org/display/34216
02:14:48 <ClaudiusMaximus> i'm having trouble with FFI, are there any caveats to be aware of when using CFloats in foreign exports?
02:26:08 <Lemmih> ClaudiusMaximus: What kind of trouble?
02:26:44 <ClaudiusMaximus> Lemmih: valid input -> my haskell function -> garbage
02:29:16 <Itkovian> brb
02:32:10 <eivuokko> Claudius, can you show your c decl and ffi decl, please?
02:32:53 <lisppaste2> ClaudiusMaximus pasted "FFI pain" at http://paste.lisp.org/display/34218
02:34:42 <eivuokko> Hmmm.  You do include the stub or something for haskell compiler generated decls in C, right?
02:35:06 <ClaudiusMaximus> yep, #include "Quux_stub.h"
02:35:09 <eivuokko> Otherwise the calling convention in C probably uses doubles.  Also if you use CFloat, you can use float.  If you use HsFloat, you can use Float in haskell.
02:35:59 <ClaudiusMaximus> that's where i got confused, the Quux_stub.h was the same whichever i use in haskell
02:36:18 <eivuokko> Yeah, they probably are the same on most platforms
02:36:44 <eivuokko> I mean, HsFloat, float, Float, CFloat all have same representation on most platforms.
02:38:07 <eivuokko> If you try doubles instead of floats, does it work?  I can't think any reason that wouldn't work, anyway.  Sorry.
02:38:48 <wolfgangbeck> is there an example how to do a user-defined exception?
02:40:52 <ClaudiusMaximus> eivuokko: "foreign export ccall foo :: Int -> IO Int"  << this works in a stripped down example i tried earlier, will see if I get the same weirdness in that example using Float instead of Int...
02:41:20 <eivuokko> There isn't much to it, check Control.Exception, DynException ctor in Exception and throwDyn, throwDynTo and catchDyn .  You might want to check out Data.Typeable and Data.Dynamic to see how it all works.
02:42:16 <eivuokko> Claudius, Sounds a bit like compiler bug, but there's probably just something we don't see in your case :-(
02:42:34 <wolfgangbeck> eivuokk: I read this stuff, but I've no luck with deriving from Typeable
02:44:34 <wolfgangbeck>  i tried data MyExc = MyEx1 | MyEx2 deriving Typeable
02:45:13 <wolfgangbeck> and got a message that this was only possible with some ghc extension
02:46:17 <pharm> -fglasgow-exts might help you...
02:47:16 <wolfgangbeck> pharm: is there no standard way to do it?
02:47:20 <eivuokko> {-# OPTIONS_GHC -fglasgow-exts #-} turns it on, otherwise you need to write instances by hand (in case you don't like that gigantic all extensions switch)
02:47:51 <eivuokko> Nah, only Prelude classes have auto-deriving in haskell 98.
02:47:58 <wolfgangbeck> eivukko: so i have to write an instance of Typeable
02:48:07 <araujo> morning
02:48:08 <pharm> wolfgangbeck: not if it's not in standard haskell, no.
02:48:39 <eivuokko> wolfgangbeck, Yeah.  Doesn't Data.Typeable docs have examples of that?
02:48:43 <iah> put {-# OPTIONS_GHC -fglasgow-exts #-} at the top of your .hs file and it should work
02:49:40 <iah> your file won't be haskell 98 anymore, but...
02:49:43 <wolfgangbeck> hope there is not dozens of methods to implement for Typeable
02:49:56 <eivuokko> Only one
02:50:46 <wolfgangbeck> this exception data type / dynamic stuff seems a bit doubious to me
02:50:50 <pharm> eivuokko: Yup, down at the bottom.
02:51:01 <wolfgangbeck> i'll try it, thank you
02:51:49 <eivuokko> Hmm, for non-ghc there's less magic and more repetition in Typeable.  Not so sure how it works on hugs etc.
02:52:19 <dons> oh good, updates on the 'nop' package!
02:52:22 <dons> "For code designed not to do anything, HNOP has high hopes. I have
02:52:22 <dons> recently split the project into two Cabal packages: "nop", a library of
02:52:23 <dons> no-op services, and "hnop", a program that uses nop to do nothing."
02:52:37 <pharm> that's silly.
02:53:07 <iah> ?where hnop
02:53:08 <lambdabot> http://semantic.org/hnop/
02:53:11 <dons> it shows good cabal + QuickCheck integration (its an example of how to package a haskell program :)
02:53:57 <eivuokko> I kinda agree that Typeable/Dynamic and Dynamic exceptions seems a bit dubious.  But in the end, compared to many other languages, it's almost the same, really.  The problem is just that Haskell is so strongly compile-time typed, and everything is oriented that way, not that Typeable is bad or anything.
02:54:04 <pharm> The moral equivalent of the autoconfed hello world gnu package then...
02:54:38 <pharm> (400kb of gzipped source in that instance!)
02:54:42 <dons> well, maybe. or a noop ruby gem (I think they have one too)
02:58:47 <lisppaste2> ClaudiusMaximus annotated #34218 with "Bazf + Barf.so => garbage" at http://paste.lisp.org/display/34218#1
02:59:10 <wolfgangbeck> now, how can i create a value of type 'TypeRep'?
02:59:38 <eivuokko> :t typeOf undefined
02:59:40 <lambdabot>     Ambiguous type variable `a' in the constraint:
02:59:41 <lambdabot>       `Typeable a' arising from use of `typeOf' at <interactive>:1:0-5
02:59:46 <lisppaste2> ClaudiusMaximus annotated #34218 with "oops, forgot the output" at http://paste.lisp.org/display/34218#2
02:59:46 <eivuokko> Yawn :)
03:02:26 <vegaiW> dons: how does hnop show cabal+quickcheck integration?
03:06:59 <tibbe> @where ghci
03:07:00 <lambdabot> I know nothing about ghci.
03:07:36 <tibbe> there's a running ghci interpreter online somewhere right?
03:07:43 <tibbe> ie web app
03:08:27 <eivuokko> I doubt totally unrestricted ghci is available that way.
03:09:03 <eivuokko> And for non-IO use, lambdabot isn't bad :)
03:15:35 <xerox> ?where lambdaweb
03:15:36 <lambdabot> http://lambdabot.codersbase.com
03:15:40 <xerox> tibbe -^
03:15:49 <tibbe> xerox, thanks
03:17:22 <Jaak> iah: IOUArrays writeArray and readArray are O(1), yes?
03:17:39 <iah> jaak: yep
03:18:11 <Jaak> well.. apparently using IOUArray didn't help much, if at all
03:18:18 <iah> hmmm
03:18:25 <iah> well you could always try profiling :D
03:18:52 <Jaak> most of the time is wasted on readArray
03:19:42 <Jaak> (i might be doing something wrong, this stuff is kind of new to me)
03:20:16 <iah> jaak: good luck
03:20:19 <iah> I have to get some sleep, though
03:20:24 <iah> it's 3 AM here
03:20:32 <iah> good night/morning, #haskell
03:20:50 <Jaak> iah: thanks for suggestions, i'll toy around some with IOUArray
03:20:52 <Jaak> blast
03:24:56 <ClaudiusMaximus> whew, got a simple FFI thingy with Float working correctly (forgot to -D__GLASGOW_HASKELL__ ...)
03:34:52 <bakert> What's the haskell equivalent of "do nothing".  I want to write a line if the value is false and not if it is true.
03:35:17 <bakert> But I get "non-exhaustive patterns" if I just leave off the case where I want nothing.
03:35:37 <dons> when (not v) $ print "nothing"
03:35:51 <dons> return () -- is the 'do nothing' action
03:36:03 <bakert> ah.  brillo.  thanks.
03:36:06 <dons> if x then print "hello" else return ()
03:36:08 <dons> -->
03:36:15 <dons> when x (print "hello")
03:36:18 <bakert> i should have thought of that.
03:36:27 <bakert> (return () i mean, not the whole bang shoot)
03:39:57 <bakert> Say I have an enum like: data Things = A | B | C
03:40:07 <bakert> and I want to give A, B and C the same fields
03:40:21 <bakert> How can I do that and still retain the kind of enum-inesss.  (if that makes sense)
03:40:25 <bakert> ?
03:40:40 <araujo> anyone good with parsec here?
03:41:01 <bakert> araujo, i looked at it for the first time yesterday.  i don't suppose that counts.
03:41:39 <araujo> bakert, easy question ; isn't 'many word' supposes to parse zero or more words?
03:41:53 <bakert> i think so, and many1 does 1 or more.
03:42:39 <bakert> Perhaps for my Thing problem I need to do something with instances?
03:42:48 <araujo> yeah. The thing is that it only keeps parsing zero or 'one' word
03:43:04 <araujo> it doesn't take more than one.
03:43:07 <bakert> araujo, not sure about greediness or lack thereof in parsec.  ??
03:43:23 <bakert> Thing = Thing { fld1 :: Int, fld2 :: String }
03:43:46 <bakert> instance A = Thing { fld1 = 2, fld2 = "hello" }
03:43:50 <bakert> hmm no.
03:50:40 <bakert> OK, so I can't make an Enum with non-nullary constructors.
03:50:51 <bakert> So is there anything better than:
03:51:00 <bakert> @paste
03:51:01 <lambdabot> http://paste.lisp.org/new/haskell
03:52:42 <lisppaste2> bakert pasted "Looking for a better way to make a collection of things.  Can you help?" at http://paste.lisp.org/display/34221
03:53:59 <kzm> Would it make sense to have a parallel map?  That distributes the work across threads?  Anybody have one?
03:54:04 <bakert> Definitely not as nice as "things = [A .. C]" like I can when it is an Enum.
03:54:11 <bakert> Shame.
03:56:47 <gds> bakert: "type Thing = (String, Int) -- (name, fld)"  ?
03:57:06 <gds> or am I misunderstanding something?
03:57:37 <gds> Oh - sorry, I am :S
03:58:01 <lisppaste2> ClaudiusMaximus annotated #34218 with "got it working, forgot to gcc -D__GLASGOW_HASKELL__" at http://paste.lisp.org/display/34218#3
03:58:23 <bakert> What I really want is to be able to say:
03:58:31 <bakert> doStuff A = ...
03:59:02 <bakert> rather than
03:59:24 <bakert> doStuff Thing { name = "A" } = ...
03:59:31 <bakert> but perhaps I have no choice.
03:59:35 <bakert> What does "instance" do?
04:00:20 <ClaudiusMaximus> bakert: http://www.haskell.org/tutorial/classes.html
04:00:21 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
04:00:47 <bakert> ClaudiusMaximus, thanks ... will have a read
04:01:22 <bakert> ah yes ... perhaps Thing can be a typeclass and A, B and C can be instances.
04:01:27 <bakert> this looks good.
04:07:30 <kzm> @karma+ ByteString
04:07:31 <lambdabot> ByteString's karma raised to 1.
04:07:55 <kzm> ./clusc.orig GEM.L seq.tgi.L  4.49s user 0.10s system 96% cpu 4.773 total
04:07:56 <kzm> ./clusc GEM.L seq.tgi.L  1.58s user 0.03s system 96% cpu 1.671 total
04:08:30 <kzm> % darcs what -s
04:08:31 <kzm> M ./Cluscomp.lhs -5 +9
04:08:31 <bakert> speedy
04:08:36 <pjd> kzm: Parallel Haskell?
04:08:42 <kzm> Basically just changing the type sigs.
04:09:01 <kzm> No, that's just going from String to ByteString (.Lazy.Char8)
04:09:53 <kzm> Took me five minutes, which I'll save if I run it, oh about a hundred times.
04:10:09 <pjd> kzm: i mean, re. your earlier question
04:11:20 <pjd> @where dph
04:11:21 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
04:11:36 <kzm> @hoogle pmap
04:11:38 <lambdabot> No matches found
04:12:34 <kzm> I know I can do it with MVars or something, mainly wondering if has been done already.
04:13:28 <kzm> I guess there would be strictness issues?  And for max perf, you'd have to allow shuffling. So it's not entirely trivial, I guess.
04:13:32 * kzm shrugs.
04:15:28 <pierre1> @where HXT
04:15:30 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
04:16:34 <pierre1> hmm, this link seems to be broken
04:17:25 <syntaxfree> I'm wondering what's the direct syntax for applying infix operators with three arguments.
04:17:28 <syntaxfree> if I define
04:17:34 <metaperl> @url hsxml
04:17:34 <lambdabot> I know nothing about hsxml.
04:17:35 <syntaxfree> (.|.) a b c = (a,b,c)
04:17:44 <metaperl> anyone know the url to Oleg's HSXML?
04:18:00 <syntaxfree> I was hoping there was a variant of a (.|. c) b that could be used.
04:18:06 <syntaxfree> I can't find one though.
04:18:19 <metaperl> pierre1 - me and Cale are using HXT quite a bit... what is your interst in it?
04:20:54 <ski> @hoogle MaybeT
04:20:55 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
04:22:05 <ClaudiusMaximus> @hoogle flip3
04:22:06 <lambdabot> No matches found
04:24:48 <bakert> Problemo.  I can't quite get "instance" and typeclasses.
04:24:51 <bakert> @paste
04:24:52 <lambdabot> http://paste.lisp.org/new/haskell
04:25:03 <syntaxfree> mathy question.
04:25:12 <pierre1> metaperl: i'm using it as xml generator in my toy project
04:25:14 <lisppaste2> bakert pasted "bakert doesn't quite understand typeclasses." at http://paste.lisp.org/display/34223
04:25:22 <syntaxfree> computing Euler's totient by just spelling out all the coprimes seems faster than doing it by prime factorisation.
04:25:42 <bakert> What's wrong with my "instance" there?  Gives me " Not in scope: type constructor or class `Pin'"
04:27:08 <metaperl> bakert - I dont know the answer to your question, but the class describes login as a function taking an argument and returning a bool ... your instance simply returns Bool
04:27:26 <bakert> very true.  ta.
04:27:31 <metaperl> bakert - you also need to put "Just" in front of that 4-tuple
04:27:58 <dmhouse> bakert: _types_ are instances of typeclasses.
04:28:06 <dmhouse> bakert: Pin is a value.
04:28:15 <bakert> ah yes!
04:28:33 <metaperl> Pin is a data constructor, isn't it dmhouse?
04:28:41 <dmhouse> metaperl: yes, which is a value.
04:28:47 <dmhouse> metaperl: just like True.
04:28:50 <syntaxfree> >  let a (.|) b = (mod a b) == 0 in 5 .| 3
04:28:52 <lambdabot>   Not in scope: `.|'
04:29:11 <dmhouse> data Bool = True | False -- True and False are data constructors and values.
04:29:36 <dmhouse> syntaxfree: . is special, I think.
04:29:44 <bakert> What I really want is a collection of Bookies.  They each have a (different) login and getFunds function.
04:29:49 <bakert> What  would be the right way to do that?
04:29:54 <dmhouse> syntaxfree: you're probably trying to select the function (|) from the current module or something.
04:29:55 <syntaxfree> dmhouse sillier than that. look.
04:30:09 <syntaxfree> > let a .| b = (mod a b) == 0 in 5 .| 3
04:30:11 <lambdabot>  False
04:30:16 <bakert> Ideally I'd like to be able to say: blahBlahFunction Pin =
04:30:17 <dmhouse> Oh, yeah, of course :)
04:30:21 <syntaxfree> I just noticed.
04:30:24 <dmhouse> syntaxfree: . isn't special. :)
04:30:31 <syntaxfree> I wish I could have ternary infix operators.
04:30:44 <syntaxfree> I'd like a modulo-equal operator.
04:30:53 <pierre1> metaperl: just wondered where i can get latest http and browser libraries
04:30:58 <dmhouse> bakert: why not blahBlahFunction :: Bk -> whatever?
04:31:01 <syntaxfree> a (===n) b = (a mod n) == (b mod n)
04:31:04 <metaperl> I think dons maintains http
04:31:19 <bakert> pierre1, i think it is www.haskell.org/http/
04:31:23 <metaperl> @google dons darcs http
04:31:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:31:25 <lambdabot> Title: lambdabot
04:31:36 <pierre1> bakert: thanks
04:31:38 <bakert> pierre1, but that code has bugs in cookie handling (but easily fixable ones)
04:31:54 <bakert> i must work out how to submit a patch.
04:32:03 <dmhouse> syntaxfree: it can be done, give me a minute.
04:32:05 <metaperl> darcs get http://darcs.haskell.org/http/
04:32:07 <lambdabot> Title: Index of /http
04:32:20 <syntaxfree> I don't know why the prelude doesn't include modulo rings out of the box.
04:32:26 <syntaxfree> er, integers modulo n rings.
04:32:42 <metaperl> syntaxfree - is that a common need? I dont even know what a modulo n ring is :)
04:32:49 <vincenz> Are the stats of the channel still around
04:33:06 <metaperl> bakert - you still havent gotten an answer to your question about creating a collection of bookies right?
04:33:14 <bakert> dmhouse, Pin is a particular bookmaker and his login function is different to other bookmaker login functions.
04:33:18 <syntaxfree> metaperl: not sure. I'm an economist, remember.
04:33:24 <syntaxfree> I'm taking a graduate-level course in num theory
04:33:27 <dmhouse> bakert: different in what way?
04:33:35 <dmhouse> bakert: is the type the same?
04:33:36 <metaperl> remember? It is news to me
04:33:36 <bakert> metaperl, not really.  i think i'm just confused about typeclasses and how exactly i ought to structure it
04:33:50 <bakert> dmhouse, yes type the same.
04:33:57 <bakert> dmhouse, just actual operations different.
04:34:34 <syntaxfree> they should add that to the topic.
04:34:40 <syntaxfree> "syntaxfree is an economist".
04:34:43 <dmhouse> bakert: then login :: Bk -> Bool; login Pin = ...; login ... = ...; No typeclasses needed.
04:34:58 <bakert> you may well be right
04:35:10 <bakert> i started looking at typeclasses because originally I had:
04:35:27 <bakert> data Bookie = Pin | Monkey | Donkey | A | B | C deriving Enum
04:35:39 <bakert> and then I could get my list of bookies with a nice [Pin ... C]
04:36:08 <bakert> So perhaps I should go back to that, ignore typeclasses and just define login Pin and login Monkey and  login Donkey, etc.
04:36:45 <dmhouse> bakert: yep.
04:36:51 <bakert> So, the operations are not associated with the types.  If I forget to do a login for one of them it won't remind me ... but my code will break soon enough anyway.
04:36:53 * vincenz siwtches comp
04:36:58 <dmhouse> bakert: if you _really_ wanted you could do:
04:37:00 <dmhouse> data Pin = Pin
04:37:03 <dmhouse> data Monkey = Monkey
04:37:04 <dmhouse> ...
04:37:14 <dmhouse> class Bookie b where login :: b -> Bool
04:37:22 <dmhouse> instance Bookie Pin where login Pin = ...
04:37:28 <dmhouse> instance Bookie Monkey where login Monkey = ...
04:37:34 <dmhouse> But that's just more complicated.
04:37:54 <dmhouse> And if you wanted to throw a number of Bookies into list, you'd have to muck around with existentials.
04:38:02 <bakert> that's probably overkill for this situation.  it's more about wanting to do it The Right Way(tm) for haskell but having no idea what that is as i only started programming in it less than 2 weeka ago!
04:38:04 <ski> @hoogle Unique
04:38:05 <lambdabot> Data.Unique :: module
04:38:05 <lambdabot> Data.Unique.Unique :: data Unique
04:38:05 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
04:38:12 <ski> @hoogle+
04:38:12 <lambdabot> Data.Unique.newUnique :: IO Unique
04:38:17 <dmhouse> bakert: The Right Way is no typeclasses. :)
04:38:27 <ski> hm, there's no 'Unique' for 'ST' ?
04:38:35 <bakert> dmhouse, metaperl, ok no typeclasses.  thanks for your help.
04:38:54 <lisppaste2> dmhouse pasted "Equality with moduli" at http://paste.lisp.org/display/34224
04:38:58 <dmhouse> syntaxfree: ^^
04:39:57 <syntaxfree> oh! ternary operators.
04:40:13 <syntaxfree> I wonder why we don't have a ? b : c funky business, if that's possible.
04:40:13 <dmhouse> It's not really.
04:40:17 <syntaxfree> dmhouse++
04:40:22 <syntaxfree> I know, I know : )
04:40:23 <dmhouse> It's not really a ternary operator.
04:40:43 <dmhouse> It parses to a === (b :% n)
04:40:54 <syntaxfree> but data Cases = Bool .| Bool is equally possible.
04:40:56 <dmhouse> But because I gave :% a higher fixity than === you can write a === b :% n
04:41:08 <dmhouse> syntaxfree: not quite, infix data cons have to begin with a colon.
04:41:09 <syntaxfree> Yes, I understood.
04:41:21 <syntaxfree> well, I stand corrected.
04:41:26 <dmhouse> The nicest formulation of ?: is as follows, IMO:
04:41:29 <bakert> "if x then y else z" is pretty close to a ternary if "(x ? y : z)"
04:41:33 <vincenz> Btw, it's perfectly possible
04:41:39 <vincenz> :)
04:41:43 <vincenz> Let met code it up
04:41:51 <bakert> 9 more characters i suppose.
04:41:57 <dmhouse> > let True ? (a, _) = a; False ? (_, a) = False in 3 > 4 ? ("yes!", "no.")
04:41:59 <lambdabot>  Couldn't match `Bool' against `[Char]'
04:42:01 <vincenz> wait!
04:42:06 <dmhouse> Err...
04:42:10 <dmhouse> > let True ? (a, _) = a; False ? (_, a) = a in 3 > 4 ? ("yes!", "no.")
04:42:11 <lambdabot>   add an instance declaration for (Num Bool)
04:42:12 <syntaxfree> oh. good one.
04:42:18 <dmhouse> With some fixity, that'd work.
04:42:22 <dmhouse> > let True ? (a, _) = a; False ? (_, a) = a in (3 > 4) ? ("yes!", "no.")
04:42:23 <syntaxfree> fixity, yes.
04:42:23 <lambdabot>  "no."
04:42:38 <lisppaste2> metaperl pasted "the variable age_handler_logic is repeating itself, should I meld them somehow?" at http://paste.lisp.org/display/34225
04:42:57 <ClaudiusMaximus> would this work at all?  data Bookie = Pin | Monkey | ...  deriving Enum  ;   and bookies :: Array Bookie (b -> Bool)  and login = bookies ! Pin
04:43:03 <dmhouse> vincenz: I'd be happy if we had a cond :: Bool -> a -> a -> a which we could use with partial app.
04:43:10 <vincenz> dmhouse: even better ;)
04:43:24 <bakert> ClaudiusMaximus, oooh, lots of things I have no idea what they do.  Let me have a read about Array and "!"
04:43:28 <ClaudiusMaximus> :t Array.fromList
04:43:30 <lambdabot> Not in scope: `Array.fromList'
04:43:39 <syntaxfree> just a nitpick.
04:43:43 <vincenz> how do I set fixity?
04:43:44 <ClaudiusMaximus> @hoogle fromList
04:43:45 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
04:43:45 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
04:43:45 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
04:43:46 <dmhouse> ClaudiusMaximus: yes, I suppose. Seems an odd way of doing it.
04:43:56 <vincenz> dmhouse: fixity?
04:43:57 <dmhouse> vincenz: infix op fixity
04:44:01 <vincenz> thx
04:44:02 <syntaxfree> in that function, it's not true that, say, 15 === 7 % 4
04:44:05 <vincenz> dmhouse: in parens?
04:44:08 <dmhouse> vincenz: no.
04:44:16 <vincenz> ok
04:44:18 <syntaxfree> because 15 `mod` 4 = 3 and that /= 7
04:44:24 <dmhouse> ClaudiusMaximus: my guess is you came from C where arrays of function pointers are everywhere :)
04:44:50 <dmhouse> syntaxfree: fine, add in an extra `mod` in the def'n of (===).
04:44:52 <syntaxfree> @pl a === b :% n = a `mod` n == b `mod` n
04:44:53 <lambdabot> (line 1, column 14):
04:44:54 <lambdabot> unexpected "="
04:44:54 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or end of input
04:45:03 <vincenz> dmhouse: doesn't work
04:45:04 <syntaxfree> @pl a `mod` n == b `mod` n
04:45:05 <lambdabot> a `mod` n == b `mod` n
04:45:09 <syntaxfree> heh.
04:45:16 <syntaxfree> @pl \a b n-> a `mod` n == b `mod` n
04:45:17 <lambdabot> (. mod) . ap . ((==) .) . mod
04:45:31 <vincenz> oh, fixity first
04:45:34 <dmhouse> Or equating (`mod` n), if you prefer.
04:45:43 <dmhouse> ?src equating
04:45:43 <lambdabot> Source for this function is not available.
04:45:44 <ClaudiusMaximus> dmhouse: almost, more from AmigaOs .library files
04:46:04 <dmhouse> Fine, equating f x y = f x == f y
04:46:35 <syntaxfree> I wonder if the integers modulo a prime can be made an instance of num.
04:46:37 <dmhouse> It's useful for, say, groupBy (equating snd) (groups a list of pairs by their second component).
04:46:44 <dmhouse> syntaxfree: yes, I did also think of that.
04:46:46 <syntaxfree> s/num/Num.
04:46:51 <dmhouse> Well, not quite. Prime?
04:46:52 <syntaxfree> integers modulo prime are a Field.
04:46:54 <vincenz> @paste
04:46:54 <lambdabot> http://paste.lisp.org/new/haskell
04:47:02 <syntaxfree> integer modulo nonprimes ain't.
04:47:02 <lisppaste2> vincenz pasted "ternary operators" at http://paste.lisp.org/display/34226
04:47:02 <dmhouse> Oh, interesting :)
04:47:18 <syntaxfree> Haskell needs a better numerical tower.
04:47:23 <vincenz> ;)
04:47:29 <syntaxfree> One that honors the sheer mathiness of type classes.
04:47:38 <vincenz> syntaxfree: and more type classes for Num
04:47:41 <vincenz> syntaxfree: and class aliaes
04:47:43 <vincenz> +s
04:47:45 <dmhouse> vincenz: much easier if you set (=:) = (,) and use my method.
04:47:56 <vincenz> dmhouse: define easier?
04:48:04 <dmhouse> Doesn't need extra datatypes :)
04:48:11 <vincenz> dmhouse: It needs data types
04:48:15 <vincenz> and I could just use a Maybe
04:48:18 <syntaxfree> well, yes, that's what I meant by "numerical tower". Maybe I used the term incorrectly.
04:48:20 <dmhouse> Okay, doesn't need _new_ datatypes.
04:48:24 <vincenz> dmhouse: I could use Maybe
04:48:29 <vincenz> ...
04:49:32 <KKKBeaver>  ☆ <快乐IRC> 新年版 ☆
04:49:33 <syntaxfree> dmhouse: your solution doesn't work ;)
04:49:37 <dmhouse> syntaxfree: where?
04:49:38 <syntaxfree> i was already thinking it was odd it would.
04:49:40 <vincenz> KKKBeaver: ??
04:49:47 --- mode: ChanServ set +o vincenz
04:49:51 <syntaxfree> because "b" is a Modulo, not a Num.
04:49:54 <pierre--> aww, how my connection lags
04:50:01 <syntaxfree> so I can't say  "b  `mod` n "
04:50:09 <vincenz> dmhouse: so?
04:50:11 <dmhouse> syntaxfree: so?
04:50:15 <vincenz> dmhouse: I think it's just personal taste.
04:50:15 <syntaxfree> so it won't type.
04:50:20 <syntaxfree> mod isn't defined for your new datatype.
04:50:22 <dmhouse> syntaxfree: why would you want to do that?
04:50:32 <syntaxfree> a === b :% n = a `mod` n == b `mod` n
04:50:39 <syntaxfree> because that's the definition of modulo equivalence.
04:50:49 <dmhouse> Err, that should work.
04:50:55 <syntaxfree> no, it shouldn't.
04:50:55 <dmhouse> b is an Int.
04:50:57 <syntaxfree> look at the type.
04:51:03 <syntaxfree> data Modulo = Int :% Int
04:51:03 <syntaxfree> (===) :: Int -> Modulo -> Bool
04:51:16 <dmhouse> syntaxfree: yes...
04:51:25 <dmhouse> syntaxfree: exactly what you wrote typechecks and works for me.
04:51:48 <syntaxfree> oh. I used (==) instead of ===
04:51:49 <dmhouse> In a === b :% n = ..., a, b and n are all Ints.
04:52:07 <lisppaste2> vincenz annotated #34226 with "cause dmhouse doesn't like _new_ datatypes" at http://paste.lisp.org/display/34226#1
04:52:09 <lisppaste2> dmhouse annotated #34224 with "With the second `mod`" at http://paste.lisp.org/display/34224#1
04:52:36 <dmhouse> vincenz: yes, fine. :) Personal taste, as you said.
04:52:41 <vincenz> :D
04:52:44 --- mode: vincenz set -o vincenz
04:52:54 <vincenz> put your solution on there too
04:53:00 <vincenz> that way people have a contrast :)
04:53:03 <dmhouse> Hehe, were you preparing yourself to /kick me if I didn't accept you were right?
04:53:15 <vincenz> no
04:53:19 <vincenz> I saw the KKK guy spamming
04:53:35 * KKKBeaver 对vincenz说: Sorry, I'm not. 
04:53:42 <vincenz> KKKBeaver: No I know :)
04:53:44 * syntaxfree goes and tries to write the multiplicative inverse in integers modulo n.
04:53:50 * KKKBeaver 对vincenz说: :) 
04:53:51 <vincenz> KKKBeaver: Was just asking what was going on, what with all the funky symbols :)
04:54:06 * KKKBeaver 对vincenz说: I'm just a new hand. 
04:54:18 <earthy> then whack your IRC client into submission
04:54:28 <earthy> you're outputting weird symbols onto IRC
04:54:32 <lisppaste2> dmhouse annotated #34226 with "using pairs" at http://paste.lisp.org/display/34226#2
04:54:50 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/gallery/coding/hsext/proof-of-concept.png   << a Haskell function wrapped in a C shared library loaded by a C app
04:54:54 <lambdabot> http://tinyurl.com/vvjq9
04:54:54 <syntaxfree> it seems to me that multiplication in the cannonical ring of integers modulo n induces a permutation.
04:55:07 <earthy> claudiusmaximus: cool
04:55:09 <syntaxfree> (induces a permutation onto Z/nZ* , anyway)
04:55:19 <bringert> KKKBeaver: see the bottom of this log if you don't see the funkiness in your client: http://tunes.org/~nef/logs/haskell/07.01.05
04:55:55 * KKKBeaver 对bringert说: Thank you 
04:56:05 <kzm> @hoogle STM
04:56:06 <lambdabot> Control.Concurrent.STM :: module
04:56:06 <lambdabot> GHC.Conc.STM :: data STM a
04:56:06 <lambdabot> Language.Haskell.TH.Stmt :: data Stmt
04:56:30 <vincenz> KKKBeaver: what client are you using?
04:57:09 * KKKBeaver 对bringert说: I'm using mIRC v6.02 
04:57:34 * KKKBeaver 对bringert说: And what client are you using? 
04:57:46 <bringert> KKKBeaver: Colloquy
04:58:33 <bringert> KKKBeaver: it seems like most people in here, including the logs, see some funky symbols around nicks that you write
04:58:45 * KKKBeaver 对bringert说: I'm just watching your talking words. 
04:59:08 <bringert> KKKBeaver: can you try switching your client to use UTF-8?
04:59:27 <sieni> and why the actions?
05:00:45 <therp> kkkbeaver: you might want to choose another IRC client for your plattform http://en.wikipedia.org/wiki/Comparison_of_IRC_clients
05:00:45 <lambdabot> therp: You have 1 new message. '/msg lambdabot @messages' to read it.
05:00:59 * KKKBeaver 对bringert说: I'm just choose a nick name randomly for differentiating the name beaver. 
05:01:04 * KKKBeaver 对bringert说: :) 
05:01:47 <dmhouse> KKKBeaver: not only are you outputting weird symbols, everything you say appears as if you've said /me before it.
05:02:14 * KKKBeaver 对bringert说: I'm using a chinese interface of mIRC. 
05:02:20 <bringert> KKKBeaver: your nick is not the problem. the problem is what you appear to type
05:02:34 * KKKBeaver 对bringert说: How to change client to use UTF-8? 
05:02:40 <vegaiW> That's not UTF-8
05:02:51 <vegaiW> ...is it?
05:02:57 <therp> kkkbeaver: depends on the client. maybe try /charset UTF-8 or /charset UTF8
05:03:01 <bringert> KKKBeaver: see the manual
05:03:05 * KKKBeaver 对bringert说: Sorry, I'm a Chinese. 
05:03:29 <syntaxfree> we're such an easy target for trolls.
05:03:40 <syntaxfree> we just let them get their kicks.
05:03:55 <syntaxfree> anyway, be back later.
05:05:10 * KKKBeaver 对bringert说: I have tried /charset UTF8 
05:05:25 <vincenz> KKKBeaver: join ##mirc
05:05:29 * KKKBeaver 对bringert说: and /charset UTF-8, 
05:05:33 <vincenz> KKKBeaver: they can help you
05:06:04 <bringert> KKKBeaver: it you are trolling, cut it out. otherwise, read the manual or go ask in the mirc channel
05:06:05 * KKKBeaver 对vincenz说: Thank you, I will try 
05:06:13 <bringert> s/it/if/
05:06:24 <vincenz> bringert: I don't think he is
05:06:32 <vincenz> bringert: syntaxfree tends to be a bit too judgemental at times
05:17:06 <bakert> So, I do a map with a function that returns a monad-wrapped result.  Is there an easy way to unwrap each element of the list and return the non-monadised list?  just another map of some sort?
05:17:41 <integral> :t mapM
05:17:43 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
05:18:08 <bakert> thanks integral
05:18:26 <notsmack> catMaybes?
05:18:54 <notsmack> or just use mapMaybe instead of map
05:23:12 <bakert> is there a way to turn this into a one liner?
05:23:18 <bakert>     loggedIn <- login bookie
05:23:24 <bakert>     if loggedIn then doFunds bookie else return False
05:23:47 <bakert> I mean, is there some way I can put the "loggedIn <- login bookie" bit into the if?
05:23:59 <bakert> Or does an unwrapping have to stand alone like that?
05:24:16 <Jaak> login bookie >>= \loggedIn -> if loggedIn then doFunds bookie else return False ?
05:24:36 <bakert> Ah!  Thanks Jaak.  I was wondering what that dragon tongue operator might be useful for
05:25:13 <bakert> Of course, that's longer than a line so I don't gain anything!  There's no smaller way like:
05:25:34 <bakert> if (loggedIn <- login bookie) then doFunds bookie else return False???
05:26:05 <notsmack> does saving a line gain you something?
05:26:13 <bakert> "succinctness is power"!
05:26:39 <bakert> you wouldn't want to take 24 lines to do one line's worth of stuff.  this is just a smaller case of the same thing!
05:28:13 <bakert> Actually, my favourite thing about haskell so far is the way i seem to be able to squish down whole chunks of code into single lines.  We'll see about the maintainability.  I actually think it will be good for that too.
05:30:35 <notsmack> heh, that's true of perl, too.  The difference is Haskell's clarity usually /increases/ as you shorten.
05:31:30 <bakert> That's the big trick, you're right, not just the squishing.
05:34:08 <bakert> Hmm ... I'm not quite sure I get mapM.  The inputs to the supplied function have to be in the monad?
05:34:18 <bakert> type of my function is "getInfo :: Bookie -> BrowserAction Bool"
05:34:25 <xerox> ?type (sequence .) . map
05:34:27 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
05:34:52 <bakert> so i want to say (in main) "x = map getInfo bookies" and then "putStrLn $ show x"
05:34:58 <bakert> so i changed it to:
05:35:06 <bakert> x <- mapM getInfo bookies
05:35:30 <bakert> xerox, is that for me?
05:36:13 <xerox> that is mapM implementation, if it helps
05:36:52 <bakert> If I am going from non-monadic args to monadic result in my function can I still use mapM?
05:37:46 <bakert> Actually yes I can see from the type sig that I can.
05:37:56 <bakert> That's what it is for.
05:39:45 <bakert> Ah.  I am just getting the IO and the BrowserAction monads all muddled up.
05:40:39 <bakert> wahey, working.  Thanks xerox
05:49:04 <notsmack> chibeaver: new irc client?
05:50:58 <chibeaver> Yah
05:52:44 <notsmack> much better :-)
05:53:57 <bringert> bakert: you can write a function ifm :: Monad m => m Bool -> m a -> m a -> m a and use that
05:54:48 <bakert> bringert, I don't feel comfortable enough branching out on my own like that!
05:54:54 <bakert> it is a good idea.
05:55:01 <bakert> I now need to simplify this:
05:55:06 <bakert> --loggedIn <- login bookie; if loggedIn then doFunds bookie else return False
05:55:13 <bakert> oops sorry ignore that
05:55:17 <bakert> cut and paste cock up
05:55:31 <bakert> This is what i need to simplify:\n    funds <- getFunds bookie
05:55:31 <bakert>     case funds of
05:55:31 <bakert>         Nothing -> return False
05:55:31 <bakert>         Just funds -> return $ insertFunds bookie funds
05:55:44 <bakert> would be nicer to say:
05:56:01 <bakert> case newFunc $ getFunds bookie of
05:56:06 <bakert>     Nothing -> return False
05:56:12 <bakert>     Just funds -> return $ insertFunds
05:56:13 <bringert> @type maybe
05:56:15 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:57:09 <bakert> eek
05:57:15 <bakert> that is warping my brain.
05:57:32 <xerox> > maybe 31337 (^2) Nothing
05:57:34 <lambdabot>  31337
05:57:42 <xerox> > maybe 31337 (^2) (Just 10)
05:57:44 <lambdabot>  100
05:57:48 <bakert> ah!
05:57:52 <bakert> merci
05:58:06 <bringert> something like getFunds bookie >>= maybe (return False) (return . insertFunds bookie)
05:58:41 <xerox> maybe False (insertFunds bookie) `fmap` getFunds
05:58:42 <kowey> couldn't that return be factored out?
05:58:53 <bringert> yeah
05:59:15 <bakert> ah.  the dot pointfree thing.  i nearly get that.
05:59:28 <bakert> ooh xerox what on earth is that.  time for a read
05:59:55 <xerox> ?type fmap
05:59:57 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
06:00:05 <kowey> bakert: you know how map works, right?
06:00:05 <bakert> oh lord.  what's a Functor?
06:00:08 <bakert> kowey, yes
06:00:16 <xerox> use f = yourmonad
06:00:28 <xerox> (every monad is a functor, so no worries)
06:00:32 <kowey> fmap is just like map, except that you can use it on anything that is a functor
06:00:33 <bakert> map was in scheme and lisp and erlang and even python!  it's crazy nonsense like monads and functors that melt my brain.
06:00:46 <kowey> no need to worry about what a functor is, because you can think of it as anything you can apply fmap on
06:01:01 <bakert> cool.
06:01:17 <xerox> fmap f container maps f to each element of the container without messing with its shape
06:01:25 <kowey> so can you see what fmap on Maybe would look like?
06:01:42 <bakert> but i can't apply maybe to a single thing???
06:01:43 <xerox> s/maps/applies/
06:02:06 <kowey> oh wait, nevermind my question, irrelvant :-)
06:02:09 <xerox> maybe takes a default value for the Nothing case
06:02:12 <syntaxfree> fmap is a generalized map of sorts.
06:02:24 <xerox> and a function for the Just x case, to apply to x
06:02:25 <syntaxfree> really the basics of cat theory are simple.
06:02:59 <syntaxfree> there are categories, which are a bunch of things together with a bunch of arrows between those things, and a functor is an arrow in a category of categories.
06:03:02 <bakert> i get maybe.  fmap i'm not so sure.
06:03:09 <syntaxfree> then in Haskell you have types.
06:03:14 <Syzygy-> > (+3) `fmap` Just 2
06:03:16 <lambdabot>  Just 5
06:03:16 <xerox> bakert: try writing the implementation as kowey was suggesting
06:03:21 <syntaxfree> functions in haskell are arrows from types to types.
06:03:24 <Syzygy-> > (+3) `fmap` Nothing
06:03:26 <lambdabot>  Nothing
06:03:34 <kowey> bakert: imagine you wanted a function like map, only for maybe
06:03:35 <syntaxfree> functors take types to types and arrows to arrows.
06:03:38 <kowey> call it maybeMap
06:03:44 <syntaxfree> so, um, [] is a functor.
06:04:09 <kowey> bakert: how would you implement maybeMap?
06:04:15 <syntaxfree> it takes a to [a], and a->a to (a->a->[a])
06:04:25 <syntaxfree> to apply the functor to a given arrow, you use fmap.
06:04:42 <bakert> kowey, that's what i don't get.  what is a "function like map for maybe".  map takes a function and applies it to everything in a list.  maybeMap would take a function and apply it to the result of a maybe???  that's just a function isn't it???
06:04:45 <AWizzArd> Moin
06:05:02 <syntaxfree> Maybe a can be Just a or nothing.
06:05:18 <bakert> right ... i get Maybe and I get maybe.  I hope.
06:05:19 <syntaxfree> fmap f (Maybe a) probably goes to Just f or Nothing.
06:05:23 <kowey> bakert: yep... the trick is to unlearn the idea that map is neccesarily about lists (that took me a while)
06:05:24 <Syzygy-> bakert: Not quite. It's a function that handles the different values Maybe can have.
06:05:25 <syntaxfree> er, Just (f a)
06:05:31 <syntaxfree> that's the natural fmap for me anyway.
06:05:41 <kowey> bakert: so look, what would maybeMap Nothing do?
06:05:51 <bakert> Nothing?
06:06:05 <kowey> exactly, because you don't want to change the shape of the Maybe, right?
06:06:11 <bakert> right.
06:06:15 <kowey> so now what about mapMaybe f (Just x)?
06:06:18 <xerox> bakert: what type has fmap for f = Maybe ?
06:06:55 <bakert> kowey, it can't be "f (Just x)" because that's the same as if there were no maybeMap but I don't know what else to say.
06:07:16 <kowey> right... you want to give back a Just, because you got a Just
06:07:23 <kowey> just like map on lists gives back a list...
06:07:39 <xerox> That information is really in the type, start from there.
06:07:46 <pjd> syntaxfree: i think i get how [] takes a to [a], but how does it take a->a to (a->a->[a]) ?
06:07:53 <kowey> map f [1,2,3] gives me [f 1, f 2, f 3]; so what would mapMaybe f (Just 1) give?
06:08:08 <bluestorm> so mapMaybe is a particular kind of fmap ?
06:08:08 <bakert> Just (f 1)???
06:08:10 <xerox> I think there's no need to guess.
06:08:26 <kowey> bakert: exactly, so what would mapMaybe f (Just x) look like?
06:08:33 <bluestorm> (what's the exact syntax of fmap btw ?)
06:08:47 <bakert> Just (f x)
06:08:49 <bakert> !
06:09:08 <kowey> bakert: so you see you've got a map, which works on lists, and a mapMaybe that works on Maybe
06:09:21 <kowey> and you can imagine that there would be many map-like functions for lots of different things, right?
06:09:36 <bakert> I see.  So it kind of puts the function "inside" the Maybe and leaves it on the outer layer so the type of my answer is unchanged to the type of the input.
06:09:54 <kowey> and all fmap does is to generalise over both kinds, all kinds of map-like function
06:10:02 <kowey> this will become clearer when you learn more about typeclasses
06:10:13 <bakert> i get it!  (i think!)
06:10:22 <pjd> bakert: do you know the monad laws?
06:10:43 <syntaxfree> I think the better way to do this is to try and grok functors, and realize functors in Haskell are a type constructor together with a fmap function.
06:10:55 <bakert> pjd, no.  well, i am now successfully using monads after some tears but it's still a bit trial and error rather than deep understanding.
06:11:19 <bakert> syntaxfree, my bet is you are a mathematician of some sort.  i have a gcse in maths.
06:11:25 <xerox> Write your own "instance Functor Maybe where ..." and you will understand.
06:11:26 <syntaxfree> I'm an economist.
06:11:38 <pjd> bakert: it might be useful to play around with the laws
06:11:40 <syntaxfree> I wish someone would write that on the channel topic
06:11:46 <syntaxfree> "syntaxfree is an economist"
06:12:14 <bakert> do you get asked a lot?!
06:12:15 * allbery_b is no math-head, but groks generalized map
06:12:55 * Syzygy- is here because I -am- a math-head. :P
06:13:18 <dylan> hmm, is it sane log debug messages to a database table?
06:13:30 <allbery_b> it can be
06:13:55 <Syzygy-> Functors are things commuting with maps - so you can do things like for instance f (Just 3) =>= Just (f 3). The -way- you do this in Haskell, though, is using fmap.
06:14:15 <allbery_b> it can also be a really bad idea (say, if you're processing hundreds of transactions a second, that'll do bad things to your overhead)
06:14:23 <syntaxfree> I got attracted into Haskell because of the mathiness.
06:14:33 <Syzygy-> I'd have written it like F (f x) = f (F x) when thinking about categories...
06:14:43 <bakert> yeah my boss is a mathematician and he is the one that got me started.
06:14:44 <syntaxfree> I actually found out about Haskell upon stumbling into "Theorems for free".
06:14:48 <bakert> that and programming.reddit.com
06:14:53 <syntaxfree> Of which I understood nothing, mind you.
06:14:59 <syntaxfree> But found fascinating anyway.
06:16:21 <syntaxfree> methinks trying to hide away the mathiness takes away a lot of the fun as well
06:17:00 <bakert> it's not so much the mathiness that i can't get, it's the mathy explanations of the mathiness that sometimes trip me up!
06:17:24 <bakert> still, 10 days ago i had no idea about any of it and here i am being paid to write haskell.  it's all good.
06:17:50 <bluestorm> hum
06:17:59 <Itkovian> any ghc-6.6 available for gentoo?
06:18:32 <syntaxfree> you don't need to grok much actual maths to get mathiness.
06:18:35 <bluestorm> think at all the people that would do anything to be paid to write haskell bakert :p
06:18:57 <bakert> bluestorm, all you need for that is a programming job and an ok boss.
06:19:06 <bakert> then just write your next program in haskell.
06:19:13 <bakert> that's what i'm doing.
06:19:53 <bakert> (although my boss is a mathematician and thinks haskell may well be the answer to the world's prayers, although hasn't actually written anything in it for the company)
06:19:56 <Syzygy-> Itkovian: Via an overlay, yeah.
06:20:10 <Syzygy-> Itkovian: Get yourself layman, add the haskell overlay, and then check out the ghc from there.
06:20:44 <Syzygy-> You'll need to generate the manifests for the things though - those aren't generated in the overlay.
06:21:03 <syntaxfree> Syzygy: gah, isn't ./configure && make && make install much simpler than that?
06:21:26 <Syzygy-> syntaxfree: It is, but doesn't give you the package management, easy uninstall and reasonably easy updates.
06:21:40 <Syzygy-> Besides, using layman is something that you'll get a lot of benefits from anyway on a gentoo box.
06:21:52 <BCoppens> debian unstable has 6.6, and has packagemanagement ;)
06:21:54 * syntaxfree can't get bothered with package management.
06:22:12 <Syzygy-> And I really, really, REALLY, REALLY don't want to get into a shouting match about distros.
06:22:15 <syntaxfree> I tried using Fink for a while, but eventually found myself better off just installing the damn thingies.
06:22:18 <Syzygy-> The original question was for gentoo.
06:22:25 <Syzygy-> So I answer adapted to gentoo.
06:22:47 <BCoppens> which is why I only answered after saying that ./configure is simpler ;)
06:22:56 <BCoppens> +somebody
06:23:08 <syntaxfree> I'm not "somebody", I'm syntaxfree.
06:23:21 <BCoppens> syntaxfree: indeed you are
06:23:29 <vincenz> everybody is somebody
06:23:44 <wolfgangbeck> and building ghc-6.6 from source works without trouble?
06:23:52 <bluestorm> hmm, isn't everybody a set of somebody ?
06:23:53 <Itkovian> let's find out, eh
06:23:55 <syntaxfree> but I'm not just "somebody", I'm like the center of the world.
06:23:57 <BCoppens> vincenz: as long as it's not the other way arou,d it's ok with me ;)
06:24:01 <syntaxfree> of the universe, even.
06:24:13 <vincenz> syntaxfree: everybody is the center of the univeres
06:24:14 <Itkovian> BCoppens: shouldn't you be studying?
06:24:20 <BCoppens> Itkovian: uhm, yes ;)
06:24:26 <vincenz> Itkovian: ooh, is that the phd student beating down on his master student?
06:24:38 <BCoppens> Itkovian: don't you see I'm very busy studying? ahem ;)
06:24:38 <Itkovian> he's not my master student
06:24:43 <vincenz> :P
06:24:43 <Itkovian> I'm ill at home
06:24:47 <vincenz> Oh :/
06:24:49 <BCoppens> :(
06:24:51 <Itkovian> running to the toilet on a regular basis
06:24:57 <vincenz> Then don't stay home if you're ill at home
06:25:05 <syntaxfree> oh. too much information.
06:25:29 <vincenz> Itkovian: I had that on the 27th, couldn't even keep in tea
06:25:41 <BCoppens> :/
06:25:51 <Itkovian> I managed to keep everything down so far, though this morning it was kinda hairy
06:25:54 <vincenz> stomach flue
06:26:09 <vincenz> fortunately I had booked another ticket to spend more time with my parents, cause supposedly I was flying that day
06:26:16 <syntaxfree> ltkovian: tea and cream crackers are the best for that.
06:26:28 <vincenz> Itkovian: toast and tea
06:26:41 <bigbigdog> :)
06:27:13 <Itkovian> toast and golden syrup
06:27:15 <Itkovian> mmmm
06:27:42 <syntaxfree> I keep getting these spams from a company that sells Strawberry Prolog.
06:27:48 <Itkovian> is it me, or does the ghc-6.6-unknown-linux.tar.bz2 tarball not contain a ghc-6.6 binary?
06:28:06 <syntaxfree> The other day I went to the fridge and stared at a jar for many many seconds, thinking..
06:28:21 <syntaxfree> "Oh damn, if I had learned Prolog I could have some of this nice jelly."
06:28:25 <Itkovian> ah
06:28:27 <Itkovian> in the lib dir
06:28:29 <Itkovian> duh
06:30:36 <allbery_b> vanilla prolog wasn't good enough for them?  so why didn't they go all the way and make chocolate prolog?
06:31:20 <syntaxfree> my head is screwed up.
06:31:26 <pjd> bakert (re. fmap earlier): for me it was very useful to learn how fmap relates to the other monadic operations (join, bind, return)
06:32:48 <bakert> pjd, thanks i'll have a look at those.  i'm still trying to wrap my head around this one.
06:32:51 <pjd> specifically, you can always define >>= in terms of join/fmap, and vica versa
06:32:59 <pjd> m >>= f  =  join (fmap f m)
06:33:19 <pjd> and: fmap f m  =  m >>= (return . f)
06:33:34 <bakert> goddamn, is that right?  i only met ">>=" about an hour ago and it's that side of things ("binding"?) that is screwing me up currently
06:33:37 <pjd> and for completeness: join m  =  m >>= id
06:34:03 <Andris> today I had an idea to implement fmap generically, until I understood that Data type class insists on the whole type being Data
06:34:24 <Andris> so instance Data (f a) => Functor f does not really make sense :(
06:34:34 <pjd> bakert: yeah, >>= is bind
06:35:02 <Andris> any research on something like Data, but for typecons?
06:35:49 <Syzygy-> ?type (>>=)
06:36:05 <lambdabot> thread killed
06:36:11 <vincenz> life's good
06:36:29 <Syzygy-> Is bind the monadic operation from category theory? Or what is that called?
06:36:40 <Syzygy-> ?hoogle m(m a) -> m a
06:36:42 <lambdabot> Prelude.id :: a -> a
06:36:42 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:36:42 <lambdabot> Prelude.asTypeOf :: a -> a -> a
06:38:47 <pjd> bakert: not sure if this will help, but one way i like to think about bind (>>=) is as a function application with inverted control
06:39:00 <bakert> pjd, !!!
06:39:06 <pjd> in stead of giving the value to the function, you give the function to the value
06:39:17 <ski> :t join
06:39:19 <bakert> pjd, ah i see.
06:39:19 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
06:39:33 <Syzygy-> Right.
06:39:35 <pjd> where the value is monadic; it controls how the function is applied to itself
06:39:56 <Syzygy-> > join (Just Nothing)
06:39:58 <lambdabot>  Add a type signature
06:40:02 <therp> does anyone know an implementation of http://lambda-the-ultimate.org/node/112 that is available and recent? (Prolog embedded in Haskell)
06:40:03 <lambdabot> Title: Embedding Prolog in Haskell | Lambda the Ultimate
06:40:09 <Syzygy-> > join (Just Nothing) :: Maybe Int
06:40:13 <lambdabot>  Nothing
06:40:15 <pjd> have you used callbacks in event-based programming?
06:40:23 <Syzygy-> > join (Just Just 3)
06:40:24 <pjd> it's reminiscent of that
06:40:24 <lambdabot>      The function `Just' is applied to two arguments,
06:40:25 <lambdabot>     but its type `a -> ...
06:40:31 <Syzygy-> > join (Just (Just 3))
06:40:33 <lambdabot>  Just 3
06:41:16 * chibeaver says hello
06:41:37 <ski> therp : maybe http://citeseer.ist.psu.edu/claessen00typed.html helps ?
06:41:39 <lambdabot> Title: Typed Logical Variables in Haskell - Claessen, Ljungl (ResearchIndex)
06:41:52 <bigbigdog> hello
06:42:27 <ski> (therp : btw, i'm working on such an embedding right now .. but with extra features)
06:42:56 <therp> ski: nice. Do you know norvig's work for common lisp on embedding prolog?
06:43:21 <pjd> bakert: for example, say you have a simple function:  double = (*) 2
06:43:41 <bakert> yep
06:44:00 <ski> therp : no
06:44:03 <pjd> to apply that to a normal value, you say double x
06:44:16 <bakert> right
06:44:46 <Syzygy-> Is there some standard way to commute monads with each other?
06:44:58 <Syzygy-> Say m and n are monads, I want a function m (n a) -> n (m a)
06:45:07 <AWizzArd_> question about currying: if I have a 5-ary function foo and want to curry away the fourth parameter, how would I do that?
06:45:25 <Syzygy-> AWizzArd_: Use a lambda expression would be my guess.
06:45:58 <therp> ski: I'm aiming to automate the embedding step for my lisp-variant of Haskell.. that's why I'm searching for an underlying implementation, as it was obviously done already
06:46:04 <AWizzArd_> ok, so built in currying is targeted mostly at 2-ary functions for which one can curry the first arg
06:46:09 <pjd> to "apply" it to a monad, you switch them around and say x >>= double
06:46:17 <ski> Syzygy- : mayhaps 'Data.FunctorM.fmapM id' ?
06:46:24 <bakert> bar = (\a, b, c, d -> foo a b c 777 d)???
06:46:35 <pjd> (which is not correct, but it's the general idea)
06:46:43 <amiddelk> Syzygy-: that should not be possible in general, consider IO (Maybe Int) and Maybe (IO Int)
06:47:14 <bakert> bar x = (\a, b, c, d -> foo a b c x d) -- i mean
06:47:17 <Syzygy-> amiddelk: Good point. Though for at least some stricter monads, it shouldn't be a problem.
06:47:26 <Syzygy-> And fmapM id seems to be accurate.
06:47:26 <bakert> pjd, i see
06:47:31 <bakert> pjd, thanks
06:47:56 <pjd> bakert: the only further difference/catch is that the argument to >>= has to return a monad as well, instead of just a plain value
06:48:02 <ski> Data.FunctorM.fmapM id :: (Data.FunctorM f,Monad m) => f (m a) -> m (f a)
06:48:27 <ski> therp : hm .. i don't see the relation to logic programming ..
06:48:53 <bakert> pjd, right.  gotcha.
06:49:01 <pjd> so in general double x would "monadize" into x >>= return . double
06:49:18 <ski> actually
06:49:54 <ski> Data.Traversable.sequenceA :: (Traversable t,Applicative f) => t (f a) -> f (t a)
06:49:59 <pjd> which is the same as: x >>= \x -> return (double x)
06:50:06 <therp> ski: it's not about logic programming, it's about easying language embedding by meta-programming.
06:50:19 <Syzygy-> pjd: Or for that matter (`fmap` double)
06:50:27 <ski> Syzygy- : does that help ?
06:50:32 <pjd> Syzygy-: right
06:50:45 <ski> therp : oh
06:51:01 <Syzygy-> ski: I find it easier to read - though it probably was the wrong way around...
06:51:23 <Syzygy-> Or .. wait .. for Traversable? Not certain - fmapM id was more to the point.
06:51:46 <pjd> bakert: the point of all that is that now the monadic value in a sense "controls" the function, instead of vica versa
06:52:12 <ski> Data.Traversable.traverse id
06:52:14 <ski> if you like
06:52:36 <pjd> so the Maybe monad, for example, will only apply the function to itself if it doesn't contain Nothing
06:52:51 <bakert> pjd, i see.
06:53:01 <ski> > Nothing >>= (\x -> return (2*x))
06:53:03 <lambdabot>  Nothing
06:53:07 <pjd> and the list monad will apply the function to all its values
06:53:08 <pjd> and so on
06:53:10 <ski> > Just 7 >>= (\x -> return (2*x))
06:53:11 <lambdabot>  Just 14
06:53:16 <ski> > [] >>= (\x -> return (2*x))
06:53:18 <pjd> the function doesn't need to know about any of that
06:53:18 <lambdabot>  []
06:53:22 <ski> > [3,5,6] >>= (\x -> return (2*x))
06:53:23 <Syzygy-> > [3,4,5] >>= (\x -> return (2*x))
06:53:24 <lambdabot>  [6,10,12]
06:53:25 <lambdabot>  [6,8,10]
06:53:46 <Syzygy-> > [Just 3, Just 5, Nothing, Just 8] >>= (\x -> return (2*x))
06:53:47 <lambdabot>   add an instance declaration for (Num (Maybe a))
06:53:55 <ski> heh
06:53:58 <Syzygy-> > [Just 3, Just 5, Nothing, Just 8] >>= (\x -> return (fmap (2*x)))
06:54:00 <lambdabot>      Expecting a function type, but found `a'
06:54:00 <lambdabot>       Expected type: a -> b
06:54:00 <lambdabot>    ...
06:54:10 <Syzygy-> Oh bugger.
06:54:21 <ski> > mapM (\x -> return (fmap (2*x))) [Just 3, Just 5, Nothing, Just 8]
06:54:22 <lambdabot>  Couldn't match `a -> b' against `Maybe a1'
06:54:31 <ski> > mapM (\x -> return (2*x)) [Just 3, Just 5, Nothing, Just 8]
06:54:32 <lambdabot>   add an instance declaration for (Show (m [Maybe a]))
06:55:05 <Syzygy-> > fmap (fmap (*2)) [Just 3, Just 5, Nothing, Just 8]
06:55:07 <lambdabot>  [Just 6,Just 10,Nothing,Just 16]
06:55:19 <ski> > mapM (>>= (\x -> return (2*x))) [Just 3, Just 5, Nothing, Just 8]
06:55:20 <lambdabot>  Nothing
06:55:42 <ski> > mapM (>>= (\x -> return (2*x))) [Just 3, Just 5, Just 8]
06:55:44 <lambdabot>  Just [6,10,16]
06:57:22 <bigbigdog> good night
06:58:47 <ski> > sequence [Just 3, Just 5, Just 8] >>= \x -> return (2*x)
06:58:49 <lambdabot>   add an instance declaration for (Num [a])
06:59:37 <xerox> > fmap (*2) `fmap` sequence [Just 3, Nothing, Just 5]
06:59:39 <lambdabot>  Nothing
06:59:48 <xerox> > fmap (*2) `fmap` sequence [Just 3, Just 5, Just 8]
06:59:49 <shapr> @users
06:59:50 <lambdabot>  Just [6,10,16]
06:59:50 <lambdabot> Maximum users seen in #haskell: 296, currently: 288 (97.3%), active: 39 (13.5%)
07:00:15 <ski> xerox,shapr : hiya
07:00:19 <xerox> Yow.
07:00:22 <shapr> hej ski, god morgon!
07:00:54 <shapr> Oj, I think I'm going back to sleep.
07:00:59 <ski> hehe
07:01:17 <JKnecht> are you the ski from #prolog?
07:01:19 * ski ska kanske ta andra frukosten, snart
07:01:24 <ski> JKnecht : indeed
07:01:24 <shapr> heh
07:02:34 * ski thinks he could use a 'Unique' for 'ST' ..
07:03:53 <kowey> bakert: it sounds like you need a proper monad tutorial; the community have produced many fine variants on the theme
07:04:08 * chibeaver says hello
07:05:04 <maskd> hi
07:05:44 <bakert> kowey, yeah i've read 1 or 2.  i will get on top of it shortly.  i liked the one about monsters.
07:06:19 * ski grins
07:08:01 * chibeaver says hello
07:10:11 <arjanb> hi chibeaver
07:14:56 <Azmo> threadDelay does not seem to be an "interruptible operation", shouldn't it be?
07:34:02 <glguy> looks like a slow morning
07:35:15 <Azmo> morning? :o
07:35:51 <vegai> and quite warm
07:35:51 <glguy> yup, I mold the time of day everywhere in the world to match my preception
07:43:37 <glguy> back from reboot.. when your tab key stops working, and enter refuses to submit forms, you know you haven't rebooted recently enough
07:44:56 <chessguy> wb, glguy
07:45:04 <glguy> :)
07:45:08 <chessguy> @localtime glguy
07:45:11 <lambdabot> Local time for glguy is Fri Jan  5 09:38:02 2007
07:45:22 <Azmo> glguy: what OS would that be?
07:45:25 <chessguy> an hour behind, not too bad
07:46:08 <glguy> Azmo: XP
07:46:16 <glguy> it had a good run though
07:46:23 <glguy> was probably up for a month
07:47:35 <chessguy> practically an eternity for XP
07:47:54 <glguy> when I rebooted, there were 6 applications that had to be force-quited
07:48:13 <chessguy> lol
07:48:16 <glguy> I usually try to clean up stuff like that, but I guess those slipped past me
07:48:44 <glguy> VS2005 loves to leave devenv.exe's running after I close it, so I know to look for that
07:52:45 <dylan> Bulat refers to functions as methods?
07:53:43 <glguy> link?
07:53:45 <Syzygy-> Yikes
07:53:52 <Syzygy-> I gotta get back to reading the cafe!
07:55:52 <dylan> Subject: Re: [Haskell-cafe] Redefining superclass default methods in a subclass
07:56:08 <glguy> I guess that it is too new for the archive?
07:56:34 <dylan> perhaps.
07:57:34 <Tanuk-> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/18137/focus=18137
07:57:37 <lambdabot> Title: Gmane Loom, http://tinyurl.com/y5e5ed
08:05:38 * ski 's noted this problem, as well
08:08:00 <glguy> this is a much nicer interface than the archive link from haskell.org
08:08:03 <ski> could someone note http://repetae.net/john/recent/out/supertyping.html on that thread ?
08:08:05 <lambdabot> Title: Supertyping Suggestion for Haskell
08:11:23 <dvekravy> hi, are there any problems with HGL on windows? I'm using only events and drawing (lines and ellipses)..
08:29:16 <glguy> I'm reading through one of the archive threads, and every time Bulat ends each of his sentence with a :) or ;) (just about every one) I want to punch him in the smiley
08:33:35 <Jaak> @src unfoldr
08:33:36 <lambdabot> unfoldr f b  = case f b of
08:33:37 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:33:37 <lambdabot>    Nothing        -> []
08:34:07 <notsmack> huh, didn't know about src
08:34:16 <notsmack> @src map
08:34:16 <lambdabot> map _ []     = []
08:34:17 <lambdabot> map f (x:xs) = f x : map f xs
08:35:05 <AStorm> Blah, I get to convert all SMTP syntax to Parsec :/
08:38:32 <ski> @src undefined
08:38:33 <lambdabot> undefined =  error "Prelude.undefined"
08:38:39 <ski> @src id
08:38:40 <lambdabot> id x = x
08:38:53 <ski> @src main
08:38:54 <lambdabot> Source for this function is not available.
08:39:46 <notsmack> ?type undefined
08:39:49 <lambdabot> forall a. a
08:40:16 <glguy> ?type let x = x in x
08:40:18 <lambdabot> forall t. t
08:45:11 <seliopou> ?docs Data.Sequence
08:45:12 <lambdabot> Data.Sequence not available
08:51:56 <Jaak> @pl id x = x
08:51:57 <lambdabot> id = id
08:58:19 <xic> > pi
08:58:23 <lambdabot>  3.141592653589793
08:58:28 <glguy> ?src pi
08:58:28 <lambdabot> Source for this function is not available.
08:58:45 <xic> > e
08:58:46 <lambdabot>   Not in scope: `e'
08:59:08 <xic> > let f 3.14 = "oh yeah" in f 3.14
08:59:10 <lambdabot>  "oh yeah"
08:59:17 <xic> > let f pi = "oh yeah" in f pi
08:59:19 <lambdabot>  "oh yeah"
08:59:48 <xic> > let f pi = "oh yeah" in f 1
08:59:50 <lambdabot>  "oh yeah"
09:05:49 <malebria> xic: this is not pi.
09:06:00 <malebria> xic: he is considering that pi is in the local scope.
09:06:09 <malebria> > let f 3.14 = "oh yeah" in f 1
09:06:11 <lambdabot>   Non-exhaustive patterns in function f
09:06:23 <xic> malebria: yeah, i understand what's going on
09:06:28 <malebria> xic: ok.
09:09:24 <LPhas> http://catenova.org/~phas/doc/hid3/index.html <- lib for reading mp3 tags :D
09:12:29 <bakert> nice one LPhas
09:12:42 <LPhas> thx :D
09:12:50 <LPhas> i hope to patch hmp3 now
09:13:04 <seliopou> is this id3v1 or id3v2?
09:13:04 <LPhas> and then i want to bind libgpod ...
09:13:11 <LPhas> both
09:13:57 <bakert> i do like to see some practical haskell ... gives me hope that i'm going to be able to write my database-interacting, internet-scraping system, SOAP-using system that i started this week.
09:14:34 <seliopou> This is a pretty high level interface
09:15:26 <LPhas> my?
09:15:53 * seliopou darcs gets
09:17:48 <ClaudiusMaximus> how would i go about interface C and Haskell code, where the C has a linked list structure, and i would like to have a Haskell list?
09:18:01 <ClaudiusMaximus> *interfacing
09:18:02 <metaperl> unfortunately practical haskell is almost an oxymoron. This is the most elegantly crafted language. But the hardest to get anything done in
09:18:47 <ndm> I use Haskell in practice
09:19:31 <ndm> the other day i actually got paid for writing Haskell code to do a task, was very nice :)
09:19:40 <Philippa> heh
09:19:42 <Templar2> what is dot called? (the haskell function " . "  )
09:19:48 <glguy> compose
09:19:51 <Templar2> ty
09:20:02 <ndm> Templar2: i call it dot, as it happens
09:20:19 <Templar2> aha, ok =)
09:20:56 <LPhas> ClaudiusMaximus : you can access manually the list trougth C pointers
09:21:11 <LPhas> for accessing the members of a datastruct
09:21:14 <LPhas> i used hsc2hs
09:21:25 <metaperl> ndm - take the thread on default arguments about a week ago... there is no "Effective Haskell Programming" book which covers that and other common software engineering situations
09:21:50 <ndm> metaperl: default arguments aren't something in C# either, they aren't exactly commonly required either
09:23:03 <bos31337> metaperl's point still obtains.
09:23:11 <metaperl> remains
09:23:21 <ndm> metaperl: correct, there does need to be a Haskell in practice book
09:23:36 <ndm> but i think i now have sufficient knowledge that if it existed i probably wouldn't bother reading it
09:23:42 <ndm> therefore, for me, I can use Haskell in practice
09:23:45 <bos31337> no, i meant "obtains" :-)
09:23:54 <metaperl> dons' blog posts are a move in the right direction, but when mapM_ is required for what is the very first example in "Learning Perl", you've got problems :)
09:24:18 <Templar2> Im trying to learn how compose works and in the book they are using "mapSet" to describe it. But can anyone describe what mapSet dose?
09:24:28 <metaperl> i think there need to be some more practical examples of typeclasses and data construction and validation
09:24:28 <waern> metaperl, what's wrong with mapM_?
09:24:29 <ndm> @hoogle mapSet
09:24:29 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
09:24:30 <lambdabot> Data.Set.mapSet :: (Ord a, Ord b) => (b -> a) -> Set b -> Set a
09:24:42 <metaperl> waern - it's advanced stuff... monad stuff...
09:24:45 <ndm> waern: its more scary than a for loop, by far
09:24:55 <waern> well... :)
09:25:09 <bos31337> @hoogle mapM_
09:25:10 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
09:25:11 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
09:25:32 <ndm> i only became comfortable with using monads in the last year, and still can't define them
09:26:09 <metaperl> Haskell is actually an easier language to program in ... especially with arrows, because all you have to do is go find all the routines which match up with the output arrow using Haddock and what you need has to be there
09:26:45 <metaperl> Hoogle and Haddock are "forcing functions" on what is available in your programming
09:26:48 <emu> forM_ = flip mapM_
09:26:53 <emu> happy? =)
09:26:55 <astrolabe> ndm: you're kidding right?
09:27:08 <ndm> astrolabe: about monads, no, not at all
09:27:21 <emu> blah, you jsut have to jump in and try it
09:27:37 <explicitjelly> well. I can *define* monads, I even succeeded in writing a simple one. Being comfortable with them is where I'm lacking :)
09:27:38 <emu> the implementations are really simple; i just based my monads on them
09:28:35 <astrolabe> ndm: but you are an uber-hacker!  I can define monads and have stacked them, and I'm only just not a newbie.
09:28:40 <takuan> has anybody ever been comfortable with monads?
09:28:58 <explicitjelly> good question.
09:29:01 <explicitjelly> maybe nobody has
09:29:05 <astrolabe> they aren't THAT bad
09:29:07 <ndm> astrolabe: i hack purely functional stuff in purely functional ways, there's a big difference :)
09:29:35 <explicitjelly> maybe we should just accept them as... good to have for tasks where they are wellknown.
09:29:44 <ndm> Hoogle 3 is written without any monads apart from IO at the top level
09:29:59 <ndm> Hoogle 4 is looking like it will be written without Monads, but with unsafePerformIO :)
09:30:03 <Igloo> ndm: And what part of a state monad isn't purely functional, hmm?  :-)
09:30:10 <explicitjelly> ndm, oh, I wish I would start incorporating more monads than IO at the top level in my programs.
09:30:27 <ndm> Igloo: oh, indeed it is, but its only recently i've got comfortable enough to use it (i used it 3 times today so far)
09:30:28 <glguy> Monadic code is still purely functional, no?
09:30:28 <emu> why unsafePerformIO
09:30:38 <emu> yes
09:30:58 <Philippa> glguy: yes, although it may describe thoroughly impure things
09:31:02 <Igloo> ndm: Defining them is easy if you just try to write type correct code rather than thinking about what it does, BTW
09:31:13 <glguy> but it's impelemented in a pure way
09:31:16 <ndm> emu: a neat data file serialisation and lazy reading technique i'm working on - which gives you high performance, lazy reading, cacheing and other goodness
09:31:28 <glguy> it's not some exception bolted into Haskell (other than the do-notation support)
09:31:30 <explicitjelly> Igloo, uuuhm.
09:31:32 <Philippa> glguy: FCVO "implemented". The part of IO that's in Haskell's pure...
09:31:34 <ndm> Igloo: yes, that i now get - but a year ago i'd have taken a day to struggle over a state monad
09:31:36 <astrolabe> monadic code is purely functional, but it has an imperative spirit somehow.
09:31:52 <ClaudiusMaximus> LPhas: thanks, i'll look into it, but i think it might be overkill at the present time (the header file has 642 lines with very few comments, and I only need to interface to around 10 structs at most)
09:31:57 <explicitjelly> Igloo, do you mean while implementing monads, or while using them?
09:32:03 <Igloo> ndm: Oh, err, you said "still can't define them"
09:32:10 <Igloo> explicitjelly: Implementing monads
09:32:21 <explicitjelly> Igloo, but I have to think about what they do while writing them?
09:32:29 <LPhas> ClaudiusMaximux: good luck then
09:32:32 <ndm> Igloo: yeah, still can't do that - i could implement the state monad but it makes my head hurt, and is already imoplemented
09:32:37 <LPhas> libid3 was totally uncommented
09:32:46 <LPhas> but it was little
09:33:03 <explicitjelly> let's see if I can find my counter monad
09:33:07 <Igloo> explicitjelly: You need to think while writing the datatype, but >>= you normally don't have to think about what's actually happening
09:33:08 <emu> i just read the ghc source for State.hs, it wasn't that long at all
09:33:34 <astrolabe> Ah, well they still make my head hurt.  I thought that was normal.
09:34:09 <Philippa> the usual implementations're a bit weird to read off
09:34:16 <explicitjelly> my Counter Monad: http://www.frodoid.org/stuff/Test.hs
09:34:19 <emu> one of the tutorials has sample implementations too
09:35:02 <LPhas> ClaudiusMaximux : by the way a CList a -> [a] isn't too difficoult to make
09:35:30 <monochrom> what is CList?
09:35:36 <astrolabe> There are a couple of nice monads in the SOE book that make it pretty clear how they work.
09:35:45 <chessguy> what's SOE?
09:35:53 <astrolabe> moment
09:35:55 <monochrom> Hudak's Haskell book
09:36:10 <chessguy> monochrom, doesn't help much
09:36:28 <astrolabe> http://www.haskell.org/soe/
09:36:30 <lambdabot> Title: Home Page
09:36:32 <explicitjelly> oh, I have Hudak's book, too
09:36:32 <chessguy> ty
09:36:33 <monochrom> Hudak's "The Haskell School of Expression"
09:36:38 <explicitjelly> I'm not far into it but I like it so far
09:37:04 <monochrom> Sorry, my notion of "help" differs from yours.
09:37:12 <explicitjelly> it explains monads, also? I feared it would not because it doesn't mention them *at all* when introducing IO
09:37:17 <chessguy> "Aimed at both beginning and advanced programmers"...sounds dangerous
09:37:39 <astrolabe> explicitjelly: not explaining them when it covers IO is all part of the plan
09:37:52 <LPhas> monochrom: well, PTr a
09:37:58 <explicitjelly> astrolabe, okay.
09:38:22 <astrolabe> haskell is aimed at both begining and advanced programmers, and is dangerous too.
09:38:35 <chessguy> no, just unsafe :)
09:39:12 <Saizan> how much is experimental the experimental DBMS inside HAppS?
09:39:39 <monochrom> I.e., if I ask "what is SCSI" and the reply is "Small Computer Serial Interface", I consider that useless information.  I find it more helpful to forget the expansion and tell me "a disk interface in Apple and highend PCs".
09:42:11 <monochrom> If 'a' is Storable, there is already a marshalling routine from CList a and length to [a].
09:42:18 <AStorm> Saizan, much experimental
09:42:20 <AStorm> :>
09:42:31 <explicitjelly> monochrom, I consider it most helpful when the reply *starts* with "It's an acronym for 'Small Computer Serial Interface'" and *proceeds* to explain what that is and how it's used.
09:42:47 <AStorm> monochrom, highend? ;-)
09:43:11 <Saizan> still usable? i'd like to not install mysql too :)
09:43:24 <chessguy> monochrom, and the difference here was, it was pretty clear from the context that it's a book, so just telling me the author wasn't nearly as helpful as pasting a link that desribes the book, as astrolabe did
09:44:29 <explicitjelly> and monochrom and chessguy, why the hell are you arguing about THAT.
09:44:44 <chessguy> arguing?
09:44:55 <chessguy> didn't intend it that way, sorry
09:45:04 <explicitjelly> I'm not a native english speaker. did I spell it wrong?
09:45:09 <explicitjelly> "argueing" looks wrong.
09:45:19 <explicitjelly> ah, ok, it wasn't about the spelling.
09:45:22 <chessguy> no, you spelled it right
09:45:35 <monochrom> I have been computing for over two decades, and I have found that names are more and more useless, very often the full name is a meaningless one conjured solely to give a meaningful acronym.
09:45:51 <AStorm> E.g. ATAPI :>
09:46:03 <bringert> or PCMCIA
09:46:22 <AStorm> PCMCIA is obsolete. It's called CardBus now
09:46:31 <AStorm> (the 32-bit version)
09:46:34 <explicitjelly> hmm. PCI, PCMCIA, SCSI, ISA, MCA, TCP/IP, SMTP, FTP, HTTP, DNS, ...
09:46:36 <chessguy> really? i thought it was just called PC cards
09:46:46 <explicitjelly> but, yes, I know what you mean.
09:46:53 <bos31337> cardbus is obsolete, too.
09:47:03 <monochrom> Sorry, I am an academic and I need the author's name the most, it's a handle to a whole world of information.
09:47:07 <AStorm> bos31337, so what? :>
09:47:09 <explicitjelly> bos31337, there's a successor to CardBus?
09:47:22 <chessguy> not everyone is an academic though
09:47:22 <bos31337> express cards :-)
09:47:35 <AStorm> express card == CardBus dummy
09:47:47 <explicitjelly> CardBus dummy?
09:47:51 <bos31337> no, astorm, they're not the same.
09:48:12 <AStorm> Well, you're right
09:48:15 <explicitjelly> so, what's new with express cards? are they PCI express?
09:48:19 <bos31337> why yes, i am :-)
09:48:23 <AStorm> USB2 and PCIEx
09:48:31 <AStorm> PCI-E
09:48:32 <AStorm> :P
09:48:34 <explicitjelly> ah.
09:48:40 <explicitjelly> nice.
09:53:42 <explicitjelly> I'm looking at my "Counter" monad code right now.
09:54:06 <explicitjelly> and it remember's me that monads aren't *that* hard.
09:54:20 <explicitjelly> "remembers" even
09:55:04 <bakert> reminds?
09:55:14 <explicitjelly> ah, yes. thanks.
09:55:29 <bakert> @localtime explicitjelly
09:55:31 <lambdabot> Local time for explicitjelly is Fri Jan  5 18:48:26 2007
09:55:39 <bakert> europe, somewhere
09:55:44 <explicitjelly> Germany
09:55:50 <bakert> aha.
09:55:54 <bakert> South or North?
09:55:58 <explicitjelly> South
09:56:01 <bakert> Munchen?
09:56:06 <explicitjelly> right
09:56:16 <bakert> :)
09:56:40 <bakert> (my deutch ist sehr terrible)
09:56:42 <explicitjelly> (you would have guessed Berlin if I had said North, right? ;) )
09:56:58 <bakert> i don't know.  but South is definitely munich
09:57:05 <explicitjelly> bakert, well, as you could see, my english does horrible things sometimes, too ;-)
09:58:37 <explicitjelly> althoug confusing "remembering" with "reminding" is new for me.
09:58:43 <explicitjelly> although even
09:59:09 <SyntaxNinja> y0
10:05:25 <Syzygy-> bakert: There is more to southern Germany than Munich, you know...
10:08:30 <bfulgham> Is there a way to add additional Include/Library search paths when building something via cabal?
10:08:38 <bfulgham> ... under Windows with GHC-6.6?
10:10:37 <Botje> (how) can you convince haskell to show more numbers of a double?
10:10:52 <Botje> hmm
10:11:08 <Botje> or maybe that's just the best accuracy it can get, nm
10:11:53 <Saizan> yeah it's the machine limit
10:13:47 <monochrom> bfulgham: is it ok to edit the cabal file? :)
10:15:05 <monochrom> In Numeric, showEFloat, showFFloat, showGFloat can show various numbers of digits.
10:17:29 <ClaudiusMaximus> LPhas++
10:17:38 <ClaudiusMaximus> hsc2hs is exactly what i need
10:17:44 <LPhas> :D
10:18:01 <bfulgham> monochrom:  Sure.  This is just for a local build.
10:18:42 <ClaudiusMaximus> > "c2hs" == "hsc2hs"
10:18:44 <lambdabot>  False
10:20:29 <LPhas> ?! lol
10:20:30 <lambdabot> Maybe you meant: . v
10:20:56 <LPhas> >"c2hs" > "hsc2hs"
10:31:02 <Igloo> Any French native speakers about?
10:32:30 <kowey> Igloo: a handful in #haskell.fr
10:41:08 <bfulgham> Got it --thanks.  'include-dirs' and 'extra-lib-dirs'.
10:42:59 <seliopou> Is there anybody around that could help me with a fuctional dependencies question?
10:44:33 <MarcWeber> Is there already a function of type :  m a -> (b -> [ m b ]) -> [m b] ? (similar to >>= but it should return a list of monads)
10:44:58 <MarcWeber> seliopou: Just put your question..
10:45:29 <seliopou> @hoogle (Monad m) => m a -> (a -> [m b]) -> [m b]
10:45:30 <lambdabot> No matches, try a more general search
10:46:02 <seliopou> :t concat . mapM
10:46:04 <lambdabot>     Expecting a function type, but found `b'
10:46:05 <lambdabot>       Expected type: (a1 -> m b) -> [[a]]
10:46:15 <seliopou> poo
10:46:19 <seliopou> :t mapM
10:46:21 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
10:46:29 <seliopou> Right...
10:46:32 <seliopou> Anyways
10:46:58 <seliopou> I'm pretty sure that this is really stupid mistake that I'm making
10:47:10 <seliopou> class Some class a b | a -> b
10:47:15 <seliopou> with a function cost :: b -> Double
10:47:27 <seliopou> I basically can't do that, right?
10:49:03 <seliopou> I just changed the class to:
10:49:07 <xerox> > const (1::Double)
10:49:08 <lambdabot>  Add a type signature
10:49:09 <xerox> :t const (1::Double)
10:49:11 <lambdabot> forall b. b -> Double
10:49:21 <seliopou> class SomeClass a b | a -> b, b -> a
10:49:22 <seliopou> and it works
10:49:54 <seliopou> xerox: that is cost, not const (if that was directed to me)
10:50:21 <xerox> D'oh.
10:50:22 <MarcWeber> seliopou: I'm not sure, either. But how should haskell decide wether to use implementation  instance Some _  A b or instance Some _  B b if cost only depends on type b?
10:51:23 <seliopou> Yeah, I think I see the problem
10:52:11 <MarcWeber> seliopou: But you can add another class class X a where cost :: a -> Double ...
10:54:08 <seliopou> Right, that doesn't do it for me, so I have to make it a one-to-one relation
10:54:13 <seliopou> thanks for your help
10:54:23 <malebria> @t swapMVar
10:54:24 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:54:35 <malebria> ?t swapMVar
10:54:36 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:54:43 <malebria> ?type swapMVar
10:54:45 <lambdabot> Not in scope: `swapMVar'
10:55:08 <malebria> swapMVar returns the new value or the old value?
10:55:18 <malebria> In GHC doc this is not especified.
10:56:40 <seliopou> it returns the old value
10:57:09 <malebria> seliopou: in GHC the whole doc about it is: Swap the contents of an MVar for a new value.
10:57:22 <seliopou> Check out the source
10:57:28 <malebria> seliopou: Wouldn't it be better if it explained more?
10:57:45 <seliopou> Indeed.
10:58:18 <malebria> seliopou: I'll report a bug in debian.
11:00:29 <glguy> m >>= k = MaybeT $ maybe (return Nothing) (runMaybeT . k) =<< m
11:01:49 <Cale> ugh, reddit is mind-numbingly stupid this morning
11:02:45 <thelsdj> yea not much there today
11:03:37 <Cale> I don't even have time or energy to write all the negative comments that I normally would.
11:05:45 <Cale> There's an article about graphic design which is at 104 points, and the only reason people seem to be modding it down at all is that it's a PDF.
11:05:51 <malebria> Is it an MVar right?
11:05:58 <malebria> Isn't it a MVar?
11:06:45 <glguy> Who are these people whose computers can't handle opening a PDF and who are not smart enough to glance at the url before they click on it, knowing that their computers can't handle a PDF?
11:07:34 <glguy> A PDF? *fuck* that's not going to have any flash ads, it'll probably be 2 column format black text on white.. how boring
11:07:43 <glguy> where are the tag clouds?
11:07:58 <glguy> how do I know what other people think?? no comments
11:08:17 <glguy> is it more than a page long? ugh, what is this, school?
11:09:59 <vegai> Cale: 104 points isn't that bad
11:10:35 <Cale> vegai: It's extremely high for something on programming reddit which has nothing to do with programming.
11:11:30 <vegai> web design has _nothing_ to do with programming?
11:12:03 <glguy> you might be thinking of art.reddit.com
11:12:25 <notsmack> vegai: True?
11:12:34 <vegai> notsmack: well, no
11:12:50 <glguy> We pay people to do a shitty job designing webpages so that the programmers don't have to
11:13:05 <vegai> aren't you happy today
11:13:17 <Cale> vegai: nothing!
11:13:19 <glguy> at least that's how it goes at my work
11:13:22 * notsmack is with Cale
11:13:24 <vegai> Cale: no, you're not correct
11:13:50 <notsmack> vegai: what's the relation?
11:13:57 <glguy> well.. that settles it then
11:14:26 <Cale> What does graphic design have to do with describing computations?
11:14:45 <Cale> They're completely orthogonal issues.
11:15:29 <seliopou> *ahem* STRAWMAN
11:15:35 <vegai> and is programming just describing computations?
11:15:41 * vegai shrugs.
11:15:43 <seliopou> that's the strawman
11:15:43 <Cale> Yes, it is.
11:15:46 <notsmack> vegai: seems to be
11:15:50 <seliopou> No, it's not
11:15:59 <chessguy_work> fight! fight! fight!
11:16:22 <notsmack> if your web programming contains graphic design, you've probably done something wrong
11:16:40 <Cale> notsmack: Yes!
11:17:03 <Cale> We have ways to cleanly separate graphic design from the description of structure and computation.
11:17:06 <vegai> Well, perhaps I was just a bit too pedantic on Cale's total separation
11:17:19 <vegai> Not something worth fighting for.
11:17:44 <seliopou> semantic arguments generally aren't worth fighting over
11:17:56 <Cale> The graphic design part can't really be considered programming. (Unless you consider things like writing a CSS document "programming".
11:17:57 <Cale> )
11:18:49 <glguy> ?quote pedant
11:18:50 <lambdabot> No quotes match. My mind is going. I can feel it.
11:18:55 <glguy> surprising, no?
11:19:45 <Cale> In any event, it, along with 90% of the other stuff that's posted there, isn't something I'd care to find on programming.reddit.com
11:19:46 <seliopou> What about GUI layout?
11:19:51 <glguy> is there a way to know that code in Cont exited via callCC instead of by completing the block?
11:19:56 <Cale> seliopou: Separate issue.
11:20:15 <Cale> The means of describing GUI layout are a programming issue.
11:20:21 <Cale> Actual GUI layouts are not.
11:20:24 * glguy makes some African Redbush Peach tea
11:20:49 <seliopou> When you design your GUI layout and code it up, are you describing a computation?
11:21:31 <Cale> I design my GUI layouts using a separate tool, and load them from XML files.
11:21:53 <bd_> glguy: What do you mean? If the code exits by callCC, it'll skip to the return of callCC...? You could return a flag value...
11:22:07 <Cale> But even if I was to hard code them
11:22:20 <Cale> there's a difference between the design phase and the programming phase of that
11:22:29 <vegai> glguy: hey, I used the word correctly this time :P
11:22:46 <Cale> As a programming problem, GUI development using a particular library is completely uninteresting
11:23:01 <Cale> (well, almost)
11:23:12 <seliopou> That it is uninteresting is not the issue
11:23:15 <glguy> vegai: I was just looking for quotes about pedants being pedantic
11:23:20 <Cale> As a design problem, it's much more interesting, but it's not a programming issue at that point.
11:23:26 <glguy> > "pedant" `isPrefixOf` "pedantic"
11:23:28 <lambdabot>  True
11:23:28 <Cale> It's a graphic/UI design issue.
11:23:43 <Cale> There should be a separate reddit for it :)
11:24:27 <Cale> If you want to talk about the design aspects of UI development, you're not talking about programming anymore.
11:24:45 <vegai> web.reddit would make sense
11:24:59 <Cale> yes
11:25:09 <Cale> there is a Web 2.0 reddit at least
11:25:17 <malebria> I'm trying to find doc about unsafePerformIO. GHC mannual explains it well, but I don't understand when it should be used.
11:25:24 <glguy> ?quote programming
11:25:25 <lambdabot> lispy says: one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
11:25:33 <Cale> malebria: It shouldn't be used unless your first name is Simon
11:25:37 <notsmack> the set of "things programmers sometimes think about" isn't equivalent to the set of "things related to programming"
11:26:30 <monochrom> I should post some Bach and Mozart thingies to programming.reddit.com
11:26:37 <malebria> Cale: I'm reading darcs code and I wanted to understand why they used it, that's why I was search when I should use it.
11:26:43 <Cale> ah, okay
11:26:58 <Cale> Well, it allows you to execute an IO action as part of the evaluation of an expression.
11:27:18 <vegai> monochrom: so what stops you? :)
11:27:31 <monochrom> I despise reddit.com
11:27:53 <Cale> This basically allows evaluation of a particular expression to do anything that you want.
11:28:03 <malebria> hum...
11:28:14 <Cale> Usually, it's best to ensure that the execution of that IO action is actually referentially transparent.
11:28:24 <monochrom> I now have a better idea.  Everyday I post a program correctness proof to programming.reddit.com.  So what if people mod it down or insult me.
11:28:27 <vegai> monochrom: so much that you won't even corrupt it?
11:28:39 <malebria> Cale: the examples I've seen till now is creating an MVar and an IORef.
11:28:40 <vegai> indeed, so what?
11:28:53 <monochrom> But it may be a waste of time.
11:28:57 <Cale> malebria: okay, those are examples where it really should not be done
11:29:02 <ClaudiusMaximus> malebria: i've been reading http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/unix/System/Posix/Files.hsc?rev=1.11.2.2;content-type=text%2Fplain where unsafePerformIO is used to read from Foreign memory
11:29:05 <lambdabot> http://tinyurl.com/y34lk3
11:29:11 <Cale> malebria: essentially, it's being used to create a global mutable variable
11:29:25 <monochrom> And the proofs may also happen to be solutions to homework in courses.
11:29:40 <malebria> Cale: this could be done without unsafePerformIO.
11:29:54 <malebria> Cale: one of them is in darcs code.
11:30:12 <Cale> malebria: Well, you couldn't create a global mutable variable, but then again, the fact that you're using one is a design flaw.
11:30:30 <malebria> Cale: ok, a global one..
11:30:34 <malebria> Now I got it.
11:30:57 <malebria> It's strange cause it uses it only once.
11:38:53 <malebria> No, I was wrong, it's not used only once.
11:42:14 <chr1s> g'day all
11:42:42 <chr1s> would it be possible to make my program multithreaded in the current GHC?
11:42:50 <monochrom> Yes.
11:42:57 <chr1s> is that easy?
11:43:13 <monochrom> But by that I mean you call forkIO to create threads.
11:43:51 <chr1s> hm
11:44:15 <chr1s> do you know if there's any work being done on automatic threading?
11:44:46 <chr1s> for example, I've got a computation on a very large tree (syntax tree of a program)
11:45:07 <monochrom> Control.Parallel and Control.Parallel.Strategies may offer some automation.
11:45:27 <chr1s> which is defined using catamorphisms, which should not be too hard to make threaded
11:45:34 <chr1s> ok, thanks
11:46:43 <Cale> Is par working though?
11:47:07 <monochrom> Yes.  Compile with -threaded.
11:48:11 <monochrom> I miss GPH.  But then again at present I don't have access to a room of computers.
11:49:31 <monochrom> I used to dream of implementing a multiple polynomial quadratic sieve in GPH, then harnassing the school's computer lab to do criminal things for me!  Bwhahahahaha...
12:00:32 <malebria> Ins't there a wiki written in haskell?
12:00:55 <metaperl> malebria - Flippi
12:01:04 <metaperl> malebria by our very own Phillipa Cowderoy
12:01:13 <metaperl> who said women couldnt code their ass off?
12:01:31 <malebria> metaperl: so why it's not used in haskell wiki and darcs wiki?
12:02:03 <metaperl> malebria - I guess it is not as fully featured
12:02:10 <metaperl> it's a shame I think
12:02:15 <notsmack> there's also hikij
12:02:37 <metaperl> Haskell people are forever focused on correctness as opposed to deliverables... perfectionism taken to mal-productive levels
12:02:52 <metaperl> @remember metaperl   Haskell people are forever focused on correctness as opposed to deliverables... perfectionism taken to mal-productive levels
12:03:16 <metaperl> PHP is just the opposite - deliverables no matter how ugly, how non-sensical, how illogical
12:03:29 <glguy> (or wrong)
12:03:42 <notsmack> glguy: no, /and/ wrong
12:03:44 <malebria> http://www.flippac.org/projects/flippi/
12:03:46 <lambdabot> Title: Flippi: a Wiki clone written in Haskell
12:03:52 <metaperl> it's scary how much stuff runs on PHP ---
12:04:00 <malebria> Broken link on the running copy of flippi.
12:04:01 <metaperl> doesnt wikipedia run on php/mysql?
12:04:14 <metaperl> malebria - you know Philippa  dont you?
12:04:20 <mbishop> Wikipedia runs on people
12:04:41 <malebria> metaperl: I don't think so.
12:05:19 <malebria> metaperl: it runs.
12:05:42 <metaperl> malebria - agreed!
12:05:53 <metaperl> some people talk. others theorize. others deliver
12:06:18 <metaperl> the WWW does not have time for Haskell's perfectly correct masterpiece
12:06:29 <shapr> metaperl: I dunno, #haskell seems equally focussed on deliverables and correctness.
12:06:39 <shapr> #haskell isn't afraid of a little unsafePerformIO
12:07:16 <Cale> I'm afraid of unsafePerformIO :)
12:07:21 * metaperl refuses to take the bait
12:07:51 <Cale> But yeah, the only reason we might seem less focused on deliverables is that usually that's all that people care about
12:07:59 <malebria> notsmack: hikij is full of java script, seems to be nice.
12:08:03 <Cale> Whereas we also want those to be correct :)
12:08:11 <metaperl> @google haskell hikij
12:08:14 <lambdabot> http://www.lshift.net/blog/2006/09/28/hikij-haskell-and-javascript-based-wiki
12:08:15 <lambdabot> Title: LShift Ltd. 禄 Hikij: Haskell and Javascript based Wiki
12:08:22 <glguy> Where i work is too much worried about rush garbage out the door
12:08:28 <notsmack> malebria: yeah, i just came across it today
12:08:31 <glguy> this is part of my counter balance
12:08:52 <astrolabe> mathematicians have this thing about once they can see something's possible, they lose interest.  Maybe haskellers are similar.
12:09:01 <malebria> IE don't support it.
12:09:03 <malebria> nice..
12:09:05 <glguy> Umm, that's just a GUI mock up... "Ship it!"
12:11:11 <monochrom> I don't care about deliverables.  I care about, what the corporate culture calls, personal growth.
12:11:48 <glguy> I'm not interested in programming because it pays, it just happens to work out for me that I get paid to program
12:11:55 <Cale> astrolabe: to some extent it's possible there's a bit of that
12:12:10 <Cale> astrolabe: It depends on the initial intent in writing something
12:12:23 <vegai> astrolabe: I think there are reasons for non-mathematicians to become interested in Haskell as well
12:12:29 <glguy> so I'm not trying to figure out how to slop something together for the least amount of effort to maximize my dollars
12:13:21 <Cale> Well, he didn't say that. He was comparing that aspect of mathematicians with a potential corresponding aspect of Haskell programmers.
12:13:40 <glguy> yeah... I'm probably still hung up on what he was talking about a few lines before
12:13:49 <Cale> But I think there is some drive to create practical things with Haskell, however, there are only so many Haskell programmers.
12:14:17 <Cale> (that was aimed more at vegai)
12:14:28 * glguy understood
12:15:15 * vegai nods
12:15:21 <monochrom> I lied when I said I don't care about deliverables.  I did it to start a flame war.
12:15:54 <vincenz> monochrom: stop lying!
12:16:18 <monochrom> But certainly, using JSP to build a website is weaker personal growth than using Haskell to build a website.
12:16:41 <mbishop> Is there a good haskell top level, somewhere that you can just interact, without having to use let everywhere?
12:16:58 <Cale> Yep, it's called vim :)
12:17:27 <Cale> You type your definitions into vim, then save the file, and in a separate window, you have that file open in ghci and you type :r
12:17:31 <monochrom> Recall that when you apply for a job, your r茅sum茅 cannot just brag about how great you will deliver, but also how great you will grow.
12:18:19 <mbishop> Cale: ah, thanks, I seem to recall somewhere that someone (I think it was you) explained why haskell can't have a "real" REPL
12:18:33 <Cale> well, it could have something closer to that
12:18:48 <Cale> But it would be a bit awkward :)
12:19:09 <Cale> It's valid to define types after using them
12:22:51 <metaperl> @remember metaperl Haskell is like the lady who never gets married because there is something wrong with every potential suitor
12:24:04 <metaperl> @remember metaperl if you type check every suitor, you are bound to find an inconsistency somewhere... just get in there and get it over with!
12:25:50 <kpreid> I think one shouldn't be able to @remember oneself
12:25:59 <kpreid> or, at least, one shouldn't
12:27:58 <velco> @paste
12:27:59 <lambdabot> http://paste.lisp.org/new/haskell
12:28:11 <metaperl> kpreid - just as Gurdjieff about that
12:28:14 * glguy agrees with kpreid
12:29:06 <velco> umm, paste down ?
12:29:38 <araujo> metaperl, hah
12:31:33 <kpreid> velco: prodded
12:31:36 <monochrom> I sometimes @remember myself.  But I am highly selective about that.
12:32:02 <monochrom> I am also highly selective about unsafePerformIO.
12:32:37 <Azmo> ffi question: how can a CInt differ from an Int, and how does one get around it? fromIntegral? is there any text somewhere that explains this stuff?
12:33:31 <monochrom> Use fromIntegral.
12:34:25 <Igloo> CInt is 32bit and Int 64 bit on amd64, for example
12:35:13 <Azmo> could CInt be bigger than Int ?
12:35:17 <monochrom> The ffi standard says: CInt should be a newtype of one of Int8, Int16, Int32, Int64, ... and moreover the choice must be hidden.
12:35:33 <Igloo> It could, although I doubt it is anywhere GHC works today
12:35:40 <koe> if i have a type definition such as (Double -> Double -> Double -> Double -> Double -> Double) -> (Double -> Double) -> Double -> Double, how would i make that easier/shorter to read/write?
12:35:50 <monochrom> It could.  But it's ok on GHC.
12:36:01 <vegai> koe: type aliases might help
12:37:26 <velco> http://tinyurl.com/ybgnhg
12:37:29 <lambdabot> Title: comp.lang.haskell | Google Groups
12:37:35 <kpreid> koe: what's the context?
12:37:47 <monochrom> It hurts my heart that too few people RTFM on low-level issues.
12:37:54 <velco> (used the groups for a pastebin)
12:38:06 <glguy> I need to get a job as a PM where I can make arbitrary declarations about what dates things need to be done by without doing any actual work myself
12:38:20 <glguy> or even bothering to understand the work myself
12:38:23 <koe> kpreid: the type definition of a function. (is there a better way to say that?)
12:38:39 <kpreid> koe: I mean, what are all those arguments about?
12:38:50 <kpreid> I'm especiallyl suspicious of the five identical arguments
12:39:07 <monochrom> glguy: if you don't mind two very minor unimportant issues, you can exactly do that to all Haskell community.
12:39:23 <glguy> stuff not getting done and not getting paid?
12:39:34 <monochrom> The two minor unimportant issues are: you get no pay, and not everyone listens to you :)
12:39:52 <koe> kpreid: the first is a four-point interpolation function, and the second is a base function i'm using for continuous time audio synthesis
12:39:53 <glguy> i don't even care if peopel listen
12:40:02 <glguy> I just want to get paid to do nothing like these PMs i work with
12:40:23 <kpreid> koe: I might give type aliases to those functions
12:40:26 <monochrom> I have a feeling that Bulat already has the job. :)
12:40:38 <glguy> damn..
12:40:38 <koe> kpreid: how do i do that?
12:40:57 <kpreid> koe: type Interpolator = Double -> Double -> Double -> Double -> Double -> Double
12:41:15 <koe> ah
12:41:25 <monochrom> If you have an MBA you have a better chance getting a PM job.
12:42:11 <monochrom> However, all success stories on dailywtf point towards family ties or something.
12:43:28 <koe> cool, thanks
12:44:12 <monochrom> Haha, you're right, that type signature is completely uninformative :)
13:02:30 <seliopou> Question: What is wrong with using the type () in instance declarations?
13:02:45 <araujo> ?
13:03:34 <Lemmih> Nothing?
13:04:19 <glguy> RE: (reddit)5 Things a Ruby developer needs to know about Scala
13:04:30 <glguy> 1 your 2 language 3 does 4 not 5 compare
13:04:34 <glguy> bwa hahaha
13:04:54 <seliopou> Check it:
13:04:55 <seliopou> class (Ord a) => SearchSpace a b | a -> b, b -> a where
13:05:08 <seliopou> instance SearchSpace Int () where
13:05:36 <sjanssen> you are using -fglasgow-exts?
13:05:46 <seliopou> And I get illegal instance declaration
13:05:53 <seliopou> It's at the top of file
13:06:03 <glguy> is it common for fundeps to be reflexive like that?
13:06:09 * glguy honestly doesn't know
13:06:13 <sjanssen> glguy: fairly rare
13:06:23 <seliopou> Yeah, my class it a bit wacky
13:06:25 <seliopou> so I have to do that
13:06:45 <malebria> Is block (mapM_ (\io -> catch (unblock io) print) ios) the same as mapM (\io -> catch io print) ?
13:07:07 <sjanssen> seliopou: are you certain there aren't any overlapping instances?
13:07:42 <seliopou> D'oh. I just figured it out. The module that was importing the class wasn't being compiler with -fglasgow-exts
13:07:54 <seliopou> s/compiler/compiled
13:10:25 <glguy> fucking manager types walking around thinking that if they keep saying "final build" that that will someone change the quality of code you get from putting too few devs on a project where you don't know what you want
13:11:52 <lisppaste2> velco pasted "Inferred type is not general enough" at http://paste.lisp.org/display/34259
13:11:59 <dylan> Try being the only dev on a project. XD
13:12:59 <seliopou> I sense that glguy is pissed
13:13:16 <malebria> In the block doc it seems to say that these are the same.
13:14:22 <seliopou> velco: I ran across the same problem once
13:14:26 <heatsink> velco: Can you get any method type you want out of a class?
13:14:44 <glguy> velco: are you allowed to say: mClass :: Class c => m -> c without mentioning c in the class?
13:15:01 <velco> I guess not reaslly, I mean there ought to be dependency from c -> m
13:15:01 * glguy doesn't typically write a lot of class definitions
13:15:07 <velco> between types
13:15:11 <heatsink> glguy: You can do that, it means that it should work for any method type m.
13:15:19 <metaperl> hey ... http://groups-beta.google.com/group/comp.lang.haskell/topics ... so that's a real Usenet group?
13:15:19 <heatsink> *for any class type C
13:15:21 <lambdabot> Title: Discussions - comp.lang.haskell | Google Groups
13:15:21 <velco> I failed misarably when tried to use multi=-parameter classes thouigh.
13:15:22 <glguy> ok
13:15:58 <mbishop> metaperl: they had requested it be made...I guess it finally did
13:16:19 <metaperl> so it is a 3rd resource in additon to haskell-cafe and haskell-general
13:16:43 <heatsink> velco: I think multi-parameter classes are the right thing for this case.  What went wong when you tried those before?
13:16:46 <mbishop> it's not too hard to cross-reference with each other
13:17:59 <mbishop> Jeeze, what is with this MI5Victim crap
13:18:13 <velco> hmm, actually, my multi-param attempt failed for a different reason (tryed to create a circular value) ...
13:18:21 * glguy wonders what MI5Victim is
13:18:45 <velco> ok, I'll try with multi-param  ...
13:19:06 <mbishop> comp.lang.funtional and c.l.ml and c.l.s and others all have spam (that makes little sense) from this "MI5Victim" person
13:19:09 <malebria> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Ablock
13:19:11 <lambdabot> http://tinyurl.com/sqmlj
13:20:32 <glguy> velco: what does using a class even buy you in this case?
13:20:40 <glguy> velco: or are you just experimenting with class and instance?
13:21:35 <velco> maybe C++/Java heritige :)
13:22:29 * heatsink is getting an error when trying to add a lisppaste annotation
13:22:39 <glguy> proxy error again
13:22:58 <glguy> so... paste.lisp.org is running on a lisp server?
13:23:08 <heatsink> -- The class and method type
13:23:08 <heatsink> -- define what type system you are using.
13:23:08 <heatsink> class TypeSystem c m | c -> m, m -> c
13:23:08 <heatsink> -- Within a type system, Class objects have these methods.
13:23:08 <heatsink> class TypeSystem c m => Class c m where
13:23:08 <heatsink>         methods :: c -> [m]
13:23:10 <heatsink> -- Within a type system, Method objects have these methods.
13:23:12 <heatsink> class TypeSystem c m => Method m c where
13:23:14 <heatsink>         classInfo :: m -> c
13:23:37 <heatsink> oops.  Pasting newlines in the xchat window doesn't do what I expected.
13:24:10 <glguy> can you have newlines in an IRC message?
13:24:16 <glguy> isn't the newline the message delimiter?
13:24:31 <velco> it's ok in xchat
13:24:55 <heatsink> glguy: Apparently so, because my one message got split into many.
13:25:13 <velco> in certain versions
13:25:13 <velco>  probably
13:25:24 <velco> this was produced with a single press of Enter
13:25:38 <glguy> yeah, but xchat broke it into 3 lines
13:25:46 <heatsink> anyway, velco, try using the three-class system that I wrote up there.
13:25:47 <glguy> assuming you are using xchat
13:25:56 <velco> will try ...
13:37:39 <bringert> shankys_: how's everything going?
13:37:54 <shankys_> bringert: pretty good
13:38:25 <shankys_> bringert: We've made quite a lot of progress
13:39:14 <bringert> shankys_: good to hear. are you planning to release your framework stuff?
13:39:24 <shankys_> bringert: I think we've decided that the launch of the Haskell framework will coincide with our startup's site launch
13:39:47 <bringert> sounds like a good plan
13:39:58 <shankys_> bringert: We're doing a collaborative news site, and are hoping to attract a lot of people from this channel as users
13:40:17 <heatsink> What does the framework do?
13:40:25 <bringert> shankys_: when are you planning the release?
13:40:40 <glguy> anyone know how to load a filetype plugin in vim? I'd like to try http://www.cs.uu.nl/~arthurvl/haskell.vba
13:40:46 <shankys_> bringert: We're planning on launching sometime around the time our University's winter break ends
13:40:57 <bringert> when's that?
13:41:04 <shankys_> bringert: I'm taking this coming semester off from school to tend to the startup
13:41:20 <shankys_> bringert: Around January 24
13:41:36 <shankys_> bringert: We might launch slightly earlier, or slightly later
13:41:39 <vegai> another web framework?
13:41:45 <shankys_> yeah, another web framework
13:41:49 <vegai> cool
13:41:51 <bringert> shankys_: did you decide what to use for database / persistence?
13:41:56 <shankys_> bringert: Takusen
13:42:02 * glguy tried editing it, and typing :so %
13:42:07 <glguy> that seemed to think it worked...
13:42:12 <shankys_> bringert: We're building our database abstractions on top of it
13:42:52 <shankys_> bringert: We're pretty opinionated as to how every little aspect of things should be, so we wanted to start with something low level
13:43:08 <bringert> shankys_: will you release the DB stuff too?
13:43:15 <shankys_> bringert: yeah
13:43:32 <shankys_> bringert: Absolutely everything that isn't specific to our site will be released under the BSD license
13:44:16 <lisppaste2> velco pasted "Classes/Methods" at http://paste.lisp.org/display/34262
13:44:46 <velco> thanks, guys, here's what I got, it seems it'll do the job for the real thing too ...
13:45:03 <bringert> shankys_: are you planning to use dyn-cgi in the deployed system, or just for development?
13:45:22 <shankys_> bringert: Only for development -- it takes up a TON of memory
13:45:45 <bringert> shankys_: compiled to .fcgi for deployment then?
13:45:50 <shankys_> bringert: I actually had to add memory to my laptop to not have issues with swapping
13:46:00 <shankys_> bringert: yeah, deployment using fastcgi
13:46:37 <bringert> shankys_: I already had 2GB in mine, that's probably why I haven't run into that problem. well, that and the fact that I never use dyn-cgi for anything big
13:47:12 <shankys_> bringert: Yeah, it didn't start out being a problem, but as we started getting to having a lot of code the dynhs.fcgi starting taking up 100+ MB of RAM
13:47:17 <heatsink> velco: kay!
13:47:26 <shankys_> bringert: And it's going to take even more as things get bigger
13:47:55 <bringert> shankys_: you might be able to use RTS flags to get that a bit smaller
13:48:03 <velco> oh
13:48:10 <velco> not right
13:48:18 <bringert> shankys_: I showed you how to set those statically, right?
13:48:26 <velco> err, nevermind
13:48:44 <shankys_> bringert: Yeah, I think so. I just haven't bothered since I added 1GB RAM to my Powerbook.
13:49:09 <shankys_> bringert: And everyone else I'm working with hasn't had any performance issues since they're using reasonably good hardware to develop on.
13:49:15 <heatsink> velco: kay!
13:49:28 <heatsink> I mean
13:49:39 <heatsink> what's up?
13:50:18 <Botje> @pl \x -> x > 1000 && x < 9999
13:50:18 <lambdabot> liftM2 (&&) (> 1000) (< 9999)
13:50:44 <velco> for a moment I thought that when I create the circular value in mkClass I refernce somehow a global ``x'' ...
13:56:32 <seliopou> @hoogle unsafe
13:56:33 <lambdabot> Language.Haskell.TH.unsafe :: Safety
13:56:34 <lambdabot> System.IO.Unsafe :: module
13:56:34 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
13:56:39 <mbishop> http://blogs.nubgames.com/code/?p=15
13:56:41 <lambdabot> Title: Nub Games 禄 Haskell &#8212; First Impressions
13:56:49 <seliopou> @hoogle unsafeRead
13:56:50 <lambdabot> No matches found
13:56:52 <mbishop> that guy seems impressed :P
13:56:54 <seliopou> grrr
13:57:12 <seliopou> Right... it's not documented
13:57:19 <seliopou> does anybody remember off hand where the unsafe array operations live?
13:57:27 <glguy> has anyone seen the vim plugin do automatic type sigs for you?
13:57:29 <syntaxfree> http://blogs.nubgames.com/code/?p=15
13:57:31 <lambdabot> Title: Nub Games 禄 Haskell &#8212; First Impressions
13:57:40 <syntaxfree> glguy: heh. really?
13:58:02 <glguy> this file claims to do it http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.uu.nl%2F~arthurvl%2Fhaskell.vba&ei=LsieRemYPIyajgGFifGSDA&usg=__Q5LxA28jXqqIE5cjLhba-sxOpfc=&sig2=C2EmgUS-gfvXx3nbVITpPQ
13:58:06 <lambdabot> http://tinyurl.com/y2ywgw
13:58:08 <glguy> www.cs.uu.nl/~arthurvl/haskell.vba
13:58:53 <glguy> http://article.gmane.org/gmane.comp.lang.haskell.cafe/17675
13:58:55 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:00:33 <chessguy> i like the nubgames article
14:00:42 <mbishop> syntaxfree: I pasted that link just a minute before you entered :P
14:01:06 <syntaxfree> the nubgames article is so drooly, it almost looks like astroturfing.
14:04:15 <syntaxfree> SubEhtaEdit is making me sad.
14:04:22 <Excedrin> it bugs me when someone claims that they've rewritten some Perl as Haskell and it's shorter
14:04:23 <syntaxfree> Any recommendations?
14:04:51 <syntaxfree> I'd like mode-ful editing like vim, but gvim on the Mac sucks.
14:05:06 <kowey> syntaxfree: how so?
14:05:20 <syntaxfree> bad redrawing bugs, for one.
14:05:31 <kowey> oh yeah, that does suck
14:05:34 <Excedrin> especially when this guy's Perl isn't even correct
14:05:41 <kowey> i just hit ctrl-L
14:05:50 <syntaxfree> it's just visually unpleasant, and I'm supposed to spend hours staring at a text editor.
14:06:17 <syntaxfree> I'd like more power, as in vim.
14:06:20 <glguy> oh good, the PM will have coffee and bagels in the mornings this weekend for the people that come in
14:06:30 <syntaxfree> regexes in SEE are SLOW, man.
14:08:03 <xerox> > intersperse '-' (map chr [69,109,97,99,115])
14:08:05 <lambdabot>  "E-m-a-c-s"
14:08:20 <syntaxfree> I can't make sense of Emacs.
14:08:22 <syntaxfree> and I try.
14:08:24 <kowey> there is aquamacs
14:08:41 <Excedrin> viper
14:08:52 <glguy> but why run emacs in vim emu-mode when you can run vim
14:09:04 <syntaxfree> there's Haskell syntax highlighting for aquamacs?
14:09:05 <xerox> syntaxfree: open it and type C-h t (where C-h means hold CTRL and press h, then release everything and then press t)
14:09:17 <syntaxfree> ah, I saw the tutorial once. it doesn't help
14:09:41 <kowey> syntaxfree: i have no idea, but if emacs has it, i don't see why Aquamacs would not
14:09:44 <xerox> ...if you want to learn to use Emacs.
14:09:58 <beyert> for me, I prefer emacs because I like to use a text editor for most tasks
14:09:58 <beyert>  
14:09:58 <syntaxfree> man, my left hand hurts.
14:10:06 * olliej wishes there were a haskell mode for xcode
14:10:14 <syntaxfree> What will help, short of not typing?
14:10:16 <Excedrin> glguy: because more modes is better
14:10:18 <beyert> As for vim, I made viper even nicer than vim for my needs (though it took a lot of work)
14:10:18 <beyert>  
14:10:36 <syntaxfree>  viper will support vim plugins?
14:10:42 <beyert> not that I know of
14:10:42 <beyert>  
14:10:44 <kowey> syntaxfree: i'm pretty happy with my vertical keyboard
14:10:46 <Excedrin> no, of course not
14:10:54 <xerox> kowey: what is that?
14:10:54 <syntaxfree> what's a vertical keyboard?
14:11:01 <syntaxfree> anyway, I want a short-term solution.
14:11:01 <kowey> http://www.safetype.com/
14:11:02 <Cale> http://programming.reddit.com/info/x6s9/comments
14:11:03 <lambdabot> Title: SAFE TYPE Ergonomic Keyboard - Home Page
14:11:03 <heatsink> olliej: I've never used xcode, particularly after I found out that emacs comes with os x.
14:11:04 <lambdabot> Title: Haskell  First Impressions (reddit.com)
14:11:12 * syntaxfree uses a wireless microsoft keyboard.
14:11:16 <pejo> syntaxfree, do you have redrawing bugs in vim even if you run the x-version?
14:11:17 <Excedrin> "Wow, a few days and already youre using the Maybe monad. Not too shabby!"
14:11:20 <syntaxfree> I spent quite a few time typing in bed these days.
14:11:21 <kowey> it's completely vertical... the only discomfirst is that sometimes i put my elbows on the desk
14:11:52 <syntaxfree> Cale: haha. It's the International Tell People About the NubGames Story Day.
14:11:54 <olliej> heatsink: xcode has everything i like in emacs -- decent tab key  based auto indent, and syntax highlighting
14:12:02 <olliej> heatsink: i debug in gdb :D
14:12:12 <syntaxfree> anyway, what's a good solution to stop my hand from hurting right now? :~
14:12:16 <heatsink> you debug haskell in gdb? :O
14:12:27 <velco> debug haskell ? :D
14:12:30 <olliej> heatsink: omg no
14:12:33 <olliej> the horro
14:12:33 <olliej> r
14:12:42 * olliej suppresses a shudder
14:12:43 <mbishop> syntaxfree: I heard someone say you get two bowls, one with cold water, one with warm water, stick your hand in the warm, wait a few minutes, then put it in the cold
14:12:54 <syntaxfree> hmm.
14:12:58 <syntaxfree> sounds good.
14:13:00 <mbishop> syntaxfree: I think Peter Seibel or someone suggested that, but dunno how well it works
14:13:32 <olliej> heatsink: my work is all c++
14:13:39 <heatsink> I see.
14:13:43 <olliej> heatsink: or occasionally (the horror) obj-c
14:14:01 <Excedrin> http://programming.reddit.com/info/x5it/comments
14:14:02 <lambdabot> Title: Programming for the PS3&#39;s Cell is hard - Apparently, it takes a lot more tha ...
14:14:03 <olliej> sup OliverB
14:14:13 <heatsink> I hear IDEs are pretty useable nowadays, but I've never adapted to one.
14:14:46 <olliej> heatsink: the only ides i've ever been able to use *as* an ide are delphi's and the most recent versions of visual studio
14:15:07 <olliej> heatsink: everything else i use either emacs (linux) or xcode (macos)
14:15:09 <dylan> I prefer to adapt my operating system into an IDE
14:15:25 <olliej> where they act as glorified syntax highlighters
14:15:45 <kowey> hmm... xcode integration for darcs
14:16:01 <syntaxfree> My main need for a good text editor isn't programming, it's latex.
14:16:26 <kowey> have you played with the TeX-specific editors like TeXShop or iTeXMac?
14:16:37 <glguy> kowey: what convinced you that what you needed a "vertical keyboard"?, watching the video is hilarious
14:16:48 <olliej> syntaxfree: i liked the latex mode for emacs -- i did my thesis in it
14:16:56 <kowey> :-) i don't remember how that happened
14:17:06 <kowey> i knew i was hurting, and i was willing to try something new
14:17:26 <kowey> and i know i don't hurt anymore... could be placebo effect
14:17:34 <kowey> or maybe even the switch to Haskell (from Java(
14:18:04 <kowey> only side effect is that you feel more comfortable in vim than emacs, because the arrow keys are in an incovenient place
14:18:26 * syntaxfree soaked a sock in hot water from the coffee machine and tied up his hand.
14:18:38 <olliej> syntaxfree: kinky
14:18:43 * olliej hides
14:19:00 <syntaxfree> don't play with that just yet.
14:19:10 <syntaxfree> still in pain from being dumped and all.
14:19:12 <mbishop> could be worse, he could have peed on it :)
14:19:22 <olliej> :D
14:19:30 <olliej> syntaxfree: :(
14:19:50 <syntaxfree> Suplec's "Training wheels" is a good song.
14:19:55 <syntaxfree> Oh, off-topic. Too off-topic.
14:20:04 <xerox> #haskell-blah
14:20:33 <syntaxfree> yes, yes.
14:21:21 <chessguy> kowey, we prefer not to talk about side effects in here, thank-you-very-much
14:21:43 <seliopou> :t (iterate succ 'a') !!
14:21:45 <mbishop> heh, StumbleUpon for the keyword "Haskell" brought me to http://syntaxfree.wordpress.com/ :)
14:21:45 <lambdabot> parse error (possibly incorrect indentation)
14:21:48 <lambdabot> Title: Data.Syntaxfree
14:21:57 * mbishop gives it a thumbs up
14:22:10 <syntaxfree> I never had such a popular blog.
14:22:10 <kowey> :-D, oh, and the other thing was the pain was in my arms, not hands, and that sorta lined up with the pictures on the site
14:22:18 <syntaxfree> Stats indicate 300-1200 visitors a day.
14:22:33 <syntaxfree> my other blog gets 300-1200 visitors a month.
14:22:40 <syntaxfree> And I'm supposed to be an economist, not a programmaer.
14:22:42 <Excedrin> interesting, are you making any money off of it?
14:22:56 <syntaxfree> never thought of placing adsense ads, no.
14:23:01 <syntaxfree> I don't know if wordpress.com allows them either.
14:23:58 <mbishop> google will just lock the funds and claim they can't tell you why because of "company secrets"
14:24:27 <Cale> glguy: which video?
14:24:40 <glguy> on the safetype site
14:24:54 <syntaxfree> oh, cool, it's allowed.
14:24:56 <glguy> http://www.safetype.com/images/safetypemovie.wmv
14:24:59 <Excedrin> mbishop: I read something today about google not paying adsense, is it fairly widespread?
14:25:11 <syntaxfree> I shoulda put them when I was on the limelights with "Do-notation considered harmful"
14:25:24 <glguy> Cale: notice how unhappy the girl is typing on a normal, or even a split keyboard
14:25:25 <kowey> i think it was more their explanation of how it worked that sold me (three damaging postures)
14:25:36 <zeeeeeee> if i have "data D = forall s . Show s => D { s :: s }", why can't i do "s $ D 0"?
14:25:38 <syntaxfree> http://faq.wordpress.com/2005/12/08/adsense/
14:25:39 <syntaxfree> bah.
14:25:41 <lambdabot> Title: Adsense and other Ads 芦 WordPress.com
14:25:43 <syntaxfree> it's not.
14:25:46 <glguy> Cale: but she can't stop laughing at how rediculous she looks on the vertical one
14:25:51 <kowey> it sorta "made sense"... and the rhumatalogist (?) agreed that it was a more "neutral" position
14:25:57 <zeeeeeee> google turned up nothing for the error, "Cannot use record selector `s' as a function due to escaped type variables"
14:26:30 <mbishop> Excedrin: there was a post (on reddit perhaps?) a while back, about such an incident, and everyone chimmed in saying that they too had it happen
14:26:33 <mbishop> so apparently, yes
14:26:40 <zeeeeeee> (it turned up one thing from #haskell logs, but it was not helpful)
14:26:49 <glguy> zeeeeeee: are you trying: data E = forall t . Show t => E { thign :: t } ?
14:26:56 <zeeeeeee> glguy: yeah
14:26:56 <syntaxfree> so, um, everyone saw the safetype video?
14:26:59 <Cale> zeeeeeee: you can't do it because it can't assign a type to the result
14:27:01 <glguy> zeeeeeee: no dice
14:27:03 <zeeeeeee> glguy: i have to use pattern matching syntax
14:27:09 <syntaxfree> "Extension" is what I've been doing a lot.
14:27:11 <syntaxfree> By typing in bed.
14:27:18 <syntaxfree> God, my hand is killing me.
14:27:29 <pejo> syntaxfree, maybe you should take that as a hint and let it rest.
14:27:30 <glguy> maybe you should...
14:27:31 <glguy> oh..
14:27:32 <Cale> zeeeeeee: The type would be exists a. (Show a) => a
14:27:33 <zeeeeeee> Cale: yet pattern matching works...
14:27:35 <glguy> stop typing for awhiel?
14:27:38 <Cale> zeeeeeee: right
14:27:46 <mbishop> maybe it's because typing wasn't the only thing you were doing with your hand in bed
14:27:48 * mbishop runs
14:28:08 <glguy> syntaxfree: you need voice recognition software ;)
14:28:24 <syntaxfree> stop.
14:28:26 <zeeeeeee> Cale: i'm confused :)
14:28:37 <Cale> zeeeeeee: This isn't necessarily permanent, it just requires some extensions to the type system
14:28:37 <syntaxfree> please.
14:28:46 <glguy> I've had my hand hurt, but it was from playing too much guitar hero
14:29:18 <zeeeeeee> Cale: ah, i guess that's more reassuring
14:29:58 <syntaxfree> gah.
14:30:08 <syntaxfree> that safetype video, the screen is miles away from her.
14:30:18 <syntaxfree> does she use big big characters or does she squints all day?
14:30:28 <zeeeeeee> Cale: do you think whoever's working on haskell' is aware of things like this?
14:30:34 <glguy> I'm going to vote for "it's not her desk"
14:30:59 <kowey> another thing is that after a while, you stop using the mirrors, and just turn your head when you don't know where a key is
14:31:16 <glguy> causing neck injury?
14:31:44 <mbishop> Anyone here living in the US want to do some haskell development and need an ultrasparc II?
14:31:59 <kowey> ack, my neck! (it's kinda neat, the numbers a written in mirror-image so you can see them with the mirrors)
14:32:45 <syntaxfree> I'm going to summer courses to this research institution that has no undergrad courses, just PhDs.
14:32:54 <Lemmih> mbishop: Is living in the US necessary?
14:33:08 <syntaxfree> They basically allow anyone to take the courses, and even accumulate credit in case you ever enter the programs.
14:33:09 <Cale> zeeeeeee: Haskell' is a standardisation of what's already been done
14:33:19 <Cale> zeeeeeee: It's not intended to have new features
14:33:19 <syntaxfree> anyway, they've got Sparcs there. They're cool.
14:33:26 <zeeeeeee> Cale: ah
14:33:28 <syntaxfree> (if anyone's curious. www.impa.br )
14:33:45 <syntaxfree> it's a very interesting place. People from all parts of the world travel here to take the summer courses.
14:33:50 <maskd> impa has some nice videos
14:33:52 <olliej> Cale: Haskell' ?
14:33:56 <mbishop> Lemmih: well, I was going to give it away for free, but the person who wants it will have to pay shipping...so unless you want to pay shipping from the US to whatever country you live in, then no, it's not required :P
14:34:00 <olliej> @hoogle Haskell'
14:34:01 <lambdabot> No matches found
14:34:05 <syntaxfree> er, http://www.impa.br/opencms/en/
14:34:08 <lambdabot> Title: IMPA - Instituto Nacional de Matem谩tica Pura e Aplicada
14:34:08 <Cale> olliej: the present standardisation process.
14:34:12 <olliej> ah
14:34:14 <olliej> :D
14:34:19 <Cale> olliej: hoogle is just for searching for functions in the libraries
14:35:35 <beyert> /quit
14:35:35 <beyert>  
14:36:33 <mbishop> Shipping for the ultraspar II will already be ~$30 to anywhere in the US (less if you are closer to Louisiana)
14:36:42 <mbishop> ultrasparc*
14:36:56 <mbishop> so I'm not sure if anyone outside of the US will want to pay the shipping charges :P
14:37:14 <glguy> is an ultrasparc not worth more than $30?
14:37:19 <Cale> I type with a plain keyboard, but in a nonstandard fashion, where I don't have any ulnar deviation or extension, and my arms are supported by the edge of the desk.
14:37:38 <syntaxfree> Cale: cool.
14:37:53 <pejo> glguy, percieved perforamnce is like a p2 or p3 at the same clock frequency, so not that fast by todays standards.
14:38:11 <glguy> percieved performance?
14:38:28 <seliopou> rofl
14:38:34 <pejo> glguy, shrug, when doing interactive things, like web browsing (ie. dog slow).
14:38:34 <mbishop> glguy: well, It has dual 300MHz ultrasparc II processors, and 256MB ram
14:38:37 <seliopou> Not in scope: `fap'
14:38:50 <seliopou> (I meant fmap)
14:38:57 <seliopou> :t fap
14:38:59 <lambdabot> Not in scope: `fap'
14:39:03 <xerox> ?index fmap
14:39:04 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:39:15 <glguy> seliopou: your keyboard might be broken
14:39:19 <olliej> :t fmap
14:39:21 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
14:39:24 <glguy> now is a good time to consider a vertical keybaord
14:39:37 <olliej> glguy: ?
14:39:43 <kowey> with rear-view mirrors
14:39:45 <mbishop> glguy: some people use it as a work station, but I always jsut used it as a headless server, but you can buy them on ebay for about $100 (not including shipping)
14:39:48 <olliej> and indicators?
14:39:51 <olliej> and rims
14:39:54 <seliopou> lol
14:39:55 <olliej> can't go wrong with rims
14:40:06 <seliopou> Get myself a nice set of 22s
14:40:09 <mbishop> glguy: but if someone wants it to do haskell development on, I'd be more than happy to give it away for free (except shipping :))
14:41:49 <seliopou> > let a = listArray (0, 0) ["test"] in bounds a
14:41:51 <lambdabot>  (0,0)
14:42:21 <seliopou> > let a = listArray (0, 0) ["test"] in fmap (a !) (bounds a)
14:42:23 <lambdabot>   add an instance declaration for (Functor ((,) i))
14:42:23 <lambdabot>     In the definition of ...
14:42:25 <emu> ?check \(l::[Int]) -> l == (reverse (reverse l))
14:42:26 <lambdabot>  Parse error in pattern
14:42:29 <glguy> > bounds $ listArray (1,0) [] -- :-O
14:42:31 <lambdabot>  (1,0)
14:42:41 <glguy> > elems $ listArray (1,0) [] -- :-O
14:42:42 <emu> ?check \l -> l == (reverse (reverse (l::[Int])))
14:42:42 <lambdabot>  Add a type signature
14:42:44 <lambdabot>  OK, passed 500 tests.
14:42:58 <glguy> > elems $ listArray (1,0) [] :: Array Int ()-- :-O
14:42:59 <lambdabot>  Couldn't match `Array Int ()' against `[a]'
14:43:06 <glguy> > elems $ listArray (1,0) [] :: [()]-- :-O
14:43:08 <lambdabot>  []
14:43:20 <seliopou> Isn't (a, a) an instance of functor?
14:43:33 <emu> @instances Functor
14:43:35 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:43:38 <glguy> > range $ bounds $ listArray (0,4) [] -- :-O
14:43:40 <lambdabot>  [0,1,2,3,4]
14:45:16 <glguy> > let pairmap f pair = join (***) f pair in pairmap (*2) (1,3)
14:45:18 <lambdabot>  (2,6)
14:45:28 <glguy> > let pairmap = join (***) in pairmap (*2) (1,3)
14:45:30 <lambdabot>  (2,6)
14:45:34 <olliej> :t (***)
14:45:36 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:45:48 <glguy> :t join (***)
14:45:50 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
14:46:55 <olliej> > join (***) (*2) (1,2,3)
14:46:56 <lambdabot>  Couldn't match `(b, b)' against `(a, b1, c)'
14:50:16 <seliopou> :t join
14:50:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
14:51:07 <seliopou> I'm confused
14:51:20 <monochrom> join :: (r -> r -> a) -> (r -> a)
14:52:03 <seliopou> So in (***) the arrow is (->)
14:52:12 <glguy> yeah
14:52:14 <seliopou> and in join the Monad is (-> r)
14:52:17 <seliopou> er...
14:52:20 <seliopou> ((->) r)
14:53:01 <seliopou> ?
14:53:03 <xerox> Right.
14:53:05 <glguy> yeah
14:54:25 * monochrom plays with Language.Haskell.Parser etc
14:56:33 <olliej> anyone know of a decent parser combinators tutorial?
14:57:22 <svref> I have a data structure that takes 5 minutes to build.  I'd like to cache it somehow, so the program startup time is 2 seconds instead of 3000.  Is there some silver bullet?
14:58:09 <Cale> olliej: the Parsec documentation is decentt
14:58:10 <Cale> -t
14:58:23 <kowey> olliej: maybe the first chapter of 'Write Yourself a Scheme in 48 Hours' too
14:58:27 <Cale> olliej: Note that the module names have changed a bit though
14:58:30 <heatsink> svref, Startup time? Do you want to store it in a file?
14:58:43 <svref> heatsink: yep.
14:58:44 <kowey> but as Cale says, the Parsec doc is actually quite helpful for learning
14:58:55 <Cale> svref: You could use TH and just wrap the thing in a $(...)
14:58:56 <monochrom> Too bad, Language.Haskell.* does not tell me inferred types of variables.
14:59:23 <xic> what's better: ghc 6.6 or nightly?
14:59:41 <mahogny> xic, define better
15:00:00 <olliej> Cale / kowey: cheers
15:00:06 <xic> superior
15:00:14 <svref> Cale: Language.Haskell.TH?  what the heck is it?
15:00:26 <Cale> Template Haskell
15:01:28 <monochrom> "superior" is hardly better than "better".  But I'll just fool around.  (Ask a poor question, get a poor answer.  Fair trade.)  Nightly is better because you get to test your hard disk everyday.
15:02:13 <monochrom> (Don't you love definitions that beg the question.)
15:02:22 <xpika2> @hoogle svg
15:02:23 <xic> is there a changelog?
15:02:23 <lambdabot> No matches found
15:02:46 <mahogny> there is always the checkin comments I guess
15:02:47 <Cale> sorry, I'll make an example
15:02:58 <norpan> nightly is better because then you are protected by the dark
15:03:54 <xpika2> does anyone know of a haskell svg library?
15:04:19 <mbishop> @where svg
15:04:20 <lambdabot> I know nothing about svg.
15:04:57 <svref> Template Haskell =?= LISP Macros?
15:05:02 * JKnecht notes the regional bias in the term 'nightly'.
15:05:36 <JKnecht> @seen xinming
15:05:37 <lambdabot> xinming is in #perl6 and #haskell. I don't know when xinming last spoke.
15:06:02 <Igloo> JKnecht: It's night for the machine doing the building
15:07:25 <monochrom> Yes it has to be regionally biased.
15:09:24 <norpan> here on 60 degrees north it's always night
15:09:31 <norpan> almost
15:11:04 <Syzygy-> norpan: G盲vle?
15:11:05 <JKnecht> bbl
15:11:10 <monochrom> There is difference between template haskell and lisp macros.  I don't know what.
15:11:16 <norpan> Syzygy-: n盲, jag lj枚g, 57
15:11:30 <Syzygy-> Lund?
15:11:37 <norpan> g枚teborg
15:11:45 <Syzygy-> Ah.
15:12:13 <norpan> template haskell is type safe?
15:12:42 <monochrom> Yes.
15:12:57 <svref> hm.
15:12:58 * beelsebob notes that DEVONthink is possibly the best research tool ever created
15:13:59 <svref> I can imagine a lot of scar tissue grafting the Lisp Macro concept into Haskell.  Perhaps that's the difference.
15:14:35 <monochrom> Not just that.
15:14:53 <Heffalump> it's much much harder to add macros to a typed language
15:14:55 <monochrom> You can perform IO in a macro.
15:15:26 <monochrom> Clarification.  You can perform IO in a haskell template.
15:16:33 <Cale> okay...
15:16:38 <Cale> lisppaste2: url
15:16:38 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:17:06 <heatsink> Would you have to remove the scoping restriction on TH to use it like lisp macros?
15:17:10 <monochrom> An application of that is: when ghc is compiling stuff, it also starts an mp3 player to play a Mozart opera.
15:17:20 <heatsink> haha
15:17:31 <syntaxfree> hehe.
15:17:35 <syntaxfree> I need help.
15:17:45 <syntaxfree> Can someone send me their masters' (not PhD) dissertation?
15:17:46 <heatsink> now playing: Strauss -- Thus Spake Zarathustra
15:17:49 <syntaxfree> the more the merrier.
15:18:14 <syntaxfree> heatsink: you realize the "Spake" Strauss is not the same Strauss who wrote the Blue Danube, right?
15:18:27 <heatsink> no, I didn't know that.
15:18:30 <lisppaste2> Cale pasted "using TH to force a computation at compile time" at http://paste.lisp.org/display/34270
15:18:44 <monochrom> syntaxfree: mine is http://www.cs.utoronto.ca/~trebla/scphEditor/
15:18:46 <lambdabot> Title: MSc Thesis: A Tool for a Formal Refinement Method
15:18:50 <kowey> ?query syntaxfree
15:18:50 <lambdabot> Unknown command, try @list
15:18:52 <kowey> oops
15:18:53 <Cale> hmm, there's probably a better way to automate that
15:18:56 <syntaxfree> they're not even contemporary.
15:19:11 * heatsink afks
15:19:34 <monochrom> You can write a haskell template to be either lexically scoped or dynamically scoped.  The former is easier.
15:19:52 <syntaxfree> the Blue Danube one is Johan Strauss.
15:19:58 <syntaxfree> the Spake one is Richard Strauss.
15:20:39 <syntaxfree> how do I enable Haskell syntax highlighting for emacs?
15:20:51 <syntaxfree> monochrom: thanks for the thesis link!
15:20:57 <allbery_b> M-x font-lock-mode
15:21:20 <Cale> With a more involved datastructure, that way would be somewhat of a pain
15:21:36 <monochrom> syntaxfree: http://www.haskell.org/haskell-mode/  haskell mode for emacs
15:21:37 <lambdabot> Title: Haskell Mode for Emacs
15:21:42 <syntaxfree> allbery_b: I'm guessing I need to download something first.
15:21:43 <syntaxfree> cool.
15:22:25 <allbery_b> most emacsen come with an old version of the above, it's somewhat buggy but usable.  M-x haskell-mode might be a prerequisite for M-x font-lock-mode
15:22:34 * monochrom decides that Language.Haskell.* is no fun yet.
15:22:54 <syntaxfree> the numeric classes are no fun!
15:23:18 <syntaxfree> now that I'm studying some number theory, god, is it lacking on modulo-n integer ring stuff.
15:23:34 <syntaxfree> I'm writing some, but I dare not submit it. My code has to suck.
15:24:43 <monochrom> Classification is hard.
15:27:21 <dons> wooo http://blogs.nubgames.com/code/?p=15
15:27:23 <lambdabot> Title: Nub Games 禄 Haskell &#8212; First Impressions
15:27:27 <dons> now that's a good review!
15:28:50 <Cale> dons: yeah
15:28:52 <shankys_> bringert: Do you have any idea why trying to run a function in ghci manually would cause link errors, but yet why dyn-cgi could still work perfectly?
15:29:06 <monochrom> Hahaha, I must say his own Perl example is easier to read than his Haskell example!
15:29:24 <syntaxfree> dons: today is the  IDFQTNA.
15:29:25 <Cale> oh, svref quit
15:29:29 <Cale> oh well
15:29:38 <dons> syntaxfree: you'll have to translate that one
15:30:01 <dons> monochrom: yeah, someone said that on the shootout too. I guess having 300 loc vs 1500 is a good sign though ;)
15:30:04 <glguy> what's a code point?
15:30:07 <Heffalump> monochrom: errm, yes, I was thinking that too
15:30:07 <dons> s/shootout/reddit/
15:30:15 <syntaxfree> dons: International Day For Quoting The Nubgames Article.
15:30:23 <dons> hehe. ah ok :)
15:30:41 <monochrom> a code point is usually a unicode character, but there are exceptions.
15:30:46 <syntaxfree> dons: you use a Mac, right?
15:31:08 <dons> I'm glad he's on to unfoldr already :)
15:31:11 <dons> syntaxfree: nope
15:31:16 <dons> thinkpad x86 running openbsd
15:31:20 <syntaxfree> okie.
15:31:25 <norpan> unfoldr is nice
15:31:28 <glguy> (>0) . length -- yuck
15:31:30 <olliej> dons: bsd, macos, what's the difference
15:31:33 <syntaxfree> (I'm inquiring about good text editors for the Mac)
15:31:47 <olliej> other than one having more consistent ghc support :D
15:31:56 <dons> which one though? ;)
15:32:11 <shoffsta> bringert: shanky's error appears to be caused by defining .hs-boot files for some modules. DynHS still works perfectly, but GHCI gives the error:
15:32:12 <shoffsta> During interactive linking, GHCi couldn't find the following symbol:rn  cgizm2006zi10zi28_NetworkziCGIziMonad_zdf5_closure
15:32:13 <maskd> syntaxfree: try cream
15:32:34 <syntaxfree> I like vim, and can use it with modes alright.
15:32:35 <maskd> ah, not available for mac
15:32:36 <olliej> dons: osx took a *long* time to get a new ghc last year.. though when i think about that it might have been the whole intel thing
15:32:43 <syntaxfree> It's just that gvim for the mac sucks.
15:33:01 <monochrom> The Perl example contains the ugly ending "push @histories, $history if $history".  This is a bad sign.
15:33:17 <mauke> ooh, what Perl example?
15:33:22 <norpan> glguy: yeah, somebody should teach that guy null
15:33:24 <glguy> takeWhile (not . null)
15:33:31 <glguy> norpan: agreed :)
15:33:36 <monochrom> The blog dons pasted.  Please scroll.
15:33:56 <syntaxfree> I'd particularly like a text editor that publishes to blogs automagically.
15:34:08 <mauke> monochrom: ... to the topic containing the link to the logs? :-)
15:34:18 <dons> http://blogs.nubgames.com/code/?p=15
15:34:20 <lambdabot> Title: Nub Games 禄 Haskell &#8212; First Impressions
15:34:55 <monochrom> I have some moral problem with repeating urls.  It's related to the tinyurl facility.
15:35:27 <glguy> ?type isSpace
15:35:29 <lambdabot> Char -> Bool
15:35:36 <glguy> and his empty is probably isSpace
15:36:34 <syntaxfree> monochrom: I think lambdabot's not creating tinyurls everytime.
15:36:37 <mauke> empty is isCtrl
15:36:49 <mauke> well, kind of
15:37:08 <glguy> oh
15:37:12 <glguy> it's : all isSpace
15:37:25 <glguy> (that's how he's intending it to be used, i know it's not the same
15:37:28 <syntaxfree> that is kinda poetic.
15:37:32 <syntaxfree> all isSpace.
15:37:39 <monochrom> Right, but these days urls are long enough to trigger lambdabot.  For example, simply http://www.haskell.org/onlinereport/
15:37:41 <lambdabot> Title: The Haskell 98 Language Report
15:37:57 <monochrom> Err hmm someone has increased the threshold behind my back!
15:38:00 <dons> the cut off is 60 chars or greater for tinyurl generation
15:38:04 <dons> yes
15:38:17 <mauke> I don't know, his Perl code just seems buggy
15:38:28 * sorear pokes @seen
15:38:52 <allbery_b> hm.  Thing (hangs out on cognet) not only wants >=60 chars, it remembers URLs and who sen tthem where along with their snurls
15:39:01 <monochrom> I cited that particular url many times.  We have now a million tinyurls registered for the same page simply because I liked to tell people to RTFM.
15:39:43 <sorear> tinyurl doesn't memoize?
15:39:46 <mauke> it looks like a variant of push @history, do { local $/ = ""; <> };
15:39:47 <syntaxfree> @where dntntrtfm
15:39:48 <lambdabot> I know nothing about dntntrtfm.
15:39:58 <syntaxfree> @where dnftntr
15:39:59 <lambdabot> I know nothing about dnftntr.
15:40:26 <monochrom> http://www.haskell.org/ http://www.haskell.org/
15:40:28 <lambdabot> Title: Haskell - HaskellWiki
15:42:23 <glguy> history xs | null xs || null hs = Nothing | otherwise          = Just (unlines hs, ys) where (hs, ys) = break empty $ dropWhile empty xs
15:42:37 <glguy> histories = unfoldr history . lines
15:43:14 <olliej> ?pl \x y = x y
15:43:15 <lambdabot> (line 1, column 6):
15:43:15 <lambdabot> unexpected "="
15:43:15 <lambdabot> expecting pattern or "->"
15:43:19 <dons> ?tiny-url http://www.haskell.org/
15:43:21 <lambdabot> http://tinyurl.com/z2aba
15:43:22 <dons> ?tiny-url http://www.haskell.org/
15:43:23 <olliej> ?pl \x y -> x y
15:43:24 <lambdabot> http://tinyurl.com/z2aba
15:43:24 <lambdabot> id
15:43:34 <olliej> ?pl \x y -> x 2*y
15:43:36 <lambdabot> (*) . ($ 2)
15:43:46 <allbery_b> it may also ognore urls prefixed by *, so you have a convenient way to avoid unwanted botting
15:43:49 <olliej> :t (.)
15:43:51 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
15:43:56 <olliej> :t (.)(.)
15:43:59 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
15:44:19 <olliej> :t (.)(:)(.)
15:44:21 <lambdabot> forall b c a. (b -> c) -> [(a -> b) -> a -> c] -> [(a -> b) -> a -> c]
15:44:23 <monochrom> OK, I feel morally better now. :)
15:44:28 <allbery_b> (don't recall if that's thing or the CMUSCS zephyr urlbot)
15:44:43 <olliej> :t (.)(:)(.)(+)
15:44:45 <lambdabot> forall b a. (Num b) => [(a -> b) -> a -> b -> b] -> [(a -> b) -> a -> b -> b]
15:51:07 <dons> olliej: hehe
15:51:46 <lisppaste2> glguy pasted "histories redone" at http://paste.lisp.org/display/34276
15:52:56 <dons> I'd even favour :   break empty (dropWhile empty xs)
15:53:05 <dons> just because its a bit cleaner on the eye, and outsiders understand it
15:53:08 <glguy> sure
15:53:09 <glguy> done
15:53:10 <glguy> :)
15:53:35 <dons> there should be a 'list' combinator like 'maybe' and 'either'
15:53:51 <glguy> headDef?
15:54:01 <glguy> oh
15:54:03 <dons> which Cale always says is foldr
15:54:06 <dons> but I'm not sure :)
15:54:17 <dons> list Nothing (Just . unlines ..) where ...
15:54:17 <glguy> list Nothing Just []
15:54:21 <glguy> ah
15:54:37 <Cale> You could have a nonrecursive one
15:54:53 <dons> I just want a case on [] / :
15:54:58 <mauke> huhu, that's exactly my "destruct"
15:54:59 <monochrom> ?type (either, foldr)
15:55:01 <lambdabot> forall a c b a1 b1. ((a -> c) -> (b -> c) -> Either a b -> c, (a1 -> b1 -> b1) -> b1 -> [a1] -> b1)
15:55:13 <glguy> list def f xs = foldr (\x xs -> const (f x)) def xs
15:55:14 <Cale> list f z [] = z; list f z (x:xs) = f x xs
15:55:15 <glguy> like that?
15:55:16 <Cale> like that?
15:55:20 <glguy> heh
15:55:24 <monochrom> There is a formal sense in which maybe :: either :: foldr.
15:55:54 <dons> list a b [] = a ; list _ b xs = b xs -- no?
15:56:08 <dons> though the 'taking apart' bit that maybe does is missing
15:56:10 <Cale> er
15:56:19 <Cale> yeah
15:56:35 <dons> list Nothing (Just .unlines) xs -- is the idea
15:56:39 <monochrom> maybe, either, and foldr are the catamorphisms of the respective data types.
15:56:50 <dons> yep
15:56:58 <dons> maybe they *should* be derivable too
15:57:01 <mauke> list a _ [] = a; list _ f (x : xs) = x `f` xs ?
15:57:06 <Cale> maybe, either, and foldr are similar in that they go through the entire data structure, replacing constructors with functions or values as specified
15:57:42 <monochrom> I spent three months learning this stuff.  I now want to inflict this pain to you all!
15:57:50 <Cale> Yeah, a fancier way to say that is that they're the catamorphisms on those types.
15:58:17 <monochrom> catamorphisms are mechanically derivable from algebraic data types.
15:58:42 <Cale> given various conditions
15:59:01 <Cale> You need enough instances of Functor available
16:00:06 <monochrom> Yes, actually, by algebraic data type I mean [isomorphic to] polynomial functor.
16:00:13 <emu> @type unfoldr
16:00:15 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:01:10 <Cale> I don't like that type for unfoldr, it's almost always awkward to use it.
16:01:43 <sorear> me neither...
16:01:47 <monochrom> Isn't GADT about automating catamorphisms etc.?
16:02:44 <OliverB> What alternative type would unfoldr have?
16:02:45 <sorear> not that I knew of
16:03:07 <monochrom> Cale, show Oliver your unfoldr! :)
16:03:19 <sorear> some special cases are easier to use ... (b -> (a, b)) -> b -> [a]  -- stream unfoldr
16:03:21 <Cale> @let unfoldr' p f g = takeWhile p . map f . iterate g
16:03:23 <lambdabot> Defined.
16:03:36 <mauke> > unfoldr'
16:03:37 <lambdabot>  Add a type signature
16:03:38 <Cale> > unfoldr' (/= 0) (`mod` 10) (`div` 10)
16:03:40 <lambdabot>  Add a type signature
16:03:41 <Cale> > unfoldr' (/= 0) (`mod` 10) (`div` 10) 457128940
16:03:41 <sorear> @type unfoldr'
16:03:43 <lambdabot> Not in scope: `unfoldr''
16:03:44 <lambdabot>  []
16:03:46 <sorear> @type L.unfoldr'
16:03:48 <lambdabot> Couldn't find qualified module.
16:03:48 <Cale> er
16:04:01 <Cale> er, oh
16:04:05 <Cale> wrong way :)
16:04:13 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
16:04:14 <lambdabot> <local>:3:0:     Warning: Pattern match(es) are overlapped              In th...
16:04:19 <Cale> bah
16:04:21 <Cale> @undefine
16:04:22 <lambdabot> Undefined.
16:04:25 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
16:04:27 <lambdabot> Defined.
16:04:30 <Cale> > unfoldr' (/= 0) (`mod` 10) (`div` 10) 457128940
16:04:32 <lambdabot>  [0,4,9,8,2,1,7,5,4]
16:04:36 <mauke> how much does undefine undefine?
16:04:37 <Cale> there we go :)
16:04:39 <dons> all of it
16:04:44 <mauke> :(
16:04:53 <dons> mauke: though I'm thinking of keeping the @let state in a Map, so updates do replace existiing ones
16:04:59 <dons> and then flushing the Map to disk
16:05:13 <OliverB> Hmm, I see - yes I guess it is more likely you would have those 3 functions defined for any particular datatype...
16:05:40 <Cale> Well, it's not so much the general case that I'm talking about
16:05:47 <Cale> this function is equivalent to the list unfoldr
16:05:52 <mauke> I'm thinking of keeping state in a directory of symlinks. is this awesome/retarded?
16:05:54 <Cale> but it's more convenient to use
16:05:58 <dmhouse> Evening everyone.
16:05:58 <OliverB> > unfoldr' (not . null) head tail [1,2,3,4]
16:06:00 <lambdabot>  [1,2,3,4]
16:06:23 <OliverB> Very convenient
16:07:08 <dmhouse> ?hoogle unfoldr
16:07:09 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
16:07:10 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:07:30 <dmhouse> > unfoldr (\xs -> case xs of [] -> Nothing; b:bs -> Just (bs, b)) [1..4]
16:07:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
16:07:32 <lambdabot>       Expected...
16:07:38 <OliverB> ?hoogle [a] -> Maybe(a, [a])
16:07:40 <lambdabot> No matches, try a more general search
16:08:01 <dmhouse> > unfoldr (\xs -> case xs of [] -> Nothing; b:bs -> Just (b, bs)) [1..4]
16:08:03 <lambdabot>  [1,2,3,4]
16:08:03 * sorear wishes for a standard headM
16:08:13 * dmhouse would like a readM too.
16:08:20 <glguy> The Perl example can be greatly reduced using Perl's paragraph mode:
16:08:21 <glguy> local $/ = ""; push @histories, $_ while <>;
16:08:28 <glguy> that's pretty nifty, however unreadable
16:08:33 <Cale> I only wish for those once we have MonadZero back.
16:08:35 <glguy> to the non Perl monk, me
16:08:40 <dmhouse> Cale: yes, I was just thinking that.
16:08:48 <dmhouse> Cale: why was it removed?
16:08:52 <Cale> Using general monads to express failure gives the wrong impression entirely.
16:09:20 <allbery_b> "it eas only beingused by monad comprehensions" or something like that
16:09:20 <Cale> dmhouse: the argument for removing it was that it "wasn't needed" once they removed monad comprehensions in the H98 process.
16:09:23 <mauke> glguy: <mauke> it looks like a variant of push @history, do { local $/ = ""; <> };
16:09:33 <monochrom> Come join the dark side!  Use Arrow.  We have ArrowZero.
16:09:48 <glguy> mauke: I was just pasting from reddit, not claiming credit :-p
16:09:50 <Cale> All the mistakes in the H98 process stemmed from the removal of monad comprehensions.
16:09:57 <Cale> I don't think that's a coincidence.
16:10:05 <dmhouse> MR?
16:10:14 <Cale> Well, the MR is more of a toss-up
16:10:33 <Cale> It's true that without it, it's easier to write more inefficient programs if you're not careful.
16:10:37 <xic> if i lift IO to an arrow what would readChar >>= putChar look like?
16:10:51 <sorear> readChar >>> putChar
16:10:56 <Cale> (that doesn't completely justify it, but at least it's a reasonably good reason)
16:11:14 <sorear> :t Kliesi (\_ -> readChar) >>> Kliesi putChar
16:11:16 <lambdabot> Not in scope: data constructor `Kliesi'
16:11:17 <lambdabot>  
16:11:17 <lambdabot> <interactive>:1:14: Not in scope: `readChar'
16:11:20 <xic> sorear: cool, what about do notation? do { a <- readChar; putChar a }
16:11:35 <xic> sorear: i mean what would it look like in arrow notation?
16:11:39 <sorear> uh... I haven't used proc notation, sorry.
16:11:44 <xic> oh :(
16:11:53 <dmhouse> Cale: so what other mistakes are there stemming from the removal of monad comprehensions?
16:12:03 <allbery_b> -< instead of <- ?
16:12:26 <Cale> proc x -> do y <- readChar -< x; putChar -< y
16:12:28 <Cale> I think
16:12:56 <sorear> That agrees with my limited understanding too.
16:13:08 <dmhouse> Why does readChar take an argument?
16:13:17 <sorear> it's an arrow
16:13:20 <sorear> :t proc x -> do y <- readChar -< x; putChar -< y
16:13:21 <Cale> dmhouse: after merging MonadZero into MonadPlus, lots of the Prelude functions couldn't have their nice general types anymore, and got specialised to lists.
16:13:22 <lambdabot> Parse error in pattern
16:13:43 <ohmega> proc () -> do y <- readChar -< (); putChar -< y
16:13:52 <sorear> > (proc x -> do y <- readChar -< x; putChar -< y)
16:13:53 <Cale> dmhouse: the expectation is that it'll ignore that argument
16:13:53 <lambdabot>  Parse error
16:13:54 <Heffalump> did the merger stem from the removal of monad comprehensions?
16:14:04 <Cale> Heffalump: yes
16:14:19 <OliverB> One thing I'd like with that arrow syntax is the ability to leave out the -< ()
16:14:21 <monochrom> Can you just pretend "a -> IO b" is an arrow?  I think you have to Kleisli everything.
16:14:50 <dmhouse> monochrom: well, this is assuming a new IOA a b, I guess. And new types for readChar and putChar.
16:14:51 <Cale> yeah, you have to wrap things in Kleisli to make it aware that you're not using the (->) arrow
16:15:11 <Cale> readChar :: IOA a Char
16:15:39 <dmhouse> Cale: why not readChar :: IOA () Char and make it explicit that it'll ignore its argument?
16:15:39 <Heffalump> Cale: how?
16:15:54 <Cale> dmhouse: the polymorphism also makes it explicit
16:16:00 <monochrom> Kleisli is a newtype to wrap "a -> IO b".
16:16:04 <Cale> Heffalump: how what?
16:16:37 <dmhouse> Cale: true enough.
16:16:39 <monochrom> who defined readChar?
16:16:45 <Cale> monochrom: us, just now
16:16:55 <monochrom> and putChar too?
16:17:10 <Cale> yeah, we're speculating about an arrow-based IO library
16:17:17 <monochrom> NICE!
16:17:27 <monochrom> Welcome to the Dark Side...
16:17:28 <xic> readChar is (IO Char), how do i make a function that converts IO a -> IOA () a ?
16:17:33 <dmhouse> I don't see many advantages over a monad-based one.
16:17:39 <augustss> I find arrow syntax hard to read
16:17:42 <monochrom> Err Dart Side... (dart for arrow haha)
16:17:43 <sorear> xic: Kliesi . const
16:17:44 <Cale> Seeing that IO really is a monad, it seems saner to keep it at the monad level
16:17:53 <allbery_b> so, just out of silliness, why isn't h' looking at undoing the whole monad comprehension thing?
16:17:59 <Cale> Arrow syntax isn't *that* bad when used in an appropriate fashion
16:18:00 <xic> sorear: what is kliesi?
16:18:09 <sorear> a data constructor
16:18:11 <Cale> but without proc notation, it's pretty insane
16:18:15 <monochrom> It's spelt Kleisli dammit
16:18:33 <Cale> @spell spelt
16:18:34 <ohmega> if becomes tricky without notation ;)
16:18:36 <lambdabot> splat split pelt spell smelt
16:18:36 <monochrom> I am not a spelling police but ghc is!
16:18:42 * glguy wonders whose bright idea it was to pick a name that most can't spell
16:18:42 <xic> what about function (a -> IO b) -> IOA a b?
16:18:47 <ohmega> if then else i mean
16:18:49 <glguy> spelled is proper
16:18:49 <sorear> Kliesi
16:18:59 <dmhouse> xic: newtype Kleisli m a b = Kleisli (a -> m b)
16:19:04 <Cale> Kleisli
16:19:05 <sorear> @nazi-on  GHC has competition
16:19:06 <lambdabot> Spelling nazi engaged.
16:19:07 * allbery_b can spekk Kleisli fine.  he just can't type :p
16:19:09 <lambdabot> Did you mean speak, speck, spec, Spike or spake?
16:19:11 <sorear> @nazi-off
16:19:12 <lambdabot> Spelling nazi disengaged.
16:19:15 <allbery_b> ...case in point :/
16:19:39 <glguy> nazi mode would be fun for about 5 minutes
16:19:40 <emu> thus spake allbery_b
16:19:42 <monochrom> Everyone please memorize http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html before you ask questions!
16:19:44 <dmhouse> xic: it turns monads into arrows. All monads are arrows.
16:19:45 <lambdabot> http://tinyurl.com/y6yt3s
16:19:55 <xic> dmhouse: but how does it work?
16:20:10 <bringert> shoffsta, shankys_: hmm, interesting. maybe a -package problem
16:20:10 <dmhouse> xic: it uses that newtype, like I just showed you.
16:20:11 <sorear> @src instance Arrow Kliesi
16:20:11 <glguy> http://www.wsu.edu/~brians/errors/edet.html
16:20:12 <lambdabot> Source for this function is not available.
16:20:12 <lambdabot> Title: -ed/-t
16:20:20 <glguy> You have learnt your lessons only in U.K.-influenced countries, youve learned them in the U.S. There are several common verbs which often have T endings in Britain which seem a little quaint and poetic in American English, where we prefer -ED. Other examples: dreamt/dreamed, dwelt/dwelled, leant/leaned, leapt/leaped, and spelt/spelled. However, the following alternatives are both common in the U.S.: "burned/bur
16:20:26 <dmhouse> Then you have instance Arrow (Kleisli m) where ...
16:20:38 <bringert> shoffsta, shankys_: dyn-cgi does one trick that ghci doesn't: it looks for -package flags in OPTIONS_GHC
16:20:50 <xic> dmhouse: hm...
16:21:02 <shankys_> bringert: is there any easy way to get ghci to do that too?
16:21:19 * dmhouse never quite got the philosophical difference between a -> m b and Arrow a b.
16:21:31 <bringert> shankys_: other than asking JaffaCake to implement it, no
16:21:41 <bringert> shankys_: or use a shell script wrapper
16:21:44 <xic> dmhouse: you are into happs, right?
16:21:49 <dmhouse> xic: yep
16:21:56 <xic> dmhouse: what do you think of it?
16:22:14 <bringert> shankys_: you could write your own ghci based on the dyn-cgi code
16:22:17 <monochrom> There is no philosophical difference.
16:22:32 <bringert> shankys_: or hack ghci itself
16:22:43 <shankys_> bringert: Hmm...
16:22:45 <dmhouse> It's a nice platform for web dev. I haven't tried the alternatives so I can't really compare, but I like it.
16:22:56 <dmhouse> It's got a poorly documented API.
16:23:08 <dmhouse> It puts an odd amount of emphasis on XML and XSLT.
16:23:13 <shankys_> bringert: There's one other thing that leads us to believe that it *might* be a bug in ghci
16:23:16 <shankys_> bringert: http://hackage.haskell.org/trac/ghc/ticket/936
16:23:18 <lambdabot> Title: #936 (strange ghci behavior and error with recursive modules) - GHC - Trac
16:23:19 <dmhouse> It's been highly tuned to be really fast.
16:23:28 <shankys_> bringert: We're doing recursive imports
16:23:28 <xic> i imagine that one can just ignore the xml and xslt stuff
16:23:52 <mattiast> is it true that "instance (Error e) => Monad (Either e)"?
16:24:02 <bringert> shankys_: did you try giving ghci all the -package falgs to see if it goes away?
16:24:03 <dmhouse> ?instances Error
16:24:05 <lambdabot> IOError, [Char]
16:24:07 <emu> mattiast: yes
16:24:10 <emu> i think
16:24:16 <dmhouse> mattiast: sure.
16:24:23 <emu> @instances Monad
16:24:25 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:24:34 <dmhouse> mattiast: Either e is the monad for functions that might give errors.
16:24:37 <emu> @src instance Monad (Either e)
16:24:38 <lambdabot> Source for this function is not available.
16:24:43 <shankys_> bringert: Not all of them, but I'll give it a shot...
16:24:53 <mattiast> where is it said explicitly?
16:24:59 <dmhouse> In Control.Monad.Error
16:25:18 <bringert> shankys_: the error in that bug seems to be fore one of the recursive modules, but your error is for one of the cgi package modules
16:25:22 <dmhouse> instance Monad (Either e) where return = Right; Left err >>= _ = Left err; Right x >>= f = f x, IIRC
16:25:36 <monochrom> with (Error e)=> context
16:25:42 <dmhouse> Yeah.
16:25:53 <shankys_> bringert: We got that error after loading in every single file we have into ghci
16:26:12 <shankys_> bringert: We get a slightly different one where it can't find some files we created if we don't do that
16:26:20 <mattiast> maybe I'm blind: I don't see it in http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
16:26:22 <lambdabot> http://tinyurl.com/sw72f
16:26:47 <dmhouse> mattiast: instances aren't listed in Haddock.
16:27:04 <mattiast> dmhouse: aaaaah... ok, good to know :)
16:27:15 <dmhouse> mattiast: http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
16:27:17 <bringert> shankys_: sounds odd. it may well be a bug. strange the dyn-cgi doesn't have the problem though.
16:27:20 <dmhouse> instance (Error e) => Monad (Either e) where
16:27:21 <dmhouse> 	return        = Right
16:27:21 <dmhouse> 	Left  l >>= _ = Left l
16:27:21 <dmhouse> 	Right r >>= k = k r
16:27:24 <dmhouse> 	fail msg      = Left (strMsg msg)
16:27:48 <shankys_> bringert: Yeah, that's exactly what we were thinking :(
16:28:01 <mattiast> thanks, the world is crystal-clear again
16:28:01 <Saizan> ?type strMsg
16:28:04 <lambdabot> forall a. (Error a) => String -> a
16:28:16 <shoffsta> bringert: the error still happenes when all of the -package flags are given...
16:28:21 <dmhouse> Saizan: that's a member function of the Error class.
16:28:33 <shoffsta> is there anything else that dyn-cgi does that ghci doesn't?
16:28:54 <bringert> shoffsta: probably :-) I haven't looked at the ghci code
16:29:01 <Saizan> dmhouse: i see, just wondered because the standard member is String
16:29:12 <dmhouse> Saizan: there's also IOError.
16:29:25 <dmhouse> Which are exceptions, you throw and catch them.
16:29:29 <bringert> shoffsta: are any of the modules loaded as object files?
16:29:53 <bringert> shoffsta: ghci uses those if it can. I'm not sure about what dyn-cgi does
16:30:06 <shoffsta> I don't think so
16:30:46 <shoffsta> but the error I'm getting now complains about 'ModelziProfile_makeDefaultProfile_closure', which we define...
16:31:00 <shoffsta> so it doesn't look like it's a problem in the external modules
16:31:20 <Heffalump> Cale: how did monad comprehensions being removed lead to the merging of MonadPlus and MonadZero?
16:31:38 <bringert> shoffsta: maybe you can try the code from that bug in your ghci and dyn-cgi and see if cyn-cgi is ok with it?
16:32:04 <bringert> by that bug I mean the ticket #936
16:32:08 <Cale> Heffalump: one sec
16:32:19 <shoffsta> I'll give it a shot...
16:35:44 <dons> ?src Either >>=
16:35:45 <lambdabot> Left  l >>= _ = Left l
16:35:45 <lambdabot> Right r >>= k = k r
16:39:22 <dons> oh, interesting, I see Ross has applied a patch to show the nicer record-based GetOpt handling
16:39:31 <dons> just a couple of days after we talked about adding such an example
16:39:34 <dons> does Ross read the logs?
16:39:38 <Cale> Heffalump: The argument was pretty weak. It was basically that MonadZero and MonadPlus were split in the first place because of the desire to handle monad comprehensions, so to simplify things, they should be merged again when monad comprehensions were removed.
16:40:17 <dmhouse> Cale: why were they together in the first place? Categorical monads have no notion of failure.
16:40:42 <syntaxfree> http://damienkatz.net/2007/01/the_volkswagen.html
16:40:44 <lambdabot> Title: Damien Katz: The Volkswagen Lisp
16:40:45 <Cale> Well, the MonadPlus class was invented to handle things like parsers and the list monad.
16:40:48 <dons> Heffalump: someone was complaining the tower of monads implemented in Lambdabot
16:40:54 <dons> who should I talk to about that ?;)
16:41:00 <Cale> and whenever you have a plus, it's natural to have a zero :)
16:41:32 <Cale> fail is another story
16:42:00 <Cale> fail was added after MonadPlus and MonadZero were merged, because do-notation needed something to do with refutable patterns
16:42:29 <jcreigh> why were monad comprehensions removed in the first place? (let me know if this is answered in the scrollback, and I'll look harder.)
16:42:32 <Cale> In Haskell 1.4, do-notation was defined to use mzero to catch failures to match refutable patterns.
16:42:43 <dmhouse> jcreigh: too confusing for newcomers.
16:43:01 <syntaxfree> sometimes I feel Haskell lost a few cool features.
16:43:03 <dons> Heffalump: sometimes I think we should tear down the lambdabot monad tower, esp. once it gets used in screenshots: http://www.workingmouse.com/research/IntelliJIdea%2DHaskell/
16:43:05 <lambdabot> Title: Workingmouse: Where you find the Java People!
16:43:06 <Cale> jcreigh: because they caused confusing error messages for beginners who only wanted list comprehensions. Personally, I think this was sort of a bad reason
16:43:13 <Heffalump> dons: I'm innocent, I tell you.
16:43:17 * allbery_b thniks that's nonsense.  (and monads, in particularly IO, *aren't?*)
16:43:22 <Heffalump> completely innocent
16:43:23 <sorear> Now that we have rank-2 type, do we still have an excuse?
16:43:40 <Cale> allbery_b: hm?
16:43:45 <Cale> oh
16:43:50 <Cale> confusing for beginners
16:43:54 <allbery_b> that monad comprehensions are "too confusing"
16:43:55 <dmhouse> dons: but isn't it great that you can derive Monad for it :)
16:43:56 <Cale> well, beginners don't need IO
16:43:59 <Heffalump> dons: you're probably right, a lot of it was "cos I could" rather than necessrily being an obviously good design
16:44:29 <dons> yeah, in the end lambdabot operates as a StateT at the top level, augmented with a local ModuleT for each plugin's local state
16:44:34 <dons> so it could be a lot simpler :)
16:44:44 <Cale> In fact, I'm one of those people who would teach IO near the middle of their tutorial.
16:44:48 * dmhouse never understood why people liked highlighting comments in grey. I'd say they're more important than the code.
16:45:01 <Cale> I'd start with types and values.
16:45:14 <jcreigh> oh, so if you said foo x = [ y*y | y <- [y..x] ], it wouldn't work without a type signature or enough context to know what the monad was?
16:45:18 <emu> i put them in green, easy to read
16:45:27 <Cale> jcreigh: that's true
16:45:36 <Heffalump> from memory, the obvious thing to get rid of is the distinction between IRC and LB
16:45:36 <Cale> jcreigh: It's fixable with a defaulting mechanism
16:45:37 <allbery_b> fine.  so introduce monad comprehensions as list comprehensions andshow their generality later
16:45:40 <Heffalump> (if it's still there)
16:45:41 <allbery_b> like map -> fmap
16:45:55 <Cale> But that's a defaulting mechanism we don't have
16:46:21 <Cale> It would be nice to have monad comprehensions which defaulted to list comprehensions whenever the type was ambiguous.
16:46:22 <Heffalump> it was intended to provide static separation between "we're connected" and "we're not connected", but the complexity cost is probably not worth it
16:46:31 <dons> yeah. that can go
16:46:52 <dons> there's some other scary stuff too, after TheHunter added implicit params
16:46:55 <Cale> allbery_b: what do you think of the idea of merging fmap and (.) ?
16:46:56 <dons> which then got turned back into a monad
16:47:05 <Heffalump> ouch :-)
16:47:25 <Heffalump> I also recall the interaction between signal handling and other exceptions was a bit clunky, though effective in some ways.
16:47:29 <dons> yeah.
16:47:31 <allbery_b> map / fmap I like, fmap / (.) I'm a little iffy on but think it makes sense
16:47:36 <sorear> Heffalump: also, I'm working (sorta) on multiple servers, my current plans feature lambdabot *always* being connected.
16:47:37 <dons> the signals are a bit irksome. i cleaned it up
16:47:48 <dmhouse> Cale: so you'd write things like (*2) . [1..3]?
16:47:55 <sorear> signals = PRIVMSG et al | SIGINT et al ?
16:47:59 <Heffalump> sorear: ok, so then it really has to be dynamic
16:47:59 <dons> but the whole monad/type stack could be simplified to just StateT and then a ModuleT I think
16:48:00 <jcreigh> hmm, seems kinda lame to me. Yeah, Haskell's kinda confusing, but hey, Haskell /= newspeak
16:48:01 <Heffalump> SIGINT et al
16:48:08 <Heffalump> what's a ModuleT?
16:48:20 <Cale> dmhouse: yeah
16:48:47 <Cale> I think it would be bewildering at first, but it would eventually be for the better.
16:48:53 <allbery_b> maybe what's needed is a way to define things so that the prelude defines list comprehensions and you canthen import another module (with appropriate hiding on Prelude) to redefine for general monads
16:49:08 <Heffalump> that's getting back to the beginner/expert language
16:49:09 <Cale> Functor application and function composition are potentially the most important operations in functional programming.
16:49:12 <ctkrohn> http://www.postgresql.org/docs/8.2/interactive/arrays.html#AEN5733
16:49:15 <lambdabot> Title: PostgreSQL: Documentation: Manuals: PostgreSQL 8.2: Arrays, http://tinyurl.com/yx8zxp
16:49:22 <Cale> Merging them has a particular appeal.
16:49:37 <Cale> Then again, I think I'd leave map as a synonym for (.)
16:49:38 <dmhouse> Certainly merging map and fmap would be great.
16:49:50 * allbery_b thinkls training wheels can be overdone
16:49:56 <Cale> So that we'd have an elegant prefix and infix form for that operation.
16:49:58 <Heffalump> and liftM, for the benefit of whoever keeps complaining about that
16:50:01 <allbery_b> ...then again, arguably that line of thought leads to perl :>
16:50:08 <shoffsta> bringert: hmm. the error won't actually occur in ghci when running a .hs file, so I'm not sure how to reproduce this in dyn-hs
16:50:26 <dmhouse> I'd love all my code I wrote for lists to suddenly be applicable to Seqs, Sets and so on.
16:50:26 <Cale> perl has lots of training wheels
16:50:43 * Heffalump belatedly realises the suggestion is merging map and (.). Ewwwwww!
16:50:44 * mbishop thinks perl is a bike with huge training wheels with square tires
16:50:44 <Cale> So many that they start making it hard to ride the bike
16:50:50 <allbery_b> it does but it also has ways to take them off.  how do I define a monad comprehension in h98?
16:50:58 <bringert> shoffsta: what do you mean by running a .hs file? what was it you did before?
16:51:05 <shoffsta> However, I realized, that if i imported the module that ghci was complaining about (eg. Model.Profile), ghci stopped complaining about that module, and complained about different closures in stead
16:51:14 <Cale> allbery_b: you edit GHC :)
16:51:17 <Heffalump> you use do notation and guard where you'd have used a boolean
16:51:30 <Cale> but yeah, more practically, you just use do-notation
16:51:43 <Cale> Heffalump: yes, it would
16:52:04 <shoffsta> bringert: the ghci bug-report is about running commands interactively in ghci...
16:52:16 <Cale> There are cases where I'll admit things can be valid but incorrect with that level of polymorphism.
16:52:30 <bringert> shoffsta: and what did you do to run it? use runghc?
16:52:31 <shoffsta> but dyn-hs will run a .hs file, in stead of accepting interactive commands
16:52:46 <Cale> Which is why I'd recommend leaving in map as a synonym for (.), because notationally, that can make things clearer
16:52:59 <mbishop> Haskell would be so much more friendly if they just changed some of the terminology
16:53:00 <mbishop> :P
16:53:16 <Cale> mbishop: which terminology?
16:53:28 <bringert> shoffsta: sure, but first it loads and links. what dyn-hs does is like loading in ghci, and then running cgiMain from the ghci prompt
16:53:28 <sorear> main :: WarmFuzzyThing ()
16:53:29 <sorear> ?
16:53:46 <allbery_b> main :: Monster () -- }:>
16:54:06 <Cale> @let (.) :: Functor f => (a -> b) -> f a -> f b; (.) = fmap
16:54:07 <lambdabot> <local>:1:23:     Ambiguous occurrence `.'     It could refer to either `L..'...
16:54:10 <mbishop> Cale: monads, polymorphism, referencial transparency, parametric polymorphism, etc
16:54:11 <Cale> err
16:54:16 <mbishop> big words are scary D:
16:54:30 <Cale> mbishop: hehe
16:54:41 <Cale> mbishop: they use similar words in OO languages
16:54:46 <sorear> Cale: you wrote unfoldr' earlier
16:54:49 <sorear> @undef
16:54:50 <lambdabot> Undefined.
16:54:53 <mbishop> I mean, a language like Java needs those words to confuse people with MBAs, but haskell doesn't have an excuse :P
16:54:55 <Cale> @let (.) :: Functor f => (a -> b) -> f a -> f b; (.) = fmap
16:54:56 <lambdabot> Defined.
16:54:59 <emu> perhaps we should refer to reefer transparency and party polymorphism
16:55:03 <Heffalump> I don't want my (.)s accidentally becoming maps either!
16:55:11 <Cale> > succ . [1,2,3]
16:55:12 <lambdabot> Terminated
16:55:19 <dmhouse> Ouch.
16:55:22 <mauke> Cale: you can't redefine standard functions :/
16:55:26 <sorear> > succ L.. [1,2,3]
16:55:27 <lambdabot>  [2,3,4]
16:55:31 <Cale> right
16:55:37 <allbery_b> polymorphism => type polyamory? :)
16:55:41 <sorear> > succ . [1,2,3]
16:55:42 <lambdabot> Terminated
16:55:54 <Cale> we need @hiding
16:56:00 <dmhouse> allbery_b: typewise apathy?
16:56:12 <emu> or maybe it's mutant types
16:56:26 <allbery_b> X-types!
16:56:39 <sorear> Cale: you could make that work automagically, with dons' musings on Map-based @let implemented
16:56:43 <shoffsta> bringert: bringert: hmmm, ok... I'm not that familiar with the dyn-hs internals
16:56:51 <Cale> @undefine
16:56:53 <lambdabot> Undefined.
16:57:58 <mbishop> Someone should make a DrHaskell
16:58:25 <allbery_b> @where DrHaskell
16:58:26 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
16:58:27 <dons> ?where DrHaskell
16:58:28 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
16:59:12 <mbishop> heh not THAT DrHaskell
16:59:21 <mbishop> I'm talking more along the lines of DrScheme, only for haskell
16:59:43 <dons> ah
16:59:52 <dmhouse> What's DrScheme?
17:00:19 <mbishop> ?goog drscheme
17:00:22 <lambdabot> http://www.drscheme.org/
17:00:22 <lambdabot> Title: DrScheme
17:00:57 <mbishop> it's an IDE for scheme, has a repl/editor, built in "Help Desk" (Documentation browser/search) and other really neat features
17:01:19 <dmhouse> Emacs nearly does that for Haskell.
17:01:30 <dmhouse> Documentation search will be implemented as soon as Hoogle 4 is out.
17:01:48 <dmhouse> We have GHCi integration.
17:02:11 <mbishop> I used to use emacs quite a bit (pretty much just emacs and firefox, everything I needed) but that started to become a pain
17:02:26 <dmhouse> Why?
17:02:33 <iulus> I always swore by vim, but I hear a lot of good things about emacs
17:02:36 <mbishop> well, drscheme also "just works.", I tried getting ghci in an emacs buffer, it was a kludge :\
17:02:46 <iulus> almost to the point of trying it...
17:02:56 <dmhouse> Yes, haskell-mode does need some love.
17:03:10 <allbery_b> hm.  eclipsefp?
17:03:11 <iulus> but judging by how long it took me to learn vim, I'm not sure I want to go through that again
17:03:13 <dmhouse> But there are some really polished Emacs modes out there, haskell-mode could become one given enough care and attention.
17:03:20 * allbery_b hasn't worked with thatenough to now how much of that it does
17:03:30 <mbishop> I found emacs way easier to learn than vim
17:03:37 <dmhouse> Once Haskell debugging really matures I'd love to write the Emacs integration.
17:04:35 <bringert> shoffsta: I'm off to bed, good luck working it out
17:04:53 <mbishop> dmhouse: what do you mean by "really matures"?
17:05:12 <dmhouse> mbishop: well, becomes part of the standard GHC distribution, perhaps.
17:05:19 <mbishop> ah
17:05:59 <monochrom> Lately I have thought a bit about debugging.
17:06:04 <mbishop> Still, I'd like to see an editor solely for the purpose of editing haskell, with every nice feature you could imagine (since it doesn't have to put up with other language nonsense)
17:06:29 <dmhouse> There was an effort to create one, look up hIDE on the wiki, but it's since been orphaned.
17:06:38 <mbishop> I saw that :(
17:06:48 <xic> as far as i know, Lemmih is still working on hIDE
17:06:49 <dmhouse> Personally, I like having one IDE for every language I could possibly want to write in.
17:06:56 <dmhouse> xic: no, it's been orphaned.
17:07:01 <xic> :'(
17:07:34 <monochrom> You know how ghc goes Haskell -> Core -> C -> machine.  (There are also several optimization stages.)  Each transform is lossy or obfuscating, you need to annotate like hell to support debugging.
17:08:12 <sorear> dons: I've found a way to make lambdabot spam... too much?
17:08:15 <sorear> @seen #haskell
17:08:16 <lambdabot> In #haskell I can see allbery_b, araujo, arjanb, astorm, astrolabe, audreyt, augustss, avar, azmo, bcoppens, bd_, benja_, bfulgham, botje, boulez, bringert, cale, calvins, claudiusmaximus, ctkrohn,
17:08:16 <lambdabot> dcoutts, dgriffi3, dino-, dmhouse, dons, dvekravy, dylan, earthy, emu, excedrin, explicitjelly, flux__, fridim_, gaal, gds, glguy, gvdm_other, heatsink, heffalump, igloo, integral, iulus, jcreigh,
17:08:16 <lambdabot> jknecht, khisanth, koe, kolmodin, korollary, kosmikus, kpreid, kzm, kzm_, lemmih, lisppaste2, lucca, mahogny, maskd, mattiast, mauke, mbishop, monochrom, muad_dib, mux, mynstral, nafai, newsham,
17:08:16 <lambdabot> nok1z, norpan, nothingmuch, notsmack, ohmega, olliej, pejo, philippa, psnl, psykotic, qwr, ray, reppie, resiak, saizan, samb_xp, shankys_, shoffsta, sieni, sipaliwini, sjanssen, ski, sorear,
17:08:19 <lambdabot> syntaxfree, syzygy-, takuan, tanuk-, templar2, thartman, thelsdj, therp, tizoc, tsc, ulfdoz, vegai, vincenz, vq^, waern, wilx, wolverian and xic.
17:08:29 <mahogny> gaargh
17:08:30 * syntaxfree mumbles.
17:08:30 <syntaxfree> yes?
17:08:31 <dmhouse> sorear: congrats, you just pinged the entire channel.
17:08:34 <kpreid> Yes, that's too much.
17:08:34 <mbishop> heh
17:08:34 <iulus> ah man
17:08:42 <allbery_b> "whee"
17:08:42 <Cale> wow, that's awesome for getting everyone's attention all at once
17:08:43 <iulus> I was concentrating, and then my IRC flashed
17:08:47 <mbishop> at least everyone is awake :)
17:08:48 <bringert> yeah, that's not great
17:08:50 <brainly-green> sorear you can't see me
17:08:50 <Saizan> very active channel or bugged seen?
17:08:53 <Cale> @users
17:08:54 <shoffsta> bringert: thanks fo the help
17:08:54 <lambdabot> Maximum users seen in #haskell: 296, currently: 279 (94.3%), active: 47 (16.8%)
17:08:59 <shankys_> not great at all
17:09:07 <kpreid> Unanimity!
17:09:19 <brainly-green> how come i'm not seen
17:09:30 <dmhouse> brainly-green: you probably haven't spoken recently.
17:09:33 <Saizan> now that you are all here, a nice xslt tutorial?
17:09:36 <brainly-green> oh
17:09:44 <monochrom> To put this into perspective, consider even gcc.  In the transform C->asm, there is a whole lot of line number annotation added to support debugging.  ghc will have to do even more.
17:09:44 * Botje inflictes horrible temperature-based torture upon sorear 
17:09:46 <Botje> spammer! :(
17:10:03 <allbery_b> within the past 4 hours, or something like that
17:10:09 <AStorm> grr.
17:10:11 <sorear> @seen
17:10:11 <lambdabot> Lately, I have seen allbery_b, astorm, botje, brainly-green, bringert, cale, dmhouse, dons, emu, iulus, kpreid, mahogny, markstos, mauke, mbishop, monochrom, saizan, shankys_, shoffsta, sorear,
17:10:12 <lambdabot> syntaxfree and xic.
17:10:18 <avar> argh highlight
17:10:20 <dons> sorear: you must submit a patch now
17:10:35 <AStorm> Yes, it's an order!
17:10:37 <dons> I can see a , b , c and 270 others
17:10:46 <dons> for example
17:10:54 * iulus wakes up from his nap only to see that he's been fooled twice, grumbles, and goes back to sleep.
17:11:07 <AStorm> I can see lambdabot here, and all <nnn> others.
17:11:08 <bringert> can't it just require an argument, or just give the count when called without one
17:11:08 <monochrom> OK, now all of you have washed away my wise comments.
17:11:11 * allbery_b thinks "I can see 270 people, please be more specific"
17:11:12 <lucca> I see you too, lambdabot
17:11:36 * Igloo thinks "My eyes! My eyes! It burns!"
17:11:59 <mauke> huhu, I could do that with colors if haskell wasn't +c
17:12:18 <monochrom> Every time I have something useful to say, someone undermines it.
17:12:20 <Igloo> That's why it's +c  :-)
17:12:28 <monochrom> Next time I'll just say useless things.
17:12:29 <dmhouse> Gah. C array declaration syntax is so stupid. int is[]. Being an array is a property of the type, not of the variable. I want int[] is.
17:12:40 <allbery_b> monochrom: useful things -> blog :)
17:12:47 <mauke> dmhouse: it's not a variable, it's a declarator!
17:12:55 <dmhouse> Whatever.
17:12:56 <norpan> int *is
17:13:02 <monochrom> My experience with most blogs is the opposite.
17:13:09 <lucca> norpan: int *a, *b, *c ?
17:13:14 <mauke> also, int *(*where_is_your_god_now[123])[42];
17:13:14 <dmhouse> norpan: likewise, although at least you can write int* a.
17:13:19 <iulus> then you need an 'online technology journal' :P
17:13:23 <allbery_b> most blogs yes.  haskell blogs seem to follow more useful rules
17:13:25 <norpan> i know it's stupid
17:13:33 <Igloo> dmhouse: But int* a, b; ...
17:13:33 <lucca> heh
17:13:44 <dmhouse> Igloo: yes, it's stupid.
17:13:50 <lucca> dmhouse: it's nothing compared to function pointer syntax.
17:13:51 * Igloo can never remember which way round to write things in C
17:13:53 <mbishop> @remember mauke also, int *(*where_is_your_god_now[123])[42];
17:14:04 <dmhouse> Igloo: don't put multiple decls onto one line when using pointers :)
17:14:11 <monochrom> haskell blogs are all like "I learned monads yesterday and it's so cool".  Useful for newbies but of little eternal value.
17:14:13 <mauke> dmhouse: why not?
17:14:32 <dmhouse> typedef double (*(*(*fp3)())[10])(); -- from my book.
17:14:37 * sorear has lost the ability to C ... int main argc argv = do printf "Hello World\n" >> exit 0
17:14:38 <iulus> I enjoy reading a few of the people on planet.haskell.org
17:14:54 * olliej stabs g++ error messages
17:15:05 <mauke> fp3: alias for pointer to function() returning pointer to array[10] of pointer to function() returning double
17:15:17 <Excedrin> <monochrom> ... blogs are ... Useful for newbies but of little eternal value.
17:15:24 <dmhouse> mauke: I was saying for pointer declaration syntax, int* i makes more sense, but that breaks down when you want multiple decls on one line, like int* a, b, c, as b and c aren't pointers. So don't do it.
17:15:26 <syntaxfree> monochrom: I feel newbies have a perspective that Haskell wizards have long lost.
17:15:26 <monochrom> heh
17:15:31 <mauke> dmhouse: the signal() function is pretty awesome, too :-)
17:15:42 <syntaxfree> I myself have started my Haskell blog to give voice to that kind of perspective.
17:15:45 <mauke> dmhouse: int* only makes sense if you don't know C
17:15:54 <allbery_b> olliej: template errors?  (you'll never complain about ghc errors again :)
17:15:56 <dmhouse> mauke: why?
17:16:06 <lucca> some of us say int * c; but that makes people mad because it looks like multiplication
17:16:11 <mauke> because it doesn't parse that way
17:16:18 <monochrom> syntaxfree: yes, but your statement does not contradict mine.
17:16:20 <dmhouse> mauke: so?
17:16:28 <olliej> allbery_b: of course.  ghc errors are just as obsucre, albeit in different ways
17:16:30 <mauke> it's more obvious if you use parens: int (*p)
17:16:50 <syntaxfree> monochrom: yes, it does. I'm saying the perspective of newbies is useful to the wizards.
17:16:53 <dmhouse> mauke: int* i is more natural than int *i. Being a pointer is a property of the type, not of the declarator.
17:17:11 <olliej> dmhouse: unfortunately C doesn't make that distinction
17:17:12 <mauke> dmhouse: * doesn't mean "pointer". it means "dereference".
17:17:12 <monochrom> Could you give an example?
17:17:21 <iulus> 'int *i', 'int* i', and 'int * i' parse. Does 'int*i' parse?
17:17:25 <olliej> dmhouse: eg. int* i, j;
17:17:26 <syntaxfree> monochrom: http://syntaxfree.wordpress.com  ;)
17:17:30 <sorear> "declaration mirrors use"
17:17:33 <lambdabot> Title: Data.Syntaxfree
17:17:49 <dmhouse> olliej: yes, Igloo already brought that up
17:17:50 <mauke> int (*p); means "dereferencing p yields an int"
17:18:05 <dmhouse> mauke: why not have int* i, which means "i is a pointer to an int"?
17:18:19 <mauke> ITYM &int i; :-)
17:18:29 <dmhouse> ?wty ITYM
17:18:29 <lambdabot> Maybe you meant: ft wn
17:18:36 <dmhouse> ?wtf ITYM
17:18:36 <norpan> brrr pointers
17:18:37 <lambdabot> Maybe you meant: bf ft wn
17:18:37 <mauke> "I think you mean"
17:18:57 <dmhouse> mauke: why would I mean that?
17:19:06 <mauke> dmhouse: real answer: because that's incompatible with the rest of C's declaration syntax
17:19:15 <olliej> mauke: pascal (those versions with pointers) go ident: ^type for a pointer.  i think. it might also be type^... hmm
17:19:16 <mauke> because "&int" says "address of int"
17:19:27 <olliej> too long since i did anything in pascal... or maybe not long enough
17:19:33 <arrakisdunes> hi
17:19:43 <allbery_b> ^type for declaration, type^ for dereferencing
17:19:43 <dmhouse> mauke: oh, fair enough.
17:19:49 <allbery_b> (IIRC)
17:20:19 <mauke> dmhouse: if int* meant "pointer to int", how would you declare a pointer to an array of 10 ints?
17:20:38 <dmhouse> mauke: ideally? int[10]* is.
17:20:47 <Saizan> well, having things that are not pointers is just a premature optimization.
17:20:54 <mauke> ok, now a pointer to a function returning a pointer to an int
17:21:14 <allbery_b> lemme know when you get done reinventing algol68 :p
17:21:44 <dmhouse> int* (*func)()?
17:21:54 * dmhouse is still a bit hazy on function pointers.
17:22:03 <mauke> that's inconsistent with the first use of *
17:22:12 <iulus> mauke: int**, right? (but you can't represent the fact that there are 10 in the array)
17:22:23 <jcreigh> I haven't seen any case where I actually *want* explict pointers. Maybe if I was writing a kernel, I'd think it was a great idea, but other than that, I don't see any reason.
17:22:23 <mauke> it should be something like int*()* fp
17:22:33 <dmhouse> mauke: function pointer syntax is horrible anyway.
17:22:35 <arrakisdunes> i have one code, and i do the makeinstal...but when i trie to do the make give me one error: /usr/bin/ld: Undefined symbols: ___DISCARD__ collect2: ld returned 1 exit status. Can some one help me?
17:22:35 <mauke> iulus: nope, int[10]* would be "right"
17:22:43 <mauke> dmhouse: it's totally consistent, though
17:22:56 <monochrom> what is "one code"?
17:23:13 <Excedrin> what's wrong with array (10, ref 0) ?
17:23:15 <dmhouse> Anyway, bedtime.
17:23:16 <iulus> bah, we should be talking about Haskell anyway :P
17:23:28 <Saizan> jcreigh: in C you simply can't do dynamic allocation without pointers
17:23:31 <mauke> the rule is pretty simple: to declare a pointer to something, you first declare the something, then replace the variable name by "(*ptr)"
17:23:33 <monochrom> Yeah, haskell debugging
17:23:50 <mauke> I guarantee it.
17:23:52 <jcreigh> Saizan: right, in *C*. But I don't, for example, miss them at all in Haskell.
17:24:19 <arrakisdunes> its my bad english...i mean that i wrote one program when i make, make (of the makeFile) it give me that error
17:24:20 <monochrom> syntaxfree: my impression is that you are not a newbie.  Is that an accurate impression?
17:24:24 <Saizan> jcreigh: well it was my point, just have everything be implicitly a pointer :)
17:26:02 <jcreigh> Saizan: ah, okay. Carry on then. <g>
17:26:08 <mauke> let's say I want to write an IRC bot. should I just deal with servers, or should I introduce a "network" abstraction?
17:26:32 <monochrom> depends on what is a network abstraction
17:26:47 <monochrom> My feeling is Network.* is abstract enough.
17:26:57 <mauke> like "EFnet" instead of "irc.efnet.eu"
17:27:11 <sorear> irc.efnet.eu is better IMO
17:27:12 <mauke> a "network" could have multiple servers in it
17:27:32 <sorear> well, then use a list of servers.
17:27:34 <Saizan> well Network :: [Server] i think
17:27:37 <sorear> [String]
17:27:43 <Excedrin> will your bot connect to multiple servers on a single network for some reason?
17:27:57 <mauke> Excedrin: it probably shouldn't
17:27:57 <monochrom> Yes and no.  You will not hardcode the list of efnet servers anywhere in your code.  This means neither the network abstraction.
17:28:04 <sorear> When you say data Network , you are hardwiring the possible network.
17:28:05 <zeeeeeee> why do i sometimes get this error when trying to build my (multi-file) haskell app? "Can't find interface-file declaration for ..."
17:28:24 <zeeeeeee> it goes away once i remove all .o/.hi files, but i was curious why it comes up
17:28:34 <sorear> sorear-lambdabot: @seen #haskell
17:28:34 <sorear-lambdabot> In #haskell I can see sorear.
17:28:53 <zeeeeeee> (it also says "Probable cause: bug in .hi-boot file, or inconsistent .hi file")
17:29:12 <sorear> sorear-lambdabot: @quit
17:29:13 <monochrom> But you will have a network data type, and you create values of this type by parsing config files that list networks and servers.
17:29:50 <dons> > [1..] !! (10^5)
17:29:50 <mauke> why should I use networks instead of plain servers?
17:29:52 <lambdabot>  100001
17:29:59 <dons> > [1..] !! (10^6)
17:30:01 <lambdabot>  Exception: stack overflow
17:30:06 <dons> huh
17:30:08 <jcreigh> mauke: Well, most IRC networks seem to have a round-robin DNS setup (eg, I think irc.freenode.net is this way) that sends you to some arbitrary server in the network. So I'd just list a single hostname, and extend it later if you need to.
17:30:21 <iulus> ?src (!!)
17:30:22 <lambdabot> xs     !! n | n < 0 = undefined
17:30:22 <dons> something weird's happening there
17:30:22 <lambdabot> []     !! _         = undefined
17:30:22 <lambdabot> (x:_)  !! 0         = x
17:30:22 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:30:23 <monochrom> This is useful because if brown.freenode.net kicks you or whatever, you will want to try green.freenode.net etc.
17:30:30 <arrakisdunes> its my bad english...i mean that i wrote one program when i make, make (of the makeFile) it give me the error:  /usr/bin/ld: Undefined symbols: ___DISCARD__ collect2: ld returned 1 exit status. Can someone help me?
17:30:50 <xic> @hoogle GhcMode
17:30:51 <lambdabot> No matches found
17:31:06 <mauke> monochrom: yeah, but do the plugins need to know about that?
17:31:19 <iulus> dons: is Int able to carry a 10^6?
17:31:37 <monochrom> plugins?
17:31:37 <mauke> > 10^6 ::Int
17:31:37 <sorear> > 10^9 :: Int
17:31:38 <lambdabot>  1000000
17:31:39 <iulus> nevermind, it definitely is
17:31:39 <lambdabot>  1000000000
17:31:44 <sorear> > 10^10 :: Int
17:31:46 <lambdabot>  1410065408
17:31:49 <dons> nothing ays it's Int anyway
17:31:59 <mauke> monochrom: yeah, what's a bot without plugins? :-)
17:32:00 <sorear> :ty (!!)
17:32:01 <iulus> :t (!!)
17:32:03 <lambdabot> forall a. [a] -> Int -> a
17:32:06 <dons> ah sorry
17:32:06 <iulus> that does
17:32:17 <dons> I was looking at my code that doesn't have that constraint :}
17:32:18 <monochrom> That's a weird definition.
17:32:19 <iulus> (although part of me questions why)
17:32:42 <sorear> something tells me Cale knows
17:33:00 <Cale> what do I know?
17:33:10 <dons> > [1..] !! (10^6) -- bug?
17:33:12 <lambdabot>  Exception: stack overflow
17:33:34 <monochrom> I don't know.  Some plugins don't want to know anything.  Some plugins want to know networks but not servers.  Some plugins want to know servers.  Some plugins want to know networks and servers too.
17:33:51 <iulus> and why :t (!!) includes an Int instead of an Integer or (Integral a) => a
17:34:06 <jcreigh> Befores most function in Prelude are limited it Int?
17:34:10 <jcreigh> *Because
17:34:26 <sorear> Cale: why (!!) uses Int
17:34:53 <dons> hysterical reasons
17:34:57 <dons> there's genericIndex isn't there?
17:35:02 <Cale> sorear: It's not expected that you'll have a list index larger than an Int.
17:35:03 <jcreigh> yeah, I think so
17:35:04 <dons> :?hoogle generic
17:35:11 <dons> ?hoogle generic
17:35:12 <lambdabot> Data.Generics.Aliases.Generic :: type Generic c
17:35:12 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
17:35:12 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
17:35:24 <brainly-green> cadadadar
17:35:25 <Cale> If you do, then it will likely take a very long time for that index operation to happen.
17:35:42 <monochrom> arrakisdunes: I am afraid you have given too little information.  To boot, it is not even clear which compiler you use.
17:35:56 <dons> ok, your challenge today, should you choose to accept it, is to work out what's wrong here:
17:36:00 <dons> xs     .!. n | n < 0 = Nothing
17:36:00 <dons> []     .!. _         = Nothing
17:36:00 <dons> (x:_)  .!. 0         = Just x
17:36:00 <dons> (_:xs) .!. n         = xs .!. (n-1)
17:36:00 <dons> main = print $ [1..] .!. (10^6)
17:36:36 <dons> $ ghc -no-recomp -o stack -O A.hs
17:36:40 <dons> $ ./stack
17:36:40 <dons> Stack space overflow: current size 8388608 bytes.
17:36:40 <dons> Use `+RTS -Ksize' to increase it.
17:37:22 <olliej> dons: wtf
17:38:08 <monochrom> This is very odd.
17:38:12 <arrakisdunes> monochrom : my makefile is: HaLeX_LIB    = .
17:38:12 <arrakisdunes> HaLeX_TARGET = ./bin/bibtex
17:38:12 <arrakisdunes> bibTex:
17:38:12 <arrakisdunes> 	ghc --make                          \
17:38:12 <arrakisdunes>             -I$(HaLeX_LIB) -i$(HaLeX_LIB)   \
17:38:12 <arrakisdunes>             -package util                   \
17:38:15 <arrakisdunes>             -O2                             \
17:38:17 <arrakisdunes>             -fglasgow-exts                  \
17:38:18 <arrakisdunes>             tp.hs        \
17:38:20 <arrakisdunes>             -o $(HaLeX_TARGET)
17:38:22 <arrakisdunes> clean:
17:38:24 <arrakisdunes> 	rm *.o  \
17:38:25 <mauke> :(
17:38:26 <arrakisdunes>            *.hi
17:38:29 <allbery_b> @paste please
17:38:35 <lambdabot> http://paste.lisp.org/new/haskell
17:38:36 <jcreigh> arrakisdunes: in the future, please use a pastebot.
17:38:43 <arrakisdunes> okis osry
17:39:28 <olliej> dons: any idea how big each stack frame is?
17:39:48 <dons> note that:
17:39:54 <monochrom> You enter "make bibTex" and you get linker error?
17:39:54 <dons> {-# OPTIONS -fbang-patterns #-}
17:39:55 <dons> at xs     !n | n < 0 = Nothing
17:39:55 <dons> is of now is of no help.
17:40:01 <dons> s/no/
17:40:20 <dons> (also revealed a bug in bang pattern parsing with infix  ops)
17:40:21 <olliej> dons: what are you using as an irc client?
17:40:27 <nornagon> is of w is of no help?
17:40:29 <dons> olliej: irssi, why?
17:40:39 <olliej> dons: i'd swear it's transmitting backspaces
17:40:41 <dons> slow client sorry
17:40:44 <lisppaste2> arrakisdunes pasted "MakeFile error" at http://paste.lisp.org/display/34282
17:40:46 <allbery_b> you're  passing ^? throigh uninterpreted
17:40:49 <monochrom> Your 0x007f characters are getting through
17:40:54 <dons> wifi delay messes with irssi's timeout for esc chars
17:41:01 <olliej> dons: ah
17:41:17 <nornagon> dons's output looks fine here
17:41:28 <zeeeeeee> is there a better way of changing a value deep in a data structure? eg: appState { rootWidget = (rootWidget appState) { statusBar = (statusBar $ rootWidget appState) { caption = "hello" } } }
17:41:48 <monochrom> To be proper, U+007f is delete, U+0008 is backspace
17:42:05 <olliej> monochrom: :p
17:42:42 <nornagon> > readHex "007f"
17:42:43 <lambdabot>  [(127,"")]
17:43:02 <zeeeeeee> basically i'm just doing (as expressed in most imperative langs): appState.rootWidget.statusBar.caption = "hello"
17:44:26 <monochrom> arrakisdunes: if you omit -O2, what will happen?
17:44:28 <arrakisdunes> monochrom: yes, when i do  "make bibTex"  give me a linker error
17:44:30 <olliej> dons: so that function is borking itself?
17:45:12 <arrakisdunes> monochrom: same error
17:45:38 <olliej> dons: ?
17:45:42 <xic> ghc-6.6: panic! (the 'impossible' happened)
17:45:52 <clanehin> zeeeeeee: it depends on the situation, it might be better to represent you widgets using a different data structure, or simply write setter functions to shorten the syntax
17:46:17 <monochrom> OK, sorry, I know something is wrong, but I don't know where.
17:46:25 <zeeeeeee> :(
17:46:38 <zeeeeeee> ok, thanks clanehin
17:47:02 <dons> olliej: I'm not sure what's going on. Looks like something's broke
17:47:09 <monochrom> I don't think the makefile has a problem.  I think the libraries used have a problem.
17:47:14 <clanehin> updates work that way for a reason: the update to the record requires that the entire record be copied, so they encourage you to update many fields at once
17:47:30 <arrakisdunes> monochrom: thks anyway ;)
17:47:38 <brainly-green> watch the way I gravitate-hahahaha HAA
17:47:46 <brainly-green> whoops wrong channel
17:47:52 <xic> anyone know where i can find a working hello world example of ghc api?
17:48:12 <dons> there's an example on the haskell.org wiki somewhere
17:48:53 <monochrom> ghc api = Language.Haskell.* ?
17:48:59 <clanehin> on the other hand, haskell's ability to do things very generically allows you to work around a lot of biolerplate; if you could show me more of the code in the pastebin I might be able to make a concrete suggestion
17:49:08 <xic> dons: seems to be outdated
17:49:33 <zeeeeeee> clanehin: ok, gimme a moment
17:52:12 <monochrom> Oh nice, Language.Haskell.* is not ghc api
17:53:24 <lisppaste2> zeeeeeee pasted "simple curses application, or: why is haskell state so painful?" at http://paste.lisp.org/display/34285
17:53:59 <zeeeeeee> clanehin: those are the main modules in my app, but the function of interest should be mkMainWidget
17:54:54 <arrakisdunes> monochrom: i forgot to say i'm in a mac os x
17:55:03 <zeeeeeee> er, mkMainScreen
17:55:16 <dons> zeeeeeee: nice, but looks over engineered in my opinion :)
17:55:30 <zeeeeeee> dons: really? :(
17:55:40 <monochrom> That will add ghc itself as a possible culprit :)
17:55:41 <dons> I wonder if vty, being pure haskell, would be simpler
17:56:08 <dons> the curses code i've written tends to lead to curses gunk style code, too much state, all based on side effects
17:56:28 <zeeeeeee> dons: well, CF does stand for curses framework...but i've never heard of vty, i'm reading up on it now
17:56:38 <dons> hmp3 uses a pretty printer to abstract over screen construction. that was one useful thing I found
17:56:53 <dons> you build the screen strings using pretty printer combinators, then curses just dumps the result
17:57:01 <dons> so no need to interleave IO curses calls
17:58:51 <monochrom> If you over-engineer, you should really over-engineer, i.e., if you define a nested record as your state, you should for each field provide a pair of getter-setter function.
17:59:16 <Cale> modify :)
18:03:23 <xic> @hoogle stringToPackageId
18:03:25 <lambdabot> No matches found
18:03:57 <clanehin> The fact that every single function is monadic (or constant) concerns me.  You would do better to have a single IO function that plots stuff to the screen.  Build it all up using pure functions, and you'll never need to modify anything.
18:04:39 <zeeeeeee> Cale: i don't think that would help much with these nested updates....
18:05:25 <Cale> zeeeeeee: I was just adding that to the getter/setter list
18:06:39 <clanehin> It looks a lot like my old java programs, with data structures that explicitly limited what I could draw to the screen (i.e. your "top line", "bottom line"), and slowly the walls closed in on me and crushed my soul
18:07:26 <zeeeeeee> clanehin: i am also very aware of (and frustrated by) this tendency. i find myself constantly reorganizing my code.
18:08:12 <clanehin> Instead, have a function "topLine" that puts stuff in the top line, but have the lines just be a list or something; then you can come back later and write a "secondLine" or "firstColumn" or whatever
18:09:36 <clanehin> ten years from now plotting curses text diagonally might be in vogue . . .
18:10:56 <bd_> ?where base64
18:10:57 <lambdabot> I know nothing about base64.
18:10:59 <bd_> ?where sha1
18:11:00 <lambdabot> I know nothing about sha1.
18:11:16 <zeeeeeee> clanehin: i see, you mean the UI structure ought to be more dynamic
18:11:40 <zeeeeeee> i was also considering this, since i was hoping to write a curses UI builder as part of CF
18:12:19 <clanehin> zeeeeeee: right, the data structure doesn't have to enforce the visual consistency of whatever you plot; let your eyes do that
18:15:30 <dons> bd_ you looking for the crypto package?
18:15:49 <bd_> dons: possibly :)
18:18:03 <dons> ?where crypto
18:18:04 <lambdabot> http://www.haskell.org/crypto
18:26:34 <Saizan> question on HAppS, from the tutorial it seems that all the requests are forwarded to a single function with several cases, if i want something more modular, should i write my own "dispatch" policy or is there a variation of simpleHTTP that does it?
18:28:44 <zeeeeeee> dons: oh btw i thought hmp3 was a pleasant surprise in how clear it was to understand. `draw`ing strings was simple and effective
18:28:54 <Cale> I'm not sure, but it doesn't seem likely to be all that hard to whip up some custom url-handling scheme.
18:31:20 <zeeeeeee> i wanted to explore how to juggle substantially larger state (HState is small, flat, mostly unchanging, and in a global MVar!)
18:32:01 <zeeeeeee> the views (Elements) were also tightly coupled with the app model
18:33:22 <Saizan> Cale: true, an association list, maybe a tree
18:34:30 <Saizan> mmh, is there a way to get a function by its name?
18:34:47 <dons> zeeeeeee: yeah. that's true
18:34:47 <araujo> none i know of
18:35:11 <dons> the global MVar is a bit sneaky on my part too. simulating a threadsafe state monad with a global variable : who'd a thunk it!?
18:36:11 <jcreigh> Saizan: yeah, you just reference it. :)
18:36:20 <jcreigh> > map product [[1,2,3],[4,5,6]]
18:36:21 <lambdabot>  [6,120]
18:36:26 <jcreigh> see? :P
18:36:45 <Saizan> kidding me?:P
18:36:52 <jcreigh> (but you want String -> (some type sig here), right?)
18:37:01 <Saizan> (yeah)
18:37:11 <zeeeeeee> heh...i also looked at riot (suggested by someone here), which also has no decoupling of UI and app states. it has a tree for a data model, but the way it manipulates this tree was depressing (bunch of boilerplate for mutations, including expanding/collapsing/adding/removing nodes). i find i am just starting to run into similar issues. my primary goal is to achieve clear, compact, 'scalable' code, and not performance (though i can't imagine performance w
18:37:12 <zeeeeeee> ill be very good if everything stays pure)
18:37:13 * monochrom plays with the GHC api
18:37:20 <jcreigh> well, that's pretty impossible, but thankfully, it's usually bad style, so you don't need to do it often.
18:38:03 <Saizan> it's nice when you have to dispatch, so you don't have to explicitly declare the relations
18:38:13 * monochrom types at the ghci prompt ":b GHC" and gets stuff :)
18:38:17 <xic> monochrom: did you get it working?
18:38:35 <dons> riot was written by tuomov as he was learning haskell though, so its *very* imperative/C-ish, imo
18:38:38 <jcreigh> oh, is this for HAppS?
18:38:47 <monochrom> No, I have only started "import GHC" :)
18:38:48 <xic> would you guys say that Ruby is elegant?
18:38:53 <xic> monochrom: oh
18:38:58 <Saizan> jcreigh: yes
18:38:59 <jcreigh> tuomov? auther of ion?
18:39:10 <dons> ?join #happs
18:39:15 <dons> jc	yeah
18:39:22 <dons> he even helped with the second lambdabot paper :)
18:39:24 <dons> and on yi
18:39:39 <monochrom> :b GHC  has so much stuff my scroll buffer is overflowed :)
18:40:22 <araujo> xic, i think so
18:40:36 <xic> monochrom: good thing i found the source: http://darcs.haskell.org/ghc/compiler/main/GHC.hs
18:40:52 * monochrom 's old unix training activates.  "script" comes to the rescue!
18:41:51 <jcreigh> xic: well, I haven't done any large projects with Ruby, but the whole "blocks aren't lambdas in subtle, confusing ways!" thing kinda gets to me. But it's nicer than, say, Perl and currently my "scripting language" of choice.
18:42:19 <xic> jcreigh: did they fix the unicode bugs yet?
18:42:20 <dons> sorear_: how do we get @join to work these days?
18:42:22 <jcreigh> *is currently
18:42:24 <monochrom> Excellent, now I have captured a whole lot of names and type signatures.
18:42:26 <zeeeeeee> dons: i did notice that; everything was monadic, and i think that might be affecting my own code :) HSCurses' example ContactManager was somewhat similar
18:42:46 <jcreigh> xic: Unicode "bugs"? Lack of unicode support, you mean?
18:42:47 <sorear> it's still @join
18:42:57 <dons> ?seen lambdabot
18:42:58 <lambdabot> Yes, I'm here. I'm in #ltu, #happs, #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
18:43:01 <dons> does it need the channel name?
18:43:07 <dons> s/server/
18:43:15 <dons> ?join #happs
18:43:20 <dons> doesn't want to work :/
18:43:20 <sorear> no, it defaults like everything else
18:43:39 <dons> ah, maybe i'm over the limit
18:43:44 <dons> oh, it already joined!
18:43:52 <xic> jcreigh: yeah, that
18:43:57 <dons> there's a #ltu now?
18:44:08 <nostrademons> apparently.  news to me too
18:44:21 <monochrom> First I have to find out what's outdated in the examples and update them.
18:44:22 <iulus> just started, I think
18:44:26 <dons> and lambdabot's already there... ?
18:44:41 <xic> heh
18:44:44 <dons> lambdabot knows more about what's going on than I do
18:44:45 <heatsink> somebody invited lambdabot without dons? faux pas!
18:44:46 <iulus> they discussed it in the SecondLife discussion
18:44:47 <nostrademons> she gets around
18:45:04 <iulus> haha, and suddenly there's a surge in the #ltu membership
18:45:14 <heatsink> What's ltu?
18:45:20 <iulus> lamba-the-ultimate.org
18:45:24 <Cale> d
18:45:28 <iulus> lambda-the-ultimate.org, rather
18:45:29 <heatsink> ah
18:46:10 <sorear> iulus: you're talking to ltu
18:46:23 <sorear> nm, ack
18:46:45 * sorear is finding multichannel in ircii rather confusing
18:47:53 <monochrom> ltu has a channel?!
18:52:14 <sorear> @part #ltu
18:52:21 <sorear> @join #ltu
18:52:35 <sorear> command character confusion!
18:54:11 <sorear> @users
18:54:11 <lambdabot> Maximum users seen in #haskell: 296, currently: 268 (90.5%), active: 48 (17.9%)
18:55:00 <jcreigh> xic: Not that I know if. I haven't had any need to process any text documents that weren't ASCII encoded, so I wouldn't know.
18:57:06 <bd_> hmm
18:57:07 <bd_> ghc-6.6: /usr/lib/Crypto-3.0.3/ghc-6.6/HSCrypto-3.0.3.o: unknown symbol `Cryptozm3zi0zi3_GentooziPrivateziNewBinaryziBinary_getBits_closure'
18:58:33 <sjanssen> none of the Haskell implementations have fixed their Unicode bugs either
18:58:51 <dons> bd_ missing --make or -package crypto ?
18:58:52 <xic> which bugs?
18:59:07 <bd_> dons: it was in ghci
18:59:08 <bd_> ghci -package Crypto -package HTTP
18:59:23 <dons> -pacakge NewBinary
18:59:25 <sjanssen> xic: no unicode IO
18:59:49 <xic> that's not important. anyway, haskell isn't meant to be used for production
18:59:59 <bd_> using the crypto ebuild in http://www.haskell.o
18:59:59 <bd_> rg/~gentoo/gentoo-haskell/
19:00:16 <sjanssen> xic: I disagree on both counts :)
19:01:49 <dons> xic, I guess you know there are entire companies based upon haskell... (not many, but they are out there)
19:02:03 <bd_> ... I note that the gentoo ebuild seems to have removed a few build-deps
19:02:03 <vincenz> funky!
19:02:05 <sorear> vty has full support for unicode output, using (ick ick blah blah) an application-level utf-8 codec
19:02:06 <vincenz> dons: check this
19:02:12 <vincenz> > 1
19:02:13 <vincenz> >
19:02:14 <lambdabot>  1
19:02:15 <vincenz> >
19:02:17 <dons> bd_ you have NewBinary package installed?
19:02:19 <vincenz> >   -- comment
19:02:24 <lambdabot>  Parse error
19:02:26 <jcreigh> of course, that are entire companies based upon COBOL...
19:02:27 <dons> ah right
19:02:29 <bd_> dons: no, and apparently the ebuild let me get away with that :)
19:02:33 <sorear> >
19:02:38 <vincenz> > -- comment
19:02:39 <sorear> >
19:02:46 <sjanssen> sorear: now we need to attack the ick ick blah blah part ;)
19:02:48 <dons> just misses the eol on the comment I think
19:02:52 <lambdabot>  Parse error
19:03:00 <vincenz> > 1 + 1 -- comment
19:03:10 <sorear> > 1 + 1 {- comment -}
19:03:13 <sorear> >   {- comment -}
19:03:16 <sjanssen> lambdabot adds an EOL
19:03:18 <vincenz> lag?
19:03:18 <lambdabot>  2
19:03:19 <bd_> ?where lang
19:03:27 <sjanssen> it's just that the empty string is not a valid expression
19:03:33 <vincenz> sjanssen: yes it is
19:03:34 <vincenz> >
19:03:38 <lambdabot>  2
19:03:42 <vincenz> that returns nothing
19:03:44 <lambdabot>  Parse error
19:03:48 <vincenz> if she weren't spammed
19:03:55 <bd_> ?where lang-any
19:03:56 <lambdabot> I know nothing about lang.
19:03:59 <vincenz> >
19:04:02 <vincenz> > 1
19:04:05 <vincenz> >  -- ocmment
19:04:11 <vincenz> nothing, 1, parse error
19:04:27 <bd_> ?where newbinary
19:04:32 <lambdabot> I know nothing about lang-any.
19:04:38 <lambdabot>  1
19:04:41 <lambdabot>  Parse error
19:04:43 <vincenz> see :)
19:04:48 <dons> ?where NewBinary
19:04:57 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
19:05:08 <vincenz> > 1 -- comment on exp should work
19:05:11 <sjanssen> vincenz: the empty string really isn't an expression
19:05:13 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
19:05:19 <lambdabot>  1
19:05:21 <sjanssen> vincenz: and note that it does
19:05:22 <bd_> these ebuilds seem to be a bit out of date in places :)
19:05:38 <vincenz> sjanssen: it does, and the empty string works, just not the empty string with comment
19:05:38 <dons> vincenz: ok ok. please stop. :) submit a patch to handle [] if you wish.
19:05:51 <vincenz> mmk
19:06:10 <dons> it should behave like this:
19:06:11 <dons> Prelude>
19:06:11 <dons> Prelude> -- test
19:06:11 <dons> Prelude> :q
19:06:36 * vincenz doesn't have 6.6 or fps
19:06:41 <sjanssen> vincenz: "> " responds with Parse error.  seems like the correct behavior to me
19:06:49 <vincenz> sjanssen: no it doesn't
19:06:53 <vincenz> ">       "
19:06:55 <vincenz> >
19:07:03 <vincenz> responds with nothing
19:07:08 <vincenz> > 1
19:07:10 <lambdabot>  1
19:07:32 <sjanssen> vincenz: are you sending a space after the > ?
19:07:36 <vincenz> yes
19:07:37 <vincenz> plural
19:07:48 <vincenz> don't believe me, send it yourself :)
19:07:55 <sjanssen> >
19:08:08 <vincenz> > 1
19:08:09 <lambdabot>  1
19:08:23 <sjanssen> vincenz: now try it in a /msg
19:08:35 <vincenz> funky
19:08:50 <vincenz> anyways
19:08:50 <iulus> you can /msg lambdabot?
19:08:55 <dons> yeah
19:08:56 <vincenz> I'll take a look tomorrow
19:09:02 * vincenz >>= sleep >>= date
19:09:17 <vincenz> :)
19:09:33 <sjanssen> dons: did you catch that?  lambdabot responds differently to "> " in channel versus a private message
19:09:57 <Saizan> also :t works only in channel
19:10:25 <sjanssen> hmm, do we have separate code handling these?
19:11:07 <Saizan> i suspect separated "parsers" at least
19:11:31 <dons> sjanssen: yeah, the privmsg cases must have slightly different preprocessing
19:11:36 <dons> it's a bit of a wart
19:11:45 <dons> (remember that > is treated specially)
19:12:40 <dons> secondly, :t is a contextual plugin, which only works in channel (it doesn't filter /msg streams)
19:13:04 <sjanssen> is > contextual in channel?
19:13:23 <dons> yep
19:13:26 <dons> ah no.
19:13:33 <Saizan> contextual?
19:13:46 <dons> its handle specially in Base.hs before the contextual stuff was added
19:14:12 <dons> I do see some (inexplicable) differences in handling of > between /msg and normal
19:14:15 <dons> I'll fix that now
19:15:03 <sjanssen> isn't sorear planning to refactor message dispatching code of this sort?
19:15:14 <dons> not sure. I've not heard anything
19:19:46 <sorear> no
19:20:05 <sorear> I'd only been looking at the part between IRC and Plugin/Base
19:20:20 <bd_>         # drop unnecessary deps
19:20:20 <bd_>         sed -i 's/, QuickCheck, HUnit, NewBinary//' "${S}/crypto.cabal"
19:20:21 <bd_> hm.
19:20:25 <sjanssen> I think this is a bit related, yeah?
19:20:47 <putas_vinho_verd> hello
19:22:01 <sorear> hi!
19:22:11 <dons> well, the > handling could become a contextual plugin
19:22:25 <dons> and we'd add extra contextual handling for /msg queries
19:22:30 <dons> then that would unify hte interfaces
19:22:38 <sorear> in the most nebulous reaches of my speculation, ?foo is a contextual plugin
19:22:44 <dons> but I want to fix a couple of things, and implement this Map stuff for @let first
19:23:45 <bd_> hm, why is it that cabal, when building a package with a library and executables, rebuilds the relevant portions of the library for every executable it builds?
19:23:58 <putas_vinho_verd> i have to do one main using getOpt,with one file input and some options (-f for file out or -s for screen), someone can help how to do it??
19:24:04 <sjanssen> sorear: one meta contextual plugin to, in the darkness, bind them?
19:24:10 <mauke> @index liftIO
19:24:10 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:24:30 <sorear> sjanssen: muahahaha!
19:24:39 <dons> bd_, nope (?)
19:24:47 <dons> sorear: yeah. maybe. a Dispatch plugin eh?
19:25:05 <dons> lambdabot *almost* needs a rewrite of Base.hs ...
19:25:07 <dons> ah well
19:25:18 <sorear> dons: why do we use a Message typeclass vs. coercing all contextual-ish messages to a common type?
19:25:27 <bd_> dons: er, it says it's rebuilding them at least
19:25:30 <dons> I thin kthe idea was for xmpp
19:25:34 <bd_> and... the amount of time it takes is about on par
19:25:41 <dons> bd_, ah executables. maybe
19:25:54 <dons> if you build multiple executables
19:26:00 <dons> (I think its a known wart)
19:26:10 <sorear> dons: in take-1, Base was completely eliminated, the dispatch code was folded into LMain, the IRC code was folded into Plugin/IRC
19:26:23 <bd_> anyway, who decided it would be a good idea for the dev-haskell/crypto thing to extract a private copy of newbinary into the build directory, patch the cabal files to use it, and apparently not install it correctly, rather than just depending on newbinary?
19:27:18 <dons> weird
19:27:37 <sorear> @go xmpp
19:27:39 <lambdabot> http://www.xmpp.org/
19:27:39 <lambdabot> Title: XMPP.org
19:27:55 <bd_> no wonder I wasn't able to actually load it otherwise
19:28:06 <sorear> XML!?
19:28:45 <dons> talk to ADept, he uses it over jabber or something
19:28:58 <dons> crazy russian hackers
19:29:39 <sorear> it = lambdabot?
19:29:52 <dons> yeah
19:30:17 <sorear> @seen ADept
19:30:18 <lambdabot> I saw ADept leaving #haskell 11h 3m 10s ago, and .
19:30:25 <putas_vinho_verd> i have to do one main using getOpt,with one file input and some options (-f for file out or -s for screen), someone can help how to do it??
19:30:43 <mauke> putas_vinho_verd: what's your question?
19:31:02 <putas_vinho_verd> how to do this main!!
19:31:35 <mauke> that sounds like "write my program for me"
19:32:01 <dons>  putas_vinho_verd do you have an example of how to use GetOpt handy?
19:32:10 <putas_vinho_verd> no
19:32:13 <dons> ?source GetOpt
19:32:18 <dons> there's some examples in the source
19:32:35 <putas_vinho_verd> ?source GetOpt
19:32:41 <dons> ?source System.Console.GetOpt
19:32:41 <lambdabot> GetOpt not available
19:32:51 <lambdabot> GetOpt not available
19:32:52 <lambdabot> http://darcs.haskell.org/packages/base/System/Console/GetOpt.hs
19:32:53 <dons> http://darcs.haskell.org/packages/base/System/Console/GetOpt.hs
19:33:14 <dons> also, on a recent blog I wrote. let me find the url..
19:33:23 <putas_vinho_verd> nice;)
19:33:50 <dons> in particular, have a look at $example2
19:33:56 <dons> that's the "best practice"
19:34:26 <sorear> Jabber says it's super-simple, then gives me a total of 250 pages of RFC's.  sigh.
19:34:33 <dons> http://haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
19:34:35 <lambdabot> Title: High-level option handling with GetOpt - HaskellWiki, http://tinyurl.com/ynhvsx
19:34:40 <dons> putas_vinho_verd: ^^
19:36:03 <dons> > -- test
19:36:04 <lambdabot>  Parse error
19:36:08 <dons> >
19:36:16 <putas_vinho_verd> thks dons
19:36:53 <sjanssen> dons: I'd say the first test is expected behavior, yeah?
19:38:29 <dons> I guess I don't care much either way :)
19:45:05 <sorear> @users
19:45:05 <lambdabot> Maximum users seen in #haskell: 296, currently: 265 (89.5%), active: 5 (1.9%)
19:47:23 <mauke> wow, Data.Time is evil
19:49:49 <kfish> mauke, how so?
19:50:19 <mauke> it contains nothing related to time() and friends
19:50:44 <sorear> System.Time ?
19:50:51 <sorear> time() is impure
19:51:02 <mauke> yep, that's what I found after that :-)
19:59:41 <mauke> why is asks called asks?
20:00:30 <audreyt> because it asks the environment for some value?
20:00:32 <Saizan> get was taken?
20:00:49 <audreyt> also if you can get something you can conceivably put something back
20:01:00 <audreyt> but if you asks for something, there's less hint for modification
20:01:03 <augustss> because axe makes no sense?
20:01:45 <mauke> no, "ask" makes sense. but "asks" doesn't return multiple values, so it's not like "x" -> "xs"
20:01:51 <sjanssen> augustss: axe is in Control.Monad.Bleeder
20:01:58 <dons> :)
20:02:09 <augustss> lol
20:02:15 <audreyt> mauke: ask/asks get/gets are pairs
20:02:30 <audreyt> they are verbs, so -s is not plural suffix
20:02:45 <Saizan> ?type gets
20:02:47 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
20:03:03 <audreyt> I persume they can be spelled getWith askWith
20:03:29 <audreyt> but the -s can probably be contrued to mean "specific" or something
20:03:57 <audreyt> it's shorter to type and still (somewhat) grammatically correct
20:03:59 <kfish> ask and get are conceptually similar, is it possible that they could they be rolled into a typeclass?
20:04:21 <Saizan> gets f = get >= return . f ?
20:04:31 <audreyt> kfish: sure, you can write an instance that makes all State into Reader
20:04:43 <sorear> kfish: IOW you want MonadState to be a subclass of MonadReader ?
20:04:49 <sjanssen> kfish: it'd complicate the overloading for ReaderT (StateT ...)
20:04:51 <audreyt> and then just use ask
20:04:57 <audreyt> but, what sjanssen said.
20:05:26 <kfish> well, i was thinking more that both reader and state implement the same typeclass
20:05:30 <kfish> and similarly writer and state
20:05:58 <sorear> writer isn't like state at all
20:06:12 <sorear> put "foo!" >> put "foo!"  ===> put "foo!"
20:06:23 <sorear> tell "foo!" >> tell "foo!"  ===> tell "foo!foo!"
20:06:48 <audreyt> well, writer can be made into state iff we have a monoid that simply discards older values
20:06:54 <audreyt> but that's hardly useful
20:07:35 <kfish> true :-)
20:07:56 <sorear> it's... write only memory!
20:08:03 <audreyt> aka, a Sink, iirc
20:08:38 <audreyt> write-only memory is perfect for write-only programs!
20:11:59 <Saizan> however the types match so you could define those typeclasses and implement them
20:17:35 <bos> are there idioms or considerations of taste that indicate when one should or shouldn't use the Maybe monad?
20:18:11 <bos> i have a pattern matching function that uses Maybe () because it short-circuits nicely on a failed match
20:18:42 <bos> is this clean, or does it smell bad and need a shower?
20:19:19 <Philippa> what's the concern you're trying to short-circuit for?
20:19:48 <bos> failure to match.
20:19:53 <Philippa> ...
20:19:55 <Philippa> more detail?
20:20:14 <bos> i.e. it's a normal failure. i just turn the result into a Bool with isJust later.
20:20:50 <Philippa> yeah. Would a big case statement with an _ -> False case be a sane implementation?
20:21:10 <bos> yes, but more verbose.
20:21:31 <Philippa> even using pattern guards?
20:22:11 <bos> let me show you what it currently looks like.
20:23:04 <bos> http://pastebin.com/852461
20:23:12 <bos> paste.lisp.org is down.
20:23:54 <bos> the code as it stands works, i just have no clue of the taste question.
20:24:52 <bos> btw, data MatchTerm = MatchLiteral String (in case it's not obvious)
20:25:48 <nostrademons> what does the function do?
20:25:50 <Philippa> what's wrong with using && instead?
20:26:55 <bos> i can't use && because >>= feeds the residual string returned by matchLiteral back into match
20:27:00 <dons> Maybe () maps nicely to Bool though
20:27:09 <dons> and then you can | match "foo" "bar" = ...
20:27:18 <bos> at least, i could use it, but i'd need to capture the result with "let" or "where"
20:27:41 <Philippa> I'd consider catching it with let to be more idiomatic than the monad
20:27:42 <dons> I often use:
20:27:46 <dons> matches r p = unsafePerformIO $ do
20:27:46 <dons>     res <- execute r p
20:27:46 <dons>     case res of
20:27:46 <dons>         Left err       -> error $ "regex execute failed: " ++ show err
20:27:48 <dons>         Right Nothing  -> return False
20:27:55 <dons>         Right (Just _) -> return True
20:28:00 <dons> for some regex 'matching' code
20:28:23 <dons> or using the old Text.Regex:
20:28:24 <dons> matches' r s | Just _ <- matchRegex r s = True
20:28:24 <dons>              | otherwise                = False
20:28:32 <dons> (uses pattern guards, then maps to Bool)
20:28:50 <dons> (which is like Maybe () no?)
20:28:51 <bos> hmm, we had unsafePerformIO back in the day, but bugger if i can remember what it does. short circuits when error is called?
20:29:07 <dons> no no, in this case it just hides a (pure) IO call
20:29:15 <mauke> haha, now I have a "seen" plugin without a bot around it
20:29:36 <dons> since matching a regex better be referentially transparent (so its ok to make it pure, even if it is an FFI call)
20:29:48 <bos> ah, right, so you're calling out via the ffi.
20:29:54 <dons> ?hoogle unsafePerformIO
20:29:54 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:30:04 <dons> yeah, 'execute' is calling regex.c
20:30:21 <bos> so you think Maybe () is ok, and phillipa thinks not?
20:30:29 <dons> I think, hmm, use Bool :)
20:30:34 <bos> heh.
20:30:47 <dons> and you can simply convert Maybe () to bool using a pattern guard, matches' r s | Just _ <- matchRegex r s = True
20:31:26 <bos> hmm.
20:31:36 <dons> bos, btw, nic e quote about "Run, don't walk, to haskell.org" :)
20:31:41 <nostrademons> what's the function doing?
20:31:43 <bos> heh.
20:32:03 <bos> nostrademons: it's matching a glob pattern against a string.
20:32:12 <bos> since haskell doesn't have glob.
20:33:01 <zeeeeeee> how do i write something like data D = forall a. forall b. Class a, Class b => D a b?
20:33:11 <zeeeeeee> (that doesn't parse)
20:33:15 <bos> so i have some code that turns a glob pattern into a [MatchTerm], and more that goes from [MatchTerm] -> String -> Maybe ()   (or Bool)
20:33:41 <dons> data D = forall a b . (C a , C b) => D a
20:33:51 <dons> D a b
20:33:51 <zeeeeeee> dons: thanks
20:34:27 <zeeeeeee> er wait, i did try that already: "Ambiguous constraint `Widget w'"
20:34:36 <dons> bos, oh you're writing some kind of [a] regex code?
20:34:38 <zeeeeeee> (where C = Widget)
20:34:41 <bos> dons: yes
20:34:45 <bos> fnmatch = ((.) isJust) . match . peephole . parseGlob
20:35:06 * dons is scared of isJust
20:35:09 <bos> i know there's a glob routine in MissingH, but i didn't want to cop out and turn the glob into a regexp.
20:35:14 <zeeeeeee> oh sorry, i ommitted w from the right hand side
20:35:22 <dons> nothing in any of the 5-10 regex libs out there?
20:35:39 <bos> the purpose was more as a coding exercise than anything else.
20:35:50 <bos> also, i expect it's faster to stay native.
20:36:17 <nostrademons> matchLiteral can probably be replaced by Data.List.isPrefixOf
20:36:36 <dons> > "foo" `isPrefixOf` "foobar"
20:36:38 <lambdabot>  True
20:36:54 <sorear> Data.ByteString.Char8.isPrefixOf is faster still
20:36:55 <bos> nostrademons: but it returns the residual
20:37:24 <bos> i.e. i need a routine that does isPrefixOf, but also gives me the suffix of the longer of the two strings.
20:37:24 <dons> sorear: you know why I guess ;)
20:37:30 <dons> inlinePerformIO $ withForeignPtr x1 $ \p1 ->
20:37:30 <dons>         withForeignPtr x2 $ \p2 -> do
20:37:30 <dons>             i <- memcmp (p1 `plusPtr` s1) (p2 `plusPtr` s2) (fromIntegral l1)
20:37:30 <dons>             return $! i == 0
20:37:36 <dons> :}
20:38:15 <dons> bos, hmm, splitAt, then == ?
20:38:20 <bos> yeah, keeping your ByteString as a C pointer is nice.
20:38:59 <bos> i don't know how to concisely express the same thing with splitAt.
20:40:22 <dons> > let splat s t = splitAt t (length s) in splat "foo" "foobar"
20:40:23 <lambdabot>  Couldn't match `[a]' against `Int'
20:40:34 <dons> > let splat s t = splitAt (length s) t in splat "foo" "foobar"
20:40:36 <lambdabot>  ("foo","bar")
20:41:01 <zeeeeeee> if i am in a function of type (StateT a IO b), is there an easier way to call into a function (foo :: State a c) than doing (get >>= return (evalStateT foo))? some sort of lifting?
20:41:17 <zeeeeeee> er, return . evalStateT foo
20:41:29 <sorear> zeeeeeee: yes, but it's not in the standard libs.
20:41:30 <dons> > let splat s t | s `isPrefixOf` t = Just (splitAt (length s) t) | otherwise = Nothing in splat "foo" "foobar"
20:41:31 <lambdabot>  Just ("foo","bar")
20:41:36 <zeeeeeee> evalState! not evalStateT
20:41:39 <zeeeeeee> sorear: what are you referring to?
20:41:47 <dons> > let splat s t | s `isPrefixOf` t = Just (splitAt (length s) t) | otherwise = Nothing in splat "foo" "fobbar"
20:41:49 <lambdabot>  Nothing
20:41:51 <sorear> MetaLift
20:42:15 <sorear> but IIRC the usual approach is to rewrite foo to have type MonadState m a => m c
20:42:52 <bos> dons: yeah.
20:44:07 <Saizan> but splat runs throgh s twice if it match
20:44:21 <nostrademons> lazy eval?
20:44:41 <Saizan> what lazy eval has to do with length?
20:45:12 <nostrademons> not entirely sure, but wouldn't it memoize the traversal?
20:45:32 <Saizan> afaik lazy eval is not memoization
20:47:14 <sorear> restricted memoization is the difference between call-by-name and true laziness.
20:47:42 <sorear> > let x = 2 + 2 in x + x -- a truly lazy language will only calculate 2+2 once
20:47:43 <lambdabot>  8
20:48:06 <Mitar> why does mapM putStrLn ["a","b","c"] outputs [(),(),()] at the end?
20:48:17 <sorear> > let x y = y + y in x 2 + x 2 -- even true lazy languages aren't required to notice *this*
20:48:18 <lambdabot>  8
20:48:28 <monochrom> Because that's the destiny of mapM
20:48:29 <sorear> Mitar: it doesn't
20:48:29 <dons> Mitar: putStrLn returns ()
20:48:31 <dons> you want mapM_
20:48:35 <bos> @goole mapM_
20:48:37 <lambdabot> http://www.zvon.org/other/haskell/Outputprelude/mapM__f.html
20:48:37 <lambdabot> Title: Haskell : mapM_
20:48:37 <sorear> it evaluates to [(),(),()]
20:48:41 <bos> @hoogle mapM_
20:48:41 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:48:41 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
20:48:48 <sorear> but it only prints a\nb\nc\n
20:48:59 <augustss> @src mapM_
20:48:59 <lambdabot> mapM_ f as = sequence_ (map f as)
20:49:08 <sorear> @src mapM
20:49:08 <lambdabot> mapM f as = sequence (map f as)
20:49:12 <sorear> @src sequence
20:49:12 <lambdabot> sequence ms = foldr k (return []) ms
20:49:12 <lambdabot>     where
20:49:12 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
20:49:25 <sorear> @src sequence_
20:49:26 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:49:26 <Mitar> aha, so [(),(),()] came from interactive session
20:49:28 <Mitar> :-)
20:49:56 <sorear> mapM would work fine in a compiled program BUT it would be inefficient, so use mapM_ anyway.
20:50:04 <Mitar> yes ... i will
20:50:06 <olliej> > mapM_ putChar "foo\n"
20:50:08 <lambdabot>  <IO ()>
20:50:13 <olliej> > mapM putChar "foo\n"
20:50:15 <lambdabot>  <IO [()]>
20:50:35 <Mitar> ok, one more question, how can i prepend the line with its line number (so it will be 1a 2b 3c ...)
20:50:44 <olliej> > mapM putStrLn ["foo", "wibble"]
20:50:46 <lambdabot>  <IO [()]>
20:50:56 <olliej> :t mapM putStrLn ["foo", "wibble"]
20:50:58 <lambdabot> IO [()]
20:51:22 <sorear> Mitar: mapM_ putStrLn $ zipWith (\num str -> show num ++ str) [1..] my_lines
20:51:46 <sorear> > zipWith (\num str -> show num ++ str) [1..] ["foo", "bar", "baz", "quux"]
20:51:47 <lambdabot>  ["1foo","2bar","3baz","4quux"]
20:51:56 <Saizan> isn't there zipWithM?
20:51:57 <augustss> @pl \num str -> show num ++ str
20:51:57 <lambdabot> (++) . show
20:51:57 <Mitar> ahh, zipWith, I was looking at zip and it was not the thing
20:51:58 <Mitar> :-)
20:52:09 <Mitar> thanks
20:52:29 <sorear> @type zipWithM_
20:52:30 <lambdabot> forall (m :: * -> *) b a c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m ()
20:53:01 <sorear> zipWithM_ (\num str -> putStrLn (show num ++ str)) [1..] my_lines -- like this
20:53:26 <augustss> @type zipWithM_ (putStrLn . (++) . show) [1..] ["a"]
20:53:27 <lambdabot>     Couldn't match `String' against `[Char] -> [Char]'
20:53:27 <lambdabot>       Expected type: a -> String
20:53:29 <sorear> @pl \num str -> putStrLn (show num ++ str)
20:53:29 <lambdabot> (putStrLn .) . (++) . show
20:53:52 <Mitar> currently I have something like
20:53:53 <Mitar> mapM_ putStrLn (map (concat . intersperse "\t" . (map show)) (transpose frames))
20:54:00 <augustss> yep, gotta trust LB instead of my own head
20:54:18 <Mitar> (this is still without line number)
20:54:24 <dons> > zipWith (printf "%4d %s") [(1::Int)..] (unlines "a\b\nc\nd\n"))
20:54:26 <lambdabot>  Parse error
20:55:05 <augustss> dons, the printf man :)
20:55:34 <bd_> :t printf
20:55:35 <lambdabot> forall r. (PrintfType r) => String -> r
20:55:36 <augustss> > zipWith (printf "%4d %s") [(1::Int)..] (unlines "a\b\nc\nd\n")
20:55:36 <lambdabot>  Couldn't match `String' against `Char'
20:56:00 <Saizan> > zipWith (printf "%4d %s") [(1::Int)..] (lines "a\b\nc\nd\n")
20:56:01 <dons> lines "a\b\nc\nd\n"
20:56:02 <lambdabot>  Add a type signature
20:56:13 <bd_> @hoogle printf
20:56:13 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
20:56:13 <lambdabot> Text.Printf :: module
20:56:13 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
20:56:22 <augustss> > zipWith (printf "%4d %s") [(1::Int)..] (lines "a\b\nc\nd\n") :: [String]
20:56:23 <lambdabot>  ["   1 a\b","   2 c","   3 d"]
20:56:48 <Saizan> @instances PrintfType
20:56:49 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
20:57:06 <zeeeeeee> wow, "Record update for the non-Haskell-98 data type `Blah' is not (yet) supported"
20:58:29 <sorear> @instances-importing Text.Printf PrintfType
20:58:30 <lambdabot> (a -> r), IO a, [c]
20:58:39 <zeeeeeee> i think i've done (blah { a = b }) a hojillion times, so what does this mean?
20:58:40 <Mitar> why I have the felling that this is ugly: mapM_ putStrLn (map (concat . intersperse "\t" . (map show)) (zipWith (\f fs -> f:fs) [1..] (transpose frames)))
20:58:40 <dons> > zipWith (printf "%d  %s") [(1 :: Integer)..] (lines "a\nb\nd\n") :: [String]
20:58:42 <sorear> @list instances
20:58:42 <lambdabot>  ["1  a","2  b","3  d"]
20:58:42 <lambdabot> instances provides: instances instances-importing
20:59:13 <zeeeeeee> (where blah were of my own data type, Blah)
20:59:29 <sorear> mapM_ putStrLn (map (concat . intersperse "\t" . (map show)) (zipWith (\f fs -> f:fs) [1..] (transpose frames))) =
20:59:37 <sorear> mapM_ putStrLn (map (concat . intersperse "\t" . (map show)) (zipWith (:) [1..] (transpose frames))) =
21:00:06 <sorear> mapM_ putStrLn $ map (concat . intersperse "\t" . (map show)) $ zipWith (:) [1..] (transpose frames) =
21:00:11 <Mitar> sorear ... true :-)
21:01:19 <sorear> mapM_ putStrLn $ map (intercalate "\t" . (map show)) $ zipWith (:) [1..] (transpose frames) =
21:01:26 <sorear> @type intercalate
21:01:28 <lambdabot> Not in scope: `intercalate'
21:01:36 <dons> ?src intercalate
21:01:37 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:02:20 <augustss> mapM_ putStrLn $ map (intercalate "\t" . map show) $ zipWith (:) [1..] $ transpose frames
21:02:37 <sorear> putStr $ unlines $ map (intercalate "\t" . (map show)) $ zipWith (:) [1..] $ transpose frames =
21:02:38 <Mitar> intercalate? first time i head about it
21:02:50 <zeeeeeee> hmm, does this have anything to do with my use of existential types?
21:02:52 <augustss> it's very new
21:02:53 <sorear> (putStr . unlines . map (intercalate "\t" . (map show)) . zipWith (:) [1..] . transpose) frames =
21:03:01 <sorear> @pl (putStr . unlines . map (intercalate "\t" . (map show)) . zipWith (:) [1..] . transpose)
21:03:02 <lambdabot> putStr . unlines . map (intercalate "\t" . map show) . zipWith (:) [1..] . transpose
21:03:06 <augustss> zeeeeeee: have you used GADT syntax?
21:03:07 <sorear> awww
21:03:15 <dons> ?let intercalate xs xss = concat (intersperse xs xss)
21:03:16 <lambdabot> Defined.
21:03:19 <zeeeeeee> augustss: i don't know what that is
21:03:55 <augustss> zeeeeeee: then you probably haven't.  :)  existential type could be enough to disable record update
21:04:17 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/data-type-extensions.html#existential-quantification
21:04:19 <lambdabot> Title: 7.4. Extensions to data types and type synonyms, http://tinyurl.com/t6nce
21:04:35 <sorear> "At the moment, record update syntax is only supported for Haskell 98 data types, so the following function does not work:"
21:05:37 <sorear> A suprisingly large number of questions are answered in the GHC User's Manual.
21:06:24 <zeeeeeee> thanks for the pointer
21:07:32 <zeeeeeee> augustss: hmm, how is the GADT syntax related?
21:08:12 <augustss> i know records are not fully supported with GADT syntax (last time I checked)
21:08:25 <zeeeeeee> ah, gotcha
21:09:19 <sorear> GADT syntax also subsumes existential types, and inherits their restrictions.
21:10:04 <audreyt> the ghci debugger is _so_ useful
21:10:12 * audreyt finally got motivation hacking pugs because of it
21:10:35 <sorear> how do you get the breakpoints to work?
21:10:41 <audreyt> we were at a point where existing "print/trace" mechanism simply is not useful anymore
21:11:01 <sorear> I try :break add and nothing happens
21:11:06 <audreyt> uhm? I just pulled trunk, tuned mk/build.mk to add
21:11:06 <audreyt> GhciWithDebugger = YES
21:11:26 <augustss> it just worked for me too
21:11:26 <sorear> I didn't change that :(
21:11:48 <audreyt> and ~/.ghci should say
21:11:49 <audreyt> :set -fdebugging
21:11:50 <audreyt> that's all
21:11:50 <sorear> when you have to add a breakpoint, where do you put it?  beginning of function
21:11:57 <audreyt> whatever line you like
21:11:59 <audreyt> even inner functions
21:12:01 <audreyt> that's godsend
21:12:11 <audreyt> actually you can stop at whichever subexpression you like
21:12:14 <audreyt> using column notation
21:12:49 <sorear> I thought the reason my bp's weren't working was I was using the wrong column!
21:12:55 <audreyt> heh
21:12:57 <audreyt> column is optional
21:13:03 <audreyt> you just need to recompile with build.mk
21:13:12 <audreyt> gaal on #perl6 observed that it really should be default
21:13:19 <audreyt> I don't know why the HQ did not turn the default on
21:13:30 <audreyt> just so bindist chasers can test it more
21:14:22 <audreyt> also :sprint is godsend too
21:15:06 <audreyt> mnislaih++
21:15:15 <audreyt> lemmih++ JaffaCake++
21:15:41 <dons> audreyt: very interesting report. should be on by default eh? in ghci?
21:15:48 <dons> maybe we can manage to make that happen during next week's hackathon
21:15:49 <audreyt> no in builds
21:15:55 <audreyt> mk/build.mk that is
21:16:00 <dons> mnislaih Lemmih and JaffaCake should be there..
21:16:03 <audreyt> -fdebugging should be on by default I think
21:16:08 <dons> yeah
21:16:08 <audreyt> but it largely doesn't matter
21:16:14 <audreyt> what matters is the build option
21:16:22 <dons> I think you may be the first serious user :)
21:16:23 <audreyt> since hacking build.mk is relatively much higher entry barrier
21:16:31 <audreyt> well, that's not the first time :)
21:16:40 <dons> feel free to drop an experience report via haskell-cafe@
21:16:49 <audreyt> "pugs exists so I can try out every single new feature in ghc" etc
21:16:53 <dons> before the hackathon, might give the debugging team some motivation/ideas
21:16:56 * sorear is preparing to rebuild GHC-head
21:18:18 <audreyt> dons: might be, though I prefer actually finish this metaobject-protocol system in Haskell
21:18:38 <audreyt> a MOP for haskell is something I _think_ POPL people will be interested at
21:18:41 <audreyt> and it's just 1 wk away
21:19:25 <audreyt> so hack = higher priority :)
21:19:34 <audreyt> and I'll see you there, no?
21:19:37 <sorear> Deleting GHC takes a *long* time...
21:21:36 <sorear> audreyt: where can I find the list of all the valid names in build.mk?
21:22:35 <audreyt> oh wait. GhciWithDebugger=YES is already on
21:22:41 <audreyt> it just needs reconfigure
21:22:45 <sorear> like GhciWithDebugger, etc?
21:22:52 <audreyt> gaal: try bindist; it should actually come with debugger
21:23:05 <audreyt> sorear: mk/config.mk.in
21:23:25 <audreyt> gaal: "ghci -fdebugging" should do
21:24:02 <Shimei> I wonder why it is strangely satisfying when I can do "Prelude> let cons = \a -> \b -> \f -> f a b" in Haskell. :P (Reading _The_Implementation_of_Functional_Programming_Languages_ by SPJ).
21:27:00 <dons> audreyt: indeed you will. POPL/PADL/DAMP I'll be at
21:27:21 <dons> as will dcoutts, Igloo, Lemmih, et al
21:27:25 <audreyt> woot
21:27:34 <audreyt> looking forward to see y'all
21:28:00 <dons> yeah!
21:28:02 <audreyt> I'll be in conf hotel 13~20 jan
21:28:21 <dons> ok. cool. I *think* that's where I'm at (the oxford guys booked it, so gotta chase up the details)
21:29:00 <audreyt> Plaza Nice
21:29:17 <dons> yeah, that's the one I think
21:29:34 <audreyt> and I just got my first camera
21:30:05 <audreyt> so while my prowess at it is ~nil, I'd still want to take some pictures of y'all :)
21:31:06 <dons> hehe. yeah, I got one a couple of months back (for the SoC-athon),and plan to get some hackathon-in-actoin shots :)
21:31:13 <olliej> OliverB_: yo?
21:35:59 <audreyt> dons: so was it the impression during SoC summit that google, whilst primarily a C++ shop, has a fair number of people interested in Haskell?
21:36:32 <audreyt> <- ask because going to give talks of not-yet-determined-topic in google.tw in Feb and google.us in May
21:37:09 <dons> audreyt: they seem to be primarily C++ and Python, but have lots of smart people interested in all sorts of things
21:37:11 <audreyt> and I suspect they're more interested in pugs-the-system than pugs-the-language
21:37:17 <dons> yeah
21:38:25 <audreyt> so they don't really have a subsystem, internal or external, developed in haskell yet?
21:38:37 <audreyt> (amazon.com has, I was told)
21:38:53 <Lemmih> dons: I won't make it for Nice, unfortunately.
21:40:43 <dons> hmm, I was told that they use no haskell for anything official. there are side projects though
21:40:52 <dons> audreyt: amazon eh? that's news
21:41:14 <audreyt> dons: yeah. but they didn't say which part; probably not an outside-facing part
21:41:26 <dons> any url? :) or is it top secret weapon material?
21:41:39 <audreyt> no, most likely internal-use system
21:41:59 <dons> fair enough
21:42:13 <dons> linux-circa-1994 ;)
21:44:59 <bos> how do you get ghci to import a stdlib module without having to write a source file that imports it?
21:45:25 <mauke> :m +Module
21:45:34 <bos> thank you.
21:45:35 <monochrom> Whew!  I have updated most of GHC/As_a_library !
21:46:06 * monochrom now has many evil ideas about using the GHC API!
21:47:07 <monochrom> For example starts an interactive session that runs TH that starts an interactive session that runs TH that ...
21:50:20 <dons> monochrom++
21:50:33 <monochrom> whee!
21:51:16 <bos> could people take a look at this? http://www.serpentine.com/blog/2007/01/05/getting-started-with-installing-third-party-haskell-packages/
21:51:21 <lambdabot> Title: clever, witty blog title 禄 Blog Archive 禄 Getting started with installing thir ..., http://tinyurl.com/y9mrur
21:51:25 <bos> i'm trying to leave breadcrumbs for my fellow newbies.
21:52:12 <bos> so this is "haskell packages for dummies".
21:57:15 <dons> yeah, having a look
21:58:04 <bos> thanks.
22:00:27 <dons> have you seen the Cabal / package guide I wrote from the developer's perspective?
22:00:42 <bos> yes.
22:00:46 <bos> it's nice.
22:01:03 <dons> and the creating-a-deb-from-cabal guide? http://pupeno.com/blog/the-lambda-revolution-episode-v-the-deb-strikes-back/
22:01:06 <lambdabot> Title: The lambda revolution, Episode V, the deb strikes back &mdash; Pupeno's web site, http://tinyurl.com/y4xxd2
22:02:07 <dons> ok. this looks good. you might even want to copy the text over to haskell.org, and create a new page "Cabal for beginers" or "Installing Haskell packages"
22:02:34 <bos> thanks. will do.
22:02:41 <dons> I'll see what I can do to get those bogus 'Not found' errors removed from cabal. IThey're a frequent src of worry :}
22:03:34 <dons> :module +System.CPUTime.Rdtsc can be written more canonically as :m + System.CPUTime.Rdtsc
22:03:54 <dons> (tab completion might even work on the module name)
22:04:02 <bos> i followed the output of ghci's ":?"
22:04:23 <dons> yeah, you can shorten any ghci command to its unique prefix
22:04:34 <bos> i figured as much.
22:04:42 <dons> mm, and the tab completion does work!
22:04:46 <bos> but using the full name in the example is better pedagogy :-)
22:04:47 <dons> Prelude> :m + Data.L
22:04:47 <dons> Data.LTree      Data.LargeWord  Data.List
22:04:47 <dons> Prelude> :m + Data.List
22:04:54 <bos> ooh, yummy
22:04:56 <dons> (modules I didn't even know about!)
22:05:17 <dons> and two tabs show everything currently in scope, I think
22:05:20 <dons> oh, this is very useful
22:05:46 <bos> is it gauche to put one's own stuff up on programming.reddit.com?
22:05:51 <dons> mm
22:05:52 <dons> Prelude Data.LargeWord> :k Word256
22:05:53 <dons> Word256 :: *
22:05:53 <dons> Prelude Data.LargeWord> maxBound :: Word256
22:05:53 <dons> 115792089237316195423570985008687907853269984665640564039457584007913129639935
22:05:55 <dons> :)
22:06:00 <dons> bos, nope.
22:06:01 <dons> go for it
22:06:09 <dons> its adroit
22:07:55 <bd_> hmm
22:08:06 <bd_> Data.LargeWord isn't in http://haskell.org/ghc/docs/latest/html/libraries/ ?
22:08:13 <sorear> I love the number of 50+-year-old documents on reddit
22:08:22 <sorear> nope.
22:08:23 <dons> its in crypto
22:08:27 <bd_> oh
22:08:30 <bd_> no wonder :)
22:09:34 <dons> I'm adding it to lambdabot right now, since its so much fun!
22:09:47 <dons> (probably should be in base/Data/Word.hs though)
22:09:54 <dons> mm. that'd be an easy patch too
22:10:29 <bd_> Hmm, I'd expect LargeKey to be using strict fields... or would that be premature optimization? :)
22:10:52 <bos> wow, galois.com contains a pile of former glasgow fp people.
22:11:06 <bos> who'd have thought they'd all want to work for the NSA?
22:11:54 <dons> bd_ yeah, I though the same thing.
22:12:07 <dons> seems like a reasonable thing to do
22:12:08 <monochrom> Compiling and linking a simple program importing GHC yields a 12MB executable ^^
22:12:12 <bd_> doesn't make much sense for half of a number to be the bottom :)
22:13:07 <dons> I notice several Num methods are missing to
22:14:34 <glguy> I'm not sure if the articles on Reddit that pick one language, and then attempt to show how another languge is better reallly ever accomplish much...
22:14:58 <bos> especially not if they're written by the newly infatuated :-)
22:15:17 <glguy> and it's probably just a misconception that everyone writting these posts just found the languages they are writting about
22:15:32 <dons> yeah, they are more experience reports "you can do X with A. I used to do it with B too"
22:16:01 <dons> any further conclusions about B in relation to A tend not to work
22:16:02 <glguy> but that's how it feels to me
22:16:09 <sorear> Absolute Truth: forall a b . (Language a, Language b) => a `isBetterThan` b
22:16:53 <dons> the main thing from that current post is that a guy can go from 0 to "production" haskell in a week :)
22:17:20 * sorear gives dons a funny look
22:17:39 <glguy> that recent "First impressions article" just stirred a bunch of people up "Haskell <?> Perl"..
22:17:52 <glguy> and arguably accomplished nothing more
22:17:55 <dibblego> let them be
22:18:01 <dons> yeah. not helpful. I've decide myself never to mention other languages when talking about Haskell in blog posts
22:18:10 <Korollary> I agree. Who gives a rat's monad
22:18:19 <dons> (the On Syntax article was a nice example of how it all goes horribly wrong)
22:19:04 * dons adds *LargeWord> maxBound :: Word1024  ;)
22:19:31 <monochrom> That is a royally large number :)
22:19:57 <monochrom> Is someone trying to 0wn reddit.com by cracking some RSA key?
22:20:40 <dibblego> "reddit.com 0wn3d by 1-week old Haskell programmer"
22:20:44 <bos> was the "on syntax" article the one that mixed up foldr and foldl?
22:20:51 <dibblego> bos, no, that was me
22:20:52 * dibblego runs
22:21:10 <bos> yeah, oopsie :-)
22:21:23 <dibblego> I felt like such a dick head when I woke up and saw the comments
22:21:31 <bos> folds are much more subtle than that, anyway :-)
22:22:16 <monochrom> You've won the Flame War Starter award of Year 2007!
22:22:35 <dibblego> who has?
22:22:43 <monochrom> hee hee
22:22:54 <dibblego> aren't you talking about Haskell - First Impressions?
22:23:49 <glguy> yeah
22:26:33 <sorear> hi!
22:26:46 <dons> > maxBound :: Word1024 -- go lambdabot!
22:26:50 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
22:27:08 <dons> > maxBound :: Word2048
22:27:13 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
22:27:38 <dons> I was able to add Word1024 in 1 line of code. Haskell rules
22:28:13 <dibblego> what's the line?
22:28:18 <sorear> > let log10 x = if (x < 10) then 1 else 1 + log10 (x `div` 10) in log10 $ toInteger (maxBound :: Word2048)
22:28:23 <lambdabot>  617
22:28:34 <dons> type Word1024 = LargeKey Word512 Word512
22:28:45 <dons> and the deriving takes care of the rest
22:29:17 <dons> (its a rather well written little module, LargeWord)
22:29:25 <sorear> newtype F x = LargeKey x x deriving(...)
22:29:42 <sorear> newtype Du f x = Du (f (f x)) deriving(...)
22:29:45 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/LargeWord.hs
22:29:47 <lambdabot> http://tinyurl.com/w4wjt
22:29:52 <treitter> hi everyone
22:30:11 <treitter> is there any way to cast IO Strings to Strings without assigning to a variable first?
22:30:26 <dons> you have to run the action
22:30:28 <sorear> (Du (Du (Du (Du (Du (Du (Du Word2048))))))) -- haskell has 256kbit nums in 3 extra lines!
22:30:29 <dons> ie.. with >>= or <-
22:30:35 <dons> sorear: hehe nice :)
22:30:50 <sorear> higher kinded types rock.
22:30:59 <monochrom> Wha...oaaa!  So you use LargeKey WordN WordN to build Word2N?
22:31:04 <dons> treitter: what kind of thing are you doing?
22:31:26 <dibblego> data LargeyKey a b = LargeKey !a !b -- is ! a strict annotation or something?
22:31:30 <sorear> Haskell does have full type lambdas.  All that's missing is normal-form equality.
22:31:32 <dons> yeah
22:31:39 <monochrom> Yes, ! is a strict annotation
22:31:44 <dibblego> is it a Haskell98 thing or GHC?
22:31:48 <sorear> h98
22:31:50 <dons> (I added that, its missing from the orH98
22:31:56 <dons> slow wifi /me cries
22:32:03 <monochrom> hahah
22:32:18 * sorear eschews everything wireless
22:32:28 * monochrom is always wireless
22:32:29 <treitter> dons: like trying to do "foo <- getLine ; bar foo"  (where bar is a function) in a single line
22:32:38 <dons> getLine >>= bar
22:32:39 <sorear> fmap bar getLine
22:32:54 <sorear> I'm wrong, dons is right
22:32:57 <treitter> dons: what's the name of the >>= operator?
22:32:59 <monochrom> I bought and configured the WAP myself.  The key is to buy and configure the WAP yourself.
22:33:02 <sorear> 'bind'
22:33:06 <monochrom> >>= is bind
22:33:08 <dons> ?undo do foo <- getLine ; bar foo
22:33:09 <lambdabot> getLine >>= \ foo -> bar foo
22:33:11 <treitter> right. I've heard that one before :)
22:33:20 <dons> ?. pl undo do foo <- getLine ; bar foo
22:33:21 <lambdabot> bar =<< getLine
22:33:26 <dons> :)
22:33:27 <monochrom> As iulus says, IO, IO, it's off the bind we go...
22:33:30 <sorear> my wap 'randomly' becomes slow ... I suspect interference
22:33:50 <dibblego> sorear, my microwave does that
22:34:02 <dons> monochrom: "Wha...oaaa!" ?
22:34:07 <dibblego> it appeared random at first, but I soon found the problem
22:34:18 <treitter> dons: so =<< is also a valid bind in the other direction?
22:34:26 <dons> yeah, its just >>= flipped
22:34:30 <treitter> dibblego: microwaves and WiFi use the same frequency
22:34:33 <monochrom> There are about three wireless networks around me.  I look at their channels and choose mine to avoid the pack.
22:34:42 <dons> ?src (=<<)
22:34:43 <sorear> I use 100baseT personally, but my father doesn't want to run lots of cables :(
22:34:43 <lambdabot> f =<< x = x >>= f
22:34:47 <treitter> dibblego: ..like basically every other consumer radio device now
22:34:58 <sorear> dons++ @src rocks
22:35:10 <dibblego> treitter, yep, that's why I was hesitant to blame the microwave immediately :)
22:35:10 <monochrom> Two of them are like using the default (6).  Suck be to them. :)
22:35:25 <treitter> dons: I think it's going to take me a little bit to get used to reversable operators :)
22:35:39 <dons> heh
22:35:47 * dons hands treitter flip
22:35:50 <dons> ?src flip
22:35:51 <lambdabot> flip f x y = f y x
22:36:15 <dons> > flip map "haskell" toUpper
22:36:16 <lambdabot>  "HASKELL"
22:36:35 <dibblego> > let tcartbus = flip (-) in 7 `tcartbus` 8
22:36:37 <lambdabot>  1
22:36:42 <treitter> monochrom: non-randomized defaults are also an issue with WiFi. Add in that some wireless routers try to pick an unused channel.. go, go gadget race condition! :)
22:36:57 <monochrom> "Wha...oaaa!" is an exclamation meaning "awesome"
22:37:23 <dons> hehe :)
22:37:31 <dons> a bit like Phoar ?
22:38:01 <monochrom> Well it begins with "What?" meaning one is baffled.
22:38:33 <monochrom> But before "What?" is finished, one suddenly sees the light, and that transfigures into "Whoa!"
22:38:33 <treitter> dons: cool. Some of the little things like flip are probably going to be handy :)
22:38:49 <dons> ?let for = flip map
22:38:51 <lambdabot> Defined.
22:39:00 <dons> > for [1..10] show
22:39:01 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
22:39:30 <treitter> I've just got to play around with Haskell more often.. finally got around to it again tonight, and I've basically got to do this tutorial again before I can do anything meaningful
22:39:39 <treitter> dons: heh.. cool
22:39:42 <glguy> > [1..10] >>= show
22:39:43 <lambdabot>  "12345678910"
22:40:21 <treitter> glguy: so bind isn't _only_ for IO-tainted data?
22:40:27 <glguy> heavens no
22:40:31 <dons> its for all monads!
22:40:32 <glguy> bind works on all Monads
22:40:37 <dons> ?src [] >>=
22:40:37 <lambdabot> Source for this function is not available.
22:40:38 <glguy> \o/
22:40:43 <dons> ?src [] >Dbah>=
22:40:44 <lambdabot> Source for this function is not available.
22:40:50 <treitter> glguy: pff. Says you! I'm a Haskell pro! :)
22:41:01 <monochrom> Dbah?  :D
22:41:03 <treitter> *cough*
22:41:10 <Korollary> The right place to start is typeclasses.
22:41:11 <glguy> Haskell pro?
22:41:22 <treitter> glguy: just kidding
22:41:30 <glguy> that's more like it (-;
22:41:30 <sorear> haskell has an extremely powerful overloading system
22:41:44 <treitter> anything I say that sounds dumb is probably even dumber than it sounds
22:41:59 <dons> ?src IO.>>=
22:42:00 <lambdabot> m >>= k     = bindIO m k
22:42:09 <olliej> do happy generated parser have any external dependencies?
22:42:11 <dons> ?src (->).>>=
22:42:12 <glguy> ?index bindIO
22:42:12 <lambdabot> f >>= k = \ r -> k (f r) r
22:42:12 <lambdabot> bzzt
22:42:14 <monochrom> w00t
22:42:15 <sorear> +, -, etc work on all numeric types, >>=, return, work on all monadic types (you'll figure out what that means eventually, we hope), etc.
22:42:25 <sorear> ?src bindIO
22:42:25 <lambdabot> bindIO (IO m) k = IO ( \ s ->
22:42:25 <lambdabot>   case m s of
22:42:25 <lambdabot>     (# new_s, a #) -> unIO (k a) new_s
22:42:25 <lambdabot>   )
22:42:28 <dons> ?src [].(>>=)
22:42:29 <lambdabot> m >>= k     = foldr ((++) . k) [] m
22:42:47 <sorear> ?src Maybe.(>>=)
22:42:48 <lambdabot> Source for this function is not available.
22:42:58 <sorear> ?src Maybe.>>=
22:42:58 <lambdabot> Source for this function is not available.
22:42:58 <Korollary> boo
22:43:15 <dons> ?src Maybe >>=
22:43:16 <lambdabot> Source for this function is not available.
22:43:20 <dons> ?src Either >>=
22:43:20 <lambdabot> Left  l >>= _ = Left l
22:43:21 <lambdabot> Right r >>= k = k r
22:43:31 <dons> (gotta add some more things, normalise the entries a bit)
22:43:37 <sorear> or, for a simpler case:
22:43:41 <sorear> ?src Int +
22:43:41 <lambdabot> Source for this function is not available.
22:43:42 <glguy> Nothing >>= _ = Nothing
22:43:43 <Korollary> buggy haskell software
22:43:44 <sorear> ?src Int.+
22:43:45 <lambdabot> Source for this function is not available.
22:43:47 <sorear> ?src Int.(+)
22:43:48 <lambdabot> Source for this function is not available.
22:43:53 <sorear> oh well..
22:43:54 <glguy> Just v >>= k = k v
22:44:07 <dons> ?src Int.==
22:44:08 <lambdabot> (==) = eqInt
22:44:11 <sorear> ?src State.(>>=)
22:44:11 <lambdabot> Source for this function is not available.
22:44:16 <sorear> ?src State >>=
22:44:16 <lambdabot> Source for this function is not available.
22:44:23 <sorear> ?src Control.Monad.State.State >>=
22:44:23 <lambdabot> Source for this function is not available.
22:44:40 <Korollary> ?src Vista.Root.exploit
22:44:41 <lambdabot> Source for this function is not available.
22:44:59 <sorear> ?src withPS
22:45:00 <lambdabot> Source for this function is not available.
22:45:13 <monochrom> ?src rumour
22:45:13 <lambdabot> Source for this function is not available.
22:45:14 <treitter> the fact that there's a Maybe function/operator intrigues me :)
22:45:21 <treitter> and/or scares me
22:45:29 <Korollary> treitter: which tutorial are you reading?
22:45:37 <sorear> [withPS] that was me trying to think of a lambdabot function quickly
22:45:39 <monochrom> scary stuff is good stuff
22:45:46 <treitter> Korollary: http://www.iceteks.com/articles.php/haskell/1
22:45:47 <lambdabot> Title: Introduction to Haskell [Page 1 of 6]
22:45:59 <sorear> Maybe isn't an operator, it's a functor!
22:46:21 * sorear babbles in arcane mathematics
22:46:26 <treitter> Korollary: it's a good starting point. I haven't found a good Next tutorial though
22:46:41 <sorear> ?where MetaTutorial
22:46:42 <lambdabot> I know nothing about metatutorial.
22:46:55 <sorear> ?wiki Metatutorial
22:46:56 <lambdabot> http://www.haskell.org/haskellwiki/Metatutorial
22:47:16 <sorear> ^^^ we're trying to make this the standard starting point
22:47:40 <Korollary> its empty?
22:48:16 <Korollary> oh its not
22:48:46 <sorear> ?wiki MetaTutorial
22:48:47 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
22:49:01 <sorear> argh, MediaWiki case sensitivity
22:49:30 <sorear> treitter: look at this next, give feedback if poor
22:50:01 <treitter> sorear: awesome. I will
22:50:08 <sorear> @version
22:50:16 <dons> http://programming.reddit.com/info/x8jx/details
22:50:22 <rizzix> ooh metatutorial is nice
22:50:35 <lambdabot> lambdabot 4p407, GHC 6.5 (OpenBSD i386)
22:50:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:50:43 <sorear> +4, ooh
22:50:47 <lambdabot> Title: Haskell: getting started with third-party packages (reddit.com)
22:51:15 <dons> ?src Maybe >>=
22:51:15 <lambdabot> (Just x) >>= k      = k x
22:51:15 <lambdabot> Nothing  >>= _      = Nothing
22:51:16 <sorear> what's his nick again
22:51:21 <dons> ?src -> >>=
22:51:21 <lambdabot> f >>= k = \ r -> k (f r) r
22:51:24 <sorear> ? [bryan o'sullivan]
22:51:24 <dons> that's bos
22:51:50 * Korollary urges dons to port hsplugins to 6.6
22:52:04 <monochrom> Nevermind monads.  Use arrows.  Come join the Dart Side!
22:53:12 <dpiponi> Never mind arrows. Use comonads. Cojoin the other side.
22:53:23 <monochrom> Hahaha that's great!
22:53:43 * sorear urges dons to add proper dependency support (a la modprobe) to hs-plugins
22:54:13 <sorear> ?remember dpiponi [<monochrom> Nevermind monads.  Use arrows.  Come join the Dart Side!] <dpiponi> Never mind arrows. Use comonads. Cojoin the other side.
22:54:20 <sorear> ?quote Cojoin
22:54:21 <lambdabot> dpiponi says: [<monochrom> Nevermind monads.  Use arrows.  Come join the Dart Side!] <dpiponi> Never mind arrows. Use comonads. Cojoin the other side.
22:54:48 <Korollary> Unit testing ?remember
22:55:02 <Korollary> we're so fallible
22:55:29 <sorear> huh?
22:55:45 <Korollary> I think you ran a ?quote just to make sure
22:55:53 <sorear> yeah :)
22:56:25 <sorear> but ?remember is the only command that doesn't give a satisfying "Done."
22:57:52 <sorear> gotta love tab completion: stefan@stefans:~/yank$ ghci yank.cabal
22:58:03 <Korollary> I wanna play with Scala, but I have to install JRE. Bleagh.
22:58:13 <sorear> oh, wait, gotta love CapsLock more
22:58:41 <Korollary> Numb3rs sucks.
22:59:24 <dpiponi> I kind of half like Numb3rs, though I only watched series 1.
23:00:12 <dons> "Funktors" -- Everybody uses categories everyday.
23:00:41 <Korollary> Season 1 was ok. Lately they've been sucking.
23:00:51 <sorear> no, it sucks.  I have 0 formal math training above calculus, and I can tell they have no research team.
23:01:28 <dpiponi> They had a research team on series one. But I expect they get overruled most of the time.
23:02:06 <Korollary> Also, Charlie is absolutely uninteresting.
23:03:18 <Korollary> Actually, none of their characters is interesting.
23:03:49 <dpiponi> Actually, I'm pretty surprised it got as far as the third season, so someone is watching it.
23:04:15 <Korollary> bad time slot
23:04:55 <Korollary> but yeah, someone is still watching.
23:04:57 <mauke> @hoogle TVar a -> (a -> a) -> STM ()
23:04:59 <lambdabot> No matches, try a more general search
23:05:10 <mauke> @hoogle TVar a -> (a -> b) -> STM ()
23:05:11 <lambdabot> No matches, try a more general search
23:06:40 <sorear> mauke:
23:06:51 <sorear> @hoogle TVar a -> (a -> a) -> STM a
23:06:51 <lambdabot> No matches, try a more general search
23:06:59 <sorear> wt?
23:07:11 <sorear> @hoogle (a -> a) -> TVar a -> STM a
23:07:12 <lambdabot> No matches, try a more general search
23:07:22 <sorear> @ty modifyTVar
23:07:23 <lambdabot> Not in scope: `modifyTVar'
23:07:24 <mauke> hmm?
23:07:31 <sorear> @ty Control.Concurrent.STM.modifyTVar
23:07:32 <lambdabot> Not in scope: `Control.Concurrent.STM.modifyTVar'
23:07:36 <sorear> @ty Control.Concurrent.STM.TVar.modifyTVar
23:07:38 <lambdabot> Not in scope: `Control.Concurrent.STM.TVar.modifyTVar'
23:08:46 <treitter> in the convention "(x:xs)", "xs" is a play on "excess", right?
23:08:54 <bos> here's a stupid question. why isn't there a foldrM?
23:08:56 <mauke> no, it's the plural of x
23:09:02 <Jessehk> How could I do this: "map (putStrLn . show) list" correctly?
23:09:13 <bos> since foldM is monadic foldl.
23:09:16 <mauke> Jessehk: mapM print list
23:09:23 <treitter> that's what this tutorial said. But I don't get that mnemonic
23:09:29 <Jessehk> mauke : Ah, I didn't know about mapM. Thanks
23:09:45 <mauke> actually, mapM_
23:09:56 <treitter> because x is the head of the list, and xs is the rest of it, right? How does that make xs the "plural" of x?
23:09:58 <sorear> print == putStrLn . show
23:10:19 <sorear> x is a representative object of type X, xs is a lot of them
23:10:32 <mauke> treitter: a list consists of one item, followed by more items
23:10:40 <mauke> well, or it's empty
23:10:45 <Jessehk> mauke : Why mapM_ ?
23:10:55 <mauke> because you don't care about the return values
23:11:16 <Jessehk> mauke : I mean, Why does the name have a trailing underscore?
23:12:23 <mauke> to indicate that there is no return value, I think
23:12:53 <Jessehk> Hm... Seems a bit cryptic to me.
23:12:56 <bos> so sequence has a don't-care variant sequence_ etc
23:13:03 <bos> it's just a naming convention, like fooM
23:13:31 <bos> and since _ is don't-care in a pattern, it makes some sense
23:13:41 <rizzix> yep
23:13:49 <Jessehk> bos : That's true...
23:15:06 <sjanssen> bos: that's a good explanation, I'll have to remember that one
23:16:07 <Korollary> I've had it with flash.
23:16:57 <olliej> what module is bounds in?
23:17:08 <sjanssen> @hoogle bounds
23:17:08 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
23:17:09 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
23:17:09 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
23:17:52 <sjanssen> olliej: Data.Array for the standard interface, Data.Array.IArray for the overloaded interface
23:18:23 <olliej> sjansen, cheers
23:20:26 <treitter> is there a way to do block comments?
23:20:44 <bos> > True {- yes -}
23:20:45 <Korollary> {- block comment -}
23:20:46 <lambdabot>  True
23:20:48 <sjanssen> {- like this treitter -}
23:21:39 <treitter> cool. Thanks
23:21:52 <bos> > "hmm." {-
23:21:52 <lambdabot>  Unterminated nested comment
23:22:13 <bos> dons: if i message that to lambdabot, it doesn't message me back.
23:22:32 <bos> treitter: block comments nest, as the above error implies
23:22:32 <sjanssen> bos: nice try :).  That hole was exploited and plugged months ago
23:22:47 <bos> actually, i wasn't trying to exploit anything.
23:23:40 <bos> lambdabot is stupidly ridiculously useful.
23:23:44 <sorear> besides, there are much fresher ones.
23:23:57 <mauke> @v
23:23:58 <lambdabot> "\"#$%&'()*+,\""
23:24:09 <sorear> > array (minBound::Int, maxBound) [(-3, 'a')]
23:24:11 <lambdabot> Terminated
23:24:15 <sorear> > array (minBound::Int, maxBound) [(1, 'a')]
23:24:17 <lambdabot> Terminated
23:24:18 <sjanssen> bos: I think we stumbled on to a similar issue earlier today.  try "> " in and out of the channel
23:24:20 <sorear> > array (minBound::Int, maxBound) [(3, 'a')]
23:24:22 <lambdabot> Terminated
23:24:28 <sorear> > array (minBound::Int, maxBound) [(-100000, 'a')]
23:24:29 <bos> ah.
23:24:30 <lambdabot> Terminated
23:24:33 <sorear> > array (minBound::Int, maxBound) [(0, 'a')]
23:24:35 <lambdabot>  internal error: EVACUATED object entered!
23:24:35 <lambdabot>     Please report this as a bug to...
23:24:42 <dons> ~[6~:)
23:24:49 <mauke> oh wow
23:24:52 <sjanssen> sorear: nice one
23:24:54 * sorear sympathizes
23:24:59 <dons> ?rememeber ghc internal error: EVACUATED object entered!
23:25:00 <lambdabot> Done memoising quote for `ghc', if that is their real name...
23:25:10 <dons> this bug is fixed in ghc 6.6
23:25:15 <mauke> @ghc
23:25:16 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
23:25:17 <treitter> bos: cool. That's something that always bugged me about C :)
23:25:39 <sorear> dons: you think I found this?
23:25:40 <mauke> treitter: what?
23:25:41 <dons> sorear: is that satisfying enough of a message? :)
23:25:53 <sorear> yes :)
23:25:54 <dons> '18:18  lambdabot> Done memoising quote for `ghc', if that is their real name..."
23:25:56 <treitter> mauke: you can't nest multi-line comments in C
23:26:07 <mauke> treitter: yeah, because that's a fucking stupid idea
23:26:12 <mauke> use #if 0 .. #endif instead
23:26:15 <sorear> haskell's lexer isn't regular
23:26:49 <sorear> > True {- {- -} Yeah comments nest, who cares about regularity! -}
23:26:49 <treitter> mauke: I know
23:26:50 <lambdabot>  True
23:27:21 <mauke> > () {- "hmm {-" -}
23:27:21 <lambdabot>  Unterminated nested comment
23:27:32 <mauke> so this isn't useful for disabling code
23:28:11 <sjanssen> yes, it will fail in those rare "{-" string literals
23:28:35 <sorear> dons: it's not fixed in 6.6
23:29:11 <sorear> HEAD segfaults instantly, 6.4.2 prints part of the array then segfaults, 6.6 "Illegal instruction"s
23:29:13 <mauke> and C-style comments will fail for those rare "*/" string literals
23:29:16 <JKnecht> 6.6 sound 'unstable'
23:29:18 <JKnecht> sounds
23:30:09 <mauke> the only way to "solve" this is to do it like OCaml and actually tokenize the contents of comments
23:30:17 <bos> dons: you need to post more in your blog, not the comments in reddit :-)
23:34:38 <dons> bos, hehe. ok. I'm just holding off atm, as I'm writing a longer article for the Monad.Reader coming up, but I'll blog in a few days about the Haskell Hackathon
23:37:08 <bos> it makes me sad that california is a backwater of functional programming. what little there is is all lisp.
23:37:45 <Excedrin> bos: how do you figure that?
23:37:54 <sorear> yeah, I'm from California!
23:39:12 <dons> bos, well, TheTallGuy is in Berkley I think (the Linspire/Haskell crowd)
23:39:20 <bos> Excedrin: the local universities don't produce any FPers.
23:39:47 <bos> and any FP people who drift in inevitably end up working in different languages,
23:39:48 <dons> but yeah, compared to say, .au or .se or the uk, its a backwater
23:40:01 <JKnecht> duh!
23:40:02 <dons> its been theorised that its due to the "Not invented here" syndrome
23:40:07 <dons> hence no erlang, ocaml or haskell
23:40:24 <bos> even the east coast of the US, and portland, are better off than here.
23:40:30 <dons> except for some notable places like Portland
23:40:31 <dons> yeah
23:40:41 <JKnecht> or maybe the general social, economic, and cultural milliue, hmmmm?
23:40:51 <dons> against static typing, eh?
23:40:52 <JKnecht> millieu
23:41:08 <bos> it's the universities.
23:41:20 <dpiponi> Reminds me of comments by John Baez that the US is a backwater for category theory.
23:42:16 <Excedrin> I think there's a lot of invisible FP usage in CA
23:42:36 <bos> there's a little, and it's completely invisible.
23:42:47 <JKnecht> eventually the 'backwater' rises above the tops of the ivory towers. I think that happened about 5 - 10 years ago.
23:49:16 <bos> what do people do for sending haskell data over a wire, or into a file, and back out?
23:50:39 <Excedrin> show and read
23:50:39 <bos> @hoogle pickle
23:50:40 <lambdabot> No matches found
23:51:25 <bos> really?  eugh.
23:52:18 <treitter> what's the difference between Int and Integer?
23:52:21 <bos> if i have similarly-named and -shaped types deriving Show in different modules, won't that go poo?
23:52:36 <bos> > maxBound :: Integer
23:52:37 <lambdabot>   add an instance declaration for (Bounded Integer)
23:52:38 <lambdabot>     In the expression: ma...
23:52:40 <treitter> bos: heh.. does anything but Python call serialization "pickle"?
23:52:53 <bos> @hoogle marshal
23:52:54 <lambdabot> GHC.Dotnet.marshalObject :: Object a -> (Addr# -> IO b) -> IO b
23:52:54 <lambdabot> GHC.Dotnet.marshalString :: String -> (Addr# -> IO a) -> IO a
23:52:54 <lambdabot> GHC.Dotnet.unmarshalObject :: Addr# -> Object a
23:53:17 <bos> treitter: lambdabot was telling us that Integer is big
23:54:06 <bos> while Int is fixed in size
23:54:39 <bos> Integer is not an instance of Bounded, i.e. it's a bignum
23:56:35 <sorear> bos: there are many, many competing approaches for better serialization
23:56:52 <bos> sorear: and it's terribly hard to google for pointers to them.
23:57:26 <dons> treitter: Integer is unbounded
23:57:30 <dons> > 2 ^ 2048
23:57:31 <treitter> bos: ah, cool. Does that mean it's theoretically unbounded, or just very big?
23:57:31 <treitter> ah
23:57:32 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
23:57:35 <sorear> SerTH DrIFT Binary AltBinary NewBinary genericserialize -- the ones I know of
23:57:41 <bos> treitter: limited by memory.
23:57:47 <treitter> bos: yeah
23:57:53 <dons> > 2 ^ 2048 :: Word32
23:57:55 <lambdabot>  0
23:58:04 <dons> > 2 ^ 2048 :: Word64
23:58:06 <lambdabot>  0
23:58:10 <sorear> > 2 ^ 2048 :: Word4096
23:58:11 <lambdabot>   Not in scope: type constructor or class `Word4096'
23:58:36 <sorear> > 2 ^ 2048 :: LargeBits Word2048 Word2048
23:58:37 <bos> @hoogle binary
23:58:37 <lambdabot>   Not in scope: type constructor or class `LargeBits'
23:58:37 <lambdabot> System.Win32.File.BinaryType :: type BinaryType
23:58:38 <lambdabot> System.Win32.File.sCS_32BIT_BINARY :: BinaryType
23:58:38 <lambdabot> System.Win32.File.sCS_DOS_BINARY :: BinaryType
23:58:40 <Cale> treitter: It's only bounded by how much memory you have available
23:58:44 <sorear> ?src Word2048
23:58:45 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:58:51 <treitter> Cale: yeah
23:59:08 <sorear> Disk works too (very slowly)
23:59:20 <dons> sorear: ok. I see what you want :)
23:59:29 <sorear> note that you need a VM OS to use disk for this
