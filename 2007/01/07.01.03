00:01:47 <dons> ?yow
00:01:48 <lambdabot> One FISHWICH coming up!!
00:07:37 <arcatan> ?vixen
00:07:38 <lambdabot> I hear ya!
00:07:43 <arcatan> hokay.
00:08:13 <lispy> ?arg
00:08:14 <lambdabot> Swab the deck!
00:08:23 <mauke> ?keal
00:08:23 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
00:08:38 <lispy> ?. elite keal
00:08:39 <lambdabot> 5OmEONE nEEDs to wRITE 4 80idz 4 HaSK3L1 tHA7 3Mul4Tez0rz HUmAn5 9oIn9 0n ANd ofF T0Pic
00:11:01 <mgsloan> ?. elite yow
00:11:02 <lambdabot> |-|E pRoBab|Y JUst W4n+z0rz To 7Ake OVer /\/\Y (31|z 4ND t|-|3N EXpl0d3 IN5iDe ME LiKe A BaRr31 of ruNNY (hopPeD |Iver! Or /\/\AYBe h3'D 1IKe T0 pSy(H0109IcALlY +eRROrIze /\/\3 UNtiL i H4\/E nO
00:11:02 <lambdabot> o8J3cTIOn +o a RI9ht-WIn9 mi1i+aRY TAx30Ver Oph My aP4R7MEN+!! I Gu35s i SH0ULd c4L| A1 paCiNo!
00:11:33 <lispy> oh my
00:11:38 <lispy> that one is kinda crazy
00:11:40 <emu> that was pretty rough
00:12:58 <mgsloan> ?. elite elite Hello, world!
00:12:59 <lambdabot> hEL|0, w0r|d!
00:14:14 <emu> ?. fix elite Hello, world!
00:14:15 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "fix"
00:14:22 <lispy> ?. elite . elite . elite elite hello, world!
00:14:23 <lambdabot> |-|e||0, W0R|D!
00:14:58 <bos> @hoogle replace
00:15:00 <lambdabot> Data.Array.Diff.replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
00:15:00 <lambdabot> System.Win32.File.mOVEFILE_REPLACE_EXISTING :: MoveFileFlag
00:15:00 <lambdabot> System.Win32.Registry.c_RegReplaceKey :: PKEY -> LPCTSTR -> LPCTSTR -> LPCTSTR -> IO ErrCode
00:15:03 <mgsloan> uber - elite
00:15:20 <mgsloan> ?quote
00:15:21 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
00:15:30 <mgsloan> ?. elite quote
00:15:30 <lambdabot> SEanrUSse1L $AYs: [0N Th3 \/\//\/\Ii (wINdoW MAnaGer) m4I1in9 li$+] HaH! ThA7'$ A 14u9H. $In(e \/\/h3N DOe5 "i7 CO/\/\pIleS" Equ47E to "IT will RUN (c0RrecT1Y)"? \/\/3'R3 +4lxIng AboU7 (, AphtEr A1L.
00:15:31 <lambdabot> .. noT H4$ke||.
00:15:45 <emu> late night Haskell, with your host, lambdabot
00:23:00 <ski> emu : existential ?
00:23:13 <araujo> @hoogle split
00:23:14 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
00:23:15 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
00:23:15 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
00:27:14 <ski> (emu : btw, you've seen the way to define the y combinator (nonrecursively) by means of a recursive type ?)
00:34:20 <shapr> SHAZAM!
00:34:45 <shapr> ?. elite quote
00:34:46 <lambdabot> SWIER7 $AYz: oF (0uRsE! \/\/|-|O c4n 1ivE wIT|-|0U7 c0VaRiaN+ hOMphUn(T0r5?
00:35:14 <ClaudiusMaximus> ? . hoogle elite Int -> [a] -> a
00:35:32 <ClaudiusMaximus> ?. hoogle elite Int -> [a] -> a
00:35:34 <lambdabot> Did you mean: Int -> [a] -> a
00:35:34 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
00:35:34 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
00:35:59 <pierre-> ?. elite hoogle [a] -> [a]
00:36:01 <lambdabot> PReLudE.CYCLe :: [A] -> [A] pre|UdE.inIt :: [A] -> [a] PReLUDe.Re\/3Rz3 :: [4] -> [A]
00:36:07 <flux__> araujo, is John DOE a regular poster in l4-hurd? I just get somewhat of a "I'm being trolled"-feeling when reading his three posts (during the first and second day of the year) :-o
00:36:48 <ski> (shapr : heh, that makes me think of salt water springs)
00:37:29 <flux__> (that means also: I don't get the feeling the guy is going to have a haskell-microkernel in three years..)
00:37:49 <dons> oh, is it that guy?
00:38:06 <dons> who was it with the plans to write a haskell os from scratch last year?
00:40:57 <flux__> I don't know, I just picked this month's archive this morning
00:42:08 <Syzygy-> ?elite Int -> [a] -> a
00:42:09 <lambdabot> iNT -> [4] -> 4
00:42:16 <dons> types rock
00:44:09 <LoganCapaldo> hehhe
00:44:24 <LoganCapaldo> looks like Haskell got dependent types ;)
00:45:03 <goltrpoat> does this mean lambdabot is going to publish a paper
00:45:26 <dons> she's been in a couple of papers that I know of
00:45:47 <ClaudiusMaximus> ?. hoogle hoogle [a] -> [a]
00:45:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '
00:45:48 <lambdabot> Prelude.i'
00:48:16 <dons> ?hoog hoogle [a] -> [a]
00:48:17 <lambdabot> Maybe you meant: hoogle hoogle+
00:48:45 <dons> ?hoogle [a] -> [a]
00:48:46 <lambdabot> Prelude.cycle :: [a] -> [a]
00:48:46 <lambdabot> Prelude.init :: [a] -> [a]
00:48:46 <lambdabot> Prelude.reverse :: [a] -> [a]
00:48:55 <dons> we do need the little sed plugin, as lennart suggested
00:52:44 <pierre-> > [a..Z] ++ [A..Z]
00:52:45 <lambdabot>  Parse error
00:53:01 <pierre-> > ['a'..'Z'] ++ ['A'..'Z']
00:53:03 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
00:53:35 <mauke> > ['A' .. 'z'] ++ ['a' .. 'Z']
00:53:36 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
00:59:44 <araujo> flux__, kind of difficult to say
00:59:49 <araujo> dons, i think he _is_
00:59:58 <araujo> Though i think he is using other email addy
01:02:29 <vegaiW> about HAppS...
01:02:59 <vegaiW> in the tutorial, the server is started like this:
01:03:08 <vegaiW> main = stdMain $ simpleHTTP "static/books.xsl" [("/static/", "static")] app :*: End
01:03:29 <vegaiW> and the GET method is handled by this:
01:03:32 <vegaiW> app GET _ ["books"] = do
01:03:32 <vegaiW> 	toMessageM $ XML (XSL "/static/books.xsl") $ toElement
01:03:32 <vegaiW> 		[(Book "Haskell Curry" "Functions" "lambda")
01:03:35 <vegaiW> 		,(Book "Many" "Haskell Report" "String -> IO ()")]
01:03:41 <Syzygy-> Right. So I can write code that generically generates ana-, cata-, hylo- and paramorphisms. Now what is this good for?
01:04:11 <vegaiW> Why is static/books.xsl repeated? What does it mean in the GET handler? What does it mean in the simpleHTTP call?
01:06:59 <dons> Syzygy-: hmm, deriving fusable combinators for a librayr?
01:08:07 <Syzygy-> dons: And what is a fusable combinator?
01:08:41 <dons> map f . map g = map (f.g) -- saves one traversal
01:08:55 <dons> now, there's a variety of mechanisms for writing functions that can be 'fused' like this
01:09:00 <dons> often in terms of hylomorphsms
01:09:40 <dons> so if you can write a list library (say) in terms of hylormophism, the compiler maybe be able to produce more efficient code, with fewer intermediate data structures, when you combine those functions
01:10:10 <dons> ?go Rewriting Haskell Strings
01:10:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
01:10:12 <lambdabot> Title: Rewriting Haskell Strings
01:10:16 <dons> ^^ for an example of this in practice
01:10:31 <zeeeee> hi dons, i've been studying your hmp3 app, and i was wondering if you could tell me what the ! are in your HState, so i can look it up
01:11:01 <metaperl> probably eagerly evaluated arguments to a function?
01:11:14 <metaperl> data Something = Something a b! c! d
01:11:21 <metaperl> b and c are eagerly evaluated
01:11:29 <zeeeee> metaperl: well it's more like HState { foo :: !Int }
01:11:32 <zeeeee> metaperl: is that the same thing
01:11:42 <metaperl> not sure in that case
01:12:59 <Syzygy-> dons: Ok....
01:13:12 <Syzygy-> So it's mainly of interest for functional compiler builders?
01:13:44 <zeeeee> metaperl: hmm, where do i find more about these eagerly evaluated arguments? google hasn't turned up anything so far...
01:14:18 <metaperl> zeeeee - i'm not sure... I just asked in this channel 2 days ago myself
01:14:28 <metaperl> it just means they are not lazy
01:14:33 <metaperl> haskell is lazy by default
01:14:51 <metaperl> oh, I think the term is normal order or something ... hold on
01:14:53 <Syzygy-> (10:06) (@Kit) Syzygy-: I swear you're making up words now. :)
01:15:06 <Syzygy-> ^^  When talking about ana-, cata-, hylo- and para-morphisms.
01:15:29 <metaperl> zeeeee - ok eager === applicative... lazy === normal order : http://mitpress.mit.edu/sicp/full-text/sicp/book/node85.html
01:15:30 <dons> zeeeee: strict fields (can be unboxed, just a habit for efficient data )
01:15:30 <lambdabot> Title: Normal Order and Applicative Order
01:15:43 <metaperl> dons what does strict mean?
01:15:51 <metaperl> what does unboxed mean?
01:16:24 <dons> in this sense, values will be evaluated eagerly, and stored in evaluated form
01:16:35 <dons> i.e. strictly evaluated
01:16:37 <metaperl> ok ML is strict
01:16:43 <metaperl> haskell is non-strict
01:16:51 <metaperl> non-strict == lazy == normal order
01:16:58 <metaperl> strict == eager == applicative order
01:16:59 <vegaiW> hmm, no happs people on...
01:17:03 <dons> now, since we know a value is strict, we can unbox it -- i.e. store it as a primitive int (if the type is Int), since we know it can't ever be an undefined/bottom value
01:17:42 <ClaudiusMaximus> @hoogle binary relation
01:17:44 <lambdabot> Did you mean: Binary Relation
01:17:44 <dons> of course, this also means you can't put an infinite structure, or a lazy structure, into a strict field of a data type
01:17:44 <lambdabot> Prelude.undefined :: a
01:17:44 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
01:18:34 <ClaudiusMaximus> @hoogle relation
01:18:36 <lambdabot> No matches found
01:18:41 <ClaudiusMaximus> @hoogle Relation
01:18:42 <lambdabot> No matches found
01:19:01 <zeeeee> dons: thanks!
01:20:03 <dons> zeeeee: let me know if you want any more advice on the curses program
01:35:40 <dmhouse> Morning all.
01:54:46 <dons> oh nice reddit err "looks like we shouldn't have stopped using lisp..."
01:55:31 <goltrpoat> haha
01:55:42 <goltrpoat> which one is that?
01:55:57 <dons> you can generate errors all day long: http://programming.reddit.com/?x
01:56:01 <dons> (just a little bogus field)
01:56:12 <goltrpoat> oh you mean the site itself?
01:56:16 <dons> yeah
01:56:23 <goltrpoat> weren't they like.. funded by paul graham
01:56:35 <goltrpoat> or incubated or whatever
01:56:38 <dons> yep, hence another error msg says "Think you can do better? email pg@ycombintor.com"
01:56:44 <dibblego> must be written in one of those inferior languages
01:56:44 <goltrpoat> ah
01:56:50 <dons> funny guys
01:57:09 <goltrpoat> odd that a ycombinator outfit would stop using lisp
02:03:20 <earthy> it was the libs.
02:17:25 <dons> maybe if they'd used haskell.. ;)
02:25:39 <ClaudiusMaximus> ?hoogle tails
02:25:40 <lambdabot> List.tails :: [a] -> [[a]]
02:25:41 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
02:26:47 <dons> > runCont ord
02:26:49 <lambdabot>      Expecting a function type, but found `Cont r a'
02:26:49 <lambdabot>       Expected type: Con...
02:27:23 <ClaudiusMaximus> humm, i have "> import List", but ghci spits out "HadSoda.lhs:38:38: Not in scope: `tails' "
02:27:40 <dons> Data.List
02:27:53 <dons> ?index tails
02:27:54 <lambdabot> Data.List
02:28:33 <ClaudiusMaximus> thanks dons
02:31:04 <rthj> what's the name of the list membership test function in haskell?
02:31:14 <Syzygy-> elem
02:31:17 <rthj> thanks
02:31:21 <Syzygy-> > 3 `elem` [1,3,5,7]
02:31:23 <lambdabot>  True
02:31:50 <Syzygy-> > 3 `elem` (map ((+1) . (*2)) [1..])
02:31:52 <lambdabot>  True
02:31:52 <rthj> why not "member"? i thought that was pretty much standard across a whole bunch of functional languages.
02:32:20 <dons> ?hoogle member
02:32:21 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
02:32:21 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
02:32:21 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
02:32:31 <dons> hysterical reasons I guess :)
02:32:37 <rthj> ok
02:33:04 <dons> ?let table = M.fromList (zip [1..] "haskell")
02:33:05 <lambdabot> Defined.
02:33:18 <dons>  M.member 7 table
02:33:26 <dons> >  M.member 7 table
02:33:28 <lambdabot>  True
02:33:34 <Syzygy-> > M.member 7 L.table
02:33:35 <dons> ?hoogle+
02:33:36 <lambdabot>  True
02:33:36 <lambdabot> Data.Set.member :: Ord a => a -> Set a -> Bool
02:33:36 <lambdabot> Data.IntSet.splitMember :: Int -> IntSet -> (IntSet, Bool, IntSet)
02:33:36 <lambdabot> Data.Set.splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
02:34:03 <dons> ?let tableSet = S.fromList "haskell"
02:34:05 <lambdabot> Defined.
02:34:12 <dons> > S.member k tableSet
02:34:14 <lambdabot>   Not in scope: `k'
02:34:21 <Syzygy-> > S.member 'k' tableSet
02:34:23 <lambdabot>  True
02:34:32 <dons> ?hoogle+
02:34:45 <dons> that's it I guess
02:35:10 <dons> ?src elem
02:35:11 <lambdabot> elem x    =  any (== x)
02:35:15 <dons> mm tasty
02:40:18 <Syzygy-> ?src any
02:40:19 <lambdabot> any p =  or . map p
02:40:29 <Syzygy-> ?src map
02:40:30 <lambdabot> map _ []     = []
02:40:30 <lambdabot> map f (x:xs) = f x : map f xs
02:40:33 <Syzygy-> ?src or
02:40:34 <lambdabot> or    =  foldr (||) False
02:40:46 <dons> ?src foldr
02:40:47 <Syzygy-> ?src foldr
02:40:47 <lambdabot> foldr k z xs = go xs
02:40:48 <lambdabot>     where go []     = z
02:40:48 <lambdabot>           go (y:ys) = y `k` go ys
02:40:48 <lambdabot> foldr k z xs = go xs
02:40:48 <lambdabot>     where go []     = z
02:40:49 <lambdabot>           go (y:ys) = y `k` go ys
02:40:53 <Syzygy-> Ooops
02:41:01 <dons> ?src []
02:41:02 <lambdabot> data [] a = [] | a : [a]
02:41:28 <dons> ?src (==)
02:41:29 <lambdabot> x == y = not (x /= y)
02:41:31 <Syzygy-> ?src (:)
02:41:32 <lambdabot> Source for this function is not available.
02:41:35 <Syzygy-> ?src (/=)
02:41:36 <lambdabot> x /= y = not (x == y)
02:41:38 <dons> hehe
02:41:43 <dons> ?src not
02:41:43 <Syzygy-> Circular much? :)
02:41:43 <lambdabot> not True   =  False
02:41:44 <lambdabot> not False  =  True
02:41:56 <Syzygy-> ?src (||)
02:41:57 <lambdabot> True  || _ =  True
02:41:57 <lambdabot> False || x =  x
02:42:04 <Syzygy-> Neat.
02:42:23 <rthj> ?src reverse
02:42:24 <lambdabot> reverse = foldl (flip (:)) []
02:42:28 <dons> now that's how your roll yourself a language
02:42:28 <rthj> i like that one :)
02:42:56 <Syzygy-> ?src flip
02:42:57 <lambdabot> flip f x y = f y x
02:43:15 <Vq^> ?src lift
02:43:16 <lambdabot> Source for this function is not available.
02:43:23 <Syzygy-> ?src liftM
02:43:24 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:43:28 <Syzygy-> ?src fmap
02:43:29 <lambdabot> Source for this function is not available.
02:43:47 <dons> class methods have multiple implementations
02:43:52 <Syzygy-> Point.
02:43:53 <dons> so I'm not sure about how best to display them
02:43:54 <Syzygy-> ?src map
02:43:55 <lambdabot> map _ []     = []
02:43:55 <lambdabot> map f (x:xs) = f x : map f xs
02:45:29 <rthj> dons: can't you require another argument that specifies the class, and give an error saying that the class argument is needed in case of class methods?
02:46:03 <dons> ah yes. that's doable
02:46:30 <dons> e.g. (==) would print: Bool.(==) Int.(==) and so on
02:46:40 <dons> which can then be used as keys to find the correct implementation
02:46:48 <rthj> yeah, that would be neat
02:53:33 <amiddelk> ?src fmap :: (a -> b) -> Maybe a -> Maybe b
02:53:34 <lambdabot> Source for this function is not available.
02:54:39 * dons adds class methods
02:54:46 <astrolabe> @karma+ dons
02:54:47 <lambdabot> dons's karma raised to 109.
02:55:02 <astrolabe> (for help in /msg)
02:55:12 <astrolabe> wow, don's has all the karma
02:55:18 <astrolabe> @karma shapr
02:55:19 <lambdabot> shapr has a karma of 34
02:55:32 <astrolabe> @karma astrolabe
02:55:33 <lambdabot> You have a karma of 5
02:55:40 * astrolabe hangs his head
02:59:15 <ClaudiusMaximus> which linear algebra libraries are preferred?  i need to first find the number of solutions of, and if there be a unique solution then solve: Ax=b for A::SquareMatrix(n) and x,b::Vector(n), for varying n (so i think that rules out that stla lib)
03:00:22 <astrolabe> stla lib?
03:00:50 <astrolabe> There is a partial port of lapack I think
03:01:03 <astrolabe> I was going to get round to trying it myself
03:01:55 <astrolabe> If you don't care about efficiency, there might be standard native haskell implementations, but I don't know of them.
03:02:56 <astrolabe> Are these Real matrices?
03:03:48 <ClaudiusMaximus> astrolabe: they'll either be Float or Double, i'm not sure what Real entails
03:03:57 <bringert> grr
03:04:04 <astrolabe> ClaudiusMaximus: that was my meaning
03:04:10 <ClaudiusMaximus> astrolabe: ok
03:04:15 * bringert lost a bunch of ghc test cases due to a hard drive crash
03:04:31 <astrolabe> ClaudiusMaximus: what is 'stla lib'?
03:04:58 <ClaudiusMaximus> http://portal.acm.org/citation.cfm?id=1159859&jmp=cit&coll=ACM&dl=ACM&CFID=15151515&CFTOKEN=6184618
03:05:08 <lambdabot> Title: Statically typed linear algebra in Haskell, http://tinyurl.com/ycowon
03:05:35 <astrolabe> Ah, thanks
03:06:04 <goltrpoat> claudius:  with no other constraints, what's wrong with just doing gaussian elimination and backsubstitution in haskell
03:06:37 <opqdonut> (maybe he doesn't want to program it himself)
03:06:40 <goltrpoat> takes very little effort, especially considering the amount of code online
03:06:45 <ClaudiusMaximus> goltrpoat: as opqdonut says
03:06:55 <opqdonut> yeah but gaussian elimination has many optimizations
03:07:03 <astrolabe> ClaudiusMaximus: http://www.cs.utah.edu/~hal/HBlas/index.html
03:07:05 <lambdabot> Title: HBlas - Linear Algebra for Haskell
03:07:25 <opqdonut> linear algebra and numeric solving are the areas in which i trust established libs loads more than myself
03:07:30 <ClaudiusMaximus> astrolabe: ta
03:07:44 <goltrpoat> meh.
03:07:50 <ClaudiusMaximus> there was this, but the domain is squatted by evilness http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg03493.html
03:07:51 <lambdabot> Title: Indexless linear algebra algorithms
03:07:56 <JoshTriplett> Does lambdabot respond to /msg?  I wanted to do some hoogling, but lambdabot doesn't seem to answer.
03:08:19 <astrolabe> JoshTriplett: yes it does
03:08:37 <ClaudiusMaximus> JoshTriplett: you need to be registered+identified on freenode to /msg afaik, unless the /msg-ee has set some option...
03:08:49 <astrolabe> JoshTriplett: You need to be registered, and you need to get the syntax right.
03:08:53 <opqdonut> JoshTriplett: lambdabot was down at least a while ago
03:09:01 <opqdonut> > 1+1
03:09:03 <lambdabot>  2
03:09:08 <opqdonut> not anymore tho it seems
03:09:13 <JoshTriplett> ClaudiusMaximus: I've identified.
03:09:24 <goltrpoat> apparently i'm the only person who thinks that writing linear solvers is fun.
03:09:46 <astrolabe> goltrpoat: yep :)
03:09:56 <JoshTriplett> astrolabe: Ah, apparently lambdabot just ignores incorrect syntax, rather than complaining.
03:10:11 <JoshTriplett> astrolabe: Which makes figuring out correct syntax fun. :/
03:10:16 <astrolabe> JoshTriplett: yeah, I discovered that yesterday :)
03:10:44 <JoshTriplett> So, what correct syntax would I use for asking for functions of type a -> [a] -> [a] ?
03:10:53 <dons> ?hoogle a -> [a] -> [a]
03:10:55 <lambdabot> List.intersperse :: a -> [a] -> [a]
03:10:55 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
03:10:55 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:10:56 <astrolabe> I guess we wouldn' t want it complaining in here everytime we typed something.
03:11:13 <dons> ?hoogle+
03:11:14 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
03:11:15 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
03:11:15 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
03:11:38 <JoshTriplett> dons: Apparently I lacked the ?.
03:11:46 <JoshTriplett> dons: Thanks.
03:11:53 <dons> you need @foo in /msg (buglet)
03:11:55 <Syzygy-> You can use @ as well iirc
03:12:03 <Syzygy-> @hoogle a -> [a] -> [a]
03:12:03 <opqdonut> and +
03:12:05 <lambdabot> List.intersperse :: a -> [a] -> [a]
03:12:05 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
03:12:05 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:12:12 <dons> ?quit more instances
03:12:23 <Syzygy-> dons: ??
03:12:30 <Syzygy-> Ah
03:12:33 <opqdonut> +hoogle a -> [a] -> [a]
03:12:34 <Syzygy-> ?quit Can I do this?
03:12:39 <JoshTriplett> Can I limit hoogle to functions of exactly the signature I specify, rather than something which ends in that signature or something similar to that signature?
03:12:39 <opqdonut> :)
03:13:01 <lambdabot> Not enough privileges
03:13:02 <dons> JoshTriplett: not that I know of, check the web interface (its a bit richer)
03:13:08 <dons> ?google hoogle
03:13:21 <lambdabot> http://haskell.org/hoogle/
03:13:23 <lambdabot> Title: Hoogle
03:13:39 <Syzygy-> Is it just me or did lb get much more sluggish with this reboot?
03:13:41 <goltrpoat> that'd be nice, actually.  that, and treating tyvars as distinct things, not as a specific type name
03:13:51 <dons> ?src [].>>=
03:13:52 <lambdabot> Plugin `source' failed with: IRCRaised state not initalized
03:14:00 <dons> interesting
03:14:07 <Syzygy-> ?src >>=
03:14:08 <lambdabot> Plugin `source' failed with: IRCRaised state not initalized
03:14:21 <dons> ah I know
03:14:35 <goltrpoat> oh.  it does treat tyvars correctly.  my bad
03:14:43 <goltrpoat> ?hoogle [b] -> [b]
03:14:44 <lambdabot> Prelude.cycle :: [a] -> [a]
03:14:44 <lambdabot> Prelude.init :: [a] -> [a]
03:14:44 <lambdabot> Prelude.reverse :: [a] -> [a]
03:14:52 <goltrpoat> i didn't realize that.
03:15:26 <goltrpoat> oh oh oh.  qualified names.
03:15:38 <JoshTriplett> Does any way exist to ask lambdabot "does this functoin have a name"?  For example, "does \x -> filter (x/=) have a name"?
03:16:01 <dons> ?quit typo
03:16:14 <goltrpoat> isn't that undecidable
03:16:17 <goltrpoat> hehe
03:16:21 <dons> JoshTriplett: no unfortunately. well sort of
03:16:21 <opqdonut> ?pl \ x -> filter ( x /= )
03:16:26 <dons> ?type \x -> filter (x/=)
03:16:41 <JoshTriplett> goltrpoat: In the general case, certainly.
03:16:42 <dons> we wait on freendoe...
03:16:44 <goltrpoat> actually.  no it's not, is it?  given a normal form of some sort.
03:16:50 <lambdabot> filter . (/=)
03:16:58 <dons> there you go
03:16:58 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
03:17:13 <dons> ?pl \x -> x
03:17:18 <lambdabot> id
03:17:21 <dons> it can work out a few
03:17:25 <opqdonut> yep
03:17:31 <goltrpoat> i.e. take the queried expression to the normal form, compare it against the database of library functions in normal form.
03:17:45 <JoshTriplett> goltrpoat: Which looks like exactly what pointless does.
03:18:07 <dons> pointless uses rewrite rules to reduce, and has a set of tactics. so sort of
03:18:13 <goltrpoat> -nod-
03:18:35 <dons> ?src [].>>=
03:18:36 <lambdabot> Source for this function is not available.
03:18:36 <ClaudiusMaximus> hmm, http://dis.um.es/~alberto/GSLHaskell/ seems more developed (and less frightening installation instructions) than the one astrolabe linked me to, but i don't have ghc-6.6 (only 6.4.2)
03:18:40 <dons> ?src IO.>>=
03:18:41 <lambdabot> Title: GSLHaskell
03:18:41 <lambdabot> m >>= k     = bindIO m k
03:18:48 <dons> ?src [].(>>=)
03:18:48 <lambdabot> m >>= k     = foldr ((++) . k) [] m
03:18:53 <dons> I should have used a consistent naming scheme ;)
03:18:58 <dons> ?src bindIO
03:18:59 <lambdabot> bindIO (IO m) k = IO ( \ s ->
03:18:59 <opqdonut> heh :)
03:18:59 <lambdabot>   case m s of
03:18:59 <lambdabot>     (# new_s, a #) -> unIO (k a) new_s
03:18:59 <lambdabot>   )
03:19:13 <dons> ?instances IO
03:19:15 <lambdabot> Couldn't find class `IO'. Try @instances-importing
03:19:16 <dons> ?instance Monad
03:19:17 <lambdabot> Maybe you meant: instances instances-importing
03:19:22 <dons> ?instances Monad
03:19:23 <JoshTriplett> ?hoogle [a] -> [(a,a)]
03:19:24 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:19:24 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
03:19:33 <dons> ?src (->).fmap
03:19:33 <lambdabot> fmap = (.)
03:19:43 <JoshTriplett> ?hoogle [a] -> [[a]]
03:19:44 <lambdabot> List.inits :: [a] -> [[a]]
03:19:44 <lambdabot> List.tails :: [a] -> [[a]]
03:19:44 <lambdabot> List.group :: Eq a => [a] -> [[a]]
03:19:52 <dons> there's a quick sketch anyway of class method src lookup
03:19:59 <goltrpoat> what's RWS anyway?
03:20:01 <opqdonut> nice
03:20:07 <goltrpoat> the haddock is more or less useless on the matter
03:21:33 <goltrpoat> oh, sort of like MonadReader, MonadWriter and MonadState rolled into one?
03:21:53 <goltrpoat> RWST being the ST version?
03:22:00 <goltrpoat> or.  the transformer version?
03:22:02 <goltrpoat> hehe
03:22:20 <goltrpoat> k, i couldve looked that one up, sorry.
03:23:01 <JoshTriplett> What function should I use if I want to turn [1,2,3,4,5,6] into [(1,2),(3,4),(5,6)]?  Goal: concatmap a binary function onto that list.
03:23:31 <dons> > let s = [1,2,3,4,5,6] in zip s (tail s)
03:23:33 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
03:23:47 <norpan> almost
03:23:51 <JoshTriplett> Hmmm.
03:23:57 <JoshTriplett> Every other element of that list would work.
03:24:41 <dons> > let s = [1,2,3,4,5,6] in filter (even.fst) $ zip [1..] $ zip s (tail s)
03:24:43 <lambdabot>  [(2,(2,3)),(4,(4,5))]
03:24:55 <dons> > let s = [1,2,3,4,5,6] in filter (odd.fst) $ zip [1..] $ zip s (tail s)
03:24:57 <lambdabot>  [(1,(1,2)),(3,(3,4)),(5,(5,6))]
03:25:07 <dons> > let s = [1,2,3,4,5,6] in map snd . filter (odd.fst) $ zip [1..] $ zip s (tail s)
03:25:08 <lambdabot>  [(1,2),(3,4),(5,6)]
03:25:11 <dons> :}
03:25:32 <dons> 100% guaranteed there's nicer ways ;)
03:25:35 <norpan> > let binmap f (a:b:r) = f a b:binmap f r; binmap _ [] = [] in binmap (,) [1,2,3,4,5,6]
03:25:36 <lambdabot>  [(1,2),(3,4),(5,6)]
03:25:42 <dons> its a fold after all
03:25:47 <dons> (its always a fold)
03:25:49 <goltrpoat> > take 4 . (unfoldr (Just . splitAt 2)) $ [1,2,3,4,5,6,7,8]
03:25:51 <lambdabot>  [[1,2],[3,4],[5,6],[7,8]]
03:25:58 <goltrpoat> oh.  pairs, not lists
03:26:03 <JoshTriplett> goltrpoat: *nice*, though.
03:26:05 <Syzygy-> > let s = [1,2,3,4,5,6]; f (x:y:xs) = (x,y):f xs; f [x]=[]; f []=[]; in f s
03:26:06 <lambdabot>  [(1,2),(3,4),(5,6)]
03:26:18 <Syzygy-> You could always just write down what you want. :P
03:26:23 <dons> heh
03:26:27 <goltrpoat> haha
03:26:29 <dons> ugly, but true ;)
03:26:30 <Syzygy-> IT'll be uglier than recognizing that it's a fold with (,), but...
03:26:35 <goltrpoat> quite true :)
03:26:49 <JoshTriplett> Syzygy-: Yeah, that looks pretty much like what I did.
03:27:07 <JoshTriplett> Syzygy-: Except I just directly did the operation I wanted to with the two items.
03:27:37 <JoshTriplett> goltrpoat: I always forget about unfoldr.
03:28:45 <goltrpoat> it seems to be underappreciated
03:28:54 <malebria> Good morning.
03:29:08 <Vq^> g'day malebria
03:30:08 <Syzygy-> ?type unfoldr
03:30:09 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
03:31:55 <dons> > let s = [1..8] in map snd . filter fst . zip (fix ([True,False] ++)) $ zip s (tail s)
03:31:57 <lambdabot>  [(1,2),(3,4),(5,6),(7,8)]
03:32:12 <goltrpoat> dude.
03:32:13 <Syzygy-> ?index unfoldr
03:32:14 <lambdabot> Data.List
03:32:26 <Syzygy-> What does unfoldr do?
03:32:51 <dons> > zip (fix ([True,False] ++)) [1..10]
03:32:52 <goltrpoat> dons:  that's quite pretty, in a remarkably perverse way.
03:32:53 <lambdabot>  [(True,1),(False,2),(True,3),(False,4),(True,5),(False,6),(True,7),(False,8)...
03:32:53 <JoshTriplett> dons: I think you could replace fix ([True,False]++) with cycle [True,False]
03:32:55 <dons> little trick ;)
03:33:00 <dons> yeah
03:33:13 <dons> there must be a list monad in there somewhere for this.. ;)
03:33:40 <JoshTriplett> > let s = [1..8] in map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:33:41 <lambdabot>  [(1,2),(3,4),(5,6),(7,8)]
03:34:32 <dons> a nice way to manually fuse map . filter is with a comprehension:
03:34:34 <dons> > [ x | (True,x) <- zip (cycle [True,False]) . zip s $ tail s ]
03:34:35 <lambdabot>   Not in scope: `s'
03:34:45 <dons> > let s = [1..8] in [ x | (True,x) <- zip (cycle [True,False]) . zip s $ tail s ]
03:34:46 <lambdabot>  [(1,2),(3,4),(5,6),(7,8)]
03:35:03 <JoshTriplett> > let s = [1..9] in map snd . filter fst . zip (cycle [True,False,False]) $ zip3 s (tail s) (tail . tail s)
03:35:04 <lambdabot>      Expecting a function type, but found `[a]'
03:35:05 <lambdabot>       Expected type: a1 -> [a...
03:35:40 <JoshTriplett> > let s = [1..9] in map snd . filter fst . zip (cycle [True,False,False]) $ zip3 s (tail s) (tail $ tail s)
03:35:42 <lambdabot>  [(1,2,3),(4,5,6),(7,8,9)]
03:35:55 <apfelmus> > unfoldr (\n -> Just (n,n+1)) 1 -- Syzygy-
03:35:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:36:21 <goltrpoat> syzygy:  induction in a box.
03:36:22 <dons> hey apfelmus
03:36:35 <pierre-> > let f s = filter (odd . fst) $ zip s (tail s) in f [1..10]
03:36:37 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
03:36:43 <JoshTriplett> > unfoldr (\n -> if n > 10 then Nothing else Just (n,n+1)) 1
03:36:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:36:55 <dons> pierre-: hehe
03:37:20 <JoshTriplett> pierre-: A bit too specific, but nice.
03:37:29 <pierre-> thx :-)
03:37:29 <apfelmus> dons: hi!
03:37:57 <dons> apfelmus: I must say I'm a bit of a fan of your haskell-cafe@ posts :)
03:37:58 <pierre-> it's just the same as dons's
03:38:17 <JoshTriplett> pierre-: No, yours relies on the use of an integer list.
03:38:44 <JoshTriplett> > let s = "hello world!" in map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:38:45 <lambdabot>  [('h','e'),('l','l'),('o',' '),('w','o'),('r','l'),('d','!')]
03:39:11 <pierre-> JoshTriplett: yes, i see
03:39:56 <apfelmus> dons: thanks :), me too :D
03:39:58 <dons> ooh, minimal hackage online http://ross-paterson.dyndns.org/~ross/hackage/pkg-list.html
03:40:06 <JoshTriplett> > let s = "1a2b3c4d" in map (replicate.read) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:40:07 <lambdabot>  Couldn't match `String' against `(a, b)'
03:40:16 <dons> http://ross-paterson.dyndns.org/~ross/hackage/
03:40:18 <lambdabot> Title: Experimental Hackage interface
03:40:25 <JoshTriplett> > let s = "1a2b3c4d" in map (uncurry (replicate . read)) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:40:26 <lambdabot>  Couldn't match `String' against `Char'
03:40:54 <shoffsta_> ?paste
03:40:54 <lambdabot> http://paste.lisp.org/new/haskell
03:41:00 <JoshTriplett> > let s = "1a2b3c4d" in map (\(x,y) -> replicate (read x) y) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:41:01 <lambdabot>  Couldn't match `String' against `Char'
03:41:10 <goltrpoat> @pl \xs -> fix (xs ++)
03:41:11 <lambdabot> fix . (++)
03:41:38 <JoshTriplett> Heh, that *does* make for a nice definition of cycle.
03:41:45 <dons> ?src cycle
03:41:46 <lambdabot> cycle [] = undefined
03:41:46 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:41:48 <goltrpoat> that's such an unnecessarily awesome definition of cycle.
03:41:50 <dons> mm
03:41:54 <dons> hehe
03:42:38 <dons> > fix . (++) $ []
03:42:39 <lambdabot>  Add a type signature
03:42:44 <dons> > fix . (++) $ [] :: [Int]
03:42:46 <lambdabot>  Exception: <<loop>>
03:42:47 <JoshTriplett> > let s = "1a2b3c4d" in map (\(x,y) -> replicate (read [x]) y) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:42:49 <lambdabot>  ["a","bb","ccc","dddd"]
03:42:49 <dons> :)
03:42:56 <JoshTriplett> > let s = "1a2b3c4d" in concatMap (\(x,y) -> replicate (read [x]) y) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s)
03:42:58 <lambdabot>  "abbcccdddd"
03:42:59 <pierre-> > let f s = map snd $ filter (odd . fst) $ zip3 (take (length s) [1..]) s (tail s) in f [1..10]
03:43:00 <lambdabot>  Couldn't match `(a, b)' against `(a1, b1, c)'
03:43:21 <pierre-> > let f s = map snd $ filter (odd . fst) $ zip (take (length s) [1..]) $ zip s (tail s) in f [1..10]
03:43:22 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
03:43:26 <goltrpoat> hehe a one liner of an RLE decoder
03:43:30 <goltrpoat> gotta love haskell.
03:43:42 <pierre-> > let f s = map snd $ filter (odd . fst) $ zip (take (length s) [1..]) $ zip s (tail s) in f "Hello world"
03:43:44 <lambdabot>  [('H','e'),('l','l'),('o',' '),('w','o'),('r','l')]
03:44:24 <dons> no need for the 'take length' in a lazy language
03:44:30 <JoshTriplett> > let see_n_say s = concatMap (\(x,y) -> replicate (read [x]) y) . map snd . filter fst . zip (cycle [True,False]) $ zip s (tail s) in see_n_say "1a2b3c4d"
03:44:31 <lambdabot>  "abbcccdddd"
03:44:38 <dons> > zip [1..] "haskell"
03:44:40 <lambdabot>  [(1,'h'),(2,'a'),(3,'s'),(4,'k'),(5,'e'),(6,'l'),(7,'l')]
03:44:58 <pierre-> > let f s = map snd $ filter (odd . fst) $ zip [1..] $ zip s (tail s) in f "Hello world"
03:45:00 <lambdabot>  [('H','e'),('l','l'),('o',' '),('w','o'),('r','l')]
03:45:09 <pierre-> dons: thanks
03:45:54 <dons> > let f s = map snd $ filter fst $ zip (cycle [True..]) $ zip s (tail s) in f "Hello world"
03:45:55 <lambdabot>  Parse error
03:46:04 <dons> > let f s = map snd $ filter fst $ zip (cycle [True ..]) $ zip s (tail s) in f "Hello world"
03:46:06 <lambdabot>  [('H','e'),('e','l'),('l','l'),('l','o'),('o',' '),(' ','w'),('w','o'),('o',...
03:46:16 <dons> heh
03:46:32 <dons> > let f s = map snd $ filter fst $ zip (cycle [False ..]) $ zip s (tail s) in f "Hello world"
03:46:33 <lambdabot>  [('e','l'),('l','o'),(' ','w'),('o','r'),('l','d')]
03:47:07 <opqdonut> > [True ..]
03:47:08 <lambdabot>  [True]
03:47:15 <JoshTriplett> [True,...]
03:47:18 <opqdonut> > [False ..]
03:47:19 <lambdabot>  [False,True]
03:47:26 <JoshTriplett> > [True,...]
03:47:26 <lambdabot>  Parse error
03:47:36 <dons> > [minBound ..] :: [Bool]
03:47:37 <lambdabot>  [False,True]
03:47:51 <opqdonut> :)
03:47:54 <JoshTriplett> Nice.
03:48:14 <pierre-> > let f s = map snd $ filter (fst) $ zip [False..] $ zip s (tail s) in f "Hello world"
03:48:14 <lambdabot>  Parse error
03:48:16 <JoshTriplett> I had no idea that .. would stop when it hit maxBound.
03:48:24 <dons> > let f s = map snd . filter fst . zip (cycle [minBound ..]) . zip s $ tail s in f "Hello world"
03:48:26 <lambdabot>  [('e','l'),('l','o'),(' ','w'),('o','r'),('l','d')]
03:48:26 <pierre-> > let f s = map snd $ filter (fst) $ zip (cycle [False..]) $ zip s (tail s) in f "Hello world"
03:48:27 <lambdabot>  Parse error
03:48:42 <pierre-> > let f s = map snd $ filter (fst) $ zip (cycle [True,False]) $ zip s (tail s) in f "Hello world"
03:48:43 <lambdabot>  [('H','e'),('l','l'),('o',' '),('w','o'),('r','l')]
03:49:08 <Andris> hello everyone, I am fooling around with existentially quantified types, and feel stuck. I want to abstract a group of goals with its own scheduler along the lines of: class Group c o where
03:49:09 <Andris> 	open :: c -> Maybe (Goal, o)
03:49:09 <Andris> 	close :: o -> [Goal] -> c
03:49:39 <dons> ok
03:49:50 <Andris> but as soon as I start writing functions that use open.close, I get a lot of "Could not deduce" errors
03:50:19 <Andris> should I manually explain context everywhere I use them?
03:50:51 <Andris> e.g., given data Config = forall c o . Group c o => Config c Store
03:51:05 <Andris> I expected at least this to compile: test (Config c s) = Config c s
03:51:18 <Andris> but it does not :(
03:51:19 <JoshTriplett> let filterlist b l = filter . fst . zip in let pairs s = filterlist (cycle [True,False]) $ zip s (tail s) in pairs "hello"
03:51:22 <JoshTriplett> > let filterlist b l = filter . fst . zip in let pairs s = filterlist (cycle [True,False]) $ zip s (tail s) in pairs "hello"
03:51:23 <lambdabot>      Expecting a function type, but found `b'
03:51:23 <lambdabot>       Expected type: [a1] -> (a...
03:51:34 <JoshTriplett> > let filterlist = filter . fst . zip in let pairs s = filterlist (cycle [True,False]) $ zip s (tail s) in pairs "hello"
03:51:35 <lambdabot>      Expecting a function type, but found `b'
03:51:36 <lambdabot>       Expected type: [a1] -> (a...
03:51:52 <JoshTriplett> > let filterlist = map snd . filter . fst . zip in let pairs s = filterlist (cycle [True,False]) $ zip s (tail s) in pairs "hello"
03:51:53 <lambdabot>      Expecting a function type, but found `b'
03:51:53 <lambdabot>       Expected type: [a1] -> (a...
03:52:12 <goltrpoat> filter . fst . zip is broken, methinks
03:52:24 <JoshTriplett> Yeah.
03:52:34 <JoshTriplett> > let filterlist = map snd . filter fst . zip in let pairs s = filterlist (cycle [True,False]) $ zip s (tail s) in pairs "hello"
03:52:35 <lambdabot>      Expecting a function type, but found `b'
03:52:35 <lambdabot>       Expected type: [a] -> [(B...
03:52:36 <Andris> should I try stating dependencies between o and c in class Group c o?
03:53:00 <apfelmus> > type Goal = (); class Group c o where { open :: c -> Maybe (Goal,o); close :: o -> [Goal] -> c}
03:53:01 <lambdabot>  Parse error
03:53:07 <apfelmus> > type Goal = ()
03:53:08 <lambdabot>  Parse error
03:53:23 <apfelmus> let x = 1
03:53:27 <apfelmus> > let x = 1
03:53:27 <lambdabot>  Parse error
03:53:40 <JoshTriplett> > let x = 1 in x
03:53:42 <lambdabot>  1
03:54:09 <apfelmus> eh? didn't lambdabot support persistent declarations at some point?
03:54:23 <pierre-> @let x = 1
03:54:24 <lambdabot> Defined.
03:54:28 <pierre-> > x
03:54:29 <lambdabot>  1
03:54:37 <apfelmus> @type Goal = ()
03:54:39 <lambdabot> parse error on input `='
03:54:49 <Andris> hmm
03:55:04 <apfelmus> ah, @let is an extra command. ok.
03:55:08 <Andris> class Group c o where { open :: c -> Maybe ((),o); close :: o -> [()] -> c}
03:55:13 <Andris> > class Group c o where { open :: c -> Maybe ((),o); close :: o -> [()] -> c}
03:55:13 <lambdabot>  Parse error
03:55:25 <dons> ?let x = 1
03:55:26 <lambdabot> <local>:4:0:     Multiple declarations of `L.x'     Declared at: <local>:3:0 ...
03:55:26 <dons> > x
03:55:27 <lambdabot>  1
03:55:31 <Syzygy-> Andris: What on earth are you doing?
03:55:35 <dcoutts__> hia dons
03:55:36 <Andris> ok, so it needs {-# OPTIONS_GHC -fglasgow-exts #-} :)
03:55:47 <goltrpoat> @pl \xs -> zip xs (tail xs)
03:55:48 <lambdabot> ap zip tail
03:55:49 <dcoutts__> dons: remind me, what day & time are you arriving in the UK?
03:55:52 <goltrpoat> ooh nice.
03:56:07 <dcoutts__> dons: you're flying into Heathrow right?
03:56:19 <goltrpoat> > let odds (x:y:xs) = x : odds xs; odds (x:[]) = [x]; in (ap zip tail) "hello"
03:56:20 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
03:56:33 <pierre-> > let f s = map snd $ filter (fst) $ zip (cycle [True,False]) $ ap zip tail in f "Hello world"
03:56:34 <lambdabot>      Expecting a function type, but found `m (a -> b)'
03:56:35 <lambdabot>       Expected type: [...
03:56:40 <Andris> Syzygy-: a very simple interpreter :)
03:56:47 <Andris> but I tend to overgeneralize
03:56:48 <dons> yeah
03:56:55 <goltrpoat> oh, that didn't quite work did it.
03:57:25 <Andris> so what I need for starters is just instance Group [Goal] [Goal] where
03:57:25 <Andris> 	open [] = Nothing
03:57:25 <Andris> 	open (g:gs) = Just (g, gs)
03:57:25 <Andris> 	close gs gs2 = gs ++ gs2
03:57:48 <apfelmus> Andris: lambdabot doesn't eat type declarations currently, so no luck for lambdabot-supported interactive type hackery today
03:57:56 <dons> dcoutts__: I'm arriving on Wednesday morning
03:58:03 <dons> dcoutts__: check the Attendees page for flight info
03:58:08 <dcoutts__> dons: ok :-)
03:58:15 <Andris> the idea was to have a closed and open representation of the group (a la zipper)
03:58:21 <Andris> well, one-step zipper
03:58:24 <dcoutts__> dons: so that's morning of day 1 of the conference. Right O.
03:58:43 <Andris> so by open I take one goal out of it, and it remembers how it opened
03:58:55 <apfelmus> Andris: what shall a "group" be?
03:58:57 <Andris> then by close I put descendants of the goal back
03:59:03 <dons> dcoutts__: yep
03:59:19 <dons> i'll catch the bus up with bringert and binkley I guess
03:59:22 <Andris> it's a group of goals or tasks with its own scheduler
03:59:33 <Andris> whcih is hidden from the main interpreter
03:59:49 <apfelmus> Andris: ah, logic programming i guess
03:59:59 <Andris> well, almost
04:00:07 <Andris> concurrent logic programming :)
04:00:21 <pierre-> > let f = map snd $ filter (fst) $ zip (cycle [True,False]) $ ap zip tail in f "Hello world"
04:00:23 <lambdabot>      Expecting a function type, but found `m (a -> b)'
04:00:23 <lambdabot>       Expected type: [...
04:00:50 <vegaiW> How many people would be interested in a #happs?
04:00:55 <dcoutts__> dons: right, and I did give you the option of your own personal space at the YHA rather than demanding that you stay with me? :-) I mean, you're most welcome to stay with me but if you'd prefer a private room the YHA is just down the road.
04:01:21 <Andris> initially I wanted to have a pair of ([Goal], [Goal]->Goal) instead of Group
04:01:26 <dcoutts__> dons: and kolmodin will be staying with us too
04:01:36 <JKnecht> i would
04:01:39 <Andris> but then I realized that putting goals back is task of the scheduler as well
04:02:16 <Andris> so I would need ([Goal], [Goal]->Goal, [Goal]->[Goal]->[Goal])
04:02:25 <dons> dcoutts__: ah right. I've booked a room at the 'Europa Hotel' or something, with bringert and beschmi :)
04:02:30 <dons> we got a fancy room when booking for 3
04:02:30 <apfelmus> Andris: ok, and now you want type checked opening and closing. Why? I mean, o == c should always do the trick.
04:02:37 <Andris> but some schedulers really need to keep more info than just a sequence of goals
04:02:39 <dons> (on the cheap)
04:02:40 <dcoutts__> dons: ok, np.
04:02:45 <dcoutts__> dons: nice :-)
04:02:48 <JKnecht> sounds liek Hlog
04:02:58 <dons> dcoutts__: do we have details for the Nice hotel yet?
04:03:06 <dons> I'd like to be able to tell my GF where I'm staying :)
04:03:08 <vegaiW> Not many, I see :) Well, I hope you don't mind if I mention it infrequently
04:03:12 <dcoutts__> dons: oh yes, that, lemme check
04:03:26 <Andris> apfelmus: o == c does not work, as c is a container, while o is a container with a hole
04:03:38 <JoshTriplett> > let pairs = filterlist (cycle [True,False]) . ap zip tail in pairs "hello world!"
04:03:40 <lambdabot>  [('h','e'),('l','l'),('o',' '),('w','o'),('r','l'),('d','!')]
04:03:52 <bakert> is there an implementation of a Queue ADT in any of the standard libraries?
04:03:54 <Andris> I might want to look for examples of coding zippers using type classes
04:03:56 <goltrpoat> filterlist?
04:03:57 <pierre-> vegai: i'm very interested
04:04:10 <goltrpoat> :t filterlist
04:04:11 <lambdabot> Not in scope: `filterlist'
04:04:14 <pierre-> *vegaiW:
04:04:17 <goltrpoat> meh?
04:04:18 <goltrpoat> hehe
04:04:20 <JoshTriplett> goltrpoat: @
04:04:29 <dons> bakert: yeah, in Edison
04:04:31 <dons> ?where edison
04:04:31 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
04:04:33 <dcoutts__> dons: "Hotel Plaza" which must be associated with the "Park Hotel" since the latter booked us into the former.
04:04:39 <goltrpoat> @type filterlist
04:04:40 <lambdabot> Not in scope: `filterlist'
04:04:41 <bakert> thanks dons
04:04:41 <dons> ah ok.
04:04:48 <dcoutts__> dons: I'll ask the secretary for the full details
04:04:50 <dons> dcoutts__: got an email or confirm you could forward me?
04:04:53 <JoshTriplett> goltrpoat: @ let filterlist b l = map snd . filter fst $ zip b l
04:04:58 <goltrpoat> ohhh
04:05:01 <goltrpoat> you had a @let in there.
04:05:05 <dons> I'll need it for the immigration papers :)
04:05:09 <Andris> apfelmus: e.g., c may be a tree, while o a zipper
04:05:12 <dons> or customs or whoever it is who asks
04:05:18 <vegaiW> pierre-: I'm idling there currently, hoping that things will pick up.
04:05:35 <Andris> or c a list and o a pair of lists
04:06:02 <dcoutts__> dons: she says she has more details which she "will send" but hasn't done so, I'll ask.
04:06:14 <apfelmus> Andris: mh. in the list case, both types coincide. for priority queues, it's not clear what a 'hole' should be. btw, close can only accept *one* goal (to fill the hole)
04:06:29 <dcoutts__> dons: btw, ta for the zlib patch
04:06:35 <JoshTriplett> goltrpoat: Looks like hoogle doesn't look through defined functions either.
04:06:40 <dcoutts__> dons: what is lambdabot using it for ?
04:06:42 <dons> dcoutts__: cheers.
04:06:54 <dons> dcoutts__: the state files are now zlib compressed on serialisation :)
04:07:11 <dcoutts__> nice
04:07:13 <dons> (for the bytestring-based serialisers, the Binary based ones can't yet
04:07:17 <Syzygy-> ?type map snd . filter fst $ zip
04:07:18 <lambdabot>     Expecting a function type, but found `a'
04:07:19 <lambdabot>       Expected type: [(Bool, b)]
04:07:19 <dons> due to the issue with reading from Handles
04:07:30 <dons> didn't we have a tricky Binary using ContT or something... ?
04:07:35 <dons> on top of lazy bytestrings?
04:07:47 <dcoutts__> dons: yes, kolmodin is working on it, he's got a first thing working
04:07:53 <Andris> apfelmus: a good catch, it really must accept a single Goal, which could contain a Group inside...
04:07:53 <dons> :t map snd . filter fst . zip
04:07:55 <lambdabot>     Expecting a function type, but found `b'
04:07:55 <lambdabot>       Expected type: [a] -> [(Bool, b)]
04:07:56 <JoshTriplett> Syzygy-: ideally ., there, but that doesn't DTRT with functions of all arities.
04:08:07 <dons> dcoutts__: ah ok. good. I'd like to get hold of it now. I have a use case!
04:08:09 <dcoutts__> dons: and tested it on a friend's prog with good results
04:08:10 <JoshTriplett> dons: Yeah, I tried to do that, but it wouldn't take.
04:08:34 <dcoutts__> dons: ping kolmodin, actually he linked to it the other day on haskel-cafe iirc
04:08:48 <dons> :t map snd . filter fst $ zip (cycle [True,False])
04:08:50 <lambdabot>     Expecting a function type, but found `a'
04:08:50 <lambdabot>       Expected type: [(Bool, b)]
04:09:03 * dons is sleepy. bed time!
04:09:09 <JoshTriplett> :t map snd . filter fst $ zip (cycle [True,False]) [1,2,3,4,5]
04:09:11 <lambdabot> forall b. (Num b) => [b]
04:09:46 <dcoutts__> g'night dons
04:09:59 <JoshTriplett> dons: Night, and thanks for the interesting definitions. :)
04:12:12 <apfelmus> dons: good night! btw, are there stuffed lambda for more peaceful slumbers?
04:16:23 <apfelmus> Andris: Actually, it doesn't accept a Goal but a 'c'. close :: c -> o -> c
04:16:54 <Andris> so it's more like graft?
04:17:17 <Andris> oooh, it reminds me of one paper by the author of Epigram
04:17:33 <Andris> hope I don't need to use Epigram to program this stuff :)
04:19:15 <JoshTriplett> > let groupsof n = filter ((==n).length) . filterlist (cycle (True : replicate (n-1) False)) . transpose . take n . tails in groupsof 3 [1..10]
04:19:17 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
04:19:55 <Andris> apfelmus: thanks for the help, I will go to read http://citeseer.ist.psu.edu/mcbride01derivative.html to clarify my thinking
04:19:56 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts (Extended Abst ...
04:20:13 <Andris> wow, nice feature
04:20:41 <Andris> ++
04:20:51 <apfelmus> of course, you always have the singleton group. mh. the interesting restriction, namely that close x c may use x only once ("linear in x") cannot be expressed in the type system. do you really need zippers?
04:23:54 <Andris> no, I don't
04:24:12 <posidon> Does anyone know if there's a planned Qt binding?
04:24:36 <Andris> just thought some of the schedulers may need all the info, like from where the original goal was picked, and this is the interface that came to mind
04:24:39 <kzm> What is the simplest/canonical way to check for the presence of an executable in $PATH?
04:24:41 <apfelmus> Andris: the point is that a zipper like o tracks the position where c will be inserted. for scheduling, i don't think that this makes sense. taking priority queues, the position depends mostly on c
04:25:12 <Andris> well, this position may be used for other purposes as well
04:25:13 <dons> kzm, findExecutable :: String -> IO (Maybe FilePath) ?
04:25:28 <dons> posidon: no one is working on one , afaik, though people often talk of it
04:25:35 <Andris> like calculating insertion position from picking position
04:25:35 <kzm> dons, you didn't make that up? :-)
04:25:36 <JKnecht> kzm: in realtime at the command line or programatically?
04:25:36 <apfelmus> Andris: anyway, the type class problem is independent of usefulness :)
04:25:38 <kzm> thanks.
04:25:42 <Andris> I know :)
04:26:06 <dons> ?hoogle findExecutable
04:26:07 <lambdabot> System.Directory.findExecutable :: String -> IO (Maybe FilePath)
04:26:19 <apfelmus> Andris: so where did the existential problems arise?
04:26:46 <Andris> I want to hide both the data structure and the selection algorithm inside Group class
04:26:56 <Andris> so the evaluator is unaware of them
04:27:10 <Andris> as I expect some of the schedulers to be supplied by application programmers
04:27:54 <Andris> and hiding means existentials for me
04:28:16 <apfelmus> Andris: if you don't mix different scheduler type, you don't need existential stuff. just make your code polymorphic in o and c together with the type class constraint
04:28:25 <apfelmus> s/type/types
04:28:26 <Andris> yes I do mix
04:28:34 <Andris> and it can be nested
04:29:10 <apfelmus> Andris: example? why do you need mixing?
04:29:12 <Andris> e.g., a round-robin group containing several atomic goals as well as prioritized group and random group :)
04:29:34 <Andris> I am exploring possibilities of speculative executaion
04:29:39 <Andris> execution
04:30:03 <Andris> so change of scheduler may mean change of termination
04:30:26 <Andris> it's along the lines of Algorithm = Logic + Control
04:30:42 <Andris> and the programmer must provide both
04:31:02 <Andris> unlike in Prolog, where it can provide only Logic, and rely on the built-in Control
04:31:34 <apfelmus> you mean something like scheduler :: c -> Result?
04:32:40 <apfelmus> sure, the programming can freely plug control and logic together, but the question is whether he needs to mix two different logics and plug the result to a common control
04:34:05 <Andris> the idea is that Group is a scheduler (Control) and a container of Goals (Logic)
04:34:42 <Andris> but some of the Goals can be Groups as well
04:35:17 <Andris> containing different logic driven by different control
04:36:20 <Andris> ok, I guess I will start with polymorphic code
04:37:11 <Andris> apfelmus: thanks again, it was a pleasure to discuss this stuff with you
04:37:18 <Andris> bye!
04:39:11 <ClaudiusMaximus> seems GSLHaskell doesn't work with ghc-6.4.2, unless i'm doing something silly?   "./GSL/Core.hs:313:13: Not in scope: `getBounds' "
04:41:07 <diegito> @paste
04:41:08 <lambdabot> http://paste.lisp.org/new/haskell
04:41:09 <apfelmus> Andris: you're welcome! :)
04:42:22 <apfelmus> rats, too late.
04:42:35 <kzm> ?type getEnv
04:42:37 <lambdabot> Not in scope: `getEnv'
04:42:40 <kzm> @hoogle getEnv
04:42:41 <lambdabot> System.getEnv :: String -> IO String
04:42:41 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
04:43:01 <apfelmus> ClaudiusMaximus: interface change between 6.4.2 and 6.6
04:43:14 <kzm> Why not: getEnv :: String -> IO (Maybe String)?
04:44:27 <JoshTriplett> kzm: Most IO stuff doesn't use Maybe; it uses errors instead.
04:44:50 <kzm> Hmm... must I use catch?
04:44:53 <dons> kzm, you could modify:
04:44:57 <dons> getProxy = handle (\_ -> return Nothing) $ do
04:44:57 <apfelmus> kzm: urg, it will raise an exception.
04:44:57 <dons>     env <- M.fromList `fmap` getEnvironment
04:44:57 <dons>     return $! do
04:44:57 <dons>         s <- M.lookup "http_proxy" env
04:45:02 <dons> ...
04:45:20 <dons> or just M.fromList `fmap` getEnvironment
04:45:27 <dons> and do your own Maybe lookups
04:46:00 <JoshTriplett> Or use try and either.
04:46:04 <kzm> Yes.  Slightly surprised it's not that way already.
04:46:09 <dons> me too
04:46:13 <dons> I'm thinking of submitting a patch
04:46:16 <kzm> @hoogle catch
04:46:17 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
04:46:18 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
04:46:18 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
04:46:46 <diegito> hi everybody, i need just a quick help on the little prog i post right now...
04:46:56 <lisppaste2> diegito pasted "example" at http://paste.lisp.org/display/34055
04:47:21 <diegito> it's trivial, but i can't find the error
04:48:01 <Botje> what's minOdd supposed to do?
04:48:08 <Botje> find the smallest odd number?
04:48:27 <diegito> given a list take out the 2 smallest odd numbers
04:49:04 <JoshTriplett> diegito: Well, first of all, your code would look clearer if you used "odd" rather than mod 2 == 1.
04:49:24 <diegito> ok
04:49:32 <Botje> you could foldl .... $ filter odd funz too
04:49:41 <Botje> that way, you ony have to take care of odd numbers
04:50:03 <apfelmus> > let minOdd = take 2 . sort . filter odd in minOdd [5,4,3,2,1]
04:50:05 <lambdabot>  [1,3]
04:50:55 <JoshTriplett> Hmmm, I wonder: does sort optimize for taking elements off the front?
04:50:58 <apfelmus> diegito: if you use mergesort, the complexity will be O(n) instead of O(log n*n)
04:51:19 <apfelmus> head . mergesort is O(n)
04:51:34 <apfelmus> head . quicksort is O(n log n)
04:51:40 <JoshTriplett> apfelmus: Hence why I wondered.  I dunno if sort == mergesort.
04:52:23 <diegito> apfelmus: but mergesort hasn't O(n log n) as complexity?
04:52:36 <apfelmus> JoshTriplett: i think Data.List.sort unfortunately is quicksort
04:53:07 <JoshTriplett> diegito: If it completes, yes.  But Haskell's laziness helps here: if you only need the first two items, and sort can supply the first two items without computing the whole list, it will.
04:53:15 <goltrpoat> diegito:  i'm guessing `mod` instead of mod
04:53:16 <JoshTriplett> diegito: mergesort can supply partial results easily.
04:53:18 <Templar2> I got this function: subsets (x:xs) = subsets xs ++ [x:ys | ys <- subsets xs]   (with basecase subsets [] = [[]] ). But I dont understand how it works (utput all diffrent list combinations). Can anyone make it more simpel so it becomes more easy to understand?
04:53:31 <apfelmus> diegito: sure, but thanks to lazy evaluation, only a part of the sorting algorithm will actually be executed.
04:54:00 <goltrpoat> diegito:  or at least, that gives minOdd a reasonable type
04:54:12 <diegito> oh, yes, lazyness... i have to get comfortable with it... :P
04:54:35 <apfelmus> diegito: the right smiley is :)
04:54:43 <diegito> goltrpoat: if i use 'mod' it gives me an error...
04:54:51 <goltrpoat> wrong quote marks.
04:54:53 <JoshTriplett> Templar2: It doesn't get much simpler than that.  Think about the cases: the subsets of a list with head x and tail xs consist of the subsets of the xs plus the subsets of the xs with x prepended to each.
04:54:55 <goltrpoat> `mod` not 'mod'
04:55:00 <JoshTriplett> Templar2: Another way to write it:
04:55:30 <JoshTriplett> let subsets (x:xs) = subsets xs ++ map (x:) subsets xs in subsets [1,2,3]
04:55:37 <JoshTriplett> > let subsets (x:xs) = subsets xs ++ map (x:) subsets xs in subsets [1,2,3]
04:55:38 <lambdabot>      The function `map' is applied to three arguments,
04:55:38 <lambdabot>     but its type `(a -...
04:55:44 <JoshTriplett> > let subsets (x:xs) = subsets xs ++ map (x:) (subsets xs) in subsets [1,2,3]
04:55:46 <lambdabot>   Non-exhaustive patterns in function subsets
04:55:48 <goltrpoat> alternatively, odd x instead of (abs x) `mod` 2 == 1 && x<a is fine
04:55:52 <goltrpoat> err.
04:55:55 <goltrpoat> odd x && x < a
04:56:03 <opqdonut> JoshTriplett: you need subsets [] = [[]]
04:56:09 <JoshTriplett> opqdonut: Yeah.
04:56:26 <JoshTriplett> > let subsets (x:xs) = subsets xs ++ map (x:) (subsets xs) ; subsets [] = [[]] in subsets [1,2,3]
04:56:27 <goltrpoat> still probably doesn't do what you want though
04:56:28 <opqdonut> > let { subsets [] = [[]]; subsets (x:xs) = subsets xs ++ map (x:) (subsets xs)} in subsets [1,2,3]
04:56:28 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:56:29 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:56:32 <opqdonut> :)
04:56:34 <diegito> goltrpoat: ok, i'll use odd
04:56:49 <JoshTriplett> Templar2: That might make the algorithm clearer.
04:57:04 <JoshTriplett> Templar2: It also highlights the fact that this algorithm does extra computation.
04:57:24 <opqdonut> subsets xs twice?
04:57:28 <JoshTriplett> Yeah.
04:57:43 <opqdonut> well, the compiler will probably just optimize those away
04:57:51 <Templar2> JoshTriplett ok, dont understand it yet but will try to look at it some hours
04:57:59 <augustss> no, it will not be optimized away
04:58:00 <JoshTriplett> Templar2: So, think about it this way.
04:58:14 <augustss> it's a dangerous oprtimization
04:58:25 <opqdonut> oh?
04:58:28 <diegito> goltrpoat: yes, it doesn't it's a type problem i think, because the type of funz is not what i expected it to be and i don't understand why
04:58:28 <JoshTriplett> augustss: Not with referential transparency...
04:58:43 <opqdonut> yeah, that's what i thought
04:58:46 <goltrpoat> diegito:  what do you want funz to do?
04:58:57 <augustss> not in the sense that you'll get the wrong answer, but you get a space leak
04:59:02 <apfelmus> > let subsets = foldr (\x s -> s ++ map (x:) s) [[]] in subsets [1..3]
04:59:03 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:59:12 <JoshTriplett> Templar2: If I give you the list [1,2,3], you might compute the subsets like this: look at the 1, and say that you want all the subsets without 1 and all the subsets with 1.
04:59:41 <JoshTriplett> Templar2: So you first compute the subsets of [2,3], and then include each one of those twice, once without 1 and once with.
04:59:43 <augustss> say that the list is really long, e.g. 500M, if you compute 'subsets xs' once you need to hold on to that list for the second use
04:59:53 <opqdonut> ah
05:00:15 <JoshTriplett> augustss: I see.  So, in the same vein, memoizing as an optimization causes a space leak?
05:00:22 <JoshTriplett> augustss: True, but possible to avoid.
05:00:22 <augustss> JoshTriplett: yes
05:00:36 <JoshTriplett> augustss: You can decide when to throw away intermediate values.
05:01:06 <augustss> I don't see how to avoid that leak if you hol on to 'subset xs'
05:01:38 <diegito> goltrpoat: funz is applied to every element of the list by the fold and it compares the element with the first elem in the couple (a,b) (i.e. a)
05:01:43 <augustss> but you can decide which version you want yourself.  if you want to compute 'subset xs' once, just use a 'let' or 'where'
05:01:48 <JoshTriplett> augustss: When you memoize as an optimization, you can throw away memoized values whenever you decide you don't have the space.
05:02:16 <JoshTriplett> augustss: But in any case, if you reverse the order, you could take advantage of the fact that you need that tail anyway.
05:02:27 <augustss> JoshTriplett: oh, I see what you mean
05:02:28 <opqdonut> ?pl \x s -> s ++ map (x:) s
05:02:28 <diegito> goltrpoat: if it's odd and < a the couple becomes (x,a) (x is the elment of the list)
05:02:29 <lambdabot> ap (++) . map . (:)
05:02:57 <ClaudiusMaximus> > let f 0 _ = [[]]; f n xs = [a : rest | (a:as) <- tails xs, rest <- f (n-1) as] in concat (zipWith f [0..4] (repeat [1..4]))   -- based on something glguy sent me for a different problem, it could solve this one?
05:02:59 <lambdabot>  [[],[1],[2],[3],[4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[1,2,3],[1,2,4],[1,3...
05:03:23 <goltrpoat> diegito:  right, but that doesn't do you much good.  if xs consists of nonnegative numbers, you get (0,0).  if it has a negative number, you get the smallest negative number in the list.
05:03:36 <goltrpoat> er.  smallest odd number in the list, rather
05:03:42 <goltrpoat> which, i'm guessing, is not what you're going for.
05:03:47 <ClaudiusMaximus> > let f 0 _ = [[]]; f n xs = [a : rest | (a:as) <- tails xs, rest <- f (n-1) as] in length (concat (zipWith f [0..4] (repeat [1..4])))
05:03:48 <lambdabot>  16
05:04:03 <JoshTriplett> augustss: in the expression (map (x:) (subset xs) ++ subset xs), the compiler could safely save away subset xs, and then use it as the tail of the final answer.
05:04:47 <JoshTriplett> augustss: And a smart compiler will know when it can preserve that optimization all the way up, by tacking stuff onto the end of lists when it no longer needs the original.
05:04:55 <diegito> goltrpoat: u're right...
05:05:57 <augustss> JoshTriplett: unless the compiler is doing the throwing away trick you mentioned it can't safely save 'subset xs'
05:06:31 <JoshTriplett> augustss: Sure it can.  Given the list x, it doesn't need to trash x to create y ++ x.
05:06:33 <augustss> JoshTriplett: say that 'subset xs' is too big to fit in memory.  you can't safely save it then
05:07:02 <diegito> goltrpoat: ignoring that "little"  mistake the type of that function should be funz ::(eq a, Ord a) => a->(a,a)->(a,a) isn't it?
05:07:19 <JoshTriplett> augustss: Hmmm, true; this optimization requires strictness.
05:07:29 <augustss> JoshTriplett: remember that we have lazy evaluation, so the 'subset xs' is generate in a stream-like way
05:07:48 <augustss> JoshTriplett: oh, with strictness it's a whole other game
05:08:49 <goltrpoat> diegito:  if you want a -> (a,a) -> (a,a) then you should probably make that (0,0) an argument instead of a constant :)
05:08:54 <goltrpoat> the way it is, it's a -> (a,a)
05:09:10 <goltrpoat> er.  [a] -> (a,a)  (i'm assuming you meant [a] for the first argument)
05:09:37 <JoshTriplett> goltrpoat: If you like the one-liner RLE decoder, check out the lookandsay sequence:
05:09:40 <JoshTriplett> > let say = read . concatMap saygroup . group . show where saygroup s = (show $ length s) ++ [head s] in let lookandsay = 1 : map say lookandsay in take 10 lookandsay
05:09:42 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
05:10:06 <goltrpoat> hah!
05:10:14 <goltrpoat> very cool, thanks.
05:10:42 <JoshTriplett> goltrpoat: I love how you can state the lookandsay sequence in Haskell with just "lookandsay = 1 : map say lookandsay".
05:10:44 <augustss> neat
05:11:28 <goltrpoat> -nod- and say just basically states the problem.
05:11:30 <augustss> saygroup=show.length
05:11:40 <goltrpoat> maybe move the concatMap into saygroup for clarity
05:11:42 <diegito> goltrpoat: the type of minOdd is [a] -> (a,a) but the type of the internal function "funz" is a->(a,a)->(a,a)?
05:11:42 <goltrpoat> oh and.. that.
05:12:01 <JoshTriplett> augustss: No, saygroup has to include the number and the length.
05:12:04 <goltrpoat> diegito:  oh sorry, misread
05:12:15 <JoshTriplett> augustss: saygroup "111" == "31"
05:12:29 <augustss> oh, sorry.  i missed the ++ [heads].  it was on the next line on my screen
05:13:03 <augustss> @pl \ s -> (show $ length s) ++ [head s]
05:13:03 <lambdabot> ap ((++) . show . length) (return . head)
05:13:10 <augustss> no improvement
05:13:10 <goltrpoat> diegito:  funz is (Integral a) => (a,a) -> a -> (a,a), no?
05:13:27 <JoshTriplett> augustss: Yeah, some things just shouldn't use points-free.
05:13:35 <augustss> JoshTriplett: I agree
05:13:47 <goltrpoat> (Integral due to odd)
05:14:33 <JoshTriplett> goltrpoat: Moving the concatMap into saygroup would turn saygroup into saygroups, no?
05:15:15 <goltrpoat> josh:  sure, just makes say more readable, though.  show the digits, then group them, then show the groups, etc.
05:15:19 <augustss> JoshTriplett: i prefer it this way
05:15:21 <JoshTriplett> goltrpoat: And doing so would require either a lambda or another where.
05:15:40 <JoshTriplett> goltrpoat: Because concatMap needs a function, and that function needs to use pointful style.
05:15:51 <goltrpoat> technicalities :)
05:16:18 <JoshTriplett> goltrpoat: But defining saygroups = concatMap saygroup couldn't hurt.
05:16:27 <diegito> goltrpoat: my ghc gives me the following: well, something i cant describe but it fills half of the screen.size
05:17:14 <goltrpoat> diegito:  hmm?  what you have right now should typecheck, right.  it's just the algorithm itself is broken
05:18:10 <diegito> something like: (Ord ((a1 ->a1 -> a1) t -> a),Num a, num t ...
05:18:35 <JoshTriplett> goltrpoat: The code would also get a lot shorter if I created the list as a list of String, and mapped read onto it.
05:20:48 <diegito> goltrpoat: it was the "mod" which has broken all the code and the type of the funciton...
05:21:47 <diegito> thanks for the help... :D
05:25:04 <goltrpoat> [06:45] <goltrpoat> diegito:  i'm guessing `mod` instead of mod
05:25:08 <goltrpoat> so.. yes :)
05:26:28 <goltrpoat> @pl \x -> (show $ length x) ++ [head x])
05:26:29 <lambdabot> (line 1, column 36):
05:26:29 <lambdabot> unexpected ")"
05:26:29 <lambdabot> expecting variable, "(", operator, ":", "++" or end of input
05:26:33 <goltrpoat> @pl \x -> (show $ length x) ++ [head x]
05:26:34 <lambdabot> ap ((++) . show . length) (return . head)
05:26:45 <goltrpoat> so much for that idea.
05:39:20 <goltrpoat> > let say = 1 : map (\x -> (read . concat) [(show $ length y) ++ [head y] | y <- (group . show) x]) say in take 10 say
05:39:21 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
05:40:04 <goltrpoat> can't think of a better way to put it, unless there's some arrow magic i'm missing
05:41:12 <goltrpoat> josh:  shouldn't that group . show be group . sort . show btw?  in other words, shouldn't 111221 be 3112
05:42:22 <goltrpoat> actually i think ive seen both versions, nevermind
05:58:09 <wy> I guess I need a stronger tracer than Debug.Trace.trace. It just can't display anything when my code falling into infinite loops
05:59:30 <dons> perhaps compile with -prof and check the top of the stack trace
05:59:37 <dons> -prof -auto-all
06:01:55 <wy> I compiled it with the option. Then how do I look at the stack trace?
06:13:47 <kzm> dons?
06:13:50 <kzm> Prelude> :i System.Posix.getEnv
06:13:50 <kzm> System.Posix.Env.getEnv :: String -> IO (Maybe String)
06:13:50 <kzm>         -- Defined in System.Posix.Env
06:13:59 <kzm> Just thought you'd like to know :-)
06:14:15 <kzm> @hoogle getEnv
06:14:15 <lambdabot> System.getEnv :: String -> IO String
06:14:16 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
06:40:30 <metaperl> hmm, external libs dont necessarily have profiling libs installed:       Perhaps you haven't installed the profiling libraries for package hxt-7.0?
06:45:04 <Elifant_> hello all! if I need function which may fail and do IO, do I have to use 'IO (Either Exception Result)' or 'ErrorT Exception IO Result', and why?
06:45:50 <kpreid> IO does have its own exception scheme, but you *can* use those
06:46:38 <kpreid> ?instances MonadError
06:46:39 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
06:47:04 <Elifant_> IO errors can't carry needed info, user error may contain only string
06:47:17 <kpreid> then you'll probably want ErrorT
06:47:27 <kpreid> @type runErrorT
06:47:29 <lambdabot> forall a e (m :: * -> *). ErrorT e m a -> m (Either e a)
06:47:39 <Elifant_> ok, but how is it different from 'IO (Either Exception Result)
06:47:56 <kpreid> in that fail and mzero will produce your errors
06:48:07 <kpreid> and errors will stop execution
06:48:23 <kpreid> in IO (Either Exception Result) if the return value of some action is ignored, it doesn't stop
06:48:42 <kpreid> in ErrorT ..., the exception case is part of the monad and will stop execution
06:48:44 <Elifant_> tnx, this is what I missed...
06:48:55 <kpreid> note that runErrorT turns the latter into the former
06:49:08 <kpreid> you use it at the outermost level when you're done doing things-that-might-fail
06:49:38 <Elifant_> and I have to use liftIO inside this function to do IO?
06:50:24 <kpreid> also, if you want to store user-defined info you'll want to define your own exception type and give it an Error instance
06:50:36 <kpreid> you can use liftIO or lift
06:50:58 <kpreid> or use IO functions which are defined for MonadIO a => a rather than IO
06:51:17 <kpreid> @type putStrLn
06:51:19 <lambdabot> String -> IO ()
06:51:40 <kpreid> @let putStrLnL = liftIO . putStrLn
06:51:41 <lambdabot> <local>:6:12:     Ambiguous type variable `m' in the constraint:       `Monad...
06:51:47 <kpreid> hm
06:52:46 <Elifant_> io action aren't permitted for bot, afaik
06:53:10 <int-e> > putStrLn "foo" -- well, it does something funny
06:53:10 <Elifant_> the only function for MonadIO is liftIO :)
06:53:14 <lambdabot>  <IO ()>
07:01:25 <george--> if i have a IO [String], how can i print that on screen?
07:01:52 <george--> i kinda want something like putStr unwords var
07:03:44 <ClaudiusMaximus> @hoogle IO [String] -> IO ()
07:03:45 <lambdabot> No matches, try a more general search
07:03:56 <ClaudiusMaximus> @hoogle IO [a] -> IO ()
07:03:57 <lambdabot> No matches, try a more general search
07:04:30 <Jaak> foo >>= print where foo is IO [String]?
07:04:56 <ph8> hi all
07:04:58 <ClaudiusMaximus> :t mapM putStr
07:04:59 <lambdabot> [String] -> IO [()]
07:05:00 <apfelmus> george--: (>>= putStrLn . unlines) ?
07:05:01 <ph8> it's right that i can't do this:
07:05:01 <ph8> >	where
07:05:01 <ph8> >	firstResult <- repGen a theMap []
07:05:05 <ph8> yes?
07:05:18 <ph8> but i could just replace everywhere i've used firstResult in the function with repGen a theMap [] and it would work?
07:05:33 <ph8> ah but thinking about it i can't do that
07:05:37 <ph8> i need only one result for repGEn
07:06:45 <george--> abfelmus: ty
07:06:45 <ClaudiusMaximus> :t do t <- blah::IO[String] ; mapM putStr t ; return ()
07:06:47 <lambdabot> Not in scope: `blah'
07:07:02 <george--> ph8: still doing callaghan?
07:07:11 <ph8> lol, yes
07:07:14 <ph8> almost there now
07:07:16 <ClaudiusMaximus> :t let f x = do t <- x ; mapM putStr t ; return () in f
07:07:18 <lambdabot> IO [String] -> IO ()
07:07:22 <george--> yeah, this is first time i have looked at it since we last spoke
07:07:49 <lisppaste2> ph8 pasted "This is what i'm 'trying' to do" at http://paste.lisp.org/display/34060
07:08:03 <ClaudiusMaximus> hmm, apfelmus's way is much more elegant :)
07:08:08 <ph8> i might have to rewrite it in a more cunning way?
07:08:13 <ph8> unless anyone can see a quick way around that problem?
07:08:17 <george--> my program is just being ridiculously stubborn in that it works if i try and generate the next word, but when implemented in the generate next sentence function it doesnt work and i just cant see why
07:08:28 <ph8> it complains about the <- in the where clause, btw
07:08:43 <ph8> ah the above paste is my attempt at the next generation function
07:08:47 <ph8> although if you look it's plageurism! :p
07:10:02 <ph8> you're looking now aren't you? :p
07:10:31 <george--> yes
07:11:41 <apfelmus> ClaudiusMaximus: not necessarily. (>>= mapM putStrLn) can do as well. besides, the other version is buggy and should read (>>= putStr . unlines)
07:11:43 <george--> considering im doing the same thing and should have insight
07:11:48 <george--> i cant really follow it =)
07:11:53 <ph8> :o)
07:11:57 <ph8> it's the one to generate x number of sentences
07:12:06 <ph8> i suppose you have to know repGen to make sense of it
07:12:20 <ph8> are you there did you say? or the stage before?
07:12:26 <ph8> where you only generate up to '.'
07:12:51 <ClaudiusMaximus> :t >>=
07:12:52 <george--> generating a single sentence
07:12:53 <lambdabot> parse error on input `>>='
07:12:57 <ClaudiusMaximus> :t (>>=)
07:12:59 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
07:13:05 <ph8> are you using his recommended map structure?
07:13:17 <george--> but at the moment mine is being stubborn in the case where there is more than one option of word to choose
07:13:28 <george--> it instead picks something random from what i cans ee
07:13:36 <ph8> heh?
07:13:38 <ph8> that sounds interesting
07:13:45 <ph8> bad randomness
07:13:52 <george--> yes :P
07:14:04 <george--> i have been trying to work out why for about 6 hours
07:14:11 <ph8> that part took me a similar amount of time
07:14:14 <ph8> the function looks gross as well
07:14:26 <ph8> i only have today and tomorrow to finish this but hopefully i can get the code working tonight and write the essay tomorrow
07:14:31 <ph8> i'm back in durham with bugger all else todo :p
07:15:18 <george--> why only today/tomorrow?
07:15:32 <george--> and why back in durham SO early?!
07:15:55 <ph8> going skiing on the 5th
07:15:59 <ph8> avec mon college
07:16:02 <ph8> fear my french skills :)
07:16:17 <george--> hah
07:16:34 <george--> fair enough. i have absolutely tons of physics work to do for the first week back
07:16:47 <george--> and left all my books in durham, so i may go back around 11th
07:16:49 <ph8> i don't envy the problems :)
07:17:40 <lisppaste2> ToRA annotated #34060 with "Stabbed guess at how to fix this maybe (no guarantees, untested)" at http://paste.lisp.org/display/34060#1
07:18:59 <ToRA> ph8: think of it more as how the syntax should work, i've not looked at what you're trying to do...just what it looks like you're trying to do ;)
07:21:02 <ph8> cheers Tora, i'll give it a crack as soon as i've devoured this pizza
07:21:40 <ToRA> k, make noise if what's going on with the do, <-, and let don't make sense
07:22:52 <ph8> ty muchly
07:26:56 <ToRA> ok, my question: I have an IORef a, and a function (a -> IO a), is there a way of updating the IORef using modifyIORef (or some variant i can't seem to see) or do i need to write a helper using readIORef and writeIORef?
07:28:50 <jethr0> @hoogle modifyIORef
07:28:51 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
07:28:51 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:29:16 <ToRA> there's an irritating lack of IO on the return type of the update function
07:30:02 <jethr0> yeah, my guess is that you'd have to use readIORef at some point...
07:30:36 <ToRA> yeah
07:30:41 <syntaxfree> programming.reddit.com is definitely gone to crap.
07:30:53 <syntaxfree> they linked to a defmacro post complaining about his healthcare provider.
07:31:01 <jethr0> you could of course write your own variant "modify' ref f = do {a <- readIORef ref; let a' = f a; writeIORef ref a'; return a'}"
07:31:10 <jethr0> but i'm really "just talking" :)
07:31:23 <syntaxfree> sure, defmacro is a good programming blog, but is reddit supposed to be a blind announcement service for programming blogs like Planet Haskell?
07:31:42 <ToRA> jethr0: yeah true
07:32:04 <ToRA> it just strikes me that if you're programming with iorefs, it's not beyond the realm of possibility that you're update functions would use them too
07:32:09 <ph8> http://paste.lisp.org/display/34060
07:32:18 <ph8> that doesn't display for me
07:32:20 <ph8> is it broken for others?
07:32:22 <jethr0> sometimes modify functions are lacking a return value. i've got the same problem with Control.Monad.State.modify
07:33:00 <ToRA> jethr0: i think the next problem I'm going to have is a -> IO a's inside state modify's too
07:33:12 <ToRA> ooh
07:33:17 <jethr0> ToRA: i guess the intention is to have functions do one thing and one thing well. so that modification and reading are seen as separate actions......
07:33:28 <ToRA> ph8: proxy error?
07:33:55 <ph8> yup
07:34:01 <ph8> good-o i'll wait for it
07:34:17 <syntaxfree> TorA: I feel that the key thought is  "separation of concerns"
07:34:20 <glguy> paste.lisp.org is terrible when it comes to "not being down"
07:34:22 <jethr0> @hoogle IORef a -> IO a
07:34:23 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
07:34:23 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
07:35:43 <jethr0> syntaxfree: well, there could still be a meta-function that has a sensible return value as well. but it seems sometimes sensible functions aren't thought to be clean enough, so that everyone has to reimplement them again and again
07:36:10 <jethr0> s/meta-/derived /
07:36:13 <ToRA> syntaxfree: yeah, i guess I'm thinking that modifyIORef has the capability to allow IO in the update function, since it has to return in IO and it just feels weak that there isn't a variant that allows you to use it, since it feels like people would want to use it.
07:36:30 <ToRA> (or at least /I/ want to use it!)
07:36:55 <jethr0> huh? i guess i misunderstood your question ToRA :)
07:37:02 * syntaxfree pioints all sensitive soulds in #haskell-blah 's general direction.
07:37:12 <syntaxfree> s/pionts/points
07:37:33 <jethr0> syntaxfree: np, i won't be flaming any more
07:37:44 <syntaxfree> it's not aboutthe flaming.
07:37:58 <syntaxfree> it's about something I'm kvetching about over there ; )
07:38:07 <jethr0> ah
07:39:21 <Elifant_> @paste
07:39:24 <lambdabot> http://paste.lisp.org/new/haskell
07:41:00 <ph8> hmm
07:41:05 <ph8> if i'm taking a string from argv
07:41:10 <ph8> which is actually an int
07:41:14 <ph8> can i cast it somehow?
07:41:22 <ph8> as i'm getting type errors when i try to submit it as an int argument of a function
07:41:27 <ClaudiusMaximus> :t read
07:41:28 <lambdabot> forall a. (Read a) => String -> a
07:41:35 <ph8> danke!
07:42:13 <ph8>  result <- (doRepGen (padKey genWords) theMap (read (argsList !! 1)) 0)
07:42:14 <ph8> like that?
07:42:23 <lisppaste2> Elifant pasted "Mixing  Either monads" at http://paste.lisp.org/display/34061
07:42:35 <jethr0> :t reads
07:42:36 <lambdabot> forall a. (Read a) => ReadS a
07:42:50 <ph8> eep?
07:42:52 <jethr0> reads is actually more runtime safe as it doesn't directly fail on wrong input
07:42:52 <Elifant_> how can I mix different 'Either String t' monads in a single 'do'?
07:43:09 <ph8> is that in place of read, or passing in read's output?
07:43:09 <tuukkah> i wonder how to write this better: \record -> record {field = f (field record)}
07:43:25 <jethr0> Elifant_: if the t's are different there aren't exactly combinable...
07:43:47 <ph8> @google reads
07:43:48 <jethr0> afaik, you can't use more than one monad inside a single do, unless you nest other monad operations in it
07:43:51 <lambdabot> http://www.reads.com/
07:43:51 <lambdabot> Title: READ'S restaurant with rooms
07:43:52 <ph8> @hoogle reads
07:43:53 <lambdabot> Prelude.reads :: Read a => ReadS a
07:43:54 <lambdabot> Prelude.ReadS :: type ReadS a
07:43:54 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
07:43:54 <ph8> lol typo
07:44:08 <Elifant_> jethr0: but what is a shortest way to propagate error automatically while evaluating Eithers?
07:44:08 <jethr0> > reads "124" :: Integer
07:44:09 <lambdabot>  Couldn't match `Integer' against `[(a, String)]'
07:44:13 <ph8> is it a newer function? my version of ghc says it doesn't exist
07:44:22 <jethr0> > reads "124" :: [(Integer,String)]
07:44:23 <lambdabot>  [(124,"")]
07:44:42 <ph8> ah was just a capitalisation thing
07:44:56 <ph8> Couldn't match `Integer' against `[(a, String)]'
07:44:56 <ph8>       Expected type: Integer
07:44:56 <ph8>       Inferred type: [(a, String)]
07:44:59 <ToRA> ph8: http://www.haskell.org/tutorial/stdclasses.html section 8.3 may be some help
07:45:00 <lambdabot> Title: A Gentle Introduction to Haskell: Standard Classes
07:45:01 <ph8> w00t!
07:45:09 <ph8> ta
07:45:20 <jethr0> Elifant_: you could have an "error" do and use ">>=" inside to work with the eithers
07:46:06 <Elifant_> jethr0: hm... any short example?
07:46:07 <jethr0> you'd just have to nest the monads (i.e. use monad transformers) and use nested do's
07:46:20 <tuukkah> isn't (Either String t) like (IO a) and you can mix them freely in a do block...
07:46:25 <AStorm> > read "123"
07:46:26 <lambdabot>  Add a type signature
07:46:30 <jethr0> Elifant_: i'm not quite sure what you're trying to do. are you inside ErrorM?
07:46:30 <AStorm> > read "123" :: Integer
07:46:31 <lambdabot>  123
07:46:48 <AStorm> > read "123abc" :: Integer
07:46:49 <lambdabot>  Exception: Prelude.read: no parse
07:46:59 <Syzygy-> > read "123 abc" :: Integer
07:47:01 <lambdabot>  Exception: Prelude.read: no parse
07:47:04 <jethr0> > reads "123abc" :: [(Integer,String)]
07:47:06 <lambdabot>  [(123,"abc")]
07:47:09 <AStorm> It's strict
07:47:12 <Elifant_> jethr0: process :: String -> ErrorT String IO Float
07:47:14 <ph8> reads "5" :: Integer
07:47:17 <Syzygy-> >read "123 456" ::Integer
07:47:20 <ph8> > reads "5" :: Integer
07:47:20 <lambdabot>  Couldn't match `Integer' against `[(a, String)]'
07:47:25 <ph8> that's my error
07:47:28 <ph8> how naff?
07:47:32 <AStorm> > read "123 456" :: Integer
07:47:34 <lambdabot>  Exception: Prelude.read: no parse
07:47:42 <AStorm> It indeed is strict.
07:47:47 <ph8> > (reads "5" :: [Integer, String]) !! 0
07:47:48 <lambdabot>  Parse error
07:47:49 <AStorm> You can always nest reads
07:47:50 <ph8> > (reads "5" :: [Integer, String]) !! 1
07:47:51 <lambdabot>  Parse error
07:47:53 <AStorm> No no
07:48:00 <AStorm> > reads "5" :: (Integer, String)
07:48:00 <ph8> > (reads "5" :: [(Integer, String)]) !! 1
07:48:01 <lambdabot>  Couldn't match `(Integer, String)' against `[(a, String)]'
07:48:02 <lambdabot>  Exception: Prelude.(!!): index too large
07:48:10 <AStorm> > reads "5" :: [(Integer, String)]
07:48:12 <lambdabot>  [(5,"")]
07:48:15 <ph8> > (reads "5" :: (Integer, String))
07:48:16 <lambdabot>  Couldn't match `(Integer, String)' against `[(a, String)]'
07:48:20 <AStorm> So no element no 1
07:48:21 <ph8> ah nice
07:48:26 <jethr0> Elifant_: also, you might think about lifting some functions (like "return") so that you'd only need a single "do".
07:48:30 <ph8> > (reads "5" :: [(Integer, String)] !! 0)
07:48:31 <lambdabot>  Parse error
07:48:34 <Syzygy-> ?type reads
07:48:35 <lambdabot> forall a. (Read a) => ReadS a
07:48:37 <jethr0> but i'm not the most qualified monad guru around for that
07:48:39 <ph8> > (reads "5" :: [(Integer, String)]) !! 0
07:48:40 <lambdabot>  (5,"")
07:48:46 <AStorm> > reads "5 3 2 1" :: [(Int, String)]
07:48:47 <lambdabot>  [(5," 3 2 1")]
07:48:53 <ph8> > ((reads "5" :: [(Integer, String)]) !! 0) !! 0
07:48:54 <lambdabot>  Couldn't match `[a]' against `(Integer, String)'
07:48:58 <ph8> > fst ((reads "5" :: [(Integer, String)]) !! 0)
07:48:59 <lambdabot>  5
07:49:01 <ph8> bonus.
07:49:14 <AStorm> I'd love a recursive reads variant
07:49:33 <AStorm> It normally only returns a single element (which is weird)
07:49:45 <AStorm> I'd prefer reading as much as is available...
07:49:50 <AStorm> Some separator?
07:50:03 <AStorm> ?type ReadS
07:50:05 <lambdabot> Not in scope: data constructor `ReadS'
07:50:17 <ClaudiusMaximus> > reads "1 2 3 4 5" ::[([Int], String)]
07:50:19 <lambdabot>  []
07:50:24 <AStorm> Nope.
07:50:35 <jethr0> > read "[1,2,3,4]" :: [Integer]
07:50:36 <lambdabot>  [1,2,3,4]
07:50:50 <AStorm> Yes, but w/o that "adorning"
07:51:15 <ClaudiusMaximus> AStorm: i guess you create your own Read instance
07:51:17 <AStorm> Maybe some reads + tail?
07:52:25 <lisppaste2> ph8 annotated #34060 with "Error with reads!" at http://paste.lisp.org/display/34060#2
07:52:26 <glguy> > (map read . words) "1 2 3 4  5" :: [Int]
07:52:27 <lambdabot>  [1,2,3,4,5]
07:52:34 <AStorm> glguy, hehe :-)
07:52:35 <ph8> it's being a bit uber rubbish
07:52:39 <AStorm> Forgot about that :P
07:52:58 <ph8> > (fst ((reads ("5") :: [(Integer, String)]) !! 0))
07:53:00 <lambdabot>  5
07:53:04 <AStorm> glguy, what about the comma?
07:53:13 <ph8> that's basically what i've got in my code
07:53:18 <ph8> apart from "5" is argsList !! 1
07:53:37 <ph8> :t getArgs
07:53:39 <lambdabot> Not in scope: `getArgs'
07:53:40 <AStorm> Does that exist?
07:53:42 <ph8> argsList <- getArys
07:53:45 <ph8> * getArgs
07:53:45 <glguy> AStorm: I came into this late, what are you trying to do?
07:53:52 <ph8> @hoogle getArgs
07:53:53 <lambdabot> System.getArgs :: IO [String]
07:54:02 <ph8> is it because it's IO?
07:54:36 <int-e> ph8: are you sure your 'Integer' is correct?
07:54:46 <ph8> well it's a compile-time error
07:54:56 <AStorm> It seems that fst is expecting (Int, b)
07:55:04 <AStorm> And you have a long integer.
07:55:21 <int-e> ph8: what happens if you replace that Integer in the type signature you gave by Int?
07:55:58 <AStorm> But that's weird, because fst should be type-independent
07:56:00 <AStorm> ?type fst
07:56:01 <lambdabot> forall a b. (a, b) -> a
07:56:12 <lisppaste2> ph8 annotated #34060 with "With 'Int' instead of 'Integer'" at http://paste.lisp.org/display/34060#3
07:56:19 <ph8> new and exciting error
07:56:36 <int-e> so the Integer was wrong.
07:56:47 <ph8> do you think, with that error?
07:56:57 <int-e> AStorm: nothing weird about it. The (Int, b) got inferred from one onf the functions that wasn't given in the code, I think.
07:57:02 <ph8> is there a difference between Int and Integer?
07:57:09 <AStorm> Length.
07:57:11 <int-e> AStorm: doRepGen.
07:57:12 <ph8> doRepGen asks for an Int, at that point
07:57:14 <glguy> > maxBound :: Int
07:57:15 <lambdabot>  2147483647
07:57:20 <glguy> > maxBound :: Integer
07:57:21 <lambdabot>   add an instance declaration for (Bounded Integer)
07:57:21 <lambdabot>     In the expression: ma...
07:57:25 <glguy> (it's not bounded
07:57:32 <ph8> oh(!)
07:57:38 <ph8> ok, so Int is correct
07:57:40 <AStorm> It seems that doRepGen is not a Monad
07:57:41 <int-e> > (2^32 :: Int, 2^32 :: Integer)
07:57:42 <lambdabot>  (0,4294967296)
07:57:45 <jethr0> ph8: Int are machine integers, whereas Integers are only bounded by your memory
07:57:46 <ph8> but why is first being cheeky?
07:57:54 <AStorm> So why then the <-?
07:58:03 <ph8> repGen returns IO [[Char]]
07:58:09 <ph8> * doRepGen
07:58:13 <ph8> but mainly because repGen does :p
07:58:21 <ph8> erm actually forget that
07:58:24 <int-e> so now it looks like you're missing some argument to doRepGen
07:58:27 <ph8> doRepGen's returninga [[char]]
07:58:36 <ph8> > doRepGen :: [[Char]] -> Map [[Char]] [[Char]] -> Int -> Int -> [[Char]] -> [[Char]]
07:58:37 <lambdabot>   Not in scope: type constructor or class `Map'
07:58:53 <ph8> oh i am
07:58:55 <jethr0> [[Char]] === [String]
07:58:58 <ph8> woot!
07:59:03 <ph8> i had issues using [String]
07:59:07 <ph8> so i chose to use [[char]] throughout
07:59:18 <AStorm> There should be no issues.
07:59:21 <ph8> indeed
07:59:22 <AStorm> It's just an alias.
07:59:24 <ph8> maybe it was just me
07:59:29 <ph8> should they be interchangeable?
07:59:32 <AStorm> Yes.
07:59:34 <jethr0> ph8: which interpreter/compiler are you using?
07:59:37 <ph8> ghc
07:59:37 <jethr0> yes
07:59:39 <AStorm> ?type String
07:59:39 <glguy> probably some other error that you attributed to the type-synonym
07:59:40 <lambdabot> Not in scope: data constructor `String'
07:59:44 <AStorm> Blah.
07:59:44 <jethr0> weird
07:59:47 <AStorm> ?hoogle String
07:59:48 <lambdabot> Foreign.C.String :: module
07:59:49 <lambdabot> Prelude.String :: type String
07:59:51 <lambdabot> Text.Read.String :: String -> Lexeme
07:59:57 <Syzygy-> ?src String
07:59:57 <lambdabot> type String = [Char]
08:00:03 <AStorm> ?src? :>
08:00:04 <lambdabot> Source for this function is not available.
08:00:06 <int-e> ph8: what you probably want there is   let result = <what you have now + the proper [String] argument>
08:00:25 <int-e> ph8: because doRepGen is pure, not an IO action.
08:00:29 <AStorm> ?src ReadS
08:00:30 <lambdabot> Source for this function is not available.
08:00:33 <AStorm> Hmm.
08:00:58 <AStorm> ?hoogle ReadS
08:00:59 <lambdabot> Prelude.ReadS :: type ReadS a
08:00:59 <lambdabot> Prelude.reads :: Read a => ReadS a
08:00:59 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
08:01:51 <ph8> well
08:01:55 <ph8> the error seems to have disappeared now.. :)
08:02:14 <ph8> seems to, i'm probably about to discover i need to change the return type of doRepGen :p
08:02:46 <AStorm> No, you don't, if it isn't an IO action.
08:02:52 <ph8> I return soFAR
08:02:54 <ph8> oops @ caps
08:03:07 <ph8> and get this little beauty
08:03:08 <ph8>     Couldn't match `Char' against `[[Char]]'
08:03:08 <ph8>       Expected type: Char
08:03:08 <ph8>       Inferred type: [[Char]]
08:03:08 <ph8>     In the list element: soFar
08:03:08 <ph8>     In the first argument of `return', namely `[soFar]'
08:03:18 <ph8> that's when i do return [soFar]
08:03:24 <AStorm> is soFar a list?
08:03:27 <ph8> without that it says expected: [Char], inferred [[Char]]
08:03:30 <ph8> it should be a [[Char]]
08:03:35 <shapr> @seen musasabi
08:03:35 <lambdabot> I haven't seen musasabi.
08:03:35 <jethr0> > let f (a,b) = if null b then a else (let [(x,y)] = reads b :: [(Integer,String)] in f (a++[x],y)) in f ([], "123 4 5 6")
08:03:37 <lambdabot>  [123,4,5,6]
08:03:38 <ph8> hmm actually
08:03:43 <shapr> hiya jethr0!
08:03:46 <jethr0> hey shapr
08:03:58 * jethr0 wishes a happy new year
08:04:08 <ph8> no that didn't work :/
08:04:23 <ph8> let result ... calls it with soFar as []
08:04:24 <AStorm> @pl f [(x,y)] = reads b
08:04:24 <lambdabot> (line 1, column 11):
08:04:25 <lambdabot> unexpected "="
08:04:25 <lambdabot> expecting variable, "(", operator or end of input
08:04:42 <ph8> and doRepGen recurses, adding to soFar - obviously this has to satisfy the [[Char]] property to work
08:04:47 <ph8> but then when i simply say 'return soFar'
08:04:50 <shapr> jethr0: happy new year! happy new code!
08:04:51 <ph8> it produces that bizarre error
08:04:54 <jethr0> shapr: had a good transition into the new year?
08:04:59 <AStorm> ph8, return == Monad
08:05:03 <shapr> Yup, lots of food.
08:05:05 <AStorm> Why do you want to?
08:05:07 <shapr> What about you?
08:05:11 <ph8> Monad?
08:05:13 <int-e> jethr0: hmm. that ++ doesn't look good.  f b = ... a : f y   will do better.
08:05:18 <ph8> i've heard the word mentioned but i have no idea what one is
08:05:20 <AStorm> Yes, it will.
08:05:28 <jethr0> shapr: well, i haven't been so lucky with code lately. maybe it's just one of those low periods
08:05:49 <AStorm> ph8, know Maybe, IO and Either?
08:05:54 <AStorm> Those are some.
08:05:57 <jethr0> int-e: very true! as always i was hacking (in the bad sense) myself to death *grr*
08:06:38 <ph8> i might have a google
08:06:42 <AStorm> It's a thingy that's not a function (not an argument:single value mapping)
08:07:39 <jethr0> shapr: me too. too much food as always
08:08:03 <jethr0> but i had a very serene new years party with lots of fireworks, etc...
08:08:39 <ph8> i see
08:08:50 <ph8> but a way of dealing with things
08:09:53 <jethr0> > let f b = if null b then [] else (let [(x,y)] = reads b :: [(Integer,String)] in x:f y) in f "123 4 5 6"
08:09:55 <shapr> Fireworks are nice.
08:09:55 <lambdabot>  [123,4,5,6]
08:10:06 <shapr> I nearly slept through the new year.
08:10:25 <ph8> oh it gets worse :/
08:10:44 <jethr0> shapr: they sure are. but in germany people tend to overdo it with firecrackers and so on. for children it's great fun, but more grown-ups (like me :) get a little flustered from all the banging and explosions
08:11:11 <george--> ph8, for sentence generation did you have any clever method of employing the search for a .? i was  thinking of pairing the words with a boolean to show whether they where a sentence ender
08:11:17 <bakert> is there a regular expressions library in standard haskell?
08:12:21 <ph8> george--: assuming i'm finding the next word one at a time, i search the last character for .
08:12:58 <ph8> since [String]'s == [[Char]]'s, i just did (last (last a))
08:13:07 <ph8> since [String]'s == [[Char]]'s, i just did ((last (last a)) /= '.')
08:13:08 <ph8> even
08:13:15 <george--> yeah, think i will end up doing the same... i just imagine there is a better way
08:13:23 <ph8> probably is :p
08:13:28 <ph8> at this point i just want to get it finished :p
08:13:50 <glguy> bakert: There is
08:14:02 <glguy> ?hoogle Regex
08:14:03 <lambdabot> Text.Regex :: module
08:14:03 <lambdabot> Text.Regex.Regex :: data Regex
08:14:03 <lambdabot> Text.Regex.Posix.regExtended :: Int
08:14:17 <glguy> and Data.ByteString has regex support in 6.6 I believe
08:14:19 <lisppaste2> ph8 annotated #34060 with "And now... :/" at http://paste.lisp.org/display/34060#4
08:14:26 <bakert> glguy, thanks - the libraries page on the wiki doesn't have a "text" section ... thanks
08:14:28 <ph8> there's lots of errors related to this IO business
08:14:56 <vincenz> beep
08:15:05 <glguy> bakert: What are you parsing?
08:15:28 <jethr0> hey vincenz
08:15:37 <jethr0> loong time no see
08:16:00 <vincenz> jethr0: !!!!!!!!!
08:16:06 <vincenz> get your ass to #oasis
08:16:08 <jethr0> vincenz: !!!!!!!
08:18:24 <lisppaste2> ph8 annotated #34060 with "A more complete overview..." at http://paste.lisp.org/display/34060#5
08:18:44 <ph8> generating the error mentioned in #4 :/
08:24:41 <ph8> is there an issue adding [[Char]]s to IO [[Char]] ?
08:24:43 <ph8> with ++
08:24:58 <ph8> if so, how would i combat it?
08:25:12 <ph8> just make a method to 'return [[Char]]' which would convert it to IO?
08:25:27 <ph8> s/method/function
08:25:56 <ph8> even then, ideally the final type needs to be [[char]]
08:26:49 <jethr0> ph8: you can't escape the IO monad (by design). therefore you'd have to lift the [[char]] to IO [[char]] as well and then concatenate in the io monad
08:27:05 <ph8> ok
08:27:09 <ph8> so...
08:27:10 <ph8> :p
08:27:14 <ph8> how would i go about doing that?
08:27:30 <ph8> the function needs to take IO [[Char]] as an argument instead of [[Char]]?
08:27:30 <vincenz> do list <- myIOCharList
08:27:35 <vincenz>    return $list ++ newstuff
08:27:42 <ph8> then IO [[char]] can concatenate with other IO[[chars]]
08:28:00 <ph8> hmm
08:28:10 <glguy> ph8: I think you are misunderstanding how IO works
08:28:11 <ph8> myIOCharList is [IO [[Char]]] ?
08:28:15 <ph8> perhaps
08:28:29 <glguy> if you have an "IO String"
08:28:39 <glguy> you work with the String by: x <- myIOString
08:28:44 <vincenz> myIoCharList :: IO [[Char]]
08:28:47 <glguy> then x :: String
08:28:51 <bakert> glguy, parsing web pages (often malformed ... not under my control)
08:29:02 <ph8> i have result <- IO [[Char]]
08:29:05 <bakert> glguy, are you going to suggest a different approach?
08:29:06 <ph8> then try to result ++ soFar
08:29:11 <ph8> soFar being a [[Char]]
08:29:18 <ph8> i'm thinking that's what's causing my error, am i wrong?
08:29:33 <vincenz> return $ result ++ soFr
08:29:47 <vincenz> or
08:29:48 <glguy> bakert: I've seen interesting things done with the HXT library (it's an HTML and XML parser) but it might be a little hard to pick up for a new user
08:29:54 <ph8> well, it's in this context
08:29:54 <ph8> (doRepGen key theMap numTimes (timesSoFar+1) (soFar ++ result))
08:29:55 <vincenz> return  (result ++ soFar)
08:30:23 <ph8> soFar ++ result will result in a [[Char]] though? not the IO variation
08:30:24 <ph8> ?
08:30:38 <bakert> glguy, i think i'll do it my quick and dirty way for now ... just trying to grab a number from various web pages.
08:31:10 <bakert> How do i define a function called "*****||" (i don't actually want to ... i'm just interested in the syntax!)
08:31:16 <bakert> ?
08:31:36 <glguy> > let a *****|| b = a + b in 1 *****|| b
08:31:38 <lambdabot>   Not in scope: `b'
08:31:41 <glguy> > let a *****|| b = a + b in 1 *****|| 2
08:31:43 <lambdabot>  3
08:31:45 <bakert> ah
08:31:59 <bakert> it's just that i have to put it in the middle like that.  so easy when you know how!
08:32:04 <bakert> thanks
08:32:13 <glguy> > let (*****||) a b = a + b in 1 *****|| 2
08:32:14 <lambdabot>  3
08:32:18 <bakert> can i do that at the "toplevel" of my module?
08:32:23 <glguy> yeah
08:33:09 <glguy> is that your sledgehammer function?
08:33:30 <bakert> that's a lot of fun ... i must resist the temptation to abuse it horribly!!!
08:33:59 <bakert> x = @*$(" 89 ****$$$$$$:: 200359
08:34:01 <bakert> !
08:34:04 <bakert> sort of thing
08:34:04 <emu> when the only tool you have is a sledgehammer...
08:34:35 <glguy> everything looks smashable?
08:41:22 <ptolomy> Aah! 6.6 on Gentoo in the shootout.
08:41:54 * ptolomy numa-numas.
08:42:09 <wchogg> Is it that good or that bad?
08:42:15 <emu> does it outshoot?
08:42:26 <Botje> does it cause casualties
08:42:27 <Botje> ?
08:43:11 <ptolomy> I generally consider it to be good.
08:43:23 <ptolomy> Though, they don't have GHC6.6-only programs posted yet.
08:43:47 <ptolomy> The shootout (shootout.alioth.debian.org) is silly, but it is fun.
08:45:13 <emu> i wonder if it runs on a multicore machine
08:45:22 <Cale> When you have a sledgehammer, most things *are* smashable!
08:46:05 <emu> how about the type reconstruction problem of System F omega... is that smashable?
08:47:18 <Cale> It is if you chisel it into a stone
08:47:42 <vincenz> Cale is philosophical today
08:50:52 <wchogg> Does anyone know of a good intro to algebraic datatypes?  One that goes into the actual math with F-algebras?
08:51:50 <glguy> is there any run-time performance difference between "return" and "Just"? (since the compiler knows that return *is* Just at compile time)
08:52:10 <vincenz> yes
08:52:14 <vincenz> orders of magnitude
08:52:16 <vincenz> if not more
08:52:23 <glguy> why is that?
08:52:25 <vincenz> like 1000 or 10000% percent
08:52:30 <vincenz> of course not!
08:52:37 <emu> wchogg: have TaPL?
08:52:37 <vincenz> or if there is it's probably negiglible
08:52:41 <glguy> :-/
08:52:51 <wchogg> emu:  Is that the Pierce book?
08:52:53 <emu> yea
08:52:57 <glguy> It wasn't *that* obsurd of a question
08:53:06 <vincenz> premature optimization causes cancer to the semicolon
08:53:15 <vincenz> and when in doubt: profile
08:53:26 <glguy> I'm just curious about how GHC works
08:53:34 <glguy> I'm not trying to actually make my code go faster
08:53:37 <vincenz> oh
08:53:55 <vincenz> I guess it depends on whether the code is specialized for the maybe monad or not
08:54:03 <wchogg> emu:  Yeah, a friend lent it to me.  I'll check it out then.
08:54:18 <glguy> I was playing with my MaybeT implementation
08:54:25 <emu> wchogg: its a good start, particularly chapter 23 and 29
08:54:37 <wchogg> Cool, thanks.
08:54:38 <glguy> and I didn't know if there was any difference between: return a = MaybeT $ return $ return a
08:54:43 <Cale> Yeah, there would be maybe a couple more pointer indirections for return in the case that the code is genuinely polymorphic
08:54:44 <glguy> and MaybeT $ return $ Just a
08:54:58 <vincenz> isn't that a return too many?
08:55:12 <glguy> vincenz: Maybe*T*
08:55:18 <vincenz> I knwo
08:55:31 <dmhouse> Good afternoon :)
08:55:33 <glguy> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
08:55:39 <vincenz> odd way of doing it
08:55:49 <glguy> how is that?
08:55:51 <dmhouse> vincenz: is it?
08:56:01 <vincenz> feels like it
08:56:07 <dmhouse> ?type runWriterT
08:56:09 <lambdabot> forall w a (m :: * -> *). WriterT w m a -> m (a, w)
08:56:14 <dmhouse> ?type runReaderT
08:56:16 <lambdabot> forall a (m :: * -> *) r. ReaderT r m a -> r -> m a
08:56:25 <dmhouse> Seems to follow the pattern to me.
08:56:26 <lisppaste2> glguy pasted "my maybet for while we discuss" at http://paste.lisp.org/display/34067
08:57:07 <glguy> vincenz: if there are other ways I should be considering, please annotate, I'm just doing this to learn more about transformers
08:57:12 <glguy> and not the autobot kind
08:57:13 * emu goes to get some EarlGreyT
08:57:24 * glguy *wishes* he brought tea today
08:57:46 <vincenz> that's not a proper transformer
08:57:48 <vincenz> afaict
08:58:02 <dmhouse> vincenz: in what sense?
08:58:11 <vincenz> it's storign it as
08:58:13 <vincenz> m (Maybe a)
08:58:22 * vincenz hmms
08:58:32 <allbery_b> EarlGreyT Water (IO Code) -- ?
08:58:32 <dmhouse> Just as WriterT stores it as an m (a, w).
08:58:34 <vincenz> anyways
08:58:35 <vincenz> in this case
08:58:38 <vincenz> return (Just a)
08:58:40 <vincenz> seems more proper
08:58:58 <dmhouse> Well, that would work.
08:59:17 <SamB_XP> @type Control.Monad.List.ListT
08:59:17 <glguy> that's what I had originally, I'm in the tinker phase ;)
08:59:18 <lambdabot> forall a (m :: * -> *). m [a] -> ListT m a
08:59:32 <SamB_XP> hmm, looks about right to me!
08:59:34 <vincenz> glguy: you're not layering on top, which is my concern
08:59:38 <dmhouse> vincenz: return a would work too.
08:59:57 <dmhouse> vincenz: because return :: a -> MaybeT a is defined as return x = return (Just x).
08:59:57 <SamB_XP> vincenz: do any of them layer on top?
08:59:59 <glguy> vincenz: when you unwrap the MaybeT layer, it changes the inner monad's return type
09:00:27 <vincenz> SamB_XP: most do
09:00:30 <vincenz> that's the idea of transformers
09:00:30 <glguy> ?type runStateT
09:00:32 <lambdabot> forall s a (m :: * -> *). StateT s m a -> s -> m (a, s)
09:00:33 <dmhouse> Or return (return x), if you like.
09:00:36 <SamB_XP> vincenz: show me one that does!
09:00:45 * vincenz hmms
09:00:53 <ph8> :t init
09:00:55 <lambdabot> forall a. [a] -> [a]
09:01:02 <ph8> does init return the first element anyone?
09:01:10 <glguy> head does that
09:01:14 <ph8> hmm
09:01:15 <glguy> ?type head
09:01:17 <lambdabot> forall a. [a] -> a
09:01:18 <ph8> i'll have a google then
09:01:21 <glguy> init -- all but last
09:01:22 <ph8> * hoogle
09:01:22 <Cale> init returns all but the last
09:01:25 <ph8> ah
09:01:27 <ph8> ty
09:01:41 <glguy> am I missing any typically important instances for a MonadT?
09:01:46 <lisppaste2> dmhouse annotated #34067 with "types of the returns" at http://paste.lisp.org/display/34067#1
09:01:59 <dmhouse> vincenz: http://paste.lisp.org/display/34067#1 lists the types of the various returns used there.
09:02:04 <Botje> we totally need a Pants monad.
09:02:04 <SamB_XP> glguy: just copy off of ListT?
09:02:09 <dmhouse> The 'a's aren't meant to be unified.
09:02:11 <glguy> SamB_XP: ah, ok
09:02:21 <vincenz> dmhouse: I know
09:02:21 <glguy> ?fptools Control.Monad.List
09:02:22 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/List.hs
09:02:28 <vincenz> dmhouse: I know very well the last return is a cut to short
09:02:35 <vincenz> dmhouse: but it's confusing, cause it makes it appear there's two monads
09:02:39 <vincenz> the m
09:02:42 <vincenz> and Maybe underneath
09:02:45 <dmhouse> Well, there are two monads.
09:02:48 <vincenz> which in this case is a misleading view
09:02:50 <vincenz> yes
09:02:52 <vincenz> MaybeT and m
09:02:57 <vincenz> not MaybeT, m and Maybe
09:03:06 <vincenz> but that's just subjective taste
09:03:19 <SamB_XP> how would *you* implement it?
09:04:30 <vincenz> hmm hmm
09:04:43 <vincenz> never mind
09:04:52 <vincenz> the only transformers I've implemented where on top of transformers
09:04:52 <SamB_XP> thats what I thought!
09:04:54 <vincenz> mostly StateT
09:04:58 <vincenz> but the return $ return a
09:05:01 <vincenz> I'd write it as
09:05:03 <vincenz> return $ Just a
09:05:13 <SamB_XP> yeah, me too
09:05:22 <vincenz> cause it's being used as container as art of the MaybeT monad
09:05:25 <vincenz> not as a separate monad
09:05:33 <vincenz> though yeah, the distinction line is rather thin and fuzzy
09:05:43 <vincenz> let me put one of my monads online :)
09:05:45 <vincenz> erm
09:05:47 <vincenz> transfoerms
09:06:19 <lisppaste2> vincenz pasted "A monad transformer" at http://paste.lisp.org/display/34070
09:06:48 <vincenz> :)
09:06:57 <vincenz> a type inference monad \o/
09:07:24 <vincenz> granted
09:07:32 <vincenz> it's just a state monad that's been encapsulated :D
09:07:41 <SamB_XP> many monads are
09:07:43 <ph8> given a Data.Map, map with data structured in a way: ["dog.", "cat"] := ["bar"]... is it possible to search for matches where the first half of the key = 'dog'.?
09:07:51 <ph8> and hence be able to randomly select an ending?
09:07:51 <SamB_XP> that doesn't make them less useful
09:08:01 <SamB_XP> in fact, I think encapsulating them makes them *more* useful
09:08:49 <george--> ph8: you said earlier that for checking a . you just used tail twice to convert from the [[Char]] to the last character... but in generating a word using the randomRIO function i have had to have my words generated as IO String not String... so tail doesn't work in this case... any thoughts?
09:08:58 <lisppaste2> vincenz annotated #34070 with "a monad transformer for getting a heap" at http://paste.lisp.org/display/34070#1
09:09:14 <ph8> i used last
09:09:18 <ph8> not sure if that's the same as tail
09:09:47 <xerox> ?check \xs -> tail xs == last (xs :: [()])
09:09:49 <lambdabot>  Couldn't match `[()]' against `()'
09:09:49 <george--> > :t last
09:09:50 <lambdabot>  Parse error
09:09:58 <george--> > :t tail
09:09:59 <lambdabot>  Parse error
09:10:01 <ph8> @hoogle last
09:10:05 <lambdabot> Prelude.last :: [a] -> a
09:10:05 <lambdabot> System.Win32.Registry.lastWrite_hi :: RegInfoKey -> Word32
09:10:05 <lambdabot> System.Win32.Registry.lastWrite_lo :: RegInfoKey -> Word32
09:10:12 <vincenz> SamB_XP: like em?
09:10:13 <glguy> > let xs = [1..3] in (tail xs, last xs)
09:10:14 <lambdabot>  ([2,3],3)
09:10:18 <glguy> ph8: ^^
09:10:39 <george--> giving me the same error
09:11:03 <ph8> i believe george-- that if you result <- IO [[Char]], return result <-- return's a [[Char]]
09:11:06 <george--> my problem was i couldnt use randomRIO like he told us too without making my generate word function generate IO String instead of String
09:11:07 <ph8> i might be completely wrong though
09:11:14 <ph8> but i don't check for a '.' until the next iteration
09:11:17 <ph8> * recursion
09:11:22 <ph8> but it's passed as a [[Char]]
09:11:43 <Cale> george--: You could generate random numbers and pass them into your algorithm after.
09:12:10 <george--> Cale, the problem with this is i dont know how many random number i need and i dont want excess work done
09:12:21 <vincenz> george--: make an infinite list of em
09:12:25 <vincenz> and pass that it
09:12:26 <vincenz> in
09:12:32 <glguy> newStdGen ?
09:12:34 <Cale> @type randomRs
09:12:35 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
09:12:40 <ph8> the type sig for my repetitive gen is this george--
09:12:44 <ph8> i like the sound of a random list
09:12:44 <kzm_> ph8: maybe I missed the point, but are you looking for a trie?
09:12:47 <ph8> would have saved me problems
09:12:47 <ph8> > repGen :: [[Char]] -> Map [[Char]] [[Char]] -> [[Char]] -> IO [[Char]]
09:12:48 <ph8> > repGen a theMap soFar?
09:12:49 <lambdabot>   Not in scope: type constructor or class `Map'
09:12:49 <lambdabot>  Parse error
09:12:58 <ph8> dunno why a ? was added there
09:13:12 <ph8> so it would start with a ["dog", "sat"] [[Charr]]
09:13:14 <ph8> Char :p
09:13:22 <ph8> and my map, and a blank string []
09:13:35 <ph8> it would search for the next two results, and call the function again
09:13:43 <ph8> which would check each value for ending in '.'
09:13:50 <ph8> if they didn't, it would append them to soFar, and call again
09:13:59 <ph8> if soFar ends in a '.' the function returns
09:14:18 <chessguy_work> 'morning haskellers
09:15:22 <vincenz> SamB_XP: ping
09:15:29 <SamB_XP> oh, right
09:15:46 <george--> hmmm
09:15:55 <george--> my types are funny all over the place i think
09:16:31 <vincenz> ?
09:17:44 <george--> vincenz, in the case of an infinite list of random numbers... can i assume that 1. due to lazyness they will only be produced when needed? 2. it is not less efficient to makea list of random ints between 1 and some arbitrarily high value then use modular arithmetic to get them down to size later than to just generated the random numbers later between the size i want
09:18:19 <vincenz> 1) yes 2) yes
09:18:29 <vincenz> erm wait, rereading 2
09:18:43 <vincenz> 2) yes
09:18:56 <Cale> Worry about the efficiency of your code only after it becomes clear that code is not efficient enough.
09:19:32 <george--> basically... I need every RN between 1 and x where realistically x is gonna be up to 10 and probably not much higher... but each iteration i wont know what I need till its there
09:20:03 <SamB_XP> vincenz: interesting
09:20:33 <SamB_XP> is this HeapT designed for use in a UM or something like that?
09:20:59 <vincenz> well not a UM
09:21:01 <george--> oh yeah. and 3. can i generate the random no's using randomRIO ?
09:21:05 <vincenz> but yeah, it was used for something similar
09:21:20 <SamB_XP> well, I bet it would work nicely
09:21:29 <Cale> If you use randomRIO, you have to be working in the IO monad.
09:21:46 <george--> which will give me the same problems?
09:22:06 <Cale> Which means that unless you want to write your whole algorithm in the IO monad, you will need to know beforehand how many random numbers you need.
09:22:13 <SamB_XP> Cale: um.
09:22:31 <SamB_XP> @hoogle (a, a) -> IO [a]
09:22:31 <lambdabot> No matches, try a more general search
09:22:33 <SamB_XP> hmm.
09:22:35 <Cale> On the other hand, what you can do is use newStdGen to get a generator
09:22:41 <SamB_XP> @docs Random
09:22:41 <lambdabot> Random not available
09:22:46 <Cale> and then pass that generator to randoms
09:22:47 <SamB_XP> @docs System.Random
09:22:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
09:22:52 <Cale> or randomRs
09:23:05 <Cale> to get an infinite list of random values
09:23:11 <vincenz> SamB_XP: it works ok for small things... basically I use standard "env" which basically maps keys to values (it's a stateT on top of a Map) and then a SupplyT which gives a supply of unique values.  Of course, there's no "garbage" collection in this heap
09:24:08 <george--> i hate the way that you use a little bit of IO and you are stuck with every variable being IO String or similar and all of them useless
09:24:10 <SamB_XP> vincenz: yeah.
09:24:20 <SamB_XP> but apparantly UML already has a garbage collector
09:24:40 <SamB_XP> ... which might explain why it thrashes so badly from time to time
09:25:02 <Cale> george--: well, the idea is that you do IO in the IO monad, and then pass the real work off to the other parts of your program which are pure
09:25:34 <george--> I know, but they all end up getting infected it seems
09:25:42 <george--> I have an IO String
09:25:46 <george--> i just want to do last on it
09:25:48 <george--> get last char
09:25:57 <george--> and do some pattern matching on it
09:26:11 <dmhouse> george--: do something like
09:26:16 <dmhouse> myIOFunction = do
09:26:22 <dmhouse>   str <- myIOString
09:26:25 <vincenz> SamB_XP: oh, this was not for UML but a MiniML simulator
09:26:29 <dmhouse>   let str' = allThePureStuff str
09:26:30 <Cale> do { x <- myIOString; let y = f (last x) ; ... }
09:26:57 <SamB_XP> I don't know what MiniML is
09:27:06 <vincenz> SamB_XP: a reduced set of ML
09:27:17 <dmhouse> SamB_XP: I'm sure you can guess from the name.
09:27:20 <SamB_XP> oh, okay, so I did know what MiniML was
09:27:52 <Cale> george--: a value of type (IO String) isn't a string, but a program which executes to produce a string
09:28:10 <Cale> Only IO actions are allowed to cause the execution of other IO actions
09:28:25 <Cale> and eventually, main gets executed by the runtime system
09:31:02 <Cale> However, IO actions are of course allowed to use pure functions and values.
09:32:56 <SamB_XP> there wouldn't be much point in having them if IO actions weren't allowed to use them ;-)
09:34:30 <lisppaste2> ph8 pasted "Almost!" at http://paste.lisp.org/display/34071
09:34:51 <ph8> hi again, could anyone offer insight into that? i've figured out a large part of what the problem was before
09:34:56 <ph8> this seems to be getting an IO type from somewhere!
09:35:08 <ToRA> ph8: what is the type of repGen
09:35:16 <ToRA> ?
09:35:52 <ph8> > repGen :: [[Char]] -> Map [[Char]] [[Char]] -> [[Char]] -> IO [[Char]]?
09:35:53 <lambdabot>  Parse error
09:35:57 <ph8> i don't now why it keeps adding ? to my pastes
09:36:13 <ToRA> right, now you're doRepGen calls repGen
09:36:20 <ToRA>  / uses it
09:36:45 <ph8> yes, stores the return in result
09:36:54 <ToRA> yeah
09:37:18 <ToRA> thing is, because repGen uses IO, and doRepGen calls repGen, doRepGen needs IO
09:37:31 <ToRA> (kinda like george-- and Cale were just discussing)
09:37:46 <ph8> so i just need to make repGe's return type IO [[Char]] and add a return or two in
09:37:47 <ph8> ?
09:37:59 <ToRA> yeah
09:38:09 <ToRA> i don't think you'll need to add any return's to what you have
09:38:11 <ToRA> tho i may be wrong
09:39:04 <ph8> it all goes foobar
09:39:27 <ph8> ERROR "Main.lhs":114 - Type error in guarded expression
09:39:27 <ph8> *** Term           : do {...}
09:39:27 <ph8> *** Type           : IO [[Char]]
09:39:27 <ph8> *** Does not match : [[Char]]
09:39:38 <ToRA> which do
09:39:39 <ph8> 114 is that line | (timesSoFar >= 1) =
09:39:42 <george--> ph8, hahaha. identical errors =)
09:39:50 <ph8> nice :p
09:40:12 <ToRA> ok, so the (timesSoFar >= 1) = soFar
09:40:17 <ToRA> you will need a return there
09:40:29 <ph8> no, | (timesSoFar >= numTimes) = soFar
09:40:39 <ToRA> yeah
09:40:40 <ph8> oh shit
09:40:43 <ToRA> you will need a return there
09:40:43 <ph8> if i make the return soFar
09:40:44 <ph8> it compiles!
09:40:47 <ph8> does it work is the question
09:40:54 <ph8> for the sake of my sanity i hope so
09:40:55 <ToRA> do you understand why the return makes it compile?
09:41:08 <ToRA> *(or at least) gets it closer to compiling
09:41:15 <ph8> yes
09:41:21 <ToRA> gd gd
09:50:18 <wy> Ah. Infinite loop again. I really need a way to print thing along the way
09:50:32 <glguy> when using the Mk prefix, is it: data MyData a = MkMyData a ?
09:53:35 <bakert> wy, me too!
09:53:43 <Cale> Debug.Trace
09:54:02 <araujo> anybody has tried Qi here?
09:54:07 <wy> Cale: Debug.Trace.trace doesn't print anything in a infinite loop
09:54:14 <SyntaxNinja> y0
09:54:14 <lambdabot> SyntaxNinja: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:54:39 <Cale> wy: It only prints things when values are evaluated.
09:54:57 <ph8> george--: the problem i'm running into, is it repeatedly generating sentences from my 'book', which are paragraphs in themselves
09:55:05 <wy> Cale: That's my problem. I don't have values.
09:55:10 <Cale> wy: are you saying that your program is suffering from an infinite loop, or that you want an infinite loop where things are printed
09:55:12 <ph8> and then generating the same sentence x amount of times
09:55:16 <wy> I just want to see what's going on
09:55:24 <ph8> since the end of each sentence maps to [""]
09:55:35 <wy> I'm getting infinite loops
09:55:36 <ph8> i might have to throw some randomisation in for good luck
09:55:36 <george--> ph8, maybe just the book isnt a large and random enough source? or instead of tri-grams you are using like 9-grams etc
09:55:38 <george--> ?
09:55:45 <ph8> i'm using tri-grams
09:55:50 <george--> ph8, do you have randomisation in?
09:55:50 <ph8> i don't think my code would work with anything else
09:55:54 <wy> Cale: So I want to see what caused the loop
09:55:55 <ph8> and i don't know if i want to modify it
09:56:03 <ph8> hmm maybe it doesn't randomise on empty actually
09:56:06 <ph8> maybe that's the source of the problem
09:56:10 <ph8> it definitely randomises at some point
09:56:17 <Cale> wy: are you getting <loop> ?
09:56:25 <george--> in my code just replacing the constant defined in ngram_size will change it for all
09:56:29 <wy> Cale: No. It's not detected.
09:57:00 <Cale> Okay, then it's definitely dependent on the values which are being received by some function
09:57:06 <wy> Cale: It just hangs there.
09:57:47 <Cale> If you have no idea what part of the code is causing it, you could run the profiler
09:57:50 <wy> Isn't there a way to print something as it goes? Even ML can do that
09:57:57 <Cale> yes, Debug.Trace
09:58:04 <apfelmus> wy: if you have any idea which parts might loop, you can trace them. of course, the easiest solution would be to post your code :)
09:58:37 <Cale> Though the order in which things are printed by Debug.Trace is up to the compiler. (But it lets you see how things are really being evaluated)
09:58:38 <wy> My code is long. I wonder if anybody want to see it
09:59:10 <apfelmus> Cale: the profiler sounds good. but it does it output anything if the program denotes non-termination
09:59:15 <wy> Cale: I tried. But there wasn't any output
10:00:08 <apfelmus> wy: well, searching for a loop shou
10:00:25 <allbery_b> hm.  hat?
10:00:26 <apfelmus> ld only take O(log code size) time with a binary search ;)
10:00:37 <Cale> hmm, I think it should... you compiled with -prof -auto-all, and ran the program with +RTS -p on the commandline, right?
10:00:52 <bakert> @paste
10:00:53 <lambdabot> http://paste.lisp.org/new/haskell
10:01:03 <bakert> help me because i am thick oh gurus
10:01:16 <lisppaste2> bakert pasted "Thickness about Maybe and IO" at http://paste.lisp.org/display/34072
10:01:21 <Philippa> wy: when you say "even ML can do that", you do realise that's because ML's an impure language and thus has no greater problem doing so than C?
10:01:51 <SamB_XP> wy: why do you want to print something as it goes?
10:01:57 <SamB_XP> just for debugging purposes?
10:02:11 <wy> SamB_XP: Yes. Just for debugging
10:02:12 <bakert> my paste is a very simple little problem i am having with IO and Maybe and my lack of brain
10:02:29 <bakert> i'm doing something dim but i'm not sure what
10:02:30 <allbery_b> bakert: main is in the IO monad, blah isn;t
10:02:32 <SamB_XP> wy: ah. well, if you don't get any trace outptu...
10:02:37 <allbery_b> so you get a type mismatch
10:02:38 <SamB_XP> er, output...
10:02:55 <allbery_b> (blah would need to have a type of IO <something> for <- to work with it from main
10:02:57 <allbery_b> )
10:03:07 <SamB_XP> that must mean that the expression to which you attached the trace call wasn't evaluated
10:03:08 <bakert> allbery_b, i see
10:03:21 <bakert> hmm
10:03:59 <allbery_b> you may have used that somewhere where the active monad was Maybe, in which case <- would work and strip the Just.
10:04:01 <SamB_XP> wy: you should try placing some trace calls further out
10:04:27 <bakert> allbery_b, so if i want to call blah from main, i MUST alter blah?  there's nothing i can do in main to "fix" things?
10:04:29 <allbery_b> but main is (and must be) in the IO monad, so it's IO that gets stripped by <-.  except that blah isn't of type IO <something>
10:04:51 <allbery_b> let (Just x) = blah -- instead of the <-
10:05:41 <bakert> pattern matching is always the answer!
10:05:43 <allbery_b> note that if blah ever returns Nothing, this will elicit a runtime error (since fail in the IO monad raises a user exception)
10:06:17 <allbery_b> if that bothers you, instead say:
10:06:25 <bakert> allbery_b, magic.  thanks.  i can do a case if necessary.
10:06:30 <bakert> right?
10:06:38 <bakert> case blah of
10:06:39 <bakert> ??
10:06:44 <allbery_b> yeh, use a case instead (and lose the pattern match in the let)
10:06:54 <bakert> great.  thanks so much.
10:07:12 <allbery_b> case blah of Nothing -> whatever; Just x -> putStrLn $ show x
10:13:54 <wy> Too bad. It hanged my computer just now
10:14:46 <apfelmus> pfew, wy hasn't been swallowed by his time leak, yet. actually, a black hole is far less dangerous.
10:14:57 <wy> There must be some way to protect the system from using up its memory
10:16:48 <dmhouse> What's a word for a single level of a hierarchy?
10:16:56 <Philippa> dmhouse: "level"
10:17:05 <dmhouse> :) That doesn't quite fit.
10:17:20 <Philippa> further context, then? Normally it's at least pretty close to fitting
10:17:29 <wy> apfelmus: Have you encountered this kind of problems before?
10:17:43 * SamB_XP is surprised to find that he got all As last semester
10:17:44 <dmhouse> I'm writing forum software so I have various levels: forums, conversations and posts. I need a name for a class encompassing them.
10:18:08 <psnl> People?
10:18:18 <apfelmus> being swallowed by a time leak or black hole? fortunately not!
10:18:26 <dmhouse> (There are also users too; they fit in because they have a 'user display page' that shows details about how long they've been registered, etc.)
10:18:50 <SamB_XP> what methods does the class have?
10:19:01 <wy> It's just too hard to find the bug without the print thing. I think a programming language should ease this kind of thing instead of maintain the theoretical robustness strictly
10:19:28 <SamB_XP> wy: Debug.Trace does do that.
10:19:39 <SamB_XP> you still have to make sure the trace calls are evaluated!
10:19:46 <wy> SamB_XP: But why doesn't it show anything?
10:20:00 <dmhouse> Something like 'name :: t -> String', 'deleteUrl :: t -> URI', 'addUrl :: t -> URI' etc.
10:20:10 <SamB_XP> wy: the calls are never evaluated
10:20:43 <SamB_XP> either that, or you aren't looking at stderr
10:21:12 <apfelmus> wy: but i guess that's not exactly what you meant... sure, i had these bugs too, and they are hard to locate. it usually turned up that the code had other bugs, too and fixing them often pinpointed the real problem.
10:21:29 <wy> SamB_XP: I'm sure they are evaluated. But they don't return
10:21:38 <SamB_XP> wy: don't return?
10:22:21 <SamB_XP> wy: can you paste a small example?
10:22:23 <wy> SamB_XP: That's my bug. It doesn't produce a value. It's a infinite loop
10:22:41 <wy> Is there a way to upload a package?
10:22:47 <SamB_XP> a package?
10:23:05 <wy> SamB_XP: I have 4 files
10:23:09 <SamB_XP> hmm, maybe you could just paste the trace call?
10:23:34 <wy> Debug.Trace.trace "step" $ putStr(showResults(eval(compile(parse(mlex "main = casePair (MkPair 1 2) K")))))
10:23:49 <SamB_XP> and it doesn't print the "step"?
10:24:10 <wy> SamB_XP: It doesn't print it. But I'm sure it's evaluated
10:24:28 <Philippa> wy: trace prints before it /starts/ evaluating what's on the inside
10:24:33 <Philippa> so no, it's not evaluated
10:25:12 <SamB_XP> yeah. unless stderr is redirected or you messed with the buffering somehow!
10:25:18 <apfelmus> wy: you are tracing an IO action. can you paste the context
10:25:57 <lisppaste2> ph8 annotated #34071 with "Evul Tracing" at http://paste.lisp.org/display/34071#1
10:26:15 <wy> I'll paste the function I want to trace
10:26:27 <sjanssen> http://ross-paterson.dyndns.org/~ross/hackage/
10:26:27 <lambdabot> Title: Experimental Hackage interface
10:26:42 <sjanssen> CPAN, here we come!
10:28:16 <wy> It seems paste.lisp.org is down
10:28:37 <sjanssen> wy: works for me
10:29:15 <wy> Uhh... strange.
10:30:19 <wy> But I'm sure the function is evaluated. Because if I change the part where the infinite loop is and put in: error "hello". I got output "hello"
10:30:20 <ph8> http://paste.lisp.org/display/34071#1 <-- could anyone imagine why that trace isn't working?
10:30:25 <ph8> it seems such  a difficult function to be using
10:31:41 <SamB_XP> wy: if you already know where the infinite loop is... why do you need to use trace?
10:32:35 <wy> I know there won't be infinite loop if I comment out that part. But I need to know why is there infinite loop so that I can modify it. Or my code won't work.
10:33:51 <sjanssen> ph8: there's a syntax error there?  don't you need to fix that first?
10:34:06 <SamB_XP> so, in exactly the place where you would comment out an expression and put error "hello", simply add parens around the expression and precede it with trace "step"
10:34:07 <Igloo> ph8: Why not use putStrLn?
10:35:02 <SamB_XP> hmm. or that.
10:35:18 <SamB_XP> (though putStrLn writes to stdout, not stderr)
10:35:31 <ph8> Igloo: because then i'd have to declare IO()
10:35:33 <Igloo> Well, hPutStrLn stderr if you care
10:35:38 <ph8> which begins *all* sorts of problems
10:35:47 <SamB_XP> ph8: you seemed to already be using IO
10:35:48 <Igloo> ph8: You're already in the IO monad?
10:35:48 <sjanssen> ph8: you are already in IO
10:35:58 <ph8> ah right you are
10:35:58 <wy> SamB_XP: Nothing is printed
10:36:00 <ph8> genious :)
10:36:13 * mbishop waits for it
10:36:13 <SamB_XP> wy: are you sure stderr is working correctly?
10:36:21 <mbishop> ph8: You are already in IO
10:36:34 <ph8> forgot i was in io :p
10:36:38 * mbishop giggles
10:36:53 <wy> Does error use stderr?
10:36:59 <SamB_XP> wy: good question
10:37:44 <ph8> right, envision this if you will: I'm inside a guard, and i'm doing result <- IO [[Char]]... i need to check that result != [], but i can't put a guard inside a guard? i've seen 'if thens' before - is this the place to be using them?
10:38:02 <allbery_b> error appears to use stdout
10:38:04 <SamB_XP> apparantly it does not!
10:38:12 <SamB_XP> yeah, what allbery_b said
10:38:23 <wy> SamB_XP: I compiled it and run instead of running ghci in Emacs. This time it printed out something. But they are of no use. It just printed out the function name again and again
10:38:32 * allbery_b thinks that's wrong, at least in the unix environment...
10:38:44 <SamB_XP> wy: is that what you passed to trace?
10:38:51 <wy> Yes
10:38:54 <ph8> anyone? ;)
10:39:21 <SamB_XP> well, now you need to include some interesting information in the first argument to trace
10:39:43 <wy> SamB_XP: Oh. Can I use anything?
10:39:44 <SamB_XP> allbery_b: in Windows, it ought to pop up a dialog box with a red X sign ;-)
10:40:10 <SamB_XP> wy: you can pass whatever string value you like
10:40:47 <apfelmus> wy: wait. you traced on an IO and it got executed oo times?
10:40:53 <ClaudiusMaximus> :t (\x -> case x of True -> 0 ; False -> 1)
10:40:55 <lambdabot> forall t. (Num t) => Bool -> t
10:41:02 <ClaudiusMaximus> ph8: ^^
10:41:12 <ClaudiusMaximus> ph8: might work...
10:41:44 <ph8> hmm
10:41:47 <ph8> i'm only sort of with you
10:41:51 <wy> It works!!!
10:41:59 <ph8> case [] of result?
10:42:00 <wy> Ah.. Good
10:43:22 <ClaudiusMaximus> :t let result = [1,2,3] in (case result of [] -> "boo!" ; _ -> "hooray")
10:43:24 <lambdabot> [Char]
10:43:56 <ph8> cheers
10:45:10 <ph8> case result of [] -> result = ["", ""]
10:45:12 <ph8> evul?
10:45:42 <xerox> What does that mean?
10:45:57 <ph8> interested point
10:46:04 <ph8> if result == [] set it to ["", ""]
10:46:11 <xerox> "set" ?
10:46:19 <ph8> assign it the value of!
10:46:23 * xerox faints
10:46:34 <xerox> Is that Haskell?
10:46:34 <glguy> is there a better way to say this: put =<< lift =<< gets f -- ?
10:46:40 <glguy> this is a modify that can fail
10:46:51 <ph8> the next line is going to try and pull index of ((length result) - 2)
10:46:52 <glguy> StateT MyType Maybe MyType
10:46:56 <ph8> and it's throwing exceptions
10:46:59 <ph8> because result can be empty
10:47:06 <xerox> ph8: values are _constant_.
10:47:53 <Saizan> ph8
10:48:20 <glguy> ?pl put =<< lift =<< gets f
10:48:21 <lambdabot> put =<< lift =<< gets f
10:48:29 <glguy> i guess: tryModify f = put =<< lift =<< gets f
10:48:30 <ph8> well i've got to find some odd way of dealing with this
10:48:37 <ph8> it's so complicated
10:48:43 <ph8> are any large projects made in Haskell?
10:48:58 <psnl> uh, yes
10:49:09 <Saizan> if have to pass result to a function f you can do: case result of [] -> f ["", ""]; _ -> f result
10:49:33 <ph8> oo cunning
10:50:15 <Saizan> or in the same function you can do: let result' = case result of [] -> ["",""]; _ -> result in ...
10:50:19 <psnl> ph8: hat is about 75,000 lines
10:50:24 <Saizan> and then use result'
10:50:46 <psnl> actually, that number could be bollocks
10:51:10 <xerox> > let xs = ["",""] in xs !! (length xs - 2)
10:51:11 <george--> ph8, callaghan always talks of the big projects he has done!
10:51:12 <lambdabot>  ""
10:51:24 <ph8> i know, but i was beginning to think he had to have been lying
10:51:31 <ph8> it just doesn't seem possible
10:51:36 <george--> hah
10:51:59 <psnl> hehe
10:52:00 <SamB_XP> ph8: you mean they always seem to shrink when you do them in Haskell?
10:52:23 <george--> are you making paragraphs just a fixed no. of sentences?
10:52:43 <lisppaste2> ph8 pasted "Hopefully you'll get a laugh out of this case usage..." at http://paste.lisp.org/display/34077
10:53:05 <ph8> george--: no, just using paul's paras function
10:53:08 <Saizan> ph8: maybe one has to approach problems with a different design strategy in haskell and then it will become more natural
10:53:17 <ph8> perhaps that's it
10:53:22 <xerox> ph8: is the value of (genNext ["",""] theMap) always the same?
10:53:38 <ph8> recursion in imperative languages will no doubt be easy after this anyway
10:53:42 <ph8> xerox: it can vary randomly
10:53:43 <SamB_XP> personally, I don't know how anyone has the attention span to do anything large in, say, C
10:53:49 <ph8> it will always be of the same type
10:55:18 <ph8> is there something wrong with my indentation though?
10:55:20 <ph8> or something else silly?
10:55:25 <Saizan> ph8: yeah you have some layout issues there
10:55:32 <xerox> ph8: what does the program do?
10:55:44 <ph8> Saizan: does it all need to be on the same line?
10:56:06 <Saizan> no, i'll annotate in a sec ^^
10:56:08 <ph8> xerox: We're making something that uses N-grams to generate the next few sentences, given two or three starting words
10:56:21 <ph8> it extrapolates said sentences after 'learning' from a large e-book
10:56:22 <ph8> or similarly large text
10:57:08 * psnl boggles
10:57:37 <ph8> i'm almost finished
10:57:41 <ph8> this is literally the last functon
10:57:41 <psnl> last year we just had to draw pretty pictures of newgroup activity
10:57:43 <ph8> * function
10:57:59 <ph8> i'm sure it was similarly devious
10:58:06 <ph8> want a link to the assignment page?
10:58:13 <psnl> yeah, please
10:58:14 <lisppaste2> Saizan annotated #34077 with "try like this" at http://paste.lisp.org/display/34077#1
10:58:20 <ph8> cheers Saizan
10:58:25 <ph8> http://www.dur.ac.uk/p.c.callaghan/ngrams06.html
10:59:18 <xerox> Thanks.
10:59:50 <psnl> ph8: that looks at lot more fun than our assignment
10:59:58 <lisppaste2> ph8 annotated #34077 with "complete repGen now w/error" at http://paste.lisp.org/display/34077#2
11:00:13 <ph8> it's interesting at least
11:00:28 <ph8> it aggravates me i could have made it in about three quarters of an hour with ruby or something
11:00:34 <ph8> but i suppose that's what learning is all about
11:02:33 <ph8> Saizan: why is it being nasty to me? Can you make it stop?
11:02:37 <ph8> :p
11:03:15 <Saizan> nasty?:D
11:03:42 <sjanssen> ph8: you've got some nasty indentation, I think
11:03:45 <kpreid> ph8: that error means that you have incorrect indentation, such that haskell thinks your do block ended before you intended it to
11:04:03 <ph8> but nothing's on the same line as the do
11:04:07 <ph8> /column
11:04:38 <ph8> ah ok fixed it
11:04:39 <kpreid> that doesn't matter
11:04:40 <ph8> it builds
11:04:45 <ph8> it's because the paste had spaces and i use tabs
11:04:58 <sjanssen> ph8: please do not use tabs in Haskell code
11:04:59 <kpreid> what matters is that everything in the do block is the same level as the *first* thing in it
11:05:34 <ph8>  ["Dandy","look","him","out","of","Conti","coming","from","Bourbon."]
11:05:38 <ph8> that's remarkably intelligent :p
11:05:52 <ph8> yup
11:06:02 <ph8> sjanssen: it's easier to edit, if i ever published anything i'd convert the tabs first
11:07:13 <george--> any intrinsic functions in haskell for returning everything but last element in a list?
11:07:23 <nmessenger> ?type init
11:07:25 <lambdabot> forall a. [a] -> [a]
11:07:31 <nmessenger> > init [1,2,3]
11:07:33 <lambdabot>  [1,2]
11:07:37 <george--> perfect. ty
11:07:46 <kpreid> > init []
11:07:47 <lambdabot>  Add a type signature
11:07:54 <Saizan> ph8: i'll reccomend emacs + haskell-mode for easy indentation :)
11:07:56 <kpreid> > init [] :: [Int]
11:07:57 <lambdabot>  Exception: Prelude.init: empty list
11:08:42 <nmessenger> I use an editor that lets me indent + outdent lines without too much hassle.
11:08:47 <kpreid> @pl \x -> if null x then [] else init x
11:08:48 <lambdabot> ap (flip if' [] . null) init
11:09:11 <kpreid> @pl \x -> if null x then x else init x
11:09:12 <lambdabot> ap (if' =<< null) init
11:09:14 <apfelmus> sjanssen: doesn't the haskell report specify a tab width of 4 spaces?
11:09:57 <Igloo> apfelmus: 8
11:10:04 <nmessenger> > let init' xs = drop (length xs - 1) xs in init' [] -- this might be simpler, kpreid
11:10:05 <lambdabot>  Add a type signature
11:10:17 <Igloo> apfelmus: but much easier just not to use them
11:10:36 <nmessenger> > let init' :: [a] -> [a]; init' xs = drop (length xs - 1) xs in init' ([]::[Int])
11:10:38 <lambdabot>  []
11:10:39 <kpreid> nmessenger: I was fishing for monad usage, actually
11:10:40 <apfelmus> ok. "Tab stops are 8 characters apart."
11:10:41 <Saizan> @src init
11:10:41 <lambdabot> init [x]    = []
11:10:42 <lambdabot> init (x:xs) = x : init xs
11:10:42 <lambdabot> init []     = undefined
11:11:54 <nmessenger> ?src drop
11:11:55 <lambdabot> drop n xs     | n <= 0 =  xs
11:11:55 <lambdabot> drop _ []              =  []
11:11:55 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
11:12:25 <apfelmus> Igloo: spaces make it hard to de-indent code
11:12:45 <AStorm> apfelmus, with bad editor, perhaps
11:12:57 <AStorm> With good one, not really.
11:14:28 <nmessenger> I'm writing code that is obviously in some kind of State monad.  Anybody recommend any good tutorials for the ignorant?
11:15:10 <sjanssen> @google nomaware monads
11:15:12 <lambdabot> http://www.nomaware.com/monads/
11:15:12 <lambdabot> Title: Nomaware | Monads
11:15:22 <sjanssen> nmessenger: that might help
11:15:49 <nmessenger> thanks
11:16:39 <glguy> underModify f = put =<< lift . f =<< get
11:17:03 <nmessenger> ?type lift
11:17:04 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:17:23 <glguy> ?type \ f -> f = put =<< lift . f =<< get
11:17:25 <lambdabot> parse error on input `='
11:17:30 <glguy> ?type \ f -> put =<< lift . f =<< get
11:17:32 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) s. (Monad m, MonadTrans t, MonadState s (t m)) => (s -> m s) -> t m ()
11:17:53 <glguy> it lets me do modifications to the state that can fail
11:18:05 <glguy> (I'm wrapping Maybe with a StateT)
11:19:25 <apfelmus> AStorm: really? i have
11:19:26 <apfelmus>   foo [] \t= ...
11:19:26 <apfelmus>   foo (x:xs) \t=...
11:19:26 <apfelmus> so that the equal signs are aligned. suppose i change the second pattern to [[]] and have to realign '='. with a tab width of n, i have a chance of 1-1/n that no realignment ever happens.
11:19:44 <ph8> someone told me a while ago how to 'elevate' a mere [[char]] to the level of an IO [[char]] so i can ++ them together, how did i go about that again?
11:20:01 <dcoutts__> ph8: liftM ?
11:20:07 <wy> The bug is found! Thanks a lot!
11:20:11 <dcoutts__> liftM2, liftM3 etc
11:20:16 <ph8> :t liftM
11:20:18 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
11:20:31 <sjanssen> ph8: return :: a -> IO a -- it injects a value into the monad
11:20:32 <wy> I can't imagine without Trace ;-)
11:20:46 <ph8> ty
11:20:52 <sjanssen> erm, (Monad m) => a -> m a actually
11:21:10 <dcoutts__> ph8: but you can only ++ [a]'s together, not IO [a]'s
11:21:15 <ph8> well
11:21:18 <ph8> oh
11:21:21 <ph8> well that's annoying
11:21:22 <dcoutts__> ph8: hence the need to liftM2 (++)
11:21:26 <nmessenger> apfelmus: well, if the pattern change goes past your tab stop, you'd have to change it anyway.  Spaces do make a lot more often, but that's not been a problem in my experience.
11:21:32 <dcoutts__> :t liftM2 (++)
11:21:32 <ph8> ((return [head a]) ++ (doRepGen firstKey theMap numTimes (timesSoFar+1) firstResult)) <-- that's not legal, surprisingly
11:21:33 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
11:22:19 <Saizan> (doRepGen firstKey theMap numTimes (timesSoFar+1) firstResult) is IO [a] ?
11:22:20 <nmessenger> what is the type of doRepGen blah blah etc. ?
11:22:23 <ph8> yes
11:22:30 <ph8> IO [[Char]]
11:22:43 <dcoutts__> ph8: just use do notation
11:22:49 <wy> SamB_XP: So trace is much like printf :-)
11:22:54 <MarcWebe1> I want to print the name of a type. Is there a better solution than introducing a class Type t where \n typeName :: t -> String?
11:23:12 <ph8> dcoutts: what and then something <- doRepGen; return something ++ a?
11:23:15 <sjanssen> @hoogle typeOf
11:23:16 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
11:23:16 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
11:23:16 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
11:23:24 <apfelmus> nmessenger: yes. but the chance for that to happen is 1/n where n is the tab width. and AStorm promised a good editor that achieves the same with spaces.
11:23:25 <sjanssen> > typeOf 'c'
11:23:25 <dcoutts__> ph8: exactly
11:23:26 <lambdabot>  Char
11:23:29 <ph8> cheers
11:23:36 <sjanssen> MarcWebe1: ^^^
11:23:49 <MarcWebe1> sjanssen: I've seen it. Thanks
11:23:59 <ph8> return can't be the last statement in a do construct?
11:24:08 <xerox> Yes it can.
11:24:14 <sjanssen> MarcWebe1: GHC can automatically derive Typeable too
11:24:23 <ph8> Main.lhs:144:23: The last statement in a 'do' construct must be an expression
11:24:27 <nmessenger> > show (typeOf putStr)
11:24:28 <ph8> that's the line that has final <- doRepGen..
11:24:29 <lambdabot>  "[Char] -> IO ()"
11:24:29 * sjanssen bets that ph8 has indentation troubles
11:24:41 <ph8> the line below that is return (head a) ++ final
11:25:02 <ph8> i don't appear to
11:25:05 <Saizan> try return $ (head a) ++ final
11:25:17 <nmessenger> ph8: return is just an ordinary function, you can use it in an expression.
11:25:24 <MarcWebe1> sjanssen: http://rafb.net/p/DL5BZY80.html
11:25:27 <lambdabot> Title: Nopaste - How to tell GHC to use type token from declaration
11:25:33 <Saizan> but i think it's an indentation problem again
11:25:40 <ph8> same error Saizan :/
11:25:49 <ph8> hmm
11:25:51 <ph8> but why on earth would it be
11:25:56 <ph8> and why is haskell so anal about it
11:26:01 <ph8> it's all in the same line
11:26:12 <lisppaste2> ph8 annotated #34077 with "like so..." at http://paste.lisp.org/display/34077#3
11:26:13 <Saizan> can you paste from the do?
11:26:21 <ph8> :)
11:26:28 <MarcWebe1> As tokenName is implemented as _ = .. error won't be called. All I need is the type ;)
11:26:51 <sjanssen> ph8: it doesn't look like your parens are nested correctly
11:27:09 <ph8> :o
11:27:10 <ph8> right you are
11:27:12 <Saizan> yeah
11:27:34 <nmessenger> MarcWebe1: 'undefined' is probably better suited that 'error "blah"'
11:27:53 <ph8> usually gives me an unexpected ) error
11:27:55 <ph8> how strange
11:28:06 <sjanssen> lisppaste++ 's paren matching is very handy
11:28:14 <Lemmih> ?check \lst -> not (null lst) ==> lst!!(length lst-1) == last (lst::[Int])
11:28:16 <lambdabot>  OK, passed 500 tests.
11:28:33 <MarcWebe1> sjanssen: You're right. But how to tell ghc that token from line 3 is the same type as token from line 2 ?
11:29:10 <nmessenger> ?type 1 `asTypeOf` (2.0 :: Float)
11:29:12 <lambdabot> Float
11:30:17 <sjanssen> MarcWebe1: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
11:30:19 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
11:30:31 <apfelmus> Igloo: it's a trivial question but what is the historical reason for a tab width of 8? i find 4 more convenient.
11:33:19 <ph8> @hoogle findWithDefault
11:33:19 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
11:33:20 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
11:33:23 <nmessenger> ?where+ tabs http://www.haskell.org/onlinereport/syntax-iso.html#sect9.3
11:33:24 <lambdabot> Done.
11:33:25 <Cale> apfelmus: lining things up in tables, probably
11:33:33 <MarcWebe1> sjanssen: Thanks . o ( exactly what I was looking for)
11:34:36 <Cale> Tab characters weren't just 8 spaces, but aligned things to columns 8 spaces apart
11:34:59 <Cale> 4 characters isn't a very wide column
11:35:23 <emu> apfelmus: were you the one who wrote the den semantics wiki book
11:36:23 <sjanssen> apfelmus: http://en.wikipedia.org/wiki/Tab_key#ASCII_and_EBCDIC
11:36:25 <apfelmus> Cale: yeah, sounds good, 4 spaces are too few. and one cannot remedy things by a double tab because this means to introduce 1 or 0 tabs in the data columns
11:37:12 * Eidolos uses two space tabs >_>
11:37:39 <ray> 8 characters is also not a very wide column
11:38:06 <ray> just try editing fstab on a unix system
11:38:32 <apfelmus> sjanssen: thanks
11:39:22 <apfelmus> emu: yes and no, for technical reasons, it was Apfelmus ;)
11:39:45 <emu> can you answer a small clarification about a proof in there?
11:40:00 <ray> the real question is, how narrow is your text editor that 8 is inconvenient ;)
11:40:17 <apfelmus> emu: of course!
11:40:46 <Cale> Tab characters should not occur in source files.
11:40:48 <emu> in the strictness proof of "succ", you mention that 4 \sqsubseteq \bot
11:41:12 <emu> but don't mention that as a contradiction... am i confused?
11:42:53 <apfelmus> emu: oh, it's a mistake. wait a moment...
11:43:26 <emu> while you're there, can you clarify how you are destructuring that expression
11:43:46 <emu> it appears to be some kind of structural induction on (+)?
11:44:09 <ph8> @hoogle insertWith
11:44:09 <lambdabot> Data.IntMap.insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
11:44:10 <lambdabot> Data.Map.insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
11:44:10 <lambdabot> Data.IntMap.insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
11:49:22 <apfelmus> emu: i changed it. is that better?
11:51:20 <emu> thanks
11:52:36 <apfelmus> emu: np :)
11:54:15 <apfelmus> emu: after all, *i* have to thank for the bug report :)
11:58:40 <george--> does haskell have an intrinsic function to see if a variable occurs in a list
11:58:51 <emu> a variable, or a value?
11:58:54 <george--> value
11:58:58 <emu> elem
11:59:05 <emu> > 1 `elem` [2,1,3]
11:59:06 <lambdabot>  True
11:59:31 <george--> > "a" `elem` [a..z]
11:59:32 <lambdabot>   Not in scope: `z'
11:59:39 <george--> > 'a' `elem` [a..z]
11:59:39 <lambdabot>   Not in scope: `z'
11:59:45 <george--> > 'a' `elem` ['a'..'z']
11:59:46 <lambdabot>  True
11:59:50 <george--> > 'y' `elem` ['a'..'z']
11:59:52 <lambdabot>  True
11:59:52 <apfelmus> ?src elem
11:59:53 <lambdabot> elem x    =  any (== x)
12:00:08 <nmessenger> ?src any
12:00:08 <lambdabot> any p =  or . map p
12:00:10 <emu> showoff
12:00:35 <apfelmus> ?src
12:00:35 <lambdabot> Source for this function is not available.
12:00:41 <apfelmus> ?src or
12:00:42 <lambdabot> or    =  foldr (||) False
12:00:43 <emu> ?src foldM
12:00:44 <lambdabot> foldM _ a []     = return a
12:00:44 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:02:24 <george--> > 'y' `elem` ['a'..'z']:['A'..'Z']
12:02:25 <lambdabot>  Couldn't match `[Char]' against `Char'
12:02:44 <george--> i thought : would join 2 lists?
12:02:47 <nmessenger> >  'y' `elem` (['a'..'z']++['A'..'Z'])
12:02:49 <lambdabot>  True
12:02:59 <nmessenger> 'a':"bc"
12:03:05 <nmessenger> > 'a':"bc"
12:03:06 <lambdabot>  "abc"
12:03:09 <george--> ok
12:03:09 <george--> ty
12:03:17 <emu> george--: ++ is append lists
12:04:02 <nmessenger> george--: you must give george pretty low karma :)
12:04:26 <emu> @karma george
12:04:27 <lambdabot> george has a karma of -3
12:04:49 <micty> hi
12:04:51 <george--> @karma emu
12:04:52 <lambdabot> emu has a karma of 1
12:04:56 <nmessenger> hello micty
12:05:01 <george--> how does this karma function work :P ?
12:05:08 <george--> @karma lambdabot
12:05:09 <lambdabot> lambdabot has a karma of 39
12:05:09 <micty> I did getContents and I can't stop :(
12:05:13 <nmessenger> name plus plus increases karma
12:05:19 <lisppaste2> ph8 annotated #34077 with "IO = Oh Oh?" at http://paste.lisp.org/display/34077#4
12:05:20 <emu> micty: ctrl-c to break
12:05:33 <ph8> who fancies getting tangled in my IO web?
12:05:44 <micty> emu - no EOF symbol?
12:06:02 <emu> micty: whatcha mean? are you looking to terminate a program running too long?
12:06:21 <micty> no, to end the input
12:06:33 <apfelmus> micty: ctrl+d ?
12:06:34 <emu> oh, ctrl-d
12:06:52 <nmessenger> ph8: does genNext use a random number generator?  You might pass a pure StdGen in.
12:06:53 <micty> don't work
12:07:10 <emu> what is genNext, ph8 ?
12:07:30 <micty> x\n^D
12:07:30 <micty> \EOT\n
12:07:30 <micty> \n^D^D
12:07:30 <micty> \EOT\EOT\n
12:07:58 <apfelmus> george: how karma is build up should be clear, the real question is what it will mean after one's dead ...
12:08:05 <emu> ph8: if genNext is in the IO monad, you should put it on its own line and pull a value out
12:08:45 <emu> next <- genNext ...; let firstWordOfNext = head next
12:08:51 <apfelmus> ?type getContents
12:08:53 <lambdabot> IO String
12:08:58 <nmessenger> emu: pulling it out to use it would imply that the eventual result also be in IO.
12:09:08 <Lemmih> ph8: You might find this interesting: http://www.haskell.org/haskellwiki/Introduction_to_IO
12:09:09 <lambdabot> Title: Introduction to IO - HaskellWiki
12:09:18 <emu> well his entire function IS in IO already, i think
12:09:26 <apfelmus> micty: try ctrl-c after you did ctrl-d?
12:09:58 <emu> micty: are you running on Windows in ghci?
12:10:04 <allbery_b> micty: what platform
12:10:08 <apfelmus> in case your program loops indefinitely after swallowing stdin
12:10:25 <micty> windows ghci
12:10:47 <emu> windows ghci has difficulties with control characters unless you run it with the wrapper
12:10:47 <george> ph8, your code work to generate sentences properly?
12:11:04 <micty> after ^C it looks stuck
12:11:13 <emu> ^C will cause it to become stuck, yes
12:11:21 * nmessenger goes off to restore george's karma to 0 in a /msg
12:11:28 <micty> emu ah
12:11:34 <emu> you'll need to open up Task Manager and kill it.  then run it with the wrapper; it tells you in a Warning when you run ghci
12:12:03 <emu> it's a problem with the terminal on windows
12:12:40 <micty> hummmm
12:12:50 <micty> what wrapper?
12:13:05 <micty> and why did it got stuck?
12:13:16 <micty> the input should end
12:13:19 <emu> because there is something wrong with its terminal handling on windows
12:13:19 <nmessenger> this is one of the reasons I wanted a System.Environment.withStdin function.
12:13:40 <emu> GHCI outputs a warning on Windows... read when you first run it...
12:13:55 <emu> in big letters the very first thing it says
12:14:42 <micty> emu - there is no warning
12:14:54 <emu> hmmm.. which version have you got?
12:15:01 <micty> 6.6
12:15:19 <zeuxis> But only if you run ghci fom a cgywin or msys shell... (yes also ghc 6.6)
12:15:30 <emu> ah. well, thats what i run from.
12:15:38 <emu> do you know why he's having terminal troubles?
12:16:36 <micty> I just did getContents and then try to end the input some way to see what happens
12:16:47 * micty learn
12:17:13 <zeuxis> Nope, I've got the same problem (i'll usally run ghci from the window-cmd commandline)
12:17:14 <zeuxis> SoI just kill the ghci-job with the taskmanager :-(
12:17:53 <therp> is GHC doing tail recursive calls automatically?
12:17:54 <micty> what does it mean? that one can't get input?
12:18:27 <nmessenger> micty: it means you can't use ghci to get input interactively
12:18:29 <glguy> from windows console, F6 and ^Z (+ enter) are EOF
12:18:40 <emu> therp: it is performing the transformation
12:18:57 <nmessenger> micty: it should still work with piped input, and I think with a compiled program.
12:19:00 <glguy> to reset the input after a getContents, type ":" Enter
12:19:12 <emu> micty: put this in a file:  main = getContents >>= putStr
12:19:39 <X-scream> hey, anyone good with parsec? :)
12:19:48 <emu> X-scream: got a specific q?
12:19:52 <glguy> X-scream: you ask questions, if someone knows the answer, they answer it
12:19:53 <X-scream> yeah, just a sec
12:19:58 <nmessenger> I'm not the best, but I'll help
12:20:04 <X-scream> trying to figure out a good way to put it
12:20:14 <nmessenger> ?paste your code
12:20:15 <lambdabot> http://paste.lisp.org/new/haskell
12:20:21 <X-scream> ah
12:20:31 <glguy> lol, the doctor is in
12:20:37 <zeuxis> The hangups so occur, when one doesn't do anything with stdin (i.e. if one wants the cancel a long running prog)
12:22:24 <nmessenger> micty: you might also use System.Environment.readFile for non-interactive stuff.
12:22:54 <micty> nmessenger: I don't know, how can I find out?
12:23:31 <nmessenger> micty: ask lambdabot!  Cool commands are @src, @hoogle, @type, @eval (also '>')
12:23:42 <nmessenger> ?type System.IO.readFile
12:23:44 <lambdabot> FilePath -> IO String
12:23:50 <nmessenger> (I had the wrong package name)
12:24:10 <nmessenger> ?type System.IO.readFile "path/to/your/file"
12:24:11 <lambdabot> IO String
12:24:12 <emu> > readFile "/etc/passwd"
12:24:14 <lambdabot>  <IO [Char]>
12:24:46 <emu> > readFile "/etc/passwd" >>= putStr
12:24:48 <lambdabot>  <IO ()>
12:24:48 <nmessenger> @docs System.IO
12:24:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
12:25:11 <nmessenger> ^^ read that.
12:25:55 <X-scream> gah, the paste site just died :D
12:26:02 <nmessenger> o.O
12:26:17 <X-scream> 502 proxy error
12:27:03 <nmessenger> well that sucks, try http://www.rafb.net/paste/ as an alternative
12:28:09 <nmessenger> (paste.lisp.org seems to have gone back up)
12:29:39 <X-scream> http://paste.lisp.org/display/34086
12:29:41 <X-scream> cool :)
12:30:41 <emu> you're tossing the first char
12:30:45 <nmessenger> optional (oneOf ":\n\r")
12:30:51 <X-scream> i know.. but how can i untoss it? :D
12:30:56 <X-scream> ah
12:31:28 <emu> or explicitly save it and cons it
12:32:22 <ph8> sorry my connection appears to have died - reading logs now..
12:32:58 <X-scream> nmessenger: but that makes ":hello " ok..  ":hello " is bad because it starts with a ':'
12:33:13 <ph8> george
12:33:16 <ph8> i was soo happy
12:33:19 <ph8> i thought i'd almost finished
12:33:36 <ph8> but whenever the key becomes [""] (it needs to start a completely random new sentence) - it always selects the first value
12:33:39 <ph8> so i need to add randomness
12:33:47 <ph8> which means i've got to seed an IO return value through loads of code
12:33:49 <ph8> which is a nightmare
12:34:16 <nmessenger> ah, then something like...
12:34:43 <nmessenger> > do {c <- noneOf ":\n\r"; liftM (c:) (manyTill (noneOf "\n\r") (try space))}
12:34:44 <lambdabot>   Not in scope: `space'
12:35:22 <X-scream> yeah, something like that :)
12:35:52 <zeuxis> X-scream: noneof consumes the char that fits, s. http://paste.lisp.org/display/34086#1 .
12:36:40 <nmessenger> zeuxis's should be the same.
12:36:45 <ph8> emu: with this though, the arguments to genNext depend on this case call
12:36:59 <X-scream> yeah.. don't think there's a liftM in parsec (?)
12:37:02 <zeuxis> same idea :-)
12:37:04 <ph8> so i can't call genNext in advance, can I? will it only be executed if i then do a let foo = next ?
12:37:14 <ph8> and hence not error unless it has to (if that makes sense)
12:37:29 <zeuxis> X-scream: but in Control.Monad
12:38:18 <nmessenger> ph8: try adding an explicit StdGen to the args, then ''doRepGen ... =<< newStdGen"
12:38:41 <X-scream> you guys really enjoy doing free online support? ;D
12:38:48 <nmessenger> yeppers :D
12:38:48 <ph8> nmessenger: eep?
12:38:58 <ph8> that's really scary
12:39:00 <X-scream> hehe :)
12:39:00 <ph8> what's =<< do?
12:39:17 <nmessenger> do {gen <- newStdGen; doRepGen ... gen}
12:39:57 <zeuxis> ph8: (=<<) = flip (>>=) (no pun...)
12:40:07 <nmessenger> ?type System.Random.newStdGen
12:40:09 <lambdabot> IO StdGen
12:40:58 <george--> say i have a list of list of a... and i want to apply my function to every item of type a how do i do this? map is giving me errors that my function shouldn't be applied to values of type [a]
12:41:03 <ph8> i might have found another way around it
12:41:04 <ph8> just a jiffy!
12:41:10 * ph8 puts on his superted outfit
12:41:17 <ph8> map map george
12:41:18 <ph8> ?
12:41:33 <nmessenger> george is an (a -> b)!
12:41:36 <apfelmus> Cale: concerning tab stop, I found that I'm using them to achieve effects like in http://nickgravgaard.com/elastictabstops/
12:41:37 <lambdabot> Title: Elastic tabstops - the solution to the tabs-versus-spaces issue
12:41:38 <george--> ill try that =)
12:41:48 <nmessenger> map (map george)
12:41:59 <ph8> heh
12:42:17 <ph8> maps the function map george over <oblivion>
12:42:24 <ph8> map (map george) internalOrgans
12:42:50 <ph8> that would be interesting output
12:43:14 <glguy> Haskell says "tabs are 8 spaces" so does elastic tab stops break that?
12:43:25 <thelsdj> what exactly is an internalOrgan a list of?
12:43:39 <nmessenger> body cells, obviously
12:43:57 <george--> ph8, would you say your program is quick:
12:43:59 <george--> ?
12:44:06 <SamB> glguy: elastic?
12:44:27 <glguy> SamB: yeah, that
12:44:38 <nmessenger> george--: what map (map f) ?  It's lazy, to be sure.
12:44:40 <glguy> SamB: I came in late (as usual) so I might be way off
12:45:01 <george--> nmessenger, we are doing the same project
12:45:05 <glguy> SamB: apfelmus mentioned elastic tabs above
12:45:09 <nmessenger> ah
12:45:13 <george--> nmessenger, so i ask ph8  because i feel mine is very inefficient
12:45:15 <ph8> george--: takes a relative lifetime to parse the input
12:45:23 <ph8> about 5/6 seconds
12:45:25 <george--> ph8, yeah, thats my problem
12:45:26 <ph8> lookups are quick
12:45:31 <ph8> my debug echoes are slowing them down
12:45:31 <george--> what input file are you using?
12:45:35 <ph8> i don't think there's a way around it
12:45:44 <ph8> a 333k book
12:46:06 <george--> mine throws up an error on anything more than ~ 6 paragraphs
12:46:12 <george--> and takes ages to parse even that much
12:46:30 <apfelmus> glguy: yeah, of course they break   semantics '\t' = repeat 8 (semantics ' ').
12:46:53 <nmessenger> Ooh, semantics as a function!
12:46:57 <ph8> ah
12:47:03 <ph8> are you running it through hugs?
12:47:15 <george--> yeah
12:47:17 <ph8> hugs can't handle large inputs, i only use it now for getting nicer errors than ghc throws at me
12:47:20 <ph8> i don't run it through hugs at all
12:47:23 <george--> oh
12:47:26 <ph8> you'll have to use ghc
12:47:31 <nmessenger> but in this case 'semantics '\t'' depends on the number of previous characters on the line ;)
12:47:32 <ph8> or <insert compiler here>
12:48:03 <george--> i guess ill install ghc
12:48:40 <SamB> elastic tabstops are no good for programming if they are table-oriented...
12:48:51 <nmessenger> ph8, george--: are you two using Haskell in a class or something?
12:49:03 <apfelmus> nmessenger: yes, that's the point of tabs. but the haskell report does not state it explicitly
12:49:22 <nmessenger> :P
12:49:31 <apfelmus> SamB: table oriented?
12:49:38 <george--> nmessenger, yes, we take the same module
12:49:49 <apfelmus> nmessenger: though it's assumed implicitly i think
12:51:16 <SamB> apfelmus: oh, but they aren't really...
12:51:56 <ph8> looks way more promising now, just got to fix an index too large error
12:52:00 <ph8> nmessenger: yes
12:52:06 <ph8> george--: we don't do it after this project until the exam do we?
12:53:08 <george--> maybe one or two more lectures left? and then the logic guy
12:53:53 <ph8> hoorah. :p
12:55:24 <SamB> the real solution is to use editors that actually know syntax
12:55:31 <SamB> but which can be extended to support extensions
12:55:36 <SamB> *easily*
12:55:58 <SamB> oh, and stop storing text as ... text ;-)
12:56:06 <ph8> i want an editor that makes me think i'm using tabs, but is actually using spaces
12:56:42 <ph8> i think such a thing will never happen though
12:56:43 <SamB> I want an editor that makes me think I'm using ASTs without being inconvenient
12:56:50 <Botje> ph8: like .. vim?
12:56:54 <SamB> or ugly
12:57:42 <nmessenger> I'm on Windows, and my random freeware editor of choice is Metapad.  http://www.liquidninja.com/metapad/
12:57:44 <lambdabot> Title: metapad home
12:58:44 <nmessenger> Alt-Z (delete first char of selected lines) Alt-Q (Add char to start of selected lines)
12:58:58 <apfelmus> true, true. text is detrimental. but the consequence would be to *trash the terminal* and use GUIs instead...
12:59:41 <nmessenger> also, 'Insert tabs as spaces' option
13:01:00 <nmessenger> teeny-tiny, too.  46K!
13:01:02 <glguy> vim: :set expandtabs, :set tabstop=8 , :set softtabstop=2
13:01:17 <ph8> can i have something = do result <- IO...; | (cond1) | (cond2) etc?
13:01:18 <glguy> :set smartindent
13:01:23 <ph8> or do i have to start guards straight away?
13:01:36 <glguy> ph8: case statements can use guards
13:02:13 <ph8> hmm
13:02:19 <SamB> ph8: I often want to do something like that....
13:02:37 <ph8> i just find the need to make my function 'repGenNext' return an IO type, and it's used in loads of guard conditions
13:02:45 <ph8> atm it's where result = repGenNext ...
13:02:49 <ph8> and | (result ==) etc
13:03:05 <nmessenger> ph8: use a pure StdGen and forget the IO!
13:03:25 <Cale> do result <- x; case () of _ | (cond1) | (cond2) ...
13:03:41 <glguy> ph8: f = liftM aux repGenNext where aux result | cond1 = a | otherwise = b
13:05:02 <ph8> i don't know what a pure StdGen is
13:05:03 * SamB might like where x <- doSomething ;->
13:05:05 <ph8> and it sounds scary
13:05:16 <glguy> or as an expression: let aux res | (conds) in fmap aux dorepgen
13:05:27 <ph8> do result <- x; case () of _ | (cond1) | (cond2) ... <-- i can then use things like 'all null result' in the guard conds?
13:05:34 <glguy> yeah
13:05:39 <ali_lou2> metapad < editpad pro
13:05:50 <SamB> ph8: it means you pass around the RNG "state" instead of reading it from an unsafely created mutable variable
13:06:05 <ph8> of course, that's just what i was thinking!
13:06:29 <glguy> metapad ? editpad pro? are those editors for people that don't know about gvim?
13:06:45 <nmessenger> ali_lou2: meh, I like how tiny it is, and I've gotten used to the keyboard shortcuts.  Editor arguments don't interest me.
13:06:58 <SamB> Cale: that wastes valueable whitespace!
13:07:10 <nmessenger> or people far too lazy to learn vi ;)
13:07:43 <glguy> Are there any editors that can match Visual haskell for type feedback?
13:07:47 <ali_lou2> yeah, you have a point
13:08:40 <ph8> Cale: can i still use where? on those guards?
13:08:42 <nmessenger> glguy: I wonder how robust the Eclipse fp tools are?
13:09:13 <Cale> er, you could use a let beforehand
13:09:37 <nmessenger> ph8: where is in the scope of an equation's '='.  'Let' is better for expressions.
13:09:46 <ph8> > 		result <- (repGenNext a theMap)
13:09:46 <ph8> >		case () of _
13:09:46 <ph8> >		-- Empty Key?
13:09:47 <ph8> >		| (all null key) =
13:09:47 <lambdabot>  Parse error
13:09:50 <ph8> oops, dirty pastage
13:10:00 <ph8> should the _ be elsewhere?
13:10:03 <ph8> getting alignment errors
13:10:30 <ph8> on the guard line
13:10:42 <nmessenger> indent it a space
13:10:43 <glguy> you need to indent your guards at least one step deeper than yoru case
13:10:58 <nmessenger> nvm :)
13:11:44 <ph8> i'll show you a paste now
13:11:45 <ph8> same error
13:12:04 <glguy> the guards need to be more indented than the _
13:12:34 <lisppaste2> ph8 pasted "indentation errors!" at http://paste.lisp.org/display/34088
13:12:36 <glguy>   case () of
13:12:36 <glguy>    _ | otherwise -> putStrLn "TEST"
13:13:21 * nmessenger eyes the "stupid user" mode on the vim website.  He will try it out.
13:13:39 <ph8> hmm
13:14:02 <ph8> and that _ only needs to go in front of my first guard?
13:14:57 <glguy> yeah
13:15:12 <ph8> ah that might have got it, got to alter all my = to ->
13:15:15 <glguy> you could have them in front of all your guards, but you don't need them
13:15:30 <glguy> I lied
13:15:33 <glguy> you don't have them in front of all
13:15:40 <glguy> can't*
13:15:59 <glguy> lied again!
13:16:00 <glguy> you can
13:16:05 <ph8> oh my
13:16:07 <glguy> I forgot to add the second ->
13:16:08 <ph8> if this works it will be genious
13:16:09 <ph8> and fugly
13:16:12 <glguy> so it blew up for the wrong reason
13:16:28 <glguy>   case () of
13:16:29 <glguy>    _ | False -> return ()
13:16:29 <glguy>      | otherwise -> putStrLn "TEST"
13:16:31 <glguy> isn't so ugly
13:16:50 <lisppaste2> ph8 annotated #34088 with "Successful output?" at http://paste.lisp.org/display/34088#1
13:17:27 <nmessenger> horizontal scrollbar!
13:17:57 <ph8> seems to have inconsistencies
13:18:01 <ph8> but definite progress :)
13:19:04 * bd_ hacks fps to pieces trying to get it to work on buffers of CDouble
13:21:12 <lisppaste2> metaperl pasted "hasQAttr not working, but hasAttr is working" at http://paste.lisp.org/display/34089
13:21:54 <metaperl> Cale, could you help with line 37 of this: http://paste.lisp.org/display/34089
13:24:29 <ph8> i think i've chosen a book written by a large testicle as my sample text
13:24:35 <ph8> it's full of queer language that just messages things up
13:24:44 <metaperl> Cale - what I mean is why doesnt hasQAttr seam_id work but hasAttr "seam:id" work
13:25:27 <Cale> metaperl: sorry, I didn't get your previous messages
13:25:45 <metaperl> Cale, I'm just wondering why line 37 of this doesnt work: http://paste.lisp.org/display/34089
13:25:52 <metaperl> actually it _does_ work
13:25:57 <emu> bd_: a sign that I've been reading too many theory books: at first I thought "CDouble? Church encoding for Doubles? whoa"
13:26:18 <metaperl> but hasQAttr seam_id is not working
13:26:46 <bd_> emu: It's theoretically possible!
13:27:07 <bd_> but no, the point is to make manipulations of large lazy buffers of floating-point values more, not less efficient ;)
13:29:12 <ph8> > stripPunc ["mr."] = ["mr"]
13:29:13 <lambdabot>  Parse error
13:29:15 <ph8> is that case insensitive?
13:29:28 <ph8> if not, is there a way to make it so or do i have to specify both cases seperately?
13:29:36 <nmessenger> bd_, emu: well, doubles are represented as bags of bits eventually, right?  This may not be ideal, but it'd be possible.
13:30:03 <nmessenger> ph8: '>' evaluates expressions.  To define names, use a 'let'.
13:30:17 <ph8> heh
13:30:23 <ph8> lets see here
13:30:34 <Cale> metaperl: hmm
13:30:37 <metaperl> Cale - I just sent you the files to try it out
13:30:40 <ph8> > let stripPunc ["mr."] = ["mr"] in stripPunc "Mr."
13:30:41 <lambdabot>  Couldn't match `[Char]' against `Char'
13:30:47 <ph8> > let stripPunc ["mr."] = ["mr"] in stripPunc ["Mr."]
13:30:48 <lambdabot>   Non-exhaustive patterns in function stripPunc
13:30:51 <emu> it will be sensitive
13:30:55 <ph8> indeed :(
13:30:57 <ph8> > let stripPunc ["mr."] = ["mr"] in stripPunc ["mr."]
13:30:58 <ph8> that's naffo
13:30:58 <lambdabot>  ["mr"]
13:31:01 <ph8> i see the point though
13:31:54 <nmessenger> > let stripPunc cs = filter (`notElem` ".,:;!?")
13:31:55 <lambdabot>  Parse error
13:32:00 <nmessenger> :)
13:32:04 <metaperl> Cale - do you get private messages?
13:32:12 <nmessenger> > let stripPunc cs = filter (`notElem` ".,:;!?") in stripPunc "Mr."
13:32:14 <lambdabot>  <[Char] -> [Char]>
13:32:35 <nmessenger> > let stripPunc = filter (`notElem` ".,:;!?") in stripPunc "Mr." -- oops
13:32:36 <lambdabot>  "Mr"
13:33:42 <nmessenger> if you want to use it on a [String], then 'map stripPunc'
13:37:05 <ph8> ah yes i would do that
13:37:18 <ph8> if i didn't want to keep the full stop at the end of any work apart from those select few
13:37:20 <ph8> * word
13:38:15 <nmessenger> try 'case map toLower inputString of "mr." -> "mr"; "mrs." -> "mrs"; etc.'
13:38:36 <bd_> woot, my mutant FastPackDoubles built
13:39:19 <nmessenger> ?index toLower
13:39:20 <lambdabot> Data.Char
13:43:05 <bd_> okay, so they don't work, though.
13:47:38 <lisppaste2> nmessenger pasted "strip abbreviations" at http://paste.lisp.org/display/34091
13:49:32 <nmessenger> might also add (s' = init s) to the where clause of strip.
13:51:02 <nmessenger> did you see that, ph8?
13:51:07 <george--> is there any reason code that words in hugs wouldnt work in GHC?
13:51:23 <dmhouse> george--: not many, what code are you talking about?
13:52:00 <george--> just some project im playing with
13:52:10 <george--> it works in hugs but i thought as it runs slow i will try ghc
13:52:14 <george--> never used it before
13:53:22 <nmessenger> I believe thatHugs is *mostly* a subset of GHC.
13:56:06 <ph8> sometimes hugs errors are more informative than GHCs
14:01:08 <glguy> if I have: something :: MaybeT (State MyData) (), how could I then have: do x <- Just 1
14:01:17 <glguy> or its equivalent?
14:01:57 <shapr> I've got it! My copy of Hamming's book actually ARRIVED!
14:02:22 <dmhouse> shapr: which book?
14:02:37 <shapr> The Art of Doing Science and Engineering: Learning to Learn
14:02:48 <dmhouse> glguy: why are you using MaybeT (State MyData) instead of StateT MyData Maybe?
14:02:56 <shapr> I've been trying to get a copy of this book for YEARS.
14:03:37 <glguy> dmhouse: that's what I WAS doing, but I wanted to see if what I was actually doing was easier with the monads flipped
14:03:37 <shapr> This one went for the incredibly low price of $125 from someplace in Arizona. The only other copy I can find for sale right now is going for $600 in the Netherlands.
14:03:46 <glguy> now I have: liftModify f = put =<< lift . f =<< get
14:03:58 <glguy> so that I can modify the state with a: s -> Maybe s
14:04:10 <dmhouse> shapr: must be a good book. :)
14:04:12 <fasta> Is there a documented(meaning that I don't need to read a "paper" about it before I can use it) unit test frame-work that has been used extensively?
14:04:24 <dmhouse> fasta: HUnit?
14:04:28 <glguy> and so I wondered if I should need that function (I'm pretty new at layering these)
14:04:41 <fasta> dmhouse: is is better than QuickTest
14:04:43 <fasta> ?
14:04:46 <glguy> basically, I want to modify the state with a function that can fail
14:04:47 <fasta> er is it
14:04:53 <shapr> dmhouse: Let me transcribe some quotes from the introduction:
14:05:05 <dmhouse> glguy: it might be an idea to write a MonadState instance for MaybeT (State st).
14:05:13 <glguy> dmhouse: I did
14:05:14 <dmhouse> fasta: no, but QuickCheck's not really unit testing.
14:05:19 <glguy> OH
14:05:27 <dmhouse> glguy: in which case you should be able to use modify straight off.
14:05:28 <fasta> dmhouse: er right, I had the name wrong
14:05:33 <glguy> instance (MonadState s m) => MonadState s (MaybeT m) where
14:05:41 <glguy> get = lift get, put = lift . put
14:05:48 <dmhouse> Something like that, yeah.
14:05:51 <fasta> dmhouse: well, I do like the "property testing" approach too.
14:05:54 <Botje> +w 21
14:05:57 <Botje> argh :(
14:06:04 <fasta> dmhouse: does HUnit does that too?
14:06:09 <dmhouse> fasta: I'd recommend QuickCheck if you want that kind of thing.
14:06:11 <fasta> er do
14:06:26 <dmhouse> I don't think so, although it's been a while since I checked it out.
14:06:29 <shapr> Great results in science and engineering are "bunched" in the same person too often for success to be a matter of random chance. \n <italics>Teachers should prepare the student for the students future, not the teacher's past.</italics>
14:06:53 <glguy> dmhouse: but since the function returns a Maybe state, the monads are in the wrong order that way too...
14:07:10 <glguy> (I'm not sure there is a right order)
14:07:36 <shapr> Man, this book is in near perfect shape, I almost feel bad about making notes in the margins. No, I guess don't feel bad about it.
14:08:10 <dmhouse> shapr: just make sure you write down proofs for any monumental theorems you may stumble across, I don't care how small the margins are.
14:08:17 * shapr laughs
14:08:33 <olliej> dmhouse: hehe
14:09:01 <fasta> shapr: what was the book?
14:09:04 <olliej> dmhouse: but think of all the discoveries that could be made while endeavouring to prove shapr's last theorem
14:09:16 <dmhouse> Well, true.
14:09:50 <araujo> hello
14:10:26 * glguy determines that StateT MyType Maybe () is the correct type
14:10:40 <glguy> because a failure causes the state to not be returned
14:10:51 <shapr> fasta: http://lambda-the-ultimate.org/node/668
14:10:52 <lambdabot> Title: Richard Hamming - "You and Your Research" | Lambda the Ultimate
14:11:06 <fasta> shapr: I read that earlier
14:11:16 <dmhouse> His name makes me think of the unfortunate Top Gear presenter.
14:11:27 <george--> ok, to make a hugs file work in GHC i just make one function called main and then compile with ghc -c file.lhs
14:11:28 <george--> ?
14:11:42 <dmhouse> george--: not quite.
14:11:55 <fasta> shapr: but I am a bit confused now. That's a talk, I thought you were talking about a book.
14:11:57 <dmhouse> ghc -o <executable file name> --make file.lhs
14:11:58 <shapr> fasta: The book is called "The Art of Doing Science and Engineering: Learning to Learn"
14:12:08 <fasta> shapr: ok
14:12:21 <shapr> If you look at the comments on that LtU article, the book is mentioned.
14:12:39 <psnl> george--: if paul has other files or modules, then ghc --make might be what you need
14:13:16 <george--> ok
14:13:25 <george--> so i converted my function i had called nmain and renamed in main
14:13:40 <george--> and its giving me a type error
14:13:53 <dmhouse> What's the error?
14:13:55 <dmhouse> ?where paste
14:13:56 <lambdabot> http://paste.lisp.org/new/haskell
14:14:02 <dmhouse> Paste it there, along with your code.
14:14:23 <george-->     Couldn't match expected type `IO a'           against inferred type `String -> IO ()'   In the first argument of `GHC.TopHandler.runMainIO', namely `main'    When checking the type of the main function `main'
14:14:55 <dmhouse> george--: right, main can't take any arguments.
14:15:04 <nmessenger> Pass it a string.
14:15:05 <dmhouse> If you want to read arguments from the command line, use getArgs.
14:15:38 <nmessenger> do {[arg] <- getArgs; nmain arg}
14:15:48 <nmessenger> ?index getArgs
14:15:49 <lambdabot> System.Environment
14:16:02 <ph8> myArgs <- getArgs
14:16:15 <george--> right
14:16:36 <george--> ill just compile it with the input file location not as an input i think
14:18:13 * shapr boings furiously
14:18:50 <nmessenger> shapr: as in, with furious energy, or while furious?
14:18:57 <shapr> with furious energy!
14:20:35 * nmessenger slumps lazily
14:21:32 <shapr> Wow, this immediately starts to sound like Christopher Alexander's works.
14:22:08 * psnl tries to fire himself up
14:23:05 * thelsdj gets very furious at having to write in javascript and keep it portable between XUL, Yahoo Widgets and Vista Gadgets
14:23:10 <ph8> it sounds like a channel for those suffering fom erective disfunction, what with all the attempts to fire up and the furious boinging
14:23:26 <ph8> * erectile
14:23:29 <ph8> is there a y in there somewhere?
14:23:50 <nmessenger> no, but ew
14:24:15 <ph8> i've only heard rumours such channels actually exist of course..
14:24:20 <shapr> ph8: Hey, you should read this book, you'd boing furiously too.
14:24:29 <ph8> haha
14:24:35 <shapr> This is like receiving a copy of the Book of the Magi in the mail or something.
14:24:55 <dmhouse> How do I pass extra arguments to GHC when compiling with Cabal?
14:25:33 <emu> am i making a huge mistake using TChans to communicate across threads generated by Control.Parallel.Strategies?
14:25:35 <dmhouse> Oh, I specify something in the prj.cabal file, don't I?
14:25:51 <Lemmih> dmhouse: GHC-Options:
14:25:53 <daniel_larsson> GHC-Options: -O
14:33:35 <fasta> shapr: you have another branch of QuickCheck, right?
14:33:59 <fasta> shapr: did you implement an instance for Arbitrary Char?
14:34:53 <emu> hmm, i just realized for this thing to work, every thread has to run in synchronization.. doh
14:35:15 <shapr> fasta: I did, but it's easy to do for yourself. Also, QuickCheck 2 has been released as a public beta.
14:35:26 <glguy> ?hoogle modifyM
14:35:26 <lambdabot> Control.Concurrent.MVar.modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
14:35:27 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
14:35:45 <shapr> fasta: If you have some QC questions, ask me now, I'm about go unicycling :-)
14:35:57 <NichardRixon> unicycling :o
14:35:59 <fasta> shapr: yes, I know, it's easy, but I'd assume such basic functionality would be built-in already
14:36:03 <dmhouse> shapr: btw, got a change to install HAppS yet?
14:36:14 <fasta> shapr: why was HApps unique, btw?
14:36:39 <fasta> shapr: I think you didn't tell yesterday.
14:38:21 * glguy finds the article where Cale and Peter Steiner introduce "modifyM" and "liftModify" to a coder with the same issue that I had, they even used the same names that I did, sweet ;)
14:38:46 <glguy> mailing list archive, not particle
14:38:49 <glguy> s/p//
14:43:40 <glguy> and would you guess it? Bulat submitted a completely unhelpful response
14:44:08 <fasta> glguy: that's more than most people did
14:45:08 <glguy> Um, sure
14:46:28 <wchogg> category question:  doesn't a monad's return function naturally induce a coalgebra for each type and a comand's coreturn induces an algebra?
14:48:43 <Saizan> are there coalgebras?
14:49:26 <fasta> These people think so http://www.cs.le.ac.uk/people/akurz/mgs.html
14:49:28 <lambdabot> Title: Introduction to Coalgebras
14:53:40 * monochrom is here to save the newbies again!
15:07:25 * ndm has a subtle bug to trouble shoot about 10 levels deep in a haskell program - why are there no good debuggers...
15:08:00 <astrolabe> I thought we'd worked out the reason to that one :)
15:08:07 <syntaxfree> theres no good repl.
15:08:08 <dmhouse> ndm: I know. It's possibly Haskell's biggest shame.
15:08:09 <ndm> we have, but why hasn't anyone else...
15:08:15 <syntaxfree> i wish you could :load a single function in ghci, for example.
15:08:18 <dmhouse> ndm: if it's highly layered, Hat?
15:08:24 <syntaxfree> also :load-recursively so it loads all the functions it calls.
15:08:31 <dmhouse> Although I would have thought you'd know about that, didn't you do some work on Hat yourself?
15:08:34 <ndm> dmhouse: yes, which i can guaratnee it won't work
15:08:54 <ndm> dmhouse: my deep knowledge of hat means i _know_ its death by a thousand cuts for any real program
15:09:05 <glguy> I figured out why using the state was being such a hassle
15:09:17 <glguy> I was just using it to carry a value that I needed to modify over and over
15:09:18 <ndm> syntaxfree: you can in WinHaskell - a multiline edit prompt
15:09:24 <glguy> switched from StateT to just a foldM
15:09:25 <ndm> (if it worked...)
15:09:39 <ndm> you actually can in WinHugs, but i don't think anyone but me knows how
15:10:00 <qwr> collect :: Monad m => m (Maybe a) -> m [a]
15:10:00 <qwr> collect m = m >>= maybe (return []) (\e -> collect m >>= return . (e:))
15:10:06 <glguy> ndm: what's this winhugs magic you secretly hold?
15:10:27 <ndm> glguy: copy from a text buffer, multi-line, and paste it - you end up with a multiline edit prompt
15:10:27 <qwr> is there something in the libraries, that would let it in a nicer way?
15:10:37 <astrolabe> ndm: dons was saying that the next version of ghci will have a debugger
15:10:42 <ndm> glguy: not very useable though, WinHaskell makes it much much nicer
15:10:50 <qwr> (... write in a nicer way)
15:11:00 <ndm> astrolabe: breakpoint debugger, its a start, but its about 1000 times less than Hat
15:11:07 <ndm> (in terms of features, and 1000 time more reliable)
15:11:23 <ndm> i am sharing a hostel room with the guy who wrote it, so am very curious to see it in action
15:11:34 <syntaxfree> I can't see how the concept of "breakpoint" translates to Haskell.
15:11:40 <dmhouse> qwr: whenever you place return on the RHS of a >>=, think fmap.
15:11:41 <ndm> poorly is my guess
15:11:47 <ndm> but i am hoping i'm wrong...
15:12:01 <dmhouse> \e -> collect m >>= return . (e:)   ===     \e -> fmap (e:) (collect m)
15:12:08 <ndm> esp as with a breakpoint most of the values will be unevaluated thunks, which show up badly
15:12:37 <psnl> hsdebug deals with that nicely
15:12:42 <syntaxfree> it would be better to be able to load functions at will from a GUI.
15:12:58 <syntaxfree> the GUI presents you a list of your functions and you double-click them to load into the environment.
15:13:09 <ndm> psnl: hsdebug? tell me more
15:13:20 <ndm> syntaxfree: why not just load them all at the start?
15:13:40 <syntaxfree> because if _one_ function fails to type or something, you can't use anything else.
15:13:52 <syntaxfree> so you resort to commenting-out stuff so you can check your type model in ghci.
15:14:05 <astrolabe> Is it fundamentally more difficult to produce a debugger for a functional language than an imperative one?
15:14:14 <ndm> syntaxfree: fix your errors, then reload - i'm not convinced thats a good development model, i would never dream of having broken stuff
15:14:27 <ndm> astrolabe: a bit, the real challenge is lazy
15:14:38 <syntaxfree> astrolabe: i think the problem isn't functionalness, it's laziness.
15:14:42 <psnl> ndm: http://portal.acm.org/citation.cfm?id=871904&dl=acm&coll=&CFID=15151515&CFTOKEN=6184618
15:14:45 <lambdabot> Title: HsDebug, http://tinyurl.com/y9535t
15:15:47 <ndm> psnl: given how dead the optimistic evaluation branch of GHC is, i guess this is several feet underground by now
15:16:24 <psnl> aww, when I first saw that, I thought it was the best solution to debugging yet
15:16:36 <astrolabe> Surely spj must have run up against the difficulty of debugging haskell.  Unless he doesn't produce bugs.
15:16:47 <ndm> if you read the comparison to hat the reason is "because Hat is broken" - reading bteween the lines
15:17:17 <ndm> astrolabe: expert vs novice, of course he has less bugs, he has been doing this a lot longer than most of us
15:17:25 <ndm> (but not quite all in this channel, i suspect)
15:17:50 <temujin> <troll> vista > * </troll>
15:17:52 <monochrom> I think a functional debugger is fundamentally more difficult.  There is a contrived relation between closures and memory layout.  I mean just look at *.hc files  +_+  :)
15:18:09 <ndm> Colin Runciman doesn't write bugs in Haskell, i've seen him write 10 pages of bugfree code without even loading it in any Haskell type checker
15:18:12 <astrolabe> I suspect he might have more programming ability than some (me) too.
15:18:31 <astrolabe> ndm: that is scary!
15:18:44 <bos31337> how do people get a handle on stuff like concurrent programming and network programming in haskell?
15:18:46 <ndm> astrolabe: i know, he did miss a bracket, but that was all i found when i reviewed his code
15:19:01 <qwr> dmhouse: hmm thnx. but liftM worked better than fmap there... :)
15:19:03 <astrolabe> I find I produce lots of bugs in haskell because the typechecker catches so many.
15:19:14 <ndm> and thats the only way i knew for sure he hadn't passed it though a haskell type checker
15:19:27 <dmhouse> qwr: they're precisely the same.
15:19:39 <qwr> only i got error message with fmap
15:19:44 <ndm> bos31337: have you read up on STM?
15:19:46 <psnl> bos31337: the concurrencey is lovely, just do a bit of reading and start writing
15:19:54 <bos31337> ndm: yes.
15:20:01 <qwr> Could not deduce (Functor m) from the context (Monad m)
15:20:13 <bos31337> psnl: the problem is the "bit of reading". do i start with the original peyton jones paper introducing concurrent haskell?
15:20:13 <astrolabe> ndm: what kind of bug is it?
15:20:14 <zeuxis> Some stategic 'trace's and quickChecks are sufficient for me
15:20:18 <ndm> bos31337: i have no idea from that :)
15:20:37 <psnl> bos31337: is that the fifty page one?
15:20:38 <dmhouse> qwr: oh, okay, you'd have to add (Functor m) to your typeclass context, but fair enough, liftM is probably just easier.
15:20:51 <Cale> heh, I just misparsed the word "codemonkeys" as co-demon-keys
15:20:54 <monochrom> I learned concurrency from a formal CS education.
15:20:56 <psnl> bos31337: I picked it up really quickly
15:21:07 <Shimei> bos31337: You could try Peyton Jones' recent intro paper: http://research.microsoft.com/~simonpj/tmp/beautiful.ps
15:21:14 <ndm> astrolabe: i have a transformation system, which does 10 levels of applying multiple transformations, and by the end the answer is slightly wrong - i suspect i've missed a variable capturing thing at some point
15:21:18 <mahogny> what is the current state of hs-plugins. does it work with the latest ghc?
15:21:22 <ndm> free variables are very painful
15:21:40 <bos31337> monochrom: the question isn't really how to do concurrent programming, it's how to do it in haskell.
15:21:42 <mahogny> n/m
15:22:09 <ndm> psnl: what always scares me about all these debugger questions, none ever seem to have used Visual Studio, the gold standard in debugging - no wonder all of them fall way short
15:22:10 <bos31337> i guess i'll just poke at forkIO a bit.
15:22:12 <astrolabe> ndm: that sounds like the kind of code that is begging for a bug :)
15:22:17 <monochrom> Subsequently I attended the "Tackling the Awkward Squad" lectures.
15:22:28 <ndm> astrolabe: it is, but it's also my PhD :)
15:22:43 <mahogny> bos31337, nothing stops you from doing threads the old style. but I would really urge you to look at STM and other more civilized versions of it
15:22:54 <astrolabe> ndm: can you view the results at intermediate levels?
15:23:13 <monochrom> STM still uses threads the old style.  Just not locks the old style.
15:23:27 <ndm> astrolabe: yes, i can view 10 pages of code where the bug moves around randomly based on which stage it is in, and there is no real way to see if the bug is present
15:23:41 <ndm> astrolabe: but that is of course what i am currently doing...
15:23:49 <astrolabe> ndm: I'm glad it's not my PhD :)
15:23:55 <emu> forkIO and STM is what you want to use
15:24:25 <emu> STM is very easy to use, especially if you were accustomed to the old ways and want better
15:24:31 <monochrom> If you already know concurrency in general, the first STM paper has usable examples.
15:24:44 * emu is doing a forkIO/STM demo atm
15:25:18 <emu> the paper Composable Memory Transactions as linked from the haddock docs for Control.Concurrent.STM is good to read
15:25:23 <ndm> astrolabe: its fun and i enjoy the challenge, but i do sometimes wish i'd made Hoogle or something else my main topic...
15:25:27 <monochrom> Yeah, that one.
15:26:24 <monochrom> What does Visual Studio do on debugging?
15:26:48 <ndm> monochrom: perfection, in coded form
15:27:08 <ndm> monochrom: it gives you the right visual metaphores, easy interaction with the code, breakpoints and exactly what you'd want
15:27:25 <ndm> in later versions you can even change C++ code while its running, and that scares me muchly
15:27:52 <astrolabe> It is good.  I wonder how they made it.
15:28:08 <astrolabe> Must be some very bright people in MS
15:28:09 <mahogny> xcode can change code while it runs too. can't say I like the feature
15:28:12 <ndm> it is perfect, if i had my way, i'd force everyone who ever wrote a debugger to use Visual Studio for a few days
15:28:21 <ndm> mahogny: me neither, its the rest of everything i love
15:28:35 <ndm> and then shoot the GDB people for lowering the expectations of the world
15:28:50 <mahogny> I used msvc for two months in school. never again will I touch that POS
15:28:58 <emu> i am used to changing code while running from CL
15:29:08 <emu> (and Smalltalk)
15:29:11 <ndm> mahogny: why? what didn't you like?
15:29:19 <ndm> i love it from top to bottom
15:29:35 <emu> it is one thing i do miss in Haskell
15:29:56 <astrolabe> ndm: I find it diffucult to know what I can do, or where to find out.
15:30:01 <mahogny> ndm, more of the lack of anything I did like. and I felt very unproductive as well, and I got pissed off by non-standard stuff and irritating autoindent etc etc
15:30:04 <syntaxfree> well, HINDL.
15:30:10 <monochrom> To tell you the truth, I am not sure what I'd want in a debugger.
15:30:19 <emu> developing an OpenGL app in CL is wicked fun because you can fiddle with the output while running
15:30:35 <ndm> i know exactly what i want in a debugger
15:30:42 <syntaxfree> emu: are there good OpenGL/GLUT  bindings for CL?
15:30:48 <astrolabe> monochrom: the descriptions of the hat tools are quite mouthwatering.  Till you try it.
15:30:51 <syntaxfree> Something that's as easy to get running as Haskell's.
15:31:02 <ndm> astrolabe: most of MSVC debugging is very intuative, requires no learning curve
15:31:04 <emu> a number.  CL-SDL is what i was using. i don't know what the state of it is now.
15:31:08 <ndm> much much less than Hat
15:31:13 <ndm> (even if it worked)
15:31:26 <syntaxfree> emu: what compiler/interpreter do you recommend?
15:31:32 <emu> sbcl, no doubt
15:31:34 <mahogny> I like erlang in the debug aspect, if it wasn't for the horrible dynamic types
15:31:39 <ndm> syntaxfree: there are bindings to both shiped with Hugs, never used either though
15:31:52 <syntaxfree> well, yes. I use GLUT with H askell.
15:31:56 <syntaxfree> I'm talking about CL :)
15:31:59 <emu> i wonder if you can finagle hs-plugins to do similar things
15:32:12 * syntaxfree finagles emu.
15:32:21 <emu> @yow
15:32:22 <lambdabot> I'd like some JUNK FOOD ... and then I want to be ALONE --
15:33:36 <emu> the dynamic types make it much easier to implement that kind of debugging / reloading
15:35:01 <Cale> 8/100, Reddit is not doing all that well lately.
15:35:28 <ph8> is a binary search tree O(logn) lookup times or O(nlogn)?
15:35:40 <Cale> (That's the not-modded-down/posts ratio)
15:35:40 <Igloo> log n
15:35:55 <matthew-_> log_2 n
15:35:59 <syntaxfree> Cale: reddit linked a defmacro post about how he hates his health care insurance.
15:36:09 <emu> heh
15:36:14 <syntaxfree> Cale: sure, defmacro is a nice blog and all, but that's not reddit material.
15:36:22 <Cale> There's too much not-programming on programming reddit.
15:36:34 <syntaxfree> not programming.reddit material anyway.
15:36:37 <Igloo> matthew-_: The base is irrelevant, asymptotically
15:36:37 <Cale> I can't even be bothered to post messages with "not programming" on all of them
15:36:55 <syntaxfree> maybe there should be a "speed-review" button.
15:36:58 <sorear> Just write a program to do it for you :)
15:37:15 <Igloo> Errr, not asymptotically. YKWIM.
15:37:32 <emu> > getClockTime
15:37:33 <lambdabot>   Not in scope: `getClockTime'
15:37:54 <monochrom> I have a vision for a functional stepper.  At a typical intermediate state, and frozen at that point, the computer highlights an expression and says "I am about to evaluate this".  There are bubbles pointing out from variables telling you their values (perhaps a bubble doesn't show unless you mouse-over the variable; this is negotiable).  If the value is a thunk, or a constructor with a child thunk, or ... you can ask to expa
15:37:54 <monochrom> nd as deeply as you want.  You can also ask to undo the expansion.
15:38:44 <sorear> has this been done yet? @remember ndm I guess the only thing to do is to trust that people who have learnt enough about monads and IO to hijack Haskell things probably realise how cool Haskell is...
15:38:54 <sorear> @quote cool Haskell
15:38:55 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
15:39:06 <sorear> @quote hijack Haskell
15:39:06 <lambdabot> No quotes for this person. My mind is going. I can feel it.
15:39:13 <ndm> sorear: no
15:39:16 * sorear remembers the regex-quote
15:39:21 <sorear> @remember ndm I guess the only thing to do is to trust that people who have learnt enough about monads and IO to hijack Haskell things probably realise how cool Haskell is...
15:41:20 <bos31337> what'st the lambdabot command to query by signature?
15:41:35 <mauke> hoogle
15:41:59 <bos31337> doesn't that query by name?
15:42:09 <bos31337> @hoogle [a] -> [a]
15:42:10 <lambdabot> Prelude.cycle :: [a] -> [a]
15:42:10 <lambdabot> Prelude.init :: [a] -> [a]
15:42:10 <lambdabot> Prelude.reverse :: [a] -> [a]
15:42:13 <bos31337> oh, never mind :-)
15:42:21 <kpreid> @hoogle cycle
15:42:21 <lambdabot> Prelude.cycle :: [a] -> [a]
15:42:22 <lambdabot> Data.Graph.Inductive.Example.ucycle :: Graph gr => Int -> gr () ()
15:42:22 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
15:42:24 <ndm> bos31337: hoogle does everything :)
15:43:00 <bos31337> i was looking for a breakAll in the standard prelude, similar to python's string.split, but hoogle didn't give me the goods.
15:43:21 <bos31337> it's only 4 lines of code, but i thought it would have been a standard thing.
15:43:23 <thelsdj> @src cycle
15:43:23 <lambdabot> cycle [] = undefined
15:43:23 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:43:47 <ndm> bos31337: alas its not, we have lines and words, but no general version
15:43:58 <monochrom> Consider using Text.Regex.splitRegex
15:44:11 <bos31337> but my little 4-liner works great :-)
15:44:27 <monochrom> yes, rolling your own is also good.
15:44:36 <ndm> but it really should be in Data.List
15:44:52 <ndm> did someone not propose it on the library list?
15:45:31 <sorear> many, many times
15:45:32 <seliopou> bos: break on a char or a substring?
15:46:04 <sorear> but regexen are evil
15:46:28 <pesco> how's that?
15:46:57 <bos31337> seliopou: in my case, on a predicate that can test a char
15:47:10 <bos31337> i.e. (a -> Bool) -> [a] -> [[a]]
15:47:19 <sorear> structured strings are evil, a fortiori,
15:47:39 <bos31337> they're just DSLs.
15:47:46 <bos31337> DSLs are mom and apple pie.
15:47:53 <monochrom> Computers are evil.
15:48:01 <bos31337> evil is mom and apple pie, too.
15:48:07 <sorear> EDSLs are better.
15:48:11 <monochrom> Apple is evil.  As are apple pies.
15:48:22 <bd_> @pl \f m a1 a2 -> f (m a1) (m a2)
15:48:23 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:48:42 <bos31337> yoicks.
15:48:56 <sorear> i'm shocked, that looks like a pretty basic combinator
15:49:29 <dons> Cale, see the mailing list for "Monad Set via GADT" ?
15:50:21 <dons> looks like something in (->) r Monad..
15:50:56 <dons> ?pl \m x y -> ((m x),(m y))
15:50:56 <lambdabot> flip =<< (((.) . (,)) .)
15:51:10 <dons> ?pl \m x y -> (m *** m) (x,y)
15:51:10 <lambdabot> (. (,)) . (.) . join (***)
15:51:23 <mauke> @pl \f m a -> f (m a) (m a)
15:51:24 <lambdabot> join . liftM2
15:51:53 <dons> we need to get people into extending the @pl rules set, now that we find the need for more rules...
15:52:00 <dons> ?users
15:52:01 <lambdabot> Maximum users seen in #haskell: 304, currently: 302 (99.3%), active: 34 (11.3%)
15:52:03 <mauke> @pl \f m1 m2 a -> f (m1 a) (m2 a)
15:52:04 <lambdabot> liftM2
15:54:38 <Lemmih> Currently 302?
15:55:24 <ndm> wow, thats pretty close
15:56:00 <Cale> dons: ah, neat, he's just resorting to using lists when the Ord constraint isn't available
15:57:38 <dons> ?users
15:57:38 <lambdabot> Maximum users seen in #haskell: 304, currently: 302 (99.3%), active: 34 (11.3%)
15:57:43 <dons> mm. I count 282
15:58:10 <sorear> ?users
15:58:10 <lambdabot> Maximum users seen in #haskell: 304, currently: 301 (99.0%), active: 34 (11.3%)
15:58:11 <dons> sorear: did you mess with @seen? (could it be counting wrongly?)
15:58:27 <dons> could say, #Haskell and #haskell be separate now?
15:58:40 <sorear> ?users #Haskell
15:58:40 <lambdabot> Maximum users seen in #Haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:59:00 <sorear> ah, look not good
15:59:05 <sorear> *looks
15:59:07 <dons> ah, those call backs changed right?
15:59:20 <shapr> @users shapr
15:59:20 <dons> so I think maybe it got the high count right, but its missing parts/quits?
15:59:20 <lambdabot> Maximum users seen in shapr: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:59:27 <shapr> I'm inactive!
16:00:02 <sorear> There is currently a great deal of type-unsafety in Seen
16:00:39 <sorear> You can convert a String-off-the-wire into a ByteString using pack, or readNick and packNick.
16:00:56 <dons> mm
16:00:59 <sorear> the former is type correct, now wrong, and used in the old code.
16:01:08 <dons> ah
16:01:19 <dons> dive in, take charge of @seen and make it good!
16:01:25 <sorear> I had to use grep to find the uses of it.
16:01:44 <xpika> how come this doesnt work in my ghci session
16:02:01 <xpika> > (reverse >>= (++)) "ontaxeslana"
16:02:03 <lambdabot>  "analsexatnoontaxeslana"
16:02:16 <norpan> yikes
16:02:21 <syntaxfree> hahahaha
16:02:49 <ndm> xpika: your GHCi session got upset
16:03:09 <sorear> dons: I think I'll change Nick to use ByteString directly, this way the unsafe packing can be completely removed. (And it should play into your plans.)
16:03:09 <nmessenger> works in mine
16:03:38 <Saizan> :m + Control.Monad.Instances ?
16:03:58 <nmessenger> Prelude> ...
16:04:19 <gvdm_other> ?src head
16:04:20 <lambdabot> head (x:_) = x
16:04:20 <lambdabot> head []    = undefined
16:04:27 <Saizan> No instance for (Monad ((->) [Char])) ... on prelude
16:04:45 <xerox> :m + Control.Monad.Reader
16:04:49 <dons> sorear: sounds good
16:05:12 <sorear> dons: how short does a String have to be to be more efficient than a ByteString?
16:05:22 <dons> I think it was 7 chars or something
16:05:25 <sorear> is fn:ndm short enough?
16:05:54 * sorear is probably worrying too much
16:05:58 <dons> I'd leave it as a ByteString, unless you need to do structural matching
16:06:10 <dons> since then its easier to serialise anyway, and key comparision is faster
16:06:46 <sorear> Maybe there should be a type for VeryShortByteStrings (just a pointer, without the overheard required for O(1) slicing)
16:07:03 <syntaxfree> > length "fn:fdm"
16:07:05 <lambdabot>  6
16:07:34 <syntaxfree> @let chop n s = take (min n (length s)) s
16:07:36 <lambdabot> Defined.
16:07:42 <sorear> sf: that's *n*dm, as in Neil D. Mitchell on Freenode.
16:07:45 <syntaxfree> > L.chop 7 "seven is short"
16:07:46 <lambdabot>  "seven i"
16:07:56 <lisppaste2> nmessenger pasted "combined instances for class heirarchies" at http://paste.lisp.org/display/34097
16:08:19 <syntaxfree> oh.
16:08:25 <syntaxfree> ndm = Neil D. Mitchell.
16:08:28 <sorear> ?let chop = zipWith (const id) . flip replicate ()
16:08:29 <lambdabot> <local>:6:0: Varying number of arguments for function `chop'
16:08:31 <syntaxfree> he's on my google talk list somehow.
16:08:35 <xerox> > L.chop (-1) ""
16:08:37 <lambdabot>  ""
16:08:52 <sorear> ?undef
16:08:53 <lambdabot> Undefined.
16:08:53 <sorear> ?let chop = zipWith (const id) . flip replicate ()
16:08:55 <lambdabot> Defined.
16:09:05 <xerox> > L.chop (-1) ""
16:09:06 <lambdabot>  ""
16:09:08 <sorear> > L.chop 7 "seven is sh"
16:09:10 <lambdabot>  "seven i"
16:09:25 <ndm> why are people discussing me?
16:09:34 <ndm> D = David, in case anyone cares :)
16:09:42 <sorear> youre nick is too(?) short, that's why
16:10:00 <nmessenger> (too is correct)
16:10:07 <sorear> efficiency of ByteStrings on three letter strings
16:10:16 <ndm> its my comp sci username, hence the default for me
16:10:20 <dons> sorear: dont worry! just use bytestrings
16:10:29 <sorear> (too vs. sufficiently, not too vs. to)
16:10:38 <ndm> who cares about efficiency?
16:10:41 <syntaxfree> > L.chop 2 "ndm"
16:10:42 <lambdabot>  "nd"
16:10:55 <ndm> tell them they are using a broken compiler, and should upgrade to Yhc ;)
16:10:56 <dons> sorear: what case are you worried about? slow lookups for short nicks?
16:11:00 <nmessenger> What does anyone think of my sugar proposal?
16:11:03 * dons measures the cycles to chcek 
16:11:14 <monochrom> nmessenger: you may also consider posting to haskell-cafe for a wider discussion
16:11:29 <thelsdj> Am I insane in wondering whether Tetris might be Turing Complete?
16:11:39 <xpika> where might i be able to find the source file for something like http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#v%3A%3E%3E%3E ?
16:11:41 <lambdabot> http://tinyurl.com/y6yt3s
16:11:44 <nmessenger> ?google Tetris Turing Complete
16:11:52 <ndm> thelsdj: its an NP problem even given infinite lookup, not turing complete though
16:12:00 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
16:12:07 <nmessenger> O.O
16:12:17 <monochrom> you are insane alright :D
16:12:23 <sorear> Autotyping can be problematic
16:12:25 <syntaxfree> @yow
16:12:26 <lambdabot> VICARIOUSLY experience some reason to LIVE!!
16:12:43 <sorear> I just fatfingered "su -c 'aptitude -u'" into "su -c 'init 0'"
16:12:48 <monochrom> xpika: is there a "Source" link at the top?
16:13:01 <sorear> that's why I left
16:13:02 <zeuxis> xipka: look at http://hackage.haskell.org/trac/ghc/wiki/DarcsRepositories
16:13:04 <lambdabot> Title: DarcsRepositories - GHC - Trac
16:13:14 <thelsdj> if not turing complete i still want to try making a language from playing it
16:13:27 <olliej> is there a printf in the standard haskell libs? i just had a thought of how to do it, and want to know how much better the real solution is :D
16:13:28 <xpika> monochrom: thanks i never noticed that
16:13:33 <bos31337> @hoogle printf
16:13:34 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
16:13:34 <lambdabot> Text.Printf :: module
16:13:34 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
16:13:52 <thelsdj> @src printf
16:13:53 <lambdabot> Source for this function is not available.
16:14:03 <olliej> bos31337: cheers
16:14:20 <olliej> :t Text.Printf.printf
16:14:22 <lambdabot> forall r. (PrintfType r) => String -> r
16:14:25 <augustss> > printf "%d %s" (33::Int) "hello" :: String
16:14:26 <lambdabot>  "33 hello"
16:14:48 * olliej is wondering what printftype is,
16:14:54 <olliej> @hoogle PrintfType
16:14:54 <lambdabot> No matches found
16:14:57 <olliej> :-/
16:15:05 <monochrom> The doc has it.
16:15:06 <augustss> olliej: it's whatever it needs to be :)
16:15:11 <wchogg> Doesn't that printf use template haskell under the hood?
16:15:20 <augustss> wchogg: no
16:15:28 <augustss> just H98
16:15:33 <monochrom> Just type class Oleging.
16:15:37 <bos31337> olliej: if you want to see printf properly, look at cayenne
16:15:41 <olliej> augustss: not even higher ranked types?
16:15:43 <wchogg> augustss:  Ah, so I'm getting it confused with the one from one of the TH papers.  Thanks.
16:15:46 <olliej> bos31337: i am :D
16:15:49 <bos31337> ah.
16:16:03 <augustss> olliej: just H98
16:16:29 <wchogg> monochrom:  Oleg is now a verb?
16:16:31 <sorear> besides, higher rank types are equivalent to type classes
16:16:42 <monochrom> Heh
16:16:45 <augustss> yeah, kinda
16:16:48 <sorear> its already an adjective and improper noun
16:16:53 <sorear> ?quote oleg
16:16:54 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
16:17:01 <sorear> ?quote oleg
16:17:02 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
16:17:04 <Philippa> wchogg: all we've got to do now is drop the capital and I think we've run out of honours...
16:17:37 * monochrom founds the School of Olegology.
16:17:58 <wchogg> monochrom:  It sound better as Church rather than School.
16:18:37 <monochrom> I already belong to an existing church.
16:18:50 <wchogg> You should have thought of that before you founded a new one.
16:19:05 <monochrom> Yes, so I found a school instead.
16:19:43 <gvdm_other> I can see why writing Monad tutorials is the done thing, I thought I knew them till I decided to read a few, I now feel thoroughly confused...
16:20:08 <gvdm_other> it's a trick by the Haskell community to make new people feel stupid
16:20:35 <bos31337> it's ok. once you understand monads, there are arrows to make you feel stupid.
16:20:39 <gvdm_other> you read a few tutorials and then you will never be able to use Monads, unless that is, you figure them out yourself
16:20:44 <bos31337> after that, it's the yoneda lemma.
16:20:45 <monochrom> haha
16:20:47 <bos31337> the list goes on.
16:21:34 <Philippa> there're surprisingly few tutorials about implementing monads by means other than stacking a few transformers though
16:22:00 * allbery_b thinks school is fairly appropriate; then again, he's imagining Beit Oleg vs. Beit Bulat
16:22:14 <monochrom> Hee Hee!
16:22:44 <augustss> Bulat the Assigner
16:22:51 <wchogg> That's pretty awesome.
16:23:04 * sorear understands arrows perfectly, but is still trying to digest comonads.
16:23:07 <dons> sorear: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
16:23:11 <syntaxfree> gvdm_other: monads are a thing from mathematics, that's the problem.
16:23:17 * syntaxfree understand comonads better than arrows.
16:23:21 <dons> (timing the number of cycles to do a lookup with a String or ByteString key)
16:23:25 <wchogg> sorear:  I'm kind of in the same boat.
16:23:45 <sorear> what'ya know! mg doesn't accept URLs!
16:24:34 <Philippa> has anyone proposed a comonad equivalent of do yet?
16:24:53 <syntaxfree> sigfpe sorta suggested it, but found a few walls and left them open.
16:25:03 <syntaxfree> (in the cellular automata article everyone read, IIRC)
16:25:09 <dons> we should make the comonad library more widely available...
16:25:13 <dons> there's a couple floating around
16:25:28 <syntaxfree> I'm taking a course in percolation systems.
16:25:40 <wchogg> Now, wasn't there a problem with OI violating referential transparency?
16:25:42 <syntaxfree> Simulating percolation systems looks quite comonadic to me.
16:26:15 <syntaxfree> wchogg: you don't need an OI comonad to have the comonad library into Haskell.
16:26:19 <augustss> wchogg: nothing says we need to have OI just because we have comonads
16:26:50 <sorear> I know the signatures and the logs, I've found a few (random numbers are close enough to be treated as comonadic), but I don't "get" the general case.
16:27:01 <wchogg> Oh sure, I agree:  I was just asking if I was remembering the issues with OI correctly.
16:27:05 <sorear> s/logs/laws
16:27:40 <dpiponi> I tried writing a whole bunch of comonadic versions of monad related functions such as sequenceM and foldM (PS This is sigfpe by another name)
16:27:53 <glguy> ?fptools Data.Generics
16:27:54 <lambdabot> http://darcs.haskell.org/packages/base/Data/Generics.hs
16:28:00 <syntaxfree> dpiponi = sigfpe?
16:28:06 <dpiponi> yes
16:28:11 <syntaxfree> oh. you rock.
16:28:26 <dpiponi> Don't embarass me.
16:28:35 <monochrom> You rock.
16:28:36 <augustss> sigfpe: you confuse us with the name change :)
16:28:39 <sorear> data RC g a where RandomGen g => RC g a ; instance Comonad (RC g) where coret (RC a b) = b ; cojoin (RC a b) = let (x,y) = split a in RC x (RC y b)
16:28:42 <wchogg> You can't be embarassed when it's true, yo.
16:28:47 <monochrom> When will you re-invent comonads? :D
16:28:48 <syntaxfree> just be sigfpe :)
16:28:55 <dpiponi> I don't understand IRC. Haskell is a lot easier.
16:29:04 <sorear> dpiponi: we found a generalization of your CA comonad
16:29:05 <syntaxfree> Haskell _is_ easy.
16:29:15 <glguy> ?docs Data.Generics
16:29:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
16:29:16 <syntaxfree> The mathematics that is being modelled in Haskell is hard.
16:29:23 <syntaxfree> sorear: oh. tell me more.
16:29:23 <monochrom> @remember dpiponi I don't understand IRC. Haskell is a lot easier.
16:29:32 <dpiponi> What kind of generalisation?
16:29:52 <sorear> instance Monoid o => Comonad (->) o where coreturn = ($ mempty) ; cojoin f x y = f (x `mappend` y)
16:30:12 <sorear> CA x is Integer -> x, and is a comonad because Integer isa Monoid.
16:30:38 <olliej> let (f::Int->Int) x = x+x in f 2
16:30:43 <olliej> > let (f::Int->Int) x = x+x in f 2
16:30:44 <lambdabot>  Parse error in pattern
16:30:53 <olliej> > let (f::Int->Int) = \x -> x+x in f 2
16:30:54 <lambdabot>  Parse error in pattern
16:31:03 <olliej> > let (::Int->Int = \x -> x+x in f 2
16:31:04 <lambdabot>  Parse error
16:31:06 <dpiponi> sorear - I did almost the same thing actually
16:31:18 <dpiponi> Convolution is comonadic
16:31:42 <dpiponi> What you've done is a kind of generalised convolution
16:32:00 <sorear> 06.12.23
16:32:40 <sorear> ski & sorear, tunes-time ~12:40
16:33:11 <sorear> I never thought of this as being related to convolution, neat
16:33:45 <dpiponi> I think when I did this I had f x y = f (x-y) instead of f (x+y)
16:34:06 <dpiponi> Maybe it doesn't matter.
16:34:16 <sorear> yes it does
16:34:41 <sorear> coreturn . cojoin = id -- - doesn't satisfy this
16:34:46 <dpiponi> OK, I think it's just a change of variable in the integral
16:35:16 <norpan> @quote norpan
16:35:17 <lambdabot> norpan says: your sentence missing a verb
16:35:22 <norpan> bah
16:35:38 <dpiponi> Anyway, convolution is comonadic which means that vast amounts of DSP and image processing code are
16:36:27 <syntaxfree> convolution comes up in probability.
16:36:44 <sorear> dpiponi: \f -> coreturn $ cojoin f = \f -> cojoin f 0 = \f a -> cojoin f 0 a = \f a -> f (-a) -> (. negate) /= id
16:37:57 <dpiponi> Yeah, you can write the equation for convolution in different ways, the usual one uses a minus, but you need the plus one to make it fit the definition of a comonad
16:38:13 <syntaxfree> Haskell really should have a stochastic calculus library.
16:38:31 <bakert> Anyone got any experience of Debug.Trace and can show me a simple example?
16:38:44 <bakert> Say I'm playing a round of card game with "round state"
16:38:45 <sorear> > Debug.Trace.trace "foo" 2
16:38:46 <lambdabot>   Not in scope: `Debug.Trace.trace'
16:39:03 <astrolabe> syntaxfree: what would that contain?
16:39:11 <bakert> Can I just say "round $ trace (show state) state" ???
16:39:16 <sorear> aww, can't attack dons' xterm :)
16:39:33 <syntaxfree> a Stochastic data type, consisting of a distribution function P(X<=x), which is an instance of Num.
16:39:35 <sorear> bakert: probably
16:40:02 <syntaxfree> There's mathematics to recover the distribution function of functions of random variables.
16:40:09 <sorear> syntaxfree: Distributions have been modeled as monads, I've read a paper.
16:40:23 <bakert> sorear, thanks
16:40:44 <bakert> i did try that but at least i know it must be a typo not a fundamental wrong approach now!
16:40:45 <astrolabe> sorear: I thought I discovered that :(
16:41:08 <dpiponi> Wouldn't recovering distribution functions require a calculus library before writing a stochastic calculus library
16:41:30 <sorear> oh, you wanted *closed form*?
16:42:18 <sorear> Smallest Maxima port contest! :)
16:42:59 <syntaxfree> haha.
16:43:11 <syntaxfree> Well, numerical approximations are okay.
16:43:24 <sorear> that's been done.
16:43:31 <sorear> ?go distribution monad
16:43:35 <syntaxfree> Stochastic calculus?
16:43:35 <lambdabot> http://www.cs.ru.nl/~ichiro/papers/calcoJrAbstract.pdf
16:43:38 <syntaxfree> oh, cooool.
16:43:56 <syntaxfree> cool, and at the same time, blah, someone took my idea.
16:43:59 <sorear> I haven't tried the search though
16:44:47 <bakert> ?where logs
16:44:48 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
16:45:14 <syntaxfree> bah, no implemented. they just prove it's possible.
16:45:18 <syntaxfree> (via a monad)
16:47:15 <astrolabe> A similar thing that can be coded as a monad is a quantum mechanical 'wave' function.
16:48:35 <dpiponi> In the right category, vector spaces form a monad. The wavefunction thing kinda follows for free from this.
16:49:36 <astrolabe> how are vector spaces a monad?
16:49:51 <astrolabe> oh, I think I see
16:51:14 <dpiponi> M = functor taking a set to the vector space generated by elements of the set
16:51:36 <dpiponi> makes M a monad.
16:52:03 <augustss> there are some interesting papers about expressing quantum computation (and vector spaces) in haskell
16:52:11 <Saizan> is a bug if i ask ghci to compute a very big number and it gives an "unknown software exception"? (win32)
16:52:13 <astrolabe> Where the set is the set of values of a type
16:52:28 <astrolabe> augustss: do you have any links?
16:52:55 <dpiponi> Eg. M({u,v}) is the set of vectors {au+bv} for real a and b
16:52:56 <sorear> how big is your number?
16:53:00 * astrolabe googles
16:53:35 <astrolabe> got one http://portal.acm.org/citation.cfm?id=871900&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618
16:53:38 <lambdabot> Title: Modeling quantum computing in Haskell, http://tinyurl.com/yb8b4h
16:53:45 <dpiponi> Expressing quantum computation as a monad is the easy bit...
16:53:48 <augustss> I don't have any links, but Jerzy Karczmarczuk wrote one
16:53:51 <ndm> Saizan: report a bug
16:54:01 <Saizan> 28433*2^7830457+1
16:54:03 <dpiponi> ...the hard bit is trying to make it so that you can't write code that wouldn't make sense on a quantum computer
16:54:20 <bos31337> @hoogle prefix
16:54:21 <lambdabot> Distribution.Simple.Configure.prefix :: LocalBuildInfo -> FilePath
16:54:21 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
16:54:21 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
16:54:31 <augustss> Amr Sabry wrote another
16:54:55 <astrolabe> The Sabry one looks interesting
16:54:56 <sorear> wait - that looks like a Rice prime?
16:55:19 * sorear thinks he got the name wrong
16:55:26 <dpiponi> (augustss, when I originally met that problem with thinking Set couldn't be implemented as a monad it was when I was trying to implement the vector space monad to do some quantum computation.)
16:55:26 <Saizan> i just know that's a non-Mersenne prime :)
16:55:58 <augustss> dpiponi: ah, yes.  that messes things up
16:56:01 <Saizan> and that it has 2,357,207 digits
16:56:41 <dpiponi> If you apply a reasonably large matrix to a vector a few times you end up with a gigantic representation of the vector because you can't use Eq to collect coefficients.
16:57:04 <augustss> Yes, I can see how that's bad
16:57:15 <astrolabe> Saizan: that crashes my ghci too
16:57:21 <astrolabe> (also win32)
16:57:36 <dpiponi> I think it get's really bad if you want to factor even modest sized numbers with Shor;s algorithm
16:58:18 <Saizan> (it crashes even a compiled version by the way)
16:58:38 <augustss> So the new GADT stuff that saves a dictionary with the data should help to make Set a monad in a nicer way
16:58:56 <sorear> my ghci is now spamming my console with digits (Linux)
16:58:57 <augustss> but I haven't verified that it works
16:59:05 <sorear> wow, it's done
16:59:20 <dpiponi> Do you have a link to this new GADT stuff?
16:59:21 <Saizan> :O
16:59:39 <Saizan> i'll report a bug then
17:00:02 <astrolabe> I found the previous version of ghci very unstable on windows.
17:00:10 <astrolabe> 6.6 seems a lot better though.
17:00:15 <augustss> dpiponi: hmmm, simon had an email about it before the 6.6 release, i think
17:00:19 <Saizan> sorear: can you paste me the last 10?
17:00:36 <Saizan> +digits
17:00:40 <sorear> It takes just unter 9s to compute
17:00:42 <astrolabe> There are better ways to calculate the last 10
17:01:04 <sorear> 8739992577
17:01:13 <augustss> wow, cool!  while printing that large number my macbook actually uses both cpus!
17:01:25 <sorear> it only took 10s, far shorter than the type needed to find a better algo :)
17:01:41 <sorear> (I'd use modular arith)
17:01:42 <Saizan> :D
17:02:03 <astrolabe> sorear: When the cpus rebell, you'll be first up against the wall.
17:02:29 <dpiponi> Too weird. Checked my gmail for occurrences of GADT and someone posted to Haskell-Cafe with this title 1 hr ago "Monad Set via GADT"
17:02:42 <augustss> heh
17:02:57 <sorear> time ghc -e 'let x = 28433*2^7830457+1 in x `mod` 2'   takes 0.9s longer than   time ghc -e ''
17:03:06 <sorear> so display is the bottleneck
17:03:24 <sorear> I have 1 core
17:04:31 <dons> are you fixing @seen? :)
17:05:00 <sorear> yessish
17:05:39 <sorear> which is preferred : P.append x (P.cons y z) ; P.concat [x, P.singleton y, z]
17:05:54 <Botje> hmmm
17:06:23 <Botje> I had to use repeated squaring to get that bigass number
17:06:43 <Botje> and even then had to trim the intermediate results down to 10 numbers :/
17:07:23 <sorear> I have 3 gibidigits of RAM.
17:07:24 <augustss> Botje: what language were you using?
17:07:29 <Botje> augustss: haskell
17:08:05 <sorear> Haskell uses GMP for integers, which is uber-efficient with huge numbers (and not-as-great with small ones)
17:08:14 <sorear> Haskell meaning GHC here
17:08:24 <sorear> Botje: what version?
17:08:29 <Botje> 6.4.2
17:08:40 <sorear> HEAD takes 0.9s
17:08:41 <Botje> does 6.6 really do it that much better? :/
17:09:01 <sorear> 6.6 takes 0.9s
17:09:19 <Botje> sorear: mind giving me the exact code you used?
17:09:35 <sorear> 6.4.2 takes 7.5s
17:09:40 <Botje> not on my box :/
17:09:44 <sorear> stefan@stefans:~/lb-sorear$ time ghc -e 'let x = 28433*2^7830457+1 in x `mod` 2'
17:09:57 <sorear> 2.0 GHz P4, 384MB ram
17:10:06 <sorear> ghc is HEAD
17:10:19 <sorear> (but Debian's 6.6 is just as fast)
17:10:41 <sorear> (Binary-from-haskell.org 6.4.2 takes 7.5s)
17:10:46 <Botje> hmm
17:10:49 <syntaxfree> HEAD?
17:11:01 <sorear> sf: anachronism
17:11:15 <Botje> lesson learned: don't use show when taking subsets of very large numbers
17:11:21 <glguy> ?type Data.Generics.listify
17:11:23 <lambdabot> forall r a. (Data.Generics.Basics.Data a, Typeable r) => (r -> Bool) -> a -> [r]
17:11:24 <mauke> that code takes ~0.85s here
17:11:35 <mauke> both 6.4.2, 6.6
17:11:56 <bakert> Anyone know how arbitrary and coarbitrary work in Test.QuickCheck?
17:12:14 <bakert> I need to set up my State record type to work with QuickCheck
17:12:16 <dons> $ time ghc -e 'let x = 28433*2^7830457+1 in x `mod` 2'
17:12:16 <dons> 1
17:12:16 <dons> ghc -e 'let x = 28433*2^7830457+1 in x `mod` 2'  4.19s user 0.05s system 99% cpu 4.276 total
17:12:47 <dons> bakert: you just implement a 'arbitrary' case in terms of some existing arbitrary value (i.e. map to Int or some such)
17:13:02 <glguy> ?index listify
17:13:03 <lambdabot> Data.Generics.Schemes, Data.Generics
17:13:26 <dons> bakert: there's some examples here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/ShowQ.hs
17:14:20 <bakert> instance Arbitrary State where arbitrary = choose (State.initial, State.test, State.test2)
17:14:21 <bakert> ???
17:14:27 <bakert> What does coarbitrary do?
17:14:35 <bakert> (thanks dons looking at those now)
17:14:56 <sorear> coarbitrary generates random numbers from an object
17:15:04 <sorear> arbitrary generates an object from random numbers
17:15:25 <Saizan> mmh the bug on windows is related only on printing the number..
17:15:37 <bakert> sorear, and i need both for any given type i want in my tests?
17:17:01 <dons> sorear: hmm. not quite
17:17:09 <dons> coarbitrary is used to generate random functions
17:17:15 <dons> its usually not needed
17:17:55 <Mynstral> How can I see what Prelude defines?
17:18:06 <bakert> so what does arbitrary return?  a list of possible elements?
17:18:13 <psnl> anyone know anything about describing protocols as types?
17:18:41 <dons> ?source Prelude
17:18:41 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:18:58 <dons> bakert: it is monadic, and returns a new random value of a given type each time
17:19:02 <Mynstral> Thanks
17:19:14 <bakert> ?hoogle elements
17:19:15 <lambdabot> Test.QuickCheck.elements :: [a] -> Gen a
17:19:15 <lambdabot> Text.Html.getHtmlElements :: Html -> [HtmlElement]
17:19:35 <bakert> dons, ok thanks think i am getting there ... !
17:22:08 <sorear> dons: is IRC typical or atypical in its case insensitivity?
17:22:09 <nmessenger> Mynstral: you might also ':b Prelude' in GHCi.
17:23:10 <sorear> I'm thinking of forcing all nicks to lowercase.
17:23:18 <dons> sorear: hmm. case matters (usually), some times they don't e.g. channel names. by custom case doesn't matter to users
17:23:24 <dons> yeah, I *think* that'd be ok
17:23:33 <dons> we do it in other plugins
17:24:12 <sorear> we can always fake case sensitivity, stty xcase (but that's probably too evil)
17:24:34 <dons> yes. that is too evil
17:31:57 <sorear> If lambdabot lowercases all nicks, would that prevent /msg replies to e.g. SamB?  I can see /msg sOREAR, but there is no response to /msg lambdAbot @help
17:33:57 <dons> I don't think we can in general lower case everything
17:34:08 <dons> but a particular plugin can.
17:34:26 <dons> just keep an eye on the task at hand ;)
17:34:34 <dons> get @seen fixed, then look at the larger issues
17:34:47 <dons> "patches win matches"
17:35:36 * shapr boings!
17:36:02 <augustss> the ever-boinging shapr!
17:41:52 * psnl cries into the hat code
17:42:10 * shapr boings past augustss!
17:42:38 <deadbeef> what is your opinion about the P=NP problem ?
17:43:01 <shapr> augustss: After Lunar^ et al wrote hOp, stepcut threatened to get hugs running on the bare hardware and call it bOing.
17:43:11 <orbitz> i generally debug via well placed print's in a program.  i noticed in teh debug seciton on teh wiki there is mention of a trace function but i'm rather new to haskell so teh description of how to use it was a bit vague for me.  when i define a function i do f | trace "Baz" bar = yadda ?
17:43:24 <dons> yeah
17:43:40 <dons> it prints its first argument (as a side effect) before returning its second argument
17:43:51 <dons> :t Debug.Trace.trace
17:43:53 <lambdabot> forall a. String -> a -> a
17:43:56 <dons> ?docs Debug.Trace
17:43:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
17:44:08 <orbitz> how does this work though?  what is happening in this defintion?
17:44:13 <psnl> @hoogle when
17:44:14 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
17:44:14 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
17:44:23 <psnl> aah
17:45:14 <dons> see also traceShow
17:45:20 <dons> trace string expr = unsafePerformIO $ do
17:45:20 <dons>     hPutStrLn stderr string
17:45:20 <dons>     return expr
17:45:36 <dons> it runs an IO action for its side effect (the print)
17:46:22 <orbitz> for instance what i fiw ant to show x in this funciton add x y = x + y
17:46:37 <orbitz> add x y | trace show x False = x + y
17:46:39 <orbitz> err (show x)
17:47:34 <dons> add x y = traceShow x (x+y)
17:47:39 <dons> or
17:47:45 <dons> add x y = trace (show x) (x+y)
17:47:53 <dons> add x y = trace (show x) $ x + y
17:48:04 <orbitz> hrm the wiki shows code like:
17:48:05 <orbitz> myfun a b | trace ("myfun " ++ show a ++ " " ++ show b) False = undefined
17:48:06 <orbitz> myfun a b = ...
17:48:50 <dons> hmm. not sure if that works. interesting idea
17:48:56 <dons> I guess it does!
17:49:05 <dons> (and its a nice extensible way to add tracing)
17:49:14 <orbitz> i don't quite follow what that expreison is doing..
17:49:31 <dons> oh, it tries to evaluate the first guard, which is False (and has the side effect of printing a string)
17:49:39 <dons> then it drops down an executes your normal code
17:50:18 <orbitz> ohh i think i see
17:50:53 <mauke> oh, hello orbitz :-)
17:51:05 <orbitz> ohh wonderful that works
17:51:13 <orbitz> hey mauke, i wrote my first real haskell program today
17:51:33 <mauke> cool
17:51:47 <orbitz> it solves sudoku's
17:52:08 <orbitz> it's 55 line sof code almost 1/3 the length of my elrang one (although my erlang one has obvious places i can shorten it)
17:53:13 <orbitz> it' sa bit ugly thouhg, since i wrote it while learning haskell so obviously it's a bit hackish
17:53:30 <dons> there's a 7 line sudoku solver floating around
17:53:31 <dons> in hskell
17:53:36 <dons> ?wiki Sudoku
17:53:37 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
17:53:37 <dons> maybe?
17:55:39 <orbitz> http://rafb.net/p/va1N9k45.html is wha tmine lok slike, rather naive
17:55:41 <lambdabot> Title: Nopaste - No description
17:56:43 <orbitz> mauke: you writ emuch haskell or just like to hang out with me?
17:59:00 <mauke> I don't write much code, but haskell is a cool language
17:59:36 <orbitz> i like writing it so far, not sure how i feel about reading it currently
17:59:48 <olliej> orbitz: or you can be like me -- write a haskell compiler, but restrict all the haskell you write to testcases for that compiler
17:59:58 <orbitz> olliej: sound sliek a pan
18:09:56 <orbitz> mauke: what shoudl my net haskell program be?  solving the world hunger equation?
18:10:21 <mauke> heh, no idea
18:10:26 <mauke> making a regex generator was fun
18:11:21 <orbitz> mauke: i discovered teh rx library in emacs, it's pretty swell
18:12:12 <mauke> what does it do?
18:12:23 <ralf`> C-h C-f rx: no match.
18:12:30 <ralf`> orbitz: How do you use the rx library?
18:12:35 <ralf`> That's for regular expressions right?
18:13:59 <orbitz> ralf`: yup
18:14:02 <nornagon> hm, it'd be cool to be able to feed something a whole bunch of lines and have it work out a regex that matches the input
18:14:21 <nornagon> as in, matches every one of the input lines
18:14:24 <orbitz> ralf`: i goto *scratch* M-x load-library <ent> rx
18:14:26 <mauke> that's easy, join them with |
18:14:41 <nornagon> an optimised regex :P
18:14:56 <nornagon> so that it matches more lines of the same format
18:14:56 <mauke> there are several modules on CPAN for that
18:16:17 <orbitz> ralf`: (rx (and line-start (0+ (in "a-z")))) C-j - >"\\(?:^[a-z]*\\)"
18:17:15 <mauke> oh, so it's just sexprs for regexes?
18:17:27 <orbitz> yeah
18:17:34 <AStorm> Cheap, but effective :P
18:17:41 <orbitz> a bit easier to read i think
18:17:47 <AStorm> No, it isn't :P
18:17:49 <mauke> I have a program that takes a regex and generates a list of matching strings
18:18:23 <orbitz> AStorm: heh i'd rather read a sexpr than that regexp
18:18:45 <AStorm> Because you don't know them by heart yet? ;-)
18:18:57 <orbitz> yes and i'd rather not learn htem by heart
18:19:14 <AStorm> mauke, like a QuickCheck?
18:19:31 <mauke> I don't know what QuickCheck is
18:19:38 <orbitz> i prefer SlowCheck
18:20:50 <AStorm> ?help check
18:20:50 <lambdabot> check <expr>
18:20:50 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
18:21:03 <nmessenger> ?check 1 == 1
18:21:04 <lambdabot>  OK, passed 500 tests.
18:21:07 <nornagon> lol
18:21:37 <nornagon> ?check \a -> a + 1 == 1 + a
18:21:38 <lambdabot>  Add a type signature
18:21:45 <nmessenger> ?check (\xs -> reverse (reverse xs) == xs) -- slightly more interesting
18:21:46 <lambdabot>  Add a type signature
18:21:50 <mauke> I don't see how that's related to my program
18:22:04 <nmessenger> ?check (\xs -> reverse (reverse xs) == (xs::[Int])) -- ...when it works
18:22:04 <nornagon> ?check (\a -> a + 1 == 1 + a) :: (Num a) => a -> Bool
18:22:05 <lambdabot>  OK, passed 500 tests.
18:22:05 <lambdabot>  Add a type signature
18:22:28 <nornagon> ?check (\a -> a + 1 == 1 + a) :: Int -> Bool
18:22:29 <lambdabot>  OK, passed 500 tests.
18:22:50 <nornagon> ?check (\a -> a / 1 == 1 / a) :: Int -> Bool
18:22:51 <mauke> ?check (\a -> a + 1 == 1 + a) :: Double -> Bool
18:22:51 <lambdabot>   add an instance declaration for (Fractional Int)
18:22:52 <lambdabot>  OK, passed 500 tests.
18:23:00 <nornagon> ?check (\a -> a / 1 == 1 / a) :: Double -> Bool
18:23:01 <lambdabot>  Falsifiable, after 0 tests: -1.75
18:23:11 <AStorm> nornagon, yep, it's wrong :>
18:23:21 <AStorm> Due to binary rounding problems.
18:23:27 <sbarg> ?check a==a
18:23:28 <lambdabot>   Not in scope: `a'
18:23:37 <AStorm> ?check a==a :: String
18:23:37 <lambdabot>   Not in scope: `a'
18:23:44 <AStorm> ?check \a -> a==a :: String
18:23:45 <lambdabot>  Couldn't match `String' against `Bool'
18:23:51 <AStorm> ?check \a -> a == a :: String
18:23:52 <lambdabot>  Couldn't match `String' against `Bool'
18:23:53 <nornagon> ?check (a::String) == (a::String)
18:23:54 <lambdabot>   Not in scope: `a'
18:23:58 <AStorm> ?check (\a -> a == a) :: String
18:23:59 <lambdabot>      The lambda expression `\ a -> ...' has one arguments,     but its type `...
18:24:03 <nornagon> ?check \a -> (a::String) == (a::String)
18:24:04 <lambdabot>  OK, passed 500 tests.
18:24:17 <sbarg> Good, nornagon
18:24:19 <AStorm> ?check (\a -> a == a) :: String -> Bool
18:24:20 <lambdabot>  OK, passed 500 tests.
18:24:49 <nornagon> ?check 1.0 == 1
18:24:50 <lambdabot>  OK, passed 500 tests.
18:25:39 <augustss> ?check \ x y z -> (x+y)+z == x+(y+z::Double)
18:25:40 <lambdabot>  Falsifiable, after 11 tests: 0.33333333333333326, 2.5, -2.0
18:25:46 <nornagon> ?check \a -> (a::Float) * pi == (a::Double) * pi
18:25:47 <lambdabot>  Couldn't match `Double' against `Float'
18:25:54 <mauke> $ echo '\d+\.\d+' | ./regen 30
18:25:55 <mauke> ["0.0","0.1","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.0","1.1","1.2","1.3","1.4","1.5","1.6","1.7","1.8","1.9","2.0","2.1","2.2","2.3","2.4","2.5","2.6","2.7","2.8","2.9"]
18:26:10 <nmessenger> ?check theAnswerToLifeTheUniverseAndEverything == 42
18:26:11 <lambdabot>   Not in scope: `theAnswerToLifeTheUniverseAndEverything'
18:26:25 <mauke> maybe I should make it a lambdabot plugin :-)
18:26:26 <nornagon> mauke: booring, you should make it generate random stuff :)
18:26:26 <AStorm> lambdabot is not all-knowing :>
18:26:28 <nmessenger> ?let theAnswerToLifeTheUniverseAndEverything = 42
18:26:29 <lambdabot> Defined.
18:26:43 <gvdm_other> ?check theAnswerToLifeTheUniverseAndEverything == 42
18:26:44 <lambdabot>  OK, passed 500 tests.
18:26:48 <mauke> nornagon: it generates ALL matching strings. just select random elements :-)
18:26:48 <AStorm> :-)
18:27:01 <nornagon> mauke: :)
18:27:23 <nornagon> what if I want to select the several millionth element, though -- does it generate all previous elements?
18:27:41 <mauke> yep
18:27:49 <nornagon> :(
18:28:18 <nornagon> pls to be writing a lambdabot plugin that generates random ones.
18:28:35 <mauke> that's boring
18:28:39 <gvdm_other> having lambdabot available on console as a developer 'friend' would be really cool, it could look up source, run checks hoogle for stuff... he should be added to a haskell IDE
18:28:50 <syntaxfree> wait, wait.
18:28:51 <dons> it runs from ghci already
18:28:57 <gvdm_other> ok
18:29:08 <nornagon> i want a lambdabot> prompt :D
18:29:10 <syntaxfree> this ?check generates random inputs given a function type?
18:29:14 <nmessenger> ?where goa -- gvdm_other
18:29:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:29:27 <syntaxfree> ?check (reverse (reverse x)) == x
18:29:28 <lambdabot>   Not in scope: `x'
18:29:34 <nornagon> where can I get one?
18:29:41 <syntaxfree> ?check reverse . reverse == id
18:29:42 <lambdabot>   add an instance declaration for (Eq ([a] -> [a]))     In the definition of ...
18:29:50 <nmessenger> nornagon: also see goa
18:30:13 <nmessenger> (==) is not defined for (a -> b)
18:30:30 <nornagon> ?check (\a -> reverse (reverse a) == a) :: [Int] -> Bool
18:30:32 <lambdabot>  OK, passed 500 tests.
18:30:55 <nmessenger> ?let (===) f g x = f x == g x
18:30:56 <lambdabot> Defined.
18:31:19 <nmessenger> ?check reverse . reverse === (id :: [Int] -> [Int])
18:31:20 <lambdabot>      precedence parsing error         cannot mix `(.)' [infixr 9] and `(===)'...
18:31:29 <nornagon> ... how do you have an infix operator with three arguments? O.o
18:31:29 <nmessenger> ?check (reverse . reverse) === (id :: [Int] -> [Int])
18:31:31 <lambdabot>  OK, passed 500 tests.
18:31:40 <nmessenger> :D
18:31:48 <syntaxfree> ohh.
18:32:08 <syntaxfree> ?check (reverse . reverse) === (id :: [String]->[String])
18:32:12 <lambdabot>  OK, passed 500 tests.
18:32:16 <nmessenger> nornagon: operators are just functions
18:32:37 <nornagon> nmessenger: right, but how do you pass it three arguments?
18:32:40 <nornagon> ... hm.
18:32:52 <nornagon> i guess its type is a -> b -> c -> Bool
18:33:04 <nornagon> so it takes two and returns something of type c -> Bool
18:33:19 <nmessenger> (blah ! barf) puke -- for some operator (!)
18:33:31 <nornagon> :)
18:34:16 <nmessenger> you might also say that it takes two arguments and returns a function.  Currying FTW.
18:34:19 <falmeshon> haskell sucks
18:34:37 <falmeshon> too lazy
18:34:42 <falmeshon> ;)
18:34:43 <nornagon> heh
18:34:52 <AStorm> falmeshon sucks too for not reading the docs
18:35:11 <AStorm> Two words: seq and ($!)
18:35:20 <AStorm> Maybe (~) as well
18:35:23 <nornagon> :t seq
18:35:25 <lambdabot> forall b a. a -> b -> b
18:35:36 <nmessenger> ~ is just *more* lazy
18:35:36 <nornagon> ... ?
18:35:42 <AStorm> nmessenger, ah, right :P
18:35:45 <nornagon> :t (~)
18:35:46 <lambdabot> parse error on input `)'
18:35:53 <AStorm> It's special
18:35:56 <nmessenger> nornagon: ~ is syntax, not a function
18:35:56 <AStorm> :t ~1
18:35:57 <lambdabot> Pattern syntax in expression context: ~1
18:36:00 <dons> falmeshon: let !x = [1..10] -- not lazy
18:36:02 <nornagon> ah.
18:36:06 <dons> its a lazy and strict language!
18:36:06 <mauke> nornagon: do you know what , does in C?
18:36:17 <dons> data T = T !Int -- not lazy!
18:36:17 <nornagon> mauke: i have a vague idea
18:36:25 <nmessenger> nornagon: and seq forces its first argument to be strict
18:36:53 <nmessenger> > let infiniteListOhNoes = repeat "lol" in infiniteListOhNoes `seq` 1
18:36:54 <lambdabot>  1
18:37:01 <nmessenger> wait a second
18:37:08 <AStorm> :>
18:37:10 <falmeshon> dons: i'll take your word for it havent touched it in 4 semesters
18:37:10 <nornagon> heh
18:37:12 <mauke> nmessenger: head
18:37:20 <dons> nmessenger: WHNF
18:37:27 <nmessenger> > let infiniteListOhNoes = cycle "lol" in (last infiniteListOhNoes) `seq` 1
18:37:32 <lambdabot> Terminated
18:37:56 <nornagon> oh man
18:38:02 <nornagon> > "l" ++ cycle "ol"
18:38:03 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
18:38:17 <mauke> > cycle "lo"
18:38:19 <nornagon> :DDDD
18:38:19 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
18:38:29 <nmessenger> ([blah] ++) = (blah :)
18:38:31 <nornagon> aw.
18:38:52 <mauke> $ echo '(lo)+' | ./regen 10
18:38:52 <mauke> ["lo","lolo","lololo","lolololo","lololololo","lolololololo","lololololololo","lolololololololo","lololololololololo","lolololololololololo"]
18:39:13 <nornagon> mauke: that's begging for a lambdabot plugin
18:39:16 <nmessenger> ?check \x -> ([x] ++) === ((x::Char) :)
18:39:17 <lambdabot>  OK, passed 500 tests.
18:40:20 <nornagon> > [1..] `seq` 1
18:40:21 <lambdabot>  1
18:40:26 <nornagon> I don't get it.
18:40:33 <AStorm> Eh...
18:40:43 <AStorm>  [1..] doesn't have to be evaluated at all
18:40:54 <nmessenger> ?google WHNF seq haskell
18:40:55 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg10722.html
18:40:56 <lambdabot> Title: RE: Confused about seq and forms.
18:41:05 <mauke> [1..] is 1 : [2..]
18:41:28 <mauke> it evaluates until it hits the first constructor, which is (:)
18:41:28 <AStorm> mauke, which still doesn't have to be evaluated at all :P
18:41:46 <dons> ?src []
18:41:46 <AStorm> Yeah right. Not in that case :-) ghc is smarter than that
18:41:46 <lambdabot> data [] a = [] | a : [a]
18:41:52 <dons> it reduces it to the outermost constructor
18:42:08 <dons> so when your data type is:   1 : (2 : ( 3 : ...
18:42:14 <dons> you just get 1 : <thunk>
18:42:35 <dons> its fairly easy  to roll a DeepSeq class that forces the structures in their entireity
18:42:46 <AStorm> There is one, too :P
18:42:50 <AStorm> ?hoogle DeepSeq
18:42:51 <lambdabot> No matches found
18:42:55 <AStorm> ?hoogle seq
18:42:55 <lambdabot> Prelude.seq :: a -> b -> b
18:42:56 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
18:42:56 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
18:43:02 <nmessenger> (?hoogle+)
18:43:04 <AStorm> Hmm. I've seen it somewhere
18:43:26 <AStorm> Pugs has that
18:43:56 <AStorm> Well, it's all too common :P
18:44:03 <AStorm> Should be in the lib, probably.
18:45:40 <AStorm> Ok, throw me an idea for a real Haskell project :>
18:46:10 <dons> what's your favourite library from some other language?
18:46:12 <dons> or app?
18:46:18 <nmessenger> ?hoogle Eq b => (a -> b) -> (a -> b) -> a -> Bool
18:46:18 <dons> something in python or perl you want to port?
18:46:19 <lambdabot> No matches, try a more general search
18:46:22 <dons> and say, add parallelism
18:46:59 <nornagon> ?src liftM
18:47:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:47:01 <AStorm> dons, uh... well, the most useful ones have already been ported :>
18:47:17 <AStorm> Maybe some sound library :P
18:47:31 <nornagon> SDL?
18:47:31 * nmessenger thinks QuickCheck should define an (===) operator for loose function equivalence
18:47:32 <AStorm> GStreamer bindings, with combinators maybe? :P
18:47:43 <nornagon> what graphics libraries are ther for haskell?
18:47:52 <dons> nornagon: quite a few, check the libraries page
18:48:02 <dons> a Qt ui binding is one notable missing lib though
18:48:08 <AStorm> SDL already has bindings.
18:48:29 <nornagon> hm... what about image generation? something like imagemagick?
18:48:31 <nornagon> (or GD?)
18:48:55 <AStorm> Hmm... good idea, too.
18:50:41 <AStorm> But first, I need a small, non-broken SMTP server. That will be fun in Haskell too :>
18:51:24 <dons> theres one already
18:51:29 <dons> check the Network page
18:51:29 <nornagon> someone should write a nethack-playing bot in haskell >:)
18:51:41 <AStorm> Damn, somebody was faster :>
18:51:58 <AStorm> dons, is that a server or just the lib? :-)
18:52:04 <dons> not sure
18:52:04 <AStorm> I meant a full server.
18:52:07 <dons> just a lib I guess
18:52:48 <AStorm> I can see just HappS
18:53:41 <AStorm> Ahh, HaskellNet
18:54:15 <sorear> dons: in that microbenchmark you showed me, I think the strings were being packed in the time window (laziness)
18:54:45 <dons> sorear: yeah
18:54:52 <dons> good point
18:54:54 * dons tries again
18:55:11 <nornagon> where's the lambdabot source? seems goa wants it.
18:55:18 <sorear> I also think we need a PackedShortString lib
18:55:27 <mauke> @where lambdabot
18:55:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:55:49 <sorear> pascal-or-c-strings, let's not waste a full int + lots o FFI calls for 3 letter strings
18:56:34 <AStorm> Data.ByteString?
18:57:29 <sorear> I want to replace (SPECIALIZE really) Data.ByteString
18:57:52 <sorear> DbS is good for multi-kb strings
18:57:55 <dons> most bytestrings are stored on the heap and invoke no ffi calls though
18:58:16 <dons> but yeah, they're more oriented to large strings
18:58:37 <dons> if you had lots and lots of small strings, a shared symbol table FastString library would be more efficient
18:58:44 <sorear> ooh, didn't know, (should actually look at the code some day)
18:58:45 <dons> (ie. as ghc uses)
18:59:26 <nornagon> heh, i love the lambdabot icon thingy
18:59:47 <sorear> it's from the south-park contest
18:59:54 <sorear> @topic-tell #haskell-blah
18:59:55 <lambdabot> Anything BUT Haskell (even SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first works: "Ooh, functional programmers are so
18:59:55 <lambdabot> hot" -|- current topic: "Happy Christmas and Merry Newyear and all that shit."
19:01:35 <dons> sorear: so how's the @seen fix coming along?
19:01:42 <dons> not getting side tracked reimplementing the entire world?
19:01:43 <dons> :)
19:02:12 <sorear> oh, right
19:02:38 <sorear> getting caught on converting everything to bytestring
19:02:54 <nornagon> Copying patch 6 of 398... :|
19:03:14 <dons> sorear: focus! as shapr says :)
19:03:32 <nmessenger> nornagon, do you have a copy of ghc 6.4?  I think lambdabot won't build on 6.6 yet.
19:03:46 <sorear> nornagon: future gets are a lot faster if you do a full get first :)
19:04:05 * sorear has several (hardlinked) full LB repos
19:04:19 <nornagon> nmessenger: um.
19:04:22 <nornagon> hm.
19:04:40 <sorear> LB builds fine on 6.6
19:04:58 <nmessenger> sorear, doesn't she need hs-plugins?
19:04:59 <sorear> HEAD, however, dies with a fatal warning.
19:05:23 <sorear> nmess: no.  hs-plugins use is optional, and for that matter currently broken.
19:05:36 <sorear> (IOW not default)
19:05:51 <nmessenger> nornagon, nvm then :)
19:05:59 <nornagon> :P
19:06:58 <dons> nmessenger: just grab lambdabot and build it, it builds with 6.6 by default now
19:07:23 <nmessenger> I've grabbed LB, but I've haven't built her yet.  I shall do so now.
19:07:33 <dons> chmod +x build
19:07:35 <dons> ./build
19:07:40 <dons> though you'll need the zlib library first
19:07:43 <dons> ?where zlib
19:07:43 <lambdabot> I know nothing about zlib.
19:07:50 <sorear> ooh, build - never noticed that file!
19:07:55 * nmessenger uses Windows :(
19:08:01 <dons> ?where+ zlib darcs get http://haskell.org/~duncan/zlib
19:08:01 <lambdabot> Done.
19:08:06 * dons wonders how sorear built lambdabot
19:08:07 <sorear> I've been using runhaskell Setup.hs build ...
19:08:12 <dons> heh
19:08:13 <nmessenger> I'll read the README
19:08:17 <dons> but that doesn't build a few oth the things
19:08:40 <dons> nmessenger: hmm. might have a bit of a porting issue (though it has been built on windows before, see alphecar's blog)
19:08:40 <nornagon> gr
19:08:43 <nornagon> darcs failed:  Failed to download URL http://www.cse.unsw.edu.au/~dons/lambdabot/_darcs/patches/20070102112240-1893e-df398702f22733be7de27f74e6cf200fdf49923a.gz
19:08:44 <lambdabot> http://tinyurl.com/ygpjcb
19:08:57 <sorear> oooh, so the directory problems I've noticed were actually cabal brokenness
19:08:58 <dons> nornagon: hcecking...
19:09:17 <nornagon> dons: might be my dodgy connection
19:09:36 <dons> yeah, try again
19:11:07 <dons> $ darcs get http://www.cse.unsw.edu.au/~dons/code/lambdabot
19:11:07 <dons> Copying patch 1423 of 1423... done!
19:11:07 <dons> Applying patch 1423 of 1423... done.
19:11:07 <dons> Finished getting.
19:11:07 <lambdabot> Title: Index of /~dons/code/lambdabot
19:12:02 <syntaxfree> factor looks cool.
19:12:15 <syntaxfree> anyone here has been using it?
19:12:18 <syntaxfree> (even for toy projects)
19:12:54 <nmessenger> C:\blahblah\zlib>runhaskell ./Setup.hs configure
19:12:55 <nmessenger> ...
19:12:59 <nmessenger> Setup.hs: cannot satisfy dependency fps-any
19:13:21 <sorear> @seen Dons
19:13:22 <lambdabot> I haven't seen Dons.
19:13:44 <nmessenger> dons was just talking 2 minutes ago!
19:13:57 <nmessenger> oh, Dons
19:14:10 <dons> nmessenger: let me post a patch for you
19:14:30 <nmessenger> dons, for zlib?
19:15:26 <dons> yeah, here: http://www.cse.unsw.edu.au/~dons/tmp/zlib.patch
19:15:35 <dons> just wget that, and darcs apply to the zlib dir
19:15:47 <nornagon> Setup.hs: cannot satisfy dependency network-any
19:15:47 <dons> it fixes the zlib build for ghc 6.6
19:15:49 <nornagon> :/
19:15:58 <dons> nornagon: i guess you're missing the extralibs library bundle?
19:16:06 <dons> its available from haskell.org/ghc, and just builds with cabal
19:16:17 <dons> should also be in your local package system
19:16:28 <nornagon> i'm running debian unstable
19:16:35 * nmessenger is still using Windows and doesn't have wget :P  He can manage, though
19:16:37 <dons> yep, its in that
19:16:43 <nornagon> package name?
19:16:49 <dons> network something
19:16:55 <dons> look somewhere around hte mtl package
19:17:04 <nornagon> libghc6-network-dev - Haskell network library for GHC
19:17:06 <nornagon> ?
19:17:11 <dons> yeah
19:18:42 <nornagon> hm, apparently wants ghc6-prof as well
19:18:47 <nornagon> what's -prof? >.>
19:18:52 <nmessenger> dons, should I ignore a bunch of 'configure: no <package> found'?
19:18:57 <dons> yep
19:19:05 <dons> that's just cabal being helpful
19:19:50 <sorear> OK, I've changed seen to compulsively lowercase everything ... building, then will test, then send
19:20:04 <dons> great. testing to make sure things work is a good plan!
19:20:14 <dons> did you find any bugs that seem likely to explain the funny numbers?
19:20:21 <dons> @users
19:20:21 <lambdabot> Maximum users seen in #haskell: 304, currently: 276 (90.8%), active: 30 (10.9%)
19:20:37 <dons> so its still 20 too high
19:20:45 <dons> like it missed some parts
19:21:02 * nmessenger realizes that he needs zlib.  He doesn't have a 'zlib.h'.  >.>
19:21:03 <Saizan> nmessenger: there are ports for wget and other nice unix tools :)
19:22:48 <sorear> it does seem as though the exit-routing isn't working correctly, and stale data is appearing...
19:23:45 <sorear> got a bunch of: ....Error parsing state file for: haddock: user error (Codec.Compression.Zlib: incorrect header check)
19:24:06 <sorear> oh nm I didn't compress the state-files
19:24:12 <dons> sorear: yeah. so try pulling the updated state files
19:24:21 <dons> any that mising the header check need compressing
19:24:51 <sorear> I deleted them earlier (in the build dir) so that darcs wouldn't see the changes in my source dir
19:25:02 <sorear> I'm using a symlink-farm for testing
19:25:10 <mauke> so I just ordered my first book on the internets
19:25:18 <orbitz> mauke: what book
19:25:26 <mauke> types and programming languages
19:25:28 <nmessenger> mauke, congrats!  My first (and only) was GEB
19:25:34 <sorear> @seen
19:25:34 <sorear-lambdabot> Lately, I have seen sorear.
19:25:34 <lambdabot> Lately, I have seen Saizan, bucky, dons, mauke, nmessenger, nornagon, orbitz, sorear and syntaxfree.
19:25:39 <sorear> @users
19:25:39 <sorear-lambdabot> Maximum users seen in #haskell: 258, currently: 258 (100.0%), active: 2 (0.8%)
19:25:39 <lambdabot> Maximum users seen in #haskell: 304, currently: 277 (91.1%), active: 31 (11.2%)
19:25:40 <orbitz> i order many books on the internets
19:25:49 <sorear> dons: that look right?
19:25:52 <sorear> @seen Dons
19:25:52 <sorear-lambdabot> Dons is in #haskell. I don't know when Dons last spoke.
19:25:53 <lambdabot> I haven't seen Dons.
19:26:02 <sorear> @seen #Haskell
19:26:02 <sorear-lambdabot> In #Haskell I can see lambdabot, orbitz and sorear.
19:26:02 <lambdabot> In #Haskell I can see nobody.
19:26:08 <sorear> @users #Haskell
19:26:08 <sorear-lambdabot> Maximum users seen in #Haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
19:26:08 <lambdabot> Maximum users seen in #Haskell: 1, currently: 1 (100.0%), active: 0 (0.0%)
19:27:06 <dons> sorear-lambdabot: looks better
19:27:17 <dons> fake channels could get a error msg, rather than bogus numbers?
19:27:51 <sorear> How do you distinguish fake channels? Zeros?
19:28:01 <sorear> @users #Haskell
19:28:02 <sorear-lambdabot> Maximum users seen in #haskell: 258, currently: 258 (100.0%), active: 1 (0.4%)
19:28:02 <lambdabot> Maximum users seen in #Haskell: 1, currently: 1 (100.0%), active: 0 (0.0%)
19:28:27 <sorear> sorear-lambdabot: @quit
19:29:40 <orbitz> why does do let not ahv ea n 'in'?
19:29:56 <dons> less typos!
19:29:59 <mauke> it's implied
19:30:10 <dons> my error correcting algorithms are having trouble :)
19:30:31 <orbitz> mauke: why isn't it implied in any other let statement?
19:30:33 <mauke> we need a @deorbitz
19:30:37 <dons> ah, I parse it now. let x = 1 ; v <- .. -->   let x = 1 in do v <- ...
19:30:51 <dons> orbitz: since other code isn't in a sequential monad
19:30:51 <nmessenger> Likewise, took some effort.  There is no layout to imply it.
19:31:08 <mauke> orbitz: because you need to know where the definition ends and where the rest of the expression starts
19:31:11 <dons> ?. unpl elite why does do let not ahv ea n 'in'?
19:31:12 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
19:31:40 <dons> ?. pl elite why does do let not ahv ea n in (?)
19:31:41 <lambdabot> w |-| y D03z do LEt NOT ahV ea n iN (?)
19:31:44 <dons> close!
19:31:56 <dons> ?. pl elite why does do flip `f` let not ahv ea n in (?)
19:31:57 <lambdabot> (line 1, column 26):
19:31:57 <lambdabot> unexpected "|"
19:31:57 <lambdabot> expecting space or simple term
19:32:35 <dons> sorear: cheers for the patch
19:32:40 <nmessenger> orbitz, the layout of the do block allows the in to be implied over the remaining actions.  There is ordinarily no layout to use, though.
19:33:26 <orbitz> does the do let knwo wby teh column where the 'code' starts and the new varaibles begin?
19:33:39 <nornagon> hm
19:33:44 <nornagon> zlib is not in apt
19:33:49 <nornagon> what do i do?
19:33:49 <dons> ?spell varaibles
19:33:51 <lambdabot> variables variable's variable parables valuables
19:33:52 <bd_> nornagon: zlib1g-dev I think
19:33:55 <nmessenger> ?google zlib
19:33:57 <lambdabot> http://www.zlib.net/
19:33:57 <lambdabot> Title: zlib Home Site
19:34:01 <nornagon> bd_: the haskell version
19:34:04 <bd_> oh
19:34:08 <dons> nornagon: yeah. darcs get
19:34:10 <bd_> ?google zlib haskell
19:34:11 <dons> ?where zlib
19:34:13 <lambdabot> http://haskell.org/~duncan/zlib
19:34:13 <lambdabot> Title: Index of /~duncan/zlib
19:34:13 <lambdabot> darcs get http://haskell.org/~duncan/zlib
19:34:20 <mauke> orbitz: layout inserts ';'
19:34:46 <orbitz> ok
19:34:48 <mauke> do { let { var = def }; ... }
19:34:52 <mauke> ok, and braces
19:35:12 <nornagon> Setup.hs: cannot satisfy dependency fps-any
19:35:13 <nornagon> gr
19:35:23 <dons> nornagon: which ghc do you have?
19:35:26 <nmessenger> I suppose the syntax could be changed so that the 'in' is omitted, and is implied when the layout goes back to the 'let' indentation.
19:35:36 <nornagon> dons: 6.6
19:35:43 <dons> nornagon: grab the zlib.patch file I posted above
19:35:48 <dons> and darcs apply it
19:35:58 <dons> then rebuild zlib
19:35:58 <nornagon> this sure isn't uncomplicated >.>
19:36:11 <dons> zlib is very new, and needs a tiny fix to build with ghc 6.6
19:36:13 <dons> that's all
19:36:18 <nornagon> i see
19:36:24 <nornagon> but all this ought to be in debian :|
19:36:27 <dons> welcome to bleeding edge development
19:36:37 <bd_> nornagon: make a debian package!
19:36:39 <dons> agile yourself up!
19:36:40 <bd_> :)
19:36:42 <nornagon> heh
19:37:00 <dons> I only added zlib support to lambdabot 12 hours ago :)
19:37:14 <nornagon> okay, it finally built
19:37:27 <nmessenger> *grumble* and added a complication to building
19:37:49 <dons> yes, it added 1 dependency
19:37:49 <nornagon> should I install it or can i somehow tell the lambdabot build system where it is?
19:37:58 <dons> install what? zlib?
19:37:59 <dons> yes.
19:38:02 <nornagon> okay.
19:38:10 <dons> runhaskell Setup.lhs install -- or what have you
19:38:12 * nmessenger has basically no experience building things, so ignore his grumblings.
19:38:15 <nornagon> dons: right.
19:38:27 <dons> the zlib binding is a bit too big to inline into lambdabot, imo
19:38:31 <nornagon> okay, cool, lambdabot is building.
19:38:35 <dons> maybe we can get it into the extralibs bundle
19:38:56 <dons> anyway, bring on hackage
19:39:00 <dons> all your libs will belong to it
19:39:06 <nornagon> :P
19:39:13 * nmessenger hums the Zero Wing tune.
19:39:33 <nornagon> it needs a scheme interpreter
19:39:36 <nornagon> ?help scheme
19:39:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:39:48 <nornagon> :P
19:39:51 <orbitz> hrm
19:39:53 * sorear is currently writing a spelling-nazi plugin
19:39:56 * orbitz tries tto hink of osmethign interesting ot write in hskell tomorrow
19:40:14 <nornagon> orbitz: how about buying a new keyboard instead? :)
19:40:28 <orbitz> this one is atteched to my laptop
19:40:37 <nornagon> buy a usb keyboard
19:40:55 <orbitz> i don't know what the problem is, i'm typing fine, all you crazies are hiting the wron gbuttons everywhere
19:41:35 <dons> sorear: a layer over @spell?
19:41:50 <dons> sorear: can you just add it as a @spell-all that maps spell . words ?
19:41:56 <dons> or some thing like that?
19:42:07 <nmessenger> s/some thing/something/ :P
19:42:13 <bd_> ?remember orbitz i don't know what the problem is, i'm typing fine, all you crazies are hiting the wron gbuttons everywhere
19:42:44 <sorear> dons: @spell / @vixen-on crossover
19:42:56 <mauke> ?quote
19:42:57 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
19:43:36 <dons> ?where+ shellac+vty http://www.eecs.tufts.edu/~rdocki01/shellac.html
19:43:37 <lambdabot> Done.
19:43:44 <nmessenger> (>:[) -- < vampire operator
19:44:00 <Saizan> (if you should write a CLI test to show off what your dumb project does, would you just print all the output or insert some readChar here and there to "pause" it?)
19:44:11 <dancor> ?paste
19:44:20 <dancor> what
19:44:22 <dons> dancor: don't worry, 'twasn't your fault ;)
19:44:26 <dancor> hah
19:44:29 <dons> ?bot
19:44:30 <dancor> ?paste
19:44:54 <nmessenger> good timing, though :D
19:44:57 <lambdabot> :)
19:44:59 <lambdabot> http://paste.lisp.org/new/haskell
19:45:11 <dons> ?seen
19:45:17 <lambdabot> Lately, I have seen dancor, dons and nmessenger.
19:45:20 <dons> ?users
19:45:21 <lambdabot> Maximum users seen in #haskell: 304, currently: 261 (85.9%), active: 4 (1.5%)
19:45:22 <nornagon> ?remember nmessenger (>:[) -- < vampire operator
19:45:31 <dons> looks good sorear
19:45:34 <mauke> ?bat
19:45:34 <lambdabot> Maybe you meant: bf bug fact faq ft let map part what
19:45:56 <nornagon> ?fact
19:45:56 <lambdabot> I can not handle empty facts.
19:46:00 <nornagon> ?help fact
19:46:00 <lambdabot> fact <fact>, Retrieve a fact from the database
19:46:00 <dons> ?help fact
19:46:01 <lambdabot> fact <fact>, Retrieve a fact from the database
19:46:06 <dons> ?fact haskell
19:46:06 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
19:46:08 <nornagon> ?fact haskell
19:46:08 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
19:46:10 <dons> heh
19:46:10 <nornagon> darnit
19:46:12 <dons> jinx
19:46:27 <mauke> ?fact norris
19:46:27 <lambdabot> I know nothing about norris
19:46:36 <nmessenger> ?fact Windows
19:46:37 <lambdabot> I know nothing about windows
19:46:37 <nornagon> ?fact dons
19:46:37 <lambdabot> I know nothing about dons
19:46:45 <nornagon> lambdabot doesn't know much.
19:46:52 <nmessenger> ?fact much
19:46:52 <lambdabot> I know nothing about much
19:46:53 <mauke> ?quote
19:46:53 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
19:47:02 <nornagon> Initialising plugins .................................................. done.
19:47:03 <nornagon> lambdabot>
19:47:04 <nornagon> :)
19:47:06 <dons> yay
19:47:08 <SamB> heh
19:47:11 <SamB> @quote
19:47:11 <lambdabot> heatsink says: @pl (\y -> you y off)
19:47:12 <dons> now type: src foldr
19:47:29 <SamB> @pl (\y -> you y off)
19:47:29 <lambdabot> flip you off
19:47:35 <SamB> heh
19:47:51 <SamB> @quote
19:47:51 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
19:48:08 <SamB> hmm. or maybe they find the roman catholic page?
19:48:12 <nmessenger> poop jokes are ALWAYS funny
19:48:17 <SamB> @quote
19:48:17 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
19:48:24 <SamB> hahahahahaha
19:48:36 <nmessenger> ?quote SamB
19:48:36 <lambdabot> SamB says: Because sliced bread gives horribly uninformative error messages?
19:48:51 * nmessenger cackles
19:48:55 <sorear> lol - GHC complained of a typo in the spelling-nazi plugin I just wrote
19:48:59 <mauke> @ghc
19:48:59 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
19:49:02 <orbitz> SamB: hello! i wrote my first haskell program
19:49:04 <newsham> any haskell code for silc yet?  still wanting silc lambdabot.
19:49:15 <sorear> @remember ghc Plugin/Spell.hs:35:31: Not in scope: `spellineNazi'
19:49:33 <SamB> orbitz: hi!
19:49:47 * nornagon giggles.
19:49:58 --- mode: ChanServ set +o dons
19:50:03 <nornagon> where does lambdabot keep its quote database?
19:50:03 --- topic: set to 'The Haskell programming language | Get yourself some cognitive dissonance! | http://haskell.org | Logs at http://tunes.org/~nef/logs/haskell/ | The language of ICFP winners 3 years running' by dons
19:50:07 <seliopou> hmmmm
19:50:09 --- mode: ChanServ set -o dons
19:50:12 <seliopou> new microsoft web page
19:50:14 <nornagon> dons: aw
19:50:16 <sorear> what was the change?
19:50:17 <dons> :)
19:50:17 <nornagon> i liked the []
19:50:22 <orbitz> dons: i think you should add "orbitz wrote his first haskell program today" to teh topic
19:50:23 <sorear> (in the topic)
19:50:25 <orbitz> the world shoudl know
19:50:27 <dons> I know I know. Kinda retro
19:50:37 <SamB> sorear: I'm not sure that really fits the "ghc" category, since it isn't a general error message... but it *is* funny ;-)
19:50:39 <dons> ok. I'll fix the type :)
19:51:00 <nornagon> liftM [] IRC.Channel.Haskell
19:51:04 <nornagon> .Topic
19:51:05 <nornagon> :/
19:51:05 <iulus> orbitz: pretty proud, hey?
19:51:13 <SamB> nornagon: don't we need to make it parse, too?
19:51:23 <orbitz> iulus: well i tonly adds to teh growing evidence that i am amazing
19:51:27 <nornagon> SamB: right :)
19:51:30 * nornagon prods dons 
19:51:37 <iulus> orbitz: haha
19:51:51 <orbitz> iulus: :)
19:51:52 --- mode: ChanServ set +o dons
19:51:56 --- topic: set to '[ "The Haskell programming language" , "Get yourself some cognitive dissonance!" , "http://haskell.org" , "Logs at http://tunes.org/~nef/logs/haskell/" , "The language of ICFP winners 3 years running" ] :: [String]' by dons
19:51:57 <iulus> orbitz: who am I to argue?
19:52:03 <nornagon> also dissidents
19:52:15 --- mode: ChanServ set -o dons
19:52:29 <orbitz> iulus: i'm not sure but you best have some pretty concrete evidence contrary, writing a progrma in haskell is no small task!
19:52:36 <newsham> ?map elite topic
19:52:37 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:52:46 <SamB> orbitz: hmm. and here I was thinking Haskell was cool because even space cadets like me can write programs in it that actually work!
19:52:49 <mauke> orbitz: main = putStr "Hello, world!\n" -- there
19:52:58 <sorear> > 2 + 2
19:53:01 <lambdabot>  4
19:53:11 <nornagon> sorear: :O
19:53:19 <dons> > fix ( (1:) . scanl (+) 1 ) -- sure its a small task. smaller than most!
19:53:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:53:30 <newsham> dons: lambdabot requires both regexp and hs-plugins, right?
19:53:32 <iulus> woah!
19:53:35 <dons> newsham: yeah
19:53:45 <dons> newsham: but not hs-plugins
19:53:46 <newsham> so where do I get regex from?  (usually i get that with ghc-6.6)
19:53:53 <dons> and regex-* is in the core set of ibs
19:54:07 <newsham> not in 6.4.   but no hs-plugins?  so i can just use 6.6
19:54:08 <nornagon> :t fix
19:54:10 <lambdabot> forall a. (a -> a) -> a
19:54:10 <dons> so probabl your package system
19:54:11 <nmessenger> ?. elite topic-tell
19:54:11 <lambdabot> do NO+ xNOw 7hA7 c|-|4nnE1
19:54:19 <dons> newsham: you can just use 6.6
19:54:20 <nmessenger> ?. elite topic-tell #haskell
19:54:20 <lambdabot> [ "7he ha$K31L PR0gRa/\/\/\/\IN9 lAnGu49e" , "9et yoURze|f So/\/\E CO9nItI\/3 dIz$0nANce!" , "H77p://|-|asK31|.0RG" , "l0Gz0rz at |-|++P://7un3$.oRg/~N3f/lo9S/HaSKeL|/" , "T|-|e 14nGuAGe 0ph ICphp
19:54:20 <lambdabot> winN3Rz 3 y3ArS RuNNiNG" ] :: [z7RInG]
19:54:30 <NichardRixon> ew :(
19:54:45 <nornagon> heh
19:54:54 <dons> newsham: use the 6.4 .cabal file if you want that
19:55:01 <nornagon> ?src fix
19:55:01 <lambdabot> fix f = let x = f x in x
19:55:01 <dons> it has a compat layer that doesn't need the regex package
19:55:10 <newsham> but topic :: [String]  !
19:55:53 <newsham> elite :: String -> String
19:56:18 <nmessenger> newsham, @topic-tell :: String
19:56:27 <nmessenger> newsham, @topic-tell :: Channel -> String
19:56:30 <newsham> dons: how does it deal with plugins?
19:56:36 <newsham> static list?
19:56:52 <sorear> yes
19:57:39 <newsham> and if someone wanted to use a diff chat, the IRC.hs is the only thing that needs replacement?
19:57:45 <nmessenger> read . @topic-tell :: Channel -> [String]
19:58:27 <mauke> umm... let's say I deleted a file in the lambdabot directory
19:58:33 <mauke> how do I tell darcs to recreate it?
19:58:46 <nmessenger> wouldn't 'darcs get' do 'er?
19:59:11 <dons> darcs revert Foo.hs
19:59:25 <dons> (no need to go online.)
19:59:41 <newsham> hmm.. it supports xmpp too?
20:00:02 <nmessenger> 'darcs --help' helps :P
20:00:04 <sorear> no
20:00:10 <dons> just stub support for it
20:00:14 <sorear> xmpp is a tiny stub
20:00:41 <newsham> i could really use this on silc.  there are some silc libs that might be easy to FFI to.
20:00:50 <sorear> silc ?
20:01:07 <sorear> what's that ?
20:01:12 <newsham> http://www.silcnet.org/.  like irc, but with crypto.
20:01:14 <lambdabot> Title: SILC Secure Internet Live Conferencing
20:01:40 <sorear> how long can you wait?
20:01:50 <newsham> depends on how lazy I am, I suppose :)
20:01:52 <nornagon> hm, goa isn't working for me
20:02:05 <dons> yeah, I think there's a bug with 6.6
20:02:14 <dons> causing all goa stuff to get unloaded on the first :load or :m
20:02:20 <nornagon> hm
20:02:29 <dons> you can just fire up ./lambdabot though...
20:02:31 <sorear> I'd like to finish my refactors first - and since they are directed at making other protocols easy, you might too :)
20:02:42 <nornagon> dons: that's true... but GOA would be nicer
20:02:48 <dons> yeah
20:02:51 <sorear> (OTOH I have other obligations, and no shortage of personal laziness)
20:02:55 <dons> i've not investigated the problem enough yet
20:02:57 <dons> feel free to dive in
20:02:58 <nornagon> means i don't have to switch between lb and ghci to evaluate things
20:03:04 <nmessenger> :! lambdabot if you're in a pinch
20:03:09 <nornagon> (unless lambdabot can evaluate stuff?
20:03:15 <dons> it can, with hs-plugins
20:03:16 <newsham> sorear: i'll probably just hack at it and if its useful i can think about folding it back when you think its appropriate
20:03:20 <dons> > map (^2) [1..]
20:03:22 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
20:03:28 <nornagon> hm, i get: Loading package base ... linking ... done.
20:03:28 <nornagon> module main:GOA is not loaded
20:03:35 <nornagon> when i run ghci
20:03:38 <newsham> can always reimplement if necessary
20:03:53 <dons> yeah, it might be simpler to revert goa to use a non-persistent mode
20:04:09 <dons> hmm, lambdabot server running locally, anyone?
20:04:11 <sorear> dons: where in AUTHORS should I put myself
20:04:22 <sorear> what do you mean?
20:04:29 <dons> sorear: anywhere you like
20:04:33 <newsham> hmm.. whats fptools path for?
20:04:38 <sorear> I've contemplated adding a builtin webserver to LB :)
20:04:44 <newsham> do I need to grab fptools?
20:04:46 <dons> used to be for the Code plugin, which grepped random lines out of fptools
20:04:49 <dons> newsham: no!
20:04:53 <newsham> *phew*
20:05:00 <dons> @code
20:05:00 <lambdabot> Maybe you meant: more todo vote
20:05:03 <dons> was a little joke
20:05:06 <dons> I don't even use it anymore :)
20:05:30 <dons> ?src fix
20:05:31 <lambdabot> fix f = let x = f x in x
20:05:32 <dons> is better
20:05:33 <newsham> blah  Setup.hs: cannot satisfy dependency unix-any
20:05:34 <dons> :)
20:05:39 <newsham> i have 6.4 on linux and 6.6 on windows :\
20:05:40 <dons> newsham: pkg unix you need
20:05:55 <newsham> my linux box 6.6 crashes (unless not built for threads)
20:05:56 <dons> which isn't on windows...
20:06:00 <nornagon> how, how do i make goa work? :(
20:06:11 <newsham> so i'm stuck on 6.4
20:06:20 <dons> nornagon: ./lambdabot
20:06:26 <nornagon> dons: D:
20:06:30 <newsham> can I grab the regex stuff for 6.4 somehow?
20:06:34 * dons feels like a support desk sometimes
20:06:46 <dons> newsham: you don't need it. use the lambdabot.cabal.ghc-6.4 file
20:06:47 <newsham> sorry :(
20:06:54 <dons> mv lambdabot.cabal.ghc-6.4 lambdabot.cabal
20:06:56 <dons> and build
20:07:01 <newsham> ah! didnt see that!
20:07:44 <sorear> dons: patches sent { @nazi-{on,off}, AUTHORS block }
20:07:54 <dons> sorear: hehe :)
20:07:55 <dons> nice
20:08:16 <AStorm> sorear, what does that use? aspell?
20:08:26 <sorear> yes
20:08:37 <sorear> shares most of the code with @spell
20:08:50 <sorear> basically I ported @vixen-on to the Spell plugin
20:09:15 <dons> yeah
20:09:26 <dons> makes me think this on/off functionality should be built into every plugin
20:09:38 <dons> as well as a standard way to lift a plugin to contextual
20:10:05 <newsham> Setup.hs: got error code while preprocessing: Codec.Compression.Zlib.Stream
20:10:13 <dons> you got zlib.h ?
20:10:14 <newsham> (trying to build the zlib package)
20:10:29 <newsham> /usr/lib/zlib.h
20:10:37 <newsham> err.. include
20:11:30 <sorear> @nazi is _slightly_ more sophisticated than just run-@spell-on-lines.
20:11:30 <lambdabot> Unknown command, try @list
20:11:37 <newsham> oh crap, its using the wrong version of ghc for some reason
20:11:45 <sorear> no its not
20:11:54 <newsham> yes it is.
20:11:57 <sorear> ignore autoconf's whining
20:12:06 <newsham> command was: /usr/local/bin/ghc-6.6 -c Codec/Compression/Zlib/Stream_hsc_make.c -o Codec/Compression/Zlib/Stream_hsc_make.o
20:12:10 <sorear> Cabal is telling the truth
20:12:12 <newsham> my ghc-6.6 is bad.
20:12:29 <newsham> my ghc is ghc-6.4
20:12:38 <sorear> configure -w ?
20:13:46 <newsham> -w /usr/local/bin/ghc ?
20:13:57 <sorear> yes
20:14:01 <newsham> same thing.
20:14:17 <sorear> /usr/bin/ghc ?
20:14:33 <newsham> no, /usr/local/bin/ghc is 6.4
20:14:37 <newsham> i backed out of 6.6
20:14:42 <newsham> manually.. perhaps i goofed somehow
20:14:49 <newsham> but omstly it works (ghc, ghci, etc)
20:14:55 <mauke> try both -w and --with-ghc=
20:16:30 <newsham> Setup.hs: Unrecognised flags: --with-ghc=/usr/local/bin/ghc
20:16:51 <newsham> i removed all my 6.6 files onw and its still trying ot use them (even after reconfigure)
20:18:01 <sorear> dons: on the Wiki Version I'm amazed it takes 3k cycles to build a thunk
20:18:11 <glguy> Is "scrap your boiler plate" / Data.Generics "typesafe"?
20:18:17 <glguy> at compile time
20:18:40 <dons> sorear: there's 800 cycles in the ffi call though
20:18:52 <dons> (try to rsdtc in a row)
20:18:54 <dons> two
20:19:04 <dons> glguy: yeah, I think so
20:19:06 <dons> :)
20:19:16 <newsham> oops.. hsc2hs referencing 6.6 still
20:19:26 <dons> you imagining a segfault due to hitting a non-Typeable value at runtime?
20:19:56 <sorear> it's safe - you'll get a Nothing if the types are incompatible
20:20:16 <glguy> so it's dynamic typing then, right/
20:20:22 <sorear> if fromJust . cast fails, it's your fault
20:20:23 <sorear> yes
20:21:01 <glguy> so... kind of like programming in ruby or something?
20:21:24 <sorear> Haskell allows dynamic typing, but doesn't force the whole language to be poisoned by it.
20:21:38 <glguy> o
20:21:39 <glguy> k
20:21:59 <newsham> *sigh* now real compiler errors -- Stream.hsc:495: error: `Z_FIXED' undeclared (first use in this function)
20:22:00 <sorear> I'd more compare it to clasical Lisp, but then I've never seen ruby :)
20:22:14 <sorear> "funny, it worked for me"
20:22:30 <sorear> Is zlib-dev installed?
20:23:00 <newsham> zlib-1.2.1.1-2.1
20:23:00 <newsham> zlib-devel-1.2.1.1-2.1
20:23:15 <dons> sorear: does the spelling nazi plugin work from the console ?
20:23:19 <dons> !nazi-on
20:23:22 <dons> !test
20:23:22 <sorear> yes
20:23:23 <newsham> no Z_FIXED in my headers
20:23:25 <dons> for example?
20:23:32 * dons wonders what's going on then
20:23:36 <dons> newsham: needs a newer zlib
20:23:37 <sorear> lambdabot> nazi-on   lambdabot> !foo
20:23:42 <dons> (just updating the header is enough
20:23:51 <sorear> @nazi-on is a command, not a contextual
20:23:51 <lambdabot> Unknown command, try @list
20:23:58 <dons> its handing me blank lines back
20:24:00 <dons> hmm
20:24:26 <newsham> is there a way to specify which path to use for getting zlib headers and libs?
20:24:35 <sorear> uh, I thought that's what it was supposed to do when the plugin gave no text (to avoid sync lockups)
20:24:46 <dons> ah hehe
20:24:52 <dons> if the sentence is correct you get no output
20:25:07 <sorear> correct
20:25:28 <sorear> it also only gives output for the first misspelt word - less spam
20:25:42 <dons> yep
20:25:43 <dons> good
20:26:07 <seliopou> misspelled
20:26:26 <dons> ?spell misspelt
20:26:26 <lambdabot> miss pelt miss-pelt misspell misspent misspelled
20:26:33 <newsham> does cabal have a cmd line switch to specify an include path and library path?
20:26:38 <dons> ?spell spelt
20:26:39 <lambdabot> splat split pelt spell smelt
20:26:48 <sorear> newsham: ./Setup.lhs --help
20:27:00 <newsham> yah, thats not nearly as useful as you would hope, sorear :(
20:27:03 <dons> newsham: you can add paths to C libs by hacking CPPFLAGS and LDFLAGS, or tweaking ghc-options:
20:27:24 <newsham> oh! nevermind
20:27:42 <nornagon> lambdabot> > hi
20:27:43 <nornagon> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
20:27:59 <dons> no runplugs/hs-plugins with ghc 6.6
20:28:11 <dons> tyr:   lambdabot> bot
20:28:13 <sorear> try djinn a -> a
20:28:20 <nornagon> okay.
20:28:23 <dons> > hi
20:28:24 <lambdabot>   Not in scope: `hi'
20:28:46 <nornagon> is this lambdabot running on ghc 6.4?
20:28:47 <newsham> fuck it, i'll just do it the hack way.
20:29:15 <glguy> ?version
20:29:16 <lambdabot> lambdabot 4p398, GHC 6.5 (OpenBSD i386)
20:29:16 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:30:08 <sorear> is the number after p the count of patches since the 4.0 tag ?
20:30:13 <dons> yeah
20:30:16 <newsham> what do I need to get Codec.Compression.GZip?  I installed the zlib package
20:30:25 <sorear> nothing
20:30:38 <newsham> Could not find module `Codec.Compression.GZip':
20:30:54 <sorear> next line please (does it say hidden?)
20:31:06 <newsham>   use -v to see a list of the files searched for
20:31:06 <dons> did you build and install the haskell zlib library with your current ghc?
20:31:15 <newsham> yup, just built and installed it
20:31:25 <newsham> shows up in ghc-pkg -list
20:31:52 <dons> ah, maybe the .cabal file you're using doesn't have zlib in the build-depends: ?
20:32:23 <dons> ?version
20:32:48 <nornagon> ... :)
20:32:51 <lambdabot> lambdabot 4p401, GHC 6.5 (OpenBSD i386)
20:32:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:33:03 <newsham> dons: that was it.   the 6.4 cabal didnt have zlib.
20:33:08 <sorear> @nazi-on
20:33:08 <lambdabot> Spelling nazi engaged.
20:33:11 <newsham> (for lambdabot)
20:33:11 <lambdabot> Did you mean lambda bot, lambda-bot, lambda, lambdas or lambda's?
20:33:17 <nornagon> heh
20:33:18 <lambdabot> Did you mean He, he, eh, HRH or Hew?
20:33:23 <nmessenger> stopit!
20:33:23 <sorear> That will need fixing
20:33:24 <lambdabot> Did you mean stop it, stop-it, stupid, Stout or stout?
20:33:38 <nmessenger> needs more sass.
20:33:40 <dons> ?spell-all it also only gives output for the first misspelt word          
20:33:41 <lambdabot> Did you mean miss pelt, miss-pelt, misspell, misspent or misspelled?
20:33:45 <dons> sorear: better turn it off
20:33:46 <lambdabot> Did you mean sorer, soarer, sourer, so rear or so-rear?
20:33:49 <sorear> @nazi-off
20:33:50 <lambdabot> Spelling nazi disengaged.
20:33:55 <newsham> did you mean st0p 1t, stoP-1+, stUp1t, st0U+ or s+0ut
20:33:55 <dons> probably goeson in*all* channels too eh?
20:33:59 <dons> i.e. even perl6?
20:34:12 <dons> ?seen lambdabot
20:34:13 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
20:34:20 <sorear> uh, probably
20:34:36 <newsham> sweet, lambdabot building now.
20:37:27 <newsham> Plugin/Seen.hs:218:18: Overlapping instances for Binary (Data.Map.Map String Int)
20:38:58 <dons> that's ok
20:39:14 <dons> unless  I didn't record my -fallow-overlapping-instances patch?
20:39:32 <dons> should be at the top of Lib/Binary.hs:  {-# OPTIONS -cpp -fasm -fallow-overlapping-instances #-}
20:39:48 <newsham> thats there.
20:40:03 <dons> sorear: so now log files are written with quotes in the names?
20:40:14 <dons> manzano$ ls -t1  |head
20:40:15 <dons> "#perl6"
20:40:15 <dons> "#jtiger"
20:40:15 <dons> "#haskell.hac07"
20:40:15 <dons> "#gentoo-uy"
20:40:20 <dons> is this a feature?
20:41:04 <glguy> ?where stats
20:41:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
20:42:14 <newsham> dons: if I add options to the head of Seen.hs it goes away.
20:42:23 <newsham> is that a 6.4 vs. 6.6 thing?
20:42:33 <dons> msut be
20:42:42 <dons> thank for the report, i'll try to nail that
20:43:50 <dons> so	     where dir  = outputDir config </> "Log" </> host config </> show chan
20:44:03 <dons> sorear: looks fishy :)
20:44:13 <sorear> yeah
20:44:48 <sorear> I used seen because I needed the server name, totally forgot about the quotes
20:45:27 <sorear> actually the quotes are generated with show :: String -> String, so read :: String -> String would remove them properly
20:46:03 <nornagon> > read "\"foo\""
20:46:05 <lambdabot>  Add a type signature
20:46:08 <dons> yeah
20:46:08 <nornagon> > read "\"foo\"" :: String
20:46:10 <lambdabot>  "foo"
20:46:30 <nmessenger> ?read "foo"
20:46:30 <dons> but maybe there's a better way to show the channel name?
20:46:30 <lambdabot>  foo
20:46:36 <sorear> I wonder if this (externalizing but without adding quotes) is a common enough need that an exported function should be added to Message?
20:46:44 <dons> maybe
20:46:48 <dons> is there a field to grab it?
20:46:58 <sorear> Msg.nName
20:47:25 <sorear> *but* you want to distinguish different channels with the same name and different servers
20:47:52 <dons> yeah, so server.chan would be reasonable for log files
20:48:04 <sorear> If showNick took a String rather than a Message showNick would work
20:48:13 <sorear> Msg.nTag is the server
20:48:32 <sorear> should I change that to use server.chan?
20:49:16 <dons> well, I think we need to consider how to write logs
20:49:23 <dons> and putting them in Log/server-chan
20:49:24 <dons> would be ok
20:49:31 <dons> or something similar
20:49:44 <dons> leaving them as is, but without the quotes would be ok too, for now
20:49:56 <dons> (i do have a use for running on multiple servers)
20:50:17 <sorear> fn-#haskell or fn.#haskell ? (you just proposed both)
20:50:44 <dons> well, we have #haskell.hac07
20:50:55 <dons> so maybe: freenode.#haskell.hac07
20:50:57 <dons> or ...
20:51:03 <dons> freenode/#haskell
20:51:17 <dons> so that needs thinking about.
20:51:22 <dons> we have irc.freeenodeorg/#haskell
20:51:25 <dons> atm
20:51:46 <dons> i'd forgotten we already handle servers in this way
20:52:34 <sorear> so maybe it should just be tag/channel?
20:53:02 <nmessenger> there's irc://server:port/channel
20:53:10 <sorear> (or perhaps we should ditch the abbreviated 'tags' and just add an alias dictionary to readNick)
20:53:27 <dons> sorear: yeah, I'd like:   server/channel
20:53:38 <dons> tags are really only for the irc user, I think
20:54:10 <dons> we probably should just use the shorthand tags irc already provides, i.e. 'freenode' for irc.freenode.org
20:54:12 <sorear> ah, so maybe there should be a long-name field in the eventual VCS
20:54:55 <sorear> so because it defaults to the current server, using the full server basename is acceptable ?
20:56:09 <newsham> ./Modules.hs: file name does not match module name `Main'
20:56:17 <newsham> (when runnin ghci Main.hs as per README)
20:56:58 <dons> sorear: yeah
20:57:12 <dons> newsham: hmm. you mean: sh ghci Main.hs ?
20:57:37 <dons> $ sh ghci Main.hs
20:57:38 <dons> Make sure you've done a full compiled build recently
20:57:38 <dons>    ___         ___ _
20:57:39 <dons> ...
20:57:43 <dons> Prelude Main> :t main
20:57:43 <dons> main :: IO ()
20:57:47 <newsham> oh.. blah.
20:58:00 <newsham> sorry dons
20:58:04 <dons> you're running the ./ghci script
20:58:11 <dons> which sets up some flags
20:58:22 <newsham> Initialising plugins ..........Plugin.Djinn: couldn't find djinn binary
20:58:22 <newsham> .......................*** Exception: exit: ExitFailure 1
20:59:06 <dons> no ./djinn ?
20:59:39 <newsham> hrmm.. weird.. i ran dist/build/lambdabot/lambdabot earlier and it complained about djinn but it still ran, now it exits immediately
21:00:34 <newsham> removed State and reran and it runs now
21:00:50 <newsham> (although complained about djinn missing still, but I dont care so much about that)
21:01:36 <dons> ah ok.
21:02:25 <newsham> how do I run haskell commands at the prompt?
21:02:28 <Elifant> @paste
21:02:29 <lambdabot> http://paste.lisp.org/new/haskell
21:05:11 <nornagon> ?ft \a -> a == 1 :: Int
21:05:13 <lambdabot>  ft: scripts/FT/FTbase.hs:211:16-29: Irrefutable pattern failed for pattern (w : ws)
21:05:26 <reilly> I'm having a (I hope) fairly simple problem building hs-plugins.  I'm running ghc-6.6 on my macbook pro.  It's barfing on the first line of the form INSTANCE_TYPEABLE1(.....).  It's complaining about an indent problem, but it looks to me as if INSTANCE_TYPEABLE1 isn't defined.  Typeable.h defines INSTANCE_TYPEABLE0, but nothing else.
21:05:57 <newsham> how did you build hs-plugins for 6.6?
21:06:10 <reilly> i'm trying to build it
21:06:24 <newsham> hs-plugins not yet ready for 6.6
21:06:25 <lisppaste2> Elifant pasted "Using 'Either' with 'ErrorT'" at http://paste.lisp.org/display/34113
21:06:27 <Elifant> I want exception from 'get1' to automatically propagate as exception from 'process', but the program doesn't even compile. What should I modify?
21:06:30 <reilly> ahh
21:07:26 <reilly> my desire to build hs-plugins came because I want to run GHC on Acid, which depends on lambdabot, which depends on hs-plugins
21:07:39 <reilly> yak shaving
21:08:01 <TSC> Is there a simple way to get the binary representation of an integer?
21:08:11 <sorear> yes, id :)
21:08:17 <TSC> Ho ho ho
21:08:22 <dons> reilly: hs-plugins won't work with ghc 6.6. lambdabot doesn't need hs-plugins
21:08:24 <TSC> As a string (:
21:08:46 <nmessenger> reilly, dons told me that hs-plugins is optional for LB
21:09:14 <reilly> thanks ... cabal wanted me to have it
21:09:17 * nmessenger should read before pressing 'Enter'
21:09:48 <dons> > showIntAtBase 2 id (42 :: Integer) []
21:09:50 <lambdabot>  Couldn't match `Char' against `Int'
21:10:11 <sorear> > fix (\f n -> case n of 0 -> "0" ; 1 -> "1" ; x = f (x `div` 2) ++ show (x `mod` 2)) 131
21:10:11 <lambdabot>  Parse error
21:10:13 <dons> > showIntAtBase 2 chr (42 :: Integer) []
21:10:15 <lambdabot>  "\SOH\NUL\SOH\NUL\SOH\NUL"
21:10:30 <TSC> @type showIntAtBase
21:10:31 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> ShowS
21:10:32 <seliopou> Data.Bits?
21:10:43 <sorear> > showIntAtBase 2 (chr . (+48)) (42 :: Integer) []
21:10:43 <nmessenger> ?index showIntAtBase
21:10:44 <lambdabot>  "101010"
21:10:44 <lambdabot> Numeric
21:11:08 <seliopou> ?src showIntAtBase
21:11:09 <lambdabot> Source for this function is not available.
21:11:13 <dons> ?hoogle digit
21:11:15 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
21:11:15 <lambdabot> Char.digitToInt :: Char -> Int
21:11:15 <lambdabot> Char.intToDigit :: Int -> Char
21:11:17 <sorear> > showIntAtBase 2 (head . show) (42 :: Integer) []
21:11:18 <lambdabot>  "101010"
21:11:29 <sorear> what, +48 too obscure :)
21:11:41 <dons> > showIntAtBase 2 digitToInt (42 :: Integer) []
21:11:42 <TSC> Ah, thanks everyone, that's perfect
21:11:42 <lambdabot>  Couldn't match `Char' against `Int'
21:11:51 <dons> > showIntAtBase 2 intToDigit (42 :: Integer) []
21:11:53 <lambdabot>  "101010"
21:12:12 <dons> let showBinary n = showIntAtBase 2 intToDigit (n :: Integer) []
21:12:16 <dons> > showBinary 255
21:12:17 <lambdabot>   Not in scope: `showBinary'
21:12:23 <dons> ?let showBinary n = showIntAtBase 2 intToDigit (n :: Integer) []
21:12:24 <lambdabot> Defined.
21:12:27 <dons> > showBinary 255
21:12:29 <lambdabot>  "11111111"
21:12:34 <olliej> :t showBinary
21:12:36 <lambdabot> Not in scope: `showBinary'
21:12:41 <olliej> :(
21:12:42 <TSC> :t L.showBinary
21:12:44 <lambdabot> Couldn't find qualified module.
21:12:48 <dons> > showBinary (10^6 - 7)
21:12:49 <lambdabot>  "11110100001000111001"
21:12:58 <nmessenger> > show (typeOf showBinary)
21:13:00 <lambdabot>  "Integer -> [Char]"
21:13:01 <nmessenger> :D
21:13:05 <dons> :)
21:13:10 <dons> > showBinary (10^32 - 7)
21:13:11 <lambdabot>  "100111011100010110101101101010000010101101110000101101011001110111110000000...
21:13:16 <olliej> > showBinary (2^42)
21:13:17 <lambdabot>  "1000000000000000000000000000000000000000000"
21:13:20 <olliej> :D
21:13:41 <seliopou> > length $ showBinary (2^42)
21:13:42 <lambdabot>  43
21:13:58 <nmessenger> how does one ?type an ?let'ed name?
21:13:58 <Elifant> can anybody help me with my stupid question?..
21:14:12 <nmessenger> Elifant, that's why we're here!
21:14:17 <dons> nmessenger: one doesn't yet, other than with typeOf
21:14:19 <Elifant> <lisppaste2> Elifant pasted "Using 'Either' with 'ErrorT'" at http://paste.lisp.org/display/34113
21:14:19 <Elifant> <Elifant> I want exception from 'get1' to automatically propagate as exception from 'process', but the program doesn't even compile. What should I modify?
21:14:37 <nmessenger> ?let showType = show . typeOf
21:14:39 <lambdabot> <local>:5:18:     Ambiguous type variable `a' in the constraint:       `Typea...
21:14:55 <mbishop> bugs!
21:15:08 <seliopou> elifant, what are you trying to do with the num <- get1 line?
21:15:52 <Elifant> if 'get1' returns Left, then return error from 'process', if Right, get returned number in 'num'
21:16:33 <seliopou> @hoogle Either
21:16:34 <lambdabot> Prelude.Either :: data Either a b
21:16:34 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
21:16:44 <seliopou> ?src Either
21:16:44 <lambdabot> Source for this function is not available.
21:16:58 <seliopou> is there a command that links you to the docs?
21:17:26 <seliopou> Either is not an instance of Monad
21:17:45 <Elifant> ?
21:17:47 <nmessenger> ?docs Data.Either
21:17:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
21:17:54 <seliopou> thanks, nmessenger
21:18:20 <glguy> Either String and Either IOError are instances of monad
21:18:31 <nmessenger> ?instances Monad
21:18:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:18:42 <dons> csae foo of Left s -> error s ; Right n -> return n
21:18:45 <dons> omething like that?
21:18:56 <seliopou> Ah
21:18:56 <glguy> Left is a labeled Nothing
21:18:59 <glguy> Right is a Just
21:19:27 <seliopou> where are those?
21:19:35 <glguy> Control.Monad.Error probably
21:19:47 <seliopou> ?docs Control.Monad.Error
21:19:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
21:19:54 <Elifant> dons: yes, I known how to propagate error manually, but aren't monads for doing it automatically?
21:20:15 <Elifant> I thought I've missed something simple...
21:20:16 <dons> yeah, import the Error monad
21:20:32 <dons> do x <- foo ; will call fail if you return a Left
21:20:33 <glguy> instance (Error e) => Monad (Either e) where return        = Right Left  l >>= _ = Left l Right r >>= k = k r fail msg      = Left (strMsg msg)
21:20:46 <dons> ?src Either >>=
21:20:47 <lambdabot> Left  l >>= _ = Left l
21:20:47 <lambdabot> Right r >>= k = k r
21:20:47 <Elifant> it is imported, isn't it? 'import Control.Monad.Error'
21:21:20 <glguy> ?fptools Control.Monad.Instances
21:21:21 <lambdabot> Control.Monad.Instances not available
21:21:57 <nmessenger> ?instances Error
21:21:58 <lambdabot> IOError, [Char]
21:21:59 <Elifant> I just want to mix 'ErrorT String IO t' and 'Either String t' to automatically handle errors, and I can't do it...
21:22:27 <dons> just use ErrorT then
21:22:42 <Elifant> for 'get1' function?
21:22:52 <nmessenger> ErrorT is an Either in a fancy dress.
21:23:29 <Elifant> ye, but it is just workaround. 'ErrorT String Identity t' is ugly and requires 'runIdentify'
21:23:31 <glguy> --   type ErrorWithIO e a = ErrorT e IO a
21:23:31 <glguy> --	==> ErrorT (IO (Either e a))
21:24:58 <seliopou> MTV is rotting my brain
21:27:50 <sorear> dons: so you want the tag for freenode changed from "fn" to "freenode" ?
21:28:04 <glguy> fn smells like function
21:28:12 <glguy> (but I am aware of what you are refering to)
21:29:14 <glguy> is there a one sentence explaination of what undecidable instances are?
21:29:29 <glguy> that isn't a reflexive definition :-p
21:30:30 <ptolomy> > let boog = 1 : 1 : map succ (tail boog) in take 10 boog
21:30:32 <lambdabot>  [1,1,2,3,4,5,6,7,8,9]
21:30:50 <sorear> undecidable instances is a GHC term for instance definitions not satisfying the normal GHC restrictions.
21:32:04 <glguy> relating to fundeps?
21:32:26 <sorear> it's in the Users Manual
21:32:35 <sorear> no, not specifically fundeps
21:34:07 <Elifant> my problem is solved by introducing 'liftThrows :: (Monad m, Error e) => Either e v -> ErrorT e m v' and using 'num <- liftThrows $ get1'. tnx all.
21:34:40 <Elifant> I just wonders why there is no such thing in standard libraries...
21:34:52 <glguy> I was wondering why there was no liftModify earlier
21:34:58 <shapr> SHAZAM!
21:35:45 <glguy> ended up with: modifyM f = put =<< f =<< get; liftModify f = modifyM (lift . f)
21:38:32 <moconnor> Are there binary packages for GHC on Intel OS X Tiger?
21:38:47 <rashakil> yes
21:40:19 <moconnor> oh, google brought me to an old version of GHC
21:40:27 <moconnor> I see it now.
21:41:24 <glguy> Does OSXx86's rosetta support the bsd layer? or just the objc layer?
21:41:35 <glguy> objc + cocoa
21:41:51 <glguy> err carbon!
21:41:52 <glguy> :)
21:42:07 <dgoldsmith> Rosetta works at all levels in OS X, including BSD.
21:42:21 <glguy> so does the ghc ppc work for intel users then?
21:42:37 <dgoldsmith> It works for ghci, but not for compiling.
21:42:42 <glguy> ah, OK
21:43:18 <dgoldsmith> ghc fails because it tries to pass ppc code to the Intel assembler.
21:43:26 <glguy> well... at least that helps blunt the pain of having a last generation powerbook
21:44:02 <dgoldsmith> 6.6 is available for both PPC and Intel...
21:44:32 <glguy> :-/ thanks for that
21:44:35 <glguy> q-:
21:45:10 <dgoldsmith> One correction: Rosetta doesn't work for kernel extensions, but it works for anything that runs at user level.
21:54:24 <dons> ?users
21:54:25 <lambdabot> Maximum users seen in #haskell: 304, currently: 256 (84.2%), active: 15 (5.9%)
21:56:58 <sorear> wrt patchbundle: is that what you had in mind?
21:58:13 <dons> yeah, i like thta
22:01:30 <olliej> dgoldsmith: another correction
22:01:38 <olliej> dgoldsmith: it only supports up to the G4
22:01:50 <olliej> dgoldsmith: eg. no 64bit PPC
22:02:00 <dgoldsmith> Right
22:02:06 <olliej> dgoldsmith: but surely everyone has a mac pro now :D
22:02:16 <dgoldsmith> Well, that would be nice...
22:02:17 * olliej <3's his mac pro
22:02:37 <dgoldsmith> envies olliej's mac pro ;)
22:03:03 <olliej> dgoldsmith: to rub salt in the wound: i got a 25% discount on it :D
22:21:37 <dibblego> @pl let f m = map (uncurry X) (toList m)
22:21:38 <lambdabot> (line 1, column 37):
22:21:38 <lambdabot> unexpected end of input
22:21:38 <lambdabot> expecting variable, "(", operator, ";" or "in"
22:21:45 <dibblego> @pl map (uncurry X) (toList m)
22:21:46 <lambdabot> map (uncurry X) (toList m)
22:22:21 <nornagon> ?pl \m -> map (uncurry X) (toList m)
22:22:22 <lambdabot> map (uncurry X) . toList
22:22:55 <nornagon> @pl \y -> let x = map in x x y
22:22:55 <lambdabot> map map
22:23:16 <dibblego> ta
22:23:18 <nornagon> @pl \y -> let x = map in x y x
22:23:18 <AStorm> ?pl f m X = map (uncurry X) (toList m)
22:23:19 <lambdabot> flip join map . flip id
22:23:19 <lambdabot> f = flip (map . uncurry) . toList
22:24:20 <AStorm> ?pl f X m = map (uncurry X) (toList m)
22:24:21 <lambdabot> f = (. toList) . map . uncurry
22:25:08 <TSC> How can I get the smallest integer x such that x * x <= n ?  Like (floor $ sqrt n), except that doesn't type
22:25:47 <AStorm> sqrt fromIntegral n < floor x, right?
22:26:48 <AStorm> Ah, no ;-)
22:27:06 <SamB_XP> that doesn't typecheck!
22:27:18 <AStorm> > floor sqrt 3.5
22:27:20 <lambdabot>        add an instance declaration for (RealFrac (a -> a), Integral (t -> a1)...
22:27:25 <AStorm> > floor $ sqrt 3.5
22:27:27 <lambdabot>  1
22:27:37 <AStorm> What doesn't type? :P
22:27:49 <TSC> :t floor $ sqrt 3.5
22:27:51 <lambdabot> forall b. (Integral b) => b
22:27:55 <TSC> Hmm, that's odd
22:28:09 <AStorm> :t f n = floor $ sqrt n
22:28:10 <lambdabot> parse error on input `='
22:28:47 <AStorm> > let bound = floor . sqrt in bound 10.5
22:28:49 <lambdabot>  3
22:29:10 <TSC> :t floor $ sqrt (3::Integer)
22:29:12 <lambdabot>     No instance for (RealFrac Integer)
22:29:12 <lambdabot>       arising from use of `floor' at <interactive>:1:0-4
22:29:16 <AStorm> > let bound = floor . sqrt in bound 9
22:29:18 <lambdabot>  3
22:29:26 <TSC> That's what doesn't type, so I need fromInteger
22:29:34 <TSC> floor $ sqrt (fromInteger (3::Integer))
22:29:36 <TSC> > floor $ sqrt (fromInteger (3::Integer))
22:29:38 <AStorm> No, you don't.
22:29:38 <lambdabot>  1
22:29:53 <TSC> I think I do...
22:29:55 <AStorm> That'd just limit the type of the function to Integer
22:30:03 <AStorm> :t floor . sqrt
22:30:06 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
22:30:14 <TSC> That's ok, it's already an Integer
22:30:15 <nornagon> :t sqrt
22:30:18 <lambdabot> forall a. (Floating a) => a -> a
22:30:23 <AStorm> :t (floor . sqrt)
22:30:26 <lambdabot> forall b a. (RealFrac a, Integral b, Floating a) => a -> b
22:30:59 <AStorm> So, it takes a Floating value. Integer should be convertible to it... hmm.
22:31:07 <nornagon> > 1 :: Floating
22:31:08 <lambdabot>      Class `Floating' used as a type
22:31:08 <lambdabot>     In the type `Floating'
22:31:08 <lambdabot>     In an exp...
22:31:10 <nornagon> er.
22:31:16 <nornagon> > 1 :: Double
22:31:16 <AStorm> > 1 :: RealFrac
22:31:18 <lambdabot>  1.0
22:31:18 <lambdabot>      Class `RealFrac' used as a type
22:31:19 <lambdabot>     In the type `RealFrac'
22:31:19 <lambdabot>     In an exp...
22:31:25 <AStorm> > 1 :: Float
22:31:27 <lambdabot>  1.0
22:31:33 <glguy> anyone have a link to a txt file of primes up to around 60M?
22:31:36 <tibbetts> I'm currently using ghci for development. When I get an error like "*** Exception: Prelude.head: empty list", is there any way to get some kind of backtrace or call stack?
22:31:39 <nornagon> > sqrt 1
22:31:41 <lambdabot>  1.0
22:32:01 <AStorm> tibbetts, a debugger you say? Uh...
22:32:39 <tibbetts> That's crazy talk, eh?
22:32:42 <dons> tibbetts: yeah, there's a number of ways
22:32:55 <dons> you can use 'hat', you can use an assert, or a src located 'head'
22:32:56 <dons> ?where loch
22:32:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/loch.html
22:32:58 <dons> for example
22:33:01 <ray> hat?
22:33:06 <dons> ?where hat
22:33:07 <lambdabot> http://www.haskell.org/hat/
22:33:22 <ray> oh, that
22:33:23 <dons> ghc also now has a code coverage engine
22:33:33 <dons> in the head branch, that gives good back traces (iirC)
22:34:07 <dons> also, compile with -Wall -Werror will tell you when your patterns are partial
22:34:19 <dons> and avoid partial functions unless you have a proof on the side that its safe!
22:35:16 <jcreigh> dons: "partial functions"? Like fromJust or head?
22:35:29 <dons> yeah
22:35:51 <AStorm> head is not actually partial, it just errors out on empty list
22:36:00 <AStorm> ?src head
22:36:01 <lambdabot> head (x:_) = x
22:36:01 <lambdabot> head []    = undefined
22:36:14 <SamB_XP> AStorm: that counts as partial
22:36:16 <dons> looks partially defined to me :)
22:36:23 <dibblego> me too
22:36:41 <AStorm> Anyway, redefine as you see fit
22:37:00 <SamB_XP> just because it covers all cases doesn't mean it is non-partial
22:37:09 <jcreigh> AStorm: well, if "head" isn't partial, what would be an example of a partial function?
22:37:33 <AStorm> Hmm... anything that doesn't define all cases.
22:37:54 <glguy> dons: is there any decent way to read ints from a bytestring?
22:37:56 <ray> but undefined isn't a definition
22:37:56 <AStorm> head does define [] to be error "empty list"
22:38:39 <tibbetts> Those tools look reasonable, but I think I will put off shaving this yak until tomorrow
22:39:04 <dons> glguy: readInt is my preferred method ;)
22:39:14 <glguy> dons: so I have to convert to string first?
22:39:19 <dons> nope
22:39:25 <glguy> ?hoogle readInt
22:39:26 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
22:39:26 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
22:39:26 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
22:39:26 <dons> :t Data.ByteString.Char8.readInt
22:39:29 <lambdabot> Data.ByteString.Base.ByteString -> Maybe (Int, Data.ByteString.Base.ByteString)
22:39:34 <glguy> Pimping
22:39:49 <dons> gives you an Int, and the rest of the bytestring
22:40:21 <AStorm> Which is quite fast.
22:40:53 <glguy> how much faster would that be than a standard (map read . words)`fmap` (readFile "stuff")
22:41:04 <glguy> insanely? noticably? eh?
22:41:09 <dons> insanely, I think
22:41:13 <dons> maybe 10x?
22:41:16 <AStorm> Noticeably for small files.
22:41:21 <AStorm> Insanely for large files.
22:41:21 <glguy> say, 20meg
22:41:23 <glguy> or primes
22:41:27 <glguy> of*
22:41:30 <AStorm> That's insanely :P
22:41:33 <dons> 20M, insanely
22:41:47 <dons> (we use this function for the sum-file test in the shootout)
22:41:53 <dons> and its much much fsater
22:42:50 <AStorm> I really have to write that charset library
22:43:02 <AStorm> :>
22:43:02 <glguy> ?docs Data.ByteString
22:43:04 <lambdabot> Data.ByteString not available
22:43:09 <glguy> ?docs Data.Char
22:43:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
22:43:21 <AStorm> uh, there are docs for the ByteString
22:43:26 <AStorm> ?docs ByteString
22:43:27 <lambdabot> ByteString not available
22:43:32 <glguy> yeah, but I'll just find my way
22:43:35 <glguy> using the other url
22:43:36 <AStorm> Blah, can't find? :P
22:43:59 <dons> yeah, just haven't updated the db
22:44:05 <AStorm> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
22:44:08 <lambdabot> http://tinyurl.com/y58jn8
22:45:22 <AStorm> I wonder why it doesn't support Unicode directly (CInt32 for instance)
22:45:52 <glguy> dons: so just unfoldr readInt myBtyeString?
22:46:05 <dons> yeah, that'd do
22:46:18 <dons> AStorm: you need the Vector bytestring lib for that
22:46:27 <dons> which supports arbitrary Storable values in bytestrings
22:48:09 <AStorm> Hmm, I wonder why cons is O(n)
22:48:24 <AStorm> Can't the ByteString just try to realloc the memory?
22:48:34 <Cale> AStorm: on which structure?
22:48:55 <AStorm> Blah, right, it has to create a copy due to GC
22:49:39 <dons> we do realloc when fusion occurs between fusible bytestring operations
22:49:42 <Cale> It would have to allocate a byte before the existing memory, and always be able to do so in order to make it O(1)
22:49:51 <dons> e.g. filter . map
22:52:54 <AStorm> Well, in case of cons this should be _almost_ always... but that's not good enough for O(1)
22:53:09 <AStorm> Almost - fragmentation can prevent that.
22:54:49 <glguy> ?shootout
22:54:50 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
22:55:39 <glguy> fmap (length . words) (readFile "primes1") is *roughly* 3x faster using Data.List over D.BS.Char8
22:55:43 <glguy> i must be doing this wrong
22:56:31 <glguy> in the interpreter
22:56:41 <glguy> (does bytestring prefer compilation?)
22:56:51 <dons> very very much
22:56:55 <glguy> ok
22:57:02 <mauke> can a dynamically loaded plugin call functions of the host program?
22:57:16 <dons> ome examples for summing a file http://haskell.org/haskellwiki/Shootout/SumFile
22:57:18 <lambdabot> Title: Shootout/SumFile - HaskellWiki
22:57:18 <dons> mauke: yeah
22:57:23 <glguy> dons, you were right
22:57:36 <glguy> dons: compiled -O2 about 6x faster *super rough estimate*
22:57:43 <glguy> than non-bS
22:57:55 <glguy> why is that?
22:58:02 <bos> i see the occasional comment in the mailing list archive cursing fromJust, but i know not why.
22:58:03 <dons> yeah, I'd toss in an -funbox-stricti-fields too (might help)
22:58:07 <mauke> dons: I guess it needs to see an interface file to be compiled then, right?
22:58:31 <dons> mauke: yeah, to know what to call. mauke often its easier to export the functions from the plugin to the host app, and have the hsot app do the calls
22:58:50 <dons> bos: endless source of bugs
22:58:52 <mauke> I need both :-)
22:59:10 <dons> bos: some 15 darcs bugs are due to fromJust without approprtiate proof of safety
23:02:18 <dons> i've even seen one or two in ghc
23:02:28 <bos> what happens? fromJust Nothing -> kerboom?
23:02:56 <mauke> > fromJust Nothing :: kerboom
23:02:57 <lambdabot>  Add a type signature
23:02:57 <newsham> > fromJust (Nothing :: Maybe Int)
23:02:59 <lambdabot>  Exception: Maybe.fromJust: Nothing
23:03:20 <bos> i must learn me some o' them exceptions.
23:03:42 <mauke> @hoogle exception
23:03:43 <lambdabot> Control.Exception :: module
23:03:43 <lambdabot> Distribution.Compat.Exception :: module
23:03:43 <lambdabot> Control.Exception.Exception :: data Exception
23:03:59 <bos> i only used the Maybe monad for the first time tonight.
23:04:11 <dons> hehe
23:04:23 <dons> for hard exceptions, handle/catch are my favourite
23:04:35 <bos> got a bit of catching up on the local prevailing idioms to do.
23:04:43 <reppie> Syntactic sugar causes cancer of the semicolon.
23:04:45 <dons> i guess there were no exceptions in Haskell when you last hacked the lambdas?
23:04:47 <mauke> sequence in the list monad is fun
23:05:10 <bos> no, we rolled our IO monads using endless chains of `thenIO`
23:05:19 <bos> i.e. we didn't have a module system, either.
23:05:30 <dons> yeah, still a few of those thenIO's in ghc (done in the old backend)
23:06:13 <bos> so i am aware of exceptions, but haven't given them even a bit of thought yet :-)
23:06:14 <dons> here's a little fragment I wrote a few days ago to safely extract a URI from the $http_proxy environment variable, using the Maybe monad for failing parses, and catching any weird exceptions:
23:06:20 <dons> getProxy = handle (\_ -> return Nothing) $ do
23:06:20 <dons>     env <- M.fromList `fmap` getEnvironment
23:06:20 <dons>     return $! do
23:06:20 <dons>         s <- M.lookup "http_proxy" env
23:06:20 <dons>         a <- parseURI s
23:06:22 <dons>         v <- uriAuthority a
23:06:25 <dons>         let host = uriRegName v
23:06:28 <dons>             port = read (tail (uriPort v))
23:06:30 <dons>         return (host, port)
23:06:35 <dons> all that stuff on the $! rhs is in Maybe
23:06:46 <dons> but we've got a big handle to catch any troublesom IO issues too
23:07:24 <dons> (I think its a nice example of robust handling of code fragments with many potential failure points)
23:07:44 <dons> (since we can't trust the data coming in, in any way)
23:07:52 <bos> of course, the uninitiated reader has no idea what any of those failure points might be :)
23:08:04 <dons> well, getEnvironment could die (?)
23:08:13 <dons> then the lookup for http_proxy could fail (not in the env)
23:08:28 <dons> then maybe its not a valid URI
23:08:35 <dons> then maybe its not got an Authority part
23:08:39 <bos> haskell desperately needs an equivalent to "practical common lisp".
23:08:44 <dons> yeah
23:08:53 <dons> hopefully we'll see one or two this year...
23:09:09 <bos> are people working on them?
23:09:23 <dons> there's a couple of people with sketches, no book deals yet that I know of
23:09:32 <bos> book deals are terrible.
23:09:40 <bos> they make writing feel like work, so you avoid it.
23:09:49 <dons> mmm. yes
23:09:57 <dons> easier to just write 'Practical Haskell' blog articles from day to day ;)
23:10:03 <dons> everyone should do it!
23:10:30 <mbishop> just as long as you don't publish them at Apress and end up with something the likes of "Practical Ocaml" :P
23:11:13 <dons> uh hu.
23:11:17 <bos> the folks at apress are nice.
23:11:18 <dons> quite a scandal that
23:11:22 <bos> they're just not domain experts.
23:12:06 <bos> although the ocaml book looks pretty egregious.
23:12:22 <mbishop> Practical Common Lisp was a good one
23:12:30 <bos> peter seibel is very nice.
23:12:33 <bos> and smart.
23:12:35 <bos> and rich.
23:12:45 <bos> lucky bugger :)
23:13:10 <glguy> > maxBound :: Int
23:13:13 <lambdabot>  2147483647
23:13:24 <olliej> > maxBounds :: Integer
23:13:25 <lambdabot>   Not in scope: `maxBounds'
23:13:28 <olliej> > maxBound :: Integer
23:13:29 <lambdabot>   add an instance declaration for (Bounded Integer)
23:13:30 <lambdabot>     In the expression: ma...
23:13:34 <olliej> hehe
23:14:27 <mauke> @let fullRange = [minBound .. maxBound]
23:14:28 <lambdabot> Ambiguous type variable `a' in the constraints
23:14:45 <mauke> what
23:15:43 <olliej> @let fullRange::[Int] = [minBound .. maxBound]
23:15:44 <lambdabot>  Parse error
23:15:57 <olliej> @let fullRange = [minBound :: Int .. maxBound]
23:15:58 <lambdabot> <local>:6:0:     Multiple declarations of `L.fullRange'     Declared at: <loc...
23:16:03 <mauke> > fullRange :: [Int]
23:16:04 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
23:16:17 <mauke> > fullRange :: [Char]
23:16:18 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
23:16:22 <mauke> whee!
23:16:39 <olliej> > fullRange :: [Byte]
23:16:39 <lambdabot>   Not in scope: type constructor or class `Byte'
23:16:43 <olliej> :-/
23:16:44 <dons> Word8
23:16:51 <olliej> dons: ah
23:17:58 <mauke> > fullRange :: [Ordering]
23:17:59 <lambdabot>  [LT,EQ,GT]
23:18:03 <dons> > fullRange :: [Word8]
23:18:04 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:19:22 <bos> bah, i was hoping that graham hutton's new haskell book would be of a practical bent, but it's not.
23:20:26 <bos> it's a cs 101 book.
23:20:36 <dons> nope. another beginner book
23:20:45 <dons> we need some Haskell for the Working Programmer books !
23:20:59 <Smokey`> what're you waiting for dons? ;)
23:21:08 <dons> trying to finish my PhD
23:21:14 <Smokey`> ah, fair call.
23:21:23 <mbishop> Publish your thesis as a book? :)
23:21:23 <dons> and writing 2-3 page 'Haskell for the Working Programmer' blog articles to keep people happy ;)
23:21:36 <ray> the only way to learn a language is writing an irc bot in it!
23:21:48 <dons> ?go Roll your own IRC bot
23:21:51 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:21:51 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
23:21:52 <dons> :}
23:21:56 <Smokey`> hehe :)
23:21:58 <mauke> damn, then I don't know any languages :(
23:22:30 <ray> :(
23:22:45 <hyrax42> bos: but it is a good book for what it's aimed at
23:22:49 <hyrax42> at least the 5 ch preview
23:22:55 <hyrax42> nice and to the point
23:23:10 <hyrax42> I can't stand books that spend hundreds of pages getting nowhere
23:23:25 <hyrax42> cf. the typical cs 101 books from java
23:23:38 <dons> we could probably divide up the base modules betweeeeen say, 10 people in here, and have each person write an exmaple of how to use that library module each week
23:23:44 <bos> hyrax42: oh yes, no doubt about the need for good cs101 books.
23:23:52 <dons> till the whole of the base libraries are covered with howto/coookbook examples...
23:24:05 <hyrax42> dons: do you have a bigger body of code where that Maybe monad example comes from?
23:24:17 <dons> yeah, urlcheck
23:24:21 <dons> ?where urlcheck
23:24:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/urlcheck
23:24:32 <hyrax42> I'm trying to motivate for a couple of friends how the monad abstraction is handy
23:24:37 <dons> my smp linkchecker replacement (for an upcoming Monad.Reader article)
23:24:48 <hyrax42> but couldn't come up with a contrived Maybe example on the spot
23:24:54 <hyrax42> *not-too-contrived
23:25:10 <dons> having to correctly extract fields fro mthe http_proxy variable turned out to be a nic euse case
23:25:23 <dons> esp. since all the relevant haskell functions returned Maybe a
23:25:41 <dons> there's some Either monad use in their too omewhere
23:25:43 <hyrax42> map lookup et al?
23:26:17 <hyrax42> shame that instance is a bit crap
23:31:33 <ray> cool, dons
23:33:29 <glguy> ?src sum -- strict?
23:33:30 <lambdabot> Source for this function is not available.
23:33:38 <glguy> ?
23:35:32 <nornagon> ?src sum
23:35:33 <lambdabot> sum = foldl (+) 0
23:35:36 <nornagon> Bug!
23:35:39 <glguy> oh
23:35:42 <glguy> doesn't allow comments
23:35:43 * nornagon notifies the authorities.
23:35:51 <glguy> what is the reason that sum isn't fold'?
23:36:06 <dons> fusion?
23:36:13 <dons> lazziness?
23:36:19 <dons> no, there's no fusion for foldl
23:36:37 <glguy> ?type sum
23:36:39 <lambdabot> forall a. (Num a) => [a] -> a
23:36:49 <glguy> are there any lazy instances of Num?
23:37:02 <glguy> like lists for example
23:37:08 <glguy> where partial results are meaningful
23:37:08 <dons> they've all got a little bit of magi^h^h^h strictness :)
23:39:37 <sjanssen> glguy: not in the standard libraries
23:39:49 <glguy> foldl' isn't?
23:39:56 <glguy> or strictness isn't
23:40:00 <sjanssen> but addition on peano style numbers could be lazy, for example
23:40:07 <glguy> hm, ok
23:40:09 <sjanssen> glguy: there aren't any lazy instances of Num in the libs
23:40:47 <glguy> for the 400000 numbers I was summing, it barely mattered
23:40:55 <glguy> so I bet ghc is doing it strictly anyway
23:40:58 <sjanssen> dons: that really should be a foldl'
23:41:13 <sjanssen> most likely, GHC /is/ fairly smart
23:41:29 <glguy> does foldr fuse with map?
23:41:34 <sjanssen> yes
23:42:04 <sjanssen> glguy: have you seen the list of good consumers/producers in the GHC manual?
23:42:09 <glguy> nope
23:42:41 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3179621
23:42:43 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
23:43:48 <glguy> is this the case for 6.4 as well?
23:44:13 <sjanssen> 6.4 should be largely the same, IIRC
23:45:05 <sjanssen> hmm, there is a bug in that document
23:45:31 <glguy> that's neat that you are encouraged to write clear good without being penalized for not attempting to optimize the list functions together
23:46:26 <sjanssen> length is a good consumer in GHC 6.4, but not in GHC 6.6
23:46:41 <glguy> was that intentional?
23:47:40 <sjanssen> 6.4 had a rewrite rule to turn length into a foldr for fusion, but it causes stack overflows on large inputs
23:47:51 <glguy> ah
23:49:59 <glguy> oh, I was summing 4*10^6 (not 5) number earlier, and the difference in foldl and foldl' didn't exist
23:50:09 <glguy> for summing
23:50:50 <glguy> but that's not really important anyway
23:50:52 <sjanssen> strictness analysis in action
23:52:08 <dons> a, sjanssen :
23:52:09 <dons> #ifdef USE_REPORT_PRELUDE
23:52:09 <dons> sum                     =  foldl (+) 0
23:52:09 <dons> product                 =  foldl (*) 1
23:52:09 <dons> #else
23:52:12 <dons> sum l   = sum' l 0
23:52:14 <dons>   where
23:52:17 <dons>     sum' []     a = a
23:52:19 <dons>     sum' (x:xs) a = sum' xs (a+x)
23:52:22 <dons> product l   = prod l 1
23:52:24 <dons>   where
23:52:27 <dons>     prod []     a = a
23:52:29 <dons>     prod (x:xs) a = prod xs (a*x)
23:52:32 <dons> #endif
23:52:34 <dons> stupid h98 report ;)
23:52:37 <dons> (looks like the strictness analyser wanted some help there)
23:53:03 <dons> probably not even needed these days
23:53:03 <sjanssen> interesting that none of these have explicit strictness
23:54:54 <dons> now, dynamic typing guys love to talk about: if p then 1 else "two"
23:55:05 <dons> and we can do this several ways in haskell, eg.g with existentials
23:55:06 <dons> or typeables
23:55:12 <dons> > let a `greater` b = if a > b then toDyn "It was greater" else toDyn 0
23:55:12 <dons> > fromDynamic (8 `greater` 3) :: Maybe String
23:55:12 <dons> Just "It was greater"
23:55:13 <lambdabot>  Parse error
23:55:13 <dons> or
23:55:13 <lambdabot>   Not in scope: `greater'
23:55:15 <glguy> dons: and perl knows that "two" is 2 ;)
23:55:19 <dons>   	
23:55:19 <dons> dons 1 point 5 minutes ago*
23:55:19 <dons> Hehe, just had to try it. Works with either Typeable:
23:55:22 <dons> > let a `greater` b = if a > b then toDyn "It was greater" else toDyn 0
23:55:22 <dons> > fromDynamic (8 `greater` 3) :: Maybe String
23:55:22 <dons> Just "It was greater"
23:55:23 <lambdabot>  Parse error
23:55:24 <lambdabot>   Not in scope: `greater'
23:55:25 <dons> > fromDynamic (0 `greater` 1) :: Maybe Integer
23:55:27 <lambdabot>   Not in scope: `greater'
23:55:27 <dons> Just 0
23:55:30 <dons> Or, a bit nicer, with existentials:
23:55:32 <dons> data E = forall t . Show t => E t
23:55:35 <dons> case "haskell" `greater` "C"  of E t -> print t
23:55:35 <dons> "It was greater"
23:55:44 <dons> now, would we ever *want* to do this?
23:55:57 <dons> other than to save show/read use? :)
23:56:02 <Korollary> not for primitives like this
23:56:19 <Korollary> nor do they want it I believe
23:56:44 * Korollary speaks like Yoda at times
23:56:47 <dons> so its a strawman?
23:56:52 <glguy> "(1+2)" + "three"
23:56:55 <glguy> >4
23:56:57 <dons> and the real uses are hlists (i.e. lists of existentials) ?
23:56:59 <glguy> oops
23:57:01 <glguy> 6
23:57:01 <glguy> ;)
23:57:08 <Korollary> I think the simple if x then False else 2.0 is a strawman, yes.
23:57:11 <dons> or just union types
23:57:26 <Korollary> but, if the branches are more complicated, I don't know. Could be full blown objects.
23:57:37 <dons> yeah, i.e. existentials :)
23:57:49 <dons> pack up a value (statically) with its operations
23:57:58 <dons> call it an object, create a list of them
23:58:01 <dons> toss 'em around
23:58:08 <dons> (lambdabot does use this for representing Modules)
23:58:24 <Korollary> I went to a perl users group meeting (dont ask why)
23:58:27 <glguy> it would be nice to say: foldl ap (return f) [g,h]
23:58:32 <glguy> for liftM2
23:59:02 <glguy> > (fromDynamic . toDynamic) 3 :: Int
23:59:03 <lambdabot>   Not in scope: `toDynamic'
23:59:05 <Korollary> even they dont think perl is being considered an industry strength language by everybody.
23:59:17 <glguy> ?hoogle Dynamic
23:59:19 <lambdabot> Data.Dynamic :: module
23:59:19 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
23:59:19 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
23:59:30 <glguy> ?hoogle+
