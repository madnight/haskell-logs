00:00:04 <nornagon> possibly in passing
00:00:18 <nornagon> i meant as an everyday OS
00:00:47 <nornagon> not "does it work"
00:07:18 <nornagon> ?where greencard
00:07:19 <lambdabot> I know nothing about greencard.
00:07:35 <nornagon> HOpenGL seems to want some GreenCard thing.
00:11:08 <nornagon> ?where+ greencard http://haskell.org/greencard/
00:11:09 <lambdabot> Done.
00:12:53 <nornagon> i can't seem to build it
00:12:59 <nornagon>     Could not find module `Data.FiniteMap':
00:13:28 <sorear> nornagon: use GHC 6.2
00:13:38 <sorear> GHC 6.4 and later deleted FiniteMap
00:13:43 <nornagon> um.
00:13:55 <nornagon> okay then, i guess i'll just forget trying to get hopengl to work
00:14:01 <nornagon> since i really can't be bothered
00:14:26 <sorear> nornagon: hopengl standalone is bitrotted, hopengl in extralibs works
00:14:50 <nornagon> oh, hm:
00:14:50 <nornagon> libghc6-opengl-dev - Haskell OpenGL binding for GHC
00:15:08 * nornagon installs that.
00:15:14 <sorear> doons: does what I just sent to you look good enough for g-h-u?
00:16:20 <sorear> dons: s/doons/dons/
00:18:28 <nornagon> sorear: so where can i get docs on the good hopengl?
00:18:46 <sorear> @docs
00:18:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
00:18:53 <nornagon> oh
00:18:56 <nornagon> zany :)
00:21:17 <nornagon> it doesn't look like there's actually anything there
00:21:26 <nornagon> i mean, it has places where there could be docs
00:22:01 <dons> sorear: ok. we can send it out tomorrow.
00:22:11 <dons> if you're too tired :)
00:22:17 <dons> ?time sorear
00:22:18 <lambdabot> Local time for sorear is Sun Jan 28 00:18:11 2007
00:22:21 <dons> gives me a chacne to read it through
00:22:45 <sorear> leven 5?
00:22:49 <sorear> ?list time
00:22:50 <lambdabot> localtime provides: time localtime localtime-reply
00:22:52 <sorear> oh.
00:23:20 <nornagon> oh, nm
00:23:29 <nornagon> i have to click more
00:23:38 <nornagon> any example code? :)
00:23:39 <sorear> click more?
00:24:22 <nornagon> it looked like there were a bunch of undoc'd modules
00:24:35 <nornagon> but then when i click on the name of the module, i get docs
00:28:59 <nornagon> http://projects.codersbase.com/repos/nehe-tuts/lesson01.hs <- wtf is $=?
00:29:14 <sorear> an operator
00:29:44 <nornagon> thx
00:29:53 <sorear> to a first approximation, ($=) :: IORef a -> a -> IO () = writeIORef
00:30:24 <nornagon> eek.
00:31:49 <dons> or := ?
00:32:10 <dons> (would have been better syntx ;)
00:32:33 <dons> p := 7
00:32:46 <dons> i wonder why that kind of operator name for IORef didn't really take off... :}
00:33:05 <dons> morning apfelmus
00:33:28 <apfelmus> good morning!
00:33:42 <nornagon> dons: can you tell me what it does in the context of this opengl thingumy?
00:34:14 <dons> no idea :)
00:34:20 <nornagon> :(
00:34:23 <dons> ah, maybe it sets an attribute?
00:34:26 <nornagon> so it's not standard?
00:34:37 <dons> no, it'd be some library/module local defn
00:34:39 <nornagon> or you're just not familiar with the opengl lib? :)
00:34:40 <dons> grep the src
00:34:46 <dons> correct.
00:35:07 <sorear> I am, and it is a HOpenGL specific thing.
00:39:50 <apfelmus> dons: i'm still sleepy. i need a hot cup of Haskell now
00:40:57 <nornagon> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/ seems to be nice
00:41:00 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
00:54:13 <kolmodin> morning!
00:55:18 <sorear> yawn
01:01:05 <sjanssen> I suppose it is technically morning . . .
01:01:43 <sorear> sleep now.  (later: syntax in yi)
01:02:10 <nornagon> night sorear!
01:02:15 <nornagon> thanks for all your help earlier
01:02:52 <sorear> yw
01:17:25 <boegel> it seems nofib is still actively used in GHC as a test suite? is that right?
01:28:34 <CloudiDust> Hi all, I'm now looking for the tutorial All About Monads, surprisingly I cannot access the web site www.nomaware.com/monads/ for three days.  Could you offer me a copy? Thanks.
01:30:19 <boegel> CloudiDust: can't seem to access it either... it's a conspiracy!
01:31:19 <abz> try this
01:31:21 <abz> http://web.archive.org/web/*/http://www.nomaware.com
01:31:28 <lambdabot> Title: Internet Archive Wayback Machine
01:32:30 <CloudiDust> Very slow ...... Still loading ......
01:32:32 <sm> any good tips for debugging parsec parsers ?
01:32:41 <sm> I'm using <?> liberally
01:33:01 <sm> but now I'm stuck
01:33:12 <abz> paste your code
01:33:30 <abz> http://hpaste.ath.cx:8000/
01:34:08 <beschmi> boegel: i think it's used in the nightly build: http://archive.netbsd.se/?ml=haskell-cvs-all&a=2007-01&m=3042354
01:34:08 <lambdabot> beschmi: You have 1 new message. '/msg lambdabot @messages' to read it.
01:34:10 <lambdabot> Title: archive.netbsd.se
01:35:08 <hpaste>  sm pasted "(no title)" at http://hpaste.org/160
01:35:21 <sm> well, there's the whole thing
01:35:37 <sm> but I think specific help will be too hard..
01:36:19 <sm> ack, hpaste truncates
01:36:49 <abz> so what is the problem?/
01:37:15 <CloudiDust> The page seems uncached. :(
01:37:24 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/hledger.hs
01:37:31 <lambdabot> Title: darcs - hledger, http://tinyurl.com/ynu8g2
01:38:07 <sm> but the failing case is in my own ledger file.. I'll add a test case
01:40:11 <tuukkah> should i already be able to type in yi/gtk?
01:41:18 <jyp> tuukkah: yet
01:41:21 <jyp> yes
01:41:55 <tuukkah> i can't, could it be that i don't have the very latest gtk2hs compiled?
01:42:13 <jyp> what version have you?
01:42:28 <jyp> what mode do you use? (--as= ?)
01:43:08 <tuukkah> something that still claims to be 0.9.10.3
01:43:22 <jyp> you need to upgrade
01:43:25 <tuukkah> hmm, i didn't give any mode
01:43:26 <jyp> that one was buggy
01:44:02 <jyp> strange is that I put a dependency in the cabal gtk>=0.9.10.3
01:44:12 <jyp> did you override it somehow?
01:44:34 <tuukkah> i changed that yes. i don't see anything related in darcs changes
01:45:27 <abz> sm: what are you trying to do? have you tried each sub parser with parseTest?
01:45:35 <jyp> tuukkah: default mode is vim mode
01:45:50 <tuukkah> ok, with --as emacs, i can type other letters but not newlines
01:45:59 <jyp> use --as=emacs2
01:46:24 <jyp> but you need to upgrade gtk2hs otherwise you will experience crashes
01:46:33 <tuukkah> here i'm missing the cursor
01:47:23 <jyp> you should see one...
01:48:12 <tuukkah> anyway, this looks promising. i'll try later when i'm done with gtk2hs hacking.
01:48:13 <jyp> dunno what happens... but I can't help prior to a gtk2hs upgrade
01:48:22 <tuukkah> thanks
01:48:24 <jyp> cool
01:48:35 <jyp> thanks to you ;)
01:51:50 <sm> abz: sorry.. having some trouble isolating the problem
01:52:43 <abz> I see that it parses the test cases in main, but the problem is in your .dat file right?>
01:56:39 * CloudiDust finds the tutorial right on Haskell.org.
01:57:33 <hpaste>  sm pasted "the problem" at http://hpaste.org/161
01:58:37 <sm> I've been beating my brains out on parsec for a while now.. very foolish at this time of night
01:59:54 <abz> have you got you gramma defined anywhere?
02:02:25 <dcoutts> tuukkah, jyp: so do you know if yi's gtk UI works ok then?
02:02:32 <sm> yes, but unfortunately it's hard to link to. http://ledger.cvs.sourceforge.net/*checkout*/ledger/ledger/ledger.texi?revision=1.24 , maybe
02:02:34 <lambdabot> http://tinyurl.com/yo8c6t
02:02:59 <jyp> dcoutts: it works for me :)
02:03:22 <jyp> Some patches haven't made it to dons' repo though
02:03:28 <dcoutts> jyp, great, is gtk UI in the main yi darcs repo?
02:03:32 <jyp> I don't think these are critical
02:03:34 <dcoutts> ah right
02:03:42 <dcoutts> so it's mostly in the main repo
02:03:46 <sm> in the docs he says "The ledger ﬁle format is quite simple".. then "but also very ﬂexible. It supports many options", which I'm finding out
02:03:49 <jyp> dcoutts: yes
02:04:06 <jyp> With bugs, but you can already have a look
02:04:43 <augustss> yo
02:06:06 <sm> would it be a good idea to use that trace library maybe ?
02:06:40 <abz> sorry, I don't know what your talking about... `that trace library`
02:06:58 <dons> hey augustss
02:07:09 <sm> for example http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html#v%3Atrace
02:07:24 <dons> ?docs Debug.Trace
02:07:30 <dons> ah beat me
02:07:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
02:08:30 <beschmi> @where+ shim http://shim.haskellco.de/trac/shim
02:08:30 <lambdabot> Done.
02:08:32 <abz> I've never used it.
02:09:22 <dons> trace "some msg" $ 1 +2 -- is the style, get messages printed out as things are evaluated
02:09:30 <abz> sm: the first thing is, your using `many` way to much.
02:09:55 <abz> look at choice
02:10:14 <sm> I don't think I can call trace from inside a parser
02:10:22 <abz> look at using choice along with many right at the top level
02:10:42 <sm> choice, ok
02:11:00 <abz> so basically, your not `doing it the parsec way`.
02:11:46 <abz> `the parsec way`, is to use choice throughout your grammar and many at the top level.
02:12:55 <sm> oh, choice is <|> ? I thought I was using that
02:13:38 <abz> yes, you are too...
02:21:06 * sm adds the grammar to the source file
02:29:53 <abz> sm: once you've defined the start of a comment in LanguageDef, you don't need to add it into your grammar, parsec treats it like whitespace
02:30:36 <sm> yes.. I'm debating whether to switch over to using the token stuff
02:31:04 <sm> I probably will need to parse comments, they're not always just comments..
02:31:41 <sm> would quickcheck be effective for testing this kind of thing ?
02:31:42 <opqdonut> ?pl \x y -> (x,f x y)
02:31:42 <lambdabot> liftM2 (.) (,) f
02:32:47 <retybok> ?users
02:32:47 <lambdabot> Maximum users seen in #haskell: 322, currently: 278 (86.3%), active: 18 (6.5%)
02:36:05 <abz> sm: next, you should define you keywords in reservedNames
02:36:22 <abz> then use the combinator `reserved` to parse them
02:36:41 <abz> sm: dont use things like `manyTill anyChar newline `
02:36:43 <sm> I'm not sure I have any!
02:37:19 <abz> keywords are things like: include, account...
02:37:36 <sm> you're right.. I haven't implemented those yet
02:37:43 <abz> monthly
02:37:48 <abz> from
02:37:51 <sm> aha
02:38:25 <abz> these are a must
02:39:32 <dcoutts> @seend jyp
02:39:37 <lambdabot> I saw jyp leaving #haskell 26m ago, and .
02:39:37 <dcoutts> @seen jyp
02:39:37 <lambdabot> I saw jyp leaving #haskell 26m 5s ago, and .
02:39:42 <dcoutts> damn
02:40:12 <abz> dont use things like this `many (noneOf "-.0123456789\n"`, use the parsec combinators like natural, integer
02:42:18 <abz> sm: I don't think ` identLetter    = alphaNum <|> oneOf "_':" ` shouldn't have `:` in it, it has different meaning
02:43:07 <abz> colon appears twice in LanguageDef, this is a mistake, it should only appear once
03:06:13 <paolino> good morning
03:06:30 <paolino> how I catch a read exception ?
03:07:24 <paolino> I want to make a simple retry until it parse
03:10:27 <dcoutts> @type reads
03:10:29 <lambdabot> forall a. (Read a) => ReadS a
03:10:54 <dcoutts> paolino, use reads rather than read. that way you can see if the parse succeeded or failed.
03:11:44 <paolino> @src ReadS
03:11:46 <lambdabot> Source not found. Do you think like you type?
03:12:10 <paolino> iIi
03:12:17 <beschmi> > (reads "a123213") :: [(Int,String)]
03:12:18 <lambdabot>  []
03:12:25 <beschmi> > (reads "123213sdfsdfsd") :: [(Int,String)]
03:12:26 <lambdabot>  [(123213,"sdfsdfsd")]
03:14:01 <paolino> > reads "a123" :: Maybe (String,Int)
03:14:02 <lambdabot>  Couldn't match `Maybe (String, Int)' against `[(a, String)]'
03:15:37 <paolino> ok
03:16:50 <yaxu> good morn
03:19:39 <yaxu> who is haskell-admin@haskell.org ?
03:19:58 <apfelmus__> it's lambdabot
03:22:43 <apfelmus> yaxu: (just kidding :)
03:23:50 <yaxu> heh
03:24:26 <apfelmus> @botsnack
03:24:27 <lambdabot> :)
03:28:06 <paolino> :t null
03:28:08 <lambdabot> forall a. [a] -> Bool
03:28:30 <paolino> :t null a || head a
03:28:36 <lambdabot> Not in scope: `a'
03:28:36 <lambdabot>  
03:28:36 <lambdabot> <interactive>:1:15: Not in scope: `a'
03:28:53 <yaxu> i've emailed them anyway, about the possibility of having a haskell-art mailing list
03:29:14 <paolino> > let a= [] in  null a || head a
03:29:16 <lambdabot>  True
03:29:49 <paolino> > let a= [1] in  null a || head a
03:29:50 <lambdabot>   add an instance declaration for (Num Bool)
03:29:50 <lambdabot>     In the list element: 1
03:29:50 <lambdabot>     I...
04:01:15 <mahogny> hm. has someone used docon?
04:13:42 <paolino> @.pl undo do {x <- f1;y <- f2;return (x,y)}
04:13:42 <lambdabot> (line 1, column 9):
04:13:43 <lambdabot> unexpected "{"
04:13:43 <lambdabot> expecting variable, "(", operator or end of input
04:14:32 <AStorm> @. undo . pl do {x <- f1; y <- f2; return (x,y)}
04:14:32 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "do"
04:14:43 <AStorm> @. pl . undo do {x <- f1; y <- f2; return (x,y)}
04:14:43 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "do"
04:14:49 <Saizan> ?type \f1 f2 -> liftM2 (,) f1 f2
04:14:50 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
04:14:51 <AStorm> @. pl undo do {x <- f1; y <- f2; return (x,y)}
04:14:51 <lambdabot> (`fmap` f2) . (,) =<< f1
04:14:56 <AStorm> :>
04:15:10 <paolino> :)
04:15:34 <AStorm> Saizan, it's not a simple liftM
04:15:43 <Saizan> why not?
04:16:03 <Saizan> ?type \f1 f2 -> do {x <- f1;y <- f2;return (x,y)}
04:16:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m (a, b)
04:16:11 <Saizan> same type
04:16:28 <Saizan> it's a liftM2 however
04:16:51 <AStorm> Yes.
04:16:53 <AStorm> :p
04:19:03 <musasabi> Did FFI calls block exceptions with GHC?
04:23:18 <rahikkala> @src sortBy
04:23:19 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:23:30 <rahikkala> Where does lambdabot get its @src from?
04:24:02 <roconnor> I was wondering the same.
04:24:36 <roconnor> dons would probably know, or know who knows
04:24:47 <malebria> Is there a function like liftM2 but with (a -> b -> m c) instead of (a -> b -> c) ?
04:27:52 <paolino> @. pl . undo do {(x,y) <- f;g x;return y}
04:27:53 <reilly> ?hoogle Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
04:27:53 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "do"
04:27:54 <lambdabot> Did you mean: Monad m => (A1 -> A2 -> m r) -> m A1 -> m A2 -> m r
04:27:54 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
04:27:58 <der_eq> sortBy is insertion-sort?
04:28:21 <paolino> @. pl undo do {(x,y) <- f;g x;return y}
04:28:22 <lambdabot> uncurry ((. return) . (>>) . g) =<< f
04:30:08 <paolino> :t (put *** return)
04:30:09 <lambdabot> forall b (m :: * -> *) (m1 :: * -> *) b'. (MonadState b m, Monad m1) => (b, b') -> (m (), m1 b')
04:33:00 <paolino> @. pl undo do {let (fa,fb) = (put *** return) (a,b);fa;fb}
04:33:05 <lambdabot> (line 1, column 21):
04:33:05 <lambdabot> unexpected "{"
04:33:05 <lambdabot> expecting variable, "(", operator or ")"
04:33:18 <paolino> @ . pl undo do {let (fa,fb) = (put *** return) (a,b);fa;fb}
04:36:21 <qwr> @undo do {let (fa,fb) = (put *** return) (a,b);fa;fb}
04:36:21 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 44}) "Parse error"
04:38:16 <malebria> I think it's better to use a do notation.
04:41:15 <malebria> I'm trying to do a type synonym with forall, but I'm getting the error:
04:43:02 <hpaste>  malebria pasted "Problem with type = forall" at http://hpaste.org/162
04:44:21 <malebria> Shouldn't this work?
04:54:41 <xpika2> is there anything i can do with (4 (+))?
04:56:08 <sieni> yes, throw it towards an aquatic avian
04:56:21 <malebria> xpika2: this is wrong.
04:56:26 <malebria> > let x = (4 (+))
04:56:26 <lambdabot>  Parse error
04:56:36 <malebria> > let x = (4 +)
04:56:36 <lambdabot>  Parse error
04:56:55 <malebria> ?
04:57:09 <malebria> Here in ghci let x = (4 +) works fine.
04:57:18 <malebria> > let x = (4 +) in x 5
04:57:19 <lambdabot>  9
04:58:34 <der_eq> malebria: does it work if you declare point as a data-type?
04:58:57 <xpika2> im trying to understand what a CAF is. http://haskell.cs.yale.edu/hawiki/ConstantApplicativeForm?action=show&redirect=CAF
04:58:59 <lambdabot> Title: ConstantApplicativeForm - The Haskell Wiki, http://tinyurl.com/2bsqsh
05:00:16 <malebria> der_eq: I don't know, but this is not what how I want it.
05:00:56 <malebria> der_eq: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#type-synonyms
05:00:58 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
05:01:08 <malebria> der_eq: it should work like this.
05:06:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/163
05:06:32 <der_eq> I don't have your code, but this similar code works
05:06:56 <der_eq> (for me)
05:08:04 <der_eq> are you using 6.6?
05:09:57 <malebria> der_eq: yes, I'll try to make a simple example here.
05:11:05 <mahogny> musasabi, I wouldn't be surprised. FFI calls blocks pretty much everything
05:13:22 <bringert> @type Data.ByteString.Lazy.cycle
05:13:24 <lambdabot> Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString
05:13:35 <bringert> @type Data.ByteString.Lazy.Char8.cycle
05:13:36 <lambdabot> Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString
05:13:46 <bringert> hmm, haddock says otherwise
05:14:11 <bringert> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString-Lazy-Char8.html#v%3Acycle
05:14:12 <lambdabot> http://tinyurl.com/2n8fvy
05:14:38 <dcoutts> bringert, oh yeah, so I see. odd
05:14:59 <dcoutts> it's getting the List version
05:15:23 <bringert> dcoutts: my ghci says the same:
05:15:24 <bringert> Prelude> :i Data.ByteString.Lazy.Char8.cycle
05:15:24 <bringert> cycle :: [a] -> [a]     -- Defined in GHC.List
05:15:42 <malebria> der_eq: strange, the problem is with liftM2
05:15:49 <bringert> what version does lambdabot use?
05:15:53 <bringert> base from darcs?
05:15:53 <malebria> der_eq: try changing your test to liftM2.
05:18:01 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/163#1
05:18:11 <der_eq> like this?
05:18:20 <der_eq> still works
05:18:52 <dcoutts> bringert, in the source we clearly import cycle from Data.ByteString.Lazy and import Prelude hiding cycle.
05:19:12 <bringert> dcoutts: maybe it has been fixed since the GHC 6.6 release?
05:19:14 <huschi> is it possible to work on a mysql or postgresql database with HAppS?
05:19:18 <dcoutts> bringert, yeah, maybe
05:19:43 <dcoutts> bringert, yep
05:19:45 <dcoutts> Fri Nov 10 02:13:11 GMT 2006  Don Stewart <dons@cse.unsw.edu.au>
05:19:45 <dcoutts>   * The wrong 'cycle' was exported from Data.ByteString.Lazy.Char8, spotted by sjanssen
05:20:03 <bringert> weird, when I use readFile for input, getBytes is not lazy enough, but when the data comes from replicate, it is
05:20:26 <malebria> der_eq: no, like this:
05:21:23 <dcoutts> bringert, we were talking to John Hughes about how to use QuickCheck to test laziness properties
05:21:44 <hpaste>  malebria annotated "(no title)" with "liftM" at http://hpaste.org/163#2
05:21:55 <malebria> der_eq: It's not about liftM2, it's about liftM
05:22:05 <dcoutts> bringert, there are two ideas we had, one was to modify the data structure to have an explicit representation for _|_, eg List a = Cons _ _ | Nil | Bottom
05:22:39 <dcoutts> bringert, the other was to actually insert (error "some unique string") and then catch the error and see if it's that same unique string.
05:26:18 <bringert> dcoutts: sounds interesting
05:26:59 <dcoutts> bringert, if we want to take laziness properties seriously (and for lazy bytestring it's obviously very significant) then we should test it
05:27:10 <bringert> yeah
05:27:11 <dcoutts> we already had one laziness bug
05:27:31 <dcoutts> which was causing problems for people who wanted to do networking stuff
05:28:02 <dcoutts> because it was trying to grab too much input (since one function was forcing the tail)
05:28:12 <dcoutts> and thus blocking
05:28:31 <dcoutts> so we should specify and test the laziness properties
05:28:43 <xpika2> ok i get what cats are now :)
05:28:51 <xpika2> cafs*
05:30:21 <bringert> dcoutts: I guess there need to be some high-level constructs for specifying laziness then
05:32:03 <der_eq> okay, now I get the problem, but I get "Inferred type is less polymorphic than expected"
05:33:06 <dcoutts> bringert, so for example some are trivial: f _|_ = _|_
05:33:50 <dcoutts> bringert, others are more interesting: take n (cycle n ++ _|_) = cycle n
05:33:51 <bringert> dcoutts: False && _|_ == False
05:33:54 <dcoutts> or something like that
05:33:55 <bringert> yeah
05:34:26 <nornagon> wouldn't False && _|_ be _|_?
05:34:26 <bringert> take 0 _|_ == []
05:34:35 <bringert> nornagon: no, why?
05:34:39 <dcoutts> or take n (repeat n _|_) /= _|_
05:35:40 <bringert> nornagon: even most strict languages guarantee False && _|_ == False as a special case
05:35:45 <bringert> e.g. Java
05:35:57 <nornagon> oh, okay then
05:36:10 <nornagon> i thought the f _|_ = _|_ covered that
05:36:44 <bringert> nornagon: that's not a general rule, dcoutts used that as an example when you want to say that f is strict in its argument
05:36:50 <nornagon> oh.
05:36:54 <AStorm> it's (&&) False _|_
05:36:59 <nornagon> right
05:37:02 <bringert> i.e. its for some specific f, not all fs
05:37:05 <AStorm> and (&&) False _ = False
05:37:26 <nornagon> oh, right
05:37:40 <bringert> nornagon: f _|_ = _|_ is true in general in strict languages
05:37:58 <bringert> nornagon: except possibly for built-in operators like && and ||
05:38:06 <dcoutts> strict :: (a -> b) -> Property; strict f = f undefined == undefined
05:38:29 <dcoutts> ok, so the impl isn't going to work, but you get the idea
05:39:09 <bringert> strict :: (a -> b) -> Property; strict f = isBottom (f undefined)
05:39:13 <bringert> should work
05:39:16 <AStorm> THat'd be strict f = f $x
05:39:18 <bringert> with chasing bottoms
05:39:21 <AStorm> f !x
05:39:23 <AStorm> *sorry
05:39:54 <bringert> and lazy f = not (isBottom (f undefined))
05:40:05 <AStorm> Incorrect? :>
05:40:24 <AStorm> that strict one isn't really strict, just checks for _|_
05:40:48 <dcoutts> bringert, aye, so perhaps that's all you need. an isBottom, isNotBottom function that forces the arg to WHNF and check if it's a distinguished bottom value (ie not general error, but error with a unique string)
05:41:15 <bringert> dcoutts: sounds good
05:41:35 <bringert> dcoutts: what if you have two arguments, and you want it to be strict in one but not the other?
05:41:48 <bringert> you could use two different strings
05:41:55 <dcoutts> bringert, or two properties
05:42:05 <bringert> ah, right
05:42:22 <bringert> bottom = error "bottom"
05:42:43 <bringert> and isBottom just checks if it failed, and that the string == "bottom"
05:42:58 <dcoutts> right
05:43:05 <dcoutts> but yes, multiple distinguished bottoms might be handy some times
05:43:09 <bringert> yeah
05:43:17 <dcoutts> eg for structures with lots of _|_'s in
05:43:29 <bringert> could have a monad which generates fresh bottoms
05:43:39 <dcoutts> though I don't have a good example that'd need it yet
05:45:45 <huschi> it looks like the network package is no longer included in ghc 6.6. is that true?
05:46:03 <dcoutts> huschi, all the non-core libs are available separately
05:46:11 <dcoutts> it's all modular now
05:46:32 <huschi> are the in hackage?
05:46:48 <dcoutts> huschi, yep and in the ghc-src-extralib tarball
05:47:34 <huschi> ah. i will take the extra-libs package. thx.
05:48:23 <hpaste>  malebria pasted "Types with forall" at http://hpaste.org/164
05:49:22 <malebria> Shouldn't they be the same?
05:51:28 <TuringTest> hmmm
05:51:43 <TuringTest> malebria: realToFrac :: forall a b. (Real a, Fractional b) => a ->b
05:51:52 <TuringTest> hmmmm
05:52:36 <TuringTest> The type inference for w is the problem
05:54:09 <TuringTest> Prelude Foreign> let w x = fmap realToFrac (peek x)
05:54:10 <TuringTest> Prelude Foreign> :t w
05:54:10 <TuringTest> w :: forall a b. (Storable a, Real a, Fractional b) => Ptr a -> IO b
05:55:08 <hpaste>  malebria annotated "Types with forall" with "Same problem without w" at http://hpaste.org/164#1
05:55:21 <malebria> TuringTest: I think the problem is with using liftM
05:55:28 <Saizan> ?hoohle peek
05:55:29 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
05:55:29 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
05:55:29 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
05:56:48 <Failure02> what does $ do in front of an identifier?
05:56:54 <Failure02> ghc translates it to $[splice]x
05:57:05 <bringert> Failure02: template haskell
05:57:09 <bringert> @google template haskell
05:57:35 <lambdabot> http://www.haskell.org/th/
05:57:35 <lambdabot> Title: Template Haskell
05:58:09 <TuringTest> teste4 :: (Storable p, Real p,Fractional a) => Ptr p -> IO (a,a)
05:58:09 <TuringTest> works
05:58:36 <malebria> TuringTest: that's the point.
05:58:49 <malebria> TuringTest: Shouldn't this be the same of IO Point?
05:58:57 <TuringTest> no
05:59:03 <malebria> TuringTest: why not?
06:02:00 <hpaste>  malebria annotated "Types with forall" with "More examples" at http://hpaste.org/164#2
06:02:40 <hpaste>  TuringTest annotated "Types with forall" with "forall position" at http://hpaste.org/164#3
06:03:54 <malebria> TuringTest: hum.. but do you know why does the first works and the second don't?
06:06:11 <malebria> Changing Point to IO (a, a) works also.
06:07:08 <hpaste>  malebria annotated "Types with forall" with "Point2 = IO (a, a)" at http://hpaste.org/164#5
06:11:48 <TuringTest> malebria: I understand it now
06:12:51 <TuringTest> malebria: Well...I almost undestand it.
06:13:31 <malebria> TuringTest: =D
06:13:42 <malebria> TuringTest: can you try to explain?
06:13:54 <TuringTest> I will post it in a second.
06:14:00 <malebria> TuringTest: ok, thanks.
06:19:27 <hpaste>  TuringTest annotated "Types with forall" with "Similar example?" at http://hpaste.org/164#6
06:19:54 <TuringTest> This is another example where the location of a forall makes a world of difference to the meaning of the code.
06:20:12 <TuringTest> Foo is legal while Bar is definable but useless
06:20:35 <TuringTest> With data constructor and GADT syntax, you can make the useful Baz type.
06:21:19 <TuringTest> But the actual explanation of the problem with your code is over my head.
06:21:53 <malebria> TuringTest: thanks for the explanation.
06:21:56 <der_eq> it has to do with data vs. type, I think:
06:22:04 <der_eq> data Point' = forall a. Fractional a => Point' a a
06:22:11 <der_eq> mkPoint' :: Fractional a => (a,a) -> Point'
06:22:11 <der_eq> mkPoint' (x,y) = Point' x y
06:22:14 <malebria> But still what makes liftM be different from <- I can't get.
06:22:14 <der_eq> this works
06:22:21 <der_eq> while
06:22:22 <der_eq> mkPoint :: Fractional a => (a,a) -> Point
06:22:22 <der_eq> mkPoint = id
06:22:26 <der_eq> does not
06:22:35 <der_eq> don't ask me why ;)
06:23:35 <TuringTest> Use for "forall" is an extension to Haskell98 and like many extensions it has a paucity of documentation.
06:26:59 <huschi> is it possible to let cabal install the documentation for a package at the place haddock will search for it?
06:29:46 <huschi> ah, Setup.hs copy does it.
06:29:54 <Saizan> TuringTest: but the problem remains the same even without forall, and we're not even using -fglasgow-exts
06:33:04 <der_eq> we need a function Fractional a => (a,a) -> forall b. Fractional b => (b,b) and I have no Idea how to realize that
06:33:34 <malebria> I think we're using -fglasgow-exts.
06:33:55 <malebria> For me the problem is that with return (realToFrac ... it works, and with liftM it doesn't.
06:35:12 <malebria> The problem for me is from test to test3 in http://hpaste.org/164#2
06:36:43 <Saizan> i think we just need to understand what  m (forall a. Class a => a) means
06:37:49 <malebria> Saizan: I don't know if only this will explain the difference between test and test3
06:38:47 <TuringTest> @type (>>=)
06:38:49 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
06:38:58 <Saizan> the difference is between  forall a. C a => m a   and m (forall a. C a)
06:39:25 <TuringTest> Now if 'a' is (forall x. Class x=> a) then the second parameter to (>>=) must accept such a weird type
06:39:27 <Saizan> s/(forall a. C a)/(forall a. C a => a)
06:41:30 <dcoutts> ndm, I've got a new gtk+ tarball to make it easier for people who want to distribute gtk2hs apps, eg guihaskell
06:41:49 <dcoutts> ie it's just a tarball with a bunch of dlls (+ a few support files)
06:41:57 <Saizan> this would be a good wuestion for Cale
06:42:22 <ndm> dcoutts, cool :)
06:42:25 <apfelmus> what are you doing with type Type = forall a . ... ??
06:42:35 <ndm> dcoutts, of course, i can't distribute guihaskell until the threading thing is solved...
06:42:45 <ndm> dcoutts, but the installer for Gtk is very nifty now, very impressive
06:43:07 <TuringTest> apfelmus: We are trying to explain while malebria 's Point type is causing problems
06:43:08 <apfelmus> malebria: i mean i don't see why you use something like type Test = forall a. Read a => IO (a, a) at all?
06:43:37 <malebria> apfelmus: I just wanted some type synonyms to make type signatures simpler.
06:43:48 <malebria> apfelmus: I'll post the whole code and you'll get it.
06:43:49 <dcoutts> ndm, you only need two threads right? and one of them waits in a file read and writes stuff into a textbuffer right? so we could do it in the threaded rts and do the thread switching thing to 'post' the action into the main thread.
06:44:19 <apfelmus> malebria: can you manke a new post instead of annotating the old ?
06:44:23 <apfelmus> *make
06:44:34 <ndm> dcoutts, i guess, not really sure how...
06:44:37 <malebria> apfelmus: I'll do it.
06:44:40 <apfelmus> ok
06:45:21 <ndm> dcoutts, http://www.cs.york.ac.uk/fp/darcs/guihaskell/ then the gtkconsole directory has a minimal sample, if you give me an example of how to do that reliably i can build the rest around it
06:45:23 <lambdabot> Title: Index of /fp/darcs/guihaskell
06:45:33 <hpaste>  malebria pasted "Algebra.Geometric.Gpc" at http://hpaste.org/165
06:46:32 <malebria> @hoogle (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
06:46:33 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
06:46:44 <ndm> malebria: hoogle doesn't like the Monad thing
06:47:07 <malebria> ndm: =(
06:47:19 <malebria> there're too many do notations in my code.
06:47:31 <malebria> I'd like to have a slightly different liftM
06:47:32 <ndm> malebria: hoogle 4 will get it, once its done
06:47:33 <malebria> liftM2
06:47:37 <malebria> ndm: =D
06:48:02 <malebria> apfelmus: have you seen the situation there?
06:48:16 <Saizan> hpaste has truncated your post
06:48:19 <allbery_b> :t liftM2
06:48:21 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:48:32 <allbery_b> have to choose a different name :)
06:48:43 <apfelmus> malebria: yes. i'm still digesting it
06:49:06 <Saizan> ?type \f m1 m2 -> m1 >>= \x -> m2 >>= \y -> f x y
06:49:07 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
06:50:08 <Saizan> you can call it (>>=>>=) :D
06:50:17 <apfelmus> malebria: i wonder why you don't code polygon intersection in Haskell directly, most likely, it's much easier :)
06:53:01 <malebria> apfelmus: you mean Data Polygon = ... ?
06:53:33 <allbery_b> hm, that looks almost arrow-ish
06:54:01 <apfelmus> malebria: i'm not completely sure yet. what is the project you are working on?
06:54:20 <malebria> apfelmus: the project is just that file.
06:54:29 <malebria> apfelmus: is a port of libgpcl to haskell.
06:54:38 <malebria> http://www.cs.man.ac.uk/~toby/alan/software/
06:54:40 <lambdabot> Title: Alan Murta's Public Software (gpc)
06:55:15 <malebria> Saizan: in this case I think I prefer using do notaton...
06:55:16 <malebria> =D
06:57:20 <apfelmus> malebria: clipping polygons is definitively shorter to do in pure Haskell. any other requirements on your polygon lib for Haskell?
06:57:50 <apfelmus> do you use it for production or for learning Haskell?
06:59:08 <malebria> apfelmus: fror production.
06:59:13 <wolverian> ugh, gpc's license is ugly.
06:59:31 <malebria> I don't know math that much to write a polygon clip library.
06:59:58 <malebria> I thought about trying to understand how GPC do it, and them rewriting it in haskell.
07:00:15 <malebria> But I'm not sure if it's going to be that easy.
07:00:20 <tomh-> what does => do in a type definition?
07:00:46 <xerox> tomh-: it establishes constraints.
07:00:47 <allbery_b> "applies" a type class constraint
07:01:16 <tomh-> i see so for example Parens a => Parser Char a
07:01:17 <malebria> apfelmus: do you think it's an easy thing to do?
07:01:24 <tomh-> then a needs to be of the class Parens?
07:01:42 <xerox> tomh-: yes.
07:01:47 <tomh-> ok cool
07:01:56 <apfelmus> malebria: mh, learning the maths is surely worth it. most likely, there are some pointers on the web how the algorithm works.
07:02:05 <apfelmus> the difficult thing is numeric stability
07:02:25 <malebria> apfelmus: I just don't get much time right now.
07:02:40 <malebria> But maybe it could be faster than writing this C calls.
07:03:38 <apfelmus> mh. i know that there is a geometrical algorithm library in Haskell that does Voronoi diagrams and such, but i don't know about polygon clipping
07:04:21 <apfelmus> what polygons do you need to clip? if you clip by rectangular regions only, things are very easy
07:04:31 <apfelmus> *very/sufficiently
07:04:56 <malebria> apfelmus: it's not only rectangles..
07:05:07 <malebria> apfelmus: what library is this?
07:05:11 <malebria> http://www.codeguru.com/Cpp/misc/misc/graphics/article.php/c8965/
07:05:13 <lambdabot> Title: CodeGuru: Polygon Clipping
07:05:24 <malebria> This doesn't make me want to do it..
07:07:03 <apfelmus> the sutherland-hodgman is some 5 lines in Haskell
07:08:26 <malebria> It is also very efficient in two important cases, one being when the polygon is completely inside the boundaries, and the other when it's completely outside.
07:08:42 <malebria> So, maybe using gpc is a better option.
07:10:24 <apfelmus> ? the sutherland-hodgman clips against rectangles only and is 5 (five) lines in haskell (ok, maybe 10)
07:10:50 <malebria> apfelmus: and for non-rectangles?
07:11:04 <malebria> I'll have to use it for clipping complex polygons.
07:11:30 <apfelmus> then, the page states that you may not use sutherland-hodgman anyway, but Weiler
07:11:48 <apfelmus> (or some modern incarnation)
07:12:41 <malebria> yes..
07:13:29 <apfelmus> malebria: considering that this problem already took your day, i don't know whether the library binding was the 'faster' idea :)
07:15:10 <apfelmus> http://en.wikipedia.org/wiki/Weiler-Atherton
07:15:52 <Saizan> i'm curious about why you need to clip to non-rectangular regions
07:16:13 <malebria> apfelmus: If it wasn't I think it can be a good idea to do it latter.
07:16:22 <malebria> Saizan: I'm doing a spatial objects program.
07:16:34 <malebria> And they can have arbitrary geometry.
07:17:04 <apfelmus> spatial objects? then means trouble in 3D?
07:17:35 <malebria> No, in 2d.
07:17:57 <apfelmus> pfew. what are your spatial objects then?
07:18:45 <malebria> 2d polygons
07:20:07 <apfelmus> X)
07:20:58 <apfelmus> mh, i wonder how you expect to program such a thing and hope to avoid the maths, but it's your choice
07:21:57 <apfelmus> back to the library binding.
07:22:16 <apfelmus> you may want to put the polygons into ForeignPtrs
07:23:26 <apfelmus> Foreign.ForeignPtr
07:25:57 <apfelmus> malebria: so that the data remains at the library and you avoid the many conversion like verticesToCVertices
07:27:09 <apfelmus> kowey: we need a wikibook section about building a C-library binding
07:27:40 <kowey> apfelmus: good thought, probably under the specific tasks chapter
07:28:43 <apfelmus> kowey: perhaps. maybe even under "General Practices"? i mean, it's generally applicable
07:29:06 <apfelmus> but most likely, it doesn't really matter :)
07:29:54 <kowey> yeah :-) by "General Practices" i basically meant "best practices"... things you ought to be doing in general
07:30:25 <kowey> well, then again, building a standalone application doesn't fit into that
07:31:15 <apfelmus> indeed. maybe it should be entitled "interoperating with pre-functional OS" :)
07:34:15 <velco> is there any practical difference between map f ls and [f x | x <- ls] ?
07:34:26 <apfelmus> velco: look and feel
07:40:04 <malebria> apfelmus: sorry for taking so long, I was lunching.
07:40:14 <apfelmus> np
07:40:33 <malebria> apfelmus: I don't understand how changing it to ForeignPtr would avoid the conversions.
07:41:40 <apfelmus> currently, you have
07:41:40 <apfelmus> type Polygon a = Set (Bool, Set (a,a)) -- this type synonym should really have been there
07:42:03 <malebria> yes...
07:42:08 <malebria> This is a good synonym.
07:42:35 <malebria> I was afraid of type synonyms because of that problems described some time ago.
07:42:36 <apfelmus> with ForeignPtrs, you can do
07:42:37 <apfelmus> newtype Polygon = P (ForeignPtr (Double,Double)) -- I'd restrict myself to Doubles first
07:43:24 <apfelmus> malebria: these problems came from the fact that
07:43:25 <apfelmus> type Synonym a = (a,a)    is very different from    type Synonym = forall a . (a,a)
07:43:45 <apfelmus> unless you know what you are doing, you want the former
07:43:58 <malebria> yes..
07:43:59 <malebria> sure.
07:44:29 <malebria> But will this be godd?
07:44:43 <malebria> Polygon = P (ForeignPtr (Double, Double))?
07:45:06 <malebria> I think I prefer Polygon = Set (Bool, Set (a, a))
07:45:43 <xerox> Why not just Polygon = [a] ?
07:46:03 <int-e> why a set?
07:46:09 <apfelmus> (Polygon a = ...)
07:46:28 <xerox> Polygon = [Point]
07:46:46 <malebria> Why not a set?
07:46:59 <vincenz> malebria: sets aren't ordered
07:47:15 <daniel_larsson> The @pl command sometimes generates if' calls. Where is if' defined?
07:47:19 <apfelmus> Set (Double,Double) is a set of points
07:47:22 <vincenz> daniel_larsson: it isn't
07:47:23 <malebria> The way the library I'm using treats polygons is something as [[Point]]
07:47:35 <int-e> yes, that makes sense.
07:47:37 <malebria> Better [(Bool, [Point])]
07:48:14 <malebria> vincenz: good point.
07:48:14 <apfelmus> malebria: anyway, i don't think that you want a Haskell-native representation
07:48:17 <xerox> daniel_larsson: it isn't, define it yourself if you want to use it.
07:48:37 <apfelmus> after all, the library is going to do the work for you
07:48:43 <vincenz> apfelmus: can't have a set of points... sets aren't ordered unless you store a couple of points, which is rather overkill
07:48:47 <malebria> apfelmus: why not? I think it'll be much better to the user to have an Haskell-native polygon type.
07:49:15 <apfelmus> vincenz: yes, that's what i wanted to say. set of points is not a polygon
07:49:16 <xerox> vincenz: what do you mean?
07:49:25 <malebria> vincenz: But still I don't wan repetition, is list the best option?
07:49:30 <xerox> (with couple)
07:49:30 <vincenz> Set (point, point)  -- (prev,next)
07:49:37 <apfelmus> malebria: only if you code the clipping yourself
07:49:51 <xerox> what about a circular list :D
07:49:55 <malebria> apfelmus: I just want to offer a good haskell type for the user.
07:50:04 <malebria> apfelmus: for who is going to use the library.
07:50:33 <vincenz> xerox: what is the difference between a circular and infinite list?
07:50:58 <xerox> vincenz: succ ?
07:50:59 <int-e> malebria: Yes, that makes sense, have conversions from (and possibly to) a more natural Haskell representation.
07:51:13 <vincenz> xerox: o.O
07:51:26 <malebria> int-e: I think it's a very good thing.
07:51:46 <malebria> vincenz: are they implemented?
07:51:49 <malebria> sorry..
07:51:54 <malebria> xerox: are they implemented?
07:52:00 <vincenz> malebria: circular lists?
07:52:02 <vincenz> malebria: yes
07:52:04 <int-e> malebria: what apfelmus meant, I think, is that your binding shouldn't be converting all the time.
07:52:04 <malebria> yes.
07:52:11 <vincenz> > cycle [1,2,3]
07:52:12 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
07:52:28 <vincenz> malebria: since you don't have mutation, an infinite repeating list and a circular list are the same
07:52:29 <malebria> int-e: I just convert to make easier mallocs...
07:52:36 <apfelmus> yes.
07:52:41 <xerox> vincenz: but I mean something like loeb.
07:52:49 <vincenz> xerox: that's not a circular list
07:52:58 <malebria> What's loeb?
07:52:59 <xerox> one of the examples was
07:53:04 <vincenz> malebria: nothing to worry about
07:53:13 <vincenz> xerox: loeb is applying a lookup structure continuously to the results
07:53:18 <malebria> apfelmus: I can't thing about a way to do mallocs without all that "conversions".
07:53:20 <apfelmus> malebria: if you need to do converting, you'd best make Polygon an instance of Storable
07:53:46 <xerox> uhmm.
07:54:06 <malebria> apfelmus: hum... You're talking about write the same whole stuff in a more organized way, right?
07:54:18 <malebria> apfelmus: or do you think that there's a simpler way?
07:54:19 <vincenz> xerox: want the proof?
07:54:37 <vincenz> @let loeb x = fmap (\a -> a (loeb x)) x
07:54:38 <lambdabot> Defined.
07:54:43 <apfelmus> yes, there is no way around converting (if you don't want to avoid it)
07:54:45 <malebria> vincenz: The problem of lists is that it can have repetitions.
07:54:58 <emk> "The Haskell Road to Logic, Maths and Programming"++
07:54:59 <lambdabot> emk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:55:03 <vincenz> > loeb [const 1, (!!0), const 2, (!!4), (!!2)]
07:55:05 <lambdabot>  [1,1,2,2,2]
07:55:47 <emk> What a lovely math textbook--the Haskell makes it easier for me to keep the types straight and build some intuition.
07:59:27 <malebria> apfelmus: I think I'll write instances of Storable. Thanks for the tips.
08:00:07 <vincenz> malebria: you can forgive that during construction
08:00:09 <vincenz> erm
08:00:11 <vincenz> forbid
08:01:33 <malebria> vincenz: yes...
08:02:32 <vincenz> newtype UniqList = UniqList [a]
08:02:37 <vincenz> then hide that datacons in a module
08:02:49 <vincenz> give only functions that create new uniqlist that guarantee uniqueness
08:02:50 <apfelmus> malebria: yes, that seems reasonable. you can make good use of newtypes
08:02:50 <apfelmus> newtype Polygon a = Polygon (Contours a)
08:02:50 <apfelmus> newtype VertexList a = VertexList [(a,a)]
08:02:53 <vincenz> and use a list as view
08:03:28 <apfelmus> then, you can do the instances of Storable for every newtype
08:03:51 <vincenz> @hoogle storable
08:03:51 <lambdabot> Data.Array.Storable :: module
08:03:52 <lambdabot> Foreign.Storable :: module
08:03:52 <lambdabot> Foreign.Storable.Storable :: class Storable a
08:03:52 <malebria> apfelmus: yes, I wondered about that.
08:03:57 <vincenz> que es storable?
08:04:09 <malebria> apfelmus: but what difference does it make ForeignPtr?
08:04:17 <malebria> apfelmus: I can do all this with Ptr, no?
08:04:42 <apfelmus> ForeignPtr would allow you to garbage collect malloc-stuff
08:05:14 <dcoutts> jyp, so yeah, yi+gtk oddness, want me to explain what I did?
08:05:18 <malebria> apfelmus: but do you think it's needed?
08:05:30 <jyp> dcoutts: please
08:05:48 <apfelmus> malebria: no. it's only useful if you don't want to convert
08:05:49 <jyp> I can send you the latest patches if you wish.
08:05:58 <dcoutts> jyp, so I'm using http://www.cse.unsw.edu.au/~dons/code/yi , up to date
08:05:59 <lambdabot> Title: Index of /~dons/code/yi
08:06:26 <dcoutts> jyp, sure send me more recent patches if you think appropriate
08:06:55 <malebria> apfelmus: but I'll have to convert anyway, don't you agree?
08:07:19 <apfelmus> yes. thus, you need Storable but not ForeignPtr
08:07:35 <dcoutts> jyp, everything I did was pretty standard, cd gtk; runghc Setup clean; runghc Setup configure; runghc Setup build;
08:08:10 <jyp> dcoutts: using ghc 6.6 and latest gtk2hs I'm sure :)
08:08:17 <dcoutts> jyp, of course :-)
08:08:20 <dcoutts> jyp, I assume the standard key bindings are vi style right?
08:08:24 * apfelmus `ap` supper
08:08:31 <jyp> let me try
08:08:40 <dcoutts> so pressing 'i' or <insert> followed by ordinary keys should get some text entry
08:09:13 <malebria> apfelmus: what maybe I could avoid with ForeignPtr is all those {#call free_polygon#} and free in the polygonClip function.
08:09:48 <jyp> dcoutts: strange... that is working here, even missing the latest patches
08:09:58 <malebria> apfelmus: but how can I do plusPtr with ForeignPtrs?
08:10:21 <dcoutts> jyp, so you select the text box with the mouse and press say: ifoo and get "foo" in the buffer?
08:10:35 <jyp> dcoutts: try pre-loading a file on the command line
08:10:48 <dcoutts> jyp, that loads the file, but still no text entry
08:11:15 <apfelmus> malebria: (munch,munch) mh, not really. you have to use withForeignPtr
08:11:19 <dcoutts> jyp, it also seems to set a selection of all lines in the file except  the first one
08:11:33 <apfelmus> but i'd stick to storable
08:11:45 <dcoutts> jyp, clicking the text view resets the selection
08:11:49 <jyp> dcoutts: that latest behaviour is still not understood yet
08:12:15 <jyp> dcoutts: but the insertion should work with the latest patches which I sent you
08:12:24 <dcoutts> jyp, ok, I'll apply and retry
08:12:33 <velco> Having an IntMap x, what would be the best way to get a list of values, where the keys were within some range?
08:13:04 <vincenz> jyp: you're back
08:13:12 <jyp> vincenz: Yes I am
08:13:13 <dcoutts> jyp, you know that the selection is set by two 'marks', so I guess if one inserts text between the two marks then it'll extend the selection.
08:13:38 <jyp> dcoutts: The initial setting of the mark is not handled yet
08:13:57 <jyp> but the rest should work fine (latest patches)
08:14:05 <dcoutts> jyp, it may even be that if the two marks are at index i in the buffer and you insert at index i that one mark will end up at the end of the new text, since the two marks have opposite 'gravity' iirc
08:14:10 <xerox> hi dcoutts!
08:14:17 <dcoutts> hia xerox, long time no see!
08:14:29 <dcoutts> xerox, you working too hard?
08:14:45 <xerox> dcoutts, hard enough
08:14:58 <jyp> dcoutts: gravity should be ok; I have implemented the same behaviour in the non-gtk buffer
08:15:26 <br1> how do I shorten id $! value
08:15:30 <br1> ?
08:15:59 <dcoutts> value
08:16:36 <xerox> dcoutts, staying in another city for the whole day, means less time devoted at the computer.
08:16:44 <dcoutts> br1, in other words (id $! value) doesn't mean what you think it means.
08:16:53 <dcoutts> xerox, yeah, I bet.
08:17:21 <dcoutts> jyp, yay!
08:17:33 <jyp> dcoutts: \o/
08:18:08 <velco> Having an IntMap, what would be the best way to get a list of values, whose the keys were within some range ? (foo :: Int -> Int -> IntMap x -> [x])
08:20:42 <dcoutts> jyp, lots of stuff looks good!
08:20:46 <malebria> apfelmus: I think I don't need plusPtr if I have Storable.
08:20:56 <jyp> dcoutts: thanks :)
08:20:56 <malebria> apfelmus: Then I can use ForeignPtr
08:21:09 <roconnor> hmm, Phooey looks like it is only a proof of concept
08:21:09 <dcoutts> jyp, now all I need are selection and <delete> to work :-) (<backspace> works fine)
08:22:00 <ndm> roconnor: i have something in a similar vein, but also still proof of concept so far - proplang
08:22:08 <malebria> Do you think it's better to stick it to double then to keep these RealFrac a => a?
08:22:17 <jyp> dcoutts: lots remains to be done for sure... I mainly focused on the emacs mode, vi is mostly unknown to me.
08:22:50 <allbery_b> I gather the explicit type can be faster
08:22:52 <ndm> velco: toAscList ?
08:22:54 <dcoutts> jyp, ah, right. Yeah I mostly use nedit, which has key bingings much like gtk/windows
08:22:55 <jyp> dcoutts: ah, you mean mouse selection :)
08:23:05 * allbery_b needs to check if that'll speed up one of hi programs, not that it really needs optimization
08:23:09 <dcoutts> jyp, no, keyboard selection
08:23:15 <Saizan> velco: foo x y im = foldWithKey (\k v l -> if x < k && y > k then v:l else l) [] im  -- i don't think you can do much better than this
08:23:27 <dcoutts> jyp, perhaps that works already in emacs mode :-)
08:23:36 <jyp> dcoutts: afaict, yes
08:23:40 <dcoutts> ok, nice
08:23:54 * apfelmus back
08:24:30 * ndm hugs smallcheck
08:24:49 <ndm> @karma smallcheck
08:24:49 <lambdabot> smallcheck has a karma of 0
08:24:53 <ndm> @karma quickcheck
08:24:53 <lambdabot> quickcheck has a karma of 1
08:24:59 <dcoutts> ndm, can smallcheck check laziness properties yet?
08:25:00 <ndm> @karma+ SmallCheck
08:25:00 <lambdabot> SmallCheck's karma raised to 1.
08:25:04 <velco> ndm, Saizan: thanks
08:25:18 <ndm> dcoutts, no idea, can't StrictCheck do laziness properties?
08:25:30 <dcoutts> ndm, things like f _|_ = _|_
08:25:43 <ndm> dcoutts, i believe that StrictCheck can do that sort of thing
08:25:50 <apfelmus> malebria: mh, are you sure? i mean ForeignPtr is for treating foreign Ptr as if they were normal 'data' types
08:25:55 <dcoutts> ndm, StrictCheck !?
08:26:19 <ndm> dcoutts, yes, a tool by Olaf at Kent, checks strictness/laziness properties, and gives hints at where your code is too strict
08:26:43 <dcoutts> ndm, sounds good, another example: last (take n (replicate n 'a' ++ _|_)) /= _|_
08:26:44 <malebria> apfelmus: I think ForeignPtr is for automatcly calling a pre-defined free function, no?
08:26:44 <pejo> "too strict"?
08:26:58 <ndm> pejo: could be made more lazy
08:27:01 <malebria> apfelmus: I don't understand this alignment function on Storable class.
08:27:14 <ndm> dcoutts, yes, indeed - i don';t think its been released but i have talked to Olaf about it
08:27:18 <dcoutts> pejo, being too strict can often be the cause of severe perf problems
08:27:24 <allbery_b> too strict means you do unnecessary work; too lazy means you may build up too many unevaluated thunks. balancing them is key
08:27:56 <dcoutts> allbery_b, or that you do work too early (even if you'll use it later) and then end up using too much memory.
08:27:58 <ndm> allbery_b: usually too lazy means you build up unelvauated thunks deeply which don't add to the laziness - its not being lazy, its being lazy in the laziness that gives the space leaks
08:28:19 <allbery_b> sure
08:28:19 <apfelmus> malebria: yes, but upon garbage collection. so you can use a Ptr and leave it to garbage collection to free it. but i wouldn't recommend it in your case because you know that you don't need the temporary results anyway
08:28:25 <apfelmus> *anymore
08:28:48 <dcoutts> ndm, we have had a few strictness bugs in the ByteString.Lazy lib, we want to be able to specify and test them.
08:28:57 <pejo> ndm/dcoutts, so basically evaluating unecessary expressions?
08:29:22 <ndm> dcoutts, if StrictCheck can't solve it, then it doesn't really deserve its name or marketing materials - if you can't find it on Olaf's home page, send him an email
08:29:25 <dcoutts> pejo, or as I said to allbery_b, it can be evaluating things too soon and dragging too much into memory.
08:29:29 <pejo> Oh. allbery_b said that the line below.
08:29:34 <ndm> @google Olaf Chital StrictCheck
08:29:35 <pejo> I should be less sequential in my reading!
08:29:35 <lambdabot> No Result Found.
08:29:35 <apfelmus> malebria: mh, looks like Ptrs to your data structures must be multiples of alignment.
08:29:39 <ndm> @google Olaf Chital Kent
08:29:42 <lambdabot> http://www.zoominfo.com/people/level2page6978.aspx
08:29:42 <lambdabot> Title: James Chisum &mdash; Mark Chitjian : ZoomInfo Business People Information
08:29:53 <malebria> apfelmus: but how can I specify it?
08:30:01 <ndm> @google Olaf Chitil StrictCheck
08:30:05 <lambdabot> http://www.cs.kent.ac.uk/people/staff/oc/
08:30:05 <lambdabot> Title: Computer Science: Home page for O Chitil
08:30:14 <dcoutts> ndm, right'o
08:30:37 <ndm> dcoutts, the code is up there
08:30:40 <malebria> apfelmus: about Foreigns, I don't need final results also. After converting it to haskell types, they can be fred. Why do you think ForeignPtrs aren't a good choice?
08:30:55 <dcoutts> @tell dons we should formulate our strictness properties for ByteString.Lazy and check them with something like StrictCheck: http://www.cs.kent.ac.uk/people/staff/oc/
08:30:55 <lambdabot> Consider it noted.
08:31:09 <pejo> I think Haskell is too complicated for me.
08:31:22 <apfelmus> malebria: well, just say alignment _ = 4 (or 8) or so. i think it's used for peekByteOff. it says how to align an array of stuff
08:31:56 <dcoutts> pejo, na, it's just that it's a tricky business trying to build something really simple.
08:32:14 <malebria> apfelmus: I thought about that too, but isn't  this sizeOf?
08:32:15 <dcoutts> making libs that are really simple and easy to use is hard
08:32:37 <pejo> dcoutts, I don't even do that, yet it's too complicated. :-)
08:32:50 <dcoutts> heh, don't look so hard
08:33:03 <dcoutts> malebria, no, alignment is different
08:33:11 <apfelmus> malebria: no, sizeof can be different from the alignment. so sizeof(short) = 2, but you may have to align words at multiples of 4
08:33:26 <malebria> so alignment >= sizeOf?
08:33:32 <apfelmus> perhaps, yes.
08:33:36 <apfelmus> err, sometimes, yes
08:33:46 <malebria> sometimes?
08:33:55 <malebria> How can I get the alignment of a C structure?
08:33:57 <dcoutts> malebria, no, I might have a 100 byte structure but it only needs to be aligned to double word boundaries (ie 8)
08:34:09 <apfelmus> malebria: c2hs should be able to tell you
08:34:51 <malebria> apfelmus: I don't know how.
08:35:05 <pejo> Does c2hs keep track of machine alignment things?
08:35:06 <ndm> would anyone describe Simon PJ or Simon Marlow as *not* career academics?
08:35:08 <apfelmus> neither do i :(
08:35:12 <dcoutts> apfelmus, malebria, actually I don't think c2hs can tell you.
08:35:30 <malebria> dcoutts: but how can I know then?
08:35:49 <pejo> ndm, wasn't SPJ professor somewhere before he went to MS Research?
08:35:55 <dcoutts> malebria, using alignof the first member in your structure is a good bet
08:36:05 <ndm> pejo: yes, Glasgow
08:36:22 <dcoutts> malebria, basically there's a natural alignment for everything on your machine, it'll be 4 or 8 bytes depending on the arch
08:36:35 <dcoutts> malebria, so alignof (undefined :: Int) is a pretty safe bet.
08:36:43 <huschi> making hs-plugins tells me that it can't find Language.Haskell.Hsx.
08:36:47 <huschi> where can i find it?
08:36:48 <malebria> dcoutts: thanks. =D
08:37:24 <malebria> dcoutts: I think you meant alignment (undefined :: Int)
08:37:29 <dcoutts> yeah
08:37:32 <pejo> ndm, full professor is a nice career, imho.
08:38:56 <br1> dcoutts: Why?  How can I get what I want?
08:39:11 <JKnecht> wonder if he went under contract
08:39:22 <pejo> ndm, which way do you want the proof to go, that they are career academics, or that they aren't? (We aim to please!)
08:39:41 <ndm> pejo: just someone on the mailing list said they weren't, where as i would have said they definately were
08:39:53 <ndm> pejo: just trying to figure out if i was right or wrong, really
08:41:10 <dcoutts> @source $!
08:41:10 <lambdabot> $! not available
08:41:21 <br1> f $! x    =  x `seq` f x
08:41:42 <int-e> @source ($!)
08:41:43 <lambdabot> ($!) not available
08:41:46 <int-e> aww :(
08:42:18 <dcoutts> br1, id $! value = value `seq` id value = value `seq` value = value
08:42:56 <dcoutts> br1, look at it this way, a value only gets evaluated if it's demanded
08:43:22 <dcoutts> so when you demand (id $! value) then yes indeed, value will be demanded
08:43:31 <dcoutts> but it'll also be demanded if it's just value
08:43:55 <dcoutts> what you want to do is make value get demanded when some other value in your program is demanded
08:44:06 <dcoutts> like say the overall return value of your function
08:44:19 <malebria> apfelmus: do you think it's better defining a new data type than creating a type synonym.
08:44:30 <br1> mmmm
08:44:39 <dcoutts> br1, ... =  ...  value `seq` result
08:44:45 <malebria> apfelmus: instance RealFrac real => Storable (real, real)
08:45:06 <br1> mmmm
08:45:08 <br1> I'll play with it a little.  Thanks!
08:45:19 <dcoutts> br1, so when the function is called it's because it's result is being demanded and that use of seq there sets up a dependency in the demand order
08:45:45 <malebria> apfelmus: with this second option I get a obscure warning:
08:45:53 <malebria> Warning: orphan instances: instance base:Foreign.Storable.Storable [(,)] = $f1
08:46:27 <malebria> apfelmus: I think that kind of instance is not Haskell98, right?
08:46:33 <dcoutts> (actually seq doesn't impose an order of evaluation)
08:47:19 <rahikkala> Is there a significant difference in performance between "reverse (0:l)" and "l ++ [0]"?
08:47:20 <vincenz> seq only does something if the value returned by seq is seq'd itself right?
08:48:08 <br1> rahikkala: I think the second is better because I can be fused
08:48:14 <dcoutts> vincenz, well, demanded
08:48:16 <br1> s/I/it
08:48:32 <dcoutts> vincenz, the demand can be due to a dependency imposed by seq
08:48:48 <malebria> apfelmus: and about ForeignPtrs, I didn't understand why you don't like it in this case.
08:48:50 <apfelmus> malebria: yes, it's not in Haskell98. but you can use a newtype
08:48:50 <apfelmus> newtype Point a = Point (a,a)
08:48:57 <vincenz> dcoutts: oh?
08:49:37 <dcoutts> vincenz, seq isn't the only way of demanding values, things like case do that too
08:49:47 <vincenz> dcoutts: right, I know
08:49:53 <vincenz> dcoutts: not sure about your second statement, however
08:49:55 <vincenz> takuan: vlaams?
08:50:13 <takuan> yup
08:50:19 <takuan> why?
08:50:25 <vincenz> that's why
08:50:29 <dcoutts> vincenz, it was just a not very clear way of saying what I just said :-)
08:50:55 <malebria> apfelmus: do I have to alloc memory in defining poke?
08:51:03 <vincenz> dcoutts: ah :)
08:51:14 <malebria> apfelmus: or it alloc the memory of sizeOf automatcly?
08:51:23 <dcoutts> vincenz, the point is that seq just sets things up such that if your program ever demands the result of (seq a b) then it demands both a and b (but in no particular order)
08:51:31 <apfelmus> malebria: no, poke assumes that the memory is already allocated
08:52:06 <dcoutts> vincenz, so counter-intuitively, seq doesn't impose any sequencing
08:52:20 <vincenz> Only if it is sequenced
08:52:30 <dcoutts> huh?
08:52:31 <apfelmus> malebria: ah, i found it. instead of calling malloc and free, you can use Foreign.Marshal.Alloc instead
08:52:56 <vincenz> dcoutts: misinterpretation of your word 'sequence'
08:52:56 <malebria> apfelmus: yes, I've seen it..
08:53:07 <malebria> apfelmus: so I always must allocate memory before calling poke?
08:53:53 <apfelmus> yes. but Foreign.Marshal.Alloc.alloca can do malloc and free for you (if you supply the right sizeOf)
08:54:40 <malebria> apfelmus: yes, I got it. There's also new, which is very nice.
08:55:26 <apfelmus> yeah. but maybe you get in difficulties because the number of bytes to be allocated depend on the number of Points in your Polygon. i don't know whether Storable is made for that.
08:55:43 <malebria> apfelmus: It doesn't make any difference.
08:55:48 <malebria> apfelmus: this is not a problem.
08:55:56 <malebria> apfelmus: my doubt is about using ForeignPtr or not.
08:56:12 <malebria> apfelmus: the problem with Alloc.alloca is that I can't return the Ptr with allocated memory.
08:56:27 <apfelmus> yes, that's intended.
08:56:43 <apfelmus> the Ptr a is only valid inside the function you supply to alloca
08:57:42 <apfelmus> a think that you might want to poke around in the foreign function interface documentation http://www.cse.unsw.edu.au/~chak/haskell/ffi/
08:57:42 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
08:57:47 <malebria> apfelmus: I don't think it's a good option for the Storable instance.
08:57:57 <malebria> apfelmus: I'm looking at GHC haddock.
08:58:49 <apfelmus> the haddocks are a bit sparse. there is an extra report on how to use the ffi
08:58:57 <malebria> apfelmus: but why do you think I shouldn't use ForeignPtrs?
08:59:25 <gotaku> Is there a haskell mode for scite?
09:01:01 <apfelmus> the point about ForeignPtr is that they can live very long. if i understand you correctly, the pointers allocated in polygonClip don't survive the function, i.e. you can easily tell when they need to be deallocated. for that, ForeignPtr is likely to be overkill
09:01:26 <apfelmus> in a sense, you'd just use withForeignPtr instead of alloca
09:01:58 <bringert> dcoutts: I got untarring running in constant space now
09:02:03 <bringert> it took a while
09:02:05 <dcoutts> bringert, woo!
09:02:15 <dcoutts> bringert, so, what have we learned?
09:02:23 <bringert> laziness is tricky
09:02:27 <dcoutts> apart from the fact that it's harder than it looks :-)
09:02:27 <dcoutts> yeah
09:02:59 <bringert> one thing is that you will have to force the typle returned from splitAtST
09:03:33 <bringert> I had some really strange things happening for a while, where the laziness would go away if runGet was inlined
09:03:51 <dcoutts> bringert, ie use case splitAtST of (,) -> rather than let ?
09:03:57 <bringert> dcoutts: yeah
09:04:28 <dcoutts> bringert, interesting
09:04:34 <bringert> dcoutts: I also haven't been able to figure out how to get the current offset value in the Get state to be sensible if getBytes runs out of data
09:04:54 <huschi> bringert: are you one of the authors of haskelldb?
09:05:02 <bringert> huschi: maintainer, yes
09:05:07 <dcoutts> bringert, it's a case where you'd want to use an unlifed pair, like (# , #)
09:05:19 <dcoutts> except they're non standard
09:05:22 <huschi> bringert: i've got a problem, would you please help me?
09:05:28 <bringert> or a bang-pattern
09:05:31 <dcoutts> yeah
09:05:55 <bringert> but if would of course be better to have it in the functions itself, as with (# , #)
09:06:00 <bringert> huschi: what's the problem?
09:06:03 <malebria> apfelmus: hum, you're right.
09:06:05 <huschi> bringert: DBDirect always tells me sth like: DBDirect: user error (Couldn't load Database.HaskellDB.HSQL.SQLite2.driver from package haskelldb-hsql-sqlite2-0.10)
09:06:06 <dcoutts> bringert, so can we hide away that detail in the Get module ?
09:06:34 <bringert> huschi: what GHC version is that?
09:06:38 <huschi> ghc 6.6
09:06:51 <bringert> huschi: hs-plugins does not work with 6.6 yet
09:06:51 <huschi> and it should be sqlite3 instead of sqlite2
09:07:07 <huschi> ah. is there another way to this then?
09:07:10 <bringert> dcoutts: yes, but not in ByteString, if we want to use splitAtST there
09:07:25 <huschi> maybe rewriting DBDirect? is it possible without too much effort?
09:07:41 <allbery_b> oo, ghc6.6 has landed on freebsd
09:07:59 <bringert> huschi: you can to link in the right driver by hand. for DBDirect, that would mean some hacking, yes. But DBDirect is very simple.
09:08:09 <emu> 4 months later
09:08:20 <huschi> bringert: ok, i will try.
09:08:26 <allbery_b> yeh, well, blame releng for keeping the tree locked for so long
09:08:45 <bringert> huschi: basically just replace dynConnect with the connection function that you want
09:08:46 <allbery_b> 3 months was a bit excessive
09:08:53 <SimonRC> Hey guys, a question...
09:09:06 <huschi> bringert: ok, i will do. will this also work with SQLite3?
09:09:10 <psnl> is a way of getting infomation
09:09:14 <SimonRC> While reading  http://www.ias.ac.in/resonance/May2005/pdf/May2005Classics.pdf  , I decided to bash out that pi program in Haskell...
09:09:31 <bringert> huschi: I think so
09:09:37 <huschi> ok.
09:09:46 <bringert> huschi: just use the right module
09:10:08 <SimonRC> since it is an infinite series, I thought it would be nice to write it in the same style as was done in Why FP Matters, i.e. a steam of improving approximtions...
09:10:11 <huschi> bringert: i will do so :)
09:10:18 <bringert> huschi: i.e. Database.HaskellDB.HSQL.SQLite3
09:10:36 <bringert> huschi: or Database.HaskellDB.HDBC.SQLite3
09:10:44 <psnl> SimonRC: wow, long question
09:10:47 <SimonRC> I found I needed this function, and was suprised that I had to write it...
09:10:54 <SimonRC> progress z f (x:xs) = z : progress (f z x) f xs
09:10:59 <SimonRC> is there a proper was to do this?
09:11:05 <allbery_b> er?
09:11:12 <apfelmus> foldl
09:11:13 <allbery_b> :t iterate
09:11:15 <lambdabot> forall a. (a -> a) -> a -> [a]
09:11:24 <SimonRC> no
09:11:35 <apfelmus> ah, scanl
09:11:40 <apfelmus> :t scanl
09:11:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:11:42 <allbery_b> hm, right, that's a scan
09:11:42 <SimonRC> it is like unfold and zipwith combined...
09:11:48 <huschi> bringert: i'm using HSQL. i couldn't compile the HDBC driver because there was an error that some type class starting with an I was not found.
09:11:53 <bringert> dcoutts: so, do you think we should replace splitAt with splitAtST in ByteString?
09:11:53 <apfelmus> @let progress z f (x:xs) = z : progress (f z x) f xs
09:11:54 <lambdabot> Defined.
09:12:00 <apfelmus> :t progress
09:12:01 <lambdabot> Not in scope: `progress'
09:12:06 <emu> :t L.progress
09:12:07 <lambdabot> Couldn't find qualified module.
09:12:11 <allbery_b> @type doesn't see @let
09:12:13 <lambdabot> parse error on input `let'
09:12:22 <SimonRC> indeed it si, silly me
09:12:23 <apfelmus> :t \z f (x:xs) = z : progress (f z x) f xs
09:12:24 <lambdabot> parse error on input `='
09:12:29 * SimonRC fwaps SimonRC.
09:12:32 <emu> @type fix (\f z f (x:xs) -> z : progress (f z x) f xs)
09:12:34 <lambdabot>     Conflicting definitions for `f'
09:12:34 <dcoutts> bringert, not sure yet, lets experiment with it in the Get module for the moment
09:12:34 <lambdabot>     In a lambda abstraction
09:12:34 * SimonRC oofs.
09:12:35 <apfelmus> :t \z f (x:xs) -> z : progress (f z x) f xs
09:12:36 <bringert> huschi: it should work using the current darcs version of HBDC
09:12:36 <lambdabot> Not in scope: `progress'
09:12:40 <emu> @type fix (\g z f (x:xs) -> z : g (f z x) f xs)
09:12:44 <huschi> bringert: Database/HaskellDB/HDBC.hs:176:19:
09:12:44 <huschi>     Not in scope: type constructor or class `IConnection'
09:12:47 <lambdabot> forall a a1. a1 -> (a1 -> a -> a1) -> [a] -> [a1]
09:12:52 <apfelmus> :t scanl
09:12:52 <huschi> bringert: ok.
09:12:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:13:25 <SimonRC> :t let progress z f (x:xs) = z : progress (f z x) f xs in progress
09:13:26 <lambdabot> forall a a1. a -> (a -> a1 -> a) -> [a1] -> [a]
09:13:35 <huschi> bringert: i could help if it is not too difficult.
09:13:36 <gotaku> Is there a good haskell ide?
09:13:41 <SimonRC> make that "flip scanl"
09:13:43 <emu> yea
09:14:09 <bringert> huschi: what would you like to help with?
09:14:12 <malebria> apfelmus: the problem is that in poke I need to alocate the things that are not in the struct.
09:14:23 <malebria> apfelmus: in the struct is just the pointer for it.
09:14:30 <huschi> bringert: working on hdbc to get the error corrected.
09:14:35 <malebria> apfelmus: Then I need to {#call free_polygon#}
09:14:42 <malebria> apfelmus: it'd be good to have this automatic.
09:14:48 <allbery_b> gotaku: define "good"
09:15:10 <bringert> huschi: I don't think it's an error in HBDC. It's rather that the current darcs version of HaskellDB depends on the current darcs version of HDBC
09:15:34 <huschi> bringert: ok.
09:15:46 <huschi> you mean my version of hdbc i too old?
09:15:57 <gotaku> allbery_b, something usable.
09:16:02 <Anon4888> Is there a way to define the type of all values of type a where a is of class C?
09:16:10 <Anon4888> or do I have to invent a new data constructor?
09:16:30 <allbery_b> forall a. Class C => a -- ?
09:16:41 <apfelmus> malebria: that's strange. i mean, poke should write to a pointer that is already allocated.
09:16:42 <Anon4888> hmm, that's not working
09:16:50 <Anon4888> Thanks, let me play with it some more
09:16:54 <allbery_b> er, Class a => a
09:17:03 <Anon4888> I know
09:17:11 <Anon4888> thanks
09:17:23 <allbery_b> depenmds on context though, foralls in the wrong place will cause odd effects
09:17:26 <malebria> apfelmus: yes, the first is allocated, but not the pointers inside the structure.
09:17:50 <br1> gotaku: emacs
09:17:59 <allbery_b> ...and so do class constraints in the wrong place
09:18:09 <malebria> typedef struct {int num_vertices; gpc_vertex *vertex;} gpc_vertex_list;
09:18:19 <gotaku> emacs is not an IDE
09:18:25 <malebria> apfelmus: I must allocate the memory to the gpc_vertex *vertex
09:18:48 <apfelmus> malebria: ah, yes. mh, this will be difficult because the size of the inner structures are not known beforehand, are they? the problem is that sizeof ignores it's first argument.
09:18:59 <allbery_b> no, it's an integrated everything environment :)
09:19:03 <malebria> apfelmus: they're all known.
09:19:06 <malebria> apfelmus: this is not a problem.
09:19:12 <malebria> apfelmus: I'm using newArray
09:19:39 <malebria> apfelmus: the problem is freeing this memory. There's a C function free_polygon, but I'd like to automate its call.
09:19:52 <allbery_b> on windows there is visual haskell for visual studio; portably there's ecipse + http://eclipsefp.sourceforge.net
09:19:54 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
09:19:58 <allbery_b> both are still youngish
09:20:23 <apfelmus> malebria: ah, you mean that poke allocates a new gpc_vertex *vertex but the old one isn't freed yet?
09:20:28 <malebria> @hoogle [(a, b)] -> ([a], [b])
09:20:29 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
09:21:17 <malebria> apfelmus: I don't know what it does with the old one, because who do this is newArray.
09:21:28 <malebria> apfelmus: Must I free Ptr before calling newArray?
09:21:34 <malebria> apfelmus: I think it should free by itself.
09:21:55 <dcoutts> ndm, I've got a demo prog using Gtk2Hs with the threaded rts.
09:21:59 <malebria> apfelmus: What I meant is that I can't just free polygon, because I need to free the inside pointers.
09:22:27 <LoganCapaldo> Prelude.stuckUnzip :: [(a, b)] -> ([(a,b)], [a], [b])
09:23:07 <apfelmus> malebria: ah
09:23:22 <malebria> apfelmus: do you think I must free the pointer before calling newArray?
09:23:44 <apfelmus> maybe.
09:24:40 <ndm> dcoutts, like my gtkconsole thing?
09:24:45 <malebria> apfelmus: It doesn't call free.
09:25:08 <dcoutts> ndm, it's a simple variant on the demo/concurrent/Progress.hs
09:25:19 <dcoutts> ndm, it'll be in darcs shortly so you can see
09:25:49 <dcoutts> ndm, basically it involves saying postGUIAsync $ do ...
09:26:08 <dcoutts> ndm, for any GUI actions in a thread that isn't the main GUI thread
09:26:10 <malebria> apfelmus: but this is a C thing. If I do malloc two times on the same pointer, is it going to free the first allocation?
09:26:11 <ndm> dcoutts, i.e. will it generalise to gtkconsole as i have in my thing?
09:26:15 <malebria> apfelmus: I think it's..
09:26:20 <ndm> dcoutts, sounds promising
09:26:29 <gotaku> I hate the indenting in emacs.
09:26:34 <dcoutts> ndm, probably, all you do is call a couple text buffer functions in one thread right?
09:26:43 <ndm> dcoutts, pretty much
09:26:50 <dcoutts> ndm, should work the same way then
09:27:02 <ndm> dcoutts, is this a new Gtk2Hs primitive?
09:27:41 <dcoutts> ndm, it's just an easy to use wrapper over an existing function (idleAdd)
09:27:46 <apfelmus> malebria: mh, i wouldn't rely on that. i'm glad that haskell has garbage collection :)
09:27:46 <bringert> dcoutts: I've pushed Get which uses splitAtST now
09:27:52 <dcoutts> bringert, great
09:27:57 <ndm> dcoutts, didn't that completely fail for me?
09:28:07 <dcoutts> ndm, no, that was inputAdd
09:28:19 <ndm> dcoutts, is this going to be in teh new release?
09:28:26 <dcoutts> ndm, yep, in the next RC
09:28:30 <ndm> and chances of a new demo windows installer?
09:28:34 <dcoutts> yep
09:28:35 <ndm> with this change
09:28:37 <dcoutts> yep
09:28:37 <ndm> yay!
09:28:42 <dcoutts> @yarr!
09:28:42 <lambdabot> Keelhaul the swabs!
09:29:08 <dcoutts> ndm, and I'll want you to test opengl in win32 too
09:29:26 <dcoutts> ndm, it's a bit hard to test via a terminal server since it's only 16 colours
09:29:29 <ndm> dcoutts, i can try and compile a demo if you tell me which one - never tried opengl though
09:29:46 <dcoutts> there's only one opengl demo, it'll be obvious
09:30:11 <dcoutts> ndm, and I'm going to try and make it work in ghci in windows...
09:30:24 <apfelmus> malebria: unfortunately i have to go in a moment. hope i could help a bit
09:30:31 <ndm> dcoutts, woohoo, sounds like all good stuff - having GuiHaskell working once more would be very nice :)
09:30:39 <dcoutts> @arr!
09:30:39 <lambdabot> Arrr!
09:30:47 <ndm> although i'm currently knee deep in PhD'ness, so will have to wait quite a while
09:31:08 <vincenz> only knee deep?
09:32:03 <ndm> well its more knee deep upside down, i.e. entire head burried in phd stuff
09:32:29 <huschi> bringert: it worked. thanks for your help.
09:32:42 <bringert> huschi: you're welcome
09:34:44 <ndm> dcoutts, when is the fabelled RC likely to hit?
09:35:08 <dcoutts> ndm, either today or some time this week
09:36:56 <huschi> bringert: is there any recent guide for getting started with haskelldb?
09:37:08 <bringert> huschi: no :-)
09:37:28 <huschi> huschi: that's pity. so i will try on my own.
09:43:44 <bringert> dcoutts: htar now uses 2 cpu secs and 3 mb ram to untar a 488 mb tar file consisting of five 97 mb files. BSD tar takes 3 cpu secs and 492 kb ram. On my machine they both take about 13.5 wall secs, so they're pretty IO-bound.
09:43:56 <kolektiv> hi all (if anyone's around). does anyone have any recommendations for works to read on designing/composing programs using haskell? i have a fairly strong programming background, although have been working in an OO style for some time. i'm finding it difficult to know how to approach programming a solution using haskell. are there any references worth reading? i have a reasonable grasp of the theory i think, but something like a "way to thi
09:43:59 <dcoutts> bringert, cool
09:44:26 <mahogny> kolektiv, large scale composition, basics?
09:44:45 <dcoutts> bringert, yeah, due to GC we take more memory since we allocate lots of chunks rather than a single mutable chunk. It's not a big price to pay imho.
09:45:08 <dcoutts> bringert, and if anyone cared, they could reduce the ghc heap size I think, see how low you can go... :-)
09:45:32 <bringert> dcoutts: it's interesting that we use less CPU time though. I would have thought we would be the same for the code, plus some GC overhead.
09:45:37 <kolektiv> mahogny - basics would be fine. i'm more comfortable in things like lisp, ocaml, etc. where i can express myself in an OO style when needed, and i then break the problem down in ways which aren't really "functional" i have a feeling - they don't seem right (or sometimes possible) in haskell
09:45:44 <dcoutts> bringert, actually for that app, a smaller heap size would probably be faster since it'd scribble over less memory
09:45:52 <dcoutts> bringert, hmm, that's interesting.
09:46:32 <kolektiv> mahogny - i should emphasise that i'm not a lisp expert either - or ocaml! i code in c#, c++ etc. as a day job, but i love languages and theory, and am trying to broaden myself with haskell
09:47:07 <mahogny> kolektiv, if you have done object oriented coding in for example C then it is no problem. myclass.f(...) is converted to f myclass ...  etc. if you need interfaces then look up on the class system
09:47:26 <bringert> dcoutts: it wors fine with -M1m
09:47:30 <bringert> works
09:47:45 <dcoutts> aye
09:47:51 <allbery_b> there was a message about OO vs. parametric polymorphism on haskell-cafe this morning...
09:48:47 <allbery_b> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021754.html
09:48:58 <lambdabot> Title: [Haskell-cafe] OOP < parametric polymorphism, http://tinyurl.com/36nj9k
09:49:11 <kolektiv> mahogny - yeah - i'm more interested in how you go about designing a program. i could just try and shoehorn my usual thinking into haskell, but i'm not sure i'll learn much. how would you go about designing, say, a web server? in an imperative OO style I might start by considering the server as an object, then perhaps creating classes which implement handling of certain requests, etc. essentially i'd model my actors and responsibilties. i'
09:49:19 <allbery_b> basically showing off how things translate from one to the other (and sometimes don't translate the other way)
09:49:34 <kolektiv> allbery_b: i'll look at that certainly
09:49:35 <Saizan> even if you know how to translate the OO patterns in functional style that doesn't mean you should use them
09:49:35 <pejo> kolektiv, or look at OOHaskell, and O'Haskell for OO-thinking inspiration. :-)
09:49:35 * qwr has noticed, that most OO code really don't use polymorphism. and when it uses, its usually best done with interface-classes - which are basically bunch of function references
09:49:59 <kolektiv> pejo: heh - i think i'm more trying not to think OO!
09:50:05 <bringert> kolektiv: you could start by reading some existing Haskell programs
09:50:36 <Saizan> kolektiv: don't write such long lines, they get truncated by IRC
09:50:53 <pejo> kolektiv, for the webserver example - Marlow has written an article about it. And I think bringert (?) has some code which is updated more recently for that webserver in questino.
09:50:54 <mahogny> kolektiv, I would design it the same way in haskell unless I wanted to make use of haskell-specific features like threads using CPS etc. I think the major thing that would affect my design is the simplicity of using partially evaluated functions for callbacks and in lists. in the end, depends on how crazy you want your design to be
09:50:54 <kolektiv> bringert - yes, i am trying to do that where possible - i was just wondering if there was a good reading list as well
09:51:02 <kolektiv> Saizan - apologies!
09:51:24 <allbery_b> "my actors and responsibilties. i" <<- your message got chopped off here
09:51:38 <kolektiv> ah apologies to all on line length
09:51:44 <kolektiv> my client seems to elide that
09:51:52 <allbery_b> IRC servers silently truncat at 512 characters
09:52:02 <allbery_b> truncate even
09:52:08 <bringert> kolektiv: here's a web server: http://www.cs.chalmers.se/~bringert/darcs/hws-cgi/src/Main.hs
09:52:10 <kolektiv> i learn something every day!
09:52:14 <kolektiv> bringert - thank you
09:52:48 <vincenz> bringert: ouch
09:53:06 <kolektiv> bringert: i think that may take me a while to read :)
09:53:34 <pejo> qwr, does any of the popular OO languages have a type system which can express polymorphism? (Casting to void * excluded).
09:53:55 <ndm> pejo: Java, C# (versions 5 and 2 respectively)
09:54:04 <allbery_b> generics come close
09:54:09 <kolektiv> pejo - generics would be a close approximation in usage perhaps?
09:54:28 <pejo> ndm, thinking of parametric polymorphism?
09:54:47 <velco> same answer, C++ too
09:57:26 <kolektiv> c++ less so perhaps, as templates generate type specific code for each usage?
09:57:31 <bringert> kolektiv: well, that's just one of the modules :-)
09:57:47 <qwr> pejo: behavioral polymorphism is usually somewhat supported :)
09:57:54 <bringert> kolektiv: there must be better examples to look at.
09:58:09 <kolektiv> bringert - heh, i wasn't expecting simplicity yeah! a web server was just a top of head example
09:58:10 <pejo> kolektiv, that's more an efficiency issue - nothing prevents a functional compiler from generating a function for each instantiated type of a function.
09:58:23 <kolektiv> pejo - true
09:59:16 <kolektiv> bringert: reading code is certainly a large part of my task though - i'll try and find some interesting an descriptive stuff
09:59:18 <pejo> I should learn more about this some day - I just need to find more time. *cough*
09:59:56 <pejo> kolektiv, I've looked at GHC some. It's quite readable I must say.
10:00:03 <kolektiv> i wish i had more time - i'm studying ocaml and haskell on the morning commute, and category theory on the evening one...
10:00:05 <benc__> 6
10:00:07 <benc__> oops
10:00:08 <benc__> sorry
10:00:44 <michaelw> kolektiv: move further away from work? :)
10:01:00 <kolektiv> when the day job is architect for large scale ecommerce systems, all i end up with is a headache :)
10:01:01 <pejo> michaelw, heh, I was just going to complain that I live 3 minutes from work. ;)
10:01:14 <kolektiv> michaelw: it's an hour and a half each way now!
10:02:34 <kolektiv> i'm trying to persuade my company to give me a half day personal hacking/research time as well per week - nearly there! would give me some lisp and ruby hacking time haha
10:05:42 <qwr> kolektiv: sneak kawa or something like that into the ecommerce system and use it for hacking ;)
10:06:27 <malebria> How is CDouble different from Double?
10:06:29 <kolektiv> qwr - haha - it's on .NET at the moment, so i'd need to port Kawa to j# perhaps first...
10:06:35 <malebria> Can it have more precision?
10:06:47 <qwr> .net should give opportunities with F# which is mostly ocaml ;)
10:07:23 <kolektiv> qwr: i'm already playing with f# - i nearly programmed part of our system in before being gently informed that would be a good way to get fired...
10:09:23 * qwr is lucky enough to have kawa accepted... and the macros allow quite nice staff
10:09:40 <ndm> malebria: for interfacing with C, its exactly like C's "double", which isn't guaranteed to be exactly like Haskell's (although very probably is)
10:10:21 <malebria> ndm: I'm writing a port for as C library, and I'm wondering about using Double as the functions types.
10:10:27 <malebria> ndm: and converting it to CDouble.
10:10:35 <kolektiv> qwr: sadly there's a limit to what i can really do - i need to bear in mind that there's many other programmers who need to be able to understand and modify anything i design... ah well :)
10:10:40 <ndm> malebria: don't know the exact details, but should be pretty easy
10:10:46 <malebria> ndm: do you think I should keep CDouble, or use Real a => a ...
10:11:02 <ndm> malebria: no idea, barely even used floating point numbers ever in Haskell
10:11:09 <malebria> ndm: ok..
10:11:22 <michaelw> is there something to graph module dependencies?
10:11:31 <malebria> ndm: thanks.
10:14:36 <kolektiv> just out of interest, how many here are using haskell in an academic context, and how many for commercial? or just fun?
10:14:56 <ndm> i'm using at as an academic
10:15:10 <michaelw> me too
10:15:17 <allbery_b> just for fun, here, pretty much --- while I work for a university, I don't use Haskell in that context (my coworkers would kill me...)
10:15:24 <velco> I'm using it to prototype stuff I later code at work  in C
10:15:32 <pejo> kolektiv, this channel is a mixture. Some people here are employed by the companies that show up in the "Commercial users of functional programming"-context.
10:16:16 <kolektiv> yeah - about what i'd have guessed i think.
10:16:32 <astrolabe> I'm using it for fun, but I've managed to blag using it at work too.
10:17:10 <allbery_b> have some vague ideas about throwing Haskell at system configuration management, but no intention of using ece.cmu.edu as a guinea pig :)
10:17:16 <koala_man> how do you get the last n elements from a list?
10:17:32 <sm> morning all
10:18:04 <ndm> koala_man: drop (length list - number_you_want) list
10:18:10 <koala_man> thanks
10:19:31 <kolektiv> i wrote part of a change management sys at my last job in scheme. i still get phone calls. filed under mistake that one... :)
10:20:04 <allbery_b> maybe andrew.cmu.edu is looking for folks --- they use scheme for that kind of thing :)
10:20:09 <ndm> kolektiv: do you get paid for these phone calls? that can make haskell valuable
10:22:06 <kolektiv> ndm - haha - no, they're more of the begging type - "please tell us how to make it do this..."
10:29:25 <dancor> to make my own exception type which just has an error string, do i have to use throwDyn?
10:30:04 <dancor> is data Exception just for non-user-def'd exceptions?
10:30:56 <qwr> use fail "blaah"?
10:31:18 <qwr> or error "blaah"
10:31:40 <allbery_b> you can also throw a dynami exception, although IMO that looks kinda painful
10:31:59 <dancor> qwr: i want it to be catchable
10:32:22 <allbery_b> Control.Exception.catch can catch error
10:32:24 <dancor> allbery_b: why is it painful
10:32:51 <dancor> allbery_b: i want my own exception, aren't the benefits of separated exception types well-established?
10:33:00 <allbery_b> alterntely you can avoid exceptions entirely and use MonadError
10:33:29 <michaelw> dancor: Control.Monad.ErrorT
10:34:10 <allbery_b> dancor: yes and no.  I kinda wish Exception were a type*class*
10:34:31 <allbery_b> sure, my own type, but why delve into Dynamic?
10:35:05 <dancor> yeah it seems like typeclass would be better
10:35:50 <allbery_b> just seems to me that Dynamic is inviting type problems, isn't it abusable?
10:35:54 <dancor> hmm, haskell makes me make an unplesant decision here
10:36:06 <allbery_b> (unsafeCoerce anyone?)
10:36:31 <LoganCapaldo> Just use safeCoerce instead :)
10:36:50 <pejo> allbery_b, um, are you saying something is abusable because of unsafeCoerce?
10:37:30 <dancor> it seems like a misuse of dynamic to make that the way that ppl can do exceptions properly
10:37:34 <allbery_b> pejo: actually I'm saying I'm not sure what's going on there, if I make a dumb mistake will I accidentally derive unsafeCoerce#?
10:37:35 <dancor> i agree with that
10:37:47 <dancor> but i think it's more important to do exceptions properly
10:38:18 <dancor> than ph3ar leaving the static realm a bit
10:38:31 <dancor> i guess i'll see what happens
10:39:45 * allbery_b has 40+ years of experience making dumb mistakes :}
10:40:09 <dancor> allbery_b: heh so what have you learned here, exceptions aren't worth it?
10:40:21 <Anon4888> Can function types be made instances of a class?
10:40:35 <dancor> does anyone else think user-defined exceptions are a little broken in haskell right now
10:40:47 <allbery_b> no, just means if I use them I'll generally stick with error insted of trying to roll my own
10:40:48 <dancor> am i being to harsh in my assessment
10:41:03 <allbery_b> anon4888: they can, sure, if the class makes sense for them
10:41:08 <LoganCapaldo> Anon4888, if I understand your question correctly, sure! consider the State monad
10:41:12 <michaelw> exceptions in a lazy language are troublesome anyway
10:41:27 <newsham> Is there any way to compose (@.) lambdabot cmd output with an eval command (>) ?
10:41:44 <allbery_b> ">" is available as @run
10:41:45 <michaelw> and i wish haskell would have adopted conditions instead of exceptions
10:42:06 <LoganCapaldo> newsham, run
10:42:08 <allbery_b> anon4888: consider the monad ((->) r)
10:42:12 <LoganCapaldo> @. run command
10:42:12 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "command"
10:42:15 <dancor> michaelw: do you tend to just use a bunch of eithers then?
10:42:23 <Anon4888> I thought they could... but I can't define parameterized types to be instances, right?
10:42:30 <LoganCapaldo> @. run topic #haskell
10:42:31 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "topic"
10:42:38 <LoganCapaldo> @. run tell-topic #haskell
10:42:38 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "tell-topic"
10:42:44 <dancor> i really don't like the idea of globalizing error conditions by giving up my own exception types
10:42:45 <allbery_b> topic-tell?
10:42:49 <allbery_b> @topic-tell
10:42:50 <lambdabot> Do not know that channel
10:42:52 <LoganCapaldo> @. run topic-tell #haskell
10:42:53 <lambdabot>  ["The Haskell programming language: Get yourself some cognitive dissonance!"...
10:42:58 <LoganCapaldo> thanks :)
10:43:03 <newsham> so how do I compose "@elite aaaaaaaaa" with "run nub" ?
10:43:11 <michaelw> dancor: I use ErrorT, and I define which exceptions I have beforehand as a sum type
10:43:25 <newsham> ?elite aaaaaaaaaaaaaaaaa
10:43:26 <lambdabot> A4444aa44a4a4aAaa
10:43:28 <allbery_b>  @. elite run nub ....
10:43:28 <LoganCapaldo> @. run nub elite aaaaaaa
10:43:28 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "nub"
10:43:33 <newsham> > nub A4444aa44a4a4aAaa
10:43:34 <lambdabot>   Not in scope: data constructor `A4444aa44a4a4aAaa'
10:43:40 <newsham> > nub "A4444aa44a4a4aAaa"
10:43:42 <lambdabot>  "A4a"
10:43:44 <LoganCapaldo> @. run nub (elite aaaaaaa)
10:43:44 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "nub"
10:43:55 <allbery_b> not sure you can compose with arguments that way
10:44:02 <LoganCapaldo> @. (run nub) elite aaaaaaaaa
10:44:03 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "(run"
10:44:07 <LoganCapaldo> le sigh
10:44:14 <allbery_b> have to ask dons
10:44:17 <newsham> dont think "run nub" works either
10:44:36 <LoganCapaldo> @run nub
10:44:37 <lambdabot>  Add a type signature
10:44:53 <LoganCapaldo> @run nub :: [()] -> [()]
10:44:55 <lambdabot>  <[()] -> [()]>
10:46:46 <dancor> michaelw: sorry so is that the same as having all my fcns return Either OneOfMyErrTypes RetType
10:47:47 <tomh-> is there a "ruby on rails" style framework in haskell yet?
10:47:57 <allbery_b> @where HAppS
10:47:57 <lambdabot> http://happs.org
10:48:12 <tomh-> i just visited that page but does look more as an app server
10:48:25 <allbery_b> yeh, it'
10:48:32 <kolektiv> there's nothing you'd describe as a faithful port
10:48:33 <allbery_b> s also as close as we currently get
10:49:24 <tomh-> isnt directly cgi better?
10:49:27 <tomh-> fastcgi
10:49:33 <musasabi> kolektiv: might because HAppS is different from rails, and existed prior ot rails fame.
10:49:37 <tomh-> if you want to build a ror style framework
10:49:50 <kolektiv> musasabi: oh i know - they're nothing alike in terms of design goals
10:50:03 <newsham> isnt ruby on rails an app server?
10:50:07 <tomh-> no
10:50:23 <tomh-> its a framework
10:50:36 <newsham> so an app server isnt a framework?
10:50:42 <allbery_b> basically a toolkit for building app servers
10:50:58 <tomh-> i think mongrel is more like that happs thing
10:51:05 <allbery_b> so, one level of indirection from app servers
10:51:07 <tomh-> mongrel is a http server for rails
10:51:09 <kolektiv> tomh - fastcgi is usueful where you want to use a framework on top of "some" server, but happs includes an http server
10:51:21 <tomh-> i rather use my own server
10:51:34 <newsham> allberry: if an app server comes with no apps, then musn't it be a toolkit for building app servers?
10:51:37 <newsham> I'm confused.
10:51:40 * qwr . o O ( bits of haskelldb and wash... )
10:52:09 <tomh-> compiled haskell is supposed to be much faster than ruby atm right?
10:52:11 <allbery_b> newsham: no, because an app server will usually enforce some behaviors that a framework will let you compose for yourself
10:52:25 <michaelw> dancor: yes, except you get it all wrapped up nicely in a monad transformer
10:52:36 <qwr> tomh-: http://jackass.tekno.chalmers.se/dp03-7/DEMO/
10:52:37 <lambdabot> Title: DEMO
10:52:38 <newsham> allbery: hmm.. such as?
10:53:09 <kolektiv> WASH is probably closer to rails than happs, but neither are at all close
10:53:24 <tomh-> qwr: i dont like that style
10:53:32 <tomh-> it has markup included it seems
10:53:45 <tomh-> i want to use a MVC pattern
10:53:51 <musasabi> an application server is a good way to do things, using something like fastcgi would just make things more complicated.
10:53:58 <dancor> michaelw: how wrapped up?  it's just like the type becomes MightErr RetType right
10:53:58 <tomh-> how come
10:54:05 <newsham> tomh: so separate the viewer from the model.
10:54:08 <musasabi> and apache can still be used in front of HAppS if wanted to.
10:54:15 <tomh-> i prefer nginx :)
10:54:28 <kolektiv> tomh - most common web app setups in the functional sphere tend to use html generation out of the box - you could change it of course
10:54:30 <tomh-> and maybe that app server then
10:54:41 <musasabi> tomh-: managing concurrency between different instances of the application (and synchronizing access).
10:55:09 <tomh-> so a setup with that app server behind nginx is prolly the best way to go
10:55:12 <qwr> tomh-: its separated there - model is in the ForumUtils.hs
10:55:18 <tomh-> ok
10:55:50 <newsham> qwr: login.hs has font markups in it
10:56:00 <tomh-> the code is not as clean as i hoped
10:56:24 <kolektiv> tomh - have you read the article rails vs. seaside? it's an insight into the different schools of thought - why templates aren't perhaps applicable (although it's definitely an opinion)
10:56:28 <kolektiv> tomh - http://onsmalltalk.com/programming/smalltalk/rails-vs-seaside/
10:56:29 <lambdabot> Title: Rails vs Seaside
10:56:35 <tomh-> i have seen that article ye
10:56:45 <tomh-> but i prefer templates
10:56:50 <tomh-> so designers can work with it too
10:56:54 <tomh-> w/o breaking your code
10:57:12 <kolektiv> tomh - fair enough - so what problem are you hoping to solve with a haskell solution?
10:57:19 <tomh-> well
10:57:27 <tomh-> actually making use of the stuff i learn here on school :P
10:57:27 <newsham> as long as the templates allow recursive decomposition.
10:57:41 <newsham> xslt makes it nigh impossible to call on template from within another
10:57:47 <tomh-> atm i see absolutly no point in ever learning haskell
10:57:56 <tomh-> so im looking for something usefull to do with it
10:58:00 <newsham> which is like tying my hands behind my back and breaking 3 of my toes
10:58:38 <newsham> tomh: so you see no point in learning a new language but you're looking for one? ;-)
10:58:40 <dancor> if i have   f :: IO (MightErr r)   f = if ... then return $ throwError $ MyFunErr "death" else ...
10:58:43 <pejo> tomh, you'll get a better imperative programmer even if you never look back at Haskell again after your class is done.
10:58:47 <newsham> trying to waste some time?
10:58:51 <dancor> am i making things too complicated?
10:58:56 <tomh-> well my university forces us to learn haskell
10:59:02 <newsham> ahh, I see.  makes sense.
10:59:03 <tomh-> all courses are haskell based almost
10:59:13 <sjanssen> tomh-: where do you go to school?
10:59:18 <kolektiv> tomh - what uni is this? i've never known one with almost all haskell!
10:59:27 <dancor> this is some that tries to do some IO stuff but could also explode in some user-defined ways
10:59:30 <tomh-> university of utrecht
10:59:30 <newsham> tomh: one interesting reason to learn it would be that your compiler will catch an order of magnitude more of your bugs for you
10:59:33 <dancor> this is some fcn
10:59:41 <newsham> vs. using a dynamically typed languag elike python, perl, lisp or ruby
10:59:51 <pejo> newsham, is that claim substantiated somewhere?
10:59:51 <sieni> tomh-: cool
11:00:14 <newsham> which is attractive if you'r writing a large program over a long period of time with several people
11:00:20 <tomh-> ye i see
11:00:22 <newsham> pejo: i dont know.. I dont have a ref myself.
11:00:39 <tomh-> the only point is that i have several design patterns i like i want to be able to use :)
11:00:39 <kolektiv> newsham - not sure i agree there - that's the old typing debate, which is never quite finished...
11:00:55 <tomh-> so maybe i have to write those myself
11:00:59 <kolektiv> tomh - forcing patterns into a language they don't fit will not benefit you at all!
11:01:12 <pejo> tomh, design patterns for functional programs, or the "OO" ones?
11:01:15 <michaelw> dancor you could have type MyComputation a = ErrorT MyException IO a, and f :: MyComputation a; f = throwError $ SomethingBad ...
11:01:29 <tomh-> well i think MVC is kinda language independed
11:01:40 <tomh-> but stuff like activerecord
11:01:48 <tomh-> i dunno how to apply that to haskell ye
11:01:50 <allbery_b> if he needs to catch IOExceptions anyway, he may well be better off using error or throwDyn
11:02:01 <tomh-> cause im a total noob when it comes to haskell OO'ness
11:02:03 <kolektiv> activerecord is quite an OO thought i would say
11:02:08 <tomh-> ye
11:02:19 <tomh-> but the code is super clean
11:02:23 <dancor> michaelw: so i would use MyComputation for things that would have been IO (), and my previous MightErr for things that would have been purely fcnl?
11:02:25 <tomh-> like user.name = 'bla'
11:02:27 <tomh-> user.save
11:02:38 <pejo> tomh, heh. That has been extensively "discussed" at lambda-the-ultimate.org. Shouldn't be hard to find, standard reply is "use the zipper".
11:02:43 <dancor> michaelw: and then i at least have no more return $ return $ ...
11:02:59 <tomh-> whats the zipper
11:03:24 <pejo> ?where zipper
11:03:25 <lambdabot> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
11:03:48 <newsham> i've written a small web app in HAppS.  I've never used rails before, but I have some experience with myghty (and read a bit of mason).
11:04:14 <newsham> I'm still unclear on how HAppS is an application server and that differs from a framework.
11:04:19 <kolektiv> newsham - would you be open to sharing the source code? i wouldn't mind seeing that
11:04:31 <newsham> kole: i would at some point, but not today.
11:04:41 <kolektiv> newsham - that's fair enough :)
11:04:41 <newsham> i did put up small samples when i was testing some code
11:04:47 <michaelw> dancor: yes. purely functional does not mix well with exceptions anyway, because they might escape the handler
11:05:06 <tomh-> so are there any template libs in haskell yet?
11:05:09 <newsham> http://www.thenewsh.com/~newsham/HAppS-StateExample.tgz
11:05:19 <pejo> tomh, the standard OO design patterns probably won't lead where you want though.
11:05:27 <pejo> tomh, what is a template lib?
11:05:37 <tomh-> you know like rhtml or python kit
11:05:42 <newsham> tomh: haskell has good functions for building HTML in code.  there's also the haskell scripted pages (hsp) stuff
11:05:53 <newsham> haskell server pages
11:05:56 <newsham> http://www.cs.chalmers.se/~d00nibro/hsp/
11:05:58 <lambdabot> Title: HSP - Haskell Server Pages
11:06:01 <tomh-> hsp lemme check
11:06:43 <newsham> you an also use xslt if you like ;-)
11:07:01 <newsham> (haskell has good functions for building XML too)
11:07:05 <tomh-> sure i like xslt
11:07:16 <newsham> some of the happs examples online show xslt usage
11:07:19 <tomh-> maybe the best way to do templating actually
11:07:29 <tomh-> cause you can make rss/json/html with that super easy
11:07:29 <newsham> heh.. sure.. if you say so :)
11:07:41 <tomh-> but
11:07:43 <tomh-> is it fast?
11:07:58 <newsham> is which fast?  xslt? xml?  happs?  haskell?
11:08:01 * allbery_b is not sure a template library makes sense for Haskell --- sure you *can* interpret it, but interpreted Haskell is not intended to be high performance
11:08:09 <allbery_b> (that said, well, ruby??!)
11:08:14 <newsham> allberry: xslt renders clientside
11:08:15 <tomh-> xslt with haskell
11:08:27 <tomh-> nah xslt can also be done serverside
11:08:35 <newsham> why would you do that? :)
11:08:47 <sorear> tellfodder
11:08:55 <tomh-> because the web is build for html
11:09:03 <allbery_b> newsham: I'm thinking in terms of stuff like Mason --- embedded code in templates that's executed as the page is served up
11:09:03 <tomh-> so i want to output html
11:09:06 <newsham> so why do browsers render xslt clientside?
11:09:22 <tomh-> they do but its not as good as html support
11:09:27 <kolektiv> newsham - they can, but you can't really rely on client capabilties in that way...
11:09:32 <newsham> allbery: yah, I ended up coding my templates directly in haskell (following similar code I had in myght, which is like mason)
11:09:38 <allbery_b> suppose template library is a bit of an overloaded concept
11:09:40 <newsham> using Text.Html
11:09:50 <newsham> it was pretty nice actually, although i'm not sure an html designer would want to edit it
11:10:08 <newsham> probably if you're using an html designer, hsp is a better choice
11:10:11 <tomh-> ye i need stuff which a html designer can edit
11:10:11 <newsham> or xslt
11:10:31 <tomh-> so preferably just html with stuff like <% user.name %>
11:10:34 <newsham> kole: sure i can.
11:10:56 <tomh-> or <haskell:string>user.name</haskell:string>
11:11:14 <kolektiv> newsham - well - sorta. but that mandates a client with that capability to use your app. how many phones or text browsers have xslt capabilties?
11:11:38 <newsham> phones?  most now.
11:11:40 <tomh-> from an accesibility point of view html is the best way to serve your pages
11:11:43 <newsham> text browsers?  probably none?
11:11:54 <newsham> besides, dont use the web from your phone.
11:11:56 <newsham> geeze, get a life.
11:12:04 <dancor> blame the victim
11:12:13 <tomh-> more people in japan use internet from their phone than a pc
11:12:13 * allbery_b has a job, which is sometimes incompatible with a life
11:12:19 <kolektiv> newsham - ok, fine! but there are still clients that don't, and from a commercial point of view, or a maximum audience, require the thinnest client possible!
11:12:38 <allbery_b> ...and sometimes requires web from phone (well, more often from palm T3 via BT to phone...)
11:12:48 <tomh-> and my clients prolly require valid html 4 strict~
11:12:56 <newsham> kol: do the business analysis..  I render xslt client-side.  what share of the market have I lost?
11:13:08 <newsham> i dont have the answer, but i'd wager less than 1%.
11:13:19 <sorear> Haskell web browsers don't support XSLT, hence when you do it client side you are depending on non-haskell software. :)
11:13:36 <tomh-> newsham: and how is your SEO with those xslt client side templates?
11:13:40 <newsham> sorear: i wouldnt use xslt in the first place...  but thats besides the point.
11:13:45 <kolektiv> the point is that by allowing a processing requirement on the client side you have lost control over part of your app. from a business perspective, that rarely makes sense.
11:13:57 <newsham> lost control?  heh..
11:14:07 <kolektiv> you have excluded some people for no actual reason!
11:14:19 <newsham> no reason?
11:14:39 <kolektiv> well, you could have done the same transformation server side, and sent them a more broadly readable result
11:14:41 <newsham> efficiency is a reason.  lots of people serve up important data over http (non-ssl!) for that reason.
11:15:14 <newsham> there's cpu and bandwidth to pay for xslt.
11:15:19 <kolektiv> efficiency? you mean lack of cycles on the server type efficiency?
11:15:23 <dancor> everything is a trade-off
11:15:47 <newsham> this is a silly argument.
11:15:49 * dancor is tired of optimizing and deciding
11:15:55 <newsham> xslt is horrible.  not many people actually use it.
11:16:09 <kolektiv> this is a silly argument, i agree there :)
11:16:31 <kolektiv> oh dear - i can't agree with the "not many people" bit though! never mind
11:16:32 <dancor> now it's a silly agreement
11:16:33 <newsham> xslt is best left to people who write standards and not code.
11:16:36 <dancor> good job guys
11:16:41 <tomh-> mm hsp is also not what im looking for~
11:16:55 <newsham> kolektiv: i'm a consultant.  I review lots of web applications.  I dont see it that often.
11:17:08 <newsham> could be due to sampling bias, who knows..  thats my view of th emraket.
11:17:39 <kolektiv> newsham - we use it extensively for messaging between different stock/data/retail systems - every company has there own formats, etc...
11:17:45 <cain--> hey ll
11:17:45 <kolektiv> (it's not nice though, i give you that)
11:17:51 <dancor> most practical discussion in #haskell ever?
11:18:04 <newsham> kole: yup, some people use it, i've seen several..
11:18:06 <kolektiv> newsham - let's leave it at sampling bias :)
11:18:09 <newsham> but most the systems i've seen dont
11:18:24 <newsham> you using it extensively is just 1 data point.
11:18:32 <hpaste>  cain pasted "tree strcture" at http://hpaste.org/166
11:18:54 <kolektiv> newsham... true, true... i also consult though... however, not a fruitful argument :)
11:19:00 <cain--> who can help me implementing the other functions
11:19:03 <newsham> agreed.
11:19:18 <kolektiv> let us not talk of XSLT again...
11:19:20 <cain--> i dont have an idea for deleting roots
11:19:20 <kolektiv> :p
11:19:37 <newsham> ?fact-set xslt not to be discussed in #haskell
11:19:41 <lambdabot> Fact recorded.
11:20:37 <kolektiv> hmmm, i haven't seen that before! handy - strongly typed conversations...
11:20:46 <_roconnor> can we talk about dsssl?
11:21:18 <sorear> we can talk about dsls!
11:23:49 <sjanssen> cain--: http://en.wikipedia.org/wiki/Binary_search_tree#Deletion
11:26:42 <cain--> thanks but i know how is has to be done but i have problems with the programming
11:26:59 <cain--> how do i get back to the root of a tree?
11:27:35 <cain--> i can only think of very very complicated ways to realize the deletion of a knot
11:27:46 <cain--> or node
11:30:34 <bringert> tomh-: shankys and shoffsta are working on a haskell web framework. it's still vaporware, but it ought to be released any day now.
11:31:39 <kolektiv> bringert - do they have a vaporware site at all to go with that?
11:31:51 <bringert> kolektiv: yes
11:32:00 <bringert> that is, the site is still vaporware, afaik
11:32:05 <kolektiv> ah, shame
11:32:06 <kolektiv> haha
11:32:41 <bringert> you can look at Heop in the meantime http://hope.bringert.net/about
11:32:46 <bringert> eh Hope
11:33:52 <bringert> I would also point you to a demo of dynamically compiled haskell web apps, but our IT department broke that machine the other day
11:33:57 <kolektiv> thanks, will take a look at that
11:34:15 <kolektiv> bringert - ah dear - your IT folks are the same as most then?
11:34:36 <newsham> bringer: cool, i was hoping to do something like that soon
11:34:47 <newsham> reading the yi/lambdabot paper reminded me
11:36:00 <newsham> cain: when you want to delete a node with two children, you can call a helper function which recurses to find the new root and returns a subtree with that node removed.
11:36:17 <newsham> and the the delete function can return a new tree with that node as its root
11:37:52 <newsham> delete x (Node y left right) | x == y = Node y' left right' where (y', right') = deleteLeftMost right
11:37:55 <newsham> something like that?
11:38:11 <chessguy> hi haskeller
11:38:12 <chessguy> s
11:38:18 <cain--> hmm
11:38:38 <sorear> hi!
11:38:58 <cain--> what about if the leftmost has a child on its right?
11:39:05 <newsham> so deleteLeftMost x  would return two things, a new tree with th eleftmost removed, and the value of that item that was removed
11:39:41 <newsham> what if?  -> http://en.wikipedia.org/wiki/Binary_search_tree#Deletion
11:40:09 <newsham> in this case "9" has right children, "9" is removed and replaced with its right children
11:40:25 <newsham> since its leftmost, it has at most one child (right)
11:40:45 <newsham> so you can delete it by replacing it with its only child
11:41:51 <cain--> ok
11:41:54 <Daveman> Hi chessguy :)
11:42:08 <chessguy> Daveman, yo!
11:42:16 <newsham> since it is leftmost, it is smaller than any other value in the subtree
11:42:19 <newsham> maintaining tree ordering
11:43:26 <newsham> if you need to maintain balance while deleting you can choose which side to rotate on.. the left or the right, based on their height
11:46:39 <newsham> if you like,   deleteLeftMost x = (rm x, delete rm x) where rm = findRightMost x
11:46:51 <newsham> or it could be done in a single pass more efficiently but slightly more complicatedly
11:46:57 <newsham> (if complicatedly is indeed a word)
11:47:12 <LoganCapaldo> in a more complex manner ?
11:47:15 <newsham> er..  (rm, delete rm x)
11:47:31 <newsham> verily
11:47:34 <chessguy> newsham, if it's not a word, just define it and add it to the language. that's what FP is is all about, right?
11:47:53 <allbery_b> @spell complicatedly
11:47:55 <lambdabot> complicatedly
11:47:55 <newsham> ?let complicatedly = "in a more complex manner"
11:47:56 <lambdabot> Defined.
11:48:05 <chessguy> > L.complicatedly
11:48:06 <lambdabot>  "in a more complex manner"
11:48:29 <LoganCapaldo> it doesn't really substitue in your sentence though
11:48:46 <LoganCapaldo> (if you use that defn)
11:49:16 <newsham> > ["slightly", "more", L.complicatedly]
11:49:18 <lambdabot>  ["slightly","more","in a more complex manner"]
11:50:51 <newsham> heh, i said deleteLeftMost then I did a findRightMost
11:50:59 <newsham> i guess no free homework today
11:54:37 <sorear> @remember chessguy [<newsham> (if complicatedly is indeed a word)] <chessguy> newsham, if it's not a word, just define it and add it to the language. that's what FP is is all about, right?
11:54:37 <sorear>  
11:54:37 <lambdabot> Done.
11:55:04 <chessguy> that's a complicatedly quote :)
11:55:46 <sorear> @users
11:55:46 <lambdabot> Maximum users seen in #haskell: 322, currently: 303 (94.1%), active: 42 (13.9%)
11:56:34 <chessguy> i have a question about the code at http://www.haskell.org/haskellwiki/Simple_StateT_use
11:56:35 <lambdabot> Title: Simple StateT use - HaskellWiki
11:57:08 <cain--> ERROR file:.\uebung12a3.hs:49 - Instance of Eq (BinTree Int) required for definition of findMin
11:57:09 <cain--> ERROR file:.\uebung12a3.hs:49 - Instance of Eq (BinTree Int) required for definition of findMin
11:57:16 <cain--> ERROR file:.\uebung12a3.hs:49 - Instance of Eq (BinTree Int) required for definition of findMin
11:57:21 <cain--> ERROR file:.\uebung12a3.hs:49 - Instance of Eq (BinTree Int) required for definition of findMin
11:57:27 <allbery_b> cain:
11:57:28 <allbery_b> @paste
11:57:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:57:31 <cain--> sry
11:57:36 <chessguy> the comment that says "layer a infinite list of uniques over the IO monad"...that goes with the line of code main = runStateT ..., right?
11:57:43 <cain--> 	| left == Nil   = x
11:57:49 <cain--> this is 49
11:57:56 <cain--> what does that mean?
11:58:03 <cain--> findMin :: BinTree Int -> Int
11:58:03 <cain--> findMin (Node x left right)
11:58:03 <cain--> 	| left == Nil   = x
11:58:03 <cain--> 	| otherwise 	= findMin left
11:58:20 <chessguy> where you have data Tree = ..., you need to end that line with "deriving Eq, Show"
11:58:23 <allbery_b> you can only use == with types that are members of the Eq class.  your BinTree isn't.
11:58:28 <chessguy> er, BenTree
11:58:32 <chessguy> BinTree, darnit
11:58:40 <allbery_b> you want to use patterns anyway
11:58:52 <allbery_b> not Eq
12:00:16 <allbery_b> findMin (Node x Nil _) = x; findMin (Node _ left _) = findMin left
12:00:29 <cain--> ok got it thanks
12:01:21 <allbery_b> might need a more complex pattern for the second part, don't recall if haskell will whine about overlapping  patterns
12:02:07 <allbery_b> chessguy: the [1..] is the list of uniques, yes, as a state initialization
12:02:36 <chessguy> ok, so the comment is just kind of in the wrong spot
12:03:03 <allbery_b> depends on how you think about it
12:03:34 <chessguy> well, the other comment is clearly about the code under it, whereas this comment is about the code above it
12:03:45 <chessguy> no big deal, i just wanted to make sure i was understanding it right
12:03:46 <allbery_b> I'd say the runStateT line just provides one possible list ofuniques; code uses it, pop defines its behavior
12:03:56 <allbery_b> one could argue for the comment being on any one of the three
12:05:31 <chessguy> ok
12:09:37 <bringert> Igloo: htar can now unpack gzipped tarballs, thanks to your compression package
12:11:14 <TomMD> Why is there so many people redeveloping tools that have already been programmed and well tested, for the Linspire tool collection?
12:12:10 <emu> linspire?
12:12:10 <bringert> TomMD: I started working on tar as a test of the binary package, and to make it possible to use cabal-intall on machines that don't have tar (read Windows)
12:14:43 <hpaste>  cain pasted "reviewed" at http://hpaste.org/167
12:14:54 <cain--> allbery_b
12:15:03 <cain--> now it lokks like this
12:15:09 <cain--> but there is one thing missing
12:15:51 <cain--> the subtree of the findmin has to be attaced
12:18:24 <paolino> :t readilne
12:18:25 <lambdabot> Not in scope: `readilne'
12:18:29 <allbery_b> does it?  looks to me like delete handles creating and returning the subtree
12:18:34 <allbery_b> :t readLn
12:18:36 <lambdabot> forall a. (Read a) => IO a
12:18:43 <paolino> :t readline
12:18:45 <lambdabot> Not in scope: `readline'
12:18:48 <sorear> :t System.Console.Readline.readline
12:18:49 <lambdabot> String -> IO (Maybe String)
12:19:12 <sorear> paolino: what do you want? readline gets a line of text, readLn also parses a value
12:19:25 <paolino> readline
12:19:31 <sorear> getLine also gets a line of text, with much fewer features
12:19:36 <sorear> :t getLine
12:19:37 <lambdabot> IO String
12:20:46 <paolino> :t liftM (fst.head.reads.fromJust) (System.ConsoleReadline.readline "")
12:20:47 <lambdabot> Couldn't find qualified module.
12:21:20 <paolino> :t liftM (fst.head.reads.fromJust) (System.Console.Readline.readline "")
12:21:21 <lambdabot> forall a. (Read a) => IO a
12:22:04 <sorear> paolino: read = fst . head . reads
12:22:12 <sorear> read would be clearer
12:22:29 <arjanb> TomMD: maybe because it's hard to find, do you have link to it?
12:22:32 <sorear> @tell glguy you've fallen to #4 ... hpaste is #42
12:22:32 <lambdabot> Consider it noted.
12:23:24 <paolino> mmhh that function should parse everything has Read instance right ?
12:23:52 <sorear> paolino: yes, but it is unnecessarily long and (worse) partial
12:24:46 <paolino> my problem  is it fails on an string input
12:25:28 <paolino> *Main> liftM (fst.head.reads.fromJust) (readline "") >>= print
12:25:28 <paolino> paolino
12:25:28 <paolino> *** Exception: Prelude.head: empty list
12:25:29 <allbery_b> for a raw string just use readline directly
12:25:52 <bobwhoops> Hi, I'm starting with haskell. Does anyone have recommendations for well-written haskell code/projects for me too look at? Preferably not something too big. I've looked around the wiki a bit but was wondering if anyone here had anything to recommend
12:26:09 <allbery_b> if you want to handle an empty string, you'd need to special case that.  while at it, fix the fromJust :)
12:26:36 <paolino> "paolino" is not an empty string
12:27:50 <paolino> *Main> liftM (fst.head.reads.fromJust) (readline "") >>= print
12:27:51 <paolino> 10
12:27:51 <paolino> 10
12:28:52 <sorear> paolino: don't use read for user input, it's too unfriendly :(
12:28:57 <allbery_b> oh sorry, I misread
12:29:36 <paolino> readline is ok
12:29:51 <allbery_b> read is useful if you want to read something other than String; for String use readline directly.  Or, better, use readline and then use a parse routine that behaves gracefully in the presence of typoes
12:30:23 <paolino> *Main> liftM (fst.head.reads.fromJust) (readline "") >>= print
12:30:24 <paolino> 5.5
12:30:24 <paolino> *** Exception: Prelude.head: empty list
12:30:29 <allbery_b> (you're making your own pain there by using head without checking if the list is empty (failed parse))
12:30:47 <paolino> why it fails here ?
12:31:07 <paolino> and not on 10
12:31:11 <allbery_b> you didn't give it a type, it assumed Int
12:32:22 <paolino> this confuses me
12:32:40 <paolino> Int over String ?
12:32:47 <paolino> or Float ?
12:33:04 <allbery_b> :t liftM (fst.head.reads.fromJust) (System.Console.Readline.readline "") >>= print
12:33:06 <lambdabot> IO ()
12:33:15 <allbery_b> whoops, tthat was less than useful :)
12:33:24 <paolino> yes
12:33:36 <allbery_b> anyway, yes, it needs to determine a type.  at compile time, not runtime.
12:34:29 <sorear> Defaulting!
12:34:32 <allbery_b> you didn't specify one, so it used the "default" fallback specified in the Prelude, which led it to use Integer (not Int as I earlier said)
12:35:17 <allbery_b> if you want a particular type, you need to specify one at compile time --- Haskell will not *at runtime* mutate that to read Double or String or [(Int,Double)], etc.
12:36:18 <allbery_b> (in normal usage the type can probably be inferred from how you use it, but in that simple test case there isn't enough information)
12:36:25 <sm> so, I've got this file read into ghci (actually, a structure generated from the file)
12:36:43 <sm> is there no way to interactively find the length of this data ?
12:38:00 <allbery_b> x >>= return . length (assuming x is the structure and your data is in IO)
12:38:25 <sorear> fmap length x
12:39:08 <allbery_b> that too
12:47:22 <paolino> ok, now if I derive Read from a newtype , how I'm supposed to input parsable values ?
12:47:51 <paolino> newtype T = {unT::Int} deriving (Read)
12:48:07 <emu> > read "1" ::Int
12:48:19 <lambdabot>  1
12:48:52 <sm> hmm! thanks, let me stare at these
12:49:09 <allbery_b> is thta newtype legal?  isn't there supposed to be a constructor therE?
12:49:25 <paolino> :/
12:49:38 <paolino> newtype T = T{unT::Int} deriving (Read)
12:49:48 <ski> read "T 1"
12:49:50 <allbery_b> anyway constants in that typep would be of the form "T 1" or "T {unT = 1}"
12:50:06 <sorear> allbery_b: how do you distinguish newtype deriving read "T 1" from cunning newtype deriving read "1"
12:51:05 <allbery_b> ?
12:51:10 <Axioplase> paolino: T(read "1") ?
12:51:19 <sm> allbery_b: actually my data is an Either wrapped in an IO (a parsec result)
12:51:51 <paolino> *Main> read "1"::T
12:51:52 <paolino> T {unT = *** Exception: Prelude.read: no parse
12:51:57 <sm> so in ghci I'm in an IO do block, that makes sense
12:52:10 <mgsloan> Am I mistaken that messing with a DAG representation of a language would be a bit messy in haskell - a DAG with no obviously appropriate root
12:52:11 <sorear> allbery_b: how is the Read Int dictionary supposed to know it should parse a "T 1" ?  cunning vs. normal  deriving on newtypes
12:52:25 <sorear> mgsloan: for different reasons
12:52:32 <mgsloan> Seems like a language with pointer equality and references might be more apt
12:52:36 <sorear> mgsloan: the root is easy (pick a point)
12:52:42 <sorear> mgsloan: the question is identify
12:52:44 <sorear> mgsloan: the question is identtfy
12:52:45 <mgsloan> yep
12:52:47 <sorear> mgsloan: the question is identity
12:53:09 <sm> to get at the data in the either, I think I have to write a case expression to return the length or fail
12:53:12 <paolino> *Main> read "T 1"::T
12:53:12 <paolino> T {unT = *** Exception: Prelude.read: no parse
12:53:17 <sorear> mgsloan: look at Data.Graph.*
12:53:37 <mgsloan> also, that acyclicity needs to be enforced, which requires that equality
12:53:38 <sorear> paolino: what happens when you read "1"
12:53:44 <sorear> paolino: what happens when you read "T { unT = 1 }"
12:54:08 <ski> hiya esap
12:54:15 <esap> hi!
12:54:18 <paolino> *Main> read "T { unT = 1 }" :: T
12:54:18 <paolino> T {unT = 1}
12:54:34 <allbery_b> interesting that it doesn't support both
12:54:47 <ski> (esap : i have to confess i mixed up '/' and '\' last time ..)
12:55:18 <sorear> allbery_b: I believe that's specified in the Report
12:55:19 <allbery_b> maybe that was what sorear was getting at, but I don't see why it couldn't create both the same way strings can be parsed as "xxx" or ['x','x','x'] or 'x':'x':'x':[]
12:55:21 <esap> ski: that's way too easy, I never remember which one is which
12:55:34 <sm> but I'm not smart enough to do that.. maybe later
12:56:29 <sorear> > read "['x', 'x']"
12:56:30 <lambdabot>  Add a type signature
12:56:33 <sorear> > read "['x', 'x']" :: [Char]
12:56:35 <lambdabot>  "xx"
12:56:44 <sorear> > read "'x':'x':[]" :: [Char]
12:56:45 <lambdabot>  Exception: Prelude.read: no parse
12:56:50 <LoganCapaldo> > read "'x':['x','x']" :: [Char]
12:56:52 <lambdabot>  Exception: Prelude.read: no parse
12:56:57 <sorear> > read "'x':('x':[])" :: [Char]
12:56:57 <allbery_b> thought we had that one the other day
12:56:58 <lambdabot>  Exception: Prelude.read: no parse
12:57:00 <paolino> what methods I have to implement for the Read class
12:57:09 <sorear> paolino: readsPrec
12:57:22 <paolino> :t readsPrec
12:57:23 <lambdabot> forall a. (Read a) => Int -> ReadS a
12:57:25 <LoganCapaldo> @type readsPrec
12:57:27 <lambdabot> forall a. (Read a) => Int -> ReadS a
12:57:55 <sorear>    readsPrec will parse any valid representation of the standard types apart from strings, for which only quoted strings are
12:57:55 <sorear>    accepted, and other lists, for which only the bracketed form [...] is accepted. See Chapter 8 for full details.
12:58:09 <sorear> so ['x', 'x'] shouldn't have worked...
12:58:19 <LoganCapaldo> > read "['x','x']" :: String
12:58:21 <lambdabot>  "xx"
12:58:26 <LoganCapaldo> shouldn't work :)
12:58:39 <LoganCapaldo> ['x', 'x'] :: [Char] should be fine :)
12:58:57 <sorear>      * If the constructor is defined using record syntax, the derived Read will parse only the record-syntax form, and
12:58:57 <sorear>        furthermore, the fields must be given in the same order as the original declaration.
12:59:11 <ski> (esap : 'c (P / R) b' was 'forall a. c P a <= b R a' .. i think a memo-trick is to consider the right argument to '/' as denominator .. which would be comparable with contravariant)
12:59:26 <sorear> hi glguy
12:59:34 <glguy> hi
12:59:35 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
12:59:44 <sorear> @help clear-messages
12:59:44 <lambdabot> clear-messages. Clears your messages.
12:59:56 <sorear> @help purge-notices
12:59:56 <lambdabot> purge-notices [<nick> [<nick> [<nick> ...]]]]. Clear all notes for specified nicks, or all notices if you don't specify a nick.
13:00:11 <LoganCapaldo> > show (['x','x'] :: [Char])
13:00:12 <lambdabot>  "\"xx\""
13:00:18 <LoganCapaldo> drat
13:00:49 <LoganCapaldo> I guess that w/o -fallow-overlapping-instances show has to be magical for strings?
13:01:03 <sorear> LoganCapaldo: clever, yes.  magical, no.
13:01:03 <paolino> readPrec = (readPrec :: Int->Reads Int) :: Int -> Reads T  ?
13:01:08 <allbery_b> you do realize the type system has no way to distinguish String from [Char] ecause they're synonyms?
13:01:16 <LoganCapaldo> allbery_b, yep :)
13:01:21 <sorear> LoganCapaldo: Show has a showList function
13:01:21 <LoganCapaldo> I jsut like causing problems
13:01:33 <LoganCapaldo> sorear, aha
13:01:36 <LoganCapaldo> very clever
13:01:36 <newsham> doesnt ghc6 come with a "quickcheck" script?
13:01:52 <ski> @. read show "xx"
13:01:53 <lambdabot>  "xx"
13:02:00 <esap> ski: It's not clear to me what contravariant means in this context.
13:02:46 <ski> esap : oh .. just that the "denominator" part, i.e. 'R', should occur in the antecedent, rather than the consequent, of the implication
13:03:37 <paolino> readPrec n = (readPrec n :: Reads Int) :: Reads T ?
13:03:45 <esap> ski: ok, but it seems as some kind of property of the relation itself
13:04:03 <ski> 'it' being ?
13:04:30 <esap> ski: contravariance. I mean when you use the notation P/R
13:05:35 <esap> ski: maybe I'm reading too much into what you said
13:05:41 <paolino> I suppose I must reuse readPrec for Int to implement it for T , right ?
13:06:48 <sm> woohoo! my basic ledger parser works
13:07:08 <ski> esap : hm .. i think if you take endo-relations, then maybe one could make '\' a difunctor .. hmm
13:07:23 <ski> esap : anyway, been doing much lately ?
13:08:17 <Cale> @type showList
13:08:20 <lambdabot> forall a. (Show a) => [a] -> ShowS
13:08:31 <esap> ski: Not much, last weekend I setup connection with my Roland keyboard and my linux box via USB...
13:08:31 <newsham> does ghc6 have a method for testing all quickcheck properties of a file?
13:08:43 <Cale> > showList [1..10]
13:08:45 <lambdabot>  <[Char] -> [Char]>
13:08:46 <Cale> > showList [1..10] ""
13:08:48 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10]"
13:08:55 <Cale> > showList "Hello" ""
13:08:56 <lambdabot>  "\"Hello\""
13:08:58 <Igloo> bringert: Cool
13:09:06 <newsham> > showHex 255 ""
13:09:08 <lambdabot>  "ff"
13:09:22 <sm> .. I sure wish I could play with it interactively though.
13:09:24 <newsham> > let hex = flip showHex "" in hex 127
13:09:26 <lambdabot>  "7f"
13:09:34 <Cale> showList is the trick that's used to special-case the behaviour of show for lists.
13:09:58 <esap> ski: Turned out Linux didn't support the USB id of the keyboard, so had to patch the kernel to make it work :-(
13:10:13 <Cale> instance  (Show a) => Show [a]  where
13:10:13 <Cale>     showsPrec p      = showList
13:10:35 <ski> esap : ouch .. /me 's been pondering partial derivatives some
13:12:03 <esap> ski: It wasn't that bad, only added some lines to sound/usb/usbquirks.h
13:12:20 <ski> ok
13:12:41 <esap> ski: what about partial derivates?
13:13:30 <ski> oh .. clarifying somethings about them to myself .. and ponding a somewhat-related effect system
13:13:39 * ski ought to go eat supper .. bbl
13:13:52 <esap> ski: ok, see you later
13:14:55 <paolino> @src Int readPrec
13:14:56 <lambdabot> Source not found. You type like i drive.
13:15:08 <glguy> oh dang burn
13:15:22 <sorear> @users
13:15:22 <lambdabot> Maximum users seen in #haskell: 322, currently: 311 (96.6%), active: 46 (14.8%)
13:16:45 <paolino> how should I implement a readsPrec for a newtype ?
13:24:00 <paolino> newtype T= T {unT::Int}
13:24:00 <paolino> instance Read T where
13:24:00 <paolino>   readPrec = (readPrec :: ReadPrec Int) :: ReadPrec T
13:24:22 <sorear> that's a type error :(
13:24:31 <paolino> yes
13:24:41 <sorear> and GHC's cunning newtype deriving won't hemp you here
13:25:16 <sorear> readPrec = map (first T) . readPrec -- works?
13:25:38 <sorear> import Control.Arrow( first )
13:26:31 <sorear> first here has type :: (a -> b) -> (a,c) -> (b,c)
13:26:37 <sorear> :t Control.Arrow.first
13:26:39 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
13:26:48 <sorear> so let a = (->)
13:27:21 <paolino>       Expected type: a -> [(Int, d)]
13:27:21 <paolino>       Inferred type: ReadPrec a1
13:27:21 <paolino>     In the second argument of `(.)', namely `readPrec'
13:27:24 <sorear> forall d c b. (->) b c -> (->) (b,d) (c,d)
13:27:47 <sorear> sorry, read*s*Prec
13:27:54 <sorear> readsPrec = map (first T) . readsPrec -- works?
13:28:26 <paolino>       Expected type: Int -> [(Int, d)]
13:28:26 <paolino>       Inferred type: Int -> ReadS a
13:28:26 <paolino>     In the second argument of `(.)', namely `readsPrec'
13:28:31 <sorear> readPrec is a GHC extension that has nothing to do with what we are trying to accomplish
13:28:39 <paolino> ok
13:29:10 <sorear> :t \t -> map (first t) . readsPrec
13:29:11 <lambdabot>     Expecting a function type, but found `b'
13:29:12 <lambdabot>       Expected type: Int -> [(b, d)]
13:29:29 <sorear> :t \t s -> map (first t) (readsPrec s)
13:29:30 <lambdabot>     Expecting a function type, but found `[a]'
13:29:31 <lambdabot>       Expected type: [(b, d)]
13:29:41 <sorear> :t \t s -> map t (readsPrec s)
13:29:42 <lambdabot>     Expecting a function type, but found `[a]'
13:29:42 <lambdabot>       Expected type: [a]
13:29:49 <sorear> *doh*
13:30:01 <sorear> readsPrec p = map (first T) . readsPrec p -- works?
13:30:34 <paolino> compiles
13:30:37 <paolino> :)
13:31:18 <paolino> and runs
13:31:22 <paolino> :))
13:31:28 <sorear> and works?
13:31:44 <paolino> *Main> read "1"::T
13:31:44 <paolino> T {unT = 1}
13:31:50 <matthew-_> err, anyone know of a function anything like: foldWhilstZipping :: (a -> b -> c -> c) -> [a] -> [b] -> c -> c
13:32:32 <paolino> :t first
13:32:33 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
13:33:49 <paolino> :t first (+)
13:33:51 <lambdabot> forall b d. (Num b) => (b, d) -> (b -> b, d)
13:33:51 <sorear> paolino: in this case, first :: (a -> b) -> (a,s) -> (b,s)
13:34:10 <sorear> @djinn (a->b) -> (a,s) -> (b,s)
13:34:11 <lambdabot> f a (b, c) = (a b, c)
13:35:24 <paolino> why map ?
13:36:05 <sorear> paolino: backtracking - readsPrec returns a list of possible parses, and we need to postprocess all of them.
13:37:00 <paolino> ok, what is that p ?
13:37:48 <sorear> paolino: precence context.
13:38:37 <paolino> all the possible parses are a list of couples with an int in the first element and the unparsed string in the other
13:38:43 <Saizan> what's the right first line for an .sh? #!/usr/bin/env sh ?
13:38:46 <sorear> exactly
13:38:58 <sorear> paolino: exactly
13:39:04 <sorear> Saizan: #! /bin/sh
13:39:10 <LoganCapaldo> Saizan, shouldprobably be #!/bin/sh
13:39:22 <Saizan> ok
13:39:25 <LoganCapaldo> that's generally guranteed to be bourne compatable
13:39:29 <qwr> env is useful for less standard interpretators
13:39:35 <sorear> Saizan:  some ancient BSD's I'm told had "#! /" as a 4 byte magic, so #!/ is less portable
13:40:08 <Saizan> thanks :)
13:43:05 <sm> how do I define a custom show for a data type ?
13:43:19 <sorear> instance Show MyType where ...
13:43:39 <LoganCapaldo> instance Show Type where show a = ...
13:43:46 <sm> should I remove deriving Show, then ?
13:43:51 <ski> yes
13:43:51 <LoganCapaldo> yes
13:43:59 <sm> aha.. thx
13:45:19 <newsham> hah, as if portability with ancient bsd is a pragmatic concern
13:45:52 <pejo> newsham, good habits aren't a bad idea. All the sudden you have to write portable software.
13:46:08 <newsham> i've been writing portable unix software for a long time
13:46:16 <newsham> i've never run into an issue with "#! /"
13:46:36 <newsham> I fail to see how that is a "good habit"
13:47:20 <pejo> newsham, what do you gain from the less portable version?
13:47:38 <newsham> exactly what you lose by not using it -- zero.
13:48:58 <pejo> newsham, the fact that it's mentioned by the name "less portable" gives a hint what is lost.
13:49:17 <newsham> pejo: can you enumerate the systems on which "#!/bin/sh" will work but for which "#! /bin/sh" wont?
13:49:20 <dons> ?yow
13:49:20 <lambdabot> Oh my GOD -- the SUN just fell into YANKEE STADIUM!!
13:49:37 <newsham> so we can properly quantify the gain/loss?
13:49:41 <chessguy> dons, where does the bot get these quotes from?
13:49:45 <sorear> why doesn't CPP + Haddock + Cabal work for executables?
13:49:45 <chessguy> yow, yarr, all those
13:50:00 <newsham> dons: why no ?farberism ?
13:50:02 <sorear> Where can I ask questions about bizarre cabal problems
13:50:27 <newsham> (?farber from http://www.cs.arizona.edu/icon/oddsends/farber.htm)
13:50:29 <lambdabot> Title: Farberisms
13:50:29 <sorear> dons: why does lb insult people?  I think the comment score is 10+ against 0 for
13:51:38 <newsham> sorear: i filed a bug for that
13:52:09 <newsham> one reply i got was that you dont need "library documentation" (which is what haddock supposedly does) for an executable
13:52:15 <tuukkah> i clearly don't master autoconf magic, but i was finally able to compile a gtk2hs app with profiling support
13:52:16 <sorear> newsham: insults or cabal?
13:52:27 <newsham> haddock/cabal
13:52:35 <sorear> I didn't know lambdabot hada bugtracker
13:52:49 <newsham> for cabal.
13:53:56 <paolino> thanks sorear, I've learnt some good things tonight
13:54:17 <sm> is there a function for pretty-printing data, like ruby pp ?
13:54:54 <pejo> newsham, no. The autoconf manaul seems to imply the reverse though.
13:55:01 <sorear> Text.PrettyPrint.HughesPJ - generic lib for easily writing prettyprinters
13:55:10 <sm> in my custom show, is there a way to get at the automatically-derived show, so I can print that too ?
13:55:13 <pejo> newsham, that is, #! /bin/sh is preferred.
13:55:34 <newsham> err, sorry, i backwardsed my quesiton
13:56:47 <astrolabe> sm: maybe you should call your custom show something different.
13:56:49 <dons> http://blogs.nubgames.com/code/?p=17
13:56:49 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
13:56:51 <lambdabot> Title: Nub Games » One Month with Haskell
13:56:55 <sm> aha
13:57:06 <trurl> pejo, newsham: you may find http://www.in-ulm.de/~mascheck/various/shebang/ a useful source of information
13:57:08 <lambdabot> Title: '#!'-magic, details about the shebang mechanism
13:57:10 <newsham> If you omit the space before the path, then 4.2BSD based systems (such as DYNIX) will ignore the line, because they interpret `#! /' as a 4-byte magic number.
13:57:21 <newsham> so the question is, will your code ever run on a 4.2bsd system?
13:58:25 * allbery_b wonders if there are any 4.2BSD systems left
13:58:34 <sorear> newsham: if I reply to the ticket, will anyone ever know?
13:59:19 <newsham>         if (u.u_exdata.ux_shell[0] != '#' ||
13:59:19 <newsham>             u.u_exdata.ux_shell[1] != '!' ||
13:59:19 <newsham>             indir) {
13:59:24 <newsham> thats 4.2 bsd kernel code.
13:59:30 <newsham> it does not check for a space or a '/'
13:59:31 <chessguy> "The program I just finished is a little over 600 lines of Haskell.  It replaces a system written in 11,000 lines of Java"
13:59:32 <chessguy> nice
14:00:50 <sorear> newsham: rossp's reply has made me so angry I can't in good consience reply today
14:01:04 <pejo> allbery_b, I have no idea what people use, but I'm aware of Sun3's being in production.
14:01:15 <sorear> and how does cabal get a defect list as long as all of GHC has?
14:01:35 <newsham> sorear: good policy (not replying when angry)
14:01:40 <allbery_b> which 4.2?
14:01:45 <newsham> CSRG 4.2
14:02:23 <chessguy> @type nub
14:02:25 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:02:27 <newsham> csrg/4.2/usr/src/sys/sys/kern_exec.c:442
14:02:27 <allbery_b> CSRG made several 4.2 releases, distinguished by codenames.  each was somewhat different and IIRC "#! /" was only true of the very first
14:02:32 <chessguy> ?src nub
14:02:33 <lambdabot> nub = nubBy (==)
14:02:38 <chessguy> heh
14:02:50 <chessguy> ?src nubBy
14:02:51 <lambdabot> nubBy eq []             =  []
14:02:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:02:52 <newsham> allbery: do you mean 4.3?
14:03:13 <allbery_b> 4.3 continued it but 4.2 also had some of it.  or maybe it was distinguished by platform inb the 4.2 days
14:03:26 <newsham> 1bsd 2.10 2.79 2.8 2.9 2.9pucc 2bsd 3bsd 4.0 4.1 4.1a 4.1c.1 4.1c.2 4.1.snap 4.2 4.2buglist 4.3 4.3reno 4.3tahoe 4.4 4.4BSD-Lite1 4.4BSD-Lite2 net.1 net.2 pascal.2.0 pascal.2.10 src VM.snapshot.1 VM.snapshot.2
14:03:34 <dons> ?user
14:03:34 * allbery_b actually doesn't quite recall thatfar back but knows there were multiple 4.2s
14:03:35 <lambdabot> Maximum users seen in #haskell: 322, currently: 307 (95.3%), active: 46 (15.0%)
14:03:42 <chessguy> > nub [1..10]
14:03:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:03:46 <newsham> those are the CSRG sources that mckussick releases on his CSRG source
14:03:47 <dons> sorear: so what's this about insults? time to remove them?
14:03:48 <newsham> CD
14:03:55 <chessguy> > nub [1..10,1..10]
14:03:56 <lambdabot>  Parse error
14:04:07 <chessguy> > nub [1,2,3,1,2,3]
14:04:08 <lambdabot>  [1,2,3]
14:04:11 <rahikkala> Where does lambdabot et its @src from, btw?
14:04:20 <rahikkala> @src sortBy
14:04:20 <dons> from the standard libraries
14:04:21 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:04:57 <huschi> bringert: i've got another question. is there a way to insert NULL into a column which is specified as NOT NULL and AUTOINCREMENT?
14:05:17 <sorear> dons: several people want them gone, nobody has spoken in favor
14:05:20 <newsham> 4.1c.2 checked for "#!" too
14:05:25 <allbery_b> people were very careful into the 80s to make sure that it was "#! /", after that few enough machines were in service that cared that people stopped bothering
14:05:32 <rahikkala> I take it the standard libraries are not meant to be uses if you need to sort long lists, then ;)
14:05:36 <sorear> dons: syntaxfree went as far as to set up a bot @vote
14:05:37 <newsham> 4.1 does not seem to support "#!" at all
14:05:46 <sorear> @vote-results cheeky-off
14:05:47 <lambdabot> Unknown command, try @list
14:05:53 <sorear> @poll-results cheeky-off
14:05:53 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=2, Yes=12
14:05:54 <astrolabe> How about reducing insults to a randomised 1 in 100 occurence?
14:06:30 <allbery_b> hm, maybe it was 2.9 then?  2.9 and 4.2 were roughly same timeframe (different platforms)
14:06:33 <bringert> huschi: try _default
14:06:44 <bd_> rahikkala: @src gives simple implementations, often the actual implementations are longer and faster :)
14:06:50 <michaelw> hrm, is c2hs known to be broken with ghc-6.6?
14:06:51 <bringert> huschi: also, see http://darcs.haskell.org/haskelldb/test/old/default-auto-inc.hs
14:07:01 <dons> sorear: fair enough
14:07:18 <bd_> rahikkala: the actual implementation of sort in GHC would probably fill several pages of scrollback
14:07:20 <newsham> err.. I take that back, 4.0.upgrade has "#!"
14:08:00 <tuukkah> michaelw, works at least for me and works for gtk2hs darcs version
14:08:39 <huschi> bringert: ghci takes it now.
14:09:33 <huschi> bringert: and how can i perform a query like "SELECT last_insert_rowid();"?
14:09:38 * rahikkala looks at the implementation in ghc... it's not all *that* complicated, actually, but yeah, the simple one definitely is more suitable for being shown on the channel
14:09:46 <bringert> huschi: see http://darcs.haskell.org/haskelldb/test/old/default-auto-inc.hs
14:09:55 <newsham> 2.9 was pdp11.  is your code 16-bit clean?
14:10:24 <michaelw> tuukkah: 0.14.5?
14:10:46 <huschi> bringert: ok. i'm blind :) thanks again.
14:11:17 <newsham> #ifdef  UCB_SCRIPT
14:11:17 <newsham> #define SCRMAG  '#!'
14:11:25 <newsham> csrg/2.9/usr/src/sys/sys/sys1.c
14:11:56 <tuukkah> michaelw, yes
14:11:57 <newsham> nifty 16-bit character constant :)
14:12:11 <sorear> newsham: better idea - I will implement the change and minimally comment it.  Code doesn't insult anyone.
14:12:20 <newsham> sorear: true.
14:13:18 <huschi> bringert: i think i will write a new tutorial for HaskellDB base on the old when i have finished my current work.
14:13:26 <bringert> huschi: great!
14:13:40 <newsham> (did I mention gnu autoconfig is an abomination before god?)
14:13:54 <tuukkah> michaelw, actually it seems that both the debian version and gtk2hs version are different from the released version
14:13:56 <dons> http://programming.reddit.com/info/11iqu/details
14:13:57 <lambdabot> Title: Haskell introduction for beginners (reddit.com)
14:14:04 <bringert> huschi: tell me where I should link when you have something up
14:14:16 <huschi> bringert: as a sign of my thanks and to give the community something back.
14:14:29 <Axioplase> Just wondering... when merging lists recursively, is it better to use nub when merging two sub lists, or once the big one has been created ? (it's a speed matter, not a size one I ask for)
14:14:36 <huschi> bringert: i will write it on the haskellwiki if that is ok.
14:14:50 <bringert> huschi: of course
14:14:58 <michaelw> tuukkah: gnarl. thanks.
14:15:48 <newsham> looks like bell labs 7th ed doesnt have #! at all
14:16:16 <allbery_b> correct
14:16:27 <allbery_b> CSRG came up with it
14:17:48 <allbery_b> before that, the trick was that exec[lv]p() would fall back to invoking /bin/sh on anything that failed the actual syscall with ENOEXEC
14:18:34 <allbery_b> (and csh intercepted things that started with '#' and treated them as csh scripts, since sh didn't acquire #-comments until relatively late)
14:18:45 <newsham>             execv(shell, newargs);
14:19:06 <newsham> unix/PDP-11/Trees/V7/usr/src/libc/gen/execvp.c:83
14:21:43 <allbery_b>   : 'ancient /bin/sh comment'
14:24:01 <michaelw> tuukkah: builds with debian patches now
14:24:43 <tuukkah> good :-)
14:27:27 <newsham> heh, csh exec thing is amusing
14:28:05 <newsham> looks like started in 2BSD which introduced csh?
14:29:16 <fasta> I am in #unix-history?
14:32:55 <newsham> #!unix-history i think
14:35:17 <newsham> those who fail history are doomed to repeat it
14:36:10 <vincenz> and those who repeat "those who fail history are doomed to repeat it" are doomed to fail history
14:36:31 <newsham> that doesnt make sense
14:36:36 <vincenz> it parses perfectly
14:36:56 <moonlite> :)
14:36:57 <vincenz> and it types :)
14:37:03 <newsham> so if it doesnt make sense but it makes syntactic sense (parses) .....
14:37:13 <vincenz> it makes perfect sense
14:37:15 <vincenz> history is overloaded
14:37:27 <newsham> so is "repeat"
14:37:28 <vincenz> and there's no monomorphic restriction
14:37:46 <newsham> am I saying "repeat historical events" or do I mean "repeat the history class"
14:38:02 <newsham> i do not know
14:38:22 <vincenz> those who repeat "thisquote" are doomed to fail history
14:38:31 <vincenz> seeems rather straightforward
14:38:42 <newsham> yes, it parses, but its incorrect.
14:38:44 <fasta> Other subject: Do you think that a program could be written in natural language practically?
14:38:55 <newsham> since i have repeated the quote many times AND passed history
14:39:10 <newsham> fasta: too imprecise.
14:39:30 <bd_> Inform 6 tries.
14:39:36 <newsham> its hard enough trying to write a spec in natural language
14:39:36 <fasta> newsham: natural language or my question?
14:39:36 <bd_> 7 rather
14:39:41 <newsham> natural language.
14:39:43 <fasta> bd_: I heard about it.
14:39:51 <fasta> bd_: wasn't it intended for games?
14:39:58 <bd_> It's annoying, you read some examples, start typing in natural english, and get an error back :)
14:40:23 <bd_> fasta: Yeah, the idea is to make writing an interactive fiction game a lot like writing a novel
14:40:23 <michaelw> fasta:L Dijkstra had something to say about it
14:41:02 <fasta> michaelw: L Dijkstra?
14:41:06 <newsham> dijkstra, church, turing, etc.. always ruining the party :(
14:41:21 <vincenz> newsham: oh, so you were complaining about the validity, that doesn't make it semantically incorrect, it just might not apply to your world.
14:41:22 <fasta> michaelw: that's not his initial, right?
14:41:43 <newsham> vincenz: hence your conclusion does not make sense.
14:41:46 <newsham> given the reality i live in.
14:42:00 <fasta> Edsger Wybe Dijkstra
14:42:03 <fasta> No L
14:42:07 <vincenz> newsham: no "incorrect" and "does not make sense" are two different things
14:42:41 <newsham> vincenz: yes, but a conclusion that does not make sense is a conclusion that is incorrect
14:42:53 <fasta> michaelw: and what did he have to say about it?
14:42:55 <vincenz> newsham: wrong way of going
14:43:15 <vincenz> newsham: the premise is incorrect according to you, and "does not make sense" does not automatically follow :D
14:43:18 <vincenz> anyway
14:43:18 <vincenz> it was a joke
14:44:00 <newsham> http://www.answers.com/sense&r=67, 4c "something sound or reasonable"
14:44:02 <lambdabot> Title: sense: Definition, Synonyms and Much More from Answers.com
14:44:11 <Philippa> *reads up*
14:44:21 <newsham> from which it follows something that does not make sense is something that is not sound or reasonable.
14:44:28 <Philippa> I7 has the advantage of being something of a special case, and also suited to something resembling a logic language
14:44:29 <vincenz> newsham: look
14:44:32 <newsham> a false conclusion is not sound.
14:44:35 <vincenz> newsham: something can be incorrect and make sense
14:44:36 <newsham> qed.
14:44:38 <michaelw> fasta: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html
14:44:41 <lambdabot> Title: E.W.Dijkstra Archive: On the foolishness of "natural language programming". (EWD ..., http://tinyurl.com/2eh4ud
14:44:44 <vincenz> "goo goo gaga" does not make sense
14:44:57 <vincenz> "chickens lay football-sized eggs" is incorrect but makes sense
14:45:05 <newsham> how can something be incorrect and make "something sound or reasonable" ?
14:45:33 <sorear> how about programming in Newspeak? :)
14:45:39 <newsham> stupid natural language :(
14:46:07 <newsham> newsqueak?
14:46:34 <tuukkah> would anyone remember an example of code that memoizes a function with (Typable t) in the type context?
14:46:55 <vincenz> sorear: maybe in 1984
14:48:43 <fasta> michaelw: Thanks, I read it.
14:50:05 <Axioplase> One *really* good point for Ocaml compared to Haskell, is that the ocaml suite compiles very fast, whereas ghc takes hours...</wishes_it_was_finished>
14:51:11 <newsham> does ghc triple-build with optimization on?
14:52:28 <Axioplase> I have no idea. All I did was "cd /usr/ports/lang/ghc;make -j8 CC=distcc" (freebsd and 3 computers)
14:52:56 <fasta> Axioplase: hours?
14:53:00 <uccus> performance, performance, performance
14:53:00 <lambdabot> uccus: You have 1 new message. '/msg lambdabot @messages' to read it.
14:53:04 <nornagon> i don't think that's really a good point to compare the languages on
14:53:11 <fasta> Axioplase: even on my single CPU it goes within the hour, I think.
14:53:14 <nornagon> you compile it once, then you use it
14:53:24 <newsham> norn: i think its a complaint rather than a comparison :)
14:53:36 <newsham> heh, build it once.. I wish :(
14:53:37 <heatsink> It matters a great deal when porting.
14:53:49 <nornagon> i didn't even build it ^_^
14:53:54 <nornagon> i guess, though
14:54:06 <sorear> Axioplase: 2Ghz, single core, max optimization, all libraries, build over in 90mins.
14:54:06 <fasta> A good system should be a portable as Squeak.
14:54:22 <fasta> s/a/as
14:54:46 <newsham> sorear: do you know if it does a double or a triple build?
14:54:53 <sorear> newsham: double
14:54:55 <newsham> also do the earlier stages get built with optimization?
14:55:07 <Axioplase> sorear: well.. it's a 600Mhz here, but distcc runs on a P3 800Mhe and a P4 3Ghz... not enough it seems..
14:55:09 <sorear> newsham: iirc yes
14:55:22 <newsham> (if so, you'd get the same binary if the earlier stage wasnt built with optimization, wouldnt that be faster?)
14:55:55 <sorear> newsham: first stage can compile the second stage faster if optimized.
14:56:10 <newsham> right but builds slower itself
14:56:10 <sorear> newsham: first stage is just compiler, second stage includes libs (iirc)
14:56:16 <newsham> ahh
14:57:23 <sorear> newsham: I've failed my immediately-understand-cabal check ... now trying to write a completely unvitriolic "how do I understand large programs?" for -cafe
14:57:39 <beelsebob> okay... so I just got a runtime type error
14:57:41 <beelsebob> hat-delta: LowLevel.hs:68:0: No instance nor default method for class operation GHC.Num.fromInteger
14:58:03 <huschi> bringert: to my mind there should be changed something in HaskellDB concerning the SQLite backend.
14:58:09 <sorear> ... since haddock is for "libraries only"
14:58:38 <huschi> bringert: the default value is rendered to DEFAULT, but this keyword doesn't exist. NULL should be taken instead.
14:58:45 <dons> oh, http://programming.reddit.com/info/11ire/comments
14:58:48 <lambdabot> Title: A simple TCP client in Haskell using transactional memory and message passing (r ...
14:59:21 <beelsebob> dons: you got any idea what that's all about?
14:59:43 <dons> hmm?
14:59:48 <dons> oh hmm
14:59:49 <beelsebob> runtime type error...
15:00:00 <dons> missing class method
15:00:04 <dons> for your type
15:00:19 <beelsebob> ah, that makes sense
15:00:26 <beelsebob> why doesn't ghc enforce me having it?
15:01:31 <sorear> beelsebob: use -Wall -Werror
15:01:48 <beelsebob> sorear: sure -- but why isn't that an error in the first place
15:01:57 <beelsebob> i was under the impression that Haskell's type system was sound
15:02:27 <sorear> beelsebob: define sound , undefined :: a proves everything
15:03:11 <sorear> sound iirc just meant no segfaults
15:03:16 <sorear> @users
15:03:16 <lambdabot> Maximum users seen in #haskell: 322, currently: 294 (91.3%), active: 44 (15.0%)
15:04:14 <fasta> beelsebob: if you have only Haskell 98 code, it shouldn't happen.
15:04:29 <beelsebob> fasta: it is H98 + adendums only
15:04:49 <fasta> beelsebob: what does Hugs say?
15:04:52 <dons> you're allowed to leave out methods, afaik
15:04:59 <dons> and this is the result :)
15:05:08 <beelsebob> fasta: not a clue - this requires quite a serious build system
15:05:09 <fasta> dons: hmm, yes.
15:05:16 <beelsebob> dons: kk
15:05:19 <fasta> beelsebob: dons is right, AFAIR
15:05:20 <sorear> beelsebob: this is no type error ...
15:05:27 <dons> sorear: btw, I'd hasktags yi
15:05:35 <dons> then you can jump to defns by ^[ on the symbol
15:05:42 <dons> (in vim, something else similar in emacs)
15:05:43 <beelsebob> ARGH!
15:05:47 <beelsebob> I hate fucking GHC's profiling
15:05:50 <beelsebob> it SUCKS!
15:05:55 <dons> patch it
15:06:02 <beelsebob> would rather patch hat for the mo
15:06:11 <beelsebob> <GHC.List.CAF>hat-delta: Prelude.head: empty list <-- useful stack trace that one
15:06:14 <fasta> All software sucks, some more than others.
15:06:14 * dons hasn't seen a hat release in a looong time
15:06:19 <dons> what you guys up to?? eh?
15:06:27 <beelsebob> dons: I think there's going to be a 2.06 some time soon
15:06:32 <sorear> beelsebob: I didn't even know it was possible... <tryes not to visualize>
15:06:44 <dons> if you don't watch out, everyone'll be using ghci-debugger
15:06:47 <fasta> fromJust and head are evil.
15:06:47 <newsham> sorear: why would you ever want to document a program?
15:06:49 <beelsebob> we're mostly patching a load of irritating bugs that most people complaining about
15:06:58 <SyntaxNinja> I'm eating jaffa cakes!
15:07:02 <beelsebob> o.O
15:07:02 <dons> hehe
15:07:05 <fasta> I always think "Oh, but this will never be an empty list".
15:07:06 <beelsebob> no eating ghc programmers!
15:07:18 <fasta> ... and then surely, it gets empty.
15:07:20 <sorear> newsham: because you can always write documentation, even when you are too tired to code?
15:07:20 <dons> eat York programmers instead! they're tastier
15:07:40 <beelsebob> yeh, go for it
15:07:43 <dons> SyntaxNinja: can you get JaffaCakes in Portland?
15:07:54 <newsham> sorear: hypothetical_question :: IO ()
15:07:58 * dons was very happy to find them in oxford
15:08:05 <sorear> @all-dicts jaffa
15:08:07 <lambdabot> *** "Jaffa" wn "WordNet (r) 2.0"
15:08:07 <lambdabot> Jaffa
15:08:07 <lambdabot>      n : a port in western Israel on the Mediterranean; incorporated
15:08:07 <lambdabot>          into Tel Aviv in 1950 [syn: {Joppa}, {Yafo}]
15:08:18 <sorear> @all-dicts jaffa.*
15:08:19 <lambdabot> *** "Jaffa" wn "WordNet (r) 2.0"
15:08:19 <dons> sorear: small orange /chocolate candy
15:08:19 <lambdabot> Jaffa
15:08:19 <lambdabot>      n : a port in western Israel on the Mediterranean; incorporated
15:08:19 <lambdabot>          into Tel Aviv in 1950 [syn: {Joppa}, {Yafo}]
15:08:27 <qwr> fasta: head is useful ;) like for head (args ++ ["nice default"])
15:08:43 <dons> also available in biscuit form, with chocolate jam and biscuit
15:08:47 <newsham> dons: can I @. (@elite aaaaaaaaaaa) with (@run nub)
15:08:53 <fasta> qwr: heh
15:08:55 <sorear> qwr: fromMaybe "nice default" (listToMaybe args)
15:09:03 <dons> newsham: nah
15:09:11 <fasta> I never have nice defaults.
15:09:36 <fasta> It means I need to abort the computation.
15:09:52 <fasta> I eliminated all my fromJust from my programs.
15:10:06 <fasta> it's now case mval of Just a -> a
15:10:08 <sorear> hasktags6!
15:10:19 <newsham> or better   (@run replicate 10 'a') . (@elite) . (@run nub)
15:10:46 <nornagon> @run nub
15:10:47 <lambdabot>  Add a type signature
15:10:56 <bd_> @. elite run replicate 10 'a'
15:10:57 <lambdabot> "A4A4A4a4A4"
15:11:13 <bringert> huschi: see src/Database/HaskellDB/Sql/SQLite.hs, add a line to the function 'literal'
15:11:16 <newsham> cool, so just need a way to get @elite output as input to @run
15:11:18 <sorear> @> elite (replicate 10 a) >>$ nub
15:11:18 <lambdabot> Maybe you meant: . v
15:11:24 <bringert> huschi: send me a patch if you fix it
15:11:27 <huschi> bringert: i've already done.
15:11:35 <sorear> Call for (>>$) = flip fmap in the stdlibs!
15:13:52 <huschi> bringert: to what e-mail-address?
15:14:11 <nornagon> :t nub
15:14:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:14:18 <nornagon> @src nub
15:14:19 <lambdabot> nub = nubBy (==)
15:14:24 <nornagon> @src nubBy
15:14:25 <lambdabot> nubBy eq []             =  []
15:14:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:14:56 <nornagon> > nub [1..
15:14:57 <lambdabot>  Parse error
15:15:00 <nornagon> > nub [1..]
15:15:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:15:12 <nornagon> > nub [1,1,1,1,2]
15:15:14 <lambdabot>  [1,2]
15:15:15 <sorear> hehe.
15:15:21 <nornagon> ah.
15:15:28 <bd_> nornagon: Data.Set.fromList . Data.Set.toList probably faster if you have Ord and can afford things getting out of order. and the list is finite :)
15:15:43 <nornagon> :P
15:15:45 <sorear> if you Can't
15:16:03 <SyntaxNinja> dons: some brit just brought them to my home :)
15:16:10 <sorear> @typ mapAccumL
15:16:12 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:16:50 <nornagon> neat
15:17:03 <sorear> @let ordNub = catMaybes . snd . mapAccumL (\s x -> if (S.member s x) then (s,Nothing) else (S.insert x s, Just x)) S.empty
15:17:03 <lambdabot> <local>:9:96:     Occurs check: cannot construct the infinite type:       a =...
15:17:06 <nornagon> there're so many little utility functions
15:17:12 <sorear> @ty S.member
15:17:14 <lambdabot> Couldn't find qualified module.
15:17:19 <sorear> @ty Data.Set.member
15:17:20 <lambdabot> forall a. (Ord a) => a -> Data.Set.Set a -> Bool
15:17:22 <sorear> @ty Data.Set.insert
15:17:24 <lambdabot> forall a. (Ord a) => a -> Data.Set.Set a -> Data.Set.Set a
15:17:28 <sorear> @let ordNub = catMaybes . snd . mapAccumL (\s x -> if (S.member x s) then (s,Nothing) else (S.insert x s, Just x)) S.empty
15:17:29 <lambdabot> <local>:9:87:     Ambiguous type variable `a' in the constraint:       `Ord a...
15:17:37 <sorear> @let ordNub xs = catMaybes . snd . mapAccumL (\s x -> if (S.member x s) then (s,Nothing) else (S.insert x s, Just x)) S.empty $ xs
15:17:39 <lambdabot> Defined.
15:17:43 <sorear> > ordNub [0..]
15:17:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:17:56 <sorear> > ordNub $ 12 : [0..]
15:17:57 <lambdabot>  [12,0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:18:05 <nornagon> cute
15:18:07 <bd_> sorear: hm, O(n lg n), I guess?
15:18:08 <sorear> O(n log n), in order, lazy
15:18:21 <bd_> Would it be safe for GHC to specialize nub to that when it can assume Ord?
15:18:40 <bd_> I mean, if you're breaking the rules for Ord you arguably deserve what's coming...
15:19:19 <sorear> bd_: safe, yes.  possible ?
15:19:42 <bd_> I've seen specialize declarations deep within various libraries, I don't see why not?
15:19:45 <sorear> actually I'd like a system where bogus Ords *cannot be written*
15:20:27 <sorear> of course unsafeShutUpAndActLikeACompiler might be needed someday :(
15:21:14 <nornagon> i don't see why such a system would really be all that useful
15:21:19 <nornagon> just obey the rules :P
15:21:30 <sorear> cleverness?
15:21:31 <bd_> sorear: undecidable...?
15:21:41 <bd_> You can quickcheck of course
15:21:46 <sorear> bd_: proof checking is very much decidable
15:21:46 <astrolabe> I don't see how it could be possible.
15:21:54 <bd_> oh, well, proof /checking/
15:21:59 <bd_> but then you need to write proofs :(
15:22:08 <astrolabe> It get arbitrarily hard to prove something is a poset.
15:22:31 <bd_> @check \a b c -> (a == b) && (b == c) => (a == c)
15:22:31 <lambdabot>  Parse error
15:22:49 <bd_> @check \a b c -> ((a :: Int) == (b :: Int)) && (b == (c :: Int)) ==> (a == c)
15:22:51 <lambdabot>  Arguments exhausted after 66 tests.
15:22:51 <sorear> bd_: you already do ... ghc helps, but it can't do the whole thing itself ... a ghc that can infer the types of class methods can infer arbitrary rank-2 types
15:23:31 <bd_> well, it's not a complete proof there. More of a statement of what the proof would be about, really?
15:31:37 <theturtlemoves> hey, could someone help me out with what must be a really trivial error?
15:32:04 <theturtlemoves> I've got a function definition that goes minThree :: Int -> Int -> Int -> Int
15:32:20 <theturtlemoves> and then it does stuff
15:32:39 <theturtlemoves> i get an error saying minThree is not in scope
15:32:40 <fasta> theturtlemoves: never ask to ask with lots of people in the channel.
15:32:54 <fasta> theturtlemoves: it's not a function definition
15:33:12 <fasta> theturtlemoves: it only states its type
15:33:36 <theturtlemoves> fasta: right, sorry, i'm new to the language
15:33:42 <fasta> minThree a b c = minimum [a,b,c]
15:33:57 <fasta> > let minThree a b c = minimum [a,b,c] in minThree [1,2,3]
15:33:58 <lambdabot>  Add a type signature
15:34:16 <bd_> > let minThree a b c = minimum [a,b,c] in minThree [1,2,3] :: Int
15:34:17 <lambdabot>      Expecting a function type, but found `Int'
15:34:17 <lambdabot>       Expected type: Int
15:34:17 <lambdabot>     ...
15:34:27 <fasta> > let minThree a b c = minimum [a,b,c] in minThree [1::Int, 2, 3]
15:34:29 <lambdabot>  <[Int] -> [Int] -> [Int]>
15:34:30 <bd_> :t minimum
15:34:32 <lambdabot> forall a. (Ord a) => [a] -> a
15:34:39 <bd_> > let minThree a b c = minimum [a,b,c] in (minThree 1 2 3 :: Int)
15:34:41 <lambdabot>  1
15:34:42 <bd_> >.>;
15:34:43 <nornagon> > minimum [1..]
15:34:47 <lambdabot> Terminated
15:34:53 <bd_> @pl minThree a b c = minimum [a,b,c]
15:34:54 <lambdabot> minThree = ((minimum .) .) . (. ((. return) . (:))) . (.) . (:)
15:34:59 <nornagon> nice
15:34:59 <bd_> much clearer :D
15:35:00 <dons> heh
15:35:13 <dons> ?let minThree = ((minimum .) .) . (. ((. return) . (:))) . (.) . (:)
15:35:14 <lambdabot> <local>:10:13:     Ambiguous type variable `a' in the constraint:       `Ord ...
15:35:18 <fasta> > let minThree a b c = minimum [a,b,c] in minThree
15:35:18 <fasta>               [1::Int, 2, 3]
15:35:19 <lambdabot>  Add a type signature
15:35:20 <dons> yeah yeah
15:36:41 <dons> hmm, #14 on the reddit front page
15:36:48 <dons> good thing its a good story :)
15:37:15 <newsham> ?type minimum
15:37:17 <lambdabot> forall a. (Ord a) => [a] -> a
15:38:09 <newsham> ?type min . min
15:38:11 <lambdabot> forall a. (Ord (a -> a), Ord a) => a -> (a -> a) -> a -> a
15:38:39 <bd_> ?type foldr1 min
15:38:41 <lambdabot> forall a. (Ord a) => [a] -> a
15:38:46 <bd_> ?src minimum
15:38:47 <lambdabot> minimum [] = undefined
15:38:48 <lambdabot> minimum xs = foldl1 min xs
15:39:15 <bd_> > minimum []
15:39:16 <lambdabot>  Add a type signature
15:39:19 <bd_> > minimum [] :: Int
15:39:20 <lambdabot>  Exception: Prelude.minimum: empty list
15:39:59 <newsham> > 5 `min` 3
15:40:01 <lambdabot>  3
15:40:38 <newsham> > let min3 a b c = a `min` b `min` c in min3 3 2 9
15:40:39 <lambdabot>  2
15:43:45 <fasta> Hmm, changing major mode is bad.
15:43:56 <newsham> does ghc have tools for parsing and type checking haskell code?
15:44:34 <newsham> ie. editor with haskell code in it, highlight a portion of a definition, right click and select "print type" from menu and get the type of the highlighted code
15:44:51 <newsham> does ghc have the support tools to parse the code and let you query the type information?
15:45:09 <fasta> newsham: There is GHC-API, but I never used it.
15:45:40 <newsham> is that part of hierarchical libs?
15:45:48 <fasta> newsham: Probably not.
15:45:59 <allbery_b> didn't dons come up with a script that uses ghci to do that?
15:46:14 <allbery_b> ?where typeOf
15:46:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/typeof/
15:47:00 <newsham> can typeof tell me the type of "x" in do { x <- act; return (f x) } ?
15:47:03 <nornagon> http://www.cs.uu.nl/~arthurvl/haskell.vba
15:47:51 <fasta> nornagon: I don't think so.
15:47:57 <fasta> newsham: I don't think so.
15:48:02 <fasta> nornagon: ignore
15:50:40 <nornagon> newsham: it's just a shellout to ghci
15:50:49 <nornagon> anything that ghci can tell you, typeOf can tell you.
15:51:13 <allbery_b> I think you'd need ghc-api to get that kind of information
15:51:16 <bd_> nornagon: only if it's an instance of Typeable
15:51:21 <allbery_b> effectively, it's ghc(i) as a library
15:51:23 <bd_> and a concrete type
15:52:45 <fasta> Writing an editor for Haskell is pretty difficult, because incremental parsing for it hasn't been done, AFAIK.
15:53:42 <fasta> Implementing a structured editor for Haskell also makes little sense, so I guess the rotten tools are here to stay for some time.
15:54:17 <newsham> i agree with the "difficult", but not with the "makes little sense"
15:54:24 <dons> I don't understand the first statement
15:54:27 <newsham> i think better dev tools would be very useful
15:54:43 <dons> you want incremental parsing on its own?
15:55:07 <dons> (we have incremental lexing, btw, that's what's behind visual haskell and yi's syntax highlighting)
15:55:27 <newsham> the compiler has lots of good info that would be useful if properly conveyed to the programmer while developing
15:55:41 <dons> yeah, this is the point of shim
15:55:46 <dons> the ghc-api bidning to emacs and vim
15:55:57 <genbie> hi, anyone knows which has the best support for haskell? vim or emacs please?
15:55:58 <fasta> oh, goodies, new information.
15:55:59 <dons> get at the type info, transformations, errors and so on.
15:56:12 <newsham> ?where shim
15:56:13 <fasta> @where shim
15:56:13 <lambdabot> http://shim.haskellco.de/trac/shim
15:56:13 <lambdabot> http://shim.haskellco.de/trac/shim
15:56:15 <nornagon> problem is that it doesn't make sense to compile a program at most states of editing
15:56:17 <fasta> heh
15:56:17 <dons> genbie: emacs has a little better support
15:56:19 <dons> vim is also good
15:56:34 <fasta> genbie: I use Emacs, dons uses vim. Pick your poison.
15:56:39 <genbie> dons thanks, could you please elaborate?
15:56:46 <dons> emacs supports indenting
15:56:54 <dons> of haskell, which vim doesn't. i use vim though
15:57:19 <genbie> thanks fasta.. i am just looking for a programming environment.. and found out that hIDE is no longer active unfortunately
15:57:20 <nornagon> not that there's a great amount of indenting that needs to be done
15:57:25 <dons> fasta: shim is probably where things are heading, and its pretty hot at the moment (emerged during the hackathon last week)
15:57:31 <nornagon> apart from what autoindent can provide
15:57:45 <fasta> dons: It looks a bit like SLIME.
15:58:00 <newsham> right now when you get a ghc type error you have to do manual type propogation around the error to mentally figure out where the error is.
15:58:06 <fasta> dons: That's the idea?
15:58:17 <dcoutts> dons, have you seen the latest yi/gtk patches? jyp seems to be doing well.
15:58:18 <newsham> if you could interactively query the compiler for what it thinks things are, you could narrow down the error a lot faster
15:58:23 <genbie> dons just indenting?
15:58:36 <fasta> genbie: what editor do you use now?
15:58:59 <dons> dcoutts: yeah, he's sending 10+ patches a day
15:59:03 <genbie> gedit and xemacs
15:59:06 <genbie> fasta
15:59:19 <dcoutts> tuukkah, oh you got gtk2hs with profiling? what was your technique, is it generally usable?
15:59:42 <dons> dcoutts: so what about these CString functions being unsafe
15:59:46 <dons> better docs?
16:00:03 <dcoutts> dons, well, I'd just stick them in IO
16:00:16 <dons> that's ok for packMallocCString
16:00:16 <genbie> i tried to use eclipse support for fp, but found it unnecessarily bloated
16:00:26 <newsham> (also an editor that automagically added type signatures would be nifty)
16:00:27 <sm> current Text.Printf can't truncate values to match field width, can it ?
16:00:36 <dons> but the point of packCString is that it shares the underlying CString
16:00:40 <dcoutts> dons, they are correct that they're not transparent, so they should just go in IO
16:00:45 <dons> so if you mutate the CString, you see that on the haskell side
16:00:48 <dcoutts> dons, yeah, that's fine if it's in IO
16:01:02 <tuukkah> dcoutts, i tried to do it properly but didn't quite get there :-(
16:01:03 <dons> how does that help?
16:01:06 <newsham> > printf "foo %3.3s bar" "aaaaa"
16:01:06 <lambdabot>  Add a type signature
16:01:14 <dons> shouldn't it be unsafePackCString -- warning warning
16:01:14 <newsham> > printf "foo %3.3s bar" "aaaaa" :: String
16:01:16 <lambdabot>  "foo aaaaa bar"
16:01:22 <dcoutts> dons, no I just mean that the behaviour becomes legit when it's in IO :-)
16:01:35 <dons> ah ok
16:01:42 <dons> it'll change the api
16:02:02 <dcoutts> dons, and sure, document that it requires you to not change the underlying data, oerthwise use the copy versions
16:02:06 <dons> i'm thinking though that packCString should be copyCString
16:02:12 <newsham> this "shim" thing looks pretty cool
16:02:15 <dons> and unsafePackCString should be the zero copy
16:02:22 <fasta> genbie: In that case I suggest GNU Emacs
16:02:23 <dons> ok. docs + IO
16:02:23 <dcoutts> dons, so are they impure even without doing other impure things?
16:02:25 <dons> that'll do
16:02:25 <genbie> newshim and fasta thanks for the shim link! lamdabot is really cool!!
16:02:31 <dons> dcoutts: nope
16:02:36 <dons> only if you go peeking on the C side
16:03:01 <genbie> yes fasta i am leaning that way too
16:03:01 <dons> dcoutts: though sorear points out a seperate issue with packMallocCString calling a finaliser twice
16:03:06 <dons> that should definitely be in IO
16:03:10 <dcoutts> right
16:03:11 <fasta> I won't be using shim for at least a month.
16:03:14 <newsham> this page mentions emacs but not vim..   but shim does work with vim?
16:03:18 <tuukkah> dcoutts, i have a small patch to mk/common.mk that describes .p_hi and then i configure --with-hcflags="-O -prof -hisuf p_hi -osuf p_o"
16:03:18 <dcoutts> dons, I'm just looking at that example again
16:03:21 <fasta> I can't imagine it to be in a usable state.
16:03:29 <dons> fasta: right. i don't think it is yet.
16:03:36 <dons> hold on for at least a  release announcement :)
16:03:46 <dons> but its good to know people care, and are working on it
16:03:51 <fasta> It isn't released yet. So, if even the developer thinks it's not ready.
16:03:53 <dcoutts> tuukkah, I see, ok, send in the patch. I'll take a look.
16:04:19 <fasta> dons: it's also a slightly more practical project than Yi, I guess.
16:04:22 <dons> well, yi's done.
16:04:25 <dons> and its vim :)
16:04:33 <dons> hIDE is something else entirely
16:04:47 <fasta> dons: Done?
16:04:47 <dons> (I was never going to turn yi into emacs + ide heaven...)
16:04:57 <hoelzro> hello, I'm new to haskell and I have a question regarding the Xlib bindings
16:05:00 <newsham> does gtk/yi work in windows (no vty)
16:05:02 <fasta> dons: oh, I got the impression you were at some point.
16:05:05 <dons> so yeah, a ghc-api binding to emacs and vim is far far more practical
16:05:26 <dons> fasta: nah, i just wanted to write vim in haskell, and that is what happened.
16:05:39 <hoelzro> where is there no get_PropertyEvent function in Graphics.X11.Xlib.*?
16:05:41 <newsham> shim also wants unix-any.
16:05:43 <fasta> dons: but you don't use it?
16:05:55 <fasta> dons: you use VIM 7?
16:05:56 <dcoutts> dons, hmm, there's an argument that packCString should be unsafe or in IO I guess.
16:06:06 <genbie> dons you wrote yi?
16:06:10 <fasta> dons: unless Yi is so "done" that it really is VIM.
16:06:11 <dons> sometimes i do. but the syntax highlighting isn't finished, which is the key missing piece
16:06:18 <dcoutts> dons, actually, the problem with packCString is that there's no way to know when it's safe to free the underlying memory
16:06:35 <dons> however, sorear has been assigned to finish the syntax highlighting, at which point i'll go back to using yi for everythiing
16:06:35 <fasta> dons: Ah, so it's not done (:
16:06:46 <dons> well, if you want nvi, its done
16:06:48 <dons> :)
16:06:54 <dons> genbie: yeah
16:07:09 <dons> dcoutts: I think it is both unsafe and in IO
16:07:13 <genbie> dons cool!
16:07:22 <dons> and that the copy version should be the default
16:07:31 <genbie> dons what about hIDE 2, you think it will see the light one day?
16:07:34 <fasta> I like VIM's responsiveness.
16:07:34 <dons> but we can achieve the same affect with docs I guess
16:07:42 <dons> genbie: it'll be called shim ;)
16:07:47 <fasta> Emacs feels more sluggish
16:07:52 <genbie> dons cool ;-)
16:08:04 <fasta> But that's only a visual thing, though.
16:08:07 <dons> dcoutts: you mean, packMallocCString?
16:08:54 <fasta> Ever heard of the Windows editor called Context?
16:09:35 <dons> nope
16:09:57 <fasta> Anyway, I used it for some time, (before I actively used *nix), and I was happy with it
16:10:01 <monochrom> hi
16:10:16 <fasta> When I look back it's just a better Notepad.
16:10:17 <dcoutts> dons, no, packMallocCString is ok, since it uses the finaliser. With packCString you have no idea when it's safe to deallocate the string, eg it's ok only for constant strings.
16:10:30 <dons> dcoutts: packMallocCString is ok if we move it into IO
16:10:36 <dcoutts> dons, yes.
16:10:41 <dons> right.
16:10:46 <dons> packCString is only ok for constnats
16:10:50 <fasta> Emacs is a complete documented system. The difference is enormous.
16:10:55 <dons> so its unsafe*
16:11:05 <dons> fasta: yeah I agree
16:11:06 <dcoutts> dons, right.
16:11:12 <fasta> VIM is also nicely documented, but I only know the basics.
16:11:36 <dons> dcoutts: if we're changing the types we might as well change the names as well
16:11:44 <dcoutts> dons, agreed.
16:11:46 <dons> unsafepackCString -- zero copy, only suitable for vegetarians
16:11:55 <dons> and copyCString --> packCString -- copy, safe for all
16:12:21 <dons> ok. i'll do this today
16:13:57 <dcoutts> dons, for 6.6.1 we can't change or add names, correct?
16:14:10 <dons> right
16:14:12 <dcoutts> dons, or is it ok to add functions and add deprecation warnings?
16:14:18 <dons> don't think so
16:14:21 <dcoutts> oh well
16:14:29 <dons> let's just stick this in the head
16:14:32 <dcoutts> yep
16:14:32 <newsham> hmm.. no gtk2hs installer for ghc6.6 (win)?
16:14:35 <dons> we can fix the docs
16:14:43 <dcoutts> newsham, sure there is! try the latest rc
16:14:59 <dcoutts> newsham, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
16:15:04 <newsham> i'm looking at http://www.haskell.org/gtk2hs/download/
16:15:06 <lambdabot> Title: Gtk2Hs » Download
16:15:33 <dcoutts> newsham, yep, it's not on the font page yet, the first release candidate was only announced to the users list
16:15:39 <newsham> ah.
16:15:40 <dcoutts> newsham, the next RC will be more public.
16:15:42 <newsham> grabbing
16:16:02 <newsham> so when i installed the gtk dev package it could only register with cygwin (didnt see msvc for some reason.. I have 2003)
16:16:03 <dcoutts> newsham, if you try that first rc, note that the theme bug is noted and fixed in the next rc.
16:16:16 <newsham> will that cause issues?  ghc uses its own gcc (msys/mingw?)
16:16:32 <dcoutts> newsham, sorry, what?
16:16:40 <dcoutts> I don't get the problem
16:17:04 <newsham> during the process of installing gtk+ it asks if you want to register environ variables
16:17:13 <dons> bringert: which db libs support mysql, do you know?
16:17:26 <newsham> and it gives you 4 checkboxes of dev environments to register with:  cygwin, msys, msvc and some other?
16:17:39 <dons> (or anyone familiar with the db libs around)
16:17:40 <newsham> anyway, for my box it only showed "cygwin" despite the fact that I have msvc 7 installed
16:17:59 <newsham> will that cause issues with the gtk2hs installer?
16:18:01 <dcoutts> newsham, no problem, the new gtk2hs installer comes bundled with it's own gtk+
16:19:03 <newsham> arghh..  :)
16:19:13 <dcoutts> dons, both HSQL and HDBC support mysql
16:19:26 <dcoutts> dons, and HaskellDB supports both HSQL and HDBC iirc
16:20:48 <sorear> tell fodder
16:22:54 <dons> ah ok
16:24:27 <newsham> In file included from ..\Yi\Regex.hsc:40:0:
16:24:28 <newsham> ../cbits/YiUtils.h:5:21:  ncurses.h: No such file or directory
16:24:39 <newsham> (building in yi/gtk)
16:26:44 <sorear> ouch
16:26:58 <sorear> I thought all ncurses was removed?
16:27:18 <newsham> there are some C helpers..  I'm not sure if I have the latest (checked out a few days ago?)
16:27:47 <sorear> I submitted a small patch to yi removing the unused ncurses C helpers (dons: *not* buffer helpers)
16:33:16 <newsham> cbits/YiUtils.[ch] have curses stuff in them.
16:33:28 <newsham> gtk/yi-gtk.cabal has vty dependency
16:36:57 <dons> dcoutts: I just proposed a fixed api, on the mailing list
16:37:00 <dons> whaddya thing?
16:37:06 <tuukkah> dcoutts, i sent a message with patches to gtk2hs-devel but of course it went into the moderation queue
16:37:34 <dcoutts> tuukkah, ok, np. It'll come through.
16:38:17 <sorear> newsham: edit the cbits, and delete the top two functions
16:38:30 <sorear> newsham: those are aren't even imported anymore
16:39:06 <dcoutts> dons, looks good.
16:39:19 <sorear> newsham: I submitted a patch earlier, but I think my later misguided attempts to refactor the buffer subsystem retroactivally tainted my yi-patch karma :)
16:39:45 <newsham> sorear: yah, did that (ifdefed them out)
16:39:57 <newsham> trying to get a stripped down Graphics.Vty so that I can build gtk
16:40:32 <newsham> i think i need colors and attrs but probably not a whole lot more
16:40:45 <sorear> probably not
16:40:57 <sorear> the colors and attrs are a pure data type
16:41:45 <sorear> newsham: you can probably get away with deleting everything from L110 down (in Graphics.Vty)
16:43:50 <sorear> dons: I suppose you don't want *.cabal highlighted as Haskell though...  synhl done right begets filetype recognition *gulp*
16:43:54 <sorear> @users
16:43:54 <lambdabot> Maximum users seen in #haskell: 322, currently: 286 (88.8%), active: 34 (11.9%)
16:48:20 <newsham> ../Yi/Style.hs:156:43: Not in scope: `Vty.def'
16:49:00 <newsham> blah, Style.hs imports Yi.Vty as Vty,  Yi/Vti.hs imports Graphics.Vty and lists it as an export
16:49:11 <newsham> Graphics.Vty has attr defined
16:49:13 <newsham> and exported
16:49:48 <TuringTest> dons: I like the new API
16:50:32 <newsham> ugh i'm dumb
16:51:53 <sorear> I don't even remember what def is for
16:52:06 <sorear> that's a bad sign when you wrote it :)
16:52:20 <dons> TuringTest: ok good.
16:52:28 <dons> so i think i'll just push that into the stable darcs repo
16:52:35 <dons> which is to become fps 0.8
16:52:39 <dons> that'll then get released
16:52:46 <dons> and then the stream fusion version becomes fps 0.9
16:53:00 <TuringTest> dons: Another API issue: My regex code is not supporting ByteString and Lazy ByteString and I am running into the Int vs Int64 issue  in the two APIs.  Perhaps I should project the regex API up to Int64.  Thoughts?
16:53:16 <TuringTest> not supprting ->now supporting
16:53:28 <dons> sounds reasonable
16:54:05 <dcoutts> TuringTest, I suppose someone might want to use a regexp search on a >4Gb file
16:54:29 <dons> gday reilly
16:54:31 <dcoutts> TuringTest, so your regex code is the haskell stuff right? not a C lib?
16:54:36 <dons> back for another round with the lambdas?
16:54:59 <sorear> dons: so, if devel on fps continues, which is better: fps-darcs or base-darcs ?
16:55:06 <dcoutts> TuringTest, the problem with all the existing C regex libs is that they can't work on the chunked representation we use for lazy bytestrings. It's really annoying.
16:55:15 <dons> sorear: fps-darcs is jsut for the devs really, and for ghc 6.4.x
16:55:24 <TuringTest> dcoutts: Did you see my regex-tdfa announcement?
16:55:27 <dons> after the stream stuff is done, i doubt there'll be much more than bug fixes
16:55:40 <TuringTest> It is pure haskell and works on Lazy bytestrings
16:55:43 <dcoutts> TuringTest, ok, that was you. Yeah I saw, sounds good.
16:55:49 <dcoutts> yay
16:55:51 <sorear> dons: can base-2.1 do all the fancy stream-fu that fps-0.9 can?
16:56:22 <TuringTest> dcoutts: I have instances for [Char], Seq Char, ByteString.Char8, and ByteString.Lazy.Char8
16:56:31 <dcoutts> dons, we'll need to move reasonably quickly to get the stream-fu into base for the 6.6.1 release
16:56:47 <dcoutts> TuringTest, great.
16:57:04 <TuringTest> dcoutts: I may want to get some regex-base updates into 6.6.1, what is the timeframe?
16:57:26 <dcoutts> TuringTest, you can't change the api though you realise. That's only for major versions.
16:57:35 <dcoutts> as for the time frame, ask Igloo
16:57:44 <TuringTest> dcoutts: I have a bug fix.
16:57:49 <dcoutts> that's fine
16:58:08 <sorear> dons: since you can't Depends: (base >= 2.0) || (fps-any) , would fps-1.0 = { Depends: base >= 2.0 ; Exposed-Modules ...} be a good idea?
16:58:11 <dons> dcoutts: well, if we're chanign the api anyway...
16:58:45 * dons just wants to get stream-fu into head
16:58:49 <dcoutts> dons, oh I see, we're not chaning it much. We could get the fusion in and make the api changes in head.
16:58:55 <dons> yeah
16:59:04 <dcoutts> dons, ok lets get it in head and think about merging to stable later
16:59:05 <dons> we can consider this once fps 0.8 is out
16:59:07 <dcoutts> right
16:59:25 <dons> i'd like to checksum the api for this job
16:59:28 <dons> so i know i'm not breaking things
16:59:37 <dcoutts> dons, use my tool
17:00:00 <dcoutts> http://darcs.haskell.org/gtk2hs/tools/apidiff
17:00:01 <lambdabot> Title: Index of /gtk2hs/tools/apidiff
17:00:12 <bringert> is there an excel tutorial for functional programmers?
17:00:17 <bringert> what's filter called?
17:00:26 <dons> bringert: hah.
17:00:29 <dons>  check with lennart
17:00:34 <dcoutts> poor bringert ;-)
17:00:45 <sorear> wow, I'ven't used excel for so long, I had no idea it even *had* filter
17:00:56 <sorear> you can't even use pointless code!
17:00:57 <dons> doesn't it have lambda abstractions now?
17:01:09 * dcoutts expects it does not
17:01:33 <allbery_b> well, you might beable to script it with F# :)
17:02:34 * bringert exports to csv
17:02:42 <bringert> and writes a haskell program
17:03:06 <dons> that's the preferred way to write filter, I think bringert :)
17:03:06 <newsham> so ghc dist in windows doesnt come with the regex utils in the libs.
17:03:10 <newsham> which yi depends on
17:03:20 <dons> newsham: they're in the extra-libs bundle
17:03:24 <bringert> but there must be a filter, right?
17:03:31 <dons> 'cept for regex-compat which is in the core libs
17:03:50 <newsham> dons: i mean regex.c.  yi calls down through ffi
17:04:45 <sorear> newsham: that's not a GHC concern, the funs yi calls are in POSIX
17:05:32 <sorear> gah. somehow I'd become convinced yi+syn was using the GHC lexer via GHC-API ... the truth is so much easier
17:05:40 <newsham> i'm not sure what your point is, sorear.
17:06:06 <newsham> my point is, ghc came with gcc+libs and those libs dont come with regex, so those have to be built separately to compile yi on win32.
17:06:17 <sorear> newsham: the funcs should've been provided by your OS vendor?
17:06:30 <allbery_b> google suggests there's a Data->Filter menu item
17:06:44 <newsham> sorear: my OS vendor didnt provide the gcc or libs that ghc is using.
17:06:45 <sorear> or at least GCC <|> cygwin
17:06:52 <newsham> ghc did.
17:07:02 <newsham> (i think its mingw built?)
17:07:04 <nornagon> oh
17:07:09 <nornagon> ozone is andre pang?!
17:07:20 <nornagon> hi!
17:07:38 <bringert> why is there still no splitBy?
17:07:45 <sorear> bringert: span?
17:07:55 <bd_> :t span
17:07:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:08:02 <bringert> sorear: no
17:08:02 <sorear> or do you mean unfolding ...
17:08:21 <bringert> splitBy :: (a -> Bool) -> [a] -> [[a]]
17:08:34 <newsham> i wonder if this gcc has enough pieces to build bsd's regex
17:08:56 <sorear> bringert: I think it is an issue of ppl deciding no bikeshed is better than a rainbow bikeshed :)
17:09:03 <newsham> (any reason yi uses C regex rather than haskell native lib?)
17:09:17 <bringert> but there is an obvious way to do it right
17:09:19 <sorear> newsham: ancientness, and perf concerns
17:09:48 <sorear> newsham: yi actually uses a raw Foreign.Ptr.Ptr Foreign.C.Types.CChar for a buffer
17:10:24 <sorear> that's how low level optimized it is
17:10:29 <SamB> eeeeeek
17:10:56 <sorear> SamB: and it uses malloc/free !
17:11:08 <SamB> mmmmhmmm
17:11:11 <bd_> sounds like a library waiting to be born :)
17:11:20 <SamB> I think the Ptr CChar part is scarier
17:11:41 <dons> don't be a wuss
17:11:58 <dons> newsham: only because it was written *before* the new regex libs
17:13:17 * Lemmih attempts to resurrect hIDE.
17:13:53 <sorear> urk! yi+syn has conflict markers!
17:13:53 <dons> Lemmih: hack on shim! :)
17:13:59 <Lemmih> shim?
17:14:05 <dons> sorear: maybe. just copy the src, don't use the repo
17:14:10 <dons> ?wher shim
17:14:11 <lambdabot> Maybe you meant: where where+
17:14:14 <dons> ?where shim
17:14:14 <lambdabot> http://shim.haskellco.de/trac/shim
17:14:22 <dons> beschimi et als ghc-api bindings to emacs and vim
17:14:33 <dons> (I think that's more likely to work than hIDE ...)
17:14:59 <sorear> shim works.  <-- user
17:15:46 <hpaste>  rohar pasted "something stupid" at http://hpaste.org/168
17:16:04 <Lemmih> Really? Something based on emacs can work?
17:16:39 <sorear> sure!
17:16:51 <sorear> yi'd be better of course :)
17:16:59 <Lemmih> Are we referring to the same emacs here?
17:17:20 <Lemmih> The emacs I have uses lots of e-lisp! Yak.
17:17:22 <sorear> Lemmih: CVS-version RMSmacs, you?
17:17:34 <basht> I'm guessing list comphrensions shouldn't be used like that
17:17:43 <sorear> agreed wrt elisp.
17:17:46 <basht> basht was rohar
17:18:12 <Lemmih> Anyhow, multiple IDE's will only benefit from each other.
17:18:24 <sorear> basht: echt!!! :)
17:18:30 <sorear> basht: use monads!
17:18:47 <basht> (gulp)
17:19:26 <basht> I'm just learning.. what's a better way to do what 'add' does?
17:19:41 <sorear> no, don't use monads
17:19:44 <Lemmih> dons: hIDE has more potential than shim, imho.
17:19:56 <basht> Does the data structure make sense?  a pair of a pair and an Int
17:20:20 <sorear> Lemmih: is a ncurses/vty/termcap based interface planned, ever, for hIDE?
17:20:31 <sorear> <-- persecuted-feeling console user
17:21:34 <basht> pity me, friends.. I may use comprehensions that way forever!
17:21:35 <twanvl> basht: It may be better to use a custom datatype, for example:  data MarkovItem = MarkovItem { from, to :: Word, occurences::Int }
17:22:40 <basht> twanvl: I see that.. thx..   the thing I'm doing in the comphrensions, tho, busting up the data and reconsituting it.. is there any easier way?
17:22:54 <twanvl> Your current approach has some advantages as well
17:23:46 <hpaste>  sorear annotated "something stupid" with "use Map!" at http://hpaste.org/168#1
17:24:07 <TuringTest> dcoutts: The API changes look very clear for gtkhs.  Is there a "isGUIThread :: IO Bool" that can test if the current thread is the GUI thread?
17:24:38 <Lemmih> sorear: Yes. Well, it came up in passing. We didn't do a whole lot of planning.
17:24:54 <dcoutts> TuringTest, no, I've not added that. We'd need to add a top level IORef to save the ThreadID, want to send in a patch?
17:25:15 <basht> thx sorear... I will go off until I am stupid no more.  thx all!
17:25:18 <TuringTest> dcoutts: Nah...I need sleep.   Good night all!
17:25:26 <dcoutts> g'night TuringTest
17:26:50 <sorear> wow, tar --help is longer than my kernel scrollback buffer
17:27:59 <sorear> dons: the conflict markers are in the tarball
17:28:05 <ndm> dcoutts, have just sent the Gtk list an email with my thoughts on your new API function...
17:28:16 <ndm> somewhat sarcastic, somewhat drunk - just so you have context
17:28:18 <dcoutts> ndm, ta
17:28:22 <dcoutts> hah hah
17:28:23 <dcoutts> ok
17:31:30 <newsham> ok, yi.exe built... but when i run, nothing :)
17:32:53 <sorear> newsham: hnop is a lot more portable iirc, it could fill that role easier
17:34:22 <newsham> same thing when I build a gtk2hs demo program
17:34:47 <dcoutts> newsham, hmm, what os, gtk2hs & ghc version ?
17:35:02 <dcoutts> ah, win32
17:35:23 <newsham> its a PATH issue.
17:35:38 <dcoutts> oh, nasty. did the installer detect it?
17:35:50 <newsham> Core.startE: mkstemp failed
17:35:50 <newsham> yi.exe: Core.startE: mkstemp failed
17:35:52 <newsham> closer!
17:35:56 <dcoutts> the new installer is supposed to detect that situation
17:36:04 <newsham> dcoutts: I didnt have the gtk2hs bin dir in my current PATH
17:36:17 <newsham> added and calc.exe worked fine
17:36:23 <dcoutts> newsham, hmm, the installer is supposed to set the path
17:36:35 <ndm> dcoutts, does it set the user path or the computer path?
17:36:43 <newsham> i'm in a shell.. I have my own paths (and didnt restart since installer ran)
17:36:44 <dcoutts> ndm, it sets the user's path
17:37:00 <dcoutts> newsham, oh ok, just starting a new shell should be enough
17:37:10 <newsham> i dont use the windows PATH.
17:37:12 <newsham> so it wouldnt in my case
17:37:20 <newsham> my .bashrc constructs a clean path
17:37:22 <dcoutts> ok
17:37:29 <newsham> operator error.
17:37:38 <dcoutts> ndm, it sets the users path and checks for clashes on the system path.
17:37:59 <ndm> dcoutts, i believe the user path takes precedence
17:38:18 <dcoutts> ndm, really? I didn't think so
17:38:31 <newsham> ahh, yi expects there to be \tmp.
17:38:42 <dcoutts> ndm, my path seems to be the concatenation of the system and user path
17:38:47 <sorear> newsham: Yi/MkTemp.hs
17:38:56 <newsham> cool, I have a gtk yi window up..
17:39:04 <newsham> it doesnt seem very responsive to keyboard though :)
17:39:10 <newsham> menu looks good
17:39:27 <dcoutts> ndm, more precisely, the path env var is the concatenation of the registry values for system and user path.
17:39:32 <ndm> dcoutts, you are right, its the other way round
17:39:49 <newsham> ls
17:41:16 <newsham> who actively maintains yi?
17:41:29 <dcoutts> newsham, jyp and sorear I think.
17:41:38 <newsham> sorear: interested in diffs?
17:42:30 <Lemmih> dons: Patches for hs-plugins/ghc6.6 coming up.
17:43:46 <ndm> dcoutts, you gonig to BCTCS 2007?
17:43:54 <dcoutts> ndm, probably not
17:44:08 <ndm> dcoutts, i am, just got a grant application back :)
17:44:24 <ndm> if you want to see how to make haskell first order, its the place to be :)
17:44:42 <sorear> newsham: don't send me patches ... I'm still a whiles away from usefully contributing to yi
17:44:46 <dcoutts> oh great, well I'll see you there
17:45:02 <sorear> ndm: see GRIN, boquist has solved that problem
17:45:04 <dcoutts> ndm, I'll still be in Oxford then, it's just before I go to .au
17:45:09 <newsham> email for jyp?
17:45:21 <sorear> newsham: dons is the repokeeper
17:45:25 <ndm> sorear: does that make it first order?
17:45:34 <sorear> ndm: GRIN is fist order
17:45:35 <dcoutts> newsham, see 'darcs changes' for one of his patches
17:45:44 <newsham> i dont have proper patch to commit
17:45:50 <ndm> sorear: i didn't think it was, how does it translate haskell to GRIN?
17:45:50 <newsham> just some general notes
17:46:20 <ndm> sorear: i.e. it starts off higher order and then becomes first order in GRIN, how? before it gets to GRIN or once it is there?
17:46:29 <dcoutts> ndm, see the jhc site, it has some description
17:46:33 <sorear> ndm: it creates explicit data structures representing partial applications, and then cases for calls
17:46:53 <dons> Lemmih: oh oh oh !
17:46:55 <sorear> ndm: during the nhc.core -> grin transformation
17:47:03 <dons> Lemmih: details?
17:47:14 <dons> to what address should I send the carton of beer?
17:47:17 <ndm> sorear: ah yes, reynolds style defunctionalisation - complete and pretty horrid for program analysis
17:47:17 <dons> ;)
17:47:48 <ndm> sorear: it is complete, but not as beautiful as my solution - its what i use as a backup if my solution fails
17:47:50 <dcoutts> dons, ah, I'm doing the funding application tomorrow and am looking for estimates on housing...
17:48:04 <sorear> ndm: well it must be good for *something*, JohnMeacham tapped it as the backend in jhc
17:48:17 <dons> dcoutts: ok. you want me to send you some options?
17:48:23 <dcoutts> dons, that'd be great
17:48:24 <ndm> sorear: oh, its great, just mine is better for program analysis - it disturbs the code less
17:48:30 <dons> dcoutts: i'll mail you some later today
17:48:40 <dcoutts> dons, thanks muchly!
17:48:57 <sorear> ndm: OH! I thought you were asking how to do it, not suggesting a way :)
17:49:09 <ndm> sorear: that approach is similar to embedding an interpretter in the language, so one extra level of indirection - fine if your compiler removes it, but bad if you want to analyse
17:49:31 <ndm> sorear: oh yes, i have a method - Reynold's style was one of my original backups - but thanks for the info on GRIN, very useful
17:49:54 <sorear> ndm: analysis /= optimization? confusion level ++
17:49:55 <Lemmih> dons: It couldn't find any packages because of the new version tag. Quite simple. I'm cleaning it up now; patches will ensue.
17:50:02 <ndm> i wonder if my method gives a better GRIN level interpretation, or if GRIN optimises the overhead the Reynold's style generates out
17:50:12 <edwinb> I thought the interesting thing about grin was the analysis it could do as a result, not necessarily the fact that it was first order itself
17:50:12 <dcoutts> ndm, the lovely thing about the jhc transformation is how it works out for classes and non-dictionary a based impl.
17:50:24 <ndm> sorear: if you want to analyse code and report back to the user, its best not to screw with the code more than you have to
17:50:42 <ndm> dcoutts, mine takes dictionary transformation, then removes the dictionary afterwards
17:50:57 <sorear> ndm: so analysis as in Catch, not analysis as in Simplifyer ?
17:50:59 <ndm> dcoutts, mainly because thats what Yhc gives me, rather than any reason its better
17:51:06 <ndm> sorear: yes, indeed
17:51:16 <sorear> makes sense now :)
17:51:17 <dcoutts> ndm, remove the dictionary? how?
17:51:57 <ndm> dcoutts, by generating specialised versions for each instance, essentially - but via a generalised firstification algorithm
17:52:12 <dcoutts> ah ok
17:55:45 <dons> Lemmih: yes, that was a known issue.
17:55:51 <dons> I should have documented this stuff ...
17:56:01 <dons> Lemmih: also, talk to robreim
17:56:27 <dons> anyone notice anything funny about http://programming.reddit.com/
17:56:28 <lambdabot> Title: reddit.com: programming - what&#39;s new online
17:56:43 <mbishop> there's lots of haskell links? :P
17:57:04 <dons> we have the technology!
17:57:21 <dons> as long as there's fun new things to do in this language, i think we'll keep sucking in the early adopters
17:57:30 <robreim> Lemmih: what version tag is this? you mean how the packages are of the form <package name>-<version>?
17:57:47 <dons> yeah, it changes how you look things up in the package database
17:57:55 <dons> and hence on whether or not you can find dependent packages
17:58:59 <newsham> anyone use the yi+gtk version?
17:59:04 <robreim> hmm.. I seem to remember looking into that and finding that packages included versions at least as far back as 6.4.2... I'll have to double check...
17:59:20 <mbishop> I've been thinking about making a "Reddit asks you!" post on reddit, where I ask for names/emails of "famous" programs and questions that reddit uses want to ask
17:59:44 <dons> famous programmers?
17:59:46 <dons> or programs?
17:59:58 <mbishop> I'm interested in what languages they use, why they use them, how they started, etc...and I'll include the more popular questions people ask
18:00:01 <mbishop> famous programmers
18:00:12 <mbishop> dons: you'd be one on the list :P
18:00:15 <dons> oh, i thought a turing test for famous programs would be more fun
18:00:18 <dons> mbishop: hehe
18:00:25 <mbishop> it's kind of like "the Road to lisp"
18:00:26 <dons> yeah "famous" eh?
18:00:37 <mbishop> only not specific to a language
18:00:45 <dons> mbishop: yeah, you could solicit a top 10 question list
18:00:58 <dons> then send it off to key language hackers, and get their responses
18:00:58 <mbishop> http://wiki.alu.org/The_Road_to_Lisp_Survey
18:01:01 <lambdabot> Title: ALU Wiki: The Road to Lisp Survey
18:01:02 * mbishop nods
18:01:03 <dons> you could do a whole series that way
18:01:05 <sorear> Do I qualify yet?
18:01:12 <sorear> <-- wannabe oleg
18:01:15 <dons> sorear: so when did you first find out about Haskell?
18:01:22 <dons> what was the first type level program you wrote?
18:01:29 <monomorph> Knuth is a famous programmer.  His answers will unmake your world.
18:01:34 <mbishop> I thought about making a post with the idea, and then getting people to post name/emails of people they watned to get the answers for as well
18:01:44 <dons> what did you do to get your first segfault in haskell?
18:01:47 <mbishop> monomorph: "who are you, and what are you doing in my house?" :)
18:02:08 <sorear> um... I wasn't keeping notes?
18:02:14 <bd_> <-- first segfault was playing with unsafeCoerce# in ghci, I think :)
18:02:18 <dons> cool
18:02:20 <bd_> or was it throw#?
18:02:22 <dons> that's the best way, bd_ :)
18:02:30 <bd_> yeah, probably throw# :)
18:02:30 <dons> unsafeCoerce# () :: Int
18:02:33 <sorear> <-- I think I was playing with instance Typeable where
18:02:35 <monomorph> One thing that surprises even many people in this channel: he uses emacs.
18:02:40 <bd_> I managed to get it to throw# and catch# an Int in the end :)
18:02:43 <sorear> <--- or maybe it was old .hi files ...
18:02:44 <dons> heh
18:03:36 <sorear> funny, I was so sure knuth used a telephone and a modem :)
18:04:05 <sorear> speed modem whistling .... arcane sports rank: ?
18:04:05 * allbery_b half suspected he'd written an editor in texguts...
18:04:52 <sorear> ed isn't have as bad as it is made out to be ...
18:05:04 <dons> so, does Eric <lastname> hang out here? http://blogs.nubgames.com/code/?p=17
18:05:05 <lambdabot> Title: Nub Games » One Month with Haskell
18:05:12 <dons> he's written some very positive reviews/comments in the last month
18:05:41 <robreim> Lemmih, dons: a diff of ghc 6.4 and ghc 6.6's compiler/main/PackageConfig.hs shows no difference wrt PackageIds containing version strings... is this the same version you guys were talking about?
18:05:48 <sorear> kowey? I'm sure I've seen him here
18:05:56 <dons> not kow
18:05:58 <dons> ey
18:06:31 <mbishop> http://programming.reddit.com/info/11k1e/comments
18:06:33 <lambdabot> Title: Ask Reddit: Reddit asks YOU! (details inside) (reddit.com)
18:07:14 <dons> hmm, i get page not found :(
18:07:17 <dons> heya nostrademons !
18:07:21 <dons> how's the code
18:07:25 <sorear> Eric Sessoms
18:07:34 <dons> sorear: have we seen him in here?
18:07:41 <Lemmih> robreim: hs-plugins internally discarded the version part of the PackageIds.
18:07:43 <sorear>    Nub Games, Inc.
18:07:43 <sorear>    4819 Bradshaw Quarry Rd
18:07:43 <sorear>    Efland, NC 27243-9718
18:07:43 <sorear>    US
18:07:50 <sorear>       Sessoms, Eric             vain@nubgames.com
18:08:05 <dons> sorear: ok... maybe you shouldn't do that ;)
18:08:25 <sorear> the whois, or the pasting?
18:08:46 <robreim> Lemmih: oh ok. So how did that break things for 6.6?
18:09:45 <robreim> (the main change I've found btw is that ModuleNames are now distinct from Modules in ghc 6.6 which seems to change the .hi format a bit. I've tried fixing that but I'm getting other bizarre linker bugs now.)
18:11:06 <robreim> ie Modules are now called ModuleNames and Modules have become a data type containing a ModuleName and PackageId
18:11:09 <sorear> wow, whois and google are unstoppable
18:11:29 <fons> hi all
18:12:13 <sorear> amazon.com profile: "Basic Category Theory for Computer Scientists"  doesn't that just *scream* haskeller?
18:12:38 <Pseudonym> I dunno.  The word "Basic" in the title seems a little non-haskeller.
18:13:28 <calvins> @paste
18:13:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:13:58 <sorear> ooh... brackish water fish ... replying to a post by ... oleg kiselev !? what a name coincidence
18:14:11 <robreim> sorear: I've got that book. It's pretty hefty for "basic" I found. Then, I've never done any category theory or most of the background math it mentions.
18:14:34 <hpaste>  calvins pasted "Ghc Compilation problem involving Ratio and -fglasgow-exts" at http://hpaste.org/169
18:16:18 <sorear> calvins: works here, with -fglasgow-exts
18:16:25 <bd_> fails here
18:16:33 <sorear> fails here with 6.6
18:16:49 <sorear> doh!
18:17:01 <hpaste>  fons pasted "Multiparameter class instance error ..." at http://hpaste.org/170
18:17:04 <sorear> calvins: put spaces around (%)
18:17:14 <allbery_b> so what does %x mean?
18:17:17 <sorear> calvins: w/o spaces, a%b is a %b
18:17:30 <sorear> allbery_b: linear implicit parameter named 'x'
18:17:39 <sorear> allbery_b: did you really want to know? :)
18:17:45 <fons> I'm getting an instantiation error when trying to compile the code of the paste above
18:17:52 <fons> can someone please have a quick look at it?
18:18:01 <allbery_b> sorear: on second thought...
18:18:12 <calvins> sorear: doh! thanks for that! I was puzzled because it works fine in ghci and hugs both, just won't compile.
18:19:02 <fons> it seems to be quite basic, but I don't understand why Synchronous s ((a, b) -> a) (a, b) a) isn't covered by the Synchronous s  (a->b)  a b instance
18:20:09 <calvins> so is it a bug that "a%b" is parsed as I wanted it to be in ghci and ghc (without -fglasgow-exts)?
18:21:22 <fons> calvins, when you use -fglasgow-exts a different language grammar is applied when parsing
18:21:23 <sorear> calvins: I think you need -fglasgow-exts to enable support for linear implicit parms
18:21:50 <sorear> linear-implicit-parms were deleted in HEAD - too complicated, too few uses
18:22:26 <fons> sorear, could you please have a look at http://hpaste.org/170 ?
18:23:15 <sorear> there are multiple eric sessoms out there
18:23:22 <calvins> thanks, so the problem was that % is overloaded and with the extensions enabled, got parsed as something other than the Ratio (%) operator, whereas something like a+b would always work.
18:23:59 <sorear> on the first three google pages we have a programmer of unknown location, a medical malpractice plaintiff in Ohio, and a homeless guy in NY
18:24:04 <allbery_b> as a rule I use spaces around operators, in part to avoid such issues.  (now if only it worked for (-)...)
18:25:27 <calvins> yeah, perhaps I should start using spaces again. I used to, but then I started not using them because they can really bloat your lines if you're doing a lot of arithmetic ops on one line...
18:25:46 <calvins> thanks everybody...
18:26:09 <allbery_b> (a) multiple lines (b) if you're' doing thatmuch math, use subexpressions.  easier to figure out what's going on anyway
18:26:19 <allbery_b> and what else are where clauses for?
18:26:22 <dylan> sorear: how's the urxvt-bug fixing going?
18:26:49 <sorear> dylan: distracted?
18:27:35 <dylan> sorear: ah. Perhaps I'll take a wack at it after I finish these stupid humanities essays...
18:27:55 <mbishop> sorear: you were added to the list, btw :P
18:28:33 <sorear> dylan: bug reproduced ... characterization soon?
18:28:36 <sorear> mbishop: which one?
18:28:49 <fons> Anyone willing to give me a hand with the instantiation problem?
18:28:52 <mbishop> to get the "reddit asks you" survey
18:29:42 <fons> Uhm, well I guess I'll send it to haskell-cafe :(
18:31:09 <dons> fons, ?? paste it
18:31:11 <dons> ?paste <--
18:31:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:31:14 <jeberle> fn1: spending a lot of time in gdb?
18:31:18 <dons> and then we 'll see what we can do eh?
18:31:36 <dylan> writing english-y papers would be good if I didn't have to use the horrible MLA citation style. Why can't I use the one amslatex uses? :(
18:31:39 <dons> (its a quite time of the day for the nxt 5 hours or so, but there's still a few dozen people active.)
18:31:42 <fons> dons I pasted it already  http://hpaste.org/170 could you please have a look at it?
18:31:53 <dons> looking...
18:32:13 <fons> dons,  I don't understand why Synchronous s ((a, b) -> a) (a, b) a) isn't covered by the Synchronous s  (a->b)  a b instance
18:33:31 <dons> i'm looking at it fons.
18:33:34 <sorear> dylan: I found it! I found it!
18:34:08 <sorear> dylan: simply put, incompatibility between urxvt and ^[%G
18:34:36 <sorear> dylan: I'll put in a quick fix and release 2.0.1
18:35:01 <fons> dons, strange, I just found out that it works if "fstSY a = mapSY fst a" is declared instead of "fstSY = mapSY fst"
18:35:13 <sorear> dylan: 2.1 will have $TERM support, and will work mcuh better on weird terminals, iff it ever happens :)
18:35:18 <dylan> sorear: you da man.
18:35:32 <dons> ah ..
18:35:41 <dylan> sorear: perhaps I'll try writing a termcap parsing library..
18:36:29 <dons> fons, you could ask on glasgow-haskell-users@ about this, spj would know what's going on (sometimes you need the extra point to help type inference ... I don't know why. It might even be fixed in HEAD)
18:37:18 <fons> dons, I'm not subscribed to that list, shouldn't haskell-cafe be enough?
18:37:23 <hpaste>  dons annotated "Multiparameter class instance error ..." with "points" at http://hpaste.org/170#1
18:37:30 <dons> fons, well, its ghc specific
18:37:39 <dons> but haskell-cafe@ would do, if you explicitly cc. spj as well
18:37:50 <dons> i'd actually try ghc head first
18:38:06 <dons> just to check if it hasn't been fixed (a lot of the type inference stuff for typeclasses has been reworked recently)
18:40:50 <sorear> dylan: for testing - how do I tell urxvt to use UTF8 ?  some env var I think ...
18:41:10 <bd_> LC_ALL=en_US.UTF-8 ?
18:41:16 <dylan> sorear: think about it -- the vty library can't set a env var that the terminal will see.
18:42:13 <sorear> dylan: of course - this will be needed in the full fix. since vty is using utf8 atm, what do I set to tell urxvt to interpret utf8?  FOO=bar urxvt
18:42:33 <bd_> LC_ALL=(something).UTF-8 :)
18:42:37 <hpaste>  dons annotated "Ghc Compilation problem involving Ratio and -fglasgow-exts" with "looks like a whitespace % issue" at http://hpaste.org/169#1
18:42:42 <dons> calvins: ^^
18:42:55 <sorear> dons: I already fixed it, and calvins already acked
18:43:18 <nornagon> LANG?
18:43:20 <fons> dons, yep it's a type inference problem, if I declare the type signature of the function no error is thrown
18:43:31 <fons> I'll report it anyway
18:44:10 <dons> sorear: fixed it? in ghc... ?
18:44:18 <dons> fons, right. please do
18:44:21 <dons> check with head if you can
18:45:36 <sorear> dons: [18:13] <sorear> calvins: w/o spaces, a%b is a %b <sorear> allbery_b: linear implicit parameter named 'x'
18:45:37 <sorear>  
18:45:40 <Anon4888> I'm looking to output some custom math looking text with very specific formatting requirements (I don't think TeX is going to work for me)
18:45:59 <Anon4888> I'm thinking about just putting out a utility to render the text for me
18:46:02 <sorear> Anon4888: hmm. HughesPJ maybe? (if text only is sufficient)
18:46:10 <Anon4888> No it's graphical & symbols
18:46:18 <dons> sorear: ah yes
18:46:37 <calvins> dons: thanks, sorry for forgetting to update the paste after the fix was found
18:46:38 <Anon4888> I'm wondering what format to target: will HTML work? is DVI easy?
18:46:55 <sorear> Anon4888: can you give more details? sounds like a job for image composition combinators, a la SOE
18:47:07 <Anon4888> Yes, could be
18:47:17 <sorear> Anon4888: PS is very easy
18:47:36 <sorear> and can be converted to dvi(iirc) and pdf(ikfs)
18:47:46 <Anon4888> Would SOE be able to target those formats as well?
18:47:50 <mbishop> Heh someone voted down my comments to my own topic :/
18:48:22 <dons> heh
18:48:29 <dons> the fickle reddit crowd..
18:48:44 <dons> maybe if you posted some code fragments instead. or mentioned lisp prominently ;)
18:49:24 <mbishop> heh
18:49:28 <dons> fons, also, you should mention that no error arises if you give an explicit type signature
18:50:00 <fons> forgot about that ... I'll send a reply to the post
18:50:19 <calvins> how does one award karma to somebody?
18:50:28 <sorear> calvins: karma++
18:50:40 <calvins> sorear: karma++
18:50:49 <calvins> sorear:  so that gave you karma?
18:50:51 <sorear> oh, sorry, nick++
18:50:58 <sorear> @karma nick
18:50:59 <lambdabot> nick has a karma of 1
18:51:00 <calvins> sorear++
18:51:01 <sorear> nick++
18:51:04 <sorear> @karma nick
18:51:04 <lambdabot> nick has a karma of 2
18:51:08 <sorear> nick-- nick--
18:51:14 <dons> test nick++ test test
18:51:16 <calvins> @karma calvins
18:51:17 <lambdabot> You have a karma of 1
18:51:19 <dons> ?karma nick
18:51:19 <lambdabot> nick has a karma of 1
18:51:24 <dons> test nick++ test test
18:51:26 <dons> ?karma nick
18:51:26 <Anon4888> sorear: thanks for the help.  Do you have an opinion as to whether SOE or outputting PS directly would be more straightfoward?
18:51:26 <lambdabot> nick has a karma of 2
18:51:37 <calvins> test sorear++
18:51:45 <sorear> dylan: (debian here) where do I get en_US.UTF8 ?
18:51:57 <calvins> dons++
18:52:00 <sorear> @karma
18:52:00 <lambdabot> You have a karma of 22
18:52:03 <sorear> @karma dons
18:52:03 <lambdabot> dons has a karma of 117
18:52:10 <dylan> sorear: dpkg-reconfigure locale
18:52:12 <maskd> @karma c
18:52:12 <dylan> or locales
18:52:13 <lambdabot> c has a karma of 15
18:52:14 <dylan> I forget.
18:52:16 <bd_> locales
18:52:55 <sorear> dylan: !? if they're not on my system how will that help?  (doing it anyway, just confused)
18:54:01 <sorear> that worked
18:54:21 <dylan> ja.
18:55:20 <bd_> sorear: they're generated by converting another charset's data, generally
18:55:30 <bd_> eg en_US would probably be ISO-8859-1 -> UTF-8, I think
18:55:58 <sorear> dylan++
18:56:14 <Anon4888> BTW, do you have a link for SOE?  I'm not finding it...  does it ship with Haskell?
18:56:30 <sorear> anyway, UTF8-vty-urxvt can be made to work (yay)
18:56:45 <emu> are there any tools for htmlizing .lhs files
18:57:09 <dons> lhs2tex ?
18:57:13 <dons> tex2html ?
18:57:31 <emu> that'll produce some pretty large and wacky results, though
18:57:36 <dons> yeah
18:57:42 <emu> and i meant bird-lhs
18:58:01 <dons> ah, hscolour would do
18:58:06 <dons> ?where hscolour
18:58:07 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
18:58:14 <dons> you just want pretty coloured code?
18:58:23 <emu> i did try that, but it goes nuts and treats the literate part as code
18:58:39 <dons> yeah
18:58:41 <mbishop> Anon4888: You need the Haskell Graphics Library, it has an SOE module inside of it
18:58:42 <emu> maybe if it only operated on > sections
18:59:09 <EvilRanter> cunning application of sed?
18:59:23 <calvins> Anon4888: soe module is: Graphics.SOE
18:59:29 <Anon4888> thanks guys
18:59:39 <emu> maybe i will just hack somnething up
19:01:13 <rohar> is there a function which converts ["a", "b", "c", "d"] to [("a","b"), ("c","d")] ?
19:01:35 <rohar> or an easy way to do that?
19:01:47 <LoganCapaldo> @hoogle [a] -> [(a,a)]
19:01:48 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
19:02:04 <LoganCapaldo> Hmm
19:02:08 <sorear> rohar: uh ... ap zip tail?
19:02:15 <sorear> > ap zip tail [0..]
19:02:16 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
19:02:24 <sorear> ^^^ you want that?
19:02:51 <rohar> actually, yes.. I was going to double the elements first and then do what I originally asked, but that hits it on the head
19:02:58 <rohar> thx
19:03:10 <magnus--_> @hoogle ap
19:03:11 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
19:03:11 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
19:03:11 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
19:03:31 <sorear> ?unpl ap zip tail
19:03:31 <lambdabot> (zip >>= \ b -> tail >>= \ a -> return (b a))
19:03:36 <emu> thats not quite it
19:03:38 <bd_> magnus--_: Control.Monad.ap instantiated with Monad (->) of course
19:03:42 <bd_> s/of course//
19:03:47 <LoganCapaldo> Is there an Arrow-ish way to do ap?
19:03:54 <sorear> LoganCapaldo: app ?
19:04:08 <LoganCapaldo> @hoogle app
19:04:09 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
19:04:09 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
19:04:09 <lambdabot> Ratio.approxRational :: RealFrac a => a -> a -> Rational
19:04:21 <LoganCapaldo> guess so :)
19:04:21 <sorear> > app ((*2), 5)
19:04:23 <lambdabot>  10
19:04:58 <dons> ?users
19:04:58 <lambdabot> Maximum users seen in #haskell: 322, currently: 287 (89.1%), active: 34 (11.8%)
19:05:28 <magnus--_> Monad (->)?
19:05:50 <sorear> magnus--_: no, Monad ((->) a)
19:06:20 <sorear> return x = \_ -> x
19:06:32 <magnus--_> That solution doesn't do what he asks for
19:06:50 <sorear> magnus--_: you're right ... but he's fine with that
19:07:06 <magnus--_> that explains why I'm confused :)
19:07:13 <sorear> <*rohar> actually, yes.. I was going to double the	elements first and then do what I originally asked, but that hits it on the head
19:07:14 <sorear>  
19:07:30 <LoganCapaldo> @src ((->) a) (>>=)
19:07:31 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:07:41 <sorear> @src (->) (>>=)
19:07:41 <lambdabot> f >>= k = \ r -> k (f r) r
19:07:46 <sorear> @src (->) return
19:07:46 <lambdabot> return = const
19:07:50 <sorear> @src (->) (>>)
19:07:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:07:56 <sorear> @src (->) join
19:07:56 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:08:02 <sorear> join f x = f x x
19:08:09 <sorear> ap f g x = f x (g x)
19:08:27 <sorear> liftM f x y = f (x y)
19:08:44 <sorear> liftM2 f g h x = f (g x) (h x)
19:09:04 <EvilRanter> alternatively, for people who find ap scary: [(a,b) | a:b:_ <- tails (...)]
19:09:16 <LoganCapaldo> > join (,) (*2) (*3) 3
19:09:16 <lambdabot>      Expecting a function type, but found `(a, b)'
19:09:17 <lambdabot>       Expected type: a -> ...
19:09:26 <magnus--_> how about zip x (tail x)
19:09:41 <LoganCapaldo> > ap (,) (*2) (*3) 3
19:09:41 <lambdabot>      Expecting a function type, but found `(a, b)'
19:09:42 <lambdabot>       Expected type: a1 ->...
19:09:42 <EvilRanter> yes, that's true...
19:09:43 <sorear> magnus--_: the ap version is shorter
19:09:49 <sorear> LoganCapaldo:
19:09:56 <sorear> > liftM2 (,) (*2) (*3) 3
19:09:58 <lambdabot>  (6,9)
19:10:06 <magnus--_> sorear: and more confusing :)
19:10:08 <sorear> > join (,) 3
19:10:10 <lambdabot>  (3,3)
19:10:10 <LoganCapaldo> right I 've seen it before :)
19:10:22 <LoganCapaldo> was trying to remember it by doing
19:10:46 <glguy> > (*2) &&& (*3) $ 3
19:10:47 <lambdabot>  (6,9)
19:11:01 * glguy doesn't know the context of what you were discussing,  but contributes that ;)
19:11:25 <sorear> glguy: magnus--_: no, Monad ((->) a)
19:11:34 <LoganCapaldo> arrows + Monad ((->) a) both hurteth my brain :)
19:11:52 <EvilRanter> deja vu...
19:11:56 <magnus--_> sorear: Monads are hard, and you have to memorize each instance what it does
19:12:14 <Anon4888> I think PS will be easiest actually.  Thanks sorear!
19:12:49 <Cale> > map (ap (,) (join (*))) [1..10]
19:12:51 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
19:13:23 <magnus--_> the same monad word means completely different things in different contexts
19:13:56 <magnus--_> which you have to memorize
19:14:17 <monomorph> Numbers are hard.  You have to memorize what + does to each kind of numbers.
19:14:58 <EvilRanter> hardly; numbers can generally be grouped into a bunch of concentric sets
19:15:24 <monomorph> For example kids take years to memorize the procedure for 2/3 + 4/5
19:15:27 <EvilRanter> with each set's (+) working consistently on its subsets
19:15:48 <LoganCapaldo> > [ (x, x*x) | x <- [1..10] ] -- It strikes me as really interesting how all the list comprehensiony things translate to non-list comprehensiony things but don't explode (in the number of syntactic elements) as much as you might expect
19:15:49 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
19:16:15 <EvilRanter> having memorised that, tho, that's only one rule, and it could be used for all subsets of the rationals if you so desired
19:16:23 <EvilRanter> also, kids are dumb :P
19:17:01 <monomorph> Yes, my point is that if you find monads hard you are dumb.
19:17:20 <sorear> > map (join(*) *** id) [1..10]
19:17:20 <lambdabot>   add an instance declaration for (Num (b, b'))
19:17:20 <lambdabot>     In an arithmetic sequence...
19:17:26 <sorear> > map (join(*) &&& id) [1..10]
19:17:28 <lambdabot>  [(1,1),(4,2),(9,3),(16,4),(25,5),(36,6),(49,7),(64,8),(81,9),(100,10)]
19:18:09 <sorear> LoganCapaldo: also, list comprehensions and do notation are essentially the same.
19:18:24 <EvilRanter> monomorph, that's a little elitist, surely?
19:18:27 <glguy> > map (second (join (*)) . join (,)) [1..10]
19:18:28 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
19:19:10 <monomorph> When EvilRanter says + works consistently over all variations, that reminds me of things like 0+x=0 that work consistently over all variations.
19:19:37 <glguy> 0+x=0?
19:19:41 <EvilRanter> I see what you mean, but i can see magnus--_ is getting at, too
19:19:43 <monomorph> oops, 0+x=x
19:19:44 <sorear> Monads, hard?
19:19:54 <magnus--_> map (\x -> (x,x*x)) [1..]
19:20:08 <sorear> I simply cannot imagine anyone failing to immediately comprehend monads.
19:20:22 <glguy> that means you aren't very imaginative ;)
19:20:30 <sorear> glguy: right.
19:20:35 <EvilRanter> I detect sarcasm!
19:20:52 <SamB> sorear: are you kidding? there is a whole paper about comprehending monads!
19:20:57 <Cale> I didn't immediately comprehend monads, but then the references back then were not quite as lucid as they are now.
19:21:15 <Cale> Heh, this is why we need monad comprehensions :)
19:21:16 <bd_> sorear: Alas, GHC cannot comprehend monads. Only lists :/
19:21:17 <monomorph> Anyway monads have a similar commonality too.  return x >>= k  =  k x.
19:21:18 <sorear> EvilRanter: not as much as you might think ... my people imagining skills are weak
19:22:31 <sorear> @remember bd_ sorear: Alas, GHC cannot comprehend monads. Only lists :/
19:22:31 <lambdabot> Done.
19:23:09 <Cale> Basically, monads are not a hard concept in and of themselves, but the programming techniques involving them do take quite a bit of effort to learn. It's not that bad though, if people manage to put the right words in front of you :)
19:23:10 <EvilRanter> i think understanding the rules of monads is fairly easy, but understanding the utility of the abstraction is a whole other matter
19:23:27 <Cale> EvilRanter: Right.
19:23:43 <EvilRanter> "er... why do i want lists to be like IO again?"
19:23:45 <Cale> There's almost nothing to monads on their own, which makes it hard to see why you want them.
19:23:45 <monomorph> Absolutely.
19:24:09 <SamB> or how to understand them
19:24:15 <SamB> there isn't much to understand
19:24:26 <SamB> its like trying to understand three twigs tied together!
19:24:32 <Lemmih> dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
19:24:38 <magnus--_> There is also no reason that the list monad should do the particular thing it does
19:24:48 <magnus--_> it could have any other meaning
19:24:56 <bd_> what could join be if not concat?
19:24:57 <magnus--_> it's all arbitrary overloading
19:24:58 <LoganCapaldo> Cale, try saying that in a spontaneous conversation with non-programmers. "What di you do today? I tried to create a Stack Monad. Whats a Monad? ..."
19:25:12 <LoganCapaldo> actually not non-programmers
19:25:21 <LoganCapaldo> just casualler programmers
19:25:26 <bd_> "It's a mapping over the category of..."
19:25:31 <SamB> non-;skellers
19:25:32 <sorear> @remember Lemmih dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
19:25:33 <monomorph> You see what magnus--_ is saying about monads is precisely what kids say about arithmetic.
19:25:33 <nornagon> >______>
19:25:33 <lambdabot> Done.
19:25:33 <SamB> er.
19:25:37 <SamB> non-'skellers
19:25:39 <nornagon> The scariest thing about monads is the name.
19:25:49 <sorear> @quote spj fuzzy
19:25:49 <lambdabot> No quotes match. That's something I cannot allow to happen.
19:26:04 <magnus--_> bd: I'll see if I have an answer
19:26:05 <LoganCapaldo> Well first I was like "Well a list is a kind of monad", "So a Monad is a list?" "No.... um"
19:26:10 <SamB> monomorph: and those kids are right, sort of
19:26:13 <Lemmih> dons: You've got mail.
19:26:16 <bd_> @djinn [[a]] -> [a]
19:26:17 <lambdabot> -- f cannot be realized.
19:26:19 <bd_> hm.
19:26:34 <nornagon> @djinn [a] -> [[a]]
19:26:35 <lambdabot> -- f cannot be realized.
19:26:35 <sorear> bd_: f _ = []
19:26:36 <LoganCapaldo> @type concat
19:26:38 <lambdabot> forall a. [[a]] -> [a]
19:26:50 <LoganCapaldo> stop lying djinn! ;)
19:26:50 <bd_> sorear: I suppose that satisfies the monad rules, but it's not very useful :)
19:26:57 <sorear> LoganCapaldo: concat is greater complexety than needed here
19:27:35 <monomorph> Well yes, all of our theories and abstractions are artificial.  But they are also useful.  You have to distinguish between "there is no point" and "I am not ready to see the point".
19:27:42 <EvilRanter> i guess it's a matter of perspective. we can all see why the arithmetic rules make sense, because we know a lot of the context
19:28:03 <monomorph> Yes absolutely.  You have the experience, then you see the point.
19:28:03 <EvilRanter> but people meeting monads for the first time will be thinking "why do i want to do this?"
19:28:20 <monomorph> Yes absolutely.  You have no experience, then you see no point.
19:28:45 <monomorph> Thus it's wise to say "I am dumb", but it's dumb to say "there is no point".
19:28:53 <EvilRanter> it's like the flash of insight when you saw why x^(-n) = 1/(x^n) is the only consistent interpretation of negative powers
19:29:24 <monomorph> Yes absolutely.  Piaget has described this in detail.
19:29:28 <sorear> I wonder what the curry howard interpretation of paraconsistant logic is?
19:29:29 <EvilRanter> it feels arbitrary 'til it all suddenly slots together
19:29:56 <bd_> The sheep did it for me. Nothing made sense until I saw how monads help with complex sheep manipulation.
19:30:36 <nornagon> please link me to this sheep manipluation paper.
19:30:56 <bd_> ?where all about monads
19:30:57 <lambdabot> I know nothing about all.
19:30:59 <monomorph> probably Cale's monad as container
19:31:04 <bd_> nono it was the nomaware one
19:31:29 <bd_> http://www.nomaware.com/monads/
19:31:41 <dylan> @where aam
19:31:42 <lambdabot> http://www.nomaware.com/monads/
19:32:24 <EvilRanter> broken
19:43:42 <Cale> Sometimes nomaware.com goes down
19:47:06 <dons> hmm. important resources like that we should put on haskell.org
19:47:10 <dons> centralise!
19:47:15 <dons> lower the barriers!
19:48:07 <sorear> @quote Lemmih test
19:48:08 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
19:48:32 <dons> hmm. :}
19:48:51 <nornagon> @quote what's your monad
19:48:51 <lambdabot> No quotes for this person. Take a stress pill and think things over.
19:48:54 <nornagon> sux
19:49:02 <nornagon> @poll-results cheeky-off
19:49:03 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=2, Yes=12
19:53:17 <SamB> @help poll
19:53:18 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
19:53:27 <SamB> @poll-show cheeky-off
19:53:28 <lambdabot> ["MakeItAbuseCowboyNeal","AddFlag","No","Yes"]
19:53:36 <SamB> @poll-list
19:53:37 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
19:53:57 <SamB> @poll-show jabberName
19:53:58 <lambdabot> ["Network.Protocol.Xmpp","Network.Xmpp"]
19:54:20 <SamB> @poll-show Written_a_compiler_or_interpreter?
19:54:21 <lambdabot> ["No","Yes"]
19:54:30 <SamB> @poll-result Written_a_compiler_or_interpreter?
19:54:31 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=3, Yes=12
19:55:00 <SamB> @vote Written_a_compiler_or_interpreter? yes
19:55:00 <lambdabot> "yes" is not currently a candidate in this poll
19:55:05 <SamB> @vote Written_a_compiler_or_interpreter? Yes
19:55:06 <lambdabot> voted on "Yes"
19:55:33 <dgriffi3> @vote Written_a_compiler_or_interpreter? no
19:55:34 <lambdabot> "no" is not currently a candidate in this poll
19:55:41 <bd_> dgriffi3: Why not? :)
19:55:41 <dgriffi3> @vote Written_a_compiler_or_interpreter? No
19:55:42 <lambdabot> voted on "No"
19:55:50 <dgriffi3> lame
19:55:56 <dgriffi3> err, I am rather
19:56:05 <bd_> it's not as hard as you might think
19:56:08 <bd_> well, the interpreter anyway
19:56:32 <bd_> if you target an easy language like scheme or something certainly :)
19:56:35 <mauke_> yeah, just write a brainfuck interpreter :-)
19:56:39 <bd_> heh
19:56:46 <NichardRixon> @vote Written_a_compiler_or_interpreter? Yes
19:56:47 <lambdabot> voted on "Yes"
19:56:58 <monomorph> I have written a toy compiler.
19:56:58 <Nafai>  @vote Written_a_compiler_or_interpreter? Yes
19:57:05 <bd_> or HQ9+ :)
19:57:07 <Nafai> Me too; for a class a long time ago
19:57:19 <monomorph> Oh haha!  I have also coded up the SECD machine!
19:57:29 <SamB> I've written a BD interpreter, translated an Unlmambda interpreter from C, and written a good part of a Z-machine interpreter ;-)
19:57:38 <SamB> er.
19:57:41 <SamB> s/BD/BF/
19:57:43 <nornagon> a bd_ interpreter?
19:57:49 <nornagon> i'd like one of those.
19:57:55 * monomorph emulates bd_
19:58:01 <Nafai> I've had a crazy inkling to write a compiler/interpreter
19:58:04 <bd_> <-- currently writing a compiler to a rather horrible game scripting language
19:58:14 <Nafai> But it's mainly for the sake of doing so, not for any real reason
19:58:21 <Nafai> bd_: What language?
19:58:22 <monomorph> Nafai do it for the lambda calculus! :)
19:58:34 <bd_> Nafai: I'm making it up as I go :p
19:58:38 <SamB> also I've started on, like, my third attempt to write a Self implementation
19:59:01 <bd_> Nafai: the source anyway, the target is 'CAOS', a horrible pseudo-assembler-ish scripting language for the Creatures series of games
19:59:05 <SamB> oh and I wrote a stupid BF compiler in Python a while back
19:59:12 <SamB> and then made it slightly less stupid
19:59:20 <sorear> I wrote an unlambda interpreter twice as fast as Jakob Mandleson's interpreter.
19:59:27 <SamB> (basically I did the "RLE" optimization)
19:59:42 <SamB> sorear: Jakob Mandleson is who?
19:59:47 <bd_> 100 numbered registers, subroutines (but you can't return from inside any sort of block!), a mixture of assembler-style modify-the-register expressions, and prefix expressions, etc
19:59:55 <Nafai> bd_: Interesting; I used to do game development for a living; used the Torque engine...TorqueScript can be a pain
19:59:59 <SamB> mine only went marginally faster than the C version :-(
20:00:12 <SamB> I think because mine didn't use libgc, but a real garbage collector ;-)
20:00:22 <bd_> Nafai: I'm planning on adding if-statements Real Soon Now ;)
20:00:24 <Cale> bd_: does it have conditionals?
20:00:26 <sorear> http://ofb.net/~jlm/
20:00:28 <lambdabot> Title: A modest home page
20:00:44 <bd_> Cale: yes, DOIF <condition> <block> [ELIF <condition> <block>] [ELSE <block>] ENDI
20:01:01 <Cale> So you can use that to get the same effect as jumping out of a block :)
20:01:09 <bd_> Cale: you can, but it'd be slow :)
20:01:24 <magnus--_> bd: It indeed seems that the standard list monad is the only useful one I can find, but that doesn't make it the only possible one
20:01:25 <bd_> Cale: you get five operations per tick, unless you lock the interpreter.
20:02:00 <bd_> also if an event arrives unless you have a different sort of lock, your script is brutally aborted without warning
20:02:01 <sorear> SamB: I wrote mine to reify my knowledge of generational GC.  that alone made the interpreter triple-uber-fast, faster than a massively tuned refcounting interpreter (mandelson's)
20:02:29 <monomorph> the Maybe monad is also very useful.
20:02:41 <EvilRanter> IO is vital
20:03:01 <monomorph> After a while you'll also appreciate state monads.
20:03:06 <bd_> Cale: oh, and there /is/ a GOTO command, but the docs warn you that if you ever, ever use it, things will immediately crash due to corrupted stacks of various sorts
20:03:13 <magnus--_> monomorph: I have used state monads.. they are clumsy
20:03:30 <SamB> oh, well, mine is just an untuned straight translation of the interpreter that comes with the unlambda distribution into Haskell, so I think it is kinda cool that it runs slightly faster than that one ;-)
20:03:35 <monomorph> But the real delight and enlightenment comes when you see that parsers are monads too.
20:03:47 <magnus--_> monomorph: I have used parsec. I like that
20:03:50 <Cale> magnus--_: using a state monad directly is clumsy, you don't usually do that
20:04:05 <Cale> You usually build your own monad out of a state monad
20:04:05 <magnus--_> Cale: so you need to write lots of boilerplate just to use state
20:04:19 <Cale> Well, depends on what's considered boilerplate
20:04:29 <Cale> State is often a starting point for implementing your own DSL.
20:04:47 <SamB> sorear: it was eerie how easily it translated to Haskell!
20:04:52 <Cale> and more commonly still, StateT over some other monad, like the list monad.
20:05:07 <monomorph> Once you find out that arrows are also cool, there is no return.
20:05:19 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
20:05:24 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
20:05:53 <Cale> that's related :)
20:05:59 <magnus--_> Cale: hehe, monad transformers scare me becuase monads are hard enough already
20:06:24 <Pseudonym> "Transformers" bring a new meaning to "robot ninja monkey".
20:06:29 <bd_> a nice exercise is writing a sudoku solver with List and StateT :)
20:07:17 <SamB> robots in disguise, you say?
20:07:50 <sjanssen> more than meets the eye?
20:07:51 <SamB> (meaning: arrows disguised as...?)
20:08:31 <AStorm> No, Functors disguised as Monads
20:08:47 <Cale> magnus--_: They're just a convenient way to build up the monad you want, rather than having to write an instance of Monad from scratch. It won't get you everything, but most of the obvious applications for monads arise as combinations of the transformers in the libraries.
20:08:52 <bd_> all monads are functors, so it's not much of a disguise :)
20:09:43 <SamB> I thought we had decided to use "robots" as a term for "arrows", like "monsters" are a term for "monads" ;-P
20:10:35 <magnus--_> Cale: That's what I've figured
20:11:23 <Cale> Using the transformers directly is really awkward though, so if you're planning on doing that, read my article :)
20:11:43 <blsecres> Does anyone know if http://www.reid-consulting-uk.ltd.uk/docs/ffi.html is available anywhere or any other FFI tutorial?
20:12:29 <Cale> blsecres: I'd start with the FFI spec, because it's very tutorial-like.
20:12:40 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:12:41 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
20:14:13 <blsecres> Cale: OK, I've been looking through it and it look good as a reference.  I just wasn't sure if it'd work as a HOWTO or tutorial type document.
20:14:45 <AStorm> There are no HOWTO's or tutorials to FFI
20:14:54 <AStorm> but it's simple enough already.
20:15:01 <AStorm> Just remember about IO
20:15:24 <blsecres> OK, there was one pointed to at the URL I posted but it appears to have disappeared
20:18:05 <magnus--_> Cale: I'm skimming your lights code, but I don't see how it is much shorter than say the equivalent C or java code
20:18:31 <Cale> magnus--_: You wouldn't do this in C or Java :)
20:18:44 <magnus--_> Cala: that is my point
20:18:51 <magnus--_> you would just do it straight-forwardly
20:18:55 <Cale> I don't actually have examples of using the code that's written there
20:19:00 <SamB> @quote CosmicRay
20:19:01 <lambdabot> shapr says: CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
20:19:21 <SamB> @quote CosmicRay
20:19:22 <lambdabot> shapr says: CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
20:19:33 <Cale> The point is that after constructing that monad, you have a language in which it's possible to describe control sequences for the traffic lights (and only that)
20:19:56 <SamB> ... control sequences?
20:20:11 <Cale> The important thing being that it's not possible for control sequences to the traffic lights to do things they're not intended to do, like file IO.
20:20:15 * SamB would have thought some kind of FS+time automaton would be more appropriate
20:20:49 <magnus--_> Cale: I think demonstrating monads using state is a losing battle because state is more convenient in stateful languages
20:20:59 <SamB> magnus--_: heh
20:21:05 <bd_> mhm, functional reactive programming for traffic lights?
20:21:09 <bd_> Time -> Color :)
20:22:33 <Cale> magnus--_: It's really hard to restrict the use of state in those languages though.
20:22:41 <magnus--_> Cale: that's true
20:23:11 <Cale> For example, suppose you want to ensure that some code which is a parameter to your function does no network IO. That's going to be pretty tough.
20:24:05 <magnus--_> Cale: I agree C and Java can't prove such a constraint
20:24:39 <SamB> at least java can prove that it was painfully constructed!
20:24:53 <magnus--_> samB: I am not saying that java is a great language
20:24:58 <SamB> because you need to pass some kind of object in a class...
20:25:12 <SamB> and that is a heck of a lot more painful than \x -> do somethingWith x
20:25:37 <sieni> yeah, monadic IO + STM is <3
20:26:18 <newsham> http://blogs.nubgames.com/code/?p=17
20:26:20 <lambdabot> Title: Nub Games » One Month with Haskell
20:26:37 <gravity> Very nice article
20:26:39 <sieni> after reading the STM paper by SPJ et al. I became convinced that monadic IO is a blessing, not a pain.
20:27:17 <dons> sieni: because its a very useful application that really needs to know there's no IO going on?
20:27:28 <sieni> dons: yes
20:27:38 <dons> (see also lambdabot's Eval plugin for another good use case fo paritioned-on-the-typelevel IO)
20:27:54 <sieni> concurrency in C and such just sucks (I know, I do _that_ for living)
20:27:56 <dons> > readFile "/etc/passwd" -- thnks Mr. TypeChecker
20:27:57 <lambdabot>  <IO [Char]>
20:28:10 <dons> mm. yeah, concurrency guys seem to get it
20:28:24 <dons> they know that side effects muck things up badly
20:29:21 <Cale> magnus--_: as far as state monads go, you'd never use anything but IO if you didn't care about being able to control what things won't do.
20:31:10 <magnus--_> Cale: I kinda like ocaml so I guess I'm in IO all the time
20:32:07 <glguy> hpaste is up to 27191 requests served
20:32:25 <magnus--_> Cale: still I see your point about proving things
20:33:49 <Cale> One of the major advances made by functional programming is the ability to section off which parts of code may have various types of effects.
20:34:16 <fons> is there a way to transform an unboxed value to boxed one?
20:34:24 <mgsloan> It's almost toobad there aren't less powerful versions of IO - eg, FileIO, etc
20:34:35 <dons> huh, the 'binary' serialisation benchmarks run roughly 100x slower between -O and -Onot
20:34:44 <dons> inliner++
20:34:52 <dons> fons, to box it with a constructor
20:34:55 <dons> e.g. I# i
20:35:01 <dons> turns an unboxed int, i, into an Int
20:35:13 <fons> thanks dons :)
20:35:24 <Cale> mgsloan: yeah. It's totally possible to write libraries which give you that.
20:37:13 <dons> mgsloan: newtype IO, hide the constructor, liftM readFile/writeFile
20:37:17 <dons> bang, you're done :)
20:37:20 <fons> Not in scope: data constructor `I#' :S
20:37:25 <mgsloan> haha
20:37:27 <mgsloan> nice
20:37:42 <dons> fons, its in GHC.Int
20:37:51 <fons> oh sorry
20:38:05 <fons> thanks
20:39:17 <mbishop> Wow, my idea really didn't go over well
20:40:05 <dons> mbishop: not enough code. maybe you should just go ahead and do it. reddit isn't a very tight community, after all
20:40:22 <dons> there's a few friendly ones, but they're all in here anyway ;)
20:40:44 <mbishop> probably, I might take littledan's advice and make it open, post the questions on a website or something and just ask that they send it back answered
20:40:51 <mbishop> that way anyone who wants to can fill it in
20:40:56 <mbishop> maybe put it on LtU
20:41:11 <nornagon> gr
20:41:18 <nornagon> can't compile stuff with GLUT
20:41:26 <nornagon> /usr/bin/ld: cannot find -lGL
20:41:39 <nornagon> there's a libGL.so.1 in my /usr/lib/
20:41:40 <dons> glguy: talk to metaperl ;)
20:41:57 <dons> glguy, so that he knows to release the xcode plugin
20:42:02 <glguy> dons: heh
20:42:10 <glguy> word travels in weird loops ;)
20:42:47 <dons> @seen metaperl
20:42:48 <lambdabot> I saw metaperl leaving #haskell 19h 48m 38s ago, and .
20:43:08 <fons> dons, there is no straight I# version, there are I32# I16# etc etc
20:43:19 <dons> there's also I#
20:43:26 <dons> ah, its in GHC.Base
20:43:42 <dons> note you're not making portable code once you do this.. I guess you know that
20:44:06 <ClaudiusMaximus> i'm attempting to model a stochastic process.  i'm not sure where to get random numbers from, any tips?  (newbie-oriented tutorial appreciated...)
20:44:08 <fons> dons,  I know, I'm making use of TH anyway so I have to stick to GHC
20:44:11 <fons> thanks dons
20:45:09 <TomMD> ClaudiusMaximus: it is my understanding that System.Random can give rngs good enough for modelling uses.
20:45:27 <fons> dons, same problem Module `GHC.Base' does not export `I#' . Where are the haddoc docs of GHC.* ?
20:45:52 <ClaudiusMaximus> @docs System.Random
20:45:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
20:46:12 <fons> @docs GHC.Base
20:46:12 <lambdabot> GHC.Base not available
20:46:44 <dons> its $ ghci
20:46:44 <dons> Prelude> :set -fglasgow-exts
20:46:44 <dons> Prelude> :m + GHC.Base
20:46:44 <dons> Prelude GHC.Base> I# 42#
20:46:44 <dons> 42
20:47:44 <nornagon> :t mapM_
20:47:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
20:48:10 <nornagon> @src mapM_
20:48:11 <lambdabot> mapM_ f as = sequence_ (map f as)
20:48:32 <nornagon> I don't quite get it.
20:49:48 <dons> it maps some actions over a list of values, then sequences the evaluation of the resuilting list of actions
20:50:00 <fons> dons, strange, it seems to be my GHC bug night ... I cannot do import GHC.Base (I#), import GHC.Base works just fine
20:50:11 <nornagon> mapM_ (\a -> mb) [1,2,3]  is like saying,  let f = (\a -> mb) in f 1 >> f 2 >> f 3 ?
20:50:13 * sorear declares understanding of yi+syn
20:54:02 <dons> import GHc.Base ((I#))
20:55:05 <robreim> dons: got a tic? with hs-plugins I'm now getting: Looking for <<Plugin.StaticIce_sourcePlugin_closure>> \n ["load: couldn't find symbol <<sourcePlugin>>"]
20:55:29 <robreim> However nm Plugin/StaticIce.o  | grep sourcePlugin  gives 00000078 D PluginziStaticIce_sourcePlugin_closure
20:55:58 <sorear> robreim: Lemmih is also hacking 6.6/hs-plugins, btw
20:56:08 <hyrax42> > [LT..]
20:56:08 <robreim> sorear: Yeah, I know
20:56:09 <lambdabot>  Parse error
20:56:18 <sorear> hyrax42:
20:56:22 <sorear> > [LT ..]
20:56:23 <lambdabot>  [LT,EQ,GT]
20:56:29 <hyrax42> oh d'oh
20:56:34 <hyrax42> surprised I didn't figure that out
20:56:41 <hyrax42> I was going to ask why it didn't work in hugs
20:56:57 <sorear> [LT..] parses as singleton list of (.) qualified by module LT
20:57:07 <hyrax42> yeah I realise now
21:04:57 <ClaudiusMaximus> @type foldr1
21:04:58 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
21:06:03 <ClaudiusMaximus> ?hoogle (a -> b) -> (a -> b -> b) -> [a] -> b
21:06:03 <lambdabot> No matches, try a more general search
21:06:44 <ClaudiusMaximus> ?hoogle (a -> b -> b) -> (a -> b) -> [a] -> b
21:06:45 <lambdabot> No matches, try a more general search
21:06:53 <dons> you want to map . foldr1?
21:07:08 <sorear> you want a specific zero-object case?
21:07:16 <dons> :t \f g xs -> map f . foldr g xs
21:07:18 <lambdabot> forall a b a1. (a -> b) -> (a1 -> [a] -> [a]) -> [a] -> [a1] -> [b]
21:07:31 <dons> :t \f g xs -> foldr g xs . map f
21:07:33 <lambdabot> forall b a b1. (a -> b1) -> (b1 -> b -> b) -> b -> [a] -> b
21:07:42 <dons> :t \f g xs -> foldr1 g xs . map f
21:07:43 <lambdabot> forall c a b. (a -> b) -> (([b] -> c) -> ([b] -> c) -> [b] -> c) -> [[b] -> c] -> [a] -> c
21:07:52 <sorear> argh, it seems I don't understand yi+syn after all.
21:07:52 <dons> :t \f g xs -> map f  . foldr1 g xs
21:07:54 <lambdabot> forall a b a1. (a -> b) -> ((a1 -> [a]) -> (a1 -> [a]) -> a1 -> [a]) -> [a1 -> [a]] -> a1 -> [b]
21:07:59 <nornagon> man
21:08:07 <nornagon> your types are getting longer and longer
21:08:19 <ClaudiusMaximus> i want a foldr1 with a function instead of an identity element
21:08:32 <sorear> ?
21:08:33 <ClaudiusMaximus> or seed element, whatever
21:09:01 <sorear> remember foldr is actually a generic free monoid morphism
21:09:08 <dons> foldr f id xs
21:09:21 <dons> id makes a good zeroth element
21:09:54 <dons> > foldr (.) id [(+2) , (+3), (*2)] $ 7
21:09:55 <lambdabot>  19
21:10:16 <dons> do *that* in a one liner in java ;)
21:10:45 <sorear> > foldr ($) 7 [(+2), (+3), (*2)]
21:10:46 <lambdabot>  19
21:11:02 <sorear> > mconcat [(+2), (+3), (*2)] 7
21:11:04 <lambdabot>  19
21:11:13 <emu> i could, just a really really really long one liner
21:11:18 <dons> heh
21:11:19 <sorear> do that in a 7-char in java!
21:11:54 <dons> public static something<somethingelse mconcat(...) { .... 1024 lines later ...; return v }
21:12:10 <SamB> dons: s/\n/ /!
21:12:19 <emu> p1024}
21:12:51 <ClaudiusMaximus> i want a 1st element, not a zeroth, guess i'll roll my own...
21:13:02 <dons> ClaudiusMaximus: more info!
21:13:10 <dons> I *don't* think you need to roll your own here
21:13:26 <dons> what input, what output please.
21:13:56 <emu> input: ?; output: 42
21:14:17 <bd_> :t mconcat
21:14:19 <lambdabot> forall a. (Monoid a) => [a] -> a
21:14:30 <bd_> interesting.
21:14:32 <sorear> @instances Monoid
21:14:33 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
21:14:36 <bd_> a -> a is a Monoid a?
21:14:38 <bd_> neat
21:14:44 <dons> yeah. super magic fun fun
21:14:51 <bd_> how is (a, b) a monoid?
21:15:04 <dons> ?src mconcat (,)
21:15:05 <lambdabot> Source not found. Wrong!  You cheating scum!
21:15:07 <sorear> bd_: lambdabot only shows instance heads, not contexts
21:15:11 <dons> ?src (,) mconcat
21:15:11 <lambdabot> Source not found. Take a stress pill and think things over.
21:15:15 <sorear> @src (,) mappend
21:15:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:15:21 <bd_> ah
21:15:28 <sorear> @src (a,b) mappend
21:15:28 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:15:32 <bd_> okay, :i Monoid makes it clear :)
21:15:35 <sorear> @src (a,b) mzero
21:15:35 <lambdabot> Source not found. stty: unknown mode: doofus
21:15:49 <newsham> return x*2+3+2; ?
21:15:50 <dons> actually, don't have any monoid instances in there
21:15:54 <newsham> doesnt seem that hard in java ;-)
21:15:58 <sorear> @set +insulting
21:15:58 <lambdabot>  Parse error
21:16:11 <dons> instance (Monoid a, Monoid b) => Monoid (a,b) where
21:16:12 <dons>     mempty = (mempty, mempty)
21:16:12 <dons>     (a1,b1) `mappend` (a2,b2) =
21:16:12 <dons>         (a1 `mappend` a2, b1 `mappend` b2)
21:16:22 <sorear> ah. direct sum
21:16:27 <emu> sorear: except foldr expects a list, not a set
21:16:32 <sorear> or is it direct product?
21:16:44 <sorear> emu: ?
21:17:06 <emu>  re: free monoid morphism
21:18:15 <ClaudiusMaximus> diffuse :: [[Bool]]->[[Bool]], modelling a diffusion process in a triangular segment of a hexagonal grid.  head input == [True] && last input == take ((length input) -1) (repeat False) ; the aim is to pick a random cell in (last input), and random walk towards the (head input) until the next move would be to a cell that contains True
21:19:18 <sorear> emu: list == free monoid
21:19:59 <ClaudiusMaximus> (i'm trying to make snowflakes)
21:20:01 <sorear> emu: foldr is a morphism from the free monoid over (a -> a) to the composition monoid
21:20:06 <SamB> sorear: what == expensive monoid
21:20:10 <SamB> ClaudiusMaximus: I could lone you some
21:20:24 <SamB> if I could get some individual flakes, anyway
21:20:32 <SamB> it looks like they are coming down in clumps
21:20:44 <sorear> they don't have snowflakes where I'm from
21:22:18 <SamB> I need sleep
21:22:31 <SamB> weather.com does not give me the impression that tomorrow is a snow day
21:22:53 <sorear> dons: does yi+syn handle string gaps?
21:22:55 <SamB> despite the alarming fall I just saw when I was taking some trash out
21:24:32 <base_16> SamB: where are you?
21:24:50 <SamB> in Upper Darby, PA
21:25:01 <dons> sorear: *no* idea
21:25:12 <SamB> wth is a string gap?
21:25:31 <notsmack> > "gaps"
21:25:32 <lambdabot>  "gaps"
21:25:36 <sorear> " la la la that is too\
21:25:43 <sorear>   \ long to fit on one line"
21:26:25 * glguy didn't know that was what those were called
21:26:31 <SamB> ... oh
21:26:34 <newsham> hmm, using Yi, hit "i" type some text, hit escape, :wq,  escape doesnt seem to switch out of edit mode
21:26:39 <SamB> it sounded a lot scarrier than that
21:26:42 <newsham> debug log shows it being translated to KEsc
21:26:54 <glguy> I just stumbled upon them in someone else's code
21:27:18 <sorear> newsham: how quickly are you typing? <50ms --> Meta-:
21:27:48 <sorear> (in vty, *doh*)
21:27:49 <newsham> slowly
21:27:54 <newsham> also this is gtk.
21:28:00 <SamB> heh
21:28:23 <newsham> gtk gets key "Escape" and gtk/Yi/UI.hs translates it to KEsc and sends it
21:28:27 <newsham> (and logs it to debug log)
21:29:11 <SamB> okay, yeah, like, the weather report doesn't look good, so, sleep...
21:29:26 <SamB> (by "doesn't look good" I mean "it doesn't look like it will snow too much"
21:32:09 <glguy> dons: ?
21:33:23 <nornagon> @index new
21:33:23 <lambdabot> Data.Graph.Inductive.NodeMap, Data.Graph.Inductive, Data.HashTable, Foreign.Marshal.Utils, Foreign.Marshal, Foreign
21:33:47 <nornagon> @index IORef
21:33:48 <lambdabot> Data.IORef
21:34:07 * glguy wonders if it is a bad idea to let people edit / delete their own pastes (within a certain time frame)
21:35:24 <SamB> probably yes
21:35:33 <notsmack> annotations seem to cover the reasonable use cases
21:35:44 <SamB> maybe mark them as "deprecated"
21:36:06 <sorear> glguy: make it wiki-ish - you can delete pastes, but anyone who's curious can look at the deleted pastes list
21:36:41 <notsmack> sorear: what does deleting a paste buy you?
21:36:49 <sorear> maybe with mandatory exponential backoff for edit wars :)
21:37:10 <glguy> I was trying to think of reasons that I needed to play with the
21:37:14 <glguy> SessionKeeper
21:37:36 <sorear> notsmack: be greatful you don't know.
21:37:39 <glguy> I figured that I could put a user's pastes in a set and tie to a session for that user
21:37:49 <glguy> fixing the authentication problem
21:37:57 <glguy> to a certain extent
21:38:44 <glguy> (the authentication problem specific to how do you decide who can delete something)
21:40:23 <nornagon> what about correcting typos and so forth
21:40:41 <glguy> did anyone notice that the paste titles light up when you link to a specific annotation?
21:40:57 <glguy> http://hpaste.org/168#1
21:41:04 <nornagon> yes
21:45:04 <notsmack> what does ":: (a -> b) -> f a -> f b" imply?  is that functors?
21:45:59 <glguy> nothing in particular :)
21:46:07 <notsmack> ah.
21:46:34 <notsmack> i still love that blog called "Date -> Maybe String"
21:51:30 <emu> blog :: Monad m => WriterT String m ()
21:55:02 * glguy sets out to find a new project to toy with ;)
21:59:19 <ClaudiusMaximus> @type foo where foo f g [z] = g z ; foo f g (x:y:zs) = f x (foo f g (y:zs))  -- this is the function i was thinking of, btw, some kind of mutated foldr1
21:59:20 <lambdabot> parse error on input `where'
21:59:34 <glguy> you need a let
21:59:37 <glguy> (first of all)
21:59:49 <glguy> let foo f g [z] = g z
22:00:05 <ClaudiusMaximus> @type let foo f g [z] = g z ; foo f g (x:y:zs) = f x (foo f g (y:zs)) in foo -- retry
22:00:06 <lambdabot> forall a t. (a -> t -> t) -> (a -> t) -> [a] -> t
22:00:41 <glguy> ClaudiusMaximus: you dont need the y:
22:01:21 <glguy> ClaudiusMaximus: if you are concerned about [], you need: foo _ _ [] = error "empty list"
22:01:38 <glguy> ?src foldr1
22:01:38 <lambdabot> foldr1 _ [x]    = x
22:01:39 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:01:39 <lambdabot> foldr1 _ []     = undefined
22:02:04 <dibblego> I've always wondered when to use undefined, error or Maybe
22:03:16 <ClaudiusMaximus> glguy: ah, i thought [x] and (x:xs) would be an overlapping pattern, wasn't sure what the behaviour of such patterns would be
22:03:32 <glguy> [x] is x:[]
22:03:49 <glguy> so it's different than x:xs
22:04:50 <ClaudiusMaximus> well, x:xs includes x:[], i guess i'm just paranoid ;)
22:05:11 <glguy> ClaudiusMaximus: you should express your function with foldr still
22:06:30 <glguy> ?type let claudius f g = foldr aux where aux x [] = g x; aux x xs = f x xs in claudius
22:06:32 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> (a -> [a1]) -> [a1] -> [a] -> [a1]
22:08:16 <ClaudiusMaximus> glguy: hmm, what does that gain me?
22:09:33 <glguy__> lousy fucking internet
22:09:36 <glguy__> ?type let claudius f g = foldr aux where aux x [] = g x; aux x xs = f x xs in claudius
22:09:38 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> (a -> [a1]) -> [a1] -> [a] -> [a1]
22:09:47 <ClaudiusMaximus> glguy: hmm, what does that gain me?
22:10:04 <glguy__> I have no idea, I don't know why you need the function you think you need
22:10:14 <ClaudiusMaximus> ?paste
22:10:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:10:34 <ClaudiusMaximus> let me test whether my code works, then i'll paste it...
22:16:14 <sorear> ClaudiusMaximus: the first matching pattern is used.
22:16:31 <sorear> > case 2 of 2 -> "foo" ; _ -> "bar"
22:16:32 <lambdabot>  "foo"
22:16:46 <sorear> > case "x" of (x:xs) -> "foo" ; [x] -> "bar"
22:16:47 <lambdabot>      Warning: Pattern match(es) are overlapped
22:16:47 <lambdabot>              In a case alterna...
22:17:09 <sorear> er, can we set -w in the bot :)
22:17:18 <sorear> > case "x" of [x] -> "foo" ; (x:xs) -> "bar"
22:17:19 <lambdabot>  "foo"
22:17:22 <sorear> > case "xy" of [x] -> "foo" ; (x:xs) -> "bar"
22:17:23 <glguy> sorear: that would be an "error"  thought
22:17:23 <lambdabot>  "bar"
22:17:26 <glguy> the second neveer hits
22:17:32 <sorear> > case "" of [x] -> "foo" ; (x:xs) -> "bar"
22:17:32 <glguy> though*
22:17:33 <lambdabot>   Non-exhaustive patterns in case
22:17:52 <hpaste>  ClaudiusMaximus pasted "barely tested snowflake generator (with mutant foldr1)" at http://hpaste.org/171
22:22:10 <glguy> ClaudiusMaximus: are you intentionally avoiding keeping the RandomGen in a state monad?
22:22:47 <sorear> ClaudiusMaximus: there *is* a function:
22:22:50 <sorear> @src or
22:22:50 <lambdabot> or    =  foldr (||) False
22:22:57 <ClaudiusMaximus> glguy: only because i'm n00b and scared of monads ;)
22:23:46 <araujo> hello!
22:24:03 <sorear> ClaudiusMaximus: take n (repeat x) = replicate n x
22:24:20 <sorear> glguy: how about porting DrHaskell to hpaste :)
22:24:37 <glguy> (take (length gs + 1) (repeat False)) is replicate (length gs + 1) False
22:25:02 <dons> ?users
22:25:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 278 (86.3%), active: 35 (12.6%)
22:26:52 <sorear> night all
22:28:48 <ClaudiusMaximus> thanks sorear
22:28:58 <ClaudiusMaximus> thanks glguy
22:29:03 <glguy> welcome
22:29:25 <glguy> ClaudiusMaximus:
22:29:41 <glguy> if you wait one moment longer, I will show you the monadic version
22:30:26 <ClaudiusMaximus> glguy: cool
22:30:33 <asoko> :t randomR
22:30:35 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:33:26 <glguy> ClaudiusMaximus: in a case like this, it takes a little extra work because of your custom fold
22:36:01 <hpaste>  glguy annotated "barely tested snowflake generator (with mutant foldr1)" with "first shot, not typed cheched" at http://hpaste.org/171#1
22:36:54 <glguy> folder f g (x:zs) = liftM2 f (folder f g zs) x -- this might actually be (folder f g zs) >>= flip f x
22:37:14 <glguy> in a right fold, the arguments of f are usually switched
22:37:17 <glguy> from what you have
22:37:44 <glguy> what algorithm are you implementing?
22:38:25 <ClaudiusMaximus> algorithm i thought up earlier tonight/this morning, dunno if it will generate aesthetic results yet...
22:38:47 <glguy> can you explain the idea of it easily?
22:41:07 <ClaudiusMaximus> it's modelling snowflake formation by aggregation of particles coming in from the outside edge of a 60degree sector of a hexagonal grid
22:42:52 <ClaudiusMaximus> i could draw diagrams, but the diagrams would take longer to draw than finish the code, i think...
22:47:13 <dons> glguy: what does the pretty pink box indicate?
22:47:39 <glguy> that your url has a #
22:47:53 <glguy> it shows you which paste you came to see
22:48:00 <dons> ah ok
22:48:09 <dons> cute
22:48:15 <glguy> and if you click other "link"s
22:48:20 <glguy> it changes
22:50:44 <glguy> > runIdentity ()
22:50:45 <lambdabot>  Couldn't match `Identity a' against `()'
22:50:49 <glguy> oops
22:51:06 <glguy> > runIdentity $return ()
22:51:07 <lambdabot>  ()
22:51:47 <glguy> > runIdentity $ return 1 `mplus` return 2 -- yes, i know
22:51:48 <lambdabot>   add an instance declaration for (MonadPlus Identity)
22:56:26 <ClaudiusMaximus> :t iterate
22:56:28 <lambdabot> forall a. (a -> a) -> a -> [a]
22:56:45 <glguy> :t until
22:56:46 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
23:03:31 <glguy> I want to mention on the new reddit thread about Monads in Ruby
23:04:03 <glguy> that monads are the perfect example of why ruby's type system isn't sufficient to safely do interesting programming
23:04:18 <glguy> (at the programm
23:05:03 <glguy> (at the level that monads operate at)... I can't imagine writing complicated monad transformer stacked code and having to do all the type checking in my head before hand
23:07:00 <ibid> hah
23:07:11 * ibid just got spam with subject "mzero"
23:07:52 <glguy> what's pathetic is that people are buying stuff from this spam, and making it profitable
23:10:00 <glguy> how is Ruby programming different that C programming with void*'s everywhere?
23:10:01 <jcreigh> yeah, but I'd be surprise if the response rate was great than one in, say, ten or twenty thousand.
23:10:20 <jcreigh> *surprised
23:10:55 <sjanssen> glguy: a ruby interpreter will crash reliably when the type error is encountered
23:11:28 <glguy> I thought that ruby had lists of handled messages, what are these types you speak of?
23:11:34 <sjanssen> whereas C might chug along, overwriting your stack
23:12:15 <jcreigh> glguy: well, yeah, but you can't do "2" + 2
23:12:38 <glguy> so the primitives have types?
23:13:00 <sjanssen> is "2" + 2 a static or dynamic error in Ruby?
23:13:06 <jcreigh> sjanssen: dynamic
23:13:18 <sjanssen> what about sqrt "elephant"?
23:13:41 <dons> its all dynamic isn't it? 'cept syntax errors?
23:13:46 <jcreigh> String#+ will refuse to implicitly coerce something to a string. (there's more to it than that...)
23:13:49 <glguy> since no two instances of any class are guaranteed to support the same methods, or support the same methods in the same way...
23:13:50 <dons> or is there a -Wall that does some static checks?
23:13:52 <jcreigh> dons: yeah.
23:13:59 <jcreigh> dons: "yeah", it's all dynamic
23:14:32 <dons> dynamic typing: because type systems are hard, and interpreters are easy
23:14:38 <jcreigh> heh
23:14:48 <jcreigh> pretty much
23:14:52 <glguy> dons: why should I figure out if the program is right? that's the programmers job
23:15:05 <sjanssen> I don't think I'll ever understand why people enjoy dynamic typing
23:15:21 <glguy> sjanssen: because they don't like being told they are wrong?
23:15:48 <dons> yeah. and they know they don't write code with bugs!
23:16:12 <dons> its the unit test guys you have to worry about though: the ones who know about the bugs, and to fix it try to approximate a type system
23:16:13 <glguy> all the programs I've written have crashed in exactly the ways I expected them to ;)
23:16:54 <glguy> dons: heh "sometimes I feel like all this test based type checking could be abstracted out somehow"
23:17:21 <sjanssen> glguy: that's a quote?
23:17:22 <dons> i'm going to write a tool for haskell, a super mega automated unit tester. it will validate *all* code paths, symbolically modelling classes of values that can be valid at any point. its really cool and will save you writing 100s, no, 1000s of unit tests!
23:17:27 <dons> its implementation:
23:17:34 <dons>  echo ':t ' | ghci
23:17:46 <nornagon> heh
23:18:10 <glguy> dons: but what if you want to change the return type of a function
23:18:16 <glguy> you'd have to actually find ALL occurances of it
23:18:22 <glguy> and change the code in all of those places
23:18:39 <dons> true true. much easier to not change the type, and just use unsafeCoerce#
23:18:47 <nornagon> conclusion: don't change return types >:)
23:18:49 <glguy> now... who the fuck is the compiler writer to say that I need to update my whole program??
23:19:09 <dons> yeah, it should just start running right?
23:19:21 <glguy> nornagon: no no, the dynamic camp says that the ability to change all your code and do experimental coding or whatever is a feature
23:19:33 <dons> i actually use this feature, explicitly chaning types to break my code, to help identify points in my code that need changing
23:19:44 <glguy> exploratory programming?
23:19:51 <glguy> I forget what lisp people call it
23:20:08 <glguy> where you don't know wtf you are doing so you just start programming, and worry about if it works once you've sold it
23:20:23 * dons hands glguy 'undefined'
23:20:46 <glguy> I use undefined to let ghci figure out complicated types for me
23:20:48 <dons> slip a few of those into your customer's code. it's agile as hell!
23:21:05 <glguy> when I'm thinking "wtf type argument would fit here??"
23:21:09 <dons> charge them each time 'Exception: undefined' occurs
23:21:18 <dons> since that's code they haven't paid for yet!
23:21:22 <glguy> heh
23:21:48 <glguy> let undefined = error "25 cents for the next additional 5 minutes"
23:22:36 <glguy> dons : http://programming.reddit.com/info/11kvs/comments
23:22:38 <glguy> :)
23:22:38 <lambdabot> Title: Monads in Ruby (reddit.com)
23:23:23 * sjanssen eagerly awaits the replies
23:24:02 <dons> yeah. its been pointed out elsewhere (the lisp monad guy) that you really need this stuff checked
23:24:52 <dons> does any non-haskell monad implementatoin get as far as monad transformers/
23:25:20 <dons> or just stick to Maybe, [] and State?
23:25:49 <glguy> dons: the people that realize that monad transformers exist and are useful aren't the ones writing about how to make Ruby's array type a monad
23:27:10 <dons> heh
23:27:37 <dons> so no ContT c (StateT [b] (IO a))
23:27:49 <glguy> they aren't the ones going, lets take this single abstraction over to my barren language and proclaim victory
23:27:51 <dons> (which we *actually used* for a real world program last week)
23:28:39 <hpaste>  ClaudiusMaximus annotated "barely tested snowflake generator (with mutant foldr1)" with "example 1/6 snowflake output" at http://hpaste.org/171#2
23:29:25 <kolmodin> ?remember dons I had a dream about how to write instance Binary Integer last night
23:29:25 <lambdabot> Done.
23:29:37 <kolmodin> :D
23:30:19 <dons> heh
23:30:49 <dons> i skipped breakfast at the pub that day to it on my bed and write down my dream. it typechecked!
23:30:55 <dons> s/sit on/
23:31:10 <kolmodin> then it must be ok
23:31:37 <dons> the scary dreams are the ones that typecheck, but aren't type correct at all! when the typechecker turns evil.... !!
23:34:12 <kolmodin> oooo!
23:35:18 <glguy> -rw-r--r-- 1 eric eric 103K Jan 29 00:57 checkpoint-0000000741
23:35:18 <glguy> -rw-r--r-- 1 eric eric 105K Jan 29 01:58 checkpoint-0000000742
23:35:30 <dons> cool. so we've hit 100k
23:35:36 <glguy> gzipped
23:35:39 <dons> the 1M mark should be fine.
23:35:46 <dons> I'm more interested in 10M
23:35:50 <dons> then we need to start thinking
23:36:20 <glguy> if a haskell application is doing a lazy read
23:36:22 <glguy> and I delete the file
23:36:24 <glguy> (in linux)
23:36:34 <glguy> does the fact that the application still has the file open
23:36:37 <dons> @tell dcoutts: random public complaint about gtk2hs on freebsd, http://programming.reddit.com/info/11iku/comments/c11lf9?context=5
23:36:38 <lambdabot> Consider it noted.
23:36:40 <glguy> prevent it from actually disappearing?
23:36:44 <notsmack> glguy: i'd think the you'd still have the handle and it wouldn't go away.
23:37:43 <glguy> then I need to set up a cron job to clean up the check point directory...
23:37:45 <ClaudiusMaximus> glguy: afaik it would disappear from a directory listing but continue to use disk space, until you close it, at which point the disk space would be marked free...
23:37:53 <glguy> ok, cool
23:38:03 <notsmack> glguy: it may get interesting if the laziness means it hasn't opened the file yet though
23:38:16 <glguy> that's nearly impossible
23:38:18 <glguy> in this case
23:38:20 <glguy> specifically
23:38:54 <glguy> because, I believe, that the file is only read on startup
23:38:56 <glguy> to rebuild the state
23:39:08 <glguy> the subsequent writes are only in preparation for a crash
23:39:25 <glguy> and the final write is in preparation for being shutdown
23:39:33 <notsmack> HAppS has no way to clean that stuff up?
23:39:44 <notsmack> (i haven't seen one, but it seems like an oversight)
23:39:44 <glguy> true
23:39:56 <glguy> I could write the "cron job" within HAppS
23:40:14 <glguy> (it has the everyNthSecond function for scheduling IO actions)
23:40:16 <notsmack> i'd think you could get more elegant :)
23:40:54 <notsmack> maybe hack the filewriter to delete un-necessary checkpoints as it writes new ones or something
23:41:31 <glguy> I do like having the old checkpoints
23:41:39 <glguy> for rolling back in the case of an "attack" or whatever
23:43:45 <ClaudiusMaximus> glguy: i use logrotate on one of my linux boxes, as far as i know it sends a signal to whichever daemons to tell them to reopen their log files (before this logrotate has renamed the old log, after this logrotate gzips the old log)
23:44:43 <glguy> it is fortunate that the saver only writes the state every hour
23:45:07 <glguy> it won't be so bad when it hits multiple megs to just do it every hour
23:50:08 <hpaste> What's new? <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
