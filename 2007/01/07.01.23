00:00:09 <glguy> what font should I use for the buttons?
00:00:15 <glguy> format and diff
00:00:46 <glguy> dons: do you think that the hr could be inproved
00:00:48 <glguy> improved
00:00:53 <glguy> we have a lot of stuff that all lines up
00:01:24 <glguy> my initial inclination was to make it 80% width
00:01:34 <dons> well, i like 100% :)
00:01:37 <glguy> do you think there is something like that that could help set it appart
00:01:50 * nmessenger notices that hpaste's type lacks the (Functor f) constraint, but he is suprised at how much prettier it's gotten.
00:02:13 <glguy> nmessenger: what can I say, nmessenger, I delegate well ;-p
00:02:18 <dons> glguy: set apart the header?
00:02:28 <glguy> the lines between each annotation
00:04:07 <glguy> I also need to fix the table headers
00:04:20 <glguy> authorwhen   and titlerevisions
00:04:58 <newsham> ok, sick of edit distance now.  gnite
00:05:03 <glguy> lol, night
00:05:16 <glguy> !lcs lisp.paste.org hpaste.org
00:05:17 <hpaste>  +h -l -i -s -p -. p a s t e . o r g
00:05:25 <glguy> haha!
00:05:44 <glguy> works on a pair of levels ;)
00:06:13 <newsham> i really like how scanl == foldl debugging utility
00:06:45 <newsham> if anyone writes a nifty IDE for haskell they should let you right click on foldls and dump the scanl table
00:07:12 <dons> good idea!
00:10:14 <Vq^> scanl table? isn't that dependent on the input?
00:10:54 <glguy> scanl always returns a list, just not necessarily of lists :)
00:11:56 <Vq^> yeah, but when used in a function for example, you don't know what it will return
00:12:07 * glguy tries to think of a mascot 
00:14:56 <dons> some funny little insect?
00:15:06 <dons> they're cute :)
00:15:42 <dons> a lady bug with lambds for dots
00:16:10 * dons attempts to create this
00:16:54 <glguy> I'm doing some wibbling of the CSS file now
00:17:16 <glguy> lots of unnecessary stuff in it
00:17:23 <dons> yeah
00:17:25 <glguy> redundant and whatnot
00:17:27 <dons> we need a css compression tool
00:19:46 <kolmodin> hah, Dominic sent me that ringtone from hac07.. hilarious :)
00:19:49 <glguy> what do you propose we do to the <th>s
00:19:59 <dons> kolmodin: heh
00:20:27 <kolmodin> message. message! message!!11 messaaaaaaggegegge!!!!! and so on.. :)
00:20:33 <hpaste>  Adam pasted "Test" at http://hpaste.ath.cx:8000/42
00:20:57 <dons> :)
00:21:16 <dons> glguy: the 'format' button is on a new line now?
00:21:29 <glguy> dons: on safari it doesn't line up
00:21:35 <glguy> otherwise...
00:21:36 <hpaste>   annotated "Test" with "" at http://hpaste.ath.cx:8000/42#1
00:22:10 <glguy> dons: how about I put it all on one line
00:22:16 <glguy> dons: but one line per form
00:22:36 <glguy> dons: centered list page
00:22:52 <glguy> dons: i think i should get rid of the 600px
00:22:56 <glguy> and make it match
00:22:59 <dons> yeah, perhaps
00:22:59 <glguy> the rest of the site
00:23:16 <glguy> like now
00:23:19 <dons> the input textarea should probably also be wider
00:23:24 <dons> it seems constrained to the fixed columns?
00:23:28 <dons> could it be a % of the page?
00:23:34 <glguy> one moment
00:23:45 <dons> you're doing all this in css I see? :)
00:23:51 <glguy> yeah
00:23:52 <dons> yay for separating content from markup
00:23:59 <glguy> hows that
00:24:08 <dons> hmm yes, the full width 'all' page is good
00:24:17 <glguy> dons: its good and bad, the site looks like shit a couple seconds a minute
00:24:34 <dons> glguy: hmm?
00:24:50 <glguy> when i make a bad change
00:24:54 <glguy> or when the file is saving
00:24:59 <glguy> users see it break
00:25:33 <dons> ah right
00:25:46 <glguy> dons: look at a paste with diff form
00:25:55 <dons> could the input textarea be "flat", i.e. not sunken?
00:26:07 <dons> a bit like the output box in http://lambdabot.codersbase.com/
00:26:09 <lambdabot> Title: Lambdabot Web Interface
00:26:18 <glguy> dons: now look
00:26:21 <glguy> in firefox
00:26:28 <glguy> (i don't know if this works otherwise)
00:26:52 <dons> oh, that looks good. the non-sunken input text area
00:26:52 <glguy> http://hpaste.ath.cx:8000/2
00:27:20 <dons> the footer isn't centred
00:27:31 <glguy> weird
00:27:32 <glguy> fixing
00:27:50 <dons> yeah, the buttons at the bottom of the diff page don't line up
00:28:03 <dons> but its better having the diff stuff all on one line
00:28:09 <glguy> footer centered
00:28:10 <dons> it flows better
00:28:38 <dons> why don't you go ahead and announce this then
00:28:46 <glguy> tonight?
00:28:53 <dons> say where it is, what its written in, and seek feedback
00:28:58 <glguy> ok
00:28:59 <dons> yeah, i can review the text if you like
00:29:12 <glguy> should I list all the contributors?
00:29:36 <dons> sure just say 'thanks' to all the people who provided patches or testing
00:30:19 <glguy> it's been about a week now, right?
00:30:27 <dons> mm. i'm inclined to link to hpaste of haskell.org's front page, once he hpaste.org url works
00:30:30 <dons> glguy: looks like
00:30:40 <dons> Thu Jan 18 15:34:21 EST 2007
00:30:44 <dons> to Jan 23
00:30:57 <csci> !paste
00:30:57 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
00:32:05 <dons> glguy: we'll have to chop the 'all' page to display say, the last 25 at some point...
00:32:08 <dons> :)
00:32:18 <glguy> dons: yeah, but it will never be more than 100
00:32:19 <nmessenger> glguy, how about <nick' = if all isSpace nick then "(unnamed)" else nick>?  (also for title)
00:32:24 <dons> and change it to be 'recent' instead of 'all'
00:32:35 <glguy> nmessenger: I've been meaning to :)
00:32:36 <dons> glguy: ah ok. its already limited then?
00:32:44 <glguy> dons: remember, it recycles
00:32:50 <dons> oh
00:32:51 <dons> hmm
00:32:57 <dons> so the links aren't permanent?
00:32:58 <glguy> at the moment
00:33:15 <dons> we should fix that. the links should be permanent.
00:33:24 <dons> i.e. write an Integer into the state
00:33:28 <glguy> I'll take a patch to PasteState.hs
00:33:31 <dons> and use that to set up the next seed
00:33:32 <dons> ok
00:33:50 <dons> dinner first
00:34:10 <hpaste>  csci pasted "Simple if-then-else formating question." at http://hpaste.ath.cx:8000/43
00:34:43 <nmessenger> csci: add a 'do' after the 'else'
00:35:25 <dons> glguy: 'annotate' should probably be a button on the bottom of the page., and should include the src that you wish to annotate.
00:35:34 <dons> i sought for the button at the bottom, after reading down
00:35:42 <abz> furthermore, type declarations are you friend
00:35:59 <glguy> dons: instead of the current annotate links?
00:36:47 <csci> nmessenger: unfortunatly I tried this, i.e. inserted a do between else and putStrLn , but that didnt word. I looked in the wikibook of YAHT, esp on indenting, but well, did not resolve my problem :-|
00:36:47 <dons> yeah, a button at the bottom was what my brain tried to find
00:36:49 <hpaste>  dons annotated "Simple if-then-else formating question." with "fix " at http://hpaste.ath.cx:8000/43#1
00:37:12 <dons> csci: how's that ^^
00:37:12 <Landrew> god damn C++'ers
00:37:17 <Landrew> I can't take it
00:37:33 <Landrew> bend me over and shove up the segment fault
00:37:36 <dons> glguy: could the textarea for annotate be populated with the original src?
00:37:44 <Landrew> could you be using a model ?
00:37:48 <Landrew> that involves ?
00:37:49 <Landrew> too much ?
00:37:51 <Landrew> mentation ?
00:37:53 <glguy> dons: have you clicked the annotate links next to each post?
00:37:53 <dons> > map (\x -> x ^ 2) [1..] -- have a lambda
00:37:55 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
00:37:56 <csci> dons: That's really nice :)
00:37:57 <Landrew> do you have the right tool
00:38:12 <nmessenger> csci: did you also indent 'linewise ...' to match to putStrLn?
00:38:16 <Landrew> MatLib can crank that out in a heartbeat
00:38:24 <dons> Landrew: this is a haskell channell...
00:38:36 <csci> nmessenger: yes, like in the snippet (copy&pasted it)
00:38:43 <dons> Landrew, please try not to rant :)
00:38:43 <glguy> ?where hpaste
00:38:44 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
00:39:00 <csci> nmessenger: this is why i'm so irritated!
00:39:03 <nmessenger> csci: you need to add the 'do' too.
00:39:38 <hpaste>  csci annotated "Simple if-then-else formating question." with "added do does not work, too" at http://hpaste.ath.cx:8000/43#2
00:39:38 <hpaste>   annotated "Simple if-then-else formating question." with "" at http://hpaste.ath.cx:8000/43#3
00:39:44 <dons> glguy: oh, i see what you mean.
00:39:58 <dons> once you've got multiple boxes, the annotate shouldn't be at the bottom
00:40:05 <dons> ah, and it does populate!
00:40:09 <dons> hmm, why didn't it do that before?
00:40:11 <csci> nmessenger: I think (;-) I did it right, or?
00:40:21 <nmessenger> csci: did you get a parse error?
00:40:28 <dons> oh, i clicked on the 'big' annotate button at the top
00:40:42 <hpaste>  Saizan annotated "Simple if-then-else formating question." with "more fix" at http://hpaste.ath.cx:8000/43#4
00:40:44 <dons> glguy: does the top level 'annotate' have a purpose? isn't it just 'new' ?
00:40:58 <glguy> dons: new goes to a new thread
00:41:07 <hpaste>  csci annotated "Simple if-then-else formating question." with "error from ghc" at http://hpaste.ath.cx:8000/43#5
00:41:21 <csci> nmessenger: just pasted it
00:41:32 <dons> Saizan: your version has an indenting problem.. ?
00:41:48 <csci> Even though dons solution is better I'd like to understand the correct syntax :)
00:42:46 <Saizan> dons: mmh, adding spaces in a textarea field seems not so straightforward..
00:42:53 <nmessenger> csci: that's a type error, 'print' in one case has type 'IO ()', but 'return []' has type 'IO [a]'
00:43:47 <hpaste>  csci annotated "Simple if-then-else formating question." with "Why don't I get an error here?" at http://hpaste.ath.cx:8000/43#6
00:44:00 <csci> oh I see
00:44:05 <csci> now it's clear
00:44:11 <csci> Thanks, nmessenger :) (and dons!)
00:44:54 <nmessenger> csci: Make sure to read those error messages! I was scared at first, too, but they don't bite ;-)
00:44:58 <csci> Haskells (ghci's) error messages are sometimes quite difficult to understand ;-)
00:45:50 <dons> Saizan: yeah, you need vim to open up :)
00:46:06 <Saizan> http://hpaste.ath.cx:8000/43#6 -- mmh i'm a bit confused here, is that parsed as do { (if .. then .. else ..); linewise (xs);} ?
00:47:09 <nmessenger> Saizan, methinks it is invalid, but was meant to be do {if..then..else do {..; linewise (xs)} }
00:47:17 <hpaste>  dons annotated "Simple if-then-else formating question." with "do / not / do" at http://hpaste.ath.cx:8000/43#7
00:47:37 <nmessenger> what dons said :P
00:48:22 <Saizan> we need a syntax validator in hpaste :D
00:48:44 <nmessenger> Ooh!  And a literate code colorer!
00:48:46 <dons> oh !
00:48:56 <dons> hmm
00:49:16 <nmessenger> does the used colorer library support literate code?
00:49:46 <dons> doubt it..
00:49:51 <dons> hang on.
00:49:53 <dons> yeah, it would
00:51:02 <hpaste>  dons pasted "test .lhs" at http://hpaste.ath.cx:8000/44
00:51:26 <Saizan> mmh i checked, it's not invalid, and is parsed as i tought
00:52:45 * glguy clicks send
00:52:48 <nmessenger> Saizan, aye, 'twould need either a coloring mode picker or some kind of auto-detect algorithm
00:53:37 <Saizan> do you have something against having all the line link to the paste in the list page?
00:54:00 <dons> no, that would be more sensible
00:54:07 <dons> darcs send!
00:54:10 <dons> (look for 'view' in the src)
00:55:00 <dons> ?where mailing-list
00:55:01 <lambdabot> I know nothing about mailing-list.
00:55:04 <nmessenger> that could be confusing if both the title and nick are left out of a paste
00:55:26 <dons> ?where mailing-lists
00:55:27 <lambdabot> I know nothing about mailing-lists.
00:55:32 <dons> ?where mailinglist
00:55:32 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
00:56:10 <nmessenger> @where-add-alias ?
00:56:10 <lambdabot> Unknown command, try @list
01:07:34 <Saizan> ?docs Text.XHtml
01:07:35 <lambdabot> Text.XHtml not available
01:08:16 <Saizan> ?where xhtml
01:08:17 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
01:09:43 <dons> ?users
01:09:43 <lambdabot> Maximum users seen in #haskell: 321, currently: 290 (90.3%), active: 28 (9.7%)
01:09:55 <njd> ?list
01:09:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:09:58 <glguy> dons: you sent that patch?
01:10:16 <dons> almost ..
01:10:49 <dons> yes.
01:12:11 <glguy> !id alive
01:12:12 <hpaste> alive
01:12:31 <glguy> !lcs lisp.paste.org hpaste.org
01:12:31 <hpaste>  +h -l -i -s -p -. p a s t e . o r g
01:12:35 <glguy> woot ;)
01:12:44 <dons> heh
01:13:04 <dons> is that with the Integer patch?
01:13:06 <njd8> hoogle+ registerDelay
01:13:14 <glguy> dons: your patch is in
01:13:20 <njd8> ?hoogle+ registerDelay
01:13:20 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
01:13:34 <njd8> ?where registerDelay
01:13:35 <lambdabot> I know nothing about registerdelay.
01:13:54 <dons> njd8: ?
01:13:56 <abz> ?where Arrow
01:13:57 <lambdabot> I know nothing about arrow.
01:14:02 <dons> threadDelay?
01:14:08 <dons> ?docs Control.Arrow
01:14:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
01:15:15 <abz> wrt lambdabot, thats pretty cool.
01:15:16 <glguy> oh yuck
01:15:21 <glguy> by using record syntax
01:15:28 <glguy> each record label is used in the show
01:15:33 <glguy> and is saved for each instance
01:15:51 <dons> glguy: yeah, :)
01:15:59 <dons> we don't care yet, i guess
01:16:05 <dons> but binary would be the better way to go
01:16:13 <dons> i wonder if we can register binary serialisers with happs
01:16:17 <glguy> I might need help from you with that one
01:16:22 <glguy> and musabi
01:16:25 <dons> yeah, i coudl write the instance pretty quickly
01:16:32 <dons> since the state type is standard
01:18:57 <glguy> the state is up to 51K
01:19:06 <glguy> when "show"n
01:19:52 <glguy> dons: I think that changing serialization methods *could* be as easy as loading with an old reader and new writer
01:19:57 <glguy> (guessing)
01:20:23 <glguy> but I have to work tomorrow, goodnight all!
01:20:34 <dons> ok night
01:20:38 <dons> patch for anonymous users almsot ready..
01:20:42 <glguy> oh
01:20:47 <glguy> ok, waiting
01:21:13 <glguy> unless you didnt mean that
01:21:15 <dons> just recording now
01:21:32 <dons> e.g view(anonymous)4s(no title)0
01:21:49 <bos> glguy: the hpaste.org registration went through
01:21:50 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
01:22:00 <dons> sending...
01:22:02 <glguy> we saw the whois
01:22:04 <glguy> :)
01:22:22 <glguy> thats sweet, shapr is set up to redirect it
01:22:33 <bos> redirect to where?
01:22:40 <luqui> is there any way to define an operator (|||) like (||) such that, say: (length [0..] == 42 ||| True) == True, (True ||| length [0..] == 42) == True
01:22:44 <glguy> hpaste.org to :8000
01:23:31 <glguy> since happs need a different port since apace is running
01:23:49 <bos> btw, i changed the domain registrant to "Succ (Succ (Succ Zero))"
01:23:52 <luqui> and no, _ ||| _ = True doesn't count :-)
01:24:11 <dons> gl	sent
01:24:18 <dons> glguy:
01:24:22 <glguy> heh
01:24:23 <nmessenger> whois hpaste.org: 'Admin Organization:Succ (Succ (Succ Zero))' :D
01:24:32 <dons> heh
01:24:48 <glguy> dons only chanegs main list?
01:24:51 <nmessenger> 3?
01:24:55 <glguy> not view?
01:25:00 <glguy> of each?
01:25:12 <dons> oh hmm. i might have missed some
01:25:18 <dons> i thought i just got the creation of 'new' entries
01:25:25 <glguy> OHHH
01:25:26 <glguy> ok
01:25:29 <Masklinn> Good morning #haskell
01:25:46 <dons> not reinterpreting empty ones (maybe that's better?)
01:26:07 <glguy> dons: easier to chane message then
01:26:24 <bos> glguy: do you want email at hpaste.org, or should i bin it?
01:26:42 <glguy> bin prolly
01:27:35 <bos> glguy: what continent are you on?
01:27:42 <glguy> NA
01:27:57 <glguy> MO,usa
01:28:06 <bos> ok, because shapr seems to be in europe somewhere, and the ip address he gave me for redirecting is 100+ ms away
01:28:13 <Korollary> Montana baby
01:28:16 <glguy> atlanta
01:28:22 <bos> that's going to give crappy latency
01:28:28 * nmessenger thought NA stood for not applicable 8)
01:28:32 <dons> bos, did you look at http://hpaste.ath.cx:8000/ :)
01:28:35 <dons> much prettier now
01:28:44 <dons> leaves lisppaste in the dut
01:28:47 <bos> ooh, yum!
01:28:48 <dons> dust
01:29:12 <Shammah> much easier simply to live in a country that is a continent. :)
01:29:25 <Korollary> despite what the brazilians say?
01:29:38 <Korollary> you probably meant australia though
01:30:32 <Korollary> I bet there's somebody out there who questions whether europe is a continent
01:31:31 <luqui> of all you gurus, nobody can answer my question?  (if the answer is no, I require proof! :-)
01:32:54 <glguy> !lcd good.night for.real.this.time
01:33:07 <brainly-green> the minute haskell has lisp-like macros I'm using it and not lisp
01:33:08 <glguy> !lcs good.night for.real.this.time
01:33:09 <hpaste>  +f -g -o o +r +. +r +e +a +l -d . +t +h -n i +s +. -g -h t +i +m +e
01:33:19 <nornagon> ?src foldl
01:33:20 <lambdabot> foldl f z xs = lgo z xs
01:33:21 <lambdabot>     where lgo z []     =  z
01:33:21 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
01:33:22 <Saizan> luqui: you could spawn two threads and see if one of them returns
01:33:34 <nornagon> ?src foldl1
01:33:35 <lambdabot> foldl1 f (x:xs) = foldl f x xs
01:33:36 <lambdabot> foldl1 _ []     = undefined
01:33:50 <Saizan> luqui: or have a non deterministic turing machine :)
01:34:22 <luqui> ahh, but that is in IO monad...  but I do see your turing machine point :-)
01:34:37 <roconnor> luqui: There isn't a way without invoking concurency or something like that.
01:34:59 * luqui was thinking something akin to par...
01:35:28 <luqui> but that would *require* par to be parallel, rather than just suggest it
01:35:53 <luqui> okay, i think I'm vaguely convinced
01:36:39 * Cale wonders what people want lisp-like macros for in Haskell.
01:36:49 <Korollary> what people or why people?
01:36:57 <Korollary> I can't read
01:37:22 <roconnor> I wonder if there is a continutity argument that can be made.  hmm, maybe not.
01:37:37 <luqui> what is continuity?
01:37:46 <hpaste>  nmessenger pasted "luqui :P" at http://hpaste.ath.cx:8000/45
01:37:52 <Korollary> Well, people who ask for lisp macros are those who have used lisp macros.
01:38:23 <Korollary> it's a knee jerk thing.
01:38:26 <Cale> Most of the things that I see macros used for in lisp are doable as ordinary functions in Haskell due to lazy evaluation.
01:38:40 <Korollary> I wouldn't know if "most" is right.
01:38:47 <bos> could people let me know if this works for them? nslookup hpaste.org sanpietro.red-bean.com
01:38:57 <Cale> In some sense, all of them are. :)
01:39:31 <Korollary> You have to write something like Norvig's patterns in lisp.
01:39:43 <dons> anyone got any comments on the new hpaste? :)http://hpaste.ath.cx:8000/45
01:39:47 <dons> do we win yet?
01:39:49 <Korollary> Find out what people use macros in lisp for, and why it's not necessary.
01:39:56 <luqui> nmessenger, thank you, very useful :-)   (indeed, it may be true that this implementation does exactly what I want.  Once it returns I will tell you)
01:40:01 <nmessenger> dons: 'tis awesome!
01:40:04 <bos> dons: it's sweet!
01:40:23 * Cale tries to decide why hpaste has that type.
01:41:05 <dons> its pretty :) but yeah, paste transformer over the paste container
01:41:14 <nmessenger> Cale, it's a functor (or would be with Functor f =>) that holds code
01:41:26 <Korollary> It looks as if when you paste a function, hpaste produces another
01:41:29 <Korollary> function
01:41:30 <Cale> can we pass it a function?
01:41:48 * nmessenger ponders this
01:42:10 <Cale> Basically, hpaste could only be fmap :)
01:42:22 <dons> :)
01:42:24 <luqui> btw, hpaste is very slick
01:42:37 <dons> yeah, i think this is a great use case fo happs
01:42:43 <Cale> That is quite sweet.
01:42:47 <dons> i actually will use happs now for all my new stuff
01:42:59 <int-e> bos: works.
01:43:07 <bos> ok, i've updated the dns records for hpaste.org. once the root servers get the new addresses, you should be able to go to hpaste.org or www.hpaste.org
01:43:12 <luqui> is there source?
01:43:36 <nmessenger> luqui, go to the 'all' link, then 'darcs'
01:43:42 <Saizan> http://saizan.no-ip.org:8000/ <-- table rows that link to the paste, some idea on how to make this evident?
01:43:53 <nmessenger> http://www.scannedinavian.com/~eric/hpaste/
01:43:56 <luqui> ahh, there we go
01:43:58 <Korollary> I'm getting a 68.178.232.100 for hpaste.org
01:44:18 <apfelmus> dons: it's great. but i'm not sure whether i like the syntax colors. they're a bit icy cold
01:44:32 <dons> heh
01:44:49 * nmessenger still likes haskell.org's color scheme
01:44:53 <dons> its 42 degrees here yesterday! i need to cool down
01:44:55 <bos> Korollary: yes, you'll have to wait for the root dns servers to get updated.
01:45:19 <Excedrin> the format, diff, whatever buttons are ugly
01:45:37 <apfelmus> dons: on the northern hemisphere, things are exactly inverse :)
01:45:52 <Saizan> we could have multiple css-es :D
01:46:04 <Korollary> the page should render according to ip address
01:46:06 <roconnor> LCF considered as a programming language, Plotkin 1977
01:46:22 <hpaste>  nmessenger annotated "luqui :P" with "changed to fit spec" at http://hpaste.ath.cx:8000/45#1
01:46:38 <nmessenger> aw, luqui quit :(
01:46:57 <dons> Excedrin: yeah, patches needed
01:47:29 <dons> Excedrin: even a mock up of what it should look like would be welcome..
01:48:00 <int-e> bos: www.hpaste.org won't work, scannedinavian.com doesn't redirect that. hpaste.org works.
01:48:39 <int-e> bos: well, as soon as the root name servers pick up the change of course as you already said
01:48:53 <dons> int-e, hpaste.org is working now for you?
01:49:03 <int-e> dons: no, playing with http Host headers :)
01:49:09 <dons> heh ok
01:50:47 <dcoutts> nice new look to the hpaste guys
01:50:47 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
01:51:44 <dcoutts> hmm, some really old messages there, 20 days?
01:53:08 <dcoutts> dons, some old state files?
01:53:16 <dons> yeah maybe
01:53:54 <dcoutts> dons, so you said something about the abi issue we discussed, you've seen it in the wild again?
01:55:33 <dons> yeah a couple of times today
01:55:43 <dons> when rebuilding partially, after a complete binary rebuild
01:55:49 <dons> rebuilding lambdabot partialy
01:56:05 <dons> in one case a 'inconsistent .hi file'
01:56:17 <dons> and in another , a panic .. though i have to look into that more
01:56:50 <dons> that was between binary from a week ago, and today
01:56:54 <dons> so the internals had changed a lot
01:56:59 <dons> but the api was the ame
01:58:36 <dcoutts> mm
01:58:53 <dcoutts> dons, but only between packages right?
01:58:54 <Saizan> is there a more direct way to send a patch, rather then mail it?
01:59:02 <Saizan> (with darcs)
01:59:11 <dcoutts> Saizan, if you have ssh access to the server then you can darcs push
01:59:43 <dcoutts> and it's possible to set up a system to make signed darcs send auto apply on the server side
01:59:52 <tuukkah> hello dcoutts! do you have an idea what it would take for us to get profiling versions of the gtk2hs modules?
02:00:23 <dcoutts> tuukkah, yeah, it needs some hacking with the Gtk2Hs build system
02:00:58 <dons> dcoutts: yeah, lambdabot breaking on and old and new binary
02:01:12 <dcoutts> tuukkah, if you can spare any hacking time we could look into it for the upcoming release
02:01:19 <dcoutts> dons, right
02:01:48 <tuukkah> dcoutts, excuse my english, what do you mean?
02:02:59 <dcoutts> tuukkah, well I mean it's not currently easy to do, it needs someone to look at the issue. It'll need work in the makefiles for Gtk2Hs. If you have some time to help we can have a go.
02:03:30 <tuukkah> we're using the darcs version and could try to help because it's somewhat important for us :-)
02:03:39 <dcoutts> tuukkah, there is going to be a new Gtk2Hs release soon, so if you want that issue fixed, now is the time to get it done.
02:03:57 <dcoutts> tuukkah, ok, great.
02:04:05 <kolmodin> 'soon' means anything from next week to next year
02:04:13 <kolmodin> :)
02:04:17 <tuukkah> %-)
02:05:21 <dcoutts> kolmodin, oi!
02:05:22 <dcoutts> ;-)
02:05:42 <tuukkah> dcoutts, Makefile.am is created manually, so that would be the file to hack, right?
02:05:44 <dcoutts> kolmodin, I've actually got a windows installer ready and am about to announce RC1
02:05:44 <kolmodin> oi?
02:05:57 <kolmodin> oh, french
02:06:00 <Saizan> dcoutts: btw, after cleaning my %Path% a bit helloworld.exe now finds its .dlls, but not it complains about some symbol missing in iconv.dll, even if i've deleted an old version of it that i had in %Path%
02:06:00 <kolmodin> "oui"
02:06:08 <dcoutts> kolmodin, erm "oi!" == "hey!" I guess
02:06:21 <kolmodin> ah :) thought you used some phrases you picked up in Nice
02:06:26 <dcoutts> hah
02:06:31 <kolmodin> like "yes"
02:06:51 <dcoutts> Saizan, do you have an iconv.dll in your windows or system dir ?
02:07:07 <kolmodin> "oi" doesn't look like a "strong word" you say on top of your lungs, like "hey!"
02:07:18 <dcoutts> kolmodin, well, it is :-)
02:07:33 <kolmodin> we say more "ey"
02:08:07 <dcoutts> Saizan, I realised the original issue was that while the installer did update the PATH, it didn't tell explorer to re-read the PATH var from the registry, so explorer didn't use the new PATH
02:08:11 <nornagon> @instances Num
02:08:12 <lambdabot> Double, Float, Int, Integer
02:08:17 <nornagon> @instances Fractional
02:08:18 <lambdabot> Double, Float
02:08:46 <kolmodin> dcoutts: the @unmtl seems to work (somewhat), but the parsing and prettyprinting needs fixing, it's done in the most hackish way
02:09:05 <dcoutts> kolmodin, oh cool! is it live? can I try it?
02:09:17 <dcoutts> @unmtl State Int
02:09:17 <lambdabot> State Int
02:09:25 <kolmodin> so: 1) fix parsing 2) fix pretty printing 3) make it an actual lamdabot plugin
02:09:29 <kolmodin> oh?
02:09:40 <dcoutts> @unmtl foo bar
02:09:41 <lambdabot> foo bar
02:09:41 <kolmodin> it's not live, at least not my code
02:09:44 <dcoutts> ?
02:09:46 <dcoutts> ok
02:09:56 <kolmodin> which command responds to ?unmtl?
02:10:01 <kolmodin> ?help unmtl
02:10:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:10:07 <kolmodin> pew
02:10:11 <dcoutts> heh
02:10:16 <kolmodin> don't want to duplicate someones code
02:11:08 <kolmodin> I'll continue on that tonight
02:11:22 <kolmodin> now: back to paid hacking (not haskell though)
02:11:24 <kolmodin> ttyl
02:12:48 <int-e> @unmtl ap id
02:12:49 <lambdabot> (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
02:12:49 <Saizan> dcoutts: found a iconv.dll in ruby\bin.. mmh i should find a better way to call my commands from the prompt rather than dump every \bin directory in %path%
02:12:52 <int-e> @unpl ap id
02:12:52 <lambdabot> (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
02:13:26 <dcoutts> Saizan, so did that dir appear on the path before the path that the Gtk2Hs installer set ? I thought that I prepended it to the path, hmm.
02:13:52 <Saizan> it's prepended to the user-specific path
02:14:06 <dcoutts> Saizan, I prepended it to the user's path rather than the global path. Perhaps I should try to modify the global path and if that fails then do the user's path.
02:14:11 <Saizan> but not to the machine/global path
02:14:15 <dcoutts> right
02:14:39 <dcoutts> Saizan, the danger of course is in breaking other stuff, like ruby
02:14:48 <Saizan> heh
02:14:56 <dcoutts> but that's ok ;-)
02:14:59 <Saizan> :P
02:15:49 <Saizan> mmh i'm quite clueless about .dlls isn't there some sort of namespacing?
02:23:28 <nornagon> what's the minimal definition for Enum? The docs don't say.
02:24:10 <dcoutts> Saizan, there was something introduced in WinXP, but it's a bit hard to use. We'd have to extend ghc to include manifests in the .exes it builds.
02:25:07 <dcoutts> Saizan, windows is really designed for deploying apps, not for library components
02:25:16 <apfelmus> nornagon: usually, you say "deriving (Enum)"
02:25:22 <nornagon> apfelmus: can't
02:25:32 <apfelmus> ?src Enum
02:25:32 <lambdabot> class  Enum a   where
02:25:33 <lambdabot>     succ                     :: a -> a
02:25:33 <lambdabot>     pred                     :: a -> a
02:25:33 <lambdabot>     toEnum                   :: Int -> a
02:25:33 <lambdabot>     fromEnum                 :: a -> Int
02:25:34 <lambdabot> [3 @more lines]
02:25:40 <apfelmus> @more
02:25:41 <lambdabot>     enumFrom                 :: a -> [a]
02:25:41 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
02:25:41 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
02:26:18 <apfelmus> most likely, toEnum and fromEnum should be enough
02:26:25 <nornagon> okay.
02:27:08 <apfelmus> what do you need as instance? sometimes, Ix suffices, too
02:27:51 <nornagon> It's on my way to instance Integral
02:27:54 <nornagon> so i can get div
02:28:23 <apfelmus> mh? you need Enum for an instance of Integral?
02:28:29 <nornagon> apparently.
02:28:33 <nornagon> @src Integral
02:28:34 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:28:34 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:28:34 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:28:34 <lambdabot>     toInteger           :: a -> Integer
02:28:58 <roconnor> @type fromIntegral
02:28:59 <lambdabot> forall b a. (Num b, Integral a) => a -> b
02:29:39 <apfelmus> uh, then the types toEnum :: Int -> a and fromEnum :: a -> Int really hurt. should be Integer, at least
02:30:32 <nornagon> yeah :(
02:31:03 <apfelmus> looks like those classes are only intended for Integer-like things, no fancy polynomial divison and so on
02:31:35 <nornagon> what do a guy gotta do to get an integer division?!
02:32:05 <Korollary> use floor?
02:32:11 <apfelmus> what is the type in question?
02:32:25 <dons> http://www.randomhacks.net/articles/2007/01/22/high-performance-haskell
02:32:27 <lambdabot> Title: High-Performance Haskell, http://tinyurl.com/ywg98e
02:32:49 <nornagon> Korollary: i want mod, quot and rem too
02:33:01 <nornagon> apfelmus: some scary union thingy
02:33:36 <nornagon> data Scheme = ScmFloat Double | ScmInteger Integer | ScmComplex (Complex Double) | ScmRational Rational | ScmSymbol String | ...
02:33:36 <apfelmus> suspicious. more details?
02:33:58 <Korollary> numerical tower?
02:34:00 <apfelmus> uh, and you want instance Enum Scheme ??
02:34:19 <nornagon> Korollary: right
02:34:35 <nornagon> apfelmus: i want div to work on ScmInteger foo
02:34:55 <nornagon> which seems to require Enum, Real and Ord.
02:35:21 <apfelmus> mh. most of the time, those functions will be undefined anyway.
02:35:36 <apfelmus> Scheme cries for a GADT
02:35:42 <nornagon> what's a GADT.
02:36:20 <apfelmus> data Scheme a where
02:36:20 <apfelmus>    Float :: Double -> Scheme Double
02:36:20 <apfelmus>    Integer :: Integer -> Scheme Integer
02:36:36 <nornagon> crazy
02:36:42 <nornagon> how does that work?
02:37:00 <apfelmus> it's an extension. -fglasgow-exts
02:37:09 <nornagon> *nod*
02:37:17 <nornagon> can i read more about it somewhere?
02:37:19 <nornagon> @where gadt
02:37:20 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
02:38:02 <apfelmus> http://haskell.org/haskellwiki/GADT
02:38:04 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
02:38:23 <Korollary> does Scheme define enum operations for doubles?
02:38:35 <nornagon> no idea
02:39:50 <nornagon> i fail to see why Scheme needs a GADT
02:40:17 <apfelmus> ?paste
02:40:17 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
02:40:51 <dons> yay, hpaste.org works
02:42:24 <apfelmus> nornagon: you get type checking for free
02:42:45 <hpaste>  apfelmus pasted "scheme GADT" at http://hpaste.ath.cx:8000/46
02:42:53 <nornagon> don't i already get free type checking?
02:42:56 <dons> nornagon: yeah, embedding a language like scheme in a gadt is a pretty natural thing to do now
02:43:09 <dons> since you're getting a deeper embedding, than just using an AST
02:43:14 <nornagon> ooh
02:43:28 <nornagon> I like instance Enum (Scheme Integer)
02:43:37 <hpaste>  apfelmus annotated "scheme GADT" with "(no title)" at http://hpaste.ath.cx:8000/46#1
02:44:34 <apfelmus> this way, you cannot accidentally add to non-integers
02:45:25 <hpaste>  nornagon annotated "scheme GADT" with "(no title)" at http://hpaste.ath.cx:8000/46#2
02:45:29 <nornagon> uhm.
02:45:39 <nornagon> I actually want to be able to add integers to non-integers.
02:45:45 <nornagon> (+ 1 1/2)
02:45:49 <nornagon> ^- should work.
02:47:01 <hpaste>  apfelmus annotated "scheme GADT" with "polymorphic add" at http://hpaste.ath.cx:8000/46#3
02:47:51 <nornagon> and what about (Float a) + (Integer b) ?
02:49:30 <apfelmus> you can do this, too. but the fact that it's not very easy means that you have to think of the semantics, first. Is (1+ 1/2) = 1 or = 1.5 or = 1.5 + i*0 ??
02:49:54 <nornagon> (+ 1 1/2) should be 3/2
02:50:04 <nornagon> (+ 1 0.5) should be 1.5
02:50:16 <nornagon> (+ 1/2 0.5) should be 1.0
02:50:19 <dons> so you have to specify these type coercion rules somewher
02:50:23 <nornagon> yes.
02:54:00 <bakert> Hi all.  I'm trying to use cabal for my build process.  I need to pass -rpath=/opt/postgresql/lib" through to the linker.
02:54:05 <dons> ok
02:54:10 <bakert> Do you know how I say that in my .cabal file?
02:54:30 <bakert> If I do a "runhaskell Setup.lhs -v build" then I can see the ghc command.
02:54:48 <hpaste>  apfelmus annotated "scheme GADT" with "with subtyping" at http://hpaste.ath.cx:8000/46#4
02:54:48 <bakert> If I add to that -optl "-Wl,-rpath=/opt/postgresql/lib" then it allworks great.
02:54:53 <nornagon> dons: what's an elegant way of specifying above coercion rules?
02:54:57 <dons> ghc-options: -optl-rpath=/opt/postgresql/lib
02:54:57 <dons> I think
02:54:57 <dons> ah ok
02:55:06 <bakert> dons, thanks
02:55:30 <earthy> hpaste is nice
02:55:31 <hpaste>  apfelmus annotated "scheme GADT" with "corrected typo" at http://hpaste.ath.cx:8000/46#5
02:56:19 <apfelmus> but you should test whether this really compiles :)
02:56:22 <nornagon> heh.
02:58:32 <apfelmus> this way, the type system enforces you to think about the coercion rules.
02:59:48 <dcoutts> Saizan, found it!, all I needed was "ChangesEnvironment=yes" in the install script.
03:00:29 <Saizan> mmh, and what would that do?
03:00:58 <Saizan> refresh %path%?
03:01:24 <dcoutts> Saizan, it notifies other apps, like windows explorer that the environment in the registry has changed and that they should reload that info from the registry.
03:01:57 <dcoutts> normally a process's environment doesn't change and is inherited from the lanuching process
03:02:28 <dons> apfelmus: very very nice
03:02:51 <Saizan> yeah, experienced that with multiples cmd.exe
03:03:35 <apfelmus> dons: indeed. but unfortunately, we cannot say
03:03:35 <apfelmus> instance (Subtype a b, Subtype b c) => Subtype a b where
03:03:59 <nornagon> you mean Subtype a c?
03:04:06 <apfelmus> err, of course
03:04:13 <nornagon> why not?
03:05:30 <apfelmus> the compiler won't accept it. it's unclear how to preserve termination of type inference with such general instance definitions. the point is that b does not appear on the right hand side of =>
03:05:55 <nornagon> hm.
03:06:22 <apfelmus> so the compiler would have to search for a nice b, just like on does in PROLOG
03:07:05 <straus> hello, All
03:08:10 <ToRA> morning
03:10:07 <dons> hmm. very interesting
03:10:35 <dons> a challenge for oleg and shan :)
03:11:40 <pejo> Now that we're on the topic of things appearing to the right of =>, are functional dependencies uncapable of expressing what you want?
03:11:54 <pejo> (I shouldn't wander into discussions midway, I know. But I have to ask!)
03:12:08 <nornagon> incapable!
03:12:20 <nornagon> but i have no idea what you mean by that, sorry. I'm just another newbie :)
03:13:26 <apfelmus> dons: :) but, alas, oleg simply says -fallow-undecidable-instances and things work anyway. this allows general type level programming and it's not that surprising that he can f.i. emulate GADTs
03:15:04 <apfelmus> pejo: no, fundeps don't help here. the point is that for given a, there should be multiple bs with Subtype a b. same goes for the other way round
03:16:43 <apfelmus> you can use fundeps to make (inject . inject) work, but then, you must explicitly track how many injects you need.
03:17:58 <DrDetro1t> I tell ha
03:18:00 <DrDetro1t> ya
03:18:04 <DrDetro1t> those C++ people just suck
03:18:13 <DrDetro1t> they need a little fortran in their lives
03:18:40 <DrDetro1t> why reduce real human beings to thinking systems ?
03:18:44 <DrDetro1t>  they probably dont' suck
03:18:45 <dons> hmm
03:19:05 <DrDetro1t> but - to hold onto a paradigm and embrace it
03:19:07 <DrDetro1t> even if Haskell
03:19:13 <DrDetro1t> a problem solving paradigm
03:19:19 <DrDetro1t> and mistake it for the process itself
03:19:27 --- mode: ChanServ set +o dons
03:19:32 <DrDetro1t> might as well be snow falling
03:19:35 --- kick: DrDetro1t was kicked by dons (no spamming)
03:19:39 <DrDetro1t> oh no
03:19:42 <DrDetro1t> not this again
03:19:49 --- mode: dons set +b *!*n=erwin@*.pitt.east.verizon.net
03:19:49 --- kick: DrDetro1t was kicked by dons (sigh)
03:20:08 --- mode: ChanServ set -o dons
03:20:13 <dons> did this earlier today too
03:21:05 <apfelmus> i suspected that
03:22:21 <apfelmus> why reduce human beings to spamming systems?
03:23:04 <matthew_-> mmm. was that the same as the brainy green thing about 12 hours ago?
03:23:15 <dons> yeah
03:23:18 <dons> same guy
03:23:23 <opqdonut> what did he do?
03:23:27 <matthew_-> spam
03:23:33 <dons> just spammy troll noise
03:23:52 <matthew_-> grrr. it's like blog spam - they pay humans so to get round capcha and other systems so to post spam.
03:24:34 <int-e> they pay? I thought all you needed to do is offer porn for solving captchas.
03:24:52 <dons> heh
03:24:54 <psnl> damn, I could have got money instead of porn
03:26:08 <apfelmus> don't tell me that you'd spend it for other things than HOT stuff (higher order and typed, of course)
03:26:16 <dons> heh
03:26:44 <matthew_-> ahh, I thought you were going to refer to the HOTChips conference ;)
03:28:49 <dons> so i put a link to http://hpaste.org on the haskell front page now
03:28:56 <dons> so we better hope we got the thing working :)
03:29:50 <dons> hmm, now i should really work out a darcs interface to this thing
03:32:29 <hpaste>  (anonymous) pasted "test" at http://hpaste.ath.cx:8000/47
03:34:26 <dons> people have to check it works? :)
03:42:15 <kaol> I'm checking through HAppS's licensing...  HAppS/Protocols/Base64.hs has a sizable chunk of rfc2045 quoted in it. While a handy reference, RFCs aren't generally licensed under BSD or anything of the like as the rest of HAppS is.
03:44:34 <kaol> I guess I should email them about it.
03:45:42 <vegai> kaol: you could also /join #happs and make some noise :)
03:46:50 <syntaxfree> @paste
03:46:50 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
03:48:07 <syntaxfree> @tell glguy wow. big redesign. the buttons ("save", etc.) are kinda odd, though. These Dojo-style buttons suck! Bring the old square, shadowed buttons!
03:48:07 <lambdabot> Consider it noted.
03:48:48 <hpaste>  syntaxfree pasted "I feel stupid. What is wrong with this?" at http://hpaste.ath.cx:8000/48
03:51:35 <straus> can anybody help me with hsql instalation on winxp&
03:51:46 <Saizan> syntaxfree,  left, right :: (Eq b)=> a->b  here b can be every instance of Eq as the caller needs
03:51:59 <syntaxfree> hmm.
03:52:04 <syntaxfree> you're right.
03:52:15 <syntaxfree> what should be the type of left and right?
03:53:45 <Saizan> something like c a b -> b?
03:54:58 <syntaxfree> hmm.
03:55:09 <Saizan> ?src Monad
03:55:10 <lambdabot> class  Monad m  where
03:55:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
03:55:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
03:55:10 <lambdabot>     return      :: a -> m a
03:55:10 <lambdabot>     fail        :: String -> m a
03:55:59 <Saizan> a little like that
03:56:15 <Saizan> but that depends on the meaning of your class i suppose
03:56:47 <hpaste>  syntaxfree annotated "I feel stupid. What is wrong with this?" with "still don't understand" at http://hpaste.ath.cx:8000/48#1
03:57:34 <apfelmus> syntaxfree: what are you doing? i mean to say: what do you want to do? what's a Chain?
03:57:52 <syntaxfree> a Chain is something with one side that "fits" into the other.
03:58:16 <syntaxfree> like a plug that goes into a plug-hole.
03:58:23 <syntaxfree> or a domino piece that fits into another.
03:58:56 <apfelmus> ok. but is it a type? a value?
03:59:04 <syntaxfree> it's a type class!
03:59:44 <apfelmus> syntaxfree: that's what you're trying to do. but you need to formalize what "plug" means
03:59:48 <syntaxfree> the class of things that has two sides and has an operation "match" between them.
04:00:01 <syntaxfree> plug a b = (right a) == (left b)
04:00:09 <dcoutts> someone just posted to haskell-cafe "IO is not a monad". Can anyone see what's wrong with his example? It's not clear to me that there's anything wrong.
04:00:13 <syntaxfree> for the appropriate definition of (==)
04:00:41 <apfelmus> syntaxfree: that's "pluggable". but how do you plug?
04:00:43 <Botje> syntaxfree: the types for left and right look wrong to me..
04:01:04 <syntaxfree> apfelmus: well, that's not relevant yet I think.
04:01:16 <Botje> but then again, i'm not very experienced in haskell either :)
04:01:20 <njd> ?hoogle sort
04:01:20 <syntaxfree> Chain really should be called "Chainable".
04:01:21 <lambdabot> List.sort :: Ord a => [a] -> [a]
04:01:21 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
04:01:21 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
04:01:36 <syntaxfree> I'll later figure out how to construct a Chain.
04:02:18 <syntaxfree> for now, I just want to express the class of things that are pluggable.
04:02:40 <apfelmus> syntaxfree: mmh. i have the suspicion that you have to include the chain construction into the type class right now, otherwise the class is void of meaning
04:03:14 <syntaxfree> I don't' see why I would.
04:03:29 <apfelmus> it's a feeling, but a strong one
04:03:38 <syntaxfree> This looks like a simple algebraic structure to me. I want pairs of things with an operation "match".
04:03:50 <syntaxfree> where (a, b) <*> (c, d)  if b == c
04:04:23 <hpaste>  ToRA annotated "I feel stupid. What is wrong with this?" with "(no title)" at http://hpaste.ath.cx:8000/48#2
04:04:49 <syntaxfree> of course, I could just use tuples, but I want to be able to specify the "left" of non-tupled types if the need arises.
04:05:10 <ToRA> syntaxfree: is that some help?
04:05:32 * syntaxfree has an idea of left and right for integers. But that's not the point here yet. Pretend I'm taking about dominos.
04:06:14 <syntaxfree> hmm. what's the functional dependency doing there again?
04:06:36 <ToRA> erm, it doesn't compile without it
04:06:40 <apfelmus> hehe
04:07:02 <ToRA> it's one of those odd cases where i know why it's there, but have no idea how to explain the intuition as to why it's needed
04:07:46 <apfelmus> look, p is an object that can be chained. a describes how the plugs look like
04:08:02 <syntaxfree> I mean, I understand now why it needs to be Chain p a
04:08:34 <syntaxfree> of course. the class definition needs to know what the components of a piece look like.
04:08:40 <syntaxfree> It's the fundep that confuses me.
04:09:12 <apfelmus> clearly, you can tell from the domino p how it's plugs must look like
04:09:28 <ToRA> ok i'll try this, it's for the <*> function; if the fun dep isn't there, there could be multiple instances for what the plugs could be unless you force there to be only one
04:09:50 <ToRA> (which is what the fundep does0
04:09:54 <syntaxfree> ah.
04:09:56 <syntaxfree> I see.
04:10:23 <syntaxfree> how would I write "reverse" there?
04:10:28 <ToRA> "reverse"?
04:10:53 <syntaxfree> where reverse satisfies  y == reverse x <=> ( left x == right y) && ( right x == left y)
04:11:36 <syntaxfree> it's not clear to me whether the data constructor for the piece was passed as a parameter to the class. It seems to me that it isn't.
04:11:41 <apfelmus> syntaxfree: you can't. p may contain other data than it's plugs
04:11:50 <syntaxfree> true.
04:11:55 <syntaxfree> I'll use a separate class.
04:12:20 <apfelmus> also, you shouldn't make <*> a member of your class.
04:12:39 <syntaxfree> shouldn't I?
04:12:58 <syntaxfree> hmm. This looks like a good exercise to learn the exotic-ish type system extensions from.
04:13:00 <apfelmus> no. because the default definition is *the* definition
04:13:14 <apfelmus> you don't want another one
04:13:43 <syntaxfree> ah, shouldn't make <*> a member of the new, "Revertible" class?
04:14:11 <apfelmus> no. it's a simple function <*> :: (Eq a, Chain p a) => p -> p -> Bool
04:14:57 <syntaxfree> yes. I wanted the class to contain the one true definition.
04:14:59 <hpaste>  apfelmus annotated "I feel stupid. What is wrong with this?" with "<*> extra" at http://hpaste.ath.cx:8000/48#3
04:15:52 <apfelmus> syntaxfree: that's not advisable because it reduces Chain to a mere Eq
04:16:42 <syntaxfree> not really.
04:17:08 <syntaxfree> (==) in Eq is supposed to be transitive.
04:17:11 <syntaxfree> (<*>) isn't.
04:18:16 <syntaxfree> ((P One Two) <*> (P Two Three)) && ((P Two Three) <*> (P Three Four)) =/=> (P One Two) <*> (P Three Four)
04:18:34 <apfelmus> ah, ok.
04:18:55 <apfelmus> but it looks like an artifact as plugging itself is associative
04:19:43 <syntaxfree> well, <*> does not define "plugging", it defines "pluggable".
04:20:11 <syntaxfree> anyway, I didn't really want "reverse". This is what I wanted:
04:20:22 <syntaxfree>  a <**> b = (a <*> b) || (b <*> a)
04:20:23 <apfelmus> yes. but it's type is too general. left and right together with == define "plugging" much better
04:20:54 <syntaxfree> in a sense, this could be done with tuples. I'm investigating the general structure of dominos here.
04:21:07 <syntaxfree> I suspect I have an application to number theory.
04:21:25 <syntaxfree> it's really dominos I'm thinking of at the moment though.
04:22:47 <syntaxfree> I'm kinda trying to push my knowledge of the type system as well.
04:24:28 <hpaste>  apfelmus annotated "I feel stupid. What is wrong with this?" with "pair" at http://hpaste.ath.cx:8000/48#4
04:24:42 <straus> млин, этот канал - вещь в себе =((ъ
04:24:42 <malebria> Hello, is it possible to call a State function inside a StateT function?
04:25:09 <malebria> I have a State Env () function, and I and to call it from a StateT Env IO () function.
04:25:20 <ToRA> malebria: hi again
04:25:26 <malebria> ToRA: hey!
04:25:32 <ToRA> http://hpaste.ath.cx:8000/33
04:25:35 <ToRA> oh
04:25:35 <malebria> ToRA: sorry, couldn't get heere yesterday.
04:25:39 <ToRA> different signatures
04:25:47 <ToRA> dd you see that?
04:25:51 <ToRA> *did
04:26:18 <malebria> ToRA: it's the same..
04:26:37 <malebria> ToRA: thanks, converting it to pure functions is really a good options.
04:26:48 <syntaxfree> apfelmus: yes. but I want to have, at some point, instance Chain Int Int.
04:27:06 <apfelmus> syntaxfree: why? just take (Int,Int)
04:27:25 <syntaxfree> because Chain Int Int doesn't mean (Int, Int).
04:27:28 <apfelmus> or (Int, ExtraData, Int)
04:27:39 <syntaxfree> It means the container type is an int and the containee type is also an Int. Look at the code.
04:28:04 <apfelmus> ah, sorry.
04:28:25 <syntaxfree> np. thanks for trying to help, heh :)
04:28:57 <syntaxfree> ToRA, Botje: thanks as well :)
04:28:58 <malebria> ToRA: have you seen my question in haskell-cafe?
04:29:38 <ToRA> title/topic?
04:29:55 <apfelmus> syntaxfree: though i'm interest in your number theory application now
04:29:58 <dcoutts> sjanssen, so do you think I should generalise the Undo.hs module to provide @desugar and just make @undo an alias ?
04:30:03 <ToRA> or do you mean #haskell-cafe?
04:30:12 <malebria> ToRA: no haskell-cafe@haskell.org
04:30:40 <syntaxfree> apfelmus: it's all too fuzzy in my head yet.
04:30:45 <malebria> ToRA: Type infer
04:30:48 <syntaxfree> I've been taking this number theory course for two weeks.
04:30:55 <syntaxfree> graduate-level course.
04:31:02 <ToRA> malebria: i'll have a look
04:31:06 <ToRA> brb
04:31:31 <syntaxfree> so, um, we've gotten through a lot already, but the ideas are not mature in my head already.
04:31:35 <syntaxfree> s/already/yet.
04:31:50 <malebria> ToRA: http://www.haskell.org/pipermail/haskell-cafe/2007-January/021521.html
04:31:52 <lambdabot> Title: [Haskell-cafe] Type infer, http://tinyurl.com/2rdbk7
04:32:07 <syntaxfree> I never had a course in number theory before, and this course is taught as if the basics of usually-applicable number theory have already been taught.
04:32:34 <syntaxfree> (Though I'm being able to follow it because the course is strictly constructive, and relies on some ring/group theory to cut to the chase)
04:33:09 <apfelmus> ok :) but what property for plugging did you have in mind?
04:34:05 <ToRA> malebria: i don't know the answer, and it's actually a situation i've hit before, so i'd like to know the answer too ;)
04:34:13 <syntaxfree> I'm trying to look at an integer as the product of two integer factors.
04:34:17 <malebria> ToRA: =D
04:34:24 <syntaxfree> I still haven't thought out fully of how this unique factorization is to be defined.
04:34:50 <syntaxfree> Right now I'm playing with a simpler example.
04:34:57 <dons> ?uptime
04:34:58 <lambdabot> uptime: 1m 7s, longest uptime: 2d 3h 42m 19s
04:35:00 <syntaxfree> instance Chain Int Int where
04:35:00 <syntaxfree>         left x = x `mod` 2
04:35:00 <syntaxfree>         right x = x `mod` 3
04:35:04 <dons> ?paste
04:35:05 <lambdabot> http://hpaste.org (Haskell pastebin)
04:35:19 <syntaxfree> I want to see if I can derive some direct formula for x <*> y
04:35:25 <syntaxfree> er, x <**> y
04:35:49 <merus> What does this syntax mean?
04:35:52 <syntaxfree> it's not hard, yes, but if I keep on chatting on IRC I'll never be able to concentrate!
04:36:39 <apfelmus> yeah, i know this feeling, too :)
04:36:52 <merus> Oh, nevermind, checked the backlog.
04:37:05 <hpaste>  syntaxfree pasted "this is what I'm playing with right now." at http://hpaste.ath.cx:8000/49
04:38:50 <merus> Interesting.
04:39:13 <bakert> :q
04:39:28 <syntaxfree> Fun question: with that definition of Chain, what's the smallest twin integer?
04:39:28 <merus> <*> isn't even reflexive :O
04:39:36 <syntaxfree> <**> is.
04:39:54 <syntaxfree> oh, not reflexive, commutative.
04:39:58 <syntaxfree> merus: Think of dominos.
04:40:09 <merus> Oh, is that what this is about.
04:40:11 <syntaxfree> that's what the One Two Three Four Five Six is doing up th ere.
04:40:21 <syntaxfree> it's about seeing integers as dominos.
04:40:33 <merus> Some sort of CG?
04:40:33 <syntaxfree> Can you work out a formula for obtaining the twin integers?
04:40:41 <syntaxfree> (hint: chinese remainder theorem)
04:41:02 * ToRA wonders if there are unicode characters for dominos, and if you could use them as haskell data constructors...
04:41:37 <syntaxfree> evidently, multiples of 6 are twin integers.
04:41:49 <syntaxfree> there are some non-multiples of six as well though.
04:42:11 <merus> Oh, I see what you're asking.
04:42:13 <syntaxfree> for example, 6x+1 when 6x is even.
04:42:17 <merus> Hurm.
04:42:18 <syntaxfree> oh. then again, 6x is always even.
04:42:32 * merus contemplates.
04:42:43 <syntaxfree> merus: it's just a first test. I eventually want to examine factorizations of integers.
04:43:05 <syntaxfree> so the "left" and "right" of an integer will be integer factors.
04:43:14 <earthy> ToRA: there are not.
04:43:25 <earthy> ToRA: however, you could, if there were. ;)
04:43:27 <bakert> ?hoogle liftIO
04:43:28 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
04:44:14 <ToRA> earthy: http://unicode.org/alloc/Pipeline.html i think they're coming though
04:44:15 <lambdabot> Title: Proposed New Characters -- Pipeline Table
04:46:05 <merus> syntaxfree: So yeah, you're just looking for ints such that n = x mod 2 and n = x mod 3?  Sounds chinese remainder theorem to me.
04:46:08 <syntaxfree> it seems that numbers of the form 6x and 6x+1 are the only twin integers for that defiintion of Chain Int Int.
04:46:49 <syntaxfree> I just said that :)
04:47:05 <merus> I thought you were copying some homework problem or whatever :P
04:47:18 <earthy> ToRA: accepted, indeed.
04:48:00 <syntaxfree> nah, Im exploring what versions of Chain Int Int can be used, and what the properties of <*>, <**> and twin would be.,
04:48:08 <syntaxfree> in this case, it's simple.
04:48:23 <merus> Oh, okay.
04:48:36 * merus has spent too much time hanging around #math.
04:48:36 <syntaxfree> 2*x+1 will be 1 mod 3 whenever it can also be written as 6*x + 1
04:49:15 <syntaxfree> 2* x will be 0 mod 3 whenever it can be written as  6*x
04:49:22 <merus> Yeah.
04:49:27 <syntaxfree> 2*x +2 = 2* (x+1), so it's useless to look furhter.
04:49:40 <merus> yay induction.
04:50:20 <syntaxfree> I'm not good at homework-type problems. Or formal education, at all.
04:50:36 <syntaxfree> I just pursue it to learn new kinds of problems that are fun to explore.
04:50:59 <syntaxfree> I'm an explorer. I suck at olympiad-type problems because I can't focus on one thing for long.
04:53:56 * merus wanders off to go play with lattices.
04:55:02 <syntaxfree> in case anyone's in the mood to explore: new definition of Chain:
04:55:15 <syntaxfree> instance Chain Int Int where
04:55:16 <syntaxfree>         left x = x `div` 2
04:55:16 <syntaxfree>         right x = 3 * x + 1
04:55:35 <syntaxfree> any resemblance to the collatz conjecture is accidental. divving even numbers ruins it.
04:55:54 <merus> heheh.
04:56:23 <merus> One of my erm, what's the word, acquaintances is working with a generalization of Collatz
04:56:36 <merus> computational number theory estimates == boring, imho.
04:58:52 <bakert> Is there any way to tell cabal to use some of my ghc-options only on certain machines?
05:01:58 <syntaxfree> is killing a program a guaranteed way to free its memory?
05:02:51 <ToRA> yes
05:02:54 <therp> syntaxfree: if it's actually terminated, I would say so
05:03:13 <bakert> kill -9 to be more sure that it dies?
05:03:21 <syntaxfree> it no longer appears on ps ax
05:03:26 <syntaxfree> I didn't explicitly kill it.
05:03:37 <syntaxfree> iTerm died on me, so I "killed" it via the GUI.
05:03:44 <syntaxfree> When I returned, the program had disappeared from ps ax.
05:05:59 <syntaxfree> wow.
05:06:00 <syntaxfree>     The equation(s) for `twins' have one argument,
05:06:00 <syntaxfree>     but its type `[Int]' has none
05:06:06 <syntaxfree> the error messages for ghc sure have improved!
05:06:17 <pejo> bakert, it's definitely a good idea to try ordinary kill before -9, since it will give the program a fair chance of shutting down cleanly.
05:09:19 <hpaste>  syntaxfree annotated "this is what I'm playing with right now." with "wow, ghc is psychic" at http://hpaste.ath.cx:8000/49#1
05:10:14 <merus> syntaxfree: yes, ghc is psychic.
05:11:39 <earthy> ghc 6.6 is annoying
05:11:54 <earthy> module Foo where (export1, , export2) is no longer valid syntax. :)
05:11:56 <erg0t> <pejo> bakert, it's definitely a good idea to try ordinary kill before -9, since it will give the program a fair chance of shutting down cleanly. <- maybe better kill -15 first, the program can catch a SIGTERM
05:15:02 <syntaxfree> erg0t: is that do-notation?
05:16:46 <erg0t> what?
05:18:50 <hpaste>  syntaxfree annotated "this is what I'm playing with right now." with "Conjecture: are all "balanced" numbers powers of two?" at http://hpaste.ath.cx:8000/49#2
05:19:24 <emk> I've discovered a new way to loose with Haskell packages that contain C helper sources. :-(
05:20:21 <emk> Now GHCI can't find snprintf: /usr/local/lib/ByteStringIO-0.0/ghc-6.6/HSByteStringIO-0.0.o: unknown symbol `_snprintf$LDBLStub
05:21:38 <syntaxfree> (hint: totient (2^k) = 2^k - 2^{k-1})
05:22:27 <merus> that's not exactly a hint :P
05:22:37 <merus> that's more hitting someone over the head with the answer.
05:22:52 <syntaxfree> heh.
05:23:04 <syntaxfree> I feel like a schoolboy at an amusement park.
05:23:07 <syntaxfree> This is a great toy.
05:23:24 <emk> GHC seems to work fine, though. I just need to figure out how to GHCI to find the necessary support files...
05:23:53 <ToRA> syntaxfree: how are you getting the timing information?
05:24:00 <syntaxfree> :set +s
05:24:26 <ToRA> wow, ghci just never ceases to amaze
05:25:21 <earthy> okay, that's the wxHaskell build instructions updated for Mac OS X with GHC 6.6
05:25:33 <earthy> and Dazzle upgraded to GHC 6.6
05:25:51 <kowey> oh earthy, thanks for figuring out what's wrong with using Tiger's wxWidgets, btw
05:26:30 <earthy> no probs. I was interested and had some time on my hand due to you solving the linux problem for me. ;)
05:26:56 <malebria> Where can I find doc about GHCs kinds?
05:27:02 <earthy> there seems to be No Way to get wxhaskell to work with Tiger's wxWidgets
05:27:02 <malebria> I'm getting a kind mis-match error.
05:27:19 <emk> Oh, goody. Do I really need to rebuild all of MacPorts to fix this bug?
05:27:22 <kowey> it's a pity, that
05:27:23 <earthy> malebria: then you are mis-applying a type constructor
05:27:26 <earthy> emk: what bug?
05:27:48 <earthy> emk: the wxWidgets that is in MacPorts doesn't have it
05:28:02 <emk> earthy: unknown symbol `_snprintf$LDBLStub (this isn't wxWidgets related)
05:28:25 <emk> It's a GHCI problem loading C stubs...
05:37:53 <earthy> emk: can't help you with that one, unfortunately
05:38:31 <emk> earthy: It looks like it's related to this problem: http://hackage.haskell.org/trac/ghc/ticket/1018
05:38:34 <lambdabot> Title: #1018 (ghci dynamic loading of X11 - unknown symbol `_printf$LDBLStub') - GHC -  ...
05:38:45 <malebria> ToRA: I got a better option.
05:38:45 <emk> But I already have the fix in that e-mail applied. :-(
05:39:07 <pejo> malebria, TAPL has a nice chapter on kinds, it's rather late in the book though.
05:39:07 <malebria> Using MonadState m class instead of State type in type signature.
05:39:28 <ToRA> malebria: ahh yeah
05:39:32 <malebria> pejo: thanks.
05:39:42 <earthy> emk: the DYLD_LIBRARY_PATH thing?
05:39:44 <hpaste>  syntaxfree pasted "a totient conjecture (no idea of how to solve this)" at http://hpaste.ath.cx:8000/50
05:40:23 <emk> earthy: Actually, this seems to be a weird MacOS X thing that GHC sort of works around, but doesn't always quite handle...
05:40:35 <earthy> linking on MacOS X is weird
05:40:58 <earthy> and it's obviously a linking problem
05:41:10 <malebria> ToRA: but since I can't add the type signature to the source, I'll have to leave it comented.
05:41:46 <earthy> but try setting DYLD_LIBRARY_PATH=/usr/lib:/usr/X11R6/lib:/usr/local/lib/ByteStringIO-0.0/ghc-6.6/
05:41:49 <syntaxfree> I should always add a disclaimer.
05:41:58 <syntaxfree> This is not a homework question -- I have no idea if it's even decidable.
05:43:26 <matthew_-> challenge 1, reduce HCP to http://hpaste.ath.cx:8000/50. On success, abandon hope!
05:43:37 <ToRA> malebria: right
05:44:20 <syntaxfree> HCP?
05:44:32 <matthew_-> hamiltonian circuit problem
05:44:42 <syntaxfree> well, no idea of what that is,
05:44:46 <matthew_-> one of the standard NPC problems
05:44:59 <syntaxfree> I know nothing of decidability theory.
05:45:12 <malebria> State monad is very nice.
05:45:15 <malebria> Monads are nice.
05:45:24 <syntaxfree> @seen glguy
05:45:24 <lambdabot> I haven't seen glguy.
05:45:40 <syntaxfree> I wonder if it's okay to post an hpaste url to programming.reddit.com
05:46:08 <ToRA> malebria: i know exactly what you mean :)
05:46:15 <malebria> =D
05:47:29 <matthew_-> syntaxfree: ahh, ok. Well in time complexity, you basically have P which is polynominal execution time in terms of length of input (where input is not unary); NP which is polynominal as before but on non-deterministic machine where you can abstract over multiple runs of the same algo, and then undecideable which is even worse!
05:47:48 <syntaxfree> I know P and NP. That I know :)
05:48:10 <syntaxfree> I mean, I don't know how to prove a problem is undecidable.
05:48:20 <matthew_-> prove it's not in NP
05:48:28 <psnl> reduce it to the halting problem
05:49:01 <matthew_-> if it's not in NP then you can reduce an NPC problem to it, but you can't reduce it to an NPC problem
05:49:09 <matthew_-> anyway, probably off topic...
05:50:48 <pejo> matthew, naw, I wouldn't call decidability off topic in here.
05:52:02 <matthew_-> ok, well in that case I can continue regurgitating parts of a course I took last year ;)
05:52:14 <shapr> @seen brainly-green
05:52:15 <lambdabot> I haven't seen brainly-green.
05:52:28 <shapr> Good morning #haskell!
05:52:28 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
05:56:58 <ToRA> interesting lambdabot behaviour there: did it not do the seen/messages check on shapr's @seen instruction, and instead wait for the Good morning?
05:57:31 <matthew_-> next it'll be wanting the morning's papers and a cup of coffee before reporting messages!
05:58:59 <shapr> ToRA: You want to fix lambdabot so that it activates on @commands as well as normal messages?
05:59:06 * earthy grins
05:59:47 <ToRA> shapr: is it a conceptually hard fix to do?
06:00:00 <shapr> I don't think so.
06:00:42 <ToRA> shapr: i think i will then
06:00:50 <shapr> I suspect the messages hook is only in the normal message handler, and that the command handler never calls the normal message handler.
06:01:08 <augustss> syntaxfree: the typical way to prove undecidability is to reduce to some know undeciable problem.  there are plenty, it doesn't take much to be undecidable
06:02:17 <shapr> ToRA: I think you'll have fun :-)
06:03:43 <ToRA> shapr: the first challenge is getting it to build...
06:03:47 <hpaste>  syntaxfree annotated "a totient conjecture (no idea of how to solve this)" with "Conjecture disproved!" at http://hpaste.ath.cx:8000/50#1
06:03:48 <njd> ?hoogle yeild
06:03:48 <lambdabot> No matches found
06:03:55 <njd> ?hoogle yield
06:03:56 <lambdabot> Control.Concurrent.yield :: IO ()
06:05:36 <matthew_-> augustss: if you try the "guess-and-check" for membership within NP and the check is not in P, is that sufficient to show it's outside NP ?
06:06:57 <syntaxfree> that's a fun conjecture. I wish I could restate it in simple terms.
06:07:01 <njd> ?hoogle readIORef
06:07:01 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
06:07:15 <matthew_-> > f :: Room ->
06:07:16 <lambdabot>  Parse error
06:07:17 <matthew_-> agh
06:07:22 <syntaxfree> I feel like posting it to reddit, but I fear for the poor guy who pays for the hpaste bandwidth.
06:08:22 <Saizan> aka shapr
06:08:59 <matthew_-> > let f :: Room -> #HaskellMember -> #HaskellMember -> Maybe (Room, #HaskellMember, #HaskellMember), f r m1 m2 | (in r m1) && (in r m2) = Just (r, m1, m2); otherwise = Nothing
06:08:59 <lambdabot>  Parse error
06:09:11 <syntaxfree> well, yeah.
06:09:15 <matthew_-> not for you lambdabot, but for the channel ;)
06:09:21 <syntaxfree> that would not be courteous.
06:12:34 <amiddelk> syntaxfree: I probably don't understand the problem you mention... but you input is effectively a graph, so you can always construct a next-function by indexing in the corresponding adjacency list?
06:12:53 <shapr> Saizan: what?
06:12:59 <shapr> oh
06:13:15 <syntaxfree> apparently not all numbers have a "next". It requires a restrictive condition.
06:13:32 <syntaxfree> that is, totient (next x) = co-totient x
06:14:01 <shapr> syntaxfree: Feel free to try it.
06:14:11 <syntaxfree> try what?
06:14:23 <syntaxfree> nah. I'm gonna take an image of the page and post it on imageshack.
06:14:24 <shapr> posting something on hpaste to reddit
06:14:27 <shapr> ok
06:14:38 <syntaxfree> it would cost you money, man :)
06:15:02 <shapr> I dunno, I get a large chunk of bandwidth for free, and in the past I've not yet approached my monthly limit.
06:15:27 <syntaxfree> well, I'll see if there's a convenient way of taking screenshots.
06:15:37 <syntaxfree> I think I once saw a program that did "tall" screenshots like that.
06:15:39 <paolino> @pl do {a <- get;tell [a]}
06:15:39 <lambdabot> (line 1, column 4):
06:15:39 <lambdabot> unexpected "{"
06:15:39 <lambdabot> expecting variable, "(", operator or end of input
06:16:35 <ToRA> shapr, or others, how do you install zlib that is needed for lambdabot?
06:16:49 <paolino> @pl let f=do {a <- get;tell [a]} in f
06:16:49 <lambdabot> (line 1, column 10):
06:16:49 <lambdabot> unexpected "{"
06:16:49 <lambdabot> expecting variable, "(", operator, ";" or "in"
06:18:19 <paolino> what's wrong there ?
06:18:39 <Saizan> @. pl undo do {a <- get;tell [a]}
06:18:39 <lambdabot> tell . return =<< get
06:19:12 <paolino> @pl undo do {a <- get;tell [a]}
06:19:12 <lambdabot> (line 1, column 9):
06:19:12 <lambdabot> unexpected "{"
06:19:12 <lambdabot> expecting variable, "(", operator or end of input
06:19:42 <paolino> @. pl  do {a <- get;tell [a]}
06:19:42 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ""
06:19:44 <Saizan> 1) pl doesn't understand do notation 2) you need @. to compose 2 plugins
06:19:51 <paolino> ah
06:19:56 * malebria is wondering about never let type signatures uncommented.
06:20:49 <paolino> @. pl undo do {a <- gets b;tell [a]}
06:20:49 <lambdabot> tell . return =<< gets b
06:21:29 <chessguy> 'morning
06:21:37 <paolino> thanks
06:22:23 <syntaxfree> shapr: this is the result : )
06:22:24 <syntaxfree> http://img214.imageshack.us/img214/9281/totient2xd.png
06:22:49 <emk> OK, I figured out how to work around the long double lossage with GHCI on MacOS X...
06:23:05 <emk> Nasty. :-/
06:23:08 <sjanssen> oh wow, the new hpaste looks really snazzy
06:23:16 <shapr> Yeah, I love the new look.
06:23:25 <shapr> glguy++ -- for great code justice!
06:23:26 <syntaxfree> hmm. otoh people have to retype stuff to try it.
06:23:52 <syntaxfree> shapr: do you have a simple way of throttling visitors based on http_referrer?
06:24:08 <sjanssen> @paste
06:24:08 <lambdabot> http://hpaste.org (Haskell pastebin)
06:24:28 <shapr> No... but I'm sure I could figure it out if I needed to.
06:24:36 <syntaxfree> I know what I'm going to do.
06:24:43 <syntaxfree> I'm gonna link to the image, and mention the hpaste url in a comment.
06:24:50 <shapr> Good idea!
06:25:11 <hyrax42> new hpaste look is nice
06:25:23 <njd> ?hoogle+ readIORef
06:25:56 <njd> ?hoogle readIORef
06:25:57 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
06:26:07 * emk slogs through bugs to get a fast ByteString version of read/show working...
06:26:34 <syntaxfree> listo. http://programming.reddit.com/info/100fl/comments
06:26:34 <chessguy> syntaxfree, you're trying to find a function?
06:26:35 <lambdabot> Title: A totient conjecture (reddit.com)
06:26:54 <syntaxfree> gonna get some lunch now.
06:27:04 <chessguy> syntaxfree?
06:27:13 * shapr sends e-pizza to SeГ±or Navarro
06:28:01 <shapr> @karma glguy
06:28:01 <lambdabot> glguy has a karma of 41
06:28:10 <shapr> wow, hpaste is GOOD for the karma =)
06:28:59 <emk> Does Haskell have a standard operator for approximate floating-point comparison?
06:29:41 <hyrax42> ?karma+ glguy
06:29:41 <lambdabot> glguy's karma raised to 42.
06:29:51 <hyrax42> had to round it out a bit to a nice number
06:29:54 <shapr> hah
06:30:04 <hyrax42> I think his karma should now be fixed
06:31:11 <paolino> @. pl undo do {a <- gets b;tell [show a]}
06:31:12 <lambdabot> tell . return . show =<< gets b
06:35:53 * shapr throws lambda paste
06:37:06 <shapr> I met ROGER DAVIES from UNICYCLE.COM with a VAN FULL of UNICYCLES at MICROSOFT RESEARCH by COMPLETE ACCIDENT!
06:37:17 <shapr> that's actually true...
06:37:35 * shapr decides to start a new 'zine "True Yow!"
06:37:44 <shapr> hej bringert, god morgon!
06:37:53 <bringert> god morgon shapr!
06:37:59 <shapr> Hur mГҐr du?
06:38:34 * resiak steals a unicycle
06:38:34 <bringert> is there a quick way to tell darcs to give me the an old version of a given file?
06:39:03 <shapr> bringert: First thing that comes to mind is to ask for a diff from this version to the old version and apply it.
06:39:09 <shapr> There's probably an easier way....
06:39:17 <bringert> shapr: i'm ok, working on an article due in a few hours
06:39:21 <shapr> oh
06:39:25 * shapr is quiet
06:39:49 <kowey> bringert: no official way; darcs diff --diff-command="cat %1" --from-patch="short name for prior patch"
06:40:05 <bringert> heh, cool
06:40:28 <bringert> kowey: thanks
06:40:32 <kowey> (might also want to sanity check to make sure it's really choosing the right "version")
06:40:59 * earthy is editing patches for fun and profit
06:42:15 <shankys> Can anyone recommend any nice serialization libraries in Haskell? I'm looking to use an existing serialization library to store things in memcached for the Haskell web framework I'm working on. Performance is important.
06:42:22 <kowey> :-)
06:42:37 <bringert> shankys: binary
06:42:39 <bringert> @where binary
06:42:40 <lambdabot> http://darcs.haskell.org/binary
06:42:45 <shankys> bringert: Thanks
06:43:01 <bringert> shankys: do you want to write you serialization instances yourself?
06:43:10 <chessguy> hi bringert
06:43:14 <matthew_-> is the hac07 a regular event - i.e. is there going to be a hac08?
06:43:16 <bringert> if not, I think ndm wrote something for deriving serialization
06:43:31 <shankys> bringert: Probably not
06:43:44 <shankys> bringert: But it might be useful at some point
06:44:46 <bringert> kowey: darcs gives me an annoying "Hit return to move on..." when I use --diff-command
06:45:12 <kowey> bringert: yeah, it's to deal with graphical diff utilities
06:45:38 <kowey> we really need a "query cat" feature; just not enough man power
06:46:14 <bringert> kowey: it also outputs a list of patches to stdout before the content
06:47:13 <kowey> oh yeah... hmm... one stupid solution is to actually use something like "open -e" instead of cat or TextEdit and save there
06:47:26 <kowey> or even opendiff %1 %2, and use the save feature in the gui
06:47:34 * kowey digs around
06:49:02 <bringert> ah, I can use latexdiff directly
06:49:31 <chessguy> hey bringert, i'm curious whether you looked at the suggested simplified interface to HTTP.Network on haskell-cafe the other day
06:49:51 <bringert> chessguy: not in detail, but it looked pretty good
06:50:35 <chessguy> yes, i think with a simple patch to its redirection-handling, it could be a nice bolt-on patch
07:03:44 <paolino> how happens that print put the "" on the screen and \n instead of going neline ?
07:04:33 <dcoutts> paolino, because show for strings adds " chars and escapes special chars
07:04:48 <dcoutts> to print it straight to the terminal rather than using show, use putStr
07:05:07 <dcoutts> > show "foo"
07:05:14 <lambdabot>  "\"foo\""
07:05:26 <dcoutts> > "foo\nbar"
07:05:27 <lambdabot>  "foo\nbar"
07:06:00 <njd> ?hoogle Int -> [a] -> [[a]]
07:06:01 <lambdabot> No matches, try a more general search
07:06:03 <paolino> ok so print = putStr.show
07:06:10 <bd_> print = putStrLn . show
07:06:14 <dcoutts> paolino, exactly
07:06:23 <dcoutts> the 'show' function produces exactly the same as how you write strings in Haskell source code.
07:06:27 <bd_> ?src print
07:06:27 <lambdabot> print x = putStrLn (show x)
07:06:42 <njd> ?hoogle [a] -> [[a]]
07:06:43 <lambdabot> List.inits :: [a] -> [[a]]
07:06:43 <lambdabot> List.tails :: [a] -> [[a]]
07:06:43 <lambdabot> List.group :: Eq a => [a] -> [[a]]
07:08:52 <huschi> @type replicate
07:08:54 <lambdabot> forall a. Int -> a -> [a]
07:09:01 <huschi> njd: what about this?
07:09:48 <bakert> I've got a Network.NewCGI noddy little program that reads a load of values from the querystring.  I do this with var <- getInput "name".
07:09:57 <bakert> Is there anyway to do lots of these in one line?
07:10:19 <bakert> Some kind of map of getInput over list of names but also taking them out of the monad at the same time?
07:10:22 <bakert> sequence???
07:10:36 <bakert> ?paste
07:10:36 <lambdabot> http://hpaste.org (Haskell pastebin)
07:11:18 <Saizan> mapM?
07:11:23 <Saizan> ?type mapM
07:11:24 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:11:32 <hpaste>  bakert pasted "getInput mapping" at http://hpaste.ath.cx:8000/51
07:12:15 <bakert> (VERY nice new pastebin but why the long redirect at the beginning?)
07:12:18 <Saizan> yeah you can use mapM
07:12:29 <bakert> mapM eh.
07:13:11 <Saizan> do { [cmd, ts, ... ] <- mapM getInput ["cmd", "ts", ...] } -- like this, or any other similar way
07:13:43 <bakert> wicked.  Thanks Saizan.  i know all my programs can be reduced to only one tenth the size if only I can learn all these crazy functions.
07:13:49 <hpaste>  (anonymous) annotated "getInput mapping" with "(no title)" at http://hpaste.ath.cx:8000/51#1
07:13:53 <bakert> oops
07:13:55 <bakert> ignore that
07:14:28 <Saizan> a useful trick is to think of the type of what you need and then ask hoogle
07:14:41 <Saizan> ?hoogle (a -> m b) -> [a] -> m [b]
07:14:41 <lambdabot> No matches, try a more general search
07:14:50 <Saizan> ?hoogle (Monad m) => (a -> m b) -> [a] -> m [b]
07:14:50 <lambdabot> No matches, try a more general search
07:14:54 <Saizan> nah
07:15:04 <Saizan> just ask in channel :D
07:15:08 <bakert> oop.  i have actually done that before and it worked quite well
07:15:17 <bakert> haven't written any haskell for a few days and i forgot the trick.
07:15:31 <bakert> ALWAYS think about type signatures!
07:16:03 <bakert> thanks for your help
07:16:43 <Saizan> :)
07:16:48 <mux> @seen dmhouse
07:16:48 <lambdabot> I haven't seen dmhouse.
07:18:59 <chessguy> ?src mapM
07:19:00 <lambdabot> mapM f as = sequence (map f as)
07:19:20 <Botje> ?src replicateM
07:19:20 <lambdabot> replicateM n x = sequence (replicate n x)
07:19:25 <Botje> duh.
07:23:42 <paolino> type L a b = State  a  b
07:23:43 <paolino> type F a b = WriterT [String] (L a b)
07:23:43 <paolino> this gives a kind error, how can I define F ?
07:24:46 <emu> @kind WriterT
07:24:47 <lambdabot> * -> (* -> *) -> * -> *
07:25:03 <Saizan> @kind State
07:25:04 <lambdabot> * -> * -> *
07:25:36 <paolino> it wants a section of L
07:25:36 <sjanssen> paolino: type F a b = WriteT [String] (L a) b
07:26:19 <paolino> sjanssen: can you put superfluos parens there ?
07:27:02 <sjanssen> paolino: sure, you could put more parens in there
07:27:27 <paolino> type F a b = (WriteT [String] (L a)) b ?
07:27:31 <sjanssen> ((WriterT [String]) (L a)) b -- is exactly the same
07:28:26 <paolino> ok, at least strange , it works without
07:28:54 <sjanssen> paolino: do you understand what was wrong with your first attempt?
07:29:35 <paolino> more or less
07:29:58 <sjanssen> okay, good
07:30:12 <paolino> :)
07:31:47 <paolino> shame it doesn't compile
07:33:46 <paolino>     Type synonym `L' should have 2 arguments, but has been given 1
07:33:47 <paolino>     In the type synonym declaration for `F'
07:35:11 <sjanssen> oh that's right, you're not supposed to partially apply type synonyms
07:35:43 <bd_> (\b -> L a b) <-- shame this doesn't work, or does it?
07:36:09 <paolino> uh, this is a big flaw
07:36:44 <bd_> use State rather than L :)
07:36:54 <paolino> I have to export internals of my type synonym to make it be wrappable
07:36:55 <Igloo> Type inference becomes undecidable if you allow it
07:37:19 <bd_> paolino: type S = State Foo ?
07:37:23 <sjanssen> Igloo: oh, I hadn't heard that before
07:37:26 <bd_> I *think* that works
07:37:27 <sjanssen> very interesting
07:37:52 <Igloo> sjanssen: It's possible I'm mistaken, but I believe that's the reason
07:37:59 <bd_> hmm, I suppose it'd make the typesystem equivalent to typed lambda calculus, wouldn't it?
07:39:22 <paolino> ah, bd_ that's the way :D
07:46:23 <njd9> ?hoogle getCPUTime
07:46:24 <lambdabot> CPUTime.getCPUTime :: IO Integer
07:46:42 <njd9> ?doc getCPUTime
07:46:42 <lambdabot> getCPUTime not available
07:47:05 <dons> ?docs System.CPUTime
07:47:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-CPUTime.html
07:47:12 <dons> ?source System.CPUTime
07:47:12 <lambdabot> http://darcs.haskell.org/packages/base/System/CPUTime.hs
07:47:20 <njd9> dons: thanks
07:48:21 <dcoutts> @localtime dons
07:48:23 <lambdabot> Local time for dons is Wed Jan 24 02:45:02 2007
07:49:13 <dcoutts> dons, but you were up at 7am!
07:49:38 <mux> dons lives in a floating time zone
07:49:47 <mux> or something
07:49:58 <Igloo> Sleep is for Java weenies
07:50:47 <cjeris> java >>= return o (flip (-) 1)
07:51:02 <MarcWebe1> GHC documentation says that when creating libraries and registering them with ghc-pkg you also need a .o file if you want to use that library with ghci. How do you create a single o file from different .c/.hs files?
07:51:33 <Igloo> You don't need a single one
07:52:03 <Igloo> Oh, for making a package, sorry
07:52:13 <Igloo> The simplest way is to use cabal to build the package
07:52:44 <Igloo> And give the --enable-library-for-ghci flag to configure
07:53:39 <Igloo> dons: Any idea if http://hackage.haskell.org/trac/ghc/ticket/487 was with a registerised GHC?
07:53:41 <lambdabot> Title: #487 (powerpc/linux segfaulting binaries) - GHC - Trac
07:53:43 <chessguy> i don't understand this idiom: let (a, bs) = f b in ...
07:53:50 <chessguy> i've seen this a lot of times, but i don't get it
07:54:02 <Igloo> chessguy: I'm not sure what you don't get?
07:54:07 <bos> @remember bakert  i know all my programs can be reduced to only one tenth the size if only I can learn all these crazy functions.
07:54:08 <lambdabot> Done memoising quote for `bakert', if that is their real name...
07:54:13 <chessguy> what gets bound to a and bs?
07:54:33 <bos> a -> the first element of the tuple returned by (f b)
07:54:37 <bos> bs -> second element
07:54:38 <Igloo> f b has type (x, y)
07:54:56 <Igloo> a has type x and bs has type y
07:55:06 <glguy> morning everyone
07:55:07 <MarcWebe1> Igloo: You are right, I've found it, too. There is the ghc flag --auto-ghci-libs which uses ld to create a single .o file.
07:55:11 <dcoutts> Igloo, --enable-library-for-ghci is the default
07:55:25 <Igloo> dcoutts: Hmm, in 6.6?
07:55:30 <chessguy> then what does this have to do with the in block?
07:55:31 <Saizan> morning glguy
07:55:37 <dcoutts> Igloo, that's a cabal flag
07:55:41 <glguy> so hpaste.org works now, eh?
07:55:52 <glguy> ?seen shapr
07:55:53 <lambdabot> shapr is in #scannedinavian and #haskell. I last heard shapr speak 1h 16m 27s ago.
07:55:53 <Igloo> chessguy: a and bs are bound in that block only
07:56:02 <dcoutts> Igloo, it's always been the default. There's very little reason to turn it off.
07:56:02 <bringert> syns detta?
07:56:03 <Igloo> dcoutts: Sure, but for the cabal that comes with GHC 6.6?
07:56:07 <bringert> oops
07:56:07 <chessguy> specifically, i'm looking at this code:
07:56:07 <chessguy> -- | Build a tree from a seed value
07:56:08 <chessguy> unfoldTree :: (b -> (a, [b])) -> b -> Tree a
07:56:08 <chessguy> unfoldTree f b = let (a, bs) = f b in Node a (unfoldForest f bs)
07:56:32 <Igloo> I didn't think I was turning things on redundantly, but maybe I was
07:56:50 <chessguy> how would you use this?
07:56:51 <dcoutts> Igloo, if it's not the default then someone's changed it and it needs fixing to be the default again.
07:57:10 <shapr> glguy: You screamt?
07:57:10 <chessguy> ?hoogle b->(a,[b])
07:57:10 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
07:57:11 <lambdabot> List.mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
07:57:11 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:57:45 <glguy> shapr: do you think it would make sense for hpaste.org to redirect to hpaste.org:8000 ?
07:59:15 <glguy> shapr: or do you prefer the publicity? :-D
07:59:22 <shapr> I don't mind either way.
07:59:42 <shapr> Whatever is best for the users.
07:59:55 <dcoutts> glguy, why not just serve on port 80 ?
08:00:01 <Saizan> glguy: do you think that whole clickable rows in the root page would be nice? i've a patch in case
08:00:06 <shapr> I'm running my blog on 80 :-)
08:00:16 <glguy> Saizan: how did you do it?
08:00:17 <shapr> Though .. why not proxy it?
08:00:25 <dcoutts> shapr, but http can do virtual servers
08:00:26 <glguy> shapr: proxy is fine by me
08:00:43 <shapr> Ok, I'll set that up later today.
08:00:50 <dcoutts> shapr, the client says the host name it thinks it's talking to and the server produces the appropriate site.
08:00:57 <Saizan> glguy: with <tr onclick="location.href='/n'" ..
08:01:22 <glguy> oh, sure
08:01:25 <shapr> dcoutts: Yeah, that's setup so that hpaste.org redirects to www.scannedinavian.com/hpaste and that meta refreshes to :8000
08:01:33 <bos> glguy: hpaste.org is resolving correctly now.
08:01:34 <shapr> But a 302 would be faster.
08:01:43 <shapr> and a proxy would be fastest
08:01:47 <dcoutts> shapr, can HappS do virtual server stuff?
08:01:50 <bos> i can set up whatever you need.
08:01:52 <glguy> bos: that was the first thing I checked when I turned my computer on
08:01:56 <bos> :-)
08:02:01 <shapr> I don't know.
08:02:11 <glguy> shapr: I think that a proxy solution is best
08:02:16 <glguy> keeps the 8000 out of the urls
08:02:19 <shapr> yeah
08:02:33 <shapr> And some corporate users can't access stuff away from 80 or :8080
08:02:40 <Saizan> glguy: also added a css rule to make the rows highlight a bit on hover, it suggest the clickability (i hope)
08:02:54 <glguy> Saizan: I'd accept such a patch
08:03:13 <Saizan> k
08:03:43 <dcoutts> shapr, the downside of using a http virtual server setup would be that it'd be the same HappS instance that'd need to server hpaste and your blog which is probably not what you want.
08:04:13 <glguy> Saizan: I'm behind a bad firewall here :(
08:04:20 <Saizan> mmh
08:04:42 <glguy> I should add a patch drop box
08:04:45 <glguy> to hpaste
08:04:50 <Saizan> mail/hpaste?:D
08:04:54 <glguy> mail
08:05:27 <chessguy> ?instances Functor
08:05:28 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:05:32 <Saizan> i should use a darcs send compatible mail client..
08:05:56 <george> can haskell deal with imaginary numbers?
08:06:04 <glguy> > 9 :+ 8
08:06:04 <sjanssen> george: yes
08:06:05 <lambdabot>  9.0 :+ 8.0
08:06:08 <sjanssen> @hoogle Data.Complex
08:06:09 <lambdabot> No matches, try a more general search
08:06:12 <mux> you mean complex numbers?
08:06:17 <george> yes i dl
08:06:19 <george> do*
08:06:30 <mux> so yeah, as people have been saying =)
08:06:33 <sjanssen> @docs Data.Complex
08:06:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
08:06:45 <mux> :t (:+)
08:06:46 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
08:07:29 <sehute> What's the main advantages of Haskell compared to Scheme?
08:07:41 <george> > :+ 1 1
08:07:41 <lambdabot>  Parse error
08:07:42 <pejo> sehute, the type system.
08:07:54 <george> > (:+) 1 1
08:07:55 <pejo> sehute, or laziness.
08:07:55 <lambdabot>  1.0 :+ 1.0
08:07:59 <syntaxfree> sehute: laziness.
08:08:04 <pejo> sehute, or the syntax.
08:08:04 <Spark> > (fn x => x) (fn x => x)
08:08:05 <lambdabot>  Parse error
08:08:14 <george> > (:+) 1 1 * (:+) 3 5
08:08:15 <lambdabot>  (-2.0) :+ 8.0
08:08:25 <syntaxfree> sehute: the syntax is more expressive also, believe it or not.
08:08:31 <sehute> I see, syntax, type-system and laziness :)
08:08:32 <mux> > sqrt (-1)
08:08:33 <lambdabot>  NaN
08:08:37 <kowey> stubborn orchid
08:08:43 <syntaxfree> (you can later do metaprogramming with ASTs with template haskell)
08:08:44 <mux> > imgPart (sqrt (-1))
08:08:45 <lambdabot>   Not in scope: `imgPart'
08:08:54 <mux> > Data.Complex.imgPart (sqrt (-1))
08:08:54 <lambdabot>   Not in scope: `Data.Complex.imgPart'
08:08:55 <syntaxfree> @vote cheeky-off Yes
08:08:56 <lambdabot> voted on "Yes"
08:09:03 <syntaxfree> @poll cheeky-off
08:09:03 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
08:09:03 <mux> > Data.Complex.imagPart (sqrt (-1))
08:09:05 <lambdabot>  1.0
08:09:07 <chessguy> there's also monads
08:09:08 <mux> ah.
08:09:10 <mux> that's it
08:09:11 <syntaxfree> @poll-results cheeky-off
08:09:11 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=0, Yes=11
08:09:18 <syntaxfree> monads, yes, monads.
08:09:18 <mux> > Data.Complex.realPart (sqrt (-1))
08:09:20 <lambdabot>  -0.0
08:09:20 <syntaxfree> and comonads.
08:09:23 <syntaxfree> ;)
08:09:39 <chessguy> there's a lot of advantages to haskell :)
08:10:03 <syntaxfree> sehute: Scheme is very smart, but Haskell is more up-to-date with the developments of the last two decades.
08:10:13 <Saizan> don't forget lambdabot!
08:10:26 <chessguy> yes, and #haskell is no small advantage
08:10:29 <syntaxfree> Scheme pretty much stopped evolving. Haskell is a moving target, ever smarter.
08:10:42 <syntaxfree> ah,  yes. We also have the nicest community of any programming language.
08:10:50 * mux concurs
08:10:52 <mux> that's so true
08:10:53 <sehute> syntaxfree: but is that a good thing ("moving target")?
08:10:56 <chessguy> if we do say so ourselves :)
08:10:58 <ClaudiusMaximus> does scheme have list comprehensions?
08:11:05 <syntaxfree> Chock-full of Very Smart People with PhDs or close to getting theirs, and yet humble.
08:11:06 <Spark> > (\x -> x) (\x -> x)
08:11:07 <lambdabot>  Add a type signature
08:11:08 <sehute> syntaxfree: that is true. I've got a very good impression of the Haskell community in general
08:11:17 <Nafai> Now if I could just learn enough Haskell do so something useful with it
08:11:40 <bd_> sehute: Haskell is a moving target, but bits don't tend to fall off too often, so you don't have to chase it to keep up :)
08:12:00 <syntaxfree> I should say Haskell is a growing target.
08:12:03 <bd_> to put it less metaphorically, most of the extensions people add are backwards-compatible
08:12:14 <mux> I can't even conceive using a functional language without monads nowadays
08:12:18 <mux> it's way too convenient
08:12:20 <syntaxfree> Haskell will n ever stop evolving!
08:12:22 <syntaxfree> Ruuun..
08:12:37 <syntaxfree> liiive to flyyyy... flyyy to liiiiive ... for all tiiime ... aaacees hiiiiiiiiiiiiiiiigh...
08:12:42 <sehute> Well, my impression of Haskell is very good. I even used it at work once, but now I'm learning Scheme, so I was just curious about the viewpoints. :-) So far, I like Haskell better.
08:12:52 * syntaxfree slaps himself
08:13:08 <syntaxfree> sehute: Scheme's only advantage over Haskell is homoiconicity.
08:13:19 <sehute> syntaxfree: I don't even know what that means
08:13:31 <syntaxfree> Ah, the syntax of the language is an object in the language itself.
08:13:34 <sehute> syntaxfree: something about equality
08:13:47 <syntaxfree> So, um, meta-programming in Scheme is very natural.
08:13:53 <pejo> syntaxfree, that's not a very objective statement. Scheme has its advantages.
08:13:53 <glguy> Saizan: Your plain text patches never work :)
08:14:02 <sehute> syntaxfree: yeah, that struck me as a good thing about Scheme as well
08:14:07 <glguy> Saizan: could you gzip it or something?
08:14:10 <syntaxfree> in Haskell, we have Template Haskell, with which you can manipulate an abstract syntax tree, but that's not nearly as natural.
08:14:26 <Saizan> glguy: sure
08:14:41 <glguy> OH
08:14:44 <glguy> i got it to work
08:15:04 <syntaxfree> well, Scheme could also be easier to learn as it's not pure.
08:15:13 <sehute> Hey, I found this program at Sourceforge named Hybrid Share, but I have nobody to try it out with. It's for sharing files. Anyone care to try? Just sharing a random file?
08:15:15 <syntaxfree> But purity yields huge, huge ROI.
08:15:39 <sehute> syntaxfree: aom. Purity and ROI. Must. Follow. Buzzwords.
08:15:45 <mux> ROI?
08:15:50 <syntaxfree> return over investment.
08:15:53 <mux> thanks
08:15:53 <sehute> mux: return of investment
08:16:23 <glguy> Saizan: (in case you missed the lines not addressed to you) don't worry about the gz patch
08:16:24 <earthy> return on investment?
08:16:37 <syntaxfree> I think it's over.
08:16:42 <syntaxfree> it's really "return / investment".
08:17:13 <Saizan> glguy: ooh, how?
08:17:27 <sehute> http://www.google.com/search?q=define%3Aroi
08:17:27 <lambdabot> Title: define:roi - Google Search
08:17:31 <glguy> Saizan: opened "show original" in gmail
08:18:00 <pejo> @google define:roi
08:18:01 <syntaxfree> @google define:roi
08:18:02 <lambdabot> No Result Found.
08:18:02 <Saizan> :)
08:18:03 <lambdabot> No Result Found.
08:18:04 * earthy grins
08:18:59 <sehute> The most common definition that googles define:roi found was "Return on investment"
08:19:11 <syntaxfree> so be it.
08:19:19 <syntaxfree> so it shall be written.
08:19:21 <syntaxfree> so it shall be done.
08:19:24 <sehute> @google define:"working advanced search"
08:19:25 <lambdabot> No Result Found.
08:19:27 <mux> I'll write it ROI
08:19:36 <mux> so that I'm sure it's correct :-P
08:20:06 <syntaxfree> @google 50 BRL in US$
08:20:07 <lambdabot> 50 Brazil reais = 23.4301781 US$
08:20:37 <sehute> @google (+ 1 2 3)
08:20:38 <lambdabot> http://en.wikipedia.org/wiki/Lotus_1-2-3
08:20:45 <sehute> > (+ 1 2 3)
08:20:46 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
08:20:51 <syntaxfree> @. elite google 1 mole in unitis
08:20:53 <lambdabot> |-|T+p://En.wIkipedi4.0RG/WIxi/AtOmIC_/\/\A$5_uNI+ tITLE: a7O/\/\i( m4s$ uNI7 - WIxIPedi4, tHE fr3e encYc1opEDi4
08:20:56 <emu> #haskell, not #scheme
08:20:56 * shapr curses evil i18n approaches
08:21:03 <sehute> Ahrg! I'm destroyed by Scheme! ;)
08:21:09 <syntaxfree> @. elite google 1 mol in units
08:21:10 <lambdabot> 1 M0lE = 6.0221415 X 10^23 unit$
08:21:27 <syntaxfree> @eval 2+2
08:21:29 <shapr> @. elite quote
08:21:29 <lambdabot> 5UDO SAys: y0u spEAk AN INfiNite dEA1 0F nOTHiNg
08:21:35 <emu> @yow
08:21:36 <lambdabot> ... I want to perform cranial activities with Tuesday Weld!!
08:21:44 <syntaxfree> @. elite . quote . yow
08:21:45 <lambdabot> no QUo7Es ph0R +|-|I$ P3RSon. $T7Y: UNKNowN MODE: dOoFuS
08:21:51 <sehute> @. elite > "hello world"
08:21:51 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ">"
08:22:09 <sehute> hm
08:22:17 <chessguy> @elite "hello world"
08:22:17 <lambdabot> "H3|L0 \/\/Or1d"
08:22:19 <syntaxfree> @. elite . quote . yow
08:22:19 <lambdabot> no QuOTE5 phOr 7Hi$ PerSon. TAkE 4 $+reSS pi11 AND T|-|INK 7hIng5 0veR.
08:22:26 <syntaxfree> @quote
08:22:26 <lambdabot> kilimanjaroglguy: says: Maybe shapr will make you a historical landmark and you will get your own preservation society!
08:22:27 <glguy> Saizan: your patch is live
08:22:42 <syntaxfree> @quote scheme
08:22:42 <lambdabot> sieni says: scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
08:22:51 <sehute> @. swedish-chef . quote
08:22:51 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "swedish-chef"
08:22:53 <syntaxfree> huh?
08:22:55 <Saizan> !paste
08:22:55 <hpaste> Haskell paste bin: http://hpaste.org:8000/
08:23:02 <emu> @google TIMTOBFTTWTDI
08:23:03 <lambdabot> http://tunes.org/~nef/logs/haskell/06.11.23
08:23:12 <syntaxfree> @. bork quote
08:23:12 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "bork"
08:23:24 <syntaxfree> @. tell dons . quote
08:23:24 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "dons"
08:23:25 <Saizan> glguy: yay, do you like it?
08:23:25 <sehute> no borking for us
08:23:38 <glguy> Saizan: I think it's very helpful
08:23:52 <glguy> Saizan: we might need to use a less subtle highlight color though ;)
08:24:00 <glguy> I didn't notice it was highlighting at first
08:24:10 <syntaxfree> @quote scheme
08:24:11 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
08:24:15 <bakert> Does anyone know how to send a flag through ghc-options in cabal conditionally?  That is, only on one machine but not on another?
08:24:40 <glguy> If evilranter didn't like scheme's naming convention... I wonder what he thought of CL's
08:24:42 <Saizan> well, i'm no graphic designer, just trying to not be intrusive :D
08:25:09 <glguy> Saizan: I'm not either, so I'll wait for someone else to change it before I worry about it
08:25:11 <syntaxfree> @quote scheme
08:25:11 <lambdabot> ghc says: Cannot unify a type variable with a type scheme
08:25:18 <syntaxfree> @quote scheme
08:25:18 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
08:25:25 <syntaxfree> @quote lisp
08:25:26 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
08:25:35 <syntaxfree> @quote lisp
08:25:35 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
08:25:45 <kaol> @quote emacs
08:25:45 <lambdabot> augustss says: I have to use Windows, but inside emacs you don't notice much
08:25:53 <syntaxfree> @quote lisp
08:25:53 <lambdabot> qwe1234 says: sometimes i think lisp is as deadly to programmer competence as java or basic.
08:25:59 <syntaxfree> @quote lisp
08:25:59 <lambdabot> qwe1234 says: lisp is a wannabe python from the seventies.
08:26:03 <syntaxfree> bah.
08:26:10 <syntaxfree> @quote programmer
08:26:11 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write, it should be hard to understand
08:26:32 <kaol> @quote syntax
08:26:32 <lambdabot> ndm says: the only language i've seen which is ugly at a deeper level than syntax is perl
08:26:48 <mux> "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
08:26:51 <mux> hahaha
08:27:13 <syntaxfree> @remember mux "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
08:27:13 <lambdabot> Done memoising quote for `mux', if that is their real name...
08:27:16 * mux hearts wikipedia for the nice quote of Alan Kay
08:27:21 <syntaxfree> @quote mux
08:27:21 <lambdabot> mux says: "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
08:27:29 <syntaxfree> @quote king
08:27:29 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
08:27:29 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
08:27:37 <bakert> ?src mapM
08:27:37 <lambdabot> mapM f as = sequence (map f as)
08:27:47 <bakert> ?src sequence
08:27:47 <lambdabot> sequence ms = foldr k (return []) ms
08:27:47 <lambdabot>     where
08:27:47 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
08:28:02 <bakert> :t sequence
08:28:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:30:13 <syntaxfree> I wish I had a larger monitor.
08:30:19 <shapr> so go buy one!
08:31:02 <Nafai> Morning shapr!
08:31:04 * syntaxfree grabs his pockets and pokes around looking for a five-hundred-dollar bill, to no avail.
08:31:14 <syntaxfree> @google 0.75 BRL in US$
08:31:15 <lambdabot> 0.75 Brazil reais = 0.351452671 US$
08:31:22 <syntaxfree> that's what I found in my pockets.
08:31:43 <shapr> Save up some money! You know that ludicrous monitor size is the cheapest way to improve programmer productivity, yeah?
08:31:49 <shapr> hiya Nafai, how's code?
08:32:00 <syntaxfree> I don't make any money.
08:32:17 <syntaxfree> except in exam week, when crazy undergrads will pay anything for a couple of hours of my time.
08:32:29 <syntaxfree> I've already squandered the money from october though
08:32:47 <Nafai> shapr: Okay!  Did you see my example that I pasted last night that I wished I could have done in haskell?
08:32:53 <shapr> No, I didn't.
08:33:07 <bakert> ?undo [cmd, ts, ttype, desc, code, usr, amount, who] <- mapM getInput
08:33:08 <bakert>     ["cmd", "ts", "ttype", "desc", "code", "usr" , "amount", "who"]
08:33:08 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 48}) "Parse error"
08:33:23 <bakert>     [cmd, ts, ttype, desc, code, usr, amount, who] <- mapM getInput
08:33:23 <bakert>     ["cmd", "ts", "ttype", "desc", "code", "usr" , "amount", "who"]
08:33:31 <syntaxfree> maybe I should blackmail shapr into buying me a larger monitor.
08:33:43 <syntaxfree> buy me a large monitor or I type @get-shapr!
08:34:07 <shapr> If I had enough money for a ludicrous monitor... I'd have one!
08:34:22 <chessguy> oh, what kind of day and age do we live in, where passers-by can type "@get-shapr" at will??
08:34:34 <shapr> hah!
08:34:38 <shapr> NI!
08:34:43 <chessguy> NU!
08:34:54 <shapr> Nafai: I just saw your example. I think you can do that in Haskell :-)
08:35:25 <Nafai> How ugly would it be? :)
08:35:52 <chessguy> Nafai, paste?
08:36:04 <shapr> chessguy: http://www.pastebin.ca/325357
08:36:07 <shapr> Nafai: Not too bad.
08:37:01 <Nafai> Really?
08:39:08 <shapr> Nafai: Yeah, you could make it quite pretty in fact. And it'd probably take fewer lines in Haskell. But I'm hacking ZPTs at the moment, and so cannot offer assistance.
08:39:12 <syntaxfree> @get-shapr
08:39:12 <lambdabot> shapr!!
08:39:15 <shapr> aiee!
08:39:20 <syntaxfree> buy me a larger monitor!
08:39:20 * shapr throws himself at syntaxfree!
08:39:31 <shapr> I can't even afford one for myself!
08:39:38 <syntaxfree> Gah, a 20" would be ok with me.
08:39:46 <shapr> I don't have a 20" monitor.
08:39:55 * syntaxfree has a measly 17"
08:40:02 <shapr> I have a 19"
08:40:08 <syntaxfree> aaaagh.
08:40:25 <Nafai> shapr: Well I'm hacking on Jython + Geronimo, etc right now :)
08:40:30 <shapr> @google 200 USD in BRL
08:40:30 <lambdabot> 200 U.S. dollars = 426.8 Brazil reais
08:40:32 <Nafai> But I'd like some guidance when we both have time :)
08:40:36 <shapr> ok
08:40:47 <syntaxfree> @google 200 USD in meters
08:40:50 <lambdabot> http://www.skywatches.com.sg/watches/index.php?cPath=48
08:40:50 <lambdabot> Title: SkyWatches.com.sg
08:40:57 <shapr> syntaxfree: This 19" cost me $200, you can afford that!
08:41:03 <syntaxfree> can I?
08:41:26 <Igloo> @get-wibble
08:41:26 <lambdabot> Unknown command, try @list
08:42:32 <shapr> I'm just about to implement something worthy of thedailywtf... I need to call different SQL queries according to the language the client has selected, so I'm putting the SQL query names into my i18n layer. Is that sickening or what?
08:43:01 * shapr posts to alt.tasteless.code
08:43:07 <bakert> shapr, not pretty.
08:43:25 <syntaxfree> do you prefer 1024 x 768 or 1280 x 960?
08:43:27 <shapr> Sadly, I can't think up a prettier solution.
08:43:36 <bakert> 1920x1200 is NOT enough!
08:43:45 <shapr> syntaxfree: I use 1440x900
08:43:49 <sjanssen> syntaxfree: the higher the better
08:43:58 <sjanssen> you can always turn up the font size
08:43:59 <syntaxfree> I normally use 1280.
08:44:06 <syntaxfree> I found a 1570 x 870 mode here.
08:44:13 <syntaxfree> I'm trying it as an alternative.
08:44:16 <syntaxfree> I like computing from afar.
08:44:56 <kolmodin> try a window manager that helps you order your windows, then you can do with a smaller screen
08:45:11 * shapr wants to try wmii
08:45:13 <syntaxfree> I would use ion, if I wasn't on OS X.
08:45:26 <syntaxfree> OS X has Zoom.
08:45:27 <kolmodin> shapr: try dwm, it's similar to wmii
08:45:31 <syntaxfree> That helps a lot when computing from afar.
08:45:39 <pejo> I'm on 15" with OS X, it works great even for a longtime twm user like me.
08:45:53 <syntaxfree> command-option-+, and you can move across the screen with the mouse.
08:46:02 <syntaxfree> it's great for watching full-screen videos when there's no option too.
08:46:30 <syntaxfree> really this wireless keyboard/nouse kit is one of the best things I ever bought :)
08:46:56 <kolmodin> shapr: similar to larswm, ion etc, but very easy to use. you can get started right away
08:47:05 <kolmodin> I fell in love with it in 0.2 sec
08:47:28 <shapr> Ok, I'll try it later today.
08:47:40 <kolmodin> it's dons that recommended it to me
08:48:24 <syntaxfree> sjannsen: not all font sizes are adjustable, and even when they are it often screws up layouts into unusability.
08:48:34 <syntaxfree> (and I'm not talking about web pages either.)
08:53:34 <chessguy> it's really unnerving to us newbies to see discussions like "IO is not a monad" in -cafe right now that argue that haskell is really broken
08:54:14 <psnl> ?hoogle [[a]]->[a]
08:54:15 <lambdabot> Prelude.concat :: [[a]] -> [a]
08:54:53 <syntaxfree> IO is not a monad?
08:54:54 <syntaxfree> Hahahahaa
08:56:08 <sehute> ah, twm, my first wm-love
08:56:10 <albino> shapr: Hey, how many lines do you think you can get Nafai's script down to?  I'm just curious.
08:56:21 <sehute> I configured it perfectly, then I abandoned it for Ctwm
08:56:23 <sehute> The Fvwm
08:56:27 <sehute> Ah, Fvwm, what a joy
08:56:34 <Lemmih> musasabi: ping.
08:56:36 <sehute> *Then Fvwm
08:56:51 * chessguy places his bet on about 20 or so
08:57:44 <sehute> So, what's the easiest way to get started with fullscreen 2d-graphics in Haskell?
08:59:17 <musasabi> Lemmih: poin
08:59:45 <musasabi> shapr: I am using wmii, it is quite nice.
08:59:47 <shapr> albino: I don't know exactly, but some immediate differences are that return lines are not needed in Haskell, and loops and nested if/elifs usually become maps or other traversals. Also, one liner functions tend to become anonymous functions.
09:00:30 <Lemmih> musasabi: 'unsafeIOToEv' looks exactly like what I want. How do I get it? It's exported by a hidden module.
09:01:10 <musasabi> Lemmih: do you need it outside HAppS? iirc unsafeSTMToEv is exported and the standard libs have IO->STM.
09:01:39 <shapr> albino: Also, things like the 'action' will probably become an algebraic datatype, and the sort of switching that happens in the edit_and_review_post def will become pattern matching. That'll save more lines. You'll end up closer to a pure finite state machine.
09:02:44 <sehute> I have a mock-up of the GUI for a program for installing, running and uninstalling games under Linux, that could be cool to make with Haskell, but I don't know where to start. I'm ready to share it with Hybrid Share, if anyone's ready to give it a go. :-)
09:03:09 <sehute> (Just because I really want to find out if Hybrid Share actually works (it's open source, for mono))
09:03:13 <shapr> sehute: Grab the gtk2hs tutorial and go for it!
09:03:21 <sehute> shapr: thanks :)
09:03:22 <ohmega> hi shapr :)
09:03:59 <shapr> hej ohmega!
09:04:33 <dcoutts> sehute, you use glade for your mockup?
09:04:58 <shapr> sehute: If you have a good idea and you start working towards it, you almost always end up somewhere worthwhile, whether or not you reach the goal you originally had in mind.
09:05:18 <sehute> dcoutts: no, paintbrush, but I'm proud of it still ;) I'm at a laptop that's not my own
09:05:46 <Lemmih> musasabi: unsafeSTMToEv isn't exported.
09:06:17 <shapr> albino: The popen and scp parts will probably be a bit longer in Haskell, but I think everything will be shorter.
09:06:19 <sehute> Glade is okay, but it was really unstable when I tried it a year or two back
09:06:25 <shapr> else*
09:06:28 <dcoutts> sehute, nothing wrong with a mockup like that :-). Check out the Gtk2Hs glade tutorial and have a go at converting your mockup to a Glade one. Try Glade 3.1.x too.
09:06:30 <sehute> It was stable until the design got too involved
09:06:31 <malebria> > let length_ x = length $ show x;
09:06:32 <lambdabot>  Parse error
09:06:43 <albino> shapr: I'm excited to see the result of your efforts.
09:06:51 <malebria> @type (\x -> length $ show x)
09:06:52 <lambdabot> forall a. (Show a) => a -> Int
09:07:02 <malebria> @type length . show
09:07:03 <lambdabot> forall a. (Show a) => a -> Int
09:07:05 <albino> shapr: I've noticed that the further from shell you go the worse that popen stuff gets
09:07:06 <shapr> albino: Why don't you try it?
09:07:13 <dcoutts> sehute, oh, stability. Well there's glade 2.x which should be pretty stable, and then there's glade 3.x which is much nicer but probably less stable at this point.
09:07:18 <albino> shapr: In python, it's still not as nice as in bash
09:07:22 <sehute> dcoutts: I've actually got Glade installed, I'll think I'll convert it. But, a search for "gtk2hs tutorial" didn't give any obvious search-results. Any ideas?
09:07:27 <albino> shapr: Because I don't know a lick of haskell
09:07:34 <shapr> albino: I can point you to a nice tutorial.
09:07:35 <dcoutts> sehute, check the Gtk2Hs web site
09:07:40 <dcoutts> @where gtk2hs
09:07:40 <lambdabot> http://haskell.org/gtk2hs/
09:07:44 <sehute> tnx
09:07:53 <dcoutts> http://haskell.org/gtk2hs/documentation/#tutorials
09:07:58 <albino> shapr: And I'm sure that will be enough for me to rewrite it :)
09:08:07 <shapr> albino: Thing is, I have two different contracts to work on, one in Python and one in Haskell, so I'm a bit busy :-)
09:08:29 <mux> glade3 is really nice
09:08:35 <mux> it generates a proper xml file
09:08:39 <shapr> albino: If you do the pure parts and skip the scp and popen, I think you can do the rest after one day of looking at the Haskell tutorial.
09:08:40 <albino> shapr: Oh well you don't have it so bad then.  I have got contracts to write Javascript and Java.  So count your blessings.
09:09:01 <shapr> I like JavaScript, prototype oriented languages are nifty.
09:09:16 <albino> oof, not a fan of the prototype chain
09:09:18 <mux> I hate JavaScript closures :-(
09:09:38 <albino> and NaN drives me insane!
09:09:38 <mux> for some reason they seem to be "lazy" somehow
09:09:53 <shapr> I think prototype is better than object. It seems to me that the dual hierarchy of class and instance is a mental waste of space.
09:10:12 <malebria> I'm trying to do in GHCi:
09:10:24 <malebria> I mean, ghci -Wall
09:10:32 <shapr> albino: Have you tried other nifty stuff like stack based languages? PostScript or Joy?
09:10:41 <albino> shapr: Have you seen that argument played out online somewhere?  I would be interested in reading it.
09:10:43 <malebria> let length_ = length . show
09:10:45 <malebria> It sais:
09:10:50 <albino> shapr: Just Factor.  But very little.
09:10:55 <malebria> Warning: Defaulting the following constraint(s) to type `Integer'
09:11:03 <malebria> `Show a' arising from use of `show' at <interactive>:1:23-26
09:11:19 <sehute> shapr: Where do you work? That sounded like a perfecft combination. :-)
09:11:22 <shapr> albino: No, I haven't seen anybody write about that specific point except for me.
09:11:29 <malebria> Then :type length_
09:11:38 <malebria> length_ :: Integer -> Int
09:11:40 <shapr> sehute: I'm self employed, but I'm contracting for people in NYC and Erlangen.
09:11:53 <sehute> shapr: Do you need any more programmers? ;)
09:11:58 <albino> shapr: Have you written about it in a more detailed form somewhere?
09:12:05 <malebria> Why doesn't it keeps Show a => a -> Int ?
09:12:19 <shapr> sehute: If you can produce quality Haskell code in a short amount of time, send me a resume and links to sample code.
09:12:27 <bd_> malebria: monomorphism restriction
09:12:40 <Jaak> @type length . show
09:12:41 <lambdabot> forall a. (Show a) => a -> Int
09:12:42 <sjanssen> malebria: monomorphism restriction + numeric defaulting
09:12:44 <bd_> malebria: constants are resolved to a single type by default
09:12:55 <bd_> malebria: add a type signature to force it to be polymorphic
09:13:05 <sehute> shapr: I don't have the balls to be in #haskell and say that I can write quality Haskell code - people are too clever here. :-)
09:13:17 <malebria> bd_: is this a GHCi let policy or a GHC?
09:13:25 <bd_> malebria: It's a haskell 98 policy :)
09:13:31 <paolino> h98
09:13:35 <malsyned> what does (# this syntax #) mean?
09:13:41 <bd_> malebria: you can override it globally in GHC or GHCi by passing -fno-monomorphism-restriction
09:13:56 <shapr> sehute: I feel the same way.
09:14:11 <bakert> Is it me or is it really fun to write a function of type IO ([Either String Transaction]) -- where transaction is just a type of mine.  Haskell glee!
09:14:12 <malebria> hum...
09:14:17 <bd_> malebria: unboxed tuples; a GHC extension. A very fast way to return a tuple from a function but with all sorts of weird restrictions, so they're generally only used deep in GHC's internals
09:14:18 <kosmikus> malsyned: unboxed tuples
09:14:21 <bd_> er
09:14:24 <bd_> malsyned*
09:14:42 <bd_> bakert: tsk, why's that in IO? :)
09:14:54 <malsyned> yeah, deep in GHC's internals is where I ran into it - I was looking at IOBase.hs
09:14:58 <bakert> bd_, because it gets the details from a database.
09:15:01 <malebria> I'm trying to write the function in a .hs file now, and getting a compilation error instead of a warning.
09:15:16 <Igloo> malebria: You need -fglasgow-exts if you want to use unboxed tuples
09:15:17 <bd_> malebria: -fglasgow-exts
09:15:32 <bd_> malebria: or take off the # #
09:15:38 <Igloo> malebria: But you shouldn't use them without good reason - the optimiser should handle it for you
09:15:45 <Jaak> @type let l = length . show; foo = l (undefined :: Integer) in l
09:15:47 <lambdabot> Integer -> Int
09:15:47 <malebria> I'm not talking about unboxed tuples..
09:15:53 <malebria> I think it's malsyned
09:15:57 <bd_> oh XD
09:16:02 <malsyned> yeah, check your tab completions, guys :-P
09:16:21 <bd_> how confusing. At least have the decency to have nicks of different length :)
09:16:21 <kosmikus> malebria: the defaulting? ghci does more defaulting than Haskell does usually. provide a type signature for the function in question.
09:16:31 <Igloo> Oh, i was just replying to who someone else replied to I think  :-)
09:16:49 <malsyned> I was just curious about what the notation meant.  What makes a tuple "unboxed"?
09:17:12 <malebria> But why is it different when I do length_ x = length $ show x?
09:17:16 <bd_> malsyned: "boxed" means there's a heap value containing whatever your datatype is
09:17:24 <kosmikus> malsyned: there's no indirection for the tuple constructor, the values are just concatenated in memory
09:17:32 <malebria> I'll use ghc instead of ghci.
09:17:35 <bd_> malsyned: so for example a boxed int is a machine integer represented by a pointer to the int in the heap
09:18:06 <bd_> malsyned: an unboxed type is passed around as just the value itself - this means among other things that it cannot be the bottom
09:18:16 <bd_> [implying that it's strict]
09:18:22 <malsyned> I get it.  an unboxed tuple is essentially a C struct?
09:18:31 <bd_> pretty much
09:18:36 <bd_> but there are limitations
09:18:42 <bd_> for example, they can't be the argument to a function
09:18:45 <bd_> only the return value
09:19:22 <malsyned> I'm seeing it used as a pattern in a case statement.  isn't that analogous to being a function argument?
09:19:23 <malebria> I still can't get it very much.
09:19:26 <malebria> In ghc I get no problem.
09:19:46 <malebria> Only the Definition but no type signature warning.
09:19:50 <bd_> malsyned: nope, you can do something like case f x -> (# x', y' #), that's fine
09:20:07 <bd_> err, case f x of (# x', y' #) -> ... even
09:20:21 <malsyned> right, that second notation is what I'm seeing.
09:20:52 <malsyned> it's just that you can't have a function with a type signature like (#,#) -> a ?
09:20:57 <bd_> right
09:21:02 <malsyned> cool.  thanks.
09:21:22 <bd_> You might not be able to bind a variable with type (# x, y #) either
09:21:38 <bd_> the basic idea is, once you return from the function call, you /immediately/ deconstruct the tuple
09:21:51 <chessguy_lunch> @pl evaluate x = maximise . maptree static . prune 5 . x
09:21:52 <lambdabot> evaluate = ((maximise . maptree static . prune 5) .)
09:22:38 <Axioplase> @hoogle prune
09:22:39 <lambdabot> No matches found
09:23:00 <chessguy> Axioplase, http://www.math.chalmers.se/~rjmh/Papers/whyfp.pdf
09:23:08 <malsyned> what's the @pl operation do?  rewrite the function in point-free style?
09:23:14 <mux> yep
09:23:20 <chessguy> malsyned, yes
09:23:37 <malsyned> sweet
09:23:43 <chessguy> @unpl evaluate = ((maximise . maptree static . prune 5) .)
09:23:43 <lambdabot> evaluate a j = maximise (maptree static (prune 5 (a j)))
09:23:53 <bd_> sometimes it can be unhelpful though :)
09:24:14 <malebria> There's no problem in GHC because I added a main function.
09:24:20 <bd_> @pl returnIf v r = guard v >> return r
09:24:20 <lambdabot> returnIf = (. return) . (>>) . guard
09:24:52 <bd_> malebria: how are you entering the type signature in ghci?
09:25:07 <Axioplase> bd_:  foo :: Int  ?
09:25:11 <malebria> bd_: I'm not adding the type signature. I have a error.hs file with: length_ = length . show
09:25:20 <malebria> bd_: And I try to load it with ghci and I got:
09:25:35 <malebria> !paste
09:25:35 <hpaste> Haskell paste bin: http://hpaste.org:8000/
09:25:39 <ToRA> any lambdabot code experts around?
09:25:41 <bd_> malebria: you need to either provide a type signature, or give it enough information to infer the type, or pass -fno-monomorphism-restriction
09:26:01 <hpaste>  malebria pasted "ghci error" at http://hpaste.org:8000/52
09:26:18 <bd_> yep
09:26:24 <bd_> it gives you the answer right there :)
09:26:34 <malebria> bd_: but doen't it has enough information?
09:26:43 <malebria> @type (length . show)
09:26:44 <lambdabot> forall a. (Show a) => a -> Int
09:27:00 <bd_> malebria: you've not used length_ at all; it assumes (due to the monomorphism restriction) that length_ :: a -> Int for some /particular/ a
09:27:05 <bd_> but it can't figure out which a that is
09:27:11 <malebria> And I got no problem when I change from length . show to length_ x = length $ show x
09:27:13 <bd_> you need to tell it to let a be polymorphic
09:27:30 <bd_> yes, it's weird; functions defined with that kind of pattern binding will become polymorphic
09:27:47 <bd_> whereas if you do length_ = \x -> length $ show x, or length_ = length . show, it'll trigger the monomorphism restriction
09:27:55 <malebria> Why?
09:28:08 <malebria> This sounds nonsense to me.
09:28:34 <bd_> Not sure :)
09:28:38 <bd_> I guess it's for cases like:
09:28:40 <bd_> foo = 42
09:28:44 <bd_> well, maybe not
09:28:59 <malebria> Strange..
09:29:31 <malebria> Does anyone knows the motivation of monomorphism restrition?
09:29:36 <bd_> http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/decls.html section 4.5.5
09:29:38 <paolino> anyone can explain how to use ContT to break this loop on a condition ?
09:29:38 <paolino> evolution = do
09:29:38 <paolino>   evolve'
09:29:38 <paolino>   lift get >>= tell.return
09:29:38 <paolino>   evolution
09:29:39 <lambdabot> Title: The Haskell 98 Report: Declarations, http://tinyurl.com/2zlgmy
09:29:42 <malsyned> malebria: I've been told "efficiency"
09:29:49 <bd_> malebria: motivation is in the report :)
09:32:20 <chessguy> paolino, mind if i ask what you're working on?
09:32:43 <chessguy> oh, you were the one playing with conway's life, weren't you?
09:32:48 <bd_> paolino: evolution = callCC $ \cc -> do [...] when condition (cc ())
09:32:57 <njd9> @seen dons
09:32:57 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 1h 45m 45s ago.
09:33:05 <bd_> paolino: and of course flip runContT id to kick the whole thing off
09:33:16 <bd_> s/()/somethign else/ if you have a meaningful return value
09:33:31 <malsyned> Is there a standard idiom for building test code into individual modules in Haskell, similar to putting code inside an "if __name__ == '__main__':" block in Python?
09:33:40 <bd_> malsyned: QuickCheck declarations?
09:33:55 <malsyned> bd_: what's that?
09:33:58 <bd_> properties, rather
09:34:18 <bd_> malsyned: quickcheck is a way of verifying that some condition holds true for a large number of (random) input values
09:34:26 <bd_> for example, to test distribution of . over map:
09:34:47 <bd_> @quick \f g l -> (map (f . g) l :: [Int]) == (map f $ map g l)
09:34:47 <lambdabot> Not enough privileges
09:34:51 <bd_> ... aw
09:34:54 <bd_> @check \f g l -> (map (f . g) l :: [Int]) == (map f $ map g l)
09:34:54 <njd9> @seen igloo
09:34:55 <lambdabot>  Add a type signature
09:34:55 <lambdabot> igloo is in #darcs, #ghc, #haskell.hac07 and #haskell. I last heard igloo speak 18m 23s ago.
09:35:08 <bd_> @quick \f g l -> (map ((f :: Int -> Int) . g) l :: [Int]) == (map f $ map g l)
09:35:08 <lambdabot> Not enough privileges
09:35:15 <bd_> @check \f g l -> (map ((f :: Int -> Int) . g) l :: [Int]) == (map f $ map g l)
09:35:15 <lambdabot>  Add a type signature
09:35:19 <bd_> -_-
09:35:23 <malebria> bd_: I got the motivation for the pattern thing, (Reason 2 of motivation for rule 1), but I can't get why a function binding is required.
09:35:35 <bd_> @check \f g l -> (map (f . (g :: Int -> Int)) l :: [Int]) == (map f $ map g l)
09:35:38 <lambdabot>  OK, passed 500 tests.
09:35:40 <malsyned> oh, nah, not like that.  Not anything so rigorous.
09:35:41 <bd_> there we go
09:35:54 <bd_> malsyned: but it's easy to make it rigorous :)
09:35:55 <paolino> chessguy, playing with cell concepts , better
09:36:11 <bd_> malebria: function bindings make it clearer that you're doing another computation I guess
09:36:28 <bd_> let x = f v <-- there's only one x, but there might be more than one f; but only one of those fs will be selected
09:36:31 <malsyned> My hacky plan was to say #ifdef TESTING module Main where #else module MyModule where #endif.
09:36:41 <LoganCapaldo> malsyned, the equivalent to if __name__ == '__main__' would be main = ...
09:37:08 <chessguy> paolino, cell concepts?
09:37:14 <LoganCapaldo> nvm
09:37:29 <malsyned> LoganCapaldo: Not entirely true.  @main@ is only a special identifier in the Main module.  ghc will refuse to compile any other module name into a final binary, won't it?
09:37:31 <malebria> bd_: how could it have more than one f?
09:37:53 <bd_> malebria: f x = length $ show f <--- f :: Int -> Int is not the same function as f :: String -> Int
09:38:22 <LoganCapaldo> malsyned, well of course its not _exactly_ the same, :)
09:38:32 <bd_> there's one definition from which both are created... but two functions with different domains can hardly be the same, right? :)
09:38:33 <malebria> bd_: aren't the both f :: Show a => a -> Int
09:38:34 <malebria> ?
09:38:42 <LoganCapaldo> I thought you were askinga different question anyway :)
09:38:48 <malebria> they
09:38:53 <bd_> malebria: no, that's the type of the polymorphic variable f, it has to be resolved to some particular f at some point :)
09:39:15 <malsyned> no problem.  I'll come back and pester you guys more later.  Thanks for the help.  AFK.
09:39:27 <malebria> bd_: yes, but shouldn't this be done only when it get specific enough?
09:39:39 <bd_> malebria: conceptually, you could rename all the fs to, eg, f_Int, f_String, etc, all at compile time, and it'd work. it might be bloated code-size-wise, but...
09:40:09 <bd_> malebria: well, the motivation, I think is that if you do (f x, f x), you know you might be evaluating it twice. while let v = f x in (v, v) seems to imply you only want to evaluate once
09:40:09 <malebria> I mean, the whole point is why f x = length $ show x is different from f = (\x -> length $ show x)
09:40:30 <bd_> and that's because f is a constant there :)
09:40:35 <bd_> it's weird and ugly, yeah
09:41:21 <bd_> but it's difficult to improve it without having weird performance impacts or confusing people or making the spec extremely complex. And, you can always add a type signature to override/.
09:41:43 <sehute> wonderful ppl! See you around. Bye
09:42:02 <malebria> bd_: you could rename the names in the function calls, not in the definition.
09:42:07 <bd_> malebria: eh?
09:42:19 <bd_> malebria: the renaming doesn't happen to the user, though the compiler may do it at some level
09:42:21 <malebria> bd_: about f_Int f_String
09:42:23 <bd_> or well
09:42:40 <bd_> right, the compiler internally can specialize f to f_Int :: Int -> Int, etc.
09:42:41 <malebria> Yes, but the compiler won't do it at the definition, just at the uses.
09:42:54 <bd_> malebria: It can do it at the definition if it thinks it'll be helpful :)
09:42:57 <bd_> faster that way.
09:43:04 <paolino> bd_: something along this line ?
09:43:05 <paolino> evolution cond = callCC breakable where
09:43:05 <paolino>   breakable exit = do
09:43:05 <paolino>      evolve'
09:43:05 <paolino>      lift get >>= tell.return
09:43:05 <paolino>      if gets cond then exit
09:43:06 <paolino>      evolution
09:43:07 <bd_> there's a pragma to force it too
09:43:27 <bd_> paolino: exit needs to be passed the return value of the function
09:43:31 <bd_> exit () or something
09:43:47 <malebria> But where does it make a difference if I've written f x = ... or f = (\x -> ... ?
09:43:54 <chessguy> @hoogle [a] -> Bool
09:43:55 <lambdabot> Prelude.null :: [a] -> Bool
09:43:55 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
09:43:55 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
09:43:57 <paolino> ah ,right and I miss a lift
09:44:02 <malebria> In this (f x, f x) issue I don't thing that there's a relation.
09:44:06 <chessguy> ?src null
09:44:06 <lambdabot> null []     = True
09:44:06 <lambdabot> null (_:_)  = False
09:44:08 <malebria> I can't see the relation.
09:44:09 <bd_> malebria: That's just what the spec says. It's a trade-off, for the reasons outlines in the spec :/
09:44:29 <malebria> hum..
09:44:36 <chessguy> hmm, couldn't that be written null [] = True; null _ = False
09:44:48 <bd_> malebria: Anything else ("Okay, it's monomorphic UNLESS it's a lambda UNLESS that lambda is wrapped in another function UNLESS it's composition OR it's top-level ...") would be an ugly hack too :)
09:45:02 <bd_> arguably uglier
09:45:11 <bd_> anyway, I must go afk now :)
09:46:02 <malebria> bd_: ok, thanks!
09:46:26 <malebria> bd_: I was trying to read more things on the report, but I think this is just not clear enough there.
09:49:00 <paolino> :t runContT
09:49:02 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
09:49:42 <paolino> :t runCont
09:49:44 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
09:53:11 <glguy> !paste
09:53:12 <hpaste> Haskell paste bin: http://hpaste.org:8000/
09:53:21 <paolino> :t flip runContT id
09:53:23 <lambdabot> forall r (m :: * -> *). ContT r m (m r) -> m r
09:54:03 <glguy> ?fptools Data.ByteString
09:54:03 <lambdabot> Data.ByteString not available
09:54:11 <glguy> ?fptools Data.Char
09:54:11 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
09:54:26 <paolino> :t flip runCont id
09:54:28 <lambdabot> forall a. Cont a a -> a
09:54:40 <glguy> :t flip runContT return
09:54:41 <lambdabot> forall a (m :: * -> *). (Monad m) => ContT a m a -> m a
09:54:46 <paolino> ah
09:54:48 <paolino> :)
09:55:48 <chessguy> hmm, is there an existing data structure in haskell where, say, a maps to b, and b maps to a, and accessing a from b or b from a is constant time?
09:56:28 <apfelmus> chessguy: no. but you can take a pair of Maps
09:56:40 <glguy> Maps have O(log n) lookup
09:57:15 <paolino> glguy , I need the computation result,  but I get ()
09:57:18 <chessguy> what about updates?
09:57:44 <glguy> paolino: then your computation isn't returning a result ;)
09:57:47 <glguy> paolino: where is your code
09:57:51 <paolino> right
09:57:53 <apfelmus> chessguy: you simply update both?
09:57:53 <chessguy> ?hoogle Map
09:57:54 <lambdabot> Data.Map :: module
09:57:54 <lambdabot> Data.Map.Map :: data Map k a
09:57:54 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:58:05 <paolino> evolution cond = callCC breakable where
09:58:05 <paolino>   breakable exit = do
09:58:05 <paolino>      evolve'
09:58:05 <paolino>      --lift get >>= tell.return
09:58:05 <paolino>      cond' <- gets cond
09:58:05 <paolino>      when cond' $ exit ()
09:58:07 <paolino>      evolution cond
09:58:12 <paolino> that exit ()
09:58:16 <chessguy> apfelmus, yeah, i'm not familiar with maps, are updates constant time?
09:58:27 <twanvl> Also O(log(n))
09:58:28 <glguy> paolino: use a pastebin plz
09:58:35 <chessguy> ok
09:58:37 <glguy> http://hpaste.ath.cx:8000
09:59:03 <dpiponi> main.hs:50:18: My brain just exploded
09:59:07 <dpiponi> Nice error message!
09:59:10 <apfelmus> chessguy: constant time is not natural for a functional language. it's an artifact of our underlying RAM machines
09:59:21 <chessguy> uh
09:59:35 <chessguy> how do you figure?
09:59:50 <apfelmus> what time does it take to add two integers? O(1) or O(log n) ?
09:59:52 <chessguy> e.g., getting an item from a list is clearly O(n) time
10:00:14 <chessguy> it's assumed to be O(1)
10:00:28 <apfelmus> then NP = P
10:00:40 <chessguy> huh?
10:00:41 <glguy> HURRAY!
10:01:24 <Z4rd0Z> I'm trying to install hdbc-odbc, and everything builds, but ConnectionImpl.hi doesn't get installed.  Anyone know why that might happen?
10:01:25 <chessguy> in any algorithm, addition of two numbers is assumed to be 1
10:01:29 <apfelmus> the point is that the cost model for RAM machines is skewed. two add two integers of size n, you have to perform O(log n) operations because they have log n digits
10:01:30 <chessguy> O(1)
10:01:48 <apfelmus> *to add
10:01:53 <hpaste>  paolino pasted "(no title)" at http://hpaste.org:8000/53
10:01:59 <chessguy> big-Oh notation isn't meant to be that precise
10:02:13 <glguy> ?
10:02:16 <chessguy> it's just a way of talking in general about the classes of efficiency of algorithms
10:02:20 <Lemmih> Z4rd0Z: The author might have forgotten to add it to the cabal file.
10:02:23 <apfelmus> sure it is. adding to Integers is O(log n).
10:02:34 <glguy> in the size of the integer :)
10:02:51 <apfelmus> yeah, i need to say what n is :)
10:02:53 <paolino> glguy, it should spit out a list
10:03:19 <Z4rd0Z> Lemmih: so true
10:03:21 <chessguy> in getting an item from a list, you could potentially have to look at every item of the list, thus it's O(n) in the size of the list. whereas accessing an entry of an array is O(1) because it's just a lookup
10:03:29 <glguy> paolino: what is that function's type?
10:03:35 <chessguy> i don't know why you feel the need to make it any more complex than that
10:04:06 <glguy> paolino: also, you keep creating new current continuations
10:04:17 <glguy> paolino: your exit won't break all the way out
10:04:20 * apfelmus got a phone call
10:04:37 <paolino> ahi
10:05:36 <chessguy> in defining data types, do they have to be non-ambiguous?
10:05:55 <hpaste>  glguy annotated "(no title)" with "how about this?" at http://hpaste.org:8000/53#1
10:05:57 <sjanssen> chessguy: huh?
10:05:59 <Z4rd0Z> this doesn't look healthy: Loading package HDBC-odbc-1.0.1.1 ... linking ... <interactive>: /usr/local/ghc//lib/HDBC-odbc-1.0.1.1/ghc-6.6/HSHDBC-odbc-1.0.1.1.o: unknown symbol `HDBCzmodbczm1zi0zi1zi1_DatabaseziHDBCziODBCziConnectionImpl_Connection_con_info'
10:06:00 <Z4rd0Z> ghc-6.6: unable to load package `HDBC-odbc-1.0.1.1'
10:06:28 <chessguy> hang on, let me give an example
10:06:39 <sjanssen> Z4rd0Z: does it compile with ghc rather than ghci?
10:06:52 <Z4rd0Z> I'll try that
10:07:07 <glguy> paolino: are you looking for an excuse to use ContT?
10:07:29 <paolino> yes
10:07:59 <chessguy> Data Piece = SlidingPiece [Square] | NonSlidingPiece [Square] | BishopMover [Square] | RookMover [Square]
10:08:16 <chessguy> Data SlidingPiece = Queen | Bishop | Rook
10:08:26 <chessguy> BishopMover = Queen | Bishop
10:08:29 <chessguy> something like that
10:08:52 * glguy lunch
10:09:02 <Z4rd0Z> sjanssen: no, it doesn't compile with ghc
10:09:40 <sjanssen> chessguy: you can't overlap constructors like that
10:09:46 <chessguy> darn
10:10:21 <chessguy> is there a better way to refactor something like that?
10:10:40 <chessguy> so that i can do moves (BishopMover squares) = ...
10:10:55 <sjanssen> chessguy: I'd say keep the data Piece, and then have isSliding, isBishopMoving :: Piece -> Bool
10:11:24 <chessguy> meh, an extra level of indirection
10:11:30 <sjanssen> chessguy: and then data Piece should enumerate all the different pieces
10:12:04 <sjanssen> oh, you want each piece to hold the squares that it could move to?
10:12:29 <chessguy> no, squares would be a list of the squares that contain a bishop
10:12:41 <sjanssen> ah
10:13:04 <chessguy> mmm, SPJ's view patterns would come in handy here
10:13:26 <chessguy> with your refactoring
10:14:00 <sjanssen> standard guards are fine
10:14:12 <sjanssen> moves p | isBishopMover p = ...
10:14:22 <chessguy> well, yeah
10:15:37 <chessguy> it's also possible to assign pieceType integers so that i can do if pieceType & BishopMoverBitPattern ...
10:15:52 <chessguy> etc.
10:17:21 <glguy> isn't optimization something you do *after* program works?
10:17:30 <chessguy> yeah, there is that too
10:18:43 <chessguy> that's hard to do in chess programming though. i'm used to optimization being everything
10:20:20 <glguy> if you are going to write a bit-board representation
10:20:22 <glguy> then do tha
10:20:23 <glguy> t
10:20:42 <chessguy> meh, then i may as well write it in C
10:20:56 <glguy> well... if you are going to do integers and bit masks...
10:21:14 <glguy> you already might as well write it in C
10:21:20 <chessguy> that's why i said, you're right.
10:21:24 <bd_> Hmm, do unboxed arrays of booleans use bitmasks?
10:21:37 <dcoutts> bd_, yes
10:21:39 <bd_> also, that's micro-optimization, get the algorithm right first :)
10:21:58 <bd_> chessguy: hm, so, DiffUArray (Int, Int) Bool :)
10:22:19 <chessguy> DiffUArray?
10:22:26 <bd_> Differential unboxed arrays
10:22:33 <chessguy> what are you talking about?
10:22:47 <dcoutts> glguy, actually one can do bit sequence stuff in functional languages quite nicely and declaratively, it's just a matter of implementation / libs. There's a lovely PADL paper on how they do it in Erlang.
10:22:50 <bd_> they're pure arrays with O(1) lookup and update for the latest version, where older versions are successively less efficient
10:23:13 <bd_> chessguy: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
10:23:15 <lambdabot> http://tinyurl.com/274glu
10:24:15 <chessguy> i think i'll start with a simple implementation :)
10:24:48 <bd_> these are simple ;)
10:26:03 <chessguy> not if you don't have a clue what they are
10:26:18 <bd_> they're just like Data.Array, but faster
10:26:22 <bd_> [in most cases]
10:26:25 <chessguy> i've never used Data.Array
10:26:43 <apfelmus> chessguy: i'm back. array lookup in O(1) is an artifact. to lookup position n, you have to inspect the log n digits, after all.
10:27:08 <apfelmus> the rule of thumb is to just stick with Data.Map in Haskell
10:27:13 <chessguy> nobody talks about algorithms to that precision
10:27:30 <Saizan> inspect log n digits?
10:27:47 <sjanssen> apfelmus: no, you do not have to inspect log n digits
10:28:06 <sjanssen> the size of a word is constant on any given platform, so it is O(1)
10:28:13 <apfelmus> how that? please lookup 01001*** ?
10:28:34 <sjanssen> apfelmus: you are confusing your n's
10:29:08 <chessguy> he's just being anal-retentive
10:29:40 <sjanssen> you are also confusing the abstract machine that computer scientists consider when making O declarations with the real machines that we all use
10:29:53 <apfelmus> what i want to say is that the constant word size is the artifact
10:30:03 <sjanssen> the abstract machine has Theta(1) array lookups
10:31:14 <apfelmus> yes.
10:32:44 <Saizan> however when you say inspect log n digits, n is not the length of the array right? and it's an hardware operation i suppose
10:34:00 <apfelmus> yes. i should say that you have to inspect log j digits where j <= n is the position in the array. actually, the hardware inspects those log j = 32 (or 64) digits
10:34:15 <sjanssen> Saizan: on a mythical machine that has variable sized words, n would be somehow related to the length of the array
10:34:20 <bd_> To borrow someone else's explanation, you are in a ball of solid ram. How long does it take you to contact a cell in there?
10:35:03 <Saizan> aah it's the not-instant-memory issue
10:35:06 <apfelmus> bd_: O (log (size of the ball))
10:35:11 <apfelmus> ?
10:35:22 <bd_> r ~ V ^ 1/3
10:35:27 <bd_> O(r) :)
10:35:31 <malsyned> it this because you have to do a multiplication and an addition to the index to get the address , whose size in bits has an upper bound of log n?
10:36:33 <Saizan> well i would say that if you have a Map, first you need O(n) just to find the address, and then you need the same O(r) to fetch it from memory..
10:36:42 <sjanssen> malsyned: you have to at least look at all the digits to know which index to look up
10:37:12 <malsyned> sjanssen: right.  of course.  oops.
10:37:36 <sjanssen> so O(log n) may or may not be correct.  We should say Omega(n)
10:37:48 <chessguy> but still, everyone knows what we mean when we say that array access takes constant time
10:38:05 <apfelmus> sjanssen: for n the number of digits (?)
10:38:07 <chessguy> and list element access takes O(n)
10:38:12 <sjanssen> s/Omega(n)/Omega(log n)
10:38:59 * vincenz votes for gpling research
10:39:12 <apfelmus> chessguy: sure. but with hash tables, this distinction becomes important
10:39:30 <chessguy> i'm not talking about hash tables
10:39:56 <chessguy> nobody has said anything about hash tables
10:40:21 * cjeris votes for breaking Reed Elsevier on the wheel
10:40:56 <hpaste>  Adam pasted "Test" at http://hpaste.org:8000/55
10:41:04 <Saizan> apfelmus: O(1) in hashtables is misleading because you have agglomeration, not because a loadword has to lookup the data given the address imho
10:41:36 <apfelmus> yes, sorry. but i think it's the same problem
10:42:57 <apfelmus> wait, no, the agglomeration of data at a bucket is just an additional annoyance.
10:43:10 <apfelmus> it's the hash function that is not O(1)
10:43:18 <abz> ?hoogle map
10:43:18 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
10:43:19 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
10:43:19 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
10:43:37 <hpaste> now 75% more valid xhtml output
10:43:50 <Saizan> ah, right, it depends on the length of the key
10:43:53 <abz> ?doc Control.Arrow
10:43:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
10:44:32 <apfelmus> for array lookup, it's kind of the same.
10:45:19 <hpaste> also with 100% error free CSS
10:45:39 <Saizan> what was invalid?
10:45:47 <glguy> the CSS was always valid
10:46:06 <glguy> someone refactored the xhtml output and put the <link> tag outside
10:46:09 <glguy> of the <head> tag
10:46:25 <glguy> and there were some form elements without id attributes
10:46:33 <glguy> that were referenced by <labels>
10:46:40 <Saizan> ah
10:48:30 <glguy> !lcs now.performed in.one.pass
10:48:31 <hpaste>  +i n -o -w . -p -e -r -f o -r -m +n e -d +. +p +a +s +s
10:49:20 <paolino> type S a = State a
10:49:20 <paolino> type W a = WriterT [String] (S a)
10:49:20 <paolino> type C a  = ContT (S a)
10:49:29 <vincenz> paolino: not possible
10:49:35 <paolino> C a is wrong
10:49:41 <vincenz> all of them are
10:49:44 <vincenz> you need a newtype
10:49:50 <paolino> no
10:49:54 <vincenz> newtype S a = S (State a)
10:50:04 <paolino> first two compiles
10:50:09 <vincenz> o.O
10:50:12 <glguy> ew, why do that?
10:50:27 <vincenz> paolino: that's odd, it should not compile
10:50:30 <glguy> just make one: newtype MyStack a b c = ThatT a ThisT b....
10:50:40 <vincenz> what glguy said
10:50:43 <glguy> deriving (Monad)
10:50:46 <paolino> to sign with a simpler formula
10:51:07 <vincenz> !lcs ab
10:51:07 <hpaste>  -a -b
10:51:09 <vincenz> !lcs abc
10:51:10 <hpaste>  -a -b -c
10:51:14 <vincenz> !lcs abci
10:51:14 <hpaste>  -a -b -c -i
10:51:19 <vincenz> !lcs abci.a
10:51:19 <hpaste>  -a -b -c -i -. -a
10:51:22 <vincenz> hmm
10:51:29 <vincenz> @help lcs
10:51:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:51:32 <glguy> paolino: I can write a simpler type decl with better error messages using newtype than you can with type synonyms
10:51:32 <vincenz> !help lcs
10:51:34 <malsyned> What package is used to generate the library documentation HTML on haskell.org?
10:51:37 <glguy> vincenz: word1 word2
10:51:44 <sjanssen> malsyned: haddock
10:51:50 <vincenz> glguy: ah, thanks
10:51:55 <vincenz> !lcs aabc aac
10:51:55 <hpaste>  a a -b c
10:51:57 <sjanssen> @where haddock
10:51:57 <vincenz> !lcs aabc aacb
10:51:57 <lambdabot> http://www.haskell.org/haddock/
10:51:57 <hpaste>  a a -b c +b
10:52:02 <glguy> !lcs synonym antonym
10:52:02 <hpaste>  -s -y +a n +t o n y m
10:52:26 <vincenz> !lcs aabcb aacbc
10:52:26 <hpaste>  a a -b c b +c
10:52:27 <paolino> glguy ,ok, but I want to know what's wrong with C a  also
10:52:41 <vincenz> glguy: I didn't know you could do type synonyms for partially defined types
10:52:47 <Saizan> @kind ConT
10:52:48 <lambdabot> Not in scope: type constructor or class `ConT'
10:52:50 <glguy> vincenz: me neither
10:52:57 <vincenz> afaik that was illegal
10:53:00 <apfelmus> @kind ContT
10:53:02 <lambdabot> * -> (* -> *) -> * -> *
10:53:20 <apfelmus> @info ContT
10:53:20 <lambdabot> ContT
10:53:25 <paolino> @kind WriterT
10:53:27 <vincenz> ContT something monad
10:53:27 <lambdabot> * -> (* -> *) -> * -> *
10:53:30 <glguy> ContT earlyReturnType Monad resultType
10:54:39 <paolino> so is ConT a (S a)
10:55:01 <glguy> ContT a (State b) c
10:56:11 <vincenz> glguy: no, gotta leave off the c
10:56:16 <vincenz> ContT a (State b)
10:56:22 <vincenz> and then apply it to the c at the correct place
10:56:25 <glguy> oh, i see what you are trying to do
10:56:55 <paolino> what do you mean with earlyReturnType exactly ?
10:58:28 <paolino> type C a  = ContT a (W a)
10:58:37 <paolino> this should be my type
10:59:02 <paolino> how do I run it ?
10:59:28 * SamB wonders what to do about reduce/reduce conflicts
11:00:21 <paolino> type C a  = ContT a (Writer [Float] a)
11:00:35 <glguy> flip runContT return
11:00:47 <vincenz> SamB: rewrite your grammar :)
11:00:57 <SamB> vincenz: hmm.
11:01:21 <paolino> type C a  = ContT a (WriterT [Float] (S a))
11:01:30 <SamB> !paste
11:01:30 <hpaste> Haskell paste bin: http://hpaste.org:8000/
11:01:46 <glguy> ?type flip runContT return (tell "test")
11:01:47 <SamB> what is this, URL #4?
11:01:48 <lambdabot> forall (m :: * -> *). (Monad m, MonadWriter [Char] (ContT () m)) => m ()
11:02:06 <glguy> SamB: like any good haskell program
11:02:10 <glguy> SamB: we continue to shorten the url
11:02:17 <glguy> SamB: soon, hpaste.org will work
11:02:21 <glguy> and we'll be done reducing
11:02:30 <glguy> (without the 8000)
11:02:42 <glguy> ?quote lines
11:02:42 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
11:02:49 <SamB> glguy: if only that did something for my reduce/reduce conflict
11:02:56 <glguy> ?quote lines
11:02:56 <lambdabot> Excedrin says: 66016 lines of C is only 2200 lines of Haskell, just rewrite it
11:03:10 <vincenz> glguy: I like the new font and colors
11:03:12 <hpaste>  bakert pasted "Need a sort of map on a record's values." at http://hpaste.org:8000/56
11:03:20 <dcoutts> SamB, what's your grammar for?
11:03:25 <SamB> Self
11:03:25 <bakert> Anyone know what I can do with this baby?
11:03:35 <vincenz> SamB: hmm, @paste it?
11:03:42 <SamB> the whole grammar?
11:03:48 <vincenz> it's that big??
11:03:55 <vincenz> self seems like a pretty 'simple' lang
11:03:57 <bakert> I just apply "fromSql" to a list of values and then plop them into a record.  Is there a neater way?
11:04:02 <SamB> it is like 134 lines right now
11:04:05 <bakert> http://hpaste.org:8000/56
11:04:06 <chessguy> anybody have lambdabot privileges
11:04:18 <vincenz> chessguy: what for?
11:04:18 <dcoutts> @users
11:04:18 <lambdabot> Maximum users seen in #haskell: 317, currently: 315 (99.4%), active: 54 (17.1%)
11:04:20 <paolino> glguy I'm having no success in composing runContT and runWriterT together on that type
11:04:22 <chessguy> mbot seems to be down, would be nice to have LB as a backup
11:04:26 <SamB> well I guess I'll close out of this emacs running under screen...
11:04:28 <vincenz> chessguy: where?
11:04:31 <chessguy> #math
11:04:32 <glguy> paolino: that isn't a writerT
11:04:34 <vincenz> @join #math
11:04:38 <SamB> chessguy: lambdabot doesn't do mathematica though
11:04:41 <glguy> ?type flip runContT return (tell "test")
11:04:42 <lambdabot> forall (m :: * -> *). (Monad m, MonadWriter [Char] (ContT () m)) => m ()
11:04:46 <chessguy> no, but it does some stuff
11:04:51 <vincenz> chessguy: there you go
11:04:55 <chessguy> thanks
11:05:10 <paolino> type S a = State a
11:05:11 <paolino> type W a = WriterT [String] (S a)
11:05:11 <paolino> type C a  = ContT a (W a)
11:05:49 <glguy> ?type flip runContT return (tell "test" >> lift get)
11:05:51 <lambdabot> forall (m :: * -> *) s. (MonadWriter [Char] (ContT s m), MonadState s m) => m s
11:06:12 <glguy> ?type runWriterT $ flip runContT return (tell "test" >> get)
11:06:13 <lambdabot> forall w (m :: * -> *) s. (Monad (WriterT w m), MonadWriter [Char] (ContT s (WriterT w m)), MonadState s (ContT s (WriterT w m))) => m (s, w)
11:06:35 <hpaste>  SamB pasted "Parser.y" at http://hpaste.org:8000/57
11:06:39 <glguy> ?type flip runStateT () $ runWriterT $ flip runContT return (tell "test" >> get)
11:06:40 <lambdabot> forall (m :: * -> *) w s. (Monad (WriterT w (StateT () m)), MonadWriter [Char] (ContT s (WriterT w (StateT () m))), MonadState s (ContT s (WriterT w (StateT () m)))) => m ((s, w), ())
11:06:52 <glguy> ?type flip runState () $ runWriterT $ flip runContT return (tell "test" >> get)
11:06:54 <lambdabot> forall w s. (Monad (WriterT w (State ())), MonadWriter [Char] (ContT s (WriterT w (State ()))), MonadState s (ContT s (WriterT w (State ())))) => ((s, w), ())
11:07:19 <paolino> uhm, strange it's not working in my real code, I recheck it
11:07:27 <Saizan> you can do get because of typeclass magic?
11:07:40 <Saizan> instead of lift get i mean
11:07:43 <glguy> Saizan: yeah, same reason I can do tell
11:07:48 <apfelmus> bakert: basically, you're out of luck.
11:07:52 <Saizan> ah, right
11:07:52 <glguy> Saizan: all the mtl monads have pass through instances
11:07:56 <Igloo> njd9: ?
11:08:14 <SamB> of course, you can't make a general one...
11:08:22 <SamB> (and you wouldn't want it anyway!)
11:08:32 <SamB> well. I don't think you would...
11:08:56 <glguy> ?type flip runStateT () $ runWriterT $ flip runContT return (tell "test" >> get >> liftIO getLine)
11:08:57 <lambdabot> forall (m :: * -> *) w s. (Monad (WriterT w (StateT () m)), MonadWriter [Char] (ContT String (WriterT w (StateT () m))), MonadState s (ContT String (WriterT w (StateT () m))), MonadIO (ContT String (
11:08:57 <lambdabot> WriterT w (StateT () m)))) => m ((String, w), ())
11:08:58 <sjanssen> SamB: it'd be nice if we could write general pass through instances
11:09:14 <SamB> well. okay, yeah, it would
11:09:18 <SamB> I wasn't thinking straight
11:09:44 <sjanssen> right now you have to write O(n^2) instances where n is the different types of monads
11:09:51 <SamB> must remember that newtype != MonadTrans in the future
11:10:20 <SamB> sjanssen: no. O(n*m), where n is the number of types and m is the number of classes
11:10:48 <SamB> the biggest problem being *where to put them*
11:10:57 <sjanssen> SamB: right
11:11:03 <apfelmus> bakert: there is no such thing for Haskell. (you can use heterogenous collections (HList) but I'm unsure whether you really want to)
11:11:06 <glguy> Control.Monad.Instances :)
11:11:18 <sjanssen> instances should always be in one of two places: where the type is defined or where the class is defined
11:11:26 <SamB> the problem with a general instance is, of course, that it could overlap with specific instances
11:12:58 <paolino> ?type execWriterT $ flip runContT return (tell "test" >> get )
11:12:59 <lambdabot> forall w (m :: * -> *) s. (Monad m, Monad (WriterT w m), MonadWriter [Char] (ContT s (WriterT w m)), MonadState s (ContT s (WriterT w m))) => m w
11:14:19 <paolino> !paste
11:14:19 <hpaste> Haskell paste bin: http://hpaste.org:8000/
11:15:43 <hpaste>  paolino pasted "last line is broken" at http://hpaste.org:8000/58
11:16:43 <hpaste>  SamB annotated "Parser.y" with "reduce/reduce conflicts" at http://hpaste.org:8000/57#1
11:17:23 <SamB> vincenz: so are you looking at it?
11:18:07 <glguy> paolino: enet10 isn't a function?
11:18:17 <vincenz> SamB: yes
11:18:30 * glguy doesn't know the language that the comments are written in
11:18:33 <glguy> and doesn't know the error message
11:18:49 <paolino> it's a closure
11:19:12 <glguy> paolino: future reference, mapM_ putStrLn
11:19:16 <monochrom> it's the language of Happy.  similar to yacc.  archaic arcane parser language.
11:19:43 <bakert> apfelmus, thanks
11:19:43 <paolino> it's a valid runner for "execWriterT test" ie
11:19:58 <vincenz> SamB: yeah, badly defined rules
11:20:03 <SamB> vincenz: yeah
11:20:06 <SamB> I know...
11:20:08 <vincenz> quite clear why
11:20:30 <SamB> what can I do without making it look horrible, though?
11:20:32 <glguy> paolino: get is in MonadState
11:20:41 <vincenz> expression = binaryMessage = receiver BinrayMessage
11:20:41 <glguy> paolino: the last functino doesn't mention it
11:20:49 <glguy> paolino: does enet10 take a monad state?
11:20:49 <vincenz> SamB: that infinitely recurses
11:21:02 <paolino> yes
11:21:02 <glguy> paolino: also, "lift get" can be "get"
11:21:08 <vincenz> SamB: I would go with a constructive approach instead of a top-down definition
11:21:15 <vincenz> let me see if I can fix it
11:21:30 <SamB> I wish they would put that in the reference manual...
11:21:32 <paolino> no, it's coming from underground
11:22:15 <glguy> paolino: ContT passes get through to a MonadState
11:22:34 <vincenz> SamB: btw, how can a receiver be empty?
11:22:54 <vincenz> oh, calls on the object you're in? (implicit this?)
11:23:00 <SamB> vincenz: the implicit "self"
11:23:14 <SamB> you know, its only where the language gets its name!
11:24:17 <glguy> paolino: maybe the result of enet10 doesn't have a Show instance
11:24:43 <paolino> glguy enet1 ::   Int -> StateT (Nodes Int) (ReaderT (Env KPath DumbTag) (State System.Random.StdGen)) a -> (a, Nodes Int)
11:25:00 <paolino> it does
11:25:18 <reilly> does anybody know of a hashtable implementation with decent performance?  The target is something on the order of 20m inserts in 12 seconds (2.ghz core duo)
11:25:58 <paolino> glguy you can guess it from logState
11:26:07 <SamB> which rule recurses infinately?
11:26:27 <Lemmih> reilly: Data.Map doesn't cut it?
11:26:27 <monochrom> Somehow hpaste's font is too big :)
11:26:31 <huschi> is it anyhow possible to use cabal not only as a build mechanism for released software but also during development?
11:26:52 <paolino> glguy , without last line, the code runs nicely
11:26:53 <vincenz> SamB: a set of rules
11:27:02 <huschi> as a replacement for make i mean.
11:27:13 <Lemmih> huschi: Yes.
11:27:34 <glguy> paolino: the line above the last one doesn't try to print the full result
11:27:41 <SamB> vincenz: which one, of 14 and 16, is involved?
11:27:46 <glguy> paolino: so if the snd of the result is not showable, it won't compile
11:28:03 <huschi> Lemmih: i've got a little tool and after doing Setup.lhs build it resides in an ugly directory.
11:28:37 <paolino> which is ?
11:28:50 <reilly> Lemmih: Data.HashTable is off by orders of magnitude.  I was looking for a hashtable, not a tree.
11:29:15 <Lemmih> reilly: Any reason a tree wouldn't do?
11:29:22 <vincenz> SamB: your main issue is that you do not define a way into which reduce multiple binary operators
11:29:38 <vincenz> SamB: your language is descriptive in an AST way, not constructive in a parse weay
11:29:39 <huschi> and that's ugly. is there a way to do it better?
11:29:42 <Lemmih> huschi: You could install it in ./bin or link the binary to .
11:29:55 <vincenz> SamB: so:  a + b + c  could be (a+b) +c or a+(b+c)
11:30:02 <paolino> glguy I cannot figure out the output
11:30:04 <vincenz> SamB: and that's where you get the reduce conflicts
11:30:10 <huschi> but the trick with the link is not available under windows.
11:30:27 <Lemmih> huschi: Then install it to ./bin
11:30:30 <paolino> of execWriterT
11:30:31 <huschi> ok.
11:30:32 * allbery_b looks at the parser spec and shudders a bit
11:30:41 <SamB> "a + b + c" should parse as "(a + b) + c"
11:30:47 <allbery_b> yeh, that description is just a bit off.
11:30:55 <huschi> thx. i hoped the would be a special mode for development or something similar.
11:30:56 <vincenz> SamB: that's not defined in your spec
11:31:06 <vincenz> but I get it now
11:31:16 <vincenz> SamB: wwhat about "a+b*c"
11:31:23 <paolino> should be a list of Float
11:31:35 <allbery_b> the problem.  having seen an operator, is it a continuation of the expression, or is it the start of a binarySend?
11:31:54 <SamB> according to the reference manual, "a + b - c" shouldn't parse...
11:32:07 <SamB> or anything with mixed operators
11:32:11 <reilly> Lemmih: I was looking for O(1) lookup time
11:32:17 <vincenz> SamB: got a fix
11:32:22 <allbery_b> perl5 hs a case like this which it disambiguates by requiring a simple (nno operators) expression or use of brackets
11:32:23 <SamB> but, I don't care if it parses as (a + b) - c instead
11:32:29 <sjanssen> reilly: what type are your keys?
11:32:36 <apfelmus> reilly: the key size matters
11:33:01 <allbery_b> {} brackets, since () might be part of an expression
11:33:06 <vincenz> SamB: fixed
11:33:08 <Botje> it's not the size that matters, it's how you hash it.
11:33:10 <reilly> 32 bits
11:33:15 <paolino> glgut the error is before entering enet10
11:33:16 <paolino>     Couldn't match `WriterT w m'
11:33:16 <paolino>            against `StateT (Nodes s) (ReaderT (Env r q) (State g))'
11:33:16 <vincenz> SamB: let me fix the two remaining shift/reduce conflicts
11:33:20 <sjanssen> reilly: Int keys, then?
11:33:40 <reilly> yes, with pretty uniform distribution
11:33:42 <apfelmus> reilly: Data.IntMap ?
11:33:47 <sjanssen> reilly: use Data.IntMap
11:34:08 <sjanssen> it is technically O(1) lookup/insertion
11:35:04 <apfelmus> reilly: i'm not quite sure. you hash Ints into 32 bits, do you?
11:35:07 <vincenz> SamB: I'll let you tackle the s/r problems, not that familiar with that part of the syntax you require (unless you were to give me a full explanation) and I got some work to do :
11:35:11 <vincenz> SamB: but the r/r conflicts are gone
11:35:22 <paolino> glguy, I need a break, I go to eat ,bbl
11:35:22 <SamB> vincenz: yeah, I can deal with s/r problems
11:35:28 <SamB> or leave them alone
11:35:45 <SamB> but reduce/reduce are just scary
11:35:48 <hpaste>  vincenz annotated "Parser.y" with "Fixed R/R conflicts" at http://hpaste.org:8000/57#2
11:36:13 <vincenz> SamB: look how I differentiate between two expression types
11:36:15 <vincenz> SamB: that way in
11:36:16 <vincenz> a + b + c
11:36:26 <vincenz> a + .... what comes in that ... can never be a binary message
11:36:29 <vincenz> only base-exps
11:36:38 <vincenz> so it can't be a + (b+c
11:36:44 <vincenz> unless of course there's explicit parens
11:36:49 <vincenz> which makes an expression a base-exp
11:38:41 <reilly> apfelmus: assume it looks like [1..20 * 1000 * 1000] :: [Int32]
11:39:00 <vincenz> > last [1..20*1000*1000]
11:39:03 <lambdabot>  20000000
11:39:09 <SamB> glguy: diff lines look too tall to me
11:39:21 <glguy> what browser?
11:39:26 <glguy> they all seem different
11:40:02 <vincenz> diff seems fine for me, btw, nice :)
11:40:18 <vincenz> glguy++
11:40:22 <SamB> Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.7) Gecko/20060830 Firefox/1.5.0.7 (Debian-1.5.dfsg+1.5.0.7-2)
11:40:26 <glguy> :)
11:40:29 <vincenz> glguy++ or the nice fonts
11:40:32 <vincenz> s/or/for
11:40:36 <SamB> fonts?
11:40:40 <AhPook> hi folks
11:40:41 <vincenz> I like the style of the page
11:40:44 <vincenz> nice colors, nice fonts
11:40:47 <vincenz> nice layout
11:40:52 <vincenz> soft, zen, easy to read
11:40:55 <SamB> perhaps I do not have the fonts?
11:41:12 <vincenz> SamB: anyways, that ok?
11:41:14 <glguy> there is a stack of 4 specified
11:41:17 <apfelmus> reilly: ok. i just wondered whether you want to store strings or something like that and you just hash them to Int32.
11:41:24 <SamB> vincenz: that works nicely
11:41:36 <SamB> I think I could have done that
11:41:43 <vincenz> SamB: typical trick I use, split my exps into base_exps and non-base exps, with a workaround with parens
11:41:53 <SamB> except maybe for coming up with a nice name
11:42:23 <vincenz> SamB: of course you could've done that, just gotta know it :)
11:42:32 <SamB> I'm hoping that the precedence stuff will enable me to avoid doing it anymore
11:43:13 <vincenz> not stuff like this
11:43:30 <AhPook> Anyone here do much with HXT? I have some newbie questions.
11:43:51 <AhPook> and I'm not afraid to look stupid ;)
11:44:05 <monochrom> I do some HXT
11:44:32 <AhPook> I'm trying to put together a basic "hello world"
11:44:42 <sjanssen> @paste
11:44:42 <lambdabot> http://hpaste.org (Haskell pastebin)
11:44:51 <AhPook> generating a document, and the outputting it to stdout
11:45:09 * SamB wonders how to get happy to shut up about that conflict on the ")"
11:45:25 <hpaste>  sjanssen pasted "IntSet benchmark" at http://hpaste.org:8000/59
11:45:34 <sjanssen> reilly: take a look at that ^^^
11:45:39 <monochrom> I haven't generated much document. I have only parsed some.
11:46:09 <AhPook> All the tutorials I've found so far concentrate on parsing
11:46:22 <AhPook> readDocument >>> writeDoument
11:46:23 <sjanssen> reilly: it takes about 1 s to create an IntMap with 2m elements on my machine
11:46:24 <SamB> maybe generating is easier than consuming?
11:46:37 <reilly> apfelmus: Thanks.      ....     some of the time, yes.  some of the time the keys are really ints.  The recurring pattern is, load up 10 to 50 million rows and do a bunch of lookups against them throughout the day.
11:46:48 <reilly> sjannsen: thanks
11:46:50 <SamB> I mean, you can *generate* XML with bourne shell!
11:47:07 <SamB> I mean, easily
11:47:08 <sjanssen> reilly: but I really think you're going to run into memory issues with 20 m items
11:47:11 <AhPook> what I want to do is runX(genDoc >>> writeDoument)
11:47:11 <monochrom> Give me a few minutes.
11:47:34 <reilly> sjannsen: Why should i?
11:47:36 <AhPook> right, samB, but I'm trying to teach myself something new
11:47:43 <SamB> AhPook: well, yeah.
11:47:51 <SamB> but I guess they didn't figure it took a whole tutorial
11:48:13 <SamB> I suppose a few paragraphs would be good though
11:48:45 <AhPook> I'm looking for what the function signature would be for genDocument
11:49:05 <AhPook> all it has to do is make "<dummy />"
11:49:08 <apfelmus> reilly: interesting. i did not expect different key types in one and the same map.
11:49:16 <reilly> sjannsen:  I want to be able to keep a gig or two of data in memory
11:49:26 <reilly> apfelmus:  It's one keytype in a given map
11:49:39 <SamB> reilly: how much ram do you have?
11:49:42 <sjanssen> reilly: ah, maybe you won't
11:49:47 <sjanssen> my benchmark was flawed
11:50:00 <bd_> reilly: Data.ByteString has some (disabled) code for mmap... you could look into brushing that off and using that
11:50:01 <reilly> apfelmus: looking into the feasibility of using haskell
11:50:20 <sjanssen> reilly: 20m insertions took about 14s
11:50:43 <vincenz> SamB: welcome ;)
11:50:48 <reilly> right, but it's a tree so the lookup is O(log n)
11:50:56 <AhPook> thanks, monochrom
11:51:14 <apfelmus> reilly: you may want to use tries for keys of String type. this way, you don't even have collision
11:51:48 <reilly> in much of the problem space i know i won't have collision
11:52:28 <SamB> vincenz: oh, did I forget to say thanks?
11:53:35 <vincenz> hmm
11:53:38 <apfelmus> reilly: how do you guarantee it for Strings?
11:53:50 <SamB> actually its not working right...
11:54:20 <reilly> apfelmus: semantic knowledge of the string composition used in generating the key
11:54:20 <bos31337> glguy: ping
11:54:25 <bos31337> @seen glguy
11:54:25 <lambdabot> glguy is in #haskell. I last heard glguy speak 13m 10s ago.
11:54:28 <glguy> hi
11:54:53 <bos31337> what do you want to do about the fact that hpaste.org redirects in a non-transparent way?
11:54:58 <vincenz> glguy: nederlands?
11:55:09 <glguy> bos31337: shapr is going to do an apache-proxy
11:55:13 <glguy> bos31337: later today
11:55:20 <glguy> bos31337: and it will be much better
11:55:29 <bos31337> ok. if you need help, let me know.
11:55:45 <glguy> bos31337: alright, not much I can do, I'm just a normal user on this server :(
11:55:53 <apfelmus> reilly: ah, you generate them somewhat randomly (?)
11:55:58 <glguy> which at least mean I'm not responsible for maintaining it ;)
11:56:02 <bos31337> sure. but i have a nice network with root, where i control both apache and dns :-)
11:56:40 <glguy> bos31337: well, let's give shapr a shot at addressing this first
11:56:44 <glguy> and if that falls through
11:56:46 <bos31337> absolutely.
11:57:13 <bos31337> i assume that the goal is to have "go to hpaste.org in firefox" result in "hpaste.org is in the location bar"...?
11:57:18 <monochrom> AhPook: main = runX (replaceChildren (selem "greet" [txt "hello world"]) >>> writeDocument [] "-")
11:57:36 <abz> wrt HApps, what does it mean by `application server`?
11:57:57 <abz> appose to a normal HTTP server
11:58:37 <glguy> abz: it runs an application, rather than serving pages, or delagating to a mod_bgi
11:58:38 <glguy> cgi*
11:58:51 <AhPook> oh, nice, monchrom! that's enough to get me going!
11:59:22 <glguy> ?hoogle modification
11:59:22 <lambdabot> Directory.getModificationTime :: FilePath -> IO ClockTime
12:00:15 <glguy> ?docs System.Time
12:00:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
12:00:58 <abz> so does that mean, if you write a HappS application, and run it on a box, you can only access that application (on whatever port)? My question is really, can you do vhosts with HAppS?
12:01:13 <abz> just the vhosts question.
12:01:15 <reilly> apfelmus: randomly enough.  I should be clear, the example I gave covers some of the problem space, not all.  We are doing back-of-the-envelope tests for several use-cases that recur in the problem space.  This is one of them, and one that haskell did poorly at.  We knew it was likely to, given haskell's performance on the k-nucleotide test in the computer language shootout.
12:01:27 <glguy> Tue, 23 Jan 2007 19:49:52 GMT
12:01:31 <glguy> what is that format called?
12:01:46 <glguy> I want to generate it from "getModificationTime"
12:02:02 <vincenz> Anyone know how you specify the initial environment in typing rules?
12:02:22 <reilly> So many programmers live on hashtables, it might make sense for haskell to have a really fast implementation as a primitive (and built into the IO Monad)
12:02:48 <psnl> a good hashmap lib would be fine
12:03:05 <emu> Data.HashTable?
12:03:14 <apfelmus> i think that hash tables are not natural for a functional language at all
12:03:16 <reilly> Data.HashTable is beyond slow
12:03:27 <reilly> you're right, they are not natural
12:03:29 <dons> morning all
12:03:42 <emu> i use Data.Map generally
12:03:49 <Saizan> abz: afaik vhosts are managed via an apache proxy as to date
12:03:52 <dons> yeah, Data.IntMap makes a good hashtable
12:04:07 <dons> for some specific applications, e.g. pugs, people use HsJudy
12:04:17 <dons> ?users
12:04:18 <lambdabot> Maximum users seen in #haskell: 322, currently: 317 (98.4%), active: 56 (17.7%)
12:04:20 <reilly> HsJudy?
12:04:43 <dons> ?where HsJudy
12:04:44 <lambdabot> I know nothing about hsjudy.
12:04:53 <dons> bah, its a summer of code proejct
12:04:56 <abz> HApps -> a different port for each different site, cant run them all on port 80
12:04:57 <dons> and pugs uses it
12:05:09 <apfelmus> for everything bigger than integer keys, a generalized trie is likely the way to go in Haskell
12:05:28 <Excedrin> Judy is a C library that implements fast sparse dynamic arrays
12:05:46 <Excedrin> http://judy.sourceforge.net/
12:05:50 <lambdabot> Title: Judy Arrays Web Page
12:05:56 <dons> yeah, we need a good Data.Trie library though, apfelmus
12:06:00 <sjanssen> I wonder how a construct-but-never-insert hashtable would do in Haskell
12:06:02 <dons> rather than rolling our own each time
12:06:09 <dons> sjanssen: hmm, like arrays eh
12:06:33 <sjanssen> dons: exactly
12:06:38 <apfelmus> dons: mh, difficult without generic programming
12:06:55 <sjanssen> @google generalized tries haskell
12:07:02 <lambdabot> http://citeseer.ist.psu.edu/233124.html
12:07:02 <lambdabot> Title: Generalizing Generalized Tries - Ralf (ResearchIndex)
12:07:05 <dons> :)
12:07:17 * sjanssen wants deriving Trie
12:08:21 <sjanssen> with class Trie k where {data Trie k v; lookup :: k -> Trie k v -> v; etc.}
12:08:49 <apfelmus> reilly: btw, tries can be infinite. and thanks to lazyness, they only consume space for actual elements
12:09:15 <reilly> right, the only issue is lookup time
12:09:55 <apfelmus> well, you can't be faster than the key size :) (which is O(digits) for integers)
12:10:25 <apfelmus> and tries are exactly as fast as key sizes permit
12:10:41 <AhPook> Thanks, monchrom, it worked, once I got the compiler flags right
12:10:43 <dons> we used tries for one of the shootouts that needed hashtables, and the performance was really really good
12:10:47 <dons> pity it wasn't legal
12:10:52 <reilly> yes, but hashtables are O(1) for most entries
12:11:20 <reilly> i agree that Tries are a better structure in many cases
12:11:34 <apfelmus> well O(1) is because digits <= 32
12:11:38 <dons> yeah, a nice hashtable lib, even just a construction only one, would be useful though
12:11:43 <glguy> ?hoogle String -> CalendarTime
12:11:44 <lambdabot> No matches, try a more general search
12:11:56 <sjanssen> reilly: OOI are you using GHC 6.6?
12:12:05 <apfelmus> dons: why wasn't it legal?
12:12:18 <dons> you had to specifically use the data structure they asked for
12:12:22 <glguy> Does anyone know how to read in Tue Jan 23 14:06:28 CST 2007 to a CalendarTime?
12:12:23 <dons> which was a hashtable, iirc
12:12:24 <reilly> dons: why not do it in the IO Monad and not make it construction only?
12:12:34 <dons> reilly: well, we have that
12:12:37 <reilly> Yes, I am using 6.6
12:12:51 <reilly> yes, but the implementation is slow
12:12:59 <dons> but they tend not to mix well with the rest of the code. io-only data structures are not so useful
12:13:01 <sjanssen> reilly: if it is construction only, it doesn't have to use IO at all
12:13:05 <dons> but sure, if you need it, roll one up.
12:13:13 <dons> even a binding to a fast C implementation might do
12:13:14 <reilly> sjannsen, I understand
12:13:38 <reilly> dons: I am considering that
12:13:48 <apfelmus> dons: disappointing. and there is no test case for tries, right?
12:13:49 <dons> but you might just want to use HsJudy.
12:13:56 <dons> apfelmus: right
12:14:05 <apfelmus> i knew it :)
12:14:41 <dons> reilly: have you found Data.IntMap or Data.Map unsuitable?
12:14:42 <reilly> of course, if there was one built into the runtime as a primitive it could be used in the k-nucleotide test on the language shootout
12:14:55 <reilly> dons: No, I haven't tried them.  I am going to
12:15:05 <sjanssen> that's it, Data.Trie needs to be in the next iteration of the base package
12:15:14 <dons> sjanssen: yes!
12:15:20 <dons> you'd even get some help writing it
12:15:23 <dons> and fame and fortune :)
12:15:33 <dons> just implement it straight from the paper
12:15:34 <sjanssen> dons: I bet it's already written somewhere
12:15:53 <reilly> dons
12:15:55 <sjanssen> dons: the paper discusses a deriving Trie mechanism, IIRC
12:16:10 <sjanssen> dons: I'm thinking something simpler, just for lists
12:16:17 <dons> yeah
12:16:17 <reilly> dons: when we specified the test, we specified that the lookup had to be O(1)
12:16:21 <Excedrin> http://cvs.haskell.org/trac/ghc/ticket/721
12:16:22 <lambdabot> Title: #721 (Write Data.Trie) - GHC - Trac
12:16:27 <dons> reilly: :)
12:16:36 <dons> its ok. i can deal with that
12:16:44 <dons> there's plenty of benchmarks that favour pure fp anyway
12:17:03 <reilly> dons: it's an exemplar for a lot of code we end up writing
12:17:32 <dons> so what kind of keys do you have? Ints or something else?
12:17:50 <reilly> dons: and as far as i'm concerned, the way we use hasthables *is* IO.  We're just building an in-memory database
12:17:57 <dons> yeah
12:21:01 <dons> http://perlcabal.org/~audreyt/darcs/pugs/third-party/HsJudy/
12:21:03 <lambdabot> Title: Index of /~audreyt/darcs/pugs/third-party/HsJudy
12:21:05 <dons> ?where+ HsJudy http://perlcabal.org/~audreyt/darcs/pugs/third-party/HsJudy/
12:21:06 <lambdabot> Done.
12:21:27 <reilly> dons:  a variety of keys.  Many of them are ints.  There is no doubt that the tests are imperfect.  And there is no doubt that some of them reflect a less functional view of the world.
12:21:29 <dons> Develop Judy[1] bindings (a C library that implements fast sparse dynamic
12:21:30 <dons> arrays) for Haskell presenting APIs conforming as much as possible to the
12:21:30 <dons> existent Haskell library interfaces, like Data.Map
12:21:36 <reilly> thanks EVERYONE  for the help
12:21:45 <dons> reilly: hey, i don't mind :) the shootout is great fun.
12:21:50 <dons> i'm not complaining! :)
12:22:32 <dons> > let m = M.fromList (zip [1..] "haskell") in M.lookup 4 m :: Maybe Char -- have a map
12:22:33 <lambdabot>  Just 'k'
12:22:54 <dons> ?let fm = M.fromList (zip [1..] "haskell")
12:22:55 <lambdabot> Defined.
12:23:10 <dons> > M.lookup 200 fm :: [Char]
12:23:11 <lambdabot>  ""
12:23:17 <Excedrin> wow, there's really a lot of trie implementations
12:23:18 <dons> > M.lookup 2 fm :: [Char]
12:23:19 <lambdabot>  "a"
12:23:50 <lightstep> > it
12:23:51 <lambdabot>   Not in scope: `it'
12:23:53 <sjanssen> Excedrin: I can think of two off the top of my head
12:23:59 <sjanssen> collections and edison
12:24:39 <Excedrin> there's 4 others in the libraries thread, linked from the trac page
12:25:09 <sjanssen> Excedrin: really seems like a sign that there should be one in base, doesn't it?
12:25:16 <dons> > (M.lookup 2 (M.insert 200 '#' fm) :: (Char -> Char)) undefined -- hehe
12:25:17 <lambdabot>  'a'
12:25:31 <dons> sjanssen: ^^ ever looked up a (-> a) result from a map?
12:25:34 <apfelmus> dons: mmh. isn't a trie a hash table with strange keys and identity hash function?
12:25:57 <Excedrin> I guess the one in collections is the first one in that thread, so only 3
12:26:00 <sjanssen> dons: can't say that I have
12:26:17 <dons> > (M.lookup 400 (M.insert 200 '#' fm) :: (Char -> Char)) '-'
12:26:18 <lambdabot>  Exception: Data.Map.lookup: Key not found
12:26:28 <dons> hmm. error?
12:26:35 <dons> ?src (->) fail
12:26:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:26:36 <chessguy> dons, did you see the new parser library announced today?
12:26:40 <dons> not yet
12:26:46 <chessguy> something else for HWN :)
12:26:51 <vincenz> dons: that in response to lambdabot ?
12:26:59 <chessguy> lol
12:27:18 <vincenz> @remember dons [lambdabot]  Source not found. Your mind just hasn't been the same since the electro-shock, has it? [dons] not yet
12:27:19 <lambdabot> Done memoising quote for `dons', if that is their real name...
12:27:42 <AhPook> thanks folks, back to work!
12:28:38 <dons> ?where+ polyparse http://www.cs.york.ac.uk/fp/polyparse
12:28:39 <lambdabot> Done.
12:29:02 <paolino> ?type runWriterT $ flip runContT return (callCC $ \cc -> tell "test" >> get >>= cc)
12:29:04 <lambdabot> forall w (m :: * -> *) b. (Monad (WriterT w m), MonadCont (ContT b (WriterT w m)), MonadWriter [Char] (ContT b (WriterT w m)), MonadState b (ContT b (WriterT w m))) => m (b, w)
12:29:30 <dons> heh
12:29:45 <chessguy> yikes
12:30:20 <dons> hey, its just m (b, w)
12:30:24 <dons> nothing so bad ;)
12:33:41 <monochrom> Polyparse is the new workhorse of HaXml.
12:38:48 <emu> "their real name"?
12:39:11 <dons> ?users
12:39:11 <lambdabot> Maximum users seen in #haskell: 322, currently: 318 (98.8%), active: 50 (15.7%)
12:39:53 <monochrom> "if that's their real name" is just another example of lambdabot attitude :D
12:40:03 <dons> monochrom: you like that though, right?
12:40:05 <emu> mm PolyLazy looks neat
12:40:07 <dons> but yeah, its a bit weird
12:40:37 <monochrom> No, I think "if that's their real name" is pretentious.
12:41:04 <monochrom> Most lambdabot attitudes are funny.  But this one is pompous.
12:41:07 <SamB> monochrom: I thought it was referring to the time when dons thought TimToady stood for Tim Toady, not Larry Wall?
12:41:33 <monochrom> PolyLazy is the dream of everyone.
12:44:02 <SamB> vincenz: okay, so, before something started hogging my X input, I told you that your suggestion did not work right...
12:47:40 <dons> ?users
12:47:40 <lambdabot> Maximum users seen in #haskell: 322, currently: 320 (99.4%), active: 50 (15.6%)
12:47:44 <SamB> glguy: oh, um, why does this column say "revisions"?
12:47:46 <dons> close!
12:47:55 <dons> SamB: better than 'anos' ?
12:47:55 <SamB> some people are liking to use annotations for error messages
12:48:15 <dons> ok. it could be 'versions' ? or something?
12:48:18 <ndm> ?hoogle HasBounds
12:48:19 <lambdabot> Data.Array.IArray.HasBounds :: class HasBounds a
12:52:21 <dons> ?yow!
12:52:22 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
12:53:26 <vincenz> @arr
12:53:26 <lambdabot> Aye
13:02:01 <njd> @users
13:02:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 319 (99.1%), active: 47 (14.7%)
13:20:23 <vincenz> SamB: "not work right" is not very precise :/
13:21:28 <dons> ?users
13:21:33 <vincenz> @bot
13:21:33 <lambdabot> :)
13:21:43 <vincenz> @users
13:21:43 <lambdabot> Maximum users seen in #haskell: 322, currently: 319 (99.1%), active: 41 (12.9%)
13:21:50 <vincenz> dons: you're not popular it seems
13:21:56 <dons> seems so
13:22:06 <vincenz> ?users
13:22:06 <lambdabot> Maximum users seen in #haskell: 322, currently: 318 (98.8%), active: 41 (12.9%)
13:22:16 <vincenz> try again?
13:23:20 <hpaste> ?users
13:23:20 <lambdabot> Maximum users seen in #haskell: 322, currently: 319 (99.1%), active: 41 (12.9%)
13:23:45 <emu> @botsnac
13:23:45 <lambdabot> :)
13:24:59 <sjanssen> alas, ghc head, why won't you build?
13:26:16 <dons> not enough types
13:26:20 <dons> it needs more types!
13:28:14 <dmhouse> Morning everyone! :)
13:28:15 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
13:28:23 <dmhouse> Or, err, evening.
13:35:47 <kolmodin> dons: you've got mail
13:37:02 <kolmodin> ?tell dons unmtl patch in your mailbox
13:37:02 <lambdabot> Consider it noted.
13:37:59 <dons> mm!
13:37:59 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:16 <dons> kolmodin++ very nice!
13:38:39 <kolmodin> I replaced a 150 lines crappy parser I wrote yesterday with a clean 50 lines one today
13:38:47 <kolmodin> and it parses all haskell98 code
13:38:54 <kolmodin> dons: glad you like it :)
13:39:07 <dons> :)
13:39:30 <emu> using what library? or hand crafted?
13:39:56 <kolmodin> old one was parsec, new one is haskell-src's Language.Haskell.Parser
13:39:57 <kolmodin> :D
13:40:07 <dcoutts> nice
13:40:17 <emu> right!
13:40:26 <emu> (isn't that cheating?)
13:40:29 <dcoutts> kolmodin, want to extend sjanssen's @undo module to @desugar ? :-)
13:40:30 <kolmodin> now it's work to find the correct types, before it was the parsing
13:40:39 <kolmodin> dcoutts: no way :)
13:40:46 <dcoutts> oh well :-(
13:40:51 <kolmodin> not today anyhow
13:41:00 <dcoutts> I'll have to do it, or just do some examples by hand...
13:41:05 <kolmodin> does the undo remove do notation?
13:41:14 <dcoutts> yep
13:41:21 <dcoutts> just desugars do notation
13:41:25 <sjanssen> @undo do x <- m; return x -- like so
13:41:25 <lambdabot> m >>= \ x -> return x
13:41:33 <dcoutts> I just want to extend that to desugar list comprehensions
13:41:38 <dcoutts> should be easy...
13:41:43 <kolmodin> dcoutts: shouldn't you have a @scramble for your labs as well
13:41:43 <sjanssen> @. redo undo do x <- m; return x
13:41:43 <lambdabot> do { x <- m; return x}
13:41:57 <dcoutts> kolmodin, we do have @scramble, it's called @pl :-)
13:41:57 <kolmodin> oh, @., cool!
13:42:02 <kolmodin> dcoutts: haha :)
13:42:31 <kolmodin> eh...
13:42:41 <sjanssen> kolmodin: does your parser fix operator precedences?
13:43:14 <kolmodin> it parses any haskell98
13:43:33 <kolmodin> so, yes
13:43:40 <SyntaxNinja> lala
13:43:44 <dcoutts> sjanssen, @undo also uses the haskell-src H98 parser right?
13:43:49 <dcoutts> g'evening SyntaxNinja
13:43:57 <sjanssen> right, but haskell-src treats all operators as infixr with the same precedence
13:44:01 <sjanssen> dcoutts: correct
13:44:07 <dcoutts> ah, I see
13:44:13 <kolmodin> ah, ok
13:44:21 <kolmodin> then no :)
13:44:52 <kolmodin> doesn't matter to the @unmtl though
13:45:04 <sjanssen> what is unmtl?
13:45:12 <kolmodin> it unrolls the mtl monads
13:45:30 <kolmodin> unmtl State s a
13:45:34 <kolmodin> s -> (a, s)
13:45:45 <kolmodin> unmtl ContT [ByteString] (StateT S IO) a
13:45:50 <kolmodin> (a -> S -> IO ([ByteString], S)) -> S -> IO ([ByteString], S)
13:45:58 <dcoutts> nice
13:45:58 <kolmodin> and so on :)
13:46:00 <sjanssen> neat
13:46:17 <dcoutts> kolmodin, so that's doing the uncurrying too right ?
13:46:26 <sjanssen> does it unroll expressions using mtl too?
13:46:29 <dcoutts> er I mean currying
13:46:42 <bd_> Is there a corresponding @remtl? :)
13:46:52 <kolmodin> bd_: hah, God no :)
13:46:58 <dcoutts> bd_, I was thinking about that...
13:47:12 <bd_> kolmodin: just run all the transformations in reverse! How hard could it be, right? ;)
13:47:16 <dcoutts> It'd not be impossible, but only best attempt by pattern matching on the types
13:47:39 <kolmodin> bd_: well.. hmm. it could be done
13:47:45 <dcoutts> eg: @mtl type Foo a = S -> a -> (S, a)
13:48:03 <kolmodin> it would have to guess what you want to do
13:48:10 <dcoutts> you'd look at the set of args and set of outputs in the tuple
13:48:27 <dcoutts> you can identify reader, writer and state that way
13:48:33 <dcoutts> error is harder
13:48:34 <SyntaxNinja> heya dcoutts
13:49:15 <dcoutts> cont would be fun, but again it's just pattern matching
13:49:42 <dcoutts> you'd have to have specific code for each transformer you want to match
13:49:53 <dcoutts> but there arn't that many of them
13:50:01 <kolmodin> dcoutts: what about currying?
13:50:24 <dcoutts> kolmodin, don't some mtl things introduce (,)'s on the left of the -> ?
13:50:40 <dcoutts> if you nest them I mean
13:50:44 <kolmodin> sjanssen: it does use the mtl library, yes.. but only for Error definition of Either
13:50:53 <dcoutts> I recall having to expand that for ContT/StateT
13:51:34 <kolmodin> contT does
13:51:50 <kolmodin> if it gets something with (,) from an underlying monad
13:52:05 <kolmodin> dons: load it already.. :)
13:52:16 <kolmodin> anyway, I should sleep soon
13:53:13 <dons> i'm hacking!
13:53:21 <dons> i'll load it later! :)
13:53:26 <dons> kolmodin++ have a cookie :)
13:53:30 <kolmodin> ah, that's a valid excuse :)
13:53:33 <kolmodin> yay
13:53:41 <kolmodin> don't think I get ++'s very often
13:53:41 <dons> trying to get binary serialisation into hpaste
13:53:48 <kolmodin> cool
13:54:07 <mbishop> @cookie
13:54:07 <lambdabot> Unknown command, try @list
13:54:10 <mbishop> :[
13:54:19 <nornagon> @botsn
13:54:19 <lambdabot> :)
13:55:27 <csci> Hi, does a site with success stories (i.e. haskell usage in the Real World(tm)) exist?
13:55:44 <emu> haskell >>= success
13:55:53 <csci> ;-)
13:56:08 <emu> @wiki Success Stories
13:56:08 <lambdabot> http://www.haskell.org/haskellwiki/Success Stories
13:56:28 <emu> something tells me lambdabot isn't checking for existence
13:56:35 <dons> heh
13:56:43 <dons> csci: there's some pages on haskell.org
13:56:52 <dons> look atthe 'industry' page, and the 'libraries' page
13:56:52 <csci> Yes, I already search on the wiki for success stories
13:57:01 <csci> ah, industry is a good keyword
13:57:08 <dons> its linked from the front page
13:57:16 <dons> but also look at the 'libraries and applications' page
13:57:23 <dons> since that lists just about everything that has ever been released
13:57:53 <csci> also quite a good idea. I was focused on the terms "Success stories"
13:58:03 <mbishop> Great success!
13:58:13 <shapr> For Great Success!
13:58:26 * emu is reading this Fast & Loose paper
13:59:32 <kolmodin> dons: I'll just take some marmite... .. .. ... ....
14:00:17 <dons> mm yes. breakfast time
14:00:39 <vincenz> @localtime dons
14:00:41 <lambdabot> Local time for dons is Wed Jan 24 08:57:17 2007
14:02:24 <allbery_b> foo
14:02:24 * dons waves from sydney
14:02:42 <dons> ?users
14:02:42 <lambdabot> Maximum users seen in #haskell: 322, currently: 306 (95.0%), active: 37 (12.1%)
14:02:52 <dons> shapr: we reached a new highscore again last night
14:03:46 <Igloo> Woo
14:04:06 <Igloo> Soon we'll have a #haskeller for each day of the year  :-)
14:04:10 <dons> hehe
14:04:15 <dons> i think we might get 400 this year
14:05:29 <psnl> is it a count of the number of people on the channel at once, or unique nicks?
14:08:06 <shapr> Number of clients on the channel at once.
14:08:16 <shapr> Unique nick count is waaay up there. 3k or so?
14:08:19 <shapr> @where irc
14:08:19 <lambdabot> I know nothing about irc.
14:08:21 <psnl> more bots!
14:08:22 <shapr> @where irc-stats
14:08:22 <lambdabot> I know nothing about irc-stats.
14:08:26 <shapr> foo
14:08:32 <Philippa> unique nick includes a lot of alt nicks, though
14:08:35 <shapr> psnl: http://www.cse.unsw.edu.au/~dons/irc/
14:08:36 <lambdabot> Title: Haskell IRC Activity
14:08:55 <dons> ?where stats
14:08:55 <psnl> shapr: wow
14:08:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
14:09:44 <Igloo> and spammers, and people who only ever turn up once with a homework problem
14:10:20 <abcde`> and people like me, who come in and don't say anything
14:10:29 <shapr> Igloo: That's a good point, it would be interesting to filter that to nicknames that were present for more than once.
14:10:53 <Igloo> Yeah, I was thinking "unique nicks that appear at two times at least a month apart" or something
14:11:05 <kolmodin> ?where love
14:11:05 <lambdabot> I know nothing about love.
14:11:11 <shapr> poor bot
14:11:13 <kolmodin> lambdabot: right, your a machine..
14:11:17 <ndm> ?where pain
14:11:18 <lambdabot> I know nothing about pain.
14:11:24 * ndm spots a correlation
14:11:29 <kolmodin> haha :)
14:11:39 <kolmodin> good one :D
14:11:42 <shapr> Igloo: Maybe dons' graph-building source is in a repo somewhere? You could extend it?
14:11:57 <Philippa> ndm: may not be the one you're expecting :-)
14:12:04 <Igloo> shapr: Or I could throw random thoughts at the channel and hope that someone else does so  :-)
14:12:11 <ndm> Philippa: lol :)
14:12:17 <shapr> Igloo: That's my job!
14:13:43 <dons> ?where binary
14:13:43 <lambdabot> http://darcs.haskell.org/binary
14:13:45 <dons> ?where zlib
14:13:45 <lambdabot> darcs get http://haskell.org/~duncan/zlib
14:13:56 <dons> ?join #happs
14:14:04 <earthy> good morning, dons. :)
14:15:04 <dons> hey earthy
14:15:05 <shapr> Silly question, is there some option that's the opposite of --partial? Can I turn a partial repo into the full thing?
14:15:19 <earthy> you could just get the rest, no?
14:15:20 <Igloo> --complete
14:15:23 <shapr> thanks
14:15:28 <Igloo> earthy: Sadly not
14:15:49 <shapr> Oh, I thought darcs pull --complete would fill out the rest of a darcs get --partial
14:16:23 <paolino> > evalState ( runContT (runWriterT (let l x = do {get;tell ["ciao"] ; x 1;l x} in callCC l)) return) 1
14:16:25 <lambdabot>  (1,[])
14:16:35 <earthy> running darcs get on a darcs repo that was gotten with --partial gets the rest, no?
14:16:59 <paolino> anyone can tell me why my "ciao" is not there ?
14:17:52 <shapr> earthy: I don't know, try it and tell us!
14:17:53 <Igloo> earthy: It'll get the whole thing into a subdirectory
14:17:57 <shapr> oh
14:18:12 <earthy> ah, right. that's not what you want.
14:18:17 <kolmodin> paolino: you're using cont which is a bit special
14:18:32 <earthy> oh well, time for bed.
14:19:11 <paolino> kolmodin: I'd like to understand anyway
14:19:24 <kolmodin> paolino: write out the fully type of the monad, you'll see a part where  (a -> m r) -> m r
14:19:53 <kolmodin> your ciao is in the 'a', which isn't returned in the final result
14:19:59 <glguy> hpaste down for a few moments, binary state file change
14:21:15 <kolmodin> paolino: what's the full type of that expression?
14:22:20 <kolmodin> StateT s (ContT r (WriterT mono m)) a
14:22:31 <kolmodin> mono is String
14:23:17 <kolmodin> anyway, it's your s and r in the final result, I think
14:23:48 <kolmodin> paolino: you could try to put the writer transformer outside the contT?
14:25:19 <paolino> I get a instance error
14:25:51 <SamB> hmm, I seem to have gotten rid of my reduce/reduce conflicts
14:25:55 <paolino>  No instance for (MonadWriter [[Char]] (ContT a (WriterT w (State s))))
14:28:37 <kolmodin> if you unroll the monad you get: s -> ((a, s) -> m (r, mono)) -> m (r, mono)
14:29:12 <NichardRixon> ?where Haskell
14:29:13 <lambdabot> http://haskell.org/
14:29:45 <kolmodin> so the 'ciao' shold be the mono type. something is fishy, likely with cont
14:33:48 <paolino> kolmodin: I leave ContT understanding for a later learning
14:35:12 <hpaste> now with 75% smaller state files
14:36:14 <paolino> I thought it was the way to break monadic streams, but I cannot handle it
14:36:46 <kolmodin> paolino: it's probably easier to roll your own, that way you know exactly what happens
14:42:02 <newsham> is there a better (Num a) => Char -> a  than (fromIntegral.fromEnum) ?
14:43:11 <allbery_b> I don't think so, but I also get the impression that reasonable Haskell implementations will optimize that to an effective no-op
14:43:19 <hpaste> gzip for great justice!
14:43:31 <newsham> why a nop?
14:44:01 <newsham> > foldl (\n c -> n*n + fromEnum c) 0 "test"
14:44:02 <lambdabot>  -1250489852
14:44:04 <bd_> newsham: fromIntegral . ord ?
14:44:13 <SamB> newsham: well, more like nothing, depending on the output type
14:44:14 <allbery_b> because in some sense it already *is* a Num; it's just type shuffling\
14:44:18 <bd_> fromIntegral is optimized in all the common cases
14:44:29 <bd_> and Char is isomorphic to Int in GHC, isn't it? :)
14:44:32 <newsham> allbery: but its not the kind of Num I want :)
14:44:38 <SamB> well, maybe it isn't smart enough to be able to reuse the closure
14:44:39 <allbery_b> right, it's type shuffling
14:44:45 <newsham> its the kind of num that gives wrong answers
14:45:13 <allbery_b> you need to get the right type for things to operate on it.  but the *value* isn't what's wrong, just the type
14:45:20 <newsham> > foldl (\n c -> n*n + (fromIntegral.ord) 0 "test"
14:45:20 <lambdabot>  Parse error
14:45:30 <newsham> > foldl (\n c -> n*n + (fromIntegral.ord) c) 0 "test"
14:45:31 <lambdabot>  33779633064708612
14:45:58 <newsham> > foldl (\n c -> n*n + ord c) 0 "test"
14:45:59 <lambdabot>  -1250489852
14:47:03 <allbery_b> sure.  that's the type getting you.  fromIntegral changes the type to one that doesn't have Int's restrictions.
14:47:12 <newsham> yes, i know.
14:47:26 <newsham> so no functions predeclared similar to fromIntegral.ord?
14:47:32 <allbery_b> IIRC GHC's Integer uses Int when it can but promotes when needed, so de facto it's a no-op
14:47:38 <bd_> :t genericFromEnum
14:47:38 <allbery_b> ?src Integer
14:47:39 <lambdabot> data Integer = S# Int#
14:47:39 <lambdabot>              | J# Int# ByteArray#
14:47:39 <lambdabot> Not in scope: `genericFromEnum'
14:47:40 <SamB> allbery_b: no
14:47:50 <SamB> well, anyway, maybe no
14:47:54 <allbery_b> well, okay, an Int#
14:48:00 <SamB> I suppose, since S# is the first constructor...
14:48:19 <SamB> it *might* be memory-compatible with I#
14:48:26 <SamB> ?src Int
14:48:26 <lambdabot> data Int = I# Int#
14:48:33 <bd_> ?src Int64
14:48:34 <lambdabot> data Int64 = I64# Int64#
14:49:08 <SamB> what I don't know is whether I# has a field for constructor number
14:49:35 <sjanssen> heh, maybe fromIntegral = unsafeCoerce# :: Int -> Integer?
14:49:39 <sjanssen> SamB: I believe it does
14:51:27 <allbery_b> *shrug* even if you have to change a type tag in the internal rep, it's faster than cmputing an entire new representation (as from coercing an internal unboxed int to an internal bigint)
14:52:12 <sjanssen> @paste
14:52:13 <lambdabot> http://hpaste.org (Haskell pastebin)
14:52:48 <hpaste>  sjanssen pasted "Int and Integer" at http://hpaste.org:8000/60
14:53:44 <bd_> int2Integer (I# i) = S# i
14:53:48 <bd_> force-inlined
14:53:56 <allbery_b> I grant I'm only cinsidering the case of an upcast.  downcasts strike me as being dubous in general
14:54:15 <allbery_b> (i.e. your second example is courting a coredump regardless)
14:54:34 <hpaste>  bd_ annotated "Int and Integer" with "the real way to do it :)" at http://hpaste.org:8000/60#1
14:54:53 <allbery_b> ...and if you're tweaking type tags, eve more so, since I'm not talking about those
14:54:57 <fasta> Who? What? Where?
14:56:10 <SamB> allbery_b: downcasts are obviously not NOPs
14:56:20 <allbery_b> (which is to say, if unsafeCoerce# forces interpretation of the type tag in the wrong context, well, duh)
14:56:37 <allbery_b> SamB: exactly, and I'm not talking about those
14:56:43 <SamB> there are narrow*# primitives for that
14:57:06 <SamB> oh, and for things with more constructors, there is this thing called case...
15:01:57 <kolmodin> g'night!
15:03:51 <paolino> gnight
15:05:16 <bakert> ?paste
15:05:17 <lambdabot> http://hpaste.org (Haskell pastebin)
15:05:56 <bakert> save me from my own stupidity.  i'm trying to write a recursive function to build up a set of html table rows.  but i can't think how to terminate.  i need a kind of html empty list.
15:06:18 <dons> what's the base case for the recursion?
15:06:20 <hpaste>  bakert pasted "html empty list???" at http://hpaste.org:8000/61
15:06:36 <SamB> why don't you just make a list of rows and use that?
15:06:39 <bd_> bakert, ""?
15:06:44 <dons> emptyHtml?
15:06:52 <bakert> bd_, that fails because it is not of type Html
15:06:56 <bd_> oh
15:07:03 <dons> (I believe that's the haxml code for nothing)
15:07:05 <fasta> notany is not being appreciated: http://programming.reddit.com/info/101i6/comments
15:07:05 * bd_ hasn't worked with the html module much
15:07:06 <lambdabot> Title: Closures python,scheme,ruby -- Why are closures so clumsy in python (reddit.com)
15:07:14 <bakert> dons, aha!  that may be it.  i couldn't think of a name apart from noop which doesnt' even make sense!
15:07:20 <Saizan> bakert: why can't you just stop at [t] instead of []?
15:07:32 <hpaste>  dons annotated "html empty list???" with "emptyHtml" at http://hpaste.org:8000/61#1
15:07:39 <bakert> Saizan, might pass in an empty list i suppose.  but that might work.
15:08:02 <bakert> ah.  damn.  is emptyHtml not in Text.XHtml?
15:08:10 <bakert> ?hoogle emptyHtml
15:08:10 <lambdabot> No matches found
15:08:12 <fasta> hpaste is quite responsive.
15:08:14 <Igloo> Do you really want the "tr << td << " there?
15:08:25 <dons> fasta: why wouldn't it be? :)
15:08:27 <Igloo> I'd expect an emptyTable or emptyRow or something
15:08:29 <bakert> Igloo, no not in the empty list case.  i just put that in thil i worked out what to do
15:08:38 <dons> its compiled, compressed bytestrings. it should be like writing in C ;)
15:08:41 <bakert> Igloo, in that case i actually want nothing at all.
15:09:36 <bakert> I think in Text.XHtml there is noHtml that does the same job as emptyHtml.  Trying it now
15:09:57 <dons> emptyHtml is in HAppS, so I guess there's something similar
15:10:35 <Igloo> If [] can't happen then   transactionsRows = fold?1 (+++) . map transactionRow   FWIW
15:10:49 <bakert> yep noHtml is the boy.
15:11:00 <SamB> @hoogle noHtml
15:11:00 <lambdabot> Text.Html.noHtml :: Html
15:11:04 <fasta> dons: I wasn't expecting good hosting and I can imagine that a Haskell webserver build by a couple of people could be less optimized than e.g. Apache.
15:11:10 <bakert> I think i have to allow for no rows, sadly.  Thanks very much everyone!  Brilliant as usual!
15:12:15 <sorear> tell fodder
15:12:16 <shapr> fasta: It's hosted on my $15/month virtual server in Atlanta
15:12:21 * dons <3 strongly typed, compiled web frameworks
15:13:21 <cain_16> hi all
15:13:28 <dons> hey. welcome
15:13:37 <shapr> greetings cain--
15:13:44 <fasta> I like soft-typing more, but not in its current state.
15:13:55 <SamB> @karma cain
15:13:55 <shapr> I like firm typing.
15:13:55 <lambdabot> cain has a karma of -8
15:13:59 * monochrom wonders how cain-- interacts with lambdabot's karma system.
15:14:00 <cain--> is implemented a stack like that:
15:14:02 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
15:14:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:14:05 <cain--> data Stack a = Nil | Top a (Stack a) deriving Show
15:14:05 <cain--> top :: Stack a -> a
15:14:05 <cain--> top (Top x _) = x
15:14:05 <cain--> pop :: Stack a -> Stack a
15:14:05 <cain--> pop Nil = Nil
15:14:05 <cain--> pop (Top x y) = y
15:14:06 <SamB> cain--: that isn't a nice nick to have
15:14:07 <cain--> push :: a -> Stack a -> Stack a
15:14:09 <cain--> push a Nil = Top a Nil
15:14:11 <cain--> push a (Top x y) = Top a (Top x y)
15:14:16 <shapr> cain--: It's not polite to paste more than three lines in the channel.
15:14:17 <SamB> it lowers cain's karma
15:14:25 <dons> ?paste <-- is preferred
15:14:26 <lambdabot> http://hpaste.org (Haskell pastebin)
15:14:26 * monochrom wonders: will "cain--++" work? :D
15:14:32 <shapr> @karma cain--
15:14:32 <lambdabot> cain-- has a karma of 0
15:14:39 <shapr> @karma cain
15:14:40 <lambdabot> cain has a karma of -9
15:14:41 <shapr> hmm
15:14:50 <fasta> Minor bug...
15:14:51 <dons> cain--: stick it up on the paste page
15:14:52 <SamB> cain--++
15:14:53 <dons> and we can annotate it
15:14:56 <SamB> @karma cain
15:14:56 <lambdabot> cain has a karma of -9
15:14:57 <SamB> @karma cain--
15:14:57 <lambdabot> cain-- has a karma of 1
15:15:13 <cain--> ok sorry
15:15:18 <bakert> now you have to think of the nick that would screw with lambdabot even more
15:15:31 <hpaste>  cain pasted "my prog" at http://hpaste.org:8000/62
15:15:33 <bakert> bakert is now known as > something crazy
15:15:36 <SamB> "Java++"
15:15:43 <cain--> ok heres my program: http://hpaste.org:8000/62
15:15:45 <bakert> @karma c
15:15:45 <lambdabot> c has a karma of 15
15:15:49 <bakert> !
15:16:02 <dons> SamB: asks for trouble ;)
15:16:02 <shapr> cain--: Yup, the paste program announces pastes in the channel.
15:16:03 <fasta> Is there a maximum nick length in IRC?
15:16:05 <SamB> just as well
15:16:07 <shapr> fasta: yes, try it.
15:16:07 <SamB> really
15:16:14 <cain--> and i want to turn infix to postfix notation and to use my stack for that
15:16:21 <emu> some servers are different
15:16:22 <dons> hmm, postfix eh?
15:16:24 <dashlkjfhsldkjfh> Oh, I see
15:16:25 <emu> oldschool IRC max length is 9
15:16:36 <SamB> it would be so evil to have someone who, when you speak to them by name, you lose karma
15:16:37 <emu> this server is 16 i think
15:16:40 <sorear> it's speced in the RFC even
15:16:42 <cain--> and i have the question: how do i "create" a stack
15:16:51 <dons> cain--: hmm, by construction?
15:16:52 <java> what, + is illegal!?
15:16:54 <dons> > 1 : 2 : 3 : []
15:16:56 <lambdabot>  [1,2,3]
15:16:58 <monochrom> Use Nil for your initial stack.
15:17:11 <cain--> yes: look at my program
15:17:29 <cain--> it works so far but lets said if i walk through my string
15:17:29 <dashlkjfhsldkjfh> So, this is new school IRC?
15:17:32 <shapr> yup
15:17:36 <shapr> freenode has LOTS of improvements.
15:17:40 <cain--> how can i push the operator on a stack
15:17:40 <SamB> sorear: I dare you to say "Java++" without quotes or other non-whitespace characters nearby
15:17:46 <emu> @karma haskell
15:17:46 <lambdabot> haskell has a karma of 17
15:17:49 <dashlkjfhsldkjfh> Oh, it's not standardized?
15:17:56 <sorear> @karma sorear
15:17:57 <lambdabot> You have a karma of 17
15:17:59 <sorear> Java++
15:17:59 <dashlkjfhsldkjfh> Like in an RFC?
15:18:00 <sorear> @karma sorear
15:18:01 <lambdabot> You have a karma of 16
15:18:04 <emu> > let haskell++ "1" = "2" in ()
15:18:04 <Saizan> ?where zlib
15:18:04 <lambdabot> darcs get http://haskell.org/~duncan/zlib
15:18:05 <lambdabot>  ()
15:18:08 <emu> @karma haskell
15:18:08 <lambdabot> haskell has a karma of 18
15:18:22 <sorear> who pushed the patch that made java-matching case insensitive?
15:18:34 <SamB> > let haskell+ "1" = "2" in haskell
15:18:35 <lambdabot>   Not in scope: `haskell'
15:18:40 <SamB> > let haskell++ "1" = "2" in haskell
15:18:40 <lambdabot>   Not in scope: `haskell'
15:18:48 <bd_> @karma haskell
15:18:48 <lambdabot> haskell has a karma of 19
15:19:15 <emu> so multiple plugins get a scan at it
15:19:16 <SamB> > let haskell++ "1" = "2" in "x" ++ "3"
15:19:17 <lambdabot>   Non-exhaustive patterns in function ++
15:19:30 <monochrom> May I say something now?
15:19:37 <shapr> NO
15:19:41 * shapr cackles evilly!
15:19:51 <shapr> Oh ok.
15:20:00 <dons> cain--: you're  trying to use 'stack' as a mutable variable
15:20:04 <fasta> You need to get permission first from everyone.
15:20:11 <dons> you need to thread it through your code (or use a state monad)
15:20:21 <cain--> what?
15:20:22 <cain--> ^^
15:20:23 * dons hacks 
15:20:28 <cain--> i dont get nothing
15:20:31 <fasta> dons: I think you are giving "complicated advice".
15:20:34 <fasta> :)
15:20:36 <cain--> y
15:20:48 <fasta> cain--: you need to say what you want.
15:20:58 <cain--> i did
15:20:59 <fasta> cain--: What's an "operator"?
15:21:06 <SamB> cain--: you get something?
15:21:09 <SamB> that is nice
15:21:10 * sorear runs his daily masspull
15:21:11 <cain--> + , - , * or /
15:21:12 <SamB> what do you get?
15:21:25 <fasta> cain--: I know what _an_ operator is.
15:21:33 <fasta> cain--: What's your operator value?
15:21:50 <cain--> ?
15:21:58 <fasta> cain--: Your stack can only hold elements of the same type.
15:22:08 <dons> the problem is that you set up a local Stack, but don't pass it around
15:22:13 <cain--> yes and it only should hold chars
15:22:14 <fasta> cain--: Putting 1 2 and (+) on the stack is not going to work.
15:22:16 <dons> i'll try to fix this , so you can see what's going on
15:22:37 <cain--> were takling about chars here
15:22:53 <fasta> cain--: push 'h' $ push 'i' $ Nil ?
15:23:19 <cain--> i know how to use it
15:23:22 <fasta> cain--: That gives you "ih" when you look from the top of the stack
15:23:32 <cain--> did you look into my program?
15:23:44 <cain--> i already implemented the stack
15:23:54 <fasta> cain--: I only saw your stuff you put in the channel. I missed the paste.
15:23:57 <cain--> and i of course know how it works
15:24:04 <cain--> http://hpaste.org:8000/62
15:24:31 <cain--> ok
15:24:42 <cain--> (5+6) is 56+ in postfix
15:24:59 <cain--> so i need to print 5 and 6 und push + on the stack
15:25:10 <cain--> and pop it in the end
15:25:30 <cain--> but i dont know how to define a stack like i would do in java or so
15:25:40 <cain--> like a global var
15:25:48 <emu> no global vars
15:25:55 <cain--> i know and thats the problem
15:26:08 <fasta> cain--: dons already gave you the answer, in that case.
15:26:12 <emu> function parameters
15:26:21 <cain--> yes
15:26:39 <cain--> but i have to write a function which has no stack as a parameter
15:26:43 <cain--> by definition
15:26:59 <psnl> cain--: I'm evil, and do functions of type add :: Stack -> [(Stack, answer)]
15:27:01 <emu> so it starts off with an empty stack
15:27:03 <cain--> and i dont see the sense in this point in haskell
15:27:18 <emu> and returns a stack
15:27:23 <emu> ?
15:27:39 <hpaste>  dons annotated "my prog" with "better" at http://hpaste.org:8000/62#1
15:27:42 <dons> cain--: ^^
15:27:44 <psnl> want a really simple stack based calc?
15:27:59 <dons> cain--: the local stack is created on entry to 'convert'
15:28:04 <dons> and only visible locally
15:28:18 <cain--> ok let me see what u did
15:28:19 <monochrom> Listen to dons.
15:28:32 <dons> that way you can run multiple 'convert's in parallel , or in other threads, without worrying about clobbering a global stack
15:28:46 <monochrom> dons++
15:29:13 <dons> i'm not sure i got the semantics for your ')' case right, though. couldn't quite work out what you wanted to do there. but you get the general idea now?
15:29:25 <cain--> ohh thats how it works
15:29:27 <cain--> thank you
15:29:32 <dons> :)
15:29:44 <dons> here', i'll show you a little state monad version, just for fun
15:30:11 <cain--> ok
15:30:42 <emu> dons is a good example of a purely functional programmer.  he runs multiple helper threads in parallel without clobbering anything.
15:31:02 <cain--> :)
15:31:04 <psnl> most fp people do that
15:31:37 <monochrom> I was once a TA of a java programming class, I was responsible for testing student code.  They had to hand in an iterator.  I announced to them: one test obtains two iterator instances from you and use them concurrently!  This defeated all hopes of shared variables.
15:32:07 <mauke> no, you just need two sets of shared vars
15:32:10 <monochrom> @remember emu dons is a good example of a purely functional programmer.  he runs multiple helper threads in parallel without clobbering anything.
15:32:11 <lambdabot> Done memoising quote for `emu', if that is their real name...
15:32:11 <shapr> I like PaulAJ's brilliant quote.
15:32:24 <shapr> @quote overwriting
15:32:25 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
15:32:27 <shapr> hmm
15:32:27 <fasta> What does '(' mean in this language?
15:32:34 <shapr> @quote Paul
15:32:34 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
15:32:34 <lambdabot> entire human race would have to be rewritten!
15:32:44 <sorear> @quote manual.memory
15:32:44 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
15:32:49 <shapr> hmm
15:32:53 <sorear> @google HWM
15:32:53 <cain--> is there any debugger for haskell
15:32:55 <lambdabot> http://www.hwm.co.uk/
15:32:55 <lambdabot> Title: HWM Aston Martin
15:32:59 <sorear> cain--: plenty
15:33:07 <fasta> sorear: oh, really?
15:33:16 <cain--> i searched at google but didt find a good one
15:33:19 <sorear> cain--: "Standards are great, there are so many to choose from"
15:33:24 <shapr> @remember PaulAJ Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what other part of the program might have been using it.
15:33:24 <lambdabot> Done memoising quote for `PaulAJ', if that is their real name...
15:33:33 <sorear> cain--: we have dozens of debuggers, and IIRC they all suck
15:33:35 <emu> i remember that
15:33:43 <fasta> sorear: ah, ok.
15:33:46 <emu> the best debugger is referential transparency
15:33:50 <zarvok> hmm, good quote!
15:33:52 <shapr> cain--: Most Haskell users don't use debuggers.
15:33:58 <cain--> omg
15:34:04 <fasta> shapr: because they don't exist
15:34:04 <zarvok> the best debugger is a good haskell programmer
15:34:07 <cain--> but i cant evaluate that well
15:34:09 <shapr> cain--: but wait! there's a really good reason for that.
15:34:20 <shapr> fasta: Nah, that's not really it.
15:34:25 <shapr> @quote debugg
15:34:25 <lambdabot> lennart says: the best way of debugging is to understand your code
15:34:28 <shapr> @quote debugg
15:34:29 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
15:34:35 <zarvok> heh
15:34:52 <cain--> -.-
15:35:13 <fasta> shapr: You don't know that. From experience I know that something like Hat could be _very_ useful.
15:35:29 <emu> yea Hat could be .. if you can make it work
15:35:31 <shapr> fasta: It's true, I can only judge from my own experience.
15:35:43 <shapr> fasta: And from what I've seen here on #haskell, and on the mailing lists.
15:36:18 <vincenz> hey zarvok
15:36:23 <vincenz> zarvok: still waiting for the tools :)
15:36:26 <cain--> dons: its now quite working
15:36:33 <cain--> hmm
15:36:41 <fasta> shapr: I want to know the complete call history of what happened when I get fromJust *** Exception pattern match failure Nothing.
15:36:43 <cain--> but i have to fix it myself nvm
15:36:52 <shapr> fasta: That's a good point.
15:37:08 <vincenz> fasta: or dependent typing
15:37:21 <fasta> shapr: Not just a line number, since obviously my mental model of the program isn't the same as what it's doing.
15:37:32 <shapr> I'm convinced (possibly totally wrongly) that the fastest solution to solve that kind of program is to understand your program, rather than getting a stack trace.
15:37:46 <zarvok> vincenz: we'll do it eventually, I promise :)
15:37:53 <zarvok> sorry about the slowness
15:37:55 <psnl> pp please don't have the debugger argument now
15:37:58 <monochrom> It is impractical to ask programmers to understand programs.
15:38:00 * monochrom ducks
15:38:00 <vincenz> zarvok: no need to apologize, you guys did great work
15:38:01 <shapr> psnl: heh
15:38:13 <fasta> vincenz: I never tried dependent typing, since Epigram didn't compile.
15:38:13 <malsyned> shapr: couldn't the argument be made that the fastest path to understanding your program when you find that you don't is with the aid of a stack trace?
15:38:16 <SamB> monochrom: well, at least, programs that do not work
15:38:24 <zarvok> thanks
15:38:33 * monochrom shows up momentarily
15:38:40 <vincenz> fasta: nor I, but afaict it'd do that
15:38:40 <monochrom> It is impractical to ask programs to work.
15:38:41 <shapr> malsyned: Yeah, that could be true. I don't think it is, but it's possible.
15:38:43 * monochrom ducks again
15:38:51 <vincenz> monochrom: impractical prorams work
15:38:58 <shapr> I think that unit tests and added typing will give more of a long term benefit though.
15:39:01 <SamB> monochrom: yes, because if they don't work they are not likely to listen to your request
15:39:02 <vincenz> it's just those practical ones, with IO and stuff like that
15:39:19 <SamB> vincenz: also parsers
15:39:31 <SamB> btw, your solution didn't quite work...
15:39:33 <vincenz> SamB: what?
15:39:41 <malsyned> shapr: I'd actually argue that a stack trace is just a crude approximation of the actual best forensic method of understanding what a program is doing: a complete execution trace log
15:39:44 <vincenz> SamB: yeah, and you still havent told me what "quite work" means
15:40:01 <SamB> well, I ran it on something like "x + y" and it failed
15:40:02 <monochrom> We have to record this conversation.  Next time "debugging" is brought up, we can just replay the recorded conversation and save typing. :D
15:40:16 <psnl> monochrom: yeah, that would be cool
15:40:23 <Anon4888> When your program is deployed and a user reports that it doesn't work in some situation ("I clicked on X and it crashed") it is invaluable to have a dump recreating what happened
15:40:24 <SamB> malsyned: what the heck is an "execution trace log"?
15:40:29 <vincenz> monochrom: I love how you can take a double view on 'typing'
15:40:33 <psnl> sounds like a hat trace
15:40:33 <SamB> anyway, I think I like the SCC stack trace
15:40:34 <shapr> malsyned: An execution trace log isn't so helpful in the non-strict world because programs effectively 'modify themselves'.
15:40:43 <SamB> at least in principal
15:40:49 <fasta> I never used the word "stack trace".
15:40:51 <SamB> or principle or whatever
15:40:52 <Anon4888> ** Even if it's just deployed to testers
15:40:54 <vincenz> SamB: repaste?
15:40:58 <vincenz> SamB: got a bit more time now
15:41:04 <SamB> oh, well, I fixed it
15:41:10 <SamB> your basic method *did* work
15:41:39 <fasta> SamB: how does that work?
15:41:53 <shapr> I'm not sure I could ever debug a program that's both lazy and uses mutable values.
15:41:54 <SamB> vincenz: http://naesten.dyndns.org:8080/repos/hSelf/
15:41:55 <fasta> SamB: that = "SCC stack trace"
15:42:06 <vincenz> SamB: not found
15:42:10 <SamB> fasta: +RTS -xc
15:42:15 <SamB> vincenz: oh?
15:42:19 <fasta> SamB: what does it do?
15:42:23 <psnl> "Monads are a way of writing imperative code in Haskell. " <- flame me now, I'm cold
15:42:31 <SamB> oh, yeah...
15:42:33 <SamB> vincenz: http://naesten.dyndns.org:8080/repos/hSelf2/
15:42:37 <lambdabot> Title: Directory listing for /repos/hSelf2/
15:42:49 * SamB forgot he added a "2" to distinguish it from an earlier attempt
15:43:02 <SamB> nevermind that that attempt is in a different directory
15:43:11 <vincenz> SamB: that seems a lot more limiting
15:43:16 <emu> monads are a generalization of functions used to compose IO actions
15:43:25 <SamB> vincenz: hmm?
15:43:37 <Anon4888> Monads are dumb.
15:43:38 <vincenz> SamB: you can only do binary messages on binary messages, not mix unary and binary
15:43:44 <SamB> oh.
15:43:46 <monochrom> I s/are/provide/ to psnl's point.
15:43:57 <SamB> probably a typo
15:44:04 <fasta> SamB: Could you briefy give the semantics for xc?
15:44:06 <luqui> is there someone here who knows how type inference algorithms work?  I have a few questions?
15:44:11 <psnl> monochrom: thanks, actually
15:44:18 <SamB> vincenz: hmm, no, look closer
15:44:32 <SamB> "binaryExpression" means binary *or* unary
15:44:36 <vincenz> SamB: I can't focus closer
15:44:38 <SamB> or base
15:44:49 <vincenz> my eyes aren't wired like that
15:44:59 <vincenz> SamB: ah right
15:44:59 <chessguy> luqui, you're more likely to get a response if you just ask your question
15:45:05 <SamB> well, I mean, follow the thingies around
15:45:17 <vincenz> SamB: yeah I didn't know the full syntax of self, I just went with the obvious hole
15:45:27 <vincenz> but it seems the principle needed to be expanded a bi
15:45:28 <vincenz> t
15:45:33 <luqui> hmm.  it's kind of a difficult question to phrase, but I'll try.
15:45:37 <SamB> the problem, I think, was actually not where you found it
15:45:59 <SamB> I think the problem was actually in unaryMessage
15:46:30 <malsyned> fasta: you said "the complete call history".  I guess I just assumed you meant "stack trace"
15:46:42 <luqui> Going of something like the hindley-milner algorithm, where you generate equations and solve them, I'm wondering when generalization happens.  That is, if we have f :: a -> a for some variable a, when do we put forall a. in front of it?
15:46:50 <SamB> malsyned: most of the calls won't be *on* the stack
15:48:03 <SamB> I'm not exactly sure what "complete call history" means, but "SCC" means "source cost center", and an SCC stack is used by GHC's profiler...
15:48:09 <luqui> is it at the very end, or can you do it in the middle of the solving process somewhere (so that its polymorphic nature can be used later)?
15:48:10 <hpaste>  cain annotated "my prog" with "reviewed" at http://hpaste.org:8000/62#2
15:48:14 <fasta> SamB: I know that part.
15:48:19 <cain--> dons:
15:48:25 <cain--> http://hpaste.org:8000/62#2 i modified it
15:48:29 <fasta> SamB: xc prints a sorted list of most expensive cost centre, IIRC
15:48:31 <dons> cain--: hey, sorry , got distracted with my code
15:48:35 <SamB> fasta: oh?
15:48:39 <cain--> but i get an error
15:48:47 <fasta> SamB: I can very well be wrong.
15:48:49 <mkfx> Hey, is there a function to get the number of digits in an integer?
15:48:51 <SamB> I thought it showed the SCC stack upon encountering an exception?
15:48:59 <dons> [top e] ++ eval xs (pop e) is top e : eval xs
15:49:16 <chessguy> dons is coding? and here i thought he spent all his time doing research for his thesis
15:49:24 <dons> cain--: also, eval ('(':xs) _ = convert xs   == eval xs
15:49:24 <cain--> hmm
15:49:25 <monochrom> mkfx: try length(show n)
15:49:25 <fasta> SamB: ok, so the last called SCC is on top?
15:49:27 <dons> not convert xs
15:49:33 <dons> eval xs e
15:49:39 <malsyned> mkfx: log base 2 gets you pretty close
15:49:40 <dons> eval ('(':xs) e = eval xs e
15:49:41 <cain--> ohh yes
15:49:57 <fasta> SamB: Does it also work for infinite recursion?
15:50:03 <mkfx> solid, thanks monochrom
15:50:14 <chessguy> what on earth is '
15:50:15 <SamB> probably the SCC stack does not include argument values
15:50:23 <SamB> fasta: *of course*
15:50:24 <malsyned> mkfx: er, log base 10.
15:50:35 <SamB> what kind of profiler wouldn't work on infinite loops?
15:50:40 <fasta> SamB: Ok, fantastic. Thanks
15:50:52 <SamB> I'm not exactly sure what it looks like though
15:51:04 <fasta> SamB: do you know what the cost-centre f5$ is?
15:51:13 <SamB> no
15:51:14 <fasta> SamB: I didn't insert the cost-centre.
15:51:19 <cain--> ok it works!
15:51:26 <cain--> thank you
15:51:37 <cain--> its so much code in java ;)
15:51:38 <SamB> you might want to say -fext-core
15:51:41 <dons> heh
15:51:43 <SamB> when building your program
15:51:45 <chessguy> @karma cain
15:51:45 <lambdabot> cain has a karma of -9
15:51:49 <cain--> ;(
15:51:54 <chessguy> lol
15:51:57 <dons> due to the --
15:51:59 <chessguy> yes
15:52:21 <cain`> @karma cain
15:52:21 <lambdabot> cain has a karma of -9
15:52:22 <dons> damn these semantically rich channels!
15:52:23 <luqui> do cain++
15:52:32 <luqui> then I will change my name to cain
15:52:37 <dons> @karma cain'
15:52:37 <lambdabot> cain' has a karma of 0
15:52:38 <cain`> ...
15:52:41 <dons> @karma cain`
15:52:41 <lambdabot> cain` has a karma of 0
15:52:55 <chessguy> @karma cain--
15:52:56 <lambdabot> cain-- has a karma of 1
15:52:58 <mux> @karma haskell
15:52:58 <lambdabot> haskell has a karma of 20
15:52:59 <sorear> @karma cain--|cain`
15:52:59 <lambdabot> cain--|cain` has a karma of 1
15:53:00 <SamB> or maybe that show-iface thing ?
15:53:02 <cain`> but cain is aleays in use
15:53:11 <mux> @karma scheme
15:53:11 <lambdabot> scheme has a karma of -1
15:53:14 <mux> heh
15:53:21 <sorear> stefan was taken
15:53:28 <fasta> @karma scheme++
15:53:28 <lambdabot> scheme++ has a karma of 0
15:53:57 <mux> @karma category_theory
15:53:58 <lambdabot> category_theory has a karma of 0
15:54:02 <mux> @karma+ category_theory
15:54:02 <lambdabot> category_theory's karma raised to 1.
15:55:30 <chessguy> well, that was a conversation-killer
15:55:46 <edwinb> Category theory often is
15:56:08 <Pseudonym> Greetings.
15:56:14 <psnl> hey edwinb
15:56:15 <chessguy> no wonder i kept failing to get a second date after bringing up category theory on the first
15:56:23 <mux> hahah
15:56:28 <edwinb> you'd think the chicks would love that
15:56:33 <allbery_b> isn' there an xkcd about that? :)
15:56:34 <edwinb> hi psnl
15:56:38 <luqui> yeah, you'd think
15:56:43 <Pseudonym> For some reason, this cartoon seems appropriate:
15:56:45 <cain`> how do i define an else here?
15:56:45 <cain`> clean (x:xs)
15:56:45 <cain`>     | x == ' ' = clean xs
15:56:48 <chessguy> edwinb, weird huh?
15:56:49 <Pseudonym> http://spamusement.com/index.php/comics/view/221
15:56:51 <lambdabot> Title: Spamusement! Poorly-drawn cartoons inspired by actual spam subject lines! First  ...
15:56:57 <allbery_b>     | otherwise = ...
15:56:58 <luqui> cain`, | otherwise =
15:57:00 <cain`> ok
15:57:12 <chessguy> women are so unpredictable
15:57:31 <astrolabe> > otherwise
15:57:32 <lambdabot>  True
15:58:04 <Pseudonym> chessguy: Just a suggestion, topics like that are much more common on #haskell-blah
15:58:06 <allbery_b> yeh, but otherwise is idiomatic (and reads better)
15:58:26 <chessguy> what's that, women?
15:58:30 <astrolabe> And we need more chat on haskell-blah!
15:58:32 <chessguy> or category theory?
15:58:44 <Pseudonym> Category theory here, bad dates there.
15:59:15 <astrolabe> We'd even talk about CT if we had to
15:59:18 <chessguy> ah, that was just a joke. i'm engaged, so haven't had to worry about getting a second date in a long time :)
15:59:27 <Pseudonym> :-)
15:59:41 <psnl> allbery_b: ITYM http://xkcd.com/c69.html
15:59:42 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
15:59:56 <chessguy> these cartoons are really stupid
16:00:04 <Pseudonym> Wait until you have kids.  Dating?  What's that?
16:00:06 <chessguy> xkcd is much cooler
16:00:29 <edwinb> oh, great, another webcomic to read...
16:00:30 <chessguy> ah yes, that's a good one, psnl
16:00:42 <emu> allbery_b: did you see the xkcd on weh?
16:01:01 <psnl> chessguy: congratulations
16:01:16 <chessguy> psnl, eh?
16:01:33 <Pseudonym> The coolest bit about spamusement, though, is you can submit your own.
16:01:53 <psnl> chessguy: on being engaged
16:02:03 <emu> at least he wasn't thinking about the Floyd-Warshall algorithm
16:02:13 <chessguy> psnl, oh! thank you. sorry, i got distracted by the cartoons :)
16:02:16 <psnl> I hadn't heard until now
16:02:23 <Pseudonym> How much can you really think about the Floyd-Warshall algorithm?
16:02:40 <emu> about as much as Bellman Ford?
16:02:51 <chessguy> ah, just happened a couple days before Christmas
16:05:40 <Pseudonym> The problem with the Floyd-Warshall algorithm, BTW, is that it's horrible on any representation other than bit vectors.
16:05:48 <emu> yea it is
16:06:00 <emu> i just came across it while solving a similar but simpler problem
16:06:40 <fasta> But no implementation in Haskell widely available.
16:06:45 <Procyon> I just finished my first "non tutorial" peice of code. I have to say that having to think about fixity, left|right associations and precedence hurts my brain in haskell.  I hope it becomes more natural.
16:07:17 <luqui> Procyon, do you mean for defining your own operators, or are you writing a parser?
16:07:19 <sorear> it trips up experts, yes, but mostly it "just works"
16:07:41 <emu> is there a need for a Floyd-Warshall implementation?
16:07:53 <luqui> Procyon, because I usually find that I don't have to worry about that stuff in haskell.  I just remember than function application is the tightest, and everything else is looser
16:07:59 <fasta> emu: probably not, but there is for other algorithms.
16:08:07 <chessguy> emu, according to wikipedia, it's used when there are negative weights
16:08:11 * hyrax42 polls #haskell
16:08:13 <chessguy> because then dykstra's can't be
16:08:17 <emu> no, that's bellman ford
16:08:20 <Pseudonym> emu: Do we have a bit matrix implementation?
16:08:23 <chessguy> oh, sorry
16:08:29 <emu> floyd-warshall is all-pairs shortest path
16:08:31 <chessguy> mis-read
16:08:41 <Procyon> luqui: Yes, I'm writing a parser.. but my problems are in haskell.  I'm really close to just explicitly parenthesising everything so I don't have to worry about ordering.
16:08:51 <emu> and i have an implementation of bmf which i used to test my simple temporal network algorithm
16:08:56 <hyrax42> of the two ideas to investigate, which is "better" (bring your own Ord instance)
16:09:23 <sorear> hyrax42: what ideas?
16:09:23 <chessguy> hmm, byoOi
16:09:24 <luqui> Procyon, that's what I do, for some definition of "parenthesize" (I use $ a lot)
16:09:27 <hyrax42> a) DiffTable (Г  la DiffArray)
16:09:29 <astrolabe> Procyon: Don't do it!
16:09:40 <hyrax42> b) investigating making haskell callable from python
16:09:56 <hyrax42> (there exists a bridge in the reverse direction)
16:09:58 <Procyon> luqui: the whole $ vs . vs () application order is another level of though I don't like when chaining long lists of function calls.
16:10:05 <sorear> hyrax42: my (>) gives _|_ on those two
16:10:09 <emu> isn't (b) doable via ffi
16:10:13 <astrolabe> Procyon: it's easy to remember that function application (ie juxtaposition) binds more tightly than anything else.
16:10:46 <luqui> Procyon, oh, okay. well, that aspect will become more natural.
16:10:47 <hyrax42> emu: ought to be, but making it nice on the haskell side isn't free
16:10:49 <chessguy> juxtaposition?
16:10:55 <hyrax42> sorear: fair enough
16:11:03 <emu> well i don't care much for python, so I vote (a)!
16:11:07 <sorear> Yay, I'm back to getting 3x more from haskell-cafe than all spammers combined!
16:11:23 <fasta> A placing or being placed in nearness or contiguity, or side by side; as, a juxtaposition of words.
16:11:29 <hyrax42> I'm just feeling like I need to do something useful
16:11:35 <chessguy> @dict-all justaposition
16:11:36 <lambdabot> Unknown command, try @list
16:11:36 <hyrax42> and haskell-related
16:11:44 <ray> speaking of haskell-cafe, is there a nice list of haskell mailing lists somewhere
16:11:46 <chessguy> ?list
16:11:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:11:47 <sorear> @all-dicts juxtaposition
16:11:49 <lambdabot> *** "Juxtaposition" gcide "The Collaborative International Dictionary of English v.0.48"
16:11:49 <lambdabot> Juxtaposition \Jux`ta*po*si"tion\
16:11:49 <lambdabot>    (j[u^]ks`t[.a]*p[-o]*z[i^]sh"[u^]n), n. [L. juxta near +
16:11:49 <lambdabot>    positio position: cf. F. juxtaposition. See {Just}, v. i.,
16:11:49 <lambdabot>    and {Position}.]
16:11:51 <Pseudonym> Dammit, I'm trying to find that transitive closure algorithm that I read about.
16:11:51 <lambdabot> [34 @more lines]
16:11:53 <chessguy> oh, i was close
16:12:00 <Pseudonym> The one on sets rather than bitvectors.
16:12:01 <sorear> ray: yes
16:12:08 <sorear> http://haskell.org/pipermail/
16:12:12 <Pseudonym> I have a sneaky suspicion that it's from the DeRemer and Pennello paper.
16:12:34 <allbery_b> ?wiki Mailing_lists
16:12:34 <lambdabot> http://www.haskell.org/haskellwiki/Mailing_lists
16:15:48 <ray> thanks
16:21:03 <sorear> @users
16:21:03 <lambdabot> Maximum users seen in #haskell: 322, currently: 293 (91.0%), active: 48 (16.4%)
16:31:34 <sorear> dons: why typeof fmap?
16:32:46 <dons> its nice
16:33:03 <dons> :t Data.Generics.everywhere
16:33:05 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
16:52:34 <syntaxfree> Pseudonym: sneaky!
16:52:37 <syntaxfree> @quote sneaky
16:52:37 <lambdabot> No quotes match. Do you think like you type?
16:52:38 <br1> I'm not seeing any output from -ddump-rules for foldr (+) 0 . map (+1).  Why's that?
16:52:53 <Pseudonym> What's sneaky?
16:52:55 <syntaxfree> @quote suspicion
16:52:56 <lambdabot> No quotes match. stty: unknown mode: doofus
16:53:03 <syntaxfree> Pseudonym: your suspicion!
16:53:21 <Pseudonym> ?quote suspect
16:53:21 <lambdabot> dons says: so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses since most people don't understand bug theory ;)
16:53:24 <Pseudonym> ?quote suspect
16:53:24 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
16:53:26 <Pseudonym> ?quote suspect
16:53:26 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
16:53:34 <Pseudonym> ?
16:53:58 <syntaxfree> 10:08 PM  Pseudonym: I have a sneaky suspicion that it's from the DeRemer and Pennello paper.
16:54:22 <Pseudonym> Ah.
16:54:42 <syntaxfree> heh. @. google quote is funny.
16:54:43 <Pseudonym> It turns out that the algorithm in there isn't quite what I thought.  It's actually a generalisation.
16:55:05 <syntaxfree> @. google quote
16:55:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote
16:55:12 <syntaxfree> oh.
16:55:20 <jcreigh> heh
16:56:10 <syntaxfree> I didn't expect the spanish inquisition.
16:56:39 <jcreigh> naturally.
16:57:33 <syntaxfree> @. google quote
16:57:38 <lambdabot> http://www.oreillynet.com/onlamp/blog/2003/03/the_knuth_indentation_quote_re.html
16:57:38 <lambdabot> Title: The Knuth Indentation Quote rediscovered - O&#039;Reilly ONLamp Blog
17:00:21 <Pseudonym> Gah!
17:00:26 <Pseudonym> One of my quotes is misspelled.
17:00:45 <sorear> Pseudonym: for several weeks by IRC realname was misspelled!
17:01:48 <Igloo> @seen dons
17:01:48 <lambdabot> dons is in #happs, #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 28m 44s ago.
17:03:52 <dons> yeah?
17:03:52 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:04:14 <Igloo> dons, is http://hackage.haskell.org/trac/ghc/ticket/997 waiting for anything?
17:04:16 <lambdabot> Title: #997 (Add Kleisli composition to Control.Monad) - GHC - Trac
17:04:41 <dons> ah no.
17:04:43 <dons> its ready to go
17:05:15 <Igloo> OK, thanks
17:05:32 <syntaxfree> @. google seen
17:05:32 <lambdabot> Empty search.
17:05:37 <dons> pretty simple, and uncontroversail in the end
17:08:36 <Igloo> Applied
17:09:22 <dons> great!
17:09:24 <dons> Igloo++
17:10:50 <vincenz> @seen
17:13:45 <br1> help?
17:13:57 <vincenz> br1: drowning?
17:14:10 <newsham> my diff code last night was buggy.
17:14:17 <newsham> bad initial conditions.
17:16:29 <br1> something like that, yeah
17:16:30 * vincenz misread that as "bad weather conditions"
17:16:36 <br1> br1: I'm not seeing any output from -ddump-rules for foldr (+) 0 . map (+1). Why's that?
17:16:51 <psnl> "it was sunny so I coded less"
17:16:55 <sorear> br1: -Onot :)
17:17:03 <dons> newsham: oh, i've got a patch for the diff code
17:17:06 <dons> before you start hacking it...
17:17:10 <dons> you want a darcs patch?
17:17:18 <vincenz> @lcs dons psnl
17:17:19 <lambdabot> Maybe you meant: docs let list rc
17:17:22 <newsham> dons: tihs is my own code i was goofing with lsat night while talking w/ glguy
17:17:30 <dons> ah ok
17:17:32 <newsham> not based on the one in hpaste
17:17:32 <dons> not the stuff in hpaste?
17:17:33 <vincenz> lcs gone?
17:17:35 <dons> right
17:17:56 <newsham> here is the latest (fixed, somewhat tested): http://www.thenewsh.com/~newsham/x/diff4.hs
17:18:03 <br1> sorear: I'm doing ghc -C -O2 -fext-core mod.hs -ddump-rules
17:19:01 <sorear> now if only we had polymorphic memofix ...
17:19:25 <br1> newsham: I think flip mapM_ is forM_
17:19:57 <sorear> br1: forM_ is 6.6 only
17:20:42 <newsham> br1: yup.. i just didnt import control.monad
17:20:47 <vincenz> lysoforM
17:23:24 <br1> sorear: Any idead about the rules business?
17:23:35 <ph6> Can anyone offer some insign into debugging parse errors? Says possibly incorrect indentation but I can't see anything obvious
17:23:53 <sorear> ph6: @paste it
17:23:55 <sorear> @paste
17:23:55 <lambdabot> http://hpaste.org (Haskell pastebin)
17:25:20 * Igloo looks up - what's this about lcs code?
17:25:35 <dons> ph6, paste it
17:25:49 <ph6> sorear: I don't even know what I would show you, I'm using alex to generate a .hs and ghc is making reference to my alex .x file in a line far beyond the file
17:25:54 <hpaste>  br1 pasted "silent rules" at http://hpaste.org:8000/63
17:26:30 <sorear> ph6: yow?  paste the .x, preprocessors mess up line numbers
17:27:23 <ph6> http://hpaste.org:8000/64
17:27:58 <SamB> at least happy doesn't try to output those line directives...
17:28:13 <sorear> ph6: if you were just going to announce it, why'd you check Silent?
17:28:32 <ph6> sorear: does it matter? :`)
17:29:02 <Igloo> ph6: That's the complete error?
17:29:09 <sorear> ph6: glguy and I want to make this very easy.
17:29:27 <glguy> sorear: fill out annotations forms, check
17:29:28 <ph6> igloo: yes, that is the full error ghc gives when I invoke ghc m-minus.hs
17:29:38 <SamB> ph6: yes, it matters!
17:29:44 <sorear> why is there a } after main?
17:29:47 <SamB> psychological factors are important
17:29:55 <hpaste> i feel cheated :'-(
17:30:06 <ph6> sorear: Because it was opened before the data type definition
17:30:09 <Igloo> ph6: Can you paste lines 100-120 of the .hs file please?
17:30:17 <vincenz> Igloo: :D
17:30:26 <Igloo> vincenz: ?
17:30:43 <vincenz> Igloo: nothing, same thought here... Comment about an error on line 110 and it only has 106 lines or
17:30:48 <vincenz> ...so
17:31:01 <Igloo> ph6: Hang on, what are the backslashes before Alex?
17:31:05 <hpaste>  ph6 pasted "100-120" at http://hpaste.org:8000/65
17:31:25 <vincenz> ph6: no the lines 100-120 of the .x file
17:31:30 <ph6> ER
17:31:45 * glguy encourages the use of annotations for related pastes :)
17:31:53 <sorear> ph6: use sed to remove all the {-# LINE #-} from the .x
17:31:58 * vincenz concurs with glguy 
17:32:01 <ph6> the .x is only 103 lines, total.
17:32:18 <vincenz> ph6: it must be at least 104
17:32:23 <vincenz> the closing } is on 104
17:32:25 <sorear> ph6: ok, but with the {-# LINE #-} ghc compains
17:32:33 <sorear> braino
17:32:46 <Igloo> Oh, yes, it's not giving real line numbers
17:32:53 <sorear> ph6: ok, but with the {-# LINE #-} ghc will mis-identify the failing line as belonging to your program
17:32:54 <ph6> vincenz: wc says otherwise :)
17:32:59 <glguy> sorear: the FORMAT button show support starting line number?
17:33:09 <glguy> s/show/should?
17:33:19 <ph6> sorear: so I should strip these LINE \d+ then I will have useful error lines?
17:33:21 <vincenz> ph6: well your /64 paste disagrees with you
17:33:23 <sorear> glguy: no! everyone counds from 0!
17:33:26 <sorear> :)_
17:33:37 <glguy> just an idea :-p
17:33:40 * vincenz compains about counding from 0
17:33:41 <sorear> ph6: is there a 10 and the end of your file?
17:33:49 <sorear> if it is missing wc will be confused
17:34:04 <sorear> * a 10 at, note 10 == ASCII NL
17:34:27 <vincenz> sorear: we're going back to the 90's, why all the modem-talk?
17:34:54 <ph6> sorear: Ah, yeah, no new line at the end :)
17:35:08 <sorear> vincenz: slipup, sorry
17:35:16 * sorear isn't that old.  Really!
17:36:01 <SamB> um, I used modem until sometimes last year!
17:36:27 <vincenz> aha!
17:36:32 <vincenz> line 74 in paste 64!
17:36:39 <vincenz> 'skip a i' is badly inlined
17:36:47 <vincenz> erm, indented
17:37:15 <ph6> it's a tab and then a space
17:37:23 <vincenz> EWWWW
17:37:25 <vincenz> tabs are evil
17:37:27 <syntaxfree> a nod & a wink.
17:37:49 <syntaxfree> layout is whack. I never use it.
17:37:56 <ph6> vincenz: so what should it be aligned with, then?
17:38:01 <syntaxfree> I indent code, but keep the braces and semicolons.
17:38:10 <sorear> @tell glguy idea: handle tabs "properly"
17:38:10 <lambdabot> Consider it noted.
17:38:18 <vincenz> syntaxfree: ah right, and your brain is whack too ?
17:38:25 <hpaste> glguy glguy: highlight test
17:38:29 <vincenz> ph6: erm, the line before it?
17:38:34 <glguy> sorear?
17:38:34 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:38:41 <syntaxfree> maybe :)
17:38:52 <vincenz> what is "< hpaste> glguy glguy: highlight test
17:38:54 <sorear> glguy: go to paste 64, line 74.
17:39:05 <glguy> sorear: OHHH
17:39:07 <glguy> those tabs
17:39:09 <sorear> glguy: compare the indenting with v. without linenumbers
17:39:11 <ph6> vincenz: aligning it with the rest of the do still produces the same line 110 error
17:39:18 <dons> glguy: ok. done with new compressed state and -Wall works everywhere
17:39:25 <glguy> dons: already?
17:39:26 <sorear> what other kind were you thinking of?
17:39:32 <glguy> sorear: browser tabs
17:39:37 <vincenz> ph6: odd
17:39:43 <sorear> oh, those tabs.
17:39:49 <glguy> sorear: I was trying to figure out what browser behavior you were asking for
17:39:51 <syntaxfree> all this time spent debugging layout.
17:39:59 <syntaxfree> it'd be faster to type the delimiters out.
17:40:12 <ph6> vincenz: I copied that from another file that was known to compile anyways, so I wasn't much worried.
17:40:30 <Igloo> Did the code and error without line pragmas get pasted?
17:40:30 <vincenz> ph6: my best guess is layout
17:40:57 * Igloo still doesn't get the backslashes before "Alex", either
17:41:04 <vincenz> ph6: this code stands on it's own
17:41:23 <vincenz> Igloo: good point
17:41:28 <vincenz> ph6: what are those \Alex thingies?
17:41:34 <ph6> dude I don't know
17:41:49 <ph6> it fucking worked right, so I stayed with it :)
17:42:15 <vincenz> ph6: simple question, this file stands on its own?
17:42:53 <ph6> yes, and it might be these \ fucking it up
17:42:56 <vincenz> ph6: erm
17:42:58 <vincenz> what about monadUser?
17:43:18 <ph6> vincenz: It's just a slight tweek, and works fine :)
17:43:20 <glguy> what's with all the cursing?
17:43:33 <vincenz> vincenz@abstractlappy:~$ alex minus.x
17:43:33 <vincenz> alex.bin: /usr/lib/alex-2.0.1/AlexWrapper-monadUser: openFile: does not exist (No such file or directory)
17:43:42 <vincenz> ph6: monadUser does not exst
17:43:48 <hpaste> notice, my state is being converted, new pastes after this announcement before the next announcement will be lost
17:44:03 <syntaxfree> there are good programming blogs out there.
17:44:07 * glguy needs a /notice command
17:44:14 <ph6> vincenz: Oh it does, just not on your system.
17:44:21 <vincenz> ph6: ....
17:44:25 <vincenz> ph6: I asked if that file stood on its own
17:44:26 -sorear(n=root@ip68-7-248-101.sd.sd.cox.net)- glguy: huh?
17:44:27 <allbery_b> oh, that's helpful :p
17:44:32 <syntaxfree> glguy: you need a mascot!
17:44:38 -glguy(n=eric@unaffiliated/glguy)- sorear: exactly!
17:44:40 <syntaxfree> I suggest we hold a mascot competition on the wiki.
17:45:02 * glguy wants to use small graphics on the front page for column headers
17:45:07 <glguy> (with alt tags for sorear)
17:45:14 <glguy> instead of words
17:45:36 <syntaxfree> I'm usually the darkest deepest person people know.
17:45:48 <vincenz> yeah ok
17:45:50 <vincenz> Igloo: I checked the line
17:45:54 <vincenz> Igloo: it's the \Alex crap
17:46:00 <syntaxfree> but here I look like a giggling cheerleader talking about superficial things!
17:46:13 <ph6> Dude it's lambda abstractions
17:46:24 <vincenz> ph6: Dude... you can't have uppercase variable names
17:46:29 * vincenz rolls his eyes
17:46:41 <vincenz> besides no it's not
17:46:46 <vincenz> there's no arrow after the \Alex thingy
17:46:50 * vincenz peers at ph6 
17:47:11 <ph6> I'm trying to wing it
17:47:13 <ph6> ;)
17:47:16 <Igloo> (as an aside, lambda abstractions take a pattern, not a variable name, so e.g. (\True -> 5) True == 5)
17:47:17 <vincenz> yeah well
17:47:19 <vincenz> I checked the line
17:47:24 <vincenz> Igloo: good point
17:47:26 <vincenz> but still missing an arrow
17:47:34 <Igloo> Right
17:47:36 <vincenz> anyways
17:47:40 <vincenz> the error is on one of those action lines
17:47:43 <vincenz> I checked the .hs file
17:47:46 <ph6> ok buddy
17:47:48 <ph6> thanks
17:47:54 <vincenz> could've done that yourself
17:48:11 <vincenz> look for the last LINE xxx "x-minus.x" in x-minus.hs
17:48:17 <vincenz> and then count down 110-xxx from there
17:48:31 <Nafai> @get-shapr
17:48:31 <lambdabot> shapr!!
17:48:42 <sorear> @localtime shapr
17:48:43 <lambdabot> Local time for shapr is Tue Jan 23 19:45:29 2007
17:49:49 <hpaste> glguy: beep test
17:50:26 <sorear> glguy:
17:51:04 <sorear>  - can anyone hear this?
17:51:09 <syntaxfree> glguy++
17:51:13 * glguy did not hear that
17:51:17 <glguy> sorear^^
17:51:29 * glguy did hear the beep from syntaxfree though :-D
17:51:39 <sorear> ?
17:51:59 <sorear> ?read "\BEL"
17:52:00 <lambdabot>  
17:52:49 * sorear wonders if there are any clients dumb enough to pass BEL
17:53:19 <glguy> \BEL is useful when not abused though...
17:53:26 <allbery_b> no beep here
17:53:57 <glguy> i a small channel at least
17:59:47 <sorear> @users #haskell
17:59:47 <lambdabot> Maximum users seen in #haskell: 322, currently: 280 (87.0%), active: 47 (16.8%)
18:01:17 <glguy> !id still alive
18:01:18 <hpaste> still alive
18:01:29 <sorear> hunk ./hpaste.cabal 14
18:01:29 <sorear> -other-modules:       PasteBot, PasteState
18:01:33 <hpaste> feel free to start making pastes
18:01:34 <sorear> dons: what gives?
18:01:59 <sorear> dons: other-modules is require for cabal to do the Right Thing with sdist
18:02:00 <dons> why do we need other-modules??
18:02:09 <dons> oh.../ sdist eh?
18:02:17 <dons> well what about the DiffHtml module?
18:02:22 <sorear> dons: cabal doesn't chase imports
18:02:33 <sorear> dons: <points at glguy>
18:02:43 <dons> yeah, but um, either we add DiffHtml, or we don't bother with the explicit list,
18:02:47 * glguy doesn't know anything about cabal
18:02:55 <dons> ok. sweet
18:02:58 <dons> its decompressing on the fly
18:03:09 * sorear goes and looks for the most vitriolic quote on the manual
18:03:33 <dons> glguy: so i'm hoping that things off the end of the first page now never get decompressed
18:03:39 <dons> of course, we could also just leave them on disk...
18:03:49 <sorear> dons: lazy readFile?
18:04:07 <glguy> dons: oh, once they are decompressed they stay decompressed?
18:04:08 <sorear> no, better idea, unsafeInterleaveIO (P.readFile)
18:04:43 <dons> glguy: no
18:04:58 <glguy> dons: oh, they are stored in the Map compressed, and decompressed when you read them
18:05:02 <dons> yeah
18:05:08 <glguy> perfect
18:05:18 <dons> so a popular page will be decompressed on each view, modulo cahcing and so on
18:05:51 <glguy> I'm going to add paging now
18:05:55 <dons> cool
18:06:00 <dons> i'm probably done for a few hours
18:06:04 <glguy> don't blame you
18:06:08 <dons> need to get some work done!
18:06:10 <glguy> good work!
18:06:48 <dons> i'm happy we can just throw around libraries now for this kind of thing
18:06:56 <dons> little one line changes providing huge new functionality
18:07:01 <dons> yay for cabal
18:07:40 <dons> so two things are happening, the entire state is compressed on disk
18:07:50 <dons> but only the content remains compressed in memory
18:07:52 <sorear> dons: (grepping sources) it seems to be used in .hi-boot handling for ghc
18:08:20 <glguy> dons: #if !defined(LOCAL)
18:08:20 <glguy> import Control.Concurrent       (forkIO)
18:08:20 <glguy> #endif
18:08:23 <glguy> does that break ghci?
18:08:31 <dons> ghci would need -cpp
18:08:34 <glguy> ok
18:08:46 <dons> enableing -DLOCAL gives you a localhost server, and no irc
18:09:32 <glguy> $ ghci -cpp -fglasgow-exts -fbang-patterns HPaste
18:09:39 <glguy> we just keep packing on the flags :)
18:10:47 <allbery_b> doesn't glasgow-exts include bang-patterns?  (but not cpp)
18:11:01 <sorear> glasgow-exts must die
18:11:13 <sorear> idea: Cabal/ghci integration
18:11:17 <jcreigh> sorear: why?
18:11:23 <jcreigh> sorear: WRT to glasgow-exts
18:11:31 <sorear> jcreigh: portability.
18:11:52 <jcreigh> ah
18:12:06 <jcreigh> hmm, I just realized that doesn't make sense after you expand the acronym.
18:12:14 <sorear> jcreigh: if I say Rank2Types in my cabal file, I get no warning if I accidentally use newtype-deriving
18:12:35 <sorear> because cabal -> flags -> extensions is lossy
18:12:51 <sorear> because almost everything gets collapsed to -fglasgow-exts
18:13:03 <jcreigh> oh, so it should be -fsome-specific-extension
18:13:10 <sorear> jcreigh: yes.
18:13:25 <sorear> and cabal/ghci means you won't need to type em all :)
18:14:14 <dons> well, in this case, we don't need -fglasgow-exts, iirc
18:14:17 <dons> we need some isntances flag
18:14:38 <dons> actually, we do need -fglasgow-exts
18:14:42 <dons> for deriving Typeable
18:14:47 <dons> but maybe we don't need to derive that now..
18:14:56 * dons tries
18:15:25 <shapr> Nafai: You screamt?
18:15:33 <dons> right good. we can ditch the -fglasgow-exts
18:15:37 <dons> almost..
18:15:51 <Nafai> shapr: I'm starting to look into translation of my script :)  Where should I start?
18:15:51 <sorear> dons: wouldn't it be better to fix GHC :)
18:16:17 <shapr> Nafai: Start with the pure stuff, that is, not scp or popen.
18:16:21 * Nafai nods
18:16:30 <dons> sorear: flags are good too, yeah
18:16:33 <shapr> albino wants to help I'm sure ;-)
18:16:40 <Nafai> Yeah
18:16:52 <Nafai> albino was one of my college roommates
18:18:57 <shapr> neat
18:21:42 <syntaxfree> > let 2-2=5 in 2-2
18:21:43 <lambdabot>  5
18:25:07 <augustss> > let x-y=5 in 2-2
18:25:08 <lambdabot>  5
18:25:24 <jcreigh> let (.) = flip ($) in [1,2,3].head
18:25:33 <jcreigh> > let (.) = flip ($) in [1,2,3].head
18:25:34 <lambdabot>  1
18:25:34 <neonse> > let 2-2=5 in 4-2
18:25:35 <lambdabot>   Non-exhaustive patterns in function -
18:26:32 <augustss> defining (.)=flip($) sure leads to different looking programs :)
18:29:30 <glguy> ?src read
18:29:30 <lambdabot> read s = either error id (readEither s)
18:29:36 <neonse> They look object-oriented :-(
18:30:55 <glguy> ?index readEither
18:30:55 <lambdabot> bzzt
18:31:00 <glguy> ?src readEither
18:31:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:31:02 <glguy> ?
18:31:46 <shapr> neonse: Are you chalmers person also?
18:32:04 <neonse> nope, Lund
18:32:27 <Nafai> Wow, it's been forever since I read the Haskell tutorials
18:32:28 <shapr> ah
18:32:47 <shapr> neonse: Are you new to Haskell?
18:33:27 <neonse> not really, I learnt it several years ago but I spent a lot of time doing embedded programming lately
18:34:54 <neonse> but I want to catch up again. And boy has it grown up since I last used it
18:37:32 <sorear> neonse: compare to bos ... he has 10 years of catching up
18:39:08 <dons> neonse: we have a new paste site, we hacked up um, yesterday :)
18:39:13 <dons> al in haskell, using all the new libs
18:39:16 <dons> ?paste <--
18:39:16 <lambdabot> http://hpaste.org (Haskell pastebin)
18:39:27 <dons> nice example of where things are at in haskell now
18:39:50 <dons> uses haskell binary serialiation, haskell commpression, haskell web frameworks, haskell xhtml and xml, and a haskell web server
18:40:11 <sorear> is there a standard like "streaming rss" ?
18:40:41 <jcreigh> "streaming"?
18:40:44 <monochrom> even the web server is in haskell?
18:40:53 <monochrom> (I mean the httpd)
18:40:58 <jcreigh> yeah, they're using happs, I think.
18:41:00 <neonse> It's nice that it's going somewhere, and that theres so many good libraries for lazy people like me
18:41:26 <dons> monochrom: yeah, happs' high perf musasabi ninja fu web server
18:41:45 <dons> i.e. what you get if you say main = stdHTML foo
18:41:46 <dons> ;)
18:41:50 <dons> talk about easy!
18:42:12 * monochrom explodes
18:42:13 <sorear> barf, bleeh
18:42:24 <sorear> haddock can't swallow TH
18:43:17 <sorear> dist/build/tmp/src/HAppS/Protocols/SimpleHTTP2.hs:"dist/build/tmp/src/HAppS/Protocols/SimpleHTTP2.hs": 355:1: Parse error
18:43:17 <Nafai> Ok
18:43:23 <dons> so for example of where things are at, we wanted to keep patches in hpaste compresed in memory
18:43:34 <dons> so that was , um, import Codec.GZip
18:43:46 <sorear> s/./.Compression./ ?
18:43:51 <dons> and change two lines from let s = encode v ; to let s = gzip . encode $ v
18:43:58 <dons> and suddenly we're compressing raw buffers in memory
18:44:01 <dons> and lazily decompressing
18:44:01 <Nafai> Let's say I have a string the is a comma separated list, i.e. "1, 2,3 ,4" or something like that.  I want to change it to "1,2,3,4"...remove the spaces
18:44:06 <sorear> sorry to add so many characters, I know it hurts your bubble :)
18:44:06 <neonse> that's composability
18:44:14 <Nafai> What's the best way to do that with Haskell?
18:44:20 <sjanssen> Nafai: concat . words
18:44:21 <sorear> Nafai: filter (/=' ')
18:44:22 <allbery_b> filter isSpace?
18:44:28 <allbery_b> not.isSpace
18:44:36 <dons> > filter (not.isSpace) "1, 2,3 ,4"
18:44:37 <lambdabot>  "1,2,3,4"
18:44:39 <sjanssen> ha, or all these much simpler suggestions :)
18:44:53 <Nafai> Yay
18:44:59 <dons> > concat . words $ "1, 2,3 ,4"
18:45:00 <lambdabot>  "1,2,3,4"
18:45:29 <Nafai> concat . words is essentially what I did in my Python version of this script, it just was "wordier"
18:45:50 * jcreigh always has to think twice about whether "filter" returns elements that match the predicate or elements which don't match the predicate.
18:45:55 <dons> and since data we now gzipped in memory, i changed the type of in memory buffers to GZByteString. then when I recompiled ghc told me all the places i needed to insert a 'gunzip'
18:46:05 <sjanssen> jcreigh: I have this problem too
18:46:09 <dons> rather than dumping binary garbage out, the type checker told me where the conversoin points were
18:46:27 <dons> so, quick, correct web dev. yay for types
18:46:33 * shapr cheers
18:46:37 <allbery_b> that was what got me, yeh
18:47:20 <jcreigh> Ruby has "select" (ie, filter) and "reject" (negated filter), names which I believe are stolen from Smalltalk.
18:47:20 <allbery_b> filter feels backwards, ought to be pick or select or something
18:47:54 <Nafai> jcreigh: Those seem more clearly named
18:48:15 <LoganCapaldo> satisfying predicate list -- I like this one
18:48:31 <jcreigh> they're probably already taken...
18:48:34 <jcreigh> @hoogle select
18:48:35 <lambdabot> Text.Html.select :: Html -> Html
18:48:35 <lambdabot> Text.Html.selected :: HtmlAttr
18:48:40 <jcreigh> @hoogle reject
18:48:40 <lambdabot> No matches found
18:48:54 <LoganCapaldo> So much for that theory :)
18:49:03 <shapr> I think we need import Hash.Haskell
18:49:52 <sorear> what would that do?
18:49:59 * sorear wants "import Control.Memo"
18:50:23 <LoganCapaldo> sorear, I think you suffer from memoization addiction ;)
18:50:58 <dons> Igloo: around?
18:51:08 <shapr> sorear: It'd be a handy place to throw bits of code that popup here on #haskell and end up getting lots of use.
18:51:26 * allbery_b notes that he has a not-quite-cannable memoization monad
18:51:38 <neonse> I use Hugs as a calculator all the time, is there a module with typical calculator functions somewhere?
18:51:45 <allbery_b> I think if I really wanted to I could figure out how to use TH to can it
18:51:46 <LoganCapaldo> Oh that Hash :)
18:51:49 <sorear> neonse: Prelude
18:52:01 <shapr> Maybe IRCPrelude is a better name?
18:52:02 <LoganCapaldo> why not import Pound.Haskell? ;)
18:52:09 <neonse> ahh, but I want standard deviations and such things
18:52:12 <shapr> Prelude.IRC ?
18:52:14 <vincenz> import Oleg
18:52:28 <sorear> @remember vincenz import Oleg
18:52:28 <lambdabot> Done memoising quote for `vincenz', if that is their real name...
18:52:33 <vincenz> GHC: Urk! Something exploded
18:52:34 <shapr> @google deviation filetype:hs
18:52:35 <sjanssen> I read it as "sharp haskell", is that strange?
18:52:36 * LoganCapaldo wonders what would be in import Hash.Haskell.Blah
18:52:36 <lambdabot> http://www.cs.cmu.edu/~unsal/research/shift/files/2dkinectrl.hs
18:52:47 <shapr> @google standard deviation filetype:hs
18:52:49 <lambdabot> http://www.csse.monash.edu.au/~lloyd/tildeFP/II/200309/03Models.hs
18:52:52 <SamB> @quote Urk! Something exploded
18:52:52 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
18:52:58 <SamB> @quote Urk
18:52:58 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
18:53:00 <SamB> @quote Urk
18:53:00 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
18:53:05 <shapr> @quote ghc
18:53:05 <lambdabot> ghc says: In a RHS constructor application, con type doesn't match arg types
18:53:07 <SamB> @quote Something
18:53:07 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
18:53:10 <sorear> @ghc
18:53:10 <lambdabot> ghc says: Cycle in class declarations (via superclasses)
18:53:11 <vincenz> @quote oleg
18:53:12 <lambdabot> emu says: olegarithmic
18:53:16 <shapr> @quote
18:53:17 <lambdabot> lennart says: the best way of debugging is to understand your code
18:53:21 <shapr> yay augustss!
18:53:47 <SamB> vincenz: is that a genuine quote?
18:53:54 <vincenz> SamB: ?
18:54:03 <SamB> GHC: Urk! Something exploded
18:54:06 <vincenz> no
18:54:09 <SamB> oh. rats.
18:54:09 <vincenz> @quote semantics
18:54:10 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
18:54:17 <shapr> @quote
18:54:17 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
18:54:29 <shapr> robreim: Did you start it yet?
18:54:39 <shapr> mi djica lenu go'i
18:55:01 <robreim> heh, we did have #haskell.jbo for a while
18:55:08 * vincenz winces
18:55:14 <shapr> funny :-)
18:55:33 <robreim> We could start it up again :)
18:55:44 <Pseudonym> Haskell coders aren't anarchists.  We like bondage and discipline languages.  Or is that only because it's safe, sane and consensual?
18:56:06 <sorear> shapr: HAppS + haddock = dist/build/tmp/src/HAppS/Protocols/SimpleHTTP2.hs:"dist/build/tmp/src/HAppS/Protocols/SimpleHTTP2.hs": 355:1: Parse error
18:56:11 <SamB> Pseudonym: something like that
18:56:15 <Nafai> Is there a function to get a temporary file name?  Like the unix utility mktemp?
18:56:18 <SamB> the restrictions are not exactly arbitrary
18:56:19 <sorear> yes
18:56:27 <sorear> I forgot what it is called :(
18:56:31 <sorear> @hoogle temp
18:56:31 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
18:56:31 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
18:56:31 <lambdabot> System.IO.openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
18:56:32 <SamB> and many of them are actually breakable
18:56:52 <robreim> Pseudonym: yeah, if it's consensual it doesn't contradict anarchism :P
18:57:03 <Pseudonym> Unless security is on the line, most restrictions should be breakable.
18:57:18 <Pseudonym> The key thing is that you shouldn't be able to break them accidentally.
18:57:27 <Nafai> Hrm
18:57:43 <SamB> yeah
18:58:29 <Pseudonym> Actually, "Safe, sane, consensual" would be a good Haskell slogan.
18:59:33 * syntaxfree did the Haskell/Bdsm metaphor in his blog.
18:59:35 <syntaxfree> http://www.messwithyourjunk.com/?p=8
18:59:38 <lambdabot> Title: Mess with your Junk В» Blog Archive В» Object Orientation Done Differently
18:59:40 <syntaxfree> he called us nuts!
18:59:51 <syntaxfree> how are OOP classes different from Haskell classes?
19:00:05 <Pseudonym> Woo, I didn't know you had a blog.
19:00:15 <Pseudonym> Hi ho, hi ho, to RSS I go...
19:00:24 <shapr> To RSI I go...
19:00:34 <allbery_b> @go module syntaxfree where
19:00:36 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/module-syntaxfree-where/
19:00:36 <lambdabot> Title: module Syntaxfree where В« Data.Syntaxfree
19:00:45 <LoganCapaldo> Haskell classes are part of the time system, OOP classes are an implementation detail?
19:01:18 <syntaxfree> allbery_b huh?
19:01:27 <allbery_b> <Pseudonym> Woo, I didn't know you had a blog.
19:01:33 <syntaxfree> ah.
19:01:36 <syntaxfree> it's on planet haskell.
19:01:43 <syntaxfree> it's really full of uninformed rants, I'd say.
19:01:48 <syntaxfree> But so is Steve Yegge's, so..
19:01:53 <Pseudonym> Most blogs are.
19:02:10 <allbery_b> it's useful enough that I kept it, when I'm prone to drop junk fairly quickly
19:02:16 <syntaxfree> I understand 5% of things and I already go out and evangelize them.
19:02:23 <syntaxfree> I'm an arrogant prick ;)
19:02:48 <allbery_b> aren't we all?  otherwise we'd have to leave Haskell to Oleg :)
19:02:50 <syntaxfree> it's really aimed at non-haskellers. It's not like if I was Sigfpe.
19:03:02 <syntaxfree> I'm closer to Yegge than to Cale/Sigfpe/Oleg.
19:03:31 <syntaxfree> the BDSM article is good-ish, though. Slava got pissed off, though.
19:03:34 <shapr> hehe
19:03:40 <shapr> slava gets pissed off easily, imho
19:03:50 <shapr> But he's a good guy.
19:05:37 <syntaxfree> The blog does have a couple of good ideas from a software development methodology viewpoint. They're buried into long meandering rants, though.
19:05:56 <syntaxfree> One of them is metaphors vs analogies vs abstractions, from "Reddit discussion..."
19:06:00 <glguy> ?hoogle reverse
19:06:01 <lambdabot> Prelude.reverse :: [a] -> [a]
19:06:01 <lambdabot> Data.PackedString.reversePS :: PackedString -> PackedString
19:06:10 <syntaxfree> the other one is the discussion on self-restraint from the BDSM article.
19:06:33 <syntaxfree> Of course, I've never developed anything longer than, say, 50 lines, so it's rather ironic that I'm ranting on software development methodologies.
19:06:41 <syntaxfree> That's kinda how my entire life works though.
19:07:14 <glguy> and I say unto you, go forth and page through pastes 25 at a time ;)
19:07:27 <Nafai> Okay.  I'm trying to write a function to return just the filename of a temporary file.
19:07:34 <Nafai> ?hoogle openTempFile
19:07:34 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
19:07:57 <Nafai> And I want to use getTemporaryDirectory for the first argument
19:08:00 <LoganCapaldo> fst . openTempFile
19:08:06 <LoganCapaldo> err
19:08:06 <Nafai> ?hoogle getTemporaryDirectory
19:08:07 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
19:08:10 <LoganCapaldo> not really :)
19:08:18 <LoganCapaldo> stupid monads
19:08:22 <allbery_b> Nafai: that has security implications
19:08:27 <LoganCapaldo> where's M. ?
19:08:28 <Pseudonym> Hang on, aren't economists SUPPOSED to argue passionately for things they only understand 5% of?
19:08:31 <LoganCapaldo> Or .M
19:08:35 <syntaxfree> ah. there's also the point on dynamic typing.
19:08:36 <Pseudonym> I thought that was the first lecture.
19:08:40 <syntaxfree> I didn't explain myself well there.
19:09:09 <LoganCapaldo> (liftM f) . g ?
19:09:12 <Nafai> allbery_b: Sure, probably technically, but this is just for my use.  What's more secure, though?
19:09:17 <syntaxfree> The point is, the only thing you *need* to check with statically-typed languages are machine types. There's no reason you'd want to compile something that attempts to sum a string and an integer.
19:09:29 <syntaxfree> Of course, you *can* use static typing to build Architecture.
19:09:38 <syntaxfree> anyway. I should write clarifications some time.
19:09:49 <Pseudonym> There's no reason why you'd want to add two times together, either.
19:09:49 <syntaxfree> except I won't, because I'm lazy and confusing.
19:09:53 <Pseudonym> A time and a duration, yes.
19:09:53 <syntaxfree> like Haksell itself.
19:09:57 <Pseudonym> Two durations, yes.
19:10:09 <Pseudonym> Similarly, there's no reason to add two X coordinates together.
19:10:22 <syntaxfree> Pseudonym: no *semantic* reason. But a program can run like that.
19:10:30 <allbery_b> the reason modern tempfile interfaces return a handle is that you can't securely just grab a nonexistent filename, someone could create or symlink it between rolling the name ad creating the file
19:10:31 <syntaxfree> What a program *can't* do is prohibited operations on machine types.
19:10:43 <syntaxfree> And that's pretty much all that Haskell enforces if you don't roll your own types.
19:10:44 <LoganCapaldo> @type let f .M g = (liftM f) . g in (.M)
19:10:45 <lambdabot> Not in scope: data constructor `M'
19:10:45 <lambdabot>  
19:10:45 <lambdabot> <interactive>:1:32: Not in scope: data constructor `M'
19:10:48 <allbery_b> so you create it using a low level open(..., O_EXCL|O_CREAT) and return the filehandle
19:10:51 <Pseudonym> True.
19:11:08 <LoganCapaldo> @type let f `dotM` g = (liftM f) . g in dotM
19:11:10 <lambdabot> forall a1 r a (m :: * -> *). (Monad m) => (a1 -> r) -> (a -> m a1) -> a -> m r
19:11:24 <allbery_b> thus name-only tempfile generators are generally deprecated in most APIs these days, and sometimes simply not implemented
19:11:34 <Nafai> allbery_b: But I'm just wanting to create a temp filename and then open the file in $EDITOR
19:11:47 <allbery_b> ?hoogle tempdir
19:11:48 <lambdabot> No matches found
19:11:49 <allbery_b> hm
19:11:57 <syntaxfree> Pseudonym: http://syntaxfree.wordpress.com/2006/12/24/static-vs-dynamic-typing-do-what-thou-wilt/
19:11:59 <lambdabot> Title: Static vs dynamic typing: do what thou wilt В« Data.Syntaxfree, http://tinyurl.com/ykvay5
19:12:22 <allbery_b> ?hoogle temporary
19:12:22 <lambdabot> System.Win32.File.fILE_ATTRIBUTE_TEMPORARY :: FileAttributeOrFlag
19:12:22 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
19:12:49 <allbery_b> guess haskell doesn't have the create-tempdir thing which is the somewhat-secure way to deal
19:13:26 <allbery_b> anyway, you can certainly roll your own, but I don't think APIs are willing to help you with it these days
19:16:45 <Nafai> Ok
19:16:55 <bos> allbery_b: System.Posix.Temp?
19:17:08 <bos> oh, just mkstemp, not mkdtemp
19:17:10 <bos> never mind.
19:17:24 <bos> @hoogle mkstemp
19:17:25 <lambdabot> No matches found
19:17:26 <dibblego> does ByteString do O(1) concat?
19:17:28 <bos> @hoogle mkdtemp
19:17:28 <lambdabot> No matches found
19:17:30 <dons> dibblego: no
19:17:32 <bos> dibblego: no
19:17:39 <dons> lazy bytestrings do O(k) concat though
19:17:44 <dibblego> use DList?
19:17:48 <dons> where k is the n/32k
19:17:58 <shapr> Nafai: Sounds like you're going through it pretty quickly :-)
19:18:18 <sjanssen> but Data.ByteString.Lazy.concat is O(1)
19:18:34 <sjanssen> actually, that isn't quite true
19:18:50 <sjanssen> it is O(n), where n is the length of the input list
19:18:50 <allbery_b> the security guy in me approves that there is no System.Posix.Temp.mktemp
19:18:51 <hpaste>  Nafai pasted "(no title)" at http://hpaste.org:8000/63
19:18:54 <bos> you need ropes for that.
19:19:00 <bos> dons: have you any plans to do anything with sjanssen's stuff?
19:19:04 <Nafai> That's what I have so far
19:19:11 <dons> sjanssen: isn't .lazy O(k) ?
19:19:18 <dons> since it copies the list spine only?
19:19:23 <dons> which is usually O(1)
19:19:28 <bos> yes, it is.
19:19:32 <augustss> dons O(n/32k) sounds like almost O(1) ;)
19:19:37 <shapr> hpaste.org isn't responding. I'm worried...
19:19:39 <dons> yeah, that's the idea :)
19:19:51 <allbery_b> it worked for me
19:19:57 <allbery_b> (hpaste.org that is)
19:19:58 <shapr> But I can still check my email, so my server isn't down...
19:20:04 <dons> shapr: glguy might be tweaking things
19:20:12 <dons> glguy: ping?
19:20:14 <glguy> nope
19:20:15 <glguy> i wasn't
19:20:18 <shapr> I could just run top ...
19:20:23 <Nafai> Obviously my getTempFileName function isn't finished
19:20:26 <dons> yeah, seems down again. better check what's going on
19:20:29 <glguy> it's not responding
19:20:37 <dons> i hope is not this gzip thingy
19:20:52 <dons> yeah, back now
19:20:52 <shapr> and now it's back!
19:21:00 <glguy> ^c ^c UP Enter
19:21:02 <dons> so hmm, any ideas what it was doing, glguy ?
19:21:02 <glguy> will do that
19:21:05 <shapr> Prettier than yesterday.
19:21:24 <glguy> dons: no, I'm not sure yet
19:21:31 <dons> hmm, just after the Nafai paste.
19:21:35 <dons> let me check..
19:21:41 <glguy> the IRC bot was still running
19:21:49 <Nafai> I broke it! :)
19:21:53 <vincenz> o.O
19:21:58 <vincenz> dons: they have actual dragons in Australia!!!!
19:22:05 <dibblego> vincenz, absolutely
19:22:08 <vincenz> http://en.wikipedia.org/wiki/Leafy_sea_dragon
19:22:09 <lambdabot> Title: Leafy sea dragon - Wikipedia, the free encyclopedia
19:22:11 <vincenz> http://en.wikipedia.org/wiki/Weedy_sea_dragon
19:22:13 <hpaste>  dons pasted "test" at http://hpaste.org:8000/64
19:22:14 <vincenz> the even look like dragons
19:22:16 <vincenz> albeit small
19:22:23 <dons> glguy: no irc bot
19:22:28 <glguy> !hpaste ?
19:22:32 <glguy> !paste
19:22:32 <hpaste> Haskell paste bin: http://hpaste.org:8000/
19:22:40 <shapr> Nafai: do you think it'll end up being fewer lines than the Python version?
19:22:46 <glguy> <hpaste>  dons pasted "test" at http://hpaste.org:8000/64
19:22:58 <dons> huh, i didn't see that here
19:23:02 <dons> ah yes
19:23:02 <allbery_b> I successfully loaded his paste
19:23:04 <dons> there it is :)
19:23:11 <dons> yeah ok. so its not that
19:23:14 <vincenz> dibblego: they look funky
19:23:15 <Anon4888> vincenz >>= sheets >>= #haskell/sheets
19:23:18 <glguy> I can turn the debugFilter on if it crashes
19:23:27 <glguy> (or i could do that right now
19:23:27 <vincenz> Anon4888: addiction
19:23:29 <Anon4888> : )
19:23:46 <Nafai> shapr: Perhaps; so far it's about the same.  Maybe once I get it to be idiomatic Haskell it will be
19:23:57 <vincenz> Anon4888: but look at those links
19:24:01 <vincenz> Anon4888: they look like actual dragons!
19:24:27 <Anon4888> Looks like a seahorse to me
19:24:42 <vincenz> the second one
19:24:45 <vincenz> http://en.wikipedia.org/wiki/Weedy_sea_dragon
19:25:14 <vincenz> and of course it looks like a seahorse, they're related
19:25:17 <vincenz> but it also looks like a dragon
19:25:25 <Anon4888> yes
19:25:28 <dons> vincenz: off topic? ;)
19:25:33 <vincenz> dons: somewhat
19:25:38 <vincenz> dons: I mentioned .au
19:25:43 * vincenz hides
19:25:47 <dons> umm..
19:26:41 * glguy encourages everyone to click around for 15-30 seconds viewing pastes, making diffs, older, newer
19:26:54 <glguy> dons: -s-threaded is new, potentially bad?
19:27:05 <dons> ah hmm
19:27:16 <dons> yeah, that invokes a lot of happs i guess
19:27:21 <dons> lets see if happens again
19:27:26 <dons> then disable after that ..
19:27:35 <glguy> i think it's locked now
19:27:49 <glguy> dons: the signal handlers are new too
19:28:01 <glguy> 25795 eric      16   0 49684 6748 2528 S    0  2.6   0:00.89 hpaste
19:28:03 <glguy> dons
19:28:06 <robreim> dons: I've got some free time at the moment and would like to take a crack at hs-plugins for ghc 6.6. Where should I start?
19:28:07 <glguy> VIRT mem way up
19:28:15 <shapr> yup, locked
19:28:27 <glguy>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
19:28:40 <glguy> !quit
19:28:45 <glguy> !paste
19:29:14 <glguy> dons, just get rid of that flag?
19:29:28 <glguy> ghc-options:         -Wall -O -funbox-strict-fields -fasm -optl-Wl,-s -threaded
19:30:34 <Trevion> Hello
19:30:45 <Trevion> Anyone able to give me a bit of help with building wxWindows/Haskell?
19:30:48 <dons> glguy: yeah, ditch -threaded
19:30:51 <dons> robreim: ok.
19:30:59 <dons> robreim: first place is to remove AltData.Typeable
19:31:07 <dons> and replace it only with calls to Data.Typeable
19:31:09 <glguy> site's up, feel free to provide load!
19:31:37 <robreim> yep, I gathered that much. How has the .hi format changed?
19:31:57 <dons> not sure, a couple of package fields
19:32:11 <dons> the best way is to vimdiff the binary parser in hs-plugins againt the same module in ghci
19:32:17 <dons> and then make sure the parsers match
19:32:42 <dons> glguy: how's mem now?
19:32:55 <robreim> ah ok, cool. That helps, thanks. I'll see what I can come up with.
19:34:39 <dons> glguy: nice, so now 25 on the front page?
19:34:41 <dons> looks good
19:34:55 <glguy> 6138 eric      15   0 10448 8312 2512 S    3  3.2   0:06.26 hpaste
19:35:00 <dons> 3.2%?
19:35:01 <glguy> dons: 25, yes
19:35:11 <glguy>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
19:35:11 <glguy>  6138 eric      16   0 10448 8312 2512 S    1  3.2   0:06.56 hpaste
19:35:18 <dons> ah looks healthy
19:35:25 <dons> so no -threaded eh?
19:35:32 <glguy> right
19:35:36 <dons> interesting...
19:36:01 <sjanssen> hpaste won't run on -threaded?
19:36:01 <dons> better record your patch
19:36:09 <hpaste>  glguy annotated "test" with "annotating dons recent test" at http://hpaste.org:8000/64#1
19:36:23 <dons> sjanssen: it locked up twice since we switched to -threaded
19:36:27 <dons> so maybe some happs mvars ?
19:36:30 <dons> or not sure
19:37:32 <dons> glguy: and the -threaded change, recorded that?
19:37:44 <glguy> dons: yes, as a separate patch with a long comment
19:37:47 <vincenz> dons: LB ?
19:37:56 <dons> got it
19:37:56 <sjanssen> hpaste's front page should have a link to the code
19:38:01 <glguy> it does
19:38:03 <dons> it does?
19:38:06 <dons> a tthe bottom
19:38:06 <glguy> its just not obvious
19:38:12 <vincenz> what's LB?
19:38:18 <dons> lambdabot monad
19:38:20 <vincenz> ah
19:38:36 * sjanssen missed it because his browser window was bigger than his screen
19:39:04 <sjanssen> glguy: I'd say it's obvious enough
19:39:34 <glguy> colloquy as spoiled me
19:39:37 <Nafai> Is there a way to combine these two lines to 1?
19:39:42 <glguy> has*
19:39:45 <Nafai> tags <- getLine
19:39:45 <Nafai> return (concat . words $ tags)
19:39:45 <Nafai>  
19:39:50 <vincenz> Nafai: yes
19:40:00 <Trevion> getLine >>= return . concat . words
19:40:02 <vincenz> liftM (concat .words) getLine
19:40:06 <sorear> tell fogger
19:40:07 <dons> ?. pl undo do tags <- getLine
19:40:07 <lambdabot> (line 1, column 21):
19:40:07 <lambdabot> unexpected "{"
19:40:07 <lambdabot> expecting variable, "(", operator or ")"
19:40:08 <vincenz> or what Trevion said
19:40:22 <dons> ?. pl undo do tags <- getLine return (concat . words $ tags)
19:40:22 <lambdabot> (line 1, column 21):
19:40:22 <lambdabot> unexpected "{"
19:40:22 <lambdabot> expecting variable, "(", operator or ")"
19:40:23 <Nafai> Is either more idiomatic?
19:40:26 <vincenz> dons: need {}
19:40:33 <vincenz> Nafai: about equal
19:40:34 <dons> ?. pl undo do tags <- getLine ; return (concat . words $ tags)
19:40:34 <lambdabot> (join . words) `fmap` getLine
19:40:41 <dons> Nafai: ^^
19:40:52 <vincenz> eww fmap for monads
19:40:57 * vincenz prefers them only for containers
19:41:03 <vincenz> in the pure-container-sense
19:41:07 <vincenz> not in the all monads are containers
19:41:33 <glguy> vincenz: which monad isn't? :(
19:41:43 <vincenz> glguy: I mean in the traditional sense of thinking of a contianer
19:41:55 <sorear> oh, you're one of those who want Monad -/-> Functor.  HERETIC!
19:42:11 <vincenz> define -/->
19:42:23 <vincenz> I'm one of those that wants class aliases and splitting of Num
19:42:28 -ChanServ(ChanServ@services.)- dons!i=dons@pill00.orchestra.cse.unsw.EDU.AU ACCESS [#haskell] ADD GLGuy 38
19:42:34 <allbery_b> does not imply?
19:42:45 <vincenz> allbery_b: implication is typically =>
19:42:51 <vincenz> anywho
19:43:20 <vincenz> sorear: personal preference, fmap for traditional container types, more 'monadic' function for 'computation' monads
19:43:27 <vincenz> but yeah, that's rather fuzzy
19:43:40 <Nafai> Man I really need to "get" this stuff
19:44:19 <vincenz> sorear: like `ap` or liftM[2-9]*
19:44:31 <vincenz> s/*/?
19:45:22 <sjanssen> vincenz: you have something against liftM11?
19:45:34 <vincenz> @hoogle LiftM11
19:45:34 <lambdabot> No matches found
19:45:37 <vincenz> @hoogle liftM11
19:45:37 <lambdabot> No matches found
19:45:50 <sorear> I have something against the type of ... that prevents ONE liftm
19:46:21 <vincenz> sorear: you're referring to the C ...?
19:46:26 <vincenz> as in varargs?
19:46:45 <vincenz> @quote vincenz import
19:46:45 <lambdabot> vincenz says: import Oleg
19:46:45 <sorear> I'm refering to the ... I don't know
19:47:05 <vincenz> right, varargs ;0
19:47:07 <vincenz> ;)
19:49:31 --- mode: ChanServ set +o dons
19:49:36 --- topic: set to '["The Haskell programming language: Get yourself some cognitive dissonance!","http://haskell.org","http://hpaste.org","http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
19:49:40 --- mode: ChanServ set -o dons
19:50:00 <sjanssen> @hoogle thefor
19:50:00 <lambdabot> No matches found
19:50:08 <chessguy> hmm, did it change?
19:50:15 <dons> sjanssen: its in haxml deep down
19:50:20 <dons> chessguy: yeah, added hpsate
19:50:25 <chessguy> aha
19:50:28 <sjanssen> so I need a different HaXML?
19:50:31 <dons> take hat lisp!
19:50:39 <dons> sjanssen: darcs pull a more recent one, iirc
19:50:53 <ray> hat??
19:51:00 <dons> shapr: what can we do to get the redirect to :8000 faster?
19:51:10 <dons> s/^/t/
19:51:37 <ray> "ttake hat lisp!"?
19:51:38 <chessguy> red hat?
19:51:38 <ray> =D
19:51:56 <dons> :}
19:54:08 <shapr> dons: proxy it
19:54:17 <shapr> I'll make a sandwich and then fix it.
19:54:36 <dons> mm. sandwiches
19:54:48 <shapr> Now if only I had some vegemite...
19:55:02 <dons> so, glguy, when does hpaste get listed on the stock exchange? ;)
19:55:14 <glguy> that's not public knowledge yet
19:55:25 <glguy> besides, it's BSD3 licensed :-D
19:55:29 <dons> can we get a $180M buy out from some big media corp?
19:56:04 <glguy> dons: if we do, I'll invest in Haskell development
19:56:10 <dons> good idea!
19:56:16 <glguy> I have
19:56:17 <glguy>       --forkIO $ runReaderT chanListener b
19:56:18 <glguy>       --runReaderT run b `catch` \_ -> return ()
19:56:23 <glguy> rewriting
19:56:24 <glguy>       flip runReaderT b $ do
19:56:25 <glguy>         liftM forkIO chanListener
19:56:25 <glguy>         run
19:56:32 <glguy> as an exercise
19:56:38 <glguy> how do I fit the catch in this?
19:57:00 <dons> handle (const $ reutnr ()) $ flip runReaderT b $ do ... ?
19:57:22 <nornagon> impressive typo
19:57:25 <sorear> reutnr :: Monad m => a -> m a ? :)
19:57:25 <dons> or liftM $ handle ... $ forkIO ...
19:57:31 <glguy> ?type handle
19:57:32 <lambdabot> Not in scope: `handle'
19:57:50 <dons> its flipped catch
19:57:51 <kilimanjaro> The more I used haskell the more I can't imagine working in a strict language
19:57:58 <dons> heh
19:58:17 <kilimanjaro> Well, I can imagine it, but I realize that laziness is sometimes pretty useful
19:59:08 <shapr> I agree.
19:59:11 <sjanssen> glguy: which version of HaXml do I need for hpaste?
19:59:13 <shapr> I have serious issues with strict languages.
19:59:23 <sorear> sjanssen: it's a versioned dep
19:59:25 <glguy> sjanssen: the one requried by HAppS, 1.13.2
19:59:38 <sorear> sjanssen: glguy should've updated it iff it was changes
19:59:53 <glguy> ?
20:00:00 <glguy> I didn't change the HaXml library
20:00:01 <kilimanjaro> I just need to write something in haskell other than little expository programs
20:00:26 <shapr> kilimanjaro: Go for it!
20:00:26 <sjanssen> maybe "thefor" isn't in HaXml?
20:00:32 <glguy> sjanssen: that is xhtml
20:00:37 <sjanssen> ah
20:00:46 <glguy> sjanssen: you need to darcs get http://darcs.haskell.org/packages/xhtml
20:00:48 <sjanssen> so I need latest darcs of xhtml
20:00:48 <lambdabot> Title: Index of /packages/xhtml
20:01:01 <glguy> sjanssen: you want darcs versions of xhtml, hscolour, and happs
20:01:15 <glguy> and eventually base :-p
20:01:27 <kilimanjaro> shapr, I actually have an idea for something that I think would be pretty cool
20:01:38 * sorear listens in
20:02:02 <sjanssen> excellent, builds now
20:02:12 <kilimanjaro> shapr, basically, it's almost the philosophy of lisp but applied to modal logics, i.e. a basic runtime and a way for specifying and combining modal logics for logic programming
20:03:07 <kilimanjaro> the goal would be to make a language that is actually a metasystem for implementing turing incomplete languages for particular domains
20:03:11 <shapr> I like Nanevski's idea for splitting monads into possibility and necessity.
20:03:26 <shapr> Hm, sounds like dependently typed domain specific languages.
20:04:19 <shapr> kilimanjaro: Sounds cool!
20:04:26 <shapr> When do we get to try a prototype?
20:05:12 <kilimanjaro> I might actually try to implement it this spring in my free time, the idea has been bouncing around in my head for a while
20:05:31 <kilimanjaro> I don't know how useful it would be, but at the very least it would be fun (see how masochistic I am)
20:05:56 <shapr> Why not start now?
20:06:45 <kilimanjaro> shapr, I need to at least review some books to be able to clearly articulate what and how I would like to do, because I'm not quite there yet :)
20:07:08 <glguy> ?pl \s -> f s >>= g s -- liftM2 (>>=) f g
20:07:09 <lambdabot> liftM2 (>>=) f g
20:07:14 <sorear> just post it and let oleg do your prior-art research! :)
20:07:30 <sorear> NOOOOO!!!!
20:07:36 <kilimanjaro> hahaha
20:07:37 <sorear> :)
20:07:39 <SamB> hahahaha
20:07:50 <glguy> my command was too much for lambdabot?
20:07:58 <SamB> lambdabot never does that when it malfunctions, sillies!
20:08:03 <sorear> @unmtl put 2 >> get
20:08:05 <SamB> it just gets stuck
20:08:09 <kilimanjaro> i'm somewhere split between trying to do research in math and research in PL theory / logic
20:08:14 <lambdabot> err: Parse error
20:08:22 <dgriffi3> ?pl \x y -> f x == f y
20:08:24 <sorear> @unmtl do { put 2 ; get }
20:08:26 <dons> it unrolls types
20:08:28 <lambdabot> (. f) . (==) . f
20:08:30 <lambdabot> err: Parse error
20:08:43 <sorear> dons: uhh ... can you demo it?
20:08:47 <dons> @unmtl ContT ByteString (StateT s IO) a
20:08:47 <lambdabot> (a -> s -> IO (ByteString, s)) -> s -> IO (ByteString, s)
20:08:56 <dons> same thing
20:09:22 <sorear> nice
20:09:30 <dons> @unmtl ConT (IO [a]) (ConstT [a] (StateT s Identity) a
20:09:31 <lambdabot> err: Parse error
20:09:44 <sorear> ConstT! I wonder what that does?
20:09:48 <dons> @unmtl ContT (IO [a]) (ContT [a] (StateT s Identity)) a
20:09:48 <lambdabot> (a -> (IO [a] -> s -> Identity ([a], s)) -> s -> Identity ([a], s)) -> (IO [a] -> s -> Identity ([a], s)) -> s -> Identity ([a], s)
20:09:51 <dons> hehe
20:10:08 * shapr beats on his apache2 config with a lambda!
20:10:18 <glguy> shapr: proxy luck?
20:10:23 <shapr> not so far...
20:10:26 * sorear rewrites httpd.conf in an EDSL!!
20:11:20 <dgriffi3> ?pl \f x y -> f x == f y
20:11:20 <lambdabot> flip =<< (((.) . (==)) .)
20:11:47 <sorear> dgriffi3: equating
20:11:55 <sorear> (it's not in the bot yet)
20:12:09 <sorear> @docs Data.Function
20:12:09 <lambdabot> Data.Function not available
20:12:11 <sorear> @docs Data.Eq
20:12:12 <lambdabot> Data.Eq not available
20:12:19 <sorear> @docs
20:12:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:12:31 <sorear> ^^^ the pages exist, honest!
20:12:43 <glguy> why don't the bots /notice the channel again? (this has come up)
20:12:53 <sorear> broken clients
20:13:25 <sorear> non-irssi clients treat all notices as if they came from nickserv
20:13:54 <glguy> how is that?
20:13:56 <shapr> And gaim and others handle NOTICE badly, though I forget how.
20:14:02 * sorear isn't sure whether the implicit quantifier is all or some
20:14:32 <glguy> when I get a notice, it appears in a bubble outside of my irc client window
20:15:01 <glguy> the same bubble I get when it wants to tell me that someone sent me a message and I wasn't focused on the window
20:15:19 <sorear> when I get a notice, it is displayed as a privmsg but different color
20:15:27 <sorear> in context and all that nice stuff
20:15:39 <sorear> I can actually hold a conversation with chanserv
20:15:51 <sorear> err, that came out badly
20:15:54 <glguy> lol
20:15:57 <bos> @pl \f xs -> [x | x <- xs, f x]
20:15:57 <lambdabot> flip ((:) . ((x | x) <-)) . return . ($ x)
20:16:03 * glguy uses irssi when he doesn't have his colloquy ;)
20:16:08 <dons> i've heard on others it beeps, pops up windows, and starts thrashing your harddisk, and saturating your net connect, if you send a notice
20:16:13 <glguy> bos: @pl isn't list-comprehension friendly
20:16:16 <dons> so we stopped doing it
20:16:21 <bos> glguy: indeed not :-)
20:16:37 <shapr> We could switch back to NOTICE and we'd quickly be reminded of the problems.
20:16:45 <bos> i hate not knowing the prelude by heart :-)
20:16:58 <shapr> I'd like for lambdabot to be accesible via xmpp as well as irc.
20:17:01 <sorear> shapr: how about sending special NOTICEs that cause bad clients to autodelete? :)
20:17:07 <bos> @hoogle (a -> Bool) -> [a] -> [a]
20:17:08 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
20:17:08 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
20:17:08 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
20:17:12 <sorear> shapr: imminent.
20:17:24 <bos> i could have sworn it was filter i was looking for, but ghci misled me.
20:17:30 <SamB> @remember sorear I can actually hold a conversation with chanserv [/talking about NOTICE]
20:17:31 <lambdabot> Done.
20:17:33 -dons(i=dons@pill00.orchestra.cse.unsw.EDU.AU)- this is a test of the bot broadcast system
20:17:37 <shapr> yay
20:17:38 <dons> nic eeh?
20:17:39 <SamB> hello dons
20:17:46 <sorear> 20:14 < lambdabot> Done.
20:17:46 <sorear> 20:14 -dons:#haskell- this is a test of the bot broadcast system
20:17:46 <sorear> 20:14 < shapr> yay
20:17:49 <bos> @hoogle (a -> Bool) -> [a] -> ([a], [a])
20:17:50 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
20:17:50 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
20:17:50 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
20:17:56 <SamB> it says "-dons/#haskell- this is a test of the bot broadcast system"
20:18:00 <shapr> Yeah, that's pretty much how I see it.
20:18:05 <dons> i get it in red
20:18:06 <allbery_b> /notice works fine here
20:18:09 <dibblego> -dons/#haskell- this is a test of the bot broadcast system
20:18:12 <bos> > break (==2) [1,2,3,4,2]
20:18:13 <lambdabot>  ([1],[2,3,4,2])
20:18:15 <dons> though i used to have it set for normal ignore kind of thing
20:18:19 <dons> but gaim was the big problem
20:18:28 <bos> > partition (==2) [1,2,3,4,2]
20:18:29 <sorear> what does gaim do?
20:18:30 <lambdabot>  ([2,2],[1,3,4])
20:18:34 * allbery_b thinks gaim should not be used for irc
20:18:36 <dons> anyone saw that on gaim? and didn't have their net connection dropped/
20:18:43 <dons> or their files deleted?
20:19:09 <SamB> or their machine thrash to hell and back?
20:19:10 <sorear> dons: any chance we could /mode #haskell +b gaim!* :)
20:19:18 <bos> @hoogle (Either a) => [a] -> ([a], [a])
20:19:19 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
20:19:19 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
20:19:19 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
20:19:44 <nornagon> :t break
20:19:45 <shapr> Anyone here clueful about RewriteRule and Proxy for apache2?
20:19:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:19:56 <sorear> nope
20:20:11 <bos> shapr: i've used them, but wouldn't describe myself as clueful.
20:20:13 <nornagon> :t partition
20:20:14 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:20:15 <dons> shapr: how about in #apache? dare i suggest that
20:20:16 <nornagon> :t filter
20:20:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:20:53 <shapr> #haskell is often the best value to substitute for any $CHANNEL
20:21:17 <dibblego> shapr, used it a fair bit
20:21:37 <dons> shapr: more scared they'd try to hack your box or something if you asked for help
20:22:03 <dons> not sure that the irc culture outside happy lambda land is always so warm and tropical
20:22:22 <glguy> there are other channels?
20:22:23 <sorear> @remember dons not sure that the irc culture outside happy lambda land is always so warm and tropical
20:22:23 <shapr> Yeah, I like the tropical channel culture.
20:22:23 <lambdabot> Done.
20:23:15 <dons> so, now do we write a good reddit using our \eet happs skillz
20:23:32 <dons> with a type inference test for a captcah
20:23:58 <glguy> how about a type inference word problem
20:24:38 <LoganCapaldo> ooo type inference word problems are my favorite
20:25:20 <SamB> does "adventure" from the ICFP 2006 contest count?
20:25:21 <sorear> Searching 3 days of logs ... nostrademons and SyntaxNinja, that's it.  (visible gaim users)
20:25:59 <dibblego> data StrictList a :: ! = Cons a (StrictList a) | Nil -- wtf is :: !
20:26:52 <allbery_b> looks like a broken(?) attempt at strictness annotation
20:27:17 <sorear> sjanssen: still a gaim user? how'd that notice look
20:28:26 <bos> the shock! i have written my first working main in haskell in, well, way too long.
20:28:41 <sorear> main?
20:28:48 <sorear> main=return()
20:29:00 <bd_> emergencyMain = putStrLn "Don't worry! No matter what anyone else says, *I* still think you're a good haskell programmer!"
20:29:15 <dgriffi3> sorear: where was that equating you were talking about defined?
20:29:17 <sorear> main = error"Don't panic"
20:29:18 <bos> sorear: ok, nontribial main :-)
20:29:31 <sorear> dgriffi3: Data.Function, Data.Eq
20:29:35 <bos> er, nontrivial, even.
20:29:37 <sorear> dgriffi3: (only >=6.6)
20:31:15 <dgriffi3> odd, I don't have Data.Function, is it not included with GHC?
20:31:26 <allbery_b> ah, new oddball syntax
20:31:55 <sorear> dgriffi3: ghc --version
20:32:32 <dgriffi3> The Glorious Glasgow Haskell Compilation System, version 6.6
20:32:40 <sorear> oops
20:32:45 <allbery_b> Date/Function.hi isn't in my 6.6 but is in  my 6.7
20:32:48 <allbery_b> Data
20:32:51 <shapr> dibblego: I have a VirtualHost hpaste.org, and I want everything from port 8000 to show up on port 80 when someone asks for that name. I'm trying and failing to build a RewriteRule that works.
20:32:53 <sorear> I must've meant (only >6.6)
20:32:57 <LoganCapaldo> @type main = snd (1, main) :: IO ()
20:32:59 <lambdabot> parse error on input `='
20:32:59 <dgriffi3> ahh
20:33:06 <dgriffi3> thanks
20:33:09 -ChanServ(ChanServ@services.)- dons!i=dons@pill00.orchestra.cse.unsw.EDU.AU ACCESS [#haskell] DEL Janni!*@*
20:33:21 <sorear> dons: yay!
20:33:26 <LoganCapaldo> @type let main :: IO () = snd (1, main) in main
20:33:27 <lambdabot> IO () = snd (1, main) in main :: IO ()
20:33:28 <hpaste>  shapr pasted "apache not like shapr" at http://hpaste.org:8000/65
20:33:57 <sorear> dons: I guess I won't be stealing ops quite so soon :)
20:34:21 <dons> yeah
20:34:22 <sorear> kept forgetting to prod you about that line
20:34:31 <jcreigh> what did that notice from ChanServ mean?
20:34:42 <sorear> jcreigh: it means Janni isn't an op anymore.
20:34:43 <dibblego> shapr, why not use mod_proxy?
20:34:46 <dons> it meant i tweaked the op access list to remove some very old entry
20:35:11 <sorear> Anyone with UNIX username Janni could've taken ops with that line.
20:35:34 <shapr> dibblego: No reason.
20:35:39 <sorear> or, with a slightly configurable client, a hint of malice.
20:35:43 <jcreigh> which means "anybody" in today's internet.
20:36:13 <Excedrin> using IPs to authenticate things is a bad idea
20:36:30 <sorear> Excedrin: worse.
20:36:37 <sorear> Excedrin: any IP was allowed
20:36:41 <jcreigh> Excedrin: true. But all authentication methods are bad. :)
20:36:46 <glguy> no no no , Janni was a level 5, he could invite people to the channel
20:36:58 <dibblego> <VirtualHost *.8000>\nServerName hpaste.org\nProxyPass / http://hpaste.org/\nProxyPassReverse / http://hpaste.org/\n</VirtualHost>
20:37:15 <glguy> --5    5    CMDINVITE Use of command INVITE
20:37:36 <shapr> dibblego: I'll try that.
20:37:46 <dibblego> I have to admit, I haven't used mod_rewrite *that* much - but I've used mod_proxy a lot
20:37:51 * shapr is weathery the wintry #apache
20:38:01 <shapr> weathering
20:38:08 <bos> hmm, my poor parsec parser takes almost a second to parse 400K of text.
20:38:14 <dibblego> I got an earful from #apache earlier this morning
20:38:17 <jcreigh> glguy: oh, that's not so bad then. But this is open channel, nobody needs an /invite to get in...
20:38:21 <allbery_b> hm, isn't the problem with that that HAppS has port 80-00?
20:38:22 <sorear> glguy: Anyone can invite to a non -i channel
20:38:23 <shapr> So far, #haskell has been far more helpful than #apache
20:38:33 <dons> bos, you need a bytestring parser, or happy/alex with bytestrings
20:38:36 * glguy is aware
20:38:37 <bos> most big channels are giant gaping voids of suck.
20:38:45 <shapr> #haskell is different
20:38:46 <glguy> I was clarifying that he wasn't allowed to +o
20:38:48 <bos> dons: yes, i do :-)
20:38:48 <jcreigh> ...unless there's a $WEIRD_IRC_CORNER_CASE
20:38:59 <allbery_b> (dibblego's that is)
20:39:05 <shapr> Because we have SECRET LAMBDA ROBOTS that enforce peace on our channel.
20:39:13 <dons> bos, http://hackage.haskell.org/~paolo/darcs/ByteStringParser
20:39:15 <dons> possibly
20:39:15 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser
20:39:29 <dibblego> allbery_b, I have no idea; I just know how to take a request on a vhost at some port and proxy it to another host/port
20:39:44 <dons> bos, happy might just work too, if you have a ebnf grammar handy
20:39:46 <dibblego> and / will just do all requests
20:39:49 <shapr> In short, lambdabot is a sweet girl until you upset her... and then you better watch out.
20:40:03 <glguy> when someone +o's Colloquy makes a space gun noise, makes me think of dragon ball z when they power up
20:40:23 <bos> dons: it looks like Parsec would be easy to port on top of ByteString
20:40:36 <bos> just as jeremy did.
20:41:15 <glguy> dons: the hpaste README is the model of good informative documentation
20:41:17 <glguy> :-D
20:41:36 <dons> thanks glguy
20:41:55 * dons notes there were zero comments in hpaste 4 days ago
20:42:08 * glguy understood all the code 4 days ago
20:42:13 <dons> heh
20:42:37 <sorear> 5 days ago, I knew it all too.
20:42:37 <dons> well now you understand 48%, and I understand 12%
20:42:39 <dons> so we're doing ok
20:42:52 <dons> good thing ghc knows what the rest is doing
20:42:55 <glguy> comments... those are the blue things that clutter up your screen?
20:43:01 <glguy> and make it harder to find your code?
20:43:14 <dons> i think that's m and m's you're talking about?
20:43:39 * glguy syntax colors comments black on black to make coding more challenging
20:43:48 * sorear feeds hpaste through a comment chipper^Wstripper
20:44:42 <glguy>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
20:44:42 <glguy> 30493 eric      17   0  8864 6916 2496 S    2  2.6   0:27.24 hpaste
20:44:46 <glguy> looking a lot better
20:44:48 <hpaste>  nornagon pasted "fromInteger does not typecheck" at http://hpaste.org:8000/66
20:45:01 * glguy clicks the link to admire the site
20:45:12 <shapr> dibblego: Same error :-(
20:45:26 <dibblego> what's the error?
20:45:27 <glguy> 403 FORBIDDEN!
20:45:36 <nornagon>     Couldn't match expected type `c' (a rigid variable)
20:45:36 <nornagon>            against inferred type `Integer'
20:45:39 <Trevion> Anyone built wxWindows 2.4.2 on Windows recently?
20:45:40 <glguy> You don't have permission to access / on this server.
20:45:55 <nornagon> glguy: do hpaste.ath.cx:8000
20:46:00 <dibblego> that's a separate issue altogether
20:46:00 <dons> Trevion: hmm, kowey maybe
20:46:06 <glguy> nornagon: ohhhhhh
20:46:07 <shapr> client denied by server configuration: proxy:http://hpaste.org/66
20:46:17 <shapr> There must be a deny in there somewhere...
20:46:19 <nornagon> dibblego: ?
20:46:23 <glguy> Forbidden
20:46:23 <glguy> You don't have permission to access /66 on this server.
20:46:26 <dibblego> nornagon, sorry, something else
20:46:31 <nornagon> dons: oh, sry
20:46:36 <dibblego> shapr, must be - I've never seen that
20:46:36 <nornagon> er
20:46:40 <nornagon> dibblego even :(
20:46:43 <sorear> shapr: hpaste.org/../ gives a 302, not a 403
20:46:51 <shapr> wah?
20:46:54 <sorear> datapoint:  ^^^
20:47:05 <dons> glguy: hpaste.org is pretty swishy, its my dream pstebin now
20:47:08 <sorear> http://hpaste.org/../
20:47:15 <glguy> dons: I'm with you all the way
20:47:32 * glguy gets 403 and not 302 from hpaste.org
20:48:06 <sorear> glguy: what does your addressbar say?  if it's anything but hpaste.org/../, you got a 302.
20:48:23 <glguy> sorear: firebug says 403
20:48:26 <sorear> (then a 403 after your browser chased the redirect)
20:48:36 <glguy> and no redirect
20:49:04 <nornagon> so who wants to tell me why my thingy doesn't work? :(
20:49:08 <glguy> OH
20:49:28 * glguy always forgets why he went to the pastebin any more
20:49:35 <glguy> I get there and think of changes I want to make
20:49:39 <dons> heh
20:50:04 <lisppaste2> dibblego pasted "I get a 403" at http://paste.lisp.org/display/35834
20:50:23 <sorear> *retch*
20:50:26 <dons> can we kick lispaste2 yet?
20:50:34 <shapr> As soon as I fix this :-/
20:50:38 <dons> the net is so fickle
20:50:41 * shapr needs another sandwich
20:50:46 <hpaste> kicks dibblego
20:50:49 <dons> years of good service, only to be tossed into /dev/null
20:51:28 <sorear> shapr: it gets worse ... go to www.hpaste.org
20:51:59 <hpaste> shock*horror!
20:52:08 <sorear> oooh
20:52:16 <dons> heh
20:52:17 <glguy> shapr: I don't care what they say, I think you are doing alright
20:52:19 <bos> @pl \a->(head a, tail a)
20:52:19 <lambdabot> liftM2 (,) head tail
20:52:25 <sorear> that sounds worse even than shock+horror!
20:52:34 <bos> > tail "foo"
20:52:34 <sorear> liftM2 ... lambdabot beat me
20:52:35 <lambdabot>  "oo"
20:52:41 <bos> > head "foo"
20:52:42 <lambdabot>  'f'
20:52:50 <sorear> > head ""
20:52:50 <bd_> @pl \c f g a -> c (f a) (g a)
20:52:50 <lambdabot> liftM2
20:52:51 <lambdabot>  Exception: Prelude.head: empty list
20:52:52 <bos> huh
20:52:57 <glguy> fromEnum (Integer a) = fromInteger a
20:53:06 <glguy> nornagon: I don't think you can do that with (Integer a)
20:53:09 <sorear> Integer is a datacon!?
20:53:24 <glguy> oh
20:53:25 <sorear> (a :: Integer) ?
20:53:26 <nornagon> glguy: that bit works fine
20:53:33 <glguy> Integer :: Integer -> Scheme Integer
20:53:48 <nornagon> i guess that's confusing
20:53:55 <nornagon> should be ScmInteger or something
20:54:09 <bd_> nornagon: What type does fromInteger 42 have?
20:54:12 <bos> @hoogle ByteString -> (Char, ByteString)
20:54:12 <lambdabot> No matches, try a more general search
20:54:20 <nornagon> bd_: should be Scheme Integer
20:54:25 <bos> @hoogle Data.ByteString -> (Char, Data.ByteString)
20:54:26 <lambdabot> No matches, try a more general search
20:54:29 <bd_> nornagon: except you defined it for Scheme c :)
20:54:30 <bos> golly.
20:54:37 <bos> @hoogle Data.ByteString -> (Word8, Data.ByteString)
20:54:38 <lambdabot> No matches, try a more general search
20:54:39 <glguy> fromEnum (Integer a) = fromInteger a
20:54:44 <glguy> fromEnum (Integer a) = fromInteger a
20:54:48 <sorear> bos: liftM2 (,) B.head B.tail
20:54:48 <glguy> fromInteger i = Integer i
20:54:49 <nornagon> bd_: so how can i even get this to work then?
20:54:54 <bd_> nornagon: Not sure >.>;
20:55:18 <bd_> hmm
20:55:27 <bos> sorear: sure, i was just surprised there wasn't a builtin
20:55:42 <allbery_b> ?src Integer fromInteger
20:55:43 <lambdabot> Source not found. You speak an infinite deal of nothing
20:55:53 <bos> it's a natural function to need if you're turning "case (c:cs)" into something mangling ByteStrings
20:56:09 <nornagon> :t fromInteger
20:56:10 <lambdabot> forall a. (Num a) => Integer -> a
20:56:19 <shapr> Since I'm out of vegemite, I'm forced to use spicy mustard instead.
20:56:29 <Modius> Vegemite!!  Fellow Aussie.
20:56:40 <glguy> what does this actually mean: Integer :: Integer -> Scheme Integer
20:56:46 <glguy> isn't that recursive??
20:56:50 <sorear> bos: views!
20:56:50 <nornagon> no
20:56:55 <shapr> Modius: Nah, I'm from Alabama.
20:56:59 <nornagon> Integer the function =/= Integer the type
20:57:07 <allbery_b> ghc is smart enough to tell Integer-the-datacon from Integer-the-type
20:57:13 <bos> sorear: very nice! how much? :-)
20:57:18 <sorear> @hoogle Data.ByteString.ByteString -> Maybe (Char, Data.ByteString.ByteString)
20:57:18 <lambdabot> No matches, try a more general search
20:57:21 <allbery_b> same thing that makes Data Foo = Foo Int work
20:57:22 <glguy> oh :(
20:57:29 * glguy closes the bad window
20:57:33 <sorear> @hoogle Data.ByteString.Base.ByteString -> Maybe (Char, Data.ByteString.Base.ByteString)
20:57:33 <lambdabot> No matches, try a more general search
20:57:37 <glguy> marks it for deletion ;)
20:57:40 <sorear> @hoogle Data.ByteString.Base.ByteString -> Maybe (Word8, Data.ByteString.Base.ByteString)
20:57:41 <lambdabot> No matches, try a more general search
20:57:44 <glguy> !flush
20:57:50 <sorear> @flush
20:57:57 <dibblego> what is the function that is used for lists as [a..b]?
20:58:04 <sorear> enumFromTo
20:58:13 <dibblego> ?type enumFromTo
20:58:15 <lambdabot> forall a. (Enum a) => a -> a -> [a]
20:58:57 <glguy> I should add a pattern to hpastebot that accepts lisppaste2: url
20:59:29 <bos> i don't know if ghc does inlining across module boundaries, but if it does, defining my own \s->(head s, tail s) should perform fine.
20:59:29 <sorear> I should add a pattern to Plugin/Karma.hs that accepts lisppaste2: url
20:59:39 <glguy> lol
21:01:03 <sjanssen> heh
21:01:18 <sjanssen> probably a bad idea, just in case hpaste ever goes down
21:01:32 <glguy> "goes down"
21:01:33 <glguy> ?
21:01:50 <sjanssen> sorear: how about a contextual plugin that also spits out hpaste's url?
21:02:09 <sjanssen> glguy: shapr's server could catch on fire
21:02:20 <shapr> Lucky for me, it's in Atlanta.
21:02:23 <shapr> And I'm not!
21:02:24 <dons> yeah, i suppose hardware could fail
21:02:27 <glguy> sjanssen: not while hpaste is running on it though... :(
21:02:44 <sjanssen> shapr: oh, and Atlanta has never burned before
21:02:48 <sjanssen> </schadenfreude>
21:02:52 <shapr> heh
21:03:09 <glguy> happs sure generates a LOT of files
21:03:21 <shapr> They're transactions.
21:03:26 <dons> so now, a command line interface to hpaste
21:03:40 <glguy> sure, what functionality would it need to provide
21:03:45 <dons> so i can just 'hpaste put Foo.hs'
21:03:45 <Adamant> it's winter, server farms only catch on fire spontaneously in the summer in Atlanta
21:03:54 <shapr> And then, an emacs interface that ends up being TChan's between emacs sessions.
21:04:03 <glguy> oh, a separate binary?
21:04:03 <dons> glguy: well, ideally i'd have a darcsish repo for all the pastes
21:04:10 <dons> and i could just edit them, save them, and arcs push
21:04:12 * allbery_b is looking at nornagon's thing still, and thinking that fromInteger (and therefore Num C => Num (Scheme c)) can't be implemented that way
21:04:15 <dons> and it would annotate those entries
21:04:17 <dons> or create a new one
21:04:19 * dons dreams
21:04:19 <glguy> dons: "edit the pastes"?
21:04:33 <complaisant> how do i instance in Monad a recursive datatype like > date BTree a = Empty | Node (a,(BTree a, BTree a)) ???
21:04:47 <dons> well, paste's annotations are a diff/revision/patch of sorts
21:04:55 <allbery_b> so let';s say you add instances for Float.  how do you add the definition of fromInteger?
21:05:03 <glguy> we should formalize the paste algebra
21:05:06 * dons eats crepes with raspberry sauce for lunch, and ponders
21:05:15 <hpaste>  bd_ annotated "fromInteger does not typecheck" with "nornagon, maybe something like this?" at http://hpaste.org:8000/66#1
21:05:21 <complaisant> ?paste
21:05:21 <lambdabot> http://hpaste.org (Haskell pastebin)
21:06:00 <allbery_b> I'd' think you need a separate instance for each supported Num instance you're lifting
21:06:54 <bd_> I'm not sure, I would /expect/ (forall n. Num n => n -> n -> n) to work?
21:07:08 <bd_> of course there needs to be another copy for RealFloat and etc
21:07:11 <glguy>  ?paste is a broken link atm
21:07:13 <glguy> !paste
21:07:14 <hpaste> Haskell paste bin: http://hpaste.org:8000/
21:07:16 <glguy> complaisant: ^^
21:07:36 <lisppaste2> complaisant pasted "instance Monad BTree" at http://paste.lisp.org/display/35836
21:08:05 * glguy prods shapr
21:08:07 <allbery_b> bd_: again, how do you deal with the Float there?  (the others can be dne via pattern matching, that won't work for fromInteger)
21:08:25 * shapr prods glguy 
21:08:40 <bd_> allbery_b: fromInteger just always makes a SInteger
21:08:51 <allbery_b> I mean the original
21:08:51 <bd_> hmm
21:08:54 * glguy provokes shapr 
21:08:58 <bd_> oh, well, that's nornagon's paste :)
21:09:14 * shapr throws lambdas at glguy 
21:09:35 * glguy chivvies shapr :-D
21:09:48 <allbery_b> yeh.  I'm saying that what he's doing can't work; he needs a separate instance for Integer and for Float because you can't list fromInteger twice and one can't be made to work for both types
21:09:50 <hpaste>  bd_ annotated "fromInteger does not typecheck" with "hmm, fails to typecheck :/" at http://hpaste.org:8000/66#2
21:09:51 <sorear_> @tell sorear Go away, and don't come back!  (Until your homework is done)
21:09:51 <lambdabot> Consider it noted.
21:10:06 <shapr> Yay, a different error!
21:10:24 <bd_> hmm... is that use of existential types just not possible?
21:10:33 <bd_> numLift :: (forall n. Num n => n -> n -> n) -> ScmNum -> ScmNum -> ScmNum that is
21:10:33 <glguy> shapr: using what link?
21:10:46 <allbery_b> I think the problem is that fromInteger is only parametric in its return type
21:11:01 <allbery_b> er, polymorphic
21:11:02 <allbery_b> feh
21:11:13 <allbery_b> makes it hard to work with this way
21:11:20 <sjanssen> complaisant: another way of writing >>= is to think up a defn. for join :: BTree (BTree a) -> BTree a
21:11:53 <allbery_b> at least when you can't supply something equally polymorphic, as in this case
21:11:53 <sjanssen> then m >>= f = join (fmap f m)
21:12:14 <bd_> allbery_b: on annotation #2, is what I'm trying to do with the type of numLift possible?
21:14:26 <allbery_b> in #2?  looks to me like you're just fogetting to cast the result back to a ScmNum
21:14:36 <bd_> ... well, I feel silly now XD
21:15:19 * shapr feels silly too!
21:15:39 <shapr> Though my problem is this mutated Apache config.
21:16:00 <shapr> I figure any insult that includes 'mutate' in it is pretty bad on a pure FP channel.
21:16:13 <hpaste>  glguy pasted "tree with labeled leaves" at http://hpaste.org:8000/67
21:16:18 <shapr> IT WORKS!
21:16:19 * shapr boings!
21:16:30 <glguy> I know that's the "opposite" of what you wanted complaisant
21:16:33 <shapr> Finally.
21:16:34 <glguy> ?paste
21:16:34 <lambdabot> http://hpaste.org (Haskell pastebin)
21:16:42 <glguy> shapr++
21:16:45 <glguy> shapr++
21:16:55 <shapr> yay!
21:17:09 * glguy wonders if *.hpaste.org could work
21:17:19 <glguy> then I can pattern match on the hostname to provide features
21:17:19 <shapr> It could
21:17:26 <dibblego> <pedant> http://hpaste.org/ </pedant>
21:17:28 <dons> sweet
21:17:30 <dons> shapr++
21:17:47 * glguy sets out to update the in-memory url
21:17:58 <dons> glguy: you could follow up the -cafe mailing list with a small addendum saying that hpaste.org is now live
21:18:12 <shapr> Can I request darker text or a larger default font size?
21:18:16 <dons> and still running on base, HAppS >= 0.8.4, xhtml, mtl, network, hscolour >= 1.6, binary >= 0.2, zlib :D
21:18:42 <dibblego> is it using a RDBMS?
21:18:44 <dons> shapr: for the .hs code?
21:18:57 <dons> dibblego: Data.Map
21:19:08 <dons> + MACID
21:19:13 <glguy> shapr: what platform, the pastebin formatted text is huge on my computer
21:19:15 <sjanssen> lisppaste2: barf
21:19:30 <glguy> !quit ceremoniously
21:19:38 <glguy> !paste
21:19:38 <hpaste> Haskell paste bin: http://hpaste.org/
21:19:39 <shapr> Is there an hpaste announcement on -cafe?
21:19:44 <bd_> @hoogle Rational -> Float
21:19:45 <lambdabot> No matches, try a more general search
21:19:56 <shapr> glguy: I'm using linux/ff 2.x
21:19:58 <allbery_b> it's smallish on my linux mozilla and larger in my safari
21:20:06 <sjanssen> lisppaste2: url
21:20:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:20:11 <sjanssen> lisppaste2:  url
21:20:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:20:17 <allbery_b> both result from my respective monospace default font choices I think
21:20:20 <glguy> sjanssen: you seeing if hpaste responds?
21:20:31 <glguy> should it?
21:20:42 <sjanssen> glguy: I was going to write a lambdabot plugin to reply whenver it sees that text
21:20:52 <shapr> glguy: http://www.scannedinavian.com/~shae/hpaste.png
21:20:52 <dons> glguy: you centred the 'older newer' links?
21:20:56 <dons> i like them better on the left :)
21:21:09 <allbery_b> ?type fromRational
21:21:10 <lambdabot> forall a. (Fractional a) => Rational -> a
21:21:18 <dons> oh, tiny shapr
21:21:41 <dons> you've got a quishy courier?
21:22:08 <glguy> dons: < newer older >  ?
21:22:18 <glguy> < newer <   > older >
21:22:21 <shapr> quishy?
21:22:30 <dons> squishy :)
21:22:42 <allbery_b> shapr: yeh, that looks like my mozilla.  mozilla/firefox's default monospace font and font size sucks
21:22:54 <glguy> dons: I will move it to the left if you can get two people to agree before two disagree ;)
21:22:58 <hpaste>  bd_ annotated "fromInteger does not typecheck" with "woot, works" at http://hpaste.org/66#3
21:23:24 <shapr> allbery_b: I just upped it from 12 to 16, but it looks the same..
21:23:27 * glguy obviously liked it centered but is flexible
21:23:31 <allbery_b> hm
21:24:37 <dons> sjanssen: do you like the 'newer older' buttons in the centre or the left of the front page bottom row/
21:24:57 <glguy> I would probably add a margin between the table and the links
21:25:17 <dons> shapr: fwiw, http://www.cse.unsw.edu.au/~dons/tmp/screen.png
21:25:37 <glguy> mine looks still different
21:25:57 <allbery_b> hm, same here, size is fixed.  I changed the font and got one that looks larger, but I think it still ignores a user-specified size
21:26:12 <sjanssen> dons: no opinion
21:26:29 <shapr> hm
21:26:35 <dons> grr. i need a typography nazi!
21:26:43 <dons> what would knuth do?
21:27:05 <shapr> bringert seems to understand CSS, maybe he can suggest some way to get a common size display from hpaste?
21:27:10 <dons> glguy: logical argument: they should align with 'recent new'
21:27:20 <sjanssen> so, does the lisppaste2: url interceptor belong in lambdabot, or hpaste-bot?
21:27:33 <dons> shapr: ah yes. relative sizes instead of hardcoded px sizes
21:27:40 <dons> sjanssen: hmm, lambdabot?
21:27:50 <glguy> dons: you set 14px
21:27:57 <dons> yeah, bad me
21:27:57 <glguy> wha should  i try while I'm in here
21:28:02 <dons> shoud be 'normal' or something
21:28:14 <dons> and the other 'smaller' and 'larger' I guess?
21:29:01 <glguy> look now?
21:29:30 <shapr> eek
21:29:38 <shapr> smaller for me
21:29:42 <shapr> much smaller.
21:30:08 <glguy> now?
21:30:12 <glguy> this is 90%
21:30:20 <bos> hmm, parsec deeply believes that the world is a list of tokens.
21:30:30 <dons> bos, sounds reasonable for a parser :)
21:31:06 <bos> unfortunately, it believes that the basic kind of token is a [Char], and i want it to be a ByteString :-)
21:31:21 <ozone> bos: join the club :)
21:31:21 <dons> yeah :)
21:31:22 <allbery_b> you can do that
21:31:42 <bos> allbery_b: i'm all, uh, eyes
21:31:46 <allbery_b> not sure how much of it is dependent on CharParser = Parser String
21:31:49 <dons> ozone: seen our new agile pastebin written in 100% pure haskell libraries?
21:31:55 <dons> ?paste <--
21:31:55 <lambdabot> http://hpaste.org (Haskell pastebin)
21:32:02 <shapr> heh, agile
21:32:04 <ozone> dons: i presume zis is this 'hpaste' thing?
21:32:16 <bos> allbery_b: deeply embedded
21:32:18 <dons> cabal just works, plug and play with your libs
21:32:22 <dons> ozone: righty
21:32:27 <ozone> phwoar
21:32:30 <ozone> that's alotta spans
21:32:35 <dons> heh
21:32:37 <allbery_b> yeh, does look that way.  sad
21:32:38 <glguy> ozone: not a particularly inspiring announce, eh?
21:32:49 <ozone> dons: very cool
21:32:57 <shapr> glguy: still small for me
21:33:06 <ozone> looks fine in safari
21:33:09 <allbery_b> all the interesting stuff is explicitly Char.  feh
21:33:13 <glguy> yeah, i use safari
21:33:18 <glguy> so it will always look good there
21:33:41 <dons> ozone: point is it was *easy* though, and its doing e.g. on-demand gzipping of pages, binary serialisation with compression, all running on the happs web framework
21:33:46 <glguy> shapr: how is this? "100%"
21:33:48 <bos> allbery_b: i think what it needs is a typeclass of TokenStream
21:33:57 <ozone> dons: schmexcellent
21:34:01 <dons> its what we wanted to be able to do for web stuff in haskell, finally !
21:34:03 <shapr> larger
21:34:06 <allbery_b> actually I'm not sure of that
21:34:10 <bos> where TokenStream Char == ByteString, and TokenStream Int == [Int]
21:34:17 <shapr> but still small
21:34:19 <ozone> dons: at the pace you guys are going at, i reckon you'll be beating the erlang web guys
21:34:28 <allbery_b> unless you have the recent patch that overloads string constants, it'd be hard to make it work right
21:34:39 <dons> ozone: things are moving surely fast anyway
21:34:48 <glguy> shapr: everything is too small?
21:34:52 <allbery_b> for both its current Char and a proposed Data.ByteString.Char8
21:34:55 <glguy> shapr: or the monospaced stuff?
21:35:02 <shapr> The next really spiffy feature I can barely wait for is a predictable Haskell value <-> XML mapping via SYB
21:35:15 <shapr> just the monospaced
21:35:17 <bos> allbery_b: hmm, which patch?
21:35:23 <sjanssen> allbery_b: you need more than overloaded literals to do a generalized parsec
21:35:34 <allbery_b> true, that's just  a start
21:36:00 <allbery_b> but in its absence you have to do pretty much everythiing over, youcan't really generalize what's there
21:36:10 <bos> ripping out the plumbing that assumes all the world's a list is what's needed.
21:36:30 <dons> bos, ah so some thing more like a -> (token, a) ?
21:36:30 <ozone> bos: i tried about two years ago and failed
21:36:45 <ozone> then again, me not so smart
21:36:47 <bos> dons: that sort of thing.
21:36:53 <allbery_b> bos: I understand recently ghc HEAD (i.e. 6.7 devel in darcs) has a patch that allows string literals to overload as String or ByteString
21:37:00 <dons> bos, or the 'Get' monad we use in the binary parser
21:37:01 <shapr> oh?
21:37:10 * allbery_b hasn't updated his recently so has no details
21:37:11 <dons> which hides the (a -> (token, a)) steate
21:37:14 <bos> allbery_b: hm, neat
21:37:20 <bos> dons: yes
21:37:34 <dons> yeah, ghc head means things like f x | "foo" <- ByteString.take 4 x = ... works
21:37:58 <dons> sjanssen: should the pastebin msg be http://hpaste.org though?
21:38:01 * glguy removes the font-size decl
21:38:09 <shapr> @paste
21:38:09 <lambdabot> http://hpaste.org (Haskell pastebin)
21:38:25 <shapr> Shouldn't it be http://hpaste.org/new ?
21:38:50 <dons> ah yes
21:39:11 <sjanssen> dons: sounds good.  I'm already changing something in that area so I'll send that patch in a moment
21:39:29 <dons> cheers
21:39:35 <glguy> should i tell hpaste to stop responding to !paste then if lambdabot is ready to deal with it all?
21:39:46 <dons> not yet
21:39:47 <dons> but soon
21:39:58 <emu> yow
21:40:08 <dons> and then we can say good bye to lisppaste, in all its dyn typed scariness ;)
21:40:17 <dons> only strongly typed bots allowed !
21:40:19 <shapr> yay!
21:40:39 * dons rewrites ChanServ to run in the Op monad
21:40:52 <jcreigh> umm...forgive my heresy, but what was wrong with lisppaste?
21:41:16 <LoganCapaldo> it was written in lisp?
21:41:16 <glguy> jcreigh: no "annotate from here" lnk to make it easy to edit for one!
21:41:20 <dons> ugly? :)
21:41:25 <glguy> jcreigh: when it was down we couldn't do anything about it
21:41:33 <allbery_b> it was going down on weekends a lot
21:41:39 <dons> jcreigh: check hpaste.org out though, its pretty swish
21:41:45 <allbery_b> \then they added  a captcha that didn't work right in some text browsers
21:41:47 <dons> yeah, we relied on lisppaste too much, and it was down too often
21:41:50 <dons> that's what the seed was
21:42:05 <jcreigh> hmm, really? I'd never noticed it down. Guess I wasn't paying enough attention.
21:42:14 <glguy> when you are in channel all day
21:42:17 <glguy> you notice :)
21:42:20 <jcreigh> heh
21:42:21 <dons> but this looks a lot nicer too, http://hpaste.org/67
21:42:30 <dons> life's to short for ugly pastebins!
21:42:42 <glguy> jcreigh: we have diff support
21:42:53 <glguy> jcreigh: so you can find what someone changed, and compare side by side easier
21:42:57 <sjanssen> dons: you can ignore all but the last patch bundle I sent
21:42:59 <dons> yeah, the diff is quite nice
21:43:02 <dons> sjanssen: cheers
21:43:07 <dons> sjanssen++ patchy
21:43:13 <jcreigh> glguy: are hpaste IDs still mod 100? Or are there only 68 (started at zero, I think) pastes so far?
21:43:22 <glguy> jcreigh: they are not limited now
21:43:23 <dons> nah, Integer
21:43:29 <dons> so go nuts
21:43:39 <nornagon> heh
21:43:43 <jcreigh> glguy: cool, that was my one reservation. Nice work.
21:43:45 <jcreigh> glguy++
21:43:48 <sjanssen> do the pastes expire?
21:43:49 <glguy> shapr has tons are ram, right shapr?
21:43:53 <dons> sjanssen: nope
21:44:00 <shapr> err
21:44:02 <shapr> I dunno.
21:44:05 <shapr> But I can buy more ram.
21:44:10 <dons> we can leave some pastes on disk eventually ;)
21:44:12 <glguy> if it gets to where they need to, we can prune
21:44:29 <glguy> yeah, or old pastes could be archived
21:44:30 <dons> its just a lazyRead out of the Serial instance , anyway
21:45:56 * glguy is searching for free icons for table headers
21:46:23 <dons> glguy: you need to :set expandtab -- ;)
21:46:39 <glguy> i have it set locally
21:46:44 <glguy> but i forget when i edit on kakapo
21:47:11 * shapr luvs the ScannedInAvian logo
21:47:17 <shapr> I gotta ask her to draw me a kakapo
21:47:30 <dons> so, can you left align the newer older buttons? they icky in the middle. maybe one line pushed down, and to the left
21:47:50 <glguy> dons: they are left aligned...
21:48:00 * dons reloads
21:48:06 <dons> ah !
21:48:08 <dons> much better :)
21:48:53 <shapr> hiya JohnMeacham, how's jhc?
21:49:14 <JohnMeacham> doing well. the ghc back end is quite useful.
21:49:41 <JohnMeacham> I'd like to recruit some people to help maintain it, so I can work on my crazy not terribly useful at the moment other backends.
21:52:09 <Adamant> what are the avaliable formal methods/high assurance tools for Haskell?
21:52:43 <shapr> I think there's a list on the wiki.
21:53:48 <dons> Adamant: Quickcheck + Isabelle   seems to be the combination used in industry
21:54:14 <dons> pages,papers describing this set up are on the 'Research papers' part of the wiki, under 'verification'
21:54:15 <emu> we need some high assurance tools for our pastebot
21:54:26 <emu> 5 9s reliability!
21:54:48 <dons> heh
21:56:01 <Pseudonym> And ACID compliance.
21:56:20 * shapr does a fall over transaction into his bed
21:57:25 <Adamant> dons, thanks!
21:58:12 * Pseudonym hopes shapr doesn't rollback
21:58:12 <Pseudonym> Night.
22:13:41 <glguy> dons:
22:13:45 <dons> mmm did anyone see this "I work at Deutsche Bank. I am using Haskell to manage several
22:13:49 <dons> databases, using HDBC and HAppS, and do some data mining"
22:14:27 <bos> yep.
22:14:43 * glguy considers moving the text box labels into the text boxes in grayed out text
22:14:48 <bos> wall street has a lot of phds looking to put their skills to remunerative use :-)
22:14:49 <glguy> that clear when you click them the first time
22:15:50 <glguy> then it'd be easier to fit everything in one line
22:16:03 <glguy> though the check boxes would be rather inconsistent
22:16:11 <kilimanjaro> If I worked on Wall Street I would use Haskell too, and just spit out C++ as a facade.
22:16:42 <glguy> dons: I intentionally use tabs in the CSS file, makes it smaller ;)
22:17:18 <dons> kilimanjaro: that's exactly what Credit Suisse is doing
22:17:38 <kilimanjaro> dons, who?
22:17:53 <dons> at credit suisse?
22:18:03 <dons> lennart , ganesh and gabi
22:18:21 <kilimanjaro> dons, ahh
22:18:21 <dons> haskell edsl over their c++ / excel libs
22:19:12 <kilimanjaro> Out of curiosity, how many people own copies of the haskell 98 report (dead tree)?
22:19:24 <kilimanjaro> err, how many people in this channell... a little poll
22:19:24 <reilly> me
22:19:28 <kilimanjaro> channel*
22:19:30 <dons> i've got one
22:19:37 <dons> ?users
22:19:37 <lambdabot> Maximum users seen in #haskell: 322, currently: 282 (87.6%), active: 27 (9.6%)
22:19:43 <dons> kilimanjaro: ^^
22:19:51 <dons> we hit 322 this morning, around 11 hours ago
22:20:09 <dons> putting us briefly into #12 in size, of freenode's 4000+ channels :}
22:20:39 <dons> this is the quiet period though
22:20:41 <kilimanjaro> dons, congratulations :) But I actually was just correcting my previous question, reducing the set of discourse from the universe to just the people in this channel (who are active right now)
22:20:43 <Korollary> This is the Kia of freenode channels?
22:20:45 <nornagon> 17:17:01 -!- Irssi: #ruby-lang: Total of 395 nicks [0 ops, 0 halfops, 0 voices, 395 normal]
22:20:50 <nornagon> ^- still behind!
22:21:15 <Pseudonym> You can't grep dead trees.
22:21:15 <dons> kilimanjaro: well, active: 27 (9.6%)
22:21:21 <dons> is people who've spoken in the last 4 hours
22:21:39 <dons> ?users
22:21:39 <lambdabot> Maximum users seen in #haskell: 322, currently: 282 (87.6%), active: 28 (9.9%)
22:21:44 <dons> make that 28
22:22:02 <dons> nornagon: closing fast though!
22:22:11 <dons> they've stabilised around that mark for the last few months
22:22:30 <Korollary> We seem to be hung up on channel size for some reason.
22:22:46 <Korollary> for me there's no difference between 300 and 600
22:22:48 <dons> Korollary: one of the few community growth issues that we have numbers for
22:23:03 <dons> so yeah, you only care about what you can measure blah blah
22:23:13 <jcreigh> well, I'm in both #haskell and #ruby-lang, so that means my net effect is in the rankings is zero. :)
22:23:35 <dons> Korollary: if we had 600 though it would be a bit surreal, no language channel is that big
22:24:01 <Korollary> dons: since joining a channel is very cheap, I don't think 600 means anything.
22:24:09 <reilly> so what your saying is "size does matter"
22:24:12 <reilly> you're
22:24:34 <dons> growth in users indicates some trend in visibility of haskell (and the channel )
22:24:44 <dons> as does grwoth in the mailing list traffic
22:24:52 <dons> they've mirrored each other for the last 5 years
22:25:35 <dons> in turn, a few people stick around, write more code, making it easier for others to pick up, and so we go around
22:25:36 <Korollary> I'd rather look at number of downloads of ghc
22:25:51 <dons> which we don't have, since its distributed across the OS packages
22:25:54 <Pseudonym> I get mine packaged.
22:25:56 <Pseudonym> Right.
22:26:03 <dons> so, you care about what you can measure
22:26:50 <glguy> dons: http://hpaste.org/61
22:26:52 <kilimanjaro> or you could put spyware in a new release of ghc
22:26:55 <glguy> the form at the bottom
22:26:57 <Korollary> ok, wikipage views then
22:26:58 <dons> heh or that
22:26:59 <glguy> better?
22:27:09 <dons> Korollary: we do have that
22:27:17 <dons> its gone from around 1k to 2k / per day on h.o
22:27:24 <dons> and 500k for the year since we set it up
22:28:00 <dons> glguy: looks the same?
22:28:07 <glguy> still pushing under?
22:28:14 <Korollary> hackage and ghc trac
22:28:15 <dons> yeah
22:28:29 <jcreigh> Another useful benchmark might be how well the language + libraries help solve the problems you're working on. :P
22:28:32 <dons> yeah, hackage will help
22:28:42 <Korollary> jcreigh: But, I don't have any problems :)
22:28:59 <dons> jcreigh: right so i actually noticed this for the first time: i didn't need to write any libraries to get everything i needed out of hpaste.org
22:29:17 <dons> since compression, net, web, binary, xml, http, all the libraries were ready to go
22:29:20 <dons> so that's a good sign
22:29:31 <dons> glguy did push some patches back into happs
22:29:32 <kilimanjaro> dons, I have you beat. I didn't even have to write any code to get everything I needed out of hpaste.org
22:29:41 <dons> heh
22:30:04 <kilimanjaro> (Maybe that's cheating)
22:30:24 <dons> so i agree with jcreigh, its the availability of libs that just work for solving all the average kind of problems you face that matters
22:30:32 <dons> and that's definitely easier now than even 6 months ago
22:30:47 <kilimanjaro> Actually, that's the reason I started learning Haskell in the first place
22:30:54 <dons> so you can think more about app design, and less about what libs are missing
22:31:43 <kilimanjaro> I went through my big FP epiphany with Scheme via SICP, but I felt constantly constrained by mediocre (or minimal) implementations.
22:31:43 <dons> so for the huge number of apps that are just string + web processing, a bit of xml, network, db stuff, its all ready to go now
22:32:03 <dons> and you get to layer that over a nice language, instead of a gunky one
22:32:33 <dons> maybe scheme is hampered by being a teaching language?
22:32:45 <dons> whereas the teaching view of things is being left behind here
22:32:55 <dons> haskell is the C++ of FP ;)
22:33:11 <Korollary> C++ is not interesting in the industry
22:33:47 <Korollary> I can't think of an analogy at all
22:33:47 <Pseudonym> Nothing is "interesting" to industry.  Industry doesn't do "interesting".
22:34:05 <jcreigh> For practical stuff, scheme has too much "Just use SRFI-XX, which may or may not be in your implementation" and not enough "Use this, it's builtin and standard."
22:34:10 <Korollary> Well, you could say the industry found XML interesting
22:34:20 <dons> jcreigh: hmm. very interesting
22:34:42 <jcreigh> IMO, anyway.
22:34:58 <dons> jcreigh: oh, but they're divided over different incompatible implementations
22:35:06 <dons> instead of a single compiler + library suite
22:35:16 <kilimanjaro> dons, yea, Scheme doesn't really need any libraries anyways, since all Scheme is used for is writing interpreters and compilers for subsets of Scheme.
22:35:22 <dons> heh
22:35:31 <Pseudonym> True, XML was interesting, in the sense that it's complexity in a can.
22:35:50 <Pseudonym> And it was better than SGML.
22:35:53 <dons> you can get jobs now doing fusion on xml transformations for big big companies
22:35:57 <dons> just to speed up the processing
22:36:01 <dons> (invited talk a popl by ibm)
22:36:18 <Korollary> XQuery is interesting. It's a pure FP.
22:36:37 <Korollary> thanks to Wadler et al
22:36:43 <glguy> !quit -- because uptimes are for stale projects
22:37:33 <Pseudonym> ?uptime
22:37:33 <lambdabot> uptime: 2h 30m 7s, longest uptime: 2d 3h 42m 19s
22:38:06 <dons> admittedly, we patch it everyday these days. too much acgtive dev!
22:38:20 <dons> lambdabot is a feature bloat framework
22:38:28 <nornagon> s/everyday/every day/ :(
22:38:59 <Pseudonym> Yay for loose coupling.
22:38:59 <Korollary> Every time you misspell, the queen loses 3 minutes of sleep.
22:39:02 <dons> :| :/ :- :\ :| :- :/ :- :)
22:39:09 <nornagon> heh
22:40:09 <Pseudonym> Sounds like an invitation for budding republicans to engage in safe terrorism to me.
22:41:07 <Korollary> I'm not sure if the queen is against them.
22:43:52 <Pseudonym> Anyway, I gots to go.
22:43:54 <Pseudonym> Nytol!
22:54:36 <glguy> defeated!
22:56:43 <dons> hmm?
22:58:40 <glguy> *now* look at the fieldsets?
22:58:56 <glguy> come on..... work
22:59:22 <glguy> I corrected a subtle safari issue with those two forms
22:59:42 <glguy> did you notice the select boxes changed?
23:00:51 <dons> ah ok. so they're on two different lines now?
23:00:57 <glguy> only if they have  to be
23:01:23 <glguy> you need to give me an account so I can Xforward an instance of your browser
23:01:41 <dons> hmm, they're lways on 2 lines in my browswer
23:01:43 <dons> even if they'd fit
23:01:57 <dons> e.g. http://hpaste.org/62
23:01:58 <glguy> still?
23:02:16 <dons> yeah
23:02:26 <dons> browsers suck
23:02:40 <glguy> whaddaya say, give me an account for a second and let me play with a forwarded firefox?
23:02:48 <glguy> how slow could it be?
23:03:11 <dons> no idea, really slow? over wifi?
23:03:19 <glguy> wifi is no problem
23:03:25 <dons> behind a firewa too hmm
23:03:28 <dons> too much work!
23:03:28 <glguy> it the *Internet* I'm worried about
23:03:58 <dons> anyway, you're using firefox on linux right?
23:04:02 <glguy> os x
23:04:09 <glguy> I leave linux to other people
23:04:22 <glguy> openbsd servers, os x laptops, windows desktops
23:04:57 <kolmodin> morning!
23:05:01 <dons> so how many checkpoints do we have now?
23:05:14 <dons> i had some funny things happening when i randomly delated checkpoints
23:05:21 <dons> but i dont like the idea of keeping so many around :)
23:05:24 <dons> morning kolmodin !
23:05:48 <glguy> dons: I wait until the 100's place kicks over
23:05:55 <glguy> and move them into a old/
23:05:55 <dons> heh
23:06:10 <glguy> and the next time it kicks over
23:06:13 <glguy> i delete old
23:06:15 <glguy> and move more in
23:06:42 <glguy> nice to know that if we got vandalized, it'd be a complete breeze to roll back
23:06:43 <glguy> ;)
23:07:24 <dons> yeah
23:07:34 <dons> those pastes are pretty valuable, really
23:07:39 <dons> it'll be a lot of haskell code in the end
23:07:59 <dons> some of it pretty cool
23:12:24 <glguy> dons: I set the titles to be $PASTETITLE - hpaste
23:12:26 <glguy> because
23:12:35 <glguy> windows task bar
23:12:39 <glguy> and others
23:12:42 <glguy> trim from the beginning
23:13:02 <glguy> so if you had many pastes open, they might all say "hpaste - ..."
23:13:10 <glguy> or even just one or two
23:13:28 <Korollary> genius
23:14:21 <glguy> ?karma
23:14:21 <lambdabot> You have a karma of 46
23:15:21 <kolmodin> dons: tried the ?unmtl? :)
23:15:39 <glguy> ?unmtl Data.Map.lookup
23:15:40 <lambdabot> err: Parse error
23:15:51 <glguy> oh, does it take a type sig
23:15:55 <glguy> ?help unmtl
23:15:55 <kolmodin> yeah
23:15:56 <lambdabot> unroll mtl monads
23:16:04 <kolmodin> unhelpful help, perhaps
23:16:09 <Procyon> Lets say I have "data T = I Int | S String | Pair ..." where Pair is a constructor that takes 2 T's, one of them (I n) and the other (S s).  Should I make pair (T,T), break Pair out into it's own class, or is there a way to do something like: "Pair (T::(I a), T::(S b))"?
23:16:11 <kolmodin> ?unmtl State s a
23:16:11 <lambdabot> s -> (a, s)
23:16:12 <glguy> that's the kind of ?help *I* would write
23:16:35 <dons> kolmodin: yeah
23:16:42 <glguy> !help
23:16:43 <hpaste> no
23:16:57 <int-e> glguy: you mean the format and diff fieldsets, right? they're on the same line in my firefox, unless I make the window very narrow. They overlap in the later case though.
23:17:14 <glguy> int-e: they "overlap"
23:17:22 <glguy> i.e. become unusable?
23:17:34 <glguy> or they stack?
23:17:49 <dons> Procyon: hmm can you @paste and describe there what you want to do/
23:17:52 <dons> ?paste <--
23:17:53 <lambdabot> http://hpaste.org (Haskell pastebin)
23:17:58 <glguy> ^^
23:18:07 <dons> bit hard to grok all one one line
23:18:32 <int-e> glguy: see http://int-e.home.tlink.de/tmp/overlap.png
23:18:43 <glguy> UGH
23:19:25 <glguy> int-e: any change?
23:19:54 <int-e> interesting, isn't it? (hmm. Firefox 2.0.0.1 ... wonder if that is the official release)
23:19:57 <int-e> glguy: none
23:20:12 <glguy> I'm running 2.0.0.1
23:20:44 <glguy> int-e: did it do that previously?
23:20:56 * glguy change the padding
23:20:58 <glguy> any effect?
23:21:13 <int-e> yes. no overlap now.
23:21:20 <glguy> ha!
23:21:28 <glguy> dons, yours is still borked?
23:21:45 <robreim> dons [for hs-plugins]: any idea where this .hi file stuff in the ghc source code was?
23:21:48 <dons> ?docs System.Process
23:21:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
23:21:52 <dons> robreim: yeah, gimme a sec
23:23:13 <hpaste>  Procyon pasted "Constructor Question" at http://hpaste.org/69
23:23:26 <int-e> glguy: I don't know whether it did that previously though.
23:23:39 <dons> robreim, ghc/compiler/iface/BinIface.hs
23:23:40 <glguy> int-e: I don't care now that I have it fixed :)
23:24:11 <robreim> dons: thanks :)
23:24:28 <dons> still on 2 lines glguy
23:24:47 <Procyon> dons: pasted
23:24:48 <glguy> are you refreshing?
23:24:52 <glguy> or just looking back at your window?
23:25:19 <dons> Procyon: so what's the question?
23:25:25 <dons> What should STSKI_Apply take?
23:25:25 <hpaste>  glguy annotated "Constructor Question" with "updated" at http://hpaste.org/69#1
23:25:28 <dons> (looks ok to me)
23:25:41 <glguy> http://hpaste.org/69/diff?from=0&to=1
23:25:48 <glguy> Procyon: use that link :)
23:26:03 <glguy> how about an "announce this diff" ubtton?
23:26:39 <dons> Procyon: yeah, glguy is right, just have the evaluator reduce both args
23:26:45 <dons> with the function first, then apply it
23:26:59 <glguy> if it's not a function... blow up!
23:27:11 <dons> glguy: should be at lesat a link to 'link' on a diff apge?
23:27:21 <glguy> dons: definitely
23:27:22 <dons> so you can do a diff, and then get a link to paste, if oyu want
23:27:37 <glguy> dons: this is a case where GADTs would be used?
23:27:43 <dons> glguy: also, I'd change From/To to be Old/New
23:27:45 <glguy> to ensure that one side is a function?
23:27:46 <dons> more intuitive
23:28:03 <dons> not sure. we'd have to ask apfelmus
23:29:45 <Procyon> yeah, I realized I should reduce furst after I asked... but the question is still interesting to me.  Say I wanted the function part to be explicit (no higher order functions, like c).  Should I still have it be a STSKIExpr, or should I make a seperate type for Functions, or can I reference the constructor directly somehow to constrain that param to only a subset of STSKIExpr like I attempted in t
23:30:07 <glguy> dons: this is especially good because i have "no link" there now
23:30:18 <dons> yeah, a separate type is usually the way to stratify things for more compile time checks
23:30:43 <dons> glguy: what does 'no link' do? i didn't understand it.
23:30:52 <glguy> made the page not break
23:30:56 <glguy> when that <ul> was mepty
23:30:58 <glguy> empty
23:31:16 <Procyon> dons: ok, thanks
23:31:22 <Procyon> dons++
23:31:27 <Procyon> glguy++
23:31:48 <glguy> Procyon: glad you liked!
23:31:49 <Procyon> (is that how you do that?  I feel like such a noob here ;))
23:31:59 <sjanssen> Procyon: that is correct
23:32:03 * int-e realizes that it's hpaste.org now. neat.
23:32:03 <Procyon> hehe
23:32:10 <glguy> Procyon: I don't think it worked... try again ;)
23:32:15 <glguy> lol, dons, changes are in
23:32:23 <Procyon> @glguy++
23:32:23 <lambdabot> Unknown command, try @list
23:32:39 <allbery_b> @karma glguy
23:32:40 <lambdabot> glguy has a karma of 47
23:32:48 <sjanssen> Procyon: the syntax is somenick++or-- followed by whitespace or end of line
23:33:05 <dons> glguy: oh works now!
23:33:07 <sjanssen> @karma somenick++or
23:33:07 <Procyon> sjanssen: ok. gotcha
23:33:07 <lambdabot> somenick++or has a karma of -1
23:33:12 <sjanssen> oops
23:33:12 <dons> no funny breaks at the bottom
23:33:17 <glguy> dons: fuck yeah!
23:33:32 <dons> http://hpaste.org/69 looks perfect
23:33:34 <glguy> oh thank god, I was going to have that on my mind for ever
23:33:48 <dons> heh
23:34:00 <Procyon> So, is the karma actually used for anything, or just for stroking ego?
23:34:09 <dons> Procyon: hmm, it can be traded in for ops
23:34:19 <dons> but that's an ad hoc rule
23:34:36 --- mode: ChanServ set +o glguy
23:34:40 <dons> (that we're attempting to formalise)
23:34:42 <Procyon> I see
23:34:43 --- mode: glguy set -o glguy
23:34:52 <dons> glguy practices his new ops
23:34:58 <hpaste>  setuid_w00t pasted "What is wrong with this simple function?" at http://hpaste.org/70
23:35:06 * glguy admires the short url
23:35:15 * glguy gets lost looking at the colors
23:35:18 <dons> its teensy
23:35:27 <Procyon> dons: /69 has the constructor as a param to STSKI_Apply rather than a type.  Is that legal?
23:35:50 <dons> glguy: again i looked for the annotate button *under* the src box
23:35:52 <dons> i wonder why
23:36:02 <int-e> dons: lisppaste habit?
23:36:03 <glguy> dons: I'm not adding it there :-p
23:36:07 <hpaste>  sjanssen annotated "What is wrong with this simple function?" with "parens around x:xs" at http://hpaste.org/70#1
23:36:09 <glguy> I always hated that
23:36:11 <dons> maybe raw / link / annotate should be under
23:36:25 <glguy> :-/ you are definitely going ot have to get support from other people on that one
23:36:30 <dons> ok. must be burnt into my brain somehow
23:36:40 <glguy> I'll budge, but it's going to take support
23:36:41 <dons> no, i'm just noticing things i instinctively do
23:36:54 <dons> we'll see if it stil happens tomorrow
23:36:58 <int-e> glguy: have both ;)
23:36:58 <glguy> lol
23:37:14 <glguy> int-e: another case of needing support :-p
23:37:39 <Procyon> dons:  http://hpaste.org/69 has the constructor as a param to STSKI_Apply rather than a type.  Is that legal?
23:37:49 <setuid_w00t> sjanssen: Thanks.  That makes sense.
23:37:49 <allbery_b> nope
23:37:59 <int-e> glguy: make it user configurable? (note. I seriously have no idea how difficult and how useful that would be. but it's certainly too early to do that.)
23:38:16 <glguy> int-e: technically that wouldn't be hard
23:38:26 <sjanssen> glguy: I want an "annotate with current text" button
23:38:33 <glguy> sjanssen: ok, done
23:38:39 <glguy> !id add it
23:38:43 <glguy> !say done
23:38:43 <hpaste> done
23:39:26 <glguy> sjanssen: maybe you want me to be more explicit in the text of "annotate" under "12 minutes ago" ? that's reasonable
23:39:32 <glguy> it used to say annotate from here
23:39:35 <glguy> but dons changed it
23:39:36 <int-e> glguy: hmm, on a bikeshed matter, did you try white as the background color for the highlighted entry on the front bar? the contrast to the nonhighlighted part seems very poor now.
23:40:07 <glguy> int-e: That was a Saizan patch... so I'm open to ideas
23:40:15 <glguy> change the highlight color or table color?
23:40:41 <sjanssen> glguy: I just didn't realize the difference between annotate at the top and annotate per post
23:40:50 <glguy> Saizan: no offense at all, i just have less personal interest ;)
23:40:59 <Saizan> :P
23:41:01 <glguy> sjanssen: easy mistake to make, do you think most people do?
23:41:05 <dons> glguy: ah, see, i didn't get the 'annotate' at the top either
23:41:10 <glguy> lol
23:41:15 <glguy> I'm adding features without restarting!
23:41:17 <dons> so 'anotate' at the top shoudl be 'reply' or something
23:41:24 <glguy> AH
23:41:32 <glguy> that sounds reasonable
23:41:43 <glguy> any opinions before I code that in?
23:42:02 <dons> i think that might be enough of a distinction to make it work
23:42:02 <int-e> glguy: let me try offline :)O
23:42:24 <Saizan> maybe we shhould take the html generation out of the code
23:42:42 <Saizan> by xml+xslt
23:43:12 <glguy> revise rewrite redraft rework
23:43:18 <int-e> glguy: just making the highlight white looks good to my eyes. (that'd be tr.pastes:hover)
23:43:20 <glguy> polish modify adapt
23:43:39 <glguy> int-e: tr.pastes:hover /= portable :(
23:43:44 <glguy> this is a javascript code change
23:43:53 <glguy> and I haven't pulled the js into a dotJS
23:44:00 <int-e> glguy: hmm. I have javascript turned off ... hmm.
23:44:13 <glguy> int-e: maybe you don't notice the highlighting
23:44:17 <glguy> because it isn't highlighted
23:44:38 <int-e> glguy: it is highlighted, because the :hover works ;)
23:44:47 <int-e> portable or not.
23:44:51 <glguy> WHO
23:44:52 <glguy> whoa
23:44:56 <glguy> I didn't see that
23:44:58 <glguy> hmm
23:45:21 <glguy> I need to review these patches closer, I'm losing my grasp on what's going on
23:45:26 <int-e> well, it's from #f8f8f8 to #fbfbfb in the css. 3 levels of gray are barely noticable :)
23:45:40 <glguy> I changed it to white
23:45:55 <dons> yeah, i think 'annotate' shoud be 'reply'
23:46:04 <glguy> do I hear a second?
23:46:19 <dons> glguy, re. losing track. just rebuild once a day
23:46:23 <dons> so you can think about the patches
23:46:24 <int-e> Hmm. I like 'annotate'
23:46:26 <Saizan> yeah forum-imsh
23:46:31 <glguy> dons: naw, this is more exciting
23:46:35 <dons> true
23:46:41 <dons> but it can get scary ;)
23:46:45 <int-e> Hmm. 'comment'?
23:46:49 <int-e> I dislike 'reply'.
23:46:54 <glguy> I like annotate
23:46:58 <dons> reply has the email like feature of including the text
23:47:02 <glguy> could we just have "annotate with"
23:47:03 <glguy> or
23:47:05 <dons> so it makes sense for me at least :)
23:47:07 <glguy> "annotate from"
23:47:16 <int-e> I don't know why though, and it's another bikeshed.
23:47:24 <dons> its really the annotate at the top that doesn't make sense
23:47:29 <dons> maybe it should be ast the bottom
23:47:30 <glguy> well... people are missing the fact that it is there
23:47:32 <dons> and called 'reply'
23:47:41 <dons> so you add a new entry at the bottom
23:47:49 <glguy> dons and sjanssen didn't know you could annotate with text
23:48:04 <dons> yeah, cause we click the top button
23:48:06 <glguy> interpret mark-up add notes
23:48:09 <dons> when we want the middle ones
23:48:13 <glguy> comment on
23:48:30 <sjanssen> something like "blank reply", and "reply with" are painfully obvious
23:49:02 <dons> what does reddit do?
23:49:02 <int-e> glguy: "comment on, annotate or reply to this paste." - nothing beats a good compromise ;)
23:49:05 <Saizan> why don't make the top link a reply with text too?
23:49:13 <dons> ah, 'reply'!
23:49:18 <glguy> LOL
23:49:21 <dons> and 'comment'
23:49:30 <dons> so 'comment' gives you an empty top level annotatoin
23:49:39 <dons> and 'reply' for cincluding text
23:49:46 <dons> yeah, i could live with 'comment' and 'annotate'
23:49:52 <glguy> I might sleep on this and pick paint in the morning
23:49:58 <dons> where 'comment' is the empty annotate
23:49:59 <int-e> and annotate lets you add remarks on a margin?
23:50:02 <int-e> haha.
23:50:13 <glguy> I could have a list of words
23:50:17 <glguy> and one is randomly choses
23:50:19 <glguy> chosen
23:50:24 <sjanssen> yuck
23:50:39 <int-e> well that would just be bad UI design
23:50:41 <allbery_b> or random insults like cheeky-mode in lbot? :)
23:50:44 <glguy> "annotate this"
23:50:50 <glguy> "new annotation"
23:51:11 <glguy> LOL, hpaste: YOUR CODE DOESN"T TYPECHECK, ASS
23:51:23 <glguy> paste again laster
23:51:27 <dons> heh
23:51:28 <int-e> glguy: better make up a random word like "quurtzify paste" and stick to it.
23:51:44 <dons> i do like 'reply'
23:51:48 <dons> maybe i can start a movement
23:51:54 <dons> mutt and reddit can't be wrong!
23:51:55 <glguy> fork!
23:52:00 <dons> :P
23:52:01 <glguy> we could fork over this
23:52:05 <glguy> hpaste-reply
23:52:06 <sjanssen> how about "map f" and "map (const x)"
23:52:08 <glguy> hpaste-annotate
23:52:15 <glguy> hpaste-comment
23:52:22 <int-e> hpaste-quurtzify
23:52:34 <glguy> no, I would change the license to prevent that one
23:52:37 <sjanssen> the const says we don't care about the original
23:52:42 <Saizan> aht about multiple css-es? so anyone pick his word?:D
23:52:49 <glguy> sjanssen: it says we don't care about your paste
23:52:57 <glguy> sjanssen: and that it will be discarded and the current one used
23:53:07 <glguy> OH
23:53:08 <glguy> >>
23:53:09 <glguy> >>=
23:53:14 <glguy> no?
23:53:14 <allbery_b> >>= return . annotate vs. >> return . annotate -- not serius
23:53:16 <allbery_b> heh
23:53:23 <glguy> allbery_b: we were on the same page
23:54:24 <xerox> What about >>= and >>
23:54:29 <glguy> :-p
23:54:57 <glguy> sorry, you can't use hpaste until you understand monads
23:55:00 <sjanssen> about 10 percent of the time, hpaste should respond with "GHC has determined that your useless paste will not be viewed by anyone -- ever.  Therefore, your paste has been garbage collected."
23:55:07 <xerox> glguy: pedagogical effort
23:55:15 <dons> sjanssen: yeah if say there's more than 5 type errors
23:55:27 <glguy> a homework filter?
23:55:42 <int-e> glguy: hah. as a next step you can incorporate Dr.Haskell perhaps and only accept code that it doesn't complain about.
23:55:50 <dons> or it just silently rewirtes the paste to pointfree form
23:55:53 <dons> for fun
23:55:58 <xerox> :o
23:55:59 <sjanssen> glguy: I want hpaste to embed ghci
23:56:01 <sjanssen> and vim
23:56:07 <glguy> sjanssen: I like vim too
23:56:07 <glguy> ok
23:56:08 <sjanssen> and xterm
23:56:10 <dons> so 'format' can have 'number lines' and 'permanently rewrite to pointfree'
23:56:12 <sjanssen> and dwm
23:56:23 <glguy> sjanssen: dwm is awesome
23:56:25 <glguy> I'm in
23:56:26 <sjanssen> and a tetris game
23:56:29 <glguy> send the patch in the morning
23:56:30 <allbery_b> int-e: nah, it just substitutes the Dr.Haskell output in that case :)
23:56:33 <glguy> and I'll apply it
23:57:03 <xerox> Now imagine, you doubleclick a paste, and it gets loaded, and the frame becomes a lambdaweb instance with the code let-ted.
23:57:05 <allbery_b> perhaps with {- neener, neener -}
23:57:07 <glguy> sjanssen: are you trying to tell me to "shut up about hpaste and move on already, shesh"?
23:57:27 <sjanssen> glguy: not at all, hpaste is quite exciting
23:57:38 <dons> how about wiki editing ?
23:57:43 <dons> and markup support
23:57:50 <dons> also, you should be able to vote on pages
23:57:55 <glguy> I know *I* am thrilled, I'm just waiting to be banned for asking for so many opinions
23:57:55 <dons> vote pastes up or down
23:58:05 <dons> and comment on pastes too, on a talk page
23:58:08 <glguy> and articles
23:58:12 <glguy> you could submit those
23:58:14 <dons> yeah, articles are good
23:58:16 <dons> and tshirts
23:58:19 <int-e> glguy: you can always move to #haskell-overflow :)
23:58:26 <dons> 'hpaste took my code and all i got was a lousy tshirt'
23:58:27 <glguy> and live there instead ?
23:58:34 <int-e> glguy: yeah
23:58:44 <hpaste> more code plzkthnxby
23:58:55 <Korollary> Can hpaste do ajax?
23:59:05 <sjanssen> I want to receive emails that say: "Hi, we've noticed that you like pastes about monads!  Here are what other pasters like you are viewing."
23:59:06 <int-e> hpaste: what do you mean?
23:59:10 <dons> you mean, can ajax do hpaste?
23:59:33 <hpaste> int-e: --syntax error--
23:59:40 <glguy> yes
23:59:44 <glguy> you can paste ajax code
23:59:59 <glguy> and hpaste will highlight it as haskell code
