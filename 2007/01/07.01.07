00:00:02 * sorear loves >60 line error messages ... so easy to read ... must - remember - I'm - lucky
00:00:19 <dons> its good for you :)
00:01:26 <sorear> ./Setup.lhs build 2>&1 | less
00:02:09 <bd_> sorear: You think that's bad, take a look at the errors you get from boost-serialization in C++ :)
00:02:24 <glguy> I was wondering why my remote machine was taken down today, and it was because 300gigs of diskspace were added
00:02:27 <glguy> woot
00:02:53 * metaperl wants 300 gigs of remote space
00:03:09 <metaperl> actually that's not enough
00:03:14 <metaperl> 1 terabyte will do
00:03:16 <sorear> I've got 80 gigs and only know what to do with 20 of them
00:03:22 <metaperl> not me
00:03:39 <glguy> That pushes it up to 700gigs
00:03:56 <sorear> and if it weren't for several copies of the logs that I see no reason to delete, I'd only need ~8
00:04:21 <sorear> but, they just don't make 10GB drives anymore :(
00:05:28 <Saizan> sorear: your pc lacks media content :D
00:05:40 <bd_> give it a few years, that corner of the market will be covered by flash memory :)
00:05:47 <seancorfield> hah! i have defeated the hmake install and actually have hi working with ghc!
00:05:56 <sorear> yah!
00:06:05 <sorear> Saizan: what's that? :)
00:06:17 <seancorfield> thanx folks - it took me a few goes to get a clean install with no package lang dependency...
00:06:29 <seancorfield> now i can go to bed and play with haskell some more tomorrow
00:06:37 <Saizan> sorear: you know, songs, movies, pics!
00:08:03 <Mynstral> i.e. porn
00:08:24 <sorear> I actually haven't discovered any of those yet ...
00:08:26 <dons> sorear: you can have a peek at the test suite in scripts/tests now
00:08:42 <dons> sorear: i'll start adding tests for everything..
00:08:47 <sorear> my idea of working music is a 3600 rpm CPU fan
00:12:05 <Saizan> now i see how you can avoid X
00:25:04 <xpika> @paste
00:25:05 <lambdabot> http://paste.lisp.org/new/haskell
00:30:00 <dons> thanks for that patch, sorear
00:30:07 <dons> sorear++ super bot hacker
00:31:02 * sorear feels ... something
00:31:41 <dons> hehe. funny: writing unit tests I'm starting to understand some of this bot's behaviour :)
00:32:37 <sorear> do I need anything special to run them?
00:33:06 <dons> the m4 preprocessor
00:33:13 <dons> (you might have to manually set the logpp path to m4)
00:33:20 <dons> I think that's all
00:33:41 <dons> just type 'make' in the scripts/tests dir
00:33:52 <dons> and if that manages to build, ./run-utests
00:33:58 <dons> assumess a working lambdabot in lambdabot home
00:34:24 <sorear> now it just needs to be hooked up to cabal/darcs :)
00:34:28 <dons> hehe, intergrate QuickCheck with HUnit, and test the @id plugin:
00:34:29 <dons>  test2 = forM_ [1..10] $ const $ do
00:34:29 <dons>             s <- io80 random
00:34:30 <dons>             lb (" " ++ s) ("id " ++ s)
00:34:44 <glguy> ?type replicateM
00:34:46 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
00:34:53 <dons> checks that "id <foo>" returns " <foo>"
00:34:58 <bd_> hmm
00:35:11 <bd_> what's the point of replicateM? Why not just use return $ replicate?
00:35:26 <glguy> you mean (sequence . ) . replicate ?
00:35:30 <dons> ?src replicateM
00:35:31 <lambdabot> replicateM n x = sequence (replicate n x)
00:35:36 <glguy> test2 = replicateM 10 $ do
00:35:44 <sorear> it's a shortcut
00:35:45 <glguy> _ even
00:35:45 <bd_> glguy: oh
00:35:49 <dons> yeah replicateM_
00:36:03 <glguy> ?type replicateM_ -- exists, right?
00:36:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
00:36:06 <bd_> okay, I'm a bit tired apparently, missing the m a there >.>
00:36:17 <sorear> > transpose $ replicateM 4 [' ','#']
00:36:19 <lambdabot>  ["        ########","    ####    ####","  ##  ##  ##  ##"," # # # # # # # #"]
00:36:33 <Cale> cute
00:36:34 <sorear> some blogger spent far longer writing that function
00:36:53 <dons> hehe
00:37:22 <glguy> the built-in M functions + List Monad = wild results
00:37:56 <dons> top 10 signs you're having fun with Haskell:
00:37:57 <dons> [3 of 4] Compiling Tests            ( Tests.hs, Tests.o )
00:37:57 <dons> Loading package base ... linking ... done.
00:37:57 <dons> Loading package template-haskell ... linking ... done.
00:37:57 <dons> Loading package HUnit-1.1 ... linking ... done.
00:38:00 <dons> Loading package QuickCheck-1.0 ... linking ... done.
00:38:14 <ClaudiusMaximus> @hoogle (Storable a) => Ptr a -> Int -> [a]
00:38:15 <lambdabot> No matches, try a more general search
00:38:19 <glguy> looks like the 3rd of 4 signs...
00:38:24 <ClaudiusMaximus> @hoogle (Storable a) => Ptr a -> Int -> IO [a]
00:38:25 <lambdabot> Foreign.Marshal.Array.peekArray :: Storable a => Int -> Ptr a -> IO [a]
00:38:35 <Cale> > runListT (ListT [1])
00:38:37 <lambdabot>   add an instance declaration for (Num [a])
00:38:37 <lambdabot>     In the list element: 1
00:38:49 <Cale> okay, better :)
00:39:03 <glguy> ?type ListT
00:39:05 <lambdabot> forall a (m :: * -> *). m [a] -> ListT m a
00:39:11 <dons> > runListT (ListT [[1]])
00:39:12 <lambdabot>  [[1]]
00:39:23 <Cale> okay, so you added ListT
00:39:29 <Cale> > fhduia
00:39:31 <lambdabot>   Not in scope: `fhduia'
00:39:39 <dons> it was clashing with the type of the same name in TH
00:39:45 <Cale> ah!
00:41:39 <bd_> > replicateM 4 [' ','#']
00:41:40 <lambdabot>  ["    ","   #","  # ","  ##"," #  "," # #"," ## "," ###","#   ","#  #","# # ...
00:41:41 <bd_> cute :)
00:42:45 <sorear> > unwords $ replicateM 4 "01"
00:42:47 <lambdabot>  "0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 ...
00:43:17 <sorear> > map read $ replicateM 2 ['0'..'9']
00:43:19 <lambdabot>  Add a type signature
00:43:24 <sorear> > map read $ replicateM 2 ['0'..'9'] :: Int
00:43:25 <lambdabot>  Couldn't match `Int' against `[a]'
00:43:29 <sorear> > (map read $ replicateM 2 ['0'..'9']) :: Int
00:43:30 <lambdabot>  Couldn't match `Int' against `[a]'
00:43:35 <sorear> > (map read $ replicateM 2 ['0'..'9']) :: [Int]
00:43:37 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:44:12 <bd_> > (map (read.("0x"++)) $ replicateM 2 (['0'..'9']++['a','f'])) :: [Int]
00:44:14 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,15,16,17,18,19,20,21,22,23,24,25,26,31,32,33,34,35,3...
00:44:27 <bd_> hmm
00:44:49 <bd_> > (map (read.("0x"++)) $ replicateM 2 (['0'..'9']++['a'..'f'])) :: [Int]
00:44:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:44:53 <bd_> there we go
00:45:31 <lisppaste2> metaperl pasted "HXT - tree pruning help needed" at http://paste.lisp.org/display/34401
00:46:02 <Saizan> someone used HAppS.DBMS here?
00:46:19 <dons> maybe check on #happs ?
00:46:27 <dons> (yes!)
00:46:45 <Saizan> is there #happs ? :O
00:47:06 <sorear> @topic-tell #happs
00:47:06 <lambdabot> Do not know that channel
00:47:13 <sorear> @seen #happs
00:47:13 <lambdabot> In #happs I can see nobody.
00:47:17 <sorear> @users #happs
00:47:18 <lambdabot> Maximum users seen in #happs: 9, currently: 0 (0.0%), active: 0 (NaN%)
00:47:24 <vegai> because she's not there
00:47:42 <sorear> shapr + Saizan are
00:47:54 * sorear supposes Saizan just joined
00:48:12 <Saizan> yeah
00:50:33 <quazimodo> hi kids
00:51:22 <sorear> hi quazimodo
00:51:30 <quazimodo> hurro
00:51:34 <quazimodo> guys something terrible happened
00:51:47 <sorear> aw
00:52:14 <quazimodo> i hurt my wrist: D:
00:52:24 * sorear imagined something like SPJ/bus interaction
00:53:44 <quazimodo> nah
00:53:54 <quazimodo> i hurt it tearing phone books
00:54:26 <TSC> There must be an easier way to impress people (:
00:54:49 <quazimodo> its not for impresing people
00:55:07 <quazimodo> i do strongman and powerlifting work, phonebooks are just excellent forearm exercises
00:55:14 <quazimodo> as are bending nails and levering sledge hammers
00:56:57 <quazimodo> i dont see how educated men dont train their body, it basically removes all chances of osteoperosis, among other things
00:57:46 <Cale> quazimodo: Isn't it kind of a waste of phone books though?
00:57:51 <Lemmih> Maybe we try not to hurt our wrists (:
00:58:52 <Cale> I wonder what your telephone company thinks about your regular requests for a new phone book :)
01:02:04 <bakert> Is there any kind of introspection in haskell that lets you get a function's name?  Or is that not possible?
01:03:05 <Lemmih> Not possible.
01:03:33 <bakert> Shame.
01:04:27 <bakert> I'm just trying to avoid creating a test, then creating an entry in a list for running the test, then creating a string describing the test when all that info is in the name of the function (that it is a test, and what it's name is, I mean).
01:05:37 <Saizan> i miss that too, we should branch a scripting languange from haskell :D
01:05:38 <sorear> haskell just isn't that dynamic :(
01:05:52 * sorear will Someday write a RTS API
01:05:54 <quazimodo> Cale, i have about 100 books
01:06:04 <quazimodo> i saw the guys in the van driving round near my workshop so i yelled at them to stop
01:06:04 <Saizan> RTS?
01:06:21 <quazimodo> they asked me why i want them, and i told them to tear, and they gave me 5 stacks of 10 packs, ie 100 books
01:06:30 <Lemmih> http://www.mail-archive.com/haskell@haskell.org/msg19499.html
01:06:31 <lambdabot> Title: [Haskell] Announcement: cabal-test
01:07:01 <sorear> Run time system
01:07:07 <quazimodo> plus, weightlifting is fun as hell (provided you dont go into a healthclub style gym and pump out boring curls all day :/)
01:07:23 <sorear> the 5MB of code ghc links into every program
01:08:30 <Lemmih> sorear: But it already has an API.
01:08:49 <sorear> oh good
01:09:02 <Lemmih> (plus, the wanted information most likely isn't available at runtime)
01:12:09 <sorear> must sleep
01:18:09 <zeeeeeee> how do we update the haskell.org wiki? (i'm trying to add FG to the list of GUIs)
01:23:01 <zeeeeeee> sorry, never mind - i thought i didn't have permission to edit the page
01:41:20 <dons> bakert: your test/entry for test/name for test sounds like a job for Template Haskell
01:41:25 <dons> I do the same thing in the lambdabot testuiste
01:41:36 <dons> e.g
01:41:37 <dons> $(tests "dummy" [d|
01:41:38 <dons>  testDummy = lb "dummy" "dummy"
01:41:41 <dons>  |])
01:41:51 <dons> creates a test, a name for the test, and an entry in the test list
01:41:56 <dons> (at compile time)
01:44:26 <bakert> dons, that's exactly what i'm looking for.  Is Template Haskell some kind of extension or is it just the name for a coding style?
01:45:30 <Cale> @where th
01:45:44 <Cale> http://www.haskell.org/th/
01:45:46 <lambdabot> Title: Template Haskell
01:45:53 <Cale> It's an extension
01:45:56 <integral> $() and [| |] are not normal parts of haskell syntax
01:46:03 <dons> bakert: its an extension. you can get it with -fth
01:46:40 <dons> there's an example of how I use it for a testsuite here: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/tests/Tests.hs
01:46:42 <lambdabot> http://tinyurl.com/sndos
01:47:02 <dons> where the TH function, tests, is defined http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/tests/TestFramework.hs
01:47:04 <lambdabot> http://tinyurl.com/tjjkt
01:47:49 <dons> its quite an extension too, so be prepared to learn a thing or two if you want to use it
01:47:58 <lisppaste2> metaperl annotated #34401 with "type error" at http://paste.lisp.org/display/34401#1
01:48:04 <dons> (i.e. it gives you quote and eval (lisp style) at compile time)
01:51:26 <Heffalump> morning
01:52:36 <dons> hey Heffalump
01:52:43 <Heffalump> is the splice syntax $(...) or $... where you'd normally put a bracketed expression for the ...?
01:52:56 <dons> $id or $(expr goes here) -- iirc
01:52:59 <integral> yes, the latter
01:53:22 <Heffalump> I remember that it's a good idea to not write $foo instead of $ foo incase you want -fth later.
01:53:47 <dons> Heffalump: I'm adding a unit testsuite to lambdabot. 5 years later :)
01:53:54 <Heffalump> :-)
01:54:08 <Heffalump> where do you get the time to sleep?
01:54:26 <metaperl> is there a way to dump all the types that ghc calculated during compilation before it failed?
01:54:33 <dons> I find that I can alternate between left and right hemispheres between 2am and 6am
01:54:39 <Heffalump> cunning
01:54:56 <dons> metaperl: -ddump-types ? (or something similarly named)
01:55:11 <dons> check the debugging options in the ghc user's guide
01:57:59 <ClaudiusMaximus> say i have an app written in C, which calls Haskell through FFI.   is it possible to maintain a state (eg, an IORef (Data.Map CInt SomeType) ) in the Haskell part between calls from C?
01:58:51 <Heffalump> so the C part isn't aware of the state being kept?
01:59:18 <ClaudiusMaximus> Heffalump: would be nice, but not necessary
01:59:35 <Heffalump> (I've never done FFI this way round, so I haven't got much of a clue, but I'd have thought one obvious solution would be to pass some opaque handle back to C and get it to pass it in to the next call)
01:59:55 <dons> you could certainly do it. (hide it in a global IORef or monad on the Haskell side)
02:00:10 <Heffalump> dons: how do you make a global IORef without unsafePerformIO evilness?
02:00:23 <dons> its not that evil if you're just simulating a monad :)
02:00:34 <dons> as long as that's all you do, then its ok
02:00:36 <Heffalump> and I don't quite see how the monad would work, it'd affect the type of the Haskell function being called
02:00:41 <dons> it would
02:00:56 <dons> ah, C is in control?
02:01:02 <ClaudiusMaximus> dons: yes, C is the boss
02:01:10 <Heffalump> (boo hiss)
02:01:11 <metaperl> dons - yes - ddump-types - http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id3157654
02:01:14 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
02:01:16 <dons> then yeah, you'll either need to pass the state back and forward, or use an IORef on the Haskell side
02:01:48 <dons> to use a monad, the C caller would have to effectively runState (i.e. pass in the initial state, and keep track of it, I think)
02:02:00 * Heffalump thinks making the C interface aware of the state would be nicer stylistically, if possible
02:02:05 <dons> yeah.
02:02:21 <dons> it might involve too much overhead, conceivably (StablePtrs maybe ?)
02:02:36 <dons> anyway, an IORef is 3 lines and easy enough
02:03:02 <dons> i'd use an MVAr while I was there, just in case you ever used threads on the C side ;)
02:03:13 <ClaudiusMaximus> sure, it's no problem to pass in an extra pointer to my foreign exports, but i'm not sure how to create a global IORef
02:03:46 <dons> import System.IO.Unsafe
02:03:46 <dons> import Data.IORef
02:03:46 <dons> st :: IORef String
02:03:46 <dons> st = unsafePerformIO newEmptyMVar
02:03:47 <dons> {-# NOINLINE st #-}
02:04:06 <dons> which you can then access as a normal IORef with global scope (i.e. in the IO monad).
02:04:15 <dons> it simulates passing the IORef around in a StateT
02:05:38 <ClaudiusMaximus> thanks, i'll see if i can figure out something using that...
02:10:48 <Heffalump> ClaudiusMaximus: you don't need both the global IORef and the extra pointer
02:11:14 <ClaudiusMaximus> Heffalump: :)
02:29:36 <rindolf> Hi all.
02:35:30 <dons> ok, I need to keep some sleep ;) http://programming.reddit.com/info/xc8u/comments/cxcgp
02:35:32 <lambdabot> Title: If Marriage Was Strongly Typed (reddit.com)
02:36:33 <dons> ?version
02:36:34 <bdash> dons: surely you want to know if they'll be back before dinner, not only exactly at dinner time?
02:36:34 <lambdabot> lambdabot 4p428, GHC 6.5 (OpenBSD i386)
02:36:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:36:44 <dons> bdash: yeah, spotted that. fixed now
02:37:10 <dons> (there's a nice example of a bug not catchable by the type system, unless you add a bit more structure)
02:37:12 <bdash> dons: rather amusing take on that blog post :)
02:37:17 <dons> :}
02:53:21 <ClaudiusMaximus> @hoogle CInt -> Int
03:01:48 <Lemmih> ?type (fromIntegral :: Foreign.C.CInt -> Int)
03:01:49 <lambdabot> Foreign.C.Types.CInt -> Int
03:06:04 <dons> @hoogle are you there?
03:06:05 <lambdabot> Prelude.undefined :: a
03:06:05 <lambdabot> Test.QuickCheck.Batch.bottom :: a
03:16:17 <delamon> is it possible to display types of subexpressions in emacs haskell-mode like ocaml-mode does?
03:16:50 <delamon> i mean C-c C-t binding.
03:49:47 <dons> ?yow
03:49:48 <lambdabot> CHOP!!
03:49:54 <dons> ?uptime
03:49:55 <lambdabot> uptime: 1h 15m 55s, longest uptime: 1d 21h 16m 2s
03:50:00 <dons> ?version
03:50:00 <lambdabot> lambdabot 4p428, GHC 6.5 (OpenBSD i386)
03:50:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:50:07 <dons> ooh, patch-a-riffic!
03:50:12 <nornagon> wow, uptime sux
03:50:23 <dons> yeah, we've been hacking like mad of late
03:50:27 <nornagon> ?yow
03:50:27 <lambdabot> FUN is never having to say you're SUSHI!!
03:50:48 <dons> max uptime is actually,
03:50:50 <dons> 22:44  dons> ?uptime
03:50:52 <dons> 22:44  lambdabot> uptime: 2m 9d 10h 15m 1s
03:51:03 <nornagon> i see
03:51:10 <nornagon> longest uptime: 1d 21h 16m 2s
03:51:14 <nornagon> ?help yow
03:51:14 <lambdabot> yow. The zippy man.
03:51:24 <dons> yeah, here, we zapped the @uptime state by accident yesterday :}
03:51:31 <dons> same with @users
03:51:32 <dons> ?users
03:51:32 <lambdabot> Maximum users seen in #haskell: 296, currently: 262 (88.5%), active: 6 (2.3%)
03:51:35 <ClaudiusMaximus> ?. help yow
03:51:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:51:41 <dons> its really a 309 max
03:53:03 <ClaudiusMaximus> what kind of Bad Things are likely to happen if one doesn't hs_exit() before exit()?
03:53:14 <dons> nothing?
03:53:37 <dons> (since you can also call exit() from haskell without harm)
03:53:57 <mahogny> maybe hs_exit is then hooked into atexit(). dunno
03:54:21 <araujo> morning
03:54:29 <nornagon> mahogny: init snaffles up any previously used memory after exit()
03:54:37 <mahogny> ah
03:54:49 <nornagon> you never get "unused" memory, really
04:05:52 <Hunter> any idea how to rotate a list (and print them out) untill I have move throw it ( ex. [1,2,3],[2,3,1],[3,1,2] )
04:06:52 <goltrpoat> evening.
04:09:08 <kzm_> > let rot xs = take (length xs) $ map (take (length xs)) $ inits (xs++xs) in rot [1,2,3]
04:09:10 <lambdabot>  [[],[1],[1,2]]
04:09:17 <kzm_> Hmm.. not quite.
04:09:25 <kzm_> > let rot xs = take (length xs) $ map (take (length xs)) $ tails (xs++xs) in rot [1,2,3]
04:09:26 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
04:09:36 <kzm_> Hunter?
04:10:11 <kzm_> You can probably rewrite it to be more efficient.
04:12:02 <Botje> > let rot xs = zipWith (++) (tails xs) (inits xs) in rot [1,2,3]
04:12:03 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
04:13:57 <astrolabe> > let{rot (a:as) = as ++ [a]; rots l = take (length l) (iterate rot l)} in rots "hello"
04:13:59 <lambdabot>  ["hello","elloh","llohe","lohel","ohell"]
04:14:14 <astrolabe> just to join the club :)
04:17:48 <Botje> I discovered a great use of unfoldr yesterday:
04:17:52 <Hunter> kzm aha, thanks a lot =)
04:18:02 <Botje> > take 5 $ unfoldr (Just . splitAt 4) [1..]
04:18:03 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
04:21:18 <johann23> Halo! Is there web based haskell compiler ?
04:25:20 <nornagon> ... what?
04:25:42 * psykotic wants a gopher-based haskell compiler.
04:26:03 <Heffalump> johann23: are web based compilers common for other languages?
04:26:40 <nilsi> are you talking about an online interpreter perhaps?
04:26:47 <johann23> jea
04:27:04 <nilsi> i know none
04:27:37 <johann23> :(
04:27:53 <nilsi> aehmm  lambdabot?
04:28:01 <nilsi> > 15 + 25
04:28:03 <lambdabot>  40
04:28:40 <goltrpoat> there's a telnet version of allegro :)
04:28:47 <johann23> but lamdabot haven't web input ?
04:28:50 <goltrpoat> actually.. there's a javascript version too, come to think of it
04:29:17 <goltrpoat> er.. sorry, that was in response to Heffalump, not to johann
04:29:30 <johann23> (((+4).) . (.(*3))) (+2) 1
04:29:41 <goltrpoat> > (((+4).) . (.(*3))) (+2) 1
04:29:42 <lambdabot>  9
04:29:47 <johann23> Why doesn't lambda working for me ?
04:30:23 <goltrpoat> johann:  prefix expressions with > to evaluate them
04:30:36 <johann23> > (((+4).) . (.(*3))) (+2) 1
04:30:37 <lambdabot>  9
04:30:41 <johann23> Nice :P
04:31:57 <Heffalump> and it takes msgs :-)
04:32:19 <goltrpoat> and bribes.
04:33:16 <johann23> But i still need web interpreter
04:33:46 <Botje> johann23: why not install a haskell compiler locally?
04:33:56 <johann23> i already have one
04:33:57 <Botje> (or interpreter)
04:34:16 <Botje> so why do you need a web interpreter?
04:34:18 <Heffalump> @botsnack
04:34:18 <lambdabot> :)
04:34:41 <johann23> To interpret when i'm not using my comp
04:35:15 <johann23> Sometimes i can't use local interpreter
04:35:19 <scriptdevil> how do i print a list?
04:35:41 <scriptdevil> filter putStrLn [1,2,3,45] aint working
04:35:56 <Botje> scriptdevil: print [1,2,3,45]
04:36:12 <johann23> Can i first define functions for lambdabot ?
04:36:12 <johann23> s f g x = f x (g x)
04:36:12 <johann23> k x y = x
04:36:16 <Botje> scriptdevil: or mapM_ putStrLn [1,2,3,45] (i think)
04:36:32 <mauke> ITYM print
04:36:35 <scriptdevil> oh.. why do these simple thigs like print stay outta sight:D
04:36:44 <scriptdevil> mapM_?
04:36:46 <scriptdevil> whats that
04:36:52 <scriptdevil> !mapM_
04:36:57 <Heffalump> > let { s f g x = f x (g x) ; k x y = x }
04:36:57 <lambdabot>  Parse error
04:37:03 <Heffalump> hmph
04:37:11 <mauke> @index mapM_
04:37:11 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:37:17 <mauke> @docs Control.Monad
04:37:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
04:38:02 <scriptdevil> one sec... is there an analog to join in haskell..
04:38:10 <scriptdevil> i mean for separating the list up
04:38:16 <scriptdevil> not print with braces
04:38:22 <johann23> > let { s f g x = f x (g x) ; k x y = x; s (k (+1)) (k 2) 4}
04:38:22 <lambdabot>  Parse error
04:38:27 <johann23> :(
04:38:33 <Botje> scriptdevil: intersperse
04:38:51 <mauke> intersperse, then concat
04:38:58 <Botje> > let s = [1,2,3,4] in concat $ intersperse "," (map show s)
04:39:00 <lambdabot>  "1,2,3,4"
04:39:06 <tphyahoo> ?src intersperse
04:39:06 <lambdabot> intersperse _   []     = []
04:39:07 <lambdabot> intersperse _   [x]    = [x]
04:39:07 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
04:39:17 <Heffalump> > let { s f g x = f x (g x) ; k x y = x } in s (k (+1)) (k 2) 4
04:39:19 <lambdabot>  3
04:39:36 <mauke> @pl s f g x = f x (g x)
04:39:37 <lambdabot> s = ap
04:39:41 <scriptdevil> thanks
04:40:10 <mauke> > ap (const (+1)) (const 2) 4
04:40:11 <lambdabot>  3
04:40:38 <Botje> bah
04:40:46 <nornagon> :t ap
04:40:47 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
04:40:48 <Botje> I need to learn SKI-calculus sometime.
04:40:54 <nornagon> what a scary type
04:41:04 <mauke> can anyone explain the semantics of Control.Concurrent.Chan to me?
04:41:06 <nornagon> :t liftM
04:41:07 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
04:41:11 <nornagon> hmm... :)
04:41:19 <mauke> the docs don't really say what it does
04:41:36 <nornagon> ?src liftM
04:41:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:41:38 <nornagon> ?src ap
04:41:38 <lambdabot> ap = liftM2 id
04:41:42 <nornagon> cute
04:41:47 <nornagon> ?src liftM2
04:41:47 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:41:55 <nornagon> :t liftM2
04:41:56 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:42:23 <tphyahoo> :info ap
04:42:35 <tphyahoo> ?info ap
04:42:35 <lambdabot> ap
04:42:49 <tphyahoo> ?fptools ap
04:42:50 <lambdabot> ap not available
04:42:52 <ndm> Heffalump: new job?
04:43:02 <tphyahoo> ok I give up. Where does ap come from?
04:43:12 <mauke> @index ap
04:43:12 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
04:43:12 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
04:43:13 <Heffalump> ndm: yes, Credit Suisse
04:43:15 <ndm> @hoogle ap
04:43:15 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
04:43:15 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
04:43:15 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
04:43:32 <ndm> Heffalump: cool :) - that in OCaml or Haskell (or neither)
04:43:39 <Heffalump> Haskell
04:43:50 <ndm> well done :)
04:44:06 <tphyahoo> if I dare ask, did the job advert mention haskell?
04:44:10 <Heffalump> yes
04:44:19 <tphyahoo> hm, reason to hope :)
04:44:20 <psnl> Heffalump: well done
04:44:29 <ndm> tphyahoo: if you read the Haskell mailing list with gmail you get plenty of job adverts :)
04:44:37 <psnl> Heffalump: couldn't stick the low-level stuff?
04:44:49 <tphyahoo> I see jane's street over and over, but haven't noticed any others.
04:44:51 <Heffalump> psnl: no, I really regretted leaving ARM
04:45:17 <tphyahoo> ?info ap
04:45:17 <lambdabot> ap
04:45:23 <psnl> why?
04:45:56 <ndm> tphyahoo: have you read the CUFP stuff, Commerical Users of Functional Programming - Credit Suisess were in there
04:46:00 <Heffalump> well, I liked what I was doing, and I'd invested a lot of mental energy into my work on the compiler
04:46:13 <astrolabe> hehe  'lambdabot spoke a total of 24868 words!
04:46:13 <astrolabe> lambdabot's faithful follower, dons, didn't speak so much: 17977 words.'
04:46:25 <psnl> Heffalump: armcc was very good
04:46:29 <tphyahoo> yes, but I didn't remember that. I'm sure there will be more and more.
04:46:43 * psnl might go back to arm
04:47:01 <Heffalump> full-time?
04:49:29 <psnl> yeah
04:49:38 <psnl> graduate job
04:49:55 <bringert> johann23: did you see this http://lambdabot.codersbase.com/
04:49:56 <lambdabot> Title: Lambdabot Web Interface
04:51:12 <johann23> Nice
04:53:03 <tphyahoo> @source ap
04:53:04 <lambdabot> ap not available
04:53:14 <nornagon> ?src ap
04:53:14 <lambdabot> ap = liftM2 id
04:54:10 <Botje> "Hang on to lambdabot's handles"
04:54:15 <Botje> that's just perverted :P
04:54:45 <Paukka37> > (((+4).) . (.(*3))) (+2) 1
04:54:47 <lambdabot>  9
04:56:21 <johann23> hm
04:57:33 <goltrpoat> > ((+4) <<< (+2) <<< (*3)) 1
04:57:35 <lambdabot>  9
04:57:42 <goltrpoat> whee.
04:58:08 <tphyahoo> rol.Monad.ap (const (+1)) (const 2) 4
04:58:19 <tphyahoo> Control.Monad.ap (const (+1)) (const 2) 4
04:58:21 <Botje> *sigh*
04:58:33 <tphyahoo> Monad.ap (const (+1)) (const 2) 4
04:58:40 <Botje> rereading the paper on arrows is planned for next week, i guess
04:58:45 <tphyahoo> ap (const (+1)) (const 2) 4
04:58:55 <goltrpoat> > ap (const (+1)) (const 2) 4
04:58:57 <lambdabot>  3
04:59:09 <tphyahoo> > ap (const (+1)) (const 2) 4
04:59:10 <lambdabot>  3
04:59:27 <tphyahoo> > Monad.ap (const (+1)) (const 2) 4
04:59:28 <lambdabot>   Not in scope: `Monad.ap'
04:59:36 <tphyahoo> > Control.Monad.ap (const (+1)) (const 2) 4
04:59:37 <lambdabot>  3
05:00:18 <tphyahoo> 1 + 1
05:00:23 <tphyahoo> > 1 + 1
05:00:24 <lambdabot>  2
05:01:22 <tphyahoo> Prelude> Control.Monad.ap (const (+1)) (const 2) 4
05:01:22 <tphyahoo> <interactive>:1:0:
05:01:35 <tphyahoo> doesn't work from ghci.... works from lambdabot... ?
05:01:46 <mauke> tphyahoo: :m +Control.Monad.Reader
05:02:18 <tphyahoo> can't you just call it qualifiedly, and avoid loading the module?
05:02:28 <mauke> no
05:02:36 <mauke> also, what do you mean by "it"?
05:02:57 <mauke> we're loading an instance here
05:03:24 <Jaak> @src inits
05:03:25 <lambdabot> inits []     =  [[]]
05:03:25 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
05:03:27 <tphyahoo> "it" = ap. but maybe still too far over my heaad.
05:03:53 <goltrpoat> tph:  the module name doesn't necessarily correspond to the filename
05:05:05 <tphyahoo> ?src ap
05:05:06 <lambdabot> ap = liftM2 id
05:05:12 <goltrpoat> besides, there are several modules exporting 'ap'
05:05:29 <tphyahoo> how does lambdabot know which one to use?
05:05:45 <goltrpoat> it loads Control.Monad and friends unqualified
05:05:59 <goltrpoat> as a convenience type deal.
05:06:56 <tphyahoo> in this case, ap was coming from Control.Monad.Reader, and not Control.Monad ... ?
05:07:30 <mauke> doesn't matter; it's the same ap
05:08:11 <tphyahoo> yes. I must have typed something into ghci incorrectly.
05:08:23 <mauke> why?
05:08:34 <nornagon> > inits [[1,2,3],[4,5,6]]
05:08:38 <tphyahoo> What I meant by "calling qualifiedly" was ...
05:08:41 <tphyahoo> Control.Monad.ap (const ((+ 1))) (const 2) 4
05:08:50 * nornagon prods lambdabot 
05:09:04 <mauke> yes. what's the error?
05:09:16 <tphyahoo> from ghci. basically, when I see something on #haskell, I'd just like to be able to reproduce it in ghci.
05:09:30 <nornagon> @bs
05:09:31 <lambdabot> Done.
05:09:47 <nornagon> \> inits [[1,2,3],[4,5,6]]
05:09:51 <nornagon> > inits [[1,2,3],[4,5,6]]
05:09:52 <lambdabot>  [[],[[1,2,3]],[[1,2,3],[4,5,6]]]
05:10:28 <nornagon> > inits "hello"
05:10:29 <lambdabot>  ["","h","he","hel","hell","hello"]
05:10:34 <nornagon> ahh.
05:11:08 <nornagon> > inits $ "lol" ++ cycle "ol"
05:11:10 <lambdabot>  ["","l","lo","lol","lolo","lolol","lololo","lololol","lolololo","lolololol",...
05:11:16 <goltrpoat> tphyahoo:  and you can, you just need to import the appropriate modules.  lambdabot already imports a large number of modules that are commonly used.
05:11:22 <nornagon> > inits $ cycle "lo"
05:11:23 <lambdabot>  ["","l","lo","lol","lolo","lolol","lololo","lololol","lolololo","lolololol",...
05:11:31 <tphyahoo> yes, it's working for me now. thanks goltrpoat.
05:11:52 <nornagon> > putStrLn "foo"
05:11:53 <lambdabot>  <IO ()>
05:12:03 <nornagon> quite.
05:14:24 <tphyahoo> what just happened, nornagon?
05:15:31 <tphyahoo> I guess... a monad of type    IO ()      was returned.
05:15:55 <tphyahoo> lambdabot doesn't do side effects. (unlike ghci)
05:16:05 <nornagon> i guess so
05:16:18 <nornagon> IO is the monad
05:16:30 <ndm> tphyahoo: dons doesn't want people deleting all his files, so restricts out IO actions
05:16:33 <nornagon> I don't think a foo of type IO () is considered a monad
05:16:51 <ndm> no, anything Monad m => m a is a monad
05:16:55 <ndm> IO just happens to be a monad
05:16:59 <ndm> and () is a value
05:17:00 <nornagon> ah, okay
05:17:06 <nornagon> i am a newbie :)
05:17:10 <ndm> you can get monadic values like IO String (readFile say)
05:17:15 <Paukka37> > let {s f g x = f x (g x);k x y = x} in s (k (+1)) (k 2) 4
05:17:16 <lambdabot>  3
05:17:19 <ndm> we all were once ;)
05:17:40 <ndm> there are also other monads than IO, but you can ignore that for a while if you're still learning ;)
05:17:54 <nornagon> yeah, i know
05:17:58 <mauke> @hoogle [a] -> [a]
05:17:59 <lambdabot> Prelude.cycle :: [a] -> [a]
05:17:59 <lambdabot> Prelude.init :: [a] -> [a]
05:17:59 <lambdabot> Prelude.reverse :: [a] -> [a]
05:18:10 <nornagon> StateT and List and Maybe and and and...
05:18:19 <goltrpoat> (technically, () is a type there, unless we suddenly acquired dependent types while i wasn't looking)
05:18:19 <Lemmih> ndm: Are you saying 'IO ()' is a monad?
05:18:21 <johann23> > a
05:18:22 <lambdabot>   Not in scope: `a'
05:18:26 <johann23> >
05:18:32 <johann23> > uptime
05:18:32 <lambdabot>   Not in scope: `uptime'
05:18:35 <johann23> lala
05:18:37 <ndm> Lemmih: no, i was saying its not - or rather saying the IO bit was the monad
05:18:39 <nornagon> @uptime
05:18:39 <lambdabot> uptime: 2h 44m 42s, longest uptime: 1d 21h 16m 2s
05:18:51 <johann23> longest so small ? :o
05:18:55 <tphyahoo> IO is the monad, () is the value right?
05:19:05 <nornagon> johann23: recently reset accidentally
05:19:12 <Lemmih> ndm: Right, so you were agreeing with nornagon.
05:19:15 <tphyahoo> () is also known as "void", or "nothing" or... whatsit called?
05:19:18 <nornagon> tphyahoo: isn't () a type?
05:19:27 <nornagon> tphyahoo: i call it 'coin' :)
05:19:28 <Heffalump> it's both a type or a value
05:19:29 <johann23> what is the real longest uptime ?
05:19:31 <tphyahoo> i think not, but I'm also a newb.
05:19:33 <Heffalump> called "unit"
05:19:33 <johann23> week ?
05:19:38 <Heffalump> s/type or/type and/
05:19:40 <nornagon> johann23: a couple months
05:19:47 <johann23> Nice
05:19:50 <tphyahoo> :t ()
05:19:52 <lambdabot> ()
05:19:59 <tphyahoo> :t "foo"
05:20:00 <nornagon> zany
05:20:01 <lambdabot> [Char]
05:20:02 <nornagon> > ()
05:20:04 <lambdabot>  ()
05:20:20 <tphyahoo> I guess the value and the type are both called ()
05:20:51 <Paukka37> > a
05:20:52 <lambdabot>   Not in scope: `a'
05:21:08 <nornagon> ...
05:21:32 <Jaak> > [()..()]
05:21:34 <lambdabot>  [()]
05:21:44 <nornagon> > [()..]
05:21:45 <lambdabot>  [()]
05:21:52 <nornagon> @hoogle ()
05:21:53 <lambdabot> Did you mean: ()
05:21:53 <lambdabot> Prelude.undefined :: a
05:21:53 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
05:21:54 <tphyahoo> :t [()..()]
05:21:55 <ndm> @instances Bounded
05:21:56 <lambdabot> [()]
05:21:57 <lambdabot> (), (a, b), (a, b, c), Bool, Char, Int, Ordering
05:22:13 <ndm> nornagon: thats just hoogle going crazy...
05:22:19 <nornagon> heh
05:22:24 <nornagon> > cycle ()
05:22:25 <lambdabot>  Couldn't match `[a]' against `()'
05:22:33 <nornagon> > cycle [()]
05:22:33 <ndm> > repeat ()
05:22:33 <Jaak> > repeat ()
05:22:35 <tphyahoo> > cycle []
05:22:35 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:22:36 <lambdabot>  Add a type signature
05:22:36 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:22:36 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:22:44 <nornagon> heh
05:22:58 <nornagon> infinite nothings
05:23:08 <tphyahoo> infinite units
05:23:25 <nornagon> infinite coins
05:23:33 <Botje> we're RICH!
05:23:41 <nornagon> :D
05:23:55 <Syzygy-> > take 500 $ repeat ()
05:23:57 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:24:01 <doBind> hey! anyone know a less cumbersome way to create a CalendarTime? From knowing just year/month/day/hour/sec/timezone
05:24:16 <ndm> @hoogle a -> CalendarTime
05:24:17 <lambdabot> No matches, try a more general search
05:24:46 <nornagon> > let a $ b = a (repeat b) in take 500 $ ()
05:24:47 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:24:55 <tphyahoo> @index ap
05:24:56 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
05:24:56 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
05:24:56 <doBind> now I have to fill in day of year, picosec and other crazy stuff
05:25:21 <Jaak> > fix (():)
05:25:22 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
05:25:29 <nornagon> ?src fix
05:25:29 <lambdabot> fix f = let x = f x in x
05:25:36 <nornagon> i don't get it :(
05:26:02 <nornagon> seems like zany recursion
05:26:39 <Heffalump> ?src cycle
05:26:39 <lambdabot> cycle [] = undefined
05:26:39 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:26:50 <mauke> @type mfix
05:26:51 <nornagon> > cycle []
05:26:52 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
05:26:52 <lambdabot>  Add a type signature
05:27:02 <Jaak> > fix ((1:) . scanl (+) 1)
05:27:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
05:27:12 <ndm> hmm, cycle [] == _|_[pat], when I'm sure it should equal _|_[nt]
05:27:25 <ndm> logically, at least
05:27:35 <Heffalump> [nt] ?
05:27:39 <ndm> i realise haskell treats them as the same semantically
05:27:46 <ndm> pattern match vs non-termination
05:27:54 <Heffalump> you'd rather it infinite looped rather than complaining?
05:28:03 <tphyahoo> @hoogle fix
05:28:03 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
05:28:04 <lambdabot> Control.Monad.Fix :: module
05:28:04 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
05:28:10 <johann23> Jaak, sul username regatud ?
05:28:11 <ndm> no, i just feel that should be the behaviour, from a logical point of view
05:28:37 <Heffalump> I'd view that first clause as an extra added to make the user experience better
05:28:50 <ndm> yeah, but still, seems ugly in some way
05:28:59 <ndm> since the semantics is not hte obvious one
05:29:08 <ndm> although clearly does make for a better user experience
05:29:27 <Heffalump> seems harmless to me. Doesn't change the formal semantic position and does improve the user experience.
05:29:40 <ndm> yeah, more unexpected i guess
05:29:46 <Heffalump> >let x = x in x
05:29:57 <ndm> although error "cycle called with [], would never produce a result" would be better than undefined
05:30:04 <nornagon> :t fixM
05:30:05 <lambdabot> Not in scope: `fixM'
05:30:08 <ndm> @src head
05:30:08 <lambdabot> head (x:_) = x
05:30:08 <lambdabot> head []    = undefined
05:30:14 <nornagon> ?src fixIO
05:30:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:30:23 <nornagon> LIES
05:30:28 <ndm> i guess dons has replaced that error message then
05:30:51 <nornagon> ?src System.IO.fixIO
05:30:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:30:59 <nornagon> @botsnack
05:30:59 <lambdabot> :)
05:31:17 <Heffalump> module Main where
05:31:17 <Heffalump> main = print (let x = x in x :: Int)
05:31:24 <Heffalump> if you compile that with ghc, you get:
05:31:28 <Heffalump> loop: <<loop>>
05:31:34 <Heffalump> how would you view that, semantically?
05:31:44 <nornagon> _|_
05:31:45 <ndm> _|_ NT
05:32:01 <ndm> i guess it is the same thing
05:32:19 <Heffalump> I would say that ghc is transforming _|_ NT into _|_ ErrorMessage in some situations
05:32:21 <ndm> although i'm not sure about equational reasoning with the cycle example
05:32:36 <ndm> i wonder if you could corrupt the reasoning, in some way
05:32:47 <nornagon> ?src cycle
05:32:47 <lambdabot> cycle [] = undefined
05:32:47 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:32:50 <ndm> you definately could with a catch construct for pattern match errors
05:33:08 <Heffalump> but that could only work in IO
05:33:28 <ndm> oh yeah, i never use catch - i guess that fixes the reasoning back up
05:42:58 <tphyahoo> ?info scanl
05:42:58 <lambdabot> scanl
05:43:10 <tphyahoo> ?src scanl
05:43:11 <lambdabot> scanl f q ls = q : case ls of
05:43:11 <lambdabot>     []   -> []
05:43:11 <lambdabot>     x:xs -> scanl f (f q x) xs
05:44:09 <tphyahoo> @hoogle scanl
05:44:09 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:44:10 <lambdabot> Prelude.scanl1 :: (a -> a -> a) -> [a] -> [a]
05:44:31 <tphyahoo> @hoogle foldl
05:44:31 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
05:44:31 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
05:44:31 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
05:45:19 <tphyahoo> foldl (+) 0 [1,2,3]
05:45:24 <tphyahoo> > foldl (+) 0 [1,2,3]
05:45:26 <lambdabot>  6
05:45:36 <tphyahoo> > scanl (+) 0 [1,2,3]
05:45:37 <lambdabot>  [0,1,3,6]
05:46:02 <tphyahoo> @hoogle scanr
05:46:03 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:46:03 <lambdabot> Prelude.scanr1 :: (a -> a -> a) -> [a] -> [a]
05:46:09 <tphyahoo> @hoogle foldr
05:46:10 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
05:46:10 <lambdabot> Prelude.foldr1 :: (a -> a -> a) -> [a] -> a
05:46:10 <lambdabot> Data.PackedString.foldrPS :: (Char -> a -> a) -> a -> PackedString -> a
05:47:04 <Jaak> > map (foldl (+) 0) (tails [1,2,3])
05:47:06 <lambdabot>  [6,5,3,0]
05:47:45 <Jaak> > map (foldl (+) 0) (inits [1,2,3])
05:47:46 <lambdabot>  [0,1,3,6]
05:50:54 <astrolabe> > scanl (+) 0 [1,2,3]
05:50:56 <lambdabot>  [0,1,3,6]
05:52:28 <Jaak> > scanr (+) [1..3]
05:52:29 <lambdabot>   add an instance declaration for (Num [a])
05:52:34 <Jaak> > scanr (+) 0 [1..3]
05:52:35 <lambdabot>  [6,5,3,0]
05:53:00 <tphyahoo> I conclude that scanr is useful for debugging / understanding foldr.
05:53:35 <tphyahoo> *Main> scanr (-) 10 [1,2,3,4,5]
05:53:35 <tphyahoo> [-7,8,-6,9,-5,10]
05:53:35 <tphyahoo> *Main> scanr (-) 10 [1,2,3,4,5]
05:53:35 <tphyahoo> [-7,8,-6,9,-5,10]
05:53:35 <tphyahoo> *Main>
05:54:54 <tphyahoo> This was confusing me for a while. But if you read the scanr result backwards, it shows how the equivalent foldr got done.
05:55:08 <tphyahoo> *Main> foldr (-) 10 [1,2,3,4,5]
05:55:08 <tphyahoo> -7
05:58:16 <tphyahoo> ?src reverse
06:07:55 <tphyahoo> @hoogle reverse
06:07:56 <lambdabot> Data.PackedString.reversePS :: PackedString -> PackedString
06:09:01 <tphyahoo> hm, lambdabot missed Prelude.reverse .
06:09:11 <tphyahoo> http://haskell.org/hoogle/?q=reverse
06:09:13 <lambdabot> Title: reverse - Hoogle
06:10:35 <matthew-_> is there a monadic version of iterate?
06:10:52 <tphyahoo> anyone out there running haskell 6.6 on virtualized linux? (xen, user mode linux, or other flavors?)
06:11:01 <matthew-_> ?hoogle (a -> m a) -> a -> m [a]
06:11:02 <tphyahoo> i mean, ghc 6.6 ?
06:11:02 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:11:02 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:11:02 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
06:11:18 <matthew-_> tphyahoo: yes, linux-vserver
06:11:30 <tphyahoo> is vserver a flavor?
06:11:42 <matthew-_> well, it's a form of virtualisation, yes
06:11:59 <tphyahoo> local computer, or hosted somewheres? I'm hosted at linode.
06:12:04 <augustss> matthew-_: I don't think there's an iterateM
06:12:24 <augustss> @type sequence . iterate
06:12:25 <matthew-_> tphyahoo: on my own server, which is in RBII
06:12:25 <lambdabot>     Expecting a function type, but found `b'
06:12:25 <lambdabot>       Expected type: (a1 -> a1) -> [m a]
06:12:27 <tphyahoo> nice, because I can work from anywhere then. But I can't get ghc 6.6 to compile.
06:12:37 <tphyahoo> probably not haskell's fault.
06:12:46 <matthew-_> augustss: mmm
06:12:58 <augustss> @type \ f x -> sequence $ iterate f x
06:12:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m a) -> m a -> m [a]
06:13:07 <augustss> hmmm, no
06:13:29 <matthew-_> ?hoogle (a -> m a) -> a -> [m a]
06:13:30 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
06:13:30 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:13:30 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
06:13:48 <mauke> @pl iterateM f x = liftM (x :) (f x >>= iterateM f)
06:13:48 <lambdabot> iterateM = fix ((liftM2 fmap (:) .) . liftM2 flip ((>>=) .))
06:14:36 <matthew-_> ahh, ok, many thanks
06:15:21 <mauke> @pl k x = liftM (x :) (f x >>= k)
06:15:22 <lambdabot> k = fix (liftM2 fmap (:) . flip ((>>=) . f))
06:20:19 <augustss> @pl \ f x -> sequence $ iterate (>>= f) (return x)
06:20:20 <lambdabot> (sequence .) . (. return) . iterate . (=<<)
06:22:50 <augustss> tphyahoo: looks like Duncan knew about your problem :)
06:25:49 <matthew-_> let iterateM = (sequence .) . (. return) . iterate . (=<<) in head (iterateM (return) 1)
06:25:52 <matthew-_> > let iterateM = (sequence .) . (. return) . iterate . (=<<) in head (iterateM (return) 1)
06:25:54 <lambdabot>  Exception: stack overflow
06:27:21 <augustss> Since it iterates forever it's not that useful
06:27:31 <matthew-_> indeed
06:28:17 <matthew-_> presumeably I want (a -> m a) -> a -> [m a]
06:28:34 <augustss> I don't know what you want :)
06:28:42 <augustss> but drop the sequence if you do
06:28:59 * matthew-_ thinks about what he wants, what he really, really wants
06:29:10 <augustss> @type \ f x -> iterate (>>= f) (return x)
06:29:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m a) -> a -> [m a]
06:30:23 <augustss> @pl \ f x -> iterate (>>= f) (return x)
06:30:23 <lambdabot> (. return) . iterate . (=<<)
06:31:45 <Syzygy-> matthew-_: Isn't that just map?
06:31:54 <Syzygy-> ?hoogle a -> m a
06:31:55 <lambdabot> Prelude.id :: a -> a
06:31:55 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:31:55 <lambdabot> Prelude.asTypeOf :: a -> a -> a
06:32:05 <Jaak> :t mapM
06:32:06 <Syzygy-> ?Type return
06:32:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
06:32:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
06:32:12 <Jaak> @type mapM
06:32:14 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
06:32:26 <Jaak> mm
06:32:33 <Syzygy-> > map return [1,2,3,4] :: [Maybe Int]
06:32:35 <lambdabot>  [Just 1,Just 2,Just 3,Just 4]
06:32:43 <Syzygy-> ?type map return
06:32:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> [m a]
06:32:48 <matthew-_> ok, this is what I want: I have a function f :: a -> m a; I know a; I want to apply a to f and reapply the result of f back into f for as many times as I want. The ultimate result should be of type a
06:33:30 <matthew-_> so I thought that lot amounted to a monadic iterate
06:33:31 <augustss> "as many times as I want", is that a fixed number?
06:33:32 <mauke> @type return 42 0.5
06:33:34 <lambdabot> forall a. (Num a) => a
06:33:48 <matthew-_> augustss: yeah, certainly will be known at compile time
06:33:54 <Syzygy-> > return 42 0.6
06:34:03 <lambdabot>  42
06:34:43 <mauke> > "yes" `return` "no"
06:34:54 <augustss> @type \ n f x -> sequence $ take n $ iterate (>>= f) (return x)
06:34:59 <lambdabot>  thread killed
06:35:05 <matthew-_> interesting type
06:35:09 <lambdabot> thread killed
06:35:19 <matthew-_> @yow
06:35:20 <lambdabot> I want EARS!  I want two ROUND BLACK EARS to make me feel warm 'n
06:35:20 <lambdabot> secure!!
06:35:39 <augustss> @type \ n f x -> sequence $ take n $ iterate (>>= f) (return x)
06:35:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> a -> m [a]
06:35:55 <augustss> Oh, you wanted the last a?
06:36:00 <matthew-_> yes
06:36:13 <matthew-_> so  end type should be m a ideally
06:36:44 <augustss> @type \ n f x -> fmap last $ sequence $ take n $ iterate (>>= f) (return x)
06:36:45 <lambdabot> forall (m :: * -> *) a. (Functor m, Monad m) => Int -> (a -> m a) -> a -> m a
06:36:47 <mauke> @type let x = return undefined :: Monad thread -> thread killed in x
06:36:49 <lambdabot>     Class `Monad' used as a type
06:36:49 <lambdabot>     In the type `Monad thread'
06:36:59 <mauke> @type let x = return undefined :: Monad thread => thread killed in x
06:37:00 <lambdabot> Monad thread => thread killed in x :: forall (thread :: * -> *) killed. (Monad thread) => thread killed
06:37:25 <augustss> @pl \ n f x -> fmap last $ sequence $ take n $ iterate (>>= f) (return x)
06:37:26 <lambdabot> (((fmap last . sequence) .) .) . (. ((. return) . iterate . (=<<))) . (.) . take
06:37:38 <matthew-_> augustss: many thanks! One day I might drink enough coffee to understand that... ;)
06:37:46 <augustss> it's too complex
06:38:17 <augustss> I think a solution with explicit recursion would be much simpler
06:38:41 <matthew-_> yep, ok. Well I can write that ;-)
06:39:11 <ToRA|home> augustss: any reason for using fmap over mapM?
06:39:34 <augustss> @type let nth 0 f x = x; nth n f x = f x >>= \ x' -> nth (n-1) f x' in nth
06:39:35 <lambdabot> forall a (m :: * -> *) b. (Monad m, Num a) => a -> (m b -> m (m b)) -> m b -> m b
06:40:14 <augustss> you need to fiddle a bit with return & >>= to get the types right
06:40:33 <augustss> ToRA|home: fmap and mapM do very different things
06:40:51 <tuukkah> @type \n f x -> sequence (replicate n f) >>= return . last
06:40:53 <lambdabot> forall a (m :: * -> *) t. (Monad m) => Int -> m a -> t -> m a
06:41:00 <ToRA|home> ah yeah
06:41:02 <ToRA|home> my bad
06:41:43 <ToRA|home> i think i meant liftM
06:42:09 <augustss> @type \ n f -> foldr (>>=) return (replicate n f)
06:42:11 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
06:42:11 <lambdabot>       Expected type: (a -> a) -> (a -> a -> b) -> a -> a -> b
06:42:31 <augustss> @type foldr (>>=)
06:42:32 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
06:42:32 <lambdabot>       Expected type: (a -> a) -> (a -> a -> b) -> a -> a -> b
06:42:42 <matthew-_> @paste
06:42:43 <lambdabot> http://paste.lisp.org/new/haskell
06:43:02 <ToRA|home> @type foldr (=<<)
06:43:03 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
06:43:10 <lisppaste2> matthew-_ pasted "lastIterateM" at http://paste.lisp.org/display/34420
06:43:19 <matthew-_> I can understand that version ;)
06:43:20 <augustss> ah yes
06:43:39 <augustss> @type \ n f -> foldr (=<<) return (replicate n f)
06:43:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (m a -> a -> m a) -> a -> m a
06:46:11 <augustss> @pl \ n f x -> foldr (=<<) (return x) (replicate n f)
06:46:11 <lambdabot> (flip (foldr (=<<) . return) .) . replicate
06:46:39 <augustss> @type \ n f x -> foldr (=<<) (return x) (replicate n f)
06:46:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> a -> m a
06:47:55 <lisppaste2> augustss annotated #34420 with "Finally (I think)" at http://paste.lisp.org/display/34420#1
06:49:09 <astrolabe> What does ASSERT ( booleanCondition ) do?  I found it on a ghc page.
06:49:49 <astrolabe> Does it use the C pre-processor?
06:50:10 <augustss> probably
06:51:18 <matthew-_> augustss: many thanks. I don't mean to be rude, but are there any advantages to using your version?
06:51:30 <augustss> nope :)
06:52:07 <astrolabe> heh
06:52:07 <augustss> it doesn't use explicit recursion, which is nice, but not a big deal
06:52:25 <tuukkah> shorter is always better :-)
06:52:38 <augustss> hmmmm, like APL?
06:53:12 <tuukkah> like anything =) i bet APL can't match haskell in many non-trivial cases
06:53:41 <augustss> btw, you can use this too:  foldl (>>=) (return x) (replicate n f)
06:54:00 <tuukkah> yeah, looks less strange that way
06:54:08 <augustss> I kinda like it.  after a little staring you can see what it does
06:54:38 <tuukkah> and otherwise, you can easily guess. what else would it do
06:54:39 <matthew-_> well, you'll be pleased to know that the use of that function has solved the problem I was having
06:54:53 <matthew-_> so your efforts have not been wasted ;-)
06:59:23 <dmhouse> augustss: you're aware of replicateM, I guess?
06:59:27 * dmhouse came late to this conversation
07:03:27 <augustss> dmhouse: yes, but it doesn't do what we wanted
07:04:00 <dmhouse> augustss: true.
07:04:10 <dmhouse> Sorry, misread what you pasted.
07:04:18 <augustss> this is like the monadic version of 'iterate f x !! n'
07:04:31 <dmhouse> Yeah.
07:04:36 <dmhouse> ?hoogle iterateM
07:04:52 <dmhouse> > 2 + 2
07:04:54 <lambdabot>  4
07:04:56 <matthew-_> tried that one too... ;-)
07:05:03 <dmhouse> ?botsnack
07:05:03 <lambdabot> :)
07:05:08 <swiert> augustss: Have you made any progress writing up the lambda calculus note for The Monad.Reader?
07:05:10 <dmhouse> ?hoogle iterate
07:05:11 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
07:05:14 <dmhouse> Meh.
07:05:30 <dmhouse> swiert: are you the TMR editor? When's the publication date?
07:05:50 <swiert> dmhouse: Deadline for submissions is January 19th.
07:05:59 <matthew-_> games development is fun. "Mmm, collision detection is faulty. I know, let's try repeating this test a few times and bumping that number a few times..." "Oh look! It now works!"
07:06:06 <augustss> swiert: hmmm, can't say that I have.  I guess I need to hurry. :)
07:06:09 <swiert> Hopefully I'll manage to put something together two-three weeks after that.
07:06:35 <Philippa> matthew-_: unfortunately the "right thing" is a lot more expensive if you're trying to do anything accurate
07:06:46 <swiert> augustss: Too bad - if you don't make this deadline, you can always submit for the next one.
07:06:48 <dmhouse> swiert: great! Is there a preliminary table of contents or is it all Top Secret at the moment? :)
07:06:51 <matthew-_> Philippa: oh absolutely
07:07:24 <matthew-_> Philippa: and in fact you're generally screwed by the use of FP on physics
07:07:33 <matthew-_> so it's a hit and miss effort from the outset
07:08:09 <swiert> dmhouse: There's a lot of people who said they wanted to write something. It's always hard to say how many submissions I end up getting.
07:08:18 <dmhouse> swiert: sure.
07:08:30 <swiert> dons wanted to write something about implementing an irc bot.
07:08:39 <dmhouse> swiert: well, I look forward to it. :)
07:08:40 <swiert> dcoutts agreed to review Graham Hutton's new book.
07:09:06 <swiert> Dan Piponi (aka sigfpe) is writing something about classical logic in Haskell.
07:09:27 <swiert> roconnor, Bernie Pope, the list goes on...
07:09:59 <swiert> So I think it might work out all right (knock on wood).
07:10:24 <dmhouse> Aha, that's sigfpe's real name. It's not listed anywhere on his website.
07:11:13 <psykotic> dmhouse, it's on his mac.com website
07:11:47 <psykotic> homepage.mac.com/sigfpe/
07:12:28 <dmhouse> Oh, so it is.
07:14:55 <malebria> 13:09 <lambdabot> Plugin `more' failed with: IRCRaised thread killed
07:15:05 <malebria> Is this a bug in lambdabot?
07:27:14 <augustss> sigfpe is the only haskell user i know of that has an oscar :)
07:29:49 <Andris> what for?
07:30:24 <vegai> perhaps it's not the same Dan :)
07:30:31 <vegai> .. is it?
07:30:53 <augustss> it is
07:30:58 <vegai> Oh. Mom.
07:31:07 <vegai> eh, s/Mom/Wow/
07:31:12 <augustss> it's for computer animation
07:31:14 <lokojones> hey guys
07:31:31 <Andris> cool
07:31:48 <lokojones> I have this function
07:31:50 <lokojones> funcionObjetivo :: Float -> Float -> Float
07:31:50 <lokojones> funcionObjetivo x1 x2 = x1^2+2*x2^2+5-4*x1*x2
07:32:09 <lokojones> and I have a [[Float]] with 100 elements
07:32:40 <lokojones> each [Float] on that list, has 2 floats
07:32:51 <lokojones> I want them to be x1, and x2
07:33:03 <Lemmih> lokojones: Can you make it a [(Float, Float)]?
07:33:15 <augustss> map (\ [x1,x2] -> funcionObjetivo x1 x2) list
07:33:34 <lokojones> Lemmih: yes, I can, but I wanted to keep it [[Float]] for future changes in the code
07:33:42 <lokojones> in the future, I may have x1, x2 and x3
07:33:57 <lokojones> but anyway
07:34:09 <augustss> well, as you see, it's easy :)
07:34:13 <lokojones> the problem is that I want to apply funcionObjetivo to all the elements
07:34:18 <lokojones> I even did it
07:34:21 <lokojones> I did this
07:35:06 <lokojones> procesarElementos :: [Float] -> [Float]
07:35:06 <lokojones> procesarElementos [] = []
07:35:07 <lokojones> procesarElementos (x:xs) = (funcionObjetivo (x!!0) (x!!1)):(procesarElemento(xs))
07:35:28 <augustss> lokojones: I repeat: map (\ [x1,x2] -> funcionObjetivo x1 x2) list
07:35:46 <lokojones> umh
07:35:56 <lokojones> sorry, hadnt seen that :)
07:36:03 <lokojones> let me figure out what that is... :P
07:37:06 <lokojones> erm
07:37:09 <lokojones> I dont get it...
07:37:17 <lokojones> but anyone, my solution worked
07:37:40 <augustss> yes, but it's not the way you should do it
07:37:41 <lokojones> *anyway
07:37:54 <lokojones> why?
07:38:10 <augustss> the \ [x1,x2] -> ... is a function that expects an argument which is a list with 2 elements
07:38:21 <lokojones> what I want to do at the end is select the x1 and x2 that give in funcionObjetivo the higher values
07:38:25 <malebria> lokojones: it's right, but you're reimplementing map.
07:38:48 <malebria> But I don't see much problem in this.
07:38:50 <lokojones> augustss: you are right
07:39:09 <augustss> lokojones: you could do this 'map (\ x -> funcionObjetivo (x!!0) (x!!1)) list'
07:39:12 <lokojones> yes, I see the solution would only work when working with 2 elements
07:39:28 <allbery_b> but is easily expanded to 3
07:39:29 <lokojones> when having an x3 it wouldnt, for example...
07:39:31 <augustss> it only works with 2, that's what you said you had
07:39:41 <Terabyte> Hey, How would I go about outputting a list of elements containing no duplicates from a list of elements containing duplicates so [1,2,3,3] -> [1,2,3] ? my method doesn't work...
07:39:51 <augustss> map (\ (x1:x2_) -> funcionObjetivo x1 x2) list
07:40:03 <augustss> that works if you add more elements
07:40:10 <Lemmih> > nub [1,2,3,3]
07:40:11 <lambdabot>  [1,2,3]
07:40:14 <allbery_b> s/_/:_/ ?
07:40:23 <augustss> yes
07:40:42 <lokojones> whats that last "list" for?
07:40:43 <augustss> map (\ (x1:x2:_) -> funcionObjetivo x1 x2) list
07:40:57 <augustss> list is your list of [[Float]]
07:40:59 <Terabyte> where did you get nub from?
07:41:08 <lokojones> ok
07:41:16 <Lemmih> ?index nub
07:41:16 <lambdabot> Data.List
07:41:16 <allbery_b> ?index nub
07:41:17 <lambdabot> Data.List
07:41:18 <lokojones> and :_ is so that its able to work with more?
07:41:18 <Terabyte> i don't want to import anything, all has to be in prelude
07:41:37 <allbery_b> yes, it matches everything else in the list and discards it
07:41:38 <augustss> you could write  'procesarElementos = map (\ (x1:x2:_) -> funcionObjetivo x1 x2)'
07:42:00 <augustss> Terabyte: why?
07:42:46 <Terabyte> because in an exam (i'm a student) , they may not let us import such easy solutions :)
07:43:08 <augustss> since it's an exam I won't tell you the solution
07:43:22 <Terabyte> oh no this isn't an exam, sorry, this is mearly a practice question :)
07:43:31 <Terabyte> I wouldn't be on IRC in an exam lol!
07:43:38 <allbery_b> still.  you need to work this out for yoursel
07:43:40 <allbery_b> f
07:43:47 <allbery_b> that's the point...
07:43:48 <Terabyte> ok well i have some code... can I pm you it?
07:43:54 <augustss> Terabyte: you can use foldr
07:44:10 <Terabyte> ah ok thanks
07:44:24 <augustss> Terabyte: or recursion, if you're allowed that
07:44:35 <Terabyte> I tried recursion... didn't work too well
07:44:42 <Terabyte> ERROR file:C:\Documents and Settings\Terabyte\My Documents\Hardware.hs:9 - Cannot justify constraints in explicitly typed binding
07:44:44 <lokojones> and another question...
07:44:44 <Terabyte> whatever that means
07:45:08 <Terabyte> but anwyay i'll try foldr as that sounds closer to home :D
07:45:21 <lokojones> how would I select the bigger element of a [Float], without loosing the original position of the element?
07:48:01 <Botje> maximumBy (comparing snd) $ zip [1..] listOfFloats
07:48:10 <Botje> that leaves you with a (index,float) pair
07:48:13 <julias84> Ho
07:49:14 <Botje> Terabyte: that error means whatever type you gave is wrong.
07:49:15 <julias84> :)
07:49:17 <Botje> hello, julias84
07:49:36 <lokojones> bos_: what module do I need for that?
07:49:50 <lokojones> List?
07:50:51 <lokojones> sorry, Botje
07:50:55 <malebria> lokojones: you can first get the element, and then see where it was.
07:51:47 <lokojones> oh, yes
07:52:06 <lokojones> using sory
07:52:06 <lokojones> *sort
07:52:12 <lokojones> and then searching for that element...
07:52:17 <lokojones> on the original list
07:52:28 <Botje> lokojones: List, yes
07:52:34 <Botje> or Data.List
07:54:40 <mauke> @src Network.Socket.recvLen
07:54:40 <lambdabot> Source not found. Take a stress pill and think things over.
07:54:52 <mauke> @source Network.Socket
07:54:52 <lambdabot> http://darcs.haskell.org/packages/network/Network/Socket.hs
07:54:53 <Jaak> @type comparing
07:54:54 <lambdabot> Not in scope: `comparing'
07:55:05 <Terabyte> well here is my attempt... helper function called with reduceme input []
07:55:05 <Terabyte> reduceme :: [a] -> [a] -> [a]
07:55:05 <Terabyte> reduceme [] output      = output
07:55:05 <Terabyte> reduceme (x:xs) output
07:55:05 <Terabyte>                         | elem x output = reduceme xs output
07:55:05 <Terabyte>                         | otherwise = reduceme xs (x :output)
07:56:10 <mauke> the type should be (Eq a) => [a] -> [a] -> [a]
07:56:25 <Terabyte> oh rite..
07:56:53 <Jaak> @type let comparing = (comapre `on`) where f `on` g = \x y -> (g x) `f` (g y) in compare -- i assume
07:56:54 <lambdabot> Not in scope: `comapre'
07:57:00 <Jaak> blah
07:57:06 <Jaak> @type let comparing = (compare `on`) where f `on` g = \x y -> (g x) `f` (g y) in compare
07:57:08 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:58:16 <Terabyte> hey :D wow it worked....
07:58:40 <Terabyte> but why do i need (Eq a) => ?
07:58:59 <Jaak> @type elem
07:59:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:59:04 <Botje> lokojones: comparing f a b = (f a) `compare` (f b)
07:59:18 <Botje> I know it's in one of the libs but don't know which atm
07:59:31 <Terabyte> oh rite.. cus i used elem and elem has it the rest of the function needs it?
07:59:47 <augustss> yes
07:59:54 <Terabyte> ok thanks :)
08:00:30 <augustss> and if you think about it, it's not strange.  how could you remove duplicates without comparing?
08:00:59 <Terabyte> yeah :)
08:01:09 <mauke> by using a serializing function, like show :-)
08:01:23 <matthew-_> otoh, the fact that Data.Set needs Ord for many ops is strange and annoying ;)
08:01:48 <augustss> matthew-_: it's not strange.  only annoying :)
08:02:17 <matthew-_> well, I assume it's implemented as a treeSet, so the Ord is a result of implementation details
08:02:23 <augustss> matthew-_: to be efficient you need to keep the sets ordered
08:02:35 <augustss> yes
08:02:38 <matthew-_> yup. ok, it's annoying
08:02:42 <dmhouse> matthew-_: if you don't like, come up with an efficient way to store Sets without using trees.
08:02:46 <dmhouse> Why is it annoying?
08:02:56 <dmhouse> Ord's hardly a tough constraint, most things are comparable.
08:03:06 <matthew-_> because I may not have a clue what ordering I want
08:03:21 <matthew-_> I guess it doesn't matter from Set's point of view
08:03:24 <dcoutts_> it usually doesn't matter what the ordering is, as long as it's total
08:03:26 <matthew-_> so long as it's valid
08:03:27 <matthew-_> yeah
08:03:28 <dmhouse> Then invent something arbitrary. Derive it if you want. It doesn't actually matter what ordering you use.
08:03:28 <augustss> matthew-_: right
08:03:32 <mauke> @hoogle Handle -> Int -> IO String
08:03:32 <lambdabot> No matches, try a more general search
08:03:44 <mauke> is there really no read() function in haskell?
08:04:02 <dmhouse> ?hoogle hGetChar
08:04:03 <lambdabot> IO.hGetChar :: Handle -> IO Char
08:04:03 <augustss> @type readIO
08:04:05 <lambdabot> forall a. (Read a) => String -> IO a
08:04:09 <dcoutts_> mauke, there's functions for reading arrays of bytes, yes
08:04:28 <dcoutts_> @hoogle hgetarray
08:04:29 <lambdabot> Data.Array.IO.hGetArray :: Handle -> IOUArray Int Word8 -> Int -> IO Int
08:04:42 <mauke> that's evil
08:04:55 <dcoutts_> why?
08:04:57 <augustss> mauke: you want to read a number of bytes from a file?
08:05:07 <mauke> augustss: yeah
08:05:08 <dmhouse> ?type \h n -> replicateM n (hGetChar h)
08:05:09 <lambdabot> Not in scope: `hGetChar'
08:05:15 <dmhouse> ?type \h n -> replicateM n (System.IO.hGetChar h)
08:05:16 <lambdabot> GHC.IOBase.Handle -> Int -> IO [Char]
08:05:28 <mauke> dmhouse: isn't that horribly inefficient?
08:05:32 <dcoutts_> yes it is
08:05:58 <dmhouse> dcoutts_: why?
08:06:05 <dcoutts_> locking and representation
08:06:10 <dmhouse> Opening the handle multiple times?
08:06:12 <augustss> mauke: if you want efficiency, use the ByteString library
08:06:14 <mauke> dcoutts_: because now I have to allocate an array, convert it to a string, etc
08:06:53 <mauke> I don't want efficiency, I just don't want inefficiency :/
08:06:59 <dcoutts_> mauke, the quick and easy way is to hGetContents and then just use pure list ops like take
08:07:16 <dmhouse> That's easier, actually.
08:07:30 <dmhouse> ?type \h n -> take n (System.IO.hGetContents h)
08:07:31 <dcoutts_> you can do the same with ByteString.Lazy
08:07:31 <lambdabot>     Couldn't match `[a]' against `IO String'
08:07:31 <lambdabot>       Expected type: [a]
08:07:34 <yaxu> i've been thinking that Haskell is a more graphical language than Pure Data, in that Haskell has a 2D syntax whereas in PD whitespace has no meaning whatsoever
08:07:41 <dmhouse> ?type \h n -> fmap (take n) (System.IO.hGetContents h)
08:07:42 <lambdabot> GHC.IOBase.Handle -> Int -> IO [Char]
08:07:49 <mauke> dcoutts_: that doesn't sound very practical if your handle is really a socket with interleaved read/writes
08:07:49 <dmhouse> As it's consumed lazily that'll work.
08:08:24 <dcoutts_> mauke, yeah, in that case you have to be careful with strictness so it's harder to do with lazy io
08:09:42 <mauke> so far it seems clear that I need to write my own buffering; handles don't expose their buffer
08:10:07 <mauke> handles also don't support read() so I'll probably wrap Network.Socket.Socket
08:10:19 <dcoutts_> @type Data.ByteString.hGet
08:10:20 <lambdabot> GHC.IOBase.Handle -> Int -> IO Data.ByteString.Base.ByteString
08:10:27 <dcoutts_> mauke, voilla
08:11:00 <dcoutts_> and if you want a String rather than ByteString then use unpack
08:11:15 <mauke> that's nonstandard :(
08:11:28 <mauke> as in "doesn't come with ghc"
08:11:37 <dcoutts_> mauke, it does, it's in base
08:11:40 <dcoutts_> as of ghc-6.6
08:11:51 <mauke> but 6.6 doesn't work with hs-plugins
08:11:57 <dcoutts_> still?
08:12:01 * dcoutts_ pokes dons
08:14:01 <dcoutts_> mauke, here are two solutions: use hGetBuf + allocaBytes + peekCString which will be fast or use something involving hGetChar repeatedly
08:14:36 <mauke> I don't think ghc is smart enough to fuse repeated getchars into read()
08:14:46 <dcoutts_> indeed, it isn't
08:15:44 <mauke> oh, and hGetBuf means I have to do my own error handling
08:16:18 <dcoutts_> then use the array version
08:17:05 <augustss> mauke: start with the simplest solution.  if it's not adequate, make a better one
08:17:23 <dcoutts_> good advice
08:17:39 <dcoutts_> go with the hGetChar one suggested earlier and switch if it's too slow
08:18:05 <mauke> just wrapping sockets seems a lot simpler than using arrays
08:18:14 <dcoutts_> mauke, anyway if you want performance you wouldn't be using [Char] in the first place
08:18:19 <dcoutts_> you'd use ByteString
08:19:51 <mauke> I don't want performance, I just don't want inefficiency
08:20:03 <dcoutts_> mauke, sockets have already been wrapped Network.Socket
08:20:14 <dcoutts_> mauke, [Char] == inefficiency
08:20:34 <mauke> no, [Char] is very clear and simple
08:20:45 <mauke> and it doesn't do any syscalls
08:20:54 <dcoutts_> nor does hGetChar
08:20:57 <dcoutts_> it uses a buffer
08:21:15 <mauke> ... which I can't control
08:21:19 <dcoutts_> [Char] is indeed very clear and simple, it's also inefficient
08:21:21 <mauke> so it's useless for socket operations
08:21:51 <dcoutts_> mauke, I think the Handle buffer isn't a problem for sockets since it doesn't block trying to fill the buffer
08:22:11 <mauke> huh?
08:22:15 <augustss> if it were useless people would be able to write socket code in haskell
08:22:44 <mauke> augustss: that doesn
08:22:48 <mauke> t make any sense
08:22:58 <Syzygy-> dcoutts_: What should one use instead? Bytestring?
08:23:03 <dcoutts_> mauke, you're worried that the Handle buffer will try to request more bytes than are availble in the OS's socket in buffer and then block ?
08:23:30 <augustss> mauke: s/would/wouldn't/
08:23:32 <dcoutts_> Syzygy-, if you're worried about IO performance or you're throwing around large streams of data then yes
08:23:53 <mauke> dcoutts_: no, I'm worried that writing to the handle won't actually send anything until the buffer is full
08:24:03 <dcoutts_> mauke, set the output buffer mode
08:24:23 <mauke> you can do that?
08:24:31 <augustss> sure
08:24:34 <malebria> @paste
08:24:39 <mauke> how?
08:24:41 <dcoutts_> hSetBuffering
08:25:00 <mauke> that also sets input buffering
08:25:10 <dcoutts_> you can use block buffering (with a specified buffer size), line buffering and no buffering
08:25:14 <dcoutts_> yes
08:26:10 <mauke> what I really need is dynamic packet buffering, or unbuffered output/block buffered input
08:26:13 <dcoutts_> mauke, it sounds like you just want to use Network.Socket
08:26:19 <dcoutts_> send :: Socket -> String -> IO Int
08:26:19 <dcoutts_> recv :: Socket -> Int -> IO String
08:26:27 <mauke> yes, that's what I said
08:26:42 <dcoutts_> great, problem solved
08:26:48 <dcoutts_> no need to wrap it yourself
08:27:00 <mauke> yes, there is
08:27:12 <mauke> I still need a buffer
08:27:30 <mauke> the only question was whether to wrap a socket or an unbuffered io handle
08:28:04 <dcoutts_> you could use a buffered handle and flush when necessary
08:29:17 <mauke> hmm, indeed
08:30:36 <dcoutts_> @hoogle hFlush
08:30:37 <lambdabot> IO.hFlush :: Handle -> IO ()
08:30:49 <augustss> does it work to do socketToHandle more than once on a socket?
08:31:08 <dcoutts_> probably not
08:31:14 <augustss> i'm guessing no
08:31:17 <Heffalump> have you read the socketToHandle code?
08:31:37 <Heffalump> I think I looked at it some time ago while trying to play around with this stuff and got a serious headache :-)
08:31:38 <augustss> no
08:32:00 <dcoutts_> @type ConvertedToHandle
08:32:02 <lambdabot> Not in scope: data constructor `ConvertedToHandle'
08:32:09 <dcoutts_> @type Network.Socket.ConvertedToHandle
08:32:11 <lambdabot> Network.Socket.SocketStatus
08:33:05 <mauke> what should I call my string split function?
08:33:39 <norpan> stringsplit?
08:33:43 <Heffalump> split?
08:33:52 <mahogny> ssplit?
08:34:22 <mauke> Heffalump: split is already taken
08:34:34 <mahogny> in haskell I call mine split2 but then it works on any list, not only strings
08:34:45 <mahogny> ehr. duh. wrong channel. haskell is assumed :)
08:35:02 <norpan> ?type split
08:35:04 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
08:35:27 <mahogny> split taken for the rng system? now that is name space pollutio
08:35:50 <Heffalump> import qualified
08:35:53 <dcoutts_> it's not in the default namespace
08:35:54 <allbery_b> only if you load that module unqualified
08:35:58 <mauke> hmm, uncat? cocat?
08:36:09 <mauke> ?type splitAt
08:36:10 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:36:13 <dcoutts_> what does it do?
08:36:32 <mauke> (Eq a) => [a] -> [a] -> [[a]]
08:36:53 <mauke> given a delimiter and a source string, returns a list of substrings
08:37:06 <norpan> splitBy
08:37:28 <dcoutts_> or splitOn
08:37:41 <mauke> "split" seems to imply exactly two results (a tuple) in haskell
08:38:01 <dcoutts_> it's not that much of a convention
08:38:43 <seliopou> we should prefix every function that returns a tuple with 2tup!
08:38:45 <seliopou> BUG
08:39:12 <mahogny> e_e_coli, bacterial invasion? o_O
08:39:49 <e_e_coli> bacteria + mdernist poet
08:39:55 <e_e_coli> p
08:40:05 <mahogny> hm. I can stand bacteria. poets are worse
08:40:23 <mahogny> my immune response is weak against poetry
08:41:31 <seliopou> fn
08:41:38 <seliopou> aplctn
08:41:40 <seliopou> sunset
08:42:37 <e_e_coli> mahogny: http://members.tripod.com/~rafistern/poem.html
08:43:10 <mahogny> omg
08:43:35 <mahogny> reminds me that in another channel we one day decided that all sentences has to be written in form of limericks. that was a bit challenging
08:48:14 <mauke> wow, it just works
08:49:34 <astrolabe> that just means that the bugs are cunningly hidden
08:49:55 <dmhouse> Wow. I get how regexps are modelled as automaton. :)
08:50:02 <dmhouse> *automata
08:51:02 <mauke> @let dropPrefix [] xs = Just xs; dropPrefix _ [] = Nothing; dropPrefix (p : ps) (x : xs) | p == x = dropPrefix ps xs | otherwise = Nothing
08:51:13 <mahogny> dmhouse, hm. you haven't dealt with formal languages before? o_O
08:51:19 * mahogny is surprised
08:53:22 <mauke> @let splitBy _ [] = [[]]; splitBy [] xs = map (: []) xs; splitBy ds@(d : _) ys@(x : xs) = case dropPrefix ds ys of {Just ys' -> [] : splitBy ds ys'; Nothing -> let (r : rs) = splitBy ds xs in (x : r) : rs}
08:53:23 <lambdabot> Defined.
08:53:24 <fasta> How do I use non-local control flow within a State monad? I want to do an abortive continuation, but I don't really see how callCC should work in my case.
08:53:47 <mauke> > splitBy "--" "foo--bar--baz"
08:53:49 <lambdabot>  ["foo","bar","baz"]
08:54:21 <mahogny> hm. how is performance for using the ST monad for remembering values compared to tossing around state like a normal variable?
08:55:55 <kowey> hi all... i just got asked on #haskell.fr how one can assure that (read foo) :: Integer actually gives back an integer (consider read "bonjour")
08:56:07 <kowey> the advice i gave was to create a function like maybeReadInteger :: String -> Maybe Integer
08:56:24 <mahogny> sounds like the way
08:56:25 <kowey> which would check something like all isNumber theString... but that sounds fishy... better ideas?
08:56:33 <bringert> kowey: use reads
08:56:34 <mauke> > reads "bonjour" :: ReadS Integer
08:56:35 <lambdabot>      Expecting a function type, but found `[(a, String)]'
08:56:35 <lambdabot>       Expected type...
08:56:36 <bringert> @type reads
08:56:37 <lambdabot> forall a. (Read a) => ReadS a
08:56:56 <mauke> > (reads :: ReadS Integer) "bonjour"
08:56:57 <lambdabot>  []
08:57:08 <bringert> @type fmap fst . listToMaybe . reads
08:57:09 <lambdabot> forall a. (Read a) => String -> Maybe a
08:57:15 <mauke> > (reads :: ReadS Integer) "10$"
08:57:16 <lambdabot>  [(10,"$")]
08:57:32 <paolino> hi, can you suggest an efficent implementation of
08:57:33 <paolino> cycle1 [1,2,3] = [[1,2,3],[3,1,2],[2,3,1]] ?
08:57:50 <kowey> bringert and mauke: thanks! (and i learned something new too, woo!)
08:58:04 <bringert> man, I just built all of ghc + extralibs in 13 minutes
08:58:10 <bringert> build.mk is nice
08:59:06 <bringert> @type listToMaybe . map fst . reads
08:59:07 <lambdabot> forall a. (Read a) => String -> Maybe a
08:59:13 <bringert> is one char shorter
08:59:25 <mauke> @type \x -> zipWith (\a b -> zipWith const b a) x (cycle x)
08:59:27 <lambdabot> forall b. [[b]] -> [[b]]
09:00:03 <Mitar> which function on lists replaces the given element with another one (also given)
09:00:05 <mauke> @type \x -> zipWith (\_ b -> zipWith const b x) x (cycle x)
09:00:05 <Mitar> somethin like
09:00:06 <lambdabot> forall a. [[a]] -> [[a]]
09:00:31 <Mitar> replace 1 2 [1,3,4,5] = [2,3,4,5]
09:00:41 <bringert> Mitar: I don't think there is a standard function for that. I always end up writing my own
09:00:42 <Mitar> i know i could use map
09:00:55 <Mitar> ok
09:00:56 <bringert> or a list comprehension
09:01:07 <bringert> there should be one though
09:01:28 <Saizan> > cycle1 xs = let l = length xs in take l . iterate (drop (l-1)) $ (cycle xs)
09:01:29 <lambdabot>  Parse error
09:01:47 <Saizan> > cycle1 xs = let l = length xs in take l . iterate (drop (l-1)) $ (cycle xs) in cycle1 [1..3]
09:01:47 <lambdabot>  Parse error
09:01:52 <Mitar> what about changing the nth element?
09:01:56 <Saizan> > let cycle1 xs = let l = length xs in take l . iterate (drop (l-1)) $ (cycle xs) in cycle1 [1..3]
09:01:57 <lambdabot>  [[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
09:02:31 <Saizan> > let cycle1 xs = let l = length xs in take l . iterate (take l . drop (l-1)) $ (cycle xs) in cycle1 [1..3]
09:02:33 <lambdabot>  [[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
09:02:53 <mauke> > let cycle1 x = zipWith (\_ b -> zipWith const b x) x (tails $ cycle x)) in cycle1 [1..3]
09:02:53 <lambdabot>  Parse error
09:03:02 <mauke> > let cycle1 x = zipWith (\_ b -> zipWith const b x) x (tails $ cycle x) in cycle1 [1..3]
09:03:03 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
09:03:32 <mauke> > let cycle1 x = zipWith (\_ b -> zipWith const b x) x (tails $ cycle x) in cycle1 [1..]
09:03:34 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:03:53 <mauke> > let cycle1 x = zipWith (\_ b -> zipWith const b x) x (tails $ cycle x) in map (take 10) $ cycle1 [1..]
09:03:54 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,...
09:05:12 <paolino> mauke , for 3 elems mine is more efficent :/
09:05:43 <paolino> cycle1 xs = cycle' xs [] where
09:05:44 <paolino>   cycle' [] _ = []
09:05:44 <paolino>   cycle' l@(x:xs) ys = (l++ys) : cycle' xs (x:ys)
09:07:51 <paolino> I thought  that (++) in my version could be eliminated
09:10:03 <paolino> mauke yours is (164 reductions, 293 cells)
09:10:04 <paolino> mine (140 reductions, 244 cells)
09:10:04 <paolino> does this measure efficience ?
09:12:18 <glguy> What are you guys writting?
09:12:44 * glguy checks the timestamps, notices he's a bit late
09:13:05 <paolino> cycle1 [1,2,3] = [[1,2,3],[3,1,2],[2,3,1]]
09:13:20 <Jaak> rotations
09:13:34 <paolino> ah, that's the name
09:13:42 <glguy> > rotations xs = zipWith (++) (tails xs) (inits xs) in rotations [1,2,3] -- ?
09:13:42 <lambdabot>  Parse error
09:13:45 <glguy> heh
09:13:48 <glguy> > let rotations xs = zipWith (++) (tails xs) (inits xs) in rotations [1,2,3] -- ?
09:13:50 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
09:13:54 <glguy> oops
09:14:28 <fasta> How can I abort the current continuation and replace it with another?
09:14:34 <glguy> Cont!
09:14:45 <fasta> glguy: in combination with a State monad?
09:14:49 <glguy> ContT
09:14:49 <dmhouse> fasta: yeah, if you want to mess around with continuation, you need Cont.
09:15:06 <dmhouse> Continuations aren't 'built in' like (I believe) they are in Scheme.
09:15:12 <fasta> glguy: can you give an example, because I am not really getting it.
09:15:26 <fasta> glguy: with ContT
09:16:32 <fasta> Oh, I see there's a State instance, indeed.
09:16:40 <glguy> evalState $ flip runContT return . callCC $ \skipout -> put 1 >> get >> skipout 2 >> return 3
09:16:45 <glguy> something like that
09:17:08 <glguy> ?type evalState $ flip runContT return . callCC $ \skipout -> put 1 >> get >> skipout 2 >> return 3
09:17:10 <lambdabot> forall s s1 a. (Num a, MonadCont (ContT a (State s)), Num s1, MonadState s1 (ContT a (State s))) => s -> a
09:17:17 <glguy> oh!
09:17:21 <fasta> These types are really unreadable
09:17:27 <glguy> > evalState (flip runContT return . callCC $ \skipout -> put 1 >> get >> skipout 2 >> return 3) 0
09:17:28 <lambdabot>  2
09:17:53 <fasta> glguy: thanks
09:18:02 <glguy> does that make sense though?
09:18:14 <glguy> > runState (flip runContT return . callCC $ \skipout -> put 1 >> get >> skipout 2 >> return 3) 0
09:18:16 <lambdabot>  (2,1)
09:18:23 <glguy> (notice that the state value is returned
09:18:25 <dmhouse> ?type evalState $ flip runContT return . callCC $ \skipout -> put (1::Int) >> get >> skipout (2::Int) >> return (3::Int)
09:18:27 <lambdabot> forall s. (MonadCont (ContT Int (State s)), MonadState Int (ContT Int (State s))) => s -> Int
09:18:46 <fasta> glguy: the use of . and flip doesn't make it easy to read
09:18:47 <glguy> it was just saying that it wanted an initial state parameter before it coudl return somethign to me
09:18:58 <fasta> glguy: otherwise, I think I can make it work,
09:19:01 <glguy> fasta: (`runContT` return)
09:19:09 <glguy> I don't think that's much more enlightening
09:19:18 <glguy> I usually write: evalContT = flip runContT return
09:19:25 <glguy> evalCont = flip runCont id
09:20:25 <paolino> glguy: can you fix your "rotations"   ?
09:21:18 <glguy> does it matter if ti starts with the original list?
09:21:40 <glguy> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations [1,2,3]
09:21:41 <lambdabot>  [[2,3,1],[3,1,2],[1,2,3]]
09:21:53 <glguy> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations [] -- base case
09:21:54 <lambdabot>  Add a type signature
09:22:07 <glguy> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations [] :: [[()]]
09:22:08 <lambdabot>  []
09:22:30 <mauke> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations ""
09:22:31 <lambdabot>  []
09:23:04 <mauke> > let rotations x = zipWith (\_ b -> zipWith const b x) x (tails $ cycle x) in rotations ""
09:23:05 <lambdabot>  []
09:23:09 <glguy> > let rotations xs = [b:bs++a|(a,b:bs) <- zip (tails xs) (inits xs)] in rotations [1,2,3]
09:23:11 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
09:23:15 <glguy> oops
09:23:27 <paolino> slightly more efficient than mauke
09:23:35 <glguy> > let rotations xs = [b:bs++a|(a,b:bs) <- zip (inits xs) (tails xs)] in rotations [1,2,3]
09:23:37 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
09:23:44 <dmhouse> ?hoogle callCC
09:23:45 <lambdabot> Control.Monad.Cont.callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
09:23:46 <glguy> how about that?
09:24:50 <mauke> > let rotations xs = [b:bs++a|(a,b:bs) <- zip (inits xs) (tails xs)] in map (take 10) $ rotations [1..]
09:24:51 <paolino> very inefficient
09:24:52 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,...
09:28:23 <paolino> is it right to check numbers of reductions to judge performance ?
09:28:32 <glguy> I think that this function will always be an O(n^2) operation
09:29:00 <glguy> and I can't imagine that it coudl be so critical that it would be worth sacrifising readability
09:29:06 <glguy> but I dont' know what it is being used for ...
09:29:06 <glguy> so
09:29:14 <mahogny> n being what here?
09:29:19 <glguy> length of the list
09:29:32 <mahogny> number of [] in the output?
09:30:04 <mahogny> ah wait. seems this was a bit different from what he originally asked for
09:30:40 <apfelmus> what's the task?
09:31:09 <paolino> glguy you think I can gain performance if I use Arrays ?
09:31:19 <glguy> nope
09:31:38 <glguy> you'll still have to generate rotations of index values
09:31:44 <apfelmus> glguy: what's the problem?
09:31:49 <mahogny> no, but I think you might be able to gain speed if you consider how you use it in case you don't use all of it
09:32:07 <glguy> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations [1,2,3] -- apfelmus writing this function
09:33:12 <dmhouse> If you do callCC $ \k -> do foo; k "hello!"; bar, will bar ever get run?
09:33:25 <glguy> nope
09:33:45 <dmhouse> Which is why the return type of k is universally quantified. Makes sense.
09:34:02 <paolino> mahogny:  This and permutations are central to my algorithms.
09:34:18 <mahogny> paolino, do you use the entire list that you get back?
09:34:53 <paolino> usually a random subset of it
09:36:24 <paolino> I know haskell is not for number crunching, I'm just trying to get the best performance on core functions
09:36:41 <syntaxfree> what is "for number crunching", then?
09:37:02 <mahogny> paolino, hey, nice. I am also about to do some serious crunching :)
09:37:10 <syntaxfree> in principle, an elementary operation should run just as fast in a haskell program and in a C program.
09:37:12 <mahogny> paolino, but if you want random access then drop this function totally
09:37:25 <mahogny> paolino, generate the value at the place you want. otherwise you will generate lots of waste
09:37:29 <syntaxfree> some data structures in Haskell are slow, because of laziness and functionalness.
09:37:44 <syntaxfree> you should be able to write quite efficient Haskell numeric code if you play your cards right.
09:38:01 <mahogny> benchmarking is always a good thing
09:38:14 <syntaxfree> (the main problem will be that so many numerical recipes in books are written for imperative language, I guess)
09:38:20 <syntaxfree> s/language/languages.
09:38:26 <mahogny> are there any good benchmarking tools for haskell out there?
09:38:49 <mahogny> nah. you prolly resort to using monads anyway in those cases
09:39:01 <mahogny> then it is essentially cut and paste
09:39:27 <syntaxfree> uh. doing everything via IO -- that can get slow.
09:39:28 <mahogny> after all, the pseudo code almost always assume that you use mutatable state
09:39:53 <syntaxfree> do-notation is not pseudocode!
09:40:03 <apfelmus> mahogny: that's why the code is way simpler in functional style
09:40:04 <mahogny> hmmm. is IO that slow?
09:40:10 <dmhouse> ?type (\x -> (ord x, length x)) undefined
09:40:12 <lambdabot>     Couldn't match `[a]' against `Char'
09:40:12 <lambdabot>       Expected type: [a]
09:40:16 <dmhouse> Is that the MR?
09:40:32 <mauke> no, that's a type error
09:40:41 <apfelmus> ?type ord
09:40:42 <lambdabot> Char -> Int
09:40:47 <syntaxfree> mahogny: not really. but if you add IO overhead to every single little operation..
09:40:54 <syntaxfree> mahogny: http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
09:40:59 <lambdabot> Title: Do-notation considered harmful  Data.Syntaxfree, http://tinyurl.com/tlmrl
09:41:05 <mahogny> should read that
09:41:12 <syntaxfree> (somewhat unrelated, but stop thinking of do-notation as pseudocode!)
09:41:15 <mahogny> anyhow, there is a reason why pseudo code uses mutatable state; cache memory
09:41:18 <dmhouse> mauke, apfelmus: I mean undefined is polymorphic so you can apply it to both ord and length, but does the lambda infer a monotype because of the MR or because that's a general rule?
09:41:28 <dmhouse> ?type (\x -> (ord (x ()), length (x ()))) undefined
09:41:30 <lambdabot>     Couldn't match `[a]' against `Char'
09:41:30 <lambdabot>       Expected type: [a]
09:41:37 <dmhouse> Must be a general rule.
09:41:45 <syntaxfree> I'd guess numerics is more tractable in functional code anyway. It's just that the tradition uses mutable state, and so many recipes are out there.
09:41:54 <mauke> you need rank-2 polymorphism for that to work. I think.
09:41:54 <paolino> mahogny: I use haskell to learn thinking, whenever they will pay me I wil think about rewriting my well thought haskell code in C
09:41:56 <apfelmus> dmhouse: you're stuck :) x must have both types
09:42:08 <dmhouse> mauke: why?
09:42:22 <mauke> ?type (\(x :: forall a. a) -> (ord x, length x)) undefined
09:42:24 <lambdabot> (Int, Int)
09:42:39 <dmhouse> See, no rank-2 polymorphism.
09:42:52 <mauke> then what's that (forall a. a) thing called?
09:43:02 <mahogny> paolino, I am writing library code to convert haskell into very fast C, aimed at number crunching. might be of use later if I decide to open source it. what are you coding?
09:43:07 <dmhouse> mauke: standard polymorphism :)
09:43:19 <apfelmus> @pl (\x -> (ord (x ()), length (x ()))) undefined
09:43:19 <lambdabot> liftM2 (,) ord length undefined
09:43:22 <dmhouse> ?type (\(x::a) -> (ord x, length x)) undefined
09:43:24 <lambdabot>     Couldn't match `[a]' against `Char'
09:43:24 <lambdabot>       Expected type: [a]
09:43:28 <mauke> no, standard polymorphism means implicit foralls
09:43:37 <apfelmus> @type liftM2 (,) ord length undefined
09:43:38 <paolino> mahogny: clustering  algorithms
09:43:39 <lambdabot>     Couldn't match `[a]' against `Char'
09:43:39 <lambdabot>       Expected type: Char -> a2
09:43:40 <mauke> this forall isn't at the top level so it can't be implicit
09:43:47 <dmhouse> mauke: I think it's only rank-2 if you put the foralls somewhere other than at the extreme left hand side.
09:43:54 <mauke> exactly!
09:43:55 <syntaxfree> you could use mutable state for very large intermediate data-structures, but converting  "i +=1" in "i <- i+1" is not only silly, I don't know even if it works.
09:43:59 <mahogny> paolino, clustering as in stats or as in networking?
09:43:59 <Philippa> mauke: you're confusing rank-2 polymorphism with the syntactic extensions necessary for it
09:44:09 <paolino> stats
09:44:28 <dmhouse> mauke: the function has type forall a. a -> (Int, Int), foralls on the extreme LHS.
09:44:38 <mahogny> syntaxfree, ah of course. I mostly think about huge LA-algorithms
09:44:43 <dmhouse> Or is it (forall a. a) -> (Int, Int), hrm.
09:44:45 <mauke> no, it has type (forall a. a) -> (Int, Int)
09:44:57 <mahogny> syntaxfree, then you don't have that much freedom in how you rewrite it in haskel
09:45:48 <dmhouse> Okay.
09:46:49 <syntaxfree> absolute freedom exists only in pen-and-paper computing.
09:47:06 <syntaxfree> even assembly language enforces a way of thinking.
09:47:12 <yaxu> is haskell fairly unique in having a two dimensional syntax?
09:47:19 <sorear> fairly
09:47:28 <mahogny> brainfuck :)
09:47:28 <syntaxfree> (At least Z80 assembly did. I don't have an idea what modern-day assembly is like)
09:47:29 <psykotic> ISWIM had it back in the 60's :)
09:47:29 <sorear> python also has it
09:47:31 <syntaxfree> not really.
09:47:32 <mauke> python, befunge
09:47:39 <mahogny> syntaxfree, rather similar, just messier
09:47:40 <syntaxfree> Python also uses "sensible" 2D syntax.
09:47:47 <yaxu> python is more enforced indentation style
09:48:01 <syntaxfree> yaxu: you can just use braces and semicolons, you know.
09:48:03 <paolino> mmhh pyhon is not so free in the other dimension
09:48:11 <sorear> @quote knuth
09:48:11 <lambdabot> knuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
09:48:11 <lambdabot> might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
09:48:13 <syntaxfree> I never use layout. I think it's crazy to rely on characters you can't see for syntax.
09:48:14 <yaxu> syntaxfree: sure, it's nice it's optional
09:48:25 <seliopou> epigram
09:48:48 <mauke> syntaxfree: huhu, get a better editor :-)
09:49:22 <glguy> syntaxfree: you always use {, ;, and }?
09:49:36 <dmhouse> syntaxfree: I can see whitespace.
09:49:49 <dmhouse> syntaxfree: it's everywhere where there isn't text.
09:50:01 <yaxu> syntaxfree: musicians use silence in their compositions
09:50:10 <dmhouse> (On my Emacs any text gets a white background, the general background gets a grey background.)
09:50:19 <mauke> .oO( Cage? )
09:50:20 * yaxu gets metaphorical
09:50:31 <dmhouse> mauke: err... Cage didn't invent rests ;)
09:51:10 <yaxu> sorear: nice quote
09:51:16 <mauke> @quote
09:51:17 <lambdabot> Heffalump says: CPP leads to suffering
09:52:23 <vincenz> @quote
09:52:24 <lambdabot> sjanssen says: your mom has a thunk for a tail
09:52:33 <vincenz> she's a lazy list?
09:53:38 <glguy> ?quote
09:53:39 <lambdabot> delicious-mailicious-test@quote says: dmt
09:53:50 <glguy> :-/
09:53:53 <glguy> ?quote
09:53:54 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
09:54:24 <mauke> ?ghc
09:54:24 <lambdabot> ghc says: yi-static: internal error: TSO object entered!
09:55:00 <seliopou> Hmmm... epigram is written in Haskell
09:55:49 <glguy> you are correct sir!
09:56:06 <apfelmus> glguy, paolino: regarding rotations, every number you access gets generated in O(1) time.
09:56:15 <syntaxfree> is "enamoured" correct?
09:56:31 <mauke> @spell enamoured
09:56:32 <lambdabot> enamored unarmored ensured unmarred encored
09:56:41 <syntaxfree> 3:44 PM  yaxu: syntaxfree: musicians use silence in their compositions
09:56:48 <syntaxfree> yes. but they NOTATE silence.
09:57:03 <syntaxfree> they don't express silence as "no sign in this part of the score".
09:57:17 <glguy> apfelmus: if you access them sequentially
09:57:25 <Mitar> why I get "parse error on input `..'" at: lru reqs number = lru' reqs number 1..number [] 0
09:57:34 * allbery_b thinks "enamoured" would be correct for British / Commonwealth spelling
09:57:37 <e_e_coli> as a percussionist, one gets good at silence
09:57:49 <mauke> Mitar: 1..number is a syntax error
09:57:54 <Mitar> why?
09:57:55 <allbery_b> Mitar: range has to be inside a list
09:57:59 <Mitar> oh
09:58:00 <Mitar> :-)
09:58:06 <Mitar> it makes sense
09:58:10 <glguy> [1 .. number]
09:58:11 <vincenz> @quote syntaxfree
09:58:12 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
09:58:21 <mauke> as for why, everything is a syntax error by default
09:58:36 <apfelmus> glguy: that's the point. but this is a problem of representing them as lists.
09:58:40 <e_e_coli> mauke: that's beautiful
09:58:44 <glguy> so just use mod?
09:59:11 <glguy> apfelmus: it's only a problem if he's accessing them randomly
09:59:31 <mikojiba> hello
09:59:45 <malebria> Is it ! in data definition defining a strict type?
09:59:49 <glguy> yes
09:59:56 <apfelmus> glguy: what i mean is that the true problem is that he *cannot* access anything randomly in O(1) when using lists
10:00:05 <vincenz> malebria: no, a strict field
10:00:24 <augustss> apfelmus: you can access the head in O(1) ;)
10:00:44 <vincenz> and randomly access the head in O(1) as well :)
10:01:04 <glguy> apfelmus: I dont' see the issue, if he wants to apply listArray to the result, he is free to do so
10:01:24 <malebria> vincenz: ok, thanks.
10:03:25 <apfelmus> augustss, vincenz: oops, misplaced quantors. i mean (not $ forall x . he can access x in O(1)) as opposed to (forall x .  not (he can access x in O(1)))  :)
10:04:33 <paolino> glguy ,our algo are asympto.... equivalent.
10:04:44 <glguy> sweet
10:04:49 <apfelmus> glguy: sure. but listArray takes O(length list) time.
10:05:17 <glguy> apfelmus: do you know a better way to build arays?
10:05:19 <vincenz> apfelmus: no I know, I was joking in regards to augustss' comment :)
10:05:28 <Anon4888> To be really pedantic, $ forall x . he can access x in O(1) is true  :P
10:05:34 <damien_karras> I want to ask a question
10:06:03 <augustss> Anon4888: yes, these pesky finite machines
10:06:22 <apfelmus> vincenz: i wanted to give the joke a firm mathematical ground :)
10:07:00 <koala_man> you can't be sure if it's funny or not until it's proven
10:07:28 <vincenz> apfelmus: :)
10:08:14 <apfelmus> glguy: yes, but the point is that the rotations could be accessed in O(1) if he'd start with an array representation beforehand
10:09:31 <damien_karras> apfelmus sucks
10:10:54 <apfelmus> glguy: but i think you mean that building the rotations is not the time intensive task, i.e. he's accessing the ((rotations !! n) !! k) multiple times. of course, listArray is enough in that case.
10:11:00 <damien_karras> I want to ask a question
10:11:25 <apfelmus> damien_karras: just ask it.
10:11:33 <damien_karras> what should I ask?
10:11:44 <paolino> and don't insult
10:11:57 <damien_karras> alright
10:12:04 <damien_karras> I love paolino
10:12:06 <augustss> damien_karras: the question you should ask is "what should I ask?"
10:12:24 <SamB> augustss: he just asked that question!
10:12:31 <kosmikus> sounds like a bot to me
10:12:34 <augustss> And I answered it.
10:12:44 <SamB> we have a strict no-feedback-loop policy!
10:12:46 <damien_karras> augustss sucks
10:13:06 <augustss> recursive questions should have recursive answers
10:13:10 <glguy> it's only been 7 days into the new year and someone already needs to be kicked
10:13:11 <SamB> okay okay, so maybe it is actually a lazy one
10:13:13 <norpan> haha, it never fails, in star trek tos any member of the landing party wearing red clothes dies
10:13:13 <glguy> that's a shame
10:13:30 <damien_karras> I want to ask a question
10:13:34 <apfelmus> damien_karras: you should ask "Java User", whether you're in the wrong channel and whether you can afford trolling around in #haskell multiple times.
10:13:40 <SamB> norpan: every single time?
10:13:49 <norpan> yeah
10:13:53 <norpan> almost
10:13:55 <damien_karras> okay, apfelmus: am I gay?
10:14:00 <SamB> I was going to say
10:14:02 <notsmack> only the newly introduced characters
10:14:15 <augustss> norpan: it's part of the star trek charm.  you know who's gonna die
10:14:38 <damien_karras> I want to ask a question
10:15:01 <norpan> augustss: indeed
10:15:10 <e_e_coli> I saw a 4-year-old boy named "Kirk" at the grocery store the other day,and I came thisclose to screaming "Kiiiiiirk!"
10:15:12 <damien_karras> norpan sucks
10:15:17 <mikojiba> me too, I don't fully understand IO working
10:15:21 <augustss> clearly this damien bot hasn't picked up the right vocabulary for #haskell
10:15:39 <norpan> rather suck than blow
10:15:48 <SamB> someone needs to kick him until he figures out what the question he wants to ask is
10:15:49 <mikojiba> I would like to fill a grid (type Grid = [[Element]] and data Element = Empty | Full) from the console
10:15:57 <syntaxfree> what is the correct hypenization of "object-oriented-programming"?
10:16:02 <damien_karras> who is god?
10:16:06 <syntaxfree> O-O P, O O-P, O-O-P?
10:16:07 <psykotic> object-oriented programming
10:16:17 <SamB> @all-dict god
10:16:18 <lambdabot> God \God\, a. & n.
10:16:18 <lambdabot>    Good. [Obs.] --Chaucer.
10:16:20 <lambdabot>    [1913 Webster]
10:16:22 <lambdabot>  
10:16:24 <lambdabot> [205 @more lines]
10:16:28 <syntaxfree> "object-oriented" becomes an adjective, then?
10:16:29 <augustss> GOD = GOF Of all Djinnies
10:16:36 <augustss> grrr
10:16:36 <psykotic> it's an adjective phrase
10:16:55 <mikojiba> so, I've tried with a function readGrid height = readLine:(readGrid (height-1))
10:17:15 <mikojiba> and readLine = do l <- getLine return (parse l)
10:17:16 <damien_karras> I want to ask a question
10:17:27 <apfelmus> i'd like to now whether our "Java User" is a bot or not. i still don't know the answer from last time.
10:17:35 <damien_karras> I am no bot
10:17:41 <norpan> so ask
10:17:47 <e_e_coli> That's just what a bot would say
10:17:53 <psykotic> damien_karras sucks
10:17:54 <damien_karras> what should I ask
10:17:56 * allbery_b scans back and decides /ignore is apropos
10:18:09 <mikojiba> where parse [] = [] and parse (x:xs) = if x == '1' then Full:(parse xs) else Empty:(parse xs)
10:18:12 <augustss> we could all be bots
10:18:18 <damien_karras> augustss sucks
10:18:19 <norpan> i am certainly a bot
10:18:23 <damien_karras> norpan sucks
10:18:25 <apfelmus> bot. bot. bot. bot (should give a buffer-overflow now)
10:18:26 <psykotic> this is an awesome game
10:18:40 <damien_karras> psykotic sucks
10:18:47 <augustss> lol
10:18:51 <psykotic> gravity sucks
10:19:02 <SamB> if we were bots, why would we be writing programs?
10:19:04 <mikojiba> but the gridFunction has [IO [Element] type, instead of [[Element] or maybe [[IO Element]]
10:19:05 <norpan> vacuum cleaners suck
10:19:12 <mikojiba> could somebody help me please ?
10:19:18 <damien_karras> mikojiba sucks
10:19:20 <apfelmus> psykotic: you'll get used to it :)
10:19:21 <glguy> Are there any ops around that are just tolerating the bot? or do I need to /stats p?
10:19:31 <SamB> damien_karras: rawr! not really.
10:19:39 <damien_karras> SamB sucks
10:19:49 <apfelmus> ?src gridFunction
10:19:50 <lambdabot> Source not found. I feel much better now.
10:19:50 <augustss> SamB: who is writing programs?
10:19:52 * e_e_coli coughs
10:19:57 <SamB> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
10:19:57 <psykotic> i think damien_karras kolgomorov complexity is very low
10:20:05 <psykotic> kolmogorov, even
10:20:24 <apfelmus> mikojiba: where's the function from?
10:20:25 <damien_karras> you can't even type
10:20:30 <psykotic> yeah, i suck
10:20:32 <SamB> who can't type?
10:20:37 * e_e_coli sucks
10:20:40 <psykotic> @type damien_karras
10:20:41 <lambdabot> Not in scope: `damien_karras'
10:20:47 <augustss> mikojiba: you could use mapM when defining readGrid
10:21:20 <damien_karras> augustss sucks ass
10:21:21 <SamB> I think lambdabot should automatically kick anyone who says so many "$NICK sucks"
10:21:36 <psykotic> SamB, quite a niche feature
10:21:46 <mikojiba> apfelmus the function comes from main = do getLine ... g <- readGrid ... putStr (draw grid)
10:21:54 <damien_karras> you all suck
10:21:55 <Philippa> also, potentially dangerous in -blah
10:22:01 <damien_karras> life is a bitch
10:22:05 <vincenz> Philippa: for c*ber?
10:22:05 <damien_karras> god is great
10:22:10 <mikojiba> augustss I will look mapM, I don't know this function, thanks
10:22:12 <SamB> psykotic: much less niche than kicking that penisbird dude
10:22:14 <damien_karras> you all suck
10:22:25 <Philippa> vincenz: was thinking more for description of RL events :-)
10:22:35 --- mode: ChanServ set +o vincenz
10:22:38 <augustss> ok, he's getting annoying now
10:22:43 <SamB> Philippa: notice I said $NICK
10:22:54 --- kick: damien_karras was kicked by vincenz (sucks)
10:22:58 --- mode: vincenz set -o vincenz
10:23:12 <vincenz> augustss: done ;)
10:23:13 <glguy> thanks
10:23:21 <augustss> thanks!
10:23:32 <SamB> not $RANDOM_WORD_THAT_IS_A_VALID_IRC_NICKNAME or anything like that
10:23:34 <apfelmus> vincenz: harhar, that was a good shot! :)
10:23:34 <Philippa> SamB: sure. Notice that there's been at least one case of #haskellers going out
10:24:20 <vincenz> apfelmus: :)
10:24:54 <glguy> Looks like PhilKC allowed damien_karras to leave freenode
10:25:01 <glguy> he said mine wasn't the first complaint
10:25:18 * vincenz wonders what motivates these people
10:26:46 <seliopou> I mean, it might be that we all suck :(((((
10:31:42 <vincenz> seliopou: I suck at sucking
10:31:42 <mbishop> glguy: who?
10:32:02 <glguy> PhilKC is a freenode oper
10:32:57 <mikojiba> sorry but I don't understand how to use mapM. Maybe a good start could be a function which reads n lines from the console and return somthing like [[String]]
10:33:08 <glguy> mikojiba: how about:
10:33:16 <glguy> mapM_ print [1..10]
10:33:31 <glguy> the underscore means you don't care about the result
10:34:18 <glguy> or: mapM (\i -> putStrLn ("Line " ++ show i) >> getLine) [1..10]
10:35:15 <Heffalump> mikojiba: why [[String]] ?
10:35:31 <paolino> @src mapM
10:35:31 <lambdabot> mapM f as = sequence (map f as)
10:35:56 <mikojiba> Heffalump cause in fact I would like to fill a grid = [[Element]]
10:36:14 <mikojiba> glguy that's exactly what i want, thanks
10:36:16 <Heffalump> but why do you think n lines of text should have type [[String]] ?
10:36:52 <paolino> @src sequence
10:36:53 <lambdabot> sequence ms = foldr k (return []) ms
10:36:53 <lambdabot>     where
10:36:53 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
10:36:55 <mikojiba> [String]
10:37:05 <mikojiba> it was a mistake
10:37:26 <Heffalump> @type \n -> mapM (\_ -> getLine) [1..n]
10:37:28 <lambdabot> forall a. (Num a, Enum a) => a -> IO [String]
10:37:45 <Heffalump> there you go (or what glguy suggested above)
10:37:47 <glguy> mikojiba: if all you wanted to do was call getLine 10 times:
10:37:51 <glguy> replicateM 10 getLine
10:38:04 <Heffalump> oh, yeah, that's shorter than mine
10:40:12 <seliopou> @pf (\ f as -> sequence (map f as))
10:40:13 <lambdabot> Maybe you meant: bf pl
10:40:44 <seliopou> @pl (\ f as -> sequence (map f as))
10:40:45 <lambdabot> (sequence .) . map
10:41:06 <sorear> oooh, pl needs improving
10:41:23 <lambdabot> mapM  -- human override
10:41:48 <vincenz> lols
10:42:30 <Jaak> @pl \x -> [x, -x] -- why yes
10:42:31 <lambdabot> (line 1, column 7):
10:42:31 <lambdabot> unexpected "["
10:42:31 <lambdabot> expecting lambda abstraction or expression
10:43:03 <glguy> > sequence [id,negate] 5
10:43:04 <lambdabot>  [5,-5]
10:43:06 <seliopou> @pl \x -> x:(-x):[]
10:43:06 <lambdabot> ap (:) (return . subtract)
10:43:14 <glguy> mine is prettier :-p
10:43:42 <glguy> ?type ap (:) (return . subtract) -- does thsi type?
10:43:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
10:43:44 <lambdabot>       Expected type: a -> [a]
10:43:49 <glguy> nope
10:44:04 <seliopou> :t ap
10:44:06 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:44:12 <glguy> you want negate, not subtract
10:44:21 <mikojiba> where can I find replicateM ? is there any module or package to load ? and I've searched on haskell.org but I havn't got found
10:44:28 <glguy> mikojiba: Control.Monad
10:44:31 <seliopou> :t ap (:) (return . negate)
10:44:32 <lambdabot> forall a. (Num a) => a -> [a]
10:44:37 <allbery_b> ?index replicateM
10:44:38 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:44:47 <seliopou> (ap (:) (return . negate)) 5
10:44:53 <allbery_b> (bots are handy :)
10:44:54 <seliopou> > (ap (:) (return . negate)) 5
10:44:56 <lambdabot>  [5,-5]
10:45:33 <syntaxfree> how important is the fact that Haskell is pure to being able to optimize compiled code?
10:45:38 <Jaak> so, pl does need improvement
10:45:41 <syntaxfree> pure = referentially tansparent, here.
10:46:33 <psykotic> syntaxfree, it's essential to things like map fusion.
10:46:53 <syntaxfree> map fusion?
10:46:56 <syntaxfree> as in, cata-ana fusion?
10:47:14 <psykotic> e.g. map f . map g = map (f . g)
10:47:16 <augustss> all kinds of fusion
10:47:18 <psykotic> but yes it's a more general instance of that sort of thing
10:47:20 <syntaxfree> ah, yes.
10:47:44 <allbery_b> there are some kinds of optimizations that e.g. C can't attempt because (barring the use of extensions such as exist in GNU C) you can't be certain that an external function lacks side effects
10:47:46 <psykotic> also, any kind of subexpression sharing is made easier since you don't have to worry about order of evaluation
10:47:49 <syntaxfree> I'm summing up arguments in favor of referential transparency.
10:48:00 <psykotic> the only order is that imposed by direct data dependency.
10:49:05 <Anon4888> If I have a function that writes to IO, but doesn't read from it, how should I type it?
10:49:26 <syntaxfree> I see. I reckon there's already some theoretical work on what kind of optimization referential transparency affords you.
10:49:27 <LordBrain> IO ()
10:49:27 <mikojiba> ok, thank you for all your solutions, I've just to understand know ;)
10:49:46 <LordBrain> Anon4888: use IO () as the type
10:50:01 <Anon4888> Lord: So there's no difference between reading / writing?
10:50:27 <LordBrain> well if you were reading you might say IO String
10:50:31 <pejo> syntaxfree, there's loads of concrete work done on program transformations for performance.
10:50:34 <allbery_b> in a pure Haskell sense, both mutate the state of the outside world
10:50:45 * mikojiba is away: miam
10:50:47 <allbery_b> *how* they mutate it is in some ways irelevant
10:50:57 <allbery_b> *irrelevant
10:51:03 <syntaxfree> "program transformation". That sounds like a good keyword for further research.
10:51:14 <Anon4888> Thanks guys
10:51:20 <psykotic> syntaxfree, a simple example is memoization.
10:51:33 <psykotic> that relies on purity in a pretty manifest way.
10:53:21 <augustss> Anon4888: standard Haskell does not distinguish I and O in IO.  But you could.
10:53:34 <psykotic> syntaxfree, for good examples of how purity allows you to easily reason about functional programs, you could take a look at a bunch of work by guys like gibbons, hutton, de moer, bird, etc.
10:54:18 <syntaxfree> reason, yes.
10:54:25 <syntaxfree> I've read a bunch of things on Squiggol.
10:54:35 <syntaxfree> I'm more worried about selling it to engineers : )
10:54:49 <psykotic> right but reasoning happens on a smaller scale whenever you write programs.
10:55:08 <augustss> syntaxfree: what kind of engineers?
10:55:32 <syntaxfree> not a specific kind. Not really engineers. I should rather say, Real Programmers, in the sense of "The story of Mel".
10:55:46 <augustss> ah
10:55:50 <syntaxfree> People who had to be dragged kicking and screaming into dropping gotos and using "while" and "for" loops.
10:55:54 <augustss> those are hard to convince
10:56:09 <syntaxfree> It's just a blog post.
10:56:11 <Philippa> better to just leave them to fester somewhere, I would've thought
10:56:16 <psykotic> syntaxfree, i think it's hard to sell someone directly on the benefits of a fairly abstract concept such as that. those people won't be convinced until a lot of great apps are written in the language.
10:56:55 <paolino> like a fabulos haskell IDE ?
10:57:03 <timthelion> @src head
10:57:03 <lambdabot> head (x:_) = x
10:57:04 <lambdabot> head []    = undefined
10:57:06 <syntaxfree> you'll see it when it's done.
10:57:08 <norpan> a fabulous IDE would be great
10:57:31 <Philippa> which reminds me of an idea I told Binkley about - essentially a combined versioning system and structure editor/refactorer, with the intention of using it to show how a piece of code's been arrived at via a series of transformations
10:57:44 <timthelion> I find emacs with a *shell* buffer works just great.
10:57:53 <Philippa> (and to be able to repeat the transformations, possibly with some hand-cranking, after changes to the "original")
10:57:58 <sorear> not a *haskell* buffer?
10:58:05 <norpan> if haskell is so great, we should be able to whip together a fabulous IDE in no time at all
10:58:14 <syntaxfree> that's not the actual source of head.
10:58:15 <syntaxfree> > head []
10:58:15 <sorear> @users
10:58:16 <lambdabot> Maximum users seen in #haskell: 296, currently: 294 (99.3%), active: 44 (15.0%)
10:58:16 <lambdabot>  Add a type signature
10:58:22 <syntaxfree> > head []::Sting
10:58:23 <lambdabot>   Not in scope: type constructor or class `Sting'
10:58:26 <syntaxfree> >head ""
10:58:32 <syntaxfree> > head ""
10:58:33 <lambdabot>  Exception: Prelude.head: empty list
10:58:36 <syntaxfree> see?
10:58:44 <syntaxfree> it's "head [] = error "empty list"
10:58:51 <allbery_b> <norpan> if haskell is so great, we should be able to whip together a fabulous IDE in no time at all
10:58:57 <allbery_b> ah, generalizations :)
10:59:08 <sorear> actually, error "Prelude.head: empty list"
10:59:27 <syntaxfree> pick-nitting : )
10:59:35 <syntaxfree> pic-knitting, too.
10:59:40 <sorear> my specialty :)
10:59:52 <augustss> it's all _|_
11:00:10 <allbery_b> isn't it actually something like errorWithList "empty"? </nitpick>
11:00:39 <sorear> no, it's a singleton set of exceptions! see the asynchronous exceptions paper! </nitpick>
11:00:50 <paolino> for a complex typed language a good IDE is a normal request
11:01:13 <sorear> for a UNIX language Emacs is a normal response
11:01:16 <augustss> I still claim it's all _|_ :)
11:01:49 <paolino> probably . Shame I use vim
11:02:01 <sorear> hey, dons uses vim too
11:02:11 <syntaxfree> augustss: in a list-calculus sense it is. That is not the source of the "head" function as compiled by ghc.
11:02:49 <Vq^> sorear: UNIX language?
11:02:55 <augustss> It's true that it's not the source compiled by ghc
11:03:13 <augustss> but it's equivalent enough
11:03:35 <paolino> there is nothing intelligent in syntax highlighting. A good IDE is something like eclipse I suppose
11:04:13 <mbishop> for varying definitions of "good"
11:04:38 <sorear> emacs haskell-mode tells you function types & supports one-key-sequence recompiling
11:04:59 <sorear> all the more I ask is .hi parsing for user-defined function types
11:05:08 <augustss> has anyone tried intelljide, or whatever it was called?
11:05:41 <notsmack> it's one key sequence at a prompt, too ;-)
11:05:50 <vincenz> intelliJ?
11:06:21 <fasta> sorear: no, it doesn't.
11:06:30 <augustss> it was announced on the haskell mailing list, i think
11:06:49 <sorear> fasta: it doesn't what? C-c C-l?
11:07:04 <fasta> sorear: you claimed two things. It doesn't support the first.
11:07:25 <augustss> http://www.workingmouse.com/research/IntelliJIdea%2DHaskell/
11:07:41 <mahogny> intellij, costs money :(
11:07:48 <mahogny> looked nice otherwise
11:07:57 <sorear> on my system, when the cursor pauses over "head", the echo area displays "[a] -> a"
11:08:15 <fasta> sorear: yes, and when you are on a function that you defined yourself?
11:08:18 <augustss> "This software is released under a BSD-style open source licence"
11:08:19 <sorear> it'd be nice if it supported H98 (better yet, HHL)
11:08:26 <paolino> elicpse is free, right ?
11:08:29 <mahogny> augustss, what. sure?
11:08:34 * mahogny rechecks
11:08:40 <sorear> > all the more I ask is .hi parsing for user-defined function types
11:08:41 <lambdabot>   Not in scope: `types'
11:08:44 <augustss> mahogny: it's the first sentence
11:08:49 <fasta> sorear: in other words, it doesn't support it in the way Visual Studio does
11:08:58 <augustss> mahogny: but maybe you need some other part that you have to pay for
11:09:00 <fasta> (or Eclipse or whatever)
11:09:29 <mahogny> augustss, hm. that is prolly what I saw. I googled on it earlier and got another page
11:09:33 * mahogny downloads :D
11:09:34 <fasta> In other words (as has been discussed a million times before): Emacs/Vim "modes" generally are incomplete.
11:09:57 <fasta> It's just a platform for "quick" hacks
11:11:22 <mahogny> oh yes. only the plugin is free
11:11:27 <mahogny> it seems(?)
11:11:51 <fasta> It's probably free because it hasn't been tested very well.
11:11:54 <sorear> @tell dons testsuite doesn't work here ... hardcoded paths like /usr/local/bin/gm4 (I have /usr/bin/m4) and /home/dons/lambdabot
11:12:28 <augustss> mahogny: yeah, so it seems :(
11:12:56 <mahogny> $499 o_O
11:13:01 <mahogny> ugh
11:13:23 <velco> what's the recommended way to handle array index errors in haskell ?
11:13:35 <kzm_> velco, fix them? :-)
11:13:42 <fasta> kill the program?
11:13:50 <fasta> (calling error)
11:13:58 <mahogny> I prefer to check before that they cannot occur and then use the unsafe ones
11:14:15 <mahogny> checks can usually be done rather high up in the function hierarchy
11:14:16 <velco> do I have to check them myself ?
11:14:27 <mahogny> well, that or your program terminates. your call :)
11:14:56 <augustss> velco: no, the normal indexing checks.  and aborts your program if out of bounds.
11:14:57 <kzm_> velco it will result in an exception.  You can catch it if you want.
11:15:18 <velco> abort is not an option.
11:15:26 <kzm_> There's unsafeAt which will give the "normal" (to a C person) undefined behavior.
11:15:40 <mahogny> normal indeed :)
11:15:47 <velco> ok, I'll have to check them myself then.
11:15:49 <kzm_> abort is the best option, IMO.  'Always crash' and all that.
11:16:11 <velco> abort it non-acceptable behavior.
11:16:13 <mahogny> velco, I think good style is to catch errors as soon as possible instead of waiting for random things to occur
11:16:17 <kzm_> why would you want to write a program that can cause out-of-bounds errors?
11:16:30 <velco> I don't *want*.
11:16:42 <velco> I have a file format where things index othre things.
11:16:45 <bd_> velco: If undefined behavior happens, the program could do something far worse than aborting.
11:16:55 <mahogny> kzm, well, java behaviour seems to be to just continue running at strange errors :P
11:17:02 <sorear> like deleting random files <rare, but possible)
11:17:03 <velco> I can check vakidate indices myself or I can rely in the langiage to catch such errors.
11:17:05 <syntaxfree> @spell transparency
11:17:06 <lambdabot> transparency
11:17:13 <syntaxfree> @spell transparence
11:17:13 <lambdabot> transparency transparencies transparent transference transparency's
11:17:14 <velco> just figuring out hwat do do in haskell.
11:17:15 <sorear> velco: Control.Exception
11:17:18 <mahogny> java juns continues in case of null pointer dereference. they deserve to die for it
11:17:21 <mahogny> *runs
11:17:22 <sorear> velco: you can catch the errors
11:17:44 <kzm_> mahogny, surely you're not suggesting Java as an example of virtue? \me checks which channel he is in.
11:17:49 <velco> java does not "just continue"
11:17:49 <sorear> funny, back when I used java it through a NullPointerException
11:17:51 <mahogny> kzm, :D
11:18:18 <augustss> velco: and what do you want to do when an index is out of bounds?
11:18:19 <mahogny> velco, well, allright, it tend to dump a "warning" and then go on
11:18:28 <mahogny> or something
11:18:30 * mahogny forgot
11:18:48 <velco> report something like "bad file format" and continute with the next file, for example
11:19:00 <sorear> velco: wrap your file reader in Control.Exception
11:19:08 <sorear> @docs Control.Exception
11:19:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
11:19:24 <sorear> catch
11:19:35 <velco> it says GHC does not currently throe array index exception ...
11:20:06 <augustss> > array (0,0) [(0,1)] ! 2
11:20:07 <lambdabot>  Exception: Ix{Integer}.index: Index (2) out of range ((0,0))
11:20:38 <augustss> velco: where does it say that?
11:21:18 <velco> there is "(NOTE: GHC currently does not throw ArrayExceptions)"
11:21:43 <velco> and indeed looking at Arr.lhs, it just calls "error", which is fatal, AFAIK, right ?
11:21:58 <augustss> velco: no, it's not fatal
11:21:58 <sorear> error is NOT fatal
11:22:02 <velco> oh
11:22:08 <velco> how do I catch it ?
11:22:11 <sorear> Prelude Control.Exception Data.Array> Control.Exception.catch (evaluate (array (0,0) [(1,'a')]) >> return ()) (\e -> putStrLn "out of range!")       \n        out of range!
11:22:20 <sorear> that's from my ghci session
11:22:28 <velco> Control.Exception.catch then... Thanks.
11:23:09 <sorear> If you restrict yourself to H98, error (and bounds errors) are fatal
11:23:44 <Cale> and watch that call to evaluate too, it's needed in order to sequence the evaluation of the error in the IO monad so that catch will actually be able to catch it
11:27:09 * mikojiba is back (gone 00:36:25)
11:27:15 <fasta> How can I make this work? (abandon the evaluation of mapM_) http://pastebin.ca/309507
11:27:24 <paolino> is there some kind of fold which function can eat more than one element ?
11:27:40 <syntaxfree> Cale: hey. where's that "Down the rabbit hole" tutorial on IO you wrote?
11:27:55 <mahogny> paolino, sounds like you have to write something from scratch
11:27:58 <Cale> I didn't write that
11:28:17 <syntaxfree> "IO inside", or something.
11:28:18 <lokojones> does haskell provide any function to return the position of some element in a list?
11:28:23 <syntaxfree> Didn't you?
11:28:33 <allbery_b> lokojones: index
11:28:38 <Cale> I wrote "Introduction to IO" which is a short blurb on the wiki
11:28:47 <Cale> as well as Monads as Containers
11:28:48 <syntaxfree> where is it?
11:28:55 <syntaxfree> Monads as Containers is a Cale classic.
11:28:59 <Cale> @wiki Introduction_to_IO
11:28:59 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
11:29:07 <lokojones> allbery_b: Data.List?
11:29:11 <Cale> lokojones: elemIndex
11:29:18 <Cale> @type elemIndex
11:29:19 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
11:29:22 <Cale> @type elemIndices
11:29:24 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
11:29:32 <Cale> @type findIndex
11:29:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
11:29:37 <Cale> @type findIndices
11:29:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
11:29:50 <lisppaste2> velco pasted "fold-skip" at http://paste.lisp.org/display/34436
11:29:53 <mahogny> eew. index in a [list]? sounds like you want to have a look at Maps lokojones
11:30:22 <velco> paolino: something like this in the paste ?
11:30:52 <lokojones> what is that Cale ?
11:31:20 <Cale> lokojones: functions you might be interested in :)
11:31:29 <lokojones> umh, lets try them
11:31:38 <Cale> > elemIndex 5 [1,3,2,7,5,2,8]
11:31:39 <lambdabot>  Just 4
11:31:44 <Cale> > elemIndex 5 [1,3,2,7,6,2,8]
11:31:45 <lambdabot>  Nothing
11:32:28 <paolino> velco, possiblly, whenever I parse it :P
11:32:42 <lokojones> Cale: yes, I saw
11:32:56 <lokojones> thx
11:33:02 <lokojones> strange names on those functions
11:33:24 <lokojones> "elemIndices" sounded spanish for me (since indices means index in spanish)
11:33:37 <Cale> indices is the plural of index
11:33:40 <lokojones> I thought it was a module you had made :)
11:33:43 <lokojones> yes?
11:33:52 <lokojones> umh, didnt know :P
11:34:38 <paolino> velco , the function gives back the number of elements eaten together with the result ?
11:34:41 <velco> paolino: it's like the fold function takes the entire tail of the list and returns a pair of value and how many elements it has consumed, in the example wrapped in maybe if it failed.
11:34:44 <velco> yes
11:35:10 <velco> s/maybe/Maybe/
11:35:38 <paolino> mmhh the ensureLength is very expensive
11:35:56 <fasta> Cale: Is there any way I can get runContT (callCC $ \abort -> mapM_ (\x-> abort False) <some list>) or something like it to work?
11:36:27 <velco> paolino: maybe it's not needed at all
11:36:35 <syntaxfree> who wrote this?
11:36:36 <syntaxfree> http://haskell.org/haskellwiki/IO_inside
11:36:38 <lambdabot> Title: IO inside - HaskellWiki
11:36:39 <syntaxfree> I'd like to give credit.
11:36:51 <lokojones> how do I convert a Just Int to a Int
11:36:55 <fasta> I want to abandon a computation at some point, but I don't get it to work.
11:36:56 <velco> paolino: one ought to trust the length that function claims to have consumed
11:36:56 <lokojones> ?
11:37:11 <velco> > fromJust $ Just 1
11:37:13 <lambdabot>  1
11:37:14 <allbery_b> pattern matching
11:37:40 <allbery_b> (fromJust only if you're certain you won't be handed Nothing, or if that should raise an exception)
11:37:40 <lokojones> thx velco :)
11:38:00 <seliopou> > fromJust Nothing
11:38:01 <lambdabot>  Add a type signature
11:38:14 <seliopou> > fromJust (Nothing :: Maybe Int)
11:38:15 <lambdabot>  Exception: Maybe.fromJust: Nothing
11:38:17 <lokojones> in what module does fromJust come?
11:38:22 <seliopou> Data.Maybe
11:38:33 <lokojones> :)
11:38:38 <augustss> fromJust is another function that should be discouraged
11:38:48 <lokojones> why?
11:38:48 <augustss> it can fail
11:38:55 <mikojiba> ok... it's unfortunately not the end. So I use mapM (\_ -> getLine) [1..n] which has IO [[Char]] as return type
11:38:58 <nostrademons> so ban head & tail too?
11:39:02 <augustss> yes
11:39:09 <allbery_b> case val of Just x -> x; Nothing -> 0
11:39:20 <augustss> or use fromMaybe
11:39:21 <mikojiba> and I would like to pass this result to a function which takes [[Char]] and not IO [[Char]] as input
11:39:23 <augustss> or maybe
11:39:25 <bd_> :t fromMaybe
11:39:26 <lambdabot> forall a. a -> Maybe a -> a
11:39:39 <allbery_b> ?src fromMaybe
11:39:40 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
11:39:47 <augustss> @type maybe
11:39:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:39:53 <augustss> @src maybe
11:39:53 <lambdabot> maybe n _ Nothing  = n
11:39:53 <lambdabot> maybe _ f (Just x) = f x
11:40:06 <mikojiba> how could I do that ?
11:40:19 <nostrademons> > maybe 0 id (Just 4)
11:40:20 <lambdabot>  4
11:40:22 <Cale> Prelude Control.Monad.Cont> runContT (callCC $ \abort -> mapM_ (\x -> abort False) [1,2,3] >> return True) print
11:40:22 <Cale> False
11:40:29 <nostrademons> > maybe 0 id (Nothing)
11:40:31 <lambdabot>  0
11:40:33 <Cale> fasta: like that?
11:40:39 <allbery_b> mikojiba: read YAHT to learn how to use IO
11:41:10 <mikojiba> it's already done, i try to not asking question before reading doc
11:41:20 <allbery_b> short answer:  do x <- funcThatReturnsStringList; return (somePureFunc x)
11:41:22 <fasta> Cale: yes, like that
11:41:32 <mikojiba> but I don't understand all the tutorials about IO
11:41:41 <mikojiba> or not fully
11:41:41 <fasta> Cale: I have no idea why it didn't work for me, though.
11:43:20 <klapmuetz> this might have been asked before... but what was the best haskell mode for emacs again?
11:43:21 <fasta> There's a bug in Emacs mode, btw.
11:43:35 <fasta> print shows as print::Show a=> IO ()
11:43:55 <klapmuetz> I read about two competing modes out there
11:47:55 <Syzygy-> ?index print
11:47:55 <lambdabot> System.IO, Prelude
11:48:24 <bakert> How do you feel about records?  Do you like them?  Do you use them?
11:48:59 <nostrademons> I think any language that doesn't have them is broken for real-world use, IMHO
11:49:21 <bakert> Would you use one for something like the state of a card game (who is first to play, what cards are in the pack, what in which hands, etc.)?
11:49:23 <mbishop> Hello nostrademons, I recognize you from reddit :)
11:49:43 <nostrademons> hey martinbishop, I recognize you from Reddit too.  and several others in here too
11:50:01 <augustss> any LaTeX wizards here?  I'm trying to use the Monad Reader document class, but it doesn't define the tabular environment.  Where can I find it?
11:50:16 <shapr> I think kosmikus wrote it.
11:50:18 <nostrademons> bakert: yes.  basically any data structure where you expect to be adding fields frequently
11:50:50 <bakert> Have you ever used the "state monad", whatever that is?  I've heard it being bandied about.  Perhaps I ought to look into that?
11:50:53 <shapr> augustss: If you mean TMR the publication, kosmikus wrote the LaTeX stuff, he's probably the person to ask.
11:51:14 <augustss> shapr: yes, I do
11:51:21 <syntaxfree> @spell impureness
11:51:22 <lambdabot> impureness
11:51:24 <syntaxfree> @spell impurity
11:51:25 <lambdabot> impurity
11:51:31 <syntaxfree> which one do I want? : (
11:51:43 <syntaxfree> (to say Erlang is not 'pure' in a Haskell sense)
11:51:55 <augustss> impure
11:52:08 <mbishop> or "Erlang is not pure" :P
11:52:11 <nostrademons> bakert: yep, all the time.  you still need records, because the State monad stores a single type (often a tuple or record).  the ST monad may be useful too
11:52:16 <qwr> mikojiba: read monad tutorials if you want to understand why the IO is like it is
11:52:20 <syntaxfree> I want "impureness" or "impurity".
11:52:24 <syntaxfree> Which one?
11:52:27 * allbery_b would rephrase to avoid thosr two words
11:52:35 <LordBrain> how is erlang impure?
11:52:37 <syntaxfree> I want one of those.
11:52:42 <bakert> impurity is definitely preferable to impureness.
11:52:45 <nostrademons> I'd say impurity...
11:52:45 <syntaxfree> I just want grammar advice, please : )
11:52:46 <bakert> as a word, i mean.
11:52:51 <LordBrain> i dont know erlang
11:52:54 <bakert> gramatically speaking.
11:53:00 <allbery_b> or possibly non-"pure"-ness to make it clear I'm not talking abotu the usual meaning
11:53:04 <augustss> syntaxfree: we are giving grammar advice: avoid those words
11:53:20 <nostrademons> googlefight say impurity: http://googlefight.com/index.php?lang=en_GB&word1=impurity&word2=impureness
11:53:22 <bakert> i know what augustss is saying though
11:53:23 <lambdabot> Title: Google Fight : Make this fight with googleFight impurity VS impureness, http://tinyurl.com/y99m92
11:53:57 <dom> allberry_b thanks for your response on fps
11:54:00 <lisppaste2> glguy pasted "MaybeT for fasta" at http://paste.lisp.org/display/34438
11:54:14 <syntaxfree> I think "Ringfinger" by Nine Inch Nails is a song about Erland and ML.
11:54:15 <bakert> nostrademons, thanks for your thoughts.
11:54:26 <allbery_b> you'e welcome
11:54:44 <syntaxfree> "You give me the reason / You give me control / I gave you my purity / and my purity you stole / did you think I wouldn't recognize / this compromise / am I just too stupid to realize?"
11:54:59 <Syzygy-> ./~ You are a pirate! ./~
11:55:01 * allbery_b still thinks that issue points up some shortcomings in cabal that ought to be addressed somehow
11:55:14 <paolino> velco:
11:55:15 <paolino> scanSkip z _ [] = []
11:55:15 <paolino> scanSkip z f xs =
11:55:15 <paolino>   let (v,n) = f z xs in
11:55:15 <paolino>     v:scanSkip v f (drop n xs)
11:55:51 <velco> paolino: ok
11:55:58 <allbery_b> the ideal dependency would be (base = 1.* and fps > 0.7) or base >= 2.0 -- except I'm also leery of claiming comptibility with all future major versions of base
11:55:58 <bakert> Anyone know a good explanation of the State monad or the ST monad, or both?  Google results are mixed.
11:56:35 <velco> paolino: for a basic thing, my example was geared towards possiblity of errors in the input, that's why it was more verbose
11:56:41 <glguy> ST enforces a sequential evalutation enabling you to use mutable datatypes
11:57:10 <velco> paolino: say, decoding multu-byte string, which my end abruptly inside a mb sequenc :)
11:57:17 <allbery_b> (base = 1.*, fps >= 0.7); base = 2.x -- ? uses , for and, ; for or
11:57:26 <bakert> glguy, i'm not sure that's what i want then.  i am modelling an all-computer game of cards rather than with human beings (for now, at least).
11:57:40 <nostrademons> the Haddock docs are: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
11:57:42 <lambdabot> http://tinyurl.com/yy2zqk
11:57:43 <bakert> so it is deterministic except for the shuffle.
11:57:48 <nostrademons> and: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
11:57:50 <lambdabot> http://tinyurl.com/yy4aqu
11:57:58 <glguy> bakert: a common use for State might be: you have a random number generator that gets used a lot in your computation
11:58:04 <glguy> but you dont' watn to explicitly pass the value around
11:58:16 <glguy> but you need to be able to update it after each use
11:58:39 <nostrademons> I just used State for a type inference monad...
11:58:46 <paolino> velco , I suppose threading the length of the remaining list was a choice
11:58:51 <bakert> glguy, i see.  i think i've solved that problem already, actually.  so maybe i don't need these boys yet.
11:58:57 <nostrademons> and also to hold the environment for an interactive interpreter (well, StateT Env IO...)
11:59:09 <bakert> the problem i am having is a kind of deep pattern matching going on in order to do anything.
11:59:51 <bakert> i pass a "State" around but then I need to look into the head of a field of one of it's fields for the first player's hand.
12:00:09 <paolino> www.nomaware.com/monads/html/statemonad.html
12:00:26 <bakert> Perhaps I just need some "extractor" functions to give me quick access or more layers of stuff.  Or something.  Hmm .. me not quite a functional guru yet!
12:00:26 <glguy> ?type gets
12:00:28 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
12:00:38 <nostrademons> records give you automatic accessor functions
12:00:53 <bakert> nostrademons, right but my pattern matching ends up looking like this:
12:01:18 <SyntaxNinja> y0
12:01:20 <bakert> putDown state@State { State.players = (p:ps) } =
12:01:20 <bakert>     state { State.players = (np:ps) } where
12:01:25 <ndm> yo SyntaxNinja
12:01:34 <bakert> and then loads of mucking about after the "where"
12:01:35 <shapr> y0 SyntaxNinja!
12:02:06 <syntaxfree> "jump hoops" or "jump around hoops"?
12:02:12 <SyntaxNinja> heya ndm & shapr.  How's it going?
12:02:23 <ndm> syntaxfree: jump through hoops
12:02:26 <bakert> syntaxfree, i always jump /through/ hoops
12:02:41 <bakert> although that's definitely a cliche if you are trying to avoid them.
12:02:46 <syntaxfree> thanks.
12:02:50 <syntaxfree> it's a quasi-quote.
12:03:00 <ndm> SyntaxNinja: neat, go b ack to work properly tomorrow, so trying to pretend i've done 3 weeks worth of work...
12:03:15 <syntaxfree> people have specifically said that many times, so I don't choose a specific quotation.
12:03:20 <bakert> (see, Martin Amis' The War Against Cliche)
12:04:19 <bakert> (well, just the title, really!)
12:04:42 <emk> I'm flipping through "Comprehending Queries" (Grust 1999), and wondering if this is conceptual framework behind HaskellDB...
12:04:49 <psykotic> bakert: or orwell's politics and the english language
12:05:16 <SyntaxNinja> ndm: instead of playing pool and going for long walks or whatever you've been doing for 3 weeks?
12:05:32 <ndm> SyntaxNinja: instead of getting drunk and lying in bed watching tv
12:06:27 <SyntaxNinja> ndm: ahh.
12:06:38 <SyntaxNinja> ndm: tv sucks, you shouldn't do that.
12:06:45 <psykotic> ls
12:07:01 <ndm> SyntaxNinja: and online stuff, simpsons, prison break etc. - nice and relaxing
12:07:09 * psykotic waits for a directory listing to appear.
12:07:16 <ndm> @ls
12:07:33 <SyntaxNinja> ndm: sounds fun :)
12:09:35 <syntaxfree> is lazy evaluation conceptually possible in a non-rereferentially transparent context?
12:10:12 <emu> its conceptually possible, but the results will be mighty interestin
12:10:23 <paolino> if you want random numnbers it's the way to go
12:10:24 <johnnowak> syntaxfree: my guess would be not in any useful way
12:10:33 <emu> any language with closures can do that, sorta
12:10:52 <johnnowak> syntaxfree: one of the reasons for lazy eval in haskell was that it would require haskell to remain pure
12:11:24 <syntaxfree> emu: People talk of "closures" often in non-purely functional settings.
12:11:37 <syntaxfree> Closures are not really the same as curried functions, are they?
12:11:48 <syntaxfree> The cannonical examples look like they are.
12:11:49 <emu> "preservse the lexical environment where the function was defined"
12:12:03 <syntaxfree> ?
12:12:11 <allbery_b> closures can be used to implement curried functions, but they're arguably more general
12:12:18 <emu> it's related, in that a curried function is defined in the lexical environment of some outer function: \x -> \y ->
12:12:36 <syntaxfree> um, does Haskell have closures, in any useful sense/
12:12:43 <psykotic> uh, of course
12:12:47 <emu> yes. you know what i mean by "free variable" right?
12:12:58 <syntaxfree> I'm not sure I do.
12:13:17 <emu> a free variable is any that is not bound in the expression somehow: \x -> y -- y is free
12:13:28 <lisppaste2> Hunter pasted "Diary" at http://paste.lisp.org/display/34440
12:13:41 <emu> a closure captures all free variables and gives them bindings from the lexical environment.
12:13:42 <paolino> something you don't know where the hell it was defined
12:14:09 <psykotic> allbery_b, depends on what you mean by "more general". you can lambda lift a function with free variables to a combinator and then curry by its lifted free variables to get something corresponding to its closure.
12:14:35 <Anon4888> Closure is more of an implementation concept, right?
12:14:58 <psykotic> technically speaking, but people use it to describe something implementation agnostic.
12:15:39 <psykotic> in principle you could do everything with substitutions and get the same semantics.
12:16:26 * paolino would like to know what is free in "free variables" 
12:16:29 <psykotic> (aside: there are actually 'calculi of explicit substitutions' in which closures are first-class object language entities rather than meta-language artifacts)
12:17:22 <Hunter> no hlp?
12:17:57 <emu> the lambda calculus is described in terms of substitutions
12:18:36 <matthew-_> well, it gets reduced by substitution
12:18:53 <matthew-_> but then functional languages are, on the whole, term rewriting systems anyway
12:18:53 <psykotic> emu: in a calculus of explicit substitutions, the substitutions are represented within the object language. basically a term can carry an environment with it.
12:18:58 <augustss> Anon4888: yes, closures are normally an implementation technique.  And Haskell does not have closures.  You can use closures when implementing Haskell though.
12:19:19 <ndm> Hunter: can't see it immediately, but am taking a look
12:19:27 <emu> "closures" the term applied in this context does mean an implementation technique of associating a function pointer with an environment
12:19:28 <Hunter> ndm thanks =)
12:20:30 <ndm> Hunter: the first clause of the last equation is wrong
12:20:37 <emu> however, and i'm a bit fuzzy on this, there is a set known as the "closure" which binds all the free variables
12:20:40 <allbery_b> doesn't the first case there actually pass a Period instead of a Diary?
12:20:49 <ndm> Hunter: combineDiary x y - x and y are Period's not Diary's
12:20:55 <emu> unfortunately, last time i went looking for the reference on that, i oculdn't find it
12:21:24 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/gallery/coding/hsext/first-non-trivial.png   << haskell embedded in Pd with hs-plugins
12:21:27 <lambdabot> http://tinyurl.com/umfvz
12:22:05 <Hunter> ndm clause = first case?
12:22:19 <ndm> Hunter: 3 lines from the bottom
12:22:33 <ndm> Hunter: the overlap case where they are both : lists
12:22:53 <kosmikus> augustss: what's the problem with the TMR class?
12:23:13 <augustss> kosmikus: tabular doesn't work properly
12:23:45 <kosmikus> augustss: strange. any details?
12:23:59 <augustss> this doesnt't work: \begin{tabular}{|l|r@{.}l|}
12:24:10 <augustss> Removing | makes it work
12:24:22 <augustss> using the article class makes it work
12:24:27 <Hunter> ndm: is the overlap function wrong do you mean or do I use it wrong?
12:24:42 <ndm> Hunter: the right hand side, next to the overlap is wrong
12:24:54 <ndm> Hunter: because you pass period's to the function, rather than diary's
12:24:55 <kosmikus> augustss: I'll run a test to see if I can reproduce the problem.
12:25:04 <allbery_b> in the case involving overlap, you reinvoke combineDiary on two Period-s, instead of two Diary-s
12:25:17 * allbery_b took too long to copyedit himself :/
12:27:48 <kosmikus> augustss: ok, I see the problem now
12:28:14 <augustss> kosmikus: good start :)
12:28:20 <Hunter> ndm: the error is in the comdi function then right?
12:29:27 <ndm> Hunter: the error is that it doesn't do what you want, where you go to fix it is your choice
12:30:06 <Hunter> ndm thanks it works now =)
12:30:17 <ndm> Hunter: cool :)
12:31:14 <allbery_b> I'm tempted to ask what you did to fix it; if you simply stuffed x and y into lists, it'll hit bottom
12:31:28 <allbery_b> (because the overlap case will reduce to itself)
12:32:25 <kosmikus> augustss: tmr.cls defines | as "short verbatim" character, so you can write |foo| for verbatim text. this seems to conflict with the use of | in a tabular header. I'm not surprised I never stumbled upon this problem, because I see vertical lines in tables as bad style ... you should be able to work around this by undefining the short verbatim meaning of | : \UndefineShortVerb{\|}
12:34:22 <augustss> kosmikus: that worked.  thanks!
12:35:24 <kosmikus> thanks for pointing out the problem.
12:38:06 <kosmikus> augustss: I'll fix this in the class file.
12:38:18 <SyntaxNinja> kosmikus: anything going on with your Haskell' writing?
12:38:40 <SyntaxNinja> dons: same question :) It was looking promising there a few weeks back with some exchanges between you & ravi, but I haven't seen anything since.
12:38:55 <kosmikus> SyntaxNinja: actually, yes. there's a mail I still haven't sent.
12:39:52 <kosmikus> SyntaxNinja: you can expect something within the next 48 hours (regarding infix type constructors)
12:40:54 <SyntaxNinja> kosmikus: sweeeet
12:41:06 <SyntaxNinja> kosmikus: how hard do you think infix type constructors are to add to the report?
12:41:55 <kosmikus> SyntaxNinja: not hard. but it affects quite a number of sections. and there are still one or two minor open questions, but I expect that they don't cause major controversy.
12:43:05 <SyntaxNinja> kosmikus: OK.  is your email meant to work on those open questions?
12:44:13 <kosmikus> also.
12:45:05 <kosmikus> it's a collection of all report sections that have to be changed and how they have to be changed, plus the open questions that I need to be answered before I can filling in any concrete details, plus suggested answers to the open questions.
12:46:08 <paolino> @type sortBy
12:46:42 <emu> the first parameter is (a -> a -> Compare)
12:47:03 <augustss> s/Compare/Ordering/
12:47:10 <emu> er, yea. i'm no bot.
12:47:13 <SyntaxNinja> kosmikus: whew, sounds great!
12:47:21 <augustss> > 1+1
12:47:22 <lambdabot>  2
12:47:29 <augustss> @type sortBy
12:47:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:48:04 <paolino> I'm on lambdabot blacklist
12:48:15 <augustss> huh?  why?
12:48:48 <paolino> or, I finished my bonus
12:49:10 <augustss> too many questions :)
12:49:17 <paolino> yep
12:49:33 <paolino> it's you are not all bots
12:49:42 <paolino> *good
12:50:23 <paolino> @type (>)
12:50:25 <lambdabot> forall a. (Ord a) => a -> a -> Bool
12:50:41 <paolino> @hoogle Ordering
12:50:42 <lambdabot> Prelude.Ordering :: data Ordering
12:50:50 <augustss> @type compare
12:50:51 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:51:05 <augustss> > compate 1 2
12:51:06 <lambdabot>   Not in scope: `compate'
12:51:10 <augustss> > compare 1 2
12:51:11 <lambdabot>  LT
12:51:35 <paolino> > compare 1.2 1.3
12:51:37 <lambdabot>  LT
12:52:07 <paolino> @instances Ord
12:52:08 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
12:52:37 <paolino> > compare LT GT
12:52:38 <lambdabot>  LT
12:53:06 <augustss> > compare EQ EQ
12:53:07 <lambdabot>  EQ
12:53:43 <Botje> > map fromEnum [LT,EQ,GT]
12:53:44 <lambdabot>  [0,1,2]
12:53:51 <Botje> i'm shocked.
12:54:10 <augustss> you are?
12:54:11 <Saizan> why?
12:54:50 <paolino> @instances Enum
12:54:52 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
12:55:03 <Botje> EQ isn't 0 for the .0000001% efficiency gain!
12:55:24 <Saizan> why should EQ be before LT?
12:55:48 <augustss> you could have LT=-1, EQ=0, GT-1
12:56:02 <augustss> but that's not what deriving(Enum) gives you
13:00:10 <mattam> @type in_l
13:00:11 <lambdabot> Not in scope: `in_l'
13:00:20 <mattam> @type inL
13:00:22 <lambdabot> Not in scope: `inL'
13:00:31 <mattam> hmmm, sum type anyone ?
13:00:40 <bd_> :t elem
13:00:42 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:00:59 <integral> mattam: Either
13:01:12 <integral> :t either
13:01:14 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
13:01:16 <integral> :t Left
13:01:18 <lambdabot> forall b a. a -> Either a b
13:01:31 <mattam> oh right Either
13:01:39 <mattam> thx
13:01:41 <integral> or your own datatype, obviously :)
13:02:53 <augustss> you can thank Mikael Rittri for it being named Either instead of something obscure :)
13:05:05 <kosmikus> augustss: what would "something obscure" have been?
13:05:28 <augustss> Sum?
13:05:48 <kosmikus> ok
13:05:52 <augustss> Coproduct?
13:06:04 <integral> that'd be a neat name
13:06:12 <kosmikus> coproduct would be nice
13:06:16 <Saizan> OR!
13:06:18 <kosmikus> I'll suggest that change for Haskell' ;)
13:06:33 <augustss> And the constructors should be I and J
13:06:48 <Botje> no way! phi and psi!
13:06:52 <integral> hmm, or scrapping it, and insisting people create their own properly named typed,  and if they want generic ops on it, use generics
13:07:21 <augustss> or just do away with all predefined data types
13:09:02 <paolino> I suggest Buttoks
13:12:05 <pbx> I'm going to learn Haskell this year, I tell myself. In order to prepay some of the karmic debt I will surely accumulate with my annoying n00b questions, I'm sharing my Plucker versions of some Haskell docs.  (Of course this will only be of interest to, like, five people, but there you go.)  http://e-scribe.com/news/322
13:12:06 <lambdabot> Title: E-Scribe News : It&#8217;s Haskell
13:12:49 <augustss> pbx: send something to the haskell mailing list
13:13:16 <pbx> augustss: OK, I'll do that when I have a moment later.
13:13:33 <bd_> pbx: Well, I know at least one person who'd be interested in those :)
13:14:13 <pbx> Cool, let me know if you find any weirdness. I haven't paged all the way through them yet.
13:14:29 <mikojiba> I've an other question : i've a succession of l <- getLine, putStr "abc" etc, which works whell under hugs or ghci
13:14:56 <ndm> mikojiba: they should both work equally well, apart from WinHugs which should work better than either
13:15:25 <mikojiba> but when compiled with ghc, the line is asked BEFORE the prompt
13:15:47 <ndm> mikojiba: look at the hSetBuffering command, thats likely to be where the issue is
13:16:51 <mikojiba> yes, it seems to be a buffer problem, thanks
13:21:26 <paolino> mmmh, I'm using accum to modify every element of a DiffArray. I want the accumulating function to have read access to the array. Should I pass it through as a free variable or put the array in every element of the association list ?
13:24:53 <sjanssen> I'd do something like: let a = accum ... stuff mentioning a ...
13:27:12 <paolino> that would give access to the newest version of a?
13:27:35 <sjanssen> there is only one version of a
13:28:05 <sjanssen> but yes, a is bound to the Array you are creating with accum
13:28:12 <bd_> That's safe only if the array is boxed, I think.
13:28:22 <augustss> yes
13:28:40 <augustss> and accessed in the "right" way
13:29:13 <bd_>   
13:29:14 <bd_> What is Second Life?ShowcaseBusiness PartnersDevelopersCommunityBlogSupport
13:29:14 <bd_>    
13:29:14 <bd_> The Official Blog of Linden Lab
13:29:14 <bd_> Troublesome Teleports
13:29:17 <bd_> err
13:29:19 <bd_> mispaste
13:29:24 <paolino> accum changes the array on every application of f
13:29:35 * bd_ needs to figure out how to disable that "feature" of the synaptic drive
13:29:58 <paolino> and gives out the full changed array
13:30:12 <augustss> paolino: but using 'let a = accum ...' will give you access to the last version of a inside
13:30:21 <paolino> uh
13:30:33 <paolino> that's black magic
13:30:36 <augustss> last, not latest
13:30:48 <augustss> it is magic :)
13:31:01 <paolino> no it is black
13:31:06 <paolino> :)
13:31:17 <sjanssen> that is just laziness at work
13:31:29 <augustss> laziness works magic
13:32:13 <paolino> I tell you , I don't believe it, I have to touch it
13:33:48 <augustss> > let a = array (0,10) [ (i, if i < 2 then 1 else a!(i-1) + a!(i-2)) | i <- [0..10]] in a
13:34:03 <augustss> @bot
13:34:03 <lambdabot> :)
13:34:05 <newsham> someone should write a small silc lib for haskell
13:34:11 <vincenz> lc?
13:34:12 <vincenz> silc
13:34:14 <vincenz> ?
13:34:23 <augustss> > let a = array (0,10) [ (i, if i < 2 then 1 else a!(i-1) + a!(i-2)) | i <- [0..10]] in a
13:34:23 <newsham> http://silcnet.org/software/developers/toolkit/
13:34:25 <lambdabot>  array (0,10) [(0,1),(1,1),(2,2),(3,3),(4,5),(5,8),(6,13),(7,21),(8,34),(9,55...
13:34:25 <lambdabot> Title: SILC Secure Internet Live Conferencing
13:35:09 <paolino> ah
13:35:15 <paolino> :D
13:35:20 <ClaudiusMaximus> > let fib (a:b:cs) = a:(fib (b:(a+b):cs) in fib (0:1:[])   -- how is it any different from laziness with lists?
13:35:21 <lambdabot>  Parse error
13:35:33 <newsham> also lambdabot should use it :)
13:35:38 <ClaudiusMaximus> > let fib (a:b:cs) = a:(fib (b:(a+b):cs)) in fib (0:1:[])   -- oops
13:35:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:35:53 <bd_> > let fib@(_:t) = 1:1:zipWith (+) fib t
13:35:53 <lambdabot>  Parse error
13:35:55 <augustss> ClaudiusMaximus: it's not different, really.  just more unfamiliar with arrays
13:36:01 <bd_> > let fib@(_:t) = 1:1:zipWith (+) fib t in fib
13:36:02 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:36:35 <sjanssen> ClaudiusMaximus: the list is infinite, but the array is finite
13:37:07 <ClaudiusMaximus> i guess...
13:37:44 * paolino starts like lazyness .....
13:37:54 <augustss> > let fib@(_:t) = take 10 $ 1:1:zipWith (+) fib t in fib
13:37:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:38:00 <sjanssen> we have the "nofib" test suite, because fibonacci programs are supposedly trivial.  I'd like to see an "onlyfib" tutorial, that teaches every Haskell concept with fibonacci calculation
13:39:04 <paolino> at least every one abandon haskell learns fibonacci before
13:39:25 <augustss> sjanssen: it might give people the wrong impression of haskell
13:39:41 <_frederik_> hello, so ... fromEnum (2^40 :: Integer) == (0 :: Int)
13:39:46 <_frederik_> what am i to do?
13:40:02 <augustss> _frederik_: don't use fromEnum?
13:40:06 <bd_> :t fromEnum
13:40:08 <lambdabot> forall a. (Enum a) => a -> Int
13:40:32 <_frederik_> what if i want lists with more than 2^32 entries?
13:40:34 <augustss> fromEnum has the wrong type in Haskell
13:40:40 <_frederik_> 2^31 even
13:40:46 <newsham> sjanssen: http://www.willamette.edu/~fruehr/haskell/evolution.html ?
13:40:47 <lambdabot> Title: The Evolution of a Haskell Programmer
13:40:48 <augustss> _frederik_: lists of what?
13:41:08 <bd_> _frederik_: Good luck indexing a list of 2^32 entries in reasonable time :)
13:41:29 <_frederik_> ok so i don't really need lists - i was just using enum because it seemed right
13:41:42 <_frederik_> you're saying i should just create my own class
13:41:48 <_frederik_> which is like Enum but different
13:41:50 <augustss> _frederik_: probably not
13:41:52 <bd_> Well, what do you need fromEnum for?
13:41:54 <seliopou> > (fromToEnum 0 (2^31)) !! 2^31
13:41:56 <lambdabot>   Not in scope: `fromToEnum'
13:42:01 <_frederik_> i can't remember
13:42:04 <_frederik_> it's for my vector library
13:42:08 <paolino> this mechanism of using different versions of the same variable in the same expression is started having that variable also on the lhs ?
13:42:09 <newsham> > (foldr (*) 1 . enumFromTo 1) 5
13:42:10 <lambdabot>  120
13:42:15 <augustss> _frederik_: [1..] works fine for Integer
13:42:27 <newsham> > (foldr (*) 1 . enumFromTo 1) !! 5
13:42:28 <lambdabot>      Expecting a function type, but found `[a]'
13:42:28 <lambdabot>       Expected type: [a]
13:42:28 <lambdabot>     ...
13:42:31 <seliopou> > (enumFromTo 0 (2^31)) !! 2^31
13:42:32 <lambdabot>  2147483648
13:42:49 <_frederik_> hmm
13:42:51 <seliopou> > 2^31
13:42:53 <lambdabot>  2147483648
13:42:59 <bd_> paolino: There are no 'versions' of a variable - a variable is bound to the same value for its entire lifetime
13:43:01 <augustss> [0..] !! (2^31)
13:43:16 <augustss> > [0..] !! (2^31)
13:43:17 <lambdabot>  Exception: Prelude.(!!): negative index
13:43:21 <newsham> > (snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))) 5
13:43:22 <lambdabot>   Not in scope: `n'
13:43:22 <augustss> bah
13:43:35 <newsham> > let n = 5 in snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))
13:43:36 <lambdabot>  120
13:43:44 <_frederik_> i forget why but Ix is not enough for my needs
13:43:58 <_frederik_> but even Ix also has that problem
13:43:59 <newsham> > (fix snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))) 5
13:44:00 <lambdabot>   Not in scope: `n'
13:44:07 <augustss> _frederik_: well, then Enum is no help.  You need you own class
13:44:20 <newsham> > (fix (\f n -> if (n==0) then 1 else n * f (n-1))
13:44:20 <lambdabot>  Parse error
13:44:21 <seliopou> :t genericIndex
13:44:23 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
13:44:31 <_frederik_> crap
13:44:34 <newsham> > (fix (\f n -> if (n==0) then 1 else n * f (n-1))) 5
13:44:35 <lambdabot>  120
13:44:41 <seliopou> genericIndex [0..] (2^64 :: Word64)
13:44:45 <seliopou> > genericIndex [0..] (2^64 :: Word64)
13:44:47 <lambdabot>  0
13:44:51 <seliopou> D:
13:44:56 <bd_> heh
13:44:57 <_frederik_> why aren't Enum and Ix updated in the standard to use Integer rather than Int?
13:45:13 <bd_> _frederik_: efficiency I think
13:45:18 <seliopou> @src genericIndex
13:45:19 <lambdabot> Source not found. Take a stress pill and think things over.
13:45:22 <augustss> > [0..] `genericIndex` (2^10)
13:45:23 <lambdabot>  1024
13:45:27 <bd_> Int is a machine integer, Integer is software arbitrary-precision
13:45:35 <bd_> or, well, unlimited range anyway
13:45:58 <bd_> [so, if you need to index lists of 2^63 elements ... "efficiently"... you can use a 64-bit cpu :)]
13:45:59 <_frederik_> yeah
13:46:11 <_frederik_> not 2^63 hehe
13:46:39 <paolino> > let a = array (0,10) [ (i, if i < 2 then 1 else a!(i-1) + a!(i-2)) | i <- [0..4]] in a
13:46:41 <_frederik_> well it could even be more than 2^63 with sparse vectors
13:46:41 <lambdabot>  Exception: (Array.!): undefined array element
13:47:04 <seliopou> > genericIndex [0..] (2^63 :: Word64)
13:47:09 <lambdabot> Terminated
13:47:15 <_frederik_> to look up a particular element, currently one would call fromEnum
13:47:22 <seliopou> > genericIndex [0..] (2^50 :: Word64)
13:47:22 <augustss> seliopou: a bit optimistic ;)
13:47:27 <lambdabot> Terminated
13:47:28 <seliopou> Yes I am
13:47:33 <bd_> oh, I see
13:47:33 <seliopou> > genericIndex [0..] (2^40 :: Word64)
13:47:37 <lambdabot> Terminated
13:47:42 <seliopou> :(
13:48:07 <bd_> @hoogle Enum a => a -> Integer
13:48:08 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
13:48:08 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
13:48:12 <paolino> > let a = array (0,10) [ (i, if i < 2 then 1 else a!(i-1) + a!(i-2)) | i <- [0..4]] in a!4
13:48:14 <lambdabot>  5
13:48:15 <seliopou> > genericIndex [0..] (2^32 :: Word64)
13:48:19 <lambdabot> Terminated
13:48:20 <_frederik_> surely the optimizer knows how to de al with that :)
13:48:27 * seliopou gives up
13:48:41 * _frederik_ writes a new class
13:49:01 <augustss> _frederik_: it's not that easy to optimize
13:49:18 <augustss> but using Integer would have been cleaner
13:50:30 <_frederik_> maybe not easy for you
13:50:35 <_frederik_> hehe j/k
13:50:50 * vincenz peers at _frederik_ 
13:50:55 <vincenz> _frederik_: you obviously don't know who augustss is
13:51:23 <augustss> _frederik_: you're right.  it's not easy for me :)
13:51:25 <bd_> @check \x -> (succ $ pred x) == (x :: Double)
13:51:26 <lambdabot>  Falsifiable, after 4 tests: -0.33333333333333337
13:51:48 <paolino> I don't understand how can accum pass  the *right* array to f in
13:51:49 <paolino> let a = accum f a [(i,a) | i <- [1..10]]
13:51:58 <orbitz> hello
13:52:36 <lekro> does anyone here use the ghc-6.6 package from fink on Mac OS X? I have a problem with compiling: "ghc --make Main" gives: /usr/bin/ld: can't locate file for: -lHSbase
13:52:39 <_frederik_> "All articles  Recent articles  Results 1 - 10 of about 497 for Lennart Augustsson."
13:52:41 <bd_> paolino: accum builds an array of the proper length in which all of the array elements are a deferred computation calling f
13:52:43 <_frederik_> OMG!
13:52:55 <bd_> paolino: f is only invoked when you actually pattern match the values in the array
13:53:18 <lekro> I tried adding the fink-path manually: ghc --make Main -L/sw/lib/ghc-6.6 (or just -L/sw/lib), but this doesn't change anything
13:53:27 <ctkrohn> lekro: I tried building ghc-6.6 with fink, but sadly I only had success with darwinports
13:53:37 <ctkrohn> lekro: I don't remember exactly the errors I got, but that looks familiar
13:53:41 <_frederik_> so should i use Integer, or should I quantify over Integral?
13:53:42 <ctkrohn> lekro: Are you running 10.3 or 10.4?
13:53:52 <lekro> ctkrohn: 10.4
13:54:23 <ctkrohn> lekro: there are binary packages for 10.4
13:54:26 <lekro> ctkrohn: oh, DarwinPorts seems to have only 6.5
13:55:20 <lekro> ctkrohn: building ghc-6.6 with fink wasn't a problem (only that it took many many hours...), and ghci works fine, too
13:55:33 <ctkrohn> hmm
13:55:45 <ctkrohn> what is your LD_LIBRARY_PATH
13:55:46 <lekro> only compiling gives me this linker error
13:56:13 <lekro> "echo $LD_LIBRARY_PATH" prints an empty line...
13:56:15 <_frederik_> ... in the methods of my new class. also, should datatypes have a type parameter which is Integral, or should they be existential boxes of Integral, or should they just be Integer?
13:56:31 <_frederik_> (ones which were Int before)
13:56:46 <ctkrohn> lekro: not sure if this will fix it, but you could try something like running export LD_LIBRARY_PATH=/usr/local/lib/ghc-6.6 or wherever your ghc-6.6 lib directory is
13:56:50 <augustss> _frederik_: Integral would be cool.  if it works out nicely
13:56:59 <paolino> bd_ , say f want to read the same element of  a  ( which is given as second argument by definition of accum)  which is redefining. Which value it will find ?
13:57:04 <ctkrohn> if that doesn't work I'm not sure what I'd do, you can try the binary packages I guess... my friend runs 10.4 and those work for him
13:57:18 <_frederik_> augustss: but existential boxes of integral are probably no faster than Integer, right? so i have to introduce type parameters to make it worthwhile
13:57:22 <bd_> paolino: it'll find its own return value, which may ot may not be a loo
13:57:25 <bd_> p
13:57:31 <_frederik_> augustss: for the data-types...
13:57:35 <lekro> ctkrohn: i've just tried "LD_LIBRARY_PATH=/sw/lib/ghc-6.6/ ghc --make Main", still the same error
13:57:37 <augustss> _frederik_: existentials would be annoying, I think
13:57:37 <bd_> eg, this is valid:
13:58:01 <bd_> > let f \(x, _) = (1, succ x); r = f r in r
13:58:01 <lambdabot>  Parse error
13:58:05 <ctkrohn> lekro: hm... yeah beyond that I'm not sure why it won't work
13:58:07 <ctkrohn> sorry
13:58:09 <bd_> > let f (x, _) = (1, succ x); r = f r in r
13:58:10 <lambdabot>  Exception: <<loop>>
13:58:12 <bd_> err
13:58:26 <bd_> > let f x = (1, succ $ fst x); r = f r in r
13:58:27 <lambdabot>  (1,2)
13:58:30 <bd_> there we go
13:58:44 <bd_> paolino: it's the same sort of principle with the arrays; a function can depend on its own return value if you're careful
13:58:46 <augustss> > let f ~(x, _) = (1, succ x); r = f r in r
13:58:47 <lambdabot>  (1,2)
13:59:13 <augustss> paolino: but it's subtle, and easy to get wrong
13:59:22 <_frederik_> augustss: hrm. i don't know how well using Integral in the datatypes would work. in the new versions of stuff like fromEnum it should be fine though
13:59:31 <paolino> but that is not what I want
13:59:40 <lekro> ctkrohn: what I find strangest is that even "-L/sw/lib/ghc6.6" can't convince ld to find the HSbase.o (it does notice the -L, though, because an invalid path gives another ld-warning)
13:59:46 <bd_> paolino: what do you want then :)
14:00:24 <augustss> _frederik_: why not start with Integer and generalize later?
14:00:34 <_frederik_> ok
14:00:35 <paolino> I want it to read the old array on elements which have not been *just* defined (which is very imperative :/ )
14:01:10 <bd_> oh, I see
14:01:16 <augustss> paolino: then you'll have to do it monadically, methinks
14:01:20 <bd_> hmm
14:01:32 <_frederik_> by the way, nobody else has written a class for finite domains yet, have they? e.g. 'domain :: [a]' is one member
14:01:34 <bd_> Well you could fold over the diffarray or something
14:01:54 <paolino> ok, accum is not the right function
14:02:07 <augustss> paolino: have you considered STArray?
14:02:16 <paolino> I fear it
14:02:20 <bd_> @hoogle (forall s. ST s (STArray s i e)) -> DiffArray i e
14:02:21 <lambdabot> Did you mean: Forall S. ST s (STArray s i e) -> DiffArray i e
14:03:20 <bd_> hmm, hoogle doesn't support forall?
14:03:37 <sjanssen> bd_: correct
14:03:43 <bd_> [and I have no idea if that function exists, but it should]
14:04:16 <paolino> I will inject changes
14:04:25 <paolino> one by one
14:04:42 <sjanssen> bd_: see runSTArray
14:04:54 <bd_> sjanssen: yes, but that gives you a normal Array
14:04:56 <bd_> not a DiffArray
14:05:11 <bd_> ... right?
14:05:19 <sjanssen> you are correct
14:05:56 <bd_> two primitives would be useful: one to convert STArray RealWorld to IOArray, and one to pack IOArray in a DiffArray
14:06:04 <sjanssen> there should be an easy way to convert Array to DiffArray
14:06:09 <lekro> ctkrohn: oops... I found the error, now everything seems to work :)
14:06:27 <bd_> the former would be safe, even...
14:06:55 <lekro> ctkrohn: there was another package "ghc-dev" in fink, that wasn't yet installed but "archived". I only had to install this package
14:07:09 <bd_> oh, there's unsafeFreeze for the latter... probably could use a specialisation though
14:08:23 <bd_> [though,I suppose unsafeFreeze's semantics would not allow the underlying array to be changed from pure code too]
14:08:36 * bd_ goes afk
14:08:50 <ctkrohn> lekro: nice
14:10:15 <dmhouse> Anyone seen any example of modelling exceptions using continuations/
14:10:22 <dmhouse> Or could explain briefly how it's done?
14:12:02 <vincenz> sure
14:12:22 <vincenz> join #oasis and I'll do a gamble, I have more or less an idea on how it's done
14:28:25 <Botje> @pl \x y -> (snd x == snd y)
14:28:26 <lambdabot> (. snd) . (==) . snd
14:29:01 <mikojiba> good bye
14:35:02 <dcoutts> yay! glade 3.1 now has a nicer UI, no more clutter of little windows
14:37:14 <seliopou> :t ($) . ($)
14:37:15 <lambdabot> forall a b. (a -> b) -> a -> b
14:37:27 <seliopou> :t ($) . (.)
14:37:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:37:47 <norpan> how are things on the haskell ide front?
14:38:20 <dmhouse> dcoutts: score! :)
14:39:07 <dcoutts> quite :-)
14:40:22 <tuukkah> do you people know if it's possible to use ffi to create so libraries that can be loaded in ordinary c applications?
14:40:41 <dcoutts> tuukkah, yes, foreign export
14:41:27 <tuukkah> dcoutts, can you point to an example of building such a beast because i'm not getting the build commands right etc
14:42:02 <norpan> can you do it under linux nowadays?
14:42:34 <dcoutts> tuukkah, you can't build a .so though
14:42:51 <dcoutts> but the ordinary .o file will end up with that exported C symbol
14:43:01 <dcoutts> so you can statically link with some other C code
14:43:04 <Mitar> why this does not work: moveBackward x (x:ls) = ... (i want that the first argument and the header are equal) ...
14:44:15 <tuukkah> dcoutts, could i perhaps have a c wrapper that statically links the .o file and is itself dynamically compiled?
14:44:43 <dcoutts> tuukkah, no
14:44:43 <tuukkah> dynamically linked to the main application, i mean
14:45:01 <tuukkah> i see :-(
14:45:06 <Igloo> Mitar: You need to give them different name and use an   | x == y   guard
14:45:28 <Mitar> what is better, to use the quard or the if sentence?
14:45:47 <lisppaste2> dmhouse pasted "Exceptions with Cont" at http://paste.lisp.org/display/34450
14:48:20 <kowey> Mitar: it's hard to tell... you sort of get a feel for this as you code, and a lot of it depends on context
14:48:30 <Mitar> ok
14:48:37 <kowey> sometimes if you have a thicket of if then elses, and using guards helps to clear it up
14:48:58 <kowey> but there may be cases where the if statement is more readable
14:49:00 <Mitar> under where should the | be put? what is the normal idendation?
14:49:47 <Mitar> at the end of the function name?
14:50:12 <kowey> it depends also (under seems to be pretty common, though, especially for short functions)
14:50:15 <glguy> ?index getCC
14:50:56 <kowey> i would avoid using tabs, in any case (spaces are more predictable... and you can configure your text editor to use spaces w/ the tab key)
14:51:41 <dmhouse> glguy: not in the standar libs, unfortunately.
14:52:19 <Mitar> i am using spaces ... yes, i noticed that tabs are not really portable
14:52:47 <kowey> otherwise, for these sort of questions, i'd recommend reading lots of code, and learning by osmosis
14:58:10 <ClaudiusMaximus> tuukkah: http://devel.goto10.org/filedetails.php?repname=maximus&path=%2Fhsext%2FMakefile&rev=0&sc=0
14:58:13 <lambdabot> Title: DEVEL.GOTO10.ORG - maximus - Rev 150 - /hsext/Makefile, http://tinyurl.com/yxz4m7
15:01:36 <Mitar> hmm, "ghc-6.6: unrecognised flags: -Wall -Werror" ?
15:02:03 <Igloo> Where did the flags come from?
15:02:31 <Igloo> Is it quoted so it is seen as a single flag, for example?
15:02:56 <Mitar> hmm, I am using Eclipse plugin for development
15:03:08 <Mitar> I setup additional arguments for the compiler
15:03:20 <Mitar> probably plugin bug
15:03:42 <goltrpoat> those look like gcc flags
15:03:55 <Mitar> but they are ghc flags :-)
15:03:55 <ClaudiusMaximus> > 5 * 60 * 25 * 768 * 576 * 3
15:03:57 <lambdabot>  9953280000
15:04:11 <Mitar> OK, if I specify only one flag it works, so it is a bug
15:05:03 <tuukkah> ClaudiusMaximus, what kind of situation is that an example of? it can't be the impossible, or can it ?-)
15:05:20 <Cale> > 3 * 3 * 3 * 3 * 7 * 11 * 13 * 19 * 37 * 52579 * 333667
15:05:22 <lambdabot>  999999999999999999
15:05:46 <ClaudiusMaximus> tuukkah: http://claudiusmaximus.goto10.org/gallery/coding/hsext/first-non-trivial.png  haskell loaded as a shared library in a C app
15:05:49 <lambdabot> http://tinyurl.com/umfvz
15:05:56 <dmhouse> Cale: hehe :)
15:06:28 <ClaudiusMaximus> tuukkah: using the superfine hs-plugins to load more haskell code on the fly
15:07:01 <goltrpoat> oh, so i threw together an arithmetic coder in under 25 lines, not counting imports.  could be a useful snippet for the wiki, unless it's been done already.  http://vandreev.wordpress.com/2007/01/07/arithmetic-coding/
15:07:03 <lambdabot> Title: Arithmetic coding  codeland
15:07:11 <yaxu> ClaudiusMaximus: that's so nice
15:07:34 <ClaudiusMaximus> yaxu: thanks :)
15:07:43 <yaxu> ClaudiusMaximus: a pure functional language interfacing with a pure side effect language :)
15:08:17 <tuukkah> ClaudiusMaximus, so hsext.pd_linux is a normal shared object even if it doesn't end in .so?
15:08:25 <ClaudiusMaximus> tuukkah: exactly
15:09:20 <yaxu> ClaudiusMaximus: dons will be interested in this...
15:09:59 <tuukkah> i was reading this wiki page, i don't understand how it relates to this: http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
15:10:03 <lambdabot> Title: DynamicLinking - GHC - Trac
15:13:05 <ClaudiusMaximus> tuukkah: i'm using gcc to link, not ghc, and i get "warning: creating a DT_TEXTREL in object.", but it seems to work ok
15:14:42 <glguy> > runState (flip runContT return $ do { loop <- callCC (return . fix); s <- get; when (s/=10) (modify (+1) >> loop) }) 0
15:14:43 <lambdabot>  ((),10)
15:16:38 <augustss> goltrpoat: that's a very cool arithmetic coder!
15:17:07 <ClaudiusMaximus> tuukkah: the internet tells me: "DT_TEXTREL likely means that you have .text relocations remaining, which will make your DSO "unsharead" as soon as it is loaded into a process address space."    works on x86, but not other architectures (eg, x86_64)
15:18:21 <velco> ClaudiusMaximus: it is true.
15:18:25 <tuukkah> ClaudiusMaximus, can i check out your code from svn somewhere and try?
15:18:54 <ClaudiusMaximus> tuukkah: http://devel.goto10.org/listing.php?repname=maximus&path=%2Fhsext%2F&rev=0&sc=0
15:18:57 <lambdabot> Title: DEVEL.GOTO10.ORG - maximus - Rev 153 - /hsext/, http://tinyurl.com/yer352
15:19:04 <velco> ClaudiusMaximus: it's not an architecture restriction per se, but rather dynamic loader restriction
15:19:57 <tuukkah> i mean, svn co
15:21:15 <ClaudiusMaximus> tuukkah: "svn co https://goto10.org/svn/maximus/hsext hsext" should work
15:21:22 <goltrpoat> augustss:  thanks
15:21:32 <ClaudiusMaximus> velco: thanks for the clarification
15:22:37 <velco> ClaudiusMaximus: do you happen have some C++ objects in the final link ?
15:24:04 <ClaudiusMaximus> velco: i don't know, the final link is kinda huge...
15:24:34 <ClaudiusMaximus> velco: i copy and pasted it from ghc -v --make
15:25:17 <tuukkah> now that's a clever hack :-)
15:27:23 <Mitar> is there a function to get the position of a minimal element in the list?
15:27:30 <Mitar> (not the element itself)
15:27:57 <goltrpoat> oh lovely.  didn't realize that wordpress strips out \ characters
15:28:09 <Mitar> or should i zipit with the [0...], find the minimal element, unzip it and get the index
15:28:29 <emu> \l -> fst . minimum . zip l [1..]
15:28:30 <emu> heh
15:28:43 <emu> fst . minimum . flip zip [1..]
15:29:04 <tuukkah> snd?
15:29:09 <emu> yea, im dumb
15:29:12 <Mitar> :-)
15:29:18 <Mitar> ok, so this is what i was thinking
15:29:29 <emu> > snd . minimum . flip zip [0..] $ [6,5,1,7,8]
15:29:40 * emu pokes lambdabot 
15:29:44 <emu> @botsnack
15:29:44 <lambdabot> :)
15:29:50 <emu> > snd . minimum . flip zip [0..] $ [6,5,1,7,8]
15:29:52 <lambdabot>  2
15:30:37 <emu> when did lambdabot start demanding snacks before responding?
15:30:38 <notsmack> ... did you just bribe her for an answer?
15:31:01 <velco> it's getting conscious ...
15:31:08 <velco> no more unpaid work.
15:31:55 <dons> ?uptime
15:31:56 <lambdabot> uptime: 12h 58m 15s, longest uptime: 1d 21h 16m 2s
15:32:03 <dons> ?users
15:32:04 <lambdabot> Maximum users seen in #haskell: 299, currently: 287 (96.0%), active: 49 (17.1%)
15:32:20 <emu> well she responds to dons always
15:34:11 <lambdabot> Of course, dons is just SO cute. *giggles*
15:35:17 <seancorfield> question about ghci - it says it loads Prelude but a load of functions are not in scope that seem to be listed as standard prelude stuff (ord, isDigit, toUpper etc)
15:35:30 <emu> those are Data.Char
15:35:55 <seancorfield> ah, so stuff has moved since the various web pages were last updated :)
15:36:10 <emu> which web pages btw?
15:36:29 <seancorfield> the tour of the prelude that several places link to
15:36:50 <sorear> http://haskell.org/onlinereport
15:36:52 <lambdabot> Title: The Haskell 98 Language Report
15:37:06 <sorear> the one source for everything prelude.
15:37:14 <seancorfield> thanx... hard to sort the wheat from the chaff with so many tutorials and documents!
15:39:47 <dpiponi> Anyone here want to proofread at what I'm trying to write for The Monad Reader?
15:40:12 * sorear raises hand
15:40:37 <emu> sure
15:40:45 <dons> ?docs Data.Char
15:40:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
15:40:46 <dpiponi> http://www.sigfpe.com/main.{tex,bib,lhs,pdf}
15:40:58 <sorear> <thought_bubble> ooh, first crack at a sigfpe post ... he he he </thought_bubble>
15:41:37 <dpiponi> I need to know if it's comprehensible.
15:42:22 <sorear> oh joy, X11 is incompatible with my new LCD monitor .. must reconfigure something
15:42:45 <sorear> all the files except the .bib have the same content?
15:43:04 <Mitar> > snd . maximum . flip zip [0..] $ [6,5,8,8,1]
15:43:06 <lambdabot>  3
15:43:10 * allbery_b couldn't get xorg to work with his new monitor either, but that seems to be a bug in 6.9
15:43:11 <Mitar> why is not 2?
15:43:23 <Mitar> how could I get it return 2 in such case?
15:43:45 <dmhouse> ?hoogle maximumBy
15:43:45 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
15:43:46 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
15:43:46 <Mitar> > snd . minimum . flip zip [0..] $ [6,5,1,1,8]
15:43:48 <lambdabot>  2
15:43:55 <Mitar> because snd . minimum . flip zip [0..] $ [6,5,1,1,8] returns 2
15:44:01 <Mitar> this is not really consistent
15:44:10 <sorear> I've had this new monitor for almost a week, and this is the first time I tried to run X.  I'm getting good at avoiding it :)
15:44:12 <dpiponi> the .lhs is the .tex
15:44:14 <_frederik_> why no 'Num a => Monoid a' ... grr
15:44:20 <dpiponi> the .pdf is the output
15:44:27 <dpiponi> from latex
15:44:36 <dmhouse> dpiponi: from the abstract, I'm excited :)
15:44:40 <dpiponi> but the .lhs is executable
15:44:41 <dmhouse> _frederik_: because there are two ways of doing it.
15:44:49 <sorear> I am too, it's just unreadable
15:44:51 <emk> dpiponi: Oooh, shiny.
15:44:56 <sorear> (for technical reasons)
15:44:58 <Mitar> ?help
15:44:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:45:21 <tuukkah> Mitar, perhaps you can reverse the list and substract the result index from list length?
15:45:25 <seancorfield> i've noticed there are quite a few similar functions defined in Data.{something} and {something} - is there a history behind that? e.g., Char and Data.Char, List and Data.List
15:45:32 <_frederik_> dmhouse: which two? additive and multiplicative?
15:45:33 <dmhouse> _frederik_: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html, there are the two Num instances as you expect.
15:45:34 <dpiponi> Trying to fill a gap because it took my a *long* time to figure out where classical logic fitted into CH.
15:45:35 <lambdabot> http://tinyurl.com/y5qk9n
15:45:50 <allbery_b> seancorfield:  Haskell98 specified a flat namespace
15:46:05 <allbery_b> modern Haskell uses a hierarchical namespace, hence Char -> Data.Char
15:46:10 <yaxu> dons: did you see that ClaudiusMaximus had got hs-plugins working with pure-data?
15:46:10 <emk> At the moment, I'm collecting shiny monads for a survey.
15:46:11 <seancorfield> ah, ok... thanx
15:46:17 <dpiponi> (Oops, I just realised I forgot to cite the key paper by Griffin.)
15:46:23 <goltrpoat> hey, you're using the same implication symbol as i did
15:46:24 <goltrpoat> hehe
15:46:26 <dons> yaxu: oh?
15:46:27 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:46:35 <dons> 'pure data' ?
15:46:44 <Mitar> can I see somewhere source for maximum and minimum functions
15:46:45 <Mitar> ?
15:46:50 <yaxu> dons: do you know of max?
15:46:50 <allbery_b> ?src maximum
15:46:51 <lambdabot> maximum [] = undefined
15:46:51 <lambdabot> maximum xs = foldl1 max xs
15:47:02 <Mitar> ?src minimum
15:47:02 <lambdabot> minimum [] = undefined
15:47:02 <lambdabot> minimum xs = foldl1 min xs
15:47:11 <seancorfield> allbery_b: and are they equivalent or are there (significant) differences in the new versions in the hierarchical namespace?
15:47:17 <yaxu> dons: it's a kind of sound synthesis language with a visual interface
15:47:20 <ClaudiusMaximus> dons: http://claudiusmaximus.goto10.org/gallery/coding/hsext/first-non-trivial.png
15:47:22 <lambdabot> http://tinyurl.com/umfvz
15:47:23 <allbery_b> they should be identical
15:47:38 <_frederik_> dmhouse: well i think additive is more canonical and should be the default instance
15:47:40 <yaxu> http://puredata.info/
15:47:43 <lambdabot> Title: About Pure Data &mdash; PD Community Site
15:48:01 <seancorfield> lambdabot: List.maximumBy :: (a -> a -> a) -> [a] -> a
15:48:02 <seancorfield> lambdabot: Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
15:48:07 <allbery_b> that said, ghc doesn't necessarily implement the definiitons found in the standard report's Prelude, although they "should" be equialent I think
15:48:20 <seancorfield> 'k tx
15:48:35 <allbery_b> (but in that case it'll be the same definition in both places still)
15:48:44 <johnnowak> yaxu: I learned to program with Max
15:48:45 <allbery_b> (I think)
15:48:58 <sorear> dpiponi: the first two of your three axioms are exacly the K and S combinators of combinatory logic
15:49:04 <Mitar> so why than is behavior different
15:49:09 <dpiponi> Yes, I think I mention it.
15:49:13 <Mitar> this is simply prone to error
15:49:29 <tuukkah> seancorfield, i didn't see what you meant at first. so maximum is taking the maximum index because it's included in the pair
15:49:36 <Mitar> just change the maximum by minimum and expect some behavior ...
15:49:41 <emk>  I know about all the monads in the Prelude and Control.Monad, plus STM, backtracking, unification, probability distributions, continuations (regular and sub-), parsers, queries, incremental computation, modular interpreters and a bunch of strange partial-evaluation papers. What other cool monads are out there?
15:49:46 <dpiponi> Hmmm...I didn't mention S and K. Good point.
15:49:51 <dmhouse> dpiponi: I don't really understand how the first axiom can be true, how can p imply something completely unrelated to p?
15:50:08 <sorear> I *think* the third has something to do with the yoneda lemma </idiotic_musing>
15:50:10 <Mitar> ahh, yes ...
15:50:20 <Mitar> the problem is that it compares the second element in the pair
15:50:25 <dpiponi> If the there is life on Mars then 1=1.
15:50:39 <dpiponi> Do you agree that's true dmhouse?
15:50:59 <dmhouse> dpiponi: sure.
15:51:11 * emk is looking for his strange monad fix...
15:51:19 <astrolabe> emk: did you see the paper on financial instruments?
15:51:36 <dpiponi> Same thing. p="1=1". q="There is life on Mars"
15:51:45 <koe> what would i use to help track down a divide by zero error in ghc?
15:51:48 <emk> astrolabe: Yup, although I only noticed the combinator parts, not any monadic stuff.
15:52:01 <astrolabe> emk: Ah, I'm probably mis-remembering
15:52:17 <astrolabe> emk: you'll have to invent some new ones yourself then.
15:52:20 <emk> Sweet paper, by the way. (I wouldn't be surprised if there were monads in there somewhere...)
15:52:25 <allbery_b> ?where hat
15:52:41 <allbery_b> hrm.
15:52:43 <goltrpoat> dpiponi:  maybe mention that a reifies to K and b to S from SK combinator calculus as an aside?  seems like a cool connection.
15:52:52 <emk> astrolabe: The monad junkie's lament...
15:53:14 <tuukkah> hsext.pd_linux: ELF 32-bit LSB shared object !-)
15:53:26 <astrolabe> How about those ways to combine monads?  Have you done them too?
15:53:42 <dpiponi> goltrpoat: I think it's no accident that the axioms are S and K. That formulation probably goes back to Curry.
15:53:43 <dmhouse> dpiponi: but if p = "1 = 1", q = "2 = 2", r = "3 = 2", then it's clearly not true.
15:53:48 <emk> astrolabe: Yup, monad transformers are happy, too.
15:54:02 <allbery_b> koe: http://www.haskell.org/hat/ might be of use
15:54:04 <lambdabot> Title: Hat - the Haskell Tracer
15:54:06 <dpiponi> dmhouse, you talking about axiom (c) now.
15:54:09 <dpiponi> ?
15:54:23 <allbery_b> (*now* lbot listens.  feh)
15:54:32 <astrolabe> emk: You can express quantum mechanical wave functions as monads, but I don't know where that is written up.
15:54:34 <dmhouse> dpiponi: no, axiom (a), (p -> (q -> r)).
15:54:42 <koe> hmm. what if i can logically reason out any possibility of a divide by zero in my code?
15:54:49 <emk> astrolabe: Interesting. I'll go Google it.
15:55:03 <dpiponi> Thank you for spotting a *major* type dmhouse!
15:55:16 <dpiponi> s/type/typo/
15:55:20 <dmhouse> dpiponi: hehe. It's meant to be (p -> (q -> p))?
15:55:46 <dpiponi> Yes!
15:55:53 <dmhouse> Righto.
15:56:12 <sorear> it's called combinatory *logic* for a reason, I suppose
15:56:40 <dpiponi> Corrected version now online.
15:56:47 <sorear> also, there is a trivial desugaring of the lambda calculus into the SK-calculus, but other combinator sets are harder to target.
15:57:25 <dpiponi> The desugaring comes later. But how it arises is really cool.
15:57:43 <sorear> i'm only at 50%
15:58:10 <dons> ClaudiusMaximus: very cool!
16:01:49 <Mitar> > snd . Data.List.maximumBy (\(x,_) (y,_) -> max x y) $ flip zip [0..] $ [6,5,8,8,1]
16:01:50 <lambdabot>   add an instance declaration for (Num Ordering)
16:01:50 <lambdabot>     In the list element: 1
16:01:57 <Mitar> what's wrong?
16:02:05 <dons> compare x y
16:02:06 <dons> not max
16:02:22 <dmhouse> dpiponi: a one-sentence description of intuistionic logic wouldn't go amiss, I had to Wikipedia it.
16:03:20 <tuukkah> List.maximumBy had the signature that would work with max
16:03:20 <Mitar> > snd . Data.List.maximumBy (\(x,_) (y,_) -> compare x y) $ flip zip [0..] $ [6,5,8,8,1]
16:03:22 <lambdabot>  3
16:03:28 <Mitar> > snd . Data.List.minimumBy (\(x,_) (y,_) -> compare x y) $ flip zip [0..] $ [6,5,1,1,8]
16:03:30 <lambdabot>  2
16:03:35 <dpiponi> Good point. I'm assuming saome familiarity with CH but I could easily mention Intuitionistic logic.
16:03:36 <Mitar> why the difference?
16:04:26 <allbery_b> ?src min
16:04:26 <lambdabot> min x y = if x <= y then x else y
16:04:32 <allbery_b> ?src max
16:04:32 <lambdabot> max x y = if x <= y then y else x
16:04:47 <Mitar> hmm
16:04:54 <dpiponi> Gotta go trim the hedge but I'll check back later for comments. Thanks guys!
16:04:56 <Mitar> i think that such definition is a bug :-)
16:04:59 <allbery_b> so if they're equal, min returns the furst and max the second
16:05:03 <allbery_b> *first
16:05:09 <ClaudiusMaximus> dons: thanks :)
16:05:18 <dons> http://programming.reddit.com/info/xeto/details
16:05:20 <lambdabot> Title: Composability and productivity in programming languages (reddit.com)
16:05:27 <goltrpoat> dpiponi:  very very cool.
16:05:56 <goltrpoat> (still at 75% or so)
16:05:56 * allbery_b is not clear that it's a bug, so much as unspecified behavior
16:06:12 <allbery_b> if you need something more specific, use your own predicate with specified behavior
16:07:36 <tuukkah> so List.maximumBy with (flip max)
16:07:47 <sorear> @tell dpiponi inl might be slightly obscure, Left might be better for a haskell audience
16:07:47 <lambdabot> Consider it noted.
16:08:16 <dpiponi> sorear - I actually changed that already!
16:08:16 <lambdabot> dpiponi: You have 1 new message. '/msg lambdabot @messages' to read it.
16:08:25 <dpiponi> Really gotta go trim the hedge now...
16:08:39 <dons> sorear: well, inl and inr are standard :)
16:08:46 <dons> but for Haskellers I guess Left /Right are more obvious
16:08:52 <dons> ?where plbook
16:08:53 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
16:08:57 <dons> full of inl's and rs
16:09:25 <dmhouse> ?tell dpiponi typo on page 8, "then we are may no longer"
16:09:25 <lambdabot> Consider it noted.
16:10:05 <sorear> anyway - very nice.  I might actually have learned something.
16:10:19 <dmhouse> ?tell dpiponi typo on page 8, "eith assumptions"
16:10:19 <lambdabot> Consider it noted.
16:10:21 <dons> sorear: thanks for the patch. that's exactly the level of docs I like to see :)
16:10:23 <dons> sorear++
16:12:40 <ttmrichter> @help
16:12:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:12:47 <ttmrichter> @help list
16:12:48 <lambdabot> list [module|command]
16:12:48 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:14:35 <ttmrichter> @type :
16:14:37 <lambdabot> parse error on input `:'
16:14:41 <ttmrichter> @type $
16:14:42 <lambdabot> parse error on input `$'
16:14:47 <allbery_b> @type (:)
16:14:48 <lambdabot> forall a. a -> [a] -> [a]
16:14:57 <dons> :t ($) -- also works
16:14:59 <lambdabot> forall b a. (a -> b) -> a -> b
16:15:02 <ttmrichter> @type (:)
16:15:03 <lambdabot> forall a. a -> [a] -> [a]
16:15:09 <ttmrichter> Duh.  Sorry.  Forgot about the operator notation.
16:15:43 <ttmrichter> Interesting little tool, though.
16:16:14 <dons> ?src $
16:16:15 <lambdabot> f $ x = f x
16:16:22 <dons> ?index ($)
16:16:23 <lambdabot> Prelude
16:16:27 <dons> ?source Prelude
16:16:28 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
16:16:30 <dons> ?docs Prelude
16:16:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:16:38 <tuukkah> ClaudiusMaximus, i got it compiled and loaded, but now opening Print-help.pd dies in Ix{Int}.index: Index (1024) out of range ((0,18))
16:16:52 <sorear> little? I think lambdabot is one of the top 10 largest haskell programs...
16:17:05 <dons> hehe
16:17:10 <dons> nah, there's some big compilers out there
16:17:16 <dons> but it is over the 10k loc mark :}
16:19:17 <sorear> has there been much work on cross-compiler dynamic low-level code injection?
16:19:30 <sorear> (there must be a clearer phrasing...)
16:19:46 <dons> mobile code?
16:20:10 <sorear> like hs-plugins, but for Yhc + Hugs + GHC etc
16:20:15 <joelr1> good evening
16:20:36 <ClaudiusMaximus> tuukkah: i don't know, check the README for the versions of things i used, also check the Makefile to check if paths match your system?
16:20:47 <dons> heya joelr1
16:21:21 <sorear> @users
16:21:22 <lambdabot> Maximum users seen in #haskell: 299, currently: 283 (94.6%), active: 46 (16.3%)
16:21:27 <tuukkah> ClaudiusMaximus, i do have different os and versions so obviously i had to change -I -L -l -u appropriately
16:21:46 <dons> joelr1: how's the hacking coming along? whatcha working on now?
16:21:52 <joelr1> i'm trying to pull from a darcs repo and it gives me a 404 on the inventory file. on the other hand, i can wget a file from the dir that _darcs is under
16:21:54 <ttmrichter> Nice tour of the lambdabot features, dons.  Thanks!
16:21:58 <joelr1> any tips?
16:22:09 <dons> joelr1: which repo?
16:22:24 <joelr1> dons: i'm trying this on my host
16:22:34 <sorear> I feel like I *really* should know who joelr1 is ...
16:22:47 <tuukkah> joelr1, can you wget the inventory file too?
16:22:47 <dons> possibly the server is handing back something weird?  like an index.html ?
16:22:48 <joelr1> dons: set up a yampa repo
16:22:50 * dons guesses
16:22:54 <dons> joelr1: oh good!
16:23:06 <joelr1> dons: seriously looking at  functional reactive trading :D
16:23:19 <joelr1> sorear: http://wagerlabs.com
16:23:21 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
16:23:31 <dons> sorear: joel is legendary for breaking ghc in 42 different ways last summer
16:23:38 <ttmrichter> ?source quicksort
16:23:38 <lambdabot> quicksort not available
16:23:39 <joelr1> tuukkah: i cannot. weird
16:23:48 <ttmrichter> ?source sort
16:23:48 <lambdabot> sort not available
16:23:48 <bd_> ?source sort
16:23:48 <lambdabot> sort not available
16:23:54 <dons> ?src sort
16:23:54 <lambdabot> sort = sortBy compare
16:23:58 <dons> sorry, source /= src
16:23:58 * joelr1 bows
16:24:02 <beschmi> hi dons
16:24:04 <bd_> ?src sortBy
16:24:04 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:24:14 <ttmrichter> ?src insertBy
16:24:15 <lambdabot> insertBy _   x [] = [x]
16:24:15 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
16:24:15 <lambdabot>                                  GT -> y : insertBy cmp x ys'
16:24:17 <lambdabot>                                  _  -> x : ys
16:24:30 <beschmi> are you planning to come to the comlab before checking in? (checkin is from 14:00)
16:24:30 <dons> beschmi: so all set up for the hackathon?
16:24:40 <dons> beschmi: yeah, I think so.
16:24:43 <ttmrichter> You shouldn't have ought to have told me this, dons.  It's gonna get spammy if I lose control!
16:24:48 <dons> I'll just have my bag, so shouldn't be too hard to carry
16:24:56 * ttmrichter has to head off to give exams today, though.  :(
16:24:56 <beschmi> dons: cool, then we can meet there
16:25:00 <joelr1> dons, tuukkah: this happened to me before but i don't remember how i resolved it last time :(
16:25:01 <dons> ttmrichter: there's /msg if you want to play and explore :)
16:25:24 <dons> beschmi: ok. and you're staying in stanstead or something on tues night?
16:26:15 <dons> ooh my new laptop battery arrived! now I'm all set of a cross-continent hackathon!
16:26:35 <Mitar> how can i get some random looking monadless numbers in haskell?
16:26:45 <sorear> literals!
16:26:51 <sorear> 3408892349034289009 4439349089054 5690690956 6590360589056 7539096504326943
16:27:04 <Mitar> :-)
16:27:10 <beschmi> dons: i'm planning to take a cab from the bus station to igloo if it it doesn't get too late
16:27:23 <Mitar> no, really, is there some predined function?
16:27:25 <sorear> actually, if you don't like monads, random number generation is (almost) comonadic
16:27:49 <joelr1> dons: got a macbook pro /battery/?
16:28:11 <glguy> ?hoogle randomRs
16:28:12 <lambdabot> Random.randomRs :: (Random a, RandomGen b) => (a, a) -> b -> [a]
16:28:12 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
16:28:20 <glguy> Mitar: ^^
16:28:42 <Mitar> System random returns IO monad?
16:28:46 <glguy> > randoms (mkStdGen 42)
16:28:47 <lambdabot>  Add a type signature
16:28:51 <glguy> > randoms (mkStdGen 42) :: [Int]
16:28:52 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
16:29:07 <glguy> > randomRs (1,10) (mkStdGen 42) :: [Int]
16:29:08 <lambdabot>  [2,2,8,5,7,2,9,2,9,6,6,10,7,9,5,6,8,2,4,7,7,5,3,5,7,5,1,9,4,5,5,6,3,3,7,4,5,...
16:29:15 <sorear> data RandomComonad g a = RC g a ; instance Functor (RC g) where fmap f (RC g a) = RC g (f a) ; instance RandomGen g => Comonad (RC g) where cojoin (RC g a) = let (g1,g2) = split g in RC g1 (RC g2 a) ; coreturn (RC g a) = a
16:30:03 <allbery_b> Mitar: a monad is only needed for two things:  (a) seeding from something like the system time; (b) transparently carrying the current random seed arund
16:30:12 <sorear> I usually pass RandomGens down using *fake* linear implicit params, but the comonadic way is looking very appealing to me
16:30:22 <allbery_b> if you provide your own seed and you don't mind passing the seed around manually you can avoid monads completely
16:30:58 <sorear> or you can automate the seed-passing, but then you're better off using a monad
16:31:14 <sorear> od notation still doesn't exist :(
16:31:33 <allbery_b> and, of course, if you provide your pwn pure seed, you'll always get the same sequence out of it
16:31:38 <allbery_b> *own
16:31:43 <Mitar> i understand that
16:31:43 <glguy> mapAccumL is nice for carrying a stdgen
16:31:55 <Mitar> thanks, i just had trouble finding how can i do it
16:32:00 <sorear> mapAccumL is mapM in the state monad
16:32:25 <glguy> kind of
16:32:26 * allbery_b has used foldr in evil ways to carry state around
16:32:37 * glguy has used foldM to carry state around
16:33:01 * sorear declares the second week of january Monad Awareness Week
16:33:21 <allbery_b> (I rewrote eventually to use StateT, it's much cleaner now :)
16:33:36 <Stinger_> sorear are you gonna hand out pamphlets at your local mall?
16:33:57 <sorear> ooh....
16:34:46 <mbishop> MAW?
16:35:23 <mbishop> Monad Enlightenment
16:35:29 <mbishop> Monad Enlightenment Over the World
16:35:31 <mbishop> MEOW :P
16:36:46 <Stinger_> hahah
16:37:04 <dons> mbishop: hehe
16:37:21 * dons wants a MEOW tshirt, with the monad laws on the back
16:37:41 <dons> "Haskell is a programming language where you get the feeling that a lot of things are just perfect."
16:37:45 <dons> http://onthebalcony.wordpress.com/2007/01/08/haskell-is-fun/
16:37:47 <lambdabot> Title: Haskell is fun!  On The Balcony
16:38:07 <dons> also at http://programming.reddit.com/info/xese/comments
16:38:08 <lambdabot> Title: Haskell is fun! (reddit.com)
16:38:48 <heatsink> What's with all the good publicity recently?
16:39:22 <dons> the time was just right?
16:39:42 <dons> people looking for something new, coinciding with haskell getting some libraries and bloggers getting organised?
16:40:06 <dons> ?quote shapr take
16:40:06 <lambdabot> shapr says: I think the Haskell approach works fine. That is, stick with research and do the best you can. Then after fifteen years of gestation, take over the world.
16:41:55 <heatsink> All those things have been going on for a while though, this latest increase in publicity still feels sudeen.
16:43:14 <dons> maybe its just making up for the chronic ack of publicity for the fist 15 years?
16:43:17 <sorear> I agree wholly with the composability post on planet.; all these systems make using composable code libraries easy.   Haskell makes writing libraries easy.  Haskell does for coding what all the digital culture and web-2.0 folks are ranting about wrt. media.
16:43:43 <glguy> I just got a zipcode submitted "FUCKU" does that make sense to anyone?
16:43:53 <dons> glguy: hehe. hmm...
16:43:55 <heatsink> It is deserved.
16:44:37 <heatsink> Um, I meant to say that to dons, not glguy.
16:44:39 <dmhouse> ?tell dpiponi page 10 at the bottom, language is confusing, consider replacing "through" with "past".
16:44:40 <lambdabot> Consider it noted.
16:44:56 <dons> heatsink: the publicity?
16:44:59 <heatsink> yea
16:45:51 <dons> I think so. We have a lot of cool, new, useful things that no one else has. Coinciding at the time the language is getting taken up in the commercial world. So its all good
16:45:55 <sorear> we need to branch the language again... make a haskell-unstable that spj et alia aren't afraid to break compatibility in.
16:45:59 <dmhouse> ?tell dpiponi page 11, the content of the first paragraph is then repeated at the start of the second.
16:45:59 <lambdabot> Consider it noted.
16:48:39 <ClaudiusMaximus> tuukkah: it works fine here, with the versions noted in the README, if you ?tell me the versions you used i might be able to check it out later; now i sleep
16:48:47 <shapr> @seen andygill
16:48:48 <lambdabot> I haven't seen andygill.
16:49:42 <emk> dpiponi: Nice paper, by the way.
16:50:07 <tuukkah> ClaudiusMaximus, the most important is that i can copy your makefile and use the ghc -v --make trick, thanks for those!
16:50:44 <ttmrichter> Have there been any high-profile failures in conventional software recently?
16:50:57 <Anon4888> windows vista?
16:50:58 <dmhouse> ?tell dpiponi I _love_ the Pierce's law/callCC stuff. Those kinds of links between seemingly unrelated areas make your head explode. :)
16:50:58 <lambdabot> Consider it noted.
16:51:30 <goltrpoat> dmhouse:  yeah, i did a doubletake at the "callcc = peirce" line
16:51:36 <tuukkah> ClaudiusMaximus, i have debian etch, ghc-6.6, hs-plugins-1.0-rc0, gcc 4.1.2, puredata 0.39.2
16:51:59 <goltrpoat> that's remarkably cool.
16:52:21 <dmhouse> goltrpoat: I saw it coming, once you get that many nested brackets you _have_ to be talking about continuations :)
16:52:32 <goltrpoat> hehe true
16:52:53 <ttmrichter> I'm thinking that the recent popularity in Haskell and alternative approaches may be a reaction to conventional approaches having high-profile failures.  Yes, Vista seems to fit the bill, too.  That many years.  That much hype on security.  That profound a failure.
16:53:19 <dons> ttmrichter: and a bit of a preemptive scare about multicore machines and concurrency
16:53:43 <dons> well maybe not so preemptive, 16 core boxes are fairly easy to get hold of now
16:53:56 <shapr> dons: Is your manycore box up?
16:54:24 <dons> not yet. its in its box down stairs
16:54:33 <dons>  I don't think I'll have a chance to turn it on before leaving tomorrow
16:55:30 <sorear> dons: how many peak watts does it require :)
16:55:30 <shapr> Going away for awhile?
16:55:37 <dmhouse> ?tell dpiponi page 13, 'result identity' should really be 'result id' as you're talking proper Haskell now.
16:55:37 <lambdabot> Consider it noted.
16:55:56 <dons> shapr: yeah, off the the UK for the hackathon, then on to Nice for 3 conferences
16:56:15 <shapr> Cool!
16:56:39 <joelr1> dons: i resolved my repo problem
16:57:14 <dons> oh?
16:57:38 <joelr1> dons: lighttpd conf was appending .html to files w/o extension
16:57:49 <joelr1> wanna try http://wagerlabs.com/yampa ?
16:58:04 * dons tries
16:59:35 <astrolabe> joelr1: I got the impression you'd abandoned haskell for erlang?
16:59:39 <dons> $ darcs get http://wagerlabs.com/yampa
16:59:40 <dons> Copying patch 1 of 1... done!
16:59:40 <dons> Applying patch 1 of 1... done.
16:59:40 <dons> Finished getting.
16:59:57 <joelr1> dons: i'm not sure how to build everything (tests, examples, src) in one fell swoop... and how to organize the directory tree
17:00:15 <joelr1> astrolabe: not necessarily. i try to pick the best tool for the job
17:00:36 <joelr1> astrolabe: erlang sucks for everything involving arrays, for example
17:00:52 <astrolabe> So haskell has its uses?  Just not binary IO?
17:01:02 <shapr> Speaking of which, has anyone tried BitSyntax?
17:01:23 <dons> astrolabe: though i'd argue binary IO based on lazy bytestrings rules! (after playing with gzipped serialised lambdabot state on the weekend...)
17:01:24 <joelr1> astrolabe: something like that. i'm looking at yampa right now as a way to build trading systems
17:01:27 <dons> maybe I'm biased
17:01:43 <dons> that's happened since joel's original binary IO troubles
17:01:50 <joelr1> astrolabe: don't know how far i'll get. it's easier with erlang but haskell/yampa is more declarative
17:02:16 <astrolabe> joelr1: I think your blog was quite influential.  I see people expressing opinions suspiciously like your conclusions.
17:02:19 <joelr1> dons: what about gzipped serialized lambdabot state?
17:02:25 <dpiponi> Hedge trimmed. That was pretty useful feedback.
17:02:33 <joelr1> astrolabe: oh... what do you mean exactly?
17:02:53 <astrolabe> dons: I think I'll have to use bytestrings soon.
17:03:07 <dpiponi> dmhouse: head-exploding is what it's all about
17:03:09 * astrolabe tries to recall
17:03:42 <joelr1> i wonder if i should announce the repo as is or take time to clean it up further
17:03:48 <shapr> joelr1: both!
17:03:55 <dons> joelr1: oh, I modified lambdabot on the weekend to dump its state to disk serialised viabytestrings, that are then gzipped
17:03:56 <joelr1> i think it needs a better directory layout, etc.
17:04:09 <dmhouse> dpiponi: yep :) And then seeing that the Gdel-Gentzen translation was equivalent to a CPS translation... brilliant.
17:04:14 <joelr1> dons: is that code in darcs now? can you point me to the file?
17:04:15 <dons> so the state files on disk are gzipped, and transparently uncompressed, and un-serialised on startup
17:04:26 <dons> it just uses
17:04:30 <dons> ?where libz
17:04:30 <lambdabot> I know nothing about libz.
17:04:33 <joelr1> dons: i'm still waiting for hs-plugins for ghc 6.6 ;-)
17:04:33 <shapr> dons: Are you using Bulat's code to gzip the LBSs?
17:04:34 <dons> ?where gzip
17:04:34 <dpiponi> The Godel-Gentzen=CPS thing is all old stuff BTW
17:04:35 <lambdabot> I know nothing about gzip.
17:04:38 <dons> bah
17:04:43 <dons> nono. dcoutt's gzip bindings
17:04:51 <dpiponi> But I have no idea who to credit for this stuff
17:04:52 <dons> ?where zlib
17:04:53 <lambdabot> darcs get http://haskell.org/~duncan/zlib
17:04:55 <dons> ^^
17:04:59 <dons> ?where bzlib
17:05:00 <lambdabot> I know nothing about bzlib.
17:05:04 <joelr1> shapr: ok, http://wagerlabs.com/yampa
17:05:11 <shapr> dpiponi: Is that related to Charles Stewart's thesis?
17:05:19 <dons> (pure gzip functions, unlike Bulat's stuff)
17:05:21 <astrolabe> joelr1: I read some blog in which someone was saying he'd be learning erlang as his next language, and expaining why he wasn't choosing haskell.  I got the impression he'd read your blog an misinterpreted it as 'erlang is better then haskell'.
17:05:36 <dons> ?where+ bzlib http://haskell.org/~duncan/bzlib/
17:05:37 <lambdabot> Done.
17:05:45 <joelr1> astrolabe: do you think i can help this type of a person?
17:05:50 <dpiponi> shapr: never heard of that thesis
17:05:58 <joelr1> it's like saying that apples are better than oranges!
17:06:22 <dons> astrolabe: yeah, there's been a few around who cite 'wagerlabs' as the reference for not bothing with haskell :/ ah well.
17:06:25 <joelr1> then again, the haskell vs. erlang article is like the top article of all times
17:06:41 <joelr1> dons: gotta change that, right?
17:06:49 <astrolabe> joelr1: all I can suggest is that if you have a better experience with haskell at some point, that you put it in the blog too :)
17:06:50 <shapr> dpiponi: http://www.linearity.org/cas/thesis/
17:06:52 <dons> :) yeah, its a good motivation to make things work!
17:06:53 <lambdabot> Title: On the Formulae-as-Types Correspondence for Classical Logic
17:07:01 <dmhouse> dpiponi: I'm a bit stuck getting started on the exercises. Care to point me in the right direction with exercise 1?
17:07:23 <dons> joelr1: I personally hope to get out a super fast bytestrings based Binary IO module this week, during the hackathon
17:07:45 <dons> I think with stream fusion we can do some advanced optimisations
17:07:52 <shapr> dons: You think those of us on #haskell can help with the hackathon somehow?
17:08:07 <dons> shapr: well yes. code will be coming in. so we need testers, and people working on anything
17:08:11 <shapr> cool
17:08:20 <dons> we can distribute the hacking!
17:08:22 <dpiponi> dmhouse: Either a b is the same as not a -> b
17:08:28 <joelr1> dons: do you think it could be a matter of not just having fast binary IO but having it be convenient?
17:08:28 <shapr> Is there a hackathon irc channel?
17:08:34 <sorear> #haskell.hac07
17:08:51 <dons> joelr1: yeah, its got to be convenient
17:08:52 <dpiponi> So you need functions left::a -> (not a -> b) and right::b -> (not a b)
17:08:54 <joelr1> dons: convenient to describe the data structures that you are serializing. maybe you have done this already for lambdabot, i'm not sure.
17:08:54 <dons> i.e. deriving Binary
17:08:56 <dons> ideally
17:09:02 <joelr1> dons: how did you do it?
17:09:08 <astrolabe> spj's stm paper is really excellent.  Reminds me of physics papers I've read by greats.  It's just so lucid!
17:09:23 <dons> currently I just have a lot of default instances for the basic types, and then manually write new instances Binary t for my types
17:09:29 <dons> but that can be derived automatically
17:09:35 <dpiponi> As well as either::(a->c) -> (b->c) -> (neg a -> b) -> c
17:09:35 <dons> the other thing is to have the get/put functions be pure
17:09:39 <dons> and just return flat bytestrings
17:09:51 <dmhouse> dpiponi: ah, gotcha, write the constructors.
17:09:52 <dons> which leads to a flexible system (you can serialise from memory, or to disk, or the network)
17:09:55 <dons> using the same system
17:09:55 <Igloo> dons, shapr: Next time we should set up a parallel hackathon.us!
17:10:01 <shapr> Igloo: Yeah!
17:10:04 <sjanssen> dons: how is this done efficiently?
17:10:08 <dpiponi> The constructors and either.
17:10:13 <shapr> We need some US people willing to show up.
17:10:15 <sorear> stream fusion!
17:10:16 <dons> sjanssen: kolmodin's got a nice ContT based system...
17:10:19 <dpiponi> Trying to work out how either does its stuff is fun
17:10:19 * sjanssen would come to a hackathon.us
17:10:28 <shapr> Time for a wiki page..
17:10:34 <Igloo> Hmm, shapr is on the wrong side of the country, though
17:10:42 <dpiponi> I actually ended translating it to C++ to understand it (shock! horror!)
17:10:43 <shapr> Igloo: from?
17:11:00 <astrolabe> @users
17:11:00 <lambdabot> Maximum users seen in #haskell: 299, currently: 276 (92.3%), active: 42 (15.2%)
17:11:01 <Igloo> Isaac and David Roundy
17:11:03 <shapr> Igloo: Portland? NYC? oh
17:11:17 * Igloo can't remember where John lives, if I ever knew
17:11:37 <shapr> John who?
17:11:41 <Igloo> Goerzen
17:11:48 <shapr> Oh, he's in Kansas last I checked.
17:12:22 <joelr1> dons: do you think you guys will get to that convenient serialization during the hackathon?
17:12:27 <astrolabe> What is a hackathon?
17:12:42 * joelr1 just announced the yampa+gadt repo on haskell-cafe
17:12:42 <Igloo> astrolabe: Lots of people sit down in the same room (normally) and hack (write code)
17:13:09 <Igloo> astrolabe: The consumption of pizza is also requisite
17:13:21 <astrolabe> Igloo: cooporating, or on different projects?
17:13:57 <Igloo> astrolabe: Whatever has the best results. Even if there is no co-operation, just the fact that you are all sitting down and hacking away help you not get distracted
17:14:07 <dons> joelr1: yeah, I think we can do it
17:14:21 <Igloo> But generally small groups of people will try to co-operate
17:14:26 <dons> all the key hackers will be there (me, dcoutts, kolmodin) who want to work on the serialisation stuff
17:14:56 <sorear> thanks dons, leaving a file named build in the lambdabot dir :)
17:14:57 <astrolabe> dons: are you coming from austrailia especially?
17:15:05 <dons> sorear: oh?
17:15:07 <dons> astrolabe: yeah :)
17:15:15 * sorear finds bash's completetion functions ... interesting
17:15:16 <astrolabe> Thats dedication!
17:15:32 <sorear> ./Setup.hs bui<tab> ... wtf! why did that work?
17:16:12 <Igloo> sorear: tab completion does clever things like attempt to parse --help output nowadays
17:16:20 <joelr1> dons: that /convenient serialization/ would be so damn awesome. cause i'm ready to push the boundaries again :)
17:17:13 <sorear> Igloo: not on my system :( it only parses --help output for a small list of commands (curiously, including ./configure)
17:17:35 <allbery_b> suppose it depends on what version, and what shell
17:17:40 <dons> joelr1: yeah, I want it for lambdabot too, so that's important to getting it done -- motivation!
17:17:40 <joelr1> dons: i'm taking risks this year :) started day-trading futures and want to automate my trading with haskell. this means that i'm back to binary io, threads, stm, etc. etc. all that together with yampa, hopefully. and with a response time of < 100ms, ideally.
17:17:45 <sorear> this is a classic problem of not-enough-metadata ... sign
17:17:55 <dons> joelr1: ok. sounds like .. fun!
17:18:14 <dons> I'll put the serialisation stuff on the high priority setting this week then
17:18:30 * allbery_b should hack that into his zsh completion
17:18:42 <joelr1> dons: i can already see two things: 1) ghc breaking and 2) lots of nice haskell articles on my blog
17:18:45 <joelr1> :D
17:19:06 <dons> well, I hope it won't break too much.
17:19:12 <allbery_b> hm, it'd help if I had the stock completion stuff loaded on this box :)
17:19:40 <sorear> just so long as they don't push to 6.6, I'll avoid pulling HEAD for a few weeks
17:20:05 <sorear> nah, who am I kidding, must have bleeding edge ghc
17:20:22 <astrolabe> joelr1: your own money?
17:20:23 <joelr1> dons: me too. i see loading trading systems ala plugins in lambda bot. it seems like the same thing.
17:20:39 <joelr1> astrolabe: yes, putting my own money on the line with haskell
17:20:50 <bd_> ?where regex-compat
17:20:51 <lambdabot> I know nothing about regex-compat.
17:21:11 <astrolabe> joelr1: I'd find it hard to trust my own code that much.
17:21:31 <joelr1> astrolabe: http://wagerlabs.com/2007/1/6/day-trading-the-russel-2000-futures
17:21:31 <astrolabe> also my own algorithms
17:21:32 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
17:21:52 <joelr1> astrolabe: well, i'm hoping quickcheck will help
17:22:28 <joelr1> i know i could build the whole thing with erlang but... but... dunno, i'm hoping it will be more elegant with haskell
17:22:43 <sorear> the lambda revolution, phase 6 - haskell controls your economy
17:23:18 <astrolabe> joelr1: I'm suprised the per-trade costs aren't too high to make daily trades impossible for an individual.
17:23:23 <joelr1> so i'll be building up the trading platform in little pieces and posting on my blog. i will likely keep the whole thing proprietary but will post examples
17:23:37 <ClaudiusMaximus> dons: ghc-6.6 + hs-plugins-1.0-rc0 = untold pain and grief, right?
17:23:44 <joelr1> astrolabe: it's 3.75 per round-trip (enter trade + exit)
17:23:55 <joelr1> astrolabe: could be less if you are member of the exchange.
17:23:57 <shapr> joelr1: $3.75 USD?
17:24:00 <astrolabe> joelr1: I guess you don't believe the martingale + interest theory of stock prices
17:24:35 <joelr1> astrolabe: i hope to go full-time with trading this year and if all goes well then i'll likely try leasing an exchange seat
17:24:46 <astrolabe> joelr1: That's less than I thought, but still quite high at the rate you are trading.
17:24:53 <joelr1> astrolabe: ugh... dunno what you are talking about. but then i'm not trading stocks.
17:25:27 <joelr1> astrolabe: yeah, it's less if you lease an exchange seat. for the russell 2000 it's 300 usd per month, i think
17:25:32 <joelr1> shapr: yes, USD
17:25:54 <astrolabe> joelr1: sorry, it's jargon, but it means that (ignoring interest) that the expection of a commodities price next tuesday is it's current price.
17:26:10 <treitter> I've got:    mapIntsToStrings x = map numsToStrings x           and numsToStrings :: [Int] -> [String], but hugs complains that map is expecting Int -> [String]
17:26:15 <shapr> I think I'd enjoy stock trading so much I'd never do anything else.
17:26:15 <joelr1> astrolabe: that would be a GEM seat, emerging markets at the CME (chicago mercantile exchange)
17:26:28 <astrolabe> joelr1: is it free after you've got the seat?
17:26:57 <joelr1> shapr: i'm sick of working for other people and i want to program for pleasure. trading successfully is a huge challenge, though
17:26:59 <shapr> To me it seems easy to make profit on stock trading if transactions are cost free.
17:27:07 <joelr1> astrolabe: no, not free. maybe $1 per round-trip
17:27:13 <joelr1> 50 cents one-way
17:27:18 <astrolabe> shapr: how so?
17:27:39 <sorear> resell the service
17:27:41 <sorear> ?
17:27:43 <joelr1> but that's still a fraction of what you would normally be paying
17:27:48 <dons> ClaudiusMaximus: that is correct.
17:28:04 <ClaudiusMaximus> tuukkah: ^^
17:28:05 <shapr> Much like these space merchant games, where you can convert one type of item into a highly profitable item after a few steps.
17:28:14 <astrolabe> joelr1: perhaps there is a gap for a cheap broker.  You buy the seat and do other people's trades for them, all by computer?
17:28:22 <joelr1> shapr: it's still not easy. lots of powerful companies built scalping systems that go for pennis in profit
17:28:28 <joelr1> pennies, sorry.
17:28:36 <astrolabe> heh
17:28:43 <treitter> ah - forget my question
17:28:45 <joelr1> astrolabe: no, it's not as easy as that.
17:28:53 <joelr1> astrolabe: but you can save a lot of money yourself
17:29:04 <astrolabe> shapr: I suspect you need to be really quick to catch such opportunities.
17:29:05 <ClaudiusMaximus> @tell tuukkah (01:20:52) ClaudiusMaximus: dons: ghc-6.6 + hs-plugins-1.0-rc0 = untold pain and grief, right?  (01:25:03) dons: ClaudiusMaximus: that is correct.      now i try to sleep for real
17:29:05 <lambdabot> Consider it noted.
17:29:19 <shapr> joelr1: why isn't it as easy as that? If your system works and exports an xml-rpc API, I'd use it to trade my stocks.
17:29:26 <tuukkah> dons, ClaudiusMaximus, hrm, indeed good to know. i think i'll settle for compiling one .so file per plugin for now
17:29:27 <lambdabot> tuukkah: You have 1 new message. '/msg lambdabot @messages' to read it.
17:29:44 <sorear> dons: my lambdabot errors out if @seen sorear-lambdabot while it is in 0 channels.  Is this a regression?
17:29:47 <joelr1> anyway, the whole undertaking requires building exchange feeds, for example. or broker api feeds. network servers that suck in price quotes and input orders
17:29:48 <dons> sorear: want to pull those patches and try the testsuite now. be sure to build a new bot, then cd testsuite ; make ; ./run-utests
17:30:02 <dons> sorear: hmm. seems like something weird
17:30:10 <sorear> *sorear-lambdabot* Plugin `seen' failed with: IRCRaised I'm here, but not here. And very confused!
17:30:20 <dons> hehe
17:30:25 <joelr1> shapr: you need a lot of stuff to be a broker. money, registrations as a broker, etc. it's like becoming a bank, on a lesser scale
17:30:27 <shapr> astrolabe: Yeah, but I traded MtG cards to the point that most players in my state knew me.
17:30:54 <shapr> And didn't like me much...
17:31:03 <shapr> But I did make several thousand dollars in profit...
17:31:14 <joelr1> @localtime
17:31:29 <dons> ?time joelr1
17:31:31 <lambdabot> Local time for joelr1 is 2007-01-08 01:25:50 +0000
17:31:34 <joelr1> ah!
17:31:45 <dons> (I guess you expect it to return your time , given no args?)
17:31:52 <shapr> Too bad I spent my time at college trading cards instead of studying...
17:31:54 <joelr1> i need to go to sleep. good night everyone!
17:31:54 <dons> (which we could do)
17:32:01 <shapr> g'nite joel!
17:32:10 <joelr1> dons: yes, expected. sorry about that.
17:32:23 <joelr1> dons: will pull your lambda bot patches to see the serialization
17:32:30 <joelr1> dons: thanks in advance
17:32:46 <treitter> is there a function that's basically :: Int -> English String     (ie, foo 5 = "five")
17:32:58 <shapr> show
17:33:02 <sorear> yes.
17:33:09 <shapr> Oh, that's not what you want.
17:33:12 <treitter> shapr: no, spelled out
17:33:25 <treitter> I think Lisp has something like "ordinal"
17:33:32 <shapr> I've seen that given as a homework problem, so I'm sure you could find source on the 'net.
17:33:33 <sorear> it shouldn't be hard to write
17:33:45 <sorear> hint: pattern matching
17:34:57 <treitter> sorear: yeah. With some exceptions (like "forty")
17:35:20 <shapr> dpiponi: "You could have invented monads" is great!
17:35:23 <shapr> dpiponi: thanks!
17:35:33 <treitter> well, I guess that wouldn't be any more exceptional than any of the other tens
17:37:34 <bd_> ?where haskell-src
17:37:34 <lambdabot> I know nothing about haskell-src.
17:39:02 <bd_> hmm, what's the darcs dependency haskell-src?
17:39:28 <bd_> [in lambdabot]
17:39:55 <dpiponi> shapr: some day I'll rewrite it as literate haskell to eliminate the typos
17:39:57 <beschmi> treitter: CL supports (format nil "~r" 1234) ==> "one thousand two hundred thirty-four" , perhaps you can look at the sbcl/clisp sources if they do something clever
17:40:34 <treitter> beschmi: awesome. Thanks!
17:40:39 <allbery_b> Language.Haskell modules, used to be part of base, in 6.6 source distribution they're part of extralibs
17:40:43 <sorear> bd_: http://darcs.haskell.org/packages/haskell-src
17:40:45 <Anon4888> Is there a literate haskell extension?
17:40:46 <dons> bd_ Language.Haskell.*
17:40:53 <dons> Anon4888: yes, its called literate haskell
17:40:57 <dons> and goes in .lhs files
17:41:02 <Anon4888> cool i'll check it out
17:41:04 <dons> wihch maybe either be :
17:41:05 <dons> > 1 +2  -- in this form
17:41:06 <lambdabot>  3
17:41:07 <dons> or in a ltex form
17:41:10 <dons> latex
17:41:12 <bd_> sorear, dons: thanks
17:41:16 <bd_> @where+ haskell-src http://darcs.haskell.org/packages/haskell-src
17:41:17 <lambdabot> Done.
17:41:29 <nornagon> ?src flodl
17:41:30 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:41:34 <nornagon> ?src foldl
17:41:34 <lambdabot> foldl f z xs = lgo z xs
17:41:34 <lambdabot>     where lgo z []     =  z
17:41:34 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:42:33 <nornagon> ?hoogle [Char] -> [Int]
17:42:34 <lambdabot> No matches, try a more general search
17:42:42 <bd_> ?where zlib
17:42:42 <lambdabot> darcs get http://haskell.org/~duncan/zlib
17:42:49 <newsham> > map fromEnum "this is a test" :: [Int]
17:42:50 <lambdabot>  [116,104,105,115,32,105,115,32,97,32,116,101,115,116]
17:43:17 <nornagon> newsham: looking to grab the individual digits
17:43:25 <nornagon> actually I'd rather a [Int] -> Int
17:43:33 <nornagon> er
17:43:37 <nornagon> Int -> [Int]
17:43:43 <nornagon> ?hoogle Int -> [Int]
17:43:43 <lambdabot> No matches, try a more general search
17:43:53 <newsham> > map read (show 123) :: [Int]
17:43:53 <lambdabot>  Couldn't match `String' against `Char'
17:44:02 <nornagon> ?hoogle Integral a => a -> [a]
17:44:02 <lambdabot> Prelude.repeat :: a -> [a]
17:44:02 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
17:44:02 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
17:44:19 <newsham> > map (read.return) (show 123) :: [Int]
17:44:21 <lambdabot>  [1,2,3]
17:44:25 <nornagon> neat.
17:44:39 <nornagon> how on earth does that work.
17:44:48 <newsham> > show 123
17:44:49 <lambdabot>  "123"
17:44:55 <newsham> > return '1'
17:44:56 <lambdabot>   add an instance declaration for (Show (m Char))
17:45:03 <newsham> > return '1' :: [Char]
17:45:04 <lambdabot>  "1"
17:45:08 <newsham> > read "1" :: Int
17:45:09 <lambdabot>  1
17:45:20 <nornagon> ah. :)
17:45:37 <bd_> ?paste
17:45:38 <lambdabot> http://paste.lisp.org/new/haskell
17:45:45 <dons> sorear: where's Nick defined now?
17:45:57 <treitter> ghci tells me that     map (10 -) :: (Num a) => [a] -> [a], but if I    let subEachFromTen = map (10 -)    then   :t subEachFromTen ==> subEachFromTen :: [Integer] -> [Integer]
17:46:01 <dons> ah got it
17:46:06 <treitter> why did ghci make it less general?
17:46:22 <sorear> MR
17:46:33 <nornagon> why does return make 'a' into "a"?
17:46:37 <nornagon> ohh, [] is the monad
17:46:38 <sorear> treitter: monomorphism restriction
17:46:41 <dons> ?src [] >>=
17:46:42 <lambdabot> m >>= k     = foldr ((++) . k) [] m
17:46:44 <newsham> yup, list monad.
17:46:45 <dons> ?src [] return
17:46:46 <lambdabot> return x    = [x]
17:46:46 <sorear> @src [] return
17:46:46 <lambdabot> return x    = [x]
17:46:58 <nornagon> how zany
17:47:12 <treitter> sorear: wow. That's a mouthful :) - I'll look that up
17:47:18 <nornagon> so what do do-blocks look like in the context of []? :)
17:47:29 <sorear> treitter: it's in the haskell report
17:47:30 <dons> the same
17:47:35 <sorear> nornagon: list comprehensions
17:47:36 <newsham> > map (read . (: [])) (show 123)
17:47:36 <lambdabot>  Add a type signature
17:47:42 <newsham> > map (read . (: [])) (show 123) :: [Int]
17:47:43 <lambdabot>  [1,2,3]
17:47:58 <sorear> > do x <- [1..200] ; guard (even x) ; return (x*x)
17:47:59 <lambdabot>  [4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,1444,...
17:48:03 <glguy> ?type digitToInt
17:48:05 <lambdabot> Char -> Int
17:48:12 <glguy> > map digitToInt "123"
17:48:13 <lambdabot>  [1,2,3]
17:48:23 <newsham> ahh, glguy's is perdier
17:48:30 <sorear> in fact in the 1.4 days comprehensions and do notation were both monad sugar
17:48:37 <nornagon> mm :)
17:48:55 <nornagon> ?index digitToInt
17:48:56 <lambdabot> Data.Char
17:48:57 <syntaxfree> monad comprehensions sound mighty cool.
17:49:03 <syntaxfree> we could at least have functor comprehensions, gah.
17:49:27 <nornagon> :t guard
17:49:29 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
17:49:39 <nornagon> ... MonadPlus?
17:49:41 <syntaxfree> anyway, I can't find any material on program transformation in the Haskell wiki.
17:49:51 <sorear> MonadZero, actually
17:49:52 <syntaxfree> Maybe I'm not looking for the right keywords. Any pointers?
17:49:56 <sorear> ?src MonadPlus
17:49:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:50:05 <sorear> ?src [] mzero
17:50:06 <lambdabot> mzero = []
17:50:08 <sorear> ?src [] mplus
17:50:08 <lambdabot> mplus = (++)
17:50:14 <sorear> ?src Maybe mzero
17:50:14 <lambdabot> mzero = Nothing
17:50:17 <sorear> ?src Maybe mplus
17:50:17 <lambdabot> Nothing `mplus` ys  = ys
17:50:17 <lambdabot> xs      `mplus` _ys = xs
17:50:25 <dons> sorear: so the source for a clas should return the class method types?
17:50:26 <shapr> ?src cute error messages
17:50:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:50:47 <sorear> dons: that's what I was expecting, yes
17:50:56 <dons> good idea :)
17:51:07 <newsham> ?src one finger
17:51:07 <lambdabot> Source not found. My mind is going. I can feel it.
17:51:32 <bd_> ?src [] readsPrec
17:51:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:51:41 <Anon4888> dons: cool, I think I'd seen the literate stuff when I was first browsing the haskell docs and had forgetten about it
17:51:44 * shapr throws an ink pen at newsham .. for pen testing of course..
17:51:48 <Anon4888> dons: thanks!
17:52:00 <syntaxfree> @free map
17:52:02 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
17:52:21 <dons> Anon4888: this channel actually evaluates literate haskell, if you've noticed :)
17:52:30 <newsham> *rubs a balloon against shapr's head... for static analysis*
17:52:32 <syntaxfree> someone mentioned another theorem about map earlier today.
17:52:33 <Anon4888> Yes
17:52:39 <bd_> @free?
17:52:39 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:52:43 <shapr> newsham: haha
17:52:47 <Anon4888> > 1
17:52:48 <lambdabot>  1
17:52:49 <allbery_b> @help free
17:52:49 <lambdabot> free <ident>. Generate theorems for free
17:52:55 <bd_> heh
17:53:06 <syntaxfree> well, yes. I just got the free theorem for map. There was a simpler corollary to that though.
17:53:07 <sorear> @goog theorems for free
17:53:10 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
17:53:12 <syntaxfree> Maybe I just need to work it out for myself.
17:53:18 <bd_> @free (>>==)
17:53:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:53:19 <bd_> @free (>>=)
17:53:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:53:27 <syntaxfree> Heh.  "Theorems for free" is the first thing I ever read about FP.
17:53:45 <syntaxfree> I didn't get most of it at the time, and I guess I still don't understand the technical parts, but it fascinated me.
17:54:09 <syntaxfree> Haskell compilers use free theorems for fusion-like optimization nowadays?
17:54:17 <sorear> yes
17:54:28 <sorear> specific free theorems, like the map one
17:54:39 * shapr runs newsham through an ethernet-connected drier ... for network fuzzing...
17:54:44 <syntaxfree> there was a simpler map theorem. The free theorem for map requires an equality checking a compiler can't do.
17:54:47 <syntaxfree> @free map
17:54:48 <sorear> I don't think ghc automatically generates rewrite rules yes
17:54:49 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
17:54:50 <sorear> I don't think ghc automatically generates rewrite rules yet
17:55:03 <syntaxfree> I'm trying to produce the corollary on my head.
17:55:14 <syntaxfree> sorear: is there research being done in that?
17:55:29 <syntaxfree> oh, of course.
17:55:31 <sorear> does that mean I shouldn't tell you ? [the corrolary]
17:55:33 <syntaxfree> map f . h = map f . map h
17:55:35 <syntaxfree> I'm silly.
17:55:56 <sorear> put it the other way around, map fission is a pessimization
17:56:10 <syntaxfree> > map ((*3) . (*2)) [1..10]
17:56:12 <lambdabot>  [6,12,18,24,30,36,42,48,54,60]
17:56:26 <syntaxfree> > map (*3) (map (*2) [1..10])
17:56:27 <lambdabot>  [6,12,18,24,30,36,42,48,54,60]
17:56:32 <syntaxfree> ; )
17:56:46 <sorear> map (*3) . (*2) = map (*3) . map (*2) -- this doesn't look right
17:56:58 <dons> missing parens
17:57:50 <dons> mm! http://www.haskell.org/pipermail/haskell-cafe/2007-January/021178.html
17:57:53 <lambdabot> Title: [Haskell-cafe] GADTs are expressive, http://tinyurl.com/vac6p
17:58:05 <syntaxfree> is there a synonym of "research program"?
17:58:26 <syntaxfree> "This is probably what motivated the research program of program construction calculi in first place."
17:58:27 <syntaxfree> That sucks.
17:58:44 <Anon4888> Just drop the first program?
17:58:51 <treitter> how would I turn "5:17" into (5, 17)?
17:59:07 <sorear> 5:17 is just silly
17:59:13 <treitter> sorear: time
17:59:27 <sorear> ooh
17:59:27 <allbery_b> chain reads calls?
17:59:27 <treitter> is there anything like the split function?
17:59:28 <syntaxfree> "research program" implies that there's a specific, separated subculture in CS research around program construction calculi.
17:59:29 <shapr> treitter: Make a read instance for your own Time type?
17:59:41 <glguy> > (\[a,b] -> (a,b)) [5,17] -- like this, assuming it's what you meant
17:59:42 <lambdabot>  (5,17)
17:59:49 <syntaxfree> god, sometimes Haskell is so far above other programming languages, I'm just impressed!
18:00:00 <sorear> > (id *** tail) . break (==':') $ "5:17"
18:00:01 <lambdabot>  ("5","17")
18:00:11 <glguy> oh
18:00:11 <sorear> > (read *** read . tail) . break (==':') $ "5:17"
18:00:12 <lambdabot>  Add a type signature
18:00:25 <sorear> > ((read *** read . tail) . break (==':') $ "5:17") :: (Int,Int)
18:00:27 <lambdabot>  (5,17)
18:00:46 <glguy> > reads "5:17" :: (Int,String)
18:00:47 <lambdabot>  Couldn't match `(Int, String)' against `[(a, String)]'
18:00:53 <glguy> > reads "5:17" :: [(Int,String)]
18:00:54 <lambdabot>  [(5,":17")]
18:01:01 <glguy> > reads "5 : 17" :: [(Int,String)]
18:01:02 <lambdabot>  [(5," : 17")]
18:01:31 <sorear> > reads "23:12" :: [(Int,String)]
18:01:32 <lambdabot>  [(23,":12")]
18:01:49 * sorear was expecting [(23,":12"),(2,"3:13")]
18:01:57 <Stinger_> @type reads
18:01:58 <lambdabot> forall a. (Read a) => ReadS a
18:02:33 <allbery_b> hm.  not sure I'd consider that an "alternative parse" for (haskell-)normal meanings of "parse"
18:03:10 <sorear> allbery_b: is 333 33 3 or 3 33, if it's two ints?
18:03:48 <glguy> sorear: the second element in the tuple is always a String
18:03:55 <treitter> also, what's the opposite of   show 5?  (ie "5" ==> 5)
18:04:03 <syntaxfree> so, um, Haskell compilers basically don't use Wadler's "Theorems for free". Do they use [some of] the theorems present in, say, Meijer's "Functional programming with bananas yadda yadda yadda"?
18:04:04 <glguy> rea
18:04:04 <glguy> d
18:04:06 <allbery_b> sorear: absent a space, it's *one* int, is my point
18:04:29 <allbery_b> :t read
18:04:31 <lambdabot> forall a. (Read a) => String -> a
18:04:46 <treitter> allbery_b: ah, right. Thanks
18:05:06 <shapr> dons: Hey, do you know Luke Gorrie?
18:05:22 <glguy> > [a | (a,_) <- reads "333"] :: [Int] -- for example
18:05:23 <lambdabot>  [333]
18:05:47 <allbery_b> I assume reads follows Haskell rules, and having Haskell decide "333" could mean "3 33" when it uses curried functions would be fairly bad
18:05:49 <syntaxfree> that is, are Haskell compilers aware of Squiggol, or some other calculu?
18:07:38 <dons> shapr: hmm, the name rings a bell.
18:08:42 <shapr> dons: He's an Erlang guy, but he seems like the kind of person who'd fit right into the UNSW FPers, and not just because he's from .au originally.
18:09:01 <treitter> sorear: does the "break (==":") $ "5:17"" part get us much? It seems to just return (["5:17"],[])
18:09:46 <dons> > break (==':') "5:17"
18:09:53 <lambdabot>  ("5",":17")
18:10:10 <treitter> hm. I must've had slightly different syntax when I re-typed it
18:10:26 <allbery_b> double vs. single quotes?  althought hat should be a type error I'd think
18:10:58 <treitter> is there any simple way to go    "5:17" ==> ["5", ":", "17"] ?
18:11:21 <sorear> > groupBy (equating (==':')) "5:17"
18:11:22 <lambdabot>   Not in scope: `equating'
18:11:30 <treitter> or, preferably,  "5:17" ==> ["5","17"]
18:11:31 <sorear> ?let equating f x y = f x == f y
18:11:33 <lambdabot> Defined.
18:11:34 <allbery_b> equating is HED, no?
18:11:37 <sorear> > groupBy (L.equating (==':')) "5:17"
18:11:38 <lambdabot>  ["5",":","17"]
18:11:39 <allbery_b> er, HEAD
18:11:40 <glguy> > head [(a,b) | (a,':':bs) <- reads "5:17", let b = read bs] :: (Int,Int)
18:11:42 <lambdabot>  (5,17)
18:11:47 <newsham> ?src lines
18:11:48 <lambdabot> Source not found. Are you on drugs?
18:11:49 <sorear> allberyb: 6.6
18:12:01 <newsham> ?src words
18:12:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:12:04 <allbery_b> hm, thought it came in with `on`
18:12:07 <dons> > let (a,b) = break (==':') "5:17" in [a,[head b], tail b]
18:12:08 <lambdabot>  ["5",":","17"]
18:12:22 <syntaxfree> what's the function composition "o" written like in latex?
18:12:37 <astrolabe> \circ in tex iirc
18:12:37 <dons> sorear: so what's the message I see at startup:
18:12:40 <dons> sending message to bogus server: IrcMessage {msgServer = "freenode", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
18:13:14 <sorear> dons: Seen can't send its startup NAMES because it isn't connected to a server yet
18:13:45 <sorear> I don't know what effect this has
18:14:25 <sorear> I've tested: I join #sorear ; bot autojoins #sorear ; @seen sorear , and it correctly tells me what channels I'm in.
18:14:29 <glguy> fmap read (many1 digit) >> char ':' >> fmap read (many1 digit)
18:15:17 <dons> the msg is a bit ugly though
18:15:44 <sorear> well, I didn't remove it because I didn't understand it
18:16:04 <sorear> (the send $ names, not the error)
18:17:30 <dons> ?version
18:17:45 <allbery_b> oops?
18:18:43 <sorear> @version
18:18:43 <sorear-lambdabot> lambdabot 4p0, GHC 6.7 (Linux i686 2.00GHz)
18:18:43 <sorear-lambdabot> darcs get
18:18:45 <sorear> @quit
18:20:02 <dons> ?bot
18:20:19 <dons> sorear: something funny going on. hmm. irc[freenode] error: IRCRaised thread killed
18:20:20 <shapr> bot dead!
18:20:23 * shapr cries
18:20:46 <dons> ?bot
18:21:00 <sorear> ok, something must have timed out... but why would it kill the reader-thread?
18:21:10 * dons tries again
18:22:05 <sorear> I see the problem
18:22:30 <sorear> IRC.hs:139, runs in plugin context
18:22:41 <dons> I should wait for the fix then?
18:22:50 <sorear> if the timeout kills it, the ThreadKilled will be caught and treated as a network error
18:22:50 <augustss> syntaxfree: to answer a 15 minute old question: haskell compilers use very little squiggol (and similar).  some deforestation (foldr/build)
18:23:12 <augustss> syntaxfree: and the new ByteString uses some cool transformations
18:23:39 * syntaxfree might be incurring in some imprecision in the blog post he's writing, then.
18:23:44 <augustss> syntaxfree: but in general, the side conditions on those theorems are a bit hairy ti check
18:23:53 <syntaxfree> I see.
18:24:01 <syntaxfree> That's probably a very current research program, I reckon.
18:24:15 <syntaxfree> using more theorems in code optimization.
18:24:30 <augustss> for instance, the free theorems are much weaker in the presence of _|_
18:25:08 <syntaxfree> I see.
18:25:15 <syntaxfree> @type build
18:25:15 <sorear> augustss: _|_ is ok. seq isn't.
18:25:39 <dons> ?src build
18:25:45 <nornagon> whee
18:25:46 <nornagon> > english 127
18:25:46 <nornagon> "one hundred and twenty-seven"
18:25:50 <augustss> syntaxfree: i would not discount what the purity does, though.  there are many simpler transformations that are done because they are valid in haskell, but not generally
18:26:10 <augustss> sorear: seq makes things worse.  _|_ is still a problem
18:26:17 <shapr> nornagon: cool!
18:26:21 <dons> yeah, you still have to be careful with bottoms
18:26:22 <syntaxfree> augustss: I'm writing a long, involved defense of purity for a blog.
18:26:26 <dons> i.e. the head fusion rule
18:26:32 <shapr> syntaxfree: Oh I can barely wait!
18:26:34 <dons> you might replace a list of bottoms by a single bottom
18:26:35 <nornagon> ?pl english n = english' $ map digitToInt (show n)
18:26:35 <augustss> syntaxfree: excellent!
18:26:53 <syntaxfree> I might be going a little overboard in starry-eyed awe about program transformation, though.
18:26:53 <dons> and then if seq gets involved with that....
18:27:01 * nornagon prods lb
18:27:11 <dons> nornagon: we're waiting on a patch to land ....
18:27:15 <shapr> nornagon: He's pining for the fnords.
18:27:18 <dons> I might just unpull first
18:27:18 <nornagon> ah.
18:27:33 <augustss> syntaxfree: well, I think there's more to do in the program transformation area
18:27:40 <nornagon> it's okay, i have a local copy :)
18:27:43 <shapr> All over freenode, weeping is heard as lambdabot stays gone for MINUTES!
18:27:55 <dons> ah well, the price for bleeding edge
18:28:24 <sorear> code is fixed
18:28:37 <augustss> syntaxfree: the foldr/build transform used by ghc relies on parametricity (i.e., theorems for free)
18:28:37 <sorear> ... now to test (hah!)
18:28:44 <lambdabot2> I have returned from beyond the redex!
18:28:56 <nornagon> should be succ$lambdabot
18:29:00 * shapr grins
18:29:12 <sorear> yes!
18:29:13 <dons> ?bot
18:29:14 <augustss> syntaxfree: too bad that not all of what ghc does is valid in the precense of seq :(
18:29:21 <shapr> dons: I was just being silly :-)
18:29:25 <dons> :)
18:29:33 <syntaxfree> augustss: ghc should still do it if seq is not used.
18:29:38 <shapr> lambdabot2 works fine though...
18:29:40 * sorear runs an interactive record
18:29:41 <nornagon> ?bots
18:29:41 <sorear-lambdabot> :)
18:29:45 <dons> shapr: yeah, its an older backup
18:29:46 <syntaxfree> if (grep (program, seq) = True) then DoMagic else Cry
18:29:48 <shapr> ah, ok
18:30:05 <dons> shapr: but yes, that was a good point, we can sub in the stable lambdabot2 as needed
18:30:15 <dons> useful to remember in future
18:30:30 <dons> > 1+2
18:30:46 <dons> ?version
18:30:46 <sorear-lambdabot> lambdabot 4p0, GHC 6.7 (Linux i686 2.00GHz)
18:30:46 <sorear-lambdabot> darcs get
18:30:53 <dons> 6.7:)
18:30:57 <shapr> wow
18:30:58 <augustss> syntaxfree: it's not too bad.  it only affects total correctness, not partial
18:31:03 <nornagon> gr, how do I do a:b@[_,_] ?
18:31:08 <nornagon> in a pattern
18:31:19 <shapr> nornagon: huh?
18:31:23 <sorear> dons: it's lying
18:31:24 <dons> ?type map
18:31:26 <nornagon> which would otherwise be [a,b,c] followed by a reference to [b,c]
18:31:26 <sorear-lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:31:29 <sorear> dons: it's a 6.6 lambdabot
18:31:34 <dons> ah ok
18:31:44 <augustss> syntaxfree: i.e., you'll never get the wrong answer
18:31:50 <sorear> dons: the configure script failed to notice the -w /usr/bin/ghc-6.6 option
18:31:59 <syntaxfree> oh, cool.
18:32:04 <sorear> dons: patch sent, minimally tested
18:32:22 <syntaxfree> maybe ghc should have "unsafe" flags that people can use for low-reliance systems.
18:32:23 * dons checks inbox
18:32:28 <syntaxfree> like --ffast-math and whatnot.
18:32:38 <dons> syntaxfree: it does have those
18:32:39 <syntaxfree> (-ffast-math in c compilers, I mean)
18:32:42 <allbery_b> nornagon: still not getting it.  (a:b:xs)?
18:32:44 <dons> -fexcess-precision -optc-ffast-math
18:32:51 <augustss> syntaxfree: what can happen is that you get an answer when you shouldn't, and vice versa
18:32:54 <dons> -optc-O3 -- can introduce segfaults(!)
18:33:16 <nornagon> allbery_b: not quite; i want to match an array of three elements, but i only care about having the first separate to the rest
18:33:20 <syntaxfree> not --ffast-math, specifically, bu t flags that enable program transformation-based optimizations that are unsafe in the presence of _|_ and seq.
18:33:26 <dons> (sometimes i think it was a mistake to write gcc in C)
18:33:33 <augustss> dons: really?  because gcc is buggy?
18:33:38 <nornagon> i guess i could do a@[_,_,_] and use head a and tail a
18:33:44 <syntaxfree> writing a new C compiler in Haskell would show them snobs how it's done!
18:33:46 <syntaxfree> ; )
18:33:56 <allbery_b> or [a,b,_]
18:34:05 <nornagon> allbery_b: i need to know what the _ is though
18:34:14 <nornagon> for passing on to some other functions
18:34:14 <dons> well, imagine if they'd written it in ML  (which would have been a valid choice at the time, I think)
18:34:26 <allbery_b> so [a,b,c]
18:34:28 <sorear> syntaxfree: JohnMeacham has written about monadic code motion transformations in abstract C--
18:34:39 <nornagon> allbery_b: but then i have to reconstruct the array [b,c]
18:34:56 <allbery_b> oh, I get it.  no, I don't think you can do that in a single pattern expression
18:34:56 <syntaxfree> sorear: if Pugs is doing the marketing wonders it's doing for Haskell, imagine a good optimizing C compiler
18:35:03 <nornagon> darn.
18:35:05 <syntaxfree> Even if the parsing step uses Parsec or something and is slow-ish.
18:35:16 <nornagon> i guess i'll just use that a@[_,_,_] then
18:35:25 <sorear> http://repetae.net/john/repos/jhc/docs/c-minus-monad.txt
18:35:38 <nornagon> i'd love to see a haskell C/C++ compiler :)
18:36:08 * allbery_b tried that the other day, slightly differently ( (a:xs@(b:_:[])) ) and gave up
18:36:12 <sorear> Step 1: parse C into monadic Haskell.  Step 2: run ghc -fasm
18:36:20 <sorear> how slow would that be :)
18:36:22 <nornagon> heh.
18:36:33 <nornagon> allbery_b: heh.
18:36:34 <allbery_b> maybe we can talk someone into adding that to h' :>
18:36:58 <allbery_b> hm, or maybe it just needed more parens
18:37:19 <sorear> I'm about to run the failure case
18:37:24 <allbery_b> > let f (a:(xs@(b:_:[]))) = undefined in f
18:37:28 <lambdabot>  Add a type signature
18:37:30 <dons> ?bot
18:37:30 <sorear-lambdabot> :)
18:37:32 <allbery_b> huh
18:37:34 <lambdabot> :)
18:37:45 <allbery_b> > let f (a:(xs@(b:_:[]))) = (5 :: Int) in f
18:37:45 <lambdabot>  Add a type signature
18:37:49 <dons> sorear-lambdabot: @part #haskell
18:37:55 <sorear> lambdabot is lagging because I ran @list-all
18:38:07 <dons> sorear: I still see this msg: Main: caught (and ignoring) IRCRaised thread killed
18:38:11 <dons> just on joining
18:38:12 <allbery_b> > let f (a:(xs@(b:_:[]))) :: [Int] -> Int = 5 in f
18:38:12 <lambdabot>  Parse error
18:38:20 <sorear> ... which was guaranteed to kill lb-of-30-mins-ago
18:38:23 <dons> ?src Functor
18:38:24 <lambdabot> class  Functor f  where
18:38:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:38:33 <allbery_b> > let f :: [Int] -> Int;  f (a:(xs@(b:_:[]))) = 5 in f
18:38:34 <dons> ?src [] fmap
18:38:35 <lambdabot> fmap = map
18:38:35 <lambdabot>  <[Int] -> Int>
18:38:39 <allbery_b> aha!
18:38:41 <dons> sorear: ok good sign
18:38:56 <allbery_b> nornagon: see above
18:39:04 <nornagon> ... scary
18:39:17 <sorear> 'thread killed' means one of your signal callbacks ran into the time limit, which means Base failed to handle it.
18:39:20 <nornagon> but okay!
18:40:16 <sorear> dons: check the autojoin
18:40:26 <dons> ?time
18:40:30 <dons> oops
18:40:36 <sorear> dons: lambdabot joins 20 channels
18:40:40 <dons> ah right
18:40:49 <sorear> that's 40 seconds in the RPL_WELCOME handler
18:40:56 <sorear> after 15, the thread is killed
18:41:19 <sorear> suprise! lambdabot is in 5 channels now
18:41:38 <augustss> @src Monad
18:41:39 <lambdabot> class  Monad m  where
18:41:39 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:41:39 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:41:39 <dons> ?seen lambdabot
18:41:41 <lambdabot>     return      :: a -> m a
18:41:43 <lambdabot>     fail        :: String -> m a
18:41:45 <lambdabot> Yes, I'm here. I'm in #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
18:41:47 * augustss hugs dons
18:42:17 <dons> sorear: so what is happening? its joining bit-by-bit?
18:42:23 <augustss> @src (>>)
18:42:23 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:42:31 <dons> ?src >>
18:42:32 <lambdabot> m >> k      = m >>= \_ -> k
18:42:34 * augustss unhugs dons
18:42:35 <dons> (I'm not sure maybe they should be qualified)
18:42:39 <dons> ?src Either >>
18:42:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:42:44 <dons> ?src Maybe >>
18:42:45 <lambdabot> (Just _) >>  k      = k
18:42:45 <lambdabot> Nothing  >>  _      = Nothing
18:42:49 * augustss hugs dons again
18:43:03 <augustss> @type >>
18:43:04 <SamB> are these quips MS-inspired?
18:43:04 <lambdabot> parse error on input `>>'
18:43:13 <sorear> bsd sudo
18:43:17 <augustss> consistency?
18:43:21 <dons> so the idea is that it should be: Class method
18:43:30 <dons> but the syms should be haskell style, I guess :)
18:43:36 * dons fixes
18:43:48 <nornagon> allbery_b: for your next trick, can you pattern match on a five-element array, separating the first two from the last two?
18:43:49 <sorear> lambdabot claims to be in #haskell-blah, but it isn't.
18:43:56 <sorear> @join #haskell-blah
18:44:03 <dons> sorear: so its not joining everything properly yet?
18:44:07 <dons> what's going on?
18:44:07 <nornagon> (a@(_:_):b@(_:_:_:[])) doesn't seem to work :P
18:44:12 <dons> (or, are you looking into it?) :)
18:44:15 <SamB> yes it is!
18:44:27 <SamB> it even responds to @bot
18:44:29 <allbery_b> nornagon:  each x@(...) needs to itself be parenthesized
18:44:31 <SamB> sorear: maybe you aren't?
18:44:39 <sorear> /whois lambdabot
18:44:43 <nornagon> allbery_b: ah, okay :)
18:44:50 <sorear> no mention of #haskell-blah
18:45:03 <allbery_b> ((a@(_:_)):(b@(_:_:_:[]))) should work
18:45:06 <nornagon> hm
18:45:12 <SamB> it must be that mode, so that you only see shared channels
18:45:12 <nornagon> still getting errors about infinite types
18:46:22 <SamB> oh, wait, no, that ain't it -- its just that in the /whois output it says #Haskell-blah
18:46:36 <allbery_b> > let f :: [a] -> [(a,a)]; f ((a@(_:_)):(b@(_:_:_:[]))) = zip a b in f [1..5]
18:46:36 <lambdabot>  Couldn't match the rigid variable `a' against `[a1]'
18:46:48 <allbery_b> oh, wait,  a isn't valid
18:46:56 <nornagon> > let f :: [a] -> [(a,a)]; f ((a@(_:_)):(b@(_:_:_:[]))) = zip (a:[]) b in f [1..5]
18:46:57 <allbery_b> you can't do that because it's not a complete list
18:46:57 <lambdabot>  Couldn't match the rigid variable `a' against `[a1]'
18:47:09 <sorear> SamB: when I'm in #haskell-blah I can see lambdabot.  when I'm not, I can't.
18:47:16 <glguy> Is there another way to write: ListT (return [1..10])
18:47:38 <shapr> augustss: Gee, I thought I was the only person who wildly hugged people :-)
18:47:46 <SamB> sorear: oh. something to do with being unidentified?
18:47:47 <nornagon> glguy: ListT $ return [1..10] ? ;P
18:47:52 <allbery_b> I'm actually surprised it gets to type checking since a can't possibly have a meaningful type
18:47:53 * augustss hugs shapr
18:47:58 <shapr> Yay!
18:48:17 <shapr> augustss: Now I'll never have another nightmares about you.
18:48:24 * SamB jumps on shapr's neck and grabs it!
18:48:27 <shapr> argh!
18:48:28 <augustss> lol
18:48:32 <bd_> glguy: Is the ListT constructor even exported...?
18:48:33 <bd_> :t LiftT
18:48:35 <lambdabot> Not in scope: data constructor `LiftT'
18:48:35 <bd_> :t LiStT
18:48:37 <lambdabot> Not in scope: data constructor `LiStT'
18:48:37 <bd_> >.<
18:48:49 <glguy> bd_: yes , it is exported by Control.Monad.List
18:48:52 <nornagon> :t ListT
18:48:53 <lambdabot> forall a (m :: * -> *). m [a] -> ListT m a
18:48:55 <allbery_b> hm, no, the way haskell does type checking it does get that far, then decides that a@(_:_): indicates an impossible type constraint, I guess
18:48:56 <shapr> augustss: Hey, are you guys going to have Haskell meetups in NYC?
18:48:58 <augustss> shapr: I'm not sure what to think of this nightmare thing. :)
18:49:05 <nornagon> allbery_b: :/
18:49:15 <shapr> augustss: I felt the same way. I've never even met you. It was very weird.
18:49:16 <bd_> ic
18:49:18 <augustss> shapr: they might have.  I move to London soon
18:49:23 <allbery_b> (the second element in a@ has to be  simultanously type a and [a])
18:49:24 <shapr> augustss: Aww
18:49:32 <bd_> glguy: msum $ map return [1..10] ?
18:49:54 <SamB> hmm, has anyone played uniracers? its a quirky game. you play as a one of a number of unicycles with names like Mike and Melissa
18:50:01 <bd_> :t (msum $ map return [1..10]) :: ListT Identity Int
18:50:03 <lambdabot> ListT Identity Int :: ListT Identity Int
18:50:20 <shapr> SamB: It gets mentioned in rec.sports.unicycling sometimes, but I've never tried it.
18:50:24 <bd_> > runIdentity $ runListT $ (msum $ map return [1..10])
18:50:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:51:01 <SamB> it looks kinda stupid when you get a medal ;-
18:51:09 <SamB> oh, oops, lost my mouth there...
18:51:12 <glguy> Cale either wrote, or used a function like that called option
18:51:18 <glguy> for MonadNondetT
18:51:26 <glguy> in the sudoku solver, i believe
18:51:32 <SamB> @hoogle option
18:51:33 <lambdabot> Text.Html.option :: Html -> Html
18:51:33 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
18:51:33 <lambdabot> Text.ParserCombinators.Parsec.Combinator.option :: a -> GenParser tok st a -> GenParser tok st a
18:51:43 <sorear> choice?
18:51:53 <glguy> ?hoogle choice
18:51:53 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
18:51:54 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
18:51:54 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
18:52:38 <SamB> option :: MonadPlus m => a -> m a -> m a; option x p = p `mplus` return x -- ?
18:52:44 <sorear> oh, I was thinking of msum
18:53:46 <nornagon> bd_: hey, another way to write that could be
18:53:50 <nornagon> > [1..10]
18:53:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:53:54 <nornagon> :)
18:54:01 <nornagon> :t runIdentity
18:54:02 <lambdabot> forall a. Identity a -> a
18:54:15 <bd_> nornagon: The Identity was an example, I can't evaluate it without a real base monad
18:54:37 <nornagon> right
18:54:44 <nornagon> @hoogle Identity
18:54:44 <lambdabot> Control.Monad.Identity :: module
18:54:45 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
18:54:45 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
18:54:53 <nornagon> ?src Identity
18:54:53 <lambdabot> Source not found. It can only be attributed to human error.
18:55:00 <bd_> nornagon: it's a trivial monad used to convert a monad transformer into a n ordinary monad
18:55:16 <bd_> and ?src returns function source, not entire modules :)
18:55:39 <nornagon> ?src Maybe
18:55:39 <lambdabot> data Maybe a = Nothing | Just a
18:55:44 <bd_> nornagon: http://darcs.haskell.org/packages/mtl/Control/Monad/Identity.hs
18:55:51 <bd_> nornagon: oh, maybe I'm wrong now :)
18:55:55 <nornagon> ;)
18:56:26 <allbery_b> remember dons has been adding ?src stuff as he goes, it'll get there eventually :)
18:56:46 <syntaxfree> uh, does (map f) . (map g) == map (f .g ) fall in the foldr/build deforestation case someone mentioned before?
18:57:17 <syntaxfree> (I know map is trivially expressed with foldr)
18:58:07 <SamB> well...
18:58:21 <sorear> ?quote ?src
18:58:22 <lambdabot> Plugin `quote' failed with: IRCRaised Text.Regex.Posix.regcomp: error in pattern
18:58:25 <sorear> ?quote \?src
18:58:26 <lambdabot> No quotes match. Where did you learn to type?
18:58:33 <sorear> ?quote src stuff
18:58:33 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
18:58:42 <SamB> I think you need another rule for that to work fully?
18:58:42 <sorear> ?quote dons stuff
18:58:43 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
18:58:43 <lambdabot> true functional programming), and you've got haskell
18:58:43 * allbery_b said "remember", not "@remember"
18:58:44 <glguy> option :: (MonadPlus m) => [a] -> m a
18:58:45 <glguy> option = msum . map return
18:58:50 <sorear> ?quote dons \?src
18:58:50 <glguy> -- http://www.haskell.org/haskellwiki/Sudoku
18:58:50 <lambdabot> No quotes match. stty: unknown mode: doofus
18:58:52 <lambdabot> Title: Sudoku - HaskellWiki
18:58:55 <sorear> ?quote dons ?src
18:58:55 <lambdabot> Plugin `quote' failed with: IRCRaised Text.Regex.Posix.regcomp: error in pattern
18:59:02 <simc> hey guys, i'm a newbie who is working through the "scheme in 48 hours tutorial" and i'm stuck of an exercise
18:59:15 <simc> rewrite parseNumber :: Parser LispVal     parseNumber = liftM (Number . read) $ many1 digit   using do notation
18:59:26 <simc> can anybody give me a hint?
18:59:42 <sorear> ?redo parseNumber = liftM (Number . read) $ many1 digit
18:59:43 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 13}) "Parse error"
18:59:48 <sorear> ?redo liftM (Number . read) $ many1 digit
18:59:48 <glguy> ?src liftM
18:59:48 <lambdabot> liftM (Number . read) $ many1 digit
18:59:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:00:16 <sorear> ?redo liftM (Number . read) any1 digit
19:00:16 <lambdabot> liftM (Number . read) any1 digit
19:00:23 <sorear> ?redo liftM (Number . read) (many1 digit)
19:00:23 <lambdabot> liftM (Number . read) (many1 digit)
19:00:29 <sorear> ?redo fmap (Number . read) (many1 digit)
19:00:30 <lambdabot> fmap (Number . read) (many1 digit)
19:00:48 <sorear> ?redo (many1 digit) >>= (return . Number . read)
19:00:48 <lambdabot> do { a <- (many1 digit); (return . Number . read) a}
19:01:09 <SamB> syntaxfree: see Base.lhs
19:01:19 <SamB> search for mapFB
19:01:26 <simc> hmm, i've tried quite a few things but the types were always wrong
19:01:39 <syntaxfree> SamB: okie. Thanks!
19:01:50 <SamB> notice the "mapFB" RULE, which fuses two mapFBs together
19:02:57 <syntaxfree> will later.
19:03:04 <syntaxfree> the question just popped in my mind.
19:03:08 <syntaxfree> I'm writing a long, involved essay.
19:03:18 * syntaxfree multitasks too much, that's why he never gets anything done.
19:03:20 <glguy> simc: this was for you:
19:03:22 <glguy> ?src liftM
19:03:22 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:03:36 <simc> oh thanks
19:05:39 * syntaxfree thought liftM f m = m >>= return .f   :-P
19:05:50 <syntaxfree> @pl liftM f m = m >>= return .f
19:05:51 <lambdabot> liftM = fmap
19:05:56 <syntaxfree> haha. of course.
19:06:43 <syntaxfree> liftM f m = return . f =<< m
19:07:02 <syntaxfree> liftM f = return.f =<<
19:07:19 <syntaxfree> liftM = flip (.) f return =<<
19:07:32 <syntaxfree> er, that's still liftM f. How do I get f out of there?
19:08:01 <syntaxfree> @pl l f = return . f =<<
19:08:01 <lambdabot> (line 1, column 5):
19:08:02 <lambdabot> unexpected "="
19:08:02 <lambdabot> expecting variable, "(", operator or end of input
19:08:10 <syntaxfree> @pl f = (return . f) =<<
19:08:11 <lambdabot> (line 1, column 3):
19:08:11 <lambdabot> unexpected "="
19:08:11 <lambdabot> expecting variable, "(", operator or end of input
19:08:27 <syntaxfree> @pl l f = ((return .f ) =<<)
19:08:27 <lambdabot> l = fmap
19:08:31 <syntaxfree> gah.
19:08:37 <glguy> liftM f = (=<<) (return . f) --- step one
19:08:46 <syntaxfree> @pl l f = ((return .f) + )
19:08:46 <lambdabot> l = (+) . (return .)
19:08:53 <glguy> liftM f = (=<<) . (return .) --- step two?
19:09:01 <glguy> ?pl (=<<) . (return .)
19:09:02 <lambdabot> fmap
19:09:05 <glguy> yea!
19:09:20 <syntaxfree> yes, yes.That's what you get from substituting f as well.
19:09:33 * syntaxfree wonder if one can make an arithmetic monad where bind is (+)
19:09:48 <Anon4888> point free style reminds me of doing calculus without coordinates
19:10:10 <glguy> ?pl flip (>>=) . (return .)
19:10:10 <lambdabot> fmap
19:10:25 <syntaxfree> @free fmap
19:10:27 <lambdabot> Expected variable or '.'
19:10:35 <glguy> ?pl flip (.) (>>=) ((.) return)
19:10:35 <lambdabot> (return .) . (>>=)
19:10:36 <nornagon> :t >>=
19:10:38 <lambdabot> parse error on input `>>='
19:10:40 <nornagon> :t (>>=)
19:10:42 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:10:42 <Anon4888> simple, elegant, and takes forever to figure out
19:10:45 <nornagon> :t (<<=)
19:10:46 <lambdabot> Not in scope: `<<='
19:10:50 <nornagon> :t (=<<)
19:10:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
19:10:57 <glguy> ?pl  (.) (flip (>>=)) ((.) return)
19:10:57 <lambdabot> fmap
19:11:01 <syntaxfree> nornagon (=<<) is flip (>>=)
19:11:08 <nornagon> syntaxfree: i see that :)
19:11:10 <syntaxfree> that is, b =<< a = a >>= b
19:11:14 <nornagon> ?src (=<<)
19:11:15 <lambdabot> Source not found. Take a stress pill and think things over.
19:11:24 <glguy> ?pl  flip (>>=) . (.) return
19:11:24 <lambdabot> fmap
19:11:35 * glguy is done
19:11:39 <Anon4888> ya broccoli brains
19:13:19 * allbery_b wonders if there is some test suite to validate that a monad obeys the monadic laws
19:13:52 <bd_> mm, I bet you could convince quickcheck to do it
19:14:23 <bd_> you'd need to write a Gen instance for your monad of course
19:14:25 <sorear> ?scheck (\s f -> (return s >>= f) == f s ) :: Char -> (Char -> [Char]) -> Bool
19:14:37 <sorear> @check (\s f -> (return s >>= f) == f s ) :: Char -> (Char -> [Char]) -> Bool
19:14:39 <lambdabot>  OK, passed 500 tests.
19:14:39 <syntaxfree> are type sigs allowed in where blocks?
19:14:45 <glguy> yes
19:14:45 <allbery_b> yes
19:14:49 <SamB> but, don't try to run it on QuickCheck's monad ;-)
19:15:03 <sorear> @check (\s f -> (return s >>= f) == return s ) :: Char -> (Char -> [Char]) -> Bool
19:15:04 <lambdabot>  Falsifiable, after 0 tests: '\357356', <Char -> [Char]>
19:15:21 <syntaxfree> what is allowed in a Haskell module that isn't in a where block?
19:15:38 <syntaxfree> data declarations, type class declarations, instance declarations...
19:15:38 <glguy> import? default?
19:15:43 <syntaxfree> import, too.
19:15:47 <syntaxfree> what *is* default?
19:15:47 <SamB> imports aren't
19:15:54 <SamB> imports are only allowed at the top
19:15:58 <allbery_b> default is how haskell figures out what type to use for e.g. 3
19:16:05 <syntaxfree> oh.
19:16:11 <sorear> @check (\f -> (join . join $ f) == (join . fmap join $ f) ) :: [[[Char]]] -> Bool
19:16:16 <SamB> fixity declarations
19:16:17 <lambdabot> Terminated
19:16:33 <allbery_b> (Prelude declares default(Double, Integer) IIRC, so the typechecker tries DOuble first and falls back to Integer)
19:16:35 <syntaxfree> wait, are you saying data declarations can be placed in a where block, or you implicitly agreed with me?
19:16:53 <allbery_b> I accepted those as givewn
19:17:06 <Terabyte> Hey
19:17:26 * SamB nybbles on Terabyte
19:17:26 <sorear> @users
19:17:27 <lambdabot> Maximum users seen in #haskell: 299, currently: 272 (91.0%), active: 16 (5.9%)
19:17:29 <allbery_b> basically you can have anything related to a function definition, as I understand it
19:18:21 <Terabyte> I came here earlier asking about Returning a list containing no duplicates given a list of items containing duplicates e.g. [1,2,3,3,3] -> [1,2,3]... sombody mentioned the solution could be made using foldr (or foldr1) can't remember.. I still can't see how that is done.. anybody want to demonstrate?
19:19:02 <Terabyte> I did it recursivly... but i'm still interested in the foldr way
19:19:03 <bd_> :t filterAccum
19:19:05 <lambdabot> Not in scope: `filterAccum'
19:19:07 <bd_> alas
19:19:13 <syntaxfree> > nub [1,2,3,3,3,3]
19:19:15 <lambdabot>  [1,2,3]
19:19:15 <allbery_b> * syntaxfree wonder if one can make an arithmetic monad where bind is (+)
19:19:21 <Terabyte> without the nub :)
19:19:46 <syntaxfree> > foldl (flip elem) [] [1,2,3,3,3,3]
19:19:47 <lambdabot>  Couldn't match `[b]' against `Bool'
19:19:54 <syntaxfree> er,
19:19:56 <allbery_b> I think you'd need a wrpper object which was an instance of Num, to avoid type confusion.  or maybe it's just humans that would get confused
19:20:04 <dons> sorear, how do I get the nick out of a Nick?
19:20:17 <syntaxfree> bah. I'm getting distracted again.,
19:20:23 <dons> nName seems to give me "#haskell", when I'm looking for "dons"
19:20:42 <bd_> > let comb Nothing x = [x]; comb (Just x) y | x == y = [] | otherwise = [y]; uniq l = foldr (\e (p, l) -> (comb p e) ++ l) (Nothing, []) l in uniq [1,2,3,3,3]
19:20:42 <lambdabot>  Couldn't match `(Maybe a, [a])' against `[a]'
19:20:42 <glguy> > foldr (\x y -> if x `elem` y then y else x:y) [] [1,1,2,2,3,3,4,1]
19:20:44 <lambdabot>  [2,3,4,1]
19:20:52 <sorear> if what you want isn't in nName, it's in nTag
19:20:52 <glguy> > foldr (\x y -> if x `elem` y then y else x:y) [] [1,1,2,2,3,3,4,1] -- glguy ftw?
19:20:54 <lambdabot>  [2,3,4,1]
19:20:55 <dons> > S.toList (S.fromList [1,2,3,3,3])
19:20:57 <lambdabot>  [1,2,3]
19:21:00 <SamB> nTag?
19:21:00 <bd_> > let comb Nothing x = [x]; comb (Just x) y | x == y = [] | otherwise = [y]; uniq l = foldr (\e (p, l) -> (Just e, (comb p e) ++ l)) (Nothing, []) l in uniq [1,2,3,3,3]
19:21:02 <lambdabot>  (Just 1,[1,2,3])
19:21:04 <SamB> what a strange name?
19:21:14 <syntaxfree> allbery: do-notation sugar allows for some pretty obfuscated Haskell, specially if you're willing to break the monad laws.
19:21:15 <sorear> dons: Module.target is Reply-To, not From
19:21:22 <dons> ah oops
19:21:22 <goltrpoat> > map ($ 2) $ [(*),(+),(-)] <*> [1,2,3]
19:21:23 <lambdabot>   Not in scope: `<*>'
19:21:29 <bd_> > let comb Nothing x = [x]; comb (Just x) y | x == y = [] | otherwise = [y]; uniq l = snd $ foldr (\e (p, l) -> (Just e, (comb p e) ++ l)) (Nothing, []) l in uniq [1,2,3,3,3] -- Terabyte, here's a way to do it, it can be improved in a number of ways :)
19:21:30 <lambdabot>  [1,2,3]
19:21:32 <goltrpoat> no Applicative?
19:21:34 <sorear> you want 'sender msg' ?
19:21:36 <bd_> [for one, foldl might be faster]
19:21:49 <glguy> Terabyte: my foldr solution was for you
19:22:00 <Terabyte> thanks glguy and others :)
19:22:01 <dons> sorear: I'm writing:   process m msg whoAsked "localtime" []     = do
19:22:13 <dons> where we find out who asked, and use that for who to query the time of
19:22:19 <bd_> [note: my solution assumes the list is sorted or otherwise all unique elements aree groupd]
19:22:26 <dons> so I tried:     let n = Msg.nName whoAsked
19:22:27 <sorear> dons: I think you want (sender msg)
19:22:31 <dons> but that seems to return the chan (?)
19:22:35 <Terabyte> it could be any list type in any order btw ;)
19:22:38 <goltrpoat> dons:  lambdabot doesn't import Control.Applicative, it seems
19:22:43 <dons> goltrpoat: that's right
19:22:51 <dons> (it will, given ghc 6.6....)
19:22:58 <goltrpoat> ah right
19:23:00 <sorear> dons: it's a positional parameter, and whoAsked is getting bound to the reply-to
19:23:14 <dons> ah ok. my comments are confusing me then :)
19:23:15 <dons> cheers
19:23:24 <goltrpoat> just started looking at it.  wild wacky stuff.
19:23:54 <dons> ?src Traversable
19:23:54 <lambdabot> class (Functor t, Foldable t) => Traversable t where
19:23:55 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
19:23:55 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
19:23:56 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
19:23:58 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
19:24:05 <dons> ?src Applicative
19:24:06 <lambdabot> Source not found. Take a stress pill and think things over.
19:24:10 <dons> ah need to add that
19:24:37 <SamB> @src Applicative
19:24:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:24:45 <dons> sorear: where's this 'sender' function?
19:25:03 <allbery_b> hm, the bigger problem with >>= is that it expects a function
19:25:13 <SamB> hahaha
19:25:14 <sorear> dons: Message
19:25:20 <sorear> (the typeclass)
19:25:30 <dons> hmm, is that new?
19:25:35 <allbery_b> you might be able to do it with church numerals or something
19:25:51 <dons> I don't see it in my Message class
19:25:53 <sorear> nope
19:26:02 <dons>     nick        :: a -> Nick ?
19:26:14 <sorear> yeah, that "sender" :)
19:26:18 <dons> ah ok
19:26:19 <dons> :)
19:26:48 <Terabyte> GLGUY: what is \x y -> in your solution for?
19:26:57 <dons> sorear: so was there an issue with joining that you've sorted out?
19:27:18 <dons> was lambdabot not joining some channels it should have?
19:27:21 <sorear> I believe it still exists
19:27:24 <glguy> Terabyte: it's a lambda-expression
19:27:33 <Terabyte> ah ok thanks :)
19:27:34 <sorear> check Config.autojoin, then @seen lambdabot
19:28:00 <sorear> joining 20 channels takes 40s (flood control) , and lambdabot isn't willing to wait that long.
19:28:00 <syntaxfree> is "There's no stopping human stupidity" in the sense of "There seems no way of stopping human stupidity" correct?
19:28:39 <allbery_b> more or less
19:28:40 <dons> @seen lambdabot
19:28:40 <lambdabot> Yes, I'm here. I'm in #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
19:28:55 <sorear> old lambdabot sent messages asynchronously, so it only had to wait the <<1s to compute the messages
19:29:09 <syntaxfree> allbery_b: what does "there's no stopping human stupidity" mean?
19:29:10 <dons> ah..
19:29:31 <syntaxfree> gentoo-uruguay??
19:29:32 <allbery_b> "there's no (way of) stopping human stupidity"
19:29:41 <dons> syntaxfree: yes. :)
19:29:52 <syntaxfree> jesus. what *is* lambdabot doing there?
19:30:00 <allbery_b> normally would bephrased "...no way to stop..." if written out although both are valid
19:30:06 <Terabyte> or patch..
19:30:10 <sorear> > 2+2 == 4 -- in every language
19:30:11 <lambdabot>  True
19:30:27 <glguy> runState (foldM (\x y -> do { b <- gets $ Data.Set.member y; if b then return x else do { modify $ Data.Set.insert y; return (y:x) }}) [] [1,2,3,2,2,1]) Data.Set.empty
19:30:38 <syntaxfree> I'd like to run lambdabot on another channel in another network. My stupid shared network connection won't let me run any servers, though.
19:30:50 <sorear> lambdabot is a client
19:31:06 <sorear> or do you mean terms-of-use?
19:31:25 <dons> yeah, its just a client
19:31:32 <sorear> I run a lambdabot occasionally (sorear-lambdabot), and I'm behind a family NAT and a Cox NAT
19:31:37 <dons> i.e. you can literally use it as an irc client if you wish
19:31:48 <dons> it is /not/ an irc server
19:31:55 <glguy> but is it a server?
19:31:57 <glguy> or a client
19:32:07 <sorear> it's literally a server
19:32:08 <syntaxfree> sorear: oh. lambdabot is a client. of course.
19:32:14 <syntaxfree> hmmm.
19:32:22 <sorear> but it opens a TCP connection, so ISPs consider it a client
19:32:24 <dons> well, its a server of lambdabot commands, implemented on top of irc
19:32:26 * syntaxfree smiles wickedly.
19:32:30 <glguy> so it isn't not a client?
19:32:37 <syntaxfree> I wish I could get lambdabot to compile :~
19:32:42 <allbery_b> it is a client of an irc server, but a server which uses irc as its transport
19:32:46 <syntaxfree> maybe I can now, with 6.6.
19:32:53 <syntaxfree> Last time I tried, I had 6.2.1 or something.
19:32:58 <allbery_b> so it depends on how you look at it
19:33:07 <syntaxfree> of course.
19:33:10 <dons> yeah, allbery_b is right. we tunnel lambdabot protocol over irc
19:33:14 <syntaxfree> from the ISP viewpoint, it's just like an irc client.
19:33:18 * glguy is fully aware of lambdabot's role on IRC and is making fun of the many explainations that followed ;)
19:33:19 <sorear> 6.6 works (you need dcoutt's zlib binding)
19:33:22 <dons> so it appears to the outside to be an irc client
19:33:32 <dons> but really its a lambdabot server running on top of irc
19:33:39 <glguy> so it is lifted?
19:33:41 <sorear> or, it appears as a readline-based terminal program
19:33:46 <dons> see RFC _|_ for the defn of the lambdabot protocol
19:33:52 <syntaxfree> hehehehe
19:33:52 <sorear> 2813
19:34:02 <sorear> when I'm done, it will also be an HTTP server
19:34:02 <syntaxfree> hahahahaha
19:34:07 <sorear> (otpionally of course)
19:34:08 * syntaxfree drops on the floor laughing.
19:34:11 <glguy> lambdabot is a Haskell bot lifted into the IRC protocol?
19:34:34 <allbery_b> instance Monad Lambdabot where ...
19:34:37 <syntaxfree> as it grows, lambdabot will become a combinator for tunnelling arbitrary networking protocols via IRC!
19:34:46 <syntaxfree> there will be specific clients for lambdairc!
19:34:56 <syntaxfree> lambdabot will RUN THE WORLD'S INFRASTRUCTURE!
19:35:00 <syntaxfree> muhahahaha
19:35:03 <sorear> right now, lambdabot is growing to tunnel itself over all protocols
19:35:08 <sorear> you can help soon
19:35:56 <syntaxfree> virtualbuttoncontrollingnuclearfacilities >>= lambdairc
19:35:57 <sorear> soon IRC will be a mere plugin, alongside Jabber, readline, httpd, bash, telnet, gopherd, <<THUNK>>
19:36:15 <glguy> lambdabot on Jabber would be nice
19:36:20 <Anon4888> So are you going to make it post on forums?
19:36:25 <syntaxfree> sorear: oh. I wish you'd use libgaim or something instead of jabber.
19:36:26 <sorear> yes
19:36:35 <dons> I think we'll run a lambda-reddit off the top of lambdabot too
19:36:38 <allbery_b> hm, actually I suppose that'd be:  newtype Lambdabot m = (Protocol p) => BotT LBot p IO -- or something
19:36:42 <syntaxfree> sorear: libgaim takes care of forwarding messages to IM protocols of all kinds.
19:36:43 <sorear> actually, I'm just doing the infrastructure
19:36:45 <dons> you'll need to pass the typechecker to submit though
19:36:50 <syntaxfree> Keeps up with the proprietary protocols.
19:36:59 <syntaxfree> anyway, file this as a request wherever it is?
19:37:01 <sorear> ADEpt is the one doing the Jabber plugin
19:37:03 <syntaxfree> use libgaim, not Jabber :~
19:37:07 <sorear> @help todo
19:37:07 <syntaxfree> please please please.
19:37:07 <lambdabot> todo. List todo entries
19:37:12 <sorear> @help todo-add
19:37:12 <lambdabot> todo-add <idea>. Add a todo entry
19:37:54 * allbery_b wonders how many brains would explode at CMU if lbot used libgaim nd he brought it up on zephyr
19:37:57 <sorear> ^^^ that's the best idea-bucket for now
19:38:06 <dons> sorear: so what can we do about this join/timeout issue? are you looking at it?
19:38:16 <sorear> yes
19:38:23 <dons> allbery_b: hehe :)
19:38:26 <allbery_b> (class lambda, obviously)
19:38:27 <ohmega> an http-interface would be nice
19:38:47 <dons> ?where lambdaweb
19:38:48 <lambdabot> http://lambdabot.codersbase.com
19:38:49 <sorear> the quick fix is to wrap liftLB forkIO around the mapM_ join (Config.autojoin Config.config)
19:38:51 <dons> not sure if its still up though
19:38:56 <dons> (that's the Ajax lambdabot client)
19:39:10 <xpika> http://www.perl.com/pub/a/2005/03/03/pugs_interview.html quote: GHC, again, compiles to very fast C code., so does GHC compile to assembly or via C?
19:39:11 <dons> sorear: yeah
19:39:11 <lambdabot> Title: perl.com: A Plan for Pugs
19:39:19 <dons> xpika: both
19:39:24 <dons> and via bytecode too
19:39:36 <allbery_b> xpika: used to be via C, these days it has direct support as well
19:39:37 <ohmega> hm, no answer from the webbot
19:39:40 <dons> there's 3 backends in production, asm, C and bytecode
19:40:03 <sorear> the not-so-quick fix is to implement synchronous and asynchronous file sourcing and use .lambdabotrc for joining
19:40:03 <dons> and they're interoperable too!
19:40:07 <dons> take that python!
19:40:13 <dons> smoke this ruby!
19:40:20 <allbery_b> hm.  can you save the bytecode though, or is it only ephemeral used by ghci and runghc?
19:40:24 <ohmega> oh now it replied
19:40:35 <dons> allbery_b: can't be saved (can be in YHC though)
19:40:36 <ohmega> it's just terribly slow
19:40:47 <dons> ohmega: shouldn't be too bad once it warms up
19:40:54 <dons> you probably just triggered a fastcgi restart
19:40:58 <ohmega> now it warmed up!
19:41:02 <dons> (once started, it keeps the bot open)
19:41:23 <syntaxfree> @spell saintly
19:41:25 <lambdabot> saintly
19:41:28 <syntaxfree> @spell sanctly
19:41:29 <lambdabot> scantly saintly sanctify sanctity scantily
19:41:36 <syntaxfree> @spell sanct
19:41:36 <lambdabot> scant Santa saint sanctum snack
19:41:46 <allbery_b> what are you tring to say?
19:42:01 <allbery_b> *trying
19:42:03 <dons> sorear: btw, did you try the new testsuite ?
19:42:25 <sorear> yes, when it had 7 tests.  very cool.
19:42:32 <dons> it worked?
19:42:36 <sorear> yes
19:42:40 <dons> good
19:42:43 <sorear> I had to change 2 lines
19:42:48 <dons> oh?
19:42:57 <sorear> s#/home/dons/lambdabot#/home/stefan/test-lb-sorear#
19:43:01 <dons> after I fixed the portability issue today?
19:43:06 <ohmega> nice
19:43:13 <sorear> s#/usr/local/bin/gm4#/usr/bin/m4#
19:43:14 <dons> sorear: that's fixed now
19:43:16 <sorear> no, before
19:43:21 <dons> configure.ac finds m4 for us
19:43:23 <dons> and the path is now relative
19:43:33 <xpika> is there a int main function in my .HS file?
19:43:35 <sorear> configure complained about a missing logpp.in
19:43:43 <dons> ah I forgot to add that
19:43:46 <allbery_b> main :: IO ()
19:43:52 <xpika> s/HS/HC
19:44:15 * allbery_b confused
19:44:22 <sorear> xpika: there's an int main *somewhere*, if you're compiling unregisterized.
19:46:15 <syntaxfree> @spell intermingle
19:46:16 <lambdabot> intermingle
19:46:22 <syntaxfree> @all-dict intermingle
19:46:23 <lambdabot> *** "Intermingle" gcide "The Collaborative International Dictionary of English v.0.48"
19:46:24 <lambdabot> Intermingle \In`ter*min"gle\, v. t.
19:46:24 <lambdabot>    To mingle or mix together; to intermix. --Hooker.
19:46:25 <lambdabot>    [1913 Webster]
19:46:27 <lambdabot>  
19:46:29 <lambdabot> [24 @more lines]
19:51:26 * SyntaxNinja pushes changes to haskell-prime-report !
19:51:27 * SyntaxNinja &
19:51:52 * sorear congratulates SyntaxNinja
19:52:30 <dons> yay!
19:52:49 <dons> SyntaxNinja++ ** ^^
19:53:49 <dons> ?version
19:54:04 <lambdabot> lambdabot 4p439, GHC 6.5 (OpenBSD i386)
19:54:08 <lambdabot> Plugin `version' failed with: IRCRaised thread killed
19:54:15 <nornagon> heh
19:54:16 <dons> sorear: hehe
19:54:21 <dons> ?bot
19:54:22 <lambdabot> :)
19:54:24 <allbery_b> whoops
19:54:28 <dons> ?src ContT callCC
19:54:29 <lambdabot> callCC f = ContT $ \c -> runContT (f (\a -> ContT $ \_ -> c a)) c
19:54:36 <dons> ?src MonadFix
19:54:37 <lambdabot> class (Monad m) => MonadFix m where
19:54:37 <lambdabot> 	mfix :: (a -> m a) -> m a
19:54:45 <nornagon> ouch
19:55:48 <dons> ?src (->) (>>=)
19:55:49 <lambdabot> f >>= k = \ r -> k (f r) r
19:55:58 <dons> ?time
19:56:01 <lambdabot> Local time for dons is Mon Jan  8 14:50:23 2007
19:56:04 <sorear> ?version
19:56:05 <lambdabot> lambdabot 4p439, GHC 6.5 (OpenBSD i386)
19:56:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:56:18 <dons> sorear: so I guess it was still running some other threads?
19:56:59 <dons> ?src Maybe return
19:57:00 <lambdabot> return              = Just
19:57:37 <sorear> ?  I'd guess someone else was doing something and it had to wait longer than 15s
19:58:04 <sorear> QoS is on my todo - channel > privmsg priority-wise
19:58:18 <sorear> ideally, round-robin scheduling based on requestor
19:58:34 <sorear> so the bot is always snappy in public
19:58:50 <dons> that's a good idea
20:00:38 <xpika> does anyone know why even when i turn on optimization or change the heap size ghc still gives me a "COMPILATION IS NOT REQUIRED" message?
20:00:56 <glguy> because you are using --make
20:00:57 <dons> it doesn't turn flags into recompilation checks
20:00:59 <dons> use -no-recomp
20:01:02 <glguy> and that just checks timestamps
20:01:06 <glguy> it doesn't know what flags you used
20:01:21 <dons> (it would have to cache your flags somewhere after each run..)
20:01:51 <xpika> OMG WOW
20:01:58 <xpika> yes it worked.
20:03:15 <xpika> i just gained 400% improvement with the -O flag
20:03:15 * bos_ wonders if there exists a library for sending strongly-typed messages over a network.
20:03:24 <xpika> and i thought it did nothing
20:03:34 <syntaxfree> gah, I'm so tired of writing, my english is beginning to suck by the end of the essay.
20:03:41 <allbery_b> -O does stuff.  -O2 doesn';t do a whole lot over -O IIRC
20:03:58 <syntaxfree> but if I don't finish today, I'll never do.
20:03:58 <xpika> tries -O2 ***
20:04:05 <xpika> still better than no -O
20:04:08 <sorear> ?quote 28m
20:04:08 <lambdabot> No quotes match. That's something I cannot allow to happen.
20:04:13 <SyntaxNinja> dons: do I get karma for that?
20:04:14 * SyntaxNinja &U
20:04:17 <acro> how do you know if the prelude module has been loaded (winhugs)? do i have to specify dir w/ -Pstr switch?
20:04:22 <allbery_b> -O2 -fvia-C can do a few more things, I think, but that's getting into hairy internals I have no clue about
20:04:25 <dons> SyntaxNinja: yeah, you did. :)
20:04:28 <sorear> dons: how do I full text search the quotes now?
20:04:37 <bos_> ye gods. $ man ghc => No manual entry for ghc
20:04:42 <dons> same way ?
20:04:48 <sorear> dons: one person went from 28min to 7sec on -O and was quoted
20:04:54 <sorear> ?quote 28
20:04:55 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:04:58 <sorear> ?quote .*28
20:04:59 <lambdabot> No quotes match. My pet ferret can type better than you!
20:05:00 <dons> ?quote 7
20:05:01 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
20:05:01 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
20:05:10 <xpika> yea O2 is like only 5% improvement for me over O
20:05:12 <sorear> ?quote 27
20:05:12 <lambdabot> No quotes match. It can only be attributed to human error.
20:05:20 <allbery_b> ?quote 28
20:05:21 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
20:05:32 <xpika> thanks dons though
20:05:53 * allbery_b remembers the quote but not exact numbers
20:06:19 <allbery_b> ?quote minutes
20:06:20 <lambdabot> No quotes match. I feel much better now.
20:06:32 <allbery_b> ?quote -O
20:06:33 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
20:06:34 <dons> maybe it was one of those mysterious quotes that disappeared last week
20:06:38 <allbery_b> ?quote -O
20:06:38 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
20:06:41 <acro> getting "Syntax error in declaration (unexpected `<-')" .. so i'm assuming a module wasn't loaded..
20:06:44 <dons> I can't see it in the quotes file
20:06:45 <ClaudiusMaximus> ?quote 28mins
20:06:46 <lambdabot> No quotes match. I feel much better now.
20:06:51 <ClaudiusMaximus> ;)
20:06:52 <lambdabot> ClaudiusMaximus: You have 1 new message. '/msg lambdabot @messages' to read it.
20:07:00 <ClaudiusMaximus> damn sleep eludes me
20:07:45 <dons> ?remember ClaudiusMaximus compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
20:07:46 <lambdabot> Done memoising quote for `ClaudiusMaximus', if that is their real name...
20:08:02 <ClaudiusMaximus> that's the one
20:08:03 <allbery_b> hm, there's another /msg bug I noticed the other day:  abbreviated commands don't seem to work any more
20:08:32 <sorear> @nazi-
20:08:33 <lambdabot> Maybe you meant: nazi-off nazi-on
20:08:36 <allbery_b> ?qu reduced
20:08:37 <lambdabot> Maybe you meant: quit quote . bf bug ft id pl run v wn
20:08:46 <allbery_b> okay, bad test
20:08:57 <dons> ?go haskell
20:08:59 <lambdabot> http://www.haskell.org/
20:08:59 <lambdabot> Title: Haskell - HaskellWiki
20:09:06 <sorear> -> *lambdabot* @reme          *lambdabot* Incorrect arguments to quote
20:09:13 <dons> fixed
20:09:17 <allbery_b> works now I guess
20:09:42 <allbery_b> had @go failing the other day
20:09:52 <xpika> ?quote xpika
20:09:53 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
20:09:54 <sorear> A while ago I bound send-line to Esc-Enter and Enter to nothing.  - no more enter-by-accident for me
20:09:54 <dons> yeah, probably the same bug I fixed yesterday
20:09:55 <allbery_b> then I tested with ?qu today but that was just a bad choice
20:10:46 * allbery_b is sometimes tempted to move send to control-J but then he'd expect emacs scroll commands to work too...
20:11:13 <allbery_b> (heck, I already try to scroll xchat2 with M-v :)
20:11:43 <sorear> on MY system, Enter and C-j are synonymous :)
20:11:57 <allbery_b> xchat2 thinsk they're different
20:12:24 <allbery_b> (not unsuual for gooey apps :)
20:12:42 <sorear> <-- Linux console user
20:12:59 <reppie> sorear you're hardcore
20:13:49 <sorear> I use X about ten minutes a week and for the sole purpose of reading SPJ's papers.
20:14:27 <sorear> actually, it took me all of last week to notice that my X11 config was incompatible with my new LCD monitor.
20:14:58 * allbery_b uses X fairly heavily; multiple windows rock
20:15:08 <shapr> I keep X in my pocket!
20:15:23 * iulus uses Windows. Is he a bad person? :D
20:15:31 <allbery_b> so you're not just glad to see us?
20:15:35 <sorear> Virtual consoles rock almost as much.
20:15:36 <shapr> Speaking of which, the Nokia 800 just came out, it's the sequel to the Nokia 770 that I keep in my pocket.
20:15:39 <nornagon> I use X so I can more flexibly multiplex console windows.
20:15:43 <nornagon> Oh, and iceweasel.
20:15:52 <shapr> allbery_b: I'm glad to see you, but not *that* glad. Only my girlfriend, sorry.
20:15:59 <sorear> When I use X, I use ion3.
20:16:00 <allbery_b> heh
20:16:04 <nornagon> sorear: me too :)
20:16:08 <shapr> me three
20:16:12 <syntaxfree> finally! I'm done!
20:16:13 <koala_man> me four
20:16:20 <nornagon> ion3++
20:16:34 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/08/haskell-bondage-and-discipline-and-separation-of-concerns-programming/
20:16:39 <ClaudiusMaximus> what would be a reasonable type for "a function that takes an argument, might modify a state, might perform some IO, might return an error code"?
20:16:49 <sorear> @karma+ tuomov great work!
20:16:50 <lambdabot> tuomov's karma raised to 1.
20:16:57 * allbery_b uses KDE, but more because there are logistical issues with full screen windows
20:17:12 <shapr> Oh, I had a fun programming puzzle idea.
20:17:30 <sorear> CM: a -> StateT b (ErrorT c IO) d
20:17:42 <allbery_b> (1280x1024 vnc sessions, which work nicely on my 1680x1050 and 1280x1024 displays but not so hot fullscreen on the 1024x768 laptop)
20:17:48 <syntaxfree> gah, this is not even half as good as I thought it would.
20:17:58 <syntaxfree> anyway, I'm tired, and I need to learn how to finish things.
20:18:06 <syntaxfree> If I left it for later, I'd never finish it.
20:18:23 <allbery_b> I have additional windows open for smallish stuff which can usually be kept out f the way
20:18:39 <shapr> syntaxfree: Me too
20:18:44 <allbery_b> (xcutsel, and every 12 hours a widget to rnew kerberos tickets)
20:18:48 <sorear> syntaxfree: have you joined planet. yet?
20:18:50 <shapr> @karma+ tuomov yay!
20:18:51 <lambdabot> tuomov's karma raised to 2.
20:18:54 <syntaxfree> sorear:  yup.
20:19:08 <syntaxfree> sorear: I hope Planet supports <!--more--> tags, because this is a huge, meandering ramble.
20:19:09 <ClaudiusMaximus> sorear: will take me a while to comprehend that type i think, unless there is a simple example somewhere...
20:19:47 <allbery_b> @go monad transformers step
20:19:53 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
20:19:53 <lambdabot> Title: Monad Transformers Step by Step
20:20:20 <allbery_b> it's layered:  IO -> ErrorT -> StateT
20:20:39 <allbery_b> so you effectively get all three at the same time, maybe at the cost of a few "lift"s
20:21:51 <ClaudiusMaximus> allbery_b: thanks
20:22:14 <bos_> wow, saw my first google ad that mentioned haskell.
20:22:36 <shapr> bos_: cool
20:22:53 <ttmrichter> OK, stupid questions time: is there a good place that explains Arrows vs. Monads without resorting to too much abstract mathematics?  The sites I've seen so far go heavy on the theory and light on practical uses.  I'd like to learn more, but am mathematically declined after all these years out of school.
20:23:13 <dons> ?src Arrow
20:23:14 <lambdabot> class Arrow a where
20:23:14 <lambdabot>     arr, pure   :: (b -> c) -> a b c
20:23:14 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
20:23:16 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
20:23:18 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
20:23:20 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
20:23:24 <dons> ?src Monad
20:23:24 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
20:23:26 <lambdabot> class  Monad m  where
20:23:28 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
20:23:30 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
20:23:32 <lambdabot>     return      :: a -> m a
20:23:36 <lambdabot>     fail        :: String -> m a
20:23:43 <bos_> syntaxfree: you refer to haskell modules as "objects", which they really aren't in the sense that anything else in haskell is.
20:23:45 <dons> the Arrows generalise Monads from sequences to graphs
20:23:52 <allbery_b> try the haskell wikibook?
20:24:03 <syntaxfree> bos_: do I?
20:24:06 <dons> ?src Applicative
20:24:07 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:24:10 <dons> bah
20:24:12 * allbery_b is trying to remmebre where he saw the "assembly line" thing
20:24:17 <bos_> syntaxfree: yes :-)
20:24:23 <syntaxfree> oh. will fix.
20:24:57 <syntaxfree> bos_: it's really a long, meandering ramble with the superficial appearance of an organized argument.
20:25:24 <bos_> ttmrichter: http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
20:25:48 <bos_> ttmrichter: the arrow notation has changed since the original paper, but the idea hasn't.
20:25:55 <ttmrichter> OK, so Monads generalise related operations into sequences and then Arrows do further generalisation?  Can Monads be expressed in terms of Arrows or are they divergent concepts?
20:26:15 <sieni> ttmrichter: look up "Kliesli arrow"
20:26:24 <bos_> "kleisli"
20:26:38 <allbery_b> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
20:26:39 <sieni> oops
20:27:01 <ttmrichter> I'll have to just record the URLs for now.  The Taiwanese with their earthquake didn't bother consulting with me to see how inconvenient it would be!  :)
20:27:16 <bos_> that's why god gave us del.icio.us
20:27:50 <dons> we have instance Monad m => Arrow (Kleisli m)
20:28:24 <ttmrichter> OK, and wikibooks is firewalled off on me.  Time to fire up my tunnel.
20:28:35 <dons> so anything in Monad is automatically in Arrow, via the Kleisli arrow
20:29:07 <ttmrichter> I assume that Arrows will be standardised with Haskell'?
20:29:43 <orbitz> hello i am getting the error: "Couldn't match expected type `IO' against inferred type `[]'" what shoudl I be looking for in order to solve this
20:29:59 <orbitz> the line sit's compalining on looks like: solveFromFile filename = do boards <- readBoardsFromFile "sudoku_puz.txt"; solveList boards
20:30:27 <syntaxfree> you mean proc-notation?
20:30:35 <syntaxfree> Arrows are straight Haskell, AFAIK.
20:30:39 <syntaxfree> Like monads.
20:30:49 <dons> orbitz: what's the type of "solveList " ?
20:30:58 <bos_> orbitz: it's probably solveList
20:31:16 <bos_> try liftM $ solveList boards instead.
20:31:20 <orbitz> oh durh
20:31:22 <orbitz> i need ot do
20:31:25 <ttmrichter> Well, yes.  But there can be different ways of expressing them, right?  Or have they been pretty much hammered out in expression and are now defacto standards?
20:31:28 <orbitz> return (solveList boards) i think
20:31:49 <bos_> yep.
20:31:53 <allbery_b> ttmrichter:  basic Arrows are sraight Haskell, only proc notation needs an extension
20:31:55 <orbitz> using a return worked, thanks
20:33:18 <syntaxfree> oh boy. depression strikes.
20:33:21 <kilimanjaro> What alternatives to abstract interpretation are there in the realm of flow analysis for languages like Haskell?
20:33:33 <syntaxfree> I understand post-pregnancy depression for women.
20:33:47 <kilimanjaro> syntaxfree: Some of it is hormonal
20:33:50 <syntaxfree> It's quite odd being concentrated in something for a while and then giving birth to it.
20:34:00 <syntaxfree> Even if it took you only a few hours.
20:34:14 <syntaxfree> anyway, personal problems have more to do with this than nothing.
20:34:28 <syntaxfree> I'm actually doing work not to think of personal woes. So when work vanishes, I'm sad again.
20:34:52 <sieni> try zazen
20:35:06 <sieni> anyway, off to juggling
20:35:14 <syntaxfree> kilimanjaro: sigfpe has been writing on comonads for flow processing.
20:35:42 <bos_> bah, hugs pukes when i try to import Control.Monad.State
20:36:18 <kilimanjaro> syntaxfree: Well, I actually was talking about flow analysis of source programs to enable compiler optimizations
20:36:34 * syntaxfree tries to construct a "You think you got it bad? I built a *insert large complex problem here* in Helium!", but nothing good came up.
20:38:01 <syntaxfree> no one even liked my half-joke. Oh boy, *that* is depressing.
20:39:08 <Anon4888> I liked your joke syntax
20:39:09 <bos_> i suggest a beer or a cup of coffee.
20:39:13 <Anon4888> What's helium?
20:39:27 <Anon4888> :P
20:40:05 <syntaxfree> part of what got me into this state is coffee.
20:40:17 <syntaxfree> I drank just a little coffee, because I missed the taste.
20:40:29 <syntaxfree> It got me into a huge high where I wrote the good part of the BDSM essay.
20:40:31 <kilimanjaro> Bitter?
20:40:38 <kilimanjaro> BDSM essay?
20:40:53 <syntaxfree> kilimanjaro: http://syntaxfree.wordpress.com/2007/01/08/haskell-bondage-and-discipline-and-separation-of-concerns-programming/#more-12
20:40:58 <orbitz> hrm, i have:  solveFromFile :: t -> IO [KeyVal] and printBoard :: [KeyVal] -> IO ().  and i'm doing do res <- solveFromFile; printBoard res  howeve ri'm getting: Couldn't match expected type `[KeyVal]' against inferred type `IO [KeyVal]'.  but shouldn't te inferred tpe not be IO?
20:40:58 <lambdabot> http://tinyurl.com/y4wmn2
20:41:01 <syntaxfree> er, ignore #more-12
20:42:16 <syntaxfree> anyway, I've always suffered from bad post-caffeine depression.
20:42:58 <syntaxfree> orbitz: in that case, you really just want print (solveFromFile (waaawaaa))
20:43:11 <syntaxfree> (where waaawaaa is whatever argument your function needs)
20:43:26 <syntaxfree> no, you don't.
20:43:27 <syntaxfree> ignore me.
20:43:31 * syntaxfree hides
20:43:32 <orbitz> that dones't work either
20:43:36 <syntaxfree> yes.
20:43:42 <allbery_b> <bos_> bah, hugs pukes when i try to import Control.Monad.State
20:43:48 <orbitz> i'm curious as t why the IO is ther eon the iffered type
20:43:49 <allbery_b> hugs +98 -- ?
20:43:55 <syntaxfree> I don't know.
20:44:00 <syntaxfree> Ignore what I just said.
20:44:07 <syntaxfree> Not the "I don't know part", the answer to your problem.
20:44:27 <allbery_b> heh
20:44:52 <paranoid-android> there *has* to be some version of this that isn't registered.
20:45:08 <bos_> allbery_b: it's actually the Reader monad it's complaining on, when I import State.
20:45:18 <bos_> complaining about dependent parameters.
20:45:19 * allbery_b doubts it; marvin is rather popular among geeks
20:45:32 <paranoid^android> geeks and radiohead fans alike.
20:45:50 <paranoid^android> you can tell a lot about people by what reference they get from "paranoid android".
20:46:04 <kilimanjaro> SyntaxNinja: Well, at the very least your essay inspired me to put on some NIN
20:46:11 <paranoid^android> kilimanjaro: hehehe
20:48:21 <paranoid^android> "Paranoid android" is a Completely Automated Test to Tell Indie-rockers and Geeks Apart. CATTIGA.
20:48:26 * allbery_b hasn't heard much Radiohead, no
20:48:48 <allbery_b> maybe because I'm an ancent gee(k)zer :>
20:49:40 <allbery_b> (then again, I hack to techno)
20:50:38 <ttmrichter> I hack to almost anything.  Lately Chinese traditional folk.
20:51:05 <ttmrichter> I'm over 40 and get the Radiohead reference, though.  As well as the Marvin reference.  What does that make me?  (Methinks perhaps a freak?)
20:51:09 <Anon4888> You have mp3s of that or do you just bang pots & pans around?
20:51:21 <allbery_b> ah, join the club.  (42 here)
20:51:40 <ttmrichter> Bah!  You're still an old-timer compared to me.  Barely.  :(
20:51:59 <ttmrichter> <=== will be 41 sooner than is comfortable to think about.
20:52:03 * sorear prefers 3600 RPM of background noise
20:52:07 <paranoid^android> ttmrichter: which one did you learn first?
20:52:27 <paranoid^android> I knew the radiohead tunes for years before I read THHGTG.
20:52:37 <ttmrichter> I listened to HHGTTG back before there were books.  Guess....
20:53:19 <bos_> ttmrichter: over 40 and learning haskell? keeping the alzheimer's at bay! :-)
20:54:36 <paranoid^android> bos_: you probably get to be 40 before you know all the math required to know haskell inside out ; )
20:54:39 <ttmrichter> Oops.
20:54:51 <ttmrichter> bos_: What can I say?  I'm a language junkie.  I told my students once how many languages I've learned and they started to get consternated when the list reached 50.  With a dozen on the "fluent" list.  :-)
20:54:52 <ttmrichter> Damned IRC commands.  :@
20:55:03 * allbery_b resembles that
20:55:08 <bos_> ttmrichter: what do you teach?
20:55:10 <ttmrichter> This over and above the natural languages I've learned.
20:55:23 <allbery_b> I strive to learn a new language every 6 months or so to try to stay flexible
20:55:29 <ttmrichter> I teach technical English to computer majors in Wuhan University's International Software School.
20:55:55 <ttmrichter> My favourite experience here involves Haskell, actually.
20:56:00 <paranoid^android> every language outside Haskell I try to learn looks stupid.
20:56:02 <dons> so you're just starting out in Haskell at the moment?
20:56:10 <ttmrichter> They had a quicksort written in Java they were poring over just before my class started.
20:56:11 <dons> paranoid^android: try Epigram or Isabelle
20:56:20 <ttmrichter> So I wrote a Haskell quicksort on the board for them.
20:56:21 <dons> they almost make Haskell a blub language :)
20:56:24 <ttmrichter> They boggled.  :D
20:56:26 <paranoid^android> Epigram is too complex for me ;)
20:56:30 <dons> ttmrichter: hehe
20:56:37 <Anon4888> When is Epigram 2 gonna happen?
20:56:59 <ttmrichter> What's funniest is that the Java one could only sort integers.  I pointed out that the Haskell one could sort anything which could be compared.
20:57:08 <dons> it'll just get rewritten to use GADTs and index type families in ghc 6.8 ;)
20:57:31 <dons> ttmrichter: oh no! polymorphism! you'll cause a fatal overload
20:57:42 <ttmrichter> That class REALLY started paying attention in my classes after that.  And yes, dons, I'm a Haskell newbie.  I've been peering at it off and on for about two years, but only now have I decided to get into full-fledged larval mode and learn the bastard.
20:57:56 <dons> I guess you've done some erlang or ocaml ?
20:58:04 <ttmrichter> My big win of the month?  I finally grokked about 10% of Monads.  :D
20:58:10 <dons> or old school ML?
20:58:12 <ttmrichter> Nope.  No erlang or ocaml.
20:58:15 <ttmrichter> A bit of ML.
20:58:21 <ttmrichter> SML/NJ to be precise.
20:58:22 <paranoid^android> I might learn ML at some point.
20:58:26 <bos_> dons: i think that about every second sentence from you involves some concept i'm unfamiliar with and spend 15 minutes googling. you need to lower your signal to noise ratio.
20:58:29 <ttmrichter> And a lot of Scheme.
20:58:48 <bos_> otherwise i'll never keep up with the channel, see.
20:58:50 <ttmrichter> <=== hates Lisp-alikes.
20:59:04 <dons> today I see a nice Epigram-ish thing, done with GADTs, http://www.haskell.org/pipermail/haskell-cafe/2007-January/021178.html
20:59:10 <paranoid^android> Scheme is great. Scheme me got back into programming.
20:59:20 <ttmrichter> I just can't stand the fingernail parings.
20:59:38 <dons> augustss: did you see that post?
21:00:08 <paranoid^android> dons: you know you're dealing with researchy haskell when there are more data declarations than functions : )
21:00:21 <ttmrichter> I *REALLY* like Haskell's terseness.  Not so terse as to be unreadable (I'm looking at APL/K/J/Q/whatever here), but not verbose and weird with brackets.
21:00:26 <Anon4888> GADTs are like C++ templates... way out of control
21:00:28 <paranoid^android> One could even make that a metric.
21:00:56 * ttmrichter covers his eyes and chants loudly to avoid seeing or hearing anything about GADTs.
21:01:04 <paranoid^android> Researchiness = Datatype declarations / (Function definitions + Datatype declarations)
21:01:08 <paranoid^android> ttmrichter: why?
21:01:08 <sorear> ttmrichter: Haskell *can* be dense-to-unreadable, and very well.  Show me a 590 character theorem prover.
21:01:26 <sorear> that's not my Haskell one
21:01:42 <dons> bos_: re. index type families, they're a new GHC 6.6-head feature, and corresponding new intermediate language in GHC to support the fancy types, http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
21:01:45 <lambdabot> Title: TypeFunctions - GHC - Trac
21:01:46 <ttmrichter> paranoid^android: why what?  Why dislike Scheme or why ignoring GADTs?
21:01:48 <dons> (proper type level functions in GHC)
21:01:54 <paranoid^android> both!
21:02:46 <dons> sorear: nice patch idea, -e
21:02:47 <sorear> 3D accellerators are just silly.  I want a GHC accellerator card.
21:02:54 <dons> should make the unit tests a bit easier :)
21:03:03 <ttmrichter> paranoid^android: Scheme: I don't like the parentheses.  They drive me batty.  I just don't think the backwards way that the minimal syntax forces you into and don't want to go there for any length of time.  GADTs: I'm having problems enough with Monads and related stuff.  GADTs are off the radar for me now until I grok the stuff I have sitting in front of me first.
21:03:07 <dons> sorear: esp. if it filters out the prompt (?)
21:03:24 <bos_> dons: thanks for the pointer!
21:03:30 <allbery_b> GADTs aren't really that hard
21:03:40 <dons> yeah, they could just about be the default
21:03:42 <allbery_b> some of the *uses* of them, OTOH... :)
21:03:49 <paranoid^android> ttmrichter: Scheme is ostensively a learning language.
21:04:04 <ttmrichter> I'm sure they're not.  Monads turned out not to be all that difficult once I dove past the overly mathematical descriptions of them.
21:04:08 <paranoid^android> The point is to teach the whole language in one lecture and then move on to actual computer programming.
21:04:25 <ttmrichter> But right now, I've got other problems on my plate.  GADTs are calling to me like sirens, but I don't want to wind up on their rocks just yet.
21:04:29 <zeeeeeee> is there any introductory material or primer to things ST, STRef, and/or IORef? the closest thing i could find is http://haskell.org/hawiki/ImperativeHaskell (mentioned in an old post in repsonse to the question i just re-posed)
21:04:31 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki
21:04:35 <zeeeeeee> *things like
21:04:46 <paranoid^android> I don't quite understand GADTs yes.
21:04:49 <dons> bos_: it must feel a bit like christmas, coming back to Haskell after 10 years, and > 100 reserchers, adding new features :)
21:04:50 <paranoid^android> s/yes/yet.
21:04:57 <ttmrichter> Oh, I agree, p^a.  Scheme was a great learning experience.  (Sussmann et al's book.)  But I would never want to use it in anger.
21:05:07 <paranoid^android> I'm told they implement a limited form of dependent types.
21:05:37 <bos_> dons: especially since i only had a hazy understanding of monads when i left the community. now i've got all this remedial learning to do before i can even catch up!
21:05:47 <dons> yes, it will be an interesting era post ghc 6.8, with index types /and/ GADTS to play with
21:05:57 <ttmrichter> I have to say, though, that Haskell gives me that "awakening" feeling I got when first reading Sussman's book.
21:05:59 <dons> working out just how much of Epigram that gives us will be fun
21:06:02 <Anon4888> If GADTs can accept only terminating lambda terms, they should be able to handle any kind of dependent type shouldn't they?
21:06:09 <Anon4888> (in a horribly mangled and verbose way)
21:06:14 <bos_> i'm trying to figure out how to use the State monad without following a tutorial. it's bracing.
21:06:24 <sorear> Anon4888: I am deeply convinced it is all equivalent
21:06:37 <glguy> bos_: My favorite State example is MonadRandom
21:06:41 <Cale> Looks like there are lots of new irc users here?
21:06:42 <ttmrichter> Is this "bracing" in the sense of an "Arctic Wind in 50 below weather"?
21:06:42 <sorear> Anon4888: Haskell *98* has full type lambdas...
21:06:57 <dons> ?users
21:06:58 <lambdabot> Maximum users seen in #haskell: 299, currently: 258 (86.3%), active: 19 (7.4%)
21:06:59 <paranoid^android> I don't even know how to spot GADTs in code.
21:07:01 <Cale> sorear: huh?
21:07:05 <bos_> it's bracing in every sense :-)
21:07:08 <dons> Cale: yeah, a few new names
21:07:27 <paranoid^android> I know "vanilla" types from sexy ones, but they could be existentially quantified, or, or, or.
21:07:34 <Anon4888> sorear: in vanilla 98?
21:07:46 <Cale> Anon4888: I don't believe him :)
21:07:54 <Cale> GHC doesn't have full type lambdas
21:07:57 <ttmrichter> Huh.  So arrows are just pipes with "tee" added?  Wow!
21:08:09 <Cale> ttmrichter: basically
21:08:16 <sorear> Cale, Anon4888: church numerals in h98: newtype Zero f x = Zero x ; newtype Succ n f x = Succ (f (n f x))
21:08:17 <allbery_b> paranoid^android: data Foo where ...
21:08:33 <sorear> Haskell has full type lambdas, but *not* normal form equality.
21:08:34 <dons> Cale: but http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions (well, maybe not anonymous ones :)
21:08:37 <lambdabot> Title: TypeFunctions - GHC - Trac
21:08:38 <ttmrichter> OK, so arrows aren't all that difficult.  I may add that to my study list and merge it with my monad practice.
21:08:39 <Cale> ttmrichter: well, a little more -- you can always add another fd, by that analogy :)
21:08:42 <sorear> normal form equality is undecidable
21:08:46 <paranoid^android> allbery_b huh?
21:08:56 <allbery_b> <paranoid^android> I don't even know how to spot GADTs in code.
21:08:57 <sorear> newtype is type lambda
21:09:09 <paranoid^android> ahh.
21:10:01 <dons> data T where ... -- is how they're declared
21:10:03 <paranoid^android> @quote type
21:10:04 <lambdabot> ghc says: From-type of Coerce differs from type of enclosed expression
21:10:13 <paranoid^android> @quote type
21:10:14 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
21:10:15 <Cale> sorear: well, *sort of*
21:10:18 <ttmrichter> Cale: let me bounce this off you: in one project (C++/telephony) I made a library that basically chained together multiple sources and multiple sinks using dynamically attachable filters, merges and forks.  Is this basically what arrows provide?
21:10:25 <paranoid^android> @quote type lambda
21:10:26 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
21:10:30 <paranoid^android> @quote type
21:10:31 <lambdabot> ghc says: All of the type variables in the constraint are already in scope (at least one must be universally quantified here)
21:10:34 <Cale> ttmrichter: yes
21:11:05 <ttmrichter> Cale: I think I'm going to curse not having had access to Haskell back then.  My life would have been made much simpler....
21:11:22 <kilimanjaro> @pl unfoldr (\x -> Just ((head x) + (head (tail x)), x))
21:11:23 <lambdabot> unfoldr (Just . ((,) =<< liftM2 (+) head (head . tail)))
21:11:57 <lisppaste2> glguy pasted "bos_ , this is one of the standard uses of State" at http://paste.lisp.org/display/34471
21:12:36 <koe> how would i do a floating-point modulus? ex: 3.5 `floatmod` 2 == 1.5
21:12:38 <bos_> glguy: thanks
21:12:39 <Cale> ttmrichter: basically, the arrow combinators are ways to describe flow of data through some abstract type of computations
21:12:43 <dons> yeah, sounds like a canonical use for Arrows, in fact.
21:12:45 <paranoid^android> @quote type
21:12:46 <lambdabot> ghc says: All the type patterns for a generic type constructor must be identical
21:12:55 <paranoid^android> bah. There's no funny quote on types?
21:12:57 <dons> given they're used to describe hardware circuits
21:13:00 <paranoid^android> @quote hack
21:13:01 <Cale> ttmrichter: and proc notation makes it far simpler to use when you have a complex diagram
21:13:01 <lambdabot> chessguy says: heh. i think i'm officially addicted. i'm chatting in #haskell, helping hack on a haskellwiki page, browing a reddit thread about haskell, while playing a haskell video lecture in the
21:13:02 <lambdabot> background
21:13:05 <bos_> glguy: what i'm trying to do is construct and use the State monad just based on reading the source for it :-)
21:13:18 <Cale> http://haskell.org/arrows/
21:13:19 <bos_> glguy: so looking at your example is cheating :-)
21:13:20 <lambdabot> Title: Arrows: A General Interface to Computation
21:13:24 <goltrpoat> there are haskell video lectures?
21:13:25 <glguy> bos_: ah...
21:13:37 <paranoid^android> there are vaskell lideo hectures?
21:13:45 <dons> goltrpoat: yeah, some on the haskell.org tut pages
21:13:49 <Cale> that lists the primitives, http://haskell.org/arrows/syntax.html shows some examples of proc notation, and how it desugars
21:13:51 <lambdabot> Title: Arrow syntax
21:13:53 <ttmrichter> OK, I'm going to have to definitely add Arrows to the list and merge it with Monad studies.
21:14:15 <Cale> There's not too much to know about arrows on their own
21:14:22 <goltrpoat> dons:  ah cool
21:14:33 <Cale> But that gives libraries lots of flexibility
21:14:34 <zeeeeeee> dons: why did you choose to use vty instead of curses? (for yi)
21:14:57 <dons> jyp did, he's rewriting the whole thing
21:15:03 <ttmrichter> OK, out of the "advanced" concepts of modern Haskell (the stuff that's likely to join Haskell'), what is the best order to learn things?
21:15:03 <dons> and I said: ok, go for it
21:15:10 <Cale> HXT is a really cool arrow library for processing XML. It actually makes processing XML not-so-bad.
21:15:29 <dons> zeeeeeee: the idea is that vty gives us a lot less state to worry about and manage, producing cleaner code, and faster dev
21:15:29 <Cale> However, I wish the documentation for it was a bit cleaner
21:15:30 <paranoid^android> Cale: not-so-bad in that's easy and fun to use, or in that it's efficient?
21:15:47 <Cale> In that it's easy and fun to use, and not too inefficient for most tasks.
21:15:58 <dons> sorear: is the idea of -e that , e.g., $ ./lambdabot -e yow would work?
21:16:12 <sorear> yes
21:16:15 <paranoid^android> Cale: incidentally, how does Parsec fit in those two scales?
21:16:17 <dons> but its not done yet?
21:16:17 <ttmrichter> Isn't "efficiency" mostly a hobgoblin these days?  I mean *80*-core processors have been demoed now.
21:16:22 <sorear> it's almost unimplemened
21:16:30 <dons> ok :)
21:16:39 <Cale> paranoid^android: it scores quite well on both
21:16:53 <kilimanjaro> ttmrichter: time to switch to prolog
21:16:54 <Cale> paranoid^android: and if you're learning monads, it's definitely a monad you want to check out
21:17:04 <paranoid^android> I know monads. : )
21:17:06 <dons> ttmrichter: I've got a 16 core box downstairs for running haskell on too.  :) and we've had ghc running on a 32 core sparc box
21:17:10 * paranoid^android = syntaxfree
21:17:19 <Cale> ah, okay :)
21:17:25 <paranoid^android> btw, new blog post^H^Hrant
21:17:26 <dons> so yeah, low level efficiency becomes less important than an SMP runtime and easy parallelism, pretty quickly
21:17:28 <ttmrichter> Done the Prolog thing.  Didn't really like it (because, to be honest, at the time didn't really understand it).  Probably time to look at it again in about two years.
21:17:32 <Cale> Even so, it's a good example if you've never seen it
21:18:07 <Cale> Prolog lacks various means of abstraction that I'd usually like to  have.
21:18:18 <kilimanjaro> It's good for some things, not so good for others
21:18:35 <kilimanjaro> It's not a general purpose language (Haskell is)
21:18:42 <Cale> Can you write a polymorphic map function in prolog?
21:18:54 <kilimanjaro> Do you want to?
21:18:57 <Cale> yes :)
21:19:02 <paranoid^android> Cale: I know Parsec too.
21:19:12 <glguy> What do I need to do to enable GADTs?
21:19:13 <paranoid^android> Most of what I do nowadays is "small language to do X".
21:19:16 <kilimanjaro> Cale: The answer is no, since prolog doesn't have functions
21:19:19 <dons> glguy: -fglasgow-exts
21:19:21 <paranoid^android> always Parsec.
21:19:29 <glguy> dons: and does Hugs support those?
21:19:29 <Cale> kilimanjaro: well, it has relations which are functions
21:19:36 <Cale> (or happen to be functions)
21:20:00 <benc__> oof
21:20:02 <Cale> The problem is that you can't parametrise relations over other relations.
21:20:06 <benc__> too much time this evening playing with parsec
21:20:33 <goltrpoat> whoa.  those juergen giesl video lectures appear to be part of a series that covers everything from complexity theory to compiler design.
21:20:39 <kilimanjaro> I was under the impression that not all relations were functions
21:20:44 <goltrpoat> that's .. rather cool.
21:20:46 <dons> glguy: nope
21:20:51 <ttmrichter> Is there a *current* Haskell implementation which does distributed parallelism?
21:20:54 <Cale> kilimanjaro: not all relations are functions, all functions are relations.
21:21:04 <kilimanjaro> right
21:21:26 <Cale> ttmrichter: *distributed* parallelism, I don't think so
21:21:27 <dons> ttmrichter: not really. only the smp ghc runtime for multicore machines is close. there's GPH of course, and others, but they're research projects
21:22:06 * ttmrichter has a dream of networks of multicore boxes who intelligently share their processing loads using a decent language like Haskell.
21:22:08 <Anon4888> There you go paranoid android - "research projects" :P
21:22:42 <ctkrohn> Speaking of multicore machines, has anyone heard any serious talk of porting GHC or another compiler to the Cell/PS3?
21:22:45 * sorear wants a 16M-core arm (or even PIC) box, and a runtime that will work on it.
21:22:51 <dons> ctkrohn: there's been talk
21:23:08 <ctkrohn> I saw something on the YHC wiki throwing it out as an idea, but I couldn't tell if anyone was serious about doing it
21:23:17 <Cale> paranoid^android: so, you asked in order to determine something about the way that I rate libraries?
21:23:40 <ctkrohn> running haskell on a ps3 would be pretty damn cool... it's so much cheaper than any other Cell system I know if
21:23:45 <ctkrohn> s/if/of
21:23:48 <dons> but none of the devs have access to a Cell machine, afaik
21:23:52 <dons> at least not one they can hack on
21:24:01 <ctkrohn> IBM makes a simulator, but I've heard its quite slow
21:24:13 <allbery_b> doesn't sony have a linux pack for the ps3?
21:24:16 <ctkrohn> allbery_b: yes
21:24:19 <Anon4888> Is the cell architecture even suited to STM?
21:24:20 <ctkrohn> allbery_b: well, Terra Soft does
21:24:38 <paranoid^android> Cale: I asked because I don't know how Parsec ranks in the efficiency department compared to other parsing methods.
21:24:44 <paranoid^android> I've never done anything else, parsing-wise.
21:24:44 <ctkrohn> Sony helped Terra Soft port the Yellow Dog distro
21:24:46 <Cale> ah, okay
21:24:56 <ctkrohn> Anon4888: no idea... I haven't gotten much of a chance to read up on STM yet
21:25:16 <ctkrohn> I do have SPJ's "Beautiful Concurrency" article on my "to-read" list :)
21:25:39 <Anon4888> I think STM is a good idea
21:26:06 <ttmrichter> Ooh!  Arrows make parsing much nicer as well!
21:26:06 <Cale> There are faster Arrow-combinator based libraries, but nothing quite so well-developed as Parsec. There's also somewhat slower monadic libraries which provide symmetric <|>. Parsec is still a bit slower than a good parser generator would give you, but the convenience is usually worth it.
21:26:26 <ttmrichter> I'm really going to like Arrows I think.
21:26:49 <dons> hehe "This might have been important in the days of Forth, when Real Programmers roamed the land chewing tobacco and stealing horses"
21:26:54 <Cale> Well, maybe a little nicer in some ways and a little worse in others, but they certainly make parsing faster.
21:27:09 <newsham> how about a nice GLR parser generator
21:27:17 <paranoid^android> Cale: a friend over MSN tells me that there are ways to obtain similar results to parametrizing relations over relations in Prolog.
21:27:29 <paranoid^android> Cale: he only knows very basic prolog so he doesn't really know, though.
21:27:32 <Cale> paranoid^android: ah, okay
21:27:40 <Cale> paranoid^android: ask him to try writing map :)
21:27:52 <paranoid^android> I tried once. He didn't really "get" it.
21:28:06 <paranoid^android> He knows some Scheme, and all, but his course is mostly Prolog- and AI- oriented.
21:28:58 <allbery_b> hm.  haven't touched prolog in 10 years, it's bitrotted :/
21:29:13 <paranoid^android> I didn't get prolog either.
21:29:15 <goltrpoat> cale:  see the bottom of http://lsbu.ac.uk/csd/binprolog/node57.html
21:29:20 <Anon4888> Can you not create a variable for the relation?
21:29:39 <paranoid^android> It seemed like an involved query language to databases.
21:29:49 <Anon4888> instead of F(a,b) write Apply(F,a,b)
21:29:50 <Anon4888> ?
21:30:43 <Cale> goltrpoat: ah neat. Perhaps at some point, I'll try to understand what's happening there :)
21:31:06 <goltrpoat> likewise :)
21:34:44 <bos_> paranoid^android: your blog entry is getting some points on reddit
21:34:53 <paranoid^android> already?
21:34:59 <bos_> reddit never sleeps.
21:35:04 <paranoid^android> I write for nonhaskellers.
21:35:07 <paranoid^android> that helps.
21:35:23 <paranoid^android> but getting posted on reddit late on a sunday night is bad news if I wanted to be popular there : )
21:35:35 <ttmrichter> Sunday?
21:35:44 <bos_> ?time paranoid^android
21:35:47 <dons> its Monday afternoon!
21:35:54 <dons> ?time
21:35:57 <ttmrichter> Right.  1:30PM Monday.
21:35:57 <ttmrichter> ?time
21:35:58 <paranoid^android> @localtime paranoid^android
21:35:58 <lambdabot> Local time for dons is Mon Jan  8 16:30:21 2007
21:36:07 <paranoid^android> ?time
21:36:14 <dons> your client doesn't return a time value
21:36:23 <paranoid^android> it's 3 AM here.
21:36:30 <bos_> so lambdabot silently fails? boo, hiss!
21:36:34 <ttmrichter> That would make it Monday morning.
21:36:35 <bos_> ?time
21:36:37 <lambdabot> Local time for bos_ is Sun Jan  7 21:31:02
21:36:43 <dons> kawa++ http://programming.reddit.com/info/xbc7/comments/cxfs0
21:36:46 <lambdabot> Title: What makes a programming language more productive? (reddit.com)
21:37:22 <allbery_b> ?time
21:37:24 <lambdabot> Local time for allbery_b is Mon Jan  8 00:31:49
21:38:19 <Anon4888> 3AM?  You live in greenland?
21:38:27 <paranoid^android> bos_: I can't see my blog entry on programming.reddit.com/new
21:38:32 <Anon4888> brazil?
21:38:38 <bos_> paranoid^android: it's at the top of my list.
21:38:45 <paranoid^android> oh. of course.
21:39:16 <dons> paranoid^android: its at the top :) currently in #5 on the 'hot' page
21:39:23 <dons> http://programming.reddit.com/info/xfl5/comments
21:39:25 <lambdabot> Title: Haskell, bondage-and-discipline and separation-of-concerns programming (reddit.c ...
21:40:15 <paranoid^android> The hot page can be inconsistent. I have zero points, and I'm close to articles with 93 points.
21:40:43 <Anon4888> Is there a simple haskell in haskell implementation floating around somewhere?
21:40:50 <Anon4888> *simple* being the keyword
21:41:01 <bos> paranoid^android: i think it takes the recent increase in popularity as an indicator of hottitude.
21:41:05 <ttmrichter> p^a: what's the link to the blog entry directly?  My data straw just won't let me get through to reddit right now.
21:41:05 <kilimanjaro> dons: Safety belts are for victims
21:41:33 * bos defeats the State monad, single-handed!
21:41:34 <Cale> paranoid^android: hot will rank new things higher than old things
21:41:48 <paranoid^android> http://www.wynia.org/wordpress/2006/12/19/if-marriage-was-strongly-typed/
21:41:48 <Cale> paranoid^android: but to stay near the top of hot, you have to get points
21:41:51 <lambdabot> Title: If Marriage Was Strongly Typed . . .-- The Glass is Too Big, http://tinyurl.com/y73rom
21:41:52 <goltrpoat> anon:  EHC maybe?
21:41:54 <goltrpoat> http://www.cs.uu.nl/wiki/Ehc/WebHome
21:41:56 <dons> Anon4888: hmm, yhc? helium? there's a simple type checker, and a simple parser
21:41:57 <lambdabot> Title: Ehc / Web Home
21:42:00 <dons> ah Ehc perhaps
21:42:43 <Anon4888> thanks looking
21:43:30 <Cale> aha, call will do it
21:43:36 <Cale> map(F,[],[]).
21:43:36 <Cale> map(F,[X|Xs],[Y|Ys]) :- call(F,X,Y), map(F,Xs,Ys).
21:43:43 <Anon4888> Is there a haskell interpretter somewhere?
21:43:45 <Cale> so that's good :)
21:44:04 <goltrpoat> i like how the BinProlog download page takes you to a broken link.
21:44:10 <dons> Anon4888: um, ghci? hugs?
21:44:12 <Cale> (that's in swipl, I don't know about other prologs)
21:44:20 <dons> Anon4888: all good things are available at http://haskell.org
21:44:22 <lambdabot> Title: Haskell - HaskellWiki
21:44:42 <Anon4888> yes, sorry, stupid question... I mean toy interpretter
21:44:54 <sorear> scheme-in-48-hrs?
21:44:56 <Anon4888> no emphasize on performance
21:45:05 <Anon4888> ah, yes maybe thx
21:45:16 <dons> oh, hmm, Ehc maybe? there's some mini-haskells on the 'libraries and applications' compilers page
21:45:30 <goltrpoat> baskell? :)
21:45:41 <dons> (you can write a Core haskell interpreter in < 800 lines, I reckon)
21:46:44 <dons> assignment 1 in ~cs3161 is an interpreter for MiniML, assignment 2 is a type inference/checker for the same
21:46:48 <dons> nd they do that in a week or two each
21:46:56 <Anon4888> Looking at it, I'm guessing Ehc is not toy enough
21:46:59 <dons> so you could do one of your own :)
21:47:03 <Anon4888> Yes, it'd probably make a good exercise
21:47:28 <dons> you could probably implement an smp ruby interpreter in the same time frame though
21:47:29 <raxas> Cale: once, I saw haskell code for the first time, and I abandoned all prolog-mindedness forever
21:47:32 <dons> and get super super famous
21:47:35 <sorear> I've written *tiny* type inference engines
21:47:35 <Anon4888> Should probably pick up a different language to implement it in though
21:47:36 <ClaudiusMaximus> how does the haskell run time system handle re-entrancy?  i've got C calling Haskell, but to be useful the Haskell needs to call C, which might call Haskell in the same thread?
21:47:39 <dons> (writing it in haskell, of course, perl6-style)
21:47:43 <sorear> CM: well.
21:47:50 <goltrpoat> anon:  http://www.dblab.ece.ntua.gr/~adamo/csbooksonline/student.pdf.gz
21:48:16 <bd_> ClaudiusMaximus: The FFI spec provides for a safe/unsafe flag. Use safe if the call is to reenter the haskell runtime.
21:48:16 <sorear> CM: see the safe/unsafe in the FFI - reentracy is allowed by default, at much loss of performance.
21:48:20 <goltrpoat> or.. at least that's what google said when i searched for SPJ's 'implementing functional languages: a tutorial'
21:48:36 <Cale> raxas: well, you can get back a lot of prologesque experiences through the list monad, and other nondeterminism monads :)
21:48:40 <goltrpoat> if that link turns out to be a collection of barnyard porn, blame google, not me.
21:48:50 <Lunchy> I know this is a #haskell channel, but does anyone here have experience getting pugs installed on OS X?
21:49:10 <bd_> ClaudiusMaximus: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3 last paragraph in section 3.3
21:49:37 <paranoid^android> Lunchy: there's an actual #pugs channel.
21:49:44 <paranoid^android> I think it's called #perl6
21:49:54 <Lunchy> will check it out, thanks :)
21:50:09 <Anon4888> goltrpoat: thank you!
21:50:25 <dons> Lunchy: almost certainly audreyt over in #perl6 has done this
21:50:26 <allbery_b> yes, #perl6
21:50:39 <Lunchy> yea, probably
21:51:01 <paranoid^android> " barnyard porn "
21:51:50 <Anon4888> ?where barnyard porn
21:51:50 <lambdabot> I know nothing about barnyard.
21:52:59 <dons> Skal, do you know about #haskell.fr ?
21:53:06 <goltrpoat> anon:  np
21:53:44 <dons> sorear: so this done MVar is set once things hvae settled/connected?
21:54:37 <sorear> dons: yes
21:54:39 <glguy> ?docs Data.Char
21:54:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
21:55:00 <dons> sorear: is that enough to get the autojoin problem fixed?
21:55:04 <dons> (i.e. should I rebuild now?)
21:55:13 <Anon4888> ?where sorear
21:55:13 <lambdabot> I know nothing about sorear.
21:56:58 <Anon4888> @type map map
21:56:59 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
21:57:35 <Anon4888> @type map map map
21:57:37 <lambdabot>     Expecting a function type, but found `[a]'
21:57:37 <lambdabot>       Expected type: [a -> b]
21:57:56 <bd_> @type map map [map]
21:57:58 <lambdabot> forall a b. [[a -> b] -> [[a] -> [b]]]
21:58:10 <bd_> @type map map [map] [[map map]]
21:58:11 <lambdabot>     The function `map' is applied to three arguments,
21:58:12 <lambdabot>     but its type `(a -> b) -> [a] -> [b]' has only two
21:58:25 <bd_> @type map map [map] >>= map map
21:58:27 <lambdabot>     Couldn't match `[a]' against `[a1 -> b] -> [[a1] -> [b]]'
21:58:27 <lambdabot>       Expected type: ([a1 -> b] -> [[a1] -> [b]]) -> [b1]
21:58:30 <bd_> @type map map [map] >>= map
21:58:32 <lambdabot>     Expecting a function type, but found `m b'
21:58:32 <lambdabot>       Expected type: ([a -> b] -> [[a] -> [b]]) -> [b1]
21:58:34 <bd_> bleh
21:58:41 <sorear> dons: problem encountered: just setting the mvar will allow threads to continue, but the threads will still have 'no connection' in the reader-monad.
21:58:57 <Anon4888> @type map (map map)
21:58:59 <lambdabot> forall a b. [[a -> b]] -> [[[a] -> [b]]]
21:59:06 <Anon4888> @type map (map (map map))
21:59:08 <lambdabot> forall a b. [[[a -> b]]] -> [[[[a] -> [b]]]]
21:59:31 <dons> sorear: ok. i'll wait till you let me know that its fixed
22:00:22 <Anon4888> > map (map (map map)) [[[* + - /]]]
22:00:22 <lambdabot>  Parse error
22:00:51 <Anon4888> > map map [*]
22:00:52 <lambdabot>  Parse error
22:00:58 <Anon4888> > map map [(*)]
22:01:00 <lambdabot>  Add a type signature
22:01:13 <Anon4888> > map map [(*)] :: Int
22:01:14 <lambdabot>  Couldn't match `Int' against `[b]'
22:01:19 <Anon4888> > map map [(*) :: Int]
22:01:20 <lambdabot>      Expecting a function type, but found `Int'
22:01:21 <lambdabot>       Expected type: Int
22:01:21 <lambdabot>     ...
22:01:26 <Anon4888> > map map [(*) :: Int->Int]
22:01:26 <lambdabot>      Expecting a function type, but found `Int'
22:01:27 <lambdabot>       Expected type: Int -> I...
22:01:32 <dons> :t map map [(*)]
22:01:34 <lambdabot> forall a. (Num a) => [[a] -> [a -> a]]
22:01:39 <Anon4888> heh
22:01:43 <Anon4888> > map map [(*) :: Int->Int->Int]
22:01:45 <lambdabot>  [<[Int] -> [Int -> Int]>]
22:01:58 <Anon4888> > map map [(*) :: Int->Int->Int (/) :: Int->Int->Int]
22:01:59 <lambdabot>  Parse error
22:02:01 <paranoid^android> lists of functions. I just love'em.
22:02:03 <dons> ,
22:02:15 <paranoid^android> Prolly folding over lists of functions is quite inefficient, though. (is it?)
22:02:16 <Anon4888> > map map [(*) :: Int->Int->Int (+) :: Int->Int->Int]
22:02:16 <dons> but / doesn't have that type anyway
22:02:17 <lambdabot>  Parse error
22:02:36 <bd_> paranoid^android: no less efficient than folding over anything else ;)
22:02:41 <dons> > map map [(*), (+), div :: Int->Int->Int]
22:02:43 <lambdabot>  [<[Int] -> [Int -> Int]>,<[Int] -> [Int -> Int]>,<[Int] -> [Int -> Int]>]
22:02:51 <Anon4888> > ty
22:02:52 <lambdabot>   Not in scope: `ty'
22:03:33 <bd_> I shouldn't expect it to be in general any worse than any other function call which the compiler can't or doesn't inline, right?
22:03:48 <ClaudiusMaximus> thanks sorear, bd_
22:04:01 <goltrpoat> ok, i just broke my own head.
22:04:02 <goltrpoat> > map ($ 1) $ concatMap (\f -> f [1,2,3]) (map map [(*), (+)])
22:04:04 <lambdabot>  [1,2,3,2,3,4]
22:04:04 <sjanssen> bd_: that sounds like an accurate statement
22:05:03 <Anon4888> It will probably translate into an indirect call I'd think
22:05:17 <Anon4888> so it will be no more expensive than any first class function call
22:05:18 <Anon4888> I'd think
22:06:25 <bd_> <lambdabot> [1,2,3,2,3,4]
22:06:30 <bd_> err
22:06:31 <Anon4888> map ($ 1)
22:06:38 <Anon4888> what's the $ do there?
22:06:45 <bd_> goltrpoat: I think I just about understand that now
22:06:46 <goltrpoat> it's the same thing as \f -> f 1
22:06:51 <goltrpoat> bd:  i don't
22:06:51 <goltrpoat> hehe
22:07:04 <bd_> take it in parts
22:07:10 <Anon4888> heh, I've been reading $ wrong
22:07:11 <bd_> (map map [(*), (+)])
22:07:34 <bd_> map (*) makes (*) work over a list
22:07:47 <bd_> so we have [map (*), map (+)]
22:07:48 <ttmrichter> Is there an efficient quicksort implementation in Haskell somewhere?  And a stable implementation?  Or even one that's both?  ;)
22:08:10 <paranoid^android> yay! Chad Vader ep.5  came out!
22:08:14 <goltrpoat> bd:  no i mean, i'm sure i can sort it out, it just looks.. gnarly
22:08:25 <bd_> heh
22:08:48 <paranoid^android> what do you mean, quicksort? of an array, of a list?
22:08:50 <bd_> it only looks scary until you take it one part at a time >.>
22:09:02 <ttmrichter> Say a list.
22:09:04 <sjanssen> ttmrichter: Data.List.sort used to be a quicksort, but it is mergesort now
22:09:10 <kilimanjaro> What's an instance declaration?
22:09:30 <ttmrichter> The canonical version of quicksort that I scared my class with is pretty grossly inefficient, actually, and is also unstable.
22:09:49 <ttmrichter> I'd like to see what a more efficient one would look like and/or a stable one.
22:09:50 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/Data/List.hs has a mergesort implementation
22:09:58 <bd_> and quicksort
22:10:00 <Cale> Anon4888, goltrpoat: I suppose my real question regarding prolog is why things like F(X,Y) don't do the same thing as call(F,X,Y)
22:10:08 <paranoid^android> Haskell should have pluggable syntactic sugar over type classes.
22:10:13 <bd_> with both stable and anti-stable versions :)
22:10:13 <allbery_b> the haskell98 report should have the quicksort version
22:10:25 <Cale> (I didn't know about call before, as it was never mentioned in any of the tutorials)
22:10:30 <sjanssen> ttmrichter: the URL bd_ gave you also has the old implementation commented out
22:10:46 <sjanssen> allbery_b: the report defines an insertion sort
22:10:55 <allbery_b> hm, right
22:11:13 <allbery_b> quicksort is the tutorial one, not the preamble one
22:11:16 <Cale> in particular, why this implementation of map is completely broken:
22:11:16 <Anon4888> Cale: I didn't know about call either
22:11:20 <Cale> map(F,[],[]).
22:11:20 <Cale> map(F,[X|Xs],[Y|Ys]) :- F(X,Y), map(F,Xs,Ys).
22:11:21 <ttmrichter> The report has the merge sort implemented.
22:11:43 <glguy> Does anyone know enough about Scrap Your Boilerplate to know how to generically alter a single structure (even if others match?)
22:11:46 <kilimanjaro> I'm still sort of new to Haskell. When I type "let avg = Monad.listM2 (/) sum length" into ghci I get a type error, asking for an instance declaration of (Monad ((->) [Int])) and (Fractional Int)
22:11:54 <glguy> I was thinking like: everywhereM with Cont
22:11:59 <glguy> for complicated example
22:11:59 <allbery_b> cale: IIRC you can't use a variable to make a call that way
22:12:06 <Cale> allbery_b: right
22:12:20 <allbery_b> it's been 10+ years though, and I probably ought to be in bed
22:12:24 <Cale> allbery_b: but you can write  call(F,X,Y)  instead of  F(X,Y)
22:12:37 <allbery_b> right.  indirect calls have to be via call()
22:12:38 <bd_> kilimanjaro: division on integers (length returns an Int) is the function div. Also, you need the Monad Reader instance - import Control.Monad.Reader
22:12:48 <kilimanjaro> ohh
22:12:51 <Cale> It doesn't make sense to me why they wouldn't have implemented things so that you could.
22:13:16 <Cale> or use genericLength
22:13:20 <Cale> @type genericLength
22:13:31 <goltrpoat> cale:  sorry, no idea
22:13:52 <ttmrichter> Huh.  Pretty concise and clear even with the stability and the like.  Nice.
22:13:53 <bd_> kilimanjaro: if you want Floats or whatever:
22:13:55 <treitter> if a function takes (a -> b) as input, is (a -> a) also valid input?
22:13:56 <allbery_b> I think it's a matter of parsing --- F(...) would be an assertion
22:13:57 <bd_> :t liftM2 (/) (fromIntegral . sum) (fromIntegral . length)
22:13:59 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> b
22:14:04 <allbery_b> treitter: sure
22:14:13 <bd_> treitter: yes, but the only function with that signature is f _ = undefined :)
22:14:25 <Cale> :t liftM2 (/) sum genericLength
22:14:27 <lambdabot> forall i. (Fractional i) => [i] -> i
22:14:28 <allbery_b> b will be unified with a during type inference as long as nothing else makes it think differently
22:14:35 <allbery_b> hm?
22:14:39 <Cale> hmm
22:14:44 <raxas> Cale: concept of predicates in prolog is very different from concept of functions
22:14:44 <Cale> yeah
22:15:23 <allbery_b> hm, right, (a -> b) is not so useful
22:15:25 <Cale> raxas: sure, but call(F,X,Y) "means the same" as F(X,Y), after substitution.
22:15:50 <dons> whoa, someone's posting oleg to reddit now! http://programming.reddit.com/info/xfxu/comments
22:15:50 <allbery_b> semantically yes.
22:15:54 <lambdabot> Title: Haskell as a markup language (reddit.com)
22:16:10 <Anon4888> So functions in prolog are done the same way that 2nd order logic is approximated in 1st order logic, right?
22:16:12 <allbery_b> cale:  think of it as being in the same class as Haskell's use of title case
22:16:19 <kilimanjaro> bd_: thanks
22:17:06 <Cale> allbery_b: that's all the more reason to replace instances of things like that with uses of 'call' -- they're unambiguously distinguishable
22:17:21 <bd_> allbery_b: only if you don't give it the signature f :: a -> b
22:17:28 <bd_> er
22:17:29 <bd_> wait
22:17:32 <Cale> (aren't they?)
22:17:35 <bd_> I need to stop getting myself scrolled up
22:17:36 <Anon4888> cale: I'd guess that two uses of F are in different syntactic categories
22:17:50 <Anon4888> predicates vs. values
22:18:02 <allbery_b> the use of F(...) is a different syntactic category, yes
22:18:14 <Cale> However, you're allowed to use predicates as values.
22:18:26 <Cale> map(F,[],[]).
22:18:26 <Cale> map(F,[X|Xs],[Y|Ys]) :- call(F,X,Y), map(F,Xs,Ys).
22:18:27 <allbery_b> but the value is F(...)
22:18:30 <Anon4888> Are you?
22:18:31 <Cale> that works just fine
22:18:40 <Anon4888> But F isn't a predicate there is it?
22:18:58 <allbery_b> when you say F(X,Y) it takes that entire object as a predicate, not as a functon call
22:19:06 <allbery_b> because that's how prolog parsing works
22:19:17 <treitter> allbery_b: one of the signatures of show is Show (a -> b)
22:19:24 <treitter> but I guess that's a little different
22:19:27 <allbery_b> it's just oen of the things you have to get used to, just like haskell makes you deal with (-) weirdness
22:19:37 <Anon4888> When you define F, do you define it as F(...) :- ... ?
22:19:43 <Cale> I can do things like  map(plus(1), [1,2,3], Xs), and Xs will be bound to [2,3,4]
22:19:46 <Anon4888> or do you define it as call(F, ...) :- ...?
22:19:52 <paranoid^android> 4:10 AM  dons: whoa, someone's posting oleg to reddit now! http://programming.reddit.com/info/xfxu/comments
22:19:54 <lambdabot> Title: Haskell as a markup language (reddit.com)
22:19:56 <allbery_b> treitter: no, it's (Show a) => a -> b, which is a different beast
22:19:59 <Cale> F isn't defined yet
22:20:01 <Cale> it's a variable
22:20:04 <paranoid^android> what's the whoa in that? Someone posts my stuff too, and I'm no oleg.
22:20:07 <allbery_b> unconstrainedf :: a -> b can only be undefined
22:20:38 <zeeeeeee> dons: how do i use yi? :) (more specifically, how do i get out of insert mode? esc, c-[ don't work)
22:20:41 <Cale> ?- map(plus(1),[1,2,3],Xs).
22:20:42 <Cale> Xs = [2, 3, 4] ;
22:20:42 <Cale> No
22:20:42 <lambdabot> Maybe you meant: . v
22:20:44 <allbery_b> anon:  title case in Prolog indicates a variable
22:21:02 <Cale> It even works fine when F is bound to a proper relation
22:21:09 <Anon4888> Really?
22:21:12 <allbery_b> yes
22:21:24 <Anon4888> I guess that's a special sugaring of 'call'
22:21:28 <Cale> (it returns all possible combinations of the forward images of the points in the list)
22:21:44 <allbery_b> prolog is "interesting"
22:22:07 <Cale> So I'd have designed it so that F(X,Y) means what call(F,X,Y) means here.
22:22:36 <ctkrohn> How is Oleg's approach in the article above any different from the approach in Text.XHtml?
22:23:13 <raxas> Cale: in prolog you should ask "what does it mean" instead of "what does it do". what does the map mean if call(F,X,Y) fails?
22:23:22 <allbery_b> except I;m pretty sure F(...) already means something, anbd overloading it there even though it can't mean what it normally does would be "confusing"
22:23:41 <allbery_b> there are other instances of Prolog taking that tack that I'm not recalling off the top of my head
22:23:52 <Cale> raxas: It's false.
22:23:59 <Cale> (that is, it should generate no results)
22:24:00 <treitter> what's the equivalent of argv[]?
22:24:16 <Anon4888> Ok, this is out of my depth.  Thanks for the help earlier.  g'night all
22:24:37 <Cale> In general, the number of results from map(F,Xs,Ys) should be the product of the number of results of call(F,X,Y) for each X and Y in Xs and Ys respectively.
22:24:40 <Cale> (and it is)
22:24:48 <raxas> Cale: that's quite strange, isn't it. do you find some purpose for such map?
22:24:51 <Cale> yes
22:25:11 <Cale> It exactly corresponds to map in Haskell, as well as other logic-functional languages.
22:25:24 <Cale> (well, it's more general than Haskell's map)
22:25:57 <ClaudiusMaximus> type Instance = (State, Method) ; type Method = State -> a -> IO Instance ; error "Cycle in type synonym declarations" (it would be useless for me in any case, as it breaks on reentrancy :-/ )
22:28:16 <allbery_b> treitter: System.Environment.getArgs
22:28:24 <treitter> allbery_b: thanks!
22:28:26 <allbery_b> ?ty getArgs
22:28:28 <lambdabot> Not in scope: `getArgs'
22:28:38 <allbery_b> ?ty System.Environment.getArgs
22:28:40 <lambdabot> IO [String]
22:29:15 <ClaudiusMaximus> is IORef the way to go, given the constraints that if my method outputs anything before i return, rentrancy will have a chance of happening, and i can't output anything after i return?
22:30:06 <Cale> foldr(F,Z,[],Z).
22:30:06 <Cale> foldr(F,Z,[X|Xs],Q) :- foldr(F,Z,Xs,P), call(F,X,P,Q).
22:30:10 <Cale> ?- foldr(plus,0,[1,2,3],X).
22:30:10 <Cale> X = 6 ;
22:30:11 <lambdabot> Maybe you meant: . v
22:30:20 <Cale> check that out :)
22:30:46 <Cale> So it's quite possible to write higher-order relations in prolog, at least, in swi-prolog.
22:31:04 <Cale> It's just that you have to use a slightly awkward notation for them.
22:31:07 <Cale> (call)
22:31:18 <Cale> er, to construct them.
22:31:59 <allbery_b> it's all coming back now.  aieee, the tentacles, the tentacles...
22:32:37 <Cale> It's somewhat reminiscent of common lisp in that respect.
22:33:02 <Cale> Prolog needs a scheme
22:33:06 <Cale> :)
22:33:40 <dons> zeeeeeee: hmm is it possible the vim mode is broken? it should behave like vi by default. try unpulling the recent patches for vty perhaps? or fiddle around some more
22:33:50 <dons> i'm only applying patches atm, jyp is maintaining it
22:34:16 <ttmrichter> Oh, that reminds me: is there a good text editor (non-Emacs) that has decent Haskell support?
22:34:23 <Cale> vim?
22:34:31 <ttmrichter> Vim is OK, but I'd like something perhaps slightly less modeful.  ;)
22:34:46 <allbery_b> eclipse plus eclipsefp?
22:34:54 <Cale> gedit has syntax highlighting for Haskell
22:35:04 <Cale> Lots of things have Haskell syntax highlighting at least.
22:35:18 <ttmrichter> Syntax highlighting is good, yes.  What about things like function lookups and the like.
22:35:38 <allbery_b> kdevelop has haskell syntax highlighting, but only mediocre language support otherwse last I checked
22:35:56 <allbery_b> look into eclipsefp
22:36:02 <Cale> If vim even has that, I wouldn't know :)
22:36:12 <allbery_b> http://eclipsefp.sourceforge.net
22:36:20 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
22:36:24 <Cale> There's a program to generate tags files from Haskell source.
22:36:35 <dons> check haskell.org's libraries/apps page for 'Program development'
22:36:47 <Cale> hasktags
22:36:48 <dons> pretty much everything does at least haskell syntax h now
22:36:49 <raxas> some better kdevelop support for haskell is in my todo list. maybe at end of february.
22:38:21 <raxas> i dream also about qt-4.2 bindings, but that's above my current haskell skills yet
22:39:48 <zeeeeeee> i think i tried eclipsefp at some point but i don't remember anything (positive) about it.
22:40:27 <allbery_b> I only poked at it briefly, I'm nostly not an IDE user
22:40:38 <zeeeeeee> i'd guess that vshaskell is the most powerful haskell ide available
22:41:30 <raxas> eclipse is just good for corporate work, when you need a break for coffee between every mouse clicks
22:42:17 <zeeeeeee> hasktags is deficient in many ways, and ghci's tagger doesn't always work
22:43:01 <zeeeeeee> someone mentioned vim - what package do you use for haskell development in vim?
22:43:43 <treitter> one thing the MetaTutorial seems to be missing (unless it's buried in the Monads articles - I didn't see it in the ones I've looked it) is simple file IO examples
22:45:02 <inv2004> hi all
22:45:31 <zeeeeeee> dons: vty is looks similar to the thin string-printing layer you placed atop your curses.hsc in hmp3.
22:46:09 <dons> yeah
22:46:25 <zeeeeeee> er, i mean the usage
22:46:33 <inv2004> question: I have some type in Parser.hs: date Syntax = Sfun [Syntax] offset | Svar [Char] offset | ... , in the Eval.hs I has the same type, but without offset.
22:46:37 <Cale> I added a link to http://www.haskell.org/haskellwiki/Introduction_to_IO, but it doesn't contain anything in the way of specifics about IO
22:46:38 <lambdabot> Title: Introduction to IO - HaskellWiki
22:46:41 <dons> not sure :) i've not looked at the src recently
22:47:05 <inv2004> is it possible to do smth like inheritance ?
22:47:12 <Cale> (It's mostly intended to get people off the ground so that they can understand the documentation)
22:47:26 <zeeeeeee> there was a link to http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/18#ph-3 from the metatut
22:47:28 <lambdabot> Title: Haskell hacking
22:47:44 <zeeeeeee> "You want to just do IO and command line argument handling" that has file i/o
22:47:47 <Cale> inv2004: You could just return a pair
22:48:02 <Cale> Or create a type like
22:48:17 <Cale> data SynOffset = SynOffset Syntax Offset
22:48:19 <inv2004> Cale: the problem is in the Sfun [Syntax] offset
22:48:31 <zeeeeeee> is there any introductory material or primer to things ST, STRef, and/or IORef? the closest thing i could find is http://haskell.org/hawiki/ImperativeHaskell (mentioned in an old post in repsonse to the question i just re-posed)
22:48:32 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki
22:48:58 <inv2004> y, but I need offset inside Syntax, for example (Sfun [Svar "abc" 10] 0)
22:49:51 <inv2004> if I define SynOffset, I can do only (SfunOff [Svar "abc"] 0)
22:50:19 <Cale> SynOffset (Sfun [Svar "abc" 10]) 0
22:50:39 <inv2004> ?
22:50:47 <inv2004> Svar has offset
22:50:49 <Cale> That's what it would be with the type I defined.
22:50:53 <inv2004> i don't need it
22:51:02 <Cale> oh
22:51:13 <Cale> I see
22:51:24 <Cale> You can add a parameter to the Syntax type
22:51:35 <Cale> which would allow you to extend it in various ways
22:51:41 <inv2004> I has structure like a tree, in parser I use offset, but I don't need it after parsing
22:51:46 <Cale> (and with () in the case that you want it unlabelled)
22:52:06 <malsyned_> Does anybody know what I have to pass to ghc in order to get it to link with HaRP properly?  I've got it compiling fine with HaRP as a preprocessor, but then the link phase fails.
22:52:19 <Cale> for example
22:52:36 <Cale> data Syntax a = Sfun [Syntax] a | Svar [Char] a | ...
22:52:53 <Cale> and then the parser would work with  Syntax Offset  values
22:53:06 <Cale> and these could be later projected to  Syntax ()  values if you want.
22:53:37 <inv2004> I thought about it, but if I need to save Syntax to file, it will save a too, I don't need it, doesn't care is it offset or just null
22:53:41 <treitter> how do you have lambdabot tell you which module a function is from?
22:53:56 <inv2004> save "a" too
22:54:16 <Cale> You can write your own Read and Show instances
22:54:42 <inv2004> maybe, but don't want to do it :)
22:55:02 <Cale> Or write a function (a -> b) -> Syntax a -> Syntax b
22:55:20 <Cale> and then apply it with (const ())
22:55:37 <inv2004> Parser will be separate module, and don't want to keep unused "a" in Syntax in Eval
22:55:41 <Cale> which will throw away the offsets
22:55:46 <Cale> and leave unit values
22:56:08 <Cale> then make two separate types
22:56:12 <Cale> name them differently
22:56:31 <inv2004> thx, looks like its the best way.
22:56:33 <Cale> (and their constructors too)
22:56:41 <Cale> and define a function from one to the other which throws away the offset
22:57:19 <inv2004> they're the same types, there's different in offset only :(
22:57:38 <Cale> well, that's what parametric polymorphism is for
22:57:45 <Cale> but you don't seem happy with that
22:57:52 <malsyned_> nobody uses Harp, huh?
22:58:09 <Cale> malsyned_: I haven't heard anything about HaRP in a long time
22:58:27 <Cale> The last version was released sometime in 2004
22:58:27 <malsyned_> Cale, what do people use for regular expressions these days?
22:58:41 <Cale> Text.Regex
22:58:52 <Cale> Or just use Parsec
22:58:56 <malsyned_> thanks
22:59:34 <Cale> If you're going to go to the trouble of writing regular expressions anyway, it's usually worth it to use Parsec.
23:02:10 <inv2004> interesting idea: define SynOff = SynOff Int Syntax
23:02:27 <paranoid^android> maybe a regex parser for parsec could be written.
23:02:36 <inv2004> and data Syntax a = Sfun [a] | ...
23:02:46 <paranoid^android> something that transformed a regex string into a Parsec parser. Wouldn't that be fun?
23:03:20 <Cale> inv2004: yeah, you could do explicit recursion
23:03:26 <inv2004> SynOff a = SynOff Int a
23:03:37 <treitter> what's wrong with this?:      main = do { input =<< readFile "foo.txt" ; putStr input}
23:03:54 <Cale> main = do { input <- readFile "foo.txt" ; putStr input}
23:03:54 <treitter> ghci complains that input isn't in scope on the last line
23:03:58 <Cale> yes
23:04:12 <nornagon> <-
23:04:16 <nornagon> not =<<
23:04:24 <Cale> In the first line, input is expected to be a function which is going to take the result of readFile, and produce another action to run
23:04:34 <Cale> (whose result will be thrown away)
23:04:36 <treitter> grr. So close. I swear I tried that :)
23:04:37 <ski> main = putStr =<< readFile "foo.txt"
23:04:42 <treitter> I think I probably did it without do
23:04:57 <Cale> yeah, look at ski's example
23:05:08 <Cale> for something relevant you can do with =<<
23:05:19 <treitter> ski, cale: awesome. Thanks
23:05:22 <treitter> that's what I was looking for
23:05:33 <inv2004> SynOff 0 (Sfun [SynOff 7 (Svar "abc")]), thx, going to try it
23:06:13 <Cale> inv2004: the type of that is tricky though
23:06:16 * ski is tired of trying to reason about three-level continuation monad, at the moment
23:06:31 <Cale> you might need to define a type-level Fix if you want that to be convenient
23:06:49 <Cale> ski: why three levels?
23:07:02 <ski> well, actually unbounded number of levels
23:07:06 <inv2004> y, trapped solution
23:07:19 <ski> but at most three at a time visible (yet)
23:07:21 <inv2004> but seems I can use SynOff a = SynOff Int Syntax
23:07:35 <inv2004> its not so tricky :)
23:07:36 <ski> Cale : playing around with logic programming
23:08:17 <inv2004> Syntax a = Sfun [a] ... looks good enought
23:08:24 <inv2004> bb all, thx for the help
23:08:24 <ski> (more specifically a better implication)
23:09:08 <goltrpoat> better than what? :)
23:10:04 <Cale> paranoid^android: I dislike the way that your blog lays out code.
23:10:05 <ski> better than the current 'implication-as-testing' in prolog
23:10:25 <goltrpoat> ahh gotcha
23:10:31 <paranoid^android> Cale: I can't edit CSS. I can choose another readymade template.
23:10:49 <ski> (goltrpoat : i.e. 'A => B :- \+ (A, \+ B).')
23:10:52 <Cale> It seems to be destroying indentation.
23:10:58 <goltrpoat> -nod-
23:11:12 <paranoid^android> Ah, it always does. So I eventually gave up indenting code.
23:11:25 <ski> i want instantiations to persist out of the negation :}
23:11:46 <paranoid^android> Im gonna switch templates. I hope my sidebar customizations are not lost.
23:11:56 <slava> paranoid^android: please read my comment on your web log :)
23:12:11 <paranoid^android> switched. try reloading.,
23:12:27 <goltrpoat> ive been meaning to play with logic programming in haskell a bit more.  the halfassed prover i wrote was rather fun to play with
23:13:34 <ski> goltrpoat : you've seen the paper by Ljunglf and Claessen ?
23:14:03 <Cale> paranoid^android: a bit nicer, at least it's not indenting the first line awkwardly anymore.
23:14:06 <dons> slava, welcome!
23:14:09 <goltrpoat> i have not.  claessen rings a bell though
23:14:23 * ski wonders where this blog might reside ..
23:14:51 <ski> goltrpoat : Koen Claessen,Peter Ljunglf, Typed Logical Variables in Haskell
23:14:57 <goltrpoat> well, his site is at http://www.cs.chalmers.se/~koen/
23:14:59 <lambdabot> Title: Koen Claessen
23:15:03 <goltrpoat> ah cool, thanks
23:15:03 <slava> hi dons
23:15:11 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint!
23:15:13 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:15:20 * paranoid^android was actually asleep and was woken up by the IRC client bell.
23:15:36 * ski probably ought to be asleep now
23:15:37 <paranoid^android> I'm going back to bed now.
23:15:38 * slava rings paranoid^android's bell again
23:15:59 <dons> paranoid^android: did you change the fmt on that article? it looks a lot nicer, fwiw :)
23:16:16 <dons> maybe a bit narrow?
23:16:39 <dons> (wasn't 60 chars wide Knuth's rule for TeX?)
23:17:26 <paranoid^android> dons: I can't change CSS on the free blog host.
23:17:30 <goltrpoat> ski:  there's also "a virtual machine for functional logic computations" by antoy et al
23:17:32 <paranoid^android> I just can choose from a menu of templates.
23:17:37 <dons> ah ok
23:17:39 <paranoid^android> I sleepily chose one.
23:17:44 <paranoid^android> Now I'm going back to bed.
23:17:56 <ski> (dunno how good it is to be up forty-odd hours continuously)
23:18:03 <ski> goltrpoat : ty
23:18:20 <ski> Cale : ah, you spake of LP just above
23:18:28 <Cale> ski: yeah
23:18:48 <Cale> ski: do you have any idea why prolog doesn't treat F(X,Y) the same as call(F,X,Y) ?
23:19:19 <ski> structures must have definite functors
23:20:04 <slava> have you guys seen http://www.cs.kent.ac.uk/projects/vital/ ?
23:20:12 <Cale> ski: why is that?
23:20:18 <ski> basically, the predicate part of a call is not an expression .. it must be a predicate identifier
23:20:44 <Cale> Is there a good reason for that?
23:21:00 --- mode: ChanServ set +o dons
23:21:01 <Cale> Or is it just historical?
23:21:01 <ski> what should happen if you do 'Goal = F(X,Y),F = G(Z)' ?
23:21:05 --- topic: set to '["The Haskell programming language: get yourself some cognitive dissonance!","http://haskell.org","Hac 07 Haskell Hackathon, 10-12 Jan, http://haskell.org/haskellwiki/Hac_2007","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"] :: [String]' by dons
23:21:10 --- mode: ChanServ set -o dons
23:21:33 <ski> 'Goal = G(Z)(X,Y)' ? .. such curried terms doesn't exist
23:21:35 <dons> The Hackathon starts in 2 days!
23:21:55 <Cale> Goal = G(Z,X,Y)
23:22:10 <Cale> So uncurry them, like call does
23:22:32 <goltrpoat> slava:  i played with it briefly
23:23:01 <slava> it would be interesting to see vital with a full implementation of the language, and a compiler
23:23:06 <ski> Cale : hm .. if functions were added, i think that wouldn't mix well
23:23:15 <goltrpoat> slava:  felt it was mostly just getting in the way, and the interface wasn't terribly intuitive.  maybe i should give it another try though.
23:23:16 <ski> Cale : i'm not fully sure on the *why* .. it just doesn't work with the way prolog currently works
23:23:21 <slava> i liked the interface
23:23:40 <Cale> ski: for instance, once I knew about call, I had no trouble writing map and foldr
23:23:57 <Cale> But it seemed impossible until I found out about it.
23:23:58 <ski> slava : yes, it's interesting
23:24:08 <Cale> map(F,[],[]).
23:24:08 <Cale> map(F,[X|Xs],[Y|Ys]) :- call(F,X,Y), map(F,Xs,Ys).
23:24:08 <Cale> foldr(F,Z,[],Z).
23:24:08 <Cale> foldr(F,Z,[X|Xs],Q) :- foldr(F,Z,Xs,P), call(F,X,P,Q).
23:24:11 <slava> are there any other interactive environments for haskell?
23:24:18 <slava> or do you guys just do the edit/compile/run cycle?
23:24:41 <Cale> I keep ghci open alongside my texteditor
23:24:43 <treitter> I'm trying to simplify this:         main = do { input <- getArgs ; putStr =<< readFile (head input) }   but this doesn't work:     main = putStr =<< readFile (head =<< getArgs)
23:24:45 <sjanssen> slava: I think somebody is working on a new vital that uses hs-plugins and gtk2hs
23:24:46 <Cale> :r reloads the file from ghci
23:24:52 <slava> sjanssen: cool
23:25:08 <dons> there's WinHugs and Eclipse for the windows crew. But most people use emacs/vim with ghci running (the interactive interpreter)
23:25:11 <sjanssen> slava: it was in the communities and activities report IIRC
23:25:18 <dons> sjanssen: yeah, pivot?
23:25:27 <Cale> treitter: readFile takes a string, not an IO action
23:25:28 <ski> treitter : main = putStr =<< readFile . head =<< geA
23:25:31 <ski> rm
23:25:35 <ski> treitter : main = putStr =<< readFile . head =<< getArgs
23:25:38 <ski> i think
23:25:42 <ski> :t putStr =<< readFile . head =<< getArgs
23:25:44 <lambdabot> Not in scope: `getArgs'
23:25:46 <goltrpoat> i use either textpad+ghci on windows (there's a bare-bones haskell syntax file for textpad, and you can bind keys to invoke ghci), or vshaskell
23:25:50 <sjanssen> dons: sounds familiar
23:26:03 <ski> :t let getArgs :: IO [String]; getArgs = getArgs in putStr =<< readFile . head =<< getArgs
23:26:05 <lambdabot> IO [String]; getArgs = getArgs in putStr =<< readFile . head =<< getArgs :: IO ()
23:26:07 <dons> I can't rememeber whether pivot was the precursor to vital, or the other way around
23:26:52 <zeeeeeee> dons: what are modelines in yi?
23:27:27 <treitter> Cale: yeah, I'm trying to figure out a simple way to go from IO action to String
23:27:58 <dons> zeeeeeee: from memory, its the line at the bottom of each window, stating its mode/status info
23:28:06 <dons> but check in Yi/UI.hs (and elsewhere)
23:28:46 <zeeeeeee> ah, thanks
23:29:13 <ski> Cale : simulating lambda in prolog is harder, though
23:29:31 <Cale> ski: yeah
23:29:53 <raxas> dons: is yi still broken on ghc6.6?
23:30:11 <ski> (i know of two variants)
23:30:34 <zeeeeeee> raxas: just comment out the fps requirement
23:30:52 <zeeeeeee> (use darcs head)
23:31:28 <dons> feel free to submit a patch to have it build on 6.6
23:31:34 <dons> I'm moving to 6.6 by default for everything now
23:31:38 <zeeeeeee> dons: yay
23:31:46 <dons> hopefully by the end of the week it'll all be done (i.e. hs-plugins too)
23:31:47 <vegaiW> dons: hs-plugins? :)
23:31:50 <vegaiW> ah, great
23:32:13 <ClaudiusMaximus> still pondering on my stateful re-entrancy thingy:  data Instance s = Instance s (s -> Int -> IO (Instance s)) ; type Creator s = Int -> IO (Int, Int, Instance s) -- this seems to work, question is, can hs-plugins handle a free type variable if i want to load "creator :: Creator a" ?
23:32:35 <zeeeeeee> dons: who was the current maintainer again?
23:32:54 <dons> ClaudiusMaximus: you'll need to constrain the type at some point to use it, but hs-plugins can deal just fine with polymorphic values
23:33:02 <dons> zeeeeeee: of what?
23:33:09 <zeeeeeee> dons: sorry, yi
23:33:46 <dons> ah, patches still go to me. but design discussoin should be done with 'jyp', aka Jean-Philippe Bernardy
23:33:53 <dons> (also with jyp)
23:34:44 <zeeeeeee> gotcha
23:35:26 <slava> hi shapr
23:35:52 <shapr> hiya slava, how's Factor?
23:36:45 <shapr> slava: Pivotal
23:36:53 <ClaudiusMaximus> dons: great, i'm not sure if i'll ever need to peek into the state of an instance, if i'm only doing "run (Instance s m) i = m s i" ?
23:36:57 <raxas> dons: thats a great news because it's actually hs-plugins which shocks yi on ghc 6.6 in gentoo-haskell overlay
23:36:58 <shapr> slava: http://www.cs.kent.ac.uk/projects/pivotal/
23:37:00 <lambdabot> Title: Pivotal home page
23:37:06 <slava> shapr: ooh nice
23:37:24 <dons> ah so is pivotal the new vital?
23:37:26 <shapr> yup
23:37:36 <dons> I got an email from the author about porting to ghc-api
23:37:39 <dons> has that been done?
23:37:53 * shapr dunno
23:38:11 <shapr> Downloads page still mentions hs-plugins
23:39:57 <shapr> slava: You may also like conal elliot's recent work, interacting with tangible values and something else along those lines.
23:47:01 <zeeeeeee> to send a patch, i darcs get, edit, darcs record, darcs send -o email-attachment.txt?
23:48:24 <shapr> Yeah, though I've found it's polite to the recipient to gzip the patches.
23:50:36 <bd_> perhaps darcs should have that as a builtin feature of darcs send?
23:52:58 <zeeeeeee> for some reason, even though i changed a single line, the resulting .patch is 32K
23:53:08 <bd_> zeeeeeee: it's the history references
23:53:17 <zeeeeeee> bd_: even with darcs get --partial?
23:53:52 <zeeeeeee> never mind last question
23:56:10 <dons> zeeeeeee: thanks for the patch!
23:56:26 <dons> shapr: oh. I don't like them gzipped
23:56:31 <shapr> whyso?
23:56:31 <dons> since its a little harder to read then
23:56:38 <shapr> Hm, true
23:56:39 <dons> (if the client doesn't decompress them)
23:56:48 <dons> and iI apply my patches from within mutt...
23:57:20 <shapr> dons: btw, how do you deal with things like lambdabot and lambdabot2 having different karma values?
23:57:27 <shapr> As in, their state isn't synced?
23:57:29 <bd_> might be useful for a future version of darcs to automatically handle compression and decompression of patches in darcs apply and send
23:57:32 <dons> I don't sync the state
23:57:36 <shapr> ah, ok
