00:00:44 <sorear> seeding the designers mind is a suprisingly effective way to control the evolution of software.  muahahaha.
00:01:15 <glguy> I realized that I was listing the pastes in order of when they were pasted
00:01:20 <glguy> so if people ever started using it
00:01:24 <glguy> new stuff was going to be hidden
00:01:28 <glguy> at the bottom
00:01:48 <glguy> when you only have 10 entries , it didn't matter :)
00:02:00 <glguy> !paste
00:02:00 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
00:02:52 <sorear> looks good
00:03:02 <glguy> in console ?
00:03:16 <sorear> still
00:03:35 <glguy> I just never know what you are looking at it with when you comment on something :)
00:03:53 <vegai> glguy: I suppose you're the first one with a complete public HAppS application
00:04:06 <vegai> excluding the authors of HAppS, of course
00:04:07 <glguy> I can't believe that
00:04:22 <glguy> what about that application that HAppS listed on their site
00:04:22 <vegai> perhaps not, but I don't remember any others
00:04:22 <sorear> I haven't looked at it in a graphic browser yet, except in screenshots :)
00:04:25 <glguy> as example code
00:07:10 * tessier pans pan
00:11:10 <kolmodin> ?tell dcoutts__ and finally we have some snow in gothenburg! yay!
00:11:10 <lambdabot> Consider it noted.
00:11:15 <kolmodin> morning!
00:13:55 <sorear> sleep sounds good now...
00:14:12 <kolmodin> what? I just got up..
00:14:46 <sorear> timezones considered harmful.
00:28:15 <paolino> good morning
00:28:16 <paolino> I have a type State s but I want to hide the put methods to outside the module, how can this be done ?
00:31:39 <paolino> do I have to wrap it in a newtype ?
00:34:34 * glguy wonders if hpaste will survive this change
00:34:51 <paolino> !paste
00:34:52 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
00:35:33 <glguy> hmm, polarity on line numbering is switched
00:37:28 <glguy> in my quest to delete a function... I created 3 more...
00:37:42 <glguy> (technically the code is now more orthogonal at least)
00:39:15 <hpaste>  glguy annotated "announce test" with "announce check" at http://kakapo.scannedinavian.com:8000/2#2
00:39:16 <lambdabot> Title: announce test - hpaste
00:42:00 <goltrpoat> so um.. Data.ByteString.Lazy.readFile/hGet/hGetContents/etc appears to crash ghci (6.6, windows)
00:42:27 <vegai> glguy: how does your web thing communicate with hpaste?
00:42:56 <glguy> vegai: using a Control.Concurrent.Chan.Chan PasteAnnounce
00:43:52 <glguy> data Bot = Bot { socket :: Handle, messages :: Chan PasteAnnounce}
00:43:56 <psnl> chan.chan?
00:43:56 <lambdabot> psnl: You have 1 new message. '/msg lambdabot @messages' to read it.
00:43:59 <glguy> data PasteAnnounce = NewPaste String String String
00:44:00 <glguy>                    | Annotation String String String String
00:44:05 <vegai> glguy: they're both on the same machine?
00:44:15 <glguy> psnl: one is the namespace, one is the type
00:44:19 <glguy> constructor rather
00:44:23 <psnl> ah, got you
00:44:25 <glguy> vegai: some initial process
00:44:44 <glguy> vegai: the irc bot is forked off before happs starts serving
00:44:46 <vegai> ah, ok. Now I see it
00:44:53 <glguy> and the irc bot forks off a listener
00:45:04 <glguy> to announce stuff written to the Chan
00:46:21 <paolino> track :: (Monad m) => Int -> (a -> m b) -> m d -> [m b]
00:46:22 <paolino> track n f g = foldM (\s x -> (g >> f x):s) [] [1..n]
00:46:22 <paolino> anyone can help me degug this , please ?
00:47:53 <glguy> ?type \n f g -> foldM (\s x -> do { g; a <- f x; return (a:s) }) [] [1..n]
00:47:56 <lambdabot> forall b a (m :: * -> *) a1. (Monad m, Num b, Enum b) => b -> (b -> m a1) -> m a -> m [a1]
00:48:38 <glguy> ?type \n f g -> foldM (\s x -> g >> fmap (:s) (f x)) [] [1..n]
00:48:40 <lambdabot> forall b a (f :: * -> *) a1. (Monad f, Functor f, Num b, Enum b) => b -> (b -> f a1) -> f a -> f [a1]
00:49:37 <glguy> ?type \n f g -> foldM (\s -> (g >>) . liftM (:s) . f) [] [(1::Int)..n]
00:49:39 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Int -> (Int -> m a1) -> m a -> m [a1]
00:50:07 <paolino> probably that is what I was looking for , thanks glguy
00:50:59 <glguy> ?type \n f g -> foldM (\s -> (g >>) . flip (.) f . liftM . flip (:)) [] [(1::Int)..n]
00:51:01 <lambdabot>     Couldn't match `[a1]' against `Int'
00:51:01 <lambdabot>       Expected type: [a1]
00:51:12 <glguy> bah, seemed so close
00:52:01 <glguy> ?type \n f g -> foldM ((g >>) . flip (.) f . liftM . flip (:)) [] [(1::Int)..n]
00:52:02 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Int -> (Int -> m a1) -> (Int -> a) -> m [a1]
00:52:33 <glguy> ?type \n f g -> foldM ((g >>) . (. f) . liftM . flip (:)) [] [(1::Int)..n]
00:52:35 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Int -> (Int -> m a1) -> (Int -> a) -> m [a1]
00:52:54 <glguy> I'm not pulling n f and g out for you though...
00:53:50 <glguy> welp, getting late, goodnight all
00:53:56 <wkh> night
00:54:10 <paolino> night
00:54:35 <glguy> hpaste, urly better stay up all night!
00:54:36 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
00:58:00 <notsmack> i seem to have to use fromIntegral a lot, is that normal when working with doubles?
01:19:36 <goltrpoat> notsmack:  it's not normal in any sort of performance code, since fp to int conversions are still rather expensive -- but then again, it's hard to tell from that description, if you take laziness into account
01:20:09 <notsmack> sure
01:20:54 <wkh> hey, JDBC scales!
01:20:57 <wkh> with SQLite, at least.
01:21:04 <goltrpoat> i think i have the "don't mix integers and floats" mantra beaten into me hard enough that i'd avoid it in general, just out of habit.  certainly depends on the app though.
01:21:13 <notsmack> but, for instance, i need to use it after taking the length of a list, yes?
01:22:10 <notsmack> i guess arithmetic involving list lengths and pointer coordinates are the places it's been getting on my nerves
01:22:29 <goltrpoat> right, but i guess the point is to isolate those conversions to as few places as possible, or refactor to avoid them to begin with
01:22:36 <notsmack> yeah
01:23:15 <goltrpoat> but..  again, that assumes the app is something where that type of optimization matters, and it's assuming that laziness won't do the isolation for you anyway
01:23:44 <goltrpoat> on a different note, holy crap does HaXml generate a lot of warnings.
01:23:49 <allbery_b> the one that got me was a computation involving lots of floats that expected to be able to truncate and get a float
01:24:20 <allbery_b> most of my fromIntegral-s got abtracted away when I truncate' = fromIntegral . truncate
01:24:31 <goltrpoat> -nod-
01:24:35 <allbery_b> (ephemerides)
01:25:29 <psnl> @hoogle String->Int
01:25:30 <lambdabot> No matches, try a more general search
01:26:02 <allbery_b> read?
01:26:07 <goltrpoat> @hoogle [a]->Int
01:26:08 <lambdabot> Prelude.length :: [a] -> Int
01:26:29 <psnl> allbery_b: yeah, remembered what it was called
01:26:39 <goltrpoat> hmm.  does hoogle handle polymorphism in general?
01:26:43 <goltrpoat> @hoogle [Char]->Int
01:26:44 <lambdabot> No matches, try a more general search
01:26:53 <goltrpoat> guess not
01:27:54 <allbery_b> that seems hard in general.  how polymorphic do you wan to get?
01:27:57 <goltrpoat> it'd probably get confusing in general, though.  you'd ask it for a->a and it would give you fromInteger and toInteger.
01:28:12 <goltrpoat> replacing tyvars with some fixed set of types, i guess.
01:28:18 <allbery_b> if you ask for [Char]->Int should it consider generic monadic ops?
01:28:44 <goltrpoat> ah right.
01:28:44 <allbery_b> ([Char] --> [a] --> m a)
01:29:09 <notsmack> hmm, gtk2hs signals aren't working like i'd expect...
01:30:08 <notsmack> if my buttonPress handler sets up a buttonRelease handler, the release for that click doesn't get caught by it, though the next release does
01:30:43 <goltrpoat> actually, tyvar to tycon seems easy enough.  the issue was tycon to tyvar though, and yeah it gets weird with [Char]->Int returning everything that matches m a -> b, heh.
01:30:48 <goltrpoat> oh well.
01:31:41 <goltrpoat> maybe do some "simple" substitutions if it can't find a match though?
01:32:35 <goltrpoat> eg, "can't find [Char]->Int, but here's an [a]->Int.  can't find [a]->Int, so here's an m a -> Int.  can't find an m a -> Int, so here's m a -> b."
01:32:48 <allbery_b> yeh, it'd b ehelpful, I'm just wondering about the limit if it tries [Char]->Int and gts no hits, then [a]->Int, then (Num b) => [a]->b, then (Monad m, Num b) => m a -> b ... looking for a result
01:32:57 <allbery_b> ^result^match
01:33:20 <allbery_b> otoh some of the things it currently thinks are matches can be a bit surprising
01:33:56 <notsmack> aha, figured it out.  if anybody's curious:  Explicitly turning those events on with widgetAddEvents before this lets them come through right away
01:34:00 <goltrpoat> yeah, a -> a returns throwError in the second hit
01:34:01 <goltrpoat> hehe
01:34:13 <goltrpoat> so eh.
01:36:09 <allbery_b> @hoogle (Monad m, Num b) => m a -> b
01:36:10 <lambdabot> Prelude.id :: a -> a
01:36:10 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:36:10 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
01:36:33 <allbery_b> speaking of odd results :)
01:36:40 <allbery_b> (id?!)
01:37:12 <goltrpoat> haha nice
01:39:10 <goltrpoat> but then again, i don't think there can be a function with anything remotely close to that type
01:39:10 <goltrpoat> hehe
01:39:14 <goltrpoat> so i guess it's doing the best it can
01:40:08 <dons> morning all
01:40:18 <allbery_b> well, it is just an excessively lenient type for genericLength :)
01:40:59 <allbery_b> (or excessively general if you prefer)
01:41:05 <allbery_b> morning dons
01:41:06 <goltrpoat> well, yeah
01:42:48 <goltrpoat> dons:  you're probably aware of this, but Data.ByteString.Lazy does unpleasant things to ghci 6.6 on windows.
01:43:46 <goltrpoat> (morning btw)
01:44:29 <dons> hmm?
01:44:30 <dons> it does?
01:44:45 <dons> i'm not aware of any issues.
01:44:52 <goltrpoat> hmm.. sec
01:45:29 <goltrpoat> Prelude Data.ByteString.Lazy> Data.ByteString.Lazy.readFile "c:/tasks.txt"
01:45:29 <goltrpoat> LPS <interactive>: internal error: asyncRead# on threaded RTS
01:45:57 <goltrpoat> (followed by the "This application has requested the Runtime to terminate it in an unusual way." etc)
01:46:50 <goltrpoat> Data.ByteString.readFile and friends work fine.
01:46:59 <dons> huh
01:47:10 <dons> uing which version of ghc?
01:47:13 <dons> and which version of fps?
01:47:17 <dons> the one in base?
01:47:51 <dons> could you send me the complete transcript via email, so I don't forget?
01:48:18 <goltrpoat> good point, i should probably try reinstalling fps.  vshaskell includes a version in their snapshot, but i don't know how up to date that is
01:48:59 <musasabi> That sounds like a windows bug that was fixed
01:49:01 <dons> ah ok
01:49:02 <dons> yeah
01:49:11 <goltrpoat> ah cool.  bug in fps or ghc?
01:49:19 <musasabi> ghc
01:49:20 <dons> wasn't it ghc's non blocking read stuff?
01:49:44 <dons> ok. time to check out. be good to the bot! /me disappears for 30 hours :(
01:49:47 * wkh made his java program faster by taking advantage of his second processor with simple multithreading!
01:49:57 <musasabi> see you later
01:49:58 * wkh is prouder of himself than he should be
01:50:01 <wkh> well not java, scala.
01:50:03 <goltrpoat> dons:  later
01:50:04 <wkh> later dons
01:50:22 <musasabi> goltrpoat: are you using the latest visual haskell or the old one?
01:50:58 <goltrpoat> it's 0.2, but they've actually had several releases under the 0.2 monicker, so it's hard to tell which distribution i'm running
01:51:40 <goltrpoat> er.  "several" might be just 2 (the first one had broken integration with 2005, iirc)
01:52:15 <musasabi> if their ghc version is 6.5.X you will probably just need to update it, if it is 6.6 then complaining on the list might make sense.
01:52:21 <goltrpoat> nah, it's 6.6
01:52:28 <goltrpoat> 0.0 was a 6.5 development snapshot
01:52:39 <musasabi> mmh
01:52:46 <goltrpoat> 0.2 is 6.6 stable
01:55:30 <musasabi> http://hackage.haskell.org/trac/ghc/ticket/806 is the issue.
01:55:32 <lambdabot> Title: #806 (hGetBufNonBlocking doesn't work on Windows) - GHC - Trac
01:56:16 <goltrpoat> ah, cool
01:56:36 <goltrpoat> yeah, i figured it had to be a known issue, seems pretty fundamental
01:56:36 <goltrpoat> hehe
01:57:35 <csci> Hello. I'm reading YAHT, chapter about Type basics, data types. But when I want to load a file with "data Pair a b = Pair a b" (as in the example)  with ghci, I get an error message about a parse error?
02:00:21 <csci> Answering my own question: I have to leave out module Foo where ... data Pair ... . But why?
02:00:21 <beschmi> csci: just to make sure: you don't enter data Pair .. at the ghci prompt?
02:00:43 <csci> beschmi: No, I've saved it in a file. But why can't I put it in a module?
02:00:45 <therp> csci: can you paste the error msg?
02:00:45 <therp> @paste
02:00:46 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
02:00:54 <goltrpoat> and the file
02:01:30 <beschmi> morning dcoutts_
02:01:32 <csci> ok, moment :)
02:01:43 <dcoutts__> g'morning beschmi
02:01:44 <lambdabot> dcoutts__: You have 1 new message. '/msg lambdabot @messages' to read it.
02:01:49 <dcoutts__> @arr
02:01:49 <lambdabot> Yeh scurvy dog...
02:02:37 <hpaste>  csci pasted "data types" at http://kakapo.scannedinavian.com:8000/7
02:02:55 <dcoutts__> kolmodin: I hear you're all suffering storms up north
02:03:23 <allbery_b> "module data" is wrong, module names are in title case
02:03:45 <allbery_b> module Data where ... would be okay
02:03:50 <csci> oh, thats the error. Thanks! :)
02:04:16 <wkh> woah, threads make things fast!
02:04:18 <wkh> wunderbar!
02:04:26 <allbery_b> sometimes
02:04:34 <thartman> > (*5) >>= (+) $ 4
02:04:36 <lambdabot>  24
02:04:44 <thartman> how come that doesn't work in ghci?
02:04:51 <kolmodin> dcoutts__: hia!
02:05:01 <kolmodin> dcoutts__: yeah, quite stormy
02:05:05 <wkh> thartman: ghci doesn't serve your kind.
02:05:06 <kolmodin> dcoutts__: and we have snow now!
02:05:14 <dcoutts__> kolmodin: yay!
02:05:34 <allbery_b> thartman: :m +Control.Monad.Reader
02:05:34 <joelr1> good morning
02:05:37 <dcoutts__> hia joelr1
02:05:37 <kolmodin> dcoutts__: how is that rewrite of get comming along..? :)
02:05:50 <joelr1> dons, dcoutts__: how's binary hacking?
02:05:53 <dcoutts__> kolmodin: ok, ok. I've got the idea worked out
02:06:03 <dcoutts__> joelr1: you've heard the perf results so far?
02:06:07 <thartman> danke :)
02:06:18 <joelr1> dcoutts__: not really
02:06:22 <dcoutts__> joelr1: 10MB/s on your P166 isn't all that unrealistic...
02:06:27 <kolmodin> :D
02:06:46 <dcoutts__> joelr1: we're currently getting >150MB/s max throughput
02:06:50 <joelr1> dcoutts__: wow! how did you manage that?
02:06:59 <matthew-_> magic?
02:07:20 <kolmodin> joelr1: lots of careful inlining, monoid from ross.. :)
02:07:26 <dcoutts__> joelr1: though it varies quite a bit depending on the size of records you're writing, for smaller things it's more like 10-50 MB/s
02:07:26 <joelr1> dcoutts__: or, to be more precise, how did you manage to get to that? i think a post describing your iterative performance improvements would be invaluable. profiling techniques and such.
02:07:50 <dcoutts__> joelr1: yes, we've been talking about writing something about that
02:08:06 <kolmodin> joelr1: you can read the source, not that big library
02:08:10 <kolmodin> ?where binary
02:08:11 <lambdabot> http://darcs.haskell.org/binary
02:08:13 <joelr1> dcoutts__: i went through a similar process in my last haskell project but lost the records. i saved profiling stats and recorded the changes i made
02:08:42 <dcoutts__> joelr1: basically you've just got to realise that ghc's optimiser is a term rewriting system, so you just have to program it as such
02:08:58 <joelr1> dcoutts__, kolmodin: does the repo include automatic derivation? dons mentioned it would be all of a few minutes to add this feature.
02:09:14 <kolmodin> joelr1: not in the repo, no
02:09:19 <joelr1> dcoutts__: post! please post!
02:09:28 <joelr1> dcoutts__: with examples :D
02:09:39 <goltrpoat> dcoutts:  i think it's pretty safe to say that there are hordes of people who would be interested in a post/article/whatever along those lines.
02:09:52 <joelr1> kolmodin: is that something that you are working on?
02:10:00 <kolmodin> I had something something for DriFT earlier, don't think it's compatible any more
02:10:02 <dcoutts__> you have to know what you want the final low level code to look like and then design the inlining and rule rewriting strategy to rewrite the initial terms to the final code.
02:10:26 <kolmodin> joelr1: I can fix it, yeah
02:10:48 <dcoutts__> kolmodin: did you see ndm's syb code for deriving his form of binary? it should be easy to modify.
02:10:58 <kolmodin> oh yeah
02:11:02 <kolmodin> that would be even nicer
02:11:19 <kolmodin> have to make the code readable first before I modify it
02:11:25 <dcoutts__> heh
02:12:11 <Lemmih> dcoutts__: Are you getting >150MB/s throughput with the Binary from the default repo?
02:12:48 <dcoutts__> Lemmih: yes, run make bench in the tests dir. As I said it varies widely for different types and chunk sizes.
02:12:57 <kolmodin> looked like augustss had obfuscated it
02:13:20 <kolmodin> Lemmih: yeah, for word32s in chunks of 16 at a time
02:13:26 <dcoutts__> Lemmih: and we're not commoning up the bounds checks yet, that'll be another big boost if we can make that work.
02:13:37 <dcoutts__> but it's trickier than it looks at first
02:14:06 <dcoutts__> kolmodin: it's harder than it looks because it's in a monad so you can easily end up with lambdas all over the place which get in the way of rules
02:14:17 <dcoutts__> rules work best on applicative terms
02:15:16 <dcoutts__> kolmodin: so the two major remaining tasks are 1. optimise Get 2. make the readN/readN, writeN/writeN rules work.
02:15:17 <kolmodin> dcoutts__: yeah, I had that problem when I wrote the initial library version
02:15:25 <kolmodin> yeah, cool
02:15:42 <dcoutts__> yeah, you can see what's happening if you examine the -ddump-simpl
02:16:11 <kolmodin> don't know where I put ndm's syb code..
02:17:17 <dcoutts__> kolmodin, dons knows where it is, ask him.
02:17:29 <kolmodin> dons: hia!
02:17:32 <kolmodin> is he around?
02:18:01 <allbery_b> <dons> ok. time to check out. be good to the bot! /me disappears for 30 hours :(
02:18:13 <kolmodin> gah!
02:18:32 <kolmodin> hia Jaak
02:19:12 <Jaak> morning
02:19:21 <Kototama> hi
02:21:28 <dcoutts__> kolmodin: well he's sitting next to me...
02:21:39 <dcoutts__> does that count as 'around' ?
02:21:49 <kolmodin> dcoutts__: in your world, yes
02:21:53 <dcoutts__> heh
02:21:54 <kolmodin> not for me :)
02:22:01 * dcoutts__ pings dons
02:22:21 <dons> yo
02:22:25 <kolmodin> hia dons
02:22:31 * kolmodin is looking for ndm's syb code
02:22:32 <dons> didn't quite chcek out yet, i'll wait 30 mins
02:22:37 <dons> ah ok.in my mail box
02:22:50 <kolmodin> oh, right, I'll get it there then.... muhhahah
02:22:56 <Lemmih> Hm, my box must be slow. I get a max of 29MB/s and min of 2.2MB/s.
02:23:10 <dons> Lemmih: with ghc 6.6?
02:23:14 <kolmodin> Lemmih: hardware, ghc version?
02:23:14 <Lemmih> dons: Yes.
02:23:19 <dons> yeah, what hardware?
02:23:21 <kolmodin> I get about half with ghc 6.4
02:23:59 <Lemmih> AMD Athlon XP 2400+, a 2Ghz cpu.
02:24:07 <dcoutts__> hmm
02:24:22 <dons> hmm. sounds suspicious!
02:24:25 <dcoutts__> oh, I'll commit the C benchmarks
02:24:43 <dons> you should do much much better than that, at least from what i've seen on all the other boxes
02:24:48 <dcoutts__> btw, does anyone know how to do accurate timings in C ?
02:24:53 <dons> ah, is that a 64 bit box?
02:25:01 <dcoutts__> no, not XP
02:25:06 <Lemmih> dons: I wish /-:
02:25:08 <dons> Lemmih: can you rebuild the benchmark.hs with -fvia-C ?
02:25:14 <dons> (it currently uses -fasm)
02:25:33 <dons> kolmodin: http://www.cs.york.ac.uk/fp/darcs/binarydefer/Data/Binary/Defer/Derive.hs
02:25:36 <lambdabot> http://tinyurl.com/ykfnbe
02:25:42 <kolmodin> dons: thanks!
02:27:04 * dcoutts__ pushes C memory throughput benchmark
02:27:13 <kolmodin> it requires Typeable, Show and Data of the datatype it will derive type for. that's an ok requeriment
02:27:18 <kolmodin> dcoutts__: cool :)
02:27:46 <dcoutts__> kolmodin: it's so we can see what fraction of the machine's maximum throughput we're getting
02:27:47 <Jaak> hmm, 5M to 110M
02:28:06 <dons> Jaak: yeah, sounds about right.
02:28:16 <dons> so on my 1.6Gz i get from 10->160M/s
02:28:18 <dcoutts__> kolmodin: perhaps I should just ffi import the C versions and time them from Haskell :-)
02:28:21 <kolmodin> to get better testing, finding corner cases and stuff, I've written an refragment function, :: [Int] -> L.ByteString -> L.ByteString
02:28:30 <dons> kolmodin: oh good
02:28:32 <dcoutts__> kolmodin: ok
02:28:34 <kolmodin> it makes new chunks of a bytestring
02:28:50 <kolmodin> for the get monad to see if it can read anything
02:29:12 <kolmodin> dcoutts__: hah, yeah, can't beat quickcheck in C :)
02:29:23 <dcoutts__> @arr
02:29:24 <lambdabot> Aye
02:31:18 <kolmodin> dcoutts__: the C version was quite fast..
02:31:21 <Lemmih> dons: Same results.
02:31:41 <kolmodin> dcoutts__: 100mb in 0.28 sec
02:32:02 <dcoutts__> kolmodin: yeah, they should be. it compiles to a *4* instruction loop.
02:32:14 <kolmodin> whoha!
02:32:16 <dcoutts__> it's even faster for reads
02:32:27 <dcoutts__> and even faster for word sized reads/writes
02:32:35 <dons> Lemmih: very interesting
02:32:42 <kolmodin> and you wrote that in like 30 min, hmm
02:32:43 <kolmodin> :)
02:32:44 <Jaak> memcopies and writes can be sped up with some "l33t" mmx/sse, but...
02:33:01 <dcoutts__> kolmodin: I get nearly 700 MB/s for aligned word reads on my laptop
02:33:39 <dcoutts__> Jaak: well true, but that's mostly cheating since we can't use mmx/see in binary serialisation
02:33:48 <Jaak> :)
02:33:55 <Lemmih> dons: And somewhat depressing. (:
02:34:04 <dcoutts__> but simple C byte/word copying loops are a fair comparison
02:34:06 <kolmodin> dcoutts__: so a CD a second. that's ok
02:34:17 <dcoutts__> yeah :-)
02:34:23 <kolmodin> :)
02:34:38 <dons> Lemmih: so you think its your machine?
02:34:38 <dcoutts__> so at the top end we're getting about 1/3 of the maximum for byte writes
02:34:54 <dcoutts__> since we're not doing any aligned word writes at the moment
02:35:12 <dons> though i only got an extra 15% when doing aligned word writes
02:35:14 <dcoutts__> really it shows that the problem is overhead in the looping
02:35:16 <kolmodin> true, the C version isn't nearly as flexible
02:35:30 <ttfh> does anyone here know a good resource on the history of programming language features? stuff like: "feature X first appeared in language Y in ..."
02:35:31 <dcoutts__> I talked to SPJ about this yesterday
02:35:55 <dons> ttfh: hmm. there's some in the history of haskell paper
02:36:07 <dons> and foldoc/wikipedia
02:36:10 <kolmodin> oh, guess he's interested in this project as well. pushing the limits
02:36:12 <dons> but i don't know of a general source
02:36:17 <dons> kolmodin: yeah
02:38:46 <joelr1> dons: how's the syb derivation for binaries? :-)
02:38:53 <kolmodin> dons, dcoutts__: so you're on your way home?
02:39:02 <kolmodin> or to the next conference?
02:39:08 <dcoutts__> kolmodin: I'm off tomorrow
02:39:10 <dons> joelr1: i've just sent it on to kolmodin  to hack on
02:39:19 <dons> kolmodin: yeah, i'm on my way home in like 30 mins
02:39:29 <dcoutts__> back home, then going to GHC HQ on Friday :-)
02:39:29 <dons> so i'll be out of wifi for umm. 30 hours afte rthat :(
02:39:33 <nornagon> dons: lca rocked!
02:39:42 <dons> nornagon: cool!
02:39:45 <nornagon> shame you missed it :(
02:39:49 <kolmodin> dons: argh! no price worthy wifi on the plane?
02:39:52 <dcoutts__> plenty of hacking time then eh dons?
02:39:52 <dons> i saw that some of the google Soc peoper were there
02:39:58 <dons> kolmodin: not that i know of
02:40:00 <nornagon> but a bunch of videos are up
02:40:12 <dons> nornagon: cool. did you meet ozone or kfish?
02:40:16 <dons> or patrykz?
02:40:20 <nornagon> thanks to me^Wthe kickass AV team
02:40:24 <kolmodin> dons: they sometimes have that on long flights like yours, but it's not for free..
02:40:36 <nornagon> i met patryk, i've known kfish for forever
02:40:44 <nornagon> don't think i met ozone
02:40:53 <joelr1> dons: cool
02:41:15 <wkh> have any of you guys used the Scala programming language?
02:41:26 <dons> wkh, this is the Haskell channel ;)
02:41:35 <joelr1> kolmodin: how will i know when the derivation is in? should i poke you from time to time or will you make an announcement?
02:41:35 * dons hands wkh some smp haskell threads
02:41:42 <wkh> yeah but they're similar, and there is no scala channel :(
02:41:55 <kolmodin> joelr1: poke me every 30 min from now
02:41:58 <kolmodin> j/k :D
02:42:00 <wkh> scala has hadley-milner type inference.
02:42:00 <Lemmih> dons: I hope so, yes. I'll receive my new box an a few days.
02:42:06 <dons> kolmodin: yeah so probably once the script is working, put it in 'tools' or something
02:42:13 <dons> with a little demo of how to run it from ghci
02:42:16 <dons> to dump the binary src
02:42:24 <kolmodin> yeah
02:42:26 <joelr1> Lemmih: what's your new box?
02:42:35 <kolmodin> it would be nice to have some TH as well
02:42:52 <kolmodin> so you don't have to redo your instances with a script when your datatypes change
02:43:18 <dons> Lemmih: cache size probably matters a bit to the binary
02:44:59 <Lemmih> joelr1: Its most notable features will be the dual-core 64bit cpu and the faster ram.
02:45:05 <dons> sounds good Lemmih
02:45:23 <joelr1> Lemmih: woohoo! sounds like something i'm looking to buy :-)
02:45:56 <nomeata> good morning
02:46:20 <lisppaste2> nomeata pasted "Inner Function Type" at http://paste.lisp.org/display/35677
02:46:48 <nomeata> When I run this code, I get     Inferred type is less polymorphic than expected
02:47:00 <nomeata> When I remove the inner’s function type specification, it works.
02:47:07 <nomeata> What type does the inner function have, then?
02:47:23 <nomeata> (this is just a minimal example of a more complicated thing I have here)
02:47:58 <nomeata> It’s only four lines, so to save you a click:
02:48:00 <nomeata> outer :: (a -> b) -> a -> b
02:48:01 <nomeata> outer f a = inner a
02:48:01 <nomeata>  where	inner :: a -> b
02:48:01 <nomeata>         inner a = f a
02:49:09 <Lemmih> nomeata: 'inner :: x -> y' would be the same thing.
02:49:27 <nomeata> yes
02:49:36 <nomeata> slightly simpler example:
02:49:41 <nomeata> outer :: a -> b -> (a,b)
02:49:42 <nomeata> outer a b = inner b
02:49:42 <nomeata>  where	inner :: x -> (y,x)
02:49:42 <nomeata>         inner b = (a,b)
02:49:56 <kolmodin> dons: ok, have a safe flight
02:50:12 * vegai tries to bootstrap ghc6.6 on Nexenta
02:50:34 <Lemmih> nomeata: Thing is, it doesn't give any (y,x). It gives the (a,b).
02:50:43 <nomeata> so what should I write?
02:50:51 <nomeata> :: b -> (a,b) does not work either
02:51:13 <Lemmih> nomeata: Exactly. The type variables aren't in scope.
02:51:31 <nomeata> Can I get them into scope?
02:52:00 <Lemmih> nomeata: You can add 'forall a b.' to the outer type or just remove the inner type.
02:52:18 <paolino> uhm, haskell.org is down ?
02:52:28 <nomeata> outer :: forall a b. a -> b -> (a,b)
02:52:29 <nomeata> outer a b = inner b
02:52:29 <nomeata>  where	inner :: x -> (y,x)
02:52:29 <nomeata>         inner b = (a,b)
02:52:45 <nomeata> Couldn't match the rigid variable `y' against `. (forall a b) a'
02:53:02 <Lemmih> nomeata: inner :: b -> (a,b)
02:53:08 <nomeata> (same with a and b instead of x and y)
02:53:17 <nomeata> Couldn't match the rigid variable `a' against `. (forall a1 b) a1'
02:53:54 <matthew-_> is it considered good style to reuse type variables as value variables? I know it's a different name space, but it always seems to confuse me.
02:54:00 <paolino> noobs cannot live without haskell.org !
02:54:23 <nomeata> matthew-_: I just do it here to demonstrate what variable has what type.
02:54:43 <Lemmih> nomeata: You need -fglasgow-exts for 'forall'.
02:55:00 <ibid> matthew-_: i have never seen it as a problem
02:55:17 <matthew-_> yeah, I tend to suffix the value variables with V for Value. Just to be clear. I was just wondering if there's a standard haskell style for that kind of thing
02:55:19 * paolino ssh haskell.org sudo pkill -hup httpd
02:55:33 <nomeata> ok, that works then
02:55:55 <nomeata> And there is no way that I can write a type signature to the inner function with pure haskell98?
02:57:26 <ttfh> dons: thank you, I'll look that up
02:57:35 <Lemmih> nomeata: No.
02:57:52 * nomeata is a bit disappointed.
02:59:35 <nomeata> But I’m not writing a style of code there that was unusual when haskell98 was defined?
03:00:20 <nomeata> (Assuming it were somewhat larger functions, and the variable a is something big that I don’t want to have as a parameter to the inner, recursive, function)
03:07:54 <mq_mattr> @see
03:07:55 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
03:09:44 <ibid> huh?
03:10:15 * matt_r is having trouble
03:10:27 * matt_r has it fixed
03:13:28 <Lemmih> Sounds like you neutered your trouble.
03:19:37 <dmhouse> Good morning channel! :)
03:20:11 <kolmodin> good morning dmhouse
03:20:24 <araujo> Good morning!
03:20:33 <kolmodin> hia araujo!!!1
03:20:38 <araujo> hah
03:20:40 <araujo> kolmodin!!!
03:20:47 <araujo> How you doing bud? :-)
03:20:57 <kolmodin> better, now it's down to a cold
03:21:04 <kolmodin> I can still hack!
03:21:14 <kolmodin> and you?
03:21:33 <xerox> Do you mean the weather is very cold?
03:21:47 <kolmodin> that too. but I ment that I have a cold
03:21:58 <kolmodin> we actually got snow this morning!
03:22:14 <kolmodin> first snow for this winter
03:22:29 <araujo> kolmodin, fine fine :-)
03:23:06 <xerox> Yesterday night I kept the window open until 23 o'clock, and the temperature was always >20°C. It's crazy, isn't it January?
03:23:24 <kolmodin> xerox: woha!
03:23:25 <xerox> There was an odd hot wind.
03:39:55 <vegai> gah, bootstrapping from .hc doesn't work on 6.6
03:41:02 <JKnecht> that sounds serious
03:41:10 <vegai> in rts/, make[1]: *** No rule to make target `Apply.o', needed by `libHSrts.a'.  Stop.
03:41:46 <vegai> and Apply is implemented in C--... perhaps there's something missing with Cmm builds
03:41:49 <JKnecht> stale lib/env components?
03:42:37 <vegai> Probably not? I built them just now
03:43:09 <JKnecht> entirely?
03:43:57 <vegai> Hmm, I don't know. I'll restart from scratch to make sure.
03:44:13 <kolmodin> haskell.org down?
03:44:22 <vegai> Gah. So it is
03:44:48 <vegai> Ah, I had the source package stashed away
03:45:09 <JKnecht> appears so
03:45:11 <vegai> JKnecht: I'm trying to do this with configure --enable-hc-boot
03:45:27 <kolmodin> I was trying to get dcoutts {,b}zlib
03:46:33 <JKnecht> vegai: not familiar with it.
03:49:37 <vegai> that's the "bootstrapping from .hc" -part. Afaik.
04:01:34 <Saizan> !paste
04:01:34 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
04:07:52 <xic> @hoogle transpose
04:07:53 <lambdabot> List.transpose :: [[a]] -> [[a]]
04:07:53 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
04:08:47 <nornagon> ?src transpose
04:08:48 <lambdabot> transpose []             = []
04:08:48 <lambdabot> transpose ([]   : xss)   = transpose xss
04:08:48 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
04:21:01 <xic> i am getting "*** Exception: Prelude.(!!): index too large"
04:21:12 <xic> how can i be told which line this is happening on?
04:21:36 <dmhouse> If I'm using -Wall for a project, can I turn those warnings off for a given file?
04:22:12 <nornagon> > [1..] !! 12323512462563671346245746789896789372443153
04:22:16 <lambdabot> Terminated
04:22:24 <nornagon> how are you getting that?
04:22:39 <kolmodin> xic: compile your app with -prof -auto-all
04:22:43 <xic> > [1, 2] !! 2
04:22:44 <lambdabot>  Exception: Prelude.(!!): index too large
04:22:47 <kolmodin> xic: then run it and add +RTS -xc
04:22:51 <nornagon> ah, right.
04:23:00 <kolmodin> (I think)
04:23:02 <kolmodin> worth a try
04:24:43 <xic> kolmodin: i get: <GHC.List.CAF>Test: Prelude.(!!): index too large
04:26:59 <kolmodin> xic: ok, not so helpful then
04:29:43 <astrolabe> xic: you know (!!) numbers from 0?
04:29:52 <xic> yeah
04:30:02 <astrolabe> Just checking :)
04:30:11 <xic> @hoogle trace
04:30:12 <lambdabot> Debug.Trace.trace :: String -> a -> a
04:30:12 <lambdabot> Debug.Trace :: module
04:30:12 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
04:30:40 <astrolabe> xic: dons had some scheme for finding those
04:30:40 <xic> wasn't there a trace :: (Show a) => a -> a?
04:30:56 <astrolabe> xic: easy to write you own
04:31:16 <nornagon> :t trace
04:31:18 <lambdabot> Not in scope: `trace'
04:31:20 <astrolabe> xic: also, import the prelude hiding (!!), and write your own using trace.
04:31:24 <nornagon> :t Debug.Trace.trace
04:31:26 <lambdabot> forall a. String -> a -> a
04:31:34 <nornagon> ?src Debug.Trace.trace
04:31:35 <lambdabot> Source not found. Do you think like you type?
04:32:00 <xic> ghc really should have a debug mode that gives source file an line number on unhandled exceptions :/
04:32:25 <xic> and also all of the stack values
04:32:56 <astrolabe> xic: maybe.  Some would argue that functions like head and (!!) shouldn't be used except when it is clear from local code that they will work.
04:33:36 <nornagon> !! is really not very nice.
04:38:41 <astrolabe> xic: I confess, it would be nice though.
04:39:30 <astrolabe> http://www.cse.unsw.edu.au/~dons/loch.html
04:39:31 <lambdabot> Title: LocH
04:39:39 <astrolabe> xic  ^^^^^^^^^^^^^^^^^^^
04:40:22 <xic> nice
04:41:24 <tuukkah> @hoogle mapM
04:41:24 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:41:25 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
04:41:25 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:42:28 <tuukkah> does lambdabot have an internal hoogle now?
04:58:41 <orbitz> are tehre any articles contrasting how one might oslve various problems in a functional language vs imperative?
05:10:31 <astrolabe> orbitz: I'm not aware of any that do that methodically.  There is a paper (Wadler?) that amongst other things compares an imperitive and a functional quicksort.
05:11:48 <orbitz> is quicksort somethign aht you'd wna to use in a languag eliek haskell?  Don't you want something that isn't quite made for array type structures?
05:12:21 <astrolabe> The haskell version works on lists
05:17:47 <pejo> orbitz, Okasaki's book (and probably thesis too) contains a lot of algorithms, and discussion on how to "convert" ordinary algorithms to the functional style. But that is rather specific stuff.
05:18:39 <orbitz> pejo: ok, i have been lokin gto buy that book lately, finally tiem to make use of my amazon giift cards
05:19:02 <astrolabe> http://homepages.inf.ed.ac.uk/wadler/poem.html
05:19:05 <lambdabot> Title: A Haskell Lover's Plea
05:19:08 <orbitz> i think a problem i have (which might be common) is i can visualize how to do something fairly easily in python however finding the way to do it in haskell sometimes i sa bit of a ehadscratch
05:19:38 <astrolabe> orbitz: I think that's probably lack of practice
05:19:55 <orbitz> ceritnaly i CAN do it in haskell, however it's proabbly going ot be ugly and difficult to manage
05:20:04 <astrolabe> although haskell does make me scratch my head more still.
05:20:39 <astrolabe> I find the haskell is usually more beautiful.  The extra through required pays off.
05:20:58 <astrolabe> orbitz: do you have a simple example?
05:22:07 <orbitz> astrolabe: one problem i'm working on which i haven't wirtten any code for is i need to search for a pattern in a string, and then fomr there do some backtracking to expand teh pattern out over as much of the string as i can (i want to implement BLAST in haskell and one of the first part is sequence alignment)
05:24:40 <astrolabe> orbitz: Sadly, I couldn't follow most of that :).  Have you seen parsec?
05:25:08 <orbitz> astrolabe: haven't used it
05:26:02 <orbitz> astrolabe: it's like a simple text serach so i look for a peice of text in a haystack. but once i find a peice I have to work out from both left and right directions to tr to expand that bit over the rest of teh string so wha ti'm not sure how to do nicely is go backwards through the string form the point wher ei found the match
05:26:40 <astrolabe> Hmmm
05:27:04 <orbitz> iterating one way throuhg a list is trivial but backwards not so muhc..
05:27:19 <astrolabe> I suspect it's not so hard
05:27:39 <astrolabe> Can you give a toy example?
05:27:55 <orbitz> hrm i don't have one on me rigt at the moment sinc ei'm basically jus reading up on teh algorithms
05:28:16 <pejo> orbitz, could you please try to get the characters in your words in the right order? I find your comments interesting, but I have a hard time reading them.
05:28:45 <astrolabe> I don't mean an actual example of the problem, I mean an analogous but simpler one using letters or numbers.
05:29:01 <orbitz> astrolabe: http://en.wikipedia.org/wiki/Needleman-Wunsch_algorithm is the algorithm i'm looking at right now
05:29:03 <lambdabot> Title: Needleman-Wunsch algorithm - Wikipedia, the free encyclopedia
05:29:13 <orbitz> pejo: ok
05:29:37 <orbitz> perhaps if i find the index of my match i could get a substring form beginign to that, reverse it, then iterate over that lookign fo rmy matches?
05:30:23 <astrolabe> orbitz: my initial reaction is 'yuk'  :)
05:30:56 <orbitz> astrolabe: hah in what respect?
05:31:36 <astrolabe> having to reverse the list to find things further back seems ugly to me.
05:31:44 <orbitz> oh yes
05:32:01 <orbitz> and potentionally very wasteful inteh long run
05:35:01 <astrolabe> orbitz: I think that code will be much nicer in haskell
05:36:05 <astrolabe> haskell has lazy arrays, which should make it quite neat.
05:36:40 <xic> what's a good way to save/load haskell records to a file? xml?
05:37:24 <astrolabe> xic: deriving Show and print?
05:38:03 <astrolabe> orbitz: Still there?
05:38:07 <orbitz> astrolabe: so should i use a monadic container?
05:38:17 <astrolabe> orbitz: I don't think so
05:38:37 <astrolabe> @type array
05:38:39 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
05:38:44 <orbitz> how do you think i should go about needing random access?  (or do you tink my understanding of the agorihtm is wrong an di dont' need random access?
05:39:06 <astrolabe> (I answered your question before you asked it :)
05:39:29 <astrolabe> The [(i,e)] you can do with a list comprehension
05:40:07 <astrolabe> try to mimic the recursive definition on your web page rather than the imperitive program.
05:40:09 <xic> astrolabe: hm... i'm looking for something a bit more powerful, so i can version the files in case i change the data types later
05:40:27 <astrolabe> orbitz: haskell should be able to sort out the evaluation order.
05:41:06 <orbitz> astrolabe: documetnation for array type?
05:41:31 <astrolabe> xic: You could include version info in the types perhaps, or the filenames?  I've never done something like that myself.
05:42:05 <orbitz> (also does haskell have a tree type?)
05:42:11 <astrolabe> orbitz: http://www.haskell.org/onlinereport/array.html
05:42:12 <lambdabot> Title: The Haskell 98 Library Report: Arrays
05:42:26 <ibid> orbitz: all algebraic types are trees in a sense
05:43:11 <astrolabe> orbitz: In other words, it is trivial to make your own.
05:44:05 <orbitz> i'm thinking more alogn the lines of one that might not be so trivial such as AVL or redblack (something balacned).  it may not be difficult but perhaps more than i care to deal with?
05:44:22 <astrolabe> orbitz: ah  a moment
05:44:39 <velco> Data.Map, Data.Set ?
05:44:49 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/libraries/
05:45:06 <ibid> orbitz: Map and Set are internally balanced trees, afaik
05:45:32 <orbitz> danke
05:45:48 <ibid> orbitz: the main thing one cares about them is the interface, not the implementation, though, hence we were a bit confused by your question :)
05:48:18 <orbitz> hrm
05:49:15 <orbitz> imagine i wish to use a monadic container because pretending i have side effects lets me write an algorithm more succinctly for whatever erason.  generally with monads i've een that you have to do a -> IO a   however in this case i'd wnat to go a -> a, is that possible/common/worth it?
05:49:38 <orbitz> i've only used IO operatiosn so perhaps my experience is simply IO related
05:50:12 <fasta> Can I disable all calls to assert in some kind of "release build" when I am done testing?
05:50:27 <astrolabe> orbitz: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
05:50:30 <lambdabot> http://tinyurl.com/yosw2p
05:50:44 <astrolabe> orbitz: but I'm sceptical that you really want to do that.
05:51:03 <orbitz> astrolabe: my question was in general not for this particular instance
05:51:12 <astrolabe> Liking to program inside a monad sounds like a hangover from imperative programming to me.
05:51:25 <orbitz> hehe
05:51:29 <orbitz> probably
05:51:41 <xic> what kind of monad do i want, so i can write code like: bool test() { if (a) return false; if (b) return false; if (c) return false; return true; }
05:52:16 <astrolabe> xic: Maybe ()   ?
05:52:49 <orbitz> why would you wan ta monad for that? aren't you returning true or false at all times?
05:53:16 <xic> without a monad i'll need a huge set of nested ifs
05:53:33 <resiak> isn't test equivalent to not (or [a, b, c]) ?
05:53:46 <orbitz> hrm, perhaps i'm nto following.  where would a, b, c come from in the haskell version?
05:54:06 <fasta> resiak: I was going to suggest that too.
05:54:13 <velco> xic: Maybe monad, Either monad.
05:54:23 <xic> resiak: hm...
05:54:42 <xic> not a bad suggestion
05:54:56 <xic> orbitz: variables from the parent scope
05:55:08 <velco> test a b c = do { a; b; c; return Just (); }
05:56:14 <orbitz> velco: please return MyPants ()
05:56:20 <xic> @hoogle bounds
05:56:21 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
05:56:21 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
05:56:21 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
05:56:33 <velco> orbitz: what?
05:56:44 <xic> is there a function to check if a value is within some bounds?
05:56:50 <orbitz> velco: i'd like the pants you sotle last week back, kthx
05:57:04 <astrolabe> :)
05:57:11 <ibid> xic: you can also use guards. no nested ifs there
05:58:26 <xic> ibid: hm....
06:00:39 <fasta> Anyone with an answer to my Control.Exception.assert question?
06:00:55 <ibid> fasta: what is the question?
06:01:15 <fasta> Can I disable all calls to assert in some kind of  "release build" when I am done testing?
06:01:27 <ibid> ah. no idea
06:01:47 <ibid> though disabling asserts for release is like removing your life vest when you go to the sea
06:02:07 <ibid> (attributed to tony hoare)
06:02:09 <orbitz> ibid: life vests are for lakes
06:02:11 <fasta> ibid: not really, in this case.
06:02:25 <fasta> ibid: Either way the application crashes
06:02:37 <ibid> orbitz: ok, leave the lifeboats on shore
06:02:43 <pejo> fasta, except the assert will tell you why.
06:02:59 <ibid> fasta: no, without asserts the application crashes *if you are lucky*. it could also silently misbehave
06:03:13 <fasta> pejo: right, but I will only disable the assert when I am really really sure (TM) it works.
06:03:21 <pejo> Julian Seward had some excellent points on why he has so much asserts in Valgrind. Not sure where though, probably in the developers documentation.
06:03:40 <fasta> pejo: My asserts are rather expensive.
06:03:48 * ibid tends to use asserts fairly often
06:03:56 <ibid> i never disable them for release
06:03:58 <astrolabe> @hoogle assert
06:03:59 <lambdabot> Control.Exception.assert :: Bool -> a -> a
06:04:00 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
06:04:00 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
06:04:02 <ibid> ah, expensive asserts. that is a problem
06:04:15 <fasta> ibid: I intend to use them for every function now.
06:04:31 <fasta> ibid: A good debugger would make them obsolete, though.
06:04:34 <astrolabe> fasta: import your own trivial assert library instead of the proper one?
06:04:37 <ibid> fasta: not so
06:04:55 <ibid> fasta: debugger is othogonal to asserts, asserts are test oracles
06:05:13 <ibid> of, course i never use assert in haskell ;)
06:05:14 <fasta> astrolabe: yes, I thought of that, but I would expect a compiler option for it.
06:05:28 <fasta> ibid: you don't?
06:05:28 <ibid> when i want something assert-like (for preconditions), i just use test and error
06:05:47 <ibid> stuff like, head [] = error "head []"
06:05:59 <fasta> assert gives line numbers
06:06:07 <ibid> true
06:06:34 <astrolabe> fasta: I guess they aren't h98, so there probably isn't.  You can use C preprocessor directives iirc.
06:06:51 <fasta> They are in the revised H98 standard.
06:07:02 <ibid> there is no sych thing
06:07:16 <ibid> there is a draft haskell-prime, but that's not standard yet
06:07:23 <fasta> -fignore-asserts
06:07:32 <fasta> Probably this works.
06:07:37 * fasta reads full docs
06:07:54 <erider> good morning to all
06:08:14 <astrolabe> good morning to erider :)
06:08:28 <orbitz> erider: goodnight!
06:08:34 <ibid>  /nick all
06:08:39 <ibid> good morning
06:08:45 <ibid>  /nick ibid
06:10:50 <csci> !paste
06:10:50 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
06:11:25 <hpaste>  csci pasted "Double show" at http://kakapo.scannedinavian.com:8000/9
06:11:44 <csci> Does anyone have a hint on this probably stupid easy problem ;-)
06:12:15 <csci> (I actually want to print the "M" and then the "i")
06:12:48 <astrolabe> ha
06:12:56 <astrolabe> haskell is being cryptic
06:13:06 <astrolabe> try using print instead of show
06:13:07 <goltrpoat> csci:  here's a hint
06:13:09 <goltrpoat> @type show
06:13:10 <lambdabot> forall a. (Show a) => a -> String
06:13:13 <astrolabe> @type print
06:13:15 <lambdabot> forall a. (Show a) => a -> IO ()
06:13:27 <csci> oh, i see
06:13:44 <csci> thanks (didn't knew that print exists -> beginner haskell user *g*)
06:14:01 <goltrpoat> actually, milk that one for what it's worth.
06:14:05 <goltrpoat> what's the type of pp?
06:14:29 <csci> a -> a -> [a] -> IO ()  (Just thought, did not verifed)
06:14:34 <csci> Right
06:14:35 <csci> ?
06:14:46 <goltrpoat> get it to work, then go back to your current implementation and see what monad your do statement is forcing it to go into, due to the show statements, and their type signature
06:14:55 <goltrpoat> no, very much not :)
06:15:06 <csci> :)
06:15:27 <csci> goltrpoat: I'm in the middle of YAHT -- give me some time and I'll take a deeper look into monads
06:15:42 <goltrpoat> ah ok
06:16:23 <augustss> csci: Maybe you want putChar
06:16:52 <csci> BTW: I knew more or less, depends, C, Java, Python, Ruby, Scheme but learning Haskell is like I've never programmed before. (I'm not quitr sure atm if this is positive ;-))
06:17:50 <augustss> csci: but what would be the point of learning a language if it were just like one you already know? :)
06:17:55 <astrolabe> csci: right :)
06:18:04 <goltrpoat> csci:  i had this metaphor that i used a while back, if a c++ programmer learning python is like an english speaker learning french, then a c++ programmer learning haskell is like an english speaker learning to ride a bike.
06:18:06 <csci> augustss: hehe, that's right
06:18:21 <csci> goltrpoat: Great! :)
06:18:25 <goltrpoat> :)
06:18:31 <syntaxfree> @pl f x y = x
06:18:32 <lambdabot> f = const
06:18:37 <syntaxfree> have you seen the Pancito thing?
06:18:38 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
06:19:15 <syntaxfree> hmm.
06:19:17 <syntaxfree> @type const
06:19:18 <lambdabot> forall a b. a -> b -> a
06:19:29 <syntaxfree> @pl f x y = g x
06:19:29 <lambdabot> f = const . g
06:19:44 <syntaxfree> I don't understand that!
06:19:50 <goltrpoat> ?
06:19:54 <augustss> huh?
06:20:25 <syntaxfree> I have an a->a function and want to turn it into an a->a->a function that ignores the second argument.
06:20:28 <syntaxfree> (or the first one)
06:20:31 <syntaxfree> @pl f x y = g y
06:20:31 <lambdabot> f = const g
06:21:01 <goltrpoat> ok, so, f :: a -> a, and you want some g such that f . g :: a -> a -> a, and (f . g) x y = f x?
06:21:04 <augustss> syntaxfree: and what part don't you understand?
06:21:17 <syntaxfree> why "const" does it.
06:21:20 <xerox> syntaxfree: const g = \x -> g = \x y -> g y
06:21:25 <twanvl> ?pl f x y = g x -- ignores the *second* argument
06:21:26 <lambdabot> f = const . g
06:21:48 <syntaxfree> ah, yes.
06:21:56 <syntaxfree> liftX = (const .) ; iftY = const
06:21:57 <xerox> const . g = \x -> const (g x) = \y -> g x
06:22:01 <syntaxfree> gah for dense code.
06:22:05 <syntaxfree> anyway, I got it.
06:22:25 <xerox> write it with lambda expressions, it's saner
06:22:53 <syntaxfree> I'm writing a quick library to exploit Pancito.
06:22:56 <syntaxfree> Good stuff.
06:22:59 <astrolabe> That's rich coming from 'mr >>>'!
06:23:08 <astrolabe> :)  Hi xerox
06:23:11 <syntaxfree> I did something like that about six months ago, but I eventually dropped in the face of overwhelming complexity.
06:23:17 <syntaxfree> (that = Pancito)
06:23:20 <xerox> Hiya astrolabe.
06:23:27 <syntaxfree> I'm glad that someone bothered to do the plumbing I was too lazy to do.
06:23:42 <syntaxfree> It kinda sucks that I was beaten to the punch in the functional image transformation dept though ;)
06:23:51 <goltrpoat> syntaxfree:  you know you can do these things more or less mechanically, right
06:23:53 <syntaxfree> I did some pretty images, back then.
06:24:04 <syntaxfree> these things?
06:24:13 <syntaxfree> @pl f x y = k
06:24:13 <lambdabot> f = const (const k)
06:24:16 <goltrpoat> your f = const g conundrum
06:24:34 <syntaxfree> ah, that you can mechanically calculate the pointfree version of a function?
06:24:51 <syntaxfree> @pl f x y = 5
06:24:51 <lambdabot> f = const (const 5)
06:25:03 <syntaxfree> @pl f x y k = k
06:25:04 <lambdabot> f = const (const id)
06:25:28 <goltrpoat> well, i mean, if you have a function that does what you want, but you don't understand why, you can obviously sit down and come up with a proof, right
06:25:50 <syntaxfree> yes, true.
06:26:02 <syntaxfree> I'm excited that someone bothered to do what I was daydreaming of completing for months.
06:26:09 <xic> is there a linked list, with fast insertion and delete, like c++ std::list?
06:26:17 <syntaxfree> his code is faster than mine, too.
06:26:51 <syntaxfree> this is Haskell we're talking abouti, xic ;)
06:26:59 <augustss> xic: not exactly, since you can't update destructively
06:27:07 <xerox> astrolabe: I've been suggested to read ``mock the mockingbird'' for a good introduction to the ideas behind the lambda-calculus to SKI reduction.
06:27:19 <goltrpoat> xic:  or to summarize the responses -- what is it that you want to do? :)
06:27:22 <xic> well, i mean something like STUArray
06:27:34 <syntaxfree> linked lists in Haskell:
06:27:37 <syntaxfree> > 2 : 3 : 4 : []
06:27:39 <lambdabot>  [2,3,4]
06:27:47 <syntaxfree> > head ( 2 : 3 : 4 : [])
06:27:49 <lambdabot>  2
06:27:51 <augustss> xic: in the ST monad you can make your own destructive lists.
06:27:55 <syntaxfree> > tail ( 2 : 3 : 4 : [])
06:27:56 <lambdabot>  [3,4]
06:28:06 <augustss> xic: But I doubt that's the right solution to your problem
06:28:07 <syntaxfree> I think he just wants lists.
06:28:10 <astrolabe> xerox: I haven't heard of it.
06:28:32 <xerox> astrolabe: it's written by http://en.wikipedia.org/wiki/Raymond_Smullyan
06:29:05 <augustss> xerox: "mock the mockingbird" is a nice book, but the first few chapters are enough to get the hang of SKI
06:29:09 <astrolabe> xerox: Ah, I've read books by him
06:29:23 <augustss> xerox: have you tried reading David Turner's old papers?
06:29:31 <goltrpoat> why would you need more than one chapter to present SKI? :)
06:29:40 <xic> i'm worried that inserting an element in the middle of a large list is too slow
06:29:46 <syntaxfree> Skiing is a dangerous sport.
06:29:52 <pejo> goltrpoat, becuase I might want to read the book!
06:29:53 <augustss> goltrpoat: when you talk a lot a bout birds it takes a while :)
06:30:02 <syntaxfree> You should at least have a few with-tutor sessions before venturing on the mountains by your own.
06:30:23 <cinimod> @hoogle Word32 -> [Word8]
06:30:24 <lambdabot> No matches, try a more general search
06:30:28 <augustss> xic: why are you inserting something in the middle of a list?
06:30:41 <cinimod> @hoogle Word32 -> Word8
06:30:43 <lambdabot> No matches, try a more general search
06:30:51 <cinimod> @hoogle Word8 -> Word32
06:30:52 <lambdabot> No matches, try a more general search
06:30:54 <xic> augustss: actually i mean deleting an element from the middle of a list
06:31:09 <augustss> xic: ok, so why are you deleting in the middle?
06:31:20 <goltrpoat> augustss:  i can't come up with a good pun involving meertens.
06:31:25 <goltrpoat> i give up, therefore.
06:31:37 <augustss> goltrpoat: heh!
06:31:38 <syntaxfree> @pl skip n xs = take (n-1) xs ++ drop n x s
06:31:38 <lambdabot> skip = ap (flip . ((++) .) . take . subtract 1) (flip (flip drop x) s)
06:31:49 <syntaxfree> there's your middle-of-the-list delete.
06:32:01 <syntaxfree> in clean and obfuscated form!
06:32:04 <xerox> augustss: doesn't ring a bell, sorry, what are them about?
06:32:31 <goltrpoat> lawrdy.
06:32:31 <xic> augustss: doing a particle simulation. have a list of particles, when 2 particles collide, they both are deleted
06:32:53 <augustss> xerox: "A new implementation technique for applicative languages"
06:33:24 <augustss> xic: so maybe you have sets of particles rather than lists?  or is the order important?
06:33:42 <xerox> @go to dissect a mockingbird
06:33:44 <lambdabot> http://users.bigpond.net.au/d.keenan/Lambda/
06:33:44 <lambdabot> Title: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Anim ...
06:33:45 <astrolabe> xic: I find it is best to sort out haskell efficiency as late as possible.  I find it difficult to predict what will be slow till then.
06:33:46 <goltrpoat> let delete n xs = let (first, last) = splitAt n xs in first ++ tail last in delete 5 "hello world"
06:33:52 <goltrpoat> bah.
06:33:54 <xerox> ...for a taste of the mockingbird thing
06:33:54 <goltrpoat> > let delete n xs = let (first, last) = splitAt n xs in first ++ tail last in delete 5 "hello world"
06:34:02 <lambdabot>  "helloworld"
06:34:04 <goltrpoat> not that this is recommended or anything.
06:34:55 <xic> astrolabe: order isn't important, but i need the particles to be indexable, since i need to maintain a spacial tree in order to quickly detect collisions
06:34:58 <augustss> xic: It's a good idea to figure out what the operations are on these collection of particles and then pick the suitable data structure.
06:35:12 <syntaxfree> ghci should have a shortcut for :r \n main
06:35:22 <syntaxfree> @todo-add ghci should have a shortcut for :r \n main
06:35:22 <lambdabot> Entry added to the todo list
06:35:41 <augustss> xic: and then you make an abstract type out of the particle collection and you can switch implementations later
06:35:57 <syntaxfree> aye. listen to augustss!
06:35:57 <goltrpoat> xic:  wouldn't you typically have your particle pair in a bucket of some sort though?
06:36:11 <xic> what do you mean?
06:36:29 <goltrpoat> xic:  i mean that i'm guessing that sweep and prune is still popular for this.
06:36:36 <xic> problem is that switching implementation will basicly mean rewriting everything
06:37:00 <astrolabe> That's why you wrap it in an abstract type
06:37:03 <goltrpoat> what do you mean by switching implementation
06:37:16 <xerox> > let (.:) = (.) . (.) in ((uncurry (++) . second tail) .: splitAt) 3 ['a'..'f']
06:37:17 <lambdabot>  "abcef"
06:37:42 <syntaxfree> xerox: yay.
06:37:57 <goltrpoat> someone has finally formalized the breast combinator.
06:38:07 <orbitz> finally!
06:38:10 <syntaxfree> I keep saying bind-notation isn't hard, it's just that we don't have enough good combinators yet. You just showcased that for pointfree notation as well.
06:39:06 <goltrpoat> bedtime.
06:39:07 <goltrpoat> adios.
06:40:18 <syntaxfree> @pl f x y = (g x) + (g y)
06:40:19 <lambdabot> f = (. g) . (+) . g
06:40:37 <syntaxfree> @pl f x y = h (g x) (g y)
06:40:37 <lambdabot> f = (. g) . h . g
06:40:56 * syntaxfree stops to ponder how the syntax of this can be made nicer.
06:41:26 <augustss> How about f x y = h (g x) (g y) ? ;)
06:41:54 <astrolabe> augustss: right!
06:42:12 <syntaxfree> I think i'm looking the wrong direction.
06:42:58 <augustss> syntaxfree: a small picture would also illustrate f well
06:43:08 <xerox> :t join . liftM2
06:43:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> a1 -> r) -> m a1 -> m r
06:45:31 <syntaxfree> :t (-1)
06:45:32 <lambdabot> forall a. (Num a) => a
06:48:16 <uccus> ANN: amazing discovery (argh I'm bored)
06:48:19 <uccus> > let if' True t x e y = x; if' False x t e y = y; then' = (); else' = () in if' (0 == 1) then' "bleh" else' "hello (saved) world!"
06:48:20 <lambdabot>  "hello (saved) world!"
06:49:25 <augustss> uccus: and you can make it even safer by giving then' and else' type like Then and Else
06:49:41 <uccus> lol
06:50:16 <augustss> so if' :: Bool -> Then -> a -> Else -> a -> a
06:50:24 * rahikkala looks at http://users.bigpond.net.au/d.keenan/Lambda/
06:50:25 <lambdabot> Title: To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Anim ...
06:50:42 <rahikkala> What is it with functional programming people and mockingbirds anyway?
06:51:35 <augustss> Blame Raymond Smullyan
06:51:43 <syntaxfree> I wonder what is it with FP people and bananas!
06:52:31 <Philippa> not enough women in the field?
06:52:33 <augustss> Blame Erik Meijer!
06:52:40 <xerox> > let (.:) = (.) . (.) in ((. curry . join (***)) . (.:) . uncurry) (+) (^2) 2 3
06:52:41 <lambdabot>  13
06:52:44 <xerox> ^- syntaxfree
06:53:37 <syntaxfree> Erik Meijer is one of the Wadlermen. Blame him not.
06:53:51 <uccus> what's a Wadlerman?
06:54:36 <syntaxfree> The Wadlermen are a  conspiracy of People With Big Brains trying to make us feel stupid :)
06:55:51 <augustss> syntaxfree: Is it being successful?
06:56:03 <syntaxfree> dunno.
06:56:12 <syntaxfree> @tell wadler is the Wadlermen conspiracy being succesful?
06:56:13 <lambdabot> Consider it noted.
06:56:19 <syntaxfree> some day we'll know.
06:56:21 <augustss> World domination is next.
06:56:30 <uccus> does anyone know what's Wadler up to these days? I'm just curious. I read some of his writings and am a great fan of his ideas.
06:56:44 <syntaxfree> I'm not only a big fan.
06:56:51 <syntaxfree> I pray in the direction of Glasgow at noon.
06:57:00 <augustss> uccus: The latest I heard Phil talk about was Links.
06:57:09 * syntaxfree waits for the flood of "all the good people left Glasgow" comments.
06:57:56 <augustss> Oh, John O'Donnell is still in Glasgow. :)
06:58:17 <uccus> my small brain prevents me from comprehending the full weight of these things
06:58:39 <syntaxfree> uccus: see? They're winning!
06:59:02 <uccus> linear logic and uniqueness types? I guess if Wadler's interested I would be a fool not to be
06:59:03 <augustss> World domination is near!
06:59:08 <syntaxfree> Once we felt smart about grokking some abstract algebra or real analysis.
06:59:16 <uccus> augustss: amen
06:59:32 <syntaxfree> Now we can't feel halfway adequate without even a working knowledge of cat theory.
06:59:42 <syntaxfree> s/can't feel/can't even feel
07:00:27 <uccus> is there any research into uniqueness inference in Haskell compilers?
07:00:52 <SamB> syntaxfree: cat theory?
07:00:56 <syntaxfree> yes.
07:01:00 <SamB> you have heard of a theory of cat behaviour?
07:01:09 <SamB> that is incredible!
07:01:09 <syntaxfree> you know, Mingus, Coleman Hawkins, Dizzy Gillespie.
07:01:16 <syntaxfree> people with horns & basses.
07:01:34 * SamB has heard of people with horns and tails
07:02:25 <huschi> does anybody know a good way to generate the infinite list a,b,...,z,aa,ab,...,az,...,zz,aaa,aab,...?
07:02:52 <syntaxfree> explicit recursion?
07:03:19 <chessguy> ?seen dons
07:03:19 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 4h 18m 12s ago.
07:03:34 <SamB> huschi: someone found a way a while back...
07:03:35 <xerox-> oh I was lagging out.
07:03:38 <uccus> chessguy: it's 2:00 here in Sydney...
07:04:02 <chessguy> oh, whoops
07:04:11 <huschi> SamB: where can i find it?
07:04:16 * xerox- checks the logs
07:04:22 <SamB> xerox: good idea
07:05:02 <SamB> oh, but you aren't looking for that function are you ?
07:05:43 <uccus> huschi: can you find a function that encodes any integer into those strings?
07:05:50 <SamB> huschi: I suppose you could just use explicit recursion, rather than try searching the logs...
07:06:15 <uccus> huschi: like, 0 -> "a", 1 -> "b", ... 26 -> "aa"?
07:06:22 <huschi> uccus: that woul be overkill i think.
07:06:30 <SamB> huschi: oh really?
07:06:38 <uccus> hehe
07:06:49 * SamB can't think how the recursion pattern would go right now
07:06:51 <huschi> uccus: you mean something like convert the number to base 26 with digits a to b, i think.
07:06:57 <uccus> I am deeply in love with this language...
07:06:58 <huschi> SamB: i will try.
07:06:59 <uccus> yes.
07:07:06 <augustss> huschi: concatMap sequence $ iterate (['a'..'z']:) []
07:07:08 <syntaxfree> > convert c = ord c - ord a
07:07:09 <lambdabot>  Parse error
07:07:30 <syntaxfree> > let convert c = ord (toLower c) - ord 'a' in ord 'D'
07:07:31 <lambdabot>  68
07:07:42 * syntaxfree ducks
07:07:46 <uccus> syntaxfree: I want the opposite of that!
07:07:53 <huschi> augustss: great.
07:07:58 <augustss> > take 10 $ concatMap sequence $ iterate (['a'..'c']:) []
07:08:00 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc"]
07:08:01 <huschi> that's what i wanted.
07:08:32 <SamB> > concatMap sequence $ iterate (['a'..'c']:) []
07:08:34 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
07:08:37 <huschi> allthough i have to take the tail.
07:08:43 <uccus> :|
07:08:48 <augustss> that's ok :)
07:08:58 <syntaxfree> you could just generate all numbers and convert them to base 26!
07:09:00 <SamB> huschi: taking the tail is O(1) isn't it?
07:09:43 <chessguy> @type iterate
07:09:44 <lambdabot> forall a. (a -> a) -> a -> [a]
07:09:45 <orbitz> i'd hope so!
07:10:14 <SamB> orbitz: well. it depends on whether or not you include the cost of calculating the tail ;-)
07:10:22 <uccus> syntaxfree: auguetss' solution is so elegent, I don't think mine stands any chance now
07:10:25 <chessguy> > iterate (*2) 3
07:10:26 <lambdabot>  [3,6,12,24,48,96,192,384,768,1536,3072,6144,12288,24576,49152,98304,196608,3...
07:10:33 <huschi> SamB: i know. i just wanted to emphasise that the list has one element to much.
07:10:57 <uccus> ?type concatMap
07:11:06 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
07:11:19 <SamB> huschi: it must be easier to get that list, then!
07:11:42 <chessguy> ?src iterate
07:11:43 <lambdabot> iterate f x =  x : iterate f (f x)
07:11:59 <augustss> ?src concatMap
07:12:00 <lambdabot> concatMap f = foldr ((++) . f) []
07:12:10 <chessguy> heh. haskell makes this stuff way too easy
07:12:54 <_roconnor> > sequence =<< inits (repeat ['a'..'c'])
07:12:56 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
07:13:49 <roconnor> inits is cojoin, and repeat is coreturn right?
07:13:53 <chessguy> > iterate (['a'..'c']:) []
07:13:54 <lambdabot>  [[],["abc"],["abc","abc"],["abc","abc","abc"],["abc","abc","abc","abc"],["ab...
07:14:13 <SamB> heh
07:14:31 <roconnor> so it really ought to be sequence =<< cojoin (coreturn ['a'..'c']), ... I think
07:14:44 <roconnor> It's all monadic and comonadic
07:15:14 <augustss> We're still waiting for the comonad module :(
07:15:39 <roconnor> Actually I'm not sure the types quite work out for that.
07:15:42 <SamB> augustss: that probably explains why we don't have one
07:16:57 <xerox> > zipWith replicate [1..] (repeat "abc") >>= sequence
07:16:59 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
07:17:17 <roconnor> > zipWith replicate [0..] (repeat "abc") >>= sequence
07:17:18 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
07:17:42 <chessguy> ?src sequence
07:17:43 <lambdabot> sequence ms = foldr k (return []) ms
07:17:43 <lambdabot>     where
07:17:43 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:17:43 <xerox> The important empty case.
07:17:51 <chessguy> @type sequence
07:17:53 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:19:55 <chessguy> hmm, that type signature doesn't make sense to me
07:20:16 <tibbe> @users
07:20:16 <lambdabot> Maximum users seen in #haskell: 311, currently: 283 (91.0%), active: 35 (12.4%)
07:20:33 <chessguy> it takes any kind of monad, and any type, and then takes a list of monads of type a, and returns a monad of a list of type a
07:20:39 <chessguy> is that right?
07:20:43 <uccus> chessguy: you are right. you can't tell what it does on lists by its signature
07:20:46 <paolino> does hiding apply to module directive also ?
07:22:32 <paolino> module Paolino hiding DumbFact where  ?
07:23:08 <roconnor> oh, that would be a good idea.
07:23:27 <roconnor> well maybe
07:24:12 <paolino> ok, so to hide on I have to export the rest only ?
07:24:18 <paolino> *one
07:24:40 <roconnor> that's the way I do it
07:24:54 <paolino> module Paolino (.......... but DumbFact) where ?
07:25:52 <roconnor> I suppose it is good practice explicitly list what you are exporting.
07:25:52 <paolino> looks asymmetric
07:26:44 <roconnor> I think the difference is that your export list affects everyone in the world while your import list only affects your current module.
07:27:15 <roconnor> at least your export list affects the entire world so long as people import entire modules
07:28:06 <roconnor> It might actually be better for people to list their imports explicitly
07:28:07 <augustss> paolino: hiding for exports would be handy now and then
07:28:13 <paolino> ok, really what I miss is an exportTo directive which exports symbols only for some child modules
07:28:51 <roconnor> of course, since we can export the entire module with ease, we might as well have a hiding directive too
07:29:46 <paolino> it's a shame I have to clutter a module only because I don't want everyone see one symbol
07:30:20 <paolino> so I don't export it and everything needs it goes there in the module
07:31:56 <fasta> What's better: sum (<function generating list of ints>) or foldr <same function but implement adding too>? I guess separation of concerns wise, the former would be better.
07:32:43 <tibbe> and easier to read?
07:32:57 <tibbe> generator/consumer
07:34:08 <syntaxfree> a hiding keyword would be fun, yes.
07:34:53 <dcoutts__> fasta: the first is better and in future it'll fuse too
07:35:36 <syntaxfree> @free sum
07:35:37 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Num a) => [a] -> a\n"
07:35:39 <dcoutts__> at least if (<function generating list of ints>) is a good producer
07:36:35 <augustss> @free syntax
07:36:37 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `syntax'\n\n"
07:36:57 <dcoutts__> hmm, seems broken
07:45:06 <syntaxfree> @. elite . free pl f x = 3
07:45:06 <lambdabot> eXtra 5TUFF At EnD 0f liN3
07:45:18 <syntaxfree> 5TUFF.
07:46:01 <Vq^> :)
07:46:49 <chessguy> > head $ iterate (['a'..'c']:) []
07:46:50 <lambdabot>  []
07:48:36 <socrates2> how can i get haskell to pass greek/russian characters?
07:48:51 <socrates2> im on winHugs
07:49:10 <socrates2> the light-weight version.
07:50:10 <syntaxfree> @google hugs unicode
07:50:12 <lambdabot> http://www.golubovsky.org/software/hugs-patch/hugs_unicode_test.html
07:50:13 <lambdabot> Title: Experimental Support of Unicode in Hugs
07:53:14 <chessguy> ?src foldr
07:53:14 <lambdabot> foldr k z xs = go xs
07:53:15 <lambdabot>     where go []     = z
07:53:15 <lambdabot>           go (y:ys) = y `k` go ys
07:58:20 <socrates2> does that allow acceptance of greek/russian characters
07:59:48 <JKnecht> should if you have right UTF variant set (southern european?)
08:00:07 <JKnecht> and it aint too 'experimental'
08:00:51 <JKnecht> actually, experimental I would take at face value
08:01:24 <kowey> UTF variant?
08:04:19 <JKnecht> I assumed winHugs had something that allowed one to set the character set
08:05:31 <kowey> i was just commenting on 'UTF variant'; i thought the variants consisted of 8, 16, and 32?
08:05:47 <kowey> (as opposed to 'southern european', etc)
08:06:07 <JKnecht> to something like UTF-8 or ISO-8859-7, Mac Greek, or the like
08:06:39 <kowey> ah, ok
08:24:51 <sorear> tell fodder
08:24:52 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:27:13 <orbitz> are there bindings for haskell for somethig nliek imagemagic? so i can open/manipulate/save somethign like a .jpg
08:27:34 <xic> i was wondering the same thing
08:27:44 <sorear> GD?
08:27:48 <orbitz> gd works
08:27:51 * SamB seems to remember having heard of something like that
08:27:53 <sorear> (has a binding)
08:28:06 * sorear checks the wiki for a url
08:28:12 <sorear> @where gd
08:28:13 <lambdabot> I know nothing about gd.
08:28:17 <xerox> there're the ones from bringert too
08:29:09 <allbery_b> pancito was mentioned on planethaskell overnight
08:29:22 <bos> pancito is purty.
08:29:44 <sorear> argh, wiki-search turns up nil.
08:30:02 <bos> better nil than _|_
08:38:22 <allbery_b> @go haskell gd graphics
08:38:25 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-gd/doc/
08:44:02 <augustss> bos: does pancity still work, or has it bit rotted?
08:44:41 <augustss> s/city/cito/
08:50:10 <Failure02> doesn't ghc or hugs have some mode that shows you the # of reductions it's made? i can't find it now
08:50:19 <sorear> hugs yes
08:50:27 <Failure02> how do i enable it?
08:50:28 <sorear> GHC doesn't do reductions
08:50:34 * sorear doesn't use hugs
08:50:49 <Failure02> ok
08:50:53 <sorear> for GHC the -prof is probably what you want
08:51:07 <sorear> GHC has a full time/space profiler
08:51:11 <Cale> :set +s
08:51:36 <Cale> Hugs.Base> 1 + 1
08:51:36 <Cale> 2
08:51:36 <Cale> (28 reductions, 64 cells)
08:52:22 <Failure02> thanks
08:52:24 <Failure02> what does -prof do?
08:52:39 <sorear> it's a compiler option, switches on profiling
08:52:56 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/profiling.html
08:52:57 <Cale> Compiling with -prof -auto-all and then running your program with +RTS -p -RTS will produce a profile report
08:52:58 <Failure02> is it the same as :set +s?
08:52:59 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/ytc2r9
08:53:04 <Cale> not at all
08:53:38 <syntaxfree> reductions? what are reductions?
08:53:53 <Cale> It produces a report of how much CPU time and memory each function was responsible for, and how many times each function was entered.
08:54:00 <syntaxfree> bos: isn't it great?
08:54:06 <syntaxfree> I had that same idea about eight months ago.
08:54:16 <Cale> syntaxfree: Hugs probably works via direct graph-reduction.
08:54:20 <syntaxfree> I even wrote a PPM reader/writer and some stuff.
08:54:36 <syntaxfree> Nowhere near as "complete" as Pancito.
08:54:47 <Cale> Apparently the transformation from  1 + 1 to (+) 1 1 takes 2 reductions. I'm not completely sure why.
08:55:01 <syntaxfree> 28 reductions!
08:55:05 <Cale> er, no
08:55:09 <sorear> Cale: currying?
08:55:20 <Cale> It's just that required an extra 2 reductions the first time I did it.
08:55:29 <Cale> Now it's 26 no matter how I write it
08:55:59 <sorear> show might be guilty
08:56:09 <Cale> well, yeah
08:56:22 <Cale> There's actually a reasonable amount of stuff going on there.
08:56:29 <Cale> There's also a read going on
08:56:37 <Cale> I'm not sure if that's counted.
08:56:41 <sorear> and fromInteger
08:56:49 <Cale> right
08:57:16 <augustss> 28 sounds cheap if show is involved
08:57:20 <Cale> adding digits to the number doesn't seem to require more reductions
08:58:39 <syntaxfree> show necessarily involved a list of chars, right?
08:58:51 <Cale> yeah
08:58:59 <Cale> but now I don't think it's counting that
08:58:59 <syntaxfree> worse yet, it's not consing, it's appending.
08:59:43 <Cale> Hugs.Base> show 4553189732918
08:59:43 <Cale> "4553189732918"
08:59:43 <Cale> (268 reductions, 357 cells)
09:00:06 <syntaxfree> try show 2.
09:00:12 <syntaxfree> and compare to show 1+1
09:00:24 <Cale> Hugs.Base> show 2
09:00:24 <Cale> "2"
09:00:24 <Cale> (52 reductions, 71 cells)
09:00:24 <Cale> Hugs.Base> show (1+1)
09:00:24 <Cale> "2"
09:00:25 <Cale> (56 reductions, 75 cells)
09:00:36 <complaisant> ?how can i calculate the intermediate type if an hylomorphism?
09:00:37 <lambdabot> Maybe you meant: show yow
09:00:39 <sorear> apt-get source hugs
09:00:44 <Cale> It looks like there's possibly some constant overhead.
09:00:55 <sorear> let's see what that says...
09:04:20 <Cale> complaisant: hm?
09:07:16 <benja_> I'm getting "Illegal instance declaration for `Monoidal f' (There must be at least one non-type variable in the instance head -- Use -fallow-undecidable-instances to permit this)"
09:07:20 <benja_> but I *do* have {-# OPTIONS_GHC -fallow-undecidable-instances #-}
09:07:26 <benja_> at the top of the file
09:07:31 <benja_> anybody have an idea what is going on?
09:07:39 <benja_> I have GHC 6.4.1
09:08:14 <benja_> the instance looks like this:
09:08:15 <benja_> instance (FunctorUnit f, FunctorZip f) => Monoidal f where {}
09:08:50 <complaisant> http://en.wikipedia.org/wiki/Morphism <-
09:09:46 <complaisant> hylomorphism f g = http://en.wikipedia.org/wiki/Catamorphism f . http://en.wikipedia.org/wiki/Anamorphism g
09:10:13 <Cale> yeah, I know that much, I don't understand what you're asking
09:10:37 <complaisant> Cale : do u know how to calculate the intermediate type ?
09:10:51 <Cale> What do you mean by "intermediate"?
09:11:41 <complaisant> well like a dups :: (Eq a) => [a] -> Bool
09:11:43 <XRayNuke> Is there a non-lazy version of hGetContents? I want to run an external program and return the complete contents of its output and error streams, as well as the exit code. I think http://pastebin.ca/322665 is the right way to do it but if I call it on a list of FilePaths, it'll only return a value for the first one, then the second call seems to hang and the external program doesn't terminate. I'm using GHC 6.6 on an Intel Mac. Using -thr
09:11:46 <complaisant> dups [] = False
09:12:00 <complaisant> dups (h:t) = elem h t || dups t
09:12:22 <complaisant> if u express that as a hylo
09:12:24 <complaisant> the intermediate type is [Bool]
09:12:48 <complaisant> i mean intermediate as the output of the ana consequent input of cata
09:13:24 <Cale> complaisant: So you mean the type of the result of an anamorphism then?
09:14:36 <complaisant> yes
09:14:38 <Cale> XRayNuke: Well, not really, though you can force the contents to be read using evaluate (length output) (the evaluate function is defined in Control.Exception)
09:15:43 <sorear> XRayNuke: use Data.ByteString.Char8.readFile
09:15:59 <sorear> XRayNuke: please don't say anything longer than 512 characters
09:16:06 <Cale> Yeah, that might be better.
09:16:11 <XRayNuke> sorear: duly noted
09:16:20 <sorear> XRayNuke: read RFC 2812, IRC servers are required to truncate what you say
09:16:33 * allbery_b wishes (some) IRC clients weren't so stupid about that
09:16:33 <Cale> XRayNuke: Your message was likely cut off:  "Using -th" was the end of it.
09:16:40 <complaisant> [( g )] :: [Int] -> F X
09:16:40 <complaisant> [(g)] = in . ( id -|- id >< [(g)] ) . g
09:16:48 <complaisant> how do u know the type of F X ?
09:17:12 <sorear> uh F X? Haskell type signatures, if accepted, are the truth.
09:17:24 * sorear is pretty sure he is misunderstanding complaisant's want
09:17:27 <XRayNuke> Cale: -threaded option for GHC doesn't seem to have any effect on the hang.
09:17:54 <sorear> XRayNuke: get lambdabot, read Lib/Process.hs
09:17:55 <complaisant> sorear : it's an alternate notation that is adopted by my teacher
09:18:12 <sorear> XRayNuke: there is a function in that file that does exactly what you want
09:18:15 <sorear> (popen)
09:18:21 <sorear> @where lambdabot
09:18:22 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
09:18:44 <complaisant> it could b :
09:18:44 <complaisant> [( g )] :: [Int] -> a
09:19:31 <complaisant> ?paste
09:19:32 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
09:20:58 <Failure02> how can i force ghc to evaluate a function? i want to compare the runtime of two functions, but if i run them, all the time goes towards printing the results (huge lists)
09:21:17 <sorear> Control.Parallel.Strategies.rnd
09:21:17 <sorear> Control.Parallel.Strategies.rnf
09:21:23 <Cale> Failure02: you could compute the length of the lists
09:21:37 <sorear> Cale: what if the values are lazy?
09:22:14 <Cale> Well, yeah, that won't necessarily force the actual values.
09:22:16 <augustss> Failure02: do something that consumes all the elements
09:22:37 <Failure02> hm, like summing them
09:22:42 <Failure02> i'll try that
09:22:43 <sorear> rnf should force everything
09:22:45 <Cale> foldr seq () [1..10]
09:23:13 <Cale> which is equivalent to  [1..10] `using` rnf
09:23:27 <sorear> foldr seq ? "but what about shortcut deforestation!" :)
09:23:41 <Cale> hm?
09:23:49 <Cale> It'll have to evaluate all the elements.
09:24:02 <sorear> foldr/build assumes parametricity :(
09:24:14 <Failure02> sorear: uhm, how do i use that? i only get 5 resultson google
09:24:14 <Cale> right, at least, as usually stated
09:24:40 <Cale> Failure02: use Control.Parallel.Strategies?
09:24:43 <Failure02> yeah
09:25:08 <sorear> > Control.Parallel.Strategies.rnf [1 .. 10]
09:25:09 <lambdabot>   Not in scope: `Control.Parallel.Strategies.rnf'
09:25:31 <sorear> it's just a function from (anything in NFData) to ()
09:25:41 <sorear> such that forcing the () forces all the data
09:25:48 <sorear> type Strategy a = a -> ()
09:25:51 <Cale> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
09:25:55 <lambdabot> Title: Algorithm + Strategy = Parallelism, http://tinyurl.com/22srxl
09:26:07 <Cale> that paper describes the library if you really care that much :)
09:26:09 <sorear> but you don't need all the fancyness
09:26:25 <Cale> In this case, I'd be more likely to just use foldr seq ()
09:27:19 <Failure02> it's actually a list of lists
09:27:44 <sorear> rnf will handle that automatically
09:27:55 <Failure02> what's NFData?
09:28:05 <sorear> foldr (seq . foldr seq ()) () anyone :)
09:28:15 <sorear> Failure02: anything that can be forced deeply
09:28:24 <sorear> Failure02: into *N*ormal *F*orm
09:28:49 <sorear> @instances-importing Control.Parallel.Strategies NFData
09:28:51 <lambdabot> (), (a, b), (a, b, c), Assoc a b, Bool, Char, Double, Float, Int, Integer, [a]
09:29:24 <sorear> so [[(Int,[Char])]] for instance
09:29:57 <Failure02> i get this error
09:29:58 <Failure02> Couldn't match `IO a' against `Done'
09:30:12 <sorear> oh
09:30:18 <sorear> evaluate . rnf then
09:30:18 <Failure02> when i do main = Control.Parallel.Strategies.NFData (f x)
09:30:31 <sorear> main = evaluate $ Control. ....
09:30:44 <sorear> type Done = ()
09:31:06 <Failure02> where's evaluate? not in prelude nor Control.Parallel.Strategies
09:31:11 <sorear> :t Control.Exception.evaluate . Control.Parallel.Strategies.rnf
09:31:13 <lambdabot> forall a. (Control.Parallel.Strategies.NFData a) => a -> IO Control.Parallel.Strategies.Done
09:31:38 <sorear> it forces a value in IO
09:31:46 <sorear> Control.Exception btw
09:32:01 <Failure02> i get "Ambiguous type variable `a' in the constraints"
09:32:21 <sorear> is the function you are benchmarking polymorphic?
09:32:31 <sorear> you'll need to give it a specific type
09:33:02 <sorear> after all sqrt :: Double -> Double and sqrt :: BigFloat -> BigFloat have very different perf characteristics :)
09:33:17 <Failure02> yeah :)
09:33:22 <sorear> (BigFloat is infinite-precision reals, in an extension library)
09:33:31 <Failure02> um, what's the type of main again?
09:33:35 <sorear> IO ()
09:33:51 <sorear> and Done is the same as ()
09:35:49 <Failure02> ah, that works
09:35:51 <Failure02> thanks for the help
09:35:59 <sorear> yw
09:38:52 <Saizan> glguy,sorear: what do you think of this interface for line-numbers? http://saizan.no-ip.org/1/nums
09:38:54 <lambdabot> Title: asdasd - hpaste
09:39:39 <sorear> I like it
09:40:20 <glguy> !paste
09:40:21 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
09:40:28 <Saizan> [183448] <Saizan> glguy,sorear: what do you think of this interface for line-numbers? http://saizan.no-ip.org/1/nums
09:40:30 <lambdabot> Title: asdasd - hpaste
09:40:42 <sorear> 09:36 < sorear> I like it
09:40:58 <Saizan> sorear: repasted for glguy :)
09:41:01 <hpaste>  complaisabt pasted "hylomorphism intermediate datatype" at http://kakapo.scannedinavian.com:8000/10
09:41:02 <glguy> heh
09:41:06 <Saizan> ah, you too
09:41:14 <complaisant> brb
09:42:11 <glguy> Saizan: my only concern is that we are going ot want additional options
09:42:22 <glguy> and it's going to be more difficult to choose a combination of them
09:42:38 <sorear> hm
09:42:55 <Saizan> mmmh
09:43:07 <sorear> chasing links ["linenumbers:yes" "coloring:haskell"] vs setting options at once
09:43:38 <complaisant> http://kakapo.scannedinavian.com:8000/10
09:43:39 * sorear likes the form approach better all of a sudden
09:43:40 <lambdabot> Title: hylomorphism intermediate datatype - hpaste
09:44:02 <glguy> both were originally Saizan's ideas :)
09:44:16 <glguy>  \ implementations
09:44:19 <Saizan> mmh we should at least have only "?lines=true" instead of "?lines=true&submit=Format"
09:44:35 <glguy> Saizan: the submit=Format is optional though
09:44:45 <glguy> if it wasn't there it would still work
09:45:09 <Saizan> yes, we have only to change how the form works
09:45:16 <glguy> but that can be scrubbed off
09:45:51 <allbery_b> shouldn't it be called "Apply"?  (or maybe "($)" :> )
09:46:32 <Saizan> Format? copyed from lisppaste :)
09:46:47 <Failure02> can you make ghci throw an error or something rather than just self terminate when it runs out of memory?
09:46:58 <sorear> no
09:47:04 <sorear> Failure02: you on linux?
09:47:13 <Failure02> windows xp
09:47:28 <allbery_b> OS-level "out of memory" often leaves things in an inconsistent state
09:47:39 <allbery_b> unrecoverably
09:48:01 <sorear> Failure02: futz with the +RTS -Hfoo options
09:48:46 <huschi> is anywhere in the standard libraries an instance of monad for either defined?
09:48:50 <sorear> yes
09:48:52 <glguy> the ?lines=true doesn't include submit=Format anymore
09:48:56 <sorear> Control.Monad.Error
09:49:08 <sorear> Control.Monad.Instances
09:49:13 <allbery_b> Either itself isn't a monad; (Either a) is (MonadError)
09:49:25 <sorear> ^^^ both of these modules define instance Monad (Either String)
09:49:27 <huschi> allbery_b: thx. that was what i meant.
09:49:55 <sorear> and either is a data value not a type :)
09:50:08 <glguy> ?instances String
09:50:10 <lambdabot> Couldn't find class `String'. Try @instances-importing
09:50:16 <glguy> ?instances [Char]
09:50:17 <lambdabot> Couldn't find class `[Char]'. Try @instances-importing
09:50:20 <glguy> oh
09:50:23 <glguy> ?instances MonadError
09:50:25 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
09:50:28 <sorear> glguy: String isn't a cless yet.
09:50:34 <glguy> sorear :-p
09:50:37 <sorear> ?instances Monad
09:50:38 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:50:55 <glguy> instance MonadError e => Monad (Either e)
09:51:05 <sorear> no
09:51:15 <sorear> MonadError has two params
09:51:26 <sorear> instance Error e => Monad (Either e)
09:51:29 <sorear> instance Error e => MonadError e (Either e)
09:51:31 <Failure02> sorear: i didn't find any +RTS option
09:51:40 <glguy> ?src Error
09:51:41 <lambdabot> class Error a where
09:51:41 <lambdabot>     noMsg  :: a
09:51:41 <lambdabot>     strMsg :: String -> a
09:51:43 <sorear> Failure02: it's not documented well
09:51:50 <glguy> ?src MonadError
09:51:50 <lambdabot> class (Monad m) => MonadError e m | m -> e where
09:51:51 <lambdabot>     throwError :: e -> m a
09:51:51 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
09:51:52 <sorear> Failure02: don't look for it, just try it
09:51:52 <Failure02> but it should be possible to do something, at least in the code
09:51:58 <sorear> Failure02: ghci +RTS --help
09:52:01 <Failure02> i tried it and it didn't exist
09:52:08 <sorear> REALLY?
09:52:11 <Failure02> :set +RTS
09:52:21 <allbery_b> you can't do it inside ghci
09:52:22 <sorear> no, it only works on the command line
09:52:26 <Failure02> okay
09:52:47 <sorear> ghci, like everything compiled with ghc, has +RTS options
09:54:43 <sorear> aw, it's uncatchable
09:55:20 <sorear> stefan@stefans:~$ ghci +RTS -M16M -RTS -e 'Control.Exception.try (Control.Exception.evaluate $ foldr (+) 0 [1..])'
09:55:23 <sorear> Heap exhausted;
09:55:23 <sorear> no
09:55:25 <sorear> Current maximum heap size is 15998976 bytes (15 Mb);
09:55:26 <sorear> Left ...
09:55:28 <sorear> use `+RTS -M<size>' to increase it.
09:55:57 <allbery_b> no, there's something somewhere in the ghc docs saying HeapException isn't currently thrown
09:56:38 <Failure02> that makes haskell programs unrelieable, doesn't it?
09:56:43 <Failure02> since you can't control the memory
09:56:56 <allbery_b> no more so than e.g. C programs when malloc() returns NULL
09:57:17 <Failure02> you can make it catch that
09:57:27 <allbery_b> perhaps more reliable since when malloc() fails you've likely got unfixable corruption somewhere, because there's no way to clean things up if it happens in a library function
09:57:36 <sorear> no real program does...
09:57:51 <sorear> cf. GNU's religous use of xmalloc
09:58:27 <sorear> actually on Linux malloc (essentially) never returns NULL
09:58:28 <rahikkala> On Linux it won't necessarily even be malloc that fails if you run out of memory
09:58:52 <sorear> you get a SIGKILL instead when you exhaust memory!
09:58:52 <allbery_b> yeh, but mmap() doesn't buy you anything on the recoverability front
09:59:07 <augustss> It's difficult to know what to do in Haskell if HeapException is thrown.
09:59:49 <augustss> Since there is no subset of Haskell that is guaranteed not to allocate.
09:59:54 <Failure02> i remember i read some trick in c++ about first allocating 10 MB extra when starting the program, then overloading the new operator, and when there's no new memory, you release the 5 mb you had, and you can try to fix the problem
10:00:01 <allbery_b> root problem being that system library functions have a tendency to immediatey return an error if memory allocation fails, leaving internal structures possibly in an inconsistent state.
10:00:44 <sorear> Failure02: won't that corrupt the arena? freeing a 10mb block as if it were a 5mb block?
10:00:52 <Failure02> typo. i meant 10
10:01:24 <augustss> And then you use those 10M to shut down the program orderly?
10:01:38 <Failure02> i suppose so
10:01:48 <glguy> You can instruct Linux to return NULL when you run out of memory
10:01:52 <glguy> instead of overallocating
10:01:56 <sorear> glguy: do you?
10:02:02 <glguy> use linux?
10:02:02 <glguy> no
10:02:03 <sorear> glguy: I know you *can*
10:02:36 <augustss> writing software that can reliably cope with running out of memory at any point is a major pain
10:02:55 <rahikkala> malloc(3) actually describes the default behaviour on Linux as "a really bad bug"
10:02:57 <allbery_b> ==augustss see my previous comment
10:02:58 <sorear> anyone with this kind of reliability demands shouldn't use GHC
10:02:59 <augustss> but sometimes necessary.  but i don't want to do it again :)
10:03:11 <sorear> it's 70klines of unaudited code
10:03:34 <sorear> by comparison, OOM issues are trivial
10:03:44 <allbery_b> and anyone with that kind of requirement needs to use a trusted (in the rleiability, not security, sense) OS, which doesn't include most unixlikes
10:04:09 <Nafai> allbery_b: What OS do you suggest?
10:04:28 * allbery_b knows such things exist but could not point to one
10:04:40 <sorear> I recommend ...
10:04:47 <sorear> changing your requirements.
10:04:59 <allbery_b> well, they used to.  lots of things that used to use them (e.g. medical equipment) seem to be switching to windows on the theory that cheap trumps reliable :/
10:05:05 <allbery_b> (or linux,same argument)
10:05:24 <Failure02> wasn't haskell used for some heart machine thingy?
10:05:39 <Failure02> maybe that was some other language
10:06:04 <Failure02> but it was something functional, and whoever wrote the article about it said it was super reliable
10:06:06 <glguy> cost of expensive OS > cost of cheap OS + lawsuit rate * lawsuit payout
10:06:20 <allbery_b> might have been nhc, which targets embedded devices
10:06:53 <sjanssen> Failure02: I think you're referring to a humor article on haskell.org
10:07:02 <Failure02> hehe
10:07:04 <Failure02> possible
10:07:20 <sjanssen> http://www.haskell.org/haskellwiki/Humor/Haskell_saves_lives
10:07:22 <lambdabot> Title: Humor/Haskell saves lives - HaskellWiki
10:08:46 <Failure02> that was probably it
10:08:49 <Failure02> now i look stupid :)
10:08:54 <sjanssen> :)
10:13:23 <augustss> oh, the Haskell April Fool's jokes has fooled many
10:14:10 <kolmodin> cd
10:14:13 <kolmodin> heh, sorry
10:20:55 <sorear> @seen stepcut
10:20:56 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 11h 51m 12s ago.
10:32:46 <sorear> @users
10:32:46 <lambdabot> Maximum users seen in #haskell: 311, currently: 291 (93.6%), active: 39 (13.4%)
10:34:20 <augustss> @bot
10:34:21 <lambdabot> :)
10:34:40 <sorear> the quiet ... it burns
10:35:57 <Lemmih> So, how's code everybody?
10:36:19 <augustss> Bah, I've written documentation and tests.
10:36:50 <sorear> Applying patch 1 of 279... darcs: parser error
10:37:21 <augustss> how reassuring
10:37:21 * sorear thought darcs would be a good way to get the irc logs ...
10:38:07 <augustss> I wish darcs were more reliable.
10:38:46 * sorear is now trying wget -r
10:40:00 <sorear> stepcut has donated a patch for 6-months-ago-lambdabot supporting XMPP
10:40:16 <sorear> it looks like a <2 hr integration
10:40:25 <sorear> I just want to understand it first :)
10:41:51 <sorear> the code breaks a lot of Haskell idioms
10:41:57 <sorear> XmppT :: * -> *
10:42:15 <sorear> had me confused quite well...
10:42:20 <sorear> (for instance)
10:42:45 <sorear> dons is down to #4 on #haskell, after lambdabot, sorear, and glguy (in that order)
10:42:56 <XRayNuke> sorear: thanks a ton, that code from lambdabot does exactly what I need
10:43:52 <sorear> your assurance of reliability - you test it every time you say > 2 + 2
10:44:08 <Saizan> sorear: so you have to apply it like XmppT (IO ()) ?
10:44:13 <augustss> > 2 + 2
10:44:14 <lambdabot>  4
10:44:24 <sorear> Saizan: no!
10:44:39 <sorear> oh wait, I suppose that would work
10:44:46 <sorear> XmppT () mostly
10:45:03 <Saizan> ah
10:45:08 <sorear> see - I'm still confused! :)
10:45:16 <Saizan> :)
10:46:56 <socrates2> http://www.golubovsky.org/software/hugs-patch/hugs_unicode_test.html
10:46:58 <lambdabot> Title: Experimental Support of Unicode in Hugs, http://tinyurl.com/2dgl4o
10:47:12 <socrates2> this is a linux version
10:47:18 <socrates2> i dont want a linux version.
10:47:24 <socrates2> i am on windows.
10:49:19 <sorear> @tell stepcut Your website has multiple strongly connected components :(
10:49:20 <lambdabot> Consider it noted.
10:51:32 <sorear> fun statistics project: count the SCCs of the entire Web.
10:51:55 <trurl_> I'm trying to build hmp3.  './Setup.hs configure' says "Setup.hs: cannot satisfy dependency binary-any" - what does that mean?  './Setup.hs build' then fails because it can't read .setup-config.
10:52:23 <sorear> trurl_: that means you need to install 'any' version of 'binary'
10:52:41 <sorear> trurl_: it couldn't satisfy a dependency on any version of binary
10:52:53 <trurl_> and binary is a library?
10:52:56 <sorear> yes
10:53:08 <trurl_> ok, thanks
10:53:11 <sorear> @where binary
10:53:12 <lambdabot> http://darcs.haskell.org/binary
10:53:41 <sorear> binary was a chief hackathon victim, be prepared to unpull changes until you find a version compatible with hmp3 :(
10:54:13 <GoAwayStupidAI> Hello, I'm having troubles with pokeElemOff. Anyone care to help?
10:54:22 <sorear> sure
10:54:24 <trurl_> sorear: I'll try it
10:54:39 <sorear> why are you using pokeElemOff? that's a FFI function IIRC ...
10:54:46 <GoAwayStupidAI> yes
10:54:52 <sorear> ok
10:54:57 <GoAwayStupidAI> this is to write to a float array passed in from C
10:54:58 <sorear> what's the problem
10:55:03 <sorear> good use
10:55:39 <sorear> type errors? crashes?
10:55:49 <GoAwayStupidAI> I have a audio IOProc implemented in Haskell. This essentially gets a pointer to a float array
10:56:20 <sorear> GoAwayStupidAI: ok, ....
10:56:24 <GoAwayStupidAI> regardless of what I try to write to the array the haskell function seams to exit early
10:56:27 <qwr> is it possible to make some thread wait simultaneously for some IO and some events from other threads - whatever comes first?
10:56:38 <GoAwayStupidAI> without reporting an error that "try" can catch
10:56:44 <sorear> qwr: run the IO in a forked thread
10:57:10 <sorear> GoAwayStupidAI: does anything happen if you putStrLn in the haskell action?
10:57:12 <GoAwayStupidAI> is that not done automatically by the stub C code generated for the callback?
10:57:27 <GoAwayStupidAI> yes. Anything I try to print, prints correctly
10:57:33 <GoAwayStupidAI> up until I call pokeElemOff
10:57:39 <GoAwayStupidAI> then nothing past that executes
10:57:45 <sorear> if you print, poke, print, do 2 or 1 things print?
10:57:57 <sorear> @. docs index pokeElemOff
10:57:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
10:58:08 <qwr> sorear: and send exception to the forked thread with throwTo?
10:58:14 <GoAwayStupidAI> print, poke, print - only one thing prints
10:58:17 <GoAwayStupidAI> the first one
10:58:25 <trurl_> sorear: hmp3 compiled successfully with the current binary version
10:58:27 <sorear> qwr: yes
10:58:31 <sorear> trurl_: great!
10:58:39 <sorear> GoAwayStupidAI: ok
10:58:49 <sorear> GoAwayStupidAI: remember pokeElemOff can't check bounds
10:59:17 <sorear> GoAwayStupidAI: it also uses an offset in elements not bytes
10:59:20 <GoAwayStupidAI> sure. I've inspected the input arguments and the ptr address to which pokeElemOff is writing to and all seams correct
10:59:27 * sorear isn't a FFI exper
10:59:28 * sorear isn't a FFI expert
10:59:32 <GoAwayStupidAI> I've tried hardcoding the offset to 0
10:59:36 <GoAwayStupidAI> and still no luck
10:59:41 <sorear> what happens when you use poke
10:59:41 <sorear> ?
10:59:52 <GoAwayStupidAI> this is a Mac OS X project, and I can upload it if anybody wants to take a look
11:00:00 <GoAwayStupidAI> poke - same thing
11:00:12 <sorear> is the type on the foreign export correct ?
11:00:27 <sorear> what's the C type, haskell type?
11:00:37 <GoAwayStupidAI> haskell: Ptr AudioStreamDescription.T ->
11:00:38 <GoAwayStupidAI> 								Ptr AudioBufferList.T ->
11:00:38 <GoAwayStupidAI> 								StablePtr State ->
11:00:38 <GoAwayStupidAI> 								IO (StablePtr State)
11:00:49 <GoAwayStupidAI> C : extern HsStablePtr process_frames (AudioStreamBasicDescription* stream_description,
11:00:53 <GoAwayStupidAI> 								   AudioBufferList* out_data,
11:00:55 <GoAwayStupidAI> 								   HsStablePtr in_state);
11:01:09 <allbery_b> !paste
11:01:09 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
11:01:17 <GoAwayStupidAI> I've printed out what the Haskell AudioStreamDescription.T deserializes from the pointers. And it's correct
11:01:17 <sorear> @paste works too now
11:01:18 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
11:01:26 <GoAwayStupidAI> ahhh
11:01:31 <GoAwayStupidAI> k. new to IRC, and Haskell
11:01:35 <sorear> what was it?
11:01:45 <sorear> wrt ahhh
11:02:15 <Lemmih> GoAwayStupidAI: Tabs are evil, btw. (:
11:02:19 <sorear> what do you get when you print the pointer?
11:02:20 <socrates2> with win hugs how do you find the present working directory
11:02:21 <hpaste>  GoAwayStupidAi pasted "Haskell and C type of export" at http://kakapo.scannedinavian.com:8000/11
11:02:21 <socrates2> ?
11:02:25 <sorear> a reasonable address?
11:02:27 <GoAwayStupidAI> http://kakapo.scannedinavian.com:8000/11
11:02:28 <lambdabot> Title: Haskell and C type of export - hpaste
11:02:43 <sorear> GoAwayStupidAI: you don't need to paste the url
11:02:44 <GoAwayStupidAI> whoa. fanciness
11:02:49 <sorear> GoAwayStupidAI: look at hpaste
11:03:02 <GoAwayStupidAI> the address is not unreasonable
11:03:12 <GoAwayStupidAI> sorear: so I see. Neat!
11:03:31 <GoAwayStupidAI> by unreasonable I mean: Correct
11:03:40 <sorear> so you have a reasonable address, and when you poke it, the proc dies?
11:03:49 <sorear> yow.
11:03:50 <GoAwayStupidAI> not the whole proc
11:03:59 <sorear> proc(edure) sorry
11:04:05 <GoAwayStupidAI> ah, yes
11:04:07 <sorear> not proc(ess)
11:04:45 * sorear is also rather unfamiliar with stable ptrs :(
11:04:51 <GoAwayStupidAI> this function is called from a separate thread than main. Are there any caveats in that?
11:05:06 <sorear> shouldn't be
11:05:08 <GoAwayStupidAI> I have removed the stable pointer, and have had the same behavior
11:05:59 * dmhouse yawns.
11:06:05 <dmhouse> Evening everyone.
11:06:20 <sorear> ok, last ditch idea: -keep-hc and check for spurious indirection.
11:06:35 <sorear> fell free to scream in terror when you see the generated code.
11:06:55 <GoAwayStupidAI> ... done the screaming part
11:07:07 <GoAwayStupidAI> uh.. how do I check for spurious indirection?
11:08:43 <sorear> ok, *last* solution: forall foo. foo experts are more likely to be found on haskell-cafe@haskell.org than #haskell.
11:09:50 <augustss> GoAwayStupidAI: can you try it without threads?
11:11:19 <GoAwayStupidAI> hm. It'll take a bit, since the threading is imposed by the system, but yes
11:12:17 <SamB> sorear: it wouldn't be so bad if GHC would use indentation and maybe try to do some basic loop detection (i.e. replace some gotos with for or while loops)
11:12:28 <benja_> did sigfpe sometimes hang out here?
11:12:41 <dmhouse> benja_: occasionally, yeah.
11:12:59 <benja_> ok, thanks :)
11:13:24 <dmhouse> benja_: he goes by the nick of dpiponi, here, though.
11:13:47 * benja_ just read sigfpe's post on comonads
11:14:01 <benja_> I don't think comonads would be right for frp
11:14:22 <benja_> (not a theoretical question since I'm trying to figure out how to do an implementation of frp :))
11:14:54 <dmhouse> benja_: isn't the normal approach to use arrows?
11:15:11 <benja_> it is
11:15:38 <sorear> comonads are arrows
11:15:57 <SamB> so, what would class Comonad cm look like?
11:16:08 <SamB> or do I mean CoMonad?
11:16:09 <benja_> but I don't like the way it doesn't allow for nested expressions
11:16:10 <sorear> cojoin :: m a -> m (m a)
11:16:16 <benja_> SamB: http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
11:16:38 <dmhouse> ?oldwiki Comonads
11:16:39 <lambdabot> http://www.haskell.org/hawiki/Comonads
11:16:51 <SamB> so are arrows both monads and comonads?
11:16:58 <dmhouse> SamB: http://www.haskell.org/hawiki/CoMonad is good
11:17:00 <lambdabot> Title: CoMonad - The Haskell Wiki
11:17:00 <sorear> backways
11:17:02 <sorear> backwards
11:17:04 <SamB> oh
11:17:06 <allbery_b> no, arrows are more general than either.
11:17:11 <glguy> some arrows are monads
11:17:12 <sorear> Comonads and monads are both arrows.
11:17:16 <SamB> so both monads and comonads are *arrows*
11:17:22 <SamB> okay
11:17:23 <allbery_b> yeh
11:17:25 <sorear> numbers aren't both integers and rationals
11:17:33 <SamB> true
11:17:41 <SamB> ... but integers are
11:17:42 <glguy> all monads are arrows
11:17:43 <dmhouse> Comonads \subset Arrows; Monads \subset Arrows
11:17:58 <benja_> sigfpe's post is http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
11:18:01 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
11:18:13 <Saizan> Comonads disjoint Monads?
11:18:19 <sorear> Saizan: no
11:18:26 <SamB> Saizan: why would that be?
11:18:51 <sorear> Reader \elem {Monad \isect Comonad} , for instance.
11:19:00 <allbery_b> hm, that's an interesting though.  can something simultaneously be a monad and a comonad?
11:19:03 <Saizan> :O
11:19:12 <benja_> if using comonads for frp, you would have to look at the whole history of user inputs to look at the current value of a signal
11:19:15 <SamB> allbery_b: sorear just said "yes"
11:19:15 <benja_> allbery_b: yes
11:19:21 <SamB> he said Reader is
11:19:25 <allbery_b> yeh, saw that as finishing
11:19:31 <SamB> ah ;-)
11:19:31 <socrates2> ERROR file:.\testutf.hs - Can't find imported module "Hugs.Unicode"
11:19:31 <socrates2> Hugs>
11:19:31 <allbery_b> as I was finishing
11:19:32 <sorear> Reader has different formulations though
11:19:35 * allbery_b a bit slow
11:19:40 <socrates2> I cant find the problem?
11:19:40 <sorear> Reader comonad is (,) a
11:19:45 <sorear> Reader monad is (->) a
11:19:48 <benja_> Identity is both a monad and a comonad
11:19:58 <sorear> benja_: /me feels dumb
11:20:03 <SamB> sorear: can you formulate it so that the same tycon is both?
11:20:16 <sorear> unk.
11:20:20 <SamB> or do we need a nicer type system?
11:20:25 <SamB> or nastier, whichever
11:20:28 <sorear> always!!
11:20:46 <SamB> ... true, dat
11:21:07 <benja_> SamB: no, you can't formulate it so and a nicer type system probably wouldn't help
11:21:14 <dmhouse> Why would you want to?
11:21:28 <benja_> I agree with sigfpe that Kleisli (co)arrows are the right way to think about this:
11:21:46 <benja_> a 'reader function' has type (a -> Reader b) for some a, b
11:21:46 <SamB> yeah... I guess you'd just make it an arrow
11:21:59 <benja_> a 'coreader function' has type (Reader a -> b) for some a,b
11:22:05 <benja_> now look at what that expands to:
11:22:10 <SamB> and make it an instance of ArrowApply and the comonadic equivalent?
11:22:13 <benja_> sorry... I must backtrack
11:22:21 <SamB> ArrowApply gives you a monad right?
11:22:25 <glguy> yes
11:22:37 <benja_> reader function is (a -> Reader r b), coreader is (CoReader r a -> b)
11:22:44 <SamB> so what gives you a comonad?
11:22:44 <benja_> now look at what that expands to:
11:22:53 <benja_> reader is (a -> r -> b)
11:22:59 <benja_> coreader is ((r,a) -> b)
11:23:05 <benja_> see the equivalence of the types?
11:23:09 <dmhouse> Ooh, I spot an isomorphism!
11:23:17 <sorear> benja_: unify a and b!
11:23:34 <benja_> sorear: hm?
11:23:44 <sorear> a -> r -> b is uninhabited
11:23:51 <sorear> (ignoring _|_)
11:23:59 <benja_> sorear: no, they are for fixed a and b
11:24:03 <sorear> @djinn a -> r -> b
11:24:04 <lambdabot> -- f cannot be realized.
11:24:11 <glguy> sorear: that's why it's a monad
11:24:15 <glguy> there is more info
11:24:19 <glguy> contained within
11:24:24 <dmhouse> sorear: it's not universally quantified.
11:24:25 <benja_> like, take putChar :: Char -> IO ()
11:24:40 <benja_> that's a Kleisli arrow in the IO monad, with a=Char and b=()
11:24:53 <dmhouse> ?djinn Int -> () -> String
11:24:54 <lambdabot> -- f cannot be realized.
11:24:57 <SamB> this is why I told that Yhc guy that having typeOf give you a source-level type was impossible
11:24:59 <benja_> I guess I didn't say what I meant well...
11:25:00 <dmhouse> That's clearly inhabited.
11:25:03 <SamB> or something like that...
11:25:31 <SamB> I mean, it would have free type variables, which makes no sense!
11:25:46 <benja_> a "monadic function" -- a Kleisli arrow -- in a monad 'm' has type (a -> m b) for some a and b
11:26:09 <benja_> example: putChar :: Char -> IO () has type (a -> m b) for a=Char, b=(), m=IO
11:26:50 <dmhouse> So if KIO is the IO arrow, then putChar :: KIO Char ()
11:27:17 <glguy> ?type Kleisli putChar
11:27:19 <lambdabot> Kleisli IO Char ()
11:27:34 <dmhouse> newtype KIO = KIO (a -> IO b); instance Arrow KIO where ...
11:27:45 <socrates2> HELP ME
11:27:57 <dmhouse> socrates2: what's up?
11:28:20 <socrates2> http://www.golubovsky.org/software/hugs-patch/hugs_unicode_test.html i have win husgs
11:28:21 <lambdabot> Title: Experimental Support of Unicode in Hugs, http://tinyurl.com/2dgl4o
11:28:34 <socrates2> and am stuck trying to input unicode chars
11:28:39 <benja_> now a "comonadic function" -- a cokleisli arrow -- is a function (c a -> b) for some comonad c and some given types a and b
11:28:54 <benja_> i.e. (exists a b. c a -> b)
11:29:09 <socrates2> how do imports work?
11:31:24 <benja_> you write 'import ModuleName' at the top of your module and then everything ModuleName exports is in your local scope
11:31:57 <benja_> or: you write 'import ModuleName (fn1, fn2, fn3)' at the top of your module and then fn1, fn2, fn3 are in your local scope
11:34:03 <socrates2> so in the file that i pasted
11:34:06 <socrates2> what to do?
11:34:16 <socrates2> in the line
11:34:17 <socrates2> link
11:34:28 <socrates2> where to stor the import
11:35:05 <paolino> "corte di cassazione"  (maximum judgement entity) sentenced in Italy: "exchanging  copyrighted materials, with no trading intention is not punished by  italian law".
11:35:06 <paolino> Ma vieni !!!!
11:35:33 <benja_> sorry, what did you paste? the unicode hugs patch or...?
11:35:48 <socrates2> thats unicode link
11:36:22 <socrates2> i pasted that unicode link
11:36:53 <tuukkah> socrates2, a snapshot from 2003 doesn't seem current
11:37:12 <socrates2> i need unicode format
11:37:24 <socrates2> i want to parse greeek and russsain words
11:37:35 <ohmega> it also looks like Hugs need special support for unicode compiled in to support it
11:37:41 <socrates2> this language seems ideal.
11:37:45 <ohmega> try Ghc instead?
11:37:57 <socrates2> a friend tried it he said same problem
11:38:10 <ohmega> GHC 6.6 has some unicode support.
11:38:19 <socrates2> greek/russian?
11:38:50 <ohmega> hm, wait parsing will probably be an issue though since IO-operations in UTF-8 aren't handled
11:38:51 <benja_> http://cvs.haskell.org/Hugs/pages/latest.htm says Hugs supports Unicode as specified in the Haskell 98 report since the Mar 2005 release
11:38:53 <lambdabot> Title: Latest News
11:39:54 <koala_man> socrates2: I tried ghc 6.4.2. and I have the Mar 2005 release of hugs that worked
11:40:17 <socrates2> oh god it you :)
11:40:26 <socrates2> hello there
11:40:48 <socrates2> yeah trying ghc 6.6 now
11:41:09 <ohmega> import Hugs.Unicode works fine here with hugs
11:41:43 <socrates2> ohmega: where did you store the Unicode file ?
11:42:33 <ohmega> socrates2: outputting greek letters and math symbols also works fine :)
11:42:48 <ohmega> socrates2: what unicode file?
11:43:40 <ohmega> i've not done anything fancier than "apt-get hugs" that i can recall
11:43:44 <socrates2> ohmega: ok maybe i need to version of hugs thats 14 mb
11:43:45 <ohmega> +install ;)
11:48:22 <sorear> @seen stepcut
11:48:22 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 13h 18m 38s ago.
11:49:40 <qwr> hmm, i have to play htons like in C when building PortNumber for SockAddrInet?
11:50:03 <glguy> PortNumber (fromIntegral x)
11:50:29 <SamB> @quote trappes
11:50:29 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
11:51:18 <qwr> bindSocket s (SockAddrInet (PortNum (fromIntegral port)) addr)
11:51:25 <qwr> port is Int 3372
11:51:35 <qwr> and it will listen 11277
11:51:36 <augustss> @quote abysmal
11:51:37 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
11:51:46 <sorear> there is no total function with that type. proof: ($[])
11:56:27 <glguy> h <- connectTo server (PortNumber (fromIntegral port))
11:56:49 <glguy> PortNum /= PortNumber
11:57:10 <qwr> glguy: i just got it work with PortNumber (toEnum port) by reading some http library source ;)
11:57:12 <qwr> but tnx
11:57:46 <socrates2> Geeeez
11:57:47 <qwr> hmm it is even just SockAddrInet (toEnum port) addr
11:58:07 <socrates2> now ghc is putting my foriegn chars as question amrks
12:01:09 <kolmodin> ?tell joelr1 I just pushed deriving binary instances with syb to the main repo. feel free to try it out
12:01:09 <lambdabot> Consider it noted.
12:01:22 <sorear> how can I have multiple versions of HaXml usefully installed at once?
12:01:58 <sorear> If I just install the dev version I imagine I'll have difficulty getting HApps to confiugure with the stable version.
12:02:04 <sorear> (or will it all Just Work?)
12:02:14 <socrates2> koala_man ?
12:02:30 <koala_man> socrates2:
12:02:32 <Lemmih> sorear: You could tell HAppS to use the stable version.
12:02:49 <sorear> is that as easy as configure?  do I need to edit the .cabal?
12:03:16 <Lemmih> You need to edit the cabal file.
12:04:26 <socrates2> koala_man : :?
12:04:29 <socrates2> :)
12:12:01 <socrates2> the cmd window just displays question marks
12:19:10 <glguy> and GLGUY unlocks the ENCORE song for the 7th bracket on EXPERT in GUITAR HERO 2
12:19:11 <glguy> woot
12:19:33 <glguy> It YYZ by Rush
12:19:39 <glguy> its*
12:24:25 <glguy> and we are on to the final bracket :)
12:36:50 <glguy> and.. I've reached my new limit
12:41:09 * paolino fears glguy limit
12:42:22 <fasta> GHC should steal the black hole analyzer from Hugs.
12:42:31 <Lemmih> paolino: ping.
12:42:31 <fasta> It's better.
12:42:45 <paolino> pong
12:42:57 <tuukkah> uhm, so i need a profiling version of gtk2hs to profile an app that uses gtk2hs...
12:43:10 <Lemmih> paolino: Your 'See LICENSE' link is broken http://catenova.org/~phas/doc/hid3/
12:43:30 <Igloo> tuukkah: If you want to compile the app with profiling then the libs need to be profiled too
12:44:29 <moconnor> I have a function of type: foo :: Show a => x -> IO a  (where x doesn't matter).  I want to have another function, print_foo :: IO a -> IO (), which prints "a" to the screen.  However, what I really want is if "a" is String then I want to use putStrLn and if "a" is anything else just use print.  How do I do that?
12:44:52 <allbery_b> you need a typeclass
12:45:59 <augustss> indeed
12:46:00 <moconnor> allbery_b: Ahh, of course.  So I have a generic implementation that does "print a" and then create an instance for String that does the special thing.
12:46:15 <paolino> !paste
12:46:16 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
12:46:20 <moconnor> allbery_b: Is that how that'd work?
12:46:28 <allbery_b> where the generic instantiation requires Show a, and you probably need -fallow-overlapping-instances
12:46:30 <paolino> Lemmih: I'm not phas
12:46:46 <allbery_b> (because String is also a member of Show)
12:46:52 <moconnor> allbery_b: Thank you, I think you've told me enough so I can start playing around.
12:47:47 * allbery_b would actually create a MyShow class, and then myPrint :: MyShow a => a -> IO (); myPrint a = putStrLn (myShow a)
12:47:53 <augustss> moconnor: but try avoiding -fallow-overlapping-instances if you can.  it's not nice
12:48:01 <allbery_b> that way I could reuse it for other things
12:48:14 <allbery_b> (like hPutStrLn)
12:48:22 <Lemmih> paolino: Oh right, sorry.
12:48:34 <paolino> np
12:49:17 <moconnor> allbery_b: Thanks again!
12:50:26 <SamB> moconnor: you could maybe use Data.Generics for that
12:50:49 <SamB> ... if you can get it to pass in the Show instance...
12:52:33 <socrates2> my windows command line does not take foriegn characters, but i need them in my program
12:52:41 <socrates2> this is very annoying.
12:53:21 <SamB> what windows be that?
12:54:54 <socrates2> ME i think
12:55:41 <SamB> ah :-(
12:56:04 <SamB> you need NT to even hope for Unicode support
12:56:28 <socrates2> FFS this is shit
12:57:05 <SamB> ME is the windows I don't think I have ever seen
12:57:22 <SamB> I certainly have no desire to do so
12:57:38 <SamB> it is the 9x that didn't quite rate a 9
12:57:54 <PaulAJ> Is anything happening with wxHaskell?
12:58:00 <allbery_b> ME is more or less 98 with a prototype of the Win2k device driver implementation grafted on, no?  No Unicode support
12:58:12 <PaulAJ> I recall an announcement that people were getting together to revive it, but nothing since.
12:58:14 <allbery_b> PaulAJ: http://darcs.haskell.org/wxhaskell seems usable
12:58:17 <lambdabot> Title: Index of /wxhaskell
12:58:29 <tuukkah> there has been talk last year that gtk2hs wouldn't support building a profiling version
12:58:30 <allbery_b> the sourceforge project is dead because they moved development to darcs
12:58:46 <kowey> actually... we have the keys to it now
12:58:48 <sorear> tell fodder
12:58:55 <PaulAJ> Ahh.  Then I think the SF project page should say so.  The last news on there is a couple of years old.
12:59:01 <kowey> i'd personally like to get rid of the pop-up
12:59:14 * allbery_b found out only by googling until he found someone's blog post
13:00:01 <glguy> windows ME was a disaster is what it was :)
13:00:14 <PaulAJ> As in "Windows ME harder!"
13:00:17 <glguy> I never had my own copy, I just had to fix lots of other peopls
13:01:09 <PaulAJ> Speaking of fixing other peoples windows installations, both my parents and my brother in law seem to have had the same breakage from IE7.
13:01:20 <glguy> breakage?
13:01:29 <PaulAJ> It seems it broke their 3rd party firewall, leaving them open to lots of malware.
13:01:38 <allbery_b> yow
13:01:40 <PaulAJ> Both needed  their computers rebuilding, though thankfully not by me.
13:01:50 <glguy> I laugh at people that need a 3rd party app to keep the malware away
13:01:58 <PaulAJ> Anyone else heard of similar stuff?
13:02:04 * glguy lawls
13:02:25 <kowey> PaulAJ: wxhaskell is moving along slower than i'd like, but we're all still working on it
13:02:34 <PaulAJ> glguy: Me too, sometimes.  But its hard to sell a router box to people with only one PC.
13:02:39 <glguy> I know what you mean though... I really need to spend a day and sit next to Joe Average-User
13:02:40 * kowey is looking at shelarchy's patch right now
13:02:43 <glguy> and see wtf they are doing
13:02:48 <glguy> that screw them up so badly
13:02:57 <PaulAJ> kowey: glad to hear it.  I'll keep an eye on it now I know where to go.
13:03:56 <glguy> PaulAJ: besides, win xp's built in firewall should put the kabosh on the risk of direct connection to a DSL or dialup connection
13:04:00 <glguy> no?
13:04:09 <glguy> just block everything?
13:04:52 <fasta> Are you saying the firewall works?
13:05:04 <PaulAJ> To be honest, I don't know.  My Windows knowledge is suffering bit rot.
13:05:04 <dmead> yes, i am.
13:05:20 <allbery_b> xp actually overdoes the firewall a bit by default, doesn't it?
13:05:30 <glguy> I think so
13:05:32 * allbery_b recalls having to unblock stuff to get DHCP to work
13:05:34 <fasta> Haha, Windows firewall is not secure
13:05:42 * sorear has an up to date Linux system with all services bound to lo
13:05:51 <SamB> allbery_b: better over than under
13:05:53 <PaulAJ> Back in the Win98 days I used to know where everything was, but then I got my own Linux box, and now I rarely have anything to do with the Windows PCs in the house.
13:05:55 * glguy hasn't ever plugged a winbox into the internet directly
13:06:12 <fasta> glguy: I did, and I had a virus 10 minutes later.
13:06:19 <allbery_b> of course, if you decide to use file serving, you have to unblock the most dangerous ports, and there's no halfway about it :/
13:06:23 <fasta> glguy: it was a good lesson
13:06:23 <sorear> a virus? really?
13:06:35 <fasta> Really, I didn't expect it.
13:06:37 * sorear has never heard of viruses infecting active worms
13:06:43 <SamB> file serving?
13:06:49 <allbery_b> also, viruses tend to come from email, not from unblocked ports
13:06:52 <glguy> allbery_b: why would you consider opening the smb port when connected to the internet
13:06:56 <dmead> samba, etc
13:07:02 <allbery_b> and, well, outhouse has always been rather trusting
13:07:03 <fasta> It was a remote leak.
13:07:12 <PaulAJ> Yeah, but you'd never run samba over an unsecured net.
13:07:17 <SamB> allbery_b: see, it should come without OE
13:07:44 <fasta> Anyway, I also saw some assembly code that could work around Windows firewall.
13:07:58 <fasta> It was 5K of it, admittedly
13:08:11 <allbery_b> glguy: you want to use file sharing between machiens on your home net.  you're not using NAT on the router, or you have some machine receiving all connections ("DMZ mode")
13:08:14 <allbery_b> pwned.
13:08:21 <SamB> gtom outside or inside?
13:08:30 <SamB> er, from
13:08:34 <allbery_b> as I said, there's no halfway
13:08:45 <glguy> allbery_b: you don't put your local network and your gateway on the same side
13:09:10 <glguy> allbery_b: at that point it is your fault, and not windows' :-p
13:09:15 <allbery_b> you can't tell windows firewall to only accept connections from the local net; if your gateway router doesn't either filter or do NAT, you're screwed
13:09:51 <allbery_b> (or couldn't last time I poked at it, without going into advanced config that would confuse most home users)
13:09:57 <glguy> allbery_b: even if you could, you shouldn't trust the addresses on the packets
13:10:36 <SamB> allbery_b: hmm, that is bad
13:10:50 <sorear> glguy: can you perform a two-way tcp connection with a spoofed address?
13:11:12 <SamB> glguy: any gateway that doesn't drop packets with bad "FROM" addresses should be tossed out the nearest window
13:11:18 <SamB> or reconfigured
13:11:21 <SamB> whichever
13:11:28 <glguy> SamB: he's already said that his gateway can't do NAT
13:11:35 <sorear> SamB: how do you propose to identify bad from addresses?
13:11:38 <glguy> SamB: We aren't talking about something with features
13:11:41 <sorear> SamB: the evil bit? :)
13:12:00 <allbery_b> hm?  I was talking about a hypothetical situation.
13:12:02 <SamB> sorear: well, if the from address isn't in your router table as being routable that way...
13:12:02 * glguy 's filewall filters on the evilbit
13:12:04 <allbery_b> dunno about the other user
13:12:18 <glguy> fire*
13:13:17 <arekm> helo, I'm trying to buld ghc 6.6 on x86_64/linux - unfortunately it fails: http://pastebin.us/12134
13:13:22 <arekm> is such problem known?
13:13:37 <SamB> I mean, if your gateway gets a packet from the internet destined for one of your computers, it should make sure that the packet is from an address it might possibly route to using the interface upon which it is recieved!
13:14:01 <sorear> arekm: we do have a standard pastebin, with channel announce features
13:14:05 <sorear> @paste
13:14:06 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
13:14:14 <sorear> (just for future reference)
13:14:20 <rici> ?seen anon4888
13:14:20 <lambdabot> I saw anon4888 leaving #haskell 1d 5h 7m 19s ago, and .
13:14:36 <glguy> OpenBSD's PF has a macro for antispoof for just such an occasion
13:14:44 <glguy> SamB:
13:14:56 <arekm> these regs are not defines if NO_REGS is defined when including includes/MachRegs.h
13:15:17 <rici> ?tell anon4888 that i think i figured out the lalr stuff if he wants to chat about it
13:15:18 <lambdabot> Consider it noted.
13:15:20 <sorear> arekm: can you get an unregisterised build working
13:15:23 <SamB> anyway I don't think the internet package my family got has multiple IPs
13:15:23 <sorear> ?
13:15:26 <glguy> sorear: we probably need a way to specify that the paste shouldn't be colored...
13:15:27 <SamB> so we are using NAT
13:15:35 <SamB> actually this computer is the router ;-)
13:15:49 <glguy> Or is the network the computer?
13:15:55 <glguy> is that computer the network?
13:16:04 <glguy> the router?
13:16:10 <SamB> what?
13:16:10 <arekm> sorear: afaik this one is unregistered, no?
13:16:16 <SamB> computer a network?
13:16:18 * glguy is making fun of Sun
13:16:31 <SamB> my computer may be capable of imagining LAN nodes, but we have some real ones too...
13:16:52 <mbishop> glguy: they do a pretty good job all on their own
13:17:14 <hpaste>   pasted "" at http://kakapo.scannedinavian.com:8000/13
13:17:15 <allbery_b> arekm: in general, you don't want to build your own ghc.  there's a linux x86_64 package on the ghc download page
13:17:41 <arekm> allbery_b: that's for a distro
13:17:52 <arekm> http://kakapo.scannedinavian.com:8000/13
13:17:53 <lambdabot> Title: - hpaste
13:18:01 <sorear> arekm: 13:14 < hpaste>   pasted "" at http://kakapo.scannedinavian.com:8000/13
13:18:07 <sorear> is that your name?
13:18:11 <sorear> :)
13:18:29 <allbery_b> alien can convert rpms etc. to tarballs
13:18:57 <arekm> sorear: eh, I better use paste-like service that doesn't require filling tons of forms ;))
13:19:10 <SamB> arekm: it is for convenience
13:19:12 <SamB> honest
13:19:26 <allbery_b> if you're using debian/ubuntu, you can apt-get one.  gentoo has one in portage (but it'll build it)
13:19:31 <chessguy> hey guys
13:19:38 <sorear> ... as opposed to paste services that require you to copy URLs ?
13:19:49 <glguy> or figure out captchas
13:19:59 <sorear> or *see* captchas
13:20:01 <allbery_b> building ghc is painful and slow (granting that some people have hot hardware that does it in 9sec :) and is best avoided in general
13:20:11 <sorear> painful ?
13:20:22 <sorear> GHC HEAD is 'configure && make'
13:20:34 <glguy> zomg, you have . in your $PATH?
13:20:37 <glguy> ;)
13:20:43 <allbery_b> mostly because it's so slow
13:20:45 <sorear> glguy: no.
13:20:54 <SamB> sorear: slow *is* painful
13:20:59 <sorear> glguy: so that's why building always fails!
13:20:59 * allbery_b has built from source, it brings machines to knees for hours :/
13:21:09 <sorear> 90mins here.
13:21:11 * glguy recommends: man nice
13:21:27 <arekm> sorear: that configure && make message was for me?
13:21:33 <allbery_b> no, for me
13:21:36 <sorear> and thanks to the glory of the Linux Scheduler, I can leave an un-niced build running at 99%CPU and not notice
13:21:52 <SamB> sorear: you obviously have RAM to burn
13:22:05 <sorear> 384 is nothign these days.
13:22:15 <SamB> I have 256
13:22:20 <dmead> un noticed to me means playing quake
13:22:23 <dmead> and compiling
13:22:31 <SamB> I assume that these figures are in megabytes and not in terrabytes?
13:22:36 <sorear> yes :)
13:22:37 <dmead> lol
13:22:45 * allbery_b has a 1GB macmini (which means about 512M on other platforms :) and a 512M fbsd box
13:22:53 <dmead> what, are you using?
13:22:54 * glguy is rolling on 22" rims
13:22:58 <dmead> some cli irc client?
13:23:00 <glguy> with his gig of ram
13:23:05 <glguy> :-p
13:23:07 <sorear> dmead: me?
13:23:10 <dmead> yea
13:23:14 <allbery_b> ...he respective guis chew most of ram before anything else
13:23:24 <sorear> irssi, links, emacs-nox.
13:23:30 <sorear> I use X 5mins a week.
13:23:37 <dmead> ahh
13:23:41 <dmead> well that explains it =P
13:23:41 <ElPenguin> between all the services running and the ghastly mac gui you have about 4mb RAM left to use for apps
13:23:51 <glguy> sorear's computing hardware requirements are what I call "low"
13:23:56 <SamB> hmm. I still wish we could lower the RAM usage of X stuff
13:24:13 <SamB> I need to learn irssi
13:24:17 <SamB> sometime
13:24:19 <ElPenguin> irssi is easy
13:24:20 <glguy> "learn" irssi?
13:24:21 <sorear> ElPenguin: wow. that's almost enough memory to run an entire second OS.
13:24:23 <dmead> whats irssi?
13:24:24 <SamB> and get my terminal stuff working properly...
13:24:37 <ElPenguin> sorear: or half of vista's aero interface ;)
13:24:39 <glguy> irssi is the preferred irc client of discriminating hackers
13:24:43 <ElPenguin> dmead: cli irc client
13:24:49 <dmead> ahhh
13:24:52 <dmead> i was looking for one
13:24:54 <SamB> does emacs-nox have mouse support yet?
13:24:57 <pejo> I hate when it turns out I'm not a hacker just because I chose an application. =(
13:24:59 <dmead> i've got a kde addon called yakuke
13:25:01 <SamB> also, I think I'd want larger terminals
13:25:04 <dmead> which i used to run naim
13:25:04 <glguy> pejo: it's the worst, sorry
13:25:07 <ElPenguin>  /server freenode; /join #haskell; /nick <blah> what's so hard?
13:25:10 <SamB> pejo: huh?
13:25:17 <sorear> I used to use ircii.
13:25:23 <sorear> irssi is better.
13:25:27 <ElPenguin> irssi rocks
13:25:28 <pejo> SamB, <glguy> irssi is the preferred irc client of discriminating hackers
13:25:31 <ElPenguin> i refuse to use anything else
13:25:41 <glguy> sorear: You thought you'd splurge a little and use more ram? ;)
13:25:45 <SamB> it doesn't say *all* discriminating hackers agree
13:25:51 <SamB> or even that most of them agree
13:25:58 <glguy> SamB: Oh, did I leave that out?
13:26:07 * rici prefers tools used by tolerant hackers
13:26:12 <sorear> I *like* being able to read my screen.
13:26:13 <dmead> =p
13:26:18 <rici> unfortunately, there don't seem to be any
13:26:22 <SamB> sorear: you are farsighted?
13:26:27 <sorear> no
13:26:31 <SamB> I am nearsighted
13:26:36 <SamB> oh, blurry screen
13:26:37 <SamB> right
13:26:37 <dmead> xchat takes way too much memory
13:26:38 <SamB> ;-)
13:26:40 * SamB forgot
13:26:40 <glguy> rici: Tolerance is a tool best used by the politically correct
13:26:46 <ElPenguin> xchat-gnome is even worse
13:26:48 <SamB> glguy: not always...
13:26:57 <sorear> *-gnome is even worse
13:26:59 * arekm trying unregistered build for x86_64
13:27:07 <ElPenguin> and on top of that, try being in 20 channels and being able to see which channels have new messages in
13:27:11 <ElPenguin> irssi is the only solution
13:27:12 * allbery_b actually set up x11 on th fbsd "server" because of peculiarities in its display foo.
13:27:23 * glguy can't follow more than a pair of channels
13:27:28 <sorear> what ever happened to space optimized programs?
13:27:31 <ElPenguin> glguy: it's easy on irssi :)
13:27:31 <glguy> I know that a lot of people regularly visit tons though
13:27:33 <dmead> ElPenguin: everything does that
13:27:42 <sorear> It helps if 9/10 channels are unused :)
13:27:48 <dmead> ha
13:27:59 <ElPenguin> well for one it helps to see which channels are highlighted
13:28:04 <sorear> I don't think I've seen a message in #oasis for a week.
13:28:06 * dmead does emerge irssi-svn
13:28:11 * allbery_b has 8 channels across 2 networks
13:28:13 <ElPenguin> can't keep track of more than about 10 in xchat[-gnome]
13:28:41 <hpaste>  arekm pasted "unregisterd build fails on x86_64, too" at http://kakapo.scannedinavian.com:8000/14
13:28:43 <glguy> I like my Coloquoy (don't know how to spell it though) on mac
13:28:53 <ElPenguin> sometimes i consider dumping x entirely, then i realise i actually do quite like emacs' gui
13:28:55 <arekm> so both failed
13:28:58 <ElPenguin> colloquy*
13:29:02 <glguy> yeah, that
13:29:13 <dmead> emacs without the xlibs stuff is really ugly
13:29:16 <ElPenguin> apparently it's pretty rad, but i don't own a mac
13:29:33 <SamB> sorear: do you have the mouse working in emacs?
13:29:33 <glguy> the nickserv support it pretty cool
13:29:35 <ElPenguin> and i intend to keep it that way
13:29:39 <sorear> SamB: yes
13:29:44 <SamB> sorear: ... how?
13:29:45 <sorear> SamB: I can copy and paste.
13:29:46 <kowey> macirssi has this annoying problem where if you're in utf-8 and somebody sends you a string in iso8859-1, you don't see anything
13:29:49 <sorear> SamB: gpm++
13:29:52 <SamB> ... oh, only that?
13:29:58 <SamB> not click on things like in links?
13:30:01 <ElPenguin> unicode handling in 99.9999% of programs sucks
13:30:06 <glguy> Colloquy understand why nickserv wants you to identify, and responds... so if you switch nicks , colloquy notices and identifies with that nick's password
13:30:06 <sorear> mice make computers slow :)
13:30:14 <pejo> kowey, . :P
13:30:18 <SamB> sorear: not always
13:30:27 <ElPenguin> i would love textmate for linux
13:30:34 <SamB> I think it would be nice for configure stuff
13:30:34 <ElPenguin> the nearest thing we have is scribes
13:30:35 <sorear> I think it's called "Fitt's Law"
13:30:41 <kowey> for example, i think pejo just said something, but i don't know what :-)
13:30:47 <glguy> sorear: most modern computers can handle the extra interrupts that are generated :-p
13:30:48 <dmead> l.
13:30:50 <dmead> ;/
13:30:50 * ElPenguin added the special variables support to scribes :D
13:30:52 <SamB> also for clicking on where I want my cursor to go
13:30:54 <dmead>    
13:30:55 <dmead>    
13:30:56 <dmead> there
13:31:01 <dmead> you can't see my spaces, can you?
13:31:12 <glguy> I can highlight them with my mouse...
13:31:16 <ElPenguin> noone uses mice for 90% of things. everyone knows the keyboard shortcuts
13:31:17 * allbery_b ==glguy
13:31:18 <SamB> plan9 people apparantly ran tests and found that clicking where you want the cursor is often faster than using arrows
13:31:21 <ElPenguin> so it doesn't actually matter?
13:31:24 <pejo> kowey, nothing of importance. :-)
13:31:37 * allbery_b likes his gui.  and uses both mouse and keyboard
13:31:39 <dmead> plan9?
13:31:40 <ElPenguin> SamB: plan9 are IDIOTS. i swear it's intolerable being in their chan
13:31:50 <dmead> isn't that a hippie UI thing?
13:31:53 <SamB> ElPenguin: I meant the people who made it
13:31:53 <glguy> allbery_b: I don't understand... "/me ==glguy"?
13:31:55 <dmead> like next
13:32:01 <allbery_b> "agrees with", sorry
13:32:01 <SamB> not the people in their crazy IRC channel
13:32:02 <glguy> you agreed?
13:32:03 <glguy> oh
13:32:05 <glguy> :)
13:32:14 <allbery_b> convention used on some of the other channels I'm on, and other non-IRC placs
13:32:17 <glguy> ?losers
13:32:18 <lambdabot> Maximum users seen in #haskell: 311, currently: 300 (96.5%), active: 43 (14.3%)
13:32:18 <ElPenguin> SamB: well long live emacs style shortcuts for next-word, next-para etc.
13:32:41 <SamB> ElPenguin: a lot of good that does me if I am editing code
13:32:54 <ElPenguin> why? i find it very useful
13:33:14 <ElPenguin> m-b m-f
13:33:15 <sorear> SamB: next-para is language sensitive
13:33:23 <glguy> I like having my scroll wheel on my mouse
13:33:26 <sorear> SamB: it means next-function in C for instance
13:33:30 <dmead> yar
13:33:30 <SamB> I guess the main thing is I would like to be able to middle click *where I want to paste to*
13:33:34 <glguy> ?yow
13:33:34 <lambdabot> Reality distorts my sense of television.
13:33:36 <ElPenguin> c-v for next page :)
13:33:39 <sorear> SamB: I don't
13:33:45 <SamB> hmm.
13:34:01 <sorear> SamB: with editors that do that, I invariably paste one character to the left or right of where I want it.
13:34:02 <SamB> and it would be nice for configuration buffers
13:34:11 <glguy> copy and paste means you are doing something wrong!;)
13:34:12 <ElPenguin> scribes' bookmarks are quite cool though
13:34:13 <SamB> and maybe you need it for nxml-mode?
13:34:19 <SamB> glguy: no it does not
13:34:24 <SamB> you might be moving code around
13:34:28 <sorear> Now, with gpm, I position the cursor first and my pastes are always spot-on.
13:34:30 <SamB> you know, cut and paste?
13:34:31 <dmead> irssi is taking quite a while for a cli app...
13:34:37 <glguy> SamB: cut and paste is different
13:34:43 <sorear> C-w C-y!!!
13:34:52 <glguy> 5dd
13:34:57 <sorear> P
13:34:59 <glguy> p
13:35:00 <SamB> glguy: well, the pasting part is usually the same...
13:35:02 <ElPenguin> sorear: m-w
13:35:12 <sorear> ElPenguin: 13:31 < SamB> you might be moving code around
13:35:16 <ElPenguin> oh
13:35:23 <SamB> hmm.
13:35:24 * glguy wonders how many people are taking him seriously
13:35:38 <ElPenguin> not one
13:35:41 * ElPenguin looks around
13:35:42 <SamB> well, maybe I am just a GUI infidel
13:35:56 <dan__> irssi read my xchat config?
13:35:58 <SamB> but I kinda think mouse support is neat in console apps, so sue me!
13:35:59 <dan__> wtf?
13:36:06 <ElPenguin> guis suck. their saving grace was allowing people to have more than one term open. then they invented screen...
13:36:06 <dan__> kerjgkaljergklae
13:36:07 * allbery_b doesn't take religious wars too seriously
13:36:16 <SamB> dan__: maybe it brings everyone to #haskell
13:36:23 <dmead> ha
13:36:36 <dmead> whats the command to open a new server connect?
13:36:42 <sorear> @users
13:36:43 <lambdabot> Maximum users seen in #haskell: 311, currently: 300 (96.5%), active: 43 (14.3%)
13:36:43 <ElPenguin> on irssi?
13:36:43 <allbery_b> /server
13:36:45 <sorear> /connect
13:36:49 <dmead> yes
13:36:49 <allbery_b> either one
13:36:55 <ElPenguin> allbery_b: /server kills the original connection
13:36:59 <dmead> ah
13:36:59 <dmead> k
13:37:20 <dmead-irssi> do do
13:37:51 <dmead> o0
13:37:53 <sorear> not dmead has quit? :)
13:38:04 <dmead> right
13:38:06 <dmead> hmm
13:38:24 <hpaste> more code plz, kthnxby
13:38:32 <dmead> k
13:38:37 <arekm> ehm, make[1]: *** No rule to make target `Apply.o', needed by `libHSrts.a'.  Stop.
13:38:49 <sorear> what's the difference between eric@... and glguy@... ?
13:38:59 <ElPenguin> a new account, presumably
13:39:03 <glguy> sorear: me being an idiot
13:39:05 <sorear> (besides only one can use hpaste)
13:39:08 <glguy> and hardcoding too much into the bot
13:39:08 <SamB> heh
13:39:09 <dmead> irssi is sucking my patience
13:39:27 <ElPenguin> i love seeing when people come on with root@...
13:39:37 <dmead> hehe
13:39:39 <glguy> I think that root@ is banned in #haskell
13:39:45 <ElPenguin> rightly so
13:39:48 * sorear is amazed that actually happens
13:39:51 <glguy> used to be at least
13:40:01 <ElPenguin> some people don't realise the damage that could be done
13:40:02 <SamB> nobody ever complains when I come on as Sam@
13:40:08 <allbery_b> doesn't mirc default to root@?
13:40:09 <ElPenguin> then again, some people use linspire which is root everything
13:40:10 <glguy> windows users like me do it every day ;)
13:40:11 <dan___> w t f
13:40:15 <SamB> Sam has Admin, you know!
13:40:18 <sorear> ElPenguin: ?!
13:40:20 <dmead> is there a way to like
13:40:24 <dmead> tell irssi to show like
13:40:28 <dmead> what the fuck is going on
13:40:30 <ElPenguin> sorear: linspire runs in single user mode (aka root)
13:40:38 <syntaxfree> when I interrupt some intensive computation in ghci with ctrl-c, my computer remains slow.
13:40:47 <SamB> ElPenguin: how odd!
13:40:49 <sorear> yow!!
13:40:53 <glguy> syntaxfree: killing ghci doesn't give you a better ocmputer
13:40:53 <SamB> why?
13:40:53 <dmead> check processes
13:41:07 <syntaxfree> Is there a way to force a garbage collection or something while in the ghci prompt? I'm afraid there's a lot of memory still allocated somehow.
13:41:17 <ElPenguin> SamB: ironic really that people who have the common sense to announce haskell as their preferred language would do such a stupid thing
13:41:19 <syntaxfree> ghci is not killed.
13:41:22 <SamB> syntaxfree: what, you wanted that RAM back?
13:41:36 <Cale> syntaxfree: values still in scope will continue to take memory
13:41:49 <SamB> ElPenguin: is that the only option?
13:41:55 <glguy> doesn't typing ":" reload the source, and clear the scope?
13:42:02 <Cale> :r
13:42:07 <ElPenguin> SamB: i believe so, though i personally have no intention of ever trying l/s
13:42:12 <glguy> ":" and ":r" and ":reload" all equiv though
13:42:24 <Cale> Oh, I didn't know that : was the same as :r
13:42:34 <glguy> I stumbled upon it by accident
13:42:35 <Cale> I would have figured it was ambiguous.
13:42:46 <dan___> erge
13:42:49 <glguy> I use it all the time now... path of least resistance
13:42:51 <allbery_b> that still won't release memory back to the OS though, just to ghc's own memory pool
13:43:12 <glguy> winhugs had a gc command
13:43:15 <dmead> run the garbage collector
13:43:17 <SamB> if you could force a GC of whatever generation, it would!
13:43:20 <dmead> +gc
13:43:27 <dmead> or something
13:43:39 <SamB> because it frees fromspace when it does a flip
13:44:28 <SamB> which is more than you can say for malloc
13:44:37 <SamB> (perhaps because malloc doesn't do flips)
13:44:43 <glguy> Old CSS: http://fserv.pikapphi.umr.edu:8000/    New CSS: http://kakapo.scannedinavian.com:8000/
13:44:45 <lambdabot> Title: All pastes
13:45:28 <sorear> hmm, no special warnings or anything
13:45:46 <SamB> hmm, where can I read about generational collection?
13:45:49 <sorear> (don't panic - all I did was edit the connection config)
13:45:54 <sorear> @goog GC FAQ
13:45:56 <lambdabot> http://www.iecc.com/gclist/GC-faq.html
13:45:57 <lambdabot> Title: GC FAQ -- draft
13:46:04 <SamB> It occurs to me that I know next to nothing about it...
13:46:32 <bd_> syntaxfree: I don't thing GHC's memory manager releases heap ram, if that's what you mean...
13:46:36 <pejo> SamB, there's a great book written about GC, by .. hm. Someone I can't think of the name of.
13:46:50 <bd_> syntaxfree: you can force a GC, but that won't release RAM back to the system
13:46:55 <glguy> sorear: when you paste, a cookie should save your nick for next time, no?
13:46:56 * sorear generates names...
13:47:01 <sorear> Hans Boehm?
13:47:07 <rici> SamB: http://www.cs.kent.ac.uk/people/staff/rej/gcbook/gcbook.html
13:47:07 <sorear> glguy: great idea!
13:47:09 <lambdabot> Title: Garbage Collection
13:47:12 <rici> is a great resource
13:47:19 <SamB> bd_: why wouldn't it?
13:47:25 <glguy> sorear: we talked about cookies saving some setting earlier
13:47:32 <SamB> wouldn't it be simplest to?
13:47:33 <glguy> sorear: was that it, or was there more
13:47:34 <sorear> SamB: nobody sbrks negative
13:47:42 <SamB> sorear: but! mmap!
13:47:57 <rici> changing tlbs is slow
13:47:57 <pejo> SamB, rici had the reference. Saves me some trouble. :-)
13:48:08 <bd_> I suppose with a compacting collector it could be done, but I don't know if GHC actually does so
13:48:08 <sorear> glguy: all I had thought of was cookieing stylesheets.
13:48:18 <SamB> surely the heap areas are large enough to be mmapped
13:48:20 <sorear> glguy: cookieing nicks is an even better idea
13:48:36 <SamB> even if they are malloced, the malloc on my system would use mmap to allocate them
13:48:38 <bd_> and... +RTS -c crashes ghci
13:48:53 <bd_> SamB: only if it free()s them :)
13:49:06 <SamB> copying collectors do compact
13:49:11 <SamB> they just do it a bit oddly
13:49:22 <SamB> (you didn't think GHC used mark/sweep, didja?)
13:49:43 <SamB> bd_: wouldn't it want to free them before allocating the new one?
13:50:00 <SamB> it does adjust the sizes, you know!
13:50:02 <bd_> SamB: It's faster to just reuse the ones you were going to free as the new ones
13:50:07 <bd_> right?
13:50:22 <SamB> only if you are using fixed size regions!
13:50:36 <SamB> maybe it does that for the nursery
13:52:51 <sorear> @users
13:52:52 <lambdabot> Maximum users seen in #haskell: 311, currently: 295 (94.9%), active: 42 (14.2%)
13:54:02 <bd_> hmm, well, the GHC commentary is missing information on the garbage collector, so the world may never know :)
13:54:05 <SamB> that book is not cheap, is it?
13:54:23 <bd_> in any case, it seems GHC does not do it by default; I have a ghci here using 200M and performGC changes nothing :
13:54:27 <bd_> :)*
13:54:32 <rici> SamB: no, it's not
13:54:37 <pejo> SamB, the gc book? There are links to amazon on the webpage.
13:54:47 <rici> but it bitrots a lot more slowly than most of the oreilly's on my shelf
13:55:06 <rici> if i didn't live in peru, i'd do a garage sale of useless cs books
13:55:24 <rici> there's only about 20 that were worth dead-treeing, and some of them are 30 years old
13:55:33 <pejo> Marlow has written an article on the GC in GHC, hasn't he?
13:56:03 <SamB> pejo: it looks like > $61 used...
13:56:33 <SamB> rici: who would buy useless CS books?
13:56:46 <SamB> I mean, you'd have to at least call it something else
13:57:08 <rici> well, i'd give them away, really.
13:57:21 <rici> if anyone lives in lima and wants some oreilly's, give me a shout.
13:57:49 <SamB> why do you have them anyway?
13:58:14 <sorear> that was fast
13:58:20 <rici> a casual glance at the cs section of any bookstore demonstrates that people do buy useless cs books
13:58:25 <rici> even me, sometimes.
13:58:35 <glguy> sorear: ^C kills thinks fast, even when you press it on accident
13:58:37 <rici> SamB: because throwing them away seems like a bad idea
13:58:39 <glguy> things*
13:58:45 <sorear> funny I've never seen a true-CS book in a bookstore
13:58:50 <rici> or offends my aesthetic sense
13:58:51 <sorear> just code grinding manuals
13:59:02 <rici> sorear: try blackwells or foleys
13:59:05 <rici> foyles
13:59:06 <glguy> !paste
13:59:07 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
13:59:09 <rici> damn can't type today
13:59:19 <glguy> I guess I need to add /new to that link?
13:59:42 <sorear> glguy: why?  that IS the pastebin base url
13:59:55 <glguy> @paste
13:59:56 <rici> although i've seen knuth and sedgewick in a variety of bookstores
13:59:56 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
14:00:10 <glguy> sorear: I just thought about it because someone decided that lambdabot should
14:00:19 <malsyned> is there a library in haskell for getting an lstat(2) call?
14:00:22 <allbery_b> it's helpfull for the pastebin pointer to go straight to the new paste page
14:00:32 <sorear> I sent the patch, but I didn't really think about it.
14:00:36 <sorear> malsyned: try System.Posix
14:00:42 <glguy> I need to add a List Pastes link to the new paste page
14:01:12 <sorear> rici: when you say there are 20 non-worthless CS books, you are counting TAOCP as 6, right? :)
14:01:30 <rici> three, actually
14:01:32 <sorear> glguy: while you're at it, how about a Source Code link? :)
14:01:41 <SamB> sorear: what? shouldn't each of those fascicles count as one?
14:01:43 <glguy> ?where hpaste
14:01:43 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
14:01:46 <glguy> you mean put this on the front page?
14:01:56 <sorear> glguy: yes.
14:01:58 <rici> well, it's an inaccurate count
14:02:07 <sorear> glguy: (I think lisppaste does that too)
14:02:09 <rici> i could have said 10, but there are actually more than that
14:02:25 <rici> the gc book, for example, is definitely worthwhile if you're interested in gc
14:02:59 <SamB> knuth, depressingly, does not seem to be at all
14:03:02 <rici> it's far from as all-encompassing as say SICP but that doesn't mean its not worthwhile
14:03:05 <sorear>    Main page           New paste | List all pastes | Syndication | XML-RPC | Source | Requests Email | Project home
14:03:20 <glguy> sorear: I was going to add that to the footer
14:03:31 <sorear> wow.  Lisppaste has a captcha for http users, but no captcha on the XML-RPC make-paste interface.
14:03:41 <SamB> heh
14:03:46 <syntaxfree> the captcha on Lisppaste is always "Lisp"
14:03:51 <pejo> Speaking of good books, I glanced through the new edition of the dragon book, and it seems really good - just like the old one.
14:03:58 <glguy> syntaxfree: recently it has been
14:04:01 <sorear> syntaxfree: thank you.  Now I can use lisppaste.
14:04:01 <SamB> what captcha?
14:04:02 <glguy> syntaxfree: but not always
14:04:11 <notsmack> dragon book?
14:04:16 <SamB> sorear: what? no framebuffer?
14:04:20 <pejo> rici, it does one thing, and does it really good though. Definitely worth its money if you're into GC as you say.
14:04:28 <SamB> or you just can't read anything on it?
14:04:28 <rici> pejo: i hope it's available next time i'm in london
14:04:42 <SamB> (or svgalib?)
14:04:50 <ElPenguin> there's a new edition of the dragon book?
14:04:53 <rici> i've been rereading sippu an soisalon-soinenen lately
14:05:12 <rici> those were phenomenally expensive but i'm glad i bought them.
14:05:20 <pejo> notsmack, the compilers book by Aho, Sethi and Ullman.
14:05:30 <sorear> SamB: what? run elinks as root?
14:05:31 <notsmack> ah.
14:05:38 <SamB> sorear: no silly
14:05:42 <SamB> just the image viewer!
14:05:54 <sorear> SamB: I *have* an image viewer
14:06:08 <sorear> SamB: the lisppaste captcha is a <TABLE>, not a <IMG>
14:06:11 <SamB> oh.
14:06:19 <SamB> that is a pretty stupid captcha
14:06:25 <SamB> when did they start using captchas?
14:06:30 <SamB> I don't remember any of this
14:06:42 <sorear> SamB: right before glguy wrote hpaste. :)
14:06:44 <SamB> also... I thought links supported tables
14:06:57 <sorear> SamB: it does ... but not background colors!
14:06:58 <nornagon> elinks forever, man.
14:07:20 <nornagon> TERM=xterm-256color elinks
14:07:22 <glguy> if I was going to restrict access to hpaste, I would have the irc bot generate a new url every day for adding pastes
14:07:27 <glguy> once you clicked it, you'd geta cookie
14:07:34 <glguy> so !paste users wouldn't know the difference
14:07:38 <glguy> but I'll wait for spam for that
14:08:09 <sorear> glguy: if you need it, how about just making sure Nick: is filled out within 1 levenschtein of a channel user?
14:08:17 <SamB> nornagon: I'm sure sorear will be able to use that without X
14:08:19 <glguy> sorear: perfert
14:08:24 <glguy> sorearbut
14:08:28 * allbery_b was just thinking that too
14:08:30 <glguy> most nicks are always valid
14:08:33 <nornagon> SamB: hush, i was lacking context
14:08:41 <sorear>      * complaisabt - hylomorphism intermediate datatype
14:08:47 <SamB> glguy: *channel user*
14:08:48 <sorear> who is complaisabt?
14:08:49 <SamB> someone there
14:08:50 <glguy> so that owuld be like having a captcha that was always "lambdabot"
14:08:51 <allbery_b> just don't also check IP since I usually paste from the machine I'm on, not the machien I'm vnc-ing to my IRC client on :)
14:08:53 <SamB> oh.
14:09:28 <allbery_b> "complaisant".  fits levenschtein distance 1...
14:09:34 <ElPenguin> http://paste.lisp.org/display/35696 the code for their 'captcha'
14:09:37 <ElPenguin> what a load of crap
14:09:39 <sorear> 14:05 < glguy> most nicks are always valid
14:09:48 <SamB> true...
14:09:53 <SamB> well, maybe not most
14:09:55 <SamB> but lots
14:10:03 <syntaxfree> Pancito is teh rox.
14:10:07 <SamB> like, someone could spam as me
14:10:08 <sorear> ElPenguin: if only I could see the alttext!!
14:10:27 <ElPenguin> sorear: they weren't concentrating on screenreaders methinks
14:10:34 <syntaxfree> Pancito is teh rox.
14:11:08 <syntaxfree> As much as functional image processing is slower, the fact that I can write filters in straight Haskell might save me a lot of time, as compared to the Photoshop approach.
14:11:37 * sorear ought to write his optimizing compiler arrows
14:15:40 <Saizan> [230359] <sorear> glguy: if you need it, how about just making sure Nick: is filled out within 1 levenschtein of a channel user? <-- this also needs IO from happs :\
14:16:10 <glguy> yeah, atm it's not easy for the bot to talk to happs
14:17:36 <Saizan> but if they use external DBs there should be a way to do it
14:17:55 <glguy> I know it can be done
14:17:56 <dmhouse> glguy: you could use HAppS to implement some kind of REST API
14:18:03 <glguy> I'm not sure how major ofa change it is
14:18:16 <glguy> I don't really want the bot to call websites up to do stuff though...
14:18:24 <dmhouse> glguy: and why aren't you on #happs? :)
14:18:26 <dmhouse> glguy: why not?
14:18:45 <glguy> dmhouse: because then it would be a public facing interface
14:18:59 <glguy> seems hackish to pass around a key to validate myself to the webserver
14:19:09 <dmhouse> glguy: what's wrong with a public facing interface?
14:19:17 <dmhouse> I presume your bot is open source anyway.
14:19:27 <glguy> for validating nicks?
14:19:43 <dmhouse> Sure.
14:19:50 <glguy> dmhouse: the bot and the paste page are one and the same...
14:21:58 <sorear> dmhouse: how hard is it to to http trickle-feed in happs?
14:22:14 <dmhouse> sorear: trickle-feed?
14:22:50 <sorear> dmhouse: ideally hpaste would be merged into lambdabot.  so we want a no-polling method to announce pages.
14:23:00 <sorear> shapr said it was called trickle-feed.
14:23:05 <musasabi> sorear: if you mean a HTTP-page that is streaming over and over that is supported.
14:23:11 <sorear> I call it writing to a socket :)
14:24:06 <dmhouse> So what exactly is a trickle feed?
14:24:18 <sorear> ask shapr
14:24:23 * glguy wonders how long the nick cookie should last
14:24:26 <glguy> days? session?
14:24:31 <dmhouse> musasabi: what do you mean by 'streaming'?
14:24:31 <sorear> glguy: indefinite?
14:24:40 <glguy> maxBound?
14:24:46 <dmhouse> glguy: have a 'Remember Me' checkbox, and if checked, years.
14:25:01 <sorear> dmhouse: why only years? why not forever?
14:25:04 <dmhouse> Indefinite for all practical senses of the word.
14:25:08 <glguy> there isn't a "forever"
14:25:14 <glguy> all cookies expire
14:25:15 <dmhouse> sorear: well you can't actually have indefinite cookies in HTTP.
14:25:22 <sorear> that's dumb
14:25:28 <dmhouse> It's a privacy thing.
14:25:47 <allbery_b> you can however set the expiration to sometime in 2032 or something
14:26:06 <sorear> Hey! Why'd you forget me!
14:26:09 <allbery_b> (can't go past 2038... :)
14:26:26 <sorear> I thought it used RFC 2822 dates?
14:26:36 <glguy> Set a Cookie in the Result. The values are escaped as per RFC 2109, but some browsers may have buggy support for cookies containing e.g. '"' or ' '.
14:27:03 <glguy> but HAppS' API takes seconds
14:27:45 <sorear> HAppS uses Int32 ?!
14:28:05 <glguy> type Seconds = Int
14:28:11 <sorear> that's dumb
14:28:34 <glguy> > (maxBound :: Int) `div` (3600 * 24 * 365)
14:28:36 <lambdabot>  68
14:28:47 <glguy> yeah, your cookies might expire in 68 years..
14:28:49 <sorear> it's like newspeak.
14:29:02 <sorear> they don't want us to worry about the end of the world
14:29:10 <SamB> sorear: what crazy elinks are you using
14:29:29 <sorear> so they make timespecs such that we can't represent times beyond the end of the world.
14:29:30 <SamB>    Captcha:                      What language is paste.lisp.org written in?
14:29:30 <SamB>                                  _____________________
14:30:07 <dmhouse> glguy: it's probably 68 years from 1970.
14:30:13 <sorear> SamB: funny, it never showed up before
14:30:22 <dmhouse> glguy: if HTTP uses the same size Ints.
14:30:28 <sorear> (it does now BTW)
14:30:32 <_magus_> I'm having some problems with c2hs on a Debian Sid system, anyone around who could give me some pointers?
14:30:34 <SamB> maybe they added that part since you tried before?
14:30:50 <SamB> since people complained that it did not work in elinks?
14:30:54 <jcreigh> ..and you'll burn up some extra seconds in leap years...
14:31:02 <sorear> leap seconds!
14:31:45 <_magus_> it's really about the C2HS library... anyone?
14:32:10 <sorear> _magus_: we can't help unless we know what your problem is :)
14:32:21 <sorear> !paste
14:32:22 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
14:32:35 <sorear> (if long)
14:32:37 <_magus_> sorear, ah, well, now I have someone's attention at least...
14:33:09 <_magus_> sorear, the code imports CForeign... but GHC says the module is hidden (I suppose that means it shouldn't be used)
14:33:25 <sorear> _magus_: are you using cabal?
14:33:33 <_magus_> sorear, yupp
14:33:40 <sorear> _magus_: hidden means you forgot to declare a dependency
14:33:57 <sorear> _magus_: you're right, you shouldn't use packages without saying you use them
14:34:26 <sorear> _magus_: Cabal is the only build system I know that actually does something about undocumented dependencies.
14:34:30 <_magus_> sorear, ah, but searching through hoogle for CForeign doesn't turn up anything
14:34:58 <allbery_b> @hoogle CForeign
14:34:59 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
14:35:00 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
14:35:00 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
14:35:04 <sorear> _magus_: GHC should have said someting like "which was found in package foobar (which is hidden)"
14:35:06 <sjanssen> _magus_: CForeign is a helper module for c2hs generated code
14:35:09 <_magus_> sorear, there was a similar problem with Monad, I could solve that by putting in Control.Monad instead
14:35:12 <sorear> add foobar to build-depends
14:35:21 <sorear> _magus_: Monad is in haskell98
14:35:36 <sorear> which GHC *should* have told you
14:36:45 <_magus_> sorear, yeah, it did, but what's the difference between Monad and Control.Monad?
14:36:56 <sorear> Monad is obsolete
14:36:59 <allbery_b> Monad is the old Haskell98 flat namespace name
14:37:01 <sorear> pre-hierarichal-libs
14:37:01 <hpaste>  glguy annotated "announce test" with "" at http://kakapo.scannedinavian.com:8000/4#9
14:37:03 <lambdabot> Title: announce test - hpaste
14:37:18 <hpaste> "Remember Me" works now until maxBound seconds from 1970
14:37:53 <_magus_> sorear, GHC tells me CForeign is in haskell98 as well... why doesn't it show in hoogle?
14:38:08 <allbery_b> becaus ehoogle uses the new namespace
14:38:08 <sorear> _magus_: because hoogle doesn't support packages.
14:38:16 <sorear> _magus_: hoogle /= haskell
14:38:28 <glguy> ew, only worked on annotations
14:38:30 <glguy> hmm..
14:38:36 <sorear> _magus_: just add haskell98 to build-depends
14:38:59 <_magus_> sorear, just confuses me that Monad is in hoogle, while CForeign isn't...
14:40:45 <sorear> _magus_: hoogle is going to have support for packages RSN ... ndm knows more than I here
14:42:44 <musasabi> sorear: HAppS uses 64-bit ints (Int64) for absolute time and machine ints (Int) for relative time mostly.
14:43:13 <hpaste>  sorear pasted "testing remember-me" at http://kakapo.scannedinavian.com:8000/16
14:43:20 <dcorbin> What is Haskell equivalent of the Ruby PickAxe book?
14:43:52 <LoganCapaldo_> blood and sweat?
14:44:02 <dcorbin> I was afraid you'd say that.
14:44:35 <_magus_> sorear, hmm, have a "build-depends: base, haskell98" in the cabal file, still I'm told that Monad is in haskell98, which is hidden
14:44:51 <sorear> _magus_: did you reconfigure?
14:46:10 <_magus_> sorear, ah, I'm stupid, thanks!
14:53:19 <Saizan> ah, btw, the #n internal links for annotations don't work, we miss the <a name="n">...</a> right?
14:53:52 <glguy> yeah...
14:53:56 <glguy> i odn't know how that happened
14:53:58 <glguy> fixing
15:02:25 <Fullmoon_mobile> I have trouble defining functions in the hugs interpreter... I type "square x = x * x "
15:02:33 <Fullmoon_mobile> And get "ERROR - Syntax error in input (unexpected `=')" :( Why?
15:02:46 <Cale> Fullmoon_mobile: hugs only evaluates expressions at its prompt
15:02:57 <sorear> Fullmoon_mobile: you can't define functions in hugs at the prompt
15:02:59 <Fullmoon_mobile> Cale: So no functions, aaah!
15:02:59 <Cale> To make declarations, you need to create a file.
15:03:03 <sorear> you need GHCI, or a file.
15:03:07 <Fullmoon_mobile> Interesting, thanks :)
15:03:22 <Cale> In GHCi, you can declare functions, but can't make other kinds of declarations.
15:03:22 <dmead> unfortuneatly it's not like CL
15:03:25 <allbery_b> ...and in ghci it's:  let square x ...
15:03:28 <dmead> where you can just type functions
15:03:29 <matthew-_> in ghci, how do you undefine a function?
15:03:54 <dmead> type it in backwards
15:03:54 <dmead> :>
15:03:54 <allbery_b> (with no "... in ...")
15:03:55 <sorear> dmead: CL doesn't have typed forward refs does it?
15:04:00 <Cale> matthew-_: reloading the file should work to clear any temporary bindings
15:04:11 <dmead> sorear: whatnow?
15:04:12 <augustss> It's sad that hugs and ghci have such deficient top levels.
15:04:14 <Cale> :r (or I'm told just : works)
15:04:27 <Cale> I've never really minded it.
15:04:28 <glguy> it does!
15:04:33 <sorear> dmead: we pay dearly for our top level letrec.
15:04:38 <glguy> Cale: makes it easy to do with one hand
15:04:46 <matthew-_> Cale: but if you just do "let square x = x * x" at the prompt, and then you want to undefine square ?
15:04:57 <sorear> matthew-_: why?
15:04:57 <dmead> mmmm
15:05:06 <dmead> sorear: everything at a lisp prompt is a lisp expression
15:05:06 <Cale> matthew-_: you could type  square = undefined
15:05:13 <sorear> dmead: I know.
15:05:23 <allbery_b> let?
15:05:25 <Cale> er, let square = undefined, of course :)
15:05:35 <sorear> dmead: effectively, a lisp prompt is a (begin), which can be processed lazily.
15:05:51 <dmead> ah
15:05:52 <sorear> dmead: but a haskell toplevel is a (letrec), which can't
15:06:25 <sorear> dmead: haskell interpreters use a plain let, which gives us interactivity at the cost of much flexibility
15:06:39 <dmead> ahh
15:06:40 <dmead> gotcha
15:06:41 <augustss> sorear: but there's no reason why we couldn't make any top level declarations legal at the ghci prompt
15:06:44 <sorear> not quite exact, but close enough
15:07:01 <sorear> augustss: computational complexity?
15:07:11 <augustss> sorear: in hbi you can make any top level declaration
15:07:12 <sorear> augustss: I believe runplugs is O(n^2) ?
15:07:29 <sorear> in runplugs you can make any toplevel declaration
15:07:30 <augustss> sorear: and thay's from 1992 :)
15:07:39 <Cale> augustss: can you refer to not-yet-defined things?
15:07:46 <augustss> s/thay/that/
15:07:46 <sorear> runplugs uses the GHC 6.4 RTS
15:07:54 <sorear> Cale: not with runplugs.
15:07:56 <augustss> Cale: no
15:08:08 <sorear> augustss: is hbi similar in structure to runplugs?
15:08:16 <sorear> (prefix compilation)
15:08:23 <augustss> Cale: for a mutually recursive group you need { defs }
15:08:55 <augustss> sorear: no, hbi was just a top level prompt, much like hugs and ghci
15:09:05 <Cale> and this also forces data declarations to be at the top (which is probably a good idea, but also means that it's not the same as in the file)
15:09:19 <augustss> you can load object files, or interpret, just like ghci
15:09:34 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/20/baby-steps-with-pancito-a-simple-color-filter/
15:09:37 <lambdabot> Title: Baby steps with Pancito: a simple color filter « Data.Syntaxfree, http://tinyurl.com/2juora
15:10:26 <sorear> yow.
15:10:35 <sorear> Network/Protocol/XMPP.hs:46:7:       \n      Could not find module `Data.FiniteMap':
15:10:51 <augustss> It's just laziness (from the implementors) not allowing more at the top level. :)
15:11:10 <sorear> augustss: where can you get hbi?
15:11:14 <sorear> @where hbi
15:11:14 <Cale> Well, sure, I still think it's a better idea to put declarations in a file.
15:11:15 <lambdabot> I know nothing about hbi.
15:11:15 <sorear> @where hbc
15:11:16 <lambdabot> I know nothing about hbc.
15:11:36 <augustss> sorear: I've not made a new release in years
15:11:53 <augustss> sorear: I regard it as pretty much dead
15:12:04 <Cale> A two-pane view like Dr.Scheme would be better.
15:12:04 <sorear> augustss: I want to loot the body
15:12:12 <augustss> heh
15:12:24 <Korollary> Cale: I hate drscheme's panes
15:12:51 <Cale> at least, if you're going to have people making declarations
15:12:51 <syntaxfree> how can you?
15:13:00 <syntaxfree> are you even human?
15:13:26 <fatalis_> I eat human
15:13:32 <JKnecht> Cale not human?
15:13:43 <augustss> Cale is a bot
15:14:11 <augustss> We are all bots.
15:14:20 <syntaxfree> How does someone hate Dr. Scheme?
15:14:25 <syntaxfree> Dr. Scheme is a good person!
15:14:55 <augustss> Dr Scheme is a bot.
15:15:00 <Korollary> No wonder you have misconceptions about who's human
15:15:19 <augustss> Korollary is a bot.
15:15:50 * lambdabot feels less unique :(
15:16:06 <hpaste> life is hard
15:16:51 <mbishop> aww cheer up emo bot
15:16:51 * JKnecht is definitely a special snowflake.
15:16:58 <mbishop> @botsnack
15:16:59 <lambdabot> :)
15:17:16 <hpaste> :)
15:20:30 <sorear> @users
15:20:31 <lambdabot> Maximum users seen in #haskell: 311, currently: 293 (94.2%), active: 46 (15.7%)
15:21:23 <glguy> holy shit... 8th bracket expert songs are TOUGH in guitarhero2
15:21:38 <matt__r> glguy: :)
15:22:16 <glguy> this game is decidedly harder to beat than the original ;)
15:23:06 <matt__r> glguy: they often do that - sometimes it is a good thing - sometimes bad.  With Pikmin they trashed it my making it harder, but I think with gh it is good
15:23:43 <glguy> they made medium easier though
15:23:52 <glguy> I got 5 stars in all the medium songs on my first try
15:23:58 <glguy> but the expert songs tend to kick ass
15:24:00 <glguy> mine
15:25:00 <glguy> but I guess when I first played medium in the first game I was new to it
15:25:26 <mauke> where can I read about runtime complexities of typical malloc implementations?
15:26:23 <matt__r> mauke: umm...
15:27:50 <sorear> seen in real world Haskell code: (\r -> r ++ "!")
15:28:26 <Botje> is it _THAT_ much worse than (++"!") ?
15:28:55 <mauke> (++"!") is inefficient; use ("!"++) instead
15:29:18 <Botje> but that puts the "!" in front..
15:29:19 <sorear> mauke: that's semantically different
15:29:29 <mauke> yes, but it's faster!!
15:29:42 <sorear> ('!':) `isBetterThan` ("!"++)
15:29:51 <sorear> True
15:29:54 <mauke> sorry, I'm writing C again :(
15:30:57 <Cale> (.('!':))
15:31:17 <Botje> :t (.('!':))
15:31:19 <lambdabot> forall c. ([Char] -> c) -> [Char] -> c
15:31:32 <syntaxfree> why is ("!"++) faster than (++"!")?
15:31:40 <mauke> "ShowS-off"
15:31:54 <Cale> x ++ y takes O(length x) steps
15:32:01 <syntaxfree> oh. true.
15:32:12 <syntaxfree> well, "const 1" is even faster!
15:32:17 <Botje> \omega(length x) even :P
15:32:47 <sorear> import Data.DList
15:32:59 <sorear> (`mappend` (singleton '!'))
15:33:03 <LoganCapaldo_> \Omega(length x) too as well, no? :)
15:33:03 <Cale> Specifically, I'm pretty sure it's  1 + length x  steps.
15:33:28 <Cale> Well, min(1 + length x, k), where k is the number of cells actually needed.
15:34:11 <Cale> DList is a little silly :)
15:34:13 <sorear> > foldr (:) "foo" "bar"
15:34:14 <lambdabot>  "barfoo"
15:34:23 <sorear> > flip (foldr (:)) "foo" "bar"
15:34:25 <lambdabot>  "foobar"
15:34:47 <sorear> @users
15:34:48 <lambdabot> Maximum users seen in #haskell: 311, currently: 292 (93.9%), active: 48 (16.4%)
15:34:49 <syntaxfree> "Barfoo" reminds me of "Darfur".
15:35:14 <syntaxfree> @src concat
15:35:15 <lambdabot> concat = foldr (++) []
15:35:24 <sorear> Barfoo is an ancient contry of programmers
15:35:27 <sorear> @src (++)
15:35:28 <lambdabot> (++) []     ys = ys
15:35:29 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
15:35:35 <sorear> aww, no foldr
15:35:39 <syntaxfree> @src ($)
15:35:40 <lambdabot> f $ x = f x
15:36:28 <sorear> ($)=id
15:36:53 <sorear> what's the most overlong @src?
15:37:08 <glguy> ?src Arrow
15:37:08 <lambdabot> class Arrow a where
15:37:09 <lambdabot>     arr, pure   :: (b -> c) -> a b c
15:37:09 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
15:37:09 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
15:37:09 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
15:37:10 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
15:37:12 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
15:37:24 <glguy> guess
15:37:37 <sorear> I meant most-longer-than-necessary
15:37:49 <sorear> ?src Foldable
15:37:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:37:54 <sorear> aww
15:38:07 <sorear> ?src Float
15:38:08 <lambdabot> data Float = F# Float#
15:38:08 <sorear> ?src Floating
15:38:09 <lambdabot> class  (Fractional a) => Floating a  where
15:38:10 <lambdabot>     pi                                                      :: a
15:38:10 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:38:10 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:38:10 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:38:36 <sorear> what gives? :)
15:38:42 <sgillespie> hello
15:38:45 <sorear> hi!
15:38:50 <glguy> wtf do those functions have to do with whether something is a "Floating"
15:39:06 <sgillespie> I have a question about IO
15:39:10 <sorear> well they don't work on rats :)
15:39:20 <sorear> sgillespie: a lot of people do.
15:39:25 <sgillespie> i'm sure they do
15:39:27 <sorear> sgillespie: (you have attention)
15:39:28 <Cale> sgillespie: go for it
15:39:32 <sgillespie> alrighty
15:39:38 <sgillespie> i'm sure this is a common question
15:39:49 <glguy> is that your question?
15:39:53 <sgillespie> if i do putStrLn "Enter Something:  "
15:39:58 <sorear> ...
15:40:07 <sgillespie> and then something <- readLine
15:40:10 <sgillespie> or wait
15:40:14 <sgillespie> is it read?
15:40:17 <sgillespie> not important
15:40:19 <Cale> readLn
15:40:24 <sgillespie> but if i do
15:40:24 <bd_> :t readLn
15:40:24 <mauke> getLine or readLn, depending
15:40:26 <lambdabot> forall a. (Read a) => IO a
15:40:36 <syntaxfree> wait, wait.
15:40:38 <sgillespie> putStr "Enter Something:  " (no newline)
15:40:46 <kpreid> sgillespie: hFlush stodut
15:40:49 <sorear> sgillespie: the answer is hFlush
15:40:56 <mauke> heh
15:40:57 <Botje> or you can turn off buffering.
15:41:00 <kpreid> stdout, even
15:41:02 <Cale> It's not printing the prompt?
15:41:07 <kpreid> there oughta be a flush = hFlush stdout
15:41:08 <sorear> sgillespie: (we can guess your quiestion, it is so common0
15:41:13 <sgillespie> right
15:41:16 <syntaxfree> he wants the cursor to be in the same line as the prompt, I think.
15:41:19 <sgillespie> i thought it was fairly common
15:41:30 <allbery_b> yep.  not even haskell-specific
15:41:40 <bd_> sgillespie: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#12
15:41:42 <lambdabot> http://tinyurl.com/sbkmj
15:41:43 <sgillespie> yeah, had it in other languages recently as well
15:41:44 <sorear> and would you believe some ppl think it is a laziness problem? wow.
15:41:45 <mauke> allbery_b: STOP READING MY MIND
15:41:53 <Cale> Yeah, that's just a buffering thing. You can turn output buffering off with  hSetBuffering stdout NoBuffering
15:41:55 <bd_> hSetBuffering stdout NoBuffering
15:42:01 <allbery_b> heh
15:42:13 <sgillespie> lazy? interesting
15:42:20 <sorear> sgillespie: no
15:42:25 <sgillespie> i tried hSetBuffering sdtout LineBuffering
15:42:28 <Cale> Welcome to #haskell where your questions are answered in majestic stereo!
15:42:34 <sorear> sgillespie: the laziness is an absolutely ridiculous misconception
15:42:40 <bd_> sgillespie: LineBuffering means the buffer is flushed after \n
15:42:43 <syntaxfree> @remember Cale Welcome to #haskell where your questions are answered in majestic stereo!
15:42:43 <lambdabot> Done memoising quote for `Cale', if that is their real name...
15:42:47 <bd_> sgillespie: since there's no \n, it's not flushed :)
15:42:48 <syntaxfree> @quote Cale
15:42:48 <lambdabot> Cale says: They're using continental drift as a means of communication.
15:42:54 <sgillespie> i saw that in the yyht
15:43:10 <sgillespie> okay
15:43:13 <yax1> more like dolby 5.1
15:43:13 <sgillespie> what was it again
15:43:14 <sorear> acronym overload!
15:43:16 <sgillespie> NoBuffering
15:43:18 <sorear> what's yyht
15:43:27 <Cale> sorear: probably yaht
15:43:31 <sgillespie> yet another haskell tutorial
15:43:40 <syntaxfree> @quote tutorial
15:43:41 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
15:43:45 <sgillespie> aw man..
15:44:05 <sgillespie> yaht, good guess
15:44:10 <sorear> I don't like acronyms, they lower hamming-distance too much
15:44:16 <bd_> This program brought to you by IO, ReaderT, and viewers like you.
15:44:30 <syntaxfree> @quote IO
15:44:31 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
15:44:35 <syntaxfree> @quote IO
15:44:36 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
15:44:37 <sgillespie> yeah, but acronyms are inevitable
15:44:44 <sgillespie> especially for lazy typers
15:44:49 <mauke> yet ynother haskell torturial
15:45:02 <sgillespie> torturial?
15:45:06 <sorear> if you type lazily, won't that just truncate the output? :)
15:45:25 <sgillespie> <laugh out loud>
15:45:43 <yax1> sorear: ooh, hamming distance!
15:45:49 <bd_> sorear: Nah, it'd just serialize the CAF and send it through IRC :)
15:45:59 <sorear> yax1: what about it?
15:46:12 <syntaxfree> @quote hamming
15:46:12 <lambdabot> No quotes match. You type like i drive.
15:46:13 <sgillespie> alright, thanks everyone
15:46:19 <syntaxfree> @cheeky-off
15:46:20 <lambdabot> Unknown command, try @list
15:46:28 <yax1> sorear: just reading about it now, looks relevant to my current problem, thanks!
15:46:34 <sgillespie> will get back to hacking
15:46:35 <sorear>  @tell dons
15:46:43 <LoganCapaldo> @quote LoganCapaldo
15:46:44 <lambdabot> LoganCapaldo says: <LoganCapaldo> @src fixIO <lambdabot> Source not found. Are you on drugs? <LoganCapaldo> No <LoganCapaldo> Meanie
15:47:01 <sorear> you still have 20 hrs to fill dons' inbox
15:47:52 <SamB> someone send him a DVD in little tiny pieces ;-)
15:47:54 <yax1> ah, in fact was reading about hamming distance earlier
15:48:31 * sorear doesn't get it
15:48:55 <yax1> sorear: in fact i think you meant Levenshtein distance :)
15:50:22 <sorear> yax1: I think hamming distance is a property of codes, and it can use any metric on the space of codewords, including the Levenschein metric.
15:51:15 <augustss> @quote
15:51:16 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
15:51:16 <lambdabot> Haskell
15:52:07 <augustss> @quote
15:52:08 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
15:52:35 <sorear> @quot
15:52:36 <lambdabot> wadler says: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
15:52:37 <SamB> um... probably because it is filled with "arr"s?
15:52:37 <Saizan> :D
15:52:57 <yax1> sorear: according to wikipedia, hamming distance only applies between strings of the same length, and levenschtein distance generalises that to strings of different lengths
15:53:48 <sorear> yax1: "abcdefgh" `hamming` "bcdefgha" /= "abcdefgh" `levenschtein` "bcdefgha"
15:54:17 <sorear> does wikipedia say anything about what the minimal pair distance of a metrized code is called?
15:55:00 <SamB> @pl \xs ys -> length (filter id (zipWith (/=) xs ys))
15:55:02 <lambdabot> ((length . filter id) .) . zipWith (/=)
15:55:21 <Saizan> yax1, afaik, hamming distance is between languages and levenschtein is between words
15:55:29 <SamB> languages?
15:55:46 <Saizan> well if you consider line noise to be a language too
15:55:54 <sorear> \xs ys -> sum [1 | True <- zipWith (/=) xs ys]
15:56:03 <rici> hamming distance is the number of substitutions needed to make string a into string b, if a and b are the same length
15:56:06 <allbery_b> Saizan: Perl? :)
15:56:18 <SamB> sorear: how is that an improvement?
15:56:35 <rici> it's one of many possible distance metrics, and probably not the most useful one
15:56:38 <sorear> SamB: don't know.  more idiomatic?
15:56:39 <sgillespie> is there a convention for predicates
15:56:41 <SamB> allbery_b: now, now, not *all* line noise is valid perl
15:56:49 <allbery_b> no, that'd be J...
15:56:49 <rici> but more people can spell hamming than levenshtein
15:56:50 <sorear> sgillespie: isFoo
15:56:50 <sgillespie> like for example ? in scheme and p in common lisp
15:56:56 <sgillespie> oh...
15:56:58 <sorear> isPrefixOf
15:57:08 <sgillespie> isFeelingStupid
15:57:08 <sorear> isUpper
15:57:26 <sorear> False?
15:57:34 <SamB> isPrefixConvention
15:57:47 <Saizan> uhm no, it's some other distance what i was referring to
16:05:56 <orbitz> hrm what does teh Ix module do?
16:06:19 <malsyned> Ix is used to index into Arrays.  Check the Array docs to learn about Ix.
16:09:15 <sorear> whoa
16:09:18 --- mode: irc.freenode.net set +o ChanServ
16:09:32 <SamB> it lets you use tuples to index arrays, among other things
16:11:34 <syntaxfree> @quote
16:11:35 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
16:12:04 <kolmodin> g'night
16:12:24 <sorear> night
16:17:02 <musasabi> Are there snapshot tarballs of the darcs GHC head repo available? (that is containing _darcs, so they can be used for further pull/push)
16:17:21 <sorear> I don't know.
16:18:01 <sorear> I wonder if that would be a good thing, compressed repo images?
16:18:29 <sorear> lzma and inter-patch compression ftw, never mind near-0 connection overhead.
16:19:11 <SamB> sorear: ... that will only work if the patches aren't already gzipped
16:19:19 <sorear> SamB: yes
16:19:30 <sorear> SamB: I would darcs optimize --decompress first
16:19:46 <sorear> s/de/un/
16:20:23 <SamB> maybe darcs could support checkpoint tarballs?
16:21:05 <sorear> hmm.
16:21:44 <sorear> Copying patch 26 of 15259...
16:23:40 <musasabi> sorear: use --partial
16:23:54 <sorear> musasabi: --complete is the whole point here
16:24:16 <sorear> musasabi: I want to see how big a darcs optimize --uncommpressed 7zipped ghc darcs repo is
16:24:31 <musasabi> nice ^^
16:24:41 <sorear> besides, I'm already at patch 2000
16:25:06 <sorear> as long as you have something else to do (like #haskell), darcs get is pretty fast
16:25:57 <sorear> is anyone here a user of xmpp?
16:26:06 <sorear> patch 3k ...
16:26:08 <SamB> oh man
16:26:13 <SamB> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/BlockAlloc
16:26:17 <lambdabot> Title: Commentary/Rts/Storage/BlockAlloc - GHC - Trac, http://tinyurl.com/2x5qzt
16:26:22 <sorear> eh?
16:26:49 <SamB> apparantly GHC can't free memory to the OS
16:27:13 <sorear> even though it uses blocks bigger than the glibc mmap threshold?
16:27:58 <rici> it says it doesn't free memory to the OS
16:28:08 <musasabi> freeing memory to the OS is nontrivial to do right.
16:28:58 <sorear> would it be trivial to do acceptably? :)
16:29:05 <rici> strictly speaking, there's an enormous difference between telling the OS that you no longer need a VM address range and telling it that the contents of a VM address range are no longer needed
16:29:22 <rici> the first one is what you're probably thinking about, and it's not a good idea
16:29:28 <sorear> rici: have you seen /dev/anon?
16:29:34 <rici> the second one can be done on posix-like systems with madvise
16:30:02 <rici> it's been tried extensively and rarely speeds things up, although it sometimes does
16:30:02 <sorear> UML has hooks into the host kernel for freeing ram...
16:30:20 <dmead> i think you need to have a better english sentence to describe the two
16:30:30 <dmead> thats like, semantically identical
16:30:40 <rici> yeah, that's highly non-portable and probably badly used in most cases
16:30:44 <rici> dmead: not at all
16:30:55 <musasabi> sorear: mostly it is about avoiding boundaries where the system is oscillating between allocating and freeing memory from the OS.
16:30:56 <rici> in the first case, if i reference the contents of an address in that range, i get a segfault
16:30:59 <dmead> rici: enlighten me?
16:31:06 <sorear> musasabi: hysteresis!
16:31:07 <rici> in the second case, i get random data, (or 0 on posix systems)
16:31:15 <allbery_b> dmead: no, one unmaps the address space, the other leaves it nominlly mapped but considers its contents disposable (so kernbel might substitute COW zero pages)
16:31:18 <rici> those are quite different events
16:31:24 <dmead> oh
16:31:26 <dmead> yea
16:31:28 <dmead> i see now
16:31:32 <dmead> need glasses :)
16:31:55 <rici> actually you might not get 0. you might get whatever you left there.
16:31:56 <sorear> Copying patch 7009 of 15259...^L[A
16:31:58 <rici> so it is non-predictable data
16:32:19 <SamB> I bet madvise speeds things up when other programs need RAM
16:32:21 <allbery_b> yeh.  "might"
16:32:27 <sorear> but it's not going to be used, so why do we care?
16:32:29 <allbery_b> madvise is only advice after all
16:32:31 <rici> samb, not necessarily
16:32:32 <sorear> (the data)
16:32:38 <rici> but sometimes
16:32:41 <SamB> rici: why not?
16:32:46 <SamB> well, it is *advice*
16:32:48 <sorear> doesn't it free swap?
16:32:51 <SamB> and as such might be ignored...
16:32:53 <rici> well, what is saves is writing the data out to swap
16:33:00 <SamB> rici: yes
16:33:01 <sorear> which takes time
16:33:11 <rici> indeed, but it doesn't necessarily take many cycles
16:33:11 <allbery_b> the kernel isd also free to ignore your request unless it thinks it needs the memory and can't get it some other way
16:33:15 <sorear> rici: I only have 2G of swap.
16:33:22 <SamB> it will also save reading useless data back in from swap
16:33:23 <rici> are you on linux?
16:33:34 <sorear> I have very fast disks, and can fill swap in under a minute.
16:33:35 <allbery_b> it's all up to the kernbel's policies,, which can range from "ignored" to "immediately replace with COW zeros"
16:33:35 <rici> SamB: that's less of a concern
16:33:37 <sorear> rici: yes
16:33:43 <SamB> rici: how so?
16:33:49 <mbishop> kernbel
16:33:50 <rici> most of the cost of the read is the interrupt handling, not actually getting the data
16:33:51 * mbishop giggles
16:34:00 <SamB> rici: um.
16:34:04 <SamB> reading takes *TIME(
16:34:05 * allbery_b can't type.  even less so around  dinner plate :/
16:34:10 <SamB> disks must seek
16:34:13 <rici> sorear: unlike windows, linux does not reserve swap just because you've allocated address space
16:34:19 <SamB> it is REALLY DAMN SLOW
16:34:28 <sorear> rici: while the system is reading data, I may not be using CPU power, but Haskell is still TASK_UNINTERRUPTABLE
16:34:30 <rici> SamB: that's true: it takes time, but it doesn't necessarily take many cycles
16:34:36 <SamB> rici: I care about both
16:34:44 <rici> sure, that's fair enough.
16:34:47 <SamB> also it makes a horrid noise
16:35:01 <rici> the problem is that when you do the madvise, you need to do a context switch into the kernel
16:35:04 <mbishop> allbery_b: send me that card :P
16:35:05 <sorear> rici: yes.  But I've written data, and now I'm not using it.  Hystesis has been applied, don't worry about occilation
16:35:12 <rici> and then the kernel needs to change the page tables
16:35:17 <rici> which means you have to flush the tlbs
16:35:24 <sorear> rici: this would be *rare*, like when memory falls below 50% utilization
16:35:26 <rici> which is really an enormous oomph
16:35:44 <rici> practical experience shows that it's not a clear win
16:35:56 <sorear> rici: P1 and above have an instruction to flush only a narrow address range
16:36:10 <rici> the freebsd allocator used to do it, and it still has it as an option, but it's usually not good to enable it
16:36:32 <sorear> Copying patch 10003 of 15259...L[A
16:36:58 <sorear> how often did the fbsd allocator do this?
16:37:11 <rici> the point is, the case where it would really be a win is the case where your machine is going into swap mode
16:37:12 * sorear still thinks all the problems can be solved with hysteresis
16:37:23 <rici> and at that point all is lost from a performance perspective
16:37:47 <sorear> the same argument can be made for not having a vm subsystem.
16:37:58 <rici> sorear: it did it when the free block got big enough to be worthwhile, but i don't know what the threshold is.
16:38:04 <sorear> I like soft boundaries.
16:38:12 <rici> sorear: not at all, the vm subsystem protects processes from each other
16:38:30 <sorear> I'm prepared to wait while a program finishes with a too-large working set.
16:38:45 <rici> the same argument could be made for not having a swapping system, though.
16:38:49 <sorear> If I can do things that will (only) make it faster while swapping, that's great.
16:38:55 <rici> and, in fact, it has been made (not by me)
16:39:26 <sorear> Suprisingly enough, waiting for VM is often faster than tuning your throwaway program for space usage.
16:39:44 * allbery_b used to use non-demand paging unixen.  no thanks.
16:39:47 <rici> sure
16:40:07 <rici> that's a testimony to good vm algorithms in modern kernels
16:40:59 <yax1> sorear: i wonder which uses more electricity though?
16:42:54 <sorear> yax1: I'm one of those obscenely rich (by world standards) Americans who doesn't care about small efficiencies 99% of the time.
16:43:02 <allbery_b> modern cpus suck down so much power the faster one wins :)
16:43:07 <sorear> Copying patch 14083 of 15259...L[A
16:46:42 <sorear> darcs get --complete http://darcs.haskell.org/ghc  has reached the apply phase
16:46:43 <lambdabot> Title: Index of /ghc
16:48:39 * allbery_b was not crazy enough to do a --complete of ghc :)
16:49:57 <sorear> 12474 stefan    18   0 46232  41m 3492 D 79.1 10.9   3:34.83 darcs
16:50:20 <sorear> allbery_b: and I haven't even gotten to darcs-all --complete get!
16:50:29 <sorear> 130M    ghc
16:51:41 <sorear> once I'm done with darcs-alling, I'll delete the pristine tree and working dir.
16:52:03 <sorear> you will be expected to run darcs repair and darcs revert.
16:52:10 <sorear> come to think of it...
16:52:28 <sorear> how about darcs sending all of ghc in a since bundle to an empty repo?
16:52:41 * sorear expects to meet the oom_killer
16:52:53 <Botje> sorear: tell it I said hi
16:54:50 <sorear> Consider it noted.
16:55:53 <sorear> stefan@stefans:/usr/local/src/ghcfull/ghc$ ./darcs-all --extra --complete get
16:56:05 <sorear> only 1643 patches in base?
16:56:07 <orbitz> does Array.! have a defiend time complexity?
16:56:12 <sorear> O(1)
16:56:40 <orbitz> ohh thank you
16:56:58 <astrolabe> Though I suspect that is actual rather than prescribed.
16:57:23 <sorear> not even actual
16:57:41 <astrolabe> How come?
16:57:41 <sorear> #haskel logs are full of rants about how cache hierarchies make it O(log n)
16:57:59 <sorear> and the laws of physics make it O(n^1/3)
16:58:02 <orbitz> hehe
16:58:33 <astrolabe> sorear: could you explain a bit please
16:59:03 <sorear> you are surrounded by a solid ball of RAM.
16:59:12 <astrolabe> I am !?
16:59:22 <sorear> how long does it take to reach any bit?
16:59:32 <astrolabe> sorear: I think I see
16:59:35 <sorear> given radius ~ cbrt(volume)
16:59:38 <mauke> O(1)
16:59:47 <mauke> there's a fixed upper limit on the size of the ball
16:59:49 <sorear> O(1) throughput I know
17:00:07 <astrolabe> But if the array is small, it is O(1)?
17:00:14 <sorear> mauke: Bekenstein bound makes it O(n^1/2)
17:00:18 <Botje> @src Data.Array
17:00:19 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:00:26 <astrolabe> heh
17:00:40 <sorear> mauke: Schwartzchild makes it O(n) iff your memory has fixed bits/gram
17:00:47 <astrolabe> I guess C arrays are the same then?
17:00:55 <orbitz> how is array implemented to have O(1) indexing time?
17:01:10 <sorear> but most people don't have to worry about their memory subsystem collapsing into a black hole :)
17:01:29 <sorear> orbitz: address fudging, and massively parallel decoder arrays.
17:01:43 <orbitz> what are decoder arrays? are they like a decoder ring?
17:02:00 <sorear> kinda. you have hundreds of thousands of address decoders in your ram chips
17:02:18 <sorear> all matching the addresses in parallel
17:02:27 <sorear> fast, phenominally wasteful.
17:02:39 <orbitz> why so wasteful?
17:03:05 <sorear> imagine if you only spent power on the lines that will have your data.
17:03:13 <astrolabe> wasteful of power
17:03:18 <orbitz> oh ok
17:03:27 <mauke> you think that's wasteful? try quantum bogosort!
17:03:48 * allbery_b rolls his eyes
17:04:13 <allbery_b> is that "keep observing it until you see it in order"?
17:04:57 <allbery_b> ...didn't mean to kill him :>
17:05:14 <sorear> Haskell: the language where quicksort is shorter and clearer than bubble sort.
17:05:21 <mauke> see http://www.catb.org/~esr/jargon/html/B/bogo-sort.html
17:05:23 <lambdabot> Title: bogo-sort
17:05:56 <allbery_b> I know bogosorts, just wondering what "quantum" adds here :)
17:06:00 * mbishop doesn't believe in Eric S. Raymond
17:06:13 <mauke> allbery_b: the second paragraph
17:06:22 <rahikkala> http://www.dangermouse.net/esoteric/bogobogosort.html
17:06:24 <lambdabot> Title: DM's Esoteric Programming Languages - Bogobogosort
17:06:25 <mauke>  "The steps are: 1. Permute the array randomly using a quantum process, 2. If the array is not sorted, destroy the universe (checking that the list is sorted requires O(n) time). Implementation of step 2 is left as an exercise for the reader."
17:06:25 <allbery_b> heh
17:06:54 <fatalis> HERESY
17:09:10 <sorear> 354M    .
17:09:22 <sorear> after ./darcs-all optimize --uncompress
17:09:44 <mauke> hahaha, http://en.wikipedia.org/wiki/Bogosort#Quantum_Bogosort
17:11:26 <matt__r> @paste
17:11:27 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
17:12:15 <hpaste>  matt__r pasted "can I get a little reflection?" at http://kakapo.scannedinavian.com:8000/17
17:13:10 <sorear> yes you can.
17:13:16 <sorear> @docs Data.Generics.Basics
17:13:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html
17:13:25 <sorear> matt__r: there's your module
17:14:32 <matt__r> sorear: thanks! but i am not sure any of that make sense to me :)
17:15:03 <sorear> you're not alone
17:15:35 <hpaste>  twanvl annotated "can I get a little reflection?" with "Use Enum+Show" at http://kakapo.scannedinavian.com:8000/17#2
17:15:36 <lambdabot> Title: can I get a little reflection? - hpaste
17:15:52 <sorear> 12693 stefan    18   0  309m 297m  68m D 62.3 78.9   0:38.44 darcs
17:16:11 <orbitz> anyone been following fortress development?
17:16:12 <matt__r> twanvl: legend!
17:16:16 <matt__r> twanvl++
17:16:27 <matt__r> orbitz: a little
17:16:39 <twanvl> :)
17:16:48 <matt__r> I noticed there is an alpha-alpha-alpha compiler released
17:17:07 <sorear> swap at 128MB
17:17:19 <orbitz> any ideas on the language?
17:17:21 <sorear> 12693 stefan    18   0  478m 339m  13m D  7.3 90.0   1:08.92 darcs
17:17:22 <matt__r> orbitz: I read the spec and thought - crap, good luck implementing that
17:17:37 <orbitz> it better be incredibly succinct becaue typing it out sound slike hell
17:17:49 <matt__r> orbitz: so I am glad to see them put their money where their mouths are
17:18:09 <matt__r> orbitz: I think it is a nice language filling a needed niche where they will never get any traction
17:18:13 <sorear> oh, the darcspatch is actually growing
17:18:17 <matt__r> orbitz: doesn't interest me though
17:18:23 <sorear> swap at 280MB
17:18:29 <orbitz> i like the idea of parraellism
17:18:32 <sorear> 12693 stefan    18   0  532m 316m  17m D 16.3 83.9   1:21.56 darcs
17:18:41 <matt__r> orbitz: and it will all hinge on the quality of the implmentation (which we are yet to see) :)
17:18:43 <sorear> note that VIRT is twice RSS
17:19:16 <beschmi> sorear: what is your darcs doing?
17:19:38 <sorear> beschmi: sending all 15k GHC patches to an empty repo
17:19:45 <sorear> :)
17:20:17 <beschmi> sorear: using put?
17:20:25 <sorear> beschmi: using send
17:20:42 <sorear> wow, my system is swapping so hard irssi is reporting server lag
17:21:00 <sorear> 12693 stefan    18   0  600m 349m  10m D  0.9 92.5   1:26.06 darcs
17:21:25 <beschmi> i see, seems like nobody made send lazy enough
17:21:46 <Saizan> why are you moving 15k patches?
17:21:53 <allbery_b> *boom*
17:22:02 <sorear> Saizan: it will produce a good distribution format.
17:22:18 <sorear> I want to smash GHC's entire history as much as possible.
17:22:55 * sorear has experience reducing 200MB of irc logs to 38MB using custom preprocessing - gzip could only achieve 65
17:23:14 <sorear> darcs Isn't Dead Yet.
17:25:33 <Botje> sorear: bzip2 isn't half bad either
17:25:44 <Botje> reduced 7G of apache logs to 135 mb for me
17:25:55 <sorear> yeah, I used lzma in the final pass of my custom compressor
17:26:10 <sorear> bzip2 on the preprocessed logs could only achieve 41MB
17:26:17 <sorear> bzip2 on the raw logs could only achieve 50MB
17:26:32 <Botje> nice.
17:26:37 <sorear> but now, swap at 500MB and rising
17:26:41 <beschmi> rzip was much better than bzip2 for me, but it's pretty slow
17:26:55 <Saizan> is there something that will let me browse a .tar.bz2 75mb archieve quite easily, btw?
17:26:59 <Botje> bzip2 is already pretty slow
17:27:08 <sorear> I'll worry about compression *after* I have a patch bundle :)
17:27:16 <beschmi> http://rzip.samba.org
17:27:19 <lambdabot> Title: rzip
17:27:27 <sorear> Saizan: bzip2 is random-access in the large, by virtue of block structure.
17:27:46 <sorear> HOWEVER, tar requires lots o reading.
17:28:03 <sorear> simetihn like 7z is probable a btter bet for bworsing.
17:28:32 <sorear> 12693 stefan    20   0  687m 344m 1332 D 73.6 91.2   1:54.74 darcs
17:28:38 <Saizan> uhm, i see
17:29:07 <sorear> this would probably go a lot faster if I actually *had* 687MB of ram :)
17:29:54 * Saizan 's irc logs will rest unreaded
17:31:04 <sorear> interestingly, darcs is staying above 10% cpu even as >50% of it is swapped out
17:31:27 <sorear> 12693 stefan    18   0  701m 330m  13m R  6.0 87.6   2:07.89 darcs
17:31:32 <sorear> oh 6.0 ...
17:31:44 <sorear> the oom killer is 1300m away
17:32:08 <Saizan> 2G of swap?
17:32:41 <sorear> YEs
17:33:01 <sorear> ok, I guess that means 1600m away
17:33:09 <sorear> 384 m of ram
17:35:31 <slowriot> can anyone link me to something that explains how to do dynamic programming in haskell?
17:35:43 <sorear> what is dynamic programming?
17:35:54 <mauke> massive memoization
17:35:59 <sorear> oh right
17:36:03 <slowriot> yeah
17:36:12 <sorear> @goog Stretching the storage manager
17:36:15 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99stretching.html
17:36:15 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
17:36:30 <sorear> ^^^ paper presents memoization combinator
17:36:58 <slowriot> thanks, I'll take a look.
17:37:47 <mauke> I have a program that uses a fixed array as its cache
17:38:04 <mauke> but thanks to laziness, only the parts that are needed are actually computed :-)
17:38:15 <sorear> oooh, send is 2/3 done
17:38:22 <sorear> stefan@stefans:/usr/local/src/ghcfull$ grep '^}$' ghc/GHC.darcs-patch-0 | wc -l
17:38:51 <sorear> muahahaha
17:39:31 <sorear> when I become a GHC hacker, I will implement {-# MEMOIZE #-}. Easy as pie.
17:39:41 <sorear> (will anyone take it, if I can do it?)
17:40:21 <LoganCapaldo> take it straight to the Bank
17:40:22 <mauke> while you're at it, automemoize polymorphic "constants"
17:40:46 <sorear> good iden
17:42:20 <sorear> 12693 stefan    18   0  776m 347m 4152 R  0.7 92.0   2:14.40 darcs
17:46:22 <sorear> 12693 stefan    18   0  792m 331m 9508 D 12.3 87.8   2:33.64 darcs
17:47:46 <bd_> sorear: I'm not sure MEMOIZE is easily implementable
17:48:10 <sorear> bd_: that's not gonna stop me from trying :)
17:48:19 <bd_> I suppose it could throw a wrapper around, but then why not something like:
17:48:23 <bd_> f = memoize $ \x y -> ...
17:48:38 <bd_> you can probably abuse typeclasses and unsafePerformIO to do that :)
17:48:49 <bd_> [somehow]
17:48:50 <sorear> MEMOIZE can modify the garbage collector. memoize can't.
17:49:04 <bd_> there's already weak references
17:49:17 <bd_> and memoize can alter the GC too ;)
17:49:18 <sorear> bd_: SPJ has written memoY using unsafePointerEq and unsafePerformIO
17:50:03 <bd_> I see.
17:50:33 <bd_> Does it need to be a pragma, and not just a function with special RTS support?
17:51:31 <sorear> Ideally we want to make this function have optimizer support too.
17:51:54 <sorear> I don't like ultra-magical functions like unsafeCoerce#
17:52:18 <sorear> (the only polymorphic "function" that works on unboxed types)
17:52:28 <bd_> well, ultra-magical functions are fine when only used deep within the libraries; What optimizer support would it need that cannot be acheived with a regular function and eg RULES?
17:53:09 <sorear> the ability to remove it when useful ?
17:53:23 <sorear> the point is that semantically it is id.
17:53:33 <bd_> remove the memoization, or remove cached values?
17:53:45 <sorear> pragmas capture that pattern IMO far better than decorators.
17:54:22 <bd_> On the other hand, decorators let you memoize anonymous functions
17:55:28 <sorear> 12693 stefan    18   0  840m 349m  884 D  1.3 92.7   2:49.14 darcs
17:56:54 <SamB> rici: if your computer is borderline swapping, heeding a bit of madvice could help it out!
17:57:35 <rici> SamB: there's no doubt that madvise has it's uses.
17:58:15 <SamB> there should be an madvise variant that takes a block bitmap or something like that
17:58:17 <rici> my only observation is that it is very difficult to figure out when it will actually help, and when it will just bog down your application with too many kernel context switches
17:58:34 <SamB> obviously this int madvise(void *start, size_t length, int advice); variant is too slow
17:58:54 <rici> it can only work at the granularity of vm pages
17:59:02 <SamB> rici: yes
17:59:15 <sorear> obviously this is a problem with the Linux syscall interface.
17:59:17 <rici> and you don't want to split up page table structures
17:59:19 <SamB> but, I mean, you can only pass in one range per double-context-switch
17:59:33 <sorear> I want safe haskell haskell and just calling-into-kernel.
17:59:35 <rici> the page tables rapidly get out of hand
17:59:38 <SamB> the problem being that this requires contiguity
17:59:50 <rici> yes, and so do keeping efficient page tables
18:00:01 <SamB> oh?
18:00:23 <SamB> I didn't think pages were defragged at all in kernelspace
18:00:24 <rici> contiguous ones take up a lot less memory -- and that's locked kernel memory
18:00:42 <rici> yes, the kernel has some fairly complex datastructures to maintain page tables
18:00:47 <sorear> my disk light just flashed black for a second!
18:00:49 <brainly-green> I'm trying to understand monads and this sentence is confusing me:  "
18:00:59 <sorear> 12693 stefan    21   0  891m 345m 1324 R 86.6 91.4   2:54.73 darcs
18:01:22 <brainly-green> "We now must work out how to compose two randomised functions, f and g. The first element of the pair that f returns needs to be passed in as an input to g. But the seed returned from the g also needs to be passed in to f."   from sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html about 2/5 down the page
18:01:27 <sorear> 891 is VM, 345 is RAM
18:01:45 <sorear> brainly-green: don't paste stuuff that long. It just gets truncated server-side
18:02:12 <brainly-green> how can a return value from f be passed as an input to g, while at the same time a return value of g also needs to be passed to f?
18:02:27 <brainly-green> sorear where did it cut off?
18:03:07 <brainly-green> ah is there a separate splace to post stuff like that for this forum?
18:04:36 <sorear> brainly-green: it ended: "down the page"
18:04:44 <brainly-green> that's all I wrote
18:04:51 <sorear> good
18:05:02 <sorear> alot of people write more than your
18:05:24 <sorear> the limit is 510 chars after command formatting btw
18:05:36 <allbery_b> @paste
18:05:37 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
18:05:47 <allbery_b> ^^ preferred way to deal with large amounts of text
18:05:59 <sorear> 12693 stefan    18   0  912m 343m  14m R  3.0 90.9   3:21.66 darcs
18:06:02 <mauke> brainly-green: yeah, it doesn't make sense
18:06:40 <brainly-green> I think they switched f and g in one of the sentences
18:06:45 <brainly-green> ok
18:07:00 <sorear> brainly-green: it's perfectly reasonable.
18:07:20 <sorear> dpiponi is using the backward state monad in that sentence.
18:07:43 <sorear> not that the backward state monad is anything less then extremely obscure...
18:07:57 <mauke> how is it backward?
18:08:47 <brainly-green> I don't understand their type signature for bind on that one either
18:09:02 <sorear> mauke: effects precede causes
18:09:23 <brainly-green> it looks like it should take 2 arguments but in the function definition it takes 3, probably just my insufficient knowledge of haskell but what's going on?
18:10:13 <mauke> brainly-green: that's just a side effect of currying
18:10:39 <mauke> a function of 2 arguments is really just a function (of 1 argument) returning a function (of 1 argument)
18:11:06 <brainly-green> yes but in the function definition it looks like it takes 3 arguments, f, x, and seed
18:11:30 <mauke> bind :: ... -> (StdGen -> (b,StdGen))
18:11:43 <mauke> "seed" is the StdGen
18:12:24 <brainly-green> oh, because -> is right associative?  (is it?)
18:12:34 <mauke> yes
18:12:37 <brainly-green> ok
18:12:58 <mauke> (++) :: [a] -> ([a] -> [a])
18:15:46 <chessguy> hi haskellers
18:16:06 <sorear> hi chessguy
18:16:11 <syntaxfree> hi chessguy.
18:16:31 <chessguy> all together now :)
18:16:53 <bd_> @quote stereo
18:16:54 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:16:57 * syntaxfree randomly mentions we have #haskell.br now for brazilians.
18:17:59 <glguy> brazillians of what?
18:18:02 <glguy> that sounds like a lot
18:19:02 <sorear> syntaxfree: +s is the channel mode that causes anyone not in the channel, to see the channel as empty
18:19:21 <sorear> (which is either still set or the channel is empty)
18:19:54 <syntaxfree> sorear: hmm.
18:20:01 <syntaxfree> I wonder if I'm still an op there.
18:20:14 <syntaxfree> well, I'm not.
18:20:22 <Saizan> i think sigfpe has a type there, his solution is very straghtforward and doesn't correspond to that passage: bind f x seed = let (x',seed') = x seed in f x' seed'
18:20:23 <syntaxfree> I also haven't registered it./
18:20:27 <syntaxfree> so I don't know what to do.
18:21:35 <syntaxfree> bah, I can't seem to gain ops by leaving an joining.
18:21:51 <sorear> (runnning /msg chanserv help register) it looks like you don't need to be an op to register, and then you can op yourself
18:22:59 <syntaxfree> I didn't really want to register and having to deal with administration and the implicit accusations of trying to build up something for myself.
18:23:02 <sorear> 12693 stefan    18   0 1001m 340m 6280 D  1.9 90.2   3:36.87 darcs
18:23:10 <syntaxfree> I've opped channels before. Not pleasant.
18:24:45 <sorear> 12693 stefan    18   0  952m 332m 1736 D  1.3 88.0   4:06.82 darcs
18:24:52 <sorear> wow, it freed memory
18:26:00 <bd_> hmm, bytestrings being freed?
18:26:45 <sorear> anyway, 15k patches, so <1k left to send
18:27:20 <sorear> 12693 stefan    18   0 1016m 347m  12m D  3.7 92.0   4:12.42 darcs
18:28:01 <glguy> what is the longest nick that freenode allows?
18:28:18 <allbery_b> 15 I think
18:28:29 <asdfghjklqwertyu> This long.
18:28:37 <glguy> bugger
18:28:39 <bd_> > length "asdfghjklqwertyu"
18:28:40 <lambdabot>  16
18:28:48 <glguy> > replicate 16 "M"
18:28:50 <lambdabot>  ["M","M","M","M","M","M","M","M","M","M","M","M","M","M","M","M"]
18:28:58 <glguy> > replicate 16 'M'
18:28:59 <lambdabot>  "MMMMMMMMMMMMMMMM"
18:29:07 <glguy> that nick takes up a lot of space...
18:30:11 <brainly-green> ok I still don't understand what that bind function I was talking about does
18:30:26 <brainly-green> I don't understand the paragraph explaining it is my problem
18:31:01 <brainly-green> what does the backward state monad do?
18:31:24 <sorear> olegy stuff :)
18:31:38 <sorear> seriously:
18:32:07 <sorear> runBackward (do { x <- get ; put (1:x) ; return x })  -->  [1,1,1,1,1,...]
18:32:10 <allbery_b> you can only op yourself if you have been given access
18:32:21 * allbery_b has that access elsewhere, but not here
18:32:31 <sorear> can you give yourself access?
18:32:33 <mauke> brainly-green: I don't think this has anything to do with backward state
18:32:40 <sorear> (if you registered the chan)
18:32:47 <mauke> it's just an ordinary state monad
18:32:55 <allbery_b> no, I think someone has to be registered with freenode as a channel admin, then they can deligate to registered nicks
18:33:14 <sorear> we're talking about syntaxfree , correct?
18:33:15 <allbery_b> or possibly if you were the one registering the chan, yeh
18:33:21 <brainly-green> well mauke then what does it mean when it says f's output is g's input and g's output is f's input?
18:33:30 * allbery_b hasn't looked closely, doesn't plan to make any use of it :)
18:33:31 <brainly-green> is that a typo as I thought at first?
18:33:46 * allbery_b was just scanning back, yeh
18:33:54 <mauke> brainly-green: yes, probably
18:34:02 <sorear> he's already the most (only?) visible .br haskeller, he shouldn't be worried about percieved visibility grab
18:35:21 <xpika> does greencard come with ghci?
18:35:31 <sjanssen> no
18:35:38 <sorear> 12693 stefan    18   0 1016m 348m  20m D  0.2 92.3   4:24.75 darcs
18:36:54 <sjanssen> sorear: alas
18:37:00 <sjanssen> that happens on occasion
18:39:29 <sorear> sjanssen: what are you referring to?
18:39:50 <sjanssen> sorear: darcs eating memory and time
18:40:15 <sorear> sjanssen: you see it is using 3x physical memory :)
18:40:38 <sorear> sjanssen: seriously, most people don't try to send the entire history of GHC in a single bundle
18:42:29 <sorear> 12693 stefan    18   0  975m 347m 5884 D  3.5 91.9   5:00.08 darcs
18:48:25 <dpiponi> I just spotted someone talking about f and g in "You could have..."
18:48:34 <dpiponi> There may be an f &g swapper round.
18:48:41 <dpiponi> s/swapper/swapped/
18:49:14 <dpiponi> I keep meaning to fix it...
18:49:39 <allbery_b> yeh, as written it's a bit confusing.  I got the idea, but then I'd already pretty much gotten the idea anyway :)
18:50:00 <brainly-green> ok thanks i think i'm getting it now
18:50:16 <dpiponi> Recently my policy is to write literate Haskell so I know the code actually works :-)
18:51:02 <allbery_b> wouldn't have helped here since it was the descrption, not the code, that was confusing
18:51:13 <sorear> 12693 stefan    18   0 1103m 349m  12m D  1.0 92.5   5:09.92 darcs
18:51:21 <allbery_b> (describing bind for the random monad)
18:51:35 <dpiponi> True. But at least you'd be confident the code worked.
18:52:06 <dpiponi> I'll see about fixing it soon.
18:52:13 <sorear> so I was completely wrong about you inflicting the backward state monad on unsuspecting newbies, good.
18:52:43 <dpiponi> I've been trying to think up some fiendish application for the backward monad. Ain't come up with one yet.
18:52:45 <sorear> it was actually just discussed here
18:54:08 <HairyDude> is there a MaybeT in mtl?
18:54:37 <brainly-green> argh no it did not really explain anything
18:54:53 <bd_> HairyDude: No, but if you ask me there should be :)
18:55:02 <brainly-green> I mean that website didn't
18:55:20 <bd_> HairyDude: You can emulate it with ErrorT (), defining a suitable instance of Error ()
18:55:26 <brainly-green> I am trying to find out how IO can be done in a pure functional language, this just skipped over it, saying IO is a "black box"
18:55:29 <HairyDude> interesting
18:55:34 <bd_> HairyDude: and an appropriate MonadPlus too I guess
18:55:44 <allbery_b> @google haskell io inside
18:55:44 <bd_> ... actually you might as well just define MaybeT at that point
18:55:46 <lambdabot> http://haskell.org/haskellwiki/IO_inside
18:55:46 <lambdabot> Title: IO inside - HaskellWiki
18:55:49 <HairyDude> would be easier to write the MaybeT directly surely ;)
18:56:01 <bd_> :)
18:56:28 <allbery_b> brainly-green: see above.  "IO Inside" will take you from monads to how monads make IO work
18:56:46 <HairyDude> I could have asked "is there an IOT" instead but I already know there isn't, presumably for good reasons.
18:56:51 <allbery_b> (and reveal that IO is not quite as mystical as it seems)
18:57:42 <bd_> HairyDude: newtype IOT m a = IOT (m a) deriving (Monad); instance Monad m => MonadIO (IOT m) where liftIO m = return $! unsafePerformIO m ;)
18:58:04 <bd_> [note: extremely dangerous]
18:58:11 <HairyDude> yes, looks dangerous :)
18:58:19 <HairyDude> it even says "unsafe" right there ;)
18:58:20 * allbery_b was pleased to note that he'd already actually worked out the basics of it by the time he got there, in particular suspecting partial application was involved)
18:58:28 <sorear> 12693 stefan    18   0 1063m 349m 7292 D  5.3 92.5   5:26.93 darcs
18:58:54 <HairyDude> deriving Monad?
18:59:10 <bd_> HairyDude: GHC extension, generalized newtype deriving
18:59:30 <HairyDude> ah, that's rather cool
18:59:39 <bd_> Works on any typeclass :)
19:02:01 <syntaxfree> http://www.lylo.co.uk/blog/2007/01/20/peak-java/
19:02:03 <lambdabot> Title: The Lylo Files » Blog Archive » Peak Java
19:04:42 <sorear> !whatsnew
19:04:54 <HairyDude> hmm, strafunski provides a MaybeT, but that's not in the edgy repos it seems
19:05:28 <brainly-green> ok thanks albery_b, so in concept it passes the entire world as an argument to the IO
19:05:38 <sorear> No remote changes to pull in!
19:06:20 <sorear> !whatsnew
19:06:22 <brainly-green> actually though is there any reason to pass the entire world?  why not simply pass the current time--the function would still be 1 to 1
19:06:25 <allbery_b> that's oen way to look at it
19:06:50 <allbery_b> another way to look at it is it passes a sequence number which starts at 0 and is incremented in each I-performing function
19:06:54 <allbery_b> IO-pperforming
19:06:57 <allbery_b> gah.
19:07:02 * allbery_b fwaps finfers
19:07:28 <sorear> another way is to consider IO actions to produce decision trees
19:07:43 <allbery_b> ...except it starts out as a lazily indeterminate value
19:07:49 <sorear> data IOTree = Getc (Char -> IOTree) | Putc Char IOTree
19:08:01 <allbery_b> and therefore all IO functions result in a chain of partial applications
19:08:14 <sorear> type IO = Cont IOTree
19:08:53 <brainly-green> what sorear... I do not understand that
19:08:58 <HairyDude> hmm, I can see that type synonym causing rather confusing error messages
19:09:54 <brainly-green> ah wait a minute if you think of it as passing the world, what about the fact that the world changes inb etween two calls to I/O
19:09:57 <brainly-green> independently of the program
19:10:06 <sorear> putch ch = Cont $ \c -> Putc ch (c ())
19:10:06 <sorear> getch = Cont $ \c -> Getc c
19:10:06 <sorear> do you know the cont-monad?
19:10:06 <sorear> darcs is doen
19:10:17 <brainly-green> so the world returned by one call to I/O is not the same world that you pass to the next call
19:10:23 <allbery_b> brainly-green: it doesn't matter since you can't look at it anyway :)
19:10:59 <sorear> only I can see the world!
19:11:12 <glguy> when i close *my* eyes the world disappears
19:11:18 <sorear> and where there is no IO there is no I
19:11:45 <allbery_b> the sequence-bunber view gives you a "relative generation" of the "world".  you don't really care what else happens in the world since the only part you can observe is that which you actually operate on
19:12:22 <allbery_b> ("bunber".  I'm really with it with the fingers tonight...)
19:12:50 <brainly-green> you could stipulate that the world returned by each call to I/O is the world that WILL be present during the next call to I/O
19:13:20 <bd_> brainly-green: yes, but each call to IO advances the state of the world forward by an amount of time determined by some oracle :)
19:13:50 <brainly-green> ah but it really doesn't matter so long as the arguments to the I/O functions are always different, then they can be 1-1
19:13:51 <HairyDude> all this talk of passing the world around is rather amusing
19:14:01 <allbery_b> yeh
19:14:05 <HairyDude> if the process is suspended, did you just save the world?
19:14:12 <allbery_b> neat concept, unrel;ated to reality in any fashion :)
19:14:20 <bd_> actually, is this in fact pure? with f :: Int -> IO (World -> (World, ())), if we invoke (f $ 1 + 1) vs (f 1), it should advance the world a different amount of time :)
19:14:27 <sorear> destroyTheWorld :: World# -> ()
19:14:36 <brainly-green> well I dont mean 1-1, I mean well-defined
19:14:42 <bd_> er, (f 2)
19:15:00 <bd_> I suppose you could decorate all values with their computational time requirements though
19:15:18 <bd_> so eg data Int = I#  { value :: Int#, ticksToCompute :: Int# } ...
19:15:41 <bd_> but that means memoisation is impure ;_)
19:15:42 <bd_> ;)*
19:16:08 <allbery_b> many memoization schemes do involve unsafePerformIO :)
19:16:42 <bd_> I refer to this kind of memoisation: y = let x = someHairyExpression in (x, x) -- now force both fst y and snd y
19:18:05 <rici> yeah, a truly pure implementation would go off and get itself a cup of coffee while pretending to evaluate y the second time, just so you couldn't observe the difference :)
19:19:16 <bd_> A truly pure implementation would compute pure values outside of time ;)
19:22:07 <allbery_b> ...so only G-d can write truly pure programs?
19:24:10 <Adamant> I don't know about this G-d fellow, but maybe God could
19:25:57 <sorear> anyone can write pure programs, but only God(s) can run them.
19:26:07 <sorear> wow
19:26:46 <sorear> the entire history of ghc-head, with extralibs, 7zipped, is a third the size of the gzipped ghc-6.6 binary package.
19:27:15 <sorear> -rw-r--r--  1 stefan src  28M Jan 20 19:20 ghcfull.7z
19:27:29 <wolverian> gzip is meant to be fast, not particularly efficient
19:27:36 <Philippa> a truly pure implementation's easy
19:27:39 <Adamant> what about bzip2?
19:27:40 <Philippa> it's just hard to use
19:27:47 <wolverian> bzip2 would be a more sensible comparison, yes.
19:28:07 <sorear> Adamant: I'm more complaining about the size of ghc compiled programs. :)
19:28:15 <sorear> anyway, Debian forces gzip on me.
19:28:31 <Philippa> sorear: have you bothered stripping them?
19:28:50 <sorear> Philippa: Debian policy says they were already stripped.
19:29:15 <allbery_b> isn't the real problem with ghc-compled programs that they link the runtime statically?
19:29:37 <allbery_b> (which HEAD is working on changing)
19:29:38 <sorear> allbery_b: that is the major factor, but it isn't the "real problem"
19:29:56 <sorear> I have no reason to want dynamic linking.
19:30:02 <sorear> I do want small binaries.
19:30:22 <sorear> Fixing the first non-problem is the best way to fix the second yes-problem.
19:30:32 <glguy> any CSS wizards went to tell me what I need to do to get all of the titles line up on
19:30:34 <augustss> I hate dynamic linking.  I love small binaries.
19:30:34 <glguy> !paste
19:30:35 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
19:30:48 <sorear> hpaste: !whatsnew
19:30:55 <jcreigh> glguy: use a table?
19:31:02 <jcreigh> glguy: ...but I guess that's out. :)
19:31:21 <glguy> last resort.. breaks my clickable rows :(
19:31:36 <glguy> that highlight the whole thing when you hover
19:32:06 <sorear> @tell musasabi after 2.5 hours of thrashing, darcs send and 7zip have smashed the entire history of ghc+extralibs into 28Mib
19:32:06 <lambdabot> Consider it noted.
19:32:19 <sorear> 5 mins cpu time :)
19:32:47 <glguy> sorear: new stuff since last time i having the "ago" value listed on the front page
19:33:07 <glguy> (Had to take a break and take the fiancee out to a restaurant)
19:33:28 <sorear> @seen stepcut
19:33:28 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 21h 3m 41s ago.
19:36:38 <HairyDude> hmm, I have newtype Monad m => MaybeT m a = <stuff> and deriving a Monad instance for MaybeT m without putting "Monad m =>" at the top gives me an error, even though hugs should already know that m is a monad
19:36:56 <HairyDude> s/deriving/defining/
19:39:11 <sjanssen> HairyDude: class constraints in type declarations doesn't do what you'd expect
19:39:21 <HairyDude> what does it do then?
19:40:00 <sjanssen> it add a class constraint to the constructor
19:40:43 <glguy> @whatsnew
19:40:44 <lambdabot> Unknown command, try @list
19:40:47 <HairyDude> so it says that m must be a monad?
19:40:57 <sorear> glguy: lambdabot?
19:40:57 <sjanssen> so in "data (Ord a) => Wrap a = Wrap a", Wrap :: (Ord a) => a -> Wrap a
19:41:12 <glguy> sorear: You'd typed that in a couple of times, I wondered if lambdabot had one :)
19:41:18 <sjanssen> HairyDude: it says that m must be a monad when the MaybeT is constructed
19:41:32 <jcreigh> glguy: well, if it comes to that, you can use javascript to make the rows clickable...(a kludge, I know...)
19:41:44 <glguy> jcreigh: I know there is a way to do this
19:41:47 <glguy> jcreigh: I've done it before
19:41:57 <glguy> jcreigh: but the method is evading me at the moment :)
19:41:59 <sorear> I'm just really over-eager with hpaste, and chessguy only pushes daily...
19:42:02 <HairyDude> can hugs not then infer that if we have an expression Wrap a, then a has to be in Ord or it doesn't type check?
19:42:21 <glguy> sorear: what features are you eagerly anticipating?
19:42:32 <HairyDude> type expression I mean
19:43:03 <sjanssen> HairyDude: you have to write the constraint in the type signature if you use a function in that class
19:43:19 <sorear> oh wait.  was it chessguy or glguy who wrote hpaste?
19:43:27 * sorear is extremely embarassed
19:43:35 <allbery_b> glguy
19:43:43 <glguy> sorear: ?
19:43:43 <allbery_b> heh
20:05:25 <glguy> ?seen bringert
20:05:26 <lambdabot> I saw bringert leaving #haskell 1d 4h 19m 8s ago, and .
20:13:49 <sorear> @where haddock
20:13:50 <lambdabot> http://www.haskell.org/haddock/
20:14:22 <sorear> !whatsnew
20:14:25 <sorear>  :)
20:14:58 <xpika> !obliterate
20:15:24 <sorear> !id, !quit, and !paste are known to exist.
20:15:50 <brainly-green> h\
20:16:18 <xpika>  haskell is needed by greencard-2.05-1.i386 :(
20:16:33 <xpika> i already have the rpm for 6.4
20:18:42 <allbery_b> !wazzaaaap? -- :)
20:18:42 <glguy> lol, it's not hard to determine what commands exist (the source is public)
20:18:47 <glguy> the working copy of the source is public
20:19:06 <glguy> You can go to the source directory and see things as I save then
20:19:08 <glguy> them*
20:19:20 <sorear> oh
20:19:35 * sorear assumed I'd only see things after record;push
20:19:47 <glguy> you can only darcs pull after I recor
20:19:49 <glguy> record
20:19:58 <glguy> but what you see in that directory is what I'm doing right now
20:20:25 <augustss> :wazzap
20:20:33 <augustss> :t 5
20:20:35 <lambdabot> forall t. (Num t) => t
20:20:50 <augustss> interesting
20:20:52 <sorear> hehehe
20:21:09 <sorear> I see you too have compiled the setup script :)
20:21:12 <sorear> compiling too slow?
20:21:19 <glguy> ?
20:21:36 <sorear>  [   ] Setup.hi                19-Jan-2007 15:48  304
20:21:49 <glguy> oh, yeah... I did ghc--make Setup
20:22:42 <sorear> I did that in lb-sorear so I wouldn't have to wait 0.6 seconds for runghc Setup.hs :)
20:23:06 <glguy> there is a cpu time limit
20:23:12 <glguy> so every second counts
20:23:39 <sorear> cpu time limit - cumulative?
20:23:57 <sorear> like 10mins cpu/day
20:24:11 <glguy> no...
20:24:19 <glguy> seems like if you use a lot at once it kills you
20:24:26 <glguy> have to ask shapr
20:25:46 <HairyDude> hmm there seems to be no untilM
20:26:03 <allbery_b> @ty until
20:26:03 <sorear> alas :(
20:26:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
20:26:14 <sorear> @src until
20:26:15 <lambdabot> until p f x | p x       = x
20:26:15 <lambdabot>             | otherwise = until p f (f x)
20:26:20 <allbery_b> was thinking of somrthing else nm
20:26:22 <sorear> @index until
20:26:23 <lambdabot> Prelude
20:26:33 <sorear> wow, I never noticed that function
20:26:39 <glguy> ?type while
20:26:40 <lambdabot> Not in scope: `while'
20:26:44 <glguy> hmm
20:26:54 * glguy had forgotten about until
20:27:04 <HairyDude> you could do while by just while p = until (not p)
20:27:09 <sorear> > until (> 10000) (^2) 3
20:27:10 <lambdabot>  43046721
20:28:46 <glguy> ?index until
20:28:47 <lambdabot> Prelude
20:29:40 <allbery_b> (fmap .) . until -- ?
20:30:10 <glguy> and all this time we have been writing takeWhile x . iterate f
20:30:23 <glguy> and that isn't related
20:30:24 <glguy> directly
20:30:26 <glguy> so nevermind
20:30:48 <sorear> hoogle++
20:30:52 <sorear> hoogle--
20:30:55 <sorear> haddock++
20:30:58 <SamB> whoa
20:31:07 <SamB> @hoogle while
20:31:07 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
20:31:08 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
20:31:08 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
20:31:14 <sorear> SamB: aohw?
20:31:28 <SamB> @hoogle (a -> Bool) -> (a -> a) -> a -> a
20:31:29 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
20:31:36 <SamB> why is there no "while"?
20:31:45 <SamB> I guess that would be until . not
20:31:48 <augustss> @hoogle until
20:31:48 <glguy> ?fptools until
20:31:49 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
20:31:50 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
20:31:50 <lambdabot> until not available
20:31:53 <SamB> er. no
20:31:58 <bd_> @check (\condition f init -> (until condition f init) == (takeWhile (not . condition) $ iterate f init)) :: (Int -> Bool) -> (Int -> Int) -> Int -> Bool
20:31:59 <lambdabot>  Couldn't match `Int' against `[Int]'
20:32:04 <SamB> @pl (\f -> until (not . f)
20:32:05 <lambdabot> (line 1, column 23):
20:32:05 <lambdabot> unexpected end of input
20:32:05 <lambdabot> expecting variable, "(", operator or ")"
20:32:08 <SamB> @pl (\f -> until (not . f))
20:32:09 <lambdabot> until . (not .)
20:32:10 <glguy> (until .) . not
20:32:15 <glguy> ah
20:32:22 <chessguy> sorear, i haven't written anything very sophisticated in haskell, certainly not at the level of a pastebin
20:32:25 <SamB> @type (until .) . not
20:32:27 <lambdabot>     Couldn't match `a1 -> a -> Bool' against `Bool'
20:32:27 <lambdabot>       Expected type: Bool -> a1 -> a -> Bool
20:32:40 <SamB> glguy: not . quite
20:32:41 <glguy> chessguy: the paste bin isn't that complicated, see for yourself
20:32:47 <chessguy> ?src until
20:32:47 <glguy> SamB: :-p
20:32:47 <lambdabot> until p f x | p x       = x
20:32:48 <lambdabot>             | otherwise = until p f (f x)
20:32:56 <bd_> oh, ic
20:33:02 <augustss> > until (> 5) (+1) 3
20:33:04 <lambdabot>  6
20:33:15 <chessguy> oh, it's like iterate with an endpoint
20:33:22 <glguy> without a history
20:33:27 <chessguy> well, yes
20:33:32 * allbery_b was thinking "fix with an endpoint"
20:33:39 * glguy ==allbery_b 
20:34:16 <sjanssen> No instance for (Eq Person)
20:34:28 <augustss> and what would the endpoint test be?
20:34:29 <allbery_b> heh
20:34:30 <glguy> allbery_b knows what I meant
20:34:33 <glguy> :)
20:34:34 <blackdog> sjanssen: deep :)
20:34:39 <allbery_b> "agrees with"
20:34:46 <sorear> sjanssen: Bools in channel are axioms, not questions
20:35:34 <augustss> > 1==2
20:35:35 <lambdabot>  False
20:35:47 <augustss> 1==2
20:35:49 <sorear> (unless preceeded with >)
20:35:51 <SamB> lambdabot /= sorear
20:36:12 <chessguy> glguy, i still can't fully fathom the code for dons' simple bot tutorial
20:36:12 <lambdabot> True
20:36:19 <SamB> isCrazy sorear
20:36:27 <SamB> how is that for an axiom?
20:36:27 <lambdabot> False
20:36:30 <lambdabot> True
20:36:32 <chessguy> much less a useful program
20:36:32 <lambdabot> False
20:36:33 <lambdabot> Tru
20:36:45 <SamB> sorear: quit playing with @msg
20:36:53 <augustss> I think one should be careful not confusing decidable equality (==) with other equalities
20:38:11 <augustss> we need more equality symbols!
20:38:50 <bd_> id =?= not . not
20:39:40 <sorear> that's id|Bool
20:39:48 <augustss> (let xs = 1:xs) ==== (let ys=1:1:ys)
20:40:17 <SamB> augustss: how are those the same?
20:40:31 <augustss> denotationall, yes
20:40:33 <SamB> they don't bind the same variable, and they also haven't got "in"s
20:40:38 <augustss> sorry
20:40:56 <augustss> (let xs = 1:xs in xs) ==== (let ys=1:1:ys in ys)
20:41:03 <SamB> that is much better ;-)
20:41:15 <augustss> it's the bottle of wine :)
20:42:16 <sorear> @users
20:42:17 <lambdabot> Maximum users seen in #haskell: 311, currently: 274 (88.1%), active: 29 (10.6%)
20:43:23 <augustss> The = symbol must be the most abused one in programming language history. :)
20:43:56 <glguy> it doesn't mean double bond?
20:43:57 * sorear beats up =
20:44:25 <allbery_b> @slap =
20:44:26 * lambdabot beats up =
20:44:29 * augustss kicks =
20:44:47 * blackdog negates =
20:44:59 <augustss> cruel!
20:45:01 * sorear fromEnums =
20:45:38 <JKnecht> but := is the right semiotics being an 'ideograph' (notice the balls)
20:45:48 <sjanssen> @slap =
20:45:48 * lambdabot beats up =
20:45:49 <augustss> Haskell is unusually nice to =
20:46:12 <emk> Yay! GSL Haskell now builds on my OS X laptop.
20:46:23 <blackdog> GSL?
20:46:25 <emk> Matrixy goodness. :-)
20:46:33 <blackdog> ok
20:46:39 <augustss> GSL = Gwasgol?
20:46:48 <emk> GNU Scientific Library. GSL Haskell includes interfaces for BLAS, LAPACK, etc.
20:47:14 <augustss> ah, yes
20:47:35 <collins> Can you refer to a type constructor in a pattern without naming the type constructor explicitly?
20:47:37 <JKnecht> @hoogle gsl haskell
20:47:38 <lambdabot> Did you mean: Gsl Haskell
20:47:38 <lambdabot> Prelude.undefined :: a
20:47:38 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
20:47:46 <augustss> i checked it out once.  it looked like it needed an additional layer to make it nice and functional
20:48:14 <augustss> collins: no
20:48:21 <collins> Thanks.
20:48:43 <emk> augustss: The version I'm looking at seems fairly functional, though taste may vary, and I haven't gotten into the details yet.
20:50:01 <augustss> emk: it may have improved
20:50:57 * augustss would like a good NAG interface
20:54:50 <emk> augustss: NAG?
20:55:43 <augustss> NAG is the standard numerical library, even if you have to pay a little for it
20:57:00 <emk> Oh, OK. I did most of my numerics as a undergrad, where it was pretty much assumed that GNU Octave was all we were getting, unless somebody splurged for a MATLAB license. :-)
20:58:27 * allbery_b has matlab available, and no clue what he would do with it :)
20:58:42 <SamB> allbery_b: take it out and shoot it?
20:58:54 <allbery_b> (except try to make sure it works when the students need it...)
21:01:15 <sorear> stepcut: ping?  what symbols are 'exported' from haskell-xmpp
21:01:54 <collins> OK.   So, if I have a T with constructors X and Y, and a function f  :: T -> T that just calls another function g on the arguments to the type constructors
21:02:06 <augustss> emk: nag.com
21:02:23 <collins> there is no way to avoid defining f in two almost identical lines, e.g.
21:02:33 <sorear> collins: gmap ?
21:02:38 <collins> f (X z) = X (g z)
21:02:45 <collins> f (Y z) = Y (g z)
21:02:47 <sorear> collins: gmap
21:02:51 <bd_> :t gmap
21:02:53 <lambdabot> Not in scope: `gmap'
21:02:57 <collins> just a sec
21:03:13 <SamB> sorear: wouldn't it be easier to just use the normal way?
21:03:15 <sorear> @index Data b =>(Typeable a => a -> a) -> b -> b
21:03:16 <lambdabot> bzzt
21:03:18 <collins> Yeah, I also get "Not in scope"
21:03:20 <augustss> collins: there's no avoiding that, barring some kind of generics
21:03:21 <sorear> @hoogle Data b =>(Typeable a => a -> a) -> b -> b
21:03:22 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/Parser.hs:123:17-29: Irrefutable pattern failed for pattern (a, [])
21:03:22 <lambdabot>  
21:03:25 <bd_> collins: wrt referring to the constructor without naming it, you could use a field
21:03:44 <bd_> collins: data T = X { field :: U } | Y { field :: U }
21:03:59 <bd_> well, you can't rebuild the constructor that way though
21:04:08 <sorear> the generics stuff is designed for datatypes with lots of constructors and awkward code duplication
21:04:14 <augustss> collins: It's a bit of a weird type that has two constructors that have the same argument
21:04:17 <sorear> it really is overkill for your example
21:04:33 <sorear> but I'm sure your example is a gross simplification
21:04:52 <sorear> if your two constructors have semantically identical args, use a Bool instead
21:04:55 <collins> augustss: the example is Peano arithmatic
21:05:06 <augustss> collins: Perhaps: data XY = X | Y; type T = (XY, U)
21:05:21 <collins> data P = Zero | Pred P | Succ P
21:05:39 <augustss> collins: That's not Peano arithmetic
21:05:44 <sorear> collins: Peano is naturals only, you can drop Pred
21:05:59 <collins> I was writing a simplify function that successivly collapses adjacent Pred Succ.
21:06:29 <augustss> collins: Why pick Pred?  Why not Mul? Or some other function?
21:06:34 <collins> Oh, sorry.
21:06:51 <collins> That is what I was doing though.  Not sure what to call it then.
21:07:11 <augustss> collins: Perhaps Pred should not be a constructor at all
21:07:22 <sorear> any time you have nontrivial constraints on your types (e.g no uses of Pred), you are wasting what the typesystem is giving you.
21:08:03 <collins> augustss: yeah, that seems better.
21:09:13 <augustss> collins: But if you were representing, e.g., abstract synyax trees you'd want Succ and Pred.  And then you'd have to use the same(?) RHS for Pred and Succ in some cases
21:09:29 <augustss> Haskell doesn't have OR patterns
21:09:47 <sorear> ASTs are the motivating case for Data.Generics.
21:10:30 <augustss> And even without Data.Generics, you can define a reusable recursion operator yourself.
21:25:13 <augustss> @quote
21:25:14 <lambdabot> DAP says: DAP - Download Accelerator Pro
21:25:31 <augustss> @quote
21:25:32 <lambdabot> metaperl says: Haskell is like the lady who never gets married because there is something wrong with every potential suitor
21:27:24 <augustss> @quote
21:27:24 <lambdabot> Makali says: Whenever a programmer thinks, "Hey, skins, what a cool idea", their computer's speakers should create some sort of cock-shaped soundwave and plunge it repeatedly through their skulls.
21:27:51 <sorear> @quote
21:27:51 <lambdabot> nmessenger says: EVERYONE ADMIRE MY ELDERBY HAT!!
21:29:02 <merus> Heh.
21:30:34 <augustss> elderberry
21:31:30 <Adamant> @quote quote
21:31:31 <lambdabot> dons says: boegel, stop polluting the quote-space please
21:31:51 <merus> Hahahah.
21:31:55 <collins> Thanks for the help.
21:31:59 <collins> Good night.
21:32:04 <augustss> nite
21:32:11 <augustss> quote night
21:32:17 <augustss> @quote night
21:32:18 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
21:32:19 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
21:32:19 <lambdabot> he was one of the pugs de
21:39:54 <SamB> @quote
21:39:55 <lambdabot> EvilRanter says: I went off scheme, because the fundemental keywords of the language had stupid names
21:39:59 <SamB> @quote
21:40:00 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
21:40:09 <SamB> @quote break
21:40:09 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
21:40:12 <SamB> @quote break
21:40:12 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
21:40:18 <SamB> hah
21:40:20 <SamB> @quote break
21:40:22 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
21:40:27 <SamB> @quote break
21:40:28 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
21:40:30 <SamB> @quote break
21:40:31 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
21:40:41 <SamB> whoa
21:40:45 <SamB> BSOD on TV?
21:40:50 <SamB> @quote break
21:40:50 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
21:40:59 <SamB> @quote
21:41:02 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
21:41:07 <SamB> @quote
21:41:08 <lambdabot> matthew-_ says: wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
21:41:15 <sorear> emertens!?
21:41:24 <SamB> @quote
21:41:25 <lambdabot> u221e says: I swear, reading Haskell source code is like trying to read a Chinese newspaper
21:41:28 <sorear> is there another one, or is that an email quote?
21:41:37 <SamB> sorear: I have no idea!
21:41:38 <SamB> @quote
21:41:39 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
21:41:45 <SamB> @quote
21:41:46 <lambdabot> Heffalump says: CPP leads to suffering
21:41:52 <blackdog> anyone else find that they write Haskell backwards?
21:42:05 <blackdog> sometimes i'm tempted to start using irish composition...
21:42:05 <SamB> Lleksah? no.
21:42:11 <sorear> SamB: The emertens I know of goes by glguy or Eric Mertens, never emertens.
21:42:12 <SamB> I never write that.
21:42:12 <blackdog> Smartarse. :)
21:42:28 <SamB> glguy: was that you?
21:42:28 <sorear> blackdog: you mean (>>>)
21:42:29 <glguy> sorear: yeah, that was an experiment
21:42:35 <blackdog> but you know - write a chunk of code, whack a $ in front, then write another chunk...
21:42:37 <glguy> SamB: I was emertens
21:42:40 <SamB> okay
21:42:42 <SamB> @quote
21:42:43 <lambdabot> you'll says: probably still want unsafeEquality or whatever, though
21:42:48 <sorear> blackdog: yeah I do that...
21:43:00 <sorear> hello, SyntaxNinja
21:43:03 * allbery_b prototypes like that, yeh
21:43:03 <SamB> @quote
21:43:04 <lambdabot> ghc says: Bindings in hs-boot files are not allowed
21:43:10 <SamB> @quote
21:43:11 <blackdog> Isaac! How're you doing, dude?
21:43:11 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
21:43:17 * glguy was on irc as emertens for a couple days
21:43:28 <SamB> @quote
21:43:29 <lambdabot> sudo says: You speak an infinite deal of nothing
21:43:35 <SamB> ????
21:43:41 <SamB> @quote
21:43:42 <lambdabot> samc says: monads are hard, let's go shopping
21:43:45 <SamB> @quote
21:43:47 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
21:43:52 <SamB> @quote
21:43:53 <lambdabot> vincenz says: I wish meta had a letter. like eta
21:44:02 <SamB> @quote
21:44:03 <lambdabot> cjeris says: and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking
21:44:03 <lambdabot> programming as easy as possible.  see ColdFusion.
21:44:33 <SamB> hmm, I don't need a programming language for that
21:44:38 <SamB> I just stays up too late
21:44:39 * sorear reminds SamB of: zless `@where lambdabot`/State/quote
21:44:39 <blackdog> @vixen
21:44:40 <lambdabot> <undefined>
21:44:48 <sorear> blackdog: she's dead
21:44:55 <blackdog> bah. still broken. i'm going to go make sad faces at dons till he throws something at me
21:45:13 <blackdog> now i'm going to have to write an emo song about my poor dead internet girlfriend
21:45:14 <glguy> SamB: I entered that sudo quote
21:45:16 <sorear> chopped up during the hackathon.
21:45:24 <allbery_b> @remember blackdog bah. still broken. i'm going to go make sad faces at dons till he throws something at me
21:45:25 <lambdabot> Done memoising quote for `blackdog', if that is their real name...
21:45:46 <SamB> @tell dons :-( :-( :-( about @vixen (from blackdog)
21:45:46 <lambdabot> Consider it noted.
21:45:52 <blackdog> wow, i'm cranky _and_ quotable!
21:45:58 <blackdog> i've bitched at him already. :)
21:46:11 <jcreigh> @remember blackdog wow, i'm cranky _and_ quotable!
21:46:12 <lambdabot> Done memoising quote for `blackdog', if that is their real name...
21:46:15 <jcreigh> :P
21:46:19 <augustss> what happened to vixen?
21:46:25 <sorear> @quote sorear
21:46:26 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
21:46:26 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
21:46:30 <sorear> I've only got one :(
21:46:31 <SamB> augustss: the new regexp stuff happened to vixen
21:46:35 <SyntaxNinja> y0
21:46:41 <sorear> augustss: Binary happened to vixen
21:46:41 <SyntaxNinja> hiya sorear
21:46:45 <SyntaxNinja> hi blackdog!
21:46:48 <SyntaxNinja> blackdog: where you been?
21:46:48 <SamB> wait, what?
21:46:49 <augustss> bah!
21:46:50 <SamB> oh.
21:46:54 <blackdog> Hey dude. long time no speakee.
21:46:56 <SamB> okay, I got confused
21:47:01 <blackdog> Doha and Thailand
21:47:01 <SamB> so vixens regexps got mashed?
21:47:08 <SamB> into ascii?
21:47:16 <sorear> oooh I'm notable enough to be greeted by name by the haskell-prime guy!!
21:47:16 <blackdog> am in a bar in Chiang Mai, listening to BB King and drinking beer.
21:47:19 <SyntaxNinja> blackdog: sweet.
21:47:23 * sorear jumps and giggles
21:47:26 <SyntaxNinja> blackdog: and IRCing ;)
21:47:30 <SyntaxNinja> blackdog: you on a laptop?
21:47:30 <blackdog> and IRCing
21:47:31 <blackdog>  :)
21:47:33 <blackdog> yeah
21:47:49 <SyntaxNinja> sounds fun.  doing much Haskell lately?
21:47:57 <blackdog> i should be working on speeding up this postgresql db, but i don't have access to the logs, so i don't know why it's falling over
21:48:01 <blackdog> yeah, a bit
21:48:29 <blackdog> wrote a little program to pull english text out of viruses, just because someone kept sending me dodgy .sis files in bangkok traffic
21:48:53 <SyntaxNinja> heh
21:49:02 <blackdog> and i'm getting sort of interested in writing a really good emacs mode - something that does typechecking and colours your buffers appropriately
21:49:09 <glguy> SamB: actually, I entered that sudo quote right about when lambdabot started quoting sudo for errors
21:49:12 <SyntaxNinja> blackdog: that would be nice :)
21:49:20 <augustss> blackdog: nice!
21:49:29 <SamB> sudo makes surly remarks?
21:49:42 <blackdog> (also, if you have a fast computer, i think some interaction with hippie-expand and incremental type-checking would give you IntelliSense-ish tech)
21:49:45 <nornagon> sudo make me a sandwich.
21:50:04 <merus> nornagon: ok
21:50:10 <SamB> nornagon: I hope you have a nice Makefile
21:50:37 <blackdog> SN: what've you been up to?
21:51:09 <allbery_b> sudo makes those remarks on openbsd
21:51:21 <SamB> ah
21:51:32 <SamB> that does sound like an openbsd kind of thing ;-)
21:51:38 <SamB> them being big on security
21:51:47 <SamB> I suppose it does that when you mistype your password?
21:51:52 <allbery_b> yeh
21:52:03 <SyntaxNinja> blackdog: living in Portland oregon these days, which I really like.
21:54:28 <bos> SyntaxNinja: do you work with andy gill and company?
21:55:15 <SyntaxNinja> bos: yeah
21:55:28 <bos> cool.
21:55:51 <SyntaxNinja> bos: yeah :)
21:56:00 <bos> galois looks very interesting, except for being in portland and doing lots of nsa work :-)
21:56:16 <blackdog> Portland's meant to be nice... some band I like comes from there, I think. :)
21:56:18 <SyntaxNinja> portland rocks ;)
21:56:47 <blackdog> of course, tonight i'm off to a club to see Thai hardcore music. Should be interesting...
21:56:57 * bos knew andy and sigbjorn and a few other galois people back a long time ago.
21:57:29 <augustss> Portland is great.
21:57:51 <SyntaxNinja> yeah.  I work pretty closely with Andy and sigbjorn.  those guys rock.
21:58:13 <bos> they do. andy's incredibly nice.
21:58:15 <SyntaxNinja> andy, siggy, Iavor Diatchki, me, and another guy are all on a project together.
21:58:23 <bos> nice!
21:58:25 <SyntaxNinja> oh, and another guy
21:58:33 <augustss> Iavor is at Galois now?
21:58:33 <SyntaxNinja> both other guys aren't well known in the Haskell community.
21:58:43 <SyntaxNinja> yeah. he sits right next to me.
21:58:59 * sorear was somehow under the impression there were only 4 people at galois...
21:59:14 <augustss> sorear: very wrong
21:59:38 <bos> it's more like 30, right?
21:59:40 <SyntaxNinja> sorear: nah, there are more. we're just one project.
21:59:42 <SyntaxNinja> yeah
21:59:46 <SyntaxNinja> something like that
21:59:59 <augustss> Is John L back?
22:00:30 <SyntaxNinja> yeah :)
22:00:49 <beschmi> blackdog: you should hack on shim: http://shim.beschmi.de/trac/shim ;)
22:00:51 <lambdabot> Title: shim - Trac
22:00:52 <augustss> cool
22:01:06 <SyntaxNinja> augustss: how are things with you
22:01:20 <SyntaxNinja> it's fun to come on here at different times than normal, I run into totally different people :)
22:01:32 <augustss> SyntaxNinja: I'm moving from Manhattan to London in a week.
22:02:25 <beschmi> blackdog: there is already identifier completion, type lookup, typecheck-on save which underlines errors and jump to declaration
22:02:25 <augustss> A whole new set of people to do Haskell indoctribation on. ;)
22:02:46 <SyntaxNinja> augustss: manuel is heading back too, right?
22:02:49 <SyntaxNinja> augustss: excellent :)
22:03:07 <SyntaxNinja> augustss: you should do a day on commercial Haskell :)
22:03:10 <augustss> SyntaxNinja: Manual leaves on Monday.  Gabi in two weeks.
22:03:50 <blackdog> beschmi: hm, cheers, will check it out. (weird coincidence - my website is shimweasel.com :)
22:05:20 <blackdog> indoctribation = moving people into the post-doctoral tribe? :P
22:06:15 <bos> it's funny that with so many fibonacci examples around in haskell, there's no canonical fast version in the standard libraries
22:06:48 <augustss> blackdog: lol.  yes
22:06:59 <blackdog> where's the fun in thirdfib = Stdlib.fib 3?
22:07:01 <mbishop> fibonacci numbers aren't exactly something you need often :P
22:07:22 <augustss> bos: if fib were useful it would be in the standard library
22:07:41 <bos> i must be the only person ever to need it for something practical, then :-)
22:07:54 <sorear> are you implying split isn't useful? :) :)
22:08:11 <psykotic> bos: in what context?
22:08:21 <bos> rebalancing a tree.
22:08:24 <blackdog> actually, one thing i keep writing is fastNub :: Ord a => [a] -> [a]
22:08:25 <augustss> ok, hands up!  who has ever used fib in real code?
22:08:25 <psykotic> it can be useful to detect fibonacci numbers when dealing with huffman coding
22:08:34 <blackdog> which probably means i'm using an inappropriate datastructure :)
22:08:57 <brainly-green> there is such a thing as a fibonacci tree
22:08:58 <sorear> actually every piece of code non-pedagogically written is a fortiori useful code that isn't in the stdlibs :)
22:08:59 <bd_> blackdog: fastNub = Data.Set.toList . Data.Set.fromList ? :)
22:09:02 * bos raises a hand tentatively. "just once, though."
22:09:14 <augustss> I know there are legitimate uses, but they are rare
22:09:16 <bd_> blackdog: you could do faster with straight sort+uniq of course
22:09:20 <psykotic> (you want the histogram counts not to form part of a subsequence of fibs)
22:09:34 <brainly-green> I think that someone should start a website where you can upload useful functions you make
22:09:36 <blackdog> bd_: yeah, that's the way i usually write it
22:09:46 <brainly-green> and then anyone who wants a function, looks at the website
22:09:51 <augustss> fastNum = map head . group . sort
22:09:54 <blackdog> i think there's an underground stdlib somewhere on the haskell wiki
22:09:58 <augustss> s/Num/Nub/
22:09:59 <bos> brainly-green: as with the python and perl cookbooks.
22:10:19 * allbery_b thought there was a section of the wiki for that
22:10:20 <sorear> brainly-green: it's called hackage
22:10:26 <blackdog> augustss: nice, that's much prettier than mine
22:10:26 <bos> augustss: where are you going in london? imperial?
22:10:28 <allbery_b> that too
22:10:30 <sorear> allbery_b: CodeOnTheWiki ?
22:11:03 <augustss> bos: Still working for Credit Suisse.  In the Docklands area.
22:11:37 <bos> ah. they have you doing haskell stuff?
22:11:54 <augustss> bos: I do Haskell all day long :)
22:11:59 <bos> yum!
22:12:05 <allbery_b> Category:Idioms seems to have some entries that function as code snippet repositories
22:12:08 <augustss> we have a pretty cool DSEL
22:12:40 * bos paid a visit to the credit suisse offices once, to talk about clustering big spreadsheet evaluations.
22:12:52 <allbery_b> (as distinct from idioms)
22:13:17 <glguy> !paste
22:13:18 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
22:13:20 <glguy> !id check
22:13:21 <hpaste> check
22:13:29 <augustss> The DSEL is for making pricing models.  The current back end generates Excel sheets.
22:13:51 <bos> i forget what spreadsheet they were using at the time; it ran on solaris.
22:13:58 <bos> long time ago, in other words.
22:14:02 <augustss> Ah, a long time ago
22:14:14 <augustss> It's all Windows now :(
22:14:25 <bos> so long as you're insulated from it :-)
22:14:26 <allbery_b> 2020?  tactician?
22:14:50 <augustss> I have to use Windows, but inside emacs you don't notice much
22:15:28 <augustss> It's an interesting DSEL.  It looks kinda like Haskell (well, it is), but when you run the program it generates Excel.
22:15:43 <bos> very nice.
22:15:46 <sorear> @remember augustss I have to use Windows, but inside emacs you don't notice much
22:15:47 <lambdabot> Done memoising quote for `augustss', if that is their real name...
22:15:51 <psykotic> in what way is excel used, exactly?
22:16:08 <psykotic> is it like a parameterized model, where you can tweak the knobs from inside excel and see the results?
22:16:27 <augustss> Excel is used as the main user interface, as well as gluing together all the analytics written in C++.
22:17:16 <augustss> psykotic: yes, it's like a parametrized model (in C++).  Except that there are many C++ building blocks.
22:17:59 <psykotic> interesting. i work on video games and game designers use excel in a similar way, though they keep most things inside excel.
22:18:14 <augustss> And Excel is a horrible, horrible language for the purpose of this kind of programming.
22:18:38 <augustss> There is 0 possibility of abstraction in Excel.
22:19:21 <psykotic> so does the system support inverting relationships? like say you want a certain characteristic in the output--can it try to find a suitable tweak to the input(s)?
22:20:07 <augustss> To do that you either has to use the Excel solver, or some external solvers (we have several).
22:20:54 <blackdog> hey, do we have anything like rubygems yet?
22:21:16 <blackdog> cabal seems like a good step in the right direction, but it'd be really nice to be able to not have to worry about dependency stuff so much..
22:21:32 <augustss> what is rubygems?
22:21:57 <blackdog> it's a system for ruby. language-specific thing like ports for BSD, i guess.
22:21:59 <sorear> blackdog: cabal-install
22:22:20 <augustss> cabal and hackage, i guess
22:22:31 <blackdog> where is cabal-install?
22:22:32 <sorear> I would much rather see apt-hackage than cabal-install.
22:22:44 <sorear> maybe I should write it :)
22:22:50 <blackdog> never mind, found it
22:22:51 <blackdog> :)
22:23:09 <psykotic> sorear, piggybacking on apt?
22:23:17 <blackdog> is there a philosophical difference between cabal and hackage?
22:23:42 <sorear> psykotic: yea!
22:23:59 <sorear> psykotic: it would be a proxy server - hackage in, apt mirror out.
22:24:00 <psykotic> sorear, nice. i'm tired of everyone rolling their own system for dealing with requirements/dependencies.
22:24:23 <sorear> right now, it only exists in my head.  this must change.
22:24:32 <allbery_b> hackage is kinda the next stage of cabal.  not just building stuff, but finding and installing it, including dependencies
22:24:33 <Shimei> sorear: Sweet idea.
22:26:33 <blackdog> um. anyone know how to satisfy the network-any dependency in cabal?
22:26:57 <allbery_b> on what platform?
22:27:06 <blackdog> MacOS X
22:27:21 <allbery_b> hm, the OSX package should include it
22:27:31 <SyntaxNinja> blackdog: hackage is the entire system. the package database, the web interface, cabal, etc.
22:27:57 <SyntaxNinja> blackdog: cabal is the architecture for building applications and libriares, as well as storing the package metadata
22:28:08 <sorear> Cabal is dpkg.  Hackage is apt-get.
22:28:26 <sorear> more like dpkg+autotools+make actually
22:28:35 <allbery_b> or in perl-speak, cabal is MakeMaker (the thing that generates Makefile.PL) and hackage is CPAN
22:28:38 <SyntaxNinja> sorear: kinda; hackage is like packages.debian.org and, etc.
22:28:45 <SyntaxNinja> hackage includes everything
22:29:02 <sorear> oh. /me had hackage confused with cabal-install (?)
22:29:06 <SyntaxNinja> hackage includes cabal and cabal-install (cabal-install is like apt-get)
22:29:13 <blackdog> ok, with you now
22:29:14 <allbery_b> ...hackage uses cabal as a base the way CPAN relies on things using Makefile.PL for building
22:29:30 * sorear doesn't speak perl-speak
22:29:38 <blackdog> but i still don't know how to satisfy network-any. should it be provided by ghc, or cabal, or something else entirely?
22:29:46 <SyntaxNinja> wow. I'm running apt-get on my palmtop nokia now :)
22:29:53 <allbery_b> enough people do have to deal with perl one way or another that it's still a useful comparison
22:30:14 <brainly-green> what would you get if you took a large program and did a google-like "page-rank" of all the functions in that program, where a function is said to "link" to another function if the other function appears directly in its body text
22:30:16 <SyntaxNinja> blackdog: ghc-pkg -l |grep -i network
22:30:27 * allbery_b installed OSX ghc6.6 from the ghc download page and extralibs (inluding network) was included.
22:30:36 <sorear> brainly-green: a mess? :)
22:30:47 <blackdog> ok, i don't have it. must have screwed up my ghc install...
22:31:00 <allbery_b> no idea what m,acports does; I'm holding off on that because I might still want/need ghc6.4 and dn't know if macports deals with having both
22:31:05 <allbery_b> (should probably check that)
22:31:12 <SyntaxNinja> blackdog: you might need like the extras library in GHC? they reorganized it
22:31:20 <brainly-green> I think you would get a list of the language features and functions used in that program, sorted by ubiquity
22:31:29 <SyntaxNinja> blackdog: but I never notice because Igloo rocks and apt-get install ghc does the right thing ;)
22:31:41 <allbery_b> in fbsd ports they'd repocopy the current one
22:32:12 <SyntaxNinja> blackdog: is this ghc 6.6?
22:32:13 <allbery_b> but macports is kinda fbsd ports' retarded younger brother
22:32:16 <blackdog> yeah
22:33:03 <blackdog> but i suspect i just screwed up the install - it was a while ago, and it took forever. (slow machine...)
22:33:19 <brainly-green> and maybe you could turn it into a language search engine
22:33:52 <blackdog> hey, anyone got any reports on ghc on the new macs?
22:33:55 <brainly-green> wouldn't that be interesting
22:35:04 <blackdog> my beautiful old g4 powerbook is getting a little long in the tooth...
22:35:28 <allbery_b> brainly-green: I think haddock does that already
22:35:37 <allbery_b> and can be combined with hoogle
22:37:27 <allbery_b> hm, well, some of it.  I don't tink it outputs a hyperlinked html markup of source code, although I could be wrong
22:37:49 <brainly-green> ah i'm not talking about hyperlinking code
22:38:10 <brainly-green> yeah hoogle is similar, I don't know enough about haddock
22:38:10 <sorear> stepcut: ping?
22:38:42 <allbery_b> okay, you're talking about haddock then
22:38:49 <allbery_b> @docs
22:38:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:39:04 <allbery_b> that's haddock output on the standard libraries
22:39:46 <brainly-green> I think a language should be really, really big
22:39:56 <brainly-green> too big for anyone to learn, when you include all of the standard functions
22:40:07 * allbery_b thinks a language should be compact.  the *libraries*, however, should be big
22:40:11 <mbishop> it's called common lisp :P
22:40:19 <brainly-green> but it should have a function for almost anything you want
22:40:21 <brainly-green> and it should come with its own search engine
22:41:01 <sorear> With Haskell, you almost pretend the syntax is libraries.
22:41:12 <sorear> Haskell-the-language is called yhc.core
22:41:25 <brainly-green> ok well then I'm talking about libraries
22:41:45 <sorear> google?
22:41:47 <sorear> hoogle?
22:42:00 <sorear> hmph, too similar...
22:42:14 <allbery_b> it's amazing hw little of Haskell is actually core; most of the "language" is defined in the Prelude
22:44:03 <brainly-green> I wonder if work has been done on how to extract useful functions out of big software projects, without consulting the developers
22:44:20 <brainly-green> like, analyzing the source to determine which functions might be useful to other people
22:45:40 <brainly-green> for example functions that deal with only common data types like integers or strings might be likely to be useful
22:46:01 <brainly-green> where functions that deal with specialized program-specific data types are probably less likely to be useful
22:46:53 <brainly-green> functions that reference program-specific global variables can never be useful unless altered
22:49:02 <brainly-green> few functions with any side effects would be useful, the exceptions being those with side effects that change things common to many people such as filesystem, output, or graphics
22:49:07 <sorear> there are no global variables in Haskell
22:49:19 <sorear> only global constants
22:49:41 <allbery_b> (ignore that IORef behind the curtain)
22:49:58 <glguy> There are no global values in Haskell98 at least, right?
22:50:07 <glguy> variables*
22:50:15 <sorear> Haskell, unqualified, refers to Haskell - *unsafe* , correct?
22:50:41 <glguy> I thought that was why we had the Haskell98 standard...
22:50:53 <sorear> besides, all the cool people use monad transformers.
22:51:08 <bos> @hoogle sizeOf
22:51:08 <sorear> global variables are *sooo* lame ...
22:51:08 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
22:51:31 * glguy isn't advocating them :)
22:51:48 <blackdog> and let's call 'em global mutable references, for the sake of clarity, hm? :)
22:54:36 <brainly-green> basically you could compute portability by looking at a lot of different programs
22:55:09 <brainly-green> if a function uses data structures or I/O that is common to many programs, then perhaps that function could be widely useful
22:55:14 * allbery_b wonders how much of that is in, or already being worked on for, google code
22:55:45 <allbery_b> (search etc.)
22:55:51 <brainly-green> on the other hand if a function uses data structures or I/O constructs that appear only in the original program, then that function may not be widely useful
22:56:52 <brainly-green> line up 10 big projects side by side, turn on your function extractor, and voila, a new library
22:57:34 <allbery_b> IIRC there's a fair amount of research showing that code isn't as reusable as one would think
23:04:04 <blackdog> i think you also reach a certain point where specifying the type of a function that you want takes you 90% of the way to writing it anyway...
23:04:55 <brainly-green> maybe you just have to look harder to re-use things
23:05:12 <brainly-green> and I'll bet functional programs would have better re-usability
23:06:12 <allbery_b> no, the real problem IIRC is that inb nmost languages --- Haskell being a notable exception --- you end up with code that knows about program-specific data types in places it "shouldn't" (ideally) be
23:06:58 <allbery_b> FP in general and haskell does have much greater reusability but I saw something go by on planethaskell recently suggesting it's still not great
23:07:17 <allbery_b> (which might mean programmers don't know how to use what they have, and fall back on silliness like "deisgn patterns" instead)
23:08:27 <allbery_b> a design pattern being in essence interningling generic concepts with your program-specific structures in a non-readily-extractable way
23:10:29 <brainly-green> x\what do you mean allbery_b
23:10:41 <brainly-green> shouldn't be?
23:11:06 <brainly-green> where shouldn't the program-specific data types be that they do tend to be anyway?
23:11:08 <allbery_b> the neat thing about Haskell is that, once you know how to use the language, you can abstract almost any design pattern into a polymorphic function or a monad transformer, and then it truly *is* a reusable component
23:11:40 <blackdog> hey, did anyone here read Steve Yegge's latest article?
23:11:55 <blackdog> http://steve-yegge.blogspot.com/
23:11:57 <lambdabot> Title: Stevey's Blog Rants
23:12:03 <allbery_b> the concept behiind design pattenns is that you in effect build things thta in a sane design and a sane language would be abstract, into the guts of your code and your data types
23:12:28 <allbery_b> as someone (sorear?) was ranting the other day, this indicates your language sucks :)
23:12:35 <blackdog> some interesting stuff on the influence of static/dynamic typing on building flexible programs... bit incendiary here, maybe, but interesting
23:12:35 <brainly-green> yeah I get the bit about design patterns and agree, but what about the other thing--program specific data types
23:12:41 <brainly-green> that are where they shouldn't be
23:13:05 <brainly-green> what do you  mean by that
23:13:07 <allbery_b> where they shuldn't be is in code that should really be generic
23:13:19 <brainly-green> oh
23:13:33 <glguy> !paste
23:13:34 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
23:13:48 <allbery_b> instead, you're forced to build a design pattern into and around your program-specific stuff, because your language is too stupid to let you extract it in a reusable form
23:15:10 <allbery_b> so you have these design patterns which basically tell you what "generic" operations have to be built into your data types (meaning it's not really generic)
23:15:16 <sorear> and most languages that do have polymorphism (C) have far too much of it
23:15:46 <sorear> conditional-free strict untyped lambda calculus isn't that easy to use
23:15:47 <allbery_b> in haskell, otoh, you can design such things polymorphically in such a way that it's truly reusable.  no design patterns, just libraries.
23:16:47 <hpaste>  glguy annotated "test paste" with "cookie test" at http://kakapo.scannedinavian.com:8000/15#4
23:17:27 <allbery_b> go take a look at stuff like the Iterator pattern or the Observer pattern
23:18:09 <allbery_b> in a sane language, those are in libraries and you can use them anywhere with minimal work.  in most languages, you need to code to a design pattern to get them.
23:18:48 <allbery_b> as such, design patterns are almost the antithesis of code reusability
23:19:13 <bd_> isn't the observer pattern trivially implemented with Control.Concurrent.Chan and dupChan? :)
23:24:09 <merus> blackdog: It was fine until he jumped the shark and started talking about living things as software, and rebooting as death.
23:25:13 <blackdog> it's just an analogy - you can take it for what it's worth
23:25:40 <merus> I'm not done reading it yet.
23:26:00 <blackdog> unless you think that non-deterministic processes are intrinsic to life, then the software analogy isn't totally dumb, i think.
23:26:35 <blackdog> but i agree with philippa's comment that haskell got a bit of an unfair showing - hs-plugins is popping up everywhere...
23:27:11 <sorear> maybe he uses 6.6 <evil grin>
23:28:11 <merus> I never realized that the console/modding features are why I still play Quake.
23:29:07 <glguy> sorear:
23:29:10 <glguy> ?where stats
23:29:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
23:29:41 <sorear> you pointing out the #3?
23:30:09 * sorear hasn't really had many chances to rant today
23:30:32 <glguy> mostly that we've surpassed all the living nicks
23:30:53 <sorear> muahahaha
