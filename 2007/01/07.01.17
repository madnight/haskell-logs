00:04:29 <dons> morning!
00:05:02 <glguy> evening to you as well
00:05:31 * LoganCapaldo 3AM!!!
00:05:44 <glguy> 2am here
00:09:37 * LoganCapaldo runs away
00:09:37 <LoganCapaldo> good night
00:09:37 <glguy> maybe i lie to myself to justify being up
00:09:37 <glguy> having too much fun tinkering...
00:16:29 <Saizan> 9am :D
00:18:05 <Saizan> glguy: i find your code is also a good tutorial for happs and Text.Html, lots of functions to pick up
00:18:29 <glguy> i ought to paste the new code
00:18:39 <glguy> that code is at least 12 hours out of date
00:18:49 <Saizan> oh
00:19:10 <Saizan> changed to 0.9 in the meantime?
00:19:50 <glguy> version numbers? naw, no way ;)
00:20:44 <Saizan> happs' 0.9 i mean :)
00:20:49 <glguy> http://fserv.pikapphi.umr.edu:8000/5#1
00:20:50 <lambdabot> Title: Display Paste
00:21:07 <glguy> oh, no, it's the same code for that
00:21:18 * glguy thinks to put the paste title in the title
00:24:49 <ButterNaan> yodel!
00:25:03 <ButterNaan> am new to haskell!
00:25:07 <ButterNaan> how do i run my script?
00:25:31 <glguy> with Hugs or GHC
00:25:31 <ytinasni> runhaskell script.hs (args)
00:25:42 <ButterNaan> hmm
00:26:06 <ButterNaan> heck.hs:6:44: parse error on input `->'
00:26:14 <ButterNaan> syntax errors?
00:26:22 <glguy> you have a error on line 6, column 44
00:26:32 <nmessenger> lisppaste2: url?
00:26:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:26:36 <glguy> :(
00:26:48 <glguy> i guess channel announcement is huge
00:26:53 <glguy> I need to figure that one out..
00:27:21 <nmessenger> ButterNaan, put your code on paste.lisp.org
00:27:21 <ButterNaan> thats just 1 line
00:27:26 <ButterNaan> mm k
00:28:06 <nmessenger> if less than 3 lines, you might paste in-channel
00:28:07 <ButterNaan> uhh, itll be announced?
00:28:15 <nmessenger> via the above url
00:28:51 <ButterNaan> uhh, you mean i can paste here, its just 4 lines?
00:29:32 <nmessenger> I think that would be okay
00:29:37 <nmessenger> *shrug*
00:29:39 <ytinasni> we prefer you use the paste site, but you can paste here :)
00:29:50 <ButterNaan> module Main where
00:29:55 <ButterNaan> main = do putStrLn (show $ sum $ takeWhile (< 1000000) primes)
00:30:00 <ButterNaan> primes= 2:sieve [3, 5 ..]
00:30:05 <ButterNaan>     where sieve (p:ns) = p:sieve (filter (x -> x `mod` p > 0) ns)
00:30:10 <ButterNaan> thats it , thanks :)
00:30:17 <glguy> filter (\x ->
00:30:18 <LoganCapaldo> \x -> x ...
00:30:20 <nmessenger> forgot the backslash in your lambda
00:30:22 <ytinasni> you want (\x ->
00:30:32 <nmessenger> :D
00:30:32 <ButterNaan> aaah
00:30:33 <glguy> main = print (sum $ takeWhile
00:32:03 <nmessenger> print = putStrLn . show
00:32:12 <glguy> You don't need "do" for one-liners and print x is like: putStrLn (show x)
00:32:46 <ButterNaan> hmm
00:32:57 <nmessenger> do-syntax is main for connecting actions together, but it won't hurt it.
00:33:03 <nmessenger> *mainly
00:33:12 <glguy> I just figured he didn't know :)
00:38:28 * nmessenger wonders if the printf polyvariadic args magic could be applied to generalize 'zipN', 'liftMN', etc.
00:38:52 <glguy> I tried earlier
00:39:05 <glguy> no one really knew how, me included
00:39:22 <glguy> (for liftMn)
00:39:27 <nmessenger> maybe a 'list' function for lispy commaless lists
00:39:39 <glguy> we were doing it in the context of Control.Applicative
00:39:56 <glguy> using the notation introduced in the paper relating to that topic
00:40:10 <glguy> liftM2 a b c = iI a b c Ii
00:40:27 <glguy> at least for applicative... not monad
00:42:01 * glguy &
00:43:41 <Cale> nmessenger: I think I've seen that one done
00:44:24 <Cale> Every monad is applicative though
00:44:24 <LoganCapaldo> Yay! commaless lists1
00:45:51 <Cale> and I've seen generalisations of zipN which produced nested pairs
01:06:18 <notsmack> glguy: glad to see some valid xhtml now  :-)
01:13:53 <dons> musasabi: thanks for the patches!
01:14:02 <dons> I quite like this darcs.h.o style repo stuff
01:14:08 <dons> less overhead merging patches and applying them
01:16:13 <russruss> hey guys, I have a quick problem - I'm trying to set up hscurses, the ncurses library
01:16:19 <musasabi> np, the code was very clean so writing the patch was easy :)
01:16:20 <russruss> I've never installed a library in haskell before
01:16:31 <russruss> I ran the setup.hs configure
01:16:34 <russruss> and it ran fine
01:16:38 <russruss> but on build it yelled at me
01:16:56 <russruss> because there were "#def"'s still in the hs files
01:17:27 <russruss> like does this mean hsc2hs is working wrong? or what's up? how can I find out what's going on?
01:18:15 <Cale> hmm
01:18:43 <Cale> It sounds like somehow the C preprocessor isn't getting run when it should.
01:19:42 <russruss> huh... it doesn't give any errors during the preprocessing phase :-\
01:20:28 <Cale> Can you tell if ghc is getting run with -cpp ?
01:21:21 <russruss> yah, according to -v
01:21:30 <Cale> hmm
01:22:10 <conal> phew!  i just release three libraries.  announcements on haskell mailing list.
01:22:57 <russruss> I also tried using the regular makefile but it didn't seem to work, as in I couldn't import HSCurses.Curses from an outside file
01:23:00 <conal> dons: is HWN going out this week?
01:23:05 <russruss> although the example compiled
01:23:57 <notsmack> elem 'W' "HWN"
01:24:03 <russruss> this kinda sucks :'(
01:24:20 <Cale> russruss: perhaps I'll get the library and see if I run into the same problem
01:25:30 <russruss> Cale, thanks
01:25:36 <russruss> it might be something to do with the version of ghc
01:25:41 <dons> conal: probably not this week, i'm at popl and its a bit busy
01:25:50 <russruss> I'm just using the debian package for 6.6
01:25:52 <dons> should be ready for next week, after this one week break
01:25:59 <dons> conal: great!
01:26:17 <conal> dons: got it, thanks.  i was hoping to get my libs out in time.  but i see i had plenty.
01:26:30 <dons> ?where+ DeepArrow http://haskell.org/haskellwiki/DeepArrow
01:26:43 <dons> ?where+ tv http://haskell.org/haskellwiki/TV
01:27:00 <conal> dons: hey -- thanks!
01:27:05 <conal> ?where tv
01:27:17 <dons> mmm....
01:27:21 <conal> (i'm guessing)
01:27:23 <dons> ?bot
01:27:28 <dons> ah...
01:28:16 <Cale> russruss: It built fine under GHC 6.4.2
01:28:27 <Cale> I'll try 6.6
01:29:10 <russruss> Cale, thanks
01:31:59 <Cale> builds fine under 6.6 as well
01:32:01 <Cale> hmm
01:32:23 <Cale> I'm using the generic linux binary package for 6.6
01:32:42 <Cale> oh, and the darcs version of hscurses
01:33:05 <russruss> okay yah I'll tray that
01:37:57 <russruss> okay, well it worked
01:37:59 <russruss> thanks
01:38:23 <russruss> kinda weird that the link of like the "stable" version on his site didn't work but the darcs did :-P
01:41:31 <Saizan> ?paste
01:41:31 <lambdabot> http://paste.lisp.org/new/haskell
01:42:43 <Cale> russruss: It's quite possible that the stable version has bitrotted relative to GHC 6.6
01:43:07 <Cale> Cabal things have been stabilising over the last few releases of GHC.
01:56:38 <pejo> How do you sign emails in english, "Best, RET RET <name>", "Regards, RET RET <name>", or some other way?
01:57:40 <dons> yeah. Regards, \n <name>
01:57:43 <dons> is pretty common
01:57:47 <dons> or 2 newlines
01:58:02 <pejo> Thank you.
02:02:45 <dons> ?users
02:02:45 <lambdabot> Maximum users seen in #haskell: 311, currently: 278 (89.4%), active: 9 (3.2%)
02:05:03 <Masklinn> Good morning #haskell
02:05:50 <nornagon> dons: ?users should track unique too :)
02:20:20 <bakert> ?hoogle isNothing
02:20:21 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
02:20:47 <nornagon> ?src isNothing
02:20:47 <lambdabot> isNothing Nothing = True
02:20:48 <lambdabot> isNothing _       = False
02:21:15 <bakert> I have four Doubles and an Int.  I wish I could map isNothing over them
02:22:56 <bakert> ?hoogle isNothing
02:22:56 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
02:22:59 <bakert> oop
02:23:03 <nornagon> ... what?
02:23:22 <bakert> i wish xchat didn't have command history.  i repost stuff when i think i have switched to a terminal!
02:23:30 <Saizan> you can use oleg's mapTuple :D
02:24:05 <nornagon> that sounds... a little crazy
02:24:12 <nornagon> :|
02:24:13 <bakert> Saizan, i tried a kind of mapTuple that dons posted yesterday but it used arrows (me no comprendo) and only worked on pairs (i have four values) so i figured that was something for another day ...
02:24:24 <bakert> f = f *** f or something
02:24:46 <Saizan> ?type \f -> f *** f
02:24:47 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
02:24:55 <bakert> yah.  see what i mean?!
02:25:00 <Saizan> that's for omogeneus tuples
02:25:10 <Saizan> ?spell omogeneus
02:25:11 <lambdabot> Imogene's Emogene's Imogen's homogeneous Imogene
02:25:55 <Saizan> well, oleg's one works on all 2-tuples and is easily extendible
02:26:17 <Saizan> it's a little typeclass hackery though :)
02:26:24 <bakert> probably there is a much easier way to shorten my cod
02:26:28 <bakert> s/cod/code/g
02:26:33 <bakert> ?paste
02:26:34 <lambdabot> http://paste.lisp.org/new/haskell
02:26:59 <lisppaste2> bakert pasted "What is the RIGHT way to do this??" at http://paste.lisp.org/display/35513
02:27:18 <bakert> I'm sure one of you gurus can tell me in 5 seconds flat what I really ought to be doing.
02:27:29 <bakert> ??? pretty please ???
02:27:30 <bakert> !
02:28:43 <bakert> :(
02:28:59 <tuukkah> i'm no guru but at least with the list you can use map
02:29:02 <daniel_larsson> sequence [balance, fundsPending,, ...] ?
02:29:09 <therp> don't beg.
02:29:22 <bakert> therp, it's my one skill!
02:29:22 <Saizan> [11·17·50] <bakert> I have four Doubles and an Int.  I wish I could map isNothing over them
02:29:32 <aleator> bakert: maybe is a monad. so you can get rid of the if.
02:30:09 <aleator> but it will still be long because you convert a list to a big tuple.
02:30:24 <daniel_larsson> > sequence [Just 1, Just 2]
02:30:25 <lambdabot>  Just [1,2]
02:30:34 <bakert> >sequence [Just 1, Just 22.0]
02:30:36 <daniel_larsson> sequence [Just 1, Nothing]
02:30:45 <daniel_larsson> > sequence [Just 1, Nothing]
02:30:47 <lambdabot>  Nothing
02:31:05 <daniel_larsson> Well, lists need to be homogenous
02:31:17 <bakert> yeah, that's my problem.
02:31:35 <bakert> aleator, what do you mean when you say i can get rid of the if?
02:32:31 <aleator> bakert: Like daniel said. Just sequence the values or like do {a<-balance;b<-pending..etc.; return (a,b,..)}
02:33:12 <bakert> aleator, sorry not being very clear.  betCountPending is a Maybe Int and the others are Maybe Doubles.
02:33:39 <bakert> I've improved it a teeny bit with:
02:33:40 <bakert>     if or $ (map isNothing [balance, fundsPending, totalStakePending])
02:33:40 <bakert>             ++ [isNothing betCountPending]
02:33:44 <webus> hi
02:33:49 <bakert> hi webus
02:35:29 <tuukkah> also in this case, i would think using rational could replace the use of Ints and Doubles
02:35:41 <aleator> bakert: Well. It is not shorter, but you can remove the if by using a maybe monad..
02:35:51 <bakert> tuukkah, aha! that sounds good.
02:36:04 <aleator> Whats the piece of code doing anyhow?
02:36:36 <aleator> why do you want to get the values out of the Maybe?
02:36:37 <bakert> aleator, i've visited a website and (maybe) collected these numbers and now I want to pass them back as a Maybe (x, y, z, i)
02:36:47 <bakert> but that's up for grabs.  that's just how it occurred to me to do it.
02:37:06 <bakert> maybe the secret is to send it back as (Maybe x, Maybe y ...)
02:37:22 <bakert> or maybe the secret is to do with rational ... what's that tuukkah?
02:37:55 <aleator> I mean, what are you doing with the values afterwards?
02:38:20 <bakert> If it is nothing i am printing an error.  If it is a Just (numbers) then I am putting them in a database row.
02:39:25 <tuukkah> bakert, rational numbers can represent both integers and floating point numbers
02:39:53 <aleator> It is just that I can't think of anything that essentially helps the given bit of code, but it just feels like something that might be unnecessary in the big picture.
02:41:14 <bakert> tuukkah, i will investigate them.  thanks
02:41:38 <bakert> aleator, i am almost certain you are right.  i am definitely not "thinking in haskell" here.  it's very imperative and rubbish.  i'm just not sure how to extricate myself!"
02:42:29 <aleator> bakert: you can also write it something like this: http://pastebin.com/861149
02:42:47 <aleator> I think. Haven't played with these in a while.
02:43:03 <Saizan> i think the problem is that you have them in named variables rather than in a list/tuple from the beginning, but that really depends on how you fetch them from the web
02:43:46 <bakert> Saizan, I have a command "get" that gets a web page.  And I use regexes to extract the values.  I suppose I could sort of say:
02:44:00 <bakert> let x = (oneFunc, twoFunc, threeFunc, fourFunc)
02:44:04 <bakert> or something?  Does that help?
02:44:32 <tuukkah> isn't there little you can do with tuples even if you have one?
02:44:55 <bakert> tuukkah, i think your rational thing may be the way to go.  then i can do everything listy.
02:45:10 <Saizan> yeah
02:46:03 <bakert> although is it right to influence the return value of say my getBalance function because of what I want to do with it later.  Or perhaps I should wrap that in something that turns the Double into a Rational?
02:46:09 <aleator> bakert: How come the values are already in Maybes? Does the webpagefectcher put them there?
02:46:41 <bakert> yeah ... just because it might fail to get the page or what have.  Doesn't have to be like that though.  That just seemed like a good idea at the time.  Have to signal a cock up somehow?
02:47:19 <aleator> So can you use maybe monad the whole way? (Not sure what you're doing so no promise that this is any good)
02:47:35 <bakert> i'm sorry i'm not really sure what you mean?
02:48:22 <tuukkah> bakert, i was thinking of mapping toRational to a list of the Ints and appending toRational of the Double
02:48:33 <tuukkah> of course that's work too
02:48:35 <aleator> bakert: See the code at http://pastebin.com/861149. This is equivalent to your if. (unless I misthought it)
02:49:23 <bakert> oh right.  so that would be Just (1.0, 1.0, 1.0, 1) if they were all numbers but Nothing if any where Nothing?
02:49:41 <bakert> s/where/were/g
02:49:53 <velco> yep.
02:50:05 <bakert> hmm ... well it's a lot prettier.  but it's more lines!
02:50:34 <bakert> I could do something like:
02:50:41 <bakert> Just balance = getBalance
02:50:54 <bakert> then catch the exception if getBalance returns Nothing and return Nothing?
02:50:56 <tuukkah> you can use sequence on the Ints as suggested earlier
02:50:57 <aleator> Like I said. But if you can have the rest of the stuff in similar construct you wouldn't need to do that explicitly.
02:51:00 <bakert> Is that too hideous to contemplate?
02:51:22 <aleator> Can you paste more code?
02:51:26 <bakert> aleator, good idea.
02:52:22 <lisppaste2> bakert annotated #35513 with "Trying to sort out my Maybe related chaos." at http://paste.lisp.org/display/35513#1
02:52:52 <bakert> some of the values are hardcoded as 0 but that won't be the case when it is finished ...
02:53:12 <bakert> Please, slaughter this code and teach me the right way.  I am really a beginner.
02:54:00 <bakert> tuukkah, i kind of did what you said with the map of isNothing over the Doubles.  Or would sequence be better?
02:54:47 <Cale> bakert: hmm, what's the type of getFunds?
02:55:24 <bakert> getFunds :: Bookie -> BrowserAction (Maybe (Double, Double, Double, Int))
02:55:36 <bakert> Or it was, at some point.  It doesn't compile now :(
02:55:58 <lisppaste2> aleator annotated #35513 with "something.." at http://paste.lisp.org/display/35513#2
02:56:05 <bakert> BrowserAction is a state monad like thing to enable you to sequence webby stuff from Network.Browser
02:56:20 <aleator> I'm really not thinking but if you happen to have proper types..
02:56:46 <bakert> aleator, that looks cool but what if grabAmount returns Nothing, will that explode, or work wonderfully?
02:56:48 <Cale> aleator: wrong monad then
02:57:50 <aleator> bakert: If everything would be in Maybe monad it would just return Nothing.
02:57:53 <tuukkah> bakert, perhaps sequence only makes sense with the unified list of rationals, otherwise it's a mess to append the maybe double to the maybe tuple
02:58:27 <bakert> tuukkah, ok.  but Rational won't represent any Double, will it?  And this is real money we're talking about so I better be precise?
02:59:12 <bakert> thanks everyone for helping, by the way, i'm very grateful.  i know i'm at an early stage here and that can be quite annoying!
02:59:30 <aleator> bakert: What are the types of functions that getFunds applies?
03:00:17 <bakert> grabAmount :: BrowserAction (Maybe Double)
03:00:23 <Cale> Let's take a small example here,  isNothing betCountPending  will be a type error, because betCountPending is 0
03:00:28 <kosmikus> not that I've followed the discussion, but why won't Rational represent any Double ?
03:00:31 <tuukkah> bakert, Double is an efficient, limited floating point, whereas rational is of arbitrary precision
03:00:41 <Cale> and 0 can't be interpreted as a Maybe value
03:00:51 <kosmikus> tuukkah: indeed
03:01:07 <Cale> Rational won't represent NaN or Infinity
03:01:10 <bakert> So I _can_ use Rational.  Great.
03:01:13 <Cale> or negative 0 :)
03:01:20 <tuukkah> Cale, good point
03:01:31 <kosmikus> Cale: ok, but it'd be easy to add
03:01:38 <bakert> Cale, sorry that's me cocking up my stubs.  Those 0s should be Just 0 -- later they will be a call to a function.
03:01:54 <Cale> aha, okay
03:02:14 <bakert> Cale, i was just trying to get it working like this before adding in more functions and complicating things!
03:02:24 <bakert> As you can see the simple version is somewhat beyond me!
03:04:47 <tuukkah> aleator, would MaybeT help write it your way?
03:05:28 <aleator> tuukkah: Yeah. But there still isn't enough of code to see what really should be going on.
03:05:33 <lisppaste2> Cale annotated #35513 with "refactor" at http://paste.lisp.org/display/35513#3
03:05:44 <lisppaste2> bakert annotated #35513 with "OK, a version that compiles." at http://paste.lisp.org/display/35513#4
03:06:28 <Cale> note that the do-block is inside a return
03:06:45 <Cale> the outer return is the return of the BrowserAction monad
03:07:03 <bakert> ah.  great.  that looks good.
03:07:07 <Cale> in fact, we could lift that farther out if there are no actual uses for that monad here
03:07:12 <bakert> no there are.
03:07:15 <Templar2> Anyone who knows whats the main diffrence between haskell and erlang is. And what makes them similar?
03:07:15 <lisppaste2> aleator annotated #35513 with "Why not where?" at http://paste.lisp.org/display/35513#5
03:07:21 <Cale> I don't know how you intend to grow this code
03:07:38 <Cale> The inner return is the return of the Maybe monad
03:07:50 <Cale> (which is to say that it means the same as Just)
03:07:50 <bakert> the growing is that balance, fundsPending and betCountPending will all be functions in the BrowserAction monad because they visit websites.
03:07:59 <Cale> oh
03:08:08 <aleator> Aha. So thats why I'm not helpful.
03:08:17 <bakert> does that change everything? :(  sorry!
03:08:31 <aleator> What is a BrowserAction?
03:08:38 <Cale> http://www.haskell.org/http/api/Network-Browser.html
03:09:00 <bakert> It's from Network.Browser.  It's like a state monad that lets you pretend to be a browser (persistent cookies, etc.)
03:09:14 <Cale> Not everything, but you'll have to change things up somewhat. You'll end up with two layers of unwrapping.
03:09:15 <bakert> (I don't really know what a state monad is but that's what it says in the docs)
03:09:52 <bakert> Perhaps the secret is to do this a different way?  Should I be using Nothing to signal failure at the website.
03:10:29 <Cale> It's only a bit awkward because there are so many possible places for things to fail.
03:10:56 <Cale> (and BrowserAction has no builtin mechanism for failure)
03:11:32 <Cale> hmm...
03:12:20 <Cale> There is the possibility of MaybeT transforming the BrowserAction monad, but I'm not sure that's really significantly nicer.
03:12:45 <Cale> well, here's what it'll look like, I'll make an annotation
03:13:43 <Cale> er, so grabAmount :: ... -> BrowserAction (Maybe ...) ?
03:13:55 <Cale> or something else?
03:16:19 <lisppaste2> Cale annotated #35513 with "something like this?" at http://paste.lisp.org/display/35513#6
03:16:53 <Cale> You have all the stuff in the BrowserAction monad, and then inside the return, you do the Maybe-unpacking.
03:17:48 <apfelmus> Cale, bakert: i think BrowserAction (Error e ..) or something like that is natural. the point is that the Maybe-stuff only arises because you want intelligent error handling.
03:18:36 <Cale> Well, really it's only messy because bind isn't doing both jobs at once for us.
03:18:47 <apfelmus> what i want to say is that if bakert wants error handling (= has more than a couple of Maybes), he'd be best off incorporating them right away
03:19:01 <Cale> Oh, there's only one level of maybe
03:19:14 <Cale> and one of BrowserAction
03:19:21 <apfelmus> Cale: ?
03:19:56 <Cale> getFunds results in something of type BrowserAction (Maybe (...))
03:20:10 <Cale> where (...) is just a tuple
03:20:37 <Cale> What would really clean things up is if it was in MaybeT BrowserAction
03:21:06 <Cale> but MaybeT isn't in the standard libs, and you'd end up lifting all the actual browser action work.
03:21:26 <Templar2> I have heard that earling is mutch beather then haskell, is that true?(more compact code and so on)
03:21:27 <Cale> So I'm uncertain as to whether that's worth it.
03:21:43 <Cale> Templar2: I wouldn't agree :)
03:22:02 <Templar2> Cale: really? Whats beather with haskell then?
03:22:14 <Cale> Templar2: Erlang might be better at certain concurrency problems.
03:22:28 <apfelmus> well, MaybeT = ErrorT ()
03:22:35 <Cale> apfelmus: true
03:22:49 <Cale> Is there an instance of Error for () ?
03:22:58 <malebria> Is there a better HashTable librarie than GHC's one?
03:23:07 <dons> malebria: yeah, perhaps HsJudy?
03:23:09 <Templar2> Cale: aha,k but what problems are haskell bether for?
03:23:28 <dons> things other than telecoms infrastructures
03:23:36 <Cale> dons: :)
03:23:48 <malebria> dons: this is a wrapper for a C library, right?
03:24:00 <dons> malebria: I *think* so, haven't checked
03:24:03 <Cale> Templar2: It's hard to answer that question.
03:24:06 <dons> what do you need a hash for?
03:24:12 <dons> (an IntMap won't do?)
03:24:13 <Cale> Templar2: They're both rather good at lots of things
03:24:20 <Cale> Templar2: and they're both general purpose
03:24:32 <malebria> dons: That's not what I meant.. I just wanted more functions on HashTable class.
03:24:39 <dons> ah ok
03:24:49 <Templar2> Cale roger, but haskell is beather at more complex problems maybe?
03:24:54 <apfelmus> malebria: hash tables are not natural for a functional language
03:24:54 <Cale> Templar2: Most of the Haskell code I've seen has been cleaner and shorter than corresponding Erlang code, but they're fairly similar in many ways.
03:25:01 <Cale> Yeah, quite possibly.
03:25:15 <Cale> It's probably better just to learn both and decide for yourself :)
03:25:31 <malebria> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
03:25:33 <lambdabot> http://tinyurl.com/y47x6e
03:25:36 <malebria> There's no even filter.
03:26:07 <apfelmus> malebria: just don't use hash tables.
03:26:10 <Cale> malebria: Almost nobody uses Data.HaskTable
03:26:14 <Cale> Hash*
03:26:19 <malebria> Why aren't they used
03:26:20 <malebria> ?
03:26:26 <Cale> Because Data.Map exists :)
03:26:27 <dons> because they're not pure
03:26:28 <apfelmus> malebria: why should you use them?
03:26:58 <dons> malebria: Data.Map and Data.IntMap are the preferred structures
03:27:04 <malebria> hum...
03:27:05 <Cale> Data.Map has a beautiful interface, and runtimes that for all *practical* purposes are just as good.
03:27:15 <malebria> dons: aren't they pure?
03:27:16 <dons> i can't off ahnd thing of any haskell program that uses HashTable, actually
03:27:29 <malebria> What about Data.Set?
03:27:40 <dons> what about it? its good too
03:27:40 <Cale> Or yeah, Data.Set
03:28:03 <tuukkah> malebria, you get filter with toList and fromList =)
03:28:21 <Cale> Data.Map and Data.Set come pretty close to setting the standard of quality for Haskell libraries :)
03:28:25 <malebria> tuukkah: I noticed, but that's not the best thing to do...
03:28:52 <malebria> Map fit good into my needs.
03:28:54 <apfelmus> malebria: hash tables are crappy. they mainly exists because balanced trees were too complicated for the implementors
03:29:11 <malebria> I was just going to use hashtables because I didn't knew map.
03:29:21 <dons> ?docs Data.Map
03:29:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
03:29:26 <dons> and for int keys, you have
03:29:29 <dons> ?docs Data.IntMap
03:29:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
03:29:32 <dons> enjoy!
03:29:33 <dons> :)
03:29:50 <malebria> thanks all.
03:30:14 <Cale> That said, it would be good if someone implemented a really good hashtable with a pure interface.
03:30:25 <apfelmus> Cale: i'm against hash tables
03:30:33 <Cale> why?
03:30:46 <Saizan> apfelmus: you think one can use balanced trees to implement something like a relational database?
03:31:54 <apfelmus> Cale: what do they offer? O(1) is a lie. generalized tries are the natural thing
03:32:01 <sieni> Saizan: are you being sarcastic?
03:32:14 <Cale> hehe
03:32:32 <Cale> Saizan: isn't that generally what proper relational databases use?
03:32:57 <apfelmus> Saizan: why not? or do you mean that they use hash tables?
03:33:05 <Elifant> dons: Hello. May be you can help me. I asked this question two times, but nobody answered :( Here is the question: I have datatype and pretty-printing function for it using HughesPj. But now I want to colorize pretty-printed output with ANSI ESC sequences. How can I do it?
03:33:16 <psnl> hash tables give me the creeps, but thats another story
03:33:40 <Cale> Elifant: um, you might have to add combinators for that
03:33:43 <Saizan> ok, now i've the proof that they lie to me at my unversity!
03:33:51 <dons> Elifant: you could use HsColour perhaps?
03:33:55 <dons> ?where HsColour
03:33:55 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
03:34:03 <dons> or at least use the ansi code lib in there
03:34:08 <Cale> Elifant: For including text that doesn't count as taking up space.
03:34:26 <Elifant> Cale: this is what I need, how to do it?
03:34:32 <Elifant> dons: I'll look
03:34:43 <Saizan> so, where do they use hashtables?
03:35:12 <malebria> Does anyone know a paper of OO in Haskell?
03:35:19 <apfelmus> Saizan: Perl,Python,Ruby,,Zombie and such languages
03:35:39 <malebria> just found it thanks.
03:37:16 <Elifant> Cale: any hint, link?..
03:37:24 <Cale> Elifant: Unfortunately, the HughesPJ library included with GHC doesn't have anything that would let you do that.
03:37:40 <Cale> Elifant: I wonder if I still have my implementation of Wadler's similar combinators.
03:37:41 <Saizan> apfelmus: yeah i know that, i mean, in which kind of application? to store object's dictionaries one could easily use a Map
03:37:58 <Cale> It would be easy if the Doc type weren't opaque
03:38:15 <apfelmus> yeah, the Doc type should be (Doc a) or something like that
03:38:50 <Elifant> Cale: I started to modify hughespj to work with instances of Pretty class instead of String. with plength and pstring methods. is this the right way to go?
03:38:59 <apfelmus> Saizan: indeed. i think hash table exist because they are easier to implement than balanced trees.
03:40:25 <apfelmus> Elifant: maybe. i guess that the pretty class reads
03:40:25 <apfelmus> class Pretty a where length :: a -> Integer ?
03:40:52 <Elifant> apfelmus: yes
03:42:07 <apfelmus> mmh, maybe you also need whitespace, perhaps with (hfill :: Integer -> a)
03:42:27 <Elifant> hfill returns 'n' spaces?
03:42:36 <apfelmus> yes.
03:43:07 <Elifant> ok. it seems I also need 'cat'...
03:43:13 <Elifant> cat :: a -> a -> a
03:44:46 <Cale> lisppaste2: url
03:44:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:45:00 <apfelmus> Elifant: i'm not sure. but i have an idea: to find a class 'Pretty' that is general enough, you may want to "abuse" the library.
03:45:13 <lisppaste2> Cale pasted "Wadler" at http://paste.lisp.org/display/35514
03:45:23 <Cale> er, I should have exported control.
03:45:26 <tuukkah> that's not quite the same hfill as latex has then. more like hspace
03:46:16 <Elifant> I think whether I need to define 'semi', 'comma' and so on for 'Doc a' or for 'Doc String' only...
03:46:18 <lisppaste2> Cale annotated #35514 with "add control to export list" at http://paste.lisp.org/display/35514#1
03:47:22 <Cale> That's untested, but I think it should work.
03:47:26 <apfelmus> Elifant: most likely, a good Pretty class emerges if you try to get the pretty printing library output graphical contents instead. So (instance Pretty Graphics.HGL.Grpahic where) or something like that. for pretty printing colored squares and diamonds
03:49:22 <apfelmus> Cale: control is not a good abstraction. while it works, it's more like \bf than \textbf
03:49:51 <Cale> meh, I like plain TeX :)
03:50:02 <apfelmus> Cale: i hate both :)
03:50:40 <Cale> Control is a terrible abstraction, but it lets you build the good abstractions you want in various cases.
03:51:47 <Cale> In this case, all we really need is to be able to tell it that given strings are not taking up space. If you wanted to be completely general, you'd generalise over the length function.
03:52:23 <Cale> (that is, add 'length' as a parameter to pretty)
03:52:37 <Elifant> it is already done :)
03:53:08 <Elifant> I hope license allows free modifications...
03:53:15 <Cale> License of what?
03:53:17 <Elifant> ye, BSD
03:53:21 <Elifant> HughesPj
03:53:24 <Cale> ah
03:54:34 <apfelmus> Cale: i doubt that. suppose you have "<bold>" `CTRL` "keyword" `TEXT` "</bold>" `CTRL`. why doesn't the (pretty) algorithm not break this "atomic" statement across multiple lines?
03:56:43 <Cale> um, because there's no `LINE` in it?
03:57:09 <Cale> That's part of the intermediate structure constructed by pretty anyway
03:57:16 <apfelmus> i you want to be sure, you'd better put that invariant into the types.
03:57:16 <apfelmus> HasLenght a => Doc a
03:57:16 <apfelmus> data Format a = F { value :: a , bold :: Boolean, italic :: Boolean, color :: RGB }
03:57:16 <apfelmus> instance HasLength a => (HasLength (Format a)) where
03:57:20 <Cale> not something what you'd give to pretty
03:57:30 <Cale> that*
03:58:11 <apfelmus> well, intermediate or not, control, Control and CTRL are not that different in this respect
03:58:20 <Cale> huh?
03:58:32 <Cale> Control and control are equal
03:58:40 <Cale> CTRL isn't at the same level
03:59:28 <Cale> CTRL, TEXT and LINE are where it's already been decided how it is to be laid out.
03:59:31 <apfelmus> sorry. i mean that (control "<bold>") <> (text "keyword") <> (control "</bold>") is very fragile
03:59:43 <Cale> It is?
04:00:04 <apfelmus> there is no static guarantee
04:00:16 <Cale> Well, of course there isn't.
04:00:26 <Templar2> >sort map snd [(1,'b'),(3,'a')]
04:00:32 <Templar2> not possible right?...
04:00:39 <Cale> > sort (map snd [(1,'b'),(3,'a')])
04:00:41 <lambdabot>  "ab"
04:00:47 <Cale> > sort . map snd $ [(1,'b'),(3,'a')]
04:00:48 <lambdabot>  "ab"
04:01:02 <Templar2> =(
04:01:08 <apfelmus> that's the point: you can give a static garantuee by chosing another abstraction
04:01:54 <Cale> apfelmus: How are you ever to know that "<bold>" doesn't take up space? I suppose you could actually parse SGML tags.
04:02:47 <Cale> You can't know that statically.
04:02:51 <apfelmus> you mean a non-proportional font?
04:03:14 <Cale> no, I'm not talking about fonts, I'm even assuming that all fonts are fixed-width
04:04:03 <apfelmus> what do you mean with "parse SGML tags"? i don't intend to have (Doc a) to interpret things inside a
04:04:10 <Cale> You can write  bolden s = control "<bold>" <> s <> control "</bold>", and then show that bolden is correct.
04:04:41 <apfelmus> sure you can show. but why to show this, when parametricity gives it for free?
04:05:05 <Cale> I don't see how you're going to statically determine that <bold> is going to take up 0 length on the page.
04:05:48 <Cale> Or, what are you claiming to be able to do?
04:06:20 <apfelmus> i'd eschew Control "bold" completely. so that pretty does not even know whether things are bold or not
04:06:33 <Cale> okay, then what?
04:06:47 <Cale> (this way, pretty doesn't know either)
04:07:25 <Cale> Control simply instructs the layout algorithm that "<bold>" does not actually appear, and so it shouldn't set aside space for it.
04:08:00 <apfelmus> i mean render :: HasLength a => Doc a -> [Line a]
04:08:01 <apfelmus> data Line a = Line { indent :: Integer, content :: [a] }
04:08:55 <apfelmus> Cale: "not appear" is not quite correct. that's the hole point :)
04:09:43 <Cale> I suppose that works. You can get a similar abstraction via this route too though.
04:10:21 <Cale> One might have a class Document a where toDocument :: a -> Doc
04:10:31 <apfelmus> yes, most likely, Control "bold" works. but it's "dangerous".
04:10:42 <Cale> I don't think it's any more dangerous either way.
04:10:56 <Cale> You could still mess up your definition of length in the HasLength class.
04:11:34 <apfelmus> sure. but that's not (pretty)'s fault, then.
04:12:00 <Cale> Nor is it pretty's fault if you put control around things you weren't supposed to.
04:12:34 <apfelmus> what i want to do is to make the pretty printing library agnostic with repsect to it's output format.
04:12:39 <apfelmus> *respect
04:13:30 <Cale> I'll admit that way is certainly more general.
04:13:51 <Cale> But for the problem of just setting fixed-width text, they're about the same.
04:14:47 <Cale> For non-fixed-width text, you have to generalise over lengths, so that there's someplace for the text extents to go.
04:15:29 <apfelmus> right, for fixed-width texts it's the same.
04:16:47 <apfelmus> i think i want to say that it's sad that the pretty printing library has a fixed output format, because the algorithm does not change for different output formats. the generalization comes for free.
04:17:23 <apfelmus> it's like having a function of type (a -> IO a) and knowing that it's pure.
04:17:58 <Cale> I'd say it's more like having a function  a -> IO a, and knowing that it's actually  a -> m a
04:18:25 <Cale> (or something like that)
04:18:34 <paolino> Hi, is there any data structure in the standard lib which keep elements ordered operation by operation ?
04:18:42 <Cale> paolino: Set?
04:19:28 <tuukkah> @type sortBy
04:19:30 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:19:30 <apfelmus> Cale: yes. indeed, you can substitute a -> Identity a :)
04:19:50 <paolino> hi apfelmus
04:20:06 <tuukkah> Templar2, i guess sortBy is what you wanted
04:20:13 <apfelmus> paolino: hi. still caring about you friends? :)
04:20:27 <paolino> Cale, where I can decide the ordering function
04:20:59 <paolino> apfelmus: sure
04:22:00 <paolino> Cale , actually I need 2 indexes on the elements :/
04:22:56 <Cale> apfelmus: that's not *quite* the same though
04:23:17 <rortian> is there a default ordering if you had a product of two sets of rationals?
04:23:40 <apfelmus> Cale: yes, of course. you probably want MonadRead m => a -> m a  or something like that
04:24:05 <Cale> apfelmus: I mean, in substituting for the Identity, you lose structure.
04:24:25 <Cale> (maybe not with this specific type, but in general)
04:24:42 <Cale> rortian: lexicographic?
04:25:21 <paolino> Cale ,and sets/maps are not supporting multiple entries with same value
04:25:35 <Cale> Well, you have Map a Integer
04:25:44 <rortian> is that the default?
04:25:45 <Cale> which can record the number of duplicates of something
04:25:52 <Cale> rortian: I'm not sure what you mean
04:25:56 <Cale> rortian: which type?
04:26:16 <apfelmus> Cale: do you mean that your prefer (return . f) :: (a -> m a) to a plain f, or do you mean something else? in this special case, any function (forall m . Monad m => a -> m a) must be pure, due to parametricity.
04:26:19 <Cale> (but probably, most things are sorted lexicographically)
04:26:19 <emk> Hmm. Where should I look for cabal-install? It used to be a standalone package...
04:26:34 <emk> Am I better off just upgrading my version of Cabal?
04:26:53 <rortian> @type Complex
04:26:55 <lambdabot> Not in scope: data constructor `Complex'
04:27:23 <Cale> apfelmus: I just mean that if you replace a polymorphic monad m with the identity monad, you can't go back, so you're losing structure of that computation.
04:27:56 <matthew_-> can someone point to some documentation that explains, in a type class, what the | foo -> bar stuff means in the class declaration?
04:28:28 <Cale> This is more interesting when the parameter is monadic than in this specific example, because, given the monad laws, you can't have anything but a pure function composed with return.
04:28:41 <huschi> matthew_-: it's calles functional dependencies, i think.
04:28:52 <paolino> yep
04:28:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies
04:28:57 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
04:28:57 <huschi> @google haskell functional dependencies
04:29:00 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
04:29:00 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac
04:29:03 <bakert> ?hoogle split
04:29:03 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
04:29:04 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
04:29:04 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
04:29:09 <paolino> one type at the price of two
04:29:41 <matthew_-> thanks all. googling type classes didn't get there. Cheers
04:29:54 <apfelmus> Cale: yes, that's what i mean. in this special case, (forall m . Monad m => a -> m a) is isomorphic to (a -> Identity a).
04:31:08 <rortian> @type Complex Rational
04:31:10 <lambdabot> Not in scope: data constructor `Complex'
04:31:10 <lambdabot>  
04:31:10 <lambdabot> <interactive>:1:8: Not in scope: data constructor `Rational'
04:31:49 <rortian> ouch, that is a correct type, isn't it?
04:32:35 <tuukkah> @type (a :: Complex Rational)
04:32:37 <lambdabot> Not in scope: `a'
04:32:43 <tuukkah> @type (undefined :: Complex Rational)
04:32:44 <lambdabot> Complex Rational
04:33:15 <paolino> two separated words ?
04:33:24 <lisppaste2> apfelmus annotated #35514 with "separate generation and convergence test" at http://paste.lisp.org/display/35514#2
04:33:32 <apfelmus> paolino: ^^
04:33:35 <paolino> @hoogle Complex
04:33:35 <lambdabot> Complex :: module
04:33:35 <lambdabot> Data.Complex :: module
04:33:35 <lambdabot> Data.Complex.Complex :: data Complex a
04:34:17 <rortian> @hoogle Rational
04:34:18 <lambdabot> Prelude.Rational :: type Rational
04:34:18 <lambdabot> Text.PrettyPrint.HughesPJ.rational :: Rational -> Doc
04:34:18 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
04:34:53 <apfelmus> oops, wrong annotation. i'll make a new one.
04:35:32 <Cale> hehe
04:35:38 <lisppaste2> apfelmus pasted "first generate, then prune" at http://paste.lisp.org/display/35516
04:36:45 <tuukkah> Complex a isn't in Ord but (a,a) is
04:37:44 <apfelmus> paolino: ^^. that's the canonical way of iterating things and testing convergence afterwards. i think that it can be applied to your problem quite nicely.
04:37:44 <paolino> tuukkah: complex numbers are not famous to be orderable
04:37:57 <rortian> so how would I make complex rational ordered if say I wanted it sorted in the real component first and then the complex second
04:38:22 <tuukkah> paolino, they are similar to (a,a) though...
04:38:23 <Cale> instance Ord (Complex Rational) where compare x y = ...
04:38:33 <paolino> apfelmus: thanks, I like lazyness when i'm not sleeping
04:39:00 <webus> hi
04:39:09 <Cale> hi
04:39:13 <paolino> tuukkah: (a1,a2) is ordered  first on a1, then on a2
04:39:27 <webus> i'm from Russia. And i newer use Haskell ? It's very different with C# ?
04:39:37 <rortian> cool, bare with me, I dabbled in haskell this summer
04:39:56 <Cale> webus: yes, very different from C#
04:40:18 <paolino> tuukkah:  do you think the real part is more ordeing significant then th imaginary one ?
04:40:20 <rortian> I was infatuated by infinite lists, wrote a program that gave the number of partitions of an interger and haven't done anything since
04:40:47 <rortian> its arbitrary, paolino, I just want a grid of them
04:40:50 <webus> <Cale> : What kind of software i can develop with Haskell ? This is compiled language or interpretator ?
04:41:29 <Cale> webus: Both. Haskell is general purpose, so there's no real restriction on what types of software you might write with it.
04:41:48 <tuukkah> paolino, i know there isn't one ordering that makes more sense than all the others, but that it is possible to have orderings
04:41:55 <micahcowan> webus, that's the wrong way to hilite someone: the way you wrote it (with the <>s) suggest that you are quoting Cale, rather than trying to get his attention.
04:41:56 <Cale> GHC is a compiler for Haskell, and it comes with GHCi, which is an interactive environment/interpreter.
04:42:19 <webus> thanks all
04:42:29 <Cale> also, there's hugs, which is another interpreter
04:42:38 <Cale> and yhc, which is a bytecode compiler
04:42:59 <Cale> and jhc, which is an experimental compiler with whole-program optimisations
04:43:15 <paolino> instance Ord (Complex Rational) where compare x y =  compare (re x,im x) (re y,im y)
04:43:22 <tuukkah> and how do we call runghc ?-)
04:43:28 <rortian> wait are rational Ord?
04:44:13 <tuukkah> sure
04:44:17 <paolino> @instances Ord
04:44:18 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
04:44:49 <tuukkah> um...
04:45:20 <rortian> this algebriac type shit is a beast if all you want are some rational complex numbers
04:45:52 <Cale> rortian: I don't think it's so bad
04:46:14 <tuukkah> @instances Rational
04:46:15 <lambdabot> Couldn't find class `Rational'. Try @instances-importing
04:46:19 <rortian> I'm just a little itimidated here Cale is all, just need to get started
04:46:26 <Cale> Rational isn't a class.
04:46:29 <tuukkah> @instances-importing Ord
04:46:30 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
04:46:35 <rortian> @type Pelude.Rational
04:46:37 <lambdabot> Couldn't find qualified module.
04:46:43 <rortian> @type Prelude.Rational
04:46:44 <lambdabot> Not in scope: data constructor `Prelude.Rational'
04:47:04 <Cale> rortian: If all you want are rational complex numbers, import Data.Complex and Data.Ratio, and use Complex Rational
04:47:06 <tuukkah> Cale, how would you ask lambdabot for the classes of a type?
04:47:35 <rortian> but then how use them in a function
04:47:35 <Cale> I don't think you can do that at the moment. In ghci, you can do  :info <typename>
04:48:49 <Cale> oh, that's odd
04:49:06 <Cale> realPart and imagPart are stupidly typed.
04:49:17 <Cale> Oh well, you can still pattern match.
04:49:48 <rortian> see, I'm a bit worried
04:50:25 <Cale> I think that perhaps you're expected to use the Complex class with RealFloat values, which basically means Float and Double
04:50:33 <Cale> er, Complex type
04:50:45 <Cale> (excuse me, I haven't slept :)
04:51:02 <Cale> However, that does seem like a rather arbitrary and silly restriction.
04:51:38 <rortian> shit, I thought haskell would be perfect for this
04:51:56 <rortian> I know, Complex should take any number class
04:52:12 <Cale> It really should, but that's not what H98 says.
04:52:27 <rortian> what were they thinking?
04:52:34 <Cale> Good question.
04:52:37 <rortian> algebriac number theory
04:52:44 <Cale> It's easy to implement your own.
04:52:47 <kzm> well - it will complicate some operations, perahps?
04:52:48 <rortian> seems like those people would love haskell
04:53:12 <Cale> kzm: I don't think so
04:53:14 <kzm> magnitude
04:53:20 <rortian> see Cale I'm newbie, not exactly look to reimplement them but i guess I could
04:53:20 <kzm> @type magnitude
04:53:22 <lambdabot> forall a. (RealFloat a) => Complex a -> a
04:53:37 <kzm> @type realPart
04:53:39 <lambdabot> forall a. (RealFloat a) => Complex a -> a
04:53:41 <bakert> ?hoogle find
04:53:42 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
04:53:42 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
04:53:42 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
04:53:48 <Cale> Right, you might need RealFloat for magnitude and phase
04:53:49 <rortian> alright you mind helping me get my complex rationals off the ground?
04:53:59 <Cale> You don't need it for Num
04:54:52 <Cale> rortian: I'll whip something up
04:54:53 <kzm> abs is defined as magnitude, no?
04:55:27 <rortian> damn, that'd be sweet Cale, I just did remember a sigfpe post that might he me
04:56:10 <kzm> and signum gives a unit in the same direction, so that needs RealFloat as well, I think.
04:57:30 <Cale> kzm: ah right
04:57:45 <Cale> We'll ignore those then.
04:59:11 <Cale> abs and signum shouldn't be in Num
04:59:56 <Cale> That, along with Num being a subclass of Eq and Show, probably is the most annoying part about the numeric classes. Most of the other stuff is actually pretty reasonable when you think about it.
05:00:32 <Cale> lisppaste2: url
05:00:32 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:01:03 <lisppaste2> Cale pasted "MyComplex" at http://paste.lisp.org/display/35519
05:01:38 <Cale> oh, and you wanted lexicographic ordering? Just add  Ord  to the deriving clause.
05:02:37 <Cale> you might want to add dummy methods for signum and abs to avoid the warnings.
05:02:44 <Cale> like  abs = undefined
05:03:55 <rortian> bitchen Cale, thanks a lot
05:05:44 <rortian> so are exponents automatically there or would I have to add that?
05:05:55 <Botje> :t (^)
05:05:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:06:05 <rortian> nice
05:06:30 <Botje> :t (**)
05:06:32 <lambdabot> forall a. (Floating a) => a -> a -> a
05:06:36 <Botje> :t (^^)
05:06:37 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
05:10:44 <Cale> Botje: I'd say that's actually the most insightful feature of the numeric prelude.
05:11:10 <Botje> perhaps i'll see the ligh someday
05:11:37 <Botje> right now it's "grumble, why is this giving type errors?" (randomly add fromIntegral) "gah, I needed ^^ instead of ^"
05:14:47 <rortian> is there a good java based hs98 implementation?
05:17:11 <bd_> ?where jaskell
05:17:11 <lambdabot> I know nothing about jaskell.
05:18:01 <bd_> rortian: http://jaskell.codehaus.org/ possibly
05:18:04 <lambdabot> Title: Jaskell - Home
05:20:20 <rortian> hmm, I'll have to give a try, I'm a sucker for working in Java, never got trained in C
05:20:46 <rortian> at Georgia Tech you learn Scheme, then Java, C was the next one I think
05:20:52 <bd_> I don't know if it's a complete implementation
05:21:13 <rortian> but it wasn't just a C course, it was the infamous C compiler course
05:22:06 <bd_> Sounds like a fun course, as long as I don't have to use scheme or Java to write the compiler ;)
05:22:12 <rortian> haha
05:23:01 <rortian> no, saw a roomate take it, they learned some sparc assembly, i think the compiler was written in C
05:23:42 <rortian> @type infix
05:23:44 <lambdabot> parse error on input `infix'
05:23:52 <bd_> ic
05:23:59 <bd_> I suppose the goal in the end was to bootstrap it?
05:24:24 <rortian> pretty sure
05:25:49 <rortian> http://www-static.cc.gatech.edu/classes/AY2004/cs2130_fall/slideindex.html
05:25:51 <lambdabot> http://tinyurl.com/23bslf
05:25:55 <rortian> there's the lectures
05:26:27 <rortian> gt's cs class websites stay up for eternity, can be a really good resource
05:27:09 <rortian> Cale: what does the 6 mean for infix?
05:27:27 <Cale> It's a precedence level
05:27:41 <Cale> You can get a list of the other precedences of things in the prelude.
05:27:52 <Cale> I just copied the precedence from Data.Complex
05:28:01 <rortian> why doesn't lambdabot know about it
05:35:11 <Cale> It might, I don't know
05:35:18 <Cale> @src (+)
05:35:18 <lambdabot> Source not found. You type like i drive.
05:35:25 <Cale> @src +
05:35:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:35:36 <Cale> Nope, I don't know.
05:37:04 <rortian> ?hoogle infix
05:37:04 <lambdabot> Prelude.infix :: keyword
05:37:05 <lambdabot> Data.Generics.Basics.Infix :: Fixity
05:37:05 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
05:38:53 <bakert> ?hoogle find
05:38:54 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
05:38:54 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
05:38:54 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
05:39:10 <Templar2> whats the difference between a function of type   A -> B   and a function of type    A -> IO B  ?
05:39:17 <augustss> LB needs something like :info
05:39:54 <augustss> The latter might do I/O while computing the B.  And you have to use the B in a slightly different way.
05:41:00 <rortian> where can I learn about the identation rules
05:41:01 <Templar2> augustss aha, ok, but are there things I can do with one of them and not do with the other?
05:41:28 <aleator> I seem to have a largish haskell program that leaks a lot of memory. Whats the good way to debug it?
05:41:49 <augustss> Templar2: the A->B is better in some way, because you can turn that into A->IO B, but not vice versa
05:42:24 <augustss> Templar2: Once you have a type with IO it will "taint" your program from that point on.
05:43:14 <Templar2> augustss aha, so you can say that the dessign of the program is fixed with IO and not the other one?
05:43:37 <augustss> Templar2: yeah, kind of
05:43:51 <earthy> aletor: find the foldl's
05:43:56 <augustss> Templar2: there are tutorials about this very subject :)
05:44:12 <augustss> aleator: use heap profiling to find the leaks
05:44:16 <Templar2> augustss ok, thanks a lot for your help =)
05:44:17 <earthy> aletor: otherwise, do memory profiling.
05:47:14 <wolfgangbeck> how can a 'atomically (readTVar x)' block if there are no other threads yet?
05:52:36 <Igel> wolfgangbeck: do you have sample-code?
05:53:12 <wolfgangbeck> it's too long to post, i'll try to simplify it
05:53:59 <wolfgangbeck> but from my understanding atomically shouldnt block unless there is a 'retry' somewhere or there is serious contention
05:54:14 <shapr> @users
05:54:14 <lambdabot> Maximum users seen in #haskell: 311, currently: 294 (94.5%), active: 41 (13.9%)
05:54:53 <Igel> you're right, afaik
05:55:14 <shapr> glguy: Nice app! And you created it quickly!
05:57:00 <musasabi> wolfgangbeck: I don't think there is any guarantee about not blocking.
05:57:19 <wolfgangbeck> even if there's is only a single thread?
05:58:14 <musasabi> it should finish eventually
05:58:26 <wolfgangbeck> well, it doesnt
06:02:50 * yaxu tries to understand haskore
06:02:54 <wolverian> http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html -- stevey's new post mentions haskell a few times (in a rather negative way :)
06:02:55 <lambdabot> Title: Stevey's Blog Rants: The Pinocchio Problem
06:03:10 <shapr> uh oh
06:03:18 <shapr> yaxu: Are you looking at the new or old Haskore?
06:03:30 <yaxu> shapr: latest from darcs
06:03:51 <yaxu> shapr: i'm a bit lost because the pdf i've generated has broken contents and references
06:04:32 <tuukkah> yaxu, if it's from latex source, did you remember to run latex several times?
06:06:03 <yaxu> tuukkah: i just did make pdf
06:06:12 <yaxu> tuukkah: is it worth trying running that a couple of times?
06:06:26 <yaxu> tuukkah: i'm not so good with LaTeX, i'm a LyX weenie :)
06:07:10 <tuukkah> it might be worth it, yes
06:07:23 <yaxu> tuukkah++ # it worked!
06:07:48 <yaxu> that's so not functional :)
06:07:57 <tuukkah> i'd say that's a bug in the makefile, it should take care of running latex multiple times
06:08:14 <micahcowan> yaxu, the rule of thumb is to run three times, I believe.
06:08:32 <micahcowan> And yeah, what tuukkah said :)
06:09:29 <cain--> hi all
06:09:47 <cain--> i have the program
06:09:47 <cain--> magic :: Int -> Int -> [Int]
06:09:47 <cain--> magic 0 _ = [] -- m1
06:09:47 <cain--> magic m n = m : (magic n (m+n)) -- m2
06:09:47 <cain--> getIt :: [Int] -> Int -> Int
06:09:47 <cain--> getIt [] _ = 0 -- g1
06:09:49 <cain--> getIt (x:xs) 1 = x -- g2
06:09:51 <cain--> getIt (x:xs) n = getIt xs (n-1) -- g3
06:10:09 <cain--> and the function call
06:10:10 <cain--> getIt (magic 1 1) 3
06:10:22 <cain--> magic 1 1 alone doesnt terminate
06:10:23 <yaxu> it's surprising how important it is to read the contents, even if you're reading linearly
06:10:29 <cain--> but getIt (magic 1 1) 3
06:10:44 <cain--> does terminat
06:11:03 <cain--> howcome?
06:12:04 <Philippa> wolverian: "Quake had QuakeC, which is still, I think, the gold standard for PC game scripting, but my info is a little dated, since for the past five years or so I've played mostly console games, which are sadly all deader than a coffin-nail." - someone doesn't know what he's talking about...
06:12:14 <Philippa> I mean, QC was nice for a quick hack, but it /stank/ as a language
06:12:18 <pejo> cain, getIt doesn't use all elements from the list that magic generates.
06:12:20 <Philippa> I mean, I wrote hangman in it once, sure...
06:12:27 <Philippa> ...this is a language where the only operation on strings is equality
06:13:02 <chessguy> cain--, this is the beauty of lazy evaluation
06:13:44 <chessguy> > take 4 [1..]
06:13:45 <lambdabot>  [1,2,3,4]
06:14:09 <chessguy> notice that [1..] doesn't terminate, but you can still pass it to a function and have it terminate
06:14:52 <cain--> but if magic 1 1 downt terminate, the program is logically stuck in this function
06:14:52 <chessguy> let magic 0 _ = []; magic m n = m : (magic n (m+n)) in magic 1 1
06:14:56 <chessguy> > let magic 0 _ = []; magic m n = m : (magic n (m+n)) in magic 1 1
06:14:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:15:00 <cain--> so how does is come back to getIt
06:16:13 <huschi> what's the decl magic 0 _ = [] for?
06:16:17 <pejo> cain, the program will only run magic as much as it needs to get a final result for "getIt (magic 1 1) 3", it doesn't run magic "to the end".
06:16:36 <Cale> Outermost-first
06:16:42 <Cale> getIt happens first
06:16:49 <cain--> the program makes no sense its for learning purposes
06:17:24 <cain--> ahh ok
06:17:27 <cain--> that makes sense
06:18:22 <cain--> so its runs magic until it provides a valid list?
06:18:38 <Cale> Well, let's actually evaluate it
06:18:49 <Cale> getIt (magic 1 1) 3
06:19:08 <Cale> First thing, it needs to know if magic 1 1 is empty or not
06:19:29 <Cale> the magic 0 _ case doesn't match
06:19:29 <syntaxfree> Cale: you should write the outermost-first explanaion as a small tuorial.
06:19:32 <kowey> (this might actually turn into a nice tutorial on laziness / graph reduction)
06:19:45 <Cale> So magic 1 1 = 1 : (magic 1 (1+1))
06:19:59 <yaxu> "when in doubt, run it again" - not the kind of advice you'd expect on #haskell
06:20:24 <cain--> yes
06:20:26 <Cale> now, getIt's last case will match
06:20:33 <chessguy> outermost-first? you mean lazy?
06:20:40 <pejo> syntaxfree, atleast YAHT covers lazy evaluation.
06:20:58 <syntaxfree> I know. But Cale's explanation on that is short & good.
06:21:00 <Cale> getIt (1:(magic 1 (1+1))) 3 = getIt (magic 1 (1+1)) (3-1)
06:21:00 <kowey> yaxu: there's a handy little program in Python ;-) which figures out the run-it-N-times stuff for you, i think... it's called 'rubber'
06:21:09 <cain--> is there any program that demonstrates the evaluation visually?
06:21:46 <Cale> and then getIt tries to match again, which forces some more evaluation of magic
06:21:53 <shapr> Cale has some neat animated pix that show foldr and foldl
06:21:55 <Cale> as well as the evaluation of that 3-1
06:21:59 <Cale> I do?
06:22:03 <Cale> hmm
06:22:09 <syntaxfree> trace in scheme environments is fun.
06:22:28 <Cale> There's those Hops animations
06:22:29 <syntaxfree> maybe ghci could show the trace over some AST.
06:22:35 <syntaxfree> (It seems there are two)
06:22:47 <Cale> But I don't think those are foldr and foldl.
06:23:05 <Cale> I've written out some outermost evaluations for foldr and foldl before
06:23:49 <Cale> cain--: the gist of it is that the list produced by magic is only demanded as far as needed to get that 3rd element.
06:23:59 <Cale> Demand is generated by pattern matching
06:24:11 <cain--> okok
06:24:14 <cain--> but
06:24:24 <Cale> Let's do a simpler example...
06:24:27 <cain--> the list is never finished which is generated in magic
06:24:45 <Cale> from n = n : from (n+1)
06:25:16 <Cale> (x:xs) !! 0 = x
06:25:24 <Cale> (x:xs) !! n = xs !! (n-1)
06:25:41 <Cale> (from 0) !! 3
06:25:56 <Cale> = (0 : from 1) !! 3
06:26:10 <Cale> = (from 1) !! 2
06:26:18 <Cale> = (1 : from 2) !! 2
06:26:25 <Cale> = (from 2) !! 1
06:26:35 <Cale> = (2 : from 3) !! 1
06:26:42 <Cale> = (from 3) !! 0
06:26:48 <Cale> = (3 : from 4) !! 0
06:26:52 <Cale> = 3
06:27:06 <Cale> That's basically what's going on there.
06:27:20 <ButterNaan> hi
06:27:24 <Cale> hello
06:27:29 <chessguy> nice illustration
06:27:32 <cain--> ok let me wathc it over
06:27:45 <ButterNaan> whats wrong in this line
06:27:49 <ButterNaan> maximum $ filter isPalindrome $ [a * b | a <- [100 .. 999], b <- [100 .. 999]]
06:27:52 <Cale> So even though (from 0) is an infinite list, we never end up needing it all.
06:28:16 <chessguy> @type isPalindrome
06:28:17 <lambdabot> Not in scope: `isPalindrome'
06:28:25 <kowey> cain-- : there's a trick to understanding this (i don't get this stuff deeply either)...
06:28:26 <ButterNaan> isPalindrome n = str == reverse str
06:28:44 <matthew_-> then you'll need show in there
06:28:46 <ButterNaan> chessguy: ^^
06:28:49 <chessguy> @type reverse
06:28:51 <lambdabot> forall a. [a] -> [a]
06:28:54 <kowey> cain-- : you're thinking that functions like 'magic' and 'from' produce some kind of infinite list and "return" them, right?
06:29:00 <chessguy> reverse needs a list
06:29:05 <cain--> yes
06:29:07 <Cale> The trick is thinking in terms of demand. What parts of the data structure do you really *need* to look at in order to evaluate the thing?
06:29:19 <ButterNaan>         where str = show n
06:29:20 <cain--> a list
06:29:20 <kowey> cain-- : here's the secret (or a variant of it)
06:29:21 <ButterNaan> this?
06:29:23 <trurl_> chessguy: String = [Char]
06:29:26 <kowey> cain-- : it doesn't work that way
06:29:42 <chessguy> trurl_, yes i know. he didn't say he was doing show n before
06:29:43 <kowey> cain-- : from 0 returns immediately! what does it return?... oh... 0 : from 1
06:29:44 <Cale> The key thing to realise here is that values in Haskell are represented at runtime by code.
06:30:13 <cain--> but from 0 has no value
06:30:20 <Cale> Or, I should probably use the simpler model.
06:30:25 <ButterNaan> chessguy: those are the 3 lines only..
06:30:28 <cain--> because it is always replaced by itself
06:30:31 <ButterNaan> but i get error in line 3
06:30:39 <chessguy> what error?
06:30:43 <Cale> cain--: right, it's not a reducible expression
06:30:50 <ButterNaan> ERROR "some.hs":3 - Syntax error in declaration (unexpected symbol "isPalindrome")
06:30:57 <ButterNaan> that error
06:31:09 <Cale> Do you know about pointers and such?
06:31:22 <cain--> no
06:31:34 <cain--> nit in haskell
06:31:42 <Cale> I mean in the same sense as in C
06:31:47 <Botje> ButterNaan: remove the $ before the list comprehension
06:31:50 <cain--> yes i do
06:31:53 <Cale> okay
06:32:06 <ButterNaan> Botje: hmm
06:32:10 <Cale> So one way to represent Haskell values would be as a boolean flag together with a pointer.
06:32:14 <twanvl> > let isPalindrome n = let str=show n in str == reverse str in maximum $ filter isPalindrome $ [a * b | a <- [100 .. 999], b <- [100 .. 999]]
06:32:22 <lambdabot>  906609
06:32:25 <Cale> If the flag is not set, then the pointer points to code which will run and produce the value.
06:32:45 <Cale> When it does this, it sets the flag, and reassigns the pointer to point at the computed value.
06:32:49 <ButterNaan> twanvl: howd it work?
06:33:07 <Cale> If the flag is set, then it just looks up the value.
06:33:55 <Cale> That's not quite how it's implemented in GHC, but it's close enough to give some idea.
06:34:03 <cain--> hmm ok
06:34:28 <Cale> So if I say   xs = from 0
06:34:32 <cain--> but how does that answer the problem
06:34:38 <Cale> it doesn't go computing  from 0 right away
06:35:29 <Cale> When xs comes into scope, a pointer to code for from 0 is constructed (in reality, you'd have a separate pointer to the 0 at least)
06:35:43 <Cale> together with a flag set to false
06:35:52 <Cale> because it's not been evaluated yet
06:35:55 <dons> who wants serialisation!
06:35:56 <dons> 100MB of Word32 in chunks of 16: 57.60MB/s
06:36:08 <Cale> dons: nice :)
06:36:21 <Cale> when we do a pattern match, this code is run
06:36:31 <Cale> and it either is going to return a value for []
06:37:02 <Cale> or a (:) structure together with some parameters, which themselves are pointers with flags.
06:37:35 <Cale> That might be too low level an approach, but I'm not completely sure where you're confusion is :)
06:37:45 <darrint> Are there any libraries which allow an "erlangly" approach to parallelism in haskell?
06:38:19 <chessguy> cain--, you might benefit from watching the SICP video lecture series
06:38:20 <paolino> you mean concurrency ?
06:38:21 <dons> yeah, Control.Concurrent.Chan ?
06:38:29 <dons> or say, Control.Concurrent
06:38:38 <dons> dive around in there for your smp parallel haskell
06:38:42 <dons> ?docs Control.Concurren
06:38:42 <lambdabot> Control.Concurren not available
06:38:45 <dons> ?docs Control.Concurrent
06:38:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
06:38:56 <chessguy> hey, LB isn't all smart-mouth any more
06:39:12 <Cale> cain--: I think the best way to look at it is that in most programming languages, functions are evaluated innermost leftmost, whereas lazy evaluation is outermost leftmost, with a trick that when function parameters are duplicated in the body, we don't recompute each time.
06:39:19 <kowey> what's serialisation? does that mean pickles?
06:39:20 <dons> ?src chessguy
06:39:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:39:24 <dons> kowey: yeah
06:39:26 <Cale> cain--: here's a simple example which I think illustrates it...
06:39:27 <bakert> kowey, yes
06:39:30 <kowey> oh, nice!
06:39:30 <Cale> double x = x + x
06:39:44 <cain--> ok
06:39:47 <Cale> Let's evaluate  double (double 5) in a strict language, and then in a lazy one.
06:39:48 <int-e> Cale: hah. that's almost valid C ;)
06:40:09 <cain--> ok
06:40:20 <Cale> double (double 5) = double (5 + 5) = double 10 = 10 + 10 = 20
06:40:22 <bakert> Should I remove calls to Debug.Trace.trace from live code?
06:40:24 * shapr boings
06:40:26 <Cale> that's in a strict language
06:40:38 <Cale> We always pick the innermost thing to evaluate first
06:40:49 <cain--> yes
06:40:51 <shapr> dons: I want serialisation!
06:40:55 * shapr hOps
06:40:57 <Cale> Now let's do outermost-first evaluation, without the laziness trick of saving duplicate work
06:41:02 <darrint> dons: I see. Thanks for the pointer. While I don't see message-passing/pattern-matching, it should be buildable.
06:41:14 <Cale> double (double 5) = double 5 + double 5
06:41:17 <chessguy> there's also a really good explanation of the contrast between different evaluation strategies in one of the first videos of the haskell lectures
06:41:26 <Cale> = (5 + 5) + double 5
06:41:32 <Cale> = (5 + 5) + (5 + 5)
06:41:37 <Cale> = 10 + (5 + 5)
06:41:39 <Cale> = 10 + 10
06:41:41 <Cale> = 20
06:41:43 <cain--> ok
06:41:57 <Cale> Same result, different path to get there
06:42:15 <Cale> It turns out that if any evaluation path works, then outermost first works
06:42:19 <cain--> yes and lazy would save double 5 so it doesnt have to recalculate it
06:42:24 <Cale> right
06:42:37 <Cale> Basically, it would look like...
06:42:48 <chessguy> http://lambda-the-ultimate.org/node/1303
06:42:49 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
06:42:49 <Cale> double (double 5) = let x = double 5 in x + x
06:43:03 <cain--> ok
06:43:04 <dons> shapr: we're about 10x NewBinary now
06:43:05 <Cale> = let x = 5 + 5 in x + x
06:43:10 <Cale> = let x = 10 in x + x
06:43:13 <Cale> = 10 + 10
06:43:14 <Cale> = 20
06:43:15 <cain--> but how is this done in my eyample?
06:43:41 <Cale> Your example is complicated slightly by the need to pattern match, but only a little
06:43:44 <shapr> dons: w00h00!
06:44:16 <Cale> If, in order to evaluate the outermost function, we need to pattern match to work out which case to take
06:44:50 <Cale> what happens is that things are evaluated left to right until it can be determined if the pattern matches
06:44:59 <Cale> (and the patterns are tried from top to bottom)
06:45:06 <cain--> ahh ok
06:45:23 <cain--> so it tries to evaluate magic 1 1 until it matches the requirement
06:45:24 <Cale> But not fully evaluated, just enough to tell if the pattern matches!
06:45:30 <psnl> is there a list remove in a library somewhere?
06:45:38 <Cale> getIt is defined in terms of (x:xs)
06:45:48 <cain--> yes
06:45:51 <Cale> so it just has to tell if the list is empty or not there
06:46:04 <Cale> and whether the number is 0 or not will force the number to be evaluated
06:47:21 <Cale> Thinking in terms of the demand generated like this can be a little unnatural at first if you're used to strict languages.
06:47:41 <cain--> is it right now that it evaluates magic and checks after every operation it the result matches obe of the patterns of getit?
06:47:41 <chessguy> will it actually do one evaluation of magic there, to tell whether or not the list is empty?
06:47:43 <Cale> Personally, I found it quite nice, because it sort of mimics the way that I'd do things on paper.
06:47:49 <Cale> yes
06:48:19 <Cale> and it will bind x to the first element (without evaluating it) and xs to the rest (without evaluating that)
06:48:45 <cain--> ok one moment
06:49:15 <cain--> ohhh now i see
06:49:33 <cain--> so its doent care if magic is finished or not
06:49:54 <Cale> Right.
06:49:57 <cain--> but how does it get to an end then?
06:50:04 <ButterNaan> >sum (map sq [1 .. 100] ) - sq (sum [1 .. 100]) where sq = \x -> x * x
06:50:14 <Cale> Looked at another way, magic finishes, but returns a data structure which contains a call back to itself.
06:51:12 <Cale> magic 1 1, when evaluated, produces 1 : (magic 1 (1 + 1))
06:51:38 <Cale> and the evaluation doesn't go any farther unless it's forced to by more pattern matching
06:51:38 <cain--> yes
06:51:54 <cain--> ohh ok
06:52:02 <chessguy> cain--, is the result a 1?
06:52:07 <cain--> so becase the head of the list is an actuel number
06:52:15 <Cale> In some sense, pattern matching is the only thing which causes anything to happen. You might make another exception for actual IO.
06:52:24 <cain--> no the result is two
06:52:36 <cain--> beause getit is called 2 times
06:53:00 <chessguy> getIt (magic 1 1) 3 == 2?
06:53:05 <cain--> y
06:53:30 <cain--> and now i understand why
06:53:41 <chessguy> hmm, i'm getting 1 when evaluating by hand. must be doing something wrong
06:54:26 <Cale> getIt (magic 1 1) 3 = getIt (1 : magic 1 (1+1)) 3
06:54:36 <Cale> = getIt (magic 1 (1+1)) 2 = getIt (1 : magic (1+1) (1+(1+1))) 2
06:55:32 <Cale> = getIt (magic (1+1) (1+(1+1))) 1 = getIt ((1+1) : magic (1+(1+1)) ((1+1)+(1+(1+1)))) 1
06:55:52 <Cale> = getIt (magic (1+(1+1)) ((1+1)+(1+(1+1)))) 0
06:55:59 <paolino> anyone knows how to tag from 0 to 1 a set of real numbers , so that randomly eliminating them by their tag gives back a given distrinution ?
06:56:23 <paolino> *distribution
06:56:43 <Cale> = getIt ((1 + (1+1)) : magic ((1+1)+(1+(1+1))) ((1+(1+1))+((1+1)+(1+(1+1))))) 0
06:57:02 <Cale> er, sorry
06:57:10 <Cale> your getIt stops with 1
06:57:15 <cain--> y
06:57:24 <Cale> getIt ((1+1) : magic (1+(1+1)) ((1+1)+(1+(1+1)))) 1
06:57:31 <Cale> = 1 + 1
06:57:32 <Cale> = 2
06:57:40 <cain--> ;)
06:57:42 <cain--> crazy
06:58:25 <dons>   /win 11
06:58:36 <Cale> And those additions are not done until the very end, because they're always innermost. This can be a waste of memory or stack space sometimes, so there devices for making things stricter when that's desirable.
06:58:45 <Cale> there are*
06:58:50 <chessguy> $!
06:58:57 <Cale> yeah $! and seq
06:59:07 <cain--> ok
06:59:19 <chessguy> definitely worth a writeup on a wiki page
07:00:16 <cain--> ok thanks for your help i thick i understand now
07:00:20 <Cale> But it's best to ignore those for a while, and come back to them when your program is having problems with stack overflows or too much memory usage. Adding strictness is not something which should be done all over, it's usually enough to add just a tiny amount in the right place.
07:00:37 <cain--> ok
07:00:55 <Cale> Profiling will help find that place in a large program
07:01:25 <Cale> Also, most programs can be written with no strictness annotations and have no trouble
07:01:28 <chessguy> technically, aren't the subtractions delayed too?
07:01:40 <Cale> no, those are always forced by the pattern match
07:01:49 <Cale> I didn't show them because of that.
07:01:52 <chessguy> well, but they're done as a separate step
07:01:54 <Cale> yeah
07:02:12 <Cale> I probably could have shown them and reduced them on the next step.
07:03:25 <cain--> getIt (1 : magic (1+1) (1+(1+1))) 2
07:03:31 <cain--> where does this come from?
07:03:35 <cain--> the bold part
07:03:49 <Cale> er, I don't see bold
07:04:01 <cain--> (1+(1+1))
07:04:19 <Cale> magic m n = m : magic n (m+n)
07:04:23 <Cale> so
07:04:38 <Cale> magic 1 (1+1) = 1 : magic (1+1) (1 + (1+1))
07:04:40 <cain--> ok yes
07:04:43 <cain--> i got it
07:05:22 <Cale> If we were printing the list as we went along, the big trees of 1's wouldn't get so big
07:05:26 <chessguy> getIt (magic 1 1) 3
07:05:26 <chessguy> =getIt (1 : (magic 1 (1+1)) 3
07:05:26 <chessguy> =getIt (magic 1 (1+1)) (3-1)
07:05:26 <chessguy> =getIt (magic 1 (1+1)) 2
07:05:26 <chessguy> =getIt (1 : (magic (1+1) (1+(1+1)))) 2
07:05:27 <chessguy> =getIt (magic (1+1) (1+(1+1))) (2-1)
07:05:29 <chessguy> =getIt (magic (1+1) (1+(1+1))) 1
07:05:30 <chessguy> =getIt ((1+1) : (magic (1+(1+1)) (1+(1+(1+1))))) 1
07:05:32 <chessguy> =(1+1)
07:05:33 <fridim> fibonacci ?
07:05:35 <chessguy> =2
07:05:38 <Cale> fridim: yeah
07:05:52 <Cale> cain--: here's another way to write fibonacci :)
07:06:08 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:06:09 * matthew_- wonders how many versions will get presented!
07:06:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:06:36 <fridim> fib n = fib (n - 1) + fib (n - 2)
07:06:39 <cain--> where is fibbonacci?
07:06:45 <cain--> -b
07:06:53 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- this one
07:06:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:06:57 <chessguy> Cale, are you interested in writing this up in a wiki page? because if not, i probably will
07:07:00 <paolino> people nevers abandon haskell before knowing fibonacci
07:07:03 <Cale> It's essentially what magic 0 1 produces
07:07:21 <matthew_-> ?where Cale blog
07:07:21 <lambdabot> http://cale.yi.org/
07:07:22 <Cale> chessguy: go for it, I'm a little sleepy :)
07:07:34 <chessguy> magic 1 1 you mean
07:07:34 <velco> I vaguely remember a discussion somewhere on the topic whether pattern matching is a flow control or not ? Does anyone remember such thing ?
07:07:43 <Cale> chessguy: not the way I wrote it :)
07:07:47 <chessguy> oh, nm
07:07:52 <paolino> and fibonacci due most of his fame to #haskell
07:07:58 <chessguy> i thought fib usually started at 1
07:08:08 <Cale> sometimes 0 sometimes 1
07:08:10 <vorago> Uhm, hi.
07:08:14 <Cale> Hello
07:08:27 <chessguy> vorago, salutations and other such pleasantries
07:08:59 <vorago> (-; I wasn't prepare for so "full" channel. ;)
07:09:04 <Cale> :)
07:09:15 <Cale> @users
07:09:16 <lambdabot> Maximum users seen in #haskell: 311, currently: 299 (96.1%), active: 49 (16.4%)
07:09:39 <chessguy> i can leave if it would make you feel better :)
07:09:47 <Cale> hehe
07:09:50 <vorago> Just wanted to ask if you can advertise me some haskell compiler for linux. Rather opensource. ;-) But i can try to look it up on the /topic website.
07:09:56 <Cale> ghc
07:09:58 <sjanssen> vorago: ghc
07:10:00 <vorago> chessguy, no, stay. ;)
07:10:12 <Cale> Definitely hang out and ask lots of questions :)
07:10:18 <paolino> we are going to beat #python  in 6 months
07:10:22 <vorago> Glassgow? Okay.
07:10:30 <sjanssen> vorago: your distro probably even has a package for ghc
07:10:30 <Cale> We like questions, especially beginner questions :)
07:10:42 <vorago> -bin after ghc made me suspicious...
07:10:48 <vorago> sjanssen, sure it has. ;)
07:10:52 <Cale> If you're on debian, apt-get install hc6
07:10:53 <Cale> er
07:10:55 <Cale> If you're on debian, apt-get install ghc6
07:11:07 <matthew_-> if you're not on debian, explain yourself! ;-)
07:11:13 <vorago> Actually it's merging now. (-;
07:11:18 <vorago> but I have a computer with debian also!
07:11:21 <sjanssen> vorago: ghc is written in Haskell, so your distro provides a ghc-bin so you don't have to bootstrap
07:11:25 <vorago> I just left it somewhere here...
07:11:48 <Cale> vorago: You really really don't want to compile ghc unless you have something like an 8 core machine
07:11:49 <vorago> sjanssen, hah I see. Solves 'hen and egg' problem.
07:12:13 <Cale> vorago: It's a massive waste of time and heat when there are perfectly good binaries :)
07:12:30 <vorago> Cale, it's much simpler for me to compile it however.. ;)
07:12:45 <Cale> You have to have ghc installed already to compile it
07:12:54 <Cale> So just use the bin package
07:12:58 <vorago> If.. this ghc-bin is just for compiling ghc.....
07:12:59 <matthew_-> can you use hugs to compile ghc?
07:13:02 <vorago> Hm. It's true.
07:13:06 <sjanssen> Cale: it's pretty manageable with two cores, my core duo compiles ghc+extralibs in less than an hour
07:13:21 <matthew_-> errr, ignore that dumb question... ;-(
07:13:21 <vorago> Cale, if it's only compiled for 64 bit procesor i will use it.
07:13:30 <vorago> Cale, if not i will compile from the source. (-;
07:14:09 <Cale> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-x86_64-unknown-linux.tar.bz2
07:14:11 <lambdabot> http://tinyurl.com/ypjyyy
07:14:13 <Cale> In case it's not
07:15:47 <hyrax42> ButterNa1n: the way you were solving that euler problem will turn out inefficient
07:16:27 <hyrax42> you'll compute ~10^6 products before finding the maximal palindrome
07:16:28 <ButterNa1n> hyrax42?
07:16:35 <ButterNa1n> oh
07:16:47 <ButterNa1n> hmm
07:16:57 <hyrax42> the best solution won't use a list comprehension, at least I think not
07:17:11 <hyrax42> as you want to control which of the numbers you go down with
07:17:16 <ButterNa1n> hyrax42: of course there has to be a better way :)
07:17:43 <hyrax42> so you start at 999*999, if that does'nt work, 999*998 and then the larger of 999*997 and 998*998 and so on downwards
07:17:56 <chessguy> hmmm
07:18:00 <chessguy> hey Cale?
07:18:10 <hyrax42> of course, I don't reember the solution I wrote
07:18:13 <hyrax42> probably a list comp :p
07:18:16 <vorago> 'Yet Another Haskell Tutorial' is ok, or would you propose learning from something else?
07:18:19 <Cale> chessguy: yeah?
07:18:26 <Cale> vorago: it's pretty good
07:18:34 <hyrax42> vorago: yaht is very good in the early parts
07:18:36 <chessguy> in getIt (magic 1 (1+1)) (3-1)
07:18:37 <hyrax42> to get the basics
07:18:42 <Cale> yeah
07:18:48 <hyrax42> I didn't like the later parts...
07:18:51 <chessguy> it'll expand the function call even before it does the subtraction, won't it
07:18:53 <Cale> hyrax42: I agree
07:19:12 <hyrax42> but in that vein, the new haskell intro textbook is very good
07:19:13 <Cale> The wikibook is getting better all the time
07:19:15 <chessguy> to decide whether it will match with getIt [] _
07:19:16 <hyrax42> at least to ch5 where I read the preview
07:19:37 <vorago> Cale, hyrax42 ok, thank you. ;-) One more, *dumb* question.
07:19:44 <vorago> Cale, hyrax42 is haskell worth learning? ;)
07:19:50 <hyrax42> there are no stupid questions
07:19:54 <hyrax42> only stupid people ;)
07:20:05 <vorago> hyrax42, och, so true. ;-)
07:20:09 <hyrax42> vorago: you won't get an unbiased opinion
07:20:13 <hyrax42> but I think so
07:20:24 <vorago> I just want to hear your opinion. (-;
07:20:32 <hyrax42> well I like it quite a bit
07:20:46 <chessguy> the real question is whether other languages are worth learning :)
07:20:54 <hyrax42> I haven't done anything "big" in it
07:20:59 <chessguy> (to which the answer is 'yes', of course)
07:21:00 <vorago> chessguy, hah.
07:21:04 <hyrax42> but then again, I haven't done anything "big" in any other language
07:22:02 <chessguy> i think Cale's falling asleep :)
07:22:30 <hyrax42> I am looking out for "big" things to do in haskell though, just haven't come up with any terribly compelling projects yet
07:22:48 <earthy> haskell definitely is worth learning
07:23:00 <earthy> if only for the experience of messing your mind up
07:23:42 <vorago> earthy, ;-)
07:24:09 <matthew_-> mmm. In SPJ's tackling the awkward squad, Channel is a type. In Chan.hs, Chan is data, but other than that, they're the same. Is there any reason why to use one over the other given otherwise identical content?
07:24:20 * earthy actually wrote an ADT preprocessor for C when he was doing C code for his master's
07:24:33 <earthy> with 'free' memory management
07:24:53 <hyrax42> why
07:25:10 <hyrax42> or was it part of the project?
07:25:14 <randomless> earthy: out of curiosity, what does 'free' mean here?
07:25:24 <hyrax42> or rather, why not a language that provides that
07:25:30 <earthy> because I couldn't stand having to define structs with unions by hand
07:25:42 <earthy> I had to use C
07:25:59 <earthy> randomless: I wrote all memory management myself, but it was completely taken care of by the ADT preprocessor
07:26:08 <hyrax42> youchies
07:26:15 <hyrax42> preproc written in?
07:26:17 <randomless> earthy: complex!
07:26:22 <earthy> hyrax42: C. :)
07:26:29 <hyrax42> :'(
07:26:39 <earthy> ah, it wasn't too bad
07:26:51 <earthy> I never got round to adding true generic functions though
07:27:01 <Svrog> is there an updated version of afrp somewhere online?
07:27:20 <earthy> yampa?
07:27:24 <Svrog> yeah
07:27:39 <Svrog> i checked darcs.haskell.org repository but the yampa directory is pretty much empty
07:28:30 <Svrog> are there any other newer frp libraries around?
07:32:55 <LoganCapaldo> @vixen No, Haskell can't possibly conceive of plugins, no sir
07:32:55 <lambdabot> <undefined>
07:34:34 <alexj__> @seen shapr
07:34:35 <lambdabot> shapr is in #scannedinavian, #unicycling and #haskell. I last heard shapr speak 2m 20s ago.
07:36:12 <Saizan> ?where hs-plugins
07:36:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:37:32 <glguy> morning
07:40:41 <syntaxfree> http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html
07:40:42 <lambdabot> Title: Stevey's Blog Rants: The Pinocchio Problem
07:40:43 <Svrog> morning
07:40:57 <syntaxfree> that is rambly in the beginning, but gets interesting when he begins discussing type systems.
07:41:38 <syntaxfree> "There's nothing wrong with static type systems. You just have to realize that when you use them, you're building hardware, not software."
07:41:54 <Saizan> yeah and afaik it's quite true that static typed languages lacks introspection
07:42:06 <syntaxfree> well, that is true.
07:42:29 <syntaxfree> there's no simple way of implementing a typeOf function in Haskell to my knowledge, and that's scary.
07:42:40 <syntaxfree> (maybe TH allows it)
07:43:37 <twanvl> ?hoogle typeOf
07:43:38 <lambdabot> Data.Typeable.typeOf :: Typeable a => a -> TypeRep
07:43:39 <lambdabot> Data.Typeable.typeOf1 :: Typeable1 t => t a -> TypeRep
07:43:39 <lambdabot> Data.Typeable.typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
07:43:53 <syntaxfree> hmm.
07:44:04 <syntaxfree> > typeOf (2 ::  Int)
07:44:05 <lambdabot>  Int
07:44:15 <syntaxfree> aw shucks. how the hell do they do it?
07:44:47 <Saizan> with python and rpc i can open a repl inside my program, as if i was the "main" function, browse object and modules etc.. it's not something you have often to do but feels quite powerful even if hacky
07:44:49 <twanvl> The typeable class simply has a member typeOf :: a -> TypeRep
07:45:27 <syntaxfree> ah, that's just a hack.
07:46:00 <syntaxfree> Saizan: that has nothing to do with type systems, really.
07:46:07 <syntaxfree> Python is a dynamic language.
07:46:14 <syntaxfree> Basically because it has "eval".
07:47:03 <Saizan> well what's the point of have a static type system when you are so dynamic?
07:47:09 <syntaxfree> that Steve Yegge rant is really a rant. The guy has an attitude that makes it seem he knows what he's talking about, but he isn't.
07:47:18 <shapr> I'd say that Python is very much like Haskell, if you only ran Haskell apps in the compile cycle of TH.
07:47:36 <syntaxfree> Saizan: well, sure. that's why you don't see dynamic (as in having eval) languages with static type systems.
07:47:42 <syntaxfree> anyway, quote from Yegge:
07:47:51 <shapr> You could get runtime reloading, access to the type values, and lots of other interesting features if you only ran Haskell apps 'inside' TH
07:48:05 <syntaxfree> "Unsurprisingly, it handles some other common and highly desirable constructs awkwardly at best, but they explain those scenarios away by saying that you're mistaken, you don't actually want them. You know, things like, oh, setting variables. You don't want to do that, trust them on this."
07:48:15 <syntaxfree> he's attached to a dysfunctional model of programming :)
07:49:22 <glguy> link?
07:49:23 <syntaxfree> last quotation, I promise.
07:49:28 <syntaxfree> ""It's true that with some effort you can build beautiful, lithe marionettes with Haskell. But they will forever remain little wooden Pinocchio, never to be granted their wish for boyhood by the Good Fairy."
07:49:29 <syntaxfree> gah.
07:49:36 <syntaxfree> http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html
07:49:37 <lambdabot> Title: Stevey's Blog Rants: The Pinocchio Problem
07:49:51 <Saizan> shapr: is it something that can be done as TH is?
07:50:05 <apfelmus> Saizan: introspection breaks referential transparency.
07:50:45 <bakert> How would you lay this out?
07:50:47 <lisppaste2> bakert pasted "Simple layout question" at http://paste.lisp.org/display/35528
07:50:49 <syntaxfree> TH is basically a DSL for describing Haskell programs, as I see it.
07:50:55 <syntaxfree> It's not introspective.
07:51:05 <Saizan> apfelmus: dynamicity is about not being referentially transparent :)
07:51:08 * glguy encourages anyone to use http://fserv.pikapphi.umr.edu:8000/
07:51:09 <lambdabot> Title: All pastes
07:51:20 <shapr> syntaxfree: err, I have more to say about TH and Yegge, but I'm in a meeting...
07:51:37 <glguy> bakert: with or without >>= 's
07:51:58 <syntaxfree> shapr: okie. you can tell me later :)
07:52:00 <bakert> glguy, it looked worse without them so i added them.  but it sort of stretches across the screen a lot
07:52:02 <glguy> bakert: you don't need "do" when you aren't using <-
07:52:09 <lisppaste2> apfelmus annotated #35528 with "no >>=" at http://paste.lisp.org/display/35528#1
07:52:18 <bakert> glguy, ah yes good point.  will clean that up
07:52:31 <lisppaste2> twanvl annotated #35528 with "What is wrong with do notation?" at http://paste.lisp.org/display/35528#2
07:53:00 <syntaxfree> do notation considered harmful!
07:53:06 <syntaxfree> @google "do notation considered harmful"
07:53:11 <lisppaste2> glguy annotated #35528 with "for bakert" at http://paste.lisp.org/display/35528#3
07:53:11 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
07:53:11 <lambdabot> Title: Do-notation considered harmful Â« Data.Syntaxfree
07:53:12 <bakert> nothing wrong with "do" i suppose.  it looked quite big in do form though.
07:53:23 <apfelmus> Saizan: i see :) dynamic necromancing, that is.
07:54:10 <Saizan> apfelmus: yes it's a little macabre to mess up your program when it's running :D
07:55:07 <kosmikus> bakert: you can use "fmap Just (getFunds bookie)" in the then-branch ...
07:55:41 <bakert> kosmikus, ooh cool.
07:55:43 <bakert> thanks
07:56:36 <twanvl> or liftM, which does the same thing as fmap, but makes it clear you are using a monad
07:57:02 <glguy> but it takes an extra character!
07:57:04 <apfelmus> Saizan: callCruelCut (forkDemon >>= introspect) ...
07:57:09 <bakert> glguy, that's the spirit!
07:57:22 <syntaxfree> bah, you can't post on Yegge's without being a member of blogspot.
07:57:30 <wolfgangbeck> concerning my blocking 'atomically (readTVar xy)'; i tripped once more over the default 'letrec' behaviour of haskell and used a name twice and created inadvertant recursion
07:57:40 <bakert> syntaxfree, give it to me and i'll post it
07:57:51 <bakert> syntaxfree, then i'll look like i know what i'm talking about!
07:57:58 <syntaxfree> heheh.
07:58:05 <syntaxfree> I wanted to spam my  own blog address as well :P
07:58:07 <lisppaste2> bakert annotated #35528 with "Huzzah, two lines!" at http://paste.lisp.org/display/35528#4
07:58:08 <syntaxfree> "Ah, yes, argument by analogy. Dynamic languages are life-like in the sense it's somewhat introspective, ergo intelligent software can only be written in a life-like language since intelligence is a property of life!
07:58:08 <syntaxfree> Way to go!"
07:58:13 <syntaxfree> that was my comment.
07:58:35 <apfelmus> Saizan: actually, Mathematica (which is kinda lisp) has introspection. and it just sucks because you have to care about Evaluate[], Hold[] and so on.
07:59:05 <syntaxfree> bah. HINAGeP
07:59:09 <Saizan> care in what sense?
07:59:16 <bakert> syntaxfree, he is not a G e P?
07:59:18 <syntaxfree> er, HAAGePP
07:59:25 <syntaxfree> Haskell ain't a general purpose platform!
07:59:41 <syntaxfree> it's not bloody Logo, kids. It's closer to C than to Lisp in purpose.
08:00:10 * glguy can see why Stevey has to limit himself to 4 hours of blogging a week, he likes to talk... a lot
08:00:11 <bakert> So you don't see a great future of web apps and commandline utils in haskell?
08:00:25 <bakert> It's for certain things only?
08:00:34 <syntaxfree> it's not a platform.
08:00:38 <syntaxfree> it's a language.
08:00:44 <apfelmus> Saizan: kick your computer because it doesn't work as you want :)
08:00:49 <syntaxfree> lambdabot is a platform of sorts, based around Haskell.
08:01:03 <syntaxfree> some languages mix up these two concepts, basically by having eval.
08:01:12 <bakert> I see what you are saying.
08:01:34 <bakert> He obviously likes that idea (the mixing up) I guess.
08:01:41 <Saizan> you are saying that you should not expect to have a RTS to mess with, right?
08:02:05 <syntaxfree> Haskell actually has three or four different, separable instances of what Pytthon or Scheme have
08:02:19 <syntaxfree> 1) Haskell/Haskell'/GHC the compileable language
08:02:33 <syntaxfree> 2) ghci (possibly with the lamdabotty extensions dons wrote)
08:02:42 <syntaxfree> 3) Template Haskell
08:03:08 <apfelmus> Saizan: RTS?
08:03:24 <syntaxfree> 4) hs-plugins
08:03:26 <Saizan> runtime system
08:03:37 <Saizan> even if there's one and has api
08:03:55 <syntaxfree> well, yes. but that's a convenience, not something by design crippling the separation of purposes.
08:04:31 <syntaxfree> the same way Haskell separes stateful and stateless code, it separates the core language from a dynamic environment that can be built around it.
08:04:32 <Svrog> night
08:04:37 <syntaxfree> (just witness lambdabot)
08:04:39 <syntaxfree> @yow
08:04:39 <lambdabot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
08:05:48 <syntaxfree> sure, it takes more hacking, because there's been a conscious decision to have no simple "eval" crippling what can be done with the "pure" language.
08:06:30 <syntaxfree> in any case, all this has NOTHING to do with type systems, but whether you have introspective abilities like eval or a non-hacky typeOf.
08:06:40 <syntaxfree> which ghci and lambdabot have, mind you. Just witness
08:06:47 <syntaxfree> @type show (Nothing)
08:06:49 <lambdabot> String
08:06:54 <Saizan> well i don't know how hs-plugins or HT work to continue this conversation, but i feel like you can't do what you really need to do that "grow a running software"
08:07:15 <syntaxfree> Saizan: lambdabot is living hs-plugins over IRC.
08:07:42 <syntaxfree> @let nextcoll x = if (odd x) then 3*x+1 else x `div` 2
08:07:43 <lambdabot> Defined.
08:07:46 <tuukkah> hs-plugins includes eval, right?
08:07:47 <Saizan> but she gets taked down when sorear sends a patch :)
08:07:54 <syntaxfree> there you are. new functionalities into lambdabot!
08:08:01 <syntaxfree> > nextcoll 17
08:08:02 <lambdabot>  52
08:08:15 <Saizan> and you can't do data def :P
08:08:31 <syntaxfree> nor you can in Pytthon, my friend.
08:08:36 <syntaxfree> @unlet nextcoll
08:08:37 <lambdabot>  Parse error
08:08:48 <syntaxfree> er, how do I remove a let bionding again?
08:08:54 <Saizan> well in python you don't have data, that's the only reason
08:08:59 <Saizan> @undefine
08:09:00 <lambdabot> Undefined.
08:09:15 <Saizan> > nextcoll 17
08:09:15 <lambdabot>   Not in scope: `nextcoll'
08:09:16 <tuukkah> you do have classes and you can define them with eval
08:10:11 <Saizan> you can even change the class of an object at runtime
08:10:33 <syntaxfree> anyway, my two main points are that 1) this has nothing to do with a type system (lambdabot is "living" dynamic software in a statically typed environment) and b) Haskell is *just* a language.
08:10:51 <syntaxfree> Introspective, dynamic systems can be built around it.
08:11:00 <syntaxfree> shall I demonstrate @let and @type again?
08:11:17 <tuukkah> syntaxfree, i don't think it's easy for people to see that possibility
08:11:28 <Saizan> yeah that's true, but is like hacking on windows, you can't do much whaen you can't get to the sources..
08:11:52 <syntaxfree> it's also not easy to see the State monad as a possibility, and not needing it for most software anyway as a possibility.
08:11:54 <tuukkah> hs-plugins is not in haskell 98
08:12:28 <syntaxfree> I don't mind. "Haskell" is a word like "Linux".
08:12:59 <tuukkah> haskell 98 is the latest standard of the language as much as there is *a* language
08:13:00 <syntaxfree> people say "oh, system X written in Haskell. Um, plus GADTs."
08:13:15 <syntaxfree> sure.
08:13:55 <tuukkah> syntaxfree, so what's your point about the language extensions here?
08:14:11 <syntaxfree> that some language mix up concepts.
08:14:17 <syntaxfree> s/language/languages.
08:14:29 <Saizan> one thing that worries me is how lazy evaluation interacts with dynamicity
08:14:33 <syntaxfree> Language definition, interactive environment, dynamic environment.
08:14:41 <syntaxfree> Python is like that.
08:14:59 <Saizan> well python is interpreted, it has to
08:15:12 <syntaxfree> Haskell has [Haskell 98 | Haskell' | Haskell+GHCexts], ghci, hs-plugins.
08:15:32 <syntaxfree> Haskell *can* be interpreted.
08:15:34 <syntaxfree> It's a possibility.
08:16:08 <syntaxfree> It can also be interpreted and dynamic.
08:16:12 <syntaxfree> Witness lamdbabot.
08:17:27 <Saizan> sf: i witness LB all the time :D
08:17:35 <vegai> is hs-plugin a hack or more of an elegant solution?
08:19:09 <syntaxfree> http://www.googlebattle.com/index.php?domain=hs-plugins+hack&domain2=hs-plugins+elegant&submit=Go%21
08:19:14 <lambdabot> Title: &#9658;&#9658; GoogleBattle: The latest indicator of cultural relevance. hs-plug ..., http://tinyurl.com/34edht
08:19:15 <Saizan> what i mean is that if you force programmers to a VM like python and you don't give them a way to interact with it you are no better than java
08:19:55 <lispy> Cale: http://xkcd.com/c207.html
08:19:56 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:20:34 <lispy> Saizan: no better?  but java is successful! ;)
08:21:02 <Saizan> java is harmful, to my mind at least :D
08:21:40 <syntaxfree> basically because it's crippled.
08:22:11 <syntaxfree> Haskell manages to be quite adept at building DSLs even with no shade of hs-plugins or TH.
08:22:30 <glguy> it still isn't totally clear to me where the DSL line is drawn
08:22:55 <syntaxfree> do people get to write programs in your DSL without knowing Haskell?
08:23:03 <syntaxfree> that's what I aim for, basically.
08:23:39 <glguy> is a DSL inherently imperative
08:24:48 <matthew_-> is it possible to construct a value v which is of type T a b and T b a ?
08:24:50 <syntaxfree> nope.
08:24:51 <norpan> haskell is very well suited for domain specific languages i think
08:25:00 <syntaxfree> my EDSLs are basically description languages.
08:25:16 <norpan> you can define combinators so that the user needs to know virtually no haskell at all
08:25:29 <syntaxfree> precisely.
08:25:40 <syntaxfree> there was some text some time ago saying java was the land of nouns.
08:25:50 <syntaxfree> Haskell is, oppositely, a land of verbs.
08:26:53 <SyntaxNinja> snow snow snow
08:27:28 <lispy> SyntaxNinja: hey, speaking of snow i saw the video on the internet of you driving to work :)
08:27:49 <norpan> and then when users ask for advanced features they have a reason to learn haskell :)
08:28:03 * shapr throws a snowball at SyntaxNinja
08:28:33 <SyntaxNinja> lispy: that SUV you mean?
08:28:37 <SyntaxNinja> lispy: portland drivers ;)
08:29:07 <SyntaxNinja> lispy: Q: What's the difference between the driver in question and an average SUV driver? A: The driver in question has his lights on!
08:29:09 <lispy> watching one of my co-workers program in C# has been frightening...he has written a couple thousand lines of code without creating or using an ADTs ... he just uses ints, strings and arrays
08:29:19 <lispy> SyntaxNinja: ha!
08:29:38 <SyntaxNinja> shapr: you don't want to start w/ the snow w/ me! I have all the snow!! and lispy
08:29:54 * lispy climbs into the lispy cannon
08:29:58 <lispy> ready!
08:30:50 <nomeata> @seen kowei
08:30:50 <lambdabot> I haven't seen kowei.
08:30:52 <nomeata> @seen kowey
08:30:53 <lambdabot> kowey is in #darcs. I last heard kowey speak 1h 51m 22s ago.
08:30:54 <lispy> he writes amazingly poor code which, near as i can tell, just _happens_ to work
08:31:05 <shapr> lispy: who?
08:31:18 <lispy> shapr: a co-worker...i'm trying to teach him better habits
08:31:21 <shapr> oh
08:31:21 * SyntaxNinja fires lispy cannon at shapr
08:31:34 * shapr tries to dodge!
08:31:36 <lispy> waaaahhhhhhhooooooo!
08:31:53 * lispy lands in a pile of lambdas
08:32:13 <pejo> lispy, how is the teaching going?
08:32:30 <lispy> pejo: slow :)
08:32:37 <pejo> lispy, but there's progress?
08:33:07 <lispy> actually i'm not sure...he seems to understand the refactorings/changes and agrees they are good, but i don't know that he is putting it to use in new code
08:33:21 <SyntaxNinja> lispy: are you driving / going into work today?
08:33:40 <lispy> SyntaxNinja: not driving, i always bike.  but yeah, i'm going to work today
08:34:07 <SyntaxNinja> lispy: I think I'm going to work from home.  if I had mountain bike, I think I'd go for it, but I don't feel like changing out my road tires for cross tires
08:34:10 <lispy> in fact, i'm heading to my sci. visualization class here in 10 minutes
08:34:29 <lispy> yestarday i fell twice on the bike going to work
08:34:35 <lispy> that was not fun
08:34:44 <shapr> lispy: You need a unicycle... like mine!
08:34:48 <lispy> heh
08:35:05 <shapr> My unicycle handles snow, ice, slush, and just about anything else with no problem.
08:35:22 <lispy> because there is enough pressure on the wheel?
08:35:25 <shapr> The only two difficulties are 1. water (I'm too heavy) and 2. clean asphalt (my tire has *too much* grip)
08:36:56 <lispy> SyntaxNinja: i think your driving conditions were a bit worse than ours
08:37:02 <SyntaxNinja> lispy: ahh
08:37:16 <shapr> lispy: 3.7 inch tire at 12-15 psi
08:37:24 <lispy> it was slippery, and we did have a few accidents, but nothing like the SUVs
08:38:11 <syntaxfree> shapr: http://www.youtube.com/watch?v=9xuUzuklkoU
08:38:24 <bakert> You know how one can import Monad or Control.Monad to get liftM.  Which is "correct", Control.Monad?
08:38:31 <dmhouse> bakert: Control.Monad.
08:38:34 <lispy> bakert: yeah
08:38:41 <dmhouse> Monad is from the older non-hierarchical module system.
08:38:42 <lispy> bakert: that's the "modern" way
08:38:46 <bakert> thanks folks
08:38:53 <dmhouse> Along with things like List and Char. Always use their full na,es
08:39:40 <shapr> syntaxfree: I'm nowhere close to her skill level.
08:39:43 <bakert> wahey i got a shell pipeline wrong and put the * at the end ... i hope that's a sign i'm beginning to understand pointfree!
08:40:04 <syntaxfree> shapr: that's some great unicycling exhiibition, though, isn't?
08:40:21 <syntaxfree> not sure how technically hard it is, but it looks great.
08:40:41 <shapr> it's incredibly technically hard
08:41:02 <shapr> I'd guess there are fewer than 20 people in the world who can do that.
08:41:04 <huschi> i've got multiparameter classes and get many type ambiguities. is there a way to this problem?
08:41:15 <syntaxfree> how old is that girl?
08:42:34 <apfelmus> huschi: functional dependencies ?
08:43:05 <glguy> ?losers
08:43:05 <lambdabot> Maximum users seen in #haskell: 311, currently: 300 (96.5%), active: 51 (17.0%)
08:43:22 <huschi> apfelmus: i will try it. thx.
08:43:36 <lispy> syntaxfree: that was brilliant
08:43:42 <dmhouse> ?ask kowey why he moved the CT article to Program Correctness? It doesn't really seem like an appropriate place for it. To be honest, I'm not convinced about the entire Program Correctness section, I think a lot of its content belongs in Haskell in Time and Space.
08:43:42 <lambdabot> Consider it noted.
08:44:40 <psnl> shapr: I don't remember you being that good
08:44:54 <shapr> psnl: Nor was I that cute. In short, that's not me ;-)
08:45:36 <huschi> apfelmus: wow, now it works. great!
08:45:44 <psnl> shapr: for what its worth, I was really impressed with your unicycle
08:45:49 <shapr> heh, thanks
08:46:09 <shapr> psnl: This is from 1.5 weeks ago http://picasaweb.google.com/shae.erisson/OakMountainUnicycling
08:46:13 <lambdabot> Title: Picasa Web Albums - shapr - Oak Mountain ...
08:46:19 <shapr> No action shots sadly. I couldn't ride and take pix at the same time.
08:46:35 <apfelmus> huschi: most often, they arise naturally, but sometimes going without them is better. depends on what your type classes mean. but if it works, just stcik to it :)
08:46:41 <apfelmus> *stick
08:47:40 <apfelmus> dmhouse: why do you think that CT belongs to time and space? i mean, "time and space" is intended to be the "performance" chapter
08:47:57 <dmhouse> Oh, that kind of time and space.
08:48:08 <dmhouse> I thought it just meant 'Haskell in a wider context'.
08:48:27 <dmhouse> In which case I agree with the move, but I think we should rename Program Correctness.
08:49:09 <apfelmus> dmhouse: perhaps that would be Haskell in "space-time", "outerspace" or "hyperspace".
08:49:38 <Saizan> "n-dimensional space"?
08:51:33 <dmhouse> In fact, Time and Space should be renamed, too.
08:51:41 <dmhouse> And PC should go after FWT
08:52:41 <apfelmus_> dmhouse:(i'm back) yes, we should rename "program correctness". but i can only think of "formal program manipulation"
08:52:50 <shapr> hej bringert!
08:53:01 <bringert> hej shapr
08:53:17 <apfelmus_> dmhouse: renaming Time and Space? ooh, i thought it would make a nice name
08:53:27 <dmhouse> apfelmus_: well that section seems to be more about Haskell in a wider context.
08:53:37 <dmhouse> apfelmus_: T&S, well, I misinterpreted it :)
08:53:45 <dmhouse> It's the 'Haskell in' bit that's confusing, I guess.
08:54:44 * dmhouse casually remind apfelmus_ about the rather empty-looking Zippers article, while he's here. :)
08:54:58 <bringert> dons, kolmodin, dcoutts: I get this compiling binary on GHC 6.6 on Linux amd64:
08:54:59 <bringert> src/Data/Binary/Builder.hs:311:35:
08:54:59 <bringert>     Couldn't match expected type `Word64#'
08:54:59 <bringert>            against inferred type `Word#'
08:54:59 <bringert>     In the first argument of `uncheckedShiftRL64#', namely `w'
08:54:59 <bringert>     In the first argument of `W64#', namely
08:55:01 <bringert>         `(w `uncheckedShiftRL64#` i)'
08:55:02 <bringert>     In the expression: W64# (w `uncheckedShiftRL64#` i)
08:56:00 <kolmodin> bringert: oh, must be one of dons latest changes
08:57:57 * apfelmus_ has problems with the zippers (of his anorak, that is)
08:58:36 <bringert> it seems like on amd64, W64 takes a Word#, not a Word64#
08:58:49 <kolmodin> bringert: right
08:59:26 <glguy> ?seen Cale
08:59:26 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 40m 13s ago.
09:00:30 <bringert> ah, yes: data Word64 = W64# Word#
09:00:47 <bringert> only when #if WORD_SIZE_IN_BITS < 64 is data Word64 = W64# Word64#
09:01:11 <glguy> > EQ `mplus` GT
09:01:12 <lambdabot>  Couldn't match `m a' against `Ordering'
09:01:15 <glguy> hmm...
09:01:23 <glguy> what am I thinking of?
09:01:37 <glguy> > EQ `mappend` GT
09:01:38 <lambdabot>  GT
09:01:44 <dmhouse> > EQ `max` GT
09:01:45 <lambdabot>  GT
09:01:54 <dmhouse> ?src Ordering mappend
09:01:54 <lambdabot> Source not found. Do you think like you type?
09:01:56 <kolmodin> bringert: feel free to make a patch :)
09:01:59 <glguy> > LT `mappend` GT -- this is it
09:02:01 <lambdabot>  LT
09:02:12 <dmhouse> glguy: does it differ from max?
09:02:19 <glguy> dmhouse: yes
09:02:30 <glguy> dmhouse: EQ `mappend` x = x
09:02:36 <glguy> dmhouse: x `mappend` _ = x
09:10:44 <LoganCapaldo> @hoogle fix
09:10:45 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
09:10:45 <lambdabot> Control.Monad.Fix :: module
09:10:45 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
09:12:40 <vegai> I wonder if a Cabal file format would be nice for describing package build scripts for a linux distribution
09:14:25 <LoganCapaldo> @src fixIO
09:14:25 <lambdabot> Source not found. Are you on drugs?
09:14:31 <LoganCapaldo> No
09:14:34 <LoganCapaldo> Meanie
09:14:43 * shapr cries on lambdabot 
09:15:03 <Saizan> ahuahua
09:15:54 <Saizan> @remember LoganCapaldo <LoganCapaldo> @src fixIO <lambdabot> Source not found. Are you on drugs? <LoganCapaldo> No <LoganCapaldo> Meanie
09:15:55 <lambdabot> Done memoising quote for `LoganCapaldo', if that is their real name...
09:16:25 <shapr> What's the command to rename an ethernet device?
09:16:50 <bringert> kolmodin: I need to be able to know the word size when CPP:ing. GHC uses WORD_SIZE_IN_BITS when building base. It would be nice to avoid configure scripts for binary, but I can't think of another way. I guess we might need that in the future anyway, to play tricks with endianess.
09:17:25 <sieni> shapr: mv
09:17:34 <sieni> shapr: (just kidding)
09:17:41 <shapr> I was wondering...
09:18:25 <shapr> aha! nameif!
09:19:05 <kolmodin> bringert: actually I don't think we'll use cpping for endianess as it is hard to read in full words (due to alignment)
09:19:13 <bringert> ok
09:19:46 <bringert> having a configure script for this silly thing alone feels like overkill
09:19:55 <vegai> lambdabot is getting cranky
09:20:07 <kolmodin> bringert: yeah, but I don't know any other way either
09:20:16 <bakert> vegai, in what way?
09:21:16 <cjeris> @quote lambdabot
09:21:16 <lambdabot> lambdabot says: tERmIN473d
09:21:20 <kolmodin> cabal should help us somehow
09:22:12 <bringert> heh, here's a partial work around: #ifdef x86_64_HOST_ARCH
09:22:17 <bringert> GHC defines that
09:22:27 <vegai> 17:12 < lambdabot> Source not found. Are you on drugs?
09:22:32 <vegai> and a short while later
09:22:38 <Igloo> bringert: Do you know the URL for package uploads?
09:22:39 <vegai> 17:13 < lambdabot> Done memoising quote for `LoganCapaldo', if that is their real name...
09:22:42 <bringert> won't work for other 64-bit architectures though
09:22:57 <kolmodin> bringert: yeah, sounds a bit hackish
09:23:20 <bringert> Igloo, http://hackage.haskell.org/packages/hackage.html
09:23:21 <lambdabot> Title: Basic Hackage interface
09:23:38 <Igloo> Cool, thanks
09:23:39 <bringert> Igloo: the packages end up in http://hackage.haskell.org/packages/archive/
09:23:41 <lambdabot> Title: Index of /packages/archive
09:23:58 <bringert> Igloo: which is not what cabal-install uses by default :-(
09:27:39 <bringert> grr, I don't want to mess with autoheader
09:28:27 <malebria> Does anyone know a good tutorial to write a simple parser in haskell?
09:28:53 <malebria> I just want to make a Read instance for a data type which was really easy to define show.
09:30:13 <bringert> ah, #include "MachDeps.h" did the trick
09:30:27 <bringert> GHC seems to know where to find its headers
09:31:38 <dcoutts__> @yarr
09:31:38 <lambdabot> What be a priate's favourite cheese?
09:31:38 <lambdabot> Yarrlsburg!
09:32:09 <dcoutts__> kolmodin: we've nearly hit 100MB/s serialisation speed on dons's laptop
09:32:23 <dcoutts__> 96MB/s
09:32:56 <dcoutts__> we're looking at commoning up the bounds checks rules again
09:34:00 <dcoutts__> so there's a reasonable chance that we'll be able to serialise 50x faster than the best lib in python :-)
09:34:04 <shapr> w00
09:34:09 <dcoutts__> @arr
09:34:09 <lambdabot> I want me grog!
09:34:10 <vegai> dcoutts__: is that the hard drive's speed?
09:34:15 <dcoutts__> hia shapr
09:34:24 <shapr> greetings dcoutts__
09:34:34 <dcoutts__> vegai: we're serialising into memory, lazy ByteStrings, so no IO yet
09:34:39 <shapr> er, I mean "salut dcoutts__"
09:34:41 <vegai> ah, right. Of course
09:34:51 <dcoutts__> but they're in big 32k chunks so the IO will be full speed
09:35:55 <bringert> dcoutts_, kolmodin: I just pushed a patch to make binary compile on amd64 again. I hope I didn't break it on som other arch. OS X/i386 seems to work anyway.
09:36:26 <dcoutts__> vegai: and since serialisation is pure a pure function producing lazy bytestrings we can write nice compositions like: writeFile f . gzip . serialise
09:36:36 <dcoutts__> bringert: oh ok, what was wrong?
09:36:39 <bringert> is it an accepted trick to #include headers that sit in GHCs install dir?
09:36:43 <diogo> hello there
09:36:54 <dcoutts__> bringert: yeah, that's fine
09:37:10 <dcoutts__> bringert: is that for the stg_ include stuff?
09:37:16 <diogo> is there anyone with a mac intel?
09:37:18 <bringert> dcoutts_, on 64-bit archs, Word64 is just a Word#, not a Word64#
09:37:21 <bringert> dcoutts_, yes
09:37:26 <dcoutts__> bringert: oh ok.
09:38:00 <bringert> diogo: I've got one
09:38:03 <dcoutts__> bringert: I test amd64 too so we shouldn't hit this too often
09:38:43 <Igloo> bringert: OK, compression-0.1 is in hackage now
09:38:44 <dcoutts__> bringert: did you arrive just after I said we've nearly hit 100Mb/s peak serialisation speed?
09:38:45 <bringert> dcoutts_, I had to #include "MachDeps.h", but GHC seems to know where to find it
09:38:50 <diogo> do you have ghc installed?
09:38:54 <Igloo> It needs lots of work, but should be basically functional
09:38:59 <bringert> dcoutts_: great!
09:39:02 <bringert> Igloo: great
09:39:06 <bringert> diogo, yes
09:39:07 <kolmodin> dcoutts__: omg, you guys never give up, do you? :D
09:39:14 <diogo> i have one little problem..
09:39:25 <diogo> i don't have any ghc installed in my computer
09:39:32 <diogo> i need the version 6.4.1
09:39:40 <dcoutts__> kolmodin: hia :-)
09:39:51 <diogo> when i try to install the bin package it says i have a better version installed!
09:39:54 <kolmodin> I was quite happy with 50mb/s, which was double of the old, which was double of the old, which was double of the old...
09:39:55 <diogo> i don't let me install
09:39:57 <kolmodin> :D
09:39:59 <dcoutts__> kolmodin: yeah, dons has been doubling the speed every few hours :-)
09:40:11 <kolmodin> dcoutts__: hia, hope you have a good time in France as well!
09:40:15 <shapr> Soon Linus will ask dons for optimization tips.
09:40:34 <bringert> kolmodin, dcoutts_: my untarring isn't as lazy as it should be. I think it's getLazyByteString's fault. It's not lazy
09:40:35 <kolmodin> dcoutts__, dons: so how was last night, ejoyable?
09:40:39 <dcoutts__> kolmodin: oh we are, fear not. We spent our prize money last night. :-)
09:40:57 <kolmodin> well don!
09:41:00 <bringert> because of ensureLeft
09:41:00 <kolmodin> *done
09:41:34 <dcoutts__> bringert: hmm, that's a bit tricky.
09:42:13 <dons> ?yow!!
09:42:14 <lambdabot> Did I SELL OUT yet??
09:42:15 <kolmodin> dcoutts__: I was just saying that you shoud take notes somewhere on how you can make your library go 400 times faster than your prototype
09:42:27 <bringert> dcoutts_, if it just instead could return a shorter string if the input ended, everything would be fine
09:42:40 <dcoutts__> bringert: you could make it lazy by assuming that there'll be the right length available but then failing if it turns out in the end that there isn't
09:43:09 <dcoutts__> bringert: ie pushing the check down into the lazy take branch
09:43:13 <bringert> dcoutts_, that sounds good
09:43:24 <dons> kolmodin: there's a present for you in the repo now
09:43:26 <diogo> by the way.. is there mr joost visser?
09:43:35 <dons> is he here?
09:43:38 <dons> no I don't think so
09:43:42 <diogo> why?
09:43:45 <dons> but he's somewhere in the building. I could go and find him
09:43:48 <dons> :)
09:43:49 <diogo> hm
09:43:50 <dons> (really!)
09:43:53 <dcoutts__> bringert: and using take & drop rather than splitAt I think.
09:43:54 <diogo> who are you?
09:44:00 <dons> dons! :)
09:44:03 <kolmodin> dcoutts__: otoh, that string might be in the other side of the app by then, or on its way on the network
09:44:04 * dons <- dons
09:44:18 <diogo> ok.. how do you know joost?
09:44:26 <dcoutts__> kolmodin: huh?
09:44:33 <dons> oh, he's here at a conference
09:44:38 <bringert_> kolmodin: yeah, there should be a safe and an unsafe one
09:44:42 <sieni> dons: was that very useful?
09:44:49 <dons> sorry :)
09:44:56 <cjeris> do { dons <- dons ; return dons } ?
09:44:56 * dons is in a silly mood
09:44:57 <shapr> diogo: The Haskell community is well connected.
09:45:00 <emu> dons: what version of ghc is needed for hs-plugins rc?
09:45:02 <diogo> hm ok
09:45:06 <dons> emu, ghc 6.4.2
09:45:06 <diogo> i see
09:45:08 <dcoutts__> kolmodin: oh I see, yes when you discover that the getLazyByteString returned short when you finally forced it. Yeah.
09:45:18 <kolmodin> dcoutts__: that's what I ment
09:45:19 <dons> drum roll.....
09:45:20 <diogo> i have to do this project for him.. but i can start working!!
09:45:21 <shapr> diogo: Who are you?
09:45:22 <dons> 10MB of Word32 in chunks of 2: 78.12MB/s
09:45:22 <dons> 10MB of Word32 in chunks of 4: 104.16MB/s
09:45:22 <dons> 10MB of Word32 in chunks of 8: 131.57MB/s
09:45:22 <dons> 10MB of Word32 in chunks of 16: 131.57MB/s
09:45:24 <dons> :D
09:45:29 <diogo> < diogo :)
09:45:30 <bringert_> kolmodin: otoh, that can happen now anyway, if you get two lazy bytestrings, and send them. the first will be sent, and the second one will fail
09:45:31 <kolmodin> dons: muhahahahhhahah!!!111
09:45:32 <emu> dons: not yet w/ghc head?
09:45:36 <dons> emu, right
09:45:40 <syntaxfree> dons: is there any possibility lambdabot can hang out in #haskell.br?
09:45:44 <dons> yeah
09:45:49 <dons> ?join #haskell.br
09:45:54 <dons> is she there now?
09:46:12 <syntaxfree> yay. now there are _two_ people #haskell.br
09:46:12 <dons> @seen bos
09:46:13 <lambdabot> I saw bos leaving #haskell 2d 49m 14s ago, and .
09:46:21 <dons> @seen joelr
09:46:21 <lambdabot> I haven't seen joelr.
09:46:22 <syntaxfree> one and a half, I guess ;)
09:46:34 <syntaxfree> there are four or five brazilians in here, IIRC.
09:46:40 <shapr> syntaxfree: There are more .br Haskellers, I'll point them to that channel next time I see 'em here.
09:46:41 <kolmodin> bringert_: hmm, true
09:46:56 <shapr> @seen joelr1
09:46:57 <lambdabot> I saw joelr1 leaving #haskell 1d 21h 48m 41s ago, and .
09:47:08 <bringert_> to avoid that, we need to go back to the days of ErrorT
09:47:15 <bringert_> what was that, two days ago?
09:47:19 <syntaxfree> I haven't even registered it. I'm not trying to be a channel founder or anything.  Just feel like talking to .br haskellers in portuguese once in a while :)
09:47:25 <dons> shapr, he wanted 10M/s throughput for his trading app ;)
09:47:29 <shapr> oh!
09:47:42 <shapr> You appear to have exceeded his expectations.
09:47:46 <dcoutts__> @arr!
09:47:46 <lambdabot> Aye
09:47:53 <dons> ghc is being very clever
09:48:02 <dons> hack smarter, not harder!
09:48:37 <dons> ?users
09:48:37 <lambdabot> Maximum users seen in #haskell: 311, currently: 300 (96.5%), active: 49 (16.3%)
09:48:40 <dcoutts__> work smarder and not harder, and be careful of your spelling
09:48:41 <bringert_> maybe there could be a getLazyByteString that never fails, though it can return fewer bytes then requested
09:49:05 * dons turns off laptop for now. ciao!
09:49:16 <shapr> bye dons!
09:49:18 <syntaxfree> ciao.
09:49:18 <dcoutts__> bringert_: yes that'd be fine and you could do the length check yourself: takeExactly n
09:49:32 <kolmodin> dons: bye
09:50:55 <diogo> Bootstrapping GHC on a system without GHC already installed is achieved by taking the intermediate C files (known as HC files) from another GHC compilation, compiling them using gcc to get a working GHC.
09:50:56 <bringert_> maybe readN shouldn't check, someone else could do that
09:51:10 <bringert_> diogo: just use macports
09:51:17 <diogo> where am I supossed to get hc files from another compilation?
09:51:28 <diogo> but i need version 6.4.1
09:51:34 <diogo> macports only has 6.6
09:51:51 <shapr> diogo: What hardware and operating system are you using?
09:51:53 <bringert_> diogo: ghc 6.4.1 was never available for OS X/Intel
09:52:04 <diogo> and is not possible to compile?
09:52:13 <bringert_> you may have to do some non-trivial porting
09:52:25 <diogo> yes.. i am trying
09:52:29 <bringert_> diogo: why do you need 6.4.1?
09:52:35 <shapr> diogo: Is it possible for you to shell into a server and use 6.4.1 there?
09:52:51 <bringert_> diogo: or run linux in a VM?
09:52:55 <diogo> because i am using some code that only runs on 6.4.1
09:53:03 <diogo> hm
09:53:17 <bringert_> diogo: you might be better of changing the code than changing GHC :-)
09:54:09 <shapr> Oh hey, I got to beta-test a movie theater game thing yesterday. Turned out I was the only person in the theater who uses their brain for fun.
09:54:16 <diogo> bringert.. that what i want to ask to joost visser :)
09:54:23 <diogo> to make it run on 6.6
09:54:33 <diogo> well.. maybe is not so dificult
09:54:46 <diogo> i'll show you the error
09:55:09 <bringert_> dcoutts__: can you guys add something like what I need? Or should I do it myself? I was thinking that you are hacking so much on that exact code that I would change that the code would have changed by the time I try to push :-)
09:55:46 <diogo> ok.. i can't show you the error because now i don't have any ghc installed..
09:55:54 <diogo> but is some problem with packages
09:55:54 <dcoutts__> bringert_: we're mostly not chaning that part of the code I think
09:55:59 <psnl> dcoutts__: have you seen "bus errors" running gtk2hs on a mac?
09:56:11 <bringert_> diogo: that's normall easy to fix
09:56:13 <bringert_> y
09:56:16 <dcoutts__> psnl: no, but then I don't have a mac
09:56:17 <kolmodin> bringert_: the Get monad is still the naive version we started with
09:56:23 <bringert_> ok
09:56:31 <kolmodin> bringert_: so feel free to poke around
09:56:34 <kolmodin> :)
09:56:41 <dcoutts__> psnl: I do occasionally get successful reports from mac users so I think it's usually ok
09:56:50 <diogo> i think that now i need to specifie the name and the version of the package..
09:56:52 <kolmodin> bringert_: it will give us a better understanding of wat people need anyway
09:57:22 <bringert_> I might reduce performance, but you guys seem to like incresing it, so you should just be happy about that
09:57:34 <dcoutts__> kolmodin: it's not that naive. the writer and builder all get optimised out at the core level with some well placed inline pragmas
09:58:34 <psnl> dcoutts__: I'm a tad annoyed, since it worked over christmas but has stopped now
09:58:46 <dcoutts__> psnl: hmm, what changed?
09:58:59 <psnl> dcoutts__: I wish I knew
09:59:19 <dcoutts__> psnl: have you upgraded gtk+ or gtk2hs ?
09:59:45 <kolmodin> dcoutts__: ok, but we also talked about a few changes
10:00:03 <psnl> I don't think so, I'll poke with different versions of gtk2hs
10:00:06 <kolmodin> dcoutts__: we have to write some benchmarks first to be able to measure the results though
10:00:28 <dcoutts__> kolmodin: yeah, I redid the benchmark
10:00:30 <diogo> some have glade3 running on a mac intel?
10:00:37 <diogo> someone*
10:02:11 <kolmodin> dcoutts__: does it measure getting now as well as putting?
10:02:33 <kolmodin> no?
10:03:08 <dcoutts__> kolmodin: not yet
10:03:28 <dcoutts__> kolmodin: feel free to do that, we'll optimise reading after the benchmark is ready
10:03:37 <kolmodin> sure
10:03:45 <dcoutts__> we're still optimising serialisation atm
10:04:05 <kolmodin> as soon as I get better, I'm still fighting just to stay awake
10:04:14 <dcoutts__> oh, poor you :-(
10:04:21 <dcoutts__> sleep cures all
10:04:21 <kolmodin> maybe I shouldn't and just sleep for a while? :)
10:04:26 <dcoutts__> yeah
10:12:00 <emu> @hoogle repeatM
10:12:01 <lambdabot> No matches found
10:12:53 <emu> @hoogle (Monad m) => m a -> m ()
10:12:53 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:12:54 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
10:12:54 <lambdabot> Prelude.id :: a -> a
10:13:25 <emu> @pl sequence_ . repeat
10:13:26 <lambdabot> sequence_ . repeat
10:16:41 <syntaxfree> @type repeat
10:16:43 <lambdabot> forall a. a -> [a]
10:16:56 <syntaxfree> @djinn (Monad m) => a -> m a
10:16:57 <lambdabot> Cannot parse command
10:17:11 <syntaxfree> @djin a -> m a
10:17:11 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:17:18 <syntaxfree> @djinn a->a
10:17:19 <lambdabot> f a = a
10:17:27 <syntaxfree> @djin (Monad m)=> a->ma
10:17:28 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:17:31 <syntaxfree> :(
10:20:52 <diogo> ..
10:25:58 <bakert> How can I use a Makefile in conjunction with cabal?  Is there some way to tell the makefile to pass off all responsibility to cabal?
10:27:01 <bakert> hey paolino.  did you ever use cabal and make together?
10:27:02 <daniel_larsson> well, you can do "runhaskell Setup.hs build" from the makefile of course.
10:27:39 <bakert> daniel_larsson, yeah. that's what i'm going to do.  but how can I avoid telling it to look for changed files and all that behaviour?
10:27:48 <paolino> no, I'm new to haskell
10:27:49 <bakert> actually i suppose this is really a make question and not a haskell question.
10:28:10 <daniel_larsson> What do you want to do in make?
10:29:04 <bakert> I want it to fire "runhaskell Setup.lhs build" every time it is called.
10:29:20 <CosmicRay> bakert: what are you trying to do?
10:30:00 <Saizan> but you need it to do others thing too or is just as a shortcut to build?
10:30:03 <bakert> CosmicRay, there's an existing build system for the whole project.  I want to integrate my little app into it.  It uses make and expects a Makefile it can call at my top level dir.  So I'm trying to work out what to put in that Makefile to get it to call cabal.
10:30:06 <glguy> paolino: after a certain number of weeks you can't claim new status ;)
10:30:18 <bakert> glguy, how many weeks?  i just entered week 4.
10:30:25 <daniel_larsson> all:
10:30:25 <daniel_larsson>     runhaskell Setup.lhs build
10:30:27 <glguy> well, there is a certain number
10:30:37 <CosmicRay> runhaskell is not portable AFAIK
10:30:39 <CosmicRay> better to:
10:30:44 <CosmicRay> if you're using ghc:
10:30:50 <bakert> daniel_larsson, and that doesn't do the checking for changed files?
10:30:52 <CosmicRay> ghc --make -o setup Setup.lhs
10:30:54 <CosmicRay> ./setup configure
10:30:56 <CosmicRay> ./setup build
10:31:15 <bakert> CosmicRay, oh really?  i thought i was _supposed_ to use runhaskell.  thanks.
10:31:23 * glguy continues to encourage everyone to feel free to use http://fserv.pikapphi.umr.edu:8000/
10:31:25 <lambdabot> Title: All pastes
10:31:40 <CosmicRay> bakert: I should double-check, but last I looked, hugs supported it.  ghc supports it too, but only on some platforms
10:31:48 <daniel_larsson> It does check for changed files. Why do you want to avoid that?
10:31:53 <CosmicRay> so it is only useful if you intend it to work with both hugs and ghc.
10:32:10 <CosmicRay> but even then, it breaks on the majority of ghc platforms
10:32:13 <bakert> daniel_larsson, well i don't want to have to list the files.  but i think i see now.  if i don't list any files it checks ALL not NONE?
10:32:17 <CosmicRay> it happens that i386 and amd64 are two that it works on ;-)
10:32:49 <bakert> CosmicRay, i see.  ok i'll do it your way.  that still reads the .cabal file and everything so that's all good.
10:32:51 <daniel_larsson> You should only have to list the files in your .cabal files
10:33:25 <bakert> daniel_larsson, great
10:33:27 <bakert> thanks
10:33:32 <bakert> thanks everyone
10:33:46 <daniel_larsson> No need to have make do the job cabal is already doing, so don't list any files and dependencies there
10:34:30 <CosmicRay> bakert: my standard haskell makefile lives at: http://software.complete.org/hpodder/browser/Makefile
10:34:32 <lambdabot> Title: /Makefile - hpodder
10:34:38 <CosmicRay> should be a reasonable example
10:34:50 <paolino> is Cabal pure haskell ?
10:35:26 <CosmicRay> yes
10:35:41 <CosmicRay> and is a standard part of all modern Haskell compilers and interpreters these days
10:36:49 <glguy> In consideration of the hard work my team has been doing at work... we were told that half of us would get tomorrow and friday off, and the others would get monday and tuesday
10:37:11 <malebria> Isn't there a tutorial on parsing in haskell, using readPrec or readsPrec?
10:38:11 <CosmicRay> malebria: not afaik, but you might try google.  I find Parsec far more helpful.
10:38:38 <bakert> CosmicRay, thanks that's great
10:38:54 <paolino> mhh, freebsd doesn't distribute cabal
10:39:07 <bakert> glguy, is "hard work" a synonym for "working the weekend" or is this a genuine back pat?
10:39:10 <CosmicRay> are you sure it's not just rolled into ghc6?
10:39:16 <CosmicRay> paolino: you have to use -package CAbal
10:39:18 <malebria> CosmicRay: thanks.
10:39:19 <CosmicRay> err Cabal
10:40:19 <paolino> ok, it's there
10:40:48 <paolino> then I have no more excuses, I have to use it
10:41:21 <bringert> dcoutts_: I pushed some new Get stuff. Hope I didn't break it. htar still isn't lazy enough, but I think it needs some more thinking now.
10:41:41 <diogo> how do I register packages?
10:41:43 <CosmicRay> bringert: you have a tar implementation in haskell?
10:41:51 <bringert> CosmicRay: yes
10:41:58 <CosmicRay> ooo, wonderful!  url?
10:42:01 <malebria> CosmicRay: But my problem is very simple.
10:42:09 <CosmicRay> I started writing such a beast for missingh but never had time to get very far
10:42:16 <CosmicRay> bringert: are you using ByteString?
10:42:24 <bringert> CosmicRay: http://www.cs.chalmers.se/~bringert/darcs/tar/
10:42:25 <lambdabot> Title: Index of /~bringert/darcs/tar
10:42:36 <bringert> CosmicRay: yes, and the binary package
10:43:05 <bringert> CosmicRay: beware, it's not very stable, and it is a security risk with untrusted tarballs
10:43:06 <CosmicRay> ooo, I love this.  BS.getContents to read the file.
10:43:09 <malebria> I just want to parse things as ((1 2, 2 3), (4 5, 6 7)) into Set (Set (Point 1 2) (Point 2 3)) (Set (Point 4 5) (Point 6 7))
10:43:17 <CosmicRay> haskell rocks
10:43:31 <bringert> CosmicRay: there is a command line program in htar
10:43:42 <CosmicRay> I see it
10:44:08 <bringert> it also doesn't handle unix file meta data correctly, since it doesn't use the unix package yet
10:44:20 <bringert> due to lack of conditional dependencies in Cabal
10:44:25 <Masklinn> Btw I had a question about darcs usage: is it possible to "display" an old version of the repository without affecting the recorded patches? Something akin to svn update -r{some revision in the past} ?
10:44:32 <CosmicRay> bringert: it is possible, but ugly, to do that.
10:44:41 <CosmicRay> I am doing it in MissingH
10:44:59 <CosmicRay> http://software.complete.org/missingh/browser/Setup.hs
10:45:01 <lambdabot> Title: /Setup.hs - MissingH
10:45:22 <CosmicRay> that adds the unix package to the list of build-depends if not being compiled on Windows
10:45:31 <CosmicRay> you may in fact be able to just rip that off verbatim
10:45:45 <bringert_> oh, I didn't think you could change the dependencies with hooks
10:45:49 <CosmicRay> I also have some stubs in MissingH that may be useful for you
10:45:50 <emu> what's the semantics of exceptions thrown within a forkIO'ed thread?
10:45:57 <emu> do they propagate to the parent?
10:46:01 <CosmicRay> there is a StatCompat module that emulates the stat data types on Windows
10:46:08 <bringert_> oh, nice
10:46:22 <paolino> darcs put , can put on a machine with no darcs installed ?
10:46:42 <CosmicRay> http://software.complete.org/missingh/static/doc/System-IO-WindowsCompat.html
10:46:44 <lambdabot> http://tinyurl.com/24bs2y
10:46:45 <daniel_larsson> no, need darcs on remote box (afaik)
10:46:47 <CosmicRay> paolino: no
10:47:15 <CosmicRay> unfortunately the haddock docs are built on Linux so you can't see the contents of the module right there
10:47:17 <paolino> I wonder why
10:47:33 <CosmicRay> paolino: because it does a darcs apply on the remote, same as darcs push
10:47:33 <bd_> emu: from my brief testing, it seems it prints a diagnostic and keeps going (main = forkIO undefined >> threadDelay 10000000 in runhaskell, GHC 6.6)
10:48:01 <bringert_> CosmicRay: thanks: I
10:48:06 <emu> yea it prints something
10:48:08 <bringert_> 'll have a look at that
10:48:12 <emu> i was trying to catch it
10:48:20 * bringert_ is off
10:49:20 <bd_> emu: You could wrap forkIO in something to catch it
10:49:47 <CosmicRay> bringert: it has a fake getFileStatus() call, and builds up the stat structure and accessor functions independently of the unix package on Windows.  it does not support chmod/chown though, but then those don't make sense on Windows
10:50:00 <emu> yea, gonna try throwing to the main thread
10:50:03 <CosmicRay> getFileStatus() does do the right thing WRT files/dirs and size, though
10:50:16 <CosmicRay> err, scratch that for size.
10:51:36 <bitshftr> I know I've seen discussion of this problem before, but I can't find it.
10:51:45 <bd_> emu: one option: forkWithCatch m = do { v <- newEmptyMVar; tid <- forkIO ( (m >>= putMVar v . Right) `catchIO` (putMVar v . Left) ); return (tid, v) }
10:51:53 <bitshftr> foldl (+) 0 [1..10000] executes
10:52:02 <bitshftr> foldl (+) 0 [1..1000000] runs out of stack
10:52:11 <bd_> emu: With that you can catch the error at a point where it won't futz up the main thread
10:52:41 <bitshftr> can someone point me at where I can find the why and how to fix?
10:52:46 <paolino> foldl' maybe ?
10:53:25 <emu> cool; i do want to futz up the main thread in this case. throwTo seems to work.
10:53:31 <emu> it's a similar idea
10:53:32 <paolino> @src foldl'
10:53:33 <lambdabot> foldl' f a []     = a
10:53:33 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:53:51 <DracoCepheus> hello
10:54:53 <DracoCepheus> i am thinking of using ocaml instead of haskell --- has anybody tried both languages?
10:54:57 <bd_> emu: okay, but are you sure you want to cause such hard-to-predict behavior? exitFailure might be a better approach
10:55:50 <emu> why is it hard to predict?
10:56:05 <bd_> emu: Well, the exception could be raised at any point in your code
10:56:49 <emu> @hoogle exitFailure
10:56:50 <lambdabot> System.exitFailure :: IO a
10:56:50 * bd_ shrugs
10:56:50 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
10:56:57 <bitshftr> paolino: thanks
10:57:02 <bd_> anyway, I must afk now :)
10:57:07 <emu> i'll consider it, thanks
10:57:14 <paolino> yw
10:58:12 <bakert> How can I change where cabal puts the /dist/build stuff?
11:00:48 <dfranke> Does darcs need to be installed on the remote host in order to 'darcs put' to it?
11:00:56 <daniel_larsson> yes
11:00:58 <dylan> dfranke: yes.
11:01:14 <dfranke> that's slightly annoying.  I don't have root there.
11:02:59 <daniel_larsson> well, you would have needed that still, if you want to create a repo where you don't have write access...
11:03:14 <dfranke> I have write access, just not root access.
11:03:30 <dfranke> I'll have to use a static binary I guess.
11:03:31 <daniel_larsson> ah, you mean to install darcs...
11:03:45 <dfranke> needless to say they don't have haskell installed either.
11:04:08 <paolino> you can install darcs/haskell in your jail
11:04:39 <dfranke> I only have a 75MB quota so I can't install haskell.
11:04:44 <dfranke> but I just need darcs.
11:04:53 <Lemmih> dfranke: How about hosting your repos somewhere else?
11:05:20 <emu> calling exitFailure from within a thread doesn't seem to terminate the program unless it is the main thread
11:06:13 <Lemmih> dfranke: You can get server space on my box if you have an SSH key.
11:06:16 <dfranke> Lemmih, it's a university research project, ought to stay on uni servers if possible.
11:07:45 <fasta> I get "Could not deduce Show ... from ... ". Apparently, somewhere I use show, but I don't suppose there's an easy way to find them except for grepping... Bad tools :(
11:08:57 <Lemmih> fasta: You could ask GHCi.
11:09:11 <fasta> Lemmih: I can?
11:09:40 <Lemmih> Doesn't the error message say where the culprit is, btw?
11:10:09 <bakert> How can I change where the binaries go with cabal?  The docs mention a "scratchdir=" parameter but no dice.  Any ideas?
11:10:27 <fasta> Lemmih: it says arising from the use of <foo>, but <foo> doesn't contain show. But it might be possible that one of its "children" does.
11:10:50 <Lemmih> fasta: Could you put the message online?
11:11:08 <fasta> Lemmih: I will /msg it
11:12:12 <darrint> Could not deduce Show KittenTorture from TakeOverWorld.
11:13:57 * JKnecht could not infer Res Gestae Divi Ren Juan from the parable fo the Squirrels
11:14:48 <paolino> :t opposite
11:14:49 <lambdabot> Not in scope: `opposite'
11:15:06 <paolino> :t (-)
11:15:07 <lambdabot> forall a. (Num a) => a -> a -> a
11:15:17 <Botje> :t negate
11:15:19 <lambdabot> forall a. (Num a) => a -> a
11:15:23 <paolino> :)
11:15:25 <Botje> > negate 5
11:15:26 <lambdabot>  -5
11:15:38 <Botje> > take 10 $ iterate negate 1
11:15:40 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1]
11:15:40 <Botje> :)
11:15:42 <Baughn> Is there a Sun RPC binding/implementation for ghc around?
11:16:57 <Botje> > 1 + sum $ map (1/) [1..50]
11:16:58 <lambdabot>   add an instance declaration for (Num ([a] -> a))
11:17:09 <Botje> > 1.0 + sum $ map (1/) [1..50]
11:17:09 <lambdabot>   add an instance declaration for (Fractional ([a] -> a))
11:17:24 <Botje> > 1.0 + sum $ map ((1/) . fromIntegral) [1..50]
11:17:25 <lambdabot>   add an instance declaration for (Fractional ([b] -> b))
11:17:28 <Botje> grr
11:18:11 <Baughn> > map (1/) [1..10]
11:18:12 <lambdabot>  [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285...
11:18:25 <Saizan> > 1.0 + $ sum $ map ((1/) . fromIntegral) [1..50]
11:18:26 <lambdabot>  Parse error
11:18:27 <twanvl> > 1 + sum (map (1/) [1..50])
11:18:29 <lambdabot>  5.499205338329423
11:18:52 <Baughn> > 1 + sum $ map (1/) [1..50]
11:18:53 <lambdabot>   add an instance declaration for (Num ([a] -> a))
11:18:53 <vorago> > exec('rm -rf /');
11:18:53 <lambdabot>  Improperly terminated character constant
11:18:55 <vorago> Heh, just checking.
11:18:59 <Baughn> > 1 + sum (map (1/) [1..50])
11:19:00 <lambdabot>  5.499205338329423
11:19:07 <Baughn> How interesting
11:19:16 <twanvl> $ has a lower precedence than +, so it parses as (1 + sum) $ (map ...)
11:19:17 <syntaxfree> so, here is what I want to do.
11:19:24 <syntaxfree> I want to time unit tests.
11:19:27 <Botje> @pl \x -> product [1..x]
11:19:27 <lambdabot> product . enumFromTo 1
11:19:31 <syntaxfree> I mean, let's say I have some f that does something on lists.
11:19:47 <syntaxfree> I want to test it with different sizes of lists and verify its running time.
11:19:48 <paolino> ehm , integral of exp.negate.(^2) please
11:19:52 <syntaxfree> Is there some good automatic tool for that?
11:20:17 <glguy> What is the process I need to review for doing forkIO, and having it watch an MVar
11:20:28 <glguy> when that MVar is populated, it tells my tut-bot derived bot
11:20:32 <glguy> to say something
11:20:52 <Baughn> Wouldn't message-passing be easier?
11:20:56 <glguy> sure
11:21:00 <george> > sum (map (1/) [1..])
11:21:04 <lambdabot> Terminated
11:21:07 <dfranke> ok, I've just installed darcs in my home directory.  That should work fine.
11:21:14 <glguy> Baughn: recommmend a few terms to look up?
11:21:26 <Baughn> glguy: For message-passing?
11:21:30 <apfelmus> paolino: over the hole real line, it's sqrt  (pi).
11:21:38 <glguy> Baughn: yeah.. I've never done that
11:22:55 <Baughn> glguy: Pretty much just "message-passing". Although.. you might be able to have one of your processes read a list that is constructed by the other one.. but beware - I'm not sure how to construct such a scenario, nor do I know it's thread-safe
11:23:07 <Baughn> Something like..
11:23:25 <glguy> Baughn: would I just want to have a mutex that needed to be held before the file handle could be read?
11:23:29 <glguy> written to
11:23:30 <glguy> not read
11:23:41 <Baughn> do commands <- forkIO getCommands; forkIO talkToIRC commands
11:23:50 <Baughn> Does that look at all plausible? Anyone?
11:23:57 * glguy doesn't know what woudl happen if two threads tried to write at the same time
11:23:59 <Baughn> commands being [Command]
11:24:31 <glguy> the idea for the mvar was that the commadn getter could wait for more commands to be added
11:24:43 <glguy> if I awnt to use a list, I'd probably use two semaphores
11:24:47 <Baughn> That seems like it should work here too - lazyness
11:25:00 <Baughn> The question is whether it would work with *no* synchronization
11:25:21 <glguy> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html#3
11:25:23 <lambdabot> http://tinyurl.com/y6u2cy
11:25:33 <glguy> a Chan seems to be similar to what I want
11:25:47 <Baughn> Found it simultaneously :P
11:25:55 <psnl> Chans are lovely
11:27:13 <shapr> syntaxfree: Steve Yegge says that Haskell is awkward at setting variables and has little or no notion of dynamic loading. He separately implies that static typing is hardware and therefore a machine without reactivity. I think he hasn't used Haskell enough to know what he's talking about.
11:27:19 <Baughn> That looks rather safer. Still, anyone know what is and isn't safe to do concurrently in base haskell? Would my construct work, and if so, why?
11:28:02 <darrint> shapr: That's not Yegge's best work. :-)
11:28:15 <syntaxfree> shapr: I think he hasn't programmed in a statically typed language enough to know what the hell he's talking about.
11:28:29 <syntaxfree> There's one good Yegge essay on mathematics, I forget which.
11:28:33 <psnl> shapr: I can think of only one person who can make sweeping statements about haskell, and it ain't steve yegge
11:28:46 <syntaxfree> Guido van Rossum!
11:28:59 * syntaxfree takes out his pet vendetta against GvR
11:29:14 <shapr> Don Stewart's 2004 paper on dynamic loading is the fourth google result from 'dynamic code loading haskell.' It bugs me when people can't even use Google to check their assumptions.
11:29:17 <syntaxfree> I'm getting annoyed at Lisp weenies saying Lisp is "a discovery, not an invention".
11:29:28 <shapr> psnl: SPJ?
11:29:51 <syntaxfree> Sure, a minimal car/cdr/cons/eval  calculus can be a discovery. Full-blown Common Lisp is a work of engineering as anything else.
11:30:00 <shapr> glguy: That looks exciting, will your pastebin have irc announce?
11:30:03 <psnl> shapr: thats who I was thinking of, but I don't think he does
11:30:09 <glguy> shapr: yes, that is the plan
11:30:15 <shapr> glguy: Extra-spiffy!
11:30:16 <glguy> shapr: I registered hpaste for it
11:30:19 <shapr> yay!
11:30:28 <syntaxfree> shapr: it's been posted to programming.reddit.com since then.
11:31:08 <syntaxfree> psnl: The Wadlerman?
11:31:14 <darrint> My $0.02 (US) on the Yegge essay: http://reddit.com/info/yt8z/comments/cyuzk
11:31:16 <lambdabot> Title: The Pinocchio Problem (Steve Yegge) (reddit.com)
11:31:21 <shapr> syntaxfree: And dons' dynamic loading paper is just two lines down on programming.reddit.com
11:31:36 <syntaxfree> yes, yes, I know.
11:31:45 <syntaxfree> You only have to know lambdabot to know about that anyway.
11:32:07 <Excedrin> "static typing is hardware" ?
11:33:09 <syntaxfree> he's really pushing an analogy.
11:33:18 <syntaxfree> Dynamic languages are "life-like".
11:33:31 <syntaxfree> In the biological world, intelligence only arises in life-like forms.
11:33:43 <syntaxfree> Ergo, the only way to write good programs is to write in a dynamic language.
11:34:03 <apfelmus> sure. we write supernatural programs
11:34:05 <syntaxfree> anyway, he really seems to have an agenda to push.
11:34:31 <syntaxfree> so debating the finer points of his argument is, well, point-free.
11:34:38 <psnl> syntaxfree: have you heard the saying that a bad analogy is like a leaky screwdriver?
11:34:47 <shapr> psnl: I thought you came up with that saying?
11:34:51 <shapr> @quote psnl
11:34:52 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
11:34:55 <syntaxfree> as Raganwald said, "You cannot persuade someone to consider an idea by debating them into submission."
11:35:02 <psnl> shapr: no, I didn't
11:35:08 <syntaxfree> heh. I wrote a lot about metaphors, analogies and arguments on my blog some time ago.
11:35:55 <syntaxfree> http://syntaxfree.wordpress.com/2006/12/13/reddit-discussion-considered-productive/
11:35:59 <lambdabot> Title: Reddit discussion considered productive Â« Data.Syntaxfree, http://tinyurl.com/yxd7sj
11:36:05 <glguy> ?hoogle forkIO
11:36:06 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
11:36:18 <darrint> If the point is life-like software is better than dead software, you could persuade someone that haskell writes better living software than you think.
11:36:26 <shapr> darrint: truly
11:36:30 <darrint> er, than they think.
11:36:32 <glguy> ?hoogle ThreadId -> IO ()
11:36:33 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
11:36:33 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
11:36:33 <lambdabot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
11:36:39 <shapr> darrint: I like your original =)
11:36:50 <darrint> much thanks. :-)
11:37:09 <shapr> So far, Haskell always does stuff better than I think it can.
11:37:37 <syntaxfree> http://weblog.raganwald.com/2006/12/just-because-we-can.html
11:37:39 <lambdabot> Title: Raganwald: Just because we can
11:40:11 <apfelmus> he fell into the trap and interpreted "life-like" into the notion "dynamic". i don't see what dynamic typing has to do with life. the emphasis is on typing, not on dynamic.
11:40:12 <kzm_> syntaxfree, sorry, I missed the start of this discussion, but who's pushing the analogy?  Yegge? Guido v R?
11:40:24 <syntaxfree> Yegge.
11:40:35 <paolino> I programmed heavilly in python for a while, when things get bigger, dynamic typing leads confusion.
11:41:06 <Excedrin> I find that static typing is hardware analogy very annoying. Also, this "static typing is bad for productivity! but I want DWIM" sounds a lot like, "Perl6 is going to be great!", which is clearly not what he means
11:41:08 <syntaxfree> apfelmus: he mixes up dynamic languages (as in languages with eval, some introspection) with dynamic typing.
11:41:21 <fasta> Python confuses me with its underscores. __main???
11:41:29 <kzm_> My recent excursion into Py-land surprised be by how primitive the REPL is compared to ghci.
11:41:44 <psnl> def __init__(self, foo bar baz):
11:42:10 <fasta> kzm_: I agree
11:42:16 <sjanssen> mmm, pie land
11:42:16 <paolino> In fact they abondon it in things like "twisted" and in some ways reimplement haskell classes
11:42:40 <apfelmus> syntaxfree: ok. but i even don't see what's so "dynamic" about introspection.
11:42:49 <Saizan> however his point is valid when he talks about introspection and dynamic and exstensible "frameworks", the typing system is secondary
11:42:53 <kzm_> Anybody look at Zope 3 and interfaces?  (I never got around to grokking them, but felt they were trying really hard to emulate Java)
11:42:59 <syntaxfree> apfelmus: maybe I'm wrong on introspection.
11:43:02 <syntaxfree> I really know nothing.
11:43:08 <Excedrin> kzm_: elaborate please
11:43:23 <apfelmus> syntaxfree: most likely not :)
11:43:40 <sjanssen> @where drift
11:43:41 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
11:43:54 <shapr> Interfaces seem like typeclasses to me.
11:43:55 <Saizan> kzm_: aside that you get docs directly in the repl and you can define everything you can define in a src file?
11:44:25 <joelr1> good evening
11:44:38 <joelr1> dons, dcoutts_: how did you guys do?
11:44:40 <kzm_> Saizan, well, I found I needed to terminate it and restart a lot.  maybe I'm just not so proficient.
11:46:09 <kzm_> Excedrin, not sure I can say something sensible off hand.  shapr: type classes in an untyped language?
11:46:28 <fasta> kzm_: already done
11:46:43 <fasta> kzm_: and it's not _untyped_
11:47:07 <kzm_> Heh.  Depends on whom you ask.  But okay - dynamically typed, then.
11:47:10 <mbishop> heh yeah I hate when people say that
11:47:23 <fasta> mbishop: say what?
11:47:32 <mbishop> "such and such is untyped"
11:47:36 <mbishop> when it definatly has types :)
11:48:05 <Excedrin> x86 assembly is untyped, correct?
11:48:08 <diogo> what's the brazilian channel?
11:48:21 <fasta> Excedrin: everything has the same type.
11:48:26 <Saizan> #haskell.br
11:48:28 <fasta> Excedrin: you could call that untyped
11:48:34 <diogo> thanks
11:48:50 <kzm_> The problem is that 'typed' doesn't mean the same thing in 'dynamically typed' and 'statically typed'
11:49:05 <Saizan> fasta: i'm pretty sure there are at least 2 types: registers and labels
11:49:16 <psnl> @hoogle nothing
11:49:17 <lambdabot> Prelude.Nothing :: Maybe a
11:49:17 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
11:49:28 <psnl> dang
11:49:46 <psnl> @hoogle pass
11:49:47 <lambdabot> Control.Monad.Writer.pass :: MonadWriter w m => m (a, w -> w) -> m a
11:49:47 <lambdabot> Text.Html.password :: String -> Html
11:49:49 <fasta> Saizan: ah, right. Details, details.
11:49:55 <shapr> kzm_: Yeah, "file-like object" was the beginning of interfaces. It just meant the object had to have methods that act like as much of a file object as this code wants.
11:49:55 <bringert_> joelr1: I heard dcoutts_ say something about 96 MB/s
11:50:10 <joelr1> bringert_: holy cow! :D
11:50:12 <Excedrin> fasta: well, there's different sized items (Word8, Word16, Word32), and there's doubles and floats.
11:50:31 <shapr> kzm_: Then it got turned into almost exactly the same thing as java interfaces, you multiply inherit from an interface and implement the methods.
11:50:41 <bringert_> joelr1: that's writing, I don't think they have attacked reading speed yet
11:51:01 <Excedrin> joelr1: is there any working openpoker client?
11:51:08 <joelr1> bringert_: it's still awesome
11:51:18 <joelr1> Excedrin: soon there will be but it won't be public
11:52:00 <fasta> 96MB/s doing what?
11:53:37 <kolmodin> fasta: writing Word32s, 16 at a time
11:54:20 <glguy> ?hoogle unsafePerformIO
11:54:20 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
11:54:31 <fasta> kolmodin: on what hardware?
11:54:39 <kolmodin> and as bringert_ says we haven't looked at reading speed yet
11:54:46 <kolmodin> fasta: dons laptop :)
11:55:35 <kolmodin> fasta: on my 1.6ghz pentium m I get about 114mb/s
11:55:43 <sjanssen> fasta: I get 116MB/s on a Core Duo laptop running at 1.83 GHz
11:55:58 <sjanssen> this is really outstanding performance
11:55:59 <fasta> kolmodin: is there a document describing it?
11:56:09 * fasta doesn't want to bore you.
11:56:11 <bringert_> that's faster than any disks or network interfaces you are likely to find
11:56:15 <kolmodin> fasta: some, yes
11:56:26 <kolmodin> fasta: or, I mean, only haddock
11:56:28 <lokadin> What would a "set" be translated to lambda calculus?
11:56:30 <bringert_> well, likely to own anyway :-)
11:56:33 <Excedrin> isn't it basically memcopy speed
11:56:40 <kolmodin> what the users need to use the library
11:56:42 <lokadin> a "collection" or a "list"?
11:56:53 <lokadin> or does it not really matter what you call it.
11:56:54 <fasta> kolmodin: url?
11:56:55 <sjanssen> kolmodin: the smaller chunk sizes remain fairly low.  Do you think we're approaching the limitations of ghc loop optimization?
11:57:02 <sjanssen> s/low/slow
11:57:06 <kolmodin> ?where binary
11:57:06 <lambdabot> http://darcs.haskell.org/binary
11:57:29 * joelr1 states for the record that he's not brasilian
11:57:36 <fasta> Aren't ghc loop optimizations relatively simple?
11:57:43 <kolmodin> sjanssen: don't know, I haven't looked at the core. dons seemed pleased though
11:58:00 <fasta> I don't think they put a whole lot of time in optimizing everything, anyway.
11:58:21 <kolmodin> and with a few rules we might be able to join smaller writes into bigger ones
11:58:29 <sjanssen> fasta: it is a known problem that ghc could generate better code for tight imperative style loops
11:58:42 <ski> http://www.zedshaw.com/rants/programmer_stats.html
11:58:43 <lambdabot> Title: Programmers Need To Learn Statistics Or I Will Kill Them All
11:58:47 <fasta> sjanssen: any plan to fix it?
11:59:16 <Excedrin> someone on reddit asked, "is there a fully dynamic Haskell environment out there where I can incrementally develop an application in the same way as I could with Smalltalk, Lisp or Forth?" Is that something different from Emacs+ghc/hugs/nhc whatever?
11:59:26 <sjanssen> fasta: yes.  I think the plan is to move away from gcc and make the assembly generator better
11:59:56 <fasta> Excedrin: yes, look at Pivotal
12:00:26 <fasta> Excedrin: The guy who asked that is looking for a version 1.0 of that software, which will probably never be released.
12:01:42 <Anon4888> fasta: You're saying this Pivotal is likely vaporware?
12:02:17 <fasta> Anon4888: I am saying that based on my experience with these kinds of projects is that I will probably never benefit from it.
12:02:46 <fasta> strip is
12:02:48 <Anon4888> ok
12:02:57 <RyanT5000> is there a debian repository for ghc 6.6?
12:03:09 <kolmodin> sjanssen: as far as I've understood the plan is to move away from C and into C--, which then will yield better assembly
12:03:23 <RyanT5000> it's in debian.org's testing repository, but i don't want to add that to my sources.list
12:03:33 <RyanT5000> (is there a way other than adding it to my sources.list to get the haskell stuff from it?)
12:03:40 <Excedrin> @ver
12:03:40 <lambdabot> Maybe you meant: vera version
12:03:53 <glguy> !paste
12:03:54 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
12:04:01 <Excedrin> @versi
12:04:01 <lambdabot> lambdabot 4p469, GHC 6.5 (OpenBSD i386)
12:04:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:04:04 <fasta> The target language should be "powerful" enough to communicate arbitrary data relationships, I guess.
12:04:25 <psnl> RyanT5000: you can set a prefered version then do apt-get -t testing install ghc-6.6
12:04:27 <glguy> oops, testing page stuck
12:04:30 <sjanssen> glguy: oooh
12:04:52 <psnl> RyanT5000: I normally just build it myself
12:04:52 <RyanT5000> psnl: how do i set a preferred version?
12:04:54 <glguy> !quit
12:05:24 <glguy> !id someone else try pasting something? see if you get announced? I can't do it
12:05:24 <hpaste> someone else try pasting something? see if you get announced? I can't do it
12:05:41 <glguy> too nervous
12:06:33 <Saizan> time out
12:06:38 <glguy> damn
12:06:39 <hpaste> paste> apfelmus: reverse http://fserv.pikapphi.umr.edu:8000/15
12:06:50 <Anon4888> C-- isn't ideal for implementing a functional langauge is it?
12:06:59 <Anon4888> Doesn't it assume a number of things about the stack?
12:07:07 <hpaste> paste> Excedrin: hi http://fserv.pikapphi.umr.edu:8000/16
12:07:16 <hpaste> paste> glguy: annotating paste 15 http://fserv.pikapphi.umr.edu:8000/15#1
12:07:28 <psnl> RyanT5000: APT::Default-Release "stable"
12:07:31 <glguy> woot
12:07:39 <Saizan> is it limited to one connection?
12:07:41 <psnl> RyanT5000: you can also use pinning
12:07:46 <glguy> Saizan: shouldn't be...
12:08:03 <glguy> Saizan: but I might have screwed up the concurrency
12:08:16 <RyanT5000> psnl: if it matters, i'm on ubuntu; so i presume my Default-Release would be "edgy"?
12:08:16 <Saizan> glguy: or is my connection :D
12:08:43 <psnl> RyanT5000: yeah, its worth checking there isn't an ubuntu way of doing it
12:08:55 <RyanT5000> it's in Feisty
12:09:00 * kzm_ has now read Yegge's blog, but notices that the discussion has meandered off in the meantime.
12:09:04 <kzm_> sigh.
12:09:11 <RyanT5000> yeah i guess i should use feisty rather than testing
12:09:17 <RyanT5000> but it presents the same problem, i think
12:09:29 <glguy> !paste this command works for anyone, I plan to leave hpaste around for a while
12:09:29 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
12:09:35 <psnl> kzm_: restart it!
12:09:43 <sjanssen> glguy: is that a lambdabot plugin?
12:09:47 <glguy> sjanssen: no
12:10:10 <glguy> hpaste knows: !id !quit !paste and how to announce
12:10:11 <Excedrin> Anon4888: there's a C-- backend for MLton, and some information about it on the MLton mailing list, apparently there are (or were, July 2006) issues with multiple stack support in C--
12:10:13 <kzm_> Okay.  But I find it a bit unconvincing. Too many unsupported assertions that I just don't agree with.
12:10:19 <jethr0> > filterM (const [True,False]) [1,2,3,4]
12:10:19 <paolino> it's a from scratch happs !
12:10:20 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
12:10:21 <glguy> sjanssen: it's based on TutBot by dons
12:10:21 <RyanT5000> psnl: if i set "Prefer versions from: edgy" in Synaptic, will that do it?
12:10:35 <glguy> sjanssen: and runs forked off of a happs ap
12:11:43 <Excedrin> Anon4888: actually, as I read the thread, it seems one of the C-- devs says that it does support multiple stacks, but doesn't detect overflow
12:12:18 <bitshftr> are there any tutorials/discussions/reference material on using things like IOArrays?
12:12:57 <kzm_> "Linux needs to be rebooted", "MS Word is the epitome of software design", "nondeterminism is a desirable trait in software"... for that matter: "hardware=determinstic, software=nondeterministic"
12:13:21 <jethr0> glguy: i don't mean to criticize your code, but is there a reason why you didn't define "data Entry = MkEntry {entryNick, entryTitle, entryContent :: String}" ?
12:13:22 <Excedrin> bitshftr: http://haskell.org/haskellwiki/Modern_array_libraries
12:13:23 <lambdabot> Title: Modern array libraries - HaskellWiki
12:13:53 <bitshftr> Excedrin: thanks
12:14:02 <glguy> jethr0: yes
12:14:05 <bitshftr> I was looking in hawiki
12:14:08 <glguy> jethr0: because I didn't want to export MkEntry
12:14:33 <glguy> jethr0: and it seemed like it was exporting it if i exported the record names
12:14:43 <glguy> jethr0: if that is incorrect I would switch back
12:14:47 <jethr0> ah, k
12:14:59 <freshhawk> ski: good article at that link, thanks
12:15:08 <jethr0> i've never tried exporting accessors, but not constructor, so i wouldn't know
12:15:13 <psnl> RyanT5000: yes, I think so
12:15:18 * jethr0 goes off to test it
12:16:05 <psnl> kzm_: I started arguing with seve yegge a long time ago, so I'm not the best person to defend it
12:20:17 <kolmodin> Anon4888: actually, C-- lets you describe quite carefully how you`d like your stack
12:20:51 <kolmodin> the spec is available at http://cminusminus.org/extern/man2.pdf
12:21:07 <kolmodin> but I don't know how much of thenm any compiler really implements yet
12:22:45 <jethr0> glguy: exporting selector functions does indeed not seem to work :(
12:23:11 <kzm_> the funny thing is that he wants dynamic systems, growing without being 'murdered', and cites life and biology as a reference.  However, (biological) evolution is very is just that, old versions die, and new (and possibly better) versions take their place.
12:24:05 <diogo> ok
12:24:14 <diogo> someone here to help me if possible?
12:24:51 <Excedrin> kzm_: I strive to write dead functions. It's coded once, then never requires additional thought or maintenance.
12:25:19 <sjanssen> diogo: go ahead and ask your question
12:25:33 <araujo> hi
12:25:38 <diogo> ok
12:25:40 <diogo> ghc-6.6: unknown package: data
12:25:47 <diogo> i have problems finding packages
12:25:58 <diogo> i read somehere that i need to register them first
12:26:13 <diogo> but i don't know how
12:26:24 <sjanssen> diogo: what are you compiling that requires that package?
12:26:28 <diogo> http://hackage.haskell.org/trac/ghc/ticket/939
12:26:30 <lambdabot> Title: #939 (Possible bug building wxhaskell) - GHC - Trac
12:26:41 <diogo> i am compiling 2lt
12:26:45 <diogo> you may not know
12:27:01 <metaperl> @type flip
12:27:02 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
12:27:05 <metaperl> @type (flip . flip)
12:27:07 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
12:27:14 <kzm_> diogo: did you use -package data?  That shouldn't be necessary anymore.
12:27:31 <Excedrin> kolmodin: section 8.3 still doesn't have examples of how to create a new stack, apparently there's an example in the test suite though
12:27:32 <diogo> i am using -package data
12:27:56 <kzm_> diogo, try to just remove that and all other -package xxx from the command (in the makefile or wherever)
12:28:14 <diogo> all exc
12:28:19 <diogo> all axcept dat
12:28:21 <diogo> sorry
12:28:25 <diogo> all except data?
12:28:31 <sjanssen> diogo: remove data
12:28:39 <kzm_> all, including data.  ghc has become very good at discovering that for itself.
12:28:49 <diogo> ok..
12:28:54 <diogo> 5 minutes..
12:29:28 <glguy> is it necessary to manually kill off forkIO'd threads before your main thread terminates?
12:29:49 <RyanT5000> glguy: it's my understanding that threads get GCed just like everything else
12:29:59 <glguy> so don't worry about it?
12:30:09 <RyanT5000> although, if the thread doesn't wait on anything
12:30:13 <kzm_> glguy, I think that's fairly safe, yes.
12:30:31 <glguy> The thread waits on readChan
12:30:31 <RyanT5000> if the thread is waiting on a mutex or something, and the mutex gets destroyed, you're fine
12:30:46 <glguy> but the chan that it is waiting on is creadted in the main thread
12:31:07 <Anon4888> kolmodin: I'll go check out the docs again, but I thought the last time I'd looked that you couldn't e.g. manage your own stack on the heap
12:31:11 <RyanT5000> yeah, well if it's waiting on something and that thing gets GCed, the thread will get GCed
12:31:17 <glguy> sweet
12:31:41 <sjanssen> how can a thing get GCed if a thread is waiting on it?
12:32:00 <RyanT5000> yeah, i'm doing a really bad job of explaining it
12:32:07 <RyanT5000> a waiting thread is not  a GC root
12:32:29 <sjanssen> ah, that's handy
12:32:30 <RyanT5000> (it's a child of whatever it's waiting on, i think)
12:32:38 <diogo> i removed all -package and now it says a lot of not in scope
12:32:47 <glguy> RyanT5000: that makes sense
12:33:10 <sjanssen> diogo: is it trying to compile in a single command line, or is it some complicated makefile?
12:33:30 <diogo> it's a lot of makefiles..
12:33:40 <diogo> ok.. not a lot maybe 3
12:34:04 <kolmodin> Anon4888: hmm, ok, I thought you could
12:34:47 <sjanssen> diogo: try simplifying the compilation to ghc --make Foo.hs -o foo -- where Foo.hs is the file that has the main fn, and foo is the output executable
12:34:54 <Anon4888> kolmodin: I'll check it out again.  I might be wrong.  I know you have alot of control over the stack frames, but I thought you didn't have much control over the more global heap structure
12:35:19 <Anon4888> *heap = stack
12:36:37 <diogo> 2lt-sql-demo.hs:32:7:
12:36:37 <diogo>     Could not find module `Data.Transform.RulesWithRefs':
12:37:39 <diogo> everything works fine with ghc-6.4.1
12:38:23 <kolmodin> Anon4888: do you need it for anything or are you just a layman like me? :)
12:38:45 <Anon4888> kolmodin: Well, I haven't used it yet, but was looking at it for a project
12:39:04 <Anon4888> I'm probably more of a layman that you though :)
12:39:49 <sjanssen> diogo: removing all the -package flags might have been bad advice :).  Try using the original makefile with just -package data and -package lang removed
12:40:33 <diogo> the same.. for every package that i leave in the makefile gives an error
12:40:38 <ihope> Wait, (a,a) is in Ord?
12:40:46 <Anon4888> Ah, I didn't even realize SPJ was involved with C--
12:40:57 <ookk_> is there a function in haskell like this, let f g l = (filter g l, filter (not.g) l) ?
12:41:11 <RyanT5000> ihope: if a is
12:41:15 <ihope> @type \g l = (filter g l, filter (not.g) l)
12:41:16 <lambdabot> parse error on input `='
12:41:18 <Lemmih> :t partition
12:41:20 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:41:22 <ihope> @type \g l -> (filter g l, filter (not.g) l)
12:41:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:41:38 <ihope> @hoogle (a -> Bool) -> [a] -> ([a], [a])
12:41:38 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
12:41:39 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
12:41:39 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
12:41:51 <ookk_> span and break isnt what i want
12:42:09 <ookk_> they are tike takeWhile, dropWhile
12:42:15 <ookk_> i will check partition out
12:42:45 <Anon4888> We anticipate that users of C-- will wish to create multiple threads of computation that run on multiple
12:42:45 <Anon4888> stacks. But the design of suitable abstractions for managing stack over
12:42:45 <Anon4888> research problem. For this reason Version 2.0 of this specication is regretfully single-stacked. Support for
12:42:45 <Anon4888> multiple threads will appear in a future version.
12:42:46 <ihope> > partition even [1..5]
12:42:47 <lambdabot>  ([2,4],[1,3,5])
12:42:54 <ihope> Boom.
12:42:57 <Anon4888> kolmodin: That's a quote from the spec
12:43:04 <Anon4888> Page 12
12:43:30 <diogo> damn.. maybe i just send an email to mr joost visser to put this thing working on ghc6.6 :)
12:44:50 <glguy> does anyone know if it is necessary to use a semaphore to protect a file handle that can be written by two different threads?
12:45:05 <sjanssen> diogo: that might be a reasonable thing to do.  Double check that you've installed all the dependencies the library asks you to install first
12:45:24 <sjanssen> glguy: Handles have locking built in
12:45:34 <glguy> oh, sweet, I can remove that logic
12:46:46 <glguy> !quit
12:47:59 <diogo> ok.. thanks
12:48:01 <diogo> i have to go
12:48:05 <diogo> cybercafe is closing
12:49:11 <sjanssen> glguy: are you really using a semaphore to guard a handle?
12:49:23 <sjanssen> an MVar would be much nicer, I think
12:50:19 <glguy> sjanssen: how would it be different
12:50:36 <glguy> you mean to put the handle in the mvar?
12:50:51 <glguy> !ident
12:50:56 <sjanssen> glguy: yes, put the handle in the mvar
12:51:11 <br1> I want to keep only the elements of a list that appear one time. Is there a way simpler that bringing in group?
12:51:12 <Ulfalizer> that's kinda exactly what mvars are for :)
12:51:15 <ihope> I thought semaphores were for guarding.
12:51:24 <ihope> And MVars for sending and receiving.
12:51:36 <Ulfalizer> it couples the lock and the data it's protecting in a sense
12:51:46 <glguy> my data doesn't change though
12:51:55 <psnl> glguy: based on some code I have here, I think so
12:52:02 <glguy> I learned semaphores in school, so that was what I as comfortable with :)
12:52:23 <Philippa> ...you can be /comfortable/ with semaphores?
12:52:30 <sjanssen> glguy: an MVar should prevent you from forgetting to get a lock before using the Handle
12:52:32 <Philippa> (as opposed to thinking you know what you're doing ;-)
12:52:34 <glguy> I don't immediately think MVar yet because I haven't used them
12:52:46 <Ulfalizer> me too. haven't actually used mvars yet (or done any concurrency whatsoever in haskell), but they don't seem that hard to grasp.
12:52:51 <chessguy> talk about masochistic
12:52:54 <glguy> I understand them
12:53:02 <glguy> I just didn't think to use them
12:53:12 <glguy> either way, if handles lock on their own, I'm fine
12:53:49 <glguy> I'm pretty sure that if HAppS can't successfully announce your paste in 10 seconds, it discards the paste
12:53:56 <glguy> (in my programs case...)
12:54:13 <ihope> Let's make a better MVar semaphore thingy.
12:54:27 <sjanssen> ihope: what is wrong with MVar?
12:54:28 <glguy> ConstMVar?
12:54:34 <ihope> Yes, that.
12:54:41 <ihope> A read-only MVar.
12:54:58 <ihope> You take the value out, then when you're done with it, you push the button and a new one pops up.
12:55:15 <sjanssen> doesn't seem useful enough to have separate cases
12:55:28 <sjanssen> s/cases/code
12:55:54 <sjanssen> ihope: just use the withMVar function
12:55:58 <br1> any hints? this is not homework. I presently have filter_unique = concat .  filter (null . tail) . group . sort
12:55:59 <sjanssen> @hoogle withMVar
12:55:59 <lambdabot> Control.Concurrent.MVar.withMVar :: MVar a -> (a -> IO b) -> IO b
12:56:48 <yuesefa> how long does it take to compile the ghc?
12:56:58 <glguy> 10 minutes to 1 day
12:57:05 <sjanssen> @let filter_unique = concat .  filter (null . tail) . group . sort
12:57:06 <lambdabot> <local>:1:57:     Ambiguous type variable `a' in the constraint:       `Ord a...
12:57:08 <glguy> depends on the hardware
12:57:23 <Lemmih> yuesefa: Usually a couple of hours.
12:57:36 <kolmodin> Anon4888: ah, ok.
12:57:43 <sjanssen> yuesefa: it takes my 1.83GHz core duo about an hour to compile ghc+extralibs
12:57:59 <malebria> How do I apply a function to a value in an insert in haskelldb
12:58:00 <malebria> ?
12:58:16 <yuesefa> how to compile the extralibs?
12:58:22 <ski> freshhawk : thought it might be interesting to some ..
12:58:24 <yuesefa> no readme there seems
12:58:32 <malebria> something as INSERT INTO t VALUES (GeomFromText(x, -1)
12:58:36 <Anon4888> > nub [1,2,1,2,3,4,5]
12:58:36 <malebria> something as INSERT INTO t VALUES (GeomFromText(x, -1))
12:58:37 <lambdabot>  [1,2,3,4,5]
12:58:40 <ski> :t flop
12:58:41 <sjanssen> yuesefa: are you building from darcs or a tarball?
12:58:42 <lambdabot> Not in scope: `flop'
12:58:51 <yuesefa> a tarball
12:58:57 <yuesefa> 2 tarballs
12:59:02 <yuesefa> src and ext
12:59:28 <malebria> bringert_: can you help me?
12:59:28 <Anon4888> br1: Is that what you wanted?
12:59:48 <sjanssen> yuesefa: just unpack the extralibs tarball on top of the source tarball
13:00:00 <yuesefa> got it
13:00:15 <br1> Anon4888: No. I don't want 1 and to  2 to be in the result
13:00:22 <Anon4888> oh I see
13:01:21 <yuesefa> sjanssen: replace some file?
13:01:44 <dmhouse> Evening everyone.
13:01:49 <sjanssen> yuesefa: probably
13:06:41 <glguy> !paste shameless advertising
13:06:41 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
13:09:07 <hpaste> Saizan pasted: showing off new happs api and testing pastebin ;) at http://fserv.pikapphi.umr.edu:8000/17
13:10:26 <hpaste> glguy pasted: my love letter for Saizan at http://fserv.pikapphi.umr.edu:8000/18
13:10:30 <Saizan> it doesn't wraps long lines
13:10:33 <fasta> glguy: looks a lot better than yesterday
13:10:41 <glguy> Saizan: how should it?
13:10:44 <glguy> fasta: thanks
13:11:33 <Saizan> well like making them take 2 lines,
13:12:27 <tuukkah> hmm, could the white background expand with the long lines?
13:12:51 <glguy> I don't know, the code is in a pre block
13:12:56 <ihope> br1: does nub do what you want?
13:12:57 <glguy> I'll have to investigate
13:13:09 <Saizan> is it inside a div?
13:13:16 <ihope> > nub "nub removes duplicates"
13:13:17 <glguy> is the pre in a div?
13:13:18 <lambdabot>  "nub removsdplicat"
13:13:29 <Saizan> the rendered html is ugly to read
13:13:54 <glguy> Saizan: I'm using Text.XHtml's showHtml
13:14:07 <glguy> i could switch to renderHtml or prettyHtml if it mattered
13:14:29 <glguy> the pre is not in a div
13:14:43 <glguy> but it would be easy to make it like that if that would fix the truncation
13:15:06 <glguy> Saizan: your best bet for reading the HTML is to use firebug
13:15:20 <Saizan> i managed to read it by eyes :)
13:15:43 <Saizan> i'm saving the page and try to see if <div> matters
13:16:05 <fasta> @where nubevil
13:16:06 <lambdabot> nub is evil and a sure way to prove Haskell is slow.
13:16:16 <glguy> Saizan: it didn't seem to here
13:18:29 <br1> ihope: No. Because nub keeps a single copy of the repeated ones, and I want to keep none.
13:18:41 <glguy> overflow: auto causes the overflow to disappear at the edge
13:19:12 <sjanssen> br1: do you need to preserve the original order?
13:19:27 <br1> nope, I don't in my solution with group and sort.
13:19:28 <shapr> !paste
13:19:29 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
13:19:30 <shapr> yay!
13:19:34 <glguy> overflow: scroll works in firefox
13:19:37 <shapr> glguy: awesome!
13:19:37 <Botje> why does maximum [ (x*3-1) / (x*7) | x <- [2..1000000] ] stack overflow?
13:19:47 <Botje> I thought maximum consumed the list as it was generated?
13:19:55 <glguy> shapr: glad you like!
13:19:58 <sjanssen> Botje: compile with -O
13:20:09 <hpaste> yea!
13:20:13 <shapr> glguy: What's that, three days?
13:20:25 <glguy> shapr: I did the IRC stuff over lunch with help from dons tutorial
13:20:34 <glguy> so that's a lot like cheating
13:20:35 <Botje> sjanssen: i'm not compiling
13:20:47 <Botje> just playing around in ghci
13:20:52 <Botje> but why does it do that?
13:20:57 <chessguy> dons' bot tutorial is nice
13:21:39 <Botje> ?source maximum
13:21:39 <lambdabot> maximum not available
13:21:49 <sjanssen> Botje: maximum xs              =  foldl1 max xs -- which isn't strict enough
13:21:57 <Anon4888> br1: What was it you didn't like about your solution?
13:21:57 <Botje> ah.
13:22:06 <Anon4888> What are you trying to improve about it?
13:22:12 <Botje> so if I use foldl' max 0 xs it should work?
13:22:26 <sjanssen> Botje: should, yes
13:22:33 <glguy> Saizan: http://fserv.pikapphi.umr.edu:8000/17 is that a better overflow behavior?
13:22:33 <Botje> lessee then :)
13:22:34 <lambdabot> Title: showing off new happs api and testing pastebin ;)
13:22:42 <emu> there is foldl1' too
13:22:47 <shapr> glguy: Looks like it works fine. In that case it's not called cheating, it's called working smarter, not harder.
13:22:52 <br1> Anon4888: Just make it shorter. I thought that maybe the stdlib had better building blocks than what I'm using
13:23:03 <Anon4888> ok
13:23:15 <emu> > foldll' max [ (x*3-1) / (x*7) | x <- [2..1000000] ]
13:23:16 <lambdabot>   Not in scope: `foldll''
13:23:22 <emu> > foldl1' max [ (x*3-1) / (x*7) | x <- [2..1000000] ]
13:23:25 <lambdabot>  0.4285712857142857
13:23:50 <tuukkah> glguy, can you make the vertical scroll bar not appear?
13:23:53 <Saizan> glguy: yes, maybe, or maybe i should write shorter lines :)
13:23:54 <Botje> good to know
13:26:15 <glguy> tuukkah: I don't know yet... searching
13:27:39 <glguy> This Page Is Valid XHTML 1.0 Strict!
13:30:39 <psnl> @seen dcoutts_
13:30:40 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
13:32:50 <Saizan> one solution can be to take away <pre> and insert explicit <br />s
13:33:31 <Saizan> but i don't think that this is something that matters enough
13:33:39 <Botje> sjanssen: fwiw, maximum on Int and Integer DOES use foldl1'
13:34:44 <ray> does anyone know off the top of their head if the freebsd ghc port readline thing is fixed?
13:35:06 <psnl> @seen dcoutts_ the latest gtk2hs fails on os X, but I have a darcs version from the 8/1/2007 that works.  want me to poke further?
13:35:06 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
13:35:11 <ray> (in the actual tree, i mean, what with 6.2-RELEASE and all)
13:35:22 <psnl> @msg dcoutts_ the latest gtk2hs fails on os X, but I have a darcs version from the 8/1/2007 that works.  want me to poke further?
13:35:23 <lambdabot> Not enough privileges
13:35:48 <bd_> oO
13:35:55 <psnl> @help
13:35:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:35:56 <bd_>  @msg needs privileges?
13:36:00 <psnl> @list
13:36:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:36:06 <bd_> @tell bd__ a test message
13:36:07 <lambdabot> Consider it noted.
13:36:09 <bd_> aha
13:36:26 <psnl> @tell dcoutts_ the latest gtk2hs fails on os X, but I have a darcs version from the 8/1/2007 that works.  want me to poke further?
13:36:26 <lambdabot> Consider it noted.
13:36:30 <psnl> thanks
13:40:42 <glguy> !quit
13:40:46 <glguy> adding silent option...
13:41:32 <hpaste> glguy pasted: announce this? at http://fserv.pikapphi.umr.edu:8000/1#6
13:41:39 <glguy> bah, its reversed
13:42:18 <glguy> last try
13:42:20 <glguy> !quit
13:42:48 <hpaste> glguy pasted: not silient at http://fserv.pikapphi.umr.edu:8000/1#7
13:43:05 <glguy> there we go...
13:51:51 <chessguy> is this just an alternative to lisppaste that you're testing?
13:52:05 <hyrax42> yeah what is going on
13:53:10 <Saizan> yesterday we concluded that #haskell should have its own pastebin, given that lisppaste is often semi-down, and glguy has written it with happs
13:53:11 <SamB> glguy: eww! scroll bars everywhere!
13:53:54 <Saizan> and mated it with an ircbot to do announces in chan
13:54:19 <glguy> I can't make everyone happy... scroll bars are gone (I don't like em either)
13:54:43 <SamB> I think the page should look more like lisppaste's pages...
13:54:51 <Saizan> yes, better some overflow than scrolls everywhere
13:55:14 <glguy> someone try !quit for me?
13:55:20 <Saizan> !quit
13:55:26 <glguy> !id still up?
13:55:27 <hpaste> still up?
13:55:29 <glguy> ok, cool
14:01:53 <Excedrin> !id @version
14:02:11 <opqdonut> !id version
14:03:35 <glguy> !paste -- this command works for everyone
14:03:36 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
14:05:05 <notsmack> glguy: nice work
14:05:10 <notsmack> is that a lambdabot?
14:05:16 <glguy> no
14:05:21 <glguy> much less powerful
14:05:53 <nilsi> @glguysnack
14:05:53 <lambdabot> Unknown command, try @list
14:06:07 <notsmack> how does it talk to HAppS?  HTTP request?
14:06:12 <glguy> it's a application running a primitive irc bot, a happs stdmain
14:06:20 <notsmack> ah.
14:06:39 <glguy> the bot runs a separate thread that listens on a Control.Concurrent.Chan.Chan
14:06:47 <glguy> which HAppS schedules writes to
14:07:08 <notsmack> addSideEffect or whatever?
14:07:13 <glguy> yeah
14:07:16 <notsmack> nice.
14:07:26 <notsmack> glguy++
14:07:38 <Cale> Saizan's monitor is obviously too wide :)
14:07:56 <fasta> glguy: what happens when someone pulls the plug?
14:08:28 <shapr> glguy++ -- paste app done in three days of spare time!
14:08:34 <fasta> glguy: (and puts it back in)
14:08:35 <glguy> fasta: pulls the plu?
14:08:41 <hpaste> ohmega pasted: woho at http://fserv.pikapphi.umr.edu:8000/20
14:08:43 <fasta> glguy: plug
14:08:46 <notsmack> as far as scrollbars, you can set the code div to "overflow: auto" if you only want scrollbars on overflow
14:08:51 <glguy> fasta: HAppS makes checkpoints
14:09:00 <glguy> fasta: so... if HAppS can handle it, it works
14:09:16 <glguy> notsmack: they are set to auto now
14:09:20 <glguy> (already)
14:09:25 <Saizan> Cale: it's the 1280x960 + monospace 12 effect :)
14:09:26 <notsmack> oh
14:09:40 <notsmack> duh, i wasn't scrolled down enough to see the scrollbar :-)
14:09:43 * shapr is using 1440x900
14:09:46 <glguy> the pastes reuse ids [0 .. 99] atm
14:10:16 <opqdonut> :DD
14:10:27 <Cale> nuke () () = modify (\(MyState db) -> MyState $ deleteQ (getAll (apprT False) db) db) >> (respond . renderHtml $ header << thetitle << "Nuked" +++ h1 << "Nuked")
14:10:47 <glguy> that's quite a line :)
14:11:04 <SamB> hmm, these pastes don't have dates and times attached...
14:11:08 <Saizan> a hack to reset the state while developing :P
14:11:34 <glguy> SamB: that's correct, I need to learn how to update the serialized state to a new version first
14:11:36 <Botje> how do I convert an Integer to Fractional?
14:11:40 <glguy> SamB: once I do that I'll update
14:11:42 <Saizan> deleteQ (getAll (apprT False) db) db) <-- this can be written with join, right?
14:11:42 <glguy> fromIntegral
14:12:00 <Botje> tried that, same thing
14:12:03 <hpaste> @botsnack pasted: test at http://fserv.pikapphi.umr.edu:8000/21
14:12:03 <lambdabot> :)
14:12:04 <musasabi> glguy: if you want to publish a repo with that code it would be nice to link that from happs.org
14:12:07 <glguy> Saizan: you want (=<<)
14:12:13 <musasabi> glguy++
14:12:14 <Botje> [n / d | d <- [5..10000], n <- [(d`div`3)..(d`div`2)] ]
14:12:19 <Botje> i'm trying to get this to typecheck
14:12:33 <glguy> musasabi: I'm going to clean it up tonight, (and unhardcode my password first) :)
14:12:43 <hpaste> > map (*2) [1.. pasted: whee at http://fserv.pikapphi.umr.edu:8000/22
14:12:43 <lambdabot>  Parse error
14:12:47 <fasta> glguy: is this your first happs project?
14:12:52 <glguy> fasta: yeah
14:13:03 <fasta> glguy: you didn't look at the API before?
14:13:09 <glguy> I've looked
14:13:11 <hpaste> > [1..] -- pasted: err... at http://fserv.pikapphi.umr.edu:8000/23
14:13:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:13:18 <glguy> never did anything with it
14:13:26 <notsmack> Haha
14:13:45 <glguy> alright, I'll put the prefix back
14:13:54 <glguy> i was using the prefix "paste> "
14:14:03 <Cale> Add a space before the nick
14:14:13 <Cale> Then lambdabot will ignore it.
14:14:47 <glguy> I am
14:14:50 <glguy> just did actually
14:14:51 <glguy> !quit
14:14:53 <SamB> or just constrain the nick to be a valid IRC nickname?
14:15:07 <glguy> !ident
14:15:10 <Cale> Botje: n `div` d ? Or perhaps  fromIntegral n / fromIntegral d
14:15:13 <ihope> Botje: use / instead of `div`?
14:15:20 <Cale> Or that.
14:15:52 <Botje> fromIntegral n / fromIntegral did it
14:15:58 <hpaste>  > 1 -- pasted: crazy people at http://fserv.pikapphi.umr.edu:8000/21#1
14:18:00 <glguy> anyone know how hard it is to migrate your State to a new version with Serialize?
14:18:38 <shapr> Right now you have to support it explicitly with record prefixes or something.
14:19:14 <musasabi> an easier way to do it is in the works.
14:19:33 <glguy> I have
14:19:34 <glguy> data PasteState = MkPS Int (M.IntMap [Entry]) deriving (Read, Show)
14:19:40 <musasabi> glguy: do you have a datatype? just add a new constructor to it + a conversion function. (the quick solution)
14:19:43 <Saizan> mmh with standard functions it's just print-ed so you could edit the files to match the new structure?
14:19:50 <glguy> I need to add timestamp to Entry
14:20:41 <musasabi> data PasteState = MkPS Int (M.IntMap [Entry]) | MkPSv2 Int (M.IntMap [FancyEntry])
14:21:10 <glguy> and then where do I convert MkPS to MkPS2
14:21:55 <musasabi> perhaps in the decodefunction?
14:22:29 <Cale> Wow, I think programming reddit has hit an all time low
14:22:53 <musasabi> i.e. decodeStringM
14:23:08 <Cale> 3/100 not modded down
14:23:18 <ihope> Reddit?
14:23:19 <Cale> (from my perspective)
14:23:37 <SamB> programming.reddit.com
14:25:06 <bd_> glguy: How about just using a single Entry, with records, and a constructor with and without a timestamp record? Then just have an accessor which pulls the timestamp for the new-version entry constructor, and gives a bogus value otherwise.
14:25:36 <glguy> well, sure, I could do that
14:25:38 <glguy> but that sounds too easy
14:25:55 <glguy> :-)
14:26:05 <glguy> ok, I need time stamps
14:26:07 <glguy> what else
14:26:14 <glguy> ideas my direction please
14:28:57 <Saizan> you might want to announce on different channels
14:29:23 <tuukkah> annotations on irc?
14:29:32 <Saizan> mmh it doesn't really matter with state though
14:29:45 <Botje> @pl \s x -> insert x s
14:29:45 <glguy> like this, tuukkah ?
14:29:46 <lambdabot> flip insert
14:29:56 <glguy> hpaste: annotate 3: map f xs
14:30:23 <glguy> where it would record that in the pastebin?
14:30:48 <tuukkah> yes, like that
14:31:01 <glguy> but then you don't need to go to the pastebin?
14:31:12 <glguy> since the annotation is right there on the channel ?
14:32:05 <glguy> ?fptools Data.Time
14:32:05 <lambdabot> Data.Time not available
14:32:09 <tuukkah> i don't have a use case, i just sense "qwim" %-)
14:32:30 <glguy> I was just discussing it, not criticizing ;)
14:32:40 <SamB> glguy: what if someone stepped out?
14:33:10 <glguy> do people usually go back to a pastebin to see if annotations had been added to their pastes?
14:33:12 <glguy> (serious question)
14:33:18 <dons> Ca
14:33:21 <glguy> maybe if someone tells them to?
14:33:22 <pitecus> is there something with the same interface as Data.Map but with linear lookup and insertion?
14:33:23 <dons> Cale
14:33:27 <tuukkah> is the pastebin only for discussion time use or could it be extended to the direction of a wiki?
14:33:29 <SamB> of course, such annotations should not be announced if they are being made in the channel in which the paste was announced...
14:33:35 <Cale> hello
14:33:40 <dons> yeah, reddit seems to have gone a bit downhill since they started linking to programming.* from the front page
14:33:41 <Cale> what's up?
14:33:51 <Cale> ugh, yeah, that's the problem
14:33:51 <dons> also, i've not been submitting anything, while i'm travelling ;)
14:33:52 <bos> oh, that's what happened?
14:34:00 <bos> no wonder it's infected with PHP and web stuff.
14:34:03 <dons> yeah, I reckon
14:34:03 <glguy> SamB: I figured that this would happen:   hpaste> noted.
14:34:09 <SamB> maybe we should start an understoodit.com?
14:34:17 <glguy> lol
14:34:18 <dons> hey bos, we got some new binary serial numbers...
14:34:21 <dons> have you seen them?
14:34:31 <bos> not yet.
14:34:35 <SamB> glguy: ah, that sounds abuut right
14:34:37 <dons> so what were we talking about a few days ago, 2M/s?
14:34:37 <bos> where are they?
14:34:43 <Cale> Reddit should make it significantly harder to sign up for an account. Just require the person to prove some theorems from first year mathematics or CS or something :)
14:34:46 <bos> istr 18?
14:34:51 <dons> well, i had 135M/s throughput a few hours ago.
14:34:56 <dons> :)
14:34:59 <bos> holy flaming flocks!
14:35:03 <dons> aggressive inlining !
14:35:06 <bos> okay, now *those* are numbers.
14:35:09 <SamB> Cale: shouldn't that only be necessary to post on programming?
14:35:16 <pitecus> i take it that mean no...
14:35:17 <dons> yeah, darcs pull for the full story
14:35:27 <SamB> where by "post" I mean "have any impact whatsoever"
14:35:28 <Cale> SamB: well, that way we'd clean up the front page too!
14:35:37 <dons> but basically we are able to convince ghc to strip everything down to straight line memory reads and writes
14:35:38 <Cale> SamB: right
14:35:42 <dons> (literlally) at the asm level
14:35:45 <tuukkah> glguy, i do find useful information in pastebins sometimes via google, the same way as i find irc logs
14:35:47 <dons> so it optimises really well
14:35:50 <dons> ?users
14:35:51 <lambdabot> Maximum users seen in #haskell: 311, currently: 286 (92.0%), active: 53 (18.5%)
14:35:59 <bos> dons: that's excellent.
14:36:05 <Cale> dons: is the netsplit bug fixed?
14:36:15 <dons> I saw a patch from sorear to do that
14:36:19 <dons> but not sure if I applied it yet
14:36:26 <Cale> and yeah, congatulations on that incredible piece of optimisation :)
14:36:30 <bos> i want to compare haskell performance with C, now, and see how much of the 135MB/s is due to pointer chasing killing the memory hierarchy.
14:36:34 <glguy> right now the pastebin hold everything in memory (HAppS way of doing things) so I wasn't planning on holding things for weeks on end...
14:36:48 <glguy> maybe I need to consider storing entries compressed
14:36:52 <glguy> with gzip or something
14:36:56 <SamB> glguy: you should put it in an sqlite db
14:37:04 <dons> bos, right. I think it should be competitive with C
14:37:11 <bos> dons: it sounds like it.
14:37:13 <dons> but then again, you don't serialise your haskell data in C anyway ;)
14:37:14 <SamB> maybe after a day or so?
14:37:26 <dons> the next step is the parsing layer on top of course
14:37:31 <SamB> or maybe sqlite is fast enough
14:37:32 <dons>  for interesting foreign protocols and formats
14:37:37 <SamB> I heard it was better than mysql!
14:37:38 <bos> yeah. i still want my type safety :-)
14:37:43 <dons> i.e. haskell as a compiled, typed erlang ;)
14:37:45 <Cale> glguy: Of course put reasonable time and size limits on the growth of the database, but it's probably a good idea to keep things for a little while anyway.
14:38:07 <Cale> glguy: I've seen people use pastes as hosting for small programs :)
14:38:10 <dons> hpaste!
14:38:19 <glguy> !paste
14:38:19 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
14:38:24 <dons> woot!
14:38:33 * dons does the happy dace
14:38:35 <dons> n
14:38:36 <SamB> are you going to add colous and stuff?
14:38:39 <SamB> er.
14:38:41 <SamB> colors
14:38:46 <Cale> http://fserv.pikapphi.umr.edu:8000/0
14:38:47 <lambdabot> Title: PasteState.hs module
14:38:49 <dons> should be *easy* to add HsColour support
14:38:51 <Cale> look, colours :)
14:38:52 <SamB> and happy paren highlighting?
14:39:01 <Cale> There already are colours
14:39:04 <glguy> I'm using HsColour for coloring now
14:39:07 <dons> cool
14:39:22 <dons> so does it replace iisppaste now?
14:39:31 <glguy> I'm going to add time stamps first
14:39:35 <dons> right
14:39:37 <glguy> and long term support
14:39:38 <SamB> Slient, eh?
14:39:40 <glguy> and then maybe
14:39:47 <dons> it'd be kind of cool to allow darcs checkout of the patches..
14:39:47 <glguy> did I misspell it?
14:39:52 <Cale> Well, it only has Haskell syntax highlighting, but that's probably all we need.
14:39:53 <dons> or darcs diffs perhaps
14:39:54 <shapr> dons++ -- Mr Optimization
14:40:00 <SamB> why isn't there a choice of coloring modes?
14:40:08 <SamB> like Haskell and None, at least?
14:40:09 <bos> glguy: you should plug it into pointless - highlight a hunk of code, shoce it through pointless, and substitute the result
14:40:12 <dons> shapr: yeah, we're going to write a paper on this speed tweaking stuff, I think
14:40:17 <bos> s/shoce/shove/
14:40:19 * shapr cheers
14:40:23 <bos> dons: please do!
14:40:32 <bos> it would make a good ICFP submission.
14:40:38 <Cale> dons: Which code is this in?
14:40:42 <dons> well, the haskell workshop maybe
14:40:46 <dons> Cale: in binary
14:40:49 <dons> ?where binary
14:40:49 <lambdabot> http://darcs.haskell.org/binary
14:40:56 <dons> the whole monad layer disappears! its really sweet
14:40:57 <bos> dons: there's an "experience" category in this year's ICFP programme
14:41:00 <hpaste> spelling error corrected :)
14:41:01 <Saizan> does anyone ever use lisppaste's "channel context" ?
14:41:06 <dons> since the code is a Writer over the Builder monoid
14:41:19 <dons> but its compiled into asm you'd write by hand
14:41:23 <shapr> Saizan: Yeah, that's how it decides which channel gets the message.
14:41:24 <kpreid> Saizan: I have occasionally
14:41:26 <dons> the inner loops anyway
14:41:32 <shapr> At least, I think...
14:41:49 <kpreid> Saizan: I assume you mean the "Context in IRC logs" link
14:41:50 <Cale> That's pretty awesome
14:41:57 <Saizan> kpreid: yeah
14:41:59 <dmhouse> ?ask ndm whether he had any feedback on the cat theory article. If you haven't read it, I'd reprint, at least the first section's changed a fair bit.
14:41:59 <lambdabot> Consider it noted.
14:42:10 <Cale> Something to tell joelr about :)
14:42:15 <dons> glguy: very nice
14:42:19 <dons> how long did this take to set up?
14:42:32 <dons> looks like a *perfect* case for HAppS
14:42:38 <Cale> dons: 3 days' spare time :)
14:42:45 <glguy> I did the IRC bot starting at lunch
14:42:47 <glguy> using your tutorial
14:42:56 <dons> Cale: heh
14:42:58 <dons> yes
14:42:59 <glguy> grafted into HAppS with forkIO
14:43:01 <dons> ?seen joelr
14:43:02 <lambdabot> I haven't seen joelr.
14:43:05 <dons> ?seen joelr_
14:43:06 <lambdabot> I haven't seen joelr_.
14:43:09 <dons> ?seen joelr1
14:43:10 <lambdabot> I saw joelr1 leaving #haskell 2h 23m 33s ago, and .
14:43:13 <dons> doh
14:43:26 <Cale> @seen joell
14:43:27 <lambdabot> I haven't seen joell.
14:43:39 <Cale> @seen joell'
14:43:40 <lambdabot> I haven't seen joell'.
14:43:40 <SamB> hey, are you going to put put hpaste on Project Wonderful?
14:43:45 <Cale> hehe
14:43:53 <dons> Cale: so its a nice balance of abstraction and cleverness :) I think the code might appeal to the Cale sensitivities
14:44:00 <SamB> I bet you could, like, get money for that!
14:44:01 <glguy> @echo test
14:44:02 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "glguy!n=eric@unaffiliated/glguy", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo test"]} rest:"test"
14:44:03 <dons> Cale, also , interesting paper on efficient backtracking in haskell at PADL
14:44:22 <dons> i'll find the link. NonDet stuff, where you write a naive search, and get an efficient one by magic
14:44:34 <Cale> cool
14:44:55 <Baughn> Is that similar to how parsec works?
14:44:58 <glguy> project wonderful??
14:45:01 <dons>   * Takeshi Morimoto, Yasunao Takano and Hideya Iwasaki. Instantly Turning a Naive Exhaustive Search
14:45:04 <dons>     into Three Efficient Searches with Pruning
14:45:55 <dons> glguy: so we write our new reddit in happs then?
14:46:00 <dons> is it a day or two's work?
14:46:11 <yitz> Cale, whatsup w/ MonadRandom?
14:46:14 <dons> www.typeit.com or something ;)
14:46:21 <Cale> yitz: what's up with it?
14:46:29 <Cale> yitz: I haven't touched it in a while
14:46:45 <Cale> Baughn: Parsec gets its efficiency by forcing you to keep track of where you might want more than a character of lookahead.
14:46:51 <glguy> dons: sure, if you don't need hardly any features
14:46:52 <Cale> (which usually isn't so bad)
14:46:57 <yitz> Is whats on the wiki current?
14:46:58 <bos> dons: do you use del.icio.us
14:47:06 <Cale> yitz: oh, I'll check. I think it is.
14:47:11 <Cale> @where MonadRandom
14:47:11 <lambdabot> I know nothing about monadrandom.
14:47:27 <Baughn> Cale: I've been having serious problems fitting C into parsec, but maybe that's just my lack of experience showing
14:47:28 <dmhouse> MonadRandom, with all the extra instances, doesn't compile under 6.6
14:47:29 <Cale> yes, it it
14:47:30 <Cale> is*
14:47:31 <SamB> Cale: unfortunately, it also makes it potentially hard for you to say when you have had enough lookahead
14:47:42 <SamB> Baughn: C?
14:47:43 <dmhouse> The coverage condition failed for the MonadState instance, I think.
14:47:46 <bos> Baughn: why?
14:47:46 <SamB> C is crazy!
14:47:51 <Baughn> SamB: For the DS9K compiler. ;)
14:47:52 <SamB> you can't parse C
14:48:00 <Cale> dmhouse: Those aren't my code
14:48:04 <bos> C's not so bad. now C++, that's bad.
14:48:11 <Cale> dmhouse: I don't write automatic lifting instances like that.
14:48:25 <SamB> Baughn: what exactly are you doing with C?
14:48:33 <Baughn> bos: I keep getting exponential-time parsing from it. >_<
14:48:49 <Baughn> SamB: A DS9K compiler, hopefully
14:49:00 <SamB> oh, ds9k is a processor?
14:49:07 <SamB> so a prewritten parser would be ideal?
14:49:15 <Baughn> Mm. Yes.
14:49:32 * glguy dreads moving large parts of his code into IO to get timestamping :(
14:49:35 <yitz> Why Rand and RandomT, not Rand[T] or Random[T]?
14:49:49 <Baughn> glguy: Doesn't ghc's profiling support do it for you?
14:49:54 <Cale> Yeah, for Parsec, you want to factor your grammar a bit so that you don't end up with very large things ending up inside of try.
14:50:15 <bos> lots of aggressive left-factoring of a grammar is no fun.
14:50:32 <SamB> Is there a preexisting C parser?
14:50:38 <dons> glguy: hmm?
14:50:42 <SamB> one that, like, works?
14:50:51 <Cale> yitz: To be honest, I didn't think all that hard about naming.
14:50:52 <dons> can't you grab the timestamp at the start?
14:50:53 <glguy> dons: how do I run an IO ClockTime function in HAppS
14:50:53 <shapr> hiya yitz, I've seen you on the mailing lists. Nice posts!
14:50:55 <dons> or StateT it?
14:51:04 <Cale> yitz: Probably I'd prefer Random and RandomT
14:51:05 <yitz> tnx shapr
14:51:05 <dons> glguy: no idea. check with shapr or #happs I guess
14:51:08 <glguy> dons: at the start of when a paste is created?
14:52:10 <bd_> ?where phooey
14:52:11 <lambdabot> http://conal.net/phooey/
14:52:11 <yitz> Also - MonadRandom should have next and range, not reinvent random*
14:52:33 <bos> Baughn: what dialect of C do you want to support?
14:53:05 <dons> glguy: yeah?
14:53:21 <dons> (I was assuming you don't want to insert IO in the middle of somethin gpure)
14:53:40 <Baughn> bos: C99 would preferable, but C89 will do
14:55:45 <Cale> ah, that's why
14:56:01 <Cale> using the name Random clashes with the H98 random module
14:56:04 <dmhouse> ?ask kowey if he has any preferences for when we should use Image:100%.png. I'd say my cat theory article is pretty much complete; it has had feedback, improvements, is well typeset, includes images and exercises. Of course, it'll never be totally finished, but I still think it's a case for Image:100%.png
14:56:04 <lambdabot> Consider it noted.
14:56:47 <shapr> dmhouse: Hey, did you try the HAppS I installed yesterday? need anything else?
14:57:00 <dmhouse> shapr: haven't tried it yet, actually.
14:57:05 <dmhouse> I'll see if it works.
14:57:17 <shapr> ok
14:57:42 <yitz> dmhouse: I like the cat th. article on wikibooks.
14:58:15 <dmhouse> yitz: yes, I caught your comments on the mailing list, thankyou. :)
14:59:49 <Cale> yitz: I changed it such that the names are Rand/RandT
15:01:37 <yitz> OK tnx. My next idea is a bigger change tho :)
15:01:58 <yitz> dmhouse: How about some commutative diagrams?
15:02:01 <shapr> bitshftr: Are you really irc'ing as root?
15:02:10 <dmhouse> shapr: could I pwetty please have XHtml installed? :)
15:02:17 <shapr> yes!
15:02:21 <dmhouse> (As in Text.XHtml.)
15:02:59 <dmhouse> yitz: where would you include them?
15:03:39 <dmhouse> shapr: I think apart from that, it should build.
15:03:53 <Cale> yitz: I think that's it for the editing for now
15:04:17 <Cale> er, one more :)
15:04:37 <Cale> there we go
15:05:22 <dmhouse> shapr: I have to dash, I'll try building again tomorrow night.
15:05:31 <dmhouse> shapr: thanks once again for your patience.
15:05:56 <shapr> Sure
15:06:01 <dmhouse> G'night.
15:06:07 <shapr> g'nite!
15:08:24 <syntaxfree> this is a masterpiece: http://www.clemenskogler.net/film/grandcontent.htm
15:08:25 <lambdabot> Title: Le Grand Content
15:08:46 <Cale> Unable to connect
15:08:54 <Cale> oh, there we go
15:09:12 <Cale> hmm, quicktime video. I'll scrape out the URL
15:09:15 <syntaxfree> there's a youtube link for le grand content.
15:09:19 <syntaxfree> just a min.
15:10:30 <syntaxfree> http://www.youtube.com/watch?v=lWWKBY7gx_0
15:10:30 <Cale> http://www.clemenskogler.net/film/legrandweb.mov
15:10:56 <syntaxfree> it's really a masterpiece.
15:14:07 <glguy> Excedrin: you there?
15:14:53 <Cale> hehe, it is pretty good
15:16:10 <Cale> http://video.google.ca/videoplay?docid=2670820702819322251&q=Hans+Rosling
15:16:14 <Cale> reminds me of that
15:17:07 <Cale> http://video.google.ca/videoplay?docid=7996617766640098677&q=gapminder.org -- and this is another video about similar things
15:18:35 <tuukkah> hmm, seems i've lost sound in youtube but not in google video
15:19:56 <syntaxfree> ah, I know gapminer.
15:20:05 <syntaxfree> Gapminder is more serious, less emo.
15:20:12 <syntaxfree> www.indexed.blogspot.com
15:20:52 <Cale> right
15:21:04 <Cale> Just the bubbles in graphs thing :)
15:21:09 <shapr> I discovered last night that most people in movie theaters shut off their brain during entertainment, and prefer that. I suspect that's not true here on #haskell
15:21:35 <syntaxfree> indexed.blogspot.com is somewhat like xkcd when it does charts.
15:21:44 <mbishop> shapr: isn't that the point?
15:22:02 <shapr> mbishop: What do you mean?
15:22:30 <mbishop> Most things that are "entertainment" are typically to relax, not to think
15:22:47 <mbishop> I believe there is an einstein quote about how he never did crosswords or puzzles
15:22:57 <mbishop> because he didn't want to think after spending a day researching
15:22:58 <shapr> I find #haskell and research papers entertaining.
15:23:11 <SamB> I don't think my brain has an off switch
15:23:18 <shapr> Me neither
15:23:24 <SamB> I just go right on thinking until I fall asleep, or something
15:23:31 <psnl> what about when you sleep?
15:23:33 <mbishop> I don't think mine does either, but I at least try to get it to go off :P
15:23:38 <shapr> That's one reason I have to exercise, so I can sleep.
15:23:41 <SamB> psnl: think badly?
15:23:46 <shapr> psnl: Nah, I think about stuff when I'm asleep too.
15:24:05 <psnl> shapr: when I dream in haskell I call it a nightmare
15:24:28 <shapr> Sometimes I have great realizations while dreaming.
15:24:35 <Cale> If something doesn't make me think, it's basically not entertaining.
15:24:52 <psnl> Cale: what about just sitting in fornt of the tv with beer?
15:24:59 <Cale> I don't drink
15:25:04 <Cale> and I hardly watch any TV
15:25:19 <Cale> Discovery still has a few good shows, but it's falling apart
15:25:27 * psnl winds down with tv and beer
15:25:48 <sorear> tell fodder
15:25:48 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:25:51 <shapr> I never watch TV, though I do rent movies every once in awhile. I drink rarely.
15:25:53 <sorear> @bot
15:25:53 <lambdabot> :)
15:26:28 <shapr> I think I don't wind down, I think I go from speed to crash.
15:26:41 <sorear> allbery_b: too late :(
15:26:56 <allbery_b> yeh
15:27:03 <sorear> I was trying to see if pre-restart lambdabot was reacting to @tell
15:27:15 <sorear> btw, has anyone had insight?
15:27:25 <allbery_b> hm, this happened before the restart, though, if the timestamp is correct
15:27:25 <Botje> maybe I should buy more ram sometime.
15:27:28 <mbishop> Cale: discovery used to have all the good specials, now it has too many "real" shows
15:27:30 <glguy> Ev st Request (IO Result))
15:27:36 * glguy can't figure out how to use this type
15:27:39 <mbishop> but I think they are fixing that, started pushing all their worthless shows onto TLC
15:27:44 <Cale> mbishop: and crap about ghosts
15:27:45 <sorear> glguy: how's the pastebin coming?
15:27:52 <glguy> !paste
15:27:53 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
15:28:02 <sorear> glguy++ oooh
15:28:10 <sorear> does it announce yet>
15:28:13 <glguy> sorear: still trying to figure out how to do IO inside happs
15:28:16 <Cale> I have a hard time taking seriously any science channel which would promote a show about ghosts.
15:28:20 <glguy> sorear: I don't remember, try it
15:28:31 <mbishop> I like some of the more "fact" filled animal planet shows, and some discovery channel, but mostly I just watch the History channel, scifi, and TNT (for the Xfiles on monday nights)
15:28:31 <glguy> :-p
15:28:34 <sorear> glguy: does queueIO work?
15:28:45 <shapr> Cale: Check out the 'science' section of youtube. I've decided that science and tv are mutually exclusive.
15:29:02 <glguy> sorear: where is that defined?
15:29:12 <shapr> youtube is equally content-less
15:29:18 <sorear> it's a happs function with a misremembered name
15:29:27 <glguy> addSideEffect?
15:29:33 <sorear> i think so
15:29:42 <glguy> but I need to see the result first
15:29:46 <glguy> so I can do a getClockTime
15:29:46 <psnl> shapr: you aren't getting the whole "zone out with tv" thing
15:30:02 <mbishop> the only interesting thing I found on youtube is that video of the "Max Headroom hijacker" who pirated a TV signal over two chicago channels in 1987
15:30:39 <SamB> shapr: what about that bridge that fell down?
15:31:02 <hpaste>  sorear pasted: ping at http://fserv.pikapphi.umr.edu:8000/24
15:31:26 <sorear> replicate 5 " glguy++ "
15:31:34 <Cale> The best thing on YouTube is the comedy series "Look Around You"
15:31:39 <sorear> guess I'll have to unroll that myself ;)
15:31:44 <sorear> glguy++ glguy++ glguy++ glguy++
15:31:53 <sorear> @karma glguy
15:31:53 <lambdabot> glguy has a karma of 29
15:31:59 <sorear> @karma
15:31:59 <lambdabot> You have a karma of 12
15:32:06 <psnl> sorear: your unrolling is bust
15:32:43 <psnl>  replicate 5 " glguy++ " reduces to  glguy++ glguy++ glguy++ glguy++ glguy++
15:32:46 <Cale> shapr: definitely check out that Hans Rosling video though, it's quite cool
15:33:02 <sorear> psnl: I had to compensate for the one in the loop
15:33:07 <sorear> @karma glguy
15:33:07 <lambdabot> glguy has a karma of 35
15:33:17 <sorear> hpaste: @bot
15:33:25 <psnl> sorear: I see
15:33:47 <sorear> glguy: is the code online?
15:33:53 <glguy> sorear: not yet
15:34:04 <glguy> sorear: my nickserv password is in it :0D I need to clean it tonight
15:34:55 <SamB> ???
15:35:13 <sorear> @locatime glguy
15:35:15 <lambdabot> Local time for glguy is Wed Jan 17 17:32:46 2007
15:36:09 <sorear> SamB: !!!
15:36:32 <SamB> sorear: hmm?
15:36:56 <glguy> i also need to figure out how to set up a darcs repository tonight
15:36:58 <glguy> so people can see patches
15:37:06 <sorear> SamB: it == hpaste (is that why '???')
15:37:10 <sorear> glguy: easy
15:37:14 <sorear> glguy: darcs init
15:37:19 <sorear> glguy: darcs add *
15:37:29 <sorear> glguy: darcs record -am "initial"
15:37:31 <sorear> glguy: cd ..
15:37:42 <sorear> glguy: upload `find hpaste`
15:37:46 <SamB> oh, you answered my ??? with !!!... I Get it...
15:37:56 * sorear tries to be too clever
15:38:07 <SamB> anyway, my ??? was: why would you put *your* nickserv password in a bot?
15:38:14 <SamB> wouldn't it have its *own* password?
15:38:40 <sorear> sorear-lambdabot's nickserv has the longest password I use, 16 chars
15:39:03 <sorear> my nickserv: 13  my root: 12  my user: 14
15:39:20 <sorear> pwgen rocks
15:40:14 <sorear> glguy: if I may...  you see http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html recently? :)
15:42:36 <glguy> you winning?
15:42:49 <glguy> oh
15:42:50 <sorear> not yet
15:42:51 <glguy> beat dons!
15:43:23 <shapr> I must talk more!
15:43:51 <shapr> glguy has right at four times my number of lines!
15:44:24 <sorear> I have only half glguy's rank :(
15:44:37 <SamB> I am at least on the list
15:45:12 <shapr> I wonder if we should switch lambdabot back to NOTICE?
15:45:16 <yitz> bye
15:45:23 <SamB> shapr: no!
15:45:26 <shapr> bye yitz
15:45:28 <SamB> not until you fix the IRC clients!
15:46:34 <sorear> oh so lambdabot used to not be broken?
15:47:02 <shapr> Oh yeah, that was the problem. gaim et al couldn't handle NOTICE, right?
15:47:08 <sorear> "violates RFC 2812" == broken in my book
15:47:14 <sorear> nooooooooo.
15:47:20 <sorear> !!!ooooooonnn
15:47:35 <hpaste>  glguy pasted: time stamps saved by not displayed at http://fserv.pikapphi.umr.edu:8000/24#1
15:47:38 <SamB> sorear: everything does that
15:47:47 <SamB> shapr: it looks horrible in x-chat too
15:47:53 <sorear> SamB: everything does what
15:47:53 <SamB> iirc
15:48:04 <SamB> sorear: violates RFC 2812
15:48:39 <sorear> irssi doesn't
15:48:51 <SamB> ... okay.
15:48:56 <tuukkah> "looks horrible" =)
15:49:01 <SamB> heh
15:49:08 <sorear> irssi rewrites the handlers so that /msg in a /msg handler automagically becomes /notice
15:49:33 <sorear> glguy: I can't undestand your paste title.
15:49:40 <SamB> okay, I guess irssi even interprets notice correctly?
15:49:45 <SamB> if it does that...
15:50:00 <glguy> sorear: I think the timestamps are now being recorded
15:50:04 <sorear> interprets correctly ?
15:50:08 <Excedrin> how does lambdabot violate rfc 2812?
15:50:13 <glguy> sorear: and when I get home, I'll add support for displaying paste age
15:50:17 <Philippa> bots aren't supposed to PRIVMSG
15:50:20 <sorear> Excedrin: lambdabot replies to MSG with MSG
15:50:42 <sorear> PRIVMSG must be replied to, if at all, with NOTICE
15:50:50 <sorear> NOTICE must not be replied to
15:50:58 <allbery_b> hrrrm
15:51:01 <SamB> sorear: I am replying to your privmsg with a privmsg!
15:51:02 <sorear> together those rules eliminate bot loops
15:51:06 * allbery_b *likes* the current behavior
15:51:08 <SamB> I am violating rfc 2812!
15:51:10 <sorear> automatically :)
15:51:17 <Philippa> SamB: you mean you're both bots?
15:51:26 <shapr> Excedrin: The idea was to eliminate infinite loops.
15:51:31 <sorear> it's not just bots
15:51:32 <SamB> sorear: so if I get mad do I get to count as violating rfc 2812?
15:51:38 <sorear> any automatic reply
15:51:43 <SamB> Arg!
15:51:44 <sorear> fex. CTCP
15:51:47 <SamB> Arg!
15:51:58 <sorear> CTCP replies are NOTICE ... which is good!
15:52:00 <SamB> Arg!
15:52:24 * SamB wonders how often he has to do that to qualify it as automatic
15:52:31 <allbery_b> I have a tab open to LB, when I type something there I get a response in that tab, in conext --- /NOTICE is not linked to a "session" that way and comes up randomly  as a result
15:52:34 <SamB> Arg!
15:52:43 <Excedrin> shapr: doesn't that mean lambdabot shouldn't reply to notice, not that it shouldn't reply to privmsg with notice?
15:52:45 <SamB> Arg!
15:52:52 <sorear> allbery_b: irssi puts notice in context
15:52:54 <SamB> Arg!
15:53:11 <sorear> SamB: until "ChanServ sets mode: +o ...", I thinj
15:53:23 <SamB> Arg!
15:53:38 <SamB> so if I do that, then I get to say I violate RFC 2812?
15:53:56 <Excedrin> SamB: only if you reply to notices that way
15:54:07 <SamB> Arg!
15:54:18 <SamB> you misunderstand!
15:54:24 <shapr> Excedrin: Yes, lambdabot should not reply to NOTICE, and should only emit NOTICE.
15:54:29 <SamB> Arg!
15:55:05 <SamB> this could take a while...
15:56:36 <Excedrin> there's nothing in the rfc that states that automatic responses must be notice
16:21:25 <sorear> @users
16:21:25 <lambdabot> Maximum users seen in #haskell: 311, currently: 282 (90.7%), active: 41 (14.5%)
16:22:07 <yuesefa> my current ghc 6.6 is compiled with ghc 6.4, will it be better using the current compiler to recompile 6.6?
16:22:29 <sorear> really?
16:22:42 <sorear> how did you compile 6.6 with 6.4
16:22:43 <sorear> ?
16:22:59 <sorear> I'm suprised
16:23:00 <yuesefa> just follow the readme
16:23:05 <Igloo> It should Just Work
16:23:11 <sorear> did you use 'make'?
16:23:25 <yuesefa> gcc and ghc both needed
16:23:33 <sorear> a 6.6-compiled 6.6 is better because it supports ghci
16:23:34 <sorear> BUT
16:23:40 <Igloo> yuesefa: By default you'l already have a (stage 2) compiler built with a (stage 1) GHC 6.6, so it shouldn't make any difference
16:23:48 <sorear> if you just 'make' it will do a 2-stage bootstrap
16:23:58 <sorear> BTW, #ghc exists
16:24:05 <yuesefa> got it, thanks :-)
16:24:11 <Igloo> That question would be off-topic for #ghc, though
16:24:27 <sorear> oh right
16:24:33 <sorear> silly me
16:25:40 <tuukkah> #haskell == #ghc-user-club
16:26:15 <sorear> tuukkah: canonicalize "#hugs-user-club" == ?
16:26:35 <tuukkah> #n/a ?-)
16:26:48 <setuid_w0rk> Is there haskell standard prelude documentation?
16:27:03 <sorear> ?docs Prelude
16:27:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:27:07 <setuid_w0rk> I'm just starting out and I want to get an idea of what the builtin functions are
16:27:13 <setuid_w0rk> ahh, thanks
16:27:30 <sorear> don't expect it to be very helpful, though.
16:28:01 <setuid_w0rk> haha
16:28:06 <sorear> also there are a lot of useful builtin funs that are in modules
16:28:08 <ohmega> i think this is more helpful
16:28:10 <ohmega> http://www.haskell.org/onlinereport/standard-prelude.html
16:28:48 * glguy wonders if EpochTime can be adapted with a built-in to use the TimeDiff functions
16:31:43 <tuukkah> sorear, sorry, i didn't mean to be serious about ghc vs. hugs use, ghc just seems to have a lot more visibility here at the moment
16:32:01 <sorear> I wasn't being serious either
16:32:07 <sorear> is there a special GHC Newbie's Guide, or should I just read the commentary?
16:34:52 <tuukkah> what kind of guide and commentary?
16:35:22 <sorear> categorical error
16:35:39 <sorear> probably a #ghc ontopic one
16:35:50 <sorear> glguy: @recentchanges
16:35:55 * sorear is overeager
16:37:16 <Igloo> You probably want the http://hackage.haskell.org/trac/ghc/wiki/Commentary commentary
16:37:28 <sorear> yes, that was the one I meant
16:37:30 <sorear> ok.
16:38:03 * sorear wants to see {-# MEMOIZE #-} or a reason it can't exist, and isn't afraid to learn the code...
16:42:31 <Philippa> sorear: it can't exist for parameter types that aren't in Eq
16:42:39 <Philippa> (or something equivalent)
16:42:57 <sorear> Philippa: unsafePointerEq.
16:43:15 <sorear> unsafePointerEq -> (==)  (axiom)
16:43:30 <tuukkah> sounds unsafe
16:43:34 <sorear> unsafePointerEq && !(==)   = invalid by Eq law
16:43:48 <sorear> !unsafePointerEq && (==)   = extra computation is never harmful.
16:43:52 <SyntaxNinja> hm. wasn't there a shootout problem that, when literally implemented in Haskell, ended up taking no time because the complex bit was never evaluated?
16:43:59 <shapr> yup
16:44:01 <SyntaxNinja> does anyone have a link to that?
16:44:07 <SyntaxNinja> or a discussion of it?
16:44:13 <shapr> SyntaxNinja: It had to do with memoisation.
16:44:56 <shapr> let x = {- big long computation -} in print $ show [x,x,x,x,x]
16:45:43 <shapr> Or maybe it didn't have show at all, and that caused the big long discussion.
16:45:55 <SyntaxNinja> I think maybe there was no "show"... I can't remember
16:46:02 <SyntaxNinja> shapr: who was involved in the discussion?
16:46:31 <shapr> It was on the new computer language shootout, so probably Isaac Gouy, Brent Fulgham, etc on the shootout list.
16:49:38 <sorear> did they revise the problem?  Laziness *is* a legitimate implementation technique...
16:53:55 <SamB> benchmarks that rely on stupidity in the compiler are stupid
16:59:41 <OliverB> Calculate and print the result of 2+2 while summing the digits of pi to 5 milion places :)
17:05:09 <glguy> !paste -- shameless self-advertising
17:05:10 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
17:06:09 <gregb> ?let â = sqrt in â 2
17:06:09 <lambdabot>  Illegal character ''\136''
17:07:14 <gregb> Does one have to do something special to get GHC or Hugs to understand Unicode in source files?
17:07:26 <bd_> Are there any portable byte-order conversion functions for haskell? Not just ntohl, but host -> big/little endian and back, for types in Data.Int and Data.Word?
17:07:32 <Cale> sorear: yeah, they've had to repeatedly update the problems in order to eliminate wasted work from the requirements, because laziness will kill everything at that.
17:08:13 <sorear> gregb: no
17:08:21 <sorear> gregb: lambdabot doesn't support unicode
17:08:29 <Excedrin> gcc's ability to unroll simple recursive functions is somewhat surprising
17:08:33 <sorear> gregb: further, lambdabot is still using 6.4
17:08:47 <sorear> gregb: 6.6 added unicode-in-sourse
17:08:48 <Excedrin> lambdabot uses 6.5
17:09:01 <sorear> > 6.4 == 6.5
17:09:02 <lambdabot>  False
17:09:04 <sorear> oh.
17:09:24 <allbery_b> IIRC LB is reporting based on what it sees, not what i was compiled with.  I tsees a 6.5 first...
17:09:25 <gregb> sorear: Hmm, I can't get my copy of 6.6 to accept that.
17:10:00 <sorear> gregb: maybe it's being treated as an operator symbol?
17:10:09 <sorear> 2 +- 3 works (with unicode +-)
17:10:14 <sorear> ±
17:10:43 <allbery_b> yeh, I'd guess it neeeds parens around an assumed operator
17:11:16 <gregb> sorear: its complaining about character problems
17:11:53 <gregb> Maybe I need to recompile my 6.6 to get it to understand unicode?
17:11:59 <sorear> nah
17:12:05 <sorear> what character probs?
17:12:15 <sorear> fwiw, you need utf8
17:12:27 <sorear> everything else is obsolete and unsupported
17:12:44 <gregb> <interactive>:1:15: lexical error at character '\136'
17:12:59 <gregb> ...and I'm using utf8.
17:13:15 <sorear> does ± work?
17:13:23 <allbery_b> are you usina non-utf8-aware terminal?  I get stuff like that when I try to paste a unicode sqrt symbol into a terminal.app window
17:13:24 <Igloo> I don't think ghci accepts unicode
17:13:38 <sorear> Igloo: it did for me
17:13:39 <allbery_b> ...readline may not be utf8-aware
17:13:44 <sorear> (linux OTOH...)
17:13:50 <Igloo> Oh, fair enough
17:13:57 <allbery_b> or may need to be kicked with the appropriate LANG=...
17:14:41 <gregb> sorear: Â± doesn't work
17:14:58 <allbery_b> ok, I got it to paste right but nwo get that \136 error
17:15:04 <gregb> allbery_b: the symbols show up fine.
17:15:06 <sorear> gregb: type +- into 'hexdump'
17:15:06 <allbery_b> sounds like something is not UTF8 aware still
17:15:08 <Igloo> Well, it works in a source file but not at the ghci prompt for me
17:15:18 <Igloo> (in a UTF8 terminal)
17:16:11 <Excedrin> e2 88 9a is utf8 sqrt, right?
17:16:29 <sorear> utf string yes
17:17:06 <Excedrin> I put 'â = sqrt' in a file and ghci fails to load it
17:17:13 <bd_> ?where newbinary
17:17:14 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
17:17:25 <sorear> how about (?) = sqrt ?
17:17:51 <Excedrin> oic of course
17:17:52 <Excedrin> that works fine
17:17:55 <TSC> (â) = sqrt works for me too
17:18:02 <TSC> But I can't use it at the ghci prompt (:
17:18:17 <Excedrin> same
17:18:38 <sorear> ?expand oic
17:18:38 <lambdabot> Unknown command, try @list
17:18:47 <allbery_b> "oh, I see"
17:18:48 <Excedrin> oh, I see
17:19:04 <sorear> doh :)
17:20:19 <gregb> Ah, (â) works here as well.
17:20:43 <emu> what's the motivation behind making Setup.lhs instead of Setup.hs?
17:20:54 <Cale> @where binary
17:20:55 <lambdabot> http://darcs.haskell.org/binary
17:20:58 <mbishop> ?
17:21:04 <emu> especially when its usually a 2-liner
17:21:54 <sorear> emu: #! /usr/bin/runhaskell
17:22:16 <sorear> Haskell 98 can only parse that in a .lhs.
17:22:20 <SamB> yeah
17:22:27 <SamB> the shabang line is the whole motivation
17:22:28 <emu> ah. i always do runghc
17:23:18 <SamB> does âx work then?
17:23:42 <SamB> personally I think that is a stupid codepoint
17:23:58 <Cale> why?
17:23:59 <SamB> because no amount of unicode will let you make a real sqrt symbol
17:24:33 <Cale> the overline is actually just an older way of parenthesizing expressions
17:25:19 <mbishop> Hey who wants to join my fraternity? ??? :P
17:25:22 <Cale> actually, code points for common text decorations would be nice
17:25:47 <Cale> (overline, underline, strikethrough, etc.)
17:25:48 <gregb> SamB: I have to use (â) x
17:26:15 <gregb> I just learned you could have one argument infix operators.
17:31:10 <SamB> Cale: maybe
17:31:26 <SamB> but that seems outside the scope of unicode
17:32:38 <koala_man> unicode already has composing accents and such
17:36:20 <sorear> I'd like to see a MathML-based syntax for Haskell.
17:36:26 <sorear> (is it called Epigram?)
17:36:38 <koala_man> sÌ¶tÌ¶rÌ¶iÌ¶kÌ¶eÌ¶
17:36:59 <sorear> 17:34 < koala_man> s?t?r?i?k?e?
17:37:07 <allbery_b> it worked here
17:37:13 <augustss> and here
17:37:18 <emu> mathML is a disaster
17:37:27 <sorear> emu: oh well.
17:37:31 <allbery_b> and there should be a composing overbar accent in unicode, but getting GHC to accept that as parentheses strikes me as not worth the effort
17:38:03 <koala_man> â4Ì2Ì haha well almost
17:38:04 <Cale> emu: I agree
17:38:22 * sorear has never used it
17:38:34 <sorear> it sounded good when I heard the pitch, however ...
17:38:44 <emu> just like all "XML technologies"
17:38:46 <Cale> I think that things like overline and underline shouldn't compose with individual characters, but enclose blocks of text.
17:38:56 * sorear agrees
17:40:10 <Excedrin> is math notation that much nicer to read than typical ascii code?
17:40:15 <SamB> no *duh*
17:40:35 <SamB> Excedrin: well, when you are trying to read math: hell yes!
17:41:36 <gregb> ?let (â) = sqrt in (â) 2
17:41:37 <lambdabot>  Illegal character ''\136''
17:41:41 <Excedrin> I don't read math, so I have no idea. Whenever I see a sigma I think "ok, this is like sum [some_list_comprehension]"
17:43:21 <SamB> Excedrin: yes!
17:43:56 <SamB> but sometimes it is more like just plain sum
17:44:19 <SamB> at least, when I use it
17:44:56 <orbitz> SamB: did you jsut touch my butt?
17:45:00 <OliverB> Heh, me too (read math) - I usually end up trawling google to figure out what the funny symbol like a rotated T means.
17:45:11 <SamB> orbitz: what?
17:45:18 <orbitz> SamB: was that you?
17:45:33 <SamB> orbitz: if someone touched your butt, it was not me
17:45:42 <SamB> I will randomly blame it on your dog
17:46:16 <orbitz> i don't have a dog
17:46:28 <SamB> orbitz: that just makes it more random ;-)
17:46:40 <SamB> OliverB: well, I don't know what that means either!
17:47:05 * sorear points out that ASCII characters can't touch anything
17:47:33 <SamB> that ... is a strange thing to point out...
17:47:35 <allbery_b> they can touch bits.  now, maybe they're *private* bits...
17:47:44 <SamB> especially since sometimes they *can* touch eachother!
17:47:48 <SamB> depending on the font
17:48:14 <gregb> map' :: (Î± -> Î²) -> [Î±] -> [Î²]
17:48:25 <gregb> works, but ghci can't print it out with :t
17:48:26 <sorear> heh.
17:48:35 <SamB> what does ghci do?
17:48:55 <sorear> why can't you just use US-ASCII like a normal person? :)
17:48:57 <allbery_b> huh.  I'd've expected it to obey lowercase vs. uppercase, if nothing else
17:49:14 <SamB> allbery_b: aren't those lowercase?
17:49:26 <SamB> they look lowercase to me!
17:49:34 <allbery_b> hm, nemmind
17:49:37 <allbery_b> type vs. tycon
17:49:49 * allbery_b is slightly dizzy and not altogether there
17:49:56 <gregb> SamB: prints out a little empty "I can't understand this character" box
17:49:57 <allbery_b> er, tyvar vs. tycon
17:50:01 <SamB> oh.
17:50:12 <SamB> I think it should rename them to something it can say ;-)
18:05:32 <shapr> I read about a cheating bittorrent client recently, I'd guess that it misreports the amount it has uploaded for a given torrent.
18:05:50 <shapr> The solution to that is to instead take that clients total uploads as the combined uploads its peers report.
18:06:14 <shapr> I should probably just put that into my blog since it's off-topic...
18:33:57 <chessguy> is there a version of GHC that will run on a 64-bit machine? i don't care if it actually makes use of the 64-bit architecture, i just want it to run
18:34:18 <sjanssen> ghc runs on AMD64
18:34:33 <chessguy> sweet
18:34:44 * allbery_b sees an x86_64 linux binary on the download page
18:34:51 <sjanssen> http://www.haskell.org/ghc/download_ghc_66.html#x86_64linux
18:35:02 <sjanssen> allbery_b++ beat me
18:35:35 <chessguy> yeah, but he didn't have a link :)
18:35:40 <sorear> last I heard you can run 32-bit binaries on AMD64 (you need 32 bit libs of course)
18:35:50 <allbery_b> can't cut&paste to this window
18:35:59 <sjanssen> but surely the 64-bit build is better
18:36:00 <allbery_b> (and thr browser's a pita over vnc)
18:36:33 <sorear> of course you can't cut.  you don't have write access to d.h.o :)
18:37:25 * allbery_b sighs --- aqua-native vnc client does cut&paste but gets keyboard wrong; X11-based ones get keyboard right but can't deal with cut&paste to/from carbon/cocoa apps
18:37:34 <allbery_b> (or even to each other for some reason)
18:38:26 * mgsloan doesn't understood Steve Yegge's bit on static typing = hardware construction
18:41:15 <chessguy> wow, i don't even have gcc on this system. how nice
18:41:25 <gravity> mgsloan: I think he's thinking about how it maps to hardware, with things like int versus long in C.
18:41:25 <araujo> hi hi
18:41:40 <sjanssen> chessguy: you can hardly call it a "system" if it doesn't have gcc :P
18:41:55 <chessguy> indeed
18:41:56 <mgsloan> ah, well, you can have perfectly statically typed languages which do not have those hard mappings
18:42:05 <gravity> True
18:42:07 <chessguy> that just moved to the top of my priority list
18:42:14 <gravity> And he's aware of haskell, so I found it a little weird
18:42:20 <mgsloan> yeah
18:42:21 <sjanssen> @src Integer
18:42:22 <lambdabot> data Integer = S# Int#
18:42:22 <lambdabot>              | J# Int# ByteArray#
18:42:32 <mgsloan> ooh, interesting
18:42:46 <chessguy> what the heck is that?
18:42:57 <sjanssen> chessguy: ghc's defn. of the Integer type
18:43:13 <chessguy> yeah but what's S# Int#
18:43:24 <mgsloan> kinds, i think.  prim ones
18:43:31 <sjanssen> it either fits into a single machine Int (S#), or it's an array holding a GMP int (J#)
18:43:32 <mgsloan> or maybe just part of the ident
18:44:04 <sjanssen> and # is ghc's convention for unboxed things and other primitives
18:45:44 <chessguy> heh. i have perl but not gcc
18:46:22 <mgsloan> It's kinda relevant though.  I've been thinking about a static type system which allows hard, binary specification, while at the higher level escaping representational stuff
18:49:54 <mgsloan> Eg, every datatype which instances Num would be a representation, and you just mess with nums with constraints
18:51:15 <SyntaxNinja> dons: y0
18:51:43 <mgsloan> Those constraints, and performance considerations would equal a compile time choice to hardcode a type or to do a runtime choice and pick one (eg, if a particular representation has a really fast sort algorithm for a certain size n)
18:51:49 <sorear> SyntaxNinja: dons is asleep
18:51:52 <sorear> @localtime dcoutts
18:52:05 <sorear> dons is in dcoutts' zone attending POPL
18:52:07 <sorear> @localtime dcoutts_
18:52:09 <lambdabot> Local time for dcoutts_ is Thu Jan 18 02:49:38
18:52:36 <sorear> can we help?
18:53:55 <SyntaxNinja> sorear: just wondering if Don got a chance to look at the changes to the report that Iavor and I made.
18:54:30 <nostrademons> mgsloan: Yegge's considering hardware to be "anything that is fully deterministic"
18:54:44 <sorear> oh.
18:55:35 <mgsloan> so basically, he's arguing we should go for dynamic language, because they're less predictable?
18:55:44 <mgsloan> ok then...
18:55:49 * mgsloan backs away slowly :P
18:56:18 <allbery_b> if that was the thing that was being quoted earlier today, it did kinda sound like "haskell sucks because it's not perl"
18:56:25 * allbery_b rolls his eyes
18:56:53 <nostrademons> yeah, I think that was his basic point...
18:57:01 <nostrademons> he wants software to support emergent consciousness
18:57:12 <nostrademons> i.e. do stuff you don't expect
18:57:44 <allbery_b> funny, where I come from that's called a bug
18:58:13 <nostrademons> heh.  In Yegge's World, software programs YOU
18:58:19 <nostrademons> I think he basically wants SkyNet
18:58:30 <nostrademons> after all, that's the other famous software program that never reboots...
18:58:32 <allbery_b> (or, oddly enough, hardware failure --- cf. single bit errors in RAM)
18:58:45 <SyntaxNinja> ar ewe talking about this article: http://steve-yegge.blogspot.com/2007/01/pinocchio-problem.html
18:58:54 <nostrademons> yeah
18:58:56 <mgsloan> yep
18:58:57 <allbery_b> that's the one, yeh
18:59:12 <SyntaxNinja> I couldn't get through the whole thing, I'm afraid.  I was just writing a related rant, though.
18:59:40 <nostrademons> I read it all, but damn, he seems to be descending into kookdom...
18:59:56 <nostrademons> he's following in Richard Gabriel's footsteps...
19:00:07 <SyntaxNinja> is yegge a bit uninformed about Haskell, or did I misunderstand his claims about mutable variables and dynamic code loading?
19:00:26 <nostrademons> he's not completely-fully-up-to-date, but he does know *something* about it
19:00:46 <chessguy> oh that's a lovely error
19:00:53 <chessguy> [('file /usr/include/sepol/policydb/avrule_block.h from install of libsepol-1.15.1-1.fc5 conflicts with file from package libsepol-1.11.18-2', (7, '/usr/include/sepol/policydb/avrule_block.h', 0L)), ('file /usr/include/sepol/policydb/avtab.h from install of libsepol-1.15.1-1.fc5 conflicts with file from package libsepol-1.11.18-2', (7, '/usr/include/sepol/policydb/avtab.h', 0L)), ('file /usr/include/sepol/policydb/conditional.h from 
19:01:08 <nostrademons> nowhere near as bad as STL...
19:01:09 <chessguy> whoah
19:01:34 <nostrademons> I once had a coworker send out an STL error that was 4K long...
19:01:47 <nostrademons> like 2 pages printed
19:02:00 <SyntaxNinja> chessguy: that's an error from RPM, not Haskell, irght? :)
19:02:08 <chessguy> yes
19:02:11 <sorear> I've seen 200 line Haskell error messages
19:02:25 <sorear> GHC likes to print a *lot* of context sometimes
19:02:49 <sorear> it wasn't quite the entire source file, but it was close
19:02:56 <allbery_b> yes, but STL errors regularly produce copious vomit
19:03:02 <mgsloan> yeah, i read the whole thing, but only agreed with it up till the role of type systems bit, which is halfway through
19:03:08 * sorear has never used STL
19:03:19 <mgsloan> maybe more like 3/4 through
19:03:44 <mgsloan> i use STL, but usually only Vector and such, so it doesn't bug me, i don't bug it
19:04:10 <SyntaxNinja> mgsloan has a truce with C++
19:04:56 <mgsloan> well, we have little tifts occasionally
19:05:18 <mgsloan> but mostly an antagonistic sort of cooperation
19:05:19 <nostrademons> I kinda like C++, actually
19:05:42 <nostrademons> certain things about it are a horrible mess, but at least it's a horrible mess by design
19:05:51 <chessguy> ok, let's see if i can update JUST gcc
19:05:53 <mgsloan> my main annoyance is function defs
19:06:01 <nostrademons> unlike Java, which is a horrible mess because it got way too popular too fast and now nobody will let Sun fix it
19:06:25 <mgsloan> they tend to get quite messy, especially once you start optimizing
19:06:49 <nostrademons> function defs meaning just normal member functions?
19:06:53 <nostrademons> or function pointers?
19:07:01 <nostrademons> or pointers to member functions? (ick)
19:07:09 * SyntaxNinja likes C++, but don't tell the irc logs
19:07:14 <nostrademons> hah
19:07:50 <sorear> just don't confess to liking lowercase java :)
19:08:24 <SyntaxNinja> OK, I drafted my Haskell blog rant, but I'm not going to post it on my blog until after the cool-off period.  Feel free to comment, though: http://www.syntaxpolice.org/tmp/someHaskellMyths.html
19:08:47 <sorear> "cool-off period" ?
19:08:49 <SyntaxNinja> I was sorta set off by the pinnochio-rant
19:08:56 <mgsloan> nostrademons: yeah, pointers are pretty bad, but i don't do that much
19:09:07 <SyntaxNinja> sorear: well, ya know... ya don't want to be too hasty posting those rants.
19:09:42 <sorear> SyntaxNinja: ich - you have unescaped do a <- ... lots of stuff that elinks thinks is in a tag ...
19:10:24 * sorear tries again to find the elinks loose-contructionist optionm
19:10:53 <Eelis> SyntaxNinja: your "debunking" of the first two myths boil down to: "i, an experienced bla bla programmer, don't think so". it's not going to convince anybody or "set the record straight"
19:11:05 <nostrademons> SyntaxNinja: sequence and map are both beyond the ken of ordinary industrial programmers...
19:11:49 <SyntaxNinja> sorear: yeah, it's not real HTML
19:12:06 <mgsloan> nostrademons: well, const causes tons of problems - i've seen funcs where its used in almost every place it can be used, which is like 5.  Then there are references, and consts, and pointers, all mixed into a big incoherent def :P
19:12:18 <sorear> ah, atleast unlike shapr you use readable plaintext...
19:13:07 <sorear> and you call yourself a Haskell expert!  @pl can write a shorter cat! :)
19:13:19 <nostrademons> mgsloan: agreed.  I went through a gung-ho const correctness phase too.  think of it as writing Haskell in C++ ;-)
19:13:20 <SyntaxNinja> Eelis: yeah, you're kinda right... I guess I feel like there's so much blah-blah about Haskell that goes the other way, at least someone should occasionally _say_ that it's not true, even though I don't explain it.
19:13:34 <Eelis> SyntaxNinja: and the myth "Haskell isn't being used in industry" is pretty much a straw man. the correct myth to address would be: "Haskell is _hardly_ used in the industry.". in addressing it you won't get away with pointing at one single company
19:14:05 <sorear> 'main = getArgs >>= mapM readFile >>= putStr . concat'
19:14:13 <sorear> @pl getArgs >>= mapM readFile >>= putStr . concat
19:14:13 <lambdabot> getArgs >>= mapM readFile >>= putStr . join
19:14:46 <SyntaxNinja> Eelis: depends on why people say that... if they say it meaning "I can't get a job programming Haskell" then they're wrong. if they say it to mean that Haskell is not widely deployed, then they're right.
19:15:02 <SyntaxNinja> sorear: yeah, I think I wrote that version somewhere too, but I wasn't going to post that ;)
19:15:12 <sorear> Can *I* (0-line resume) get a job using Haskell ?
19:15:28 <sorear> (temporarily ignore the fact that I'm below the child labor age)
19:15:28 <mgsloan> the syntax errors are also pretty horrible - I'm getting "error: declaration of âoperator*=â as non-function" on "Matrix &operator*=(Scale const &other);"
19:16:47 <mgsloan> I think It might have something to do with it not picking up on the Scale definitions, for some unknown reason.  Its header is included.
19:17:22 <mgsloan> operator overloading in C++ is also a complete mess
19:17:23 <sorear> SyntaxNinja: in case you missed the bugfix, your cat adds an extra newline.  <cynic> this will come back to haunt you.
19:18:36 <Eelis> mgsloan: i like it that in C++ i can overload operator+ for things like (linear algebra) vector addition and string concatenation without being forced into a Num type class straightjacket
19:18:37 <SyntaxNinja> OK you guys are right. my rant is lame, I won't post it ;)
19:18:41 <nostrademons> sorear: there's also "main = getArgs >>= mapM (\s -> readFile s >>= putStrLn)"
19:18:42 * SyntaxNinja goes to eat &
19:18:58 <mgsloan> yeah, i'm just out of the child labour age.  Probably gonna do a MS internship...
19:19:10 <mgsloan> Eelis - definitely agree on that
19:19:15 <nostrademons> MS = MicroSoft?
19:19:19 <mgsloan> aye
19:19:24 <nostrademons> expect to do a lot of testing
19:19:39 <mgsloan> yeah
19:19:41 <nostrademons> a friend of mine just got a job (full-time) there, he says basically all they do is testing
19:20:02 <mgsloan> yep.  I know a guy who's job there is essentially testing
19:20:20 <mgsloan> apparently for every tiny feature, there is a test guy, an impl guy, and a manager guy
19:20:31 <nostrademons> yup
19:20:45 <mgsloan> Sounds like a horrid system
19:20:57 <nostrademons> that was my feeling too, but he seems to like it
19:21:05 <nostrademons> maybe it's just because it's Microsoft
19:21:18 <nostrademons> then again, he's a Mac guy.  I wonder why the hell he ended up in Redmond...
19:22:20 <nostrademons> @pl \s -> readFile s >>= putStrLn
19:22:20 <lambdabot> (putStrLn =<<) . readFile
19:22:42 <shapr> sorear: Wha? readable plaintext?
19:23:14 <sorear> elinks '\'
19:23:23 * sorear goes to refresh memory
19:23:56 <shapr> sorear: I don't use readable plaintext where?
19:26:15 <sorear> s/shapr/ndm
19:26:58 <shapr> oh
19:29:29 <mgsloan> might like it because you can appear productive while mostly doing brainless stuff
19:30:00 <mgsloan> I'm still going to try hard for an internship though, money, etc, maybe its not all that bad
19:30:19 <sorear> too bad elinks doesn't have a wrap-text option
19:31:13 <shapr> Where's the Haskell vs Python article?
19:31:31 <mgsloan> isn't that fairly incomperable?
19:32:09 <shapr> SyntaxNinja refers to such an article in his anti-rant rant.
19:33:20 <shapr> But that link is empty, and I want to find and read the article.
19:33:59 <nostrademons> I kinda want to read it too
19:34:01 * nostrademons likes both
19:35:37 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:35:37 <mgsloan> sounds interesting, but seems like it'd mostly be static vs dynamic
19:36:07 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:10 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:12 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:13 <shapr> aiee
19:36:14 <allbery_b> erm
19:36:14 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:27 <shapr> hmm
19:36:30 <shapr> !paste
19:36:30 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:33 <sorear> every time I /msg hpaste !paste, it replies in channel!
19:36:37 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:36:41 <shapr> aha
19:36:45 <shapr> I was just trying that.
19:36:55 <sorear> fpp !hpaste
19:37:05 <sorear> ?msg hpaste !paste
19:37:07 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:37:09 <sorear> fpp !paste
19:37:12 <shapr> well, now we know.
19:37:31 <shapr> I think that pastebin is really cool.
19:37:32 <mgsloan> ah, i think my C++ bug might be cyclic .h inclusion... somehow i figured that double-inclusion blocks fixed that
19:37:39 <shapr> glguy wrote it in three days of spare time.
19:37:55 <nostrademons> #pragma once ;-)
19:38:10 <sorear> shapr took how long to write most of hpaste ?
19:38:28 <sorear> reusability is great\
19:38:37 <shapr> You mean how long to write HAppS?
19:38:44 <mgsloan> nostrademons: hah, if the compiler supports it
19:39:11 <sorear> yes
19:39:14 <allbery_b> on the one hand, I kinda think #pragma sucks.  on the other, well, it'd be nice if cpp did #require
19:39:15 <shapr> musasabi, alexj, and Lemmih get credit for HAppS. I'm really the newbie.
19:39:38 <sorear> oh
19:39:58 <shapr> I do lots of advertising though ;-)
19:40:05 <sorear> {-# STANDARDISED_PRAGMAS_ARE_NICE #-}
19:40:34 <mgsloan> yah.  GCC deprecated #pragma once, though
19:41:14 <allbery_b> eventually they realized there are valid uses for it that can't be served by e.g. __attribute__
19:41:37 * cjeris wails and tears his hear
19:41:41 <allbery_b> (but they're right that there are pragmas that really ought to be done in other ways)
19:41:47 <cjeris> s/hear/hair/
19:42:18 * allbery_b hands cjeris some sackcloth
19:42:24 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:42:41 * sorear is still reverse engineering hpaste
19:42:51 <cjeris> sorry.  my register allocator is forcing me to pass half-bricks
19:43:06 <SyntaxNinja> mgsloan: why do an MS internship? maybe you could intern at galois?
19:43:33 <master_baiter> i'd love to intern at MS
19:43:58 <shapr> sorear: glguy claims he'll release the code soon.
19:44:10 <SyntaxNinja> shapr: http://wiki.python.org/moin/PythonVsHaskell
19:44:25 <mgsloan> SyntaxNinja: I'm very close to MS
19:44:29 <mgsloan> geographically
19:44:43 <SyntaxNinja> mgsloan: which MS?
19:44:47 <mgsloan> redmond
19:45:01 <SyntaxNinja> mgsloan: Galois is in Portland, which isn't too far.
19:45:30 <SyntaxNinja> shapr: the pythonvshaskell article isn't bad.
19:45:31 <mgsloan> hah.  200 miles away
19:45:43 <SyntaxNinja> 200 short miles :) You can drive it in a few hours, there's even a train.
19:45:47 <sorear> I want to see glguy's bikeshed while it is still unpainted.
19:45:47 <SyntaxNinja> well, from seattle, anyway
19:45:57 <SyntaxNinja> mgsloan: plus for interns, we give you housing.
19:46:31 <mgsloan> cool
19:47:53 <mgsloan> Seems rather unlikely though - I've only used haskell for about 3 months
19:48:49 <SyntaxNinja> mgsloan: "Always with you what cannot be done"
19:48:57 <sorear> me only <6 months
19:49:07 <mgsloan> yeah, maybe <6 is more accurate :P
19:49:15 <SyntaxNinja> I actually really want someone right now who knows PHP really well, likes web programming, and knows Haskell OK.
19:49:20 <mgsloan> I've said 3 months for about 3 months :P
19:49:27 <sorear> PHP!?
19:49:32 <mgsloan> ah, well that doesn't match me at all :P
19:49:49 <mgsloan> I'm mainly into API and language development
19:49:57 <SyntaxNinja> sorear: you gotta roll with the punches
19:52:15 <nostrademons> SyntaxNinja: I know PHP fairly well (enough to have written a 100k users web application in it), like web programming when it's not in PHP or Java, and know Haskell
19:54:03 * mgsloan looks at site - FPGA stuff would be fun.  Too bad I have no experience actually messing with em
19:59:07 <mgsloan> yep, pretty sure my parents wouldn't agree to it either (still in highschool, etc)
20:00:04 <SyntaxNinja> mgsloan: if I were your parents, I wouldn't let you work for bill gates ;)
20:00:14 <SyntaxNinja> nostrademons: check your msgs
20:00:39 <nostrademons> I got the first one, about sending you a resume if interested...
20:00:50 <nostrademons> I'm on Gaim, which sometimes behaves oddly with IRC
20:01:05 <nostrademons> you get my reply at all?
20:01:15 <mgsloan> lol, yeah, i plan to finagle my way into doing fun, but not useful stuff, for pay
20:01:17 <SyntaxNinja> hm. no. are you identified w/ nickserv?
20:01:39 <SyntaxNinja> nostrademons: I'm using gaim too. always works for me.
20:01:46 <nostrademons> hmm.  probably not
20:02:02 <SyntaxNinja> nostrademons: OK. well, you can hear me, but I can't hear you, then, unless you identify w/ nickserv ;)
20:02:11 <nostrademons> how do I do that with Gaim?
20:02:21 <allbery_b> /msg nickserv help
20:03:09 <allbery_b> (gaim will require you to send a message to nickserv somehow.  dunno if it has support for automatically identifying on connect)
20:03:17 <dancor> how do i poplate l :: [Int] with infinite values generated by f :: IO (Int)
20:03:32 <dancor> s/pl/pul
20:03:39 <nostrademons> cool, thanks allbery_b
20:04:03 <SyntaxNinja> dancor: l <- f ()
20:04:20 <nostrademons> dancor: maybe try sequence . replicate?
20:04:25 <SyntaxNinja> oh, sorry
20:04:27 <SyntaxNinja> heh
20:05:04 <mgsloan> :src replicate
20:05:10 <mgsloan> ?src replicate
20:05:10 <lambdabot> replicate n x = take n (repeat x)
20:05:29 <nostrademons> nope, meant repeat
20:05:35 <mgsloan> yeah
20:05:36 <nostrademons> ?src repeat
20:05:37 <lambdabot> repeat x = xs where xs = x : xs
20:05:39 <dancor> ah sweet
20:06:08 <allbery_b> f >>= (return . repeat) -- ?
20:06:36 <allbery_b> @redo f >>= return . repeat
20:06:37 <lambdabot> do { a <- f; return a} . repeat
20:06:44 <allbery_b> hm, yep, needs parens
20:06:49 <allbery_b> @redo f >>= (return . repeat)
20:06:49 <lambdabot> do { a <- f; (return . repeat) a}
20:07:08 <allbery_b> @. unpl redo f >>= (return . repeat)
20:07:09 <lambdabot> do { a <- f; (return (repeat a))}
20:07:34 <mgsloan> hmm, I thought that . had higher prec than >>=
20:07:38 <dancor> :t sequence $ repeat random
20:07:40 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [(a, g)]
20:07:45 <dancor> :t sequence $ repeat randomIO
20:07:46 <mgsloan> makes sense that it'd be more useful, anyway
20:07:47 <lambdabot> forall a. (Random a) => IO [a]
20:08:26 <nostrademons> the precedence of >>= vs. . vs. $ always confuses me...
20:08:31 <nostrademons> it never seems to DWIM
20:09:14 <dancor> > take 2 $ sequence $ repeat $ randomRIO (4, 7)
20:09:15 <lambdabot>  Couldn't match `[]' against `IO'
20:09:18 <mgsloan> yeah, $ can foul you up sometimes. I thought I had . down though
20:09:45 <dancor> > take 2 $ repeat $ randomRIO (4, 7)
20:09:46 <lambdabot>  Add a type signature
20:09:50 <allbery_b> ghci says (>>=) is infixl1, (.) is infixl 9
20:09:52 <dancor> > take 2 $ repeat $ randomRIO (4 :: Int, 7)
20:09:54 <lambdabot>  [<IO Int>,<IO Int>]
20:09:56 <allbery_b> er, infixr 9
20:10:03 <dancor> > take 2 $ sequence $ repeat $ randomRIO (4 :: Int, 7)
20:10:03 <lambdabot>  Couldn't match `[]' against `IO'
20:10:17 <mgsloan> yeah, so it should be fine
20:10:24 <dancor> > sequence $ replicate 2 $ randomRIO (4 :: Int, 7)
20:10:26 <lambdabot>  <IO [Int]>
20:11:33 <mgsloan> > fmap (head) $ sequence $ repeat $ randomRIO (4 :: Int, 7)
20:11:35 <lambdabot>  <IO Int>
20:12:15 <mgsloan> > mapM_ (+1) $ sequence $ repeat $ randomRIO (4 :: Int, 7)
20:12:16 <lambdabot>  Couldn't match `[]' against `IO'
20:12:26 <mgsloan> :t mapM_
20:12:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
20:12:52 <mgsloan> ah, yeah
20:24:32 <glguy> anyone have a good place for me to post my source?
20:24:32 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:24:55 <SyntaxNinja> @paste
20:24:56 <lambdabot> http://paste.lisp.org/new/haskell
20:25:36 <glguy> i mean tar
20:25:37 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
20:25:52 <glguy> ok, I'll just paste it on my paste bin
20:25:53 <sorear> tell fodder
20:26:08 <glguy> my sshd isn't "hidden"
20:26:10 <glguy> 22 is blocked
20:26:14 <glguy> so I have to move it to an open port
20:26:18 <glguy> that my work doesn't block
20:26:23 <sorear> joy
20:27:28 <hpaste>  hpaste source pasted: Main.hs at http://fserv.pikapphi.umr.edu:8000/25
20:27:55 <hpaste>  glguy pasted: PasteBot.hs at http://fserv.pikapphi.umr.edu:8000/25#1
20:28:21 <hpaste>  glguy pasted: PasteState.hs at http://fserv.pikapphi.umr.edu:8000/25#2
20:28:44 <glguy> I wasn't trying to "hold out" on anyone
20:28:53 <nostrademons> hah.  pastebin source on pastebin
20:29:09 * sorear goes and copies it into a darcs repo
20:29:32 <sorear> on second thought that's a worthless idea
20:30:18 <nostrademons> I wonder if anyone's done pastebin-darcs...
20:30:24 <nostrademons> turn your annotations into patches?
20:30:43 <glguy> I haven't used darcs... so I don't know
20:30:55 <nostrademons> I haven't either, it just seems like a natural thing to do...
20:30:59 <glguy> I've only used it to get dev sources, but I always just paste the command from the HTML
20:31:11 <nostrademons> actually, the Darcs patch algebras look a lot like the research on collaborative editing systems
20:31:13 <glguy> and I don't have a good place to put the repo...
20:31:35 <glguy> unless it runs its own HTTPd
20:32:32 <sorear> I have an ISP's server
20:33:05 <SyntaxNinja> nostrademons: what research do you mean?
20:33:19 <hpaste>  glguy pasted: license at http://fserv.pikapphi.umr.edu:8000/25#3
20:34:39 <nostrademons> SyntaxNinja: things like operational transformations, the GOTO algorithm, SubEthaEdit, etc...
20:34:55 <nostrademons> there was a whole lot done on that in the late 90s, IIRC
20:35:32 <nostrademons> it basically consisted of figuring out which edits could commute and then finding inverses for primitive editing operations
20:35:38 <nostrademons> much like the Darcs patch algebras
20:35:47 <nostrademons> (from what little I've read of the Darcs patch algebras...)
20:37:34 <dancor> how good are haskell threads
20:37:42 <sorear> very
20:37:49 <sorear> easy to use, at least
20:37:52 <dancor> if they are all userspace, does io like block the whole process
20:37:55 <sorear> no
20:38:01 <glguy> sorear: See, I show you the source and you realize its nothing and move on :-p
20:38:43 <sorear> glguy: I don't want your source per se.  I want a good pastebin and am willing to offer patches for the cause.
20:39:01 <sorear> and it's rather hard to make patches when you don't have the source
20:39:07 <glguy> so true
20:39:13 <glguy> so why were you port scanning my machine?
20:39:21 <glguy> looking for darcs repo?
20:39:26 <sorear> trying to find a student web server
20:39:38 <sorear> yes probably
20:39:41 <glguy> student webserver?
20:39:43 <sorear> not thinking too much
20:40:13 <glguy> that's jus a computer a left at my university after I graduated
20:41:08 <dancor> sorear: so is the only real problem when you use foreign procedures
20:41:27 <sorear> dancor: it depends
20:41:40 <sorear> dancor: by default foreign procedures are run in new OS threads
20:42:01 <sorear> dancor: of course this is expensive, so there is a special unsafe option
20:43:37 <sorear> @where HaXml
20:43:38 <lambdabot> http://haskell.org/HaXml
20:46:14 <glguy> !quit
20:49:10 <sorear> wow ... haxml is very far from -W clean ...
20:49:51 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
20:50:23 <glguy> I made a change to the wrong copy
20:50:28 <glguy> so i have to restart, yet again :)
20:51:06 <glguy> ok, now we have timestamps
20:51:55 <glguy> ok, so how to I push my darcs patch out?
20:52:26 <sorear> is the change recorded
20:52:27 <sorear> ?
20:52:31 <sorear> darcs whatsnew
20:52:54 <glguy> OH, my copy is DOS format
20:53:00 <glguy> I need to convert to UNIX
20:53:04 <glguy> all the lines are new :)
20:53:12 <sorear> heh.
20:53:42 <sorear> 4113 lines of warnings from HaXml build
20:54:00 <sorear> so, darcs record to create the patch, then darcs send to send it
20:54:12 <glguy> what is the vim :set for changing the filetype to save as (unix vs dos)
20:54:21 <sorear> :set ff=unix
20:54:23 <glguy> fileformat?
20:54:33 <sorear> you may need to pass an option to darcs send - by default it will go to emertens@gmail.com
20:54:43 <glguy> that's my default email
20:54:59 <glguy> you mean if I want it to go to the repository
20:55:00 <sorear> yes, but I won't apply patches you send there :)
20:56:25 * sorear is now compiling HAppS...
20:56:41 <glguy> so what argument do I add
20:56:57 <sorear> --help
20:57:37 <sorear> you might also want to "echo 'Eric Mertens <emertens@gmail.com>' > ~/.darcs/author"
20:57:45 <sorear>              --to=EMAIL                  specify destination email
20:58:03 <sorear> so, --to=stefanor@cox.net
20:58:37 <sorear> oh joy
20:58:40 <glguy> who do I chec kin my changes locally?
20:58:52 <sorear> who -> how ?
20:59:01 <glguy> record?
20:59:02 <sorear> darcs record
20:59:02 <allbery_b> darcs record?
20:59:03 <glguy> how
20:59:37 <sorear> darcs record -a says don't ask what to record (can be dangerous)
21:00:01 <glguy> darcs send --to=stefancor@cox.net ?
21:00:08 <sorear> darcs record -m "foo" is sometimes good because bash line editing is far better than darcs line editing
21:00:15 <sorear> nor, not ncor
21:00:23 <sorear> yes
21:00:35 <sorear> HAppS failed to compile.
21:00:44 <glguy> darcs thinks I sent you a patch
21:00:44 <sorear> (will now try a *released* version of GHC)
21:00:53 <glguy> I'm not sure if the email will make it out however
21:02:05 <sorear> darcs send -o /tmp/foo # may be useful
21:04:01 <glguy> ok, .. sent
21:04:15 <glguy> sorear: what changes did you have in mind?
21:04:36 <sorear> display as plain text
21:04:41 <sorear> lambdabot integration
21:04:52 <glguy> I'll add plain-text now
21:05:00 <glguy> since I don't know about lambdabot :)
21:07:21 <glguy> hostname/id/annotationid -> plain?   or  hostname/id/annotationid/plain -> plain?
21:07:22 <sorear> applied.
21:07:37 <glguy> not sure if we'd want to save the former for something else
21:07:55 <glguy> the latter allows youto have other formats
21:08:04 * sorear agrees with the latter
21:08:14 <sorear> I'd also like to see cookies
21:08:21 <glguy> to do?
21:08:28 <sorear> people who hate your colorscheme can set cookies to change it
21:08:33 <glguy> heh
21:08:41 <glguy> or just set their own CSS file
21:09:23 <sorear> paste CSS, then set CSS_PASTE_ID cookie :)
21:09:40 <sorear> re-upload finished
21:10:22 <sorear> once HAppS finishes building, I think I'll add Cabal support
21:12:20 <glguy> take a look at how the bot and happs talk over the Chan sometime to see if I'm making that harder than it should be
21:12:38 <sorear> ok
21:12:50 <sorear> I still haven't learned happs, either :)
21:13:15 <glguy> !id test
21:13:16 <hpaste2> test
21:13:55 <sorear> !help
21:14:17 <hpaste2> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
21:16:10 <glguy> !quit
21:16:30 <glguy> http://fserv.pikapphi.umr.edu:8000/25/0/plain
21:16:46 <glguy> I need to figure out how to set "text/plain" in HAppS now :)
21:17:38 <sorear> wow, that's condensed code ;)
21:17:40 <hyrax42> happs?
21:17:44 <glguy> yeah
21:17:51 <hyrax42> isn't that overkill for a pastebin?
21:17:51 <hyrax42> !
21:17:57 <glguy> using happs?
21:18:25 <hyrax42> or never mind
21:18:29 * hyrax42 shuts up
21:21:38 <sorear> @where HsColor
21:21:38 <lambdabot> I know nothing about hscolor.
21:21:40 <sorear> @where HsColour
21:21:40 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
21:28:50 <sorear> glguy: what version of HAppS are you using?
21:28:55 <glguy> 0.8.4
21:29:06 <shapr> Not 0.9.0?
21:29:12 <glguy> nope
21:29:13 <shapr> hmm
21:29:14 <glguy> should I change?
21:29:26 <sorear> 0.9.0 has been released?
21:29:33 <shapr> Not released yet, but it's in the darcs repo.
21:29:37 <glguy> 0.8.4 was the newest shown on the site
21:29:39 <shapr> It's not totally finished either...
21:29:39 * sorear is using the darcs version and experiencing type errors
21:29:54 <shapr> But it's 99% done
21:30:00 <sorear> shapr: btw, 0.9.0 doesn't compile on GHC HEAD
21:30:31 <sorear> something about implicit params
21:30:36 <shapr> I'll mention that to the peoplez.
21:30:37 <sorear> and no instance
21:31:36 * sorear is now compiling 0.8.4 ...
21:35:55 <glguy> these work: http://fserv.pikapphi.umr.edu:8000/24/0/plain
21:36:02 <glguy> and links are displayed near the paste
21:37:08 <sorear> nice
21:38:38 <sorear> Ok, modules loaded: PasteBot, Main, PasteState.
21:39:32 <hpaste2>  sorear pasted: test at http://fserv.pikapphi.umr.edu:8000/0
21:40:16 <glguy> probably need to not hardcode the URL :)
21:41:05 <sorear> hehehe
21:41:13 <sorear> anyway, I don't have a public IP
21:41:16 <glguy> there may be a happs function for looking that up
21:41:52 <glguy> !paste
21:41:52 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
21:44:08 <glguy> someone tuukkah? suggested annotations from IRC
21:44:37 <glguy> hpaste: #22 + this h hj l lkj; lj ioj k
21:45:02 <TSC> That seems awkward for multi-line annotations
21:45:23 <glguy> yeah, though i could try to ?pretty it or something
21:51:54 <sorear> Cabal can compile hpaste
21:52:05 <glguy> yea :_
21:52:07 <glguy> :)
21:53:51 <sorear> cabal patch sent.
21:54:10 <sorear> (I'm trying to ignore the fact that I have physical repository access)
21:54:17 <glguy> received
21:54:52 <glguy> if all the patches are via email
21:54:57 <glguy> oh
21:55:05 <glguy> hey, so what is serving your darcs repo?
21:55:23 <sorear> Cox Communication customer web-hosting
21:55:44 <sorear> they're the big ISP in san diego
21:56:06 <glguy> so you just have the hpaste dir in a location that the webserver servers?
21:56:08 <glguy> serves*
21:56:35 <glguy> want me to sent *you* the patch with plain text link support?
21:56:41 <sorear> yes
21:56:53 <sorear> I don't have direct access to the server - ftp only.
21:58:34 <Cale> hmm, it might be cool to have the all pastes page display some relevant characteristics of each paste, like number of lines/annotations.
21:59:19 <glguy> that should probably be cached though, right?
21:59:45 <sorear> laziness? :)
21:59:49 <glguy> which means I am going to need a MkEntry3 data constructor :)
22:00:08 <glguy> i just don't want to calculate it each time
22:00:34 <glguy> that's why some records have a TimeDiff of "Pre-history"
22:00:50 <Cale> You'd save a bunch of code by using record syntax for the Entry datatype
22:01:16 <glguy> Cale: can multiple data constructors share record names?
22:01:22 <sorear> no
22:01:25 <Cale> field names, yes
22:01:32 <glguy> oh, that's what I meant
22:01:46 <sorear> but they have to be on the same type
22:01:55 <Cale> In this case, they are :)
22:02:05 <sorear> data Foo = Bar { bar :: Int } | Quux { bar :: Int }  -- okay
22:02:12 <glguy> Cale: what does calling a field accessor on a data constructor that doesn't have that field do?
22:02:19 <sorear> data Foo = Bar { bar :: Int } ; data Quux = Quux { bar :: Int }  -- not okay
22:02:22 <sorear> glguy: error
22:02:29 <glguy> that can't happen
22:02:37 <glguy> I need fail-over logic
22:02:46 <glguy> when the field doesn't exist
22:02:54 <Cale> right, so you might still want entryTime to have its existing implementation
22:03:13 <Cale> but entryNick, entryTitle and entryContent might as well be field accessors.
22:03:15 <sorear> wouldn't it be easier to create the field on startup if it doesn't exist?
22:03:29 <sorear> in the deser code?
22:03:39 * sorear hasn't read it yet
22:03:41 <glguy> sorear: yeah, but I didn't know how, and I wanted a timestamp
22:04:51 <sorear> y
22:05:04 <sorear> 'know, purging the state is still an option...:)
22:05:23 <glguy> yeah, but I need to be able to add fields without doing that...
22:05:35 <glguy> and I like having stuff in there
22:05:53 <glguy> i could blow away all the old pastes  i guess
22:06:08 <Cale> yeah, I'd say just blow them away :)
22:06:20 <glguy> every time I want to make a change?
22:06:43 <Cale> We ought to know whether there's any important ones :)
22:06:52 <sorear> It would be better to have instance Read PasteState fill in default field values.
22:07:01 <sorear> I could do that generically using SYB.
22:07:38 <glguy> one thing I want to do is compress the paste contents
22:07:42 <Cale> Oh right, I suppose we could have classes.
22:07:49 <Cale> even without SYB
22:08:06 <sorear> SYB makes it so all glguy has to do is
22:08:14 <sorear> deriving (Typeable,Data)
22:08:34 <sorear> instance Read PasteState where readsPrec = extRecordReadsPrec
22:08:48 * sorear is now writing extRecordReadsPrec
22:09:05 <glguy> I'll just write a function that updates the state to use the new constructor
22:09:15 <glguy> call it via happs "/fix" or whatever
22:09:19 <glguy> and then remove the old constructor
22:14:26 <sorear> glguy: should I transfer the Cabal-patch into the main repo?
22:14:33 <glguy> might as well
22:14:37 <glguy> I'll pull down from there
22:14:42 <glguy> that's easier
22:14:52 <sorear> ok.
22:15:40 <bos31337> ?seen dons
22:15:40 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7h 22m 16s ago.
22:16:01 <sorear> bos31337: dons will be awake Real Soon Now ... 3h tops
22:16:21 <sorear> dons is attending POPL, has the same @localtime as dcoutts_
22:16:49 <sorear> glguy: this is the kind of thing HWN wants ... so announcing to -cafe might be good
22:16:51 <hpaste> glguy flushed me :(
22:17:07 <sorear> yay, it can talk!
22:17:33 <hpaste> (Admin commands: !id !quit) (Public command: !paste)
22:17:45 <sorear> oooh
22:17:48 <sorear> neat
22:18:03 <hpaste> @bot
22:18:04 <lambdabot> :)
22:18:41 <sorear> can I still spam the channel with it?
22:18:48 <sorear> ?msg hpaste !paste
22:18:50 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
22:19:13 <sorear> you see who sent that message
22:19:18 <glguy> *I* do
22:19:32 <glguy> :lambdabot!n=lambdabo@manzano.cse.unsw.EDU.AU PRIVMSG hpaste :!paste
22:20:54 <glguy> first post?
22:21:00 <glguy> "frist" rather
22:21:05 <sorear> ?
22:21:13 <Cale> frost pist!
22:21:25 <sorear> where+ ?
22:22:33 <sjanssen> glguy: is hpaste's code available?
22:22:43 <glguy> sjanssen: ask sorear for the url
22:22:56 <sorear> glguy: may I say it on channel?
22:23:10 <glguy> yes
22:23:12 <sorear> http://members.cox.net/stefanor/hpaste/
22:23:26 <sorear> @where+ hpaste http://members.cox.net/stefanor/hpaste/
22:23:26 <lambdabot> Done.
22:23:29 <glguy> I have to admit to everyone that the code is boring eventually
22:23:37 <glguy> might  as well let them look at it
22:24:50 <hpaste>  glgu pasted: frist post!!1 at http://fserv.pikapphi.umr.edu:8000/0
22:25:05 <sorear> glgu? :)
22:25:34 <glguy> yeah, I rushed the whole thing
22:25:40 <glguy> I didn't even put working code up!
22:26:12 <sjanssen> glguy: the text box doesn't seem wide enough
22:26:25 <glguy> for new pastes?
22:26:36 <glguy> (agreed if that's what you mean)
22:26:58 <hpaste>  sjanssen pasted: wonder how this looks at http://fserv.pikapphi.umr.edu:8000/1
22:27:25 <sjanssen> glguy: right
22:27:39 <sjanssen> it should be a bit wider at least
22:27:39 <glguy> straw poll, how big should it be?
22:27:43 <glguy> 100%
22:27:53 <glguy> ?
22:28:01 <sjanssen> I'm also not a big fan of the scroll bar, but I'm flexible
22:28:07 <nmessenger> I vote yes
22:28:10 <sorear> 100% sounds goodx
22:28:18 <Cale> what isn't wide enough?
22:28:20 <glguy> is it tall enough?
22:28:24 <sorear> I have a 128 col screen, so 120 should be fine.
22:28:31 <Cale> oh, that text box
22:28:42 <Cale> The New Paste page?
22:28:44 <glguy> yeah
22:28:59 * sjanssen was referring to the paste as rendered
22:29:03 <sjanssen> sorry
22:29:07 <Cale> make it the same width as the box in which the text will be displayed
22:29:10 <glguy> sjanssen: that will be as big as your window
22:29:29 <Cale> (basically, 100% - some small margin)
22:30:10 <sorear> 80 columns is standard...
22:30:51 <glguy> I just copied lisppastes settings
22:30:54 <sjanssen> glguy: I guess it looks fine in Firefox, but it renders very strangely in Safari
22:31:47 <sorear> looks *great* in elinks
22:32:01 <sorear> much better than lisppaste
22:32:36 <glguy> lisppastes captcha was a breaking point and motivation for this for me
22:33:15 <glguy> that and it being down...
22:33:42 <glguy> sorear: did you ever pick your paint color?
22:33:43 <allbery_b> that is rather odd looking in safari
22:33:43 <nmessenger> lisppaste added a captcha?
22:33:51 * glguy gets his powerbook out
22:34:39 <sorear> nmessenger: yes :(
22:35:02 <sorear> a captcha, I might add, which is completely invisible in elinks.
22:35:04 <sjanssen> glguy: http://cse.unl.edu/~sjanssen/hpaste_safari.png
22:35:08 <glguy> whoa, looks bad in safari
22:35:10 <nmessenger> bummer
22:35:12 * glguy is in OS x now
22:35:14 <glguy> i'll fix
22:35:27 <sorear> at least wikipedia's captcha has the decency to show up as [IMG]
22:35:32 <nmessenger> Teeny weenie problem: a big, wide paste will cause a horiz scrollbar on the bottom.  If I'm in the middle of code and want to scroll right, I must either click into the <pre> and arrow right or scroll page down, scroll code right, scroll page up.
22:35:47 <nmessenger> Possible changes: either make it less than a page high so I don't need to scroll down to the horizontal scrollbar, or get rid of the 'pre {overflow: auto}'
22:35:51 <glguy> nmessenger: you can hold your mouse down
22:36:06 <glguy> nmessenger: and use the selection to scroll over
22:36:15 <nmessenger> yuck :/
22:36:29 <glguy> use OS X
22:36:31 <glguy> a powerbook
22:36:32 <sorear> glguy: I don't have CSS and it looks much better than that :)
22:36:35 <glguy> two finger scroll
22:37:35 <glguy> Does the paste display page look right in everyones browser now?
22:37:43 <glguy> it's been modified for safari...
22:37:52 <sjanssen> glguy: looks great
22:38:03 <sorear> !paste
22:38:04 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
22:38:14 <sjanssen> glguy++
22:38:26 <sorear> still looks good for me
22:38:30 <glguy> lol
22:38:32 <sorear> one minor point
22:38:42 <sorear>    all pastesannotate this pastenew paste
22:38:43 <glguy> shoot
22:38:52 <glguy> ah..
22:39:05 <sorear> I'd like spaces, if you can arrange it :)
22:39:21 <glguy> you have the source!
22:39:38 <glguy> that is a <ul>
22:39:42 <glguy> err
22:39:43 <glguy> no
22:39:45 <glguy> that's not is it..
22:39:45 <sorear> I don't have working HAppS knowledge yet
22:39:46 <glguy> ok
22:39:56 <glguy> that's Text.XHtml stuff, but I'll fix, that's fine
22:39:59 <allbery_b> much better, glguy++
22:40:00 <sorear> I also see it is bedtime:37
22:40:02 <sjanssen> future work: parse/typecheck the code and return ghc error messages
22:40:09 <glguy> lawls...
22:40:14 <allbery_b> ha
22:40:40 <sorear> Going down for User Halt in 45 seconds!
22:40:52 * nmessenger is fond of the haskell.org syntax color scheme.
22:41:25 <glguy> spaces added
22:41:37 <glguy> nmessenger: link to your favorite examle?
22:41:39 <sorear> perfect
22:41:41 <sorear> glguy++
22:41:49 <sorear> user halted.
22:41:54 <glguy> ?karma
22:41:54 <lambdabot> You have a karma of 38
22:41:56 <glguy> lol
22:42:33 <sjanssen> we should also look into the function name -> haddock linking that haskell.org does
22:42:49 <glguy> sjanssen: hscolour has something like that
22:43:21 <nmessenger> glguy, Of code? http://haskell.org/haskellwiki/The_Other_Prelude
22:43:23 <lambdabot> Title: The Other Prelude - HaskellWiki
22:44:21 * sorear suggests creating a TODO file
22:44:31 <sorear> now, halt for real ...
23:10:30 <glguy> slow night..
23:11:08 <Jaak> slow morning...
23:15:56 <glguy> welp, if theres nothing going on, I'll just spam and log
23:16:00 <glguy> !paste -- spam
23:16:01 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
23:16:04 * glguy log
23:16:25 * glguy out*
23:19:44 <Korollary> I came back from a C++ users meeting
23:20:43 <Korollary> Walter Bright gave a presentation on his D language
23:20:58 <Korollary> I irritated him with my questions until I got bored.
23:22:52 <Korollary> why do people read Steve Yegge's posts anyway
23:23:44 <Modius> Was reading an article at this blog:  http://scienceblogs.com/goodmath/2006/11/why_haskell.php  and the comments under it - I think they missed the point; but I have questions. . . .
23:23:45 <lambdabot> Title: Good Math, Bad Math : Why Haskell?
23:24:17 <Modius> Someone mentioned - what if the lists being merged in this haskell weren't haskell lists - but doesn't this miss the point - aren
23:24:31 <Modius> 'aren't "lists" in haskell just representations for some lazy-evaluated or virtual data sequence?
23:24:49 <Modius> Does the spec ensure that a "list" mentioned in code ever actually cause the generation of a list?
23:25:37 <Korollary>  What do you mean by generation of a list?
23:25:47 <Modius> Look at hte examp
23:25:51 <Modius> woops
23:26:07 <Modius> The example showed a quicksort implemented as (smallerlist) ++ [X] ++ (biggerlist)
23:26:26 <Modius> But expressing in this form doesn't necessarily tell the compiler to literally build a list does it?
23:27:27 <tphyahoo> Modius, I think the answer must be no.
23:27:33 <Korollary> what else could it be building?
23:27:42 <tphyahoo> otherwise, infinite lists would be impossible.
23:27:59 <nmessenger> the only expressions evaluated are those necessary to perform the 'main' action, or in layman's terms, if it doesn't get 'called' from main, it doesn't get constructed.
23:28:01 <Modius> Aah, good point - wish someone had/would post that point (I don't have any "haskell" cred myself)
23:28:18 <Modius> Right, a list could represent a sequence of results from some map that don't ever get made into a list at all, right?
23:28:34 <nmessenger> > take 5 [1..]
23:28:35 <lambdabot>  [1,2,3,4,5]
23:28:42 <nmessenger> > [1..]
23:28:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:29:01 <nmessenger> yep
23:29:18 <Modius> So technically (although I don't know if the implementations would in practice) - the compiler, given the example in that link, has enough information to build an optimal quicksort, right?
23:29:59 <Korollary> not in place
23:30:40 <nmessenger> in place sort would require destructive update, which isn't (implicitly) allowed in haskell
23:31:24 <Modius> Right; but technically what's there is the specification for a sort.
23:32:17 <nmessenger> Yep, at evaluation time, the compiler decides on an order of operations, and code is executed that isn't too exotically different from any other language.
23:33:09 <Modius> The compiler has latitude to build a destructive sort from the spec I would imagine.
23:34:43 <nmessenger> I suppose it could if it could guarantee that the input list is not re-used anywhere else, but this guarantee is not given (I think), so in-place wouldn't happen.
23:34:47 <allbery_b> I think in theory it could do so *if* it knows the original value is not reused
23:34:51 <allbery_b> yeh
23:35:00 <Modius> As haskell it can know the original won't e used ;)
23:35:06 <Modius> I mean, it can know where the original came from.
23:35:13 <Modius> Or worst case do a single-copy
23:35:20 <Modius> (At the outermost caller)
23:35:29 <nmessenger> I don't know of any haskell facility for this, but I trust GHC to Do The Right Thing.
23:35:43 <arv> Hey all, I am just  starting up with Haskell and I have this error. Anyone can tell me what's happening? "...Instance of Num Expr required for definition of s
23:35:48 <arv> "
23:35:52 <Modius> If the thing calling into "qsort" is just more haskell, haskell has control over how the caller inteacts with its results anyway.
23:36:42 <nmessenger> arv, an Expr is being added or subtracted or something in your 's' function, so the compiler wants it to be a number.
23:36:54 <allbery_b> arv: you are trying to do math on a value of type Expr (presuably user-defined)), instead of presumably on a value contained within it
23:37:42 <nmessenger> you should probably pass your Expr into a function to turn it into a number and use that.
23:38:05 <arv> Hmm
23:38:15 <arv> http://devforge.net:8080/arv/haskell.hs
23:38:21 <nmessenger> ?paste your code at the below link
23:38:22 <lambdabot> http://paste.lisp.org/new/haskell
23:38:29 <arv> I have a Expr to Int derivation, isnt that enough?
23:39:03 <nmessenger> arv, put the 'Litr' constructor before '3'
23:39:18 <nmessenger> 'Litr' turns an 'Int' into an 'Expr'
23:39:48 <arv> Actually, I want the s to be a collection of cells. i.e., I originally tried s :: Sheet and that is my intention :)
23:40:33 <arv> I can have a tuple (containing teh address) and  the second element as the expression, which can be a number, as in this case, or a more complcated stuff like 3+4
23:40:34 <arv> hmm
23:40:35 <allbery_b> that should work.  but yoy can't just use an Int where you declared an Expr; you need to use the type constructor:  Lit 3 (instead of just 3)
23:40:38 <nmessenger> You'd still need the 'Litr' constructor. '3' is an 'Int', 'Litr 3' is an 'Expr'
23:40:48 <arv> oh
23:40:50 <allbery_b> and similarly with the cell address
23:41:23 <allbery_b> nom, sorry, the address is fine
23:41:35 <allbery_b> already closed the window, misremembered Addr was a tyuple
23:41:45 <allbery_b> *tuple
23:42:46 <arv> so can i not have 's' contain tuples of addresses and expressions, where expressions can be either simple numbers, or more complicated stuff?
23:42:58 <allbery_b> you can, they just have to have the correct types
23:43:05 <allbery_b> which is why you use type constructors
23:43:21 <arv> If I mentioned just Litr, then I can have only Int's there, I suppose...
23:43:30 <allbery_b> so Litr 3, or Add (Litr 3) (Litr 5), etc.
23:44:08 <arv> Oh..
23:44:11 <nmessenger> if the typechecker expects an Expr, you cannot use an Int, but Expr can contain an Int if it's a Litr
23:44:19 <tphyahoo> > take 10 ( [1..10^100] )
23:44:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:44:40 <arv> Let me try that one..:)
23:44:44 <tphyahoo> what's going on behind the scenes there?
23:44:54 <nmessenger> ?src take
23:44:54 <lambdabot> take n _      | n <= 0 =  []
23:44:54 <lambdabot> take _ []              =  []
23:44:54 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
23:44:58 <tphyahoo> is that called "list comprehension"?
23:45:08 <allbery_b> no, it's just a range
23:45:16 <allbery_b> secretly it's enumFromTo
23:45:31 <tphyahoo> but the .. is sugar for something?
23:45:39 <allbery_b> yes, that's the enumFromTo
23:45:40 <Korollary> it's sugar from enumFromTo
23:45:43 <nmessenger> > take 10 (enumFromTo 1 (10^100))
23:45:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:46:03 <tphyahoo> :src enumFromTo
23:46:04 <nmessenger> ?hoogle enum from to
23:46:04 <lambdabot> Did you mean: Enum From To
23:46:04 <lambdabot> Prelude.undefined :: a
23:46:04 <lambdabot> Test.QuickCheck.Batch.bottom :: a
23:46:14 <allbery_b> ?src enumFromTo
23:46:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:46:28 <allbery_b> ?hoogle enumFromTo
23:46:28 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
23:46:29 <lambdabot> Language.Haskell.Syntax.HsEnumFromTo :: HsExp -> HsExp -> HsExp
23:46:39 <allbery_b> guess the source hasn't been entered into the db yet
23:46:43 <nmessenger>  ?src doesn't work on methods since they vary by type
23:46:44 <allbery_b> wait
23:46:48 <allbery_b> ?src Int enumFromTo
23:46:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:46:51 <allbery_b> nope
23:47:03 <allbery_b> ?src Integer enumFromTo
23:47:04 <lambdabot> Source not found. stty: unknown mode: doofus
23:47:11 <nmessenger> ?help src
23:47:11 <lambdabot> src <id>. Display the implementation of a standard function
23:47:31 <allbery_b>  ?src does take an optional type for things defined in a typeclass
23:47:38 <allbery_b> ?src Maybe (>>=)
23:47:38 <lambdabot> (Just x) >>= k      = k x
23:47:38 <lambdabot> Nothing  >>= _      = Nothing
23:47:53 * nmessenger didn't know that
23:49:01 <allbery_b> anyway, all the [ .. ] forms desugar to enumFrom... things, as specified in the Haskell98 report
23:49:08 <allbery_b> another form is:
23:49:20 <allbery_b> > take 10 [1,3..100]
23:49:21 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
23:49:28 <allbery_b> which desugars to:
23:49:36 <nmessenger> > take 10 (enumFromThenTo 1 3 100)
23:49:37 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
23:49:38 <allbery_b> > take 10 (enumFromThenTo 1 3 100)
23:49:40 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
23:49:43 <nmessenger> :P
23:49:46 <allbery_b> heh
23:49:50 <tphyahoo> but my example had
23:50:02 <tphyahoo> > take 10 ()
23:50:02 <lambdabot>  Couldn't match `[a]' against `()'
23:50:16 <tphyahoo> > take 10 (enumFromTo 1..10^100)
23:50:16 <lambdabot>  Parse error
23:50:20 <nmessenger> The parens?  Just for grouping.
23:50:29 <tphyahoo> > take 10 (enumFromTo 1 10^100)
23:50:29 <lambdabot>   add an instance declaration for (Num [a])
23:50:32 <allbery_b> you can't use '..' in that
23:50:46 <tphyahoo> > take 10 (enumFromTo 1 2 10^100)
23:50:47 <lambdabot>      The function `enumFromTo' is applied to three arguments,
23:50:47 <lambdabot>     but its typ...
23:51:00 <nmessenger> +Then
23:51:04 <tphyahoo> > take 10 (enumFromTo 1 10^100)
23:51:04 <lambdabot>   add an instance declaration for (Num [a])
23:51:24 <tphyahoo> arg, back to ghci :)
23:51:37 <nmessenger> > take 10 (enumFromTo 1 (10^100))
23:51:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:52:18 <allbery_b> in Haskell function application has highest precedence, so enumFromTo 1 10^100 parses as (enumFromTo 1 10)^100
23:52:26 <allbery_b> which is a type error
23:52:33 <tphyahoo> thanks nmessenger. point being, that humongo list isn't actually being constructed fully.
23:52:45 <nmessenger> nopers :D
23:53:02 <tphyahoo> yet hoogle says enumFromTo returns "an array of members..."
23:53:04 <nmessenger> > take 10 [1..] -- is more dramatic, though :P
23:53:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:53:16 <nmessenger> o.O
23:53:30 * nmessenger checks hoogle in disbelief
23:53:45 <tphyahoo> http://www.zvon.org/other/haskell/Outputprelude/enumFromTo_f.html
23:53:46 <lambdabot> Title: Haskell : enumFromTo
23:54:14 <allbery_b> remember that Haskell is lazy unless specified otherwise.  so it returns an array, sure, but arrays are lazy
23:54:34 <tphyahoo> aha, I didn't know that.
23:54:42 <allbery_b> you could say that an array is actually a "suspended" calculation, which will be continued stepwise as hthe caller needs
23:55:00 <tphyahoo> whereas a list... is just a bunch of cons :)
23:55:05 <allbery_b> thus, "take 10" causes only the first 10 elements to be computed; the rest doesn't ever get seen
23:55:27 <allbery_b> > take 5 [1,2,3,4,5,undefined]
23:55:29 <lambdabot>  [1,2,3,4,5]
23:55:34 <allbery_b> > take 5 [1,2,3,4,undefined]
23:55:36 <lambdabot>  Undefined
23:55:52 <tphyahoo> ohhhh...
23:55:58 <nmessenger> Or, to be *completely* anal, the *evaluation* of "take 10" causes the computation, it can be skipped, too.
23:56:09 <allbery_b> yeh
23:56:35 <allbery_b> infinite lists are a very common idiom in Haskell because they never actually *become* infinite unless you do something wrong
23:56:45 <allbery_b> take 5 [1..]
23:56:53 <allbery_b> > take 5 [1..]
23:56:54 <lambdabot>  [1,2,3,4,5]
23:56:58 <allbery_b> > [1..]
23:57:00 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:57:09 <nmessenger> It's exciting!  Playing with things which don't actually exist! :D
23:57:34 <allbery_b> ...and the reason the second isn't infinite is the fact that the bot chops the result at a specific length, and Haskell is smart enough to propagate that back to the infinite list
23:57:41 <nmessenger> > reverse [1..] -- though sometimes dangerous
23:57:45 <allbery_b> yeh
23:57:45 <lambdabot> Terminated
23:58:55 <nmessenger> If we're on the topic of sugar, plain ol' list notation is sugar for repeated consing: '[1,2,3,4]' -> '1:2:3:4:[]'
23:59:33 <tphyahoo> whereas yada yada notation ... is sugar for enumFromTo. which gives you an array, not a list.
23:59:40 <tphyahoo> right?
23:59:47 <allbery_b> laziness has advantages other than this:  because expressions are evaluated lazily, you can implement control constructs as ordinary functions
23:59:50 <Modius> Has anyone played with/know of anything useful that can tie lisp and haskell together somehow?
23:59:50 <nmessenger> No!  Incorrect documentation!
23:59:53 <allbery_b> no, enumFromTo produces lists
