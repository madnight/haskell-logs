00:06:09 <hpaste>  glguy annotated "!a new paste!" with "sorry to say that #anchors need to start with a letter to be "valid"" at http://hpaste.org/5#a2
00:24:55 <musasabi> notsmack: old checkpoints are like backups
00:25:39 <notsmack> sure
00:25:56 <notsmack> i'm just saying when you're in the code creating them, you shouldn't need to poll.
00:36:22 * roconnor wonders if people ought not to be using a research language for practical applications
00:37:46 <notsmack> roconnor: why's that?
00:38:05 <roconnor> I was pointed to this thread http://www.haskell.org/pipermail/haskell-cafe/2007-January/021765.html
00:38:08 <lambdabot> Title: [Haskell-cafe] Channel9 Interview: Software Composability and theFu ture of Lang ..., http://tinyurl.com/2sb232
00:38:21 <roconnor> well, I just read that one post actually
00:38:54 <roconnor> ``Haskell looks like it has these solutions, but extracting them from the noise level of ivory tower debates is a real problem.''
00:39:03 <roconnor> says one person
00:39:12 <roconnor> but I thought Haskell was a research language
00:39:35 <roconnor> So, one would expect ivory tower debates for a research language
00:39:51 <roconnor> the fact that people can write real applications in Haskell is great.
00:40:07 <roconnor> But it seems to be more of a fortunate side effect, rather than the direct goal.
00:40:28 <roconnor> ... maybe I shouldn't call it a side effect
00:40:31 <roconnor> :)
00:45:25 <velco> you're not the only one with that feeling ;)
00:46:59 <Syzygy-> Yo roconnor
00:47:26 <roconnor> hey
00:49:35 <roconnor> I'm reminded of  ``Teach Yourself Programming in Ten Years'' http://norvig.com/21-days.html
00:49:36 <lambdabot> Title: Teach Yourself Programming in Ten Years
00:49:43 <pejo> roconnor, why even bother? We need more (human readable) documentation, no doubt about it.
00:50:11 <pejo> But people approach fp with the idea "Since I know Java - this will be a piece of cake to learn", which it turns out to not be.
00:50:11 <roconnor> pejo: why even bother about what?
00:50:48 <roconnor> ``Walk into any bookstore, and you'll see how to Teach Yourself Java in 7 Days alongside endless variations offering to teach Visual Basic, Windows, the Internet, and so on in a few days or hours.
00:50:48 <pejo> And anyone who has gone through the trouble of learning fp once could have told them before, just like Norvig does - you need to find a new way to think about things .
00:51:09 <roconnor> I wish I could find a book: Teach yourself engeneering in 7 days.
00:51:42 <roconnor> Teach yourself particle physics in 7 days
00:51:51 <roconnor> ... I'd totally buy that book.
00:52:20 <roconnor> Perhaps the market is too small
01:01:16 <mdmkolbe> If (>>=) has type "m a -> (a -> m b) -> m b", then is there an existing operator that has type "a -> (a -> b) -> b" that I can put in a monad pipeline (e.g. if the operator was "=>>", I want to write "m >>= f =>> g >>= h")?
01:01:41 <roconnor> @type flip id
01:01:42 <lambdabot> forall b c. b -> (b -> c) -> c
01:02:17 <roconnor> actually, i don't understand the question
01:04:25 <dons> mdmkolbe: you want to lift a function into a monad?
01:04:40 <dons> :t return () >>= return
01:04:42 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
01:05:01 <dons> > return [1..10] >>= return
01:05:02 <lambdabot>   add an instance declaration for (Show (m [a]))
01:05:14 <mdmkolbe> it's more of a syntactic thing.  The operation I want is a reversed application (e.g. foo x f = f x), but I'd like to use a better syntax than "foo (m >>= f) g >>= h"
01:05:21 <dons> > Just [1..10] >>= return
01:05:23 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10]
01:05:28 <mdmkolbe> I want the function to operate over the entire monad
01:05:37 <mdmkolbe> not just lifting it
01:06:06 <dons> ?let (<.<) = flip (.)
01:06:07 <lambdabot> Defined.
01:06:11 <dons> :t (<.<)
01:06:13 <lambdabot> Not in scope: `<.<'
01:06:25 <nornagon> @ty L.(<.<)
01:06:27 <lambdabot> Not in scope: data constructor `L'
01:06:27 <lambdabot>  
01:06:27 <lambdabot> <interactive>:1:2: Not in scope: `<.<'
01:06:33 <dons> > 'x' <.< toUpper
01:06:33 <lambdabot>  Couldn't match `a -> b' against `Char'
01:06:48 <dons> ?let (<.<) = flip ($)
01:06:48 <lambdabot> <local>:11:0:     Multiple declarations of `L.<.<'     Declared at: <local>:1...
01:06:50 <dons> > 'x' <.< toUpper
01:06:50 <lambdabot>  Couldn't match `a -> b' against `Char'
01:06:54 <dons> ?undefine
01:06:55 <lambdabot> Undefined.
01:06:57 <dons> ?let (<.<) = flip ($)
01:06:57 <lambdabot> Defined.
01:07:02 <dons> > 'x' <.< toUpper
01:07:03 <lambdabot>  'X'
01:07:49 <mux> :t (L.<.<)
01:07:51 <lambdabot> Couldn't find qualified module.
01:07:56 <dons> its not available to :t
01:08:05 <mux> dang
01:08:17 <mux> :t flip ($)
01:08:18 <nornagon> :t flip ($)
01:08:19 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
01:08:20 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
01:08:20 <nornagon> heh
01:08:23 <roconnor> shouldn't one be able to use >>= for reverse application?
01:08:25 <nornagon> jinks
01:08:25 <mux> jinx :-)
01:08:28 <mux> rofl
01:08:31 <nornagon> >.>
01:08:39 <roconnor> Just use >>= in the identity monad, right?
01:08:49 <Syzygy-> Hmmmm.... This probably is not only an insane idea, but also probably unfeasable, but can't one use the curry-howard isomorphism to write a Haskell function that is a proof of ... say ... the 5-lemma?
01:08:59 <mdmkolbe> dons: is (<.<) an existing function or a common notation for that operation?  I can make up my own operator name but if one already exists using that would be best
01:09:12 <roconnor> Syzygy-: what is the 5 lemma?
01:09:30 <roconnor> > 5 >>= (1+)
01:09:30 <lambdabot>   add an instance declaration for (Num (m b))
01:09:42 * mux curses winter
01:09:49 <roconnor> @hoogle Identity
01:09:50 <lambdabot> Control.Monad.Identity :: module
01:09:50 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
01:09:50 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
01:09:52 <nornagon> > Just 5 >>= return . (1+)
01:09:54 <lambdabot>  Just 6
01:09:56 <mux> I must have been ill 80% of the time this winter
01:09:56 <dons> mdmkolbe: there's no existing functoin that I know of
01:09:58 * mux sniffles
01:10:02 <dons> the closest are =<<
01:10:07 <dons> and <=<
01:10:09 <roconnor> @docs Control.Monad.Identity
01:10:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
01:10:16 <dons> for flipped >>= and kleisli composition of monads
01:10:21 <dons> so define away!
01:10:26 <abz> ?docs List
01:10:27 <lambdabot> List not available
01:10:31 <dons> once you have an implementation see if @pl can find you a standard version
01:10:33 <dons> ?docs Data.List
01:10:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
01:10:34 <Syzygy-> roconnor: Say you have two exact sequences a -> b -> c -> d -> e and A -> B -> C -> D -> E with appropriate maps a->A, b->B, d->D, e->E (some need to be epi, some mono), then there is a map c->C, which is iso if enough of the others are.
01:10:44 <abz> thanks
01:10:51 <dons> abz, List is the pre-1998 name for that module :)
01:11:01 <roconnor> > runIdentity (5 >>= (1+))
01:11:02 <lambdabot>   add an instance declaration for (Num (Identity b))
01:11:25 <abz> right.
01:11:31 <mux> dons: I was pondering, is there any interest in having a strict list data-type, besides ByteString which is limited to strings?
01:11:32 <roconnor> :type 5 >>= (1+)
01:11:37 <mdmkolbe> dons: what/who is/are "@pl?
01:11:41 <roconnor> @type 5 >>= (1+)
01:11:42 <lambdabot> forall (m :: * -> *) b. (Monad m, Num (m (m b)), Num (m b)) => m b
01:11:48 <mux> @pl is to rewrite code in point-free style
01:11:49 <lambdabot> (line 1, column 20):
01:11:49 <lambdabot> unexpected reserved word "in" or "i"
01:11:49 <lambdabot> expecting variable, "(", operator or end of input
01:12:20 <mux> @pl foo xs = length (filter (>2) xs)
01:12:20 <lambdabot> foo = length . filter (> 2)
01:12:27 <mdmkolbe> @pl foo x f = f x
01:12:28 <lambdabot> foo = flip id
01:12:32 <roconnor> > (Identity 5 >>= (liftM (1+)))
01:12:33 <lambdabot>   add an instance declaration for (Num (Identity a1))
01:12:40 <roconnor> bah
01:12:45 <mdmkolbe> mux: cool
01:13:00 <roconnor> Syzygy-: Sounds like you could do such a thing
01:13:15 <mux> @undo do x <- getLine; putStrLn x
01:13:15 <lambdabot> getLine >>= \ x -> putStrLn x
01:13:17 <dons> @pl \x f g x -> g x (f x) x
01:13:17 <lambdabot> const (flip flip id . (ap .) . flip ap)
01:13:25 * mux notes lambdabot could have done better here
01:13:30 <dons> @. pl undo do x <- getLine; putStrLn x
01:13:30 <lambdabot> putStrLn =<< getLine
01:13:39 <mux> heh yeah, I was about to type that
01:13:44 <mux> it prefers reverse order ?
01:13:58 <mux> getLine >>= putStrLn is more natural to me
01:15:06 <mdmkolbe> @pl flip ($)
01:15:07 <lambdabot> flip id
01:15:32 <nornagon> @unpl flip id
01:15:33 <lambdabot> (\ b c -> c b)
01:15:54 <sieni> @unpl flip
01:15:54 <lambdabot> (\ a b c -> a c b)
01:16:52 <sieni> @unpl flip id id
01:16:53 <lambdabot> (\ c -> c (\ e -> e))
01:17:14 <nornagon> :t flip id id
01:17:16 <lambdabot> forall c a. ((a -> a) -> c) -> c
01:17:20 <mux> @unpl join (*)
01:17:21 <lambdabot> ((*) >>= \ a -> a)
01:17:24 <sieni> @unpl flip id id id
01:17:24 <lambdabot> (\ e -> e)
01:18:03 <mdmkolbe> @pl flip id id id
01:18:04 <lambdabot> id
01:18:19 <sieni> @unpl flip id id id id
01:18:19 <lambdabot> (\ g -> g)
01:18:22 <mdmkolbe> @pl flip id id x
01:18:22 <lambdabot> x id
01:18:36 <mdmkolbe> @pl flip id id x id
01:18:37 <lambdabot> x id id
01:18:45 <mdmkolbe> @pl flip id x id
01:18:45 <lambdabot> x
01:18:56 <mdmkolbe> @type x
01:18:58 <lambdabot> Not in scope: `x'
01:37:22 <kowey> ?tell dmhouse http://www.haskell.org/mailman/listinfo/wikibook <-- just created :-)
01:37:22 <lambdabot> Consider it noted.
01:40:44 <dcoutts> dons, noted.
01:41:10 * dcoutts waits to be jumped on my lambdabot about messages
01:41:15 <dcoutts> my/by
01:41:56 <dcoutts> dons, yeah, we've been too long without having a release, fortunately it's being fixed now
01:52:39 <pjd_> > runIdentity $ Identity 5 >>= Identity . (+1)
01:52:40 <lambdabot>  6
01:52:55 <pjd_> ^- rconnor
01:53:04 <pjd_> damn, he's gone
02:03:10 <nornagon> kfish: ping
02:03:14 <nornagon> i can't get to kfish.org
02:05:37 <kfish> nornagon: cheers, noted
02:08:50 <kfish> nornagon, fixed (thanks to horms), up again
02:09:04 <nornagon> awesome :)
02:10:40 <kfish> hmm, i really should update that sometime ... most of my homepage is a complete lie about living in australia and stuff :-/
02:11:30 <nornagon> :P
02:11:47 <nornagon> just wanted it for the boids stuff; Chris McCormick mentioned it in his talk
02:23:48 <kfish> nornagon, ah, cool :-)
02:26:18 <nornagon> If I want a list that's infinite in both directions, i need a zipper, right?
02:28:20 <Saizan> normagon: probably, you certainly need 2 lists
02:39:28 <xpika2> does anyone know what $= is equivalent to?
02:45:54 <kosmikus> xpika2: where?
02:46:40 <xpika2> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
02:46:44 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
02:50:14 <nornagon> hm... writing a bf 'terp, because i'm bored
02:50:18 <nornagon> the brackets are the hardest
02:50:21 <nornagon> terp (Brackets b) t = (flip (.)) (flip (foldr terp) b t) (\t@(Tape l x r) -> if x == 0 then t else (flip (foldr terp) b t))
02:50:40 <nornagon> that's obviously not right, but i'm having trouble working out what the best way is to compose that
02:51:43 <nornagon> i need to apply the latter to the result of the former forever until x == 0
02:51:54 <xpika2> man norn have you heard of the where statement. that looks like something @pl would produce
02:52:00 <nornagon> heh
02:52:06 <nornagon> yeah, i'm just hashing it out
02:52:16 <kosmikus> @index $=
02:52:17 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
02:52:17 <nornagon> i'll clean it up when i know what's going on
02:52:20 <kosmikus> xpika2: ^^
02:52:26 <xpika2> thanks
02:52:31 <xpika2> hoogle didnt work
02:52:49 <xpika2> @hoogle $=
02:52:50 <lambdabot> No matches found
02:53:18 <kosmikus> probably Hoogle doesn't index the GL libraries
02:53:33 <kosmikus> $= seems to be a class method of the HasSetter class
02:53:39 <kosmikus> so there are probably different implementations
02:53:51 <kosmikus> ($=) :: s a -> a -> IO ()
02:59:22 <xpika2> @src $=
02:59:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:02:06 <nornagon> okay, cool, i think i got it: execnz b t@(Tape l x r) = if x == 0 then t else execnz b (terp_instrs b t)
03:02:54 <nornagon> oooh, it compiles
03:03:56 <nornagon> sweet, it works too
03:04:03 <nornagon> that was far less painful than i'd imagined
03:07:36 <nornagon> hm, not quite
03:07:42 <nornagon> oh wait
03:07:52 <nornagon> how does brainfuck work when it encounters [+
03:07:53 <nornagon> er
03:07:59 <nornagon> [
03:08:13 <nornagon> does it jump to the ] if the pointer is 0?
03:08:22 <nornagon> or does it execute up to the ] and then check?
03:08:39 <nornagon> while or do .. while?
03:10:48 <nornagon> ah, it's while
03:10:55 <nornagon> that makes it nice and easy
03:11:04 <pjd_> @src ap
03:11:04 <lambdabot> ap = liftM2 id
03:11:14 <nornagon> in fact, i think i'm finished... apart from IO
03:11:16 <pjd_> oh, nifty
03:20:46 <ivanm> dons: For some reason, every time I try and use lambdabot it comes up saying "loading plugins" then quits.  Do you know why?
03:21:22 <nornagon> hm, i think i have a weird laziness issue
03:21:42 <nornagon> *Brainfuck> interpret (Tape [0] 0 [0]) (ast "+++<")
03:21:42 <nornagon> Tape [] 3 [0,0]
03:22:00 <nornagon> maybe it's a problem with my implementation of Tape
03:22:02 * nornagon pastes
03:22:41 <hpaste>  nornagon pasted "A Brainfuck interpreter... that maybe doesn't work?" at http://hpaste.org/172
03:23:47 <int-e> nornagon: why is interpret a foldr?
03:24:10 <nornagon> i guess that's my issue >.>
03:24:26 <nornagon> foldl, i guess it should be
03:25:48 <nornagon> it works!
03:25:49 <nornagon> cool.
03:25:59 <nornagon> thanks for pointing out that stupid error >.>
03:26:19 * nornagon makes the tape autovivify where necessary
03:27:15 <int-e> you could start with (Tape (repeat 0) 0 (repeat 0)) (for a tape that's infinite in both directions)
03:28:08 <nornagon> that makes printing the tape rather painful :P
03:28:19 <int-e> true.
03:28:55 <nornagon> it's really easy to make it autovivify by just amending right and left
03:29:10 <nornagon> but it specializes them to Num t => Tape t
03:29:17 <int-e> I know, I was just trying to be lazy.
03:29:29 <nornagon> yeah, i thought of that in the first place :P
03:29:39 <nornagon> now all i need to add is . and ,
03:29:41 <nornagon> i'm not sure how
03:29:48 <int-e> nornagon: the Num t is your own doing.
03:30:07 <nornagon> not when i add some bits:
03:30:08 <int-e> nornagon: you provided a type signature for left and right.
03:30:12 <nornagon> right (Tape l v []) = Tape (v:l) 0 []
03:30:17 <int-e> ah
03:30:17 <nornagon> left  (Tape [] v r) = Tape [] 0 (v:r)
03:30:27 <int-e> the 0 would do that, right.
03:30:32 <nornagon> yeah.
03:31:19 <nornagon> i'm not sure how to make . and , work without lifting all of terp into IO
03:31:41 <Jaak> you have to
03:31:56 <nornagon> darn.
03:32:18 <Jaak> unless there is some really nasty hack i don't know
03:32:32 <nornagon> :t unsafePerformIO
03:32:34 <lambdabot> Not in scope: `unsafePerformIO'
03:32:38 <nornagon> :t unsafePerformIO#
03:32:39 <lambdabot> Not in scope: `unsafePerformIO#'
03:33:02 <nornagon> @index unsafePerformIO
03:33:03 <lambdabot> System.IO.Unsafe, Foreign
03:33:16 <nornagon> :t System.IO.Unsafe.unsafePerformIO
03:33:18 <lambdabot> forall a. IO a -> a
03:33:50 <int-e> nornagon: don't go there :)
03:34:01 <nornagon> >.>
03:35:24 <nornagon> unsafePerformIO $ do { a <- getChar; return (Tape l a r) } -- it's so tempting!
03:35:54 <Jaak> you can always try it
03:36:07 <int-e> sadly, it probably even works.
03:36:35 <int-e> because you have almost a state monad there with a single state being threaded through a linear computation
03:36:50 <nornagon> :(
03:36:53 <int-e> and that forces evaluation order.
03:37:36 <Jaak> nornagon: you better throw in some !'s, it will perform terribly otherwise
03:37:44 <Jaak> sorry, i meant seq
03:37:46 <nornagon> hm, i should ln -s =ghci ~/bin/irb
03:37:51 <Jaak> ! doesnt hurt either
03:37:57 <nornagon> i see
03:38:00 <int-e> but it's still a bad way to do this.
03:38:28 <nornagon> yes
03:41:53 <int-e> Hmm, depending on how much you like the MTL, I guess you'll either write  interpret :: [Instr] -> StateT Tape IO  or  interpret :: Tape -> [Instr] -> IO Tape  (or [Instr] -> Tape -> IO Tape)
03:44:46 <nornagon> that requires more understanding than i currently possess
03:44:51 <nornagon> i need sleep
03:45:42 <Jaak> nornagon: if you are interested: http://lepo.it.da.ut.ee/~a51081/Progemine/Haskell/bf3.hs
03:45:57 <nornagon> cool, i'll check that out
03:46:05 <nornagon> for now, zzz
03:46:21 <Jaak> slightly optimising but still performs terribly compared to naive C interpreter :\
04:12:29 <jmuk> hello,
04:12:53 <jmuk> I have a trouble when compiling with c2hs, in my program...
04:13:05 <jmuk> The error message is,
04:13:28 <jmuk> c2hs: Error in C header file.
04:13:29 <jmuk>   >>> Syntax error!
04:13:29 <jmuk>   The symbol `{' does not fit here.
04:13:55 <dons> ivanm, the tate format probably changed, delete the State/seen file
04:14:07 <paolino> hi, how do I correctly  write
04:14:08 <paolino> type BeneMale = Int->Int ?
04:14:13 <dons> jmuk, hmm. better ask a c2hs guru on haskell-cafe@ ?
04:14:16 <jmuk> A syntax error in /usr/include/machine/endian.h, which is came from __extension__
04:14:24 <jmuk> dons: thanks
04:14:29 <dons> paolino: ooks ok, but I'd put spaces in
04:14:35 <dons> type ... = Int -> Int
04:15:14 <dons> jmuk, yeah, include the precise header line that failed
04:15:28 <malebria> Good morning.
04:15:38 <dons> hey malebria
04:16:12 <malebria> dons: hey!
04:16:30 * dons `seq` sleep
04:17:03 <jmuk> the file c2hs dumps are uploaded to http://www.city5.org/Node.i
04:17:37 <jmuk> search the word `endian', to see the error
04:18:18 <jmuk> The error line is:  return (__extension__ ({ register __uint32_t __X = (_x); __asm ("bswap %0" : "+r" (__X)); __X; }));
04:18:34 <jmuk> maybe, c2hs failed to process __extension__
04:19:24 <allbery_b> how did I guess it was some weird gnuc-ism?
04:22:04 <jmuk> The code is came from FreeBSD, but I agree that this is weird
04:22:14 <agrasifff32> hi jmuk how r u
04:22:16 <agrasifff32> ?
04:22:19 <agrasifff32> ?
04:22:43 <agrasifff32> hey people
04:24:07 <dons> learning Haskell, agrasifff32 ?
04:24:42 <allbery_b> freebsd uses gcc too... gnuc-ism != linuxism
04:27:34 <jmuk> allbery_b: I agree with you
04:49:27 <fasta> How do I get a Read instance for DiffArray?
04:50:18 <SamB> well, first you send me five dollars in the mail...
04:50:54 <yaarg> :D
04:52:47 <SamB> or, well, maybe you could use ReadP
04:55:40 <robreim> how are type classes made derivable?
04:55:41 <yaarg> actually i've always wondered how DiffArray works
04:55:46 * yaarg googles
04:56:17 <fasta> @src DiffArray
04:56:17 <lambdabot> Source not found. Wrong!  You cheating scum!
04:56:28 <fasta> @src Data.Array.Diff
04:56:29 <lambdabot> Source not found. My pet ferret can type better than you!
04:56:48 <SamB> @docs Data.Array.Diff
04:56:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Diff.html
04:57:18 <fasta> @help src
04:57:19 <lambdabot> src <id>. Display the implementation of a standard function
04:57:25 <yaarg> ah stores the difference...funny enough
04:57:38 <fasta> Either it's Current or it's a difference list
04:57:50 <SamB> I might point out that you can write a perfectly good Read instance using only methods of IArray
04:58:01 <fasta> SamB: I know
04:58:27 <fasta> SamB: I only need to decide on a standard way to show it and a standard way to parse it.
04:58:36 <fasta> For show I could use the builtin stuff.
04:59:18 <SamB> > array (0,2) (zip [0..] [1..]) :: Array Int Int
04:59:20 <lambdabot>  Exception: Ix{Int}.index: Index (3) out of range ((0,2))
04:59:29 <SamB> > array (0,2) (zip [0..2] [1..]) :: Array Int Int
04:59:31 <lambdabot>  array (0,2) [(0,1),(1,2),(2,3)]
04:59:44 <SamB> I say use that format ;-)
04:59:56 <fasta> Yes, I was referring to that.
05:04:32 <daniel_larsson> Am I missing something, or is using ByteString and string constants very cumbersome?
05:04:53 <SamB> daniel_larsson: well, I hear that in GHC HEAD it is not so anymore
05:05:09 <SamB> but yes, at the moment it is fairly so
05:05:30 <daniel_larsson> Ok, good... it's getting rather ugly fast...
05:05:54 <SamB> but you could make make a short name for the String -> ByteString function (like bs)
05:06:43 <daniel_larsson> yes, I did :)
05:07:01 <pjd_> robreim: http://lml.ls.fi.upm.es/~jjmoreno/manual/haskell98-report/derived.html
05:07:04 <lambdabot> Title: The Haskell 98 Report: Derived Instances, http://tinyurl.com/ykmj42
05:07:25 <pjd_> robreim: i think it's a bit magic
05:07:58 <daniel_larsson> I was writing a function to remove preceding/trailing spaces, and using Data.Char.isSpace was rather convoluted
05:08:56 <robreim> pjd_: thanks
05:11:22 <dcoutts> dons, you about? I talked to SimonM the other day about memory management improvements for ByteString
05:12:06 <dcoutts> dons, he thinks we can make the heap allocated bytestrings movable now, without any serious RTS changes
05:12:12 <dcoutts> ie copyable
05:12:28 <dcoutts> so they should cause less heap fragmentation
05:13:46 <dcoutts> though now I come to think about it again there still seems to be one problem..
05:14:04 <dcoutts> but the basic idea is that we only need to pin stuff when we pass them to C land
05:14:25 <dcoutts> now, the rts doesn't have a way to pin exiting allocations, however,
05:14:44 <robreim> I think he went to bed
05:14:58 <dcoutts> if the string is big then it's pinned anyway, and if it's short then there's very little cost in copying it.
05:15:15 <dcoutts> robreim, ah ok, well he'll see it when he wakes up
05:15:21 <daniel_larsson> dcoutts: ***dons `seq` sleep (1 hour ago)
05:15:58 <dcoutts> fear not, #haskell works well as a shared notepad :-)
05:16:05 <daniel_larsson> *nod*
05:16:28 <huschi> bringert: are you also the maintainer of hws?
05:16:44 <bringert> huschi: I guess so
05:17:25 <huschi> bringert: you seem to be the maintainer for many components of my recent project :)
05:17:28 <bringert> huschi: I maintain two versions, http://darcs.haskell.org/hws/ and http://www.cs.chalmers.se/~bringert/darcs/hws-cgi/
05:17:30 <lambdabot> Title: Index of /hws
05:17:42 <huschi> i've got a question concerning the cgi version.
05:17:52 <bringert> huschi: shoot
05:18:32 <huschi> in MimeTypes.hs in the function parseMimeLine there is a "case of" over the result of a parser.
05:18:43 <huschi> if the parser fails, nothing is returned.
05:18:50 <malebria> I'm trying to write a .cabal file, but I'm getting an error in the tested-with field:
05:18:55 <malebria> tested-with: ghc-6.6
05:19:01 <malebria> Setup.hs: haskellgpc.cabal:20: Parse of field 'tested-with' failed:
05:19:06 <huschi> but if it succeeds, it return nothing too.
05:19:16 <malebria> It's not a very clear error message.
05:19:27 <huschi> that looks strange and disables mime handling.
05:19:49 <malebria> It's not a very clear error message.
05:20:11 <malebria> Ok, I got it, GHC == 6.6
05:21:29 <bringert> huschi: hmm, interesting
05:21:36 <bringert> case parse pMimeLine "MIME line" l of
05:21:37 <bringert>                     Left _  -> Nothing
05:21:37 <bringert>                     Right l -> Nothing
05:21:40 <bringert> very useful
05:22:15 <bringert> that should probably be Right l -> Just l
05:22:26 <huschi> i noticed it because every output was of type text/plain.
05:22:33 <huschi> with that line it works.
05:23:54 <bringert> weird, I seem to have rewritten MimeTypes.hs to use parsec instead of regexps, but I can't have tested it much
05:24:20 <bringert> huschi: send patches for haskelldb, hws etc to bjorn@bringert.net
05:24:33 <huschi> bringert: ok, i will do so.
05:26:18 <huschi> bringert: i need sendmail for darcs send. am i right?
05:26:58 <bringert> huschi: or you can use darcs send -o file and the attach the file to an e-mail manually
05:27:01 <Igloo> You need /usr/sbin/sendmail, but it doesn't have to be sendmail
05:27:31 <bringert> huschi: if you're on OS X and use Mail.app, you can use this http://www.cs.chalmers.se/~bringert/darcs/darcs-apple-mail/send-mail.applescript
05:27:33 <lambdabot> http://tinyurl.com/2d2uyw
05:27:53 <huschi> bringert: i'm on linux :(
05:28:29 <malebria> I'm getting another error now with cabal. I'm using c2hs, and I get the error:
05:28:35 <malebria>      error: Algebra/Geometric/Gpc.h: Arquivo ou diretório não encontrado
05:28:39 <malebria> File not found.
05:28:46 <kowey> huschi: maybe something like msmtp will work for you
05:28:56 <malebria> But this file is there.
05:29:13 <bringert> huschi: attaching darcs send -o output works anywhere. I guess it should be easy to write a script to use thunderbird etc
05:29:37 <huschi> i will try msmtp.
05:29:46 <malebria> Do I have to include Algebra/Geometric/Gpc.h in some field in cabal file?
05:30:24 <bakert> If I use >>= to chain together some operations can I catch an exception thrown in an earlier operation on the end or will my program crash before getting there?
05:30:30 <bakert> (this is all in IO)
05:30:35 <bd_> :t catchIO
05:30:37 <lambdabot> Not in scope: `catchIO'
05:30:40 <bd_> hmm
05:30:42 <bd_> :t catch
05:30:43 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:31:05 <bd_> bakert: you'd do something like catch (a >>= f >>= g >>= h) (\error -> respondToError error)
05:31:12 <bd_> or use try (a >>= f >>= g >>= h)
05:31:36 <bakert> so i can't do (a >>= f >>= g) and do the catch inside g?
05:31:47 <bakert> unless i only want to catch exceptions in g, i suppose.
05:31:58 <bakert> what i mean is to have g be the catch
05:32:00 <bd_> no, because g won't be evaluated until f completes successfully :)
05:32:05 <bakert> drat.
05:32:11 <bd_> think of it, the return value from f is passed to g
05:32:19 <bd_> if f doesn't return, what does g get?
05:32:25 <pjd_> read >>= as "into"
05:32:25 <bd_> you can do:
05:32:30 <bd_> try (a >>= f) >>= g
05:32:34 <bakert> yes but isn't the return value a kind of "possible exception/possible value"  can't i pass that into g?
05:32:41 <bd_> and if g's arguemnt is (Left x) then that's fine
05:33:11 <bd_> bakert: Not really, no. The GHC implementation actually uses exceptions, I think.
05:34:17 <pjd_> bakert: the "possible exception/possible value" isn't what gets passed to g or the other functions; it's the monad as a whole
05:34:49 <bakert> OK.  I think I will use the try (foo >>= bar) >>= handleErrs thing
05:34:55 <kowey> huschi: there is a small bug though.  If the address for darcs send contains "<" or ">", it will get confused.  You can fix that by using the latest darcs stable
05:35:33 <bd_> bakert: you need to use try around it
05:35:39 <pjd_> bakert: think by analogy with the Maybe monad:  it can be Just something or Nothing
05:35:45 <bd_> bakert: try (foo >>= bar) >>= handleErrs
05:35:48 <huschi> kowey: i've got darcs 1.08.
05:35:50 <pjd_> but the things you bind to Maybe values will only ever see Just values
05:35:56 <bd_> handleErrs is of type Either IOError YourDataType
05:36:34 <kowey> huschi: that's going to have the buggy behaviour; darcs get --verbose --partial http://abridgegame.org/repos/darcs <-- might work better
05:36:35 <lambdabot> Title: darcs
05:37:06 <bakert> bd_, pjd_, so i have to use Either?  That's what I was getting rid of as the error handling seemed to be all over my code.  I visit some web pages, I put the values in the db.  If either of these things fail I catch the exception and wrap it.  Then at the top level I want to write a little message to stderr for each one that failed (the string in the exception).  does that make sense?
05:37:40 <bakert> I don't really want all my routines to return IO (Either String Foo) just in case the database is down or whatever.
05:37:45 <kowey> huschi: oh wait, the _darcs/prefs/email isn't set on those repos... no problem then; just don't use '<' or '>' in the address and you'll be fine
05:37:56 <bd_> bakert: no, try adds on the Either
05:38:00 <bd_> so you can do:
05:38:10 <huschi> kowey: i will do so :)
05:38:15 <bd_> do { result <- try someComplexOperation; case result of Left error -> ...; Right ok -> ... }
05:38:26 <bd_> or you can use someComplexOperation `catch` \err -> ...
05:38:43 <bakert> bd_, I see.  Great.  That's what I'm after.
05:39:10 <kowey> (that said, it probably doesn't matter anyway if msmtp is being called as sendmail, not via --sendmail-command, so forget i said anything)
05:39:38 <bakert> The trouble is, I'm doing all this on lists.  So I want to catch or try once for each item in the list rather than for the whole list.  Can I map the try across the list somehow???
05:40:00 <hpaste>  malebria pasted "Problems with cabal + c2hs" at http://hpaste.org/173
05:40:36 <bd_> sure:
05:40:38 <bakert> Perhaps I should define a function that does the whole set of operations on one item.  The wrap a try around that.  Then map the new function across the items.  Does that sound right?
05:40:39 <malebria> I think I'm missing something in the cabal file.
05:40:44 <bd_> mapM (try . someOperation) yourList
05:41:00 <bakert> bd_, cool.  let me try that (no pun intended).  thanks!
05:41:05 <bd_> bakert: probably a good idea, then you can slot it in the someOperation :)
05:41:40 <bakert> where does the error handling go in this version?
05:41:52 <bakert> i mean, the function that decides what to do on error.
05:42:07 <bd_> well, with mapM (try . someOperation), you're, for each element in the list, catching the error and continuing
05:42:18 <bd_> so you need to examine it looking for Left later
05:42:21 <bd_> alternately you could do:
05:42:23 <bakert> Ah right
05:42:29 <bd_> mapM someOperation list `catch` ...
05:42:39 <bakert> So i say mapM (try . someOperation) >>= handlErr
05:42:40 <bakert> ???
05:42:59 <bakert> no
05:43:02 <bakert> that's not right
05:43:16 <bd_> well... that are you trying to do? :)
05:43:34 <bd_> mapping the try over the list will continue with the rest of the list even if any particular item fails
05:43:42 <bakert> Sorry.  Not being very clear.
05:44:09 <bakert> I have a list of Accounts.  I want to visit a website for each one, then put the numbers I find on the site in a database.
05:44:20 <bakert> If any of these operations fail I throw an exception.
05:44:42 <bakert> So I need to say: do all of these operations to the things in this list but if any fail write a little message to stderr.
05:44:49 <bakert> Does that make sense?
05:44:53 <bd_> okay
05:45:41 <bd_> you could do something like mapM (\url -> fmap Just $ doStuff url `catch` err -> hPrint stderr (err, url) >> return Nothing) urls
05:45:45 <bd_> or something
05:45:55 <bd_> then do catMaybes on the result
05:46:02 <bd_> leaving you with only the successes
05:46:10 <bd_> (and the failures on stderr as a side effect)
05:46:47 <bd_> anyway, must leave for class now :/
05:46:53 <bakert> bd_, thanks for your help
05:48:28 <huschi> bringert: there is a problem with the cgi support.
05:48:49 <huschi> i always get an error message like Mon, 29 Jan 2007 13:43:36 GMT  "CGI output" (line 1, column 1):
05:48:49 <huschi> unexpected end of input
05:48:49 <huschi> expecting "\r\n", "\n\r", "\n" or "\r"
05:49:32 <huschi> i extended the error message and noticed that the parsed output is always empty although my cgi generates some output.
05:51:15 <bringert> huschi: if you run the CGI program from the command-line, what does it print?
05:51:34 <huschi> Content-type: text/html
05:51:34 <huschi> bla
05:51:43 <huschi> with some more empty lines.
05:52:46 <bringert> huschi: is there an empty line between content-type and bla?
05:53:05 <huschi> yes. 2 empty lines.
05:53:35 <bringert> huschi: hmm, it worked for me last time I tried
05:54:41 <huschi> i also don't understand that problem.
05:55:12 <bringert> huschi: did you print the value of 'output' in your error message?
05:55:19 <huschi> yes.
05:55:22 <huschi> it was empty.
05:56:07 <bringert> huschi: maybe your CGI program can't be run by the web server for some reason, e.g. some missing environment stuff (like LD_LIBRARY_PATH)
05:56:44 <huschi> i also tried it with a perl script.
05:56:54 <huschi> mhm, i will check that.
05:57:05 <huschi> but i have to go to university now.
05:57:19 <huschi> i will give you a report when i find out more.
05:57:24 <bringert> huschi: ok, great
06:06:56 <diogo> hello
06:08:13 <malebria>      error: Algebra/Geometric/Gpc.h: No such file or directory
06:09:18 <malebria> This is the error message in english.
06:10:10 <bakert> ?tell bd_ thanks for your help with exceptions I haven't everything working perfectly now!
06:10:10 <lambdabot> Consider it noted.
06:11:27 <bakert> ?tell bd_ unfortunately i can't type!  i mean I _have_ everything working perfectly now!  Thanks, bakert
06:11:28 <lambdabot> Consider it noted.
06:35:35 <Masklinn> hello #haskell
06:35:53 <bakert> hello Masklinn
06:41:38 <dancor> what's the right way to do
06:42:35 <dancor> do { .. ; case .. of { .. -> a = 4; .. -> a = 5}; (something with a) }
06:43:18 <dancor> i guess i don't know the right way to have a case statement create a variable
06:43:20 <Igloo> do { ..; a <- case .. of { .. -> 4; ... -> 5; }; foo a }
06:43:27 <dancor> ah.
06:43:30 <Igloo> Sorry, return 4 not just 4
06:43:32 <dancor> of course!
06:43:34 <dancor> right
06:43:42 <dancor> it's like magic
06:44:08 <Igloo> Or a <- return $ case .. of { .. -> 4; .. -> 5 }
06:44:17 <dancor> even better
06:45:12 <twanvl> Or let a = case .. of { .. -> 4; .. -> 5 }
06:45:13 <Igloo> Or you can just say   let a = case .. of { .. -> 4; .. -> 5 } if you aren't doing anything monadic at all
06:46:00 <dancor> there's no way to "pull out" return from something like   a <- case .. of { .. -> .. >> return 4; .. -> .. >> return 5 }   right
06:46:23 <Igloo> right
06:53:37 <dancor> i should set up auto-quit on hibernation, that would be sweet
07:05:37 <malebria> ./Setup.hs is not cleaning c2hs generated *.chs *.chi files.
07:06:19 <malebria> Is this a Cabal bug?
07:08:14 <malebria> About that .h problem, I'm searching for a lot of time now in google, but I can't find any report about a similar problem.
07:08:24 <malebria> http://hpaste.org/173
07:08:35 <malebria> And I got this other c2hs problem..
07:20:28 <malebria> I only get this error message when I specify -odir directory
07:20:36 <bakert> I've got a routine in IO that produces a list of Items.  I've got another routine that turns a list of Items into a String (not in IO).  Very rarely there will be a problem with one of the Items and the second routine will need to print an error passed up not the standard report.  I'd like to avoid an Either as the condition is rare but I can't handle and Exception outside IO.  Any ideas?
07:20:38 <malebria> Without it it giver no error or warnings.
07:20:59 <bakert> *an Exception
07:22:06 <dancor> well you can't print the error without going into IO right
07:22:16 <dancor> and once in IO you can catch exceptions
07:22:50 <dancor> so it seems like you will have to go into IO somewhere at which point you can catch and print if there was an exception
07:22:58 <bakert> Yes.  I suppose I will.
07:23:29 <dancor> lately though i'm coming around on always using either
07:23:33 <bakert> The problem in a nutshell is that the [Item] -> String routine kind of combines all the items in one String.  But I need to catch exceptions at the level of per-Item not once for the whole report.
07:23:46 <bakert> dancor, really?  I've just spent three days removing all the Eithers!
07:23:51 <bd_> bakert: hence, catch exceptions before they go to [Item]->String :)
07:23:52 <lambdabot> bd_: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:24:18 <bakert> Hello bd_ -- I am now exception-ifying a second program!
07:24:33 <bd_> :)
07:24:34 <dancor> bakert: wait won't laziness allow you to print the exception just on the first bad item?  or is that the problem
07:24:50 <dancor> you want it to continue through the items even on error?
07:24:56 <bakert> yes
07:25:03 <bd_> fmap (itemsToString . catMaybes) $ mapM (\i -> fmap Just (getItem i) `catch` \e -> (print <some diagnostis>) >> return Nothing)
07:25:16 <bd_> I'm sure that can be prettified somehow
07:25:45 <bd_> :t fmap (unlines . catMaybes) . mapM (\i -> fmap Just (return i) `catch` \e -> (print (e, i)) >> return Nothing)
07:25:50 <lambdabot> [String] -> IO String
07:26:20 <dancor> bakert: yeah i'm def an Either/Maybe guy these days.  esp since user-def'd exceptions don't seem pleasant in haskell
07:26:48 <bd_> dancor: There's throwDyn and catchDyn
07:26:52 <bd_> :t catchDyn
07:26:53 <lambdabot> Not in scope: `catchDyn'
07:26:55 <bd_> hmm
07:26:59 <bd_> :t Control.Exception.catchDyn
07:27:01 <lambdabot> forall a exception. (Typeable exception) => IO a -> (exception -> IO a) -> IO a
07:27:02 <dancor> bd_: yeah that's how you have to do it
07:27:25 <bd_> doesn't seem too bad, but Either gives some more interesting ways of dealing with it in a monad stack
07:27:28 <bakert> I'm actually using throw and throwIO to throw ErrorCall exceptions.  But I do plan on going back and changing that.
07:27:29 <bd_> EitherT rather
07:27:44 <dancor> bd_: i feel like needing Dynamic for exceptions is broken
07:27:53 <bd_> fair enough :)
07:27:59 <bakert> Basically I am producing a set of line items in a table.  If there's been a problem getting the right thing from the db then I want to print a message to that effect instead of the line item.
07:28:04 * allbery_b wants Exception to be a typeclass
07:28:08 <bakert> But I still want all the other line items.
07:28:32 <bd_> bakert: What's wrong with the snippit I posted? Do you want them to be printed in order or something...?
07:28:37 <dancor> bd_: i mean that's how i feel *today* anyway.  like Exception should have been a typeclass
07:29:04 <bd_> dancor: Well, if you're going to want typing for your exceptions it stands to reason it needs to be in the type of the function
07:29:07 <bd_> ergo, in the type of the monad
07:29:11 <bd_> which conveniently EitherT does :)
07:29:14 <bakert> bd_, sorry i thought that was a "terminating" one that didn't go beyond the first exception.
07:29:18 <bd_> bakert: nope :)
07:29:20 <bakert> the one beginning with fmap?
07:29:22 <bakert> fmap (itemsToString . catMaybes) $ mapM (\i -> fmap Just (getItem i) `catch` \e -> (print <some diagnostis>) >> return Nothing)
07:29:31 <bd_> bakert: yeah, except with your list at the end of that
07:29:39 <bakert> cool i'll give it a shot.  thanks!
07:31:50 <malebria> I'm getting a compilation error and some warnings with -O that I don't get without it.
07:32:19 <hpaste>  malebria pasted "GHC error message with -O" at http://hpaste.org/174
07:32:19 <hpaste>  malebria pasted "GHC error message with -O" at http://hpaste.org/175
07:34:01 <bd_> not sure since I don't know spanish (?), but are you missing an include? try -optc-I <root path to Algebra/Geometric/Gpc.h>
07:34:21 <bd_> [-O would be using gcc for codegen instead of the native ghc codegen...]
07:37:32 <malebria> bd_: hum..
07:37:57 <malebria> bd_: that message is No such file or directory.
07:38:05 <malebria> bd_: it's portuguese.
07:39:53 <dancor> does anyone think it's good practice to do all IO in some IOOrError wrapper in case you need to have error conditions later
07:40:07 <dancor> or should you just refactor as needed
07:40:51 <dancor> type IOOrError a = ErrorT MyErrors IO a
07:41:12 <malebria> BCoppens: thanks, using include-dirs: . worked.
07:41:41 <BCoppens> mmmm?
07:41:52 <BCoppens> ah, that was for bd_ =)
07:42:18 <malebria> BCoppens: sorry. =D
07:43:08 <BCoppens> =)
07:43:53 <Jaak> @pl \(x, y) (w, h) -> (x `mod` w, y `mod` h)
07:43:54 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. mod) . flip . (((.) . (,)) .) . mod)
07:44:00 <Jaak> *khmmm*
07:51:03 <dancor> bd_: sorry i didn't understand what you said earlier about needing exception type in the type of the function
07:51:15 <xerox> > (uncurry (***) . join (***) mod) (12,7) (5,3) -- Jaak
07:51:18 <lambdabot>  (2,1)
07:51:19 <bd_> dancor: if you have a throwSomeExpr :: e -> ?
07:51:24 <bd_> e must appear on the right side
07:51:29 <bd_> or you need to use Dynamic :)
07:51:33 <dancor> bd_: wouldn't an Exception type*class* allow you to have your own ones
07:51:38 <bd_> no
07:51:40 <bd_> because then you have:
07:51:42 <Jaak> nice
07:51:51 <bd_> throwSomeExpr :: Exception e => e -> IO ()
07:52:09 <bd_> catchSomeExpr :: IO () -> (forall e. Exception e => e -> IO ()) -> IO ()
07:52:11 <bd_> which isn't too useful
07:52:27 <bd_> since, it has to accept any exception which might be thrown
07:52:38 <bd_> unless you use something which is functionally equivalent to Dynamic's Typeable
07:53:21 <dancor> i don't quite understand but you are close enough to what i know about that i believe you :)
07:53:41 <dancor> i'll just have to keep thinking about it
07:54:29 <bd_> dancor: catch doesn't know what type e is, you see.
07:54:36 <bd_> it might vary at runtime:
07:54:49 <bd_> doCatch e = ... -- can doCatch be monomorphic?
07:54:56 <bd_> instance Exception A; instance Exception b;
07:55:13 <dancor> so catch :: Exception e => e -> IO ()
07:55:15 <bd_> throwSomeExpr (_ :: A) `catch` doCatch >> throw (_ :: B) `catch` doCatch
07:55:35 <bd_> dancor: Yes, but what can it do with e? What methods will be in Exception to let you inspect the exception?
07:55:46 <dancor> can't use anything about e except its Exception (base class, or whatever) things
07:55:46 <bd_> Now you can't really stuff arbitrary user data in there, can you? :)
07:55:50 <bd_> yep
07:55:52 <dancor> ok
07:55:53 <dancor> got it
07:56:00 <bd_> at which point you might as well just fail "some string"
07:56:45 * bd_ goes to class
07:57:49 <glguy> Good morning
07:58:02 <glguy> ?seen sjanssen
07:58:02 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard sjanssen speak 8h 34m 36s ago.
07:58:36 <glguy> http://programming.reddit.com/info/11kvs/comments/c11lec - (if you were around last night and wondered what the respond would be)
07:58:38 <lambdabot> Title: Monads in Ruby (reddit.com)
08:06:27 <bakert> Can you detect "undefined"?  With == ?
08:07:02 <Botje> ?src undefined
08:07:02 <lambdabot> undefined =  error "Prelude.undefined"
08:07:08 <Botje> good luck with that :)
08:07:16 <bakert> I guess not.
08:07:32 <bakert> I guess I need to use Nothing.
08:08:56 <bakert> > let x = undefined; if x == undefined then putStrLn "hi" else putStrLn "bye"
08:08:56 <lambdabot>  Parse error
08:09:00 <malebria> http://haskell.org/haskellwiki/Libraries_and_tools
08:09:01 <lambdabot> Title: Libraries and tools - HaskellWiki
08:09:05 <bakert> > let x = undefined in if x == undefined then putStrLn "hi" else putStrLn "bye"
08:09:06 <lambdabot>  Add a type signature
08:09:13 <malebria> The link: Creating a .deb from a Haskell Cabal package is broken.
08:09:40 <Botje> :t undefined
08:09:42 <lambdabot> forall a. a
08:10:28 <xerox> bakert: no way - http://www.haskell.org/onlinereport/exps.html#sect3.1
08:10:29 <lambdabot> Title: The Haskell 98 Report: Expressions
08:10:57 <bakert> xerox, yeah i thought it was like that.  i'll use a Maybe
08:11:00 <bakert> thanks
08:11:07 <xerox> You're welcome.
08:24:08 <bakert> ?hoogle liftIO
08:24:09 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
08:31:44 <Terabyte> hey, anyone know how to (recursivly) return a powerset? of a list say [a] -> [[a]]
08:32:39 <twanvl> > filterM (const [False,True]) [1,2,3]
08:32:41 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:32:49 <bakert> ?pl (\acc r -> acc ++ show r)
08:32:49 <lambdabot> (. show) . (++)
08:33:01 <Terabyte> recursivly?
08:33:06 <Terabyte> powerSet::[a]->[[a]]
08:33:06 <Terabyte> powerSet[]=[[]]
08:33:06 <Terabyte> powerSet(x:xs)=...
08:33:30 <Saizan> > let pow [] = [[]]; pow (x:xs) = map (x:) (pow xs) in pow [1..3]
08:33:31 <lambdabot>  [[1,2,3]]
08:33:46 <bakert> There's a functional version in the comments on http://bluebones.net/2005/08/all-possible-subsets/
08:33:51 <lambdabot> Title: bluebones.net » All Possible Subsets
08:33:54 <Terabyte> cool
08:34:38 <Saizan> > let pow [] = [[]]; pow (x:xs) = let xs' = (pow xs) in map (x:) xs' ++ xs' in pow [1..3] --better
08:34:39 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:35:18 <bakert> ?pl \x -> putStrLn $ fullReport $ catMaybes x
08:35:18 <lambdabot> putStrLn . fullReport . catMaybes
08:35:51 <glguy> > let powerset = filterM (\_->[False ..]) in powerset [1,2,3]
08:35:53 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:35:54 <Terabyte> thanks
08:36:37 <Saizan> ?type \f -> filterM f []
08:36:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> m [a]
08:37:05 <bakert> How can I do more than one thing on the leaf of a case statement?
08:37:21 <xerox> glguy: crazy.
08:37:31 <glguy> > let powerset xs = [] : [x : y | (x:ys) <- tails xs, y <- powerset ys] in powerset [1..3]
08:37:33 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
08:37:47 <Saizan> bakert: are you in a monad?
08:37:47 <glguy> (because ++ should be saved for later ;) )
08:38:11 <xerox> ?src filterM
08:38:12 <lambdabot> Source not found. Take a stress pill and think things over.
08:38:15 <xerox> ?src [] filterM
08:38:16 <lambdabot> Source not found. Take a stress pill and think things over.
08:38:32 * xerox takes a stress pill and thinks things over.
08:38:32 <bakert> Saizan, i worked it out ... i needed another do block.  so yes being in a monad was the issue i think.
08:38:36 <resiak> > take 5 [False..]
08:38:36 <lambdabot>  Parse error
08:38:51 <resiak> > take 5 [False ..]
08:38:53 <lambdabot>  [False,True]
08:38:59 <resiak> Huh!
08:39:07 <bakert> resiak, odd.
08:39:27 <resiak> oh, that makes sense
08:39:43 <paolino> If I want to catch the Nothing from readline function and jump out inside the main actions ,what should I use ?
08:39:45 <xerox> > enumFrom False
08:39:46 <lambdabot>  [False,True]
08:40:06 <paolino> > take 5 (repeat False)
08:40:08 <lambdabot>  [False,False,False,False,False]
08:40:19 <glguy> the reason that filterM (\_ -> [False ..]) works?
08:40:30 <glguy> > replicateM 3 [False,True]
08:40:32 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
08:40:49 <xerox> Auhm.
08:40:53 <Saizan> omg
08:40:57 <resiak> What!
08:41:11 <xerox> :t replicateM
08:41:13 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
08:41:57 <glguy> > map (zipWith (\y x-> if x then [y] else []) [1..3]) (replicateM 3 [False,True])
08:41:58 <lambdabot>  [[[],[],[]],[[],[],[3]],[[],[2],[]],[[],[2],[3]],[[1],[],[]],[[1],[],[3]],[[...
08:42:04 <glguy> > map (concat . zipWith (\y x-> if x then [y] else []) [1..3]) (replicateM 3 [False,True])
08:42:06 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:42:07 <Syzygy-> > tails [1,2,3]
08:42:08 <lambdabot>  [[1,2,3],[2,3],[3],[]]
08:42:25 <glguy> (my pokemans, let me show you them!)
08:43:03 <dcoutts_> so, xerox, how much free time do you get these days? :-)
08:43:14 <dcoutts_> want to update the cairo bindings? ;-)
08:44:40 <glguy> > map concat $ mapM (([]:).(:[]).(:[])) [1..3]
08:44:42 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:45:30 <glguy> > map (([]:).(:[]).(:[])) [1..3] -- step 1
08:45:32 <lambdabot>  [[[],[1]],[[],[2]],[[],[3]]]
08:45:42 <glguy> > sequence $ map (([]:).(:[]).(:[])) [1..3] -- step 2
08:45:43 <lambdabot>  [[[],[],[]],[[],[],[3]],[[],[2],[]],[[],[2],[3]],[[1],[],[]],[[1],[],[3]],[[...
08:45:55 <glguy> > map concat $ sequence $ map (([]:).(:[]).(:[])) [1..3] -- step 3 :-D
08:45:57 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
08:47:06 <Saizan> sequence computes the cartesian product?
08:47:23 <glguy> in the list monad
08:47:34 <xerox> dcoutts_ first exam tomorrow, then other two this week, and finally the new lectures will start
08:47:36 <Saizan> yeah
08:47:54 <dcoutts_> xerox, oh, good luck!
08:47:55 <sjanssen> > filterM (const [True, False]) [1..3]
08:47:57 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:48:10 <xerox> dcoutts_ well, actually second, I've passed one, but it was just the afternoon lab :)
08:48:16 <xerox> dcoutts_ thanks! :)
08:48:48 <glguy> sjanssen: were you the one that mentioned wanting ot see the ruby response to having a nightmare type system?
08:49:01 <sjanssen> glguy: oh yes
08:49:13 <xerox> glguy: thanks for the explanation.
08:49:16 <glguy> sjanssen: they didn't come up with one argument that we didn't laugh about in here before hand
08:49:21 <glguy> http://programming.reddit.com/info/11kvs/comments/c11n2o?context=5
08:49:24 <lambdabot> Title: Monads in Ruby (reddit.com), http://tinyurl.com/28ecln
08:49:52 <glguy> Dons called the adhoc lousy type system via unit tests, and I called exporatory programmnig
08:50:05 <sjanssen> that is creepy
08:50:19 <glguy> maybe... ruby programmers are lurking in the channel right now!
08:50:31 <glguy> trying to subvert the revolution!
08:50:45 * glguy proposes an inquisition
08:51:06 * sjanssen begins work on @prove-loyalty
08:51:20 <paolino> http://catenova.org/~paolino/school/school.hs
08:51:21 <paolino> I want to match the Nothing from readline in readLine and jump back in main after the evalState
08:52:49 <sjanssen> I think static typing helps with exploratory programming
08:53:18 <glguy> why would you want to know where you've been if you don't know where you are going :-p
08:53:50 <sjanssen> dons had a good anecdote the other day, about adding gzip support to hpaste
08:54:53 <apfelmus> glguy: galileoguy, your are accused to be a heretic, because you know about ruby. concede that the world is strongly typed!
08:54:54 <lambdabot> apfelmus: You have 1 new message. '/msg lambdabot @messages' to read it.
08:55:43 <sjanssen> it would be pretty easy to forget to gzip or ungzip a paste somewhere along the line, so he introduced newtype Gzipped = Gzipped ByteString.  This way the program wouldn't compile until it was correct
08:56:00 <glguy> sjanssen: that's no way to make money
08:56:44 <apfelmus> (glguy: so much for inquisition :)
08:56:47 <glguy> apfelmus: every great military leader will tell you that you must no your enemy :)
08:56:51 <glguy> know*
08:57:18 <apfelmus> i don't know whether the pope is a great military leader
08:57:20 <glguy> If I'm going to mock my Ruby programming friends, I need to know where they are vulnerable :)
08:57:45 <glguy> apfelmus: You don't give him enough credit
08:58:05 <JKnecht> Sun Tzu said the 1st thing was "The Moral Law" (of five things a great general needs).
08:58:56 <apfelmus> glguy: mh. credit as in coin or as in reputation?
08:59:41 <glguy> I'm guessing both :-p
09:00:02 <apfelmus> :)
09:03:45 <glguy> malebria: you about?
09:03:48 <glguy> ?seen malebria
09:03:49 <lambdabot> malebria is in #darcs and #haskell. I last heard malebria speak 54m 36s ago.
09:06:14 <Saizan> so filterM (const [False ..])  is like building an entire "tree of decision" and reporting the "leafs"?
09:06:36 <malebria> glguy: I'm here.
09:07:09 <paolino> anyone has a hint for my code , please ?
09:07:13 <bd_> :t filterM
09:07:14 <glguy> did you figure out why your type Point = forall a. Fractional a => (a, a) didn't work
09:07:15 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:07:29 <glguy> Saizan: yeah
09:07:30 <bd_> filterM :: (a -> m Bool) -> m [a] -> m [a] ?
09:07:35 <bd_> aha
09:07:37 <bd_> close
09:07:39 <bd_> hmm, tricky :)
09:08:07 <glguy> Saizan: a tree of dicisions not influence by the input (const)
09:08:22 <malebria> glguy: I got to the point that f :: forall a. Fractional a => IO (a, a) works, but f' :: IO (forall a. Fractional a => (a, a)) don't.
09:08:41 <bd_> but I don't think filterM (const [False..]) is typed right? Since we have a reader monad for some a, so the argument to filter needs to be (a -> b -> Bool)...? Or am I missing something?
09:08:44 <glguy> malebria: and you understand why those are different
09:08:55 <bd_> oh wait, not reader, list monad...
09:08:58 <glguy> bd_: what
09:09:02 <glguy> yeah, list monad
09:09:41 <dcoutts_> malebria, did you fix that c2hs problem? if not, paste your .chs file as an annotation
09:10:22 <dcoutts_> malebria, actually, did you try just adding "." to the include-dirs: ?
09:10:37 <dcoutts_> since it's not on the search path by default, unless you specify it
09:11:10 <dcoutts_> however, then you have a problem, since those files need installing
09:11:25 <malebria> dcoutts_: which problem?
09:11:30 <malebria> dcoutts_: I got so many problems..
09:11:43 <malebria> dcoutts_: Adding . to include-dirs worked.
09:11:51 <dcoutts_> ok
09:12:00 <malebria> glguy: no.. =(
09:12:11 <dcoutts_> malebria, so, you'll have to install that Gpc.h
09:12:26 <malebria> dcoutts_: is there a way to do this with Cabal?
09:12:38 <glguy> malebria: you don't want to put the forall in your type synonyms
09:12:44 <dcoutts_> malebria, yeah, though I don't remember the exact name of the field
09:12:49 <malebria> marcot@quindinho:~/codigo/haskell/hgpc/hgpc$ cat Algebra/Geometric/Gpc.h
09:12:49 <malebria> #include <gpcl/gpc.h>
09:12:58 <malebria> dcoutts_: can't I just not use Gpc.h?
09:12:59 <glguy> malebria: forall takes on a different meaning when nested inside the type declaration like that
09:13:21 <malebria> glguy: yes, but without forall in the type synonym the result is the same.
09:13:28 <syntaxfree> glguy: I chimed in in that thread.
09:13:34 <malebria> glguy: I think when you define a type synonym the forall is implicit.
09:13:42 <glguy> malebria: nope
09:13:56 <glguy> malebria: it's not forall, its the specifically chosen one
09:13:57 <dcoutts_> malebria, ah, ok. I see the problem.
09:14:03 <malebria> dcoutts_: have you seen the other problem? That the .chi .h files are not being clean?
09:14:12 <malebria> glguy: hum..
09:14:14 <dcoutts_> malebria, cabal's c2hs support sucks.
09:14:16 <glguy> type Point a = (a,a) -- you pick a type "a"
09:14:27 <dcoutts_> malebria, it's on my todo list, but not very near the top.
09:14:28 <glguy> now, Point "that type" = (that type, that type)
09:14:35 <malebria> dcoutts_: Why does c2hs generate Gpc.h?
09:14:45 <malebria> dcoutts_: a #include in the .hs file wouldn't be enough?
09:14:51 <dcoutts_> malebria, yeah, I know.
09:15:02 <dcoutts_> malebria, I have that problem too
09:15:17 <malebria> dcoutts_: the clean one, or the pointless .h file?
09:15:42 <dcoutts_> malebria, it's because c2hs allows you to include other stuff in the .chs file and that get's included into the .h file. But most of the time it ends up with just that one thing in it.
09:15:56 <dcoutts_> malebria, gtk2hs's fork of c2hs works differently.
09:16:08 <glguy> malebria: you are getting into *arbitrary-rank polymorphism" http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#universal-quantification
09:16:11 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
09:16:13 <dcoutts_> and cabal doesn't cope well with the .h files produced by c2hs
09:16:30 <dcoutts_> I intend to make c2hs not make those .h files when they turn out to be trivial.
09:16:45 <dcoutts_> but in the mean time, hmmm... what's the easiest fix...
09:17:03 <malebria> glguy: I'll take a look.
09:17:32 <glguy> malebria: (and it isn't appropriate in this case, you are simply stumbling into it)
09:17:36 <malebria> dcoutts_: Maybe I should just edit the .hs file by hand.
09:17:42 <dcoutts_> malebria, noooo!
09:18:03 <dcoutts_> malebria, ok, try this: add -I. into the ghc-options: and take "." out of include-dirs:
09:18:20 <malebria> dcoutts_: but even with more includes on the .h file, wouldn't it be simpler to have them in the foreign calls?
09:18:35 <Saizan> glguy: so there's no way to restrict the type a to a specific class without this?
09:18:38 <dcoutts_> malebria, and while you're at it, remove /usr/include, /usr/local/include and /usr/lib, /usr/local/lib from include-dirs: and extra-lib-dirs:
09:18:47 <malebria> dcoutts_: ok.
09:19:09 <glguy> Saizan: type synonyms can't be restricted to a certain typeclass liek that , no
09:19:45 <glguy> Saizan: to do stuff like that you need to use the GHC type extension in HEAD
09:19:48 <malebria> dcoutts_: what's the difference between -I. and include-dirs: . ?
09:20:07 <syntaxfree> since we're discussing types, may I once again ask what the hell are existential types? I can't grok any of the existing material.
09:21:14 <malebria> dcoutts_: with both options I compile ok, then install, but when I run ghci -package hgpc-0.0.1 I got:
09:21:23 <malebria> dcoutts_: ghc-6.6: /usr/local/lib/hgpc-0.0.1/ghc-6.6/HShgpc-0.0.1.o: unknown symbol `gpc_polygon_clip'
09:21:26 <malebria> Loading package hgpc-0.0.1 ... linking ... ghc-6.6: unable to load package `hgpc-0.0.1'
09:21:49 <paolino> :t callCC
09:21:50 <lambdabot> forall (m :: * -> *) a b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:22:03 <dcoutts_> malebria, it's a hack, the problem with including . in include-dirs: is that it'll add '.' to the search path of all programs/packages that use your package. That would be bad. We want dependent packages to just look for gpcl/gpc.h on the standard search path. By using ghc-options: -I. it only adds the search path when compiling this package, not for dependent packages.
09:22:15 <dcoutts_> malebria, that's a different linking error
09:22:41 <dcoutts_> malebria, have you got the lib name right? "libgpcl"? are you sure it shouldn't be just "gpcl"?
09:22:53 <glguy> paolino: what is your problem you were trying to solve/
09:23:18 <malebria> dcoutts_: yes, that's the problem.
09:23:23 <malebria> dcoutts_: it's gpcl.
09:23:28 <dcoutts_> malebria, if when you link it with an ordinary C program you would say "gcc -lgpcl" then you want to use "gpcl" as the lib name
09:23:46 <dcoutts_> malebria, the system linker then looks for libgpcl.a or .so
09:24:02 <malebria> dcoutts_: yes, now it's working.
09:24:07 <dcoutts_> great
09:24:14 <malebria> dcoutts_: do you know a hack for that clean problem?
09:24:19 <dcoutts_> no
09:24:23 <dcoutts_> cabal just needs fixing
09:24:29 <malebria> hum..
09:24:40 <malebria> dcoutts_: so now it's installing Gpc.h?
09:24:47 <dcoutts_> malebria, no it doesn't.
09:24:59 <dcoutts_> but that's ok since it was never really needed in the first place
09:25:13 <bd_> hmm, is there a beginner's introduction to Data.Generics somewhere?
09:25:21 <glguy> paolino: type your code in
09:25:22 <glguy> !paste
09:25:23 <hpaste> Haskell paste bin: http://hpaste.org/
09:25:35 <glguy> and I'll try to straighten it out for you... just the function you were dealing with
09:25:42 <bd_> I've got a large number of tiny transformations to do on a number of tree-ish structures, and that boilerplate is starting to get on my nerves... :)
09:26:15 <malebria> dcoutts_: good then. Thanks a lot for the help.
09:26:18 <dcoutts_> bd_, I think one of the SYB papers is quite readable.
09:26:20 <dcoutts_> malebria, np
09:26:46 <dcoutts_> malebria, some day cabal+c2hs will work nicely, because I'll need it to be able cabalise gtk2hs
09:26:52 <bd_> the tldi03 paper?
09:27:01 <dcoutts_> bd_, sorry, I don't know which
09:27:21 <bd_> dcoutts_: I guess I'll just read them all until it makes sense... :)
09:27:30 <dcoutts_> heh :-)
09:27:47 <glguy> bd_: if you are dealing with trees, you should try ndm's Data.Play
09:28:07 <malebria> dcoutts_: sure.. I'd be good to can use just cabal and nothing else.
09:29:42 <dcoutts_> malebria, yeah, the other major issue with cabal+c2hs at the moment is that c2hs allows {# import Foo.Bar #} and gtk2hs uses that quite extensively, however that requires a dep analysis to call c2hs in the right order, since it has to generate these .chi files (much like ordinary .hi files)
09:29:43 <Saizan> syntaxfree: existential types are very similar to subtype polimorfism where you use the typeclass as a type and you forgot the "real" type of the values
09:30:08 <dcoutts_> malebria, however, cabal does no dep analysis at all and just calls c2hs on the .chs files in any old order.
09:30:27 <dcoutts_> which is only ok if you never use c2hs's {# import #} hooks;
09:30:35 <michaelw> um, is the "Stretching the storage manager" paper the most recent on the subject?
09:30:49 <malebria> hum..
09:31:17 <glguy> @get-shapr
09:31:17 <lambdabot> shapr!!
09:31:36 <Cale> hmm, maybe OI doesn't break referential transparency, it's just horribly horribly inefficient.
09:32:24 <ski> Cale : hm ?
09:32:34 <chessguy> ?seen glguy
09:32:34 <lambdabot> glguy is in #haskell. I last heard glguy speak 1m 18s ago.
09:32:54 <chessguy> hey glguy, i had an idea for a new feature for hpaste
09:32:54 <glguy> ?
09:33:12 <chessguy> web access to GHC
09:33:13 <apfelmus> Cale: i don't whether OI breaks referential transparency, but i think it duplicates the world
09:33:19 <Cale> apfelmus: yes
09:33:25 <ski> apfelmus : pong
09:33:38 <Cale> It just allows arbitrary duplication of the world.
09:33:41 <apfelmus> ski: baldur's gate 2
09:33:45 <malebria> dcoutts_: I'll put your name in thanks in the changelog file.
09:33:48 <syntaxfree> Saizan:  thanks!
09:33:51 <ski> apfelmus : yes ?
09:33:57 <Cale> Which of course is going to be odd :)
09:33:58 <apfelmus> ski: (as opposed to pong :)
09:34:08 <syntaxfree> o boy, the referential transparency of OI is still an open problem?
09:34:14 <ski> (apfelmus : you pinged me a couple of days ago ..)
09:34:39 <chessguy> glguy, you'd have to run the code through some kind of pre-processing script to make sure it's not doing some kind of system 'rm -r -f'
09:34:47 <chessguy> but it would be usefl
09:34:51 <chessguy> *useful
09:35:04 * ski suspects rendering I/O effects as a comonad is not doable .. at least not in haskell ..
09:35:04 <apfelmus> ski: ah yes. i wanted to know what your adventure game was about. the example i currently can think is just plain boring as a game
09:35:13 <xerox> Cale: does that come from cobind's type?
09:35:24 <Cale> I think it's doable, just totally impractical.
09:35:27 <ski> apfelmus : oh .. just a simple course laboration
09:35:41 <glguy> chessguy: I probably won't be running arbitrary code, especially not arbitrary IO code (and ther eis already an online lambdabot interface)
09:35:54 <Cale> It comes from the fact that if you have a function of type OI X -> Y, then it might duplicate its parameter.
09:35:55 <ski> (Cale : unique objects shouldn't need to be copied ..)
09:36:07 <apfelmus> ski: take this and put it there?
09:36:17 <chessguy> glguy, right, i'm talking about non-oneliners
09:36:36 <glguy> ?version
09:36:37 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
09:36:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:36:43 <dancor> what are comonads good for
09:36:44 <Cale> For instance, you might have to duplicate stdout, and allow for nondeterministic program output.
09:36:45 <glguy> chessguy: hs-plugins doesn't run on 6.6
09:37:10 <glguy> chessguy:
09:37:14 <Cale> dancor: so far the most useful comonads have a sort of convolution-type feel to them
09:37:17 <glguy> but I could just link to are comonads good for
09:37:18 <glguy> 11:32  Cale> For inst
09:37:22 <dancor> can monads be constructed completely in haskell
09:37:22 <glguy> http://lambdabot.codersbase.com/
09:37:24 <ski> apfelmus : yes .. (plus an unidirectional passage)
09:37:24 <lambdabot> Title: Lambdabot Web Interface
09:37:28 <Cale> dancor: absolutely
09:37:33 <dancor> could i make MyMonad without using Monad?
09:37:40 <Cale> oh, yeah
09:37:47 <Cale> Monad is just an ordinary typeclass
09:37:59 <dancor> and >> and stuff are normal too
09:38:02 <Cale> Well, do-notation is tacked on to that.
09:38:05 <dancor> right
09:38:10 <Cale> But otherwise it's perfectly ordinary
09:38:25 <dancor> so is there an od notation for comonads
09:38:35 <chessguy> glguy, that doesn't help for code that's more than a single line, unless i'm missing something
09:38:41 <Cale> good question, I don't know if there's anything natural in that regard
09:38:50 <Cale> (but certainly nothing implemented)
09:38:59 <glguy> chessguy: well, it's a moot point, hs-plugins doesn't run on 6.6
09:39:10 <dancor> so comonads always do out << (i guess?) and stuff
09:39:25 <chessguy> i'm not sure what hs-plugins does
09:39:42 <glguy> > "lets lambdabot evaluate haskell code at runtime"
09:39:43 <lambdabot>  "lets lambdabot evaluate haskell code at runtime"
09:40:08 <chessguy> oh, i was thinking of a more direct link to GHC
09:40:10 <dcoutts_> syntaxfree, btw, I fixed zlib so it should work on your box
09:40:18 <glguy> chessguy: not a chance in hell :)
09:40:34 <Cale> dancor: well, you're writing things directly in terms of the combinators anyway
09:40:37 <chessguy> glguy, surely with a pre-processing script you could do it safely
09:40:53 <Cale> dancor: we don't have enough really good examples of comonads to know what would be a really effective notation
09:40:55 <syntaxfree> dcoutts: oh! Will try later.
09:41:07 <xerox> chessguy: and then dons would have no phd thesis!
09:41:08 * syntaxfree hopes to get better when he starts taking the meds.
09:41:08 <dcoutts_> syntaxfree, you need the latest darcs version of course
09:41:14 <Cale> You can get nice dataflow effects using comonads though.
09:41:22 <Cale> So that might be one source of inspiration
09:41:31 <glguy> chessguy: What would you expect this script to do exactly ?
09:41:32 <chessguy> xerox, i didn't know he had chosen a topic for his thesis yet
09:41:40 <chessguy> glguy, the preprocessing script?
09:41:42 <glguy> anticipate every nasty thing someone could try to do?
09:41:44 <glguy> and stop it?
09:41:46 <apfelmus> ski: ah, unidirectional is good idea. very mean, mhehe
09:41:49 <dcoutts_> malebria, sure
09:42:05 <dcoutts_> malebria, (this nick isn't registered so I can't PM you)
09:42:09 <glguy> naw, if someone wants to compile code, they can do it locally
09:42:25 <chessguy> glguy, hmm, i'd think blocking any interaction with the file system would be enough
09:42:39 <ski> apfelmus : well .. if you jump down a slippery hole, it's a little hard to climb up again :)
09:42:58 <chessguy> i don't have GHC here at work, and it would be cool to be able to code when i'm sitting here bored :)
09:43:10 <apfelmus> ski: unless your graph has a cycle. which it doesn't, whahaha :)
09:43:12 <malebria> dcoutts_: ok!
09:43:17 <xerox> ?where lambdaweb
09:43:17 <lambdabot> http://lambdabot.codersbase.com
09:43:20 <bakert> How do I convert a double to a string rounded to 2 decimal places?
09:43:28 <huschi> bringert: i think i found the bug concerning the cgis.
09:43:35 <chessguy> xerox, that doesn't help for code that's not a single line
09:43:37 <dcoutts_> bakert, use one of the functions from the Numeric module
09:43:45 <chessguy> (AFAIK)
09:43:49 <apfelmus> Cale: i was thinking about giving System.Random a comonadic interface
09:43:52 <dancor> Cale: so is it not the case that anything done with a monad can be done with a comand?
09:43:55 <bakert> dcoutts_, thanks i was off in Text.Printf and getting confused.
09:44:00 <bringert> huschi: what is it?
09:44:00 <dcoutts_> @hoogle showFFloat
09:44:01 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
09:44:06 <ski> (apfelmus : i wonder whether it would be possible to keep track of cycles anyway (without global state) ...)
09:44:06 <int-e> > printf "%.2f" (1.0 :: Double) :: String
09:44:08 <lambdabot>  "1.00"
09:44:11 <dancor> Cale: i can't really understand the 'problem' at http://haskell.org/pipermail/haskell-cafe/2003-January/003794.html
09:44:13 <lambdabot> Title: comonads, io, http://tinyurl.com/yoy8a4
09:44:18 <xerox> chessguy: somebody should implement a ?load-hpaste <n>.
09:44:20 <bd_> With Data.Generics is it possible to traverse a parametric type, transforming it into a new parametric type with a different parameter?
09:44:23 <huschi> bringert: ThreadId 9: Running CGI program: www/hello.cgi in www/
09:44:26 <dcoutts_> > Numeric.showFFloat (Just 3) pi ""
09:44:27 <ski> (i have an idea, that might work)
09:44:27 <lambdabot>  "3.142"
09:44:34 <huschi> bringert: that wont work i think.
09:44:44 <chessguy> xerox, hmm. that would @let the functions in the hpaste?
09:44:47 <Cale> dancor: a and b both have type Char
09:44:58 <xerox> right.
09:44:59 <michaelw> is the ghc-bugs list open only for subscribers?
09:45:04 <Cale> dancor: they're also obviously equal, because they're the same thing
09:45:10 <huschi> bringert: there are 2 possible solutions.
09:45:18 <chessguy> xerox, that's a nice idea
09:45:20 <bringert> huschi: why doesn't it work?
09:45:21 <dcoutts_> michaelw, I wouldn't have thought so, that'd make it hard to report bugs :-)
09:45:32 <Cale> (in particular, they're both equal to coeval (w .>> () =>> stdGetChar))
09:45:49 <Cale> So they ought to be the same Char
09:45:55 <huschi> bringert: www is used as working dir and hello.cgi should be executed in this dir.
09:45:58 <Cale> however, this means one of two things
09:46:06 <malebria> dcoutts_: When I run ghci -package hgpc-0.0.1 it works fine, but when I do :module + Algebra.Geometric.Gpc it sais:
09:46:09 <apfelmus> ski: yes, you can keep track of cycles. but you have to use a spanning tree and in the end, it doesn't feel very different from putting things into a Data.Map and tracking the current position with a room id
09:46:16 <malebria> module main:Algebra.Geometric.Gpc is not loaded
09:46:17 <Cale> either referential transparency is broken, and the effect of getting a character from the user is repeated
09:46:21 <huschi> bringert: but this tries to call www/hello.cgi in www, that means www/www/hello.cgi
09:46:21 <xerox> chessguy: hpaste (like lisppasted) can output the raw text, which \bot can fetch va the embedded http module.
09:46:28 <ski> apfelmus : mhm .. ok
09:46:31 <Cale> or the world context has been duplicated
09:46:36 <bringert> huschi: ah, that doesn't seem right
09:46:42 <chessguy> xerox, yes
09:46:50 <huschi> bringert: i tried it with a smaller example.
09:46:57 <bringert> huschi: I probably only tested with CGIs in the server root
09:46:57 <Cale> That is, w is something which remembers everything that the user eventually types.
09:46:58 <Saizan> xerox: @let would easily become a mess, we need namespaces at least
09:47:00 <xerox> chessguy: then one appends it to the @let file, and it's done, I think.
09:47:08 <chessguy> xerox, unfortunately, i haven't had any success with hs-plugins on my local build of lambdabot
09:47:11 <Cale> and holds onto that forever, as long as it's in scope
09:47:13 <chessguy> (even with 6.4)
09:47:20 <huschi> bringert: that's very possible.
09:47:21 <Cale> dancor: does that make sense?
09:47:29 <xerox> Saizan: I thought about that, one could use the paste number as module name if you want
09:47:33 <bringert> huschi: it should use basename on path_prog before calling runInteractiveProcess
09:47:33 <huschi> bringert: there are 2 possible solutions.
09:47:42 <dcoutts_> malebria, so you built and registered the package using cabal right?
09:47:45 <huschi> bringert: ok, i will try.
09:47:46 <Cale> The e-mail seems to think that the first thing is true, but that's not actually what the paper suggests.
09:47:55 <malebria> dcoutts_: yes.
09:48:00 <bringert> huschi: what was your other solution?
09:48:06 <Cale> It seems more like the paper is suggesting that the I/O context is really duplicated and saved.
09:48:16 <huschi> bringert: ommiting the working dir.
09:48:28 <dcoutts_> malebria, paste the whole ghci command and session: http://hpaste.org/new
09:48:28 <huschi> bringert: using the server root as working dir.
09:48:29 <dancor> Cale: it makes some sense.  but is IO itself then a counterexample to the hypothesis that monads can always be interchanged for comonads
09:48:38 <huschi> huschi: but that's ugly.
09:48:40 <Cale> yes
09:48:42 <dancor> Cale: ok
09:48:50 <xerox> Saizan: actually if hpaste and lambdabot were more integrated, one could @module+49582, and have lambdabot load the actual file
09:48:50 <Cale> In fact, we shouldn't expect anything to be both.
09:48:56 <bringert> huschi: yeah, I think using the CGI dir is more appropriate
09:49:03 <ski> environment/reader is both
09:49:06 <Cale> It'll be extremely rare that something is both a monad and a comonad.
09:49:10 <huschi> bringert: i think so too.
09:49:10 <dancor> "The only problem with using comonads for effects in Haskell is that for ideal use, the top-level program would be different, cobinding an unspecified constant of type OI () with main, which itself would be of type OI () -> ().
09:49:14 <dancor> so is that a lie
09:49:19 <dancor> "the only problem"
09:49:23 <Cale> right
09:49:26 <dancor> ok
09:49:37 <bringert> huschi: the docs for runInteractiveProcess don't say if the program path is considered relative to the currect directory or the directory argument
09:49:41 <hpaste>  malebria pasted "GHCi session" at http://hpaste.org/176
09:49:46 <Cale> There's another massive problem of how programs might have to return an unordered set of stdouts.
09:50:07 <Cale> The current terminal technology just isn't up to that task :)
09:50:07 <hpaste>  michaelw pasted "Stretching the Storage manager a little too much..." at http://hpaste.org/177
09:50:19 <dancor> i'm not allowed to edit http://www.haskell.org/hawiki/CoMonad
09:50:20 <lambdabot> Title: CoMonad - The Haskell Wiki
09:50:26 <araujo> has anyone here tried Eiffel?
09:50:26 <dancor> but it seems like it should be changed
09:50:32 <huschi> bringert: i also was wondering. but playing a bit around showed it up.
09:50:33 <Cale> That'd be because you're not logged in.
09:50:34 <bringert> huschi: if you want to do a good deed, check which one it is, whether that is intentional, and submit a documentation patch
09:50:49 <Cale> Also it's on the old wiki, so if you're going to change it, delete it, and move it to the new one.
09:50:53 <bringert> huschi: ok, sounds like you did check which one it is already
09:51:02 <Cale> (with a link to the new one)
09:51:31 <dancor> This wiki is not enabled for mail processing.
09:51:32 <dancor> hm
09:51:35 <huschi> bringert: is there already a function basename defined in any module?
09:51:51 <dancor> everything about monads is hard, even editing them on the wiki :)
09:52:07 <bringert> huschi: no :-)
09:52:21 <huschi> bringert: i'll put it beneath dirname in Util.hs
09:52:22 <bringert> huschi: it should probably go in Util.hs, along with dirname
09:52:25 <bringert> :-)
09:52:26 <bringert> yes
09:52:50 <bringert> ideally, it should use System.FilePth, once that becomes more available
09:52:55 <bringert> FilePath
09:53:10 <huschi> bringert: that's a good idea.
09:55:35 <malebria> dcoutts_: have you seen the paste?
09:57:05 <dcoutts_> malebria, is it the same result if you start ghci without specifying -package hgpc?
09:57:29 <dcoutts_> the odd thing there is the "main:" prefix
09:57:50 <dcoutts_> malebria, what version of cabal have you got there?
09:58:06 <malebria> dcoutts_: same problem without the main: thing.
09:58:09 <malebria> sorry.
09:58:14 <malebria> Without -package
09:59:38 <dcoutts_> malebria, what does this report: ghc-pkg field hgpc exposed-modules
10:00:39 <huschi> bringert: i had to prefix the executable with "./" but now it works.
10:00:58 <malebria> dcoutts_: exposed-modules: Algebra.Geometric.Gpc
10:01:35 <dcoutts_> malebria, and what version of cabal are you using?
10:02:05 <dcoutts_> ghc-pkg list cabal
10:02:24 <bringert> huschi: that's odd, does runInteractiveProcess use the $PATH to find the program?
10:02:33 <bringert> anyway, ./ should do it
10:03:28 <huschi> bringert: the docs don't say anything about this fact.
10:03:36 <huschi> but i think so.
10:04:19 * glguy wonders how challenging it would be to implement django's template engine in TH
10:04:52 <bringert> huschi: if you make a haddock patch for System.Process, you may want to include that. Or you could ask on libraries@haskell.org if it's intended to work that way
10:04:56 <malebria> dcoutts_: this gives only /usr/lib/ghc-6.6/package.conf:
10:05:12 <dcoutts_> malebria, oops, ghc-pkg list Cabal
10:05:19 <dcoutts_> with a capital C
10:05:34 <malebria> dcoutts_: 1.1.6
10:05:57 <dcoutts_> malebria, well, I'm quite perplexed. I don't know what's wrong. Try someone else.
10:06:25 <malebria> dcoutts_: can I send you the package?
10:06:36 <dcoutts_> malebria, what error do you get if you start ghci and say  :b Algebra.Geometric.Gpc
10:07:14 <huschi> bringert: runInteractiveProcess with "date" as command shows up the date.
10:07:31 <huschi> so i think it uses PATH.
10:07:48 <malebria> dcoutts_: same thing.
10:08:13 <huschi> bringert: maybe it's better to prefix the executable with "./" otherwise it would probably possible to issue any command.
10:08:26 <bringert> huschi: yes, definitely
10:09:01 <bringert> huschi: to avoid any possibility of running something else, we should really use something that doesn't look in $PATH
10:09:14 <bringert> but I think runInteractiveProcess should be fixed
10:09:20 <dcoutts_> malebria, try doing runghc Setup.hs clean, and then when you do the build again, use the -v flag and check for the "-package-name" that cabal passes to ghc.
10:09:44 <huschi> bringert: and resetting the PATH would hide it from the cgi. this would make calling other programs from the cgi more difficult (i'm thinking of things like xsltproc).
10:09:58 <bringert> yeah, that wouldn't be correct
10:10:09 <bringert> I think ./ is ok for now
10:11:11 <malebria> dcoutts_: /usr/bin/ghc -package-name hgpc-0.0.1
10:11:17 <dcoutts_> malebria, you said you're loading "hgpc", but in that .cabal file you've set the name as "HaskellGPC" or is that just out of date? have you cleaned, configured, built, installed and registered since changing the name?
10:11:58 <dcoutts_> malebria, you see, it seems to be a mis-match in the package name
10:12:20 <dcoutts_> that's what the "main:" prefix is, that's the pseudo-name of the program's package
10:12:28 <malebria> dcoutts_: it's just out of date.
10:12:52 <dcoutts_> malebria, so you have completely cleaned and rebuilt since changing the name ?
10:12:55 <malebria> dcoutts_: can I send you a .tar.gz?
10:12:59 <malebria> dcoutts_: yes.
10:13:11 <dcoutts_> malebria, well, I can't promise that I have the time
10:13:19 <malebria> dcoutts_: ok..
10:13:43 <dcoutts_> malebria, I've got 5min, so if I find the problem in that time...
10:13:51 <dcoutts_> so sure, send it
10:14:06 <dcoutts_> or post it somewhere and I'll wget it
10:14:51 <malebria> dcoutts_: I send it via e-mail.
10:15:50 <huschi> bringert: i sent you the patch.
10:26:26 <bringert> huschi: thanks, pushed
10:27:07 <huschi> huschi: no problem. i wanted the server to get running so i gave my best...
10:28:20 <chessguy> does anyone know if http://www.aetion.com/jobs.html is still accurate? it mentions hiring people during 2005, but i'm curious whether they're still hiring
10:28:22 <lambdabot> Title: Aetion Technologies LLC - Jobs
10:31:54 <malebria> dcoutts_: did you received it?
10:33:50 <dcoutts_> malebria, I can't look at it 'til I get home
10:34:25 <malebria> dcoutts_: ok =D
10:36:32 <astrolabe> dcoutts: are you mr HOpenGL?
10:37:03 <dcoutts_> astrolabe, nope
10:37:20 <astrolabe> Ah :( wishful thinking
10:37:27 <dcoutts_> astrolabe, I do stuff with Gtk2Hs and OpenGL, but I'm not a GL expert
10:37:52 * dcoutts_ notes that Gtk2Hs + HOpenGL is a nice combo
10:38:05 <hpaste>  Marc Weber pasted "Why isn't a type synonym not equal to its representing type ?" at http://hpaste.org/178
10:38:06 <astrolabe> I'm a bit concerned that all the hopengl docs are a few years out of date.
10:38:29 <dcoutts_> astrolabe, I think HOpenGL has had a few updates recently
10:38:45 * astrolabe is interested that it goes with Gtk2Hs
10:38:55 <astrolabe> @where HOpenGL
10:38:55 <lambdabot> http://haskell.org/HOpenGL/
10:39:14 <dcoutts_> astrolabe, yep, OpenGL in a widget and then use the ordinary HOpenGL stuff with it
10:39:30 <dcoutts_> astrolabe, I used it on a FP practical course
10:39:31 <astrolabe> The last release is 09/09/03
10:39:37 <dcoutts_> na
10:39:54 <dcoutts_> that might have been the last stand alone release or something
10:40:01 <dcoutts_> it's been bundled with ghc for agess
10:40:05 <astrolabe> The last release on this page http://haskell.org/HOpenGL/releases.html
10:40:06 <lambdabot> Title: HOpenGL Releases
10:40:09 <dcoutts_> and it's now one of the extralibs packages
10:40:32 <dcoutts_> if it really was last released in '93 then there's no way it'd compile with ghc 6.6 :-)
10:40:33 <astrolabe> dcoutts_: what are extralibs?
10:40:53 <malebria> dcoutts_: Is gl good for 2d drawing?
10:40:55 <dcoutts_> astrolabe, they're the libs that used to come bundled with ghc but are now separate
10:40:56 <malebria> dcoutts_: or only for 3d?
10:41:03 <dcoutts_> malebria, I used it for both
10:41:12 <astrolabe> dcoutts: Cool!  How do I get them?
10:41:16 <dcoutts_> malebria, there are easier 2d apis than OpenGL, certainly
10:41:26 <dcoutts_> astrolabe, same place you got ghc from
10:41:56 <malebria> hum..
10:42:14 <dcoutts_> malebria, for 2D I'de use cairo for vector graphics, or something else for bitmap
10:42:33 <ToRA> astrolabe: if you want something that's a good introduction to the current opengl libraries in haskell; I found this tutorial v.v.v.good:
10:42:37 <ToRA> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
10:42:40 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
10:43:33 <malebria> dcoutts_: cairo is nice.
10:44:12 <astrolabe> Ah here http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
10:44:14 <lambdabot> http://tinyurl.com/337hg2
10:44:35 <astrolabe> Thanks dcoutts, ToRA.
10:44:54 <dcoutts_> astrolabe, yep, that's it, though as I say, there is even more recent stuff that's not released yet, pixel shaders etc
10:45:13 <hpaste>  michaelw annotated "Why isn't a type synonym not equal to its representing type ?" with "type synonym" at http://hpaste.org/178#a1
10:45:15 <astrolabe> dcoutts any chance of getting GTK2Hs into the extralibs?
10:45:43 <dcoutts_> astrolabe, there's no need, the "extralibs" are no different to the other non-core libs.
10:45:53 <dcoutts_> ie one installs them in the same way
10:46:07 <ToRA> dcoutts_: we're getting pixel shaders?
10:46:20 <dcoutts_> ToRA, apparently, according to the changelogs
10:46:36 <ToRA> dcoutts_: cool...where does one go to find out about these things?
10:47:03 <dcoutts_> ToRA, on the libraries commit mailing list
10:47:09 <astrolabe> dcoutts: so how do I install them then? In my experience, it is easier when they are bundled.
10:47:22 <ToRA> dcoutts_: ah cool, cheers
10:47:29 <dcoutts_> astrolabe, pretty much everything uses cabal now.
10:48:22 * astrolabe goes to make a sandwich
10:53:10 * xerox follows astrolabe 
10:54:42 * astrolabe investigates cabal
10:57:38 <Sinner> hello, i'm kinda new to Haskell, and I'm trying to write my first Haskell functions.
10:58:08 <Sinner> I've looked at some of the documentation on various functions, but I'm still confused on how they are used
10:58:21 <Sinner> example, how would I read text from a file?
10:58:46 <Sinner> I know it has to be within a Monad(IO) do structure, but that's about it
10:58:50 <astrolabe> Sinner: It would probably be easiest to start with a pure function and work up
10:58:52 <dcoutts_> in ghci: stuff <- readFile "blah.txt"
11:00:18 <Sinner> well I've gone through a tutorial that lead me through the basics, such as how to write a function to calculate any element or a list of elements of the fibonacci sequence
11:00:38 <astrolabe> Sinner: have you got any code working?
11:00:53 <Sinner> well again, only what the tutorial guided me through
11:01:11 <astrolabe> Sinner: yaht is very good
11:01:14 <astrolabe> @where yaht
11:01:15 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:01:27 <Sinner> thanks, i'll have a look
11:01:46 <astrolabe> Sinner: alternatively, feel free to ask here
11:02:37 <astrolabe> Although if you use IO, you'll be in a state of sin
11:06:59 <chessguy> isFoo? isn't a valid function name in haskell is it?
11:07:11 <glguy> nope
11:09:17 <Cale> http://programming.reddit.com/info/11o80/comments/c11prh?context=5
11:09:20 <lambdabot> Title: Codata and comonads in Haskell (pdf) (reddit.com), http://tinyurl.com/2ym66b
11:09:44 <dancor> can two modules import each other??
11:10:02 <glguy> short answer, no
11:10:04 <astrolabe> dancor:yes strictly
11:10:05 <glguy> long answer , yes
11:10:10 <astrolabe> heh
11:10:36 <astrolabe> there is a section in the ghc user manual called something like 'mutually recursive modules'
11:11:10 <dancor> i can have two modules import each other or use a typeclass as an interface to collect a bunch of fcn together
11:11:19 <mauke> > length "no" < length "yes"
11:11:21 <lambdabot>  True
11:11:29 <dancor> i guess i'll just use the typeclass
11:12:00 <sieni> Is there a use case for mutually recursive modules except for competing in the International Obfuscated Haskell Code Contest?
11:14:48 <apfelmus> sieni: you can do something about the expression problem.
11:15:49 <apfelmus> module Z defines the type Z = EIther A (Either B (Either C ())) where A,B,C are from corresponding modules.
11:16:11 <apfelmus> with recursion modules, A can use Z without knowing what B and C are
11:16:42 <apfelmus> but the functions of A actually work with Z
11:17:44 <apfelmus> be big advantage is that you can decide to remove B or C later, i.e. module A will still work with Z
11:23:37 <dancor> i'm trying to hook into an rpc library.  i've got Server.hs with some fcn MyFcn, and i have an auto-generated interface to that function   class Handler h where myFcn :: IO (String)  (if the return type in the rpc specification is String, say).
11:24:00 <dancor> i'm using IO bc the rpc spec doesn't let you specify if your fcn has side-effects
11:24:13 <dancor> (of cours, since it needs to plug into to other langs)
11:24:45 <dancor> and now i'm wondering if it should be more general somehow
11:25:17 <dancor> instead of deciding you wanted IO, maybe just Monad?
11:26:05 <dancor> i don't want to force ppl to use IO.  at first i thought i had to, to work with the general rpc framework
11:26:46 <Saizan> to do an rpc call you need IO anyway
11:27:03 <Saizan> an RPC monad maybe?
11:27:42 <dancor> Saizan: yeah the stuff calling the Handler fcn def has to be IO
11:28:40 <dancor> client calls fcn -> translated to request over network -> server recieves and calls its implementation of that fcn, return results which are translated back into native lang of client
11:29:24 <Saizan> this Handler is server side, right?
11:29:27 <dancor> but on the server side, the fcn itself
11:29:28 <dancor> yes
11:30:02 <dancor> i guess the rpc library calling the fcn will be IO so it can't do other things
11:30:09 <Saizan> mmh the funtion itself could be anything..
11:31:05 <Procyon_> can lambda's have where expressions?  I want to do a basic: \a->(if null l; then []; else head l; where l=getlistfrom a)
11:31:44 <Saizan> Procyon_: i'm not sure wbout where, but you can use let .. in
11:31:49 <glguy> Procyon_: \a -> let l = getlistfrom a in if null n then [] else head l
11:32:21 <dancor> i just realized that the rpc itself has Exceptions
11:32:34 <dancor> so i'll use like IOOrErr
11:32:42 <Procyon_> let it is then.  I couldn't get where to work and I wasn't sure if it isn't supported, or If I just am not getting the syntax right
11:32:44 <dancor> and translate the exception
11:32:51 <dancor> into an rpc one
11:32:55 <dancor> if one happens
11:33:02 <glguy> where works at the declaration level
11:33:09 <glguy> let ... in... creates an expression
11:33:34 <glguy> let a = b where b = c in a
11:34:29 <Procyon_> I see.  there is more differenciation than just syntax then.
11:35:14 <glguy> also, a where spans guards: let a | b = c | d = e where this = worksinalltheguards
11:35:37 <glguy> rather than: let a | b = let c = d in e
11:35:43 <malebria> @hoogle Maybe a -> Maybe a -> Maybe a
11:35:44 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
11:35:54 <glguy> malebria: mplus
11:36:02 <glguy> > Just 1 `mplus` Just 2
11:36:03 <lambdabot>  Just 1
11:36:06 <glguy> > Nothing `mplus` Just 2
11:36:08 <lambdabot>  Just 2
11:36:09 <glguy> > Nothing `mplus` Nothing
11:36:10 <lambdabot>  Add a type signature
11:36:15 <glguy> > Nothing `mplus` Nothing :: Maybe Int
11:36:15 <malebria> glguy: thanks..
11:36:16 <lambdabot>  Nothing
11:36:23 <malebria> glguy: that's just what I'm looking for.
11:36:29 <glguy> :)
11:36:36 <Procyon_> glguy: thanks also :)
11:37:04 <dancor> now i really have to decide how exceptions will work for this whole thing
11:37:15 <dancor> i'm feeling pretty good about IOOrErr
11:37:23 <dancor> as opposed to catchDyn
11:39:31 * shapr cackles happily
11:39:38 <glguy> shapr!
11:40:28 <shapr> glguy!
11:40:40 <chessguy> wow, aetion looks like it's doing some really cool stuff
11:40:44 <glguy> shapr, do you want to add my work SSH key for me? I left my personal laptop at home :'-(
11:40:56 <shapr> sure, no worries
11:40:58 <shapr> send it to me
11:42:02 <shapr> Wow, did you know that HaskellNet has code for both JSON and BEncode ?
11:42:16 <syntaxfree> @google haskellne
11:42:19 <lambdabot> http://haskell.org/hawiki/HaskellNewbie
11:42:19 <lambdabot> Title: HaskellNewbie - The Haskell Wiki
11:42:21 <syntaxfree> @google haskellnet
11:42:24 <shapr> @where haskellnet
11:42:25 <lambdabot> http://darcs.haskell.org/SoC/haskellnet/
11:42:25 <lambdabot> Title: Index of /SoC/haskellnet
11:42:25 <lambdabot> I know nothing about haskellnet.
11:42:46 <Syzygy-> @where+ haskellnet http://darcs.haskell.org/SoC/haskellnet/
11:42:47 <lambdabot> Done.
11:42:58 <Syzygy-> Would seem to be the obvious next step...
11:43:01 <shapr> truly
11:43:17 <Syzygy-> Gleh.
11:43:24 <Syzygy-> I'm starting to loathe scalar products.
11:43:34 <shapr> They're green and scalary?
11:43:43 <Syzygy-> Bashing my head against two exercises my advisor posed and I'm unable to solve. I'm supposed to handle them in class tomorrow. :(
11:43:55 <shapr> uh oh
11:44:05 <shapr> Syzygy-: The easy solution is to ask here on #haskell
11:44:21 <Syzygy-> I could use the #math's and spinoffs I frequent too... :P
11:44:22 <rohar> Anyone have an idea what sort of optimization Haskell does by default?
11:44:51 <syntaxfree> rohar:
11:44:54 <syntaxfree> @google haskell fusion
11:44:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
11:44:59 <Syzygy-> Suppose (,) and [,] are realvalued scalar products, and suppose (v,v)=[v,v] for all v in V. Show that the scalar products are identical.
11:45:03 <Syzygy-> And I'm stumped.
11:45:04 <Syzygy-> Completely.
11:45:11 <rohar> I guess the best way to put this is.. if I have a large data structure and I iterate it and change one element, and I really making an entirely new copy if the runtime can figure out that it is not aliased?
11:45:42 <syntaxfree> Syzygy-: have you tried to argue by contradiction?
11:45:57 <syntaxfree> it's usually the best way to handle that kind of problem.
11:46:27 <Syzygy-> Suppose (v,w)/=[v,w] and then use scalar product properties... Hmmmm...
11:47:29 <shapr> rohar: Hiya! I haven't talked to you for years.
11:48:35 <shapr> rohar: I don't think I've ever talked to you in real-time before, only on Ward's Wiki.
11:48:39 <Syzygy-> syntaxfree: Thanks. I'm getting mileage now.
11:48:56 <apfelmus> Syzygy-: what does (v,v) mean for the vector v?
11:48:59 <Syzygy-> Supposing that, then (v+w,v+w)-[v+w,v+w]/=0. Contradiction.
11:49:10 <Syzygy-> apfelmus: I started with (,) and [,] being two scalarproducts on V.
11:49:29 <shapr> rohar: Hi, I'm Shae Erisson
11:49:42 <apfelmus> i know, i wanted you to philosophy about it
11:49:57 <rohar> shapr: Hi
11:50:12 <apfelmus> Syzygy-: (in order to solve the problem)
11:50:28 <apfelmus> *philosophize
11:50:37 <syntaxfree> Syzygy: he might not be allowed to use norm properties.
11:50:56 <syntaxfree> hmm. Ward's Wiki.
11:51:04 <syntaxfree> rohar: how would you define an unit test?
11:51:11 <syntaxfree> I'm planning a rant on unit tests.
11:51:49 <apfelmus> Syzygy-: i mean there is geometrical property that (v,v) represents
11:53:24 <Procyon_> I'm trying to do a guarded car. in scheme, I could guard car by having it return #f or '() on an empty list.  I can guard division by having 0/0=0 (int->int->int still holds) is there any way to guard car in a typesafe manner so that [a]->a still holds, or is this unsolvable?
11:53:36 <apfelmus> Syzygy-: (ah you already solved it. sorry)
11:54:25 <shapr> rohar: If your large data structure is something like a large list, when you create a new large list that has only one new element, all the old elements are still there. The space used over your previous list is just enough space to hold a new list value and new pointers to the old elements, and space for the new element and a pointer to it.
11:54:27 <rahikkala> Procyon_: Maybe
11:55:00 <malebria> dcoutts_: hey, good news.
11:55:03 <rahikkala> Procyon_: (actually, I have no idea if that's the "right answer", I just liked the idea of an ambiguous one-word answer)
11:55:13 <malebria> dcoutts_: it's working with GHCi now.
11:55:24 <shapr> Procyon_: I think you could do that pretty easily in Epigram.
11:55:33 <malebria> dcoutts_: PolygonC *** glibc detected *** free(): invalid pointer: 0x00002b0f0d098158 ***
11:55:48 <malebria> It's a more atractive problem now.
11:55:54 <dcoutts_> malebria, oh good, what changed?
11:56:28 <malebria> dcoutts_: I'm not sure. =(
11:56:34 <malebria> dcoutts_: I think nothing.
11:56:59 <Syzygy-> I have one more bugging me. Suppose we have a scalar product (,) on C^2 given by ((z1,z2),(w1,w2))=z1 ~w1 - z1 ~w2 - z2 ~w1 + 2 z2 ~w2 (with ~ meaning conjugate)
11:57:03 <Syzygy-> Show that [2-2i,4i;1-2i,2i] is selfadjoint wrt this scalar product.
11:57:06 <Syzygy-> I.e., say that the matrix is the endomorphism F, then (Fu,v)=(u,Fv).
11:57:09 <Syzygy-> I end up with coefficients being wrong up to conjugacy. :(
11:57:14 <Procyon_> rahikkala: Maybe adds a whole layer of complexity.  I'm doing a genetic algorithm, so I *know* that I will generate bad car calls.  cdr can be easily guarder (cdr []=[]) but I think I'm going to have to propagate an error up my interpreter on a bad car application. :(  errors in the parse tree are ugly in GP.
11:58:09 <shapr> rohar: In OOP, identity is the 'primary' equality, but in pure FP you have only value equality. http://www.haskell.org/tmrwiki/FpVsOo
11:58:10 <lambdabot> Title: FpVsOo - TmrWiki
11:58:26 <apfelmus> Syzygy-: (Fu,v) = (u,F*v)
11:59:00 <shapr> rohar: Does that help any?
11:59:07 <apfelmus> Syzygy-: ah, sorry. i mean that F* = transpose + conjugate
12:00:41 <Syzygy-> apfelmus: And this holds regardless of my scalar product, right?
12:01:14 <Syzygy-> Gleh. I'm just going to skip that one, and poke my advisor about it afterwards for the sample solutions...
12:01:21 <apfelmus> Syzygy-: actually no, i'm mistaken again :)
12:01:30 <Syzygy-> Heh
12:01:33 <malebria> dcoutts_: now I got it.
12:02:00 <malebria> dcoutts_: nothing has change, but when I run ghci with a module loaded, it can load the library.
12:03:03 <malebria> dcoutts_: ok, this is getting strange.
12:03:07 <dcoutts_> sounds it
12:03:43 <apfelmus> Syzygy-: i mean you can just calculate (u,Fv) and (Fu,v) with u,v unit vectors. if all four things are equal, you're done. if not, you likely messed up with conjugation ~
12:04:03 <malebria> dcoutts_: the situation is the following: When I build and install, it gives that error message.
12:05:09 <Syzygy-> apfelmus: I did calculate with u,v kept symbolic. And things screwed up to a conjugate of what it should be. AND I've rechecked it 3-4 times.
12:05:28 <malebria> dcoutts_: then, if I load a module with :load that imports Algebra.Geometric.Gpc it works.
12:05:49 <shapr> hiya swiert!
12:05:49 <malebria> dcoutts_: and after that it starts to work just ghci :module + Algebra.Geometric.Gpc
12:05:56 <dcoutts_> wierd
12:05:59 <swiert> hi shapr.
12:06:09 <malebria> dcoutts_: the thing is I need to load a module that imports it before using :module +
12:06:14 <dcoutts_> hey swiert, any word on that book being delivered?
12:06:18 <Procyon_> rahikkala: Just found a reference by Montana.  He recommends propagating an error, or defining car seperately for each type, having a default value for each type.  He chooses errors.  He does not even mention Maybe (I think that would just add unneccissary complexity to the language).  I'll probably do defaults for each primitive type ('\0', 0, False, and \x->x) because I really don't want errors.
12:06:36 <swiert> dcoutts_: No - nothing yet.
12:06:51 <cjeris> Syzygy-: doesn't adjointness have an extra conjugation in it over C-vector spaces though?
12:06:53 <swiert> dcoutts_: I spoke to Graham and he had had similar problems.
12:07:06 <dcoutts_> swiert, I saw an advance copy briefly at POPL, they were doing advance orders
12:07:26 <swiert> Yeah - you can buy it from amazon.
12:07:26 <dcoutts_> only got 30sec to skim through
12:07:27 <Syzygy-> cjeris: That's not the way my advisor states it in his lecture notes. If it does, then I'm home free, and he screwed up. The other way around is, well, the other way around.
12:08:30 <Syzygy-> Ahhhhhhh! Wikipedia: selfadjoint, albeit very terse, seem to give us that extra conjugation.
12:09:10 <malebria> dcoutts_: any idea about what could be causing this?
12:09:24 <dcoutts_> malebria, no idea, sorry
12:09:42 <apfelmus> Syzygy-: does this change anything? i mean selfadjoint is F=F*, with (u,Fv) = (Fu,v)
12:09:52 <apfelmus> err (u,Fv) = (F*u,v)
12:10:29 <Dybber> Is there something like SML's "as" in Haskell?
12:12:07 <shapr> basht: Did you get the url I sent?
12:12:09 <Syzygy-> apfelmus: That changes everything.
12:12:27 <apfelmus> Syzygy-: why? your scalar product remains the same
12:15:32 <glguy> Dybber: f xxs@(x:xs) = x : xs ++ xxs
12:15:37 <glguy> Dybber: is that what you mean?
12:15:49 <Syzygy-> It ended up with cjeris being right: selfadjointness is (Fu,v)=(u,Fv) only for euclidean spaces. For unitary, we need to conjugate F on one side.
12:16:02 <xerox> join (
12:16:03 <Syzygy-> And this extra conjugation gives me just what I need to get things to work.
12:16:20 <xerox> join (++) -- I mean.
12:16:48 <glguy> xerox: how does that illustrate the "as" question?
12:16:59 <bd_> > join (++) "foo"
12:17:00 <lambdabot>  "foofoo"
12:17:32 <glguy> besides, join (++) is defined on the empty list, making it different than what I wrote
12:17:33 <Dybber> glguy, yes, thanks :)
12:17:37 <glguy> welcome :)
12:18:34 <apfelmus> Syzygy-: ? for the standard scalar product, you have F self-adjoint <=> F = (transpose . conjugate) F. but this is exactly the same as (Fu,v) = (u,Fv)
12:19:33 <Syzygy-> apfelmus: This isn't a standard scalar product.
12:19:36 <Syzygy-> We introduce a new one.
12:19:45 <malebria> dcoutts_: do you think I should ask somewhere about it?
12:19:47 <Syzygy-> The matrix given ISN'T self-adjoint for the standard scalar product.
12:19:52 <dcoutts_> malebria, try Igloo
12:20:07 <apfelmus> Syzygy-: yes, of course. but the condition (Fu,v) = (u,Fv) for self-adjointness remains
12:20:28 <Igloo> What's up?
12:20:35 <malebria> Igloo: hello.
12:20:37 <Syzygy-> apfelmus: That condition gives me precisely one conjugation too little. Or too much.
12:21:01 <malebria> Igloo: I've written a port for a C library using c2hs, and I'm using cabal.
12:21:11 <Syzygy-> And both the linear algebra textbook I could find here and wikipedia state something along the lines of that condition being true only for the euclidean, not for the unitary case.
12:21:30 <malebria> Igloo: when I build and install it, then run ghci :module + Algebra.Geometric.Gpc I got this error message:
12:22:10 <malebria> Igloo: module main:Algebra.Geometric.Gpc is not loaded
12:22:22 <dcoutts_> Igloo, the weird thing is the "main:" prefix, looks like the package name is messed up somewhere
12:22:42 <Igloo>  malebria Is this on the web somewhere?
12:22:48 <malebria> Igloo: then, when I :load a module that imports it
12:22:57 <paolino> is it possible to hide a continuation under ReaderT environment ?
12:23:01 <malebria> Igloo: it works fine after that, even in other ghci sessions.
12:23:15 <dcoutts_> malebria, email it to Igloo
12:23:21 * dcoutts_ -> home
12:23:26 <apfelmus> Syzygy-: ??
12:23:48 <malebria> Igloo: I'll upload it to sf.net
12:23:51 <Syzygy-> apfelmus: Anyway... I'm just teaching this crap. :(
12:23:57 <malebria> Igloo: but I can mail you, I think it'll be faster.
12:24:05 <Igloo> OK, igloo@earth.li
12:24:36 <apfelmus> Syzygy-: :)
12:24:43 * shapr boings furiously
12:24:49 <Nafai> Hey shapr
12:24:53 <kaol> careful, you'll hit the channel walls
12:26:16 <malebria> Igloo: sent.
12:26:46 <malebria> Igloo: are you the writer of that guide of packaging Cabal projects for debian?
12:27:00 <Igloo> which guide?
12:27:22 <malebria> Igloo: http://haskell.org/haskellwiki/Libraries_and_tools
12:27:24 <lambdabot> Title: Libraries and tools - HaskellWiki
12:27:28 <malebria> Igloo: this one linked here.
12:27:30 <shapr> Nafai: hiya
12:27:33 <malebria> Igloo: but the link is broken.
12:27:38 <Nafai> shapr: How's it?
12:27:41 * shapr bounces off the walls of the channel!
12:28:06 <Igloo> If you mean "Creating a .deb from a Haskell Cabal package" then no
12:28:07 <shapr> Nafai: I'm trying to figure out Sessions in HAppS. I'm getting somewhere, but it's frustrating when bits slip away and I have to refresh my understanding.
12:28:17 <Igloo> Pupeno is
12:28:18 <malebria> Igloo: yes, that's what I meant.
12:28:22 <Nafai> shapr: *nods*
12:28:33 <Nafai> shapr: I'd rather be doing that than banging my head against this Java problem :)
12:28:53 <shapr> Heh, I would ask you how code is treating you... but you just told me...
12:30:09 <Nafai> :)
12:31:51 <Vq^> shapr: hello bouncer :)
12:32:35 <shapr> hello Vq^!
12:34:38 <tibbe> good evening haskell
12:36:52 <chessguy> tibbe, salutations and other such pleasantries
12:37:15 <malebria> Igloo: have you seen the mail?
12:38:47 <Igloo> malebria: Got it
12:47:23 <Igloo> malebria: Hmm, not sure what's up
12:47:47 <malebria> Igloo: does it seems to be right to you?
12:48:19 <Igloo> At first look, yes. I'll try to look closer later.
12:48:36 <malebria> Igloo: ok, thanks a lot.
12:49:33 <glguy> > 1.1 + 0.1 == 1.2
12:49:34 <lambdabot>  False
12:50:05 <mauke> > (1.1 + 0.1) - 1.2
12:50:07 <lambdabot>  2.220446049250313e-16
12:50:13 <paolino> is there any way I can hide continuations inside monads ?
12:50:39 <glguy> paolino: that is what Cont and ContT do
12:51:40 <glguy> ?type (runContT, runCont)
12:51:42 <lambdabot> forall r (m :: * -> *) a r1 a1. (ContT r m a -> (a -> m r) -> m r, Cont r1 a1 -> (a1 -> r1) -> r1)
12:52:54 <glguy> paolino: your question borders on non-sensical (I think) , maybe elaborate some?
12:53:47 <paolino> readLine what cond exit = do
12:53:48 <paolino>   parse <- liftIO $ readline $ what ++ " ? "
12:53:48 <paolino>   case parse of
12:53:48 <paolino>     Just c -> if (null c) then readLine what cond
12:53:48 <paolino>                  else return $ read c
12:53:48 <paolino>     Nothing -> exit
12:54:23 <paolino> I want to hide exit
12:54:39 <shapr> @where gzip
12:54:40 <lambdabot> I know nothing about gzip.
12:54:48 <xerox> @where zlib
12:54:48 <shapr> @where Codec.Compression.GZip
12:54:49 <lambdabot> darcs get http://haskell.org/~duncan/zlib
12:54:49 <lambdabot> I know nothing about codec.compression.gzip.
12:54:51 <shapr> ah
12:54:52 <Igloo> shapr: What are you looking for?
12:55:03 <paolino> I tried with ReaderT
12:55:29 <glguy> paolino: what specifically do you want your function to do?
12:55:30 <shapr> Igloo: Codec.Compression.GZip... xerox pointed me in the right direction.
12:55:47 <shapr> This is a case where searchpath is nicer than cabal.
12:55:47 <xerox> dcoutts++
12:55:49 <glguy> paolino: and you can't using cond, what is it for
12:55:49 <huschi_> bringert: how can do a GROUP BY with haskelldb?
12:56:02 <bringert> huschi_: haskelldb does it automagically
12:56:14 <huschi_> bringert: wow. that's cool.
12:56:19 <paolino> I cut a little the code
12:56:27 <shapr> Is a Data.Map of ModuleName -> library already planned for cabal?
12:56:33 <paolino> cond can go away as it is
12:57:17 <bringert> shapr: there is also a pure haskell gunzip: http://urchin.earth.li/darcs/igloo/inflate/
12:57:19 <lambdabot> Title: Index of /darcs/igloo/inflate
12:57:32 <bringert> shapr: htar uses that
12:57:33 <gotaku> What are multi-parameter type classes and functional dependencies?
12:57:40 <glguy> paolino: you want to keep calling readline until they actually type something? and silently call a continuation if they don't?
12:57:43 <shapr> bringert: Thanks, I'll add that to my mental index :-)
12:58:16 <glguy> ?fptools Data.Char
12:58:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
12:58:19 <paolino> if they type Ctrl-D
12:58:24 <glguy> ?docs Data.Char
12:58:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
13:00:12 <paolino> so , whenever one hits ctrl-d inside readLine I close the run
13:00:26 <glguy> paolino: I don't see how you could to that silently
13:00:59 <glguy> why don't you want it to be clear what happens?
13:01:41 <gotaku> What are multi-parameter type classes and functional dependencies?
13:01:56 <glguy> type-system extensions
13:03:21 <gotaku> Yes, I know that part.
13:05:05 <paolino> glguy I'm trying to understand how to use ContT with the other transformers
13:05:29 <glguy> and it isn't type-checking?
13:05:49 <glguy> or you want me to show you that specific code?
13:05:49 <xerox> gotaku: MPTC are n-ary relations, functional dependencies make them functions.
13:07:03 <paolino> A working example will show me something
13:07:15 <glguy> ok
13:10:03 <gotaku> What's the difference between an Int and an Integer?
13:10:10 <glguy> Int has a maxBound
13:10:19 <glguy> and fits in the hardware's native int type
13:10:48 <gotaku> Ok, thanks.
13:11:03 <huschi_> bringert: but haskelldb has no having or am i wrong?
13:11:23 <bringert> huschi_: yes, no having
13:12:06 <huschi_> bringert: so i cannot do sth like: SELECT a FROM t GROUP BY b HAVING count(c)>1?
13:12:21 <huschi_> bringert: i have to use filter afterwards?
13:13:28 <bringert> huschi_: use where
13:13:34 <bringert> huschi_: i.e. restrict
13:13:45 <bringert> huschi_: haskelldb generates the right nested query for that
13:14:29 <huschi_> bringert: restrict (count (t ! C.location) .>. constant 1)
13:14:47 <huschi_> the type checker doesn't take that.
13:16:31 <bringert> huschi_: hmm, yes
13:16:47 <vincenz> bringert: mind if I pm you?
13:16:54 <bringert> huschi_: ok, do a projection to put the count itno some field, and the restrict on that
13:16:59 <bringert> vincenz: go ahead
13:17:33 <huschi_> how can i do that if my table has no int field?
13:18:08 <hpaste>  glguy pasted "ContT and IO" at http://hpaste.org/179
13:19:51 <xpika2> So a quy walks into a bar and asks for a spreadsheet. The bartender asks, "How do you want it?" The guy replies, "In binary--but put the ones first."
13:19:58 <xpika2> i dont get it
13:20:25 <glguy> paolino: did you get that link?
13:20:42 <huschi_> bringert: ok, i think i found it.
13:21:50 <paolino> thanks, I study it
13:21:58 <xpika2> @index rotate
13:21:58 <lambdabot> Data.Bits, Foreign, Graphics.Rendering.OpenGL.GL.CoordTrans, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
13:24:02 <Notostraca> Anyone here proficient in HGL?
13:24:13 <Notostraca> Or anything better
13:25:22 <ihope> Category theory, eh?
13:26:07 <chessguy> ihope, ?
13:26:57 <Notostraca> I have no idea what the difference is between RGB and Color
13:27:10 <ihope> You know. Category theory.
13:27:45 <chessguy> ihope, what about it?
13:27:49 <Notostraca> Kant's Categorical Imperative?
13:28:04 * shapr reKant's
13:28:18 <gotaku> Haskell is the hardest language I've ever tried to learn... these monads are really throwing me.
13:28:25 <shapr> gotaku: Oh, I can help you!
13:29:02 <chessguy> go write a monad tutorial, that's how everyone else seems to learn them
13:29:02 <ihope> They say Haskell is easier as a first language than as a later one. (Don't they?)
13:29:11 <mattam> shapr's our santa claus :)
13:29:12 <gotaku> I tried reading "All about moands" and while it starts off good it starts moving way too quickly.
13:29:20 <dons> > runState (do x <- get ; put (x*2) ; return "done") 7 -- a simple state monad!
13:29:21 <lambdabot>  ("done",14)
13:29:42 <dons> runs the first code fragment with the state threaded through, and accessible with get and put
13:29:46 <shapr> gotaku: What programming languages do you already know?
13:29:47 <gotaku> chessguy, is that why all the monad tutorials seem to suck?
13:29:57 <chessguy> hehe
13:30:21 <ihope> gotaku: how many people have told you monads are like bicycles?
13:30:22 <chessguy> gotaku, i'm beginning to believe that truly understanding monads is impossible until you just start hacking away on t hem
13:30:22 <shapr> salut mattam
13:30:36 <chessguy> ihope, unicycles, not bicycles
13:30:36 <ihope> do-notation is what did it for me.
13:30:38 <xerox> ?quote *metaphor*
13:30:38 <lambdabot> Plugin `quote' failed with: IRCRaised Text.Regex.Posix.regcomp: error in pattern
13:30:40 <mattam> salut
13:30:44 <xerox> woops.
13:30:51 <shapr> je suis trop chouette! whee!
13:30:53 <ihope> Ooh, cool, it's a little imperative mini-language!
13:30:55 * shapr boings
13:31:00 <mattam> _lol_
13:31:03 <ihope> chessguy: I take it you never forget those either.
13:31:16 <chessguy> ihope,forget what?
13:31:29 <ihope> chessguy: unicycles.
13:31:32 <chessguy> ?quote unicycle
13:31:33 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:31:37 <shapr> mmm!
13:31:41 <shapr> @quote unicycle
13:31:41 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:31:45 <gotaku> chessguy I can't start hacking on them... I have no idea how anybodies code works.
13:31:49 <shapr> Is that the only unicycle quote? no way!
13:31:55 <shapr> gotaku: oh oh! I can help you!
13:32:01 <shapr> pick me! pick me!
13:32:11 <xerox> aha.
13:32:16 <ihope> Well, try looking at individual monads. Maybe that'll make it click.
13:32:19 <chessguy> @quote unicycle
13:32:20 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
13:32:20 <lambdabot> squad, but he declined.
13:32:26 <xerox> I was searching for that one.
13:32:41 <shapr> ohh
13:32:56 <xerox> I mean, the monads-as-.. thing.  hehe.
13:33:01 <gotaku> The only Monad got a handle on is Maybe.
13:33:02 <shapr> gotaku: but first, I have to know my audience. What programming languages have you used before?
13:33:24 <xerox> ?quote introductions
13:33:24 <lambdabot> DanPiponi says: Writing introductions to monads seems to have developed into an industry
13:33:30 <gotaku> shapr, C/C++ mostly.
13:33:46 <shapr> gotaku: Have you read http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html and http://www.haskell.org/haskellwiki/Monads_as_containers ?
13:33:49 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
13:33:52 <ihope> gotaku: it's always a good idea to look at IO.
13:34:16 <shapr> gotaku: Ok, do you know what C++ 'pattern' is abstracted out by the maybe monad?
13:35:44 <gotaku> Never really used patterns that much to care.
13:36:18 <shapr> Well, if you were to translate the maybe monad into average everyday C++ code, what would you use instead?
13:36:35 <shapr> I think it's the equivalent to a bunch of nested if-then-else statements, where every if condition has to succeed.
13:36:35 <Daveman> xerox :D
13:37:02 <gotaku> shapr, I know how the Maybe monad works already.
13:37:15 <xerox> Hey Dave.
13:37:23 <shapr> gotaku: Ok, but you see that it's just there to keep you from making up a bunch of nested if statements, yah?
13:37:32 <cjeris> State monad novice here... what's the function that promotes an IO action ac :: IO a to type StateT s IO a along the identity function on s?
13:37:41 <xerox> ?type liftIO
13:37:43 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
13:37:54 <gotaku> shapr: Yes.
13:38:17 <Daveman> xerox, how have you been ? :)
13:38:19 <xerox> I don't understand the "along the identity function on s" part.
13:38:25 <cjeris> xerox: that comes indirectly from StateT's instance of MonadTrans?
13:38:26 <shapr> gotaku: Ok, so you understand the most important point, a monad is just another way to do abstraction like objects, function, etc
13:38:38 <xerox> Daveman: quite good, thanks, mathematics is being fun.
13:38:43 <xerox> ?instances MonadIO
13:38:44 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
13:38:44 <Daveman> \o/
13:39:01 <xerox> Daveman: still hacking perl?
13:39:05 <shapr> gotaku: So, how would you extend the Maybe monad to return an error message when it fails, instead of just bailing out?
13:39:06 <Daveman> yes :(
13:39:11 <xerox> hah.
13:39:13 <Daveman> paolo, I've been learning more haskell recently though :D
13:39:15 <cjeris> xerox: OK, thanks!  (I meant, the natural lifting, not altering the state.)
13:39:54 <Notostraca> Are there any existing game frameworks (could be 2d or even text-based) that employ Haskell?
13:39:58 <Daveman> silly parsec
13:40:11 <shapr> Notostraca: There's the Quake clone, Frag
13:40:18 <shapr> There are two nethack clones as well.
13:40:18 <ihope> Hmm, this "You Could Have Invented Monads" thing looks pretty nice.
13:40:25 <ihope> NetHack clones?
13:40:28 <Notostraca> Is Frag open source?
13:40:28 <shapr> yup
13:40:31 <shapr> yes
13:40:32 <xerox> cjeris: you're welcome.
13:40:37 <Notostraca> netHack?
13:40:39 <shapr> @where frag
13:40:39 <lambdabot> http://www.haskell.org/haskellwiki/Frag
13:40:45 <shapr> Notostraca: Have you played nethack?
13:40:50 <Notostraca> yes
13:41:02 <xerox> Daveman: oh cool, monadic parsing, how do you like it?
13:41:13 <shapr> Richard Braakman wrote mage - http://www.scannedinavian.com/~shae/mage-1.0pre35.tar.gz
13:41:16 <shapr> It's a nethack clone in Haskell.
13:41:18 <xerox> Isn't it the best invention after sliced bread?
13:41:23 <Notostraca> Sweet.
13:41:51 <xerox> shapr: a full clone? Impressive!
13:42:17 <xpika2> @index new
13:42:18 <lambdabot> Data.Graph.Inductive.NodeMap, Data.Graph.Inductive, Data.HashTable, Foreign.Marshal.Utils, Foreign.Marshal, Foreign
13:42:24 <Notostraca> But are .hsc files...half haskell, half c?
13:42:27 <shapr> gotaku: Still there?
13:42:48 <xpika2> Notostraca: There actually C--
13:43:10 <Notostraca> woah
13:43:21 <gotaku> shapr: Heah, i'm still here.
13:43:25 <gotaku> Yeah
13:43:26 <xpika2> a subset of c generated by haskell
13:43:26 <Notostraca> that's a funky interlanguage, right ther
13:43:50 <Daveman> xerox, still trying to get used to it ;)
13:43:57 <shapr> gotaku: So, how would you extend the Maybe monad to return an error message instead of just failing?
13:44:17 <xerox> Daveman: you're used to writing grammars out and having them interpreted by yacc-like tools?
13:44:31 <Daveman> xerox, actually working with another on writing a parser for another language's parser :D
13:44:52 <xerox> O_o
13:44:57 <Daveman> it's kind of crazy, but the end result is exactly what we've wanted, plus in MUCH less code, thanks to play and data.generics :D
13:45:01 <Daveman> <3
13:45:08 <gotaku> shapr: No idea.
13:45:13 <master_baiter> ;_;
13:45:15 <Daveman> oh, and I've totally converted another unbeliever to haskell
13:45:18 <xerox> Daveman: so you've done it in Haskell? Is it available anywhere?
13:45:29 <Daveman> he was like, hmm, I'm not sure if we should use haskell,... isn't it a bit archaic?
13:45:32 <shapr> gotaku: Well, what does >>= return right now if it doesn't work?
13:45:34 <master_baiter> ciao xerox
13:45:40 <dons> ?users
13:45:41 <lambdabot> Maximum users seen in #haskell: 322, currently: 309 (96.0%), active: 48 (15.5%)
13:45:41 <xerox> ciao (:
13:45:42 <_roconnor> what's the essential difference between Fudgets and Phooey?
13:45:49 <dons> _roconnor: 10 years?
13:45:54 <shapr> authors too
13:45:59 <master_baiter> dons how does it tell if someone is active?
13:46:01 <roconnor> :P
13:46:08 <roconnor> Both are arrows
13:46:12 <shapr> Also, doesn't Fudgets require O'Haskell? or am I confused?
13:46:12 <dons> if they've spoken in the last 4 hours
13:46:14 <roconnor> functions with UI attached
13:46:20 <gotaku> shapr: Nothing
13:46:22 <master_baiter> dons oh
13:46:22 <shapr> I couldn't get Fudgets to build last time I tried it.
13:46:31 <Daveman> I'm like, dude... wtf, check this out! ... 24 hrs later I wake up and he's like, dude, I've reduced my parser code by 500% and it works now, and the functionality way greater than I even hoped for, and I'm still learning more of the functionality as I go :p
13:46:41 <Daveman> paolo, suffice it to say, I was satisfied :]
13:46:42 <roconnor> So what, is phooey a modern implementation of the same ideas?
13:46:43 <shapr> gotaku: So, could you get the maybe monad to send back a string that describes the error instead?
13:46:43 <xerox> Daveman: hehe, great.
13:47:12 <Daveman> yep, I'm still trying to grasp some of the more complex concepts and usages, but doing it as I go along, by example seems to be fun to play with and working well :)
13:47:17 <Axioplase> hum... is there a type for symbolic calculus ? I want 1/3 to be 1/3 and no 0.3333... (and no, I don't want to write an algebraic type for expressions)
13:47:21 <Daveman> I'm enjoying it, in some spare time :)
13:47:26 <shapr> Axioplase: ratio
13:47:37 <shapr> :t 1%3
13:47:39 <lambdabot> forall a. (Integral a) => Ratio a
13:47:47 <xerox> Daveman: you've reduced it to lines - 500*lines = -499*lines of code? :P
13:47:48 <shapr> > 1%3 + 1%3
13:47:49 <ihope> gotaku: well, it wouldn't still be the Maybe type. A different type, similar to Maybe.
13:47:49 <lambdabot>  2%3
13:47:55 <gotaku> shapr: I don't know how I could.
13:48:01 <xerox> Daveman: anyway, do you have any parsec question?
13:48:04 <gotaku> shapr: Oh.
13:48:15 <shapr> gotaku: Could you directly replace the code that returns Nothing, and make it return a String instead?
13:48:46 <gotaku> shapr: If I made a new Monad, then yes.
13:48:50 <shapr> Ok, try it!
13:49:07 <ihope> gotaku: I think now would be a good time to ask if you understand the syntax of data declarations.
13:49:29 <Axioplase> shapr: thanks
13:49:57 <gotaku> ihope: I think so.
13:49:58 <shapr> Axioplase: There's also an infinite precision library by ... Andrew Bromage, I believe.
13:50:18 <shapr> What are the mixed ratio numbers called?
13:50:28 <shapr> stuff like 1 / (5 / 6)
13:50:37 <Axioplase> shapr: well, I want to print the ratios afterwards... must be easy for the end user to read.
13:50:40 <gotaku> Why is there no haskell IDE yet?
13:50:43 <ihope> gotaku: if you can tell me just what "data Maybe a = Just a | Nothing" means, then that'll work.
13:50:59 <shapr> gotaku: There are several, I like emacs.
13:51:54 <Axioplase> I like vim :)
13:51:54 <xerox> shapr: they are rational numbers.
13:51:58 <gotaku> shapr: I mean a modern IDE
13:52:06 <huschi_> when i try to load sth to ghci it tells me to use -fallow-incoherent-instances.
13:52:09 <xpika2> emacs is modern
13:52:13 <huschi_> if i use this it tells me the same.
13:52:24 <huschi_> has anybody experienced the same problem=
13:52:28 <ihope> By "modern" do you mean "GUI"?
13:52:31 <Daveman> xerox, no right now, thanks though - I did the past few days, but I got great help from others here :)
13:53:11 <xerox> Daveman: hehe, okay. I've been away from #haskell from quite long period in fact (:
13:53:11 <xpika2> @where visualhaskell
13:53:12 <lambdabot> I know nothing about visualhaskell.
13:53:30 <xpika2> @where+ visualhaskell http://www.haskell.org/visualhaskell/
13:53:31 <lambdabot> Done.
13:53:33 <xpika2> @where visualhaskell
13:53:34 <lambdabot> http://www.haskell.org/visualhaskell/
13:53:56 <gotaku> Great, if you have visual studio.
13:53:57 <astrolabe> I think .net is available for haskell if that is really what you want
13:54:04 <Daveman> xerox, yeah, I just got back... a few days ago :)
13:54:07 <glguy> astrolabe: it is?
13:54:10 <Daveman> for being away a while
13:54:19 <Daveman> oh, and I saw nymphaea :p
13:54:21 <Daveman> ^_^
13:54:34 <astrolabe> glguy: I thought I saw it advertised
13:54:44 <xpika2> there is always xemacs thats a gui.
13:54:58 <shapr> gotaku: Modifying the maybe monad to be a new monad that returns strings describing the error will help you understand monads.
13:55:04 <xerox> Daveman: hehe, cool, I've had it installed in a few new class mates' computers lately :D
13:55:09 <shapr> Yeah, I use the xemacs gui Haskell editor.
13:55:12 <Daveman> woot!
13:55:45 <xerox> (Emacs has a GUI too.)
13:55:57 <glguy> astrolabe: I think that's over 5 years outdated...
13:56:22 <astrolabe> glguy: perhaps I'm confusing it with something else
13:56:58 <gotaku> Is any work being done on this hIDE thing?
13:57:51 <Notostraca> in Mage, when I try to build it with Main.hs, I get:   Can't find imported module "Curses"
13:58:31 <Notostraca> Then again, Hugs isn't quite working for me
13:58:40 <shapr> Notostraca: try using make
13:58:57 <Notostraca> so...
13:59:05 <Notostraca> make main.hs?
13:59:11 <Notostraca> I have no idea
13:59:13 <shapr> Nah, just 'make' in that directory.
13:59:22 <shapr> Do you have gnu make installed?
13:59:51 <Notostraca> Windows.
13:59:54 <shapr> ah
14:00:27 <shapr> wellll.. I don't even know if the curses lib runs on win32
14:00:28 <Notostraca> I have VC++ express...
14:00:37 <cinimod> Can someone point me at the source for strict foldl?
14:00:39 <Notostraca> PDCurses should
14:00:47 <shapr> @src foldl'
14:00:48 <lambdabot> foldl' f a []     = a
14:00:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:01:16 <cinimod> Brilliant. I didn't know lambdabot could do that.
14:01:20 <astrolabe> Where do I find the current sources for OpenGL as advertised on this page? http://www.haskell.org/ghc/docs/latest/html/libraries/
14:01:22 <shapr> lambdabot is all powerful.
14:01:27 <Axioplase> hum.. I want to set a darcs server on a box and a client on another.. though I quite don't get how to set the server... I just set the ssh vars for the client, and darcs on the server will handle this alone ?
14:01:31 <ihope> @src lambdabot
14:01:31 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:01:38 <chessguy> does foo' usually mean "a strict implementation of foo"?
14:01:43 <ihope> shapr: :-(
14:01:45 <shapr> chessguy: yup
14:01:51 <chessguy> ah, good to know
14:01:55 <shapr> ihope: @version
14:01:58 <ihope> Isn't it usually "a different version of foo"?
14:02:03 <ihope> shapr: :-)
14:02:04 <chessguy> ?where lambdabot
14:02:05 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:02:44 <shapr> Axioplase: darcs repos are accesible over http for pulling, or darcs push user@host if you can already do ssh user@host and it works.
14:03:12 <shapr> Notostraca: I don't know how to build Haskell programs on windows, maybe someone else here on #haskell can help you?
14:03:34 <Axioplase> shapr: simply push ? cool. thanks.
14:03:35 <bos> @hoogle Int -> [a] -> ([a], [a])
14:03:36 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
14:03:39 <Sinner> unless I'm mistaken I think GHC can do it
14:03:40 <Notostraca> I have WinHugs
14:03:51 <Sinner> Hugs can't compile on windows
14:03:52 <dons> shapr: you just use ghc, afaik
14:03:56 <Sinner> you'll need to get GHC
14:04:01 <shapr> dons: for hsc2hs stuff?
14:04:11 <Notostraca> I have GHC too
14:04:30 <shapr> dons: He wants to build mage, which requires curses and hsc2hs
14:04:34 <Notostraca> I just have very little knowledge of how they work
14:04:41 <dons> hmm. on windows. with no curses?
14:04:42 <Saizan> gotaku: there's a nice explanation here http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes
14:04:55 <dons> sounds like a mountain of pain. hsc2hs should work though
14:04:56 <Sinner> sorry, i don't actually know the method to compile it... i'm still pretty new to haskell.
14:05:09 <shapr> Sinner: Welcome to the community!
14:05:18 <dons> ndm, around?
14:05:20 <Notostraca> ?where hsc2hs
14:05:21 <dons> ?seen ndm
14:05:21 <lambdabot> I know nothing about hsc2hs.
14:05:21 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 20h 8m 52s ago, and .
14:05:24 <shapr> robEdge: Are you new here also?
14:05:27 * Sinner feels welcome
14:05:38 <dons> Sinner: I'd say start with the windows version of ghc, you got that?
14:05:46 <dons> if not, grab it from haskell.org/ghc
14:05:47 <ihope> return is how you get a monadic value, >>= is what you do with it. :-)
14:05:48 <Sinner> ya i got it
14:05:53 <Sinner> dons: no i got it
14:06:09 <dons> cool. so then you also have hsc2hs already, I think
14:06:20 <dons> ghc -o myprog Foo.hs should just work for basic things
14:06:59 <Sinner> basic? Is it limited in some critical way?
14:07:16 <shapr> dons: shouldn't that be ghc --make ?
14:07:57 <dons> well, for more than one file, yeah
14:08:05 <dons> Sinner: shouldn't be.
14:08:11 <Sinner> aight, kewl
14:08:12 <dons> people use ghc on windows all the time
14:08:12 <Sinner> thanks
14:08:17 <shapr> The only limitations I can think of are that you'll need to know more parameters to explicitly specify a preprocessor or other unusual operations.
14:08:31 <dons> sometimes the $PATH breaks on windows too
14:08:40 <shapr> I had to do some windows maintenance yesterday. Made me wish I'd brought an ubuntu install CD.
14:08:46 <dons> which might involve making sure gcc, ld and so on are in your path
14:09:00 <Sinner> yes, well i'll worry about that when I'm desperately looking to optimize my otherwise superbly outstanding programs :0
14:09:18 <Sinner> gcc?
14:09:22 <dcoutts> g'morning dons
14:09:32 <shapr> Sinner: the Gnu C Compiler
14:09:45 <dcoutts> dons, see my note about movable bytestrings?
14:09:47 <Sinner> I require the C compiler to compile haskell code?
14:09:50 <xerox> shapr: a preprocessor whatever binary that does something like sed?
14:10:16 <shapr> xerox: Yeah, or the early arrows code that was .as files preprocessed to .hs files.
14:10:45 <xerox> shapr: by ghc, specifying a preprocessor?
14:10:50 <shapr> Yup
14:10:52 <dcoutts> Sinner, ghc can either produce assembly code directly or produce C code and then use the C compiler to produce assembly code.
14:10:59 <shapr> I think it's -pgmF <name of program>
14:11:00 <Sinner> ic
14:11:09 <Sinner> kk thx
14:11:16 <Notostraca> what exactly does --make do?
14:11:21 <dcoutts> Sinner, historically the via-C route has produced faster code, though these days that's less and less true.
14:11:21 <xerox> shapr: ah, nice. I never used/seen it used before.
14:11:33 <dcoutts> Notostraca, it does the "right thing"
14:11:36 <shapr> Notostraca: In my opinion it's "do what I want"
14:11:53 <Sinner> interesting. altho having C code of my haskell project, for the time being, might be more meaningful to me
14:11:54 <Notostraca> does it work on Windoze?
14:11:58 <dcoutts> yes
14:12:15 <dcoutts> Notostraca, without it, ghc operates in 'one shot' mode which is only ok if you want to write your own makefiles.
14:12:19 <shapr> Sinner: GHC-generated C code is probably not helpful.
14:12:27 <xerox> Notostraca: it resolves dependencies and imposes the other of compilation.
14:12:40 <dons> dcoutts: yeah. interesting!
14:12:43 <dcoutts> Sinner, yeah, the C code produced, is totally unreadable low level code.
14:12:47 <Sinner> hmm, back to basics then , )
14:12:58 <glguy> paolino: you about?
14:13:12 <Notostraca> so, in the src folder with the makefile, main.hs, and everything related, --make will create the project?
14:13:29 <dcoutts> Sinner, to see what I mean, use ghc -C Foo.hs and then look at the resulting Foo.hc file, you'll hardly recognise it as C code :-)
14:13:32 <xerox> Yes.
14:13:54 <cjeris> I have a tiny little REPL-like program using StateT around IO.  It just counts the lines and characters you type.  Could anyone take a moment to critique it?  I'm not sure I have the right idea.
14:13:57 <hpaste>  cjeris pasted "idiotic little REPL" at http://hpaste.org/180
14:13:57 <hpaste>  cjeris pasted "idiotic little REPL" at http://hpaste.org/181
14:14:03 <dcoutts> dons, aye, if this is the way of Haskell strings in the future then we need to make it work well for smaller strings too.
14:14:05 <cjeris> erk, sorry
14:14:19 <dons> dcoutts: right.
14:14:26 <gotaku> Doesn't --make just automatically figure out the source code dependencies and compile them?
14:14:35 <dcoutts> gotaku, exactly
14:14:38 <astrolabe> dcoutts: How do I get the code for OpenGL?
14:14:42 <Notostraca> Then, where did it go?
14:14:49 <Notostraca> the built file
14:15:19 <dcoutts> astrolabe, what do you mean? how does one install HOpenGL you mean? or are you talking about the Gtk2Hs OpenGL stuff?
14:15:22 <Notostraca> I did --make in the folder, but it acts like there is another command required
14:15:55 <Sinner> dcoutts: I'll save that exercise for a later date. I don't wanna confuse myself yet
14:16:00 <Sinner> thx all
14:16:08 <astrolabe> dcoutts.  OpenGL is mentioned here rather than HOpenGL, which I don't understand, but whichever, not the Gtk2Hs stuff at the moment.
14:16:12 <dcoutts> Notostraca, what are you expecting, a stand alone .exe file?
14:16:16 <gotaku> Notostraca, what was your full command line?
14:16:28 <astrolabe> dcoutts here = http://www.haskell.org/ghc/docs/latest/html/libraries/
14:16:34 <dcoutts> astrolabe, HOpenGL is the name of the Haskell OpenGL binding.
14:16:38 <lmbdwr> hey : what means "tessilate" ?
14:16:46 <Notostraca> cd myFolders/more/src
14:16:49 <Notostraca> then
14:16:51 <hpaste>  glguy annotated "ContT and IO" with "paolino , I see what you were asking now" at http://hpaste.org/179#a1
14:16:56 <Notostraca> make--
14:16:58 <dcoutts> astrolabe, http://haskell.org/ghc/download_ghc_66.html
14:16:58 <lambdabot> Title: GHC: Download version 6.6
14:17:09 <xerox> lmbdwr: tile?
14:17:13 <dcoutts> astrolabe, you want the "ghc-6.6-src-extralibs.tar.bz2"
14:17:34 <gotaku> Notostraca, Eh?
14:17:37 <astrolabe> dcoutts: Ah, thanks.  Is there a way to tell if I already have it?
14:17:43 <Notostraca> What am I expecting?
14:17:46 <dcoutts> astrolabe, ghc-pkg list
14:17:53 <Notostraca> what does make do?
14:18:03 <Notostraca> EEERGH!
14:18:12 <gotaku> I thought you meant ghc --make
14:18:29 <astrolabe> dcouts: that mentions 'OpenGL-2.1'
14:18:30 <Notostraca> should I try that instead?
14:18:36 <dcoutts> Notostraca, for example if you've got a HelloWorld.hs file, then you'd say: ghc --make HelloWorld.hs
14:18:51 <Notostraca> OH!
14:18:52 <dcoutts> (assuming HelloWorld.hs is in the current directory)
14:18:54 <gotaku> ghc --make Main.hs -o Main.exe
14:19:03 <glguy> ghc --make Main
14:19:15 <glguy> in 6.6 the -o is superflous
14:19:20 <bos> what does it mean when ghc reports "bad interface file"?
14:19:20 <dcoutts> yeah, and you can give a specific name to the final .exe using the -o flag
14:19:23 <glguy> ?spell superflous
14:19:24 <lambdabot> superfluous superfluously supercilious superfluity superclass
14:19:24 <hpaste>  malebria pasted "Reorder function" at http://hpaste.org/182
14:19:29 <dcoutts> bos, clean and rebuild
14:19:34 <malebria> Is there a function like this in the libraries?
14:19:46 <matthew-_> dcoutts: mmm. the -fvia-C route definately seems to be slower for me here.
14:19:51 <dcoutts> bos, eg if the .hi file came from a different arch, or is corrupt
14:19:57 <hpaste>  bringert pasted "lhs2TeX centered equations" at http://hpaste.org/183
14:20:04 <dcoutts> matthew-_, it depends on the arch and the program
14:20:04 <glguy> malebria: describe its behavior
14:20:11 <bos> dcoutts: i've done that several times.
14:20:14 <malebria> reorder [1, 2, 3]
14:20:17 <Notostraca> ghc is not in scope
14:20:18 <malebria> [[1,2,3],[3,1,2],[2,3,1]]
14:20:25 <astrolabe> dcoutts: the reply to ghc-pkg list mentions 'OpenGL-2.1'.  I guess that means I have it?
14:20:26 <bos> it complains about "mismatched interface file ways"
14:20:27 <matthew-_> dcoutts: ahh. p4, and a ogl game.
14:20:33 <dcoutts> astrolabe, right.
14:20:46 <malebria> glguy: it makes all possibilities of reordering without loosing it's "order"
14:20:48 <bringert> kosmikus: do you have any tips for how to get this right: http://hpaste.org/183
14:20:59 <Botje> malebria: so, rotation
14:21:01 <astrolabe> If we ask dcoutts enough questions, perhaps he'll explode
14:21:07 * dcoutts goes boom
14:21:13 <astrolabe> :)
14:21:15 <bringert> glguy: would it be possible for hpaste to use CSS to set the textarea font to a monospace one?
14:21:16 * dcoutts goes away to hack
14:21:23 <astrolabe> Aw
14:21:32 <matthew-_> is there any way of combining jhc and ghc to create super fast magic haskell greatness?
14:21:34 <glguy> > let rotations xs = [y ++ x | (x,y) <- zip (inits xs) (tails xs)]  in rotations [1..3] -- I know this will geneate too much
14:21:36 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
14:21:41 <astrolabe> Can anyone else help me get started with OpenGL?
14:21:45 <bringert> glguy: on my safari it's a proportional one, which makes the code look weird when you enter it
14:22:03 <glguy> > let rotations xs = [y ++ x | (x,y) <- zip (inits xs) (tails xs), not (null y)]  in rotations [1..3] -- I know this will geneate too much
14:22:05 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2]]
14:22:09 <matthew-_> astrolabe: have you got it installed then?
14:22:11 <glguy> malebria: ^
14:22:20 <Botje> > let rotations xs = tail $ zipWith (++) (inits xs) (tails xs) in rotations [1..3]
14:22:22 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
14:22:29 <Botje> ehm. duh
14:22:37 <Botje> > let rotations xs = tail $ zipWith (++) (tails xs) (inits xs) in rotations [1..3]
14:22:38 <lambdabot>  [[2,3,1],[3,1,2],[1,2,3]]
14:22:44 <Notostraca> yeah, I'm getting the error message "GHC is not in scope"
14:22:45 <dons> bringert: we have a binary library now, and fast strings. time to write the canonical http package!
14:22:47 <malebria> Thanks for the simplifications.
14:22:59 <glguy> > let rotations xs = init . liftM2 (++) tails inits in rotations [1..3]
14:23:00 <lambdabot>  Add a type signature
14:23:14 <glguy> > let rotations xs = init . liftM2 (zipWith (++)) tails inits in rotations [1..3]
14:23:15 <lambdabot>  Add a type signature
14:23:17 <glguy> :(
14:23:22 <astrolabe> matthew: apparently, but when I try the first example from http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/  I get an error window "This application has failed to start because glut32.dll was not found..."
14:23:25 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
14:23:29 <Notostraca> do I enter these commands in GHi or cmd?
14:23:44 <Notostraca> Apparently, I suck at this.
14:23:45 <bringert> dons: are you saying that you are volonteering?
14:23:47 <bringert> :-)
14:23:49 <dons> http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
14:23:51 <lambdabot> Title: Good Math, Bad Math : More Monads: Stateful Programming, http://tinyurl.com/34gwz7
14:23:52 <dons> bringert: I am.
14:23:57 <matthew-_> astrolabe: ahh, windows land. Sorry, I really can't help you there. It just works under linux...
14:23:57 <bringert> dons: sweet
14:24:13 <dons> I want an HTTP Strike Team!
14:24:17 <dons> 3 guys would be enough.
14:24:21 <dons> maybe I can bug musasabi
14:24:22 <astrolabe> matthew:    :/
14:24:25 <matthew-_> astrolabe: err, you'll need the glut stuff. I know that's an obvious think to say...
14:24:36 <glguy> dons: what are we doing?
14:24:38 <bringert> dons: why are we striking? better pay?
14:24:45 <astrolabe> matthew: not obvious enough. Thanks.
14:24:56 <gotaku> Is the current stable version of gtk2hs any good?
14:25:06 <glguy> dons: I'll get the picket sighns
14:25:07 <glguy> signs*
14:25:08 <bringert> dons: the darcs repo should be writable by the darcs group already
14:25:14 <astrolabe> matthew: you mean from outside the world of haskell?
14:25:17 <dcoutts> gotaku, I recommend going with the latest release candidate
14:25:35 <dons> it just worked really well with the binary lib. get an api sketched out, get 3+ people hacking on it, writing docs and so on
14:25:36 <dcoutts> gotaku, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.tar.gz
14:25:39 <dons> 2 weeks later its done
14:25:49 <dons> bringert: on darcs.haskell.org/http ?
14:25:53 <matthew-_> astrolabe: yeah, you'll need some sort of glut implementation. When ghc links at the end of compilation, it links to the glut and opengl system libraries
14:25:57 <bos> @seen sjanssen
14:25:57 <bringert> dons: yep
14:25:58 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard sjanssen speak 5h 1m 20s ago.
14:26:04 <bos> @where genparsec
14:26:05 <lambdabot> I know nothing about genparsec.
14:26:09 <bos> gargh.
14:26:19 <matthew-_> astrolabe: this is how it makes the opengl calls "work". it's all ffi stuff I guess under the bonet
14:26:20 <astrolabe> matthew: how does it know where they are?
14:26:38 <matthew-_> some sort of environment variables I'd guess
14:26:50 * astrolabe experiments
14:27:05 <Notostraca> GHC isn't anywhere
14:27:11 <dons> bringert: ok good.
14:27:20 <musasabi> dons: pong
14:27:26 <gotaku> dcoutts, I'm on windows right now.
14:27:43 <matthew-_> astrolabe: same way that ghc (minigw?) finds libraries to link against I'd expect.
14:27:46 <dcoutts> gotaku, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
14:27:56 <musasabi> I am interested in getting a standard HTTP lib.
14:28:06 <matthew-_> astrolabe: I'm off to bed I'm afraid. Have fun. :)
14:28:08 <bringert> dons: the permissions aren't set right yet
14:28:08 <gotaku> Oh, thanks.
14:28:18 <chessguy> musasabi, jump in on the discussion on -cafe
14:28:32 <bos> Network.HTTP.Lovefest
14:28:39 <dcoutts> gotaku, though check the Gtk2Hs website in a couple days as there's going to be a final release very soon (which btw, will fix the theme bug in that version I just gave you)
14:28:47 <matthew-_> astrolabe: you may be able to specify them manually to ghc with -I or something like than. the man page will have the gory details I'm sure
14:28:52 <astrolabe> matthew_-Thanks
14:29:44 <matthew-_> astrolabe: np. Yeah, -I looks like it might work if nothing else does:        -Idir  Add dir to the directory search list for #include files
14:33:04 <glguy> dons: what thread discusses the proposed work on HTTP?
14:33:08 <syntaxfree> I wonder if many people join the #include and #ifdef channels.
14:33:43 <Pseudonym> Visual C++ users join the #pragma channel more than anything else, I suspect.
14:35:04 <syntaxfree> C++ pragmas are like GHC pragmas?
14:35:13 <Pseudonym> Yeah.
14:35:16 <Pseudonym> C has them, too.
14:35:16 <dons> glguy: its really only been comments in here, and there's a couple of threads on http happening on haskell-cafe now
14:35:24 <bringert> dons: ok, ownership, permissions and posthooks for http://darcs.haskell.org/http/ are correct now
14:35:26 <lambdabot> Title: Index of /http
14:35:32 <Pseudonym> But in every Visual C++ program, you need to turn off one or more warnings.
14:35:54 <glguy> dons: I found the -cafe thread in my archive
14:35:58 <Pseudonym> Because VC warns about really dumb things that are quite reasonable, like using the standard C++ library.
14:36:06 <Nafai> Pseudonym: Especially if you are using the STL
14:36:07 <Pseudonym> And, of course, it doesn't warn about dubious things.
14:36:08 <Pseudonym> Right.
14:36:10 <dons> bringert: great.
14:36:14 <dons> step 1. complete
14:36:19 <Pseudonym> That's what I meant by "standard C++ library". :-)
14:36:22 <dons> now i just need to bug 3 or 4 people to help
14:36:28 <dons> glguy: sounds keen
14:36:33 <dons> musasabi knows what's going on
14:36:38 <dons> sjanssen's always up for more code
14:36:45 <Pseudonym> Hang on, dons, what do you need help with?
14:36:49 <dons> bringert has to help anyway
14:36:50 * Pseudonym missed out on this
14:36:58 <dons> Pseudonym: a standard http lib
14:37:05 <dons> starting with d.h.o/http
14:37:10 <Pseudonym> Ah, cool.
14:37:23 <dons> needs someone familiar with the python api, i reckon
14:37:37 <syntaxfree> It's interesting how hard it is to hack without internet access.
14:37:54 <syntaxfree> I've been trying to make sense of HappS, but got cut off the internet for  a few days.
14:37:58 <Pseudonym> Well I'm familiar with the Perl one.
14:38:10 <malebria> @pl (\list -> tail $ zipWith (++) (tails list) $ inits list)
14:38:11 <lambdabot> tail . ap (zipWith (++) . tails) inits
14:38:26 <Nafai> dons: API?  As in the Python libraries or the Python C api?
14:38:38 <malebria> @type ap
14:38:40 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
14:38:43 * Pseudonym assumed he meant the Python libraries
14:39:06 <Nafai> If you are talking about the libraries, I'm fairly familiar, or at least know my way around the docs fairly well
14:39:09 <dons> binding to libcurl might be even easier..
14:40:09 <Pseudonym> As a matter of curiosity, how do the Python libraries handle negotiation?
14:40:29 <gotaku> What level of indentation does everyone use? 2 or 4 spaces?
14:40:31 <Nafai> Pseudonym: negotiation?
14:40:32 <glguy> 2
14:40:48 <glguy> the point is to get curl functionality working, not to necessarily implement it in haskell, right?
14:40:52 <Pseudonym> HTTP 1.1 content negotiation.
14:41:19 <dons> glguy: yeah. a cheap version would be to bind to curl, starting with darcs' bindings
14:41:26 <dons> and we could use bytestrings for the lot
14:41:42 <Pseudonym> You know, like how the client can specify language preferences (I speak Latin first, then Norwegian, then English), and the server picks the best fit.
14:41:58 <bringert> a binding isn't great if it's to be used in things like cabal-install
14:42:05 <Pseudonym> It seems to me, dons, that the first thing to do is write a proper socket library based on byte strings.
14:42:21 <syntaxfree> how mature is the Hackage thing right now?
14:42:22 <Pseudonym> But that might just be me.
14:42:34 <dons> ?where hackage
14:42:34 <lambdabot> http://hackage.haskell.org/trac/hackage
14:42:42 <Axioplase> what is a comment like in cabal ?
14:42:45 <dons> ^^ get your lambda warez!
14:42:46 <bringert> dons: the HTTP web page, http://www.haskell.org/http/, is also a darcs repo
14:42:47 <lambdabot> Title: Haskell HTTP package
14:42:55 <dons> bringert: ok.
14:42:59 <xerox> cjeris: using io = liftIO makes things more readable, nice example.
14:43:00 <bringert> dons: it's now writable by the haskell group
14:43:08 <dons> ah good
14:43:28 <dons> ?where+ hackage http://hackage.haskell.org/packages/archive/pkg-list.html
14:43:28 <lambdabot> Done.
14:43:32 <musasabi> bringert: what is the proper way to commit there if I get to hacking?
14:43:51 <dons> musasabi: darcs push into the repo is easiest
14:43:56 <dons> do you have a d.h.o account?
14:44:04 <bringert> musasabi: http://www.haskell.org/http/ is just the web page, the code is in http://darcs.haskell.org/http/
14:44:04 <lambdabot> Title: Haskell HTTP package
14:44:25 <bringert> musasabi: I've set both up so that you can push to them if you have the right accounts
14:44:46 * bringert goes to eat some dinner
14:44:51 <xerox> bringert: what is it using now to add the packages to the repo?
14:44:55 * bringert was about to type sinner
14:45:05 <xerox> !
14:45:15 <dons> note we also have haskellNet already
14:45:23 <dons> which does a lot of bytestring-level network stuff
14:45:26 <bringert> xerox: http://hackage.haskell.org/packages/archive/pkg-list.html
14:45:31 <musasabi> I don't think I have right accounts.
14:45:38 <bringert> xerox: if you were talking about hackage
14:45:52 <dons> musasabi: can you ssh into darcs.haskell.org ?
14:45:52 <xerox> bringert: I left a perl script... is it still in use?
14:45:52 <xerox> yes
14:46:02 <dons> xerox: don't think so
14:46:23 <bringert> xerox: no, afaik there is not program which uploads to ross' new web interface
14:46:25 <xerox> dons, I also have left some work to do
14:46:29 <bringert> but it's be easy to write one
14:46:38 <bringert> it'd
14:46:52 <bringert> I think Network.HTTP has enough functionality already
14:46:53 <xerox> the interface uploads the file?
14:46:55 <bringert> for that
14:46:59 <musasabi> dons: nope. never needed an account there sending patches by email worked nicely.
14:47:01 <xerox> the web program I mean
14:47:04 <bringert> xerox: http://hackage.haskell.org/packages/upload.html
14:47:06 <lambdabot> Title: HackageDB: checking and uploading packages
14:47:44 <bringert> musasabi: a temporary solution would be for you to set up your on repo, and someone with an account could pull from there and push to d.h.o
14:47:50 <xerox> bringert: oh great. where is its source? we long talked about doing checks on the package to be added
14:47:51 <bringert> s/on/own/
14:48:14 <bringert> xerox: http://darcs.haskell.org/hackage-scripts/
14:48:15 <lambdabot> Title: Index of /hackage-scripts
14:48:22 * bringert really goes to eat
14:48:28 <xerox> Have a good meal
14:50:02 <kosmikus> bringert: try \aligncolumn{22}{r@@{}}
14:53:00 <dons> dcoutts, kolmodin http://www.haskell.org/pipermail/libraries/2007-January/006793.html
14:53:02 <lambdabot> Title: Monad laws for fail, http://tinyurl.com/yunguc
14:53:45 <dcoutts> dons, but it's not true is it?
14:53:50 <dcoutts> the law I mean
14:54:22 <dcoutts> dons, still, his example should fail
14:54:31 <dcoutts> so it's a bug
14:55:41 <xerox> encode and decode are not in class Binary?
14:55:53 <glguy> get and put
14:56:35 <dons> dcoutts: yeah. so *why* doesn't it fail?
14:56:36 <xerox> Do you mean, encode and decode are defined in terms of get and put?
14:56:58 <dons> xerox:
14:56:59 <dons> encode :: Binary a => a -> ByteString
14:57:01 <dons> encode = runPut . put
14:57:07 <dons> decode :: Binary a => ByteString -> a
14:57:09 <dons> decode = runGet get
14:57:12 <mux> this Put monad is so sexy
14:57:15 <mux> I need to find some use of it
14:57:30 <dons> its a monoid really :)
14:57:34 <xerox> dons, what are those two monads?
14:57:37 <dons> with just enough sugar to look like a monad
14:57:38 <xerox> uhu.
14:57:43 <dcoutts> instance Monoid Builder
14:57:45 <Igloo> @where binary
14:57:45 <lambdabot> http://darcs.haskell.org/binary
14:57:45 <mux> yeah, only for the do syntax right?
14:57:46 <hpaste>  kosmikus annotated "lhs2TeX centered equations" with "suggestions" at http://hpaste.org/183#a1
14:57:56 <kosmikus> bringert: ^^
14:58:16 <dons> http://www.cse.unsw.edu.au/~dons/binary <-- haddocks, needs haskell-home+haddock on hackage hehe
14:59:20 <Igloo> dons: Because the thing on the RHS of the >>= uses neither the value nor the state of the thing on the left of the >>=
14:59:34 <dons> hmm!
15:00:34 <dons> instance Monad Get where
15:00:35 <dons>     return a  = Get (\s -> (a, s))
15:00:35 <dons>     m >>= k   = Get (\s -> let (a, s') = unGet m s
15:00:36 <dons>                            in unGet (k a) s')
15:00:45 <Igloo> If you want it to be lazy then I think it has the right behaviour
15:01:15 <dons> well, if its what State does
15:01:17 <dons> :/
15:02:42 <syntaxfree> return should really be called unit.
15:02:56 <dcoutts> dons, oh, that fail is my fault
15:02:57 <xerox> Igloo: isn't s used by k (via s') which belongs to m ?
15:03:08 <dcoutts> dons, failDesc is too lazy
15:03:14 <dons> ah ha
15:03:33 <Igloo> xerox: It doesn't look at the value, it just puts it in a tuple
15:03:46 <huschi_> bringert: am i right that it is also impossible to write things like: SELECT a FROM t1 WHERE b IN (SELECT c FROM t2)?
15:03:49 <xerox> oh.
15:03:51 <hpaste>  dons pasted "ruby v haskell, from the mailing list" at http://hpaste.org/184
15:04:05 <dons> ^^^^^^ someone want to show how to do globbing using MissingH
15:04:05 <glguy> dons: would it be easy to write a template haskell function that generated Binary instances? (specifically for Enum instances)
15:04:09 <xerox> hm.
15:04:14 <dons> glguy: we have that already
15:04:20 <dons> use the tools/derive/ cript
15:04:43 <dons> dcoutts: can you add a unit test for this (or a property?)
15:05:29 <Pseudonym> dons: What glasgow-exts are allowed in HTTP?
15:05:38 <dons> hmm. only those supported also by hugs
15:05:39 <xerox> deriveM (undefined :: Drinks) -- wow.
15:05:41 <dons> so MPTCs
15:05:45 <dons> some flexible typeclass tsuff
15:05:51 <Pseudonym> So fundeps are cool.
15:05:52 <dcoutts> dons, it's a _|_ style property, so hard to test
15:05:58 <dons> Pseudonym: yeah
15:06:07 <xerox> Who wrote that?
15:06:10 <dons> xerox: get yourself some SYB! :)
15:06:30 <dons> xerox: we talked about it at the hackathon over beer, ndm hacked up a version, kolmodin extended it to binary
15:06:42 <xerox> (SYB?)
15:06:53 <dons> I think all new classes should come with a script to derive them using sYB
15:07:01 <xerox> Ah
15:07:05 <xerox> SYB, yes.
15:07:16 <glguy> dons: teach you how to use glob?
15:07:21 <dons> not me.
15:07:21 <xerox> dons haha.
15:07:21 <glguy> dons: there isn't anything to teach
15:07:34 <dons> I'm asking for someone to rewrite the code, and post it back to -cafe for the ruby guy
15:07:39 <glguy> OH, ok
15:07:40 <dons> since i don't have time ! :)
15:07:51 <dons> needs nice regex and glob support, afaik
15:08:04 <dons> so the new =~ operator from the regex libs
15:08:15 <glguy> which regex lib
15:08:16 <xerox> Binary is *very* cool.
15:08:24 <Pseudonym> dons: Where should I send patches?
15:08:29 <dons> glguy: regex-compat perhaps, or regex-*
15:08:37 <dons> Pseudonym: to which lib? http?
15:08:41 <dons> mail me, and I can apply them to the main repo
15:08:49 <Pseudonym> OK.
15:08:55 <malebria> Isn't there a way to run quickCheck with two variables? Something like check (\x y -> x + y - x == y)
15:08:57 <dons> or ask for an account on darcs.haskell.org from SimonM
15:09:02 <dcoutts> dons, hmm, actually it's not that easy to fix, since >> doesn't demand that the lhs is evaluated at all
15:09:18 <dons> ?check \x y -> x + y - x == (y :: Int)
15:09:19 <lambdabot>  OK, passed 500 tests.
15:09:20 <xerox> malebria: sure, it just works
15:09:25 <malebria> hum..
15:09:29 <malebria> Great.
15:09:31 <dons> ?check \x y -> x + y - x == (y :: Double)
15:09:32 <lambdabot>  Falsifiable, after 24 tests: -5.75, 0.14285714285714285
15:09:37 <dcoutts> dons, we could make >>= strict in the action (though not the result of the action)
15:09:42 * dons sez: don't use floating point
15:09:43 <dcoutts> ie in it's lhs
15:09:53 <glguy> dons: would this use filepath?
15:09:54 <xerox> dons, eek.
15:09:56 <malebria> then I can't use quickCheck.
15:09:57 * paolino just finished seeing Schindler Lists , heads outside
15:10:00 <malebria> =(
15:10:02 <dons> dcoutts: so this is a general philosophical issue with State monads
15:10:11 <xerox> paolino: it's _late_
15:10:15 <dcoutts> dons, I guess so.
15:10:26 <dons> malebria: why?
15:10:34 <malebria> dons: cause I'm using Double
15:10:55 <dons> you can use it. it will just find the bugs in your reasoning...
15:10:58 <malebria> ?type check
15:10:59 <dcoutts> dons, if the return value doesn't depend on previous states at all...
15:10:59 <lambdabot> Not in scope: `check'
15:11:11 <dons>  the @check is just a binding to QuickCheck
15:11:12 <paolino> yes xerox, I take a look at goat's puppies and go to bed :)
15:11:12 <malebria> oh, it's not a function..
15:11:26 <xerox> (:
15:11:53 <dons> dcoutts: laziness is fun
15:11:53 <malebria> dons: but aren't this x + y - x /= y things going to happen?
15:11:58 <dcoutts> dons, aye :-)
15:12:06 <dons> malebria: yeah, because that's not true for floating point, always.
15:12:15 <ihope> malebria: that's a problem with Double, not with QuickCheck.
15:12:15 <dons> malebria: so you better think about the math involved :)
15:12:16 <dcoutts> dons, did you follow bringert's struggle with getting untar to work in constant space?
15:12:17 <ihope> ...I think.
15:12:31 <dons> dcoutts: yeah.
15:12:39 <dcoutts> dons, which came down to making ordinary splitAt on lists work
15:12:39 <xerox> dons is there a next hackaton date?
15:12:40 <dons> his runST thingy is in the repo
15:12:43 <dcoutts> aye
15:12:53 <malebria> It's a Double problem for sure, but then it's not a good idea to use quick check with doubles, right?
15:12:56 <dons> xerox: probably before ICFP
15:13:05 <dons> malebria: I'd say its a *very* good idea
15:13:10 <xerox> dons, which will be in europe this time?
15:13:12 <dons> since it exposes this kind of bug, whihc would be quite hard to find by hand
15:13:17 <dons> xerox: yeah, Freiburg
15:13:23 <xerox> state?
15:13:25 <malebria> dons: ok, I'll see what happens with my code.
15:13:31 <xerox> .de?
15:13:32 <malebria> dons: but what function ?check calls?
15:13:46 <dons> it just uses QuickCheck's test function
15:14:20 <dons> malebria:
15:14:21 <dons> Prelude Test.QuickCheck> quickCheck (\x y -> x + y - x == (y :: Double))
15:14:21 <dons> Falsifiable, after 7 tests:
15:14:21 <dons> 2.8
15:14:32 <malebria> hum..
15:14:34 <malebria> ok.
15:15:05 <glguy> dons: i'm writing it with System.FilePath
15:15:09 <glguy> dons: it willkick ass
15:15:17 <xerox> Exams call, see you later guys.
15:15:23 <malebria> This instance Arbitrary (a -> b) is very nice.
15:15:26 <ihope> ?check \x -> tan (arctan x) (x :: Double)
15:15:27 <lambdabot>   Not in scope: `arctan'
15:15:32 <hpaste>  astrolabe pasted "This is a hack" at http://hpaste.org/185
15:15:33 * ihope fails, a little
15:15:36 <ihope> ?check \x -> tan (atan x) (x :: Double)
15:15:36 <dons> glguy: sounds good!
15:15:37 <lambdabot>  Couldn't match `Double' against `t -> t1'
15:15:46 <astrolabe> Is there a better way to do this?
15:15:50 <ihope> ?check \x -> tan (atan x) == (x :: Double)
15:15:52 <lambdabot>  Falsifiable, after 0 tests: 3.25
15:15:57 <dcoutts> dons, we cannot simultaneously make it obey that fail law and make our error message include the byte position.
15:16:06 <glguy> logfiles    = [ "mail.log", "thttpd.log" ]
15:16:06 <glguy> logdir      = "/var/log"
15:16:06 <glguy> archivedir  = "/var/log/archive"
15:16:08 <glguy> oops
15:16:11 <glguy> oldnames <- glob (asDirectory logdir </> basename <.> "*.gz")
15:16:13 <glguy> I meant to show that
15:16:16 <dons> dcoutts: hmm. maybe knowing the byte position isn't very useful?
15:16:21 <dcoutts> dons, because either the failDesc is inside or outsite the Get monad
15:16:44 <dcoutts> dons, if it's inside then it can't be forced if it's outside it can't know the offset
15:16:56 <dcoutts> dons, it's one of these \_ -> _|_ vs _|_ issues
15:17:16 <dons> hmm. i'm ok with not reporting the byte position. it seems not so useful
15:17:24 <dons> Pseudonym++ patches
15:17:30 <sorear> urk! 59 messages!?
15:18:07 <Pseudonym> More haddockisation needed, of course.
15:18:23 <glguy> dons: I don't know Ruby, does this mean get current timestamp? stat.mtime.strftime '%Y%m%d'
15:18:41 <Pseudonym> Actually, speaking of timestamp, that's another issue that HTTP will have to deal with.
15:18:53 <Pseudonym> HTTP dates are yet another timestamp format.
15:19:03 <xerox> astrolabe: it ought to work with different 'a's every time?
15:19:11 <Pseudonym> What's the current thinking on date/time in Haskell?
15:19:21 <therp> hm, I just caught myself typing "apt-get install app-emacs/gnuserv" under gentoo.. after 4 years of happy usage. that's just like calling your honey by the name of your exgirlfriend.
15:19:31 <dibblego> Pseudonym, I'm thinking 0915 Tue Jan 30 2007
15:19:34 <glguy> ?hoogle rename
15:19:35 <lambdabot> Language.Haskell.TH.Lib.rename :: Pat -> Q ([(Name, Name)], Pat)
15:19:35 <lambdabot> Directory.renameDirectory :: FilePath -> FilePath -> IO ()
15:19:35 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
15:19:37 <dibblego> :)
15:19:41 <astrolabe> xerox: thanks.  It is needed to get it to compile.  The caller chooses the type of a.
15:19:45 <SamB> therp: hahaha
15:19:51 <Pseudonym> :-)
15:19:58 <SamB> therp: you should have stuck with apt!
15:19:59 <malebria> Do you think it's a good idea to keep instance Arbitrary DataType in the same file where DataType is defined or it's better to make the instance in a Tests file?
15:20:15 <therp> samb: that's what I sometimes think about my honey too. :>
15:22:03 <astrolabe> http://hpaste.org/185
15:22:11 <astrolabe> any help apprechiated
15:22:48 <dons> malebria: testtts usually
15:23:21 <hpaste>  glguy annotated "ruby v haskell, from the mailing list" with "better?" at http://hpaste.org/184#a1
15:24:50 <dons> glguy: could you define archivedir in terms of log dir?
15:25:01 <dons> definitely looks better
15:25:03 <glguy> sure (and I'll correct the imports
15:25:34 <TSC> Any ideas why this doesn't work?  (It doesn't download the images)
15:25:35 <TSC> wget -E -H -k -K -p http://haskell.org/gtk2hs/docs/tutorial/glade/index.html
15:25:36 <lambdabot> Title: Gtk2Hs » Documentation » Glade Tutorial
15:27:12 <hpaste>  glguy annotated "ruby v haskell, from the mailing list" with "adjusted" at http://hpaste.org/184#a2
15:27:34 <glguy> that type checks, I didn't run it :)
15:27:56 <hpaste>  dons annotated "ruby v haskell, from the mailing list" with "fmt for reading" at http://hpaste.org/184#a3
15:28:32 <dons> i wouldn't bother either with explict types or explict import lists when showing code to a ruby guy
15:28:37 <glguy> ok
15:28:45 <glguy> but you made the archivedir exist again
15:28:56 <dons> i didn't change that bit :)
15:29:18 <dons> why don't you reply to the guy on haskell-cafe@ with the nice solution?
15:29:20 <glguy> ok, cool
15:29:32 <bringert> Pseudonym: I don't know if anyone answered you question about date/time
15:29:40 <glguy> dons: what si the subject?
15:29:40 <bringert> Pseudonym: I think the time package works well
15:30:12 <Pseudonym> OK.
15:30:13 <bringert> Pseudonym: I've merged my parsedate package into the darcs version of the time package
15:30:17 <Pseudonym> Cool.
15:30:22 <Pseudonym> Does it parse HTTP dates?
15:30:53 <bringert> it uses a format string
15:30:58 * Pseudonym nods
15:31:28 <bringert> you may need to try a few formats to be able to parse all variations
15:31:32 <glguy> dons: you changed basenames to bases
15:31:33 <dons> glguy: ah, i see you found it
15:31:40 <dons> glguy: yeah, shorter idents :)
15:31:41 <glguy> :(
15:31:47 * bringert goes home
15:31:47 <malebria> dons: but isn't it bad to have instances and data definitions in different places?
15:31:48 <glguy> but you only changed one of them
15:32:03 <bringert> so, will there be a good http when I wake up?
15:32:13 <dons> gee. feel free to send your own code :) and to type check it .. :)
15:32:15 <dons> ?karma- dons
15:32:16 <lambdabot> You can't change your own karma, silly.
15:34:07 <yax1> i'm going to be performing with some haskell at this: http://lurk.org/
15:34:11 <lambdabot> Title: lurk
15:34:54 <dons> nice!
15:35:34 * sorear begins mass pull
15:35:57 <hpaste>  glguy annotated "ruby v haskell, from the mailing list" with "final version :-p" at http://hpaste.org/184#a4
15:36:24 <sorear> dons: what kind of release procedure is appropriate for vty 2.0.1, the 6-character urxvt fix for dylan?
15:36:57 <dons> just release it  with a small note
15:37:06 <dons> and have me upload the tarball to hackage before you do
15:37:16 <sorear> "small note"?
15:37:30 <bringert> kosmikus: works great, thank you!
15:37:46 <sorear> is there a lintian for cabal?
15:38:17 * sorear wonders if this would be a good project
15:38:30 <dcoutts> sorear, I keep wishing for one
15:38:38 <xpika2> @index matrixExcursion
15:38:39 <lambdabot> bzzt
15:38:58 <dcoutts> sorear, what cabal really lacks imho is proper dep analysis, well that and general love
15:39:15 <SamB> also testing
15:39:24 <SamB> and it is the first system, not the third one
15:39:25 <sorear> @tell shapr darcs pulling hpaste often freezes (kakapo problem?)
15:39:26 <lambdabot> Consider it noted.
15:39:27 <dcoutts> someone with lots of time and good taste needs to look at it
15:39:36 <dcoutts> SamB, aye
15:39:37 <SamB> I think the third system will be better
15:40:20 <glguy> sorear: possibly the resource limits...
15:41:53 <xpika2> @where preservingmatrix
15:41:54 <lambdabot> I know nothing about preservingmatrix.
15:42:00 <xpika2> @index preservingmatrix
15:42:01 <lambdabot> bzzt
15:42:03 <syntaxfree> @where to find love
15:42:04 <lambdabot> I know nothing about to.
15:42:06 <glguy> astrolabe: did you figure out your type issue?
15:42:26 <xpika2> @index preservingMatrix
15:42:27 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
15:43:06 <alexj> dcoutts: dependencies are already expressed in the source.
15:43:23 <dcoutts> alexj, right, just Cabal knows nothing about them.
15:43:39 <alexj> searchpath does import chasing via mappings from module names to urls.
15:43:42 <glguy> ?type asTypeOf
15:43:43 <lambdabot> forall a. a -> a -> a
15:43:50 <alexj> that seems like a better approach.
15:44:15 <dcoutts> alexj, yeah, I'm sure it's not hard, it just needs doing. eg proper c2hs support is impossible without it.
15:44:16 <alexj> regardless of whether you want to use searchpath or cabal otherwise.
15:44:51 <alexj> c2hs?
15:45:01 <sorear> ghci and ghc --make should be eliminated, the successor to cabal should handle *all* chasing and preprocessing itself.
15:45:07 <alexj> dcoutts: Have you used searchpath?
15:45:10 <sorear> alexj: it's a C interface preprocessor
15:45:16 <dcoutts> alexj, for Haskell modules cabal can get away with not knowing since it hands off to ghc --make, but for c2hs it has to invoke c2hs in the right order
15:45:26 <dcoutts> alexj, no, but I think that solves a different problem.
15:46:07 <alexj> searchpath basically converts --internet modules.map into -isomedir
15:46:31 <alexj> if cabal is intended to replace --make then they are addressing similar issues.
15:46:40 <xpika2> @index (:=)
15:46:41 <lambdabot> Control.Parallel.Strategies
15:46:52 <xpika2> @hoogle(:=)
15:46:53 <lambdabot> Unknown command, try @list
15:46:55 <xpika2> @hoogle (:=)
15:46:56 <lambdabot> Did you mean: (:=)
15:46:57 <lambdabot> Prelude.undefined :: a
15:46:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:47:33 <alexj> sorear: oh yeah.   shae was talking about adding c2hs support to searchpath.
15:47:42 <dcoutts> alexj, yeah, I'm sure there is some code floating about we can borrow. It just needs to look at each module and see what it imports, then find it etc. And it also needs to do it for pre-processors, eg happy, alex, c2hs, hsc2hs, cpp etc.
15:48:14 <dcoutts> alexj, so what does searchpath use to parse the .hs files ?
15:48:17 <sorear> alexj: what's searchpath?  I was just stating a blind musing, the cabal code is Too Scary atm.
15:48:19 <dcoutts> to find their imports
15:48:32 <alexj> sorear: http://searchpath.org
15:48:33 <lambdabot> Title: SearchPath
15:48:34 <dons> ?hoogle :=
15:48:35 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':='
15:48:39 <dons> silly hoogle
15:48:47 <alexj> dcoutts: really simple regular expression stuff.
15:48:52 <sorear> dons: what did you mean by a "small note"
15:49:03 <alexj> hold on and I'll show you.
15:49:12 <sorear> dons: what do I need to double check before hackage?
15:49:36 * sorear keeps spoonerizing haskage.hackell.org
15:49:36 <dons> you need to make sure you've got a category, and synopsis sectoin
15:49:52 <dons> try using the 'check' button on the upload page
15:49:54 <dons> which will lint the .caba file
15:50:17 <alexj> moduleRE = mkRegex "^[ \t]*module[ \t]+([^ \t\n\r]+).*$"
15:50:19 <alexj> importRE = mkRegex "^[ \t]*import[ \t]+(qualified[ \t]+)?([^()\n\r \t]+).*$"
15:50:46 <alexj> dcoutts: that and some simple stuff for handling .lhs files.
15:51:00 <Failure02> how can i make a polymorphic constant? i want x to be 0 when x is a Num, and to be "" when it is a String.
15:51:17 <Failure02> i've come up with this solution, but it's not pretty, and i can't generalise to all Num classes: http://www.mathbin.net/7559
15:51:19 <lambdabot> Title: MathBin.net - Untitled
15:51:48 <dcoutts> alexj, right, so for cabal we need a simple framework to be able to plug in these things, eg the processing for .hs or .lhs or .whatever files, and then build a big dep graph..
15:51:49 <Failure02> (i was going to use hpaste, but there was no submit button?)
15:51:57 <dons> Failure02: use the 'new' button
15:51:59 <dons> ?paste <-- here
15:52:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:52:11 <dons> Pseudonym: applied
15:52:12 <Failure02> i did. there's no submit button when i've pasted
15:52:19 <dons> hmm?
15:52:22 <Pseudonym> Cool.
15:52:31 <mauke> instance (Num a) => IdentityElement a where identityElement = 0
15:52:34 <alexj> searchpath already builds the big graph.
15:52:35 <dons> the button says 'save'
15:52:43 <sorear> dons: what's the difference between "Graphics", "Interfaces" and "User Interfaces"? or is this just an artifact of the lack of standardization?
15:52:47 <Pseudonym> dons, one thing.  I introduced a type class that I use a lot in my own code.  it should really go somewhere else.
15:52:49 <alexj> at least for .hs and .lhs files.
15:52:50 <Failure02> mauke: ghc didn't accept that
15:52:55 <Pseudonym> class TestableProperty prop t | prop -> t where
15:52:56 <Pseudonym>     is :: prop -> t -> Bool
15:52:56 <dons> Pseudonym: so I see.
15:52:57 <mauke> Failure02: use more -foptions
15:53:02 <dons> yeah, that looks useful
15:53:07 <Failure02> is there no cleaner way to do this?
15:53:14 <Failure02> btw, hpaste works in firefox but not opera
15:53:15 <Pseudonym> That avoids the proliferation of isFoo, isBar.
15:53:25 <mauke> like -fglasgow-exts -fallow-undecidable-instances
15:53:28 <alexj> the "social" issue is the maintenance of mappings from module names to urls.
15:53:39 <sorear> Failure02: hpaste works in lynx!
15:53:42 <malebria> I think I'll can't use quickCheck.
15:53:48 <syntaxfree> Pseudonyn: that's an excellent proposal. You should post it to -cafe.
15:53:51 <dons> Failure02: can you do a screenshot from opera, and report it to glguy
15:53:56 <Failure02> mauke: it sounds bad to use fallow-undecidable-instances
15:53:56 <Pseudonym> I did once.
15:53:59 <Pseudonym> :-)
15:54:02 <alexj> see e.g. http://searchpath.org/default.map
15:54:07 <Pseudonym> Well, it was part of another library.
15:54:11 <syntaxfree> There should be a better ballot for proposals like that.
15:54:16 <sorear> dons: what categorey shoud I use for vty?  There are three that look plausible
15:54:26 <sorear> dons: what's the difference between "Graphics", "Interfaces" and "User Interfaces"?
15:54:36 <syntaxfree> my Comprehensible proposal got laughed down into oblivion, so I guess it wasn't any good, but I like yours!
15:54:37 <Pseudonym> The thing is, the way I've described it depends on MPTCs, which may go away in haskell-prime.
15:54:37 <hpaste>  malebria pasted "Big quickCheck output" at http://hpaste.org/186
15:54:45 <malebria> This is just so difficult to debug.
15:55:12 <syntaxfree> MPTCs might go away in haskell'?
15:55:13 <sorear> what are the rules for choosing hackage categories?
15:55:19 <Pseudonym> Sorry, I meant fundeps.
15:55:21 <xerox> Pseudonym: really? Eeek.
15:55:21 <xerox> And how do you do Monad Transformers?
15:55:28 <xerox> Oh no :(
15:55:30 <Pseudonym> Blerg.  Need caffeine.
15:55:34 * rahikkala eeeks at all the haskell-cafe digests that suddenly appeared in his inbox
15:55:37 <syntaxfree> man, the only thing that bothers me in Haskell is that they keep on removing good features.
15:55:39 <Failure02> hm this is weird. if i resize the window so that the textbox doesn't fit, the save button apperas
15:55:41 <Pseudonym> To be replaced by associated types, of course.
15:55:41 <hpaste>  dons pasted "polymorphic zero" at http://hpaste.org/187
15:55:42 <dons> Failure02: ^^
15:55:43 <SamB> xerox: don't get scared
15:55:43 <syntaxfree> I'm addicted to fundeps by now.
15:55:46 <Pseudonym> Personally, I think we need both.
15:55:51 <Failure02> i'm using a non-stable version of opera though
15:55:57 <dons> sorear: same user interfaces
15:56:06 <SamB> I've already started translating the MTL, I stopped because the features I was using weren't implemented yet hough
15:56:07 <sorear> dons: ?
15:56:18 <sorear> dons: I need to pick one, don't I?
15:56:23 <dons> pick one. Users Interfaces looks good
15:56:27 <qwr> hpaste in opera "loses" save button, when the window is large enough
15:56:41 <xerox> Deeps of fun, fundeps!
15:56:42 <sorear> glguy: ping
15:56:50 <sorear> otherwise use @tell glguy OH NO!
15:56:52 <dons> ah ok.thanks qwr
15:56:57 <gotaku> What does const mean?
15:57:00 <sorear> gotaku: K
15:57:01 <SamB> xerox: you don't like associated type synonyms?
15:57:02 <dons> :t const
15:57:03 <lambdabot> forall a b. a -> b -> a
15:57:12 <dons> > const 1 2
15:57:13 <lambdabot>  1
15:57:14 <sorear> gotaku: it's Shoernfinkel's K combinator
15:57:15 <xerox> SamB: what are them?
15:57:21 <dons> > foldr const 0 [1..10]
15:57:22 <malebria> dons: do you have any suggestions?
15:57:22 <mauke> Schönfinkel
15:57:22 <lambdabot>  1
15:57:32 <qwr> and when the in-opera window is maximised, the save seems to never show up
15:57:36 <SamB> xerox: they are what might be replacing fundeps
15:57:40 <malebria> dons: do you think it's possible to use quickCheck in a case like that?
15:57:41 <qwr> hmm still shows
15:57:46 <dons> Failure02: did you see my Const class/
15:57:54 <syntaxfree> Haskell needs to stop removing features!
15:57:57 <qwr> if i make window small enough
15:57:57 <Failure02> no, missed it
15:58:01 <SamB> syntaxfree: what?
15:58:04 <xerox> SamB: how does it work?
15:58:06 <SamB> you don't like better ones?
15:58:07 <sorear> syntaxfree: Haskell needs to stop adding features!
15:58:08 <dons> Failure02: http://hpaste.org/187
15:58:28 <Pseudonym> I disagree with that.  There are some things in GHC which are definitely misfeatures.
15:58:29 <xerox> sorear: ssssshhh!!
15:58:30 <SamB> syntaxfree: you wanted C++?
15:58:31 <gotaku> K combinator?
15:58:33 <Failure02> dons: that's precisely what i've done
15:58:41 <Pseudonym> Implicit parameters spring to mind.
15:58:45 <syntaxfree> at least allow a flag in GHC.
15:58:50 <dons> malebria: write a Show instance that prints the output in a shorter manner
15:58:55 <Pseudonym> What we SHOULD have is compiler support for implicit configuration, IMO.
15:58:56 <syntaxfree> -fallow-deprecated-practices
15:58:59 <dons> Failure02: btw, that's almost a monoid
15:59:05 <dons> (its half of a monoid)
15:59:08 <dons> ?docs Data.Monoid
15:59:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
15:59:11 <edwinb> maybe if Haskell and C++ add enough features, they'll eventually both be the same language
15:59:14 * edwinb runs away
15:59:19 <syntaxfree> Pseudonym: maybe. But what do you tell people developing software right now?
15:59:27 * xerox catches edwinb 
15:59:29 <Pseudonym> Don't use implicit parameters.
15:59:34 * edwinb struggles
15:59:36 <syntaxfree> I mean, there's no stable base to code against if features are removed from version to version.
15:59:38 <Pseudonym> You don't need them.
15:59:38 <SamB> syntaxfree: I don't here you whining about ?variables being removed!
15:59:38 <qwr> dons: hmm got it. hpaste width > 800 px in opera. and the save is gone ;)
15:59:45 <Pseudonym> Yeah, exactly.
15:59:51 <SamB> anyway, MPTCs aren't in h98
15:59:53 <Pseudonym> Have you ever used implicit parameters?
15:59:55 <dons> qwr, @tell glguy, so he can fix it
15:59:57 <syntaxfree> I don't know "?variables", whatever they are.
16:00:01 <xerox> edwinb - come here... do you know about what is substituting fundeps?
16:00:03 <Pseudonym> Right, then.
16:00:29 <Pseudonym> If you've never used ?variables (i.e. implicit parameters), then you won't miss them.
16:00:31 <edwinb> No, I wasn't paying attention...
16:00:41 <Pseudonym> In the mean time, don't use them, because they're dumb.
16:00:53 <Pseudonym> Superior solution: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
16:01:12 <Pseudonym> All we need is some compiler support to ensure that configuration data is garbage collected.
16:01:21 <SamB> well, plus, who actually uses fundeps in their own code?
16:01:24 <syntaxfree> bah, fundeps are about the only GHC type system extension I manage to grok ;)
16:01:28 <SamB> not just because the MTL does?
16:01:42 <Pseudonym> I use fundeps all the time, but probably 60% of them could be replaced with associated types.
16:01:43 <dons> syntaxfree: you grok fundeps??
16:01:44 <SamB> syntaxfree: you'll find AT synonyms even easier
16:01:46 <Failure02> i'm getting a bizarre error now though
16:01:50 <edwinb> I use fundaps occasionally, but I never actually need to
16:01:53 <dons> hardly anyone groks fundeps in their fullness
16:01:55 <Failure02> " Overlapping instances for IdentityElement [Char]"
16:01:55 <qwr> @tell glguy hpaste save button disappears in opera, when the window width is > 800px
16:01:55 <lambdabot> Consider it noted.
16:02:05 <syntaxfree> I didn't say "in their fullness".
16:02:14 <syntaxfree> I know when I'm gonna need'em and how to use'em when I need'em.
16:02:18 <dons> i don't know anyone, 'cept maybe Suzmann, who actually understands what's really going on.
16:02:19 <Pseudonym> The thing is, ATs and fundeps seem to denote different programmer intentions.
16:02:27 <SamB> Pseudonym: yeah
16:02:34 <syntaxfree> ATs?
16:02:39 <Pseudonym> I intend ATs maybe 60-70% of the time and fundeps the rest.
16:02:44 <SamB> I don't think that fundeps are necessarily going bye-bye
16:02:52 <SamB> I think it is still up in the air
16:02:56 <sorear> @spell infecilities
16:02:57 <lambdabot> infelicities imbecilities incivilities infidelities facilities
16:03:03 <Pseudonym> Apart from the 2-5% or so which are general nasty type hackery for which fundeps seem the best approach.
16:03:04 <dons> once mtl is rewritten to use ATs...
16:03:14 <SamB> but, they aren't going in without some better termination guarentees, is my understanding...
16:03:17 <syntaxfree> Pseudonym: how would you express your own Testable class with this new approach?
16:03:22 <dons> the remaining prolog-on-the-typelevel stuff can be done with fundeps
16:03:27 <Pseudonym> syntaxfree: Something like this.
16:03:39 <Pseudonym> class TestableProperty prop where
16:03:40 <SamB> dons: are the ATs ready for this yet?
16:03:46 <Pseudonym>     type t
16:03:49 <SamB> because I guess I could do that
16:03:50 <dons> SamB: I *think* so.
16:03:52 <Pseudonym>     is :: prop -> t -> Bool
16:03:55 <Pseudonym> Or something.
16:03:59 <Pseudonym> Not sure what the syntax is.
16:04:02 <Pseudonym> Then you'd say:
16:04:05 <syntaxfree> ah, yes. I don't grok the prolog on the typelevel stuff yet, no.
16:04:06 <Pseudonym> instance TestableProperty OK where
16:04:11 <Pseudonym>     type t = Status
16:04:15 <SamB> though I'm working on this now
16:04:22 <Pseudonym>     is _ (Status c) = c == 200
16:04:31 <Pseudonym> Make sense?
16:04:31 <pbx> Does anyone know a place selling the Graham Hutton book (http://www.cs.nott.ac.uk/~gmh/book.html) that takes Paypal?  It's not really out in the US yet so I'm having a hard time.
16:04:31 <xerox> Pseudonym: the modular arithmetic example is pretty cool
16:04:34 <lambdabot> Title: Programming in Haskell
16:04:39 <Failure02> Num and [a] overlap
16:04:40 <Pseudonym> Yeah, it is.
16:05:04 <syntaxfree> I need to learn more about the theory behind type classes.
16:05:09 <mauke> Failure02: are you sure it's not String and [a]?
16:05:16 <Pseudonym> I like implicit configuration, but I don't like the way it's implemented in the paper.
16:05:23 <Pseudonym> I think you really need a small amount of compiler support.
16:05:41 <xerox> GTG, goodnight.
16:05:44 <Failure02> Failure02: yeah
16:05:47 <Failure02> hold
16:05:54 <Pseudonym> Also, this is a classic example of where fundeps/ATs would work nicely.
16:05:59 <SamB> http://naesten.dyndns.org:8080/repos/hSelf2/
16:06:01 <lambdabot> Title: Directory listing for /repos/hSelf2/
16:06:07 <Pseudonym> Like TestableProperty, you could make a ConfigurationParameter class.
16:06:12 <SamB> <- *that* is what I'm working on right now
16:06:18 <Pseudonym> Which lets you tag configuration data.
16:06:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/188
16:06:49 <Failure02> mauke: http://hpaste.org/188
16:06:56 <SamB> I've started work on the "compiler"
16:07:40 <Sinner> newb question:
16:07:43 <SamB> which basically converts the output of the parser into code the interpreter will be able to run...
16:07:51 <dons> Failure02: why all the flags?
16:07:54 <SamB> @where hSelf
16:07:54 <lambdabot> I know nothing about hself.
16:07:57 <SamB> @where self
16:07:58 <lambdabot> I know nothing about self.
16:07:58 <dons> do you have some instances other than those in the code?
16:08:11 <SamB> @where+ hSelf2 http://naesten.dyndns.org:8080/repos/hSelf2/
16:08:12 <lambdabot> Done.
16:08:14 <sorear> Sinner: yes?
16:08:20 <pbx> No book shopping tips then?
16:08:25 <Failure02> dons: the fallow one is needed for the Num in an instance declaration
16:08:28 <dons> Failure02: that code on its own needs no extensions or flags
16:08:29 <Sinner> nevermind, as i was typing it out i figured it out
16:08:32 <Sinner> :P
16:08:33 <Sinner> sry
16:08:35 <dons> ah ok
16:08:41 <dons> let me se.e...
16:09:04 <Failure02> and the fglasgow just tagged along when i copypasted the line into a new file :)
16:09:06 <syntaxfree> hmm.
16:09:22 <syntaxfree> Haskell needs somehow better syntax extensibility.
16:09:29 <dons> ?instances Num
16:09:30 <lambdabot> Double, Float, Int, Integer
16:10:01 <syntaxfree> It seems to me that often typesystem extensions are first proposed as stuff that can be expressed in "straight" Haskell but gets contrived.
16:10:17 <SamB> syntaxfree: hmm
16:10:18 <SamB> ?
16:10:20 <syntaxfree> I know about TH, but can  TH extend typesystem syntax?
16:10:47 <SamB> have you read that paper about power that someone reddited a while back?
16:10:51 <Failure02> it seems you can make [a] inherit Num
16:10:55 <SamB> which was apparantly written decades ago?
16:10:57 <mauke> Failure02: -fallow-overlapping-instances?
16:11:14 <Failure02> i don't get what you're asking
16:11:17 <sorear> syntaxfree: it's like that mark twain quote.  people use typesystem extensions because they are too dumb/hurried to not use them.
16:11:28 <SamB> sorear: do you know what paper I mean?
16:11:33 <Failure02> is that what the fallow flag does?
16:12:01 <mauke> Failure02: it's a suggestion to add that flag
16:12:10 <sorear> SamB: power doesn't belong on programming reddit
16:12:10 <Failure02> i added it.
16:12:12 <dons> you can make [a] an instance of Num, but its not a good idea
16:12:21 <mauke> Failure02: then it works.
16:12:24 <Failure02> no
16:12:33 <Failure02> http://hpaste.org/188 this does not work
16:12:48 <mauke> Failure02: that doesn't contain -fallow-overlapping-instances
16:12:48 <Failure02> because [a] can inherit Num
16:12:52 <Failure02> yes it does
16:12:55 <mauke> where?
16:12:56 <Failure02> oops it doesn't
16:13:03 <Failure02> i just read the fallow part :)
16:13:11 <Failure02> err, these flags sound dangerous
16:13:30 <Failure02> won't they bite me in the ass later?
16:13:32 <SamB> well yeah
16:14:44 <sorear> dons: http://members.cox.net/stefanor/vty/dist/vty-2.0.2.tar.gz
16:14:55 <sorear> (expect to wait a few minutes :( )
16:15:32 <sorear> heh
16:15:38 <sorear>                                                                    http://hackage.haskell.org/ModHackage/Hackage.hs?action=home
16:15:38 <sorear> There was an error: user error (Could not find module `Distribution.ParseUtils':
16:15:38 <sorear>   it is a member of package Cabal-1.1.1, which is hidden
16:15:38 <sorear>   (imported from /srv/www/hackage.haskell.org/public_html/ModHackage//Packages.hs)
16:15:41 <sorear> )
16:16:30 <hpaste>  dons annotated "(no title)" with "monoid => zero" at http://hpaste.org/188#a1
16:16:35 <dons> Failure02: ^^
16:17:34 <sorear>                                                      hackageDB :: [Package]
16:17:47 <sorear> ooh, a LIST ? :)
16:18:32 <dons> where's MonadZero these days?
16:18:39 <Failure02> well that's just the same thing
16:19:07 <sorear> Cale
16:19:13 <sorear> 's imagination, I believe
16:19:27 <Failure02> i guess i could define it for all datatypes i need, but i think it's ugly
16:19:38 <dons> more flags, ore more portable. your choice :)
16:20:08 <sorear> dons: upload finished
16:20:30 <dons> sorear: you had upload perms already?
16:20:41 <sorear> dons: no, to my ISP webhost
16:20:45 <dons> ah
16:20:47 <Failure02> all i wanted to do was to multiply matrices, and i get myself into all this trouble :'(
16:20:50 <dons> you want it on hackage then/
16:20:56 <dons> Failure02: you're getting side tracked.
16:20:57 <sorear> since hpaste won't take tarballs :)
16:21:02 <dons> you know how to write the zero instance
16:21:07 <dons> so now proceed!
16:21:11 <dons> less talk, more code!  :)
16:21:18 <sorear> getting sidetracked is so fun
16:21:38 <sorear> dons: so, should I announce to the list?
16:21:54 <dons> you want it on hackage first I imagine
16:22:03 <Failure02> well i'm using strassen's algo, and i need to pad matrices with zeros for that. but if i hardcoded in 0s, i couldn't make matrices of strings, so i needed to do something like this
16:22:23 <sorear> Failure02: you can multiply strings !?!?
16:22:45 <sorear> Failure02: since you need a ring (Num) anyway, why not use 0?
16:22:57 <Failure02> yeah it's an amazing new paradigm of maths!
16:23:00 <Failure02> :)
16:23:30 <Failure02> i wanted a nice method for pretty-printing matrices without first converting to lists
16:23:36 <Failure02> but i'm overcomplicating everything
16:24:09 <sorear> if your math is that different from usual, be sure to check the proof of validity of sjanssen's algorithm
16:24:19 <Failure02> i'm kidding :p
16:24:43 <sorear> slip: s/sjanssen/strassen/
16:24:57 * sjanssen is proud to be confused with Strassen :)
16:25:05 <Failure02> hehe
16:26:19 <Failure02> well i'm going to bed
16:26:21 <Failure02> thanks for the help
16:28:58 <dons> ?users
16:28:59 <lambdabot> Maximum users seen in #haskell: 322, currently: 291 (90.4%), active: 48 (16.5%)
16:29:17 <malebria> dons: thanks for the quickcheck tips.
16:29:25 <malebria> dons: I think it'll be very helpfull.
16:29:36 <malebria> dons: Just found some bugs here.
16:29:45 <malebria> Good night.
16:29:46 <dons> cool!
16:32:03 <chessguy> i'm curious whether most would say that the logical jump in understanding from no monads to monads is {bigger, smaller, the same as} the jump from just monads to, say, comonads or arrows
16:34:11 <sorear> equally imperceptable, but I suspect I'm fairly unique there :(
16:35:40 <hpaste>  zarvok pasted "hs-plugins compile error" at http://hpaste.org/189
16:35:51 <zarvok> I'm getting that error when I try to compile hs-plugins
16:35:56 <zarvok> anyone care to advise?
16:35:59 <sorear> yes
16:36:14 <sorear> zarvok: that is characteristic of trying to use the wrong compiler
16:36:18 <dons> zarvok: which version of ghc?
16:36:20 <zarvok> 6.6
16:36:24 <sorear> zarvok: hs-plugins only works on 6.4.x
16:36:29 <zarvok> well then
16:36:31 <dons> 6.6? in which case a) wait til hs-plugins is ported to 6.6., or downgrade to ghc 6.4.2
16:36:37 <zarvok> heh, that explains it, thanks
16:36:44 <dons> (patches are appearing, ping lemmih for the hs-plugins+6.6 status)
16:36:49 <dons> http://programming.reddit.com/info/11s2p/comments
16:36:50 <lambdabot> Title: Classic paper: Definitional Interpreters for Higher-Order Programming Languages  ...
16:36:54 <sorear> zarvok: actually you don't need to downgrade
16:37:19 <sorear> zarvok: GHC 6.4.2, 6.6, and 6.7 can peacefully coexist on the same computer
16:37:26 <sorear> zarvok: they do on mine
16:37:50 <dons> yeah, i mean, just install ghc 6.4....2
16:38:12 <sorear> dons: is that enumFromTo or slow wifi?
16:38:15 <zarvok> yeah, unfortunately I had a build of hope all set up except for that piece, so now I have to redo a bunch of stuff for 6.4
16:38:27 <zarvok> life will go on though
16:38:31 <dons> slow fingers, actually
16:38:41 <sorear> zarvok: what does hope have to do with this?
16:38:57 <sorear> or are you talking about shapr's blog engine?
16:39:21 <zarvok> I need some database package or the other that needs hs-plugins
16:39:38 <zarvok> hope has a... lengthy list of requirements
16:41:31 <zarvok> bringert's blog engine, I think
16:43:00 <gotaku> So what does const do?
16:43:24 <sorear> gotaku: it returns its first argument
16:43:27 <sorear> @src const
16:43:28 <lambdabot> const x _ = x
16:43:37 <sorear> ^^^ explanitory?
16:43:55 <chessguy> @type const
16:43:57 <lambdabot> forall a b. a -> b -> a
16:44:01 <gotaku> What would that be used for?
16:44:11 <sjanssen> @. djinn type const
16:44:13 <lambdabot> f a _ = a
16:44:31 <sorear> > zipWith const "elelphant" "foobar"
16:44:32 <lambdabot>  "elelph"
16:44:43 <sorear> > map (const 'x') "elephant"
16:44:45 <lambdabot>  "xxxxxxxx"
16:45:10 <sorear> it's so general it has dozens if not hundereds of uses
16:45:11 <gotaku> Interesting.
16:47:24 <sorear> const is *old*
16:48:07 <sorear> a while (30-60 yrs) ago, Shoenfinkel proved that every function could be written using only ap, const, and parens.
16:48:22 <dons> hmm. 80 years perhaps...
16:48:25 <dons> 90 maybe
16:48:27 <gotaku> Gah?
16:48:41 <emu> :t ap
16:48:43 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:48:47 <nornagon> :t parens
16:48:49 <lambdabot> Not in scope: `parens'
16:48:56 <nornagon> i guess you mean ()
16:48:59 <sorear> he called ap S and const K however ; his construction is known today as the SK calculus
16:49:02 <sorear> nornagon: yea.
16:49:28 <sorear> nornagon: By 'ap', I am also specifically refering to the (a ->) instantiation of ap
16:49:31 <dons> ?check \xs -> not (null xs) ==> head (xs :: T) ==  foldr const undefined xs
16:49:32 <lambdabot>  OK, passed 500 tests.
16:49:44 <sorear> @src T
16:49:45 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:49:48 <sorear> what is T?
16:49:50 <dons> Int
16:50:12 <dons> that's actually the build/foldr rule for head
16:50:22 <dons> const++
16:50:46 <gotaku> What does ap do? I tried reading a description but I don't really understand it.
16:50:55 <dons> ?src ap
16:50:56 <lambdabot> ap = liftM2 id
16:51:12 <dons> lifts application into a monad
16:51:16 <dons> ?src liftM2
16:51:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:51:30 <sorear> in this case, ap f g x = f x (g x)
16:51:47 <sorear> (in reality it is more general, but that's not important now)
16:51:55 <dons> f `ap` g ==  do a <- f ; b <- g ; return (a b)
16:51:56 <emu> > foldl (+) 0 `id` [1,2,3]
16:51:56 <sorear> > ap zip tail [0..6]
16:51:58 <lambdabot>  6
16:51:58 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)]
16:52:09 <sorear> > zip [0..6] (tail [0..6])
16:52:11 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)]
16:52:26 <dons> yay for equational reasoning!
16:52:32 <dons> don't leave home without it
16:52:57 <TomMD> Equational reasoning you don't leave home without: 2 + 2 = 5
16:54:16 <sorear> I wonder what curry_howard(paraconsistant logic) would look like
16:57:42 <allbery_b> > let 2 + 2 = 5 in 2 + 2 -- :)
16:57:43 <nornagon> @index getArgs
16:57:44 <lambdabot>  5
16:57:44 <lambdabot> System.Environment
16:58:58 <nornagon> hm, how do i catch EOF from getChar?
16:59:07 <sorear> catch ?
16:59:28 <allbery_b> Control.Exception.catch
16:59:30 <sorear> :t IO.catch
16:59:33 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:59:36 <allbery_b> don't think Prelude.catch can do it
16:59:38 <sorear> ^^^ you want
16:59:40 <allbery_b> or IO.catch
16:59:40 <nornagon> if getChar would otherwise raise an exception when it got an EOF, i want to do something else instead
16:59:44 <nornagon> hm.
17:00:02 <sorear> allbery_b: if Prelude.catch can't catch IO errors, what's it for?
17:00:22 <allbery_b> not sure, but it didn't seem t catch muc of anything when I was playing around the other day
17:00:37 <allbery_b> maybe I was doing it wrong and it's IO.catch in disguise
17:00:44 <SamB> probably it does catch IO errors
17:00:55 <SamB> :t catch
17:01:12 <nornagon> Prelude> do { a <- getChar; return a }
17:01:12 <nornagon> ^D'\EOT'
17:01:48 <SamB> that is apparantly not considered an error
17:01:59 <nornagon> maybe ghci does weird things to ^D?
17:02:09 <allbery_b> that looks like a raw read
17:02:11 * dcoutts launches 7 parallel builds of Gtk2Hs on 5 machines, covering 5 arches (though not in 1-1 correspondence to the machines) and covering 3 versions of GHC and Gtk+
17:02:11 * dcoutts needs a build bot
17:02:13 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:02:40 <SamB> dcoutts: why don't you set one up ...?
17:02:48 <SamB> apt-get install buildbot
17:03:12 <dcoutts> SamB, yeah, I should spend some time to learn more about it set it up etc
17:03:17 <gotaku> Why can't anyone seem to create a good monad tutorial.
17:03:30 <allbery_b> hm.  yep, it';s in raw mode.  may be a ghci special though
17:03:38 <allbery_b> try it in a compiled program
17:04:02 <dibblego> because in learning what a monad is, you lose your ability to write - they are in contradiction
17:04:20 <sorear> because monads are too simple to explain?
17:04:22 <dibblego> using a non-safe language like English cannot be used after learning about monads
17:04:43 <SamB> dibblego: maybe it is like the buddha in zen buddhism or whatever?
17:05:36 <dibblego> it's the fact that it challenges deeply internalised beliefs
17:05:40 <dibblego> regardless of simplicity
17:06:13 <dibblego> nobody likes learning that their belief system is undermined by a piece of compelling evidence
17:06:37 <gotaku> Part I of "All about Monads" is fine, but they Part II assumes things that the first part never even talked about.
17:07:40 <nornagon> :t (catch getChar (\a -> return '\0'))
17:07:42 <lambdabot> IO Char
17:08:15 <nornagon> ^- does that do what I think it does? (that is, catch errors and return 0 when one occurs)
17:09:45 <sorear> nornagon: yes
17:09:46 <sjanssen> nornagon: yes, it does
17:10:28 <nornagon> 'k.
17:13:24 <allbery_b> gotaku: everyone needs a different way over the "hump", so there are lots of different tutorials --- try a bunch, one of them (or some combination) will eventually "click" and you'll get it
17:14:26 <allbery_b> it also seems to help to (a) work with (>>=) and return directly insead of do-notation; (b) play with simple monads like Maybe, Either, [], maybe State
17:15:26 <allbery_b> try to not be tripped up when something mentions category theory, it may have been necessary to invent the concept but I've managed to get by quite well without comprehending it :)
17:16:44 <SamB> allbery_b: no CT comprehensions, you say?
17:17:01 <allbery_b> <-- clueless :)
17:19:27 <sorear> I had to *quit irc* in order to upgrade emacs. :(
17:19:41 <sorear> c'mon yirc!
17:20:22 <sorear> @users
17:20:22 <lambdabot> Maximum users seen in #haskell: 322, currently: 286 (88.8%), active: 49 (17.1%)
17:25:42 <dons> sorear: why not hack on hircules?
17:25:49 <dons> ?where hircules
17:25:49 <lambdabot> I know nothing about hircules.
17:25:51 <Cale> sorear: yeah?
17:25:54 <dons> ?google hircules haskell
17:25:55 <lambdabot> http://haskell.org/hircules/
17:25:56 <lambdabot> Title: Hircules - an IRC client in haskell
17:26:08 <dons> ?where+ hircules http://haskell.org/hircules/
17:26:08 <lambdabot> Done.
17:27:15 <sorear> ERC is not as nice as irssi, but it is much better behaved in the emacs OS.
17:28:48 <dons> we really need a generic elisp-> haskell binding
17:28:54 <dons> for writing emacs plugins in haskell
17:28:59 <dons> i'd switch to emacs if we had that...
17:29:15 <dons> well, ok. maybe not.
17:29:34 <SamB> this is the paper I mentioned earlier: http://programming.reddit.com/info/u719/comments
17:29:36 <lambdabot> Title: Expressive power of languages: design patterns considered harmful ... (1990) (re ...
17:29:58 <newsham> ?fact xslt
17:29:59 <lambdabot> xslt: not to be discussed in #haskell
17:30:22 <SamB> ?fact haskell
17:30:23 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
17:30:29 <SamB> ?fact you
17:30:29 <lambdabot> I know nothing about you
17:30:32 <SamB> ?fact me
17:30:33 <lambdabot> I know nothing about me
17:30:36 <SamB> ?fact myself
17:30:37 <lambdabot> I know nothing about myself
17:31:01 <bd_> ?fact I
17:31:02 <lambdabot> I know nothing about i
17:31:40 <SamB> ?fact java
17:31:41 <lambdabot> I know nothing about java
17:31:44 <SamB> ?fact hell
17:31:45 <lambdabot> I know nothing about hell
17:31:49 <SamB> ?fact function
17:31:49 <lambdabot> I know nothing about function
17:31:51 <SamB> ?facts
17:31:51 <lambdabot> I can not handle empty facts.
17:31:59 <SamB> ?fact-list
17:32:00 <lambdabot> Unknown command, try @list
17:32:01 <siti> ?fact haskell
17:32:02 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
17:32:08 <SamB> @quote
17:32:09 <lambdabot> fsbot says: English -> English: no matching translation services found.
17:32:17 <SamB> hah
17:32:21 <bd_> id!
17:32:33 <SamB> maybe it doesn't chain services?
17:32:37 <newsham> ?babel en fr red
17:32:38 <lambdabot>   rouge
17:32:41 <SamB> that could totally mangle things you know...
17:32:50 <bd_> ?babel en kr red
17:32:51 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language kr not supported
17:32:53 <bd_> :/
17:33:03 <bd_> If you want mangling, korean's the way to go >.>
17:33:08 <bd_> ?babel en ja red
17:33:10 <lambdabot>   can't parse this language
17:33:12 <newsham> ?babel en fr would you like some wine with that, sir?
17:33:13 <lambdabot>   vous aiment du vin avec le ce, monsieur ?
17:33:16 <jre2> @list
17:33:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:33:17 <allbery_b> ?babel en he red
17:33:18 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language he not supported
17:33:40 <gotaku> Is the Reader Monad sort of like State?
17:33:45 <newsham> ?elite bable en fr all your base are belong to us
17:33:47 <lambdabot> b4813 3n FR 4lL Y0UR B4sE aR3 bEl0n9 7o uz
17:33:59 <newsham> ?. elite babel en fr all your base are belong to us
17:34:01 <lambdabot> t0ute VOTR3 bA$3 s0n+ AppAR7ienN3N+  NOU$
17:34:10 <allbery_b> reader is kinda like state on steroids
17:34:20 <allbery_b> multiple state values, pushable/poppable environments
17:34:48 <allbery_b> it's the sort of thing you use for variable bindings when parsing a programming language
17:35:33 <SamB> ?babel en en hello!
17:35:34 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:35:48 <newsham> babel is prone to failure.
17:35:52 <gotaku> I'm still having trouble understanding just the State monad
17:36:12 <jcreigh> yeah, State's a mind-bender alright.
17:36:32 <sorear> glguy: @messages
17:36:34 <jcreigh> gotaku: did you see the recent post on "Good math, bad math" about the state monad?
17:36:37 <newsham> > runState (do { x <- get; modify (+ 1); return (2*x) }) 5
17:36:40 <lambdabot>  (10,6)
17:36:43 <glguy> sorear: I got the one about opera
17:36:49 <sorear> glguy: ok.
17:36:56 <glguy> if any opera users know the CSS fix I'd apprciate a patch
17:37:08 <jcreigh> gotaku: http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php (in case you hadn't see this before)
17:37:09 <newsham> gotaku: it took the original state (5), put it into x, added one to the state, and returned 2*x (10)
17:37:10 <lambdabot> Title: Good Math, Bad Math : More Monads: Stateful Programming, http://tinyurl.com/34gwz7
17:37:13 <sorear> <-- not an opera user
17:37:15 <newsham> so that the new state was 6, and the result was 10
17:37:21 <gotaku> I'll take a look.
17:37:27 <jre2> ?fact jre2
17:37:28 <lambdabot> I know nothing about jre2
17:37:52 <newsham> ?fact-set jre2 is on my list
17:37:53 <lambdabot> Fact recorded.
17:37:56 <gotaku> Oh, I've seen this blog before.
17:37:56 <newsham> ?fact jre2
17:37:57 <lambdabot> jre2: is on my list
17:38:17 <gotaku> Not, these haskell posts though.
17:38:31 <allbery_b> a way to think about monads that I haven't seen much of (aside from sigfpe's):  return lets you attach things to a value, (>>=) lets you attach behaviors.
17:38:36 <jcreigh> gotaku: yeah, he started a series on Haskell recently.
17:38:59 <gotaku> http://scienceblogs.com/goodmath/goodmath/programming/haskell/
17:39:00 <lambdabot> Title: Good Math, Bad Math
17:39:06 <allbery_b> the usual behavior is to copy whatever return attached; that's the State monad
17:39:48 <newsham> > runState (return 3) 8
17:39:50 <lambdabot>  (3,8)
17:40:01 <newsham> > runState get 8
17:40:02 <allbery_b> alternately you can look at the thing being passed in and do something special based on it; Maybe does that (if handed Nothing it just passes it on)
17:40:03 <lambdabot>  (8,8)
17:40:08 <newsham> > runState (put 5) 8
17:40:10 <lambdabot>  ((),5)
17:40:23 <newsham> > runState (modify (+ 3)) 8
17:40:25 <lambdabot>  ((),11)
17:41:18 <newsham> > runState (do { x <- get; modify (+ 1); return x}) 8
17:41:19 <lambdabot>  (8,9)
17:41:32 <newsham> > runState (do { x <- get; set 0; return x}) 8
17:41:33 <lambdabot>   Not in scope: `set'
17:41:38 <newsham> > runState (do { x <- get; put 0; return x}) 8
17:41:39 <jre2> hey now
17:41:39 <lambdabot>  (8,0)
17:42:04 <allbery_b> the java runtime environment hangs out in #haskell?! :)
17:42:26 <SamB> it is trying to pick up some optimization techniques or something
17:47:08 <newsham> hmm.. macromedia.com
17:50:00 <abz> ?hoogle forM_
17:50:01 <lambdabot> No matches found
17:50:08 <abz> ?hoogle forM
17:50:08 <lambdabot> Text.Html.form :: Html -> Html
17:50:09 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
17:50:09 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
17:50:14 <Cale> huh... does the IO monad have any nontrivial algebras? It doesn't look like there are any interesting structure maps.
17:50:38 <allbery_b> abz: lambdabot's dtabase is too old to have forM
17:50:41 <newsham> ?src forM_
17:50:43 <lambdabot> forM_ = flip mapM_
17:50:54 <newsham> its in Control.Monad
17:51:02 <abz> thanks.
17:51:05 <allbery_b> (well, src has it, hoogle doesn't)
17:51:13 <nornagon> @index forM_
17:51:15 <lambdabot> bzzt
17:51:18 <nornagon> fail
17:51:30 <abz> ?doc hoogle
17:51:31 <lambdabot> hoogle not available
17:52:36 <newsham> > forM_ [1,2,3] (\x -> print x)
17:52:37 <lambdabot>   Not in scope: `forM_'
17:52:46 <newsham> > flip mapM_ [1,2,3] (\x -> print x)
17:52:49 <lambdabot>  <IO ()>
17:53:35 <newsham> similar to "for x in [1,2,3] : print x"
17:56:22 <abz> right....
18:01:40 <glguy_> anyone here using opera?
18:02:28 <dgriffi3> glguy_: yea
18:03:23 <glguy_> dgriffi3: http://hpaste.org/171
18:03:36 <glguy_> do the diff links disappear?
18:04:53 <dgriffi3> the one at the bottom?
18:04:56 <glguy_> yeah...
18:05:15 <dgriffi3> it's there for me
18:05:24 <glguy_> but it pushes way off the right side of the page
18:05:30 <glguy_> ?
18:06:02 <dgriffi3> not sure, my opera is fullscreen
18:06:38 <dgriffi3> as in it all fits fine
18:07:00 <glguy_> well, yeah, when there is a enough space, everything always fits
18:07:21 <robreim> dons: has lemmih provided any patches for 6.6 yet?
18:10:46 <dgriffi3> glguy_: it shrinks on windows with opera instead of hanging off
18:10:56 <glguy_> ok, cool
18:10:57 <glguy_> thanks
18:11:54 <dons> robreim: not yet
18:11:57 <dons> Lemmih: ping?
18:11:59 <dgriffi3> glguy_: are you the one who runs hpaste?
18:12:02 <glguy_> yeah
18:12:04 <sorear> yes
18:12:30 * glguy needs to make his name bigger at the bottom of the page ;)
18:13:17 <robreim> dons: oh ok. Any idea if he's having any problems with anything? I've been working on it for about 2-3 days (bit slow due to lack of experience) and it would suck if we're reinventing the same solutions.
18:13:47 <dgriffi3> your name seems not to be at the bottom of the actual past pages
18:14:17 <glguy> dgriffi3: did you think I might be enlisting you to check for bugs in someone else's code using a browser I don't choose to use? :-D
18:14:27 <dgriffi3> yeah
18:14:36 <dgriffi3> of course
18:15:06 <glguy> !say owned and operated by glguy ;)
18:15:07 <hpaste> owned and operated by glguy ;)
18:15:17 <MarcWebe2> y
18:15:24 <sorear> glguy: !say still doesn't work for me
18:15:35 <glguy> sorear: the admin list doesn't get saved on restart yet
18:15:44 <sorear> !say or did switching to erc change my prefix?
18:15:53 <glguy> !admin+ :sorear!n=user@ip68-7-248-101.sd.sd.cox.net
18:16:38 <vincenz> dons: can we unremember?
18:16:58 <qwr> glguy: http://linux.ee/~mzz/i/hpaste.png
18:17:42 <glguy> qwr: I'll glance at the CSS file, but I don't use Opera
18:18:20 <sorear> vincenz: @tell would be more effective ... there is no lb-level @forget, check @where lambdabot /Plugin/Seen.hs if you don't believe me
18:19:00 <blsecres> is there a place to download the hierarchical libraries in html format or should I just mirror the pages on haskell.org
18:19:20 <sorear> blsecrec: ./Setup.hs haddock doesn't work?
18:19:32 <vincenz> sorear: hmm?
18:20:01 <qwr> glguy: when i change width, first disappears the input box, then "announce: ", then checkbox and finally Save
18:20:03 <sorear> @list quote
18:20:04 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
18:20:07 <blsecres> sorear: I don't have the library sources or haddock
18:20:10 <sorear> ^^^ no forget
18:20:22 <qwr> glguy: when makeing window wider
18:20:23 <sorear> blsecres: oh.  can't help you then.
18:20:52 <sciolizer> Is there a quick and dirty way to find out where the infinite loop in my program is? (hugs or ghc)
18:21:09 <sorear> sciolizer: profile?
18:21:23 <sciolizer> The profile file doesn't get dumped unless my program terminates.
18:21:33 <sorear> hm.
18:21:40 <sorear> can you add to main:
18:21:59 <sorear> forkIO (threadDelay (10*1000000) >> exitProcess ExitSuccess)
18:21:59 <sorear> ?
18:22:11 <sciolizer> I'll give it a shot.
18:22:21 <sorear> replace 10s with whatever is appropriate, import System.Exit and Control.Concurrent
18:23:37 <emu> it's easy, just solve the halting problem
18:23:41 <sciolizer> lol
18:23:51 <sciolizer> exitProcess not in scope
18:24:02 <allbery_b> see the imports
18:24:05 <sciolizer> I've already imported System.Exit and Control.Concurrent
18:24:11 <allbery_b> @hoogle exitProcess
18:24:12 <lambdabot> No matches found
18:24:20 <emu> @hoogle exitWith
18:24:21 <lambdabot> System.exitWith :: ExitCode -> IO a
18:24:31 <emu> mind you i think that only exits the current thread
18:24:45 <allbery_b> ?
18:24:52 <sciolizer> working on it, thank you for the help
18:25:01 <emu> maybe that works globally in the main thread
18:25:02 <Lemmih> sciolizer: Can't you use C-c to terminate the program?
18:25:03 <allbery_b> I'd expect that to exit the process (thread foo isn't in System)
18:25:04 <sorear> sciolizer: yes, exitWith is what I ment
18:25:19 <sorear> sciolizer: try it anyway .. it might work
18:25:21 <emu> well i did try it once, and it didn't
18:25:21 <sciolizer> C-c terminates the program, but then a.out.prof is an empty file.
18:25:24 <allbery_b> ...and maybe linux's weird (pre-2.6) threads might only exit the thread
18:25:26 <glguy> qwr: does that change anything now?
18:25:41 <sorear> allbery_b: Haskell doesn't use linux threads.
18:25:57 <qwr> glguy: yes
18:26:00 <sorear> (not without -threaded, anyway)
18:26:07 <qwr> glguy: seems ok now
18:26:38 <allbery_b> well, it would with +RTS -Nx, in which case you culd get odd behavior because emulating posix threads on the old linux thread model was dicey at best
18:27:01 <sciolizer> The 10 second timeout doesn't seem to be working.
18:27:13 <sorear> allbery_b: the point is threads aren't mandatory.
18:27:13 <sorear>  
18:27:22 <allbery_b> yeh]
18:27:24 <sorear> sciolizer: oh well.  worth a try
18:27:24 <emu> i was using linux 2.6
18:27:29 <sciolizer> Not sure if it's relevant, but I usually need to press C-c twice to get it to stop.
18:27:40 <sciolizer> (This was even before adding the 10 second timeout.)
18:27:52 <emu> how about this
18:28:33 <emu> tid <- myThreadID; forkIO (threadDelay (10*1000000) >> throwTo tid ...) -- some exception
18:28:55 <sorear> emu: killThread = flip throwTo ThreadKilled
18:29:16 <emu> hmm, what would happen if you killed the main thread?
18:30:22 <sorear> emu: the program would die
18:30:32 <sorear> emu: kill = throw async exn
18:30:53 <sciolizer> Killing the main thread would be fine as long as it dumped the .prof file
18:30:58 <sorear> emu: thus, the exception would unwind, main would return, and since all threads are daemonic in haskell..
18:31:55 <sciolizer> My apologies for not being very familiar with the IO library - is myThreadID a standard function, or was I supposed to replace that with something?
18:32:06 <sciolizer> (emu)
18:32:30 <robreim> Lemmih: can we talk hs-plugins?
18:33:08 <sciolizer> emu: perhaps you meant getThreadID?
18:33:34 <sorear> sciolizer:
18:33:43 <sorear> @ty Control.Concurrent.myThreadID
18:33:45 <lambdabot> Not in scope: `Control.Concurrent.myThreadID'
18:33:50 <sorear> @ty Control.Concurrent.myThreadId
18:33:51 <lambdabot> IO GHC.Conc.ThreadId
18:33:57 <sorear> ^^^ there
18:34:01 <sciolizer> sorear: ty
18:34:07 <sorear> wy
18:35:14 <sciolizer> sorear: "import Control.Concurrent.myThreadID" leads to parse error
18:35:20 <sciolizer> sorear: so I tried MyThreadID
18:35:23 <sciolizer> sorear: not found
18:35:25 <sciolizer> (ghc)
18:35:59 <allbery_b> it's routine myThreadID in module Control.Concurrent (i.e. you import the latter)
18:36:19 <allbery_b> ...Id
18:36:27 <sciolizer> oh
18:36:33 <allbery_b> and you already imported that mdule
18:36:38 <sciolizer> yeah
18:36:41 <allbery_b> so, just spell it correctly since we can't :)
18:36:45 <sorear> sorry :)
18:36:58 <sciolizer> :) it's alright
18:39:01 <Lemmih> robreim: Sure.
18:40:15 <robreim> Lemmih: great. You mentioned before the version in the packageId? How does that break things for ghc 6.6?
18:40:38 <robreim> (I ask because as far as I can tell the version has been in the package Id at least since 6.4.2)
18:41:18 <Lemmih> hs-plugins was actually broken for different reason than I first thought.
18:41:30 <xpika2> how does runhaskell work?
18:41:42 <xpika2> as apposed to compilation
18:41:54 <sorear> ghci
18:42:02 <allbery_b> in ghc it's sort of an interface to ghci
18:42:16 <xpika2> why is it that i do not have to specify -package XXX
18:42:23 <sorear> runhaskell foo --> ghc -e ':l foo' -e 'main'  or so
18:42:45 <allbery_b> because ghci does that kind of thing automatically
18:43:00 <Lemmih> robreim: GHC6.6 lists base without a version tag in the hi files.
18:44:13 <robreim> Lemmih: oh ok. How does that break it? I would have thought it would still load since hs-plugins doesn't really do anything with the version?
18:44:59 <robreim> Lemmih: Also, have you noticed Module in 6.6 has changed to ModuleName and a new Module data type including ModuleName and PackageId has appeared?
18:45:19 <Lemmih> robreim: hs-plugins doesn't strip the version tag when it looks for packages.
18:45:20 <allbery_b> ghci does a few other things straight ghc doesn't, but you probably won't' notice them (for example, it autoimports if you refer to a function by its fully qualified name)
18:46:07 <Lemmih> robreim: Nope, hadn't noticed.
18:46:19 <robreim> Lemmih: hmm... so the symptoms of this would be unable to load the package? I've got my version loading packages but unable to find symbols...
18:47:13 <Lemmih> robreim: hs-plugins silently ignores the packages it can't find.
18:47:54 <robreim> Oh! That may be my problem then, thanks :)
18:48:17 <robreim> Ok, so base has no version in its packageId in .hi files while other packages do, yeah? What solution were you thinking?
18:48:26 <xpika2> ghci is indeed magic
18:48:48 <xpika2> however, when i interpret my hopengl freeglut tells me: Unable to create direct context rendering for window. but when i compile it i dont get such error
18:49:21 <allbery_b> windows?  there's some magic you need to do for GUI programs to work from ghci, IIRC
18:49:26 <sorear> xpika2: try compiling with -threaded - does it fail?
18:50:37 <xpika2> compiling works fine. just running it through ghci
18:50:50 <robreim> Lemmih: actually, do you have any patches of hs-plugins for what you've done so far?
18:51:23 <Lemmih> robreim: This is bad. I'm looking at my fix and can't for the love of Haskell understand why it should fix anything. I'm sure it made sense yesterday. /-:
18:51:36 <Lemmih> robreim: Yes, I've mailed them to dons.
18:52:32 <robreim> Lemmih: cool, can I have a copy by any chance? I think you've fixed different problems to me
18:52:46 <robreim> btw, did your patch fix hs-plugins completely or is there still probems?
18:53:00 <Lemmih> robreim: http://darcs.haskell.org/~lemmih/hs-plugins/
18:53:02 <lambdabot> Title: Index of /~lemmih/hs-plugins
18:53:13 <robreim> Thanks plenty :)
18:53:49 <dons> Lemmih: I haven't received any mail from you yet..
18:54:21 <Lemmih> dons: Oh? Oh right!
18:54:24 <dons> dcoutts: fps api changes relating to CString have landed.
18:54:30 <chessguy> .
18:54:55 <sorear> dons: I've figured out how to make a library of incremental syntax highlighting combinators ...
18:58:01 <emu> @seen apfelmus
18:58:01 <lambdabot> I saw apfelmus leaving #haskell 5h 34m 16s ago, and .
19:10:37 <sorear> Nice.  Cont is the free monad.
19:10:39 <sciolizer> sorear (or anybody): threadDelay (1*1000000) never regains control it seems. If I get rid of it, and simply throwTo, then the program terminates.
19:11:03 <sciolizer> sorear: I'm thinking maybe I should try something like seq [1..10000000] (putStrLn "shot down")
19:11:25 <sorear> sciolizer: ghc threading is confusing.  try threadDelay 1000, -threaded, both.
19:11:46 <sciolizer> sorear: Is -threaded for ghc or for a.out?
19:11:50 <sorear> they use both milli and micro seconds with no clear orer ... bah.
19:11:54 <sorear> ghc
19:12:14 <robreim> Lemmih: your hs-plugins fix looks good! I don't know what I've spent the last 3 days fixing then...
19:12:21 <sorear> sciolizer: how much code do you have?
19:12:21 * allbery_b notes that someone in another channel just referred to map as "obtuse"
19:12:31 <sciolizer> 162 lines
19:12:33 <sorear> someone is stoopid
19:12:49 * sorear /join #haskell.axisofelitism
19:12:54 <sciolizer> sorear: Do you want me to paste bin it?
19:12:59 <sorear> not really but ...
19:13:02 <sciolizer> :)
19:13:02 <sorear> sciolizer: yes.
19:13:03 <allbery_b> granted she was talking about perl, but perl's map is not so different from haskell's
19:13:13 <sorear> sciolizer: yes to pastebinning
19:13:22 <sciolizer> sorear: What's the best haskell paste bin?
19:13:31 <allbery_b> @paste
19:13:31 <sorear> sciolizer: there's only one
19:13:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:13:43 <chessguy> @pl makeMove s = place (findFree s) 'O' s
19:13:43 <lambdabot> makeMove = flip place 'O' =<< findFree
19:13:49 <sorear> the others may support haskell, but only hpaste *is* haskell
19:13:58 <dons> allbery_b: hehe
19:14:02 <sciolizer> ic
19:14:17 <dons> 100% haskell from the sockets up
19:14:18 <dons> :)
19:14:19 <sorear> sciolizer: ic!? what's wrong!? </me panic>
19:14:26 <allbery_b> hpaste supports it a bit better and has a few nice features
19:14:35 <sciolizer> ic = ic that hpaste is the only one
19:14:48 <allbery_b> compared to other pastebins, even those with haskell syntax highlighting
19:15:15 <sorear> dons: I've finally come up with a reasonable design for a library of incremental syntax highlighting combinators ... expect me to be sidetracked for a day or two :)
19:15:20 <dons> ah really?
19:15:21 <dons> hmm!
19:15:26 <dons> Lemmih: so hs-plugins 6.6 is good to go?
19:15:42 <dons> i still can't see any hs-plugins patches in my inbox though
19:16:03 <sciolizer> sorear: http://hpaste.org/190
19:16:11 <emu> @tell apfelmus take 2 (map (+1) nats) = take 3 nats -- isn't true
19:16:12 <lambdabot> Consider it noted.
19:16:25 <sorear> sciolizer: why didn't you announce [X] ?
19:16:44 <sciolizer> I didn't know what it meant. Should I repost?
19:16:49 <glguy> no
19:16:53 <sciolizer> Or is that a channel thing?
19:17:07 <dons> its o.
19:17:09 <glguy> announce -> in #haskell ?
19:17:09 <dons> ok
19:17:22 <sciolizer> ok
19:18:05 <glguy> dons: do you think I should change the wording?
19:18:10 <dons> hmm.
19:18:13 <dons> nope. it'll do
19:18:21 <dons> maybe it could pop up a tool tip ;)
19:18:21 <glguy> doublek
19:18:30 <dgriffi3> ?fact xslt
19:18:31 <lambdabot> xslt: not to be discussed in #haskell
19:18:37 <dgriffi3> ?fact ocaml
19:18:37 <lambdabot> I know nothing about ocaml
19:19:14 <sorear> sciolizer:    (==) a b = (==) b a
19:19:17 <sorear> looks bad
19:19:19 <dons> ?fact-set ocaml ocaml is an older, strict version of haskell without typeclasses or syntax, but with modules
19:19:19 <lambdabot> Fact recorded.
19:19:38 <sciolizer> sorear: yeah, I just didn't want to rewrite all the remaining possible patterns.
19:19:43 <sorear> sciolizer: if one or the other is an Op, that will infloop
19:19:53 <sorear> *AlgOp
19:20:01 <sciolizer> sorear: oh, duh. Thanks.
19:20:48 <sorear> dons: are there any guides for how to find nontrivial q-c properties for code?
19:21:48 <glguy> I changed the <textarea> font-family to monospaces for the Safari users
19:21:53 <glguy> if it breaks for anyone else, let me know
19:22:41 <sciolizer> sorear: the loop (if it is indeed a loop) is not in ==
19:22:53 <sciolizer> sorear: I commented out the (==) a b = (==) b a
19:22:56 <sciolizer> sorear: and it still hung
19:23:07 <chessguy> are there any #haskellers that work for Aetion?
19:23:50 <sciolizer> sorear: don't feel obliged to scan through my code; it's just for fun anyway
19:23:50 <sorear> sciolizer: comment out 80 ?
19:24:10 <sorear> same aura
19:24:30 <sciolizer> sorear: that appears to be it.
19:24:50 <sciolizer> sorear: indeed it is - Non-exhaustive patterns error.
19:25:44 <glguy> (==) (AlgInt a) (AlgRatio b) = (denominator b == 1) && a == numerator b
19:25:56 <dons> sorear: hmm. hard questoin
19:26:09 <dibblego> I saw a guy the other guy with a lambda symbol tattooed on his arm
19:26:16 <dibblego> *the other day
19:26:16 <dons> sorear: some simple things to consider: what happens if you apply the functoin twice
19:26:30 <dons> if you apply it to the concat of two args, or concat two args you apply it to
19:26:32 <dibblego> he said he was studying physics at school and "hated programming because every time he used Java..."
19:26:33 <dons> that kind of thing
19:26:44 <dibblego> so I wrote haskell.org on a business card and handed it to him
19:27:17 <sciolizer> glguy: What are you pointing out?
19:27:20 <jre2> is Frags the only large game written in haskell?
19:27:38 <sorear> I consider GHC a game
19:27:42 <sorear> that's large
19:27:47 <glguy> sciolizer: shouldn't that be denominator b * a = numerator b?
19:27:54 <glguy> ==
19:28:03 <chessguy> ?wiki TicTacToe
19:28:04 <lambdabot> http://www.haskell.org/haskellwiki/TicTacToe
19:28:10 <sorear> why shoot monsters when you can hack or teach newbies?
19:28:29 <dibblego> http://en.wikipedia.org/wiki/Frag_(game) <-- that is written in Haskell?
19:28:50 <sciolizer> glguy: It's probably safer. I was assuming that Ratio always reduces.
19:29:01 <glguy> dons: The first feature that should be written on that TicTacToe page is "use features"
19:29:08 <glguy> sciolizer: ah
19:29:08 <hpaste>  chessguy pasted "TicTacToe is improving!" at http://hpaste.org/191
19:29:14 <allbery_b> wikipedia doesn't know about the game he's talking about:
19:29:17 <allbery_b> @where frag
19:29:18 <lambdabot> http://www.haskell.org/haskellwiki/Frag
19:29:23 <glguy> dons: "use functions"
19:29:54 <dgriffi3> @users
19:29:54 <lambdabot> Maximum users seen in #haskell: 322, currently: 278 (86.3%), active: 40 (14.4%)
19:29:56 <chessguy> glguy, it was designed to start out being hideous
19:30:07 <glguy> right, but the first thing in the bulleted list
19:30:10 <glguy> "functions"
19:30:44 <dons> jre2: there's some other large games
19:30:45 <chessguy> well, that'll be a byproduct of the other refactoring i do, i think
19:30:50 <dons> check the 'games' page of haskell.org's applications page
19:31:06 <dibblego> @where applications
19:31:06 <lambdabot> I know nothing about applications.
19:31:11 <dibblego> @where games
19:31:12 <lambdabot> I know nothing about games.
19:31:14 <dons> good idea
19:31:20 * dibblego reverts to google
19:31:31 <dons> ?where+ games http://www.haskell.org/haskellwiki/Libraries_and_tools/Games
19:31:31 <lambdabot> Done.
19:31:35 <chessguy> http://www.haskell.org/haskellwiki/Libraries_and_tools/Games
19:31:36 <lambdabot> Title: Libraries and tools/Games - HaskellWiki
19:31:39 <chessguy> oops
19:31:40 <dons> ?where+ libraries http://www.haskell.org/haskellwiki/Libraries_and_tools
19:31:41 <lambdabot> Done.
19:31:57 <Notostraca> http://www.scannedinavian.com/~shae/mage-1.0pre35.tar.gz
19:31:59 <dons> jre2: -->
19:32:03 <dons> ?where games
19:32:03 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Games
19:32:07 <jre2> thanks
19:32:13 <Notostraca> shapr has this nethack clone in Haskell
19:32:26 <dons> ah, yeah.
19:32:33 <dons> that's not even on the list
19:33:10 <jre2> Notostraca: haha! I was hoping one existed (google failed me however)
19:33:13 <Notostraca> It's not really documented, but the code is there and solid
19:34:03 <Notostraca> I'm hoping to make my own roguelike-ish thing eventually, but I don't know if Haskell is right for it.
19:34:05 <dons> Lemmih: so what's the status of hs-plugins after i apply these patches?
19:34:30 <dons> Notostraca: it'd be fairly fun to write in haskell. should suit rapid development, while minimising bugs
19:34:37 <dons> (see Frag, that's 10 weeks hacking by a newbie)
19:34:51 <Notostraca> dons: !!!!
19:35:27 <Lemmih> dons: I broke compatibility with <ghc6.4, I believe.
19:35:30 <dons> he knew games fairly well, but didn't know haskell
19:35:33 <dons> Lemmih: ok.
19:35:38 <dons> but it should work with 6.6 .now?
19:35:40 <dons> testsuite runs?
19:35:45 <Lemmih> dons: Yes, yes.
19:35:47 <Notostraca> Now, is there a haskell curses binding that works with windows?
19:35:50 <dons> woo!!!
19:35:53 <dons> Lemmih++
19:36:07 <dons> just let me know when its your birthday Lemmih, and I'll send you a big present!
19:36:18 <dons> Notostraca: if you have curses on windows, then yes.
19:36:31 <dons> try hscurses, failing that, take the mini-curses binding from hmp3
19:37:04 <robreim> Lemmih++
19:37:05 <Notostraca> the hmp3 one I don't think works with Windows...
19:37:21 <Lemmih> dons: I celebrated my birthday with you in a pub in England :D
19:37:24 <dons> its fairly stripped down, so i don't know why it wouldn't work (given some tweaking)
19:37:27 <dons> Lemmih: ah very true!
19:37:27 <Notostraca> ?where hscurses
19:37:28 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
19:37:42 <dons> Lemmih: ok. well I'll have to think up some way to reward you
19:37:59 <Notostraca>  Requirements: GHC 6.2 or greater and a Unix-like operating system (the README  file lists all systems on which hscurses has been reported to work).
19:38:18 <dons> Notostraca: right. i didn't even know curses was available on windows
19:38:26 <dons> so all bets are off. things might work, they might not.
19:38:32 <Notostraca> PDcurses, maybe
19:38:35 <Notostraca> not ncurses
19:39:04 <dons> the hmp3 curses binding is very minimal, even works with old 'curses', 'ocurses' and irix curses
19:39:04 <Notostraca> There's even Nintendo DS curses
19:39:11 <dons> however, its embedded in hmp3
19:39:51 <sorear> sorry vty (in present form) will *not* work on windows
19:40:08 <sorear> not unless you can port termios and ioctl(TIOCGWINSZ)
19:40:12 <Notostraca> Still though, I could make do without the...marvelous powers of curses...if I had a good Haskell graphics library
19:40:59 <dons> well, what? opengl? wxhaskell?  gtk2hs?
19:41:05 <sorear> Lemmih++ Lemmih++ Lemmih++  now, time to fix lamdbdabot-dynamic
19:41:12 <dons> (note frag runs in opengl on windows)
19:41:14 <sorear> @karma Lemmih
19:41:15 <lambdabot> Lemmih has a karma of 39
19:41:22 <dons> yeah, we can port lambdabot now
19:41:31 <dons> and get applicative functions in @run!
19:41:34 <Notostraca> wxHaskell...how does that one work?
19:41:35 <dons> and bytestrings!
19:41:43 <Notostraca> ?where wxhaskell
19:41:44 <lambdabot> http://wxhaskell.sourceforge.net/
19:41:45 <dons> it uses wxWidgets underneath
19:41:50 <chessguy> hey dons, there was an interesting discussion earlier about an idea for a new LB feature
19:41:51 <sorear> dons: applicative functions?
19:41:57 <dons> functors
19:42:01 * dons needs more green tea
19:42:02 <sorear> ah.
19:42:06 <sorear> chessguy: eh?
19:42:15 <dons> chessguy: oh?
19:42:32 <chessguy> it would be cool to tie LB and hpaste together, so that you could do something like @loadpaste ####
19:42:41 <sorear> @where Pappy
19:42:41 <lambdabot> http://pdos.csail.mit.edu/~baford/packrat/thesis/
19:42:44 <dons> mm
19:42:48 <chessguy> and have it load the functions in paste ###
19:42:52 <dons> yeah, that'd be fun
19:43:07 <chessguy> into a namespace specific to the post
19:44:13 <chessguy> would be convenient for if you don't have immediate access to GHC locally
19:44:33 <dons> yeah
19:44:40 <dons> that's doable
19:45:10 <jcreigh> slowly but surely, lambdabot is developing sentience. :)
19:45:47 <chessguy> @yow
19:45:47 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price of
19:45:48 <lambdabot> CHICKEN ...
19:46:07 <Notostraca> ...WHAT?
19:46:18 <hyrax42> hoas = higher order abstract syntax?
19:46:35 <hyrax42> I'm trying my best to deacronymify it
19:46:48 <jcreigh> I wonder if you could just make a @loadurl command. Then @loadpaste 123 would just @loadurl hpaste.org/123/0/plain
19:47:28 <chessguy> now you're thinking like a functional programmer
19:47:57 <jcreigh> well, I'm sure there's Haskell files sitting on the web that would be handy to load other than pastes.
19:48:06 <chessguy> indeed!
19:48:37 <sorear> @ask shapr I see pappy/frisby as more suitible to syntax highlighting then parsec ... is that just as good?
19:48:38 <lambdabot> Consider it noted.
19:48:51 <chessguy> ?help ask
19:48:51 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
19:48:57 <chessguy> ?help tell
19:48:58 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
19:49:12 <chessguy> is there a difference?
19:49:31 <jcreigh> @ask chessguy let's see, shall we?
19:49:32 <lambdabot> Consider it noted.
19:49:41 <sorear> there is
19:49:42 <chessguy> jcreigh, who, me?
19:49:42 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
19:49:51 <sorear> chessguy: you can say it in channel
19:49:53 <chessguy> @messages
19:49:53 <lambdabot> jcreigh asked 21s ago: let's see, shall we?
19:50:08 <sorear> @tell chessguy note the subtle difference
19:50:09 <lambdabot> Consider it noted.
19:50:18 <chessguy> ...
19:50:18 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
19:50:22 <chessguy> @messages
19:50:22 <lambdabot> sorear said 13s ago: note the subtle difference
19:50:32 <sorear> see it?
19:50:36 <jcreigh> it's just a verb selector?
19:50:41 <sorear> yes
19:51:15 <chessguy> jcreigh asked vs. sorear said
19:51:59 <chessguy> seems pretty redundant to me
19:52:02 <jcreigh> I'm assuming it's not nick-specifc, though. :)
19:52:45 <glguy> @messages
19:52:45 <lambdabot> You don't have any new messages.
19:52:48 <glguy> :(
19:52:56 <Notostraca> So, for basic game graphics (Not even a need for layers, really, just 2d sprites), what is the easiest framework to use?
19:53:08 <chessguy> glguy, did you see the news about hs-plugins?
19:53:12 <glguy> 6.6
19:53:18 <chessguy> yup
19:53:41 <glguy> neat
19:53:46 <glguy> @version
19:53:46 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
19:53:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:54:11 <sorear> Notostraca: HGL?
19:54:23 <sorear> (note that hgl doesn't do bitmaps)
19:54:52 <Notostraca> I tried that, but I don't really know what the difference is between RGB and color types
19:55:01 <hyrax42> ?src Data.Array.elems
19:55:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:55:14 <Notostraca> So the Hello World...illegible.
19:55:17 <hyrax42> ?fptools Data.Array
19:55:18 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array.hs
19:57:47 <Notostraca> sorear: I'm really a newbie at all this, so are there any good tutorials for simple data stuff?
19:57:59 <Notostraca> like constructors.
19:58:01 <sorear> I don't knwo ...
19:58:14 <sorear> #haskell is your best bet
19:58:25 <sorear> data D = X | Y creates:
19:58:28 <sorear> * A type D
19:58:32 <Notostraca> Hmmm.. Where could that be...
19:58:39 <sorear> * A function X with type D
19:58:44 <sorear> * A function Y with type D
19:58:59 <sorear> * A case analysis requiring X and Y cases
19:59:22 <sorear> it gets a little, but not much, more complicated with arguments, and higher kinds
19:59:30 <hpaste>  dons annotated "TicTacToe is improving!" with "copy'n'paste'die'die'die" at http://hpaste.org/191#a1
19:59:40 <Cale> I wouldn't call X and Y functions in that case
19:59:50 <Cale> They're just values of type D
19:59:59 <Cale> but in general, they'll be functions
20:00:05 <Notostraca> So, in HGL, RGB has 3 'Word8' constructors.
20:00:49 <Cale> @type Graphics.HGL.RGB
20:00:50 <lambdabot> Word8 -> Word8 -> Word8 -> Graphics.HGL.Internals.Types.RGB
20:00:59 <glguy> hello
20:01:00 <Cale> It has 3 Word8 parameters
20:01:08 <Cale> and it is a single data constructor
20:01:11 <xpika2> @index ($=)
20:01:11 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
20:02:26 <chessguy> dons, nice
20:02:35 <hpaste>  dons annotated "TicTacToe is improving!" with "refactor" at http://hpaste.org/191#a2
20:02:41 <Notostraca> Okay, back to basics: how do I set text color?  It takes an RGB as a parameter
20:02:48 <dons> chessguy: even nicer
20:03:33 <Cale> setTextColor (RGB 255 128 0)
20:03:42 <chessguy> err
20:03:46 <chessguy> have you tried running that?
20:03:49 <Notostraca> seriously?
20:04:09 <chessguy> i'm pretty sure it's broken
20:04:29 <dons> $ ghci Tic.hs
20:04:29 <dons> *TicTacToe> main
20:04:29 <dons> 1
20:04:29 <dons> 2
20:04:29 <dons> 3
20:04:31 <dons> 4
20:04:34 <dons> 5
20:04:36 <dons> "XXXXXO   "
20:04:53 <chessguy> well, that's because you're placing X's on squares that already have O's
20:04:55 <gotaku> I'm looking for a new editor font, any suggestions?
20:05:07 <Notostraca> *** Expression     : setTextColor (RGB 255 40 0) withWindow_ "Hello World Window" (300,200)
20:05:07 <Notostraca> *** Term           : setTextColor
20:05:07 <Notostraca> *** Type           : RGB -> Draw RGB
20:05:07 <Notostraca> *** Does not match : a -> b -> c -> d -> e
20:05:14 <chessguy> try 9, 8, 7, 6, 5
20:05:24 <dons> I like Verdana 16, gotaku
20:05:29 <chessguy> i think you'll hit the empty list case in findFree
20:05:31 <dons> chessguy: oh, its very posisble I broke it
20:05:47 <chessguy> you have to loop 4 times and then do an extra getline
20:05:53 <dons> that partial findFree without a comment scares me
20:06:19 <chessguy> well, yeah, it wasn't intended to be polished code
20:06:30 <chessguy> that wasn't the part i was really interested in
20:06:33 <dons> :)
20:06:44 <Notostraca> So... is there a difference between a Word8 and an Int?
20:07:05 <chessguy> what does the const in the middle there do?
20:07:11 <Notostraca> I am most confused.
20:07:26 <dons> Notostraca: yeah, big difference 3 bytes worth, or 7.
20:07:32 <dons> and a sign bit
20:07:38 <dons> > maxBound :: Word8
20:07:39 <lambdabot>  255
20:07:40 <dons> > maxBound :: Int
20:07:42 <lambdabot>  2147483647
20:07:48 <dons> > minBound :: Int
20:07:50 <lambdabot>  -2147483648
20:07:51 <dons> > minBound :: Word8
20:07:51 <chessguy> code = forM_ [1..5] $ const $ do -- this line
20:07:52 <Notostraca> but in the usage
20:07:53 <lambdabot>  0
20:07:57 <chessguy> @type forM_
20:07:58 <lambdabot> Not in scope: `forM_'
20:08:07 <chessguy> ?hoogle forM_
20:08:07 <lambdabot> No matches found
20:08:10 <dons> :t flip mapM_
20:08:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
20:08:32 <dons> tosses away the value passed from the list
20:08:39 <Notostraca> 4 + 4, or (Word8 -> 4 + Word8 -> 4) or something
20:08:43 <chessguy> heh
20:08:44 <chessguy> cute
20:09:03 <dons> roll your own control!
20:09:15 <chessguy> so all you're left with is basically m b -> m ()
20:09:46 <dons> you could really just use a State monad there
20:09:57 <chessguy> i wondered about that
20:10:01 <dons> and instead of running getLine on the inside
20:10:13 <dons> just pop the next char off a lazy list handed into the State by getcontents
20:10:21 <dons> then the whole core code would be pure
20:10:32 <chessguy> so it would just be in the State monad?
20:10:37 <dons> something like this:
20:10:40 <dons> main = print . execState code . ((replicate 9 ' '), ) =<< hGetContents
20:10:40 <dons> next = do
20:10:40 <dons>     (b,(x:xs)) <- get
20:10:40 <dons>     put (b,xs)
20:10:40 <dons>     return b
20:10:42 <dons> code = forM_ [1..5] $ const $ do
20:10:45 <dons>     c <- next
20:10:48 <dons>     modify (makeMove . place (read m) 'X')
20:11:00 <dons> but you'd need to tweak the 'modify' line to not touch the input string
20:11:15 <dons> there's about 3 bugs in that code
20:12:21 <chessguy> i'll play around with that, thanks
20:14:52 <Pseudonym> BTW, first prize to the person who ports my tic-tac-toe program to have a GUI.
20:14:58 <Pseudonym> http://web.archive.org/web/20050313074723/iohcc.mgoetze.net/Pseudonym.hs
20:15:06 <lambdabot> http://tinyurl.com/ywkbpn
20:15:32 <dons> sounds like a job for gtk2hs man!
20:15:48 <chessguy> wow
20:15:48 <Pseudonym> Trouble is, you need to recompile to make your next move.
20:16:11 <chessguy> that's...really awful
20:16:22 <Pseudonym> Well it did win a prize in the IOHCC.
20:17:16 <chessguy> so that's why someone told me the other day that my tic-tac-toe program wasn't a real tic-tac-toe program unless it looked like a tic-tac-toe board
20:17:16 <mauke> is that a port of the C one?
20:17:22 <Pseudonym> mauke: No.
20:17:28 <Pseudonym> The C one has much better AI than mine.
20:17:37 <Pseudonym> But I was definitely inspired by it.
20:19:22 <Pseudonym> The C version starts off as a dumb player and, as you keep recompiling it, turns into a perfect player.
20:19:34 <nornagon> :)
20:20:00 <Pseudonym> Self-modifying, self-replicating AND self-learning.
20:20:15 <mauke> WHERE IS SARAH CONNOR
20:21:15 <chessguy> ?src mapM_
20:21:15 <lambdabot> mapM_ f as = sequence_ (map f as)
20:21:45 <nornagon> :t sequence_
20:21:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
20:22:39 <chessguy> ?src sequence_
20:22:40 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:25:46 <chessguy> dons, how could you just use 'forM_' in there? where is it defined?
20:25:55 <dons> its in ghc 6.6
20:26:01 <dons> coming in from ControlMonad
20:26:04 <chessguy> ah, ok
20:27:31 <sciolizer> sorear, glguy: thanks for your help
20:28:16 <sorear> @users
20:28:17 <lambdabot> Maximum users seen in #haskell: 322, currently: 277 (86.0%), active: 36 (13.0%)
20:35:25 <falconair> what is hsakell's equivalent of f#'s "let (|>) x f = f x" ?  (I mean does haskell have a predefined |> type operator?)
20:35:59 <glguy> |> is defined in Data.Sequence
20:36:10 <glguy> but that doesn't mean you couldn't write your own
20:37:02 <glguy> > (`id` 5) (*2)
20:37:04 <lambdabot>  10
20:37:17 <glguy> > ($ 5) (*2)
20:37:18 <lambdabot>  10
20:37:24 <falconair> |> reminds me of a unix pipe ... every once  in a while i try to read haskell code and wonder if all the dots, dollar signs, exlamation points, etc. couldn't be simplified
20:37:35 <sorear> @let ($.) = flip ($)
20:37:36 <lambdabot> Defined.
20:37:53 <sorear> > "foo" $. ap zip tails
20:37:55 <lambdabot>  [('f',"foo"),('o',"oo"),('o',"o")]
20:37:57 <falconair> well, following is f# example: "let res = [1;2;3] |> List.map (fun x -> x + 1);;"
20:39:40 <mauke> let res = map (+ 1) [1,2,3]  -- more readable IMHO
20:39:44 <glguy> > 5 `elemIndex` [1..10]
20:39:46 <lambdabot>  Just 4
20:45:40 <hpaste>  glguy annotated "TicTacToe is improving!" with "further reduction" at http://hpaste.org/191#a3
20:45:43 <hpaste>  sorear pasted "This doesn't typecheck without the annotation on telling. Why?" at http://hpaste.org/192
20:46:42 <Pseudonym> sorear: What error do you get without the annotation?
20:47:04 <Korollary> Why does one guy's "One month with haskell" get so many more damn points over some informative article about anything (including about haskell). Who really cares what this guy's personal experience has been?
20:47:05 <sorear> checking...
20:47:11 <Korollary> at reddit that is.
20:47:23 <Pseudonym> Ah, you answered your own question.
20:47:24 <dons> you're so bitter Korollary. ;)
20:47:38 <Korollary> I am not bitter. I am indifferent. I am just confused why people mod it up.
20:47:39 <Pseudonym> I was curious about that myself, until you added "at reddit".
20:47:47 <dons> its a story of hope!
20:47:59 <dons> and contains universal themese of love, hate, betrayal and redemption
20:48:00 <hpaste>  sorear annotated "This doesn't typecheck without the annotation on telling. Why?" with "the error, as requested" at http://hpaste.org/192#a1
20:48:16 <dons> its an inspiring, heart-warming, heart-breaking blockbuster of the year!
20:48:44 <dons> a story of hope and typechecking. who wouldn't mod that up!!??
20:49:02 <sorear> I'm not afraid to use hpaste when things aren't obvious to me ... I hope others aren't scared of the thing that can stump sorear :(
20:49:23 <falconair> i have programming.reddit on my rss feed, it seems to me every other post is about haskell ... the 'one month with haskell' story resonates with those who want to learn but find obstacles of some sort
20:49:32 <sorear> Actually I don't really understand GADT type inference, and was under the impression it was decidable
20:49:40 <dons> monomorphism kicking in?
20:49:50 <sorear> dons: no typeclasses in this code
20:49:54 <dons> GADT/type inf. kicking in?
20:50:04 <dons> what does the head say?
20:50:04 <sorear> ?
20:50:13 <sorear> "the head" ?
20:50:17 <dons> ghc head
20:50:19 <sorear> oh duh
20:50:23 <dons> not my talking type checker head in a jar
20:50:25 * sorear forgot shim uses 6.6
20:50:37 <Pseudonym> No, it's GADTs.
20:50:42 <dons> all wise, but useless without a human aid to feed it nutrients
20:50:56 <Pseudonym> Fail :: Parser MayFail, correct?
20:51:08 <Pseudonym> So it stands to reason that of telling ls Fail = Fail
20:51:22 <Pseudonym> then telling :: _ -> Parser MayFail -> Parser MayFail
20:51:25 <Pseudonym> For some _
20:51:30 <Pseudonym> Right?
20:51:40 <sorear> right
20:51:46 <sorear> but with the sig it works
20:51:50 <Pseudonym> Yes.
20:52:04 <sorear> since the Fail on the left constrains the type mumble mumble
20:52:10 <Pseudonym> Bingo.
20:52:12 <sorear> so why can't GHC figure it out
20:52:38 <sorear> anyway from the HEAD error:       Tell GHC HQ if you'd like this to unify the context
20:52:52 <Pseudonym> Aha.
20:52:56 <Pseudonym> So it is a known issue, then. :-)
20:53:11 <sorear> I'll read that as "we punt, please complain if you encounter it"
20:53:17 <Pseudonym> Yeah.
20:53:22 <dons> sorear: hehe. that's a cool error msgs
20:53:26 <dons> please @remember it
20:53:41 <sorear>     GADT pattern match in non-rigid context for `Fail'  -- also worthwilie?
20:54:06 <Pseudonym> The problem here is that wobbly types and Hindley-Milner don't interact so well sometimes.
20:54:25 <Pseudonym> But I'm pretty sure you can always fix it with a type signature.
20:54:27 <sorear> last chance to edit: @remember ghc GADT pattern match in non-rigid context for `Fail'; Tell GHC HQ if you'd like this to unify the context
20:54:48 <Pseudonym> You might also want to tell GHC HQ.  Or possibly haskell-cafe.
20:55:18 <sorear> @remember ghc GADT pattern match in non-rigid context for `Fail'; Tell GHC HQ if you'd like this to unify the context
20:55:19 <lambdabot> Done.
20:56:57 <Daveman> Hi sorear :)
20:57:04 <Lemmih> @seen dcoutts
20:57:05 <lambdabot> dcoutts is in #happs, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 3h 53m 51s ago.
20:57:13 <sorear> hi Daveman
20:57:16 <sorear> (?)
20:57:45 <sorear> i've been spontaneously greeted by name
20:57:50 * sorear feels more important
20:58:00 <Daveman> hehe
20:58:06 <Daveman> Just saying hi :)
21:15:28 <hyrax42> lazy arrays are fun for dynamic programming
21:22:01 <dons> so how are we going to change the world today?
21:22:32 <sorear> <-- writing incremental syntax highlighting compinators - weird mutant WriterT [Color] ReadP
21:23:15 <dons> sounds good!
21:23:23 <dons> would it make a nice library?
21:23:27 <dons> i.e. for scripting hscolour
21:23:33 <dons> for more colour styles on hpaste.org?
21:23:45 <sorear> brilliant
21:23:57 <sorear> muahahaha!
21:24:20 <sorear> the lambda revolution will destroy all duplicated codes!!
21:25:38 <sjanssen> hyrax42: have you seen Okasaki's DP fix combinator?
21:25:53 <hyrax42> sjanssen: nope
21:25:57 <abz> dons: did you every watch `pinky and the brain`
21:25:59 <hyrax42> ?google okasaki fix dynamic
21:26:03 <lambdabot> http://www.cs.cmu.edu/~maverick/Talks/2005-09-21%20A%20Tale.ppt
21:26:07 <hyrax42> ugh
21:26:26 <hyrax42> ?hoogle a -> [a] -> Maybe Int
21:26:27 <sorear> abz: possible answer: vvv
21:26:27 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
21:26:28 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
21:26:29 <sorear> @brain
21:26:30 <lambdabot> Brain! Brain! You aren't going to leave me!!!???You know what happened to Jerry Lewis after Dean Martin left him!!!
21:26:43 <hyrax42> I always forget these functions
21:26:48 <hyrax42> they have very forgettable names
21:26:54 <sjanssen> hyrax42: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
21:26:58 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
21:27:30 <hyrax42> sjanssen: cool
21:27:45 <hyrax42> though I'm already overstepping a bit perhaps by doing this in haskell
21:27:58 <hyrax42> the assignment never mentions a language though
21:28:35 <dons> abz, yeah I did :)
21:29:05 <dons> @brain
21:29:06 <lambdabot> I think so, Brain! But ruby-studded stockings would be mighty uncomfortable wouldn't they?
21:29:27 <dons> oh no! @brain isn't referentially transparent! good thing it runs in the IRC monad. all your chat belongs to us!
21:29:41 <abz> hahaha.... I just flicked over to see what was going on ...and you talking about `changing the world today`...and with all this lambda rev stuff.... I thought it sound like pinky
21:30:03 <dons> mwhahahaha!
21:30:13 <dons> you *will* be typechecked!
21:30:21 <abz> lol
21:30:25 <hyrax42> ?localtime dons
21:30:28 <lambdabot> Local time for dons is Tue Jan 30 16:26:06 2007
21:30:49 <allbery_b> "I am Lambda of Borg.  You will be typechecked."
21:30:50 * hyrax42 tries to draw conclusions
21:30:58 * hyrax42 fails
21:31:16 <allbery_b> (suggesting perhaps we shouldbemore careful around LB...)
21:31:39 <hyrax42> sjanssen: that's really neat
21:31:50 <jcreigh> I'm sorry, Dave. I'm afraid I can't let you do that. I was expecting type Int -> Int
21:32:06 <hyrax42> so much more structure you can pull out with first class functions
21:32:12 <hyrax42> well higher order
21:37:23 <Daveman> grr
21:38:02 <jcreigh> grr?
21:38:12 <Daveman> Indeed.
21:40:16 <bos> what's it mean when ghci says "module is not loaded" in response to a :m request?
21:40:22 <bos> :Prelude> :m +Network.XmlRpc.Client
21:40:22 <bos> module main:Network.XmlRpc.Client is not loaded
21:41:09 <bos> ah!
21:41:18 <bos> it means i was running ghci from the root haxr directory.
21:41:25 <bos> what an unhelpful message :-(
21:41:57 <sjanssen> ah yes
21:42:22 <sjanssen> the problem with ghci in a libraries directory is quite annoying
21:43:24 <bos> aye
21:47:28 <bos> @hoogle forM_
21:47:29 <lambdabot> No matches found
21:47:32 <bos> @hoogle forM
21:47:33 <lambdabot> Text.Html.form :: Html -> Html
21:47:33 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
21:47:33 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
21:47:42 <bos> uhhh.
21:47:48 <bos> @hoogle mapM_
21:47:48 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
21:47:49 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
21:47:57 <allbery_b> the hoogle db hasn't been updated for 6.6
21:48:23 <bos> ok, it's in Control.Monad. i wasn't going crazy after all :-)
21:48:25 <bos> thanks, aleator_
21:48:27 <bos> er, allbery_b
21:52:16 <hyrax42> does anyone know why the dynamic programming algorithms for LCS always work form the end of the strings?
21:52:25 <hyrax42> some historical accident?
21:54:32 <newsham> LCS?
21:54:47 <sorear> longest common subsequence
21:54:50 <nornagon> Longest Common Substring
21:54:51 <nornagon> or that
21:55:08 <glguy> hyrax42: it makes it easier to backtrack lazily
21:55:25 <glguy> hyrax42: that's why hpaste does it like that
21:55:32 <hyrax42> oh really?
21:55:36 * hyrax42 should look
21:55:40 <glguy> DiffHtml.hs
21:55:47 <hyrax42> seems to me that it's equivalent either way
21:56:06 <hyrax42> and if you're using [Char] (or Eq a => [a] more generally) then looking at the front is easier
21:56:23 <glguy> well, it doesn't really matter if you way works for yo....
21:56:28 <hyrax42> is there a browsable darcs?
21:56:41 <hyrax42> well I'm curious to see just how it's made easier
21:56:51 <glguy> http://kakapo.scannedinavian.com/~eric/hpaste/HtmlDiff.hs
21:58:34 <Pseudonym> hyrax42: Not all of them do.
21:58:41 <Pseudonym> The Myers algorithm is symmetric.
21:58:47 <hyrax42> hm wouldn't CSE obviate need to use silly names like x'ge'lenx
21:59:27 <glguy> there isn't anything special about the lcs algorithm that hpaste uses
21:59:47 <hyrax42> ok well I'm talking here of the bog standard lcs algorithm
21:59:57 <hyrax42> shouldn't have said all algorithms
22:00:03 <hyrax42> rather all presentations I've seen of it
22:00:21 <hyrax42> bog standard = CLRS pg 353 for those following at home
22:08:44 <Pseudonym> There might be something with loop termination involved.
22:08:52 <Pseudonym> Like, the termination condition is a bit nicer.
22:09:39 <bos> how odd. the IO module isn't documented in my local GHC docs.
22:09:58 <allbery_b> System.IO?
22:10:25 * allbery_b notes that some algorithms work backwards just because ==0 is faster than == length list
22:10:26 <bos> ah, that's it.
22:10:33 <bos> i must be getting the legacy name. thanks!
22:14:00 <hpaste>  glguy pasted "lcs from the beginning (not cleaned)" at http://hpaste.org/193
22:18:38 <Pseudonym> In the case of LCSS, it's trickier because there is m and n involved.
22:18:49 <glguy> lcss?
22:19:14 <Pseudonym> Longest common subsequence.
22:19:21 <Pseudonym> I always abbreviated that to LCSS.
22:19:22 <bos> interesting. there's no drop-like function for the end of a list.
22:19:47 <hpaste>  glguy annotated "lcs from the beginning (not cleaned)" with "rewritten with a scanl" at http://hpaste.org/193#a1
22:20:01 <newsham> whats the diff between a TVar and an MVar?
22:20:17 <glguy> TVar has to do with STM I believe
22:20:24 <glguy> MVars work in simple IO
22:20:55 <allbery_b> tracked by STM for conflict checking?
22:21:32 <newsham> haskell lib docs not so good on STM stuff
22:21:56 <newsham> STM also has TMVars which are "transactional MVars" whatever that means
22:23:03 <allbery_b> as is too often true, the documentation is a pointer to a research paper :/
22:23:31 <newsham> in this case a pointer to several papers
22:24:16 <dons> in this case its a haddock bug though, see here: http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#t%3ASTM
22:24:18 <lambdabot> http://tinyurl.com/ys92tb
22:24:28 <dons> a patch has been submitted to fix this
22:24:36 <newsham> ah, mvar can do scheduling too (if you grab it, you can block until the thing is full)
22:25:20 <newsham> thx dons
22:26:35 <newsham> trying to make sense of HAppS internals
22:26:41 <newsham> its all STM'd out
22:30:43 <bos> what's the haskell equivalent of popen again?
22:32:01 <allbery_b> ?index runInteractiveCommand
22:32:01 <lambdabot> System.Process
22:32:12 <bos> allbery_b: thank you, once again :-)
22:34:56 <hpaste>  glguy annotated "lcs from the beginning (not cleaned)" with "backtracking with scanls" at http://hpaste.org/193#a2
22:38:07 <ctkrohn> Hey, does anyone know if there are any issues running GHC on Irix?  A quick google search doesn't seem to turn up any problems, but it looks like you'd have to compile it yourself?
22:38:53 <dons> you have to build it yourself
22:39:00 <dons> or take the 6.0 binary that was posted (by me:)
22:39:13 <dons> we have a mips.com guy comitting ptches, so things should *just work*
22:39:22 <ctkrohn> ah, ok, nice
22:39:23 <dons> i'd start with the binary for 6.0 though, see if that works
22:39:27 <dons> then use that to build ghc 6.6
22:39:35 <dons> should work both in 64 and 32 bit modes
22:39:57 * ctkrohn is considering picking up an old SGI workstation for cheap
22:39:59 <dibblego> if I map across a list, can each element be freed as I move along?
22:40:33 <dons> hehe
22:40:34 <dons> edison$ cat test.hs
22:40:34 <dons> import System.Info
22:40:34 <dons> main = do
22:40:34 <dons>         putStrLn System.Info.arch
22:40:36 <dons>         putStrLn System.Info.os
22:40:39 <dons> edison$ ./a.out
22:40:41 <dons> mipseb
22:40:44 <dons> irix
22:40:46 <dons> :)
22:40:49 <dibblego> nice one
22:41:10 <bos> dibblego: depends.
22:41:13 <dons> dibblego: if there's no references to the old list...
22:41:23 <dibblego> assume there are no old references
22:41:58 <dibblego> the GHC profiler seems to suggest that isn't the case (though, I am extrapolating from a more complex example for now)
22:44:58 <dibblego> essentially, mapping across a list of length n, uses 2 * n space - even if the original list is never referenced again
22:46:11 <bos> boy, wordpress makes me crazy.
22:46:23 <dibblego> why come?
22:46:32 <jcreigh> OTOH, writing a "for" loop for the 1000th time makes developers want to jump off tall buildings. So pick your poison. :)
22:46:43 <hpaste>  glguy annotated "lcs from the beginning (not cleaned)" with "dons, do you think this would be faster than the existing diff algorithm?" at http://hpaste.org/193#a3
22:46:56 <bd_> forM [0..999] $ write (Loop For)
22:47:00 <bos> it's too clever-clever by half with trying to tell which ">" should be escaped.
22:47:17 <dibblego> I have a LCS-based diff somewhere
22:47:26 <newsham> cool, working yi-gtk in windows.
22:47:32 <glguy_> There is one running on hpaste already
22:47:36 <glguy_> I'm just playing around now :)
22:47:39 <bos> so my little lhs-to-markdown-to-xhtml filter gets every &gt; escaped to the literal string "&gt;"
22:47:40 <dibblego> ok
22:48:20 <dibblego> why must a be of type Ord?
22:48:21 <mwc> props to dcoutts on the recent spate of gtk2hs work
22:48:30 <glguy_> dibblego:
22:48:31 <glguy_> ?type max
22:48:32 <lambdabot> forall a. (Ord a) => a -> a -> a
22:48:40 <glguy_> OH
22:48:44 <glguy_> because I'm lazy
22:48:48 <glguy_> and didn't write a custom type
22:48:49 <dibblego> ok
22:48:54 <dibblego> yeah that's what I did
22:49:07 <jcreigh> bos: oh, wordpress converts "&gt;" to "&amp;gt"?
22:49:25 <dibblego> what does hpaste do with a diff anyway?
22:49:33 <mwc> dibblego, there might be a ghc internal IO action you could call to perform a complete and aggressive garbage collection
22:49:33 <dibblego> each revision of the post?
22:49:36 <bos> jcreigh: yep!
22:49:42 <jcreigh> heh
22:49:42 <glguy_> dibblego: hpaste.org
22:49:43 <mwc> I'd do that before you look at your test results
22:49:52 <dibblego> mwc, ok thanks
22:50:01 <bos> so my literate haskell looks like the insane ravings of a madman.
22:50:05 <bos> appropriate, really.
22:50:06 <mwc> there might be, but I haven't actually looked
22:50:19 <mwc> but every language has interfaces to the GC: Java, Ocaml, SML
22:50:49 <bos> there is, but you don't really want to use it.
22:51:28 <mwc> Actually, I can think of a lot of times you'd want to trigger a gc
22:51:38 <bos> messing with the gc is a mistake 99 times out of 98.
22:52:08 <mwc> if you were writing a game, the obvious thing to do is trigger a GC after you've loaded your level and set everything up, then call it just before you start the game itself.
22:52:15 <bos> ample experience with java has proven this, and having a lazy language makes it even harder to get right.
22:52:30 * dibblego garbage collects and heads to the train station
22:53:38 <dibblego> @message glguy does hpaste use LCS-based diff for describing the differences between each revision of a post or something more?
22:53:39 <lambdabot> Maybe you meant: messages messages?
22:54:02 <dibblego> how do you leave a message?
22:54:17 <glguy_> dibblego: just go to the site and play with it, shesh :)
22:54:31 <dibblego> play with what exactly?
22:54:33 <glguy_> You can't be that busy if you are trying to figure out how to leave me a message
22:54:36 <glguy_> the diff button
22:54:46 <dibblego> oh
22:54:55 <dibblego> not busy, just blind
22:55:06 <mwc> so uhm, where is all the Ghc.* stuff documented?
22:55:10 <glguy_> it's only used for one thing
22:55:14 <glguy_> so if you find it, that's it :)
22:55:34 <dibblego> it was the colour
22:55:48 <dibblego> it is in my peripheral registering as spam because it is bright
22:56:06 * dibblego gets himself some cognitive dissonance
22:56:11 <dibblego> train to catch, bye!
22:57:21 * mwc pounds on the keyboard like a crazy german adolescent while waiting for haskell.org to load
22:57:28 <hpaste>  glguy annotated "lcs from the beginning (not cleaned)" with "and I'm spent" at http://hpaste.org/193#a4
22:58:11 <narain_> i just found hpaste doesn't seem to show up on google
22:58:15 <narain_> btw, hello all
22:58:39 <narain_> my first time here (and on irc) so forgive any faux pas
22:59:21 * glguy_ ponders scanning diagonally so that he always keeps the fewest possible elements in memory at a time
22:59:32 <mwc> narain_, almost anything can be forgiven as long as you're not on AOL :)
23:00:06 <glguy_> i don't think aol users program
23:00:07 <narain_> :) thanks, i certainly am not
23:00:30 <glguy_> narain_: then you are well on your way
23:00:33 <mwc> glguy_, I have sneaking suspicions about a grad students in physics who's doing black hole simulations in delphi
23:00:34 <glguy_> whats up?
23:00:37 <narain_> aol + haskell = earth-shattering kaboom?
23:00:43 <Korollary> heh
23:01:10 <narain_> so i was wondering if anyone could help me out
23:01:19 <Korollary> The answer is no!
23:01:23 <glguy_> !paste
23:01:23 <hpaste> Haskell paste bin: http://hpaste.org/
23:01:38 <narain_> i'm writing my first nontrivial haskell progra... "the answer is no!" um.
23:01:41 <mwc> If anybody's wondering about that german kid comment I made: http://youtube.com/watch?v=T7FZnV-joeA
23:01:43 <jcreigh> narain_: don't ask to ask, just ask. :)
23:01:50 <Korollary> mwc: I had seen that. I wonder if it's real.
23:02:06 <narain_> ok i'll go over to hpaste and be back
23:02:14 <Korollary> Though, it could be. I once punched my keyboard so hard that I lost some keys.
23:02:29 <mwc> Doubt it, it looks too much like something a 14 year old would think is really funny
23:02:32 <mwc> that and the camera
23:02:38 <glguy_> lol i was just excited to recognize the UT2004 music
23:03:11 <Korollary> I like UT music. Kharismatron specifically.
23:03:35 <glguy_> whoa whoa whoa i didn't say i knew the name
23:03:39 <glguy_> you are weird
23:03:47 <master_baiter> anyone camping out for vista?
23:03:56 <glguy_> i have it
23:03:59 <glguy_> msdn
23:04:00 <glguy_> ftw
23:04:21 <glguy_> and it's sitting idle on a spare partition, not worth the money I didn't pay for it
23:04:46 <jcreigh> pah, vista.
23:05:17 <glguy_> vista + ghc is a no go at present
23:05:36 <Cale> It sounds like nobody's going to run vista anyway :)
23:05:51 <glguy_> no drm for j00?
23:05:55 <hpaste>  narain pasted "Trouble with HOpenGL" at http://hpaste.org/194
23:07:35 <Korollary> glguy_: Teque wrote some really nifty stuff.
23:07:54 <glguy_> who?
23:08:13 <Korollary> That's the guy who wrote Kharismatron.
23:08:23 <glguy_> http://youtube.com/watch?v=A7NYB4SPTJk
23:08:29 <glguy_> german kid
23:08:51 <narain_> can anyone help me out with the code i hpasted?
23:08:57 <allbery_b> narain: precedence maybe?
23:09:08 * glguy_ doesn't know opengl
23:09:45 <narain_> do you think i should put parentheses everywhere
23:10:31 <glguy_> after =$ to end?
23:10:33 * allbery_b sould suspect, sight unseen, that ($=) is higher precedence than (>>)
23:10:44 <narain_> what do you know, that worked!
23:11:08 <narain_> thanks a lot allbery_b and glguy_!
23:11:18 <Korollary> >> has very low prec
23:11:27 <Korollary> iirc
23:11:42 <allbery_b> infixl 1
23:12:02 <narain_> it looks so obvious now that i know the problem :)
23:13:04 <allbery_b> if you use ghc/ ghci, you can tell from the error message how it's breaking down the expression --- that should make it clear when it's a precedence problem, becuase it'll be looking at too little
23:13:56 <narain_> except that it compiled fine because everything was of type IO ()
23:14:01 <narain_> it just didnt run properly
23:14:29 <allbery_b> heh.  that is a problem, when the types aren't differentiated the type system can't help you :/
23:14:34 <Korollary> Heh
23:15:09 <Korollary> Interesting problem.
23:34:13 <robreim> Lemmih, dons: the recent changes to hs-plugins don't seem to work with windows.
23:50:37 <dons> robreim: ok. in what sense 'don't work" ? :)
23:51:41 <dons> ?users
23:51:42 <lambdabot> Maximum users seen in #haskell: 322, currently: 265 (82.3%), active: 22 (8.3%)
23:53:22 <robreim> c:/ghc/ghc-6.6/HSregex_posix_cbits.o: unknown symbol `_free'
23:53:24 <robreim> foo.exe: unloadObj: can't find `c:/ghc/ghc-6.6/HSregex-base.o' to unload
23:53:24 <robreim> foo.exe: user error (unloadObj: failed)
23:53:30 <robreim> in that sense
23:55:44 <notsmack> where do i find HsFFI.h for FFI?
23:56:54 * notsmack finds it
23:57:16 <robreim> dons: ping ^^
23:57:45 <wkh> omg Scala rocks
23:59:31 <Excedrin> is the System.Random rng decent? I see that it has decent period
