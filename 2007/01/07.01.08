00:06:51 <dons> hey slava:
00:06:54 <dons> :t cos -- ;)
00:07:06 <slava> hi dons
00:07:10 <dons> hehe. modulo lambdabot being awake...
00:07:15 <dons> cos :: (Floating a) => a -> a
00:07:24 <dons> (polymorphic over floating types :)
00:07:27 <slava> heh
00:07:47 <slava> i certainly don't think static typing is worthless, as karsten tries to paint me
00:07:55 <dons> yeah, I know :)
00:08:11 <dons> I only noticed today that there really is a little bit more type info in the trig functions, than I'd recalled
00:08:40 <slava> do you think languages such as epigram and coq will see wider usage?
00:09:03 <dons> nah, I think however you'll see epigram fetures move into haskell, and haskell features move into C#
00:09:14 <slava> heh
00:09:40 <dons> Epigram as is is too hard for me :)
00:09:56 <slava> the interactive environment is tasty
00:10:06 <slava> i'm a sucker for tools, mostly, not languages :)(
00:10:13 <slava> (that ( should not be there)
00:10:28 <dons> Here's a nice example I saw today of how GADTs give us some Epigram in Haskell, http://www.haskell.org/pipermail/haskell-cafe/2007-January/021178.html
00:10:30 <lambdabot> Title: [Haskell-cafe] GADTs are expressive, http://tinyurl.com/vac6p
00:11:04 <dons> yeah, the epigram, and proof theorem systems in general, have good attention paid to  the interactive environment
00:11:26 <dons> I guess since theorem proving is even harder than writing down the correct type in Haskell
00:11:58 <slava> well, in such a language, once you've written down the type, you're almost done
00:12:09 <dons> yeah
00:12:39 <dons> its a bit like working in the parametrically polymorphic haskell functions
00:12:45 <dons> ?djinn a -> a
00:12:45 <lambdabot> f a = a
00:13:07 <dons> ?djin a -> b -> (b,a)
00:13:08 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
00:13:13 <dons> ?djinn a -> b -> (b,a)
00:13:13 <lambdabot> f a b = (b, a)
00:13:23 <slava> heh, neat
00:13:43 <dons> ?djinn Maybe a -> (a -> Maybe b) -> Maybe b
00:13:43 <lambdabot> f a b =
00:13:44 <lambdabot>     case a of
00:13:44 <lambdabot>     Nothing -> Nothing
00:13:44 <lambdabot>     Just c -> b c
00:13:57 <dons> (that's a derived 'bind' for the Maybe monad
00:14:00 <nornagon> that looks familiar
00:14:04 <nornagon> ah, right :)
00:14:19 <Cale> ?djinn Cont r a -> (a -> Cont r b) -> Cont r b
00:14:19 <lambdabot> -- f cannot be realized.
00:14:25 <dons> djinn is a theorem prover though :)
00:14:32 <nornagon> Cale: DENIED
00:14:40 <dons> Cale: I think it can do it , given the right decls set up
00:14:44 <Cale> Cont is probably not defined
00:14:49 <Cale> ?help djinn
00:14:49 <lambdabot> djinn <type>.
00:14:49 <lambdabot> Generates Haskell code from a type.
00:14:49 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
00:14:50 <dons> data CD r a = CD ((a -> r) -> r)
00:14:50 <dons> returnCD ? a -> CD r a
00:14:50 <dons> bindCD ? CD r a -> (a -> CD r b) -> CD r b
00:14:52 <dons> callCCD ? ((a -> CD r b) -> CD r a) -> CD r a
00:14:59 <dons> you need the CD type first
00:14:59 <Cale> ?help djinn-add
00:15:00 <lambdabot> djinn-add <expr>.
00:15:00 <lambdabot> Define a new function type or type synonym
00:15:28 <Cale> ?djinn-add type Cont r a = (a -> r) -> r
00:15:36 <Cale> ?djinn Cont r a -> (a -> Cont r b) -> Cont r b
00:15:37 <lambdabot> f a b c = a (\ d -> b d c)
00:15:50 <Cale> there we go :)
00:16:06 <slava> will djinn write my thesis for me? :)
00:16:13 <slava> or at least prove the results
00:16:14 <nornagon> ?ft fmap
00:16:16 <lambdabot>  There was an error in the type: (line 1, column 8):
00:16:16 <lambdabot>  unexpected "("
00:16:16 <lambdabot>  expecting "::"
00:16:27 <dons> ?free map
00:16:28 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
00:16:35 <dons> that's the free theorem lemma generator
00:16:49 <nornagon> ?help free
00:16:49 <lambdabot> free <ident>. Generate theorems for free
00:16:51 <nornagon> ?help ft
00:16:51 <lambdabot> ft <ident>. Generate theorems for free
00:16:55 <Cale> Is it a theorem or a lemma? :)
00:17:02 <nornagon> or a lemur?
00:18:01 <Cale> What's yellow and equivalent to the axiom of choice?
00:18:07 <dons> ?free sortBy
00:18:09 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
00:18:18 <slava> a banana of choice?
00:18:18 <dons> ?free foldr
00:18:20 <lambdabot> (forall x. f . h x = k (g x) . f) => f . foldr h y = foldr k (f y) . $map g
00:18:21 <dons> hehe
00:18:23 <slava> tychonoff's banana?
00:18:24 <Cale> Zorn's Lemon
00:18:26 <slava> haha
00:18:56 <Cale> What's yellow and complete under the topology induced by the norm?
00:19:00 <dons> ?djinn-add type SX s a = s -> (s, Maybe a)
00:19:08 <slava> Cale: i heard that one. bananach space :)
00:19:17 <dons> state monad, with exceptions
00:19:21 <dons> ?djinn SX s a -> (a -> SX s b) -> SX s b
00:19:21 <lambdabot> f a b c =
00:19:21 <lambdabot>     case a c of
00:19:21 <lambdabot>     (d, e) -> case e of
00:19:21 <lambdabot>               Nothing -> (d, Nothing)
00:19:23 <lambdabot>               Just f -> b f d
00:19:58 <dons> yay for lots of structure in the types
00:19:58 <nornagon> crazy :)
00:20:33 <dons> ?djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
00:20:33 <lambdabot> f a = a (\ b -> Left (\ c -> a (\ _ -> Right (\ d -> b (c, d)))))
00:20:39 <slava> dons: how do people implement memoizing functions?
00:20:42 <dons> de Morgan, in CPS style
00:20:43 <nornagon> ?!
00:20:44 <lambdabot> Maybe you meant: . v
00:20:57 <nornagon> not actually, thx lambdabot
00:21:20 <dons> slava, memoising in Haskell? usually with lists (build an infinite list of results, access what you need)
00:21:24 <Cale> ?djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
00:21:25 <lambdabot> f a b = a (\ c _ -> b c) b
00:21:36 <dons> Cale might have some other suggestions (you were looking at memoising recently with someone, Cale?)
00:22:37 <Cale> Well, you can use the fact that things will be shared together with arrays of values. If you want more control, you can use unsafePerformIO to construct various types of automemoisers.
00:23:04 <dons> yeah, that's another approach
00:23:22 <Cale> (e.g. a function of type   (Ord a) => (a -> b) -> (a -> b)  which turns functions into automatically-memoised versions of themselves.
00:23:23 <Cale> )
00:23:45 <Cale> There's a whole paper on how to do that in various different ways
00:24:10 <nornagon> heh
00:24:49 <pejo> Cale, have a reference handy?
00:24:56 <Cale> Looking for it
00:24:58 <nornagon> forall (Problem a) => a. perl has a module CPAN a, haskell has an academic paper a
00:26:01 <Cale> http://research.microsoft.com/Users/simonpj/Papers/weak.htm
00:26:02 <lambdabot> Title: Simon Peyton Jones: papers
00:26:04 <Cale> there we go
00:26:09 <matthew-_> nornagon: Are you suggesting that Perl hackers write code where Haskellers just write papers?
00:26:26 <nornagon> matthew-_: the papers generally come with code.
00:26:31 <nornagon> or have a .lhs extension.
00:27:09 <Cale> The first thing the paper does is explain why there isn't a memo function in the libraries.
00:27:33 <Cale> However, it might be nice to have a whole library of standard memo functions.
00:27:42 <matthew-_> ahhhh! So your suggesting that Haskellers manage to get papers out of code that Perlers just write?
00:27:45 <matthew-_> ;)
00:27:55 <Cale> you're
00:28:01 <matthew-_> thanks
00:34:50 <pejo> matthew, lots of bad things could be said about journals, but atleast my library has them - and will have for the foreseeable future. :-)
00:41:05 <matthew-_> hey, don't get me wrong - I'm not trying to criticise
00:41:34 <matthew-_> I find it interesting that things that start in academia tend to stay there, and things that start outside of academia tend to stay there too
00:42:00 <matthew-_> and in some cases there's not actually that much difference between the two in terms of end-user functionality
00:42:33 <dons> yeah, but it needn't be the case, in these days of open source
00:43:34 <dons> the academic just has to make sure they release source packaged propely, open and in public version control
00:43:44 <dons> i.e. darcs + cabal + BSD3 :)
00:43:53 <matthew-_> O.o
00:44:14 <matthew-_> going the other way seems harder though - getting academia to take notice of other stuff seems a rare achievement
00:44:45 <pejo> matthew, in academias defense, a lot of things out there are simply not documented, except for the source code.
00:44:49 <dons> yeah, there too, if you do it in an open, public way, its more likely to be accepted
00:45:15 <matthew-_> mmmm true. ok, must run to college... later
01:11:52 <kzm> Anybody know what the 'carrot indicator like java has' is?
01:16:09 <pbx> kzm: Perhaps "carat"? As in "^"? As in the thing the compiler uses to try to show you where an error is?
01:16:57 <dons> hey pbx.
01:17:13 <pbx> Hello!
01:17:18 <kzm> pbx, ah.
01:18:04 <dons> pbx, is this you? http://e-scribe.com/news/322  :)
01:18:06 <lambdabot> Title: E-Scribe News : It&#8217;s Haskell
01:18:20 <pbx> dons: Yeah, I'm taking the (slow) plunge.
01:18:40 <dons> cool! the lambdas are on the house!
01:18:51 <slava> free lambdas? where?
01:18:54 <dons> just stick it on lambdabot's tab
01:19:24 <dons> > fix (\x -> 1 : x) -- lambdas for all!
01:19:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:20:33 <dons> :t \x -> x -- lambdas of forall type!
01:20:35 <lambdabot> forall t. t -> t
01:21:14 <Jaak> > fix ('Î»':)
01:21:14 <lambdabot>  Improperly terminated character constant
01:21:17 <Jaak> blah
01:21:23 <dons> bah
01:21:32 <dons> needs 6.6
01:22:04 <dons> > cycle "\x -> x"
01:22:04 <lambdabot>  Illegal escape sequence
01:22:14 <dons> > cycle "\\x -> x" -- heh
01:22:15 <lambdabot>  "\\x -> x\\x -> x\\x -> x\\x -> x\\x -> x\\x -> x\\x -> x\\x -> x\\x -> x\\x...
01:23:11 <dons> > cycle "(\a -> a) " -- ;)
01:23:12 <lambdabot>  "(\a -> a) (\a -> a) (\a -> a) (\a -> a) (\a -> a) (\a -> a) (\a -> a) (\a -...
01:24:44 <tphyahoo> :t fix
01:24:46 <lambdabot> forall a. (a -> a) -> a
01:26:22 <Andris> @djinn forall a. (a -> a) -> a
01:26:22 <lambdabot> -- f cannot be realized.
01:26:40 <slava> i can see why!
01:26:48 <Andris> I can see Y :)
01:26:55 <dons> :)
01:27:00 <dons> ?src fix
01:27:00 <slava> you don't have a canonical initial a to pass to the input function to get your result, right?
01:27:00 <lambdabot> fix f = let x = f x in x
01:27:28 <tphyahoo> what does realized mean? Something like, finish without using take to finish it early?
01:27:42 <dons> > fix (1 :) -- need to be building a lazy structure
01:27:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:27:58 <Andris> I believe Djinn operates on a model that is different from the real Haskell's
01:28:12 <dons> > let x = 1:x in x
01:28:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:28:14 <Andris> more like the LC
01:28:30 <dons> ?help djinn
01:28:30 <lambdabot> djinn <type>.
01:28:31 <lambdabot> Generates Haskell code from a type.
01:28:31 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
01:28:59 <dons> Djinn interprets a Haskell type as a logic formula using the
01:28:59 <dons> Curry-Howard isomorphism and then a decision procedure for
01:29:00 <dons> Intuitionistic Propositional Calculus.
01:29:07 <Andris> yes, just looked it up :)
01:29:12 <Andris> you are typing faster :)
01:29:34 <dons> you can speak to the author, augustss, here :)
01:30:28 <dons> ?djinn (a -> a) -> (a -> (a,a))
01:30:28 <lambdabot> f a b = (a b, a b)
01:30:35 <dons> mm, almost pointfree...
01:30:42 <dons> ?. pl djinn (a -> a) -> (a -> (a,a))
01:30:42 <lambdabot> f = ap =<< ((,) .)
01:30:49 <slava> why is point-free style called point-free?
01:31:03 <dons> ?wiki Pointfree
01:31:03 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
01:31:33 <Cale> ?djinn Bool -> a -> b -> Either a b
01:31:33 <lambdabot> f a b c =
01:31:33 <lambdabot>     case a of
01:31:33 <lambdabot>     False -> Left b
01:31:33 <lambdabot>     True -> Right c
01:31:51 <nornagon> Right c?
01:31:54 <nornagon> oh
01:31:55 <nornagon> right
01:31:58 <nornagon> yeah :)
01:33:24 <Andris> @djinn Bool -> Bool
01:33:25 <lambdabot> f a = a
01:33:41 <nornagon> @djinn Bool -> a -> Maybe a
01:33:42 <lambdabot> f a b =
01:33:42 <lambdabot>     case a of
01:33:42 <lambdabot>     False -> Nothing
01:33:43 <lambdabot>     True -> Just b
01:34:10 <Andris> I hoped for two implementations
01:34:19 <dons> it just picks one
01:34:20 <Andris> @djinn a -> a -> a
01:34:21 <lambdabot> f _ a = a
01:34:32 <Andris> I see
01:34:57 <dons> ?free a -> a -> a
01:34:57 <lambdabot> Extra stuff at end of line
01:35:00 <Andris> well, actually for Bool -> Bool there are 5 functions, right?
01:35:15 <slava> there are infinitely many
01:35:29 <Andris> I mean operationally distinguashable classes of them
01:35:35 <slava> ok
01:35:38 <tphyahoo> @djinn Bool -> Bool
01:35:38 <lambdabot> f a = a
01:35:45 <Andris> and therefore canonical members
01:35:47 <slava> Andris: i count 6
01:35:54 <Andris> hmm
01:36:00 <Andris> two constants
01:36:02 <slava> each input (True or False) can be mapped to True, False or _|_
01:36:03 <Andris> id
01:36:04 <Andris> not
01:36:09 <Andris> and bot
01:36:11 <dons> and then undefined
01:36:14 <dons> yeah
01:36:16 <Andris> 5
01:36:17 <slava> your function may just hang, too :)
01:36:27 <dons> yeah bottom
01:36:35 <Andris> ah, wait
01:36:42 <Andris> you are right
01:36:46 <vincenz> hi
01:37:07 <Andris> they can also differ in how they treat bottom as an argument
01:37:12 <dons> I wonder if small check can find them
01:37:17 <vincenz> woah
01:37:19 <vincenz> Urk! Inventing strangely-kinded void TyCon: ZCt{tc a275} (* -> *) -> * -> *
01:37:40 <Masklinn> hello there
01:37:51 <Andris> so is it 3^3 = 27?
01:37:52 <dons> ?scheck (\f -> (f :: Bool -> Bool) True)
01:37:54 <lambdabot>   Failed test no. 3. Test values follow.: {True->False;False->True}
01:38:07 <vincenz> Urk! Inventing strangely-kinded void TyCon: ZCt{tc a275} (* -> *) -> * -> *
01:38:10 <slava> Andris: you cannot write a function which returns False for bottom and True for True/False!
01:38:10 <vincenz> whoops
01:38:25 <Andris> right
01:38:28 <slava> i think if your function does not output bottom for bottom, its a constant function
01:38:29 <dons> ?scheck (\f -> (f :: Bool -> Bool) False)
01:38:30 <lambdabot>   Failed test no. 2. Test values follow.: {True->True;False->False}
01:38:31 <xpika> @where zippers
01:38:32 <lambdabot> I know nothing about zippers.
01:38:39 <xpika> damn
01:38:47 <vincenz> dons: any idea why this i sa problem:  No instance for (MonadReader (Exceptions -> m t) m)
01:38:51 <xpika> @hoogle zipper
01:38:51 <lambdabot> No matches found
01:39:04 <dons> its listing the output of the first random function it hits, that returns False
01:39:18 <dons> so I wonder if I could tweak SmallCheck to list all the functions in the domain B -> B its generating
01:39:58 <dons> ?scheck (\f x -> (f :: Bool -> Bool) x)
01:39:59 <lambdabot>   Failed test no. 4. Test values follow.: {True->True;False->False}, False
01:40:15 <dons> ?scheck (\f x -> (f :: Bool -> Bool) x `elem` [True,False])
01:40:16 <lambdabot>   Completed 8 test(s) without failure.
01:40:24 <dons> 8 !
01:40:27 <Andris> ok, so 4 constants + id + not + bot?
01:40:56 <dons> slava: ^^ type based unit tests generator :)
01:41:03 <slava> yeah, i've seen it before
01:41:33 <dons> SmallCheck is cute in that it finds minimal failure cases, and doesn't waste tests
01:41:37 <dons> unlike QuickCheck
01:41:44 <dons> ?check (\f x -> (f :: Bool -> Bool) x `elem` [True,False]) -- wasteful random walk
01:41:45 <lambdabot>  OK, passed 500 tests.
01:44:03 <dons> *SmallCheck> series :: Series (Bool -> Bool)
01:44:03 <dons> -3->
01:44:03 <dons>   [{True->True;False->True},{True->True;False->False},{True->False;False->True},{True->False;False->False}]
01:44:35 <Andris> that's easy, now where are the bottoms
01:44:53 <dons> ah,8 because I asked it to generate the args
01:44:58 <dons> so 2 x 4 functions
01:45:30 <ClaudiusMaximus> how would you implement in Haskell a box like this in a way that allows boxes with different behaviour with minimal effort?   http://imagebin.org/6871
01:45:30 <ClaudiusMaximus> the world acts on the box through two inlet actions (top) and the box acts on the world through two outlet actions (bottom).  i'm struggling with re-entrancy and state
01:45:31 <lambdabot> Title: Imagebin - A place to slap up your images.
01:45:32 <Andris> hmm, atm I have 2 non-strict functions, and 9 strict
01:45:36 <dons> ?scheck (\f -> (f :: Bool -> Bool) True `elem` [True,False])
01:45:37 <lambdabot>   Completed 4 test(s) without failure.
01:45:43 <kosmikus> Andris: that's what I have, too
01:46:53 <Andris> so QuickCheck tests only 4 out of 11 possibilities :)
01:47:02 <Andris> under 40% coverage
01:47:07 <dons> SmallCheck, in this case
01:47:22 <Andris> is QuickCheck different in this respect?
01:47:50 <Andris> and the percentage is even worse for () -> (), I imagine
01:48:11 <dons> probably not. they both use the arbitrary/coarbitrary mechanism to map the domain of the argument type into a random function
01:48:33 <dons> *SmallCheck> series :: Series (() -> ())
01:48:33 <dons> -3->
01:48:36 <dons>   [{()->()}]
01:48:42 <Andris> 1 of 3
01:49:15 <Andris> > compare (1 % 3) (4 % 11)
01:49:16 <lambdabot>  LT
01:50:04 <dons> I'd suspect we could tweak the arbitrary generators to toss in some bottoms and seqs too
01:50:21 <kosmikus> Andris: it's difficult to check with functions returning undefined, because you cannot observe undefined in Haskell
01:50:22 <Andris> and know, to really drive the point home, let's minimize the domains involved even further :)
01:50:40 <Andris> like VOid -> Void
01:50:42 <dons> kosmikus: except for the magic in QuickCheck for catching the 'undefined' exception
01:51:02 <slava> kosmikus: hurry up and solve the halting problem already
01:51:27 <kosmikus> slava: I'm working hard, but I don't know if I'll finish ...
01:51:29 <vincenz> Andris: Void == ()
01:51:45 <Andris>  meant the type without inhabitants
01:51:47 <Andris> () has one
01:51:51 <dons> > let f = f in f :: () -- slava ;)
01:51:52 <lambdabot>  Exception: <<loop>>
01:51:57 <Andris> like data Void -- that's it
01:52:07 <slava> dons: stack overflow?
01:52:15 <dons> nope. loop detection
01:52:20 <slava> ah
01:52:35 <lisppaste2> vincenz pasted "For Cale" at http://paste.lisp.org/display/34484
01:52:54 <dons> > scanr (*) 1 [1..]
01:52:57 <lambdabot>  Exception: stack overflow
01:53:10 <Andris> @data Void
01:53:11 <lambdabot> Unknown command, try @list
01:53:13 <dons> > last [1..]
01:53:17 <lambdabot> Terminated
01:53:23 <Andris> @list
01:53:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
01:54:11 <Andris> @help let
01:54:12 <lambdabot> let <x> = <e>. Add a binding
01:54:45 <dons> ?let failure = failure :: ()
01:54:46 <lambdabot> Defined.
01:54:52 <dons> > map failure [1..]
01:54:52 <lambdabot>      Expecting a function type, but found `()'
01:54:52 <lambdabot>       Expected type: a -> b
01:54:52 <lambdabot>   ...
01:55:01 <dons> > 1 * failure
01:55:02 <lambdabot>   add an instance declaration for (Num ())
01:55:07 * dons is tired
01:55:20 <dons> > case failure of _ -> True
01:55:21 <lambdabot>  True
01:55:23 <dons> good
01:55:30 <Andris>  failure
01:55:34 <Andris> > failure
01:55:35 <lambdabot>  Exception: <<loop>>
01:55:40 <dons> > fix (failure :)
01:55:41 <lambdabot>  Exception: <<loop>>
01:56:17 <Andris> ?let bogus = bogus :: Int
01:56:18 <lambdabot> Defined.
01:56:21 <Andris> ha
01:56:42 <dons> ?let notgood | False = notgood
01:56:43 <lambdabot> Defined.
01:56:51 <hopsa21> @uptime
01:56:51 <lambdabot> uptime: 1h 48m 12s, longest uptime: 1d 21h 16m 2s
01:57:04 <dons> > let bad = notgood in bad
01:57:05 <lambdabot>  Add a type signature
01:57:21 <dons> > let bad = notgood in bad  :: ()
01:57:22 <lambdabot>  Exception: <local>:8:0-24: Non-exhaustive patterns in function notgood
01:57:37 <dons> that's how Gofer used to implement 'undefined'
01:58:23 <Andris> by the way, talking of bottoms, aren't there two different bottoms in Haskell?
01:58:31 <Andris> the crashing one and the hanging one?
01:58:46 <Andris> at least as a user I see the difference
01:58:58 <Andris> @type error
01:58:59 <lambdabot> forall a. [Char] -> a
01:59:18 <Andris> > error "_|_"
01:59:18 <lambdabot>  Add a type signature
01:59:31 <Andris> > error "_|_" :: Bool -> Int
01:59:32 <lambdabot>  <Bool -> Int>
01:59:37 <dons> hehe
01:59:47 <dons> > error "_|_" :: () -- try to evaluate it
01:59:48 <lambdabot>  Exception: _|_
02:00:19 <vincenz> > undefined :: Bool -> Int
02:00:21 <lambdabot>  <Bool -> Int>
02:00:31 <metaperl> @type (***)
02:00:32 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:00:35 <vincenz> undefined === _|_
02:01:04 <nornagon> > undefined :: Bool -> [Bool]
02:01:05 <lambdabot>  <Bool -> [Bool]>
02:01:08 <nornagon> zany
02:01:34 <metaperl> > (+1) (+7) (2,2)
02:01:35 <lambdabot>   add an instance declaration for (Num (a, b))
02:02:00 <Andris> well, I believe under Curry-Howard you can prove whatever you want given false
02:02:06 <metaperl> @type (+1)
02:02:07 <lambdabot> forall a. (Num a) => a -> a
02:02:20 <Andris> so you can type undefined by any type
02:02:47 <vincenz> of course
02:02:50 <vincenz> bottom inhabits all types
02:02:53 <vincenz> that's why it's bottom
02:02:58 <Andris> right...
02:03:11 <metaperl> > (+1) *** (+8) (2,2)
02:03:12 <lambdabot>  Couldn't match `b' -> c'' against `(a, b)'
02:03:22 <dons> need some parens
02:03:29 <dons> > (+1) *** (+8) $ (2,2)
02:03:31 <lambdabot>  (3,10)
02:03:33 <metaperl> > ( (+1) *** (+8)) (2,2)
02:03:34 <lambdabot>  (3,10)
02:03:38 <metaperl> oh ok
02:04:07 <dons> > map (toUpper *** flip) $ zip "haskell" [(*), (+), div]
02:04:07 <lambdabot>  Add a type signature
02:04:17 <dons> > map (toUpper *** flip) $ zip "haskell" [(*), (+), div::Int->Int->Int]
02:04:19 <lambdabot>  [('H',<Int -> Int -> Int>),('A',<Int -> Int -> Int>),('S',<Int -> Int -> Int>)]
02:04:21 <dons> :}
02:04:57 <nornagon> ?src Arrow
02:04:58 <lambdabot> class Arrow a where
02:04:58 <lambdabot>     arr, pure   :: (b -> c) -> a b c
02:04:58 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
02:04:58 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
02:04:59 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
02:05:01 <metaperl> so those examples are done within the (->) arrow I take it? we did not have to do a runSF or runLA or something to "run" the arrow
02:05:01 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
02:05:03 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
02:05:43 <metaperl> yeah, I understand each of those arrow operators. I am reading Hughes 2004... HXT was rough-going without studying arrows in isolation
02:06:12 <metaperl> dons, what "ran" the arrow? just constructing an arrow is not enough
02:06:13 <nornagon> doing better than me then :(
02:06:25 <metaperl> nornagon - you have HXT questions?
02:06:31 <nornagon> no
02:06:38 <nornagon> just newbieing along :)
02:06:49 <xpika> (+1) &&& (2,3)
02:06:54 <metaperl> Actually arrows make all of Haskell easy
02:07:01 <xpika> > (+1) &&& (2,3)
02:07:01 <dons> ?src (***)
02:07:01 <nornagon> heh
02:07:01 <lambdabot>  Couldn't match `(->)' against `(,)'
02:07:02 <lambdabot> f *** g = first f >>> second g
02:07:07 <dons> ?src first
02:07:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:07:11 <dons> hehe
02:07:18 <nornagon> ?src (,)
02:07:18 <lambdabot> Source not found. Where did you learn to type?
02:07:30 <dons> lambdabot's got all narky
02:07:54 <metaperl> dons, what decides which arrow instance you are in and what "fires" the arrow?
02:09:55 <dons> the types :)
02:10:21 <metaperl> I see... most of the Hughes 2004 examples require something like runLA or runSF to "run" the arrow
02:10:36 <metaperl> but I guess pure functions run by default
02:10:48 <metaperl> runLA and runSF ust extracted the pure function and Haskell took it from there
02:10:50 <dons> instance Arrow (->) where
02:10:50 <dons>     arr f = f
02:10:50 <dons>     f >>> g = g . f
02:10:50 <dons>     first f = f *** id
02:10:50 <dons>     second f = id *** f
02:10:52 <dons> --  (f *** g) ~(x,y) = (f x, g y)
02:10:55 <dons> --  sorry, although the above defn is fully H'98, nhc98 can't parse it.
02:10:57 <dons>     (***) f g ~(x,y) = (f x, g y)
02:11:06 <metaperl> @type arr (+1)
02:11:09 <dons> we just use:  (***) f g ~(x,y) = (f x, g y)
02:11:36 <xpika> > (first (+3)) (3,3)
02:11:37 <lambdabot>  (6,3)
02:12:01 <metaperl> @type (arr (+1))
02:12:02 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a, Num b) => a b b
02:12:39 <metaperl> what is that tilde in front of (x,y) for?
02:12:42 <metaperl> what does it mean?
02:13:37 <dons> > let f ~(Just x) = 1 in f Nothing
02:13:38 <lambdabot>  1
02:13:47 <dons> > let f (Just x) = 1 in f Nothing
02:13:49 <lambdabot>   Non-exhaustive patterns in function f
02:14:21 <metaperl> ummm...
02:14:28 <dons> (lazy pattern bind)
02:14:37 <dons> see we didn't actually use anything in the (Just x) in the first one?
02:14:40 <metaperl> but it should not have bound at all
02:15:07 <metaperl> f == 1 only when f (Just something) though
02:15:13 <dons> it was never scrutinised, so behaved like f _ = 1
02:15:22 <metaperl> > let f _ = 1 in f Nothing
02:15:23 <lambdabot>  1
02:15:26 <dmhouse> metaperl: http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
02:15:28 <lambdabot> http://tinyurl.com/ykch9p
02:15:37 <metaperl> oh, because x was not needed
02:15:49 <metaperl> now I though haskell was lazy period
02:15:55 <metaperl> so pattern matching is eager
02:16:01 <metaperl> argument eval to function is lazy
02:16:08 <dmhouse> metaperl: pattern matching has to be eager.
02:16:29 <dmhouse> let (x, y) = someRandomTuple
02:16:58 <dmhouse> You have to evaluate the 'top level' of someRandomTuple to check it's actually a tuple, and to extract the component parts.
02:17:35 <dmhouse> let x:xs = someRandomList
02:17:47 <dmhouse> You have to evaluate the 'top level' of the list to make sure it's a cons cell.
02:18:01 <dmhouse> Evaluating the 'top level' like this is called evaluating to 'weak head normal form'.
02:18:26 <nornagon> :t 1 : 2 : 3 : []
02:18:27 <Igloo> If they're bound by a let then they're actually lazily bound
02:18:27 <lambdabot> forall a. (Num a) => [a]
02:18:35 <nornagon> :t 1 : 2 : 3
02:18:37 <lambdabot> forall a. (Num a, Num [a]) => [a]
02:18:48 <nornagon> Num [a]?!
02:18:55 <dmhouse> metaperl: try reading that wikibooks page. I think it explains it pretty well.
02:19:01 <dons> how do you terminate the list, nornagon ?
02:19:05 <metaperl> ok who wrote the Haskell wikibook?
02:19:08 <dmhouse> nornagon: it's saying that if you had an instance for Num [a], then it wouldn't be a type error.
02:19:14 <Igloo> The reason pattern matching has to be eager is that otherwise   head [] = undefined; head (x:xs) = x   would always choose the first clause and return undefined
02:19:18 <nornagon> dmhouse: ah :)
02:19:18 <dmhouse> metaperl: a bunch of people. I wrote that chapter.
02:19:33 <metaperl> oh. nice
02:20:00 <dmhouse> > let head' [] = undefined; head' x:xs = x in head' [1..5]
02:20:00 <lambdabot>  Parse error in pattern
02:20:08 <dmhouse> > let head' [] = undefined; head' (x:xs) = x in head' [1..5]
02:20:09 <lambdabot>  1
02:20:14 <dmhouse> Igloo: I disagree.
02:20:30 <Igloo> dmhouse: With what?
02:20:41 <dmhouse> Oh, wait, I see.
02:20:51 <dmhouse> Although the function's bound with a let, the patterns are bound by the function, right?
02:20:58 <nornagon> > let head [] = undefined; head ~(x:xs) = x in head [1..5]
02:20:59 <lambdabot>  1
02:21:05 <Igloo> Right
02:21:08 <nornagon> > let head ~[] = undefined; head ~(x:xs) = x in head [1..5]
02:21:09 <lambdabot>  Undefined
02:21:37 <dmhouse> In fact, in general, there's not much point having more than one equation if the first one has an irrefutable pattern, because that pattern will always be matched by the nature of irrefutable patterns.
02:28:08 <Andris> BTW, why constructors that are single in their data type are not irrefutable?
02:28:21 <rc-1> why did GHC crash when i tried to give grahms number as the arguments to the akerman function>?
02:29:09 <iah> ?ghc
02:29:09 <lambdabot> ghc says: foreign declaration uses deprecated non-standard syntax
02:29:34 <dcoutts> rc-1, perhaps that's a gmp problem, assuming you're using Integer for your ack
02:30:05 <dcoutts> rc-1, it's going to fail in one way or another, the question is how
02:30:37 <dcoutts> ack big big cannot be computed on any ordinary size machine
02:30:51 <Jaak> http://xkcd.com/c207.html
02:30:52 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
02:30:56 <dmhouse> Andris: perhaps functions would change their behaviour if you added another constructor to the datatype they're defined on?
02:31:06 <rc-1> was wondering how long it would take someone to get that :)
02:31:26 <iah> especially since the ORDER OF MAGNITUDE of the argument is larger than the number of particles in the visible universe
02:31:42 <dcoutts> rc-1, ah ok :-)
02:32:06 <dons> > maxBound :: Word4096 -- try this instead of grahams number, (not going to take too long to spot in #haskell ;)
02:32:10 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
02:32:22 * dcoutts didn't know what graham's number was but assumed that it was big
02:32:29 <dons> its kinda big
02:32:35 <Andris> dmhouse: ah, good point
02:35:19 <dons> dcoutts: http://en.wikipedia.org/wiki/Graham%27s_Numbe
02:35:22 <dons> r
02:35:35 <dcoutts> ta
02:56:44 <pejo> Can anyone comment on how close the short cut deforestation performed by ghc is to the one described in Gill's thesis?
03:04:28 <dmhouse> ?src reverse
03:04:28 <lambdabot> reverse = foldl (flip (:)) []
03:05:03 <dcoutts> pejo, it's fairly close
03:05:10 <dmhouse> Ooh, I bet ?src uses the Prelude from the report.
03:05:32 <dcoutts> pejo, Andy describes a way of doing fusion for foldl that ghc does not implement
03:05:36 <dmhouse> ?src fst
03:05:36 <lambdabot> fst (x,_) =  x
03:05:41 <dmhouse> Maybe not.
03:05:49 <dcoutts> pejo, did you want to know anything specific?
03:18:01 <dmhouse> Someone feel like reviewing a laziness article for me? :)
03:18:26 <dmhouse> Just the first 'Thunks and weak head normal form' section of http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form
03:21:24 <Igloo> dmhouse: I haven't read it in detail, but under "Let's try a slightly more complicated pattern match:" nothing is evaluated at all
03:21:58 <pejo> dcoutts, hm, well, the best would be a reference to something that does describe what it implements. If such a reference doesn't exist, I guess I could use his thesis as approximation for what GHC does implement. :-)
03:22:12 <Igloo> dmhouse: If ... is 'x', for example, then you can replace (length [1..5], reverse "olleh") with undefined and it will still evaluate to 'x'
03:22:30 <dcoutts> pejo, you can look at the code, it's just rule pragmas in a couple modules
03:22:58 <dmhouse> Igloo: good catch, I'll add a paragraph explaining that, thanks.
03:23:06 <pejo> dcoutts, oh, the implementation uses the rewriting rules present in GHC?
03:23:12 <dcoutts> pejo, yes. I think it's in GHC.Base and GHC.List
03:23:25 <pejo> dcoutts, thank you. Will look at it.
03:23:38 <pejo> (Is the rules machinery rather new, say after GHC 4?)
03:25:08 <pbx> "ghc-6.4.2_1 depends on file: /usr/local/bin/perl5.8.8 - found"
03:25:31 <pbx> eek
03:26:07 <dmhouse> pejo: do you mean GHC 6.4?
03:26:43 <dons> pbx, probably for the mangler
03:27:03 <dons> (the ancient gcc postprocessing script)
03:27:31 <pejo> dmhouse, no, 4.x.
03:29:33 <pbx> dons: I really should just close my eyes during builds anyway.  I have a similar reaction when I see checks for the Fortran 77 compiler...
03:29:55 <opqdonut> :)
03:29:57 <opqdonut> heh
03:32:28 <Azmo> is the alignment of a Word16 guaranteed to always be 2, or could it be something else on some machine?. seems to be 4 in my GHC source files, but i suspect the values might be genereated.
03:32:45 <Azmo> i mean 2, not 4.
03:36:09 <ClaudiusMaximus> Azmo: http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg11850.html
03:36:44 <e_e_coli> I was able to find areference to some versions of VAX allowing odd word-alignment
03:36:47 <e_e_coli> :)
03:36:49 <e_e_coli> but nothing else
03:36:53 <ClaudiusMaximus> Azmo: i know it doesn't answer your question directly, but you can take into account alignment at compiletime
03:37:20 <Azmo> how do you mean ?
03:41:31 <ClaudiusMaximus> Azmo: "The 68000 cannot address anything larger than a byte from an odd address; 16 and 32 bit data must be accessed from an even address. The 68020 eases this restriction; however, the time penalty for non-optimal alignment is substantial.".  but i don't know if ghc can generate 68020 code
03:42:09 <Azmo> :]
03:42:16 <sieni> ahh, those public transportation failures (i.e. bus errors)
03:43:02 <pejo> Azmo, it might be good to check sparc and VAX, unless you're looking for micro controllers and dsp's.
03:45:46 <Azmo> ok
04:01:07 <apfelmus> argh! *@$! UNIX sucks
04:01:19 <sieni> what now? :-)
04:01:29 <nornagon> what unix?
04:01:57 <sieni> if it's aix or hp/ux, then the utter suckage is common knowledge :-)
04:02:23 <apfelmus> mac os x. it's enraging, i'm trying to upgrade gtk2 for the third time now.
04:02:59 <apfelmus> the problem is trivial, some headers are missing.
04:03:12 <nornagon> get yourself a real unix ;P
04:03:18 <cperfumo> in the expression         f (x + 1) ((x + 1) + 1)      how many thunks are created for (x + 1)? Only one or two?
04:03:43 <matthew_-> in fact, if it's not solaris and it's unix, it sucks
04:03:57 <earthy> cperfumo: 2.
04:04:29 <bakert> Hi all, anyone here ever hooked up haskell to postgresql?
04:04:30 <earthy> matthew_: even solaris sucks
04:04:42 <earthy> bakert: that's been done, yes
04:04:51 <bakert> What's the best lib?  Is there one?
04:05:04 <cperfumo> earthy: ok, and if it were f (xPlus1) ((xPlus1) + 1)    with a "where" clause, it will be only one, right?
04:05:06 <apfelmus> but to keep the package tree from breaking completely, i have to recompile it every time and this just takes unsanely long.
04:05:08 <matthew_-> apfelmus: I'd hardly call osX unix. it may have some bsd userspace tools, but there's no unix kernel code in the darwin kernel.
04:05:17 <earthy> cperfumo: inded.
04:05:18 <earthy> +e
04:05:19 <Lemmih> bakert: HDBC is nice.
04:05:34 * earthy is with lemmih on that one
04:05:56 <earthy> http://www.quux.org:70/devel/hdbc
04:05:57 <cperfumo> earthy: thanks. Which documentation would you suggest me to read about the topic? Is that in any Haskell book?
04:05:57 <lambdabot> Title: Gopher: hdbc
04:06:49 <bakert> Lemmih, earthy, thanks I'll give hdbc a look.
04:06:51 <earthy> cperfumo: It'd be in the description of the G-machine
04:07:00 <apfelmus> matthew_-: i don't mean the kernel, i mean the awfully mis"designed" include/link/library/executable/object file   architecture.
04:07:22 <cperfumo> earthy: Where can I find it?
04:07:26 <earthy> apfelmus: which actually isn't all that bad, just has different goals
04:07:35 <earthy> cperfumo: somewhere on simonPJ's siet?
04:07:36 <earthy> site?
04:07:38 <nornagon> apfelmus: how do you do it better?
04:07:48 <sieni> apfelmus: how is it misdesigned?
04:07:55 <apfelmus> earthy: goals? what goals?
04:07:55 <cperfumo> earthy: ok, I will take a look. Thank you very much
04:07:58 <pbx> hrm, my FreeBSD install seems to be stuck at this stage: http://dpaste.com/4479/
04:08:13 <earthy> apfelmus: drag-and-drop installation and moving of applications
04:08:49 <earthy> (and libraries, for that matter)
04:09:02 <nornagon> personally I think the basic heirachical filesystem structure is pretty limiting
04:09:10 <nornagon> @spell heirachical
04:09:10 <lambdabot> hierarchical hierarchically hierarchal hierarchic heretical
04:09:17 <matthew_-> apfelmus: ahh yes, ok.
04:09:45 <pbx> Anybody else here install ghc from FreeBSD ports?
04:09:45 <apfelmus> earthy: huh? ok, moving binaries is possible. but moving libraries? every path is hard coded, this is just crap
04:10:21 <earthy> hard coded relative to a framework's base path
04:10:36 <daniel_larsson> pbx: I've managed, didn't have any hangup problems
04:10:50 * earthy doesn't like it either
04:10:53 <dons> pbx, yeah, talk to allbery_b, this guy, http://www.haskell.org/pipermail/haskell/2006-December/018954.html
04:10:55 <lambdabot> Title: [Haskell] ghci readline support on FreeBSD: simple patch, http://tinyurl.com/voexf
04:11:40 <apfelmus> earthy: ah, i don't mean the Framework stuff which adds a little bit of sanity. i mean /opt/local/lib and /usr/lib
04:11:59 <cperfumo> earthy: http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/student.pdf.gz It looks quite deep, but I think it's exactly what i wanted
04:12:01 <lambdabot> http://tinyurl.com/y2he99
04:12:13 <pbx> daniel_larsson, dons: Thanks.
04:12:25 <pbx> Must go to work now...
04:13:15 <apfelmus> nornagon: to merit the name "design", a linking architecture just must provide version and package control
04:13:48 <apfelmus> ./configure scripts are just a very very dirty hack.
04:14:07 <nornagon> *nod*
04:14:33 <opqdonut> yep
04:14:40 <nornagon> it'd be very difficult to get something better designed from the ground up to become widespread, though
04:14:58 <opqdonut> well scons is spreading
04:15:01 <nornagon> also, whatever you came up with probably wouldn't be future-proof
04:15:24 <nornagon> opqdonut: i mean, an entire OS :)
04:15:32 <opqdonut> ah :)
04:15:45 <apfelmus> opqdonut: scons has design flaws as well (besides not being an OS)
04:16:00 <opqdonut> yes, but it's a cleaner system than autohell
04:16:11 <opqdonut> personally, i use no-frills makefiles
04:16:12 <nornagon> right
04:16:20 <nornagon> there are a lot of things better than autotools
04:16:27 <nornagon> me too
04:16:57 <nornagon> let's write a better OS in haskell! :)
04:17:02 <nornagon> chris2!
04:17:07 <nornagon> stalker.
04:17:14 <dons> nornagon: its called House :)
04:17:16 <apfelmus> nornagon: widespread shall not be my problem. i want sanity for myself, other people may use whatever they want.
04:17:17 <dons> ?where house
04:17:17 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
04:17:23 <nornagon> dons: oh?
04:17:33 <chris2> nornagon, you here?
04:17:43 <dons> there's at least 3 OS kernels written in Haskell :)
04:17:46 <bakert> If you need to add something to Build-Depends in a cabal file, what's the syntax?
04:17:48 <nornagon> apfelmus: but what happens when you want to use something that isn't compatible? :)
04:17:55 <bakert> Do you add another line, or a comma, or a semicolon?
04:18:00 <nornagon> heh :)
04:18:00 <nornagon> chris2: i am.
04:18:01 <dons> bakert: Build-Depends:       base, unix, network, parsec, mtl, haskell-src
04:18:05 <bakert> thanks
04:18:14 <dons> you can break lines as you see fit
04:18:18 * chris2 finds all #ruby-lang people on #haskell or #concatenative :P
04:18:23 <bakert> right.  cheers dons#
04:18:25 <nornagon> :P
04:20:01 <apfelmus> nornagon: then i'm doomed, just as i am now. but at least, the nightmare on may machine gets a little smaller :)
04:20:34 <nornagon> :)
04:21:09 <nornagon> i want to write a non-hierarchical filesystem; the current model seems either disorganised or overorganised, depending on the day of the week
04:22:40 <dylan> I find I naturally think in trees, so...
04:22:51 <nornagon> i don't, really
04:23:00 <nornagon> i prefer a tag-like system
04:23:06 <nornagon> most of the time
04:23:16 <nornagon> or at least, very much shallower trees
04:23:18 <dylan> of course, I also keep all my dotfils in ~/wc/conf/dotfiles, with is almost pathological.
04:23:26 <apfelmus> well, i think the problem is that the filesystem is not typed strongly and that removing a shared file (symlink) is not implemented in a satistfying way.
04:23:46 <nornagon> mmmm, strongly typed filesystem...
04:23:50 <nornagon> that sure sounds dreamy
04:24:07 <nornagon> /usr/bin/grep :: File -> [Line]
04:24:14 <nornagon> rather
04:24:22 <nornagon> /usr/bin/grep :: String -> File -> [Line]
04:25:17 <dylan> nornagon: I do like tags though. Possum and and I were designing a filesystem tagger.
04:25:23 <nornagon> :)
04:25:40 <dylan> and dwm's tags are very nice. I can't go back to ion because of them.
04:25:41 <nornagon> it'd be nice to have things universally accessible through a number of different models
04:25:59 <nornagon> i'd like to have, eg, libs::qt::4
04:26:02 <nornagon> or so
04:26:12 <nornagon> which is basically hierarchical, but shallower
04:26:20 <nornagon> i think.
04:26:23 <nornagon> maybe not.
04:26:31 <nornagon> i'm not sure what I'm trying to say here >.>
04:26:59 <dylan> well, you could just use a non-standard filesystem hierarchy
04:27:08 <dylan> e.g. /libs/qt/4.so
04:27:27 <dylan> for the qt/4.so part you might need to rewrite the linker, but ahem...
04:27:29 <apfelmus> nornagon: you want libs/qt/4, but you do want this to be a "virtual node"
04:27:31 <nornagon> but how do i practically make something like that work?
04:27:41 <nornagon> without making my own distro :P
04:27:47 <nornagon> apfelmus: ?
04:28:30 <vegaiW> perhaps a custom filesystem?
04:29:01 <nornagon> I'd really like to devote a bunch of time to thinking about this sort of thing
04:29:10 <nornagon> but i have a million other things to do atm :)
04:29:24 <apfelmus> nornagon: i mean that this file is a mere symlink. so you can do rm /package/qt/4 and the file in libs is gone as well
04:29:39 <nornagon> mm :)
04:29:48 <vegaiW> for me, the amount of things I need to do has no correlation to my efficiency on personal projects...
04:29:54 <nornagon> I still like the idea of a strongly typed OS
04:29:58 <pejo> nornagon, you can let your distro have a base set of packages, and package your own stuff in some other hierarchy.
04:30:27 <nornagon> pejo: too much effort :P
04:30:31 <vegaiW> is House a 'strongly typed OS'?
04:30:32 <pejo> nornagon, problem is when you want it cross platform, of course.
04:30:38 <vegaiW> do we know what that even means yet?
04:30:42 <nornagon> mm
04:30:49 <apfelmus> in a sense, hierarchical libraries are already a (non-mutable) typed filesystem
04:30:51 <pejo> nornagon, shrug, there are attempts. OpenPKG, CUE, pkgsrc, etc.
04:31:04 * apfelmus goes away for lunch
04:35:21 <opqdonut> gobolinux has experimented with an alternative layout like that
04:35:23 <opqdonut> just fyi
04:37:29 <nornagon> opqdonut: any idea how well it worked?
04:40:01 <MarcWebe1> Is there any reason why I can't omit type parameters like in this type declaration type MyParser = CharParser State ? CharParser is of kind  * -> *. I'm asking because I can do this with functions arguments..
04:40:17 <pejo> nornagon, is the goal to have multiple versions of each application installed, linked against a particular version of each library?
04:40:40 <nornagon> pejo: not sure what the goal would be :)
04:41:00 <pejo> (If that is the goal I can reveal the result: lots of patching).
04:41:00 <dons> MarcWebe1: ah you want pointfree types :)
04:43:01 <julias84> > ((+4) . ((*3) . (2-))) 1
04:43:03 <lambdabot>  7
04:44:52 <lisppaste2> paolino pasted "unwanted looping definition" at http://paste.lisp.org/display/34493
04:45:27 <dons> ?users
04:45:27 <lambdabot> Maximum users seen in #haskell: 299, currently: 284 (95.0%), active: 40 (14.1%)
04:45:30 <kzm> Whee!  My first real threaded program!
04:45:44 <vincenz> kzm: ?
04:45:50 <kzm> pmap - distribute a map over a number of worker threads.
04:45:57 <vincenz> kzm: like googlemap
04:45:57 <kzm> (probably already in some std library)
04:46:04 <kzm> mapReduce?
04:46:07 <nornagon> sounds like MapReduce
04:46:12 <nornagon> yah
04:46:33 <kzm> Sure.  Anyway, I needed to play a bit with STM.
04:46:33 <vincenz> yah
04:46:38 <vincenz> Cool :)
04:46:42 <paolino> hi , anyone can fix the code I pasted?
04:46:53 <paolino> please
04:46:56 <kzm> It looks so easy on paper, but the devil is *still* in the details, I'm afraid.
04:47:38 <dons> paolino: something like:
04:47:41 <dons> list n xs = listArray (0, z-1) ls
04:47:41 <dons>     where z  = length xs
04:47:41 <dons>           ls = [Node x (map (l!) [mod (i+1) z .. mod (i+n) z]) | (x,i) <- zip xs [0 .. z-1] ]
04:47:58 <dons> note I just reformatted it so it was clearer :) I still don't understand what you're doing
04:48:06 <vegaiW> nornagon: Gobo is still under development, so one cannot yet say that it has failed
04:48:20 <apfelmus> nornagon, opqdonut: i think the problem is about "naming". we want things to have multiple names: lib/qt/4 and packages/qt/4.
04:48:24 <dons> kzm, yayy
04:48:35 <dons> I'd think SMP + STM stuff might be pretty cool for your work
04:48:37 <nornagon> vegaiW: was wondering if there were any responses positive/negative
04:48:42 <dons> maybe even the data parallel arrays
04:48:47 <nornagon> apfelmus: mm :)
04:48:50 <apfelmus> in a sense, the semantics of *NIX hard links are the wrong ones.
04:49:10 <kzm> I suspect the code is a bit on the ugly side, I'll  paste it for your amusement.
04:49:10 <vegaiW> nornagon: well, its users and developers are enthusiastic, as is usually the case with linux distros
04:49:11 <dons> Happy 1.16  - The LALR(1) Parser Generator for Haskell is out
04:49:13 <nornagon> UNIX has, IMO, a lot of sub-optimal design features
04:49:22 <dons> http://www.haskell.org/happy/
04:49:23 <nornagon> but it's so entrenched these days :)
04:49:23 <lambdabot> Title: Happy: The Parser Generator for Haskell
04:49:27 <vegaiW> nornagon: have you checked plan 9?
04:49:38 <nornagon> vegaiW: i've heard of it; haven't looked it over yet
04:49:50 <apfelmus> so when i delete a thing with multiple names all those names are gone, too.
04:50:10 <nornagon> sometimes, though you only want to delete an alias for something
04:50:12 <vegaiW> nornagon: it might be the only OS that has actually developed new practical solutions
04:50:17 <nornagon> not the thing itself
04:50:24 <julias84> > (foldr map [3] [(+1), (*2)])
04:50:25 <lambdabot>  [7]
04:50:32 <nornagon> vegaiW: *nod* I'll make a note to check it out then :)
04:50:37 <vegaiW> nornagon: ...since Unix came along
04:50:37 <paolino> dons , every element points to its n successors
04:50:50 <kzm> http://paste.lisp.org/display/34496
04:50:55 <nornagon> vegaiW: I guess there's always room for a better solution :)
04:50:57 <kzm> (Wasn't it announced?)
04:51:16 <paolino> dons and the array "cycles"
04:51:47 <apfelmus> nornagon: well, this entrenchment costs Mio of $$! imagine the save when there are no more  "configure" scripts but only clean naming semantics
04:51:55 <mux> I'm wondering if there have been situations in the past where for some type, there could be several useful monad implementations
04:51:58 <mux> has this happened?
04:52:39 <vegaiW> nornagon: Eric Raymond has stated that Plan 9's problem is that even though it's superior to others, the others are good enough
04:52:41 <Hunter> any ideas how I can make a function who calculates '*' and '/' but not '+' and '-' with the data types: data EXPR = Var String | Const Int | OpExp OPER EXPR ; data OPER = Plus | Minus | Times | Div
04:52:46 <paolino> dons your rewriting miss the 'l' definition
04:52:51 <MarcWebe1> vegaiW: No I haven't checked it. But wmii was using their shell once.. They dropped this dependency because the majority is using bash..
04:52:53 <kzm> I guess there are no equivalent of 'wait' or any way to list all existing threads?  I could manually register them, but it is so tedious.
04:52:53 <apfelmus> vegaiW: plan9 doesn't do "delete one name => delete all names", does it?
04:52:58 <nornagon> apfelmus: Problem is, I'm vastly under-qualified to come up with a solution :)
04:53:11 <nornagon> vegaiW: that's a good point
04:53:24 <nornagon> there has to be some kind of feature that makes it worth switching to
04:53:41 <vegaiW> yeah, there has to be a feature (or several) that actually make the older systems obsolete
04:53:58 <apfelmus> nornagon: well, switching is mostly a hardware problem
04:54:09 <mux> kzm: I don't think there is, the usual solution is to have an mvar for each thread, and wait on this
04:54:39 <vegaiW> apfelmus: it doesn't have links in the same way as Unix does, so I'd guess that that problem doesn't exist there.
04:54:48 <kzm> Surely, the runtime has a table of threads already?
04:55:09 <nornagon> apfelmus: i.e, the fact that it's so hard to beat linux's hardware compatability?
04:55:10 <mux> it probably has
04:55:16 <fasta> What is a multi-sorted algebra?
04:55:17 <nornagon> @spell compatability
04:55:18 <lambdabot> compatibility computability comparability
04:55:44 <paolino> dons, probably I must use Node Float [Int] and point to indeces, right ?
04:55:44 <apfelmus> nornagon: i the os doesn't run on your computer, you can't switch to it :)
04:56:40 <nornagon> apfelmus: right
04:57:01 <vegaiW> except if it's so good that it motivates you to switch your computer
04:58:20 <paolino> anyway I wonder if there is a way to define such a recursive structure
04:59:15 <nornagon> vegaiW: the trick would be to just support everything linux does
04:59:17 <nornagon> somehow
04:59:32 <nornagon> perhaps write some kind of wrapping layer so you can use linux drivers
04:59:35 <nornagon> reactos-style
05:01:01 <apfelmus> vegaiW: true. i'd switch to an os that doesn't throw all executables in IO and provides a typed file system that manages to provide easy versioning/package support.
05:01:51 <MarcWebe1> apfelmus: Wrong. There are applications like qemu or bochs, colinux .. ;-)
05:03:50 <apfelmus> MarcWebe1: load two systems when you only need one? i'd rather not. (but one can be stripped done to the bones). but my problem is the processor: i have a ppc
05:04:12 <nornagon> well ideally that should be a trivial issue ;p
05:04:40 <nornagon> i should know more about haskell.
05:04:44 <MarcWebe1> apfelmus: What about cd / ; darcs initialize and alias writeFile f c = writeFile f $ show c , alias readFile f = liftM readToException $ .. ;-) *lol*
05:04:45 <vegaiW> nornagon: I don't think one can reach the kind of superiority I'm talking about without completely cutting life support to older systems
05:04:57 <vegaiW> nornagon: except for standard protocols
05:05:02 <nornagon> vegaiW: *nod*
05:05:24 <nornagon> then yes, hardware support is a huge huge problem
05:05:35 <hyrax42> :t flip mapM_
05:05:40 <nornagon> it would be so nice if all pc hardware conformed to specific standards
05:05:51 <hyrax42> ?type flip mapM_
05:06:20 <nornagon> i've been fiddling with coding on the nintendo ds recently; it's so nice to not have to worry at all about compatibility
05:06:27 * SimonRC finds out what STM is.
05:06:30 <SimonRC> Very nice.
05:06:37 <hyrax42> nornagon: what is the state of that
05:06:46 <apfelmus> MarcWebe1: hey that's serious :)
05:06:53 <hyrax42> I just finally got myself an M3 and have been thinking of poking around
05:06:58 <nornagon> hyrax42: very happy, I'd say :)
05:07:12 <nornagon> drop by irc.blitzed.org#dsdev
05:08:44 <augustss> Has anyone looked at Jim Apples GADT example (from the haskell mailing list yesterday)?
05:09:55 <vegaiW> nornagon: or perhaps it should be so that software is required to conform to standards
05:10:12 <vegaiW> and hardware can do whatever they want
05:10:30 <nornagon> so long as they speak the same standards as the software
05:10:44 <vegaiW> we already have a primitive form of this, via protocols such as tcp/ip, http...
05:11:55 <MarcWebe1> The only serious solution is building a system which runs on current oses because you can't manage to write so much drivers... and if you could you would get tired of it soon.. Another example is unununium (see this page import Data.Array
05:11:59 <MarcWebe1> data Node = Node Float [Node]  deriving Show
05:12:01 <MarcWebe1> list n xs =
05:12:04 <MarcWebe1>   let l = listArray (0,z-1) [Node x (map (l!) [mod (i+1) z..mod (i+n) z]) | x <- xs | i <- [0..z - 1]]
05:12:07 <MarcWebe1>       z = length xs
05:12:09 * MarcWebe1 apologizes
05:12:42 <MarcWebe1> http://unununium.org/developer_faq to see that they are still lacking man power (and I think they will forever..)
05:12:43 <nornagon> that's one hell of a URI :P
05:12:43 <lambdabot> Title: Unununium OS :: Developer FAQ
05:14:01 <MarcWebe1> lambdabot is really cool ( but not as cool as its/his/her developers !)
05:14:15 <nornagon> i think lambdabot is a she
05:14:36 <profmakx> http://www.cse.unsw.edu.au/~dons/lambdabot.html <-
05:14:36 <lambdabot> Title: lambdabot
05:14:38 <profmakx> see ther
05:14:41 <profmakx> +e
05:15:01 <koala_man> haha
05:15:02 <hyrax42> ?type mapM_
05:15:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
05:15:09 <hyrax42> ?typ forM_
05:15:10 <lambdabot> Not in scope: `forM_'
05:15:20 <hyrax42> ?type forM_
05:15:21 <lambdabot> Not in scope: `forM_'
05:15:25 <hyrax42> :index forM_
05:15:34 <hyrax42> ?index forM_
05:15:34 <lambdabot> bzzt
05:15:41 <matthew_-> ?type mapM_
05:15:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
05:15:47 <hyrax42> ?index forM
05:15:47 <lambdabot> bzzt
05:15:50 <hyrax42> hm
05:16:14 <hyrax42> well never mind then
05:16:20 <matthew_-> surely forM == mapM_ ?
05:16:28 <matthew_-> seeing as the b would typically be ()
05:18:08 <hyrax42> matthew-_: oh, I had though that forM_ = flip mapM_ was in the libs somewhere
05:20:12 <hyrax42> :t modifyMVar_
05:20:21 <hyrax42> ?type modifyMVar_
05:20:22 <lambdabot> Not in scope: `modifyMVar_'
05:20:37 <hyrax42> hoogle modifyMVar_
05:20:45 <hyrax42> ?hoogle modifyMVar_
05:20:46 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
05:32:14 <dcoutts> Igloo, ah, you fixed it!
05:32:41 <Igloo> I believe so, yes  :-)
05:33:24 <dmhouse> Yay! :) (What did Igloo fix?)
05:34:18 <ArtemGr> could somebody answer a question here: http://paste.lisp.org/display/34501
05:34:44 <Igloo> dmhouse: A bug about stacks being incorrectly marked executable
05:36:14 <Igloo> ArtemGr: You can test yourself with   let !x = undefined in 'c'
05:36:20 <Igloo> ArtemGr: Both are strict
05:36:37 <ArtemGr> Igloo: thanks!
05:37:13 <Igloo> ArtemGr: Oh, except you want a ! on the tuple in the second line
05:37:40 <ArtemGr> Igloo: all right
05:37:42 <Igloo> ArtemGr: The let one is actually stricter as the case one doesn't force the variables to WHNF
05:38:59 * Igloo wonders what   let Just !x = Just undefined in 'c'   is actually meant to do
05:39:31 <dmhouse> > let Just !x = Just undefined in 'c'
05:39:32 <lambdabot>      Constructor `Just' should have 1 argument, but has been given 0
05:39:32 <lambdabot>     When...
05:39:51 <dmhouse> Lambdabot appears to not support bang patterns.
05:40:29 <ArtemGr> It would be good if GHC docu in http://www.haskell.org/ghc/docs/latest/html/users_guide/faster.html explicitly mentioned that "let !x = foo" is even better than "case foo of x ->".
05:40:31 <lambdabot> Title: 6.2. Faster: producing a program that runs quicker, http://tinyurl.com/yfsydq
05:41:12 <dmhouse> Prelude> let Just !x = Just undefined in 'c'
05:41:12 <dmhouse> 'c'
05:41:44 <therp> just a naming question: how would you name the list that is destructed as x:xs? all_xs, xs', lst? .. so all_xs@(x:xs) ?
05:41:54 <Igloo> dmhouse: I know what it /does/, I was wondering what it /should/ do  :-)
05:42:02 <lisppaste2> dmhouse pasted "Haskell-prime-report build problems" at http://paste.lisp.org/display/34503
05:42:02 <nornagon> therp: l
05:42:12 <dmhouse> Igloo: oh, my mistake. :)
05:42:31 <dmhouse> I'm having troubles building haskell-prime-report.
05:42:32 <therp> nornagon: any particular reason? there is no visual connection to "x"..
05:42:38 <Igloo> therp: xs@(x:xs')
05:42:39 <dmhouse> ^^ The paste demonstrates it.
05:42:59 <nornagon> therp: only matters if you have multiple lists :)
05:43:03 <Igloo> dmhouse: What version of flex do you have?
05:43:13 <dmhouse> Igloo: just installed it from apt
05:43:19 <dmhouse> 2.5.31
05:43:35 <therp> nornagon: I need a naming habbit that is stable also in the multi-list situation :) ..
05:43:38 <dmhouse> There is also a flex-old in apt, do I want that instead?
05:43:49 <nornagon> therp: lx, then?
05:43:52 <dmhouse> That's 2.5.4a.
05:44:01 <Igloo> Try with that (and if it works, whinge  :-)  )
05:44:18 <therp> nornagon: sounds better.. I was wondering what other ppl are using
05:44:44 <nornagon> i haven't come across a multi-list situation, but most of the time i just make things up as i go along
05:45:34 <dylan> @tell sorear you've done the impossible
05:45:35 <lambdabot> Consider it noted.
05:46:39 <nornagon> ?
05:47:32 <benc__> anyone know any pointers to making parsec hand out good errors? (I suspect maybe its something to do with designing the grammar in a certain way?)
05:48:01 * benc__ is playing with a parser for a language that is structured sort-of C/Java like syntactically
05:48:27 <benc__> but I've managed to construct my grammer so that when it fails, it just complains that the first character on a line is wrong...
05:48:54 <dmhouse> benc__: Try using the <?> function.
05:54:15 <pejo> dmhouse, they did some very smart stuff from .4a to .31 - removed a few macros too iirc. Really sweet move for such a small upgrade.
06:05:50 <dmhouse> ?tell kowey to check out my new comments at http://en.wikibooks.org/wiki/Talk:Haskell#Move_to_Haskell_wiki.3F
06:05:51 <lambdabot> Consider it noted.
06:05:57 <dmhouse> ?ask kowey to review the new contents on the Main Page
06:05:58 <lambdabot> Consider it noted.
06:06:42 <syntaxfree> In spite of content-free long meandering rants like the ones by that syntaxfree fellar, programming.reddit.com seems to be improving again these days.
06:06:50 <syntaxfree> What's with the jwz obsession, though?
06:07:57 <bakert> he's a rock star baby
06:08:08 <pbx> syntaxfree: Maybe somebody just discovered his website?
06:09:08 <pbx> Compare and contrast:  http://programming.reddit.com/info/xcoh/comments  http://reddit.com/info/3776/comments
06:09:10 <lambdabot> Title: "Your &#39;use case&#39; should be, there&#39;s a 22 year old college student li ...
06:09:25 <syntaxfree> jwz was one of my teenage idols when I was, maybe, 13.
06:09:42 <syntaxfree> more like 15 I think.
06:09:52 <vincenz> hmm
06:10:01 <vincenz> Itkovian: ping
06:19:02 <Masklinn> syntaxfree > I strongly disagree with you, syntaxfree is awesome, don't you go dissing him
06:19:41 <syntaxfree> haha. That Slava Pestov guy who commented on my blog is, like, the creator of Factor.
06:19:47 <syntaxfree> No wonder he got pissed off.
06:19:51 <bakert> stupid question - how do I run a string over multiple lines?
06:20:17 <syntaxfree> I wonder when and Brian Kernighan and Bill Joy and Bjarne Stroustroup are gonna find out about me!
06:20:25 * syntaxfree goes and disses C++ on his blog.
06:20:49 <wilx|wrk> Heh.
06:21:35 <syntaxfree> oh, goody. I'm making enemies. I must be doing something right : )
06:22:18 <ndm> Cabal question
06:22:25 <ndm> how do i update cabal with Hugs?
06:23:01 <ndm> with GHC you can pass -cpp to it, and it works, but Hugs doesn't have that facilty
06:23:15 <ndm> and i've hit a Hugs + Cabal bug, and want to reproduce against the latest version
06:23:46 <Itkovian> vincenz: hi
06:25:16 <tphyahoo> >  let func = (+) in 1 `func` 2
06:25:17 <lambdabot>  3
06:25:33 <tphyahoo> but ......
06:25:43 <Igloo> ndm: Doesn't -Fcpp do it?
06:25:55 <tphyahoo> 1 `(+)` 2
06:26:03 <tphyahoo> > 1 `(+)` 2
06:26:03 <lambdabot>  Parse error
06:26:06 <ArtemGr> syntaxfree: "I replied to this post in the most polite way I could, but perhaps I should not have bothered" http://factor-language.blogspot.com/
06:26:08 <lambdabot> Title: Factor: a stack language
06:26:32 <ndm> Igloo: no cpp on this system, but i'll try and fake it...
06:26:38 <tphyahoo> Can I get around the parse error some more elegant way?
06:26:46 <kzm>  Anyway: is there a parallel map in the standard libraries?  It seems obvious, but I couldn't find it.
06:27:09 <nornagon> hm, how would I go about defining my own TokenParser thingies? there's a hexadecimal token, but it seems to requre input in the form 0[xX](blah)
06:27:32 <kzm> I put my implementation at http://www.ii.uib.no/~ketil/bioinformatics/repos/pmap/ - feel free to look and comment (and send patches :-)
06:27:34 <lambdabot> Title: Index of /~ketil/bioinformatics/repos/pmap
06:27:44 <ndm> Igloo: no cpp here, and cpphs doesn't quite match the syntax...
06:28:31 <syntaxfree> ArtemGr: yes, I saw it.
06:28:31 <Igloo> ndm: Making it cpphs-compatible would probably be worth doing anyway
06:28:45 <syntaxfree> I replied to his comment in the body of my post before seeing *his* post.
06:28:48 <ndm> Igloo: i guess, but i really just want to install filepath...
06:29:04 <syntaxfree> @spell enmity
06:29:04 <lambdabot> enmity
06:29:14 <ndm> Igloo: i probably won't though, since WinHugs doesn't support the -Fcpp very well anyway, i'd want to fix up that first
06:29:26 <syntaxfree> well, I guess enmity helps both his overinflated ego and *my* overinflated ego survive ; )
06:29:45 <Itkovian> is there a good guide on the wiki on how to write bindings to an existing C lib?
06:30:13 <bakert> How do I import a module that is in a subdirectory of the current directory?
06:30:54 <syntaxfree> subdirectories are mapped into hierarchical module names, IIRC.
06:31:00 <bakert> ah.
06:31:22 <bakert> and magically capitalised?  let's find out ...
06:31:34 <bakert> oh, no.
06:32:11 <syntaxfree> http://web.mit.edu/ghc/www/users_guide/syntax-extns.html#hierarchical-modules
06:32:12 <bakert> didn't work out for me.  i think i need to somehow tell it to search down the directory structure???
06:32:13 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/yjva2l
06:32:17 <syntaxfree> http://web.mit.edu/ghc/www/users_guide/separate-compilation.html#search-path
06:32:19 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/ydybj7
06:32:48 <syntaxfree> that looks like an outdated ghc manual, but it shoud apply.
06:33:33 <bakert> yeah, i need to add the dir to the search path.
06:33:36 <bakert> it looks like.
06:33:43 <bakert> with -i
06:33:45 <bakert> thanks syntaxfree
06:36:38 <syntaxfree> np. I learned something out of it as well!
06:37:19 <bakert> i think i need to say module Foo.Bar in my actual file as well, not enough to just qualify in the import.
06:38:13 <bakert> hmm .. no that doesn't work either.
06:38:15 <tphyahoo> how do I get the type of + ?
06:38:17 <tphyahoo> :t +
06:38:22 <bakert> :t (+)
06:38:23 <lambdabot> forall a. (Num a) => a -> a -> a
06:38:30 <tphyahoo> But what about when not in parens?
06:38:49 <dmhouse> tphyahoo: that is +.
06:38:52 <bakert> well the parens are just there to say "i mean the function + i'm not doing anything with it"
06:39:06 <dmhouse> tphyahoo: when you want to find the type of an operator, you need to surround that operator in brackets.
06:39:08 <dmhouse> ?type (++)
06:39:09 <bakert> i suppose otherwise it is an incomplete statement or something
06:39:10 <lambdabot> forall a. [a] -> [a] -> [a]
06:39:15 <syntaxfree> parens make it a section.
06:39:16 <dmhouse> ?type (*)
06:39:18 <lambdabot> forall a. (Num a) => a -> a -> a
06:39:18 <syntaxfree> > (+) 2  3
06:39:18 <tphyahoo> are operators things that are infix?
06:39:22 <lambdabot>  5
06:39:25 <syntaxfree> > (+2) 3
06:39:26 <lambdabot>  5
06:39:33 <dmhouse> tphyahoo: operators are functions whose names are entire non-alphanumeric characters.
06:39:39 <syntaxfree> tphyahoo: yes. Operators are just functions with special s yntax.
06:39:50 <tphyahoo> but not always necessarily infix... ?
06:40:04 <dmhouse> You can use them prefix by surrounding them with brackets.
06:40:07 <dmhouse> > (+) 2 4
06:40:08 <lambdabot>  6
06:40:25 <dmhouse> You can also use standard functions infix by using backticks.
06:40:26 <syntaxfree> tphyahoo: you can also use regular functions infix using backticks.
06:40:30 <dmhouse> > 3 `elem` [1..4]
06:40:31 <lambdabot>  True
06:40:55 <syntaxfree> In occasions like this, it was a honored tradition of IRC to say, "Great Minds Think Alike".
06:41:03 <dmhouse> tphyahoo: try http://en.wikibooks.org/wiki/Haskell/More_on_functions#Infix_versus_Prefix
06:41:08 <lambdabot> http://tinyurl.com/yxvt8f
06:41:46 * dmhouse has to dash
06:41:51 <syntaxfree> dash?
06:41:58 <tphyahoo> Is the backticking / paren surrounding thing a function? or "syntactic sugar"?
06:42:57 <tphyahoo> ah, I see, (+) reallly *is* the function.
06:43:07 <tphyahoo> + is derived from (+) ... right?
06:43:48 <syntaxfree> you could see it that way.
06:43:54 <syntaxfree> > 2 `(+)`  3
06:43:55 <lambdabot>  Parse error
06:44:01 <syntaxfree> no, you can't see it that way : )
06:44:21 <bakert> syntaxfree, "got to dash" or "must dash" is a british expression for "got to go"
06:45:09 <tphyahoo> that's what I wanted to ask about. why `( )` doesn't do what I expect.
06:45:58 <tphyahoo> > let func = (+) in 1 `func` 2
06:45:59 <lambdabot>  3
06:46:11 <tphyahoo> but not the other way.
06:46:21 <syntaxfree> @all-dict petard
06:46:22 <lambdabot> Error: connect: does not exist (Connection refused)
06:46:22 <tphyahoo> > 2 `(+)`  3
06:46:22 <lambdabot>  Parse error
06:46:29 <syntaxfree> @spell petard
06:46:30 <lambdabot> petard
06:51:22 <bringert> dcoutts: what happend to the alex bytestring stuff you guys hacked on here at chalmers? did that make it into alex?
06:57:19 <bakert> What's a Fractional String?
06:57:23 <araujo> good morning
06:58:08 <Igloo> bakert: It sounds like you've made an error in your program
06:58:09 <therp> is there a standard name for \x,y -> y x?
06:58:16 <Jaak> > ("" :: String) / 1
06:58:16 <bakert> Igloo, sure does!
06:58:17 <lambdabot>   add an instance declaration for (Fractional String)
06:58:17 <lambdabot>     In the definition o...
06:59:15 <bakert> i see ... i've treated a string like a number somewhere?
06:59:41 <bakert> ah yes ... that's better.
06:59:45 <bakert> thanks
06:59:57 <flux__> @pl \ (x, y) -> y x
06:59:57 <lambdabot> uncurry (flip id)
07:01:16 <therp> flux: that's not exactly the same.. I'm using it in continuation passing style and it's sort of the identity-continuation.
07:05:55 <therp> huch, what's wrong with "data Foo = Bar (String -> (String -> a) -> a)"? why can't I use type variables in function signatures here?
07:06:22 <dcoutts_> therp, it's missing from the type decl
07:06:24 <dcoutts_> try:
07:06:32 <dcoutts_> data Foo a = Bar (String -> (String -> a) -> a)
07:06:40 <therp> dcoutts: that's not my intention
07:06:49 <dcoutts_> perhaps you mean forall ?
07:06:51 <therp> the type is not parametrized over a.
07:07:05 <therp> dcoutts: yes, but why don't I get implicity quantification here?
07:07:12 <dcoutts_> is it supposed to be extentially qualified?
07:07:17 <therp> no
07:07:23 <dcoutts_> therp, you have to be explicit about that kind of thing
07:07:38 <therp> Bar holds a function that takes an arbitraty contination to finally produce a value of type a
07:07:39 <dcoutts_> data Foo = Bar (forall a. String -> (String -> a) -> a)
07:08:07 <therp> dcoutts: why is that necessary for ADT declarations? .. for functions this type sig works just fine
07:08:53 <dcoutts_> it's not quite the same
07:08:54 * therp searches for his copy of the haskell 98 report..
07:09:08 <dcoutts_> this is rank-2 iirc
07:12:42 <ArtemGr> strange, the "\endash\endash print-libdir" option, docummented in GHC "4.17.1. Help and verbosity options" doesn't work: "ghc \endash\endash print-libdir" prints "ghc-6.6: does not exist: \endash\endash print-libdir"...
07:13:33 <therp> dcoutts: is there anything in haskell wiki that will shed light on that topic, for someone who does not know the difference between rank 1/2.
07:13:42 <allbery_b> sounds like documentation formatting blew up.  "ghc --print-libdir"
07:13:53 <allbery_b> (works here)
07:14:33 <ArtemGr> allbery_b: thanks!!
07:14:56 <dcoutts_> therp, hmm, google for rank 2 polymorphism or higher rank polymorphism
07:16:30 <swiert> dcoutts_: did you get my email?
07:17:17 <quazimodo> hullo fellows
07:17:26 <nornagon> ?hoogle Integer -> Double
07:17:27 <lambdabot> No matches, try a more general search
07:17:32 <nornagon> ?hoogle Int -> Double
07:17:33 <lambdabot> No matches, try a more general search
07:17:37 <quazimodo> what is hoogle?
07:17:57 <nornagon> ?hoogle a -> Double
07:17:57 <lambdabot> No matches, try a more general search
07:18:09 <pejo> quazi, gives functions matching a type signature. Very useful.
07:18:20 <pejo> ?hoogle a -> a
07:18:21 <lambdabot> Prelude.id :: a -> a
07:18:21 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
07:18:21 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
07:18:36 <Saizan> > (fromIntegral 1) :: Double
07:18:37 <lambdabot>  1.0
07:18:50 <quazimodo> pejo: that would give you hundreds of functions then?
07:18:55 <nornagon> Saizan: ah, neat.
07:18:57 <nornagon> thanks
07:19:03 <quazimodo> well, as many that it knows of that math the type sig?
07:19:08 <quazimodo> match, even
07:20:38 <pejo> quazi, oh, it's just a matching between the type signature you give and what is defined in the modules it knows about. You saw for a -> a, only 3 functions it considered matching.
07:22:09 <quazimodo> fair enough i guess
07:22:15 <quazimodo> my brain has turned into mush lately
07:22:30 <allbery_b> hoogle chops of at 3 anyway, dosn't it?
07:22:39 <quazimodo> i think its this fluxbox theme i have been using, i havent changed it for too long
07:22:43 <allbery_b> @help hoogle+
07:22:43 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
07:24:25 <Saizan> allbery_b: it uses @more it there's more
07:31:01 <syntaxfree> ?hoogle a
07:31:02 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
07:31:02 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
07:31:02 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
07:31:10 <syntaxfree> : (
07:31:25 <syntaxfree> ?hoogle Int
07:31:26 <lambdabot> Data.Int :: module
07:31:26 <lambdabot> Prelude.Int :: data Int
07:31:26 <lambdabot> Text.Read.Int :: Integer -> Lexeme
07:36:39 <bakert> Say I have a list of Maybes and I want to filter out the Maybe-ness and just end up with a list of values (all Nothings discarded), how would I do that?  Apols for the elementary question ... still learning!
07:37:04 <syntaxfree> what is fptools?
07:37:41 <dcoutts_> swiert, yes, I got the emails but I've just checked with reception and I don't have the parcel. :-( What address was it mailed to?
07:38:12 <allbery_b> ?ty catMaybes
07:38:36 <allbery_b> ?type catMaybes
07:38:38 <lambdabot> forall a. [Maybe a] -> [a]
07:38:40 <dcoutts_> swiert, I thought it might have been kept back and not stuck in my file as it would be a bit big, but there's nothing in their oversized mail cupboard for me
07:38:48 <bakert> allbery_b, thanks!
07:38:55 <bakert> is that in List?
07:39:03 <allbery_b> ?index catMaybes
07:39:04 <lambdabot> Data.Maybe
07:39:16 <bakert> thanks ... didn't know about "index" that's cool.
07:39:23 <allbery_b> lambdabot is your friend :)
07:39:49 <swiert> dcoutts: Hmm that's a bit worrying.
07:39:57 <dcoutts_> swiert, yes
07:40:11 <swiert> dcoutts: I'll e-mail CUP and CC you.
07:41:24 <dcoutts_> swiert, thanks
07:45:05 <pbx> syntaxfree: Enjoying your "defense of purity"
07:45:35 <syntaxfree> : )
07:45:59 <pbx> How come the Factor dude didn't post code?
07:46:32 <syntaxfree> dunno. I've seen the factor dude here before, so I don't doubt he's Haskell-initiated.
07:48:10 <bakert> what's the url?
07:49:02 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/08/haskell-bondage-and-discipline-and-separation-of-concerns-programming/
07:50:11 <nornagon> ?hoogle fromFractional
07:50:12 <lambdabot> No matches found
07:50:21 <malebria> @hoogle instance MonadPlus IO
07:50:21 <lambdabot> Did you mean: Instance MonadPlus IO
07:50:23 <nornagon> ?hoogle toInteger
07:50:24 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
07:50:24 <maskd> syntaxfree: where has the sidebar gone?
07:50:35 <malebria> @hoogle Instance MonadPlus IO
07:50:35 <nornagon> ?hoogle toIntegral
07:50:35 <lambdabot> No matches, try a more general search
07:50:36 <lambdabot> No matches found
07:50:41 <nornagon> :(
07:51:33 <nornagon> ?hoogle a -> Int
07:51:34 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:51:34 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:51:34 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:51:50 <nornagon> ?hoogle Double -> Int
07:51:51 <lambdabot> No matches, try a more general search
07:51:57 <nornagon> ?hoogle Floating -> Int
07:51:58 <lambdabot> No matches, try a more general search
07:52:04 <nornagon> ?hoogle Floating a => a -> Int
07:52:04 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:52:05 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:52:05 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:52:07 <nornagon> gr
07:52:12 <nornagon> make hoogle better
07:52:22 <nornagon> ?doc
07:52:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:53:29 <allbery_b> ?type truncate
07:53:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:54:40 * syntaxfree closes his eyes and imagines Factor people clicking the little down arrows in reddit furiously. And smiles.
07:54:50 <allbery_b> the numeric hierarchy is a PITA :/
07:55:37 <syntaxfree> the numeric hierarchy should at least have rings.
07:56:17 <dcoutts_> 5 gold rings, 4 calling birds, 3 french hens, 2 turtle doves and a partridge in a pear tree
07:56:41 <scriptdevil> ?post
07:56:46 <scriptdevil> ?paste
07:56:46 <lambdabot> http://paste.lisp.org/new/haskell
07:57:01 <benja_> hmm, anybody know if there's a monad encapsulating breadth-first search?
07:58:46 <dcoutts_> benja_, sounds familiar but I can't recall. Sounds quite doable though, it's just a state monad with a dqueue right?
07:59:00 <dcoutts_> or is it more subtle...
07:59:27 <lisppaste2> ScriptDevil pasted "What error is this?" at http://paste.lisp.org/display/34510
07:59:48 <benja_> dcoutts_: what's a dqueue?
08:00:03 <scriptdevil> any help with that paste?
08:00:19 <dcoutts_> benja_, a double ended queue, ie you put them in one end and take them off the other end
08:00:46 <allbery_b> scriptdevil: import List
08:00:46 <chessguy> 'morning haskellers
08:00:46 <syntaxfree> scriptdevil: can't you just import Data.List?
08:01:49 <dcoutts_> benja_, actually it only needs a queue, not a dqueue
08:02:00 <benja_> hmm. I thought perhaps a writer monad which writes values of (m a) and a wrapper function which keeps a list of stuff yet to run
08:02:19 <scriptdevil> err.. u meanimport Data.List and then do only fidIndices?
08:02:46 <syntaxfree> yes!
08:02:54 <allbery_b> fully qualifying a name doesn't bring it into scope, you still need to import it from somewhere
08:02:58 <benja_> ... lists [m a] actually. I haven't thought it out too well since I thought I'd look what's  there first :)
08:02:58 <syntaxfree> Hahaha.  "A common misconception is that the 'points' of pointfree style are the (.) operator"
08:03:15 <allbery_b> either that, or import qualified and use the full name
08:03:59 <scriptdevil> thanks
08:05:30 <cjeris> syntaxfree: wouldn't that make it point-saturated style?
08:05:39 * benja_ thinks ($$) would be a good name for (.) in haskell'
08:05:53 <dcoutts_> benja_, you've seen the queue implemented as ([a], [a]) ?
08:05:57 <syntaxfree> (.) is good.
08:06:03 * dcoutts_ agrees with syntaxfree 
08:06:09 <syntaxfree> it resembles math notation. ($$) would be confusing.
08:06:24 <syntaxfree> what Haskell needs is (&) = flip (.)
08:06:36 * cjeris thinks what haskell needs is the APL keyboard :D
08:06:42 <dcoutts_> or | like unix :-)
08:06:52 <syntaxfree> (&) means "then".
08:07:05 <syntaxfree> double . square actually means "square, then double".
08:07:09 <benja_> dcoutts_: no, I haven't
08:07:14 <syntaxfree> it would be useful for bind-notation monadic code.
08:07:41 <syntaxfree> interact = getChar >>= f & putStr
08:07:54 <lisppaste2> ScriptDevil annotated #34510 with "No What??" at http://paste.lisp.org/display/34510#1
08:08:13 <scriptdevil> one more thingnow again.. another problem
08:08:35 <cjeris> you can't use the character ; in infix operator tokens, can you?
08:08:45 <dcoutts_> benja_, it's quite neat, ([], []) it represents the front and the reversed tail of the queue. Things get added to the front of the reversed tail, things get taken off the front. when the front is empty you reverse the tail and make it the new front. giving O(1) amortised complexity
08:09:02 <slava> hi syntaxfree, comparing factor to unlambda and melbodge is unfair, because your fibonacci lazy list example etc is not a one-liner in those languages
08:09:43 <benja_> ($$) would generalize to ($$$) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)
08:09:47 <slava> syntaxfree: you clearly didn't bother learning it or you didn't understand something. i used to feel the same about haskell 2 or 3 years ago, criticizing it for needing monads to do basic i/o, etc
08:09:47 <syntaxfree> oh, well. I wasn't "comparing them". I was just saying "These things can be written in Factor!" is not a good argument.
08:10:02 * benja_ needs that sometimes
08:10:05 <slava> i said they can be written in factor /and they look almost like hte haskell code you showed/
08:10:09 <benja_> dcoutts_: ok, neat!
08:10:21 <slava> factor has every abstraction haskell does and many more
08:10:43 <syntaxfree> well, yes. The whole article is about defending the "hoops" one seems to need to jump through to get I/O done are worth it.
08:10:45 <scriptdevil> people.. any replies to that paste ??
08:10:50 <resiak> @pl \f g x y -> f (g x y)
08:11:03 <syntaxfree> I could just s/Factor/RPN there. It's not important.
08:11:13 <slava> no it shows you don't understand stack programming
08:11:15 * resiak looks pointedly at lambdabot.
08:12:03 <syntaxfree> I don't understand a lot of things. Did you even *see* the "About" page?
08:12:13 <syntaxfree> It's not like if I was posting to Communications of the ACM. Sheeesh.
08:12:39 <slava> i'm not particularly concerned, because i know i'm better than you anyway. i just wanted to inform you that you were wrong
08:13:01 <slava> you might want to do some research, if you ever want to go beyond the equivalent of "OMG monads are scary!!!111" stage, that's all
08:13:03 <earthy> whoa whoa whoa
08:13:18 <earthy> slava, please stop the personal attacks, will you?
08:13:19 <bakert> I can't believe haskell.  I finally got my web-scraping, database-using program working from end to end and in the process squeezed it down to 59 lines!
08:13:22 <scriptdevil> I don't understand a lot of things. Did you even *see* the "About" page?
08:13:22 <scriptdevil> 21:36 < syntaxfree> It's not like if I was posting to Communications of the ACM. Sheeesh.
08:13:32 <scriptdevil> sorry..
08:13:33 <slava> bakert: what personal attacks?
08:13:39 <scriptdevil> tahts not what i wanted to paste
08:13:42 <bakert> 59!  And I am a clueless newbie.  I'm sure it could be less than that!
08:13:43 <syntaxfree> scriptdevil: that wasn't directed at you, man!
08:13:51 <scriptdevil> http://paste.lisp.org/display/34510#1
08:13:53 <metaperl> bakert - nice job.
08:14:03 <scriptdevil> tis is what i wanted to paste///
08:14:07 <earthy> slava: you're attacking syntaxfree with an axe that I can feel the edge of... from the side!
08:14:17 <scriptdevil> syntaxfree: i meant i pasted a wrong text
08:14:21 <syntaxfree> oh, ok :)
08:14:22 <metaperl> slava - bakert  said nothing to you
08:14:26 <vincenz> Everyone, calm down lplease
08:14:29 <syntaxfree> scriptdevil: why did you quote me then?
08:14:35 <metaperl> what's the URL to Factor?
08:14:41 <shapr> @google slava factor
08:14:43 <lambdabot> http://factor-language.blogspot.com/
08:14:43 <lambdabot> Title: Factor: a stack language
08:14:44 <bakert> metaperl, yeah but i like it when my name gets mentioned cos xchat puts it in red.
08:14:52 <bakert> i feel involved in the community!
08:14:57 <shapr> bakert: cool!
08:14:59 <scriptdevil> ] syntaxfree because my middleclick pasted that text by mistake
08:15:05 <bakert> shapr, yeah!
08:15:07 <slava> earthy: telling someone they're wrong is not attacking
08:15:16 <earthy> the way you're doing it though is. ;)
08:15:19 <vincenz> Enough
08:15:21 <syntaxfree> well, looky. the last thing I'm gonna say about it is, look at the subtitle ("Haskell programming journal") and the About page (which ammounts to "I know nothing about programming! These are just random thoughts!)
08:15:30 <benja_> scriptdevil: interesting, where are you based? :-)
08:15:37 <scriptdevil> benja_: why?
08:15:40 <slava> syntaxfree: i realize that, i was saying /if/ you want to be informed, do more research
08:15:43 <syntaxfree> People are free to take it as they wish to take it.
08:16:06 <slava> java programmers are far, far worse when it comes to !java languages, and i'm used to that
08:16:11 <benja_> scriptdevil: the time stamp in your accidental paste :)
08:16:18 <scriptdevil> benja_: india.. madras
08:16:20 <bakert> syntaxfree, that's the only attitude you can take really.  If you publish anything on the internet that anyone reads then you will get attacked.  it's the nature of the beast.  fair play to you.
08:16:30 <bakert> for being so sensible.
08:16:33 <earthy> syntaxfree seems informed to me... more informed about Factor than I am, at least. ;)
08:16:43 <pbx> syntaxfree: Did some Python experiments inspired by your post: http://dpaste.com/4485/
08:16:54 <slava> he came into the irc channel and said a bunch of silly stuff about his HP 12 C
08:17:03 <slava> and how confusing it was as a kid having an rpn calculator, basically
08:17:16 <delamon> bakert: do you parse html in your 'web scrapping program' ?
08:17:22 <syntaxfree> not really. I had my first HP 12 C when I was a professional economist already.
08:17:29 <pbx> I employed the principles of "functioniness" in my code.
08:17:30 <syntaxfree> And, man, am I fast with it. I challenge you!
08:17:32 <benja_> oh, ok -- I didn't know there was a +04:00 time zone in india. more geography learned =)
08:17:37 <benja_> oh no, +05:00
08:17:39 <earthy> anyway, the bdsm article, to me, didn't seem like a smash on Factor rather than an explanation of the 'bdsm hoops' of monads
08:17:41 <bakert> delamon, not really.  i just use regexes.  it doesn't actually get very much from the web.  just a few numbers.
08:17:52 <earthy> and why they are needed
08:17:57 <scriptdevil> http://paste.lisp.org/display/34510#1 this one.. please.. someone
08:18:00 <benja_> I got the time zone my irc client is running in wrong =)
08:18:10 <earthy> he maybe mistakenly took Factor to be a good example of a stack language, akin to Forth
08:18:12 <bakert> @localtime benja_
08:18:24 <slava> earthy: neither factor or forth have the problems he describes
08:18:28 <delamon> bakert: you are happy man. parsing real world html is scary thing
08:18:35 <slava> ask any forth programmer
08:18:43 * vincenz silently suggests to take the argument to a more relevant place, and I'm not targetting anyone in specific, but all involved parties of the argument.  It is not related to haskell.
08:19:00 <delamon> bakert: well, may i look at your web scapper?
08:19:00 * earthy agrees with vincenz. :)
08:19:03 <bakert> delamon, that's what i figured.  i've used python's version of mechanize before and although it is quite useful it just dies on properly broken html.  and of course there's a lot of that out there.
08:19:09 * syntaxfree is not discussing Factor anymore. He's willing to undertake HP12C speed challenges though : )
08:19:12 <bakert> delamon, uh .. sure
08:19:14 <bakert> hang on
08:19:42 <bakert> got to edit out the "company confidential" side of things ...
08:20:02 * pjd thinks the stack languages and the currying languages will converge one day
08:20:10 <scriptdevil> http://paste.lisp.org/display/34510#1 this one.. please.. someone... am really confused.. cant understand the damned error messages
08:20:15 <pjd> the only difference will be which end you start reading from
08:20:29 <slava> point-free style is somewhat similar
08:20:43 <delamon> bakert: there is html parser implemented in scheme that parses real world html.
08:20:55 <pbx> bakert: FWIW there's also BeautifulSoup for Python, which handles awful HTML fairly well.
08:21:02 <vincenz> scriptdevil: easy
08:21:15 <vincenz> scriptdevil: bind the return from getRandomValues
08:21:18 <vincenz> scriptdevil: and then apply : to that
08:21:43 <vincenz> scriptdevil: getRandomValues returns a list in a monad, you have to bind that value before you can use the list
08:21:54 <vincenz> scriptdevil: same for 27
08:22:06 <scriptdevil> u mean like rest <- getRandomValues crap1 crap2 then do num <-crap?
08:22:12 <scriptdevil> num :crap
08:23:02 <lisppaste2> vincenz annotated #34510 with "fix" at http://paste.lisp.org/display/34510#2
08:23:13 <vincenz> there you go
08:23:20 <syntaxfree> scriptdevil: do-notation is not imperative code!
08:23:54 <syntaxfree> scriptdevil: http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
08:23:54 <syntaxfree> ; )
08:23:56 <lambdabot> Title: Do-notation considered harmful Â« Data.Syntaxfree, http://tinyurl.com/tlmrl
08:24:05 <slava> do notation exists because you don't have macros ;)
08:24:21 <psnl> ooh, thats fighting talk
08:24:38 <chessguy> do notation is only harmful to newbies who don't know what the de-sugared form looks like
08:24:39 <scriptdevil> thanks... anyway what is $?? in return $ num : tail?
08:24:51 <Igloo> Application
08:24:59 <Igloo> It's equal to return (num : tail)
08:25:10 <vincenz> scriptdevil: what Igloo said
08:25:19 <slava> does $ exist solely to avoid parentheses?
08:25:28 <vincenz> slava: no
08:25:30 <earthy> nope.
08:25:32 <Igloo> Also you can pass ($) to functions like zipWith
08:25:35 <vincenz> > map ($2) [+1, *3]
08:25:35 <lambdabot>  Parse error
08:25:41 <vincenz> > map ($ 2) [+ 1, * 3]
08:25:42 <lambdabot>  Parse error
08:25:47 <vincenz> > map ($ 2) [(+ 1), (* 3)]
08:25:49 <lambdabot>  [3,6]
08:25:50 <vincenz> there we go
08:25:54 <syntaxfree> hmm. flip($) could prove useful.
08:25:56 <scriptdevil> thanks...
08:25:57 <chessguy> wow, that's cool
08:25:57 <slava> ah
08:26:05 <lisppaste2> bakert pasted "Some snippets from my scraper thingummydooda (for delamon (and anyone else who is interested))" at http://paste.lisp.org/display/34513
08:26:11 <syntaxfree> @unpl flip ($)
08:26:11 <lambdabot> (\ b c -> c b)
08:26:27 <Saizan> @pl flip ($)
08:26:27 <lambdabot> flip id
08:26:28 <chessguy> > map (ap 2) [ (+ 1), (* 3)]
08:26:29 <delamon> bakert: thanks!
08:26:29 <lambdabot>   add an instance declaration for (Num (a -> a -> b))
08:27:05 <bakert> delamon, sorry i couldn't post the whole working thing but it's for work.  hope it is interesting/useful
08:27:15 <earthy> slava: or, in Factor, as I understand it:   { [ 1 + ] [ 3 * ] } [ 2 swap call ] each
08:27:26 <slava> s/each/map
08:27:29 <bakert> that really is most of it.
08:27:33 <earthy> (this is just from reading the tutorial)
08:28:03 <bakert> delamon, if you do look at it and spot anything daft/non-haskelly do let me know
08:28:33 <delamon> bakert: why do you omit error handling?
08:28:42 <earthy> > zipWith ($) [(+ 1),(* 3)] [2,3]
08:28:43 <lambdabot>  [3,9]
08:28:46 <bakert> delamon, because i haven't worked out how to do it yet!
08:28:52 <bakert> delamon, it's coming!
08:29:17 <delamon> bakert: so am i.
08:29:26 <earthy> slava: was that right thouh?
08:29:30 <slava> yes.
08:29:33 <earthy> but for the map?
08:29:39 <syntaxfree> earthy: did you see sgifpe's code that handled "spreadsheets"?
08:29:39 <earthy> ah. then I understood. :)
08:29:45 <syntaxfree> (i.e. lists of functions depending on each other)
08:29:47 <metaperl> > map ($ 2) [(+ 1), (* 3)]
08:29:48 <lambdabot>  [3,6]
08:29:49 <slava> sigfpe is great
08:29:51 <earthy> syntaxfree: that was *scary*
08:30:00 <metaperl> > map (\f -> f 2) [ (+ 1), (* 3) ]
08:30:02 <lambdabot>  [3,6]
08:30:09 <metaperl> much clearer methinks
08:30:12 <slava> i like his writings on algebraic topology
08:30:12 <vincenz> ($ x) is a slice on function application :)
08:30:29 <shapr> slava: Yeah, I like his writings. His monad tutorial is especially nifty.
08:30:47 <slava> monad tutorials are not really interesting to me anymore :)
08:30:52 <chessguy> which monad tutorial is that?
08:31:13 <shapr> chessguy: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
08:31:16 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
08:31:20 <chessguy> ah  yes
08:31:34 <slava> i like the 'you could have invented spectral sequences' paper he references
08:31:52 <syntaxfree> monad tutorials are the "Hello world" of our community.
08:32:10 <slava> i thought the hello world was factorial ;)
08:32:26 <chessguy> ?remember syntaxfree monad tutorials are the "Hello world" of our community.
08:32:27 <lambdabot> Done memoising quote for `syntaxfree', if that is their real name...
08:32:42 <chessguy> hmm, lambdabot  has been fiddled with
08:32:53 <bakert> He's getting cheekier.
08:33:00 <bakert> (She?  It?)
08:33:01 <chessguy> She
08:33:08 <chessguy> ?quote syntaxfree
08:33:09 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
08:33:16 <chessguy> ?quote syntaxfree
08:33:16 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
08:33:25 <chessguy> ?quote syntaxfree
08:33:26 <lambdabot> syntaxfree says: "You can't catch me / I'm syntax free / I'm preconceived / preternaturally"
08:33:37 <shapr> @quote chessguy
08:33:38 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
08:33:39 <vincenz> @quote denotational
08:33:40 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
08:33:47 <slava> heh
08:33:58 <syntaxfree> @quote lambdabot
08:33:58 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
08:34:06 <shapr> @quote slava
08:34:06 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
08:34:06 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
08:34:25 <slava> what the hell
08:34:25 <vincenz> @quote shapr
08:34:26 <lambdabot> shapr says: Hey man, want to toke on a lambda? The first redex is free man!
08:34:44 <syntaxfree> @quote quote
08:34:44 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
08:34:53 <chessguy> ha
08:34:54 <shapr> I like that one.
08:35:00 <dcoutts_> :-)
08:35:08 <chessguy> @quote sarahbot
08:35:08 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
08:35:11 <vincenz> someone trying to infiniloop
08:35:19 <shapr> Yeah, but it diverges quickly.
08:35:26 <slava> bet haskell's type system can't catch that one.
08:35:51 <vincenz> slava: sure, all you need is Oleg
08:36:22 <metaperl> slava - the Factor documentation system is impressive. Not only because the webserver is in Factor, but it is easy to use as well...
08:36:33 <slava> i had a funny discussion with an enterprise guy a few years back, where he said haskell and such are only used for silly trivial little applications such as theorem provers. i pointed out that a theorem prover is far more complex than his typical web app
08:37:05 <slava> metaperl: yeah, we ported that from unlambda
08:37:14 <edwinb> how about a web based theorem prover? ;)
08:37:24 * syntaxfree sings to the popular Iron Maiden tune. "Run .. live to type .. type to live.. Oleg high aaaaa"
08:37:27 <quetzal> sadly, theorem provers can hardly make business running :)
08:37:33 <pbx> slava: I think he meant, your theorem prover has no ROI :)
08:37:35 <slava> quetzal: depends on the business
08:37:53 <quetzal> slava, sure. you can find one that needs prover. or two :)
08:38:03 <metaperl> unlambda? why the very thought is sacreligious
08:38:05 <slava> they call them 'business rules engines'
08:38:28 <vincenz> quetzal: but can you prove in a theorem prover that theorem provers have no ROI?
08:39:07 * syntaxfree points vincenz out to Paul Samuelson's "Foundations of economic analysis", where he discusses the meaning of 'theorem' in economics.
08:39:11 <Saizan> are we bringing up the ROI-problem?
08:39:11 <quetzal> vincenz :)
08:39:50 <olliej> wow
08:39:52 <syntaxfree> Economic "theorems" evidenty are mathematical theorems, but they have a wider interpretation than just "given this idealized model we get the following result".
08:40:11 <psnl> edwinb: a web based theorm proves is just a theorm prover mated with a bad php script.
08:40:32 <slava> php? why not happs?
08:40:33 <edwinb> I think it's a bit harder than that...
08:40:39 <vincenz> @join #haskell.be
08:40:52 <psnl> edwinb: oh?
08:40:52 <edwinb> I wouldn't fancy working out how to pass around the proof state efficiently
08:41:07 <syntaxfree> vincenz: can anyone ask lambdabot to join anywhere in freenode?
08:41:13 <vincenz> syntaxfree: no
08:41:21 <syntaxfree> oh. Just admins.
08:41:31 <psnl> I assumed you meant a automatic prover.... my bad
08:41:31 <syntaxfree> Anyway, I'm halfway through compiling my own lambdabot now.
08:41:39 <slava> takes a while? :)
08:41:52 <slava> perhaps all those linked lists and lazy thunks are not kind to the CPU :)
08:43:01 <shapr> SyntaxNinja: hiya!
08:43:09 * psnl assembles a completely useless observation from edwinb's comment
08:43:18 <SyntaxNinja> y0
08:43:23 <SyntaxNinja> shapr: how's hack?
08:43:32 <vincenz> For all .be people, there is now a haskell.be
08:43:33 <shapr> Hack is good, how's code on your end?
08:43:52 <pjd> why does flip id work?
08:43:57 <syntaxfree> vincenz: so, I thought of starting #haskell.br
08:44:00 <shapr> vincenz: Are you going to start a blog at http://haskell.be/good ?
08:44:07 <syntaxfree> there are four or five .br people already.
08:44:16 <vincenz> syntaxfree: :D
08:44:17 <vincenz> erm
08:44:19 <vincenz> shapr: :D
08:44:23 * shapr grins
08:44:54 <edwinb> psnl: do we get to observe your useless observation too?
08:44:55 <syntaxfree> http://haskell-is.br/illiant.
08:45:01 <SyntaxNinja> shapr: pretty good, but I just got up :)
08:45:17 <vincenz> shapr: it should be http://haskell.be/lazy
08:47:22 <psnl> edwinb: I'm trying to work out how to say it. it would be something along the lines of for any two programs; if merging them doesn't give you a more complex program, then one of the programs is a functionality-subset of the other.
08:47:23 <bakert> Ugh.  Give me some IO monad help guys and put a loser newbie out of his misery.  Say I have a list of IO Bools in main.  How can I get a list of Bools from it?
08:47:40 <bringert> bakert: <-
08:47:52 <earthy> didn't .br have .com.br and .edu.br and .gov.br and such?
08:47:57 <bringert> well, that and sequence
08:48:03 <bringert> @type sequence
08:48:04 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:48:04 <bakert> If I use the magic unwrapping operator ("<-") I get a problem because it is a list of IO Bools not an IO [Bool] if you know what i mean
08:48:31 <bakert> the IO is inside the list.  or at least that's how it seems to my weak and feeble brain.
08:48:32 <earthy> sequence is the magic word.
08:48:37 <bakert> cool i will check that out.
08:48:47 <psnl> ?type sequence
08:48:48 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:49:04 <bakert> ah yes tres bon!
08:49:12 <bakert> thanks bringert earthy and psnl !
08:49:28 <bringert> bakert: I recommend looking through Control.Monad. there's lots of other good stuff like sequence
08:49:32 <bakert> how have i lived without this little devil?!
08:49:39 <vincenz> Voor alle nederlandstalige mensen is er nu een haskell kanaal puur in het AN: #haskell.be
08:49:56 <psnl> step n on the road to being a haskell guru: you think that type sigs can answer questions.
08:49:58 <scriptdevil> one small help.. how do i use concat and intesperse to print [1,2,3,4,5] as "1,2,3,4,5" ?? is it putStrLn concat $ intersperse , (map show [1,2,3,4,5])
08:49:59 <kowey> syntaxfree: maybe a #haskell.pt would also be useful (#haskell.nl ??)
08:49:59 <lambdabot> kowey: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:50:12 * earthy thinks vincenz means ABN
08:50:35 <vincenz> earthy: no
08:50:42 <vincenz> earthy: it got changed to AN a few years ago
08:50:50 <vincenz> ABN is old
08:51:50 <psnl> scriptdevil: I'll just use mapM and putStr
08:52:10 * psnl fwaps himself
08:52:15 <vincenz> eww
08:52:17 <vincenz> TMI
08:53:22 <psnl> putStrLn $ foldl (\a,b->(show a)++",""++(show b)) [1,2,3,4,5]
08:54:08 <vincenz> MAke that haskell.dut for all dutch/flemish people :)
08:54:26 <Botje> psnl: you mean foldl1, right?
08:54:27 <scriptdevil> putStrLn $ concat $ List.intersperse "," (map show [1,2,3,4,5])
08:54:29 <scriptdevil> :D
08:54:31 <scriptdevil> i got it
08:54:37 <vincenz> Botje: move your ass
08:54:46 <Botje> pff :p
08:55:11 <vincenz> Botje: you're not charged by channel you're in
08:55:24 <vincenz> :P
08:55:39 <Botje> nothing on freenode #haskell.be or ##haskell.be
08:55:47 <vincenz> I said haskell.dut :)
08:55:51 <vincenz> Making it country independent :)
08:57:36 <Botje> bleh
08:57:48 <vincenz> Itkovian: nieuw nederlandstalige haskell kanaal: haskell.dut
08:58:29 <bringert> hmm, I guess #haskell.se should really be #haskell.sv, if it's a language rather than a country thing (assuming ISO 639 language codes).
08:58:59 <kowey> three letter lang codes are probably less confusing
08:59:01 <vincenz> bringert: we chose to keep it country neutral due to .be and .nl
08:59:14 <kowey> otherwise you get people wondering why #haskell.uk isn't in english
08:59:39 <bringert> kowey: true. http://en.wikipedia.org/wiki/Dutch_language says that dut or nld is the code for dutch
08:59:41 <lambdabot> Title: Dutch language - Wikipedia, the free encyclopedia
09:00:22 <kowey> although, with inertia, i'm not sure i can convince #haskell.fr to become #haskell.fre
09:00:29 <pjd> ah!
09:00:31 <vincenz> kowey: cool :)
09:00:36 <vincenz> kowey: we can make it a haskell community std
09:00:50 <vincenz> kowey: and you might get people from wallonie
09:01:01 <Itkovian> vincenz: thx
09:01:05 <earthy> fre or fra, your choice, kowey. :)
09:01:07 <pjd> am i correct in understanding that given flip :: (a -> (b -> c)) -> (b -> (a -> c))
09:01:26 <pjd> if it's called with a id :: a -> a
09:01:38 <kowey> well, fra would like be better... although i don't like this idea of being able to choose
09:01:47 <earthy> @type flip id
09:01:49 <lambdabot> forall b c. b -> (b -> c) -> c
09:02:01 <earthy> kowey: dutch also has dut and nld
09:02:25 <vincenz> I guess it's in the language of origin and in english
09:02:31 <pjd> then id "matches" against flip's first parameter so that flip's a "becomes" (b ->c)
09:02:38 <vincenz> FREnch, FRAncais, DUTch, NederLanDs
09:02:44 <scriptdevil> india is .in :D we r in :P
09:02:47 --- mode: ChanServ set +o vincenz
09:03:00 <shapr> power!
09:03:25 <vincenz> tho
09:03:27 --- mode: vincenz set -o vincenz
09:03:29 <vincenz> wrong channel
09:03:32 <vincenz> doh even
09:04:04 <pjd> giving you a full signature of flip :: ((b -> c) -> (b -> c)) -> b -> (b -> c) -> c)
09:04:12 <bringert> kowey: use ISO 639-3 if you don't want choices
09:04:21 <pjd> (right before id is applied)
09:05:05 <kowey> heh... i like a man who knows his ISO standards
09:05:36 <pjd> so it's a different reduction to the same result as flip ($)
09:05:40 * vincenz sings . o O ( Love is in the air )
09:05:48 <shapr> vincenz: Mile High Club?
09:05:57 <vincenz> Lol :)
09:06:05 <pbx> kowey: Where were you when I was trying to sell ISO 8601 CERTIFIED t-shirts?
09:07:07 <SamB> that wouldn't happen to be a standard for idiots, would it?
09:07:21 <kowey> pbx: :-) sometimes my fingers will get confused, and i'll be extolling the virtues of iso-8859 (oops!)
09:07:32 <kowey> euh, ISO 8859
09:07:54 <matthew_-> pjd: I believe that's right.
09:08:28 <matthew_-> pjd. Certainly my implementation of hindly milner does the same unification of (a -> b -> c) and (d -> d)
09:08:34 <matthew_-> *Lambda> unify' ((F (V 1) (F (V 2) (V 3))), (F (V 4) (V 4)))
09:08:34 <matthew_-> (((2 -> 3) -> (2 -> 3)),((2 -> 3) -> (2 -> 3)))
09:09:14 <pjd> matthew-_: ack, just when i think i'm getting the hang of things, you have to go and do that
09:09:37 <matthew_-> pjd: well, unification of types is the basis of type inference
09:09:47 <matthew_-> I wasn't trying to confuse.
09:09:56 <ToRA> > ($3) show
09:09:58 <lambdabot>  "3"
09:10:09 <SamB> so what is iso 639?
09:10:10 <norpan> three dollars
09:10:11 <pjd> matthew-_: don't worry, i like being confused :)
09:10:25 <norpan> SamB: language codes
09:10:29 <vincenz> > ($ 3.75) show
09:10:30 <lambdabot>  "3.75"
09:11:17 <SamB> oh, like en_US?
09:11:28 <pjd> is there any context where flip ($) and flip id won't be identical?
09:11:47 <vincenz> @type flip ($)
09:11:48 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
09:11:49 <vincenz> @type flip id
09:11:50 <lambdabot> forall b c. b -> (b -> c) -> c
09:11:52 <vincenz> nope
09:12:03 <matthew_-> quick check?
09:12:14 <ToRA> hold on
09:12:22 <syntaxfree> 2:44 PM  kowey: syntaxfree: maybe a #haskell.pt would also be useful (#haskell.nl ??)
09:12:28 <ToRA> the argument order is different for flip ($) and flip id
09:12:40 <SamB> ToRA: heh
09:12:46 <vincenz> ToRA: no it's not
09:12:46 <pjd> ToRA: ?
09:12:50 <ToRA> yeah sorry
09:12:52 <ToRA> just noticed that
09:12:59 <ToRA> the quantifier messed me up
09:13:14 <pjd> interesting
09:14:29 <Saizan> flip id = (\f x y -> f y x) id = \x y -> id y x = \x y -> y x = ($)
09:14:51 <Saizan> @src ($)
09:14:51 <lambdabot> f $ x = f x
09:15:07 <Saizan> err flip ($) of course
09:15:16 <pjd> Saizan: ah, right
09:16:58 <Saizan> i was quite struck on it too and lambda calculus made things clear ^^
09:18:37 <ClaudiusMaximus> "<<loop>>    |    Program exited with code 01.    |     (gdb) bt    |     No stack"     how do i make <<loop>> segfault so i can find out roughly where it happens?
09:18:55 <SyntaxNinja> is there a mailing list or anything for the upcoming hackathon?
09:19:14 <Igloo> There's a channel (#haskell.hac07)
09:22:29 <ndm> SyntaxNinja: will you be there?
09:22:33 <ndm> @seen dcoutts
09:22:33 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 4m 40s ago.
09:22:40 <dcoutts> @yarr!
09:22:40 <lambdabot> Drink up, me 'earties
09:22:44 <dcoutts> hia ndm
09:22:54 <ndm> dcoutts, if i want Gtk2Hs and GHC 6.6 is the best solution to cry and winge?
09:23:01 <seliopou> :t flip id
09:23:02 <dcoutts> ndm, on windows?
09:23:03 <lambdabot> forall b c. b -> (b -> c) -> c
09:23:09 <ndm> dcoutts of course :)
09:23:24 <seliopou> :t flip ($)
09:23:26 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
09:23:35 <dcoutts> ndm, I can give you a .zip, but you'll have to edit the package files & register it yourself
09:23:42 <dcoutts> ndm, ie no installer
09:23:45 <SyntaxNinja> ndm: nah, a bit far for a hackathon, though I might join on irc.
09:23:57 <dcoutts> SyntaxNinja, great
09:23:58 <ndm> dcoutts if there are good enough instructions i'm happy to give it a whirl
09:24:07 <ndm> and the installer can come with Hac :)
09:24:24 <ndm> SPJ says just set off with what we have for the HsInstaller project
09:24:39 <dcoutts> ndm, instructions are just, edit the various package.conf files to add the install directory and then use ghc-pkg on them in the right order
09:24:58 <ndm> dcoutts "edit" is a vague term :)
09:25:12 <dcoutts> with a text editor, supstituting for ${blah}
09:25:23 <ndm> hit me with the link and i'll have a go
09:25:27 <dcoutts> @arr
09:25:27 <lambdabot> Arrr!
09:25:42 <SyntaxNinja> I'm still hoping to write up my ideas about what needs to get done for cabal-install.
09:25:58 <dcoutts> SyntaxNinja, send it in by Wednesday when the hackathon starts!
09:26:23 <pjd> i'm trying to figure out what the concatenative analogue is of flip id = flip ($)
09:27:25 <SyntaxNinja> dcoutts: will do.
09:28:02 <pbx> Is there a more up-to-date Haskell/Cocoa binding project than HOC (http://hoc.sourceforge.net/)?
09:28:55 <ndm> dcoutts link?
09:29:14 <dcoutts> ndm, I'm just checking which builds worked
09:29:35 <ndm> 6.6 windows xp sp2, gtk as you tell me to install it
09:30:03 <dcoutts> ndm, I fired off all combinations of ghc-6.2.2, 6.4.2, 6.6 and gtk+ 2.6, 2.8 & 2.10 on win32 and I'm checking which worked
09:30:33 <ndm> cool, i want to bring a working copy of GuiHaskell to the Hac to try and entice Simon Marlow
09:35:06 <pbx> I'll take that as a no then?
09:36:00 <shapr> @arr !
09:36:01 <lambdabot> I'll keel haul ya fer that!
09:36:03 <shapr> @first !
09:36:04 <lambdabot> No module "!" loaded
09:36:06 <shapr> hmm
09:41:40 <ClaudiusMaximus> ?paste
09:41:41 <lambdabot> http://paste.lisp.org/new/haskell
09:43:19 <tuukkah> ClaudiusMaximus, have you tried "ghc -optl -shared" because it works as well as cutting the options from "ghc -v" to gcc?
09:43:32 <tuukkah> might be a ghc6.6 thing that it works right
09:47:13 <ClaudiusMaximus> tuukkah: wow, appears to work in ghc-6.4.2 too :)
09:47:16 <ClaudiusMaximus> tuukkah++
09:47:40 <SamB> huh?
09:47:44 <SamB> -shared?
09:48:05 <tuukkah> makes a shared library of the resulting linked binary
09:48:17 <SamB> oh. what is that good for?
09:48:34 <Saizan> foreign export is suspect
09:48:49 <Saizan> s/is/i/
09:48:55 <tuukkah> i can create plugins to c programs that are totally unexpecting of haskell =)
09:49:47 <SamB> ah ;-)
09:51:20 <norpan> and also plugins to java programs for instance
09:51:28 <norpan> since java can load dynamic libraries
09:51:57 <norpan> (but you cannot link statically from a java program)
09:52:15 <tuukkah> good point
09:52:27 <SamB> java can load dynamic libraries now?
09:52:33 <SamB> without any JNI?
09:53:03 <tuukkah> SamB, that's how jni works
09:53:35 <SamB> oh, well, wouldn't that mean having to write boring JNI bindings?
09:54:15 <tuukkah> yes, but now you can write your boring jni bindings in haskell using ffi!
09:54:23 <SamB> ... you can?
09:54:32 <SamB> Haskell doesn't even support structs!
09:54:46 <tuukkah> the preprocessors do
09:55:54 <dcoutts> SamB, what's a struct? :-)
09:56:42 <ndm> dcoutts, any updates on Gtk things?
09:57:02 <dcoutts> ndm, still fixing builds, though at least some worked :-)
09:57:15 <dcoutts> ndm, in particular ghc-6.6 with gtk+ 2.10 is ok
09:57:20 <ndm> dcoutts - any 6.6 ones?
09:59:43 <Igloo> dcoutts: Is a stable release imminent?
09:59:50 <dcoutts> Igloo, yes
10:00:09 <Igloo> Cool
10:00:21 <dcoutts> next rc should be a day or two
10:00:45 <tuukkah> i think it would work like this: you declare some methods in your java class as "native" and load a library in the class initialization. you extract the jni interface as a .h file. you implement the methods in haskell using that .h file and foreign exports, plus a short c file that just calls hs_init
10:00:53 * Igloo wonders what the Debian RMs stance on it would be, if it is released in time
10:01:20 <dcoutts> Igloo, oh you mean etch?
10:01:27 <Igloo> Yup
10:01:38 <tuukkah> Igloo, let's petition
10:01:55 <dcoutts> Igloo, what's the timescale for etch?
10:03:09 <Igloo> dcoutts: Did you see http://people.debian.org/~igloo/popcon-graphs/index.php?packages=libghc6-gtk-dev%2Clibghc6-mtl-dev&show_installed=on&want_legend=on&beenhere=1 BTW? You can really see the effect ghc 6.6 (represented by mtl) had
10:03:25 <Igloo> etch will be released on Dec 4th 2006
10:03:42 <dcoutts> Igloo, hah :-)
10:04:11 <tuukkah> a lot of stuff didn't make it into etch because of ghc6.6 :-/
10:04:19 <dcoutts> Igloo, I hadn't seen that, so previously most people were building from source I presume
10:04:20 <Igloo> there are about 130 bugs marked RC, but it hasn't really been going down recently. I don't know about the number really considered RC for the distribution as a whole
10:04:41 <Igloo> tuukkah: Only 2 or 3 packages AFAIAA
10:04:53 <Igloo> dcoutts: Huh?
10:05:01 <tuukkah> ok so the important stuff ie gtk2hs ;-)
10:05:10 <dcoutts> Igloo, oh, nm
10:05:17 <chr1s> hey all!
10:05:19 <tuukkah> hs-plugins too
10:05:38 <Igloo> Of course, what the graph doesn't tell you is how many people compiled darcs gtk2hs themselves
10:05:54 <chr1s> I'm writing a pretty-printer for a lot of code, which is becoming fairly slow.
10:05:59 <dcoutts> Igloo, right
10:06:13 <chr1s> I got the advice to don't do a lot of string concatenations
10:06:16 <ndm> chr1s: using a pretty printer combinator thing?
10:06:25 <Igloo> Yeah, dons thought he would have hs-plugins fixed in a weekend aaages ago; don't know what happened there
10:06:26 <chr1s> ndm: no
10:06:27 <ndm> @hoogle Pretty
10:06:28 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
10:06:28 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
10:06:36 <ndm> @hoogle HughesPJ
10:06:37 <lambdabot> Text.PrettyPrint.HughesPJ :: module
10:06:43 <chr1s> I got the advice to don't do a lot of string concatenations
10:06:51 * SamB looks on happily
10:06:58 <chr1s> so is there a simple alternative to string concatenations?
10:07:00 <ndm> chr1s: use the one above ^ - string concat is fine, as long as its left to right, the other direction is O(n^2)
10:07:13 <shapr> chr1s: What about ShowS?
10:07:21 <ndm> chr1s: use concat if you can, rather than ++
10:07:24 <chr1s> I've not yet looked into that
10:07:25 <SamB> shapr: that is for uglyprinters
10:07:56 <chr1s> oh, but it's a bit of an ugly printer
10:08:08 <ndm> chr1s: i would really recommend a proper pretty printer library though - usually much simpler
10:08:16 <chr1s> ok, thanks
10:08:25 <chr1s> I'll look into that and ShowS
10:17:45 <lisppaste2> ClaudiusMaximus pasted "<<loop>>" at http://paste.lisp.org/display/34519
10:18:04 <SyntaxNinja> by the way, we're hiring yet again.
10:18:17 <SyntaxNinja> haskell hackers rejoice ;)
10:18:23 <ndm> SyntaxNinja: ever english people?
10:18:44 <SyntaxNinja> ndm: our ceo is english ;)
10:18:55 <SyntaxNinja> permission to work in the US is the tricky part.
10:19:00 <ndm> SyntaxNinja: but will you hire new english people?
10:19:48 <shapr> lambda otaku!
10:19:55 <SamB> ndm: I didn't know you were from new england!
10:19:59 <SyntaxNinja> ndm: yeah, nationality isn't an issue, but visas are (due to the timeline for hiring and how long they take)
10:20:15 <ndm> SyntaxNinja: :( - not that i want a job at the moment, but i likely will one day...
10:20:36 <SyntaxNinja> ndm: just let us know plenty beforehand so we can start the visa process, that's all.
10:20:43 <ndm> SyntaxNinja: will do :)
10:21:14 <glguy> I'm going to have to process a CSV file into an XML file today, are there any CSV libraries in Haskell I should be using?
10:21:14 <shapr> There are at least three companies actively trying to hire Haskellers right now.
10:21:33 <SyntaxNinja> we really would like someone with leadership capabilities too, as we have important projects that need leads.
10:21:34 <ndm> shapr: mainly to have them work other languages than Haskell?
10:21:40 <ndm> i like being bossy :)
10:21:44 <sjanssen> glguy: might be something in missingh
10:22:16 <chr1s> I've got a big list of strings, and I want to repeatedly check if a a string is an element of that list
10:22:20 <bringert> Igloo, dcoutts, dons, ndm, lemmih and everyone else going to hac: care to swap mobile phone number?
10:22:41 <ndm> bringert: 07876 126 574
10:22:47 <chr1s> It's ofcourse possible in O(log(n)), but is there a default haskell implementation for that?
10:22:56 <bringert> ndm: that's +44 I take it?
10:23:05 <ndm> bringert: ideally we should email out to everyone every address
10:23:07 * SamB isn't sure "being bossy" qualifies as "leadership"
10:23:14 <sjanssen> ClaudiusMaximus: are you familiar with what "<<loop>>" means?
10:23:16 <ndm> bringert: yep indeed, and if you +44 take off the first 0
10:23:46 <glguy> Setup.exe: cannot satisfy dependency FilePath-any
10:23:57 <glguy> Is that a ghc 6.4 thing, or a library I don't have
10:24:03 <chr1s> ah, Data.member
10:24:34 <shapr> SamB: Hey, are you talking about ME?
10:24:37 * shapr is teasing
10:24:38 <ClaudiusMaximus> > let x = x in x
10:24:44 <SamB> shapr: no!
10:24:46 * shapr bosses SamB around
10:24:50 <SamB> I was talking about ndm...
10:25:01 <ndm> glguy: the filepath library
10:25:04 <ndm> @where filepath
10:25:04 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
10:25:12 <shapr> ndm: FilePath rocks, thanks for writing and packaging it!
10:25:16 <ndm> glguy: should be in GHC 6.8 :)
10:25:20 * shapr hugs ndm
10:25:21 <Igloo> bringert: I don't have one
10:25:29 <ndm> shapr: i hope to put it in base properly within the month
10:25:33 * ndm hugs shapr back
10:25:43 <shapr> Yay!
10:26:18 <olliej> ndm: does yhc maintain any arity information?
10:26:21 <ClaudiusMaximus> sjanssen: i imagine it's a particular kind of undefined, that can be detected
10:26:21 <glguy> ?where hslogger
10:26:22 <lambdabot> I know nothing about hslogger.
10:26:37 <sjanssen> ClaudiusMaximus: exactly, you get it whenever the result of something depends on itself.  The code you pasted looks okay as far as I can tell
10:26:41 <ndm> olliej: no idea, my guess is it maintains original arity information, but not after transformation
10:26:47 <olliej> ndm: ah :-/
10:26:48 <Igloo> shapr: Which three are you thinking of?
10:26:48 <ndm> olliej: but you can easily extract it
10:26:49 <bringert> I guess that most of all I need the numbers for dons and Binkley, since I'll meet them at heathrow
10:26:54 <olliej> ndm: yeah
10:27:21 <glguy> Are there any plans for a Haskell library repository
10:27:30 <ndm> bringert: collect all numbers and send it off to everyone (or me at least!)
10:27:34 <glguy> where you can make sure you up are up to date in one command?
10:27:37 <ndm> glguy: hackage is the thing, and yes, its being done
10:27:42 <ndm> glguy: one day, one day...
10:27:44 <olliej> ndm: yhc erases type info when targeting .net doesn't it?
10:27:56 <Igloo> Where is Binkley comign from?
10:28:00 <olliej> ndm: i vaguely recall that being the case
10:28:04 <olliej> biut am not sure
10:28:16 <ndm> olliej: it screws up type info when it does the lambda-lifting and the dictionary transformation, so type information is gone long before than
10:28:19 <bringert> ndm: ok, I'll try to remember. I could easily wake up on wednesday and realize I should have gone to the airport
10:28:40 <ndm> lol :)
10:28:51 * ndm leaves to teach
10:28:58 <shapr> Igloo: Galois, Credit Suisse, and HAppS are all actively hiring.
10:29:25 <bringert> Igloo: UA958
10:29:40 <bringert> Igloo: Seattle it seems
10:29:48 <Igloo> Oh, wow
10:30:06 <Igloo> I assumed that her coming meant she was still in Cambridge
10:30:07 <shapr> glguy: cabal-get
10:30:13 <Igloo> Oh, maybe she's going to POPL/PADL/...
10:30:16 <shapr> Igloo: I think the Cambridge deal ended at Xmas
10:30:36 <glguy> shapr: is that what I should be using now instead of manually downloading and installing?
10:31:32 <shapr> glguy: I'm not sure if it works yet, but it's the way of the future.
10:32:25 <ClaudiusMaximus> sjanssen: thanks for taking a look
10:33:28 <sjanssen> ClaudiusMaximus: any time.  I suggest you go through your code very carefully, and look for things of the form "let x = ... x ..." :)
10:34:18 <sjanssen> I usually have these troubles when I write "let n' = n' + 1", when I really mean "let n' = n + 1"
10:37:20 <ClaudiusMaximus> sjanssen: $ grep \ let\  *.hs   => only 2 lines in 2 unrelated files...   can this pitfall occur with do notation?
10:38:30 <ClaudiusMaximus> sjanssen: i guess it can occur outside lets, nevermind...
10:40:24 <tphyahoo> Is there any "downside" to this simple fibonacci func?
10:40:26 <tphyahoo> fibs 1 = 1
10:40:27 <tphyahoo> fibs 2 = 1
10:40:27 <tphyahoo> fibs n = ( fibs (n-2) )  + (fibs (n-1))
10:40:44 <norpan> tphyahoo: yes there is
10:40:54 <tphyahoo> I knew it. what?
10:40:55 <norpan> try fibs 10000
10:41:40 <tphyahoo> doh.
10:42:09 <norpan> basically you are calculating fibs (n-2) two times, so you get exponential behaviour
10:42:15 <liyang> you can use memoisation...
10:42:26 <profmakx> or infinite datatypes ^^
10:42:41 <norpan> or a running accumulator
10:43:08 <liyang> with memoisation you can keep the original look of the algorithm
10:43:16 <ClaudiusMaximus> or some kind of integer near a power of a certain irrational number
10:43:29 <tuukkah> ClaudiusMaximus, have you tried ghc -Wall, it can point you at some quationable locations in the code
10:43:58 <tphyahoo> what does ^^ mean? thought bubble?
10:44:20 <tuukkah> ^_^
10:44:22 <earthy> nope, japanese-style smiley
10:44:46 <tphyahoo> all right, back to my cave.
10:47:18 <liyang> Orz
10:48:20 <ClaudiusMaximus> tuukkah: unfortunately it just spits out "blahblah defined but not used", for each foreign export blahblah.  thanks for the tip....
10:48:22 <shapr> hiya liyang!
10:49:23 <ClaudiusMaximus> tuukkah: :)
10:51:38 <liyang> hi shapr :)
10:52:35 <sjanssen> ClaudiusMaximus: yes, the problem can happen in any binding, wheres, lets, top levels
10:53:54 <tuukkah> if it's detectable in run time isn't it detectable in compile time (unlike stack overflow)?
10:54:31 <shapr> lambdabot: You dirty slank!
10:56:02 <sjanssen> tuukah: GHC doesn't generally warn about nontermination at compile time
10:57:27 <emu> > 4^^8
10:57:28 <lambdabot>  65536.0
11:00:42 <Philippa> tuukkah: in general, non-termination can't be detected in advance
11:01:07 <tuukkah> it can't be detected at the spot either
11:02:06 <glguy> is there a writeDocument in HXT that just returns the resulting file instead of writing it to disk?
11:02:47 <Philippa> some forms can be but still can't be detected at compile-time
11:02:55 <tuukkah> i think i see it now. even if <<loop>> can be detected during computation, it may take arbitrarily long to reach a detectable point
11:03:09 <Philippa> that, and it may never actually get forced
11:03:23 <Philippa> the compiler could only report it if it knows it will
11:03:38 <tuukkah> it could report it as a warning :-)
11:04:58 <Philippa> that could be problematic given that half the point of a lazy language is to let people play with infinities!
11:06:05 <tuukkah> but loop is a different kind of infinite, isn't it? a closed one :-)
11:07:30 <tuukkah> i'm guessing proper corecursion and recursion don't produce loops in any situation, only stack overflows
11:08:24 <chr1s> I'm trying to profile my program, but it seems as if MissingH isn't compiled with profiling support.
11:08:39 <chr1s> Anyone who knows something about this?
11:11:11 <shapr> dgoldsmith: How's Haskell treating you?
11:11:17 <monochrom> I just received a spam with subject "This is not to say vi is better than Emacs" etc.
11:11:33 <shapr> monochrom: I think spam is ripping off blog posts lately.
11:11:39 <dgoldsmith> shapr: Still learning slowly in my not-so-copious spare time.
11:11:43 <monochrom> Interesting!
11:12:02 <tuukkah> now i got a good question: why am i using c2hs and not for example hsc2hs?
11:12:15 <shapr> dgoldsmith: Got any questions?
11:13:03 <dgoldsmith> shapr: Not at the moment. I would like to talk to someone at some point about getting the glitches in the Darwin Intel/PPC 6.6 releases worked out.
11:13:49 <shapr> dgoldsmith: I'd suggest asking on #ghc and possibly on the ghc-users mailing list.
11:14:14 <dcoutts> tuukkah, you're using c2hs 'cos it is better, it does more, saves you more time and headaches
11:14:17 <dgoldsmith> shapr: I'm not having any trouble with the tutorials or books. It's just taking time for my brain to adjust to a very different way of thinking about programming.
11:14:26 <glguy> ?hoogle sequenceA
11:14:27 <lambdabot> No matches found
11:14:34 <Igloo> dgoldsmith: What sort of glitches?
11:14:37 <dgoldsmith> shapr: Thanks, I will raise the issues again. I have mentioned them in the past but gotten no response.
11:15:04 <glguy> is there a sort of:  foldl (>>>) (arr id) xs ?
11:15:10 <dgoldsmith> Igloo: the Intel build has a problem with HOpenGL. It doesn't work as distributed because some of the C header files are missing from the distribution.
11:15:20 <CosmicRay> hrm, there appears to be no putEnv on Windows?
11:15:21 <shapr> dgoldsmith: Ok, if you have some questions about Haskell itself, feel free to ask me.
11:15:31 <CosmicRay> System.Environment seems to define only getting, not setting, environment variables
11:15:34 <dgoldsmith> Igloo: And both the PPC and Intel builds have troubles loading shared libraries from ghci, but not from ghc.
11:15:44 <dgoldsmith> shapr: OK, thank you! :-)
11:15:48 <shapr> :-)
11:16:14 <tuukkah> dcoutts, now that's a good answer you've got :-) btw i hit the __attribute__ problem, are you collecting reports on that?
11:16:23 <dgoldsmith> Igloo: The problems make some graphics programs fail from ghci, but not ghc.
11:16:41 <dcoutts> tuukkah, did you find the workaround?
11:16:52 <tuukkah> yes
11:16:55 <dcoutts> ok good
11:17:21 <dcoutts> tuukkah, what header file were you using btw?
11:17:37 <tuukkah> first i hacked something ugly myself, now i'm using c2hs --cppopts '-D"__attribute__(A)= "'
11:17:39 <dgoldsmith> Igloo: There's also the whole readline issue. I have no problem with installing GNU readline, but the current distributions replace the system readline, which is an issue if you are developing non-Haskell software that has to run on stock Mac OS X.
11:18:04 <dgoldsmith> Igloo: I have managed to build it with the GNU readline in /usr/local, but haven't got all the issues worked out yet.
11:18:11 <tuukkah> dcoutts, raptor.h, it uses __attribute__((deprecated)) in the beginning of function declarations
11:18:32 <dcoutts> tuukkah, what's raptor.h from?
11:18:41 <tuukkah> the redland rdf library
11:19:28 <tuukkah> or one of them rather, "Raptor RDF Parser Toolkit"
11:21:22 <dgoldsmith> Igloo: That's all I can think of at the moment. :-)
11:25:32 <notsmack> can one call haskell from .net?
11:25:44 <notsmack> is that just the FFI?
11:26:29 <SamB> well, maybe you would like hugs.NET?
11:28:07 <notsmack> i doubt i would.  :-)
11:28:09 <tuukkah> quick googling turns up this: http://www.ercim.org/publication/Ercim_News/enw63/lucas.html
11:28:10 <notsmack> looking though
11:28:11 <lambdabot> Title: Crossing the Rubicon: from Haskell to .NET through COM
11:32:05 <notsmack> tuukkah: looks useful if all else fails
11:32:24 <notsmack> SamB: google isn't coming up with much, have a link for hugs.NET?
11:32:54 <tuukkah> "The GHC compiler for .NET is currently under development at Microsoft Research, Cambridge, and will come with a similar range of functionality."
11:33:43 <mbishop> my "arguments against oop" link already got a downmod
11:33:49 <mbishop> I've angered the masses D:
11:34:00 <SamB> @google hugs98.net
11:34:04 <lambdabot> Title: Hugs98 for .NET
11:34:09 <SamB> ah, no wonder
11:34:15 <SamB> there is a 98 in the name
11:37:33 <notsmack> SamB: thanks
11:40:39 <shapr> hiya simon
11:41:03 <slava> mbishop: i don't think those arguments are particularly convincing. OOP is just another abstraction in the bag of tools any modern language should offer
11:41:28 <sm> hey there shapr
11:42:22 <shapr> How's code treating you?
11:42:46 <sm> pretty good thx
11:43:00 <sm> I used haskell to better understand a ruby app I'm working on
11:43:16 <shapr> Sounds neat, what sort of app?
11:43:24 <sm> first time I wrote haskell and it seemed sort of natural.. http://paste.lisp.org/display/34358#5
11:43:30 <sm> inventory tracking
11:46:12 <sm> unfortunately this simple structure is being flattened into a mind-bending single rdbms table
11:47:10 <shapr> sm: yow
11:47:31 <shapr> Well, I'm glad you're enjoying Haskell.
11:47:42 <sm> thx.. and you ?
11:47:55 <shapr> I'm getting paid to write Haskell, I'm definitely enjoying that  =)
11:48:21 <sm> very cool.. what application ?
11:48:26 <shapr> HAppS
11:48:47 <slava> can you reload changed code into a running happs instance and have it take effect immediately?
11:49:17 <sm> lovely
11:49:31 <sm> hey, I saw slava's snow show last night
11:49:33 <notsmack> slava: look at hs-plugins
11:49:36 <sm> can it be the same...
11:49:40 <shapr> slava: Nope, not yet. Once ghc6.6 has hs-plugins, it'll likely work.
11:50:01 <slava> shapr: even changes to happs itself?
11:50:02 <notsmack> oh, didn't see happs
11:50:48 <shapr> slava: It depends on the level of the loader. For example, Yi can reload everything except the loader.
11:51:31 <shapr> Yi is 'just' a dynamic loader and everything else is loaded on top of that.
11:52:01 <slava> shapr: ah, good
12:04:30 <Eelis> do i understand correctly that i can only use operator + for my types if i can also come up with implementations for a bunch of other operators (like *) ?
12:04:46 <fridim> "haskell for C programmers", that was exactly what I was looking for :]
12:04:58 <fridim> nice tut
12:05:45 <sjanssen> Eelis: yes, (+) is part of the Num class which has several other operations
12:05:59 <bd_> Eelis: Well, you can cheat
12:06:24 <sjanssen> yes, you can not implement those other operations
12:06:42 <sjanssen> but then calling (*) on your types results in a runtime error
12:07:00 <Eelis> i tried that and got compiler warnings, so i assumed i shouldn't do that
12:07:17 <bd_> It'll work as long as you don't use the unimplemented operations
12:07:17 <bd_> but
12:07:55 <bd_> by implementing the Num class you're promising that you'll implement all the requires operations with proper semantics - if you don't, well, sometime down the road, you might use a function which internally calls * or something
12:08:08 <sjanssen> Eelis: correct.  You /can/ do it, but you really /shouldn't/
12:08:10 <bd_> you can make a new operator if tyou want to avoid these problems
12:08:17 <bd_> eg, <+> or something
12:08:21 <Eelis> ok, that makes sense. thanks
12:08:37 <bd_> or just backquote: x `someFunction` y
12:09:09 <Eelis> though it's kind of annoying that i can't use something like x*y for vector*scalar multiplication since the types are not what Num wants them to be
12:10:19 <Eelis> i'm used to C++ where operators can be overloaded at will, so these more restricted type classes will take some getting used to
12:10:27 <bd_> Eelis: To make a * which allows that would require multiparamater typeclasses and functional dependencies, I believe - neither of which are in the core haskell 98 spec (but many compilers, eg GHC, allow it)
12:10:49 <bd_> class Mul a b c | a b -> c where (<*>) :: a -> b -> c
12:10:50 <bd_> I think
12:10:58 <george> anyone have a good URL that explains how to use getArgs?
12:11:34 <Eelis> bd_: interesting
12:12:14 <bd_> this might require undecidable instances: instanceNum a =>  Mul a a a  where (<*>) = (*)
12:12:23 <sjanssen> the current design of Num is a case of flexibility vs. simplicity
12:12:41 <bd_> Eelis: if you really, really want to override (*) or something
12:12:47 <bd_> you can hide the default implementation
12:12:53 <bd_> import qualified Prelude
12:12:58 <bd_> import Prelude hiding ((*))
12:12:59 <liyang> george: main = do args <- getArgs; mapM_ print args
12:13:12 <bd_> If you need real *, use Prelude.*
12:13:25 <shapr> Hey, can a cabal file require ghc6.6?
12:13:48 <Eelis> hehe, i think i'm way too new to Haskell to start making it do my bidding by sheer force ;)
12:14:10 <yax1> george: just import System(getArgs)
12:14:23 <yax1> george: then you can do args <- getArgs
12:14:33 <george> i have not used ghc before
12:15:02 <yax1> oops didn't see that liyang had already answered
12:15:04 <liyang> These days you may have to say -- import System.Environment ( getArgs )
12:15:07 <liyang> :)
12:15:24 <liyang> (Is it in System?)
12:15:45 <liyang> @index getArgs
12:15:46 <lambdabot> System.Environment
12:16:17 <tuukkah> george, are you still getting to know haskell and wondering how to use IO or what to do with the list that getArgs gets you?
12:16:25 <bd_> Prelude System> :t getArgs
12:16:25 <bd_> getArgs :: IO [String]
12:16:30 <george> yeah im getting to know haskell
12:16:37 <george> or atleast, im quite used to it in hugs now
12:16:56 <george> and i want to use GHC because my imput is too large for hugs
12:17:03 <yax1> liyang: all i know is that importing it from System works for me
12:18:21 <tuukkah> george, standard functions such as getArgs should work the same way in hugs and ghc
12:18:38 <george> ok
12:18:39 <liyang> yax1: compatibility packages for H98 I think. Too used to the hierarchical module namespace. :)
12:19:48 <tuukkah> liyang, can you turn off the compatibility to avoid using it by accident?
12:22:01 <lisppaste2> ClaudiusMaximus annotated #34519 with "unsafePerformIO is, well, unsafe :(" at http://paste.lisp.org/display/34519#1
12:22:03 <SamB> is it only for H98 compatability?
12:22:15 <SamB> I thought it moonlighted as a heirarchical module?
12:25:11 <george> ok so i see that you can use args <- getArgs and how this works, what would you typically do now? some case statement on args? check if certain strings come up?
12:26:54 <glguy> george: System.Console.GetOpts if you are doing anything complicated
12:27:42 <glguy> otherwise you can just treat it as a list of arguments: "your_program one two three\ four" --> ["one","two","three four"]
12:28:41 <tuukkah> SamB, "worked at a secondary job, esp. at night, and often illegitimately"?
12:28:49 <george> yeah i see it works like this glguy, but i wonder if there is just like a neat chunk of code you use over and over to analyse this list of strings
12:28:55 <george> i think mine will look messy is what im saying ;)
12:29:05 <glguy> george: System.Console.GetOpts
12:29:36 * benc__ likes getopts
12:30:12 <glguy> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
12:30:14 <lambdabot> http://tinyurl.com/y3585u
12:35:13 <sjanssen> ClaudiusMaximus: perhaps you can avoid unsafePerformIO altogether?
12:38:07 <dmhouse> Evening everyone.
12:38:29 <monochrom> Just saw your mailing list message on `(+)` :)
12:39:03 <bd_> ClaudiusMaximus: Perhaps an IORef would be safer? You can then add a MVar in from main
12:39:19 <emu> > 1 `(+)` 1
12:39:30 <emu> @botsnack
12:39:30 <lambdabot> :)
12:39:32 <emu> > 1 `(+)` 1
12:39:32 <lambdabot>  Parse error
12:39:42 <bd_> ClaudiusMaximus: also, do you really need that many locks? your outer mvar ought to be enough...
12:39:48 <monochrom> Eh!  Need snack to get bot to work?!
12:39:59 <emu> yep, lambdabot is getting spoiled
12:40:06 <monochrom> Evil!
12:40:10 <ClaudiusMaximus> bd_: the fun part is, it's a singlethreaded app
12:40:16 <monochrom> Whoever coded that up is Evil!
12:40:19 <sjanssen> > (`div`) 2 1 -- I find this behavior more surprising
12:40:20 <lambdabot>  Parse error
12:40:36 <emu> complicated grammars bite back
12:40:44 <dmhouse> sjanssen: why should that work?
12:41:06 <dmhouse> sjanssen: you can use operators either prefix, (OP) or infix, OP. You can use functions either prefix, func, or infix, `func`.
12:41:13 <tuukkah> ghc -hide-package haskell98 does the trick: "Failed to load interface for `System': it is a member of package haskell98, which is hidden"
12:41:35 <sjanssen> dmhouse: I'm surprised that infixified functions can't be in sections
12:41:51 <sjanssen> I see no good reason this should be the case
12:41:55 <dmhouse> sjanssen: yes, they can.
12:42:05 <dmhouse> > map (`elem` [1..5]) [0..10]
12:42:06 <lambdabot>  [False,True,True,True,True,True,False,False,False,False,False]
12:42:12 <emu> idle question: why does --make have two dashes but most other options only have 1? like -prof.
12:42:45 <sjanssen> dmhouse: ah, so applied to zero arguments is not a section?
12:42:47 <kzm_> random historical reasons, I think.
12:43:11 <dmhouse> sjanssen: I didn't think so.
12:44:15 <sjanssen> this begins to make more sense then
12:44:36 <Botje> :t (`div`)
12:44:38 <lambdabot> parse error on input `)'
12:47:22 <dmhouse> Last modified  	2006-12-05 05:10:59 UTC
12:47:33 <dmhouse> Does that mean the 12th May or the 5th December?
12:47:53 <Botje> 5th of december
12:48:15 <Botje> the units decrease from left to right
12:48:27 <seliopou> as they should
12:48:38 <dmhouse> Botje: that's what I'd expect, but the American standard is different.
12:49:04 <seliopou> :t empty
12:49:05 <Botje> yes
12:49:05 <lambdabot> Not in scope: `empty'
12:49:15 <Botje> but dates in that format are standardised :)
12:49:15 <seliopou> :t Data.Set.empty
12:49:17 <lambdabot> forall a. Data.Set.Set a
12:49:42 <dmhouse> Botje: okay, good.
12:49:50 <tuukkah> americans never write the year first i hope
12:49:54 <sjanssen> dmhouse: in American dates, the year is typically last
12:50:02 <dmhouse> Ah, okay.
12:50:10 <dmhouse> sjanssen: it's still a silly way of doing it. :)
12:50:15 <tuukkah> and i also hope they don't use dashes but slashes
12:50:33 <sjanssen> tuukah: what is wrong with dashes?
12:50:55 <tuukkah> sjanssen, they're reserved to the iso standard :-)
12:51:01 <sjanssen> dmhouse: as an American, I agree 100%
12:51:07 <dmhouse> Tbh, I never use a numerical month.
12:51:32 <dmhouse> If I read a numerical month I have to stop and think about which month that represents for a while.
12:51:45 <tuukkah> so "8. tammikuuta 2007" is a good way ?-)
12:51:52 <dmhouse> I'd use something like '8 Jan 07'.
12:52:10 <dmhouse> Still quite concise, completely unambiguous, and instantly readable.
12:53:06 <Excedrin> I use ISO 8601
12:53:06 <sjanssen> > [7, 107 ..] -- unambiguous?
12:53:07 <lambdabot>  [7,107,207,307,407,507,607,707,807,907,1007,1107,1207,1307,1407,1507,1607,17...
12:53:26 <seliopou> :t join (,)
12:53:27 <lambdabot> forall a. a -> (a, a)
12:53:43 <ClaudiusMaximus> @botsnack
12:53:43 <lambdabot> :)
12:53:50 <seliopou> > join (,) 1
12:53:51 <lambdabot>  (1,1)
12:53:57 <dmhouse> sjanssen: [1, 2, 3, 4, 5, 6 ..] -- unambiguous?
12:53:57 <conal> anyone here use cygwin?  i had to reinstall and now i'm having trouble with dos-style vs unix-style end-of-line conventions.
12:54:14 <seliopou> :
12:54:16 <seliopou> :t join
12:54:18 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:54:45 <dmhouse> You could construct a 6th degree polynomial which passes through those points but isn't y = x.
12:55:02 <paolino> :t (,)
12:55:04 <lambdabot> forall b a. a -> b -> (a, b)
12:55:23 <Botje> :t join (,)
12:55:24 <lambdabot> forall a. a -> (a, a)
12:55:28 <sjanssen> dmhouse: my point is that you really should use the full "2007" rather than "07"
12:55:34 <seliopou> :t join (,) 1
12:55:36 <lambdabot> forall a. (Num a) => (a, a)
12:55:44 <seliopou> :t join (,) (1::Int)
12:55:45 <lambdabot> (Int, Int)
12:56:24 <tuukkah> so where do the monads disappear from the type?
12:56:32 <seliopou> I'm getting something different in ghci
12:56:47 <dmhouse> sjanssen: if I wanted to refer to a century other than the current one, I'd use the full year.
12:57:00 <Botje> seliopou: it's the ((->) a) monad
12:57:04 <sjanssen> seliopou: you need to import the module that has the instance Monad ((->) a)
12:57:15 <seliopou> right
12:57:35 <dmhouse> tuukkah: join's parameter has type m (m a). You gave it something of type (a -> b -> (a, b)). Therefore, you must be using the ((->) a) monad.
12:57:38 <seliopou> but that's just Control.Monad
12:57:47 <seliopou> which I had to import to get join
12:57:51 <sjanssen> Control.Monad.Instances or Control.Monad.Reader
12:57:57 <seliopou> I see
12:58:08 <seliopou> that's always something I've found confusing about haskell docs
12:58:16 <seliopou> you're never really quite sure where instances live
12:58:18 <norpan> re dates, i have food that have expiry dates like 05.06.07
12:58:24 <norpan> that confuses me
12:58:51 <norpan> i hope that the 07 is the year
12:59:18 <chessguy> @localtime norpan
12:59:20 <lambdabot> Local time for norpan is Mon Jan  8 21:54:08 2007
12:59:28 <sjanssen> norpan: feed it to your friends first, then wait a week before eating the rest
12:59:37 <chessguy> ah, no wonder you see dates weird, you're not from the US :)
13:00:07 <ClaudiusMaximus> @hoogle (a->b) -> IO (FunPtr (a -> b))
13:00:12 <lambdabot> No matches, try a more general search
13:00:17 <norpan> in sweden, it's standard to write 2007-01-08 for today
13:00:41 <chessguy> well, maybe it's standard for sweden, but it's still weird :)
13:01:05 <sjanssen> norpan: sounds reasonable on January 8th, but what about the rest of the year? :P
13:01:05 <Botje> and over here it's 08/01/2007
13:01:24 <tuukkah> sjanssen =-D
13:02:05 <norpan> how much do you guys use the 24 hour clock?
13:02:19 <tuukkah> norpan, i expect you used the normal european 8.1.2007 before?
13:02:41 <norpan> tuukkah: i don't remember not using the 8601 notation
13:03:00 <tuukkah> how old is the standard anyway
13:03:07 <sjanssen> I write my dates like so "The eighth of January in the two thousand and seventh year of our Lord"
13:03:45 <tuukkah> from 1988
13:03:49 <norpan> the original was iso 2014
13:04:12 <sjanssen> s/our Lord/the current era/ when I'd like to be religiously neutral
13:04:29 <norpan> from 1976
13:04:45 <dmhouse> sjanssen: be explicit, please. s/January/January, the first month,/
13:04:46 <Botje> sjanssen: think about the people in the NEXT era!
13:05:17 <norpan> the iso 2014 standard itself says: first edition 1976-04-01
13:05:17 <dmhouse> We should just all use seconds since the Unix epoch to give dates.
13:05:24 <sjanssen> Botje: I suppose I should write Common Era instead
13:05:24 <norpan> it was all an april's fool joke
13:05:49 <tuukkah> norpan, there's been plenty of time to adopt it then, but not much adoption :-(
13:06:17 <norpan> it's easier to adopt if you're already using it, as i suspect sweden was
13:06:34 <tuukkah> i doubt
13:06:41 <norpan> we have had birth numbers since way before that in that format
13:07:01 <tuukkah> odd
13:07:09 <norpan> they were introduced in 1947
13:07:27 <tuukkah> "Den formen anvÃ¤nds sedan 1970-talet i bland annat Sverige."
13:07:45 <tuukkah> but this is wikipedia so you never know :-)
13:08:27 <norpan> the swedish "personal numbers" (yes, everybody has a number, control state) were introduced in 1947 in the format yymmdd
13:08:49 <benc__> that only accomodates one person being born per day?
13:09:06 <norpan> no, you have three additional digits and a control sum digit
13:09:10 <tuukkah> that just means the numbering scheme was designed by a person with a clue
13:09:30 <norpan> tuukkah: yeah, and it also made people understand such numbers
13:09:54 <tuukkah> clever indeed
13:10:07 <obelus> newb question: do i understand correctly that 'purely functional' means (and only means) that given a certain set of inputs, a program will always give the same outputs?
13:10:18 <earthy> almost
13:10:27 <SamB> obelus: s/program/function/
13:10:34 <earthy> if you replace program for function, you would be write
13:10:44 <earthy> s/write/right/
13:10:52 <obelus> oh, so the term "pure" is for functions?
13:11:00 <earthy> obelus: exactly
13:11:02 <ClaudiusMaximus> sjanssen: i think i can avoid unsafePerformIO by writing a load of   foreign import ccall "wrapper" bleh :: s -> (s->a->b) -> IO (FunPtr (a->b)) ; bleh bort oof = oof bort
13:11:09 <earthy> programs can use IO, e.g.
13:11:17 <emu> programs are still pure
13:11:30 <Cale> http://programming.reddit.com/info/xd1n/comments/cxfyc
13:11:31 <lambdabot> Title: OOP is dead (part 3) (reddit.com)
13:11:40 <emu> just that the moment in time they are called is part of the parameters ;)
13:11:47 <SamB> emu: worse
13:11:56 <SamB> far worse!
13:11:57 <Hunter> if I whant to make an 4 index list with all possible combinations(1-9), do I need to make 4 list comprehensions then?
13:12:07 <tuukkah> "purely functional" is also used for the style so you're not allowed to use non-pure functionality in the implementation either
13:12:15 <raxas> purity, either functional or not, is just a state of mind
13:12:51 <obelus> i see a lot of references on wikipedia to purely functional languages ... are they incorrect?
13:13:15 <SamB> obelus: what do you mean?
13:13:25 <obelus> http://en.wikipedia.org/wiki/Purely_functional
13:13:29 <obelus> first sentence
13:13:55 <Cale> > replicateM 4 [1..9]
13:13:56 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,1,6],[1,1,1,7],[1,1,...
13:14:08 <Cale> Hunter: is that the sort of thing you mean?
13:14:10 <Cale> > replicateM 2 [1..9]
13:14:11 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[2,1],[2,2],[2,3],[2,...
13:14:36 <george> ok, i've been reading and re-reading the system.console.getopts information and the example and i just cant make sense of how to use it
13:14:54 <sjanssen> obelus: I agree with that article
13:14:59 <Hunter> Cale yea
13:15:11 <Cale> replicateM is defined in Control.Monad
13:15:14 <george> my method so far has been to paste the example code and throw arguments at the compilerOpts function as that seems to be the important one
13:15:19 <george> but i just get nothing returned
13:15:20 <emu> whether his prof will accept that implementation is another matter ;)
13:15:36 <george> can someone help my understanding of how this function works so i can try and implement it later
13:15:45 <Cale> Hunter: It's a good exercise to try writing the list version of it yourself :)
13:16:05 <obelus> well, doesn't it contradict what was just said?
13:16:11 <Cale> You can do it recursively, using a list comprehension drawing items from a single list.
13:16:21 <sjanssen> > filterM (const [True, False]) [1..3]
13:16:22 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:16:33 <Hunter> Cale: what list version?
13:16:51 <Cale> that is, a function which does the same thing as replicateM, but only works for lists
13:17:04 <Hunter> Cala aha, cool
13:17:25 <Cale> (replicateM is very general, it works in any monad)
13:17:51 <Hunter> Ok, but havent came to monads yet =(
13:17:58 <Cale> george: hmm, okay
13:18:33 <tuukkah> sjanssen, can i find a collection of these pieces of wisdom somewhere?
13:18:34 <Cale> Hunter: basically, the list monad is the same as list comprehensions
13:19:00 <Cale> george: Well, it basically comes down to calling getOpt
13:19:13 <Cale> george: so everything else you do is just to set up parameters for that
13:19:20 <sjanssen> tuukah: I don't think that little filterM trick is written down anywhere
13:19:39 <george> cale, for now i want to set it up to take two arguments
13:19:43 <george> input and output file
13:19:54 <Cale> oh, you don't need this level of specialisation then
13:20:00 <Cale> this is for complicated parameter parsing
13:20:32 <Cale> In System.Environment
13:20:39 <Cale> there's a function called getArgs
13:20:46 <Cale> *cough* IO action
13:20:54 <george> yes
13:20:55 <Cale> which gives you a list of strings
13:21:00 <george> im starting simplre
13:21:02 <george> simple*
13:21:03 <Cale> So you could just write
13:21:11 <george> i intend to get it more complex after i understand the basics
13:21:17 <sjanssen> @where paste
13:21:17 <lambdabot> http://paste.lisp.org/new/haskell
13:21:19 <Hunter> Cale "replicaeM 4 [1..9] : Undefined variable "replicateM"
13:21:19 <Cale> ah, okay
13:21:26 <Cale> Hunter: import Control.Monad
13:21:34 <Hunter> Cale thx
13:22:18 <lisppaste2> sjanssen pasted "very simple getArgs example" at http://paste.lisp.org/display/34537
13:22:30 <Cale> If you want to use getOpt, most of the interesting part of what getOpt does is parsing options like -l and --verbose
13:23:22 <Cale> If you want to use switches to describe the input and output file...
13:23:29 <Cale> I suppose I can make up an example
13:23:39 <george> that would be really useful
13:25:36 <seliopou> george: the documentation for that module contains an example that does just what you want
13:25:54 <seliopou> @docs System.Console
13:25:54 <lambdabot> System.Console not available
13:26:04 <seliopou> ?index System.Console
13:26:05 <lambdabot> bzzt
13:26:08 <seliopou> ?
13:26:14 <Cale> @docs System.Console.GetOpt
13:26:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
13:26:15 <george> i have been reading docs on system.console.getopts
13:26:27 <seliopou> right
13:26:28 <george> i cannot see how to implement this
13:27:24 <bringert> @seen dons
13:27:25 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7h 26m 23s ago.
13:28:05 <mbishop> dons is in europe right now I believe
13:28:10 <mbishop> or on his way anyway heh
13:28:18 <matthew-_> am I being blind or are the 6.6.1 snapshots in a non-obvious place?
13:28:31 <matthew-_> ahh, ignore me
13:30:58 <miez> :)
13:31:47 <dons> not quite
13:31:58 <dons> I leave in um 6 hours or so
13:35:05 <mbishop> ah
13:35:11 <dons> ?users
13:35:13 <lambdabot> Maximum users seen in #haskell: 299, currently: 295 (98.7%), active: 51 (17.3%)
13:35:17 <dons> ?uptime
13:35:17 <lambdabot> uptime: 13h 26m 56s, longest uptime: 1d 21h 16m 2s
13:35:28 <mbishop> the bot counts unique users, right?
13:35:45 <dons> nicks
13:35:53 <dons> same as /names should report (roughly..)
13:40:51 <mbishop> ah
13:41:30 <Cale> lisppaste2: url
13:41:31 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:42:46 <lisppaste2> Cale pasted "example for george" at http://paste.lisp.org/display/34540
13:42:53 <george> tyvm =)
13:43:42 <george> i just started a bit of cooking but ill spend some time with this after... it looks  just how i wanted though =)
13:43:42 <Cale> It's pretty similar to the other example
14:00:14 <george> is it possible to use this script in hugs or will it only work compiled?
14:02:42 <lisppaste2> Hunter pasted "Master Mind Game" at http://paste.lisp.org/display/34541
14:04:31 <Cale> george: well, I'm not quite sure how to set program commandline options in hugs
14:04:42 <Cale> But if you can work out how to do that, it might work
14:06:10 <Cale> Hunter: filter :)
14:06:16 <Cale> Hunter: is this homework?
14:06:26 <Cale> or just for fun?
14:07:14 <Botje> Hunter: you might want to find some existing master mind solving algorithms first
14:07:42 <Hunter> Cale no, having a exam in a week so I just study some old exams
14:07:52 <Hunter> Botje: ok
14:08:41 <Hunter> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/tenta2001-01.pdf
14:08:43 <lambdabot> http://tinyurl.com/y94ray
14:10:02 <Saizan> i used the heuristic one in my past exam, very good player but with an exponential running time based on the length of the combination
14:10:44 <george> cale, i assume reqArg means required argument... why doesn't it cause an error when a required argument isn't given to it
14:11:08 <Cale> It means that if -i is provided, an argument to it is required
14:11:28 <Cale> That is, that -i on its own doesn't mean anything
14:11:40 <Cale> (and should cause an error)
14:11:47 <george> ahh ok
14:13:02 <george> say instead of just printing the args... if i wanted to access what the inputFile value... could i do something like: inputFile(opts)
14:13:35 <tuukkah> george, ghc includes an interactive user interface called ghci, and the script runghc to run a haskell source file
14:19:52 <Hunter> cale how do i filter all wring answers
14:27:15 <newsham> ?pl (\x -> sum x `div` length x)
14:27:16 <lambdabot> liftM2 div sum length
14:28:18 <newsham> ?pl (\x -> sum x / length x)
14:28:19 <lambdabot> liftM2 (/) sum length
14:28:20 <conal> hey joseph
14:28:32 <conal> (oops -- wrong window)
14:28:38 <newsham> > liftM2 (/) sum length [1.1, 2.2, 3.3, 4.4]
14:28:39 <lambdabot>   add an instance declaration for (Fractional Int)
14:28:39 <lambdabot>     In the list element: 4.4
14:28:57 <newsham> > liftM2 (/) sum (fromIntegral.length) [1.1, 2.2, 3.3, 4.4]
14:28:59 <lambdabot>  2.75
14:30:34 <george> with code like that cale posted earlier ( http://paste.lisp.org/display/34540 ), how would I access an individual input? say if i wanted to know what the input file was as part of my program? or how would i set a default value for this?
14:35:30 <newsham> *Main> args <- parseArgs
14:35:31 <newsham> ([InputFile "foo",OutputFile "bar"],[])
14:35:38 <newsham> *Main> [x | (InputFile x) <- (fst args)]
14:35:38 <newsham> ["foo"]
14:35:43 <mbishop> http://www.cs.chalmers.se/~augustss/cayenne/
14:35:44 <mbishop> heh
14:35:45 <lambdabot> Title: Cayenne
14:36:08 <newsham> george: make sense?
14:37:23 <george> newsham, maybe... ill play with that a little
14:37:57 * mbishop just realised augustss is the guy responsible for most of the USB code in BSD
14:39:02 <xpika> how can i go about installing http://www.cs.uu.nl/~daan/ddata.html ?
14:39:05 <lambdabot> Title: DData
14:39:54 <newsham> if you "args <- parseArgs" you get back a tuple with a list of flags (fst) and a list of non-flags (snd)
14:40:05 <xpika> when i try to :l the .hs files it want's to other .hs in the directory as a module
14:40:16 <xpika> but cannot find them as such
14:40:20 <newsham> you can iterate the list and pick out only the "InputFile" types or only the OutputFile types
14:40:26 <newsham> *Main> fst args
14:40:27 <newsham> [InputFile "foo",OutputFile "bar"]
14:40:41 <newsham> thats what my list comprehension above did.
14:41:03 <george> ok
14:41:22 <george> you see cales code... where he prints opts
14:41:30 <george> im trying just to print InputFile
14:41:35 <newsham> if you wanted to set defaults, thats part of the specification of "options" I think
14:42:01 <george> so i removed mapM_ as im printing just one line... and tried print InputFile opts
14:42:07 <newsham> let input = head [x | (InputFile x) <- (fst args)]
14:42:20 <newsham> putStrLn ("Input: " ++ input)
14:43:38 <newsham> let input = head ([x | (InputFile x) <- (fst args)] ++ ["default"])
14:43:44 <newsham> could work too to specify a default
14:44:27 <lisppaste2> Hunter pasted "List rotations" at http://paste.lisp.org/display/34543
14:44:54 <george> newsham: ty =) that is a nice trick for getting a default too
14:46:23 <newsham> what I like to do is make a record like   data Opts = Opts { opt_input :: String, opt_output :: String }
14:46:35 <newsham> make a default   def_opts = Opts "foo" "bar"
14:46:45 <newsham> and then while parsing, for each parsed match, apply an update function
14:47:07 <newsham> ie:  (\x o -> o {opt_input = x})
14:47:29 <newsham> start with opt_input and fold all the updaters together to get your conf
14:47:46 <newsham> then its really easy to access all the options
14:48:42 <newsham> here's an example of what I mean:  http://www.thenewsh.com/~newsham/x/Options.hs
14:48:55 <george> would the Opts type just be a repeat of the Flag type?
14:49:05 <Hunter> anyone awake that want to rotate lists?
14:49:32 <newsham> no, it would be a record that had one field for each option you want (ie. input file, output file, non-flag args, etc..)
14:50:18 <Saizan> > let rot xs = tail $ zipWith (++) (tails xs) (inits xs) in rot [1..4] -- copyed from someone here yesterday
14:50:48 <Saizan> @botsnack
14:50:48 <lambdabot> :)
14:50:51 <Saizan> > let rot xs = tail $ zipWith (++) (tails xs) (inits xs) in rot [1..4] -- copyed from someone here yesterday
14:50:52 <lambdabot>  [[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
14:51:55 <Hunter> ok, but is it not possible to modify the one I made? http://paste.lisp.org/display/34543
14:52:05 <newsham> > (let rot xs n = { let (a,b) = splitAt n xs in b ++ a }) "foo bar" 3
14:52:06 <lambdabot>  Parse error
14:52:28 <newsham> > (let rot xs n = { let (a,b) = splitAt n xs in (b ++ a) }) "foo bar" 3
14:52:28 <lambdabot>  Parse error
14:52:48 <newsham> > let rot xs n = { let (a,b) = splitAt n xs in (b ++ a) } in"foo bar" 3
14:52:48 <lambdabot>  Parse error
14:52:52 <newsham> > let rot xs n = { let (a,b) = splitAt n xs in (b ++ a) } in "foo bar" 3
14:52:53 <lambdabot>  Parse error
14:52:57 <newsham> grr. i giv eup
14:53:05 <dons> not a function
14:53:17 <newsham> > let rot xs n = { let (a,b) = splitAt n xs in (b ++ a) } in rot "foo bar" 3
14:53:18 <lambdabot>  Parse error
14:53:18 <newsham> oops!
14:53:30 <dons> > let rot xs n = let (a,b) = splitAt n xs in (b ++ a) in rot "foo bar" 3
14:53:31 <lambdabot>  " barfoo"
14:53:42 <Hunter> dons what is not a funktion ?
14:53:56 <dons> (let rot xs n = { let (a,b) = splitAt n xs in b ++ a })
14:54:03 <dons> its almost one, but not quite ;)
14:54:25 <dons> > (\xs n -> let (a,b) = splitAt n xs in b ++ a) "foo bar" 3 -- however, is.
14:54:26 <lambdabot>  " barfoo"
14:54:41 <Hunter> ok, but is it not possible to modify the one I made? http://paste.lisp.org/display/34543
14:57:44 <DapperDan2> What are good examples of Haskell code in real world software. darcs? Is bzip2 written in Haskell?
14:58:07 <newsham> hunter:  n > 0 = hlp (n-1) (xs++x)
14:58:16 <newsham> n == 0 = x:xs
14:58:29 <dons> DapperDan2: yeah, for example. check the 'Example code' page on haskell.org
14:58:31 <newsham> one rotation of (x:xs) is  xs++x
14:58:52 <dons> DapperDan2: or check around the 'libraries and applications' page, there's all sorts, from OS kernels, to compilers, to games, .
14:58:55 <newsham> > let (x:xs) = "foo bar" in xs++[x]
14:58:56 <lambdabot>  "oo barf"
14:59:05 <newsham> err..  xs++[x]  (not xs++x)
14:59:40 <newsham> hlp 0 xs = xs     always, we rotate not at all, its identity
15:00:03 <newsham> hlp n (x:xs) = hlp (n-1) (xs++[x])     one rotation followed by n-1 more.
15:00:08 <newsham> make sense?
15:00:45 <DapperDan2> thanks dons.
15:00:47 <newsham> if you rotate the thing length times, you get back the same string though.. is that what you want to do?
15:00:49 <Hunter> aha, yea, ty
15:01:03 <newsham> or is my idea of rotate different than yours?
15:01:18 <Saizan> i thought he wanted all rotations
15:01:56 <Hunter> that wasnt all rotations?
15:02:06 <Saizan> no,
15:03:16 <newsham> > lenght "foo bar"
15:03:16 <lambdabot>   Not in scope: `lenght'
15:03:21 <newsham> > length "foo bar"
15:03:22 <lambdabot>  7
15:03:27 <newsham> > let rot xs n = let (a,b) = splitAt n xs in (b ++ a) in rot "foo bar" 7
15:03:29 <lambdabot>  "foo bar"
15:03:32 <newsham> > let rot xs n = let (a,b) = splitAt n xs in (b ++ a) in rot "foo bar" 6
15:03:33 <lambdabot>  "rfoo ba"
15:03:36 <newsham> > let rot xs n = let (a,b) = splitAt n xs in (b ++ a) in rot "foo bar" 4
15:03:37 <lambdabot>  "barfoo "
15:03:40 <newsham> see?
15:03:44 <george> data Flag = InputFile String | OutputFile String | runType RunType | sens Int deriving Show <----- this line is giving me error: Syntax error in data type declaration (unexpected `|')       any ideas?
15:04:08 <bd_> let r' (h:t) = (let l' = t ++ [h] in l':r' l'); r l = zipWith fst (r' l) l in r [1,2,3,4,5]
15:04:11 <bd_> > let r' (h:t) = (let l' = t ++ [h] in l':r' l'); r l = zipWith fst (r' l) l in r [1,2,3,4,5]
15:04:12 <lambdabot>  Couldn't match `(b1 -> c, b)' against `[a]'
15:04:24 <newsham> oh, you want the result to be a list of all rotations?
15:04:25 <chr1s> hey!
15:04:50 <Hunter> newsham yes
15:04:59 <lisppaste2> Saizan annotated #34543 with "..." at http://paste.lisp.org/display/34543#1
15:04:59 <bd_> > let r' (h:t) = (let l' = t ++ [h] in l':r' l'); r l = zipWith fst (r' l) l; in r [1,2,3,4,5]
15:05:00 <lambdabot>  Couldn't match `(b1 -> c, b)' against `[a]'
15:05:04 <bd_> bleh
15:05:09 <chr1s> I've got a list of lists, and I want to sort the elements of the outer list according to the inner list
15:05:11 <bd_> oh, I'm an idiot
15:05:16 <Hunter> and with my function?
15:05:23 <bd_> > let r' (h:t) = (let l' = t ++ [h] in l':r' l'); r l = zipWith const (r' l) l; in r [1,2,3,4,5]
15:05:25 <lambdabot>  [[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4],[1,2,3,4,5]]
15:05:29 <bd_> there we go :)
15:05:58 <chr1s> I'm now doing: sortBy (\a b compare (length a) (length b))
15:06:06 <chr1s> that should work, right
15:06:09 <olliej> > [[1..],[2..]..]
15:06:10 <lambdabot>   add an instance declaration for (Enum [a])
15:06:10 <lambdabot>     In an arithmetic sequence: [...
15:09:21 <george> anyone any idea on that error message im getting?
15:09:40 <george> nvm i see why =)
15:09:54 <lisppaste2> newsham annotated #34543 with "All Rotations" at http://paste.lisp.org/display/34543#2
15:11:11 <bd_> > map (\n -> [n..]) [1..] -- Unfortunately a general instance of Enum over infinite lists is somewhat difficult, olliej :)
15:12:15 <newsham> > let rot (x:xs) = xs++[x] in take 5 $ iterate rot "foo bar"
15:12:16 <lambdabot>  ["foo bar","oo barf","o barfo"," barfoo","barfoo "]
15:13:37 <Hunter> newsham getting cannot find "show" function
15:14:16 <sjanssen> I'd appreciate comments: http://programming.reddit.com/info/xh0m/comments/cxjm7
15:14:17 <lambdabot> Title: The Beauty of List Comprehension (reddit.com)
15:14:36 <newsham> show for what?
15:15:15 <dons> heya sjanssen
15:15:28 <sjanssen> greetings
15:15:53 <tieTYT> i bought this book: http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089
15:15:57 <lambdabot> http://tinyurl.com/y352ho
15:15:58 <tieTYT> is it a good one to learn from?
15:16:02 <Hunter> newham Cannot find "show" function for: Expression : rotations' [1,2,3,4]  Of type    : Integer -> [[Integer]]
15:16:10 <dons> sjanssen: too many backspaces in the displayed code?
15:16:19 <dons> build (\\c n  ...
15:16:20 <newsham> "rotations' [1,2,3,4]" is a function
15:16:24 <newsham> "rotations [1,2,3,4]" isnt
15:16:37 <newsham> (rotations' takes two args, rotations takes 1)
15:16:43 <dons> sjanssen: have you checked the types of each reduction step? do they check?
15:17:02 <newsham> hunter: are you familiar with the "iterate" function?
15:17:09 <sjanssen> dons: oh, that is annoying.  Is reddit's formatter incompatible with the official one?
15:17:14 <SamB> are you telling me that () is not a function?
15:17:26 <newsham> > iterate (+ 2) 5
15:17:27 <lambdabot>  [5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,...
15:18:06 <newsham> > iterate (\(x:xs) -> xs++[x]) [1,2,3,4]
15:18:07 <lambdabot>  [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,...
15:18:29 <Hunter> newsham no sorry
15:18:38 <dons> sjanssen: it seems to do ok, you just indent 4 spaces and it should display verbatim, modulo the < char, which wil be mangled (you use the unicode version instead)
15:19:14 <dons> evening sorear
15:19:38 <SamB> why is < mangled?
15:20:13 <dons> sjanssen: also you can link better using:   [Data.List](http://darcs.haskell.org/packages/base/GHC/List.lhs)
15:20:13 <sorear> wrt reddit: lack of HTML escaping?
15:20:14 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:20:21 <dons> SamB: stupid code
15:20:41 <sorear> @seen dylan
15:20:41 <lambdabot> dylan is in #haskell. I last heard dylan speak 9h 35m 21s ago.
15:20:43 <SamB> dons: and why haven't they fixed it yet?
15:20:54 <dons> I have *no* idea
15:21:00 <dons> maybe parsers aren't their thing
15:21:05 <SamB> is that on reddit yet?
15:21:38 <dons> hat?
15:21:44 <newsham> hunter: iterate f x   builds a list starting with x, then f(x) then f(f(x)), etc..
15:21:48 <dons> s/^/w/
15:22:05 <newsham> so if you run  "iterate rotateOnce list"  it will make a list of rotations of list.
15:22:14 <newsham> ... forever.
15:22:17 <SamB> "Ask reddit: why isn't < fixed yet?"
15:22:28 <SamB> or something like that
15:22:28 <sorear> @tell dylan huh?
15:22:29 <lambdabot> Consider it noted.
15:22:32 <george> my understanding if i have a data type data foo = foo {one :: String, two :: String, three :: String}; var = foo {one = "1", two = "2", three = "3"}; i can use: 'one var' and get the value under one in var... ie. "1". is this correct?
15:22:53 <newsham> george: yup
15:23:04 <newsham> "one" will be an accessor function (a "gettor")
15:23:30 <newsham> unfortunately there is no settor, you have to roll your own:  (\x v -> v {one=x})
15:24:03 <george> *** Type           : [Char]     *** Does not match : foo -> [Char]
15:24:35 <SamB> maybe you need parentheses?
15:25:29 <george> heh. i had brackets... replaced with parenthesis and it gives Syntax error in expression (unexpected `{', possibly due to bad layout)
15:25:51 <newsham> whats the code?
15:26:01 <newsham> error without code isnt that useful :(
15:26:24 <Hunter> newsham ok, nice one, ty
15:26:49 <george> its me playing around with what you gave earlier newsham... to set a default i was trying: 	  let input = head $ [x | (InputFile x) <- opts] ++ [input def_config]
15:27:19 <george> data Config = Config {input :: String, output :: String, run :: RunType, sentences :: Int}; def_config = Config {	input = "/home/george/haskell/story.txt",	output = [],	run = Textgen,	sentences = 4}
15:27:20 <newsham> george: did you see the Config.hs URL i pasted?
15:27:24 <george> yes
15:27:40 <george> but it is a little complicated for me to get completely to grips with right now =)
15:27:52 <newsham> i can explain it if you would like
15:29:34 <george> ok =)
15:29:52 <george> im trying to follow your basics at the moment
15:30:15 <george> but this is also my first time with getOpts which is why i was trying to use a slightly more simple way of updating the default
15:31:27 <newsham> so you see in Cale's example  "ReqArg OutputFile "File"" ?
15:31:37 <george> yes
15:31:43 <newsham> the "OutputFile" part is a function to apply to the argument
15:32:07 <newsham> and what getOpt does is return a list of the results of applying these various functions to arguments
15:32:22 <newsham> in his case he's returning a list of Flag's
15:32:41 <newsham> in my case instead I'm returning a list of functions   Config -> Config
15:33:18 <newsham> ie. when it gets a "b" option, it returns a function that takes a Config, and creates a new Config with the c_batch set.
15:33:31 <newsham> to the particular value from the optarg
15:33:51 <newsham> so after getOpt runs, the "updates" variable is a list of all these update functions
15:34:00 <DapperDan2> does it make sense to write a function which parses HTTP requests (or whatever) off a socket, lazily?
15:34:39 <DapperDan2> then have another function which evals them, lazily.
15:34:45 <newsham> err.. sorry.. when getOpt is run "fs" is a list of the functions
15:34:52 <newsham> then I define   updates = foldr (.) id fs
15:35:07 <george> i dont think i know id
15:35:08 <newsham> that basically puts all the functions together into a single update function that applies each of the fs in turn
15:35:11 <george> > :t id
15:35:12 <lambdabot>  Parse error
15:35:12 <newsham> > id 3
15:35:14 <lambdabot>  3
15:35:22 <newsham> the identity function
15:35:42 <newsham> so if fs = [updateBatch "foo", updateOuput "Bar"]
15:35:52 <dons> :t id
15:35:53 <lambdabot> forall a. a -> a
15:35:57 <dons> ?src id
15:35:58 <lambdabot> id x = x
15:36:03 <newsham> then updates = updateOutput "Bar" . updateBatch "foo" . id
15:36:18 <newsham> (err.. I probably got that backwards.. but the idea is there)
15:36:36 <newsham> so when you run  "updates defConfig"  you transform the default config into the desired config
15:36:45 <newsham> since updates is a fnction  Config -> Config
15:37:08 <newsham> make sense?
15:37:17 <george> why wouldnt it be a function updates Config -> Config -> Config
15:37:18 <george> i.e.
15:37:22 <george> it takes the new one
15:37:24 <george> the default
15:37:26 <george> merges
15:37:27 <george> ?
15:38:11 <newsham> *shrug* I didnt do it that way?  I thikn that would be harder.
15:38:25 <george> heh ok =)
15:38:44 <newsham> I already know what the default config is, so if I have a function Config -> Config, that overwrites any fields, just applying it to the default is sufficient
15:39:22 <george> updates is just 1 line long though
15:39:28 <george> i dont see how it is doing much of anything
15:39:59 <newsham> in essense what it does is something like this:   ((\r -> r {conf_input="foo"}) . (\r -> r (conf_output="bar")) (Config "defin" "defout")
15:40:29 <newsham> george: the "fs" that is return from getOpt is a list of update functions (each Config -> Config)
15:40:43 <george> ok
15:40:45 <newsham> updates is just the composition of all the functions in that list
15:41:17 <newsham> the actual functions themselves come from the options = [...] list.
15:41:34 <newsham> ie tihs funtion:  (\v c -> c {c_out=v})
15:41:48 <newsham> when applied to an argument becomes   (\c -> c {c_out="foo"})
15:41:53 <newsham> and that becomes one item in the fs list.
15:41:57 <master_bater> for every minute you are angry, you lose sixty seconds of happiness
15:42:12 <newsham> master: unless being angry makes you happy
15:42:31 <newsham> also there are states of being that are neither happy nor angry.
15:42:38 <newsham> so you could have lost some seconds of something else
15:45:04 <sorear> @users
15:45:04 <lambdabot> Maximum users seen in #haskell: 299, currently: 274 (91.6%), active: 41 (15.0%)
15:47:25 <zeeeeee> how do i define my own set of exceptions, throw one, and catch/handle them? (in the IO monad, if that makes things easier)
15:47:29 <seliopou> @pl \m -> m >>= id
15:47:29 <lambdabot> join
15:47:33 <seliopou> heh
15:47:56 <zeeeeee> i looked at Control.Exception but i don't know how that lets me define my own.
15:48:00 <bd_> :t DynException
15:48:01 <lambdabot> Not in scope: data constructor `DynException'
15:48:03 <bd_> hmm
15:48:07 <bd_> :t DynamicExceptions
15:48:08 <lambdabot> Not in scope: data constructor `DynamicExceptions'
15:48:10 <bd_> :t DynamicException
15:48:11 <lambdabot> Not in scope: data constructor `DynamicException'
15:48:13 <bd_> bleh
15:48:15 <zeeeeee> bd_: it's DynException
15:48:20 <bd_> hmm
15:48:26 <bd_> not imported in lambdabot ?
15:49:04 <sorear> ?index DynException
15:49:04 <lambdabot> Control.Exception
15:49:05 <bd_> well, fi you want it in pure IO you can use DynException
15:49:08 <bd_> or use ErrorT on IO
15:49:27 <zeeeeee> bd_: so i should define a data of class Typeable?
15:49:45 <bd_> hmm, isn't Typeable derivable?
15:49:46 <bd_> not sure
15:49:58 <sorear> yes it is
15:50:00 <bd_> in any case, you can't make your own instance manually
15:50:07 <bd_> since there are no exported constructors of TypeRep
15:50:13 <sorear> yes you can - it's just massively unsafe
15:50:37 <sorear> bd_: typeOf (0 :: Int) is a valid value of type TypeRep
15:50:42 <bd_> you need to derive it
15:50:48 <zeeeeee> should i be using ErrorT monad instead?
15:50:56 <bd_> sorear: okay, I suppose that technically works... >.>
15:50:57 <sorear> I've successfully segfaulted GHC using a hand-rolled Typeable instance
15:51:21 <newsham> whats an unsuccessful segfault? ;-)
15:51:25 <bd_> zeeeeee: that's probably best, but if you's rather stay in IO you can do data MyExecption = ... deriving (Typeable), and use throwDyn and catchDyn
15:51:30 <bd_> newsham: a bus error? :)
15:51:35 <sorear> newsham: an exception
15:51:59 <zeeeeee> i mean, i see an bewildering number of leads: fail, error, exitImmediately, Error monad, Control.Exception, ...
15:52:06 <sorear> > array (minBound::Int, maxBound) [(2,'a')] -- unsuccessfull segfault
15:52:38 <bd_> zeeeeee: probably the easiest way if you're in IO anyway is to just use throwDyn, catchDyn, and derive Typeable for anything you're going to be throwing
15:52:39 <newsham> The type of exceptions. Every kind of system-generated exception has a constructor in the Exception type, and values of other types may be injected into Exception by coercing them to Dynamic
15:52:47 <seliopou> darcs question
15:52:57 <seliopou> I'm trying to do a darcs get via ssh
15:53:22 <newsham> what about System.IO's userError :: String -> IOError?
15:53:24 <seliopou> I'm using the following command: darcs get <username>@<host>:<repo>
15:53:37 <bd_> zeeeeee: if you want to use the ErrorT monad, define an instance of Error for your exception type and use ErrorT YourErrorType IO; then use throwError and catchError
15:54:06 <seliopou> it prompts me for the password twice, appears to begin downloading the files
15:54:08 <seliopou> and then disconnects
15:54:22 <zeeeeee> newsham: i guess that should be added to the list
15:54:32 <zeeeeee> bd_: i'll try *Dyn then
15:55:12 <benc__> k
15:55:14 <benc__> oops
15:55:15 <benc__> sorry
16:13:47 <zeeeeee> bd_: thanks, seems like DynException fits the bill
16:23:15 <george> newsham, still about?
16:28:08 <sorear> @users
16:28:08 <lambdabot> Maximum users seen in #haskell: 299, currently: 282 (94.3%), active: 35 (12.4%)
16:29:05 <nornagon> ?hoogle Double -> Int
16:29:06 <lambdabot> No matches, try a more general search
16:29:47 <sorear> nornagon: you want fromInteger . round ?
16:29:52 <sorear> :t fromInteger . round
16:29:54 <lambdabot> forall a a1. (Num a, RealFrac a1) => a1 -> a
16:30:23 <sorear> > (fromInteger . round) 3.14159
16:30:24 <lambdabot>  3
16:30:27 <sorear> > (fromInteger . round) 3.922
16:30:28 <lambdabot>  4
16:31:15 <Igloo> The fromInteger is unnecessary
16:31:47 <sorear> it is?
16:31:55 <nornagon> :t round
16:31:55 <sorear> :t round
16:31:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:31:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:32:17 <Igloo> If you want the result to be Int, yes
16:32:29 <sorear> I wonder why hoogle didn't pick up on round?
16:32:40 <george> can i use getOpts to take integer input or will it only take strings?
16:32:54 <nornagon> ?hoogle (RealFrac a, Integral b) => a -> b
16:32:55 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
16:32:55 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
16:32:55 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
16:32:57 <Igloo> (the fromInteger above is actually converting from Integer to Integer, as it happens  :-)  )
16:33:30 <nornagon> it turns out i have to convert into a ratio in this particular case, but thanks for pointing that out :)
16:33:51 <sorear> you mean :
16:34:16 <sorear> @hoogle RealFrac a => a -> Rational
16:34:17 <lambdabot> Prelude.toRational :: Real a => a -> Rational
16:34:27 <nornagon> well, like #e3.9 -> 39/10
16:34:59 <bd_> > read "3.9" :: Rational Integer
16:35:00 <lambdabot>      Kind error: `Rational' is applied to too many type arguments
16:35:00 <lambdabot>     In the ...
16:35:01 <sorear> nornagon: don't store it as a double!  that will nullify 'e' ness
16:35:07 <nornagon> sorear: right.
16:35:10 <bd_> > read "3.9" :: Ratio Integer
16:35:11 <lambdabot>  Exception: Prelude.read: no parse
16:35:15 <bd_> hmm
16:35:35 <nornagon> sorear: i was going to be storing it as an int for 'e'ness, but it turns out i'm supposed to store it as a ratio.
16:35:52 <sorear> Is this a learning exercise? (I ask because I have a nearly complete R5RS parser)
16:35:59 <nornagon> yes. :)
16:36:16 <george> @seen newsham
16:36:16 <lambdabot> newsham is in #haskell-blah and #haskell. I last heard newsham speak 42m 55s ago.
16:36:17 <nornagon> I'd love to peruse that.
16:36:18 <sorear> I think I'm missing quasiquote and vectors...
16:42:16 <george> what is the read function for?
16:42:21 <george> i get errors however i try to use it
16:42:23 <sorear> parsing
16:42:31 <sorear> > read "200" :: Int
16:42:34 <sorear> > read "foo!" :: Int
16:42:36 <lambdabot>  Exception: Prelude.read: no parse
16:42:43 <sorear> > read "200" :: Int
16:42:44 <lambdabot>  200
16:42:49 <george> perfect
16:43:57 <george> http://www.thenewsh.com/~newsham/x/Options.hs
16:44:13 <george> in this file, how is the read function used without defining :: Int like you have done?
16:45:40 <nornagon> > fromInteger (read "200") :: Float
16:45:42 <lambdabot>  200.0
16:45:46 <sorear> the type of 'f' imposes the neccessary constraint
16:45:46 <augustss> read converts to whatever the context requires
16:45:47 <nornagon> it can be inferred
16:46:08 <sorear> "foo!" !! read "1"
16:46:11 <augustss> > read "200" + (1::Int)
16:46:13 <lambdabot>  201
16:46:14 <sorear> > "foo!" !! read "1"
16:46:15 <lambdabot>  'o'
16:46:47 <sorear> read "\"foo\\\"bar\"" ++ "!"
16:46:48 <sorear> > read "\"foo\\\"bar\"" ++ "!"
16:46:50 <lambdabot>  "foo\"bar!"
16:48:55 <george> so f is defined as an int elsewhere?
16:49:37 <dons> This week's haskell weekly news is out, http://programming.reddit.com/info/xjzs/comments
16:49:39 <lambdabot> Title: Haskell Weekly News: parser and lexer generators, GADT fun and the Hackathon (re ...
16:52:28 <sorear> ooh, that sure snuck up on me ... didn't get a chance to release something this week :)
16:52:33 <dons> heh
16:52:36 <dons> lazy!
16:53:28 <robreim> Oh wow... Yampa + GADTs!
16:53:48 <dons> sorear: did you see this, http://www.cse.unsw.edu.au/~dons/images/commits/lambdabot-commits.png :)
16:54:28 <sorear> muahahaha!
16:57:09 <sorear> I now have -e working
16:57:41 <newsham> george: haskell knows its trying to make an Int.
16:57:49 <newsham> > read "2" + 3
16:57:50 <lambdabot>  5
17:09:17 <pbx> I won't know for sure until I hear back from the techs, but I think I wedged my FreeBSD VPS twice today trying to build ghc :)
17:16:01 <pbx> Installing hugs instead...
17:19:12 <astrolabe> I don't know what that means, but it sounds painful.
17:21:00 <robreim> dons: any news on hs-plugins + ghc 6.6?
17:21:27 <sjanssen> @remember astrolabe I don't know what that means, but it sounds painful.
17:21:39 <tuukkah> can anyone help with a kind error: this would work: type VV a = StateT VVState (SFKT (State [Vob Node])) a
17:21:56 <tuukkah> but i would have to use the exported type SG r m a = SFKT m a
17:22:06 <sorear> what's the kind of SKFT? VVState?
17:22:39 <tuukkah> newtype SFKT m a  = SFKT (forall ans. SK (m ans) a -> FK (m ans) -> m ans)
17:22:53 <sorear> sorear-lambdabot is now connected to two servers, simultaneously.
17:23:02 <tuukkah> data VVState = VVState { vvDepth :: Int, vvX :: Double, vvY :: Double, vvAngle :: Double }
17:23:47 <tuukkah> i guessed i would have to write some forall in the definition of VV
17:24:01 <pbx> astrolabe: Basically, I typed "sudo portinstall ghc" and backgrounded the process (via GNU screen); a few hours later I noticed that the server had been restarted (whether the physical box or just my instance I don't know) sometime just a few minutes after that. Happened twice today; usually the box is up for weeks to months at a time. Suspicious! There was some talk of the FreeBSD port being broken presently, in limbo pending the ne
17:26:25 <dons> robreim: this week. i'm flying out to the hackathon in a few hours
17:27:31 <robreim> dons: excellent. Have a great trip
17:27:58 <Cale> pbx: how's the cooling solution on that server? Compiling GHC does tend to create lots of excess entropy.
17:32:16 <augustss> computers must be the most inefficient machines we have. 100% of the energy input turns to heat. :)
17:32:32 <augustss> (ok, ok, close to 100%)
17:33:24 <monochrom> Semiconductor inefficiency is astonishing.
17:33:38 <tuukkah> so i suppose this is an equivalent question: given type SG r m a = SFKT m a, how do i write SFKT m a using SG?
17:33:43 <monochrom> But don't generalize to "computer".
17:33:47 <glguy> does 6.6 have any flags I can use to tell it to compile stuff using two processors?
17:33:51 <bd_> Computers are just big short circuits which keep rearranging themselves without warning :)
17:34:02 <bd_> glguy: GHC 6.6 uses make, right? You can try make -j2
17:34:27 <glguy> also , what if I'm building somethig with Cabal (Setup.hs)
17:34:28 <monochrom> dons could build ghc in parallel.
17:34:41 <allbery_b> no, ghc doesn't use make
17:34:54 <bd_> oh, it did last time I tried to build it
17:34:55 <augustss> monochrom: I'll happily generalize to "computer"
17:35:01 <allbery_b> I'd imagine that, since ghc is itself written in ghc, you can use the +RTS option to enabl parallelization
17:35:30 <monochrom> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/03#build_ghc_fast
17:35:31 <lambdabot> Title: Haskell hacking
17:35:47 <monochrom> "building ghc in 10 minutes"
17:35:52 <allbery_b> building ghc undoubtedly uses make, but I readf the question as making a run of ghc paralelize
17:36:30 <monochrom> dons used make -j
17:36:40 <bd_> oh, misread the question...
17:37:48 <monochrom> follow dons's instruction on that page.  there is some preparation
17:39:10 <allbery_b> right, +RTS -Nx to enable use of n processors
17:39:30 <bd_> allbery_b: is ghc capable of utilizing multiple OS threads
17:39:33 <bd_> ?
17:39:49 <bd_> Even if you give it multipel capabilities, that doesn't mean it'll actually use them
17:40:19 <allbery_b> I believe that's what this option controls; in its absence it will use only one OS thread
17:40:40 <allbery_b> it's billed as SMP support, not thread support
17:41:00 <bd_> Yes, but if it's only using one haskell thread, then adding SMP support will do nothing
17:41:08 <allbery_b> (where "thread" there would mean Haskell threads, which aren't necessarily related to Haskell threads)
17:41:34 <allbery_b> I belive there is some work on automatically parallelizing some things, but it probably doesn't do much if anything in 6.6
17:41:59 <allbery_b> in ghc head it probably does a bit more
17:43:33 <allbery_b> okay, looks like 6.6 requires you to use `par`
17:43:52 <allbery_b> I think for 6.7/HEAD they were playing with things like auto-parallelizing map
17:44:16 <allbery_b> (since in pure code there should be no dependencies)
17:45:49 * allbery_b looks at what ghe wrote and kicks himself
17:45:58 <allbery_b> (where "thread" there would mean Haskell threads, which aren't necessarily related to OS threads)
17:46:44 <bd_> Well, certainly one should be able to parallelize ghc --make... in a perfect world :)
17:47:18 <allbery_b> you'd need a ghc internals type to find out if they did :)
17:47:31 <allbery_b> certainly it would be nice, at least if one had SMP available
17:47:33 * allbery_b doesn't
17:48:41 <allbery_b> yay!  freebsd ghc port maintainer has confirmed the build bug and is working on it
17:57:07 <newsham> all: why should a build reboot your machine?
17:57:13 <newsham> sounds like more than just a ports problem.
18:00:13 <bd_> newsham: out-of-memory condition killing something vital, maybe?
18:01:19 <SamB> bd_: you can do it in an imperfect world too
18:01:25 <SamB> but maybe it wasn't maintainable or something
18:02:11 * bd_ shrugs
18:02:28 <bd_> --make is all in-process, right? Maybe it was just waiting for the SMP support in the runtime
18:02:48 <SamB> there was a paper which talked about a parallized version
18:02:53 <SamB> I think it was even recent
18:03:20 <bd_> yeah, the original parallel-haskell paper used parallel GHC runs as an example
18:04:50 <pbx> allbery_b: Thanks for the good FreeBSD news
18:12:34 <pbx> So I notice there's an old mod_haskell project that hasn't been touched in several years... did something supersede it? Or is web stuff just not that interesting for Haskellites?
18:13:51 <vagif> all: Is there actively used haskell web framework ? The ones i found look more like research projects
18:14:00 <SamB> maybe a scripting-language-style apache module just wasn't appropriate?
18:15:01 <Saizan> vagif: HAppS?
18:15:28 <pbx> Yeah, Happs seems quite active
18:15:49 <vagif> thx i'll check it
18:16:24 <Saizan> even if in my opinion it needs quite an injection of hs-plugin's dynamicity
18:16:37 <ClaudiusMaximus> @where MakeSuccess
18:16:38 <lambdabot> I know nothing about makesuccess.
18:16:47 <ClaudiusMaximus> @hoogle MakeSuccess
18:16:48 <lambdabot> No matches found
18:17:31 <george> can someone help... i want a little function that takes X and returns a maybe Int.. the maybe Int will take value of just X if X was an int and be a nothing if X wasn't an int
18:17:34 <george> any ideas?
18:18:44 <Saizan> you need Typeable
18:19:02 <Saizan> ?index typeOf
18:19:02 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
18:19:04 <augustss> george: why would you want such a function?
18:19:45 <george> augustss, heh... because im in a mess =)
18:19:50 <george> basically
18:19:51 <augustss> george: it's doable in Haskell, but it's rarely the right way
18:20:02 <george> well ill explain as im sure im doing this wong
18:20:03 <george> wrong*
18:20:14 <george> im using getargs
18:20:19 <george> and i want to ensure i get an int
18:20:28 <george> and getargs is just returning a list of strings
18:21:42 <augustss> yes, that's right
18:22:13 <george> so i figured if i did it this way
18:22:18 <george> it would be possible
18:22:22 <augustss> so what you have is a string, and you want Just x (where x is the int) if it converts, and Nothing otherwise?
18:22:50 <sjanssen> @where paste
18:22:51 <lambdabot> http://paste.lisp.org/new/haskell
18:23:22 <augustss> f :: String -> Maybe Int; f s = case reads s of [(x,"")] -> Just x; _ -> Nothing
18:23:30 <lisppaste2> sjanssen pasted "found this in my code snippets: maybeRead" at http://paste.lisp.org/display/34563
18:23:53 <sjanssen> blast! augustss beat me
18:23:55 <george> yeah
18:24:19 <george> is this the best way to strip an int out do you think?
18:24:27 <sjanssen> and I don't remember why the assert False is there . . .
18:24:41 <augustss> sjanssen: the assert False looks bogus
18:24:53 <seliopou> sjanssen: probably put it there for debugging at some point
18:24:59 <augustss> george: well, f is one way of doing it
18:25:10 <sjanssen> augustss: right, definitely bogus
18:25:21 <george> but, is this a good way to get ints from getarg?
18:25:49 <augustss> george: depends on what you want to happen if it's not an int
18:26:09 <lisppaste2> sjanssen annotated #34563 with "done the right way" at http://paste.lisp.org/display/34563#1
18:26:10 <gmh33> ml
18:26:20 <george> augustss, print a custom error message would be good
18:26:36 <george> if its not an int, or if its <= 0
18:26:54 <augustss> george: an error message and then let the program die?
18:27:05 <george> yes
18:27:37 <augustss> f :: String -> Int; f s = case reads s of [(x,"")] | x> 0 -> x; _ -> error "Bad value"
18:28:26 <augustss> > let f :: String -> Int; f s = case reads s of [(x,"")] | x> 0 -> x; _ -> error "Bad value" in map f ["2","3"]
18:28:27 <lambdabot>  [2,3]
18:28:37 <augustss> > let f :: String -> Int; f s = case reads s of [(x,"")] | x> 0 -> x; _ -> error "Bad value" in map f ["aa","3"]
18:28:39 <lambdabot>  Exception: Bad value
18:28:49 <augustss> > let f :: String -> Int; f s = case reads s of [(x,"")] | x> 0 -> x; _ -> error "Bad value" in map f ["-2","3"]
18:28:50 <lambdabot>  Exception: Bad value
18:29:12 <george> awesome =)
18:30:52 <george> i thought you can only use case in IO ?
18:31:05 <allbery_b> case can be used anywhere
18:35:29 <Anon4888> @type reads
18:35:30 <lambdabot> forall a. (Read a) => ReadS a
18:36:04 <Anon4888> @src reads
18:36:05 <lambdabot> reads = readsPrec minPrec
18:36:13 <Anon4888> @src readsPrec
18:36:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:36:32 <Anon4888> @src ReadS
18:36:33 <lambdabot> Source not found. stty: unknown mode: doofus
18:36:51 <Anon4888> @doc reads
18:36:51 <lambdabot> reads not available
18:36:58 <Anon4888> @docs reads
18:36:59 <lambdabot> reads not available
18:37:12 <Anon4888> @doc ++
18:37:12 <lambdabot> ++ not available
18:37:34 <allbery_b> @doc (++)
18:37:35 <lambdabot> (++) not available
18:38:06 <sjanssen>  @doc takes module names only
18:38:17 <allbery_b> oh duh
18:38:23 <Anon4888> @what-module reads
18:38:24 <lambdabot> Unknown command, try @list
18:38:25 * allbery_b was thninking @src and typed @doc
18:38:32 <allbery_b> @index reads
18:38:32 <lambdabot> Text.Read, Prelude
18:38:44 <Anon4888> @help
18:38:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:38:46 <sjanssen> Anon4888: try @hoogle, perhaps
18:38:52 <Anon4888> @help list
18:38:52 <lambdabot> list [module|command]
18:38:52 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:39:03 <Anon4888> @list
18:39:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:39:11 <seliopou> @list Prelude
18:39:11 <lambdabot> No module "Prelude" loaded
18:39:17 <sjanssen> Anon4888: lambdabot listens to /msg, please take repeated queries there
18:39:56 <Anon4888> sorry
18:40:15 <allbery_b> the module argument to @list is a lambdabot plugin,. not a haskell module
18:40:52 <Anon4888> The list it linked to does not contain src, index, etc
18:42:01 <allbery_b> er?  "haddock provides: index"
18:42:30 <shapr> whee
18:42:31 <sjanssen> lambdabot is ever changing, the list just hasn't caught up yet
18:42:40 <Anon4888> ah I wasn't reading the list correctly
18:42:44 <allbery_b> "source provides: src"
18:42:49 * sorear waves to lambdabot
18:43:26 <lambdabot> hello sorear!
18:43:40 <shapr> @quote
18:43:40 <lambdabot> dpiponi says: [<monochrom> Nevermind monads.  Use arrows.  Come join the Dart Side!] <dpiponi> Never mind arrows. Use comonads. Cojoin the other side.
18:43:48 * shapr laughs
18:44:08 <shapr> How do I submit stuff to HWN again?
18:44:29 <sjanssen> shapr: I think there's a darcs repo
18:44:46 <shapr> ah
18:46:47 <orbitz> is it possible to write a function which performs IO in it but does not return an IO type?
18:47:04 <allbery_b> yes, but don't do that
18:47:20 <allbery_b> it invites haskell to do strange things
18:47:45 <nostrademons> unsafePerformIO, but as allberry_b says, don't do that ;-)
18:47:51 <orbitz> so does the trace function do soem trickery?
18:47:52 <sjanssen> nostrademons: shhh!
18:48:01 <sorear> yes
18:48:08 <orbitz> would you consider it evil?
18:48:19 <allbery_b> look up the "IO Inside" document for (a) how to do it nd (b) why it's a bad idea
18:48:22 <sorear> trace uses hafnsrCresbezVB internally
18:48:23 <allbery_b> on the wiki
18:48:30 <orbitz> ok
18:48:45 <orbitz> and is it correct to think of (<-) as the inverse of return?
18:48:57 <sorear> (<-) : no such thing
18:48:57 <shapr> sorear: Is hafnsrCresbezVB Hungarian notation?
18:49:02 <orbitz> <-, in very laymans terms takes a out of an IO a
18:49:03 <benc__> rot13!?
18:49:07 <allbery_b> (and also just what's going on wth that IO stuff, which explains why things are done that way)
18:49:08 <orbitz> and return ptus a into an IO a?
18:49:34 <shapr> orbitz: You should look at monads without do notation first.
18:49:37 <allbery_b> you can think of return as wrapping something in the monad and <- as unrapping it, yes.  but that's not actually what's going on
18:49:50 <sorear> @type (>>=)
18:49:51 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:49:52 <orbitz> shapr: right i know it translates to a lambda ntoation with >> and >>=
18:49:55 <benc__> i was thinking the other day that I could wrap my whole program inside an SQL transaction and then do unsafePerformIO on SQL selects without risk of the DB changing under me...
18:50:12 <sorear> benc__: what about laziness?
18:50:14 * dons is off to the hackathon. see you all in a couple of days... !
18:50:15 <benc__> for this photo album thing I do
18:50:31 <sjanssen> @undo do {x <- m1; y <- m2; return (x + y)}
18:50:32 <lambdabot> m1 >>= \ x -> m2 >>= \ y -> return (x + y)
18:50:40 <allbery_b> that doesn't stop haskell; from lazily ignoring or modifying your commands
18:50:45 <benc__> sorear: I was just gonna let the transation get closed by the program terminating
18:50:46 <shapr> dons: Have fun!
18:50:46 <allbery_b> s/;//
18:50:49 <dons> be nice to the bot.
18:50:57 <sjanssen> have a nice trip, dons!
18:50:57 * dons departs... zooooom !
18:51:21 * sjanssen pulls out his accumulated lambdabot hacks :)
18:51:23 <sorear> *hackneyed goodbye*
18:51:39 <shapr> I wish lambdabot had failover.
18:51:44 <shapr> hm! This gives me an idea...
18:52:34 <SamB> shapr: lambdabot with failover?
18:52:41 <SamB> you are going to implement that?
18:52:59 <shapr> Maybe
18:53:28 <sorear> shapr: lambdabot will Real Soon Now support multiple connections, so nothing short of a system crash will be able to kill it
18:53:30 <shapr> Actually, I have a really good idea how to do that.
18:53:41 <shapr> sorear: Ah, but I know how to get around a system crash too.
18:53:44 * sorear does too
18:53:51 <shapr> How would you do it?
18:54:29 * sorear tries to find URL
18:55:02 <SamB> does this work even if the system stays down?
18:55:16 <sorear> oh wait the revised version isn't up...
18:55:54 <sorear> (1) run N lambdabots. (2) lambdabot only responds to general requests if it is the alphabetically first lambdabot in channel.
18:55:56 <Anon4888> Why does lambdabot die so frequently?
18:56:06 <sorear> now: upgrades
18:57:05 <SamB> sorear: what about keeping the state consistant?
18:57:27 <SamB> so that if I say @remember sorear (1) run N lambdabots. (2) lambdabot only responds to general requests if it is the alphabetically first lambdabot in channel.
18:57:46 <SamB> when lambdabotB is down, it will learn about that later?
18:58:04 <sorear> normally, lambdabot doesn't die, so only one lb keeps state
18:58:14 <SamB> um.
18:58:20 <SamB> big flaw in that plan!
18:58:24 <sorear> otherwise ... @remember et al are disabled.
18:58:55 <SamB> ... the whole point of this is to handle those times when lambdabot *does* die
18:59:12 <shapr> hej Hunter
18:59:46 <shapr> sorear: I know how to make state and all the rest work with a single lambdabot, and it'll even handle dead hard ware...
18:59:57 <Excedrin> if state is replicated across instances, and it dies due to a bug, won't all instances die?
19:00:11 <sorear> GdH!?
19:00:36 <bd_> Excedrin: Check the state into a version control system :)
19:00:50 <sorear> just put it on the wiki :)
19:00:53 <SamB> Excedrin: depends how state is replicated
19:00:59 <bd_> darcs is line oriented, so if LB started using Read/Show...
19:00:59 <sorear> (the state, not shapr's suggestion)
19:01:11 <SamB> bd_: lb used read/show for state once!
19:01:19 <Excedrin> bd_: ya, it'll need some sort of log and the ability for the Nth instance to not apply changes that cause a crash...
19:01:26 <sorear> bd_: LB has used a line-oriented format since the beginning of time.
19:01:38 <sorear> bd_: now, it uses gzipped text.  blame dons.
19:01:48 <shapr> I know how to fix it, but I'll just try the implementation and get back with patches...
19:01:56 <shapr> Won't be this week though.
19:02:00 <bd_> Excedrin: Well, hopefully you don't allow anything which will crash it at the type level :)
19:02:20 <sorear> dons-- dons++ dons-- dons++ dons-- dons++ dons-- dons++ dons-- dons++ just felt like doing this for some reason
19:02:36 <SamB> does that work?
19:02:39 <SamB> @karma dons
19:02:42 <bd_> doesn't it only recognize it if it's on a line by itself?
19:02:47 <SamB> dons++ dons--
19:02:51 <bd_> karmatestthing++ karmatestthing++
19:02:52 <SamB> @karma dons
19:02:53 <lambdabot> dons has a karma of 110
19:02:53 <bd_> ?karma karmatestthing
19:02:54 <lambdabot> karmatestthing has a karma of 2
19:02:57 <bd_> huh
19:03:01 <shapr> @karma
19:03:02 <lambdabot> You have a karma of 34
19:03:03 <allbery_b> I thought it had to be the first thing on the line, but there was discussion about it and maybe it's been fixed
19:03:10 <sorear> blame sjannsen, he patched it
19:03:43 <SamB> mmm.
19:03:46 <SamB> okay.
19:03:46 <sorear> @karma
19:03:47 <lambdabot> You have a karma of 10
19:03:48 <SamB> @karma xs
19:03:48 <lambdabot> xs has a karma of 1
19:03:49 <sjanssen> oh no, what did I do?
19:03:51 <bd_> ?karma
19:03:52 <lambdabot> You have a karma of 0
19:04:03 <sorear> this: sjanssen++
19:04:26 <sjanssen> sorear: oh.  So a good sort of blame then?
19:04:30 <shapr> I shall test this with bd_++
19:04:34 <shapr> @karma bd_
19:04:34 <lambdabot> bd_ has a karma of 1
19:04:46 <bd_> it seems that shapr++'s test has succeeded.
19:04:48 <shapr> Another test bd_+++ bd_---
19:04:49 <bd_> ?karma shapr
19:04:50 <lambdabot> shapr has a karma of 34
19:04:53 <shapr> @karma bd_
19:04:53 <lambdabot> bd_ has a karma of 1
19:05:05 <Anon4888> @karma police
19:05:05 <lambdabot> police has a karma of 0
19:05:06 <sorear> @where lambdabot
19:05:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:05:06 <shapr> Another test bd_++ bd_--
19:05:10 <shapr> @karma bd_
19:05:10 <lambdabot> bd_ has a karma of 1
19:05:14 <shapr> Well, now we know.
19:05:21 <sorear> shapr: you can read the source :)
19:05:24 <shapr> too easy!
19:07:40 <sorear> @users
19:07:40 <lambdabot> Maximum users seen in #haskell: 299, currently: 277 (92.6%), active: 31 (11.2%)
19:11:30 <sorear> ?index Sem
19:11:35 <sorear> ?index QSem
19:11:35 <lambdabot> Control.Concurrent.QSem, Control.Concurrent
19:13:42 <shapr> Whoa, that Paul Johnson quote in HWN is *really* profound!
19:14:38 <sorear> agreed.
19:16:38 <benc__> so that SQL thing i said
19:16:58 * shapr brands benc__ with the insanity logo
19:17:03 <benc__> heh
19:17:10 <shapr> Of course, I've got one of those too...
19:17:13 <benc__> shapr: basically what I want is to have a functional SELECT
19:17:24 <benc__> shapr: because inside a transaction, it is referntially transparent
19:17:29 <Excedrin> so is that Excedrin quote... seriously mind-blowing!
19:17:41 <Excedrin> oh wait, nevermind
19:17:41 <shapr> benc__: Have you seen HaskellDB
19:17:52 <shapr> Excedrin: Hey, you made it into HWN quotes, that's nice :-)
19:18:18 <Excedrin> yea, and I was trolling
19:18:20 <benc__> shapr: i've been using HDBC
19:18:20 <sorear> (I didn't get one this time :( ) :)
19:18:26 <shapr> benc__: What about HaskellDB?
19:18:38 <benc__> no
19:18:48 <shapr> Try it, you might like it.
19:18:52 <sorear> but I was a HWN quoter, which is almost as good...
19:18:53 * benc__ looking now
19:19:00 <sorear> (just not as public)
19:19:13 <benc__> neat
19:19:21 <benc__> heh
19:19:25 <benc__> i was reading the paper about that earlier
19:19:31 <benc__> but didn't realise it was haskelldb
19:19:35 <benc__> like 4h ago
19:19:38 <Excedrin> Paul Johnson's quote is good
19:19:42 <benc__> was it on lambda-the-ultimate or something?
19:19:52 <shapr> Probably
19:19:59 <benc__> oh
19:20:06 <benc__> no, i got it by following links from parsec
19:20:11 * benc__ remembers now
19:20:15 <sorear> iirc it was on planet. or p.r.c
19:20:19 <shapr> Right, because Daan wrote Parsec and the first version of HaskellDB
19:20:38 <benc__> right
19:20:47 <benc__> the papers are right next to each other on http://www.cs.uu.nl/people/daan/pubs.html
19:21:06 * sorear once saw a bumper sticker and then proceeded to confuse Paul Graham with Billy Graham
19:21:08 <benc__> it even has a hyperlink in the abstract to haskelldb...
19:22:05 <glguy> ?seen Cale
19:22:06 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 54m 11s ago.
19:22:31 <kaol> @quote Cale
19:22:32 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
19:22:57 <orbitz> drats this sudoku algorithm is not working out
19:23:06 <kaol> @quote sudoku
19:23:07 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
19:23:11 <benc__> mmm sudoku
19:23:29 <shapr> @quote fin
19:23:30 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
19:23:31 <mgsloan> > last []
19:23:32 <lambdabot>  Add a type signature
19:23:36 <shapr> @quote swed
19:23:36 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
19:23:41 <glguy> ?pl swing f c a = (f ($ a)) c
19:23:41 <lambdabot> swing = flip . (. flip id)
19:23:41 <shapr> @quote bring
19:23:41 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
19:23:44 <shapr> @quote bring
19:23:44 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
19:23:54 <shapr> Hm, only matches the first quote everytime?
19:24:20 <mgsloan> I think it matches quotes to the context, recent discussion.
19:24:25 <glguy> ?djinn (((a -> b) -> b) -> c -> d) -> c -> a -> d
19:24:26 <lambdabot> f a b c = a (\ d -> d c) b
19:24:40 <kaol> @quote djinn
19:24:41 <lambdabot> sjanssen says: @djinn Haskell -> Curry
19:24:48 <sorear> yow!
19:25:14 <sorear> you trying to djinn pierces law?
19:25:52 <sorear> @djinn ((((p -> f) -> f) -> ((q -> f) -> f)) -> ((p -> f) -> f)) -> ((p -> f) -> f)
19:25:52 <lambdabot> f a b = a (\ c _ -> c b) b
19:26:14 <glguy> I was just playing with the LicensedPreludeExts swing combinator
19:26:39 <seliopou> @djinn (a -> b)
19:26:40 <lambdabot> -- f cannot be realized.
19:27:00 <seliopou> @djinn a -> b -> c
19:27:01 <lambdabot> -- f cannot be realized.
19:27:04 <bd_> @djinn [a -> b] -> [a] -> [b]
19:27:04 <lambdabot> -- f cannot be realized.
19:27:06 <seliopou> :(
19:27:20 <sorear> @djinn (a -> s -> (b, s)) -> (b -> s -> (c,s)) -> a -> s -> (c,s)
19:27:20 <lambdabot> f a b c d =
19:27:20 <lambdabot>     case a c d of
19:27:20 <lambdabot>     (e, f) -> b e f
19:27:24 <bd_> @djinn [a -> b] -> [[a]] -> [[b]]
19:27:24 <lambdabot> -- f cannot be realized.
19:27:34 <seliopou> @djinn a -> (a, a)
19:27:34 <lambdabot> f a = (a, a)
19:27:45 <astrolabe> it's not good on recursive types apparently
19:28:04 <bd_> @djinn [a -> a] -> a -> a
19:28:04 <lambdabot> f _ a = a
19:28:08 <bd_> heh
19:28:27 <sorear> @djinn [a] -> Maybe a
19:28:28 <lambdabot> f _ = Nothing
19:28:51 <seliopou> @djinn ((a -> b) -> a) -> a
19:28:52 <lambdabot> -- f cannot be realized.
19:28:58 <glguy> ?djinn [a] -> (a -> b) -> Just b
19:28:59 <lambdabot> -- f cannot be realized.
19:29:13 <glguy> ?djinn [a] -> (a -> b) -> Maybe b
19:29:13 <lambdabot> f _ _ = Nothing
19:29:15 <seliopou> :t head empty
19:29:17 <glguy> heh
19:29:17 <lambdabot> Not in scope: `empty'
19:29:21 <seliopou> :t head []
19:29:23 <lambdabot> forall a. a
19:29:29 <sorear> seliopou: pierce's law is only a law in classical logic, djinn uses intuitionist logic
19:29:39 <seliopou> :t \ _ -> head []
19:29:41 <lambdabot> forall a t. t -> a
19:30:04 <sorear> Now give me a total function of that type.
19:30:17 <sorear> :t GHC.Prim.unsafeCoerce#
19:30:19 <lambdabot> forall b a. a -> b
19:30:51 <sorear> > GHC.Prim.unsafeCoerce# 2 -- just making sure
19:30:52 <lambdabot>   Not in scope: `#'
19:31:24 <SamB> heh
19:31:44 <SamB> that doesn't even parse correctly without -fglasgow-exts
19:32:35 <sorear> @help set
19:32:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:32:39 <sorear> @set foo
19:32:39 <lambdabot>  Parse error
19:33:00 <sorear> I wonder what that corrects too?
19:33:43 <sorear> @set "foo"
19:33:44 <lambdabot>  Parse error
19:35:29 <sorear> @seen dylan
19:35:29 <lambdabot> dylan is in #haskell. I last heard dylan speak 13h 50m 16s ago.
19:38:43 <Cale> glguy: looking for me?
19:41:59 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/gallery/coding/hsext/swap.png << a (slightly) less trivial example of what i've been working on (namely interfacing Haskell with Pd)
19:46:28 <johnnowak> ClaudiusMaximus: why haskell for pd?
19:46:33 <Cale> http://www.serpentine.com/blog/2007/01/01/the-shock-of-the-forgotten/ -- this is a neat story :)
19:47:47 <nostrademons> hah, "away from the fold"
19:47:50 * nostrademons likes the pun
19:50:46 <ClaudiusMaximus> johnnowak: perversity is one reason (functional vs state modification), another is "because it was there", still another is to learn more about both
19:51:25 <johnnowak> ClaudiusMaximus: ah. i learned to program with max, so i'm always interested in what anyone is doing with it even though I don't use it any longer.
19:58:29 <orbitz> wheni perorm a :load somefile.hs in, ghci for example, is that code probably oging to run significantly slower than i fi compiled it?
19:59:39 <sorear> yes.
20:00:15 <sorear> *however*, if an up-to-date object file exists, ghci will load that and execute it as machine code.
20:00:27 <sorear> so for the best performance in ghci, run ghc first.
20:00:39 <orbitz> maybe that's why my code i runnig so slow
20:00:51 <sorear> then if you change a file and :reload, only that file will be interpreted
20:01:30 <sorear> also, ghci's optimizer is broken, which makes compiled code that much more faster.
20:01:38 <sorear> ?quote ClaudiusMaximus
20:01:48 <sorear> @botsnack
20:01:48 <lambdabot> :)
20:01:50 <sorear> ?quote ClaudiusMaximus
20:01:50 <lambdabot> ClaudiusMaximus says: compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
20:02:03 <orbitz> doesnt that make ghci's code lower? not ghc's faster?
20:02:25 <sorear> relatively speaking ...
20:02:28 <allbery_b> it's all in how you look at it
20:02:34 <allbery_b> is the glass half empty, or half full? :)
20:03:41 <orbitz> hrm even wiht -O2 not getting as god performane as id like
20:03:54 <orbitz> norvig's code can do 8 of these puzzles a second supposedl i'm doign 1 every 30 seconds it seems
20:04:07 <sorear> sorry, even GHC can't achieve god performance :)
20:04:18 <orbitz> norvig's is in python
20:04:21 <orbitz> i gotat owrk on my algorihtm
20:05:30 <iulus> woah--I just switched from vim to emacs; emacs gives me the type signature of functions!
20:05:40 <iulus> now that's cool.
20:05:52 <sorear> indeed
20:05:56 <orbitz> hot digity!
20:06:02 <orbitz> i sitll need to figur eout teh ghci interactive mode in emacs
20:06:04 <orbitz> been too lazy
20:06:23 <sorear> just remember that emacs only gives type signatures for functions in the 1.4 prelude
20:06:34 <sorear> from the todo file: "update for Haskell 98"
20:06:55 <iulus> ah, I'll keep that in mind
20:07:35 <sorear> If I ever learn elisp, I'll modify haskell-mode to get up-to-date signatures direcly from hoogle.
20:07:44 <iulus> I'm just happy that I don't have to have seperate ghci and editor windows any more (all though the switch significantly slowed down my navigation and editing speed)
20:08:30 <mgsloan> hmm, maybe if I get a microsoft internship I can work in research on ghc and refurbish ghci - that would be sweet.  Do something I want someone to do, and get paid for it
20:08:34 <sorear> orbitz: the brokenness is in autoload
20:09:01 <sorear> (load "/usr/share/emacs/site-lisp/haskell-mode/inf-haskell.el")  ; this is in my .emacs, and it makes inf-haskell work
20:09:06 <mgsloan> (I guess I'm assuming they pay SPJ for working on ghc... may be wrong there though)
20:09:44 <iulus> what's inf-haskell?
20:10:07 <allbery_b> "inferior haskell mode" aka haskell running in an emacs buffer
20:10:09 <sorear> that's where you hit C-c C-l and your program is automatically loaded in ghci
20:10:24 <sorear> it is very nice
20:10:34 <iulus> oh, I must have set that up already
20:11:08 <sorear> it's not the same as ghci-in-a-shell-window... inf-haskell uses a buffer named *haskell*
20:12:50 <mgsloan> ah, he's all the way in england anyway
20:14:10 <iulus> that'd be a fun semester, though
20:14:20 <sorear> you wouldn't change continents just to be able to hack ghci? :)
20:14:38 <iulus> where's your dedication! :P
20:15:33 <mgsloan> :)
20:15:56 <iulus> I'll be happy if I just get an assistantship to grad school
20:16:17 <bd_> @hoogle Int -> a -> [a] -> [a]
20:16:33 <sorear> @botsnack
20:16:33 <lambdabot> :)
20:16:43 <sorear> bribes usually work :)
20:16:46 <bd_> oh dear, the bot is getting hungry?
20:16:47 <bd_> @hoogle Int -> a -> [a] -> [a]
20:16:48 <lambdabot> No matches, try a more general search
20:16:56 <bd_> *shakes fist*
20:17:11 <the_human_hoogle> what do you want?
20:17:53 <bd_> a function to insert an element at a given index in a list... I supposd I can build it with splitAt
20:17:59 <sorear> that's not intercalate, nor is it replicate...
20:18:08 <SamB_XP> @botsnack
20:18:09 <lambdabot> :)
20:18:16 * SamB_XP heard lambdabot was hungry
20:19:22 <Cale> Use splitAt, yeah
20:19:26 <iulus> human_hoogle works by process of elimination
20:19:58 <SamB_XP> how about const (const id)?
20:20:04 <SamB_XP> @type const (const id)
20:20:06 <lambdabot> forall b a b1. b1 -> b -> a -> a
20:20:13 <bd_> insertAt n e l =
20:20:13 <bd_>     let (a, b) = splitAt n l in a ++ [e] ++ b
20:20:15 <mgsloan> :t splitAt
20:20:17 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:21:01 <sorear> it's not even in missingh!
20:21:42 <SamB_XP> isn't the insertAt based version inefficient?
20:21:55 <SamB_XP> er.
20:21:59 <SamB_XP> s/insert/split/
20:22:04 <sorear> no!
20:22:09 * SamB_XP should not try to talk and watch anime at same time
20:22:17 <sorear> it is asymptotically optimal!
20:22:26 <SamB_XP> sorear: sure sure
20:22:38 <SamB_XP> but only within a constant factor!
20:22:54 <sorear> haskell + attempts at constant factor optimization = head explosion
20:23:10 <SamB_XP> wouldn't it be more efficient to just write it the stupid way?
20:23:17 <bd_> the splitAt version may have a space leak I support
20:23:19 <sorear> SamB: I'd much rather see a stream fusion system than an optimization attempt.
20:23:19 <bd_> suppose*
20:23:27 <SamB_XP> sorear: stream fusion?
20:23:28 <seliopou> Awesome constant factor optimization: unsafe array operations
20:23:30 <seliopou> so good
20:23:33 <SamB_XP> you think that would work?
20:23:45 <sorear> sure ... fuse take with (++)
20:23:47 <SamB_XP> seliopou: that is hardly appropriate when dealing with linked lists
20:23:50 * mgsloan doesn't see what the problem is
20:23:58 <seliopou> True, but good to know about nonetheless
20:24:06 <sorear> @src ++
20:24:10 <sorear> @src (++)
20:24:10 <lambdabot> (++) []     ys = ys
20:24:11 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
20:24:12 <SamB_XP> well, actually, I think you get some nasty closures with the splitAt version?
20:24:15 <mgsloan> that should be perfectly lazy, and efficient
20:24:50 <bd_> SamB_XP: yeah, it'd probably keep a copy of the entire list until you evaluate the second closure
20:25:01 <mgsloan> ooh, nice, is that a new LB command?
20:25:32 <sorear> you evaluate the second closure when you have evaluated the entire first part
20:25:46 <mgsloan> @let insertAt n e l = let (a, b) = splitAt n l in a ++ [e] ++ b
20:25:47 <lambdabot> Defined.
20:25:51 <sorear> so it is plenty space efficient for length list >> n
20:26:20 <mgsloan> > L.insertAt 5 2 [1,2..]
20:26:22 <lambdabot>  [1,2,3,4,5,2,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:26:32 <bd_> sorear: hm, I thought the second one might keep a reference to the entire first list around?
20:26:38 <bd_> @src splitAt
20:26:38 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
20:26:41 <SamB_XP> well, the thing is that splitAt returns *two* lists
20:27:11 <mgsloan> hmm, I hope the real preludes use a better def than that
20:27:12 <sorear> I'd rather improve the garbage collector :)
20:27:22 <bd_> *checks*
20:27:25 <notsmack> ?src L.insertAt
20:27:25 <lambdabot> Source not found. Wrong!  You cheating scum!
20:27:28 <SamB_XP> sorear: *garbage collector*?
20:27:38 <sorear> yes
20:27:50 <SamB_XP> you think the garbage collector should do evaluation?
20:27:54 <sorear> yes!
20:27:56 <bd_> heh
20:28:02 <bd_> well, if it'll reduce space usage...
20:28:04 <SamB_XP> you may do the necessary proofs
20:28:14 <sorear> who cares about proofs?
20:28:29 <sorear> ghc's map fusion is provably incorrect
20:28:30 <SamB_XP> well, I want a proof that this isn't going to *waste* memory
20:28:39 <SamB_XP> okay?
20:28:46 <Hirvinen> Those who care about their software's correctness?
20:28:46 <SamB_XP> (is that fair?)
20:28:56 <sorear> fair enough.
20:29:02 <seliopou> @src ghc's map fusion is provably incorrect
20:29:02 <lambdabot> Source not found. I feel much better now.
20:29:19 <SamB_XP> @remember sorear ghc's map fusion is provably incorrect
20:29:19 <lambdabot> Done memoising quote for `sorear', if that is their real name...
20:29:38 <SamB_XP> @quote ghc
20:29:38 <lambdabot> ghc says: Use -fallow-incoherent-instances
20:29:44 <SamB_XP> @quote .*ghc.*
20:29:45 <lambdabot> lambdabot says: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
20:29:54 <sorear> it relies on a free thorem
20:30:07 <SamB_XP> sorear: what is incorrect about it?
20:30:11 <SamB_XP> @quote .*ghc.*
20:30:11 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
20:30:20 <SamB_XP> what?
20:30:22 <sorear> foldr/build + seq + ghc -O --> miscompilation
20:30:26 <SamB_XP> DEATH RAY?
20:30:34 <SamB_XP> hmm.
20:30:36 <ray> death samb_xp?
20:30:43 <sorear> bottom -> non-bottom. not that serious, but still a miscompilation.
20:30:53 <SamB_XP> that gaal quote...
20:30:59 <SamB_XP> sorear: that is not miscompilation!
20:31:15 <SamB_XP> haskell standard saith not what happen when you try to evaluate _|_!
20:31:56 <sorear> I've been trying to tell people that for years, and then I just gave up and drank the consistency-of-errors-stuff.
20:32:09 <sorear> well, insofar as C has _|_
20:32:28 <bd_> :t build
20:32:30 <lambdabot> Not in scope: `build'
20:32:36 <sorear> :t GHC.Prim.build
20:32:37 <lambdabot> Not in scope: `GHC.Prim.build'
20:32:41 <sorear> :t GHC.Exts.build
20:32:42 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
20:32:53 <sorear> @src GHC.Exts.build
20:32:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:33:05 <sorear> build f = f (:) []
20:33:19 <augustss> SamB_XP: it's a definite miscompilation
20:33:20 <sorear> foldr f z (build g) = g f z
20:33:40 <augustss> SamB_XP: you can't change bottom to non-bottom
20:34:02 <SamB_XP> augustss: Haskell standard not say what _|_ does, does it?
20:34:30 <augustss> well, the haskell standard is lacking in many respects
20:34:57 <augustss> it's doesn't say that 1+1=2 either (I think)
20:35:26 <nostrademons> hmm.  anyone know of a function that given a list [1, 2, 3, 4, ..] returns a list [(1,2), (2,3), (3,4), ...]
20:35:39 <sorear> > ap zipWith tail [1..]
20:35:40 <lambdabot>  Couldn't match `[a]' against `a1 -> b -> c'
20:35:45 <sorear> > ap zip tail [1..]
20:35:46 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
20:36:04 <nostrademons> cool, thanks
20:36:12 * sorear <heart/> ap
20:36:36 <nostrademons> ap's one of the monad functions, right?
20:36:45 <sorear> right
20:37:05 <sorear> in this context ap is Shornfinger's S combinator
20:37:18 <nostrademons> man.  where do you learn all this stuff?
20:37:32 <SamB_XP> augustss: but everyone already knows what 1+1=2 is...
20:37:33 * sorear is pretty sure he mangled that guy's name
20:37:39 <SamB_XP> obviously, it is 0!
20:37:41 <augustss> SchÃ¶nfinkel
20:38:30 <SamB_XP> @babel de en SchÃ¶nfinkel
20:38:31 <lambdabot>   SchÃ¶nfinkel
20:38:33 <SamB_XP> hmm.
20:43:38 <mgsloan> Schon means good
20:43:44 <mgsloan> @babel de en finkel
20:43:45 <lambdabot>   finkel
20:44:04 <george> what would be the easiest way to repeat a command x no. of times and instead of getting 1 output say z you get [z] instead
20:44:04 <mauke> @babel de en schÃ¶n
20:44:05 <lambdabot>   schÃ¶n
20:44:10 <mauke> wtf
20:44:14 <george> where length [z] = x
20:44:14 <SamB_XP> @babel german english SchÃ¶nfinkel
20:44:15 <lambdabot>   SchÃ¶nfinkel
20:44:20 <mauke> @babel de en schoen
20:44:21 <SamB_XP> @help babel
20:44:21 <lambdabot>   beautifully
20:44:21 <lambdabot> babel <lang1> <lang2> <phrase>.
20:44:21 <lambdabot> Translate a phrase in lang1 to lang2.
20:44:21 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
20:44:31 <mauke> ah hah!
20:44:32 <sorear_> replicateM
20:44:37 <mgsloan> schoen isn't the same as schon -_-
20:44:48 <mauke> "schon" means already
20:44:51 <SamB_XP> oh, right, lambdabot doesn't support encodings...
20:44:52 <mgsloan> (umlauts missing on the second)
20:44:57 <george> > :t replicateM
20:44:58 <lambdabot>  Parse error
20:45:11 <sorear_> irciii froze up again :(
20:45:53 <mgsloan> oh, schon is just one of those german words that means tons of things
20:46:29 <george> @t replicateM
20:46:29 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:46:31 <zeeeeee> dons: how do you decide when it's 'worth it' to use an unsafe operation? (e.g. unsafeInteleaveIO getKeys in hmp3 and yi)
20:46:39 <george> @type replicateM
20:46:40 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
20:46:43 <mauke> mgsloan: I don't think so
20:46:45 <allbery_b> dons is on his way to the hackathon
20:47:12 <sorear_> ah finally - Alt-SysRq-K did ircii in
20:47:22 <seliopou> @babel en fr hello
20:47:23 <lambdabot>   bonjour
20:47:24 <zeeeeee> as they are named, i feel i should avoid these whenever possible - but in the case of getKeys, this results in more imperative haskell
20:47:38 <seliopou> @babel en gr hello
20:47:38 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language gr not supported
20:47:41 <zeeeeee> allbery_b: oh, i copy
20:47:50 <seliopou> @babel en el hello
20:47:51 <lambdabot>   can't parse this language
20:47:59 <seliopou> ?
20:48:00 <mgsloan> I'm wrong about it being "good" though - I always just figured thats what it meant because the teacher said it when students got answers right
20:48:20 <sorear> zeeee: what is getKeys?
20:48:22 <mauke> he said "schÃ¶n", as in "nice"
20:48:47 <allbery_b> sorear: he's looking at yi and hmp3 source, he said
20:49:18 <sjanssen> zeeeeeee: unsafeInterleaveIO is a lesser evil
20:49:27 <sorear> allbery_b: no I said "shornfinger", as in a mutilated "shoernfinkel", as in a proper noun. no decomposition needed.
20:49:32 <zeeeeee> sorear: getKeys = unsafeInterleaveIO $ do { c <- getKey; cs <- getKeys; return (c:cs) }
20:49:43 <zeeeeee> sorear: think of getKey as getChar
20:49:45 <sorear> oh, that's perfectly safe.
20:49:47 * allbery_b looks confused
20:50:03 <zeeeeee> sorear: when is unsafe unsafe?
20:50:13 <zeeeeee> sorear: when is it safe?
20:50:14 <sorear> zeeeee: that's practically verbatim the GHC (or was it Hugs?) definition of getContents
20:50:31 <sjanssen> it's arguable whether that is safe/unsafe
20:50:38 <zeeeeee> sorear: actually hGetContents
20:50:43 <zeeeeee> sorear: yeah i read that
20:50:51 <zeeeeee> sorear: but it's not giving me any insight
20:50:52 <SamB_XP> it isn't non-referentially-transparent, anyway
20:50:54 <sjanssen> what happens when getKey raises an exception?
20:51:13 <sorear> sjanssen: what happens when (/) raises an exception?
20:51:37 <sjanssen> sorear: (/) never raises exceptions
20:51:47 <SamB_XP> zeeeeee: well, it isn't safe if you hClose the handle you pass to hGetContents before the end is reached...
20:51:49 <Saizan> > 1/0
20:51:51 <lambdabot>  Infinity
20:51:51 <zeeeeee> sjanssen: div, then
20:51:53 <sjanssen> it's result may be _|_, but that's a different thing
20:52:11 <zeeeeee> sjanssen: *** Exception: divide by zero
20:52:12 <sjanssen> zeeeeee: same answer
20:52:19 <SamB_XP> or, oh, writeFile to a file before a readFile on the same file reaches the end, or something like that
20:52:43 <zeeeeee> sjanssen: there's a divide-by-zero exception in Control.Exception
20:53:29 <sjanssen> oh right
20:53:53 <sjanssen> well anyway, you can't catch the exception in pure code
20:54:00 <SamB_XP> sjanssen: "raises an exception OR doesn't return" and "returns _|_" are the same thing, if by "exception" you mean the kind in Control.Exception...
20:55:07 <sjanssen> SamB_XP: I thought exceptions you see in the IO monad were totally separate from _|_, but I was wrong
20:55:17 <SamB_XP> hehe
20:55:38 <SamB_XP> hmm, even H98 has exceptions in the IO monad...
20:55:44 <SamB_XP> lame ones though
20:55:46 <zeeeeee> sorear: anyway, are you saying that i can use unsafe* anywhere i please.
20:55:52 <zeeeeee> *?
20:55:59 <allbery_b> not really, no
20:56:04 <george> could anyone give me an example of replicateM say on a function double :: Int -> Int; double x = x * 2
20:56:06 <sjanssen> zeeeeee: definitely not
20:56:13 <sorear> sjannsen: there was a SPJaper declaring _|_ to mean a set of exceptions, possibly including nontermination, from which a representative was chosen by castch.
20:56:20 <SamB_XP> > unsafePerformIO (readFile "/etc/passwd")
20:56:31 <sorear> @botsnack
20:56:31 <lambdabot> :)
20:56:34 <SamB_XP> hmm.
20:56:35 <sjanssen> zeeeeee: did you know you can write "coerce :: a -> b" with unsafePerformIO + IORef?
20:56:36 <allbery_b> @go IO_inside
20:56:38 <lambdabot> http://haskell.org/haskellwiki/IO_inside
20:56:38 <lambdabot> Title: IO inside - HaskellWiki
20:56:44 <SamB_XP> > unsafePerformIO (readFile "/etc/passwd")
20:56:45 <lambdabot>   Not in scope: `unsafePerformIO'
20:56:54 <SamB_XP> okay. why didn't it say that the *first* time?
20:57:05 <Saizan> she wanted a snack
20:57:11 <zeeeeee> sjanssen: no idea, in fact i have no idea wtf IORef's are...which reminds me, it's time...
20:57:12 <SamB_XP> Why is lambdabot just dropping queries?
20:57:14 <allbery_b> read that to find out what IO really is, and why you need to use it (and get sonme idea of whenn it's safe to cheat)
20:57:22 <allbery_b> dunno, it's been doing that for a while
20:57:29 <allbery_b> I presume it's another bug :)
20:57:47 <SamB_XP> I would assume it was somehow intentional?
20:57:57 <sorear> lambdabot will not respond if flood control makes it wait more than 15 seconds.
20:58:01 <zeeeeee> is there any introductory material or primer to things ST, STRef, and/or IORef? the closest thing i could find is http://haskell.org/hawiki/ImperativeHaskell (mentioned in an old post in repsonse to the question i just re-posed)
20:58:01 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki
20:58:09 <sorear> I do not know if this is the problem we are seeing.
20:58:16 <SamB_XP> probably something like that...
20:58:27 <SamB_XP> I think the problem is that floodcontrol is global?
20:58:46 <sorear> SamB: flood control is server-side, so yes it's global.
20:58:55 <zeeeeee> allbery_b: ok, i'll take a look.
20:59:09 <SamB_XP> sorear: it would be possible for it to be done on a per-channel basis!
20:59:16 <sorear> (although to avoid pinging out lambdabot simulates the server flood controll and waits the same amount)
20:59:35 <SamB_XP> (though of course unfortunately the IRC spec says *otherwise*)
21:00:08 <sorear> I plan to give LB a @rat command for times like this. :)
21:00:58 <sorear> "joe:6 uses in last 15s sam:2uses ..."
21:02:06 <sjanssen> @where paste
21:02:15 <sorear> @paste
21:02:15 <lambdabot> http://paste.lisp.org/new/haskell
21:02:36 <sjanssen> what is lambdabot's problem lately?
21:02:43 <zeeeeee> allbery_b: wow, that was completely unhelpful
21:02:45 <zeeeeee> "But there is an even stranger operation called 'unsafeInterleaveIO' that gets the "official baton", makes its own pirate copy, and then runs an "illegal" relay-race in parallel with the main one! I can't talk further about its behavior without causing grief and indignation, so it's no surprise that this operation is widely used in countries that are hotbeds of software piracy such as Russia and China! ;) Don't even ask me - I won't say
21:02:45 <zeeeeee>  anything more about this dirty trick I use all the time ;)"
21:02:57 <SamB_XP> I don't think lambdabot should submit to the flood control
21:03:02 <lisppaste2> sjanssen pasted "fun error (hopefully)" at http://paste.lisp.org/display/34576
21:03:18 <allbery_b> yeh, I ddn't get that either.  I'm treating unsafeInterleaveIO as something not to be touched until I find out something more useful :)
21:03:21 <SamB_XP> lambdabot should petition freenode singlehandedly to rewrite the IRC spec to remove the problem
21:03:29 <allbery_b> but unsafePerformIO should be clarified a bit, at least
21:04:01 <zeeeeee> right! i guess that's why i'm here - does anybody actually understand it and how to use it? (or if there's another approach to writing getKeys?)
21:04:31 <sorear> zeeeeeee: sure.
21:04:42 <SamB_XP> zeeeeee: how many keys are there?
21:04:55 <george> using replicateM it works only in cases where the function takes 1 argument... is that correct? for example if i use double x = 2 * x ... then i can replicateM 5 double 2 and get a list of [4.4.4.4.4]... but if i make a function mult x y = x * y i cannot do replicateM 5 mult 3 2
21:04:56 <sorear> zeeeeeee: write a thread that reads keys and writes them to a Control.Concurrent.Chan, then use getChanContents.
21:05:06 <zeeeeee> sorear: hmmm!
21:05:10 <george> why do i get errors for the functions with 2 args and how should i use this?
21:05:11 <zeeeeee> SamB_XP: keys are just inputs from the user
21:05:12 <SamB_XP> sorear: that does about the same thing though
21:05:16 <SamB_XP> except more slowly
21:05:18 <zeeeeee> think getChar
21:05:24 <SamB_XP> or maybe more eagerly
21:05:27 <SamB_XP> or both!
21:05:43 <sorear> SamB_XP: yeah. but he wants to avoid uIIO at all costs, ....
21:06:04 <SamB_XP> ooh.
21:06:28 <zeeeeee> sorear: no, i want to understand it, and if it is indeed unwise to use it in this case, then avoid it
21:06:29 <SamB_XP> @hoogle unsafeInterleaveIO
21:06:39 <SamB_XP> @hoogle unsafeInterleaveIO
21:06:40 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
21:06:54 <sorear> george: OH! I thought you wanted to repeat an IO action!  use replicate 5 $ foo x y
21:07:08 <george> sorear, i do want to replicate an IO action
21:07:11 <SamB_XP> oh wait..
21:07:13 <SamB_XP> um.
21:07:14 <george> but i cant get it to work on non IO
21:07:20 <george> so im trying to do that first
21:07:24 <george> then ill make it work on IO
21:07:31 <sorear> > replicate 5 $ "foo" ++ "bar"
21:07:32 <lambdabot>  ["foobar","foobar","foobar","foobar","foobar"]
21:07:36 <SamB_XP> doesn't getChanContents *use* unsafeInterleaveIO?
21:07:42 <sorear> SamB_XP: yes.
21:08:02 <hype> http://kmwarren.imarichkid.hop.clickbank.net
21:08:02 <sorear> but at least he can shun the name.
21:08:03 <george> sorear, it is an io action eventually... i was just simplifying my query as i get the same error for IO and non IO
21:08:05 <lambdabot> Title: Ultimate Wealth Package
21:08:06 <zeeeeee> that's fine by me
21:08:08 <hype> oops
21:08:09 <george> i havent used replicateM before
21:08:13 <SamB_XP> hmm.
21:08:17 <zeeeeee> but my orig question still stands
21:08:34 <jewel> how is the haskell parser in GHC implemented, is it hand-written or generated by a tool?
21:08:41 <sorear> happy iirc
21:08:49 <sjanssen> george: what you want to replicateM is the action after all the arguments are applied
21:08:59 <george> yes
21:09:03 * SamB_XP wonders if he can use mfix and and MVar to write unsfafeInterleaveIO
21:09:03 <sjanssen> replicateM 10 (action arg1 arg2 arg3)
21:09:13 <george> gives me errors
21:09:16 <sorear> SamB_XP:
21:09:17 * sjanssen hopes he can't
21:09:24 <sorear> @src unsafeInterleaveIO
21:09:24 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
21:09:36 <sorear> oh sorry.
21:09:43 <sorear> I was thinking of
21:09:45 <sjanssen> dons is ornery
21:09:46 <sorear> @src fixIO
21:09:46 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:10:01 <SamB_XP> oh wait.
21:10:05 <sorear> sjanssen: ?
21:10:06 <george> sjanssen, i have tried this exact code with no luck
21:10:09 <SamB_XP> that will still run to the end won't it?
21:10:11 <SamB_XP> well.
21:10:26 <sjanssen> sorear: adding the defn. of unsafeInterleaveIO
21:10:32 <brad_> can someone give me a quick overview of String vs ByeString?
21:10:35 <sjanssen> or are they yanked by a script now?
21:10:50 <brad_> oops i mean ByteString
21:10:53 <SamB_XP> @src unsafePerformIO
21:10:54 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
21:11:05 <SamB_XP> @src seq
21:11:06 <lambdabot> Source not found. I feel much better now.
21:11:10 <sjanssen> brad_: String is lazy, has built in syntax, and has full Unicode support (there are no Unicode IO functions however)
21:11:16 <sjanssen> oh, and String is slow
21:11:23 <george> sjanssen, weird.... it does work if i do replicateM 10 (action arg1 arg2) arg3
21:11:25 <sorear> very slow
21:11:26 <george> any reason for that?
21:11:46 <sorear> george: you're using the (->) a monad.
21:12:01 <SamB_XP> @type replicate 10 (readFile "/etc/passwd")
21:12:02 <lambdabot> [IO String]
21:12:03 <sorear> george: the (->) a monad is very good at confusing people
21:12:04 <sjanssen> ByteString is either totally or partially strict, doesn't have nice syntax, can only represent chars from \0 to \255, but is blindingly fast
21:12:08 <SamB_XP> @type replicateM 10 (readFile "/etc/passwd")
21:12:09 <lambdabot> IO [String]
21:12:13 <brad_> so are there people who basically use ByteString in place of String?
21:12:21 <sorear> no
21:12:26 <SamB_XP> brad_: ???
21:12:28 <sorear> both have there place
21:12:47 <sorear> I use ByteString to mangle 10Gby of data in <30s
21:12:57 <sjanssen> brad_: use ByteString when you want to scale to largish datasets
21:12:58 <SamB_XP> "" isn't overloaded yet
21:13:02 <SamB_XP> and FilePath = String
21:13:31 <brad_> thanks guys, it sounds like ByteString is used when certain features of String impair performance
21:13:35 <brad_> thanks for the answer!
21:13:46 <sjanssen> brad_: nail on the head
21:14:01 <sorear> currently, ByteString scales poorly to short strings, <100 characters or so
21:14:15 * sorear plans to fix this
21:14:21 <brad_> sounds like for my use, String should suffice
21:14:25 <sjanssen> sorear: oh? what are your plans?
21:14:37 <brad_> my use so far being very trivial script-like code
21:14:55 <sorear> write Data.ByteString.Short, engineer a clever way of gc'ing strings, etc
21:15:36 <brad_> thanks again folks! have a good one. bye
21:15:39 <sjanssen> ah, problems because the ForeignPtr'd arrays aren't relocatable
21:16:04 * dons reappears :)
21:16:10 <dons> yay for free net at the airport ;)
21:16:14 <sorear> hi dons!
21:16:22 <dons> just applied your patch
21:16:32 <dons> is the bot stable enough to leave up for the next few days?
21:16:44 <dons> (without the last few patches you've sent?)
21:16:50 <sorear> probably
21:17:11 <zeeeeee> dons: hello
21:17:30 <dons> zeeeeee: re. unsafeInter* its used there to mimic a Chan
21:17:37 <sorear> it's not like it'll segfault or anything :)
21:17:38 <dons> i.e. to interleave getKey reading from one thread, with the main thread
21:17:46 <dons> sorear: thinking more about deadlocks :)
21:17:52 <dons> ?uptime
21:18:01 <dons> senor bot?
21:18:05 <hype> http://kmwarren.imarichkid.hop.clickbank.net
21:18:06 <allbery_b> there's that dropping commands thing again
21:18:12 <allbery_b> @bot
21:18:12 <lambdabot> :)
21:18:17 <dons> @uptime
21:18:17 <lambdabot> uptime: 21h 10m 8s, longest uptime: 1d 21h 16m 2s
21:18:22 <dons> ?uptime
21:18:22 <lambdabot> uptime: 21h 10m 13s, longest uptime: 1d 21h 16m 2s
21:18:32 <sorear> well, there's practically no locking, so data corruption maybe, deadlocks no way :)
21:18:35 <dons> yeah, so something's stil a bit iffy in the new thread set up
21:18:42 <allbery_b> seems like if it's been idle for a bit it ignores the first command you send it
21:18:48 <dons> mm. interesting.
21:18:55 <george> what is worse an IO [String] or and [IO String]
21:19:05 <dons> sorear: you want to look at that ? see if its reproducible?
21:19:09 <Korollary> they're different things
21:19:15 <allbery_b> depends on what you're going to do with it, but seqwuenmce will turn the latter into the former
21:19:15 <dons> george: [IO String] needs a bit more processing ;)
21:19:16 <sorear> that's like asking "which is better: Int or Integer"
21:19:17 <allbery_b> er
21:19:19 <allbery_b> sequence
21:19:22 <allbery_b> pretend I can type :)
21:19:23 <dons> its a list of actions, rather than an action that returns a list
21:19:48 <george> i was really expecting the output to be IO [String] which i can kinda deal with
21:19:51 <george> but compiler told me otherwise
21:19:59 <slava> how does one turn [IO String] into IO [String] ?
21:20:05 <allbery_b> <allbery_b> sequence
21:20:10 <allbery_b> :t sequence
21:20:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
21:20:18 <slava> ah.
21:20:41 <george> oh rather, how does one print in some form an [IO String]
21:20:55 <allbery_b> mapM_ putStrLn
21:21:06 <slava> :t mapM_
21:21:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
21:21:22 <slava> :t mapM
21:21:24 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
21:21:27 <dons> george: are you writing, say, map print
21:21:33 <dons> rather than mapM_ print ?
21:21:36 <dons> :t map print
21:21:37 <lambdabot> forall a. (Show a) => [a] -> [IO ()]
21:21:38 <slava> ah. mapM_ -vs- mapM is like each -vs- map in factor
21:21:43 <allbery_b> if you use mapM instead of mapM_) then you get back IO [()] which is kinda useless :)
21:21:49 <dons> slava: oh, that's interesting.
21:21:54 <dons> :t mapM
21:21:55 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
21:21:57 <dons> :t mapM_
21:21:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
21:21:59 <dons> :src mapM_
21:22:05 <dons> ?src mapM_
21:22:05 <lambdabot> mapM_ f as = sequence_ (map f as)
21:22:09 <dons> ?src mapM
21:22:09 <lambdabot> mapM f as = sequence (map f as)
21:22:14 <slava> heh
21:22:19 <dons> just lifts map, and sequences the actions
21:22:26 <dons> ?src sequence
21:22:27 <lambdabot> sequence ms = foldr k (return []) ms
21:22:27 <lambdabot>     where
21:22:27 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
21:22:41 <dons> ?src sequence_
21:22:42 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:22:49 <bos> do people use the ST monad much nowadays?
21:22:50 <slava> strict languages have separate mapping functions depending on if you want results or not
21:22:52 <dons> (bit simpler, since you can discard results on the way)
21:23:16 <dons> slava: ah yes, since you'll eval too much otherwise
21:23:23 <sorear> @quote formatting
21:23:23 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
21:23:28 <sjanssen> bos: I use it from time to time
21:24:03 <bos> i've got my brain around the State monad, and wonder where to go next.
21:24:10 <slava> arrows :)
21:24:42 <sorear> ST is good for brain-exploding.  If you only have one, you might want to study something else first.  Like topology.
21:24:51 <slava> dons: does the definition of mapM use all three monad laws?
21:24:51 <bos> heh, i'm sure there are other monads i could be investigating to beat some clue into myself before i hop on the kleisli train to arrow land.
21:25:13 <slava> dons: its interesting that it allows you 'pull back' through the list type
21:25:18 <george> i have tried map mapM and mapM_ print but nothing prints my horrible [IO String]
21:25:38 <sorear> mapM id ?
21:25:48 <bos> it looks like if i want to grok ST, i must read "lazy functional state threads", which is approx. 1000 pages long.
21:25:56 <dons> slava: hmm, mapM would use return and bind, I'd think
21:26:12 <slava> dons: yes, but it relies on the algebraic identities to do the right thing
21:26:30 <dons> to get the ordering/sequencing right?
21:26:38 <slava> dons: sorry, i'm thinking of sequence, not mapM
21:26:42 <slava> :t sequence
21:26:55 <dons> hmm, sorear, is the bot playing up? :)
21:26:58 <dons> :t sequence
21:26:59 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
21:27:23 <dons> yeah, from [] m a -> m [] a :)
21:27:26 <slava> is the existence of a function [m a] -> m [a] with a certain property enough to force that m obeys monad laws?
21:27:43 <bos> no.
21:27:57 <bos> that's the responsibility of whoever wrote m.
21:28:06 * dons has to catch the plane. ciao all!
21:28:11 <dons> Happy Hacking :)
21:28:16 <bos> happy flying!
21:28:21 * sorear waves goodbye
21:28:24 <mbishop> bon voyage!
21:28:32 <slava> bos: yes, but logically, the property posessed by the function [m a] -> m [a] could imply that m obeys the laws
21:29:04 <sorear> or, you could just encode m as a GADT and require proof tokens a la Appel's type of normalizable lambda calculus terms.
21:29:19 <allbery_b> I think it's more correct to say that said function works only given that m obeys those laws
21:29:33 <bos> slava: no.
21:29:57 <slava> you misunderstand what i'm saying. i'm not talking about the definition above
21:30:21 <slava> i'm wondering if there is an equivalent definition of a monad in terms of a function with the same type signature posessing a certain property
21:31:08 <slava> ie, if you can define a function [m a] -> m [a] that preserves certain structure, then m is a monad
21:31:21 <bos> slava: perhaps, but you're getting into oleg territory.
21:31:25 <slava> but if no such function exists, then one of the monad laws are not satisfied by m
21:31:30 <slava> never mind
21:31:48 <slava> this is more logic than haskell
21:31:51 <sorear> slava: yes.  (join,fmap,return) :: (m (m a) -> m a, a -> b -> m a -> m b, a -> m a) s.t.  join . join == join . fmap join , join . return == id ,  etc
21:34:54 <george> someone please follow some logic with me... if i replicate a function which returns IO String, i should expect an [IO String]. To print this, i map print... as print an IO String works... so map just prints each member of the list right?
21:35:29 <sorear> s/map/\&M/
21:35:51 <george> mapM?
21:36:28 <sorear> ghci> mapM print [1,2,3,4,5]
21:36:38 <Korollary> he said [IO String], though.
21:36:41 <zeeeeee> is there a hoogle set up for other code bases? (eg missingh)
21:36:59 <Korollary> You can't map print over [IO String]. The types don't match.
21:37:03 <zeeeeee> (hopefully not exclusive of the standard base lib)
21:37:06 <sorear> zeeeeee: hoogle 4 promises searching ALL the databases at once
21:37:15 <george> so what can i do to output this horrible data type?
21:37:24 <Korollary> you can sequence_ perhaps
21:37:29 <Korollary> ?type sequence_
21:37:31 <zeeeeee> sorear: nice
21:37:52 <sorear> ?type sequence_
21:37:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:38:04 <sorear> this is too weird
21:38:10 <Korollary> I have been ignored.
21:38:12 <zeeeeee> ?list
21:38:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:38:26 <zeeeeee> ?kind RealWorld
21:38:28 <lambdabot> Not in scope: type constructor or class `RealWorld'
21:38:47 <zeeeeee> ?hoogle a -> (a,a)
21:38:48 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
21:38:48 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
21:39:04 <notsmack> lambdabot's been dropping the ball lately...
21:39:08 <zeeeeee> ?hoogle [a] -> ([a],[a])
21:39:08 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
21:39:08 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
21:39:08 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
21:39:35 <zeeeeee> urgh...no standard 'tee'-like function
21:39:48 <sorear> tee?
21:39:49 <zeeeeee> oh my god, i cannot believe i said that
21:40:03 <zeeeeee> sorear: let let let
21:41:24 <mgsloan> perhaps keep in mind that ?hoogle only returns 3 results.
21:41:25 <allbery_b> <notserious> arrows </notyserious>
21:41:29 <mgsloan> ?where hoogle
21:41:30 <lambdabot> http://www.haskell.org/hoogle
21:41:39 <Saizan> someone has a tutorial on parsing a list-like xml to a list of records?
21:42:13 <george> if i get my [IO String]
21:42:21 <george> and do x <- [IO String]
21:42:26 <george> then x is of type [String] ?
21:42:30 <Saizan> no
21:43:13 <Saizan> if but if have xs :: [IO String] and you do xs' <- sequence xs then xs' is of type [String]
21:43:54 <Saizan> s/if but if/if you/
21:45:00 <george> ah ha !
21:45:08 <zeeeeee> dons: your link to http://www.scannedinavian.org/iohcc/succzeroth-2004/ is broken
21:45:52 <Saizan> (cause sequence xs if of type IO [String])
21:46:01 <notsmack> @src sequence
21:46:02 <lambdabot> sequence ms = foldr k (return []) ms
21:46:02 <lambdabot>     where
21:46:02 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
21:46:36 <zeeeeee> hm, i guess there's not much you can do about it
21:49:54 * notsmack can't wrap his head around that definition
21:50:10 <george> thanks for everyones hours of help tonight. =) has only taken me 12 hours to get this project near wrapped up
22:24:12 <brad_> can anyone help me understand unfoldr?
22:25:09 <allbery_b> ?src unfoldr
22:25:09 <lambdabot> unfoldr f b  = case f b of
22:25:09 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:25:09 <lambdabot>    Nothing        -> []
22:25:50 <brad_> that src command is neat
22:26:18 <brad_> tried to get "goa" to compile on my debian box to get something like that, couldn't quite get it to install
22:26:45 <allbery_b> you provide a base value and a function.  the function receives the current list (which starts out as the base) and returns Nothing if it's done, or Just (new_item, next_seed)
22:27:15 <allbery_b> new_item is added to the list and next_seed is passed to the next invocation of your function
22:27:44 <allbery_b> it is perhaps not the best way to build up a list but it works
22:28:08 <sjanssen> unfoldr has certain nice properties
22:28:14 <brad_> ah! i think i might get it...so it would recurse forever unless f had a case to resolve to Nothing...
22:28:38 <Cale> right
22:29:00 <Cale> > unfoldr (\x -> Just (x^2, x+1)) 0
22:29:22 <sjanssen> @BOTSNACK
22:29:22 <lambdabot> Unknown command, try @list
22:29:33 <Cale> huh
22:29:35 <sjanssen> > unfoldr (\x -> Just (x^2, x+1)) 0
22:29:37 <Cale> @run unfoldr (\x -> Just (x^2, x+1)) 0
22:29:37 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
22:29:38 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
22:29:45 <Cale> er, that's odd
22:29:55 <brad_> oh poop i actually typed that into ghci
22:30:02 <brad_> took a while for ctrl-c to stop that one
22:30:04 <Cale> Ctrl-C
22:30:07 <Cale> ah
22:30:41 <brad_> ?src unfoldr
22:30:42 <lambdabot> unfoldr f b  = case f b of
22:30:42 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:30:42 <lambdabot>    Nothing        -> []
22:31:13 <Cale> Personally, I prefer:  unfoldr' p f g = map f . takeWhile p . iterate g
22:31:26 <brad_> ?src iterate
22:31:26 <lambdabot> iterate f x =  x : iterate f (f x)
22:31:31 <Cale> which is equivalent, but breaks things down in a usually more convenient way
22:31:40 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
22:31:42 <lambdabot> Defined.
22:32:29 <Cale> > unfoldr' (const True) (^2) (+1) 0
22:32:31 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
22:32:58 <Cale> > unfoldr' (/= 0) (`mod` 10) (`div` 10) 473892110
22:32:59 <lambdabot>  [0,1,1,2,9,8,3,7,4]
22:33:57 <brad_> well thanks for the info on unfoldr! not sure i see myself using it, but i'm less ignorant
22:34:35 <Cale> It's not anywhere near as common as foldr
22:35:16 <brad_> thanks again and take care!
22:35:23 <Cale> Usually, writing things directly in terms of map, takeWhile and iterate is clearer
22:35:30 <Cale> yep :)
22:36:04 <sjanssen> maybe we just need this function: (a -> Bool) -> (a -> b) -> a -> Maybe b
22:36:48 <bd_> you mean (a -> Bool) -> (a -> b) -> a -> [b] ?
22:37:16 <sjanssen> @type \p f x -> if p x then Just (f x) else Nothing
22:37:16 <Cale> No, I get what he's saying -- such a function would be useful with the existing unfoldr
22:37:18 <lambdabot> forall t a. (t -> Bool) -> (t -> a) -> t -> Maybe a
22:37:40 <bd_> oh, I see
22:37:52 <sjanssen> @let magic p f x = if p x then Just (f x) else Nothing
22:37:54 <lambdabot> Defined.
22:38:17 <sjanssen> @pl \x -> (x^2, x+1)
22:38:18 <lambdabot> liftM2 (,) (^ 2) (1 +)
22:39:03 <sjanssen> @type unfoldr (magic (const True) (liftM2 (,) (^2) (1+))) 0
22:39:05 <lambdabot> Not in scope: `magic'
22:39:17 <sjanssen> > unfoldr (magic (const True) (liftM2 (,) (^2) (1+))) 0
22:39:18 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
22:39:38 <sjanssen> I've wished for magic several times
22:39:53 <sjanssen> no idea what to call it
22:41:35 <goltrpoat> magic being (b -> Bool) -> (a -> (a, a)) ? :)
22:42:04 <mad_phoenix> so... am i correct in seeing that the function signatures lots of tutorials use in this form ( [a] -> Integer ) is not valid?  i keep getting type errors in hugs & ghc
22:43:12 <Z4rd0Z> in http://haskell.org/haskellwiki/IO_inside, what is meant by creating a 'fake' parameter to a function?
22:43:13 <lambdabot> Title: IO inside - HaskellWiki
22:44:10 <iah> z4rd0z: the function never actually uses that parameter for anything
22:44:18 <sjanssen> @. pl djinn (a, b) -> (b, a)
22:44:18 <lambdabot> f = uncurry (flip (,))
22:44:54 <sjanssen> @let swap = uncurry (flip (,))
22:44:55 <lambdabot> Defined.
22:47:30 <OliverB__> mad_phoenix, That's fine - how are you using it?
22:48:19 <OliverB__> (That particular signature doesn't make much sense, but the syntax is fine...)
22:49:46 <sjanssen> > unfoldr (magic (/= 0) (swap . flip divMod 10)) 54321
22:49:47 <lambdabot>  [1,2,3,4,5]
22:51:15 <bd_> :t toMaybe
22:51:17 <lambdabot> Not in scope: `toMaybe'
22:51:28 <bd_> @let toMaybe p x = if p then Just x else Nothing -- maybe something like this would be more general?
22:51:29 <lambdabot> Defined.
22:51:46 <bd_> You can use it in the reader monad if you like
22:51:52 <bd_> :t liftM2 toMaybe
22:51:54 <lambdabot> Not in scope: `toMaybe'
22:51:57 <sjanssen> bd_: just pondering something like that myself
22:51:58 <bd_> aw
22:51:59 <allbery_b> @hoogle (a -> Bool) -> a -> Maybe a
22:52:00 <lambdabot> No matches, try a more general search
22:52:21 <bd_> :t let toMaybe p x = if p then Just x else Nothing in liftM2 toMaybe
22:52:22 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (Maybe a2)
22:52:30 <bd_> :)
22:52:51 <bd_> > unfoldr (liftM2 toMaybe (/= 0) (swap . flip divMod 10)) 54321
22:52:52 <lambdabot>  [1,2,3,4,5]
22:53:49 <Z4rd0Z> this lambdabot is cool, is it documented anywhere what commands you can give to it?
22:54:05 <iah> @list
22:54:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:54:28 <Z4rd0Z> cool
22:55:01 <sjanssen> ooh, how about (Monad m) => Bool -> a -> m a
22:55:36 <bd_> MonadPlus? or just use fail?
22:55:38 <sjanssen> @type \p x -> if p then return x else mzero
22:55:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> a -> m a
22:55:41 <ttmrichter> @list
22:55:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:55:52 <goltrpoat> @pl (`rem` 10) &&& (`quot` 10)
22:55:53 <lambdabot> (`rem` 10) &&& (`quot` 10)
22:55:56 <sjanssen> bd_: isn't that always the question? :)
22:55:58 <goltrpoat> er.
22:55:59 <bd_> @type \p x -> if p then return x else fail "thingy"
22:56:00 <sjanssen> grrr fail
22:56:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => Bool -> a -> m a
22:56:25 <sjanssen> @type Control.Monad.when
22:56:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:57:15 <bd_> @pl \p x -> guard p >> return x
22:57:16 <lambdabot> (. return) . (>>) . guard
22:57:36 <sjanssen> what is the name of this function?
22:57:50 <sjanssen> guardReturn?
22:57:59 <sjanssen> returnIf?
22:59:18 <sjanssen> @type unfoldr (\x -> guard (x /= 0) >> return (x^2, x+1)) 0
22:59:20 <lambdabot> forall b. (Num b) => [b]
22:59:27 <sjanssen> > unfoldr (\x -> guard (x /= 0) >> return (x^2, x+1)) 0
22:59:28 <lambdabot>  []
23:00:33 <sjanssen> > unfoldr (\x -> guard (x < 5) >> return (x^2, x+1)) 0
23:00:34 <lambdabot>  [0,1,4,9,16]
23:01:55 <sjanssen> Cale: ^^^
23:02:26 <iah> :t unfoldr
23:02:27 <Cale> right
23:02:28 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
23:03:05 <sjanssen> that's about as nice as unfoldr'
23:03:24 <sjanssen> it gets quite ugly when you pointfree it, however
23:03:49 <goltrpoat> to wit:
23:03:51 <goltrpoat> @pl \k -> guard (k /= 0) >> Just (rem k 10, quot k 10)
23:03:51 <lambdabot> ap ((>>) . guard . (0 /=)) (Just . ap ((,) . flip rem 10) (flip quot 10))
23:08:06 <mgsloan> @. unpl pl \k -> guard (k /= 0) >> Just (rem k 10, quot k 10)
23:08:07 <lambdabot> ((\ p -> (>>) (guard (0 /= p))) >>= \ i -> (\ v -> (Just) (((\ ae -> ((,)) (rem ae 10)) >>= \ x -> (\ g -> quot g 10) >>= \ w -> return (x w)) v)) >>= \ h -> return (i h))
23:08:12 <mgsloan> oh no!
23:08:19 <lisppaste2> zeeeeee pasted "help, how do i fix this simple type error? i'm just not seeing it...." at http://paste.lisp.org/display/34583
23:09:09 * sjanssen saves this log and makes a note to write a wiki page about this
23:09:17 <zeeeeee> sorry, let me fix that - that wasn't the error
23:11:31 <sjanssen> mgsloan: mix a @redo in there and you're in obfuscation heaven
23:11:49 <allbery_b> yaaak!
23:11:51 <mgsloan> good idea
23:12:19 <mgsloan> @. redo . unpl pl \k -> guard (k /= 0) >> Just (rem k 10, quot k 10)
23:12:20 <lambdabot> (do { i <- (\ p -> (>>) (guard (0 /= p))); h <- (\ v -> (Just) ((do { x <- (\ ae -> ((,)) (rem ae 10)); w <- (\ g -> quot g 10); return (x w)}) v)); return (i h)})
23:12:28 <goltrpoat> no no
23:12:30 <iah> zeeeeee: every line in a do statement has to be in the same monad
23:12:39 <goltrpoat> @redo ((\ p -> (>>) (guard (0 /= p))) >>= \ i -> (\ v -> (Just) (((\ ae -> ((,)) (rem ae 10)) >>= \ x -> (\ g -> quot g 10) >>= \ w -> return (x w)) v)) >>= \ h -> return (i h))
23:12:39 <lambdabot> (do { i <- (\ p -> (>>) (guard (0 /= p))); h <- (\ v -> (Just) ((do { x <- (\ ae -> ((,)) (rem ae 10)); w <- (\ g -> quot g 10); return (x w)}) v)); return (i h)})
23:12:57 <zeeeeee> iah: yeah, that wasn't the error of interest ... that was the result of me trying to create a minimal code snippet
23:12:58 <mgsloan> same thing - i chained 3 LB commands in one
23:13:08 <iah> zeeeeee: oh, ok
23:13:09 <goltrpoat> oh sorry, missed that
23:13:27 <mgsloan> yeah, i'm decent at LB composition foo
23:13:44 <allbery_b> looks to me like @redo just punted :)
23:13:55 <allbery_b> (and I for one can't blame it :)
23:14:03 <goltrpoat> haha
23:14:58 <sjanssen> allbery_b: @redo changed a handful of things
23:15:02 <lisppaste2> zeeeeee annotated #34583 with "here's the actual type error, any help appreciated" at http://paste.lisp.org/display/34583#1
23:15:13 <sjanssen> you need to work on your line noise reading skills :)
23:15:15 <mgsloan> yeah, shortened it a bit
23:16:00 <zeeeeee> i've been trying to fix that for way too long
23:17:49 <mgsloan> :t Control.Concurrent.writeChan
23:17:51 <lambdabot> forall a. Control.Concurrent.Chan.Chan a -> a -> IO ()
23:18:00 <Cale> zeeeeee: what's the type of getEvent?
23:18:17 <zeeeeee> Cale: IO Event
23:19:15 <Cale> hmm
23:20:48 <zeeeeee> fuck.
23:21:13 <zeeeeee> data Vty = Vty { ... getEvent :: IO Event ... }
23:21:35 <Cale> So getEvent in this context is a function Vty -> IO Event
23:21:39 <zeeeeee> aye
23:22:11 <zeeeeee> but that error message still makes no sense to me
23:22:35 <zeeeeee> shouldn't it be something like inferred type: Vty -> IO Event, expected type: IO Event or some such?
23:23:20 <Cale> Doesn't make too much sense to me either, but perhaps it's treating the do-block partially as if it's the ((->) Vty) monad.
23:23:37 <Cale> since you put a function from Vty's on the right side of an <-
23:24:11 <Cale> does it work when you pass the vt down?
23:24:30 <zeeeeee> Cale: yeap
23:24:34 <zeeeeee> thanks
23:24:38 <Cale> well, all right :)
23:25:40 <mgsloan> that's something that always confuses me with do blocks - which monad its doing
23:37:20 <Cale> mgsloan: In a working program, it's always going to be the same monad throughout.
23:37:40 <Cale> So the easiest way to tell is just to look at one of the actions in the block and figure out its type.
23:37:43 <mgsloan> I know that, sometimes it is unclear which though
23:37:44 <mgsloan> yeah
23:38:14 <mgsloan> the problem is at its worst with nested dos, and monad transformers and such..
23:41:43 <manveru> hello guys
23:42:06 <manveru> i'm just starting with haskell today and thought i'd try that irc-bot tutorial
23:42:09 <zeeeeee> hm, it would be nifty if one could apply guards on records
23:42:12 <zeeeeee> er, record updates
23:42:34 <manveru> i'd really appreciate if someone could help me on some stupid errors i get :)
23:42:48 <lisppaste2> manveru pasted "Roll your own IRC bot, gone wrong" at http://paste.lisp.org/display/34584
23:43:29 <lisppaste2> manveru annotated #34584 with "the actual exceptions" at http://paste.lisp.org/display/34584#1
23:44:28 <iah> manvery: looks like you just need to import some more things
23:44:32 <iah> ?hoogle isPrefixOf
23:44:33 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
23:44:41 <iah> ?hoogle exitWith
23:44:41 <lambdabot> System.exitWith :: ExitCode -> IO a
23:44:48 <manveru> oh
23:44:52 <iah> ?hoogle ExitSuccess
23:44:52 <lambdabot> System.Exit.ExitSuccess :: ExitCode
23:44:58 <manveru> thank you :)
23:45:08 <iah> manveru: you're welcome!
23:45:35 <manveru> i really like that import...
23:45:46 <manveru> you just require single functions as you need them?
23:45:55 <iah> you can say
23:46:02 <iah> import List ( isPrefixOf )
23:46:13 <iah> which just imports isPrefixOf
23:46:15 <iah> or
23:46:16 <iah> import List
23:46:21 <iah> which imports everything in the List module
23:47:04 <manveru> alright
23:47:15 <manveru> so all i need to do now is write a privmsg function
23:47:24 * manveru tries
23:49:58 <manveru> interesting
23:50:37 <manveru> guess haskell excels at being different than every other language :P
23:54:42 <zeeeeee> ?pl do get
23:54:43 <lambdabot> do get
23:54:55 <bd_> it's already point-free :)
23:55:01 <zeeeeee> is there a ?pl in ghci
23:55:23 <bd_> zeeeeee: I think there's a way to integrate lambdabot into ghci, actually, but it might require hs-plugins
23:55:57 <zeeeeee> ?pl forM [0..] $ \i -> do { modify (+i); get }
23:55:57 <lambdabot> (line 1, column 23):
23:55:58 <lambdabot> unexpected "{"
23:55:58 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
23:56:32 <vincenz> @. pl undo forM [0..] $ \i -> do { modify(+i); get}
23:56:33 <lambdabot> forM [0..] ((>> get) . modify . (+))
23:57:04 <zeeeeee> vincenz!
23:57:26 <vincenz> hello
23:57:40 <manveru> hmm
23:58:19 <manveru> is there any tutorial for people coming from ruby? :)
23:58:24 <manveru> or smalltalk...
23:58:41 <zeeeeee> manveru: there's a tut for c programmers
23:58:46 <zeeeeee> i don't remember it being very good
23:58:52 * manveru doesn't know C
23:59:02 <zeeeeee> manveru: well, it's similar enough to ruby and smalltalk :)
23:59:03 <manveru> well, at least not enough to write something :)
23:59:13 <zeeeeee> manveru: relatively speaking...
23:59:16 <manveru> that i've seen :)
23:59:33 <mbishop> I wish I didn't know C
23:59:33 <mbishop> ;/
23:59:41 <manveru> it's totally twisting my brain
23:59:50 <zeeeeee> mbishop: be nice
23:59:54 <iah> C is useful sometimes
23:59:59 <manveru> :P
