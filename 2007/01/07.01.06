00:00:13 <calvins_> JKnecht: is your nick named after joseph knecht of 'the glass bead game'?
00:00:26 <treitter> sorear: ..do you mean Virtual Machine or Virtual Memory?
00:00:35 <sorear> Virtual Memory
00:00:49 <treitter> hah.. I was about to say "What OS doesn't have virtual memory..?"
00:00:52 <sorear> Linux, Win98, WinNT, MacOS >=7, etc
00:00:56 <treitter> I guess embedded systems
00:01:13 <sorear> DOS, MacOS <=6,
00:01:27 <treitter> but that'd more likely be due to the hardware connected, I'd think. Unless it's some obscure OS
00:01:36 <sorear> although I'll be suprised to learn of Haskell on those OS's
00:01:49 <treitter> sorear: yeah. I wouldn't expect someone would port it :)
00:01:55 <monochrom> PDA
00:02:07 <treitter> monochrom: yeah
00:02:56 <sorear> > 2 ^ 2048 :: LargeKey Word2048 Word2048
00:02:57 <lambdabot>   Not in scope: type constructor or class `LargeKey'
00:04:59 <timthelion> hey, I don't want to use ghci because it won't let me use the backspace or arrow keys, and hugs does not do toUpper or isLower. how do I make hugs work with these things
00:05:32 <dons> hmm?
00:05:39 <dons> backspace or arrow? you don't have a readline?
00:05:48 <dons> :m + Data.Char (btw)
00:05:53 <timthelion> in ghci I can type
00:05:55 <Cale> :also Data.Char
00:05:59 <dons> sounds like your ghci is broken
00:06:02 <timthelion> but no backspace it does the ^ chars
00:06:04 <dons> with a missing readline
00:06:21 <Cale> timthelion: which platform?
00:06:24 <sorear> Control-H or Control-? -- one of those should work
00:06:36 <sorear> (for backspace)
00:06:41 <timthelion> freebsd
00:07:03 <sorear> ouch
00:07:27 <timthelion> ouch what?
00:07:44 <goltrpoat> heh, this is cute:
00:07:44 <Cale> Didn't we have someone else in here on freebsd with the same problem?
00:07:46 <goltrpoat> :t join . mapM
00:07:48 <lambdabot> forall a b. (a -> [a] -> b) -> [a] -> [b]
00:07:50 <Cale> Or was that also you?
00:07:54 <goltrpoat> > (join . mapM) (\k -> map (* k)) [1..5]
00:07:55 <lambdabot>  [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]
00:07:59 <timthelion> ghci>screen>urxvt>stumpwm>x>freebsd
00:08:12 <timthelion> no I have never come with this problem
00:08:29 <Cale> okay
00:08:40 <Cale> and you got your ghc from ports?
00:08:44 <sorear> uh, WM is an ordinary client, it's not between urxvt and X in any way ?
00:09:03 <timthelion> yes
00:09:05 <bos> sorear: i see that genericserialize is your baby :-)
00:10:15 <sorear> bos: yes, mostly abandoned ... anyway its niche is compatibility, if you can choose your data format FooBinary, DrIFT, or SerTH should be better in every way
00:10:37 <timthelion> oh wait, I LOVE foldr!! and I have only been learning haskel for hours
00:11:02 <dibblego> @remember timthelion oh wait, I LOVE foldr!! and I have only been learning haskel for hours
00:11:02 <lambdabot> Done memoising quote for `timthelion', if that is their real name...
00:12:04 <dons> timthelion, yeah, on freebsd there's a bug in the build system meaning readline isn't linked (the freebsd ports build system)
00:12:06 <goltrpoat> the join . mapM trick is fair, apparently:
00:12:08 <goltrpoat> > (take 5 . map (take 5)) $ (join . mapM) (\k -> map (* k)) [1..]
00:12:09 <lambdabot>  [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]
00:12:11 <dons> now, someone is working on it
00:12:17 <goltrpoat> anyway, thought that was kind of cool.
00:12:39 <Cale> dons: do you know whether the build is good enough to compile ghc yourself?
00:14:05 <Cale> (and get proper readline support)
00:14:15 <dons> Cale, yeah, I think there was a patch mentioned to haskell@
00:14:19 <dons> by who? was it bd_?
00:15:44 <dons> #haskell is my IDE
00:17:56 <Excedrin> http://www.froglingo.com/frog-sigmod.pdf Has anyone read this? It claims ML/Haskell/Prolog are less "productive" than Java, but HaskellDB is more productive
00:18:42 <Excedrin> I don't really understand the criteria
00:18:50 <goltrpoat> oookay
00:19:59 <dons> timthelion: allbery_b was working on the freebsd port , http://www.haskell.org/pipermail/haskell/2006-December/018954.html
00:20:01 <lambdabot> Title: [Haskell] ghci readline support on FreeBSD: simple patch, http://tinyurl.com/voexf
00:20:19 <goltrpoat> excedrin:  is that in the context of db programming?
00:21:51 <koe> for some reason i'm having a lot of trouble with this:
00:21:57 <Excedrin> goltrpoat: yes
00:22:14 <koe> i need to multiply a Double and an Int, getting Double precision in the process and returning an Int.
00:22:25 <Excedrin> sort of
00:23:00 <dons> > fromIntegral $ (pi :: Double) * fromIntegral (7 :: Int)
00:23:01 <lambdabot>   add an instance declaration for (Integral Double)
00:23:04 <mauke> @type \a b -> round (a * fromIntegral b)
00:23:06 <lambdabot> forall b a b1. (Integral b1, RealFrac b, Integral a) => b -> a -> b1
00:23:08 <goltrpoat> > let n = 5::Int; x = sqrt(2) :: Double in round (x * (fromIntegral n))
00:23:09 <lambdabot>  7
00:23:29 <Cale> Excedrin: how old is it?
00:24:12 <Excedrin> submitted to SIGMOD 2006
00:24:57 <Excedrin> there's also a talk from 2006 May 19th
00:25:19 <koe> that's the ticket, mauke/goltrpoat...
00:26:38 <mauke> @let convert a = toEnum (fromEnum a)
00:26:39 <lambdabot> Defined.
00:27:51 <mauke> > convert (convert (5 :: Int) * sqrt 2)) :: Int
00:27:52 <lambdabot>  Parse error
00:28:03 <mauke> > convert (convert (5 :: Int) * sqrt 2) :: Int
00:28:04 <lambdabot>  7
00:28:18 <sorear> ?spell received
00:28:19 <lambdabot> received
00:28:39 <dons> i before e except after c
00:28:51 <vincenz> ?
00:29:27 <vincenz> dons: where can I find the stats?
00:31:00 <sorear> ?where stats
00:31:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:31:12 <vincenz> Thank you
00:31:32 <vincenz> Gah, I'm seriously dropping
00:32:54 <timthelion> foldr (:isUpper) True ["a","B","C","d","e"] should this not return True : False : True :True : False : False ?
00:33:01 <sorear> dons: what is the function of all the Maybes in the types of the message sending routines?
00:33:02 <timthelion> it fails
00:33:22 <vincenz> timthelion: you want [True]
00:33:27 <vincenz> erm wait no
00:33:34 <sorear> > map isUpper ['a', 'B', 'C', 'd', 'e']
00:33:34 <vincenz> timthelion: you never end the list, however
00:33:35 <lambdabot>  [False,True,True,False,False]
00:33:53 <sorear> > foldr ((:) . isUpper) ['a', 'B', 'C', 'd', 'e']
00:33:54 <lambdabot>  Couldn't match `Bool' against `Char'
00:34:05 <goltrpoat> foldr ((:) . isUpper) [True] "aBCde"
00:34:05 <vincenz> > foldl (((:) .). isUpper) [] ["a", "b" "C", "d", "e"]
00:34:06 <goltrpoat> maybe
00:34:06 <lambdabot>  Couldn't match `a -> b' against `Bool'
00:34:13 <goltrpoat> > foldr ((:) . isUpper) [True] "aBCde"
00:34:14 <lambdabot>  [False,True,True,False,False,True]
00:34:23 <vincenz> goltrpoat+
00:34:25 <vincenz> +
00:34:31 <kzm_> Anybody know how to use Control.Concurrent.Strategies?
00:35:07 <sorear> nope
00:35:10 <timthelion> what is the .?
00:35:18 <vincenz> timthelion: function composition
00:35:24 <timthelion> ah
00:35:34 <kzm_> (f . g) x == f (g x)
00:35:37 <timthelion> so that is like making a symbol in lisp
00:35:51 <timthelion> ok
00:35:54 <vincenz> (:) . isUpper ===  \x -> (:) (isUpper x) === \x y -> (:) (isUpper x) y === \x y -> (isUpper x):y
00:36:38 <dons> sorear: Nothing indicates no output is to be printed (which is needed to flush the readline mode)
00:37:03 <cybercobra> can anyone explain what a uniqueness type is?
00:37:32 <dibblego> https://projects.workingmouse.com/build/jar/branches/scala/
00:37:34 <dibblego> oops
00:37:36 <dibblego> sorry
00:38:10 <dons> cybercobra: its a type system extension used in Clean (among other places) where a type indicates (if I recall correctly) that a variable is used only once, this can be used to force an ordering of code, in order to sequence side effects, as we do in Haskell with monads.
00:40:48 <cybercobra> dons: so, for instance, i/o could work by something like  readline(afile) => lineRead, diff_file_instance  ?
00:41:12 <cybercobra> dons: and then afile can never be used again
00:42:02 <dons> I've not used Clean enough to know if it is visible to the user . maybe the uniquness tricks are hidden, like the IO monad workings are hidden
00:42:20 <dons> I'm pretty sure you can just create normal Clean variables though, which are resuable. :)
00:42:57 <goltrpoat> cybercobra:  http://homepages.inf.ed.ac.uk/wadler/papers/linearuse/linearuse.ps may help
00:43:00 <lambdabot> http://tinyurl.com/unmmj
00:43:27 <Excedrin> the type of a function indicates if it takes a unique variable
00:43:36 <cybercobra> dons: thanks, just trying to get a handle on what they are. wikipedia's entry is woefully sparse
00:43:56 <dons> Excedrin: ah, so it is user-visible?
00:44:16 <goltrpoat> cybercobra:  oh.. did you read http://en.wikipedia.org/wiki/Linear_logic ?
00:44:48 <cybercobra> goltrpoat: no. reading...
00:46:45 <Excedrin> dons: yes, a unique type is prefixed with *
00:47:45 <dons> ah ok. that's what those thingies are :)
00:48:51 <cybercobra> donam, goltrpoat, dons: thanks
00:56:33 <vincenz> A new term : child monads
01:14:33 <shankys_> For people that use Emacs with Haskell, does anyone know how to get the type to display for things that aren't defined in the Prelude (i.e. stuff that you define yourself)? I know I could write the emacs lisp to do it, but I'm wondering if someone has already solved this problem?
01:16:25 <goltrpoat> haha "I'm not so interested in showing off clever Haskell programming idioms for doing nothing"
01:16:50 <goltrpoat> what WOULD those clever idioms be, anyway
01:17:02 <goltrpoat> mapM_ id [] ? :)
01:18:37 <integral> s/id/return/ surely.
01:19:01 <goltrpoat> id works
01:19:12 <goltrpoat> [] just gets a weirder type than needed
01:20:50 <goltrpoat> ooh.  coinductive ways of doing nothing.  a) let there be ways of doing nothing.  b) given a list of ways of doing nothing, a new way of doing nothing can be produced by passing that list to sequence_
01:20:56 <integral> :t \x -> mapM_ id x
01:20:58 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m ()
01:21:05 <integral> ah
01:22:58 <goltrpoat> :t mapM_ undefined []
01:23:00 <goltrpoat> also works :)
01:23:00 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
01:27:54 <paolino> good morning, how I scale a matrix row ? I made this
01:27:55 <paolino> scaleRow matrix row k = let
01:27:55 <paolino>   ((c0,_),(c1,_)) = bounds matrix in
01:27:55 <paolino>   matrix // [((i,row),matrix ! (i,row) * k)| i <- [c0..c1]]
01:27:55 <paolino> which is working but I feel it's not the *right* way
01:28:51 <Cale> > runListT (ListT [1])
01:28:52 <lambdabot> Terminated
01:29:13 <Cale> dons: why does it report Terminated rather than some more useful error?
01:29:51 <goltrpoat> > runListT (ListT [[1]])
01:29:52 <lambdabot> Terminated
01:29:57 <goltrpoat> eh.
01:30:35 <goltrpoat> ghci seems to like it.
01:38:36 <Cale> The only reason that might fail is that we don't have Control.Monad.List
01:38:48 <Cale> but in that case, it should say that runListT is out of scope
01:42:10 <goltrpoat> paolino:  what about scaleRow matrix row k = let ((c0,_), (c1,_)) = bounds matrix in accum (*) matrix [((n,row), k) | n <- [c0..c1]] or some such
01:42:21 <Syzygy-> ?index runListT
01:42:21 <lambdabot> Control.Monad.List
01:42:53 <Syzygy-> *Brackets Control.Monad.List> runListT (ListT [[1]])
01:42:53 <Syzygy-> [[1]]
01:43:38 <Cale> let a = ListT [[1,1]]; f x = ListT [[x],[10+x]] ; g x = ListT [[x],[100+x]] in runListT ((a >>= f) >>= g) == runListT (a >>= (\x -> f x >>= g))
01:45:32 <paolino> goltrpoat: thanks, I was not understanding the use of accum, now I see
01:46:36 <Cale> (That's basically a proof that ListT is not a monad transformer)
01:47:37 <goltrpoat> cale:  oh nice
02:01:23 <Syzygy-> Cale: Does it help anywhere that you can sort the lists and then get equality?
02:01:43 <Cale> well, yeah
02:02:08 <Cale> If they were sets and not lists, we'd be okay
02:02:13 <Heffalump> or bags, right?
02:02:18 <Cale> or bags, sure
02:02:22 <Syzygy-> What's a bag?
02:02:27 <Cale> a multiset
02:02:31 <Syzygy-> Oh. ,ok.
02:03:20 <Syzygy-> (grmblgrmbl why switch names on something perfectly well named in the first place grmblgrmbl)
02:09:40 <vincenz> a bag is a collection :D
02:09:53 <vincenz> the most generic thing ever
02:09:55 <vincenz> cause multiset...
02:09:56 <vincenz> heh
02:10:00 <vincenz> that's so meaningless
02:10:15 <vincenz> "oh yes we're a set, but no, we allow multiple occurences"
02:31:33 <kzm_> type Bag a = Map a Int
02:31:55 <kzm_> well - and some slightly modified operations, I guess.
02:42:21 <paolino> transformRow matrix row f = let
02:42:22 <paolino>   ((c0,_),(c1,_)) = bounds matrix in
02:42:22 <paolino>   accum (\e _ -> f e) matrix (zip (rowIndeces matrix row) (repeat undefined))
02:42:22 <paolino> Is that a natural way to fake the first arg of accum ?
02:42:22 <paolino> @type accum
02:42:24 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
02:44:35 <paolino>  where rowIndeces matrix row =  [(i,row) | i <- [c0..c1]]
02:45:46 <dons> mmm, now joelr's taking on erlang :} http://programming.reddit.com/goto?id=x64j
02:45:49 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
02:48:18 <dons> Cale, got it:
02:48:19 <dons>     Ambiguous occurrence `ListT'
02:48:19 <dons>     It could refer to either `Control.Monad.List.ListT', imported from Control.Monad.List at /tmp/MqOefY4643.hs:38:0-24
02:48:22 <dons>                           or `Language.Haskell.TH.Syntax.ListT'
02:48:32 <dons> I'll fix this in the morning (disable TH again)
03:00:30 <xic> are there haddock docs for ghc api?
03:04:32 <paolino> dons, (on joelr) I believe anyone is unpatient should go with java and become a satisfied bitslave
03:05:35 <dons> > runListT (ListT [[1]]) -- Cale
03:05:36 <lambdabot>  [[1]]
03:10:05 <xic> @hoogle TypeRep
03:10:06 <lambdabot> Data.Typeable.TypeRep :: data TypeRep
03:10:07 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
03:10:07 <lambdabot> Data.Typeable.typeRepTyCon :: TypeRep -> TyCon
03:19:17 <xic> @hoogle Type
03:19:18 <lambdabot> Network.Socket.Type :: SocketOption
03:19:19 <lambdabot> Language.Haskell.TH.Type :: data Type
03:19:19 <lambdabot> Prelude.type :: keyword
03:24:53 <xic> > let f x = case x of Nothing -> "n"; Just _ -> "j" in Nothing
03:24:54 <lambdabot>  Add a type signature
03:25:06 <xic> > let f x = case x of Nothing -> "n"; Just _ -> "j" in Just 'a'
03:25:07 <lambdabot>  Just 'a'
03:25:16 <xic> > let f x = case x of Nothing -> "n"; Just _ -> "j" in f Nothing
03:25:17 <lambdabot>  "n"
03:25:23 <xic> > let f x = case x of Nothing -> "n"; Just _ -> "j" in f (Just ())
03:25:25 <lambdabot>  "j"
03:48:25 <swiert> Any haskellwiki guru's around?
03:48:33 <swiert> I can't seem to upload a file.
03:51:38 <dons> oh?
03:52:26 <swiert> Maybe I'm just impatient...
03:52:50 <dons> so you clicked on http://haskell.org/haskellwiki/Special:Upload
03:52:52 <lambdabot> Title: Error
03:53:18 <swiert> Yep. I'm logged in.
03:53:34 <swiert> Once I select the file I want to upload, and hit the button, nothing seems to happen.
03:53:34 <dons> ok that should be all that is needed
03:53:49 <dons> you set the source and destintation?
03:54:02 <swiert> Yes.
03:54:19 <swiert> Let me try a different browser...
03:55:08 <matthew-_> OTOH, there's certainly an arguement for "if it doesn't work in links or lynx, it should be rewritten..."
03:55:39 <dons> I've only ever tried this in w3m, and it seems to work :)
03:56:09 <dons> MediaWiki seems to be very w3m/txt-mode friendly
03:56:49 <dons> ?users
03:56:50 <lambdabot> Maximum users seen in #haskell: 296, currently: 268 (90.5%), active: 19 (7.1%)
03:56:56 <swiert> Firefox says "The connection was reset"
03:57:05 <dons> weird..
03:57:11 <dons> let me try uploading something
03:58:45 <dons> Upload file
03:58:46 <dons> Successful upload
03:58:50 <dons> (from w3m)
04:01:18 <ski> morning #haskell
04:01:26 <astrolabe> morning ski
04:02:40 <dons> kzm, have you seen: http://www.aber.ac.uk/compsci/Research/bio/dss/polyfarm/ (genome stuff?)
04:02:42 <lambdabot> Title: PolyFARM
04:06:42 <dons> "The downside is that when I
04:06:42 <dons> went back to work coding in C++, I'd see a one line solution in Haskell and would have no way to
04:06:45 <dons> translate that to C++.
04:06:47 <dons>  
04:06:50 <dons> "
04:07:27 <swiert> dons: Hmm strange.
04:09:37 <OliverB> I've got a header file full of Haskell-ish string manipulation functions concat, intersperse, lines,  etc. in C++ at work :)
04:10:14 <dons> hehe :)
04:18:12 <xpika> @let blas = unwords.intersperse "bloody".words
04:18:13 <lambdabot> Defined.
04:18:31 <xpika> > L.blas "this car won't start"
04:18:32 <lambdabot>  "this bloody car bloody won't bloody start"
04:22:19 <thartman> I'm trying to install regex.pcre. (first time using cabal)
04:23:44 <chr1s> hey all!
04:23:48 <thartman> ./setup configure tells me I need pcre base, so I downloaded that -- darcs get --partial http://darcs.haskell.org/packages/regex-base
04:23:50 <lambdabot> Title: Index of /packages/regex-base
04:23:54 <kfish> xpika, bloody oath!
04:24:07 <chr1s> what's the best way to run a profiler on my application
04:24:13 <chr1s> I'm using GHC :)
04:25:43 <matthew-_> chr1s : compile with  -auto-all -prof run with +RTS -P
04:26:26 <thartman> then in regex base, stuck
04:26:27 <thartman>  
04:26:34 <thartman> ~/regex-base$ make
04:26:34 <thartman> Makefile:2: ../mk/boilerplate.mk: No such file or directory
04:28:59 <chr1s> matthew-_: cool, thanks!
04:29:07 <xpika> mathew do i have to install anything
04:29:13 <xpika> to get that to work
04:29:23 <xpika> other than ghc 6.6
04:30:14 <matthew-_> err, I dunno I'm afraid. I just apt-get install ghc stuff and it tends to work... ;-)
04:31:02 <matthew-_> there's documentation on profiling on the wiki I believe
04:31:05 <xpika>  Failed to load interface for `Prelude':
04:31:05 <xpika>       Perhaps you haven't installed the profiling libraries for package base?
04:31:19 <matthew-_> ahh, then you'll need a prof package.
04:31:33 <xpika> @where profile
04:31:34 <lambdabot> I know nothing about profile.
04:31:38 <xpika> @where profiling
04:31:39 <lambdabot> I know nothing about profiling.
04:34:29 <astrolabe> The ghc documentation is pretty good on profiling
04:35:04 <matthew-_> mmm. so man ghc contains the profiling options, and I seem to have the ghc6-prof package installed, which contains the profiling libraries.
04:35:14 <quazimodo> HI KIDS
04:35:16 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
04:35:18 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
04:35:19 <quazimodo> its bed time for me
04:35:24 <quazimodo> "D
04:35:25 <quazimodo> bye
04:35:45 <astrolabe> Are there profiling libraries?
04:36:32 <matthew-_>  This package contains additional profiling libraries. They are only needed,
04:36:32 <matthew-_>  if you want to take a closer look on where exactly your program burns CPU
04:36:32 <matthew-_>  cycles.
04:37:06 <matthew-_> oh, that may be 6.4
04:37:20 <matthew-_> yes, it is
04:38:14 <matthew-_> ahh, ok, so there's no separate debian package for profiling for 6.6
04:38:43 <matthew-_> astrolabe: did you know where that page was or did you find it?
04:38:56 <astrolabe> matthew: both :)
04:39:05 <bakert> ?hoogle [a] -> [[a]]
04:39:06 <lambdabot> List.inits :: [a] -> [[a]]
04:39:07 <lambdabot> List.tails :: [a] -> [[a]]
04:39:07 <lambdabot> List.group :: Eq a => [a] -> [[a]]
04:39:08 <matthew-_> googling or wiki search for haskell and profiling didn't find that page very quickly for me
04:39:09 <astrolabe> I've got the ghc manual bookmarked.
04:39:27 <bakert> ?hoogle [a] -> [a] -> [[a]]
04:39:28 <lambdabot> No matches, try a more general search
04:39:29 <xpika> ok, so it works for my ghc6.4 package
04:39:33 <astrolabe> but I actually just googled 'ghc haskell' and then chose chapter 5
04:39:39 <matthew-_> right
04:40:50 <bakert> howdy folks ... i'm trying to create a routine that finds "runs" in a list.
04:41:10 <bakert> so [1,2,3,5,9,10,22] would give [[1,2,3], [9,10]]
04:41:17 <xpika> how do i teach lambdabot @where something is
04:41:29 <bakert> any idea how i might do that?  my rather new to functional programming brain can't quite work it out
04:41:35 <bakert> i was looking at group.
04:41:53 <bakert> and groupBy
04:42:00 <bakert> but not really getting anywhere
04:42:03 <xpika> groupby wont work
04:42:22 <bakert> no because it compares the first with the last with no info about the inbetween
04:42:35 <bakert> so now i am a bit stuck.  any idea?
04:42:55 <xpika> bakert can you see my private msg
04:43:01 <bakert> yes
04:43:04 <astrolabe> xpika: I think it is '@where+ tag address'
04:43:16 <arjanoosting> @help where+
04:43:16 <lambdabot> where+ <key> <elem>. Define an association
04:45:08 <xic> how can i have happs connection threads communicate with each other?
04:51:45 <paolino> bakert, paste your solution (when you find it) please
04:53:24 <xic> i notice that happs uses stm
04:54:05 <bakert> paolino, will do
04:54:21 <rdivacky> hi...
04:54:37 <rdivacky> I am trying to make a "repeatUntil" function. it takes 2 params "cond" and "func"
04:54:46 <rdivacky> cond is condition that must hold to repeat the "func"
04:54:52 <rdivacky> the code looks like
04:54:53 <rdivacky>                         func
04:54:53 <rdivacky>                         c <- cond
04:54:53 <rdivacky>                         if c then repeatUntil cond func
04:54:53 <rdivacky>                            else
04:54:55 <rdivacky>                               return ()
04:55:00 <rdivacky> but it evaluates the cond only once
04:55:08 <rdivacky> what can be the problem?
04:55:41 <malebria> The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness.
04:55:49 <malebria> What is this bottom thing?
04:56:02 <bakert> c is false after one application of func?
04:56:14 <malebria> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aseq
04:56:16 <lambdabot> http://tinyurl.com/y4wexy
04:56:41 <rdivacky> bakert: cond is a simple function
04:56:44 <rdivacky>                 c <- getChar
04:56:44 <rdivacky>                 return (c == 'y')
04:56:53 <Lemmih> rdivacky: Looks like it should work.
04:56:59 <paolino> malebria: maybe it's undefined, but I'm not sure
04:57:00 <rdivacky> when I refactor the code to act like "while" loop
04:57:01 <rdivacky> it works ok
04:57:05 <rdivacky> but I need repeat-until
04:57:27 <bakert> bottom is that weird _|_ symbol.  but don't ask me what it means.  is it a bit like null?
04:57:57 <paolino> @type (_|_)
04:57:58 <lambdabot> parse error on input `|'
04:58:13 <xerox> http://www.haskell.org/onlinereport/exps.html
04:58:14 <lambdabot> Title: The Haskell 98 Report: Expressions
04:58:22 <xerox> See point 3.1 for explanation of _|_.
04:58:38 <paolino> ola xerox
04:58:42 <xerox> Yow.
04:58:42 <malebria> paolino: thanks, I think you're right.
04:58:49 <malebria> paolino: but how did you get to it?
04:59:10 <malebria> seq code in ghc doc is seq _ y = y
04:59:32 <malebria> > let seq_ _ y = y in seq_ undefined 1
04:59:34 <lambdabot>  1
04:59:46 <Lemmih> rdivacky: I don't follow. Your code will repeat 'func' until 'cond' return False. Isn't that what you want?
04:59:56 <rdivacky> yes... thats what I want
04:59:57 <sieni> bakert: null? like a null pointer in C?
04:59:58 <rdivacky> but it doesnt work
05:00:06 <rdivacky> the func is called only twice
05:00:21 <malebria> > seq undefined 1
05:00:23 <lambdabot>  Undefined
05:00:36 <bakert> sieni, xerox's link is the best explanation i think.
05:00:53 <bakert> i meant null in a databasey sense - but i was wrong anyway!
05:01:23 <malebria> I greped for ^seq in GHC code and this seq_ definition is all I found.
05:01:26 <xerox> malebria: http://www.haskell.org/onlinereport/basic.html#sect6.2
05:01:28 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
05:01:38 <sieni> bakert: I have no problem in understanding bottom, I was just curious, what would be the correspondence between null (whatever that means) and bottom
05:02:41 <bakert> sieni, oh i see.  i just thought bottom was some kind of thing representing null, as i no-value or unknown-value or undefined-value.  And it kind of is, but not really.
05:03:02 <bakert> i did say "don't ask me what it means.  is it a bit like null?"
05:03:08 <malebria> xerox: thanks, but where is this in GHC code?
05:05:27 <chr1s> did anyone of you managed to get ghcprof working?
05:06:01 <chr1s> I've compiled my program with profiling support, and I'm running it with ./main [normal params] +RTS -px
05:06:18 <paolino> > let f _=_|_ in f "paolino"
05:06:19 <lambdabot>  Parse error in expression
05:06:28 <chr1s> but whenever I'm doing that the generated main.prof is not an xml file
05:07:39 <paolino> chr1s, is main.prof empty ?
05:07:59 <chr1s> no, it's filled with profiling data, but not in xml format
05:12:23 <matthew-_> @pl filter ((1 <) . length) $ foldr (\v (h:t) -> case h of [] -> ([v] : t) ; (hh: ht) -> if v + 1 == hh then ((v : h) : t) else [v] : h : t) [[]]
05:12:24 <lambdabot> (line 1, column 59):
05:12:24 <lambdabot> unexpected ">"
05:12:24 <lambdabot> expecting variable, "(", operator or ")"
05:12:27 <matthew-_> grrr
05:12:30 <xic> Lemmih: is it true that hIDE is orphaned?
05:16:30 <bakert> @karma xpika
05:16:31 <lambdabot> xpika has a karma of 0
05:16:55 <bakert> ?karma xpika
05:16:56 <lambdabot> xpika has a karma of 0
05:17:22 <Lemmih> xic: Yes.
05:18:44 <xic> Lemmih: :'(
05:19:58 <xpika> @karma haskell
05:19:59 <lambdabot> haskell has a karma of 15
05:20:15 <malebria> @hoogle a -> b -> b
05:20:16 <lambdabot> Prelude.const :: a -> b -> a
05:20:16 <lambdabot> Prelude.seq :: a -> b -> b
05:20:16 <lambdabot> Control.Parallel.par :: a -> b -> b
05:20:35 <malebria> I would like to read the code of seq. =(
05:21:05 <palmmute> :pl \f x y -> compare (f x) (f y)
05:21:31 <xpika> @where+ profiling http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
05:21:32 <lambdabot> Done.
05:21:41 <xpika> @where profiling
05:21:42 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
05:21:49 <xpika> yay
05:22:52 <Lemmih> malebria: seq _ y = y (:
05:23:11 <xic> Lemmih: so what are you working on these days?
05:23:22 <palmmute> @pl \f x y -> compare (f x) (f y)
05:23:22 <malebria> Lemmih: but this is too simple to be seq.
05:23:23 <lambdabot> flip =<< (((.) . compare) .)
05:23:33 <malebria> > let seq_ _ y = y in seq undefined 1
05:23:34 <lambdabot>  Undefined
05:23:38 <malebria> > let seq_ _ y = y in seq_ undefined 1
05:23:39 <lambdabot>  1
05:24:22 <ski> seq :: a -> b -> b
05:24:25 <ski> seq _|_ _ = _|_
05:24:25 <Lemmih> malebria: GHC changes it, like 'assert'.
05:24:25 <ski> seq  _  x = x
05:24:51 <augustss> malebria: you can't read the code for seq, because it's impossible to code seq in pure Haskell
05:25:12 <augustss> seq is not lambda definable
05:25:22 <malebria> augustss: hum ...
05:25:52 <malebria> > let seq_ x y = if x == undefined then x else y in seq undefined 1
05:25:53 <lambdabot>  Undefined
05:25:56 <malebria> > let seq_ x y = if x == undefined then x else y in seq_ undefined 1
05:25:58 <lambdabot>  Undefined
05:26:00 * Lemmih also likes the definitions of 'lazy', 'inline' and 'assert'.
05:26:05 <malebria> > let seq_ x y = if x == undefined then x else y in seq_ 0 1
05:26:06 <lambdabot>  Undefined
05:26:12 <malebria> =(
05:26:50 <augustss> malebria: one can prove that seq is not definable
05:27:24 <malebria> augustss: that's cause you compare undefined, right?
05:27:34 <malebria> can't
05:28:17 <augustss> you can interpret it that way
05:28:33 <augustss> seq is a nasty little function
05:29:45 <augustss> you can make an overloaded seq that would work for all types except functions
05:30:21 <ski> (even codata ?)
05:31:30 <ski> hm, is "parallel or" better ?
05:31:33 <augustss> ski: you mean Haskell's data used as codata?  yes, i don't think that's a problem
05:32:06 <ski> augustss : rather, i possibly meant something like 'struct' in O'Haskell
05:32:09 <augustss> ski: por is also not lambda definable, but nice in my opinion
05:32:22 <astrolabe> haskell would be impractical without seq though, don't you think?
05:32:34 <Lemmih> xic: I'm doing some paid work while trying to squish off some time for my pet project. Everything feels like a stall to figure what to do in life.
05:32:39 <ski> augustss : and the "gustave function" ?
05:32:49 <augustss> astrolabe: i think an overloaded seq would have been ok
05:33:06 <ski> bring back class 'Eval' ! :)
05:33:50 <astrolabe> augustss: what would be the type of this seq'?
05:34:23 <augustss> seq' :: (Seq a) => a -> b -> b
05:34:35 <augustss> that's how it was at first in haskell
05:34:42 <xic> Lemmih: hm.... well good luck
05:34:50 <augustss> except it was called Eval :)
05:35:04 <astrolabe> augstss: where Seq a means that a is not a function?
05:35:30 <augustss> basically, yes
05:35:55 <augustss> seq' would break parametricity less
05:36:13 <malebria> Is this Seq from Data.Sequence?
05:36:18 <astrolabe> I don't really understand the issue
05:36:19 <augustss> and we would still have _|_ = \ x -> _|_
05:36:31 <ski> yeah
05:36:47 <ski> and 'IO' would follow the monad laws
05:37:09 <astrolabe> It doesn't at the moment?
05:37:38 <augustss> malebria: no, this is a new class Seq.  it only has seq as it's method
05:37:52 <malebria> augustss: hum, ok..
05:38:18 <ski> http://www.haskell.org/pipermail/haskell/2002-May/009622.html
05:38:19 <lambdabot> Title: State monads don't respect the monad laws in Haskell
05:38:42 * astrolabe reads
05:39:28 <augustss> the most widely used monad isn't a monad
05:39:54 <sieni> cool as file system check
05:40:09 * matthew-_ finds it unbeliveable that that the quotedprintable encoding in the above email isn't dealt with
05:40:54 <astrolabe> What is '=3D'?
05:40:58 <augustss> mmmm, the good old days when eta reduction was valid
05:40:59 <matthew-_> =
05:41:10 <matthew-_> it's quoted printable encoding
05:41:37 <matthew-_> = means the next char is in hex
05:41:43 <matthew-_> so you encode = as =3D
05:41:46 <astrolabe> Ah, thanks
05:41:59 <matthew-_> to get round the fact that smtp is only 7bit safe
05:42:08 <matthew-_> but it really really should be sorted by pipermail
05:42:21 <dmhouse> augustss: the Seq class was removed because it would change the type of all your functions, whereas you'd probably only apply strictness optimisations when your program was otherwise complete, no?
05:43:52 <augustss> dmhouse: that was the big reason, yes
05:44:09 <augustss> and i can't argue with that, much
05:44:48 <augustss> also, John Huges claimed it was important to be able to seq functions.  i'd argue that this is not a big reason
05:45:00 <metaperl> @seen shapr
05:45:00 <lambdabot> I saw shapr leaving #ltu, #happs, #scannedinavian and #haskell 16h 57m 10s ago, and .
05:45:06 <dmhouse> Hrm, why would (return () >>= \_ -> undefined) `seq` 42 _not_ be undefined? The LHS evaluates to undefined, doesn't it?
05:45:22 <metaperl> hey - the darcs wiki is out of disk space
05:45:27 <metaperl> @seen
05:45:27 <lambdabot> Lately, I have seen astrolabe, augustss, dmhouse, lemmih, malebria, matthew-_, metaperl, sieni, ski and xic.
05:45:59 <dmhouse> Or does seq only return _|_ when the LHS is _exactly_ _|_, not evaluates to _|_?
05:46:55 <augustss> it's supposed to return _|_ when it evaluates to _|_
05:48:11 <dmhouse> In that case, what's Simon Marlow talking about in http://www.haskell.org/pipermail/haskell/2002-May/009622.html?
05:48:12 <lambdabot> Title: State monads don't respect the monad laws in Haskell
05:48:42 <augustss> > (return () :: IO ()) >>= (\ _ -> undefined) `seq` 42
05:48:44 <lambdabot>  42
05:49:16 <astrolabe> I don't buy that you only put strictness optimisations in when the code is 'finished'.
05:49:44 <dmhouse> augustss: why?
05:49:46 <augustss> astrolabe: that's not the only way, but it's very common
05:50:02 <thartman> struggling with cabal, building regex-base. ./setup configure gives me "setup: cannot satisfy dependency base>=2.0". Does that mean I have to install cabal package base?
05:50:20 <dmhouse> thartman: it means you need GHC 6.6
05:50:28 <augustss> dmhouse: to check it the first argument is bottom you have to run it.  but you can't run arbitrary IO computations like that
05:50:29 <astrolabe> augustss: Practically, I find that I'm never sure that I won't want to modify code later.
05:50:32 <malebria> > (return () :: IO ()) >>= (\ _ -> undefined)
05:50:33 <lambdabot>  Add a type signature
05:50:36 <thartman> build from source, or is there some way to do it with apt-get?
05:50:44 <dmhouse> GHC 6.4 has base-1.0, GHC 6.6 base-2.0.
05:50:53 <dmhouse> thartman: build from source should be easy enough if you already have GHC installed.
05:50:59 <augustss> dmhouse: only the top level can run IO
05:51:19 <augustss> dmhouse: and here we are asking to run IO for some other mystery reason
05:51:28 <malebria> @type (return () :: IO ()) >>= (\ _ -> undefined)
05:51:29 <thartman> i'l try that.
05:51:30 <lambdabot> forall b. IO b
05:52:04 <malebria> > ((return () :: IO ()) >>= (\ _ -> undefined)) :: IO ()
05:52:05 <lambdabot>  <IO ()>
05:52:07 <augustss> dmhouse: normally, IO can only be evaluated when the type is right, so you know it has 'contact' with the top level
05:52:38 <augustss> with an overloaded seq, IO would not be seq-able either
05:52:41 <malebria> > return undefined :: IO ()
05:52:43 <lambdabot>  <IO ()>
05:52:54 <malebria> > (return undefined :: IO ()) `seq` 42
05:52:56 <lambdabot>  42
05:53:02 <malebria> Isn't it the same?
05:53:19 <dmhouse> > (undefined :: IO ()) `seq` 42
05:53:20 <lambdabot>  Undefined
05:53:28 <dmhouse> augustss: how is that different?
05:53:40 <augustss> that's the same
05:54:00 <malebria> > (\ _ -> undefined) `seq` 42
05:54:01 <lambdabot>  42
05:54:19 <augustss> so seq doesn't really do it's job
05:54:25 <astrolabe> Oh dear.  Another rabbit hole.
05:55:21 <astrolabe> So, maybe Seq   (big S!) should exclude IOs
05:56:55 <augustss> Seq would have to exclude functions, and any newtype that is a function
05:56:59 <augustss> i.e., IO
05:57:23 <augustss> and typical state monads
05:57:27 <xpika> @where arrows
05:57:28 <lambdabot> http://www.haskell.org/arrows/
05:58:26 <malebria> > Maybe undefined `seq` 42
05:58:27 <lambdabot>   Not in scope: data constructor `Maybe'
05:58:33 <malebria> > Just undefined `seq` 42
05:58:34 <lambdabot>  42
05:58:47 <dmhouse> Just _|_ is not _|_.
05:58:56 <dmhouse> Because Just is not a strict constructor.
05:59:09 <dmhouse> ?define data MaybeS a = Just !a | Nothing
05:59:10 <lambdabot> Undefined.
06:00:12 <malebria> Should IO _|_ be _|_ ?
06:00:25 <dmhouse> Huh.
06:00:27 <dmhouse> data MaybeS a = JustS !a | NothingS
06:00:27 <dmhouse> main = print $ Just undefined `seq` 10 -- 10
06:00:33 <augustss> IO _|_ is not an expression
06:00:42 <dmhouse> That evaluates to 10, not undefined.
06:01:12 <augustss> using a ! in a data type is the same as using seq
06:01:34 <augustss> it involves a seq
06:01:48 <dmhouse> So that evaluates to (undefined `seq` Just undefined) `seq` 10 or something?
06:01:53 <augustss> and conversely, if you have it, you can define seq
06:01:58 <malebria> return _|_ is.
06:02:07 <dmhouse> > (undefined `seq` 10) `seq` 11
06:02:09 <lambdabot>  Undefined
06:02:17 <dmhouse> It should still work.
06:02:33 <dmhouse> > (undefined `seq` Just undefined) `seq` 10
06:02:34 <lambdabot>  Undefined
06:02:37 <augustss> malebria: it's a good question
06:03:09 <nilsi> @seen JohnMeacham
06:03:10 <lambdabot> I haven't seen JohnMeacham.
06:07:40 <xic> any happs experts here?
06:08:01 <justMe204> hi there
06:08:14 <nilsi> hi
06:08:38 <justMe204> i've got a question, where can i find out how the standard function minimum is defined?
06:08:51 <Pete_I> probably in prelude on the web
06:09:10 <xic> @src minimum
06:09:10 <lambdabot> minimum [] = undefined
06:09:11 <lambdabot> minimum xs = foldl1 min xs
06:09:11 <dmhouse> ?src minimum
06:09:12 <lambdabot> minimum [] = undefined
06:09:12 <lambdabot> minimum xs = foldl1 min xs
06:09:53 <dmhouse> justMe204: in general, you view the library documentation for the module that contains that function, then hit 'Source Code' at the top of the page.
06:10:18 <Andris> @src gfoldl
06:10:19 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:11:46 <thartman> ?src foldl
06:11:46 <lambdabot> foldl f z xs = lgo z xs
06:11:46 <lambdabot>     where lgo z []     =  z
06:11:46 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
06:12:33 <augustss> it's such an awkward foldl
06:15:28 <thartman> ?src foldr
06:15:29 <lambdabot> foldr k z xs = go xs
06:15:29 <lambdabot>     where go []     = z
06:15:29 <lambdabot>           go (y:ys) = y `k` go ys
06:17:43 <chr1s> anyone here who did profiling before?
06:18:10 <chr1s> I'm trying to get the profiler data in xml format using +RTS -px
06:18:30 <chr1s> but that still gives me a non-xml format
06:20:30 <astrolabe> I couldn't get that to work when I tried, but that was 6.4
06:20:37 <astrolabe> and with windows
06:22:59 <astrolabe> It would be really nice to have too.
06:27:05 <dmhouse> I think Wikipedia's donation graphic's broken, it's been stuck at the same value for a few days.
06:27:11 <xpika> hello haskellites. does anyone here know anything about ZIPPERs?
06:27:29 <dmhouse> xpika: a bit, why?
06:28:14 <xpika> are they of any simple use?
06:30:05 <dmhouse> Erm, yeah, pretty often. Every time you need a structure with some kind of cursor or current object and want to traverse around that object, zippers are good.
06:30:13 <dmhouse> *around that structure.
06:30:30 <dmhouse> So, for example, an adventure game with a current room (*cough* apfelmus).
06:39:58 <bakert> What's the best way to make an enum of mine respond to "+"?  Do I have to do an instance Num MyEnum?
06:40:14 <bakert> I want a type of my creation to be able to be added to another of the same type.  Is there a standard way to do that?
06:40:19 <bakert> (MyType 8) + (MyType 7) =(MyType 15) -- that kind of thing.
06:40:27 <bakert> I can tell you're not keen on this idea.  But I think it would be very handy.
06:40:31 <bakert> Or at least better than (fromEnum (MyType 8)) + (fromEnum (MyType 7)) = 15
06:40:33 <bakert> YUK!
06:40:35 <bakert> You ever done anything like that before?
06:40:39 <bakert> I bet dmhouse or astrolabe or benja_ or Cale has
06:41:08 <dmhouse> bakert: a Num instance is what you want, yes.
06:41:47 <augustss> bakert: yes, you need to make your own Num instance
06:42:08 <augustss> which can use fromEnum and toEnum to do the job
06:42:40 <dmhouse> bakert: if you've only got a single constructor you can probably derive Num, using newtype-deriving.
06:43:12 <augustss> doesn't sound like an enum type if that's the case
06:43:30 <dmhouse> augustss: no, that's what I was thinking, but judging from the examples...
06:43:30 <augustss> but nor does MyType 7
06:43:36 <augustss> yep
06:44:04 <augustss> bakert: newtype MyType = MyType Integer deriving (Eq, Ord, Show, Num)
06:48:02 <bakert> Hmm ... did I say anything in the last 10 mins?  Something odd going on with my connection.  Apologies if I start repeating myself.
06:48:12 <bakert> Does anyone know how I can make a type of mine respond to "+"?
06:48:27 <bakert> Do I need to do "instance Num MyType where ..."
06:48:28 <bakert> ?
06:50:38 <dmhouse> bakert: check the logs, you've been answered.
06:50:45 <dmhouse> bakert: see the /topic.
06:51:11 <bakert> ah ... sorry ... something odd going on with the wireless here!
06:51:19 <bakert> thanks.
06:52:15 <gaal> audreyt: -fdebugging, :breakpoint, and :sprint work -- awesome, thanks!
06:52:38 <gaal> how do I spell "okay, resume running now" though, once I reached a breakpoint?
06:53:08 <gaal> and, what's the status of ":step", which is described "DISABLED"?
06:57:24 <syntaxfree> @src (**)
06:57:25 <lambdabot> Source not found. Where did you learn to type?
06:57:36 <syntaxfree> is (**) defined in terms of (*)?
06:57:41 <thartman> *Main> maximum [1 .. 10^6]
06:57:41 <thartman> *** Exception: stack overflow
06:57:41 <thartman> *Main>
06:57:41 <syntaxfree> @type (**)
06:57:47 <lambdabot> forall a. (Floating a) => a -> a -> a
06:57:49 <thartman> what's the "right" way to do this?
06:57:56 <syntaxfree> @type (^)
06:57:58 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:58:08 <syntaxfree> good. is (^)?
06:58:18 <syntaxfree> thartman:
06:58:19 <syntaxfree> > 10^6
06:58:23 <lambdabot>  1000000
06:58:24 <syntaxfree> ; )
06:58:35 <thartman> yes, works for 10^5, but not 10^5.
06:58:43 <syntaxfree> if you know it's an ordered list, you can use scanl.
06:58:50 <thartman> could have also written 100000
06:58:52 <bakert> ?hoogle Integer -> Int
06:58:53 <lambdabot> No matches, try a more general search
06:58:53 <syntaxfree> > scanl max [1..10^6]
06:58:54 <lambdabot>  Add a type signature
06:59:08 <syntaxfree> > scanl max [1..10^6]::[Int]
06:59:09 <lambdabot>      Expecting a function type, but found `[Int]'
06:59:09 <lambdabot>       Expected type: [Int]
06:59:09 <lambdabot> ...
06:59:11 <Andris> ?hoogle toInt
06:59:12 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
06:59:12 <lambdabot> Char.digitToInt :: Char -> Int
06:59:17 <syntaxfree> @type scanl
06:59:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:59:22 <Andris> ?hoogle fromInt
06:59:23 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
06:59:23 <syntaxfree> oh.
06:59:23 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
06:59:31 <syntaxfree> > scanl max [1..10^6] 0
06:59:32 <lambdabot>   add an instance declaration for (Num [[a]])
06:59:42 <syntaxfree> > scanl max 0 [1..10^6]
06:59:44 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:59:53 <syntaxfree> not that :(
07:00:01 <bakert> Oh dear I am confused.  An Integer is "a whole number" and an Int is an Integer in a particular range, right?
07:00:13 <syntaxfree> Integer is a big integer. Int is a small one.
07:00:19 <Andris> what is a good introduction to existentially quantified types as done in GHC?
07:01:13 <bakert> syntaxfree, I'm defining fromInteger for an "instance Num MyType" and I am using fromEnum but that expects an Int.  Is there a "doh!" solution to my dilemma?
07:01:32 <Andris> I keep getting "Inferred type is less polymorphic than expected"
07:01:43 <bakert> syntaxfree, (sorry, toEnum)
07:02:26 <thartman> re my previous question, I'm going to ask at haskell cafe. thanks for trying tho, syntaxfree :)
07:02:40 <syntaxfree> oh, stupid me.
07:02:43 <syntaxfree> thartman.
07:02:49 <syntaxfree> > foldl (max) 0 [1..10^6]
07:02:51 <lambdabot>  1000000
07:03:05 <syntaxfree> > foldr (max) 0 [1..10^6]
07:03:07 <lambdabot>  Exception: stack overflow
07:03:10 <syntaxfree> see?
07:03:19 <syntaxfree> foldl compares 1 to 2, discards 2, compares 2 to 3, etc.
07:03:47 <syntaxfree> foldr returns the maximum of 1 and (the maximum of 2 and (the maximum of 3 and (.....
07:03:51 <syntaxfree> hence, stack overflow.
07:04:34 <syntaxfree> now, my question is: why is maximum defined in terms of foldr in the prelude?
07:05:10 <augustss> bakert: what does the definitions of your type look like?
07:05:10 <astrolabe> foldl' from Data.List is better I think
07:05:26 <bakert> augustss, data Rank = Ace | Two | Three | Four | Five | Six | Seven
07:05:26 <bakert>           | Eight | Nine | Ten | Jack | Queen | King
07:05:26 <bakert>             deriving (Bounded, Enum, Eq, Ord, Show)
07:05:30 <syntaxfree> foldl' is strict?
07:05:35 <astrolabe> syntaxfree: yeah
07:05:47 <bakert> augustss, to which I am adding:
07:05:53 <Jaak> @src maximum
07:05:53 <lambdabot> maximum [] = undefined
07:05:53 <lambdabot> maximum xs = foldl1 max xs
07:06:03 <bakert> instance Num Rank where
07:06:03 <bakert>     (+) = (\r1 r2 -> toEnum ((fromEnum r1) + (fromEnum r2)))
07:06:24 <bakert> ...
07:06:25 <bakert>     fromInteger = (\i -> (toEnum i))
07:06:31 <syntaxfree> ok, this is odd.
07:06:33 <bakert> and it doesn't like that last bit
07:06:37 <syntaxfree> > foldl max 0 [1..10^6]
07:06:39 <lambdabot>  1000000
07:06:45 <bakert> " Couldn't match `Int' against `Integer'"
07:06:50 <augustss> bakert: r1 + r2 = toEnum ...
07:06:50 <syntaxfree> it gives a stack overflow on my box!
07:06:53 <augustss> it's easier
07:06:56 <thartman> I'm trying...  last (sort [1..10^6])
07:07:03 <thartman> hasn't busted my stack yet, but kind of slow.
07:07:16 <syntaxfree> thartman: that's just silly.
07:07:20 <augustss> fromInteger = toEnum . fromInteger
07:07:30 <syntaxfree> sorting is expensive, and doing it just to discard all elements but the max.
07:07:31 <bakert> augustss, ah yes that would make sense
07:07:40 <syntaxfree> to boot, last is bound to be expensive as well.
07:07:46 <syntaxfree> > foldl' max 0 [1..10^6]
07:07:48 <lambdabot>  1000000
07:07:49 <syntaxfree> that's the best one.
07:07:50 <bakert> augustss, oooh one of those dot things.  i really must work them out.
07:08:20 <augustss> bakert: fromInteger i = toEnum (fromInteger i)
07:08:26 <augustss> same thing
07:08:41 <syntaxfree> *Main Data.List> foldl' max 0 [1..10^6]
07:08:41 <syntaxfree> 1000000
07:08:41 <syntaxfree> (0.45 secs, 40892388 bytes)
07:08:50 <syntaxfree> regular foldl gives me a stack overflow.
07:09:00 <thartman> is foldl' from the prelude?
07:09:05 <bakert> thanks augustss
07:09:12 <syntaxfree> foldl' is in Data.List.
07:09:21 <syntaxfree> when you have questions like that, you can use Hoogle.
07:09:21 <thartman> much obliged syntaxfree :)
07:09:23 <syntaxfree> @hoogle foldl'
07:09:24 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
07:09:27 <syntaxfree> see?
07:09:50 <thartman> ?src Data.List.foldl'
07:09:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:09:54 <syntaxfree> thartman: make sure you understand why left-folds work and last . sort is expensive.
07:10:35 <thartman> yeah, I'm trying a lot of stuff and sort of letting it wash over me, but I'm also trying to get the bigger picture.
07:10:42 <syntaxfree> why is my stack smaller than lambdabot's? :(
07:11:08 <syntaxfree> basically, with sort you're producing a lot of info you don't really need.
07:11:17 <syntaxfree> info that's somewhat expensive to produce as well.
07:11:44 <syntaxfree> also, lists are LIFO stacks. the primitive operations on them are push and pop, er, (:) and tail
07:11:50 <thartman> I've been playing with foldl/foldr all day, so this is a good exercise.
07:12:15 <syntaxfree> so stuff like "last" is defined recursively. they're not like arrays, which have better random access.
07:13:21 <Ulfalizer> thartman: take a look at the definition of reverse in the prelude. it involves folding, and figuring it out is a good practise.
07:13:25 <syntaxfree> @src (!!)
07:13:25 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:13:45 <Ulfalizer> @src reverse
07:13:45 <lambdabot> reverse = foldl (flip (:)) []
07:13:50 <syntaxfree> > foldl (flip (:) []
07:13:51 <lambdabot>  Parse error
07:13:55 <syntaxfree> ah, you beat me to the punch.
07:14:28 <Ulfalizer> a good exercise even
07:14:41 <syntaxfree> well, yes. been there, done that ; )
07:15:27 <Ulfalizer> i was correcting my buggy english :)
07:16:04 <syntaxfree> thartman: by now, if you have used other programming languages, you probably see already how much rote looping code can be reduced to this foldl/foldr algebra.
07:16:05 <syntaxfree> for one,
07:20:15 <nostrademons> anyone know of a really basic type inference implementation tutorial, one that covers Hindley-Milner type inference with no extensions?
07:20:24 <thartman> ?src maximum
07:20:24 <lambdabot> maximum [] = undefined
07:20:24 <lambdabot> maximum xs = foldl1 max xs
07:20:30 <nostrademons> I'm working off TAPL and Typing Haskell in Haskell, but I'd rather start with something simpler...
07:22:36 <basti_> hi all
07:24:39 <thartman> interesting, my initial guess to use maximum for my prob would have worked, if it had been defined with foldl' rather than foldl1, or just foldl.
07:25:45 <thartman> ?src foldl1
07:25:46 <lambdabot> foldl1 f (x:xs) = foldl f x xs
07:25:46 <lambdabot> foldl1 _ []     = undefined
07:25:54 <thartman> ?src foldl'
07:25:55 <lambdabot> foldl' f a []     = a
07:25:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:27:12 <dmhouse> thartman: well, it still would have worked, it's just that using foldl' makes it stricter and therefore faster (in this case).
07:27:58 <thartman> dmhouse: out of the box 'maximum' crashed my stack on a million element list.
07:28:10 <dmhouse> ?src maximum
07:28:11 <lambdabot> maximum [] = undefined
07:28:11 <lambdabot> maximum xs = foldl1 max xs
07:28:36 <dmhouse> thartman: it shouldn't have done if it uses foldl', that would make it O(1) space.
07:29:08 <thartman> yes, syntaxfree pointed that out as the solution.
07:29:35 <dmhouse> So doesn't the standard maximum use foldl'?
07:29:56 <thartman> not according to lanbdabot :)
07:30:28 <thartman> or maybe I don't understand lambdabot. I thought when you do ?src, you do get the standard def.
07:30:35 <dmhouse> Yes, well, lambdabot's not quite the letter of the law.
07:30:38 <dmhouse> thartman: I don't think so.
07:30:44 <dmhouse> ?index maximum
07:30:45 <lambdabot> Data.List, Prelude
07:30:48 <dmhouse> ?docs Data.List
07:30:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:30:53 <dmhouse> ?fptools Data.List
07:30:53 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:31:09 <dmhouse> maximum                 :: (Ord a) => [a] -> a
07:31:09 <dmhouse> maximum []              =  errorEmptyList "maximum"
07:31:09 <dmhouse> maximum xs              =  foldl1 max xs
07:31:15 <dmhouse> Hrm. Odd. I'd expect it to use a strict fold.
07:31:24 <thartman> well, there you have it. That's why...
07:31:47 <dmhouse> Aha.
07:31:52 <dmhouse> -- We can't make the overloaded version of maximum strict without
07:31:52 <dmhouse> -- changing its semantics (max might not be strict), but we can for
07:31:52 <dmhouse> -- the version specialised to 'Int'.
07:31:52 <dmhouse> strictMaximum		:: (Ord a) => [a] -> a
07:31:56 <dmhouse> strictMaximum []        =  errorEmptyList "maximum"
07:31:58 <dmhouse> strictMaximum xs        =  foldl1' max xs
07:32:02 <dmhouse>  
07:32:03 <thartman> *Main> maximum [1 .. 10^6]
07:32:04 <thartman> *** Exception: stack overflow
07:32:04 <dmhouse>  
07:32:12 <dmhouse> (Sorry for the paste spam, but it's not like we're busy here.)
07:37:41 <thartman> not sure I understand. is there a strictMaximum function somewhere, or were you just thinking out loud?
07:37:51 <dmhouse> thartman: no, that's from Data.List.
07:38:02 <dmhouse> And it lists the reason why maximum isn't strict by default.
07:40:28 <dmhouse> ?ask kowey to have a look at http://en.wikibooks.org/wiki/Talk:Haskell#Move_to_Haskell_wiki.3F
07:40:29 <lambdabot> Consider it noted.
07:42:39 <thartman> uh, is there some way I can force maximum to understand that this is a list of vanilla integers?
07:43:13 <thartman> and somehow get this to work without writing out the foldl' ?
07:43:35 <allbery_b> hm?
07:44:42 <Syzygy-> Wouldn't we want maximum to fold right?
07:45:04 <thartman> ?src maximum
07:45:04 <lambdabot> maximum [] = undefined
07:45:04 <lambdabot> maximum xs = foldl1 max xs
07:45:34 <thartman> long story short, it crashes on a million element list. but if you use foldl' instead of foldl1 it doesn't.
07:45:41 <Syzygy-> > (foldr1 max) [1..10^6]
07:45:43 <dmhouse> thartman: use strictMaximum, like I pointed out?
07:45:44 <lambdabot>  Exception: stack overflow
07:46:11 <thartman> Prelude Data.List> :t strictMaximum
07:46:12 <thartman> <interactive>:1:0: Not in scope: `strictMaximum'
07:46:12 <thartman> Prelude Data.List>
07:46:14 <dmhouse> Syzygy-: you don't want to be foldr'ing on long lists, foldl is tail recursive.
07:46:20 <Syzygy-> dmhouse: Ah.
07:46:26 <thartman> i'm on haskell 6.4
07:46:28 <dmhouse> ?hoogle strictMaximum
07:46:29 <lambdabot> No matches found
07:46:32 <thartman> (upgrading to 6.6)
07:46:33 <Syzygy-> ?index strictMaximum
07:46:34 <lambdabot> bzzt
07:46:38 <dmhouse> thartman: perhaps it's a 6.6 addition then.
07:46:42 <Syzygy-> ?google strictMaximum
07:46:50 <Syzygy-> dmhouse: Which module do I want for that?
07:46:51 <dmhouse> ?fptools Data.List
07:46:55 * Syzygy- is already on 6.6
07:46:57 <lambdabot> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/List.hs?rev=1.26
07:46:58 <lambdabot> Title: fptools/libraries/base/Data/List.hs - view - 1.26
07:46:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
07:47:01 <dmhouse> Syzygy-: Data.List
07:47:25 <Syzygy-> Data.List> :t strictMaximum
07:47:25 <Syzygy-> <interactive>:1:0: Not in scope: `strictMaximum'
07:47:29 <Syzygy-> No such luck
07:47:38 <Syzygy-> And this is on 6.6 with most packages around.
07:47:58 <dmhouse> For some reason it doesn't export it, which is a bit annoying.
07:48:58 <thartman> well, I must say this has been very enlightening, and I'm getting more and more sold on fp.
07:49:20 <thartman> I must go now. thanks :)
07:49:24 <dmhouse> thartman: enjoy :)
07:52:34 <xic> is putStrLn thread safe, can i call it from multiple forkIO at the same time?
07:55:44 <bringert> xic: the strings can be output intertwined
07:56:08 <bringert> xic: it should be safe, but probably not what you want
07:57:21 <bringert> xic: I normally solve that by have a decicated output thread which reads from a Chan. the other threads write to the Chan instead of using putStrLn
08:02:35 <xic> bringert: i'm having trouble with a program, it seems to abort on occasion for no apparent reason:
08:02:37 <xic> http://rafb.net/p/JAwNPs65.html
08:02:45 <lambdabot> Title: Nopaste - No description
08:09:06 <bringert> xic: I don't see any reason for that just by taking ashort look at the program. one odd thing seems to be your readHeaders. it only terminates when it gets a line with just a \r. shouldn't that be \r\n or something in http? but this should only make it hang, not abort I guess. maybe a SOCK_REUSE problem? what hapens when it aborts?
08:10:25 <xic> bringert: i figured it out. i needed to add installHandler sigPIPE Ignore Norhing, like they recommend in the docs :)
08:10:36 <bringert> ah
08:11:10 <xic> yay i wrote a working multithreaded haskell web server :D
08:12:57 <fasta> What's the best way to get the maximum used memory and used CPU time for evaluating a function?
08:12:58 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
08:17:48 <basti_> i did "darcs pull" on my ancient lambdabot, and darcs needed half an hour processing time by now
08:18:03 <augustss> fasta: run with flags '+RTS -S'
08:18:28 <augustss> fasta: well, that's for a whole program, not a function
08:19:11 <fasta> augustss: I don't want to count the time that's needed for reading the file into memory or for displaying the results.
08:20:03 <augustss> fasta: that's tricker then.  you can compile for profiling
08:20:15 <augustss> the ghc manual has a chapter on profiling
08:20:19 <fasta> augustss: but the allocation gives the total allocation, IIRC.
08:20:28 <fasta> augustss: not the maximum at any point
08:20:39 <fasta> augustss: I was reading that chapter already
08:20:54 <augustss> profiling can give you a graph of used memory over time
08:21:12 <augustss> and you can see what's using the memory
08:22:33 <fasta> augustss: yes, but can I also get a number without looking at the graph by hand?
08:23:04 <fasta> "the latter can be determined using heap profiling, which we will describe shortly)."
08:23:19 <augustss> i don't think so.  but looking at these graphs can be very informative
08:24:00 <augustss> actually, it might be possible to extract a single number with the right combination of flags and restricted profiling
08:25:38 <augustss> if you're using laziness in any way you read, processing, and printing won't be distinct phases anyway.  it will all be intertwined
08:27:10 <dmhouse> fasta: use :set +s in GHCi.
08:28:21 <fasta> dmhouse: what exactly does that do?
08:28:39 <dmhouse> "    +s            print timing/memory stats after each evaluation"
08:29:46 <fasta> dmhouse: and what does the memory stats mean?
08:30:04 <fasta> dmhouse: It probably is totally allocated space.
08:30:23 <fasta> (which isn't what I need)
08:30:25 <dmhouse> fasta: ah, sorry, what do you want? Heap space?
08:31:01 <fasta> dmhouse: I want the maximum used space by a single expression.
08:31:53 <fasta> dmhouse: e.g do x<-complex_transformation_taking_huge_amounts_of_space; do_actual_thing x
08:32:27 <augustss> fasta: and which part of that do you want the space of?
08:32:43 <fasta> dmhouse: I only want to have the space counted that x takes, and what do_actual_thing uses to compute the answer.
08:33:15 <augustss> fasta: but what exactly does that mean when you have lazy evaluation?
08:33:30 * dmhouse will brb
08:33:34 <fasta> augustss: well, I thought about strictly evaluating the above expression
08:33:59 <augustss> fasta: but how it behaves strictly is not that interesting in haskell
08:34:11 <augustss> it could be terrible
08:34:23 <fasta> augustss: this is not a stream application
08:34:32 <augustss> like 'let x = [1..10^9] in last x'
08:34:41 <syntaxfree> 2:11 PM  augustss: fasta: run with flags '+RTS -S'
08:34:54 <syntaxfree> i wonder if theres a way to disable those flags if you wanna be secretive about distributed binaries.
08:35:22 <fasta> syntaxfree: I couldn't find what -S does in my documentation.
08:35:25 <augustss> syntaxfree: yeah, i think you can provide your own main somehow
08:35:37 <syntaxfree> your own main?
08:35:58 <augustss> syntaxfree: own C main, that is.  to avoid the flag decoding
08:36:09 <syntaxfree> ah. Should be easier, though.
08:36:12 <syntaxfree> Should be a GHC flag.
08:36:51 <fasta> augustss: in what section is -S documented?
08:37:02 <augustss> fasta: even without being a stream application i can promise you that laziness has to be taken into account.  unless x is a big unboxed array
08:37:31 <fasta> augustss: x is a graph read from a file which should be completely evaluated.
08:37:33 <syntaxfree> running a compiled binary with +RTS -S seems to do nothing here.
08:37:56 <fasta> syntaxfree: you probably need to turn on the profiling options
08:37:56 <augustss> fasta: who makes sure it is evaluated?
08:38:02 <fasta> augustss: I know so.
08:38:18 <augustss> syntaxfree: you didn't get a .stat file?
08:38:20 <syntaxfree> ohh. so it's okay. It's easy to distribute binaries without profiling flags, then.
08:38:27 <syntaxfree> ah, I did.
08:38:36 <syntaxfree> I thought it'd print to stdout. Mo' fool me :)
08:39:32 <therp> putStr doesn't interpret \n right?
08:39:42 <clanehin> I just found this phrase in a comment in my code: a number of degrees equal to the second paramter, in radians
08:39:51 <augustss> -S doc: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
08:40:04 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/d7dj4
08:40:20 <therp> ah, damn. sorry forget my question. \n is interpreted by the haskell parser
08:41:34 <syntaxfree> -B
08:41:34 <syntaxfree> Sound the bell at the start of each (major) garbage collection.
08:41:38 <syntaxfree> haha. this is great!
08:42:26 <augustss> yes, it's a flags inherited from lmlc, ca 1982 :)
08:42:37 <syntaxfree> lmlc?
08:42:49 <syntaxfree> something something lisp compiler, i reckon.
08:42:51 <fasta> heh, I heard about that.
08:42:52 <arjanb> lazy ml compiler
08:43:40 <augustss> i find that it's still around reassuring
08:47:25 <ski> hm, is lmlc and/or hbc available somewhere ?
08:49:25 <augustss> not even I have built it in a while, but i'm sure it's floating around out there somewhere
08:49:42 <augustss> I should make a new release
08:50:20 <ski> that would be nice
08:53:27 <ski> istr i saw an 'ftp://ftp.cs.chalmers.se/...' link .. but i can't ftp into there :/
08:53:55 <emk> Has anyone written a continuation-based web framework (like SmallTalk's Seaside) in Haskell?
08:54:07 <augustss> no, the security nazis have turned off anonymous ftp
08:54:25 <emk> I'd like to use one as an example of continuations in a tutorial...
08:54:26 <ski> augustss : argh .. that's why then :/
08:55:26 <emk> Most examples of the continuation monad are not compelling in, say, 10 lines of code. :-(
08:56:26 <augustss> isn't wash kinda continuation based?
08:57:24 <emk> augustss: Dunno. It didn't look like, but I only glanced at a page or two.
08:57:29 <emk> Let me go look deeper.
08:59:37 <seliopou> are there any known bugs in Data.Set?
08:59:48 <gaal> random note to whoever might use the ghci debugger: to resume operation after a breakpoint, ":q". IMHO not the most intuitive way to do this...
08:59:54 <pejo> augustss, is it the same that is at http://www.cs.chalmers.se/pub/haskell/chalmers/?
08:59:56 <lambdabot> Title: Index of /pub/haskell/chalmers
09:00:03 <xic> forkIO is really fast right, there's no need to create a thread pool?
09:00:24 <augustss> pejo: yes, i think so
09:01:07 <augustss> xic: yes it is
09:01:14 <ski> oh
09:01:37 <augustss> gaal: yes, it took me a minute to figure that one out too
09:01:46 <augustss> gaal: it needs a better command
09:02:59 <Andris> is it legal to have cyclic fun deps in type classes? like class Container g i | g -> i, i -> g
09:03:13 <ski> yes
09:03:23 <ski> that just means they mutually determine each other
09:03:59 <ski> forall g. unique i. Container g i
09:04:03 <ski> forall i. unique g. Container g i
09:04:27 <Andris> that's what I want
09:04:43 <Andris> where can I read about "unique"?
09:04:51 <Andris> or was it a pseudo syntax?
09:04:55 <ski> the latter
09:05:16 <Andris> ah, along the lines of "exists" :)
09:05:32 <emk> augustss: Wash appears to fake continuations using session state (which is a pretty decent way to do things), but it doesn't appear to be truly continuation-based.
09:05:34 <ski> (unique x. P x) <=> (forall x0 x1. (P x0 /\ P x1) => x0 = x1)
09:06:18 <Andris> is this "/\" pseudo syntax as well?
09:06:28 <ski> yes .. it's just predicate logic
09:06:32 <Andris> ok :)
09:06:52 <ski> 'unique' could me pronounced as "at most one"
09:07:04 <ski> 'exists' could me pronounced as "at least one"
09:07:40 <Andris> thanks, so now when I know I am on the right track, I will just have to add right incantations
09:07:45 <Andris> to make GHC happy
09:08:27 <ski> (so that above says that "at most one 'x', satisfying 'P x' means the same as, for every 'x0' and 'x1', if 'P x0' and 'P x1', then 'x0' must be same as 'x1'")
09:09:17 <Andris> well, that's understandable
09:11:06 <Andris> I have a class class Bunch g i | g -> i, i -> g where
09:11:06 <Andris> 	pick :: g -> Maybe (Op, Path i)
09:11:06 <Andris> 	close :: i -> Cont -> g
09:11:40 <Andris> and I cannot understand why the following does not typecheck
09:11:41 <Andris> test (G g) = fmap (\(o, p) -> (o, t p)) (pick g)
09:11:54 <Andris> where data G = forall g i . Bunch g i => G g
09:12:21 <wolverian> well, my head exploded
09:13:18 <Andris> or the following:
09:13:19 <Andris> test :: forall g i . (Bunch g i) => g -> Maybe (Op, Path ())
09:13:19 <Andris> test g = fmap (\(o, p) -> (o, t p)) (pick g)
09:13:48 <Andris> ah, sorry, forgot this one:
09:13:49 <Andris> data Path i = Stop i | Step i (forall j . Path j)
09:14:18 <Andris> so a Bunch is a Bunch of Op with embedded picking strategy
09:14:28 <Andris> and it can have nested bunches
09:14:32 <Andris> hence Path
09:15:16 <Andris> close then closes the Buncg opened by pick, putting a Cont as a consequence of picked Op
09:16:02 <Andris> I suspect I might need some scoped type annotations or smething
09:16:48 <kosmikus> Andris: could you just give us a small, but complete snippet of code that doesn't typecheck?
09:17:33 <Andris> sec
09:18:42 <Andris> {-# OPTIONS_GHC -fglasgow-exts #-}
09:18:42 <Andris> module Error where
09:18:42 <Andris> type Op = ()
09:18:42 <Andris> type Cont = ()
09:18:42 <Andris> data Path i = Stop i | Step i (forall j . Path j)
09:18:42 <Andris> class Bunch g i | g -> i, i -> g where
09:18:44 <Andris> 	pick :: g -> Maybe (Op, Path i)
09:18:46 <Andris> 	close :: i -> Cont -> g
09:18:48 <Andris> --test :: forall g i . (Bunch g i) => g -> Maybe (Op, Path ())
09:18:50 <Andris> test g = fmap (\(o, p) -> (o, Step () p)) (pick g)
09:18:59 <Andris> Op and Cont are bigger in actual code
09:19:07 <Andris> but they are irrelevant here
09:19:10 <augustss> past please!
09:19:14 <augustss> paste, even
09:19:25 <Andris> paste what?
09:19:48 <astrolabe> paste the code rather than copying it to the channel
09:20:00 <astrolabe> @paste
09:20:00 <lambdabot> http://paste.lisp.org/new/haskell
09:20:18 <astrolabe> (please)
09:20:43 <Andris> @help paste
09:20:44 <lambdabot> paste. Paste page url
09:21:18 <lisppaste2> Andris pasted "Ah" at http://paste.lisp.org/display/34352
09:22:55 <Andris> astrolabe: was not aware of this wonderful feature
09:23:22 <astrolabe> Andirs: It is helpful :)
09:23:45 <astrolabe> Sorry, I don't know about those type gymnastics
09:24:28 <Andris> I just wanted to abstract things away
09:24:39 <chocolate> hi
09:24:45 <Andris> so I can have different nested schedulers for my toy interpreter
09:25:17 <Andris> so evaluator just picks an Op, and puts its Cont back
09:25:17 <kosmikus> Andris: are you sure you don't want: "data Path i = Stop i | forall j. Step i (Path j)" ?
09:25:57 <Andris> kosmikus: what is the difference? will it allow j to appear in i?
09:26:17 <Andris> yes, it worked!
09:26:35 <Andris> thanks, but I would love to learn to fish, so to say :)
09:26:49 <kosmikus> Andris: with my version, you get: "Step :: forall i j. i -> (Path j) -> Path i"
09:27:10 <kosmikus> with your version, you get: "Step :: forall i. i -> (forall j. Path j) -> Path i"
09:27:35 <kosmikus> there's a difference
09:27:35 <Andris> aha...
09:27:39 <Andris> I see
09:28:42 <Andris> I thought I understood existentials
09:28:52 <Andris> actually many times :)
09:29:00 <Andris> only to stumble later again
09:29:05 <Andris> thanks!
09:29:26 <kosmikus> you're welcome
09:33:46 <Andris> @help
09:33:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:33:51 <Andris> @list
09:33:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:34:25 <Andris> @karma+ kosmikus
09:34:25 <lambdabot> kosmikus's karma raised to 5.
09:44:33 <ski> hm .. i had a strange idea regarding 'newtype', the other day
09:45:07 <augustss> rename it to chocolate_chip?
09:45:13 <ski> hehe, no
09:45:36 <ski> newtype constructor and deconstructor is O(0)
09:45:59 <ski> newtype B = MkB {unB :: A}
09:46:00 <augustss> yes
09:46:05 <Botje> how can it be O(0) ?
09:46:23 <basti_> heh
09:46:25 <kosmikus> it's completely eliminated after typechecking
09:46:28 <jcreigh> O(0) at runtime, I assume, but not at compiletime.
09:46:29 <ski> Botje : it should be stripped off the code
09:46:50 <Botje> oh
09:46:53 <norpan> O(0) is an interesting concept :)
09:47:09 <ski> but how about the case where we want to convert, e.g. a list of 'A's to a list of 'B's ?
09:47:20 <ski> map MkB :: [A] -> [B]
09:47:40 <basti_> O(0) is obvious
09:47:50 <ski> if the compiler is smart, maybe it could recognize that that ought to be O(0) as well
09:47:53 <basti_> O(0) is if the result is already there
09:47:53 <basti_> ^^
09:47:55 <MarcWeber> In QuickCheck: What is the purpose of variant? And what about configSize? I couldn't extract its meaning from source..
09:48:20 <ski> but for some reason i don't think we can count on the compiler being that smart
09:48:22 <Jaak> hm
09:48:24 <Jaak> @bf ""
09:48:24 <augustss> ski: yes, the compiler could be that smart, but I don't think it is
09:48:25 <lambdabot> Done.
09:48:29 <ski> right
09:48:38 <Jaak> @bf "+++++++[->+++++++<]>-<++++++++++[->.+<]"
09:48:39 <lambdabot>  0123456789
09:49:06 <ski> and of course the problem is excaberated when we have more complex structures
09:49:08 <norpan> i suppose it can be done with unsafeCoerce
09:49:18 <ski> yes, i think some are doing that
09:49:31 <jcreigh> I don't think the quotes are required, @bf just ignores anything it doesn't recognize.
09:49:40 <basti_> o.0
09:50:32 <ski> in hugs, the restricted typesynomyms can be used to convert 'A' to 'B', and vice versa .. but that requires that you have control over the 'newtype' definition
09:51:17 <ski> what we really would want to have is to be able to convert any 'A' inside a type expression to 'B' (and vice versa)
09:52:24 <timthelion> um, how do I exit ghci?
09:52:31 <Jaak> :q
09:52:31 <ski> :q
09:52:35 <ski> ^D
09:52:45 <jcreigh> killall -9 ghci :)
09:52:49 <basti_> :q i think
09:52:56 <timthelion> :q
09:53:06 <xic> here's something confusing in haskell: (-1) and (+1) have different types
09:53:08 <Jaak> shutdown -H now
09:53:11 <timthelion>  what happens if I do < :q
09:53:13 <Jaak> or maybe not...
09:53:15 <pejo> jcreigh, will give surprising results on a bunch of operating systems.
09:53:26 <sm> morning all
09:53:32 <ski> so what we really would want to have could be something with the following type
09:53:33 <basti_> thats not confusing
09:53:41 <timthelion> < :q
09:53:43 <basti_> thats because a-b is not equal to b-a
09:53:43 <ski> forall f. f A -> f B
09:53:50 <timthelion> > :q
09:53:50 <lambdabot>  Parse error
09:53:57 <basti_> (or rather, because +1 is equal to 1+)
09:54:07 <sm> how to I declare a data type that's a tuple ? or, why does this give an error: data Inventory = (Pallets [Inventory], Cartons [Inventory])
09:54:33 <allbery_b> you need a cnstructor.  nmaybe you want a type / newtype?
09:54:36 <ski> so, why not just say
09:54:40 <basti_> it misses a constructor
09:54:49 <ski> newtype f B = MkB {unB :: f A}
09:54:51 <ski> so
09:54:53 <allbery_b> just a type, I guess
09:54:59 <ski> MkB :: forall f. f A -> f B
09:55:05 <ski> unB :: forall f. f B -> f A
09:55:25 <basti_> do you mean data Inventory = Cons_Inventory ([Inventory],[Inventory])?
09:55:31 <xic> basti_: so i should write ((flip (-)) 1) ?
09:55:41 <basti_> allbery_b: that is correct.
09:55:45 <allbery_b> xic: (subtract 1)
09:55:58 <basti_> you could also go like data Inventory Cons_Inventory [Inventory] [Inventory]
09:55:59 <sm> aha.. thx
09:56:14 <basti_> xic: what for?
09:56:14 <basti_> -1 is different to 1-
09:56:18 <sm> I'd like to make an OO-like structure, where I can pull out the pallets with an accessor
09:56:27 <ski> so .. the strange thing now is that we could match on 'MkB' on a lot of types :)
09:56:28 <basti_> as opposed to +1 / 1+
09:56:33 <sm> where is the best complete reference for typle declarations ? the language report ?
09:56:42 <xic> basti_: right... (subtract 1) i mean
09:56:43 <basti_> thats why the types are different i'd say
09:56:59 <basti_> uhm no xic
09:57:16 <basti_> xic: i'm sorry...
09:57:16 <basti_> -1 is interpreted as the opposite of 1
09:57:27 <ski> \(bs :: [B]) -> case bs of [] -> ...; MkB [a] -> ...; b:bs' -> ...
09:57:30 <basti_> thats the problem
09:57:37 <basti_> you can circumvent that by ((-) 1) if you want to do it explicitely
09:58:02 <Saizan> ((-) 1) is like (1-) not (-1)
09:58:16 <ski> augustss : do you see the idea ?
09:58:33 <augustss> yes.
09:58:44 <newsham> > ((-) 1) 3
09:58:45 <ski> what is your opinion ?
09:58:46 <lambdabot>  -2
09:58:55 <ski> would the problem better be solved in other ways ?
09:58:57 <newsham> > (subtract 1) 3
09:58:58 <lambdabot>  2
09:59:24 <augustss> so what's the difference between 'newtype B f = MkB (f A)' and newtype f B = mkB (f A) ?
10:00:02 <ski> (an alternative would be to allow a way of declaring a constant 'AB :: Equal A B', and then use 'subst :: Equal a b -> f a -> f b')
10:00:11 <xic> ?src words
10:00:12 <lambdabot> Source not found. I feel much better now.
10:00:50 <ski> in 'newtype B f = MkB (f A)' 'f :: (* -> *) -> *' (assuming 'A :: *'), while in 'newtype f B = mkB (f A)' 'B :: *' .. but 'f :: * -> *'
10:00:57 <ski> er
10:01:09 <ski> in 'newtype B f = MkB (f A)' 'B :: (* -> *) -> *' ..the same..
10:01:14 <augustss> ski: the new coercion extensions in Fc has all the stuff to do what you need.  it's just not easily accessible at the haskell level.
10:01:41 <ski> augustss : yes .. i got the idea when i browsed some info on that (in trac iirc)
10:02:25 <augustss> f has kind *->* in both, doesn't it?
10:02:33 * ski nods
10:02:43 <ski> (was typo)
10:02:57 <augustss> so what is the difference?
10:03:07 <ski> B :: (* -> *) -> *
10:03:08 <ski> vs.
10:03:12 <ski> B :: *
10:03:36 <augustss> hmmmmm
10:04:00 <augustss> I don't understand what your newtype means
10:04:09 <MarcWeber> Is there already a fixed length list implementation in a package? I know of one in haskelldb
10:04:19 <ski> in my variant, the 'f' is not a parameter of 'B' .. it just represents a context
10:04:41 <augustss> yes, but what formalism are you using?
10:04:47 <ski> so it states that 'f B' is iso to 'f A', for any 'f'
10:05:12 <araujo> hello!
10:05:12 <ski> i'm not sure about formalism :)
10:05:21 <augustss> oh, so it doesn't really define B in the normal sense
10:05:26 <ski> right
10:05:44 <ski> it's somewhat similar to things like
10:05:52 <augustss> it defines B, and an provides the evidence that A and B are equal in any context
10:05:54 <ski> from :: Integer -> Stream Integer
10:05:58 <ski> head (from n) = n
10:06:03 <ski> tail (from n) from (n+1)
10:06:12 * ski nods
10:06:32 <ski> (s/) from/) = from/)
10:07:19 <augustss> and to show where I want to make the conversion I'd use MkB and unB ?
10:07:32 <ski> so, i guess for this to be well-defined .. the 'f' can (must) only be used at the outermost level of the body
10:07:40 <ski> yes
10:07:59 <augustss> so MkB :: forall f . f A -> F B
10:08:04 <augustss> f B
10:08:24 <ski> and because of how haskell matches types (no lambda / higher-order unification .. not even L-lambda), it must syntactically be an application of a type expression on 'A' / 'B'
10:08:47 <augustss> which is very annoying
10:08:54 * ski nods
10:09:17 <ski> so, if one wants to translate more complicated contexts, one has to make a temporary throwaway newtype
10:09:27 <augustss> yeah
10:09:48 <augustss> it's an interesting idea
10:10:24 <ski> hm .. in relation to that .. it could possibly be nice if one could declare local 'newtype's inside e.g. function definitions .. that could use free variables that are e.g. bound in patterns (consider existential datatypes)
10:12:00 <ski> anyway, thought i'd share the idea, while i recalled it
10:18:20 <mbishop> http://programming.reddit.com/info/x7ll/comments
10:18:27 <lambdabot> Title: Origin of Programming Language Names (reddit.com)
10:18:30 <mbishop> it's a shame that link was pointlessly downmodded
10:19:38 <Heffalump> local type definitions would be neat
10:20:16 <timthelion> how come this does not work to return if x<0 then -1 else if x = 0 then 0 else 1? http://rafb.net/p/WRMwwi22.html
10:20:17 <lambdabot> Title: Nopaste - No description
10:20:56 <allbery_b> case does pattern matching.  abs x isn't a pattern
10:21:15 <allbery_b> (it's a function call, but functions won't be evaluated there)
10:21:28 <timthelion> so case does not do symbol matching like in other langs
10:21:39 <timthelion> hmm,
10:21:44 <newsham> abs x isnt a pattern
10:21:53 <timthelion> is there a symbol matching case
10:21:57 <timthelion> statement
10:22:46 <newsham> what symbol do you want to match
10:23:01 <timthelion> the one returned by abs x
10:23:05 <allbery_b> npt the way you mean, I think.  one normally uses guards for that in haskell
10:23:13 <newsham> ?type abs x
10:23:14 <timthelion> would I do y = abs x before the case
10:23:15 <lambdabot> Not in scope: `x'
10:23:16 <xic> @hoogle when
10:23:17 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
10:23:18 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
10:23:22 <newsham> ?type abs
10:23:24 <lambdabot> forall a. (Num a) => a -> a
10:23:30 <newsham> > abs 3
10:23:32 <lambdabot>  3
10:23:35 <newsham> > abs -3
10:23:36 <lambdabot>   add an instance declaration for (Num (a -> a))
10:23:44 <allbery_b> @hoogle sign
10:23:45 <lambdabot> Prelude.significand :: RealFloat a => a -> a
10:23:46 <lambdabot> Prelude.signum :: Num a => a -> a
10:23:46 <lambdabot> Control.Concurrent.QSem.signalQSem :: QSem -> IO ()
10:23:50 <newsham> oh, you want it to do   "x == abs x"
10:24:05 <allbery_b> > signum (-3)
10:24:06 <lambdabot>  -1
10:24:21 <ski> > let x = 15 in maybe (-1) id (lookup x [(0,0),(abs x,1)])
10:24:22 <lambdabot>  1
10:24:26 <ski> > let x = -15 in maybe (-1) id (lookup x [(0,0),(abs x,1)])
10:24:28 <lambdabot>  -1
10:24:30 <ski> > let x = 0 in maybe (-1) id (lookup x [(0,0),(abs x,1)])
10:24:32 <lambdabot>  0
10:24:44 <newsham> > (\x -> let ax = abs x in case x of { 0 -> 0; ax -> 1; _ -> -1}) 3
10:24:45 <lambdabot>      Warning: Pattern match(es) are overlapped
10:24:46 <lambdabot>              In a case alterna...
10:25:19 <allbery_b> newsham: ax matches anything, it won't do a comparison
10:25:25 <newsham> oh right.
10:25:34 <ski> newsham : that's a new 'ax' that shadows the old one
10:25:41 <xic> @hoogle toLower
10:25:41 <lambdabot> Char.toLower :: Char -> Char
10:25:43 <newsham> *nod* my bad.
10:25:54 <ski> newsham : that would work in logic programming (or Erlang), though
10:27:02 <ski> xic : 'Data.Char', also
10:28:51 <sm> so, I'm making an Inventory object in ruby, which I'd like to be a generic object representing some configuration of pallets, cartons and skus, probably using composite pattern. I'd like to prototype in haskell. May I ask for an example of a good way to represent this ?
10:29:32 <allbery_b> ?bot
10:29:33 <lambdabot> :)
10:30:01 <newsham> data Obj = Pallet a b c | Cartoon x y | Skus g deriving Show
10:30:09 <newsham> type Inventory = [Obj]
10:30:10 <newsham> ?
10:31:27 <sm> I'd like to be able to drill down and extract sub-Inventory's .. a pallet's cartons, a carton's skus etc.
10:31:29 <augustss> ?bto
10:31:29 <lambdabot> Maybe you meant: bf bug ft
10:31:35 <allbery_b> huuh.  /msg LB doesn't do > expr any more?
10:31:44 <augustss> ?no I meant bot
10:31:44 <lambdabot> Maybe you meant: . bf ft id pl undo v wn yow
10:32:20 <xic> if i have a bunch of functions with type a -> IO (Maybe a), how can i string them together using both IO and Maybe monad?
10:32:20 <allbery_b> hm.  not the only problem I guess :)
10:32:48 <newsham> data Sku = Sku Int;  data Carton = Carton Int Sku;  data Pallet = Pallet Int Carton
10:32:56 <jcreigh> allbery_b: hmm... > foo doesn't work for me, but @run foo does.
10:33:04 <jcreigh> (when /msg'ing lambdabot)
10:33:08 <allbery_b> fun
10:33:11 <newsham> data InvItem = InvSku Sku | InvCarton Carton | InvPallet Pallet ?
10:33:42 <newsham> or maybe Carton [Sku]   ?
10:33:42 <timthelion> if I define main x = bla bla bla, will x be set to whatever command line arguments are given?
10:33:50 <sm> newsham: very interesting, thx
10:33:51 <allbery_b> no
10:33:56 <allbery_b> @hoogle getArgs
10:33:57 <lambdabot> System.getArgs :: IO [String]
10:34:12 <allbery_b> @index getArgs
10:34:12 <lambdabot> System.Environment
10:34:27 <newsham> main :: IO ()
10:34:50 <allbery_b> (System.getArgs is the Haskell98 name; modern Haskell prefers hierarchical libs but hoogle doesn't always play along for some reason)
10:37:12 <ski> 1> [ (fun(X) -> AX = abs(X),case X of 0 -> 0; AX -> 1; _ -> -1 end end)(X) || X <- [15,0,-15]].
10:37:15 <ski> [1,0,-1]
10:37:18 <ski> newsham : ^ Erlang
10:38:33 <ski> @botsnack
10:38:34 <lambdabot> :)
10:38:44 <augustss> @btosnack
10:38:45 <lambdabot> :)
10:38:50 <ski> (:
10:39:10 <augustss> @botsack
10:39:10 <lambdabot> :)
10:41:42 <Heffalump> @bot
10:41:42 <lambdabot> :)
10:41:51 <Heffalump> @b
10:41:51 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
10:43:18 <timthelion> so one can do f 0 = 1 RET f 1 = 0 but is patern matching possible if f needs to have two arguments?
10:43:57 <augustss> timthelion: yes
10:44:10 <timthelion> augustss: how?
10:44:14 <norpan> f 0 0 = RET
10:44:35 <norpan> h f 0 0 = 1 RET f 0 1 = 2 RET f x y = x + y
10:45:01 <augustss> f 0 0 = 1; f 1 1 = 0; f x y = x+y
10:45:13 <augustss> heh
10:45:14 <timthelion> so I could do f "sd" x = x/2
10:45:24 <augustss> yes
10:45:25 <newsham> f 0 = 0; f x | x > 0 = 1  | otherwise = -1
10:45:32 <timthelion> and f "sd" 2 would = 1
10:45:37 <augustss> yes
10:45:54 <augustss> > let f "sd" x = x/2 in f "sd" 2
10:45:55 <lambdabot>  1.0
10:46:24 * timthelion is writing a library that will do his math homework for him, (ie, sd for synthetic divition...)
10:46:35 <newsham> > let f "half" x = x/2; f "double" x = x*2 in f "double" 3
10:46:36 <lambdabot>  6.0
10:46:53 <timthelion> nice
10:47:36 <xic> does system.io support timeouts?
10:48:22 <newsham> xic: sleep? a callback?  termination after timeout?
10:48:53 <xic> termination after timeout
10:50:52 <newsham> the posix library has alarm signals
10:50:58 <allbery_b> @wiki Timing out computations
10:50:58 <lambdabot> http://www.haskell.org/haskellwiki/Timing out computations
10:51:42 <newsham> what is it you want to timeout?  a read operation?
10:52:45 <xic> newsham: yes
10:53:11 <newsham> hWaitForInput :: Handle -> Int -> IO Bool
10:53:35 <newsham> hReady :: Handle -> IO Bool
10:53:52 <sm> I can't use "type" as the name of a datatype field ?
10:54:01 <sm> what other words would be disallowed here ?
10:54:16 <newsham> do hWaitForInput, if ready, loop while hReady reading with hGetChar ?
10:54:47 <newsham> if you have more time budget after that, loop back and hWaitForInput for the residual?
10:55:15 <xic> hm... looks good excpet the docs say: "NOTE: in the current implementation, this is the only case that works correctly (if t is non-zero, then all other concurrent threads are blocked until data is available)."
10:55:28 <augustss> sm: all the reserved words of haskell
10:56:11 <brad_> hi
10:56:14 <sm> thx
10:56:34 <brad_> any idea why i cannot use Network.HTTP after installing debian's libghc6-http-dev
10:56:34 <newsham> xic: oh, blah.
10:56:53 <xic> indeed :(
10:57:20 <brad_> also cannot load it after installing from source using cabal, including the register option
10:57:26 <newsham> you could fake it by using hReady and a sleep if performance isnt critical
10:58:12 <newsham> do you have other threads to consider?
10:59:16 <xic> yes
10:59:49 <xic> oh well, i'll figure it out later
11:00:01 <newsham> how about a separate thread for reading that queues the data for another thread?
11:00:15 <newsham> then you can implement your own timeouts for reading from the queue
11:00:43 <xic> would it be safe to kill such a thread that is in the middle of reading?
11:01:03 <arjanoosting> brad_: what kind of error do you get wehn using the Debian package?
11:01:07 <newsham> i dont know.
11:01:39 <astrolabe> http://blogs.nubgames.com/code/?p=15
11:01:40 <lambdabot> Title: Nub Games  Haskell &#8212; First Impressions
11:02:01 <newsham> if you can just kill it after a timeout, you can probably use the timeout mechanism on the wiki that someone referenced earlier
11:02:01 <brad_> oh hi arjan, i take it you are the maintainer!?!
11:02:20 <brad_> it just can't find the package
11:02:55 <brad_> by that, i mean ghci cannot find Network.HTTP
11:03:08 <newsham> brad:  ghc-pkg -list ?
11:03:15 <arjanoosting> brad_: yes I am
11:03:40 <arjanoosting> but obviously it is working here ;-) so I need more info
11:04:20 <xic> @hoogle [a] -> a -> Int
11:04:21 <lambdabot> No matches, try a more general search
11:04:30 <sm> I can't use the same field name in two different data types ? that's a bummer
11:04:32 <xic> @hoogle a -> [a] -> Int
11:04:33 <lambdabot> No matches, try a more general search
11:04:36 <brad_> arjan - i simply did an apt-get install libghc6-http-dev, then ran ghci with the first command being ":m Network.HTTP", no luck
11:05:07 <newsham> sm: like?  data Foo = Foo Int | Foo String ?
11:05:23 <brad_> my ghc-pkg -list shows me it is installed in my local package dir (i installed from source too), although i need to use -i to even see this in ghci
11:05:43 <newsham> the tag is a discriminator, it needs to be able to discriminate which type of the alternatives
11:05:46 <xic> @hoogle a -> [a] -> Maybe Int
11:05:47 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
11:05:47 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
11:06:20 <arjanoosting> brad_: can you paste the output of ghc-pkg list
11:06:21 <sm> here's my progress so far: http://rafb.net/p/65tDbK36.html - it doesn't like the use of skus in both Carton and Pallet
11:06:22 <lambdabot> Title: Nopaste - No description
11:06:24 <arjanoosting> @paste
11:06:25 <lambdabot> http://paste.lisp.org/new/haskell
11:07:02 <brad_> $ ghc-pkg -list
11:07:02 <brad_> /home/brad/local/lib/ghc-6.6/package.conf: Cabal-1.1.6, HTTP-2006.7.7, HUnit-1.1, MissingH-0.16.0, QuickCheck-1.0, base-2.0, cgi-2006.9.6, fgl-5.2, (ghc-6.6), haskell-src-1.0, haskell98-1.0, html-1.0, mtl-1.0, network-2.0, parsec-2.0, readline-1.0, regex-base-0.71, regex-compat-0.71, regex-posix-0.71, rts-1.0, stm-2.0, template-haskell-2.0, time-1.0, unix-1.0, xhtml-2006.9.13
11:07:03 <lisppaste2> sm pasted "1" at http://paste.lisp.org/display/34358
11:07:08 <brad_> /home/brad/.ghc/i386-linux-6.6/package.conf: HTTP-2006.7.7
11:07:57 <arjanoosting> brad_: can you paste it to http://paste.lisp.org/new/haskell ?
11:07:58 <newsham> sm: oh, record field names also define an accessor function
11:08:16 <newsham> and if you gave them the same field name, how would you tell apart the two accessor functions?
11:08:24 <sm> which is global across data types.. not encapsulated like OO class methods
11:09:01 <brad_> arjan - now for some reason when i run ghci i can reference the package
11:09:04 <brad_> ??
11:09:04 * sm is learning how to express oo code in haskell
11:09:19 <newsham> yah, its global.  so do like people do often in C, prefix the field names with an identifier for that structure
11:09:20 <brad_> not sure why this problem went away
11:09:22 <arjanoosting> brad_: Do you have a locally installed ghc 6.6?
11:09:23 <newsham> like  ip_p, ip_src, ip_dst
11:09:26 <sm> I see, thx
11:09:48 <newsham> sku_code, sku_descr, sku_color, sku_size, ...
11:09:49 <brad_> ah yes, i DID install ghc6.6
11:09:51 <brad_> locally
11:09:52 <arjanoosting> brad_: in /home/brad/local/ ?
11:10:05 <brad_> prior to debian releasing it as a package
11:10:07 <brad_> ah!
11:10:14 <brad_> hmm, you know more about my computer than me
11:10:18 <brad_> not shocking
11:10:25 <arjanoosting> well the Debian package only registers itself with the ghc shipped with Debian.
11:10:42 <brad_> ah! i should delete the ghc in my local dir
11:10:46 <brad_> or change my $PATH
11:10:49 <brad_> right?
11:10:49 <arjanoosting> brad_: use ghci from /usr/bin and it should work
11:10:59 <arjanoosting> brad_: indeed
11:11:13 <brad_> thanks arjan, great luck that i was able to contact you!
11:11:18 <brad_> thank you so much!
11:11:29 <arjanoosting> brad_: your welcome
11:11:45 <lisppaste2> sm annotated #34358 with "2" at http://paste.lisp.org/display/34358#1
11:11:49 <brad_> take care everyone, once again this forum has solved my problem
11:12:05 <sm> how am I doing so far ?
11:14:57 <sm> (pallets & cartons can have loose cartons & skus also)
11:17:46 <sm> how can I set defaults for record fields, and/or tell it not to warn me about them ?
11:20:58 <syntaxfree> findinglisp.com looks like a good blog.
11:21:11 <syntaxfree> anyway, I'm going out.
11:21:55 <lekro> I'm looking for a function (a -> b -> c) -> [a] -> [b] -> [c] that works like zipWith, but it should append the rest of the longer of the two lists to the final result. is there something predefined or an elegant expression for this, which avoids traversing the list twice?
11:23:00 <astrolabe> Wouldn't appending extra bs be badly typed?
11:23:00 <xic> how do i get rid of the last element of a list?
11:23:10 <lekro> astrolabe: oh
11:23:18 <Saizan> xic: init
11:23:24 <lekro> (a -> a -> a) -> [a] -> [a] -> [a] then
11:24:21 <astrolabe> lekro: I think you'll have to define it yourself, but you shouldn't need to traverse the list twice
11:24:47 <norpan> traverse once or twice, why are you so afraid of traversing?
11:25:29 <lekro> astrolabe: that's what i did so far, but i thought I missed some Prelude-function
11:26:35 <norpan> traversing twice may be better than trasvergins once, it all depends on the evaluation order etc
11:26:37 <astrolabe> lekro: can't think of one
11:27:04 <norpan> huh, how did i do that, what an anagram
11:28:49 <lekro> norpan: it was mainly a question of style, I thought why should I traverse twice when once is sufficient. It's not a performance-critical application at all
11:29:12 <norpan> if it's not performance critical then i would recommend to do the easiest way :)
11:29:29 <norpan> bs ++ zipWith f as bs
11:29:52 <norpan> or what the function was supposed to do
11:30:54 <lekro> it should add to polynomials, represented as lists
11:30:58 <lekro> s/to/two
11:31:33 <colibri_> heya :)
11:32:06 <norpan> lekro: so, just zipWith (+)?
11:32:44 <astrolabe> > zipWith (+) [1] []
11:32:46 <lambdabot>  []
11:33:09 <Saizan> norpan: if they are not of the same grade..
11:33:39 <lekro> norpan: yes. e.g. [1,2] represents (1 + 2x), so polyMul [1,2] [2] should evaluate to [2,4]
11:34:40 <norpan> yeah, some predefined function where you supply a list for the shortest list in zipWith would be good
11:34:43 <Saizan> lekro, you could just append zeros to the shorter list
11:34:53 <norpan> or a default value
11:35:01 <norpan> such as 0 :)
11:35:23 <lekro> Saizan: i thought of that, but to find the shorter list I have to traverse both of them
11:36:56 <Saizan> lekro: true, we really need a zipWith with default :)
11:37:52 <norpan> zipWithDefault :: a -> (a -> a -> b) -> [a] -> [a] -> [b]
11:38:12 <norpan> implementation left as an exercise
11:38:49 <xerox> Aw.
11:39:09 <xerox> > let g f k (x:xs) (y:ys) = f x y : g f k xs ys; g f k (x:xs) [] = f x k : g xs []; g f k [] (y:ys) = f k y : g [] ys; g _ _ [] = [] in g (+) [1,2,3,4] [1,2]
11:39:10 <lambdabot>  arity mismatch for 'g'
11:39:16 <Saizan> @src zipWith
11:39:16 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:39:17 <lambdabot> zipWith _ _      _      = []
11:39:27 <Andris> @index intersperse
11:39:28 <lambdabot> Data.List
11:39:41 <xerox> > let g f k (x:xs) (y:ys) = f x y : g f k xs ys; g f k (x:xs) [] = f x k : g xs []; g f k [] (y:ys) = f k y : g [] ys; g _ _ [] [] = [] in g (+) 0 [1,2,3,4] [1,2]
11:39:42 <lambdabot>      Expecting a function type, but found `[a]'
11:39:43 <lambdabot>       Expected type: [a]
11:39:43 <lambdabot>     ...
11:39:45 * sorear pokes ?seen
11:39:47 <xerox> Grrr.
11:40:31 <xerox> > let g f k (x:xs) (y:ys) = f x y : g f k xs ys; g f k (x:xs) [] = f x k : g f k xs []; g f k [] (y:ys) = f k y : g f k [] ys; g _ _ [] [] = [] in g (+) 0 [1,2,3,4] [1,2]
11:40:33 <lambdabot>  [2,4,3,4]
11:49:47 <xic> what's a good logging library?
11:51:23 <astrolabe> > let g f  (x:xs) (y:ys) = f x y : g f xs ys; g f (x:xs) [] = x : g f xs []; g f [] (y:ys) = y : g f [] ys; g _ [] [] = [] in g (+) 0 [1,2,3,4] [1,2]
11:51:24 <lambdabot>      The function `g' is applied to four arguments,
11:51:25 <lambdabot>     but its type `(a -> a...
11:51:56 <sorear> 'good' I can't attest to, but look at Control.Monad.Writer and hslogger.
11:52:19 <astrolabe> > let g f  (x:xs) (y:ys) = f x y : g f xs ys; g f (x:xs) [] = x : g f xs []; g f [] (y:ys) = y : g f [] ys; g _ [] [] = [] in g (+) [1,2,3,4] [1,2]
11:52:21 <lambdabot>  [2,4,3,4]
11:54:24 <sorear> @users
11:54:25 <lambdabot> Maximum users seen in #haskell: 296, currently: 278 (93.9%), active: 41 (14.7%)
12:07:59 <therp> neat, my embedded prolog works quite nicely..
12:10:24 <basti_> embedded prolog wtf?
12:13:05 <therp> actually I just implemented http://www.cs.chalmers.se/~koen/pubs/entry-haskell00-typedlp.html - but soon the embedding is going to be automatic in via Liskell meta-programming yeah :)
12:13:07 <lambdabot> Title: Koen Claessen - Publications
12:13:21 <therp> but that's the task for tomorrow..
12:14:47 <therp> what would be sunday without coding?
12:14:58 * basti_ sighs
12:15:17 <basti_> does anybody know OZ?
12:15:55 <sorear> the book series?
12:16:14 <basti_> no
12:16:19 <basti_> the programming language
12:17:13 <lisppaste2> sm annotated #34358 with "latest, commented prototype" at http://paste.lisp.org/display/34358#2
12:17:57 <basti_> oz, the PL is some interesting thing between prolog, imperative, functional programming, that includes virtualisation in a very skillful way IMO
12:24:03 <conal> anyone know how to get trillian to give an alert when someone mentions your nickname in irc?
12:24:21 * basti_ shakes his head
12:27:39 <conal> how do you guys manage your attention while connected to #haskell?  how do you catch your messages but still have enough focus for programming etc?
12:27:49 <sorear> /quit
12:27:52 * basti_ isnt programming atm
12:27:55 <sorear> @tell
12:27:55 <lambdabot> Plugin `tell' failed with: IRCRaised Prelude.head: empty list
12:28:22 <conal> basti_: and when you program, do you tune out #haskell?
12:28:38 <basti_> I've become kinda insensitve
12:28:47 <conal> ??
12:28:54 <basti_> first, i can focus on more than one thing at the same time
12:28:56 <timthelion> how do I make a comment, what is the comment charicter?
12:29:02 <basti_> then, when i retreat, people don't talk with me
12:29:03 <arjanb> just read up like once an hour or when waiting on something to compile
12:29:13 <ski> (therp : there was a paper by Seres and Spivey (iirc), too, which was referenced by the other link i gave you)
12:29:40 <sm> conal: make your irc client beep, set window manager hint, highlight the line etc. when someone says your name
12:29:41 <basti_> i can follow the contents roughly
12:30:08 <Heffalump> conal: I just connect when I don't care about being distracted
12:30:11 <conal> sm: that's what i want to do.  don't know how in my client (trillian).
12:30:18 <basti_> use irssi?
12:30:20 * basti_ ducks
12:30:21 <sm> if I need to keep an eye on chat, I'll sometimes leave a few lines visible at the bottom of the screen
12:30:26 <sm> conal: gaim is good
12:30:59 <conal> sm: thanks.  maybe that's what i'll do.  used to use gaim & switched.  i forget why.
12:31:41 <timthelion> what is the comment charicter in haskel?
12:31:47 <sm> --
12:31:51 <conal> maybe i didn't know gaim could to irc
12:32:08 <timthelion> ok, thanks
12:34:54 <seliopou> @hoogle Monad m => Bool -> a -> m a
12:34:55 <lambdabot> Control.Exception.assert :: Bool -> a -> a
12:36:08 <lisppaste2> sm annotated #34358 with "refinement" at http://paste.lisp.org/display/34358#3
12:37:44 <sm> not to get hung up on details on this stage.. but I've distinguished Skus and MixedSkus (line 27). I wonder if this is useful or overkill, and if I should so the same for cartons/pallets
12:37:49 <sm> s/s/d/
12:38:47 <basti_> o.o
12:38:48 <basti_> sm?
12:39:18 <sm> yes ?
12:39:26 <basti_> what are you trying to do?
12:40:13 <sm> model, understand and improve the design of a rails warehouse inventory app currently in development
12:40:28 <sm> and learn haskell :)
12:41:10 <basti_> hmm
12:41:18 <seliopou> @index MonadPlus
12:41:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:41:26 <seliopou> @src MonadPlus
12:41:27 <lambdabot> Source not found. Are you on drugs?
12:41:42 <emu> @slap lambdabot
12:41:42 * lambdabot smacks lambdabot about with a large trout
12:41:49 <seliopou> @instances MonadPlus
12:41:50 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:41:52 <bd_> lambda: My anti-drug.
12:41:55 <sm> especially, learn how to apply haskell to a real-world db app
12:42:28 <basti_> sm: did you have a look at haskelldb?
12:42:47 <sm> yes, but a while ago
12:43:10 <sm> I don't need to get it running yet, it's helping me understand our data structures
12:43:23 <basti_> then it's ok ^^
12:44:55 <e_e_coli> Hello. I've ordered the Hudak and the Thompson books, and have started noodling with YAHT in Hugs, but have run into the weird inability to name "top-level" functions in Hugs
12:45:09 <basti_> uhm
12:45:11 <basti_> to "name"?
12:45:15 <e_e_coli> well
12:45:19 <e_e_coli> let f x = x ^ 2
12:45:22 * sm is also interested in happs
12:45:27 <e_e_coli> assign that function to f
12:45:33 <basti_> yea
12:45:34 <basti_> so?
12:45:35 <allbery_b> hugs doesn't let you define top level functions in the interactive loop, only read them from a file
12:45:36 <norpan> you should use a separate file
12:45:39 <basti_> ahhh
12:45:40 <e_e_coli> riht
12:45:41 <norpan> haskell is not made for interactive use
12:45:43 <basti_> okay
12:45:47 <allbery_b> ghci lets you do e.g. let f x = ...
12:45:51 <basti_> the point is:
12:45:57 <allbery_b> (but not f x = ...)
12:45:58 <timthelion> is there a head function that gets the first word(ie all text till the first space)and a tail function that gets the rest? or do I have to write these
12:46:10 <basti_> ghci can obscure that what you're doing is actually engulfing let constructs
12:46:11 <e_e_coli> but I was wondering whether experienced haskellers use hugs and constantly go into the editor, or skip it and use ghci etc.?
12:46:21 <allbery_b> headw = head . words -- ?
12:46:27 <e_e_coli> or just edit/compile/run?
12:46:34 <norpan> e_e_coli: i use editor + reload
12:46:42 <basti_> most people use an editor, and then use an interpreter to test their functions interactively i guess
12:46:45 <sjanssen> > words "one two three" -- does this help, timethelion?
12:46:47 <e_e_coli> I got ya
12:46:47 <lambdabot>  ["one","two","three"]
12:46:57 <timthelion> yes
12:46:59 <timthelion> thanks
12:47:03 <timthelion> that's cute
12:47:35 <kpreid> > unwords ["one","two","three"]
12:47:36 <lambdabot>  "one two three"
12:47:56 <timthelion> then I just do foldr (++) "" (tail . words "one two three")
12:48:07 <timthelion> ok
12:48:16 <kpreid> sure you don't want spaces?
12:48:23 <kpreid> > foldr (++) "" (tail . words "one two three")
12:48:24 <lambdabot>      Expecting a function type, but found `[String]'
12:48:24 <lambdabot>       Expected type: a1 ...
12:48:31 <kpreid> > foldr (++) "" ((tail . words) "one two three")
12:48:32 <lambdabot>  "twothree"
12:48:43 <timthelion> ok
12:48:45 <e_e_coli> norpan, when you say that haskell is not made for interactive use, what makes it unsuited for repl?
12:48:50 <Andris> @src words
12:48:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:48:54 <kpreid> @pl foldr (++) ""
12:48:54 <lambdabot> foldr (++) []
12:49:00 <timthelion> still not quite logical enough in my mind for this
12:49:04 <kpreid> huh, pl doesn't know that foldr (++) "" == concat
12:49:26 <basti_> how could it?
12:49:34 <norpan> e_e_coli: not at all
12:49:37 <basti_> it doesn't know that "" is the neutral element of the string-quasigroup
12:49:45 <allbery_b> > break (not . isSpace) "foo bar baz"
12:49:47 <lambdabot>  ("","foo bar baz")
12:49:50 <allbery_b> whoops
12:49:54 <basti_> and then, the types don't fit either
12:50:02 <allbery_b> > break isSpace "foo bar baz"
12:50:03 <lambdabot>  ("foo"," bar baz")
12:50:21 <kpreid> well, concat is more general
12:50:22 <norpan> but stuff like mutual recursion is a bit tricky doing interactively
12:50:33 <timthelion> > unwords ( tail . words "one two three")
12:50:34 <lambdabot>      Expecting a function type, but found `[String]'
12:50:34 <kpreid> > foldr (:) ""
12:50:34 <lambdabot>       Expected type: a1 ...
12:50:35 <kpreid> er
12:50:35 <lambdabot>  <[Char] -> [Char]>
12:50:54 <kpreid> @pl foldr (:) ""
12:50:55 <lambdabot> foldr (:) []
12:50:59 <timthelion> > unwords ( (tail . words) "one two three")
12:51:01 <lambdabot>  "two three"
12:51:05 <timthelion> ok
12:51:09 <kpreid> huh, I thought it simplified something like that to id
12:51:25 <kpreid> > (unwords . tail . words) "one two three"
12:51:26 <lambdabot>  "two three"
12:51:28 <sjanssen> timthelion: that will compress multiple spaces, though
12:51:32 <e_e_coli> well, even in a source file, one definition must come before another :)
12:51:38 <ski> basti_ : quasigroup ?
12:51:48 <e_e_coli> unless... there are semantics of files-as-modules
12:51:53 <basti_> i think strings are a quasigroup
12:51:57 <e_e_coli> so I guess i understand
12:51:59 <sjanssen> > unwords . tail . words $ "one two         three"
12:52:01 <lambdabot>  "two three"
12:52:01 <e_e_coli> interesting
12:52:15 <ski> > let x = y; y = 42 in x
12:52:16 <lambdabot>  42
12:52:32 <basti_> a ++ "abc" === a ++ "abc" => a === a, but not a ++ "abc" === a
12:52:39 <timthelion> sjanssen: in this case, that is accualy a good thing
12:52:42 <ski> e_e_coli : in a file, you can order your declarations however you want
12:53:34 <e_e_coli> so, for an ocamler, a file is something like let x = ... and y = ... and z, where defs of x,y,and z can refer to each other?
12:53:48 <e_e_coli> let rec rather
12:53:55 <ski> yes, 'let rec'
12:54:03 <e_e_coli> thank you
12:54:16 <sm> what's the simplest way to implement (+) for my Inventory objects so I can add them together ?
12:54:24 <basti_> (+) ?
12:54:32 <sm> using the simple + operator, I mean
12:54:50 <ski> import Prelude hiding ((+))
12:55:46 <ski> basti_ : hm .. i guess i don't know what a quasigroup has more than a monoid
12:55:56 <allbery_b> you can't do that without removing the standard meaning of (+), because haskell expects (+) to come along with other arithmetic operations some of which will probably not make sense for your objects
12:56:25 <allbery_b> or if they do, you need to make your Inventory an instance of the Num typeclass
12:56:26 <norpan> you can jsut choose not to implement the other
12:56:33 <basti_> quasigroup implies cancellability, but it does not imply that a cancelled "fraction" is equal to the original fraction
12:56:46 <allbery_b> doesn't Num require various operations?
12:57:01 <basti_> strings (and lists) form a quasigroup with "" and ++ i think.
12:57:08 <norpan> yes, but you can choose to implement them as undefined
12:57:33 <norpan> or a more specific error
12:57:59 <basti_> i don't know if formulating a "quasigroupad" as a programming structure would give many benefits
12:58:05 <basti_> maybe it could enhance parallelism
12:58:14 <sm> so I could make Inventory derive Num and override +, but I'd have to disable/implement a bunch of other arithmetic methods ?
12:58:34 <norpan> sm: exactly
12:58:47 <norpan> not derive, instance
12:59:17 <sm> oh you're right.. interesting
12:59:51 <sm> "deriving Show" vs. "instance ... ", what's the essential difference ?
13:00:16 <basti_> "deriving" tells the compiler: do the obvious for yourself - somewhat undefined
13:00:19 <norpan> deriving is letting haskell define the functions for you
13:00:26 <basti_> "instance" says: I'll bring what you need
13:00:44 <norpan> you can only derive certain predefined classes
13:00:54 <norpan> like Eq, Show, Ord
13:01:35 <sm> interesting, thx
13:02:53 <kpreid> you can derive any class on a sufficiently simple newtype in ghc
13:03:19 <conal> sm: i switched back to gaim.  will see how it goes.  thanks for the suggestion.
13:03:20 <norpan> kpreid: yeah, on newtype you can derive any class
13:03:39 <Korollary> Cool. PLT Scheme now includes a call-by-need version of scheme.
13:06:37 <sm> is (i+) a valid function name ?
13:06:49 <sm> (i+) :: Inventory -> Inventory -> Inventory
13:07:01 <kpreid> sm: you can't mix alphanumeric and punctuation
13:07:06 <sm> aha
13:07:14 <sm> conal: np
13:07:35 * conal smiles on hearing an alert
13:09:52 <sm> hmm, how do I putStr a Bool ?
13:10:11 <kpreid> @type print
13:10:13 <lambdabot> forall a. (Show a) => a -> IO ()
13:10:53 <dmhouse> *sigh* Why isn't join in the Monad class?
13:12:01 <sm> aha, I should be using print.. still won't print my Bool though
13:12:35 <sm> perhaps I'm misreading
13:12:57 <e_e_coli> hey, that lambdabot... is it purl?
13:13:06 <Korollary> > show False
13:13:07 <lambdabot>  "False"
13:13:09 <allbery_b> @version
13:13:10 <lambdabot> lambdabot 4p410, GHC 6.5 (OpenBSD i386)
13:13:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:13:12 <Korollary> you can putStr that one
13:13:15 <sm> yes.. inventory needs to derive Eq now
13:13:24 <dmhouse> sm: print True will work.
13:14:22 <Korollary> ?src print
13:14:22 <lambdabot> print x = putStrLn (show x)
13:14:40 <e_e_coli> interesting
13:15:01 <lisppaste2> sm annotated #34358 with "adding and comparing" at http://paste.lisp.org/display/34358#4
13:15:37 <sm> it's coming along.. I think == is working now, except for that error at the bottom due to uninitialized fields
13:16:01 <thartman> Is there a way I can get ?src like behavior from ghci?
13:16:07 <sm> I wonder how to set defaults
13:16:43 <Korollary> dmhouse: if you include join in Monad, then you can write an implementation that contradicts with bind and return. No need.
13:16:51 <thartman> or some way to get the actual file that a function is defined in?
13:16:58 <Cale> Try :info
13:17:32 <Cale> It should tell you which module things have been imported from.
13:17:44 <Korollary> You could also run lambdabot locally
13:17:47 <dmhouse> Korollary: if you wanted, you could write both arr and pure methods for an Arrow instance, even though they're meant to be the same.
13:17:47 <Cale> @libsrc GHC.List
13:17:48 <lambdabot> Unknown command, try @list
13:17:54 <dmhouse> For some monads, join is just more natural.
13:17:55 <Cale> @source GHC.List
13:17:55 <lambdabot> GHC.List not available
13:17:57 <Cale> hmm
13:18:04 <dmhouse> ?fptools GHC.List
13:18:05 <lambdabot> GHC.List not available
13:18:17 <Cale> Who knows? :)
13:18:21 <Cale> That's a lie
13:18:24 <Cale> @source Data..List
13:18:25 <lambdabot> Data..List not available
13:18:26 <Cale> @source Data.List
13:18:26 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:18:35 <Cale> you could navigate from there :)
13:18:36 <dmhouse> ?fptools Data.List
13:18:37 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:18:52 <dmhouse> Yes, just s/Data/GHC/, and possibly s/hs/lhs/.
13:20:08 * sorear pokes @seen
13:21:56 <thartman> you mean s/GHC/Data/ eh :) ?
13:24:13 <thartman> I think I'm going to try to install lambdabot locally.
13:24:23 <sorear> @where lambdabot
13:24:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:24:50 <sorear> get it, use 6.6, ./Setup.hs configure, ./Setup.hs build, ./dist/build/lambdabot/lambdabot
13:25:28 <Korollary> wasnt there a lambdabot-ghci integration mode?
13:25:29 <sorear> no wait use ./build
13:25:35 <sorear> GOA
13:26:22 <allbery_b> @where goa
13:26:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:30:34 <thartman> sorear: use 6.6, that just means I have to have ghc 6.6 installed, or something more tricky?
13:31:04 <seliopou> @hoogle prefixOf
13:31:05 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
13:31:24 <seliopou> @docs isPrefixOf
13:31:24 <lambdabot> isPrefixOf not available
13:31:33 <seliopou> @docs Data.List
13:31:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:32:24 <sorear> there are two build-files, the default one assumes you have GHC 6.6 (the other assumes GHC 6.4.x)
13:32:48 <sorear> building is broken on HEAD
13:35:11 <sorear> received :: IrcMessage -> LB ()  \n  recieved msg = do s   <- get
13:35:30 <sorear> when writing software, it helps to be consistent in spelling. :)
13:37:55 <xic> @hoogle [[a]] -> [a]
13:37:56 <lambdabot> Prelude.concat :: [[a]] -> [a]
13:39:42 <lisppaste2> mbishop pasted "do notation problem with simple program from SOE" at http://paste.lisp.org/display/34365
13:39:51 <lisppaste2> sm annotated #34358 with "default field values" at http://paste.lisp.org/display/34358#5
13:39:58 <sm> woo! coming along
13:40:09 <mbishop> I get "The last statement in a 'do' construct must be an expression" whenever I try to load that file
13:41:00 <allbery_b> your spacing is odd, to say the least.  I'd bet on layour problems
13:41:06 <sorear> it's correct, the last statement must be an expression
13:41:32 <sorear> w <- openWindow  all the way to the end of the do-block is a single statement
13:41:38 <mbishop> allbery_b: yes, I had it normal before, but it's weird in the book, just wanted to make sure I used the proper layout (since I figure the book knows better than me)
13:45:24 <mbishop> So how do I fix this?
13:45:32 * mbishop tried playing with the formatting
13:49:14 <augustss> avoid tabs
13:49:32 <xic> @type Data.Map.lookup
13:49:34 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
13:49:37 <xic> @type Data.List.elemIndex
13:49:38 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:50:00 <xic> how come elemIndex doesn't use a monad like lookup?
13:50:02 <mbishop> augustss: they are spaces
13:50:16 <mbishop> augustss: no matter how I do the layout, it stil complains it seems :\
13:51:20 <augustss> it looks like the w <- needs to move in one space to line up
13:51:29 <Heffalump> use { and ; instead
13:51:59 <Heffalump> (I really ought to try this sometime, it'd be interesting to see if it makes code look less scary to non-Haskellers)
13:52:19 <augustss> Heffalump: it probably does
13:52:26 <augustss> people like {;}
13:52:32 <Heffalump> augustss: precisely
13:53:16 <augustss> and now you are surrounded by non-haskellers
13:53:31 <Heffalump> not at all
13:53:41 <thartman> I'm having trouble installing ghc 6.
13:53:48 <thartman> http://rafb.net/p/LqB0lh21.html
13:53:51 <Heffalump> I have a non-Haskeller immediately to my right, and an empty space hopefully soon to be filled by a Haskeller on my left ;-)
13:53:55 <lambdabot> Title: Nopaste - No description
13:53:59 <augustss> heh
13:54:23 <Heffalump> and two to my right is someone who seems very keen on Haskell
13:54:25 <dmhouse> thartman: run it again? Seems some signal killed the build process.
13:54:35 <dmhouse> Heffalump: so where are you?
13:54:54 <thartman> happened several times. hm, maybe because I'm inside a screen session, is the only thing I can think of.
13:55:15 <Heffalump> dmhouse: well, actually right now I'm at home with a non-Haskeller opposite. But I was talking about work, which is Credit Suisse.
13:55:19 <augustss> thartman: /usr/bin/ar dying is not a ghc bug.  it shouldn't die, no matter what you do to it
13:55:37 <thartman> uh, ghci is open, maybe that's why?
13:55:50 <augustss> thartman: maybe
13:56:14 <xic> how can i read a number and handle parse errors?
13:56:25 <augustss> reads
13:56:32 <augustss> @type reads
13:56:33 <lambdabot> forall a. (Read a) => ReadS a
13:56:45 <dmhouse> My C++ book insists on teaching me about linkers name mangling and so on. Now _that's_ an abstraction leak.
13:57:38 <mahogny> I'd say that is the level you have to know C++ at if you are to use it :P
13:57:55 <dcoutts> Heffalump, how is the new job btw? more fun?
13:57:55 <dmhouse> mahogny: yes, precisely.
13:58:02 <dmhouse> > reads "4" :: [(Int, String)]
13:58:03 <lambdabot>  [(4,"")]
13:58:07 <dmhouse> > reads "4rargh" :: [(Int, String)]
13:58:08 <lambdabot>  [(4,"rargh")]
13:58:11 <augustss> dmhouse: yes, you need to know something about name mangling
13:58:16 <dmhouse> > reads "rargh4" :: [(Int, String)]
13:58:17 <lambdabot>  []
13:58:52 <xic> dmhouse: will it ever return more then one element?
13:59:05 <dmhouse> xic: yes, in the case of an ambiguous parse (which can't happen for Ints).
13:59:07 <augustss> xic: it can happen
13:59:20 <augustss> but not for Int
13:59:24 <Heffalump> dcoutts: early days yet :-)
13:59:25 <xic> ok cool danke sehrs!
13:59:33 <dcoutts> Heffalump, right'o :-)
13:59:33 <dmhouse> augustss, mahogny: my point was that C++'s forcing me to know about linking is an abstraction leak; I should be able to code my high-level language without worrying about such implementation details.
13:59:55 <dcoutts> dmhouse, I'm not sure you actually do need to know that stuff
14:00:19 <mahogny> dmhouse, well, complaining about that in case of c++ is like kicking a dead dog :)
14:00:22 <Heffalump> isn't the concept of linking effectively part of the specification of C/C++?
14:00:23 <dcoutts> dmhouse, I used to use C++ too
14:00:45 <Heffalump> I guess that's your point.
14:00:48 <xic> all programming language implementations have limitations that aren't in the language spec. c++ spec doesn't say anything about function name length limit, but pretty much all compilers have such a limit. therefore you must know about some details of the linker
14:01:07 <Heffalump> and limits on how big a file they'll compile
14:01:19 <mahogny> Heffalump, I would say it is a very fundamental part of c/c++
14:01:26 <sorear> Haskell is Turing Complete, the i386 isn't.
14:01:46 <sorear> all Haskell implementations fail to compile Haskell by imposing limits on memory allocation.
14:03:01 <augustss> all physical computers are non-turing equivalent
14:03:35 <xic> what about a computer that can physically extend itself when needed?
14:03:44 <wilx> Actually, Annexe B says what are "Implementation Quantities."
14:04:15 * allbery_b points xic to "Goedel, Escher, Bach"
14:04:23 * sorear never noticed an annexe in the Haskell Report
14:04:24 <wilx> Well, it is not required, it is just recommendation.
14:04:26 <wilx> But still. :)
14:04:30 <Heffalump> xic: physical limits on the size of the universe
14:04:57 <xic> Heffalump: that can be debated
14:05:13 <dmhouse> allbery_b: if you're on Linux, 'AltGr+[, o' will do . Replace o with your favourite vowel for others.
14:06:00 <sorear> doesn't work here
14:06:03 * allbery_b is on a mac mini talking to linux over a vnc session, and figuring out how to get nonascii over the hump is more "interesting" than he feels like attempting right now
14:06:13 <sorear> exec kbd_mode -u
14:06:58 <dmhouse> Well, it's just a tip that was extremely helpful for me that I felt like passing on. :)
14:07:07 <sorear> my tip: man latin1
14:07:36 <lisppaste2> mbishop annotated #34365 with "used emacs with haskell-mode, indentatin should be correct" at http://paste.lisp.org/display/34365#1
14:07:55 <mbishop> indentation correct, spelling may not be :P
14:08:29 <allbery_b> indentation's still wronmg, actually
14:08:45 <sorear>        366   246   F6           LATIN SMALL LETTER O WITH DIAERESIS
14:08:50 <allbery_b> haskell-mode doesn't actually understand haskell, it offsers a rseries of possible indents
14:09:03 <allbery_b> in your case it offfered the wrong one twice
14:09:18 <dmhouse> allbery_b: more that for any given Haskell line, there are multiple possibly indents.
14:09:46 <allbery_b> the if needs to line with the k; the drawInWindow needs to line with the w
14:11:10 <mbishop> Ah, yes, now it complains that the else is improperly indented (but it only has one indentation according to emacs)
14:11:45 <allbery_b> yeh, it gets that oe wrong for me too.  needs to be indented at least one space past the start of "if"
14:12:23 <mbishop> dmhouse wasn't lying when he said haskell-mode needs lovin
14:12:36 <xic> is there something like Control.Monad.sequence that runs the same action n times and collects the results?
14:12:39 * dmhouse discovered inf-haskell.el today.
14:12:44 <dmhouse> xic: replicateM
14:12:44 <sorear> replicateM
14:12:48 <dmhouse> ?hoogle replicateM
14:12:49 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
14:12:49 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
14:12:54 <xic> ah sweet thanks
14:13:02 <sorear> > replicateM 4 [1..4]
14:13:04 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,2,1],[1,1,2,2],[1,1,2,3],[1,1,...
14:13:11 <sorear> > replicateM 4 [0,1]
14:13:12 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
14:13:29 <mbishop> ahh finally
14:13:32 <mbishop> thank you allbery_b
14:13:36 <sorear> > transpose $ replicateM 4 [' ','#']
14:13:38 <lambdabot>  ["        ########","    ####    ####","  ##  ##  ##  ##"," # # # # # # # #"]
14:13:39 * mbishop noticed he made a silly error too heh
14:13:47 <dmhouse> > replicateM 3 (Just True)
14:13:48 <lambdabot>  Just [True,True,True]
14:14:01 <dmhouse> > replicateM 3 Nothing
14:14:02 <lambdabot>  Add a type signature
14:14:04 <sorear> didn't one of the blogs just write something like that in ~10 lines?
14:14:13 <sm> how do I write an assert statement within main ?
14:14:17 <sorear> > unlines $ transpose $ replicateM 8 [' ','#']
14:14:19 <lambdabot>  "                                                                           ...
14:15:10 <sm> I think I need an IO type for the second argument
14:15:54 <therp> hmm. I would have expected DRiFT to use some sort of abstraction library over the actual text representation of syntax.. but that's wrong.. not that pretty
14:17:22 <xic> how do i make my code not look ugly as shit? http://rafb.net/p/PtXrIn70.html
14:17:24 <lambdabot> Title: Nopaste - No description
14:17:26 <augustss> sm: that's fine
14:17:45 <augustss> sm: assert (1==2) $ putStrLn "Hello"
14:17:58 <sm> is that Control.Exception assert ?
14:17:59 <dmhouse> xic, use the Maybe monad, I expect.
14:18:23 <augustss> sm: yes
14:18:37 <dmhouse> xic: break it down into smaller functions as well.
14:18:39 <sm> hmm, that doesn't work for me
14:18:40 <augustss> xic: yes, the Maybe monad looks like a plan
14:19:02 <xic> yeah i want to use the maybe monad but i don't know how since this is all in IO monad already
14:19:12 <augustss> sm: what happens?
14:19:19 <sm> main = do assert (1==2) --  Couldn't match expected type `IO a'
14:19:19 <sm> 	   against inferred type `a1 -> a1'
14:19:49 <augustss> sm: but you're not doing what I said :)
14:20:20 <newsham> print (assert (1==2)) ?
14:20:37 <sm> hmm
14:20:38 <dmhouse> ?hoogle assert
14:20:39 <lambdabot> Control.Exception.assert :: Bool -> a -> a
14:20:39 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
14:20:39 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
14:20:40 <augustss> main = do assert (1==2) $ return ()
14:20:48 <dmhouse> augustss: lose the do
14:21:11 <OliverB__> xic, Looks like you could perhaps split a lot of it out into a non IO routine, or you could use IO exceptions (or a monad transformer on IO)
14:21:15 <augustss> dmhouse: i was assuming this was the beginning of something more
14:21:16 * sm is seeking the most readable way to write assertions
14:21:29 <shankys_> Could someone tell me an elegant way to get System.Time.ClockTime to derive Typeable? I'm not sure how to get that effect if i didn't define the type myself.
14:21:39 <newsham> xic: you can have a do-block for your Maybe stuff even though you're inside an IO block
14:22:04 <sm> assert expr $ return () seems best so far
14:22:08 <sm> thanks
14:22:27 <augustss> shankys_: perhaps with the new 'derive' statement?
14:22:28 <sorear> derive instance Typeable System.Time.ClockTime -- IIRC; HEAD only
14:22:35 <dmhouse> xic: give me a while. I'm going to rewrite that more idiomatically, I think it'd be quite educational.
14:22:51 <shankys_> augustss: How does that work in general?
14:22:57 <sorear> shankys_: the most elegant way, is file a bug report.
14:23:02 <xic> dmhouse: hm... cool thanks
14:23:08 <augustss> shankys_: like deriving, but it can be freestanding
14:23:22 <shankys_> augustss: Oh, ok. Thanks.
14:23:32 <sorear> shankys_: everything should derive Typeable unless it has a reason not to.
14:23:36 <sm> assert (expr) return ()
14:23:41 <sorear> shankys_: like Show, Ord, Eq
14:24:21 <augustss> someone probably forgot to add it to ClockTime
14:24:21 <sorear> shankys_: e.g. STRef must not derive typeable because cast can weaken the isolation.
14:24:43 <sorear> OK, OK, Typeable2
14:25:44 <augustss> Someone at work discovered a few days ago that Typeable7 is the end of the line
14:25:46 <Syzygy-> ?index Typeable
14:25:47 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
14:26:10 <sorear> yeah, not having kind polymorphism sucks.
14:26:16 <augustss> yeah
14:27:00 <sorear> though you'd probably need kind classes and some kind of kind reification to make a fully-generic Typeablen...
14:27:33 <augustss> kind classes, huh?  there's something to chew on :)
14:28:37 <Heffalump> next you'll be wanting a full hierarchy of type levels
14:29:36 <sorear> I already do
14:30:37 <augustss> not a * : * guy?
14:31:29 <sorear> I am
14:31:37 <sorear> but * : [] will do
14:32:18 <sorear> (actually I'm a # : # guy))
14:32:20 <augustss> with * : * all the levels are the same, so i guess you have them all :)
14:32:33 <augustss> or # :: #
14:33:06 <augustss> with stratified types you really need kind polymorphism, it's a pain otherwise
14:33:23 <sorear> Haskell *has* full type lambdas, and all it needs for # :: # is syntactic sugar
14:33:43 <sorear> well, I haven't tried to implement it :)
14:33:57 <augustss> i'm talking about using it
14:35:16 <shankys_> augustss: I keep getting errors when trying to use derive and the Haskell Wiki says something completely different at: http://haskell.org/haskellwiki/GHC/StandAloneDeriving. Could you give me an example of using derive?
14:35:23 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
14:35:28 <Syzygy-> # :: #??
14:35:43 <augustss> shankys_: sorry, I have never used it myself
14:35:58 <sorear> # :: # is true in Cayenne
14:36:13 <augustss> sorear: no
14:36:19 <sorear> (which I *really* ought to look harder at)
14:36:43 <sorear> ok, I misunderstood the docs then, I *really* *really* have to try it
14:36:46 <augustss> Cayenne has hierachy (which is mostly hidden)
14:37:13 <augustss> sorear: it's a one line change in the type checker to turn it into # :: #
14:37:14 <sorear> I looked at "the type of types is a type"
14:37:40 <augustss> Syzygy-: # is the type of types in Cayenne.  Like * for Haskell kinds
14:38:12 <Saizan> wasn't there a paradox on this kind of thing?
14:38:22 <augustss> Syzygy-: and if you have * :: * you must be very careful if you're doing logic
14:38:39 <augustss> Saizan: yes, it's easy to get Girard's paradox
14:38:45 <sorear> does it give the same general problems as infinite types?
14:38:55 * sorear looks up girard's paradox
14:39:14 <augustss> but for a programming language Girard's paradox just mean an unusual way to make your program loop
14:40:06 <Saizan> by the way, what's #? a * of *?
14:40:23 <augustss> # is just the way * is written in Cayenne
14:40:31 <augustss> * is used for multiplication
14:43:30 <metaperl> @seen Cale
14:43:31 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 24m 57s ago.
14:44:00 <dmhouse> xic: which library do things like GET, HEAD, POST come from?
14:44:28 <xic> dmhouse: it's all my code. i shamelessly ripped a few lines from happs source
14:44:30 <shapr> @seen sigfpe
14:44:30 <lambdabot> I haven't seen sigfpe.
14:44:33 <shapr> aww
14:44:35 <shapr> @seen sigfpe_
14:44:36 <dmhouse> xic: righto.
14:44:36 <lambdabot> sigfpe_ has changed nick to dpiponi.
14:44:36 <lambdabot> I saw dpiponi leaving #haskell 14h 56m 24s ago, and .
14:44:45 <shapr> lambdabot: thanks
14:44:48 <dmhouse> shapr: I believe sigfpe was registered.
14:44:51 <shapr> yup
14:46:20 <dmhouse> Can the compiler fuse maps/filters?
14:46:28 <dmhouse> Yes, of course it can, never mind.
14:46:36 <sorear> @src map
14:46:36 <lambdabot> map _ []     = []
14:46:37 <xic> dmhouse: i can paste the whole 200 lines
14:46:37 <lambdabot> map f (x:xs) = f x : map f xs
14:46:39 <dmhouse> How good is it at doing fusion?
14:46:39 <sorear> @src filter
14:46:40 <lambdabot> filter _ []     = []
14:46:40 <lambdabot> filter p (x:xs)
14:46:41 <augustss> > let x  y = (x+y, x-y) in 3  2
14:46:41 <lambdabot>     | p x       = x : filter p xs
14:46:42 <lambdabot>     | otherwise = filter p xs
14:46:43 <dmhouse> xic: should be okay.
14:46:44 <lambdabot>  Illegal character ''\177''
14:47:07 <sorear> augustss: you need 6.6, lb runs 6.4
14:47:14 <xic> dmhouse: it's actually kind of cool, i have a working multithreaded STM webserver working here...
14:47:27 <dmhouse> xic: nice :)
14:48:00 <xic> dmhouse: http://rafb.net/p/oeoB7p68.html
14:48:08 <lambdabot> Title: Nopaste - No description
14:48:18 <newsham> xic http://rafb.net/p/Qmm9Xd79.html
14:48:20 <lambdabot> Title: Nopaste - update for xic
14:48:29 <xic> dmhouse: compile and run this baby, then browse to http://localhost:8000
14:49:00 <xic> newsham: hm..... /me reads
14:49:35 <newsham> oh, also could be    [mstr, ustr, pstr] <- return v
14:49:39 <dcoutts> dmhouse, map and filter can be fused with each other well
14:49:45 <newsham> instead of "getThree"
14:50:38 <dmhouse> dcoutts: if we had something like M.fromList . filter (not null . snd) . map break (==':'), how likely is that to get fused into a single loop?
14:50:45 <jcreigh> "fuse"? What would it mean for the compiler to "fuse" map?
14:51:06 <dcoutts> dmhouse, assuming fromList is defined as a foldr then it should all get fused
14:51:11 <dmhouse> jcreigh: it fuses two maps into one, for example, so a multi-pass algorithm becomes a single-pass one.
14:51:14 <xic> newsham: but then if v is isn't really a 3 element list then a fatal error will happen instead of Nothing being returned
14:51:16 <dmhouse> dcoutts: great.
14:51:22 <newsham> xic: if "headerList <- readHeaders" is moved earlier, more can be done in the maybe monad too
14:51:35 <dcoutts> jcreigh, you can only fuse one thing with another, eg map f . map g = map (f . g)
14:51:37 <newsham> xic: right, and when the pattern match fails in a Maybe do-block, it returns Nothing, right? (I think)
14:51:41 <newsham> ?type fail
14:51:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:51:51 <newsham> > fail "foo bar" :: Maybe Int
14:51:52 <lambdabot>  Nothing
14:51:53 <dmhouse> newsham: yep.
14:51:59 <dcoutts> dmhouse, that's not one loop of course, since it's a foldr rather than a foldl'
14:52:01 <xic> hm.... very interesting, i did not know that
14:52:34 <newsham> > do { [a,b,c] <- return "ab"; return b } :: Maybe Char
14:52:36 <lambdabot>  Nothing
14:52:48 <dcoutts> dmhouse, assuming M.fromList is Map.fromList then I expect fromList is a foldl' and as such cannot fuse.
14:52:55 <xic> if a pattern match calls fail, then monads are deeply integrated into the language
14:53:13 <dmhouse> dcoutts: okay, but two loops?
14:53:16 <newsham> xic: since you're in an IO do-block the only requirement is that insid ethe Maybe do-block is all Maybe stuff (no IO) except the last item which must return an IO thing
14:53:27 <dmhouse> Great, that makes the foldr vs. foldl debate even more complicated :)
14:53:37 <augustss> xic: well, it's part of the do syntax
14:53:42 <newsham> err. .oops, I forgot to do something....
14:53:51 <newsham> you need   mact <- do {...}
14:53:52 <dcoutts> dmhouse, well it's one loop but it allocates cons cells between fromList . filter
14:54:04 <xic> newsham: that's a problem, readHeaders and hGetChar are IO
14:54:08 <newsham> and at the end you need to do something depending on if mact is (Just act) or Nothing
14:54:21 <newsham> xic: put the readHeaders above.
14:54:46 <dcoutts> dmhouse, it's an interesting drawback with the current list fusion system that it can't fuse foldl easily. We do have a new system that can do it however.
14:54:46 <newsham> xic: lemme go back and edit this again, i'm being sloppy
14:55:07 <xic> newsham: maybe i should make a darcs repos...
14:55:11 * augustss wonders why people are getting so obsessed with dynamically typed languages.
14:55:22 * augustss is reading reddit.
14:55:36 <xic> newsham: btw, did you try running the complete program i pasted for dmhouse?
14:55:44 <mbishop> It's nice to do quick stuff in (like scheme)
14:55:47 <newsham> no.
14:55:52 <xic> newsham: http://rafb.net/p/oeoB7p68.html
14:55:52 <lambdabot> Title: Nopaste - No description
14:56:36 <Heffalump> why is everyone reading reddit all of a sudden?
14:56:42 <augustss> mbishop: well, if all you've seen is C++ I guess so
14:56:47 <dcoutts> Heffalump, I blame dons :-)
14:56:51 <sorear> Heffalump: ghc is slow
14:57:01 * mbishop has always read reddit, but never really liked it heh
14:57:23 <mbishop> well that's not true, when I first found it, even the mainpage was full of interesting stuff, now, it's just a digg clone with equally ignorant users
14:57:31 <mbishop> but programming.reddit.com is still ok...sometimes
14:59:29 <newsham> xic: http://rafb.net/p/1wOGV338.html
14:59:30 <lambdabot> Title: Nopaste - fixed more?
14:59:37 <shapr> hiya anonfunc
14:59:41 <shapr> hiya Anon4888
14:59:42 <shapr> yargh
15:00:17 <newsham> notice the do-block for maybe just computes a Maybe value.
15:00:39 <newsham> dependign on if its Nothing or not, some more stuff is done with it
15:00:41 <sorear> all do-blocks just compute values ... they desugar to expressions
15:01:24 <newsham> xic: also if you use the pastebuf thing that lambdabot urls, it lets people annotate the paste instead of creating new pastes
15:01:38 <xic> @paste
15:01:39 <lambdabot> http://paste.lisp.org/new/haskell
15:01:44 <xic> cool =]
15:01:58 <newsham> and it syntax highlights and can msg the channel when you submit
15:03:17 <newsham> xic: does my paste make sense at all?
15:04:11 <xic> sort of
15:04:14 <newsham> heh, noBodyRequest is out of scope at the bottom.
15:05:18 <newsham> so you cant return noBodyRequest in some instances..
15:05:31 <newsham> cause you dont compute it until after some of the parsing is successful
15:05:57 <newsham> probably best broken down into several pieces that are separate functions
15:06:12 <newsham> like one function for computing Maybe (method, uri)
15:06:31 <xic> also i don't like how readHeaders is executed even if there is a problem with v
15:06:48 <newsham> xic: it might not be, if it can be done lazily
15:07:21 <xic> lazy evaluation is bad enough, but lazy IO just scares me
15:07:38 <xic> my current implementation is not lazy
15:07:41 <newsham> ahh, I didnt realize it was such an evil thing :)
15:07:49 * sorear starts chanting unsafeInterleaveIO! unsafeInterleaveIO!
15:08:16 <dmhouse> My paste is nearly done. It's just the complicated semantics with noBodyRequest that's making it harder.
15:08:21 <newsham> xic: so rip out the first 4 lines of the do-block as their own function
15:08:32 <newsham> check its results, if isJust, do more...
15:09:05 <mbishop> :index getOpts
15:09:16 <newsham> btw, you can use fromMaybe to avoid using case each time you check your results
15:09:17 <mbishop> @index getOpts
15:09:18 <lambdabot> bzzt
15:09:21 <mbishop> heh
15:09:26 <mbishop> :t getOpts
15:09:28 <lambdabot> Not in scope: `getOpts'
15:09:47 <newsham> > fromMaybe 3 (Just 2)
15:09:49 <lambdabot>  2
15:09:53 <newsham> > fromMaybe 3 Nothing
15:09:55 <lambdabot>  3
15:10:17 <newsham> so.. fromMaybe <errorReturn> do { maybe computations }
15:12:03 <Anon4888> Hi shapr :)
15:12:10 <sorear> heh... @karma -rw-r--r
15:14:49 <sorear> @users
15:14:49 <lambdabot> Maximum users seen in #haskell: 296, currently: 274 (92.6%), active: 41 (15.0%)
15:15:09 <sorear> @users fn:#haskell
15:15:10 <lambdabot> Maximum users seen in fn:#haskell: 304, currently: 0 (0.0%), active: 0 (NaN%)
15:15:15 <sorear> @users :#haskell
15:15:15 <lambdabot> Maximum users seen in :#haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:19:36 <newsham> xic: how about this?  http://rafb.net/p/Nv2Ygr91.html
15:19:37 <lambdabot> Title: Nopaste - try again
15:20:20 <lisppaste2> dmhouse pasted "For xic" at http://paste.lisp.org/display/34371
15:20:26 <dmhouse> xic: that's what I've got so far.
15:20:34 <dmhouse> I'm just trying to figure out a nicer way of doing the last bit.
15:20:43 <dmhouse> It might not be totally right, I haven't typechecked it.
15:20:59 <newsham> dhm: yours is pretty similar to mine :)
15:22:24 <dmhouse> There are a few mistakes, hold on.
15:22:34 <dmhouse> Ah, I just figured out a way to make it a lot nicer :)
15:23:00 <xic> dmhouse: actually the headers are supposed to be "key: value" strings, not "key:value"
15:23:09 <dmhouse> xic: ah, okay.
15:23:11 <newsham> he doesnt like reading the headers prior to parsing the method
15:23:32 <newsham> i kept the ordering as xic wanted in my paste
15:23:35 <jcreigh> @karma+ #haskell
15:23:36 <lambdabot> #haskell's karma raised to 3.
15:23:48 <mbishop> 3? heh
15:23:55 <mbishop> @karma+ #haskell
15:23:55 <lambdabot> #haskell's karma raised to 4.
15:24:02 <sorear> @karma+ #haskell
15:24:02 <lambdabot> #haskell's karma raised to 5.
15:25:39 <timthelion> @haskel
15:25:40 <lambdabot> Unknown command, try @list
15:25:47 <timthelion> @help
15:25:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:25:54 <timthelion> @list
15:25:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:26:37 <newsham> ?karma+ chamelion
15:26:38 <lambdabot> chamelion's karma raised to 1.
15:26:53 <sorear> ?karma- chamelion
15:26:53 <lambdabot> chamelion's karma lowered to 0.
15:26:59 <sorear> ?karma+ chameleon
15:26:59 <lambdabot> chameleon's karma raised to 1.
15:27:18 <newsham> ?karma+ karma karma karma chameleon
15:27:19 <lambdabot> karma's karma raised to 2.
15:27:35 <johnnowak> newsham: :)
15:27:41 <sorear> which chameleon: the language?
15:27:50 <newsham> kids these days
15:28:20 <newsham> http://www.youtube.com/watch?v=59Bp6KMyrYs
15:33:30 <metaperl> should runghc -farrows not work? it seems I have to compile when using -farrows
15:35:26 <liyang> newsham: no, kids these days -- http://www.youtube.com/watch?v=WHzqMa9hZew
15:35:42 <newsham> kids these days havent heard of karma chameleon
15:36:21 * timthelion is a kid who hasn't heard of karma chameleon
15:36:42 <newsham> http://www.youtube.com/watch?v=WHzqMa9hZew
15:37:01 <timthelion> newsham: I don't have flash working on fbsd
15:38:06 * jcreigh hadn't either
15:38:09 * dcoutts crosses his fingers and hopes his code will compile
15:38:16 <dcoutts> woo!
15:38:38 * dcoutts has taught c2hs about the GNU C 'typeof' feature
15:38:39 <norpan> john woo
15:39:04 <norpan> just looking at "the killer"
15:39:05 <timthelion> dcoutts: you have to have a firm understanding in order to be content and confident in your code. or else you will end a human, to die a mortals death.
15:39:29 <dcoutts> timthelion, s'ok I know that I'm human :-)
15:39:44 <kilimanjaro> But does your computer know it?
15:39:45 <dcoutts> I use the type checker because I'm too stupid to do without
15:39:46 <lisppaste2> dmhouse annotated #34371 with "xic: finished" at http://paste.lisp.org/display/34371#1
15:39:55 <dmhouse> xic: it's quite a lot nicer :)
15:40:02 * xic looks
15:40:07 <dcoutts> so hopefully c2hs will not fail when parsing glibc-2.4 header files
15:40:19 <kilimanjaro> Well, it's possible to be productive in a language without a static type system
15:40:26 <dcoutts> bah
15:40:31 <dcoutts> I've tried both
15:40:32 <kilimanjaro> Just not necessarily as productive :)
15:43:58 <allbery_b> thta ar saegfault is giving me a headache
15:44:01 <allbery_b> ug
15:44:09 <allbery_b> that ar segfault is giving me a headache
15:45:04 * allbery_b is thinking that's something that "ought" to work but is asking for trouble in practice
15:50:32 <sorear> allbery_b: About a year and a half ago, I got an unexplained oops.  About a year ago, I got a burst of several hundred reports of massive corruption from the ext3 driver.  About six months ago, a program failed to compile because of syntax errors in /usr/include/wxsomething.h.  At that point I clued in, ran memtest86, removed one of my 3 simms, and have had no problems since.
15:52:50 <jcreigh> yeah, if you're getting random segfaults in multiple contexts, grab a Knoppix CD and run memtest86 overnight.
15:54:03 <allbery_b> that wasn't my point
15:54:32 * allbery_b has watched gnuish find and xargs reorder and interleave things on him, in the case of xargs that could be quite bad...
15:55:31 <glguy> ?spell maccaronni
15:55:32 <lambdabot> macaroni macaroon macron macaroons macaroni's
15:59:28 * sorear just edited a _darcs/patches/pending file to merge a pending add with a pending move ... is there a better way?
15:59:59 <sorear> (neither darcs check --complete nor darcs whatsnew are complaining)
16:01:38 <arjanb> sorear: the file moved is the same as the one added?
16:01:50 <sorear> yes
16:02:30 <sorear> move ./IRC.hs ./IRCTemp.hs ; addfile ./IRCBase.hs ; move ./IRCBase.hs ./IRC.hs ; move ./IRCTemp.hs ./IRCBase.hs
16:02:48 <sorear> became : move ./IRC.hs ./IRCBase.hs ; addfile ./IRC.hs
16:03:54 <bd_> ?paste
16:03:55 <lambdabot> http://paste.lisp.org/new/haskell
16:04:36 <arjanb> sorear: that's a bug, darcs should combine it, can you report it?
16:05:01 <arjanb> oh wait the bug tracker is still out of diskspace..
16:05:39 * sorear hopes the bugtracker handles more than just darcs ... a diskful of bugs isn't good :)
16:05:51 <zeeeeeee> i was mining the #haskell logs for discussions on the various GUIs, and i found mention of something called FG - supposed to be inspired by fruit, but with discrete events instead of continuous signals. anybody know where i can find this? google has been most unhelpful.
16:05:55 <augustss> moving and adding seems to confuse darcs, it's happened to to me a couple of times now :(
16:05:59 <lisppaste2> bd_ pasted "Why does this fail in GHC 6.6?" at http://paste.lisp.org/display/34374
16:06:16 <bd_> The code in that paste worked with GHC 6.4, I believe.
16:06:53 <sorear> bd_: -fallow-undecidable-instances
16:07:02 <augustss> bd_: ghc 6.6 has become stricter to guarantee termination
16:07:10 <bd_> oh
16:07:20 <bd_> that worked
16:07:34 <bd_> kind of an unhelpful error, there :/
16:07:55 <augustss> well, you need to read the paper :)
16:08:01 <bd_> heh
16:08:19 <augustss> it could have mention the flag to fix it, like many other messages
16:13:33 <lisppaste2> metaperl pasted "help needed stepwise-analyzing the types of a compound expression" at http://paste.lisp.org/display/34377
16:15:43 <lisppaste2> augustss annotated #34377 with "Perhaps" at http://paste.lisp.org/display/34377#1
16:17:01 <augustss> metaperl: is the original expression type correct?
16:17:24 <metaperl> well a second ago the whole thing compiled..
16:18:08 <augustss> you could try adding ':: Int' on the subexpression you want to know the type of, and see what error message you get
16:18:39 <augustss> or try what I suggested in first
16:18:56 <sorear> maybe -ddump-tc would help? iirc System F has explicit type annotations on *everything*
16:19:20 <sorear> (though Core isn't Haskell, the types *might* be readable)
16:23:47 <metaperl> is there something about runghc -farrows that can't work? must I compile things if I want to use the arrows syntactic extension?
16:24:27 <sorear> does ghci -farrows work ?
16:24:50 <metaperl> yes
16:24:56 <sorear> do you get an error from -farrows, or an error from the arrow-code?
16:25:28 <metaperl> hold on let me tell you
16:28:15 <metaperl> runghc -farrows -i/Users/tbrannon/Documents/haskell/html_seamstress/src greeting.hs
16:28:48 <metaperl> ok, that statement just runs with no feedback... but ghc --make -farrows -i/Users/tbrannon/Documents/haskell/html_seamstress/src greeting.hs -o greeting   --- leads to a compile error
16:29:38 <metaperl> it's odd that runghc simply ran with no comment...
16:29:54 <sorear> not even the print statements in your code?
16:29:55 <metaperl> I dont think runghc can process the syntactic extensions added by -farrows
16:30:10 <metaperl> what print stmts?
16:30:13 <sorear> runghc doesn't process your code
16:30:31 <metaperl> there is a compiler error in my code currently
16:30:32 <sorear> with a name like 'greeting.hs', I assumed it would print something
16:30:42 <metaperl> oh no it writes to a file
16:30:59 <metaperl> but with runghc -farrows, nothing is written (understandably, since there is a compiler error)
16:31:01 <sorear> runghc doesn't even open your file - it rearranges the arguments and runs ghc
16:31:37 <metaperl> it worked find until I tried to add -farrows to the commandline
16:31:40 <sorear> runghc foo ==> ghc -ignore-dot-ghci -e 'withFoo doBar ... Main.main' foo
16:31:54 <sorear> runghc -farrows foo ==> ghc -ignore-dot-ghci -farrows -e 'withFoo doBar ... Main.main' foo
16:32:37 <sorear> to find the actual GHC command line, try using: strace -f -eexec runghc -farrows -i....
16:33:27 <sorear> to find the actual GHC command line, try using: strace -f -eexecve runghc -farrows -i....
16:33:57 <metaperl> strace...
16:34:28 <metaperl> os x lacks strace... hmm
16:34:37 <allbery_b> ktrace
16:34:49 <allbery_b> (although it's rather uglier)
16:34:54 <glguy> the BSD's have ktrace
16:35:01 <glguy> ha, allbery_b ftw
16:35:06 <glguy> s/ha/ah
16:35:09 <allbery_b> run under ktrace, run kdump to translate the trace file to something almost readable
16:35:59 <metaperl> oh -f GHCPATH ...
16:36:06 <metaperl> I think -f means something different to runghc
16:36:18 <metaperl> runghc: syntax: runghc [-f GHCPATH] [GHC-ARGS] FILE ARG...
16:36:36 <sorear> yeah
16:37:00 <sorear> I just ran strace, and saw a bunch of execve("/usr/games/arrows", ...
16:37:03 <metaperl> bingo
16:37:38 <sorear> (ofcourse it wouldn't work since I don't have a   /Users/tbrannon/Documents/haskell/html_seamstress/src/greeting.hs, but still)
16:38:14 <metaperl> have you played with HXT and arrows yet? I have an interesting issue i've been banging my head on all day?
16:38:29 <metaperl> drop that question mark. no question about it :)
16:38:35 <sorear> not me, no
16:38:54 <metaperl> Cale seems to be the only one...
16:38:57 <metaperl> @seen Cale
16:38:57 <lambdabot> Cale is in #oasis, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 3h 20m 26s ago.
16:45:53 <dons> moin
16:45:54 <dons> ?users
16:45:55 <lambdabot> Maximum users seen in #haskell: 296, currently: 270 (91.2%), active: 37 (13.7%)
16:49:26 <nilsi> is it possible to write an unevaluated expression to disk?
16:49:32 <sorear> yes
16:49:40 <sorear> echo '2+2' > /tmp/x # :)
16:50:04 <dons> you can't serialise Haskell functions that I know of, other than by printing the src to disk
16:50:07 <sorear> there is no way to serialize native haskell thunks ATM
16:50:15 <nilsi> i am thinking more in terms of exact real arithmetic ... :)
16:50:24 <allbery_b> no serializing thunks, that I know of
16:50:27 <sorear> but you can fake thunks in any language, even haskell
16:50:35 <nilsi> serialize native thunks was the idea :)
16:50:41 <sorear> and you can serialize fake thunks in any language
16:51:18 <nilsi> no, perhaps in any sufficiently powerfull language ;)
16:51:28 <sorear> yeah /# it seems not be impossible, to use the GHC in
16:51:49 <dons> > 1+2
16:51:51 <lambdabot>  3
16:52:03 <arjanb> ?hoogle Bool -> a -> Maybe a
16:52:04 <lambdabot> No matches, try a more general search
16:52:14 <sorear> it seems not impossible, to use the GHC infoptrs to reflect an arbitrary data structure into an algebraic data type, if you're into RTS-hacking
16:52:21 <dons> sorear: did we disable > in privmsgs somehow...
16:52:29 <dons> (I think it must have been me)
16:52:38 <allbery_b> I noticed it was broken earlier
16:52:41 <sorear> you did something to > in privmsgs
16:53:01 <nilsi> aehmm i am more in random thoughts than rts hacking :/
16:53:06 <dons> drink coffee >> fix lambdabot
16:53:36 <nilsi> maybe distributed haskell or something can send thunks over networks
16:54:21 <sorear> GHC has a very strong assumption that code is kept in code segments and raw pointers can be made to it.
16:54:35 <nilsi> but it would be platform dependant anyway
16:54:37 <sorear> a more dynamic Haskell would keep code in unboxed Char arrays
16:55:06 <nilsi> hmm maybe yhc?  (interpreted iirc)
16:55:24 <sorear> then thunks would simply have pointers to heap objects, and a cycle-detecting serializer could send it all to disk...
16:55:34 * sorear is also into random musings
16:55:54 * seancorfield is new here
16:56:04 <sorear> good!
16:56:17 <sorear> we like getting new people
16:56:24 <dons> welcome!
16:56:27 <seancorfield> hi... i only just found out about this channel... i've been dabbling with haskell for a few years on and off and recommending it to others
16:56:28 <seancorfield> thanx
16:56:31 <sorear> the lambda revolution needs followers
16:56:47 <dons> > map (^2) [1..] -- just for fun :)
16:56:49 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
16:56:57 <dons> :t map
16:56:58 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:57:03 <dons> ?src map
16:57:04 <lambdabot> map _ []     = []
16:57:04 <lambdabot> map f (x:xs) = f x : map f xs
16:57:07 <dons> :)
16:57:18 <seancorfield> i read about the bot on the haskell.org page :)
16:57:20 <sorear> group $ scanl (+) $ map (recip . (^2)) [1..]
16:57:23 <sorear> > group $ scanl (+) $ map (recip . (^2)) [1..]
16:57:24 <lambdabot>  Couldn't match `[a]' against `[[a1]] -> [[a1]]'
16:57:28 <sorear> > group $ scanl (+) 0 $ map (recip . (^2)) [1..]
16:57:30 <lambdabot>  [[0.0],[1.0],[1.25],[1.3611111111111112],[1.4236111111111112],[1.46361111111...
16:57:49 <sorear> > head $ head $ dropWhile (null . tail) $ group $ scanl (+) 0 $ map (recip . (^2)) [1..]
16:57:53 <lambdabot> Terminated
16:58:05 <spiffy> ?where lambdabot
16:58:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:58:11 <sorear> > dropWhile (null . tail) $ group $ scanl (+) 0 $ map (recip . (^2)) [1..]
16:58:16 <lambdabot> Terminated
16:58:28 <nilsi> i read about exact real arithmetics and wondered about the idea of having an integrated real type [1.8, 2.6 ,  <unevaluated pi calculation, precision unknown i.e. not yet forced> ]
16:58:48 <nilsi> as example of [Real]
16:58:49 <sorear> > scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:58:50 <lambdabot>  [0.0,1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.491...
16:59:13 <sorear> > map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:15 <lambdabot>  [0.0,2.449489742783178,2.7386127875258306,2.8577380332470415,2.9226129861250...
16:59:22 <nilsi> poor lamdabot
16:59:30 <sorear> > (!!30) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:32 <lambdabot>  3.1101287281412624
16:59:32 <nilsi> @botsnack
16:59:33 <lambdabot> :)
16:59:36 <sorear> > (!!300) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:37 <lambdabot>  3.1384132451584086
16:59:41 <sorear> > (!!3000) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:42 <lambdabot>  3.141274380627342
16:59:46 <sorear> > (!!30000) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:47 <lambdabot>  3.141560822970433
16:59:50 <sorear> > (!!300000) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
16:59:53 <lambdabot>  3.141589470494652
16:59:58 <sorear> > (!!3000000) $ map sqrt $ map (*6) $ scanl (+) 0 $ takeWhile (/= 0) $ map (recip . (^2)) [1..]
17:00:03 <lambdabot> Terminated
17:00:56 <astrolabe> Does anyone know where the activity graph for #haskell is?
17:01:06 <sorear> @where stats
17:01:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:01:12 <sorear> lambdabot does
17:01:19 <astrolabe> gratzie!
17:01:31 <nilsi> @where lambdabot
17:01:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:02:48 <astrolabe> I wonder what causes the spike in activity around the new year
17:03:03 <sorear> I wonder too
17:03:09 <sorear> @users #haskell
17:03:10 <lambdabot> Maximum users seen in #haskell: 296, currently: 272 (91.9%), active: 39 (14.3%)
17:03:12 <sorear> @users fn:#haskell
17:03:13 <lambdabot> Maximum users seen in fn:#haskell: 304, currently: 0 (0.0%), active: 0 (NaN%)
17:03:32 <dons> sorear: ah!
17:03:44 <dons> astrolabe: blogs?
17:03:52 <sorear> yes, it's my fault
17:03:56 <dons> and people not working == wasting time hacking new languages ?
17:03:57 <allbery_b> people have time off to poke at irc?
17:04:41 <nilsi> #haskell is better than google
17:04:59 <seancorfield> i was discussing closures with a coldfusion programmer and they mentioned they were learning haskell...
17:05:06 <sorear> @remember nilsi #haskell is better than google
17:05:07 <lambdabot> Done memoising quote for `nilsi', if that is their real name...
17:05:09 <sorear> *** Unknown command: REMEMBER
17:05:23 <seancorfield> since i'd been talking about haskell for a while, i thought i'd see what other resources i could find
17:05:27 <dons> I think #haskell makes a great IDE. you can view src, types, run code *and* talk to other haskellers (== better than eliza)
17:05:27 <seancorfield> and him i am :)
17:05:47 <seancorfield> him = here
17:06:00 <sorear> if there are no haskellers you CAN talk to eliza ... @vixen-on
17:06:08 <astrolabe> dons: no, I mean in the channel population
17:06:32 <xpika> @vixen-on
17:06:33 <lambdabot> Not enough privileges
17:06:43 <dons> astrolabe: yeah, so do I :) though its be driving upwards since August or so
17:06:43 <sorear> (disabled for normal users because of abusability)
17:06:53 <dons> we hit 250 in august, 300 in early Dec
17:07:13 <astrolabe> why do you think #haskell makes a great IDE. you can view src, types, run code *and* talk to other haskellers (== better than eliza)?
17:07:17 <xpika> programming 2.0 must be taking off then
17:07:56 <nilsi> @quote nilsi
17:07:56 <lambdabot> nilsi says: #haskell is better than google
17:08:04 <nilsi> :D  thanks
17:08:51 <sorear> @quote google
17:08:52 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
17:08:52 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
17:08:58 <sorear> @quote google
17:08:59 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
17:08:59 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
17:09:01 <sorear> @quote google
17:09:02 <lambdabot> nilsi says: #haskell is better than google
17:09:09 <sorear> @quote spelline
17:09:10 <lambdabot> ghc says: Plugin/Spell.hs:35:31: Not in scope: `spellineNazi'
17:11:55 <nilsi> is there a haskell raytracer able to render boxes (i found a lot rendering spheres)   ?
17:12:32 <nilsi> i wrote a hopengl 3d editor but it needs povray atm :/
17:13:26 <sorear> write one, it's easy!  hint: a box is the intersection of six plane, each of which is a degenerate quadric
17:13:46 <sorear> (if neccessary)
17:14:40 <nilsi> no,  i chose haskell for being lazy  in the first place
17:14:56 <nilsi> :)
17:14:59 <sorear> ok :)
17:15:21 * sorear would really like column-number-mode for mg
17:15:28 <koala_man> hope n gl. what a reassuring name
17:15:45 <dons> there's 10 or so raytracers on the haskell.org wiki. have you seen those?
17:15:50 <dons> on the 'libraries and applications' page
17:16:04 <nilsi> i glanced over them once
17:16:47 <nilsi> some of them cant read  .pov files  ;)
17:16:48 <dons> does anyone know what this is about? http://cohatoe.blogspot.com/2007/01/building-server-executable.html
17:16:50 <lambdabot> Title: Leif Frenzel's Haskell and Eclipse blog: Building a server executable, http://tinyurl.com/stpek
17:16:57 <reppie> http://www.jmlg.org/open_problems.htm
17:17:04 <lambdabot> Title: Open Problems
17:17:10 <dons> oh, more on nubgames + Haskell, http://programming.reddit.com/info/xb9o/details
17:17:17 <lambdabot> Title: Language redundancy: gzipping Java, Haskell and Ruby (reddit.com)
17:18:47 <sorear> pretty much nothing can parse .pov files - it's a turing equivalent language
17:19:39 <nilsi> i generate pov files atm  and call system.cmd "povray myfile.pov"
17:19:52 <nilsi> but it is very fragile and system dependant
17:20:25 <seancorfield> anyone know of a pre-built Intel OS X haskell compiler? nhc98 has a ppc binary for 1.18 which was what i was using on my old laptop...
17:20:30 <nilsi> i would happily link povray in, but there license is *interesting*
17:21:00 <nilsi> read:  their
17:21:03 <seancorfield> happy to build from source but i wondered if i could save some time there :)
17:21:20 <chr1s> hey guys
17:21:34 <chr1s> I've built MissingH with cabal (from the darcs repo)
17:21:42 <sorear> is there no binary on haskell.org/ghc?
17:21:47 <nilsi> you can build jhc .. than every build process feels like saving time
17:21:48 <chr1s> and it works quite nice
17:22:11 <chr1s> but when I try to profile my code, it says it can't find Data.String
17:22:25 <chr1s> do I need to install some profilable version too?
17:23:01 <sorear> does there exist yet a computer powerful enough to bootstrap jhc? :)
17:23:31 <seancorfield> ghc has a ppc osx build (found that on google) but not an intel osx build it seems
17:23:51 <allbery_b> hm?  I just checked there and found the intel build just below the ppc one
17:23:53 <sorear> does WINE support intel OSX?
17:24:27 <seancorfield> allbery_b: url? i couldn't find it
17:24:28 <allbery_b> at the very bottom of the download page
17:24:52 <allbery_b> http://haskell.org/ghc/download_ghc_66.html#macosxintel
17:24:54 <lambdabot> Title: GHC: Download version 6.6
17:24:59 <dons> nilsi: pretty sure there's GHC for the mac intentl now
17:25:04 <seancorfield> thanx folks
17:25:08 <dons> I think audreyt runs it
17:26:16 <seancorfield> might go ahead and build nhc98 anyway since that's what i was running before on ppc :)
17:27:13 <sorear> you should also look at yhc, it's trying to be the successor to nhc98 (more portable for a start)
17:27:18 <sorear> @where yhc
17:27:19 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
17:28:07 <sorear> and it does other nice things, like compile-to-javascript option
17:29:00 <seancorfield> to javascript? the mind boggles...
17:31:05 <sorear> @go ycr2js
17:31:12 <lambdabot> http://www.haskell.org/pipermail/haskell/2006-November/018725.html
17:31:12 <lambdabot> Title: [Haskell] ANN YCR2JS, a Yhc Core to Javascript Converter
17:31:16 <koala_man> haha, it's uber
17:32:45 <koala_man> 3000 lines of javascript in the echo example
17:33:11 <nilsi> we need a plankalkul backend !!!
17:33:27 <dons> there's a runtime compiled in there, I guess
17:34:03 <nilsi> probably a few runtimes ..
17:34:42 <sorear> it should be lazier about outputting the runtime...
17:34:58 <sorear> (also the echo example converts roman numerals)
17:42:17 <seliopou> @hoogle lift
17:42:18 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
17:42:19 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
17:42:19 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
17:45:02 <seliopou> ?instances MonadIO
17:45:03 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
17:55:16 <pbx> Hi Haskellites
17:55:38 <pbx> I just made a few Plucker files of Haskell docs for myself and figured I'd share.
17:55:46 <pbx> http://e-scribe.com/temp/HaskellTutorial.pdb
17:55:59 <pbx> http://e-scribe.com/temp/HaskellforCprogrammers.pdb
17:56:05 <pbx> and of course
17:56:17 <pbx> http://e-scribe.com/temp/HaskellReport.pdb
17:57:15 <dons> what are Plucker files?
17:57:37 <pbx> Sorry -- Plucker's an offline reader format for PalmOS etc.   http://plkr.org/
17:57:42 <dons> (perhaps you'd like to drop a note to the haskell-cafe@haskell.org mailing list, with this then?)
17:57:51 <lambdabot> Title: Plucker, the best offline HTML and ebook reader for Palm devices
17:57:56 <dons> maybe even link to them on haskell.org's page for these tutorials
17:58:20 <pbx> dons: I wouldn
17:58:25 <pbx> ... oop
17:58:31 <dons> pbx++ good work, btw
17:58:40 <pbx> I wouldn't mind if someone copied them, certainly.
18:01:16 <pbx> Gotta run. But I think I've settled on Haskell as my new language for 2007, so I'll be back!
18:11:27 <dons> sorear: want to talk about this sync thread design?
18:11:46 <dons> how does it affect lambdabot's ability to process jobs asynchronously?
18:11:58 <timthelion> hmm, http://rafb.net/p/ibRkT959.html does not work. it gives me multiple declaration errors, but I thought that the whole point of the patern matching thing was to allow what I did
18:12:05 <lambdabot> Title: Nopaste - No description
18:12:12 * timthelion is on his first day with haskel
18:12:14 <dons> sorear: this sounds very promising though:
18:12:15 <dons>   * Side effects:
18:12:15 <dons>     There is no longer a need for the synchronization MVars
18:12:28 <dons> I'll have a look, timthelion
18:12:45 <dons> ?paste <-- is preferred, since you get irc announces+ syntax highlighting.
18:12:46 <lambdabot> http://paste.lisp.org/new/haskell
18:13:13 <sorear> the forkLB at IRC.hs:114 gives us asynchronous jobs
18:13:25 <beelsebob> buh
18:13:27 <mauke> toHelpString _ = _ ++ " is undefined.  No known function named "++_++"." looks wrong
18:13:28 * beelsebob is full of rum
18:13:30 <beelsebob> and wiskey
18:13:50 <sorear> but by making the jobs themselves synchronous, it's much easier to handle syncronous protocols.
18:14:21 <lisppaste2> timthelion pasted "math program which won't compile" at http://paste.lisp.org/display/34387
18:14:32 <sorear> mauke: _ is special cased, you need a different name
18:14:48 <mauke> not my code
18:14:52 <timthelion> mine
18:14:53 <beelsebob> timthelion: what's the error?
18:15:17 <sorear> _ means 'no name'
18:15:20 <timthelion> multiple declarations of Math.toKeyWords
18:15:35 <timthelion> and all the other functions that I have multiple declarations of
18:15:58 <lisppaste2> beelsebob annotated #34387 with "doom" at http://paste.lisp.org/display/34387#1
18:16:13 <beelsebob> oops, missed one
18:16:18 <beelsebob> too much wiskey and rum and doom
18:17:03 <timthelion> so am I compleatly confused
18:17:09 <sorear> you can have fun _ _ = foo and it will work
18:17:17 <timthelion> or is there just some little thing I have missed
18:18:16 <timthelion> sorear: was that to me?
18:18:30 <beelsebob> timthelion: the symbol "_" means "this variable has no name, because it is uninteresting, and I will never refer to it again"
18:18:43 <beelsebob> because of that, you can't refer to it on the right hand side
18:18:47 <sorear> also, all patterns for one function must be together - you can't interleave function definitions
18:18:47 <sorear> toKeyWords is interleaved with eg. toLongName, and that Won't Do
18:18:55 <beelsebob> if you want to use it on the right hand side, then give it a proper name
18:19:06 <sorear> yes
18:19:11 <sorear> I lagged somehow
18:19:32 <sorear> did all my messages appear at once?
18:19:40 <timthelion> sorear: so my design is not going to work
18:19:41 <beelsebob> yes
18:19:48 <beelsebob> timthelion: it will work
18:19:53 <beelsebob> you just need to refactor a bit
18:20:05 <sorear> timethelion: try using records
18:20:29 <timthelion> ok,
18:20:35 * timthelion looks up records
18:21:17 <dons> ?paste
18:21:18 <lambdabot> http://paste.lisp.org/new/haskell
18:21:22 <sorear> dons: another maybe side effect: run a --online patched lambdabot, and invoke @list-all.  it will die after 15 seconds of flood control, thus cutting off the flood.
18:21:45 <lisppaste2> dons pasted "tim's refactor" at http://paste.lisp.org/display/34388
18:22:02 <dons> timetthere's still a couple of type errors in there though, timthelion
18:22:05 <dons> ^^
18:22:24 <dons> sorear: ok. that sounds useful (?)
18:22:49 <timthelion> ok thanks!
18:23:27 <dons> you know there's already functions divMod quotRem?
18:23:33 <dons> :t divMod
18:23:34 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
18:23:40 <dons> > divMod 10 3
18:23:41 <lambdabot>  (3,1)
18:24:02 <dons> > quotRem 10 3
18:24:04 <lambdabot>  (3,1)
18:24:33 <sorear> > divMod (-10) 3
18:24:34 <lambdabot>  (-4,2)
18:24:38 <sorear> > quotRem (-10) 3
18:24:40 <lambdabot>  (-3,-1)
18:25:00 * beelsebob pounces on dons
18:25:07 <beelsebob> how did the hacking go?
18:25:32 <dons> hmm?
18:25:39 <beelsebob> hackathon
18:25:50 <dons> its next week (in a few days)
18:25:53 <beelsebob> o.O
18:25:56 <beelsebob> oh... course
18:25:59 <beelsebob> same time as TCS soup
18:26:38 <allbery_b> it can't be over, we don't have hs-plugins for 6.6 yet...
18:26:42 <allbery_b> :p
18:26:57 <dons> that's right!
18:26:58 <beelsebob> hehe
18:27:47 <sorear> my patch would be ~50 lines, if ghc supported recursive modules.  Whine whine whine.
18:28:02 <beelsebob> lol
18:28:03 <dons> it does though...
18:28:10 <dons> why do you think we have .hs-boot files in there already?
18:28:18 <sorear> you have to write hs-boot files
18:28:41 <sorear> what if Lambdabot depends on symbols IRC with types that mention LB?
18:29:10 <sorear> IRC.hs-boot depends on Lambdabot (for LB) depends on IRC.hs-boot ... now I have to write Lambdabot.hs-boot
18:30:01 <glguy> hs-boot?
18:30:52 <sorear> it's an extension
18:31:17 <sorear> used by the disgusting hack that GHC uses to "support" mutually recursive modules
18:31:50 <allbery_b> oh, *that's* what those are
18:31:52 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/separate-compilation.html#mutual-recursion
18:31:54 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/y48y7f
18:33:05 <dons> sorear: avoid recursive modules if you can
18:33:35 <dons> we want to keep the IRC.hs module separate anyway
18:33:48 <dons> its supposed to be a generic IRC lib, or that was the plan when we split it off lambdabot.hs
18:39:27 <sorear> incase it was lost amongst beelsebob/timthelion, we have asynchronous command processing in the online case through IRC.hs:114
18:40:38 <sorear> what luck - a callback is a better choice for a library interface, but I used it simply to avoid recursive type dependencies ...
18:42:32 <dons> sorear: yes, I'm looking at the patches now
18:42:42 <dons> so this was required for the various offline/oonline refactoring?
18:46:13 <sorear> I'm not sure
18:46:22 <sorear> it was the approach taken in take-1
18:47:00 <dons> "    Offline mode no longer has a timeout.
18:47:06 <dons> " -- what happens on network timeouts?
18:47:14 <dons> like google not responding
18:47:46 <sorear> sounds like a good reason to have a timeout on offline mode
18:49:57 <sorear> any reason forkLB is pointy?
18:50:36 <dons> hmm? forkLB f = (`liftLB` f) $ \g -> do
18:50:36 <dons>             forkIO $ do
18:50:36 <dons>                 timeout (15 * 1000 * 1000) g
18:50:36 <dons>                 return ()
18:50:36 <dons>             return ()
18:51:05 <sorear> forkLB = liftLB $ \g -> do   -- looks clearer to me
18:51:25 <dons> ah yes :)
18:51:26 <dons> not sure why that is what it is
18:54:00 <ohmega> it's amazing how concrete everything in haskell feels when you've been working in a dependently typed language for a while ;)
18:55:42 <sorear> ok, I run lambdabot and it just quits instantly
18:55:47 <dons> sorear: can we use 'forever' for sequence_ . repeat
18:56:00 <sorear> this started when I killed it too forcefully
18:56:16 <sorear> dons: yes.  I didn't realize you had that :)
18:56:35 <sorear> ^C in strace, which overrides the signal-handlers
18:56:48 <sorear> do I need to delete some state-file?
18:57:16 <dons> I'm still seeing really big fundamental changes that need more documentation. I don't fully understand where each patch is coming from, what is its motivation and what problems it solves
18:57:28 <dons> so can you add more docs on these fundamental architecture changes in future?
18:57:49 <dons> since I need to be able to understand how the architecture has changed, and what if any impac that has.
18:58:05 <sorear> hm .. where would they go?
18:58:15 <dons> in the patch comment
18:58:41 <dons> explain why you're moving files, why you are making things synchronous and so on what had to be changed to make this posisble
18:58:44 <dons> that kind of thing
18:58:58 <dons> it just helps out the other devs (i.e. me :)
18:59:16 <dons> and helps you , since sometimes I can think of issues related that you mightn't have considered
18:59:36 <dons> but I need more patch docs to best make this happen :)
18:59:54 <sorear> agreed ... must try harder ... (a good bit of inertia from 7 yrs of personal-projects)
19:00:39 <dons> i.e. "  * threading rearchitecture, make almost everything synchronous" I can only guess as to why you're doing this. also, its good to list what has to be changed in the patch
19:00:58 <dons> i.e. "Need to move X to Y, because ...."
19:01:05 <dons> "This type changes, because ..."
19:01:15 <dons> then I learn more about what problems you're facing
19:01:37 <dons> keep up the good work!
19:01:41 <sorear> I can't figure out a sane way of extending the synch MVars to the multi-server case
19:02:08 <sorear> oh, wait, click, hope I won't need it
19:02:37 <dons> the sync MVars were only needed for forcing synchronisatoin in offline mode, no?
19:02:45 <dons> because the whole bot was a-sync before that
19:03:32 <dons> the 'quit instantly' issue is usually a Binary parse failure in the state files
19:03:37 <dons> if they be came corrupted somehow.
19:03:53 <dons> we should probably check for sane values in the Binary instances, to avoid this
19:04:05 <sorear> would a force-kill be able to corrupt the state files?
19:04:48 <dons> hmm, perhaps if a handled isn't closed?
19:04:58 <dons> I prefer -TERM for shutting down the bot
19:05:10 <dons> since that's explictitly set up to flush the state
19:05:13 <dons> and exit cleanly
19:06:19 <sorear> I was running the bot under strace (which disables sigaction), and hit ^C without thinking
19:07:43 <sorear> I just added a print-statement to the exception exit path (will send patch)
19:07:53 <dons> sorear: now, how have the timeouts changed?I need to understand if the bot's behaviour is going to change if I run it in here.
19:07:54 <sorear> Initialising plugins ..........Plugin.Djinn: couldn't find djinn binary.......................exception:State/seen: hGetChar: end of file
19:08:25 <sorear> you were right :)
19:09:20 <dons> we might be able to catch that, and return a default value instead.
19:10:00 <sorear> the timeouts should not have changed, since I'm still using forkLB for asynchonous command processing (in the online case)
19:10:09 <Saizan> (possibly repeated bug report:do you know that ">" in /msg isn't working?)
19:10:21 <sorear> I think it's good that the bot is very noisy about loosing state.
19:10:30 <dons> yep. I'll be fixing that today, Saizan
19:10:30 <sorear> Saizan: yes, repeated, we know.
19:10:39 <dons> use @run
19:11:01 <Saizan> k, ^^
19:16:04 <ailndx> anyone built hs-plugins in win?
19:16:30 <SamB> supposedly someone has
19:16:40 <SamB> but I do not know if they have revealed their secrets or not
19:17:09 <sorear> dons: can you give a command that trips the timeout? (testing purposes)
19:17:54 <ailndx> dons: did you port hs-plugins to 6.6 yet?
19:18:11 <dons> ailndx: nope. but 6.4.2 ghc + hs-plugins does work on win32
19:18:30 <dons> sorear: I though a google search would do. but seems not
19:18:38 <dons> (also, pull some patches ...)
19:18:44 <sorear> @unpl has no internal timeout, I see
19:18:45 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 24}: Parse error
19:19:49 <ailndx> dons: i heard, but i didnt get it to work
19:19:53 <sorear> I just got two inverse patches
19:20:23 <sorear> UNDO ... and rollback Base .. have equal and opposite changes
19:20:43 <ailndx> dons: if it works on win32, someone should spend 5 minutes on writing a tutorial on how to config/install it
19:21:49 <sorear> ?unpl (.).(.).(.).(.(.)).((.).(.(.)))
19:21:50 <lambdabot> (\ w b c f i p -> w (\ r s -> b c f i (p (r s))))
19:21:56 <sorear> ?unpl (.).(.).(.).(.(.)).((.).(.(.))).($)
19:21:56 <lambdabot> (\ y b c f i p -> y (\ r s -> b c f i (p (r s))))
19:22:26 <sorear> ?quote (x{0,5}){0,5}
19:22:27 <lambdabot> Bulat says: Base lib includes everything, from 'const' to starship control
19:22:30 <twanvl> I have build hs-plugins on win32, I don't recal doing anything special
19:22:41 <sorear> ?quote ((((x{0,5}){0,5}){0,5}){0,5}){0,5})
19:22:52 <lambdabot> mwc says: casino royale == KingT StdGen IO ()
19:23:10 <sorear> thank goodness for exponential-time regex engines!
19:23:32 <sorear> ?quote ((((((x{0,5}){0,5}){0,5}){0,5}){0,5}){0,5})
19:23:38 <ailndx> twanvl: special.. and special, i suppose you have to edit the config file and stuff at least first?
19:24:31 <ailndx> i got hs-plugins to build, but not to run
19:24:34 <sorear> dons: check your RAM!
19:24:52 <twanvl> how does it not run?
19:25:00 <ailndx> i got some error message
19:25:15 <sorear> lambdabot has a massive space leak somewhere, and my machine went from 20MB/384MB to thrashing when I ran that ?quote
19:25:42 <mauke> threading is hard :(
19:26:06 <lisppaste2> timthelion annotated #34387 with "type error that I can't fix" at http://paste.lisp.org/display/34387#2
19:26:44 <ailndx> twanvl: and did you use msys or cygwin or something?
19:26:55 <twanvl> I used msys
19:27:07 <ailndx> ok, i tried with that also
19:27:27 <timthelion> can someone please tell me what is the cause of my errer
19:27:30 <mauke> timthelion: it's f x y z, not f(x, y, z)
19:27:43 <sorear> is the !-threaded RTS pre-emptive?
19:28:00 <ailndx> twanvl: could you guide me through the install?
19:28:20 <twanvl> I really don't remember what I did, sorry
19:29:04 <timthelion> mauke: thanks
19:30:20 <glguy> timthelion: this isn't going to work
19:30:22 <glguy> main = putStrLn ( show (compute ((head . words) getArgs, unwords((tail . words) getArgs))))
19:30:27 <sorear> oooh, lambdabot segfaulted
19:30:27 <glguy> ?type getArgs
19:30:29 <dons> sorear: ram is fine,  20M or so, seems to run in constant space on openbsd
19:30:36 <dons> however, 99.02% lambdabot
19:30:43 <sorear> still?
19:30:44 <dons> so we need a timeout on regexec...
19:30:54 <glguy> would you two quite breaking lambdabot , some of us are trying to do some work
19:30:58 <glguy> quit*
19:31:08 <allbery_b> heh
19:31:18 <sorear> my lambdabot just alloced 3G of RAM & segfaulted (not OOM-killed, segfaulted)
19:32:28 <dons> sounds like a flaw in the regex lib ;)
19:32:45 <sorear> I have a 32-bit computer
19:32:56 <sorear> hence, >3G -> malloc returns NULL
19:33:04 <dons> yeah, it shouldn't need that much ram....
19:33:07 <sorear> (also Linux uses allocate-on-write)
19:33:19 <sorear> dons: was that you, or did LB crash?
19:33:24 <dons> that was me
19:33:32 <dons> I ave up on waiting for that regex to finish
19:33:46 <glguy> timthelion: like I was saying
19:33:48 <glguy> ?type getArgs
19:33:56 <dons> your next mission is to add a timeout on regexec ...
19:34:00 <sorear> perlre lists that specific regex as a pathological case
19:34:07 <lambdabot> Not in scope: `getArgs'
19:34:34 <glguy> ?type System.getArgs
19:34:36 <lambdabot> IO [String]
19:35:36 <sorear> does openbsd use glibc?
19:35:50 <allbery_b> nope
19:35:51 <glguy> it uses libc
19:35:59 <allbery_b> glibc is mostly a linux perversion :)
19:36:16 <timthelion> glguy: so that won't work, why?
19:36:33 <glguy> timthelion: have you read through YAHT yet?
19:36:47 <timthelion> glguy: the first chapter
19:37:49 <glguy> You should keep going, but in this case it's because getArgs :: IO [String] and not [String]
19:39:33 <timthelion> oh. I didn't think there would be a difference.
19:39:38 <timthelion> I guess I will find out
19:39:51 <glguy> yeah, you'll really do yourself a favor to keep working through the tutorial
19:40:09 <timthelion> it all seemed so simple. but I guess it's not
19:41:08 <dons> main = getArgs >>= print . reverse
19:41:13 <mauke> it is simple :-)
19:41:32 <glguy> timthelion: yeah, its simple, but you aren't going ot be able to skip chapters 2 on
19:41:33 <mauke> getArgs is not a list of strings, but a data structure describing how to obtain a list of strings
19:42:04 <dons> to force sidee effects (like IO), you can use >>= and >> to order computations. or use the do-notation for the same thing
19:42:09 <dons> main = do a <- getArgs ; print (reverse a)
19:43:01 <glguy> what is that code you pasted trying to do?
19:43:18 <dons> ?unpl do a <- getArgs ; print (reverse a)
19:43:19 <lambdabot> do { a <- getArgs; print (reverse a)}
19:43:27 <dons> ?undo do a <- getArgs ; print (reverse a)
19:43:28 <lambdabot> getArgs >>= \ a -> print (reverse a)
19:43:40 <dons> ?. pl undo do a <- getArgs ; print (reverse a)
19:43:40 <lambdabot> print . reverse =<< getArgs
19:43:41 * timthelion has been programing for 4 years and finds haskel to be beeten in awsomeness only by lisp and was so exited by the possibluilities that he ran up the mountain without a tent supper or raingear.
19:44:00 <dons> haskell (two 'l's) :)
19:44:07 <glguy> timthelion: If you want to understand why it beats lisp, keep reading that tutorial ;)
19:44:13 <reppie> how is lips better?
19:44:17 <dons> its like lisp, but with more fun things
19:44:29 <dons> since lisp is like a baby haskell from 1985
19:44:34 <dons> (with macros)
19:45:07 <Excedrin> dons: and a great debugger
19:45:20 <sorear> dons: how do you suggest dealing with the massive memory use of glibc-regex?
19:45:27 <augustss> and quote and eval
19:45:28 <timthelion> glguy: it is going to be a calculator, ie to do synthetic divition at the cli : math sd 2 3 3 4 would print 3 9 22
19:45:34 <dons> sorear: hmm.
19:45:53 <dons> sorear: use a different regex lib?
19:46:05 <dons> the parsec one? or the dfa one?
19:46:11 <rashakil> buy more memory
19:46:22 <sorear> rashakil: it's exponential
19:46:27 <dons> sorear: or ban the pathological case?
19:46:38 <dons> i.e. no {n,m}
19:46:45 <rashakil> buy exponentially more memory
19:46:49 <dons> :)
19:47:28 <timthelion> dons: over an exponetialy increasing amount of time the exponential amount of memorie you need will become exponetialy cheep no?
19:47:33 <glguy> timthelion: so would: -2 -3  yield 1 5 6?
19:47:54 <dons> sorear: don't use linux's regex.h? :)
19:48:06 <sorear> Text.Regex.Posix.ByteString
19:48:06 <rashakil> over a linearly increasing amount of time it seems like it gets exponentially cheap
19:48:19 <timthelion> glguy: no, the one implemented funtion of many I will implament does synthetic divition of polynomials
19:48:36 <timthelion> glguy: hopefully the helpstring on sd would tell you
19:48:46 <SamB> there is a certain difficulty in increasing the memory of a system *while it is yet running*
19:49:12 <timthelion> SamB: at some point in the future, there will be a way
19:49:15 * sorear wonders if OpenBSD regcomp/regexec was *designed* to resist "algorithmic complexity attacks"
19:49:33 <rashakil> SamB: oh please, all you need to do is increase the processor's word size as needed.
19:49:59 <sorear> is there a GHC equivalent to GCC's __linux__?
19:50:03 * augustss is flabbergasted.  There's a connection between Haskell and OSGi!  http://cohatoe.blogspot.com/2007/01/building-server-executable.html
19:50:05 <SamB> most systems I've dealt with don't even want you to plug in more RAM without turning off the power!
19:50:11 <lambdabot> Title: Leif Frenzel's Haskell and Eclipse blog: Building a server executable, http://tinyurl.com/stpek
19:50:15 <Saizan> mmh, haskell lacks helpstrings i suspect (if helpstrings are like python's)
19:50:33 <SamB> (as evidenced  by the numerous cables blocking access to the RAM slots)
19:50:58 <timthelion> SamB: but once we get good flash
19:51:12 <timthelion> SamB: you'll just put in another terabite sd card
19:51:17 <sorear> how bout FAST flash?
19:51:34 <dons> augustss: yeah I saw that. and am still trying to work out what he's doing...
19:51:40 <sorear> DRAM is *much* faster then surrent flash.
19:51:41 <Philippa> timthelion: swap space on floppies!
19:51:58 <augustss> dons: I don't know what he's doing, but I was there when OSGi was born. :)
19:52:02 <SamB> isn
19:52:16 <SamB> 't the flash supposed to be able to vibrate his way through ice and stuff?
19:52:37 <Philippa> I hope that's not a euphemism
19:52:50 <augustss> dons: I was part of the standardization process for Ericsson.  I'm just surprised to ever see a connection. :)
19:52:51 <SamB> no euphemism
19:53:08 <sorear> does ghc define __GLIBC__ or anything like that?
19:53:22 <SamB> sorear: why would it?
19:53:25 <augustss> sorear: that would be sick
19:53:41 <SamB> __GLASGOW_HASKELL__, sure...
19:53:44 <SamB> __GLIBC__, no.
19:53:51 <sorear> I want to avoid the broken glibc Text.Regex.Posix.*
19:54:28 <sorear> so, a foreign call *can't* be interrupted by a killThread?
19:54:48 <glguy> timthelion: still there?
19:55:01 <timthelion> yes
19:55:08 <glguy> code for you:
19:55:21 <bd_> sorear: Interrupting a foreign call with a killThread sounds like it might cause some interesting crashes :)
19:55:32 <timthelion> :?
19:55:51 <timthelion> glguy: to use lojban, : ma
19:56:05 <glguy> > let sd c (x:xs) = result where result = x : zipWith f xs result ; f x p = x + c * p in 2 [3,3,4]
19:56:06 <lambdabot>   add an instance declaration for (Num ([a] -> a1))
19:56:06 <lambdabot>     In the definition of ...
19:56:18 <glguy> > let sd c (x:xs) = result where result = x : zipWith f xs result ; f x p = x + c * p in sd 2 [3,3,4]
19:56:19 <lambdabot>  [3,9,22]
19:56:21 <bd_> sorear: Probably better to just write a pure-haskell regex engine...
19:56:27 <glguy> timthelion: I don't know lojban
19:56:47 <timthelion> glguy: ma means fill in the blank, which you did
19:57:11 <glguy> (I was trying to test it by sending it to lambdabot first, but lambdabot has been acting flaky tonight
19:57:38 <dons> we have several pure haskell regex engines
19:57:39 <dons> so maybe it *is* better to just use that
19:57:39 <dons> i.e. regex-parsec or regex-dfa
19:59:03 <dons> ?where regex-parsec
19:59:04 <lambdabot> http://darcs.haskell.org/packages/regex-parsec/
20:00:21 <sorear> well, building a DFA will take lots o' ram in pathological cases (Glibc regex does it), I wonder how regex-dfa is guarded...
20:00:26 <sorear> @where regex-dfa
20:00:26 <lambdabot> http://darcs.haskell.org/packages/regex-dfa/
20:00:42 <glguy> timthelion: your compute function should parse the input string, and pass that off to a function that deals in numbers
20:01:04 <glguy> timthelion: when you combine everything into one function, it makes more difficult and less useful
20:03:00 <dons> sorear: but the thing is, we can take the dfa source, and disable lots of nasty regex patterns :)
20:03:08 <dons> just giv em .* and $ ^
20:04:20 <sorear> oh, if I have .* only I can do it much faster... like log-time for a constant string
20:04:20 <allbery_b> + might be nice too.  {n,m} and (foo|bar) can go :)
20:05:37 <timthelion> glguy: ok, thanks, I will attempt to understand your code.
20:06:09 <sorear> idea - frisby backend.  haven't played with it yet, but it claims "no worst cases"
20:06:14 <glguy> timthelion: if you have to choose between reading my code and reading more YAHT, choose the latter :)
20:06:27 <augustss> dons: only .*, $, and ^  ?  You can't do much with that.
20:06:55 <allbery_b> it's only searching for quotes.  how much mroe do you need?
20:07:13 <augustss> but I see no way of entering quotes
20:07:15 <sorear> Substring search can be made *very* fast
20:07:25 <sorear> augustss: @remember
20:08:09 <augustss> So I assume that in addition to .*, $, ^ you can also match literal characters
20:08:25 <allbery_b> it's the metas that cause problems...
20:08:52 <sorear> GLIBC regcomp can be easily made to consume 3GBytes
20:09:23 <sorear> we're looking for a replacement... now at the pure haskell regex-{parsec,dfa}
20:09:38 <augustss> surely noone is stupid enough to build the dfa before it's needed?
20:09:50 <sorear> augustss: C is strict
20:09:53 <allbery_b> what has that to do with it?
20:10:09 <augustss> sorear: you can code laziness in C too
20:10:09 <allbery_b> sorear did a complex ?quote regexp and his local lbot exploded messily
20:10:58 <sorear> first I ran it on dons-lbot, which ran in constant space (openbsd > linux here) but effectively infinite time.
20:11:23 <timthelion> is there a way to view the source of a function like you can in elisp with C-h f
20:11:33 <sorear> sorear: we're talking about GNU coding style, they aren't lazy
20:11:40 <sorear> timthelion: @src
20:11:53 <sorear> s/sorear/augustss/ -- <feels silly>
20:12:00 <augustss> heh
20:12:21 <augustss> well, lazy dfa generation is a very old trick
20:12:24 <sorear> @src foldr
20:12:25 <lambdabot> foldr k z xs = go xs
20:12:25 <lambdabot>     where go []     = z
20:12:25 <lambdabot>           go (y:ys) = y `k` go ys
20:12:40 <timthelion> sorear: can I do that localy or just on this chanel?
20:12:59 <timthelion> sorear: ie, it didn't work in hugs
20:13:03 <sorear> it's a lambdabot plugin
20:13:16 <timthelion> @src zipWith
20:13:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
20:13:17 <lambdabot> zipWith _ _      _      = []
20:13:44 <augustss> @src zip
20:13:45 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
20:13:45 <lambdabot> zip _      _      = []
20:13:53 <bd_> timthelion: in the main haskell libraries, theer's a link from the online haskell.org docs to the source code; e.g. http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html has a 'source code' link to the ghc implementation
20:14:07 <lambdabot> http://tinyurl.com/sbkmj
20:15:11 * timthelion hides under the overwhelming amount of stuff to learn
20:16:02 <allbery_b> eventually (like maybe when they get it fixed :) you may want to build a local lambdabot and GOA (and switch to ghci) so you can do this stuff inside ghci
20:16:31 <timthelion> ok.
20:17:03 <timthelion> is there ever gona be an emacs of haskel? is that what ghci is gona become?
20:17:30 <Saizan> there's haskell-mode for emacs
20:17:39 <timthelion> I am using in now
20:17:43 * allbery_b biefly thinks of yi as a ghci plugin and runs away to scrub his brain
20:17:55 <timthelion> yi?
20:18:03 <timthelion> @yi
20:18:03 <lambdabot> Maybe you meant: . bf ft id pl v wn yow
20:18:10 <Saizan> ?where yi
20:18:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
20:18:15 <allbery_b> a proof-pof-concept editor written in haskell, which is extensible via haskell code
20:18:22 <sorear> emacs, rewritten stubbily in haskell
20:18:36 <allbery_b> ...but not especially useful at the moment
20:19:43 * allbery_b does most of his haskelling with an xemacs windoiw and an oversized terminal.app window running ghci
20:20:19 <timthelion> so is yi going to take over the world in the same way that calculator I am writing is going to make precalc class obsolete ?
20:20:26 <shapr> allbery_b: I predict that yi, lambdabot, and ghci will merge this year.
20:20:55 <iulus> precalc class obsolete? bah.
20:20:56 <shapr> timthelion: It's more like the calculator became the PC.
20:21:06 <sorear> emacs-snapshot-nox on tty1, ghci on tty2
20:21:08 * shapr throws lambdas
20:21:36 <conal> how does one link from haddock-generated docs to source code?  what does a 'source code' link look like?
20:21:36 <sorear> ircii on tty6, elinks on tty4, OS source code on tty3, lambdabot build dir on tty2, lambdabot source dir on tty5
20:21:38 <iulus> like the common calculator made 3rd grade math obsolete
20:21:43 * timthelion tries to figure out why haskel isn't more popular and decides it needs more evangelism.
20:21:51 <timthelion> iulus: yes
20:22:17 <timthelion> iulus: my calculator will be able to do everything up to seccond year calculus
20:22:23 <sorear> 3rd grade math is good.  I missed 3rd grade math, and spent weeks re-inventing long division
20:22:38 <iulus> timthelion: being able to do it and making it obsolete are completely different things
20:22:40 <timthelion> sorear: you where taught that in 3rd grade
20:22:43 <sorear> (for the purpose of implementing a (/) )
20:23:19 <sorear> I don't know when I should have learned it, because I never did in school.
20:23:22 * timthelion failed all math in elementary school because he could not do his multiplication tables.
20:23:24 <iulus> timthelion: my calculator can do multiplication, but I'd be nowhere if I never learned it
20:23:47 <augustss> conal: you need to use the -F flag and give it a URL with various % magic in it
20:24:20 <glguy> ?index fix
20:24:21 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:25:12 <sorear> (\f->let x=f x in x)
20:25:16 <timthelion> iulus: you see, I am dysgraphic(can't handwrite), and am really bad at memorising things. so I feal that the act of doing the math is just a bunch of pain that never gets me anywhere. I mean I already understand it. I hope to use haskel to use that understanding into a working math wiz which is me+ my comp
20:25:16 <conal> augustss: -F flag to haddock?  is it documented?
20:25:43 <sorear> math /= arithmetic
20:25:50 <augustss> conal: yes, I think it is.  but how to do it it not very well documented
20:25:58 <sorear> people (incl. myself) ignore that far too often
20:26:17 <augustss> conal: I looked at examples, and finally the haddock source, iirc
20:26:19 <iulus> timthelion: Ah! there's the key, "I already understand it." So you can use a calculator. But other people don't understand it yet, and they need to LEARN it
20:26:36 <conal> augustss: do you remember which examples?
20:26:49 <iulus> timthelion: so a calculator can be a shortcut for you once you've learned it, but it can't replace learning on it if you need to learn things that build on it
20:27:01 <augustss> conal: the ghc libraries, i think
20:27:13 <timthelion> iulus: maybe everyone needs to write a calculator
20:27:19 <conal> augustss: cool.  thanks.  i'll poke around.
20:27:49 * sorear is going to build a processor ... someday.
20:27:58 <augustss> sorear: it's fun!
20:28:11 <augustss> sorear: FPGAs rock
20:28:31 * allbery_b (foolishly?) tries to build wxHaskell on his macmini
20:28:35 <iulus> timthelion: I'm sure that'd be an enlightening experience. I've never done it, but I think about it (err, I guess I've built a simple +,-,*,/ calculator, but that's not what you're talking about)
20:29:02 * allbery_b works in a department filled with kiddies hacking on FPGAs, but has no clue how to do it himself :>
20:29:20 <timthelion> iulus: no it's not. I am talking about one that solves algebriec notations for all of the varios symbols.
20:29:31 <glguy> ?bot
20:29:31 <lambdabot> :)
20:29:37 <sorear> I was thinking more along the lines of getting a big box of BJTs
20:29:42 <iulus> timthelion: that's cool, those are important
20:30:35 * timthelion wonders if anyone has ever built more than a simple algebra symbol solver
20:30:58 <sorear> <--- symbolic differentiation
20:31:11 <glguy> > (\ c xs -> fix (\ f -> [a+c*b | (a,b) <- zip xs (0:f)])) 2 [3,3,4]
20:31:12 <shapr> <--- confused
20:31:13 <lambdabot>  [3,9,22]
20:31:19 <sorear> my first program, too. 1hr.
20:31:28 <sorear> I was *impressed*.
20:31:40 <timthelion> sorear: your first program was what?
20:31:41 <sorear> clarification: first Haskell program
20:31:45 <timthelion> ah
20:31:46 <shapr> augustss: Do you know if there's some way to use an FPGA for a Haskell coprocessor?
20:31:55 <shapr> argh
20:32:10 <timthelion> my first program was the first thing in YAHT
20:32:25 <sorear> does anyone know if it is POSSIBLE to make a haskell coprocessor, in the post-STG era?
20:34:16 <glguy> > (\ c xs -> fix $ zipWith (\(a,b) -> a+c*b) xs . (0:)) 2 [3,3,4]
20:34:17 <lambdabot>   add an instance declaration for (Num (c -> c, c -> c))
20:34:17 <lambdabot>     In the list elem...
20:34:29 <glguy> > (\ c xs -> fix $ zipWith (\a b -> a+c*b) xs . (0:)) 2 [3,3,4]
20:34:30 <lambdabot>  [3,9,22]
20:34:53 <glguy> > (\ c xs -> fix $ zipWith ((+).(c*)) xs . (0:)) 2 [3,3,4]
20:34:54 <lambdabot>  [6,12,20]
20:34:57 <glguy> bah
20:35:21 <glguy> ?pl \a b -> a + c * b -- I'm lazy
20:35:22 <lambdabot> (. (c *)) . (+)
20:35:43 <glguy> > (\ c xs -> fix $ zipWith ((. (c*)) . (+)) xs . (0:)) 2 [3,3,4]
20:35:45 <lambdabot>  [3,9,22]
20:36:57 <glguy> > (\ c xs -> fix $ zipWith (flip$(+).(c*)) xs . (0:)) 2 [3,3,4] -- was that all? (I'd do this in query, but lambdabot doesn't respond
20:36:59 <lambdabot>  [3,9,22]
20:37:15 <allbery_b> glguy: use @run
20:37:21 <allbery_b> (known bug)
20:37:42 <glguy> allbery_b: as of?
20:37:55 <sorear> yesterday when dons introduced it
20:37:55 <allbery_b> yesterday's LB changes, apparently
20:38:08 <dons> fixing....
20:38:42 <sorear> fixing it Right is harder  - the changes that broke it were trying to fix a warty inconsistency.
20:38:59 <sorear> (I'd need to rewrite >10 lines to fix it)
20:39:24 <timthelion> sorear: is haskell so complex that 10 lines is a lot?
20:39:55 <dons> heh
20:40:06 <sorear> conservative estimate
20:40:44 <sorear> things snowball, 50 lines isn't a lot, but my latest 50 line patch was 590 lines when it reached dons
20:41:04 <timthelion> wow, yikes.
20:41:42 <timthelion> so haskell hasn't taken over the world due to exponetial complexity isues?
20:41:46 <allbery_b> there's a quote recorded about someone's functions all collapsing to 2 lines each once he figured out what he was doing, but I'm afraid to try to search for it right now :>
20:41:58 <sorear> ?quote lines
20:42:01 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:42:16 <sorear> lucky
20:42:16 <dons> timthelion: hehe. I wouldn't read some grand language pronouncement into one person's random hacking
20:42:38 <timthelion> ok
20:42:59 <timthelion> why tf does ispell thing that ok is incorrect :(
20:43:00 <dons> seriously, lambdabot's just a toy we like to write code for
20:43:25 <dons> sorear: did you try something then?
20:43:28 <dons> "Main: caught (and ignoring) IRCRaised thread killed"
20:43:28 <timthelion> essentialseams like more than just a toy, but an essencial tool
20:43:31 <dons> ?bot
20:43:32 <lambdabot> :)
20:43:40 <dons> ?version
20:43:41 <lambdabot> lambdabot 4p418, GHC 6.5 (OpenBSD i386)
20:43:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:43:59 <dons> the > command works in /msg again
20:43:59 <timthelion> ?dons
20:44:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:44:22 <sorear> dons -> docs
20:44:27 <glguy> dons: wouldn't be the first giant jump to a conclusion q-:
20:44:52 <glguy> dons: and thanks, I just tried it for myself
20:45:19 <timthelion> so how many people can come up with ideas that they can express in haskell but can't express in english(with diagrams that do not include haskell)?
20:46:46 <dons> ?src foldr
20:46:47 <lambdabot> foldr k z xs = go xs
20:46:47 <lambdabot>     where go []     = z
20:46:47 <lambdabot>           go (y:ys) = y `k` go ys
20:46:49 <dons> easy ;)
20:47:46 <sorear> ooh, regex-parsec is broken on 6.6
20:47:54 <sorear> cabal is still missing Provides:
20:48:06 <dons> heya psykotic
20:49:19 <glguy> timthelion: it is: 'OK' or 'okay'
20:50:07 <glguy> This may be the most universal word in existence; it seems to have spread to most of the worlds languages. Etymologists now generally agree that it began as a humorous misspelling of all correct": oll korrect. OK without periods is the most common form in written American English now, though okay is not incorrect. -- http://www.wsu.edu/~brians/errors/ok.html
20:50:10 <lambdabot> Title: OK
20:50:17 <timthelion> glguy: Microsoft word don't have no problems with ok
20:51:07 <glguy> timthelion: I don't see how that is relevent...
20:51:08 * allbery_b considers ispell to be None Too Swift
20:51:26 <dons> ?spell ok
20:51:27 <lambdabot> OK OJ oak KO OKs
20:51:35 <timthelion> OK OK OK I'll spell ok OK
20:51:36 <glguy> or even relevant ;)
20:54:17 <timthelion> how come main = let args <- getArgs in putStrLn(show (compute ((head . words) args) (unwords((tail . words) args)))) don't work?
20:54:36 <dons> do args <- getArgs
20:54:40 <allbery_b> do, not let
20:54:47 <timthelion> ok
20:54:49 <dons> got to finish that YAHT :)
20:54:59 <glguy> yeah, "<-" is specific to do-notation
20:55:07 <sorear> the regex-foo, foo/=posix all require fps :(
20:55:24 <dons> sorear: so?
20:55:25 <sorear> (and cabal doesn't have Provides :()
20:55:46 <dons> patching is easy. but I'd like a foo/=posix actually *included* in Lib/
20:55:50 <dons> if you can get it down to 1 module
20:55:55 <dons> then we can hack away at it
20:56:01 <dons> stripping out stuff we don't need
20:56:45 <sorear> I'm looking hardest at parsec now ... looks like it should be relatively immune to pathological cases
20:57:00 <dons> timthelion: btw, getArgs is already in `words` format
20:57:11 <timthelion> oh
20:57:18 <timthelion> du
20:57:23 <glguy> what exactly are you guys trying to do (sorear / dons)
20:57:30 <dons> timthelion: main = do
20:57:30 <dons>     [a,as] <- getArgs
20:57:30 <dons>     print (compute a (concat as))
20:57:32 <timthelion> since it's [String] not String
20:57:49 <glguy> dons: unwords?
20:57:53 <sorear> glguy: harden lambdabot against evil regexes
20:57:59 <dons> ah yeah, maybe he needs that
20:58:03 <dons> not concat
20:58:06 <allbery_b> complex regexes cause a denial of servie attack (infinite time on openbsd, iinifinite space on linux)
20:58:22 <glguy> actually, he needs to stop writing is synthetic division function to take string arguments
20:58:31 <dons> uh hu :)
20:58:43 <dons> how about a parser, and an expression type, timthe	
20:58:59 <glguy> timtheTAB?
20:59:14 <dons> data E = EInt Integer | EOp Op E E -- or something
20:59:30 <dons> and run that through your calculator.
20:59:35 <timthelion> glguy: I already figured out how to do that. I am making my synthetic divition function, do the parsing, then call sd
20:59:39 <dons> no nasty untyped strings-representing-expressions
21:00:12 <glguy> timthelion: good deal
21:00:20 <dons> then you could write:
21:00:20 <dons>     args <- getArgs
21:00:20 <dons>     let v = compute (parse args)
21:00:20 <dons>     print v
21:00:52 <timthelion> don't you need to put an in befor the print?
21:01:00 <glguy> timthelion: more do notation
21:01:09 <glguy> I think that YAHT covers it
21:01:45 <allbery_b> @undo do { args <- getArgs; let v = compute (parse args); print v }
21:01:59 <allbery_b> bad timing?
21:02:12 <sorear> regexes can me matched in O(nnnm) time, O(nnm) space where n = length(input) ; m = length(regex)
21:02:17 <glguy> maybe you failed 3rd grade math (or whatever you mentioned earlier) because you only read the introduction to your text book ;)
21:02:35 * sorear needs to focus on implementing algorithms, not designing them
21:02:46 <timthelion> glguy: I did, because I am bad at memorising my multiplication tables
21:02:53 <sorear> polynomial time...
21:03:18 <Cale> timthelion: do { let <decls>; <stmts> }  ===> let <decls> in do { <stmts> }
21:03:48 <sorear> how massively inefficient are ReadS-type parsers?
21:04:23 * sorear notices a memoizing ReadS regex engine can have polynomial worst case, on full posix regexes
21:08:12 * allbery_b missed half of 2nd grade and 3rd grade math and managed to figure it out anyway
21:08:37 <allbery_b> (flip side I've always felt rather weak at math...)
21:13:35 <allbery_b> wxHaskell half done.  of course, last tiem I tried it I didn't find most of the issues until it was installed and I tried to use it...
21:14:59 <dons> ?bot
21:15:00 <lambdabot> :)
21:19:40 <augustss> sorear: to answer your question from 45 minutes ago:  I don't see any point in making a Haskell coprocessor.  What matters these days memory accesses and cache misses.  A coprocessor can't help.  This has pretty much been true for 20 years now.
21:20:06 <daniel_larsson> lisp machines were a dead end
21:20:44 <timthelion> compute "Synthetic divide" input =
21:20:44 <timthelion>     let sdString = syntheticDivide ((read ((head . words) input)) (map read ((tail . words) input)) ) in unwords ( map (show sdString)) --  the seccond map gives me a expecting function type, but found '[String]' error I don't get that at all
21:21:08 <timthelion> daniel_larsson: that is SO not true
21:21:40 <daniel_larsson> Hmm... you don't see many of those around at least
21:21:42 <glguy> let (c:xs) = map read $ words input
21:22:10 <glguy> in sd c xs
21:23:04 <Lemmih> timthelion 'map (show sdString)'?
21:23:29 <augustss> yes, LISP machines were a dead end
21:23:37 <timthelion> Lemmih: I am trying to convert an array of numbers to a string
21:23:50 <glguy> do, you were converting a list of numbers to a string
21:23:55 <Lemmih> timthelion: map show sdString?
21:24:01 <glguy> and he's questioning the parentheses
21:24:09 <Lemmih> @type \t -> map (show t)
21:24:10 <lambdabot>     Expecting a function type, but found `[Char]'
21:24:11 <lambdabot>       Expected type: a -> b
21:24:55 <timthelion> I get a unwords is aplied to three arguments withought them
21:25:31 <timthelion> * without
21:25:41 <Lemmih> > unwords (map show [1,2,3])
21:25:42 <lambdabot>  "1 2 3"
21:25:59 <lisppaste2> glguy pasted "for tim" at http://paste.lisp.org/display/34397
21:26:12 <Lemmih> 'unwords map show [1,2,3]'  and  'unwords (map (show [1,2,3]))'  are both wrong.
21:28:12 <augustss> LISP machines were very cool, but partly very poorly designed (as well as getting obsoleted after a while).
21:29:01 <augustss> Parts must have been designed by CS people instead of EE people.  Just electrically insane. :)
21:29:33 * allbery_b sighs
21:30:20 <allbery_b> how'd I know?  built test program, ran the silly adapter thing, launched it --- it started Classic, then exited without doing anything (and took virtuedesktops with it)
21:31:17 <timthelion>         $|    Expecting a function type, but found `[a]'
21:31:17 <timthelion> username:                                                           $|      Expected type: [a]
21:31:17 <timthelion> Enter a   [type error that I ca]                                    $|      Inferred type: a -> [String] -> [a1]
21:31:17 <timthelion> title:                                                              $|    Probable cause: `b_rest' is applied to too few arguments in the ca
21:31:19 <timthelion> Enter                                                               $|ll
21:31:21 <timthelion> your                                                                $|        (b_rest (c, b_n, tail (input)))
21:31:24 <timthelion> paste:                                                              $|    In the second argument of `(:)', namely `b_rest (c, b_n, tail (inp
21:31:30 <allbery_b> @paste please
21:31:31 <jcreigh> @paste
21:31:31 <lambdabot> http://paste.lisp.org/new/haskell
21:31:32 <lambdabot> http://paste.lisp.org/new/haskell
21:31:35 <timthelion> this is why I hate emacs
21:31:39 <timthelion> that was a typo
21:31:48 <timthelion> I didn't mean to paste at all
21:31:59 <jcreigh> oh, you're it, whatsitcalled, the Emacs IRC client?
21:32:09 <jcreigh> *you're in
21:32:11 <timthelion> jcreigh: rcirc
21:32:31 <jcreigh> yeah, irssi warns before a multi-line paste. :)
21:32:47 <timthelion> I should set this to do that to
21:32:55 <augustss> timthelion: what are you doing using head and tail.  those functions should be avoided
21:33:54 <timthelion> augustss: why need they be avoided. they are literaly the first functions introduced in YAHT
21:34:06 <jcreigh> > head []
21:34:07 <lambdabot>  Add a type signature
21:34:12 <jcreigh> gar
21:34:13 <augustss> yhey can fail
21:34:16 <augustss> they can fail
21:34:34 <augustss> if YAHT introduces them early I think that's a YAHT bug
21:34:58 <augustss> pattern matching is better than head&tail 99% of the time
21:36:14 <sorear> may I pretty-please pretend x{y,z} doesn't exist and remove support for it from the regex-engine?
21:36:46 <sorear> With it, I can give you cubic space and quartic time worst-case.  Without it, linear space and quadratic time.
21:36:52 <augustss> if you do 'case input of h:t -> ...' or something similar you'll be better off.  and you'll get a compiler warning if you forget to handle the empty list
21:37:27 <augustss> sorear: I'm happy without x{y,z}
21:37:29 <augustss> :)
21:37:51 * timthelion is too
21:37:57 <allbery_b> sorear: be my guest
21:37:59 <jcreigh> hmm, if the regex is limited enough (IIRC, no back-references is one thing) can't you build a DFA from a regex? (I have no idea what time/space complexity that has...)
21:38:00 <sorear> quartic time ... I never thought I'd use that adjective :)
21:38:08 <sorear> jcreigh: yes
21:38:15 <sorear> jcreigh: glibc builds a dfa
21:38:24 <bd_> jcreigh: problem is the DFA can be quite large :)
21:38:37 * timthelion does not understand regex, does not have the brain for regex, and wishes it would go away and be useful and do all those wooty things it can do without making me think about them
21:38:38 <sorear> jcreigh: dfa-building takes (with {x,y}) *exponential* worst case space+time
21:39:06 <sorear> nfa takes linear time w/o {x,y}
21:39:33 <sorear> memoizing-backtracking takes quartic time, and supports {x,y}.
21:39:39 <allbery_b> the only form of that I ever use is {x} --- {x,y} is unmitigated evil
21:39:43 <augustss> sorear: why do you get n^4 complexity?  shouldn't n^3 be enough?
21:40:09 <sorear> augustss: n^3 m, where m = length regex ; n = length input
21:40:16 <sorear> total of 4 powers
21:40:36 <augustss> hmmm, ok.  i could possibly believe that :)
21:41:12 <augustss> since you can parse any context free language in n^3
21:41:27 <sorear> augustss: oh?
21:41:38 <augustss> Earley's algorithm, for example
21:42:07 <sorear> I invented memoizing-ReadS half an hour ago... ah it can be generalized to context-free, cool
21:45:25 <Anon4888> "<sorear> jcreigh: dfa-building takes (with {x,y}) *exponential* worst case space+time"
21:45:44 <Anon4888> That's exponential in the regex length, though, not the input, right?
21:45:49 <sorear> right.
21:45:52 <Anon4888> k
21:45:53 <augustss> yes
21:46:08 <sorear> dfa-building doesn't use the input at all.
21:46:45 <sorear> we're trying to resist pathological regexes, and I'm being sidetracked inventing a better regexec.
21:47:24 <augustss> one that doesn't explode would be nice :)
21:47:30 <bd_> Can we just have it take arbitrary parsec expressions? ;)
21:48:52 <augustss> parsec drives me nuts sometimes.  that 'try' combinator is so annoying.
21:49:07 * augustss prefers parsek.
21:49:23 <bd_> ?where parsek
21:49:23 <lambdabot> I know nothing about parsek.
21:49:58 <bd_> ah, http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/koen/Parsek.hs
21:50:01 <lambdabot> http://tinyurl.com/yxnngl
21:50:23 <augustss> Also, http://darcs.augustsson.net/Darcs/Parsek/
21:50:26 <lambdabot> Title: Index of /Darcs/Parsek
21:50:27 <lisppaste2> timthelion annotated #34397 with "couldn't match error" at http://paste.lisp.org/display/34397#1
21:50:44 <timthelion> glguy's fix didn't work
21:50:55 <bd_> ?where+ parsek http://darcs.augustsson.net/Darcs/Parsek/
21:50:55 <lambdabot> Done.
21:50:58 <augustss> parsek has a commutative <|>
21:51:17 <bd_> return 1 <|> return 2 == return 2 <|> return 1 ? :)
21:52:08 <sorear> augustss: the algorithm I invented is isomorphic to wikipedia's Earley parser
21:52:10 <sorear> wikipedia++
21:52:12 <augustss> well, if you regard the returned result as a bag
21:52:18 <bd_> fair enough
21:52:36 <augustss> sorear: very cool!
21:53:07 <jcreigh> timthelion: what is the type of "input"?
21:53:31 <augustss> timthelion: and what'e the type of syntheticDivide?
21:54:16 <timthelion> input is passed as a string returned by unwords, and syntheticdivide is a list of numbers
21:55:07 <jcreigh> > map read ["123", "456"] :: [Int]
21:55:09 <lambdabot>  [123,456]
21:55:22 <bd_> > map read (unwords "123 456")
21:55:23 <lambdabot>  Couldn't match `String' against `Char'
21:55:30 <bd_> > map read (words "123 456")  :: [Int]
21:55:31 <lambdabot>  [123,456]
21:55:48 <augustss> bd_: hmmm, something is very wrong with that my darcs archieve, it seems to contain parsec instead of parsek
21:56:07 <bos_> oog. one should not read the section of YAHT regarding StateT without first playing extensively with State.
21:56:15 <timthelion> > map read (unwords (words "124 430"))
21:56:16 <lambdabot>  Couldn't match `String' against `Char'
21:56:22 <bos_> i tried, and it turned my brain into spaghetti.
21:56:26 <jcreigh> :t unwords
21:56:28 <lambdabot> [String] -> String
21:56:37 <bd_> augustss: it seems to have been developed based on parsec
21:56:38 <bd_> try :: ParserK s a -> ParserK s a
21:56:38 <bd_> try p = p -- backwards compatibility with Parsec
21:56:42 <dons> > words "124 430"
21:56:44 <bd_> in http://darcs.augustsson.net/Darcs/Parsek/Text/ParserCombinators/Parsek/Prim.hs
21:56:44 <lambdabot>  ["124","430"]
21:56:47 <lambdabot> http://tinyurl.com/yxejjv
21:56:48 <dons> > unwords (words "124 430")
21:56:50 <lambdabot>  "124 430"
21:56:52 <timthelion> ah
21:57:00 <dons> > map read (words "124 430") :: [Int]
21:57:02 <lambdabot>  [124,430]
21:57:08 <timthelion> duh
21:57:12 <bd_> which is present when I darcs get as well
21:57:14 <bd_> so it seems fine?
21:57:16 <timthelion> I need a words around the input
21:57:26 <dons> > sum . map read . words $ "124 430"
21:57:28 <lambdabot>  554
21:57:37 <augustss> bd_: ah, yes.  there is parsek stuff in there.
21:57:42 <dons> but remember if your input is coming from getArgs, its already split into words
21:57:57 <augustss> bd_: it's a mix of parsec and koen's original parsek
21:58:09 <timthelion> dons: but it has been unworded
21:58:13 <bd_> ic
21:58:23 <dons> why would you do that, if you just need to split it again?
21:58:29 <timthelion> too much to keep in head at once
21:58:37 * glguy dies
21:58:38 <augustss> bd_: i was trying to make it plug compatible
21:58:54 <timthelion> dons: because synthetic divition is not the only function this calculator is to have
21:59:22 <bd_> augustss: assuming your code does not rely on some of the finer semantics of try anyway :)
21:59:35 <augustss> bd_: true
21:59:47 <dons> Prelude System> :set args 1 2 3  4
21:59:48 <dons> Prelude System> getArgs
21:59:48 <dons> ["1","2","3","4"]
21:59:48 <dons> Prelude System> do a <- getArgs; print . sum . map read $ a
21:59:48 <dons> 10
22:01:53 <glguy> dons: have you always used . . . $ style? or did Cale get to you?
22:02:17 * glguy understands that Cale isn't the only person to use that style, before anyone else interjects
22:02:32 <Cale> hehe
22:03:25 <liyang> it emphasises the composition, as opposed to $ as a bracket-saving device.
22:03:43 * liyang finds himself using said style more and more, and generally avoiding $
22:04:33 <Cale> Yeah, it's nicer to use ($) sparingly.
22:04:42 <Cale> Also, not to rely on its associativity :)
22:05:01 <glguy> liyang: pick one,  a . b $ c     a $ b c
22:05:17 <glguy> just curious if you use that technique for the small case
22:05:18 <liyang> glguy: a (b c)
22:05:21 <liyang> :)
22:05:27 <Cale> I don't know, maybe we can get a petition together to change the associativity of ($)
22:05:32 <timthelion> I got it to compile!
22:05:32 <liyang> For the small case I always use brackets.
22:05:45 <glguy> Cale: I would prefer a petition that created a new operator
22:05:49 <liyang> It all started when I was typesetting some Template Haskell code and finding lhs2TeX can't differentiate between $ and $( ... )
22:05:59 <Cale> glguy: the problem is the lack of symbols
22:06:35 <Cale> $! should *certainly* have the other associativity
22:06:45 <timthelion> glguy: your code choked: [a,as] <- getArgs mathcalc: user error (Pattern match failure in do expression at math.hs:71:5-10)
22:06:54 <liyang> (so I replaced $ with `id` instead.)
22:07:03 <jcreigh> timthelion: did you pass two args?
22:07:07 <glguy> timthelion: I didn't write that
22:07:15 <timthelion> glguy: you didn't?
22:07:21 <timthelion> ok
22:07:23 <glguy> nope, and [a,as] match a list of two elements
22:07:27 <Saizan> @hoogle Ordering -> Ordering
22:07:28 <lambdabot> No matches, try a more general search
22:07:29 <glguy> timthelion: and (a:as) matches a head and tail
22:08:37 <glguy> shame (:) isn't a record with labels head and tail ;)  list { tail = newtail }
22:09:04 <glguy> f (list { tail = [] }) = y
22:09:22 <timthelion> yay
22:09:26 <timthelion> it worked!!!!!
22:10:34 <timthelion> wow, it all works now
22:17:25 <Cale> :)
22:20:18 <timthelion> is there a function for true if "list contains value" else false?
22:20:32 <glguy> elem
22:20:40 <glguy> > 4 `elem` [1..10]
22:20:42 <lambdabot>  True
22:20:45 <glguy> > 11 `elem` [1..10]
22:20:47 <lambdabot>  False
22:21:06 <dons> timthelion: what would its type be? if you can work that out, you can find the function using @hoogle
22:21:49 <dons> so it takes an element, and a list, and returns True or False? what would the type be? :)
22:24:00 <dons> I wish the shell had a runSudo monad
22:24:09 <dons> and withMount
22:24:24 <glguy> sudo sh -c 'mount x ; do y ; unmount x' ?
22:24:40 <dons> withSudo $ withMount $ \d -> copy d/* ~/photos/
22:24:43 <sorear> dons: I've seriously considered 'chsh /usr/local/bin/ghc-6.7'
22:24:51 <sorear> dons: I've seriously considered 'chsh /usr/local/bin/ghci-6.7'
22:25:02 <sorear> former'd be no fun :)
22:25:13 <dons> needs a lib of mappings, as well as regex/globs though; more sugar!
22:25:18 <sorear> Darcs.init
22:26:37 <dons> a Sudo monad would solve a lot of problems with manual priv separation in C servers
22:26:38 <sorear> Darcs.whatsNew >>$ map head >>$ sort >>$ group >>$ uniqC
22:27:04 <sorear> (>>$) = flip fmap -- my favorite nonstandard monad combinator
22:35:46 <lisppaste2> timthelion annotated #34397 with "how might I make this handle multiple finds" at http://paste.lisp.org/display/34397#2
22:36:33 <dons> use a better structure?
22:36:35 <dons> a Map?
22:37:03 <timthelion> use a better structure. that sounds good
22:37:07 <bd_> :t sd
22:37:09 <lambdabot> Not in scope: `sd'
22:37:44 <dons> ah I see what you're doing. you are actually keying on the snd part, to return the first
22:38:07 <timthelion> yes
22:38:19 <timthelion> because the first is the key.
22:38:41 <timthelion> you search for the key
22:40:09 <lisppaste2> dons annotated #34397 with "use a Map" at http://paste.lisp.org/display/34397#3
22:41:20 <dons> make sense? it uses a Data.Map (like a hash) to provide efficient lookup of the keys
22:41:47 <dons> and includes error handling for non-existant keys
22:43:10 <sorear> dons: do you use any auto-indenter on the lambdabot code?  (I'm fighting to stop haskell-mode from re-indenting it, and it just occured to me that things might be easier if my tool followed the lb style)
22:43:38 <lisppaste2> glguy annotated #34397 with "without a map, is this the same" at http://paste.lisp.org/display/34397#4
22:44:08 <Saizan> but he wanted to handle multiple finds, so he should have a Map String [String]
22:44:20 <glguy> oh, so a filter
22:45:01 <sorear> Saizan: Emulating multimaps with Map isn't fun - *wishes for standard Multimap*
22:45:02 <glguy> keyWord keyword =  [a | (a,b) <- keyWords, keyword `elem` b]
22:45:14 <dons> sorear: I just use vim
22:45:50 <bd_> :t elem
22:45:52 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
22:46:00 <base_16> :t find
22:46:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
22:46:11 <bd_> glguy: wouldn't that just return keyWords?
22:46:19 <bd_> or, wait
22:46:22 <glguy> ?
22:46:34 <bd_> was confusing it with (keyWords, keyword `elem` b)
22:46:49 <dons> ?let table = [("sd",["divition","polynomials","long","synthetic","divide"]),("help",["help","info"]),("sh",["search","help","info"])]
22:46:50 <lambdabot> Defined.
22:47:32 <glguy> > let keyword k = [a | (a,b) <- table, k `elem` b] in keyword "help"
22:47:33 <lambdabot>  ["help","sh"]
22:47:43 <dons> head
22:47:52 <dons> or did timthelion want all matches?
22:47:57 <Saizan> all
22:48:03 <ailndx> dons: if you see anyone that got hs-plugins working in win cant you ask them to write a tutorial how to set it up/install
22:48:20 <glguy> dons: someone said he wanted multiple matches, so I rewrote it
22:48:28 <timthelion> I wanted all matches
22:48:36 <dons> ailndx: hmm ok. but you just build it with the standard cabal instructions, and use ghc 6.4.2
22:49:26 <glguy> You notice that these functions are really simple. YAHT covers them
22:49:36 <ailndx> dons: well im not partiticular familiar with either haskell or msys/cabal stuff, i tried and installed it.. and got it to work but i get error when i run it
22:50:04 <dons> what error?
22:50:39 <ailndx> dont really recall, i think i got it installed now though, how is it i try if it works?
22:51:13 <dons> you want to try to see if it works?
22:51:19 <ailndx> sure
22:51:47 <dons> there's a testsuite you can run (details in the README)
22:51:54 <dons> but not sure how well that'll go on windows
22:52:10 <dons> btw, what are you doinng that needs hs-plugins on windows?
22:52:21 <ailndx> lambdabot for example
22:52:23 <bd_> ailndx: You're not using GHC 6.6, right? hs-plugins does not yet work on GHC 6.6
22:52:30 <ailndx> 6.4.2
22:54:35 <ailndx> runplugs.exe: user error (loadShared: couldn't load `libwsock32.so' because addDLL: unknown error)
22:55:52 <Saizan> (shouldn't that be .dll on win?)
22:59:28 <dons> ah right. now that's the same error some other people mentioned
22:59:46 <dons> I'm not sure what the fix is, but it might be that you need to have mingw and some other things on before you build hs-plugins
23:00:00 <dons> I don't know enough (anything really) about windows to help there
23:00:05 <timthelion> @src unwords
23:00:06 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
23:00:39 <timthelion> @src foldr
23:00:40 <lambdabot> foldr k z xs = go xs
23:00:40 <lambdabot>     where go []     = z
23:00:40 <lambdabot>           go (y:ys) = y `k` go ys
23:00:45 <timthelion> @src foldr1
23:00:46 <lambdabot> foldr1 _ [x]    = x
23:00:46 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
23:00:46 <lambdabot> foldr1 _ []     = undefined
23:00:54 <Saizan> mmh yes on windows inside mingw\lib i have a libwsock32.a (static version?) dunno how to get the .so
23:02:13 <ailndx> i have mingw installed before i install hs-plugins
23:02:22 <Saizan> ?where hs-plugins
23:02:23 * glguy wonders why unwords is a foldr1 rather than a foldr with a base case of ""
23:02:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
23:02:29 <glguy> > unwords []
23:02:32 <lambdabot>  ""
23:02:34 <glguy> ?
23:02:47 <glguy> > foldr1 (\w s -> w ++ ' ':s) []
23:02:49 <lambdabot>  Exception: Prelude.foldr1: empty list
23:03:05 <sorear> @. source index unwords
23:03:06 <dons> oh I might have missed a line when including the src there
23:03:06 <lambdabot>  not available
23:03:07 <glguy> so... what is lambdabot refering to?
23:03:21 <glguy> oh, and the reason is:
23:03:26 <dons> hmm
23:03:28 <glguy> no trailing space
23:03:29 <dons> ?src unwords
23:03:30 <lambdabot> unwords [] = ""
23:03:30 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
23:03:36 <bd_> > concat $ intersperse "\n" ["a", "b", "c"]
23:03:37 <lambdabot>  "a\nb\nc"
23:03:46 <bd_> > concat $ intersperse " " ["a", "b", "c"]
23:03:47 <glguy> intercalate?
23:03:48 <lambdabot>  "a b c"
23:04:03 <dons> > intercalate " " ["a", "b", "c"]
23:04:04 <lambdabot>   Not in scope: `intercalate'
23:04:09 <glguy> > intercalate " " ["a", "b", "c"]
23:04:11 <lambdabot>  "a b c"
23:04:34 <dons> ?users
23:04:35 <lambdabot> Maximum users seen in #haskell: 296, currently: 260 (87.8%), active: 19 (7.3%)
23:04:43 <bd_> @hoogle intercalate
23:04:44 <lambdabot> No matches found
23:04:57 <bd_> @src intercalate
23:04:58 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
23:05:15 <bd_> hmm, not in the GHC prelude anyway, or Data.List...
23:05:25 <dons> ?. pl src intercalate
23:05:26 <lambdabot> (line 1, column 1):
23:05:26 <lambdabot> unexpected end of input
23:05:26 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
23:05:31 <dons> bah :)
23:05:33 <glguy> ?all-dicts intercalate
23:05:39 <dons> bd_: its in ghc 6.6
23:05:48 <bd_> dons: I'm using ghci 6.6 :)
23:05:49 <lambdabot> Error: thread killed
23:06:03 <bd_> <interactive>:1:0: Not in scope: `intercalate'
23:06:04 <bd_> Prelude Data.List>
23:06:06 <sorear> ouch
23:06:32 <glguy> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg09849.html
23:06:35 <lambdabot> Title: [GHC] #971: Add intercalate and split to Data.List, http://tinyurl.com/y3l89a
23:07:09 <dons> ?web1913 intercalate
23:07:24 <dons> did we break the dict plugin, eh?
23:07:25 <glguy> I like when lambdabot used to work
23:07:25 <lambdabot> Error: thread killed
23:07:41 <glguy> :-p
23:07:42 <dons> sorear: I think we should concentrate on stability for a little while ... :)
23:07:48 <dons> I was getting happy with its 3 month uptimes
23:08:06 <glguy> I liked how you could type in ?undo and lambdabot would immediately respond
23:08:11 <dons> i.e. methodically check that every plugin is working in online and offline mode
23:08:16 <dons> glguy: oh?
23:08:21 <dons> ?undo do x <- getChar ; return x
23:08:22 <lambdabot> getChar >>= \ x -> return x
23:08:36 <dons> that's only network issues (if anything, the bot should be getting faster)
23:08:45 <glguy> yeah, a bit ago someone did one and lambdabot sat idle
23:09:12 <glguy> and ?spell didn't work in /query
23:09:24 <dons> yeah, I was playing around with some things
23:09:31 <glguy> :(
23:09:46 <dons> it works now
23:10:05 <dons> but, if you really depend on lambdabot that much, ... you could mmm, pay me! yes, that would work.
23:10:18 <dons> and I promise to only fix bugs, never add a new feature
23:10:36 <dons> and we'll keep sorear on his own megamonad-bot branch
23:10:52 <glguy> no no, I don't have money for it, I'll run my own
23:11:12 <Saizan> megamonad-bot :D
23:11:28 <timthelion> maybe I could set up an offshore account for you, funded by unspecified sources,
23:11:32 <dons> (seriously, though, I don't like instability either, but if you look at the stats it was due for a hack ;)  http://www.cse.unsw.edu.au/~dons/images/commits/lambdabot-commits.png
23:11:34 <lambdabot> http://tinyurl.com/ylvpv7
23:11:38 <dons> there's a natural cycle to lambdabot hacking
23:11:49 <Saizan> sounds like a japan 80's telefilm
23:12:02 <dons> and as you can see we're in the middle of one. your regularly schedule stable bot will return in due course
23:12:07 <timthelion> dons: just /msg me your first and last name, your social security number, and your favorite flavor of icecream
23:12:23 <dons> hehe.
23:12:50 <timthelion> I guess I am not as good as those nigerians
23:12:50 <glguy> dons: http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html -- I'm not sure if I should be pleased or embarrassed
23:12:51 <lambdabot> Title: #haskell @ freenode.org stats by dons
23:13:09 <dons> #3 !
23:13:22 <dons> glguy: you better release some haskell libraries then!
23:13:34 <glguy> dons: most of the time I spend is while at work
23:13:45 <dons> this yeah I'm going to turn the screws on the top 20 #haskellers who haven't release any libraries.... ;)
23:13:49 <glguy> dons: I leave the channel open to break the monotony
23:14:36 <sorear> dons: I don't think this is my fault
23:15:05 <sorear> dons: according to netstat, the dictd connection stays in SYN_SENT for 15 seconds and then the LB timeout hits
23:15:05 <dons> does it work for you?
23:15:06 <seancorfield> so, i got audrey's ghc macintel port installed and that seems to be just fine
23:15:12 <dons> ah ok.
23:15:19 <dons> maybe we need to update the dictd url
23:15:24 <timthelion> I think I need to get myself as the most referenced name
23:15:26 <dons> seancorfield: oh good
23:15:30 <sorear> dons: on the plus side, I now know my timeout code works
23:15:38 <seancorfield> but then i tried to build nhc98 using that ghc port and it fails because the lang package is unknown in ghc?
23:15:46 <seancorfield> any pointers?
23:15:58 <dons> seancorfield: hmm. try yhc, its a new nhc
23:16:01 <ailndx> Saizan: have you installed hs-plugins in win?
23:16:04 <dons> (same code base, but active)
23:16:12 <dons> sorear: good. ok.
23:16:21 <dons> sorear: I thin kI might (shock!) write some unit tests for lambdabot
23:16:40 <seancorfield> according to the web pages, yhc isn't ready for prime time...?
23:16:52 <dons> do you have the latest nhc source?
23:17:01 <seancorfield> 1.18
23:17:05 <dons> (most nhc dev has moved to yhc, but yes, its probably a bit more unstable)
23:17:20 <dons> hmm. the 'lang' package hasn't been around for a while. see if you can jsut remove that dependency
23:17:30 <sorear> dict(1) is running for ... a long time
23:17:42 <daniel_larsson> I removed lang when building yhc, and that seemed to do the trick
23:17:54 <seancorfield> 'k tx
23:19:30 <seancorfield> hmm, i install hmake and tried to run hi on top of ghc 6.6 and it also failed claiming unknown package lang...
23:19:48 <seancorfield> so hmake also has that dependency?
23:23:07 <bd_> isn't lang now a part of base...?
23:24:18 <Saizan> ailndx: nope, it doesn't compile on Typeable.hs, there are macros there and i don't know how to tell cabal to preprocess it, plus i have ghc6.6 so i gave up
23:25:21 <ailndx> ah okay
23:26:26 <Saizan> but now i'm curious on how to get it to compile..
23:39:50 <glguy> long paste ripped from a reddit comment (no one is typing anything anyway)
23:39:56 <glguy> In the days when Sussman was a novice Minsky once came to him as he sat hacking at the PDP-6.
23:39:59 <glguy> "What are you doing?", asked Minsky.
23:40:01 <glguy> "I am training a randomly wired neural net to play Tic-Tac-Toe."
23:40:04 <glguy> "Why is the net wired randomly?", inquired Minsky.
23:40:06 <glguy> "I do not want it to have any preconceptions of how to play".
23:40:09 <glguy> At this Minsky shut his eyes, and Sussman asked his teacher "Why do you close your eyes?"
23:40:12 <glguy> "So that the room will be empty."
23:40:14 <glguy> At that moment, Sussman was enlightened.
23:40:27 <nocotigo> s   ha
23:41:06 <sorear> glguy: that's from the jargon file
23:41:15 <nocotigo> k
23:41:19 <glguy> What's the keyword?
23:41:20 <nocotigo> wrong screen
23:41:24 <glguy> ?jargon random
23:41:36 <sorear> glguy: it's in the appendix
23:41:55 <sorear> unix koans of something or other
23:42:18 <glguy> http://catb.org/~esr/writings/unix-koans/ -- reading
23:42:21 <lambdabot> Title: Rootless Root
23:42:52 <sorear> dons: found a lambdabot bug
23:43:46 <sorear> if >=3 contextual plugins trigger on a single message, the handler-thread will deadlock (and be killed after 15 secs)
23:43:59 <metaperl> @seen Cale
23:44:00 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 26m 36s ago.
23:44:11 <Cale> hi
23:44:13 <glguy> http://catb.org/~esr/writings/unix-koans/ten-thousand.html -- This could be adapted to Haskell, me thinks ;)
23:44:15 <lambdabot> Title: Master Foo and the Ten Thousand Lines
23:44:15 <metaperl> hey Cale
23:44:23 <metaperl> I will go private with you
23:44:38 <mbishop> kinky
23:44:40 <glguy> that sounds inappropriate
23:44:59 <dons> sorear: ah well spotted.
23:45:06 <dons> is it that evil MVar trick I play, I wonder?
23:45:08 <dons> or something else?
23:45:42 <nocotigo> anyone want to go private with me
23:45:46 <nocotigo> lol
23:46:13 * nocotigo hangs head
23:46:37 <sorear> dons: yes
23:47:46 <sorear> (I'm ripping out all the Maybe-IrcMessage code, since the sync mvars are gone)
23:50:48 * metaperl is jazzed about http://groups.google.com/group/comp.lang.haskell
23:52:08 <seancorfield> i tried to remove the lang package dependencies in hmake and now i get this error so i'm going to call it a day and try again tomorrow or later next week...
23:52:10 <seancorfield> Imports.hs:19:0:
23:52:13 <seancorfield>     Bad interface file: ../cpphs/Language/Preprocessor/Cpphs/CppIfdef.hi
23:52:13 <seancorfield>         mismatched interface file versions: expected 6060, found 6
23:52:40 <sorear> classic you-accidentally-mixed-and-matched-compilers error.
23:52:48 <seancorfield> at least i have a working ghc :)
23:52:49 <sorear> delete all the .hi files
23:53:19 <sorear> (this will force a full rebuild, but assuming you only have one ghc in your PATH it should fix things)
23:53:33 <seancorfield> hmm, i tried that and it wouldn't build... hang on, i'll delete them again
23:53:47 <sorear> how many GHC's do you have?
23:54:10 <dons> sorear: yeah, if the Justs are gone, you can fix that code (it only exists to generate Justs)
23:54:16 <seancorfield> only one
23:54:16 <seancorfield> you mean delete all the .hi files in ghc? or in hmake?
23:54:16 <seancorfield> the latter does *not* work
23:54:20 * dons hacks away on the unit test framework
23:57:59 <sorear> I don't understand how two consequtive @more can work - shouldn't the first overwrite the state?
23:58:54 <dons> $ ./run-utests
23:58:54 <dons> All tests:
23:58:54 <dons>   dummyPlugin:test1
23:58:55 <dons> Cases: 1  Tried: 1  Errors: 0  Failures: 0
23:58:58 <dons> HUnit++
23:59:23 <sorear> nice!
