00:00:00 <dons> jeeves_bond: yeh, or never :)
00:00:13 <astrolabe> jeeves_bond: you don't really need that
00:00:26 <astrolabe> it give an interesting perspective, I 'd say
00:00:27 <dons> people like to sort out the foundations for haskell (since that's fairly easy in comparsion to the foundations of C :) but it doesn't mean you need it to know how to hack
00:00:53 <dons> (its like, as I say, programming C thinking about Hoare logic)
00:00:58 <dons> which no one does.
00:01:05 <Adamant> dons, been to Cambridge University Bookstore?
00:01:20 <dons> nope, haven't been to Cambridge yet, unfortunately
00:01:41 <dons> jeeves_bond: do you have some project you'd like to hack on?
00:01:45 <Adamant> it's nice. I wish now that I was interested in Haskell when I went there, though
00:01:49 <nmessenger> Haskell does seem to have an abundance of 'strange-sounding theory' relative to the amount of 'hackers' guides'
00:01:49 <dons> a good little project is a great way to dive in
00:01:52 <sorear> me, otoh, have always been a fan of higher math... Haskell introduced me to cat theory, and it seems fun from what I've seen so far.
00:01:55 <dons> glguy wrote hpaste.org, for example
00:02:25 <newsham> dons: hm.. yi paper says ncurses.. is that outdated?
00:02:25 <glguy> "wrote much of"
00:02:30 <sorear> I have no formal CS and no formal math higher than multivariate calc.
00:02:34 <dons> newsham: old yi uses curses, yeah
00:02:34 <sorear> newsham: yes
00:02:42 <dons> but its been moved over to vty and gtk now
00:03:06 <newsham> would it be possible to use gtk w/o vty?
00:03:30 <dons> yeah
00:03:34 <sorear> newsham: yes, but I would be forced to fork and/or write my own extensible editor.
00:03:34 <dons> you can use either gtk or vty
00:03:54 <newsham> yi-gtk.cabal:build-depends:  base, mtl, vty>=2.0, gtk>=0.9.10.4
00:03:55 <newsham> yi-gtk.cabal:-- vty is still used for Style!
00:04:12 <glguy>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
00:04:13 <glguy>  4321 eric      17   0 10296 7876 2548 S    3  3.0   3:30.29 hpaste
00:04:13 <dons> ah
00:04:20 <dons> glguy: cool
00:04:34 <sorear> glguy: what's the wall time?
00:04:58 <glguy> sorear: ?
00:05:19 <astrolabe> @time glguy
00:05:21 <lambdabot> Local time for glguy is 2007-01-27 02:01:27 -0600
00:05:36 <sorear> newsham: vty is too low level to effectively support windows - the best you'd get is a terminal emulator.  a native winyi or yi-gtk would do much better IMO.
00:06:02 <newsham> right, but yi-gtk has a vty dependency currenty.
00:06:12 <Procyon_> If I have a list of constructors in a type, and only 1 accepts a param that cannot be shown by the default show, do I have to instance show to my own function and specialize for every constructor, even though I only need to do the one?
00:06:20 <sorear> glguy: wall time = now - timeOf(start(hpaste))
00:07:01 <glguy> sorear: it's 3:02 on the server, started hpaste at 00:16
00:07:05 <sorear> Procyon_: no, I'm sure you could do some too-clever hackery with th and/or drift
00:07:34 <newsham> what is the haskell gtk library that yi uses?  gtk2hs?
00:07:48 <sorear> gtk2hs and gtk+hs are the only ones iirc
00:07:52 <Procyon_> lol.  I was looking for something non-clever :)
00:07:53 <sorear> gtk+hs == gtk 1.0
00:07:57 <newsham> right, so of those two...
00:08:10 <newsham> Setup.hs: cannot satisfy dependency gtk>=0.9.10.4
00:08:22 <sorear> yi is too non-ancient to use gtk 1
00:08:42 * sorear hasn't actually looked, of course
00:09:31 <astrolabe> Procyon_: Are you the guy who was doing that distance-between-chromasomes stuff?
00:09:38 <sorear> newsham: I'm pulling yi now ... "  * Define fully the Event type, so that GTK version does not depend on Vty
00:09:55 <newsham> sweet
00:09:56 <Procyon_> astrolabe: nope
00:10:10 <sorear> newsham: patch 6/6 description: "GTK frontend"
00:10:12 <astrolabe> Procyon_:  Ah, sorry.  My bad memory.
00:10:13 <jeeves_bond> It's more like I have a project idea and am looking for the right language to implement it in. Looked at Java, but I hate that synchronise thing for multithreading, it's so hacky!
00:10:25 <sorear> newsham:  I think this means yi-gtk is obsolete ?
00:10:28 * dons hands jeeves_bond some STM non blocking threads :)
00:11:19 <sorear> dons: can you comment on the status of yi-gtk?
00:11:33 <jeeves_bond> There's going to be lots of networking stuff, a web based interface, and possibly some AJAX. Haskell does seem capable at those things, whilst being exceptional at multithreading.
00:11:44 <sorear> dons: does yi need a non-HEAD compiler?  should I use my 6.4.2 ?
00:11:49 <bd_> jeeves_bond: looked into HAppS?
00:11:59 <dons> jeeves_bond: on concurrency in haskell, its a playground of modern threading, http://www.haskell.org/pipermail/haskell-cafe/2007-January/021716.html
00:12:04 <dons> sorear: i can't comment
00:12:04 <lambdabot> Title: [Haskell-cafe] Concurrency in Haskell, http://tinyurl.com/327wx4
00:12:08 <dons> i haven't built yi in quite a while
00:12:13 <dons> i just apply the patches each morning
00:12:27 <jeeves_bond> Thanks chaps
00:12:36 <sorear> hehe.
00:13:09 * sorear is now building yi
00:13:21 <sorear> dumbo ...
00:13:27 <newsham> dons: do you use yi?
00:14:26 <sorear> yi is looking nice
00:14:32 <jeeves_bond> So it seems some people agree with me: am I not the only one who screws their face up at the idea of 'synchronise' ?
00:14:33 <sorear> btw, yi builds on HEAD
00:14:59 <sorear> jeeves_bond: I screw my face up at the mere thought of pure imperative programming :)
00:15:09 <sorear> first order, actually
00:16:20 <astrolabe> It would be nice if there was a wiki-like site where people could comment on the current compilability and usability of haskell programs and libraries.  I find that the comments on the program's own sites are sometimes a bit optimistic, or at least not fully revealing.
00:16:30 <jeeves_bond> sorear: lol, might be coming round to your way of thinking. :)
00:17:37 <sorear> yi was looking so nice, then I tried to save ... 20-line minibuf ... stty: invalid argument `snae'
00:18:00 <jeeves_bond> bd_: thanks for the HAppS reference... Looks good!
00:18:29 <sorear> I need to start hacking yi if I ever want to banish elisp.  dynamic types.  impure.  yuckiness.
00:18:37 <Procyon_> jeeves_bond: If you want non-pure functional, you might look at Erlang and Termite (implemented with Gambit Scheme) also
00:18:53 <newsham> ?spell snae
00:18:55 <lambdabot> sane Snake snake snare nae
00:19:03 <newsham> lambdabot can fix your stty issue
00:19:04 <sorear> s/want/willing to accept/ :p
00:19:12 <Procyon_> hehe
00:19:44 <sorear> I'm vaguely suprised Shae wasn't on the list...
00:20:20 <jeeves_bond> Procyon_: would they suite my purposes better? I was under the impression that it was the 'pure' bit in Haskell that made it so good for multithreading.
00:22:44 <dons> astrolabe: yeah, that's what hackage will be good for
00:22:51 <dons> it should tag things with their valid compiler versions
00:22:53 <dons> ?where hackage
00:22:54 <lambdabot> http://hackage.haskell.org/trac/hackage
00:22:59 <dons> astrolabe: look for new packages here
00:23:10 <dons> as we add more features to track usage and so on
00:23:26 <dons> just measuring how many other packages depend on package A should tell us something about stability and use
00:23:38 <Procyon_> jeeves_bond: Yes, it is.  Erlang and Termite take a different tack though and model function calls as individual processes.  Calling a function is anagolous to sending a message to another process and waiting for a response.  That way "functions" can be on the same thread, other threads, other processes or even other machines.
00:23:59 <dons> Procyon_: this is like Chans in Haskell
00:24:12 <dons> though only experiemental libs use chans to talk across networks
00:24:16 <astrolabe> dons: Thanks
00:24:16 <jeeves_bond> Procyon_: Wow, that sounds powerful
00:24:17 <Procyon_> The individual functions can be imperative themselves, but they remain "pure" by encapsulating that
00:25:02 <jeeves_bond> Hmmm, so local variables only then?
00:25:04 <Procyon_> jeeves_bond: Erlang was developed for massivly scalable and reliable phone networks.
00:25:38 <Procyon_> jeeves_bond: not really... you can set up "variables" like "services"... so you can query them
00:26:18 <jeeves_bond> Procyon_: I see
00:26:20 <Procyon_> You can also have redundant nodes, so that failure of parts of the program will not cause the program to fail at all, just go a little slower
00:27:21 <Procyon_> I built a system for cell phone networks doing the exact same thing, only using (alas) C++.  Erlang makes it much simpler.
00:27:29 <notsmack> pop quiz:  QuickCheck vs HUnit.  Thoughts?
00:27:32 <jeeves_bond> Procyon_: that sounds perfect, what's the developer community like though?
00:27:59 <dons> notsmack: the answer is clear: QuickCheck where possible, HUnit everywhere else
00:28:05 <Procyon_> I have no idea ;)  I only know the concepts (having done the same thing in c++).  I've never actually used it.
00:28:08 <notsmack> dons: where isn't HUnit possible?
00:28:16 <dons> hUnit is possible everywhere
00:28:20 <dons> but its not as powerful sa QuickCheck
00:28:25 <dons> since it doesn't do genrators
00:28:29 <notsmack> er, i meant where isn't quickcheck possible
00:28:35 <dons> ah, monadic stuff is hard
00:28:47 <dons> and code lacking nice properties
00:28:52 <dons> (== bad code ;)
00:28:55 <notsmack> hehe, yeah
00:29:09 <dons> also, black box testing of external stuff
00:29:26 <notsmack> right
00:29:32 <dons> hUnit is more like your traditional unit testing framework
00:29:33 <sorear> is there any good info on finding nice properties in code?  most of the properties I think of are trivialy *proven*
00:29:36 <dons> you right tests, it runs them
00:29:43 <dons> but QuickCheck is semi-theorem proving
00:30:05 <dons> you get better guarantees from QuickCheck
00:30:11 <dons> (even proofs if you can exhause the test cases)
00:30:13 <bd_> QuickCheck is theorem disproving :)
00:30:24 <dons> :)
00:30:37 <sorear> QuickCheck proves theorems.
00:30:50 <sorear> it needs existencial quantification
00:30:58 <sorear> @spell existencial
00:30:59 <lambdabot> existential existentially existences existence existence's
00:31:14 <dons> it can only prove things by exhaustion though
00:31:23 <dons> and that can be hard to ensure
00:31:23 <sorear> the problem with fancy concepts is you can't spell them :)
00:31:26 <jeeves_bond> Procyon_: ok, sounds like amazing stuff. Thanks for the information
00:31:36 <sorear> that's what GHC needs - a spilling chicker!
00:31:45 <Procyon_> jeeves_bond: np.  good luck
00:31:49 <dons> you sound like you're from New Zealand, sorear
00:31:50 <sorear> s/checker/corrector/
00:32:06 <sorear> dons: much further away, sorry :)
00:37:45 <xic> does System.Mem.Weak work with TVar?
00:38:56 <sorear> @where yi
00:38:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
00:39:17 <sorear> xic: how so?
00:39:31 <glguy> are people here browsing hpaste? or is that reddit traffic?
00:39:53 <sorear> glguy: you can see the IPs, right?
00:39:58 <sorear> /who
00:40:01 <glguy> sorear: no
00:40:07 <glguy> sorear: apache is proxying
00:40:16 <sorear> oh
00:40:22 <glguy> shapr: might be able to
00:40:32 * sorear just sent first yi patch
00:41:51 <xic> sorear: i can't seem to understand System.Mem.Weak at all even...
00:42:08 <sorear> he. neigther can I...
00:42:56 <sorear> dons: whats the oldest GHC yi wants to support?
00:45:18 <notsmack> anything new with yi?
00:45:30 <sorear> it is much closer to working :)
00:45:52 <notsmack> cool.  it's one of the projects i hold out the most hope for.
00:45:54 <sorear> it's all JPB's fault, he's been exclusive hacker lately.
00:46:16 <sorear> notsmack: it needs hope.  not sure if mere reason will work. :(
01:04:59 <glguy> ?fptools Control.Monad.State
01:04:59 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
01:05:26 <pejo> "JPB"?
01:05:51 <sorear> Jean-Phillipe Bernardy.  His name is *way* too long.
01:06:08 <sorear> and he doesn't have an IRC nick :(
01:14:31 <sorear> @seen jyp
01:14:32 <lambdabot> I haven't seen jyp.
01:19:43 <kolmodin> morning!
01:19:58 <sorear> uhhhg...
01:21:08 <Igel> @seen eq
01:21:09 <lambdabot> I haven't seen eq.
01:21:14 <Igel> @seen der_eq
01:21:15 <lambdabot> der_eq is in #gentoo-haskell and #haskell. I don't know when der_eq last spoke.
01:22:27 <nornagon> @seen you
01:22:27 <lambdabot> I haven't seen you.
01:22:28 <sorear> night.
01:27:21 <Procyon_> Does the term "k = \x -> \_ -> x" do what I think it does?  (in that it ignores the 2nd param altogether without causing a warning)
01:29:09 <notsmack> Procyon_: yes
01:29:19 <der_eq> Procyon_: it's also called "const"
01:29:42 <Procyon_> called const how?
01:29:58 <der_eq> > const 5 4
01:29:59 <lambdabot>  5
01:30:13 <der_eq> > (\x -> \_ -> x) 5 4
01:30:14 <lambdabot>  5
01:30:21 <Procyon_> > const 5
01:30:22 <lambdabot>  Add a type signature
01:30:42 <Procyon_> I see. Thanks.
01:37:34 <apfelmus> kowey: ping
01:37:51 <kowey> hey, apfelmus
01:39:04 <apfelmus> kowey: hi! i'd like to know what you say about aim of the wikibook.
01:39:19 <apfelmus> the beginner's track is clear
01:40:20 <apfelmus> but for the advanced track, i have in mind that it should be a place where (not) all those research papers gently introductionified
01:40:24 <kowey> yeah i've been thinking about that... not too sure, but I think the emerging theme is that we're trying to be friendliest possible resource we can
01:40:57 * kowey still needs to rewrite the arrows stuff (inspired by the tutorial on haskellwiki)
01:41:22 <xic> Many readers, ourselves included, will have a queasy feeling by this stage. What is left of the beauty of functional programming by the time all these primitives have been added? How can the unspecified "proof obligations" of unsafePerformIO be characterised and proved? Has the baby been thrown out with the bath water? These are justifiable criticisms. The baby is indeed in danger.
01:41:33 <kowey> the wikibook should be friendly and slow, maybe not too deep (my opinion only)...
01:41:53 <apfelmus> yes, friendliness is the most important issue.
01:41:57 <kowey> it's always a tradeoff; you go too slow and you frustrate people who "get" things quickly, but that's ok,
01:42:05 <kowey> because the haskellwiki can fill the faster-faster-faster niche
01:43:42 <apfelmus> yes. although i find that the current beginner's track is too abstract. maybe that's why it feels a bit slow?
01:44:25 <apfelmus> but i can't say, the beginner's track doesn't apply to me anymore
01:44:27 <kowey> yeah, i'm worry that we tend to talk too much at the user, ideally there would be a lot of learning-by-doing
01:44:55 <kowey> i subscribe to the chop wood and carry water school of thought
01:45:42 <kowey> theory is great, but it's hard to understand theory if you haven't built up a battery of intuitions, if you haven't just worked with stuff enough
01:46:47 <kowey> so in chop-wood-carry-water thinking, we try to work first and explain later... that being said, i'd like to see what _real_ educators have to say
01:47:13 <apfelmus> yes. i find myself reading math books from the end to the front. the intuitions are at the end and the details are at the front. this way, reading times speed up considerably :)
01:47:21 <pejo> kowey, heh, the problem with only having academics around is that they don't have much formal training in teaching.
01:47:42 <kowey> begging somebody to teach us to teach :-)
01:48:14 <Korollary> good job on the wikibook
01:48:56 <apfelmus> kowey: pehaps the beginner's track just lacks a running example, i.e. a useful program or task that can be done quite early and gets extended along the road
01:49:16 <kowey> apfelmus: exactly!
01:49:26 <kowey> that's what i've always been wanting, but everytime i tried to think of one
01:49:27 <kowey> blank
01:50:33 <apfelmus> yeah, the problem is of finding the right example :) for it needs early introduction
01:51:09 <kowey> i'd like it to feel very real world
01:51:31 <kowey> maybe a game, or a web thing, something neither contrived nor academic
01:52:00 <apfelmus> well, that's difficult. there are different real worlds :) but i also that a game would be ideal.
01:52:09 <apfelmus> *also think
01:52:28 <apfelmus> with a game, you can stay almost purely functional
01:52:53 <kowey> well, you had the idea of using an adventure game to talk about zippers...
01:53:30 <kowey> are you talking about text adventures like Zork? i can imagine this introducing IO rather quickly
01:54:16 <apfelmus> yes, i'll definitively write the zippers section with an adventure game, a labyrinth to be precise.
01:55:10 <apfelmus> though i don't know whether Zork like things are suitable for introducing the language.
01:56:00 <kowey> (the other problem with working a running example is that it's going to take a lot of time)
01:56:21 <kowey> (it'll pay off, definitely... but this will be a project of many many weekends, i think :-) )
01:56:53 <apfelmus> the point about games (i mean classical games, not those action/graphical stuff) is that they require much program logic but few IO
01:57:59 <xic> i have a strong suspicion that functional reactive programming would work very well for the kind of logic that advtenture games or rpg games need
01:58:16 <xic> i think it would be way cleaner then the imperative scripting languages that are traditionally used
01:58:40 <apfelmus> kowey: well, one can concentrate on finding a good example before writing actual text. you don't feel productive (because you're not writing text) but the example is definitively worth it
01:58:45 <pejo> xic, frp as in the Yale-approach?
01:58:51 <xic> pejo: yeah
01:59:06 <xic> pejo: as in directly use yampa
02:00:09 <kowey> apfelmus: so any ideas on what a good classical game might be?
02:01:14 <apfelmus> mh, not really. for the explanation of infinite lists and laziness, Bird & Wadler use scissors,pen & paper. it was brilliant and will definitively go into the wikibook.
02:01:59 <apfelmus> but it's laziness only
02:02:42 <kowey> ooh man, what a great contribution that would be... if we could help people really grasp laziness, really use it to their advantage
02:03:03 <apfelmus> i think that for brainstorming purposes, we should go plunder existing textbooks of any good games/examples they introduce
02:03:57 <pejo> kowey, indeed it would.
02:04:08 <kowey> apfelmus: i have not so much access to these books, but i'd be happy to serve as a sounding board
02:05:04 <kowey> pejo: the slight problem being that I myself (modulo vague intuitions from experience) do not fully grasp it either... but hey, learn by teaching
02:05:28 <apfelmus> neither do i. much to my surprise, i found the Bird & Wadler book in my local city library (!)
02:05:43 <kowey> oh, and welcome to the Polish wikibook authors, if you're around!
02:07:09 <kowey> polska... najlepsza? (that's my one phrase of polish, assuming it's not mangled horribly)
02:07:45 <apfelmus> also, considering games and IO, we have the option of writing an IO wrapper ourselves, in the spirit of HGL. i mean the wikibook student can write the game logic and an library does graphics and IO for him
02:08:23 <kowey> apfelmus: so you mean, (1) download this (2) plug your code into it?
02:08:28 <apfelmus> exactly
02:08:48 <apfelmus> of course, the idea is as old as LOGO
02:08:48 <kowey> yeah, that's a very nice idea
02:09:36 <kowey> well, our priority isn't neccesarily to be didactic innovators... if we can innovate, all the better, but if there is an idea that really works... hey
02:10:45 <apfelmus> :) you're right, ideas cannot become old
02:11:33 <Igloo> dons, astrolabe: Blackwells, Borders and Waterstones all have CS books. For Blackwells you need to be in the right one
02:11:41 * kowey dreams of the wikibook becoming one day good enough to be used as a classroom text
02:12:30 <apfelmus> :) ok, so much for the beginner's track. can you put up a visible talk page on that and point contributors to it? this should be the place to brainstorm game ideas
02:13:20 <apfelmus> and to hatch them to completeness
02:13:56 <kowey> ok
02:16:50 <apfelmus> kowey: concerning the advanced track, friendliness is granted. but there is the question of how much material it should contain.
02:16:55 <apfelmus> in my vision, it's not necessarily comprehensive, but any good idea/abstraction/technique/subtlety (applicative functors, laziness, ...) can be put in there.
02:17:48 <apfelmus> so if you where on an isolated island with a haskell compiler, you'd chose the wikibook because it contains all stuff you need to know neatly explained
02:18:04 <apfelmus> *chose the wikibook as accompaging book
02:18:14 <apfelmus> ?spell accompaging
02:18:14 <lambdabot> accompany accompanying accompanier comparing accomplishing
02:18:22 <kowey> apfelmus: useful abstractions (since you've already learned most of the Haskell you need to know)
02:18:49 <kowey> apfelmus: but what about new features, like fancy types... do we want those? i would think so
02:19:08 <apfelmus> yes, of course. they are useful abstractions, too
02:19:26 <kowey> :-)
02:19:58 * mbishop would want GEB on his island
02:20:00 <apfelmus> fundamental issues like denotational semantics and laziness have there place, too
02:20:49 <kowey> so the advanced chapter would consist of (1) great abstractions (2) useful extensions (3) fundamental issues [gently turn up the dial on the comp sci/maths]
02:21:03 <kowey> uh... s/chapter/track/
02:22:15 <apfelmus> yes. and i think that we should not be very strict about rejecting an abstraction. just include it.
02:23:12 <kowey> there's also a doacratic element there, i think...
02:23:26 <kowey> if somebody's actually going to take the time to write something (in the advanced track at least)
02:23:46 <kowey> it's probably worth seeing if we can work it in... most of the time anyway
02:23:59 <apfelmus> (doacratic, what's that?)
02:24:31 <kowey> it's a neologism, a word that somebody made up on one of the Haskell mailing lists
02:24:45 <kowey> "this is a doacracy - "do-er decides"
02:24:56 <kowey> the person that actually does something, gets to decide
02:24:58 <apfelmus> ah, ok :)
02:25:20 <apfelmus> yes, that's the spirit :)
02:25:32 <pejo> kowey, heh. I feel exactly the same way - I have no idea what is going on.
02:25:39 <pejo> (Sorry about the late reply).
02:25:41 <apfelmus> of course, this means a tension between the haskell wiki and the wikibook. but i think that the book form is important
02:26:19 <kowey> both are useful... the wikibook isn't as fast as the wiki, because we have more pressure to be cohesive
02:26:54 <kowey> wiki emphasizes variety and content (lots of depth, lots of breadth)
02:27:26 <kowey> wikibook emphasises [oops, let my merican spelling slip] friendliness, homogeny
02:27:49 <apfelmus> indeed. and this is the strong point of the book.
02:28:12 <kowey> sometimes the book will borrow from the wiki... so it looks just as messy
02:28:26 <apfelmus> well, that's the nature of a wikibook :)
02:28:27 <kowey> but the hope is to one day clean it all up and knead it together
02:28:43 <kowey> right... it's an interesting compromise between a book book, and a wiki
02:29:07 <apfelmus> and we might be able to persuade the wikibook staff to set up things so that the book can be printed with a visually pleasing result
02:29:27 <kowey> well, they don't need persuading, just manpower
02:29:36 <kowey> (speaking from darcs project experience)
02:29:58 <apfelmus> well, manpower depends on the programming language used :)
02:30:23 <apfelmus> (in the case of the wikibook i mean)
02:31:31 <kowey> that should be the next april fool's joke... wikipedia switches to Haskell
02:31:54 <apfelmus> hehe. i'd be fool enough to believe it :)
02:32:28 <kowey> that might a be a fun project too... a bug-compatible mediawiki re-implementation
02:32:32 <kowey> hmm... or maybe not...
02:32:56 <apfelmus> fun as in bug
02:33:35 <kowey> i suspect we're one of the rare wikibooks to use higher order templates
02:33:40 <kowey> :-D
02:34:05 <apfelmus> :) but i didn't notice yet
02:34:12 <notsmack> @remember kowey i suspect we're one of the rare wikibooks to use higher order templates
02:34:12 <lambdabot> Done.
02:37:36 <apfelmus> kowey: btw, what diagramming software do you use?
02:37:47 <apfelmus> (if you do)
02:37:54 <kowey> apfelmus: omnigraffle (somewhat embarassed to admit)
02:38:17 <apfelmus> mh, the free or the costly version?
02:38:17 <kowey> apfelmus: but dmhouse says that inkscape is very nice... and you can see his cat theory diagrams as proof
02:38:42 <Procyon_> kowey: good classic game -> Hunt the Wumpus.  Graph traversal problem.
02:39:02 <kowey> apfelmus: the non-professional version, but paid for so that I don't have the 20 object limitation (which you can get around by grouping things)
02:39:19 <apfelmus> yeah, inkscape is nice. but somehow, i don't like the fact the text cannot be aligned easily with objects
02:39:28 <kowey> Procyon_: thanks for that... will note on the talk page
02:40:06 <kowey> i also like the alignment guides... hoping somebody would implement that for blobs one day
02:40:17 <kowey> (well... alignment between different objects, that is)
02:40:22 <apfelmus> kowey: ah, so the 20 objects restriction really becomes painful? i'd hope to avoid spending mony
02:40:40 <apfelmus> *money
02:40:53 <kowey> apfelmus: well... the annoying thing is that sometimes you have to ungroup things and re-group them
02:41:11 <kowey> apfelmus: but if you're not working on very complicated/intricate diagrams, it's quite livable
02:42:26 <apfelmus> ok, thanks for the hint, that's what i wanted to know.
02:42:27 <apfelmus> btw, the alignment guides are already present in Xcode's interface builder but i don't know you had them first
02:42:36 <apfelmus> *you/who
02:43:23 <kowey> oh yeah... oh hey we should send an operative to Cupertino, start a HOC revolution
02:43:38 <kowey> http://hoc.sourceforge.net/
02:43:42 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
02:45:27 <Vq^> seems to be very Mac centered
02:45:40 <apfelmus> mh, persuading them to use HOC for their objects is ad-hoc. they should build a purely functional OS instead
02:45:46 <apfelmus> :)
02:46:11 <apfelmus> Vq^: mh, that's an euphemism :)
02:46:19 <kowey> the next version of OS X using House instead of Darwin?
02:47:12 <apfelmus> of course! because even Darwin lived in a House, you know.
02:47:17 <pejo> As much as I like Haskell, I still prefer my OS to be usable. :P
02:47:43 <apfelmus> pejo: mh. "usable" is not necessarily the right word for current OS
02:48:27 <pejo> apfelmus, it runs my Emacs, Keynote, TeXShop, and Latex.
02:48:33 * apfelmus dreams of a purely functional OS. every file is value, programs are pure functions.
02:48:55 <kowey> oh btw, i'm going to be at FOSDEM if anybody wants to meet up, talk wikibook, chat in general
02:56:51 <kowey> apfelmus: ok, posted the thing about the running example on the talk page
02:57:42 <Cale> apfelmus: and nothing ever changes! :)
02:58:03 <apfelmus> Cale: mh?
02:58:08 <kowey> (how's that for stability)
02:59:46 <apfelmus> Cale: what do you mean?
03:00:08 <Cale> being pure values, files would be constants
03:00:27 <apfelmus> kowey: ouch, "pen" i'm so stupid. it's "rock", of course
03:00:46 <apfelmus> Cale: sure, where's the problem? :)
03:01:31 <kowey> apfelmus: oh :-) you got my hopes up... I was hoping for fun with cut-out figures
03:02:04 <Cale> Inkscape is awesome :)
03:02:54 <Cale> As far as the features I use are concerned, it's essentially as good as Illustrator.
03:02:59 * dmhouse initiates an Inkscape group-hug
03:03:56 * nornagon hugs inkscape.
03:04:08 <kowey> oh hi, dmhouse... have you been following the recent wikibook discussion?
03:04:17 <dmhouse> kowey: where?
03:04:26 <kowey> right here in the channel
03:04:27 <dmhouse> We really need a wikibook mailing list, I hate following talk pages.
03:04:34 <dmhouse> Oh; not really.
03:04:51 <dmhouse> What's up?
03:05:43 <kowey> (maybe we could have a haskell-teaching list and do all our wikibook discussion there)
03:06:07 <dmhouse> A dedicated mailing list would be okay tool
03:06:09 <dmhouse> *too.
03:06:31 <kowey> apfelmus had some nice ideas about adding a running example through the beginner's track
03:07:15 <kowey> and also some thoughts on what the advanced section should contain (abstractions, extensions and fundamental issues)
03:07:46 <kowey> so now we're soliciting ideas for a nice game that we could build up with the reader (e.g. rock-paper-scissors, hunt the wumpus)
03:08:15 <dmhouse> How about the game of life?
03:08:39 <dmhouse> You could start with lists, move on to Maps, then use monads to carry the updateable state.
03:09:10 <dmhouse> That was the project I was going to do with the course I'm teaching, but we didn't get far enough with the theory so we're going for something simpler.
03:10:12 <dmhouse> You could perhaps have a couple of games going. Rock-paper-scissors would be good educationally, but only for the really basic sections.
03:10:32 <dmhouse> For RPS, you basically have:
03:10:40 <dmhouse> data Choice = Rock | Paper | Scissors
03:10:46 <dmhouse> And a non-transitive `beats` function.
03:11:18 <dmhouse> It doesn't really go much further than that; to try to involve lists etc; would be stretching things.
03:12:34 <apfelmus> RPS has been used by Bird&Wadler for explaining laziness in very compelling way.
03:12:45 <apfelmus> i updated the talk page on that
03:13:13 * kowey has mailed JaffaCake re: a wikibook mailing list
03:39:21 <araujo> morning
03:39:58 <ivanm> Hey everyone, I was trying to use foldl' in a bit of Haskell code, but ghci keeps telling me: "Not in scope: `foldl''".  Any ideas why (Data.List is loaded)?
03:40:43 <ivanm> Forget that, I worked it out: I was loading List, not Data.List (but why that made a difference I had no idea...)
03:42:31 <Cale> List is somewhat deprecated -- it's the List library as standardised in Haskell 98
03:42:46 <ivanm> Ahhh..... OK, thanks Cale!
03:52:35 <Bourbaki> moin
03:52:47 <Bourbaki> is visual haskell based on ghc?
03:53:27 <nornagon> ... visual haskell?
03:53:49 <wolverian> !google visual haskell
03:53:55 <wolverian> er.
03:53:59 <wolverian> well, you get the idea
03:54:57 <Bourbaki> http://www.haskell.org/visualhaskell/downloads.html
03:54:58 <lambdabot> Title: Visual Haskell Screenshots
03:55:56 <nornagon> ah, zany
04:05:11 <Bourbaki> is there any good haskell.net implementation by now?
04:05:37 <ndm> Bourbaki: you can create native .NET binaries with Yhc
04:06:28 <Bourbaki> so i can use these in my .net apps then?
04:06:48 <ndm> Bourbaki: not quite, there is no FFI between Yhc.NET and C#.NET etc, sadly
04:07:10 <Bourbaki> ah so it just compiles msli code?
04:07:16 <ndm> yes, pretty much
04:07:33 <ndm> i guess it would be possible to prod the msli, but no idea how
04:08:03 <Bourbaki> you can use it with reflection then maybe
04:08:25 <ndm> i guess you can do it properly natively, if you figured out what hte wrapping scheme was
04:08:47 <ndm> certainly Yhc.JS allows JS FFI seamlessly
04:25:03 <dons> ndm, http://clemens.endorphin.org/weblog/archives/2007-01.shtml#e2007-01-09T09_57_26.txt
04:25:06 <lambdabot> Title: clemens.endorphin.org/weblog - January 2007 Archives - clemens.endorphin.org, http://tinyurl.com/yyc6kc
04:25:16 <dons> "hoogle.el "
04:25:27 <ndm> dons: i saw, have emailed him and already asked for the script to add to the darcs repo and the details for the wiki page
04:25:34 <dons> :)
04:25:43 <dons> good good
04:25:48 <Bourbaki> hididliho dons
04:25:55 <dons> hey Bourbaki
04:26:06 * dons heads back to bed. night all!
04:26:08 <dons> ?time dons
04:26:11 <lambdabot> Local time for dons is Sat Jan 27 23:22:13 2007
04:26:13 <Bourbaki> nighto
04:26:27 <ndm> night dons
04:47:21 <xic> anyone know of a templating engine for haskell, like python's genshi/jinja/mighty/cheetah?
04:56:31 <huschi> @hoogle Int -> [a] -> [a]
04:56:32 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
04:56:32 <lambdabot> Prelude.take :: Int -> [a] -> [a]
04:56:32 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
05:08:38 <Cale> xic: hmm... from its initial description, genshi doesn't sound too far off from HXT, though I've never used any of the libraries you listed.
05:09:21 <xic> Cale: i'm looking for something that lets me build a template from a string, like "Hello {{name}}", and then render the template by supplying a value for "name"
05:10:51 <xic> Cale: also simple programming logic is very useful: "<p>the names are:</p><ul>{{ foreach n in names}}<li>n</li>{{ endfor }}</ul>"
05:11:10 <xic> oops, that should be "{{n}}"
05:11:18 <xic> but you get the idea
05:12:03 <Cale> What HXT does is a bit more structured than that, since it operates primarily at the level of xml trees.
05:12:37 <xic> yeah, i need to operate on arbitrary strings though
05:13:52 <Cale> I'm not aware of anything like that then, but it probably wouldn't be so bad to whip something up using Parsec, depending on how much you need.
05:14:32 <dancor> does haskell have anything like C's htonl?  i mean how do i blast like Int32 over a socket in a language indepedent way
05:14:38 <dancor> Int32's
05:15:41 <xic> is there something like elemIndex, but where i can search for a sublist instead of a single element?
05:18:46 <Cale> dancor: anything which works with Network.Socket.HostAddress should produce values in network byte order, if that helps.
05:19:27 <Cale> xic: not in the libraries, but it's a decent exercise. I'd recommend using tails and isPrefixOf
05:19:50 <xic> thanks i'll give it a shot
05:20:49 * SamB likes project wonderful ads
05:22:19 <Cale> dancor: so maybe if it's not too inconvenient, use Network.Socket.inet_addr to build values.
05:23:26 * SamB wonders what ads people would put on hpaste or haskell.org
05:23:28 <dancor> Cale: isn't that a crazy overload of that fcn?
05:24:12 <Cale> @type Network.Socket.inet_addr
05:24:14 <lambdabot> String -> IO Network.Socket.HostAddress
05:24:35 <dancor> what happens if i just use the Handle returned by like connectTo?  endian-death?
05:24:41 <SamB> I wonder if they support textual ad spaces?
05:24:57 <dancor> Cale: sorry i don't mean overload of types.  i mean use in a crazy unintended way
05:25:21 <Cale> Do what with the Handle?
05:26:04 <dancor> well iwrite binary data but yeah hm
05:26:25 <SamB> dancor: I think he meant that Newtork.Socket.HostAddress is stored in network byte order...
05:26:38 <fasta> @hoogle [a->Bool] -> [a] -> Bool
05:26:39 <lambdabot> No matches, try a more general search
05:26:46 <SamB> but, your binary data hopefully is in some specific byte order too
05:26:55 <fasta> @hoogle [a->b] -> [b] -> b
05:26:56 <lambdabot> No matches, try a more general search
05:27:14 <nornagon> ... what?
05:27:23 <twanvl> ?type \a b -> and $ zipWith ($) a b
05:27:24 <therp> In my opinion haskell.galois.com (the thing hackage.haskell.org points to) hands out DNS answer with a TTL to low. (300 seconds!)
05:27:24 <lambdabot> forall b. [b -> Bool] -> [b] -> Bool
05:27:37 <SamB> however, you can use little-endian as long as you are consistant
05:27:38 <dancor> @hoogle [a->b] -> [a] -> b
05:27:38 <lambdabot> No matches, try a more general search
05:27:47 <therp> that's s/to/too/ of course
05:27:50 <Cale> (I'm thinking that the usual thing to use htonl for is working with IP addresses)
05:27:57 <SamB> for your binary data
05:27:57 <nornagon> :t L.pipeline
05:27:59 <lambdabot> Couldn't find qualified module.
05:28:10 <dancor> i'm writing cross-lingual stuff
05:28:12 <SamB> Cale: what? not sandstone platters?
05:28:16 <dancor> so everything uses network order
05:28:35 <dancor> for binary serialization of several types
05:28:48 <nornagon> :t foldr1 (flip (.))
05:28:50 <lambdabot> forall c. [c -> c] -> c -> c
05:28:53 <allbery_b> it's also used for marshaling binary data.  I wrote my own, since I didn't need speed.  meantime this sounds like Data.Binary...
05:28:54 <SamB> dancor: some cross-platform formats specifically call for little endian.
05:28:56 <dancor> this looks interesting
05:28:58 <dancor> http://darcs.haskell.org/binary/src/Data/Binary.hs
05:29:02 <Cale> yes
05:29:03 <SamB> usually stuff like NSF or SID, though
05:29:10 <Cale> I was about to ask if you knew about it :)
05:29:26 <SamB> (formats storing 6502 programs that play music)
05:29:56 <dancor> it's like Lennart Kolmodin knew exactly what i needed
05:31:55 <dancor> is Data.Binary pure
05:32:18 <Cale> basically, yes
05:32:27 <Cale> encode                    -- :: Binary a => a -> ByteString
05:32:31 <dancor> like does Int32 go to the network order 4 bytes you'd expect
05:32:48 <dancor> without any extra stuff
05:32:57 <Cale> -- Words32s are written as 4 bytes in big-endian (network) order
05:32:57 <Cale> instance Binary Word32 where
05:32:57 <Cale>     put     = putWord32be
05:32:57 <Cale>     get     = getWord32be
05:33:00 <malebria> Good morning.
05:33:15 <Cale> and a few lines down, you'll see that Int32s are as well
05:33:44 <fasta> Is the limitation on 256 constructors already lifted?
05:34:09 <Cale> That had to do with the automatic generation stuff.
05:34:10 <ndm> fasta: i believe thats only in the deriving versions, not the underlying code
05:34:31 <ndm> fasta: i am going to rewrite some of the deriving stuff, and see if i can get that limitation removed
05:35:05 <fasta> I think the "deriving" mechanism is fundamentally flawed.
05:35:15 * allbery_b is inclined to think that if you need >256 constructors, you need to refactor something
05:35:32 <Cale> Yeah, it seems pretty insane that the compiler would even allow that :)
05:35:35 <fasta> allbery_b: A good example was already given on the mailing list.
05:35:55 <therp> GHC error: 256 constructors? You don't want that.
05:36:02 <fasta> allbery_b: A data type for COBOL
05:36:03 <allbery_b> saw that, yeh.  my first though was "that's fine for tokenizers but not for types
05:36:19 <Cale> therp: sure, but I don't think I'd mind much either.
05:37:20 <fasta> I think the idea of an "open compiler" is much better. (E.g. by using the aterm format or whatever standard thing)
05:37:27 <dancor> give me constructors until i run out of memory, swap space, and disk, or give me death
05:37:32 <Cale> If I was going to end up with over 256 constructors in some sort of enumeration, I think I'd just use strings instead.
05:38:05 <fasta> TCL in Haskell FTW!
05:38:33 <allbery_b> in particular I don't think representing tokens directly as types is the right way to do it.  one of the ways parsers can save you effort is recognizing automatically common code structures, with keywords-as-constrctors doing that seems like it requires type-level hackery to d the same thing, or code duplication
05:39:01 <Cale> I don't think I'd ever want to have to write a case expression for such a type.
05:39:36 <allbery_b> another good example
05:43:37 <fasta> Cale: you seem to be implicitly saying that you throw away Haskell's static typing for writing the AST of COBOL. If you do that, you can better switch to Scheme.
05:44:19 <huschi> is there a way to find out how many seconds have gone since epoch for a given date at midnight?
05:44:32 <huschi> daylightsaving time also important.
05:44:48 <Cale> AST? I thought it was the concrete syntax that was the problem.
05:45:12 <dancor> > data A = A
05:45:13 <lambdabot>  Parse error
05:46:10 <dancor> is lb too kwl for data?
05:46:13 <allbery_b> huschi: toEpochTime (System.Time) using the CT constructor?
05:46:44 <allbery_b> lb is like the ghci eval/print loop, no declarations
05:46:47 <fasta> Cale: I read the number of >1200 in a paper for the number of different nodes in a COBOL AST.
05:46:47 <huschi> @hoogle toEpochTime
05:46:47 <lambdabot> No matches found
05:47:10 <huschi> allbery_b: i cannot find this function.
05:47:14 <fasta> Cale: it essentially argued that you need generic traversals.
05:47:20 <Cale> I'm fairly certain that could be broken up into parts.
05:47:30 <allbery_b> sorry, toClockTime.  EpochTime is the POSIX version
05:47:36 * allbery_b misspoke
05:47:43 <allbery_b> @index toClockTime
05:47:44 <lambdabot> System.Time
05:47:45 <fasta> Cale: since as you said, you don't want to write out that much explicitly.
05:48:06 <xic> is there a combination of drop and take?
05:48:08 <huschi> allbery_b: but this function doesn't consider the daylight saving time.
05:48:09 <Cale> http://www.csci.csusb.edu/dick/samples/cobol.syntax.html
05:48:11 <lambdabot> Title: Sample: Syntax of COBOL Circa 1988
05:48:24 <dancor> xic: like python range?  i think you have to roll your own
05:48:42 <allbery_b> sure it does, it's part of the CT (CalendarTime) constructor
05:48:48 <xic> dancor: like python list splice
05:49:02 <fasta> Cale: I believe there are newer versions of COBOL.
05:49:03 <dancor> xic: err yeah
05:49:21 <fasta> Cale: and how many it are is not really important, just that it are a lot.
05:49:31 <dancor> xic: only arrays have that stuff built in
05:49:34 <Saizan> python's range is very similar to [x,y..z] notation, that is syntactic sugar for the Enum class
05:49:48 <huschi> allbery_b: from the docs ... ignoring the contents of the ctWDay, ctYDay, ctTZName and ctIsDST fields.
05:49:52 <fasta> @karma-- python
05:49:52 <lambdabot> python's karma lowered to -1.
05:50:13 <Cale> fasta: that doesn't look so bad actually.
05:50:14 <dancor> @karma++ karma
05:50:15 <lambdabot> karma's karma raised to 4.
05:50:22 <dancor> so much meta
05:50:37 <allbery_b> hm.
05:50:38 <Cale> I don't think you'd need any type with over 20 or so constructors.
05:50:47 <xic> i'm lookng for something like a[x:y]
05:50:51 * allbery_b may have to check some of his own code to see if it DTRT then
05:50:57 <huschi> allbery_b: and i also would not know when dst starts.
05:51:05 <allbery_b> in general the timezone thing isn';t easy to do in other languages either
05:51:05 <huschi> each year.
05:51:16 <fasta> Cale: I believe it when I see it.
05:51:18 <huschi> allbery_b: i know.
05:52:02 <dancor> i usually have the opposite problem where i only use 1 or 2 constuctors and wonder if i'm missing out on all sorts of multconstructor fun
05:52:37 <Cale> dancor: we're referring to the specific problem of encoding abstract syntax trees for COBOL.
05:52:45 <Cale> I wouldn't use a single type for that.
05:53:53 <allbery_b> figuring out where t use the type system and where not can be something of an art, I figure --- sometimes it helps, sometimes it hurts
05:54:12 * dancor does not forsee needing 257 constructors personally any time soon, but always sympathizes with boundlessists
05:54:38 <allbery_b> when you've got >256 constructors, it's usually at the point where it's hurting
05:55:12 <allbery_b> (maybe if you';re implementing a new enumerable, but even there I'm tempted to think there are better ways)
05:55:56 <dancor> you would have to have 257 things that were not naturally subclassifyable
05:56:05 <allbery_b> (grantng that you don't have ranged types so maybe in some cases it *is* the least painful way --- but this does not describe use for e.g. COBOL keywords)
05:56:16 <kosmikus> bringert: %format mykeyword = "\mathbf{mykeyword}" is a good solution
05:56:39 <dancor> yeah i thought about having a type with 19 poss for a go game
05:57:01 <dancor> which you could imagine having 257 for like supermegago
05:57:12 <dancor> i used Int for even 19 though
05:57:26 <dancor> but i felt badly about doing so
05:57:40 <Cale> I think it's entirely appropriate to use an integer for that.
05:58:13 <Cale> If you go to the trouble of creating a custom type there, you're just hurting your ability to extend your game later.
05:59:43 <Cale> (when you want it to be compatible with all those people who play on 15x15 or 27x27 boards :)
06:00:43 <Cale> 27x27 games take a hell of a long time.
06:02:01 <Bourbaki> aha go players :)
06:02:07 <Bourbaki> whats your kyu Cale?
06:02:30 <Cale> I don't know. When I stopped playing regularly, it was somewhere in the single digits.
06:02:48 <Bourbaki> not bad
06:03:48 <dancor> board size is def a trade-off between how cool you want things to be vs how much time you are realistically willing to invest
06:04:13 <dcoutts> @seen csci
06:04:14 <lambdabot> I saw csci leaving #ghc 6h 36m ago, and .
06:04:37 <Cale> There's more reasons to like 19x19 though.
06:04:49 <dancor> why
06:04:58 <Bourbaki> i prefer 13^2
06:05:07 <Bourbaki> faster play
06:05:17 <dancor> a conscise board, and a concise notation
06:05:20 <Cale> It balances the amount of space above the 4th line and below the 3rd.
06:05:21 <Bourbaki> and you can get more reviews
06:05:44 <Cale> So territory taking and whole-board fighting are similarly effective.
06:06:15 <dcoutts> @tell csci the gtk2hs installer should register the gtk package with ghc-pkg, you might like to try using the latest version of the installer: http://haskell.org/gtk2hs/gtk2hs.0.9.10.5.exe , let me know if you get any problem with that.
06:06:16 <lambdabot> Consider it noted.
06:06:48 <Botje> in todays sigfpe (http://sigfpe.blogspot.com/2007/01/monads-hidden-behind-every-zipper.html), he uses fmap on the Zipper datastructure
06:06:51 <lambdabot> http://tinyurl.com/2m4t3k
06:06:54 <dancor> but on n=27 is just like a 3-tier version of that where n=19 is two-tier
06:07:10 <Botje> but how does fmap know that is needs to alter the lists? is there some kind of "default behavior" for fmap?
06:07:14 <dancor> 1.5 your tiers and 1.5 your fun
06:07:57 <dancor> (of course you do actually double your time)
06:08:17 <dancor> so fun/time is suboptimal
06:09:09 <Botje> we should all strive to maximize fun/time.
06:09:47 <Bourbaki> then you should probably shoot yourself soon after having a lot of fun
06:09:53 <Botje> oh, i see now, bleh.
06:09:54 <dancor> that's why i do nothing but play n=19 go and code hs
06:09:55 <ndm> data DataBox = DataBox (forall a . (Typeable a, Data a) => a)
06:09:59 <ndm> whats wrong with that?
06:10:03 <Botje> f is defined as operating on Zipper
06:10:11 <ndm> whats the syntax for putting a Typeable and Data dictionary in a data structure?
06:13:00 <integral> ndm: my syntax looks more like: data AnyBox tag = forall x. Boxable tag x => AnyBox x
06:13:09 <dmhouse> ndm: put the foralls before the constructor name
06:13:17 <ndm> integral: thanks, think i have figured it out
06:13:24 <Cale> dancor: well, it's not like it destroys the game, but it does change the way that you have to reason about what's a reasonable move, because the centre of the board is that much larger, which makes the easily securable stuff along the sides and in the corners smaller.
06:13:36 <dmhouse> ndm: otherwise you declare that DataBox takes values which are a member of all types which instantiate Data and Typeable.
06:13:45 <Cale> Basically, as the board gets larger, you expect influence to become more important.
06:14:12 * integral has found GADT notation quite handy for simplier existential thingies
06:14:16 <integral> *simpler
06:14:33 <dancor> Cale: no 4-4 starts?
06:15:06 <Cale> Perhaps 4-4, but at some point, 3-4 starts looking small.
06:15:17 <Cale> and 5-5 becomes more reasonable, I think
06:15:50 <Cale> (not that it's all that unreasonable on 19x19 :)
06:16:05 <erider> morning all
06:31:49 <dancor> hm why would building Data.Binary say Could not find module `Data.ByteString':
06:31:59 <chessguy> g'morning haskellers
06:32:10 <dancor> when i have it and indeed a test .hs file with   import ByteString   runs
06:32:23 <dancor> s/t B/t Data.B/
06:33:05 <chessguy> hmm, what dependency does your cabal file list for ByteString?
06:34:13 <dancor> binary.cabal has build-depends:   base
06:34:15 <dancor> hm
06:34:40 <dancor> shouldn't it have an actual dependency
06:34:47 <chessguy> do you have the new fps library?
06:35:09 <chessguy> err, wait, what version of GHC?
06:35:10 <dancor> i just grabbed it darcsily
06:35:12 <dancor> 6.4
06:35:22 <chessguy> oh, don't add fps then
06:35:23 <dancor> .2
06:35:29 <chessguy> wait
06:35:45 <chessguy> yeah, ok, for an old GHC you can add it
06:35:46 <ndm> dancor: download and install fps
06:35:54 <dancor> ndm: done
06:36:02 <chessguy> and then add fps as a dependency in the cabal file
06:36:55 <dancor> oh there is a note in there: -- ghc 6.4 also needs package fps
06:37:28 <chessguy> yeah, in 6.6 fps got put in with ghc, but not in earlier versions
06:38:42 <chessguy> 'morning ihope
06:39:53 <chessguy> dancor, did that work?
06:41:00 <dancor> ok it got farther.  but why does this do and say nothing and just exit: runghc -fallow-undecidable-instances Setup.lhs build
06:41:35 <bringert> kosmikus: ok, thanks
06:42:05 <xic> how would i implement something like the IO exception system in some other monad?
06:42:07 <bakert> Is there a good tutorial on exception handling in haskell?
06:42:50 <bringert> kosmikus: I've started on a java.fmt. It'll be interesting to see how well that will work.
06:42:57 <Saizan> xic: isn't that MonadError?
06:43:15 <dancor> ok had to throw that in the .cabal too
06:43:16 <dancor> yay
06:43:33 <dancor> but isn't this build stuff still too hard
06:43:45 <dancor> is it going to be golden after 6.6
06:43:56 <JKnecht> ?
06:43:58 <dancor> or will there be death every time there is a new version of hs
06:44:04 <dancor> of ghc rather
06:44:16 <Saizan> dancor: on 6.6 i builded binary quite easily
06:44:43 <dancor> Saizan: yeah but when 6.8 comes out if you have to stay at 6.6 for a bit, will there be death
06:44:55 <xic> Saizan: hm... cool!
06:45:23 <dancor> it seems like cabal should be able to handle such simple things as conditionally needing a dependency because it actually got added to the main stack
06:45:33 <dancor> of ghc
06:45:48 <dancor> s/main stack/core libraries, whatever
06:45:48 <fasta> Ambiguous type variable `a1' in the constraint:
06:45:48 <fasta>       `Show a1'
06:45:48 <fasta> 	arising from use of `res' I have tons of errors stating similar things. Wasn't the default keyword intended to be used for this? I don't care what instance of Show is used.
06:46:26 <fasta> Cabal is about the simplest system to implement, AFAIU
06:46:27 <dmhouse> Anyone know of a proof of the typing preservation theorem for the typed SK-calculus?
06:46:46 <fasta> It is intended to be simple for the implementors of Cabal, not for its users.
06:47:20 <bakert> When you use exceptions in IO, is there any way to have the "catch" several layers up from where the exception is raised?  Or must you wrap the call to the function that might cause an exception in the catch?
06:48:02 <dmhouse> bakert: you can have the catch wherever you want, I think.
06:48:10 <dmhouse> You can only catch from IO-monadic code, though.
06:48:11 <kosmikus> bringert: jeremy gibbons has formatted quite a lot of java with lhs2tex, afaik
06:48:33 <bakert> dmhouse, cool that's all i need to do.  will try it.  thanks.
06:49:38 <Saizan> you can have the opposite problem, that the exception remains hidden in unevaluated code and skips past the catch
06:50:15 <bringert> kosmikus: good tip, thanks!
06:51:20 <fasta> Ok, type defaulting only works for Num...
06:52:45 <kosmikus> bringert: http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/ssdgp.pdf contains some Pascal and Java programs and a long Java appendix
06:52:48 <lambdabot> http://tinyurl.com/2eqq75
06:53:00 <kosmikus> bringert: maybe he's willing to provide his .fmt files ...
06:53:13 <bringert> kosmikus: thanks, I'll ask him
06:57:10 <bakert> How do I intentionally raise an exception?  With "fail"?
06:57:32 <bringert> bakert: or throw, throwIO or throwError
06:58:49 <bakert> thanks bringert
06:58:52 <bakert> ?hoogle throwIO
06:58:53 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
06:59:52 <bakert> ?hoogle throwError
06:59:53 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
07:00:21 <bakert> throwError is uncatchable?
07:00:33 <bakert> crash!  (?)
07:00:33 <allbery_b> @hoogle catch
07:00:34 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
07:00:35 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
07:00:35 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
07:00:50 <allbery_b> complicatiobn being you need to catch in IO
07:01:34 <allbery_b> ...or translate.  MonadError typically maps exceptions to out-of-band values (empty list, Nothing, Left message...)
07:01:52 <allbery_b> sorry, only the latter
07:02:09 <allbery_b> keep forgetting that somehow you're not supposed to want Maybe or List :/
07:02:17 <bakert> The situation I have is that I am getting stuff from the database.  But if it isn't there or what have you I don't want every layer of my code to have to worry about it.
07:02:36 <bakert> I am currently passing an IO (Either String Account) out and the String is the err msg if it failed.
07:02:46 <allbery_b> so use MonadError instance Either String
07:02:59 <bakert> But I am trying to refine it so that only the top layer and the db layer know when it fails so that it can just return IO Account
07:03:00 <allbery_b> if you don't otherwise catch the exception, it's returned as a Left
07:03:04 <bakert> and get rid of the either.
07:03:45 <allbery_b> if you want to do your exceptions in IO directly then you must use catch
07:04:25 * allbery_b thiks ErrorT IO might also be a candidate, but that's up to you
07:04:53 <bakert> Everything is in IO all the way up to the top.  It has to be (doesn't it).  There are pure functions that manipulate what I got from IO and so on but the control flow stuff is in IO>
07:07:39 <bakert> ?paste
07:07:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:08:15 <bakert> allbery_b, bringert, i've put together a little module that illustrates what I want.  Perhaps you'd be kind enough to tell me if it is feasible.
07:08:41 <bakert> http://hpaste.org/141
07:09:49 <gotaku> What does $ mean?
07:10:01 <bakert> gotaku, $ means wrap the rest of the line in brackets.
07:10:26 <allbery_b> a $ b is (a) (b) for arbitrary expressions a and b
07:10:26 <bakert> gotaku, so "putStrLn $ show v" == "putStrLn (show v)"
07:10:45 <dmhouse> gotaku: it basically saves on parentheses, as bakert showed. It's quite handy.
07:10:49 <gotaku> I see, thanks.
07:10:51 <dmhouse> Even cooler, you can define it in pure Haskell.
07:10:58 <bakert> ?src ($)
07:10:59 <lambdabot> f $ x = f x
07:11:17 <allbery_b> ...which doesn't show the infixr declaration that makes it work
07:11:31 <allbery_b> use :info in ghci to see that
07:11:33 <dmhouse> The trick is to give it a really low precedence, so that it lets its operands be evaluated before itself is.
07:11:59 <dmhouse> Err, I don't really mean evaluated.
07:12:13 <gotaku> What's the best GUI library for haskell right now?
07:12:15 <bakert> So, back to my monkeys.
07:12:16 <bakert> http://hpaste.org/141
07:12:28 <araujo> gotaku, gtk2hs
07:12:46 <bakert> What I want is to be able to rename the monkey.  But if I never got the monkey the exception handling in main should be called rather than crashing.
07:12:49 <bakert> Is that possible?
07:12:56 <dmhouse> Say you had print $ 2 + 2. ($) has a lower fixity than (+), which means that it'll parse as print $ (2 + 2) rather than (print $ 2) + 2.
07:13:27 <allbery_b> that should work, I'd think
07:13:57 <bakert> It doesn't compile because of "parse error on input 'catch'".  am i doing something stoopid?
07:14:35 <chessguy> @hoogle catch
07:14:36 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
07:14:36 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
07:14:36 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
07:14:59 <dmhouse> bakert: hiding (catch).
07:14:59 <Saizan> import Prelude hiding (catch)
07:15:07 <allbery_b> he did
07:15:08 <bakert> oh doh
07:15:12 <bakert> missing brackets
07:15:18 <allbery_b> oh
07:15:26 <allbery_b> wrong instance of "cath" :)
07:15:31 <dmhouse> ?type IOException
07:15:37 <lambdabot> Not in scope: data constructor `IOException'
07:15:42 <dmhouse> ?hoogle IOException
07:15:43 <lambdabot> Control.Exception.IOException :: IOException -> Exception
07:15:43 <lambdabot> Control.Exception.IOException :: data IOException
07:15:59 <bakert> Or should I just use "fail" and prelude's "catch"?
07:19:48 <chessguy> bakert, does it work with (catch)
07:20:18 <bakert> chessguy, yes but now i have another problem.
07:21:15 <chessguy> ...
07:21:16 <bakert> IOException doesn't take a string.  in fact, there doesn't seem to be any exception that is appropriate
07:23:22 <bakert> How do i throw an error message up to the top level?
07:23:37 <allbery_b> bakert: look at the constructors for Exception
07:24:15 <bakert> I'm looking at them now.  They don't seem very useful!
07:24:18 <allbery_b> for user exceptions you probably want to use ErrorException
07:24:27 <csci> Hi, does anyone have a recursive definition (without span etc...) of a function split list elem which splits a list at the element elem? I just can't find one :-/
07:24:27 <lambdabot> csci: You have 1 new message. '/msg lambdabot @messages' to read it.
07:24:34 <allbery_b> er, ErrorCall
07:24:36 <bakert> that one isn't on my list!
07:24:45 <bakert> aha!
07:25:09 <bakert> I thought error was like an uncatchable exception?
07:25:18 <allbery_b> it would be nice if you could define your own exceptions (this gets back to the earlier discussion about types...)
07:25:32 <allbery_b> error is catchable, you just need to use catch
07:26:22 <bakert> oh.  if I "throwIO (ErrorCall "could not catch monkey") it seems to crash my program without visiting catch.
07:26:25 <bakert> let me paste it.
07:26:37 <pejo> allbery_b, why can't you define your own exceptions?
07:26:43 <chessguy> csci, that shouldn't be hard to write
07:26:47 <hpaste>  bakert annotated "Exception handling?" with "better monkey" at http://hpaste.org/141#1
07:26:55 <allbery_b> pejo: how do you extend Exception?
07:27:18 <chessguy> @hoogle [a] -> a -> [[a]]
07:27:18 <lambdabot> No matches, try a more general search
07:27:22 <csci> chessguy: don't tell me ;-) it shouldn't and I've written little scheme script for a couple of months but atm I'm just totally blind ;-)
07:27:22 <bakert> we're not using renameMonkey yet.  It literally calls monkey which does throwIO (ErrorCall "blah")
07:27:41 <bakert> then i try to catch and fail.
07:27:43 <chessguy> csci, do you want a hint?
07:27:50 <bakert> fail to catch rather than "fail" the function.
07:27:51 <csci> chessguy: A hint would be enough, I thikn
07:28:02 <csci> chessguy: 'am having problems with putting it all together
07:28:04 <bakert> perhaps because the m <- monkey is not in the catch function
07:28:06 <chessguy> csci, i'm not 100% sure, but i think you can use takewhile
07:28:12 <chessguy> @type takeWhile
07:28:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:28:25 <sorear> ~/hpaste$ darcs pull -vvv just freezes trying to connect to 213.242.136.207 :(
07:28:31 <csci> chessguy: ah ok, looks godd
07:28:43 * csci does still not have a good overview over the standard library
07:28:49 <bakert> ?undo m <- monkey; putStrLn $ name m
07:28:50 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
07:28:57 <dancor> i have to get from Double to the IEEE 754 floating-point "double format" bit layout
07:28:58 <bakert> ?undo do { m <- monkey; putStrLn $ name m }
07:28:59 <lambdabot> monkey >>= \ m -> putStrLn $ name m
07:29:16 <pejo> allbery_b, define your own data type WhateverException = CmdLineError String | Panic String deriving (Eq, Typeable) and then throw it with Exception.throDyn?
07:29:27 <bakert> ?undo do { m <- monkey; catch (putStrLn $ name m) (\a -> putStrLn "broken") }
07:29:28 <lambdabot> monkey >>= \ m -> catch (putStrLn $ name m) (\ a -> putStrLn "broken")
07:29:37 <dancor> the java function doubleToLongBits does this.  does anything like that exist in haskell, and if not how do i go about it
07:30:09 <sorear> :t decodeFloat
07:30:11 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
07:30:20 <sorear> > decodeFloat (0.003)
07:30:24 <lambdabot>  (6917529027641082,-61)
07:30:30 <sorear> > decodeFloat (3)
07:30:32 <ndm> @seen dons dcoutts
07:30:32 <lambdabot>  (6755399441055744,-51)
07:30:33 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 3h 4m 23s ago.
07:30:39 <bakert> wahey!  it works!
07:31:00 <dancor> sorear: ah ok i can do some bitpackery on those guys
07:31:02 <sorear> oh. I see earlier comment
07:31:07 <hpaste>  bakert annotated "Exception handling?" with "good monkey" at http://hpaste.org/141#2
07:31:28 <sorear> dancor: if you are willing to sacrifice a little portability...
07:31:43 <dancor> sorear: what do you mean?
07:32:31 <sorear> Prelude GHC.Prim Data.Word> (unsafeCoerce# :: Double -> Word64) 0.003
07:32:31 <sorear> 4569063951553953530
07:32:36 <sorear> that look right?
07:32:41 <dancor> oooh
07:32:59 <dancor> it looks magically right
07:33:15 <hpaste>  bakert annotated "Exception handling?" with "VERY good monkey" at http://hpaste.org/141#3
07:33:44 <bakert> And there it is with the renameMonkey in as well.  And it all works!  You can always tell when your haskell program is going to work because every function becomes one line long!
07:33:55 <sorear> dancor: as you might have guessed with a name like coerce, this won't work on all computers :)
07:34:14 <sorear> also, it is incredibly easy to cause crashes with that function
07:34:19 <bakert> So the question is, how do I get the String out of the ErrorCall Exception at the top level?
07:34:33 <bakert> With pattern matching?
07:34:40 <gotaku> How do I list all currently installed Haskell libraries?
07:34:42 <dancor> sorear: so that or bitpackery
07:34:50 <sorear> gotaku: ghc-pkg list
07:35:16 <sorear> dancor: @where binary might also work ... the three I know of.
07:35:29 <allbery_b> bakert: show?
07:35:31 <dancor> i didn't see Double in Data.Binary
07:35:31 <bakert> yup.  well, i'm very pleased with myself.  chessguy, allbery_b, bringert -- thanks for your help once again!
07:35:33 <dancor> sadly
07:35:45 <dancor> i guess that was too hairy for them to touch
07:35:50 <bakert> allbery_b, I can do it with pattern matching in the error handling lambda
07:35:59 <chessguy> heh. i didn't do much
07:36:06 <allbery_b> if I throwIO (ErrorCall "foo") then show e in the exception handler produces "foo"
07:36:09 <hpaste>  bakert annotated "Exception handling?" with "PERFECT monkey!" at http://hpaste.org/141#4
07:36:26 <bakert> ?seen glguy
07:36:27 <lambdabot> I saw glguy leaving #haskell 4h 18m 36s ago, and .
07:37:12 <dancor> ?seen dancor
07:37:13 <lambdabot> You are in #haskell. I last heard you speak just now.
07:37:19 <bakert> ?tell glguy it would be really great to have some whitespace at the bottom of hpaste pages so that when you click on a link like this: http://hpaste.org/141#4 the code you want is at the top of the page
07:37:20 <lambdabot> Consider it noted.
07:40:20 <sorear> @seen stepcut
07:40:20 <lambdabot> I saw stepcut leaving #haskell-blah and #haskell 3d 20h 35m 22s ago, and .
07:40:38 <sorear> @users
07:40:41 <lambdabot> Maximum users seen in #haskell: 322, currently: 299 (92.9%), active: 35 (11.7%)
07:43:07 <sorear> @where gtk2hs
07:43:08 <lambdabot> http://haskell.org/gtk2hs/
07:43:29 <sorear> whoah!
07:43:36 <sorear> totally new site!
07:44:17 <dmhouse> sorear: what is?
07:45:04 <CloudiDust> Hi all, I am just going mad for monads. Is it true that when we use get in the state monad we do loss the value as we only retained the state?
07:45:06 <sorear> the gtk2hs site
07:45:22 <dmhouse> sorear: since when? It's been like that as long as I remember.
07:45:31 <sorear> CloudiDust: no, values can be rerouted arbitrarily
07:45:42 <CloudiDust> Why?
07:45:46 <sorear> dmhouse: maybe just a new themey-thing
07:46:00 <dmhouse> CloudiDust: well, the value of a State computation is the value of the last expression in your do-block.
07:46:05 <sorear> CloudiDust: do { x <- do_someting ; y <- get ; return x }
07:46:30 <dmhouse> So, say you had do { x <- get; return "blah" }, then "blah" would be the value.
07:46:48 <CloudiDust> Oh, I got it, thanks.
07:47:15 <dancor> sorear: i don't see how you can preserve like -0 going thru decodeFloat
07:47:42 * fasta doesn't like names like more_than_2_elements_in_container
07:48:33 <dancor> sorear: i guess special-case it
07:49:03 <sorear> dancor: or just use unsafeCoerce#. Name one machine that doesn't use IEEE and supports haskell.
07:51:14 <CloudiDust> Get is of the type "State stateType stateType", while the "outter" Monad is of "State stateType valueType". We can still use them in the same do block, does it mean that all State Monads can "live" in the same do-block regardless of their state types and value types?
07:51:38 <sorear> no
07:51:43 <dmhouse> CloudiDust: if you use two state computations in the same do-block they have to have the same state type.
07:51:49 <sorear> instance Monad (State stateType)
07:51:56 <dmhouse> Because the monad isn't actually State, it's State s for any s, where s is your state type.
07:52:09 <sorear> any value type will work, since it isn't part of the monad tycon
07:52:54 <CloudiDust> Thanks a lot. :)
07:54:13 <NichardRixon> ?where fps
07:54:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
07:54:34 <rjseagraves> Can a where clause introduce multiple bindings using the layout rule (instead of { ;...;} )?
07:55:15 <chessguy> what does this mean? tick :: State Int Int
07:55:51 <dmhouse> chessguy: tick is a state computation which can pull from and might modify some state of type Int, and it returns a type Int.
07:55:58 <dmhouse> chessguy: do you understand monads?
07:56:03 <dmhouse> rjseagraves: yes, of course.
07:56:13 <rjseagraves> hmm
07:56:14 <chessguy> dmhouse, to some extent
07:56:20 <dmhouse> rjseagraves: for example:
07:56:27 <dmhouse> where a = foo
07:56:34 <dmhouse>       b = bar
07:56:44 <dmhouse> (Hope you're not using a proportional font.)
07:56:44 <sorear> NichardRixon: just fyi, you don't need fps for 6.6
07:56:46 <dmhouse> Alternatively:
07:56:48 <dmhouse> where
07:56:49 <dmhouse>   a = foo
07:56:52 <dmhouse>   b = bar
07:56:53 <NichardRixon> sorear, I know
07:56:58 <NichardRixon> I just wanted to find the docs again
07:58:03 <chessguy> so the only actual state that exists in tick is of type Int?
07:58:19 <bakert> I've accidentally added a file through a soft link in a darcs repository.  Is there a simple way to sort that out?
07:58:23 <dmhouse> chessguy: yeah.
07:58:27 <fasta> chessguy: yes, and you get it with get
07:58:33 <gotaku> What's an IORef?
07:58:41 <dmhouse> gotaku: a mutable variable.
07:58:59 <chessguy> hmm, but what if i applied some function with type Int -> Char to it
07:59:01 <dmhouse> gotaku: you can read it using readIORef and set it using putIORef.
08:00:14 <chessguy> like tick = do { put 'a'; return 3 }
08:00:33 <chessguy> even though there was an Int there, there won't be anymore
08:00:42 <allbery_b> won't typecheck
08:01:26 <chessguy> ok, so it must both get and put a single Int
08:02:22 <fasta> chessguy: there's a trick by Oleg that can do that.
08:02:31 <fasta> chessguy: I asked about it a few weeks ago.
08:02:39 <fasta> chessguy: but nobody answered.
08:02:53 <fasta> chessguy: It's in the mailing lists where.
08:02:55 <chessguy> how evil is it?
08:02:57 <fasta> somewhere, even
08:03:00 <chessguy> in -cafe?
08:03:03 <fasta> Yes
08:03:24 <dancor> i can't figure out how to use unsafeCoerce#
08:03:26 <chessguy> any recollection about the subject?
08:03:32 <sorear> oh?
08:03:49 <fasta> chessguy: I couldn't find it back myself. Sorry
08:03:50 <sorear> dancor: it (usually) needs a specific type
08:04:02 <chessguy> what's your real name?
08:04:09 <sorear> dancor: it doesn't even parse without -fglasgow-exts
08:04:14 <dancor> sorear: ah
08:04:16 <sorear> chessguy: who are you asking?
08:04:24 <chessguy> sorry, fasta
08:04:58 <fasta> chessguy: what's your real name?
08:05:01 <fasta> ;)
08:05:07 <chessguy> Andrew Wagner
08:05:35 <sorear> fasta: he's already given it away.
08:05:37 <chessguy> sorry, i didn't mean to be rude. i was just going to search the mailing list by your real name
08:05:54 <fasta> chessguy: I didn't answer in that thread.
08:06:06 <chessguy> oh ok
08:06:16 <sorear> fasta: he posted a message by Andrew Wagner and wrote on the wiki as Chessguy - thus betraying his identity.  Weeks ago.
08:06:31 <chessguy> i'll search on oleg
08:06:40 <diogo> hello
08:06:59 <sorear> hello!
08:07:08 <fasta> It could be that Andrew Wagner isn't his real name.
08:07:40 <fasta> Not that I think of chessguy as someone who would do that, but you can't know. It's the Internet after all.
08:07:41 <chessguy> sorear, it's ok, nobody wants my identity anyway :)
08:07:41 <gotaku> What's the difference between haskell and clean?
08:08:04 <sorear> gotaku: haskell is better.  reason: this is #haskell :)
08:08:15 <diogo> whats the meaning of this: arising from use of `Data.Monoid.$dmmconcat'    ??
08:08:35 <diogo> that i am using this?
08:08:58 <sorear> gotaku: seriously - clean has uniqueness types, an interesting if hackish IO solition and a just plain interesting update-in-place solution;
08:09:21 <sorear> haskell has type classes, monads, etc and can do much fancier type computations
08:09:41 <sorear> also, haskell has a much bigger channel, which is a benefit for n00bs
08:09:49 <diogo> like me..
08:09:54 <chessguy> fasta, hmm, i can't find any mention of anything related by oleg either
08:09:55 <gotaku> Haskell just seems very hard to learn...
08:09:57 <bakert> ?undo do {     r <- query connS sql values;     map f r }
08:09:58 <lambdabot> query connS sql values >>= \ r -> map f r
08:10:17 <bakert> gotaku, i agree.  but hopefully that means it pays off big time when you do learn it??
08:10:31 <fasta> chessguy: I could try searching my mail.
08:10:34 <sorear> diogo: can you @paste more context?
08:10:35 <sorear> @paste
08:10:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:11:02 <fasta> Full screen Emacs is pretty nice, btw.
08:11:05 <chessguy> fasta, it's no big deal. if you run across it, i'd be curious, but i wouldn't be surprised if i don't understand it anyway :)
08:11:16 <daniel_larsson> Might be hard, but it's damn fun to learn haskell :)
08:11:21 <fasta> chessguy: the idea is pretty simple, AFAIK.
08:11:38 <bakert> daniel_larsson, i agree. been enjoying my job a lot since i started writing a real program in haskell
08:11:42 <fasta> Just another type parameter.
08:11:49 <bakert> haven't been making lightning progress but it's been fun
08:11:56 <bakert> and when it does work it's about 2 lines of code!
08:12:03 <sorear> hehe.
08:12:08 <sorear> @quote glguy lines
08:12:09 <lambdabot> glguy says: aparently Tor sends all packets with a 512 byte minimum, so if everyone could please write their thoughts on a few lines as possible, it would be appreciated q-:
08:12:18 <sorear> @quote glguy melted
08:12:19 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
08:12:41 <bakert> that's exactly it.  if any function is 3 lines or longer you know you don't know enough haskell yet!
08:13:06 <bakert> it's going to get to the point where things like URLs are 50% of the code in terms of characters because they can't be (readably) compressed!
08:13:37 <bakert> i mean, here's 50% of my "object relational mapping": rsQuery connS sql values f = query connS sql values >>= \r -> map f r
08:13:43 <bakert> that's it!
08:14:09 <allbery_b> ... >>= map f -- ?
08:14:22 <bakert> gak!  it can always get shorter!
08:14:26 <daniel_larsson> yea, can remove r there
08:14:29 <allbery_b> @pl \r -> map f r
08:14:30 <lambdabot> map f
08:14:33 <sorear> eta contract it!
08:14:51 <bakert> that was a 10 line function about 20 minutes ago!
08:15:28 <dmhouse> ?pl r c s v f = query c s v >>= map f
08:15:29 <lambdabot> r = flip flip map . ((flip . (((.) . (>>=)) .)) .) . query
08:15:35 <dmhouse> Hrm, considerably longer.
08:15:40 <chessguy> lol
08:15:41 <bakert> !!!
08:15:44 <dmhouse> ?pl r c s v f = map f =<< query c s v
08:15:45 <lambdabot> r = ((((. map) . (>>=)) .) .) . query
08:15:48 <chessguy> not to mention less readable
08:15:50 <daniel_larsson> I just did that... a bit too obfuscated for my taste :)
08:15:51 <allbery_b> @quote doubles.*flip
08:15:51 <dmhouse> There we go.
08:15:51 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
08:15:57 <dmhouse> Now, isn't that just instantly readable!
08:16:52 <bakert> !
08:16:58 <sorear> :)
08:17:05 <fasta> chessguy: I still can't find it back.
08:17:15 <chessguy> fasta, ok, no problem
08:17:20 <chessguy> thanks for checking
08:17:35 <fasta> chessguy: okmij.org/ftp <search for Haskell> might have it.
08:17:52 <chessguy> ok
08:17:58 <diogo> Overlapping instances for Monoid Metrics
08:17:58 <diogo>       arising from use of `Data.Monoid.$dmmconcat'
08:17:58 <diogo>       at /Users/diogo/2lt/contrib/StrategyLib-5.0/library/MetricsTheme.hs:57:0
08:18:12 <bakert> ?pl rsQuery connS sql values f = query connS sql values >>= \r -> return $ map f r
08:18:13 <lambdabot> rsQuery = flip flip ((return .) . map) . ((flip . (((.) . (>>=)) .)) .) . query
08:18:17 <diogo> the problem is that i don't use any dmmconcat at that line
08:18:19 <fasta> 2lt is to elite?
08:18:25 <fasta> er too elite
08:18:35 <bakert> @pl \r -> return $ map f r
08:18:36 <lambdabot> return . map f
08:18:44 <diogo> lol
08:18:50 <diogo> i need help!
08:19:06 <diogo> i am not elite and i'm working with 2lt
08:19:43 <diogo> i don't understand.. i use the -fallow-overlapping-instances..
08:19:46 <fasta> What's a 2lt?
08:19:56 <gotaku> What does $= mean in HOpenGL?
08:20:00 <diogo> two level  transformation
08:20:33 <ToRA|home> gotaku: you can read it like assignment
08:20:50 <sorear> diogo: can you @paste your code?
08:20:51 <sorear> @paste
08:20:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:21:34 <bakert> OK.  New challenge.  I'm replacing a whole lot of overly complicated Either based code with some exception handling.
08:21:38 <ndm> @seen glguy
08:21:38 <lambdabot> I saw glguy leaving #haskell 5h 3m 48s ago, and .
08:21:55 <bakert> However, at a certain point I need to catch any exception and wrap it in a new exception and rethrow it.
08:22:09 <ndm> @tell glguy one small hpaste comment, the hpaste logo at the top of new when clicked should go to the front page
08:22:10 <lambdabot> Consider it noted.
08:22:11 <bakert> Is there a standard way?
08:22:16 <diogo> instance Monoid Metrics where
08:22:16 <diogo>   mempty        = initMetrics0
08:22:17 <diogo>   mappend m1 m2 = \s -> (m1 s) + (m2 s)
08:22:50 <bakert> Sort of catch (sqlexception e) (newexception "db err: " + e)
08:22:55 <diogo> type Metrics = MetricsName -> Inetger
08:22:57 <bakert> type thing
08:23:00 <sorear> bakert: mapException
08:23:05 <diogo> MetricsName = sString
08:23:15 <bakert> sorear, thanks
08:23:37 <bakert> someone mentioned that earlier but i'd forgotten all about it in the excitement of getting my monkey working.
08:23:38 <bakert> ?hoogle mapException
08:23:39 <lambdabot> Control.Exception.mapException :: (Exception -> Exception) -> a -> a
08:23:53 <sorear> I used hoogle to find it
08:24:04 <bakert> goddamn that is a habit i need to get into.
08:24:20 <bakert> for a while there i was thinking of it first.  but i seem to have become stupid again.
08:24:36 <bakert> it is so good (when it doesn't say "try a more general blah blah")
08:25:14 <Orphi> @type concatMap
08:25:16 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
08:25:26 <bakert> eek it looks hairy.
08:25:29 <gotaku> I now a lot of haskell syntax now but I still can't program anything...
08:25:39 <bakert> gotaku, i know the feeling!
08:26:09 <bakert> gotaku, i write it then i come on here and beg for help.  eventually i have a four line program that does everything i want.  it takes a lot out of me though!
08:26:42 <bakert> but i am gradually accruing knowledge -- mapM and mapM_ and >>= and liftIO and ...
08:26:54 <bakert> today - exception handling!
08:27:13 <Orphi> does anybody here know how to do bitmap graphics in such a way that it actually works?
08:27:14 <bakert> i hope soon to give up do notation forever!
08:27:38 <sorear> don't use hgl?
08:27:56 <sorear> opengl, x11, gtk2hs should all support it
08:28:21 <Orphi> ...which just leaves the minor problems of 1) where do I find the documentation? and 2) how to I install it?
08:28:30 <diogo> another question... is it possible to catch error messages returned by the error func?
08:28:39 <Orphi> I spent 2 hours failing to install HaXml last night :-\
08:28:45 <allbery_b> Control.Exception.catch
08:29:14 <allbery_b> (*not* the catch in Prelude)
08:31:39 <Orphi> oh well, forget it...
08:32:11 <dancor> @hoogle x -> y -> (x, y)
08:32:12 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
08:32:12 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
08:32:43 <allbery_b> @hoogle curry
08:32:44 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
08:32:44 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
08:33:04 <sorear> dancor: I think the function you want is (,)
08:33:08 <sorear> > (,) 1 2
08:33:08 <emu> what would be the ingredients in a Haskell curry?
08:33:09 <lambdabot>  (1,2)
08:33:21 <sorear> @remember emu what would be the ingredients in a Haskell curry?
08:33:22 <lambdabot> Done.
08:35:25 <allbery_b> curry pow(d)er and monadic secret sauce?
08:38:06 <bakert> Does anyone understand dynamic exceptions?  I'm currently raising an ErrorCall but I get the impression from the Control.Exception docs that I should be using Dynamic Exceptions, whatever they are.
08:38:08 <bakert> ??
08:39:39 <dmhouse> bakert: anything wrong with your current approach?
08:41:08 <bakert> dmhouse, well no i suppose not.  just want to do it the "right" way.  avoid future problems.
08:41:43 <bakert> dmhouse, the thing i really want to do is catch exceptions of a certain type and then throw a different type.  the docs for mapException refer to a paper that i'm trying to get hold of.
08:41:52 <bakert> http://portal.acm.org/citation.cfm?id=301637&coll=portal&dl=ACM
08:41:55 <lambdabot> Title: A semantics for imprecise exceptions
08:42:08 <bakert> although really i just need a practical example.
08:52:26 <dmhouse> ?freshname
08:52:27 <lambdabot> Haek
08:52:30 <dmhouse> ?freshname
08:52:31 <lambdabot> Hael
08:54:23 <MarcWebe1> Can I import everything but an instance declaration of a class? I want to use my own show instance.
08:54:50 <sorear> No.
08:57:26 <daniel_larsson> Can wrap it into a newtype, and make your own Show instance on that?
08:58:36 <MarcWebe1> daniel_larsson: Sure. I want to use DrIft to automatically derive them. But I think read show works better if Show/Read are derived both by DrIft. I'll just implement Read manually.
09:07:45 <huschi> @type forM
09:07:46 <lambdabot> Not in scope: `forM'
09:07:48 <huschi> @type forM_
09:07:50 <lambdabot> Not in scope: `forM_'
09:07:56 <huschi> @type Control.Monad.forM_
09:07:58 <lambdabot> Not in scope: `Control.Monad.forM_'
09:08:00 <huschi> @type Control.Monad.forM
09:08:01 <lambdabot> Not in scope: `Control.Monad.forM'
09:08:06 <sorear> huschi: stop! it's not there!
09:08:15 <sorear> huschi: it is 6.6 only
09:08:15 <huschi> ok.
09:08:25 <huschi> and here is 6.4?
09:08:26 <sorear> huschi: lambdabot is still running 6.4
09:08:37 <huschi> ah. i didn't know.
09:08:39 <sorear> 6.5 if you want to split hairs
09:09:07 <sorear> anyway, Monad m => (a -> m b) -> [a] -> m [b]
09:09:30 <huschi> thats the type of mapM :)
09:09:41 <sorear> oh :)
09:09:55 <sorear> anyway, Monad m => [a] -> (a -> m b) -> m [b]
09:10:05 <sorear> forM = flip mapM
09:10:07 <huschi> i know the type, i just wanted to know if there are both versions.
09:10:12 <sorear> there are
09:10:16 <huschi> forM and forM_
09:10:18 <huschi> ok. thx.
09:10:23 <sorear> @docs Control.Monad
09:10:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
09:10:35 <sorear> yes that is the 6.7 docs :)
09:12:10 <chessguy> 6.7? is that coming out soon?
09:12:16 <sorear> no
09:12:24 <sorear> 6.7 will never "come out"
09:12:36 <sorear> it's the number of the darcs
09:12:44 <chessguy> oh, it's on the devel branch?
09:12:47 <sorear> yes
09:13:16 <chessguy> hi monochrom
09:13:32 <monochrom> hi
09:13:48 <j31> *cough* *cough* http://jyte.com/cl/haskell-is-the-best-programming-language-that-exists-today
09:13:51 <lambdabot> Title: Jyte - Haskell is the best programming language that exists today, http://tinyurl.com/2vfsx4
09:14:00 <sorear> but ... we knew that
09:14:05 <sorear> :)
09:14:09 <chessguy> j31, duh?
09:14:31 <monochrom> j31 = jyte?
09:15:19 <sorear> @index inBounds
09:15:19 <lambdabot> bzzt
09:17:19 <gotaku> Hm, I can't get gtk2hs to compile...
09:17:38 <sorear> gotaku: are you sure you're using the darcs version?
09:17:42 <monochrom> missing C headers?
09:17:59 <gotaku> Could not find module `Data.FiniteMap':
09:18:07 <sorear> use the darcs version
09:18:22 <monochrom> Data.FiniteMap is obsoleted in GHC 6.6
09:18:24 <sorear> Data.FiniteMap has been deprecated for years, and is gone in 6.6
09:18:44 <sorear> the darcs version of gtk2hs supports 6.6
09:18:55 <sorear> don't use the release, it's too old
09:18:57 <ndm> sorear: much earlier, was gone with 6.4
09:19:06 <ndm> gotaku: windows or linux?
09:19:27 <sorear> > Data.FiniteMap.lookupFM
09:19:28 <lambdabot>   Not in scope: `Data.FiniteMap.lookupFM'
09:19:31 <gotaku> How do I get the darcs version? Only the tar is listed on the gtk2hs site.
09:19:47 <sorear> gotaku: darcs get http://darcs.haskell.org/gtk2hs
09:19:50 <lambdabot> Title: Index of /gtk2hs
09:19:57 * sorear downloaded it about an hour ago ...
09:20:12 <sorear> even works on head.
09:21:12 <j3h> http://jyte.com/cl/jyte-is-hot-or-not-for-nerds
09:21:14 <lambdabot> Title: Jyte - Jyte is Hot or Not for Nerds
09:23:42 <j3h> that's the best I can do. But my Haskell claim was losing..
09:25:06 <monochrom> Who is this jyte character, spamming us of its shameless plugs?
09:25:18 <chessguy> what a stupid site
09:25:24 <j3h> sorry
09:25:44 <chessguy> what are you, like 8?
09:26:25 <gotaku> How do I compile gtk2hs?
09:26:32 <sorear> I'd have difficulty believing anyone here was half my age ...
09:26:37 <roconnor> why such harsh words?
09:26:45 <sorear> gotaku: autoreconf ; ./configure ; make ; make install
09:27:06 <gotaku> There is no .configure
09:27:12 <sorear> gotaku: if that doesn't work you're probably using an obsolete version of gtk2hs
09:27:12 <roconnor> chessguy: that seemed unneccesary
09:27:25 <sorear> gotaku: of course, autoreconf creates configure
09:27:45 <gotaku> Oh, I didn't see autoreconf
09:27:57 <chessguy> roconnor, and spamming the channel wasn't?
09:27:59 <sorear> gotaku: autoreconf is a system command
09:28:17 <roconnor> chessguy: oh come on, that was hardly spamming
09:28:26 <sorear> and violating the high SPJ's order to stay unsuccessful wasn't?
09:30:12 <roconnor> the last thing we need to do is attack enthusiatic new haskell users.
09:33:22 <chessguy> roconnor, maybe not if he showed any interest in actually learning the language
09:34:44 <chessguy> beyond "omgroflmao, haskell's so cool!"
09:35:40 <bakert> ?ping
09:35:41 <lambdabot> parse error (possibly incorrect indentation)
09:35:43 <fasta> sorear: Age?
09:36:05 <chessguy> ?help ping
09:36:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:36:11 <bakert> ?undo do { r <- rsQ; return $ head r }
09:36:12 <lambdabot> rsQ >>= \ r -> return $ head r
09:36:13 <chessguy> @help ping
09:36:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:36:17 <chessguy> ...
09:36:40 <sorear> fasta: barely 16
09:36:47 <roconnor> chessguy: why couldn't you have just ignored him?
09:36:57 <sorear> I started haskell (but not #haskell) at ~15.5
09:36:58 <allbery_b> lb needs some way to determine how it edit-corrects commands
09:37:03 <bakert> Sorear, fasta, bad time to come in to this conversation ...
09:37:04 <roconnor> or her
09:37:09 <fasta> sorear: you found Haskell early
09:38:11 <chessguy> roconnor, i could have. maybe i went overboard, sorry.
09:39:27 <roconnor> okay, back to haskell then :)
09:39:34 <chessguy> good idea
09:39:48 <allbery_b> "so, how about them lambdas?"
09:40:01 <chessguy> @lambda
09:40:01 <lambdabot>  unlambda: Parse error at end of file
09:40:07 <chessguy> !?
09:40:20 * roconnor wants to learn this lambda-mu-tilde calculus.
09:40:40 <allbery_b> @help unlambda
09:40:41 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
09:41:45 <ski> roconnor : hm, the 'tilde' standing for ?
09:41:53 * allbery_b still wonders what "ping" expanded to.  kind?
09:42:04 <roconnor> there is a mu operator with a tilde over it.
09:42:17 <roconnor> but I don't know what the mu or the mu/tilde mean
09:42:34 <roconnor> it is apparently some way of encoding the sequent-style deductions
09:42:46 <roconnor> I only learned about it last Dec.
09:42:52 <ski> iirc 'mu' is for capturing current continuation .. either that or current value
09:42:56 <fasta> The impossible is happening in my program. How cool is that!
09:43:10 <roconnor> fasta: that happened to me once.
09:43:22 <chessguy> ok, so i'm taking a stab at this. what would this mean? place :: Char -> Int -> State Board ()
09:43:34 <fasta> roconnor: I had GHC to it three times, but now it's just that something happens and I don't expect it.
09:43:41 <fasta> do, even
09:44:32 <gotaku> Damn, gtk2hs failed again...
09:44:39 <chessguy> i'm hoping that it means that place is a function which takes a Char and an Int, potentially modifies a State, which contains a Board structure, and returns nothing
09:44:44 <roconnor> chessguy: I would guess it is a player placing a piece at a particular location on a board.
09:45:00 <gotaku> unknown package: mtl
09:45:29 <chessguy> that's what i want it to be
09:45:38 <allbery_b> gotakyu: where did you get your ghc from?
09:45:57 <allbery_b> -y
09:47:33 <gotaku> apt-get in ubuntu feisty fawn
09:49:10 <gotaku> Ok, the mtl package is installed... I wonder if I need anything else.
09:52:53 <br1> I read in Neil Mitchell's blog that pure funcitons are easier to inline.  How's that?
09:53:46 <allbery_b> any time you inline something you ahve t worry about whether you;'re altering the behavior of side effects
09:53:53 <allbery_b> if you have a pure function, no side efects.
09:54:05 <ndm> br1: because you can inline it without thinking (says Neil Mitchell)
09:54:30 <ndm> br1: in a pure lazy language, you can always inline directly, in a strict language you need to change bits first, ensure evaluation of the arguments
09:54:50 <allbery_b> (and likewise in the other direction with lifting common subexpressions)
09:55:49 <fasta> ndm: and you consider that an advantage?
09:56:09 <ndm> fasta: yes
09:56:15 <ndm> fasta: leads to better composability
09:56:51 <chessguy> so i use execState to place an initial environment in the State?
09:57:27 <Saizan> for initial state i've seen using runState
09:57:38 <chessguy> what's the difference?
09:57:39 <pejo> (Except CSE is tricky for lazy languages, apparently).
09:57:39 <fasta> ndm: I mean, how do you "know" these things, since you only can really know whether there's an advantage when you implemented an optimizing compiler for a pure functional language and one for a non-pure language.
09:57:46 <chessguy> @type runState
09:57:48 <lambdabot> forall s a. State s a -> s -> (a, s)
09:57:50 <Saizan> ?type execState
09:57:51 <lambdabot> forall s a. State s a -> s -> s
09:58:03 <fasta> Some algorithms become easier, ok.
09:58:28 <fasta> But are there fundamental things that a pure language buys you that cannot be recovered?
09:58:31 <ndm> fasta: if you are trying to reason about code or refactor it, you can manually inline without thinking - thats the good thing in my opinion
09:58:33 <roconnor> ?type evalState
09:58:35 <lambdabot> forall a s. State s a -> s -> a
09:59:09 <Saizan> ah, it's only a matter of what you want from the computation?
09:59:10 <chessguy> hmm, i guess i need to find some more examples
09:59:34 <kpreid> Saizan: yes
10:00:12 <ndm> fasta: nothing cannot be recovered, but a lot of things are recovered easier with lazy
10:00:22 <ndm> pejo: thats because of space leaks, a tricky issue in a lazy language
10:01:06 <pejo> ndm, was more  a side note to the un-inlining comment by allbery_b.
10:01:56 <gotaku> It still doesn't compile...
10:02:12 <Saizan> gotaku: what's the error?
10:02:27 <gotaku> unknown package: mtl
10:03:12 <Saizan> did you reconfigure after installing it?
10:03:26 <gotaku> Whoops.
10:04:05 <bakert> ?unpl mapM (liftM (renderHtml . reportToHtml) . report)
10:04:06 <lambdabot> mapM (\ c -> liftM (\ f -> renderHtml (reportToHtml f)) (report c))
10:04:37 <gotaku> Saizan... same problem.
10:05:43 <pejo> fasta, what was it ndm knew that he had to have implemented two optimizing compilers for?
10:06:23 * ndm has only implemented one optimising compiler :(
10:06:56 * LoganCapaldo has implemented 0 optimizing compilers :(
10:08:23 * roconnor has implemented -1 optimising compliers :(
10:08:45 <ski> pessimizing ?
10:08:51 <roconnor> exactly
10:08:59 <roconnor> it takes your code, and makes it worse.
10:09:10 <ski> obfuscator ?
10:09:23 <ski> or unintensional ?
10:09:38 <roconnor> well, maybe it wasn't as bad as I make it out.
10:09:57 <roconnor> I had 8 or so general purpose registers, but I only used 2.
10:10:26 <roconnor> The resulting assembly would constantly be storing data to memory, and then reloading it back into the same register.
10:11:11 <LoganCapaldo> Hm, Parrallel List Monad == MapReduce?
10:11:13 <roconnor> Actually I made a mistake in one place in my code, and patched by using a 3rd register.
10:11:33 <roconnor> easier than making it work ``properly''
10:11:48 <ski> (hmm .. reminds me of 6502 assembler)
10:12:31 <roconnor> this was DLX... I think.
10:13:09 <roconnor> DLX appears to be an assembly language, so I guess I got it right.
10:13:45 * ski 's never heard of that
10:13:49 <roconnor> oh man, I think there were 31 register
10:13:56 <roconnor> and I used 2
10:13:59 <roconnor> er, 3
10:14:13 <ski> 2.1 ?
10:14:36 <roconnor> I intended to use 2, but ended up using 3.
10:14:46 <roconnor> or maybe I inteded to use 3 and ended up using 4.
10:14:56 <Saizan> ... i used 10 registers just to do a matrix-product..
10:14:59 <roconnor> Well, it was a long time ago, back in 2nd year undergrad
10:15:04 <ski> (but how often did you use the extra one ?)
10:15:12 <roconnor> rarely.
10:15:46 <roconnor> @wikipedia DLX
10:15:49 <lambdabot> No Result Found.
10:15:54 <acro> anyone use haskell-mode on xemacs? i'm trying to figure out if the major/minor mode is "Haskell Ind Doc" ? (i'm not getting any colorization and am wondering if i'm in the wrong mode)
10:16:08 <roconnor> lambdabot: fine, I'll do it myself.  http://en.wikipedia.org/wiki/DLX
10:16:21 <ndm> how do i load two modules with GHCi?
10:16:33 <allbery_b>  :m +...
10:16:42 <roconnor> ``The DLX is essentially a cleaned up and simplified MIPS with a simple 32-bit load/store architecture.''
10:17:40 <bakert> ?unpl mapM (liftM (renderHtml . reportToHtml) . report)
10:17:41 <lambdabot> mapM (\ c -> liftM (\ f -> renderHtml (reportToHtml f)) (report c))
10:18:14 <pejo> acro, did you turn on font-lock-mode?
10:18:39 <Procyon_> acro: turn-on-haskel-font-lock
10:19:41 <acro> M-x turn-on-haskell-font-lock yields "Symbol's function definition is void: charsetp"
10:20:21 <allbery_b> I ended up patching some things and then upgrading to a newer xemacs
10:21:18 <jumps54321> GHC optimization question:  I have a function that produces a list comprehension that is immediately consumed with 'sum', expecting that the list comprehension will never really occur -- that is it should just be translated into a loop.  When I write the exact same code with 'foldl (+) 0' it is 3x slower and consumes lots of mem. (if the list is long enough the foldl version with run out of mem., while the sum version is fine)
10:21:32 <jumps54321> sorry for the long post
10:21:42 <xerox> ?src sum
10:21:42 <lambdabot> sum = foldl (+) 0
10:21:55 <roconnor> @type foldl'
10:21:56 <acro> yeh, that's the bad part of .deb pkgs, all i get is .elc files .. no .el files to mess with
10:21:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:22:14 <jumps54321> i can only imagine that it is a special optimization by GHC
10:22:16 <roconnor> doesn't sum use foldl'?
10:22:27 <chessguy> @type runExec
10:22:39 <roconnor> jumps54321: try using foldl' to see what the results are.
10:22:51 <chessguy> @type runState
10:22:51 <lambdabot> Not in scope: `runExec'
10:22:52 <lambdabot> forall s a. State s a -> s -> (a, s)
10:23:03 <jumps54321> only in the formal definition, compilers are free to optimize any way they like as long it is equivalent code
10:23:04 <roconnor> ?help src
10:23:05 <lambdabot> src <id>. Display the implementation of a standard function
10:23:13 <jumps54321> is foldl' diff. from fold?
10:23:18 <jumps54321> foldl, i mean
10:23:19 <chessguy> @type execState
10:23:22 <lambdabot> forall s a. State s a -> s -> s
10:23:29 <roconnor> jumps54321: foldl' has some strictness properties to it.
10:23:34 <jumps54321> ah
10:23:41 <roconnor> it often reduces memory consumption A LOT
10:23:50 <roconnor> and that can have a huge impact on performace
10:24:04 <jumps54321> what package is it in?
10:24:18 <roconnor> that's a good question
10:24:21 <Saizan> =hoogle foldl'
10:24:22 <roconnor> @hoogle foldl'
10:24:22 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
10:24:29 <kolmodin> does -fasm work on all platforms?
10:24:30 <jumps54321> thx
10:25:03 <kolmodin> I'm mostly interested in ppc?
10:25:08 <jumps54321> yes, that is the difference
10:25:23 <jumps54321> that version is equivalent to 'sum' as far as I can tell
10:25:24 <pejo> kolmodin, darwin/ppc is supported by the ncg, afaik.
10:25:32 <roconnor> there is a nice wiki page on foldl vs foldl'
10:25:37 <kolmodin> pejo: ok
10:26:04 <chessguy> @type evalState
10:26:05 <roconnor> the result is that you almost never want to use foldl
10:26:06 <lambdabot> forall a s. State s a -> s -> a
10:26:09 <kolmodin> pejo: so using -fasm on ppc is probably ok?
10:26:34 <jumps54321> thx a lot
10:28:10 <kolmodin> lets hope so.. :)
10:28:18 <pejo> kolmodin, if ghc is built without ncg you get a panic, with the impossible happened, and a message to use -fvia-C
10:28:32 <kolmodin> ok, good
10:29:17 <kolmodin> I don't have to use it, it would just be nice
10:33:45 <chessguy> grrr, i don't see how this state monad is simplifying my code
10:34:57 <chessguy> !paste
10:34:58 <hpaste> Haskell paste bin: http://hpaste.org/
10:35:30 <sorear> tellfodder
10:36:08 <chessguy> ok, http://hpaste.org/142
10:36:24 <chessguy> i just wrote the placeOnBoard function
10:36:47 <chessguy> but i don't see how it simplifies my main. won't it essentially be the same thing?
10:37:45 <sorear> @ask glguy <chessguy> ok, http://hpaste.org/142 <-- what's wrong with this picture? and why a energy-saving measure not the default, like it is with lisppaste?
10:37:46 <lambdabot> Consider it noted.
10:38:10 <chessguy> i just forgot to hit the annotate
10:38:14 <chessguy> err, announce
10:38:22 <sorear> chessguy: nobody does.
10:38:36 <ToRA|home> chessguy: it looks like you want the code of your main function to be under a StateT Board IO () to get the benefit?
10:38:46 <sorear> chessguy: making it so people have to go out of there way to announce, nobody will do it.
10:38:59 <sorear> IANAGLP
10:39:26 <chessguy> ToRA|home, well, i'd like the stateful interaction to remain pure, and separate it from the IO eventually
10:40:48 <bakert> Trying to wrap each call to report in a catch here but can't work out where it goes.
10:40:49 <bakert> reports = mapM (liftM (renderHtml . reportToHtml) . report)
10:42:26 <ToRA|home> chessguy: i've annotated with what it could look like (loosly) if you used a StateT
10:42:29 <bakert> This doesn't work: reports = mapM (liftM (renderHtml . reportToHtml) . (catch (report) (return "hello")))
10:42:55 <bakert> ?unpl reports = mapM (liftM (renderHtml . reportToHtml) . report)
10:42:56 <lambdabot> reports = mapM (\ c -> liftM (\ f -> renderHtml (reportToHtml f)) (report c))
10:44:13 <chessguy> ToRA, that's about what i figured, but 1.) where's the benefit? and 2.) where's the decomposition of IO and state?
10:44:43 <ToRA|home> so, 1. the benefit is you're not threading through the board's numerically
10:44:51 <allbery_b> do you want the (.) between them?
10:45:12 <allbery_b> seems to me you just want the catch with no (.)
10:45:22 <chessguy> ToRA|home, what do you mean, threading through the boards numerically?
10:45:47 <ToRA|home> let board1 = , let board2 = f board1, board3, board4 etc.
10:45:47 <hpaste>  yaxu pasted "compile error - not finding library" at http://hpaste.org/143
10:46:21 <sorear> @tell glguy http://hpaste.org/999 - note error
10:46:22 <lambdabot> Consider it noted.
10:46:22 <chessguy> modify (place board1 (firstFree board1) 'O')
10:46:22 <chessguy>   liftIO.putStrLn $ ("New board:" ++ board2)
10:46:28 <yaxu> ghc is looking for `Sound.SC3.Server.Play' in /usr/local/lib/Hsc-0.1/ghc-6.6/Sound/SC3/Server/Play.hi, which doesn't exist
10:46:36 <chessguy> ToRA|home, ^^
10:46:45 <yaxu> yet /usr/local/lib/Hsc-0.1/ghc-6.6/Sound/SC3.hi does exist
10:46:50 <ToRA|home> ah sorry, my bad on the annotation
10:47:03 <ToRA|home> @type modify
10:47:09 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
10:47:38 <sorear> ToRA|home: you might want State(T)
10:47:38 <ToRA|home> so you would call modify with a function of type (essentially) Board -> Board
10:47:43 <sorear> @type StateT
10:47:44 <lambdabot> forall a (m :: * -> *) s. (s -> m (a, s)) -> StateT s m a
10:47:55 <sorear> @type State
10:47:57 <lambdabot> forall a s. (s -> (a, s)) -> State s a
10:48:00 <yaxu> where am i going wrong?
10:48:02 <chessguy> ToRA, like placeOnBoard?
10:48:09 <ToRA|home> sorear: i'm using StateT ;)
10:48:48 <chessguy> anyway, i think modify is what i was missing in there
10:48:55 <sorear> ToRA|home: if you want a value (as well as a result), you should use StateT instead of modify
10:48:56 <ToRA|home> chessguy: your place function is functional and doesn't create intermediate boards yes?
10:49:06 <chessguy> ToRA, right
10:49:06 <ToRA|home> so you can consider place :: Board -> Board
10:49:18 <ToRA|home> (well a curried variant of place anyways)
10:49:19 <sorear> partial application!
10:49:25 <chessguy> ah, ok
10:49:30 <ToRA|home> so you just use modify (place curried) inside the do
10:49:39 <ToRA|home> and the board in the state is updated as you go
10:49:51 <chessguy> yes
10:49:54 <chessguy> that makes sense
10:50:16 <beelsebob> *giggle* http://www.joyoftech.com/joyoftech/joyimages/915.gif
10:50:26 <chessguy> what about the decomposition from IO?
10:50:42 <sorear> chessguy: parametricity guarantees purity.
10:50:58 <sorear> chessguy: a value of type forall m. StateT Board m () cannot do IO
10:53:16 <chessguy> company calls. thanks for the help
10:53:20 <sorear> yw
10:53:25 <ToRA|home> np
10:55:56 * yaxu sighs at cabal
11:00:54 <yaxu> somehow ghc doesn't know to look for Sound.SC3.Server.Play in Sound.SC3
11:01:06 <yaxu> "    Can't find interface-file declaration for audition
11:01:06 <yaxu>       Probable cause: bug in .hi-boot file, or inconsistent .hi file"
11:01:06 <bakert> ?pl reports accts = mapM (\x -> catch (liftM (\rpt -> renderHtml (reportToHtml rpt)) (report x)) (\(ErrorCall e) -> return ("Could not produce report for XXX because of " ++ e))) accts
11:01:07 <lambdabot> (line 1, column 15):
11:01:08 <lambdabot> unexpected "="
11:01:08 <lambdabot> expecting variable, "(", operator or end of input
11:02:27 <bakert> ?pl mapM (\x -> catch (liftM (\rpt -> renderHtml (reportToHtml rpt)) (report x)) (\(ErrorCall e) -> return ("Could not produce report for XXX because of " ++ e))) accts
11:02:38 <lambdabot> (line 1, column 91):
11:02:38 <lambdabot> unexpected "e"
11:02:38 <lambdabot> expecting operator or ")"
11:13:17 <hpaste>  procyon pasted "Problems adding lists to interpreter" at http://hpaste.org/145
11:13:40 <Procyon_> I'm getting naughty errors with this code and I'm lost.
11:14:49 <ToRA|home> can you paste the errors?
11:15:37 <hpaste>  procyon annotated "Problems adding lists to interpreter" with "Errors" at http://hpaste.org/145#1
11:16:38 <Procyon_> It's something about lists in my lambda expressions.  I'm not doing it right, but I'm not sure what's wrong.  All the non-list expressions work great.
11:16:58 <allbery_b> you need to extract the list from the expr, don't you?
11:17:57 <Procyon_> ah, um.. doh!
11:18:01 <ToRA|home> on a guess: cons = Function $ \a -> Function $ \List b -> List (a:b) ?
11:18:06 <Procyon_> Like I did the int in add
11:18:21 <ToRA|home> yeah
11:19:11 <Procyon_> thanks much.
11:20:03 <xic> how do i parse a unicode String from a utf8 String value?
11:20:13 <sorear> there's no such thing
11:20:25 <sorear> String is by definition Chars, not bytes
11:20:31 <sorear> UTF8 is bytes
11:20:39 <sorear> therefore no String is UTF8
11:20:54 <xic> right but i build my String by reading bytes from a utf8 stream
11:21:28 <monochrom> For the most part each Char is a Unicode code point, no encoding.
11:21:31 <sorear> then it's not a "utf8 string"
11:21:44 <xic> ok, but what can i do?
11:21:52 <sorear> "utf8 string" to us is proof of misunderstanding
11:22:09 <yaxu> what is an interface file?
11:22:23 <sorear> .hi
11:22:40 <monochrom> haddock has its own interface files.
11:22:42 <sorear> it's kinda like a C .h file, except it's automatically generatied
11:22:43 <xic> i have a utf8 file, i read each byte into a Char and end up with a String. i need to convert this to a real unicode String
11:22:49 <sorear> oh
11:23:05 <bakert> ?pl             (liftM (\rpt -> renderHtml (reportToHtml rpt)) (report x))
11:23:06 <lambdabot> fmap (renderHtml . reportToHtml) (report x)
11:23:15 <bakert> :t fmap
11:23:17 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
11:23:19 <sorear> step 1: complain. step 2: find a copy of darcs.  step 3: lift out the UTF8.lhs file
11:23:47 <xic> hm...
11:24:37 <yaxu> sorear: ah, i've installed this library using cabal, and something is screwed
11:30:20 <Procyon_> @hoogle [a]->bool
11:30:21 <lambdabot> Did you mean: [a] -> Bool
11:30:21 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
11:30:21 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
11:30:29 <koala_man> how do I read a list of lines from stdin until eof?
11:30:41 <sorear> lines `fmap` getContents
11:30:44 <Procyon_> @hoogle [a]->Bool
11:30:45 <lambdabot> Prelude.null :: [a] -> Bool
11:30:45 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
11:30:45 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
11:31:13 <koala_man> ooh, nice
11:31:16 <koala_man> thanks
11:31:32 <xic> sorear: thanks, that file looks good... but who should i complain to?
11:31:58 <sorear> GHC HQ
11:32:38 <sorear> I think they already have a ticket
11:33:00 <sorear> I think it's in "if you want it that badly, implement it yourself" status
11:33:28 <Saizan> do you find a [co]monad explanation more clear using [co]bind to define [co]join or [co]join to define [co]bind?
11:33:30 <yaxu> how does ghc keep track of what is installed via cabal?
11:33:36 <sorear> ghc-pkg
11:33:47 <sorear> Saizan: why is it exclusive?
11:33:54 <sorear> class Monad where
11:34:00 <sorear>   join x = x >>= id
11:34:11 <sorear>   a >>= f = join (fmap f a)
11:34:21 <sorear> you can have both!
11:34:34 <Saizan> isn't it fmap f (join a)?
11:34:40 <sorear> no
11:34:55 <sorear> :t \a f -> liftM f (join a)
11:34:57 <lambdabot> forall r (m :: * -> *) a. (Monad m) => m (m a) -> (a -> r) -> m r
11:35:16 <sorear> :t \a f -> join (liftM f a)
11:35:18 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> (a1 -> m a) -> m a
11:35:23 <Saizan> ah, right that's for comonads
11:35:37 <yaxu> i mean how does ghc-pkg keep track - it thinks something is installed that i've deleted it
11:35:57 <Saizan> you have to ghc-pkg unregister it
11:36:13 <sorear> yaxu: ~/.ghc/i386-linux-6.7/package.conf
11:39:14 <yaxu> i see, thanks
11:40:43 <emu> this here line is to contribute to the growth of the #haskell activity graphs
11:41:03 <emu> just doing my part
11:41:29 * koala_man salutes
11:52:51 <fasta> If foo has as output 1 and bar 2, how can I compare those two values with an arrow expression for equality? (foo &&& bar <something else> ) input
11:53:59 <ohmega> fasta: why not use the if syntax?
11:54:16 <sorear> (foo &&& bar >>> arr (uncurry (==))) ?
11:54:18 <br1> so, why is ContT s (StateT b IO a) so under appreciated?
11:54:22 <sorear> \foo bar -> (foo &&& bar >>> arr (uncurry (==)))
11:54:30 <sorear> :t \foo bar -> (foo &&& bar >>> arr (uncurry (==)))
11:54:32 <lambdabot> forall b c' (a :: * -> * -> *). (Arrow a, Eq c') => a b c' -> a b c' -> a b Bool
11:54:46 <fasta> sorear: Ok, so there's no direct way to do it.
11:54:49 <sorear> fasta: answered?
11:55:13 <sjanssen> @type \foo bar -> liftM2 (==) foo bar
11:55:13 <fasta> sorear: yes, if it means it cannot work without arr.
11:55:15 <lambdabot> forall a2 (m :: * -> *). (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
11:55:15 <sorear> fasta: there are easier ways, no doublt
11:55:36 <chessguy> ok, time to apply this stateful stuff to tic-tac-toe
11:55:37 <sorear> sjanssen: Arrow a => (a b) is an undeclarable functor :(
11:55:41 <sorear> applicative even
11:55:52 * sorear check HHL
11:55:59 <sjanssen> ah yes, fasta specifically wanted Arrows
11:56:22 <sjanssen> HHL == Haskell Hierarchical Libraries?
11:56:33 <koala_man> how do I find if and where a substring appears in a string?
11:56:34 <sorear> :t \foo bar -> (foo &&& bar >>>^ uncurry (==)) -- look ma, no arr!
11:56:36 <lambdabot> Not in scope: `>>>^'
11:56:41 <sorear> koala_man: isInfixOf iirc
11:56:44 <sorear> sjanssen: yes
11:57:03 <sjanssen> surely >>>^ uses arr in it's implementation
11:57:08 <sjanssen> @hoogle infix
11:57:09 <lambdabot> Prelude.infix :: keyword
11:57:10 <lambdabot> Data.Generics.Basics.Infix :: Fixity
11:57:10 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
11:57:11 <sorear> :t \foo bar -> (foo &&& bar >>^ uncurry (==)) -- look ma, no arr!
11:57:13 <lambdabot> forall (a :: * -> * -> *) b c'. (Arrow a, Eq c') => a b c' -> a b c' -> a b Bool
11:57:20 <sorear> sjanssen: yes
11:57:47 <sjanssen> koala_man: I don't think there is a substring search implementation in the standard libraries
11:58:01 <sorear> fasta: if you can use Applicative, liftA2 (==) is what you wamt
11:58:03 <koala_man> weird
11:58:17 <ToRA|home> are there any good docs / tutorials on when you should use arrows / declare your own?  other than for parsing libraries or automaton...
11:58:39 <sjanssen> @let isSubstringOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:58:41 <lambdabot> Defined.
11:58:59 <sjanssen> > isSubstringOf "nan" "banana"
11:59:01 <lambdabot>  True
11:59:20 <sjanssen> koala_man: feel free to use that substring test ^^^
11:59:54 <sorear> sjanssen: HHL, Data.List:    isInfixOf :: Eq a => [a] -> [a] -> Bool
12:00:04 <sorear> (latest HHL)
12:00:35 <sorear> works in my ghci (6.7)
12:00:35 <sjanssen> ah, must've made it in base 2.0
12:00:56 <sjanssen> koala_man: use Data.List.isInfixOf if you have GHC 6.6
12:01:21 <koala_man> how about hugs
12:01:42 <sorear>    isSubstringOf :: ByteString -> ByteString -> Bool
12:01:42 <sorear>    findSubstring :: ByteString -> ByteString -> Maybe Int
12:01:42 <sorear>    findSubstrings :: ByteString -> ByteString -> [Int]
12:01:43 <fasta> sorear: How would liftA2 work then? Substituting it for arr (uncurry (==)) is not equivalent.
12:02:07 <sorear> fasta: liftA2 is for Applicative, which is similar in power to Arrow
12:02:28 <sorear> liftA2 :: Applicative a => (b -> c -> d) -> a b -> a c -> a d
12:02:32 <sjanssen> koala_man: Hugs Sep. 2006 has it
12:02:41 <fasta> sorear: ok, so they are not compatible.
12:03:32 <koala_man> do the haskell libs have versions of some kind or are they just evolving differently in each implementation?
12:03:33 <sorear> fasta: it is possible (with undecidable instances anyways) to write instance Arrow a => Applicative (a i), and use liftA2 with arrows
12:03:35 <fasta> I need a WrappedArrow
12:04:07 <fasta> sorear: does it automatically pick WrappedArrow with undecidable instances?
12:04:07 <sorear> pure = arr . const
12:04:34 <sorear> a <*> b = a &&& b >>^ ($)
12:04:39 <sorear> fasta: iirc no
12:04:39 <dcoutts> gotaku, ah yes, checking for mtl. Yes I intend to make ./configure check for mtl for the next release candidate.
12:04:39 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:04:41 <fasta> Arrow a => Applicative (WrappedArrow a b) <- that was the instance I was referring to.
12:05:25 <fasta> sorear: ah, you are referring to something not in the libs.
12:05:30 <fasta> sorear: I misunderstood.
12:05:31 <dcoutts> kolmodin, yeah, Igloo fixed the executable stack issue
12:10:51 <kolmodin> dcoutts: ok, nice
12:11:07 * kolmodin cleans the gentoo TODO
12:13:41 <chessguy> http://hpaste.org/146
12:13:48 <chessguy> i'm close
12:14:21 <chessguy> Couldn't match expected type `StateT t1 t a'
12:14:22 <chessguy>            against inferred type `IO ()'
12:14:22 <chessguy>     In the first argument of `execStateT', namely `delegatedMain'
12:17:00 <ToRA|home> i think you'll need to make all of your io calls in delegatedMain prefixed with liftIO or just lift
12:17:10 <ToRA|home> though that isn't what's causing the error report
12:17:41 <ToRA|home> chessguy: what happens if you put a type signature on delegatedMain ?
12:17:56 <chessguy> i would've thought that the interaction with place would cause it to be of some type other than IO ()
12:18:18 <chessguy> you  mean like delegatedMain :: StateT t1 t a
12:18:24 <ToRA|home> StateT Board IO ()
12:18:31 <chessguy> err, yeah
12:18:31 <ToRA|home> yeah, something specific
12:19:15 <ToRA|home> @type get
12:19:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
12:19:19 <chessguy> hmm
12:19:21 <chessguy>  Couldn't match expected type `StateT t1 t t11'
12:19:21 <chessguy>            against inferred type `IO ()'
12:19:21 <chessguy>     In the expression: putStrLn "Enter your move:"
12:19:26 <ToRA|home> right
12:19:37 <ToRA|home> that should be liftIO (putStrLn "En..")
12:19:41 <chessguy> so it'll have to be liftIO $ ...
12:19:45 <chessguy> yeah
12:19:54 <ToRA|home> your use of get needs modifying
12:20:31 <chessguy> oh?
12:20:45 <chessguy> modify(get) :)
12:20:53 <ToRA|home> heh, no
12:20:59 <ToRA|home> if you want a board you need to do
12:21:01 <chessguy> just kidding
12:21:01 <ToRA|home> board <- get
12:21:04 <ToRA|home> :)
12:21:12 <chessguy> hmm
12:21:16 <ToRA|home> e.g.
12:21:22 <ToRA|home> cBoard <- get
12:21:33 <ToRA|home> putStrLn ("New board: " ++ board )
12:21:34 <ToRA|home> but
12:21:36 <chessguy> ugh, then i'll still need the numbered boards
12:21:37 <ToRA|home> that's kinda horrible
12:21:39 <ToRA|home> yeah
12:22:35 <ToRA|home> there should be a way to pass the state to an io func without you seeing it
12:23:14 <ToRA|home> possibly gets ("New board: " ++ ) >>= lift.putStrLn
12:23:32 <chessguy> @type gets
12:23:34 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
12:23:49 <ToRA|home> so gets let you apply a function to the state as you get it back
12:25:10 <ToRA|home> you could alternatively make a helper function that lets you get the state and print it out so you don't need numbered boards if that's simpler to understand
12:25:34 <chessguy> well, eventually of course, i want to put it all in a loop
12:25:48 <chessguy> with some kind of game-end check
12:26:57 <ToRA|home> ah ok
12:27:17 <chessguy> ok, let's see what happens
12:27:20 * chessguy crosses fingers
12:27:20 <hpaste>  ToRA|home annotated "Almost works..." with "possibly print out method helper" at http://hpaste.org/146#1
12:28:18 <chessguy> well, the gets.... method doesn't required a numbered board anyway
12:29:06 <ToRA|home> chessguy: sure, though i like to make my do statements read like english when possible, so i use lots of helpers to do things like that
12:29:25 <chessguy> that makes sense
12:29:31 <chessguy> i'll factor it out, once it works
12:29:40 <chessguy> Couldn't match expected type `StateT t1 t t11'
12:29:40 <chessguy>            against inferred type `IO String'
12:29:40 <chessguy>     In a 'do' expression: move1 <- getLine
12:29:50 <ToRA|home> again, lift / liftIO
12:29:58 <ToRA|home> move1 <- lift getLine
12:30:01 <chessguy> oh, whoops
12:30:04 <ToRA|home> :)
12:30:59 <chessguy> and that's all because i'm not in the IO monad anymore, right? i'm in the StateT monad?
12:31:08 <ToRA|home> the lift's, yeah
12:31:41 <ToRA|home> the lift basically moves you into the inner monad
12:31:41 <chessguy> hrmmm
12:32:05 <ToRA|home> if you have several nested StateT's you could use liftIO to jump straight into the IO without needing lift.lift.lift etc.
12:32:15 <chessguy> Couldn't match expected type `StateT t1 t t11'
12:32:15 <chessguy>            against inferred type `IO String'
12:32:15 <chessguy>     In a 'do' expression: move1 <- getLine
12:32:15 <chessguy>  ... In the first argument of `lift', namely `getLine'
12:32:15 <chessguy>     In a 'do' expression: move1 <- lift getLine
12:32:48 <ToRA|home> hmm
12:33:28 <ToRA|home> can you paste the whole code as it stands now?
12:35:01 <hpaste>  chessguy annotated "Almost works..." with "Current code" at http://hpaste.org/146#3
12:36:00 <ToRA|home> ok:
12:36:01 <qwr> chessguy: move1 <- liftIO getLine, when you have StateT t IO String?
12:36:02 <ToRA|home> delegatedMain :: StateT String IO ()
12:36:24 <chessguy> augh
12:36:28 <chessguy> i forgot to change that
12:36:48 <ToRA|home> the next one is your use of get in the middle of firstFree in the middle of place
12:37:25 <chessguy> oh yes
12:37:29 <ToRA|home> i'd suggest making a helper function of the form \board -> place (firstFree board) '0' ?
12:37:40 <TomMD> Is there a good (non programmer intensive) way to convert any arbitrary data structure to bytes (ex: for transmission over a network)?
12:38:01 <ToRA|home> chessguy: s/?/board above
12:38:28 <allbery_b> ?where binary
12:38:29 <lambdabot> http://darcs.haskell.org/binary
12:38:36 <allbery_b> TomMD ^^^
12:38:44 <TomMD> allbery_b: looking, thanks.
12:39:22 <hpaste>  bringert pasted "bytestring memory leak" at http://hpaste.org/147
12:40:17 <chessguy> ToRA, so makeMove :: Board -> Board ?
12:40:23 <bringert> how do I avoid that leak?
12:40:59 <ToRA|home> chessguy: yeah assuming you don'nt want/need to parameterise it by anything
12:41:15 <chessguy> for now i won't
12:41:59 <Bourbaki> haskell chess?
12:42:16 <chessguy> Bourbaki, starting with tic-tac-toe :)
12:42:37 <Bourbaki> ah
12:42:53 <chessguy> ?wiki TicTacToe
12:42:54 <lambdabot> http://www.haskell.org/haskellwiki/TicTacToe
12:42:57 <Bourbaki> chessguy : you dont happen to be interested in building a ai haskell repositiy?
12:43:12 <bringert> dons, dcoutts, kolmodin: do you have any ideas how to avoid this memory leak: http://hpaste.org/147 I suspect that that's what's making my tar eat memory when extracting
12:43:28 <chessguy> Bourbaki, interested, yes. able, probably not
12:43:36 <Bourbaki> ah a pitty
12:43:53 <chessguy> i'm hoping to move that direction with this project eventually
12:44:01 <Bourbaki> thats cool
12:44:01 <dcoutts> bringert, hmm
12:45:17 <ToRA|home> chessguy: may be useful:
12:45:21 <ToRA|home> > unlines.takeWhile (not.null) $  unfoldr (Just . splitAt 3) $ " x o o  x"
12:45:23 <lambdabot>  " x \no o\n  x\n"
12:45:25 <bringert> dcoutts: basically, the tar code splits the input into a lazy list of lazy bytestrings, using Data.Binary.Get.getBytes, and then does mapM_ writeFile on that list
12:45:47 <bringert> dcoutts: I figured that that would be roughly equivalent to the code I pasted
12:46:01 <dcoutts> bringert, so you think that BS.splitAt is holding onto the first part while you write the second ??
12:46:13 <dcoutts> ??/?
12:46:20 <bringert> dcoutts: yes
12:46:23 <chessguy> ToRA, i can't imagine what i'd use that for :)
12:46:31 <dcoutts> bringert, lemme check the impl for clues
12:47:07 <ToRA|home> chessguy: i'm sure it'll come to you
12:47:21 <chessguy> hehe
12:47:25 <Bourbaki> chessguy : how are you thinking to solve tictactoe?
12:47:45 <chessguy> @pl makeMove b = place (firstFree b) 'O' b
12:47:45 <lambdabot> makeMove = flip place 'O' =<< firstFree
12:48:11 <chessguy> cute
12:48:13 <ToRA|home> @type firstFree
12:48:23 <lambdabot> Not in scope: `firstFree'
12:48:24 <bringert> dcoutts: well, I guess the problem is mostly before I have started touching the second part
12:48:29 <chessguy> firstFree :: Board -> Int
12:48:46 <ToRA|home> but how did lambdabot know that?
12:48:53 <dcoutts> bringert, oh, you think we're forcing the second part
12:49:01 <chessguy> Bourbaki, i figured i'd start by implementing a brute-force solver
12:49:07 <bringert> hmm
12:49:08 <chessguy> then a lazy alpha-beta solver
12:49:12 <Bourbaki> ah nice
12:49:13 <chessguy> and go from there
12:49:15 <bringert> I don't know acutally
12:49:23 <chessguy> i found a nice paper on lazy A-B
12:49:33 <Bourbaki> make sure you put that stuff on the haskell wiki in the end
12:49:40 <chessguy> oh i will
12:49:54 <chessguy> that's a ways down the road. i've got to unhideous the code first :)
12:50:10 <chessguy> ToRA, it didn't know that
12:50:16 <chessguy> oops
12:50:20 <chessguy> ToRA|home, ^^
12:50:25 <monochrom> ?seen dons
12:50:26 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 8h 24m 14s ago.
12:50:30 <ToRA|home> chessguy: yeah, i just realised
12:50:35 <bringert> dcoutts: I think that maybe the z variable holds on to the beginning of the string, keeping if from being garbage collected after it has been writen out
12:50:59 <ToRA|home> i was just thrown to see the >>= in there, i'm guessing (->) is an instance of monad...
12:51:16 <chessguy> @type (->)
12:51:28 <lambdabot> parse error on input `->'
12:51:36 <dcoutts> bringert, try using, take & drop instead
12:51:36 <ToRA|home> @instances Monad
12:51:38 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:51:56 <ToRA|home> (and indeed it is)
12:52:09 <chessguy> hmm, /slap no longer works
12:52:12 <chessguy> @slap chessguy
12:52:13 <lambdabot> why on earth would I slap chessguy
12:52:21 <chessguy> @slap lambdabot
12:52:22 * lambdabot beats up lambdabot
12:52:25 <bringert> dcoutts: same problem
12:52:39 <dcoutts> bringert, really? hmm that's not good.
12:52:48 <chessguy> anyway
12:53:08 <bringert> dcoutts: well, z = BS.drop 500000000 x will hold on to the head until you force it, right?
12:53:15 <dcoutts> bringert, yes
12:53:26 <chessguy> now i need to replace  modify (place (firstFree $ get) 'O')
12:54:00 <ToRA|home> modify (\board -> (place (firstFree board) 'O' board)
12:54:01 <bringert> dcoutts: but if I force it, I will force the beginning of the list into memory too early
12:54:07 <ToRA|home> ?
12:54:10 <dcoutts> bringert, sigh, yeah.
12:54:28 <chessguy> well, i have makeMove now
12:54:38 <ToRA|home> ah, ok
12:54:54 <chessguy> modify (makeMove >>= gets) ?
12:55:04 <ToRA|home> nono
12:55:05 <chessguy> err
12:55:07 <dcoutts> bringert, so we have to traverse the list writing chunks out and discarding the used ones.
12:55:07 <ToRA|home> modify makeMove
12:55:15 <bringert> dcoutts: yikes
12:55:26 <dcoutts> bringert, I seem to recall there was a discussion on the haskell-cafe list and no one solved it
12:55:27 <chessguy> but makeMove requires a board
12:55:33 <dcoutts> bringert, that was for ordinary lists
12:55:34 <ToRA|home> yeah
12:55:39 <ToRA|home> modify gives it to it
12:55:45 <chessguy> ohhhh
12:55:47 <chessguy> ?src modify
12:55:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:55:49 <dcoutts> bringert, but perhaps it could be done with a different sig...
12:55:50 <chessguy> bah
12:55:57 <ToRA|home> @type modify
12:55:59 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
12:56:24 <ToRA|home> the (s -> s) first argument is makeMove
12:56:30 <dcoutts> bringert, like useSplit :: Int -> (ByteString -> a) -> (ByteString -> b) -> (a -> b -> c) -> c
12:56:45 <ToRA|home> anyone know where i can find the source for instance Monad (-> r) where ... ?
12:56:49 <dcoutts> bringert, so you'd say useSplit n (writeFile) (writeFile) (>>)
12:57:14 <bringert> dcoutts: so how do we write Data.Binary.Get.getBytes with that?
12:57:20 <profmakx> ber
12:57:21 <dcoutts> bringert, not sure :-)
12:57:36 <dcoutts> bringert, what's getBytes supposed to do ?
12:57:55 <bringert> dcoutts: get up to n bytes as a lazy bytestring
12:58:06 <allbery_b> ?source Control.Monad.Instances
12:58:07 <lambdabot> Control.Monad.Instances not available
12:58:18 <bringert> dcoutts: and return less than n if the input ends
12:58:27 <dcoutts> bringert, so it's :: Int -> Get LazyByteString right?
12:58:31 <sorear> argh!  I just got 400 lines behind by not staying at the end of an erc buffer :(
12:58:37 <bringert> dcoutts: yes
12:58:48 <bringert> (well it should be Int64, but that's a later problem)
12:58:54 <ToRA|home> allbery_b: cheers...that was the pointer i needed
12:59:15 <chessguy> ToRA|home, http://darcs.haskell.org/ghc-6.6/packages/base/Control/Monad/Instances.hs
12:59:18 <dcoutts> bringert, so how about... :: Int -> (LazyByteString -> a) -> Get a
12:59:18 <lambdabot> http://tinyurl.com/25qyth
12:59:18 <bringert> dcoutts: getBytes is in the binary package already
12:59:30 <dcoutts> bringert, yea,h doesn't mean I remember it :-)
12:59:36 <bringert> :-)
12:59:41 <dcoutts> you added that bit
12:59:46 <dcoutts> or kolmodin did, I don't recall
13:00:10 <bringert> dcoutts: hmm, ok. I would like to be able to keep a lazy list of tar entries in memory
13:00:28 <bringert> dcoutts: but I guess it's not strictly necessary
13:00:34 <dcoutts> bringert, that should be ok, no ?
13:00:34 <Bourbaki> is there any numerics package for haskell? one that specifically solves the wave equation?
13:00:46 <dcoutts> the continuation returns the entry header
13:00:46 <ToRA|home> chessguy_phone: cheers
13:00:49 <allbery_b> actually it's http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
13:01:18 <dcoutts> bringert, it can return 'Get a' not 'Get ()'
13:01:22 <allbery_b> or seems to be
13:01:24 <allbery_b> hrm
13:01:25 <allbery_b> @bot
13:01:26 <lambdabot> :)
13:01:26 <Bourbaki> are programs that work on grid solutions for numerics implementable in haskell in a fast memory saving way?
13:01:40 <basti_> I
13:01:44 <sorear> Yes!
13:01:53 <basti_> 've written a lanczos solver in ocaml
13:01:59 <sorear> add elegant and then I'll need to think :)
13:02:00 <bringert> dcoutts: I would like to get a lazy list [(EntryHeader,LazyByteString)]
13:02:10 <bringert> dcoutts: perhaps I misunderstood
13:03:09 <dcoutts> bringert, yeah, and you want it such that if you force them in order that you get constant memory usage.
13:03:34 <alex_vod> @help
13:03:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:03:42 <alex_vod> @list
13:03:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:03:57 <alex_vod> @version
13:03:58 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
13:03:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:04:19 <bringert> dcoutts: exactly
13:04:19 <sorear> alex_vod: just fyi: you can /msg the bot
13:06:22 <bringert> dcoutts: it's weird that that's so hard to achieve. I'm starting to doubt the niceness of lazy evaluation
13:07:10 <dcoutts> bringert, so we need to make sure that after you've 'gotten' the n bytes for the lazy bytestring that you return a list element and do not force the reading of the next header.
13:07:46 <bringert> dcoutts: yeah, I think that's what I do
13:08:13 <bringert> dcoutts: but as the example I pasted shows, that's not enough. right?
13:08:19 <Cale> Sorry, I just got here (and I'm not even 100% awake yet, so might not be worthwhile explaining), but what's hard to achieve?
13:08:28 <dcoutts> bringert, yeah, so we need to use something other than splitAt
13:09:06 <bringert> dcoutts: is there no way to change splitAt? (I can't think of one right now anyway)
13:09:25 <sorear> Cale: bringert, Bourbaki, impugning performance of lazy eval
13:09:30 <dcoutts> bringert, I fear not, lemme check it's the same problem as was mentioned on the mailing list
13:09:58 <Bourbaki> uh?
13:10:20 <bringert> Cale: we're trying to figure out how to avoid this memory leak: http://hpaste.org/147
13:10:39 <bringert> Cale: it's a cut down version of my real problem
13:11:21 <Cale> hmm
13:12:30 <_roconnor> 11
13:14:09 <dcoutts> bringert, "[Haskell-cafe] Computing lazy and strict list operations at the same time"
13:14:17 <dcoutts> @google "Computing lazy and strict list operations at the same time"
13:14:19 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg14487.html
13:14:19 <lambdabot> Title: Re: [Haskell-cafe] Computing lazy and strict list operations at the same
13:14:28 <Cale> That's interesting. I think we can consider that as a bit of a bug in splitAt, but I'm not 100% sure how that really works. I'll have a look at the code.
13:14:52 <dcoutts> Cale, see the above thread, it deals with the issue in some detail
13:15:21 <dcoutts> it starts by asking: is there a way to write initlast :: [a] -> ([a], a) that returns the
13:15:21 <dcoutts> result of init and the result of last, takes constant stack space, and
13:15:21 <dcoutts> traverses the list only once?
13:15:24 <sorear> @tell dons \ cstring -> packMallocCString cstring `seq` () :: CString -> () -- I think this has a side effect
13:15:25 <lambdabot> Consider it noted.
13:16:26 <dcoutts> sorear, what is the side effect?
13:17:10 <sorear> dcoutts: it frees the string
13:17:55 <sorear> dcoutts: it creates a foreign ptr with a finalizer, and forces the thunk creating a garbage ByteString ... when the GC runs the c string is freed (?)
13:18:06 <Orphi> anybody know how to make Haskell evaluate something at a specific point in time?
13:18:19 <roconnor> @type evaluate
13:18:21 <lambdabot> Not in scope: `evaluate'
13:18:27 <sorear> Orphi: bind it to Main.main
13:18:29 <roconnor> @hoogle evaluate
13:18:30 <lambdabot> Control.Exception.evaluate :: a -> IO a
13:18:30 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
13:18:45 <Korollary> Orphi: do you mean scheduling something to be run?
13:18:49 <roconnor> Control.Exception.evaluate will force evaluation of it's argument to head normal form
13:18:53 <roconnor> I think
13:19:03 <sorear> diff(HNF, WHNF) ?
13:19:05 <bringert> Orphi: you could use forkIO and threadDelay
13:19:07 <Orphi> I'm trying to do benchmarking... but due to lazy evaluation, I'm actually timing multiple things at once...
13:19:22 <sorear> Orphi: look at `@hoogle rnf`
13:19:22 <bringert> ah
13:19:25 <sorear> @hoogle rnf
13:19:25 <Orphi> I want to force different parts to be executed at different times so I can look at wall time
13:19:26 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
13:19:43 <roconnor> maybe I mean weak-head normal form
13:19:47 <sorear> evaluate only does WHNF, so it won't workwell on lists
13:19:56 <sorear> rnf + evaluate is full NF
13:20:55 <Orphi> I'm not even going to ASK what the difference between head normal and weak head normal is...
13:21:13 <Cale> Orphi: the difference is just what happens underneath lambdas
13:21:24 <Orphi> basically I'm doing that old trick of comparing sorting algorithms
13:21:27 <Cale> weak head normal form doesn't do anything to lambda terms
13:21:37 <Orphi> but I want to time the sorting algorithm - but not the part that generates the random list ;-)
13:21:46 <sorear> Orphi: you DO care about the difference between head normal and full normal, however.
13:22:06 <Orphi> oh yeah - for a list, head-normal just means the first cons is built..?
13:22:14 <sorear> evaluate (sort list) is O(n), since finding the first element is a simple minimum operation
13:22:16 <Cale> whereas head normal form will work underneath lambdas
13:22:28 <sorear> evaluate (rnf (sort list)) is O(n log n) as you'd expect
13:22:44 <Cale> (and usually isn't implemented)
13:22:54 <sorear> ty Cale...
13:23:06 <sorear> knowledge++
13:23:32 <Orphi> right, so... I need to fish around in Control.Parallel.Strategies to find the function I'm looking for?
13:23:33 <Cale> Control.Exception.evaluate
13:23:49 <sorear> Orphi: no, just ask, rnf is the one you want
13:23:51 <Cale> is what you need in order to sequence things to ensure they happen in sequence with IO
13:23:56 <sorear> the others are for parallelism
13:24:00 <Orphi> @hoohle rnf
13:24:01 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
13:24:10 <Orphi> hey - it works! lol
13:24:15 <Cale> rnf will be useful if you're dealing with compound data in that
13:24:15 <sorear> if you expand type synonyms:
13:24:34 <sorear> Control.Parallel.Strategies.rnf :: NFData a => a -> ()
13:24:43 <sorear> evaluate . Control.Parallel.Strategies.rnf :: NFData a => a -> IO ()
13:24:44 <dcoutts> sorear, hmm, perhaps it should be in IO
13:25:01 <sorear> dcoutts: rnf or packMallocCString ?
13:25:03 <Orphi> being in IO isn't too much of an issue here...
13:25:12 <Orphi> I'm looking at wall clock time anyway, so
13:25:17 <dcoutts> sorear, packMallocCstring
13:25:17 <jcreigh> if you want to make sure a list is evaluated, can't you just do, eg, print $ show someList (or print $ length $ show someList)?
13:25:35 <sorear> jcreigh: no, because that measures formatting time.
13:25:37 <Orphi> yeah, I guess that would work...
13:25:41 <Cale> jcreigh: the first works, the second might not
13:25:57 <sorear> jcreigh: he's trying to benchmark, so times must be strongly controlled
13:26:05 <Orphi> print $ length list will just build the list, not compute the list elements
13:26:07 <Orphi> (?)
13:26:09 <Cale> strictList xs = foldr seq xs xs
13:26:12 <sorear> Orphi: correct
13:26:16 <Cale> Orphi: yeah
13:26:21 <Cale> It'll build the spine
13:26:26 <sorear> Cale: is foldr seq safe?
13:26:28 <Orphi> well, if I print the list, it's sure to be "built"
13:26:32 <Cale> sorear: absolutely
13:26:39 <Orphi> then I can get on with timing the sorting bit...
13:27:13 <Orphi> ....hahaha.... and the NEXT problem is making the sort actually run! :S
13:27:24 <chessguy> is there a difference between 'data Board = String', and 'type Board String'?
13:27:30 <Cale> Orphi: if you have  length (map f [1..30]), this will never end up actually applying f.
13:27:35 <Orphi> sure, I could print that too - but what's to bet converting Int to String is slower than actually sorting?
13:27:50 <jcreigh> Cale: why wouldn't length $ show someList work?
13:28:00 <Cale> jcreigh: oh, in that order :)
13:28:10 <Cale> jcreigh: that would actually probably work
13:28:27 <sorear> chessguy: one is a type synonym, the other is a lifted data type
13:28:34 <Cale> > length (map undefined [1..30])
13:28:36 <lambdabot>  30
13:28:41 <chessguy> lifted?
13:28:51 <sorear> Cale: oh.  I was thinking wrt shortcut deforestation, etc.
13:29:11 <Cale> sorear: obviously it can't apply that with seq :)
13:29:11 <sorear> chessguy: data Board =Board String --> Board _|_ /= _|_
13:29:50 <Orphi> ok, I have GOT to look up the Unicode for that symbol... lol ;)
13:29:51 <Cale> type Board = String  doesn't actually create a new type. It just makes "Board" get translated automatically into "String" wherever it occurs in types.
13:30:31 <chessguy> ah
13:30:33 <Cale> 
13:30:39 <jcreigh> chessguy: as I understand it, "type" is just so you can write pretty type signatures.
13:30:43 <sorear> chessguy: it's kinda like #define Board String, just with more confusing error messages.
13:30:58 <Cale> chessguy: newtype Board = Board String is different from data Board = Board String though
13:31:04 <bringert> dcoutts: I guess we could write splitAt like Andrew Pimlott's imperative initlast
13:31:16 <sorear> @users
13:31:17 <lambdabot> Maximum users seen in #haskell: 322, currently: 314 (97.5%), active: 42 (13.4%)
13:31:20 <bringert> http://www.mail-archive.com/haskell-cafe@haskell.org/msg16757.html
13:31:22 <lambdabot> Title: Re: [Haskell-cafe] Computing lazy and strict list operations at the same, http://tinyurl.com/ynra5e
13:31:22 <Orphi> aha... 22A5. lol
13:31:29 <Cale> even though newtype creates a new type, it doesn't create a new data representation -- the constructor boils away during compilation
13:31:37 <sorear> Orphi: is that bottom?
13:31:38 <Cale> Whereas with data, it's still there at runtime.
13:31:39 <chessguy> hmm
13:31:47 <Orphi> hopefully...
13:32:09 <Orphi> hmm... what the heck is 22A5 in decimal? lol
13:32:15 <Cale> You can see this effect because with data,  Board undefined is a different value from undefined, whereas with newtype  Board undefined = undefined.
13:32:21 <sorear> Orphi: just ask!
13:32:24 <sorear> > 0x22A5
13:32:26 <lambdabot>  8869
13:32:29 <Cale> No evaluation is done by matching against a newtype constructor.
13:32:34 <Orphi> ah... didn't know about that syntax! lol
13:32:43 <Orphi> > 0xbad
13:32:48 <lambdabot>  2989
13:33:02 <sorear> > flip showOct "" 0x22A5
13:33:04 <lambdabot>  "21245"
13:33:09 <Cale> case x of Board y -> 1
13:33:13 <chessguy> ugh, neither of them are working for me. i'll have to mess with it later
13:33:17 <Cale> case undefined of Board y -> 1
13:33:36 <Cale> This will result in 1 with the newtype, and undefined with data.
13:33:47 <Orphi> > 0x2a
13:33:49 <lambdabot>  42
13:33:52 <Orphi> :D
13:33:55 <sorear> beschmi++ background compilation on save rocks
13:34:24 <dcoutts> bringert, I think I need to be more awake to figure it out :-)
13:34:31 <beschmi> hey sorear, hi haskell
13:35:51 <sorear> and it Just Works with yi!
13:36:11 <xic> how does hPutStrLn work when the string has unicode characters?
13:36:36 <sorear> xic: truncates
13:36:39 <beschmi> sorear: you're using shim to hack on yi?
13:36:55 <xic> sorear: cool
13:36:58 <sorear> beschmi: yes.  (do I detect suprise?)
13:37:36 <beschmi> sorear: no, just wondering because yi is pretty big
13:37:56 <beschmi> sorear: i have some problems with shim eating all my ram atm ;(
13:37:56 <sorear> beschmi: in terms of file count it's half the size of lambdabot
13:38:16 <sorear> I should check top
13:38:46 <sorear> beschmi: 28580 stefan    18   0 99.6m  96m 8696 S  0.0 25.5   0:28.54 shim
13:39:01 <sorear> 100M/384M ... bad, but not intolerable
13:39:18 <sorear> is it worse for you, or do you just have less total core?
13:39:53 <beschmi> sorear: it happens for me when load requests pile up (because i use C-x C-s very often)
13:40:22 <Orphi> ah forget it, I can't figure out how to make Unicode work on Windoze. :P
13:40:56 <Orphi> so can somebody explain precisely what seq does?
13:41:17 <beschmi> sorear: i either have to use threads and kill the current compilation when you request a new one or handle that in emacs
13:41:50 <Korollary> Orphi: http://en.wikibooks.org/wiki/Haskell/Strictness#seq
13:42:00 <Orphi> *reads*
13:42:27 <Korollary> strangely, that's a stub
13:42:38 <Orphi> ...erm, yes. :S
13:43:43 <TuringTest> Orphi: how well do you understand the lazy evaluation without "seq" ?
13:43:51 <Korollary> Orphi: http://users.aber.ac.uk/afc/stricthaskell.html#seq
13:43:53 <lambdabot> Title: Making Haskell programs faster and smaller
13:43:58 <sorear> beschmi: I have been unconciously using a lower tech solution ... not save again until I get the errors from the first :)
13:44:02 <Orphi> erm... fairly well (I think!)
13:44:15 <Orphi> I wrote a little interpreter that runs... well, not Haskell, but something like it
13:44:25 <Orphi> (in Tcl of all things!)
13:44:32 <Cale> When (seq x y) is evaluated, x is evaluated into WHNF, and the expression reduces to y
13:44:57 <Orphi> right, so... it evaluates the top of x, and ONLY THEN returns whatever y is?
13:45:02 <Cale> right
13:45:14 <Cale> You can write it for specific types
13:45:14 <Orphi> ...and presumably that's only if seq itself is evaluated of course...
13:45:18 <Cale> for instance...
13:45:19 <TuringTest> Orphi: Then evaluating x to WHNF can be made to have a side effect.  If x = seq a b then it evaluates both 'a' and 'b' to WHNF and returns 'b'.
13:45:33 <Cale> seqList x y = case x of [] -> y; _ -> y
13:45:42 <Cale> assuming the compiler is not too smart ;)
13:45:57 <beschmi> sorear: yeah, unfortunately C-x C-s/:w is hardwired for me after every two lines i type. don't even remember if i got that habit after losing some data ;)
13:46:01 <TuringTest> Orphi: If seq x y is evaulated and x is bottom then the whole thing is bottom
13:46:16 <sorear> class Eval a where rwhnf :: a -> ()
13:46:33 <sorear> instance Eval [a] where rwhnf [] = () ; rwhnf _ = ()
13:46:34 <Cale> sorear: right, we used to have something like that
13:46:46 <Orphi> OK... so using seq you can force something to be [partially] computed
13:46:50 <sorear> instance Eval (a,b) where rwhnf (_,_) = ()
13:46:55 <Orphi> I presume it's best if that something is a variable then?
13:47:07 <Orphi> so you can actually USE the stuff you just computed somewhere later...?
13:47:08 <Cale> Orphi: when something else is
13:47:13 <Cale> seq x x is the same as x
13:47:17 <TuringTest> More complicated than seq is http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
13:47:19 <lambdabot> http://tinyurl.com/yj5j75
13:47:31 <Cale> Which is an important point that's often missed by beginners :)
13:47:44 <Cale> Orphi: yeah
13:48:15 <Orphi> so, like, let x = blah in x `seq` f x or similar...
13:48:26 <Cale> foldl' f z [] = []; foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
13:48:45 <sorear> @src foldl'
13:48:46 <lambdabot> foldl' f a []     = a
13:48:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:48:55 <sorear> ah, no need to copy it :)
13:49:00 <sorear> @src ($!)
13:49:00 <lambdabot> Source not found. My mind is going. I can feel it.
13:49:02 <Orphi> hmm... @src... knowledge++
13:49:04 <Orphi> lol
13:49:05 <Cale> er, yeah, I got the first case wrong :)
13:49:18 <Cale> foldl' f z [] = z  of course
13:49:46 <Orphi> actually, running fold in my interpreter, I noticed that, e.g., fold (+) 0 [1,2,3,4] ends up being 0 + 1 + 2 + 3 + 4...
13:49:55 <sorear> Orphi: exactly.
13:49:55 <Orphi> so foldl' makes it reduce at each step?
13:49:56 <Cale> the results of @src are often less helpful than one would like
13:50:08 <Cale> right
13:50:14 <sorear> Orphi: foldl is very bad in lazy languages, most of the time
13:50:21 <Cale> foldl (+) 0 [1,2,3]
13:50:29 <Cale> = foldl (+) (0+1) [2,3]
13:50:36 <Cale> = foldl (+) ((0+1)+2) [3]
13:50:38 <sorear> > foldl' (+) 0 [1..100000]
13:50:40 <lambdabot>  5000050000
13:50:42 <Cale> = foldl (+) (((0+1)+2)+3) []
13:50:43 <sorear> > foldl (+) 0 [1..100000]
13:50:45 <lambdabot>  5000050000
13:50:49 <Cale> = ((0+1)+2)+3
13:50:49 <sorear> > foldl (+) 0 [1..1000000]
13:50:52 <lambdabot>  Exception: stack overflow
13:50:55 <Cale> = (1+2)+3
13:50:56 <sorear> > foldl' (+) 0 [1..1000000]
13:50:58 <Cale> = 3+3
13:50:58 <lambdabot>  500000500000
13:50:59 <Cale> = 6
13:51:02 <Orphi> I really wish to God there was some tool that would allow you to step through a Haskell program one redex at a time... :(
13:51:11 <sorear> Orphi: you mean like hat? :)
13:51:16 <Cale> There is, it's called your brain :)
13:51:18 <Cale> hehe
13:51:21 <ookk> class Say a where
13:51:22 <ookk> 	say :: a -> String
13:51:22 <ookk> instance Say (Int,Int) where
13:51:22 <ookk> 	say _ = "asd"
13:51:24 <ookk> doesnt work
13:51:28 <Orphi> Cale: you haven't seen the code I write :P
13:51:35 <ookk> Illegal instance declaration for `Say (Int, Int)'
13:51:36 <ookk>         (The instance type must be of form (T a b c)
13:51:36 <ookk>          where T is not a synonym, and a,b,c are distinct type variables)
13:51:40 <ookk> what is the problem?
13:51:51 <sorear> ookk: the error message says what's wrong
13:51:53 <Cale> ookk: -fglasgow-exts
13:52:09 <Orphi> so... what the heck is hat?
13:52:27 <ookk> Cale, is that not standard haskell?
13:52:28 <allbery_b> haskell.org/hat
13:52:31 <Cale> ookk: that was one of the extremely conservative decisions made about typeclasses in Haskell 98
13:52:40 <sorear> ookk: explanation: (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
13:52:42 <Cale> ookk: they only match the top level type constructor
13:52:59 <Cale> ookk: in order to decide which class is to be used
13:53:07 <sorear> ookk: your instance isn't of that form
13:53:25 <ookk> class Say a where say :: a -> String
13:53:27 <sorear> ookk: rewrite it in that form
13:53:28 <ookk> a = (Int,Int)
13:53:30 <Cale> that's obviously ridiculous, so it's been fixed since, but that's what the standard says. Typeclasses were relatively new at the time, and so they were cautious.
13:53:33 <ookk> what would be the problem?
13:53:34 <dmhouse> ookk: basically type classes were really new theory when Haskell 98 was standardised. Because of that, a lot of potentially harmless things weren't allowed, on the grounds that the implications of allowing them hadn't been studied.
13:53:49 <sorear> ookk: (Int, Int) isn't of the form T a b
13:53:56 <sorear> ookk: (Int, Int) is (,) Int Int
13:53:56 * allbery_b wonders if rephrasing it as (,) Int Int would work
13:53:58 <allbery_b> heh
13:54:05 <sorear> ookk: Int isn't a type variable
13:54:08 <Cale> allbery_b: no, because Int and Int aren't tyvars
13:54:17 <allbery_b> hm, right
13:54:23 <sorear> ookk: instance Say (a,a) would work
13:54:27 <Cale> right
13:54:30 <sorear> ookk: instance Say ((,) a a) would work
13:54:34 <sorear> nm
13:54:38 <sorear> ookk: instance Say ((,) a b) would work
13:54:43 <Cale> You can even write it as (a,b)
13:54:46 <sorear> ookk: instance Say (a,b) would work
13:54:50 <Cale> hehe
13:54:58 <ookk> sorear, so i would have to do something like Integral a => Say (a,a) ?
13:55:06 <sorear> yes
13:55:17 <sorear> (Integral a, Integral b) => Say (a,b) actually
13:55:29 <Cale> They have to be distinct type variables.
13:55:42 <Cale> Just use -fglasgow-exts, I think :)
13:55:44 <sorear> the usual trick is:
13:55:51 <ookk> doesnt work with -fglasgow-exts
13:55:55 <Cale> no?
13:55:57 <sorear> class IsInt a where from :: a -> Int ; to :: Int -> a
13:56:01 <Saizan> it's strange that you can state a stronger claim and a weaker is forbidden
13:56:08 <ookk> i added a {- OPTIONS -fglasgow-exts -}
13:56:16 <ookk> but it still produces the same error
13:56:17 <sorear> ookk: {-# #-}
13:56:26 <Cale> {-# OPTIONS_GHC -fglasgow-exts #-}
13:56:46 <ookk> ok
13:56:55 <sorear> ookk:  {- anything -} is a simple comment
13:57:16 <Orphi> ok, next question... what's the difference between foldr and foldl, and which one do you usually want?
13:57:34 <Cale> Orphi: you usually want foldr
13:57:38 <dmhouse> Saizan: I guess the objection is something along the following lines: what would you do if you had instance Foo a and instance Foo Int, and were trying to instantiate Foo a => a with Int?
13:57:38 <ookk> ok now it works
13:57:39 <ookk> thx
13:57:41 <Cale> foldr f z [] = z
13:57:55 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
13:58:05 <Orphi> ok
13:58:14 <Cale> You can think of foldr f z as replacing each (:) with f and [] with z
13:58:23 <sorear> Orphi: foldl doesn't work on infinite lists, hence is usually considered Unhaskell
13:58:26 <Orphi> ...or foldr' if the answer is a "flat" thing like an Int?
13:58:42 <sorear> Orphi: if the answer is "flat", foldl'
13:58:48 <Cale> Note that if f doesn't use its right parameter for whatever reason, the folding will stop with foldr
13:58:51 <sorear> @src sum
13:58:51 <lambdabot> sum = foldl (+) 0
13:58:55 <Saizan> dmhouse: iirc you can have overlapping instances even in 98
13:59:06 <sorear> wow, that defn is broken
13:59:07 <Cale> Whereas foldl is tail recursive and will always walk all the way to the end of the list before returning anything
13:59:09 <dmhouse> Saizan: how?
13:59:19 <Cale> sorear: It's not that bad
13:59:47 <Cale> sorear: though I'd hope for some specialise magic :)
13:59:59 <Orphi> oh god... recursive vs tail recursive... :S
14:00:07 <sorear> Cale: huh? that sum isn't even type correct!
14:00:22 <Cale> sorear: how is that?
14:00:25 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:00:27 <lambdabot> Title: Fold Diagrams - CaleWiki
14:00:29 <LoganCapaldo> @type foldl (+) 0
14:00:31 <lambdabot> forall b. (Num b) => [b] -> b
14:00:34 <sorear> @tell dons @src sum gives a def with an insufficiently generic type
14:00:35 <lambdabot> Consider it noted.
14:00:37 <sorear> LoganCapaldo:
14:00:42 <Cale> sorear: what?
14:00:42 <Saizan> dmhouse: instance Class1 a => Foo a, instance Class2 a => Foo a, and then you have instance Class1 A, instance Class2 A
14:00:44 <LoganCapaldo> Ahh
14:00:49 <LoganCapaldo> that cleared it up :)
14:00:59 <Cale> I don't get how it could be any more generic
14:01:00 <sorear> > let sum = foldl (+) 0 in (sum [0 :: Int] , sum [0.0])
14:01:01 <lambdabot>   add an instance declaration for (Fractional Int)
14:01:01 <lambdabot>     In the list element: 0.0
14:01:08 <sorear> > let sum = foldl (+) 0 in (sum [0 :: Int] , sum [0.0 :: Float])
14:01:09 <lambdabot>  Couldn't match `Int' against `Float'
14:01:13 <dmhouse> Saizan: hrm, true.
14:01:21 <sorear> LoganCapaldo: ^^^
14:01:26 <sorear> LoganCapaldo: hint: MR
14:01:34 <LoganCapaldo> gah
14:01:41 <Cale> screw the MR
14:01:46 <Orphi> @src foldr
14:01:46 <lambdabot> foldr k z xs = go xs
14:01:46 <lambdabot>     where go []     = z
14:01:46 <lambdabot>           go (y:ys) = y `k` go ys
14:01:54 <Orphi> eeps :|
14:02:06 <Cale> Things like that one are why I don't like @src
14:02:17 <Orphi> @src (+)
14:02:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:02:25 <Orphi> lmao!
14:02:43 <Cale> @src (+)
14:02:43 <Orphi> I just got insulted by a machine :|
14:02:43 <lambdabot> Source not found. You type like i drive.
14:02:44 <LoganCapaldo> Is it ok to say "screw the MR"? Or is the MR part of the standard?
14:03:03 <Cale> LoganCapaldo: It's part of the standard, but we all hate it anyway.
14:03:09 <LoganCapaldo> Ah
14:03:25 <LoganCapaldo> Can I join that club?
14:03:26 <Cale> and you can turn it off
14:03:32 <Cale> -fno-monomorphism-restriction
14:03:56 <Orphi> @hoogle unfold
14:03:56 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
14:03:57 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:03:57 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
14:04:11 <Orphi> ...ouch...
14:04:39 <Orphi> do you think we should add health warnings to Haskell?
14:04:43 <Cale> It's just there because of some people who don't like the idea that pattern bindings might actually turn into function bindings due to typeclass polymorphism and need to be evaluated repeatedly.
14:06:03 <Cale> unfoldr starts with that second parameter of type a, and applies the function to it repeatedly to get values of type b, and more values of type a to be used until it gets a Nothing, at which point it stops.
14:06:08 <Cale> that is,
14:06:44 <Cale> unfoldr f x = case f x of Just (y,x') -> y : unfoldr f x'; Nothing -> []
14:07:23 <Orphi> ...so... I might use this, say, to compute the decimal expansion of 1/x?
14:07:23 <Cale> I usually find that far less convenient than the following variant, which I wish was in the libraries.
14:07:29 <Cale> sure, yeah
14:07:40 <Orphi> remainder goes one way, result goes out
14:07:41 <Cale> any sort of iterative process which builds up a list
14:07:54 <Orphi> ...unless "iterate" will do it ;)
14:08:30 <Cale> unfoldr' p f g = map f . takeWhile p . iterate g
14:08:56 <Cale> That's far more convenient, most of the time.
14:09:02 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
14:09:04 <lambdabot> Defined.
14:09:29 <Cale> > unfoldr' (/= 0) (`mod` 10) (`div` 10) 57182904
14:09:30 <lambdabot>  [4,0,9,2,8,1,7,5]
14:09:48 <Orphi> ah... a very slow way to reverse a list of digits :D
14:10:06 <Orphi> I don't even want to contemplate how unfoldl is different...
14:10:11 <Cale> It's not that, it's actually computing the decimal expansion of the number.
14:10:20 <Cale> There is no unfoldl in the library
14:10:26 <monochrom> what is a faster way?
14:10:46 <Orphi> oh thank god! lol
14:10:49 <dons> hehe http://programming.reddit.com/info/119go/comments
14:10:50 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:10:51 <lambdabot> Title: #haskell activity for the years ending 2001-2007 (reddit.com)
14:11:43 <Cale> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) 57182904
14:11:44 <lambdabot>  [4,0,9,2,8,1,7,5]
14:12:01 <Orphi> I notice with some curiosity that there is no splitWith function in the library either...
14:12:11 <Cale> > unfoldr (\x -> guard (x /= 0) >> return (x `mod` 10, x `div` 10)) 57182904
14:12:13 <dons> > take 10 . unfoldr (Just . random) (mkStdGen 42)
14:12:13 <lambdabot>  [4,0,9,2,8,1,7,5]
14:12:14 <lambdabot>      Expecting a function type, but found `[a]'
14:12:14 <lambdabot>       Expected type: a1 -> [a...
14:12:25 <dons> > take 10 $ unfoldr (Just . random) (mkStdGen 42)
14:12:26 <lambdabot>  Add a type signature
14:12:29 <sm> good day all
14:12:31 <dons> > take 10 $ unfoldr (Just . random) (mkStdGen 42) :: [Integer]
14:12:32 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:12:35 <dons> hi sm
14:12:39 <glguy> dons: The whole of PasteState.hs was "wrong" :)
14:12:40 <lambdabot> glguy: You have 5 new messages. '/msg lambdabot @messages' to read them.
14:12:53 <dons> glguy: ?
14:13:00 <sm> what are my options for writing large multiline string literals ?
14:13:09 <dons> Data.ByteString
14:13:22 <dons> or Data.ByteString.Lazy
14:13:25 <sm> I mean, syntax-wise.. for most readable code
14:13:33 <dcoutts> g'morning dons
14:13:41 <Orphi> ok, it's too late at night for my to be thinking about high order functions in a lazy functional programming language with parametric polymorphism... heh :|
14:13:48 <dcoutts> dons, btw, we got a 2x speedup on the MemBench
14:13:51 <glguy> dons: I should have been making use of $(inferRecordUpdaters ''PasteState) and withPastes
14:13:53 <Cale> Orphi: did you look at my diagrams?
14:13:54 <glguy> allowing functions like:
14:13:59 <dcoutts> dons, for the Haskell mem reading/writing loops
14:14:00 <Orphi> I'm going to go sleep...
14:14:01 <glguy> getEntries :: Int -> Ev PasteState ev [Entry]
14:14:05 <glguy> in a very clean way
14:14:06 <Saizan> sm: a list of strings i suspect
14:14:15 <glguy> instead of manually accessing  the app state in HPaste.hs
14:14:37 <dcoutts> dons, and I've tried a bit more at rewriting the Put monad to allow the rules to fire
14:14:38 * sm tries a multiline string literal, quoted
14:15:13 <dcoutts> dons, lots of comment on the mailing lists I see. We really really need to emphasise that the Binary class isn't for externally defined formats. It is it's own format.
14:15:33 <dmhouse> Yay! My application is now a lot prettier.
14:15:42 <dmhouse> It's been a long time since I CSS'd.
14:16:52 <Cale> dcoutts: It might be nice to make it work well for externally-defined formats though.
14:17:01 <Cale> (at least as far as that's convenient)
14:17:27 <dcoutts> Cale, I fear that's too hard. What we need is a parser/printer lib designed for that. A class isn't right for that.
14:17:31 <monochrom> sm: http://haskell.org/onlinereport/lexemes.html#sect2.6
14:17:32 <dons> sm, or a string gap string
14:17:32 <Cale> One thing which might be an idea is to make some newtypes that add in some information about endianness.
14:17:32 <lambdabot> Title: Haskell 98 Lexical Structure
14:17:41 <Cale> and/or alignment
14:17:47 <sorear> morning dons
14:17:54 <dcoutts> Cale, those should be combinators or something.
14:18:21 <dons> yeah
14:18:30 <dons> some simple external formts should work
14:18:32 <Cale> Well, you want to control which instance is used, right?
14:18:35 <dons> like C structs
14:18:47 <Cale> instance Binary (LE Word32) where ...
14:18:50 <dcoutts> Cale, no I suggest not using a class at all for external formats
14:19:07 <dcoutts> just use some binary parser combinators
14:19:11 <sm> thanks
14:19:12 <dons> (like we rarely use a class for parsers)
14:19:13 * sm struggles
14:19:33 <dons> > "abcdef\ gap \defghi"
14:19:34 <lambdabot>  Illegal character in string gap
14:19:35 <bringert> hi dons
14:19:40 <dcoutts> Cale, how many external format can occur in either endianness ?
14:20:03 <dons> hey bringert. saw your bug report. pondering.
14:20:05 <Cale> Not many, I suppose :)
14:20:19 <sorear> dons: there *is* a big use for parser classes ... benchmarking
14:20:38 <bringert> dons: I'm trying to write a splitAt mimicing initLastST from here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg16757.html
14:20:39 <lambdabot> Title: Re: [Haskell-cafe] Computing lazy and strict list operations at the same, http://tinyurl.com/ynra5e
14:20:51 <sorear> benchmark :: Parser a => a -> () ; time (benchmark (undefined :: ReadP ())) ; ...
14:21:07 <basti_> tiff or some other ancient graphics format specifies endianness iirc
14:21:59 <sm> if anyone can point me to a correct example of multiline string literals, I'd be grateful
14:22:08 <monochrom> Word32 is a toy example; it proves no point.  What would be a standard binary format for [Word32] (assume finite length)?  for (Ix ix) => Array ix Word32?  ...
14:22:30 <sm> or better, where I should be finding this information on the interweb
14:22:37 <Cale> You essentially already have a combinator library for parsing binary formats there though. That's what the get monad is.
14:22:50 <dons> right. that's the idea
14:22:54 <dons> you layer your own stuff on top
14:22:56 <Cale> It could just use some more combinators :)
14:23:01 <dons> and we provide some more glue for plugging things
14:23:38 <sm> I must be misreading the report.. ahhh I see.. need a \ on the following line as well
14:24:02 <dons> ?users
14:24:02 <lambdabot> Maximum users seen in #haskell: 322, currently: 313 (97.2%), active: 43 (13.7%)
14:24:05 <Cale> sm: yeah, it just ignores the whitespace between the \'s.
14:24:25 <monochrom> > "\     \"
14:24:27 <lambdabot>  ""
14:24:37 <Cale> I wonder what joelr thinks of the new Binary
14:25:21 <Cale> I seem to recall that he actually needed varying endianness for the bizarre format he was working with.
14:25:56 <dmhouse> Is there a normal or standard endianness?
14:26:27 <monochrom> There are two.
14:26:34 <dmhouse> :) Well, yes, clearly.
14:26:59 <roconnor> I only use palendromes
14:26:59 <bringert> @google middle endian
14:27:02 <lambdabot> http://en.wikipedia.org/wiki/Endianness
14:27:04 <der_eq> three!
14:27:06 <mahogny> standard, network byte order is as standard as it gets AFAIK
14:27:13 <mahogny> *shrug*
14:27:16 <sorear> dons: I'm trying to get into yi hacking now...  first order of business: no more triple-extra-yucky Ptr CChar
14:28:26 <hpaste>  sm pasted "multiline string literal example" at http://hpaste.org/152
14:28:49 <dmhouse> Well, technically, there are n! endiannesses, where n is the number of bytes you're storing.
14:29:08 <sorear> bringert: there's a very simple solution
14:29:14 <mahogny> while you are at it, why not consider those cases when a byte is not 8 bit?
14:29:17 <Cale> (8n)!
14:29:27 <bringert> sorear: what?
14:29:36 <sorear> oh wait sorry :(
14:29:49 <sorear> mistook lazy for strict bytestringsd
14:30:39 <dons> sorear: don't break the hunit and quickcheck properties
14:30:45 <dons> the Ptr CChar was very very hard to get right
14:31:59 <sorear> get right?
14:32:13 <sm> is Text.ParserCombinators.Parsec the best included-by-default parser to use for simple parsing tasks now ?
14:32:15 <sorear> I'm aiming for fully pure bytestrings...
14:32:27 <sorear> sm: standard, yes.  best, probably.
14:32:55 <dons> sorear: I'd do a buffer as a list of ines
14:33:01 <dons> lines.
14:33:11 <dons> immutable bytestrings. should be a more flexible representation
14:33:20 <dons> but this is a hard job
14:33:27 <dons> i'm not sure it needs doing actually ..
14:33:38 <dons> but you know, if you don't want to see daylight for a week .. :)
14:34:12 <sm> thx
14:37:19 <hpaste>  bringert annotated "bytestring memory leak" with "ST version of splitAt that for some reason doesn't help" at http://hpaste.org/147#1
14:37:19 <LoganCapaldo> @instances Random
14:37:29 <lambdabot> Couldn't find class `Random'. Try @instances-importing
14:37:35 <beschmi> lol: http://programming.reddit.com/info/119go/comments/c11b70
14:37:36 <lambdabot> Title: #haskell activity for the years ending 2001-2007 (reddit.com)
14:37:59 <LoganCapaldo> @instances-importing Random
14:38:00 <lambdabot> Couldn't find class `Random'. Try @instances-importing
14:38:12 <LoganCapaldo> alllllrighty :)
14:38:12 <dmhouse> ?instances-importing Data.Random Random
14:38:13 <lambdabot> Couldn't find class `Random'. Try @instances-importing
14:38:20 <dmhouse> ?help instances-importing
14:38:20 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
14:38:24 <sorear> @instances-importing System.Random Random
14:38:26 <lambdabot> Bool, Char, Double, Float, Int, Integer
14:38:31 <LoganCapaldo> Oh goody :)
14:38:33 <dmhouse> Aha.
14:38:44 <dons> bringert: so one thought that occurs to me is that when you spit, you hang on to the original string of course
14:38:47 <sorear> @src Integer random
14:38:48 <lambdabot> Source not found. stty: unknown mode: doofus
14:38:53 <dons> but i need coffee before I can consider the problem :)
14:38:53 <bringert> dons: right
14:38:59 <LoganCapaldo> > eval enumFor False
14:39:00 <lambdabot>   Not in scope: `enumFor'
14:39:11 <sorear> LoganCapaldo: [False, True]
14:39:11 <bringert> dons: see this thread: http://www.mail-archive.com/haskell-cafe@haskell.org/msg16757.html
14:39:18 <lambdabot> Title: Re: [Haskell-cafe] Computing lazy and strict list operations at the same, http://tinyurl.com/ynra5e
14:39:25 <glguy> dons: your type synonyms help a lot!
14:39:27 <LoganCapaldo> sorear, thanks
14:39:33 <bringert> dons: it seems to be a non-trivial problem
14:40:18 <dons> yeah, I suspect so
14:41:49 <sjanssen> that initlastST is very clever
14:41:56 <bringert> yeah
14:42:31 <bringert> I can't get it to work for lazy bytestring splitAt though
14:42:47 <bringert> can anyone see what's wrong with http://hpaste.org/147#1 ?
14:46:49 <sm> a dumb question but.. how do I get the data value out of an Either ?
14:46:57 <glguy> :t either
14:46:58 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
14:47:01 <bringert> or case
14:47:17 <sorear> sm: you don't - since an Either might not have a Right!
14:47:23 <sm> aieee
14:47:42 <sorear> sm: try getting the Int out of Left "foo!" :: Either String Int
14:48:16 <LoganCapaldo> @hoogle newStdGen
14:48:17 <lambdabot> Random.newStdGen :: IO StdGen
14:48:21 <sm> careful.. I could waste an hour on that
14:48:28 <sorear> sm: remember: Just Say No to partial funtions
14:48:39 <nornagon> like head.
14:48:42 <nornagon> and tail.
14:48:47 <nornagon> and last.
14:48:47 <sorear> and fromRight
14:48:51 <nornagon> :P
14:48:56 <LoganCapaldo> sorear, does it count as a partial function if I say = error "Bad!"
14:49:20 <sorear> LoganCapaldo: yes.  error is the most partial function of them all
14:49:24 <LoganCapaldo> Or should I change it from Constructor [a] to Constructor a [a]
14:49:50 <bringert> what's the polar opposite of total?
14:49:57 <sorear> undefined?
14:50:01 <sm> what are partial functions, in a nutshell ?
14:50:09 <sm> so I can be sure to avoid them ?
14:50:13 <bringert> i.e. another word of "most partial of them all"
14:50:20 <sorear> sm: funtions whose domain is not the entire set
14:50:20 <allbery_b> only defined for a subset of the type?
14:50:31 <sm> I see
14:50:37 <sorear> sm: or, operationally speaking, functions that might fail
14:50:42 <bringert> sorear: "error is the most undefined function of them all" doesn't sound quite right
14:50:45 <sm> that helps, thanks
14:51:02 <LoganCapaldo> So yes, change my data type?
14:51:36 <sorear> LoganCapaldo: yes.  do that.  good luck porting the Data.List functions!
14:51:57 <LoganCapaldo> Are you being sarcastic?
14:52:05 <sorear> maybe
14:52:11 <sorear> == not sure
14:52:27 <jcreigh> sorear: so, which is it, Just True or Nothing? :)
14:53:23 <sorear> yes!  ByteString Yi.FastBuffer is type correct now!
14:54:30 <LoganCapaldo> Its supposed to be 1 or more items
14:54:46 <sorear> LoganCapaldo: I figured.
14:54:53 <LoganCapaldo> Theres no reason to use an empty list...
14:54:55 <LoganCapaldo> So...
14:55:14 <sorear> LoganCapaldo: the question is, does the non-empty constraint trump code reuse concerns?
14:55:15 <sm> woah.. "; print err" causes Parsec to output the error location, how does that work ?
14:55:30 <sorear> sm: very well
14:55:39 <LoganCapaldo> sorear, Doubtful, as it was just a silly idea I had in the shower
14:55:55 <sm> I thought ; was a function, but :t says no ?
14:56:08 <sorear> sm: no, ; is syntax
14:56:12 <sorear> it's used in do
14:56:18 <sorear> actually all layout forms
14:56:20 <LoganCapaldo> sm: ; is anti sugar for \n :)
14:56:23 <sm> oh right
14:56:40 <sorear> @undo do { foo ; print err
14:56:41 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
14:56:45 <sorear> @undo do { foo ; print err }
14:56:46 <lambdabot> foo >> print err
14:56:56 <sm> aha.. easy peasy, thx
14:57:00 <qwr> > [1,2] >> [3]
14:57:09 <lambdabot>  [3,3]
14:57:09 * sm was reading ; print err as a comment
14:57:36 <sorear> sm: *lisp or assembly? :)
14:57:44 <sm> *lisp :)
14:57:57 <LoganCapaldo> heheh, replicate n v = [1..n] >> [v] ;)
14:58:05 <sm> and the ledger file format, which I'm trying to parse
15:00:22 <LoganCapaldo> > let rep n v = [1..n] >> [v] in rep 2 3
15:00:23 <lambdabot>  [3,3]
15:00:45 <LoganCapaldo> > let rep n v = [1..n] >> [v] in rep 0 3
15:00:47 <lambdabot>  []
15:00:47 <dmhouse> ?src [] (>>)
15:00:47 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
15:06:50 <yip_> anyone familiar with UTF8.lhs?
15:07:00 <sorear> a little
15:07:47 <yip_> when decode finds an error, the resulting String is still valid, right? the erroneus bytes are just ignored?
15:08:02 <sorear> that would be stupid
15:08:19 <sorear> utf8 decoders are *forbidden by the spec* from ignoring error
15:08:30 <yip_> well it also returns a list of errors
15:11:33 <jcreigh> sorear: the UTF-8 spec really says that?
15:14:05 <sorear> unk, but predigested versions do
15:14:12 <sorear> consider /../
15:14:27 <sorear> an error ignored would allow non-canonical forms
15:14:37 <sorear> which is considered a security hole
15:16:24 * monochrom marvels at the ghc build process
15:17:56 <sjanssen> from RFC 3629: Implementations of the decoding algorithm above MUST protect against decoding invalid sequences.
15:18:03 <nattfodd> hi
15:18:08 <sorear> hi!
15:18:12 <nattfodd> I was wondering where I could get a feature list of ghci
15:18:16 <nattfodd> (not ghc)
15:18:30 * sorear checks users guid
15:18:33 <dons> nattfodd: the ghci section of the ghc user's guide
15:18:35 <sjanssen> the RFC does not give a definition of "protect"
15:18:54 <nattfodd> dons: like http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html ?
15:18:55 <lambdabot> Title: Chapter 3. Using GHCi
15:18:57 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/ghci.html
15:18:58 <lambdabot> Title: Chapter 3. Using GHCi
15:19:00 <sorear> usebuf?
15:19:21 <nattfodd> is there anything more complete?
15:19:22 <sorear> *ful
15:19:28 <sorear> nattfodd: yes
15:19:41 <nattfodd> (apart from the source code, that is)
15:20:04 <monochrom> The user guide is complete.
15:20:39 <dons> nattfodd: what are you looking for in particular?
15:20:40 <LoganCapaldo> @type interact
15:20:42 <lambdabot> (String -> String) -> IO ()
15:20:44 <bringert> I can't get Andrew Pimlott's original initLastST to use constant heap space
15:20:56 <bringert> could it be a ghc version difference?
15:21:09 <reilly> can somebody tell me why this (http://hpaste.org/137?lines=true) cause an error in haddock on line 24?
15:21:18 <nattfodd> dons: well, I might be porting the coolest ghci features to the ocaml toplevel
15:21:30 <dons> ah ok.
15:21:37 <nattfodd> so I'm looking for the most complete description fo those features
15:21:39 <dons> tab completion!
15:21:39 <sorear> reilly: it uses ghc-only features
15:22:00 <dons> reilly: I think its the unsafeCoerce#'s
15:22:01 <bringert> reilly: just guessing: maybe the where on line 23 throws it off?
15:22:05 <sorear> reilly: I told you were told yesterday?
15:22:09 <dons> reilly: oh no.
15:22:12 <dons> its : class HashIO a => UniqueHashIO a
15:22:15 <dons> missing a 'where' clause
15:22:24 <reilly> but it compiles
15:22:28 <reilly> this is the HsJudy source
15:22:33 <dons> right. haddock is not as lenient as ghc
15:22:40 * glguy supposes that if you coipy the "link" on any given paste, the lines setting should be preserved
15:22:55 <glguy> nevermind, it is
15:23:06 <dcoutts> @seen boegl
15:23:06 <lambdabot> I haven't seen boegl.
15:23:13 <dmhouse> dons: wasn't there a SoC project to get Haddock using the GHC API?
15:23:24 <yip_> what's better? "ab" ++ "cd" ++ "ef"     vs.     concat ["ab", "cd", "ef"] ?
15:23:31 <dons> there as and is
15:23:42 <reilly> dons: thanks
15:23:49 * TuringTest returns to chat
15:23:51 <dcoutts> @seen bogel
15:23:51 <lambdabot> I haven't seen bogel.
15:23:56 <dons> nattfodd: but i think you better dive into the src at some point, and use ghci enoug to work out what the best features are
15:24:00 <dons> welcome back TuringTest !
15:24:05 <dons> ?users
15:24:05 <lambdabot> Maximum users seen in #haskell: 322, currently: 309 (96.0%), active: 45 (14.6%)
15:24:16 <dmhouse> yip_: the latter evaluates to the former.
15:24:20 <TuringTest> dons: I just posted my regex-tdfa announcement to the mailing lists.
15:24:23 <dons> we've had some new users since I've last seen you here
15:24:25 <yip_> dmhouse: yeah, but which is faster?
15:24:27 <dons> cool
15:24:31 <dons> ah yes. very good
15:24:38 <dmhouse> yip_: my guess is neither. Why not benchmark it?
15:24:50 <yip_> what do you think dons? :)
15:25:03 <dons> concat
15:25:06 <TuringTest> That is a huge number of users.  I remember only 200 or so before...
15:25:11 <dons> but they're the same really
15:25:15 <kolmodin> good night
15:25:18 <nattfodd> dons: that's how it'll end up if I proceed with it, but I wanted to have a first look at what features ghci had
15:25:19 <reilly> sorear: I asked the general question yesterday, got a general answer, pasted to the paste bin for the specific question and then had to leave before I could ask it
15:25:21 <yip_> i know that in python, the concat is much faster
15:25:28 <nattfodd> that said, the user guide looks really good
15:25:30 <dons> so it is with strict bytestrings
15:25:36 <dons> but for lazy lists , no difference
15:25:36 <kolmodin> oo, hia nattfodd :)
15:25:48 <sjanssen> yip_: approximately the same speed for standard Strings
15:26:05 <dons> with a strict data type the concat can pre-allocate the result buffer
15:26:17 <dons> but the result in a lazy structure is just grown on demand anyway
15:26:17 <nattfodd> heya kolmodin :)
15:26:38 <yip_> what about strictness annotations?
15:26:42 <dons> hence 'concat' should always be faster on a strict data type
15:26:48 <nattfodd> kolmodin: are you still in sweden?
15:26:51 <dons> yip_: you need to be even stricter though
15:26:54 <sjanssen> yip_: what about them?
15:26:57 <kolmodin> nattfodd: how are you doing? back in gothenburg soon?
15:26:57 <dons> (won't work for lists)
15:27:09 <sorear> dons: I wonder why announce *isn't* the default ... It seems to be discouraging people from using the IMO most important feature of a pastebin
15:27:09 <kolmodin> nattfodd: I am, yes. looks like I'm staying :)
15:27:14 <nattfodd> kolmodin: yes, back in early march, and I'm doing fine, thanks
15:27:14 <glguy> should I patch hscolour to support tabs properly? or should I work around that in the hpaste code?
15:27:18 <nattfodd> great!
15:27:21 <dons> glguy: yeah, i agree.
15:27:25 <dons> announce should be the default again :)
15:27:29 <dons> we don't see any announces now
15:27:33 <glguy> ok
15:27:37 <dons> once people have finished with the 'test' phase
15:27:44 <dons> or perhaps 'silent' should be clearer
15:27:49 <sorear> dons: I pointed it out :)
15:27:54 <dons> for example 'do not announce to #haskell that you are mucking around'
15:28:22 <kolmodin> nattfodd: great! we'll meet then
15:28:39 <glguy> how about this
15:28:41 <glguy> half and half
15:28:58 <nattfodd> indeed yes, time to restart the gentoo gteborg conspiration
15:29:24 <dons> glguy: good
15:29:32 <sorear> looks nice
15:29:39 <kolmodin> nattfodd: indeed :)
15:29:40 <glguy> can an <h1> be contained *inside* an <a>?
15:29:48 <glguy> (I have to ask because I don't think it can)
15:29:51 <nornagon> i think it's illegal.
15:29:54 <sorear> glguy: can you permute it?
15:30:02 <kolmodin> nattfodd: how is your recruitement doing with regards to ocaml and gentoo?
15:30:02 <sorear> <h1><a>foo</a></h1>
15:30:13 <LoganCapaldo> Sure it can :) <a><h1>helo</h1></a>
15:30:14 <nattfodd> kolmodin: huh? which recruitment?
15:30:16 * LoganCapaldo does it
15:30:18 <glguy> OH
15:30:19 <glguy>  Iknow
15:30:23 <glguy> I need to put the SPAN
15:30:25 <glguy> inside the hotlink
15:30:26 <monochrom> glguy: are you referring to html4? xhtml?
15:30:30 <glguy> xhtml
15:30:35 <glguy> i think i figured it out
15:30:37 <glguy> I'll update
15:30:48 <sorear> dons: yi is type correct again ... what is the best way to test?
15:31:14 <dons> run the testsuite
15:31:15 <dons> and use it
15:31:19 <kolmodin> nattfodd: you where trying to get a ocaml herd starting, or something like that. not that good I suppose, then
15:31:30 <dons> test test test. it is *very* easy to break that low level code
15:31:36 <dons> so I need some strong reassurances that it works
15:31:45 <sorear> dons: well, it wasn't usable before, so using it won't help much :)
15:31:52 <nattfodd> kolmodin: oh
15:32:03 <sorear> dons: like, minibuffer is 30 lines
15:32:06 <nattfodd> well, a friend joined recently to help with it
15:32:09 <nattfodd> but it's quite low-traffic
15:32:14 <nattfodd> not many users, I'm afraid
15:32:17 <monochrom> glguy: no, xhtml 1.1 does not allow <a><h1> ...
15:32:23 <glguy> yeah.. didn't think so...
15:32:36 <monochrom> xhtml 2 may allow it again
15:32:39 <nattfodd> lisp is also orphaned in gentoo now, since mkennedy left
15:32:40 <kolmodin> nattfodd: you should only use haskell instead :D
15:32:54 <kolmodin> it is? hmm :/
15:33:25 <nattfodd> it'll probably happen, since this is what people use at chalmers
15:33:35 <sorear> dons: yi uses fptools!?
15:33:36 <sorear> stefan@stefans:~/yi/testsuite$ make
15:33:36 <sorear> Makefile:3: ../mk/config.mk: No such file or directory
15:33:37 <sorear> make: *** No rule to make target `../mk/config.mk'.  Stop.
15:34:20 <glguy> I have no idea why it underlines yet, but the header is now a link to the root
15:34:21 <dons> no.
15:34:22 <dons> looks like the testsuite got broken somewhere along the line
15:34:22 <dons> should be easy to fix
15:34:30 <glguy> which many people have been telling me to do
15:34:59 <kolmodin> nattfodd: that might mean that we'll get your help in #gentoo-haskell then? yay! :) we could use another skilled guy
15:35:24 <nattfodd> wait a moment before you call me "skilled", please :)
15:35:35 <kolmodin> hah :)
15:36:10 <nattfodd> aren't you already, like, three thousands devs working on haskell?
15:36:17 <nattfodd> seen from ocaml, that's the impression I get :)
15:36:32 <kolmodin> nattfodd: kind of true, but only 5 that also are gentoo devs
15:36:54 <kolmodin> although, 5 would be enough, we have been lazy for a few months
15:36:57 <nattfodd> if it's only about commit rights, one is enough
15:37:19 <kolmodin> true
15:38:42 <glguy> anything think I need to make a change for this:
15:38:42 <glguy> bakert said 6h 35m 23s ago: it would be really great to have some whitespace at the bottom of hpaste pages so that when you click on a link like this: http://hpaste.org/141#4 the code you want is at
15:38:44 <kolmodin> well, I'm off to bed
15:38:45 <glguy> the bottom of the page
15:38:47 <kolmodin> good night!
15:38:53 <glguy> before I delete that item?
15:39:06 <dcoutts> g'night kolmodin
15:39:12 <kolmodin> g'night dcoutts
15:39:16 <dons> nattfodd: hehe. "three thousands devs working on haskell?"
15:39:19 <nattfodd> good night kolmodin
15:39:19 <dons> nattfodd: we try :)
15:39:26 <dmhouse> glguy: there's a better way of doing that.
15:39:29 <nattfodd> dons: only in gentoo, I mean
15:39:44 <nattfodd> dons: I know there are a lot more that work on the language itself :)
15:39:59 <dcoutts> :-)
15:40:03 <dons> ?users #gentoo-haskell
15:40:03 <lambdabot> Maximum users seen in #gentoo-haskell: 20, currently: 19 (95.0%), active: 6 (31.6%)
15:40:13 <dmhouse> glguy: detect when the requested URL involves a #target, and if it does, highlight the element with that ID somehow.
15:40:21 <dcoutts> we've been doing a good job on PR then :-)
15:40:28 <dmhouse> It's commonly done with Javascript but you could do it serverside too.
15:40:44 <glguy> dmhouse: yeah... it would be easy enough server side...
15:41:03 <glguy> but
15:41:11 <glguy> that wouldn't work if you click the lnk while you were on the page
15:41:23 <dmhouse> Ah, that's why you need Javascript then.
15:41:38 <glguy> I know about [-] this much javascript
15:41:39 <ctkrohn> Hey, can anyone help with a newbie monad/typeclass question?  I have a function of type RecState () (where RecState is a monad I constructed using the state monad transformer).  When I call it, ghci says there's no instance of (Show (RecState ()), but when I add "instance (Show (RecState ())) where show r = putStrLn "()"", it says there's an illegal instance declaration.  Any ideas?
15:41:46 <dmhouse> glguy: know Java?
15:41:51 <glguy> dmhouse: C#
15:42:29 <TuringTest> ctkrohn: show r = "()"
15:42:29 <dmhouse> glguy: I might be able to sort you out with a patch. Javascript's not very hard if you just want the basics.
15:42:44 <sorear> ctkrohn: that's an illegal instance declaration. really, it is.
15:43:00 <glguy> dmhouse: I'd be keen to accept a .js file + hooks on the displayPage
15:43:00 <dmhouse> glguy: but it's like the rest of web dev, there's a right and a wrong way to do it, and a lot of old tutorials around will teach you the older, wrong way.
15:43:00 <ctkrohn> sorear: right, so how do I fix it? :)
15:43:02 <ctkrohn> TuringTest: I'll try
15:43:07 <sorear> ctkrohn: why do you want to show a State?
15:43:07 <TuringTest> ctkrohn: you wrote a show instance of type "RecState () -> IO ()" which is not "RecState () -> String"
15:43:31 <glguy> dmhouse: or if you want to send a js file and an example, I'd integrate it myself
15:43:38 <dmhouse> glguy: I'll try to find the time. I might not be able to do it over the next couple of days.
15:43:44 <glguy> that's fine
15:44:18 <dmhouse> glguy: or how about http://dorward.me.uk/software/frag/ ?
15:44:20 <ctkrohn> sorear: I don't... what I want to do is get it so GHCI doesn't throw up when I call functions of that type... it should behave just as if you're calling a function of type IO ()
15:44:20 <lambdabot> Title: Fragment Highlight (Dorward Online)
15:44:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/154
15:44:55 <ctkrohn> TuringTest: If I just change that one part, it still gives me an illegal instance declaration
15:44:59 <sorear> ctkrohn: that's not a IO ()
15:45:03 <monochrom> ghci's behaviour upon IO() is tailormade to IO().
15:45:06 <sorear> ctkrohn:
15:45:08 <glguy> dmhouse: looks interesting
15:45:13 <sorear> @unmtl StateT foo IO ()
15:45:14 <lambdabot> foo -> IO ((), foo)
15:45:25 <sorear> you need to give it an initial state
15:45:27 <dmhouse> glguy: that's the general idea. Using a prebuilt language would be easier.
15:45:44 <bd_> @mtl foo -> IO ((), foo)
15:45:44 <lambdabot> Maybe you meant: ft map msg pl unmtl url
15:45:50 <dmhouse> glguy: it looks well designed, it uses the DOM, has good browser support, is well documented; these are all plus points.
15:46:03 <glguy> ok, I'll take a look
15:46:26 <ctkrohn> OK... so in order to debug these functions in ghci, would I have to wrap it in evalState or something like that, in order to make sure that it's passing the state around?
15:46:32 <sorear> yes
15:46:48 <dmhouse> glguy: to integrate it you'd download the file and include <script type="text/javascript" src="hi.js"></script> in the <head> element.
15:46:52 <ctkrohn> alright, makes sense
15:47:09 <sorear> but the state *won't* be passed around from one call to the next ... you need to use IO for global mutable vars
15:47:18 <dmhouse> G'night all.
15:47:18 <sorear> but usually that's a good thing
15:47:36 <sorear> since evalState foo initst gives the same answer repeatably.
15:47:45 <ctkrohn> Right, I see.
15:48:10 <monochrom> ghci treats IO() by going out of its way to evaluating the IO() function you give.
15:48:20 <monochrom> this is not a generic behaviour.
15:51:18 <monochrom> You would have to go out of your way to hack and rebuild ghci if you want a similar magic for your own monads.
15:54:17 <monochrom> Another thing is instance Show (PolymorphicType ()) is illegal.  You can only instance Show (PolymorphicType a).  You can't assume much about "a" there.
15:55:38 <bd_> Hmm, why is that considered illegal?
15:56:08 <monochrom> To make Haskell simpler.
15:57:41 <LoganCapaldo> could you do something like instance (Unit x) => Show (PolyMorphicType a) where show = ... where you make () the only instance of Unit ?
15:57:50 <LoganCapaldo> err s/a/x/
15:58:02 <monochrom> I haven't tried :)
15:58:26 <monochrom> Actually, yes.  I should know.
15:59:50 <bd_> Are there any extensions which allow instance Show (PolymorphicType ()) directly...?
15:59:57 <glguy> http://hpaste.org/146#1
16:00:31 <monochrom> Yes there are ghc extensions for that.
16:00:49 <shapr> boing!
16:01:00 <yip_> "Many readers, ourselves included, will have a queasy feeling by this stage. What is left of the beauty of functional programming by the time all these primitives have been added? How can the unspecified "proof obligations" of unsafePerformIO be characterised and proved? Has the baby been thrown out with the bath water? These are justifiable criticisms. The baby is indeed in danger."
16:01:23 <shapr> Yay, I'm back from unicycling at Oak Mountain, gotta upload a few more pix... Ok, I ask for suggestions from the channel, how can I use Haskell to improve my unicycling?
16:01:42 <LoganCapaldo> You don't actually _need_ unsafePerformIO?
16:01:46 <LoganCapaldo> do you?
16:01:56 <monochrom> I have again forgotten how Show [Char] gets different treatment from other Show [a]'s.
16:02:20 <hpaste>  sm annotated "multiline string literal example" with "parse trouble" at http://hpaste.org/152#1
16:03:19 <glguy> I'm open to alternate suggestions on the highlighting that #1 adds
16:03:22 <monochrom> Nevermind, I'm an idiot
16:04:22 <sm> could someone tell me why the try in that paste does not work as described ? should I be using Parsec.Token instead ?
16:05:38 <LoganCapaldo> sm: This is a wild ass guess but I think it needs to be try (do { char "*"; return True } ) <|> return False
16:06:03 <twanvl> sm: If there is no "*", then the second many1 space will fail
16:06:49 <sm> twanvl: true.. it's saying unexpected "j", expecting space or "*"
16:06:59 <LoganCapaldo> Or I could just make some stuff up :)
16:07:30 <monochrom> -fallow-overlapping-instances allows instance MyClass (MyPolymorphicType Int)
16:09:44 <sm> once I moved the many space into the do block, either LoganCapaldo's spelling or mine worked
16:09:51 <sm> thanks!
16:10:02 <monochrom> probably also need -fallow-incoherent-instances
16:10:48 <LoganCapaldo> -fallow-total-insanity
16:11:12 <LoganCapaldo> -fallow-cant-plant-these-fields-anymore
16:11:37 <LoganCapaldo> *ba dum tih*
16:12:05 <basti_> -fgive-up
16:12:25 <Cale> -fomgwtfbbq
16:12:31 <monochrom> -fread-my-mind!!!!111
16:13:00 <bd_> -fparse-as-c
16:13:07 <Cale> -fignore-all-types
16:13:23 <LoganCapaldo> -funroll-loops
16:13:25 <bd_> -fimplicit-unsafecoerce
16:13:37 <basti_> -fsolve-halting-problem?
16:13:47 <mbishop> -foverused-jokes
16:13:54 <Cale> -fadjective-noun-verb-verb-verb
16:13:55 <basti_> -ffun
16:14:01 <bd_> -fimplicit-pragma-flags
16:14:03 <basti_> -finsult
16:14:08 <mbishop> -fretort
16:14:16 <basti_> :D
16:14:16 <Cale> -fswedish-chef-bork-bork-bork
16:14:19 <monochrom> I am an idiot again.  -fglasgow-exts is sufficient to allow instance MyClass (PolymorphicType ())
16:14:23 <bd_> -fpave-the-earth
16:14:37 <LoganCapaldo> -funified-control-kernel
16:14:56 <bd_> -fsynchronize-bimorphic-subspace-field
16:14:58 <yip_> how can i get the number of enumerations a type has? add a "Last" constructor?
16:15:17 <allbery_b> derive Enum, use maxBound
16:15:35 <AStorm> -freplace-linux
16:15:37 <bd_> yip_: If a type is a member of Enum and Bounded, you could do: (fromEnum (maxBound :: YourType)) - (fromEnum (minBound :: YourType)) + 1
16:15:38 <master_baiter> -fnumber_type_enumerations
16:16:05 <bd_> this will only work if the range is smaller than Int though :)
16:16:35 <yip_> cool it works!
16:16:51 <AStorm> -fwork-dammit!
16:17:05 <allbery_b> -fdwim
16:17:08 <augustss> yo
16:17:33 <monochrom> -frebuild-ghc-everytime-you-run-ghc
16:17:47 <mbishop> -fallbery_b-needs-to-send-me-that-wifi-card
16:17:47 <AStorm> -finfinite-stack
16:17:59 <augustss> -f
16:18:04 <monochrom> -fjust-ask-lambdabot
16:18:09 * allbery_b needs to be at work more tghan one day a week, which so far he's been failing miserably at, d*mmit
16:18:18 <Cale> AStorm: I'd like that one.
16:18:40 <monochrom> use continuations
16:18:45 <Cale> We actually do have the machinery to allow unbounded stacks. The bound is entirely artificial.
16:18:47 <Botje> -fuse-gmail-for-the-stack
16:18:59 <monochrom> haha
16:19:10 <Botje> "2G should be enough for everyone"
16:19:10 <emu> ah yes, the email turing machine
16:19:26 <LoganCapaldo> -fattachment-allocated-stack-frames
16:19:27 <monochrom> -fvia-gmail
16:19:30 <Botje> emu: careful. somebody might write a thesis paper on it.
16:19:43 <emu> probably been done
16:19:54 <Botje> like the guy who implemented binary circuits with water (yes, in tubes)
16:19:59 <monochrom> Some of those should be RTS flags.
16:20:01 <AStorm> LoganCapaldo, there is a method of storing infinite (semi?) amounts of data using the internet.
16:20:10 <mauke> the internet is a ...
16:20:12 <emu> did it hook up to pigeon IP?
16:20:21 <AStorm> No.
16:20:23 <augustss> Cale: what is the machinery for unbounded stacks?  Where can I buy one?
16:20:24 <Botje> emu: no, he was still compiling the kernel module
16:20:32 <AStorm> It worked by bouncing return packets around
16:20:38 <AStorm> (mostly email)
16:20:51 <monochrom> +RTS -heap=gmail -stack=gmail -stdin=gmail -stdout=gmail -stderr=gmail
16:21:26 <monochrom> The bouncing method is clever.
16:21:37 <Botje> monochrom: you forgot -code=gmail
16:21:39 <augustss> But it's not unbounded
16:21:57 * allbery_b remembers the backups-via-usenet (faux-)hack
16:21:59 <AStorm> Yes, it's not unbounded, but a single mail server can provide about 2TB space
16:22:07 <AStorm> s/2TB/2GB/
16:22:20 <AStorm> But it's not really random-access.
16:22:26 <augustss> Bah!  I want unbounded!
16:22:30 * monochrom writes a haskell implementation for the bouncing method
16:22:32 <AStorm> and you must have a lot of bandwidth.
16:22:54 <AStorm> Data will return after between 1 and 3 weeks.
16:23:08 <AStorm> (maybe as short as 3 days - depends on the server)
16:23:38 <AStorm> You can do some faster bounces with protocols other than SMTP.
16:23:55 <Cale> augustss: allocate in chunks
16:24:14 <augustss> Cale: from where?  My infinite memory?
16:24:24 <bd_> AStorm: ICMP as data storage?
16:24:32 <Cale> Not that sort of infinite :)
16:24:37 <bd_> +RTS --heap=ping:4.2.2.1
16:24:47 <emu> just what we need, bouncing mail data storage on top of spam
16:24:49 <bd_> or use usenet :)
16:24:50 <Cale> By infinite I just mean "only limited by physical memory"
16:25:03 <augustss> Cale: Ah, you meant bounded, but with a different bound. :)
16:25:38 <Cale> Well, presently, there's an artificial bound imposed by the runtime system.
16:25:51 <augustss> Cale: Yeah, that's just silly
16:25:52 <Cale> and I don't think there's a way to turn it off, though I might be wrong
16:26:01 <Cale> You can change it though
16:26:09 <TomMD> The problem with inf memory is Linux will try to fill the entire thing with caches of potentially usful data - you'll need unlimited memory bandwidth too!
16:26:21 <Cale> It's sort of like the volume control on the telescreens in 1984.
16:26:52 <AStorm> TomMD, not really
16:27:14 <AStorm> Linux does now support cache limiting.
16:27:20 <TomMD> Well, eventually it will run out of things to cache.
16:27:26 <AStorm> and different classes of memory.
16:27:31 <TomMD> Really?  Hummm... I'll have to look at that.
16:27:35 <AStorm> NUMA anyone?
16:27:37 <nornagon> once your memory is bigger than your hard drive >:)
16:28:20 <TomMD> Bah NUMA.  Home PCs will never have more than 1 CPU, let alone a need for NUMA.... wait *cat /proc/cpuinfo*... never mind.
16:29:04 <AStorm> :P
16:33:18 <augustss> "Home PCs will never have more than 1 CPU".  Is that some new sill Bill Gates quotes (he types on his 2 CPU MacBook).
16:35:48 <dons> home pcs will never need more than 1024 cpus
16:36:17 * allbery_b thought low-end windows supported 2 cpus
16:36:37 <allbery_b> (no more, you need extra licenses or enterprise version or something)
16:37:38 <augustss> And hey, we are gonna get more transistors with the new hafnium insulator transistors.
16:38:31 <augustss> I'm always amazed with the semiconductor guys, they keep pulling rabbits out of the hat.
16:39:24 <shapr> Has distributed garbage collection been solved?
16:39:55 <augustss> shapr: what do you mean by solved?
16:40:09 <shapr> That's a good point.
16:40:14 <augustss> It can be done is long as the nodes stay connected.
16:40:16 <mbishop> @remember dons home pcs will never need more than 1024 cpus
16:40:17 <lambdabot> Done.
16:40:20 <mbishop> :P
16:40:26 <dons> heh
16:40:51 <mbishop> let's hope lambadbot is still around in a few decades :P
16:41:16 <AStorm> Why 1024 cpus when we have MIPS?
16:42:19 <Botje> why MIPS when we can have MUPPETs ?
16:42:57 <AStorm> You mean these? http://muppets.go.com/
16:42:59 <AStorm> :P
16:43:00 <lambdabot> Title: Muppets.com -- The New Official Home of the Muppets!
16:44:36 <Botje> of course.
16:44:47 <Botje> it helps if you envision packets as really tiny muppets
16:46:06 <Daveman> Botje :P
16:46:26 * Botje turns Daveman into a muppet
16:46:34 <Daveman> zomgoodness
16:46:36 <Daveman> Nattfodd!
16:46:53 <Botje> BORK BORK!
16:47:34 <nattfodd> haha Daveman
16:47:36 <nattfodd> hullo
16:47:46 * nattfodd feels like a local star
16:47:59 <Daveman> ;D
16:48:07 <Daveman> Haven't seen you... in a long time :)
16:48:28 <nattfodd> it's because you don't know where to look :)
16:48:55 <nattfodd> and also that I haven't had the time to look properly at haskell
16:49:01 <monochrom> why your own computer when you can use gmail
16:50:10 * monochrom loves The Muppets
16:50:41 <allbery_b> gmail doesn't' (yet?) incorporate ghci :)
16:50:46 <bringert> gaah!
16:52:01 <Daveman> Nattfodd, so, where have you been hiding? :)
16:53:04 <hpaste>  bringert annotated "bytestring memory leak" with "gaah, I didn't force the tuple!" at http://hpaste.org/147#2
16:53:39 <dcoutts> bringert, so it's better now ?
16:53:54 <nattfodd> Daveman: in a gentoo closet, mostly
16:54:01 <bringert> dcoutts: now the example runs in 3M space, instead of 104M
16:54:08 <dcoutts> not bad
16:54:29 <dcoutts> so that's the ST version of splitAt
16:54:33 <bringert> yeah
16:54:44 <dcoutts> hmm, so does that make the Get monad stuff work ok ?
16:54:54 <bringert> haven't tried yet
16:56:07 <dcoutts> bringert, well if it seems better all round then send it in as a patch to the fps repo and we'll get it into base
16:56:38 <bringert> dcoutts: it will most likely be slower that the normal splitAt
16:56:48 <Daveman> Nattfodd XD
16:57:16 <dcoutts> bringert, though it's often ok to take a little more time since it's dwarfed if the chunks are big enough
16:57:42 <bringert> I'm off to bed, will continue tomorrow
16:57:55 <bringert> dcoutts, dons: thanks for your help!
16:57:55 <dcoutts> bringert, ok, g'night
16:58:00 <bringert> good night
16:59:48 <nornagon> what haskell graphics stuff is there? SDL? OpenGL? GD/ImageMagick?
17:00:20 <Daveman> heh
17:00:36 <dcoutts> nornagon, cairo vector graphics
17:00:37 <Daveman> let the enthusiasm commence
17:00:57 <dcoutts> which is great btw, nice api, lots of backends
17:01:12 <allbery_b> ?where pancito
17:01:13 <lambdabot> http://www.acooke.org/jara/pancito/
17:01:23 <dcoutts> oh yeah, that's pretty cool too
17:01:29 <dcoutts> for bitmap graphics
17:01:55 <dcoutts> nornagon, what's your application? which lib you want will depend on that of course
17:02:11 <Daveman> yay cairo
17:02:22 * Daveman grins at Nattfodd
17:03:03 <AStorm> nornagon, wxHaskell too
17:03:35 <allbery_b> wxHaskell's more of a gui framework, no?
17:03:44 <nornagon> dcoutts: awesome, i'll check it out
17:03:55 <nornagon> i want to play with some procedural generation stuff
17:03:56 <dcoutts> allbery_b, yep, though both the gui libs have 2d graphics bits
17:04:04 <nornagon> 2d and/or 3d
17:04:07 * Daveman praises cairo
17:04:16 <dcoutts> nornagon, ah, then pancito might be for you, it's 2d
17:04:19 <nornagon> mm
17:04:35 <dcoutts> for 3d you pretty much have to use opengl
17:04:37 <nornagon> i heard tell of a haskell GL lib
17:04:43 <dcoutts> HOpenGL
17:04:45 <Daveman> you don't have too
17:04:58 <nornagon> pancito looks nice
17:05:06 <dcoutts> Daveman, well you can do your own projection and all that
17:05:44 <dcoutts> I don't know of any Haskell 3D libs that provide a higher layer above opengl
17:06:04 <Daveman> Sorry :[
17:06:31 <Daveman> I was just impressed with what some people I know did a little while back with the graphics libs :)
17:11:22 * monochrom computer finishes building ghc stage 1 after five hours :D
17:12:02 <Daveman> :P
17:12:35 <sorear> whoah
17:12:46 <sorear> and I thought my comp was slow
17:12:59 <monochrom> I include the extralibs.
17:13:01 <sorear> 90 min here
17:13:03 <Daveman> heh
17:13:06 <sorear> with extralibs
17:13:16 * dons waves 7 minutes around and hands out more cores
17:13:17 <monochrom> 90 minutes is standard.
17:13:25 <Daveman> hehe
17:13:36 <Daveman> you require additional cpus!
17:13:39 <sorear> dons: I've got plenty of cores, just nowhere to put them!
17:13:48 * sorear begs for a 1024-socket mobo
17:13:53 <monochrom> dons is 7 because he uses like 8 to 10 cores. 7*10 is still close to the standard.
17:14:02 <dons> :)
17:14:04 <dcoutts> you need an 8cpu mobo like dons just acquired
17:14:21 <dcoutts> with 8 dual core amd64 chips
17:14:25 <nornagon> distghc?
17:14:28 <dons> these things are commodity now!
17:14:29 <dons> nornagon: nope
17:14:36 <dons> just gmake -j8
17:14:36 <nornagon> i mean, is there one?
17:14:37 <dcoutts> dons, hah hah hah hah
17:14:39 <sorear> I still want a 16 mega-arm system
17:14:40 <dons> nornagon: no
17:15:00 <dons> dcoutts: i think i'll re-add the host-order primitives into get and put
17:15:03 <dons> since people want them
17:15:03 <AStorm> Yeah commodity, right
17:15:07 <dons> the code is lying around here somewhere
17:15:13 <sorear> how many gflops would 16m pic14**'s have? watts?
17:15:19 <AStorm> I can barely afford another Pentium M laptop :P
17:15:26 <nornagon> sorear: heh
17:15:29 <dcoutts> dons, yeah, fine
17:15:41 <sorear> I get free handmedown computers from my must-have-bleeding-edge father
17:15:47 <nornagon> nice
17:15:47 <Daveman> heh
17:15:53 <AStorm> sorear, send me one :P
17:16:12 <nornagon> my computers tend to break, because i buy cheapo ones and don't treat them particularly well
17:16:33 <nornagon> mostly mobo failures
17:16:41 <sorear> my computers tend to break, because they are 3+ years old when I get them
17:16:43 <Daveman> either that, or he's into some kinky compiling... ;p
17:16:49 <monochrom> At one point the build was sitting on Language/TH/Syntax.hs.  It generated like 1MB of C code.  Then it took the C compiler forever and 300MB to munge.  Then the splitter had to split the .o file into 1000 .o files.
17:17:00 <dcoutts> dons, we should also perhaps have people vote on if they want Int to work for the full range on 64bit arches or if serialisation should fail for >2^32.
17:17:05 <AStorm> My computers tend not to break, even though they are 5+ years old
17:17:11 <AStorm> it's because I care
17:17:11 <dcoutts> dons, on haskell-cafe/libraries or something
17:17:20 <AStorm> and take care of them :P
17:17:30 <sorear> of course, the whole computer doesn't fail at once
17:17:43 <AStorm> Not even parts.
17:17:44 <sorear> hard drives are always first to die for me
17:17:50 <AStorm> Maybe some HDDs and ventilators
17:18:12 <AStorm> one power unit too
17:18:15 <nornagon> mmph, you are making me want to buy some kind of backup medium
17:18:23 <nornagon> come to think of it, i have this stack of dvds here
17:18:25 <AStorm> RAID? :P
17:18:26 <monochrom> sorear: actually, same here (about getting 2nd hand highend hardware from father)
17:18:29 <nornagon> but i need to go do some mathsy stuff
17:18:35 <nornagon> that isn't haskelly, sadly
17:18:54 <sorear> continuum math sucks :(
17:19:25 <nornagon> it's high school 4-unit stuff
17:19:30 <nornagon> i am horrible at it
17:19:32 <sorear> discrete math problems you can just type into ghci and get free insight :)
17:19:40 <nornagon> yes, i <3 discrete maths
17:19:45 <nornagon> it's much much much more interesting
17:19:48 <nornagon> and easier :P
17:20:09 <AStorm> Crap, I'm having an exam too at Tuesday
17:20:12 <sorear> and you don't have to worry about uncountable foo
17:20:19 <AStorm> Well, I do.
17:20:22 <sorear> the AoC makes the MR look tame
17:20:25 <AStorm> Analysis.
17:20:54 <AStorm> Integrals do suck. Differential equasions even more.
17:21:08 <AStorm> Unappealing and mindless.
17:21:17 <AStorm> (also hard :P )
17:21:43 <AStorm> Totally unlike that nice Fourier transform.
17:21:47 <allbery_b> diff.eq. defeated me
17:21:47 <AStorm> </rant mode>
17:22:13 <dons> dcoutts: yeah, as John Meacham aid, assuming Int == Int64 is a portability bug
17:22:23 <dons> so we could just tell the Int=Int64 users to fromIntegral first
17:22:27 <sorear> AStorm: you realize forier transform turns linear diff eq into linear algebra?
17:22:31 <dcoutts> dons, well, we're not. We're allowing it to be 64
17:22:42 <AStorm> sorear, yep, that's why it's nice :D
17:22:48 <AStorm> Algebra is nice, even.
17:22:52 <allbery_b> although admittedly I'm uncertain whether it was diffeq per se or the instructor that spoke English so heavily accented that most f the class couldn't undertstand his rapid-fire talk
17:22:53 <sorear> "64 bit accumulators ought to be enough for anyone"
17:23:23 <dcoutts> dons, the point is that you can't make Int both portable and support round-trips without wasting space for impls with smaller Int
17:23:29 <sorear> dons: so, whatcha gonna do when 128 bit cpus are mainstream? :)
17:23:59 <nornagon> roll over in his grave?
17:24:11 <dons> get one?
17:24:22 <AStorm> Converting some function space to the space of {sin, cos, 1} is great.
17:24:37 <AStorm> (yes, my math english still sucks a bit)
17:24:56 <sorear> function spaces are cool
17:25:19 <sorear> o<^2 points just don't fit in my brain, unfortunately
17:25:23 <dcoutts> dons, I mean, we don't assume it's 64bit, we allow communication between both sizes and allow round trips on both sizes. The other solution is to fail at runtime on 64bit arches for Ints bigger than 2^32.
17:25:40 <sorear> Partial functions: Just Say No
17:26:12 <dons> i'm sensitive to John's concerns that Int means >= 4 byte of padding most of the time
17:26:20 <conal> does anyone use longlines-mode and mmm-mode in emacs?  i'm getting an unfriendly interaction between them.  it's for having a literate haskell program be TiddlyWiki markup.
17:26:21 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
17:26:39 <dons> if someone makes a statement that Int > 29 bits <= 32 bits in Haskell' ...
17:27:10 <dcoutts> dons, yeah, I get the complaint. I think we should see what public opinion is more generally about what the priority should be.
17:27:12 <hpaste>  csci pasted "Making a small function more "haskell"-ish" at http://hpaste.org/155
17:27:26 <dons> dcoutts: btw, we need liftM5 .. liftM14 for some of these 'get' instances :)
17:27:37 <dons> liftM6 (,,,,,) get get get get get get
17:27:40 <csci> I've written a small parsing-functions and I'm pretty sure there's a more haskell way to do it
17:27:43 * beelsebob pokes his nose in and stops lurking briefly
17:27:53 <Cale> Use ap
17:27:54 <csci> Would we really nice if someone could take a look
17:28:11 <beelsebob> csci: poik it onto a board somewhere then
17:28:16 <nornagon> :t ap
17:28:18 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:28:19 <mbishop> ?paste
17:28:20 <dons> Cale: example? it'll still be more verbose than liftMN though, right?
17:28:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:28:25 <Cale> yes, a bit
17:28:28 <nornagon> :t liftM
17:28:29 <Cale> return (,,,,,) `ap` get `ap` get `ap` get `ap` get `ap` get `ap` get
17:28:30 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
17:28:35 <dons> stopping at liftM4 seems a bit low
17:28:43 <dons> 7 would be more traditional
17:28:59 <Cale> Well, there aren't *that* many functions which have over 4 or 5 parameters.
17:29:06 * allbery_b wonders if that ap could be expressed with a fold...
17:29:08 <csci> beelsebob: I'm not sure I understood you
17:29:10 <beelsebob> dons: yeh, the whole idea of such functions just screams something ungenrealis(ed|able) though
17:29:12 <dons> yeah, only Binary instances for tuples > 5 :)
17:29:12 <allbery_b> ap chain
17:29:20 <dcoutts> dons, or see if it can be fixed with another layer, like we'd like to do with the string pool layer
17:29:21 <beelsebob> csci: put it on a pasteboard (probably hpaste.org)
17:29:21 <Cale> allbery_b: not quite, because the types wouldn't work
17:29:24 <LoganCapaldo_> woah I wasn't paying atten and for a second there I though Cale had just written the world's most obfuscated liftM ever
17:29:32 <sorear> can't we just do it with typeclass oleging, a la PrintfType
17:29:37 <csci> Did already ;-) See a few more lines before
17:29:41 <dcoutts> dons, the point of some layers might be to change the instance of some key types
17:29:45 <dons> yeah
17:29:47 <monochrom> Someone wrote a (String->)^8 -> IO () function some time ago.
17:29:53 <Cale> LoganCapaldo_: that's actually the reason for ap's existence, to simulate liftMn's
17:30:18 <LoganCapaldo_> ^8 ???
17:30:31 <monochrom> 8 String-> 's
17:30:32 * dcoutts -> bed
17:30:33 <dcoutts> g'night folks
17:30:39 <LoganCapaldo_> lol
17:30:45 <LoganCapaldo_> thats new and exciting notation
17:30:50 <LoganCapaldo_> to me anyway
17:30:51 <sorear> I'm glad the type of bed is inhabited :)
17:31:00 <Daveman> heh
17:31:45 <nornagon> LoganCapaldo_: incidentally, it doesn't actually parse (afaik)
17:32:01 <hpaste>  beelsebob annotated "Making a small function more "haskell"-ish" with "I would say this is more Haskellish" at http://hpaste.org/155#1
17:32:23 <monochrom> I could contrive a TH notation for "8 String parameters".
17:32:29 <beelsebob> csci: there you go possibly
17:32:30 <LoganCapaldo_> foldr1 (->) (take 8 (fix (String:))) -> IO () :)
17:32:37 <monochrom> Haha
17:32:37 <beelsebob> see what you think
17:32:44 <csci> beelsebob: Great! Thanks. I should really think more in pattern matching :)
17:32:49 <sorear> LoganCapaldo_: easily... use type nats!
17:33:05 <beelsebob> csci: note that it actually more easily meats your spec
17:33:10 <Daveman> Why does this appear to infinitely recurse when parsing the bin op case? http://rafb.net/p/3QfWEx73.txt
17:33:16 <allbery_b> "typeclass oleging" :)
17:33:19 <beelsebob> csci: first it deals with the quoted case
17:33:25 <beelsebob> second it deals with the non quoted case
17:33:30 <beelsebob> and finally the case where it's not a space
17:33:42 <Daveman> and why is return necessary?
17:34:02 <csci> beelsebob: Yes, that's what I mean when I say Haskell is elegant!
17:34:20 <allbery_b> daveman: first thng parseExpr does is call parseExpr
17:34:27 <beelsebob> csci: I would suggest that perhaps it would be more efficient to do what you're doing with CPS
17:34:39 <beelsebob> i.e. pass a continuation to do on the second half of the list
17:34:40 <csci> beelsebob: CPS?
17:34:42 <sorear> Daveman: left recursive grammers don't work in parsec, use chainl1 instead
17:34:44 <allbery_b> I'd put that case after the parseAtom and parseNumber
17:34:51 <beelsebob> csci: continuation passing style
17:34:52 <sorear> Daveman: /me points out hpaste :)
17:34:52 <csci> beelsebob: Have still to take a tlook at continuations
17:35:00 <allbery_b> and yeh, ==beelsebob
17:35:01 <csci> beelsebob: AFAIK YAHT has a chapter, right?
17:35:28 <beelsebob> csci: not sure, probably
17:35:32 <beelsebob> allbery_b: what's that?
17:35:38 <csci> beelsebob: ok, thanks, am going to take a look
17:35:45 <allbery_b> sorry, meant sorear
17:35:47 <Daveman> allbery_b, oh geeze, whoopsie :)
17:35:52 <allbery_b> too any things scroolling by at once
17:36:01 <Daveman> sorear, ah, okay, and yeah yeah I'm aware :)
17:36:08 <beelsebob> hehe
17:37:58 <base3> if ghc invokes gcc with a bad option, that's a  bug for sure, right??
17:38:06 <sorear> yes ?
17:38:08 <allbery_b> could be
17:38:19 <allbery_b> could also mean you did something silly the configure didn't catch
17:38:21 <nornagon> huh, http://darcs.haskell.org/~lemmih/hsSDL/
17:38:23 <lambdabot> Title: Index of /~lemmih/hsSDL
17:38:31 * allbery_b keeps selecting ObjectIO which doesn't exist for unix
17:38:43 <allbery_b> ...and passes a cygwin-only -foption to gcc
17:39:34 <allbery_b> (when building ghc)
17:40:12 <hpaste>  sorear annotated "Making a small function more "haskell"-ish" with "another way" at http://hpaste.org/155#2
17:40:59 <base3> uh, i was building ghc from the makefile and ghc used an incorrect -m option
17:41:40 <base3> is there anyway to see exactly with what commands gcc is being invoked??
17:42:03 <allbery_b> did you configure with --enable-objectio?  are you on OSX or unixlinux?
17:42:08 <allbery_b> unix/linux
17:42:11 <base3> unix
17:42:56 <base3> trying to build a sparc/solaris compiler from a x86/linux ghc
17:43:18 <allbery_b> ah.  sparc/solaris not supported currently, I understand
17:43:39 <LoganCapaldo_> really? Darnitall
17:43:40 <allbery_b> (support is "there" but very out of date and likely not compatible with current versions of gcc)
17:46:03 <sm> what is the best way to expand "~" in a filepath ?
17:46:12 <base3> well, i see, there is prob. something ancient and wrong in a configure script somewhere that needs to be changed..
17:46:30 <sorear> sm: to the user's home directory.  anything else would be suprising.
17:46:56 <sm> I mean, is there a standard function to take care of this ?
17:47:12 <allbery_b> it's also highly likely that the platform support doesn't hook up to whatever internal iterfaces ghc6.6 has
17:47:26 <sorear> The Unix Way is to have the shell take care of such things.
17:47:44 <sorear> dons: how do I fix the testsuite?
17:48:09 <LoganCapaldo_> what if its not a command line argument? shell out just to say "echo ~" ?
17:48:24 <mauke> sm: there's a C function (glob(3)); dunno if there's a haskell interface
17:49:12 <sm> thanks.. I'm finding only System.Directory.getHomeDirectory
17:51:03 <dons> sorear: work out why its breaking (probably trivial reasons to do with missing tools in cpp symbols)
17:51:06 <sorear> urk! Inconsistent repository!
17:51:20 <sorear> I have my first inconsistent repository!
17:51:22 <sorear> yay!
17:51:38 <sorear> glad I ran darcs check --complete...
17:53:30 <LoganCapaldo_> @hoogle expandPath
17:53:31 <lambdabot> No matches found
17:53:41 * sm seeks a nice haskellish idiom for filepath.replace('~',getHomeDirectory())
17:53:49 <LoganCapaldo_> @hoogle FilePath -> FilePath
17:53:50 <lambdabot> Distribution.Compat.FilePath.dropAbsolutePrefix :: FilePath -> FilePath
17:53:50 <lambdabot> Distribution.Compat.FilePath.changeFileExt :: FilePath -> String -> FilePath
17:53:50 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
17:54:17 <sm> ooh.. a good lead
17:54:26 <LoganCapaldo_> sm: That's not entirely true
17:54:37 <LoganCapaldo_> ~user and ~/ are different
17:54:41 <mauke> concatMap trans filepath where trans '~' = homedir; trans x = [x]
17:54:52 <sorear> even more amazingly, darcs repair worked !!!
17:56:07 <sm> LoganCapaldo_: right
17:56:38 <sm> Distribution.Compat.FilePath should have such a function
17:56:54 <sm> ah, thx mauke
17:56:55 <sorear> @users
17:56:56 <lambdabot> Maximum users seen in #haskell: 322, currently: 294 (91.3%), active: 37 (12.6%)
18:01:41 <bd_> ?src MonadTrans
18:01:42 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:02:14 * sm tries hard to make this work
18:07:40 <sm> so, getHomeDirectory returns an IO FilePath.. how would you modify this path ?
18:08:06 <sm> or splice it into another ?
18:08:23 <sm> joinPaths I guess
18:09:13 <sm> well, I must move on
18:11:04 <sorear> dons: I get a lot of missing symbol errors ... FBuffer_, assertEqual, and insertB
18:11:17 <sorear> (when trying to load UnitTestsMain)
18:11:50 <bd_> @hoogle (a -> b) -> a -> Bool
18:11:51 <lambdabot> No matches, try a more general search
18:12:08 <bd_> @djinn (a -> b) -> (b -> b -> Bool) -> a -> Bool
18:12:10 <lambdabot> f a b c = b (a c) (a c)
18:12:18 <bd_> @. pl djinn (a -> b) -> (b -> b -> Bool) -> a -> Bool
18:12:19 <lambdabot> f = flip =<< (ap .) . flip (.)
18:12:39 <sorear> bd_: what do you wish to accomplish?
18:13:03 <bd_> I recall hearing of a 'comparing' function in recent GHC, I was wondering if there was an analogous one for ==
18:13:13 <allbery_b> equating
18:13:28 <bd_> ah. Which module is it in (and moreover, is it HEAD or in 6.6?)
18:13:53 <sorear> Data.Function | Data.Ord
18:13:55 <sorear> HEAD
18:14:06 <bd_> thanks
18:14:11 <bd_> guess I can't use them yet then :)
18:14:23 <sorear> it only takes 90m :)
18:14:35 <sorear> no, not months
18:14:45 <Lemmih> It's also in 6.6
18:15:15 <allbery_b> where?
18:16:08 <bd_> comparing is in 6.6
18:16:12 <bd_> equating doesn't seem to be?
18:18:06 <LoganCapaldo_> > let expandHome path = if null path then "" else (foldr1 (.)  $ map (\c -> case c of '~' -> ("/home/user" ++); _ -> (c:)) path) "" in expandHome "~/b/c"
18:18:07 <lambdabot>  "/home/user/b/c"
18:21:03 <nornagon> > let expandHome path = if null path then "" else foldr1 (.) $ map (\c -> case c of '~' -> ("/home/user" ++); _ -> (c:)) path) "" in expandHome "/foo/bar/~"
18:21:04 <lambdabot>  Parse error
18:21:07 <nornagon> er.
18:21:20 <nornagon> > let expandHome path = if null path then "" else (foldr1 (.) $ map (\c -> case c of '~' -> ("/home/user" ++); _ -> (c:)) path) "" in expandHome "/foo/bar/~"
18:21:22 <lambdabot>  "/foo/bar//home/user"
18:22:04 <nornagon> $ echo /foo/bar/~
18:22:04 <nornagon> /foo/bar/~
18:22:25 <LoganCapaldo_> yes its well established that this is broken :)
18:22:40 <LoganCapaldo_> $ echo ~anotheruser
18:23:11 <LoganCapaldo_> I was jsut enjoying creating a list of functions :)
18:23:15 <sorear> @tell dons urk - I've changed datatypes used by the testsuite; thus the one that works when I've fixed it will not have the all the tests it used to :(
18:23:16 <lambdabot> Consider it noted.
18:27:23 * allbery_b hates OSX sometimes
18:28:22 <allbery_b> you'd think the system getpwnam() (as linked into both perl and the ghc libs) would use the same routines the rest of the system does, namely lookupd, and therefore would actually work
18:28:23 <sorear> @tell dons oooh ... the entirety of cbits is no longer used ... should it be kept?
18:28:23 <lambdabot> Consider it noted.
18:30:26 <hpaste>  Cale annotated "Making a small function more "haskell"-ish" with "factor the problem" at http://hpaste.org/155#3
18:31:14 <Cale> Hmm, csci is gone.
18:31:18 <allbery_b> hrm.  I'd also think ``foo :: FilePath -> IO FilePath; foo somepattern = ...; foo = return'' would work, but ghc6.6 disagrees...
18:32:14 <LoganCapaldo_> @type (***)
18:32:16 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:32:26 <LoganCapaldo_> mmmmmmm k
18:32:46 <Cale> LoganCapaldo_: if you're unfamilar with arrows, you cna read that as  (b -> c) -> (b' -> c') -> (b,b') -> (c,c')
18:33:03 <LoganCapaldo_> oh
18:33:06 <Cale> that is,  (f *** g) (x,y) = (f x, g y)
18:33:07 <LoganCapaldo_> thats not so bad
18:33:24 <Cale> It's just that it's generalised over the type of arrow.
18:34:24 <hpaste>  allbery_b pasted "tildeExpand" at http://hpaste.org/156
18:34:51 <allbery_b> guess sm left
18:35:16 <Cale> It's too bad that my contexts function isn't in the Data.List library.
18:35:53 <sm> oh, hi
18:36:23 <sm> thanks very much
18:36:44 <LoganCapaldo_> hooray! allbery_b's function is actually correct! :)
18:36:57 <Cale> It's naturally an unfold, but not a really pretty unfold.
18:37:06 <allbery_b> well, it doesn't work right on OSX, tha appears to be apple's fault
18:37:48 <allbery_b> noticed it with perl and python as well, libc's getpwnam() etc. can't parse its /etc/passwd and don't consult lookupd.
18:37:55 <allbery_b> stupid
18:38:26 <LoganCapaldo_> how very lame
18:38:46 <LoganCapaldo_> case platform of OSX -> "/Users" ++ name ;)
18:42:18 <LoganCapaldo_> Cale, could that do (f *** g) y <something> x = y (f x) (g x) ? where y is a function
18:42:56 <Cale> that won't type
18:43:09 <Cale> the result of (***) has to be applied to a pair
18:43:14 <sorear> @ask dons if I delete all the (now unused) cbits, do I still have to fix the tests?
18:43:15 <lambdabot> Consider it noted.
18:43:42 <dons> hmm. you deleted them?
18:43:42 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
18:43:52 <dons> there were some key performance issues dealt with there
18:43:57 <Cale> What you're looking for is a little like liftM2 in the reader monad
18:44:10 <dons> like really really key performance issues
18:44:19 <sorear> oh *gulp*
18:44:19 <Cale> @pl \f g y x -> y (f x) (g x)
18:44:20 <lambdabot> flip . (ap .) . flip (.)
18:44:30 <Cale> hehe
18:44:30 * dons worries. that could was very delicate and carefully tuned (see the paper)
18:44:49 <dons> the commit log should have a list of what matters and where
18:44:54 <Cale> @pl \y f g x -> y (f x) (g x)
18:44:55 <lambdabot> liftM2
18:45:00 * sorear isn't too averse to starting over ...
18:45:05 <dons> but things like finiding line N quickly, finding the end of the line, inserting N chars in a line
18:45:05 <bd_> @hoogle fromRight
18:45:06 <lambdabot> No matches found
18:45:14 <dons> all have to be really fast (i was testing on 100M buffers)
18:45:16 <LoganCapaldo_> So *** is always some sort of pair eh
18:45:55 <Cale> (f *** g) takes pairs of values to pairs of values
18:46:08 <Cale> (f *** g) (x,y) = (f x, g y)
18:46:08 <sorear> dons: how did you test 100M of text without tripping over the unusable UI? or was it usable before JPB started hacking it?
18:46:21 <dons> sorear: before the jyp patches
18:46:29 <dons> i've not used yi since then
18:46:41 <dons> i.e. back when yi worked ;)
18:46:48 <LoganCapaldo_> So how does the specific arrow come in?
18:47:07 <sorear> dons: can I replace your massively tuned O(n) code with naive O(log n) code?  I've seen a concrete algorithm.
18:47:13 <Cale> oh, you can't apply it like that at all in another arrow
18:47:26 <dons> sorear: yes.
18:47:27 <Cale> only chain it with other arrow values using >>>
18:47:28 <dons> but check it in practice
18:47:45 <dons> i need a lot of convincing (i.e. numbers..) that things are ok
18:47:53 <LoganCapaldo_> So the arrow is (,) a b ?
18:47:59 <Cale> and then eventually it will be supplied with pairs somehow, but there might be extra machinery involved
18:48:05 <sorear> dons: Simon Tatham has written an editor, and claims to have used it on DVD images.  need to find numbers...
18:48:07 <Cale> The arrow in our case is (->)
18:48:15 <LoganCapaldo_> mmm
18:48:15 <Cale> i.e. a = (->)
18:48:17 <sorear> 8.4GB buffers
18:48:20 <dons> i'm not too surprised.
18:48:30 <dons> i got pretty far with O(n) stuff
18:48:33 <dons> and a naive buffer type
18:48:41 <dons> i've edited 1/2 gig buffers
18:48:53 <dons> well after emacs conked out, btw ;)
18:48:55 <LoganCapaldo_> So *** just always works on pairs, its not overloaded like >>> ?
18:49:00 <LoganCapaldo_> err >>=
18:49:03 <LoganCapaldo_> not >>>
18:49:10 <LoganCapaldo_> I don't even know what >>> is :)
18:49:11 <Cale> @type (***)
18:49:13 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:49:25 <Cale> It always works with pairs, but the arrow might be different.
18:49:42 <Cale> So it might not take functions as parameters, but other abstract function-like values.
18:49:54 <LoganCapaldo_> Ah
18:50:14 <LoganCapaldo_> ooooooo
18:50:40 <LoganCapaldo_> And the instance of Arrow has to implement a function that makes it "function like" if it itself is not a function
18:50:48 <Cale> (Arrow (~>)) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
18:50:56 <sm> allbery_b: if I import TildeExpand, when I run my main I get Loading package unix-1.0 ... linking ... <interactive>: /usr/local/lib/ghc-6.7/HSunix.o: unknown symbol `lstat' ; ghc-6.7: unable to load package `unix-1.0'
18:51:26 <Cale> LoganCapaldo_: yeah >>> becomes like "composition"
18:51:37 <allbery_b> that would be a problem with the ghc libraries, not with my code --- I don't even use lstat
18:51:47 <Cale> pure will turn an arbitrary pure function into an abstract arrow value
18:52:04 <Cale> @type first
18:52:06 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
18:52:21 <Cale> and first will produce an arrow that acts on the first part of pairs
18:52:23 * sm has 6.6 built from source as well as the 6.4 ubuntu package.. this is the first sign of trouble, oh well
18:52:42 <Cale> (and wires the second part straight through)
18:52:49 <LoganCapaldo_> > first (\x -> x + 1) (1, 2)
18:52:50 <lambdabot>  (2,2)
18:52:55 <Cale> you can see some nice example diagrams on the haskell arrows page
18:53:01 <dons> sm, sounds ok...
18:53:06 <dons> i have 4 or 5 ghcs sitting on my disk
18:53:08 <Cale> http://www.haskell.org/arrows/
18:53:09 <allbery_b> you evidently have 6.7 (aka ghc HEAD) built from source, given the path in that error messag
18:53:09 <lambdabot> Title: Arrows: A General Interface to Computation
18:53:12 <Cale> http://www.haskell.org/arrows/syntax.html
18:53:12 <dons> they all happily co-exist
18:53:14 <lambdabot> Title: Arrow syntax
18:53:28 <Cale> the arrow syntax page has some more complicated examples
18:53:32 <allbery_b> try it with 6.6 and/or 6.4 (I tested under 6.6 and 6.4.2)
18:53:42 <allbery_b> the latter on freebsd
18:54:29 <LoganCapaldo_> So arr is sort of like the >>= of arrows?
18:54:40 <Cale> It's more like the return of arrows
18:54:48 <sm> you're right.. I should roll back to standard 6.6
18:54:58 <Cale> It guarantees that pure functions/values bear some relation to the arrow.
18:55:03 <allbery_b> you should have a ghc-6.6 on disk
18:55:04 <sorear> dons: to a first approximation his algorithm is Data.Seq Char
18:55:08 <allbery_b> ghc-6.6 --interactive
18:55:14 <allbery_b> (same as ghci)
18:55:19 * mbishop still has a hard time with purely functional IO
18:55:32 <Cale> >>> is sort of the replacement for >>=
18:56:24 <LoganCapaldo_> I suspect this is too abstract for me as of yet :)
18:56:44 <LoganCapaldo_> hmm
18:56:44 <dons> sorear: makes sense. but be wary of perf issues
18:56:58 <Cale> But because both of its parameters are of the arrow type, unlike >>=, which has a function as one of its parameters, the "run" function for the arrow might be able to do more clever optimisation.
18:56:58 <dons> yi is meant to be damn fast.. really really fast
18:57:21 <LoganCapaldo_> Arrows turn functions into data?
18:57:21 <dons> sorear: you might have more fun porting the syntax highlighting code from curses to vty..
18:57:23 <Cale> Functions are essentially opaque, so run functions for monads can't do anything but evaluate the function and see what happens.
18:57:27 <dons> want the sketch?
18:57:44 <sorear> syntax hilighting code? it exists?
18:57:46 <Cale> basically -- they let you use other datatypes like you would (points-free) functions.
18:57:47 <LoganCapaldo_> s/functions/computations ?
18:57:58 <dons> sorear: yeah, does 1 line properly, and needs massaging to finish the job
18:58:01 <dons> let me find the code...
18:58:04 <LoganCapaldo_> interesting
18:59:00 <sorear> dons: really damn fast --> no way pure buffers will cut it?  that was my medium term goal, time to find another?
18:59:20 <dons> well, possibly Map LineKey ByteString would actually do it
18:59:29 <dons> but i'd work on syn hl first
18:59:35 <dons> since the buffer stuff just works, right?
18:59:46 <dons> if it ain't broke, don't fix it :)
18:59:59 <sorear> yeah, but it's ugly and quickcheck-proof
19:00:09 * dons sets up the yi+syntax repo for your perusal
19:00:16 <dons> now here, was the screenshot
19:00:43 <LoganCapaldo_> Cale, in some Arrow could &&& be parrallel such that f &&& g >>> arr f could execute f and g in parrllel and then feed the results in  the f computation that depends on all the results?
19:00:48 <sorear> ok.  now I need to understand a different part of yi!
19:00:58 <Cale> LoganCapaldo_: sure.
19:01:15 <sorear> dons: does your definition of syntax highlighting include automatic indentation?
19:01:24 <LoganCapaldo_> I'm just trying to think of ways of thinking about this so its not just funny looking functions :)
19:03:10 <hpaste>  allbery_b annotated "tildeExpand" with "slight optimization" at http://hpaste.org/156#1
19:03:35 <dons> sorear: ah here's the screeny, http://www.cse.unsw.edu.au/~dons/images/yi-color.png
19:03:47 <dons> and the repo is coming online now
19:03:55 <dons> it just uses ghc's lexer to tokenise each line the background
19:04:00 <dons> caching lines that are unchanged
19:04:12 <dons> and then uses the token stream to render colours in the Ui
19:04:23 <allbery_b> hrm.  it'd be kinda nice if the diff could be told to ignore whitespace
19:04:24 <dons> so it only re-colours lines that acctually change
19:04:47 <dons> yi + syntax working , and I'd ditch vim...
19:05:13 <dons> hpaste.org style. just needs syntax highlighting and away we go
19:05:28 <nornagon> hm, how do i get a list of values given f: [f 0, f . f $ 0, f . f . f $ 0, ...]
19:05:59 <dons> sorear: and the syntax repo, darcs get --partial http://www.cse.unsw.edu.au/~dons/code/yi+syntax
19:05:59 <lambdabot> Title: Index of /~dons/code/yi+syntax
19:06:05 <sorear> nornagon: iterate f 0
19:06:10 <sorear> > iterate (*2) 0
19:06:11 <dons> sorear: of interest, Syntax/Haskell.x and changes to UI.hs
19:06:12 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
19:06:13 <nornagon> :t iterate
19:06:15 <lambdabot> forall a. (a -> a) -> a -> [a]
19:06:19 <nornagon> cool.
19:06:23 <nornagon> thanks.
19:06:23 <sorear> Copying patch 453 of 582...
19:06:26 <dons> :)
19:06:32 <sorear> did I get too early?
19:06:34 <dons> it was a busy June back in 2004
19:06:45 <dons> nah, should be ready now
19:06:55 <dons> note that that's an old repo
19:07:01 <dons> so you'd want to merge the Syntax* stuff across
19:07:05 <dons> just use it for guidance and the api
19:07:16 <dons> super mega karma if you get this working...
19:07:24 <sorear> hehe
19:07:42 <dons> like an immediate +50 ;)
19:07:56 <sorear> so, you're saying curses-yi was a usable nvi replacement?
19:08:03 <dons> very much so
19:08:05 <sorear> ooh, #3
19:08:06 <allbery_b> @tell glGuy it might be nice to have an ignore-whitespace diff option (cf. http://hpaste.org/156/diff?old=0&new=1 )
19:08:07 <lambdabot> Consider it noted.
19:08:12 <allbery_b> crap
19:08:19 <dons> and curse yi + syn would be a very usable vim
19:08:21 <allbery_b> @tell glguy it might be nice to have an ignore-whitespace diff option (cf. http://hpaste.org/156/diff?old=0&new=1 )
19:08:21 <sorear> @tell allbery_b @tell is case sensitive
19:08:22 <lambdabot> Consider it noted.
19:08:22 <lambdabot> Consider it noted.
19:08:31 <allbery_b> hence the "'crap"
19:08:31 <dons> everything that i used was implemented , bah syntax
19:08:31 <lambdabot> allbery_b: You have 1 new message. '/msg lambdabot @messages' to read it.
19:08:39 <shapr> shazam!
19:08:54 <sorear> @help purge-messages
19:08:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:09:04 <dons> shapr: tell sorear how many karma points he'd get if he can get syntax highlighting working in yi
19:09:23 <shapr> sorear: Well, I'll give you 11 karma points...
19:09:42 <shapr> And then everyone who reads haskell-cafe will switch to Yi
19:09:44 <sorear> jyp had me tricked into believing yi was pre-alpha and half abandoned. :)
19:10:10 <dons> nah. it was in post-beta as a nvi
19:10:15 <shapr> I think it's just dormant.
19:10:18 <dons> in fact, a stable nvi in my opinion
19:10:24 <dons> jyp wanted emacs though
19:10:26 <dons> and it wasn't that
19:10:37 * sjanssen pledges 11 karma points for synhl in yi
19:10:45 <shapr> @karma
19:10:45 <lambdabot> You have a karma of 37
19:10:52 <sorear> @karma
19:10:52 <lambdabot> You have a karma of 18
19:11:00 <sorear> @karma-all
19:11:01 <lambdabot>  "dons"                116
19:11:01 <lambdabot>  "audreyt"              73
19:11:01 <lambdabot>  "fglock"               49
19:11:01 <lambdabot>  "glguy"                47
19:11:01 <lambdabot>  "lambdabot"            42
19:11:01 <shapr> sorear: I'll give you half of my karma points if you get synhl working in Yi
19:11:03 <lambdabot> [666 @more lines]
19:11:18 <sorear> > (div 37 2) + 11 + 50 + 18
19:11:19 <lambdabot>  97
19:11:21 * monochrom has liberated himself from libreadline4 after many hours of building ghc+extralibs XD
19:11:38 <sorear> monochrom: you coulda just used hexedit, like I did :)
19:11:44 <shapr> sorear: I'll give you ALL my karma points if you can get synhl working in such a way that any Parsec parser can be easily converted to do Yi synhl.
19:11:51 <monochrom> darn!
19:12:15 <sorear> monochrom: I changed *one byte* in the ghc6.4.2 binary, and it works now.
19:12:21 <monochrom> sorear++
19:12:28 <shapr> I'm tired of both emacs and vi. I want a Haskell editor written in Haskell.
19:12:41 <monochrom> I like emacs, vi, eclipse.
19:13:08 <monochrom> <troll>I am tired of writing everything in Haskell</troll>
19:13:15 <shapr> Not me!
19:13:19 <nornagon> mandelbrot c = iterate (f c) 0
19:13:19 <nornagon>   where
19:13:20 <nornagon>     f c z = z ^ 2 + c
19:13:26 <allbery_b> @monochrom -- :)
19:13:27 <lambdabot> Unknown command, try @list
19:13:29 <nornagon> ^- this seems way too elegant to be right.
19:14:12 <sorear> monochrom: 0xE0C iff you care
19:14:31 <Saizan> if only ecplipse didn't use all my ram..
19:15:00 <nornagon> sorear: haxxor
19:16:41 <sorear> dons: do you want a working yi+syntax, or a jyp-yi supporting highlighting?
19:16:43 <bd_> @pl f c z = z ^ 2 + c
19:16:44 <lambdabot> f = (. (^ 2)) . (+)
19:17:43 <dons> I think jyp-yi is the future
19:17:52 <dons> so get syn hl going in that, and get it back to being a vim replacement
19:17:52 <dons> ;)
19:18:14 <sorear> what's the emacs buffer menu command again?
19:18:30 <sorear> I thought it was C-x C-b, but that just says "Module: "
19:18:35 * sorear remembers C-h w
19:18:44 <allbery_b> normally it is C-xC-b
19:18:51 <dgriffi3> @where jyp-yi
19:18:52 <lambdabot> I know nothing about jyp-yi.
19:19:08 <sorear> oh, fun
19:19:48 <allbery_b> ...and it works here
19:21:30 <sorear> urk, killed #haskell, grr
19:21:42 <sorear> btw, my confusion: C-x C-b is rebound by shim
19:22:00 <allbery_b> ug, shouldn't it steal a prefix for itself?
19:22:35 <dons> ?where shim
19:22:35 <lambdabot> I know nothing about shim.
19:22:40 <dons> !!
19:22:50 <dons> all the ghc-api guys were talking about shim at the hackathon..
19:22:55 <dons> but i haven't seen any code :/
19:23:09 <sjanssen> where is jyp's yi repo?
19:23:15 <dons> its the main one
19:23:17 <dons> ?where yi
19:23:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
19:23:25 <dons> code/yi
19:23:25 <sorear> shim rocks, it automatically typechecked the yi as I hacked it to bits
19:23:34 <dons> url?
19:23:39 <dons> so we can @where+ ifiy
19:23:44 <dons> and who's running it?
19:23:48 <sorear> beschmi
19:24:16 <dons> ah right.
19:24:25 <sorear> lambdabot, what is the title of http://shim.beschmi.de/
19:24:43 <sorear> what are the Plugin.Url rules again?
19:24:44 <allbery_b> heh
19:24:52 <dons> @tell beschmi want to publicise shim a bit more?? :)
19:24:52 <lambdabot> Consider it noted.
19:26:19 <sjanssen> @where vty
19:26:19 <lambdabot> http://members.cox.net/stefanor/vty/
19:26:42 <sorear_> @bot
19:26:42 <lambdabot> :)
19:26:57 <sorear_> @localtime sorear
19:27:11 <sorear> @bot
19:27:11 <sorear> argh, lost MY net now
19:27:13 <lambdabot> :)
19:27:19 <lambdabot> Local time for sorear is Sat Jan 27 19:23:15 2007
19:27:22 <sorear_> finally I'm back
19:33:42 <sorear> there is @remember or HWN material in frederick ross's post...
19:34:31 <sorear> dons: where's the syntax code in yi+syntax?
19:34:46 <dons> in Syntax/Haskell.x
19:34:58 <dons> and elsewhere, been a while
19:35:17 <sorear> dons: I have no Syntax dir
19:38:19 * dons records
19:44:15 <dons> sorear: here's a tarball, too many unrecored things were lying around, www.cse.unsw.edu.au/~dons/tmp/yi+syntax.tgz
19:46:49 <sorear> ok.
19:47:29 <sorear> dons: 1. after :w, :q doesn't work.  2. "Setup.hs" "Setup.hs"C written
19:47:47 <sorear> these are in curses yi and vty yi
19:48:07 <sorear> what's going on with this polished nvi clone?
19:48:44 <sorear> I should probably use things more before concluding unfinishedness
19:49:30 <dons> you're not using the stable branch
19:49:35 <dons> you're using two unstable braches
19:49:55 <sorear> where do I find the stable branch?
19:50:05 <dons> roll back to later 2005 or so
19:50:15 <dons> in the jyp branch
19:50:25 <sorear> will try :)
19:50:25 <dons> before jyp started commiting stuff :)
19:55:20 * sorear goes to understand yi
20:09:55 <sorear> dons: I read the paper linked by @where yi, and I couldn't see anything specifically on tuned buffers - only a gross performance comparison.
20:11:54 <dancor> what does like Data.Map's code do to distinguish the ambiguous map?
20:12:03 <dancor> import qualified Prelude
20:12:04 <dancor> ?
20:12:25 <allbery_b> import Data.Map (Map); import qualified Data.Map as M
20:12:38 <allbery_b> (very common in my experience)
20:12:41 <dancor> no i mean the code for the Data.Map module
20:12:58 <sorear> @source Data.Map
20:13:05 <allbery_b> likely import Prelude hiding (map)
20:13:07 <sorear> @botsnack
20:13:10 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
20:13:10 <lambdabot> :)
20:13:20 <dancor> allbery_b: surely the module needs map at some point though
20:13:27 <sorear> import Prelude hiding (lookup,map,filter,foldr,foldl,null)
20:14:04 <sorear> import qualified Data.List as List
20:14:57 <sorear> List.map
20:15:20 <dancor> yeah i see now, 'Prelude.map' is still available
20:15:33 <dancor> hiding is not as hideful as you might think
20:23:34 <LoganCapaldo_> @hpaste
20:23:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:23:40 <LoganCapaldo_> @paste
20:23:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:26:35 <hpaste>  LoganCapaldo pasted "Thoughts, comments, criticism?" at http://hpaste.org/157
20:28:34 <allbery_b> @pl \xs -> let (user, path) = span (/= '/') in getUserEntryForName user >>= \pw -> return (homeDirectory pw ++ path)
20:28:35 <lambdabot> (line 1, column 12):
20:28:35 <lambdabot> unexpected "("
20:28:35 <lambdabot> expecting natural, identifier or "in"
20:28:39 <allbery_b> that's kinda lame...
20:32:06 <hpaste>  sorear annotated "Thoughts, comments, criticism?" with "using State" at http://hpaste.org/157#1
20:34:39 <LoganCapaldo_> @type random
20:34:40 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
20:35:06 <LoganCapaldo_> aha
20:35:10 <hpaste>  sorear annotated "Thoughts, comments, criticism?" with "using explicit binary tree" at http://hpaste.org/157#2
20:36:58 <LoganCapaldo_> sorear, I had this thought than it would be like Events [1/2, 1/4, 1/8, 1/16]
20:37:16 <LoganCapaldo_> But I think maybe my probability braincells are broken :)
20:39:44 <LoganCapaldo_> Flip (Event 1/2 (Flip (Event 1/4) (Flip (Event 1/8) (Event 1/16))))
20:39:54 <LoganCapaldo_> is actually right though, right?
20:56:32 <xpika2> @where continuations
20:56:33 <lambdabot> I know nothing about continuations.
20:56:47 <xpika2> @where contt
20:56:48 <lambdabot> I know nothing about contt.
21:01:17 <hpaste>  nornagon pasted "Profiling shows this allocates a lot. Why?" at http://hpaste.org/158
21:02:28 <sorear> nornagon: the first thing to do is add a type signature - might not help, might help a *lot*
21:02:53 <sorear> remember to use Double, Float is intrinsically slow and unoptimized to boot
21:02:58 <nornagon> *nod*
21:04:26 <nornagon> didn't really change much
21:04:50 <nornagon> is Complex slow?
21:05:29 <sorear> Complex Float is ... dunno about Complex Double
21:05:45 <nornagon> i'm using Double everywhere, so
21:08:24 <sorear> also, try replacing x ^ 2 with x * x
21:08:36 <sorear> shouldn't make a difference, but it did a week ago
21:08:49 <sorear> for someone's (glguy?) sieve
21:08:59 <nornagon> heh, okay
21:09:24 <nornagon> nah, didn't change a lot
21:09:44 <nornagon> or maybe it did
21:10:15 * sorear is reading Core now
21:10:21 <nornagon> a bit better, but still so much slower than it should be
21:12:50 <nornagon> still doing a lot of alloc
21:15:41 <nornagon> woah
21:16:10 <nornagon> improved it outta sight by changing realPart (abs val) > threshold to abs2 > threshold * threshold
21:16:16 <nornagon> where abs2 is im2 + re2
21:16:37 <nornagon> and im2 = imagPart val * imagPart val and re2 = realPart val * realPart val
21:17:15 <sorear> nornagon: can you paste the new code?
21:17:22 <nornagon> sure
21:17:28 <sorear> I've also managed to improve the Core
21:17:38 <sorear> with a strictness trick
21:17:41 <hpaste>  nornagon annotated "Profiling shows this allocates a lot. Why?" with "new code" at http://hpaste.org/158#1
21:18:17 <nornagon> it's still nowhere near fast enough that i could use it in a zoomer though :P
21:18:25 <sorear> hehe.
21:19:00 <sorear> I'm also using this to hone my core skillz
21:19:05 <nornagon> :)
21:21:01 <hpaste>  sorear annotated "Profiling shows this allocates a lot. Why?" with "tidier core; faster?" at http://hpaste.org/158#2
21:21:13 <sorear> MUCH tidier, MUCH stricter
21:21:45 <bd_> sorear: can one just use a bang pattern in the function's arguments directly?
21:21:55 <bd_> rather than that z0 `seq` ... thing
21:22:18 <sorear> bd_: I tried bangs first, got a parse error :(
21:22:23 <bd_> ah :/
21:22:28 <nornagon> hm, alloc% is smaller now
21:22:29 <bd_> sounds like a bug ... ?
21:22:37 <nornagon> mandel'                        Main                  85.3   89.5
21:22:39 <sorear> probably just a precedence thing
21:22:50 <sorear> nornagon: is it faster?
21:23:01 * sorear looks at cmm
21:23:07 <nornagon> yes
21:23:24 <sorear> woah!
21:23:30 <nornagon> still not fast enough for a zoomer though!
21:23:36 <sorear> the -ddump-stg output is really indented
21:24:10 <nornagon> ./mandelbrot  14.23s user 0.06s system 98% cpu 14.455 total
21:24:20 <nornagon> ^- for a 200*200px image
21:24:23 <jdrake> Does anyone know what software is used for this blog? http://www.cs.uu.nl/~stefan/blog/index.html
21:24:34 <nornagon> pancito is pretty slow, but it's not the bottleneck here
21:24:35 <lambdabot> Title: Personal Web Pages of Stefan Holdermans: Weblog
21:28:14 <xpika2> @where OSX
21:28:18 <lambdabot> I know nothing about osx.
21:28:20 <sorear> standard voodoo options: -O2 -fvia-C -optC-O3  -- results?
21:28:37 <sorear> the new mandle' I gave you does *no allocation at all*
21:28:55 <sorear> at least -ddump-asm contains no allocation instructions
21:29:26 <nornagon> ghc-6.6: unrecognised flags: -optC-O3
21:29:27 <dons> why are you using bang patterns *and* seq/
21:29:51 <nornagon> lower case c worked
21:29:51 <dons> also, Complex is strict in its fields, iirc
21:30:01 <dons> data (RealFloat a) => Complex a
21:30:02 <dons>   = !a :+ !a
21:30:09 <dons> so those extra seqs shouldn't be needed
21:30:18 <sorear> dons: they are.
21:30:21 <nornagon> using that voodoo seemed to help
21:30:27 <sorear> dons: I looked at -ddump-simpl
21:30:29 <dons> weird...
21:30:40 <dons> sorear: and the bang patterns on the inner fields don't help
21:30:42 <sorear> dons: w/o the seqs, there were 2 wrapper layers over the worker
21:30:54 <sorear> dons: w/ the seqs, there were 1 wrapper layers over the worker
21:30:56 <dons> val@(!z2 :+ !z3)
21:31:01 <dons> sorear: oh, -ddump-strict-fields
21:31:15 <sorear> dons: that doesn't parse!
21:31:19 <nornagon> ./mandelbrot  8.66s user 0.04s system 98% cpu 8.793 total
21:31:21 <sorear> dons: I tried it
21:31:26 <dons> to unbox the Complex
21:31:27 <dons> (!z2)
21:31:30 <nornagon> ^- with the -fvia-C goop
21:31:30 <sorear> dons: that's why I'm using seq
21:31:44 <sorear> nicer
21:31:57 <sorear> of course, not fast enough, right? :p
21:32:00 <nornagon> yep!
21:32:03 <dons> ((!a) :+ (!b)) is ok
21:32:16 <sorear> dons: it looks very pretty seeing a loop w/o allocations
21:32:20 <dons> but i'd be interested to see if -ddump-strict-fields without the extra seqs has the same effect
21:32:33 <dons> yeah, that's what you want
21:32:42 <sorear> -ddump-* shouldn't have side effects, should it?
21:32:46 <dons> nope
21:33:01 <sorear> ghc-6.7: unrecognised flags: -ddump-strict-fields
21:33:13 <dons> -funbox-strict-fields
21:33:13 <nornagon> mandel'                        Main                  87.0   81.2
21:33:14 <dons> sorry
21:33:16 <sorear> 6.6 and 6.4.2 complain too
21:33:26 <nornagon> ^- still allocing 81.2%... what's that about?
21:33:32 <sorear> dons: oh good. -d* as optimization was just too wierd :)
21:33:48 <sorear> nornagon: might be the wrapper
21:34:13 <sorear> nornagon: also make maxIter a constant, hs-plugins will let you still change it at runtime
21:34:24 <nornagon> zany, okay
21:34:26 <sorear> how much does fixing maxIter help?
21:34:37 <dons> add -fexcess-precision
21:34:39 * sorear <3 dynamic code generation
21:35:01 * sorear <3 strongly typed self-modifying code
21:35:31 <sorear> self modifying code rocks.
21:36:07 <nornagon> how do i make it constant?
21:36:11 <LoganCapaldo> self-modyfing rocks code!
21:36:58 <nornagon> i made it not a parameter (instead i just put a maxIter = 1000 next to threshold = 2)
21:37:07 <nornagon> that seems to have made the performance go down, oddly enough
21:37:08 <sorear> nornagon: that's right
21:37:11 <sorear> !?
21:37:19 <nornagon> wait
21:37:24 <nornagon> was still compiling with -prof...
21:38:07 <nornagon> ./mandelbrot  7.82s user 0.04s system 98% cpu 7.948 total
21:38:18 <nornagon> so ~0.8s
21:38:31 <sorear> every s counts :)
21:38:36 <nornagon> mhm :)
21:38:42 <sorear> how long does compilation take?
21:39:17 <nornagon> of just mandelbrot.hs or with all the pancito stuff?
21:39:40 <nornagon> ghc --make -O2 -fvia-C -optc-O3 -o mandelbrot mandelbrot.hs  0.94s user 0.10s system 98% cpu 1.065 total
21:39:44 <nornagon> ^- just mandelbrot.hs
21:39:48 <nornagon> ghc --make -O2 -fvia-C -optc-O3 -o mandelbrot mandelbrot.hs  14.85s user 0.42s system 97% cpu 15.703 total
21:39:53 <nornagon> ^- with pancito
21:41:11 <sorear> the core sure looks tidyer now
21:41:12 <sorear> just mandelbrot.hs
21:41:12 <sorear> and whatever loop you are driving it with
21:41:12 <sorear> also use high level optimization on the driver loop, if you weren't already
21:41:12 <sorear> I imagine the cost of runtime compilation will be offset by the benefits of 0.8 * 100x larger pretty picture
21:41:20 <hpaste>  dons annotated "Profiling shows this allocates a lot. Why?" with "unbox those strict fields" at http://hpaste.org/158#3
21:42:10 <dons> that code is as good as you'd want
21:43:09 <sorear> dons: no
21:43:20 <sorear>              case ww_X142 of ww3_X14s { GHC.Float.D# ww4_a12g ->
21:43:35 <sorear> see that case? it's forcing a thunk in the inner loop
21:44:12 * sorear hopes he's not talking nonsense
21:44:39 <nornagon> incidentally, when i try that with the crazy c@(z1:+z2) stuff, it's slower than when i leave off the @
21:45:08 <sorear> nornagon: try dons', or try mine?
21:45:28 <sorear> nornagon: what is sped by leaving off seq-strictness?
21:45:50 <nornagon> but with sorear's:
21:45:51 <nornagon> ./mandelbrot  6.15s user 0.03s system 99% cpu 6.243 total
21:45:57 <nornagon> that's with the seqs
21:46:20 <nornagon> ./mandelbrot  7.78s user 0.04s system 98% cpu 7.966 total
21:46:24 <nornagon> and without
21:46:25 <sorear> nornagon: I'm about to paste another ... looking at stg/cmm now
21:46:48 <nornagon> man, #haskell is awesome
21:47:14 <nornagon> how many languages are there where you can ask a question and get a response from a compiler hacker.
21:47:17 <nornagon> sorear++
21:47:52 <sorear> nornagon: I am a *wannabe* compiler hacker. just learning for now.
21:48:00 <nornagon> :P
21:48:36 <hpaste>  sorear annotated "Profiling shows this allocates a lot. Why?" with "this gives much nicer cmm - better yet? (note different type)" at http://hpaste.org/158#4
21:49:02 <sorear> manual lifting
21:49:19 <sorear> and more elegant to boot
21:49:36 <sorear> imo, anyway
21:50:15 <sorear> nornagon: just for fun ... 6.15s now, what was it same parameters with the initial paste?
21:50:29 <nornagon> ./mandelbrot  6.08s user 0.03s system 98% cpu 6.195 total
21:50:36 <sorear> aw
21:50:49 <nornagon> sec, i'll check
21:51:49 * nornagon waits, waits, waits.
21:53:28 <sorear> mathematicians know more about the mandlebrot set then compilers do - this can be taken advantage of, maybe.
21:53:51 <nornagon> more like mathemagicians :(
21:54:31 <nornagon> ./mandelbrot  154.97s user 0.83s system 97% cpu 2:39.21 total
21:54:32 <nornagon> :D
21:54:46 <allbery_b> um
21:54:46 <sorear> > 154.97 / 6.08
21:54:48 <lambdabot>  25.488486842105264
21:54:54 <sorear> 25.5x faster!
21:55:13 <nornagon> (almost)
21:55:21 <allbery_b> er, that first number is not wallclck time, the last one is
21:55:51 <sorear> gah.
21:56:27 <allbery_b> admittedly when working with pure code there shouldn't be an enormous difference
21:56:50 <allbery_b> (pure code shouldnb't be making syscalls)
21:56:57 <nornagon> 0.83 system there
21:57:03 <nornagon> so it's not really relevant
21:57:38 <hpaste>  sorear annotated "Profiling shows this allocates a lot. Why?" with "use special knowledge to {opt,pess}imize; measumement required!" at http://hpaste.org/158#5
21:57:51 <dons> sorear: ah yes, those Doubles aren't unboxed in my code. interesting
21:58:09 <dons> nornagon: does -fexcess-precision help ?
21:58:32 <sorear> nornagon: because an escaped point stays escaped, we can be more aggressive with unrolling then GHC can.
21:58:39 <nornagon> ./mandelbrot  5.31s user 0.04s system 98% cpu 5.425 total
21:58:41 <nornagon> dons: yes
21:58:50 * nornagon tries sorear's new thingy now
21:58:52 <sorear> nornagon: that was with the #5
21:58:53 <sorear> ?
21:59:02 <nornagon> no
22:00:01 <sorear> the downside is #5 does more work then neccessary, on average half an iteration.  but it does more work faster, so it could go either way.
22:00:18 <nornagon> ./mandelbrot  4.67s user 0.03s system 98% cpu 4.754 total
22:00:24 <sorear> *gape*
22:00:25 <nornagon> ^- with #5
22:00:54 <dons> now, do you want to compare this against the shootout mandlebrot entry
22:00:55 <dons> ...
22:00:58 <sorear> > 159.21 / 4.754
22:01:00 <lambdabot>  33.48969289019773
22:01:11 <sorear> and that wasn't even a haskell specific optimization!
22:01:56 <sorear> there's a shootout mandlebrot ? will check.
22:01:58 <nornagon> what's the shootout mandelbrot like, time-wise?
22:02:10 <dons> i see more allocs though, in that code
22:02:16 <dons> there's some 'lets' creeping in/
22:02:45 <sorear> nornagon: 200x200 mandlebrot rendering
22:02:55 <dons> + IO
22:03:00 <sorear> ?
22:03:01 <dons> it should fill a bytestring though
22:03:07 <sorear> oh
22:03:10 <sorear> hello!
22:03:26 <nornagon> sorear: how fast is the shootout one?
22:03:35 <sorear>    25    Haskell GHC #2          76.36           1,832         445
22:03:43 <sorear> 76 seconds to render 200x200
22:03:46 <sorear> not bad, eh?
22:03:47 <nornagon> woah.
22:03:51 <dons> hmm. that's not the right one.
22:04:00 <dons> it was down to 17secs, unless they changed the value of N
22:04:17 <nornagon> 4.8 secs is still loads better
22:04:25 <nornagon> how fast is the C implementation?
22:04:38 <sorear> C is 3.14s, Clean is 4.9s
22:04:50 <nornagon> nice
22:04:54 <sorear> Haskell can do numerics as fast as clean!?
22:05:08 <nornagon> and nearly as fast as C!
22:05:08 <dons> hmm. so something broke in that code. we were around 7x
22:05:19 <sorear> ruby is 1978s btw :)
22:05:22 <nornagon> lol.
22:05:26 <dons> nornagon: ibut you're not implementing the same program as the shootout right?
22:05:32 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=all
22:05:34 <nornagon> probably not
22:05:35 <sorear> not exactly
22:05:35 <lambdabot> Title: mandelbrot benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Langua ..., http://tinyurl.com/q8e4f
22:05:45 <dons> however, you could probably submit a version of this modified
22:05:53 <nornagon> yeah
22:06:05 <dons> and look at what Clean does
22:06:07 <sorear> ours is almost the same
22:06:20 <sorear> we just need to add a ByteString PBM writer
22:06:21 <dons> strict output though
22:06:35 <sorear> then we'd be at 2.0x or so
22:06:39 <dons> yeah
22:06:39 <dons> note the Clean program uses a custom lib :(
22:06:46 <dons> import StdEnv,LanguageShootout
22:06:51 <dons> :((
22:06:55 <nornagon> :(
22:07:05 <nornagon> that totally ruins the point of shootout :(
22:07:14 <dons> not sure what it provides though
22:07:17 <dons> probably fast IO?
22:07:27 <dons> or reexports some common modules?
22:07:34 <dons> ah well.
22:07:38 <dons> that's the way of the shootout
22:07:44 <sorear> I should start my own shootout. it'll be like the ICFP, with a time limit and all that fun stuff.
22:07:59 <sorear> == no use of libs that postdate the contest!
22:08:03 <dons> hehe. nornagon, sorear you should polish up this code and port it to the shootout entry
22:08:08 <dons> submit it and get famous :)
22:08:12 <dons> ?wiki Shootout
22:08:12 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
22:08:21 <dons> ^^ other examples to benchmark against
22:08:50 <sorear> dons: ours plays slightly fast&loose with the algorithm, making it faster at the expense of bit-perfection
22:08:55 <allbery_b> just implement a shootout whose rules don't require you to code every language like it's C?
22:09:01 <sorear> specifically we lose the last bit of the iteration count.
22:09:28 <nornagon> allbery_b: not possible
22:09:29 <sorear> my shootout will be "implement this function". all I care is you don't use the FFI except via libs like ByteString
22:09:31 <nornagon> really
22:09:41 <nornagon> C is the closest approximation of how computers work
22:09:41 <dgriffi3> @where vty
22:09:42 <lambdabot> http://members.cox.net/stefanor/vty/
22:09:45 <nornagon> except assembly
22:09:46 <sorear> wow
22:09:49 <nornagon> obviously
22:10:02 <sorear> I can't believe how many people have come running @where vty
22:10:14 <sorear> dgriffi3, etc: I should start exit polling :)
22:10:26 <nornagon> exit polling?
22:10:30 <nornagon> i should try vty sometime
22:10:43 <allbery_b> sorear: you underestimate the degree to which curses sucks? :)
22:10:44 <sorear> seriously, *major* shock to have my library become massively popular overnight
22:10:58 <nornagon> :)
22:11:22 <nornagon> that reminds me, i should release a new version of world of sand ds
22:11:36 <sorear> nornagon: US political concept.  People stand outside the polls and ask how people voted.  It's illegal to ask before the voters vote, iirc, so they do it on exit - hence exit polls.
22:11:46 <nornagon> ah, heh
22:12:04 <allbery_b> nornagon: no excuse for disqualifying an entry because it lazily didn't compute something irrelevant to the output...
22:12:07 <sorear> <--- is 16, voting age is 18, near 0 first hand experience
22:12:23 <nornagon> yeah, i'm 17
22:12:44 <nornagon> i'm still impressed by how much haskell-fu you have
22:12:50 <nornagon> when did you start?
22:12:59 <sorear> allbery_b: My problems will *just* be implement-this-function ...
22:13:13 <sorear> nornagon: I'm not sure, less than a year ago I think
22:13:24 <sorear> nornagon: I actually came from unlambda
22:13:25 <dgriffi3> sorear: I was just reading the Yi stuff and saw the note about switching to vty, thus I wanted to take another look at it
22:13:29 <nornagon> sorear: heh
22:13:35 * allbery_b has never been exit polled --- not that he's ever lived anywhere anyone cares about (polling locations at least)
22:13:48 * base_16 has never been exit polled either
22:13:51 <sorear> dgriffi3: oh, so it's all jyp's fault, thanks :)
22:16:44 <Daveman> Say I have a let elimination, 5 cases just walk the tree, and the only Let case converts (logically), however, having to write those 5 cases that just walk is foolish, is there a better recommended method by which everywhere there's an appropriate slot, recurse this function down?
22:17:12 <sorear> many
22:17:19 <allbery_b> Data.Generics?
22:17:35 <sorear> Play & SYB were both created for this purpose
22:17:38 <sorear> fat niche
22:17:47 <Daveman> ooh
22:18:27 <newsham> so maybe most programming languages make bad programming easy but good programming hard, and haskell just removes most of the opportunities for writing bad code, revealing how hard programming really is?
22:18:33 <Daveman> thanks sorear :)
22:18:47 <sorear> yep :)
22:19:28 <sorear> newsham: I only did a 2x unroll - you should try a 3x unroll.  will probably hurt, but you never know...
22:19:49 <newsham> sorear: sorry, i missed the context.  what are we rolling?
22:19:56 <dibblego> newsham, I think you're spot on there
22:21:00 <sorear> newsham: s/newsham/nornagon/ :)
22:21:04 * allbery_b thinks it just makes writing bad code as hard as writing good code, while forcing you to think about what your'e doing so you're more likely to write good code
22:21:09 <nornagon> sorear: how come Test.hs in vty rel-1.0 spits out keycodes at the bottom when the @ hits the bottom/right?
22:22:41 <sorear> nornagon: it's a testing feature, I think
22:23:02 <nornagon> sorear: i can't see where you actually use val'' in the function
22:23:32 <sorear> the recursive call
22:23:41 <sorear> mandle'' (curIter++) val''
22:24:20 <nornagon> oh, right
22:24:28 <nornagon> for some reason i only had one'
22:24:28 <nornagon> one '
22:24:36 <nornagon> which is weird, because i copy/pasted
22:24:37 <nornagon> :/
22:24:46 <sorear> nornagon: that's Bad
22:24:58 <sorear> nornagon: that will cause the program to give the wrong results
22:25:09 <nornagon> hm, crazy
22:25:12 <sorear> nornagon: try again - is 2x unroll still better than 1x ?
22:26:30 <nornagon> ./mandelbrot  3.68s user 0.03s system 96% cpu 3.853 total
22:26:35 <nornagon> ^- 1x unroll
22:26:40 <nornagon> oh, wait, that's with maxIter = 500
22:27:11 <nornagon> ./mandelbrot  6.05s user 0.02s system 98% cpu 6.148 total
22:27:16 <nornagon> ^- with 1000
22:27:24 <nornagon> i'll try a 3x unroll
22:27:36 <sorear> nornagon: what's 2x look like?
22:27:53 <sorear> correct 2x, with maxIter = 500 and val'' in the recursive call
22:28:04 <nornagon> ./mandelbrot  4.70s user 0.04s system 96% cpu 4.899 total
22:28:45 <nornagon> ./mandelbrot  4.21s user 0.04s system 98% cpu 4.294 total
22:28:49 <nornagon> ^- 3x unroll
22:28:52 * nornagon tries 4x
22:29:12 <sorear> confirming they all give similar output?
22:29:18 <nornagon> yeah
22:29:36 <nornagon> okay, 4x was a regression
22:29:39 <sorear> not bit-identical of course, increasing unroll loses precision
22:29:54 <nornagon> oops
22:30:01 <nornagon> maybe not, forgot to change maxIter
22:30:41 <nornagon> okay, it's a regression anyway
22:30:42 <nornagon> ./mandelbrot  4.39s user 0.02s system 98% cpu 4.463 total
22:31:15 <sorear> oh well
22:31:44 <sorear> anyway this ought to be highly sensitive to icache sizes and decode pipeline lengths
22:32:04 <dons> now, i'm almost certain you should send in the different versions of this program to ghc's list
22:32:11 <dons> at least some of these things ghc should be doing
22:32:32 <nornagon> :)
22:32:48 <sorear> @. read run show (15921 / 4.463) ++ "% total improvement"
22:32:49 * allbery_b would be curious to find out why complex's already-supposedly-strict fields needed to be seq'd
22:32:50 <lambdabot>  3567.331391440735% total improvement
22:33:09 <sorear> how's THAT!
22:33:23 <nornagon> :)
22:33:51 <sorear> dons: and just LOOK at the clean code ... they aren't even using lib complexes it seems!
22:36:40 <sorear> nornagon: well, that was a fun 75 minutes :)
22:36:53 <nornagon> :D
22:36:55 <sorear> Haskell: 3500% in 75 minute
22:36:56 <sorear> Haskell: 3500% in 75 minutes
22:37:06 <nornagon> 0 to 3500% in 75 minutes!
22:38:09 <sorear> nornagon: what parameters are you using? (rgn coords)
22:38:44 <sorear> It'll be REALLY fun when Jhc gets inducted
22:39:11 <nornagon> rgn?
22:39:17 <sorear> eio
22:39:35 <sorear>  e io
22:39:43 <sorear> r g  n
22:39:52 <nornagon> um.
22:40:46 <dons> so can one of you guys summarise what you did in each step, including core, and send it off to glasgow-haskell-users@
22:40:56 <dons> the strict fields needing seq seems to be something a bit fishy
22:40:59 <nornagon> sorear knows better than i
22:41:06 <dons> and some of the unrolling could be done better?
22:41:10 <sorear> dons: no
22:41:26 <dons> but the ghc guys (aka SimonM) want to at least know what ghc is doing to the code
22:41:44 <sorear> dons: the unrolling is a mandlebrot-specific hack - doing what I did in the general case for the last 20% would be a miscompilation
22:41:49 <dons> ok.
22:42:06 <allbery_b> but the stuff before that seems like they should know about
22:42:13 <dons> right
22:42:22 <dons> the seq/unbox-strict-field sstuff
22:42:32 <dons> shouldn't lead to that D# not being unboxed, afaik
22:42:41 <sorear> but the strictness could be improved, and the loop strength reduction (?, removing constants) doesn't work well
22:43:04 * sorear feels a little more like a compiler hacker now
22:43:22 <dons> sorear: so can you send in a mail showing the 4 or 5 examples, their core worker loop, and whta changed at each point?
22:43:29 <dons> with any suggestions of things that didn't quite work
22:43:43 <dons> while its still fresh
22:44:07 <sorear> ok
22:44:15 <dons> duncan and simon were looking at this kind of stuff a couple of days ago in cambrdige
22:44:18 <dons> so the timing is good
22:44:40 * dons lesson: never underestimate the social aspects of getting software fixed
22:45:16 <sorear> nornagon: what peice of the set are you rendering? (-1,1) x (-i,i) ?
22:45:42 <nornagon> yeah
22:46:02 <sorear> that specific piece ?!
22:46:27 <nornagon> um
22:46:29 <nornagon> i guess so
22:47:05 <nornagon> http://2-2-dihexanol.net/mandelbrot.png
22:47:56 <sorear> looks right
22:51:37 <nornagon> what's haskell for tan^-1?
22:52:03 <allbery_b> atan or atan2?
22:52:19 <bd_> :t (atan, atan2)
22:52:21 <lambdabot> forall a a1. (Floating a, RealFloat a1) => (a -> a, a1 -> a1 -> a1)
22:52:30 <bd_> :src atan2
22:52:36 <bd_> ?src atan2
22:52:41 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:52:57 <dons> tricky instances for different types, of course
22:53:15 <bd_> ... point :)
22:53:26 <sorear> nornagon, dons: CC ?
22:53:32 <nornagon> sure :)
22:54:12 <dons> go for it
22:54:18 <bd_> dons: "A default definition of atan2 is provided, but implementors can provide a more accurate implementation." :)
22:54:25 <dons> heh
22:54:31 <dons> how considerate
22:54:59 <sorear> gah.  emacs thinks #haskell *is* a logfile.
22:55:23 <sorear> fixed, at cost
22:55:24 <hpaste>  dons pasted "atan2 default" at http://hpaste.org/159
22:55:27 * allbery_b wonders if anyone ever takes the default given that atan2 is usually available as a primitive
22:55:51 <dons>       | y == 0 && (x < 0 || isNegativeZero x)
22:55:53 <dons>                           =  pi
22:56:08 <bd_> hm, I guess that's a bit long for @src...
22:56:19 <dons> my knowledge of trig is waning, I didn't expect that pi to pop up there :}
22:56:53 <dons> i wonder if we have pi to enough places by default for this kind of thing
22:56:55 <dons> > pi
22:56:56 <lambdabot>  3.141592653589793
22:57:38 <bd_> > atan2 1.0 3.0
22:57:39 <lambdabot>  0.3217505543966422
22:58:41 <Daveman> haha, sorry sorear, I just can't help me jest at your exclamation before departing just a few minutes ago :)
22:58:58 <Daveman> nevertheless, thanks for the pointer before, it was exactly what I needed! :D
23:00:06 <sorear> nornagon: nickserv won't tell me your email address; lj and rubyforge agree it is @gmail.com. same nornagon?
23:01:14 <bd_> sorear: yeah, nornagon @ gmail.com is nornagon here
23:01:28 <sorear> google++
23:01:36 <nornagon> sorear: yeah
23:02:01 * nornagon wonders about a nice coloring scheme
23:02:08 <nornagon> apparently there's some 'distance estimator' thing
23:02:19 <nornagon> that estimates distance between any point and the nearest point of the mandelbrot set
23:15:16 <jyp> Note for the brave souls: yi now has a gtk frontend.
23:15:32 <Nafai> Awesome
23:15:33 <sorear> I noticed :/
23:15:44 <jyp> vty is still the default :)
23:16:00 <Nafai> sorear: Why the :/ ?
23:16:36 <sorear> Nafai: I tried it earlier, weird issues foo.
23:16:55 <sorear> "/tmp/yi.EuofjN2677" "/tmp/yi.EuofjN2677"C written
23:17:04 <sorear> jyp: ^^^ any clue?
23:17:25 <sorear> that was a large part of what fooled me into thinking yi was pre-pre-alpha :)
23:18:18 <jyp> sorear: can you describe the problems in a bit more words?
23:18:36 <sorear> jyp: start yi, :w
23:18:48 <sorear> it displays the filename twice
23:19:13 <jyp> ah.
23:19:28 <jyp> I can have a look
23:19:42 <sorear> actually it happens any time I try to save
23:20:04 <jyp> k
23:20:31 <sorear> oh and I've been promised brownie points galore if I can get syntax highlighting working in yi ... so expect more patches with my name :)
23:20:41 <sorear> s/brownie/karma/
23:20:50 <sorear> that was an odd slip...
23:20:56 <jyp> :)
23:20:59 <allbery_b> heh
23:21:33 <jyp> sorear: here the explanation...
23:21:45 <jyp> msgE $ show f ++" "++show s ++ "C written"
23:21:54 <nornagon> what's the foo to get command-line args again?
23:22:00 <jyp> I never use vi nor vim myself
23:22:13 <jyp> so I don't know what it should do really
23:22:18 <dons> jyp, you breaking vim mode on me ? :)
23:22:20 <allbery_b> ?hoogle getArgs
23:22:21 <lambdabot> System.getArgs :: IO [String]
23:22:34 <nornagon> oh, import System
23:22:41 <jyp> dons: I don't think I've touched any of this actually
23:22:48 <dons> jyp++ keeping yi kicking along
23:22:55 <sorear> yi/emacs is even less usable than yi/vi ... the nongraphics are more annoying
23:22:59 <jyp> thanks ;)
23:23:31 <allbery_b> System.Environment is actually where it comes form I think
23:23:36 <jyp> sorear: that is the main reason for the gtk frontend
23:23:38 <sorear> jyp: also vim mode is broken in that randomly it will pick a point, and distractingly highlight everything between that point and the point
23:23:59 <sorear> jyp: oh, so vty will be made obsolete/unsupported?
23:24:09 <jyp> sorear: not at all
23:24:25 <sorear> jyp: I'm warning you - serious text console persecution complex here :)
23:24:28 <jyp> I expect the vty lib to support the non-graphics better ;)
23:24:48 <jyp> some time
23:24:55 <sorear> I mean like TAB ... seriously confuses yi
23:25:53 <base_16> hmmm
23:25:54 <base_16> make[2]: *** No rule to make target `depend', needed by `libHSplugins.a'.  Stop.
23:28:29 <jyp> sorear: you should use --as=emacs2
23:28:41 <sorear> emacs2 ?
23:28:49 <jyp> plain emacs is not maintained and largely obsoleted
23:28:52 <sorear> what's wrong with emacs 1?  or emacs 22 ?
23:28:54 <dons> jyp, feel free to make emacs2/jyp mode the default emacs mode
23:28:59 <dons> and ditch the old mode
23:29:09 <jyp> I think that's what I'll do
23:29:24 <sorear> I also really want to rewrite the buffer system...
23:29:35 <sorear> Ptr CChar just grates on my eyeballs
23:29:40 <dons> sorear: why?
23:29:42 <jyp> I will also remove the vimacs mode... which is now a mere copy of the emacs2 mode, with a different filler character
23:29:47 <dons> tht's not a good reason though :)
23:30:05 <sorear> too much potential for error
23:30:06 <dons> its hard low level code. and it works.
23:30:21 <sorear> but, yes, postponed until I have nothing better to do.
23:30:27 <dons> ok phew :)
23:30:36 <dons> syntax highlighting first ! :)
23:31:14 <sorear> yes!
23:31:21 <sorear> actualy understanding first
23:31:39 <sorear> right now I know enough to replace the buffer subsystem, and that's it
23:32:03 <sorear> someday I'll know yi as well as I know lambdabot
23:33:11 <dibblego> when I asked a Java Blub how to write a linked list with length that runs in less than O(n) space, I was told 'ArrayList'
23:33:14 * dibblego shakes head
23:35:32 <dons> sorear: did you get the core/mandel stuff written?
23:35:40 <dons> it could be reasonably immportant
23:35:44 <sorear> dons: working on it...
23:35:50 <dons> yay!
23:35:58 <sorear> new experience :(
23:36:19 <nornagon> gah
23:36:37 <nornagon> i hate it when i accidentally pull out my power when my battery isn't in :(
23:37:23 <bos_> wow, are people still hacking on yi?
23:37:32 <sorear> my computer is very solidly built, and is protected from such events by its sheer bulk
23:37:36 <sorear> bos_: yes
23:37:48 <nornagon> sorear: i pulled out the power on purpose
23:37:56 <nornagon> but forgot i had taken the battery out
23:38:00 <bos> sorear: with any particular goal in mind?
23:38:10 <sorear> bos: obsolete emacs
23:38:38 <nornagon> yi seems to suggest vi clone
23:38:47 <sorear> right now, I regularly use linux+bash+ghc+emacs+mutt+links ;
23:39:08 <sorear> by 2008 I hope to be using linux+ghc+emacs ;
23:39:11 * nornagon uses debian+zsh+ghc+vim+iceweasel
23:39:22 <sorear> by 2009 I hope to be using ghc+yi
23:39:34 <nornagon> where'd the bash go?
23:39:44 <sorear> nornagon: chsh /usr/bin/ghci
23:39:57 <nornagon> that sounds like it'd be horribly unusable
23:40:23 <nornagon> how many characters do you have to type to execute something?
23:40:25 <sorear> I dunno ; half my command lines have ghc -e 'interact $ foo'  -- super sed
23:40:46 <sorear> nornagon: let e = blahblahblah  ... e "emacs"
23:40:53 <sorear> :! emacs
23:41:07 <nornagon> you lose a bunch of nice shell features
23:41:13 <nornagon> expansion, for example
23:41:15 <sorear> like what?
23:41:21 <sorear> ghci has that
23:41:22 <nornagon> unless you work a bunch to make e do it
23:41:51 <sorear> hmm. sounds like a good project for 2007
23:41:55 <nornagon> also, where did your OS go? :)
23:42:23 <sorear> nornagon: the GHC RTS has been ported to PC system level
23:42:59 <nornagon> RTS?
23:44:42 <dons> ?where House
23:44:42 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:44:48 <dons> nornagon: that's one ^^
23:44:54 <dons> there's a couple of others
23:45:46 <nornagon> are they actually usable yet?
23:48:05 <dons> as what? linux? no.
23:48:14 <dons> but they exist, you can download and run them on your thinkpad or whatever
23:48:47 <dons> didn't patrykz talk about the haskell kernel the nicta guys have?
