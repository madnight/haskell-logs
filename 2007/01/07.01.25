00:00:11 <monochrom> In c++ or java, if you have two objects of the same interface but different types otherwise, you can put them into the same array.  In haskell you can't, unless you use an existential type; but then there is no downcasting.
00:00:15 <dancor> the last thing i expect after trying to get lots of unix stuff to build on os x if out of the boxery
00:00:21 <earthy> and with good reason: good systems have had excellent discoverability ever since the structured documentation movement of early seventies
00:00:22 <dancor> s/if/is
00:01:12 <dancor> i guess that would be out-of-the-tar
00:01:13 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package.cgi?name=hpaste&version=0.3
00:01:16 <dons> glguy: ^^
00:01:23 <earthy> http://portal.acm.org/citation.cfm?id=987262 ;)
00:01:26 <lambdabot> Title: Structured documentation
00:01:31 <astrolabe> dancor: like an interface is an ok analogy for typeclasses, but there are important differences
00:01:44 <glguy> dons: thanks :-D
00:01:48 <earthy> damn. I need to get to the office. :)
00:01:52 <dobblego> only *just* ok
00:02:05 <earthy> I can download pdfs from acm there. :)
00:02:32 <monochrom> There may be a way you can VPN to your office.  Then you can download from acm too.
00:02:42 <monochrom> (I do that all the time.)
00:02:58 <dancor> astrolabe: they definitely seem to have similar purposes
00:03:05 <astrolabe> In haskell, you can't have a list of things that only share the same interface, they have to have the same type.
00:03:26 <dancor> astrolabe: oh that's a good one to know
00:03:32 <Cale> Well, with existential types you can.
00:03:35 <dobblego> interfaces exist because there are uncontrolled side-effects
00:03:42 <Cale> And of course, you can simulate those by hand.
00:03:49 <Cale> dobblego: not true at all
00:03:50 <dancor> dobblego: heh is that a monad joke
00:03:59 <dobblego> Cale, I believe it quite adamantly
00:04:04 <astrolabe> Cale, ok, for haskell = haskell98 aka standard haskell
00:04:08 <Cale> What about the Num interface?
00:04:10 * dancor will never get monads but may get monad jokes some day
00:04:17 <dobblego> what Num interface?
00:04:36 <monochrom> This is a testing.  Do you see what I type here?
00:04:42 <dons> > runState (do x <- get ; put (x+1) ; return "done") 8
00:04:43 <lambdabot>  ("done",9)
00:04:44 <glguy> yeah
00:04:45 <dancor> monochrom: i found a bug
00:04:48 <Cale> The typeclass Num is an interface to arithmetic functionality at different types.
00:04:48 <dons> dancor: ^^ monads are easy!
00:04:49 <astrolabe> dancor: persevere with monads, a lot of 'getting' them is just familiarity breeding comptempt.
00:04:56 <monochrom> Ok just checking.
00:04:58 <dobblego> Cale, that's a type-class, not an interface
00:05:14 <Cale> typeclasses provide interfaces
00:05:25 <dobblego> I was referring to the interfaces that were referred to earlier
00:05:31 <dancor> thank god someone is willing to use the I-word
00:05:31 <dons> > do x <- Just 1 ; y <- Just (x + 2) ; return y
00:05:33 <lambdabot>  Just 3
00:05:42 * glguy just got lost in the indirection ;)
00:05:45 <dobblego> those that don't exist in Haskell (since of course, there are no uncontrolled side-effects)
00:05:53 <dons> > do x <- Just 1 ; y <- Just (x + 2) ; Nothing ; return y
00:05:55 <lambdabot>  Nothing
00:06:04 <Cale> Which interfaces would those be?
00:06:21 <dobblego> monochrom> In c++ or java, if you have two objects of the same interface...
00:06:38 <monochrom> No one ever saw that, dobblego.
00:06:44 <dobblego> <astrolabe> dancor: like an interface is an ok analogy for typeclasses, but there are important differences
00:06:47 <Cale> Specifically, if you have two objects with the same parent class.
00:06:56 <monochrom> Proof.  Five minutes later, three people said the same thing.
00:07:08 <dobblego> monochrom, I listen to you :)
00:07:24 <svref> So I want to define a mod'ular numeric type, but "abs" and "signum" don't make sense for that.  Is there some way to make it a compile-time error to call them?
00:07:32 <monochrom> I have a feeling that people here randomly discard 50% of what I say.
00:07:42 <dobblego> randomly you think?
00:07:45 <Cale> svref: abs = error "abs"
00:07:59 <dancor> monochrom: unfortunately, that percent was in my percent
00:08:00 <dons> well, that's a runtime error
00:08:05 <astrolabe> monochrom: oops, sorry.
00:08:14 <Cale> er, yeah, you said compile-time, no, there isn't.
00:08:17 <dons> just leave the method definition out
00:08:40 <monochrom> It's ok.  I'm planning to balance it by repeating everything I say.
00:08:40 <svref> and eat the warnings
00:08:45 <Cale> Unfortunately, Num is a little poorly designed.
00:09:07 <astrolabe> monochrom: just think of me as providing your repeats for you.
00:09:18 <Cale> (it shouldn't have abs and signum in it)
00:09:30 <monochrom> That's a new way to look at it.  I'll give it a try.
00:09:38 <svref> What's the effect of saying abs = abs?
00:09:42 <tennin> hi
00:09:52 <Korollary> I have monochrom on ignore anyway
00:10:37 <tennin> I spent yesterday writing absolutely ghastly Haskell code
00:10:52 <dobblego> what's that?
00:11:07 <tennin> learned it's about as easy to write horribly sloppy junk in Haskell as in other languages
00:11:22 <monochrom> You're making me look up "ghastly".  Your English is very unreadable, by the standard of unskilled people such as me.
00:11:39 <dobblego> ghastly and Haskell are oxymoronic terms
00:12:13 <mauke> monochrom: you need to read more internet comics
00:12:24 <monochrom> (I was being sarcastic.)
00:12:28 <dobblego> the dream that any type-checking code is meaningful is almost realised with Haskell
00:12:30 <tennin> not when your functions have signatures like String -> String -> String -> String -> String -> String -> String -> IO ()
00:12:51 <monochrom> Haha now that's ghastly
00:13:13 <dobblego> yeah, you need more String arguments to make it more meaningful
00:13:23 <monochrom> haha
00:13:33 <vegai> dobblego: or perhaps they are redundant terms?
00:13:34 * vegai flees
00:14:03 <svref> Writing Haskell code to generate Haskell code was pretty ghastly.
00:14:15 <monochrom> That is kind of true.
00:14:34 <monochrom> TH or the GHC API may alleviate that.
00:15:01 <Cale> tennin: well, are they *really* strings?
00:15:12 <Cale> Or should they be newtyped?
00:15:32 <Cale> (or at least type aliased)
00:15:43 <svref> Cale: they're strings of Perl source code.  :}
00:16:56 <astrolabe> Is anything 'really' of a certain type though, or could everything be given a more specific newtype?
00:17:39 <tennin> They should definitely be type aliased etc.
00:17:45 <tennin> I didn't think I had the time.
00:18:25 <tennin> but one thing I learned is that "the long run" that doing such things saves you time in comes in hours not days
00:18:50 <astrolabe> One of the nice things about haskell is how little effort it takes to set up some type structure and names.
00:19:09 * glguy has resigned to the fact that he's not going to make this algorithm very "pretty"
00:20:35 <hpaste>  glguy pasted "disappointing first draft" at http://hpaste.org/87
00:20:52 * astrolabe is disappointed
00:21:09 <tennin> or how about String -> Map String String -> String -> String -> String -> Either ParseError (Maybe [Either MissingField CopyAction]) hehe
00:23:13 <Korollary> gotta break up that function
00:32:45 <earthy> monochrom: oh, I can download pdfs over VPN, but going to the office is a. a good idea anyway and b. not even that much more work
00:33:36 <monochrom> nice
00:34:17 <dobblego> has anyone started their children earlier than "normal" in school?
00:34:42 <earthy> um.
00:34:58 <earthy> not me, but I plan to. ;)
00:35:12 <dobblego> do you have children?
00:35:24 <earthy> or, no, not really plan to start them in school earlier but plan to teach them stuff earlier
00:35:27 * earthy doesn't yet
00:36:26 <dobblego> here's the thing, my 5 year old can exceed by far, the level of introductory schooling; he is incredibly bored without challenging himself - I went to an interview at the school and the "authority" firmly resisted my request - I cannot help but wonder if they truly have his best interests or are acting as part of a bigger machine
00:36:33 <dobblego> and I figured #haskell would have the answer of course
00:36:57 <earthy> well, when I was 7 I skipped 'half' a grade
00:37:13 <dobblego> he has been skipping "half grades" all his life - it's time to take the plunge
00:37:25 <earthy> with 20/20 hindsight that may not have been the best thing to have happen to me socially
00:37:29 <dons> dobblego: i got started a year early
00:37:30 <dobblego> they tried to emphasise the lack of social development
00:37:45 <dobblego> dons, in the public system? and right at the start?
00:37:50 <dons> yeah
00:38:03 <dons> there was about 5 in the class a year younger. i think they discourage that now?
00:38:14 <earthy> being a year early in the public system doesn't even help you all that much in not being bored
00:38:17 <dobblego> I can't help but think there is either some other agenda on the conscience, or they simply aren't competent enough to consider
00:38:29 <dobblego> absolutely discourage it
00:38:35 <dobblego> I was surprised at the resistance I met
00:38:52 <earthy> they probably aren't competent enough
00:38:56 <earthy> find a different school
00:39:00 <dobblego> I can understand that some parents do it for foolish reasons, such as "wishing" their child was more
00:39:17 <dobblego> well, I'm afraid it's probably universal across our public school system
00:39:31 <dobblego> my son will simply be absolutely bored as hell
00:39:42 <dobblego> I vividly recall it myself
00:40:02 <dobblego> he is beyond what I was at his age if my vague memory serves well
00:40:07 <xpika> get him a laptop, problem solved.
00:40:11 <earthy> well, there's a trick in keeping him from being bored: give him enough to do next to school
00:40:24 <dobblego> he already uses his linux desktop with ghci, etc. quite well
00:40:34 <earthy> at 5 years old.
00:40:36 * earthy impressed.
00:40:46 <dobblego> only to do simple arithmetic
00:40:58 <earthy> arithmetic at 5 is impressive
00:41:01 <dobblego> but the point is, you can see he will be bored starting school
00:41:06 <earthy> especially on a computer
00:41:19 <dobblego> he's figured out ebay too
00:41:27 <dobblego> I have to put a firewall rule on soon
00:41:29 <earthy> there's a whole load of cognitive skills that are normally taught at 6 and 7 that come before that
00:41:55 <earthy> reading, for one. :)
00:41:56 <dobblego> well, he starts school next week and I am torn - so I need help
00:42:10 <glguy> ?tell dons hackage will be happy now, do I need to retag?
00:42:11 <lambdabot> Consider it noted.
00:42:13 <dobblego> #haskell is full of these people
00:42:19 <dobblego> as well as being the universal problem solver
00:42:45 <dobblego> if anything, I am erring on the side that I am right and the resistance is wrong
00:42:57 <dobblego> I just cannot rationalise it enough to instill confidence
00:44:18 <Korollary> I wasn't bored.
00:44:58 <dobblego> I always had to wait for the other kids
00:45:22 <Korollary> I remember sleeping.
00:45:27 <dobblego> chasing bubbles around in my contact covered books
00:45:57 <dobblego> well, my son gets frustrated
00:45:59 * earthy daydreamed a lot
00:46:06 <dobblego> I chase bubbles, you sleep, my son gets frustrated
00:46:11 <earthy> have you tried visualization exercises? :)
00:46:23 <dobblego> sure, I do stuff with him all the time
00:46:29 <dobblego> but the point is, his schooling
00:46:42 <dobblego> the three arguments against that were provided to me:
00:46:48 <earthy> ofcourse, by the time I was 13 I started doing college level correspondence courses
00:46:48 <dobblego> 1) he will commit suicide when he is 15
00:46:57 <dobblego> 2) he will finish school a "geek" without social skills
00:47:04 <earthy> hell, 2 isn't bad
00:47:07 <dobblego> 3) he will have no social skills (repetition of 2?)
00:47:08 <Korollary> lol
00:47:16 <dobblego> seriously, thy are the arguments given to me
00:47:26 <dobblego> they are all furfies
00:47:29 <Korollary> Well, yes.
00:47:32 <dobblego> but "social skills" sticks
00:47:36 <earthy> and honestly, if he's even half as smart as you say he is, he can easily make up for that with coaching
00:47:45 <earthy> yeah, the social skills thing is tricky
00:47:57 <dobblego> for what? it's only the social skills I'm concerned about
00:48:03 <Korollary> I played soccer nonstop. That helps social skills (presuming I have some).
00:48:05 <dobblego> he will exceed his peers if he starts a year early
00:48:11 <earthy> and I get the feeling that the school doesn't want to coach him in that
00:48:18 <earthy> he will exceed his peers no matter what
00:48:23 <dobblego> yes, he plays football and does swimming
00:48:30 <earthy> he has to learn to deal with that
00:48:38 <earthy> that's harder than maths. :)
00:48:39 <dobblego> well, he's not starting early - he's actually skipping the first year
00:48:45 <dobblego> too late to start early
00:48:58 <dobblego> right - there is the ego thing, which he has a bit of
00:49:12 <earthy> the question is whether his empathic intelligence is up to it
00:49:21 <earthy> that school won't help you answer that question
00:49:44 <Korollary> They didnt let me skip the first year.
00:50:13 <Korollary> I am not sure it would have changed anything.
00:50:56 <Korollary> I once got an F on a math test.
00:51:09 <Korollary> The stars must have been perfectly aligned for that one.
00:51:09 <earthy> they did let me skip (part of) the first year (that's what you get moving from brazil to .nl, where school years don't match up)
00:51:27 <earthy> then they suggested I'd skip another in secondary education
00:51:52 <earthy> if the kid is really truly smart he *will* have troubles socially
00:52:05 <earthy> doesn't matter if he skips a grade or not
00:52:18 <dobblego> who said?
00:52:26 <dobblego> I don't believe that implication is universal
00:52:41 <earthy> dobblego: I do. there will at least be envy
00:52:48 <earthy> at the *very* least
00:52:59 <Korollary> I didnt run into that.
00:53:07 <Korollary> I guess it depends.
00:53:10 <dobblego> I did, but only with my brother
00:53:21 <dobblego> who is in jail for the 6th time
00:53:29 <dobblego> thinks I'm a super-hero
00:54:07 <Korollary> sorry to hear that
00:54:35 <dobblego> so you see that I am divided
00:54:41 <dobblego> I have considered all of these things
00:54:45 <earthy> but, really, try to find a different school if possible
00:54:55 <dobblego> why? all the schools will have the same result
00:54:56 <earthy> or a sympathetic teacher at this one
00:55:09 <earthy> ah, no. not all the schools will be so blind
00:55:11 <dobblego> the teacher did offer the consolation that he will be challenged at his level
00:55:21 <dobblego> well, is it their blindness or mine?
00:55:25 <dobblego> they *are* teachers after all
00:55:43 <earthy> if they can *guarantee* challenging your kid at his level...
00:55:55 <dobblego> well, they seemed confident at least
00:56:17 <dobblego> I will just be resentful if he comes home unchallenged all day because he has to conform with his peers
00:56:22 <earthy> (which I kind of doubt... suppose the teach is in the top 10% smartest people. Of the 30 in any group there ought to be 3 at least as smart)
00:56:45 <earthy> dobblego: depends on the schooling system
00:56:52 <dobblego> or are the smart ones going to different schools?
00:57:17 <dobblego> I joined a chess club when I was 5 - after eating a book
00:57:26 <dobblego> I was *that* bored
00:57:42 <Korollary> eating a book?
00:57:45 <dobblego> my mother reminds me regularly
00:57:57 <dobblego> one of those little writing pad books
00:58:07 <Korollary> was it good? Maybe with Tabasco sauce?
00:58:16 <dobblego> I don't even remember - I only remember starting chess
00:59:00 <dobblego> next year there is a joined grade 2/3
00:59:05 <dobblego> I could transition him then
01:01:35 <Korollary> chess is such a cliche
01:01:44 * kolmodin is off to work. happy hacking!
01:05:11 <dancor> how do you specify like f :: Int -> String in ghci
01:06:06 <Syzygy-> dancor: let f = show :: Int -> String -- I guess.
01:06:28 <Syzygy-> *RSA Data.Bits> let f = show :: Int -> String
01:06:28 <Syzygy-> *RSA Data.Bits> f (3::Integer)
01:06:28 <Syzygy-> <interactive>:1:3: Couldn't match expected type `Int' against inferred type `Integer' In the first argument of `f', namely `(3 :: Integer)' In the expression: f (3 :: Integer) In the definition of `it': it = f (3 :: Integer)
01:06:32 <Syzygy-> Ayup.
01:07:29 <dancor> but it has no effect?
01:07:39 <Syzygy-> Yes it does.
01:07:49 <Syzygy-> Please read the snippet I gave you.
01:08:04 <Syzygy-> Also
01:08:05 <Syzygy-> *RSA Data.Bits> :t f
01:08:06 <Syzygy-> f :: Int -> String
01:08:10 <dancor> Syzygy-: but it offers no pretection
01:08:13 <dancor> for example
01:08:13 <dancor> Prelude> let f = f :: Int -> String
01:08:14 <dancor> Prelude> let f a = a
01:08:14 <dancor> Prelude> f 4
01:08:14 <dancor> 4
01:08:27 <Syzygy-> Well, 4 is actually an Int.
01:08:32 <Syzygy-> If you want it to.
01:08:34 <dancor> but not a String
01:08:46 <Syzygy-> Oooooookay. What do you -think- Int -> String means?
01:08:56 <mauke> STOP. HAMMER TIME.
01:08:58 <Syzygy-> Ah. Now I see the problem.
01:09:08 <mauke> let f = ...; let f = ...; creates two different f's
01:09:11 <merus> hahaha.
01:09:14 <Syzygy-> Each let "cancels out" the last one.
01:10:11 <Syzygy-> If you put the :: Int -> String on the same row, thus affecting the same f, as the function definition, then you'll get a confused interpreter instead of a completely other function.
01:20:44 <isieo> is there a haskell interpretor for mobile devices?
01:21:53 <nornagon> ewww, interpreter
01:22:00 <psnl> > (1:2):[]
01:22:00 <lambdabot>   add an instance declaration for (Num [a])
01:22:01 <dons> isieo: hugs and nhc have been used on mobile/small devices
01:22:01 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:22:09 <psnl> > (1::Int:2::Int):[]
01:22:10 <lambdabot>  Parse error
01:22:12 <nornagon> psnl: fail
01:22:20 <nornagon> that first bit is an incomplete list
01:22:25 <mauke> > fail []
01:22:27 <lambdabot>   add an instance declaration for (Show (m a))
01:22:27 <nornagon> it would be [[Int]], but it's not quite
01:22:33 <psnl> nornagon: cool
01:22:36 <Syzygy-> > 1:2:[] :: [Int]
01:22:38 <lambdabot>  [1,2]
01:22:49 <psnl> and without the brakets its [Int]
01:23:14 <nornagon> yes
01:23:23 <nornagon> > (1:2:[]):[]
01:23:25 <lambdabot>  [[1,2]]
01:23:37 <psnl> > 1:2:[]
01:23:39 <lambdabot>  [1,2]
01:23:41 <Syzygy-> > []:[]:[]:[]
01:23:42 <lambdabot>  Add a type signature
01:23:51 <Syzygy-> ?type []:[]:[]:[]
01:23:53 <lambdabot> forall a. [[a]]
01:24:02 <Syzygy-> > []:[]:[]:[] :: [[Int]]
01:24:03 <nornagon> The set of lists contains the empty list. The set of lists also contains (a:b), where b is a member of the set of lists.
01:24:04 <lambdabot>  [[],[],[]]
01:24:14 <dancor> if i actualy want an oo interface, should i do something like 'class MyTC a where myIntToStrF :: Int -> String' and 'data MyInst = MyInst' and 'instance MyTC MyInst where myIntToStrF = show' ?
01:24:19 <Syzygy-> ?type (([]:[]):[]):[]
01:24:21 <lambdabot> forall a. [[[[a]]]]
01:24:38 <Syzygy-> ((([]::[Int]):[]):[]):[]
01:24:41 <Syzygy-> > ((([]::[Int]):[]):[]):[]
01:24:42 <lambdabot>  [[[[]]]]
01:25:10 <dancor> or am i just doing it all wrong
01:25:27 <Syzygy-> I'm with 'doing it all wrong', but I may be wrong.
01:26:30 <dancor> Syzygy-: i need some _thing_ that supports different methods to be called on it but what the functions are can differ from one instance of the thing to the next
01:26:56 <nornagon> I wish there was an instance Show (forall a b. a -> b)
01:27:06 <nornagon> to show the code of the function.
01:27:11 <nornagon> in assembly if you must!
01:27:27 <dancor> in the assembly monad
01:27:54 <dons> nornagon: let me whip one up for you
01:27:57 * dons hacks for a second
01:27:59 <mauke> > undefined :: a -> b
01:28:00 <lambdabot>  Add a type signature
01:28:06 <mauke> what
01:28:31 <dancor> maybe i need a haskell for oo programmers tutorial
01:28:35 <Syzygy-> > undefined :: Int -> Int
01:28:36 <lambdabot>  <Int -> Int>
01:28:45 <nornagon> dons: :O
01:29:28 <Syzygy-> dancor: I get the feeling you're stuck in a completely different paradigm. I'd suggest OOHaskell or groking functional programming.
01:29:38 <dancor> Syzygy-: i'm not stuck
01:29:39 <dons> nornagon: i'm thinking you just unsafePerformIO $ system "lambdabot src" ++ sym
01:29:40 <dons> e.g.
01:29:41 <Syzygy-> Though it may be that you'd benefit from chats with Bulat as well. :P
01:29:43 <dons> lambdabot> src map
01:29:43 <dons> map _ []     = []
01:29:44 <dons> map f (x:xs) = f x : map f xs
01:29:49 <nornagon> heh
01:29:53 <dons> but then you also need to get the symbol name from the type
01:30:00 <dons> so you could use hoogle to do that
01:30:06 <dons> or some Dynamic trickery
01:30:15 <nornagon> zany :|
01:30:16 <Syzygy-> > src undefined
01:30:17 <lambdabot>   Not in scope: `src'
01:30:23 <nornagon> also, would it work for functions i defined myself?
01:30:27 <dons> ?src undefined
01:30:28 <lambdabot> undefined =  error "Prelude.undefined"
01:30:41 <dons> nah, you'd have to update the src data base yourself
01:30:50 <nornagon> ?let some_function a = flip a
01:30:51 <lambdabot> Defined.
01:30:56 <nornagon> ?src some_function
01:30:57 <lambdabot> Source not found. You speak an infinite deal of nothing
01:31:04 <dons> for example
01:31:05 <earthy> @type some_function
01:31:06 <nornagon> ?unlet some_function
01:31:06 <lambdabot> Not in scope: `some_function'
01:31:07 <lambdabot>  Parse error
01:31:21 <earthy> ??
01:31:28 <earthy> what's that let do then?
01:32:30 <nornagon> > some_function foldl
01:32:31 <lambdabot>  Add a type signature
01:32:43 <nornagon> > some_function (+)
01:32:45 <lambdabot>  Add a type signature
01:32:54 <nornagon> > some_function (+) :: (Num a) => a -> a -> a
01:32:55 <lambdabot>  Add a type signature
01:33:04 <dons> it adds a new top level binding
01:33:04 <nornagon> > (some_function (+)) :: (Num a) => a -> a -> a
01:33:06 <lambdabot>  Add a type signature
01:33:08 <nornagon> gr.
01:33:16 <nornagon> > (some_function (+)) :: Int -> Int -> Int
01:33:18 <lambdabot>  <Int -> Int -> Int>
01:33:19 <dons> ?let for = flip map
01:33:20 <lambdabot> Defined.
01:33:24 <dons> > for [1..10] show
01:33:26 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
01:33:52 <merus> dons: that's cool.
01:36:03 <AStorm> Blah, that's so cheap you shouldn't use that.
01:36:14 <AStorm> Use map directly instead. Or flip map
01:36:38 <AStorm> > for ['a'..'z'] ord
01:36:39 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
01:36:50 <blackdog> haskell has spoilt me.
01:37:01 <blackdog> i just spent ten minutes debugging a flipped argument in ruby :(
01:37:01 <AStorm> > map ord ['a'..'z']
01:37:01 <Korollary> nah. You were just like this before.
01:37:03 <lambdabot>  [97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
01:37:15 <blackdog> Korollary: oh, that's not nice :)
01:37:23 <blackdog> stupid dynamic languages
01:37:27 <Korollary> I've still got it, baby.
01:37:38 <AStorm> Haha, at least Python is strict :>
01:37:46 <Korollary> strict in what?
01:37:49 <AStorm> I mean strictly typed
01:37:58 <blackdog> ... uh?
01:38:04 <blackdog> strongly typed, you mean?
01:38:11 <AStorm> Yep.
01:38:12 <AStorm> :/
01:38:19 <blackdog> (please let's not have the static/strong/weak/dynamic argument again)
01:38:36 <Korollary> Python does let you say "if "Blah"", though
01:38:42 <mauke> static/dynamic, strong/weak, safe/unsafe
01:38:54 <blackdog> but generally strict = evaluation order, not typing
01:38:59 <mauke> explicit/implicit
01:39:10 <mbishop> I like a dynamic language when I don't care about type, for quick stuff
01:39:12 * mbishop shrugs
01:39:20 <AStorm> Why I don't like ruby: it looks like perl.
01:39:23 <blackdog> ... oh fine i give in. i thought strong/weak was the same as safe/unsafe? ie, you can't kill the interpreter accidentally at runtime in a strongly typed language
01:39:33 <Korollary> Matz meant it to be like perl in some aspects.
01:39:34 <AStorm> Yes you can.
01:39:38 <blackdog> you just get a nice formatted exception
01:39:54 <AStorm> Though it's much harder to do so.
01:39:58 <blackdog> bombing out with a proper explanation is fine - that's catchable. i'm talking bus error stuff...
01:40:00 <Korollary> blackdog: Benjamin Pierce says he doesnt know what the heck strongly typed means.
01:40:10 <mauke> blackdog: I thought it strong meant no implicit conversions
01:40:15 <mbishop> Well I use scheme for my quick mashup needs :P
01:40:32 <AStorm> Korollary, what mauke said
01:40:40 <AStorm> No stupidity included :-)
01:40:44 <Korollary> AStorm: What about it?
01:40:46 <blackdog> ruby's nothing special, really. it's a decent dynamic language, accessible metaprogramming... really, it's rails that makes it worth using...
01:40:47 <AStorm> Or just a tiny bit (like numeric types)
01:41:24 <mauke> e.g. I'd say lisp is dynamic,strong,unsafe,explicit
01:42:07 <Svrog> how is lisp unsafe?
01:42:33 <dancor> so i'm writing haskell bindings for an networky rpc mechanism
01:43:14 <blackdog> korollary: am reading the same wikipedia article now :)
01:43:32 <blackdog> so this is why every time this one comes up, people end up calling each other morons and sweating profusely
01:43:53 <mauke> Svrog: http://www.lisp.org/HyperSpec/Body/dec_type.html
01:43:55 <lambdabot> Title: CLHS: Declaration TYPE
01:44:08 <Korollary> blackdog: It boggles my mind how people love that particular subject, too.
01:44:09 <mauke> "The interpretation of a type declaration is as follows: ..."
01:44:32 <blackdog> especially when we've clearly got the best programming language yet with us already :P
01:44:47 <Svrog> i still cant see what in there makes it unsafe?
01:44:55 <Svrog> as far as i know lisp is safe unless you use ffi
01:44:59 <Svrog> just like haskell in that respect
01:46:35 <mauke> "1. During the execution of any reference to the declared variable within the scope of the declaration, the consequences are undefined if the value of the declared variable is not of the declared type."
01:46:38 <AStorm> Svrog, it's not unsafe, but dynamic
01:46:43 <mauke> "2. During the execution of any setq of the declared variable within the scope of the declaration, the consequences are undefined if the newly assigned value of the declared variable is not of the declared type."
01:46:43 <Svrog> c is unsafe because you can pretty much write to arbitrary locations in memory and do other similar stuff that can result in a hard program crash or under some operating systems crash the whole computer even - but that is not the case for lisp, haskell, java, python, etc
01:46:48 <Svrog> AStorm: yes
01:46:55 <mauke> "3. At the moment the scope of the declaration is entered, the consequences are undefined if the value of the declared variable is not of the declared type."
01:47:03 <mauke> how is that not unsafe?
01:47:22 <blackdog> mauke: ah, "flying monkeys | nose" time...
01:47:30 <mauke> exactly
01:47:44 <AStorm> That's undefined and not unsafe :>
01:47:53 <mauke> then C is completely safe
01:47:54 <Svrog> mauke: it's not unsafe in the same way that division by zero is not unsafe - the runtime environment is just free to handle it in whichever way it wants
01:47:59 <blackdog> AStorm: that's ridiculous :)
01:48:21 <mauke> because all the "unsafe" operations in C are simply undefined
01:48:23 <AStorm> http://en.wikipedia.org/wiki/Type_system
01:48:47 <AStorm> "Computer scientists consider a language "type-safe" if it does not allow operations or conversions which lead to erroneous conditions."
01:49:05 <AStorm> This is easy. So lisp indeed is unsafe? :P
01:49:32 <AStorm> No, probably an exception will be thrown?
01:49:44 <mauke> no exception. it's simply undefined.
01:50:01 <mauke> that includes the possibility of bogus values and segfaults
01:50:01 <AStorm> So, unsafe.
01:50:03 <Svrog> mauke: so what you are saying is that if a standard says that the result of (+ 1 "some string") is not defined, that makes the language unsafe?
01:50:08 <mauke> Svrog: yes
01:50:18 <blackdog> How would you build a future-proof haskell system (ie, never has to restart, even after a period of decades?)
01:50:21 <mauke> because an implementation of the language could do literally anything
01:50:22 <Svrog> that would effectively make every dynamic language unsafe
01:50:31 <mauke> Svrog: it's defined in perl
01:50:31 <AStorm> blackdog, by handling exceptions, dummy :-)
01:50:52 <AStorm> blackdog, the first thing that will fail will be the hardware.
01:52:41 <Svrog> mauke: such things cannot be defined and even though some specifications for some languages may explicitly state behavior in those undefined cases, many specs leave it up to the implementor to decide how to handle such cases
01:52:47 <AStorm> (unless you wrote buggy code, and that will probably bomb early, just the nature of Haskell)
01:52:50 <Svrog> it doesn't mean the language is unsafe
01:53:02 <AStorm> Also, use QuickCheck
01:53:56 <mauke> Svrog: yes, it does
01:53:57 <mbishop> mauke: so haskell is unsafe in your eyes?
01:54:04 <mauke> mbishop: what part of it?
01:54:18 <AStorm> Haskell is safe, except those operations which are explicitly marked as unsafe :-)
01:54:31 <mbishop> any part? you said if a language's standard allows undefined behavor, it isn't safe
01:54:34 <mbishop> @vixen
01:54:35 <lambdabot> <undefined>
01:54:37 <mauke> Svrog: what do you mean by "such things"?
01:54:37 <mbishop> :o
01:54:45 <AStorm> mbishop, it's non-standard, those extensions
01:55:03 <AStorm> And FFI isn't really a part of the language :P
01:55:23 <Svrog> what i just said - operations that dont make sense in any language - division by zero for example
01:55:33 <Svrog> or adding a string to an integer
01:55:34 <mauke> it makes sense in perl and is defined
01:55:35 <AStorm> No. These do make sense.
01:55:39 <Cale> FFI is actually in an addendum to the standard.
01:55:50 <mbishop> indeed, but I'm sure there is a part of the core that has undefined behavor, and I think ANY language has at least some undefined behavor, so in mauke's vision, no language is safe :)
01:55:50 <AStorm> Should be either defined or throw an exception. Handleable
01:56:07 <mauke> "throws an exception" is defined behavior
01:56:18 <Svrog> that is not what i mean - just because perl explicitly states what happens in such a situation it doesnt mean that the operation itself makes sense - which is why it's treated as an error
01:56:20 <AStorm> Yes, but it's a different kind of defined.
01:56:22 <AStorm> :P
01:56:33 <mauke> Svrog: we're not talking about whether it makes sense
01:57:12 <mbishop> I want to see proof that every situation possible is defined by any language
01:57:17 <mbishop> go go go! :P
01:57:24 <sieni> so if the lisp spec said "causes immedieate program termination" instead of "it's up to the implementation to do wtf they want" it would become safe?
01:57:32 <mauke> sieni: yes
01:57:37 <Svrog> no, and whether perl defines something where other languages decided to treat it as an error and leave it up to the implementation to handle it doesnt make those languages unsafe
01:57:46 <mauke> Svrog: yes, it does
01:58:10 <fasta> How can I import a module from a directory above the current one without using -v ?
01:58:20 <Svrog> ok - im not gonna argue anymore.. but do look up what unsafe means
01:58:44 <mauke> "unsicher" - what now?
01:58:45 <Cale> I think probably the closest thing to undefined behaviour in the Haskell standard is what happens with the Array type when faulty instances of Ix are supplied.
01:58:59 <AStorm> mbishop, there is one for typed lambda calculus
01:59:06 <fasta> I am in a module Foo.Bar now in directory Foo
01:59:07 <AStorm> And Haskell is an extension of that
01:59:24 <mbishop> AStorm: but that's not the language, that's just it's theoretical basis, I want proof, in a specific language
01:59:31 <mbishop> until then, languages are quasisafe :P
01:59:34 <AStorm> It is a proof.
01:59:46 <mbishop> I'm just being silly by the way, I think mauke's definition of "safe" is just wrong
01:59:52 <AStorm> If you can reformulate Haskell in TLC, it is a proof.
01:59:53 <AStorm> :>
01:59:54 <Cale> There's also probably some things to do with IO which are technically not defined.
02:00:02 <mauke> mbishop: do you have a better definition?
02:00:05 <AStorm> Cale, no, these throw exceptions.
02:00:18 <Cale> AStorm: It doesn't say that they should.
02:00:26 <AStorm> It does :P
02:00:34 <Cale> An implementation is entitled to assume the following laws about these operations...
02:00:56 <Cale> If those laws fail, bad things can (and do) happen.
02:01:05 <Svrog> mauke: http://www.cybertiggyr.com/gene/tat/
02:01:08 <lambdabot> Title: The Truth about Type Safety in Programming Languages
02:01:13 <AStorm> ?where Haskell report
02:01:13 <lambdabot> http://haskell.org/
02:01:21 <AStorm> ?where Haskell98
02:01:21 <lambdabot> http://haskell.org/onlinereport/
02:01:35 <Cale> http://haskell.org/onlinereport/ix.html
02:01:36 <lambdabot> Title: The Haskell 98 Library Report: Indexing Operations
02:02:15 <Svrog> c, c++, assembly language = no run-time type safety therefore unsafe
02:02:19 <AStorm> This means "implementation has to do that, or is not Haskell98"
02:02:23 <mauke> "C & C++ don't have run-time type safety. In either of those languages, you can (attempt to) convert any type to any other."
02:02:27 <mauke> that's bullshit
02:02:36 <Svrog> ada, java, lisp, self, smalltalk = run-time type safety - therefore safe
02:02:55 <mauke> Svrog: why do you think lisp has "run-time type safety"?
02:02:57 <AStorm> mauke, pointers?
02:03:01 <mauke> it's not part of the language definition
02:03:06 <mauke> AStorm: what about them?
02:03:14 <AStorm> C++ has some RTTS
02:03:20 <AStorm> dynamic_cast and friends
02:03:32 <AStorm> C does not and is inherently unsafe.
02:03:39 <Svrog> ugh.. because in lisp you cannot do low level operations that you can in c, c++ and assembly language - because all errors are trapped by the run-time system
02:03:43 <dancor> so i've got an rpc library i want to connect to that i want to expose certain functions to
02:03:52 <flux-> mauke, do you disagree with the conclusion or the claim of being able to convert?
02:03:54 <dancor> should i just put them in a module
02:04:00 <mauke> flux-: the claim
02:04:06 <dancor> to expose the functions i want but not others
02:04:24 <mauke> Svrog: no, not all errors are trapped by the run-time system. specifially, type declaration violations aren't (necessarily).
02:04:41 <mauke> Svrog: I also think the array index operation isn't checked.
02:04:56 <AStorm> dancor, yes
02:05:18 <Svrog> isn't checked how? is a lisp program going to seg fault? or give you a bus error?
02:05:22 <velco> in lisp? no way.
02:05:26 <Svrog> assuming you are not using ffi
02:05:31 <Svrog> velco: that is my point
02:05:37 <AStorm> Svrog, no, it will just behave erratically :P
02:05:46 <mauke> Svrog: depends on the implementation and circumstances
02:05:51 <mauke> i.e. "undefined"
02:05:57 <Svrog> ..
02:06:05 <fasta> How can I import a module from a directory above the current one?
02:06:06 <AStorm> It means you get the blame.
02:06:25 <mauke> what's the java implementation of lisp called?
02:07:40 <blackdog_> mauke: to be fair, we have a similar disclaimer to do with unsafePerformIO and its filthy brethren
02:07:54 <AStorm> blackdog, that's not standard :>
02:07:56 <blackdog_> perhaps the "type" function you referred to is a similar ugly corner
02:08:09 <flux-> mauke, well you can convert an object of any type to be an object of another type in c/c++?
02:08:14 <mauke> blackdog_: I didn't claim that haskell was a perfectly safe language
02:08:17 <blackdog_> AStorm: no, it's not. but it's ubiquitous in low level code :)
02:08:20 <mauke> flux-: no, you can't
02:08:39 <blackdog_> mauke: ok. but are you trying to draw a fundamental safety distinction between lisp and haskell?
02:08:51 <mauke> not really
02:09:09 <flux-> mauke, so you're thinking of something else than char* a = (char*) 42; ?
02:09:17 <blackdog_> alright. i can stand anything other than dogmatism :)
02:09:21 <mauke> but haskell feels much safer in that it's harder to get at undefined behavior
02:09:37 <mauke> flux-: try char *a= (char *)4.2;
02:10:20 <velco> try char *a = reinterpret_cast<char *>( 4.2); ;)
02:10:31 <mauke> that's not C
02:10:31 <blackdog> (apologies for dropping in and out, i'm hanging off wifi in a chiang mai pub.)
02:10:35 <flux-> that's c++
02:10:37 <mauke> (and I don't think that'll compile)
02:10:57 <Korollary> You should be getting drunk at that pub anyways
02:10:58 <velco> anyway, I can convert a double to a pointer
02:11:09 <flux-> but right, it doesn't compile
02:11:10 <Svrog> "We leave as implementation dependent the ways in which Haskell programs are to be manipulated, interpreted, compiled, etc. This includes such issues as the nature of programming environments and the error messages returned for undefined programs (i.e. programs that formally evaluate to bottom)."
02:11:12 <blackdog> How would you build a future-proof haskell system (ie, never has to restart, even after a period of decades?)
02:11:22 <Svrog> mauke: according to that, does that make haskell unsafe according to you?
02:11:25 <flux-> mauke, you can always go via void* to convert anything
02:11:35 <mauke> flux-: no, only pointers to object types
02:11:38 <blackdog> c'mon, this type stuff is so boring. we're debating angels on pins here... :)
02:11:38 <velco> via void and memcpy
02:11:39 <Svrog> taken from the haskell98 report
02:11:43 <AStorm> blackdog, gah. As usual.
02:11:56 <mauke> Svrog: no
02:11:57 <Svrog> right there in the introduction section
02:11:57 <AStorm> Almost all haskell systems are future-proof.
02:12:06 <blackdog> AStorm: I meant the runtime image.
02:12:07 <AStorm> Other than that, use some HaskellOS :P
02:12:07 <mauke> "implementation dependent" /= "undefined"
02:12:24 <blackdog> thinking about how Erlang is designed to run forever, more or less
02:12:24 <AStorm> blackdog, ABI compatibility? Bundle your libs with you
02:12:28 <AStorm> and compile statically
02:12:28 <Svrog> implementation defependent is pretty much undefined - means that implementations can define it however they want
02:12:41 <flux-> mauke, you can make a char/int/long long-pointer to a float, and use that for any coercing types, or copying as velco said
02:12:57 <AStorm> blackdog, no, it isn't :P
02:13:12 <blackdog> AStorm: more than ABI compatibility.
02:13:14 <AStorm> It'll break if you "update" the libs
02:13:24 <AStorm> It actually may break.
02:13:29 <mauke> flux-: huh? what do you mean by that pointer to float thing?
02:13:32 <blackdog> i mean not actually having to restart the server in order to upgrade it.
02:13:42 <AStorm> What does that have to do with Haskell?
02:13:48 <AStorm> Ever heard of yi?
02:14:03 <AStorm> That's what it does. Upgrades at runtime.
02:14:03 <mauke> and memcpy doesn't convert any types; it just reinterprets the bytes
02:14:48 <fasta> How can I import a module from a directory above the current one by using relative paths?
02:14:55 <flux-> what about float t = 42.0; char* c = (void*) &t; *c = 42; ?
02:14:59 <AStorm> ?where yi
02:15:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
02:15:19 <fasta> Or do you just dump all the files in the same directory and thus create a mess in the process?
02:15:34 <vegai> AStorm: yi uses hs-plugins, does it not?
02:15:42 <mauke> flux-: I think that makes the value of t indeterminate
02:15:43 <AStorm> vegai, these and some more
02:15:49 <AStorm> Check the paper.
02:15:52 <njd> ?hoogle Int -> Double
02:15:53 <lambdabot> No matches, try a more general search
02:16:01 <vegai> I don't think it compares to Erlang.
02:16:05 <vegai> ....well.
02:16:32 <AStorm> Lambdabot has the same architecture (that is, if it's not dons)
02:16:36 <njd> ?hoggle toFractional
02:16:37 <lambdabot> No matches found
02:16:43 <njd> ?hoogle Fractional
02:16:44 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
02:16:50 <AStorm> ?hoogle toRational
02:16:51 <lambdabot> Prelude.toRational :: Real a => a -> Rational
02:17:00 <AStorm> ?hoogle fromIntegral
02:17:01 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
02:17:08 <flux-> actually, I might reconsider my point. C/C++ doesn't really allow converting any type to any other type, but it does allow converting values of any type to values of any other type, which is in practice the same thing.
02:17:24 <mauke> it's not really conversion
02:17:32 <AStorm> njd, is that what you wanted?
02:17:43 <mauke> in C, all objects are essentially sequences of bytes
02:17:52 <velco> it allows subverting the, so called "C/C++type system".
02:17:54 <flux-> does the C memory model state that?
02:18:05 <velco> yes
02:18:15 <mauke> flux-: pretty much, since you're allowed to treat any object as an array of unsigned chars
02:18:35 <mauke> that doesn't include "all types", though; functions aren't objects
02:19:14 <hpaste>  Marc Weber pasted "Data.Graph, is dfs what I need here?" at http://hpaste.org/88
02:20:13 <blackdog> i think it's going to become more and more important
02:20:13 <blackdog> well, just that it's hard to do at the moment.
02:20:13 <blackdog> hs-plugins is a good step in the right direction.
02:20:13 <blackdog> but you can hot-swap code really easily in erlang
02:20:13 <blackdog> i'm just wondering aloud how you'd get a similar effect in haskell
02:20:21 <AStorm> mauke, yes it does
02:20:35 <AStorm> Just mangle data pointed to by function pointer
02:20:41 <AStorm> :P
02:20:49 <Itkovian> anybody know if the XCode plugin is available somewhere?
02:20:54 <AStorm> void* teh godzor
02:21:11 <Itkovian> on the sequence.complete, it's announced, but apparently not hosted anywhere
02:21:28 <mauke> AStorm: function pointers don't autoconvert to void *
02:21:31 <AStorm> blackdog_, uh... yi and lambdabot do that
02:21:49 <AStorm> mauke, not automatically, but can be converted to, say, char*
02:21:56 <mauke> what?
02:21:59 <AStorm> Nice for IOCCC
02:22:06 <blackdog_> a lot of haskell code seems to be sort of academic - mostly batch-driven, and intended to terminate - it's almost a point of pride that it _will_ terminate. (and yes, i know that's sometimes a good thing.)
02:22:20 <blackdog_> AStorm: to an extent.
02:22:22 <mauke> AStorm: (char *)some_function isn't required to compile
02:22:24 <AStorm> lambdabot, do you terminate? :P
02:22:39 <mauke> I think g++ simply rejects it
02:22:44 <blackdog_> (and please don't assume I don't know how they work. I sat next to dons for a year and have code in lambdabot.)
02:22:52 <AStorm> mauke, yes, it's undefined behaviour
02:23:06 <fasta> blackdog_: Erlang has some very good software which makes that practical now.
02:23:19 <blackdog_> but even lambdabot needs to be restarted occasionally
02:23:19 <blackdog_> to be upgraded to new compilers, etc
02:23:20 <blackdog_> fasta: yes, exactly
02:23:23 <fasta> blackdog_: it could be done in Haskell, but it hasn't.
02:23:41 <AStorm> blackdog_, well, to skip that, link fully statically
02:23:47 <blackdog_> i'm wondering aloud what the best way to do it in haskell is because i think Hindley-Milner is a hot bitch :)
02:24:00 <AStorm> Then upgrading compiler is nothing.
02:24:18 <fasta> blackdog_: The best way is to use all the software from the Erlang implementation.
02:24:29 <fasta> It's BSD, right?
02:24:54 <blackdog_> AStorm: yes, but then you've only compiled it once, back in the stone ages. Remember, i'm positing a program that once started runs uninterrupted for decades.
02:25:02 <fasta> Anyway, I found an answer to my problem/
02:25:21 <blackdog_> fasta: it's an interesting question as to whether it's harder to add types to Erlang or add serious upgradability to Haskell :)
02:26:34 <araujo> morning
02:26:44 <dancor> so can i have my function types in one flie and the definitions in another
02:26:51 <dancor> s/li/il
02:26:53 <dancor> or is that insane
02:27:10 <dancor> because i could have tho types autogenerated by my rpc thingy here
02:27:30 <fasta> Anyone with a good name for a graph library?
02:27:33 <dancor> i don't know if that would be good though
02:27:36 <dancor> or just silly
02:27:37 <AStorm> blackdog_, uh, simple - rebuild the core, then restart dynamically
02:27:50 <dancor> s/tho/the
02:28:11 <AStorm> Then rebuild all the plugins, maybe? :P
02:28:12 <blackdog_> dancor: i don't think it's possible... although i guess you could use something grody like CPP includes
02:28:18 <AStorm> Anyway:
02:28:21 <AStorm> ?where house
02:28:21 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
02:28:35 <dancor> blackdog_: i was thinking just using the same module name might do it?
02:28:37 <blackdog_> AStorm: still not that easy. Think about a system with thousands of open connections all of the time
02:28:49 <blackdog_> you can't drop any of them
02:29:05 <blackdog_> you will have to start accepting new connections with new code
02:29:09 <AStorm> blackdog_, hmm... then do 2 cores :P
02:29:10 <dancor> blackdog_: i'm not sure i should do it even if i could though
02:29:14 <AStorm> or even 3
02:29:16 <blackdog_> while still servicing the old ones with old code
02:29:17 <AStorm> Like spaceships
02:29:58 <pejo> blackdog_, doesn't Marlow have an article about a type system for Erlang right after his thesis, around 97?
02:30:14 <AStorm> Migrate these connections to a backup core, then restart the other one, start handling new connections with it, restart the other one when it's idle
02:30:15 <blackdog_> so, yeah, you can do it at the process level - spawn off a new process every now and then with upgraded code, and handle it at the front-end - just redirect all new requests to a different spot
02:30:39 <blackdog_> but what if you need state that's in the program? It's not necessarily easy to serialise everything to a database, and certainly not fast
02:30:46 <blackdog_> pejo: multiple attempts have been made, i think
02:30:52 <earthy> hm. that's interesting.
02:30:53 <AStorm> Hmm....
02:30:59 <blackdog_> none have given enough bang-for-buck, AFAIK
02:31:12 <earthy> naive conversion of the fasta shootout benchmark to bytestrings doesn't speed it up
02:31:28 <blackdog_> it's much harder to slap a type-system on top of an existing language. much, much harder.
02:31:32 <pejo> blackdog_, and IBM has some research on dynamic code .. change. In 2005/2006 sometime, for K42. The paper is there on their homepage. But that was C++, but the ideas are probably more general than that.
02:33:12 <AStorm> Hmm, when will new gtk2hs release be out?
02:33:19 <AStorm> (Working with ghc 6.6)
02:33:33 <int-e> real soon now (tm)
02:34:26 <earthy> (nor does it even work. I did something stupid apparently)
02:34:51 <AStorm> and wxHaskell?
02:35:03 <int-e> AStorm: actually. Tue Jan 23 22:06:43 CET 2007  Duncan Coutts <duncan@...> /  * Bump version to 0.9.10.5 /  This is the first release candidate for 0.9.11
02:35:06 <earthy> wxHaskell works with GHC 6.6
02:35:12 <blackdog_> pejo: cheers, am checking it out.
02:35:12 <blackdog_> in some ways, it's a pretty well-established technique - the telecoms guys have had to do it forever
02:35:12 <blackdog_> but i think before erlang, the way they did it was to use dirt-simple state machine techniques
02:35:12 <blackdog_> (don't quote me, i'm going from memory :)
02:35:20 <earthy> at least, wxHaskell 0.10.1-pre that is in darcs
02:35:48 <pejo> blackdog, "be very smart", basically. Not a great process, especially not when it fails.
02:35:50 <earthy> anyway, time for Alexey's talk on the STG optimizations he's been doing
02:36:15 <pejo> earthy, oh, interesting. Paper anywhere?
02:36:30 <AStorm> earthy, no, doesn't compile :P
02:36:33 <earthy> pejo: I'll ask
02:36:36 <blackdog_> pejo: yeah. i am a bear of very little brain, so i love it when systems let me be stupid. :)
02:36:37 <AStorm> Ah, yes, the darcs version.
02:36:41 <AStorm> It does work.
02:36:46 <earthy> :)
02:37:08 <blackdog_> or at least do dangerous things with a safety net
02:37:56 <AStorm> earthy, but, I forgot the URL. Where is it?
02:37:58 <blackdog_> i suppose the other side of it is that you'd like a system that can incorporate all the cool new type system hacks that get introduced...
02:38:08 <Elifant> what is a simpiest way to split list to parts of given size?
02:38:19 <blackdog_> elifant: two parts?
02:38:45 <Elifant> any number of parts, until all elements a consumed
02:38:54 <pejo> blackdog, we all do. The type system is #1 seatbelt for me. :-)
02:39:08 <blackdog_> oh, wait. sorry, something like "split 3 [1..9]" giving [[1,2,3], [4,5,6],[7,8,9]]?
02:39:19 <Elifant> blackdog_: yes
02:39:46 <mauke> @hoogle Int -> [a] -> [[a]]
02:39:48 <lambdabot> No matches, try a more general search
02:42:17 <mauke> > let foo _ [] = []; foo n xs = let (a,b) = splitAt n xs in a : foo n b in foo 3 [1..9]
02:42:19 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
02:42:41 <blackdog_> Elifant:don't think there's anything in the standard libs
02:42:41 <blackdog_> you could write a recursive function using take and drop
02:42:41 <blackdog_> but probably someone here can suggest a virtuousic one-liner that will stagger us all with its crystalline beauty :P
02:43:04 <blackdog_> aw, but still explicit recursion :)
02:43:09 <Elifant> I'm now trying to mix unfoldr and splitAt...
02:44:31 <mauke> @pl foo n xs = let (a,b) = splitAt n xs in a : foo n b
02:44:32 <lambdabot> (line 1, column 10):
02:44:32 <lambdabot> unexpected "="
02:44:32 <lambdabot> expecting variable, "(", operator or end of input
02:45:08 <Cale> > let breakInto n = map (take n) . takeWhile (not . null) . iterate (drop n) in breakInto 5 [1..37]
02:45:10 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
02:45:16 <Cale> > let breakInto n = map (take n) . takeWhile (not . null) . iterate (drop n) in breakInto 5 [1..12]
02:45:18 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
02:45:40 <Elifant> Cale: thanks!
02:45:58 <mauke> @pl foo n xs = (\(a,b) -> a : foo n b) (splitAt n xs)
02:45:59 <lambdabot> foo = fix ((`ap` splitAt) . ((.) .) . flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (:))) .))
02:46:01 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 3)) "abcdefg"
02:46:02 <lambdabot>  ["abc","def","g"]
02:46:22 <blackdog_> I love you guys.
02:46:24 <Elifant> another one. are there simpler way? :)
02:46:45 <int-e> Cale's version is quite straight-forward
02:46:50 <blackdog_> only here could you expect to see monads used to split lists :)
02:47:17 <int-e> @index toMaybe
02:47:17 <lambdabot> bzzt
02:47:21 <Cale> It's just the maybe monad.
02:47:33 <int-e> and the reader monad
02:47:46 <Cale> yeah
02:47:59 <int-e> just for sake of pointlessness
02:48:04 <blackdog_> So only two monads.:)
02:48:29 <Cale> It's not monadically polymorphic, is my point :)
02:48:56 <int-e> hmm. unfoldr could reside in MonadPlus I guess ;)
02:49:07 <Cale> I suppose the liftM2 is pretty bizarre if you're not from around here :)
02:49:12 <nornagon> :t unfoldr
02:49:12 <int-e> well, return MonadPlus results instead of lists.
02:49:14 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
02:49:23 * int-e blames @pl
02:49:57 <Cale> yeah, I use ap from reader without even thinking twice now.
02:50:35 <int-e> > unfoldr (\l -> (guard . not . null) l >> (return . splitAt 3) l) "abcdefg" -- without reader monad
02:50:36 <lambdabot>  ["abc","def","g"]
02:52:12 <int-e> > unfoldr (\l -> listToMaybe [splitAt 3 l | not (null l)]) "abcdefg"
02:52:14 <lambdabot>  ["abc","def","g"]
02:52:51 <Botje> > takeWhile (not.null) $ unfoldr ( Just. splitAt 3) "abcdefg"
02:52:52 <lambdabot>  ["abc","def","g"]
02:52:53 <blackdog_> int-e: i think we have a winner in the 'most-likely-to-be-understood-by-a-python-programmer' segment of the competition
02:53:40 <hpaste>  fasta pasted "Modules..." at http://hpaste.org/89
02:54:44 <fasta> I don't understand the interaction between modules and directories completely (as you can see in that post)
02:54:57 <Cale> btw, (completely offtopic) this short video is pretty cool http://uploads.ungrounded.net/content.php?id=360049&name=360049_space_duckng.swf&title=Space%20Duck&date=1169701200&quality=b&uj=0&w=720&h=405
02:55:00 <lambdabot> Title: Newgrounds presents: Space Duck, http://tinyurl.com/yujrmd
02:55:50 <Cale> fasta: hmm
02:55:52 <dancor> is there a backwards map
02:56:00 <Cale> dancor: backwards?
02:56:07 <dancor> pam [+ 1, + 2] 3 = [4, 5]
02:56:31 <nornagon> map ($)
02:56:35 <rahikkala> I asked that a couple of days ago
02:56:39 <nornagon> er, hm
02:56:47 <rahikkala> The other good answer is... sequence :(
02:56:50 <Cale> dancor: not in the libraries, but you can construct one from map
02:57:12 <int-e> dancor: do you mean [(+1), (+2)] ?
02:57:13 <dancor> k
02:57:17 <dancor> int-e: yeah
02:57:19 <njd> @pt \x -> (minimum x, maximum x)
02:57:19 <lambdabot> Maybe you meant: ft pl
02:57:28 <Elifant> > map ($ 3) [(1+), (2+)]
02:57:29 <lambdabot>  [4,5]
02:57:35 <Cale> @let swing f c a = (f ($ a)) c
02:57:36 <lambdabot> Defined.
02:58:01 <Cale> :t swing map
02:58:03 <int-e> @type flip (map . flip id)
02:58:03 <lambdabot> Not in scope: `swing'
02:58:04 <lambdabot> forall c a. [a -> c] -> a -> [c]
02:58:06 <Cale> :t L.swing map
02:58:07 <njd> @pl \x -> (minimum x, maximum x)
02:58:08 <lambdabot> Couldn't find qualified module.
02:58:08 <lambdabot> liftM2 (,) minimum maximum
02:58:10 <rahikkala> > sequence [(1+), (2+)] 3
02:58:10 <nornagon> > swing map 3 [(+1), (+2)]
02:58:12 <lambdabot>  [4,5]
02:58:12 <lambdabot>   add an instance declaration for (Num [[a -> a] -> b])
02:58:16 <Cale> hmm
02:58:21 <njd> @ft \x -> (minimum x, maximum x)
02:58:23 <lambdabot>  There was an error in the type: (line 1, column 15):
02:58:23 <int-e> rahikkala: right
02:58:23 <lambdabot>  unexpected type constructor 'Ord' (this type constructor is not declared)
02:58:32 <roconnor> > sequenc [(1+),(2+)] 3
02:58:32 <lambdabot>   Not in scope: `sequenc'
02:58:34 <Cale> > swing map [(+1),(+2)] 3
02:58:36 <lambdabot>  [4,5]
02:58:37 <roconnor> > sequence [(1+),(2+)] 3
02:58:38 <lambdabot>  [4,5]
02:58:53 <Cale> sequence is clever :)
02:58:54 <mauke> @remember TRWBW category theory gives math a bad name. sorta like functional programming does with computer science.
02:58:56 <lambdabot> Done.
02:59:01 <nornagon> :t swing map
02:59:02 <nornagon> :t sequence
02:59:03 <lambdabot> Not in scope: `swing'
02:59:04 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
02:59:10 <roconnor> sequence solves all problems
02:59:11 <nornagon> doh.
02:59:21 <fasta> Cale: any idea?
02:59:38 <int-e> > sequence (replicate 3 "01")
02:59:40 <lambdabot>  ["000","001","010","011","100","101","110","111"]
02:59:54 <nornagon> O_o
03:00:14 <Cale> fasta: I think it just expects the module name to reflect its search path for the module.
03:00:15 <nornagon> ?!??!??!?!???!?!!?
03:00:16 <lambdabot> Unknown command, try @list
03:00:23 <nornagon> totally :(
03:00:28 <fasta> Cale: but why does it work in fps then?
03:00:31 <roconnor> I think monads just blew nornagon's mind ;)
03:00:36 <Cale> That I wouldn't know
03:00:43 <Cale> nornagon: It's the list monad
03:00:47 <nornagon> > replicate 3 "01"
03:00:49 <lambdabot>  ["01","01","01"]
03:01:02 <nornagon> :t sequence
03:01:04 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:01:05 <Cale> If you know what sequence does in general, and apply that understanding to the list monad, it won't be so surprising.
03:01:07 <mauke> > sequence [[1,2,3],[4,5,6]]
03:01:09 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
03:01:36 <nornagon> i don't know what sequence does in general :P
03:01:39 <nornagon> @src sequence
03:01:39 <Cale> sequence [] = return []; sequence (x:xs) = do {y <- x; ys <- sequence xs; return (y:ys)}
03:01:40 <lambdabot> sequence ms = foldr k (return []) ms
03:01:40 <lambdabot>     where
03:01:40 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
03:02:04 <Cale> or you can write it that way if you want, but that's more confusing
03:02:12 <nornagon> mm
03:02:29 <nornagon> still not sure why it does that
03:02:47 <Cale> okay, so you know how in the list monad,  x <- [1,2,3]  acts like in a comprehension
03:02:55 <Cale> x is chosen in all possible ways from [1,2,3]
03:02:55 <nornagon> ohh.
03:03:01 <nornagon> i guess i get it now, then.
03:03:07 <nornagon> scary.
03:03:07 <Cale> :)
03:03:21 <int-e> fasta: you have fps installed already, haven't you
03:03:38 <roconnor> rahikkala: ah sorry, scrolling back I see that you mentioned sequence already
03:03:42 <fasta> int-e: probably, good observation
03:03:57 <roconnor> I just glance up and saw the conversation
03:04:03 <roconnor> glanced
03:04:25 <roconnor> @karma+ sequence
03:04:25 <lambdabot> sequence's karma raised to 1.
03:04:26 <rahikkala> roconnor: Don't worry, I'd never have actually come up with it myself, I only knew it because I had asked about it before
03:04:39 <syntaxfree> I think the darcs repository for lambdabot is down.
03:05:51 <fasta> int-e: that was it.
03:06:37 <int-e> fasta: you can play with ghci -i<dir> I suppose
03:06:56 <fasta> int-e: but that requires to hard code paths.
03:06:59 <syntaxfree> in fact, cse.unswd.edu.au is down.
03:07:29 <syntaxfree> s/unswd/unsw
03:07:44 <fasta> int-e: it breaks the whole interactive development idea.
03:07:54 <blackdog_> syntaxfree: hah. <schadenfreude>
03:08:03 <fasta> int-e: (not the paths, but when you don't hard code it)
03:08:07 <blackdog_> i knew this would happen when they fired us all :)
03:08:17 <syntaxfree> I don;t know what schadenfreude is.
03:08:22 <fasta> Darcs has a flat name space. I now understand why...
03:08:26 <blackdog_> german for guilty pleasure
03:09:00 <int-e> german for schadenfreude :)
03:09:05 <fasta> int-e: hmm, nm, I know a brute-force solution.
03:09:08 <int-e> that's an english word, too.
03:09:25 <syntaxfree> Where's the schadenfreude in that?
03:09:33 <int-e> fasta: -i.. -i../.. -i../../.. ?
03:09:51 <fasta> int-e: dir_n doesn't understand -i..
03:09:57 <int-e> aww :/
03:09:58 <syntaxfree> (btw, I can open the lambdabot repois in Safari, but it takes a long time to load. darcs just gives up; I wish I could increase ts timeout setting)
03:10:42 <fasta> int-e: I can work around it myself by doing some Elisp
03:10:57 <fasta> int-e: but imo, the situation is broken.
03:11:25 <syntaxfree> how can I get a list of which cabal modules ghc has installed?
03:11:51 <fasta> ghc-pkg -list
03:11:57 <syntaxfree> merci.
03:14:18 <blackdog_> i used to work for UNSW as tech-support - shortly after i left, they replaced most of my colleagues with a discussion board
03:14:46 <dcoutts> AStorm, you can get the latest Gtk2Hs tarball
03:15:06 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.tar.gz
03:15:10 <syntaxfree> ah, heh.
03:16:13 <syntaxfree> why darcs get copies hudnreds of patches and applies them, as opposed to getting just the pristine tree?
03:16:24 <njd> @hoogle sortBt
03:16:25 <lambdabot> No matches found
03:16:27 <njd> @hoogle sortBy
03:16:28 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:16:37 <int-e> fasta: hmm.  ghci -i..  then  :l UI.UI: [1 of 1] Compiling UI.UI            ( ../UI/UI.hs, interpreted )
03:16:52 <fasta> int-e: Yes, I already was doing that.
03:17:06 <fasta> int-e: Now, I only need to convince Emacs of that.
03:17:32 <JohnMeacham> anyone have a nice RangeSet module?
03:18:25 <JohnMeacham> as in, like  Data.Set, but efficiently handles things like containing all the numbers (1 .. 100). ideally it should support both open and closed ranges, but that is not vital.
03:18:44 <blackdog_> syntaxfree: well, in that the server fell over since we all left... :)
03:18:54 <syntaxfree> yes, yes.
03:18:59 <syntaxfree> now I understand the schadenfreude.
03:19:05 <blackdog_> sorry for intermittence. this connection blows goats.
03:19:09 <syntaxfree> (sounds a lot like sado-freud to me :P)
03:20:10 <dons> http://michaelfeathers.typepad.com/michael_feathers_blog/2007/01/haskell_and_the.html
03:20:12 <lambdabot> Title: Michael Feathers' Blog: Haskell and the Great Verb Drought of 1998, http://tinyurl.com/2g438f
03:20:26 <blackdog_> heya don
03:20:32 <dancor> so i can throwDyn whereever i want?
03:20:39 <dancor> or only in an IO returning fcn?
03:20:43 <dons> hey blackdog_
03:20:47 <dons> hey, seen hpaste.org?
03:20:58 <dancor> i can only catch in IO
03:21:01 <blackdog_> no. should i?
03:21:08 <dons> haskell powered web dev in 2 days :)
03:21:10 * syntaxfree is composing the Data.Syntaxfree song.
03:21:34 <syntaxfree> Sung to the Lumberjack Song tune. "I'm not a Haskell hacker, I'm dr. k" ;)
03:21:46 <wolverian> dons, the naming thing has been bugging me a lot, too. I mean, vim can autocomplete for me. :)
03:22:04 <dcoutts> dons, 74 packages in hackage I note
03:22:08 <dons> yeah, its really only the Prelude et al that have the historical names
03:22:16 <dons> dcoutts: yeah, i've got a bunch more to upload to
03:22:25 <dons> then i'll go and find all the gpl/bsd ones from the hwn backlog
03:22:27 <dons> and upload them
03:22:34 <dcoutts> dons, nice
03:22:44 <dcoutts> I've probably got some others I can find too
03:22:44 <dons> dcoutts: but its actually usable now
03:22:48 <dons> even without cabal-get on my box
03:22:49 <AStorm> dcoutts, installed that a while ago :P
03:22:55 <blackdog_> dons: hm. sounds tasty - i am getting so annoyed by RoR...
03:22:58 <dcoutts> AStorm, ok, great :-)
03:22:59 <dons> (can we get cabal-get released as a standalone package?)
03:23:10 <dons> blackdog_: yeah, all just runs on Happs + haxml
03:23:19 <dcoutts> dons, dunno, it's great to have it come by default with cabal
03:23:19 <dons> and was actually fun to write
03:23:27 <dons> dcoutts: yeah. i want it on my machine now though
03:23:44 <syntaxfree> Happs is interesting, yes.
03:23:55 <syntaxfree> Been playing with it till I dropped asleep.
03:24:04 <wolverian> hah, funny. he says foldr should be an operator. in perl6, it is. :)
03:24:09 <Elifant> hm... it's strange that 'double x x:xs = ...' doesn't work... shouldn't it?
03:24:20 <dons> what's an operator though?
03:24:25 <syntaxfree> dons: when I darcs get something, I already have a local repository, right?
03:24:26 <dons> :t foldlr1
03:24:27 <dcoutts> dons, there's no problem in upgrading cabal, you can have several versions installed at once
03:24:28 <lambdabot> Not in scope: `foldlr1'
03:24:35 <syntaxfree> (I dnn't need to go sround darcs adding stuff)
03:24:39 <dons> :t foldl1
03:24:41 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:24:55 <mauke> Elifant: double y (x : xs) = ...
03:24:56 <dons> ?let (<.>) = foldl1
03:24:57 <lambdabot> Defined.
03:25:00 <wolverian> dons, I think with 'operator' he means something that isn't a word. I think.
03:25:13 <dons> > (const (+1)) <.> [1..10]
03:25:14 <wolverian> (yes, I really think!)
03:25:15 <lambdabot>  11
03:25:17 <musasabi> Is http://darcs.haskell.org/HList/ the current hlist repository?
03:25:17 <lambdabot> musasabi: You have 1 new message. '/msg lambdabot @messages' to read it.
03:25:19 <lambdabot> Title: Index of /HList
03:25:45 <dons> dcoutts: so i'm just going to only get things from hackage now
03:25:50 <Elifant> mauke: I know how to get it working, I just wonder why isn't 'double x x:xs' is the same as 'double x y:xs | x == y'
03:25:51 <musasabi> syntaxfree: runghc setup haddock creates up-to-date haddock documentation.
03:25:53 <dons> and if they're not on hackage, i'll email the author
03:26:20 <syntaxfree> oh good. thanks.
03:26:24 <wolverian> well, okay, in perl6 it's actually a metaoperator: [+] (1,2,3,4), or [>] (1,2,3,4), etc. I'm too tired to make any observations from that right now though.
03:26:26 <musasabi> Is managing packages in hackage documented somewhere?
03:26:45 <dons> in what sense?
03:26:49 <dons> 'managing'?
03:26:50 <mauke> Elifant: oh, I thought you meant the parse error for x:xs
03:27:04 <wolverian> (the latter works because of a property of the > operator; it has arbitrary arity. anyway. gotta run)
03:27:06 <dcoutts> dons, we need people to test cabal-get so that we can do a new cabal release and get everyone else using cabal-get
03:27:07 <dons> musasabi: you want to upload something?
03:27:10 <musasabi> dons: some way of automatically setting that up with darcs workflow.
03:27:13 <dons> dcoutts: right
03:27:26 <dcoutts> dons, that means you need to test it! :-)
03:27:34 <musasabi> dons: e.g. with HAppS most people want to use HEAD and that has a new version every day.
03:27:43 <dons> dcoutts: ok. i will in the morning, to add it to the binary install instrs
03:27:55 <dons> musasabi: yeah, we need more darcs integratoin
03:28:06 <dons> i think there's a plan to allow a darcs repo url
03:29:05 <bakert> What's the best way to represent an moment in time in haskell?  To the minute, say, or better.
03:29:12 <dons> Integer?
03:29:40 <bakert> Is there a lib that will parse strings into Integers?
03:29:52 <dons> what kind of strings?
03:29:59 <dons> > read "12342124132212321"
03:30:00 <lambdabot>  Add a type signature
03:30:02 <dons> > read "12342124132212321" :: Integer
03:30:04 <lambdabot>  12342124132212321
03:30:18 <bakert> Sorry no I mean date strings.  So I give it the date format and it gives me seconds since epoch or something similar.
03:30:24 <dons> ah yes, check hackage
03:30:26 <dons> ?where hakcage
03:30:27 <lambdabot> I know nothing about hakcage.
03:30:32 <dons> ?where hackage
03:30:32 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
03:30:36 <rahikkala> > read "12342124132212321" :: Int
03:30:38 <dons> parseTime, iirc
03:30:38 <lambdabot>  -1263755679
03:30:43 <bakert> cool. thanks dons
03:31:31 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsedate/2006.6.4
03:31:33 <lambdabot> http://tinyurl.com/2xydt3
03:32:12 <bakert> That's great.  There's nothing in the standard libraries I take it?  What IS hackage?
03:32:31 <dons> its the central collectoin of 3rd party libs
03:32:36 <dons> cpan
03:32:43 <dons> ?docs System.Time
03:32:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
03:32:52 <dons> but i don't think there's any time parsing in there?
03:32:53 <bakert> Ah.  I wonder how I never heard of it before!
03:33:08 <dons> we only decided today to tell everyone to use it
03:33:14 <bakert> Oh!
03:33:27 <dons> things move fast in lambda land
03:33:31 <bakert> They sure do!
03:34:24 <dons> dcoutts: you think we're at a point we should link to hackage off the front page
03:34:27 <dons> of h.o?
03:34:42 <dcoutts> dons, hmm
03:34:50 <dcoutts> dons, can we do some cleanup and testing?
03:34:55 <dons> yeah ok :)
03:35:01 <dcoutts> like make the urls nicer, make sure cabal-get works
03:35:03 <dcoutts> advertise it
03:35:14 <dons> i need to get this running locally so we can tune it up like hpaste
03:35:19 <dons> make it pretty and fast
03:35:21 <dcoutts> otherwise we're making people do lots of manual downloading and dep resolution
03:35:25 <dons> yeah
03:35:59 * syntaxfree raises his hand
03:36:06 <dons> and get gtk2hs up there
03:36:11 <dons> some of the big things are missing
03:36:18 <dons> not agile enough!
03:36:22 <dcoutts> dons, it's not cabalised :-(
03:36:35 <dcoutts> cabal needs more work to get gtk2hs done
03:36:44 <dons> mm
03:36:53 <dons> night all
03:36:55 <dcoutts> cabal needs dependency chasing
03:37:00 <dcoutts> to do c2hs properly
03:37:09 <dcoutts> g'night dons
03:37:10 <hpaste>  rahikkala pasted "Any other scary things to do by applying sequence in different monads?" at http://hpaste.org/90
03:37:28 <kolmodin> it does do c2hs, somewhat.. :)
03:37:43 <gour> are there yaml bindings for haskell?
03:38:42 <shoffsta> bringert: is there a reason for why 'runFastCGI' has the type "CGIT IO CGIResult -> IO ()" in stead of "CGIT m CGIResult -> m ()" like runCGI?
03:40:08 <dcoutts> hmm, dons, to get our byte copying loops faster in ghc we need to get a byte copying loop into the shootout so we can apply pressure to make the ghc version faster ;-)
03:40:22 <csci> gour: I'd also be interested in those
03:41:00 <gour> csci: i heard that audreyt was/is working on it, but cannot find anything
03:41:53 <syntaxfree> I can't believe it.
03:42:01 <syntaxfree> It appears ... lambdabot ... built ...
03:49:47 <hpaste>  fasta pasted "(no title)" at http://hpaste.org/91
03:58:03 <SamB> syntaxfree: isn't that supposed to happen?
04:04:14 <syntaxfree> SamB: I've been trying to build it, on and off, for months.
04:04:23 <syntaxfree> Now it built. But it won't run.
04:04:24 <syntaxfree> Le sigh.
04:04:35 <beelsebob> moin all
04:04:54 <beelsebob> is there an IO action for detecting an EOF?
04:05:30 <beelsebob> or more to the point, end of input
04:06:01 <syntaxfree> I was thinking, "Isn't \eof an explicit character?"
04:06:32 <beelsebob> well yes - that's what I though
04:06:34 <beelsebob> t
04:06:39 <beelsebob> but getChar blocks on eof
04:06:52 <syntaxfree> hGetChar is supposed to be the general form of that.
04:06:57 <syntaxfree> @type hGetChar
04:06:58 <lambdabot> Not in scope: `hGetChar'
04:07:04 <syntaxfree> :t hgetChar
04:07:05 <lambdabot> Not in scope: `hgetChar'
04:07:14 <syntaxfree> bah. Don't listen to me.
04:07:21 <malebria> Is it possible to create a haskell call to a C function making it pure?
04:07:47 <ski> @hoogle eof
04:07:48 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
04:07:49 <lambdabot> Text.Read.EOF :: Lexeme
04:07:49 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
04:07:56 <musasabi> malebria: yes
04:07:56 <ski> @hoogle iseof
04:07:57 <lambdabot> IO.isEOF :: IO Bool
04:07:57 <lambdabot> IO.isEOFError :: IOError -> Bool
04:07:57 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
04:08:00 <malebria> like if I have a C function int plus2 (int i) { return (i + 2);}
04:08:19 <malebria> musasabi: is c2hs the best option to call C functions?
04:08:51 <syntaxfree> musasabi: interesting. Haskell just discards any side-effects the function might have?
04:09:21 <musasabi> syntaxfree: no, it just pretends there are none. unsafe if the function *does* have side-effects.
04:09:37 <syntaxfree> musasabi: well, that's what I just said ;)
04:09:44 <musasabi> malebria: if it is complicated then c2hs helps, if it is simple a plain foreign import declaration is enough.
04:09:47 <beelsebob> ah, cool
04:09:58 <malebria> musasabi: where can I find doc about it?
04:10:02 <syntaxfree> That sounfd like a good way to safely insert "unsafe" behaviour into Haskell programs.
04:10:17 <syntaxfree> Instead of mucking about with unsafeInterleaveIO, write in C.
04:11:00 <beelsebob> bugger, I appear to have broken it
04:11:07 <beelsebob> but I didn't think I'd edited the code :(
04:12:11 <musasabi> malebria: there is http://www.cse.unsw.edu.au/~chak/haskell/ffi/, but finding a tutorial might be better.
04:12:12 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
04:12:35 <malebria> musasabi: thanks.
04:12:49 <musasabi> syntaxfree: actually the C way can be more unsafe and problematic.
04:13:24 <profmakx> dumb question: how do I satisfy the "binary-any" dependency in lambdabot? (Im using ghc-6.6 on FreeBSD)
04:13:25 <syntaxfree> are foreign functions imported "monadically"?
04:13:43 <musasabi> @where binary
04:13:43 <lambdabot> http://darcs.haskell.org/binary
04:13:56 <profmakx> thankx musasabi
04:14:02 <syntaxfree> I mean, will f(i} { return (i+2);} become something like Int -> FFI Int?
04:14:09 <syntaxfree> or can you recover an Int -> Int function?
04:14:28 <musasabi> "foreign import ccall f :: Int -> IO Int"
04:14:43 <musasabi> then there is safe vs unsafe too.
04:15:47 <AStorm> This one is safe, as it doesn't allocate memory, so you can mark it "unsafe" :>
04:16:23 <AStorm> Actually, you could do that as Int -> Int too
04:16:26 <Igloo> If you have int's on the C side then you need CInt's on the Haskell side, not Int's
04:16:39 <syntaxfree> oh. for a while I thought you could cheat the system and get an Int -> Int unction.,
04:16:42 <AStorm> Igloo, it would work still, by converting
04:16:53 <AStorm> syntaxfree, yes, you can
04:16:53 <SamB> AStorm: eh?
04:16:55 <beelsebob> a, that's better
04:16:59 <musasabi> Igloo: point.
04:17:01 <beelsebob> just need to change the buffering mode now
04:17:03 <Igloo> It wouldn't work, it would be buggy
04:17:08 <AStorm> Igloo, yes :P
04:17:37 <AStorm> BTW, why doesn't Haskell have such nice type class syntax as ML?
04:17:48 <Cale> ML has typeclasses?
04:17:50 <SamB> what?
04:17:56 <sieni> Que?
04:17:59 <SamB> I never thought I'd hear that one!
04:18:00 <AStorm> Cale, structures
04:18:12 <syntaxfree> I thought Haskell had type classes and ML had functors.
04:18:21 <dancor> i have a test file that calls a bunch of fcns and prints as it calls them
04:18:23 <Cale> I suppose there's technically an equivalence there.
04:18:26 <sieni> ML functors <3
04:18:39 <syntaxfree> I've heard they're good, yes.
04:18:58 <syntaxfree> How do ML functors relate to cat theory functors and Haskell functors?
04:19:20 <dancor> is it cool to have something like showAndCall :: (a -> a) -> Dynamic -> IO ()
04:19:52 <SamB> dancor: that wouldn't do much for you
04:20:22 <dancor> SamB: it would putStrLn $ show $ arg
04:20:31 <dancor> actually i would want to print the fcn name too
04:20:46 <dancor> maybe i should just write them out
04:20:50 <bakert> Is CalendarTime not in the current System.Time?
04:20:54 <bakert> ?hoogle CalendarTime
04:20:55 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
04:20:56 <lambdabot> System.Time.CalendarTime :: data CalendarTime
04:20:56 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
04:21:02 <dancor> or pass in the fcn name
04:21:06 <dancor> as a string
04:21:06 <dancor> too
04:21:15 <dancor> what do you guys think
04:21:23 <dancor> am i just risking death using Dynamic
04:21:30 <Cale> I'm not sure that ML functors have anything to do with the category theoretic sort.
04:21:31 <malebria> http://www.haskell.org/pipermail/haskell/2007-January/019040.html
04:21:33 <lambdabot> Title: [Haskell] A history of Haskell
04:21:39 <malebria> Is this link broken or am I missing something?
04:22:48 <AStorm> ?where history-of-haskell
04:22:48 <lambdabot> I know nothing about history-of-haskell.
04:22:50 <AStorm> :/
04:22:53 <Cale> http://camwwwdev/~simonpj/papers/history-of-haskell/index.htm is obviously broken, but the replacement for camwwwdev should not be hard to fine
04:22:55 <Cale> find*
04:23:23 <Cale> In fact, it's just research.microsoft.com
04:23:25 <Cale> http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
04:23:28 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
04:23:47 <Syzygy-> I want to use the list and IO monads at the same time.
04:24:20 <Cale> dancor: what are you trying to accomplish?
04:24:21 <Syzygy-> To be specific, for each item in a list I want to generate a random number and use that for something that's purely functional once I have the list member and the random number.
04:24:32 <AStorm> Why does the domain name "research.microsoft.com" sound evil? :P
04:24:38 <AStorm> And oxymoronic
04:24:39 <Syzygy-> How do I reasonably go at it?
04:24:45 <Syzygy-> AStorm: Because of FUD.
04:25:01 <Cale> Syzygy-: I'd use randoms to get an infinite list of randoms, and just zip that with my existing list.
04:25:10 <Syzygy-> Cale: Hmmmmm...
04:25:12 <dancor> Cale: encapsulate the functionallity of running a test function with a test argument and also printing out a line to say that we did it
04:25:17 <Cale> and then go off and do whatever from that point on
04:25:25 <bakert> AStorm, because it's the research arm of a terrible company.
04:25:27 <dancor> Cale: but the arg type changes
04:25:52 <Cale> dancor: maybe something like (a -> Bool) -> a -> IO () ?
04:26:09 <dancor> Cale: oh.. duh
04:26:15 <dancor> <- n00b
04:26:20 <AStorm> I though Microsoft doesn't do any research - they just buy or steal good ideas...
04:26:20 <Syzygy-> Cale: How does that work?
04:26:23 <AStorm> *thought
04:26:40 <SamB> AStorm: well, I'm not sure whether or not they do anything with their research
04:27:34 <bakert> AStorm, it's like the dodgy millionaire who opens a library in his name.
04:27:35 <dancor> Cale: and there's no way to reflectively determine the fcn name right
04:27:51 <Cale> dancor: right, that's destroyed by compilation
04:27:55 <pejo> AStorm, except they have many of the most competent researchers in the field on their employment list.
04:27:56 <dancor> k
04:28:09 <Cale> dancor: So just pass the test name as a String or something
04:28:10 <syntaxfree> AStorm: MIcrosoft, for one, came up with XMLHTTPRequest, for one.
04:28:19 <Cale> Syzygy-: you want an example?
04:28:22 <AStorm> pejo, indeed :>
04:28:23 <syntaxfree> I said for one twice.
04:28:33 <Cale> Syzygy-: It's going to end up in IO, of course.
04:28:40 <Cale> Syzygy-: do { g <- newStdGen; let rs = randoms g; print rs }
04:28:42 <syntaxfree> anyway, Microsoft is really pushing for functional programming right now, and Unix is being a backwards force.
04:28:51 <syntaxfree> (some people would argue it has always been so)
04:29:18 <Cale> (nevermind the underdetermined types there :)
04:29:36 <AStorm> syntaxfree, tell that to Vista :P
04:29:41 <Cale> rs is an infinite list of random values.
04:29:45 <dancor> Cale: can i use curry to extend this to fcns taking multiple args
04:29:50 <AStorm> But yes, I'd love to see that Synergy research OS...
04:29:55 <bakert> syntaxfree, i don't think there's exactly a companywide push to functional programming.
04:30:04 <syntaxfree> bah, Microsoft is adding nice FP  features to the mainstream .NET languages.
04:30:13 <bakert> true.
04:30:14 <syntaxfree> They're also pushing a freaking ML with the next .NET
04:30:20 <syntaxfree> F#
04:30:36 <AStorm> Anyway, Haskell.NET awaits :P
04:30:37 <Cale> dancor: Sure, though actually the best thing is probably just to have it take a Bool, or if you possibly need IO, an IO Bool.
04:30:47 <Cale> (might be worth two versions)
04:31:03 <syntaxfree> there was one once, but it's probably bit-rotted
04:31:08 <Cale> Like,  test :: String -> Bool -> IO ()
04:31:09 <syntaxfree> @google mondrian internet scripting
04:31:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg06174.html
04:31:10 <lambdabot> Title: First release of Mondrian: an internet scripting language
04:31:23 <Cale> The Bool is just whether the test succeeds or not :)
04:31:36 <Syzygy-> Cale: Thanks!
04:31:39 <dancor> Cale: ah.  cool
04:31:54 <Cale> dancor: Or are you generating lots of inputs for the test functions?
04:32:15 <Cale> If you're trying to do some random testing, look at quickcheck.
04:32:20 <syntaxfree> Post-Netscape Microsoft has been generating a few important innovations, imo.
04:32:27 <Cale> In fact, look at quickcheck regardless :)
04:32:33 <dancor> Cale: heh ok
04:32:34 <syntaxfree> I mean, AJAX, damn.
04:38:47 <AStorm> Hmm, are there any nice descriptions of Y combinator on the net?
04:39:15 <AStorm> (except Wikipedia)
04:39:32 <Cale> You could go with the lecture from SICP
04:40:21 <malebria> Thus, they do not provide solutions applicable to real-life problems. To
04:40:31 <malebria> apply these ideas in practice, we need to integrate functional and imperative
04:40:32 <malebria> programming.
04:40:47 <malebria> http://geoinfo.info/geoinfo2006/papers/p29.pdf
04:40:58 <malebria> Do you agree with this?
04:41:12 <AStorm> I agree that Haskell does provide imperative programming.
04:41:14 <AStorm> :P
04:41:32 <sieni> AStorm: e.g. http://dangermouse.brynmawr.edu/cs245/ycomb_jim.html
04:41:34 <lambdabot> Title: Y-Combinator
04:41:41 <sieni> if scheme version is ok
04:41:59 <syntaxfree> the meat is before the "thus"!
04:42:00 <AStorm> Ok with me.
04:42:03 <Cale> malebria: absolutely, that's what the IO monad does :)
04:42:17 <syntaxfree> what hazard does purity bring forward according to him?
04:43:12 <syntaxfree> what is this "real life" I keep hearing about anyway?
04:43:33 <kaol> @google real life
04:43:35 <lambdabot> http://www.reallifecomics.com/
04:43:35 <lambdabot> Title: Real Life Comics - The Online Comic 1999-2006 Greg Dean
04:43:41 <malebria> Cale: but he's talking about ffi
04:43:44 <kaol> there you go
04:43:53 <AStorm> We do have FFI too.
04:44:49 <Cale> Well, I don't know whether you really have to use the FFI to get real work done, but it's there if you need it.
04:45:08 <syntaxfree> Cale: real work might involve exploiting complex libraries written by other people.
04:45:15 <Cale> Yeah
04:45:25 <AStorm> Haskell's FFI is really nice. Compare with Python FFI :P
04:45:30 <malebria> Sure, but I thing this gives an idea that haskell can only be used in real-work if we use ffi.
04:45:30 <Cale> If you want to use libraries someone else in C, then certainly :)
04:45:38 <AStorm> (where you just write C code and hope it works :P )
04:45:41 <syntaxfree> I haven't been able to use Haskell in my "real work" because I need the statistic functions provided by my Other Programming Environment, GNU R.
04:45:45 <Cale> Yeah, that wouldn't be true.
04:45:56 <syntaxfree> Of course, most of what GNU R does could be rewritten in Haskell.
04:46:05 <syntaxfree> But a lot of it depends on Ancient Routines Imported from Fortran.
04:46:07 <AStorm> syntaxfree, because you're too lazy to either rewrite or use FFI? :P
04:46:29 <Cale> Does R export functionality cleanly?
04:46:46 <syntaxfree> because there's a LOT to be rewritten, and I'm supposed to be doing research.
04:47:07 <syntaxfree> (Of course I'm not doing any, I'm sinking in a huge horrible emotional swamp)
04:47:14 <AStorm> http://www.gnu.org/software/r/R.html this thingy
04:47:16 <lambdabot> Title: R - GNU Project - Free Software Foundation (FSF)
04:47:27 <syntaxfree> http://www.r-project.org is really better.
04:47:29 <lambdabot> Title: The R Project for Statistical Computing
04:47:33 <bakert> ?hoogle liftIO
04:47:33 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
04:47:37 <pejo> What is the point of rewwriting fully functional things anyways? We'd get more publicity if we wrote something new that is revolutionary.
04:48:06 <bakert> Hmm .. how do I get liftIO?
04:48:11 <syntaxfree> well,I keep on writing R code that somehow assumes laziness and miss out on performance by using procedural best practices.
04:48:26 <syntaxfree> that's not really important, though, because all I'm trying to do is crunch the numbers for research.
04:48:26 <bakert> ?type liftIO
04:48:28 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
04:48:37 <pejo> syntaxfree, there is a performance hit with laziness too.
04:48:38 <syntaxfree> Datasets in economics are usually small, so code complexity is *whatever*.
04:48:51 <AStorm> pejo, and sometimes, a gain
04:48:55 <AStorm> :P
04:48:57 <syntaxfree> pejo: part of the problem is that I never learned procedural best practices.
04:49:16 <syntaxfree> My R code tends to look like Haskell code. Lotsa functions.
04:49:20 <AStorm> syntaxfree, the best practice is not to use recursion
04:49:25 <syntaxfree> (R has first-class functions).
04:49:31 <AStorm> Any other are just derived from that.
04:49:37 <syntaxfree> Ah, yes. R screws up recursion because of some namespace trickery.
04:49:44 <pejo> Having lots of functions isn't dependent on lazy evaluation though, you'd write lots of functions in ML too.
04:49:47 <syntaxfree> I keep on recalculating results because my code is so "functional".
04:50:12 <Saizan> syntaxfree, you just need to read something about memoization :)
04:50:16 <AStorm> syntaxfree, no, because you can't do memoisation :P
04:50:21 <AStorm> ?where memoisation
04:50:22 <lambdabot> I know nothing about memoisation.
04:50:26 <AStorm> ?where memoization
04:50:26 <lambdabot> I know nothing about memoization.
04:50:33 <AStorm> Add something there :>
04:50:41 <syntaxfree> Instead of writing x<-doLargeComputation; y<-f(x,x,y), I do y<-f(doLargeComputation,doLargeComputation,y)
04:50:51 <syntaxfree> gah, bad variable names.
04:51:38 <syntaxfree> anyway, that's really not important, but I can think of a number of ways I could abstract common patterns in econometric practice into combinators.
04:51:41 <AStorm> syntaxfree, so, just factor it out a bit
04:51:49 <syntaxfree> With GNU R, that's really limited.
04:51:50 <AStorm> In Haskell I'd use "where" notation
04:52:22 <syntaxfree> there are first-class functions, but stuff becomes unmanageable fast.
04:52:35 <bakert> ?pointful reports = map (renderHtml . reportToHtml . report)
04:52:36 <lambdabot> reports = map (\ c -> renderHtml (reportToHtml (report c)))
04:52:42 <malebria> We rely on imperative languages such as C++ to provide spatial
04:52:42 <malebria> database support
04:52:51 <syntaxfree> anyway, I'd like to have a pro-level statistical environment like R in Haskell.
04:52:52 <malebria> http://www.dpi.inpe.br/gilberto/teses/tese_sergio.pdf
04:52:54 <boegel> dons: what up with @vixen?
04:52:57 <boegel> @shapr
04:52:58 * lambdabot smacks  about with a large trout
04:53:12 <boegel> @vixen I said "shapr", not "slap" you dumb cunt
04:53:13 <lambdabot> <undefined>
04:53:15 <boegel> ???
04:53:16 <pejo> AStorm, the gains from lazy evaluation are when you are computing something unecessary otherwise. The performance hit is as soon as you perform unecessary indirect jumps. (Discarding space usage).
04:53:22 <dancor> intransitive smackings about
04:53:30 <bakert> ?seen shapr
04:53:31 <lambdabot> I saw shapr leaving #scannedinavian and #haskell 19h 50m 38s ago, and .
04:53:32 <syntaxfree> @. slap quote
04:53:32 * lambdabot beats up Excedrin says: isn't OO deprecated?
04:54:01 <Syzygy-> ?hoogle [IO String] -> IO [String]
04:54:02 <lambdabot> No matches, try a more general search
04:54:11 <Syzygy-> ?hoogle [IO a] -> IO [a]
04:54:12 <lambdabot> No matches, try a more general search
04:54:20 <syntaxfree> I keep on feeling Haskell could actually do some symbolic computation with stochastic variables before doing things numerically.
04:54:20 <Syzygy-> ?hoogle [m a] -> m [a]
04:54:21 <lambdabot> Prelude.head :: [a] -> a
04:54:21 <lambdabot> Prelude.last :: [a] -> a
04:54:21 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
04:54:39 <syntaxfree> But hell, there's way too much plumbing to be done.
04:54:53 <malebria> Isn't this fallacy?
04:55:24 <bakert> Syzygy-, that's the exact function I'm looking for.  Is it liftIO?
04:55:47 <syntaxfree> I don't know.
04:55:54 <AStorm> map (concat . liftIO) thosemonads ?
04:55:57 <syntaxfree> It seems to me they just want to use the spatial databases they already have.
04:56:03 <roconnor> ?type sequence
04:56:05 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
04:56:16 <AStorm> Ahem, sequence
04:56:18 <bakert> ah yes thanks roconnor
04:56:26 <roconnor> sequence solves all problems
04:56:32 <syntaxfree> Maybe what they meant with that conclusion is that the government agency in question shouldn't adopt FP full-out yet.
04:56:37 <syntaxfree> It's a government white paper.
04:57:10 <dancor> how does catchDyn work
04:57:17 <dancor> like where is the try block
04:57:37 <syntaxfree> (They're like a mixture of NASA and whoever does climate research in the US)
04:58:41 <AStorm> FEMA? :P
04:59:10 <syntaxfree> not really. FEMA is more like a civil defense agency.
04:59:15 <syntaxfree> I mean, emergency management.
04:59:19 <syntaxfree> Who runs the satellites?
04:59:26 <syntaxfree> They're not all private, are they?
05:03:12 <tuomov_> Um, is there somewhere an implementation of random access lists for haskell?
05:03:15 <tuomov_> I can't seem to find it
05:03:48 <therp> tuomov: !!
05:03:49 <Jaak> you mean arrays?
05:03:56 <therp> @hoogle !!
05:03:57 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
05:03:59 <tuomov_> no, the okasaki stuff
05:04:03 <Jaak> oh
05:04:12 <tuomov_> O(log n) index
05:04:43 <tuomov_> although, I guess I could use arrays too.. I just hate using arrays in haskell
05:04:48 <musasabi> tuomov_: doesn't okasaki have implementations?
05:04:51 <syntaxfree> @. slap google random access lists -abstract
05:04:53 <lambdabot> why on earth would I slap http://java.sun.com/j2se/1.4.2/docs/api/java/util/RandomAccess.html
05:04:53 <lambdabot> Title: RandomAccess (Java 2 Platform SE v1.4.2)
05:04:57 <tuomov_> google doesn't..
05:05:08 <syntaxfree> @. slap google random access lists in haskell -abstract
05:05:09 * lambdabot slaps http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg04431.html
05:05:09 <lambdabot> Title: Re: Random Access Files in Haskell
05:05:16 <syntaxfree> oh well.
05:05:18 <musasabi> tuomov_: page 194.
05:05:54 <musasabi> in Purely Functional Data Structures
05:05:54 <tuomov_> Like I'm going to start typing them up..
05:06:30 <syntaxfree> send me the book and I type them for you!
05:06:32 <tuomov_> actually, I can't use arrays.. I need update too
05:06:48 <syntaxfree> I want the physical book in return, though :)
05:07:08 <sieni> tuomov_: the source code can be downloaded: http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#cup98
05:07:09 <lambdabot> Title: Chris Okasaki's Publications
05:07:27 <tuomov_> ah, there, hidden
05:07:43 <tuomov_> you know, I thought I could find them in the standard GHC Data. hierarchy
05:08:09 <tuomov_> It has everything else and more :)
05:08:32 <Saizan> tuomov_: try DiffUArray s
05:09:12 <Saizan> has the same interface of Array but with fast update
05:09:21 <tuomov_> actually, I probably should design something based on quad-trees or something..
05:09:38 <tuomov_> but I'm too lazy for that, and just trying to speed up a naive list-based algorithm..
05:14:07 <syntaxfree> @where hscolour
05:14:07 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
05:14:22 <tuomov_> well, thanks
05:15:05 * syntaxfree tries t persuade tuomov to write ion for os x once more :)
05:18:05 <earthy> right, ghc's error messages are not adequate
05:18:24 <earthy> pity
05:18:48 <syntaxfree> it seems to me that ghc error messages have greatly improved.
05:18:56 * AStorm tried last time to persuade Tuomov to rewrite Ion3 into Haskell :P
05:19:32 <earthy> syntaxfree: without a doubt
05:19:53 <earthy> however, foisting them upon unsuspecting computerscientists scares them
05:20:29 <earthy> (yeah, I give haskell to statisticians that have not been trained in functional programming)
05:20:37 * therp tried last time not to fork off ion3 because tuomov not having any clue of delivering a good product.
05:20:44 <earthy> 'here, you can do this, it's not hard'
05:21:31 <bakert> How can I do this:
05:21:32 <bakert> mapM_ putStrLn $ reports accounts
05:21:42 <bakert> when reports accounts returns IO [String]
05:21:49 <bakert> or [IO String] (I don't care which)
05:21:50 <bakert> ?
05:22:07 <syntaxfree> heh. I was about to bitch that "reports" and "accounts" had nothing to do with mathematical statistics.
05:22:13 <bakert> I've looked at sequence and liftIO but that's not quite right, is it?
05:24:58 <Jaak> if reports accounts returns IO [String] then maybe you are looking for reports accounts >>= mapM_ putStrLn ?
05:25:22 <bakert> That could be it Jaak let me try it.
05:25:38 <bakert> I am in a do block.  Will that mess everything up?
05:26:11 <AStorm> Yes. Use this instead
05:26:16 <AStorm> x <- reports accounts
05:26:24 <AStorm> mapM_ putStrLn x
05:26:41 <bringert_> well, reports accounts >>= mapM_ putStrLn should work even in a do block
05:26:49 <AStorm> Should, well :P
05:26:57 <AStorm> But won't look right.
05:27:27 <bringert_> depends on your sense of style I guess
05:28:01 <bakert> Hmm.  I think I'm going to try and write a simple version of my problem.
05:28:06 <bringert_> say you want to do ten things, each on the form generate >>= print. then maybe a do-block with >>= lines could be nice
05:29:24 <AStorm> I love shooting arrows and monads :P
05:29:36 <Saizan> mapM_ putStrLn =<< reports accounts -- the most natural imho
05:30:47 <Saizan> i hate the fact that  "x <- foo;" forces me to invent names for intermediate results :)
05:31:19 <bringert_> or putStr . unlines <<= reports accounts
05:32:32 <Saizan> IO comonad?
05:32:40 <bringert_> oops
05:32:44 <bringert_> =<<
05:32:56 <sieni> isn't the comonad OI? :-)
05:33:04 <Saizan> :)
05:34:17 <earthy> weird. naive conversion of the fasta benchmark implementation from the shootout to Data.ByteString.Lazy.Char8 makes the implementation *slower*.
05:34:40 <dcoutts> earthy, how much slower?
05:34:52 <earthy> by a factor of about 3
05:35:06 <earthy> but I realized I forgot to use -O
05:35:09 <dcoutts> earthy, btw remember that the bytestring in base isn't the fastest one, that's still in the fps-experimental branch
05:35:29 <dcoutts> especially for fusion we get about 2x speedup over the current version
05:35:51 <dcoutts> and there's more tuning that could be done for lazy bytestring
05:35:55 <earthy> okay, -O makes the two versions comparable in speed again
05:35:56 <dcoutts> like eliminating an indirection
05:36:19 <earthy> but the bytestring version is still a few percent slower.
05:36:38 <dcoutts> earthy, have you compared the strict and lazy versions
05:36:45 <bakert> AStorm, bringert_, Jaak thanks for your help I have finally got there.  I used >>= because it gets it all on one line.
05:36:47 <earthy> not yet.
05:37:07 <dcoutts> earthy, we usually find that the lazy has about a 10% penalty compared to strict
05:37:18 <earthy> well, this has a 'cycle' in it.
05:37:19 <dcoutts> earthy, until the data sizes become large and then lazy wins
05:37:40 <earthy> so it is definitely very lazily written
05:37:54 <earthy> but I think the formulation doesn't play well with bytestrings
05:38:01 <earthy> writeFasta "TWO" "IUB ambiguity codes" (B.pack (map (chooseBase iub) seq1))
05:38:14 <earthy> where seq1 is a list of doubles.
05:38:31 <earthy> and chooseBase chooses a Char
05:39:57 <notsmack> somebody should outdo www.pythonchallenge.com with HAppS and things that are actually hard :-)
05:40:36 <eightyThree> hey, anybody there who can help a haskell newbie? want to compile a programm i've found, but ghc or hugs cant find the LibSystem module. What's that module for? and where can i find it?
05:40:55 <earthy> eightyThree: you on Mac OS X?
05:41:01 <eightyThree> no linux
05:41:25 <AStorm> eightyThree, broken install
05:41:40 * earthy nods
05:42:07 <eightyThree> does it only work on mac?
05:42:37 <bakert> Hmm.  I think I'm going to try and write a simple version of my problem.
05:43:09 <bringert_> eightyThree: what software is that?
05:43:25 <Saizan> can you tell GHC to compute a function at compile time?
05:43:42 <audreyt> yes, with TH
05:43:46 <bakert> ?hoogle (a -> b) -> m [a] -> m [b]
05:43:47 <lambdabot> No matches, try a more general search
05:44:12 <bakert> ?hoogle Monad m => (a -> b) -> m [a] -> m [b]
05:44:13 <lambdabot> No matches, try a more general search
05:44:13 <audreyt> Saizan: it can even be an IO action, with runIO
05:44:17 <eightyThree> its a game i found in the internet
05:44:26 <bringert_> @type \f -> liftM (map f)
05:44:27 <audreyt> see e.g. http://www.cs.chalmers.se/~nad/repos/ChasingBottoms/Test/ChasingBottoms/TestLibraryWhenCompiling.hs
05:44:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m [a] -> m [b]
05:44:30 <lambdabot> http://tinyurl.com/26wyv8
05:44:55 <bringert_> @type liftM . map
05:44:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
05:44:59 <Saizan> audreyt: thanks
05:44:59 <bringert_> if you want
05:45:19 <audreyt> np :)
05:45:25 <pejo> earthy, how was the talk?
05:45:55 <bakert> bringert_, thanks.  liftM added to the box of tricks with mapM and liftIO!
05:46:10 <Saizan> audreyt: i was trying to write a gadt for type-safe regexes, then i realized that most of the time they are known at compile time..
05:46:15 <bringert_> bakert: fmap should be in your box too
05:46:22 <bakert> don't know fmap
05:46:24 <bringert_> bakert: it's like liftM, but more general
05:46:25 <bakert> will look it up
05:46:28 <bringert_> @type fmap
05:46:29 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
05:46:34 <bringert_> @type liftM
05:46:36 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
05:46:53 <bringert_> all Monads should be Functors
05:46:55 <bakert> ah yes.  functors.  another thing i must look into.
05:47:36 <AStorm> bringert_, impossible :>
05:48:22 <bakert> ?hoogle liftM
05:48:23 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
05:48:24 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
05:48:24 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
05:48:29 <bringert_> AStorm: do you mean that we don't have class Functor m => Monad m, or something else?
05:48:31 <eightyThree> earthy: so you think i should install it again?
05:49:16 <Saizan> functors are quite simple, they are abstract containers with a method to apply a function on all their elements
05:50:01 <bakert> i'll take your word for it at this stage Saizan!
05:50:36 <Saizan> :D
05:50:51 * dcoutts grumbles that the word functor is getting misused by the OOP crowd
05:51:11 <sieni> dcoutts: what about the ML crowd? :-)
05:51:17 <AStorm> bringert_, they're like 1->1 mapping
05:51:20 <AStorm> Monad is not
05:51:26 <dcoutts> sieni, oh, they're ok :-)
05:51:44 <bringert_> AStorm: I don't understand.
05:51:51 <dcoutts> sieni, anyway, I think their useage is correct
05:51:58 <AStorm> Gah.
05:52:15 <bringert_> AStorm: for Monad you can write liftM, which is a special case of fmap. no?
05:52:30 <AStorm> Yes, but a Monad is not a Functor
05:52:38 <dcoutts> though it should be
05:52:44 <dcoutts> all monads are functors
05:52:46 <AStorm> No, definition problem :P
05:52:48 <therp> I miss lexically-scoped <style> definitions in HTML.
05:52:51 <bringert_> AStorm: so you could write instance Monad m => Functor m where fmap = liftM
05:52:54 <dcoutts> it's just that the class heirarchy doesn't reflect it
05:53:10 <AStorm> bringert_, not really. Think about IO :P
05:53:11 <bringert_> *what dcoutts said*
05:53:14 <AStorm> Apply some function on that
05:53:15 <AStorm> :P
05:53:29 <Saizan> what's the problem?
05:53:30 <bringert_> AStorm: I still don't understad what you mean
05:53:45 <dcoutts> AStorm, no bringert_'s right. You can make IO an instance of Functor using just liftM
05:53:45 <bringert_> fmap toUpper getChar
05:54:23 <dcoutts> AStorm, erm in fact IO is an instance of Functor already
05:54:26 <bakert> How can I make lambdabot go from pointfree back to non-pointfree?
05:54:35 <dcoutts> bakert, @pl and @unpl
05:54:47 <audreyt> @unpl (.) . (.)
05:54:47 <lambdabot> (\ i b c f -> i (b c f))
05:54:48 <bakert> dcoutts, thanks
05:55:03 <bringert_> shouldn't that be pf (point-full)?
05:55:31 <bakert> ?unpl liftM . map
05:55:32 <lambdabot> (\ c -> liftM (map c))
05:56:25 <bakert> Oh dear.  I think I've just encountered the monomorphism restriction for the first time.
05:56:47 <bakert> I'm trying to turn this into one line but it is melting my head:
05:56:50 <bakert> reports accounts = geddit (renderHtml . reportToHtml) $ sequence $ map report accounts
05:56:59 <bakert> geddit = liftM . map
05:57:13 <bakert> Basically I want to get rid of geddit
05:57:18 <bakert> But I can't work out how.
05:57:41 <bringert_> bakert: one thing: use mapM instead of sequence and map
05:58:23 <bakert> bringert_, thanks that's the kind of thing i need to know.
05:58:52 <bringert_> then move the (renderHtml . reportToHtml) into the first argument of mapM
05:58:58 <bringert_> something like that
06:00:10 <bringert_> there's no need to first make a m [a] and then map a function (a -> b) over that.
06:00:39 <AStorm> ?pl liftM . map . x . sequence . map
06:00:39 <chessguy> 'morning
06:00:41 <lambdabot> fmap . map . x . sequence . map
06:00:53 <AStorm> Blah, wrong, that was to be unpl
06:00:57 <AStorm> ?unpl liftM . map . x . sequence . map
06:00:58 <lambdabot> (\ c -> liftM (map (x (sequence (map c)))))
06:01:19 <bringert_> bakert: maybe something like reports = mapM (liftM (renderHtml . reportToHtml) . report)
06:01:43 <sjanssen> @where shootout
06:01:44 <lambdabot> http://shootout.alioth.debian.org/
06:02:32 <bakert> bringert_, that seems to work.  Let me see if I understand it.
06:02:44 <chessguy> hmm, so haskell is turning 20 years old this week!
06:02:46 <chessguy> err, this year
06:03:22 <araujo> yay!
06:03:27 <araujo> :-)
06:03:35 <araujo> we need to get a party
06:03:41 <araujo> a lambda party
06:03:59 <bakert> mapM takes a function that turns an a into a m b, and a list of as.  The function is the rest of reports and the list of as is the (not shown here because pointfree) list of accounts.
06:04:20 <chessguy> araujo, :)
06:04:26 <AStorm> sugar lambdas anyone?
06:05:04 <bakert> The function "liftM (renderHtml . reportToHtml) report" is applied to each account.  It first produces an IO report using report.  Then it lifts the report out of IO to apply (renderHtml . reportToHtml) to it.
06:05:29 <bringert_> "liftM (renderHtml . reportToHtml) . report"
06:05:35 <bringert_> (was missing a .)
06:05:44 <bakert> ah, yes.  crucial.
06:05:59 <bakert> mapM then joins all these together and pops them back into IO in a list.
06:06:16 <Saizan> mmh it's more like (renderHtml . reportToHtml) gets lifted in the IO world to perform his task there
06:06:55 <bakert> Saizan, yeah i see what you mean.  we are still in IO land.  but it is temporarily unwrapped and messed about with without the IO wrapping before being wrapped up again.
06:07:25 <bakert> So does my description sound mostly right?
06:07:26 <bringert_> bakert: that works as a model (mostly), but what Saizan is more true
06:07:39 <bakert> oh ok.  i think they may have to come a bit later ... !
06:07:55 <chessguy> Semla, Haskell, Vivaldi, Mozart, CFL
06:07:55 <chessguy> (Common Functional Language), Funl 88, Semlor, Candle (Common
06:07:55 <chessguy> Applicative Notation for Denoting Lambda Expressions), Fun,
06:07:55 <chessguy> David, Nice, Light, ML Nouveau (or Miranda Nouveau, or LML
06:07:56 <chessguy> Nouveau, or ...), Mirabelle, Concord, LL, Slim, Meet, Leval, Curry,
06:07:56 <chessguy> Frege, Peano, Ease, Portland, and Haskell B Curry
06:07:58 <bringert_> bakert: I don't quite understand what this means: "The function is the rest of reports and the list of as is the (not shown here because pointfree) list of accounts."
06:08:08 <chessguy> all the possible things haskell could've been named
06:08:19 <bringert_> I like Semlor
06:08:32 <bringert_> http://en.wikipedia.org/wiki/Semla
06:08:53 <Saizan> Frege!
06:09:07 <bringert_> David?
06:09:32 <Saizan> dunno his first name..
06:09:36 <bakert> bringert_, I mean that the function passed as the first argument to mapM is all of the reports function except for the mapM.  The other argument to mapM (list of Accounts) is not explicitly written down in the reports function because the reports function is written in the pointfree style.
06:09:49 <bakert> Right?
06:09:49 <bringert_> Saizan: no, I mean "David" was in the list
06:10:28 <bringert_> bakert: ah, ok
06:10:41 <bakert> bringert_, everyone, thanks so much for your help.  I don't know how I'd progress without it.
06:12:46 <chessguy> "...as Haskell became more widely used (partly because of the existence of the Haskell 98 standard), many small flaws emerged in the language design, and many ambiguities in the Report were discovered. Peyton Joness role evolved to that of Benign Dictator of Linguistic Minutiae."
06:17:12 <Lemmih> ?remember SPJ It was Simon Marlow actually, but we are joined at the hip so it hardly matters.
06:17:13 <lambdabot> Done.
06:17:37 <pejo> Lemmih, heh, did he say that?
06:17:46 <Lemmih> pejo: Yep.
06:18:14 <chessguy> @quote spj
06:18:15 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
06:18:21 <chessguy> @quote spj
06:18:22 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
06:18:29 <chessguy> @quote SPJ
06:18:30 <lambdabot> SPJ says: It was Simon Marlow actually, but we are joined at the hip so it hardly matters.
06:18:34 <chessguy> @quote SPJ
06:18:34 <lambdabot> SPJ says: It was Simon Marlow actually, but we are joined at the hip so it hardly matters.
06:18:56 <Botje> @quote monad
06:18:57 <lambdabot> newsham says: there are Just 1 types of people, Nothing and those who understand monads
06:19:05 <Botje> :)
06:19:29 <Botje> is \bots quote archive available somewhere?
06:19:32 <fasta> @quote c programmers
06:19:32 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
06:19:37 <fasta> @quote cprogrammers
06:19:37 <lambdabot> No quotes match. I feel much better now.
06:19:46 <chessguy> @quote c
06:19:47 <lambdabot> ghc says: Malformed predicate
06:19:48 <allbery_b> botje: state files in the lambdabot distribution I think
06:19:50 <fasta> @quote value
06:19:50 <lambdabot> lispy says: a := new Maybe(); a.envalue(1);
06:19:58 <fasta> @quote cost
06:19:59 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
06:20:02 <fasta> @quote cost
06:20:03 <lambdabot> madpickle says: Stuff costs more than it used to.
06:20:05 <fasta> @quote cost
06:20:06 <lambdabot> madpickle says: Stuff costs more than it used to.
06:20:17 <allbery_b> @quote c.programmers
06:20:17 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
06:20:27 <Saizan> ?docs Data.Complex
06:20:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
06:20:58 <allbery_b> @quote programmers.*value
06:21:00 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:21:07 <chessguy> (a -> b) -> Maybe a -> Maybe b
06:21:11 <chessguy> ?hoogle (a -> b) -> Maybe a -> Maybe b
06:21:12 <lambdabot> No matches, try a more general search
06:21:47 <allbery_b> ?hoogle (a -> b) -> m a -> m b
06:21:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:21:48 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:21:48 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
06:22:04 * allbery_b thinks that looks like liftM
06:22:10 <allbery_b> :t liftM
06:22:12 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
06:22:14 <Saizan> ?type fmap (Just 1)
06:22:16 <lambdabot>     Expecting a function type, but found `Maybe a'
06:22:16 <lambdabot>       Expected type: a -> b
06:22:26 <Saizan> ?type \f -> fmap f (Just 1)
06:22:28 <lambdabot> forall b a. (Num a) => (a -> b) -> Maybe b
06:23:50 <chessguy> > lifM (+2) (Just 3)
06:23:51 <lambdabot>   Not in scope: `lifM'
06:23:56 <chessguy> > liftM (+2) (Just 3)
06:23:58 <lambdabot>  Just 5
06:24:09 <chessguy> > liftM (+2) Nothing
06:24:10 <lambdabot>  Nothing
06:25:29 <AStorm> > fmap (+2) (Just 3)
06:25:31 <lambdabot>  Just 5
06:25:47 <AStorm> > fmap (+2) [Just 1, Just 2, Nothing]
06:25:48 <lambdabot>   add an instance declaration for (Num (Maybe a))
06:25:57 <AStorm> > fmap (+2) Nothing
06:25:59 <lambdabot>  Nothing
06:26:04 <AStorm> Hmm, hmm.
06:26:07 <mux> > return 3 >>= return . (+2) :: Num a => Maybe a
06:26:09 <lambdabot>  Just 5
06:26:12 <beelsebob> interesting
06:26:21 <beelsebob> oh... duh
06:26:24 <Igloo> Does Christian Maeder IRC?
06:27:19 <Saizan> > aequence (+2) [Just 1, Just 2, Nothing]
06:27:20 <lambdabot>   Not in scope: `aequence'
06:27:24 <Saizan> > sequence (+2) [Just 1, Just 2, Nothing]
06:27:25 <lambdabot>      Expecting a function type, but found `[m a]'
06:27:26 <lambdabot>       Expected type: [t -> ...
06:27:36 <Saizan> ah right
06:27:48 <mux> > return 3 >>= return . (+2) :: Num a => [a]
06:27:50 <lambdabot>  [5]
06:28:41 <thartman> Just 2 ==> (+2)
06:28:46 <thartman> > Just 2 ==> (+2)
06:28:46 <lambdabot>   Not in scope: `==>'
06:28:57 <thartman> > Just 2 >>= (+2)
06:28:58 <lambdabot>   add an instance declaration for (Num (Maybe b))
06:29:03 <Saizan> > map (liftM (+2)) [Just 1, Just 2, Nothing]
06:29:04 <AStorm> ?hoogle ==>
06:29:05 <lambdabot>  [Just 3,Just 4,Nothing]
06:29:06 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
06:29:35 <allbery_b> > Just 2 >>= return . (+2)
06:29:37 <lambdabot>  Just 4
06:29:45 <qwr> > Nothing >>= (+2)
06:29:46 <lambdabot>   add an instance declaration for (Num (Maybe b))
06:29:49 <chessguy> heh.
06:29:50 <chessguy> At each moment in the design process, one member of the
06:29:50 <chessguy> committee (not necessarily the Editor) served as the Syntax
06:29:50 <chessguy> Czar.
06:30:00 <thartman> oh yeah, i think i wanted albery's latest.
06:30:19 <thartman> (trying to answer question about this on haskell cafe :) )
06:30:21 <qwr> > Nothing >>= return . (+2)
06:30:23 <lambdabot>  Nothing
06:30:36 <qwr> fmap (+2) Nothing
06:30:38 <chessguy> thartman, there's several answers already
06:30:39 <qwr> > fmap (+2) Nothing
06:30:41 <lambdabot>  Nothing
06:30:45 <qwr> > fmap (+2) $ Just 2
06:30:45 <thartman> man you guys are fast!
06:30:46 <lambdabot>  Just 4
06:30:48 <chessguy> (in case you didn't see them)
06:31:38 <beelsebob> haha, brilliant
06:31:50 <beelsebob> I think I just saw the best summation of scientific life
06:32:45 <beelsebob> three job postings... cleaner, no qualifications requiried, 16.5k, Post-doc position, (duh, doctorate required) 17k, administrator 43k
06:33:01 <beelsebob> (admin required a-levels)
06:37:35 <roconnor> @pointful (>>= return . (+2))
06:37:36 <lambdabot> (\ b -> b >>= \ e -> return (e + 2))
06:38:13 <chessguy> lol
06:38:27 <chessguy> i just found a code snippet in the History of Haskell paper:
06:38:49 <AStorm> beelsebob, where?
06:39:00 <allbery_b> @. redo unpl \f -> f >>= return . (+2)
06:39:01 <lambdabot> \ f d -> (do { a <- f; return a}) (d + 2)
06:39:10 <psnl> ph8: still here?
06:39:12 <AStorm> And didn't that admin job require 10-year experience?
06:39:15 <paolino> @pl \i -> a i >>= b i
06:39:16 <lambdabot> liftM2 (>>=) a b
06:39:18 <allbery_b> @. redo unpl \f -> f >>= (return . (+2))
06:39:19 <lambdabot> \ f -> do { d <- f; return (d + 2)}
06:39:45 <paolino> @pl  a i >>= b i
06:39:45 <lambdabot> b i =<< a i
06:40:01 <chessguy> mapMaybe :: (a->b) -> Maybe a -> Maybe b    mapMaybe f (Just x) = Just (f x)    mapMaybe f Nothing = Nothing
06:41:36 <Saizan> ?type mapMaybe
06:41:41 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
06:42:04 <chessguy> ?src mapMaybe
06:42:04 <lambdabot> Source not found. Wrong!  You cheating scum!
06:42:13 <ndm> has anyone read the history of haskell paper?
06:42:13 * chessguy hangs his head in shame
06:42:19 <chessguy> ndm, i'm reading it now
06:42:53 <AStorm> ?src liftM
06:42:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:43:28 <ndm> In the UK, and many other countries, Haskell enthusiasts are truly one in a million.
06:43:44 <ndm> that sounds like crap to me, suggesting there are 60 haskellers in the UK
06:44:16 <chessguy> is that high or low?
06:44:22 <ndm> way too low
06:44:36 <ndm> i could probably throw stuff at 10 haskellers from where i'm sitting
06:44:48 <AStorm> Yes, there are about 150 in the UK
06:44:48 <chessguy> that wouldn't be very nice of you
06:44:54 <AStorm> and in Poland... 10? :P
06:45:05 * mux wonders how many there are in France
06:45:06 <AStorm> Maybe it's because all went to the UK...
06:45:33 <roconnor> there are none in France, they all use OCaml there.
06:45:39 <roconnor> :P
06:45:44 <chessguy> anyway, 1 in a million sounds better than 1 in 400,000
06:45:59 <earthy> not counting students we have at least 12 haskellers here
06:46:10 <roconnor> @where earthy
06:46:10 <lambdabot> I know nothing about earthy.
06:46:15 <AStorm> earthy, where? Tell me and in 3 years I
06:46:16 <AStorm> I
06:46:18 <earthy> utrecht university ;)
06:46:25 <AStorm> (gawk) I'll be there
06:46:33 <chessguy> utrecht, where the heck is that?
06:46:36 <earthy> .nl
06:46:36 <AStorm> hmm... Germany... ]:->
06:46:42 <chessguy> ah
06:46:43 <AStorm> Blah. .nl
06:46:58 <AStorm> Could go there too...
06:47:01 * chessguy starts brushing up on his German
06:47:06 * earthy grins
06:47:27 <roconnor> Ich ben Berliner!
06:47:28 <earthy> if I do count students that number goes up to over 50
06:47:41 <AStorm> roconnor, bzzzzt.... WRONG!
06:47:45 <roconnor> damn
06:47:53 <roconnor> I fail at German
06:47:54 <earthy> and that's not counting the 100 or so that take functional programming every year
06:48:23 <mux> roconnor: well there's me at least :)
06:48:26 <Syzygy-> roconnor: pwned!
06:48:27 <earthy> roconnor: your dutch is improving though. ;)
06:48:28 <Syzygy-> :)
06:48:33 <AStorm> Hmm, why don't we have that here... is that because it's a technical university?
06:48:41 <earthy> nah
06:48:45 <roconnor> Ik ben Berliner!
06:49:01 <earthy> the technical unis don't do that much fp in .nl
06:49:11 <AStorm> roconnor, even worse
06:49:12 <earthy> we just have a strong fp core in utrecht
06:49:30 <roconnor> AStorm: I was trying for Dutch this time.
06:49:47 <roconnor> Ik ben Nijmegenese!
06:49:51 <roconnor> hmmm
06:49:55 <roconnor> that doesn't seem right
06:50:55 <pejo> I'd say the fp groups share quite a lot, even if they don't do Haskell.
06:52:29 <roconnor> ber formal unentscheidbare Stze der Principia Mathematica und verwandter Systeme I
06:53:32 <bakert> I'm looking at typeclasses to solve some problems.
06:53:52 <bakert> I have various websites, one for each company.
06:54:06 <bakert> Plus I need to refer to the companies elsewhere in a different context.
06:54:20 <bakert> So I tried data Company = IBM | Lotus | Microsoft
06:54:32 <kowey> mux: #haskell.fr lives again, by the way (was that you that was stopping by in november?)
06:54:36 <bakert> And class Site a where login :: a -> blah
06:54:52 <bakert> But now to make a Company an instance of Site what do I do?
06:55:53 <allbery_b> what is the type a in the context of a Company?
06:56:07 <roconnor> bakert: that's not quite right.  If you are going to use a data type like Company, then login should be just a regular function.
06:56:13 <bakert> Oh.
06:56:16 <roconnor> and you don't need type classes at all.
06:56:22 <earthy> roconnor: Je bent Nijmegenaar!
06:56:25 <mux> kowey: oh, yes
06:56:28 <bakert> See what I want is to have Company available to all sorts of parts of my code.
06:56:29 <allbery_b> ==roconnor you have type constructors, not separate types
06:56:34 <bakert> But keep the login stuff just in one part.
06:56:36 <earthy> (or, if you were to be female: Nijmeegse!
06:56:37 <earthy> )
06:56:43 <roconnor> OTOH, if you make each company a different type (for some reason) then you can use type classes.
06:56:48 <bakert> So I could have data IBM = IBM
06:56:52 <chessguy> should probably have an even longer name, to discourage its
06:56:52 <chessguy> use by beginners who often use it unnecessarily.
06:56:56 <chessguy> oops
06:56:57 <bakert> And instance Site IBM where ...
06:57:29 <chessguy> "[unSafePerformIO] should probably have an even longer name, to discourage its use by beginners who often use it unnecessarily."
06:57:39 <bakert> But I'm not sure about that approach.  Then I don't have a nice enum of all the companies just these random floating IBM and Microsoft types.
06:57:40 <allbery_b> yes, although I'm not sure of the utility of doing that unless you seriously need the typep system to check companies for you (and are willing to rewrite if you add/remove companies)
06:57:45 <bakert> Which doesn't seem right.
06:58:15 <roconnor> bakert: Indeed, this doesn't look like a problem to solve with type classes.
06:58:17 <allbery_b> I'm not sure I'd even use the data version.  I'd want to load Compnies from extensible persistent storage (flat file, database, ...)
06:58:41 <bakert> allbery_b, but then I'm in the pain of IO!
06:58:46 <allbery_b> then again, I'm an old database hacker :)
06:58:50 <bakert> But you might be right there.
06:59:06 <bakert> I do in fact have a table of these companies in the db.
06:59:32 <bakert> But I need to code up the login function for each in the code so it probably doesn't hurt to list them there.
06:59:37 <allbery_b> only for loading.  you can write the rest of it as pure code and lift it into IO to apply it
07:00:07 <bakert> yes, true, i'm not very good at doing that cleanly yet.
07:00:23 <bakert> IO tends to wander down into places it shouldn't be unless I am very firm with it.
07:00:35 <roconnor> data Company = Company {name :: String, login :: String} seems to be the way to go for a simple problem.
07:00:54 <roconnor> this produces login :: Company -> String
07:01:21 <allbery_b> well, login could be interesting if one uses a string password, another uses passphrase + checkphrase (seems to bebecoming common), a third uses a captcha...
07:01:44 <roconnor> or data CompanyData = CompanyData {name :: CompanyName, login :: String}
07:02:02 <roconnor> and data CompanyName = IBM | ... , if you really have a fixed enumeration of companies
07:02:08 <AStorm> Hmm. Write me a login checker against large User database. Lazy one.
07:02:16 <bakert> I actually have Account = Account { comp :: Company, usr :: String, pwd :: String }
07:02:29 <roconnor> bakert: ah, perfect
07:02:52 <bakert> But then I don't know how to connect up a login function for IBM with an Account.  if you know what i mea.
07:02:54 <bakert> *mean
07:02:58 <roconnor> so you can either do newtype Company = String, or make Company a data type as you suggested above.
07:03:09 <roconnor> hmm
07:03:48 <bakert> I did have pattern matching on the login account parameter to provide a different login for each company but my boss told me off (!)
07:04:09 <bakert> login Account { Company = IBM, usr = u, pwd = p } = ...
07:04:18 <bakert> and so on for each company
07:04:32 <roconnor> how do the logins differ by company?
07:04:44 <bakert> roconnor, because they have different websites.
07:05:26 <allbery_b> do they really need different code, or just different {url, loginfield, passwordfield}?
07:05:49 <bakert> allbery_b, i think they really need different code.  a couple have a SOAP interface, for example.
07:07:16 <bakert> Which is why I wanted class Site a where login :: blah
07:07:30 <bakert> And then "attach" site to each company.  But it doesn't quite work like that!
07:07:42 <bakert> instance Site IBM where ...
07:07:48 <bakert> hmmm
07:08:19 <bakert> Any ideas?
07:09:04 <roconnor> I short on idea.  Your pattern matchin solution doesn't seem so bad.
07:09:10 <chessguy> can you restate your problem a little more...clearly?
07:09:15 <allbery_b> I'd refactor the patternmatch
07:09:24 <bakert> Sorry chessguy.  Let me try!
07:09:38 <chessguy> maybe a pastebin would help?
07:09:53 <allbery_b> usrlogin user = complogin (comp user); complogin IBM = ...
07:10:29 <bakert> I have a set of companies.  Each has a website with a login function.  There are one or more accounts for each website.  I want to come up with a type system to represent all this as sensibly as possible.
07:10:45 <bakert> (an account is just website + username + password)
07:10:57 <pejo> bakert, and you usually add companies, not more login-functions?
07:11:21 <bakert> pejo, there's a one-to-one relationship between websites and companies.  So much so that I have been conflating them so far.
07:11:53 <bakert> allbery_b, i am trying to understand your usrlogin thing.  But I don't quite get it.
07:12:09 <notsmack> well, the login function could be part of the Company type
07:12:29 <pejo> bakert, yes, but suppose you extend your data type with another Company, then you need to edit all functions that pattern match on it.
07:12:51 <bakert> notsmack, yes it could.  But then that would have to be available to the other parts of my code which need to know about companies but don't care about logins and websites.
07:13:00 <bakert> maybe not a problem?
07:13:21 <bakert> pejo, well if I add a company I must add a login function anyway so not necessarily a problem.
07:13:39 <bakert> My boss suggested:
07:13:56 <bakert> data IBM = IBM { usrname :: String, password :: String } for each company
07:14:03 <bakert> but i'm not sure that's any better than what I have.
07:14:15 <roconnor> that doesn't seem so good to me
07:14:25 <bakert> although it does allow me to use the instance Site IBM ... thing
07:14:31 <bakert> (Site typeclass)
07:14:54 <roconnor> notsmack: seems to have a point about the login function being part of the company type.
07:15:16 <roconnor> If it holds out, you could define a company to be a login function
07:15:20 <roconnor> thus
07:15:23 <bringert_> data Company = Company  { name :: String, ..., login :: IO () }
07:15:27 <bakert> Yes, I suppose it is.  The trouble is this is three separate applications and I was trying to keep shared code to a minimum.
07:15:31 * bringert_ doesn't know the context though
07:15:32 <roconnor> type Company = IO ()
07:15:38 <roconnor> IBM = ...
07:15:40 <matthew_-> Am I right in thinking that monomorphic types are as in haskell98 type classes?
07:15:43 <roconnor> IBM :: Company
07:15:54 <bakert> I wanted to share the basic details about companies without sharing login code and whatnot.  But perhaps I am being a bit precious about that.
07:16:02 <roconnor> ... actualy, newtype probably ought to be used here.
07:16:05 <bakert> And perhaps that is the cause of my woes?
07:16:27 <notsmack> bakert: it seems an awkward division.
07:17:08 <bakert> notsmack, yes you are probably right.  i'm just wary of turning my three nimble little progs into one big codebase.  but i guess if they are that closely related it can't be avoided.
07:17:23 <roconnor> ... actually I lke bringert_'s data type.
07:17:27 <notsmack> maybe   "data Website = Company Website String String (String -> String -> IO ())"
07:17:47 <notsmack> then have your general Company info in Company in a more generally included module
07:17:52 <bakert> notsmack, ahhh interesting.
07:18:13 <bringert_> I think record syntax is better if you have that many arguments to the constructor
07:18:21 <notsmack> bakert: then i imagine a static list of those you update as you get new websites/companies?
07:18:35 <bakert> I agree about record syntax.  I was thinking more of the separation of Website and Company.
07:18:44 <notsmack> bringert: i agree, just didn't want to type that much
07:18:48 * roconnor thinks that notsmack isn't mean to make a recursive type.
07:18:56 <roconnor> didn't
07:19:00 * bringert agrees with roconnor
07:19:02 <notsmack> roconnor: is right.
07:19:12 <bakert> oop no!  but we all knew what he meant.
07:19:27 <bakert> OK, so that seems really good.  Can I complicate it a bit now?
07:19:30 <bakert> !!!
07:20:02 <bakert> There's actually quite a lot of code hanging off these.  login is just one bit.  So I want each company in it's own Module.  That doesn't change anything does it?
07:21:30 <notsmack> without knowing much about your app, i'd think maybe you could benefit from abstracting your business logic out of the code more?
07:22:08 <bakert> it's a program to visit various websites and check our balances.  then another program checks the balances we recorded against what's in the database and points out any discrepancies.
07:22:22 <chessguy_work> man it's hard to watch the channel when your boss is standing right behind you
07:22:37 <Nafai>  Heh
07:23:25 <bakert> notsmack, not quite sure what you mean.  have the company details live somewhere else?  that's what the login function for each company is ... separated from the code that grabs pages and so on ... maybe
07:24:38 <roconnor> sounds like you have some collection of functions that you want to perform the same task for different companies, and each company as a different implemenation of these functions.
07:25:53 <notsmack> bakert: say, for instance, a data type that holds post/get/soap, username field, password field, user/pass, and target url, then a datatype that has whatever screen scraping regex you need, and put those in Website...
07:26:19 <notsmack> bakert: if you can get that working you shouldn't need actual haskell /code/ for each company, i'd think
07:27:03 <notsmack> which may simplify things.  or may not.  just a thought.
07:27:03 <chessguy_work> mmmmm, web site scraping isn't necessarily a simple matter of a regex
07:27:38 <notsmack> chessguy_work: sure, i agree.  it just sounds like he's doing something generalizable.
07:28:00 * notsmack has done too much web scraping.
07:28:20 <chessguy_work> ok, well with that i can agree
07:29:07 <malebria> What namespace layout is being used?
07:29:23 <malebria> http://haskell.org/haskellwiki/Libraries_and_tools
07:29:25 <lambdabot> Title: Libraries and tools - HaskellWiki
07:29:28 <chessguy_work> if roconnor's characterization is accurate, then a typeclass should work nicely
07:29:40 <malebria> There're three proposals here, is it the first one that is being used?
07:29:45 <bakert> notsmack, chessguy_work, roconnor, you are right -- it is generalisable and in fact in some cases the login function is just a call to "simpleLogin" that takes loginUrl, usr, pwd, checkPage, checkRegex
07:29:54 <bakert> in other cases it is more complicated.
07:30:53 <chessguy_work> so what about using a typeclass
07:31:02 <notsmack> bakert: yeah, so you've already thought along those lines, just making sure
07:31:22 <roconnor> chessguy_work: my charaterisation will produce a type class if the functions are the same upto a type that changes.  However I expect the set of functions will all have exactly the same type.  In this case, a record structure for that set of types would be used.
07:32:09 <bakert> OK, well I have some ideas now.  Going to try and get something working with Company and Website data types.  Thanks very much for your help bringert_, roconnor, chessguy_work, notsmack ... very helpful indeed.
07:32:19 <roconnor> BTW, I think this sort of discussion is part of what makes Haskell so good.  One tends to really hammer out the data types until you get something beautful.
07:32:33 <bakert> Actually I have a little problem still!
07:32:52 <bakert> Once I have Company and Website, where do I actually "instantiate" the companies?
07:33:04 <thartman> is there a way to use "return" in a statement without >>= or do?
07:33:25 <bakert> data Company = Company { ... }
07:33:35 <notsmack> bakert: either a data file gets parsed to a list of them, or you just hard code them in a haskell file...
07:33:42 <roconnor> ibm :: Company
07:33:49 <roconnor> ibm = Company ...
07:33:59 <bakert> ah cool. yes.  thanks.  sorry ... bit slow.
07:34:02 <thartman> return (\x -> Just x) I guess...
07:34:10 <ohmega> i saw a blog post a while ago that discussed how easy it was to implement an interpretor for arithmetic with variables and concluded that that was why pugs was written in haskell. does anyone know the url or some search terms?
07:34:48 <notsmack> bakert: so are you dealing with catching cookies and such, too?
07:34:49 <chessguy_work> or instance Company IBM where...
07:34:56 <bakert> notsmack, Network.Browser
07:35:08 <notsmack> bakert: ah, thanks, haven't looked at that
07:35:19 <chessguy_work> er, ibm, of course
07:35:28 <bakert> notsmack, i have even submitted two (tiny) patches.  go me!
07:35:51 <bakert> chessguy_work, i can only use the instance syntax with typeclasses though, right?
07:35:55 <notsmack> i bet a haskell web spider could be very elegant.
07:36:03 <bakert> notsmack, not this one!!!!
07:36:05 <thartman> want something like...
07:36:15 <thartman> Prelude Control.Monad> Maybe.return 1       and it gives me Just 1
07:36:27 <chessguy_work> bakert, yes, if Company is a typeclass, you would make ibm an instance of it
07:37:13 <bakert> Do you think it should be?  I was just making it a record.
07:37:24 <Saizan> > return 1 :: Maybe Int
07:37:26 <bringert> Igloo: lhs2tex Setup.hs breaks with darcs Cabal, seems to be because of the verbosity argument
07:37:28 <lambdabot>  Just 1
07:37:51 <thartman> aha, ok.
07:38:15 <allbery_b> return just needs some idea of which one you mean, an explicit or inferred type is sufficient
07:38:48 <allbery_b> just ike any other typeclass fuunction (for example, read)
07:41:53 <beelsebob> bored now
07:42:04 <beelsebob> need haskell to write
07:42:54 <edwinb> you can write mine for me if you like
07:43:01 <edwinb> then I can go to the pub or something instead
07:43:12 <bakert> beelsebob, how about a SOAP library???
07:43:22 <bakert> (ok, i need a SOAP library, i admit it)
07:43:36 <beelsebob> edwinb: well, I'd been considering adding whitespace to the brainf*** and ook interpreter I wrote yestreday
07:44:00 <edwinb> I suppose it'd pass the time
07:44:12 <beelsebob> indeed - it's somewhat more complex tough
07:44:14 <beelsebob> though*
07:46:25 <glguy> good morning
07:49:16 <chessguy> hi glguy
07:49:37 <beelsebob> edwinb: how about we just go to the pub anyway...
07:50:00 <chessguy_work> bakert, what functionality do you need in a SOAP library?
07:50:10 <edwinb> beelsebob: your suggestion has some merit
07:50:31 <beelsebob> unfortunately not too condusive to getting a PhD, but then neither was my other suggestion
07:51:05 <bakert> chessguy_work, i need to login to a couple of web services, retrieve some account details.  i guess ideally i would supply it a WSDL file and be able to call any of the functions mentioned in the WSDL
07:51:31 <bakert> as it stands i will probably do that with a ruby SOAP lib or similar and then call that from the haskell prog.  or write a SOAP lib.
07:52:29 <chessguy_work> hmm, i wouldn't think it would be too hard, if there's an existing XML library
07:52:44 <Saizan> there are two!
07:52:50 <bakert> chessguy_work, at my level ... everything in haskell is difficult!
07:53:02 <chessguy_work> well, mine too
07:53:42 <beelsebob> bakert: write a Brainf*** interpretter in Haskell and then write everything in brainf*** then :P
07:54:12 <Vq^> beelsebob: the first step should be fairly simple :)
07:54:36 <Saizan> i don't think you have to censure brainfuck :D
07:54:36 <beelsebob> Vq^: indeed - about 80 lines by my count
07:54:51 <bakert> :( that doesn't sound like it's going to improve my haskell very much
07:54:54 <beelsebob> no... the language actually isn't called brainfuck
07:54:58 <beelsebob> it's called Brainf***
07:55:13 <bakert> Saizan, someone told me off for swearing the other day in this channel.  So I don't know about that.
07:55:40 <chessguy_work> i'd prefer to see it called bf
07:55:44 <hpaste>  beelsebob annotated "BF and Ook" with "BF and Ook revisited slightly" at http://hpaste.org/82#1
07:56:39 <Vq^> beelsebob: are you sure it isn't called brainfuck?
07:56:57 <beelsebob> Vq^: certain, I have the language definition page open at the moment
07:58:04 * allbery_b sighs
07:58:11 <Vq^> beelsebob: it seems to be called brainfuck on the web
07:58:31 <beelsebob> Vq^: indeed - it's actually the ook language def page that seems to call it brainf***
07:58:33 <beelsebob> silly people
07:58:45 <allbery_b> start a sequence with "r,l,i,d...", the next entry is not "inp" :>
07:59:03 <beelsebob> allbery_b: it's not a sequence
07:59:19 <allbery_b> not a haskel sequence, certainly
07:59:23 <beelsebob> right, left, increment, decrement, input, output, jump if non zero, jump if zero
07:59:37 <allbery_b> "w" :)
07:59:53 <beelsebob> why/
07:59:54 * allbery_b has been at CMU too long
08:00:02 <allbery_b> AFS ACLs.  rlidwka
08:00:20 <beelsebob> pardon?
08:00:40 <allbery_b> Read List Insert Delete Write locK Admin
08:00:47 <beelsebob> why on earth would this have anything to do with file permissions?
08:01:17 <bakert> How can I make an anonymous function with no arguments?
08:01:21 <bakert> Just brackets?
08:01:36 <beelsebob> yep
08:01:39 <beelsebob> just use sections
08:01:40 <allbery_b> hm.  just that I'm reading it and seeing r, l, i, d and my mind jumpps forward automatically and then comes to a sudden halt when the next one is inc instead of w :)
08:01:49 <beelsebob> hehe, okay
08:02:29 <allbery_b> ("didn't we already have that? oh, wait")
08:03:28 <fasta> For what do you use an anonymous function with no arguments?
08:03:36 <Frederick> hallo folks
08:03:38 <fasta> And isn't it called a "value" then?
08:03:45 <Vq^> hello Frederick
08:03:52 <beelsebob> fasta: I think he meant in point free style
08:03:55 <Frederick> chessguy_work just said me someone here was commenting to have worked with lazy evaluation in java
08:03:57 <beelsebob> and a function is still a value
08:04:00 <beelsebob> it's just a functional value
08:04:04 <bakert> fasta, no, i didn't, i think i'm just getting confused!
08:04:41 <bakert> fasta, i have a function that generates a login function.  but i know the username and password at the time i am generating it so i don't need to pass any args when i call it.
08:04:54 <bakert> but i guess with laziness i don't worry about "when i call it"
08:05:15 <bakert> so a value and a no arg function are not different.
08:05:39 <beelsebob> bakert: well, you'll be passing round an expression, not a value
08:05:43 <bakert> however, it is in the BrowserAction monad so the sequencing is relevant but I guess that will work out somehow.  maybe.
08:05:46 <beelsebob> it'll become a value when it's demanded
08:05:52 <bakert> as you can tell, i am confused.
08:06:08 <bakert> but i think laziness is going to help me rather than hurt me here.  we shall find out!
08:07:12 <allbery_b> bakert: actually, your query was ambiguous and fasta picked a different interpretation than you intended
08:07:21 <bakert> oh.
08:07:37 <glguy> darcs++
08:07:38 <beelsebob> oh dear god no
08:07:39 <allbery_b> (an anonymous function) (with no arguments) vs. (an anonymous function with no arguments)
08:07:51 <beelsebob> pi lang
08:07:55 <bakert> second one was my one.
08:07:57 <bakert> i think.
08:07:59 <bakert> !
08:08:05 <beelsebob> encodes brainfuck into errors from digits in pi
08:08:12 <allbery_b> I'd say the first; the second means you have a function which doesn't expect any args
08:08:18 <bakert> one day i will not be the most clueless person in this chat room and that will be a great day.
08:08:20 <bakert> :)
08:08:40 <allbery_b> the first says it does but you want to omit them in the reference
08:08:43 <chessguy_work> bakert, lol, i think i've probably got you beat there
08:09:02 <bakert> allbery_b, i have a function that takes several args that i want to _produce_ a function that takes no args to be called "later".  but as there is no "later" perhaps i am just overcomplicating stuff.
08:09:11 <allbery_b> right
08:09:26 <chessguy_work> @hoogle later
08:09:27 <lambdabot> No matches found
08:09:42 <allbery_b> just pointing out that English is not the clearest of languages for describing operations or algorithms
08:09:53 <bakert> yo
08:10:02 <chessguy_work> haskell is :)
08:10:14 <bakert> only if you speak haskell
08:10:15 <bakert> !
08:10:34 * allbery_b briefly contemplates rewrtiting English sentences as ASTs
08:10:35 <csci> chessguy_work: every non-deterministic language is ;-)
08:11:05 <Saizan> well context-free grammars were invented for natural languages
08:11:35 <chessguy_work> csci, every non=dterministic language is the clearest? huh?
08:12:01 <csci> chessguy_work: no, but every n-d lang. is good to describe algorithms :)
08:12:14 * csci disliked working with amb in scheme a long time ago :)
08:13:31 <gour> csci: see http://svn.openfoundry.org/pugs/third-party/HsSyck/ & http://whytheluckystiff.net/syck/
08:13:34 <lambdabot> Title: Revision 15142: /third-party/HsSyck
08:14:14 <csci> gour: Ah, yes. Thanks!
08:14:50 <kolmodin> seems like lambdabot only sees one url in a line
08:15:09 <chessguy_work> i get a bad feeling about a paper when the first sentence contains the word 'conceptionally'
08:16:38 <allbery_b> yug
08:17:59 <gour> kolmodin: hah, we hit a bug ;)
08:25:33 <dcoutts> the "History of Haskell" paper mentions Data.ByteString in rather rosy terms :-)
08:25:42 <Botje> urgh.
08:25:46 <kolmodin> gour: it's probably a "feature"
08:25:48 <kolmodin> :)
08:25:55 <Botje> bubble sorting 2000 elements in haskell is killing my machine
08:26:20 <Botje> i'm using Data.UArray and ghc -O2, what else can I do? (switching algorithms isn't an option)
08:26:20 <dcoutts> Right! I'm off to Cambridge to visit GHC HQ tomorrow
08:26:27 <gour> kolmodin: oh yeah, i heard that story somewhere :-)
08:26:32 <kolmodin> dcoutts: yay, how so?
08:26:37 <Botje> ideally i'd like to bubblesort 20k elements :)
08:26:55 <Lemmih> Botje: STUArray or IOUArray?
08:26:56 <dcoutts> kolmodin, to discuss replacing build/fold fusion for list in ghc with stream fusion
08:27:03 <dcoutts> :-)
08:27:19 <kolmodin> dcoutts: oo!
08:27:20 <Botje> i'll look at those, then
08:27:34 <kolmodin> dcoutts: so "all" compiled might get much faster?
08:27:48 <dcoutts> yep
08:27:50 <kolmodin> dcoutts: how did that affect lazyness? hard to get it right?
08:27:57 <Lemmih> Botje: Alternatively, post the code and watch #haskell tune your code to perfection.
08:28:02 <dcoutts> for lists it should be fine
08:28:23 <kolmodin> dcoutts: you've got a unstable bytestring library where it's not 100% ?
08:28:37 <dcoutts> kolmodin, huh?
08:28:43 <chessguy_work> kolmodin, that would be like throwing red meat to hyenas :0
08:28:43 <kolmodin> the bytestring-unstable?
08:28:45 <Botje> i'll try STUarray first
08:28:50 <chessguy_work> err
08:28:52 <Botje> I've been wanting to play with ST* for a while now
08:28:53 <chessguy_work> Lemmih, ^^
08:29:00 <kolmodin> dcoutts: or what was that about? :)
08:29:10 <dcoutts> kolmodin, the fps-unstable has the stream fusion system
08:29:20 <dcoutts> base currently uses functional array fusion
08:29:23 <dcoutts> which is slower
08:29:28 <dcoutts> stream fusion is faster
08:29:28 <kolmodin> dcoutts: ah
08:29:41 <chessguy_work> stream fusion system.....that sounds so star trek-ish
08:29:52 <kolmodin> stream fusion is the one mentioned in your paper?
08:29:55 <kolmodin> right?
08:29:56 <dcoutts> yes
08:30:13 <kolmodin> don't really know what functional array fusion is
08:30:20 <dcoutts> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
08:30:23 <lambdabot> Title: Rewriting Haskell Strings
08:30:25 <dcoutts> it describes it all :-)
08:30:42 <kolmodin> hah, I haven't read it all :)
08:30:49 <dcoutts> it's only 15 pages!
08:30:50 <dcoutts> ;-)
08:31:02 <kolmodin> I've been busy! :)
08:31:05 <kolmodin> ..
08:31:11 <dcoutts> s'ok I forgive you :-)
08:31:17 <thartman> what does this data declaration mean?
08:31:19 <thartman> data Nat3   = Nat3 !Int
08:31:22 <kolmodin> I'll bring it on the buss tomorrow, going to my parents
08:31:28 <dcoutts> @arr
08:31:28 <lambdabot> Smartly me lass
08:31:40 <thartman> (from http://www.mail-archive.com/haskell-cafe@haskell.org/msg04728.html )
08:31:42 <lambdabot> Title: Re: [Haskell-cafe] data vs newtype (was: newbie problems), http://tinyurl.com/39u6am
08:31:48 <chessguy_work> Roman Leshchinskiy
08:31:51 <thartman> trying to suss out diff bt data and newtype
08:31:55 <chessguy_work> who is Roman Leshchinskiy
08:32:10 <dcoutts> chessguy_work, he's the third co-author of the paper
08:32:11 <allbery_b> thartman: the ! makes it strict (vs. lazy)
08:32:21 <thartman> ah, ok. thanks.
08:32:23 <kolmodin> dcoutts: it's not like reading the newspaper. you have to stop every sentence and think for 15 minutes
08:32:30 <dcoutts> chessguy_work, and he's a research assistant to Manuel Chatravarky at UNSW
08:32:47 <dcoutts> kolmodin, heh :-)  it's not that hard...
08:32:52 <chessguy_work> ok. not a #haskell-er?
08:32:58 <kolmodin> dcoutts: maybe not :)
08:33:15 <dcoutts> chessguy_work, he's 'rl' on irc, but he's not in #haskell much
08:33:22 <dcoutts> @seen rl
08:33:22 <lambdabot> I haven't seen rl.
08:35:01 <glguy> who was asking me to make the remember me checkbox stay checked while you were being remembered, and stop remembering you when you unchecked it?
08:35:28 * kolmodin is about to go home from work
08:35:38 <kolmodin> anything fun to hack on when I get home?
08:36:16 <int-e> /join #reallife ... heh.
08:36:24 <dcoutts> kolmodin, hmm, try implementing a string pool on top of Get/Put, see how hard it is
08:36:35 <dcoutts> kolmodin, we'll want to know how extensible our system is
08:36:37 <kolmodin> dcoutts: nice
08:36:41 * dcoutts -> Cambridge
08:36:48 <kolmodin> dcoutts: exactly
08:37:04 <kolmodin> dcoutts: you're traveling now?
08:37:07 <dcoutts> yep
08:37:09 <dcoutts> bye!
08:37:12 <kolmodin> oh, bye!
08:37:30 <kolmodin> give the Simons a big wet kiss from me
08:38:17 <chessguy_work> @quote spj
08:38:17 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
08:38:21 <chessguy_work> @quote spj
08:38:21 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
08:38:44 <Lemmih> ?quote joined
08:38:45 <lambdabot> SPJ says: It was Simon Marlow actually, but we are joined at the hip so it hardly matters.
08:38:59 <chessguy_work> there it is
08:41:44 <AStorm> Somebody, please explain neatly list comprehensions of Haskell.
08:41:56 <csci> Anyone knows where I can get pugs-fps from? Google couldn't really help. I've installed fps, but obviously this does not provide pugs-fps
08:42:05 <AStorm> (I'm to do that, but someone else is more able probably)
08:42:06 <notsmack> AStorm: do you understand monads?
08:42:15 <AStorm> notsmack, the person there doesn't
08:42:27 <AStorm> (I'm not explaining it for myself)
08:42:31 <notsmack> oh
08:42:42 <chessguy_work> AStorm, i'd do it in terms of mathematical set notation
08:42:45 <notsmack> AStorm: well, it's basically modelled on set builder notation
08:42:57 <koe> AStorm: does that person know another programming language? perhaps, perl's map and grep?
08:43:00 <AStorm> And some sample "explanatory pseudosyntax"?
08:43:05 <AStorm> koe, can't assume that
08:43:54 <chessguy_work> > [(x,y) | x<-[1..6],y<-[1..6],y>x]
08:43:56 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(2,3),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6),(4,...
08:44:09 <AStorm> What's the last argument there? :-)
08:44:25 <int-e> chessguy_work: why not  y <- [x+1..6] ?
08:44:31 <notsmack> AStorm: a condition, the step is skipped if it returns false
08:44:35 <AStorm> int-e, it's an explanation :-)
08:44:37 <chessguy_work> int-e, for simplicity's sake
08:45:06 <AStorm> Hmm. Can one do function calls in the list comprehension syntax?
08:45:18 <vincenz> yes
08:45:33 <AStorm> E.g. [f x y | x<-['a'..'z'], y<-[1,2,3]]
08:45:40 <glguy> how do I undo a patch in darcs that is about 5 patches old?
08:45:43 <AStorm> That'd be almost like a map
08:45:45 <vincenz> > [(x,y) | x <- [1..4], y <- [1..4], x + y < 4]
08:45:46 <lambdabot>  [(1,1),(1,2),(2,1)]
08:46:02 <AStorm> vincenz, a stop condition, yes? :-)
08:46:25 <chessguy_work> not really a stop condition, more like a guard
08:46:35 <int-e> glguy: darcs undo? if it's your own local repository, darcs unrecord  works on old patches occasionally.
08:46:46 <vincenz> AStorm: + is a function, as is <
08:46:47 <koe> Parsec question: how would i have an "optional" piece of a parse, but return a value if it succeeds? some function like: GenParser tok st a -> GenParser tok st (Maybe a)
08:47:32 <AStorm> vincenz, yes, I know
08:47:37 <glguy> int-e: how do I identify the patch?
08:47:47 <glguy> I know the name of it
08:47:50 <glguy> or at least th ecomment
08:47:51 <chessguy_work> is there a way to say what type the expression in the condition has to have?
08:47:53 <int-e> glguy: -p "pattern"
08:48:00 <AStorm> Does that have to be -> Boolean?
08:48:06 <vincenz> AStorm: well you were asking about functions in list-comprehensions
08:48:19 <vincenz> AStorm: yes
08:48:22 <vincenz> @hoogle guard
08:48:24 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
08:48:24 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
08:48:24 <lambdabot> Language.Haskell.TH.Guard :: data Guard
08:48:59 <AStorm> ?hoogle ord
08:49:00 <lambdabot> Char.ord :: Char -> Int
08:49:00 <lambdabot> Prelude.Ord :: class Eq a => Ord a
08:49:00 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
08:49:06 <glguy> int-e: how do  I ununrecord a patch?
08:49:10 <glguy> int-e: can I?
08:49:38 <AStorm> glguy, darcs unrecord
08:49:51 <AStorm> give it an explicit revision
08:50:08 <int-e> glguy: err, unrecord is destructive, it deletes the patch.
08:50:17 <glguy> oh, i see
08:50:27 <AStorm> Ah, that, read wrong, sorry.
08:50:39 <glguy> I did a darcs push
08:50:43 <glguy> from my local copy
08:50:49 <glguy> so I'm OK now
08:51:01 * glguy needs a darcs darcs :)
08:51:08 <chessguy_work> can't you just roll back each patch one at a time, and darcs send -f patchX, then re-apply the ones you did want?
08:51:44 <int-e> yes. darcs send -o file  I think
08:52:15 <chessguy_work> right, -o, sorry
08:52:56 <hpaste>  malebria pasted "c2hs problem" at http://hpaste.org/92
08:53:15 <hpaste>  malebria annotated "c2hs problem" with "Compilation error" at http://hpaste.org/92#1
08:53:42 <malebria> I'm getting this error when trying to compile a very simple program with c2hs.
08:53:56 <malebria> It's just basic ffi, since c2hs role here is very small.
08:54:14 <int-e> malebria: interesting, why does it say Test.h and not test.h in the generated file?
08:54:26 <AStorm> :P
08:54:47 <int-e> malebria: but your problem is a different one
08:54:52 <kosmikus> bringert: what's the problem?
08:55:02 <int-e> malebria: 'main' must be defined in a module called 'Main'. Test.main won't work
08:55:17 <kosmikus> Igloo: what was the lhs2tex/Cabal problem?
08:55:31 <int-e> malebria: ZCMain_main_closure  is the mangled name for Main.main.
08:56:00 <malebria> int-e: it creates a Test.h with #include "test.h"
08:56:11 <int-e> malebria: ah. ok.
08:56:14 <malebria> int-e: I think it's for cleaning the .hs file.
08:56:23 <malebria> int-e: I didn't knew that Main.main thing.
08:56:57 <int-e> malebria: oh, and you
08:57:30 <malebria> int-e: thanks!
08:57:33 <int-e> malebria: you'll need to add test.c (or test.o, maybe) to the ghc command line, so it knows that it has to link that.
08:57:46 <malebria> int-e: yes, I remembered that, just include it right now, and it's working.
08:57:52 <malebria> int-e: thanks a lot.
08:58:01 <Donovan> Is there some command line option for ghc to make it output the C-- code to a file?
08:59:12 <int-e> Donovan: -ddump-cmm perhaps? (the option exists. I don't know what it does, exactly)
08:59:39 <AStorm> :>
09:00:06 <xic> what is the performance difference between Data.Map String a, and Data.Map (Word64, Word64) a?
09:01:12 <bd_> The first one has String keys and some (unspecified) value, the second has (Word64, Word64) as its key
09:01:46 <xic> right
09:01:51 <AStorm> Now, C-- looks nifty :>
09:02:54 <Lemmih> ?karma C
09:02:55 <lambdabot> C has a karma of 2
09:03:08 <bakert> karma--
09:03:25 <bd_> ?karma karma
09:03:26 <lambdabot> karma has a karma of 2
09:03:33 <bd_> ?karma karma++
09:03:34 <bakert> ?karma karma chameleon you come and go you come and go
09:03:35 <lambdabot> karma++ has a karma of 0
09:03:35 <lambdabot> karma has a karma of 2
09:03:39 <bd_> ?karma karma
09:03:40 <lambdabot> karma has a karma of 2
09:03:42 <bd_> :(
09:04:24 <glguy> ?karma
09:04:25 <lambdabot> You have a karma of 47
09:04:29 <bakert> ?karma
09:04:30 <lambdabot> You have a karma of 1
09:04:34 <bakert> woo and a hoo.
09:04:52 <int-e> ?karma dons
09:04:52 <lambdabot> dons has a karma of 116
09:04:58 <bakert> ?karma god
09:04:59 <lambdabot> god has a karma of 0
09:05:02 <bakert> ?karma buddha
09:05:03 <lambdabot> buddha has a karma of 0
09:07:31 <fons> hi all
09:08:54 <Vq^> hi you
09:12:04 <fons> I'm using Template Haskell to design a part of an embedded compiler
09:13:21 <AStorm> ?karma haskell
09:13:21 <lambdabot> haskell has a karma of 20
09:13:28 <AStorm> Hmm, dons > haskell? :P
09:13:32 <AStorm> Weird.
09:13:33 <fons> aand I would like to save the Ast given to a splice
09:14:32 <fons> The only Idea I came up with was transtaling it into a string with show and reading it back afterwards
09:15:34 <fons> cause I couldn't find a way to generate the Ast of an Ast
09:15:45 <AStorm> ?hoogle Ast
09:15:45 <lambdabot> Prelude.asTypeOf :: a -> a -> a
09:15:45 <lambdabot> Prelude.last :: [a] -> a
09:15:45 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
09:15:58 <fons> Appart from doing it by hand which is a real pain
09:17:18 <vincenz> sjanssen: Woo!
09:17:29 <vincenz> sjanssen: I love the cycle approach :)  Noone had thought of that in any of the languages
09:17:50 <sjanssen> vincenz: I had a more evil version that composed several cycles
09:17:54 <sjanssen> it was longer, though
09:18:36 <sjanssen> @paste
09:18:37 <lambdabot> http://hpaste.org (Haskell pastebin)
09:19:42 <hpaste>  sjanssen pasted "fizzbuzz" at http://hpaste.org/93
09:19:52 <vincenz> sjanssen: easier way ;)
09:19:56 <vincenz> @type cycle
09:19:58 <lambdabot> forall a. [a] -> [a]
09:23:47 <fabiand> hello, can someone tell me how i can get an Int when i get an Maybe?
09:24:27 <fabiand> (i want to get the index of the minimum element of a list: something like: elemIndex minimum xs)
09:24:27 <bd_> Do you mean Maybe Int -> Int?
09:24:46 <fabiand> yep
09:24:46 <bd_> :t maybe
09:24:48 <bd_> :t fromMaybe
09:24:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:24:50 <lambdabot> forall a. a -> Maybe a -> a
09:24:57 <bd_> those are two possibilities
09:24:58 <bd_> eg:
09:25:07 <bd_> > fromMaybe 0 Nothing
09:25:09 <lambdabot>  0
09:25:14 <bd_> > fromMaybe 0 (Just 1)
09:25:16 <lambdabot>  1
09:26:15 <fabiand> hmm okay
09:26:32 <bd_> You can also act on it as a Maybe:
09:26:36 <bd_> > fmap (* 2) Nothing
09:26:38 <lambdabot>  Nothing
09:26:40 <bd_> > fmap (* 2) (Just 40)
09:26:42 <sjanssen> > minimumBy (comparing snd) $ zip [0..] ['z', 'x', 'a', 'b']
09:26:42 <lambdabot>  Just 80
09:26:43 <lambdabot>   Not in scope: `comparing'
09:26:54 <bd_> :t comparing
09:26:56 <lambdabot> Not in scope: `comparing'
09:27:01 <sjanssen> @hoogle comparing
09:27:02 <lambdabot> No matches found
09:27:09 <sjanssen> it's new in GHC 6.6
09:27:14 <sjanssen> in module Data.Ord
09:27:15 <hpaste>  bjoern_ pasted "derivative of a "combination"" at http://hpaste.org/94
09:27:24 <bd_> @hoogle Ord b => (a -> b) -> a -> Ordering
09:27:25 <lambdabot> No matches, try a more general search
09:27:32 <bd_> @hoogle Ord b => (a -> b) -> a -> a -> Ordering
09:27:34 <lambdabot> No matches, try a more general search
09:28:21 <bjoern_> Hi, I'm trying to extend the validation algorithm in http://www.thaiopensource.com/relaxng/derivative.html with a new type of pattern and could use some help computing the derivative for it. Details at http://hpaste.org/94
09:30:00 <chessguy_lunch> f'(x)=(f(x)-f(x-h))/h
09:30:09 <chessguy_lunch> or something
09:30:23 <jrockway> limit h->0
09:30:34 <chessguy_work> that too
09:32:10 <chessguy_work> oh the first line of the paste runs on really badly
09:33:16 <chessguy_work> glguy, ping
09:33:23 <glguy> ?
09:33:24 <hpaste>  bjoern_ pasted "better formatting" at http://hpaste.org/95
09:34:09 <glguy> chessguy_work: hpaste is geared towards code and not essays
09:34:09 <chessguy_work> glguy, look at  http://hpaste.org/94
09:34:24 <chessguy_work> ok, just thought you might want to look at it
09:34:27 <bjoern_> http://hpaste.org/95 is http://hpaste.org/94 with better formatting
09:34:36 <glguy> chessguy_work: haskell code is not is not conducive to being auto-wrapped
09:34:43 <glguy> (I did see it though)
09:34:58 <chessguy_work> ok
09:36:04 <chessguy_work> what is a RELAX NG schema anyway?
09:36:29 <bjoern_> RELAX NG is a schema language to validate XML documents, http://relaxng.org/
09:36:31 <lambdabot> Title: RELAX NG home page
09:36:59 <chessguy_work> ah, thanks
09:37:47 <vincenz> @info Enu
09:37:48 <lambdabot> Enu
09:37:49 <vincenz> @info Enum
09:37:50 <lambdabot> Enum
09:44:59 <apfelmus> glguy: line wrap in hpaste would be really nice
09:45:20 <glguy> at best it would be a checkbox in the formatting options
09:45:28 <glguy> but definitely wouldn't be default
09:45:39 <apfelmus> yes.
09:45:55 <hpaste>  vincenz annotated "fizzbuzz" with "nasty :D" at http://hpaste.org/93#1
09:46:17 <kosmikus> glguy: you could make it an option for the person viewing rather than for the person pasting ...
09:46:30 <glguy> right, that's what I meant
09:46:39 <glguy> (there is a format button on the bottom of the view page)
09:46:55 <Syzygy-> We have a paste of our own now?
09:47:04 <kosmikus> glguy: right
09:47:39 <hpaste>  int-e annotated "fizzbuzz" with "86 characters" at http://hpaste.org/93#2
09:47:41 <glguy> !paste
09:47:41 <hpaste> Haskell paste bin: http://hpaste.org/
09:47:43 <bakert> Hmm.  A module can't import a module that imports it?
09:48:14 <bakert> That's unfortunate.
09:48:17 <apfelmus> bakert: yesno. that's recursive modules.
09:48:34 <apfelmus> although the Haskell98 allows them, they're a mess in ghc
09:48:38 <bakert> What about "import once" type importing?
09:48:40 <apfelmus> *standard
09:48:50 <bakert> Hmm.
09:48:53 <bakert> What to do.
09:49:01 <kosmikus> it's not that bad with ghc nowadays
09:49:11 <kosmikus> writing boot files has become a lot easier
09:49:15 <kosmikus> but it's still somewhat fragile
09:49:30 <apfelmus> how so?
09:49:44 <kosmikus> how's it fragile?
09:49:54 <bakert> I have a general module with the type and helper functions.  Then I have specific modules for specific bits.  But the general module wants to form a list of all the specific bits.  And the specific modules need the type defined in the general module.  I guess I need a new module that imports both for the list.
09:49:54 <vincenz> how do you put code on reddt?/
09:50:40 <kosmikus> apfelmus: well, there's no guarantee that the syntax doesn't change; and there might still be some things you'd expect to be able to write in boot files that you can't etc.
09:50:40 <apfelmus> kosmikus: too. but i mean the boot files. maybe i just have to look up :)
09:50:56 <apfelmus> ok
09:51:36 <apfelmus> btw, iirc jhc does recursive modules without boot files
09:52:00 <kosmikus> apfelmus: jhc does whole-program-compilation. it's trivial then ;)
09:52:16 <kolmodin> hah :D
09:52:16 <apfelmus> a, cheating :)
09:55:43 <koe> ?src concatMap
09:55:44 <lambdabot> concatMap f = foldr ((++) . f) []
09:57:29 <chessguy_work> @type concatMap
09:57:30 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
10:10:07 <apfelmus_> ski: ping
10:12:56 <bakert> partial application is so lovely.
10:13:27 <apfelmus> hugs -partial http://haskell.org
10:13:29 <lambdabot> Title: Haskell - HaskellWiki
10:16:51 <malebria> Is it creating a pure function from a foreign call and creating a unpure and using unsafePerformIO the same?
10:17:37 <AStorm> Probably.
10:18:58 <malebria> Bye.
10:22:24 <bakert> ClockTime, or CalendarTime?
10:22:48 <Saizan> ?hoohle CalendarTme
10:22:49 <lambdabot> No matches found
10:22:51 <Saizan> ?hoohle CalendarTime
10:22:52 <lambdabot> System.Time.CalendarTime :: Int -> Month -> Int -> Int -> Int -> Int -> Integer -> Day -> Int -> String -> Int -> Bool -> CalendarTime
10:22:52 <lambdabot> System.Time.CalendarTime :: data CalendarTime
10:22:52 <lambdabot> Time.calendarTimeToString :: CalendarTime -> String
10:23:00 <Saizan> ?hoohle ClockTIme
10:23:01 <lambdabot> System.Time.ClockTime :: data ClockTime
10:23:01 <lambdabot> Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
10:23:01 <lambdabot> Time.getClockTime :: IO ClockTime
10:23:12 <resiak> I wish #haskell hadn't introduced me to reddit.  My RSS reader is now always full of unread items :(
10:23:44 <bakert> Saizan, but which do you prefer?
10:24:05 <bakert> I've just switched everything to ClockTime.
10:25:38 <Saizan> bakert: i was only exploring, don't know much about them, CalendarTime seems more a kind of data-time representation, where ClockTime is the simple seconds-from-epoch, right?
10:25:44 <bakert> yeah
10:25:58 <bakert> i was using CalendarTime but it started to get ugly so I simpified.
10:26:06 <bakert> Just wanted a bit of validation for my decision
10:26:07 <bakert> !
10:26:12 <Saizan> :D
10:26:47 <Saizan> i'm quite scared by CalendarTime's contructor
10:27:11 <dr_strangelove> is there a mutable list data structure that can grow? something like vector<T> in c++?
10:27:51 <sjanssen> dr_strangelove: is a mutable structure really necessary?
10:28:37 <sjanssen> there is Data.Sequence that supports O(1) inserts on the left and right ends, but it's a functional data structure
10:28:48 <dr_strangelove> sjanssen, I want to store user input from a gui
10:29:25 <xic> is there a mutable version of Data.Map, or does it already have high performance when put inside a TVar?
10:29:35 <sjanssen> what about indexing, do you need that
10:29:59 <dr_strangelove> I need iterating
10:30:09 <sjanssen> xic: I know people have attempted to write a mutable map, but TVar Map always turns out faster
10:30:23 <sjanssen> dr_strangelove: you could put a Data.Sequence inside an MVar
10:30:32 <xic> sjanssen: what if i have thousands of keys?
10:31:04 <sjanssen> xic: I'd recommend TVar Map
10:31:28 <sjanssen> especially if the ratio of lookups to inserts is very high
10:31:53 <xic> yes, my ratio of lookups to inserts is indeed high. thanks i'll give it a try
10:32:45 <sjanssen> the problem with a custom data structure is the overhead of reading O(log n) TVars
10:34:54 <xic> hm....
10:35:53 <chessguy_work> wheee
10:37:19 <glguy> ?seen dons
10:37:19 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7h 22s ago.
10:38:25 <glguy> ?tell dons I was hoping to discuss the result of your profiling with you, let me know when you are around :)
10:38:25 <lambdabot> Consider it noted.
10:42:48 <dr_strangelove> is Data.Sequence in ghc 6.4.2?
10:43:36 <mauke_> I don't think so
10:43:37 <sjanssen> dr_strangelove: nope
10:44:57 <dr_strangelove> hm
10:56:37 <xic> is there something like showHex that always outputs 2 digits?
10:56:54 <mauke_> > printf "%02x" 42 :: String
10:56:56 <lambdabot>  Add a type signature
10:57:18 <mauke_> > printf "%02x" (42::Int) :: String
10:57:19 <lambdabot>  "2a"
10:57:28 <mauke_> > printf "%02x" (1::Int) :: String
10:57:30 <lambdabot>  "01"
10:57:52 <xic> hm..... how is the performance of printf?
10:58:44 <mauke_> no idea :-)
11:00:20 <sjanssen> @src Text.Printf
11:00:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:02:56 <Procyon> @src Text.printf
11:02:57 <lambdabot> Source not found. Where did you learn to type?
11:03:01 <AStorm> Why is lambdabot so abusive? :P
11:06:56 <glguy> because you touch yourself at night
11:09:38 <Procyon> I'm safe though, because I only touch myself in a monad
11:10:24 <sjanssen> you better stop that, or we'll have you mfix'ed!
11:16:27 <chessguy_work> @quote electro-shock
11:16:27 <lambdabot> dons says: [lambdabot]  Source not found. Your mind just hasn't been the same since the electro-shock, has it? [dons] not yet
11:18:30 <Procyon> Are overlapping patterns less efficient in general? ie. data T=A|B; f1 A=...;f1 B=...; vs. f2 A=...;f2 _=...;
11:19:48 <hpaste>  csci pasted "Question on tail-recursion with Monads." at http://hpaste.org/96
11:20:02 <xic> what's faster, ((1:2):3):[] or 4:(5:(6:[]))?
11:20:15 <csci> Hope, someone can help with my question in hpaste
11:20:41 <mauke_> xic: ((1:2):3):[] because it doesn't compile
11:20:42 <int-e> Procyon: hmm, these two functions should generate the same code really.
11:20:48 <apfelmus> xic: the question is void because the first doesn't parse
11:20:58 <xic> oh yeah oopsie
11:21:23 <apfelmus> xic: but i think you mean something like (xs ++ ys) ++ zs and xs ++ (ys ++ zs)
11:21:31 <xic> yeah
11:21:52 <koala_man> if you have something like let x=42 in x, what do you call 'x'? like what you in other languages would call a variable?
11:21:58 <Procyon> int-e: I am occassionally hearing that "pattern overlapping is bad" in vague generalities.  I'm curious to understand if this is legit, and if so, why?
11:22:07 <mauke_> koala_man: I call it a variable
11:22:20 <xic> isn't it really a function though?
11:22:25 <apfelmus> xic: in this case, the second is faster. the point is that xs ++ ys take (length xs) operations
11:22:31 <apfelmus> *takes
11:22:34 <koala_man> a function with no arguments
11:22:43 <mauke_> you can use the ShowS trick
11:23:05 <int-e> Procyon: I don't think there's a runtime cost at all. There may be correctness concerns.
11:23:09 <astrolabe> The usual name is 'variable', I think, even though it doesn't vary.
11:23:14 <paolino> Module imports form a cycle for modules
11:23:14 <paolino> what is going on here ?
11:23:28 <apfelmus> xic: so the first takes (2*length xs + length ys) operations whereas the second only (length xs + length ys)
11:23:39 <int-e> Procyon: like in  f A _ = 1; f _ B = 2 ... which suggests that f x B = 2 no matter what x is.
11:23:51 <koala_man> isn't there a fancy mathematical term for it that I can show off with?
11:23:58 <int-e> Procyon: but that's a rather weak concern in my eyes.
11:23:58 <Procyon> "Implementation of Func Programs" gives a scenario of where non overlaps are easier to optimize even if they require additional checks.  I was wondering if Haskell was implemented with a similar algorithm.
11:25:16 <int-e> Procyon: a restriction is that the compiler can't change the order of overlapping pattern matches. but usually that's the point of having them in the first place.
11:25:45 <pejo> koala, what is wrong with calling it a variable, since that is what it is?
11:25:47 <apfelmus> csci: mh, while tail recursion exists in haskell, it's generally not important. i'm not sure why you want the monad, anyway
11:26:10 <paolino> how should modules be used , so that error disappears ?
11:26:12 <xerox> paolino: search for discussions about cyclic module dependencies
11:26:15 <Procyon> int-e: right.  Your example is one of "that's harder to read." I have a case where "catchall" cases unclutter the code quite a bit, but require overlap.   I was wondering if that was neccissarily a "bad Thing"
11:27:22 <paolino> xerox, in the logs of the channel ? Isn't a theory about them ?
11:27:57 <apfelmus> csci: (do { tmp <- f ; return tmp; } ) is entirely the same as (f)
11:28:41 <basti_> whoops
11:28:44 <int-e> Procyon: I don't worry about it. I hope the compiler is smart enough to figure it out in most cases.
11:29:05 <astrolabe> paolino: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
11:29:05 <Procyon> int-e: if there's no other reason of "badness" other than code clarity, then I'll stick with the overlapping version which is much more concise and clear.
11:29:08 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
11:30:10 <lisppaste2> Botje pasted "Silly optimization challenge.. any way to get this faster?" at http://paste.lisp.org/display/35921
11:30:12 <apfelmus> Procyon: that's the spirit: don't worry, be lazy
11:31:27 <apfelmus> Botje: show your friends the implementation in three lines
11:31:40 <apfelmus> implementation of quicksort i mean
11:31:43 <Botje> I know about quicksorts.
11:31:46 <Botje> however, this is bubblesort.
11:31:59 <Botje> We are comparing different languages
11:32:11 <apfelmus> yes. it's just that quicksort is waaay shorter
11:32:15 <Botje> so far C is winning (2sec), followed by SBCL (7sec) and haskell (19sec)
11:32:27 <Botje> all with the same un-optimized bubble sort
11:32:31 <xic> is there something like fold that lets me thread a state through?
11:32:47 <apfelmus> ?t foldM
11:32:48 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
11:32:49 <Procyon> Botje: Why would you use Bubblesort?  If you are sorting more than about 12 items, quicksort is invariably faster.
11:32:59 <apfelmus> :t foldM
11:33:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:33:06 <Botje> I _KNOW_ about quicksort
11:33:13 <Botje> hence the "silly optimization challenge" in the title
11:33:29 <Procyon> Botje: oh.. sorry.  I'm out of context :)
11:33:37 <Botje> we're trying to measuer how much overhead every language imposes
11:33:41 <basti_> bubblesort is very good for 3d applications
11:33:42 <Botje> *measure
11:33:52 <basti_> cos 3d data is almost presortet
11:33:58 <glguy> are the bubble sorts allowed to exit early?
11:34:03 <Botje> my first try was the state monad + (U)Array
11:34:05 <Botje> that was horrible
11:34:05 <paolino> astrolabe, that's complicate uh
11:34:16 <mauke> Botje: hmm, I wonder what happens if you use Foreign.Ptrs and stuff
11:34:23 <int-e> @index unsafeRead
11:34:23 <apfelmus> Botje: mmh. Haskell has clearly less coding overhead :)
11:34:23 <lambdabot> bzzt
11:34:33 <apfelmus> @index readInt
11:34:33 <lambdabot> Numeric
11:34:52 <apfelmus> Botje: int-e created readInt for your purpose
11:34:54 <Botje> glguy: that's a last resort, I'd really like to keep the algorithm the way it is
11:35:02 <apfelmus> :t readInt
11:35:04 <glguy> Botje: is the bubble sort algorithm you are supposed to use, are you *allowed* to exit early
11:35:04 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
11:35:16 <glguy> Botje: if the implementations in other languages are, that will matter
11:35:28 <Botje> glguy: no early exits, for now.
11:35:31 <int-e> apfelmus: uh hmm. that reminds me of something.
11:35:40 <chessguy_work> bzzt? what kind of a response is that?
11:35:41 <Botje> because it will speed up the other languages too
11:35:56 <apfelmus> int-e: i'm listening
11:36:01 <glguy> Botje: I was just making sure it was a level playing field :)
11:36:03 <Botje> apfelmus: i'll keep readInt in mind
11:36:08 <Botje> glguy: oh, it is
11:36:16 <Botje> we're testing on an oldish 1GB box with 256 mb of ram
11:36:24 <paolino> is there a rule of the thumb for organizing code to minimize hs-boot files ?
11:36:26 <int-e> apfelmus: I still haven't finished the String versions of that stuff, this code is just in Data.ByteString
11:36:42 <Botje> haskell beat SBCL and stalin in a naive fib(42) benchmark
11:37:09 <Botje> using if .. then .. instead of pattern matches doubled the speed of fib, too :)
11:37:31 <Procyon> If I'm not mistaken (and as a haskell noob, I probably am) doesn't that bublesort copy the entire array on every swap?  That's got to be bad for performance.
11:37:36 <int-e> @type Array.Base.unsafeWrite
11:37:37 <xerox> paolino: wherever people talk, ml I think are a good place
11:37:38 <lambdabot> Couldn't find qualified module.
11:37:41 <apfelmus> int-e: mh. strange it appears in Numeric
11:37:49 <int-e> @type Data.Array.Base.unsafeWrite
11:37:52 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => a i e -> Int -> e -> m ()
11:38:08 <xerox> paolino: ah astrolabe sorted it out. cool.
11:38:21 <Botje> Procyon: IOUArray is a mutable unbox array.
11:38:23 <int-e> apfelmus: yes, these functions are there. they're not very fast though, especially for big numbers.
11:38:47 <Botje> Procyon: like a C array, that's why bubble is in the array monad
11:38:49 <Botje> *IO monad
11:38:51 <Botje> argh :)
11:39:40 <hpaste>  glguy pasted "My bubble sort" at http://hpaste.org/97
11:39:46 <Procyon> See!  I told you I was mistaken! ;)
11:39:58 <ihope> IO is all about arrays, I'm sure.
11:40:12 <apfelmus> int-e: mh. i can't even find it in ByteString. you released it separately, didn't you?
11:40:18 <Botje> Procyon: as I said, my first attempt used State. that cause the box to go thrashing after about 5 seconds
11:40:22 <AStorm> glguy, isn't that a selection sort?
11:40:37 <Excedrin> Botje: does GHC beat SBCL and stalin at wli's optimized fib?
11:40:42 <Botje> glguy: I tried a similar implementation, it's too damn slow :(
11:40:47 <glguy> heh
11:40:47 <Botje> Excedrin: what's that? *googles*
11:41:15 <chessguy_work> hmmm. glguy, is bubble cs = cs equivalent to bubble [] = [] there?
11:41:20 <glguy> AStorm: no, i don't think so
11:41:28 <int-e> apfelmus: hmm
11:41:33 <Excedrin> Botje: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
11:41:34 <glguy> chessguy_work: no
11:41:35 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
11:41:40 <glguy> chessguy_work: it also handles [c]
11:41:48 <Botje> Excedrin: ah.
11:41:49 <chessguy_work> hmm
11:41:54 <chessguy_work> wouldn't c match as c:{}
11:41:56 <chessguy_work> er
11:41:58 <chessguy_work> c:[]
11:42:03 <Botje> Excedrin: again, we opted to choose the most naive approach possible for fib.
11:42:04 <glguy> AStorm: each iteration of selection sort doesn't scan the whole list
11:42:05 <chessguy_work> oh, never mind
11:42:10 * chessguy_work shuts up
11:42:12 <Botje> that is, the tree-recursive solution.
11:42:21 <int-e> apfelmus: it's in Data.Bytestring.[Lazy.]Char8
11:42:43 <Botje> C does amazingly well (55ms), followed by haskell (64 ms) followed by SBCL (120 ms)
11:43:10 <glguy> Botje: did you try writing your buble sort using STUArrays?
11:43:20 <Botje> interestingly: FORTRAN uses the floating point registers and somehow comes out at the same speed as C
11:43:22 <apfelmus> int-e: ok
11:43:35 <Botje> glguy: that's what I have in stock for tonight, are they that much faster than IOArrays?
11:43:50 <Botje> hmm, brb dinner
11:43:57 <paolino> is Cabal aware of hs-boot files ?
11:44:05 <glguy> Botje: IOUArray and STUArray are comparible
11:44:14 <glguy> comparable
11:44:14 <Botje> I'll profile my current bubblesort to find the true bottleneck
11:44:19 <AStorm> glguy, this one doesn't too
11:44:27 <Botje> glguy: will try, after food :)
11:44:33 <glguy> AStorm: mine is a bubble sort :)
11:44:52 <Z4rd0Z> What is the reason for a data definition such as 'data CConn = CConn'?  (from hdbc sources)
11:45:03 <int-e> apfelmus: and the other stuff you mean is  darcs get http://int-e.home.tlink.de/haskell/readinteger
11:45:06 <ihope> Botje: I think the bottleneck of your bubblesort is that it's a bubblesort. :-P
11:45:22 <ihope> Z4rd0Z: probably a phantom type.
11:45:29 <int-e> apfelmus: but it's not 'released' as such.
11:45:36 <ihope> ...I think.
11:45:46 <moonlite> is STM hard to grasp? I'm supposed to hold a short speech about it next Friday, and wondered if it is feasible to learn it in a few days?
11:46:46 <AStorm> moonlite, if you know C pointers, STM is just a better version of C array :>
11:46:47 <paolino> moonlite, the santa paper from the author is nice to read
11:46:50 <AStorm> Yep.
11:46:54 <AStorm> ?where STM
11:46:55 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
11:46:59 <AStorm> Uh?
11:47:29 <apfelmus> int-e: ok, thanks
11:47:30 <AStorm> Yes, that's the one.
11:47:41 <AStorm> Just a concurrent array.
11:47:42 <Procyon> ihope: optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of time, but it still feels good.
11:47:54 <ihope> Indeed.
11:47:54 <mauke> AStorm: array?!
11:48:03 <AStorm> Let's call it a monad.
11:48:40 <paolino> http://research.microsoft.com/~simonpj/tmp/beautiful.ps
11:49:01 <hpaste>  glguy annotated "My bubble sort" with "ST Bubblesort" at http://hpaste.org/97#1
11:49:21 <paolino> @bot
11:49:21 <lambdabot> :)
11:49:38 <moonlite> paolino and AStorm: thx!
11:50:07 <xerox> I don't know if you know this, but it is just *too* crazy: http://mathworld.wolfram.com/TuppersSelf-ReferentialFormula.html it mush show something about the very nature of mathematicians.
11:50:08 <lambdabot> Title: Tupper's Self-Referential Formula -- from Wolfram MathWorld
11:50:54 <allbery_b> @remember Procyon ihope: optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of time, but it still feels good.
11:50:55 <lambdabot> Done.
11:51:13 <AStorm> xerox, like a fractal :>
11:51:58 <AStorm> The function has a limit, so can be graphed :>
11:52:17 <allbery_b> it's just a bitmap plotter anyway
11:52:26 <Procyon> glguy: your bubblesort walks the entire list at each iteration.  You can get away with walking down 1 less with each loop, since the largest is already at the end.
11:52:37 <AStorm> Yes.
11:52:40 <glguy> Procyon: my ST bubble sort doesn't
11:52:42 <AStorm> But funny, hehe.
11:52:49 <xerox> Sorry?
11:52:57 <AStorm> This function graphs itself.
11:53:01 <glguy> but a "tail" could fix that
11:53:01 <AStorm> :>
11:53:23 <xerox> AStorm: what do you mean by "like a fractal, ..." ?
11:54:02 <AStorm> This function is indeed fractal in nature. You give it input data (almost in a form of bitmap), throw it through the function, it is drawn.
11:55:26 <AStorm> But why did someone look so hard for that... Finding that n value surely was hard.
11:57:17 <hpaste>  glguy annotated "My bubble sort" with "bubsort :: (MArray a t m, Ix i, Ord t) => a i t -> m ()" at http://hpaste.org/97#2
11:57:23 <glguy> a more general bubble sort :)
11:57:46 <glguy> works on any mutable array with ordered elements
11:59:44 <Jaak> > ap zip tail [1..3]
11:59:46 <lambdabot>  [(1,2),(2,3)]
11:59:57 <AStorm> glguy, iterative, yuck :P
12:00:04 <AStorm> undo that, ok?
12:00:13 <glguy> ?
12:00:42 <AStorm> @undo
12:00:42 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
12:00:45 <mahogny> ...bubble sort :(
12:00:49 <glguy> let pairs = ap zip tail r
12:00:52 <glguy> you want that change?
12:00:58 <AStorm> Not just that.
12:01:22 <AStorm> Add some >>= here and there
12:01:55 <hpaste>  apfelmus annotated "My bubble sort" with "reading ints from ByteString" at http://hpaste.org/97#3
12:03:40 <int-e> hmm. did anyone try unsafeRead + unsafeWrite?
12:04:10 <hpaste>  glguy annotated "My bubble sort" with "for astorm" at http://hpaste.org/97#4
12:05:06 <glguy> unsafeRead and unsafeWrite don't speed up much
12:05:12 <glguy> when I was profiling a previous app
12:05:24 <glguy> didn't *
12:06:49 <AStorm> :>
12:07:48 <bakert> Anyone used HDBC with PostgreSQL for dates?  The docs explicitly say that the values should come out as ClockTime or CalendarTime but they come out as Strings.
12:08:00 <bakert> Just wondering if I am doing anything stupid.
12:08:54 * allbery_b wonders if people arfe *really* that bored.  bubblesort?!
12:09:18 <int-e> allbery_b: better than FizzBuzz ;)
12:11:06 <AStorm> dons, who broke @undo? :>
12:11:07 <xerox> any better idea allbery_b ?
12:11:29 <bakert> xerox, you could write a SOAP library for haskell?
12:11:34 <AStorm> glguy, why do you need that Ix? :>
12:11:53 * xerox ducks
12:11:53 <glguy> *Main> :i readArray
12:11:53 <glguy> readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
12:11:54 <glguy>         -- Defined in Data.Array.Base
12:12:02 <glguy> AStorm: so that I can operate on an array
12:12:53 <int-e> glguy: hmm. my experience was different, when I experimented with matrix multiplications
12:13:28 <int-e> glguy: but maybe this was mainly due to using pairs as indices.
12:13:42 <glguy> int-e: that makes sense
12:13:50 <glguy> int-e: unsafeRead just bypasses the bounds checking
12:14:02 <int-e> and the index calculation
12:14:19 <Procyon> Another bubblesort analogy is that if you do have an amazing experience, it's hard to tell your friends without it getting really awkward. "So, I was optimizing bubblesort the other day..."  "You were WHAT?!?"
12:14:27 <int-e> (you pass a 0-based Int index to unsafeRead)
12:14:31 <glguy> AStorm:
12:14:33 <glguy> is this what you wanted?
12:14:36 <glguy> ?pl  liftM (ap zip tail . range) (getBounds arr) >>= \pairs -> forM_ pairs $ \_ -> forM_ pairs $ \(i,j) -> readArray arr i >>= \a -> readArray arr j >>= \b -> when (a > b) $ writeArray arr i b >> writeArray arr j a
12:14:37 <lambdabot> ap forM_ (const . flip forM_ (uncurry (ap ((.) . (>>=) . readArray arr) (ap ((.) . (>>=) . readArray arr) . (ap (ap . (when .) . (>)) .) . (. writeArray arr) . (.) . flip . ((>>) .) . writeArray arr)
12:14:38 <lambdabot> ))) =<< fmap (ap zip tail . range) (getBounds arr)
12:14:46 <AStorm> Haha!
12:14:46 <int-e> weee
12:14:53 <xerox> sigh
12:15:05 <AStorm> No liftM at all.
12:15:07 <apfelmus_> glguy: what are you doing? that's pointless.
12:15:14 <glguy> ahahaha
12:15:16 <glguy> you are funny
12:15:35 <AStorm> ?src liftM
12:15:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:15:53 <AStorm> @undo do { x1 <- m1; return (f x1) }
12:15:54 <lambdabot> m1 >>= \ x1 -> return (f x1)
12:15:59 <AStorm> ?
12:16:20 <mauke> @. pl . undo src liftM
12:16:21 <lambdabot> (line 1, column 21):
12:16:21 <lambdabot> unexpected "{"
12:16:21 <lambdabot> expecting variable, "(", operator or ")"
12:16:41 <lokojones> hey guys
12:16:41 <AStorm> Wrong order
12:16:42 <xerox> pl liftM => fmap
12:17:00 <xerox> it's in the last line
12:17:07 <glguy> liftM f m = return f `ap` m
12:17:18 <glguy> ?type \f m -> return f `ap` m
12:17:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
12:17:23 <glguy> ?type liftM
12:17:25 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
12:18:00 <glguy> liftM2 f m n = return f `ap` m `ap` n -- and so on :)
12:18:44 <AStorm> ?type ap
12:18:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:19:45 <lokojones> I have a recursive funcion (that works, of course), but I just need it to do one more thing: In each recursive call, I need it to print some data
12:19:52 <lokojones> which ways could I use to do this?
12:20:02 <lokojones> I was thinking of using "do"
12:20:09 <mauke> Writer monad or IO
12:20:36 <lokojones> but it complains about returning IO and no  [[Float]] (which is the type it should return
12:20:42 <lokojones> )
12:21:31 <AStorm> lokojones, liftM maybe?
12:21:33 <mauke> if it needs to print something, the return type must contain IO, like IO [[Float]]
12:21:43 <AStorm> Ah yes.
12:21:58 <AStorm> So just maybe putStr inside
12:22:12 <lokojones> no, the function itself shouldnt return IO type
12:22:21 <lokojones> its called by another functions
12:22:35 <lokojones> I just need that it prints something in the stdout
12:22:42 <Saizan> lokojones: why?
12:22:46 <mauke> you can't do that
12:22:55 <mauke> if it doesn't return IO, it can't print
12:23:05 <lokojones> umh
12:23:18 <sjanssen> lokojones: does it need to print for debugging purposes?
12:23:20 <rahikkala> lokojones: If it's merely for the purpose of figuring out what the function is doing, use Debug.Crace
12:23:23 <rahikkala> *Trace
12:23:26 <lokojones> sjanssen: yes
12:23:39 <sjanssen> lokojones: then it's okay to use Debug.Trace
12:23:42 <lokojones> but actually, its not exactly debug
12:24:02 <sjanssen> but please do not use trace for anything other than debugging
12:24:17 <lokojones> sjanssen: yes, I had heard about trace
12:24:27 <lokojones> but I knew it was for debuggin, so I didnt want to use it
12:24:33 <lokojones> its hard to explain it..
12:24:49 <lokojones> I have been writing a genetic algoryhtm for one month now
12:24:51 <lokojones> its done
12:24:55 <sjanssen> so you want this function to print things out as a normal part of it's operation?
12:25:24 <lokojones> and some days ago I was told that it should output the status of every generation
12:25:37 <lokojones> just to see how it works
12:25:44 <chessguy_work> lokojones, what are you evolving?
12:25:48 <lokojones> so my teacher can verify that its doind things ok
12:25:54 <lokojones> *doing
12:26:13 <lokojones> chessguy_work: numbers? maybe I havent explained myself correctly...
12:26:30 <chessguy_work> what problem are you trying to solve?
12:26:37 <astrolabe> lokojones: I think you either need to change your code around a bit, or use Debug.Trace
12:26:46 <rahikkala> Debug.Trace should be fine, then, you'll just have to explain why the trace output doesn't always come out in the "obvious" order
12:27:05 <lokojones> ok, ill just use trace then
12:27:07 <glguy> ?src trace
12:27:08 <lambdabot> trace string expr = unsafePerformIO $ do
12:27:08 <lambdabot>     hPutStrLn stderr string
12:27:08 <lambdabot>     return expr
12:27:20 <lokojones> I dont think he will not pass me for using trace :p
12:27:40 <glguy> trace doesn't enforce that the hPutStLn occurs before the expr can be computed?
12:27:41 <chessguy_work> lokojones, i'm interested in genetic approaches to AI. i'd love to see your code
12:27:46 <astrolabe> It sounds as though you actually are using it for tracing
12:27:58 <lokojones> chessguy_work: np :)
12:28:13 <lokojones> can you PM with you mail?
12:28:14 <sjanssen> glguy: unsafePerformIO ensures that
12:28:16 <chessguy_work> sure
12:28:17 <lokojones> your*
12:28:38 <sjanssen> glguy: well, sequencing in the IO monad, actually
12:28:42 <glguy> right
12:28:51 <lokojones> got It chessguy
12:29:00 <chessguy_work> cool
12:29:00 <glguy> so he could expect the trace messages for each generation to be printed in sequence then
12:29:05 <lokojones> take into account its my first time with functional languages :P
12:29:17 <lokojones> its a bit dirty, and comments are written in spanish :P
12:29:36 <sjanssen> glguy: they'll be printed in the order that the computations are evaluated
12:29:41 <chessguy_work> lo limpiare :)
12:29:56 <glguy> sjanssen: right... and one generation can't very well be computed before an earlier one
12:30:07 <sjanssen> whether this is the "obvious" order depends on the application
12:30:09 <pbx> Anybody know why HWN is stuck on January 9?  Not that I have time to read it right now...
12:30:38 <glguy> dons has been out and about going to conferences I believe
12:30:41 <sjanssen> glguy: most likely, but you never can tell without seeing the code
12:31:00 <sjanssen> pbx: look for it next week
12:31:06 <pbx> Cool, thanks!
12:31:35 <Procyon> chessguy: I should have a system that allows the evolution of fully recursive subtrees with variables soon that doesn't leave free variables around after crossover.  I'll get you the code once it's working.
12:31:37 <AStorm> @vixen
12:31:38 <lambdabot> <undefined>
12:31:41 <lokojones> chessguy_work: ill just finish some cleaning and send it
12:31:41 <AStorm> @vixen Hmm?
12:31:42 <lambdabot> <undefined>
12:31:44 <glguy> I told dons "Don't make another HWN until I write hpaste"
12:31:46 <AStorm> @help vixen
12:31:46 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
12:31:47 <glguy> and here we are
12:31:57 <AStorm> Something doesn't work.
12:32:05 <glguy> known issue
12:33:01 <chessguy_work> Procyon, cool. sounds great
12:34:05 <apfelmus> int-e: mh, readUnsafe could be useful. the generated core for bubsort :: STUArray s Int Int -> ST s () looks quite good.
12:36:54 <sjanssen> bubble sort?!
12:37:29 <glguy> apfelmus: paste said core?
12:37:35 <chessguy_work> i think the next HWN is going to be massive, and that's why it's taking a while
12:37:44 <sjanssen> glguy: you killed HWN!
12:37:46 <emu> {lonely hearts club} U {_|_}
12:37:52 <Jaak> HMN!
12:38:52 <tuukkah> would someone know how to create profiling versions of libraries with cabal?
12:39:27 <sjanssen> tuukah: runghc Setup.hs configure --enable-library-profiling
12:39:35 <apfelmus> glguy: i don't know whether this is a good idea, but here you go
12:39:39 <Procyon> how do I leave a message for dons?  hpaste needs an expiration tag, as the browser cache isn't forced to refresh to pick up annotations.
12:39:39 <hpaste>  apfelmus annotated "My bubble sort" with "bubsort core" at http://hpaste.org/97#5
12:39:49 <tuukkah> sjanssen, now that's easy!
12:39:53 <benja_> tuukkah and I were wondering whether implementing a new build system for gtk2hs in cabal would be easier than adapting the current system for profiling =-)
12:40:04 <sjanssen> apfelmus: why, oh why, are you writing bubble sort?
12:40:11 <lokojones> trace isnt part of prelude, is it?
12:40:12 <mauke> Procyon: @tell dons ...
12:40:21 <mauke> @index trace
12:40:22 <lambdabot> Debug.Trace
12:40:23 <apfelmus> sjanssen: plain Botje, i'm innocent !
12:40:37 <lokojones> oh, thanks mauke
12:40:42 <lokojones> or lambdabot :)
12:40:43 <Procyon> @tell dons hpaste needs an expiration tag, as the browser cache isn't forced to refresh to pick up annotations.
12:40:44 <lambdabot> Consider it noted.
12:40:54 <apfelmus> sjanssen: *blame
12:41:57 <sjanssen> somebody ought to implement quicksort.  That'd actually be useful
12:42:08 <emu> isn't hpaste glguy's project
12:43:11 <emu> sjanssen: with STArrays you're saying?
12:43:13 <Procyon> emu: I thought it was dons.  oops.  If it's glguy's, then I assume he might overhear this exchange ;)
12:43:31 <sjanssen> emu: ideally with any MArray
12:43:37 <emu> randomized pivot? oO
12:45:54 <sjanssen> emu: the naive approach would be a fine start
12:53:26 <chessguy_work> @tell glguy [15:37] <Procyon> @tell dons hpaste needs an expiration tag, as the browser cache isn't forced to refresh to pick up annotations.
12:53:26 <lambdabot> Consider it noted.
12:56:58 <apfelmus> array, mutable \\ quicksort, pivot is random. \\ poor, poor haskell. snob.
13:13:25 <emu> how abou tthis
13:13:30 <emu> hpaste: url
13:13:31 <hpaste> Haskell paste bin: http://hpaste.org/
13:13:55 <pbx> Hey, neat! When did that show up?
13:13:56 <hpaste>  emu pasted "Quick Sort on array" at http://hpaste.org/98
13:14:11 <emu> (naive pivot choice)
13:14:45 <pbx> I guess I can remove Haskell as a syntax option from dpaste.com now :)
13:15:14 <glguy> hpaste is mostly directed at #haskell specifically though
13:15:15 <lambdabot> glguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:15:26 <pbx> glguy: I know! I suggested the name, didn't I?
13:15:42 <glguy> you may very well have!
13:15:48 <pbx> Looks nice.
13:16:34 <glguy> thanks :)
13:16:52 <Saizan> it would be nice to have it in the "regional" channels, too
13:17:12 <glguy> multiple channel support is on my list of things to do :)
13:19:09 <glguy> ?tell Procyon I added a no-cache header to the paste list page for ya ;)
13:19:10 <lambdabot> Consider it noted.
13:19:24 <fabiand> hello
13:19:54 <mahogny> hm. has anyone given the fasta shootout benchmark a serious try? there are several rather obvious optimizations possible
13:20:02 <fabiand> if got a ... quite daily task: implement dijrkstras permutation algorithm ... but seems to be quite hard for me :)
13:20:08 <mahogny> even without wrecking readability too much...
13:20:52 <mahogny> for example, why does fasta not use cumulative probabilities? floating point subtraction is evil :/
13:21:29 <fabiand> curently i trz to implement a funktion which gives me the last a_i where a_i < a_{i+1} .(in a_0 .... a_n).. has someone got an idea how to achievbe this?
13:21:30 <dmhouse> What should the perfect article on the Curry-Howard isomorphism contain by way of content?
13:21:43 <mahogny> what it is for a starter
13:21:59 <pejo> And implications from its existence.
13:22:10 <mahogny> and how it is useful in practice
13:22:20 <glguy> ?pl (liftM . liftM . liftM $ setHeader "Cache-Control" "no-cache") $ m a b -- interested in what the rewriter does
13:22:21 <lambdabot> fmap (fmap (fmap (setHeader "Cache-Control" "no-cache"))) (m a b)
13:22:28 <int-e> mahogny: "NOT ACCEPTED: Preconverting to Int is a really interesting approach - we're looking for the vanilla approach."
13:22:49 <dmhouse> pejo: such as?
13:22:50 <int-e> mahogny: says the comment to http://shootout.alioth.debian.org/debian/benchmark.php?test=fasta&lang=ghc&id=3
13:22:52 <lambdabot> Title: fasta Haskell GHC #3 program | Debian : AMD&#8482; Sempron&#8482; Computer Langu ..., http://tinyurl.com/2936yr
13:22:59 <mahogny> hmm
13:23:36 <pejo> dmhouse, this is really not my area. But implications from its existence and how it is useful in practice partly cover the same thing.
13:23:45 <mahogny> int-e, :(
13:23:55 <sjanssen> mahogny: see the Haskell wiki for my attempt at fasta
13:24:02 <mahogny> int-e, that *is* the vanilla approach *premature optimizer from hell* :)
13:24:18 <sjanssen> mahogny: http://www.haskell.org/haskellwiki/Shootout/Fasta#Proposed_entry
13:24:20 <lambdabot> Title: Shootout/Fasta - HaskellWiki
13:24:50 <mahogny> sjanssen, 3.5x the C version. thanks. you saved my day :)
13:24:58 <pbx> I have a n00b question that probably betrays a missed concept somewhere. I've been reading YAHT, Gentle Intro, etc. and feel like I have a pretty good handle on syntax now. My question has two parts. The first is pronunciation-related. How do you say the "(Num a) =>" part of this?
13:24:59 <sjanssen> it has been waiting for inclusion for quite a while, perhaps we need to ping the shootout people
13:25:04 <pbx> > :t (+)
13:25:05 <lambdabot>  Parse error
13:25:10 <pbx> hrm
13:25:23 <pbx> What I meant was : (+) :: (Num a) => a -> a -> a
13:25:39 <bd_> hmm
13:25:48 <bd_> 'implies' maybe?
13:26:03 <dmhouse> I read 'implies'.
13:26:16 <mauke> :t (+)
13:26:18 <lambdabot> forall a. (Num a) => a -> a -> a
13:26:26 <sjanssen> @tell dons you submitted the updated fasta in November.  Do we need to ping the shootout people?
13:26:27 <lambdabot> Consider it noted.
13:26:40 <Saizan> forall a such that Num a, then a -> a -> a
13:26:54 <dmhouse> '(+) :: Num a => a -> a -> a' really means that (+) is a function that will take any two values of type a, where a is a type that is an instance of Num, and return another value of type a.
13:26:55 <pbx> Where "->" is pronounced "to"?
13:26:59 <mahogny> sjanssen, yeah. would be good. hard to advocate for haskell with that 250x monster in there :)
13:27:19 <mahogny> or 472 to be precise :(
13:27:23 <dmhouse> But I tend to read it 'plus has type num a to a to a'
13:27:33 <dmhouse> Err, s/num/num a implies/
13:27:44 <dmhouse> So 'plus has type num a implies a to a to a'.
13:27:49 <pbx> dmhouse: I like that, thanks.
13:28:40 <mahogny> hm. implies sounds evil. there is another type if the implication is false? :/
13:29:03 <mauke> no, there is no type
13:29:17 <chessguy_work> if a is not of type Num a, then the function can't be used for it
13:30:04 <pbx> So my second, more naive question is, my brain desperately wants to say that (+) takes two arguments and returns one.  I do understand partial application enough to grasp that "(+) 3" has type Integer -> Integer, but I still have a hard time explaining exactly why there is no indication in the type signature of what a "full complement" of arguments is.  What kind of object to I need to strike my head with here?
13:30:32 <dmhouse> To be precise, if b is a type that doesn't instantiate Num then trying to unify b with the a in the input type for (+) is a type mismatch.
13:30:34 <bd_> There is no 'full complement' concept in the type - ((+) 3) is a perfectly valid function call.
13:30:40 <chessguy_work> pbx, it's just assumed that the last argument is the result. everything else is the parameters
13:30:40 <sjanssen> pbx: there is no such thing as a "full complement"
13:30:58 <bd_> [GHC internally has an idea of a canonical form, which may or may not match what you think it might be, so don't bother trying to keep track of it :)]
13:31:02 * chessguy_work hands pbx a pillow
13:31:09 <mauke> pbx: in foo :: X -> Y, Y can be a function type
13:31:09 <pbx> sjanssen, dmhouse: would you agree with chessguy_work's characterization?
13:31:13 <dmhouse> pbx: in Haskell you'll find that the concepts of 'function' and 'value' are pretty much totally interchangeable.
13:31:23 <pbx> dmh Good point.
13:31:25 <sjanssen> pbx: generally that is correct
13:31:51 <mauke> > (flip id) 2 sqrt
13:31:52 <lambdabot>  1.4142135623730951
13:31:55 <chessguy_work> it's a slight simplification, i guess, but it's a good starting point
13:32:07 <sjanssen> pbx: if a type matches "a -> b", then you can apply one more argument to it, if it doesn't then you can't apply any more arguments
13:32:17 <pbx> Thanks much.  Unfortunately I have to run. I'll be back after more reading...
13:32:30 <chessguy_work> heh
13:32:42 <dmhouse> If 'f x' appears in your code somewhere, then the compiler infers that f must have type "a -> b" for some a and b. If f actually has type Int -> Int -> Int, say, then that's the same as Int -> (Int -> Int), so a = Int, b = Int -> Int.
13:32:45 <dons> ?yow
13:32:46 <lambdabot> Did you move a lot of KOREAN STEAK KNIVES this trip, Dingy?
13:32:48 <dmhouse> Gah.
13:32:53 <glguy> ?yarr
13:32:54 <lambdabot> I want me grog!
13:33:07 <dmhouse> ?tell pbx I said this just as you left: If 'f x' appears in your code somewhere, then the compiler infers that f must have type "a -> b" for some a and b. If f actually has type Int -> Int -> Int, say, then that's the same as Int -> (Int -> Int), so a = Int, b = Int -> Int.
13:33:08 <lambdabot> Consider it noted.
13:33:27 <sjanssen> imperative programming is harddd
13:35:01 <dons> hehe
13:35:02 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:35:09 <emu> @info MArray
13:35:10 <lambdabot> MArray
13:35:48 <dmhouse> Who's the editor of the Monad.Reader?
13:35:57 * dmhouse wants to know when the due date is
13:36:10 <sjanssen> aha, fixed it!
13:37:09 <hpaste>  sjanssen pasted "MArray quicksort" at http://hpaste.org/99
13:37:36 <Procyon> That's cheating
13:37:58 <hpaste>  glguy annotated "MArray quicksort" with "my old version" at http://hpaste.org/99#1
13:38:20 <SamB> Procyon: cheating?
13:38:22 <SamB> what is that?
13:41:49 <hpaste>  sjanssen annotated "MArray quicksort" with "unsafeRead it up" at http://hpaste.org/99#2
13:43:43 * sjanssen wonders whether he can cast a ByteArray# into a ForeignPtr Word8
13:45:10 <dons> yeah, almost
13:45:22 <dons> don't I do that in the wacky Integer instance in Binary?
13:45:56 <dons>         (fp, off, n@(I# sz)) <- liftM toForeignPtr get      -- so decode a ByteString
13:45:59 <dons>         assert (off == 0) $ return $ unsafePerformIO $ do
13:46:01 <dons>             (MBA arr) <- newByteArray sz                    -- and copy it into a ByteArray#
13:46:05 <dons>             let to = byteArrayContents# (unsafeCoerce# arr) -- urk, is this safe?
13:46:07 <dons>             withForeignPtr fp $ \from -> memcpy (Ptr to) from (fromIntegral n)
13:46:10 <dons>             freezeByteArray arr
13:46:14 <dons> so the evil think I don't know is if byteArrayContents# (unsafeCoerce# arr)
13:46:18 <dons> gives you a safe Addr#
13:46:33 <bringert> is anyone looking for a place do a CS master's degree?
13:46:35 <bringert> see http://www.chalmers.se/cse/EN/education/masters-programmes/computer-science
13:46:38 <lambdabot> Title: CSE: Computer Science, http://tinyurl.com/yw58v3
13:46:46 <bringert> tuition is free to everyone
13:46:55 <bringert> haskell for everyone!
13:47:14 <bringert> see code on the right-hand side of that page
13:47:45 <glguy> would you need to know languages other than English ? :)
13:48:55 <mahogny> bringert, shameless self-plug? :)
13:49:17 <bringert> mahogny: I work at Chalmers, yeah.
13:49:35 <mahogny> bringert, yeah, I know :)
13:49:45 <pejo> Shrug, this is the place to post such ads, I'd say. :-)
13:49:48 <bringert> glguy: no, English is enough
13:50:42 <chessguy_work> if i do a masters degree somewhere, they'll know how to spell 'program'
13:51:02 <bringert> chessguy_work: huh?
13:51:13 <chessguy_work> not 'programme'
13:51:30 <bringert> official chalmers stuff uses british english by policy
13:51:32 <sjanssen> bringert: gotta be a good program(me), judging from the Haskell screenshot to the right :)
13:51:32 <mahogny> bringert, nice article btw. read up on your xmlrpc. did you get that recursive class hack from somewhere?
13:51:53 <bringert> mahogny: no
13:51:54 <chessguy_work> bringert, it was a joke
13:51:56 <pejo> chessguy, so you'll only do a masters at places who refuse to use british english?
13:51:57 <mahogny> sjanssen, it is :)
13:51:57 <bringert> from nowhere
13:52:08 <hpaste>  emu annotated "Quick Sort on array" with "randomized pivot" at http://hpaste.org/98#1
13:52:18 <bringert> sjanssen: heh, yeah, I wrote that code
13:52:54 <bringert> our PR person asked for some pretty code
13:53:10 <bringert> so I took a screenshot of whatever I had open
13:53:26 <bringert> you'll all recognize the emacs haskell-mode colors
13:53:27 * SamB wonders how he can use hugs to test Happy/Alex output...
13:54:22 <mauke> wtf, is that comic sans?
13:54:34 <xerox> mauke: monaco
13:54:58 <moconnor> For the State Monad is there a puts equivalent of gets?  So I say "puts foo 5" and that's the same as: get >>= \x -> put x {foo=5}.
13:55:00 <emu> is there a better way to do randomized pivot?
13:55:09 <Procyon> Chalmers saying that there program is the result of applying the "Balogna Process" has a much different connotation in American English ;)
13:55:11 <emu> maybe without using the IO monad
13:55:12 <xerox> ?type modify
13:55:13 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
13:55:14 <bringert> chessguy_work: I've run into to too many americans who don't understand that there are other countries in the world. I'm sorry that I mistook you for one of them.
13:55:18 <xerox> moconnor: -^
13:56:05 <bringert> mahogny: are you a chalmers student?
13:56:09 <mahogny> bringert, I was
13:56:13 <emu> i guess i could use unsafeSTtoIO
13:56:18 <chessguy_work> bringert, no problem
13:56:23 <moconnor> xerox: thank you
13:56:29 <mahogny> bringert, moved to stockholm to do my phd about half a year ago
13:56:32 <bringert> mahogny: have we met?
13:56:38 <mahogny> bringert, we might have
13:56:44 <mahogny> never spoken though
13:57:35 <pejo> mahogny, does KTH have any fp activity except Faxn?
13:57:51 <bringert> mahogny: what are you working on?
13:57:58 <mahogny> pejo, know little about what kth has but their set of courses suck compared to what chalmers has to offer
13:58:12 <mahogny> bringert, spatial protein expression in c.elegans
13:58:30 <bringert> bioinformatics?
13:58:50 <mahogny> ah, we might call it that. this is a new field so there isn't really a label on it
13:59:10 <mahogny> might sort under systems biology
13:59:11 <xerox> moconnor: you're welcome
14:00:53 <LoganCapaldo> @hoggle [Maybe a] -> Maybe [a]
14:00:55 <lambdabot> No matches, try a more general search
14:01:03 <nornagon> LoganCapaldo: sequence
14:01:08 <nornagon> :t sequence
14:01:10 <LoganCapaldo> @hoggle (Monad m) => [m a] -> m [a]
14:01:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:01:11 <lambdabot> Prelude.head :: [a] -> a
14:01:12 <lambdabot> Prelude.last :: [a] -> a
14:01:12 <dmhouse> ?hoogle catMaybes
14:01:13 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
14:01:16 <nornagon> er, hm.
14:01:17 <nornagon> not quite
14:01:58 <dmhouse> Anyone got a link to the PDF on Curry-Howard and classical logic dpiponi posted in here a week or so ago?
14:02:04 <LoganCapaldo> @type Just . catMaybes
14:02:06 <lambdabot> forall a. [Maybe a] -> Maybe [a]
14:02:09 <LoganCapaldo> Hmm
14:02:45 <LoganCapaldo> But I want [] to be Nothing and not Just []
14:02:49 <nornagon> :t sequence [Just 1, Just 2]
14:02:51 <lambdabot> forall a. (Num a) => Maybe [a]
14:02:57 <nornagon> > sequence [Just 1, Just 2]
14:02:59 <lambdabot>  Just [1,2]
14:03:05 <nornagon> > sequence [Just 1, Just 2, Nothing, Just 3]
14:03:07 <lambdabot>  Nothing
14:03:14 <LoganCapaldo> Almost :)
14:03:28 <nornagon> you want to get rid of all the Nothings?
14:03:32 <mauke> LoganCapaldo: what do you want it to do?
14:03:35 <LoganCapaldo> f [Just 1, Just 2, Nothing, Just 3] = Just [1,2,3]
14:03:41 <dmhouse> > catMaybes [Just 1, Just 2, Nothing, Just 3]
14:03:43 <lambdabot>  [1,2,3]
14:03:48 <dmhouse> LoganCapaldo: no point having the Maybe tag then.
14:03:52 <LoganCapaldo> f [Nothing, Nothing, Nothing] -> Nothing
14:03:59 <dmhouse> Oh, weird.
14:04:32 <LoganCapaldo> i mean i guess I can use filter and all that jazz
14:04:34 <mauke> LoganCapaldo: if null x then Nothing else Just x
14:04:34 <dmhouse> > let l2m [] = Nothing; l2m xs = Just xs in l2m $ catMaybes [Just 1, Just 2, Just 3, Nothing, Just 4]
14:04:36 <lambdabot>  Just [1,2,3,4]
14:04:40 <nornagon> LoganCapaldo: f []?
14:04:46 <dmhouse> > let l2m [] = Nothing; l2m xs = Just xs in l2m $ catMaybes [Nothing, Nothing]
14:04:47 <lambdabot>  Add a type signature
14:04:54 <dmhouse> > let l2m [] = Nothing; l2m xs = Just xs in l2m $ catMaybes [Nothing, Nothing :: Maybe Int]
14:04:56 <lambdabot>  Nothing
14:05:19 <LoganCapaldo> nornagon, in reality it should probably be called f1, I know its not an empty list
14:05:57 <glguy> > let example x = (guard . not . null $ x) >> return x in (example [], example [1,2,3])
14:05:58 <lambdabot>   add an instance declaration for (Show (m [a1]), Show (m1 [a]))
14:06:17 <glguy> > let example x = (guard . not . null $ x) >> return x in (example [], example [1,2,3]) :: (Maybe [Int], Maybe [Int])
14:06:18 <bringert> dmhouse: have you checked the logs?
14:06:18 <lambdabot>  (Nothing,Just [1,2,3])
14:06:35 <LoganCapaldo> glguy, you so crazy!
14:06:45 <glguy> ?
14:07:06 <dmhouse> bringert: I'm trying.
14:07:12 <LoganCapaldo> glguy, were you trying to help me?
14:07:16 <LoganCapaldo> *where
14:07:20 <LoganCapaldo> no wait
14:07:24 <glguy> > let example x = liftM2 (>>) (guard . not . null) return in example [1,2,3] :: Maybe [Int] -- sure :)
14:07:25 <LoganCapaldo> that was an anti correction
14:07:25 <lambdabot>      Expecting a function type, but found `Maybe [Int]'
14:07:25 <lambdabot>       Expected type: ...
14:07:39 <glguy> > let example = liftM2 (>>) (guard . not . null) return in example [1,2,3] :: Maybe [Int]
14:07:41 <lambdabot>  Just [1,2,3]
14:07:44 <LoganCapaldo> example [Just 1, Just 2, Nothing, Just 3] :)
14:07:46 <glguy> I'm just playing around
14:07:50 <glguy> ah
14:08:05 <glguy> LoganCapaldo: example . catMaybes
14:08:24 <LoganCapaldo> yeah
14:08:27 <LoganCapaldo> that outta do it
14:08:50 <pzpz> hey -- anyway to force happy into giving more usable error messages other than : "parE" ?
14:09:05 <LoganCapaldo> > let example x = liftM2 (>>) (guard . not . null) return in example [Nothing,Nothing,Nothing] :: Maybe [Int]
14:09:06 <lambdabot>      Expecting a function type, but found `Maybe [Int]'
14:09:07 <lambdabot>       Expected type: ...
14:09:10 <LoganCapaldo> oops
14:09:21 <LoganCapaldo> > let example x = liftM2 (>>) (guard . not . null) return in example $ catMaybes [Nothing,Nothing,Nothing] :: Maybe [Int]
14:09:22 <lambdabot>  Couldn't match `Maybe [Int]' against `[a] -> m [a]'
14:09:34 <LoganCapaldo> > let example x = liftM2 (>>) (guard . not . null) return in (example $ catMaybes [Nothing,Nothing,Nothing]) :: Maybe [Int]
14:09:35 <lambdabot>  Couldn't match `Maybe [Int]' against `[a] -> m [a]'
14:10:01 <LoganCapaldo> > let example x = liftM2 (>>) (guard . not . null) return in (example $ catMaybes [Nothing,Nothing,Nothing])
14:10:03 <lambdabot>  Add a type signature
14:11:00 <glguy> > catMaybes [Nothing :: Maybe (), Nothing, Nothing]
14:11:01 <lambdabot>  []
14:11:24 <glguy> > catMaybes [Nothing, Nothing, Nothing] :: [()]
14:11:25 <lambdabot>  []
14:12:31 <glguy> > filterM id [Just True, Just False, Nothing]
14:12:32 <lambdabot>  Nothing
14:12:36 <glguy> > filterM id [Just True, Just False]
14:12:38 <lambdabot>  Just [Just True]
14:12:40 <xerox> hah
14:13:07 <Saizan> ^type filterM
14:13:11 <Saizan> ?type filterM
14:13:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:13:50 <glguy> > filterM (not . null) [Just [1,2,3], Just [4,5,6]]
14:13:51 <lambdabot>  Couldn't match `m Bool' against `Bool'
14:13:57 <basti_> > 156 * .95
14:13:58 <lambdabot>  Parse error
14:14:01 <basti_> > 156 * 0.95
14:14:02 <lambdabot>  148.2
14:14:05 <glguy> oops
14:14:09 <glguy> fmap (not . null)
14:14:17 <basti_> > 153 * 0.95
14:14:18 <lambdabot>  145.35
14:14:54 <Saizan> > filterM (fmap id) [Just True, Just False]
14:14:58 <lambdabot>  Just [Just True]
14:15:21 <pzpz> anyone a little experienced with happy?
14:15:38 <hpaste> pick me
14:16:21 <hpaste> @yow
14:16:22 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
14:19:24 <hpaste> Haskell paste bin: http://hpaste.org/
14:19:38 <emu> mm, sorting a list [1..n] offers a good example of the difference between naive pivot selection and randomized selection =)
14:20:59 <Saizan> what's better betwenn randomized and medium among three?
14:21:26 <emu> medium?
14:21:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/101
14:21:32 <emu> just the n/2 element?
14:22:26 <glguy> who pasted that?
14:22:59 <twanvl> emu: median of three = sort [a!0, a!(n/2), a!n] !! 1
14:23:11 <emu> he didn't say median
14:23:28 <Saizan> err sorry, wrong term
14:23:46 <emu> finding the median takes theta(n)
14:24:04 <Saizan> but n here is 3
14:24:50 <Saizan> however there's a Knuth analisys that show it gives a +5%
14:24:59 <Cale> If you're sorting a list, looking for the last element is going to take Theta(n) time.
14:25:15 <sjanssen> Cale: we're sorting arrays
14:25:36 <emu> sorting 10000 elements using left-most as pivot took this thing 1 minute, vs randomized pivot at 0.6sec... yikes
14:26:03 <hpaste>  glguy annotated "(no title)" with "Letting Maybe do its job" at http://hpaste.org/101#1
14:26:31 <sjanssen> emu: that is expected behavior
14:27:13 <emu> i'm using unsafePerformIO to get random numbers
14:27:43 <pzpz> anyone deal with understanding happy error messages?
14:27:46 <Saizan> 10000 sorted elements?
14:27:54 <emu> yea, [1..10000]
14:28:00 <emu> worst case
14:28:07 <sjanssen> emu: how do the algorithms compare with random input?
14:28:11 <hpaste>  glguy annotated "(no title)" with "with do notation" at http://hpaste.org/101#2
14:28:14 <emu> pretty similar
14:29:10 <sjanssen> using unsafePerformIO breaks referential transparency here
14:29:35 <hpaste>  emu pasted "what i'm using now" at http://hpaste.org/102
14:29:47 <emu> er, i thought i was annotating
14:29:52 <emu> anyhow
14:30:09 <dons> :t randoms
14:30:12 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
14:30:20 <glguy> it should probably be more clear that you are annotating
14:30:24 <dons> > randoms (mkStdGen 42) :: [Word32]
14:30:25 <lambdabot>   add an instance declaration for (Random Word32)
14:30:25 <lambdabot>     In the expression: rand...
14:30:35 <glguy> new annotation for : TITLE
14:30:36 <dons> > randoms (mkStdGen 42) :: [Integer]
14:30:38 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:30:45 <sjanssen> dons: ah yes, good idea
14:31:05 <emu> > randoms (mkStdGen 42) :: [Integer]
14:31:06 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
14:31:12 * glguy wonders what the bounds of a random Integer are
14:31:15 <dons> to change the seed feed it in from main
14:31:21 <emu> glguy: maxBound::Int
14:31:24 <sjanssen> emu: just use mkStdGen 42 -- the function will remain referentially transparent
14:31:42 <dons> > maximum $ take 100000 (randoms (mkStdGen 42) :: [Integer])
14:31:44 <lambdabot>  2147469347
14:31:51 <sjanssen> it'd still be technically possible to trigger O(n^2) behavior, but it'd be quite hard I think
14:32:02 <emu> there would be a possible input yes
14:32:07 <dons> > fromIntegral (maxBound :: Int) -  maximum $ take 1000000 (randoms (mkStdGen 42) :: [Integer])
14:32:08 <lambdabot>   add an instance declaration for (Num ([Integer] -> Integer))
14:32:20 <dons> > (fromIntegral (maxBound :: Int)) -  maximum $ take 1000000 (randoms (mkStdGen 42) :: [Integer])
14:32:21 <lambdabot>   add an instance declaration for (Num ([Integer] -> Integer))
14:32:27 <emu> potentially "exploitable" :P
14:32:34 <glguy> $ was too strong there :)
14:32:35 <dons> > (fromIntegral (maxBound :: Int)) -  maximum (take 1000000 (randoms (mkStdGen 42) :: [Integer]))
14:32:40 <lambdabot> Terminated
14:32:45 <emu> but is unsafePerformIO really unsafe there?
14:32:46 <dons> > (fromIntegral (maxBound :: Int)) -  maximum (take 100000 (randoms (mkStdGen 42) :: [Integer]))
14:32:48 <lambdabot>  14300
14:32:58 <dons> > (fromIntegral (maxBound :: Int)) -  maximum (take 500000 (randoms (mkStdGen 42) :: [Integer]))
14:33:02 <lambdabot>  3538
14:33:11 <dons> > (fromIntegral (maxBound :: Int)) -  maximum (take 750000 (randoms (mkStdGen 42) :: [Integer]))
14:33:14 <pzpz> whoowey, that's fast!
14:33:15 <lambdabot> Terminated
14:33:24 <emu> the result is going to be the same regardless of which random numbers are chosen
14:33:28 <glguy> too bad lambdabot doesn't allow admins to have more cpu time ;)
14:33:28 <dons> > (fromIntegral (maxBound :: Int)) -  maximum (take 612000 (randoms (mkStdGen 42) :: [Integer]))
14:33:32 <lambdabot> Terminated
14:33:34 <dons> heh
14:34:16 <pzpz> anyone know how to have happy give more useful error messages?
14:34:23 <sjanssen> emu: it is not referentially transparent when you have a naughty Ord instance
14:35:38 <chessguy> if dons makes me an admin, i'll submit a patch :)
14:35:39 * glguy eats a spoonful of honey
14:36:24 <chessguy> glguy, to make the sugar go down more easily?
14:37:02 <sjanssen> don't eat honey!  it ANGERS the BEES!
14:37:30 <chessguy> @quote honey
14:37:30 * glguy eats ANOTHER spoonful!
14:37:31 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:37:44 <chessguy> broccoli brains?
14:37:56 <chessguy> where does she come up with this stuff?
14:37:59 <glguy> do you take personal exception to that insult?
14:38:10 <mauke> @quote
14:38:11 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
14:38:18 <chessguy> Personal.Exception you mean?
14:38:21 <emu> i like broccoli
14:38:24 <chessguy> oh, this is not ##Java
14:38:31 <chessguy> @quote exception
14:38:32 <lambdabot> blackdog says: i think coding in your sleep should trigger an exception
14:39:06 <glguy> straw poll, do you prefer to raise, throw, or trigger your exceptions ;)
14:39:20 <emu> signal
14:39:35 <mauke> "die"
14:39:49 <emu> screw exceptions: total language
14:40:06 <velco> raise
14:40:16 <glguy> crash?
14:40:21 <JKnecht> cause
14:40:27 <glguy> :)
14:41:07 <chessguy> accept?
14:42:06 <dons> return Nothing
14:43:15 <Procyon> throw
14:45:43 <dons> callCC
14:46:59 <Procyon> hehe
14:47:44 <bd_> error "Something terrible happened! :("
14:48:31 <Procyon> *0=0;
14:48:54 <freakazoid> Better than "this should never happen"
14:49:00 <bd_> (unsafeCoerce# 0 :: (forall a. a -> a)) undefined
14:49:04 <Procyon> -- doesn't work on vax
14:50:38 <Procyon> __asm int 3;
14:50:48 <bd_> __asm hlt :)
14:51:19 <bd_> __asm { cti; hlt; } even
14:51:25 <bd_> cli*
14:54:20 <master_baiter> asm volatile ("lidt 0; int3");
14:57:11 <hpaste>  beschmi annotated "profiling a TCP Stack" with "(no title)" at http://hpaste.org/103#1
14:57:29 <Procyon> return (HRESULT)0; // sorry.  I had to go there
14:57:45 <beschmi> i'm wondering if StateT being too lazy could be a problem
14:59:39 <dons> ?remember joelr [share trading] Options twist my brain, just like Haskell, so I figure they are good for me.
14:59:40 <lambdabot> Done.
15:00:07 <dons> beschmi: possibly
15:00:39 <dons> i'm not sure what the best method is these days for ensuring a strict StateT
15:00:45 <bringert> kosmikus: I have an lhs2tex problem. I'm probably stupid, but why can't I %include a normal .lhs file?
15:00:58 <bringert> kosmikus: I get "Missing $ inserted."
15:01:58 <Cale> If you wanted to do that, you'd probably have to wrap it in a verbatim block.
15:02:05 * SamB wonders what he should do with his Self parser now that it seems capable of parsing at least one real .self file
15:02:18 <freakazoid> SamB: Take over the world!
15:02:21 <Cale> Or some such... I'm not sure how it'd work.
15:02:38 <beschmi> dons: i don't know either. i'll have a look at the monadLib and the discussion at haskell-cafe then
15:03:04 <freakazoid> That's what I did with my XML parser that allowed one to write specifications of XML-based formats using Python classes and properties
15:03:11 <SamB> okay, really I'm wondering how to turn an AST into code and objects
15:03:15 <dons> beschmi: yeah. good idea
15:03:32 <SamB> unsurprisingly, I'm also wondering how to represent objects...
15:03:38 <Cale> beschmi: I'd look more closely at those things. Add some scc's to the do-blocks for established and server and make sure it's not subexpressions before blaming the monad.
15:03:46 <freakazoid> SamB: This is all basic compiler design stuff
15:03:50 <dons> beschmi: how'd .de? I hear its turned quite cold since last week?
15:04:24 <beschmi> dons: we have snow here since tuesday
15:04:31 <freakazoid> We need to pump out more CO2 here in the US so Europe doesn't have to be so cold
15:04:46 <dons> nice! looks like we picked just the right moment for the hackathon to be warm enough, and not windy/snowy
15:04:55 <beschmi> dons: i'm happy since i'm going skiing in february
15:05:05 <dons> heh cool
15:05:25 <SamB> freakazoid: well, according to the Self reference manual, their parser actually parses object literals straight into objects...
15:05:56 <bringert> kosmikus: ah, it seems to be some problem in the .lhs
15:07:03 <freakazoid> SamB: Yeah, you can do that in a language like Self
15:07:14 <freakazoid> SamB: That's how LISPish languages work too
15:07:17 <SamB> *I* don't do that because the parsing is so messy...
15:07:30 <SamB> freakazoid: no, lispish languages parse to an AST
15:07:46 <freakazoid> not to lists?
15:07:51 <SamB> that *is* the AST
15:07:57 <freakazoid> oh I see what you're saying
15:08:02 <freakazoid> but their lists are their objects
15:08:46 <freakazoid> Python first parses to a concrete syntax tree, then to an AST
15:08:57 <freakazoid> parsing concrete is hard
15:09:11 <bringert> kosmikus: it seems like having {-# OPTIONS_GHC -fglasgow-exts #-} in my file causes lhs2tex to generate bad tex
15:09:13 <SamB> but, well, for example in scheme if I write (define x (+ 1 2)), it doesn't assign the list '(+ 1 2) to x...
15:09:44 <freakazoid> SamB: right, it evals it first, but that doesn't mean the internal representation isn't exactly what you see
15:09:53 <freakazoid> evaluation is a separate process
15:10:13 <Procyon> The internal rep *can* be the list form, but that's generally very inefficient.
15:10:30 <SamB> and if I write (define f (lambda (x) x)) it doesn't construct the identity function in the parser, either!
15:10:33 <TomMD> Is there a quality library that defines common network data types (all the way down to IP, ARP, Ethernet, not just HTTP etc)?
15:11:25 <SamB> According to Self's reference manual, Self *would* build something like an identity function in the parser if I wrote [|:x| x]
15:11:40 <SamB> or (|:x| x)
15:11:49 <freakazoid> their functions are just objects
15:12:09 <freakazoid> but I don't really see there being a huge difference there
15:12:14 <SamB> yes, but scheme's objects are functions, so...
15:12:24 <SamB> anyway...
15:12:30 <freakazoid> Self creates an activation record by cloning the function's object
15:12:44 <SamB> yeah, I know...
15:12:53 <freakazoid> that's not hugely different than how scheme does it
15:13:45 <SamB> another thing I'm wondering about is how to deal with the parents of primitive objects...
15:14:29 <freakazoid> are you compiling to Haskell code or some sort of bytecode representation or what?
15:14:39 <SamB> oh, that was the other thing
15:14:50 <SamB> I don't know.
15:14:52 <freakazoid> ah
15:14:59 <SamB> see, this is why I was wondering what to do next ;-)
15:15:08 <freakazoid> guile executes by walking the AST and optimizing as it goes
15:15:23 <freakazoid> I suspect Self does something similar but compiles to specialized machine code as it goes
15:15:24 <beschmi> TomMD:  there is a network stack in House, you can use a TUN interface for talking to the House Stack
15:15:37 <SamB> actually Self uses bytecode...
15:15:53 <freakazoid> Bytecode is sort of a compressed AST representation anyway
15:16:07 <freakazoid> designed for fast walking
15:16:41 <SamB> yeah, that is pretty much how Self uses it normally
15:17:03 <freakazoid> order is significant in Self slots, isn't it?
15:17:09 <SamB> is it?
15:17:22 <freakazoid> I thought you had to fill the slots in order when calling a method
15:17:33 <freakazoid> or whatever they call objects with code (I forget)
15:17:37 <SamB> oh, argument slots sure
15:17:38 <freakazoid> I could, of course, be wrong
15:17:50 <kosmikus> bringert: I'm here now
15:17:50 <freakazoid> well, then it at least knows the order of the argument slots
15:17:57 <bringert> hi kosmikus
15:18:12 <bringert> kosmikus: is there a know problem with lhs2tex and haskell pragmas?
15:18:15 <bringert> known
15:18:25 <kosmikus> bringert: there's no good way to format them
15:18:33 <kosmikus> best is just not to do it ;)
15:18:42 <freakazoid> SamB: Self objects have a pointer to their prototype, right?
15:18:42 <SamB> at the moment I'd like a model that doesn't involve too much circularity
15:18:49 <bringert> :-)
15:18:51 <freakazoid> SamB: They're not lazy copies like they are in some other languages?
15:18:54 <SamB> freakazoid: not their prototype, no
15:18:58 <freakazoid> oh right
15:18:59 <bringert> but I want to %include a real .lhs file
15:19:00 <sorear> tell fodder
15:19:01 <freakazoid> It's coming back to me
15:19:04 <SamB> their parents, yes
15:19:11 <freakazoid> SamB: right, the traits objects
15:19:15 <TomMD> beschmi: a TUN interface?  As in Linux Tun/Tap
15:19:27 <kosmikus> bringert: seriously, my suggestion is to surround that line with %if style == newcode and %endif ... do you really need the pragma in your formatted document?
15:19:44 <freakazoid> SamB: So it seems like you probably want an object that contains slot descriptors, and then you can represent each object as an array of slots
15:19:46 <SamB> but, there are a few kinds of objects that don't. notably those numeric types that it can stuff into a word ;-)
15:19:53 <kosmikus> bringert: oh, you mean you can't change that file?
15:20:17 <SamB> also I'd like a model where I can build the initial world with minimal fuss...
15:20:20 <bringert> kosmikus: I can, but I want it to stay a normal .lhs
15:20:29 <beschmi> TomMD: yes, house runs on bare metal. but you can compile it in a testing mode as a linux process that uses a tun interface for network
15:20:40 <bringert> kosmikus: well, it's not that important, I can work around it no problem
15:20:44 <freakazoid> SamB: I am not sure that for initial implementation it's worth wasting time treating small ints specially
15:20:49 <kosmikus> bringert: define "normal"
15:20:52 <freakazoid> SamB: Python still doesn't do that
15:20:58 <SamB> freakazoid: well, I'll have to treat them at least a little specially
15:20:59 <TomMD> beschmi: Thanks, I'll yank the code from there if it suites.
15:21:24 <bringert> kosmikus: it just seems odd that lhs2tex generates code that latex chokes whenever there's a pragma
15:21:29 <SamB> freakazoid: actually Python does...
15:21:30 <freakazoid> SamB: you will definitely have primitive types, just always use pointers to them rather than trying to avoid the pointer dereference
15:21:42 <SamB> but it doesn't *tag* them
15:21:46 <kosmikus> bringert: no, it's not choking *whenever* there's a pragma
15:22:00 <kosmikus> bringert: %subst pragma a  = "{\rmfamily\enskip\{-\#" a " \#-\}\enskip}"
15:22:01 <freakazoid> SamB: I mean using odd pointers to represent small integers... did they start doing that when I wasn't looking?
15:22:02 <SamB> freakazoid: well, I was hoping to do this in Haskell..
15:22:13 <SamB> freakazoid: no they don't use strange pointers
15:22:20 <kosmikus> bringert: this is what it does. it tries to produce pragma-like brackets and formats the contents as text.
15:22:21 <freakazoid> SamB: that's what I'm talking about  :)
15:22:37 <freakazoid> SamB: I'm not saying you shouldn't have primitive types.. obviously you need those
15:22:48 <kosmikus> bringert: unfortunately, OPTIONS_GHC contains an underscore, which is invalid in text mode
15:22:56 <SamB> but the int objects are layed out differently from the long objects, and both are layed out differently from normal python objects...
15:22:56 <dcoutts__> @arr!
15:22:56 <lambdabot> Aye
15:23:10 <freakazoid> SamB: yes, that's true
15:23:20 <kosmikus> bringert: but you can play with the %subst pragma thing and redefine it prior to including your .lhs file
15:23:23 <freakazoid> SamB: The primitive types are different
15:23:31 <Procyon> If I am typing the simply typed lambda calculus, if I cheat and make the Y combinator a primitive with a defined type, (a->a)->a is there anything that's going to bite me later or can I get away scott free with this cheat?
15:23:48 <sorear> you can get away with it yes
15:23:50 <hpaste>  bringert pasted "lhs2tex stuff" at http://hpaste.org/104
15:24:00 <sorear> that's (basically) what Haskell does
15:24:02 <Procyon> Woohoo!  Thanks sorear
15:24:04 <freakazoid> SamB: I think your first step is probably to come up with a type for your Self objects
15:24:14 <SamB> freakazoid: yeah.
15:24:27 <kosmikus> bringert: is this the only pragma in the file?
15:24:32 <freakazoid> SamB: I am just learning Haskell.. I know how I'd do it in Mercury or Prolog
15:24:43 <dons> dcoutts__: see the discussion of bytestring in the final history of haskell paper?
15:24:43 <bringert> kosmikus: I'm not a tex wizard, so I'm not sure what the problem is
15:24:44 <freakazoid> SamB: (specifically turbo prolog which is typed)
15:24:56 <SamB> but won't I need to then also figure out how to represent code?
15:25:08 <dcoutts__> dons: I did!
15:25:09 <Procyon> sorear: so, I can do a fully expressive SKIY calculus without resorting to fixed point type inference basically.
15:25:14 <freakazoid> SamB: yes, that could be one of your primitive objects
15:25:16 <kosmikus> bringert: how *do* you want it to be formatted ?
15:25:31 <SamB> freakazoid: objects?
15:25:33 <bringert> kosmikus: you saw that code here, right: http://hpaste.org/104
15:25:37 <freakazoid> SamB: I should say types...
15:25:39 <dons> dcoutts__: now bytestring should really be in the timeline, and the bibliography, ah well :}
15:25:40 <dcoutts__> dons: a pretty nice description
15:25:50 <dcoutts__> :-)
15:26:02 <freakazoid> SamB: though it doesn't have to be a tagged type I guess
15:26:06 <bringert> kosmikus: I'm not sure actually, I guess I'll just remove it. I just thought I'd report it, in case it was a bug
15:26:16 <dons> yeah, almost like John Hughes was listening to a conversation at dinner :)
15:26:17 <bringert> kosmikus: sorry to bother you
15:26:26 <Procyon> sorear++
15:26:44 <freakazoid> SamB: in Mercury your type would be something like int(Int) ; string(String) ; float(Float)
15:26:52 <svref> Profiling time.  Unfortunately, the code depends on the HTTP library which wasn't built with -prof support.  I know that library isn't affecting performance.  Is there some easier way to proceed than learning how to compile HTTP package with profiling info?
15:27:08 <Excedrin> is this funny? "The first thing I do when looking at code is delete all the comments."
15:27:11 <SamB> you mean like data Value = Int Int | String String | Float Float ?
15:27:13 <dcoutts__> dons: btw, do you want to clearly identify the main loop translation problem so I can present it tomorrow? ;-) Actually, that's not the point of the day, it's to discuss lists of course, but I could bring it up over lunch and if there was a really clear example...
15:27:16 <kosmikus> bringert: no, I'm interested in options here, really.
15:27:17 <dons> svref: hmm. i don't think so
15:27:29 <kosmikus> I just don't know what the best way is to format pragmas.
15:27:32 <dons> dcoutts__: the main loop in binary?
15:27:37 <bringert> svref: it's not that hard, just give the profiling flag (whatever it is, can't remember) to cabal
15:27:39 <freakazoid> SamB: I have no idea how one would express it in Haskell. In Mercury that thing on the beginning is just a symbol
15:27:46 <bringert> kosmikus: hmm, good question.
15:27:48 <dons> yeah, i'll see if i can write it down.
15:27:50 <dcoutts__> dons: well, a simple byte reading or writing loop would be simpler
15:27:55 <dons> yep
15:28:05 <freakazoid> SamB: so it would be represented as a pointer into a symbol table that serves as the tag
15:28:08 <dcoutts__> dons: so show how the final stg code is perfect, but the cmm code is crap
15:28:15 <dons> yeah ok
15:28:20 <bringert> kosmikus: I guess the brackets need to look about the same, so that people know that they are pragmas
15:28:32 <dcoutts__> dons: I can send you the example I was looking at
15:28:44 <dons> ok. please do
15:28:52 <dons> i'll be releasing binary to the list in the next hour or two
15:28:56 <dcoutts__> dons: I spent a little while looking at it, but it's not that easy to follow even though it's only a page of cmm
15:29:03 <dons> ok
15:29:14 <dons> i don't find cmm too hard, but i wrote the cmm pretty printer ;)
15:29:28 <bringert> kosmikus: one slightly messy way could be to have information about the possible pragmas, and do something intelligent for each
15:29:43 <kosmikus> bringert: yeah
15:30:03 <SamB> you can darcs get my code from http://naesten.dyndns.org:8080/repos/hSelf2 if you want to look at it. The grammar is *not* pretty, though.
15:30:11 <bringert> e.g. OPTIONS_GHC -fglasgow-exts ==> Needs the GHC flags: -fglasgow-exts
15:30:11 <lambdabot> Title: Directory listing for /repos/hSelf2/
15:30:15 <freakazoid> SamB: I wouldn't be able to read it yet
15:30:16 <bringert> or something like that
15:30:51 <SamB> freakazoid: probably true, considering only one of those files is straight Haskell, and it implements a Monad ;-)
15:30:51 <kosmikus> bringert: so let me ask again: is this the only pragma in that file you're including?
15:30:56 <freakazoid> SamB: even though Self is a prototype-based language I think you'll still have a separate thing that's something like a class
15:31:11 <freakazoid> SamB: That thing being the slot descriptor
15:31:14 <SamB> freakazoid: you are assuming I am making some attempt at optimality
15:31:22 <bringert> kosmikus: yes
15:31:29 <SamB> I think I will not try to implement maps until I have something that works
15:31:51 <freakazoid> SamB: then you could just have a slot type that contains the slot descriptor and the contents of the slot
15:31:53 <bringert> kosmikus: this is essentially what I do: http://hpaste.org/104
15:32:13 <SamB> freakazoid: maps seem hard to do in Haskell...
15:32:19 <freakazoid> SamB: and an object could just be an array of those plus a code object, which could just be a special slot
15:32:25 * Procyon wonders if he writes the Y combinator as a C++ template and makes a compile time omega template instantiation if it would make Herb Sutter laugh or cry.
15:32:29 <bringert> kosmikus: except there's actually more code than foo =1
15:32:32 <freakazoid> I use maps all the time in Python
15:32:37 <SamB> anyway, I think I will use a naive implementation to start with...
15:32:39 <freakazoid> it would be a pain if it's hard to use them in Haskell
15:32:46 <SamB> freakazoid: not that kind of map
15:32:53 <freakazoid> oh
15:32:59 <freakazoid> I was thinking Python dicts
15:33:12 <SamB> those are easy in Haskell
15:33:15 <freakazoid> ah
15:33:18 <freakazoid> what do you mean then?
15:33:22 <hpaste>  bringert annotated "lhs2tex stuff" with "added latex error message" at http://hpaste.org/104#1
15:33:26 <sorear> SamB: Data.Map ?
15:33:43 <kosmikus> bringert: ok, then just try this ...
15:33:44 <SamB> the kind that describes the layout of a group of Self objects
15:33:52 <SamB> so that the objects don't have to
15:34:03 <freakazoid> Oh, I see
15:34:15 <freakazoid> Well, I wasn't suggesting putting any type information in the descriptor array
15:34:25 <SamB> but I dunno how to do that in Haskell...
15:34:27 <hpaste>  kosmikus annotated "lhs2tex stuff" with "(no title)" at http://hpaste.org/104#2
15:34:54 <SamB> oh, did you mean it should just list the slot names and offsets?
15:34:57 <sorear> glguy: ping?
15:35:03 <sorear> @localtime glguy
15:35:06 <SamB> possibly also tagging assignment slots specially?
15:35:08 <kosmikus> bringert: that's just hardcoding the formatting for this specific pragma, so it's an evil hack. but if it's the only pragma concerned, it should work
15:35:10 <freakazoid> yes
15:35:16 <sorear> @botsnack
15:35:16 <freakazoid> that's exactly what I mean
15:35:17 <lambdabot> :)
15:35:18 <kosmikus> bringert: you can also change the formatting to anything you like better
15:35:28 <freakazoid> though I think it would be more of just an array index than an offset
15:35:49 <bringert> kosmikus: hehe, nice hack
15:35:57 <dcoutts__> dons: http://haskell.org/~duncan/loop/
15:35:58 <lambdabot> Title: Index of /~duncan/loop
15:36:13 <dcoutts__> dons: source, stg, cmm, C and asm
15:36:16 <dons> cheers
15:36:25 <dons> i'll investigate
15:36:33 <dcoutts__> dons: but you can see the problem already in the stg -> cmm pahse
15:36:35 <sorear> dons: did you unrecord in hpaste?
15:36:48 <bringert> kosmikus: thanks for you help
15:36:58 <dons> sorear: hmm?
15:37:10 <kosmikus> bringert: you're welcome. does it really solve the problem for you?
15:37:11 <bringert> kosmikus: this is the first time I use lhs2tex. I'm pleasantly surprised.
15:37:24 <kosmikus> good to hear
15:37:37 <bringert> kosmikus: well, it solves the most immediate problem: getting the document to build
15:37:41 <sorear> We have the following new (to them) patches:
15:37:41 <sorear> Wed Jan 24 16:19:16 PST 2007  Don Stewart <dons@cse.unsw.edu.au> * Run FactorCSS (written in Haskell!) over the css file ,removes 200 lines of gunk
15:37:47 <dcoutts__> dons: and in the asm you can see that not only is it jumping between two functions rather than a single self-recursive function, but one of those jumps is indirect! ie a computed jump, load eax and jmp *(%eax)
15:38:04 <sorear> Why do I have new patches? I never recorded that!
15:38:10 <dons> dcoutts__: ah yes
15:38:13 <kosmikus> bringert: you'll probably find out that it doesn't produce really beautiful output on unedited Haskell source code
15:38:17 <sorear> Ergo, I assume you/glguy unrecorded it
15:38:18 <SamB> freakazoid: yeah, I meant array index
15:38:32 <bringert> kosmikus: I'll probably remove the pragma in the end, since now with lhs2tex the code looks so nice that I don't want any superfluous stuff in there
15:38:40 <dons> sorear: hmm, possibly glguy unrecorded a patch I applied?
15:38:49 <dons> sorear: glguy maintains the hpaste repo, not me
15:38:58 <freakazoid> SamB: Well, Python has reasonable performance just using dicts, so you might just start that way
15:39:10 <bringert> kosmikus: I haven't looked at it in detail yet, but I'll be ok with chaning the code to loks nice, as long as it's still ok haskell code
15:39:15 <SamB> freakazoid: yeah, I was thinking I would start that way too
15:39:19 <freakazoid> SamB: You could probably get away with ignoring ordering for the time being unless Self has something I can't remember where the name doesn't need to be used
15:39:21 <bringert> damn typos
15:39:28 <dcoutts__> dons: I was looking at the list comp desugarer in ghc on the train. It's got a 'standard' and a build/fold desugarer versions.
15:39:36 <freakazoid> SamB: Why Self, btw?
15:39:44 <sorear> dons: yeah, well glguy Isn't Here.
15:39:48 <dons> dcoutts__: ok. find anything useful out?
15:39:56 <dons> sorear: what can I do about it? i don't have commit access to his repo :)
15:40:09 <SamB> freakazoid: well. I'm not liking the fact that whenever I try to build Self, it doesn't work...
15:40:12 <hpaste>  kosmikus annotated "lhs2tex stuff" with "other way to deal with pragmas" at http://hpaste.org/104#3
15:40:20 <dcoutts__> dons: we'd need to modify it to produce, map, filter, concatMap etc
15:40:24 <freakazoid> SamB: So you're reimplementing it?
15:40:26 <dons> ah ok
15:40:26 <sorear> dons: I just thought he'd probably have told you.  I didn't expect anything more, sorry.
15:40:41 <dons> yeah ok. i noticed a conflict in the .css file too this morning
15:40:45 <dons> so maybe he did play some games
15:40:48 <kosmikus> bringert: ^^ that's the way I usually remove stuff I don't want to format; note that it's still a legal .lhs file. the pragma is seen by Haskell, just not by TeX ...
15:41:04 <SamB> freakazoid: Actually I've been trying to reimplement Self since before I started learning Haskell, off and on...
15:41:06 <bringert> kosmikus: why the style == newcode?
15:41:15 <dcoutts__> dons: the standard list comp desugaring produces directly recursive code, lots of letrecs etc.
15:41:19 <freakazoid> SamB: Do you have a particular project in mind with it?
15:41:35 <kosmikus> bringert: you can actually do "%if False" if you prefer
15:41:49 <SamB> well, if I could figure out how to write a Self implementation in Self that might be cool ;-)
15:42:01 <SamB> I'm not sure
15:42:01 <freakazoid> I thought Sun's implementation *was* written in Self?
15:42:10 <SamB> freakazoid: no, C++!
15:42:17 <SamB> see, that is part of the problem
15:42:19 <freakazoid> Oh
15:42:22 <freakazoid> perhaps I'm misremembering
15:42:39 <kosmikus> bringert: only that *sometimes*, you might actually want to have lhs2TeX apply formatting to the source code as well. then you can run lhs2TeX with --newcode as an option and let it format both .tex and .hs from a common source
15:42:46 <freakazoid> SamB: BTW, I know some people who will convince you that orthogonal persistence is the root of all evil
15:42:58 <bringert> kosmikus: ah, nice
15:43:10 <kosmikus> bringert: so you can use lhs2TeX as a preprocessor-like tool, to conditionally include parts of your code or expand macros in your source code.
15:43:13 * monochrom joins the "I build my own ghc" club. :)
15:43:21 <SamB> last I checked, their implementation needed to *access vtables* and tried to *peek at malloc()'s headers*
15:43:26 <freakazoid> I think the build finally completed on my computer!
15:43:44 <SamB> freakazoid: I don't think it is nearly that simple
15:43:44 <monochrom> oooohhhh it's popular to build one's own!
15:43:59 <freakazoid> well, I was just rebuilding the Debian package for Ubuntu
15:44:14 <freakazoid> Yup! ghc6_6.6-3_i386.deb
15:44:18 <SamB> for one thing, evil has existed much longer than orthogonal persistence ;-)
15:44:23 <sorear> I run HEAD and darcs pull daily.
15:44:54 <freakazoid> SamB: Well, I just know it was so painful to upgrade your MOO core that almost nobody did it
15:45:05 <SamB> you mean the core database?
15:45:06 <freakazoid> SamB: And when they did do it it took days of effort and broke lots of stuff
15:45:16 <freakazoid> SamB: The core objects
15:45:20 <SamB> yeah.
15:45:20 <freakazoid> SamB: Even if you hadn't modified them
15:45:26 <dcoutts__> did you know that you can use let expressions inside a list comprehension? I didn't.
15:45:26 <SamB> I've been wondering about how you could fix that!
15:45:27 * dcoutts__ is reading the H98 report to find out exactly how list desugaring works
15:45:43 <freakazoid> SamB: check out divmod axiom
15:45:47 <freakazoid> SamB: they have "upgraders"
15:45:48 <SamB> I think it probably involves taking plays from Smalltalk's book...
15:45:59 <freakazoid> Smalltalk doesn't even do it that well from what I hear
15:46:00 <dcoutts__> > [ y | x <- [1..5], let y = x + 1 ]
15:46:02 <lambdabot>  [2,3,4,5,6]
15:46:03 <SamB> true...
15:46:14 <dcoutts__> heh, I had no idea...
15:46:28 <SamB> but maybe we could take plays from their book of things they wish they had done?"
15:46:43 <freakazoid> SamB: Is there a list somewhere? I'd be interested to see it
15:46:49 <SamB> anyway, clearly it would be an improvement if methods were versioned
15:47:22 <SamB> actually, I think Squeak does somewhat okay with its projects...
15:47:23 * sorear afk "Read History-of-Haskell"
15:47:53 <monochrom> I have ghc-6.6-src.tar.bz2 and ghc-6.6-src-extralibs.tar.bz2.  I want to build both.  Should I unpack both before I ./configure and make?
15:48:14 <dcoutts__> monochrom: yes
15:48:17 <vincenz> sorear: nice pdf
15:48:19 <SamB> monochrom: question one: why do you have those?
15:48:47 <monochrom> Thanks.  I have those because I want to join the build-ghc club. :)
15:48:50 <freakazoid> anyone want my ubuntu packages?
15:49:02 <SamB> monochrom: who builds the release version?
15:49:05 <freakazoid> ghci
15:49:06 <freakazoid> err
15:49:07 <freakazoid> wrong window
15:49:10 <SamB> I mean, really!
15:49:10 <monochrom> Specifically I want ghci to link to readline5 rather than readline4.
15:49:15 <SamB> oh.
15:49:25 <SamB> anyway, I need to do the dishes
15:50:06 <monochrom> There is a long story behind why I don't use the rpms or the debs or the gentoo packages or ...  So I am left with either the generic binary tarball or the source.
15:50:25 <freakazoid> the long story being that you're allergic to binary packages?
15:50:44 <freakazoid> or that your system is so frankensteined that you're in dependency hell?
15:50:49 <monochrom> Also I want to benchmark my 2GHz, 1GB desktop computer XD
15:50:54 <freakazoid> I did that with Red Hat 4.0 a long time ago
15:51:15 <monochrom> I embrace binary packages if they're done right.
15:51:30 <freakazoid> My 3 GHz, 4 GB computer took like an hour
15:51:31 <monochrom> Some binary packages are not to my liking.
15:51:40 <monochrom> Whee, that's good news :)
15:51:42 <freakazoid> but it's a lowly pentium 4
15:53:26 <dons> ?remember JanisVoigtlaender Yes, seq is from the dark side
15:53:27 <lambdabot> Done.
15:54:46 <chessguy> ?src seq
15:54:46 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:55:13 <chessguy> how is it determined what functions work with the ?src command, and what don't?
15:55:19 <chessguy> @hoogle seq
15:55:20 <lambdabot> Prelude.seq :: a -> b -> b
15:55:21 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
15:55:21 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
15:55:25 <dons> you consult me :)
15:55:29 <dons> but seq isn't a function ;)
15:55:42 <dons> so it has no src
15:55:54 <chessguy> what is it then?
15:56:11 <dons> well, you can't define it in the language
15:56:17 <dons> so its a builtin
15:56:24 <dons> since it hooks into the evaluation mechanisms
15:56:28 <chessguy> hm
15:56:36 <chessguy> > seq 3 'a'
15:56:37 <lambdabot>  'a'
15:56:49 <dons> > const undefined 'a'
15:56:50 <lambdabot>  Add a type signature
15:57:03 <dons> > const (undefined :: ()) 'a'
15:57:04 <lambdabot>  Undefined
15:57:14 <dons> > const 'a' (undefined :: ())
15:57:15 <lambdabot>  'a'
15:57:25 <dons> > (flip seq) 'a' (undefined :: ())
15:57:26 <lambdabot>  Undefined
15:57:42 <chessguy> > seq 'a' (undefined :: ())
15:57:43 <lambdabot>  Undefined
15:58:18 <chessguy> i don't get it, what does it do?
15:58:40 <dons> it forces evaluation of its first argument, returning the second
15:58:50 <dons> i.e. strict evaluatoin to weak head normal form
15:59:48 <chessguy> what's the point of the second argument then?
16:00:26 <dons> f x = x + y
16:00:33 <dons> f x = x `seq ` x + y
16:00:51 <allbery_b> basically a hack to inline strictification in a pure expression where you can't do sequential actions, I think.
16:01:00 <chessguy> oh, so that it evaluates x before adding it to y
16:01:03 <dons> yeah
16:01:06 <dons> also:
16:01:11 <dons> f !x = x + y
16:01:18 <dons> in ghc 6.6 (preferred syntax i would argue)
16:01:39 <TomMD> More bang for you buck, you might say.
16:01:44 <dons> heh
16:01:52 <chessguy> is there an example where you would do foo `seq` foo, but maybe foo `seq` bar ?
16:02:31 <chessguy> s/ maybe// # to avoid misunderstandings
16:02:37 <dons> i sometimes have:   let x = .... in x `seq` x
16:02:44 <dons> well, usually x `seq` return x
16:02:47 <dons> which is just return $! x
16:03:00 <chessguy> evaluate x strictly and return it
16:03:36 <chessguy> ok, thanks. good to know
16:03:50 <chessguy> hopefully i'll stop getting seq confused with sequence now
16:03:55 <lisppaste2> pzpz pasted "unhappy me" at http://paste.lisp.org/display/35938
16:04:33 <chessguy> no wonder you're unhappy, you're using the wrong pastebin
16:04:40 <allbery_b> hey, who let thsat back in here? :)
16:05:03 <pzpz> hey, i'm trying to use Happy and I can't seem to define sequences of statements without it yelling at me with a "parE" error
16:05:08 <pzpz> which pastebin is used now? :)
16:05:12 <dons> ?paste
16:05:13 <lambdabot> http://hpaste.org (Haskell pastebin)
16:05:19 --- mode: ChanServ set +o dons
16:05:23 <pzpz> how sexy :)
16:05:36 --- mode: dons set +b *!*=lisppast@common-lisp.net
16:05:36 --- kick: lisppaste2 was kicked by dons (so long and thanks for all the pastes!)
16:05:43 --- mode: ChanServ set -o dons
16:05:53 <dons> it probably logged back in on reboot
16:06:07 <dcoutts__> pzpz: when I've seen that before it's because I'm using terminals I've not defined or something like that
16:06:37 <dcoutts__> pzpz: it's a bizarro error but it's due to some malformed thing in your module
16:08:31 <pzpz> dcoutts__: i've eyed it over one-too many times, still not sure what terminals I could be missing
16:08:49 <kpreid> dons: you know, you could ask for it to be removed...
16:09:08 <dcoutts__> pzpz: sorry I can't help more, I just remember that's how I fixed it last time
16:09:15 <dons> well, that too.
16:09:25 <kpreid> (but I'll just do it)
16:09:29 <dons> i'm sure the lisppasters don't mind
16:09:35 <kpreid> hmm?
16:09:53 <kpreid> it leaves lisppaste with a channel you can paste to but the pastes aren't announced in that channel
16:10:03 <dons> that's ok though
16:10:09 <pzpz> or you could have lambdabot guard the channel from uninvited pastebots
16:10:28 <kpreid> dons: could you explain further?
16:11:22 <dons> i see your point. it doesn't seem terribly serious
16:11:58 <kpreid> I admit to being overly fond of Doing Things Right
16:12:19 <kpreid> anyway, #haskell will now be gone from lisppaste's channel list next time it restarts
16:12:27 <dons> ok cool
16:13:05 <chessguy> ?remember lisppaste2 so long and thanks for all the pastes!
16:13:06 <lambdabot> Done.
16:21:14 <pzpz> dcoutts__: dcoutts__ : think it could have to do with the fact that it's parsing some [a] as opposed to a ?
16:21:35 <pzpz> how did I not see that, ha.
16:21:42 <dcoutts__> works now?
16:22:46 <Igloo> kosmikus: Some of the cabal functions had to have their interfaces changed so I could get the verbosity flags everywhere they need to be
16:23:00 <pzpz> naw, I was referring to using your name twice. I've added [$1] to one of the productions. I'm still not sure though what's wrong.
16:23:37 <Igloo> kosmikus: I'd suggest ignoring it for now as what you have will presumably work with the Cabal that comes with GHC/hugs
16:31:47 <pzpz> I think I figured it out :(
16:32:42 <pzpz> dcoutts__: you were correct. forgot to define the ';' terminal :(
16:33:21 <dcoutts__> pzpz: I looked at the haddock code to try and figure out why it gives that bizarro error, it's really tricky code
16:33:37 <dcoutts__> but you can try submitting a bug report
16:33:42 <dcoutts__> with a minimal test case
16:35:00 <astrolabe> What is an efficient way to save a Double to a file?
16:35:06 <pzpz> dcoutts__: yah. i'm not sure of the scope of the bug, but it definately occurs when using a token in the grammar that hasn't been defined
16:35:15 <allbery_b> ?where binary
16:35:16 <lambdabot> http://darcs.haskell.org/binary
16:35:40 <astrolabe> allbery_b: thanks
16:35:46 <dcoutts__> pzpz: yeah, that was my experience too. If you are feelng public spirited you'll submit a nice bug report :-)
16:36:21 <pzpz> what's the future of Haskell's binaryIO?
16:36:41 <pzpz> dcoutts__: perhaps after I finish my project and become a little more aware of Happy's workings :)
16:37:15 <SamB> pzpz: did you get the parE error?
16:37:22 <dcoutts__> pzpz: I find it's best to do it immediately, or I forget :-)
16:37:32 <SamB> I found out that happy does that with virtually any kind of error
16:37:37 <SamB> I have a patch for it too...
16:37:47 <dcoutts__> SamB: have you sent it in ?
16:37:56 <dcoutts__> pzpz: you don't need to know happy to realise that it's a blatent bug :-)
16:37:56 <pzpz> SamB: Ya
16:37:58 <SamB> no, for I haven't seen an error since
16:38:07 <dcoutts__> send it!
16:38:11 <SamB> I guess I could make one
16:38:28 <pzpz> dcoutts__: I wasn't sure if that was happy's only error message or not :)
16:38:58 <dcoutts__> pzpz: yeah, I dunno, it's certainly the least helpful
16:42:06 <SamB> pzpz: what should I call the patch?
16:42:15 <SamB> it turns:
16:42:19 <SamB> happy: parE
16:42:20 <SamB> into:
16:42:24 <SamB> happy: parE: unknown identifier `slotNamex'
16:42:42 <SamB> (for instance)
16:43:44 <pzpz> parEnlightening
16:48:05 <hpaste>  slowriot pasted "solveCases" at http://hpaste.org/105
16:48:17 <hpaste>  slowriot pasted "solveCases" at http://hpaste.org/106
16:48:51 <chessguy> ?hoogle trace
16:48:51 <lambdabot> Debug.Trace.trace :: String -> a -> a
16:48:52 <lambdabot> Debug.Trace :: module
16:48:52 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
16:48:58 <hpaste>  slowriot pasted "solveCases" at http://hpaste.org/107
16:49:18 <hpaste>  slowriot pasted "solve cases" at http://hpaste.org/108
16:49:26 <Botje> slowriot: PLEASE. STOP. REFRESHING.
16:49:30 <slowriot> sorry
16:49:42 <slowriot> my browser told me that it couldn't connect to the server
16:49:49 <Botje> oh, ohkay then.
16:49:55 <Excedrin> hahaha someone needs to fix that
16:49:57 <Botje> slap your browser ;)
16:50:00 <Excedrin> where's glguy?
16:50:17 <Botje> slowriot: what's the trouble with that?
16:50:44 <slowriot> on the line: main = do solveCases cases
16:50:57 <slowriot> the expected type for cases does not match the inferred type
16:52:39 <Dreadshoot> anyone here using hsplugins in win?
16:53:03 <dons> sjanssen: i've mailed isaac on the shootout about fast, sum-file and knuc bytestring entries that have been submitted
16:53:09 <dons> and need to be rerun since he added ghc 6.6.
16:53:24 <dcoutts__> :-) yay
16:53:34 <Botje> slowriot: cases has type IO [(String,String)]
16:53:37 <dons> slowriot: hmm, what was happening?
16:53:44 <dons> you appear to have created many new posts?
16:53:49 <dcoutts__> dons: and if we make loops better ...
16:53:50 <Botje> and map solveCases expects [(String,String)]
16:54:17 <Botje> slowriot: if you change the map into mapM it should work
16:54:18 <Botje> *tries*
16:54:30 <dons> slowriot: so basically hpaste should cksum your post, and if it is the same as another post, just ignore :)
16:54:33 <Botje> or not :[
16:55:01 <slowriot> mapM doesn't work?
16:55:05 <slowriot> I guess I could try it
16:55:14 <slowriot> nope
16:55:39 <freakazoid> what's the best haskell book?
16:56:11 <dons> the haskell98 report?
16:56:12 <slowriot> dons: it told me that it couldn't connect the server when I submitted, so I tried submitting a couple more time.
16:56:14 <chessguy> hmmm. does show x force evaluation of x?
16:56:18 <dons> slowriot: fair enough
16:56:21 <freakazoid> dons: as a reference?
16:56:32 <dons> freakazoid: check the textbook page of haskell.org
16:56:35 <freakazoid> ok
16:56:36 <dons> for the complete list of textbooks
16:56:43 <Botje> slowriot: main = do c <- cases <newline> solveCases cases
16:56:50 <Botje> works
16:56:54 * sorear back
16:56:59 <Botje> but then there's another type error in your cases function
16:57:02 <chessguy> hi sorear
16:57:24 <chessguy> !paste
16:57:25 <hpaste> Haskell paste bin: http://hpaste.org/
16:57:27 <sjanssen> chessguy: for most types, totally evaluating the result of show x is equivalent to totally evaluating x
16:57:51 <chessguy> sjanssen, is there any way to get it to *not* evaluate x?
16:57:56 <slowriot> Botje: thanks
16:58:19 <chessguy> e.g., show(3 +3)
16:58:23 <conal> has anyone here built gtk2hs with ghc-6.6?
16:58:23 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:58:27 <Botje> slowriot: what do you intend to do by "if cols == 0 " ?
16:58:27 <sjanssen> chessguy: how can you show something that isn't evaluated?
16:58:28 <chessguy> i want it to say "3 +3"
16:58:40 <dcoutts__> conal: grab the latest release candidate tarball
16:58:47 <chessguy> well, let me show you what i'm actually doing
16:58:58 <dcoutts__> conal: http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.tar.gz
16:59:07 <sjanssen> chessguy: you want to show arbitrary expressions?
16:59:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/109
16:59:12 <conal> dcoutts__: will do.  thanks.
16:59:33 <chessguy> so i used this simple code recently to do a tutorial on lazy evaluation
16:59:36 <slowriot> Botje: cols == 0 should always be in the input. It signals the end of the input.
16:59:50 <dcoutts__> conal: that version builds with ghc-6.6. The final 0.9.11 version will be released in a week or so.
16:59:54 <sorear> why is the channel so active so quckly?  I read one paper, 10 pages of scrollback
16:59:55 <Botje> slowriot: you probably want (read cols) == 0, then
17:00:00 <chessguy> the point is that the first function returns the fibonacci sequence
17:00:07 <chessguy> which is infinite
17:00:14 <slowriot> yeah, I thought readLn automatically read
17:00:15 <chessguy> but of course, it's lazily evaluated
17:00:27 <chessguy> here's where it gets hard though
17:00:32 <Botje> ehh
17:00:34 <Botje> so it does.
17:00:36 <Botje> nm me :)
17:00:43 <chessguy> i want to use Debug.Trace to step through what's being evaluated at each step
17:00:56 <sjanssen> chessguy: that sounds like a job for a debugger
17:01:20 <chessguy> but as soon as i do trace (show (magic...)), suddenly it forces evaluation
17:01:33 <chessguy> well, Debug.Trace is a debugger
17:01:41 <bd_> If you show something it's going to be forced
17:01:43 <Botje> slowriot: adding a type signature for cases solves the type errors
17:01:47 <Botje> for me, at least
17:01:59 <bd_> but eg trace "" e shouldn't alter evaluation order
17:02:06 <sjanssen> chessguy: trace doesn't know how to show suspended computations
17:02:12 <chessguy> so you're telling me there's no way to use debug.trace on this code?
17:02:27 <monochrom> I agree with bd_
17:02:44 <chessguy> i'm not sure what you mean, bd_
17:02:58 <chessguy> trace "" e --what's e here?
17:03:03 <bd_> chessguy: You could trace ((take 20 $ show $ magic ...) ++ "...")
17:03:13 <bd_> chessguy: some expression that'll be forced whenever the rest of trace is
17:03:57 <slowriot> Botje: okay, got it
17:04:27 <chessguy> trace (show (getIt (magic 1 1) 3)) -- like this?
17:04:48 <sjanssen> chessguy: something like that would work
17:04:49 <monochrom> Doesn't trace take two parameters?
17:05:06 <chessguy> oh, so trace (show (getIt (magic 1 1) 3)) ""
17:05:18 <jcreigh> :t trace
17:05:19 <sjanssen> chessguy: no
17:05:20 <lambdabot> Not in scope: `trace'
17:05:30 <chessguy> :t Debug.Trace.trace
17:05:32 <lambdabot> forall a. String -> a -> a
17:05:57 <jcreigh> trace is "trace _ x = x", except that it prints the "_"
17:06:13 <chessguy> so what's wrong with using "" for x?
17:06:30 <sjanssen> chessguy: technically, there's nothing wrong with it
17:06:50 <sjanssen> but trace foo "" is equivalent to the expression ""
17:07:03 <chessguy> i don't care, as long as it prints out the foo
17:07:31 <bd_> chessguy: If you don't want to force all of magic, take <n> $ show ...
17:07:37 <bd_> just like lambdabot does:
17:07:39 <bd_> > [1..]
17:07:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:07:46 <bd_> neat, huh?
17:08:01 <chessguy> bd_, yes, that's what getIt does
17:08:06 <chessguy> which is what i intend to show
17:08:11 <chessguy> (pardon the pun)
17:08:30 <bd_> oh, I see. Where are you inserting trace?
17:08:35 <chessguy> here's the tutorial, if you're interested
17:08:36 <chessguy> http://www.haskell.org/haskellwiki/Haskell/Lazy_Evaluation
17:08:37 <lambdabot> Title: Haskell/Lazy Evaluation - HaskellWiki
17:09:49 <sjanssen> chessguy: why do you introduce the function getIt?
17:10:09 <chessguy> meh, that's just how the question was originally asked
17:10:55 <sjanssen> chessguy: so you want to output immediate steps like your article does?
17:11:07 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/109#1
17:11:20 <chessguy> not such good results
17:11:24 <chessguy> sjanssen, yes
17:11:48 <sjanssen> chessguy: http://www.haskell.org/hat
17:11:50 <lambdabot> Title: Hat - the Haskell Tracer
17:11:55 <monochrom> Do you know the meaning of the two parameters of trace?
17:12:03 <chessguy> monochrom, not really
17:12:05 <SamB> dcoutts, pzpz: okay, I've sent the patch now... but since Simon hasn't even responded to my bug report yet, I dunno when he will get to the patch...
17:12:20 <dcoutts__> SamB: good work
17:12:24 <jcreigh> chessguy: it prints the first argument and returns the second.
17:12:57 <chessguy> you mean prints the result of evaluating the first?
17:13:09 <monochrom> When the expression (trace "x" y) is evaluated, "x" will be printed.  After that (trace "x" y) reduces to (y).
17:13:09 <jcreigh> chessguy: yeah
17:13:16 <SamB> pzpz: do you want one too?
17:13:39 <chessguy> ok
17:13:40 <hpaste>  bd_ annotated "(no title)" with "(no title)" at http://hpaste.org/109#2
17:13:45 <SamB> actually it looks like this
17:13:47 <SamB> ->              Failed e    -> case k (error "parE") of
17:13:47 <SamB> +>              Failed e    -> case k (error $
17:13:47 <SamB> +>                                      ("parE: " $
17:13:47 <SamB> +>                                       ++ concat (intersperse ", " e))) of
17:14:31 <monochrom> It goes without say that "x" is evaluated fully before y.
17:14:58 <monochrom> It is common but also naive to use (show y) for x.
17:15:06 <monochrom> err for "x".
17:15:52 <bd_> chessguy: in order to see more than one trace result, you must thread trace through the computation, as in my example :)
17:16:06 <monochrom> If you have (let y = repeat 0 in head y) it gives 0 immediately.
17:16:08 <chessguy> aha
17:16:21 <bd_> chessguy: oh, tiny bug there :)
17:16:29 <chessguy> bd_, ok, let me try it in getIt
17:16:30 <chessguy> oh?
17:16:36 <monochrom> If you now insert trace thusly, (let y = repeat 0 in trace (show y) (head y)), you are screwing it up.
17:17:28 <hpaste>  bd_ annotated "(no title)" with "trace the cons, not the list value :)" at http://hpaste.org/109#3
17:17:35 <jcreigh> monochrom: ah, thanks for the example. I didn't quite see what was wrong with "trace (show x) x" until you pointed out the infinite list case.
17:17:52 <chessguy> monochrom, yes, i did something like that first
17:17:56 <jcreigh> infinite anything, really. Doesn't have to be a list.
17:19:15 <sorear> tell fodder
17:19:28 <Botje> @pl \a b -> (sort $ show a) == (sort $ show b)
17:19:30 <lambdabot> (. (sort . show)) . (==) . sort . show
17:19:42 <Botje> urgh, no fancy monad?
17:19:45 <sorear> Botje: equating (sort . show)
17:19:59 <Botje> what module has that?
17:20:05 <sorear> it is a sad state that I am smarter than @pl
17:20:12 <dcoutts__> heh
17:20:13 <sorear> Botje: Data.Function, in GHC HEAD
17:20:24 <Botje> ah, I only have GHC 6.4 :/
17:20:38 <sorear> join (liftM2 (==)) (sort . show)  -- H98!
17:20:41 <dcoutts__> Botje: it's only a 1 line function, copy it
17:20:49 <sorear> > join (liftM2 (==)) (sort . show) "foo" "oof"
17:20:51 <lambdabot>  Couldn't match `t1 -> t' against `Bool'
17:20:51 <Botje> yeah, I just did, thanks :)
17:21:17 <chessguy> ok, let's see what happens here
17:21:20 * chessguy crosses fingers
17:21:24 <sorear> won't work, sorry
17:21:27 <sorear> glguy: hi!
17:21:38 <glguy> hi!
17:21:42 <sorear> glguy: did you unrecord the CSStidy patch?
17:21:50 <jcreigh> glguy: man, hpaste's diff tool sure is handy.
17:22:01 <glguy> sorear: kind of
17:22:07 <chessguy> ack!
17:22:07 <glguy> sorear: but then I tried to reapply it
17:22:09 <sorear> unpull? :)
17:22:13 <chessguy> "evaluating: magic 48391073557209099152743364306852414854578471458368540619402286682638152130914031943589898358362706179420945487150469881227150550339579743366638685191189077172920525389348288017550981860665513306642389385352511856885805922516046391400868573349439416746455327601900219040002996767266537366289032606373361058752162880597 782984017676606016116410801539408310160545698399718355535583913096306439121910891770601427490723
17:22:14 <chessguy> 77459825290193594610511858658284143225509840916974254193286373873659113061965226080791894302829177012541810515553074161003577354980460599126398782961772810386011209920320220882456318200508359853263051355517321814760324584"
17:22:20 <jcreigh> gah!
17:22:24 <chessguy> oops
17:22:25 <sorear> urk!
17:22:42 <glguy> sorear: did I break your repo?
17:22:43 <sorear> chessguy: what's that in binary
17:22:49 <sorear> glguy: yes, but I fixed it
17:22:59 <chessguy> sorear, i'll leave that as an exercise for the reader
17:23:05 <sorear> glguy: you broke dons' too
17:23:09 <glguy> sorry, didn't understand what unrecord did
17:23:15 <glguy> obviously
17:23:21 <sorear> no sweat
17:23:22 <chessguy> hmmm
17:23:37 <chessguy> well, it seems that adding the trace to getIt will be much harder
17:23:43 <glguy> sorear: I thought that the CSS change broke the HTML output of the main page
17:23:51 <jcreigh> chessguy: getIt is just !!, right?
17:23:52 <glguy> sorear: but it turns out that dons also edit the HTML code
17:23:57 <chessguy> jcreigh, yeah
17:24:00 <glguy> and *that* was the problem
17:24:07 <glguy> I thought that I could just ununrecord or something
17:24:08 <glguy> and revert
17:24:11 <glguy> but that blew up
17:24:18 <sorear> glguy: use rollback for public repos
17:24:20 <glguy> so I did a push from my local copy
17:24:22 <glguy> OH
17:24:23 <glguy> ok
17:24:38 <jcreigh> chessguy: hold a sec, let me try
17:24:45 <sorear> glguy: unrecord makes it so that other repos think they have new patches
17:24:53 <glguy> ew
17:25:03 * sorear thinks its explained somewhere in the darcs manual
17:25:04 <glguy> yeah, after that my local respository was broken
17:25:08 <glguy> so I blew it away
17:25:09 <chessguy> jcreigh, let me paste what i have
17:25:11 <glguy> and did a get
17:25:12 <SamB> so, like, do it only with patches that have not left yours
17:25:13 <chessguy> !paste
17:25:14 <hpaste> Haskell paste bin: http://hpaste.org/
17:25:19 <Procyon> What is the function f::a->[a]->Bool such that f x y returns true if x is contained in y?
17:25:24 * sorear thinks he is nearly alone in reading manuals for fun
17:25:30 <sorear> Procyon: nil
17:25:30 <bd_> :t elem
17:25:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:25:33 <sorear> Procyon: elem
17:25:35 <SamB> sorear: I used to do it
17:25:37 <Procyon> danke!
17:25:38 <bd_> :t nil
17:25:40 <lambdabot> Not in scope: `nil'
17:25:46 <hpaste>  chessguy annotated "(no title)" with "Don't try this at home" at http://hpaste.org/109#4
17:25:48 <SamB> but I think mostly with paper manuals...
17:25:57 <sorear> Procyon: you *need* the Eq context - there is no (useful) a -> [a] -> Bool
17:26:06 <chessguy> :t (_|_)
17:26:06 <Botje> @pl \x -> (show x) == (reverse $ show x) -- second chance, \bot
17:26:06 <bd_> Procyon: If you have Ord, and will be searching more than once, you may want Data.Set
17:26:07 <glguy> sorear: I generally do, but I picked up darcs mostly incidentally
17:26:07 <lambdabot> liftM2 (==) show (reverse . show)
17:26:08 <lambdabot> parse error on input `|'
17:26:11 <Botje> ah.
17:26:13 * Botje pets lambdabot 
17:26:14 <Cale> @hoogle a -> [a] -> Bool
17:26:15 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
17:26:16 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
17:26:24 * lambdabot purrs
17:26:27 <Procyon> ok
17:26:39 <shapr> yow!
17:26:52 <glguy> jcreigh: glad you liked the diff
17:26:57 <sorear> shapr: the punctuation comes first, like:
17:26:59 <sorear> ?yow
17:27:00 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
17:27:00 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
17:27:04 <sorear> (but you knew that)
17:27:21 <SamB> !yow
17:27:34 <SamB> sorear: it seems particular about the punctuation!
17:27:48 <shapr> sorear: @yow has had some influence on my life. Nowadays I say 'yow!' in real life to denote surprise, and sometimes dismay.
17:27:51 <sorear> SamB: !yow isn't supported yet
17:28:06 <shapr> mmm, code
17:28:10 <sorear> SamB: you use !id !quit !ctcp or !paste iirc
17:28:22 <chessguy> there must be an easier way to use Debug.Trace.trace without threading it through your code quite this intrusively
17:28:34 <bd_> chessguy: It wouldn't make sense otherwise :)
17:28:35 <bd_> ?. elite yow
17:28:36 <lambdabot> i 9ues5 you 9UyS 9o+ bi9 MU5C1ez fROM DOInG 70O MuCH sTudYiNg!
17:28:49 <dons> ?users
17:28:50 <lambdabot> Maximum users seen in #haskell: 322, currently: 281 (87.3%), active: 43 (15.3%)
17:28:53 <bd_> chessguy: trace s e = unsafePerformIO (putStrLn s >> return e)
17:29:01 <sorear> ?uptime
17:29:02 <lambdabot> uptime: 1d 4h 19m 25s, longest uptime: 2d 3h 42m 19s
17:29:09 <sorear> only 2d ?
17:30:05 <dons> nah
17:30:15 <dons> 12:26  lambdabot> uptime: 1d 16h 59m 37s, longest uptime: 2m 26d 6h 57m 25s
17:30:59 <dons> for those wondering what we got up to at the hackathon, here's a little demo of 'binary', http://www.haskell.org/pipermail/haskell-cafe/2007-January/021660.html
17:31:01 <lambdabot> Title: [Haskell-cafe] Pure serialisation and compression [Was: No Derived Read for Unbo ..., http://tinyurl.com/3dsznr
17:31:19 <hpaste>  jcreigh annotated "(no title)" with "my attempt at tracing" at http://hpaste.org/109#5
17:32:30 <glguy> sorear, dons: is lambdabot's irc protocol parsing modular?
17:32:42 <jcreigh> chessguy: you were trying to (show xs), which was probably hanging, right?
17:32:49 <sorear> glguy: not at all
17:33:03 <glguy> sorear: OK :)
17:33:11 <sorear> glguy: (at least dons-lambdabot)
17:33:21 <dons> glguy: did you see this: http://hpaste.org/
17:33:26 <glguy> just making sure I wasn't going to be duplicating too much effort when I make a couple simple parsers
17:33:26 <sorear> glguy: lb-sorear-take1 had modular irc
17:33:35 <dons> (the slownot dupes)we need to check for equivalence with previous posts
17:33:39 <chessguy> jcreigh, yes, probably so
17:33:39 <dons> and redirect to them
17:33:39 <sorear> glguy: lb-sorear-take1 is terminally broken
17:33:51 <chessguy> well, printing infinite output anyway
17:34:12 <jcreigh> chessguy: yeah, it takes a long time to print an infinite list. :)
17:34:19 <sorear> does anyone want a copy of lb-sorear-take1, the broken bot that I started over on ?
17:34:50 <sorear> (it has a few large changes when I tried to refactor everything at once - like a non-IRC common internal protocol)
17:34:59 * sorear has learned not to do that
17:35:17 <dons> heh
17:35:21 <dons> yay for experience
17:35:46 <chessguy> jcreigh, that works somewhat better, thanks. not as detailed as i would like, but i'll play around with it
17:35:50 <glguy> dons: I'm going to add a construtor to the Entry data type, "Deleted"
17:36:03 <glguy> dons: so that the ids don't get unordered
17:36:03 <dons> ok. and this will allow what?
17:36:08 <dons> ok
17:36:15 <glguy> correcting these kinds of things after the fact
17:36:30 <dons> sounds reasonable
17:36:41 <dons> note that the urls will need to continue working
17:36:41 <glguy> dons: how do I write a Binary instance for something that has no data?
17:36:44 <glguy> put ()
17:36:51 <dons> so it should point to a page saying "entry delted" or osmehting
17:37:01 <dons> glguy: trivially!
17:37:03 <glguy> dons: makes sense
17:37:05 <dons> put x = return ()
17:37:11 <dons> get = return D
17:37:17 <jcreigh> chessguy: ah, well, show is lazy too, so as someone mentioned, you can look a bit ahead with take 30 $ show [1..] (or show $ take 10 [1..]), or some combination thereof.
17:37:18 <dons> since it need never go to disk..
17:37:26 <glguy> ok
17:37:52 <glguy> what kind of restrictions should I put on deleting pastes?
17:37:55 <jcreigh> I've never looked much a "hat", that might do some of this stuff.
17:38:20 <dons> its a bit (very?) unstable though... we should kick ndm some more
17:38:52 <dons> glguy: hmm. if its been annotated, you can't delete?
17:38:54 <jcreigh> *at "hat"
17:38:58 <chessguy> jcreigh, maybe i'll write fibs the right way, and play around with fibs !! x
17:39:03 <dons> glguy: hmm.... and you can only delete your own!
17:39:10 <dons> glguy: so how do you propose to do that eh?
17:39:10 <glguy> :-p
17:39:40 <dons> i think it would be easier to just spot dupes on insertion
17:39:55 <dons> though we'll need to manage spam at some point
17:39:57 <glguy> dons: I still want to be able to delete stuff... spam?
17:40:01 <dons> yeah
17:40:07 <sorear> glguy: HPaste OPERs!
17:40:25 <glguy> I don't have a good wayfor the bot to interact with the HAppS state though
17:40:26 <sorear> glguy: how about mg on the state files?
17:40:29 <dons> sorear is an op fiend
17:40:47 <glguy> sorear: mg?
17:40:56 <dons> does HAppS have some standard authetnication system
17:40:58 <sorear> desugar error: "op fiend"
17:41:11 <sorear> glguy: an editor - vi with emacs l&f
17:41:57 <glguy> dons, i believe that it might
17:42:44 <sorear> dons: what's an op fiend?
17:42:56 <glguy> someone who likes having lots of ops
17:43:39 <glguy> dons: how do I do a binary instance for something with multiple constructors?
17:43:45 <glguy> do i have to put a flag first
17:43:53 <sorear> how could you tell!
17:43:55 <sorear> glguy: yes
17:44:05 <sorear> glguy: see eg. Plugin/Seen.hs in lambdabot
17:44:35 <sorear> hmm.  could @source lambdabot:Plugin.Seen be made to Work Well?
17:45:57 <dons> glguy: yeah, you put a tag bit first
17:46:04 * glguy wonders if it would be reasonable to deriving Enum, and just use the fromEnum
17:46:08 <glguy> value to index the constructors
17:46:09 <dons> glguy: check the docs for binary (see the file src/Data/Binary.hs)
17:46:19 <dons> glguy: for enum types , yeah, that works
17:46:39 <dons> instance Binary Ordering where
17:46:39 <dons>     put     = putWord8 . fromIntegral . fromEnum
17:46:40 <dons>     get     = liftM (toEnum . fromIntegral) getWord8
17:46:42 <dons> for example
17:47:03 <glguy> I mean: a <- get; case a of 0 -> ConA; 1 -> ConB
17:47:11 <dons> right
17:47:16 <dons> that's how you do tags
17:47:17 <glguy> ok, cool
17:47:23 <dons> see the examples in src/Data/Binary.hs
17:47:29 <dons> (if you have binary lying around)
17:47:31 * glguy is reading now
17:47:33 <dons> ?where binary
17:47:34 <lambdabot> http://darcs.haskell.org/binary
17:47:39 <glguy> I have the source
17:47:42 <glguy> I had it so I could install it
17:47:49 <dons> ?karma+ glguy
17:47:50 <lambdabot> glguy's karma raised to 48.
17:47:52 <dons> got the src!
17:48:29 <conal> sorear: i got your message "TV uses DOS linefeeds (bug?)".  not sure what you mean.
17:49:34 <sorear> \015\012
17:49:43 <sorear> as opposed to
17:49:44 <sorear> \012
17:49:50 <conal> where does it happen?
17:50:08 <sorear> conal: checking...
17:51:03 <glguy> dons: it won't work in this case, but I found myself wanting to write: mapM_ put [a,b,c]
17:51:16 <glguy> (damn strongly typed lists...)
17:51:22 <sorear> conal: everywhere except under _darcs
17:51:39 <sorear> I don't know if you would consider this a problem however.
17:51:44 <conal> sorear: oh, so you mean in the source code?
17:52:43 <sorear> conal: yes
17:53:13 <Hoggy> Does anyone know how to build a tree from a list of directories?
17:53:20 <glguy> crisis averted!
17:53:26 <conal> sorear: i don't mind fixing it.  can easily automate.  what happens on your end?  how did you notice?
17:53:30 <glguy> one paste id returns a list of entries
17:53:35 <glguy> no entries, no content!
17:53:48 <glguy> PasteState (S.Seq [Entry])
17:54:37 <sorear> conal: mg apparently doesn't support DOS newlines
17:54:45 <conal> sorear: mg??
17:54:56 <sorear> conal: first line of REAME as I saw it: TV is a library for visualizing functional values.  It can also be viewed^M
17:55:02 <sorear> it's an editor
17:55:24 <sorear> vi-niche with emacs keys
17:55:41 <conal> sorear: got it, thanks.  mg as in mercury -- messenger.
17:55:49 <shapr> Hoggy: Have you looked at the module named 'Directory' in the ghc libs?
17:56:01 <sorear> much less annoying than typing :wq in emacs and ^X^S in vi, like I used to :)
17:56:20 <conal> sorear: yeah -- painful transition!
17:56:20 <shapr> I prefer M-x viper-mode of course.
17:56:48 <conal> so what the heck to people do about end-of-line conventions in source code across OSs?
17:56:49 <Hoggy> shapr: Sorry, I didn't really mean directories, I mean from a [String]
17:57:07 <shapr> Hoggy: huh? What kind of tree?
17:57:15 <monochrom> What is in the [String]?
17:57:39 <Hoggy> To make it easier, let's say from a [[String]]
17:57:53 <monochrom> And what is in the [[String]]?
17:58:05 <shapr> Hoggy: I don't understand what you're trying to do.
17:58:05 <Hoggy> So [["Root", "Child 1"], ["Root", "Child 2"]]
17:58:27 <shapr> Hoggy: What's the input, and what's the output?
17:58:34 <Hoggy> Would produce a tree with root "Root" that has two children, "Child 1" and "Child 2"
17:59:00 <sorear> conal: I wasn't transitioning - before I discovered mg I was using both regularly.
17:59:33 <shapr> Hoggy: What kind of tree?
18:00:13 <monochrom> In other words, have you defined a tree data type?
18:00:28 <Hoggy> I think something like this: data Tree = Tree { name :: String, children :: [Tree]}
18:00:50 <shapr> Hoggy: Why a record instead of an ADT?
18:01:11 <monochrom> The record is an ADT.
18:01:13 <Hoggy> I wanted to store other stuff in the tree as well
18:02:06 <Hoggy> pathsToTree :: [[String]] -> Tree
18:02:38 <Hoggy> I'm having trying getting my head around the algorithm I need to write to do this
18:03:16 <conal> dcoutts__: gtk2hs still building .....   btw, is it meant to be buildable from its darcs repo?  i found no ./configure when i tried earlier today.
18:03:57 <dcoutts__> conal: that's right, since configure is generated code it's standard practise not to include it in the source control system
18:04:15 <dcoutts__> conal: so for the darcs version you have to run autoreconf
18:04:22 <dcoutts__> which generates configure
18:04:30 <dons> dcoutts__: i'm about to try oout the cabal-get stuff
18:04:38 <dons> am i looking for cabal-install ?
18:04:52 <conal> dcoutts__: i see.  thanks.
18:04:58 <dcoutts__> dons: erm, no I think that's something different
18:05:18 <dcoutts__> dons: so I've written a list comp desugarer using the haskell-src package. I should turn it into a lambdabot module
18:05:38 <dcoutts__> dons: it was actually really easy, it's a direct translation of the H98 report
18:06:10 <dons> yeah. that's another thing
18:06:10 <dcoutts__> the standard translation introduces lots of concatMaps!
18:06:18 <dons> so we can, e.g. . pl . undo . unlist
18:06:22 <monochrom> I would scan the input and store the parent-child relation in a Data.Map first.  Then I would scan the map to build the tree.
18:06:24 <dcoutts__> map f as = [f a | a <- as]
18:06:24 <dcoutts__> map f as = let ok0 a = [f a] in concatMap ok0 as
18:06:28 <chessguy> that would indeed be a very convenient LB module
18:06:29 <dons> mm
18:06:33 <dons> bah on concatMap
18:06:53 <sorear> =<< is so much better
18:07:01 <dcoutts__> [ e | p <- l, Q ]    = let ok p = [ e | Q ]
18:07:02 <dcoutts__>                            ok _ = []
18:07:02 <dcoutts__>                         in concatMap ok l
18:07:07 <Hoggy> Monochrom: Ok, I'll try that
18:07:14 <dcoutts__> that's the rule, so every <- gives you a concatMap
18:07:18 <sorear> dcoutts__: RULES++
18:07:43 <sorear> dcoutts__: you should see the code proc notation generates
18:07:46 <Hoggy> Monochrom: Except I think the function should be pathsToForest :: [[String]] -> [Tree] because pathsToTree [] would make sense
18:08:03 <dcoutts__> sorear: you mean do notation? or arrows ?
18:08:10 <sorear> dcoutts__: arrows
18:08:23 <dcoutts__> aye, I can believe that's horrible
18:08:39 <dons> dcoutts__: so where does cabal-get live?
18:08:42 <dons> in cabal/ ?
18:08:46 <dcoutts__> dons: I think so
18:08:57 <dons> $ pwd
18:08:57 <dons> /home/dons/src/cabal
18:08:57 <dons> $ find . -name '*get'
18:09:09 <sorear> dons: for ByteString ReadP, do you recommend a specific copy of ReadP to fork from?
18:09:12 <dons> ./cabal-install/dependencies/HTTP-2006.7.7/test/get.hs ?
18:09:15 <Igloo> cabal-install is the new cabal-get AIUI
18:09:23 <dons> sorear: hmm. I recommend looking at the Get monad in binary
18:09:34 <dons> and presume you should take the readP from base?
18:09:36 <sorear> dons: (otherwise I'll just copy Text.ParserCombinators.ReadP)
18:09:42 <sorear> ooh Get monad
18:10:00 <dcoutts__> Igloo: what was the really simple command line tool that just runs the simple build system or calls setup.hs ?
18:10:01 <sorear> it's a full parser combinator monad?
18:10:11 <dcoutts__> Igloo: I thought that was -install
18:10:11 <dons> no, its a azy bytestring parser monad though
18:10:12 <sorear> cabal-setup ?
18:10:17 <dcoutts__> ah yes
18:10:20 <dons> so it keeps track of the bytestring state
18:10:23 <dcoutts__> names names
18:10:27 <dons> and you layer your parser combinators on top
18:10:45 <sorear> muahahaha. thanks.
18:10:55 <dons> Igloo: ah ok
18:11:34 <dons> so now i have cabal-setup on my disk, yay
18:11:39 <dons> but cabal-install isn't installed by default?
18:11:47 <Igloo> Does anyone happen to know what's happening when openoffice refuses to put some text and a table on the same page?
18:11:50 <dcoutts__> it wasn't in the last release
18:12:07 <dcoutts__> oh, sorry, confused again. :-)
18:12:17 <dons> ah i see. cabal doesn't install any exeutables currently
18:12:59 <dons> i think most of the issues with hakcage/cabal at the moment are missing documentatoin/directive ones
18:13:13 * dons installs cabal-install 
18:13:33 <dons> hmm. no examples of use in the cabal-install readme
18:13:49 <dcoutts__> dons: send doc patches! :-)
18:13:53 <dons> will do
18:14:23 <dons> cabal-install install --prefix=/tmp --user hnop
18:16:25 <dons> configure: found package tool in /home/dons/bin/ghc-pkg
18:16:26 <dons> cabal-install: No valid config dir found!
18:16:29 <dons> hmm?
18:16:52 <dons> oh, is that the etc-cabal-install/serv.list file?
18:16:56 <dons> dcoutts__: ^^
18:17:27 <dcoutts__> dons: I'm not really the one to ask, I don't know that much about cabal-install
18:17:36 <dcoutts__> but that sounds a reasonable guess
18:17:39 <dons> ah /etc/cabal-instal
18:17:50 <dons> is the default place to look (not ~/.cabal-install)
18:18:05 <dcoutts__> cabal can't currently install in locatons like /etc
18:18:26 <dons> and I don't like that place anyway!
18:18:36 <dons> no 3rd party packages are allowed to touch /etc on openbsd
18:19:08 <sorear> ditto here (debian FHS)
18:19:11 * dons tries to make cabal-install work
18:19:19 <shapr> Who's working on hs-plugins for 6.6?
18:19:32 <sorear> actually all FHS-compliant unixen ... even the proprietary ones
18:19:38 <sorear> shapr: afaik nobody
18:19:43 <dons> nah. can't get past this config error :(
18:19:48 <shapr> Hm, I thought someone was the past coupla days.
18:19:59 * dons looks for an AUTHORS file
18:20:09 <dons> Lemmih!
18:20:15 <dons> xerox!
18:20:31 <sorear> shapr: robreim wants to, but expects dons to give pointers ... dons has more valuable-to-him tasks  (trying to avoid judgement here)
18:20:36 <shapr> oh
18:20:38 <shapr> ok
18:20:42 <dons> ok. i think i'll just release binary now, and try to ufix cabal-install later
18:20:53 <dons> sorear: hey, i'm trying to give pointers
18:20:58 <conal> dcoutts__: i'm still puzzled over the "/" -> "\" conversion happening in cabal's "./setup configure".  who might know what's the deal there?
18:21:02 <dons> everything i know i've given
18:21:22 <shapr> robreim: How's it going?
18:21:33 <dcoutts__> conal:  you're not using MSYS then?
18:21:33 <robreim> difficult :(
18:21:40 <dons> i think he's stuck on a mysterious glibc thingy?
18:21:43 <shapr> robreim: Tell me more!
18:21:52 <dons> got to check what ghci is doing, that it doesn't suffer the same issue
18:21:56 <conal> dcoutts__: right.  using cygwin
18:22:01 <shapr> Foo, I missed SyntaxNinja
18:22:05 <robreim> Well, I rolled back my changes to get rid of the glibc thingie which is probably something I introduced
18:22:13 <dcoutts__> conal: have you tried running the command from a dos window?
18:22:23 <conal> dcoutts__: yes.  it happens via straight cmd.exe as well
18:22:34 <shapr> glguy: got a minute?
18:22:36 <robreim> I've done a diff of ghc 6.4 and 6.6's BinIface.hs but I can't find any changes relevant to hs-plugins
18:22:51 <glguy> shapr: sure
18:22:57 <robreim> It might be a change in a different file but from what I can gather BinIface is where all the parsed .hi syntax is...
18:23:08 <dcoutts__> conal: oh ok, you'd have to debug it. print out the value at various points in the prog and try and see where it gets flipped
18:23:30 <shapr> glguy: I have an idea about making hpaste a collaborative tool... but I'm not quite sure what my question is...
18:23:49 <glguy> shapr: talk it out :)
18:24:08 <conal> dcoutts__: i can do that.  i hoped for some pointers about a likely neighborhood in the code.
18:24:51 <robreim> Basically, I'm just hacking at hs-plugins, randomly trying things and not really knowing what I'm doing :)
18:25:07 <shapr> glguy: I want a button at the bottom of an hpaste page (or maybe each single paste?) that dumps the buffer into the hs-plugins eval thingy via this -> http://a-i-studio.com/cmd/
18:25:24 <dcoutts__> conal: sorry, I'd just start at a point where I know it's ok and a point where it's got flipped and then try repeated bisecting
18:25:38 <shapr> dons and I were talking about ways to remove indirection on #haskell
18:25:57 <dcoutts__> g'night folks, I gotta see SPJ and RL in the morning, bright and early
18:25:58 <conal> dcoutts__: sure.  btw, gtk2hs is still compiling.  wow.
18:26:08 <shapr> Roman L.?
18:26:13 <dons> yeah
18:26:14 <shapr> g'nite dcoutts__!
18:26:21 <dcoutts__> conal: with -O it takes about 30 min on my box, 5 min with -O0
18:26:30 <dcoutts__> g'night shapr
18:26:31 <chessguy> ?where yaht
18:26:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:26:45 <shapr> glguy: Now that I think about it, I guess it won't change hpaste much :-)
18:26:51 <glguy> :-p
18:27:14 <shapr> But I wanted to ask you if you could think of more ways to take the manual clicking/pasting/etc out of #haskell activities.
18:28:02 <glguy> get people to paste *less* ?
18:28:20 <shapr> huh?
18:28:32 <sorear> make it more automatic... ghc -fpaste-erroneous-code :)
18:28:50 <glguy> hmm
18:29:17 <glguy> I don't off hand, but I'll let it run through my mind for now
18:29:27 <shapr> ok
18:29:46 <ray> i like that one sorear
18:29:58 <sorear> thanks
18:30:00 <ray> anyone willing to implement it :P
18:31:39 <sorear> ray: dons is doing something close: ghc foo 2>&1 | hpaste --nick=sorear
18:31:54 <sorear> I'd implement it, but I don't want to duplicate work :)
18:32:24 <shapr> What are other #haskell activities? Or do we mostly do collaborative debugging?
18:32:52 <sorear> shapr: development
18:33:11 <sorear> shapr: I'm working (sorta) on a generalized tell/todo system
18:33:13 <monochrom> We mostly do collaborative tutoring.
18:33:51 <shapr> I've often thought that my todo system could be automated if I included a unit test with each todo item that would automatically mark the item done when thecode works.
18:34:19 <sorear>  @ask Igloo|JaffaCake $ARCANE_THING_(lets ignore #ghc for pedagoggical purposes)
18:34:31 <sorear>  @todo sorear implement ReadP-FPS
18:34:48 <sorear>  @todo *hpaste implement server side tabexpansion
18:34:50 <sorear> like that
18:35:18 <shapr> hm, yeah
18:35:28 <shapr> sort of like a @tell that doesn't go away?
18:35:33 <sorear> of course it's mostly unimplemented, and dons has challenged me to prove it is useful before adding complexity
18:35:45 <sorear> shapr: that's exactly what my @todo would do
18:36:08 <sorear> shapr: with polynicks the new @todo *lambdabot would subsume the current @todo
18:36:25 <sorear> polynicks == matches multiple -- *project, user1|user2
18:36:40 <sorear> | form is implemented for the new nick matching
18:36:52 <sorear> the new nick matching is only used now by @karma
18:36:56 <sorear> @karma dons|audreyt
18:36:57 <lambdabot> dons|audreyt has a karma of 186
18:37:59 <shapr> hmm
18:38:06 <sorear> I still need to implement *project (and the @link, @unlink commands for showing your affiliations)
18:38:28 <sorear> I still need to rewrite seen & tell to use the new matching
18:38:54 <sorear> I still need to find some compelling answer to dons' challenge
18:41:23 <sorear> 07.01.21 : 22:36:13 <dons> hmm, but do we *need* these fancy features?
18:41:40 <shapr> Well, we don't use @todo that much, so I can see why he's asking.
18:41:42 <sorear> 22:36:41 <dons> i'd be more interested in stabiity issues than yet more features
18:42:17 <dons> language hacking tools are always welcome though
18:42:45 <dons> so if you want to write a desguarer, or a transformer of src, or say, port @pl to langauge .Haskell and add more rewirte rules, i wouldn't complain
18:43:29 <dons> :)
18:50:35 <conal> when sharing code via darcs, how do people deal with the differing end-of-line conventions in different OSs?
18:51:54 <monochrom> By using good editors that honours the convention in the file and ignore its host OS.
18:52:03 <hpaste> ?yow -- duplicates deleted
18:52:03 <lambdabot> Zippy's brain cells are straining to bridge synapses ...
18:52:15 <monochrom> For example no one uses Notepad.
18:52:53 <allbery_b> given some of its interesting unicode bugs, that's for the best
18:53:14 <Excedrin> does darcs handle utf8 encoded files in a reasonable way?
18:53:38 <conal> monochrom: that works for me, since i use emacs.  are there plenty of editors that go both ways?
18:53:52 <shapr> conal: I just cry... but seriously, emacs can transparently read microsoft and unix line endings and save the file with the same endings.
18:54:07 <shapr> Ah, you already know that :-)
18:54:21 <conal> shapr: yep. :)  emacs is my pal.
18:55:45 <monochrom> vim does that too.
18:55:53 <monochrom> eclipse certainly.
18:56:18 <monochrom> I can't imagine any editor that doesn't abstract away eol.
18:56:44 <monochrom> Of course, by that I mean I can't imagine any programmer using the likes of pico and nano for programming.
18:56:56 <dons> ?yow binary is alive!!
18:56:57 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
18:57:00 <dons> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021662.htm
18:57:02 <lambdabot> http://tinyurl.com/2meddg
18:57:10 <monochrom> But of course my imagination has nothing to do with reality.
18:57:13 <dons> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021662.html
18:57:15 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: binary: high performance, pure binary serialisation, http://tinyurl.com/2kmyle
18:57:16 <dons> better
18:57:32 <shapr> yay binary!
18:57:45 <monochrom> The reality is that I know 4th year CS majors who use pico to edit source code files.
18:57:47 <shapr> monochrom: I actually worked with someone who preferred to write VB4 in Notepad.
18:58:39 <shapr> That was one of those times when I wanted to carefully examine their forehead & temples and say "Your lobotomy scars don't show."
18:58:55 <dons> heh
18:58:58 <malsyned> Hey, speaking of programmers' text editors, I can't seem to find any information on haskell-mode's inferior haskell mode.  The docs I've found just say "there is an inferior haskell mode" and leave it at that.
18:59:07 <allbery_b> @remember shapr That was one of those times when I wanted to carefully examine their forehead & temples and say "Your lobotomy scars don't show."
18:59:08 <lambdabot> Done.
18:59:19 <shapr> malsyned: You mean a haskell minor-mode?
18:59:42 <shapr> I know there's the ghci inferior-mode
19:00:01 <malsyned> shapr: no, I mean an inferior mode.  as in, running ghci or hugs within emacs and interacting with it from haskell buffers.
19:00:19 <monochrom> there is a ghci inferior mode, a hugs inferior mode, and a generic inferior mode.
19:00:46 <malsyned> right.  so I keep reading.  But how do I set them up and use them?
19:00:50 <monochrom> if you aren't explicit about using ghci or hugs, you get the generic one.  it's called "haskell inferior mode"
19:01:08 <shapr> malsyned: Go into a haskell buffer, M-x turn-on-haskell-ghci and then C-c C-l
19:01:13 <monochrom> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)  is an example
19:02:09 <malsyned> oh hot.  thanks!
19:02:15 <monochrom> The generic one does not parse error messages and bring you to points of errors.  That's all.
19:02:36 <conal> dons: the binary package looks awesome.  is there support for deriving Binary instances?
19:03:59 <dons> we have a script that does some SYB traversal magic, and dumps the appropriate instance as a String
19:04:04 <dons> i should test it though
19:04:12 * dons checks how this works
19:07:04 <dons> conal: yeah, in tools/derive
19:07:13 <conal> dons: nifty :)
19:07:34 <conal> i'm reading the code.  lovely.
19:08:21 <hpaste>  dons pasted "deriving binary with SYB" at http://hpaste.org/110
19:09:50 <shapr> What? No Ginger Ale or Ginger Beer?
19:10:25 <Nafai> Hi shapr!
19:10:44 <shapr> hiya Nafai!
19:13:49 <Nafai> Is it generally good Haskell style to explicitly declare the types of functions or is it okay to just let the compiler infer it when it can?
19:14:17 <bd_> Nafai: It helps track down errors, certainly. And if you want to use haddock it's necessary.
19:16:10 <shapr> Nafai: I like to write all my code first, and then if I have problems I come back and write down a few type signatures and see what type errors I get.
19:16:22 * Nafai nods
19:16:25 <sjanssen> Nafai: for short hacks I generally don't declare types, but for anything that you want other people to use you should write type declarations
19:16:40 <Nafai> Makes sense
19:16:45 <dons> for code i post to impress pythonistas, I leave the types to be inferred ;)
19:17:04 <dons> look ma! no types!
19:17:29 <shapr> Be aware that type signatures are part of the actual essential task of programming. Sometimes you can change a type signature in a legal working program and you get a different legal working program.
19:18:17 <shapr> Type signatures can affect execution speed in various ways as well. Compilers produce the most generic code when you don't specifcy something more restrictive.
19:20:25 <shapr> In Oleg messages, type signatures could be the entire program!
19:20:26 <chessguy> ?remember dons look ma! no types!
19:20:27 <lambdabot> Done.
19:20:57 <shapr> Who wrote the turing-complete type checker demo recently?
19:21:12 <dons> In soviet russia the types signatures infer you!
19:21:26 * shapr snickers
19:21:26 <dons> Rob dockins
19:21:51 <chessguy> @quote type
19:21:51 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
19:22:04 <shapr> Nafai: Things like that sparked my interest in termination, aka 'strongly normalizing'.
19:22:27 <shapr> Haskell's type system without extensions is guaranteed to terminate. With extensions it gets exciting.
19:22:41 <jcreigh> FSVO exciting.
19:22:43 <jcreigh> :)
19:22:58 <emu> exptime exciting
19:22:58 <bd_> 'even with cunning newtype deriving the newtype is recursive' <-- heh, how does one get ghc to do that?
19:23:19 <SamB> do what?
19:23:39 <SamB> emu: "halting problem" exciting
19:23:50 <shapr> Weren't there 'match the error message' contests here at one point?
19:23:54 <SamB> oh, that...
19:23:55 <sjanssen> !paste
19:23:55 <hpaste> Haskell paste bin: http://hpaste.org/
19:24:30 <monochrom> Type inference is beyond exptime.
19:24:32 <hpaste>  sjanssen pasted "check the error message" at http://hpaste.org/111
19:24:51 <sjanssen> bd_: there you go
19:24:52 <SamB> there was a turing machine that used the typesystem *waaaay* back wasn't there?
19:24:54 <emu> tpye inference in h98 is exptime, eh
19:25:04 <bd_> ah
19:25:25 <SamB> "newtype X = X X deriving Show", maybe?
19:25:46 <SamB> though why that should be a static error is beyond me...
19:26:12 <bd_> SamB: the compiler has to figure out the representation of X ...
19:26:22 <bd_> which is a bit difficult...
19:26:24 <SamB> bd_: oh.
19:26:33 <SamB> what does that have to do with derivings?
19:26:56 <bd_> hm
19:27:02 <sjanssen> SamB: see the program I pasted
19:27:03 <bd_> actually it accepts newtype T = T T
19:27:16 <bd_> I guess it's trying to derive an instance in terms of itself, and failing
19:27:52 <SamB> sjanssen: oh. so my guess was right?
19:27:54 <SamB> or not.
19:28:01 <SamB> does it need to be Monad?
19:28:27 <bd_> hmm, I can derive Eq
19:29:02 <sjanssen> SamB: I think any class that isn't derivable in H98 will cause this error
19:29:30 <sjanssen> "cunning newtype deriving" is GHC's extension to derive any class for a newtype
19:30:13 <SamB> even with cunning newtype deriving:
19:30:13 <SamB>      the newtype is recursive
19:30:13 <SamB>      the type constructor has wrong kind
19:30:26 <SamB> is that some kind of an attempt at haiku?
19:31:18 <bd_> 9-7-8?
19:31:36 <SamB> I just meant it doesn't make much sense as an error message...
19:32:30 <bd_> Sure it does. You're doing cunning newtype deriving on a recursive newtype, and your typecon has kind * while Monad is (* -> *) -> * :)
19:32:57 <sjanssen> try deriving Monoid instead of Monad
19:33:18 <SamB> why shouldn't I?
19:33:20 <sjanssen> (or another class that requires kind *, but isn't derivable in H98)
19:33:30 <SamB> oh, right.
19:33:54 <SamB> these messages are stupid
19:33:58 <SamB> also...
19:34:05 <shapr> well, fix 'em
19:34:05 <SamB> newtype Y z = Y (z (Y z)) deriving Foo
19:34:11 <SamB> that is perfectly legitimate!
19:34:21 <SamB> why shouldn't I derive Foo for that?
19:35:05 <sorear> tell fodder
19:35:16 <Nafai> Sorry, I stepped away for a bit
19:35:18 <SamB> tell fodder what?
19:35:24 <Nafai> Thanks for the answers
19:35:53 <SamB> oh, and there is no significance attached to Y
19:35:59 <SamB> except that it comes after X
19:36:01 <SamB> FYI
19:36:08 <bd_> SamB: You might be able to, have you triedf
19:36:08 <bd_> ?
19:36:12 <SamB> so no correcting me on my faulty "y combinator"
19:36:14 <SamB> bd_: yeah
19:36:18 <bd_> oh :/
19:36:44 <SamB> cunning.hs:7:8:
19:36:44 <SamB>     Can't make a derived instance of `Foo (Y z)'
19:36:44 <SamB>     (even with cunning newtype deriving:
19:36:44 <SamB>      the newtype is recursive)
19:36:44 <SamB>     When deriving instances for type `Y'
19:37:47 <SamB> I don't see why GHC should care if newtypes are recursive only when doing cunning newtype derivings, either!
19:38:04 <SamB> I mean, it doesn't seem to care in the case of Eq, why should it care in other cases?
19:38:39 <sorear> conal: I only use mg when I'm too lazy to switch to my emacs vs. :)
19:38:43 <SamB> hmm, even wierder!
19:38:50 <bd_> ?ghc
19:38:51 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
19:39:10 <SamB> cunning.hs:7:8:
19:39:10 <SamB>     No instance for (Show (z (Y z)))
19:39:10 <SamB>       arising from the 'deriving' clause of a data type declaration at cunning.hs:7:8
19:39:10 <SamB>     Probable fix: add an instance declaration for (Show (z (Y z)))
19:39:10 <SamB>     When deriving the `Show' instance for type `Y'
19:39:35 <conal> sorear: have you run into the eol problem in other libs?
19:39:54 <sorear> conal: nope
19:40:02 <sorear> conal: everyone else uses *NIX
19:40:13 <sorear> (line endings at least)
19:40:41 <sorear> mg *should* handle it, it's not a *bug* in your code ... just something I thought you should be aware of
19:40:47 <hpaste>  Nafai pasted "(no title)" at http://hpaste.org/112
19:41:12 <conal> sorear: i'm glad to know.  wouldn't have thought of it.
19:41:26 <Nafai> Question!  Why would ghci infer the type of the first function in that past as IO String, but the second as IO [Char]?
19:41:37 <Nafai> Though String == [Char], but still?
19:41:39 <sorear> Nafai: those are the same type
19:41:53 <Nafai> Why the difference though?
19:41:55 <sorear> Nafai: type synoym inference is black magic
19:42:11 <sorear> Nafai: GHC does it ostensibly for error messages only
19:42:18 <Nafai> Okay
19:42:27 <Nafai> Just curious if there was something else I was missing
19:42:30 <sorear> Nafai: if you were a lobotomized n00b, would you want to see [Char] ?
19:42:48 <malsyned> Is System.Posix.Files missing a FileMode for the sticky bit, or is the doc I'm reading out-of-date?
19:43:16 <Nafai> sorear: I'd probably be confused if I didn't know they were the same. :)
19:43:57 <Nafai> I knew they were the same but I was curious why it wasn't reported the same; I surmised it was possibly that I used "concat . words"
19:45:36 <sjanssen> Nafai: the concat might've done it
19:45:38 <SamB> compilers aren't required to tell the user types at all
19:46:01 <SamB> even if they were, they wouldn't be required to keep type synonyms unexpanded ever in such tellings
19:46:21 * Nafai nods
19:46:23 <bd_> :t concat . words
19:46:25 <lambdabot> String -> [Char]
19:46:34 <bd_> :t unwords . inits
19:46:36 <lambdabot> [Char] -> String
19:46:45 <bd_> :t unwords . inits . concat . words
19:46:47 <lambdabot> String -> String
19:46:50 <bd_> heh
19:46:50 <sorear> For readp-fps, should I bother with updating/understanding the #ifdef __NHC__ cruft?
19:47:32 <sjanssen> sorear: I don't think bytestring works in NHC
19:47:44 <sjanssen> at least I've never heard of anyone trying it
19:48:01 <sorear> sjanssen: so I should delete it, and not worry?
19:48:16 <sorear> does yhc define __NHC__ ?
19:48:28 <sjanssen> yhc doesn't support ByteString either
19:48:47 <dons> bytestring does work in nhc
19:48:51 <dons> malcolm got the port going
19:48:54 <dons> and sent me some patches
19:49:01 <dons> the yhc guys, well, i don't know wht they're doing!
19:49:02 <sjanssen> ah, neat
19:49:18 <sjanssen> yhc doesn't support FFI, the last I heard
19:49:33 <dons> :(
19:50:36 <sorear> dons: does modern NHC support whatever motivated the ifdefs?
19:50:59 <dons> i don't know what code you're looking at
19:51:57 <sorear> readp, and polymorphic fields
19:52:11 <dons> where?
19:52:18 <dons> in Text.*?
19:53:51 <sorear> Text.ParserCombinators.ReadP
19:53:58 <sorear>  newtype ReadP a = R (forall b . (a -> P b) -> P b)
19:55:26 <dons> the only way to know for sure is to get nhc from darcs and try to test it
19:55:33 <dons> i'd not bother yet. do hugs /ghc
19:55:36 <dons> then get back to nhc later
19:57:26 <sorear> ok
20:09:56 <Elifant> > fmap (+1) (1, 2)
20:09:57 <lambdabot>   add an instance declaration for (Functor ((,) a))
20:09:57 <lambdabot>     In the definition of ...
20:10:08 <Elifant> is there 'map' for tuples?
20:10:56 <bd_> Elifant: How would that work on a tuple (a, b)? :)
20:10:56 <sorear> nope
20:11:26 <sorear> Elifant: there was a nice discussion on the mailing list this month, Oleg even talked
20:11:53 <sorear> stefan's typo file, #23: Olegarchy
20:12:02 <Elifant> i mean homogenous tuples, of course...
20:12:24 <sorear> of course
20:12:31 <bd_> you'd need a type synonym I think
20:12:41 <bd_> type Tuple2 a = (a, a)
20:12:50 <bd_> instance Functor Tuple2 where fmap f (a, b) = (f a, f b)
20:12:56 <sorear> since we dont have typelambda with NF equality, (moan whine moan whine)...
20:13:02 <sorear> bd_: that won't work
20:13:03 <sjanssen> bd_: that isn't legal
20:13:09 <bd_> ohh
20:13:10 <bd_> oh*
20:13:14 <Elifant> it's easier to write 't f (a, b) = (f a, f b)'
20:13:14 <bd_> why not? :/
20:13:20 <sorear> bd_: decidability
20:13:26 <Elifant> I just hope this is somewhere in std lib
20:13:36 <sorear> Elifant: data Tuple2 a = Tuple2 a a
20:13:44 <bd_> sorear: is that always the answer for silly restrictions in the type system? :)
20:13:44 <sjanssen> "decidability" is the most obtuse one word answer ever :)
20:14:07 <sorear> sjanssen: is that a challenge? :p
20:14:16 <Elifant> sorear: is there 'fmap' for Tuple2 in stdlib? :)
20:15:00 <sorear> Elifant: there isn
20:15:06 <sjanssen> @pl \f (a, b) -> (f a, f b)
20:15:06 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
20:15:08 <sorear> 't even Tuple2 in stdlib!
20:15:20 <sorear> Elifant: HList *might* contain what you want
20:15:47 <Elifant> oh, I don't think I need another external lib just to map tuple :)
20:16:51 <chessguy> well there you go, that's easy
20:17:09 <chessguy> mapTuple2 =  (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
20:17:16 <chessguy> and so readable to boot
20:17:27 <Elifant> :)
20:17:58 <chessguy> @type ( \f (a, b) -> (f a, f b))
20:17:58 <sorear> pl is stoopid
20:17:59 <lambdabot> forall b a. (b -> a) -> (b, b) -> (a, a)
20:18:05 <sorear> @type join (***)
20:18:07 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
20:18:25 <sorear> > join (***) (*2) (34,64)
20:18:27 <lambdabot>  (68,128)
20:18:36 <sorear> that short enough
20:18:37 <sorear> ?
20:18:45 <Elifant> I think my brain will be better with 'tmap2 f (a, b) = (f a, f b)' :)
20:18:49 <chessguy> ?hoogle (a -> b) -> (a, a) -> (b, b)
20:18:50 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:19:20 <kilimanjaro> What does *** do?
20:19:38 <Elifant> hm... there are many tutorial about monads, are there ones about arrows? explaining what they are for?
20:19:43 <kilimanjaro> :t ***
20:19:45 <lambdabot> parse error on input `***'
20:19:47 <bd_> :t (***)
20:19:49 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:19:51 <bd_> it's an arrow operator
20:19:54 <chessguy> the haskell wiki book has some stuff about arrows
20:20:00 <kilimanjaro> ok
20:20:02 <chessguy> @go haskell wiki book
20:20:04 <lambdabot> http://en.wikibooks.org/wiki/Programming:Haskell
20:20:07 <bd_> you can specify that to: (b -> c) -> (b' -> c') -> ((b, b') -> (c, c'))
20:20:22 <bd_> > (succ (***) pred) (0, 0)
20:20:23 <lambdabot>  Couldn't match `b' -> c'' against `(a, b)'
20:20:43 <bd_> hm
20:21:02 <bd_> :t (succ (***) pred)
20:21:04 <lambdabot> forall b b' c'. (Enum ((b -> b) -> (b' -> c') -> (b, b') -> (b, c')), Enum b) => (b' -> c') -> (b, b') -> (b, c')
20:21:14 <dons> not (**)
20:21:17 <sorear> bd_: don't paren infix ops
20:21:17 <sorear> !!
20:21:19 <bd_> oh
20:21:20 <bd_> XD
20:21:24 <bd_> > (succ *** pred) (0, 0)
20:21:25 <dons> > (succ *** pred) (0,0)
20:21:27 <lambdabot>  (1,-1)
20:21:28 <lambdabot>  (1,-1)
20:21:45 <bd_> bd_--, get more sleep.
20:21:59 <sorear> bd_-- you need a space
20:22:20 <sorear> bd_++ I'm not you so I have to fix it :(
20:22:46 <bd_> bd_-- , stop making other people break the karma rules :(
20:23:04 <sorear> btw, you CAN lower your own karma, just say "Java" ++ "++"
20:23:09 <bd_> sorear++ for good sportsmanship
20:23:11 <bd_> heh
20:23:15 <bd_> ?karma bd_
20:23:16 <lambdabot> You have a karma of 2
20:23:18 <bd_> Java++
20:23:18 <bd_> ?karma bd_
20:23:19 <lambdabot> You have a karma of 1
20:23:23 <bd_> ?karma Java
20:23:24 <lambdabot> Java has a karma of -2
20:23:28 <sorear> bd__++
20:23:29 <bd_> ?karma+ Java
20:23:30 <lambdabot> bd_'s karma lowered to 0.
20:23:34 <bd_> heh
20:23:49 <chessguy> lol
20:23:57 <sorear_paranoid> Java++++
20:24:01 <sorear_paranoid> @karma Java++
20:24:02 <lambdabot> Java++ has a karma of 1
20:24:04 <sorear_paranoid> @karma+ Java++
20:24:05 <lambdabot> Java++'s karma raised to 2.
20:24:07 <sorear_paranoid> @karma
20:24:08 <lambdabot> You have a karma of 0
20:24:31 <chessguy> @karma sorear
20:24:32 <lambdabot> sorear has a karma of 19
20:24:36 <chessguy> ooooooh
20:24:54 <sorear> @karma dons
20:24:56 <lambdabot> dons has a karma of 116
20:25:43 <bd_> ?karma haskell
20:25:44 <lambdabot> haskell has a karma of 20
20:26:04 <moconnor> Is it considered good style to provide types for all of your functions?  I find myself writing lots of code that works fine w/ the type inferencer and then going back and manually adding the types just for completeness sake.  Is one preferred over the other?  specifying the types vs not?
20:26:30 <bd_> someone asked the same question earlier tonight :)
20:26:34 <moconnor> oops
20:26:36 <bd_> I tend to throw them in when I get errors
20:26:44 <bd_> to move the error to where it actually is
20:26:45 <master_baiter> i like having them there
20:26:50 <allbery_b> specifying the types (a) lets you make sure you know what t's doing (b) helps the compiler help you find you rerrors
20:26:54 <master_baiter> it makes reading the code easier
20:26:55 <bd_> of course if you are using haddock, you need to put them in
20:27:10 <dons> moconnor: use a script to infer the types
20:27:28 <sorear> bd_: that will be fixed
20:27:48 <sorear> moconnor: eg with shim , C-c C-n ... muahahaha
20:28:11 <moconnor> Is there anything like that for vim?
20:28:36 <dons> I use 'typeOf' available here: http://www.cse.unsw.edu.au/~dons/tmp/typeOf.txt
20:28:41 <dons> you can call this from vim with:
20:28:52 <dons> :map ty :.!typeOf %^M
20:28:56 <dons> in your .vimrc
20:28:59 <moconnor> woah
20:29:01 <moconnor> dons++
20:29:06 <dons> then just hit 'ty' on the top level decl
20:29:44 <malsyned> any way to talk ghc into giving me an instance of Show for (,,,,,) ?
20:30:00 <sorear> malsyned: upgrade
20:30:12 <malsyned> roger that.
20:30:21 <sorear> malsyned: GHC head has instances up to (only) (,,,,,,,,,,,,,,,)
20:30:44 <sorear> I *thought* old GHC had up to (,,,,,,,) ...
20:31:01 <jcreigh> what? Why is it limited?
20:31:15 <malsyned> I'm open to the possibility that I'm naive, but it seems to me that this is a weakness of the Hindley-Milner type system.
20:31:28 <bd_> I suppose because they don't want to make the show instance a primitive
20:31:32 <allbery_b> ghc6.6 goes up to 15-ples
20:31:35 <sorear> jcreigh, malsyned: actually it's the tuple system's fault
20:31:41 <sorear> if we used:
20:31:49 <sorear> data TNil = TNil
20:31:51 <bd_> though, it could be nice if there was some way to decompose tuples generally, I think Haskell' has a proposal for that
20:31:58 <sorear> data TCons a b = TCons a !b
20:32:07 <sorear> then it would Just Work
20:32:20 <jcreigh> Hmm, okay. Makes me a little nervous. I don't have tuples that big, but anytime you pick some hard-coded N, you're in trouble down the road.
20:32:31 <allbery_b> yeh, well, tuples suck
20:32:34 <sorear> join the_club
20:32:40 <allbery_b> consider it encouragement to use real types :)
20:32:47 <dons> hehe, http://programming.reddit.com/info/10uui/details
20:32:48 <lambdabot> Title: Coding productivity: Corbato&#39;s law versus social factors (reddit.com)
20:33:02 <dons> note that haskell is the top of the producitivty scale in his example :)
20:33:04 <sorear> hmm. the club has type exists m a. m (m a) ?
20:33:24 <sorear> s/Monad =>/
20:33:28 <sorear> s/Monad m =>/
20:35:21 <malsyned> hey, so Haskell strings are lists of unicode code points.  Unix file names are arrays of bytes which may or may not represent a string in UTF8, ISO-8859-1, or some other US-ASCII-compatible character set.  How does readFile reconcile that?
20:35:52 <sorear> it doesn't
20:36:11 <sorear> or rather, it converts unicode to 8-bit using (.&. 255)
20:36:12 <sjanssen> malsyned: the lowest 8 bits of each Char are used
20:36:16 <sorear> fun, eh?
20:36:33 <sorear> it even does this for file contents
20:36:49 <sjanssen> doing it for file contents is obviously a bug, though
20:37:03 <sjanssen> not sure what readFile should do
20:37:05 <malsyned> Well, for my application that's pretty much the ideal behavior.  In general, though, it's a little horrifying.
20:37:12 <sorear> of course this bug will probably never be fixed - plan accordingly
20:37:25 <sjanssen> sorear: I think it will be fixed
20:37:28 <base_16> oh
20:37:49 <sjanssen> the IO problem, not the file name problem
20:39:32 <allbery_b> I';m not sure the file name one is fixable
20:39:40 <malsyned> for the file name, it's forgivable.  for the file contents, though, you'd want something like ReadFileWithEncoding :: Encoding -> FilePath -> IO String, right?
20:39:54 <allbery_b> the only safe way to work with unix file names is LANG=C, i.e. treat as unstructured bytes
20:39:55 <malsyned> s/^R/r/
20:40:45 <malsyned> allbery_b: agreed
20:40:49 <sjanssen> malsyned: that is one way to do it.  A readFile that automagically decides which encoding to use would be nice too
20:40:56 <allbery_b> (windows uses utf16 for file paths IIRC, so hthere you can have problems)
20:41:03 <glguy> > 12*1024*365
20:41:05 <lambdabot>  4485120
20:41:22 <sorear> UTF8 FTW!!!
20:41:36 <allbery_b> er, ucs16
20:41:45 <malsyned> sorear: agreed
20:42:03 <malsyned> so how does readFile behave on Windows?  take the bottom 16 bits of each Char?
20:42:12 <malsyned> (for the FilePath argument, I mean)
20:42:34 <sjanssen> malsyned: bottom 8, I believe
20:43:00 <malsyned> it cuts it to the bottom 8, then pads each char up to a wchar_t?
20:43:20 <Elifant> malsyned: then windows converts it to UCS
20:43:27 <Elifant> according to locale
20:43:40 <sorear> that sounds lossy :)
20:44:09 <Elifant> does readFile uses CreateFileA or CreateFileW?
20:44:10 <sjanssen> ideally, FilePath would be an ADT that abstracts all this
20:44:19 <malsyned> so Windows file paths are in UCS, but the API calls take char *s in a given 8-bit locale-specific encoding?
20:44:27 <Elifant> if 'A', then 8-bit chars are converted to UCS internally by Windows.
20:45:10 <SamB> sorear: that is lossy
20:45:18 <SamB> which is why there are W calls, too...
20:47:57 <malsyned> remind me never to take a job as a Windows programmer
20:48:10 <SamB> malsyned: you have trouble remembering that?
20:48:33 <malsyned> :-P
20:48:49 * allbery_b thought CreateFileA was there so Microsoft could pretend there wa a common Win32 API across everything from win95 up
20:49:39 <hpaste>  nicolass pasted "test" at http://hpaste.org/113
20:49:59 <jcreigh> okay, it worked. :)
20:50:20 <hpaste>  nicolass pasted "test" at http://hpaste.org/114
20:50:50 <SamB> allbery_b: pretend?
20:50:57 <SamB> allbery_b: it is true
20:51:01 <SamB> there is one!
20:51:05 <SamB> it just happens to suck
20:51:47 <allbery_b> "just happens"
20:52:13 <allbery_b> win32X apis're about as portable as unix apis :)
20:52:47 <hpaste>  nicolass pasted "test" at http://hpaste.org/115
20:54:00 <malsyned> OK, that's it for me today.  Thanks for all your help, guys.  again.
20:55:06 <hpaste>  nicolass pasted "test" at http://hpaste.org/116
20:56:14 <sorear> glguy: I don't suppose hpaste supports bans? :)
20:56:28 <glguy> sorear: how do you propose I do that? :)
20:56:35 <sorear> glguy: IP ?
20:57:14 <jcreigh> heh, you could have hpaste announce the posting IP, then if there was a problem, you just say "!ban 1.2.3.4" in-channel.
20:57:19 <sorear> "Your paste has been automatically silenced due to banned IP"
20:57:40 <glguy> I don't have a way for the bot to talk to the webserver yet
20:58:04 <glguy> I haven't figured out an appropriate way to do that in HAppS
20:58:44 <jcreigh> how does the bot know when there's a paste?
20:59:08 <glguy> HAppS schedules of IO action to add the announcement to a Chan
21:00:13 <sorear> jcreigh: ideally HAppS would allow the hpaste to feed data in realtime down a socket... then lambdabot could feed everything back to hpaste
21:00:24 <sorear> hmm.
21:00:35 <sorear> HAppS supports SMTP and HTTP.
21:00:58 <sorear> perhaps instead of fighing it, one of us should hack IRC support in to happs!
21:00:58 <glguy> you want me to mail lambdabot on paste?
21:01:18 <sorear> muahahaha!
21:01:21 * allbery_b was actually wondering f the simplest solution for apps would be SOAP...
21:01:29 <allbery_b> er, for HAppS
21:01:47 <dons> glguy: i think reporting to the irc channel shouldn't be the default
21:01:52 <dons> you should have to click the button to send it
21:02:05 <hpaste>  nicolass pasted "test" at http://hpaste.org/117
21:02:12 <glguy> :-/
21:02:22 <jcreigh> SOAP? no need to get out the nukes. HTTP comes with GET and POST built-in. That's enough for simple things.
21:02:23 <dons> glguy: ah, did you enable the 'delete' feature?
21:02:27 <glguy> yeah
21:02:38 <reilly> by the way, sorry about the posts
21:02:45 <reilly> pastes
21:02:51 <dons> thats you?
21:03:00 <glguy> if that's you, do us a favor and check "silent"... :-/
21:03:01 <dons> its interesting to see how its being used
21:03:08 <dons> glguy: but silent should be the default
21:03:08 <glguy> dons?
21:03:29 <reilly> actually, the problem is that its an applescript and i'm having issues setting silent
21:03:29 <dons> glguy: so how do you delete?
21:03:33 <dons> you have an internal hook?
21:03:41 <dons> reilly: ah you're scripting it :)
21:03:43 <glguy> dons: /delete?password=1234?id=1234
21:03:45 <shapr> sorear: I haven't written the email sending example yet. I got distracted...
21:03:52 <glguy> the password is a random number generated at startup
21:04:00 <glguy> so there isn't a default password
21:04:13 <dons> ah so the host knows the passwd?
21:04:19 <glguy> yeah
21:04:24 <reilly> i made a context menu for my mac to let me post to pastebins with a ctrl-click
21:04:25 <dons> cool
21:04:30 <dons> reilly: ok. nice
21:04:39 <reilly> except for the problem with silen
21:04:42 <glguy> I didn't feel like writing something complicated
21:04:45 <dons> :)
21:04:57 <reilly> i'll direct it somewhere else for a bit
21:05:04 <dons> reilly: you got the api?
21:05:10 <dons> (also, you can run hpaste locally to test)
21:05:23 <reilly> good idea
21:06:03 <sorear> shapr: is the Happs worldview IRC compatible? (i.e is it worth trying)
21:06:21 <dons> sorear: i'm not sure it makes sense, does it?
21:06:25 <reilly> ?where hpaste
21:06:25 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
21:06:26 <dons> maybe it does
21:06:30 <reilly> ?src hpaste
21:06:31 <lambdabot> Source not found. You speak an infinite deal of nothing
21:06:41 <dons> the above is the src
21:07:15 <reilly> yeah, i realized
21:07:45 <dons> glguy: cheers
21:08:05 <glguy> take care
21:08:21 * glguy assumes that means "bye"
21:08:37 <dons> nah, it was thanks for adding 'announce'
21:08:42 <glguy> AH
21:10:34 <sorear> glguy: you delete reilly's pastes?
21:10:42 <glguy> yeah
21:10:48 <sorear> good
21:10:50 <reilly> dons: you pointed me at HsJudy, for which there doesn't seem to be a properly packaged recent version that builds with 6.6 (the most recent code is embedded in the pugs repo).  I'm happy to do that, but want to make sure I'm not wasting my time replicating
21:11:18 <sorear> observing @remember I thought happs might be suffering from data loss :)
21:11:24 <dons> i'm not aware of an updated version
21:11:41 <dons> reilly: but ask on #perl6 cmarcello might be there (the author)
21:11:55 <reilly> i'll send him an email
21:11:58 <glguy> dons: the thing about happs is... even if anyone could delete, we could always revert to a previous checkpoint :)
21:12:45 <sorear> dons: fps-readp just typechecked!
21:12:53 <glguy> in a year when the pastes file is 5 meg... and it creates a new checkpoint after every paste
21:13:03 <glguy> we are going to have to figure something else out...
21:13:09 * sorear jumps for joy
21:13:58 <sorear> fps-readp WORKS!  (first time, even)
21:14:19 <sorear> now to eradicate the use of B.(un)pack ...
21:18:28 <dons> glguy: yeah.
21:18:40 <dons> i say leave the everything on idsk 'cept the last 100
21:18:53 <dons> and load things not in theache on demad
21:18:57 <glguy> dons: will HAppS allow for that?
21:19:06 <glguy> or will we have to write our own backend
21:19:21 <dons> i'm sure we can work something out
21:19:29 <dons> its just code after all :)
21:20:51 <glguy> dons, does !say work for you?
21:22:42 <dons> agile up to the ears!
21:22:43 <dons> Subject: [Haskell-cafe] ANNOUNCE: DrIFT 2.2.1 - support for Data.Binary
21:22:44 <dons> DrIFT 2.2.1 is out and now has support for the Data.Binary module.
21:23:26 <xpika> what is Data.Binary?
21:23:33 <sjanssen> JohnMeacham blitzcode
21:24:19 <dons> xpika: its a binary serialisation library that was released about an hour ago
21:24:24 <dons> ?where binary
21:24:24 <lambdabot> http://darcs.haskell.org/binary
21:24:38 <dons> also on hackage
21:24:42 <dons> ?where hackage
21:24:43 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
21:25:00 <vegai> glguy: will every single checkpoint file be 5MB then?
21:25:16 <glguy> vegai: using the current save, I believe so
21:25:19 <dons> yeah, diffs would be better after some point
21:28:49 <vegai> using darcs as a backend? :P
21:31:13 * xpika downloads data.binary via darcs
21:32:31 <moconnor> dons: This typeOf script is nice.  Thank you!
21:40:21 <slowriot> are there any built in functions to convert a string into an array?
21:40:27 <sorear> yes
21:40:35 <jcreigh> "array" or "list"?
21:40:39 <sorear> > listArray (0,10) "Hello world"
21:40:41 <lambdabot>  array (0,10) [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'...
21:40:52 <jcreigh> > words "maybe you meant this?"
21:40:53 <lambdabot>  ["maybe","you","meant","this?"]
21:41:15 <slowriot> jcreigh... nope
21:41:37 <slowriot> ['i','m','e', ... I meant this
21:41:48 <sorear> read "array (0,10) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:41:51 <jcreigh> > ['a', 'b', 'c']
21:41:51 <sorear> > read "array (0,10) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:41:53 <lambdabot>  "abc"
21:41:54 <lambdabot>  Exception: (Array.!): undefined array element
21:42:00 <sorear> > read "array (0,7) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:42:02 <lambdabot>  Exception: (Array.!): undefined array element
21:42:03 <sorear> > read "array (0,5) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:42:05 <lambdabot>  Exception: Ix{Int}.index: Index (6) out of range ((0,5))
21:42:06 <jcreigh> slowriot: A string *is* a list of Char
21:42:07 <sorear> > read "array (0,6) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:42:09 <lambdabot>  array (0,6) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]
21:42:15 <sorear> arrays /= lists
21:42:27 <sorear> @src String
21:42:28 <lambdabot> type String = [Char]
21:43:25 <sorear> so that noone else is deceived ... why did you think they were different? /me has a feeling GHC's oh-so-clever synonym inference is involved
21:44:47 <slowriot> I did not mean the last thing I typed
21:44:56 <slowriot> not a list of chars... and array of chars
21:45:05 <slowriot> *an* array of chars
21:45:15 <sorear> slowriot: my first answer solves this
21:45:18 <sorear> > read "array (0,6) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]" :: Array Int Char
21:45:20 <lambdabot>  array (0,6) [(0,'O'),(1,'r'),(2,' '),(3,'t'),(4,'h'),(5,'i'),(6,'s')]
21:45:24 <sorear> wrong one sorry
21:45:27 <sorear> > listArray (0,10) "Hello world"
21:45:29 <lambdabot>  array (0,10) [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'...
21:45:32 <slowriot> okay, thanks sorear
21:46:08 <sorear> slowriot: you might also be interested in the GHC unboxed strings extension, "foo"# -> ptr to char
21:47:00 <shapr> sorear: Yeah, I think you could hack IRC support directly into HAppS with FromMessage
21:47:15 <slowriot> sorear: probably not neccessary for this particular problem, but I'll look into it anyway.
21:47:27 <slowriot> gotta go
21:47:28 <slowriot> later
21:47:31 <Procyon> slowriot: the numbers in the display of the array are indexes for clarity, not part of the structure.  just because it is displayed as (n,'c')... does NOT imply it is a list of tuples
21:47:44 <slowriot> okay, that's what I suspected
21:48:13 <sorear> slowriot: the only advantage of ""# is the one-time speed penalty of creating and destroying a [Char]
21:48:32 <slowriot> that's how Haskell "shows" arrays, huh?
21:48:35 <sorear> e.g. happy parsers can contain >10k string literals, and use ""# ...
21:48:38 <sorear> slowriot: yea.
21:48:54 <jcreigh> slowriot: yeah, so that you could "read" it in later if you wanted to.
21:48:56 <sorear> slowriot: Show should always produce valid haskell code as output - that's the general rule
21:49:40 <slowriot> so [(0,'a'),(1,'b')... is valid haskell code
21:49:52 <slowriot> how does haskell know whether it is an array or a list of pairs?
21:49:53 <sorear> but, yes, ANY_ARRAY ! n is O(1)  (modulo raving pedants)
21:50:00 <sorear> slowriot: the array
21:50:03 <sorear> :t array
21:50:05 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
21:50:20 <sorear> so array takes bounds and pairs, and makes an array
21:50:20 <slowriot> oh
21:50:25 <sorear> > listArray (0,10) "Hello world"
21:50:27 <lambdabot>  array (0,10) [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'...
21:50:36 <sorear> [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'...  is a list of pairs
21:50:41 <slowriot> okay, I see
21:50:42 <sorear> :t [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w')]
21:50:44 <lambdabot> forall a. (Num a) => [(a, Char)]
21:50:48 <sorear> :t array (0,6) [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w')]
21:50:50 <lambdabot> forall i. (Ix i, Num i) => Array i Char
21:50:55 <slowriot> show prepends array before the list notation
21:51:38 <sorear> exactly
21:52:19 <jcreigh> the hope is that (read . show) = id
21:52:25 <slowriot> thanks for the help, I'm going to hit the hay
21:52:32 <sorear> the hope is that (eval . show) = id
21:52:56 <jcreigh> sorear: copy/paste woes? :)
21:53:05 <allbery_b> it's not the same,
21:53:12 <allbery_b> look closely
21:53:29 <jcreigh> d'oh
21:53:31 <sorear> OK OK
21:53:36 <sorear> the hope is that (eval . show) = toDynamic
21:53:48 <sorear> happy now? :)
22:06:45 <sjanssen> @quote
22:06:46 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
22:07:21 <bd_> sorear: So we're hoping to solve the halting problem, is that it? :)
22:08:10 <sorear> ?
22:08:20 <sorear> inference /= proof obligation
22:08:26 <bd_> the toDynamic comment?
22:08:33 <bd_> when applied to function types anyway
22:08:37 <sorear> eval :: String -> Maybe Dynamic
22:08:48 <bd_> though I suppose one could dump whatever the compiler's internal state for a function is...
22:09:12 <sorear> seq 2 x == x for function types, that doesn't need halting...
22:09:32 <sorear> bd_: (->) a b is not an instance of Show!
22:09:44 <sorear> hence, non issue.
22:09:49 <bd_> But it can be an instance of Typeable :)
22:12:07 <sorear> @users
22:12:08 <lambdabot> Maximum users seen in #haskell: 322, currently: 285 (88.5%), active: 27 (9.5%)
22:15:07 <vincenz> sorear: sure of that?
22:15:14 <vincenz> > (undefined :: Char -> Bool)
22:15:15 <lambdabot>  <Char -> Bool>
22:15:25 <vincenz> > show (undefined :: Char -> Bool)
22:15:26 <lambdabot>  "<Char -> Bool>"
22:15:39 * sorear waves proof obligations at vincenz
22:16:07 <sorear> emphasis on obligations - ghc sits there stupidly when lambdabot defies them.
22:16:08 * vincenz opts out and puts on dynamic stock
22:17:38 <vincenz> @src Show
22:17:39 <lambdabot> class  Show a  where
22:17:39 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:17:39 <lambdabot>     show      :: a   -> String
22:17:39 <lambdabot>     showList  :: [a] -> ShowS
22:17:44 <vincenz> @instance
22:17:45 <lambdabot> Maybe you meant: instances instances-importing
22:17:55 <vincenz> @src Show (->)
22:17:55 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:17:59 <vincenz> @src Show (-> a b)
22:17:59 <lambdabot> Source not found. My pet ferret can type better than you!
22:18:03 <vincenz> @src Show (a -> b)
22:18:03 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:18:05 <vincenz> grr
22:18:25 <vincenz> @where
22:18:26 <lambdabot>  @where <key>, return element associated with key
22:18:29 <vincenz> @version
22:18:30 <nornagon> vincenz the rocket science.
22:18:30 <lambdabot> lambdabot 4p488, GHC 6.5 (OpenBSD i386)
22:18:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:18:34 <nornagon> er.
22:18:37 <nornagon> scientist.
22:18:38 <allbery_b> that's a lambdabot extension, not standard
22:18:43 <vincenz> uhuh
22:19:11 * allbery_b thinks a standard one should probably emit "(undefined :: type -> ...)" instead
22:23:55 <sorear> allbery_b: ooh?  referentially tranparent _|_ detection in show?  if you can manage that, expect legions of followers...
22:25:09 * sjanssen thinks that lambdabot should nix the Show instance, then capture the "no instance for Show (a -> b)" messages.  When such a message is detected, it should spit back the original code
22:26:43 <allbery_b> sorear: no, just pass back a parseable undefined for any functional value
22:26:54 <allbery_b> maybe toss in a {- lambda -} comment
22:28:08 <kolmodin> ?tell dons very nice announce letter! well done
22:28:08 <lambdabot> Consider it noted.
22:28:41 <Korollary> He should have mentioned portability heh
22:29:07 <Korollary> he made me read the docs!
22:29:35 <kolmodin> still good though :)
22:29:38 <vincenz> sjanssen: were you the one with th bf-interpreter in haskell?
22:29:48 <sjanssen> vincenz: nope
22:29:50 <sorear> that's easy!
22:29:53 <vincenz> hmm
22:29:55 <vincenz> samb then?
22:30:07 <sorear> vincenz: samb had a zmachine interp
22:30:16 <sorear> not the sparky one, no
22:30:17 <nornagon> bf interpreters are easy
22:30:21 <sorear> very
22:30:23 <nornagon> bf compilers are far more interesting
22:30:28 <nornagon> (but still easy)
22:30:33 <vincenz> easy
22:30:40 <vincenz> just map to the c-constructs
22:30:42 <bd_> nornagon: efficient unlambda compilers are more interesting ;)
22:30:42 <vincenz> and then call gcc
22:30:48 <nornagon> heh
22:30:53 <nornagon> that's cheating :P
22:30:55 <bd_> [good luck!]
22:30:58 * vincenz votes for an efficient compiler for lazy-k
22:31:12 <sorear> vincenz: just map to Haskell!
22:31:18 <vincenz> :D
22:31:43 <kolmodin> yeah, map it to a DSL in haskell :)
22:31:48 <sorear> vincenz: (apply fixtypes inference, then rewrite fixpoint combinators using explicit isorecursive nonsense)
22:32:20 <sorear> yes it is possible to infer a principal type for any lazy-k program
22:32:49 <vincenz> dunno
22:33:19 <vincenz> some progs won't be typeable
22:33:28 <sorear> eh?
22:33:46 <sorear> my infinite type inferer has no error conditions
22:34:03 <vincenz> ah righ
22:34:06 <vincenz> but haskell doesn't have that
22:34:10 <vincenz> and you said "map to haskell"
22:34:16 * vincenz raises his eyebrow
22:34:20 <vincenz> what about the equivalent of
22:34:31 <sorear> you'd need to type-infer then use isorecursive nonsense...
22:34:34 <vincenz> ((lambda (x) (x x x)) (lambda (x) (x x x))
22:34:38 <vincenz> )
22:35:20 <sorear> fix a. a -> a
22:35:29 <vincenz> nope
22:35:31 <sorear> you wanted a type, right?
22:35:35 <vincenz> no
22:35:38 <vincenz> I want a type-inference
22:36:20 <vincenz> I think you might have oversimplified it all
22:36:25 <vincenz> and now are reaching :)
22:38:23 * sorear is suspecting that higher rank inference may be needed
22:40:49 <vincenz> hmm
22:40:52 <vincenz> should've figured
22:40:54 <vincenz> tromp made it
22:41:01 <vincenz> which brings up the question, anyone seen tromp?
22:41:07 <sorear> @seen tromp
22:41:08 <lambdabot> I haven't seen tromp.
22:43:30 <xpika2> does anyone know a function [(a->b)] -> a -> b
22:44:03 <bd_> xpika2: that function is poorly defined
22:44:06 <mbishop> @hoogle [(a->b)] -> a -> b
22:44:08 <lambdabot> No matches, try a more general search
22:44:16 <bd_> the only possibly interpretation would be to pick some element of that list arbitrarily
22:44:19 <bd_> but which one?
22:44:28 <bd_> the first? the last? the third?
22:44:47 <xpika2> how about all of them
22:44:47 <bd_> @djinn (a -> b) -> a -> b
22:44:48 <lambdabot> f a = a
22:44:50 <bd_> xpika2: not possible
22:44:54 <nornagon> flip map
22:44:56 <bd_> xpika2: You only have one b being returned
22:44:57 <nornagon> :t flip map
22:44:59 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
22:45:10 <nornagon> hm.
22:45:15 <bd_> @djinn [(a->b)] -> a -> [b]
22:45:16 <nornagon> that's not what i was thinking of.
22:45:16 <lambdabot> -- f cannot be realized.
22:45:27 <nornagon> :t sequence
22:45:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
22:45:32 <bd_> :t \fl t -> map ($ t) fl
22:45:33 <vincenz> (((s ((s i) i)) i) ((s ((s i) i)) i))
22:45:34 <lambdabot> forall a b. [a -> b] -> a -> [b]
22:45:38 <bd_> :pl \fl t -> map ($ t) fl
22:45:40 <bd_> @pl \fl t -> map ($ t) fl
22:45:41 <lambdabot> flip (map . flip id)
22:46:01 <nornagon> :t id
22:46:02 <bd_> xpika2: anyway, if you meant [a -> b] -> a -> [b], you can use \fl t -> map ($ t) fl
22:46:03 <lambdabot> forall a. a -> a
22:46:03 <nornagon> :t flip id
22:46:05 <lambdabot> forall b c. b -> (b -> c) -> c
22:46:11 <nornagon> :t flip
22:46:12 <bd_> xpika2: if you really meant -> b... that's a very silly function
22:46:13 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
22:46:39 <nornagon> ah, id can be (b -> c) -> b -> c
22:46:43 <xpika2> i mean -> b yes
22:46:46 <nornagon> that makes sense now!
22:47:00 <bd_> xpika2: Then, well, the function really doesn't make much sense :/
22:47:07 <bd_> xpika2: it has to pick just one of the input list's functions
22:47:11 <bd_> and apply it to its second argument
22:47:13 <bd_> eg:
22:47:14 <xpika2> example
22:47:20 <bd_> :t \l a -> (head l) a
22:47:22 <lambdabot> forall t t1. [t -> t1] -> t -> t1
22:47:25 <bd_> :t \l a -> (last l) a
22:47:27 <lambdabot> forall t t1. [t -> t1] -> t -> t1
22:47:29 <bd_> :t \l a -> (l !! 47) a
22:47:31 <lambdabot> forall t t1. [t -> t1] -> t -> t1
22:47:37 <bd_> poorly specified :)
22:48:19 <Jaak> @type \(f:_) x -> f x -- wee
22:48:21 <lambdabot> forall t t1. [t -> t1] -> t -> t1
22:49:09 <bd_> xpika2: anyway, exactly which one is correct would depend on your situation.. in any case you'll be throwing away a lot of possibilities
22:49:23 <Jaak> @type ($) . head
22:49:25 <lambdabot> forall a b. [a -> b] -> a -> b
22:49:55 <xpika2> pipeline [(+1),(-2),(*3)] 4 == 9
22:50:09 <nornagon> uhm.
22:50:19 <nornagon> so you want [a -> a] -> a -> a
22:50:48 <xpika2> yep
22:51:04 <nornagon> this is distinctly different from [a -> b] -> a -> b
22:51:05 <bd_> :t foldr1 (.)
22:51:07 <lambdabot> forall c. [c -> c] -> c -> c
22:51:10 <Jaak> @type foldl (flip (.)) id
22:51:12 <lambdabot> forall a. [a -> a] -> a -> a
22:51:21 <bd_> > foldr1 (.) [(+1),(-2),(*3)] 4 == 9
22:51:23 <lambdabot>   add an instance declaration for (Num (a -> a))
22:51:23 <lambdabot>     In the list element: (- 2)
22:51:28 <bd_> > foldr1 (.) [(+1),(-2),(*3)] 4 == 9 :: Int
22:51:29 <lambdabot>  Couldn't match `Int' against `Bool'
22:51:32 <bd_> > foldr1 (.) [(+1),(-2),(*3)] 4 == (9 :: Int)
22:51:33 <lambdabot>   add an instance declaration for (Num (Int -> Int))
22:51:33 <lambdabot>     In the list element:...
22:51:36 <bd_> hmm
22:51:38 <Jaak> -2
22:51:42 <Jaak> subtract 2
22:51:45 <bd_> > foldr1 (.) [(+1),(-2),(*3)] id 4 == (9 :: Int)
22:51:46 <lambdabot>   add an instance declaration for (Num (Int -> Int))
22:51:50 <bd_> :/
22:51:52 <bd_> oh
22:51:56 <xpika2> > foldr1 (.) [(+1),( subtract 2),(*3)] id 4 == (9 :: Int)
22:51:56 <lambdabot>   add an instance declaration for (Num (Int -> Int))
22:51:57 <bd_> > foldr1 (.) [(+1),(subtract 2),(*3)] 4 == (9 :: Int)
22:51:59 <lambdabot>  False
22:52:02 <bd_> > foldr1 (.) [(+1),(subtract 2),(*3)] 4
22:52:04 <lambdabot>  11
22:52:07 <bd_> > foldl1 (.) [(+1),(subtract 2),(*3)] 4
22:52:09 <lambdabot>  11
22:52:14 <nornagon> flip .
22:52:16 <Jaak> > foldl (flip (.)) id [(+1),(subtract 2),(*3)] 4
22:52:17 <lambdabot>  9
22:52:18 <xpika2> > foldr1 (.) [(+1),(subtract 2),(*3)] 4
22:52:20 <lambdabot>  11
22:52:52 <nornagon> > foldr1 (flip (.)) [(+1),(*3)] 4
22:52:54 <lambdabot>  15
22:53:19 <nornagon> > foldr1 (flip (.)) [(+1),(subtract 2)(*3)] 4
22:53:20 <nornagon> er
22:53:20 <lambdabot>   add an instance declaration for (Num (c -> c))
22:53:23 <nornagon> > foldr1 (flip (.)) [(+1),(subtract 2),(*3)] 4
22:53:24 <lambdabot>  9
22:54:16 <AStorm> > map 4 [(+1),(subtract 2),(*3)]
22:54:16 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
22:54:27 <AStorm> > map .4 [(+1),(subtract 2),(*3)]
22:54:28 <lambdabot>   add an instance declaration for (Num ([a2 -> a2] -> a1 -> a -> b))
22:54:34 <AStorm> :/
22:54:43 <nornagon> >map ($ 4) [(+1),(subtract 2),(*3)]
22:54:49 <nornagon> > map ($ 4) [(+1),(subtract 2),(*3)]
22:54:51 <lambdabot>  [5,2,12]
22:54:58 <AStorm> Ah, right. Application :P
22:55:16 <nornagon> > map ($ 4) [(+1),(2-),(*3)]
22:55:18 <lambdabot>  [5,-2,12]
22:55:36 <nornagon> > foldr1 (flip (.)) [(+1),(2-),(*3)] 4
22:55:38 <lambdabot>  -9
22:55:42 <sorear> night all
22:55:43 <nornagon> > foldr1 (flip (.)) [(+1),(-2),(*3)] 4
22:55:45 <lambdabot>   add an instance declaration for (Num (c -> c))
22:55:45 <lambdabot>     In the list element: (- 2)
22:55:54 <dons> more code!
22:55:54 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
22:55:56 <nornagon> :t ((-)2)
22:55:58 <lambdabot> forall a. (Num a) => a -> a
22:56:04 <nornagon> > foldr1 (flip (.)) [(+1),((-)2),(*3)] 4
22:56:06 <lambdabot>  -9
22:56:12 <AStorm> > foldr1 . map ($ 4) [(+1),(subtract 2),(*3)] 4
22:56:13 <lambdabot>      The function `map' is applied to three arguments,
22:56:13 <lambdabot>     but its type `(a -...
22:56:20 <AStorm> > (foldr1 . map) ($ 4) [(+1),(subtract 2),(*3)] 4
22:56:21 <lambdabot>  Couldn't match `[a] -> [a]' against `[b]'
22:56:32 <AStorm> > (foldr1 (map .) ($ 4) [(+1),(subtract 2),(*3)] 4
22:56:32 <lambdabot>  Parse error
22:56:38 <AStorm> > (foldr1 (map .)) ($ 4) [(+1),(subtract 2),(*3)] 4
22:56:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1 -> b
22:56:39 <lambdabot>      ...
22:56:42 <AStorm> Blah.
22:56:57 <AStorm> Probably wrong order, eh?
22:56:58 <sorear> do per-user quotas sound good? :)
22:57:08 <nornagon> for what?
22:57:11 <AStorm> ?unpl foldr1 (flip (.))
22:57:11 <lambdabot> foldr1 (\ b c f -> c (b f))
22:57:13 <sorear> the bot
22:57:15 <xpika2> lambda computations
22:57:20 <nornagon> oh. no. :(
22:57:26 <AStorm> There are some already.
22:57:32 <dons> nah, social mechanisms work better
22:57:40 <xpika2> 20 s of cpu time per ip per day
22:57:50 <AStorm> xpika2, much too little.
22:57:54 <dons> i think i might up the cpu time limit though
22:58:05 * sorear has wedged the bot at 100%CPU for hours
22:58:13 <dons> how?
22:58:19 <xpika2> thanks sorear
22:58:32 <sorear> xpika2: ?
22:58:38 <nornagon> maybe we should have a #interactive-haskell channel which is solely for bot use and seeing how other people look at problems :)
22:58:40 <dons> actually, 14M   13M sleep    poll     0:03  0.00% lambdabot :}
22:58:43 <xpika2> all the time the bot has been down
22:58:51 <dons> nornagon: that's #haskell-overflow
22:58:52 <xpika2> at least i know it was a good cause
22:58:54 <sorear> dons: hint: ffi, posix
22:58:59 <AStorm> :/
22:59:00 <dons> ah yes
22:59:05 <Jaak> > tail $ (flip (scanl (flip ($)))) [(+1),(subtract 2),(*3)] 4
22:59:07 <lambdabot>  [5,3,9]
22:59:18 <AStorm> Hmm, lambdabot doesn't respond to /msg anymore?
22:59:27 <sorear> AStorm: it does
22:59:27 <dons> sorear: can you add a note into the src so I can remember tis
22:59:44 <nornagon> > last $ (flip (scanl (flip ($)))) [(+1),(subtract 2),(*3)] 4
22:59:45 <lambdabot>  9
22:59:46 <AStorm> Ok, just that : doesn't work there
22:59:47 <sorear> dons: sure.
23:00:00 <nornagon> ?unpl last $ (flip (scanl (flip ($))))
23:00:01 <lambdabot> (last (\ b c -> scanl (\ e f -> f e) c b))
23:02:03 <sorear> night all
23:02:26 <AStorm> ?pl (last (\ b c -> scanl (\ e f -> f e) c b))
23:02:26 <lambdabot> last (flip (scanl (flip id)))
23:02:39 <AStorm> Less parens! :-)
23:02:54 <sorear> last$flip$scanl$flip$id ?
23:02:59 <sorear> :t last$flip$scanl$flip$id
23:03:01 <lambdabot>     Couldn't match `[a]' against `[c -> c] -> c -> [c]'
23:03:02 <lambdabot>       Expected type: [a]
23:03:46 <AStorm> :t last$flip$scanl$flip id
23:03:48 <lambdabot>     Couldn't match `[a]' against `[c -> c] -> c -> [c]'
23:03:48 <lambdabot>       Expected type: [a]
23:03:52 <AStorm> Hmm...
23:03:54 <sorear> User halted.
23:05:01 <Jaak> @type flip $ scanl $ flip ($)
23:05:07 <lambdabot> forall b. [b -> b] -> b -> [b]
23:05:43 <xpika2> @let pipeline fs x = (foldl1 (.) fs) x
23:05:45 <lambdabot> Defined.
23:06:11 <Jaak> > pipeline [(+1),(subtract 2),(*3)] 4
23:06:14 <nornagon> @hoogle [a] -> ([a],[a])
23:06:15 <lambdabot>  11
23:06:17 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
23:06:19 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
23:06:23 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
23:06:28 <xpika2> > L.pipeline ((+1):(replicate 8 (*2))) 2
23:06:30 <lambdabot>  513
23:06:34 <nornagon> @src break
23:06:37 <lambdabot> break p =  span (not . p)
23:06:47 <nornagon> :t span
23:06:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:07:28 <nornagon> is there a function that will let my turn "abcd efgh ijkl" into ("abcd","efgh ijkl") ?
23:07:32 <nornagon> s/my/me
23:07:54 <AStorm> Wil pipeline be faster than this?
23:08:33 <AStorm> > sum $ (flip map) [(+1),(subtract 2),(*3)] ($ 4)
23:08:35 <lambdabot>  19
23:08:43 <AStorm> Ah, wrong! :P
23:08:46 <AStorm> Bad me.
23:08:52 <nornagon> last.
23:09:05 <AStorm> > last $ (flip map) [(+1),(subtract 2),(*3)] ($ 4)
23:09:07 <lambdabot>  12
23:09:13 <nornagon> i think pipeline would be faster.
23:09:23 <AStorm> That is actually 4*3 :P
23:09:30 <nornagon> o yeah :P
23:09:50 <nornagon> guess you broke it.
23:10:24 <AStorm> Yes, pipeline looks nice.
23:10:31 <AStorm> There's probably no better way.
23:10:42 <xpika2> > L.pipeline ( reverse [(+1),(subtract 2),(*3)] ) 4
23:10:44 <lambdabot>  9
23:10:45 <xpika2> tada
23:12:44 <pstickne> the haskell-guy in my discrete math class said that Haskell types are turing-complete? what exactly does this mean?
23:12:54 <Jaak> why not just use: pipeline = foldl (flip (.)) id
23:13:47 <Korollary> pstickne: he may have said some of GHC's type system extensions result in a TC typechecker.
23:15:37 <AStorm> It is Turing-complete - you can do all Turing machine computations with it. E.g. in unary :P
23:15:54 <xpika2> @let pipeline = foldl (flip (.)) id
23:15:55 <AStorm> (except it doesn't support infinite memory)
23:15:55 <lambdabot> <local>:9:0: Varying number of arguments for function `pipeline'
23:16:07 <xpika2> @let pipeline = foldl (flip (.))
23:16:09 <lambdabot> <local>:9:0: Varying number of arguments for function `pipeline'
23:16:26 <xpika2> @undef pipeline
23:16:28 <lambdabot> Undefined.
23:16:30 <xpika2> @let pipeline = foldl (flip (.))
23:16:32 <lambdabot> Defined.
23:16:41 <xpika2> > L.pipeline [(+1),(subtract 2),(*3)]  4
23:16:42 <lambdabot>  Couldn't match `a -> c' against `[a1]'
23:16:56 <base_16> :t random
23:16:57 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
23:17:33 <AStorm> pstickne, it's for crazy people and scientists
23:18:04 <xpika2> :S
23:21:04 <xpika2> @let pipeline = foldl1 (.)
23:21:05 <lambdabot> <local>:2:0:     Multiple declarations of `L.pipeline'     Declared at: <loca...
23:21:13 <xpika2> @undef pipeline
23:21:15 <lambdabot> Undefined.
23:21:16 <xpika2> @let pipeline = foldl1 (.)
23:21:18 <lambdabot> Defined.
23:21:31 <AStorm> xpika2, that won't work probably
23:22:08 <xpika2> > L.pipeline ( reverse [(+1),(subtract 2),(*3)] ) 4
23:22:10 <lambdabot>  9
23:22:13 <xpika2> hm
23:22:18 <pstickne> Korollary, no, he said haskell type inference was turing complete. I take it that statement is false?
23:22:35 <AStorm> It is true.
23:23:25 <pstickne> What does that mean/imply?
23:23:45 <AStorm> Check out kolmodin's work on Google :P
23:24:10 <Korollary> Type inference is an algorithm. How would that be TC?
23:25:27 * shapr fights the wiki markup
23:26:15 <shapr> Is there something like <code></code> tags that works for all the lines in the region? It seems that <code> does not work across lines, while <haskell> does, but I'm putting in XSLT.
23:26:19 <AStorm> Korollary, probably he meant type system, not type inference itself
23:33:41 <Korollary> Yay
23:35:10 <dons> pstickne: it is possible to implement a lambda calculus evaluator using type declarations only, that evaluates terms in the typechecker, at compile time
23:35:32 <dons> the type system is turing complete, with the correct extensions (various extensions may be used)
23:35:44 <dons> essentially you end up with prolog
23:35:50 <dons> running in the type checker
23:36:28 <pstickne> what does turing complete imply? I've tried reading though wikipedia and such but it just confuses me more
23:36:29 <dons> (perhaps this is what we mean by an 'expressive' static type system :)
23:36:42 <dons> @foldoc turing complete
23:36:46 <lambdabot> *** "turing" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:36:46 <lambdabot> Turing
23:36:46 <lambdabot>  
23:36:46 <lambdabot>         1. {Alan Turing}.
23:36:46 <lambdabot>  
23:36:48 <lambdabot> [28 @more lines]
23:36:49 <kolmodin> AStorm: my work on what? :)
23:36:52 <dons> check foldoc.
23:37:08 <pstickne> ooh.
23:37:17 <dons> basically, those problems that are computable, are computable on a turing machine
23:37:56 <kolmodin> dons: nice announcement!
23:38:03 <dons> cheers. :) it was fun to write!
23:38:24 <Adamant> there are theories about creating hypercomputers that will compute things discrete computers can't
23:38:47 <kolmodin> DriFT supports Binary now too, nice indeed
23:38:51 <Korollary> What's a hypercomputer?
23:38:53 <Adamant> but who knows if they will ever find the right things to build one
23:39:15 <dons> pstickne: here's a lambda calculus interpreter that runs in the type checker, http://haskell.org/haskellwiki/Type_arithmetic#A_Really_Advanced_Example_:_Type-Level_Lambda_Calculus
23:39:18 <lambdabot> Title: Type arithmetic - HaskellWiki, http://tinyurl.com/2cvjlr
23:39:40 <dons> for example, asking for the type of: > :t undefined :: Eval (App (Lam X) X) u => u
23:39:45 <dons> runs the type inference machinery,
23:39:47 <dons> yielding the type:
23:39:52 <Adamant> Korollary, in theory, a computer that could operate on Real values without using discrete approximation would be a hypercomputer
23:39:52 <dons> undefined :: Eval (App (Lam X) X) u => u :: X
23:40:09 <dons> so (\x -> x) x reduces to x
23:40:19 <Adamant> it's all theory at this point, nobody knows of a physical phenomena that will work to produce it.
23:41:06 <Adamant> !wiki hypercomputing
23:41:45 <Adamant> http://en.wikipedia.org/wiki/Hypercomputation
23:41:49 <pstickne> dons, this is why haskell is so mysterious to me. everything is explained in some notion I can't understand :(
23:44:10 <CloudiDust> Knowing little about Lambda Calculus, I wonder how we express the concept of floating numbers in that system? Church Numbers are only integers.
23:44:27 <shapr> pstickne: In my opinion, Haskell is a thin but significant layer on top of lambda calculus. It's worth understanding both of them :-)
23:44:50 <shapr> CloudiDust: You could always use IEEE754 representations!
23:45:15 <opqdonut> CloudiDust: constructing them in lambda calculus is an interesting problem but hardly relevant
23:45:20 <CloudiDust> Oh :)
23:45:22 <pstickne> shapr, I wonder if it'll be covered in this class at all.
23:45:25 <opqdonut> haskell is based on typed lambda calculus after all
23:45:31 <shapr> Oh, what class are you taking?
23:45:38 <pstickne> discrete math.
23:45:45 <shapr> pstickne: I had a CS class once a gazillion years ago.
23:45:53 <Korollary> pstickne: You don't need to know about turing computability to learn and use haskell.
23:46:13 <shapr> Yeah, all that theory stuff is nice, but you can write useful programs without it.
23:46:20 <pstickne> none of the CS classes here (100-200 level) have anything relevant with calculus :(
23:46:27 <shapr> Take me for example, I'm completely uneducated.
23:46:29 * shapr grins
23:47:00 <shapr> 'Calculus' in computer science usually just refers to a particular system of rules that does something significant.
23:47:15 <shapr> So you could also just call the lambda widget interpreter if you really wanted to.
23:47:43 <shapr> Nobody would know what you're talking about, but that's the goal of serious CS geeks anyway, right? To befuddle all listeners in casual conversation?
23:47:59 <Korollary> chicks dig it
23:48:01 <nornagon> i manage that without trying :(
23:48:05 <nornagon> Korollary: they do?!
23:48:08 <shapr> nornagon: heh, me too
23:49:07 <shapr> I think I was recently complaining at someone because their problem solving heuristic didn't terminate. They didn't care, they already had a system in place for deciding which movie to watch.
23:49:34 <nornagon> i've been thinking about Gdel's incompleteness theorem recently
23:49:38 <nornagon> it's troubling :(
23:49:48 <sieni> nornagon: why?
23:49:52 <shapr> pstickne: Anyway, lambda calculus has .... something like three pieces total.
23:49:52 <Korollary> nornagon: I've just found a complete proof of it.
23:50:05 <sieni> nornagon: how can a theorem be troubling?
23:50:13 <shapr> abstraction, reduction, and ...
23:50:21 <shapr> application, I think.
23:50:38 <nornagon> sieni: because it means maths is inconsistent (or incomplete)
23:50:54 <shapr> nornagon: What, you want to live in a perfect world?
23:51:08 <opqdonut> nornagon: i think it is very relieving
23:51:12 <opqdonut> math will never end
23:51:15 <nornagon> i'm waiting for the video of patrykz's talk to go up: http://lca2007.linux.org.au/talk/215
23:51:17 <lambdabot> Title: Computers, Programs and Logic: What Does Linux Prove? - linux.conf.au 2007
23:51:20 <dons> pstickne: hmm, any programming language or computability clases ?
23:51:26 <shapr> Gdel's incompleteness theorem supports my belief in free will.
23:51:40 <therp> does anyone know the person that's responsible for planet.haskell.org?
23:51:44 <sieni> shapr: good one
23:51:45 <nornagon> shapr: i'm a determinist :P
23:51:45 <Korollary> what does that have to do with free will
23:51:49 <shapr> therp: that would be ibid
23:51:56 <opqdonut> i wonder too
23:52:01 <sieni> shapr: not the existence of god, however?
23:52:07 <shapr> sieni: Oh that too.
23:52:11 <opqdonut> ok
23:52:13 <opqdonut> np
23:52:16 <sieni> shapr: yeah, right
23:52:31 <therp> shapr: ah thanks. xchat should really have a function to search in the list of  real names in joined channels..
23:52:35 <shapr> But I don't need any other supports for my belief in God, so I hadn't really thought about that specifically.
23:53:01 <opqdonut> lets not drag this into a religious flamewar ok
23:53:09 <shapr> No flamewar intended!
23:53:15 <sieni> shapr: why do you need a belief in free will or a god?
23:53:23 <opqdonut> yeah i believe you, but i'm suspecting sieni
23:53:29 <nornagon> um.
23:53:30 <arcatan> I don't really understand Gdel's theorem, but somehow it feels very intuitive
23:53:31 <nornagon> oh dear.
23:53:33 <Korollary> This is why God created #haskell-blah. Sorry, it was boegel.
23:53:35 <therp> W.r.t. to God: Haskell must be product of "Intelligent Design". Such things don't just happen.
23:53:36 <shapr> Hm, I don't know if I need beliefs at all, but I sure have 'em =)
23:53:44 * nornagon runs away.
23:53:56 <opqdonut> nornagon: you created a monster :P
23:53:58 <pstickne> dons, they teach BS classes here like intro to C and Java and such. the CSE classes aren't much better.
23:53:59 <nornagon> :((((
23:54:12 <Korollary> nornagon: I can't watch that feed, dude.
23:54:17 <shapr> pstickne: Was that Bachelor of Science classes? =)
23:54:25 <nornagon> Korollary: that's 'cause it's not up yet :P
23:54:34 <pstickne> shapr, just going to a 2year atm
23:54:36 <nornagon> it should be up by sunday, hopefully.
23:54:46 <nornagon> (the lca encoders are hard at work.)
23:54:49 <Korollary> nornagon: oh. I somehow read it wrong. Sorry.
23:55:08 <pstickne> but come fall I can transfer as a Junior to a 4 year for CS. whoohoo! debt, here I come!
23:55:27 <shapr> pstickne: Who is this Haskell guy in your discrete math class anyway? A teacher or a fellow student?
23:56:04 <pstickne> a student. he's kind of cocky. he's a die-hard Haskell-ftw-zealot.
23:56:13 <pstickne> but we agree on PHP sucking so he's not all bad ;)
23:56:18 <vegai> "intro to C" would be actually useful
23:56:31 <pstickne> vegai, if you've never programming in C before in your life...
23:56:36 <pstickne> *programmed
23:56:51 <shapr> pstickne: You could always take my approach and skip formal education entirely. I have no debt. But I'm 35 and I also have no real possessions or other equity. My approach is not for everyone ;-)
23:56:51 <pstickne> vegai, it's more like an intro-to-programming-in-C
23:57:02 <vegai> if the teacher is good enough, he can teach 20-year-olds something they didn't know
23:57:12 <vegai> ah, well..
23:57:16 <pstickne> shapr, I like being in school.
23:57:26 <shapr> pstickne: Well who is he? In Oregon? It's possible I know him...
23:57:46 <vegai> it's possible he's on this channel :P
23:57:50 <pstickne> possibly ;)
23:57:54 <shapr> Yeah, buncha OR people here.
23:58:04 <shapr> Could it be Jason Dagit?
23:58:11 <Korollary> Jason is outta school
23:58:12 <shapr> Hm, he's probably past discrete math...
23:58:14 <shapr> Yeah
23:58:17 <pstickne> I'm such an ass. I don't even remember his name.
23:58:27 <shapr> pstickne: You were focussing on learning ;-)
23:58:49 <pstickne> shapr, actually, I was focusing on Gena, the girl to my immediate ri... err, learning.
23:58:54 * shapr laughs!
23:59:16 <shapr> I went to college for several years (not in computer science) and I spent a lot of time with women from other countries.
23:59:24 <Korollary> nothing like focus-worthy ladies in discrete math classes
23:59:36 <shapr> Actually, I still spend time with a woman from another country.
