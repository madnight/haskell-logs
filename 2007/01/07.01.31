00:02:56 <abz> Donner: Thanks. I think I'll use this map (map (deFA (\x y -> (x,value y))) . deFL id) cSQ
00:03:25 <dons> > (exp 1) ** pi - pi
00:03:27 <lambdabot>  19.99909997918947
00:03:41 <allbery_b> spot the xkcd reader :)
00:03:52 <dons> ;)
00:08:00 <Cale> > exp pi - pi
00:08:02 <lambdabot>  19.999099979189474
00:08:15 <Cale> > exp (pi * sqrt 163)
00:08:17 <lambdabot>  2.6253741264076826e17
00:10:06 <Cale> > exp (pi * sqrt 163) - floor (exp pi * sqrt 163)
00:10:08 <lambdabot>  Add a type signature
00:10:19 <Cale> > exp (pi * sqrt 163) - fromIntegral (floor (exp pi * sqrt 163))
00:10:20 <lambdabot>  2.6253741264076797e17
00:10:47 <Cale> > fromIntegral (floor (exp pi * sqrt 163))
00:10:49 <lambdabot>  295
00:11:08 <Cale> > floor (exp pi * sqrt 163)
00:11:09 <dons> > (exp pi * sqrt 163)
00:11:11 <lambdabot>  295
00:11:11 <lambdabot>  295.4405859907143
00:11:17 <Cale> > floor (exp (pi * sqrt 163))
00:11:19 <lambdabot>  262537412640768256
00:11:20 <dons> um
00:11:22 <Cale> oh, silly of me :)
00:11:29 <Cale> > exp (pi * sqrt 163) - fromIntegral (floor (exp (pi * sqrt 163)))
00:11:30 <dons> ah
00:11:31 <lambdabot>  0.0
00:11:34 <Cale> haha
00:13:37 <Cale> % N[Exp[Pi * Sqrt[163]] - Floor[Exp[Pi * Sqrt[163]]],50]
00:13:39 <mbot> Cale: 0.9999999999992500725971981856888793538563373369908627075374103782107`50.
00:13:53 <dons> ?keal
00:13:54 <mbot> actually it bug in math
00:13:54 <lambdabot> ghc need to have plugin that allow copy paste in xp
00:13:57 <dons> ha!
00:14:23 <Cale> mbot: @part #haskell
00:14:28 <dons> what's the `50 ?
00:14:58 <nmessenger> 50 digits of precision?
00:15:14 <dons> > length "9999999999992500725971981856888793538563373369908627075374103782107"
00:15:16 <lambdabot>  67
00:15:24 <dons> > length "2500725971981856888793538563373369908627075374103782107""
00:15:25 <lambdabot>  Improperly terminated string
00:15:26 <dons> > length "2500725971981856888793538563373369908627075374103782107"
00:15:27 <lambdabot>  55
00:15:32 <Cale> nmessenger: right
00:15:48 <Cale> Only 50 of the digits are guaranteed correct
00:15:56 <dons> nice
00:16:01 <Cale> It'll print more, the way I have it set up though.
00:16:50 <dons> > exp (pi * sqrt 163) - fromIntegral $ floor (expr (pi * sqrt 163))
00:16:51 <lambdabot>   Not in scope: `expr'
00:16:57 <dons> > exp (pi * sqrt 163) - fromIntegral $ floor (exp (pi * sqrt 163))
00:16:58 <lambdabot>   add an instance declaration for (Floating (b1 -> b))
00:17:22 <dons> > exp (pi * sqrt 163) - fromIntegral (floor (exp (pi * sqrt 163)))
00:17:23 <lambdabot>  0.0
00:17:27 <allbery_b> yay.  rebuilt ghc-6.7 doesn't get a memory error.  and warns about the dd export
00:17:31 <allbery_b> odd export
00:17:52 <allbery_b> (ging back to the orignal reason I started this --- import a module qualified, how do you re-export?)
00:18:04 <allbery_b> someone was asking that yesterday afternoon
00:19:11 <Cale> dons: complete rounding error :)
00:19:25 <dons> uh hu
00:19:28 <Cale> the floor is off by 1
00:19:33 <vincent_> if someone has some time to spare for a newbie question: http://hpaste.org/213
00:19:43 <dons> ?keal
00:19:44 <lambdabot> are you saying i am MegaMonad?
00:19:54 <dons> ?quote FPU
00:19:54 <lambdabot> No quotes match. Are you on drugs?
00:20:03 <Cale> vincent_: what's the question?
00:20:11 <Cale> er
00:20:14 <ozone> ?quote dons
00:20:14 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
00:20:15 <lambdabot> true functional programming), and you've got haskell
00:20:17 <vincent_> well, i'd like to build array values incrementally
00:20:24 <Cale> vincent_: you know that // takes a list of updates, right?
00:20:34 <vincent_> yes, i'm using that
00:20:53 <vincent_> but it's very slow
00:20:58 <Cale> vincent_: you're using the foldr instead?
00:21:04 <vincent_> i guess because it's building lot's of array copies
00:21:07 <ozone> ?quote Pseudonym
00:21:07 <lambdabot> Pseudonym says: A meeting will kill almost any good idea.
00:21:20 <vincent_> well, i'm doing a foldr with my incremental function
00:21:28 <vincent_> on the range of array indices
00:21:40 <Cale> yeah, rather than build a list of the updates you want to make and applying them all at once with //
00:21:50 <vincent_> ahh
00:21:53 <vincent_> right
00:22:24 <vincent_> i was very pleasantly surprised the memory usage of the code scales linearly
00:22:31 <vincent_> couldn't say the same for CPU time though ;-)
00:22:36 <vincent_> i'll try your suggestion
00:22:39 <vincent_> thanks very much
00:22:44 <Cale> no problem
00:23:09 <Cale> also, you might try unboxing the arrays if possible
00:23:17 <vincent_> unboxing?
00:23:30 <Cale> Data.Array.Unboxed
00:23:45 <vincent_> kk thanks, will read up on that ;-)
00:23:51 <dons> instead of the boxed, lazy default Array
00:23:52 <Cale> it has the same interface, all you have to do is set the type signature to UArray instead of Array
00:24:18 <Cale> Also, DiffArrays are pretty magical, when used in the right places.
00:24:23 <Cale> They also have the same interface, all you do is change the type.
00:24:27 <astrolabe> I thought it sounded like a job for diffArray
00:24:55 <Cale> DiffArrays allow for O(1) updates and O(1) lookup when used in a linear fashion.
00:24:58 <astrolabe> Ah damn lag :)
00:25:39 <vincent_> Unboxed: Unboxed immutable arrays.
00:25:46 <vincent_> will that support incremental updates?
00:25:56 <Cale> yes, it'll work the same as Data.Array
00:26:04 <Cale> which is boxed immutable arrays
00:26:13 <Cale> Note that // is creating a new array
00:26:28 <vincent_> ok -- ;-)
00:26:29 <Cale> DiffArrays have a magical //
00:26:58 <vincent_> DiffArray sound like just what i need.
00:27:10 <vincent_> thanks again -- i'll be fiddling with those two suggestions
00:27:48 <dons> vincent_: are you vincentk ? :)
00:28:07 <Cale> If d is a DiffArray, then evaluating (d // xs) will mutate the array, and relink d such that it becomes a structure with a list of reverse updates to the current copy.
00:28:35 <Cale> So you get updates in O(length xs) time.
00:28:47 <vincent_> yes
00:28:50 <Cale> (and without creating a copy)
00:29:02 <dons> vincent_: welcome!
00:29:08 <vincent_> thanks!
00:29:17 <vincent_> trying to refit the google thing from python to haskell
00:29:23 <vincent_> should be a nice fit
00:29:38 <vincent_> and give me a good exercise to start with ;-)
00:30:06 <dons> :)
00:30:19 <astrolabe> So, how // on a normal array work? Is the original array stored together with a list of updates which has to be re-traversed every time the array is read?
00:30:55 <Cale> a // xs will create a copy of the array with the given modifications made to it.
00:31:10 <astrolabe> Cale: thanks
00:31:31 <Cale> Which is why you really do want to build up a larger list of updates if you can.
00:32:06 <Cale> (rather than making the updates one at a time)
00:39:57 <vincent_> hmm. DiffArray seems to live in the IO monad... i might be asking for the impossible, but is there something like it that does not? (a plain NO is a sufficient answer)
00:40:56 <rahikkala> Isn't the interface to DiffArray purely functional, though?
00:41:38 <vincent_> Module Data.Array.IArray provides the interface of diff arrays. They are instances of class IArray.
00:41:40 <vincent_> but
00:41:52 <dons> I thought it was pure?
00:42:08 <vincent_> newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
00:42:16 <vincent_> maybe i'm just not getting it?
00:42:20 <dons> ah, its in IO
00:42:30 <dons> at least the construction
00:42:37 <vincent_> yes ;-:
00:42:45 <dons> ah well.
00:43:08 <ozone> unsafePerformIO to the rescure!
00:44:20 <astrolabe> DiffArray is pure as far as the user is concerned though
00:44:24 <vincent_> i was somehow hoping that when i fold increments over an array, ghc would magically understand that the intermediate copies are not required ...
00:44:55 <astrolabe> vincent: I really think diffArray sounds like what you want
00:44:57 <rahikkala> > (array (0,10) [(x, x) | x <- [0..10]]) :: DiffArray Int Int
00:44:58 <lambdabot>   Not in scope: type constructor or class `DiffArray'
00:45:17 <astrolabe> @hoogle diffArray
00:45:18 <lambdabot> Data.Array.Diff.DiffArray :: type DiffArray
00:45:18 <lambdabot> Data.Array.Diff.IOToDiffArray :: data IOToDiffArray a i e
00:45:18 <lambdabot> Data.Array.Diff.newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
00:45:33 <vincent_> astrolabe : yes, thanks
00:45:47 <astrolabe> hmmm I've used it without needing IO before
00:46:21 <vincent_> i'm sure i can get it to work, i'd just like it to work _nicely_, since it will serve as my starting point for future dabblings ;-)
00:47:10 <nmessenger> > (Data.Array.Diff.array (0,10) [(x, x) | x <- [0..10]]) :: Data.Array.Diff.DiffArray Int Int
00:47:10 <lambdabot>   Not in scope: type constructor or class `Data.Array.Diff.DiffArray'
00:47:36 <nmessenger> @type Data.Array.Diff.array
00:47:38 <lambdabot> forall e i (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [(i, e)] -> a i e
00:47:45 <astrolabe> vincent: it worked really nicely
00:48:07 <nmessenger> @instances Data.Array.Base.IArray
00:48:16 <dons> ah yes, the instances
00:48:19 <vincent_> i have no doubts about that, i just don't know yet how to do it ;-)
00:48:20 <astrolabe> vincent: I used it just like a normal array iirc but said DiffArray in the type signature
00:48:41 <dons> vincent_: yeah, just the normal array api should work on DiffArrays
00:48:51 <astrolabe> I can't see how it could have worked now though
00:49:03 <vincent_> (Data.Array.Diff.DiffArray (0,10) [(x, x) | x <- [0..10]])
00:49:22 <vincent_> > (Data.Array.Diff.DiffArray (0,10) [(x, x) | x <- [0..10]])
00:49:23 <lambdabot>   Not in scope: data constructor `Data.Array.Diff.DiffArray'
00:49:36 <nmessenger> DiffArray looks to be a class, @instances didn't do nothing
00:49:40 <vincent_> lol, this is cute
00:50:37 <allbery_b> suDiffArray is a synonym
00:50:40 <allbery_b> oops
00:50:55 <allbery_b> <lambdabot> Data.Array.Diff.DiffArray :: type DiffArray
00:51:32 <nmessenger> oops, 'IArray' is the class
00:57:01 <nmessenger> @where+ imports http://www.cse.unsw.edu.au/~dons/lambdabot/State/Pristine.hs
00:57:01 <lambdabot> Done.
00:57:10 <nmessenger> 'cause I always forget
00:57:15 <dons> :)
01:09:36 <abz> dons: have you got restrictions on who, and what, people can add to lambdabot?
01:10:15 <dons> a) no, b) yes
01:10:26 <dons> "good things from anyone" is the policy :)
01:10:41 <dons> with a bias towards haskell productivity tools
01:11:44 <ozone> even from me?
01:12:13 <abz> mmm... I think I'm going to have to have a look at the code. I've always wanted to write an IRC bot.
01:12:14 <dons> well, ok, not just anyone
01:12:22 <dons> abz there's a tutorial!
01:12:28 <dons> ?google roll your own irc bot
01:12:29 <abz> really.
01:12:30 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:12:30 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
01:12:34 <dons> ^^
01:12:34 <abz> thanks.
01:14:27 <vincent_> do i understand the following correctly: i need to construct the DiffArray in the IO monad, but the function that applies the incremental updates can be a pure function that takes a DiffArray?
01:15:04 <dons> ok, these polyphasic sleeping, haskell hacking guys are weird, http://daniel-yokomizo.livejournal.com/10489.html
01:15:22 <rahikkala> *Main Data.Array.Diff> (array (0,10) [(x, x) | x <- [0..10]]) :: DiffArray Int Int
01:15:26 <rahikkala> array (0,10) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
01:15:33 <rahikkala> Doesn't seem monadic to me
01:16:12 <vincent_> ahh
01:16:23 <vincent_> copy / paste / thank you
01:17:13 <vincent_> thanks very much!
01:17:37 <allbery_b> hrm.  shim doesn't like xemacs.  "Symbol's function definition is void: overlays-at"
01:18:16 <Cale> vincent_: most of the functions in Data.Array.Diff are red herrings, only the type is really necessary for most se.
01:18:18 <Cale> use*
01:18:36 <Cale> (and the Data.Array.IArray interface)
01:19:58 <vincent_> Cale: thanks very much
01:20:57 <vincent_> sweet, running beautifully now: this should keep me occupied for a few good, long commutes ;-)
01:21:23 <nmessenger> I noticed Data.Array.Diff.array returns an 'IArray a => a i e', and tried '@instances IArray', '@hoogle IArray', and ':i IArray' in GHCi but couldn't find any useful types.  How would I discover the 'DiffArray' type?
01:21:44 <Saizan> is there a Word8-typed Char module?
01:23:59 <tuomov_> I wonder if I'm doing something wrong..
01:24:11 <tuomov_> a diffarray is _slower_ than ingenious list processing
01:24:23 <dons> hey tuomov_
01:24:40 <tuomov_> _much_ slower
01:24:43 <dons> for Char processing, or something else?
01:25:14 <tuomov_> I have two lists, and I want to insert items from the second one on the first one, at an entry that minimises certain function between them
01:25:32 <tuomov_> and I can get tolerable performance from lists with a sort of pulley-belt approach
01:25:35 <dons> sounds ok for lists
01:25:43 <dons> any change to use a Set ?
01:25:44 <tuomov_> diffarrays totally suck at it
01:25:47 <dons> s/chance/
01:25:59 <dons> diff arrays probably require -O for reasonable results
01:26:13 <tuomov_> (pulley-belt = left and right sides, so that updates always occur at head)
01:26:29 <tuomov_> (there's still lot of re-creating of lists in that approach, however)
01:26:48 <tuomov_> I have -O6 and everything..
01:26:54 <dons> sounds like a good puzzle for haskell-cafe
01:26:57 <dons> -O6?? hehe
01:27:05 <dons> nothing happens after -O2
01:27:24 <tuomov_> big number better :)
01:27:28 <dons> :)
01:27:33 <rahikkala> -fsolve-halting-problem
01:27:37 <arcatan> -O9 \o/
01:27:42 <tuomov_> -O42
01:28:01 <arcatan> -funroll-loops
01:28:02 <tuomov_>         psa_init :: DiffArray Int (Vec, ([(Vec, Double)]))
01:28:02 <tuomov_>         psa_init = listArray (0, s-1) psl_init
01:28:10 <tuomov_> this is the right way to create a diffarray?
01:28:14 <nmessenger> -OAckerman(GrahamsNumber,GrahamsNumber)
01:28:20 <dons> -funroll-loops actually affects the Data.Binary library, arcatan !
01:28:28 <dons> since we generate decent loops for gcc
01:28:40 <dons> tuomov_: that's one way, yeah.
01:30:17 <tuomov_> how did you turn on profiling, again? In the resulting binary, not ghc
01:31:36 <dons> +RTS -p
01:33:34 <Cale> nmessenger: by looking in the Hierarchical documentation under Data.Array
01:33:35 <dons> hey, pepe made a ghci debugger movie, I had no idea, http://darcs.haskell.org/SoC/ghc.debugger/demo.mov
01:33:47 <Cale> Most of the things under that are specific types of array.
01:34:47 <tuomov_> accessing the array entries seems insanely slow
01:34:53 <xpika> does ghci support unicode?
01:35:04 <xpika> ⋀
01:35:08 <tuomov_> in the monoculturist way, it appears
01:35:22 <tuomov_> i.e. not supporting actually specifying the encoding used, and defaulting to utf-8
01:35:33 <tuomov_> hint: -- -*- encoding: whatever; -*-
01:35:37 <tuomov_> editors should support that too
01:38:12 <xpika> tuomov_: my editor vim supports unicode
01:38:52 <tuomov_> read again what I said
01:39:06 <Masklinn> hello haskell
01:39:31 <dons> xpika: yeah, I think ghc 6.6 should support unicode
01:39:40 <dons> there's a wiki page on it , should be findable from haskell.org/ghc
01:39:47 <dons> hey Masklinn
01:40:51 <tuomov_> with lists, the most time individually (30%) is spent actually computing the values to be compared
01:41:05 <Masklinn> morning dons (well it's probably evening for you, you're in Australia right?)
01:41:08 <tuomov_> with diffarrays, 60% of the time is spent fetching the times from the lists!
01:41:11 <tuomov_> s/lists/arrays/
01:42:09 <tuomov_> s/times/items/
01:42:39 <dons> tuomov_: sounds a bit suspicious!
01:43:00 <dons> tuomov_: -fliberate-case-threshold=1000 help any?
01:43:02 <tuomov_> both with 'assocs' and a 'for loop'
01:44:04 <tuomov_> 56%.. a little :)
01:45:41 <dons> i'm not sure DiffArrays are the most highly tuned structure out there
01:45:52 <dons> you could ask on -cafe
01:45:56 <dons> there's some DiffArray experts around
01:46:06 <tuomov_> ok, now _this_ is suspicious
01:46:10 <tuomov_> a plain Array is faster
01:46:52 <tuomov_> could ghc 6.4.2 have something to do with it?
01:47:13 <Saizan> are you sure you are not referring to older version of the arrays?
01:47:18 <xpika> tuomov_: have you tried -O2 or an Unboxed array?
01:47:21 <Saizan> *versions
01:47:29 <dons> tuomov_: hmm. can you try 6.6?
01:47:38 <dons> its a lot nicer on arrays in the GC
01:48:20 <tuomov_> quite sure
01:48:44 <tuomov_> doesn't seem to be available for FC4
01:48:56 <Saizan> referring in the language sense, like you are not applying your diffs always on the first array created
01:49:02 <tuomov_> I'm not sure if I have all the other shit I need installed back home on debian..
01:50:18 <tuomov_>     Could not find module `Graphics.HGL':
01:50:20 <tuomov_> bah
01:50:42 <tuomov_> well, I probably could disable it for the tests..
01:50:57 <dons> the HWN is out! http://programming.reddit.com/info/012341/comments
01:50:59 <lambdabot> Title: Haskell Weekly News: COM bindings, binary IO, regexes, more parser combinators ( ...
01:52:23 <tuomov_> xpika: unboxed won't work.. they're only for primitive types
01:54:41 <tuomov_> hmm.. ghc66 is annoying.. it doesn't generate a.out
01:55:10 <dons> -o a.out
01:55:12 <tuomov_> it is faster...
01:55:16 <tuomov_> that's not the point
01:55:26 <tuomov_> one expects a.out if nothing is specified
01:55:40 <allbery_b> I always thought a.out for unspecified was dumb
01:56:04 <tuomov_> maybe.. but that's what one expects from a compiler
01:56:12 <ibid> "assembler output"
01:56:22 <dons> hysterical raisins
01:57:23 <xpika> すと3 ∷ IO ()
01:57:49 <xpika> can i get japanese characters to work with ghc?
01:58:23 <tuomov_> it takes forever to compile haskell back home..
01:58:25 <allbery_b> doesn't ghc have some silly "can't tell what case it is, therefore it's illegal" restriction?
01:58:32 <dons> I *think* so, though you might need -fglasgow-exts, and an aspirin
01:58:41 <opqdonut> :)
01:58:52 <dons> xpika: check the user's guide
01:58:57 <dons> it mentions unicode and how it is to be used
01:59:29 <tuomov_> still 50% of the time spent fetching items from the array according to profiler
01:59:37 <xerox> bos: [dons] and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing [bos] um, is that next to the dilithium crystals?
01:59:45 <tuomov_> but strangely it was faster on my slower computer, without the profiler
01:59:48 <xerox> haha...
01:59:55 <tuomov_> but I didn't test against lists yet...
02:00:05 <tuomov_> another two slow compiles..
02:03:03 <tuomov_> ok, on ghc642 diffarrays are 4 times as slow as lists (on a particular test case)
02:03:16 <tuomov_> on gc66 diffarrays are 2 times as slow as lists (on that same test case, and different computer)
02:03:39 <tuomov_> conclusion: diffarrays are shit
02:03:59 <tuomov_> let's see arrays on ghc66..
02:04:01 <dons> well, you might be using them wrong? want to paste the code?
02:04:07 <dons> ?paste <--
02:04:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:04:27 <Cale> DiffArrays, especially if unboxed, give pretty decent performance if used the right way.
02:04:38 <Cale> It's not perfect, but it's okay.
02:04:48 <tuomov_> yep, plain arrays are still faster than diffarrays
02:05:03 <Cale> What's the usage pattern?
02:05:10 <dcoutts> kolmodin, did you see SimonM's email about using Data.Binary (which should be Binary.Serialisation) for .hi files, he wants to know the plan for state aka string pools
02:05:20 <tuomov_> 11:20 <tuomov_> I have two lists, and I want to insert items from the second
02:05:20 <tuomov_>                 one on the first one, at an entry that minimises certain
02:05:20 <tuomov_>                 function between them
02:05:46 <tuomov_> insert on lists within the items..
02:05:49 <tuomov_> where was that type sig..
02:05:56 <Cale> er, hmm...
02:06:01 <tuomov_> 11:23 <tuomov_>         psa_init :: DiffArray Int (Vec, ([(Vec, Double)]))
02:06:04 <Cale> Are you using old copies of the array?
02:06:09 <tuomov_> no
02:06:50 <Cale> hmm, what's that list of (Vec,Double) pairs?
02:06:56 <dons> seems expensive
02:07:00 <Cale> Should it really be a list?
02:07:10 <tuomov_> it's O(n^2)..
02:07:18 <dons> type Vec = ?
02:07:18 <Cale> I'm always scared when I see lists of pairs
02:07:20 <tuomov_> it should be a list
02:07:26 <tuomov_> that's where the items from the other list are inserted
02:07:28 <Cale> because usually they should be Data.Map's
02:07:39 <tuomov_> dons: doesn't matter
02:07:49 <dons> well, you might be able to use a Map or IntMap ..
02:07:52 <tuomov_> but it ain't primitive
02:07:59 <dons> o, so Map
02:08:16 <Cale> Unless all you
02:08:20 <dons> hard to say much more without the code though
02:08:29 <Cale> Unless all you're going to do is iterate linearly through the whole list
02:08:37 <Cale> Data.Map will probably do better
02:08:42 <tuomov_> iterate and update
02:08:58 <Cale> update by consing?
02:09:04 <Cale> Or by modifying elements?
02:09:08 <tuomov_> modifying elements
02:09:16 <tuomov_> (consing on the list within the elems)
02:09:16 <Cale> If you ever have to do lookups or change elements randomly, use Data.Map
02:09:56 <tuomov_> I'm just surprised how inefficient diffarrays are compared to even lists
02:10:07 <Cale> Well, it depends.
02:10:19 <tuomov_> o _plain_ arrays. Now that's strange
02:10:53 <Cale> hm?
02:11:29 <Cale> Does Array do better than DiffArray?
02:11:36 <tuomov_> yes
02:11:44 <Cale> If so, then your access pattern probably doesn't suit DiffArrays
02:12:02 <tuomov_> diffarrays: 0.740046s, plain arrays: 0.48003s, lists: 0.384024s
02:12:12 <Cale> You're somehow using old copies of the array, or the ability to do updates without copying isn't worth the overhead.
02:12:13 <tuomov_> ghc6.6 and a particular test case
02:12:38 <Cale> It might be that lists are naturally good for what you're doing.
02:12:45 <Cale> Try Data.Map and see how that goes.
02:13:58 <Cale> I usually find Data.Map is more convenient and faster for more things than using arrays.
02:14:19 <Cale> Also, Data.Sequence is really pretty good, if you're using 6.6
02:14:28 <dons> i only ever use arrays for O(1) lookup, where O(1) matters
02:14:32 <dons> that's pretty rare
02:14:32 <Cale> right
02:14:49 <dons> oh yeah, Data.Sequence might be better here
02:14:57 <dons> list like, but different complexity
02:15:07 <Cale> Usually O(log n) lookup is basically the same as O(1), while the benefits on other operations and nicer interface more than make up for that.
02:15:11 <Cale> yeah
02:15:54 <Cale> If you know that the thing is finite, and you need efficient concatenation/splitting/indexing then Data.Sequence is really quite awesome.
02:16:35 <tuomov_> I don't think sequences are going to be that much faster than my list hack
02:16:42 <tuomov_> same with maps
02:16:56 <tuomov_> using Vec as key probably isn't such a good idea either
02:17:16 <Cale> I'm talking about in place of the Array.
02:17:31 <Cale> Though in place of the list of pairs might be an idea too.
02:17:37 <tuomov_> and there's no fold/map for seqs?
02:17:53 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#t%3AFoldable
02:17:55 <lambdabot> http://tinyurl.com/2xwe3t
02:18:11 <Cale> Data.Sequence is an instance of Foldable
02:18:27 <Cale> and Functor as well.
02:18:29 <dons> it'd be interesting to see if it helped.
02:19:10 <Cale> I'm going to watch a show. If you're still struggling to figure things out after, then I'll have a look at the code and see if I can't spot anything.
02:19:25 <Cale> (or maybe Don will? :)
02:19:42 <tuomov_> but there are no seqs for 6.4.2? --> bah
02:20:11 <tuomov_> or is there 6.6 somewhere for FC4?
02:22:42 <dons> you could just install the linux binary
02:23:34 <dons> ?remember apfelmus Current OS are not ready for Haskell yet.
02:23:34 <lambdabot> Done.
02:30:18 <_roconnor> I doubt that Oleg's Terminates datatype holds all terminating lambda expressions.
02:30:21 <tuomov_> maps are still twice as slow with lists, with additional integer key
02:30:27 <tuomov_> s/with/as/
02:30:47 <tuomov_> I could try not using the integer key, but the thing is, the items are the items are not necessarily unique
02:31:21 <tuomov_> although that may not matter, if at init one overrides the other..
02:36:44 <tuomov_> no speedup
02:43:04 <tuomov_> I suppose reconstructing lists isn't that expensive then
02:43:40 <tuomov_> the thing with my list hack is, that finding the element to insert at is very efficient: the left and right sides of the lists at that point are remembered
02:43:52 <tuomov_> a map obviously is slower to access when we only know the key
02:43:58 <tuomov_> but an array should be fast to access again
02:45:11 <xerox> tuomov_: and you cons on the left list, or append?
02:45:13 <tuomov_> but with the list hack, you need to move potentially many items between left/right sides on each insertion
02:45:28 <tuomov_> xerox: modify the head of one of the lists
02:46:29 <kowey> dons: http://koweycode.blogspot.com/2007/01/think-of-monad.html
02:46:32 <lambdabot> Title: koweycode: think of a monad...
02:46:36 <dons> cheers
02:47:00 <dons> oh my!!
02:47:43 <dons> ok, so now I'm laughing loudly and my girlfriend is looking at me strangely
02:47:58 <xerox> haha...
02:49:29 * dons wipes tears from his eyes
02:49:50 <dons> kowey: you should drop that by haskell-cafe@ :)
02:50:01 <kowey> :-)
02:50:25 <kowey> will do (uh... tonight, when i'm not working on my dissertation like a good boy)
02:50:42 <dons> :)
02:50:48 <dons> working hard as usual!
02:51:00 <hpaste>  beelsebob pasted "Haddock is weird" at http://hpaste.org/214
02:51:09 <xerox> Thanks for the good laugh, eheh.
02:51:17 <beelsebob> anyone able to say why haddock doesn't generate any docs for the above code?
02:52:13 <dons> nothing wrong there, afaik
02:52:16 <beelsebob> weird
02:52:18 <dons> could be on lines above or below
02:52:21 <beelsebob> hang on... I'll paste some more
02:52:47 <hpaste>  beelsebob annotated "Haddock is weird" with "More Code" at http://hpaste.org/214#a1
02:52:53 <dons> kowey: http://www.haskell.org/haskellwiki/Humor#Haskell_Humor
02:52:54 <lambdabot> Title: Humor - HaskellWiki
02:53:03 <beelsebob> it doesn't document isApplication either
02:53:09 <beelsebob> nore Graph
02:53:11 <beelsebob> nor*
02:53:17 <dons> paste the lot?
02:53:35 <hpaste>  beelsebob annotated "Haddock is weird" with "everything" at http://hpaste.org/214#a2
02:54:00 * kowey imagines that page growing an entire monad section
02:54:07 <dons> that second | on Graph will break things
02:54:20 <beelsebob> oh? Why is that?
02:54:26 <dons> yeah, you're using funny syntax all over
02:54:36 <dons> only use a single -- | to introduce a comment
02:54:43 <dons> but not on each consecutive line
02:54:58 <dons> -- | are stored in reverse order thus if the theory paper describes a node as
02:54:58 <dons> -- | "rarf" it will be stored as "frar".
02:54:59 <dons> is wrong
02:55:08 <dons> and will do something usual
02:55:13 <dons> un-usual
02:55:23 <beelsebob> okay - well, removed them, no change in the documentation
02:56:04 <hpaste>  beelsebob annotated "Haddock is weird" with "Updated code, and warnings" at http://hpaste.org/214#a3
02:56:28 <beelsebob> is it the -- in the middle of the comment perhaps?
02:56:45 <dons> beelsebob: oh, not exported?
02:56:46 <beelsebob> ... no
02:56:55 <dons> things that aren't exported won't be documented without an extra flag
02:56:56 <beelsebob> dons: oh, does it need to be exported?
02:56:59 <beelsebob> oh, okay
02:57:14 <beelsebob> I expected it to document anything that was exported plus all the dependancies of such functions
02:57:38 <dons> no, it keeps the innards hidden
02:57:41 <beelsebob> wait a minute
02:57:48 <beelsebob> it documents internal functions in my Main module
02:58:09 <dons> do you have a module Main where ?
02:58:16 <dons> or an explicit (main) ?
02:58:16 <beelsebob> yes
02:58:21 <beelsebob> module Main where
02:58:22 <dons> then everything's exported already
02:58:25 <beelsebob> oh?
02:58:34 <dons> no export list == everything's exported
02:58:40 <beelsebob> oh, okay
02:58:41 <beelsebob> silly
02:58:46 <beelsebob> forgot that
03:00:15 <beelsebob> so what's the option to document everything then?
03:00:33 <beelsebob> wait... that worked, it just still complained
03:00:54 <beelsebob> couldn't find link destinations for all sorts of things despite them actually being documented now
03:01:04 <beelsebob> think that's a bug
03:01:08 <dons> haddock complains (harmlessly) by default
03:01:19 <beelsebob> no... it's not done the cross referencing
03:01:23 <beelsebob> it's documented everything
03:01:33 <beelsebob> but it's not created links to the non-exported things
03:02:43 <beelsebob> anyway, I must go teach -- I'll poke JaffaCake about that later
03:08:47 <dons> Cale, logo-tastic! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary/0.2
03:08:49 <therp> is there a fix for the unix package containing an undefined reference to lstat?
03:08:50 <lambdabot> http://tinyurl.com/2cngah
03:09:10 <therp> this occurs because the latest GHC head does not build via-c per default
03:09:49 <dons> add a include path to ghc's command line?
03:10:33 <Igloo> The easiest way would be to put -fvia-C in an OPTIONS_GHC pragma
03:10:44 <Igloo> The right fix is presumably to write a wrapper function somewhere and call that instead
03:11:14 <therp> my fix for the moment is echo "GhcLibHcOpts = -O -fgenerics -fvia-c" >> mk/build.mk
03:11:27 <matthew_-> well I must say, having read the first couple of pages of the associated types paper, I do like them. Are they in 6.7 yet?
03:13:49 <Igloo> Yes
03:14:22 <dons> matthew_-: yeah, get hacking with 'em :)
03:14:35 <dons> hackage is looking quite spiffy now !
03:14:40 <Masklinn> HackageDB is lacking stats, I want to confirm that half the HackageDB packages are by dons :p
03:15:14 <dons> i uploaded all mine, since i have perms, but there's 100s more out there to put up
03:15:31 <dons> yeah, stats would be good
03:15:47 <Masklinn> yeah I know, it's just that I was watching the "what"s new page" and since you just uploaded all your stuff you alone take half the list
03:15:52 <Masklinn> found it funny
03:16:04 <edwinb> so are people encouraged to upload stuff now?
03:16:08 <dons> edwinb: yeah
03:16:12 <Masklinn> otherwise, HackageDB stats will be much more interesting once Hackage itself works
03:16:21 <dons> or at least to point people with access to tarballs to upload
03:16:44 <swiert> The next issue of The Monad.Reader is now official.
03:16:49 <edwinb> I used the interface to check the package I wanted to upload and it complained that I wasn't using an approved top level name
03:16:49 <swiert> Go check it out at: http://www.haskell.org/haskellwiki/The_Monad.Reader
03:16:50 <Cale> dons: :)
03:16:51 <lambdabot> Title: The Monad.Reader - HaskellWiki
03:17:25 <dons> woo! sorry swiert, my code got written, but the article died somewhere between Hac07 and POPL :/
03:17:45 <swiert> dons: No worries. There's always the next issue.
03:17:46 <dons> just like the last 2 HWN issues, actually.
03:17:49 <dons> right!
03:17:57 <therp> who's actually in charge of HWN?
03:18:04 <dons> me
03:18:08 <edwinb> are the approved top level names just the ones on http://haskell.org/ghc/docs/latest/html/libraries/?
03:18:18 <therp> ah again you! :) dons++
03:18:25 <dons> edwinb: they're a tree on the 'applications' page on haskell.org
03:18:30 <dons> (there's a few ones that are unused currently)
03:18:58 <dons> edwinb: http://www.haskell.org/~simonmar/lib-hierarchy.html
03:18:59 <lambdabot> Title: Haskell Library Hierarchy
03:19:11 <edwinb> ah! I'd never have found that on my own, thanks ;)
03:19:51 <xerox> swiert: cool!
03:20:23 <Igloo> Ooo, hackage is starting to look fuller
03:20:34 <dons> Igloo: got some cabalised stuff to upload?
03:20:39 <dons> always a good time to tag and release :)
03:21:01 <dons> i like the logo, swiert
03:21:06 <Igloo> Yeah, I should tidy up my stuff
03:21:17 <edwinb> I think I will be good and write some documentation first
03:21:37 <edwinb> some more, I should say ;)
03:21:40 <swiert> dons: Thanks - it's a mutilated wingding.
03:22:22 <edwinb> swiert: can the "instructions for authors" be made a web page instead of a .zip?
03:23:11 <edwinb> (nice job, btw...)
03:23:23 <swiert> edwinb: There's also a darcs repository. I should probably link to that.
03:23:33 <swiert> edwindb: All credit goes to the authors.
03:26:59 <dons> woo!
03:27:02 <dons> swiert++
03:27:07 <dons> http://programming.reddit.com/info/123d0/comments
03:27:09 <lambdabot> Title: Monad Reader magazine! expressivity of foldr, compiling proofs and embedded asse ...
03:28:27 <roconnor> The Haskell metatutorial:  How to write a Haskell tutorial
03:29:26 <dons> People should up mod this, its not often articles of such quality leak out into the blogosphere :) http://programming.reddit.com/info/123d0/details
03:29:27 <lambdabot> Title: Monad Reader magazine! expressivity of foldr, compiling proofs and embedded asse ...
03:31:09 <dons> swiert: I'd CC the monad reader to the haskell-cafe@ list
03:31:17 <dons> a lot more people follow that, than haskell@
03:31:27 <dons> (particuarly newbies)
03:31:42 <roconnor> dons: um, is that the final copy?
03:31:58 <dons> hmm?
03:32:13 <dons> its the one from http://www.haskell.org/haskellwiki/The_Monad.Reader
03:32:15 <lambdabot> Title: The Monad.Reader - HaskellWiki
03:32:29 <roconnor> ah indeed
03:32:41 <roconnor> works for me
03:33:00 <swiert> dons: Good idea.
03:38:50 <roconnor> swiert: hmm, do you think it would be possible to get permission from the authors of the previous editions to put them on the new wiki?
03:40:29 <swiert> roconnor: I can try to track them down.
03:41:11 <dons> was there no permissive license on the old material?
03:41:21 <swiert> dons: Not explicitly.
03:41:45 <dons> ah ok
03:41:46 <roconnor> Now I understand why journals want authors to transfer copyright to them
03:41:51 <dons> :)
03:42:03 <dons> that's an interesting point
03:42:11 <dons> also, so they can sell the books back to the authors ;)
03:43:23 <roconnor> well, still, with a permissive license, the results are as good.
03:47:33 <FastPackedString> ByteString: I am your father
03:48:57 <ness> hi, what's wrong with writing foo (x1:x2:r) = ..., where foo :: [Integer] -> [Integer]? (sorry if this is a dumb question, I'm new to haskell)
03:49:52 <roconnor> > 1:2:[]
03:49:54 <Igloo> ness: What makes you think there's something wrong with it?
03:49:54 <lambdabot>  [1,2]
03:50:26 <ToRA> @paste
03:50:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:50:33 <roconnor> let foo (x1:x2:r) = x2:x1:r in foo [1,2]
03:50:34 <ness> Igloo: ghci complains *g*
03:50:36 <roconnor> > let foo (x1:x2:r) = x2:x1:r in foo [1,2]
03:50:37 <lambdabot>  [2,1]
03:50:49 <Igloo> Ah, you can't write declarations at the ghci prompt
03:51:03 <Igloo> Normally you'd write them in a file and load the file with ghci
03:51:06 <ness> Igloo: I have that in a file and load it
03:51:15 <hpaste>  ToRA pasted "Odd type/instance error??" at http://hpaste.org/215
03:51:29 <ToRA> anybody know why the pasted behaviour happens?
03:51:31 <Igloo> ness: What's the error, then? And the exact file contents?
03:52:33 <hpaste>  ness pasted "(no title)" at http://hpaste.org/216
03:53:28 <ness> Igloo: ^
03:53:29 <Igloo> ToRA: Interesting, it works in hugs
03:53:43 <trurl> ness: add parentheses around x2:r
03:54:00 <hpaste>  _magus_ pasted "xor-encrypt" at http://hpaste.org/217
03:54:28 <Igloo> ness: A trurl hints at, it's being parsed as   (x2 - x1) : (diffs x2) : r
03:54:28 <ness> trurl: thx
03:54:45 <Igloo> ness: Function application binds tightest
03:54:48 <_magus_> I'm having type problems with the code in http://hpaste.org/217 anyone around who'd like to take a look?
03:55:24 <Igloo> ToRA: And it works in ghc 6.4.2 too
03:55:35 <Igloo> ToRA: Oh, wait, I remember this now
03:56:00 <Igloo> ToRA: -fno-mono-pat-binds will accept it
03:56:19 <ToRA> Igloo: ah ok cool, cheers
03:57:03 <Igloo> ToRA: See http://hackage.haskell.org/cgi-bin/haskell-prime/trac.cgi/wiki/MonomorphicPatternBindings , and please send a mail somewhere if it bit you
03:57:05 <lambdabot> Title: MonomorphicPatternBindings - Haskell Prime - Trac, http://tinyurl.com/2hednb
03:57:11 <nmessenger> @type xor
03:57:13 <lambdabot> forall a. (Bits a) => a -> a -> a
03:57:20 <nmessenger> @instances-importing Data.Bits Bits
03:57:21 <lambdabot> Int, Integer
03:57:31 <ToRA> Igloo: thank-you :)
03:58:20 <nmessenger> _magus_: what error do you get?
03:59:18 <hpaste>  _magus_ annotated "xor-encrypt" with "(no title)" at http://hpaste.org/217#a1
03:59:45 <nmessenger> add [] around cur
03:59:53 <nmessenger> or change ++ to :
04:00:07 <malebria> Good morning.
04:00:09 <nmessenger> (second is preffered)
04:00:31 <_magus_> nmessenger: ah, yes, of course... I keep on mixing up (:) and (++)
04:01:04 <_magus_> that should be : and ++ of course
04:01:11 <_magus_> nmessenger: thanks
04:01:33 <nmessenger> _magus_: welcome :-)
04:06:13 <earthy> @botsnack
04:06:14 <lambdabot> :)
04:07:40 <nmessenger> @vixen Say <undefined>.
04:07:41 <lambdabot> <undefined>
04:19:39 <boegel> dons: you failed to mention HaBench/nofib2 in HWN :(
04:26:13 <ness> how can I force (-1) to be evaluated as a function (that is, so I can write (-1) 4, which evaluates to 3)
04:27:59 <Igloo> (subtract 1) does what you want
04:30:23 <ness> thx
04:32:22 <nmessenger> > ((-) 3) -- maybe?
04:32:23 <lambdabot>  Add a type signature
04:32:52 <nmessenger> flip (-) rather, yeah, subtract is probably better
04:34:04 <int-e> ((-1)+)
04:34:39 <nmessenger> now that's just silly :-P
04:34:56 <int-e> I'd suggest (-1+) but last I checked that didn't work in hugs.
04:35:07 <int-e> > (-1+) 2
04:35:09 <lambdabot>  1
04:35:39 <ness> > ((flip (-)) 1) 2
04:35:40 <lambdabot>  1
04:36:02 <nmessenger> subtract = flip (-)
04:46:18 <Gotaku> Do OpenAL bindings come with the Windows version of GHC?
04:50:30 <Shish> anyone here able to help with building a CVS checkout of hugs? --> make[1]: *** No rule to make target `../hsc2hs/Main.hs', needed by `../hugsdir/programs/hsc2hs/Main.hs'. Stop.
04:50:52 <syntaxfree> :t flip
04:50:54 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
04:51:11 <beelsebob> Shish: are you a UKC shish?
04:51:15 <Shish> yes
04:51:20 <Shish> small world :O
04:51:22 <syntaxfree> huh?
04:51:23 <beelsebob> indeed
04:51:30 <beelsebob> syntaxfree: we know each other
04:51:30 <syntaxfree> what is an UKC shish?
04:51:41 <beelsebob> as in he's shish from University of Kent
04:51:54 <beelsebob> Shish: most likely it's built using the Haskell build system
04:51:59 <syntaxfree> whatt's  a shish?
04:52:01 <beelsebob> is there a file called Setup.lhs there?
04:52:07 <beelsebob> that's a shish ->
04:52:14 <Shish> following these instructions --> http://hackage.haskell.org/trac/hugs
04:52:16 <lambdabot> Title: Hugs - Trac
04:52:38 <beelsebob> fair enough
04:52:47 <beelsebob> uh... buh
04:52:54 <beelsebob> try downloading a release sourceball?
04:54:02 <beelsebob> Shish: what do you need hugs for?
04:54:11 <beelsebob> it may be a better plan to get ghc (and associated ghci)
04:55:13 <Shish> it's the interpreter we're being taught with; there's a debian package, but I can make it segfault, so I'm going on a bug hunt /o/
04:55:29 <beelsebob> okay
04:55:36 <beelsebob> well, I'd recommend just using ghci
04:55:40 <beelsebob> it's type errors are better
04:55:44 <beelsebob> and it's mostly compatable
04:55:49 <beelsebob> you wont be able to use it with heat
04:55:49 <Shish> noted
04:56:07 <beelsebob> but I'm guessing you'll be able to be clever enough to save a file and reload
04:57:37 <beelsebob> plus you get the added bonus of being able to compile instead of interpret
04:57:51 <pejo> It's still a good idea to use whatever all the others in the course are using though.
04:58:33 <beelsebob> pejo: I'm teaching said course - there's nothing that they'll hit where they're incompatable
04:58:39 <beelsebob> teaching on*
04:58:45 <beelsebob> olaf is teaching it
04:59:46 <beelsebob> in fact... they could probably use yhi but I wouldn't guarentee it
05:05:33 <syntaxfree> yay. the new monad reader is gr-r-eat.
05:05:41 <beelsebob> o.O
05:06:05 * beelsebob wonders where he put the logic bot source code
05:06:15 <beelsebob> I had that out to help the IRCing fresheres last year
05:07:34 <syntaxfree> fresheres?
05:08:07 <dcoutts_> 1st year students
05:08:26 * dcoutts_ needs to blog about deploying Haskell GUI apps on Windows...
05:08:34 <dcoutts_> it's well slick :-)
05:08:45 <beelsebob> what app's this?
05:09:03 <dcoutts_> beelsebob, well any really, but for example a demo of the practical I ran
05:09:13 * syntaxfree needs to understand fix point combinators.
05:09:21 <dcoutts_> I could give out an .exe without source
05:09:24 <beelsebob> we're teaching the 1st years using Heat because some of them are incapable of edit file, save file, load file into interpretter and run it
05:09:38 <beelsebob> dcoutts: oh... I see
05:09:40 <dcoutts_> we can't give out the source because otherwise solutions would start popping up on the net
05:09:40 <beelsebob> sorry
05:09:46 <beelsebob> my brain is squint just now
05:10:01 <beelsebob> I keep interpretting sentences backwards
05:10:06 <dcoutts_> :-)
05:10:07 <beelsebob> I think it's the 1st year's inflewence
05:10:12 <dcoutts_> hah hah hah
05:10:15 <dcoutts_> poor you
05:10:39 <dcoutts_> "help! help! my students are making me more stupid!"
05:11:22 <dcoutts_> beelsebob, what's "heat" ?
05:11:51 <beelsebob> dcoutts: it's a really really basic IDE
05:11:59 <dcoutts_> ah right
05:12:03 <beelsebob> that does things like stopping them from opening files we tell them they can't open
05:12:09 <dcoutts_> nice
05:12:15 <beelsebob> so they can't poke about in the modules we've already written
05:12:28 <pejo> Heh, Feynman apparently rejected a bunch of positions since they didn't involve any teaching. His reasoning seems to hvae been along the lines "if I can't produce, I can atleast teach".
05:12:28 <dcoutts_> yeah, or generated code, or binary files, etc etc
05:12:30 <syntaxfree> @type mdo
05:12:32 <lambdabot> Empty 'do' construct
05:12:37 <syntaxfree> what is mdo?
05:12:38 <beelsebob> because first years seem to think that the way to solve a problem is to fiddle with the API rather than their own code
05:12:51 <dcoutts_> beelsebob, yes, I know that one
05:13:13 <dcoutts_> beelsebob, they change the problem 'til their solution works :-)
05:13:20 <beelsebob> @remember dcoutts help! help! my students are making me more stupid!
05:13:21 <lambdabot> Done.
05:13:26 <beelsebob> hehe
05:13:30 <syntaxfree> @hoogle mdo
05:13:31 <lambdabot> No matches found
05:13:31 * dcoutts_ grins
05:13:40 <bringert> what's that status of mmapped bytestrings?
05:13:43 <bringert> the
05:13:45 <syntaxfree> @quote mdo
05:13:46 <lambdabot> No quotes match. You speak an infinite deal of nothing
05:13:52 <dcoutts_> oh, someone was looking at it I think
05:13:56 <dcoutts_> I think it's now doable
05:14:09 <dcoutts_> the problem was that we can't have base depend on the Win32 package I think
05:14:29 <bringert> ok, so it could be a separate package
05:14:44 <dcoutts_> no, I think that was solved by some of the stuff going into base
05:14:59 <dcoutts_> ask dons, he might remember
05:15:50 <bringert> droundy asked me if I would be interested in adding file system like operations to the tar package to be able to use it for the darcs pristine cache
05:15:50 <nmessenger> syntaxfree: mdo is syntax, similar to do.  I've not used it, but I think it allows name bindings on the left of '<-' to be used on the rhs.
05:16:13 <syntaxfree> bizarre. is that haskell 98?
05:16:31 <nmessenger> A "recursive do" from what I've read.  And no.
05:16:37 <bringert> I figured that with an index of where the files are in the file, the tarball could be mmapped in for effcient random access
05:16:38 <Igloo> bringert: Couldn't that be a layer on top of the tar package?
05:16:45 <bringert> Igloo: right
05:16:58 <dons> boegel: ah! oops
05:17:04 <dons> it'll be in the next issue
05:17:07 <Igloo> Ah, right, it couldn't be a layer on top of you want to index it directly (I assume)
05:17:35 <bringert> Igloo: it still could I think
05:17:40 <malebria> dons: have you seen my patches to typeOf?
05:17:48 <Igloo> OK, you know better than I  :-)
05:18:00 <nmessenger> syntaxfree: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation
05:18:02 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
05:18:10 <bringert> Igloo: if you expose the function for parsing a single entry
05:18:41 <bringert> Igloo: then you just "seek" (i.e. BS.drop) to the right place, and parse one tar entry
05:18:58 <bringert> for meta-data operations, you only need to parse a single 512 byte block
05:19:10 <dons> malebria: ah yes, sitting in my inbox. does it support vim in the manner we discussed?
05:19:11 <bringert> the meta-data could even be cached in the index
05:19:41 <bringert> so the index would map paths to (meta-data, file offset)
05:20:03 <malebria> dons: the support is just like it was.
05:20:16 <dons> ok good. i'll apply it then in the morning
05:20:19 <dons> malebria++
05:20:36 <bringert> in the beginning, the whole tarball could just be read inro memory, and later that could be replaced by an mmapped bytestring
05:20:45 <bringert> dons: what's the state of mmapped bytestrings?
05:21:01 <dons> they're enabled on win32, and commented out on posix
05:21:05 <dons> we could turn them on
05:21:07 <malebria> =D
05:21:21 <bringert> dons: why are the commented out on posix?
05:21:31 <bringert> dons: are they in base, or just in fps-experimental?
05:21:34 <dons> well, the old fps used to support them directly, as you know
05:21:42 <bringert> yeah
05:21:46 <dons> then when we moved it into base, we commented out the unix-only support
05:21:49 <dons> since it wasn't portable
05:21:59 <dons> then win32 support was added in the win32 package
05:22:22 <dons> now we need to move the unix/posix code from commented-out into the 'unix' package or somewhere like that
05:22:42 <bringert> ah, ok
05:22:45 <dons> or you could just copy the code into your own project
05:23:01 <bringert> gotta go for a while
05:23:09 <bringert> thanks!
05:24:04 <dcoutts_> dons, oh you mean add the bytestring mmap function to the posix or win32 packages?
05:24:29 <dons> its in win32 already!
05:24:34 <dcoutts_> dons, but we'd want it to live at the same module name
05:24:38 <dcoutts_> ie portable
05:24:43 <dons> well, yeah, that'd be even better
05:24:49 <dons> it seems to come up a lot
05:24:55 <dons> everyone loves mmap
05:25:07 <dcoutts_> that's because it's lazy :-)
05:25:10 <nomeata> Hi. Is Wouter Swierstra on IRC, and what’s his nick?
05:25:49 <dons> nomeata: he is here
05:25:52 * dons points at swiert 
05:26:03 <nomeata> ok, could have guessed that
05:26:06 * mux reads JavaGI code and goes blind
05:26:06 <nomeata> swiert: hi
05:26:23 <dcoutts_> dons, it'd be ok at the moment to have the win32 and poisix packages export the same mmap module name since the two packages can't currently be installed simultaneously, but we'd not be popular with the cygwin lovers
05:26:32 <dons> heh
05:26:45 <nomeata> swiert: I see that the monad reader now does not have a wiki any more, but is just a latex document anymore
05:27:11 <nomeata> swiert: I have a wiki software that is meant to edit latex documents (and creates pdfs, not htmls), which is based on haskell and svn
05:27:16 <dcoutts_> dons, could we justify moving the mmap functions into System.Posix.Internal ? which lives in base.
05:27:26 <nomeata> swiert: a darcs backend should also be possible
05:27:34 <dons> yeah
05:27:41 <nomeata> swiert: maybe you want to have a look at it: http://latexki.nomeata.de/
05:27:43 <lambdabot> Title: The Latexki Latex Wiki Wiki - index
05:27:49 <dcoutts_> dons, we could try the route of, well ghc will need it itself for mmaping the .hi files (and using Binary.Serialisation)
05:28:01 <dons> nomeata: http://www.haskell.org/haskellwiki/The_Monad.Reader
05:28:02 <lambdabot> Title: The Monad.Reader - HaskellWiki
05:28:02 <dcoutts_> hence should be in base :-)
05:28:12 <dons> dcoutts_: yeah.
05:28:18 <dons> mmap should be in base anyway
05:28:23 <dcoutts_> @arr
05:28:24 <lambdabot> Aye Aye Cap'n
05:28:26 <Igloo> dcoutts_: "GHC needs it" isn't a reason to put it in base
05:28:32 <SamB> you could argue that, having been ported, it is clearly portable ;-)
05:28:37 <dcoutts_> Igloo, really? damn. I thought it was ;-)
05:28:56 <dons> dcoutts_: haven't you been reading Bulat's missives?
05:29:08 <dcoutts_> hah hah hah hah. yes.
05:29:11 <dons> anyway, step 1) -package mmap
05:29:29 <roconnor> > exp (pi) - pi
05:29:30 <lambdabot>  19.999099979189474
05:29:30 <nomeata> dons: well, the content of the reader itself is no longer in the wiki, is it?
05:29:40 <dons> right, its in darcs I think
05:29:40 <dcoutts_> Igloo, is "everyone wants it" a good enough reason?
05:29:47 <SamB> so... which code would Cygwin folks want used?
05:29:48 <dons> it could be an extralibs package
05:29:57 <dons> unles ghc needs it, in which case it becomes a core package
05:30:03 <dons> which wouldn't be unreasonable
05:30:18 <dcoutts_> Igloo, or "we can't make base depend on posix/win32 packages" a good enough reason?
05:30:23 <nomeata> roconnor: lambdabot seems to be broken. shouldn’t that be 20? I read that on some cartoon, I think.
05:30:31 <dons> nomeata: heh
05:30:56 <dons> yeah, phd comics and xckd is where all wise knowledge is to be found
05:31:05 <Igloo> dcoutts_: What is the problem with it being its own package?
05:31:05 <dcoutts_> we want a portable standard mmap, and it can't be portable if it's in posix & win32, so it should be in base (along with all the other System.Posix.Internal stuff)
05:31:13 <SamB> nomeata: perhaps it was a wiggly equals sign?
05:31:23 <dcoutts_> Igloo, one function in it's own package?
05:31:36 <dcoutts_> Igloo, why not put file reading in it's own package
05:31:37 <dons> dcoutts_: or in a package that depends on win32 || unix
05:31:50 <dons> i'm ok with it being in its own package.
05:31:55 <dons> just one module, System.IO.MMAp
05:31:58 <dcoutts_> to start with it's ok
05:32:03 <dons> then we see what we see
05:32:04 <Igloo> dcoutts_: I haven't been following what "it" is, I just dislike the "throw everything in base" mentality
05:32:11 <SamB> yeah! readFile and hGetContents and getContents in a getContents package!
05:32:15 <SamB> hooray!
05:32:18 <dons> Igloo: mmapFile :: FilePath -> IO ByteString
05:32:20 <dcoutts_> Igloo, sure, but it naturally lives with the other portable IO stuff
05:32:54 <dons> i'd like less stuff in base just so bulat stops telling me there's too much stuff in base
05:33:25 <SamB> dons: yeah. that is his evil plan to steal our batteries!
05:33:30 <nomeata> SamB: I wasn’t serious. See http://xkcd.com/.
05:33:31 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:33:32 <Igloo> dons: :-)
05:34:09 <dons> did people see kowey's helpful graphic, http://koweycode.blogspot.com/2007/01/think-of-monad.html ?
05:34:12 <lambdabot> Title: koweycode: think of a monad...
05:34:21 * Igloo thinks it would be really cool if there was an IO package, but things like error need to knwo at least something about it
05:34:40 <SamB> nomeata: I realize you weren't expecting one irrational number to the power of another minus the other to be an integer...
05:34:46 <SamB> because that would be a funny thing to expect
05:34:56 <dons> SamB: but it would be cool!
05:35:01 <dcoutts_> Igloo, sure, pulling out the whole IO bit would be fine, it's just that it needs to be mostly kept together as a chunk
05:35:11 <dons> and you know, what with e ^ pi * i == -1 .... who's to say what to expect!
05:35:19 <SamB> yeah
05:35:19 <dcoutts_> Foreign.* could come out too
05:35:38 <SamB> I'm sure there is at least one pair of irrational numbers that solves this equation
05:35:41 <dons> e ^ pi - pi could well be 20. you know it would make as much sense as -1
05:35:48 <dcoutts_> most of the data structures in Data.* could be elsewhere
05:35:49 <SamB> or, well, it isn't an equation is it?
05:35:52 <dons> e ^ pi - pi should be 7
05:36:06 <dons> then everything would fall into place
05:36:12 <dons> let's see what Cale things
05:36:15 <dons> inks
05:36:16 <SamB> (or can you use modular arithmatic on nonintegral things?)
05:36:23 <SamB> what Cale inks?
05:36:29 <SamB> yes I would like to see that as well
05:37:01 <SamB> what a nasty joke ;-)
05:37:29 <SamB> on the other hand, hooray for getting kicked out of the acm
05:37:43 <nomeata> e ^ pi - pi could just be 1. after all e ^ pi - pi = e ^ 0 = 1
05:38:00 * nomeata is in favour of full cross-operation associativity
05:38:03 <csci> Small syntax question: I have a data type Token = Link [Char] | Text [Char]. How do I match it against a pattern, when I have a [Token]. I tried (besides other things) foo (Link c:cs) = ... , foo (Text c:cs)?
05:38:15 <SamB> nomeata: um.
05:38:19 <SamB> ^ binds tight!
05:38:32 <nomeata> SamB: you mean, it binds powerfully?
05:38:34 <SamB> :i ^
05:38:39 <SamB> aww.
05:38:57 <nomeata> SamB: but does that mean that - binds negatively?
05:39:00 <dons> > exp (pi * sqrt 163)
05:39:02 <lambdabot>  2.6253741264076826e17
05:39:06 <SamB> nomeata: ugh!
05:39:08 <dons> > exp (pi * sqrt 163) - fromIntegral (floor (exp (pi * sqrt 163)))
05:39:09 <lambdabot>  0.0
05:39:13 <dons> there we go
05:39:18 <Cale> hm?
05:39:23 <Cale> What I think about what?
05:39:31 <dons> exp pi - pi should be 7
05:39:41 <SamB> dons: why are we flooring?
05:39:47 <SamB> @type floor
05:39:48 <dons> cause that's fun
05:39:49 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:39:54 <SamB> hmm.
05:40:00 <Cale> 7?
05:40:08 <nmessenger> csci: Link and Text are outside the list, thus: (Link (c:cs))
05:40:15 * SamB wonders why it is Integral b and not Num b
05:40:16 <dons> Cale: since -1 is already taken
05:40:21 <Cale> It'd be pretty cool if it were rational.
05:40:35 <Cale> but it probably isn't
05:41:15 <nmessenger> csci: and for [Token], (Link (c:cs) : ts)
05:41:24 <Cale> I bet it's not known whether it's rational or not.
05:41:41 <Cale> hmm, it could be known
05:41:51 <Cale> But that sort of thing can be hard.
05:41:58 <pejo> csci, foo ((Link something):cs) = ...
05:42:13 <dons> maths is hard, give me a monad transformer any day
05:42:43 <bakert> Trying to declare a type like this:
05:42:44 <bakert> type Bucketed = Num a => [(Key, a)]
05:42:55 <bakert> gives me "illegal polymorphic or qualified type".
05:42:58 <bakert> Can I not do that?
05:43:13 <dons> float the parameter left
05:43:27 <nmessenger> type Num a => ... ?
05:43:40 <Cale> type Bucketed a = Num a => [(Key, a)]
05:43:57 <Cale> That ought to work in GHC anyway.
05:43:57 <dons> actually, not sure that's legal anyway
05:43:59 <pejo> csci, uh, or what nmessenger said. I have no idea why I read your statement that way.
05:44:06 <pbx> ocaml
05:44:08 <Cale> Probably not in Haskell 98.
05:44:10 <pbx> oops
05:44:55 <bakert> Cale, that gives me the same error unfortunately.
05:45:06 <Cale> -fglasgow-exts ?
05:45:35 <dons> data (Num a) => B a = B [a]
05:45:39 <dons> or some such,
05:45:46 <dons> i couldn't get the type synonym to work
05:46:06 <int-e> dons: hmm, that doesn't do what you want I think.
05:46:24 <dons> yeah, not the same thing at all
05:46:32 <dons> well, the Num doesn't help much here
05:46:42 <bakert> Cale, is -fglasgow-exts something most poeple are doing on most programs?  Or only for emergencies?
05:46:53 <dons> bakert: you just want a nice name for the Num qualified list?
05:47:12 <Cale> oh
05:47:22 <Cale> type Bucketed = forall a. Num a => [(Key, a)] -- somehow this works?
05:47:24 <bakert> dons, basically yes.  i'm just giving that bizarro structure a name.  Key is (String, ClockTime) too so it's a two-part thing
05:47:35 <Cale> I don't understand how that works, but it does.
05:47:47 <int-e> Cale: it packs the Num dictionary into the type
05:47:50 <therp> I'm going to release Liskell today
05:47:57 <Cale> int-e: into the type synonym?
05:47:58 <bakert> Cale, that gives me "parse error on input =>"
05:48:04 <dons> Cale: hmm
05:48:11 <Cale> bakert: with fglasgow-exts on
05:48:14 <bakert> ah
05:48:16 <dons> int-e, even in the synonym?
05:48:34 <bakert> Is it accepted practice to use -fglasgow-exts?
05:48:38 <dons> that's a bit tricky
05:48:46 <amiddelk> that's strange, I thought the type synonyms are desugared... then where does it store the dictionary?
05:48:47 <Cale> bakert: yes
05:48:48 <bakert> Don't want to step outside the bounds of good practice just for a name.
05:48:51 <bakert> you see.
05:48:54 <bakert> ok i'll do that.
05:48:57 <int-e> dons: oh wait. no. that's the other forall :)
05:49:10 <Cale> bakert: -fglasgow-exts just means that you're tied somewhat to GHC.
05:49:28 <amiddelk> or wait, nvm
05:49:30 <nmessenger> s/somewhat/irretreivably/
05:49:34 <Cale> But it's necessary for almost everything that's happened to the language after Haskell 98.
05:49:36 <int-e> dons: this one would be a function that takes a num dictionary and creates a list
05:49:43 <dons> mm
05:49:44 <bakert> Sure.  I just don't want to get into habits that will cause more experience haskell programmers to recoil in horror.  But if it's the done thing I'm happy to do it!
05:49:49 <bakert> Thanks everyone.
05:50:16 <dons> that's an interesting trick
05:50:23 <bakert> Interestingly I now get  Couldn't match expected type `Bucketed'
05:50:23 <bakert>            against inferred type `[(Key, a)]'
05:50:32 <dons> :)
05:50:41 <dons> that's what you get when Cale starts giving you funny types
05:50:47 <bakert> Which of course is what Bucketed is.  So perhaps I haven't done it right?
05:50:51 <csci> nmessenger, pejo : Thanks
05:51:08 <bakert> Perhaps I will just abandon giving that type a name?
05:51:18 <dons> bakert: i think it will be simpler to leave off the class qualification
05:51:32 <dons> and type Bucket a = [(Key, a)]
05:51:40 <dons> then constrain it at each use to Num, as appropriate
05:51:43 <int-e> dons: the only thing that I miss about this stuff is a way to dynamically create type instances (without going through the hoops of creating type level integers or something equivalent to that)
05:51:48 <Cale> yeah, that'd be the saner thing to do :)
05:51:49 <bakert> dons, that seems like a good idea
05:51:56 <int-e> dons: err, class instances.
05:52:11 <int-e> dons: in other words, class dictionaries.
05:52:16 <Cale> It's really not easy to make class qualifications go away.
05:52:28 <dons> int-e you miss that? :) you need ML functors for those kinds of games I think
05:53:46 <int-e> dons: well, it'd be really cool to have a function   evaluate_modulo :: (forall a. Num a => a) -> Integer -> Integer  that creates a Num dictionary and then runs the computation without the O(log n) overhead caused by encoding the modulus to types and back.
05:55:57 <dons> btw everyone Lemmih got hs-plugins working with ghc 6.6
05:56:14 <dons> so we need to send him some beer and cake
05:56:14 <dcoutts_> yay
05:56:18 <Igloo> Ah, cool
05:56:21 <dcoutts_> and a release tarball
05:56:23 <SamB> dons: he likes beer?
05:56:49 <dons> well, i don't think he'd say no. money might be a more flexible gift though :}
05:57:00 <dons> i owe him
05:57:07 <SamB> I'm not even old enough to buy beer anyway
05:57:13 <SamB> nor do I actually have money
05:57:54 <dons> Lemmih's probably not even old enough to buy beer where you are :}
05:58:08 <Syzygy-> We have hs-plugins in 6.6!?!?
05:58:09 <nmessenger> Lemmih++
05:58:11 <Syzygy-> Wow!
05:58:16 <Syzygy-> That's dangerous news!
05:58:20 <Syzygy-> Lemmih++
05:58:24 <SamB> how old is Lemmih?
05:58:31 <Syzygy-> Where is Lemmih?
05:58:33 <SamB> I will be that old in august...
05:58:40 <nmessenger> Why is Lemmih?
05:58:44 <dons> 21 , Denmark, iirc
05:58:50 <dons> Why, are the mystery of Lemmih
05:58:52 <SamB> oh, denmark?
05:58:59 <SamB> I'm in the US
05:59:07 <SamB> @map
05:59:08 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:59:13 <dons> ah, you should send him US dollars then
05:59:47 <dons> though he might accept shiny euros
05:59:49 <Gotaku> How would I go about parsing command line arguments and building a data structure of the specified program options?
05:59:50 <magic_user> is there any kind of fitness irc?
05:59:58 <dons> Gotaku: System.Console.GetOpt
06:00:14 <dons> Gotaku: there's some nice examples in the documentation and source for that module
06:00:18 <dons> ?docs System.Console.GetOpt
06:00:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
06:00:24 <dons> ?source System.Console.GetOpt
06:00:24 <lambdabot> http://darcs.haskell.org/packages/base/System/Console/GetOpt.hs
06:00:30 <dons> (see the exapmle at the end of the file)
06:01:38 <Gotaku> Ok thanks.
06:01:40 * SamB goes to school now
06:02:27 <opqdonut> nice to hear SamB
06:03:11 * edwardk waves hello.
06:07:13 <dcoutts_> quick Q: if you were using Gtk2Hs on windows, would you expect by default to produce .exe's that popup a console window, or have no console window? (if there's no console window then doing standard IO causes an exception which gets displayed in a msgbox)
06:07:18 <malebria> Igloo: Is http://hackage.haskell.org/trac/ghc/ticket/1125 the bug about the problem in my package?
06:07:20 <lambdabot> Title: #1125 (&#34;module main:Foo is not loaded&#34; when trying to load a module from ...
06:07:28 <dcoutts_> in other words what should I set the default as?
06:07:47 <Igloo> malebria: Yes
06:07:52 <therp> Liskell is out. Finally. http://planet.haskell.org/
06:07:53 <pejo> dcoutts, I wouldn't expect a GUI program to pop up a console window unless it had a use for it.
06:07:54 <lambdabot> Title: Planet Haskell
06:08:13 <dcoutts_> pejo, yeah, that's the hard bit, if you do have a use for it, you get an exception :-)
06:08:28 <dcoutts_> pejo, it's not like a console pops up when you first do standard IO
06:08:35 <nomeata> @seen swiert
06:08:36 <lambdabot> swiert is in #haskell. I last heard swiert speak 2h 21m 36s ago.
06:08:40 <dcoutts_> or even that it gets ignored, you get an exception
06:08:59 <nomeata> swiert: well, I’m off. If you want to know more, just mail me (mail@joachim-breitner.de)
06:09:25 <dcoutts_> pejo, so users can explicitly say:  to get no console window, so the question is, should I include -optl-mwindows as the default in the gtk package?
06:09:35 <dcoutts_> /"say: -optl-mwindows"
06:10:12 <malebria> Igloo: this happens also without --user
06:10:40 <Gotaku> dons, I don't understand what "Flag" does in the getOpt example.
06:13:07 <magic_user> can someone learn haskell as a first language?
06:13:23 <bakert> magic_user, they do it at some universities.
06:13:26 <notsmack> magic_user: sure
06:13:29 <emu> it's probably best to do so
06:13:35 <matthew_-> yes, they do it a imperial for one
06:13:40 <matthew_-> at, rather
06:13:44 <bakert> Is it sometimes the case that a function will only work _without_ a type signature?  Or is that just a sign I am not trying hard enough to get it right?
06:13:46 <magic_user> and another tutorial has most of what I need to learn?
06:14:09 <bakert> matthew-_, are you sure they do it at imperial?  it was all java and c++ last time i looked (admittedly a couple of years ago)
06:14:09 <emu> bakert: ask the system what the type should be
06:14:15 <bakert> emu, doh yes of course
06:14:27 <Igloo> matthew_-: Who teaches it?
06:14:34 <notsmack> magic_user: ah, the someone is you? :-)
06:15:08 <matthew_-> bakert: well I'm at Imperial, as a PhD, having just finished the MEng course (4year) and I'm now doing some teaching to the 1st years on Haskell
06:15:45 <matthew_-> bakert: the first 6 weeks of the first term for the 1st years is haskell. After that it pops up from time to time but there's not much further teaching of it
06:16:18 <bakert> matthew-_, well i guess you'd know then!  that's cool.  which reminds me i really must finish off my masters paper and graduate.
06:17:18 <matthew_-> yeah, graduation is important
06:17:33 <matthew_-> Igloo: Tony Field mainly
06:19:03 <bakert> How does ghci's ":t" decide whether something is String or [Char].  Seems a bit arbitrary.
06:19:27 <Igloo> It does its best to give the answer it think you'd expect
06:19:39 <Igloo> But ultimately it /is/ arbitrary
06:19:51 <chessguy> 'morning haskellers
06:20:35 <bakert> I think [Char] must be the default when it has no clue then.  And it will switch to String when it thinks it sees that.
06:20:48 <chessguy> they're the same thing
06:21:13 <bakert> chessguy, sure.  but i know which one i want in my type signature.  i'm fussy like that!
06:21:28 <norpan> so type the one you want :)
06:22:01 <bakert> norpan, I am doing!  I just need a bit of :t help to work out what it should be.  And then I noticed it had mixed together [Char] and String and wondered what the rationale was!
06:23:03 <norpan> bah, getting type information from :t is cheating!
06:23:28 <norpan> if you don't know what type your function should have, then how can you possibly write it?
06:23:54 <chessguy> lol
06:24:10 <chessguy> it's an important trick for us newbies
06:24:20 <norpan> i take it back
06:24:44 <bakert> norpan, it is to do with SqlValues.
06:25:17 <norpan> but i suppose ghci tries to use the type synonyms whenever some function involved was declared using them
06:25:21 <bakert> in my mind they are already Doubles (or whatever) but that's not what they are until "fromSql" has been called on them.  So I'm trying to qualify them with Num a => but it wasn't working and I needed a bit of ghci help.
06:25:55 <bakert> I agree with you though.  The more I write the type signatures _first_ the better my haskell gets.  This is only day 32 so forgive me!
06:26:04 <wolfgangbeck> how do I access the request body from Network.CGI? stdin doesnt seem to work
06:26:19 <chessguy> 32...wow, you're way farther than i was on day 32. i'm about 6 months in
06:26:53 <norpan> i often start writing a bunch of functions with type signatures and function = undefine
06:26:56 <norpan> undefined
06:27:12 <chessguy> heh
06:27:29 <chessguy> to see if it compiles?
06:27:48 <chessguy> > undefined :: Int
06:27:49 <norpan> yeah, to be able to implement top-down
06:27:49 <lambdabot>  Undefined
06:28:04 <norpan> and still have it type check
06:29:04 <bakert> chessguy, i have been writing haskell at work all day this month.  does wonders for the learning!
06:29:21 <bakert> chessguy, i'm still not as far along as that guy whose haskell diary was on reddit yesterday
06:29:25 <chessguy> > take 5 [1..3]
06:29:26 <lambdabot>  [1,2,3]
06:29:34 <xerox> norpan: yeah, that's pretty handy. Another nicety is to use undefined to find types you don't want to write down by hand completely.
06:29:36 <bakert> and he started on jan 1 i think (6 days after me)
06:30:03 <opqdonut> > take (len [1..]) [1..]
06:30:04 <lambdabot>   Not in scope: `len'
06:30:06 <chessguy> yeah i haven't had hardly any time to play around with it, unfortunately
06:30:10 <opqdonut> > take (length [1..]) [1..]
06:30:14 <lambdabot> Terminated
06:30:17 <opqdonut> :(
06:30:30 <opqdonut> ?test (take (length [1..]) [1..]) == [1..]
06:30:31 <lambdabot> Maybe you meant: let list tell
06:30:42 <opqdonut> bah
06:31:13 <nmessenger> ?check (\xs -> take (length xs) xs == xs) :: [Int] -> Bool
06:31:15 <lambdabot>  OK, passed 500 tests.
06:32:02 <opqdonut> ?check (take (length [1..]) [1..] == [1..])
06:32:02 <chessguy> > let chunk _ [] = []; chunk n xs = [(take n xs)] : chunk n (drop n xs) in chunk 4 [1..20]
06:32:18 <lambdabot>  thread killed
06:32:18 <lambdabot>  thread killed
06:32:27 <Saizan>                                                                  ?paste
06:32:32 <opqdonut> :)
06:32:36 <Saizan> ?paste
06:32:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:32:41 <chessguy> > let chunk _ [] = []; chunk n xs = [(take n xs)] : chunk n (drop n xs) in chunk 4 [1..20]
06:32:56 <lambdabot>  thread killed
06:32:59 <nmessenger> where is the haskell wiki page that describes 'IO a' in terms of 'World -> (a, World)'?
06:33:35 <chessguy> @type drop
06:33:41 <lambdabot> forall a. Int -> [a] -> [a]
06:34:24 <opqdonut> ?type let chunk _ [] = []; chunk n xs = [(take n xs)] : chunk n (drop n xs) in chunk
06:34:26 <lambdabot> forall a. Int -> [a] -> [[[a]]]
06:34:38 <beelsebob> Shish: are you coming to the porn tonight?
06:34:41 <opqdonut> ahh, i know
06:34:54 <opqdonut>  > let chunk _ [] = []; chunk n xs = (take n xs) : chunk n (drop n xs) in chunk 4 [1..20]
06:34:55 <chessguy> > let chunk _ [] = []; chunk n xs = (take n xs) : chunk n (drop n xs) in chunk 4 [1..20]
06:34:59 <chessguy> lol
06:34:59 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
06:34:59 <opqdonut> > let chunk _ [] = []; chunk n xs = (take n xs) : chunk n (drop n xs) in chunk 4 [1..20]
06:35:01 <lambdabot>  [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
06:35:04 <opqdonut> :)
06:35:12 <opqdonut> how's the chess project progressing btw?
06:35:18 <chessguy> eh
06:35:29 <chessguy> it's not, really. i haven't had time to play with it
06:35:39 <dons> http://programming.reddit.com/info/123xv/comments
06:35:41 <lambdabot> Title: Lisp macros for Haskell? Done. (reddit.com)
06:35:41 <opqdonut> life got in the way?
06:35:58 <chessguy> yeah
06:36:17 <chessguy> that and my utter inability to write anything resembling decent haskell
06:36:39 <hpaste>  Saizan pasted "parse an ASCII encoded integer with Binary" at http://hpaste.org/219
06:36:42 <opqdonut> dons: cool
06:37:10 <Saizan> is that a reasonable way?
06:37:12 <therp> dons: hm, I'm just struggling to get the FLV file to play in windows. I think nothing but mplayer can play FLV/flashsv codec :/
06:37:45 <Donner> opqdonut: Why do you compute the partition twice? Use splitAt instead.
06:37:58 <dons> hpaste: parse an ascii encoded integer with Binary?
06:38:08 <dons> Saizan: sorry, can  you use readInt?
06:38:14 <opqdonut> Donner: just fixing chessguy's code :)
06:38:15 <dons> to turn a ByteString into an Int?
06:38:16 <chessguy> Donner, it's my code not his
06:38:21 <dons> ?users
06:38:22 <lambdabot> Maximum users seen in #haskell: 322, currently: 296 (91.9%), active: 41 (13.9%)
06:38:23 <Donner> Ok, never mind.
06:38:24 <chessguy> how is that computing it twice?
06:38:28 <Saizan> ?hoogle readInt
06:38:29 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
06:38:29 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
06:38:29 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
06:38:39 <dons> Saizan: in Data.ByteString.Char8.readInt
06:38:59 <Saizan> oh
06:39:11 <dons> Saizan: like, http://hpaste.org/209#a2
06:39:34 <chessguy> Donner, ?
06:39:37 * nmessenger finds the wiki page @wiki IO_inside
06:39:55 <Donner> chessguy: (take n) and (drop n) does are different functions to receive the same result.
06:39:57 <dons> Saizan: i.e. this function is already written for you :)
06:40:08 <dons> (i think..)
06:40:15 <Donner> > :t splitAt
06:40:16 <lambdabot>  Parse error
06:40:25 <wolfgangbeck> Is there really no way to access the raw request body inside Network.CGI?
06:40:28 <chessguy> @type take
06:40:30 <lambdabot> forall a. Int -> [a] -> [a]
06:40:30 <chessguy> @type drop
06:40:32 <lambdabot> forall a. Int -> [a] -> [a]
06:40:34 <Saizan> mmh, well, most of it
06:40:53 <Donner> @type splitAt
06:40:55 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:40:56 <chessguy> well, ok, but they return different parts of the list, how can they be the same result?
06:41:20 <Donner> @type \n xs -> (take n xs, drop n xs)
06:41:22 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:41:36 <nmessenger> @check (\n xs -> (take n xs, drop n xs) == splitAt n xs) :: Int -> [Int] -> Bool
06:41:37 <lambdabot>  OK, passed 500 tests.
06:41:58 <Donner> chessguy: splitAt is more efficient.
06:42:13 <nmessenger> @src splitAt
06:42:13 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:42:16 <opqdonut> > let chunk _ [] = []; chunk n xs = (snd chunk n) $ splitAt n xs in chunk 4 [1..20]
06:42:17 <lambdabot>  Couldn't match `(a1, t -> a -> b)' against `t1 -> [a2] -> [a3]'
06:42:21 <nmessenger> doesn't look it :D
06:42:29 <opqdonut> > let chunk _ [] = []; chunk n xs = (snd (chunk n)) $ splitAt n xs in chunk 4 [1..20]
06:42:30 <lambdabot>      Expecting a function type, but found `(a, b)'
06:42:31 <lambdabot>       Expected type: (a1, ...
06:42:38 <chessguy> LOL
06:42:42 <Donner> nmessenger: Oh, I have a different definition.
06:43:40 <chessguy> well, this definition of chunk is on the wiki:
06:43:40 <chessguy> chunk n xs = chunk' i xs
06:43:40 <chessguy>   where
06:43:40 <chessguy>     chunk' _ [] = []
06:43:40 <chessguy>     chunk' n xs = a : chunk' n b where (a,b) = splitAt n xs
06:43:41 <chessguy>     i = ceiling (fromIntegral (length xs) / fromIntegral n)
06:44:01 <chessguy> but i liked my defnition better
06:44:34 <Donner> chunk n xs = let (a,b) = splitAt n xs in a : chunk n b
06:44:40 <nmessenger> ?let groupN n = takeWhile (not . null) . unfoldr (Just . splitAt n)
06:44:41 <lambdabot> Defined.
06:44:51 <nmessenger> > groupN 3 [1..12]
06:44:52 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
06:45:52 <chessguy> ugh
06:45:56 <chessguy> see, this is my problem
06:46:01 <nmessenger> (credit goes to dons for that function)
06:46:11 <chessguy> i can write a lot of stuff with simple, raw recursion
06:46:35 <chessguy> but coming up with a solution like that....or even understanding that solution...just escapes me for some reason
06:46:40 <chessguy> unless i stare at it for 10 minutes
06:46:42 * Botje wakes up
06:46:42 <lambdabot> Botje: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:46:48 <nmessenger> @type unfoldr
06:46:50 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
06:47:37 <Botje> dons: That's very nice :)
06:47:46 <Botje> I'll study it for a while
06:47:50 <nmessenger> unfoldr f yanks a bunch of a's out of the seed 'b', and puts them in a resulting list
06:48:06 <Botje> but first i'm going to finish SPJones' "implementation of functional languages"
06:48:34 <chessguy> @type unfoldr
06:48:36 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
06:48:48 <chessguy> oh, that's where the maybe came from
06:49:17 <nmessenger> > take 20 $ unfoldr (\x -> Just (x, x+1)) 0
06:49:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
06:50:26 <nmessenger> splitAt helpfully puts the taken elements in the fst of the tuple, and leaves the dropped remainded in the snd
06:50:35 <nmessenger> remainder*
06:52:12 <Gotaku> Ok, so using getOpt I know have a list of program options entered into the command line. Now I'm not sure how to proceed...
06:52:37 <Gotaku> How do I allow the options to be accessable from other parts of my program?
06:53:50 <notsmack> Gotaku: pass them where they're needed, i'd imagine
06:54:39 <Gotaku> Is there a function that will pattern match elements in a list and return the first match found?
06:54:50 <chessguy> @pl groupN n = takeWhile (not . null) . unfoldr (Just . splitAt n)
06:54:51 <lambdabot> groupN = (takeWhile (not . null) .) . unfoldr . (Just .) . splitAt
06:56:13 <magic_user> is haskell as easy as lisp to add new features?
06:56:33 <chessguy> magic_user, sure. it's a constantly-growing language
06:56:52 <Botje> once you master monads, arrows, voodoo, and ritual sacrifice, sure!
06:57:37 <Botje> Gotaku: define 'pattern match' ?
06:57:59 <nmessenger> ?hoogle Eq a => [a] -> a -> Int
06:58:00 <lambdabot> No matches, try a more general search
06:58:01 <chessguy> ?remember Botje [magic_user] is haskell as easy as lisp to add new features?   [Botje] once you master monads, arrows, voodoo, and ritual sacrifice, sure!
06:58:01 <lambdabot> Done.
06:59:34 <nmessenger> magic_user: you could use the Template Haskell extension if you *really* need to bust up syntax trees, but it's mostly not needed.
07:00:10 * Botje wanders off to read some more
07:01:45 <Gotaku> Botje, do you know how getOpt works?
07:02:10 <magic_user> whats a monad?
07:02:17 <magic_user> is it like a gonad?
07:02:32 <Gotaku> In a way...
07:02:35 <nmessenger> @type find -- like this Gotaku?
07:02:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:02:42 <Gotaku> They are nuts after all.
07:02:46 <chessguy> @quote metaphore
07:02:47 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:02:53 <chessguy> @quote metaphor
07:02:53 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
07:02:56 <nmessenger> > find even [1,7,3,4,5]
07:02:57 <lambdabot>  Just 4
07:02:59 <magic_user> anyone here comparing commonlisp to haskell
07:03:01 <chessguy> monad-as-gonad?
07:03:21 <magic_user> also can haskell be used on unix as a sort of shell or is that a bad idea?
07:03:34 <chessguy> sure, it can be used to write scripts
07:03:51 <Gotaku> I can't figure out how I should get the options out of the list made by getOpt.
07:04:01 <magic_user> Im sick of bash and trying to get the fucker to give me just human readible lists of file fo certain siezes adn space on drives etc?
07:04:05 <nmessenger> @type getOpt
07:04:07 <lambdabot> Not in scope: `getOpt'
07:04:09 <wolfgangbeck> but the libs are either poorly documented or poorly implemented
07:04:10 <chessguy> http://www.haskell.org/haskellwiki/Unix_tools
07:04:11 <lambdabot> Title: Unix tools - HaskellWiki
07:04:12 <nmessenger> @index getOpt
07:04:13 <lambdabot> Distribution.GetOpt, System.Console.GetOpt
07:04:25 <nmessenger> @type System.Console.GetOpt.getOpt
07:04:27 <lambdabot> forall a. System.Console.GetOpt.ArgOrder a -> [System.Console.GetOpt.OptDescr a] -> [String] -> ([a], [String], [String])
07:05:16 <Donner> magic_user: man find.
07:06:17 <chessguy> Donner, aww, let him write it in haskell. it'll be good for him
07:10:29 <Gotaku> Basically my list looks like this: [White "test1.exe", Black "test2.exe"] and I want to pattern match (Black s) to the first Black data structure in the list.
07:10:29 <Botje> Gotaku: one way of doing it would be to have a record with all possible options your program can accept
07:11:09 <Botje> Gotaku: blacks = [ x | Black x <- opts ]
07:11:27 <Botje> > let opts = [White "test1.exe", Black "test2.exe"] in  [ x | Black x <- opts ]
07:11:28 <lambdabot>   Not in scope: data constructor `Black'
07:11:38 <Botje> argh :(
07:12:22 <Donner> Botje: I think, he is looking for dropWhile.
07:14:03 <Botje> *Main> let opts = [White "test1.exe", Black "test2.exe"] in  [ x | Black x <- opts ]
07:14:06 <Botje> ["test2.exe"]
07:14:29 <Botje> if there's no Black (something) in the list, the match will fail and that list will be empty
07:14:40 <Botje> so you could take the head of the resulting list
07:14:48 <Botje> and fail horribly by taking head of empty list :)
07:20:01 <chessguy> ?src head
07:20:01 <lambdabot> head (x:_) = x
07:20:01 <lambdabot> head []    = undefined
07:20:07 <Gotaku> Hm... Anyone know a program that uses getOpt?
07:21:12 <chessguy> Gotaku, try searching the wiki
07:21:26 <chessguy> i get several matches that look good
07:21:55 * dcoutts_ welcomes jtoy_ as the 300'th member of the channel
07:22:14 <jtoy_> thanks!
07:22:23 <beelsebob> yay, pimp v0.1 created
07:22:58 * Nafai watches the Liskell video
07:23:20 <roconnor> @users
07:23:21 <lambdabot> Maximum users seen in #haskell: 322, currently: 300 (93.2%), active: 44 (14.7%)
07:24:33 * nmessenger read the following blog link, was angry at all the false claims, almost wrote a nasty reply, realized how crazy that was, and tried to write a helpful, educational one.
07:24:35 <nmessenger> How'd I do?  http://kawagner.blogspot.com/2007/01/real-functional-programming-or-why-io.html
07:24:38 <lambdabot> Title: Karsten Wagner's Blog: Real functional programming or "Why the IO-monad is evil", http://tinyurl.com/23qh3t
07:25:09 <therp> nafai: I would be interested in your comment
07:25:24 <Nafai> therp: You're the liskell guy?
07:25:28 <therp> positive
07:25:32 <Nafai> sweet
07:25:37 <Nafai> comment coming forwith
07:26:07 <Binkley> "real functional programming"
07:26:12 <Binkley> who died and made him the functional programming god?
07:26:58 <Binkley> Haha, does he realize that the "solution" he suggested is how Haskell did IO before monads started getting used for that?
07:27:17 <roconnor> I'm not sure Karsten undrstands referential transparency in haskell.
07:27:41 <Binkley> roconnor: yeah, especially since he wrote "referential transparent"
07:28:10 <Binkley> I guess we know Haskell is successful by the amount of nonsense that's gteting writtne about it
07:28:22 <norpan> he is obviously uninformed
07:28:29 <nmessenger> Binkley: just don't allow yourself to write a "You're stupid" comment.  This is for *education*, not ridicule.
07:28:29 * roconnor isn't so happy about haskell becoming successful.
07:28:47 <Binkley> nmessenger: I'm not writing any comments there, that's why I'm saying it here instead :-)
07:29:04 <Binkley> your comment was good. I admire your self-restraint
07:29:18 <nmessenger> thank you much
07:29:51 <nmessenger> that article, IO inside, did open up my understanding of IO tremendously.
07:30:11 <norpan> when i started using the gofer system there were no IO monad
07:30:22 <norpan> you had to do this by hand
07:30:55 <norpan> but fortunately some clever people realized that the monad concept was a good one
07:31:32 <pejo> norpan, happen to remember offhand when Gofer acquired monads?
07:31:56 <norpan> i don't know but we switched to hugs
07:32:11 <bakert> ?hoogle liftIO
07:32:12 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
07:32:46 <nmessenger> A monad is just three operations: return, fmap, and join.  (>>=) can be defined as '\x k -> join (fmap k x)'
07:33:05 <bakert> ?type fmap
07:33:07 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:33:09 <nmessenger> (well, fmap if it properly implied Functor)
07:33:30 <norpan> both join and fmap can be implemented in terms of >>= though
07:34:05 <nmessenger> but fmap also needs return
07:34:10 <norpan> yes
07:34:25 <norpan> so you only need return and >>=
07:34:37 <altug> ?type filter
07:34:37 <Nafai> therp: Very cool; the intersection of the 3 languages was nice...I think I might understand Liskell better than standard Haskell...since I'm new to Haskell but a have a little experience with Lisp
07:34:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:34:40 <bakert> ?paste
07:34:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:34:54 <altug> ?type map
07:34:56 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:35:02 <hpaste>  bakert pasted "Problem with two monads." at http://hpaste.org/220
07:35:14 <bakert> Folks I'd really appreciate a hand with what I've pasted.
07:35:33 <malsyned> Can anybody tell me where to go to satisfy the cabal dependency "plugins>=1.0"?
07:35:35 <bakert> I'm trying to wrap some error handing around something but then return in the CGI monad
07:36:05 <bakert> I've tried putting liftIO in various places a bit hopelessly to no avail.  I'd really appreciate it if someone who knows what they are doing would have a look.
07:36:28 <bakert> The underlying routine "enterTrans" works fine if I call it direct, but doesn't handle any exceptions.
07:36:34 <therp> nafai: good to hear that :) thanks. I hope you haven't had any problems playing that FLV file.. with mplayer no problem, but beware, if one doesn't have mplayer :)
07:36:40 <bakert> http://hpaste.org/220
07:36:50 <Nafai> therp: Yeah, I used mplayer :)
07:37:39 <bakert> I think the problem is that I am in a "do" block for IO.  So when I say return it means return in IO.  But I want to return in CGI.
07:37:54 <bakert> Is liftIO the secret here?
07:38:02 <dino-> bakert: Looking at it. But I'm pretty shaky with monadic stuff still.
07:38:27 <bakert> thanks dino-
07:38:29 <malsyned> bakert: I have no experience with this, so take me with a grain of salt, but every example of two monads I've seen so far required knowledge of monad transformers.
07:38:41 <malsyned> (knowledge I don't have so far.)
07:38:50 <bakert> ah.
07:39:04 <dino-> Well,I think he's onto something in that lifting is useful too, in the absense of transformers. I hope I'm not full of shit on that.
07:39:08 <cjeris> bakert: liftIO will work if (instance MonadIO CGI).
07:39:46 <bakert> cjeris, that is the case.  I think actually the problem might be that I am doing the lifting in the underlying enterTrans.  I will post that too.
07:40:02 <dino-> But this is in the CGI monad, yes? Maybe liftM something?
07:40:05 <malsyned> nobody knows what package satisfies plugins>=1.0, huh?
07:40:16 <hpaste>  bakert annotated "Problem with two monads." with "enterTrans as well as enterTrans2" at http://hpaste.org/220#a1
07:40:46 <bakert> perhaps i need to change enterTrans to be in IO only then do the liftIO or whatever in enterTrans2?
07:41:06 <chessguy> malsyned, i believe when i ran into that, i was told to just remove that requirement
07:41:16 <chessguy> when trying to build lambdabot
07:41:35 <malsyned> yeah, that's exactly what I'm trying to do.
07:41:49 <chessguy> then that's what i'd recommend
07:42:49 <malsyned> I'm surprised it'll work without it.  OK.
07:43:08 <malsyned> I thought it was talking about the hs-plugins package, but according to apt I've got that installed.
07:43:30 <malsyned> oh.  I have it installed, but it's at 0.9.10.  nm.
07:44:10 <chessguy> plugins != hs-plugins
07:44:27 <bakert> ?hoogle liftM
07:44:28 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
07:44:29 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
07:44:29 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
07:45:50 <malsyned> chessguy: what about fps>=0.7?
07:46:01 <bd_> ?where binary
07:46:02 <lambdabot> http://darcs.haskell.org/binary
07:46:24 <Dybber> I wan't to load in a complete file modify some things and write it back again, but because of haskells lazyness the readFile isn't finish when i start writing and i get an error saying that the file is in use. How do I handle this?
07:46:33 * Dybber is confused
07:46:40 <dino-> Ok, so try is what gets this in IO in the first place?
07:47:12 <bd_> dino-: try?
07:47:17 <bakert> dino-, i suppose so.  enterTrans enters a row in a postgresql database (if it can).
07:47:24 <dino-> r <- try (enterTrans values)
07:47:32 <bd_> Dybber: You can save to a different file, then rename over. Or rename before opening.
07:47:41 <bakert> dino-, but then using a tricky line of code I don't completely comprehend manageds to return in CGI.
07:48:08 <bakert> dino-, so perhaps what I need to do is make enterTrans be in IO and then do that trickiness in enterTrans2 instead.
07:48:09 <malsyned> lemme guess: lambdabot requires ghc 6.6
07:48:11 <bakert> dino-, perhaps.
07:48:13 <bd_> Dybber: If your dataset will fit in memory, you could force strictness with eg evaluate (length s) - though if you're going to do that ,look into Data.ByteString.readFile or Data.ByteString.Char8.readFile
07:49:36 <Dybber> bd_ i will take a look at that. Its just a file with some ASCII text
07:55:12 <cain--> hi all
07:55:39 <cain--> what does this mean
07:55:40 <cain--> filter ((\x y -> (mod y x) /= 0) x
07:56:27 <roconnor> mismatched parenteses?
07:56:50 <cain--> english please
07:56:52 <cain--> ;)
07:56:56 <Igloo> It's not valid Haskell
07:57:12 <Igloo> Oh, no, I see how it's meant to be bracketed
07:57:25 <cain-->  sieben :: [Int] -> [Int]
07:57:25 <cain-->  sieben []     = []
07:57:25 <cain-->  sieben (x:xs)     = x : sieben (filter ((\x y -> (mod y x) /= 0) x) xs)
07:58:14 <Igloo> The last line is equivalent to    sieben (x:xs) = x : sieben (filter (\y -> (mod y x) /= 0) xs)    if that helps you
07:58:14 <roconnor> ooh, that can be simplifed
07:58:39 <roconnor> @unpl (filter ((\x y -> (mod y x) /= 0) x) xs)
07:58:39 <lambdabot> (filter (\ y -> (mod y x) /= 0) xs)
07:59:01 <cain--> hmm
07:59:06 <roconnor> which is what Igloo wrote
07:59:11 <cain--> y
07:59:16 <cain--> but what does it mean
07:59:26 <cain--> i found it somewhere but dont understand it
07:59:44 <Binkley> what about it isn't clear?
07:59:51 <roconnor> it is removing all elements form xs that are congruent to 0 mod x.
07:59:56 <cain--> \ y eg
08:00:12 <cain--> and where does the y come from
08:00:17 <cain--> its not defined before
08:00:22 <roconnor> (\y -> expr) is an anonymous function
08:00:22 <malsyned> cain--: "\x ->" is lambda notation.  anonymous function notation.
08:00:39 <roconnor> > ((\x -> x + 1) 3)
08:00:40 <lambdabot>  4
08:00:54 <cain--> ohh
08:01:02 <cain--> so x + 1 is called three  times?
08:01:04 <malsyned> saying "\y -> 2 * y" means "the function which takes a single argument y and returns 2 * y"
08:01:16 <malsyned> cain--: no, x + 1 is called _on_ 3.
08:01:25 <roconnor> and the result is 4
08:01:26 <thief_grr> cain--: no, it's one function, x+1
08:01:27 <cain--> ok
08:01:51 <thief_grr> > ((\x -> x*2) 3)
08:01:53 <lambdabot>  6
08:01:56 <malsyned> cain--: "f x = 2 * x" is the same as "f = \x -> 2 * x"
08:02:00 <cain--> ok so 3 is an argument
08:02:06 <malsyned> cain--: yes, 3 is an argument
08:02:06 <cain--> no
08:02:13 <cain--> ok
08:02:18 <thief_grr> yes, and \ is supposed to look like a lambda ;)
08:02:39 <dino-> Ok, sorry, had a phone call.
08:02:42 <malsyned> what you wrote is filtering based on its first argument, and its first argument is a function with no name that someone custom-rolled just to do that filter.
08:03:05 <cain--> it has a name but german ;)
08:03:15 <cain--> its erastotenes
08:03:34 <cain--> calculating primes
08:03:34 <dino-> I have to say that I'm having a lot of trouble understand what's going on in this enterTrans stuff.
08:03:44 <dino-> ^ing
08:04:12 <cain--> ok thank you
08:04:44 <Igloo> cain--: It has the same name in English (possibly spelt differently), but the (\y -> (mod y x) /= 0) is a function with no name (an anonymous function)
08:04:59 <cain--> ohh ok
08:05:04 <cain--> now i see
08:05:08 <Igloo> As opposed to    f y = (mod y x) /= 0   which is a function with a name (f)
08:05:10 <dino-> I guess the type of the try (enterTrans values) is IO (Either IOError (CGI Html))
08:05:33 <dino-> So, after the <-, r is taken out of the outer IO
08:06:37 <malsyned> cain--: With anonymous functions, sometimes it can be helpful to give them local names to clarify intention: sieben (x:xs) = x : sieben (filter multiple xs) where multiple x y = (mod y x) /= 0
08:07:04 <malsyned> (I didn't try to run that, hopefully there aren't any syntax errors)
08:07:24 <cain--> aaahh
08:07:32 <cain--> i get what you mean
08:07:33 <dino-> Then, in the Right r -> return r case, it evaluates to an IO (CGI Html)
08:08:00 <nmessenger> the lambda just yanks out the 'multiple' name and drops the function in directly
08:10:45 <roconnor> sieben (x:xs) = x : sieben (filter multiple xs) where multiple y = (mod y x) /= 0
08:11:07 <roconnor> or sieben (x:xs) = x : sieben (filter (multiple x) xs) where multiple x y = (mod y x) /= 0
08:11:33 <malsyned> roconnor's right.  in my haste to rewrite it I completely mangled it.
08:11:45 <roconnor> only a little mangled ;)
08:12:00 <malsyned> I got the point across :-)
08:12:42 <nmessenger> it does seem like a race for "who can write the demonstration code first" in this channel
08:12:50 <nmessenger> I like it :)
08:13:33 <malsyned> does lambdabot live in a channel that isn't for normal traffic, so I can play with it without flooding #haskell with commands?
08:13:53 <cain--> hey this is fanially a channel where someone helps you and not post some links to read those
08:13:58 <notsmack> malsyned: /msg
08:14:37 <malsyned> nmessenger: it's because you can actually write one-liners that do useful things in Haskell.  Probably something about always being able to abstract away superfluous details.
08:14:47 <malsyned> notsmack: ah.  thanks.
08:14:50 <nmessenger> malsyned: start with '/msg lambdabot @' to get a long list of commands, then '/msg lamdabot @help some-command' for what you're interested in.
08:15:32 <nmessenger> also '@list command' to get related commands
08:15:43 <chessguy> @yhjulwwiefzojcbxybbruweejw
08:15:44 <lambdabot> Just 'J'
08:15:49 <nmessenger> @arr!
08:15:49 <lambdabot> Keelhaul the swabs!
08:16:03 <nmessenger> @protontorpedo
08:16:04 <lambdabot> is there an oo db in haskell?
08:16:28 <xerox> ?keal
08:16:29 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
08:16:55 <nmessenger> @vixen Unfortunately, you don't work right now.
08:16:56 <lambdabot> <undefined>
08:17:34 <chessguy> @quote nmessenger
08:17:35 <lambdabot> nmessenger says: (>:[) -- < vampire operator
08:17:57 <nmessenger> unfortunately that's a syntax error.  *blush*
08:18:05 <malsyned> so "where" is just a table lookup?  and here I thought it cleverness was involved.
08:18:38 <chessguy> ?help where
08:18:39 <lambdabot> where <key>. Return element associated with key
08:18:48 <nmessenger> @where lambdabot
08:18:49 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
08:19:18 <nmessenger> @quote chessguy
08:19:19 <lambdabot> chessguy says: i didn't think pennsylvania had anybody cool enough to know haskell in it
08:19:32 * nmessenger is appalled
08:19:44 <chessguy> hm?
08:19:50 <nmessenger> :P joking
08:21:06 <malsyned> So superficially, Microsoft's new command shell seems to have some behavior that was inspired by Haskell.  Any chance Simon Peyton Jones was involved at all?
08:21:27 <chessguy> malsyned, link?
08:21:50 <nmessenger> Heh, it was codenamed 'Monad' for goodness sake.
08:21:53 <malsyned> chessguy: I'm going from memory.  the last thing I read about MSH was on Ars several months ago.
08:22:06 <malsyned> I don't know much about it, I'm just reacting to a gut feeling.
08:22:14 <nmessenger> @google Windows Powershell
08:22:15 <malsyned> I'm thinking specifically about how piping behaves a lot more like function composition than like traditional character-based Unix piping.
08:22:17 <lambdabot> http://www.microsoft.com/windowsserver2003/technologies/management/powershell/default.mspx
08:22:17 <lambdabot> Title: Windows PowerShell
08:22:20 <chessguy> reacting to something you read several months ago?
08:22:35 <malsyned> chessguy: I didn't know Haskell several months ago.  It took a while for the connection to form in my brain.
08:22:45 <chessguy> ah
08:23:24 <malsyned> nmessenger: you're right, that's pretty telling.
08:26:35 <nmessenger> Though I also didn't know Haskell when I first heard of it.  "Monad" was a nonce word to me.
08:28:53 <velco> what can I use to map a Data.Tree ?
08:29:32 <xerox> :t fmap
08:29:34 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
08:29:43 <xerox> :instances Functor
08:29:55 <nmessenger> @instances-importing Data.Tree Functor
08:29:56 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Tree, Writer w, WriterT w m, []
08:31:17 <xerox> obscure design.
08:31:38 <malsyned> What they're trying to say, xerox, is that Tree is an instance of Functor, which means it has an fmap function which can map over the tree.  fmap is kindof a generic map for anything that's a Functor.
08:32:08 <nmessenger> malsyned: @ velco maybe?
08:32:17 <malsyned> er, yeah, you're right.
08:32:34 <malsyned> I was trying to talk to velco.
08:32:46 <velco> thanks, I just wanted to try before I say "thanks" :)
08:32:53 <Donner> xerox: The other way around: A functor is something which can apply a function inside.
08:34:55 <velco> hmm, some how ``fmap shot t'' didn't work as I expected ...
08:35:03 <velco> fmap show t, even
08:35:25 <xerox> :t fmap show
08:35:26 <malsyned> velco: it didn't return a Data.Tree [Char]?
08:35:26 <lambdabot> forall (f :: * -> *) a. (Functor f, Show a) => f a -> f String
08:35:46 <xerox> :t Data.Tree.drawTree
08:35:47 <velco> oh, my error
08:35:48 <lambdabot> Tree String -> String
08:36:07 <velco> I was passing it [Tree], map (fmap show) t worked just as I wanted it
08:36:11 <xerox> :t putStrLn . Data.Tree.drawTree . fmap show
08:36:13 <lambdabot> forall a. (Show a) => Tree a -> IO ()
08:36:57 <malsyned> ah.  right.  lists are also Functors, and fmap is the same as map on them.
08:39:19 <nmessenger> @type fmap
08:39:21 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
08:39:22 <nmessenger> @type map
08:39:24 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
08:39:29 <nmessenger> f = []
08:40:11 <nmessenger> ?src [] fmap
08:40:12 <lambdabot> fmap = map
08:40:20 <nmessenger> there you have it :D
08:40:42 <earthy> *oooh* Doaitse on a roll on the haskell-cafe!
08:41:04 <earthy> "Of course if we have the following expression:
08:41:04 <earthy>  digest.chew.eat.serve.cook.chop.pluck.kill $ chicken
08:41:06 <earthy> we all have a definite feeling that after applying the functions, the original object is no longer available, and the FP view does not feel entirely natural."
08:41:44 <chessguy> the man has a good point
08:41:50 <Dybber> How do i move a file?
08:41:53 <earthy> he often does. ;)
08:41:58 <Syzygy-> earthy: o.O
08:42:04 <earthy> dybber: using mv? or do you mean with haskell functions?
08:42:14 <dylan> is it possible to hoogle the xlib bindings yet?
08:42:18 <Dybber> earthy, with haskell functions :)
08:42:26 <nmessenger> ?hoogle FilePath -> FilePath -> IO ()
08:42:27 <lambdabot> Directory.renameDirectory :: FilePath -> FilePath -> IO ()
08:42:28 <lambdabot> Directory.renameFile :: FilePath -> FilePath -> IO ()
08:42:28 <lambdabot> System.Directory.copyFile :: FilePath -> FilePath -> IO ()
08:42:49 * nmessenger hugs lambdabot
08:43:02 <nmessenger> @botsnack
08:43:03 <lambdabot> :)
08:43:09 <Dybber> thanks
08:43:23 <dcoutts_> this month's TMR is so good!
08:43:31 * dcoutts_ reads more about mdo
08:43:52 * earthy liked TMR
08:43:56 <chessguy> very long though
08:44:05 <earthy> nice hour worth of reading
08:44:22 <bakert> hi folks.  turns out what I needed was tryCGI which is a version of try for CGI monads
08:44:28 <bakert> if you were here a while ago
08:44:30 <bakert> ...
08:45:37 <malsyned> bakert: that's a function that's part of the CGI monad module?
08:45:40 <chessguy> bakert, t hanks for the update
08:45:53 <malsyned> is it just me, or does anybody else find the special case code for unary negation with (-) to be more trouble than its worth?  (or perhaps just a botched implementation of a nice initial idea)
08:45:59 <bakert> malsyned, yeah it is in Network.NewCGI.  doh.
08:46:45 <nmessenger> malsyned: well, choosing between negate and subtract is not obvious.  One has to be picked.
08:47:10 <dcoutts_> the mdo assembly TMR article is so cute, it uses Haskell as an assembler and of course lets you use the whole haskell language as a macro assembler :-)
08:47:15 <cain--> if i have an infinite list and i want to chek if an element ist _not_ part of it, how is this done?
08:47:31 <cain--> (the elements are "sorted" ascending)
08:48:04 <chessguy> @type takeWhile
08:48:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:48:15 <chessguy> err
08:48:19 <chessguy> @type dropWhile
08:48:21 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:48:21 <nmessenger> @type \yourElem -> not . find (==yourElem)
08:48:23 <lambdabot>     Couldn't match `Bool' against `Maybe a'
08:48:23 <lambdabot>       Expected type: [a] -> Bool
08:48:33 <chessguy> nmessenger, infinite list
08:48:38 <chessguy> that's not such a good idea
08:49:04 <nmessenger> aye, it terminates only if true
08:49:18 <malsyned> cain--: why would you want to do such a thing?
08:50:00 <nmessenger> malsyned: unless perhaps it was resolved based on types, but that sounds like a swamp: (- 3) 4 = (subtract 3) 4, (-3) + 1 = (negate 3) + 1
08:50:06 <dino-> boo, nomaware.com down
08:50:14 <malsyned> nmessenger: I think it would have been less confusing to make (-) always the subtraction operator and require explicit negation (maybe shortening the name of the function to "neg" in honor of its probable more frequent usage)
08:50:48 <chessguy> > let notIn elem list = (head (dropWhile (\x -> x < elem) list)) == elem in notIn 10 [1..]
08:50:49 <lambdabot>  True
08:50:53 <chessguy> > let notIn elem list = (head (dropWhile (\x -> x < elem) list)) == elem in notIn 10 [11..]
08:50:54 <lambdabot>  False
08:51:01 <dino-> Can anyone else see this: http://www.nomaware.com/monads/html/
08:51:19 <nmessenger> "Can't find server"
08:51:21 <malsyned> dino-: that site's been down for days and days.  I was really getting into the Monad tutorial they had, too.
08:51:47 <dino-> malsyned: :o  I had no idea.
08:51:57 <Gotaku> How would I run a process and print it's stdout output?
08:52:15 <malsyned> oh!  I missed the big where cain-- said the list was sorted ascending.
08:52:21 <nmessenger> chessguy: that still doesn't terminate if the predicate isn't satisfied
08:52:37 <chessguy> but it always will be
08:53:26 <malsyned> Gotaku: you can use System.system and System.rawSystem if you just want its output to stay on stdout.  If you want to capture its output and do something with it, that's more complicated.
08:53:53 <Gotaku> Well I need to capture it's output and send stuff to it's input also.
08:54:05 <dino-> mm, like expect-behavior
08:54:14 <nmessenger> @index runInteractiveProcess
08:54:18 <lambdabot> System.Process
08:54:22 <dylan> how do I catch parse errors with read?
08:54:22 <dylan> e.g.
08:54:26 <dylan> > read "foo" :: Int
08:54:27 <lambdabot>  Exception: Prelude.read: no parse
08:54:27 <nmessenger> @type System.Process.runInteractiveProcess
08:54:29 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
08:54:45 <int-e> > reads "foo" :: [(Int, String)]
08:54:47 <lambdabot>  []
08:54:53 <int-e> > reads "42 foo" :: [(Int, String)]
08:54:55 <lambdabot>  [(42," foo")]
08:54:59 <dylan> > read "foo" :: Maybe Int
08:55:00 <Gotaku> Yes I am using that function and I got the handles but now I don't know what to do.
08:55:00 <lambdabot>  Exception: Prelude.read: no parse
08:55:19 <int-e> dylan: use reads directly
08:55:21 <chessguy> nmessenger,can you break my solution?
08:55:25 <dylan> ah, right.
08:55:46 <nmessenger> chessguy: I can't understand why notIn 10 [11..] terminates
08:55:52 <malsyned> Gotaku: hGetLine and hPutStrLn
08:55:54 <int-e> dylan: case reads x of (val :: Int, "") -> success; _ -> error
08:56:45 <nmessenger> wait, /me reads it again
08:57:11 <int-e> dylan: sorry, that should be  [(val :: Int, "")]  of course.
08:57:45 <nmessenger> > let notIn elem list = (head (dropWhile (\x -> x < elem) list)) == elem in notIn 10 [11, 5]
08:57:47 <lambdabot>  False
08:57:49 <bakert> ?hoogle String -> String
08:57:50 <lambdabot> Network.URI.normalizeCase :: String -> String
08:57:50 <lambdabot> Network.URI.normalizeEscape :: String -> String
08:57:50 <lambdabot> Network.URI.normalizePathSegments :: String -> String
08:58:20 <bakert> Is there a "trim" function in a library somewhere (strip whitespace from both ends)?
08:58:30 <Gotaku> malsyned, hGetLine doesn't work.
08:58:41 <dylan> let readMaybe s = case reads s of [] -> Nothing; (a, _) : _ -> Just a
08:59:22 <malsyned> Gotaku: the documentation for runInteractiveProcess mentions forkIO.  maybe you have to use that to get the process to run?  I'm not sure.
08:59:32 <malsyned> nmessenger: you know?
08:59:39 <Gotaku> I tried that too.
09:00:32 <nmessenger> malsyned: reading...
09:01:36 <nmessenger> malsyned: no, the forkIO just allows that example code to write to the process in the background
09:01:47 <cain--> i dont get this: let notIn elem list = (head (dropWhile (\x -> x < elem) list)) == elem in notIn 10 [1..]
09:01:58 <cain--> how can i use it?
09:02:04 <dylan> let readMaybe x = liftM fst $ (listToMaybe (reads x))
09:02:05 <cain--> im confused about the elem
09:02:28 <cain--> is it a function or varialbe
09:02:41 <malsyned> cain--: elem is the element to search for.  list is the (sorted) list to search for it in.
09:03:14 <malsyned> dropWhile (\x -> x < elem) returns the tail of the list starting at the first element >= elem
09:03:22 <Gotaku> If I all hGetLine on the output handle it just sits there blocking...
09:03:56 <cain--> ohh i see
09:04:04 <glguy> good morning
09:04:20 <malsyned> good morning, he says, as my clock strikes noon ;-)
09:05:06 <nmessenger> Gotaku: well, eh-heh, It might be required, then.
09:05:33 * nmessenger not actually having used said function
09:05:43 <bakert> ?localtime glguy
09:05:46 <lambdabot> Local time for glguy is Wed Jan 31 11:01:11 2007
09:06:54 <chessguy_work> 'morning glguy
09:07:01 <malsyned> so basically, every time someone asks a question in #haskell that can be answered algorithmically, somebody else writes a lambdabot plugin to answer the question?
09:07:05 <glguy> malsyned: In my book that is close enough to morninf
09:07:46 <csci> Hi, what is the simplest way to define a function split :: a -> [a] -> [[a]], which splits a list according to a
09:07:58 <malsyned> csci: use the one that already exists in MissingH
09:08:01 <csci> And why is such a function not defined in Prelude
09:08:12 <csci> malsyned, Oh, never head of MissingH
09:08:16 <csci> malsyned, Thank
09:08:16 * glguy is playing with Dvorak. Please excuse my spelling
09:08:21 <malsyned> csci: to give the MissingH guys something to do ;-)
09:08:29 <csci> malsyned, :D
09:08:34 <malsyned> ?where missingh
09:08:35 <lambdabot> http://software.complete.org/missingh
09:09:15 * nmessenger wants to learn Dvorak
09:09:26 * csci wants to learn Haskel
09:09:29 <csci> ...l
09:09:53 <Vq^> csci: great :)
09:10:09 <malsyned> Dvorak's a good way to discourage people from using your computer.  especially if you don't change your keycaps.
09:10:10 <nmessenger> > let split n = takeWhile (not . null) . unfoldr (Just . splitAt n) in split 3 [1..12]
09:10:12 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
09:11:09 <malsyned> nmessenger: is that splitting into lists of a specific length?
09:11:13 <nmessenger> though 'split' is used elsewhere in the libraries.  I prefer 'groupN'
09:11:39 <malsyned> I think he wants "split" like the perl spit.
09:11:40 <malsyned> er
09:11:41 <malsyned> split
09:11:52 <nmessenger> malsyned: yeppers, did you see the expression it's used in?
09:11:54 <csci> jup
09:12:02 <nmessenger> oh, silly me
09:12:09 <cain--> whats wrong here:
09:12:10 <cain--> isPrim y = notIn y primes
09:12:10 <cain--> 		where notIn y primes = (head (dropWhile (\x -> x < y) primes)) == y in notIn y primes
09:12:26 <glguy> malsyned: locking your comptuer is also a good way?
09:12:28 <glguy> :)
09:13:23 <Botje> why the "in notIn y primes" at the end?
09:14:13 <malsyned> cain--: you misunderstood the example.  the first half of the expression that was given was supposed to be the function, the second half was a demonstration.
09:14:42 <malsyned> if you remove the "in notIn y primes" it should work.
09:14:54 <cain--> ok
09:16:33 <matthew_-> err, how do I avoid writing if a < b then LE else if a > b then GT else EQ ?
09:17:03 <cain--> | a<b = LE
09:17:11 <cain--> | b<a =
09:17:16 <cain--> ;)
09:17:25 <Saizan> ?hoogle (Ord a) => a -> a -> Ordering
09:17:26 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
09:17:37 <cain--> | otherwise = EQ
09:17:53 <cain--> @matthe
09:17:54 <lambdabot> Unknown command, try @list
09:17:57 <cain--> @matthew
09:17:58 <lambdabot> Unknown command, try @list
09:18:10 <cain--> matthew_-
09:18:17 <ToRA> compare a b ?
09:18:23 <matthew_-> r = sortBy (\a@(_, _, aD) b@(_, _, bD) -> compare aD bD)
09:18:25 <matthew_-> thanks
09:18:26 <nmessenger> @quote matthew-_
09:18:27 <lambdabot> matthew-_ says: wow, haskelldb is amazing. the type system tells me when I've forgotten to select certain columns!
09:18:34 <matthew_-> true
09:18:37 <matthew_-> it is amazing
09:18:43 <matthew_-> I stand by that quote
09:18:54 <malsyned> :t compare
09:18:56 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:19:02 <nmessenger> > compare 1 2
09:19:03 <lambdabot>  LT
09:19:16 <chessguy_work> @type Ordering
09:19:17 <lambdabot> Not in scope: data constructor `Ordering'
09:19:24 <Botje> malsyned: you don't need the a@ and b@
09:19:29 <matthew_-> indeed
09:19:32 <Botje> eh, matthew_- even
09:19:33 <matthew_-> I realise that now ;)
09:19:33 <malebria> @hoogle (a -> a) -> [a]
09:19:34 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
09:19:35 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:19:35 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:19:36 <malebria> @hoogle (a -> a) -> [a] -> [a]
09:19:37 <nmessenger> @src Ordering
09:19:37 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:19:37 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:19:37 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
09:19:39 <lambdabot> data Ordering = LT | EQ | GT
09:20:00 <Botje> matthew_-: you can also define comparing f a b = (f a) `compare` (f b)
09:20:03 <matthew_-> mmm. that ?src misses out deriving (Show, Eq, Ord)
09:20:21 <Botje> then you can say sortBy (comparing trd)
09:20:29 <Botje> (where trd (_,_,x) = x
09:20:39 <matthew_-> true
09:20:54 <matthew_-> that's quite nice. provided ghc optimises it out ;)
09:21:01 * matthew_- has performance concerns
09:21:20 <Botje> it probably does
09:21:49 <Gotaku> Why won't this work...
09:22:09 * Botje is happily playing settlers 2 in dosbox
09:22:09 <Botje> whee :)
09:22:32 <xerox> Screenshot! (:
09:23:19 <matthew_-> mmm. I presume I'm being dumb. Is there a function for (head . dropWhile) ?
09:23:35 <glguy> find?
09:23:44 <matthew_-> it feels like the kind of thing that'd be in the prelude.
09:23:45 <xerox> ?type findElem
09:23:46 <matthew_-> ahh. ok
09:23:47 <malsyned> :t (head.dropWhile)
09:23:47 <lambdabot> Not in scope: `findElem'
09:23:48 <xerox> ?type findElems
09:23:49 <lambdabot>     Expecting a function type, but found `b'
09:23:50 <lambdabot>       Expected type: (a1 -> Bool) -> [a]
09:23:50 <lambdabot> Not in scope: `findElems'
09:23:54 <glguy> ?type find
09:23:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:24:05 <nmessenger> ?type ((head .) . dropWhile)
09:24:06 <lambdabot> forall a. (a -> Bool) -> [a] -> a
09:24:07 <xerox> ?type (elemIndex,elemIndices)
09:24:09 <lambdabot> forall a a1. (Eq a, Eq a1) => (a -> [a] -> Maybe Int, a1 -> [a1] -> [Int])
09:24:28 <matthew_-> cheers guys
09:24:46 <Gotaku> How do I run a process with runInteractiveProcess and capture it's stdout output?
09:24:49 <Botje> http://botje.kicks-ass.net:8080/dries/temp/settlers2.png
09:24:51 <glguy> > (head (dropWhile even [2,4,6,8,9]), find (not . even) [2,4,6,8,9])
09:24:53 <lambdabot>  (9,Just 9)
09:25:23 <notsmack> Botje: 404
09:25:38 <malsyned> I'm surprised lambdabot didn't tell everybody about the 404.
09:25:41 <Botje> argh
09:25:54 <glguy> !paste
09:25:54 <hpaste> Haskell paste bin: http://hpaste.org/
09:26:06 <malsyned> does google code search index haskell projects?
09:26:09 <Botje> oh
09:26:10 <matthew_-> ?check \x -> let a = (head (dropWhile even x)); b = fromJust $ find (not . even) x in a == b
09:26:11 <Botje> http://botje.kicks-ass.net:8080/dries/temp/settlers.png
09:26:11 <lambdabot>  Add a type signature
09:26:16 <Botje> silly webserver
09:26:18 <glguy> ugh, since upgrading to PuTTY 0.59, my connections take forever to complete
09:26:32 <matthew_-> ?check \(x:[Int]) -> let a = (head (dropWhile even x)); b = fromJust $ find (not . even) x in a == b
09:26:33 <lambdabot>   Not in scope: data constructor `Int'
09:26:44 <notsmack> man, i miss settlers 2.
09:26:44 <matthew_-> oops!
09:27:07 <hpaste>  eddyp pasted "weird Yikes" at http://hpaste.org/221
09:27:40 <nmessenger> ?check (\x -> head (dropWhile even x == fromJust (find (not . even) x)) :: [Int] -> Bool
09:27:41 <lambdabot>  Parse error
09:27:46 <matthew_-> ?check (\x -> let a = (head (dropWhile even x)); b = fromJust $ find (not . even) x in a == b):: [Int] -> Bool
09:27:47 <lambdabot>  Exception: Prelude.head: empty list
09:27:54 <matthew_-> you see, that's annoying
09:27:59 <matthew_-> they'll both error in the same cases
09:28:01 <malsyned> Gotaku: I'd recommend poking through http://www.google.com/codesearch?as_q=runInteractiveProcess&btnG=Search+Code&hl=en&as_lang=haskell&as_license_restrict=i&as_license=&as_package=&as_filename=&as_case=y for examples of it in action, see how other people use it.
09:28:04 <lambdabot> Title: runInteractiveProcess lang:haskell - Google Code Search, http://tinyurl.com/yuoy2m
09:28:09 <matthew_-> head [] and fromJust Nothing
09:28:10 <bakert> malsyned, if not try krugle.com?
09:28:14 <matthew_-> so they should be ==
09:28:44 <malsyned> Google code search does haskell.  w00t.
09:28:54 <mbishop> it has for a while
09:29:04 <mbishop> I think they added all the ML based languages at the same time heh
09:29:09 <nmessenger> I've not used Google code search
09:29:18 <hpaste>  eddyp annotated "weird Yikes" with "Yikes-changes" at http://hpaste.org/221#a1
09:29:21 <xerox> Botje: oooh.
09:30:46 <malsyned> nmessenger: http://www.google.com/codesearch
09:30:47 <lambdabot> Title: Google Code Search
09:31:01 <malsyned> subtitle "Search public source code"
09:31:07 <nmessenger> yes, looks nifty
09:32:39 <mbishop> I usually end up just doing my own google code search with filetype:hs or scm or whatever
09:33:04 <hpaste>  eddyp annotated "weird Yikes" with "record result" at http://hpaste.org/221#a2
09:34:11 <Saizan> it should be a type-sensitive search :D
09:34:26 <malsyned> Saizan: the advanced search has a check-box for case-sensitivity.
09:35:11 <malsyned> I agree, though, that should probably be the default.  Maybe they get a lot of searches for VB code or something.
09:35:36 <Saizan> type-sensitive as you can specify the type of the function you are looking for :P
09:35:59 <malsyned> oh!  /type/ sensitive.  yeah.  that's harder.
09:36:21 <malsyned> I typically use hoogle for that.  I just wish hoogle had access to more library docs.
09:36:41 <matthew_-> can you install hoogle yourself on your own code base
09:37:05 <xinming> anyone here can tell me if the server which serves <<All About Moands>> is down?
09:37:31 <mbishop> That therp is one crazy mother...
09:37:33 <malsyned> xinming: It's been down for like a week.  I'm bummed.
09:37:49 <malsyned> You're the second person today to ask about it.
09:38:06 <malsyned> wish I knew what was wrong or if it was ever coming back.
09:38:47 <xinming> It's seems, author's domain name has been expired. :-)
09:38:50 <mbishop> http://72.14.209.104/search?q=cache:UJ2spam_St4J:www.nomaware.com/monads/+all+about+monads&hl=en&gl=us&ct=clnk&cd=1&client=firefox-a
09:38:52 <lambdabot> http://tinyurl.com/237fwl
09:40:18 <nmessenger> hmm, the links don't link inside the cache :(
09:40:21 <ctkrohn> xinming: I have a PDF of it, if you'd like
09:40:22 <mbishop> google cache needs to start prefixing links in the cache
09:40:23 <mbishop> yeah heh
09:40:30 <malsyned> ctkrohn: I would
09:40:41 <xinming> ctkrohn: url please. :-)
09:40:46 <ctkrohn> actually, I found the PDF online after the site was down... let me just find the URL again
09:41:16 <ctkrohn> unfortunately the PDF makes acrobat run slow for some reason... then again my computer isn't the fastest around
09:41:51 <mbishop> http://abaris.zoo.cs.uu.nl:8080/wiki/pub/Afp/DiscussionForum/Newbern-monads.pdf
09:41:53 <Saizan> acrobat is not the fastest pdf reader either
09:41:57 <lambdabot> http://tinyurl.com/3cww9o
09:42:20 <ctkrohn> mbishop: ah, thanks, that was what I was looking for
09:42:25 <mbishop> :P
09:42:37 <xinming> thanks
09:42:40 <ctkrohn> mbishop: I would use Preview, but it screws up the fonts in lots of documents I have
09:42:50 <ctkrohn> err
09:42:53 <ctkrohn> that was directed to Saizan :D
09:43:04 <xerox> ctkrohn: I fallback on xpdf.
09:43:39 <malsyned> totally great.  thanks ctkrohn
09:43:57 <therp> mbishop :) ?
09:44:08 <malsyned> ctkrohn: what OS are you trying to read it on?
09:44:29 <mbishop> therp: Your Liskell stuff made it to the reddit page :P
09:44:47 <ctkrohn> malsyned: I run MacOS
09:44:57 <syntaxfree> this sounds too big to be true:
09:44:59 <syntaxfree> http://clemens.endorphin.org/weblog/archives/2007-01.shtml
09:45:00 <lambdabot> Title: clemens.endorphin.org/weblog - January 2007 Archives - clemens.endorphin.org
09:45:01 <syntaxfree> "Why is Lisp special? Because of macros. This changes today. "
09:45:01 <therp> mbishop: I know :).. I have already been trying to correct incorrect remarks
09:45:05 <syntaxfree> wow, that is chutzpah, man.
09:45:29 <therp> syntaxfree: I know. Excuse me for using a bit of marketing speech.
09:45:45 <ctkrohn> pretty bold statement indeed
09:46:07 <malsyned> and Preview messes up your fonts?  weird.  I've never noticed that happening to me.
09:47:57 <syntaxfree> therp: that's okay, I'm noted for my wild, somewhat inaccurate statements too.
09:47:59 <mbishop> Hmm, there needs to be a page (at least on the wiki) about Liskell
09:48:04 <mbishop> other than blog entries :P
09:48:05 <syntaxfree> "Python is soup-in-a-cup", etc.
09:48:28 <syntaxfree> so, it's Yet Another AST for Haskell?
09:48:55 <mbishop> http://clemens.endorphin.org/LskVsLisp.html
09:48:56 <lambdabot> Title: Liskell versus Lisp
09:49:00 <therp> mbishop: I released it 4 hours ago :) .. so I think we have time
09:49:17 <mbishop> haha, as a lover of haskell and scheme, let me be the first to say I hate you :[
09:49:20 <therp> oh time. 15 minutes till my beautiful wednesday date. excuse me folks and have fun with my code
09:49:47 <chessguy_work> so did someone break my notIn solution?
09:49:49 <therp> mbishop: suggestions are welcome
09:49:51 <Saizan> to use the macros i've to use the lispish syntax?
09:50:01 <therp> saizan: yes
09:50:03 <syntaxfree> my ex screwed up a date for me.
09:50:09 <Saizan> :\
09:50:13 <mbishop> s-exprs are well suited for macros
09:50:18 <syntaxfree> more info @ -blah ;)
09:50:37 <malsyned> Liskell has pattern-matching?
09:50:48 <Saizan> mbishop: true, but are less suited for human
09:51:01 <mbishop> Saizan: I don't think so
09:51:39 <mbishop> Looks like Liskell uses case
09:51:58 <mbishop> I'd like it if it used haskell's "implied" pattern matching
09:52:21 <malsyned> mbishop: agreed
09:52:52 <malsyned> I imagine it would feel like defining CLOS methods, but more flexible.
09:52:57 <therp> malsynced: it has pattern matching. in let, case and function arguments. the /liskell page should give a description
09:53:09 <syntaxfree> mbishop: from the code example it looks like it does.
09:53:27 <syntaxfree> (define (rate-outcome-a (, _ result))
09:53:36 <syntaxfree> that's a pattern-match for (_, result)  it seems
09:53:44 <therp> saizan: macros happen before translation to the haskell AST.. imho transformation on the haskell AST are very hard. compared to the really simple Liskell parse tree
09:53:50 <therp> syntaxfree: correct! :)
09:53:55 <Gotaku> Does haskell have anything like the python popen2 function?
09:54:14 <syntaxfree> Gotaku: what would be its type?
09:54:20 * therp afk -> girl
09:55:48 <Gotaku> syntaxfree: String -> (Handle, Handle) I suppose.
09:56:16 <edwinb> isn't that what runInteractiveProcess does?
09:56:21 <syntaxfree> @hoogle String -> (Handle, Handle)
09:56:21 <lambdabot> No matches, try a more general search
09:56:23 <roconnor> is hope a web-server?
09:56:27 <allbery_b> @hoogle runInteractiveCommand
09:56:27 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
09:56:50 <allbery_b> open3 instead of open2.  if you want better you can define in terms of:
09:56:55 <allbery_b> @hoogle runInteractiveProcess
09:56:56 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
09:57:05 <allbery_b> hm, no, wrong one
09:57:26 <Gotaku> wrong one?
09:57:42 <allbery_b> @hoogle runProcess
09:57:43 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
09:58:16 <allbery_b> that's the low level one, you pass in the Handles to be used so you can combine stdout and stderr or pass stderr through to yours or etc.
09:58:59 <Gotaku> I tried runInteractiveProcess but couldn't get it to work.
09:59:53 <allbery_b> depends on what yu passed it.  need to keep in mind that *Process requires you to pass a full path to an executable and already-parsed arguments
10:00:21 <allbery_b> *Command hands that stuff off to /bin/sh for simplicity at the priice of flexibility
10:00:39 <Gotaku> I'm using Windows at the moment.
10:01:08 <allbery_b> hm.  would expect *Process t work, *Command I wouldn't know how it's implemented (probably cmd.exe?)
10:03:11 <roconnor> @shapr
10:03:12 <lambdabot> why on earth would I slap
10:03:25 <roconnor> @get shapr
10:03:26 <lambdabot> shapr!!
10:03:49 <Gotaku> allbery_b: Well the command runs I know that much but I couldn't get anything out of the handle returned.
10:04:51 <chessguy_work> @shap
10:04:51 * lambdabot slaps
10:05:33 <rahikkala> What is the sound of one lambdabot slapping?
10:07:26 <chessguy_work> @quote slap
10:07:26 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
10:07:34 <chessguy_work> @quote slap
10:07:34 <lambdabot> lambdabot says: why on the earth whould I slap dons with a wet trout
10:07:59 <roconnor> lambdabot says: lambdabot says: why on the earth whould I slap dons with a wet trout
10:08:10 <roconnor> roconnor says: lambdabot says: lambdabot says: why on the earth whould I slap dons with a wet trout
10:09:25 <ToRA> is there a (standard) way in the std / extralibs to load a png image and get a list/array/other representation that gives a way of querying it's pixels?
10:09:39 <ToRA> or is there a favourite library ppl can recommend for doing such a task?
10:10:32 <Saizan> Pancito can probably do that
10:11:17 <Saizan> but the GUI bindings should have something too
10:11:27 <syntaxfree> Pancito is fun.
10:11:54 <syntaxfree> ToRA: Pancito turns images into a Pixel -> Colour function.
10:11:54 <ToRA> it looks it
10:12:07 <ToRA> ok, is there an easy way to extract from it?
10:12:34 * ToRA needs to make textures for opengl and the miloh lib doesn't compile
10:13:04 <syntaxfree> sure. they're functions.
10:13:06 <syntaxfree> just apply'em.
10:13:43 <ToRA> cool
10:13:44 <ToRA> cheers
10:13:53 <syntaxfree> ToRA: some code examples of my own, hacked together in a few minutes:
10:13:54 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/20/baby-steps-with-pancito-a-simple-color-filter/
10:13:57 <lambdabot> Title: Baby steps with Pancito: a simple color filter « Data.Syntaxfree, http://tinyurl.com/2juora
10:14:47 <ToRA> syntaxfree: t-y
10:17:05 * Saizan is corrently writing a pbm -> Zipper (Zipper a) with Binary
10:17:21 <xerox> Saizan: what is Zipper?
10:17:54 <Saizan> data Line a = L [a] [a] deriving (Eq,Show)
10:17:54 <Saizan> newtype Plane a = P (Line (Line a)) deriving (Eq,Show)
10:18:13 <Saizan> Plane, actually
10:18:56 <xerox> Interesting. What interface do you get this way?
10:19:14 <Saizan> well, i use it as a Comonad
10:20:01 <Saizan> since i saw cellular automata i wanted to apply it to images
10:20:44 <xerox> :D
10:21:54 <Saizan> first i used DIffArrays but it's somewhat cleaner with a Comonad
10:23:36 <roconnor> why is a line a pair of lists?
10:24:33 <bakert> ?seen bringert
10:24:34 <lambdabot> I saw bringert leaving #haskell 36m 10s ago, and .
10:24:38 <bakert> ?seen bringert_
10:24:38 <lambdabot> I haven't seen bringert_.
10:24:44 <Saizan> roconnor: if you have L (a:as) (b:b':bs)  you are in b, a at your left and b' is at your right side
10:24:58 <xerox> roconnor: left (y:ys) xs = L ys (y:xs); right ys (x:xs) = (x:ys) xs
10:25:22 <roconnor> ok
10:26:10 <bakert> Has anyone ever had Network.Browser bring them back just the first few lines of an HTML page (Content-Length implying it should be much longer)?
10:26:32 <xerox> ski might be able to show you a formal proof, interpreting the list type as a formula, differentiating it, and interpreting it back as a type.
10:27:10 <Saizan> life (P (L (L (u0:_) (u1:u2:_):_) ((L (u3:_) (u4:u5:_)):(L (u6:_) (u7:u8:_)):_))) =  <-- the bad side is that pattern matching on Plane becomes quite ugly :)
10:27:58 <xerox> Saizan: matched values look like a 3x3 matrix?
10:28:07 <Saizan> yes
10:28:11 <xerox> Cool.
10:28:54 <xerox> ... you might use cardinal points, n s w e ...
10:30:28 <Saizan> uhm true, or extractor functions.. actually i would like to have a DSEL
10:31:20 <xerox> I think you might even define the zipper for the Plane directly
10:31:44 <xerox> (which looks over a 3x3 binary region)
10:32:26 <Failure02> cool, hpaste works in opera now
10:33:04 <mbishop> you mean opera works with hpaste
10:33:05 * mbishop hides
10:33:40 * Failure02 shakes fist in a threatening manner
10:34:07 * chessguy_work hides
10:35:31 <hpaste>  faily02 pasted "index too large!" at http://hpaste.org/222
10:35:48 <Failure02> how can i get index too large for that?
10:35:57 <Saizan> <xerox> I think you might even define the zipper for the Plane directly <-- ending up using a zipper inside a comonad?
10:36:59 <xerox> Saizan: with the two zipper-ed lists what happens instead?
10:38:03 <glguy> Failure02: [[],[1]]
10:38:11 <mbishop> Heh, project euler changed their code around, but now some of the forum posts are screwed
10:38:19 <glguy> > [[],[1]] !! 0 !! 0 -- Failure02 like this
10:38:21 <lambdabot>  Exception: Prelude.(!!): index too large
10:38:34 <Failure02> righto
10:38:36 * chessguy_work giggles
10:38:39 <hpaste>  glguy annotated "index too large!" with "fixed" at http://hpaste.org/222#a1
10:38:40 <Failure02> thanks
10:39:26 <hpaste>  glguy annotated "index too large!" with "better still" at http://hpaste.org/222#a2
10:39:30 <glguy> Failure02: ^^
10:39:38 <Saizan> xerox: mmh, i need something to map the function on every "shift" of the plane however
10:40:12 <xerox> Saizan: and cobind happens to do that, right?
10:40:17 <Failure02> hm, is that correct?
10:40:25 <Saizan> xerox: exactly
10:40:41 <Failure02> oh yeah, it is
10:40:48 <glguy> of course it is!
10:40:55 <Failure02> i think using !! is clearer
10:40:58 <kolmodin> ?seen dcoutts_
10:40:59 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts_ speak 1h 53m 48s ago.
10:41:04 <dcoutts_> @yarr!
10:41:05 <lambdabot> What be a priate's favourite cheese?
10:41:05 <lambdabot> Yarrlsburg!
10:41:09 <kolmodin> hia :)
10:41:10 <glguy> Failure02: you shouldn't use !! 0 where "head" will do
10:41:18 <kolmodin> dcoutts_: good response time
10:41:21 <dcoutts_> :-)
10:41:26 <chessguy_work> ?src head
10:41:27 <lambdabot> head (x:_) = x
10:41:27 <lambdabot> head []    = undefined
10:41:29 <kolmodin> dcoutts_: just read the mail from Simon M on the ml
10:41:35 <dcoutts_> kolmodin, ah yes
10:41:49 <Failure02> right. i'll use head $ head instead :)
10:41:54 <kolmodin> btw, how is the Get monad doing ? :)
10:42:03 <glguy> Failure02: and if you are pattern matching to determine that that element exists anyway, you shouldn't dig back into it with head
10:42:12 <dcoutts_> kolmodin, I'm fiddling with the gtk2hs build system atm :-)
10:42:17 <kolmodin> right :)
10:42:17 <dcoutts_> trying to make it do profiling libs
10:42:36 <kolmodin> dcoutts_: ah. try to make cabal compile them and you'll get that for free
10:42:37 <kolmodin> :D
10:42:42 <dcoutts_> heh, yeah
10:42:43 <dcoutts_> so how're you going to do the string pool ?
10:43:19 <kolmodin> dcoutts_: haven't looked at it yet
10:43:24 <kolmodin> been quite busy
10:43:29 <dcoutts_> aye
10:43:50 <kolmodin> there was a radiology workshop here in gbg so it took most of yesterday
10:44:18 <Failure02> glguy: would pattern matching there make it marginally faster or do you just think it would be more elegant?
10:44:30 <kolmodin> dcoutts_: did you have a go at it?
10:44:38 <dcoutts_> kolmodin, no
10:44:43 <dcoutts_> I was volunteering you :-)
10:44:48 <kolmodin> argh!
10:44:50 <kolmodin> :)
10:44:54 <dcoutts_> heh heh heh
10:45:16 * dcoutts_ wants to bash some inner loops
10:45:26 <glguy> Failure02: I think that it makes better use of the pattern matching, which is where Haskell is particularly strong
10:45:27 <dcoutts_> that and make the rules work
10:46:12 <dcoutts_> kolmodin, did I tell you, we got the memory throughput benchmark going really well
10:46:16 <Failure02> well i think ((a:_):_) isn't very readable
10:46:27 <glguy> Failure02: because you are new to haskell?
10:46:37 <dcoutts_> kolmodin, the Haskell version is now within a very respectable margin of the C one.
10:46:43 <kolmodin> dcoutts_: I heard that the ptr in the benchmark wasn't strict, causing loss of speed
10:46:45 <dcoutts_> so that show's what we can shoot for
10:47:03 <kolmodin> how much did the speed improve when you !:ed it?
10:47:08 <dcoutts_> 2x
10:47:12 <Failure02> um, depends... i learnt it three years ago, but i haven't used it much
10:47:13 <kolmodin> very cool
10:47:17 <kolmodin> it's like one char in the code
10:47:21 <xerox> !:ed ?!
10:47:23 <dcoutts_> we want to (de)serialise at ~ 1/4 the memory throughput of the box
10:47:28 <glguy> xerox: added strictness?
10:47:29 <xerox> ah, banged.
10:47:32 * xerox ducks
10:47:33 <kolmodin> xerox: "banged" :)
10:47:37 <chessguy_work> glguy, i think you and i hit on something very interesting last night
10:47:42 * dcoutts_ banged the pointer
10:47:46 <glguy> chessguy_work: oh?
10:47:47 * xerox laughs
10:47:55 <kolmodin> heh :)
10:48:00 <chessguy_work> in terms of difficulty in understanding haskell for newbies
10:48:00 <mbishop> dcoutts_: and you finished twice as fast as normal? :x
10:48:10 <dcoutts_> hah
10:48:41 <chessguy_work> newbies tend to think in terms of raw recursion (i think), wheras more experienced haskellers think in terms of HOF and composition
10:48:47 <kolmodin> dcoutts_: so how many asm instructions is the tight haskell loop now?
10:48:58 <dcoutts_> kolmodin, a dozen or so, compared to 4
10:49:07 <kolmodin> hmm
10:49:10 <dcoutts_> still it's straight line code for the loop bodyy
10:49:13 <kolmodin> I thought it would be less
10:49:22 <kolmodin> right
10:49:26 <dcoutts_> nah, there's a few stack adjustments
10:49:41 <dcoutts_> SP=SP+4; ...;SP=SP-4;
10:49:44 <dcoutts_> that kind of thing
10:49:54 <dcoutts_> so yeah, that could be improved
10:50:04 <dcoutts_> still, it's really pretty good
10:50:13 <glguy> chessguy_work: that's probably very true
10:50:18 <kolmodin> it's amazing
10:50:44 <dcoutts_> kolmodin, so I reckon that we ought to be able to aim for (de)serialising non-trivial data structures at 100Mb/s
10:50:49 <chessguy_work> glguy, i'm not sure what to do about it yet, but i think it's an important observation
10:51:02 <kolmodin> dcoutts_: that must be enought for most needs
10:51:09 <dcoutts_> since we have up to about 2Gb/s bandwidth to play with
10:51:17 <glguy> chessguy_work: I generally see explicit recursion as a place where a standard function should ahve been used, or as an oportunity to search for an abstraction
10:51:26 <glguy> to be used again laster
10:51:28 <glguy> later*
10:51:48 <kolmodin> dcoutts_: so how about the possible memory leak with B.splitAt in getBytes (or whatever)?
10:51:48 <dcoutts_> kolmodin, yeah, that should wipe the floor against most languages
10:51:53 <chessguy_work> glguy, so a function should rarely ever have to call itself?
10:51:57 <glguy> chessguy_work: especially in the scope of questions asked in channel
10:52:07 <dcoutts_> kolmodin, see bringert's fix, it's subtle
10:52:11 <glguy> chessguy_work: I don't know about that, but I try to avoid it when it is reasonable to do so
10:52:24 <kolmodin> dcoutts_: I did see bringerts fix and got a bit terrified
10:52:31 <dcoutts_> heh, yeah
10:52:37 <kolmodin> dcoutts_: is that the price for lazyness? omg
10:52:44 <dcoutts_> kolmodin, splitAt was holding onto the first list as you started to consume the second
10:52:52 <dcoutts_> I reckon there's a nice way to do it
10:52:54 <chessguy_work> glguy, hmmm. so the issue is that many recursive patterns have already been found and abstracted
10:53:00 <dcoutts_> though not with the same signature as splitAt
10:53:07 <dcoutts_> but it'd still be usable with Get
10:53:14 <glguy> chessguy_work: yeah
10:53:22 <dcoutts_> but I've not had the time to investigate in detail
10:53:32 <kolmodin> dcoutts_: how about making the first list strict?
10:53:42 <chessguy_work> glguy, would you say that's more true in haskell than other FP languages?
10:53:48 <kolmodin> dcoutts_: or, hmm. no
10:53:53 <dcoutts_> kolmodin, that's not the problem, the problem is the first list being retained
10:53:56 <Failure02> if xs is some huge list, and i define ys = drop 100 xs, am i right about that ys will require no memory?
10:54:29 <sjanssen> Failure02: that is correct
10:54:43 <kolmodin> dcoutts_: I ment making the result of getBytes strict, but that's no good either
10:54:45 <sjanssen> lists can share their tails
10:54:56 <dcoutts_> kolmodin, the task is to turn a binary stream into [(TarEntryHeader,ByteString)] in such a way that consuming that list in order works in constant space.
10:55:21 <kolmodin> dcoutts_: right
10:55:34 <dcoutts_> so you consume the 512 byte header...
10:56:00 <dcoutts_> then you 'get' the next Nx512b blocks
10:56:05 <dcoutts_> but not strictly
10:56:17 <dcoutts_> since that file may be big
10:56:18 <kolmodin> yeah, so you can write them in constant space
10:56:50 <dcoutts_> so we have to delay checking if we're getting the right length 'til we've got to the end
10:57:01 <dcoutts_> that's the lazy getBytes
10:57:30 <kolmodin> dcoutts_: yeah. must think of how we can handle that error
10:57:42 <kolmodin> just an exception?
10:57:52 <dcoutts_> you just encounter the error when you get to the end of the list
10:58:02 <dcoutts_> if the read is short then it's an error
10:58:03 <kolmodin> or getLazyBytes :: Get (ByteString, [Error])
10:58:16 <dcoutts_> I doubt very much if that's lazy enough
10:58:32 <kolmodin> or then [Error] might keep all of the list in memory too
10:58:36 <dcoutts_> the _|_ has to live at the end of the lazy bytestring you get back
10:59:02 * kolmodin has to make some food. not eaten since 12ish
10:59:23 <dcoutts_> I was thinking of a splitAt :: Int -> [a] -> ([a] -> b) -> ([a] -> c) -> (c -> d -> e) -> e
10:59:55 <dcoutts_> that could be implemented in a straightforward way (ie no ST) and be used in getBytes
10:59:58 * mbishop bangs your _|_
11:00:09 <dcoutts_> how rude!
11:00:13 <dcoutts_> ;-)
11:01:16 <glguy> chessguy_work: (just got back) to answer your question, I have no idea. I program primarily in Haskell and C#
11:01:46 <chessguy_work> hmm, I think i'm going to start a thread on -cafe about this
11:01:56 <glguy> but haskell's HOF suport and curried functions certainly help
11:02:16 <glguy> chessguy_work: about glguy's recursion-aversion?
11:02:20 <mbishop> how can you stand declaring every single type?
11:02:22 <glguy> ;)
11:02:37 <araujo> hello
11:02:43 <chessguy_work> about simple recursion vs. recursion via HOFs
11:03:03 <mbishop> hello
11:05:00 <malsyned> so everybody who I know who is aware of Haskell is aware of it because of all the press it's gotten on Reddit in the past several months.  To the old-timers in the channel: are there any other significant single sources of new recruits, or is reddit responsible for what looks (to me) like a resurgence in interest in the language?
11:05:18 <allbery_b> pugs?
11:05:26 <malsyned> ooh, yeah, good point.
11:05:31 <araujo> darcs
11:05:36 <glguy> I think that I got interested because of Project Euler
11:05:45 <chessguy_work> hmm, it was SICP that got me interested in FP, and IRC in general that introduced me to the language
11:05:59 <bakert> darcs is where I first heard of it.  though that was from my boss and he reads reddit.  so hard to say
11:06:41 <malsyned> right.  I think I heard about darcs by reading about Haskell, which I got from reddit.
11:06:42 * araujo got into Haskell when he started looking for a purely functional language
11:07:08 <bakert> araujo, you are just posh.  unlike us reddit plebs!
11:07:26 <araujo> bakert, i actually knew reddit because of Haskell
11:07:27 <araujo> :-P
11:07:34 <bakert> oh my lord.  we are not worthy!
11:07:38 <glguy> I learned about reddit because people  in this channel talked about it
11:07:43 <araujo> yeah
11:07:46 <astrolabe> malsuned: have you seen the stats page?
11:07:51 <astrolabe> @where stats
11:07:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
11:08:12 <glguy> there are people that don't have that bookmarked?
11:08:33 <malsyned> glguy: I was one of them.
11:08:37 <glguy> :-p
11:08:40 <astrolabe> I think there has been a surge of interest recently, but I think haskell was on a gradually increasing curve anyway.
11:09:00 <chessguy_work> hmm, i didn't
11:09:09 <malsyned> astrolabe: Yeah, I figured that was another possibility - that there hasn't been a surge, and that I'm just late to the party.
11:09:12 * chessguy_work hangs head in shame
11:09:12 <araujo> Haskell is being taught in many univ too
11:09:15 <glguy> hmm, I guess i have it memorized, and not bookmarked
11:09:19 <glguy> I dont' actually "bookmark" anything
11:10:03 <chessguy_work> wow, i'm in the top 10 most active nicks
11:10:17 <chessguy_work> random quote: "hmm, are Monad.liftM and Control.Monad.liftM the same?"
11:10:21 <chessguy_work> lol
11:12:28 <bakert> my random quote is quite random (teenager sense) today.
11:12:48 <bakert> i am also the biggest shouter!  and do i ask too many questions?
11:13:21 <chessguy_work> bakert, i like your questions
11:13:57 <bakert> (i was actually making a kind of joke because i put an ! and a ? which according to the stats i do the most and the second most respectively)
11:14:12 <bakert> but it is true that soon the clueless muppets like me will overwhelm this channel and the smart people will run off into the hills.
11:14:16 <chessguy_work> oh, lol
11:14:17 <bakert> maybe
11:14:29 <chessguy_work> you mean Maybe
11:14:30 <chessguy_work> :)
11:14:48 <bakert> Either String Bool
11:14:55 <bakert> Right True
11:15:42 <malsyned> bakert: I think it's possible that Haskell is just hard enough to keep out the muppets.  cluelessness doesn't seem to last long in this channel.
11:18:20 <chessguy_work> @type splitAt
11:18:22 <lambdabot> forall a. Int -> [a] -> ([a], [a])
11:18:48 <Saizan> dcoutts: do you think we could have a getLazyRemainingByteString :: Get ByteString in Binary or that it's like killing the purpose of the Get monad?
11:19:08 <sjanssen> @seen vegai
11:19:08 <lambdabot> Last time I saw vegai was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.dut, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavian
11:19:09 <lambdabot> and #unicycling 6d 22h 8m 48s ago, and .
11:19:18 <dcoutts_> Saizan, what would be a use case?
11:19:32 <dcoutts_> Saizan, I mean yeah, it's technically possible (indeed easy)
11:20:15 <dino-> Don't know if anyone mentioned this, but I found that All About Monads is not just on nomaware.com, it's also here: http://www.haskell.org/all_about_monads/html/index.html
11:20:17 <lambdabot> Title: All About Monads
11:20:39 <Saizan> dcoutts_: well i'm stretching the library parsing a pbm image, and i would be glad to easily use ByteString funtions like readInt and so
11:21:08 <malsyned> dino-: excellent!  thanks for that.
11:21:16 <dcoutts_> Saizan, is that a text or binary format ?
11:21:42 <dino-> malsyned: Can be downloaded from there as well. Perhaps worth keeping a personal copy around.
11:21:44 <dcoutts_> Saizan, sounds like you just want a parser lib
11:21:48 <Saizan> dcoutts_: it's a binary format prefixed with some text
11:21:56 <dcoutts_> ah
11:22:06 <malsyned> dino-: already snagged it.  somebody posted a link to the PDF earlier.
11:22:11 <Saizan> actually 2 numbers in ASCII decimal
11:22:32 <dino-> malsyned: Oh, pdf, that I don't have.
11:22:41 <dino-> bakert: Sorry that I was of no help earlier.
11:22:55 <malsyned> I was only into the first chapter, but so far it's the most readable intro to monads I've found, for me anyway.  (no offense to any of the other monad tutorial writers that hang out here)
11:23:27 <Saizan> dcoutts: i'm using this at the moment to recognise one number without consuming the rest of the stream http://hpaste.org/219
11:23:28 <dino-> malsyned: Monads as Containers is very approachable too, IMO.
11:23:28 <malsyned> dino-: http://abaris.zoo.cs.uu.nl:8080/wiki/pub/Afp/DiscussionForum/Newbern-monads.pdf
11:23:31 <lambdabot> http://tinyurl.com/3cww9o
11:23:31 <bakert> dino-, no problemo ... i wasn't really articulating my problem very well.
11:23:47 <bakert> ?quote .*ello.*
11:23:48 <lambdabot> syntaxfree says: monad tutorials are the "Hello world" of our community.
11:24:04 <dino-> dino- :: MonadYoungster
11:24:05 <bakert> malsyned,  ^^
11:24:34 <dcoutts_> Saizan, you can just use readInt, it gives you the remaining string.
11:24:44 <malsyned> bakert: wtf ^^
11:25:06 <bakert> malsyned, i was pointing you at syntaxfree's quote above!
11:25:11 <bakert> about monad tutorials
11:25:21 <malsyned> oh.  gotcha.  it's a good one.  there certainly are a lot of them around.
11:25:55 <malsyned> it's the kind of thing you want to share with people once you've mastered it, I guess.
11:25:57 <Saizan> dcoutts: yeah vut i don't know how much Word8s to pass to readInt, so i should retry if it gives me a reamining empty string etc..
11:26:20 <Saizan> *many
11:26:20 <dcoutts_> Saizan, my point is, you might not want to use Get at all
11:26:44 <allbery_b> @quote comp[iler.*tutorial
11:26:45 <lambdabot> Plugin `quote' failed with: IRCRaised Text.Regex.Posix.regcomp: error in pattern
11:26:49 <allbery_b> @quote compiler.*tutorial
11:26:50 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
11:27:20 <chessguy_work> that's a good one
11:27:24 <chessguy_work> @quote monad
11:27:24 <lambdabot> bd_ says: sorear: Alas, GHC cannot comprehend monads. Only lists :/
11:28:00 <xerox> Saizan: can't you just collect the digits until the separator, and build the number from the binary data?
11:28:37 <Saizan> xerox: that's what that function does
11:28:52 <xerox> okay.
11:29:30 <malebria> Is there a way to make quickCheck generate two different values?
11:30:17 <malebria> I want to define a instance of arbitrary to a type data T a = T a a, in which I can't have the first equal to the second.
11:32:02 <malsyned> does lambdabot4 require ghc6.6?
11:32:35 <notsmack> aww, no recursive types in Djinn...
11:32:52 * kolmodin is back
11:33:12 <kolmodin> my copy of Purely Functional Data Structures arrived today...
11:35:26 <bakert> kolmodin, does it look good?  we have it on the bookshelf here but i haven't got around to looking at it yet.
11:35:29 <beschmi> malsyned: something like this should work:  a <- arbitrary; xs <- arbitrary; return $ T a (head $  dropWhile (==a) xs)
11:35:38 <bakert> kolmodin, it's probably above my head at this point.
11:36:17 <malsyned> beschmi: you meant malebria, right?
11:36:32 <beschmi> malsyned: yeah, sorry
11:36:35 <roconnor> how does hope work?
11:36:39 <roconnor> is it a web server
11:36:46 <roconnor> does it link in with apache
11:36:52 <pejo> bakert, it's very much worth a read, and having a copy in the bookshelf.
11:36:53 <roconnor> or does it just generate a bunch of files?
11:37:30 <beschmi> roconnor: it uses fastcgi
11:38:51 <bakert> pejo, i'll give it a spin after programming language pragmatics
11:39:19 <bakert> it's actually been on my list of books for ages, i can't remember why.  someone must have recommended it
11:39:54 <malsyned> bakert: are you reading the 4th edition of PLP?
11:40:06 <malsyned> or whichever ed is the latest?
11:40:18 <bakert> malsyned, i don't think so.  it's from the imperial college library and doesn't have the same cover as the one on amazon.
11:40:29 <malsyned> is it the green-cover one?
11:41:23 <malsyned> yeah, the first ed is green, the 2nd ed is black and is the latest.
11:41:52 <kolmodin> bakert: it does look good, but I can say how good yet. looks quite easy too read. might change my coding forever. exciting!
11:42:00 * roconnor looks at the requirements for hope
11:42:03 <chessguy_work> glguy, i just started that thread. thanks for the interesting discussion
11:42:10 <glguy> anytime ;)
11:42:11 <roconnor> boy, we really need a working cabal
11:42:21 <kolmodin> roconnor: heh, good look. takes forever to install them :)
11:42:29 <kolmodin> look/luck
11:42:54 <hpaste>  procyon pasted "Counting the number of Applications" at http://hpaste.org/223
11:43:35 <Procyon_> What would be an elegant way to count how many applications have happened in this code and have the evaluator bail if it exceeds a threshold?
11:45:03 <kolmodin> Procyon_: make the evaluator keep a state, and make it use Error ?
11:45:42 <glguy> > exp pi - pi
11:45:47 <lambdabot>  19.999099979189474
11:46:33 <mbishop> glguy: way to be behind the times on readding reddit :P
11:46:35 <Procyon_> kolmodin: So I need to finally learn to use a State Monad?  :P
11:46:47 <kolmodin> Procyon_: yes. and stack the error monad on top
11:46:48 <kolmodin> :)
11:47:01 <glguy> mbishop: way to make your Haskell solution posted to reddit too complicated :-p
11:47:06 <Procyon_> fun fun.   I guess It's time.
11:47:10 <mbishop> :[
11:47:18 <kolmodin> Procyon_: you'll love it
11:47:38 <mbishop> glguy: I argue readability!
11:47:41 <kolmodin> Procyon_: is it homework?
11:47:45 <glguy> mbishop: good luck
11:47:54 <glguy> :-D
11:48:03 <Procyon_> kolmodin: I was hoping to delay the learning until I needed state in my interpreted language
11:48:33 <kolmodin> well it's easy to use it
11:48:55 <kolmodin> Monad Tranformers are simplicity itself
11:48:57 <Procyon_> kolmodin: no.  It's a GP experiment.  I'm doing it in Haskell instead of my usual Scheme to force me to learn Haskell.
11:49:49 <kolmodin> Procyon_: ok
11:50:31 <kolmodin> Procyon_: ok, let's get you started. you could do it with monads or without
11:51:03 <glguy> using a monad doesn't mean you abandon purity... (for the record)
11:51:24 <kolmodin> glguy: very true
11:51:28 <pejo> Procyon, Grabmller has written something about monad transformers, writing an interpreter as example.
11:51:35 <kolmodin> it's just another way of structuring your calculation
11:51:40 <kolmodin> bringert: hia
11:51:51 <bringert> hi kolmodin
11:52:21 <kolmodin> how's code?
11:52:32 <glguy> ?unmtl StateT Int Maybe a
11:52:32 <lambdabot> Int -> Maybe (a, Int)
11:52:33 * mbishop sometimes wishes monads were hidden, so you could do side effectish code, but still in a safe manor
11:52:42 <mbishop> manor? manner*
11:52:48 <chessguy_work> manure?
11:52:49 <Procyon_> pejo: link?
11:53:07 <mbishop> "Manure, I HATE MANURE"
11:53:21 <glguy> back 2 the future?
11:53:33 * mbishop nods
11:53:36 <chessguy_work> @quote manure
11:53:36 <lambdabot> No quotes match. Just what do you think you're doing Dave?
11:54:23 <chessguy_work> Dave?
11:54:30 <glguy> 2001
11:54:31 <pejo> @google Grabmller monad transformers step
11:54:31 <bakert> (2001)
11:54:33 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
11:54:34 <lambdabot> Title: Monad Transformers Step by Step
11:54:48 <glguy> quote from HAL
11:55:37 <Procyon_> Danke
11:56:03 <ttfh> what language would HAL have been written in? :-)
11:56:35 <kolmodin> dcoutts_: mind if I give a shot at rewriting the Get monad? I could use the code so far you got
11:56:56 <dcoutts_> kolmodin, go for it, I didn't get very far
11:57:15 <kolmodin> dcoutts_: ok
11:57:16 <Procyon_> ttfh: prolog
11:57:19 <Procyon_> :)
11:57:58 * mbishop throws his extra digit at glguy 
11:58:14 <glguy> mbishop: and your extra characters?
11:58:18 <glguy> :)
11:58:29 <mbishop> extra characters built the extra digit :P
11:58:37 <glguy> naw, using GHCI did
11:58:46 <kolmodin> type Eval6 a = ReaderT Env (ErrorT String (WriterT [String ] (StateT Integer IO))) a   -- this is a really fat mtl :)
11:58:49 <Procyon_> I've got a third Bool around here somewhere I'm not using.
11:58:50 <mbishop> ah really? heh
11:59:04 <kolmodin> ?unmtl ReaderT Env (ErrorT String (WriterT [String ] (StateT Integer IO))) a
11:59:05 <lambdabot> Env -> Integer -> IO (Either String a, [String], Integer)
11:59:05 <glguy> Prelude> exp pi - pi
11:59:05 <glguy> 19.999099979189474
11:59:21 <mbishop> :P
11:59:22 <kolmodin> suprisingly simple
11:59:26 <dcoutts_> the tricky bit, as you know, is the readN function since if there's not enough bytes in the current chunk then it has to make a temp chunk and copy the tail of this chunk and a bit of the next chunk (arg! what if the following chunk also isn't big enough... Strict.concat . Lazy.take n)
11:59:30 <dcoutts_> kolmodin, ^^
11:59:47 <ttfh> Procyon_: I think HAL would have been written in LISP
11:59:52 <kolmodin> dcoutts_: neat!
11:59:56 <dcoutts_> kolmodin, then I'd set that as the new chunk and call readN recursively
12:00:30 <glguy> ttfh: because of the myth that it's good for AI? or for some other reason?
12:00:31 <kolmodin> dcoutts_: imagine what ?unmtl Eval6 would look like without the currying/uncurrying (can never remember which *curry does what)
12:01:04 <ttfh> glguy: For what was available when the book was written
12:01:04 <kolmodin> dcoutts_: yeah, that'll probably transform into a nice goto somewhere :)
12:01:13 <dcoutts_> @arr
12:01:14 <lambdabot> Avast!
12:01:31 <dcoutts_> kolmodin, the point is that the copying path is the slow path so should be out of line
12:01:32 <kolmodin> dcoutts_: the problem is solved, just need to be implemented
12:01:49 <kolmodin> dcoutts_: I'll just get the functionallity there
12:01:53 <dcoutts_> @arr
12:01:54 <lambdabot> I'll crush ye barnacles!
12:01:55 <glguy> why is the Get monad (from Binary?) being rewritten?
12:02:04 <dcoutts_> glguy, to make it really really fast
12:02:07 <Procyon_> ttfh:  I think his breakdown being a conflicting logic constraint points to prolog unification.
12:02:11 <chessguy_work> hmm, that sounds painful
12:02:13 <ttfh> glguy: I think the book was before prolog, but I might be wrong, anyway, trying to imagine "the future as it looked in the past"
12:02:22 <glguy> dcoutts_: that sounds like a good reason :)
12:02:22 <kolmodin> dcoutts_: then I'll have a go at making it faster.. then I'll let dons take over :D
12:02:29 <dcoutts_> right'o
12:02:36 <ttfh> Procyon_: Yes, interesting
12:02:54 <dcoutts_> kolmodin, try running small examples and looking at -ddump-simpl-iterations
12:03:02 <kolmodin> might not get finished tonight. I'm dead tired. luckely we already have QC's
12:03:12 <kolmodin> dcoutts_: hah, not tonight! :D
12:03:13 <dcoutts_> look at the worker wrapper transform, the strictness etc
12:03:16 <dcoutts_> no, sure
12:03:38 <dcoutts_> but don't just hand that over to dons, you can to the black magic too
12:03:42 <dcoutts_> :-)
12:03:48 <dcoutts_> to/do
12:03:54 <kolmodin> sure, and I want to!
12:04:30 <kolmodin> hehehe. maybe I won't commit any patches until it's lightening
12:04:56 <dcoutts_> you've got the benchmark to see how it's going
12:05:06 <kolmodin> dcoutts_: yeah, it's "easy" now
12:05:09 <dcoutts_> you're aiming to make it faster than the serialisation
12:05:11 <dcoutts_> :-)
12:05:26 <dcoutts_> so you're only looking for a 20x speed improvement
12:05:29 <dcoutts_> ;-)
12:05:31 <kolmodin> yeah, I'll take it from 3mb/s to 200mb/s. hold on!
12:06:23 <ttfh> Procyon_: I don't know how much Clarke knew about AI or computers, but he seems to be very thourough in his research on other subjects, It would be interesting to know what research he did before creating HAL
12:06:33 <glguy> would it be appropriate to use Binary for more than serialization, say reading a binary protocol on a network socket?
12:06:34 <dcoutts_> kolmodin, ok, g'evening, I'm off
12:06:44 <malsyned> He had Minsky consult, I think
12:06:53 <malsyned> er, no, that was for the movie.
12:07:07 <kolmodin> dcoutts_: ok, later
12:07:13 <ctkrohn>  really going on
12:07:14 <ctkrohn>  62 testEngineVerbose :: String -> Integer -> Int really going on
12:07:15 <mbishop> malsyned: what?
12:07:23 <ctkrohn> sorry mistake paste
12:07:41 <ttfh> malsyned: I think the movie script was written at the same time as the book
12:07:47 <Lemmih> glguy: Yes, I'd think so.
12:08:09 * allbery_b has a "making of" book, they were written concurrently, each driving the other, entangled in odd ways
12:08:30 <allbery_b> there was some discussion of HAL but I don't recall it offhand
12:08:35 <malsyned> mbishop: I attended a talk a few years ago at school about what we now know to be hard/easy about the tech in the 2001 movie.  I think I remember the speaker saying that Minsky consulted on the film.
12:08:57 <mbishop> oh
12:09:07 <Procyon_> ttfh: Prolog was introduced in 1970.  I just looked it up.
12:09:46 <jre2> unfortunately, being a student at uiuc doesn't give me inside information...
12:10:04 <mbishop> I found 2001 too boring, and I'm a fan of Citizen Kane, so...
12:10:31 <glguy> mbishop: right... because citizen kane kept you on the edge of your seat :-p
12:10:46 <allbery_b> keep in mind the concepts behind prolog existed before prolog
12:10:47 <bakert> mbishop, i agree.  HAL is wonderful but the film is more a "work of art" than an entertainment of any sort.  The book is much more comprehensible.
12:10:47 <mbishop> heh no, I'm just saying, I'm used to boring, but I found 2001 too boring
12:10:58 <glguy> mbishop: ah, fair enough
12:10:59 <wojtekk> hello to all! I'm new here, apart from some weblurking of meme logs, so welcome!
12:11:05 <ttfh> reading the book first helps to understand the film
12:11:08 <malsyned> hey wojtekk
12:11:17 <malsyned> welcome from a fellow n00b
12:11:30 <bakert> 2001 is the kind of thing that is fun to have on in the background when you are on acid.  And I think that's how it was intended, in a way.  Not that I know much about the making of it.
12:12:19 <ttfh> even more "boring" than 2001 are the Soviet sci-fi movies "Solaris" and "Stalker", but I liked them to
12:12:28 <mbishop> bakert: but you know lots about being on acid? :P
12:12:29 <allbery_b> "Lost Worlds of 2001" notes that they were trying to convey something that couldn't be conveyed visually
12:12:32 <ttfh> "boring" = very slow pace
12:12:40 <bakert> mbishop, enough.  misspent youth and all that.
12:12:47 <Procyon_> bakert: I tried watching it on acid, but the fern next to me was more interesting :)
12:13:09 <mbishop> I can only imagine what some movies are like on drugs...like Pi, or Donnie Darko
12:13:12 <allbery_b> ...it worked better in the book because he didn't have to provide a visual representation for the incomprehensible so could just gloss over it
12:13:12 <bakert> ttfh, the George Clooney version is soooo bad.
12:13:16 <allbery_b> (so it didn't drag)
12:13:16 <mbishop> or 12 Monkies
12:13:34 * JKnecht is pretty sure was on acid when saw it in original release
12:13:34 <ttfh> bakert: I didn't think it was so bad actually
12:13:58 <Procyon_> mbishop: Those movies aren'
12:14:01 <sm> can lambdabot easily report subversion commits, I wonder
12:14:16 <mbishop> Procyon_: eh?
12:14:17 <Procyon_> mbishop: Those movies aren't so good on drugs, as you can't follow complex plot lines
12:14:24 <chessguy_work> sm, you  mean from hackage?
12:14:31 <bakert> agreed.  aladdin - that's the right level.
12:14:35 <sm> no, from my own svn repo
12:14:37 <bakert> after you've seen it once straight.
12:14:53 * mbishop has never done drugs
12:14:54 <chessguy_work> eww
12:14:55 <wojtekk> I have question wrt to library best practices. Most of libs are developed as darcs repositories and lots of them make their way to GHC distribution. However, I'm lost with figuring the checkpoints when they were incorporated into ghc..
12:14:55 <chessguy_work> svn--
12:15:11 <chessguy_work> darcs++
12:15:17 <bakert> mbishop, is that by chance or by persuasion
12:15:18 <bakert> ?
12:15:27 <sm> we use svn at work, and I'm selecting a bot to keep us informed
12:15:44 <sm> the darcs infiltration is not yet complete here
12:15:50 * glguy hasn't done any either
12:15:53 <bakert> actually, these logs get kept forever, don't they?  i can just see future employers googling me and getting my tales of a misspent youth on #haskell.  perhaps i better shut up.
12:15:57 <sm> s/darcs/darcs+haskell/
12:16:01 <wojtekk> ..as they usually, well, lack some tags :) So now for example I'm having a problem with multipled patches in time package: from latest darcs, from some workaround repos as parsedate, and so on
12:16:02 <Procyon_> lol
12:16:26 <malsyned> bakert: I was trying to come up with a tactful way to mention that ;-)
12:16:27 <int-e> bakert: sure, please provide your real name, SSN etc. for future reference :)
12:17:06 <bakert> i don't think it's too hard to find out who i am just from the nick to be honest.
12:18:00 <wojtekk> so what is the best place to track which repositories were packaged as particular GHC libs? Some wiki page, discussion list, whatever?
12:18:06 <bakert> hopefully any future employers will not be brainwashed by the media into calling all drugs, "drugs" and assuming a fondness for hallucinogens as a teenager means i will steal from them and kidnap their families.
12:18:11 <Procyon_> There's enough google dirt on my I don't care.  I've always had my pick of jobs and can make my own company if I want, so I could care less if some employer doesn't hire based on a google search.  Their loss.
12:18:38 <bakert> Procyon_, you are right, of course.
12:18:43 <malsyned> I'm imagining "bakert" suddenly spiking in Google's statistics at 15:12 EST today.
12:19:05 <bakert> but sometimes people don't know anything about drugs but are otherwise nice people.  and it scares them off.
12:19:07 <allbery_b> if someone tries to figure me out via google they'll probably conclude I'm a complete dingbat :)
12:19:33 <glguy> other people *do* know what effect drugs can have on people and avoid them anyway
12:19:43 <glguy> (the people ;) )
12:19:49 <bakert> google allberry b = "dingbat.com"
12:20:11 <vincenz> @google allberry b
12:20:13 <jre2> bakert: nah, it's only as bad as stealing and kidnapping if you read the DRM'd pdf more than the 3 times allowed
12:20:14 <lambdabot> http://www.worldwar2exraf.co.uk/Aircrew%20Notice%20Board/aircrew%20notice%20board%2031.htm
12:20:14 <lambdabot> Title: World War 2 Ex RAF Aircrew Notice Board Page 31
12:20:17 <mbishop> bakert: what do you mean by change or persuasion?
12:20:49 <glguy> mbishop: he doesn't realize that personal pride or self-restraint or personal standards could be a reason
12:20:58 <bakert> mbishop, sorry i meant "chance" or "persuasion".  as in are you "against" "drugs"  or just happen not to have taken any.
12:21:26 <mbishop> Oh, well I'm against some drugs, others I just don't care for, and just don't do any...unless you count caffeine :P
12:21:31 <bakert> glguy, i do realise that some people feel exactly that way.  that's why i wondered which it was.  i think my typo made me seem like a bit of an idiot!
12:21:45 <bakert> mbishop, now i can't _abide_ caffeine!
12:21:49 <glguy> bakert: persuassion make it sounds ilke someone tricked him to be against them
12:22:02 <ttfh> the most interesting SF on AI I have read is "Golem XIV" by Stanislaw Lem
12:22:27 <bakert> glguy, oh sorry i meant persuasion as in "sexual persuasion" or something like that.  perhaps "orientation" would have been a better word.  or "political stance"???!!!
12:22:38 <glguy> preference?
12:22:41 <ttfh> certainly more far fetched than HAL9000...
12:22:43 <Procyon_> Having done some things in my youth, I concluded that beer and coffee are the best drugs in the world.
12:22:55 <bakert> Procyon_, but the hangovers ...
12:23:02 <bakert> I don't drink any more hardly ever.
12:23:17 <mbishop> Heh, I don't drink either :P
12:24:11 <Procyon_> Aye.  Try not to drink beer to hangover point, and not drink coffee to stare at the wall shaking point, of course :)
12:26:02 * JKnecht wishes to state, FTR, that he does not, in general, give a flying fuck what someone coming to him to buy wage labor at a fraction of it's value and otherwise present imbecile slaver shits thinks as this is the expected profile for the type of scanner of the logs referred to.
12:28:07 <bakert> Probably so.  It's just that some nice (even intelligent) people tend to hold the opinion that anyone that has ever taken any illegal drugs is untrustworthy or dangerous.  You can say that's their problem but as they are nice (and sometimes intelligent) I like to look out for them a little.
12:28:36 <bakert> I'm happy to educate anyone I come across but you can't really do that if they are just googling you.
12:28:38 <Procyon_> and Jagermeister is evil... Shots of Jager are implemented as an infinite list, and the more you take, the more strictly the list becomes evaluated until you are in a loop, blow your stack, and wake up at an exgirlfriend's house with no debugger.
12:28:58 <jre2> Procyon_: nice
12:29:16 <malsyned> bakert: if they're reading this, they're already receiving said education.  Or at least being exposed to your views on the subject.
12:29:31 <bakert> I suppose so.
12:29:48 <jre2> unless they're just grepping through a log
12:29:53 <glguy> I don't necessarily have respect for people that *use* such drugs, but I respect their right to use them... I'm against laws prohibiting them
12:29:54 <malsyned> Maybe that's the solution.  Never mention something you're concerned might disqualify you from employment without subsequently philosophising on the subject in the same forum.
12:30:49 <fasta> What's a suitable value to represent a special "infinite value"?
12:30:50 <bakert> That's it!  So remember oh log file reader, hallucinogens are NOT addictive and can give you genuine insight into the human condition.
12:31:10 <fasta> It's more convenient to use something of type Int.
12:31:11 <svref> Is the approved way to write +Infinity as a numeric literal: (1::Double)/0 ?
12:31:12 <glguy> > 1/0
12:31:13 <lambdabot>  Infinity
12:31:15 <bakert> And as I haven't mentioned any others I guess that's me covered.
12:31:27 <glguy> ?hoogle inf
12:31:28 <lambdabot> Prelude.infix :: keyword
12:31:28 <lambdabot> Prelude.infixl :: keyword
12:31:28 <lambdabot> Prelude.infixr :: keyword
12:31:35 <rahikkala> > 0/0
12:31:36 <fasta> > Infinity
12:31:37 <lambdabot>   Not in scope: data constructor `Infinity'
12:31:38 <lambdabot>  NaN
12:31:43 <malsyned> ?hoogle Infinity
12:31:44 <lambdabot> No matches found
12:31:50 <malsyned> huh
12:32:05 <fasta> Is there also a library function that gives me infinite?
12:32:11 <glguy> > maxBound :: Float
12:32:12 <lambdabot>   add an instance declaration for (Bounded Float)
12:32:12 <lambdabot>     In the expression: maxB...
12:32:23 <fasta> Otherwise, I need to add it to my "Util" library.
12:32:38 <malsyned> fasta: you're talking specifically about IEEE floating-point "Infinity", right?
12:32:52 <fasta> malsyned: I only need to have an Int infinity.
12:32:58 <glguy> ?type isInfinite
12:33:00 <lambdabot> forall a. (RealFloat a) => a -> Bool
12:33:18 <fasta> malsyned: so, when I compare _any_ non-infinite number with it, I get that it's smaller.
12:33:24 <glguy> fasta: maxBound is probably a pretty good infinity Int value ;)
12:33:42 <fasta> glguy: ok, I will rename it. Thanks
12:33:45 <malsyned> fasta: I don't think there's an int type that includes infinity.  You could define an analog to Maybe that is of class Integral, I suppose.
12:34:02 <malsyned> something like data InfiniteInt = Infinity | Finite Integer
12:34:17 <fasta> malsyned: yeah, well, in this application maxBound is enough
12:40:29 <jre2> does anyone know how to go about grabbing a region of another program's window's pixels?
12:41:39 <allbery_b> it'll vary depending on window system --- one way for X11, one for Windows, OSX/Aqua, etc.
12:43:45 <sjanssen> @hoogle unsafeInterleaveIO
12:43:45 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
12:46:53 <hpaste>  malebria pasted "No output with runghc" at http://hpaste.org/225
12:46:58 <malebria> Is this right?
12:52:18 <dylan> how can I lazily read from a directory?
12:55:26 <malsyned> I second dylan's question
12:55:55 <dylan> getDirectoryContents seems non-lazy.
12:56:19 <malsyned> I imagine the information is wrapped up in darcs' source code, which has the concept of a "slurpy" which is a lazily-read source tree.
12:56:32 <malsyned> but since I haven't gotten around to reading darcs' source code yet, I don't know the answer.
12:56:53 <allbery_b> @source System.Directory
12:56:54 <lambdabot> http://darcs.haskell.org/packages/base/System/Directory.hs
12:57:59 <beschmi> darcs just uses getDirectoryContents, the slurpy is only lazy in reading the contents of a file
13:03:29 <sjanssen> @seen dcoutts
13:03:29 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 10h 58m 15s ago.
13:05:16 <malsyned> beschmi: so there is no lazy directory reading function?
13:08:46 <glguy> what would be gained by making it lazy?
13:09:20 <glguy> the system call returns all the elements anyway
13:09:55 <malsyned> glguy: one could imagine a data structure which represents the entire filesystem.
13:09:56 <beschmi> glguy: no, readdir returns the next entry
13:09:56 <dino-> Isn't stuff like System.Directory.getDirectoryContents lazy?
13:10:21 <malsyned> and your application only traverses a small part of it, but does so in a pure-functional style.
13:10:25 <dino-> As in, that [FilePath] is grabbed only as you need it?
13:10:49 <sjanssen> there is System.Posix.Directory which you can use to write a lazy getDirContents
13:11:17 <malsyned> Is it really true that the standard one isn't lazy, though?
13:11:17 <sjanssen> that isn't portable, of course
13:11:20 <dylan> also, ((=<<) .) is a useful function
13:11:33 <dino-> I see, System.Directory.getDirectoryContents API doc says 'returns a list of _all_ entries'
13:11:43 <allbery_b> beschmi: but on many unixen readir() invokes getdents() which chunks  (you could read one at a time but it's very inefficient
13:12:25 <dylan> @pl ((=<<) .)
13:12:26 <lambdabot> ((=<<) .)
13:12:32 <beschmi> dino-: most IO functions aren't lazy by default because you can't predict when the file descriptor gets closed
13:12:33 <malsyned> My thinking is that you'd want to build a data structure out of the results of many calls to it, and you'd want each individual call to not be performed until it's needed.
13:12:33 <dylan> Darn, it doesn't have a name.
13:13:26 <beschmi> allbery_b: so libc buffers for you if you use readdir?
13:14:11 <dylan> @type ((=<<) .) filterM
13:14:12 <allbery_b> yes
13:14:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> m [a] -> m [a]
13:14:13 <sjanssen> malsyned: from cursory examination of the source, I believe getDirectoryContents is not lazy
13:14:28 <beschmi> @source Prelude.readFile
13:14:29 <lambdabot> Prelude.readFile not available
13:14:35 <beschmi> @source readFile
13:14:36 <lambdabot> readFile not available
13:14:41 <malsyned> @hoogle readFile
13:14:42 <lambdabot> Prelude.readFile :: FilePath -> IO String
13:14:42 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
13:14:42 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
13:14:51 <malsyned> huh
13:15:02 <dino-> I see. The ones in the Prelude (getContents, readFile) explicitly say lazy.
13:15:36 <dylan> alright, better question.
13:15:40 <malsyned> could readFile be implemented in Haskell in terms of the IO primitives?
13:15:42 <allbery_b> typically does getdents to an 8k buffer, and readdir steps through the buffer
13:15:47 <malsyned> er, the Handle IO primitives
13:16:23 <sjanssen> malsyned: yes, it is implemented in terms of hGetContents and openFile
13:16:26 <dylan> how would I write a function: [FilePath] -> IO [FilePath], which takes a list of directories and returns a list of all the files in them lazily? Given than each getDirectoryContents call is non-lazy
13:16:31 <sjanssen> @src hGetContents
13:16:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:16:35 <kolmodin> good night
13:17:03 <sjanssen> dylan: investigate unsafeInterleaveIO
13:17:10 <dylan> sjanssen: thanks. :)
13:17:17 <malsyned> sjanssen: how do they re-lazy the strictness of the handle operations?
13:17:25 * dylan is trying to rewrite a 35 line C program as a smaller haskell one.
13:18:31 <malebria> @hoogle Maybe a -> Maybe a -> Maybe a
13:18:31 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
13:18:38 <beschmi> malsyned: hGetContents is lazy too
13:19:14 <malebria> mplus =D
13:19:25 <SamB> @src hGetContents
13:19:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:19:28 <malsyned> beschmi: OK, but doesn't readFile automatically close the handle only when all of its contents have been read?
13:19:57 <SamB> malsyned: no
13:20:04 <SamB> hGetContents does that for it ;-)
13:20:24 <malsyned> so there's no reason to ever call hClose after calling hGetContents?
13:20:38 <SamB> never ever call hClose after calling hGetContents
13:20:43 <sjanssen> the actual source: readFile name	=  openFile name ReadMode >>= hGetContents
13:20:59 <SamB> @src readFile
13:21:00 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
13:21:04 <malsyned> Yeah, I've seen the consequences of calling hClose after hGetContents, but I've also seen it done in tutorials.  It always struck me as a bad idea.
13:21:39 <SamB> malsyned: send flames to the authors of the tutorials. okay, don't. send helpful comments!
13:22:37 <malsyned> SamB: in the one I specifically remember, it was even worse.  it was something like do {c <- hGetContents h; length(c); hClose h}
13:23:05 <sjanssen> malsyned: bad tutorial!  Do you have a link?
13:23:07 <SamB> malsyned: that doesn't even typecheck
13:23:12 <malsyned> nah.  this was like a month ago.
13:23:25 <malsyned> SamB: I said "something like" ;-)
13:23:58 <malsyned> whatever the tutorial actually said, it compiled.
13:24:36 <allbery_b> let x = evaluate (length c)?
13:25:05 <SamB> allbery_b: what?
13:25:09 <SamB> you are confused
13:25:15 <allbery_b> probably
13:25:20 <allbery_b> yeh, that won';t work
13:25:44 <SamB> that won't work -- why would evaluate be called before hClose?
13:26:18 <allbery_b> me should remember how he did this but instead noted "don't do that" and moved on
13:26:21 <allbery_b> bah
13:26:26 <allbery_b> can't type either, as usual
13:27:08 <sjanssen> do c <- hGetContents h; evaluate (length c); hClose h -- is the correctly typed solution
13:28:58 <bringert> what's the point of calling hClose there?
13:29:23 <bringert> hGetContents closes the handle when it gets to EOF
13:30:26 <SamB> bringert: obviously the point is to accidentally truncate your data!
13:30:33 <bringert> ah
13:30:46 <bringert> dylan: see recurseDirectories here: http://www.cs.chalmers.se/~bringert/darcs/tar/Codec/Archive/Tar/Create.hs
13:30:49 <lambdabot> http://tinyurl.com/2glf2o
13:38:17 <dylan> !paste
13:38:18 <hpaste> Haskell paste bin: http://hpaste.org/
13:38:22 <dylan> bringert: already wrote it
13:38:46 <hpaste>  dylan pasted "readdirs" at http://hpaste.org/226
13:39:26 <dylan> it seems to be lazy. :)
13:48:08 <dmhouse> Yay, Monad.Reader!
13:48:08 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
13:56:09 <bos> ?where pandoc
13:56:10 <lambdabot> I know nothing about pandoc.
13:56:11 <bos> ?bot
13:56:11 <lambdabot> :)
13:56:30 <bos> ?remember pandoc http://sophos.berkeley.edu/macfarlane/pandoc/
13:56:31 <lambdabot> Done.
13:56:50 <bos> ?where pandoc
13:56:51 <lambdabot> I know nothing about pandoc.
13:57:34 <bos> sod.
13:57:41 <mauke> @quote pandoc
13:57:41 <lambdabot> pandoc says: http://sophos.berkeley.edu/macfarlane/pandoc/
13:57:42 <bos> ?help
13:57:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:55 <bos> ah. wow, major lag.
13:58:06 <allbery_b> you want @where+
13:59:24 <bos> @where+ pandoc http://sophos.berkeley.edu/macfarlane/pandoc/
13:59:25 <lambdabot> Done.
13:59:32 <bos> lambdabot really needs some help :-)
14:04:49 <bluestorm> hello
14:04:55 <bluestorm> i'm reading http://en.wikibooks.org/wiki/Haskell/Understanding_monads
14:05:07 <bluestorm> and i'm in the "Maybe" section
14:05:22 <bluestorm> and it seems me that the first piece of code isn't correct
14:05:49 <bluestorm> but i'd like to be sure before editing the wiki, as i'm a haskell beginner for now
14:06:01 <bluestorm> the last list is :   Just a  -> fn a
14:06:10 <bluestorm> should it not be :   Just a  -> Just (fn a)  ?
14:06:12 <chill> fn :: a -> Just b
14:06:18 <bluestorm> hum
14:06:25 <bluestorm> ok
14:06:30 <bluestorm> :p
14:06:32 <chill> :)
14:06:46 <allbery_b> yeh, fn is required to return a Maybe, so it does the Just (or Nothing if appropriate)
14:06:47 <bluestorm> i just forgot it :p
14:06:55 <chill> err, fn :: a -> Maybe b :)
14:06:57 <bluestorm> hmm
14:07:03 <allbery_b> otherwise there'd be no wayy for fn to produce a Nothing
14:07:19 <bluestorm> isn't there a function that do   Just a -> Just (fn a) ?
14:07:20 <allbery_b> which would seriously limit the usefulness of monadic Maybe
14:07:22 <bluestorm> a map or something ?
14:07:31 <allbery_b> fmap, liftM
14:07:37 <bluestorm> ok
14:07:43 <bluestorm> so i confused bind and fmap
14:07:46 <Excedrin> this 5 card poker evaluator is interesting, I wonder if it's possible to approach (or improve on?) this speed with a solution in Haskell
14:07:51 <allbery_b> that has its use, but (>>=) isn't for that
14:07:55 <Excedrin> http://www.suffecool.net/poker/evaluator.html
14:07:55 <bluestorm> thanks for the help :p
14:07:58 <lambdabot> Title: Cactus Kev's Poker Hand Evaluator
14:08:10 <Excedrin> it uses some neat tricks
14:09:00 <malsyned> hah.  this History of Haskell paper is great. "The Haskell community is small enough, and agile enough, that they usually not only absorb language changes but positively welcome them: it's like throwing red meat to hyenas."
14:09:26 <dmhouse> That's not really true any more
14:09:52 <malsyned> dmhouse: you're responding to that quote?
14:10:10 <dmhouse> malsyned: yeah.
14:10:57 <franka> Yes, having a relatively small user community is also an advantage.
14:11:00 <dmhouse> In an ideal world we could do things like split Monad into Monad and MonadFail, split MonadPlus, remove the Eq and Show constraints from Num, make (++) a synonym for mappend, make (.) a synonym for fmap and so on.
14:11:23 <dmhouse> But there's too much Haskell code already written to make such drastic changes.
14:11:28 <allbery_b> cf. the discussion about views on haskell@
14:11:30 <beschmi> and completely redesign Num
14:11:35 <franka> And because Haskell is a bit unconventional, we are all sort of "early adopters".
14:11:55 <dmhouse> (Your possibly disagreeing with some of the aforementioned changes doesn't invalidate my point.)
14:13:12 <sjanssen> I'd say the "red meat to hyenas" quote is accurate wrt new language extensions, but it is very much the opposite with library changes
14:13:28 <malsyned> sjanssen: I think that's what they were referring to.
14:13:41 <dmhouse> Yes, that's true. People think 'Ooh, that's cool, let's have it!'. But language _changes_, as opposed to additions, are different.
14:13:50 <malsyned> dmhouse: have there been research implementations of those ideas?
14:13:53 <allbery_b> I think it'd be nice to see some of those library changes, but you'd have to frk the Prelude
14:13:59 <allbery_b> *fork
14:14:26 <dmhouse> malsyned: I think so.
14:14:59 <allbery_b> heck, the whole library :/
14:15:51 <malsyned> a useful project would be to provide for doing things like forking the library in a graceful way.  Like, versioned modules or something, so the compiler could still support Haskell98 library calls while stealing and reusing the names for newer versions of the library.  although that makes compiler maintenance more of a headache.  legacy issues usually do.
14:16:42 <allbery_b> ghc could probably do that with packages, if handled correctly
14:17:18 <chessguy> hmm, now is the time to think about stuff like that though
14:17:26 <chessguy> before it gets unamanageable
14:17:50 <allbery_b> dunno what, if anything, hugs/yhc/jhc/nhc98 would do though
14:18:17 <abz> ?doc Data.List
14:18:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
14:18:19 <malsyned> I wish I could remember where I read the quote or what it is exactly, but I read recently a great line, something about earlier generations having it wrong about barriers to code reuse: that it wasn't licencing that would be the major obstacle, but package management and versioning.
14:18:50 <malsyned> It was in regards to .NET I think.
14:18:52 <dmhouse> allbery_b: well, when Hackage gets big, a compiler without packages will be useless.
14:18:54 <malsyned> anyway, it's a good point.
14:21:30 <dmhouse> dpiponi: ping
14:22:08 <dpiponi> dmhouse: 21 bytes from dpiponi
14:23:18 <dmhouse> Hehe. Rereading your TMR article. You mention the Gödel-Gentzen translation for classical -> intuitionistic logic. But how can this work if there are theorems of classic logic which aren't theorems of intuitionistic logic?
14:23:45 <dpiponi> When the theorem is translated from classical logic it becomes a different provable theorem in intuitionistic logic
14:24:27 <dpiponi> You can run the code and see what the translation looks like
14:24:45 <beschmi> dmhouse: is peirce's law an example for that?
14:24:51 <dmhouse> Ah, I think I get it.
14:24:56 <dmhouse> The translation isn't a bijection.
14:25:25 <dpiponi> Not a bijection. But it's "conservative" in that the proofs carry over with the propositions.
14:25:41 <dmhouse> beschmi: an example of what? A classical theorem that isn't an intuitionistic theorem? If so, yes, but a simpler example would be ¬¬p -> p.
14:25:56 <beschmi> dmhouse: oh, of course
14:26:30 <dpiponi> ~~p->p becomes ~~~~p->~~p
14:26:45 <dpiponi> The latter is provable intuitionistically
14:27:07 <dmhouse> Intuitionistic logic isn't very intuitive.
14:27:18 <dpiponi> (Or something like that. I had to work out al the gory details but I forget them now...)
14:27:24 <nominolo> was TMR released today?
14:27:26 <dpiponi> It was intuitive for Brouwer
14:27:33 <nominolo> I can't find a date on it
14:27:57 <dmhouse> Well, good for Brouwer. Things like double negation elimination sit perfectly fine with my intuition. :)
14:28:08 <malsyned> wow.  lambdabot's point-free refactoring is impressive.
14:28:47 <dpiponi> It's surprising how often you don't need ~~p->p when you think you do
14:31:12 <nominolo> ok, from the wiki changelog I assume publication date was today
14:32:31 <dpiponi> yeah, TMR was today
14:32:44 <nominolo> I guess, putting it somewhere more explicit might not be a bad idea
14:33:07 <mauke> @where tmr
14:33:07 <lambdabot> http://www.haskell.org/tmrwiki/FrontPage
14:33:33 <allbery_b> themonadreader.com is available :)
14:34:17 <dmhouse> mauke: I don't think that's the current site.
14:34:17 <nominolo> it came a little too late for me, since I created an embedded assembly myself and I didn't know about mdo ... would have really helped me ..
14:34:25 <chessguy> hey mauke, i started a thread on -cafe about some of the code we were discussing last night
14:34:28 <dmhouse> ?where+ tmr http://www.haskell.org/haskellwiki/The_Monad.Reader
14:34:29 <lambdabot> Done.
14:35:32 <nominolo> nice articles though
14:36:07 <bringert> why isn't EpochTime Integral?
14:36:41 <dmhouse> Because System.Time is crap.
14:36:56 <bringert> but it's from System.Posix.Types
14:37:03 <bringert> ClockTime is the one in System.Time
14:37:05 <allbery_b> hm, it can't' be, can it?
14:37:10 <allbery_b> TOD seconds picosec
14:37:18 <bringert> allbery_b: that's ClockTime
14:37:20 <dmhouse> Oh, okay. I was getting confused; there's an EpochTime in HAppS too.
14:37:36 <allbery_b> thought the posix one had the same issue
14:37:48 <allbery_b> both are essentially returns from getttimeofday()
14:38:16 <allbery_b> hm, guess not
14:38:29 <allbery_b> (which seems odd, now that I think about it)
14:38:45 <chessguy_work> apparently nobody's interested in my recursion thread :(
14:38:57 <allbery_b> the underlying apis are gradually moving to the same kind of split
14:39:13 <dmhouse> chessguy_work: It's only been there a few hours.
14:39:33 <allbery_b> the hyenas are too busy digesting TMR?
14:39:36 <allbery_b> :)
14:40:59 <dmhouse> Is there a type of finite lists?
14:42:06 <chessguy_work> you mean lists that _must_ be finite?
14:42:10 <Saizan> when the same code kills ghci and instead runs normally compiled is bad?
14:42:18 <dmhouse> chessguy_work: yeah.
14:42:35 <hpaste>  dylan pasted "lsx -- how can I make this smaller?" at http://hpaste.org/227
14:42:45 <dmhouse> I think it could be done with GADT lists which annotate with the length of the list using type-level Peano nats.
14:43:45 <xerox> ?where tmr
14:43:45 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
14:44:39 <dylan> I'm wondering how to make that program smaller. :)
14:48:59 <glguy> dylan: you want to use System.FilePath maybe
14:49:04 <franka> data List a = Nil | Cons a !(List a)
14:49:13 <dylan> glguy: in ghc 6.6?
14:49:14 <franka> Dunno if that is accepted.
14:49:24 <glguy> dylan: nope, it's a library
14:49:27 <franka> It makes the spine strict.
14:49:32 <dylan> in dpkg?
14:49:54 <glguy> dylan: I don't know, I don't run any linux
14:50:36 <dmhouse> franka: weird, an example where strictness actually enriches the type language.
14:50:56 <franka> It does, of course.
14:51:30 <franka> It eliminates bottom.
14:52:06 <franka> Lots of theories depend on that.
14:52:06 <chessguy_work> @quote bottom
14:52:07 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
14:52:24 <dons> ?users
14:52:25 <lambdabot> Maximum users seen in #haskell: 322, currently: 301 (93.5%), active: 51 (16.9%)
14:52:42 <chessguy_work> dons, <lambdabot> Maximum users seen in #haskell-blah: 38, currently: 38 (100.0%), active: 14 (36.8%)
14:52:57 <Taral> anyone see the monad reader?
14:52:59 <franka> I have a film to watch. Ciao.
14:53:34 <malsyned> is there a shorter way to write (a >>= (sequence . (map f))) ?
14:53:42 <dmhouse> Taral: yeah, it's good. :)
14:53:47 <dmhouse> malsyned: a >>= mapM f
14:53:52 <Taral> I like the dropWhile thing.
14:54:03 <dmhouse> Even without using mapM it's be a >>= sequence . map f, those parentheses aren't necessary.
14:54:04 <malsyned> dmhouse: I suspected as much.  thanks.
14:54:09 <Taral> But there's a simple fix for the dwBackwards stack problem... use ~(ys, xs) in the pattern match.
14:54:14 <Saizan> dons: is decodeFile with -threaded sopposed to die with "internal error: asyncRead# on threaded RTS" ?
14:54:24 <Pseudonym> I like joining with bottoms, even though it's really easy to do.
14:54:31 <dmhouse> malsyned: Remember in general that prefix function application binds tighter than anything else.
14:56:21 <glguy> mbishop: still around?
14:57:12 * mbishop nods
15:00:00 <dons> Saizan: sounds like a win32 bug that's been fixed in the head
15:00:22 <dons> could you just check that it works with the ghc nightly snapshot? (you on win32?)
15:00:31 <Saizan> (i am)
15:00:47 <dcoutts_> sjanssen, pong
15:00:49 <Saizan> mmh i'll download
15:00:54 <Saizan> it
15:01:04 <mbishop> glguy: yes, why?
15:02:30 <malsyned> dmhouse: I get in trouble with the precedence of (.), mostly
15:02:30 <sjanssen> dcoutts_: did you see Bulat's comment about binary?  "my program, FreeArc, has its own compression level on top of serializing - i.e. data serialized sent in 64k blocks to the C compression routine and both serialization and compression are run at the same time using threads"
15:02:41 <sjanssen> dcoutts_: I was going to try that with zlib and wanted your input
15:02:49 <dcoutts_> hmm
15:02:53 <sjanssen> dcoutts_: I've got to go now, but I'll ping you again later
15:02:59 <dcoutts_> ok
15:03:17 <dcoutts_> so doing the serialisation on one OS thread and compression on another
15:03:35 <sjanssen> right
15:03:47 <glguy> mbishop: who is this jemfinch and why is he interrupting
15:03:54 <malsyned> does lambdabot have a deparanthesizer?
15:03:59 <dcoutts_> sjanssen, sounds quite possible, and it could even be done generically
15:04:34 <dcoutts_> sjanssen, it's a special kind of parallel (.) operator on functions of type [a] -> [a]
15:10:20 <Saizan> malsyned, quite:
15:10:26 <sorear> @messages
15:10:27 <lambdabot> You don't have any new messages.
15:10:29 <Saizan> ?pl \a f -> (a >>= (sequence . (map f)))
15:10:30 <lambdabot> (. ((sequence .) . map)) . (>>=)
15:10:46 <Saizan> it has a obfuscating parenthesizer!
15:11:00 <sorear> yay! 114 new e-mails!
15:11:46 <malsyned> Saizan: yeah, but I don't want to convert between pointful and point-free.  I just want it to tell me (a >>= (sequence . (map f)) can be written a >>= sequence . map f
15:11:50 <malsyned> some kind of simplifier or something.
15:11:53 <mbishop> glguy: heh dunno
15:13:32 <xerox> ?pl (a >>= (sequence . (map f)))
15:13:33 <lambdabot> sequence . map f =<< a
15:14:51 <malsyned> what's the difference between @ and ? to lambdabot?
15:15:19 <glguy> nothing
15:15:31 <malsyned> k
15:16:26 <malsyned> so the answer is no, lambdabot cannot remove superfluous parentheses from expressions without also doing some refactoring?
15:16:44 <malsyned> (not that I'm down on lambdabot.  what it's doing is much more impressive.  I'm just curious.)
15:16:45 <glguy> ?. unpl pl (a >>= (sequence . (map f)))
15:16:46 <lambdabot> (a >>= \ d -> sequence (map f d))
15:17:02 <sorear> has anyone told Bulat yet "if you want ocaml you know where to get it" ? <sigh>
15:17:35 <sorear> malsyned: lb could do both, it just doesn't.  we weren't aware there was a demand for paren removal.
15:17:36 <pbx> This is a first for me -- seeing the Haskell logo on a web hosting company's home page.  http://unbit.it/#FOOTER
15:17:38 <lambdabot> Title: Unbit - Your web solutions
15:18:17 <malsyned> it'd be cool if it could.  I'm constantly throwing extra parens in because I haven't memorized the (occasionally tricky) precedence rules.
15:18:19 <SamB> what does that mean?
15:18:33 <SamB> the haskell logo, I mean
15:18:41 <hpaste>  procyon annotated "Counting the number of Applications" with "Oh so ugly Error Monad" at http://hpaste.org/223#a1
15:18:56 <pbx> That they believe there's a demand for hosting services for Haskell web apps?
15:19:27 <Procyon_> Things went totally wrong introducing an error monad.  What about this paste is assanine?
15:19:28 <Cale> malsyned: the most important precedence rule is just that function application binds tighter than anything else
15:20:05 <Cale> malsyned: so if you have f x y ++ g z, where ++ is any operator at all, it'll get parsed as (f x y) ++ (g z)
15:20:06 <dons> pbx: I've seen one other hosting compnay with prominent haskell (and lisp, and erlang) support
15:20:08 <Procyon_> The plumbing is completely exposed and I think it's incorrect now
15:20:22 <sorear> ouch.
15:20:33 <pbx> dons: Do you remember who it was?
15:20:43 <dons> hmm, it was on reddit 6 months ago
15:20:45 <sorear> I just got a piece of spam, with the word 'galois' in just the wrong place...
15:21:15 <sorear> wow, an entire collection of buggy programs
15:21:36 <malsyned> Cale: that is a good thing to bear in mind.  thanks.
15:22:25 <Cale> If you keep that in mind, you'll probably not write any more parens than most Haskell programmers would :)
15:24:01 * glguy admits to sometimes using `infix` functions to eliminate parentheses
15:24:22 <Cale> Well, there's . and $ which help too :)
15:24:49 <beschmi> glguy: `fmap` is great for that ;)
15:25:08 <pbx> So when you say "function application binds tighter than anything else" that doesn't include infix function application?
15:25:31 <glguy> `infix` function application binds just weaker than normal function application
15:25:35 <emu> function application is infix
15:25:40 <emu> the operator is the empty string
15:25:48 <glguy> you can use infix[rl] on `infix` functions
15:25:53 <sorear> dons: have you seen ndm's latest post?
15:26:10 <dons> nope?
15:26:18 <pbx> emu: I'm having trouble reconciling your comment with Cale's
15:26:33 <sorear> er, on planet.
15:26:34 <dons> sorear: "Writing code by types" ??/
15:26:36 <beschmi> sorear: reminds me a bit of the map-reduce paper
15:27:11 <beschmi> sorear: i mean the type-guided programming and the undefined trick
15:27:13 <sorear> dons: yea.  I like pointing out when people have theyre grand ideas reaffirmed...
15:28:02 <emu> it's like how multiplication is written in math
15:28:03 <malsyned> pbx: f x y `g` h x ---> (f x y) `g` (h x)
15:28:06 <sorear> dons: anyway, just from memory - I did forget to add a file :(
15:28:32 <emu> f x = f <juxtaposition> x
15:28:35 <dons> better send it on then
15:29:27 <sorear> hmm - wrt wiki, Shootout/SumFile, wasn't there a big stink over readInt?
15:29:33 <malsyned> making token-juxtaposition the function application operator is like the greatest and also most confusing things about the syntax of functional programs.
15:29:58 <dons> sorear: not that i know of?
15:30:02 <pbx> emu, malsyned: Thanks.
15:30:18 <dons> sorear: though the latest version I put up could be benchmarked and submitted
15:30:31 <malsyned> (confusing coming from an imperative language background, anyway)
15:30:39 <mauke> malsyned: not if you know perl :-)
15:31:27 <sorear> he's alive!! - Wed Jan 31 01:08:44 PST 2007  Dmitry Astapov <dastapov@gmail.com>
15:32:27 <malsyned> mauke: I do, but I always use C-style function application
15:32:39 <mauke> eww
15:32:47 <malsyned> yeah :(
15:32:54 <mauke> print($foo); ?
15:33:13 <sorear> darcs locking sucks
15:33:18 <sorear> darcs should use STM
15:34:12 <Igloo> Do you mean for locking the repository?
15:34:15 <malsyned> mauke: not for simple cases like that, but when it starts to get complicated I tend to just give up.  I haven't written serious perl apps in a couple of years, though, so Haskell may have changed my style.
15:34:19 <mauke> print(map({$_ * 2} 1 .. 5)) looks downright awful
15:34:50 <sorear> Igloo: yes
15:35:06 <sorear> Igloo: I don't think stm (the library can do it)
15:35:09 <malsyned> mauke: agreed
15:35:13 <sorear> but wouldn't it be nice!
15:35:24 <sorear> no more dead lockfiles!
15:35:29 <malsyned> but then, you could say that about a lot of perl expressions, nicely-written or not.
15:35:38 <Igloo> sorear: If you're trying to solve the stale lockfile problem then it wouldn't help
15:35:41 <Cale> When you put functions in backticks to make them infix, their precedence level is determined by fixity declarations. If no fixity declaration exists, the default level is 9.
15:35:58 <Cale> (which is the strongest available)
15:36:20 <Cale> (oh, and left associative)
15:36:25 <hpaste>  rahikkala pasted "I'm being really dumb, why doesn't this work?" at http://hpaste.org/228
15:37:09 <sorear> Igloo: how wouldn't a STM-style transactional FS help?
15:37:24 <sorear> Igloo: I don't literally mean Control.Concurrent.STM.*
15:37:34 <Igloo> You said darcs should use STM, not the FS
15:37:46 <glguy> what the hell, i have burn in on my LCD
15:38:10 <Cale> rahikkala: What's the type of board, first of all
15:38:32 <Cale> It's an Array Int (Maybe SubBoard) right?
15:38:48 <rahikkala> Ahhhhhh
15:39:04 <mauke> <- join
15:39:05 <Cale> So then  board !/ (fst coord) :: Maybe (Maybe SubBoard)
15:39:17 <eckhart> hi
15:39:21 <Cale> hello
15:39:27 <rahikkala> Cale++
15:39:53 <Cale> mauke is right, apply join to it first
15:39:58 <rahikkala> Type inference is wonderful, it's just that in the early AM hours it works better than your brain :(
15:40:08 <Cale> subBoard <- join (board !/ (fst coord))
15:40:25 <eckhart> how does it come that min (1,2) (3,4) works?
15:40:35 <mauke> @type min
15:40:36 <lambdabot> forall a. (Ord a) => a -> a -> a
15:40:42 <allbery_b> glguy: yeh, it happens.  it's curable, unlike CRTs
15:40:55 <mauke> @instances Ord
15:40:57 <allbery_b> leave it off for a few days, or display all-white for a few hours
15:40:57 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
15:41:07 <sorear> eckhart:
15:41:13 <sorear> @src (,) compare
15:41:14 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:41:21 <allbery_b> heh
15:41:23 <sorear> er,
15:41:23 <sorear>  
15:41:36 <eckhart> but there's a thousand ways to compare on (,)
15:41:47 <sorear> (a,b) < (c,d) = "lexicographic order"
15:42:40 <sorear> there is no type error there :)
15:42:51 <sorear> just define instance IsString Bool :)
15:43:21 <mauke> you mean instance Boolean String
15:43:25 <mauke> and that already exists here :-)
15:43:38 <eckhart> my question is more "what is it good for" ;-)
15:43:49 <eckhart> i see the reason in defining this for []
15:43:49 <sorear> no, instance IsString Bool - this actually exists
15:43:57 <eckhart> but why for ()
15:44:00 <sorear> eckhart: Map (Int,Int) Char
15:44:18 <Taral> @type min (1,2)
15:44:20 <lambdabot> forall a b. (Ord (a, b), Num a, Num b) => (a, b) -> (a, b)
15:44:27 <Taral> err...
15:44:28 <sorear> eckhart: you can't make maps of thinks you can't compare.  so Ord (,) makes 2-tlement maps possible.
15:44:32 <Taral> > min (1,2) (3,4)
15:44:34 <lambdabot>  (1,2)
15:44:37 <Taral> hm.
15:44:45 <Taral> ah.
15:44:52 <eckhart> sorear: ah, ok
15:45:20 <mauke> > min ("foo", 1) ("bar", 9)
15:45:21 <lambdabot>  ("bar",9)
15:46:06 <bringert> can anyone think of a better way to do this:
15:46:07 <bringert> signedOrd :: Char -> Int
15:46:07 <bringert> signedOrd c = fromIntegral (fromIntegral (fromIntegral (ord c) :: Word8) :: Int8)
15:46:31 <mauke> whoa
15:46:46 <Taral> er...
15:46:49 <pbx> How do you guys pronounce "tuple"?  I've always pronounced it as in "quintuple", a schwa. But listening to some FP lectures I kept hearing this prof say "toople".
15:47:11 <bringert> I've hear "tyoople" as well
15:47:17 <Cale> pbx: I pronounce it like the prof.
15:47:19 <bringert> heard
15:47:21 <mbishop> "tuh-pull"
15:47:35 <mauke> man, German is so much easier :-)
15:47:38 <astrolabe> signedOrd c = fromIntegral (ord c)?  or am I missing something?
15:47:41 <bringert> pbx: I go for the schwa
15:47:48 <sorear> pbx: I pronounce quintuple quintoople :)
15:47:52 <mbishop> heh
15:48:01 <Taral> bringert: Eliminate the Word8 part
15:48:04 <bringert> astrolabe: ord already gives you an Int
15:48:05 <Cale> "two-ple"
15:48:05 <allbery_b> "toopl"
15:48:11 <pbx> sorear: It occured to me that might not be precise!
15:48:16 <mbishop> well obviously I say it wrong :)
15:48:19 <bringert> Taral: ah, yes
15:48:26 <mbishop> good thing I don't actually "say" it anyway :P
15:48:33 <Igloo> I think I say roughly   chew-pull
15:48:35 <Taral> bringert: But it's probably better if you use something like:
15:48:42 <bringert> I was too obsessed with figuring out how to convert unsigned 8 bits to signed 8 bits
15:48:48 <Taral> let c' = ord c in if c >= 128 then c - 256 else c
15:48:49 <Procyon_> toopl.  Quintoopl
15:48:55 <desrt> i find that pronouncing it like toople is dangerous
15:48:55 <Taral> er
15:49:02 <Taral> let n = ord c in if n >= 128 then n - 256 else n
15:49:03 <pbx> So do all you "toople" pronouncers also pronounce "quintuple" that way?
15:49:09 <desrt> so you must say tuhple
15:49:10 <bringert> Taral: isn't that going to be a lot slower because of the branch?
15:49:14 <astrolabe> Ah! I see what it is now.  I agree with Taral
15:49:22 <notsmack> tuhple for both here
15:49:22 <pbx> desrt: What's the danger exactly?
15:49:27 <desrt> toople sounds too much like twople and then you think you're talking about pairs
15:49:32 <Taral> bringert: Are you sure it's performance critical?
15:49:37 * allbery_b doesn't think he's ever pronounced "quintuple"
15:49:49 <Taral> bringert: Don't optimize early. Write it clearly, profile it, then optimize it.
15:50:04 <bringert> Taral: it isn't really, I think. But I'm not sure I think the if one is clearer
15:50:05 <Procyon_> I don
15:50:26 <Procyon_> I don't sat "twople" for pair.  I say pairs.  hence no danger ;)
15:50:27 <Taral> bringert: The one with chained fromIntegrals and such is difficult to work out at a glance.
15:50:44 <Taral> "tuple" is sometimes used for pair anyway, so it's already confused.
15:50:46 <desrt> Procyon_; eh.  i once got confused in my head :)
15:50:58 <Cale> Well pairs are tuples
15:51:03 <Cale> they're 2-tuples
15:51:06 <desrt> if you say "tuhple" it really emphasises "this might not contain 2 elements"
15:51:10 <Procyon_> desrt: I'm always confused in my head.. so no added danger ;)
15:51:26 <Cale> You have to say 2-tuple if you mean pair.
15:51:43 <Cale> (or you can just say tuple, but then it's ambiguous)
15:51:44 <desrt> i'd never say 2-tuple.  it's just clumbsy :)
15:51:58 <Igloo> I'd say "pair"
15:52:04 <Cale> Well, right, you'd say pair :)
15:52:22 <desrt> even something like "twenty-two-tuple" is a mouth-full
15:52:26 <Cale> Unless you were defining the word pair in terms of k-tuple.
15:52:34 * desrt would sooner say "a pair of eleven-tuples" :)
15:53:12 <Cale> I don't think I've ever seen a 22-tuple.
15:53:19 <Procyon_> pair, triplet, quartet(or 4-tuple), then on to n-tuples...
15:53:32 <desrt> i guess you haven't seen my code before i learnt about record types, then
15:53:36 <Cale> pair, triple, 4-tuple,...
15:53:59 <Cale> Incidentally, monads used to be called triples
15:53:59 <desrt> not quintuple?
15:54:06 <Cale> (T,eta,mu)
15:54:09 <sit1> ouch
15:54:27 * Cale goes to supper
15:54:29 <sit1> record types are good :)
15:54:29 <Procyon_> I don't use enough quintuples to have established a nomenclature
15:54:39 <pbx> Thanks for the diction lessons!
15:55:03 <sorear> dons: w/ the add, yi compiles on 6.6 and runs (vty)
15:55:44 <Procyon_> infinooples
15:55:45 <desrt> "the lauguage's preferred pronouncation of 'tuple'" is the only aspect of programming language design which demands more careful consideration than the style of comments
15:56:42 <desrt> Procyon_; no.  just no.  not even in haskell.
15:57:09 <sorear> @remember desrt "the lauguage's preferred pronouncation of	'tuple'" is the only aspect of programming language design which demands more careful consideration than the style of comments
15:57:09 <sorear>  
15:57:09 <lambdabot> Done.
15:57:19 <sorear> dons: patch sent
15:59:16 <syntaxfree> a bolt of lightning strikes me!
16:00:40 <dons> sorear: cheers
16:01:03 <sorear> dons: so should I be keeping gtk up to date as well now?
16:02:09 <lucio__> hello! how can a i do this: (length [1,2,3]) / 2
16:02:17 * sorear trues to beuild jhc
16:02:28 <sorear> lucio__: exactly like that
16:02:38 <sorear> > (length [1,2,3]) / 2
16:02:40 <lambdabot>   add an instance declaration for (Fractional Int)
16:02:40 <lambdabot>     In the definition of `...
16:02:45 <lucio__> No instance for Fractional Int
16:02:47 <allbery_b> fromIntegral
16:02:58 <sorear> > fromIntegral (length [1,2,3]) / 2
16:03:00 <lambdabot>  1.5
16:03:01 <sit1> yeah converting integers, reals and all that is so confusing in haskell :(
16:03:12 <Botje> lucio__: you can use genericLength
16:03:18 <sorear>     No instance for (Binary (Ratio Integer))
16:03:30 <sorear> ^^^ jhc build fails in <1 minute
16:03:31 <Botje> > genericLength [1,2,3] / 2
16:03:33 <lambdabot>  1.5
16:03:41 <lucio__> great!!
16:03:45 <lucio__> thanks all!
16:03:49 <sorear> lucio__: also:
16:03:53 <sorear> > (length [1,2,3]) `div` 2
16:03:55 <lambdabot>  1
16:04:01 <sorear> see difference?
16:04:55 <lucio__> where is genericLength?
16:05:06 <Botje> lucio__: Data.List, I guess
16:05:12 <Botje> @where genericLength
16:05:13 <lambdabot> I know nothing about genericlength.
16:05:15 <allbery_b> ?index genericLength
16:05:15 <lambdabot> Data.List
16:05:16 <Botje> damn :p
16:05:21 <Botje> ah, that's the command
16:05:23 <sorear> or List probably
16:05:24 <Botje> yay :)
16:05:29 <sorear> also try:
16:05:33 <sjanssen> sorear: what version of binary are you using?
16:05:35 <Botje> but List is deprecated, no?
16:05:36 <sorear> @hoogle Num a => [b] -> a
16:05:37 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
16:05:38 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
16:05:38 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
16:05:55 <sorear> allbery_b: 0.2
16:06:03 <sorear> s/ allbery_b / sjanssen /
16:06:23 <sorear> sjanssen: upgrade complete
16:06:31 <sjanssen> sorear: the latest darcs version has instances for Ratio and Integer
16:06:42 <lucio__> woow... i need to go into deep sleep for a while a process this info
16:06:43 <lucio__> thanks all
16:06:54 <sorear> sjanssen: I'm using latest darcs now.  rebuilding...
16:07:00 <dons> sorear: want to work on the shootout?
16:07:07 <dons> there's ~10 programs that need updating
16:07:12 <sorear> I wonder whether dons 's 16-core box could bootstrap JHC :)
16:07:17 <dons> and you get some good experience tuning haskell...
16:07:51 <dons> in particular, we should outperform SBCL across the board, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=sbcl
16:07:51 <sorear> dons: hmm. tempting ... what do you need done?
16:07:53 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/27u4hk
16:07:55 <dons> with only a little bit of effort
16:08:07 <dons> sorear: one thing would be to fix fasta, knuc and sum-file to use ByteStrings
16:08:13 <dons> that would make a huge improvement
16:08:14 <sorear> just rewrite benchmarks to use bytestrings?
16:08:17 <dons> yeah
16:08:27 <dons> and make sure we beat SBCL for everything ;)
16:08:41 <dons> the process is pretty simple, grab the spec, write it in bytestring haskell,
16:08:45 <dons> put it on the wiki
16:08:53 <dons> benchmark against the existing haskell versoin using the test data
16:08:59 <dons> if its better, submit it viathe web interface
16:09:22 <dons> just doing 1 a day we'd regain most of the lost ground in a week or so
16:09:46 <dcoutts> dons, have you considered Bulat's idea about using multiple threads to do serialisation and compression, I want a neat solution... pure and compositional
16:09:55 <dons> i pondered that
16:10:04 <dons> seems heavy?
16:10:09 <bd_> dons: I actually submitted a sum-file benchmark using lazy bytestrings... I guess it hasn't gone live yet?
16:10:09 <dcoutts> compress .|. seralise
16:10:15 <sorear> I'd like to mention I didn't profile or even run the mandelbrot code 2 days ago...  just looked at the core
16:10:30 <dons> bd_ yeah, I think it dropped off the radar. I pinged isaac about it a few days ago
16:10:40 <dcoutts> @type (.)
16:10:42 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
16:10:46 <dons> bd_ also, i put up my own version (un-benchmarked) which you might want to look at
16:10:50 <dons> ?wiki Shootout
16:10:50 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
16:11:07 <dons> sorear: ah yes, fixing mandelbrot would be a great contribution
16:11:25 <dons> you just have to be careful to follow the letter (and usually spirit) of the spec
16:11:36 <dcoutts> (.|.) :: (Lazy.ByteString -> c) -> (a -> Lazy.ByteString) -> a -> c
16:11:46 <sorear> yeh, my last fix would no doubt fail
16:12:12 <dcoutts> (.|.) :: ([b] -> c) -> (a -> [b]) -> a -> c
16:12:19 <dcoutts> dons, ^^
16:12:45 <dons> is that a parallel op?
16:12:58 <dcoutts> but I was trying to figure out if it can be implemented neatly using Control.Parallel.Strategies
16:13:02 <dons> yeah
16:13:03 <sorear> dcoutts: that conflicts w/ Data.Bits
16:13:04 <bd_> dcoutts, ([b] -> c) -> [b] -> c, perhaps? :)
16:13:20 <sorear> now recompiling DrIFT
16:13:21 <dcoutts> bd_, huh?
16:13:28 <dcoutts> sorear, oh yeah, good point
16:13:43 <bd_> dcoutts: Why would the parameter to the second function need to be passed in? Just use laziness...
16:13:46 <sorear> dons: I wonder what will happen to Haskell when Jhc is admitted (muahahaha)
16:13:59 <Igloo> dcoutts: There's no way to limit the memory use of the thing in the middle if you do them in parallel, though, right?
16:14:03 <bd_> actually, why not just [a] -> [a] ? With parallel computation generating the list [up to some limit] ahead of time
16:14:17 <dcoutts> Igloo, use a MVar so you don't get more than one ahead
16:14:33 <dcoutts> bd_, oh yeah, hmm
16:14:53 <dcoutts> bd_, yeah, that's nice.
16:15:01 <Igloo> dcoutts: Hmm, with that type signature?
16:15:11 <dcoutts> Igloo, sure, why not?
16:15:32 <bd_> a convenience infix operator might be nice, but it's probably not the primitive form ... :)
16:15:40 <Igloo> dcoutts: Lack of IO?  :-)
16:15:45 <sjanssen> dons: should the reworked fasta be on the shootout site?  It doesn't appear to be
16:15:54 <bd_> Igloo: It doesn't need IO as long as it's pure... :)
16:15:58 <dcoutts> Igloo, that's no barrier! or we could use par possibly
16:16:22 <bd_> Igloo: semantics would be the same as eg: (.|.) = ($)
16:16:26 <bd_> except, parallel
16:16:28 <sjanssen> dcoutts: can you describe the strictness of compress to me?
16:16:46 <dcoutts> sjanssen, erm, how do you mean?
16:17:03 <dons> sjanssen: there's seems to be some hold up. i've mailed isaac, but the shootout scores haven't been updated for days
16:17:07 <Igloo> bd_: The overall effect would be pure, but there would be quite a lot of scary stuff around
16:17:19 <dcoutts> Igloo, sure, just like the innards of par
16:17:24 <bd_> Igloo: yep, but that's all hidden in the implementation :)
16:17:24 <sjanssen> dcoutts: does compress ever pattern match "LPS [x]", or "LPS (x:y:xs)"?
16:17:26 <dons> sjanssen: also, there were problems with missing mtl and other extra libs
16:17:49 <dcoutts> sjanssen, sure, it has to pull chunks out one by one
16:17:49 <bd_> parList (x:xs) = xs `par` x:parList xs; parList [] = []
16:18:19 * dcoutts tries to understand parList
16:18:33 <sorear> dons: I'm compiling jhc now... <muahaha>
16:18:51 <michaelw> hmm, so when i use ghc -odir foo -hidir foo --make Main.hs; ghc $SAMEOPTS Main2.hs , it seems the linker trips over missing symbols.  without the *dir options everything works fine
16:19:11 <sjanssen> dcoutts: right, but does it pattern match against more than one cons cell at a time?
16:19:19 <dcoutts> bd_, doesn't that do the whole list, not just one place?
16:19:36 <dcoutts> bd_, we want parListN 1 I think, no?
16:19:37 <bd_> dcoutts: hm, point :)
16:20:01 <bd_> oh, it's already implemented XD
16:20:06 <dcoutts> bd_, I was looking through Control.Parallel.Strategies
16:20:13 <dcoutts> but I don't understand it well enough
16:20:26 <dcoutts> so it's been staring me in the face?
16:20:47 <sjanssen> I don't think parList is the solution
16:21:17 <dcoutts> what we want is that when we demand the first element, it sparks the evaluation of the second element
16:21:29 <sjanssen> it evaluates each cell in parallel, but Data.Binary.encode is inherently sequential
16:21:35 <dcoutts> but doesn't carry on with the third 'til we demand the second
16:21:45 <bd_> the source seems better documented than the haddock >.>
16:21:58 <dcoutts> yeah, the haddock docs are poo
16:22:35 <dons> comments I don't think we'd see a few years ago: "Lisp, for all the strengths of its flexible type system, hasn?t got this issue right either.
16:22:39 <dons> Otherwise Haskell and OCaml (and C++, gack) wouldn?t be kicking its ass all over the performance
16:22:42 <dons> map."
16:22:48 <dons> damn straigh!
16:22:58 <dcoutts> :-)
16:23:08 <bd_> parListN 1 (\x -> case x of [] -> (); _ -> ()) ?
16:23:16 <mbishop> lisp never really was about performance though
16:23:27 <dons> certainly
16:23:35 <mbishop> and there is stalin, which makes ungodly unsafe but fast binaries heh
16:23:41 <mbishop> in an ungodly amount of compile time :)
16:23:50 <sorear> unsafe?
16:23:57 * sorear listens
16:24:00 <dons> other comments you *don't* like to see 'JavaScript is probably the most important language in the world today.'
16:24:07 <dons> yay for blogs
16:24:14 <sorear> 87/164
16:24:26 <mbishop> stalin optimizes a lot heh, it removes bounds checking and such I'm sure
16:24:34 <mbishop> so "unsafe"
16:25:06 <sorear> google "stalin" --> #10
16:25:42 <sorear> first 9 are josephs, unsuprisingly
16:26:00 <dcoutts> bd_, that's the same as parListN 1 rwhnf  isn't it?
16:26:48 <bd_> hmm
16:27:09 <bd_> parListN 1 (\x -> case x of (x:_) -> x `seq` (); _ -> () ) even XD
16:28:05 <Procyon_> ?src head
16:28:05 <lambdabot> head (x:_) = x
16:28:06 <lambdabot> head []    = undefined
16:28:37 <bd_> ... is it safe to have bottom arise in a Strategy?
16:28:43 <dons> I wish this guy would hang out here, http://blogs.nubgames.com/code/?p=18
16:28:45 <lambdabot> Title: Nub Games » Writing a Simple Search Engine in Haskell: Part 0 &#8212; Introduct ...
16:29:13 <dons> hehe "Please, nobody post this to Reddit until I?ve completed at least the first part"
16:29:26 <sorear> hehe.
16:29:28 <dcoutts> bd_, parBuffer perhaps?
16:29:46 <dcoutts> "implements a `rolling buffer' of length n, i.e.applies a strategy to the nth element of list when the head is demanded."
16:29:55 <sjanssen> !paste
16:29:56 <hpaste> Haskell paste bin: http://hpaste.org/
16:30:26 <dcoutts> bd_, so perhaps it's parBuffer 1 rwhnw
16:30:42 <hpaste>  sjanssen pasted "mkPar: is this right?" at http://hpaste.org/229
16:31:04 <dons> http://programming.reddit.com/info/128w3/comments
16:31:05 <lambdabot> Title: Sketching in Haskell: coding by types (reddit.com)
16:31:31 <glguy> dons: I like how he compliments me for reading his blog
16:31:38 <glguy> dons: I *am* pretty smart
16:31:46 <dons> he
16:31:49 <dons> yeah, I liked that too
16:31:56 <glguy> I think I'll keep reading ;)
16:32:02 <sorear> glguy: he compliments you by name?
16:32:09 <glguy> sorear: yup!
16:32:23 <glguy> I go by "hey you" and just "you" all the time
16:32:37 <Botje> my nickname is "STOP HIM!"
16:32:50 <edwinb> The wonders of laziness never fail to amaze me. It turns out my program has a latent crash which only occurs now that I really need it to work.
16:32:57 <dons> you: did you see the comment on the -cafe about making the pastes more searchable?
16:33:05 <dons> I mean, glguy , hey you!
16:33:05 <malsyned> are fmap and liftM equivalent?  lambdabot seems to think so.
16:33:12 <Taral> @type fmap
16:33:12 <jcreigh> edwinb: aww, that happens with in script languages too. :)
16:33:13 <Taral> @type liftM
16:33:14 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
16:33:15 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
16:33:18 <dons> edwinb: heh
16:33:19 <jcreigh> *strict
16:33:23 <glguy> dons: I didn't, what was the suggestion?
16:33:25 <Taral> as you can see, not quite equivalent
16:33:27 <sjanssen> malsyned: they should be, for types that implement both Functor and Monad
16:33:30 <dons> glguy: let me forward it on
16:33:31 <allbery_b> malsyned: one expects a Functr, the other a Monad.  many Monads are Functors, but not all
16:33:37 <glguy> dons: just tell me the subject
16:33:39 <Taral> malsyned: They're the same idea though.
16:33:39 <allbery_b> so they are often but nt always interchangeable
16:33:40 <edwinb> it only happens when I do ' case exp of Nothing -> return (); Just _ -> return ()
16:33:44 <glguy> dons: I subscribe, but don't read everything
16:33:46 <edwinb> which is particularly impressive
16:34:30 <allbery_b> if you want t  get even more esoteric, map and (.) generalize to the same concept fmap and liftM do
16:34:33 <Botje> edwinb: that's not terribly useful :)
16:34:40 <glguy> dons: I found Alexy's comment
16:34:44 <malsyned> is there a nicer way to say liftM f (sequence actionList) ?
16:34:47 <allbery_b> (this generalization is *not* expressed in Haskell's libraries currently)
16:34:53 <edwinb> I'm amazed it ever worked.
16:34:54 <edwinb> oh well
16:34:56 * edwinb gets back to it
16:37:38 <Botje> malsyned: sequence actionList >>= f ?
16:37:46 <dons> here's an interesting snipped from the polymer simulation in haskell (and C) project I'm part of,
16:37:50 <dons> The intel C++ compiler generates code about 60% faster than the GCC
16:37:52 <dons> (for both pentium4 and Itanium architectures).
16:38:07 <glguy> dons: searching a bunch of gzipped pastes would be slow  :)
16:38:10 <glguy> ideas?
16:38:13 <dons> (this is a specialised molecule simulator generated at runtime by Haskell, spitting out C. intel cc is just a hell of a lot better)
16:38:26 <dons> glguy: i'm thinking we have a mechanism for exporting pastes
16:38:36 <dons> i.e. a script that takes a checkpoing, extracts the pastes
16:38:40 <dons> and dumps them in a darcs repo
16:38:46 <dons> for people to do whatever they want with
16:38:51 <glguy> ahh
16:38:55 <dons> it would just use the PasteState type
16:39:01 <dons> and run once a day or some such
16:39:02 <sit1> someone should write a c compiler in haskell ;)
16:39:11 <dcoutts> dons, writeFile f . GZip.compress . parBuffer . Binary.serialise
16:39:14 <Botje> sit1: or a haskell compiler in C!
16:39:20 <dons> dcoutts: hmm!!1
16:39:37 <sjanssen> dcoutts: and it works?
16:39:43 <dcoutts> not yet :-)
16:40:00 <sit1> I've done a little bit of parsing stuff with parsec, it's amazing :)
16:40:07 <sorear> glguy: remember, non-regex searches can be dons in O(log n)
16:40:36 <dcoutts> parBuffer :: Lazy.ByteString -> Lazy.ByteString
16:40:37 <dcoutts> parBuffer (LPS cs) = LPS (Par.parBuffer 1 Par.rwhnf cs)
16:40:40 <glguy> "dons in"? You've been in #haskell too long
16:40:54 <dcoutts> sjanssen, try it ^^
16:41:13 <glguy> sorear: you mean if I built a binary search tree of words indexing paste ids?
16:41:15 <dcoutts> dons, or you've got a parallel box, you can try it
16:41:23 <dcoutts> a multi-cpu box I mean
16:41:29 <sorear> glguy: words are too arbitrary.
16:41:37 <dons> yeah, got to set that up today actually
16:42:03 <sorear> glguy: suffix delta trees can handle arbitrary subsequences ... phrase search!
16:42:20 <sorear> 145/169
16:42:40 <sorear> who'd've guessed jhc compiles faster than ghc?
16:42:56 <sit1> vs ghc using gcc or -fasm?
16:43:03 <glguy> sorear: I'll look into that structure
16:43:11 <sorear> sit1: -fvia-C ... makes it even scarier
16:43:38 <sorear> @google "suffix array" wikipedia
16:43:40 <lambdabot> http://en.wikipedia.org/wiki/Suffix_array
16:43:45 <sorear> ^^^^ where I learnt
16:43:50 * glguy dinner
16:47:54 <dons> ?remember bulat are computers created to makes people's lives easier or peoples created to make computers more productive?
16:47:54 <lambdabot> Done.
16:48:47 <dons> sorear: hmm, you should send off the mandelbrot text to g-h-u.
16:48:56 <dons> but with the original code and some comments on what you were doing
16:49:13 <dons> you'll at least get spj's opinion on whether it means anything for ghc
16:49:34 <sorear> how'd it look?
16:49:57 <sorear> the version I sent you when I decided it probably wasn't fit for the list
16:50:16 <dons> yeah, a bit sketchy. i.e. missing details that outsiders would need :)
16:50:33 <dons> the techincal stuff was there, but missing text to help a reader follow what was happening
16:50:47 <abz> ?doc Monad
16:50:47 <lambdabot> Monad not available
16:50:56 <dons> ?docs Control.Monad
16:50:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
16:50:58 <sorear> I just have ... no clue what to say.
16:51:02 <sorear> :(
16:51:08 <abz> thanks'
16:51:59 <sorear> jhc compiles in 1/2 hour, with -fvia-C ... wow
16:52:08 <dons> its a smaller system
16:52:16 <dons> or you mean, compiles with itself??
16:52:28 <sorear> nah :)
16:52:31 <sorear> with ghc-6.6
16:54:30 <sjanssen> dcoutts: parBuffer doesn't seem to have an effect
16:54:44 <abz> whats the function that does this for me
16:54:48 <abz> ps <- mapM (...) xs
16:54:48 <dcoutts> sjanssen, semantically it's id
16:54:48 <abz> somefunction ps
16:54:48 <abz> return ps
16:54:58 <dcoutts> sjanssen, so the question is how would we tell
16:55:10 <sjanssen> dcoutts: it's actually slower if I run with +RTS -N2
16:55:12 <dcoutts> sjanssen, we could tell by adding some trace side effects
16:55:24 <dons> ?. pl . undo do p <- mapM f xs ; g p ; return p
16:55:24 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "do"
16:55:29 <dons> ?. pl undo do p <- mapM f xs ; g p ; return p
16:55:30 <sjanssen> but there could be any number of complications here
16:55:30 <lambdabot> liftM2 (>>) g return =<< mapM f xs
16:56:41 <abz> excellent. thanks.
17:02:51 <hpaste>  xpika pasted "works with runhasll but not GHC?" at http://hpaste.org/230
17:04:05 <sorear> in a word - preemption
17:04:21 <Igloo> xpika: For compiled programs at least, the program will exit as soon as the main thread exits
17:04:24 <sorear> add a threadDelay 1000000 at the end of main
17:04:32 * Igloo isn't sure if that's not the case for runhaskell or if you just got lucky
17:04:42 <dons> xpika: the programs exits when main exits
17:04:45 <xpika> @hoogle threadDelay
17:04:46 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:04:50 <dons> for runhaskell, that's ghci, so hmm, the main thread is doing other things
17:04:55 <xpika> ok
17:04:56 <sorear> Igloo: why is this?  I've only (noticed) being hurt by this "feature"
17:05:01 <dons> you should just not fork the last thread
17:05:04 <dons> run that in main
17:05:09 <dons> or else wait on both threads
17:05:24 <Igloo> If you want to control when you exit then the normal way is to use an MVar to signal to the main thread when your forked threads are done
17:05:42 <dons> ?docs Control.Concurrent
17:05:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
17:05:44 <dons> has examples
17:05:51 <Igloo> sorear: Not entirely sure of the reasoning
17:05:57 <sorear> Igloo: that's ... iritatingly non moduler.  why should the lambdabot core care whether the plugins have running threads?
17:06:22 <Igloo> The lambda core should presumably be telling the plugins to shut down cleanly
17:06:34 <Igloo> And the plugins can then wait for their threads, if they think they should be waited for
17:06:41 <dons> yeah, plugins register exit handlers
17:06:46 <dons> which thecore calls on unloading
17:06:50 <dons> killing any threads
17:06:57 <sorear> Igloo: the lambda core is just functions.  after the bot connects to a server, the core has nothing else to do.
17:07:13 <sorear> but since the plugin 'IRC' has a running thread, the bot shouldn't exit
17:07:41 <sorear> but it did, so I put in an evil MVar kluge and a paragraph of vitriol.
17:08:22 <sorear> now, main waits on a "dead" mvar
17:08:42 <sorear> the mvar is referenced in the global state structure, with a big "DO NOT TOUCH" note
17:08:54 <sorear> maybe stableptrs would have been cleaner :(
17:09:12 <sorear> so yes, GC killed the bot
17:09:30 <sorear> sit1: 10m with -fasm
17:09:52 <siti> arg is my name still sit1 ?
17:09:52 <siti> :S
17:09:52 <lambdabot> siti: You have 1 new message. '/msg lambdabot @messages' to read it.
17:09:57 <Igloo> Why are you forking the IRC stuff rather than just calling it?
17:10:31 <sorear> Igloo: you can't call two functions, but you can fork two threads.
17:10:41 <siti> wooho I got mail :D
17:10:43 <sorear> Igloo: lambdabot supports multi server now.
17:16:12 <sorear> ahh ... jhc building libs now ;)
17:16:43 <dons> Igloo: I like this whole mtl strict/lazy stuff you're looking into
17:17:01 <sjanssen> dcoutts: I've got an MVar solution
17:17:02 <dons> strict and lazy State* with precise control would be very welcome
17:17:31 <dcoutts> sjanssen, great, does it work? I mean does it make it go faster?
17:17:43 <dcoutts> sjanssen, we'd have to play with the chunk size
17:17:44 <Igloo> dons: Send opinions then, please  :-)
17:17:49 <dons> ah ok :)
17:18:08 <sjanssen> dcoutts: the program consumes approx. 115% CPU
17:18:19 <dcoutts> interesting
17:18:32 <sjanssen> (I was serializing a phony infinite type for testing purposes, so no comparison yet)
17:18:40 <dons> you know what would get multicore/smp going fster...
17:18:46 <Igloo> This is threatening to turn into a rather large propsal, given it started off as just adding a single ~
17:18:46 <dons> if instead of reporting 100% cpu == 1 cpu in use
17:18:49 <dcoutts> no, what?
17:18:52 <dons> it reported 1 cpu as a fraction of the %
17:18:57 <dcoutts> ah
17:18:58 <dons> so, if i have 16 cores, and i'm only using 1
17:19:01 <dons> it would say
17:19:03 <dcoutts> you're using 22%
17:19:09 <dons> > 1 / 16 * 100
17:19:10 <lambdabot>  6.25
17:19:15 <dons> 6.25% cpu :)
17:19:22 <dcoutts> and you'd go.. eeek!!
17:19:22 <dons> rather than 100% cpu
17:19:25 <dons> right!
17:19:25 <dcoutts> what a waste!
17:19:35 <dons> and start hunting for a good smp/parallel language
17:20:13 <dons> the whole % thing as is doesn't scale well
17:20:17 <sorear> ururk:  12003 stefan    18   0  402m 350m 4496 D  4.6 92.8   3:06.20 jhc
17:20:22 <dons> since people don't understand 3200 %
17:20:50 <dons> > printf "%0.2f%%" ( 1 / 32 * 100  :: Double)
17:20:51 <lambdabot>  Add a type signature
17:20:55 <dons> > printf "%0.2f%%" ( 1 / 32 * 100  :: Double) :: String
17:20:57 <lambdabot>  "3.13%"
17:21:02 <dons> but they do understand 3.13%
17:21:27 <dons> Igloo: yeah.
17:21:45 <sorear> wow, jhc is even more ram hungry than darcs
17:21:47 <dons> that's the issue, its *almost* like you're volunteering to solve the long standing strict/lazy mtl issues :)
17:22:15 <Igloo> Heh
17:23:09 * Igloo doesn't like the duplication it'll cause, but I think it's nicer than trying to generate lazy and strict from a single source
17:23:37 <edwinb> gaah, I used to claim trace was absolutely fine for debugging
17:24:02 <edwinb> now I'm getting no output at all, not even the error message I got before putting the traces in...
17:24:54 <sorear> 12003 stefan    18   0  451m 348m 3636 D  0.7 92.2   3:31.59 jhc
17:26:25 <mauke> there's this TMR article about defining dropWhile in terms of foldr
17:26:40 <mauke> I wonder why it doesn't talk about my solution
17:27:05 <sjanssen> mauke: what is your solution?
17:27:14 <mauke> dw p xs = foldr (\x z f -> if f x then z f else x : z (const False)) (const []) xs p
17:27:42 <sjanssen> mauke: I came up with that one too
17:27:58 <mauke> it uses foldr to built a higher order function, but unlike dwHo it doesn't use the list twice
17:27:59 <hpaste>  Procyon_ pasted "Not using Error monad correctly.  Help" at http://hpaste.org/231
17:28:04 <sjanssen> it seems to be the most obvious HO solution
17:28:09 <mauke> yeah :-)
17:28:52 <dibblego> ?where frag
17:28:53 <lambdabot> http://www.haskell.org/haskellwiki/Frag
17:29:08 <Procyon_> Can someone take a quick look at that hpaste and tell me what I need to be abstracting but am not?  There is no way the code should look like that in my apply function.
17:30:06 <Procyon_> And I'm so confused.  And sad. *sniff
17:30:22 <dibblego> ?where sudoku
17:30:22 <lambdabot> I know nothing about sudoku.
17:31:10 <mauke> do { func <- eval a; f <- apply func b; eval $ Apply f x }
17:31:27 <sorear> my system is too busy thrashing...
17:32:25 <Thomas2> Procyon_: what apply does looks a lot like what bind does in the Left/Right monad (does haskell call that Sum?)
17:32:33 <Thomas2> :t Left
17:32:35 <lambdabot> forall b a. a -> Either a b
17:32:36 <xpika> does anyone know of any cheap hosting? I wan't to create a haskell website.
17:32:42 <Thomas2> oh, Either
17:33:01 <Procyon_> mauke:  OK, so what happens to the error case?
17:34:11 <Thomas2> Procyon_: the bind operator (which holds together do blocks) already stops execution when a Left case is produced
17:34:38 <Procyon_> AHA!
17:34:54 <Procyon_> :)  This makes me very happy.
17:35:01 <Thomas2> yeah, that's its job
17:36:12 <Procyon_> I have 57 or so of these stupid case statements going on in my module and I'm thinking "The damn thing compiles and works, but this CAN'T be how monads "simplify" my code"
17:36:29 <sjanssen> @paste
17:36:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:36:49 <hpaste>  sjanssen pasted "MVar parBuffer" at http://hpaste.org/232
17:36:55 <sjanssen> dcoutts: ^^^
17:38:52 <dcoutts> sjanssen, looks sane
17:39:35 <dcoutts> do we know how big those chunks are?
17:40:00 <dcoutts> sjanssen, hold on a sec..
17:40:35 <sorear> 12003 stefan    18   0  563m 350m 4016 D  1.8 92.9   4:21.26 jhc
17:40:39 <dcoutts> sjanssen, that's not sparking the next one, ie no parallelism
17:41:32 <Procyon_> I actually comprehended a monad!  *dances*
17:41:44 <dcoutts> sjanssen, it needs to do prod (x:x':xs) and evaluate x, spark x' and putMvar x
17:41:46 <sorear> @tell dons mad idea - Parallel synhl!!!
17:41:46 <lambdabot> Consider it noted.
17:45:09 <wojtekk> What is the canonical way of using haddock with debianized GHC packages? Basically I want to generate docs for some extra libraries and can't get haddock seeing already existing docs
17:45:16 <sjanssen> dcoutts: I believe the current version is correct
17:45:52 <dcoutts> sjanssen, track an x in the output list backwards
17:46:26 <dcoutts> it cause a takeMVar in cons, which waits for a putMVar in prod
17:46:42 <dcoutts> and at that point, x has been evaluated
17:46:57 <dcoutts> but there's no more evaluation of xs
17:47:25 <dcoutts> so we're just forcing elements in one thread and passing them to another thread
17:47:36 <dcoutts> where's the overlapping of evaluation ?
17:48:03 <sjanssen> dcoutts: the overlapping evaluation happens in the function that consumes the output of parBuffer
17:48:10 <xpika> is there a way to join two threads. ie have one thread start when another finishes?
17:48:15 * sorear <3 Vvirtual memory
17:48:22 <dcoutts> xpika, using MVars
17:48:48 <sorear> xpika: forkIO (thread1 >> thread2)
17:49:43 <dcoutts> sjanssen, sorry, I don't see it. The function that consumes the output is just getting chunks after they've been forced in the other thread
17:50:16 <sorear> gah this is taking too long
17:50:16 <sjanssen> dcoutts: right, after the consumer function takes a chunk the prod thread resumes and generates another
17:50:57 <dcoutts> ah, hmm
17:51:22 <dcoutts> yes ok
17:51:59 <dcoutts> sjanssen, so you've got a 2cpu box?
17:52:12 <dcoutts> I'm wondering why we see no speedup
17:52:18 <sjanssen> yeah, Core Duo 1.83 GHz
17:52:25 <sjanssen> dcoutts: we see a very small speedup
17:52:31 <dcoutts> very very small
17:53:03 <sjanssen> I'm guessing either compression or encoding is significantly faster than the other, so one thread is often waiting
17:53:04 <dcoutts> it'd be useful to know how much time is spent by the producer and consumer processing chunks
17:53:07 <dcoutts> right
17:54:00 <dcoutts> sjanssen, try decompressing and re-compressing
17:54:08 <dcoutts> or the other way around
17:54:55 <dcoutts> and first of all time just compression and then time just decompression
17:55:02 <dcoutts> so we can see how they match up in speed
17:55:25 <dcoutts> so we should be able to predict the speedup from the pipelining
17:59:10 <sorear> heh.  I wonder which would be faster: jhc-compiled-by-ghc | jhc-compiled-by-jhc
17:59:28 <SamB> sorear: what? you can do that now?
17:59:33 <sorear> given that with ghc my system is just over the edge of thrashign
17:59:36 <sorear> SamB: huh?
17:59:47 <sorear> SamB: does JHC use !YHC extensions?
18:00:09 <sjanssen> dcoutts: will the FFI calls made by compress/decompress run in parallel?
18:00:27 <SamB> I was under the impression that JHC used extensions that it didn't support yet. or at least libraries.
18:00:48 <sorear> well, I'll have to fix this!
18:00:58 <dcoutts> sjanssen, should do, if they're on separate OS threads
18:01:00 <sorear> or just track down all the space leaks <grin>
18:01:19 <Igloo> With -threaded they should
18:01:56 <dcoutts> sjanssen, hmm, in my test the decompression is so much faster than the compression that again, it wouldn't be a good example
18:02:02 <dcoutts> sjanssen, it's like 10x difference
18:02:21 <sjanssen> maybe compress twice then?
18:02:35 <sorear> next project: *haskell* synhl in yi.
18:02:40 <dcoutts> sjanssen, no, it's the decompression that's 10x faster
18:03:06 <dcoutts> sjanssen, we need to make the decompress slower, hmm, perhaps by recompressing
18:03:23 <sjanssen> dcoutts: instead of testing (decompress . compress), we can test (compress . compress)
18:03:33 <dcoutts> oh I see
18:03:42 <sjanssen> starting with a random source of data, they should be about equivalent, yeah?
18:03:50 <dcoutts> true
18:04:08 <sjanssen> ./zip_encode +RTS -N2  0.78s user 0.89s system 121% cpu 1.373 total -- compress . compress reading from /dev/urandom
18:04:14 <dcoutts> I was thinking of: compress 1 . decompress . parBuffer . compress 3
18:10:56 <sorear> Does jhc support -fuse-less-memory? :)
18:11:58 <Nafai> What's jhc?
18:12:33 <sorear> JohnMeacham 's haskell compiler
18:12:39 <sorear> @seen JohnMeacham
18:12:40 <lambdabot> Last time I saw JohnMeacham was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.dut, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavia
18:12:41 <lambdabot> n and #unicycling 7d 5h 2m 17s ago, and .
18:13:17 <sorear> got (before ^C) to 600M compiling base
18:13:25 <sorear> my system has 384
18:13:35 <sorear> 0.3% cpu !
18:16:52 <hpaste>  sjanssen annotated "MVar parBuffer" with "compress . compress" at http://hpaste.org/232#a1
18:16:54 <sorear> I just gave jhc the +RTS -M375M -RTS ...?
18:17:08 <sorear> hopefully it will GC more now :)
18:17:31 <sjanssen> dcoutts: runtime goes from 20 seconds to 11 seconds :)
18:17:37 <sorear> which is faster GC or VM?  I hope I know the answer ...
18:18:01 <sorear> ah good, seems GC is correct
18:22:23 <sjanssen> dons: do you have that monster-core box yet?
18:22:31 <Procyon_> in an if then else clause, if I am outside a monad, then if, then and else can all have the same indentation, but inside a monad, then and else must be indented further.  WTF?
18:22:45 <Procyon_> inside a do rather
18:23:04 <sorear> Procyon_: it must be all one statement either way
18:23:15 <sorear> Procyon_: if has *nothing to do* with monads or do
18:23:23 <sorear> Procyon_: but it must be one statement.
18:23:28 <jre2> any guesses on how hard/painful it would be for a haskell newbie to try using some function from another language via COM or DLL?
18:23:40 <Procyon_> haskell mode in emacs wants them to line up in the same collumn.
18:23:47 <sorear> Procyon_: do automagically chops up your statements based on intentation
18:24:02 <sorear> Procyon_: haskell-mode sucks. "feel free to write something better"
18:24:11 <Procyon_> sorear: hehe
18:24:12 <sjanssen> jre2: Haskell interfaces with C quite nicely.  DLL/COM might be tricky though
18:25:24 <mbishop> Is vim's haskell support better?
18:25:29 <Procyon_> sorear: so, outside of a do, the indentation is pretty much ignored, but inside it's going to try to bind anything with the same indentation?
18:25:52 <sjanssen> mbishop: vim has syntax highlighting and not much more
18:25:57 <sorear> Procyon_: exactly.
18:26:13 <mbishop> sjanssen: no indentation rules?
18:26:25 <sorear> Procyon_: do, let, where, and case (am I missing any) are subject to the layout rule ... but you only use if in do
18:26:34 <sjanssen> mbishop: precisely
18:26:35 <sorear> let if .. is a syntax error
18:26:46 <sorear> if it were legal it would give the same greif
18:27:00 <mbishop> sjanssen: so are there no editors with good haskell support? :/
18:27:05 <jre2> sjanssen: any idea what library is best to use and the best place to look for information on it?  I saw a reference to hscom in the sequence newletter but its not entirely complete from what I hear
18:27:20 <allbery_b> if can be used outside do, and is subject to the layout rule
18:27:25 <sorear> mbishop: emacs has very good support.
18:27:42 <sjanssen> jre2: I'm not well educated on the subject
18:27:44 <sorear> mbishop: but when you are talking Haskell, very good is still very bad.
18:27:47 <Procyon_> sorear: thanks.  good to know.  Now to figure out a cannonical format for if inside do that doesn't confuse emacs ;)
18:27:51 <allbery_b> foo a = if somePred a then something a\n<indent>else somethingElse
18:28:09 <jre2> sjanssen: ah, alright
18:28:18 <mbishop> yeah, I use emacs currently
18:28:21 <mbishop> and it's not very good at all
18:28:27 <mbishop> haskell support that is
18:28:35 <malsyned> yeah, I ran into the same problem with if inside do a couple days ago.
18:28:35 <Cale> Procyon_: It's like this
18:28:39 <Cale> do foo
18:28:43 <Cale>    if p
18:28:49 <Cale>       then do ...
18:28:50 <aFlag> Is there an easy way to return a IO Nothing without executing the rest of the do-block?
18:28:53 <Cale>       else do ...
18:28:58 <sorear> mbishop: I don't like manual indentation because it becomes inconsistant.
18:29:13 <syntaxfree> haha.
18:29:16 <Cale> the important bit being that the 'then' and 'else' are lined up and indented farther than the 'if'
18:29:18 <allbery_b> aFlag: ContT, or if ... then return Nothing else do ...
18:29:19 <syntaxfree> second time this week I'm outcoded.
18:29:22 <malsyned> it works fine if the if is on the right-hand side of a binding (x <- if...), but it's easy to confuse otherwise.
18:29:31 <sorear> jhc is *much* *much* faster with +RTS -c
18:29:35 <syntaxfree> First, Pancito. But that's okay, I had dropped my pancito-like project months ago.
18:29:36 <Procyon_> Cale: right... but haskell-indent in emacs won't do that automagically.  it wants it lined up in the same collumn
18:29:37 <syntaxfree> Now Pandoc!
18:29:43 <syntaxfree> It parses Markdown!
18:29:46 <aFlag> allbery_b: I see, thanks
18:29:50 <syntaxfree> I was just working in a Markdown parser!
18:30:00 <Cale> Procyon_: I'd call that a bug. Try switching smart indent off, and go with simple.
18:30:16 <sorear> Procyon_: that's the only glitch that regularly bites me.
18:30:27 <allbery_b> (stacking ContT lets you invoke a return action to pop out from wherever you are)
18:30:32 <syntaxfree> bah, I hope the meds make me more productive.
18:30:46 <TomMD> In the language that comes after 'B' in the alphabet, I can delcare a structure, use it, then just give that structure to about any 'send' function and it will go over the wire nicely.  I am getting somewhat tired of making 'Storable' instances for every data structure in Haskell - what is the automated way to do this while still keeping your wire format to an arbitrary standard.
18:30:49 <malsyned> so there's about as many Monad tutorials as there are Haskell users.  Are there any good explanations of these "Arrows" I keep reading about?
18:30:54 <Procyon_> Cale: oh, but simple indent is TOO dumb.  I'd be manually formatting my indents all over.  It would make emacs feel like visual studio.  How quaint.
18:30:54 <TomMD> s/\./?
18:31:25 <sorear> P- !devioving Binary -}
18:31:54 <allbery_b> @google wikibook arrows
18:31:55 <sorear> jhc is much much much much faster witrh +RTS -c
18:31:57 <lambdabot> http://en.wikibooks.org/wiki/Adventist_Youth_Honors_Answer_Book/Recreation/Archery_-_Advanced
18:32:02 <allbery_b> hm, not that one :)
18:32:06 <allbery_b> @google wikibook arrows haskell
18:32:07 <hyrax42> TomMD: there's a script to derive Binary
18:32:08 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Arrows
18:32:11 <allbery_b> there
18:32:25 <malsyned> hyrax42: thanks
18:32:26 <allbery_b> that may not be the explanation though, there's an arrow trutorial somewhere in there
18:32:29 <malsyned> er, allbery_b
18:32:30 <hyrax42> not sure if that would help
18:32:36 <syntaxfree> "It can read markdown and (subsets of) reStructuredText, HTML, and LaTeX, and it can write markdown, reStructuredText, HTML, LaTeX, RTF, DocBook XML, and S5 HTML slide shows. "
18:32:39 <Procyon_> TomMD:  You cannot do that in standard C without a pack and endian concerns.  Your send function might be taking care of that for you, but that's not a language feature.
18:32:47 <xpika> sorear: forkIO (thread1 >> thread2) wont work because forkIO Inferred type: IO and not IO ThreadId
18:32:53 * allbery_b looks for the tutorial, he found it off of there somehow
18:32:56 <syntaxfree> man, I was doing a Markdown parser. Then comes along someone and does that.
18:32:57 <xpika> so i guess ill have to go with mvars
18:33:32 <TomMD> Procyon_: Yes, so I over simplified the C case, but my questions still stands.  I've seen the 'binary' but I am not sure how that converts... anything.
18:34:00 <TomMD> For example: x :: [Bool] ; y = serialize x ; y = ?
18:34:10 <allbery_b> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
18:34:30 * sorear > dinner
18:34:38 * allbery_b wonders what he typoed
18:34:58 <Procyon_> TomMD:  I don't know the answer (I'm a noob in Haskell) but I do know that a packing, endian fixing struct send is by no means a trivial operation in C, as I've written it a few times ;)
18:35:06 <malsyned> allbery_b: great, thanks!
18:35:07 <allbery_b> oh, I didn't; LB is just being coy
18:35:25 <mbishop> lambdabot: botsnack
18:35:36 <mbishop> @botsnack
18:35:37 <lambdabot> :)
18:35:42 <mbishop> silly bot
18:37:42 <allbery_b> arrows are actually a lot easier to figure out than monads; there are n mysterious Laws derived from even more mysterious forms of abstract advanced maths
18:37:54 <allbery_b> s/ n / no /
18:39:32 <TomMD> [x | x <- laws (monads), isMysterious x == False] == [ ]
18:39:53 <TomMD> Yep, Haskell is much more concise than English.
18:40:19 <mauke> filter (not . isMysterious) (laws monads)
18:40:47 <siti> I think law should be written in haskell not english
18:41:02 <TomMD> Serve those lawyers right!
18:41:08 <allbery_b> you don;'t want te law to be a formal system
18:41:21 <siti> yes you do ;)
18:41:35 <sjanssen> instance Monad Jury
18:41:46 <siti> heh
18:41:59 <sjanssen> the randomized Jury monad will allow for flexibility in the law
18:42:03 <siti> hah
18:42:04 <siti> :D
18:42:32 <araujo> http://www.dangermouse.net/esoteric/piet.html
18:42:33 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
18:43:11 <Procyon_> guilty = foldr and true juryVote
18:43:15 <mauke> oh yeah
18:43:55 <mauke> @. djinn type foldr (&&) True
18:43:57 <lambdabot> f _ = False
18:46:13 <TomMD> > putWord8 0
18:46:15 <lambdabot>   Not in scope: `putWord8'
18:46:18 <malsyned> what's djinn?
18:46:40 <mauke> @help djinn
18:46:41 <lambdabot> djinn <type>.
18:46:41 <lambdabot> Generates Haskell code from a type.
18:46:41 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:47:39 <Procyon_> @src and
18:47:40 <lambdabot> and   =  foldr (&&) True
18:47:42 <malsyned> that's crazy!
18:48:23 <allbery_b> as you saw, djinn often takes the lazy way out :)
18:48:49 <Procyon_> @. djinn [a]->a
18:48:50 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "[a]->a"
18:49:22 <Procyon_> :(
18:49:39 <Procyon_> @djinn [a]-> a
18:49:40 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:49:40 <lambdabot> -- f cannot be realized.
18:49:40 <lambdabot> f a b c = a (\ d -> b d c)
18:50:06 <Cale> basically, don't try using recursive types
18:50:13 <Cale> it doesn't do a great job with them
18:50:35 <mauke> @. pl djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:50:36 <lambdabot> f = (. flip) . (.)
18:51:04 <araujo> @type liftIO
18:51:06 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
18:51:50 <Procyon_> @djinn a->a
18:51:51 <lambdabot> f a = a
18:52:23 <Procyon_> @djinn a->[a]->[a]
18:52:24 <lambdabot> f _ a = a
18:52:33 <Procyon_> lol
18:53:17 <TomMD> @dijinn a -> b -> c -> d
18:53:18 <lambdabot> -- f cannot be realized.
18:53:22 <mauke> djinn doesn't understand lists
18:53:22 <TomMD> Ahh, I see.
18:53:35 <TomMD> Neither does Tom, but he lives ;)
18:53:42 <Procyon_> hehe
18:54:03 <Procyon_> and just for fun:
18:54:15 <Procyon_> @djinn (a->a)->a
18:54:16 <lambdabot> -- f cannot be realized.
18:54:35 <mauke> @djinn a->(a->a)->a
18:54:35 <lambdabot> f a b = b a
18:54:58 <TomMD> @djinn a->(a->b)->b
18:54:58 <lambdabot> f a b = b a
18:55:01 <mauke> a.k.a. flip id
18:55:23 <TomMD> @djinn a->(b->a)->a
18:55:24 <lambdabot> f a _ = a
18:55:31 <Procyon_> @djinn (a->b->c)->(a->b)->a->c
18:55:32 <lambdabot> f a b c = a c (b c)
18:55:42 <Procyon_> wow!  It got the S combinator
18:55:47 <mauke> @. pl djinn (a->b->c)->(a->b)->a->c
18:55:47 <lambdabot> f = ap
18:56:49 <xpika> join irssi
18:57:27 <mauke> irssi :: IRC (IRC client)
18:57:43 <xpika> s/join///join
18:57:56 <mauke> s!join!/join!
18:58:06 <allbery_b> mmm, leaning toothpicks
19:01:10 <bobwhoops> I have a recursive function with two arguments, say m and n. When the function calls itself m might change but n always stays the same. I need the function to use sqrt n, yet it seems that haskell recalculates the sqrt each time the function is called, even though n doesn't change. Is there a way around this?
19:01:45 <magic_user> nice
19:01:51 <xpika> i dont think sqrt is not recalculated
19:02:07 <magic_user> ever hear of lazy evaluation
19:02:09 <malsyned> bobwhoops: can you paste an example?
19:02:56 <klein> why not have the function take sqrt n as its argument?
19:04:46 <bobwhoops> klein: I could, but that's ugly :)
19:04:46 <xpika> @where+ CAF http://www.haskell.org/hawiki/ConstantApplicativeForm?action=show&redirect=CAF
19:04:46 <bobwhoops> malsyned: hm, give me a minute or two to come up with a minimal example
19:04:46 <xpika> @where CAF
19:04:46 <malsyned> I'd say something like f m n = let sn = sqrt n in f' m where f' m = ...some expression that recurses on f'...
19:04:47 <lambdabot> Done.
19:04:47 <lambdabot> http://www.haskell.org/hawiki/ConstantApplicativeForm?action=show&redirect=CAF
19:05:29 <klein> yep, i was thinking along the lines of malsyned's solution
19:05:53 <Pseudonym> Incidentally, even this:
19:06:15 <Pseudonym> f m n = f' m  where { f' m = ... sqrt n ... }
19:06:22 <bobwhoops> Could someone explain why haskell keeps on computing it? I would have thought it would just do it once
19:06:26 <Pseudonym> will only compute sqrt n once if optimisation is turned on.
19:06:30 <Procyon_> Is there a way to explicitly memoize though?
19:06:53 <Pseudonym> The key thing here is that if n is a parameter, you can't assume that sqrt n is constant.
19:07:05 <malsyned> bobwhoops: because without the clever optimization Pseudonym describes, the compiler won't figure out that n is invariant through all recursive calls.
19:07:17 <Pseudonym> Hmmm.
19:07:22 <bobwhoops> ah
19:07:41 <Pseudonym> And it depends on having optimisation turned on.
19:07:49 <malsyned> bobwhoops: how do you know it keeps recalculating it?  unsafe IO?
19:08:13 <malsyned> I'm honestly just assuming you're right and inventing an explanation for it.
19:08:22 <Pseudonym> With optimisation off, he's right>
19:08:43 <bobwhoops> malsyned: if I redefine the function and replace "sqrt n" with the actual value, the run time really decreases
19:08:54 <malsyned> ah.  makes sense.
19:08:59 <Pseudonym> It may be, though, that GHC even does the transformation that I mentioned, given the worker-wrapper transformation.
19:08:59 <allbery_b> there's no canned memoization trick in ghc, no
19:09:15 <xpika> @where CAF
19:09:16 <lambdabot> http://www.haskell.org/hawiki/ConstantApplicativeForm?action=show&redirect=CAF
19:09:16 <Pseudonym> At high levels of optimisation, anyway.
19:09:37 <Procyon_> you could wrap said function in a state monad I suppose.
19:10:19 <malsyned> an argument can be made that the closure-style version I wrote is clearer, too.  It's a flag to the reader that n is only used once, in addition to being a flag to the compiler.
19:10:37 <allbery_b> for this it doesn't seem worth it, just rephrase it so ghc knows it doesn't need to be recalculated
19:11:42 <Procyon_> or refactor you equation to work with the square of the answer if possible so that you need never call sqrt except to get the final answer.
19:11:47 <Pseudonym> That's not entirely true, BTW.  There's a quirk of the STG machine that means that it could be slightly more efficient.
19:11:53 <Pseudonym> To do the transformation.
19:11:58 <Pseudonym> Only slightly, though.
19:12:01 <newsham> ?bot
19:12:02 <lambdabot> :)
19:12:24 <newsham> ?b52s
19:12:25 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
19:12:40 <Pseudonym> But let's not go into that.
19:18:58 <sjanssen> why oh why must Control.Parallel.Strategies be so tricky?
19:22:50 <syntaxfree> http://neilbartlett.name/blog/?p=13
19:22:52 <lambdabot> Title: Neil&#8217;s point-free blog » More on Haskell, Side Effects and Code Reuse
19:22:59 <syntaxfree> of course, I'm arrogant in my blog, but this guy takes the cake.
19:23:10 <syntaxfree> he claims Erik Meijer "misunderstood Haskell".
19:26:09 <malsyned> well, in fairness, he recanted.
19:34:00 <sorear> jhc is still runnign!
19:34:32 * SamB wonders how long until he grows into his "ZSNES Developer" title
19:34:38 <sorear> 12735 stefan    25   0  475m 339m 5444 R 95.1 89.8  23:32.45 jhc
19:35:37 <sorear> at least it isn't thrashing this time :)
19:37:29 <sorear> vm++
19:37:37 <sorear> @karma
19:37:38 <lambdabot> You have a karma of 22
19:37:41 <sorear> @users
19:37:41 <lambdabot> Maximum users seen in #haskell: 322, currently: 282 (87.6%), active: 40 (14.2%)
19:37:45 <sorear> @seen
19:37:52 <SamB> @karma-all
19:37:53 <lambdabot>  "dons"                118
19:37:53 <lambdabot>  "audreyt"              73
19:37:53 <lambdabot>  "fglock"               50
19:37:53 <lambdabot>  "glguy"                47
19:37:53 <lambdabot>  "lambdabot"            42
19:37:55 <lambdabot> [681 @more lines]
19:38:19 <sorear> once yi+syntax is working, I've been promised karma=98
19:38:22 <uccus> anyone has time for yet another stupid question? I can do things will tuples but one thing bothers me, is there any Haskell implementation that does not restrict the arity of tuples? won't complain if I try to construct a 258 positions tuple?
19:38:28 <siti> woah well done dons you have the most karma :D
19:38:50 <sorear> uccus: not iirc.  it sucks.
19:39:04 <sorear> uccus: use strict tail heterogenous lists
19:39:16 <sorear> data HNil = HNil ; data HCons a b = HCons a !b
19:39:18 <uccus> what does Haskell98 report say about this?
19:39:42 * sorear checks
19:41:30 <sorear> There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
19:41:44 <sorear> section 6.1.4
19:42:02 <uccus> yes hlists solve the problem but erm... it's a type level list, isn't it? in that line, I tried data (&) a b = (&) a b, but I can't implement a sensible Show
19:42:07 <uccus> any thought?
19:42:12 <malsyned> ghc 6.4 only defines derives Show on instances up to 5-tuples or so, in my experience.
19:42:17 <Pseudonym> ?where HList
19:42:17 <lambdabot> http://homepages.cwi.nl/~ralf/HList
19:42:21 <Pseudonym> uccus: Look at that.
19:42:26 <uccus> I did
19:42:29 <sorear> http://haskell.org/onlinereport/basic.html#sect6.1.4
19:42:30 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
19:42:43 <Pseudonym> Ah, you want a Show.
19:42:47 <uccus> I just want a trick to implement Show (&)
19:42:50 <uccus> yep! :D
19:42:50 <Pseudonym> Well, it's going to be recursive.
19:43:00 <sorear> uccus: derive Show
19:43:26 <Pseudonym> instance (Show a, Show b) => Show (a&b) where { ... }
19:43:28 <uccus> it's worse than that... derive Show gives me something like 4 & (5 & 'a')
19:43:42 <sorear> you call that bad? :p
19:43:51 <sorear> will write something and hpaste it
19:43:54 <uccus> I want & to be right associative and drop the parentheses
19:44:04 <skew> did you declare fixity for (&)?
19:44:10 <sorear> skew: bzzt.
19:44:21 <uccus> sorear: drop the parentheses, can we do that?
19:44:36 <sorear> skew: http://haskell.org/onlinereport/derived.html#sect10.4
19:44:37 <lambdabot> Title: The Haskell 98 Report: Derived Instances
19:44:40 <Pseudonym> Yes, if you declare a fixity for (&) it should work.
19:44:58 <uccus> it's not a trivial matter as far as I get it
19:44:59 <sorear> Pseudonym: no, it says in so many words associativity is ignored
19:45:05 <Pseudonym> Ah.
19:45:11 <Pseudonym> In that case, you can roll your own.
19:45:22 <uccus> how? :) that's what I'm asking!
19:45:26 <skew> wait a minute, & is a constructor?
19:45:31 <uccus> yep
19:45:35 <sorear> 12735 stefan    25   0  475m 327m 5508 R 98.9 86.6  30:04.77 jhc
19:45:55 <Pseudonym> instance (Show a, Show b) => Show (a&b) where
19:46:07 <sorear> uccus: I'd do a simple hack ... coming
19:46:37 <uccus> I do want a simple hack :$
19:46:49 <sorear> vm++
19:46:57 <Pseudonym>     showsPrec (a & b) = showParen (p > prec) (shows Prec prec . showString " & " . showsPrec (prec+1))
19:47:04 <Pseudonym> Where "prec" is the precedence of &
19:47:31 <Pseudonym> Oh, and & isn't a constructior, though :& is.
19:47:48 <Pseudonym> :t showParen
19:47:50 <lambdabot> Bool -> ShowS -> ShowS
19:47:54 <Pseudonym> Right, thoguht so.
19:48:01 <Pseudonym> Errr...
19:48:06 <Pseudonym> That "shows Prec" should be "showsPrec".
19:48:18 <Pseudonym> Ah, crap.
19:48:28 <Pseudonym> Hang on, let's try that again:
19:48:42 <Pseudonym>     showsPrec (a & b) = showParen (p > prec) (showsPrec (prec+1) . showString " & " . showsPrec prec)
19:48:43 <Pseudonym> That's it.
19:49:01 <uccus> sorear: while you are at it, is there any way we can show (a & (b & (c & d))) as (a, b, c, d)?
19:52:33 <hpaste>  sorear pasted "instance Show (HCons|HNil)" at http://hpaste.org/233
19:52:48 <sorear> uccus: I thought your request was a given, sorry :)
19:53:23 <uccus> yeah, ok, no worries :D
19:53:51 <uccus> so there's no way I can do this without an HNil
19:53:52 <skew> The new TMR is great. I never realized those standard axioms for classical logic are K, S, and call/cc
19:54:28 <skew> hmm, well not quite call/cc, but something close
19:54:37 <Anon4888> TMR?
19:54:50 <uccus> skew: that's the reason I got stuck with Haskell
19:54:54 <uccus> monad.reader?
19:55:17 <sorear> uccus: corerct.
19:55:40 <uccus> I am reading it right now, so... :D
19:56:21 <sorear> uccus: to see this, consider: without HNil, how does the system decide whether to use (1,(2,3)) or (1,2,3) for HCons 1 (HCons 2 3) ?
19:56:54 <uccus> associativity?
19:57:20 <uccus> (1 & 2 & 3) should always mean (1 & (2 & 3))?
19:57:35 <uccus> so ((1 & 2) & 3) is a different beast
19:58:23 <skew> yeah, but if you can have (1 & 2 & 'a') or (1 & 2 & "String") or (1 & 2 & (3,5)), why not (1 & 2 & (3 & 4))?
19:58:32 <sorear> uccus: that would mean a tuple could not be the last elemwent of a tuple.
19:58:35 <skew> hmm, actually showsPrec might sort that out
19:58:42 <sorear> which I consider unacceptibly non-modular
19:58:57 <uccus> your solution works nice with HLists, I guess that's how HList derive Show
19:59:39 <uccus> erm... I see that... :s never mind
20:00:32 <sorear> uccus: my solution is runtime suboptimal, unless (like jhc) your compiler specializes instances.  with more class oleging, you can make the instances optimal, which I imagine HList does.
20:00:51 <uccus> okay
20:00:54 <skew> oleg is a verb now?
20:01:07 <uccus> oleg is an adjective as well...
20:01:13 <skew> I have been away from this channel for far too long.
20:01:18 <uccus> as in "oh your solution is so... oleg!"
20:01:22 <pkhuong-> skew: it's even being considered for an SI unit.
20:01:29 <sorear> @quote oleg.*unit
20:01:30 <lambdabot> No quotes match. Take a stress pill and think things over.
20:01:45 <skew> I remember oleg being only a unit
20:02:18 <sjanssen> I'm an olegologist
20:03:19 <uccus> that means all my hope of getting rid of the nasty tuple restrictions end here (without resorting to verbose HLists)
20:03:27 <SamB> @quote oleg
20:03:27 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
20:03:33 <SamB> @quote oleg
20:03:34 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
20:03:37 <SamB> @quote Oleg
20:03:38 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
20:03:39 <skew> what are you trying to code anyway?
20:03:41 <SamB> @quote Oleg
20:03:42 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
20:03:44 <sjanssen> uccus: is there any particular reason you're using tuples?
20:03:46 <SamB> @quote .Oleg
20:03:47 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
20:04:03 <SamB> @quote .Oleg
20:04:04 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
20:04:07 <sorear> @quote .[oO]leg
20:04:08 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
20:04:30 <uccus> as you can imagine, no problem worth tackling uses tuples more arity more than 15. it's just a curiosity.
20:04:32 <sorear> vm++
20:04:54 <sjanssen> I'd say tuples > 5 are too big
20:05:01 <sjanssen> maybe > 3
20:05:08 <sorear> >2
20:05:25 <uccus> most probably highest bound should be 4.
20:05:34 <brainly-green> 3.7
20:05:43 <Korollary> 640k should be enough
20:06:13 <sorear> actually ALL tuples >2 should be deleted ... use lightweight HLists for everythingh.
20:06:30 <sorear> I love virtual memory, jhc has me tyyping bling
20:06:47 <sjanssen> sorear: HLists have more overhead
20:07:03 <sjanssen> storage overhead
20:07:15 <uccus> sorear: in that case, there should be no syntactic sugar and , becomes a constructor
20:07:31 <brainly-green> I understand how you perform updates on a tree structure in a functional language, but I don't understand how you perform updates of arrays and hash maps
20:08:06 <sjanssen> brainly-green: usually you make a copy of the array with that index updated
20:08:12 <sorear> brainly-green: you use uniqueness types (Clean) or ST/IO (haskell)
20:08:21 <skew> or DiffArray
20:08:25 <sorear> jhc gives me a lot of practice blind typing :)
20:08:31 <sjanssen> updating purely functional arrays is highly discouraged
20:08:53 <sorear> uccus: better yet, [] becomes a typeclass overloaded mixfix operator!!
20:09:02 <brainly-green> in constant time
20:09:05 <brainly-green> no copying
20:09:24 <sjanssen> brainly-green: DiffArray has a hack that can emulate O(1) updates
20:09:36 <sorear> brainly-green: seriously - use STArray
20:09:37 <uccus> brainly-green: frankly, this is  not the functional way of thinking, using arrays
20:09:43 <sorear> that's the only O(1) way
20:09:50 <skew> uniqueness types work too
20:09:55 <sorear> O(log n) can be achieved functionally
20:10:08 <sorear> (dense tries FTW!)
20:10:16 <skew> more interesting, O(log n) can be achieved persistently
20:10:18 <uccus> sorear: with red-black trees or something?
20:10:39 <sjanssen> any sort of balanced tree would work
20:10:44 <sorear> uccus: sense tries.
20:11:27 <sorear> dense tries are simpler, faster and more array-like (at array jobs)
20:11:45 <uccus> any paper handy?
20:11:59 <sorear> just don't ask them to pretend they are Maps
20:11:59 <uccus> I don't know what tries are
20:12:43 <sorear> uccus: no, but I'm sure it's been discovered before
20:13:19 <sorear> uccus: see the impl of Data.IntMap - similar concept.
20:13:28 <uccus> okay
20:13:28 <sjanssen> sorear: how do dense tries differ from bog standard tries?
20:13:37 <brainly-green> if the hash map or array is implemented as a tree then I get that too, but if it's implemented as a pointer to a block of data, that's where I'm unsure
20:13:59 <brainly-green> is there a simple way to explain how you can do an O(1) update with a DiffArray?
20:14:09 <SamB> brainly-green: unsafePerformIO
20:14:23 <sorear> brainly-green: if it is a block of data, pure updates are O(n).
20:14:24 <brainly-green> unsafe?
20:14:39 <SamB> all that means is that you have to prove that what you are doing is safe
20:15:00 <sorear> if you ***rewally*** nead O(1), use IO and hold your nose
20:15:16 <sjanssen> brainly-green: it updates the array in place, and then replaces all the old references to the array with a "diff" of the new array
20:15:19 <bobwhoops> How can I get haskell (in ghci, in partiuclar) to display large numbers normally and not as 4.2342343e10 ?
20:15:23 <sorear> brainly-green : it's a version control system - it stores the current version, and when you try to access onlyer versions it reconstructs them in O(n) (but you don't do that)
20:15:25 <SamB> which is a *bit* tricky without having some postulates to go by...
20:15:42 <sorear> bowwhoops: look at:
20:15:47 <skew> bobwhoops: make sure they are Integer?
20:15:53 <brainly-green> ok
20:15:56 <SamB> DiffArray uses IO and holds your nose for you
20:16:05 <SamB> but it also uses MVars and apparantly that is slow
20:16:43 <sjanssen> you know, one could actually write an IArray instance that uses IntMap
20:17:10 <sorear> @docs Numeric
20:17:11 <sorear> if it's in haskell, it's in Numeric
20:17:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
20:17:16 <allbery_b> bobwhoops: you could also use Text.Printf
20:18:16 <sorear> sjanssen: that is what I was suggesting with my dens-e-treees stuff .. IntMap is only slightly worse
20:20:01 <sjanssen> sorear: do you have a reference for dense tries?  I've never heard of them, and Google isn't helping
20:20:52 <skew> sorear: have you read the paper referenced in the IntMap docs?
20:21:48 <sorear> long ago
20:22:01 <uccus> aha
20:22:07 <sorear> I have a way of reinventing things with my own terminology :)
20:22:35 <sorear> just use IntMap, someday I'll implement and benchmark dense tries
20:23:19 <uccus> sorear: I've found a solution to the non-modularity of my (:&) constructor... if you want a tuple to be the last element, use Id... (1 :& (2 :& Id (3 :& 4))
20:23:27 <sorear> then I'll post 'em to the list , and JHughes et al will go "you idiot, that's an order-2 frobnoctz tree - how could you not know?"
20:23:56 <uccus> umm... okay I see the lameness :s
20:24:16 <sjanssen> I'm going to start claiming that Data.Array updates are O(1)
20:24:27 <sjanssen> because the size is bounded by the range of Int ;)
20:25:00 <sorear> sjanssen: (Int,Int) is strictly bigger than Int and inhabits Ix
20:25:02 <sorear> oh wait
20:25:05 <sorear> @src Ix
20:25:06 <lambdabot> class (Ord a) => Ix a where
20:25:06 <lambdabot>     range           :: (a,a) -> [a]
20:25:06 <lambdabot>     index           :: (a,a) -> a -> Int
20:25:06 <lambdabot>     inRange         :: (a,a) -> a -> Bool
20:25:06 <lambdabot>     rangeSize       :: (a,a) -> Int
20:25:13 <sorear> ah. :)
20:25:32 <SamB> > array (0,maxBound::Int) [] ! (maxBound::Int)
20:25:33 <lambdabot>  Add a type signature
20:25:41 <SamB> > array (0,maxBound::Int) [] ! (maxBound::Int) :: ()
20:25:43 <lambdabot> Terminated
20:25:49 <SamB> hmm.
20:25:50 <sorear> > array (0:maxBound::Int) [(3,'x')]
20:25:50 <lambdabot>  Couldn't match `Int' against `[a]'
20:25:59 <sorear> > array (0,maxBound::Int) [(3,'x')]
20:26:01 <lambdabot> Terminated
20:26:04 <sorear> > array (0,maxBound::Int) [(2,'x')]
20:26:06 <lambdabot> Terminated
20:26:09 <sorear> > array (0,maxBound::Int) [(3,'x')]
20:26:11 <lambdabot> Terminated
20:26:15 <sorear> > array (0,maxBound::Int) [(4,'x')]
20:26:16 <SamB> does that mean SIGSEGV or what?
20:26:17 <lambdabot> Terminated
20:26:21 <sorear> SamB: yes!
20:26:24 <sorear> > array (0,maxBound::Int) [(5,'x')]
20:26:26 <lambdabot> Terminated
20:26:29 <sorear> > array (0,maxBound::Int) [(2,'x')]
20:26:31 <lambdabot> Terminated
20:26:40 <sorear> the magic number is different every day...
20:26:47 <sorear> > array (minBound,maxBound::Int) [(0,'x')]
20:26:49 <lambdabot> Terminated
20:26:53 <sorear> > array (minBound,maxBound::Int) [(-2,'x')]
20:26:55 <lambdabot> Terminated
20:26:57 <sorear> > array (minBound,maxBound::Int) [(2,'x')]
20:26:59 <lambdabot> Terminated
20:27:02 <sorear> > array (minBound,maxBound::Int) [(1,'x')]
20:27:04 <lambdabot> Terminated
20:27:09 <sorear> hmm. funny.
20:27:14 <sorear> > array (minBound,maxBound::Int) [(15,'x')]
20:27:16 <SamB> Prelude Data.Array> array (minBound,maxBound::Int) [(0,'x')]
20:27:16 <SamB> array (-2147483648,2147483647) [(-2147483648,'x'),(-2147483647,<interactive>: internal error: EVACUATED object entered!
20:27:16 <lambdabot> Terminated
20:27:56 <sorear> Jhc is almost done compiling base
20:28:35 <sjanssen> the array libs need some work
20:29:12 <sjanssen> this bug could be fixed.  The evil Ix bug too
20:30:31 <bobwhoops> I was here earlier about the how haskell keeps on calculating sqrt n when n doesn't change in one of my functions. I tried rewriting it like someone suggested it, but it still doesn't work. See: http://pastebin.ca/335165 . Can someone see what I did wrong? I realize that the actual function isn't very good haskell and it's a terrible way to calculate primes, but I'm more interested in the sqrt n thing than that, now
20:30:35 <sorear> sjanssen: and I will keep crashing the bot until someone with bureaucratic credits (Igloo?) notices.
20:31:02 <sorear> bobwhoops: use hpaste!
20:31:04 <sorear> @paste
20:31:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:31:24 <sjanssen> sorear: I'm sure the community would accept a fix, someone just needs to write it
20:31:43 <sorear> bobwhoops: one sec
20:33:04 <sorear> bobwhoops: updated.  (and use hpaste next time so I don't have to announce manually :))
20:33:15 <mbishop> @seen kowey
20:33:16 <lambdabot> I saw kowey leaving #haskell and #darcs 7h 21m 1s ago, and .
20:33:22 <bobwhoops> http://hpaste.org/234
20:33:37 <sorear> gah, why didn't it announc!?
20:34:10 <sorear> glguy: is Announce still the default?
20:34:25 <bobwhoops> I wasn't sure what it was, so I unchecked it. Oops
20:34:51 <sorear> we assumed people would be lazy and leave it checked unless they knew what it was :)
20:35:15 <sorear> anyway it's a community pastebin, so we welcome all bad feedback
20:35:23 <sorear> it must become perfect
20:35:32 <sjanssen> good feedback is not allowed
20:36:19 <sorear> :t ceil
20:36:21 <lambdabot> Not in scope: `ceil'
20:36:25 <sorear> :t ceiling
20:36:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:36:33 <bd_> bobwhoops: Have you compiled with -O?
20:36:47 <bd_> bobwhoops: ghci does very little optimization
20:36:52 <bobwhoops> bd_: no
20:37:00 <hpaste>  sorear annotated "(no title)" with "properly CSE sqrt, also use integers" at http://hpaste.org/234#a1
20:37:01 <bd_> ah, well :)
20:37:32 <bobwhoops> yeah, I haven't figured out the type thing quite yet
20:37:42 <skew> As a rule GHC purposely avoids floating things like that in or out, because it can change space usage
20:38:14 <sorear> bobwhoops: be wary of numeric types - there is a DWIMmy feature called "defaulting" which confuses many a newbie
20:38:25 <sorear> it only affect numbers however
20:38:34 <chessguy> 'evening haskellers
20:38:44 <bd_> skew: hm, even when it can establish a bound on the space usage (as in the case of a Double for example...)
20:38:48 <sorear> evening chessguy
20:39:00 <skew> like, if you have "main = print [map (c:) (map show [1..1000000000]) | c <-
20:39:04 <skew> "hi"]
20:39:04 <allbery_b> hm, for now?  I'm imagining t being used for String and ByteString
20:39:05 <sorear> bd_: Double can use arbitrary amounts of space!
20:39:16 <chessguy> i guess everyone on -cafe thought my thread about recursion was either really obvious or really obscure
20:39:35 <sorear> i'm for obvious
20:39:35 <skew> it would be bad to share [1..1000000000] rather than recompute it
20:39:38 <bd_> sorear: it can? I thought it was fixed storage size floating point, as CDouble and CFloat?
20:39:51 <chessguy> sorear, i figured you would be
20:39:52 <sorear> bd_: CDouble is infinite size too!
20:40:15 <bobwhoops> sorear: ok, your version runs pretty fast
20:40:18 <sorear> bd_: data Double = D# Double# | Thunk arbitrary_code -- expository only
20:40:26 <sorear> bobwhoops: eh? how much faster?
20:40:33 <skew> there's no guarantee a value the claims to have type Double isn't actually an infinite loop
20:40:42 <bd_> sorear: ah, point, but if it's going to be evaluated once, then it's still safe
20:40:48 <chessguy> sorear, but you gotta admit, it's not something we teach newbies about
20:40:56 <bd_> sorear: since, it'll take up no additional space until it is evaluated
20:41:00 <bd_> and after that the space is fixed
20:41:09 <chessguy> other than "here's map and foldr, and the other stuff is the same kind of thing"
20:41:10 <skew> and even if it would evaluate down eventually, it might take a whole bunch of extra space in the middle
20:41:12 <sorear> bd_: yes, strictness and inlining will turn most Double into Double#, which *is* fixed size
20:41:21 <bobwhoops> sorear: In about 6 seconds, actually
20:41:23 <bd_> eg, f (doubleExpr) (doubleExpr) -> let x = doubleExpr in f x x
20:41:40 <bd_> if f does not evaluate doubleExpr, it would've had both thunks anyway
20:41:52 <sorear> bobwhoops: we can make it much faster ... but let's not go there
20:42:00 <skew> say, let x = sum (reverse ([1 / fromInteger n | n <- [1..1000000]))
20:42:02 <bd_> if f does evaluate doubleExpr, twice, then this is valid, since we can put a (even smaller!) space bound on it anyway
20:42:40 <bd_> if it turns out doubleExpr is bottom, then there is no change to program behavior, since it would hit bottom anyway if the expression is duplicated
20:43:03 <bd_> and even if doubleexpr chews up gobs of ram, it would've done so at some point anyway, and here since we only do it once, it's an optimization
20:43:05 <skew> yeah, right
20:43:09 * sorear sped up nornagon 's mandelbrot by 3700% two days ago with simple tuning
20:43:22 <skew> you should be able to CSE it out if you know the evaluated form is tiny enough you don't mind hanging on to it
20:43:23 <nornagon> oh
20:43:41 <bd_> skew: certainly newtypes of primitives should be considered small enough...
20:43:46 <nornagon> way to catch my attention without triggering my hilighting thingumy
20:43:46 <Elifant> I got '*** Exception: stack overflow' when running my haskell program, how can I get details?
20:43:48 <skew> but besides that I don't think GHC actually knows much of anything about the size of values
20:43:54 <bd_> or well fixed-sized primitives
20:43:59 <skew> I guess it has to know a bit to sometimes overwrite thunks
20:44:57 <glguy> aww, chessguy referred to me as "a much more experienced haskeller" :-p
20:45:17 <chessguy> glguy, relatively so :)
20:46:35 <sorear> Elifant: there's a bug in your program, usually misuse of fold[lr].  would you mind @paste-ing the offending function?
20:46:39 <sorear> @paste
20:46:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:47:01 <glguy> so this hpaste feature for "save to tarball" many people would want this or only that specific person that mentioned it on the mailing list?
20:47:47 <chessguy> i doubt if it would be much use to anyone but him
20:47:48 <sorear> not I
20:47:50 <Elifant> sorear: I'll try to shrink it to minimal size... but there's no way to get backtrace or something like?
20:48:12 <sorear> Elifant: heh. like that'd actually exist. :( :(
20:49:02 <allbery_b> elifant: backtraces in haskell are somewhat less than intuitive, due to lazy evaluation
20:49:11 <sorear> yay, my CPU temp alarm just went off!
20:49:31 <glguy> You must be putting it to good use
20:49:43 <sorear> glguy: compiling 'base' with jhc
20:58:21 <sjanssen> @paste
20:58:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:59:11 <hpaste>  sjanssen pasted "segfaulting :(" at http://hpaste.org/235
20:59:36 <sjanssen> I'd appreciate it if somebody with GHC 6.6 and zlib would try out that program
20:59:52 <chessguy> sjanssen, i can try it
21:00:59 <sorear> I have 1 core :(
21:01:17 <sorear> I wonder if jhc is parallel yet
21:01:23 <sjanssen> sorear: I'd like to know what this program does on one core
21:01:30 <chessguy> hmm, i think i need to uninstall fps or something
21:01:34 <DannoHung> Excuse me Haskellers, and may I first say that this may not be a coherent question to most of you, but does Richard Smullyan's book "To Mock a Mockingbird" contain an explanation of Monads?  I seem to recall someone having recommended it for that purpose for some completely inexplicable reason...
21:01:45 <sjanssen> chessguy: you have fps installed with ghc 6.6?
21:01:54 <sorear> DannoHung: no
21:02:09 <chessguy> yeah, i had it installed separately, and then upgraded to 6.6
21:02:11 <sorear> it's all CL I believe
21:02:35 <DannoHung> sorear: Thank you, regardless, the book is really good, so not a big loss.
21:02:53 <skew> how much have you read? Does it mention continuations?
21:02:58 <chessguy> what's the usual way to uninstall a package?
21:03:07 <sorear> chessguy: in cabal?  no way at all!
21:03:10 <allbery_b> ghc-pkg unregister, then delete manually
21:03:24 <sorear> chessguy: for this reason I use register only, never install.
21:03:30 <allbery_b> luckily, most packages sem to install their files in separate trees, so you can just delete those trees
21:04:11 <sorear> any Cabal maintainers here? if I implemented uninstall, would it be taken? I seem to recall there was a "reason" uninstall would never be supported.
21:04:15 <chessguy> allbery_b's command worked
21:05:09 <allbery_b> "because it's risky and unsafe" IIRC
21:05:30 <chessguy> sjanssen, what should i be doing with this?
21:05:31 <DannoHung> skew: Not as such yet, not that I was able to recognize anyway
21:06:00 <allbery_b> personally I think it should try to enforce the common convention that a package installs into its own independent tree under --prefix, which should make it reasonably safe to remove
21:06:05 <skew> well, then it probably has nothing to do with the book, but I liked http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
21:06:08 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
21:06:43 <DannoHung> skew: Thanks, I think I saw a link to that before but I got kinda lost
21:06:57 <DannoHung> I've been having a rough time gr0king them
21:09:08 <chessguy> sjanssen,  ?
21:09:08 <glguy> Monads are just he dryads of the mountainous regions, right?
21:09:29 <DannoHung> What's their animal form?
21:09:44 <DannoHung> And do they get the Forestwalk skill for free?
21:09:45 <chessguy> camels? :)
21:09:46 <glguy> Either space men
21:09:48 <glguy> or monsters
21:09:56 <glguy> or containers, I can't remember now
21:10:20 <allbery_b> spacesuits in the ocean...
21:10:49 <bd_> @quote radioactive
21:10:50 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
21:10:52 <bd_> hmm
21:11:08 <bd_> @quote space
21:11:08 <lambdabot> bd_ says: If a graph is reduced in a forest, and no one is around to pattern match the resulting WHNF, does it cause a space leak?
21:11:15 <bd_> bah, evil randomizer
21:11:23 <sorear> DannoHung: (1) don't try to grok "monads".  they are an abstration.  grok "IO", grok "Maybe", grok "State", observe the correlation.
21:11:33 <sorear> (2) I forgot
21:11:55 <allbery_b> @quote spacesuit
21:11:56 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
21:11:56 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
21:12:01 <Elifant> DannoHung: here is very simple description of monad: http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
21:12:04 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
21:12:31 <Elifant> it's just a way to combine functions which returns some 'fancy types'
21:15:02 <chessguy> what's a .hi file?
21:15:12 <dibblego> it's just saying hi
21:15:13 <sorear> haskell interface
21:15:20 <sorear> it's like a .h file in C
21:15:28 <sorear> except automatically generated
21:15:28 <chessguy> but it's not text
21:15:29 <skew> you might as well think of it as part of the .o file
21:15:44 <sorear> machine readable .o
21:15:45 <allbery_b> you can also think of it as a way of adding "hooks" to a value.  you can use those hooks to copy values around (State) or modify a calculation based on the passed-in value (Maybe)
21:16:01 <glguy> like callbacks?
21:16:06 <skew> it's some extra information GHC uses when compiling stuff that uses the other module
21:16:27 * allbery_b talking about monads, not .hi files
21:17:49 <chessguy> @tell sjanssen i built and ran your broken.hs on my AMD Turion 64-bit processor. it seemed to build successfully, but when I run, it does nothing. no error, no output, just terminates. hope that helps
21:17:50 <lambdabot> Consider it noted.
21:18:17 <glguy> allbery_b: I'm just being difficult
21:19:26 <chessguy> anyway, getting back to my recursion topic: i wonder if it would be good to make up a kind of cheat-sheet table, with columns like "function name", "type signature", "simple english description", "indications you should use this function"
21:19:54 * allbery_b thinks that would go well with the "Haskell Cookbook" being discussed
21:23:45 <chessguy> how many functions are there that specifically abstract recursion patterns?
21:24:22 <dibblego> you mean the folds?
21:24:57 <glguy> infinitely many
21:25:09 <newsham> iterate, replicate, enumFromTo, foldl, scanl, map, ... ?
21:25:10 <allbery_b> rephrase that to "standard functions"
21:25:12 <chessguy> glguy, i mean commonly-used
21:25:32 <newsham> pretty much anything that loops, since primitive recursion is the looping mechanism
21:25:34 <sorear> just folds? or all HOFs?
21:25:35 <allbery_b> i.e. anything in GHC's base
21:25:42 <glguy> chessguy: I'm in a difficult mood tonight, you'll have to be more specific next time :-D
21:25:53 <sorear> foldr either maybe ...
21:25:53 <chessguy> @slap glguy
21:25:54 * lambdabot smacks glguy about with a large trout
21:26:10 <chessguy> @type either
21:26:12 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
21:26:13 <glguy> that's going on your permanent record!
21:26:21 <chessguy> ?src either
21:26:22 <lambdabot> either f _ (Left x)     =  f x
21:26:22 <lambdabot> either _ g (Right y)    =  g y
21:26:26 <chessguy> that's not recursion
21:26:44 <allbery_b> the foldr is though
21:26:47 <sorear> it may not be recursing, but I still say it's a fold.
21:26:50 <Elifant> event (+) is recursion: '0 + b = b; a + b = prev a + succ b' :)
21:26:58 <newsham> does something like "gcd" (which uses recursion) count?
21:27:07 <Elifant> s/event/even/
21:27:08 <newsham> it doesnt really allow you to create your own loops, but it has its own
21:27:19 <sorear> I think all chessguy wants is partial HOFs :)
21:27:38 <chessguy> i'm talking about functions that abstract patterns of recursions
21:27:38 <newsham> but not all partial HOFs recurse
21:27:54 <chessguy> what's the difference between a HOF and a partial HOF?
21:28:10 <sorear> a partial HOF is partial!
21:28:11 <newsham> chess: does enumFromTo count?
21:28:20 <chessguy> ?srs enFromTo
21:28:21 <lambdabot> Source not found. That's something I cannot allow to happen.
21:28:24 <chessguy> ?srs enumFromTo
21:28:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:28:28 * chessguy sighs
21:28:32 <sorear> partial is a property of functions
21:28:35 <chessguy> ?src enumFromTo
21:28:35 <newsham> > enumFromTo 'a' 'e'
21:28:35 <lambdabot> Source not found. That's something I cannot allow to happen.
21:28:36 <lambdabot>  "abcde"
21:28:37 <sorear> chessguy: it's a class method.
21:28:46 <sorear> @src Bool enumFromTo
21:28:47 <lambdabot> Source not found. Take a stress pill and think things over.
21:28:49 <allbery_b> ?src Int enumFromTo
21:28:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:28:50 <sorear> @src Bool pred
21:28:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:28:54 <allbery_b> hm
21:28:56 <sorear> @src Bool fromEnum
21:28:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:28:59 <allbery_b> ?src Char enumFromTo
21:29:00 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:29:00 <sorear> sign.
21:29:07 <sorear> @src cheeky-off
21:29:07 <allbery_b> must not have been entered
21:29:08 <lambdabot> Source not found. You type like i drive.
21:29:16 <chessguy> ?hoogle enumFromTo
21:29:17 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
21:29:18 <lambdabot> Language.Haskell.Syntax.HsEnumFromTo :: HsExp -> HsExp -> HsExp
21:29:29 <newsham> enumFromTo x y   =  map toEnum [fromEnum x .. fromEnum y]
21:29:31 <chessguy> isn't .. just sugar for enumFromTo?
21:29:36 <sorear> chessguy: yes
21:29:49 <Pseudonym> Or enumFrom
21:29:56 <Pseudonym> Or... there are a few.
21:29:58 <sorear> or enumFromThen
21:30:03 <Pseudonym> Yeah.
21:30:04 <sorear> > [1,3..]
21:30:06 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
21:30:13 <hyrax42> or enumFromThenTo
21:30:14 <Pseudonym> ?hoogle (Enum a) => a -> a -> a -> [a]
21:30:15 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
21:30:16 <chessguy> sorear, you still haven't defined partial
21:30:18 <hyrax42> just to continue the pedantry
21:30:24 <Pseudonym> ?hoogle (Enum a) => a -> a -> [a]
21:30:26 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
21:30:26 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
21:30:30 <allbery_b> partial = not defined for all possible inputs
21:30:30 <Pseudonym> ?hoogle (Enum a) => a -> [a]
21:30:31 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
21:30:32 <lambdabot> Prelude.repeat :: a -> [a]
21:30:32 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:30:36 <sorear> chessguy: a partial function makes _|_ from not _|_
21:30:38 <hyrax42> chessguy: partial usually means not defiend for all iputs
21:30:40 <allbery_b> the canonical example is head
21:30:49 <allbery_b> (which is undefined for empty lists)
21:30:59 <hyrax42> sqrt is another
21:31:10 <hyrax42> > sqrt -1
21:31:11 <lambdabot>   add an instance declaration for (Num (a -> a))
21:31:14 <nornagon> sqrt -1 should be 0 :+ 1 :<
21:31:20 <allbery_b> > sqrt (-1)
21:31:21 <lambdabot>  NaN
21:31:28 <sorear> foldr is (debatably) partail since
21:31:29 <hyrax42> but
21:31:31 <hyrax42> ?type sqrt
21:31:33 <lambdabot> forall a. (Floating a) => a -> a
21:31:33 <sorear> > foldr (+) 0 [0..]
21:31:35 <lambdabot>  Exception: stack overflow
21:31:36 <allbery_b> strictly speaking I don't think that's undefined
21:31:41 <hyrax42> ?instances Floating
21:31:43 <lambdabot> Double, Float
21:31:50 <mauke> > sqrt ((-1) :+ 0)
21:31:51 <lambdabot>  0.0 :+ 1.0
21:31:53 <chessguy> but, e.g., map would not be partial?
21:31:55 <sorear> > cycle "NaN! "
21:31:55 <newsham> until, map, filter, foldl (foldl1), scanl (scanl1), foldr (foldr1), iterate, repeat, replicate, cycle, take? drop?, takeWhile? dropWhile? scan?
21:31:56 <lambdabot>  "NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! NaN! ...
21:32:02 <sorear> chessguy: correct.
21:32:08 <newsham> any? all?
21:32:09 <allbery_b> ?instances-importing Data.Complex Floating
21:32:11 <lambdabot> Complex a, Double, Float
21:32:15 <sorear> newsham
21:32:21 <sorear> > any (repeat False)
21:32:23 <lambdabot>      Expecting a function type, but found `[a]'
21:32:23 <lambdabot>       Expected type: a -> Boo...
21:32:23 <hyrax42> allbery_b: ah I was not aware of that
21:32:28 <nornagon> > let 1/0 = "Nullity!" in 1/0
21:32:30 <lambdabot>  "Nullity!"
21:32:35 <nornagon> :O
21:32:43 <chessguy> newsham, elelm
21:32:45 <chessguy> elem
21:32:46 <newsham> > any (== True) (repeat False)
21:32:48 <lambdabot>  Exception: <<loop>>
21:32:53 <sorear> of course, some say infinite lists have no NF, and so foldr is impartial.  I cannot comment.
21:33:03 <sorear> newsham: (== True) == id
21:33:08 <allbery_b> map is not itself partial; it does something sensible for all well-typed inputs.  (the thing you're mapping may be partial, though)
21:33:16 <newsham> ?type (== True)
21:33:18 <lambdabot> Bool -> Bool
21:33:18 <newsham> ?type id
21:33:20 <lambdabot> forall a. a -> a
21:33:28 <mauke> > or (repeat False)
21:33:29 <lambdabot>  Exception: <<loop>>
21:34:00 <chessguy> well, i'm not sure what partiality has to do with the current discussion then
21:34:13 <hyrax42> > and (cycle [False ..])
21:34:14 <lambdabot>  False
21:34:24 <newsham> > scanl (:) "" "sigh"
21:34:25 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:34:26 <lambdabot>       Expected...
21:34:40 <sorear> hyrax42: cycle [False..] = [False, True, False, True, ...]
21:34:47 <hyrax42> sorear: I know
21:34:56 <newsham> > scanr (:) "" "sigh"
21:34:57 <lambdabot>  ["sigh","igh","gh","h",""]
21:35:10 <nornagon> woah.
21:35:15 <sorear> > inits "sigh"
21:35:16 <newsham> > scanl (flip (:)) "" "sigh"
21:35:16 <lambdabot>  ["","s","si","sig","sigh"]
21:35:18 <lambdabot>  ["","s","is","gis","hgis"]
21:35:21 <nornagon> that's like a foldr in reverse
21:35:27 <mauke> > iterate tail "sigh"
21:35:28 <lambdabot>  Exception: Prelude.tail: empty list
21:35:33 <sorear> > tails "sigh"
21:35:34 <lambdabot>  ["sigh","igh","gh","h",""]
21:35:51 <sorear> >ap inits tails "sigh"
21:35:53 <newsham> norn: foldr and scanr are closely related
21:35:55 <sorear> > ap inits tails "sigh"
21:35:56 <lambdabot>  Couldn't match `a -> b' against `[[a1]]'
21:36:07 <sorear> > liftM3 zip3 inits id tails "sigh"
21:36:09 <lambdabot>  [("",'s',"sigh"),("s",'i',"igh"),("si",'g',"gh"),("sig",'h',"h")]
21:36:19 <hyrax42> where can I get a concise but useful intro to gadts
21:36:22 <sorear> > liftM3 zip3 inits id (tails . tails "sigh"
21:36:23 <lambdabot>  Parse error
21:36:27 <sorear> > liftM3 zip3 inits id (tails . tail) "sigh"
21:36:29 <lambdabot>  [("",'s',"igh"),("s",'i',"gh"),("si",'g',"h"),("sig",'h',"")]
21:36:53 <nornagon> scary
21:36:54 <newsham> > iterate (\(x:xs) -> xs ++ [x]) "sigh"
21:36:56 <lambdabot>  ["sigh","ighs","ghsi","hsig","sigh","ighs","ghsi","hsig","sigh","ighs","ghsi...
21:37:15 <nornagon> :t sequence
21:37:17 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
21:37:30 <nornagon> > sequence ["sigh"]
21:37:31 <lambdabot>  ["s","i","g","h"]
21:37:34 <sorear> > (map (take 4) . tails . cycle) "sigh"
21:37:36 <lambdabot>  ["sigh","ighs","ghsi","hsig","sigh","ighs","ghsi","hsig","sigh","ighs","ghsi...
21:37:42 <nornagon> > sequence "sigh"
21:37:43 <lambdabot>  Couldn't match `m a' against `Char'
21:37:59 <mbishop> > tails "bingo"
21:38:00 <lambdabot>  ["bingo","ingo","ngo","go","o",""]
21:38:13 <allbery_b> > sequence ["sigh"]
21:38:14 <mbishop> and bingo was his name, oh!
21:38:14 <lambdabot>  ["s","i","g","h"]
21:38:17 <newsham> > (reverse.tails.reverse) "bingo"
21:38:19 <lambdabot>  ["","b","ib","nib","gnib","ognib"]
21:38:32 <chessguy> sorear?
21:38:45 <sorear> > unwords . transpose . replicateM 4 $ "01"
21:38:46 <lambdabot>  "0000000011111111 0000111100001111 0011001100110011 0101010101010101"
21:38:47 <hyrax42> gadts nobody?
21:38:58 <newsham> why is there no  revrev f = reverse.f.reverse ?
21:39:04 <sorear> chessguy?
21:39:22 <sorear> @let revrev = (reverse.) . (.reverse)
21:39:22 <chessguy> sorear, what does partiality have to do with the discussion on recursion?
21:39:23 <lambdabot> Defined.
21:39:25 <newsham> ?let revrev f = reverse.f.reverse
21:39:26 <lambdabot> <local>:3:0:     Multiple declarations of `L.revrev'     Declared at: <local>...
21:39:28 <newsham> oops
21:39:37 <sorear> newsham: there IS a revrev
21:39:45 <newsham> > revrev tails "bingo"
21:39:47 <lambdabot>  ["","b","ib","nib","gnib","ognib"]
21:39:54 <mbishop> revrev, is that like vroomvroom? :)
21:39:58 <sorear> chessguy: in a sense, foldr is partial.
21:40:07 <sorear> but only one sense.
21:40:34 <chessguy> but i mean, you said you thought i wanted only partial HOFs. why?
21:40:38 <newsham> > revrev (map succ) "bingo"
21:40:39 <lambdabot>  "cjohp"
21:41:13 <sjanssen> chessguy: thanks for trying that program.  Did you try running it with +RTS -N2 ?
21:41:14 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
21:42:07 <dons> re.
21:42:08 <lambdabot> dons: You have 5 new messages. '/msg lambdabot @messages' to read them.
21:42:11 <chessguy> sjanssen, yes, it just dumped the help file
21:42:17 <newsham> ?check \f l -> revrev (map f) l = map f l
21:42:17 <lambdabot>  Parse error
21:42:26 <newsham> ?check \f l -> revrev (map f) l == map f l
21:42:27 <lambdabot>  Add a type signature
21:42:35 <newsham> ?check \f l -> revrev (map f) l == map f (l :: [Int])
21:42:36 <lambdabot>  Add a type signature
21:42:49 <newsham> ?check \f l -> revrev (map (f :: Int -> Int)) l == map f (l :: [Int])
21:42:52 <lambdabot>  OK, passed 500 tests.
21:43:35 <dibblego> I can't believe what I just heard Erik Meijer say in this video
21:44:08 <sjanssen> chessguy: can you run this command: ghc --make broken.hs -no-recomp -threaded; ./broken +RTS -N2
21:44:10 <chessguy> ?src cycle
21:44:11 <lambdabot> cycle [] = undefined
21:44:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
21:45:03 <chessguy> sjanssen, now it just terminates
21:45:10 <sorear> 12735 stefan    26  10  475m 342m 3816 D  1.0 90.6 101:06.95 jhc
21:45:41 <sjanssen> chessguy: could you run ./broken +RTS -N2 several times?
21:45:48 <sorear> and that's WITH +RTS -c
21:45:52 <chessguy> with the current build?
21:45:57 <newsham> > let motor = "vroom " in motor cycle
21:45:58 <lambdabot>      The function `motor' is applied to one arguments,
21:45:58 <lambdabot>     but its type `[Cha...
21:45:59 <sjanssen> chessguy: correct
21:46:38 <newsham> > let motor f = f "vroom" in motor cycle
21:46:39 <lambdabot>  "vroomvroomvroomvroomvroomvroomvroomvroomvroomvroomvroomvroomvroomvroomvroom...
21:46:45 <chessguy> hm, sometimes i'm getting broken: user error (Codec.Compression.Zlib: buffer error)
21:47:01 <sjanssen> chessguy: okay good, it's broken for you too :)
21:47:07 <glguy> > "my roflcopter goes " ++ cycle "soi "
21:47:09 <lambdabot>  "my roflcopter goes soi soi soi soi soi soi soi soi soi soi soi soi soi soi ...
21:47:18 <sjanssen> chessguy++ thanks
21:47:27 <chessguy> sure thing. glad to help
21:47:52 * sorear wishes he actually had those 475m
21:48:10 <sjanssen> time for sorear to upgrade
21:48:36 <dons> so what's all this about broken zlibs?
21:48:45 <dons> people streaming/threading bytestrings?
21:48:45 <newsham> > let motor roar = roar "vroom! " in motor cycle
21:48:47 <lambdabot>  "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom...
21:48:47 <sjanssen> dons: or broken RTS
21:48:53 <sjanssen> dons: haven't tracked it down yet
21:48:53 <Pseudonym> "roflcopter" is etymologically incorrect, BTW.
21:48:57 <sorear> sjanssen: jhc: the first non-contrived program to set off my temp alarm!
21:49:00 <dons> sjanssen: ok. you on the case though?
21:49:05 <dons> sorear: hehe
21:49:08 <newsham> pseudo: get off the lollercoaster
21:49:26 <dons> sorear: could you try compiling the binary tests/Benchmark.hs program, I think that might do it (?)
21:49:32 <sorear> it's only been GC'ing continuously for like the last 2 hours
21:49:38 <dons> yikes
21:49:39 <sorear> compiling base
21:49:49 <chessguy> ok, so thus far i have: until, map, filter, foldl (foldl1), scanl (scanl1), foldr (foldr1), iterate, repeat, replicate, cycle, take? drop?, takeWhile? dropWhile? scan?  any? all?, elem
21:49:53 <sjanssen> jhc can compile base?
21:49:56 <sorear> dons: and that's WITH +RTS -s ...
21:50:07 <dons> sjanssen: its subset, surely
21:50:09 <sorear> sjanssen: a subset anyway
21:50:34 <newsham> chessguy: then the monad-a-likes, mapM, mapM_, forM, forM_, replicateM, replicateM_, etc..
21:50:35 <sorear> WITHOUT +RTS -s jhc used 600m/384 and went into hard thrash death.
21:51:02 <newsham> chessguy: list monad has implicit loops built into bind
21:51:15 <chessguy> err
21:51:24 <chessguy> isn't the bind for the list monad just concatmap?
21:51:24 <newsham> also list ocmprehensions (basically same deal)
21:51:28 <chessguy> concatMap
21:51:36 <newsham> ok, and concatmap has map which is on your list...
21:51:53 <chessguy> hmm
21:52:03 <chessguy> i think concatmap should be included too, but i'm not sure why
21:52:11 <chessguy> and mapAccuml
21:52:15 <chessguy> @type mapAccuml
21:52:16 <newsham> lots of the things on your list use something else on the list that is more primitive (see http://haskell.org/onlinereport/standard-prelude.html)
21:52:17 <sorear> mapAccumL
21:52:17 <lambdabot> Not in scope: `mapAccuml'
21:52:18 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
21:52:23 <chessguy> @type mapAccumL
21:52:25 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:52:32 <sorear> chessguy: haskel is case sensitive!
21:52:39 <chessguy> sorear, yeah, i'm just tired
21:52:41 <sorear> and speling sensitive :(
21:52:48 <sorear> wrt "haskel"
21:53:03 <chessguy> believe it or not, i know better
21:53:06 <newsham> > replicateM (Maybe 5)
21:53:13 <lambdabot>   Not in scope: data constructor `Maybe'
21:53:13 <mauke> haskell needs something like http://search.cpan.org/~davecross/Symbol-Approx-Sub-2.02/Sub.pm
21:53:14 <lambdabot> Title: Symbol::Approx::Sub - Perl module for calling subroutines by approximate names!  ...
21:53:21 <newsham> > replicateM 3 (Just 5)
21:53:22 <dons> chessguy: re. concatMap, list comprehensions are desugared to concatMaps
21:53:22 <lambdabot>  Just [5,5,5]
21:53:36 <chessguy> newsham, hmm. maybe we need some kind of dependency graph between all these recursion operators
21:53:59 <desrt> chessguy; no natural one exists
21:54:00 <newsham> chessguy: sure, that makes sense.  but keep in mind that one implementation might choose different primitives than the other..
21:54:21 <desrt> chessguy; you can implement [] using map and filter or implement map and filter using []
21:54:26 <newsham> but if what you want to do is identify a few primitives that others are based on, seems like that natural thing to do
21:54:56 <chessguy> ?src map
21:54:57 <lambdabot> map _ []     = []
21:54:57 <lambdabot> map f (x:xs) = f x : map f xs
21:55:03 <newsham> chessguy: what is the point of this exercise?
21:55:06 <desrt> chessguy; if you choose one rather than the other as your 'base' then you can do what you are trying
21:55:10 <sorear> desrt: no.  [ (x,y) | x <- "write this using", y <- "map and filter only" ]
21:55:47 <chessguy> desrt, you're saying this is map in terms of []? how would you write [] in terms of map then?
21:55:49 <desrt> sorear; bah.  you know what i mean :p
21:56:03 <chessguy> newsham, did you read my thread on recursion on -cafe today?
21:56:13 <desrt> chessguy; [ succ x | x <- [3..4] ], for example
21:56:14 <newsham> chess: no, lots of traffic, i had to skip many
21:56:19 <desrt> is just map succ [3..4]
21:56:24 <sorear> chessguy: isn't "thread" plural? *duck*
21:56:28 <dons> I love the internets. "Today, rewriting a slow Ruby program in Haskell is one of many options available" ! :)
21:56:38 <chessguy> sorear, huh?
21:56:45 <dons> "Rewriting a Ruby app in Haskell certainly seemed to make sense to
21:56:45 <dons> everyone I talked to"
21:56:46 <desrt> chessguy; and the other commonly used feature of list comprehension -- filtering.  well that should be obvious :)
21:56:58 <hyrax42> dons: source?
21:57:02 <desrt> dons; ow.
21:57:04 <dons> http://notes-on-haskell.blogspot.com/2007/01/ruby-vs-haskell-choose-what-works.html
21:57:06 <newsham> dons: when will lambdabot @farber ?
21:57:06 <lambdabot> Title: Notes on Haskell: Ruby vs. Haskell: Choose what works, http://tinyurl.com/ypfnks
21:57:11 <sorear> chessguy: iirc there was only one artical in this "thread"
21:57:15 <chessguy> desrt, that implementation seems rather obtuse
21:57:16 <dons> newsham: ah right! your patch is in my inbox.
21:57:29 <desrt> chessguy; why?  it's just different.
21:57:47 <chessguy> sorear, it's a single thread, currently with two posts
21:57:53 <chessguy> sorear, i don't know what your point is
21:58:01 <chessguy> desrt, it seems unnatural
21:58:06 <dons> I think in this guy's case Haskell does make a lot of sense. xml parsing at speed, written quickly
21:58:07 <desrt> chessguy; which one?
21:58:20 <sorear> chessguy: I have none - I thought you were unanswered.
21:58:22 <sorear> :)
21:58:23 <chessguy> desrt chessguy; [ succ x | x <- [3..4] ], for example
21:58:41 <desrt> chessguy; it's just a random example of one of the several things you can do with list comprehension
21:58:44 <chessguy> sorear, even if i were, it's still a single thread
21:59:06 <newsham> chessguy: what subject/author?
21:59:18 <sorear> dons: well, I've wasted today compiling JHC.  Tomorrow I will implement haskell coloring! (yr)
21:59:40 * sorear > homework, turns off monitor
21:59:45 <desrt> cha.
22:00:04 <chessguy> newsham, http://www.haskell.org/pipermail/haskell-cafe/2007-January/021974.html
22:00:06 <lambdabot> Title: [Haskell-cafe] Levels of recursion, http://tinyurl.com/35m936
22:00:28 <newsham> "When the professor pointed out that you simply have to assume
22:00:28 <newsham> that the recursive call will work, and then the whole recursive
22:00:29 <newsham> definition will, a light bulb went on"
22:00:49 <dons> I guess the Ruby guys are already receptive to new languages and new ideas
22:00:49 <newsham> ehh.. it works if you're breaking down your problem into smaller problems, and you have some step that can do small problems without recursion
22:00:56 <dons> http://programming.reddit.com/info/12a6a/details
22:00:57 <lambdabot> Title: Ruby and Haskell: write your Rails backend code in Haskell instead of C (reddit. ...
22:01:18 <dons> oh, it gets better! http://notes-on-haskell.blogspot.com/2007/01/haskell-open-secret.html
22:01:20 <lambdabot> Title: Notes on Haskell: Haskell: the open secret, http://tinyurl.com/3dktxf
22:01:34 <newsham> "I know how to sort a deck of 1 card"   "I can sort any deck by splitting the deck into two decks, one with cards smaller than the first card, and one with cards bigger than the first card, sorting the two decks, and putting them togther small one then big one"
22:01:34 <dons> "It turns out that a few members of the Rails team have informally chosen Haskell as their language
22:01:38 <dons> of the year this year"
22:01:47 * glguy tires of content-free blog posts... prefers point-free functions
22:01:56 <newsham> its more than juts beliving that it will work ;-)
22:02:10 <dons> any ruby/rails guys in here? raise your hands!
22:02:13 <dons> lambdas for all!
22:02:19 <desrt> λ
22:02:25 <dibblego> dons, I converted a colleague, who decided he had to leave and go back to uni
22:02:36 <dons> heh
22:02:37 <dibblego> on that note, there is talk of funding a PhD for me!
22:02:44 <dons> oh wow!
22:02:50 <dons> from work?
22:02:50 <dibblego> indeed
22:03:00 <dibblego> 50% work, 50% some government thing that I don't quite understand
22:03:05 <chessguy> newsham, yes. the point is, you don't look inside the recursive cal
22:03:11 <dons> yeah, sounds reasonable. that's moderately common
22:03:19 <dons> where are you thinking of going?
22:03:24 <dibblego> really? do you know any guys who do that?
22:03:25 <newsham> chessguy: yah, you say "I know how to solve the smaller problem already"
22:03:30 <dibblego> QUT
22:03:32 <newsham> so your job is just to make it smaller
22:03:35 <newsham> (induction, yay)
22:03:35 <chessguy> newsham, right
22:03:48 <chessguy> that's how you first start out learning recursion
22:03:56 <dibblego> I have been using Scala for the last few weeks, but damn I miss Haskell
22:04:41 <newsham> there are more complicated varieties, for example, you know how to solve the problem of size 2, and you known how to break down a problem into two equal halves, so you can solve any problem of size 2^n (but not other sizes!)
22:05:25 <goltrpoat> evening.
22:05:29 <glguy> Scala looked nice if you were required to use the JVM
22:05:38 <chessguy> newsham, yes, but that's a fairly small variation
22:05:46 <newsham> Udi Manber has a really good algorithms book that teaches algorithms by teaching how to create algorithms using inductive techniques.
22:05:48 <dibblego> yeah, I set that as a requirement as an experiment
22:06:22 <newsham> http://www.amazon.com/Introduction-Algorithms-Creative-Udi-Manber/dp/0201120372
22:06:26 <lambdabot> http://tinyurl.com/22c4sx
22:06:42 <chessguy> newsham, does he get into HOFs?
22:06:54 <newsham> the pseudo code is all in a pascal-like language.
22:06:59 <newsham> so: no.
22:07:14 <chessguy> newsham, did you read my whole post?
22:07:24 <newsham> didnt finish, i'll go back :)
22:07:27 <chessguy> ok
22:07:35 <goltrpoat> using JVM is an odd requirement, no?  the current implementations seem to have a strange approach to GC, in the sense of "eh, we'll write a mark and sweep implementation, and what happens afterwards is your problem"
22:07:55 <chessguy> that will make it easier to explain my point with this list of functions
22:07:55 <dibblego> goltrpoat, not when the entire world runs on it - despite its deficiencies
22:07:56 <goltrpoat> seems like that's one place where .net was ahead of the jvm by construction
22:08:10 <glguy> %CPU   PID USER      PR  NI  VIRT  RES  SHR S %MEM    TIME+  COMMAND
22:08:10 <glguy>    1 12266 eric      16   0 14496  11m 2528 S  4.6  64:19.24 hpaste
22:08:22 <newsham> chessguy: "where'd the recursion go", well, thats the point..  you dont always want to have to think in terms of recursion, so the higher order functions hide that.
22:08:28 <goltrpoat> dibblego:  well, that's a somewhat odd statement as well.  entire world?
22:08:30 <glguy> if I restarted hpaste, it would shed about 6 meg of virtual ram size
22:08:39 <dibblego> goltrpoat, it's an exageration
22:08:43 <glguy> is that normal for a "long running" app?
22:08:44 <newsham> ie. I dont care that "map" is implemented recursively.  Its a black box.  all I want to know is that it applies my function to each element of a list and makes a new list in the process
22:08:44 <sorear> goltrpoat: are you criticizing the JVM, or everything else?
22:08:46 <chessguy> newsham, yes, exactly, that is the point
22:09:03 <chessguy> but it's something we're not teaching much of
22:09:08 <chessguy> to newbies
22:09:16 <sorear> glguy: yes, on all unixes.  get a real OS, like House. :)
22:09:22 <goltrpoat> sorear:  oh, i think i just joined in the middle of a conversation, and a particular statement jumped out.
22:09:37 <newsham> hmm..  I'm not from the functional world, and I picked up on it pretty quickly (dont remember where).. *shrug*
22:09:47 * glguy never did bother to figure out the difference between Virt and Res
22:09:56 <goltrpoat> sorear:  i think the current JVM implementations are odd, to put it mildly.  i don't have anything against it conceptually, it's just that it's very badly implemented, currently.
22:10:00 <newsham> for example, it was a eureka for me when I noticed that a loop with an accumulator is a type of fold
22:10:03 <chessguy> heh. so maybe i'm just dumb
22:10:13 <newsham> (and that I prefer my fold's with the arguments reversed to reflect that)
22:10:51 <glguy> the checkpoint file is up to 148K
22:10:55 <goltrpoat> sorear:  it doesn't take a brain surgeon to write a compacting collector, and the current implementations *still* can't get it right, from what i hear.
22:11:07 <sorear> glguy: Virt is address space, Res is RAM.  Res will never exceed physical,  Virt - Res is swapped out / COW portion.
22:11:09 <chessguy> ?src foldr
22:11:10 <lambdabot> foldr k z xs = go xs
22:11:10 <lambdabot>     where go []     = z
22:11:10 <lambdabot>           go (y:ys) = y `k` go ys
22:11:32 <newsham> ie:   foreach 0 "123" (\accum ch -> [newline;indent]accum * 10 + charToDigit ch [newline])
22:11:37 <sorear> goltrpoat: are you talking about JVMs?  Haskell has compacting collectors, I'm using one now.
22:11:42 <dibblego> :t foreach
22:11:43 <goltrpoat> sorear:  JVMs
22:11:44 <glguy> but this server isn't using any swap space..
22:11:44 <lambdabot> Not in scope: `foreach'
22:11:46 <newsham> where    foreach init items func = foldl func init items
22:11:52 <glguy> so that means I still don't know the distinction yet ;)
22:11:56 <dibblego> :t iterate
22:11:58 <lambdabot> forall a. (a -> a) -> a -> [a]
22:12:37 <dibblego> goltrpoat, we started off mentioning Scala
22:12:42 <newsham> > foldl (\a c -> a * 10 + digitToInt c) 0 "123"
22:12:43 <goltrpoat> ah right
22:12:44 <lambdabot>  123
22:13:39 <sorear> glguy: if you allocates say 4M of stack, and only write to 1M, 1M will show up in RES and 4M in VIRT, thanks to linux allocate-on-write.  same with COW.
22:13:42 <sorear> i think
22:13:46 <newsham> chessguy; I think (for myself at least), the useful way to go about this is to 1) start off with primitive recursion, 2) notice patterns and build abstractions, 3) learn that you reinvented something like map or fold
22:13:53 <glguy> 34000+ requests served
22:13:58 <newsham> then you have a really deep understanding of it
22:13:59 <glguy> sorear: ahh
22:14:14 <newsham> and you also have practice identifying patterns and abstracting them
22:14:18 <dons> glguy: cool
22:14:24 <dons> glguy: how big are the checkpoints now?
22:14:28 <glguy> 147K
22:14:31 <dons> ping me when they hit 1M
22:14:39 <glguy> ok
22:14:50 <goltrpoat> chessguy:  btw, i ran across some papers on Go programming a while back, and had some thoughts i wanted to bounce off someone, you up for it?
22:15:00 * glguy codes hpaste to CTCP PING dons when a checkpoint is written with size exceeding 1M
22:15:04 <dons> this is the lazy programmer's optimisation strategy
22:15:09 <glguy> dons: what do you propose we do then?
22:15:10 <dons> only improve things once its gets bad
22:15:15 <dons> glguy: leave stuff on disk
22:15:17 <aFlag> hello, I have a C function that stores some data on some piece of memory and wants data allocated in another place. I want only C functions to handle that data, is there a way to have a type on haskell that will let a haskell programmer use the data only on the C functions that I'm making a wrapper of?
22:15:22 <dons> and just cache the last 100k or so
22:15:28 <chessguy> newsham, yes. and i think making up a cheat sheet with a list of each function and a simple summary would help with that
22:15:39 <glguy> dons: does Happs support that, or would we need to extend that as well?
22:15:49 <dons> aFlag: yeah, a newtype that wraps your C functions
22:15:49 <newsham> also I suspect that some of these concepts would be a lot easier for a newbie to pick up if the name were different.   for example "zipWith" is a well understood idea, if you think aboutt it..  ie. zipWith (+) == vector addition
22:15:53 <dons> that is not exported from its module
22:16:02 <dons> so only those functions you supply, of the correct type, will compile
22:16:04 <sorear> aFlag: newtype Foo = Foo (Ptr Bar)  -- only expose Foo constructor to authorized API wrappers
22:16:09 <newsham> but people first learn "zip" and go "wtf?!"
22:16:16 <dons> that way you can enforce that *no* functions other than those you provide may be used on this data
22:16:26 <aFlag> hum, I see
22:16:30 <chessguy> newsham, so that when looking at the code, they could look at the sheet and go "oh yeah", instead of having to put down the code, find the function, read the source for the function, remember what it does, and then go back and apply it to whatever source you were looking at
22:16:34 <dons> glguy: or we write it ourselves
22:16:40 * dons isn't averse to a bit of hacking
22:16:44 <chessguy> goltrpoat, i don't really know much of anything about go
22:16:57 <aFlag> thanks
22:16:57 <dons> ?users
22:16:58 <glguy> dons: I just wondered if the functionality existed yet :-p
22:16:58 <lambdabot> Maximum users seen in #haskell: 322, currently: 280 (87.0%), active: 34 (12.1%)
22:17:06 <dons> aFlag: i'd be interested to see how you go with this
22:17:11 <goltrpoat> chessguy:  me neither.  seems like they do a lot of things that are very different in chess, programming, though.  specifically, they seem to be fond of their MC schemes.
22:17:11 <newsham> chess: I personally find it easier to read code that has a function if I've used that function before.
22:17:19 <dons> since its exactly the type of strong static guarantee you should be able to code up pretty easily in haskell
22:17:32 <newsham> prob writing a bunch of things using those primitives before reading code that uses it works better
22:17:32 <chessguy> goltrpoat, what's an MC scheme?
22:17:35 <newsham> or maybe thats just me
22:17:40 <aFlag> alright
22:18:07 <chessguy> newsham, i don't know, but it just seems to me that we could somehow do a better job of teaching these HOFs that are hiding recursion
22:18:10 <newsham> chess: but really this isnt any different than learning what predefined things exist in the library of any language.
22:18:20 <sorear> goltrpoat: is it like an MZ scheme? :p
22:18:21 <newsham> one of the things you learn in a new language is what tihngs are already there for you
22:18:23 <goltrpoat> chessguy:  monte carlo.  imagine picking a positive n, and coming up with some set of random lines up to n ply.
22:19:09 <newsham> (and perhaps moreso in haskell because the "core" language doesnt really have a lot of things that are in other core languages, like "for" and "while" and such)
22:19:14 * glguy bed
22:19:25 <goltrpoat> chessguy:  this gives you two things:  a) if you're finishing it up with QS, you end up with something useful in the transposition table.  b) 5000 lines is nothing, searchwise.  b) taking the mean and standard deviation, gives you a, possibly, reasonable a-b window.
22:19:29 <newsham> ok, i'm out.
22:19:32 <goltrpoat> last b=c.  heh.
22:19:37 <newsham> > let motor roar = roar "vroom! " in motor cycle
22:19:39 <lambdabot>  "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom...
22:19:39 <chessguy> newsham, thanks for the discussion
22:19:56 <dons> sjanssen: hmm, I think we might just have to resubmit some of these shootout entries
22:20:11 <mauke> > let motor = id `flip` "vroom " in motor cycle
22:20:13 <lambdabot>  "vroom vroom vroom vroom vroom vroom vroom vroom vroom vroom vroom vroom vro...
22:20:23 <sjanssen> dons: think they just got lost in the shuffle?
22:20:25 <newsham> mauke: that makes no sense
22:20:45 <newsham> "let motor i.d. flip vroom in motorcycle" ?
22:21:03 <dons> sjanssen: yeah, and isaac hasn't replied, which is a bit strange
22:21:07 <chessguy> mean and standard deviation board values?
22:21:19 <dons> sjanssen: there was an issue with things submitted before ghc 6.6 was installed, that then broke and got removed
22:21:25 <goltrpoat> chessguy:  make sense?  with MTD(f) and driver algorithms in general, you're looking to hit the best line as soon as possible, and you want the smallest possible bound around that.  well, doing some statistics to determine a possible bound and a possible score to zoom in on, could possibly be accomplished with an MC scheme.
22:21:42 * dons -> home. bbl
22:21:59 <sorear> dons: has SyntaxNinja at least acknowledged receiving them?
22:22:24 <goltrpoat> MTD(f) style algorithms actually benefit from a good bound on the *first* node, so that's why this is interesting.
22:22:49 <chessguy> goltrpoat, hmm. maybe. i'm not used to thinking about such an enormous search space
22:22:55 <sorear> finally! jhc is dons: jhc: <stderr>: hPutStr: illegal operation (handle is finalized)
22:23:05 <goltrpoat> chessguy:  isn't that the whole point? :)
22:23:10 <chessguy> goltrpoat, like i said, i really don't know anything about go
22:23:17 <goltrpoat> oh i'm talking about chess
22:23:29 <chessguy> what? you said you were talking about go
22:23:34 <goltrpoat> right
22:23:41 <goltrpoat> i was reading about an algorithm that's used in go programming
22:23:48 <goltrpoat> i am wondering about its applications to chess programming
22:24:01 <chessguy> oh, ok
22:24:16 <chessguy> i don't think it would be as beneficial in a search space that's so much smaller
22:24:17 <goltrpoat> specifically, to establish bounds in your usual branch and bound scheme.
22:26:03 <goltrpoat> their take is -- shoot out a large number of drivers in random directions, come up with an average, then do this weird markovian thing down the tree.  i'm not quite talking about that, i'm just saying that with iterative deepening, you can, prior to your first real search, start off by picking 5-10k random lines, and evaluating them
22:26:12 <goltrpoat> this gives you a very conservative window
22:27:00 <chessguy> hmm, or do this instead of pondering maybe
22:27:11 <goltrpoat> if you're doing PVS or some such, a conservative window on the first ply is A Good Thing.
22:28:16 <goltrpoat> hmm..  oh, good point.  that could be useful with or intstead of pondering
22:28:17 <hpaste>  elifant pasted "This program causes "stack overflow" on 1.2M file. Any optimization suggestions?" at http://hpaste.org/236
22:28:40 <goltrpoat> probably not instead, since with pondering you're more likely than not to hit paydirt
22:28:45 <goltrpoat> maybe do the two concurrently though.
22:28:59 <chessguy> yeah
22:29:12 <goltrpoat> anyway.  seems useful as a pre-search "extension", of sorts.
22:29:28 <chessguy> sounds like a good masters thesis
22:29:34 <goltrpoat> heh
22:30:22 <chessguy> not that i know anything about such things
22:30:26 <sorear> Elifant: if you can use normal spaces, there IS a standard 'words'
22:30:45 <Elifant> sorear: I know, but there are punctuation signs in file
22:30:52 <goltrpoat> what do you mean?  the few times ive seen you talk about search problems, you seemed to be more than conversant
22:31:27 <chessguy> i meant i don't know anything about thesis papers :)
22:31:31 <goltrpoat> oh
22:31:31 <goltrpoat> hehe
22:31:43 <goltrpoat> me neither.
22:32:18 <sorear> Elifant: Map a (Map b c) ==> Map (a,b) c.  might not fix it, but will probably improve things...
22:32:52 <Elifant> sorear: how then to find all 'b' for given 'a'?
22:33:24 <sorear> split?
22:33:40 <sorear> @hoogle a -> Map a b -> (Map a b, Maybe b, Map a b)
22:33:41 <lambdabot> Data.Map.splitLookup :: Ord k => k -> Map k a -> (Map k a, Maybe a, Map k a)
22:33:47 <sorear> @hoogle a -> Map a b -> (Map a b, Map a b)
22:33:48 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
22:34:29 <sorear> > M.split "foo" (M.fromList [("a",1),("b",2),("z",3), ("e",4)])
22:34:30 <lambdabot>  ({"a":=1,"b":=2,"e":=4},{"z":=3})
22:34:49 <sorear> and it's efficient, O(log n)
22:34:51 <chessguy> anyway, time to hit the sack. 'night all
22:35:06 <goltrpoat> chessguy:  i wrote a quick bitboard backend a couple of months ago, i'm probably going to PD it once it's an actual engine
22:36:00 <Elifant> sorear: ok, I'll try use Map (a,b) c
22:36:03 <goltrpoat> chessguy:  i'm rather intersted in what can be done here in haskell, since it's such a notoriously unparallelizable problem.  not to mention a notoriously bug-ridden problem, heh.
22:36:10 <allbery_b> glguy> but this server isn't using any swap space..
22:36:30 <sorear> allbery_b: ?
22:36:33 <sorear> you copy?
22:36:36 <allbery_b> virt - res isn't just swap; it's also portions f the executable or initialized data that aren't in RAM
22:37:01 <allbery_b> if you aren't using swap, it indicates that the unused parts of the executable aren't wasting RAM
22:37:04 <sorear> that's part of what I meant by COW
22:37:08 <allbery_b> yeh
22:37:31 <sorear> but of course you put it clearer :)
22:38:17 <goltrpoat> chessguy:  hell, just writing a decent perft in haskell is a somewhat interesting challenge.  people get 1.4Mnodes/sec these days.  my old c++ engine was managing 400K/sec on a good day.
22:38:23 <allbery_b> given that (non-HEAD?) ghc creates largely static binaries, there's a lot of stuff that just plain isn't needed most of the time linked into them.  unix is smart and leaves those on disk instead of wasting memory on them
22:38:49 <allbery_b> so they['re part of the virtual address space, but remain vrtual because they're unnecessary
22:39:12 <sorear> "Unix is a lazy functional programming language implemented as a C DSL" -- attribution forgotten
22:40:28 <allbery_b> likewise, libc is linked dnamically and contains a lot of stuff you don't care about --> consume virtual address space, but (a) what isn't used isn't in RAM, (b) what *is* in RAM is shared with everything else that is using it
22:40:41 <goltrpoat> badly implemented as a C dsl :)
22:40:43 * goltrpoat ducks
22:41:20 * sorear is seriously considering switching to house ...
22:41:36 <nornagon> really?
22:41:44 <nornagon> does anything useful actually run under it?
22:41:50 <sorear> not very, but ...
22:41:54 <sorear> GHC!
22:42:00 <nornagon> heh
22:42:00 <sorear> :)
22:42:09 <goltrpoat> someone should bring BeOS back
22:42:13 <nornagon> ghc and yi, i guess that's all sorear needs to achieve happiness
22:42:19 <nornagon> and perhaps links
22:42:20 <nornagon> and irssi
22:42:24 <nornagon> :P
22:42:31 <sorear> nornagon: nope, I'm using erc now
22:42:35 <nornagon> oh wait, you're some crazy erc user
22:42:39 <sorear> will write yirc!
22:42:40 <Nafai> woo erc
22:43:15 <nornagon> so is yi a vi replacement or an emacs replacement or both?
22:43:51 <allbery_b> "yes"
22:44:07 <allbery_b> it supports several dialects of both, plus a few other thngs
22:45:07 <sorear> right now it's more of an nvi/mg replacement
22:45:09 <allbery_b> and at least in principle you could plug in a module to emulate somehting like BRIEF
22:45:10 <bos> @pl \x -> f x >>= blah
22:45:11 <lambdabot> (blah =<<) . f
22:46:00 <sorear> vim/emacs will come .. the lambda revolution is irrevokably advancing
22:46:22 <sorear> @users
22:46:23 <lambdabot> Maximum users seen in #haskell: 322, currently: 273 (84.8%), active: 31 (11.4%)
22:46:51 <goltrpoat> does the lambda revolution really have to recruit vim and emacs
22:48:51 * sorear is finding it difficult to imagine recursion without pattern matching
22:49:57 <goltrpoat> ?
22:50:58 <goltrpoat> pattern matching is just a useful way of formalizing case analysis
22:51:10 <goltrpoat> there's any number of other ways to do it
22:51:19 <goltrpoat> most of them not as nice, but eh.  certainly easy to imagine.
22:53:43 <goltrpoat> setup.lhs: cannot satisfy dependency unix-any
22:54:11 <goltrpoat> linux/bsd folk are pretty big on cross-platform compatiblity, but when it comes to windows, suddenly all of those considerations go out the window
22:54:37 <goltrpoat> wonder why, considering almost 50% of ghc users are running windows, according to that one poll recently.
22:55:45 <Korollary> It's a drag.
22:57:15 <goltrpoat> yeah.
22:58:47 <newsham> what are you building, golt?
22:58:54 <Korollary> We should write webapp versions of everything and let the browser handle it all!
22:58:55 <goltrpoat> well, yi, which wanted vty
22:59:17 <Korollary> with ajax and blackjack
22:59:25 <goltrpoat> and vty wants unix-any, which i suspect is not going to build.
22:59:28 <newsham> golt: you can build the gtk directory
22:59:39 <newsham> cd gtk; ./Setup.hs configure; ..etc
23:00:20 <goltrpoat> how would gtk help me with the vty dependency?
23:00:21 <goltrpoat> hehe
23:00:28 <newsham> the gtk dir doesnt use vty
23:00:46 <goltrpoat> but yi imports vty stuff
23:00:58 <newsham> in the Vty-specific parts it does
23:01:00 <Nafai> I can't build vty for some reason
23:01:11 <Korollary> bug the hell out of sorear
23:01:18 <newsham> golt: but the gtk code doesnt use those bits, and it builds on windows without vty
23:01:26 <goltrpoat> im pretty sure ive builty gtk here, but i think that was back when i was on 6.5 with vs
23:01:28 <Korollary> maybe that'll make him get a different major in college. We gotta save that kid.
23:01:40 <goltrpoat> builty?  wtf.  built.
23:02:05 <goltrpoat> newsham:  i guess i'm just not following how building gtk will help me build yi :)
23:02:20 <Korollary> with good karma
23:02:24 <newsham> golt: yi.  has a subdir.  it is called "gtk".  when you build.  in that subdir.   it doesnt.  use.  vty.
23:02:35 <goltrpoat> oh
23:02:39 <newsham> i can slow down if you like.
23:02:59 <goltrpoat> k, i deserved that.
23:03:04 <Korollary> group hug
23:03:13 <newsham> plur
23:04:45 <uccus> how much of the Haskell population lives in Windows?
23:05:02 <goltrpoat> ohh actually i remember gtk2hs pulling this cool stunt with asking for a particular gtk install, that was already there.
23:05:07 <goltrpoat> maybe that's why i don't have any of this installed.
23:05:13 <newsham> dunno.  i think developers tend to use unix except when paid not to.
23:05:21 <newsham> (as a generalization...)
23:05:55 <goltrpoat> newsham:  actually, there was this relatively recent poll that i referred to earlier.  50% or thereabouts of haskell developers are on windows, or so it would seem.
23:06:00 <newsham> the latest gtk2hs thingy isnt on the front page, and it already has gtk libs rolled into it
23:06:05 <newsham> lemme see if i can dig up the url
23:06:14 <newsham> golt: interesting
23:06:24 <goltrpoat> it's on haskell.org somewhere
23:06:26 <uccus> makes sense though... the problem is I'm a physics major and my home PC is also used by my sister so sometimes I feel like I'm the only one here who definitely don't think emacs is user-friendly
23:06:27 <brainly-green> I dislike windows--it has no linux in it
23:06:40 <Korollary> actually you can run linux on windows
23:06:45 <newsham> http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
23:07:04 <goltrpoat> newsham:  thanks
23:07:08 <newsham> uccus: i'm a C/vi guy myself.
23:07:12 <brainly-green> I used to use windows but I got a macbook
23:07:16 <goltrpoat> korollary:  there's colinux
23:07:19 <nornagon> ooh, OS wars?
23:07:22 <Korollary> goltrpoat: That's what I meant.
23:07:23 <nornagon> *and* editor wars?
23:07:24 <goltrpoat> still rather unstable though
23:07:24 <newsham> i dont use emacs because i already have an OS installed on my computer ;-)
23:07:26 <brainly-green> and I changed my windows tower to run ubuntu
23:07:28 <nornagon> *and* language wars?!
23:07:51 <brainly-green> macs have linux in them
23:07:58 <nornagon> non, BSD
23:08:02 <newsham> uccus: one nice recent change is that you can easily run a system of your choice in a virtual machine these days
23:08:11 <uccus> well, I don't really see unix vs. mac war going very far
23:08:14 <goltrpoat> ohh right that's what it was:  "GHC does not appear to be installed (...) please install GHC version 6.6 or 6.4.2"
23:08:18 <newsham> brainly: macs are very unlinux.  perhaps you mean bsd?
23:08:21 <goltrpoat> funny thing is, i have BOTH 6.6 and 6.4.2 installed.
23:08:34 <brainly-green> ah right, bsd I guess
23:08:35 <aFlag> I use emacs as a virtualization software
23:08:38 <brainly-green> not the linux kernel
23:08:40 <brainly-green> darwin kernel
23:08:53 <brainly-green> unix then
23:08:56 <brainly-green> posix
23:09:31 <allbery_b> macs only have a BSD userspace
23:09:36 <allbery_b> the kernel is Mach
23:09:47 <uccus> newsham: do you mean Cygwin or something else?
23:09:50 <allbery_b> which has BSD-likebehaviors but is ver much *not* BSD internally
23:09:57 <newsham> and mach is a microkernel with some unixy emulation layer..  seems like a rather fine point, allbery.
23:10:14 <Nafai> Eek:
23:10:17 <Nafai> nafai@hermione:~/Programs/Haskell/yi/gtk$ runhaskell Setup.hs configure
23:10:17 <Nafai> Could not find module `Distribution.Simple':
23:10:17 <Nafai>   use -v to see a list of the files searched for
23:10:17 <Nafai>   (imported from Setup.hs)
23:10:21 <Nafai>  
23:10:23 <goltrpoat> i ran openbsd for years as a kid, on several machines.  no complaints.
23:10:35 <newsham> uccus: yah, my desktop is winxp, i cant really function without cygwin.
23:10:39 <brainly-green> ah I looked it up, it's actually the XNU kernel
23:10:46 <brainly-green> which incorporates the mach kernel and a BSD kernel
23:10:48 <newsham> but i also have unix machines and lots of VMs
23:10:53 <allbery_b> newsham: sort of a fine point, sort of not.  the nature of microkernels is that there's quite a lot of stuff which is really not unixlike at all which is visible to userspace
23:11:02 <allbery_b> (programs, at least)
23:11:15 <goltrpoat> linux, on the other hand, i remember having several complaints about, back then.
23:11:17 <brainly-green> whatever, it's *nix and it does everything linux does
23:11:21 <DannoHung> D'oh... so that's how unit/return works...
23:11:23 <allbery_b> the BSD emulation layer is sometimes very un-BSD-like
23:11:44 <goltrpoat> the main complaint hinged around the fact that a linux box was as good as wide open, 99% of the time.
23:11:45 <newsham> allbery: but it is more or less a BSD superset.  you have all of the normal BSD kernel APIs plus some additional mach vm, messaging, thread, etc.. stuff
23:11:46 <Nafai> Anyone have any idea what could be wrong that would cause me to get that error message?
23:12:02 <allbery_b> for example, many things which use AF_UNIX sockets on a Unix system use Mach IPC instead, with no emulation layer
23:12:08 <brainly-green> it runs my linux programs that's all I care about
23:12:12 <uccus> perhaps this is not the right place to ask this. but you have to  pardon me, I am a physics major. why so many different unix?
23:12:38 <newsham> uccus: long history, lots of freedom, divergent goals, lots of companies, etc..
23:12:39 <uccus> specifically, what is "BSD-like" and not "BSD-like"?
23:12:52 <uccus> newsham: of course, that's a given
23:12:55 <newsham> uccus: has to do with long unix history.
23:12:56 <brainly-green> plus it has a sweet interface
23:12:56 <goltrpoat> uccus:  it's a decent underlying structure, and different groups of people have different goals?
23:12:59 <allbery_b> uccus: largely left over from ancient history
23:13:19 <uccus> but what are the main design choices that vary?
23:13:25 <newsham> in the beginning there was ken, and ken had free time and a cool video game.  ken said "let there be core operating system functions" and there was unix.
23:13:51 <uccus> okay... then?
23:13:59 <newsham> then others began to use and contribute.  soon the whole group let their little baby wander out in the world and it was taken in and modified by some hippies in berkeley (much to the chagrin of its parents!)
23:14:01 <goltrpoat> it appears that the main design choices range from "i make the choices" (hi theo), to "you make the choices, er, wait, i make the choices" (hi.. uh.. folks)
23:14:36 <uccus> so what are the main differences now?
23:14:38 <allbery_b> the short version is that UC Berkeley took AT&T Research Edition 6 UNIX and turned it into something gennerally useful which became known as the Berkeley Standard Distribution (BSD); later on AT&T took Research Edition 7 and turned it into a commercial product (AT&T System III, then later SystemV)
23:14:39 <newsham> soon companies everywhere were using and extending unix, sometimes in incompatible ways.  Some borrowed from the original lineage (which had moved over to new caretakers and been extended itself) and others borrowed from the hippies
23:14:41 <uccus> BSD vs non-BSD?
23:14:53 <allbery_b> meanwhile various other folks took both and rolled their own mdifications.
23:15:03 <newsham> some say 'generally useful', others say 'corrupted'.  potato, potata.
23:15:08 <Nafai> What do this mean? "Setup.lhs: vty.cabal:13: Unknown field 'install-includes'"
23:15:24 <DannoHung> What do you call a function that accepts a monad?
23:15:24 <allbery_b> I suspect it means you have an outdated version of Cabal installed
23:15:25 <newsham> but all of this is fairly irrelevant to the whole "linux" camp, which came along a lot later and started from scratch.
23:15:45 <brainly-green>  it started from posix not scratch
23:15:53 <newsham> so while most unixen are somewhat related to BSD, some slightly divergent (and hence 'not very bsd like')...
23:15:55 <brainly-green> the posix spec
23:15:56 <goltrpoat> yeh, im not sure about the from scratch bit.
23:16:01 <allbery_b> early versions were obnly bvaguely related to POSIX, actually
23:16:03 <Korollary> I believe this is quite off topic.
23:16:12 <newsham> you have this whole other system which is only marginally influenced by BSD (in that it wants to be compatible in some ways)
23:16:28 <Nafai> allbery_b: Okay.  :(
23:16:37 <brainly-green> no they were posix or were trying to be
23:16:49 <allbery_b> very early Linux picked and chose APIs from POSIX and 4BSD, later on they decided to focus on PSIX
23:16:55 <newsham> perhaps the linux story should mention minix (perhaps not)
23:17:27 * allbery_b has been doing Linux since 0.7 or so, he recalls some of the weird stuff in very early versions before it was decided to adopt POSIX wholesale
23:17:41 <goltrpoat> yes.  linus and whats his name had a big row, and then there was love and understanding.
23:17:41 <newsham> anyway, the true creators of all that is unix continued to make gloriously well designed and tightly integrated systems, culminating in 10th edition unix, plan9 and inferno.
23:17:54 <newsham> which all have very little to do with the turd that is now known as unix.
23:18:01 <newsham> (which smells much nicer than windows nt)
23:18:06 <newsham> and they all lived happily every after
23:18:26 <goltrpoat> may i, please, take issue with the gloriously well designed bit.
23:18:45 <newsham> no you may not.  sit down in front.  thank you.
23:18:46 <goltrpoat> perhaps i shouldn't.
23:18:52 <allbery_b> heh.  precious little is well designed, much less glorious
23:18:52 <goltrpoat> haha
23:19:12 * goltrpoat sits back down and eats his popcorn.
23:19:18 <allbery_b> <-- cynical sysadmin who's had to maintain too many weird*ss "unix like" systems
23:19:30 <uccus> but I do programming quite often on Linux/OpenBSD machines, but my programs (being as trivial as they are) never use the "advanced" features, so I never notice any differences :(
23:20:06 <newsham> allbery: just because its not what you are comfortable (which is worth a lot when you have to deal with a bunch of mostly identical but annoyingly different systems) doesnt mean it isnt good :)
23:20:09 <uccus> may be the differences are in threading?
23:20:37 <newsham> uccus: the whole unix, bsd, linux, etc.  thing..  are really more a like than they are different.
23:20:47 <goltrpoat> uccus:  posix threads are gloriously well designed.
23:20:50 <allbery_b> newsham:  some things calling themselves "unix" are only dubiously so.  look up AIX4 sometime.
23:20:53 * goltrpoat twitches and eats more popcorn.
23:20:53 <newsham> sorta like human beings.  people focus on the differences, but the parts are pretty similar
23:21:20 <newsham> all: thats one of the few i have not had the misfortune of dealing with.
23:21:31 <allbery_b> which was a kinda almost unix overlay on top of some strange hybrid of System/390 and OS/2
23:21:34 <uccus> yes, so I have experienced... but what sort of programmers would notice the difference heavily? where are those differences? concurrency? graphics?
23:22:18 <newsham> uccus: there are a lot of small api differences.  also some systems try to be a superset of all features, which causes lots of incompatability problems when people learn how to code on those systems without reguard to the portable subset of features
23:22:30 <DannoHung> Let me see if I've got this all straight:  Bind (>>=) unwraps monads and passes the primary value into a function, return takes a regular value and wraps it in the identity monad...
23:22:34 <allbery_b> large parts of it were, well, nto very unixy at all.  lots of stuff living in an OS/2-ish ODM registry; many system services looked more like mainframe stuff than unix
23:22:48 <newsham> here's a small example (thats not necessarily representative):  /proc filesystem and its use to access various system data
23:22:50 <uccus> I am asking all these because I have used yi on linux and managed to install it in windows and the windows version is not very easy to use (crashes often)
23:22:51 <newsham> or sysctl.
23:23:23 <newsham> danno: thikn of "bind" as something that combines two "actions" into one "action"
23:23:41 <newsham> and a do-block as a generalization of that (gluing together many "actions" into one "action")
23:24:01 <uccus> danno: no, it doesn't wrap it in identity monad... it wraps it into the particular monad in consideration
23:24:16 <newsham> http://www.haskell.org/haskellwiki/IOIntro_Actions
23:24:18 <lambdabot> Title: IOIntro Actions - HaskellWiki
23:24:28 <DannoHung> But that's like.. an identity monad for that particular type of monad, right?
23:24:40 <newsham> do you mean "return" ?
23:24:49 <uccus> that's like a simple converter
23:24:57 <uccus> a packager
23:25:09 <newsham> "return" takes a normal value and makes an action that has that value as its result.
23:25:13 <goltrpoat> i think danno means the identity for that particular monad, but i don't think that works
23:25:22 <newsham> ie "return 0 :: IO Int" makes an IO action that results in the int 0.
23:25:25 <allbery_b> uccus: text window?  there are relatively few good ones for windows, because windows is so graphics-oriented to start with.  in particular the few cvurses-like interfaces for windows are generallyy rather buggy ports of Unix curses, and usually mishandle the many differences between Windows "console mode" and Unix ttys/ptys
23:25:35 <DannoHung> It packages a plain value and turns it into a monad for the particular concern
23:25:39 <uccus> example: return 1 in the list monad gives you [1] (not an idenity)
23:25:59 <allbery_b> and nobody's really interested in fixing them because it's easier to just switch to a graphical U
23:26:01 <allbery_b> UI
23:26:08 <newsham> danno: take a look at the IOIntro_Actions.
23:26:29 <DannoHung> uccus: Yeah, sorry, the Neighborhood of Infinity article was talking about them as if they were like Monadic Identity Functions
23:27:06 <newsham> danno: its not too far off the mark.. they take some non-monadic value (ie "3") and build a monadic "action" that has that as its result .
23:27:12 <uccus> return is *somewhat* like an identity... it wraps a single value into monad
23:27:15 <allbery_b> in a sense, return is an identity function.  it produces wha t you fed it trivially wrapped in the monad
23:28:02 <goltrpoat> that's what i meant by identity earlier, allbery.  the only other identity i can think of, requires monads with plus.
23:28:09 <uccus> danno I'm sorry I guess the terms we are using are familiar to us but not to you. go on. ask more specific yes/no questions.
23:28:16 <newsham> here's an example.    (Maybe Int) is a monad.   "return 3" returns an "action" in tihs monad that is "Just 3"
23:28:18 <goltrpoat> (other than the identity monad, itself)
23:28:21 <newsham> > return 3 :: Maybe Int
23:28:23 <lambdabot>  Just 3
23:28:35 <DannoHung> I'm getting return.  It's bind I'm a little confused about
23:28:48 <allbery_b> ?src Maybe (>>=)
23:28:48 <lambdabot> (Just x) >>= k      = k x
23:28:49 <lambdabot> Nothing  >>= _      = Nothing
23:28:55 <uccus> bind confuses *everyone*. it's a good sign.
23:28:55 <newsham> I personally think beginners can more easily understand "do" blocks than "bind"
23:29:10 <newsham> a do-block is simply a mechanism for combining two or more actions into one big action
23:29:27 <newsham> ie:  do { print "hello"; print "I can see my house from here" }
23:29:28 <DannoHung> I'm interested in Haskell for the mind expanding properties, not necessarily making it all work right away.
23:29:37 <allbery_b> so if you bind Just something, something is passed to the bound function; if you bind Nothing, it just passes on Nothing
23:29:38 <newsham> print "hello"   is one IO action
23:29:43 <goltrpoat> i think do blocks are dangerous as the first introduction.
23:29:44 <newsham> print "I can see..."   is another IO action
23:29:58 <newsham> and the whole do-block is a single IO action made up of both
23:30:09 <uccus> newsham: do blocks (as a newbie, I find) are horribly hard to understand. think of do x <- xs; y <- ys; return (x+y)
23:30:18 <newsham> golt: I disagree.  do-block is no more dangerous than "let" for binding variable.s
23:30:24 <mauke> I think >>= is easier to understand first
23:30:28 <newsham> you can bind variables with lambdas if you are demented, but you need not.
23:30:34 <mauke> you can always introduce do-blocks later as syntactic sugar
23:30:44 <allbery_b> and that gives you the useful property that you can do a complex calculation in Maybe, and at any point "abort" it by producing a Nothing instead of returning a value --- which will be short-cirtcuited through the rest of the calculation
23:30:59 <newsham> and you can always introduce >>= later as a degenerate two-action do-block.
23:31:04 <goltrpoat> newsham:  it creates too many false parallels to imperative code
23:31:11 <newsham> no it doesnt.
23:31:14 <DannoHung> Can you guys show me an example with random?
23:31:24 <newsham> a do-block isnt imperative.  its something that combines.
23:31:31 <goltrpoat> newsham:  it doesn't to you.  it does to newbies with an imperative background.
23:31:40 <newsham> golt: i'm from the imperative world.
23:31:40 <DannoHung> In the non-block form?
23:31:44 <allbery_b> newsham: a do-block *looks* imperative to someone unfamiliar with Haskell
23:32:00 <uccus> newsham: point taken. but for a newbie, it's harder to decipher into succeesive binds.
23:32:13 <newsham> uccus: as it should be, binds are harder to comprehend.
23:32:20 <allbery_b> that's not necessarily a good thing to someone trying to understand it; it leads to false assumtpions about what's going on that just lead to confusion
23:32:34 <newsham> allbery: only if false statements are made.
23:32:44 <goltrpoat> or false conjectures.
23:33:20 <uccus> newsham: when I read a text, I see what is said there. much surprise wait for me when I later find out what *wasn't* said.
23:33:25 <newsham> if you clearly state that a do-block combines actions with particular rules (ie. in the IO monad, the rule is sequential execution with prior state changes visible in the environment of later actions) then its clearly and well defined
23:33:26 <mauke> newsham: not really
23:33:31 <DannoHung> Here, something like this: return 7 >>= (\x -> Writer (x+1,"inc."))
23:33:33 <allbery_b> mst newcomers bring a lot ofo procedural baggage with them and will automatically try to fit do-blocks into that mode --- and the structue of do-blcks has the unfortunate effect of supporting them
23:33:50 <allbery_b> right up until something "weird" happens because a do-blocks isn't really a procedural construct
23:34:02 <DannoHung> Does binding the IOMonad[7] to that block mean that the x parameter has an unwrapped 7 value?
23:34:08 <allbery_b> even though to them it sure as heck looks like one
23:34:15 <newsham> allbery: i disagree.  do-blocks have the fortunate advantage of connecting with existing intuitions.
23:34:16 <uccus> danno: yes
23:34:18 <goltrpoat> newsham:  you're bound to try and figure things out on your own when you start out.  i was lucky and had no particular issues with the notation -- it appears that neither did you.  a friend of mine had a lot of problems with writing what looked like an attempt at translating imperative code into do notation though, and it was seriously unpretty.
23:34:34 <DannoHung> uccus: Then how does the stream that's part of the IOMonad get into the Writer function?
23:34:45 <allbery_b> newsham: except those existing intuitions are *wronmg* for Haskell.
23:34:48 <mauke> wait, there's a stream in IO?
23:34:59 <allbery_b> supporting them is a mistake
23:35:05 <newsham> allbery: for the most part most of the intuitions are correct.
23:35:24 <newsham> people who introduce bind first are confusing people with a lot of information that is not necessary to form intuitions
23:35:37 <allbery_b> er, no.  except in a limited way for IO, and even there they break down if you lok at them funny
23:35:52 <newsham> the truth is you can teach someone how to use do-blocks and IO actions relatively quickly without ever introducing them to bind
23:35:58 <uccus> danno: I'm a newbie like you. and yes, I too think you are confusing related but not identical things.
23:36:01 <goltrpoat> do blocks connect with existing intuition VERY, VERY, BADLY, that's the point, heh.  "return" does not do what you think it does as a C programmer.  in fact, it has nothing in common with the return keyword in C.  not just that, but you can get bitten, quite severely, by assuming that there is a correspondence.
23:36:31 <newsham> golt: thats because of unfortunate naming, and any good text will point out that "return" IS NOT a control flow statement
23:36:39 <newsham> and not related to "return" in an imperative language
23:36:58 <mauke> newsham: you can teach someone how haskell's IO system works without ever introducing monads, which is a much better idea IMHO
23:37:02 <newsham> that issue is completely independant of teaching do-notation.
23:37:10 <goltrpoat> so it translates into existing intuition, except for the syntax?
23:37:20 <allbery_b> so?  your clam is that do-blocks link up with existing knowledge.  yet right off the bat, yu need to warn that what looks familiar very much isn't.  (return)
23:37:23 <newsham> golt: you're being silly.
23:37:38 <newsham> allbery: yes.  that is my claim.
23:37:48 <newsham> and yes.  return needs to be warned about.
23:38:01 <newsham> and more to the point, return needs to be pointed out *reguardless* of how monads are taught
23:38:08 <uccus> goltrpoat: not, it looks like it feels like your existing intuition and translates into something completely different.
23:38:09 <allbery_b> so suddently it's *not* what is familiar, there's this strange "return" that isn't really a "return? even though it looks like one
23:38:11 <newsham> you are trying to link it to do-notation and it is an orthogonal issue
23:38:21 <goltrpoat> but, without do notation, it's a lot more obvious that return may not do what you might think it does.
23:38:28 <newsham> wha?  it is?
23:38:34 <goltrpoat> that was the point -- the do notation hides a lot of details that you may need to be aware of when starting out.
23:38:45 <goltrpoat> of course it is.
23:39:12 <uccus> > do x <- [1, 2]; y <- [3, 4]; return (x + y)
23:39:14 <lambdabot>  [4,5,5,6]
23:39:38 <newsham> Here's a very important point that many beginners get confused about: "return" does not affect the control flow of the program! Return does not break the execution of the do-block. Return may occasionally be used in the middle of a do-block where it doesn't directly contribute to the result of the do-block. Return is simply a function that makes an action whose result is a particular value. In a sense it wraps up a value into an action.
23:39:55 <allbery_b> exactly
23:40:06 <allbery_b> which compltely defeats the "do-blocks are something fasmiliar"
23:40:19 <allbery_b> because there's this return in them that *isn't*
23:40:19 <goltrpoat> you don't see how that's easier to internalize when it's explicitly written as a term in an expression?
23:40:20 <newsham> so that was 1 very small paragraph.  can we dismiss your objection now?
23:40:28 <kosmikus> newsham: something you have to explain in any case, whether you use do-notation or not. and the confusion about the name "return" arises even if you use >>= instead of do ...
23:40:31 <mauke> to understand do notation, you need to understand how it combines values
23:40:37 <newsham> golt: no.  its exactly the same no matter how "return" is introduced.
23:40:45 <goltrpoat> hmm.
23:40:47 <newsham> here's a proof:  I learned monads through bind.  I had the same issue with return.
23:40:50 <newsham> qed.
23:40:53 <mauke> combining values is easier to understand if it looks like function calls
23:40:56 <DannoHung> uccus: In that example, what's getting put into x?
23:41:01 <newsham> mauke: i disagree.
23:41:07 <goltrpoat> newsham:  that may be a personal preference then.
23:41:13 <mauke> newsham: here's a proof: it worked for me
23:41:15 <uccus> newsham: see? danno's question?
23:41:16 <DannoHung> Or, assigned to or letted, or whatever the proper terminology is
23:41:21 <newsham> I think this is a fundamental problem with haskell education.
23:41:29 <newsham> people are being taught monads wrong.  and they run away.
23:41:39 <uccus> newsham is right. there is something wrong.
23:41:57 <goltrpoat> if we're going to start resorting to the "it worked for me!" argument, i think we could gather enough folk in here to cover both ends of every possible spectrum on every possible argument of this sort :)
23:42:12 <uccus> danno: read it as... for *each* x in the list, do the following...
23:42:18 <newsham> you can teach someone how to write a networking daemon in haskell in 1hr without ever mentioning "monad" or (>>=)
23:42:38 <DannoHung> I understand what return is doing in uccus' example, it's wrapping the results of (x+y) in the list block
23:42:43 <newsham> but everyone insists on teaching an abstract concept with awkward notation without concrete examles.
23:42:48 <mauke> newsham: not me
23:42:58 <goltrpoat> i love concrete examples.
23:43:06 <DannoHung> Ohhh!  I didn't even see lambdabot's answer
23:43:15 <newsham> > do x <- [1, 2]; y <- [3, 4]; return (x + y)
23:43:17 <lambdabot>  [4,5,5,6]
23:43:17 <mauke> I'd rather teach exactly how IO can work in a pure language, without ever mentioning monads
23:43:18 <goltrpoat> i just don't believe in hiding details from the get go, and hoping that the person eventually figures it out for themselves.
23:43:26 <DannoHung> s/block/monad/
23:43:32 <newsham> danno:  that has 3 List "actions" which are combined into one large list action
23:43:41 <uccus> yes, so, for each x in the first list and for each y in the second list, to add them, now, even after return, you can do things.
23:43:48 <newsham> the first action is "[1, 2]" whose result is bound to "x"
23:43:58 <newsham> the second action is "[3, 4]" whose resul tis bound to "y"
23:44:09 <zarvok> goltrpoat: so instead of teaching arithmetic in grade school we should teach abstract algebra?
23:44:13 <newsham> and the third action is "return (x+y)" whose result becomes the result of the entire do-block.
23:44:24 <DannoHung> Is [1, 2] a monad in and of itself?
23:44:42 <kosmikus> zarvok: now that's a good idea
23:44:44 <goltrpoat> zarvok:  bad analogy.  a better one would be "so instead of handing out calculators in grade school, we should teach long division."
23:44:45 <uccus> but you can do things after the return! somebody give me as example.
23:44:48 <goltrpoat> in which case, the answer is yes.
23:44:52 <mauke> DannoHung: it's a monadic value
23:45:15 <newsham> in do-blocks for the list-monad (the monad being used here) the rule is that two actions are combined in this way:  the first action results in each value from the list, in turn, and the next actions are executed with that value
23:45:16 <DannoHung> ... a value wrapped in a monad?
23:45:18 <uccus> ?src [] (>>=)
23:45:19 <lambdabot> m >>= k     = foldr ((++) . k) [] m
23:45:35 <uccus> ?src concatMap
23:45:36 <zarvok> goltrpoat: I'm not convinced.  Learning an algorithm to perform a procedure is different than learning why the algorithm works, which seemed to be what you wanted
23:45:36 <lambdabot> concatMap f = foldr ((++) . f) []
23:45:39 <newsham> so that   do { x <- [1, 2]; <something> }   runs "something" once with x set to 1 an donce with x set to 2.
23:46:09 <newsham> so the block:   do { x <- [1, 2]; y <- [3, 4]; <something> }  runs <something once with x set to 1 and y set to 3
23:46:13 <newsham> then once with x set to 1 and y set to 4
23:46:21 <newsham> then once with x,y = 2,3 and  x,y = 2,4
23:46:23 <uccus> newsham is going deep and will soon discover how a newbie react to that. danno, keep ur questions coming!
23:46:41 <goltrpoat> zarvok:  i think the grade school analogy, while rather popular, is broken in the sense that 6 year olds are, generally, not particularly interested in the things we're interested in.  we're talking about a large group of people with approximately the same goals.
23:46:59 <newsham> the rule for combining actions is the "bind" thing that they keep talking about.
23:47:18 <uccus> see, bind is concatMap for lists
23:47:37 <DannoHung> Okay, the bind in the List Monad case is a recursive operation.
23:47:40 <zarvok> goltrpoat: I don't believe every person who learns haskell has the same goals.  Some find functional languages convenient, others are interested in the underlying theory.  I see no problem with providing appropriate approaches for each group
23:47:49 <uccus> not recursive!
23:47:49 <newsham> for lists the rule t ocombine two action is:   for each value contained in the first action, do the second action, then collect all of the results together in a list.
23:47:55 <uccus> it's a concatMap
23:48:06 <DannoHung> Iterative through tail optimization?
23:48:24 <newsham> danno: doesnt matter..  thats hidden implementation detail.
23:48:28 <newsham> the end result is what is important.
23:48:57 <goltrpoat> zarvok:  unlike 6 year olds, newcomers to haskell will, eventually, need to learn what monads are, how they work, how they are used, what capacities they are used in, and why they are used in those capacities
23:48:57 <newsham> > do { x <- [1, 2, 3]; return (x * 2) }
23:48:59 <lambdabot>  [2,4,6]
23:49:13 <newsham> the first "return (x * 2)" becomes  "return 2" which becomes [2]
23:49:24 <newsham> the second "return (x * 2)" becomes "return 4" which becomes [4]
23:49:41 <goltrpoat> zarvok:  it seems to me that there's no good reason to delay that information by sweeping the obvious questions that people might have, under the carpet.
23:49:41 <newsham> an dthe last becomes [6].   these are collected [[2], [4], [6]] into one list [2, 4, 6]
23:49:46 <uccus> and then we concatenate them!
23:50:07 <mauke> bind = map + join :-)
23:50:08 <uccus> :type (>>=)
23:50:17 <newsham> thats the rule for combinging two list actions.  for more actions its just more of the same (think of using the combination in a nested fashion)
23:50:19 <DannoHung> In this case anyway
23:50:30 <uccus> ?type (>>=)
23:50:32 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
23:50:48 <newsham> > do { x <- [1, 2, 3]; y <- [10, 100]; return (x*y) }
23:50:50 <lambdabot>  [10,100,20,200,30,300]
23:50:53 <mauke> > join (fmap (\x -> return (x * 2)) [1, 2, 3])
23:50:54 <lambdabot>  [2,4,6]
23:51:25 <newsham> there's another monad similar to the list called Maybe.  Maybe Int can be either (Just Int) or Nothing.
23:51:32 <zarvok> goltrpoat: I don't disagree that everyone will need it eventually if they continue coding in haskell, it just seems to me that some people will have an easier time digesting it in parts, slowly adding more layers of theory or abstraction.  Perhaps on this point we'll just have to agree to disagree
23:51:44 <newsham> the rule for combining Maybe's is that if the first action is Nothing, the combined action is Nothing
23:51:59 <DannoHung> What's the wiki page for the random monad?
23:52:08 <newsham> if the first action's result is (Just x) then the second action is executed with the value of x.
23:52:38 <newsham> > do { x <- Just 3; return (x + 1) }
23:52:40 <lambdabot>  Just 4
23:52:46 <newsham> > do { x <- Nothing; return (x + 1) }
23:52:48 <lambdabot>  Nothing
23:53:26 <newsham> this is useful if you have a computation that can succeed with a value (ie '4') or fail (Nothing) because something went wrong.
23:53:29 <DannoHung> I think I'm like a hair's breadth away from groking this right now...
23:53:37 <newsham> like parsing a string into an integer could either give you an integer or a parse error.
23:53:41 <DannoHung> The Maybe one seems very natural
23:53:56 <newsham> but once you failed, you dont want to bother doing any of the other actions.
23:54:05 <DannoHung> Right.
23:54:20 <newsham> so like:    do { x <- parseInteger str1; y <- parseInteger str2; return (x + y) }
23:54:23 <DannoHung> A more intelligent way of handling exceptional states, to say the least.
23:54:31 <mauke> DannoHung: ding! you win
23:54:36 <newsham> would be a single Maybe-action that returns the sum of two values from two strings
23:54:47 <goltrpoat> zarvok:  i learned monads from hutton and meijer, because i had a specific project in mind.  it's probably way overkill as an introductory paper, but i still recommend it in that capacity
23:54:49 <newsham> but if str1 wasnt in the right format, it will return Nothing
23:54:55 <newsham> or if str2 wasnt in the right format, it will return Nothing
23:55:07 <dons> re
23:55:23 <newsham> so  parseInteger "1"  would return    Just 1,   but parseInteger "foo" would return Nothing
23:55:31 <goltrpoat> zarvok:  learning it that way, i really had no particular need to learn one notation before the other, since i had to get a certain feel for the motivation, first.
23:55:39 <goltrpoat> i think that's the best way to teach that subject, personally.
23:56:11 <newsham> if you prefer, you can think of the    do { var <- act1; act2expr }   as   act1 >>= (\var -> act2expr)
23:56:22 <newsham> they're more or less the same thing (modulo some other do-features that you can use)
23:56:40 <zarvok> goltrpoat: I guess I just think that you need to consider your audience before deciding what is the "best way" to teach something.
23:56:45 <newsham> its a combination of act1 and act2expr while binding the result of act1 to var
23:57:04 <uccus> see? it's difficult to explain without bind
23:57:07 <DannoHung> Would it be a pain to ask you guys to show me a Random example?  I'm still a little hung up about the situation where the Monad Accepting Function wants to deal explicitly with both parts of data inside the monadic value
23:57:23 <newsham> uccus: i'm explaining bind to make others here happy.  i could personally do without it :)
23:57:23 <Korollary> @google all about monads
23:57:28 <lambdabot> http://www.nomaware.com/monads/
23:57:32 <goltrpoat> zarvok:  true.  are you saying introducing the do notation without introducing the underlying machinery makes it easier in the long run though?  that's the part i disagree with.
23:57:48 <newsham> ?hoogle randomIO
23:57:49 <lambdabot> Random.randomIO :: Random a => IO a
23:58:01 <newsham> do { x <- randomIO; return (x + 1) }
23:58:05 <newsham> in the IO monad.
23:58:15 <goltrpoat> the underlying machinery is not THAT complex.  all the "newness" aside, it's quite elegant and useful.
23:59:02 <newsham> golt: given that the bind notation is equivalent to a 2-action do-block i'm not sure I understand whats so great about mentioning it.
23:59:14 <newsham> (its useful to know the name when you want to define your own monad... but that comes later)
23:59:26 <uccus> the only thing that confused me was that there might be different monad in sight, which am I doing the bind for :s
23:59:33 <zarvok> goltrpoat: I don't know precisely what "easier in the long run" means.  I think there are people who are unable or unwilling to get over the steeper learning curve associated with that approach, particularly some of those without a math or FP background.  But perhaps we've argued this point enough
23:59:46 <newsham> its like saying   "if you want to bind x to 3 in an expression do   (\x -> expr) 3"
23:59:50 <goltrpoat> well, it's useful to know more than just the name when you want to define your own monad
23:59:50 <mauke> newsham: x >>= y is easier than do { tmp <- x; y tmp }
23:59:57 <newsham> "because using "let" will give false intuition"
