00:00:05 <allbery_b> there are arrays, which have different behaviors (for ne, they're fixed length)
00:00:07 <tphyahoo> modius: build yourself a scheme in 48 hours, easy to find on google.
00:00:19 <tphyahoo> (you build it with haskell) :)
00:00:29 <Modius> Could build scheme even faster in lisp :)
00:00:38 <allbery_b> ?src when
00:00:39 <lambdabot> when p s = if p then s else return ()
00:00:45 <nmessenger> Liskell is being developed by someone in channel.  It's not very googleable since it's unreleased.
00:00:50 <Modius> Meant the other way around - to somehow interchange data easily between a common lisp implementation and a haskell
00:01:13 <Modius> There's QI but its portability seems to bite - and it isn't strictly functional.
00:01:24 <Modius> (It claims strength in its typing/pattern matching, not in statelessness)
00:01:33 <sieni> hey, liskell sounds cool
00:01:36 <Modius> (That is, if I understand it right as I don't claim to)
00:01:46 <sieni> haskell with tolerable syntax sounds really nice <3
00:01:56 <nmessenger> Haskell isn't 'strictly' functional either, it's 'lazily' functional  :P
00:02:02 <Korollary> Haskell - CL bindings are possible, but that would make one odd beast.
00:02:59 <nmessenger> buh-dum-pssh
00:03:10 <Modius> It would be really nice to, from CL, be able to make easy calls into it and have the "results" of functional calls be transformed
00:03:55 <nmessenger> "tolerable" syntax is just a smidge subjective
00:04:25 <Korollary> Typically you make an interface to another language because you want to be able to use its libraries, like C. Neither Haskell nor Lisp is a big library target. Java makes more sense if you're after someone else's code in another language.
00:04:38 <tphyahoo>  re incorrect documentation in zvon: I guess to be an array in yaskell you need to be constructed like...
00:04:46 <tphyahoo> > array (1,3)
00:04:47 <lambdabot>  Add a type signature
00:05:06 <Modius> Typically maybe - but in the middle of a program in language X (using language X for some reason), being able to shoot inputs into a complex haskell function may be useful.
00:05:10 <tphyahoo> anyway, square brackets always mean cons. ok.
00:05:11 <nmessenger> > array [1,3]
00:05:12 <lambdabot>  Couldn't match `(i, i)' against `[a]'
00:05:26 <nmessenger> > listArray [1,3]
00:05:27 <lambdabot>  Couldn't match `(i, i)' against `[a]'
00:05:30 <allbery_b> > array (1, 3 :: Int)
00:05:31 <lambdabot>  Add a type signature
00:05:31 <nmessenger> blah
00:05:50 <allbery_b> > array (1, 3) :: Array Int
00:05:51 <lambdabot>      `Array Int' is not applied to enough type arguments
00:05:51 <lambdabot>     Expected kind `?...
00:05:56 <allbery_b> hm
00:05:57 <Korollary> You made the same argument. In that case, you're after a haskell library function.
00:06:00 <Ytinasni> > listArray (1,3) [1..]
00:06:02 <lambdabot>  array (1,3) [(1,1),(2,2),(3,3)]
00:06:03 * allbery_b doesn't actually use arrays much :)
00:06:07 <allbery_b> ah
00:06:28 * nmessenger used an array to implement a 15-piece slider puzzle thingy.
00:06:34 <Ytinasni> where (1,3) are the list bounds, and [1..] is the data in the list :)
00:07:11 <arv> That was great, but I now have another error :) -- Empty module to serve as the default current module.
00:07:12 <arv> module Hugs where
00:07:12 <arv> import List (nub)
00:07:12 <arv> default (Int)
00:07:12 <arv> -- import Data.Char
00:07:12 <arv> type Addr = (Int, Int)
00:07:14 <arv> data Range = AddrRange Addr Addr |
00:07:16 <Modius> Perhaps; but I'd like to be able to stick "haskell library functions" all over the place.
00:07:18 <arv>   ExprSeq ExprS
00:07:18 <arv> data Expr = Lit Int |
00:07:24 <nmessenger> > fromList [(0,'f'),(1,'o'),(2,'o')] :: Array Char
00:07:25 <arv>   Plus Expr Expr |
00:07:25 <lambdabot>   Not in scope: `fromList'
00:07:29 <Modius> And have "inline" haskell library functions all over the place.
00:07:29 <arv>   Sum Range |
00:07:39 <arv>   Ref Addr
00:07:40 <arv> data ExprS = Expr1 Expr |
00:07:46 <arv>   Seq ExprS
00:07:46 <arv> type Cell = (Addr, Expr)
00:07:46 <arv> type Sheet = [Cell]
00:07:46 <arv> s :: Sheet
00:07:46 <arv> s = [ ((1,1) , Lit 3) ,
00:07:51 <allbery_b> ?paste -- arv, please use this
00:07:52 <lambdabot> http://paste.lisp.org/new/haskell
00:07:56 <allbery_b> oops
00:08:12 <Ytinasni> ?paste
00:08:12 <lambdabot> http://paste.lisp.org/new/haskell
00:08:17 <Ytinasni> :)
00:08:18 <arv> Sorry about the flood. Pasted the code instead of URL :(
00:08:39 <tphyahoo> I pasted something like two pages into another #room a few days ago. felt physically sick :)
00:08:54 <nmessenger> #CHANNEL YOU BLASPHEMER!
00:09:03 <tphyahoo> I mean #channel!
00:09:14 <nmessenger> ;P
00:09:21 <allbery_b> various clients can be made to block acidental pastes, I don't know details though
00:09:34 <nmessenger> anyway, url?
00:09:35 <arv> Sigh. I feel sick now :) It's been ages since I came on IRC. Back to programming, that too in a totally new language and IRC seems to be the best place to learn.
00:09:47 <arv> http://devforge.net:8080/arv/haskell.hs
00:09:50 <arv> Thanks :)
00:10:27 <Ytinasni> you probably need to make  `Ref (1,1)` into  `(Ref (1,1))`
00:10:32 <arv> The error seems to be on the last meaningful line.. whre I use the "Plus" constructor
00:10:36 <allbery_b> I think I'd prefer you use theregular pastebot since yours forces my browser to download your code
00:10:39 <nmessenger> Cell's have Expr's in their second slot, you need more 'Litr's  -.-;;
00:10:41 <arv> oh..
00:10:44 <allbery_b> ?paste
00:10:45 <lambdabot> http://paste.lisp.org/new/haskell
00:10:54 <arv> sorry, I would do that now.
00:11:05 <allbery_b> "can't handle document of type text/x-haskell"
00:11:16 <nmessenger> wait, those are Addr's, nevermind
00:11:47 <lisppaste2> arv pasted "Beginning to learn" at http://paste.lisp.org/display/35562
00:11:59 <allbery_b> if I could convince mozilla t just shwo it in place...
00:12:10 <arv> heh :)
00:12:17 <arv> Nice bot you guys have.
00:12:19 <allbery_b> you need parens
00:12:43 <Korollary> ?vixen do you think I can sleep if I try now?
00:12:43 <lambdabot> <undefined>
00:12:45 <allbery_b> Plus (Ref (1,1)) (Ref (1,2))
00:12:51 <Korollary> hopeless huh
00:12:59 <allbery_b> dons has been busy
00:12:59 <Ytinasni> Korollary: vixen hasnt been fixed yet
00:13:05 <arv> parens as in () stuff? But arent those only needed for generating ruples?
00:13:06 <allbery_b> he's at a conference
00:13:08 <nmessenger> Plus thinks it's getting four args: Ref, (1,1), Ref, and (1,2)
00:13:26 <arv> s/ruples/tuples
00:13:37 <arv> Oh...
00:13:44 <allbery_b> it is perfectly possible to pass a function as an argument in Haskell, and Ref is a function (a "type constructor")
00:13:57 <Korollary> a type constructor is not a function
00:13:58 <allbery_b> so unless you use parentheses, t passes the function Ref
00:14:05 <nmessenger> er, value constructor, (type constructors are different)
00:14:13 <allbery_b> sorry, yes, value constructor
00:14:21 * allbery_b still a little fuzzybrained, darnit
00:14:38 <arv> nice... thanks :) I will try that one now. And by the way.. any good place for me to get started? I am just trying things at random :) And that "report" page
00:14:38 * nmessenger makes dumb mistakes like that far too often
00:14:47 <allbery_b> ?where yaht
00:14:48 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:14:55 <Korollary> ?where metatutorial
00:14:56 <lambdabot> I know nothing about metatutorial.
00:14:58 <allbery_b> "yet another haskell tutorial"
00:15:11 <Korollary> @google haskell wiki metatutorial
00:15:13 <lambdabot> http://koweycode.blogspot.com/2006/12/haskell-metatutorial.html
00:15:13 <lambdabot> Title: koweycode: the Haskell metatutorial
00:15:32 <Korollary> it's strange that that's the first hit.
00:15:36 <arv> Excellent!
00:15:47 <arv> Thanks a lot guys :)
00:15:52 <nmessenger> haskell.org <- see 'Haskell in 5 steps', then 'Learning Haskell'
00:15:57 <allbery_b> passing functions:
00:15:58 <arv> Oh...
00:16:09 <allbery_b> > map (1+) [1..5]
00:16:10 <lambdabot>  [2,3,4,5,6]
00:16:23 <Korollary> ?users
00:16:23 <lambdabot> Maximum users seen in #haskell: 311, currently: 274 (88.1%), active: 18 (6.6%)
00:16:30 <nmessenger> > map Just [1..3]
00:16:32 <lambdabot>  [Just 1,Just 2,Just 3]
00:16:35 <allbery_b> the (1+) is a section, or a partially applied function; in this case (+)
00:17:03 <nmessenger> 'Just' is a data constructor like your 'Ref'
00:17:28 <nmessenger> given an Int, it constructs a Maybe Int
00:17:44 <arv> hmm.
00:18:15 <allbery_b> :t Just
00:18:16 <lambdabot> forall a. a -> Maybe a
00:18:33 <nmessenger> No worries, just work slowly through YAHT, you'll get there ;-)
00:18:47 <allbery_b> Maybe can wrap any type, producing a type whose values are optional:  either Just something, or Nothing
00:19:19 <nmessenger> @type [Just 1, Nothing, Just 5, Just -3, Nothing]
00:19:20 <lambdabot>     Couldn't match `Maybe a' against `a1 -> Maybe a1'
00:19:20 <lambdabot>       Expected type: Maybe a
00:19:25 <nmessenger> @type [Just 1, Nothing, Just 5, Just (-3), Nothing]
00:19:26 <lambdabot> forall a. (Num a) => [Maybe a]
00:19:47 <nmessenger> a list of maybe numbers
00:20:00 <allbery_b> that's the simplest use.  you can also use it to make optional computations, where a Nothing value somewhere in a complex calulation automatically produces a result of Nothing without your needing to do any checking for it
00:20:14 <nmessenger> > Just 1 >> Just 2
00:20:15 <lambdabot>  Just 2
00:20:18 <nmessenger> > Just 1 >> Nothing
00:20:18 <lambdabot>  Add a type signature
00:20:26 <nmessenger> > Just (1::Int) >> Nothing
00:20:27 <lambdabot>  Add a type signature
00:20:31 <nmessenger> bleh
00:20:45 <nmessenger> > Just 1 >> (Nothing::Maybe Char)
00:20:46 <lambdabot>  Nothing
00:21:15 <allbery_b> > Just 1 >>= return . (+1)
00:21:17 <lambdabot>  Just 2
00:21:32 <allbery_b> > Nothing :: Maybe Int >>= return . (+1)
00:21:32 <lambdabot>  Parse error
00:21:44 <allbery_b> > (Nothing :: Maybe Int) >>= return . (+1)
00:21:45 <lambdabot>  Nothing
00:21:46 <nmessenger> > catMaybes [Just 1, Nothing, Just 5, Just (-3), Nothing]
00:21:47 <lambdabot>  [1,5,-3]
00:22:08 <allbery_b> (there is syntactic sugar for the >>=, so you can do that more cleanly)
00:22:33 <nmessenger> (the type sigs would usually be unnecessary in your code, since it would be inferred from context)
00:22:59 <allbery_b> > let inc l = do { x <- l; return (x + 1) } in inc (Just 5)
00:23:00 <lambdabot>  Just 6
00:23:07 <allbery_b> > let inc l = do { x <- l; return (x + 1) } in inc Nothing
00:23:08 <lambdabot>  Nothing
00:24:21 <nmessenger> methinks we scared off arv
00:24:38 <allbery_b> or overloaded him(?)
00:24:50 <nmessenger> BRAIN SPLODEY!
00:25:52 <nmessenger> Brain explosion is like a traditional pasttime in #haskell
00:26:38 <allbery_b> you will note that I did that without ever mentining he dread "M word" :)
00:26:53 <nmessenger> aye, duly noted
00:27:48 <nmessenger> "WarmFuzzyThing's like Maybe have two operations defined for them: bind and return"
00:28:43 * Baughn notes that tigers are, in fact, warm and fuzzy
00:31:00 * nmessenger notes that tigers are also very powerful
00:31:21 * Ytinasni notes that `tiger` is not a M-word :)
00:32:00 * Baughn decides to rename the M-word to WarmFuzzyTiger
00:36:40 * nmessenger nominates Baughn for principal author of Haskell Prime
01:10:57 <lisppaste2> arv pasted "This is getting interesting." at http://paste.lisp.org/display/35565
01:11:27 <arv> Can anyone spot any obvious errors?
01:12:15 <arv> The error seems to occur for the tuple containing "addr" value (2,2)
01:13:02 <arv> Or am I making it too complex :)
01:17:14 <pierre-> hello. Can i compile x86 binaries on my x86_64 ghc?
01:18:55 <ibid> i do't think so
01:19:10 <ibid> but you could install a 32-bit chroot and compile there
01:19:18 <ibid> (if on *nix)
01:20:09 <bakert> Anyone know how to tell cabal to build binaries to a different location than dist/build/blah/blah
01:20:10 <bakert> ??
01:40:53 <dons> moin
01:44:27 <Vq^> hello dons
01:53:48 <musasabi> glguy: for text/plain use "plain" from SimpleHTTP2
01:55:32 <bakert> Anyone know how to tell cabal where to put the binaries in a "build"?
01:55:52 <bakert> the docs mention a --scratchdir param but that doesn't work for me
01:56:03 <bakert> ?users
01:56:04 <lambdabot> Maximum users seen in #haskell: 311, currently: 286 (92.0%), active: 25 (8.7%)
01:56:13 <bakert> ?seen
01:56:14 <lambdabot> Lately, I have seen bakert, digitalice, gly, musasabi, ohmega, vq^ and xif.
01:56:30 <bakert> ?seen dons
01:56:30 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 15m 36s ago.
01:57:21 * mq_mattr tries something
01:57:25 <mq_mattr> and it works
01:57:28 <mq_mattr> :)
01:57:52 <Vq^> mq_mattr: congratulations
01:58:16 <mq_mattr> thankyou - I owe it all to google
01:58:28 <dons> bakert:  -b /usr/obj/cabal
01:58:30 <dons> for example
01:59:12 <mq_mattr> @localtime dons
01:59:14 <lambdabot> Local time for dons is Thu Jan 18 20:56:41 2007
01:59:23 <mq_mattr> dons: welcome back
02:00:03 <dons> not back yet...
02:00:03 <dons> sitting in popl
02:00:17 <mq_mattr> oh - cool
02:00:20 <dons> Ralf's (next) SYB paper just got presented
02:00:33 <mq_mattr> damn - it looks good too
02:00:47 <mq_mattr> I really like Ralf - he is quite entertaining
02:00:54 <dons> very
02:00:58 <dons> ?users
02:00:58 <lambdabot> Maximum users seen in #haskell: 311, currently: 287 (92.3%), active: 26 (9.1%)
02:01:52 <mq_mattr> at a summer school on generic programming he arrived on the first day in a microsoft t-shirt.  Apparently he got some comments about it, so the second day he wore an east german communist youth t-shirt to balance it out :)
02:03:02 <Eelis> who is this Hero Ralf ?
02:03:25 <mq_mattr> http://homepages.cwi.nl/~ralf/
02:03:27 <lambdabot> Title: Ralf L&auml;mmel
02:03:30 <Eelis> thank you.
02:09:22 <dons> mq_mattr: hehe
02:09:31 <dons> yeah, he's got quite a dark sense of humour
02:09:34 <dons> funny guy
02:11:04 <mq_mattr> dons: he is also quite good humoured about people making silly snide comments about microsoft.  I don't think I would have his patience in many cases
02:11:42 * mq_mattr watching google hackathon videos
02:12:03 * mq_mattr wondering if there will be hc 07 videos (surely not :))
02:12:26 <mq_mattr> s/hc/hac
02:13:02 <dons> yeah, no videos
02:13:07 <dons> the photos are on planet.haskell
02:13:42 <mq_mattr> dons: it looks like it was lots of fun.  I am exceedingly jealous of you and Ben ho managed to get over from OZ.
02:13:50 <dons> hehe
02:13:53 <dons> yeah, that was good
02:13:53 <mq_mattr> dons: do you know if ben is at POPL as well?
02:13:58 <dons> he is
02:14:11 <mq_mattr> I am literally green
02:14:20 <bakert> dons, thanks for the cabal switch for building in a different place.  it still builds projectname/executablename under there.  is it possible to tell it just to put the executable in that dir?  thanks.
02:14:25 <mq_mattr> ok - not literally :)
02:14:32 <dons> bakert: --bindir
02:14:38 <bakert> dons, thanks
02:14:51 <bakert> i thought that was for "install".  doh.
02:16:18 <diogo> dons: you are from UM?
02:17:00 <dons> diogo: nope
02:17:28 <diogo> ok
02:18:24 <mq_mattr> dons: did you see any of the "pun title" papers?
02:18:51 <mq_mattr> dons: I am interested to know if the papers/presenters lived up to the title
02:20:00 <dons> "pun title"?
02:21:17 <mq_mattr> dons: A Very Modal Model of a Modern, Major, General Type System
02:21:43 <dons> ah yes
02:21:49 <dons> that was quite good actually
02:22:02 <dons> though most of the jokes were about the bad title
02:22:07 <mq_mattr> then the 100% record of pun papers is intact :)
02:22:30 <mq_mattr> in my experience only of course - I am sure you can find bad pun papers out there
02:22:31 <dons> yeah!
02:22:46 <dons> Ralf made a nice joke about the next 700 SYB papers they were going to write...
02:22:50 <Cale> You have to have a pretty good paper if you're going to go and name it something like that.
02:22:52 <bringert> haha
02:23:23 <mq_mattr> dons: the next 100 SYB papers, to go with the next 1000 programming languages :)
02:23:34 <mq_mattr> cale: I think that is how it works
02:23:34 <dons> and Phil Wadler complained that the hlist stuff made his brain hurt, so Ralf suggested making sure he had an Oleg handy
02:23:37 <Cale> Next 700 programming languages was a paper.
02:23:46 <Cale> http://www.cs.utah.edu/~wilson/compilers/old/papers/p157-landin.pdf
02:23:50 <lambdabot> http://tinyurl.com/2qxrr
02:23:58 <mq_mattr> dons: :)
02:24:14 <Cale> (specifically, the one which introduced ISWIM)
02:26:32 <Cale> hehe, 'ISWIM is thus part programming language and part program for research. A possible first step in the research program is 1700 doctoral theses called "A Correspondence between x and Church's lambda-notation"'
02:27:16 <mq_mattr> cale :)
02:27:23 <diogo> anyone here knows the StrategyLib?
02:27:49 <mq_mattr> diogo: nope
02:38:09 <Botje>  We deÔ¨Åne typical as Ô¨Åle under 20M in size. The average source Ô¨Åle in the
02:38:09 <Botje> Haskell hierarchical libraries is 10k; so, 20M is a generous limit.
02:38:12 <Botje> heh.
02:38:15 <Botje> quite generous. :)
02:38:52 <Botje> I wonder why it mangled "fi"
02:38:53 <Botje> oh well
02:39:10 <Cale> It used the ligature character for fi
02:39:36 <Cale> When typesetting fi together, they're supposed to be joined, with the top of the f extended to dot the i.
02:40:03 <Cale> There's a similar rule for fl
02:40:05 <pejo> dons, there was some proof theory in last years POPL where he said the same thing, and asked them to show it for a simpler language as well. I think it's good that he does that - if Phil Wadlers' head hurts, then so does almost everybody elses.
02:40:17 <sieni> Cale: and ffl and ffi
02:40:21 <Cale> right
02:40:39 <Cale> though those are uncommon in English
02:41:28 <sieni> shuffle, graffiti etc.
02:41:28 <tphyahoo> what is this "bot" they speak of? and can I play with it using lambdabot and ghci?
02:41:57 <tphyahoo> I mean "bot" as in undefined, error, whatever they call it.
02:42:06 <tphyahoo> not "robot" :)
02:42:15 <pejo> tphyahoo, bottom you mean?
02:42:19 <sieni> > undefined
02:42:19 <lambdabot>  Add a type signature
02:42:27 <sieni> > 1 + undefined
02:42:28 <lambdabot>  Undefined
02:42:35 <tphyahoo> sometimes written _|_ ?
02:42:37 <mq_mattr> > undefined :: Int
02:42:38 <lambdabot>  Undefined
02:42:44 <tphyahoo> or is that just math, not haskell?
02:43:00 <mq_mattr> tphyahoo: bottom == undefined
02:43:12 <tphyahoo> > bottom
02:43:13 <lambdabot>   Not in scope: `bottom'
02:43:38 <tphyahoo> > 1/0
02:43:39 <lambdabot>  Infinity
02:43:58 <bakert> dons, i think bindir _does_ refer to the "install" not the "build" step.
02:44:07 <tphyahoo> > Infinity
02:44:08 <lambdabot>   Not in scope: data constructor `Infinity'
02:44:09 <bakert> Anyone have any idea how I can get cabal to build to bin
02:44:14 <bakert> not bin/dist/packagename/
02:44:15 <bakert> ?
02:49:52 <tphyahoo> take 4 [1,2,3,4,undefined]
02:50:03 <tphyahoo> > take 4 [1,2,3,4,undefined]
02:50:04 <lambdabot>  [1,2,3,4]
02:50:09 <tphyahoo> > take 4 [1,2,3,4,'a']
02:50:10 <lambdabot>   add an instance declaration for (Num Char)
02:50:10 <lambdabot>     In the list element: 4
02:50:57 <tphyahoo> take 4 [1 1 ..]
02:51:02 <tphyahoo> > take 4 [1 1 ..]
02:51:03 <lambdabot>   add an instance declaration for (Num (t -> a))
02:51:09 <tphyahoo> > take 4 [1 ..]
02:51:10 <lambdabot>  [1,2,3,4]
02:54:06 <Jaak> > head [1,2..undefined]
02:54:07 <lambdabot>  Undefined
02:54:39 <thartman> :t [1,undefined]
02:54:40 <lambdabot> forall a. (Num a) => [a]
02:55:20 <thartman> is there a log of this channel?
02:55:48 <thartman> > undefined
02:55:48 <lambdabot>  Add a type signature
02:55:56 <resiak> thartman: /topic
02:55:58 <psnl> @logs
02:55:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
02:58:37 <thartman> :t [1,2]
02:58:39 <lambdabot> forall a. (Num a) => [a]
02:58:48 <thartman> :t [1,'a']
02:58:49 <lambdabot>     No instance for (Num Char)
02:58:49 <lambdabot>       arising from the literal `1' at <interactive>:1:1
02:59:00 <thartman> :t [1,undefined]
02:59:02 <lambdabot> forall a. (Num a) => [a]
03:00:47 <thartman> why can lambdabot type a list with undefined, but not a list where the types disagree?
03:01:14 <Jaak> :t undefined
03:01:15 <lambdabot> forall a. a
03:01:25 <Jaak> thats why
03:01:38 <thartman> :t 5
03:01:39 <lambdabot> forall t. (Num t) => t
03:01:42 <thartman> :t a
03:01:43 <lambdabot> Not in scope: `a'
03:01:46 <thartman> :t 'a'
03:01:47 <lambdabot> Char
03:02:32 <thartman> how would you read "forall a. a" out loud?
03:03:17 <Botje> "for all types a"
03:08:15 <thartman> and... "for all types t, where t is of type Num" would be "forall t. (Num t) => t" ... ?
03:09:19 <thartman> can I ask lambdabot if type Int is of type Num? actually did that question even make sense?\
03:11:17 <nornagon> > (1 :: Int) :: (Num a) => a
03:11:18 <lambdabot>   a
03:11:18 <lambdabot>       Inferred type: Int
03:11:18 <lambdabot>     In the expression: 1 :: Int
03:11:18 <lambdabot>     In the expre...
03:11:21 <nornagon> hum.
03:11:25 <nornagon> i guess not.
03:11:48 <thartman> > 1 :: Num
03:11:49 <lambdabot>      Class `Num' used as a type
03:11:49 <lambdabot>     In the type `Num'
03:11:49 <lambdabot>     In an expression ty...
03:12:26 <thartman> > 1:: (Num a) => a
03:12:27 <lambdabot>  1
03:16:00 <Jaak> in ghci you can say ":i Num"
03:16:24 <Jaak> and ":i Int"
03:17:29 <Jaak> @instances Num
03:17:30 <lambdabot> Double, Float, Int, Integer
03:17:52 <Jaak> @instances Monad
03:17:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:21:44 <thartman> is that list exhaustive? or just "let's throw some examples out"
03:22:45 <thartman> and why is ((->) r) a monad?
03:22:56 <Jaak> > join (+) 2
03:22:57 <lambdabot>  4
03:23:10 <Jaak> @src (->) (>>=)
03:23:10 <lambdabot> f >>= k = \ r -> k (f r) r
03:24:22 <thartman> :t join
03:24:23 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
03:25:01 <Jaak> > (*5) >>= (+1) $ 2
03:25:02 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
03:25:02 <lambdabot>       Expec...
03:25:10 <Jaak> oi
03:25:12 <Jaak> > (*5) >>= (+) $ 2
03:25:13 <lambdabot>  12
03:25:25 <Jaak> quite cool
03:26:29 <nornagon> ... how does that work?!
03:26:40 <thartman> my feelings exactly :)
03:28:58 <Templar2> > join (+) (2 3)   ?? how should it look like?
03:28:59 <lambdabot>  Parse error
03:29:46 <Templar2> with join
03:30:08 <Jaak> > let add x = do {f <- (+); return $ f x } in add 2 3
03:30:09 <lambdabot>  5
03:31:00 <Templar2> with join?
03:34:58 <thartman> > (*5) >>= (+) $ 3
03:34:59 <lambdabot>  18
03:35:06 <malebria> Good morning.
03:35:26 <thartman> (*5) >>= (+) $ 4
03:35:38 <thartman> > (*5) >>= (+) $ 4
03:35:40 <lambdabot>  24
03:47:22 <pitecus> hi
03:47:42 <pitecus> how can i find out the smallest positive Double?
03:54:48 <Saizan> > 2^(-1023) :: Double -- smallest normalized
03:54:49 <lambdabot>  Exception: Prelude.^: negative exponent
03:54:55 <Saizan> > 2^^(-1023) :: Double -- smallest normalized
03:54:56 <lambdabot>  1.1125369292536007e-308
03:55:43 <Ytinasni> > 2^^(-1024)
03:55:44 <lambdabot>  0.0
03:55:56 <pitecus> thanks
04:02:10 <tuukkah> > 4.94065645841247e-324
04:02:12 <lambdabot>  5.0e-324
04:02:52 <tuukkah> > 2^^(-1022)
04:02:54 <lambdabot>  2.2250738585072014e-308
04:04:49 <Masklinn> hello #haskell
04:05:03 <tuukkah> hello Masklinn
04:08:52 <bringert> malebria: to use a haskell value in a query, use the function "constant"
04:14:46 <SamB> who would have thunk it... a well-drawn comic strip where the punchline is "You're missing a tab at line 258." ...
04:15:17 <SamB> or, well, maybe it is merely well shaded...
04:15:28 <tuukkah> url?
04:15:39 <SamB> http://www.wire-heads.com/istrip/index.php?strip_id=42
04:15:43 <lambdabot> Title: Wireheads -- Hollywood Blondes, Visual Effects Blues & CGI Geeks!
04:16:55 <tuukkah> heh
04:17:10 <tuukkah> and certainly not the worst drawn
04:17:36 <malebria> bringert: but I wanted to use it with a function, I'm doing as this:
04:17:38 <SamB> that one might be "help desk"
04:17:48 <SamB> aka ubersoft
04:17:59 <malebria>         Basic.geom << Expr (ConstExpr $ OtherLit $ "GeomFromText('" ++ show geom ++ "', -1)")
04:18:05 <tuukkah> hello nomeata
04:18:38 <SamB> oh, I like how (some of?) the people in GPF look like the PBS logo ;-)
04:18:49 <malebria> or maybe constant $ "GeomFromText('" ++ show geom ++ "', -1)"...
04:19:10 <nomeata> tuukkah: hi
04:19:11 <tuukkah> SamB, what's the milieu here?
04:19:41 <malebria> bringert: But it'd be if we could do this in a better form, like: function "GeomFromText" [show geom, "-1"]
04:19:54 <SamB> @all-dict mlieu
04:19:56 <lambdabot> No match for "mlieu".
04:19:58 <SamB> @all-dict milieu
04:20:00 <lambdabot> *** "Milieu" gcide "The Collaborative International Dictionary of English v.0.48"
04:20:00 <lambdabot> Milieu \Mi`lieu"\ (m[-e]*ly[~e]"), n. [F., fr. mi middle (L.
04:20:00 <lambdabot>    medius) + lieu place. See {Demi-}, {Lieu}.]
04:20:00 <lambdabot>    Environment.
04:20:00 <lambdabot>  
04:20:02 <lambdabot> [40 @more lines]
04:20:05 <SamB> hmm?
04:20:11 <SamB> tuukkah: what do you mean?
04:20:25 <tuukkah> where are these people in the comic?
04:21:31 <SamB> they appear to be working for a company called, uh, "BAD VFX", I think it was... a CGI company
04:22:31 <SamB> at the very beginning, someone was getting nowhere in a render because they had left a shader using the default "samples" parameter of 128 ;-)
04:22:33 <bringert> malebria: you could write that function (the one called "function", that is)
04:23:41 <tuukkah> SamB, apparently i don't know enough about cg
04:23:54 <fasta> There should be a file called GraphData.hs distributed with FGL. I can't find it. Do you have a copy of it?
04:24:00 <SamB> well, that joke was not CG-dependant
04:24:06 <SamB> that was just a Python joke...
04:24:26 <tuukkah> so i don't know enough python :-)
04:24:40 <SamB> Python has indentation-based syntax too ;-)
04:24:51 <fatalis> hey you guys
04:25:01 <SamB> presumably, the tab in question was actually four spaces
04:25:11 <fatalis> SamB, how is everything
04:25:21 <tuukkah> SamB, i mean the 128 "samples"
04:25:25 <SamB> tuukkah: oh, that.
04:25:53 <SamB> tuukkah: you know how raytracing works?
04:26:10 <tuukkah> i think i have an idea
04:27:14 <SamB> well, basically, in raytracing, a "sample" is when you trace a ray from the camera into the scene and calculate its color
04:27:27 <SamB> I assume it is something like that
04:27:30 <tuukkah> right
04:28:33 <SamB> oh, and a shader is usually something that is run *at least* once for every pixel on every surface it shades
04:29:21 <tuukkah> and they were running it 128 times?
04:29:45 <SamB> anyway, taking 128 samples each pixel for a largish number of pixels seems likely to take a while, whatever sort of sample they be ;-)
04:30:31 <tuukkah> ok, this is not like photon tracing where you're supposed to take *a lot* of samples :-)
04:30:44 <SamB> for a shader? I don't think so.
04:31:02 <SamB> I honestly don't know what kind of samples they are...
04:31:38 <tuukkah> wikipedia doesn't seem to be helpful here
04:31:45 <SamB> I think a sample is really just a value for a function at a particular point
04:34:53 <diogo> hello there
04:35:43 <fatalis> hi, dude
04:35:54 <diogo> suppose I have ghc6.6 installed and I want to compile ghc6.4.1 with ghc6.6 .. is that possible?
04:36:51 <SamB> should be
04:37:02 <SamB> compiling releases with releases is supposed to work
04:37:02 <psnl> diogo: 6.4 might use things that aren't in 6.6
04:37:13 <SamB> psnl: what?
04:37:14 <koala_man> is there an io function for reading a whitespace separated word, like 1.2 in "1.2 0.3"?
04:37:19 <JKnecht> why would you want to do that?
04:37:20 <SamB> what things?
04:37:34 <diogo> so.. if I want to compile some version I need a previous version?
04:37:42 <bringert> diogo: but it will only work if the version you want to compile has support for your architecture
04:37:46 <SamB> I never heard anything about only compiling *newer* releases with releases?
04:38:08 <psnl> SamB: Map against finateMap
04:38:54 <diogo> i have a mac intel.. if I try to compile version 6.4.1 doesn't work.. do you think that if change my OS to some linux it may work?
04:38:57 <SamB> psnl: doesn't GHC have copies of those in its sources anyway?
04:39:09 <SamB> diogo: dunno
04:39:25 <psnl> SamB: maybe
04:39:36 <psnl> SamB: should do
04:39:59 <bringert> diogo, yes, GHC 6.6 should be able to compile 6.4.1 on linux
04:40:09 <bringert> not that there is much reason to do that though
04:40:26 <diogo> i have some code that doesn't work on version 6.6
04:40:30 <diogo> i need version 6.4.1
04:40:52 <SamB> psnl: yeah, it must
04:40:58 <bringert> diogo: yeah, I remember. did you try changing the code? that should be done sooner or later anyway
04:41:05 <diogo> hm
04:41:15 <diogo> i have a error that i don't understand
04:41:17 <diogo> w8
04:41:24 <SamB> if you can still compile 6.6 with 6.2, which I'm sure you can...
04:41:37 <diogo> A pattern type signature cannot bind scoped type variables `t'
04:41:37 <diogo>       unless the pattern has a rigid type context
04:41:37 <diogo>     In the pattern: x :: t
04:41:37 <diogo>     In the definition of `hasTypeOf':
04:41:37 <diogo>         hasTypeOf (TermRep (dx, _, _)) (x :: t)
04:41:38 <diogo>                     = ((fromDynamic dx) :: Maybe t)
04:41:49 <SamB> (6.2 didn't have Data.Map)
04:42:14 <bringert> diogo: that seems to have to do with the changes in scoped type variables in 6.6
04:42:30 <lisppaste2> syntaxfree pasted "comment to a moderated blog; I wonder if they'll mod it out" at http://paste.lisp.org/display/35567
04:42:41 <bringert> diogo: that code could bind the type variable t in the type signature instead
04:42:45 <bringert> I think
04:43:05 <diogo> i'll try
04:43:38 <bringert> diogo: did you try e-mailing Silva and Visser? they might already have a version that works on 6.6
04:43:44 <bringert> this is CoddFish, right?
04:44:08 <syntaxfree> http://blogs.tedneward.com/2007/01/15/The+Root+Of+All+Evil.aspx
04:44:10 <lambdabot> Title: Interoperability Happens - The Root of All Evil
04:44:26 <syntaxfree> why people keep using languages without, say, map fusion, eh?
04:44:35 <diogo> bringert: i want to do that if I have no other choice..
04:47:44 <syntaxfree> what's "CMM"?
04:48:52 <bringert> c-minus-minus
04:49:23 <syntaxfree> I don't think that's it.
04:50:00 <syntaxfree> "a one-CMM-level improvement by itself accounts for only an 11% increase in productivity"
04:50:31 <bringert> eh
04:50:37 <bringert> no
04:50:42 <tuukkah> oh the capability maturity model
04:51:48 <syntaxfree> what is that?
04:52:04 <JKnecht> checkout CIMM
04:52:40 <JKnecht> (though last I looked tom schorschs original page was offline, wiki has now though)
04:52:41 <tuukkah> a list of stages where a software development process can be
04:52:48 <SamB> is that a kind of RAMM?
04:53:03 <JKnecht> capability immaturity model
04:53:29 <syntaxfree> hmm. there's a proper software development process theory already?
04:53:41 <SamB> heh
04:53:42 <syntaxfree> I mean, I've heard of XP and agile methods, but they mostly seemed like marketing to me.
04:54:04 <JKnecht> they aren't
04:54:07 <tuukkah> this is not about agile methods, this is about non-agile methods =)
04:54:11 <SamB> well, "you aren't going to need it" and "refactor mercilessly" are actually very good ideas
04:54:28 <JKnecht> all process development efforts tend to be mooted by societal factors though
04:54:31 <malebria> bringert: function f parameters = f ++ "(" ++ concat (List.intersperse "," parameters) ++ ")"
04:54:42 <syntaxfree> I think it's funny that people have to be reminded to refactor.
04:54:43 <SamB> although you have to balance "you aren't going to need it" with "you are going to need it", sometimes
04:55:02 <SamB> syntaxfree: hmm, point ;-)
04:55:06 <malebria> bringert: But I think it'd be better to have a PrimExpr constructor Function String [String]
04:55:08 <SamB> also, testings *is* a good idea
04:55:12 <SamB> er. testing.
04:55:18 <syntaxfree> tuukah: you mean, it's about managing strongly designed-out projects?
04:55:21 <bringert> malebria: yeah, that makes sense
04:55:32 <syntaxfree> SamB: methinks proving programs correct is a good idea.
04:55:35 <SamB> and sometimes it does make sense to write only part of a function (they call it a method on ward's wiki)
04:55:42 <SamB> syntaxfree: true
04:55:47 <SamB> but proofs only go so far
04:56:06 <Saizan> proofs can be done only for things that don't need them :)
04:56:08 <SamB> I mean, knuth did say "I have only proved [the program] correct, not tried it!"
04:56:08 <syntaxfree> isn't  a program a series of matehmatical transformations over a data object anyway?
04:56:43 <tuukkah> syntaxfree, i don't remember too much about it. i don't think the theory is that proper. but they are about software engineering, like it was a factory process and not research
04:57:02 <syntaxfree> I see.
04:57:36 <SamB> Saizan: not true
04:57:38 <Eelis> one can prove nontrivial programs correct.
04:57:48 <syntaxfree> oh. there's'√° 'p'la'net openid now.
04:58:07 <SamB> it helps if you write the program in an easier-to-reason-about way
04:58:16 <Eelis> it sure does
04:58:18 <SamB> but that helps you to make it work, too ;-)
04:58:18 <syntaxfree> is the "planet" blog aggregator software free/OSS/downloadable?
04:58:24 <pejo> (Look at Leroy's certified compiler for a prime example of a real program).
04:58:52 <syntaxfree> i mean, there's planet haskell, planet lisp and planet openid, all look alike.
04:59:23 <tuukkah> see planet planet :-)
04:59:27 <SamB> ?
04:59:48 <tuukkah> http://www.planetplanet.org/
04:59:49 <lambdabot> Title: Planet Feed Reader
05:00:23 <syntaxfree> hrm. Puthon.
05:00:48 <syntaxfree> hehe. there's a planet adium.
05:01:11 <syntaxfree> planet haskell isn't listed there.
05:08:19 <diogo> i have the -fallow-overlapping-instances but it still complains about overlapped instances!
05:09:17 <SamB> ???
05:10:31 <syntaxfree> sigfpe shames me.
05:10:47 <syntaxfree> every single post on his blog is informative.
05:10:56 <SamB> heh
05:11:39 <syntaxfree> I wonder where he works.
05:12:43 <JKnecht> at home if he's really really good
05:12:55 <bringert> sjanssen: what's the status of UTF8 ByteStrings?
05:13:27 <syntaxfree> do you think he has a company or something?
05:13:51 <syntaxfree> bah, my blog sucks :D
05:20:47 <dons> what's up lambda crew!?
05:21:27 <bringert> hey dons
05:21:38 <bringert> dons: do you know that status of UTF8 ByteStrings?
05:21:53 <koala_man> I have a function readMoo that reads some data from stdin. how do I get a list of them? I wrote a function for it but there must be an existing one?
05:22:29 <Botje> mapM ?
05:22:51 <bringert> @type mapM
05:22:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
05:24:36 <bringert> dons: so, how fast is binary today?
05:24:44 <dons> getting faster
05:24:53 <dons> just quadrupled the 64 bit word stuff
05:24:58 <bringert> sweet
05:24:58 <dons> (too manye 64 bit shifts)
05:25:09 <bringert> this is still writing, right?
05:25:20 <dons> yeah
05:25:28 <dons> duncan's committing the reading patch real soon
05:25:47 <bringert> dons: do you know how UTF8 ByteString is coming along?
05:26:06 <koala_man> Botje: yay. is there a similar one for just reading N elements?
05:26:19 <bringert> @type replicateM
05:26:21 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
05:26:24 <dons> bringert: hmm, done?
05:26:34 <dcoutts__> bringert: I've made it a MSc project at oxford, we'll see if anyone takes it
05:26:35 <bringert> dons: oh? where?
05:26:47 <koala_man> great, thanks!
05:27:06 <dcoutts__> bringert: no he meant "done?" not "done."
05:27:44 <bringert> oh, I thought someone was working on that?
05:27:57 <bringert> didn't sjanssen work on it for SoC?
05:28:12 <syntaxfree> House is pretty fast.
05:28:16 <malebria> dons: is there a haddock generated hs-plugins doc?
05:28:23 <syntaxfree> Of course it doesn't' do much either;.
05:28:25 <dcoutts__> bringert: no, that was ByteString of Storable, so that'd be ok for UTF32, but not for 16 or 8
05:28:30 <dons> malebria: hmm. I think so
05:28:39 <bringert> dcoutts_: oh, ok
05:28:51 <musasabi> UTF16 needs the more generic fusion.
05:29:06 <musasabi> What is the current status of the new fps branch vs the old one in GHC?
05:29:07 <dcoutts__> bringert: mind you, I don't think it's too hard, which is why I proposed it as an MSc project
05:29:25 <bringert> dcoutts_: how about doing with the binary library?
05:29:29 <bringert> it
05:29:57 <bringert> read a byte, output if char is done, otherwise read some more
05:30:02 <malebria> dons: is it available somewhere via web?
05:30:12 <dons> I think so. check the hs-plugins page
05:30:13 <dcoutts__> bringert: that's not quite the same thing as a packed string lib that provides a string data type with all the ops
05:30:16 <dons> for 'preliminary haddock docs'
05:30:32 <dcoutts__> musasabi: dons is planning on doing a new relase and updating the fps that is currently in base
05:30:35 <bringert> dcoutts_: true
05:31:03 <malebria> dons: hum, thanks.
05:31:04 <bringert> though it would be enough for reading and writing UTF8, with UTF32 as the internal representation
05:31:04 <dcoutts__> bringert: I think it's not that hard, all that needs to change is to do a read/write that does UTFN encoding/decoding
05:31:36 <bringert> UTF32 ByteString is still much better than the [Word] that we have now
05:31:49 <dcoutts__> bringert: sure
05:32:21 <syntaxfree> bytestrings need a better name.
05:32:32 <syntaxfree> maybe "rivers".
05:32:33 <dcoutts__> syntaxfree: Vector Word8 ?
05:32:40 * earthy likes ByteString
05:32:49 <malebria> dons: The HTML documentation is not included in the Debian package as building it
05:32:52 <malebria> requires tex2page which is not available on all architectures supported by
05:32:54 <malebria> Debian.
05:32:56 <earthy> as a name
05:33:04 <syntaxfree> vector word8 seems descriptive if it's what I'm thinking.
05:33:10 <syntaxfree> is it like a Scheme vector?
05:33:10 <dcoutts__> bringert: I think one could do a fusible packed string lib quite easily if you didn't do all the specialised implementations but relied just on the generic stream impls
05:33:11 <dons> malebria: ah yes
05:33:14 <dons> earthy: oh good! :)
05:33:19 <malebria> from libghc6-plugins-dev README.Debian.. That's why I wasn't finding it..
05:33:30 <dons> better than FastPackedString
05:33:42 <dcoutts__> bringert: see, in the ByteString lib we have both fusible and non-fusible versions of everything, that's what takes time.
05:33:43 <syntaxfree> fusibility++
05:34:01 <dcoutts__> bringert: so without those bits it'd be much quicker to implement
05:34:05 <earthy> the name ByteString suggests that it works efficiently with streams of bytes
05:34:22 <dcoutts__> yeah, it's a good name
05:34:23 <earthy> FastPackedString only suggests one single string type
05:34:34 <dons> ah yes
05:34:34 <earthy> (which is less than ByteString provides)
05:34:51 <syntaxfree> bytestrings are sounding like a killer app for Haskell already to me.
05:34:52 <dons> yeah
05:34:58 <dons> syntaxfree: oh?
05:35:01 <syntaxfree> but "string" usually means "text manipulation".
05:35:03 <dons> well, we need some more libs
05:35:10 <dons> i.e. like parsec for binary network protocols
05:35:14 <dons> and this fast serial stuff
05:35:16 <syntaxfree> in the heads of php programmers, i see.
05:35:27 <syntaxfree> s/i see/i mean.
05:35:34 <syntaxfree> Bah, my english is godawful today.
05:35:41 <dcoutts__> syntaxfree: that's why we called it *Byte*String, not PackedString
05:35:59 <syntaxfree> "string" still stands out in my mind.
05:36:06 <dcoutts__> syntaxfree: there will also be PackedString in the fullness of time, which will be Unicode
05:36:13 <earthy> hm. UU.Parsing on bytestrings. *hmm*.
05:36:18 <syntaxfree> not trying to be critical in a negative way, sorry if I come out that way.
05:36:36 <dons> earthy: right. and thing erlang-style network protocol hacking
05:36:39 <dons> but with combinators
05:36:42 <syntaxfree> maybe I'd call them bytestreams.
05:37:08 <earthy> syntaxfree: but then you lose the obvious connection to strings
05:37:34 <syntaxfree> well, the appeal of bytestrings to me is in manipulating binary formats. maybe I'm being stupid.
05:37:46 <dons> yeah, that's the plan, syntaxfree
05:37:48 <syntaxfree> I mean this in a total nonironic way.
05:37:49 <dons> binary formats
05:37:57 <sieni> @pl (\x -> ( < (3 + x) ) )
05:37:57 <lambdabot> flip (<) . (3 +)
05:38:00 <dons> we're working *furiously* on binary serialisatoin right now
05:38:11 <dons> and then arbitrary external formats is the next job
05:38:32 <syntaxfree> I have a mental map of Haskell stuff that's well-defined in many areas, but when more experienced people's mental map of those areas clashes with mine, I first doubt my own.
05:38:48 <syntaxfree> dons: wow. *furiously*
05:38:57 <syntaxfree> makes me wish I could help.
05:39:01 <dons> i mean like 200 patches in 7 days...
05:39:07 <dons> :)
05:39:12 <syntaxfree> audreyt tried to involve me in Pugs but I don't know enough Perl.
05:39:42 <Igloo> Does anyone know what "a carrot indicator like java" means?
05:39:43 <syntaxfree> does the pretty web interface to darcs repos still exist?
05:39:46 <malebria> dons: is there a expectative for hs-plugins supporting ghc6.6?
05:40:05 <syntaxfree> the first thing that attracted me to Haskell was "Theorems for free!". The second one was the pretty web interface for darc repos.
05:40:13 <syntaxfree> s/darc/darcs.
05:40:29 <dons> malebria: yeah, soon
05:40:40 <Botje> Igloo: "caret" aka '^'
05:47:05 <Igloo> Botje: Ah, to "underline" where errors are, you mean?
05:48:52 <bringert> Igloo: I read that too. I think that's what it means.
05:50:47 <Igloo> OK, thanks
05:51:41 <bringert> Igloo: or it could mean that it gives you a carrot to munch on while it compiles.
05:51:45 <bringert> you never know
05:52:03 <Igloo> :-)
05:59:42 <syntaxfree> http://www.mensa.es/test/test.html
05:59:44 <lambdabot> Title: Mensa EspaÒa - Test orientativo
05:59:52 <syntaxfree> this isn't an IQ test, it's a visual acuity test!
06:00:00 <syntaxfree> my head hurts form trying to discern white and black dots!
06:05:10 <syntaxfree> these tests are easy. the trick is to compute the answer first and then check what alternative it is.
06:05:29 <syntaxfree> what-seems-closer heuristics don't work, you need to find the pattern not knowing the options.
06:08:04 <fatalis_> too easy
06:08:06 <mahogny> the mensa test is silly
06:08:33 <mahogny> you will be labeled for life if you join :P
06:09:01 <syntaxfree> heh.
06:09:24 <syntaxfree> I'm over the high-IQ society thing. Just killing time / stroking my ego.
06:09:45 <malebria> Is it right to include {-# OPTIONS_GHC -i/home/marcot/codigo/haskell/urban/urban-plugins/haskell/ #-} in a .hs file?
06:09:56 <mahogny> mensas limit for high is a bit silly though :)
06:09:59 <malebria> Or this OPTIONS_GHC is just for things as -fglasgow-exts?
06:10:11 <syntaxfree> limit for high?
06:10:18 <syntaxfree> ah, of course. 2%.
06:10:26 <SimonRC> Am I the only one to see a connection between the "connection names" of Arrow notation and linear types?
06:10:34 <syntaxfree> pretty much anyone who's in graduate school is in the top 2% of society anyway.
06:10:39 <mahogny> yeah
06:11:07 <mahogny> you don't even have to be in grad school to be in
06:11:10 <bringert> malebria: I think OPTIONS_GHC should be things that do not depend on your local configuration
06:11:18 <SimonRC> You can only use such a name in the "output" of one arrow and the "input" of another.
06:11:24 <syntaxfree> well, yes. but graduate school is a better signal of smarts than a 2% society anyway.
06:11:31 <malebria> bringert: hum.. but shouldn't this work?
06:11:38 <mahogny> syntaxfree, that too :)
06:11:49 <bringert> malebria: yeah, it should work, at least in 6.6
06:11:57 <bringert> malebria: see http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
06:11:59 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/ydk2e6
06:12:32 <bringert> malebria: those that say "dynamic" should work in OPTIONS_GHC
06:13:11 <SimonRC> *sigh*
06:13:17 * SimonRC tries on #ltu.
06:13:40 <syntaxfree> bah, I got 6 wrong! I was expecting a perfect score, or maybe 1 or 2 wrong!
06:13:53 <fatalis_> syntaxfree, I didn't even get to see my score :-(
06:13:58 <mahogny> so even worse, the answer is non-unique :)
06:13:59 <syntaxfree> why?
06:14:02 <fatalis_> not being able to read spanish
06:14:07 <syntaxfree> ah, paste it to me.
06:14:08 <fatalis_> syntaxfree, no idea
06:14:24 <fatalis_> too late, I clicked back to try what the other button does
06:14:27 <fatalis_> and it cleared the answers
06:14:36 <psykotic> this is much easier than the ones they use in practice
06:14:47 * syntaxfree blames it on being sleepy and caffeine-less.
06:14:50 <psykotic> i usually do pretty poorly on these tests and i got 18/18
06:14:54 <koala_man> I want to work with some graphs, connect edges and that sort of things. what would be a decent approach to that?
06:14:59 <syntaxfree> I thought it was all pretty simple. I expected 16/18 or something.
06:15:06 <psykotic> none of the patterns were tough. do the one on mensa.dk if you want a challenge.
06:15:13 <psykotic> the last 10 in that test are insane.
06:15:13 <syntaxfree> oh, thanks!
06:15:18 <koala_man> rebuild the entire graph with the changes in place?
06:15:22 <fatalis_> I'll challenge myself with haskell :-)
06:15:49 <syntaxfree> I had some contact with people in the Prometheus society for a while, but I never took tests.
06:16:16 <syntaxfree> I just had long email discussions with various members, and after a while was publishing articles in their newsletter and moderating one of their discussion lists.
06:16:25 <bringert> Igloo: the docs say that -package is dynamic, but ghc ignores it when set in OPTIONS_GHC
06:16:26 <syntaxfree> I think I might still be a moderator, if I log on to my old address.
06:16:39 <syntaxfree> All the benefits of being a member, none of the hassle :)
06:16:41 <psykotic> most of the mensans i ever met were hilariously self-absorped and stupid people.
06:17:13 <syntaxfree> well, it's the kind of people who pay $50 a year for a minor ego stroke.
06:17:16 <psykotic> i'm sure there are exceptions, but people who join a society for "smart people" are rather self-selective.
06:17:17 <psykotic> right.
06:17:45 <syntaxfree> I can empathize with low self-esteem because I have it in other areas, but I'm just okay with my "intelligence".
06:17:52 <syntaxfree> It's enough to explore all the cool stuff I wanna explore, so.
06:17:54 <diogo> 1 wrong
06:17:57 <diogo> nice
06:18:01 <kzm> @seen Igloo
06:18:01 <lambdabot> Igloo is in #darcs, #ghc, #haskell.hac07 and #haskell. I last heard Igloo speak 25m 57s ago.
06:18:01 <Igloo> bringert: Hmm, OK, ta
06:18:06 <Igloo> kzm: ?
06:18:13 <kzm> whoah!
06:18:15 <bringert> Igloo: I'll create a ticket
06:18:27 <psykotic> well, i have plenty of self-esteem issues, but most of the people i know who make a big point of their IQ are those with mediocre success in life.
06:18:32 <Philippa> I figure those societies are for people who haven't figured out that commonality in what you're smart about matters too
06:18:41 <Philippa> *nod*
06:18:48 <kzm> I was just going to mention that I also observe AMD64 code to be slower than x86 on an AMD64 machine...
06:18:56 <syntaxfree> it's all a matter of ego and self-esteem, I reckon.
06:18:58 <Philippa> I basically just keep it in hand for clubbing medical professionals around the head with if they try to pull an "I'm smarter than you"
06:18:58 <kzm> (as mentioned on the mailing list)
06:19:03 <Igloo> bringert: OK, thanks!
06:19:18 <syntaxfree> heh.
06:19:20 <malebria> bringert: it seems to be ignoring -i too.
06:19:22 <dons> Philippa: hehe
06:19:24 <Philippa> kzm: that's to be expected, no?
06:19:28 <syntaxfree> I just start name-dropping cat theory or econometrics on them :)
06:19:29 * dons waves from .fr
06:19:35 <Igloo> kzm: If you have any examples (particularly small examples) then that would be great
06:19:46 <psykotic> syntaxfree, btw this was the test i mentioned. i am totally unable to figure out the last 10 or so. they are insane. http://www.iqtest.dk/main.swf
06:20:02 <kzm> Igloo, only large examples so far. :-)
06:20:27 <diogo> psykotic: what test?
06:20:34 <psykotic> the one i just linked to.
06:20:43 <psykotic> it starts out easy but the later ones are fairly tricky.
06:21:00 <kzm> Philippa - I guess the new registers and instructions fail to compensate sufficiently for the larger footprint.
06:21:01 <diogo> mensa
06:21:19 <syntaxfree> psykotic: I'll try it later when fully awake and caffeinated.
06:21:21 <psykotic> diogo, yes, i know it's fairly stupid. i only thought of it because syntaxfree posted that other thing.
06:21:34 <syntaxfree> Right now, I'm just going to get ready for classes and for gloating I'm "mensa-capable".
06:21:41 <syntaxfree> :-P
06:22:38 <syntaxfree> I feel bad about my "intelligence" when I can't grok something -- say, existential types -- not when I can't solve a picture puzzle.
06:22:56 <syntaxfree> OTOH, I'm able to grok a lot of really cool stuff that excites, so I'm better off whining about not being tall than about not being smart.
06:23:18 <malebria> bringert: is this a problem in GHC?
06:23:25 <diogo> i feel bad when i can't compile ghc 6.4.1
06:23:26 <diogo> :)
06:23:47 <bringert> malebria: either in GHC or GHC's manual. I'm submitting a bug report.
06:24:22 <malebria> bringert: are you including -i in it?
06:25:20 <bringert> malebria: yep, will do
06:26:07 <kzm> Igloo, I'll pick up Philippa's comment: is code for AMD64 supposed/expected to be faster?  I thought this (64-bit is slower) was more or less the consensus observation.
06:26:34 <chessguy> this needs some cleaning up, but could someone read through it and double-check the logic for me? http://www.haskell.org/haskellwiki/Haskell/Lazy_Evaluation
06:26:35 <lambdabot> Title: Haskell/Lazy Evaluation - HaskellWiki
06:26:36 <Philippa> kzm: bandwidth-bound code will be slower. If you're fitting in cache still, it may be faster
06:26:58 <Philippa> and the extra registers certainly help there
06:27:41 <Igloo> I was under the impression that it was normally faster (in mainstream languages)
06:27:48 <Igloo> Due to having more registers to play with
06:27:50 <kzm> Hmm.. okay.  I suspect most (of my) code is too bandwidth intensive.
06:28:33 <dons> kzm, have you tried the latest 'binary', btw?
06:28:34 <kzm> Maybe the code gen can be improved?  Or maybe it is possible to pack things tighter?  Does GHC use a 64-bit word for tag?
06:28:40 <dons> its about 200 x faster than on friday
06:28:44 <dons> (for writing)
06:28:45 <kzm> dons, no, not yet.
06:28:50 <dons> reading,we're working on now
06:28:58 <kzm> two hundred times, eh?
06:29:05 <dons> yes, literally
06:29:18 <dons> > 166 / 0.25
06:29:20 <lambdabot>  664.0
06:29:29 <dons> ok...
06:29:35 <dons> that's the speed up
06:29:51 <kzm> I'm worried that if I wait another week, the factor will be 40 000.  Somebody must stop you guys!
06:29:58 <dons> i don't think so now
06:30:03 <dons> there's only really one more thing we can do
06:30:05 <chessguy> i can do some 64-bit testing, i just put GHC on my 64-bit machine last night
06:30:07 <kzm> (In other words: awesome!)
06:30:11 <dons> and its almost up to the bandwidth of the  laptop anyway
06:30:31 <kzm> 166 and 0.25 are in which units? MB/s?
06:30:34 <dons> yeah
06:30:37 <dons> after and before
06:30:52 <dcoutts__> kzm, if you want to help, you could write a C & Hs prog that measures the maximum memory throughput on a box
06:30:53 <kzm> Damn.  I need to order three more disks to keep up. :-)
06:31:01 <kzm> lmbench?
06:31:54 <dcoutts__> hmm, though we need to know the practical max
06:32:00 <dcoutts__> using byte copying loops
06:32:04 <dcoutts__> and word copying loops
06:32:11 <dcoutts__> in C and in Haskell
06:32:25 <earthy> chessguy: that lazy evaluation thingy seems to be correct.
06:32:27 <bringert> Igloo, malebria: http://hackage.haskell.org/trac/ghc/ticket/1108
06:32:28 <lambdabot> Title: #1108 (-package and -idir in OPTIONS_GHC are ignored, but manual says that they' ...
06:32:28 <matthew_-> err, I've come late to this conversation. What are you making such improvements in?
06:32:33 <bringert> what, hackage?
06:32:52 <dcoutts__> matthew_-: binary serialisation speed
06:32:54 <bringert> oh, all tracs are on hackage.haskell.org
06:33:40 <matthew_-> dcoutts__: uh hu. and where is that used?
06:34:03 <dcoutts__> matthew_-: we're still developing it, but lambdabot is using it already
06:34:18 <kzm> dcoutts__, isn't it lmbench still?
06:34:27 <dcoutts__> kzm, dunno
06:34:46 <kzm> http://www.bitmover.com/lmbench/whatis_lmbench.html
06:34:47 <lambdabot> Title: LMbench - Tools for performance analysis -- What is LMbench?
06:35:08 <dcoutts__> kzm, ta
06:35:33 <malebria> bringert: how do I run a sql function in haskelldb that is not related to any table? Like LASTVAL().
06:35:44 <kzm> I have a deadline Feb 2, in the meantime, everything else is on hold.  But I'll try to put Binary to good use after that.
06:35:50 <chessguy> > let magic 0 _ = []; magic m n = m : (magic n (m+n)); getIt [] _ = 0; getIt (x:xs) 1 = x; getIt (x:xs) n = getIt xs (n-1); in getIt (magic 1 1) 1
06:35:57 <lambdabot>  1
06:36:08 <malebria> bringert: bringing the result to the haskell program.
06:36:08 <chessguy> mmmm
06:36:11 <chessguy> bad answer
06:36:21 <chessguy> oh maybe not
06:36:29 <chessguy> > let magic 0 _ = []; magic m n = m : (magic n (m+n)); getIt [] _ = 0; getIt (x:xs) 1 = x; getIt (x:xs) n = getIt xs (n-1); in getIt (magic 1 1) 3
06:36:30 <lambdabot>  2
06:37:16 <chessguy> > let magic 0 _ = []; magic m n = m : (magic n (m+n)); getIt [] _ = 0; getIt (x:xs) 1 = x; getIt (x:xs) n = getIt xs (n-1); in map (getIt (magic 1 1)) [1..5]
06:37:17 <lambdabot>  [1,1,2,3,5]
06:41:55 <malebria> bringert: the problem is converting from Expr a to Query (Rel a)
06:43:45 <Templar2> is the function union and nub++ the same thing
06:43:46 <Templar2> ?
06:43:57 <kzm> dcoutts__, I couldn't get lmbench3 to compile before I mkdir SCCS; touch SCCS/s.ChangeSet.  Seems to work after that.
06:44:22 <dcoutts__> kzm, ok
06:46:44 <allbery_b> sccs?  now there's a blast from the past
06:47:37 <Saizan> > union [1,2,2,3] [1,2,3,4,4] -- don't seems so
06:47:38 <lambdabot>  [1,2,2,3,4]
06:49:22 <chessguy> How do i add a wiki page to the tutorials list? i can't remember
06:49:32 <kzm> allbery_b, I think it's bitkeeper, actually.  (Guess what L and M stands for in lmbench?)
06:50:25 <sjanssen> @check (\xs ys -> union xs ys == nub (xs ++ ys)) :: [Int] -> [Int] -> Bool
06:50:27 <lambdabot>  Falsifiable, after 11 tests: [1,3,3], [-1,4]
06:53:45 <allbery_b> oh, I know that.  I didnn't realize bk simulated sccs, though.  explains a few things :/
06:54:09 <chessguy> dons, ping
06:57:56 <kowey> Templar2: did sjanssen's reply answer your question?
06:57:56 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
06:59:13 <Templar2> kowey: yes, I belive so
07:06:17 <dons> chessguy:
07:06:39 <dons> hey kow
07:06:43 <dons> kowey
07:06:49 * dons waves from Nice!
07:08:07 <bakert> dons, is it as windy in Nice as it is in London?
07:08:16 <bakert> dustbins flying around here.
07:08:16 <dons> not at all
07:08:19 <dons> huh
07:08:29 <bakert> so it's nice in Nice?
07:08:31 <earthy> we have force 9 gales to force 10 storms.
07:08:39 <bakert> @localtime earthy
07:08:41 <lambdabot> Local time for earthy is Thu Jan 18 16:06:06 2007
07:08:55 <dons> yeah, flee south I say
07:08:57 <dons> to the sun!
07:09:05 <bakert> Ah earthy, you're prepared for it.  We have no clue.
07:09:09 <earthy> hey, Doaitse came up north already. ;)
07:09:21 <dons> oh, he's already back
07:09:22 <dons> hehe
07:09:34 <earthy> wearing a Popl sweater even. ;)
07:09:44 <earthy> POPL'97, that is :)
07:09:55 <bakert> My first "commercial" haskell program is going live at work today, in a minute.
07:10:04 <earthy> cool, bakert
07:10:12 <dons> wow. that's great
07:10:15 <dons> earthy: heh
07:10:20 <bakert> it's not very sophisticated.
07:10:26 <bakert> but it does work.
07:10:30 * earthy just started another run of Dazzle. let's see if this takes less than 72 hours.
07:10:45 <dons> i can't compile my binary benchmark on the laptop anymore
07:10:50 <dons> after about 100M of swap, things get asty
07:11:06 <dons> lesson: using GHC as a whole program compiler (with massive inlining) can be awkward
07:11:17 <earthy> ;)
07:12:27 <tuukkah> asty as in abstract-syntax-tree-y?-)
07:12:32 <dons> heh
07:12:38 <dons> n-asty
07:13:06 <tuukkah> well, what's filling the memory ?-)
07:13:34 <dons> code. the entire library is inlined into the user's code, and then lots of transofrmations happen
07:13:52 <dons> ghc really goes pretty nuts on the code, turning a Writer Monoid into direct unrolled pokes into memory
07:14:28 <tuukkah> that is cool, i have to admit
07:14:33 <sjanssen> dons: ghc and the cc1 process it forks take up 500MB peak memory over here
07:14:43 <dons> yeah, that's about what i'm seeing
07:14:49 <dons> could be a reasonable test case to hand to Simon
07:15:06 <dons> though spj did say we were stressing the inliner a bit..
07:15:29 <dons> sjanssen: o you got similar throughput on the mac?
07:15:34 <dons> and the QC properties hold?
07:17:31 <sjanssen> dons: yep.  Reading Word32 in chunks of 16 approaches 160MB/s
07:17:49 <dons> sweet.
07:17:51 <sjanssen> and the QCs hold
07:18:16 <sjanssen> has anyone tried binary on a ppc or sparc?
07:18:44 <dons> ah, so you've only used x86/mac?
07:18:45 <fatalis> I sure haven't
07:18:57 <dons> duncan has a sparc up
07:19:00 <dons> we'll try that
07:19:09 <tuukkah> what's qc except questionable content?
07:19:15 <dons> quick check
07:19:22 <dons> testing suite for haskell
07:19:28 <tuukkah> right, thanks
07:19:30 <earthy> whoa. the head of the department sent out an e-mail an hour ago urging people to go home
07:19:37 <dons> wow
07:19:43 <dons> because of the weather?
07:19:49 * earthy nods
07:19:49 <sjanssen> @check (\x y -> x + y == y + x) :: Int -> Int -> Bool
07:19:50 <lambdabot>  OK, passed 500 tests.
07:19:57 <Philippa> if it's due to get any worse then better to go now
07:20:05 <Philippa> people're being advised not to travel here and the trains aren't running
07:20:22 <sjanssen> tuukkah: ^^^ quick check takes properties and checks whether they hold for random inputs
07:20:26 <dons> wow
07:21:01 <earthy> my whoa was triggered by 'Even if you would have to teach a class.'
07:21:17 <tuukkah> perhaps we'll unit test our code one of these days
07:21:24 * earthy is going to make use of the lull in the rain. ;)
07:21:25 <earthy> bbl
07:22:02 <edwinb> Scotland seems to have its own curious microclimate today
07:22:05 <bringert> malebria: see http://darcs.haskell.org/haskelldb/test/old/CustomSql.hs
07:22:09 <dons> stay safe earthy :)
07:22:20 <sjanssen> tuukkah: QuickCheck is better than unit testing in some ways.  You can only unit test the cases you can imagine
07:22:38 <dons> yeah, it generates the uni tests
07:22:42 <dons> based on the type
07:22:54 <dons> so yep, it automates much of the unit testing
07:23:11 <malebria> bringert: thanks, but I got to this point already. The problem is executing in the database and getting the result.
07:23:30 <bringert> oh, sorry, wrong file
07:23:53 <bringert> malebria, http://darcs.haskell.org/haskelldb/test/old/default-auto-inc.hs
07:24:21 <bringert> malebria, the trick is to use a fake field and do a project and run that with query
07:24:39 <bringert> see lid_q
07:24:55 <bringert> and the line (r:_) <- query db lid_q
07:25:06 <bringert> it could be nicer...
07:25:36 <malebria> bringert: thanks..
07:25:45 <malebria> I was reading the code, it's very explicative.
07:27:25 <malebria> bringert: sure it could be nicer, haskelldb needs some improvements, but it's very nice, are you the developer?
07:27:56 <bringert> malebria: i'm the maintainer, but I haven't really done much maintenance for quite a while
07:28:54 <chessguy> hmmm, did my mention of the new lazy evaluation tutorial show up on haskell-cafe? i see it in the archives, but i didn't get a copy in my email
07:29:07 * allbery_b saw it
07:29:12 <chessguy> oh ok
07:29:21 <chessguy> i guess it doesn't send me email from myself
07:29:41 * chessguy likes talking to himself
07:29:42 <bringert> chessguy: I think it does
07:30:18 <chessguy> well, i got an email from the next thread after mine, but not mine
07:31:49 <malebria> bringert: good to know, thank you for the program, it's very nice.
07:40:03 <chessguy> @type (~)
07:40:05 <lambdabot> parse error on input `)'
07:40:17 <dons> sym not an op
07:40:32 <chessguy> oh, what is it?
07:41:01 <chessguy> let foo = foldr (\a ~(x,y) -> (a:y,x)) ([],[]) in foo "1234567"
07:41:06 <chessguy> > let foo = foldr (\a ~(x,y) -> (a:y,x)) ([],[]) in foo "1234567"
07:41:08 <lambdabot>  ("1357","246")
07:41:48 <allbery_b> it's pattern matching syntax for a lazy pattern (which succeeds until something inside the pattern is used
07:42:02 <allbery_b> ...then if the pattern wasn't actually matched it fails
07:42:06 <chessguy> is there a simpler example?
07:42:40 <dons> > f ~(Just x)= 1 in f Nothing
07:42:40 <lambdabot>  Parse error
07:42:47 <dons> > let f ~(Just x)= 1 in f Nothing
07:42:48 <lambdabot>  1
07:43:00 <dons> > let f (Just x)= 1 in f Nothing
07:43:02 <lambdabot>   Non-exhaustive patterns in function f
07:44:09 <chessguy> hmm, so it's like a negation of a pattern?
07:44:22 <allbery_b> no, just a delayed pattern
07:44:35 <allbery_b> pattern natches are normally strict, ~ makes them lazy
07:44:54 <chessguy> hmmm
07:45:06 <chessguy> i don't get it
07:45:34 <fasta> chessguy: it matches regardless of the value
07:46:32 <allbery_b> > let f p ~([a]) = if p then a else 0 in f False []
07:46:33 <lambdabot>  0
07:46:39 <allbery_b> > let f p ~([a]) = if p then a else 0 in f True []
07:46:41 <lambdabot>   Irrefutable pattern failed for pattern ([a])
07:46:56 <trurl_> chessguy: see 4.4 on http://www.haskell.org/tutorial/patterns.html
07:46:57 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
07:47:03 <allbery_b> basically lets you delay a pattern based on other data
07:49:27 <earthy> damn.
07:49:43 <allbery_b> I don't think you ever *need* lazy patterns, but the example I used above is much shorter/cleaner than the equivalent done without lazy patterns
07:49:48 * earthy >>= wear_dry_clothes
07:50:23 <earthy> time for a nice warm cuppa
07:51:05 <allbery_b> > let f False _ = 0; f True [a] = a in f False []
07:51:07 <lambdabot>  0
07:51:22 <allbery_b> > let f False _ = 0; f True [a] = a in f True []
07:51:23 <lambdabot>   Non-exhaustive patterns in function f
07:52:19 <allbery_b> well, in this trivial example it's a wash :) more useful in more complex functions
07:52:37 <fasta> It's useful in mfix
07:53:23 <fasta> Hmm, how nice, an undocumented file format.
07:54:04 <fasta> And Kile is crashing too. What a jolly good software.
07:54:56 <earthy> where's that binary interface stuff located, by the way?
07:55:11 <glguy> morinin' all
07:55:21 * earthy might want to try reimplementing mdbtools in Haskell
07:55:29 <allbery_b> ?where newbinary
07:55:29 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
07:55:33 <allbery_b> that?
07:55:39 <fasta> Output written on problems.tex.dvi (10025 pages, 802188 bytes) <- WTF?!
07:55:43 <earthy> is that the stuff dons is working on?
07:55:54 <glguy> I thoughtdons was replacing newbinary
07:55:58 <glguy> !paste
07:55:58 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
07:56:00 <allbery_b> hm
07:56:08 * earthy thought so to
07:56:09 * allbery_b dunno
07:56:09 <earthy> +o
07:56:25 <fasta> Ok, do you know of a viewer that can scale to 10K pages?
07:56:44 <earthy> fasta: xdvi?
07:57:09 <fasta> earthy: yes, that works. I already did so before you suggested.
07:57:25 <fasta> It appears xdvi is properly implemented.
07:57:27 <fasta> Good stuff.
07:57:50 <bringert> @where binary
07:57:51 <lambdabot> http://darcs.haskell.org/binary
07:57:57 <pitecus> I have this function which eats up all available memory. Is there some strictness or other tick that would fix that? Its the following:
07:58:00 <pitecus> meanSimilarity f xs ys = sum / fromIntegral size
07:58:00 <pitecus>     where (size,sum) = foldl' (\(z,z') s -> (z+1,z'+s))  (0,0) [similarity f x y | x <- xs , y <- ys ]
07:58:09 <bringert> earthy, allbery_b: that's the one dons, dcoutts and kolmodin are hacking on
07:58:33 <fasta> Ok, this is pretty funny: every word is on a different page.
07:58:37 <earthy> bringert: thanx
07:58:47 <pitecus> xs is about 700000 elements
07:59:21 <pitecus> I mean ys
08:00:07 <earthy> pitecus: try using foldr'
08:00:28 <pitecus> earthy, why is that better?
08:00:29 <hpaste>  glguy pasted: nonogram solver at http://fserv.pikapphi.umr.edu:8000/2
08:01:14 <earthy> pitecus: foldr, that is. as to why it's better: the optimizer gets more chance to work its magic
08:01:22 <pitecus> ok
08:02:23 <pitecus> I guess i just dont see why the whole list would be needed at any point....
08:03:24 <allbery_b> that may not be the problem
08:04:01 <allbery_b> laziness means haskell may decide to stick unevaluated values on the stack or heap
08:04:41 <pitecus> so what would i make strict?
08:05:50 <allbery_b> well, start with foldr' to see if the compiler can work it out itself.  next thing I';d look at is the (z+1,z'+s)
08:07:11 <pitecus> foldr didnt help, it still eats memory, just a bit slower...
08:07:34 <glguy> what code is blowing up the stack?
08:08:26 <pitecus> glguy, i dont get any stack error
08:08:34 <earthy> pitecus: okay, then the list comprehension keeps things unevaluated
08:09:12 <bringert> size and sum will be huge thunks on the heap
08:09:18 * earthy nods
08:09:29 <pitecus> i have never used seq etc
08:09:44 <pitecus> could you give hint how to change the code?
08:10:34 <bringert> I think foldl' is the right function, but you also need to force the sums with seq
08:11:05 <earthy> foldl' or foldr doesn't much matter, but the sums *and* the call to similarity need to be forced
08:11:35 <diogo> one simple question
08:11:40 <bringert> unless similarity is strict already
08:11:50 <earthy> which I doubt. ;)
08:11:50 <diogo> a dylib file is a library?
08:11:53 <pitecus> Smth like that: ((+) 1 $! z, (+) z' $! s)) ?
08:12:03 <earthy> diogo: or a plugin, yes
08:12:30 <bringert> pitecus: you need to force the results of the additions, not the arguments
08:12:31 <diogo> so I need to specifie the dir where it is with -L commmand?
08:12:43 <bringert> + is strict in its arguments already
08:12:56 <allbery_b> dylib is a Mac OS X-style shared library, yes.  you may need -L option if it's nto in a standard place
08:13:48 <pitecus> bringert, let me try again: let x = 1 + z in x `seq` x
08:13:52 <diogo> ok
08:13:53 <diogo> eduroam055:~/Desktop/gtk2hs-0.9.10.3 diogo$ locate libjpeg.dylib
08:13:54 <pitecus> Would that work?
08:14:14 <diogo>   /opt/local/lib/libjpeg.dylib
08:14:28 <bringert> pitecus: yeah, that should do it
08:14:29 <diogo> and when I put this dir on -L
08:14:30 <diogo> Loading package gtk-0.9.10.3 ... can't load .so/.DLL for: jpeg (dlopen(libjpeg.dylib, 10): image not found)
08:14:44 <pitecus> ok thanks guys
08:14:45 <diogo> i don't understand
08:14:47 <pitecus> let me try it
08:14:48 <bringert> pitecus: you can still use $! I think, something like: (,) $! (z+1) $! (z'+1)
08:15:05 <pitecus> ok
08:15:07 <bringert> eh, got parens wrong though
08:15:24 <bringert> maybe using seq is better
08:17:20 <pejo> diogo, does it help if you add /opt/local/lib to DYLD_LIBRARY_PATH?
08:17:25 <allbery_b> hm.  that seems wrong but I'm not sufficiently u[p on how OSX searches for dylibs at runtime
08:18:14 <diogo> hm
08:18:32 <bringert> setting LD_LIBRARY_PATH helps I think
08:18:45 <diogo> how do I set that?
08:18:49 <pejo> bringert, they wisely call that DYLD_LIBRARY_PATH in osx.
08:19:08 <bringert> pejo: LD_LIBRARY_PATH seems to work for me
08:19:14 <bringert> for GHC
08:19:17 <bringert> which uses GNU tools
08:19:19 <pejo> bringert, on osx?
08:19:23 <bringert> pejo: yes
08:20:17 <bringert> pejo: at least, I have the line export LD_LIBRARY_PATH=/opt/local/lib:$LD_LIBRARY_PATH in my ~/.profile
08:20:36 <bringert> and ghc can find libs I installed with macports
08:21:03 <glguy> bringert: are you involved with the xhtml library
08:21:24 <bringert> glguy: yes. I just happend to see you bug report btw
08:21:34 <pejo> bringert, ghc installed via macports too?
08:21:40 <bringert> pejo: yes
08:21:59 <bringert> well, it also weems to work when I compile my own ghc
08:22:02 <bringert> seems
08:22:38 <bringert> glguy: send me a darcs patch and I'll push it. Include the bug ticket URL in the patch comment.
08:22:51 <glguy> bringert: ok
08:23:00 <glguy> what source do I need to darcs get
08:23:01 <bringert> maybe that wasn't your question :-)
08:23:15 <bringert> http://darcs.haskell.org/packages/xhtml/
08:23:17 <lambdabot> Title: Index of /packages/xhtml
08:23:17 <glguy> I was going to ask if you wanted me to do it or if it was easy enough for a maintainer
08:23:17 <pejo> bringert, I have neither set, and the ports still find it. Boggle.
08:23:49 <bringert> it is easy enough, but I have a long list of things to do
08:23:51 <pejo> bringert, I'm fairly sure I had trouble where LD_LIBRARY_PATH didn't work though.
08:23:56 <glguy> ok, I've got the source now
08:23:56 <bringert> hmm, ok
08:24:28 <diogo> still don't work
08:24:44 <diogo> added dir toi DYLD_LIBRARY_PATH and LD_LIBRARY_PATH
08:24:51 <bringert> diogo: did you reload your .profile?
08:24:59 <diogo> yes
08:25:23 <diogo> could be some problem with the file?
08:25:35 <diogo> but ghc says that can't find the file!
08:25:42 <sjanssen> @tell dons building Benchmark.hs with -fasm uses half as much memory and builds twice as fast.  Performance is just as good or better than -fvia-c
08:25:43 <lambdabot> Consider it noted.
08:25:54 <glguy> bringert: should I call it "thefor"?
08:26:17 <pejo> diogo, does -v3 or similar give any more hints?
08:26:27 <paolino> @help record syntax
08:26:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:26:44 <diogo> nop
08:26:49 <paolino> @docs record syntax
08:26:50 <lambdabot> record syntax not available
08:27:31 <allbery_b> hm.  I'm not sure how my macmini finds the dylibs, I have no special envars set but it seems to just work
08:27:52 <paolino> is record syntax helpful for pattern matching ?
08:27:59 <allbery_b> yes
08:28:19 <bringert> glguy: sounds good
08:28:29 <pitecus> Hm i have forced everything i could think of and memory usage is still the same...
08:28:55 <paolino> allbery_b: can you find me examples please ?
08:29:53 <paolino> is it good to avoid _ on big records , or else ?
08:29:55 <glguy> bringert: I didn't include the bugtracker URL in the comment... is there a way to remake the email bundle?
08:30:24 <waern> does anyone know where the repos for the data parallel haskell libraries are? if they are available
08:34:02 <earthy> fortunately we didn't loose an ICFP PC-member to the falling crane this morning.
08:34:53 <allbery_b> hm, don't have any examples but I have the report section describing how it works
08:35:13 <earthy> @where nph
08:35:13 <lambdabot> I know nothing about nph.
08:35:40 <earthy> @where ndp
08:35:40 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph
08:35:46 <earthy> that's what you're looking for, waern
08:35:49 <allbery_b> http://haskell.org/onlinereport/exps.html#pattern-matching see section 3.17.2 point 6
08:35:50 <lambdabot> Title: The Haskell 98 Report: Expressions
08:35:56 <paolino> allbery_b: found it
08:35:57 <paolino> http://www.ki.informatik.uni-frankfurt.de/doc/html/Haskell1.3/explain-13.html
08:36:01 <lambdabot> Title: Introducing Haskell 1.3, http://tinyurl.com/2krs8r
08:36:13 <allbery_b> 1.3?  seems a bit old :)
08:36:34 <paolino> eh, looks like a mile stone anyway
08:36:41 <paolino> thanks
08:37:36 <waern> earthy, thanks!
08:42:09 <kosmikus> helmut: hi there :)
08:42:46 <helmut> kosmikus: Hi. :-)
08:47:01 <JuanMarcus> hey, big channel =D
08:47:12 <malebria> @hoogle a -> Bool
08:47:13 <lambdabot> Char.isLatin1 :: a -> Bool
08:47:13 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
08:47:13 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
08:48:32 <JuanMarcus> hey i have a question
08:48:59 <allbery_b> ask
08:49:14 <JuanMarcus> how do i integrate haskell and c?
08:49:29 <JuanMarcus> couldn't find anything related...
08:49:30 <allbery_b> use the foreign function interface
08:49:52 <JuanMarcus> foreign function an
08:50:01 <JuanMarcus> that helps a lot, gonna check
08:50:05 <JuanMarcus> thanks
08:50:18 <allbery_b> @go haskell ffi
08:50:19 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
08:50:19 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
08:50:48 <bringert> glguy: use darcs amend-record or (darcs unrecord and then darcs record)
08:51:07 <JuanMarcus> cool =DD
08:51:35 <paolino> deleting a list of keys from a Set is better/same to delete one by one or form a Set of the key and difference ?
08:52:27 <paolino> *Set of the list
08:52:34 <glguy> so set the patch name to the url, or put that in the extended comments?
08:52:45 <glguy> (I emailed you the original dpatch)
08:58:51 <paolino> I suppose the complexity is the same, but I wonder if programming the delete injection in haskell is less efficient than using the library functions for that (fromList in this case)
08:59:03 <bringert> glguy, either. you could for example make the patch name somthing like: "Add 'for' attribute defined in HTML 4.0 (or whatever). Fixes http://hackage.haskell.org/trac/ghc/ticket/1104"
08:59:04 <lambdabot> Title: #1104 (Text.XHtml missing &#34;for&#34; attribute) - GHC - Trac
08:59:33 <bringert> glguy: it's not that important, it's just nice to have some connectiion between patches and tickets when possible
09:00:28 <vegai> hmm!
09:00:38 <diogo> i don't understand this...
09:00:51 <diogo> i run ghci with some commands
09:00:54 <vegai> project idea: a trac-like software with strong coupling to darcs
09:00:59 <diogo> Loading object (dynamic) jpeg ... done
09:01:03 <diogo> and then..
09:01:13 <diogo> Loading package gtk-0.9.10.3 ... can't load .so/.DLL for: jpeg (dlopen(libjpeg.dylib, 10): image not found)
09:02:15 <diogo> after load the damn lib it still gives me an error!
09:03:14 <pejo> vegai, isnt there anyone who has pondered making trac work with darcs?
09:03:47 <vegai> pejo: perhaps, but I have NIH syndrome ;)
09:04:08 <pejo> vegai, ah. I suffer from the reverse. WHIFM.
09:04:40 <pejo> Ups, missed an AI, WHAIIFM.
09:06:48 <malebria> Is there a way to do nested guards?
09:06:52 <malebria> @paste
09:06:52 <lambdabot> http://paste.lisp.org/new/haskell
09:06:58 <glguy> !paste
09:06:59 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
09:08:05 <lisppaste2> malebria pasted "guards" at http://paste.lisp.org/display/35578
09:09:25 <malebria> Just not to repeat things, in this example is silly, but not to repeat | x && y = ...; | x && z = ...; | x = ...;
09:10:31 <Igloo> malebria: No
09:13:14 <malebria> Igloo: any good alternative for this problem?
09:13:38 <allbery_b> I bet you could do something with TH
09:14:37 <malebria> What's TH?
09:14:46 <sjanssen> malebria: are you worried about evaluating an expensive test multiple times, or do you just want to avoid the extra typing?
09:15:01 <Igloo> I don't think there's a good general alternative
09:15:13 <malebria> sjanssen: is more avoid extra typing and improve code organization.
09:15:37 <pejo> malebria, Template Haskell.
09:15:53 <sjanssen> Template Haskell is bad advice here
09:15:57 <malebria> is like f a | a && b = ...; | a && c = ...; | a && d = ...; a = ...
09:16:39 <allbery_b> hey, I didn't say it was a *good* idea
09:17:07 * allbery_b doesn't generally suggest TH seriously
09:17:08 <bringert> malebria: f a | a = g; g | b = ...; | c = ...; ...
09:17:26 <malebria> bringert: this is a good alternative.
09:18:11 <sjanssen> malebria: you could also use the case/guard idiom
09:18:38 <malebria> sjanssen: what do you mean?
09:20:35 <lisppaste2> sjanssen annotated #35578 with "case/guard idiom" at http://paste.lisp.org/display/35578#1
09:22:44 <malebria> sjanssen: thanks...
09:22:56 <malebria> I think bringert option is the clearer.
09:25:44 <diogo> anyone here compiled gtk2hs with darwinports?
09:27:18 <bringert> in XML comments, do < and > have to be coded with entities?
09:27:37 <pejo> diogo, if you have an easy to reproduce problem I could start compiling it now while I go to work?
09:27:54 <diogo> i just can't compile it
09:28:03 <diogo> Could not find module `Data.FiniteMap':
09:28:08 <diogo> this is the error i get
09:28:24 <bringert> diogo: it's a GHC version problem
09:28:36 <bringert> GHC 6.6 does not come with Data.FiniteMap
09:28:40 <diogo> hm
09:28:43 <diogo> can I get it?
09:29:40 <vegai> there's Data.Map
09:31:20 <bringert> diogo: there must be a version of gtk2hs that compiles with GHC 6.6
09:31:38 <bringert> diogo: check with dcoutts
09:31:42 <allbery_b> dunno if they released it yet; the one in darcs works
09:31:52 <allbery_b> they're working on a new release
09:32:06 <bringert> diogo: ok, seems you need to get the darcs version then
09:32:29 <diogo> but when i get the darcs version it gives this error
09:33:05 <allbery_b> you need to run autoreconf on the darcs source before trying to build it
09:33:27 <diogo> don't forget that I have a "fabulous" mac intel!
09:33:38 <diogo> hm
09:33:44 <diogo> ok.. i'll try
09:33:50 <bringert> diogo: they are fabulous. mine is anyway :-)
09:33:53 <glguy> I'm pretty sure that I had gtk2hs installed from macports on my ppc powerbook
09:34:13 <allbery_b> if the stock autoreconf doesn't work, you may need to install autoconf/automake/libtool from macports
09:34:26 <allbery_b> (but I think you get those when installing anything in macports that's autoconf-ed...)
09:34:30 <diogo> bringert: i can't get anything working here..
09:34:41 <diogo> i'm sure i am the problem..
09:34:43 <diogo> :)
09:35:14 <bringert> diogo: well, not all libraries are released in GHC 6.6 friendly versions yet
09:35:51 <glguy> I've used gtk2hs on ghc 6.6 on windows
09:35:54 <glguy> but the install isn't easy yet
09:36:50 <diogo> how do I autoreconf the source?
09:37:50 <allbery_b> run autoreconf
09:37:54 <allbery_b> doesn't need arguments
09:37:54 <diogo> with configure command?
09:37:55 <fasta> heh
09:38:00 <diogo> hm
09:38:04 <fasta> diogo: autoreconf is a command
09:38:05 <allbery_b> configure won't work until autoreconf is run
09:38:28 <fasta> diogo: (as described in the building docs)
09:38:34 <allbery_b> the darcs source doesn't include generated files like configure, Makefile.in (generated from Makefile.am), etc.
09:38:46 <allbery_b> autoreconf runs all the stuff needed to generate those files
09:39:25 <diogo> but i have done it...
09:39:46 <diogo> you are sayning to aureconfig the darcs source or the source of gtk2hs from darcs?
09:40:11 <olifante> newbie here: is it impossible to add new names to the interactive namespace? For instance, can I define a new function in the hugs interpreter without having to use the "let f = .... in f 10"?
09:40:26 <allbery_b> the gtk2hs source obtained from darcs
09:40:38 <allbery_b> olifante: no
09:40:38 <diogo> and i use the fetch command to that.. right?
09:40:55 <allbery_b> with ghci you can say "let f = ..." without an "in ..."
09:41:06 <allbery_b> @where gtk2hs
09:41:07 <lambdabot> http://haskell.org/gtk2hs/
09:41:17 <allbery_b> darcs get http://haskell.org/gtk2hs
09:41:18 <lambdabot> Title: Gtk2Hs
09:41:20 <allbery_b> cd gtk2hs
09:41:21 <allbery_b> autoreconf
09:41:23 <allbery_b> configure
09:41:36 <diogo> ok..
09:41:44 <diogo> i was confusing everything
09:41:47 <allbery_b> hm, wrong URL
09:41:52 <diogo> darcs with darwin port
09:42:00 <allbery_b> http://darcs.haskell.org/gtk2hs I think
09:42:02 <lambdabot> Title: Index of /gtk2hs
09:42:04 <allbery_b> yeh
09:42:14 <olifante> allbery_b: thanks for the clarification. Coming from Python and Ruby, it's something of a disappointment
09:42:36 <olifante> how about multiline commands in the interpreter?
09:43:02 <olifante> how do I use a let block to define multipattern / multiguard functions?
09:43:07 <allbery_b> olifante: haskell is hard to incrementally compile, since type inference in some function can affect functions declared anywhere else in the current module
09:43:40 <earthy> let { foo 1 = 2; foo 2 = foo 1 } in foo 2
09:43:41 <paolino> !paste
09:43:42 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
09:43:42 <sjanssen> olifante: you can use ; instead of a newline to type multiline defns
09:43:47 <earthy> > let { foo 1 = 2; foo 2 = foo 1 } in foo 2
09:43:48 <lambdabot>  2
09:44:31 <olifante> Yeah, I know about the semicolon, but how can I use the pipe character to interactively define functions with guards, for example?
09:44:54 <glguy> > let f x | x == 1 = 2 | otherwise = 3 in f 1
09:44:55 <lambdabot>  2
09:45:02 <bringert_> olifante: you can add new names in the interpreter
09:45:12 <olifante> how?
09:45:14 <allbery_b> bringert_: he's using hugs
09:45:25 <olifante> yes
09:45:26 <bringert_> oh, use ghci
09:45:38 <earthy> or winhugs
09:45:44 <earthy> if you're on windows
09:46:03 <hpaste>  paolino pasted: missing prelude funcions at http://fserv.pikapphi.umr.edu:8000/3
09:46:04 <earthy> reloading is one click then
09:46:05 <olifante> I'm actually using winhugs on windows and hugs inside a ubuntu virtual machine
09:46:13 <glguy> winhugs doesn't support definitions in window
09:46:20 <olifante> oh
09:46:25 <earthy> glguy: I know, but it does support reloading with 1 click
09:46:31 <olifante> but linux hugs does?
09:46:33 <earthy> so you can have an editor runnign alongside
09:46:35 <Saizan> or emacs and reloading is C-c C-l
09:46:40 <earthy> yeah
09:46:43 <glguy> ghci support reloading by typing   :
09:46:54 <bringert_> olifante: so, just have a foo.hs file where you type your code, and reload it
09:47:03 <bringert_> (just clarifying)
09:47:04 <olifante> yeah, I was able to configure the haskell minor mode
09:47:04 <earthy> I should figure out if vimsh is useful
09:47:05 <allbery_b> you can reload in hugs but you can't do interactive definitions inline.
09:47:20 <allbery_b> ghci lets you do:  let f x = whatever
09:47:30 <allbery_b> (but you'll lose all such definitions when you :reloac)
09:47:35 <allbery_b> er, :reload
09:47:54 <olifante> allbery_b: but is f available outside the scope of the let block?
09:47:57 <musasabi> class aliases seem more and more attractive each passing day. Writing a few lines of class dependencies is not fun.
09:48:08 <allbery_b> without an "in" it's not a block
09:48:19 <allbery_b> think of the ghci prompt as being inside a big "do"
09:48:20 <olifante> oh, right
09:48:24 <olifante> yeah
09:48:33 <glguy> in ghci , ":" is a synonym for ":reload"
09:48:56 <vegai> whoa, really?
09:49:12 <olifante> besides this advantage, what are the main advantages of ghci over hugs?
09:49:25 <glguy> better type inference
09:49:27 <allbery_b> hugs doesn't implement some features
09:49:37 <bos31337> bigger library, more language extensions.
09:49:49 <allbery_b> (it does the entire H98 standard but there's lots of useful stuff not covered by H98)
09:49:49 <glguy> it compiles
09:50:07 * allbery_b thinks the error messages, while initially intimidating, are more useful
09:50:36 <allbery_b> it gies you a lot more information about what happened, whhich makes it easier to figure out what/where the problem is
09:50:51 <chessguy> hmm, i wonder if there's a more....family-friendly version of something like http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
09:50:52 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki
09:50:58 * paolino hugs hugs
09:51:27 <glguy> ?type foldject = foldl $ flip ($) in foldject
09:51:29 <lambdabot> parse error on input `='
09:51:41 <glguy> ?type foldject = foldl ( flip ($)) in foldject
09:51:43 <lambdabot> parse error on input `='
09:51:48 <glguy> ?type let foldject = foldl ( flip ($)) in foldject
09:51:49 <allbery_b>  ?typ let ...
09:51:50 <lambdabot> forall b. b -> [b -> b] -> b
09:51:56 <glguy> ?type let foldject = foldl $ flip ($) in foldject
09:51:57 <lambdabot> forall b. b -> [b -> b] -> b
09:53:06 <paolino> can't work with mutable things without them
09:53:24 <paolino> Set,Map,Array ...
09:53:41 <glguy> what can't work
09:53:48 <paolino> I
09:53:57 <paolino> :)
09:54:21 <glguy> example code?
09:54:33 <Saizan> > let fact n = let foldject = foldl $ flip ($) in foldject 1 $ map (*) [1..n] in fact 5 -- we have found another funny way to write fact
09:54:35 <lambdabot>  120
09:55:08 <paolino>  foldject [populate [(1,10),(4,5)],tick,add 2 3,tick,add 3 3] Main.empty
09:55:08 <paolino> Friends {sorteds = {(3.0,2),(3.0,3),(5.0,4),(10.0,1)}, db = {1:=(10.0,2),2:=(3.0,1),3:=(3.0,0),4:=(5.0,2)}}
09:55:58 <allbery_b> oh, he's talking about his "missing prelude functions" paste earlier
09:56:02 <allbery_b> I think
09:56:03 <glguy> yeah
09:56:07 <glguy> that's what I pasted out of
09:56:29 <glguy> (populate [(1,10),(4,5)] >>> tick >>> add 2 3 >>> tick >>> add 3 3) Main.empty
09:56:50 <paolino> ah
09:57:01 <paolino> :t (>>>)
09:57:02 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
09:57:12 <glguy> or:
09:57:39 <glguy> add 3 3 . tick . add 2 3 . tick . populate [(1,10),(4,5)] $ Main.empty --- obviously
09:57:55 <SyntaxNinja> y0
09:58:09 <hpaste> y0
09:58:11 <paolino> populate kvs fs = foldject (List.map (uncurry add) kvs) fs
09:59:36 <bringert> hi SyntaxNinja
09:59:48 <SyntaxNinja> yo bjorn.
09:59:49 <glguy> foldl (\x (a,b) -> add a b x) fs kvs
09:59:55 <glguy> paolino: that?
10:00:12 <SyntaxNinja> hey, if sigbjorn means "victorious bear", how would one say "failure bear", just out of curiosity, in case I wanted to make fun
10:00:14 <paolino> yes
10:00:31 <Saizan> ?type sequence
10:00:31 <bringert> SyntaxNinja, maybe "felbjorn"
10:00:33 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
10:00:38 <bringert> or "feilbjorn"
10:00:59 <bringert> though "sig" there is an older mer german-like form
10:01:06 <Saizan> ?type foldM
10:01:07 <bringert> s/mer/more/
10:01:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:01:30 <SyntaxNinja> is "mer" also an older mer german form?
10:01:32 <SyntaxNinja> ;)
10:01:41 <SyntaxNinja> those mer germans were somethin'
10:01:51 <bringert> yes
10:02:47 <bringert> SyntaxNinja: I guess the opposite of "sieg" would be "niederlag". so maybe "niderlagbjorn"
10:03:02 <bringert> maybe with -s-
10:03:04 <paolino> :t foldl (>>>)
10:03:05 <lambdabot> forall (a :: * -> * -> *) b d. (Arrow a) => a b d -> [a d d] -> a b d
10:03:43 <bringert> I can ask a colleague who works on implementing ancient nordic morphology in haskell
10:04:39 <paolino> > foldl (>>>)  0 (map (+) [1..5])
10:04:40 <lambdabot>   add an instance declaration for (Num (b -> d))
10:05:31 <glguy> paolino: in a case like this, I'm pretty sure that if you are mapping to create a list of partial applications, you are making the problem too hard :-p
10:05:46 <paolino> > foldl1 (>>>)  (map (+) [1..5]) $ 0
10:05:47 <lambdabot>  15
10:05:55 <paolino> :-P
10:07:05 <paolino> mmhh, that's not hard, it reflects the way we think about building things
10:07:14 <SyntaxNinja> bringert cool. thanks ;)
10:08:16 <paolino> half the step towards monads
10:08:23 <glguy> paolino: or making it harder than it needs to be, one or the other ;)
10:08:32 <paolino> true
10:09:41 * bringert goes home
10:10:01 * SyntaxNinja waves at bringert
10:12:30 * kolmodin is home
10:16:41 <kolmodin> dons: any luck with the rules?
10:18:06 <diogo> if something can happen.. it happens to me!
10:18:15 <diogo> i dowload
10:18:23 <diogo> i download gtk2hs from darcs
10:18:33 <diogo> but autoreconf gives an error
10:18:53 <allbery_b> what error?
10:18:54 <allbery_b> @paste
10:18:55 <lambdabot> http://paste.lisp.org/new/haskell
10:18:58 <glguy> !paste
10:18:59 <glguy> !
10:18:59 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
10:19:08 <allbery_b> heh
10:19:08 <diogo> configure.ac:117: error: possibly undefined macro: AC_MSG_ERROR
10:19:13 <glguy> heh
10:19:15 <diogo>       If this token and others are legitimate, please use m4_pattern_allow.
10:19:43 <allbery_b> hm, you may have an outdated autoconf
10:19:53 <diogo> i have version 2.54
10:20:01 <diogo> 2.59
10:21:33 <diogo> i think is the last
10:22:05 <allbery_b> I think you need to wait for dcoutts_ to show up
10:22:49 <diogo> this is a message from god: don't do this project..
10:22:54 <diogo> nothing works
10:23:23 * allbery_b is trying to recall if gtk2hs is even supported on OSX
10:23:33 <allbery_b> ...last I heard, gtk2 was squirrelly
10:24:35 <diogo> so the solution is to install some linux or windows..
10:27:53 <kolmodin> diogo: works for me, I have autoconf 2.13 and 2.61
10:28:15 <diogo> and a mac intel?
10:28:23 <kolmodin> diogo: no, x86 intel :)
10:28:49 <diogo> and can you see the version of aclocal?
10:29:09 <astrolabe> No definitions were found for  squirrelly.
10:29:46 <dmhouse> Gah, damned Haskell. I keep misreading the word 'command' as 'comonad'.
10:30:02 <allbery_b> that's nto haskell's fault.  sigfpe, maybe :)
10:30:10 <kolmodin> diogo: I have tons of versions of automake, I run gentoo
10:30:16 <dmhouse> allbery_b: hehe, perhaps.
10:31:01 <diogo> and how do you choose the version to use?
10:31:56 <diogo> uff
10:31:59 <diogo> i made
10:32:07 <diogo> looks like it was my aclocal version
10:32:15 <diogo> i have the last but it was using the older
10:32:51 <diogo> so much to learn...
10:33:29 <Jaak> is IntMap ByteString test supposed to fail in binary? :\
10:33:53 <kolmodin> diogo: I don't, It Just Works (tm)
10:34:17 <joelr1> good day
10:34:31 <kolmodin> hia joelr1
10:34:57 <sjanssen> Jaak: none of the tests are supposed to fail, as far as I know
10:35:43 <sjanssen> Jaak: it passes over here.  Do you have the latest darcs version?
10:36:44 <Jaak> i have 1.0.8-rc1
10:36:52 <Jaak> or whatever gentoo has
10:36:54 <kolmodin> Jaak: no, they should all succeed
10:37:26 <Jaak> maybe something to do with 64bit system?
10:37:50 <kolmodin> Jaak: which input did it fail on?
10:38:03 <Jaak> {-3:="y\216",-1:="",3:="\US"}
10:38:05 <sjanssen> Jaak: 64bit problems are quite possible
10:38:21 <dmhouse> ?src Cont >>=
10:38:21 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:38:24 <dmhouse> ?src Cont (>>=)
10:38:25 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
10:38:36 <dmhouse> ?hoogle runCont
10:38:36 <lambdabot> Control.Monad.Cont.runCont :: Cont r a -> ((a -> r) -> r)
10:38:37 <lambdabot> Control.Monad.Cont.runContT :: ContT r m a -> ((a -> m r) -> m r)
10:38:46 <bitshftr> Is there a way to change the bounds of an IOUArray?  (I do know the operation would be unsafe and could kill babies.)
10:39:23 <chessguy> maybe you need Control.Population
10:40:27 <sjanssen> bitshftr: you want to make the array hold more elements?
10:40:45 <sjanssen> or do you want to change the bounds from (0, 10) to (10, 20)?
10:41:03 <kolmodin> Jaak: how many tests before it failed?
10:41:14 <kolmodin> of IntMap ByteString, I mean
10:41:25 <bitshftr> Both kinda, I'm casting an IOUArray from holding say Word32 to Word8
10:41:26 <Jaak> none
10:41:26 <huschi> is it possible to declare a type synonym with a class constraint?
10:41:39 <kolmodin> Jaak: ok
10:41:45 <huschi> e.g. type ShowFunction = Show a => a -> a
10:41:47 <astrolabe> I think so huschi
10:41:52 <allbery_b> huschi: with -fgasgow-exts, but you don't want to do that
10:41:56 <bos31337> wow, programming.reddit.com has rapidly gone from about 20% interesting to about 0%
10:42:00 <allbery_b> glasgow-exts
10:42:00 <bitshftr> the number of "elements" quadruples in that case
10:42:09 <kolmodin> Jaak: have you a recent version of binary?
10:42:18 <Jaak> yes, just pulled
10:42:19 <huschi> allbery_b: why do i not want it?
10:42:24 <kolmodin> Jaak: ok
10:42:30 <bitshftr> I want to go from 0,19 -> (0,22)
10:42:32 <allbery_b> the problem is that the constraint is expandfed in place, and therefore does not match any other constraint in the declaration it's used in
10:42:42 <kolmodin> Jaak: all tests work for me.. gimme a minute
10:42:52 <sjanssen> bitshftr: poke around in Data.Array.Base
10:42:52 <huschi> allbery_b: i know.
10:43:07 <joelr1> bos31337: how so?
10:43:31 <bitshftr> sjanssen: thanks
10:43:50 <huschi> allbery_b: but if i use it as a parameter the restriction applies? or am i wrong?
10:44:00 <huschi> only as a single parameter.
10:44:37 <allbery_b> you cn get away with it then.  just be aware that if you ever change your mind you will suddenly be faced with bizarre type errors
10:44:51 <kolmodin> Jaak: you run ghc 6.6, I suppose?
10:44:59 <bos31337> joelr1: it's all web/xml/ruby/php/not programming at all
10:45:06 <huschi> i only wan't to use it to restrict the range.
10:45:09 <Jaak> nope, 6.4.2
10:45:14 <kolmodin> ok
10:45:31 <kolmodin> Jaak: so which version of the fps package do you have?
10:46:11 <huschi> allbery_b: i only wan't to use it to restrict the range of possible argument types.
10:46:21 <kolmodin> ghc-pkg list fps        <-- this will tell you
10:46:39 <Jaak> fps-0.8
10:46:46 <kolmodin> ok.. hmmm..
10:46:57 <kolmodin> weird?
10:47:26 <huschi> allbery_b: but hugs doesn't like it. am i right?
10:47:31 <allbery_b> right
10:47:37 <huschi> ok. i won't use it :)
10:47:46 <allbery_b> well, possibly it'd take it in -98 mode, not sure
10:47:58 <huschi> no, also not in -98 mode.
10:48:28 <Jaak> yeah, i guess so :)
10:48:40 <astrolabe> huschi: you might have the syntax wrong
10:49:24 <Wild-[]-Duck> hi, i would like to do map Char.toUpper "Test" but i get every time error - undefined qualified variable "Char.toUpper". i use winhugs for programming
10:49:56 <Wild-[]-Duck> im a noob i have to say ;)
10:50:10 <Jaak> load Data.Char
10:50:17 <astrolabe> huschi: Ah no, you can't do it :?
10:50:22 <Cale> :also Data.Char
10:50:35 <Cale> I think is the command to do that in hugs
10:50:50 <kolmodin> Jaak: and no other tests fail?
10:50:54 <Jaak> nope
10:50:56 <Wild-[]-Duck> i try thanks
10:50:58 <Cale> then you shouldn't need the Char.
10:51:06 <Cale> map toUpper "Test"
10:51:09 <Cale> should work
10:51:39 <sjanssen> kolmodin: has binary been tested with GHC 6.4.2 on a 64 bit platform?
10:51:53 <chessguy> Cale, did you see this yet? http://www.haskell.org/haskellwiki/Haskell/Lazy_Evaluation
10:51:55 <lambdabot> Title: Haskell/Lazy Evaluation - HaskellWiki
10:51:57 <kolmodin> sjanssen: not that I know of
10:52:12 <Wild-[]-Duck> thanks it works
10:52:23 <diogo> sorry to be so noob... but anyone here know how to compile happy?!
10:52:36 <diogo> i don't find any doc explaining that..
10:52:37 <Cale> chessguy: cool
10:52:38 <kolmodin> so the Int test and ByteString tests are ok, but the IntMap fails. hmm
10:52:49 <tuukkah> ghci seems to automatically import qualified modules when you refer to them
10:52:56 <chessguy> diogo, smile while you type.....oh, never mind
10:53:08 <Jaak> kolmodin: actually, i can't "make compiled", it fails saying that it couldn't find Data.ByteString.Base
10:53:57 <kolmodin> Jaak: I run fps-0.8 (darcs version) on my ghc 6.4.2 machine and that works nice
10:54:02 <allbery_b> ghci and hugs both will import things if you tell them to.  if you don't, you will get that error
10:54:17 <allbery_b> probably want to import Data.Char in the program, instead of just using :also
10:54:43 <tuukkah> allbery_b, i'm saying in ghci you don't get that error
10:55:18 <kolmodin> Jaak: you must run darcs version of fps too then?
10:55:53 <tuukkah> automation is of course convenient, but yet another thing how ghci is different from "haskell"
10:55:54 <Jaak> yeah
10:57:02 <kolmodin> would you mind to try running the test manually?
10:57:04 <Jaak> i have really strange configuration tho', darcs stuff is installed to ~/usr/ but still "registred" with root
10:57:09 <allbery_b> huh.  seems a bit wrong to me
10:57:17 <allbery_b> maybe it's imported y default, btu qualified
10:57:54 <Jaak> manually?
10:57:57 <kolmodin> Jaak: fps is installed to ~/usr/ ?
10:58:29 * kolmodin reinstalled fps
10:59:12 <kolmodin> try running the test that failed by hand
11:00:37 <kolmodin> Jaak: ghci -package binary ; :m +Data.Binary ; :m +Data.ByteString.Char8
11:00:45 <Jaak> sec
11:00:54 <kolmodin> encode (fromList [(-3,pack "y\216"),(-1,pack ""),(3,pack "\US")])
11:01:13 <kolmodin> decode (encode (fromList [(-3,pack "y\216"),(-1,pack ""),(3,pack "\US")])) :: IntMap ByteString
11:04:13 <tuukkah> allbery_b, ok: "To make life slightly easier, the GHCi prompt also behaves as if there is an implicit import qualified declaration for every module in every package, and every module currently loaded into GHCi."
11:04:16 <Jaak> second one gives me: {-5188146770730811389:="\US",-3:="y\216",-1:=""}
11:05:02 <kolmodin> Jaak: yeah, that isn't right
11:05:43 <sjanssen> Jaak: what does only the fromList part yield?
11:05:54 <kolmodin> Jaak:  decode ( encode (-3::Int) ) :: Int
11:06:29 <sjanssen> fromList [(-3,pack "y\216"),(-1,pack ""),(3,pack "\US")] -- this, to be specific
11:06:59 <Jaak> -3
11:07:11 <kolmodin> ok, try sjanssen's :)
11:07:18 <Jaak> {-3:="y\216",-1:="",3:="\US"}
11:07:20 <Jaak> :)
11:07:26 * kolmodin is lost :)
11:07:31 <Lemmih> @seen shapr
11:07:32 <lambdabot> shapr is in #haskell-blah, #scannedinavian, #unicycling and #haskell. I last heard shapr speak 2h 27m 32s ago.
11:08:28 <kolmodin> ok, I'm out of ideas
11:08:39 <sjanssen> Jaak: decode (encode [(-3 :: Int,pack "y\216"),(-1,pack ""),(3,pack "\US")]) :: [(Int, ByteString)]
11:08:49 <kolmodin> you said that make compiled didn't work either?
11:09:00 <Jaak> [(-3,"y\216"),(-1,""),(-5188146770730811389,"\US")]
11:09:03 <Jaak> yeah
11:09:05 <kolmodin> ah
11:09:09 <Jaak> i couldnt build it
11:09:21 <sjanssen> kolmodin: the problem is really in the [] instance, then
11:09:24 <Jaak> but thats prolly my fail or something
11:09:37 <Jaak> fault*
11:09:49 <kolmodin> sjanssen: hmm, there are a bunch of other [] stuff that works
11:11:18 <sjanssen> Jaak: decode (encode [(-3 :: Int,pack "y\216"),(-1,pack "padding"),(3,pack "\US")]) :: [(Int, ByteString)]
11:12:08 <Jaak> works correctly
11:12:17 <kolmodin> empty bytestrings?
11:12:31 <sjanssen> kolmodin: apparently
11:12:42 <sjanssen> or at least empty bytestrings in tuples in lists
11:13:00 <kolmodin> hah, yeah
11:13:12 <kolmodin> altohugh, it _shouldn't_ matter
11:13:25 <kolmodin> I guess that's why we have tests
11:13:38 <Jaak> decode (encode [pack "",pack "\US"]) :: [ByteString] => ["","*** Exception: Data.Binary.Get.takeExactly: Wanted -5188146770730811391 bytes, found 0.. Failed reading at byte position -5188146770730811367
11:14:05 <kolmodin> I really doubt that it wanted -5188146770730811391 bytes :D
11:14:16 <Jaak> :)
11:15:07 <kolmodin> ok, the get monad was rewritten today, something might have happened
11:16:05 <sjanssen> strangely, this doesn't break on regular x86
11:16:24 <kolmodin> sjanssen: could be that Int's are 64bit on 64bit machines, perhaps
11:16:32 <kolmodin> easy to get it wrong somewhere
11:17:51 <kolmodin> Jaak: decode (encode (pack "")) :: ByteString
11:17:57 <Jaak> that works
11:18:02 <kolmodin> Jaak: decode (encode (pack "hia")) :: ByteString
11:18:05 <kolmodin> :)
11:18:25 <Jaak> same
11:18:27 <sjanssen> it'd be nice to see encode (pack "hia") too
11:18:36 <sjanssen> and encode (pack "")
11:18:41 <Jaak> LPS ["\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX","hia"]
11:18:45 <Jaak> hm
11:18:57 <Jaak> and: LPS ["\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL",""]
11:19:26 <sjanssen> kolmodin: LPS shouldn't contain empty bytestrings
11:19:35 <kolmodin> sjanssen: argh!
11:19:36 <sjanssen> that's one of the invariants of the library
11:19:53 <kolmodin> ok, I'll get right to it
11:20:00 <sjanssen> I bet something stupid like head or tail breaks
11:20:16 <diogo> I give up.. see you tomorrow
11:21:19 <kolmodin> weird that it worked for me?
11:21:34 <araujo> hello
11:21:38 <kolmodin> hia araujo !
11:21:48 <araujo> kolmodin!!!
11:21:49 <araujo> :-)
11:21:55 <kolmodin> :D
11:24:26 * kolmodin gets some more food
11:36:18 <tuukkah> hmm
11:37:35 <ohmega> should () be considered as a type with only one element?
11:37:46 <glguy> yes
11:37:51 <Excedrin> no
11:37:54 <kolmodin> depends
11:37:57 <glguy> lol
11:37:59 <ohmega> :D
11:38:04 <glguy> basically: data () = ()
11:38:06 <kolmodin> haha :D
11:38:14 <kolmodin> but it could be _|_
11:38:22 <shapr> But every element has bottom as well!
11:38:24 <allbery_b> technically it's a type with two possible values:  () and _|_
11:38:25 <shapr> kolmodin: You beat me to it!
11:38:29 <kolmodin> shapr: yay :)
11:38:34 <ohmega> hm
11:38:51 <kolmodin> that should go to the hwn quote thingie
11:38:55 <kolmodin> yes. no. depends
11:38:57 <ohmega> it is _|_ until you evaluate it?
11:39:02 <glguy> kolmodin: they mean that both  ( () :: () ) and ( undefined :: () )
11:39:45 <shapr> undefined is surprisingly useful.
11:39:52 <kolmodin> glguy: yes?
11:40:06 <glguy> oh
11:40:10 <glguy> ohmega: ^^
11:40:15 <glguy> whatever, he know
11:40:16 <glguy> knew*
11:41:02 <bd_> ohmega: it's either _|_ or (), you just don't know which until you evaluate it :)
11:42:10 <bd_> coincidentally, the semantics for the bottom look a lot like throwing exceptions down the call stack, but of course we don't believe in 'call stacks' when writing the semantics for haskell ;)
11:43:27 <allbery_b> well, except when the semantics for _|_ look a lot like an infinite loop :)
11:44:18 <tuukkah> the variety of bottoms
11:45:26 <ski> another view is that unforced thunks is '_|_'
11:45:52 <ski> so '_|_' would then mean "not (yet) evaluated"
11:46:20 <ski> and the '_|_' of above would be something that we wait and wait on, but it never delivers a value
11:48:31 <bd_> Or wait on it, and it delivers no value, in finite time :)
11:48:39 <ski> iirc 'hat' denotes this by '_'
11:50:27 <tuukkah> would it be useful to distinguish between synchronous and asynchronous bottoms. (error s) is of the first type and out-of-memory is of the second kind. are all asynchronous bottoms asynchronous exceptions?
11:53:47 <bd_> Distinguish?
11:54:01 <bd_> Once it hits IO you can catch the exception, and examine it to see what happened
11:54:09 <sjanssen> I'm not sure that OOM is actually bottom
11:54:42 <bd_> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#1
11:54:43 <lambdabot> http://tinyurl.com/yk8zqb
11:54:58 <tuukkah> bd_, yeah, but if we're discussing which "kinds of bottoms" exist
11:55:31 <pejo> sjanssen, if it is then your semantics needs to be parametrized on available memory, I'd say.
11:55:31 <wy> Hi all
11:55:52 <pejo> (And would unplugging the computer be bottom too, although the computation obviously stops for a totally different reason?)
11:56:00 <bd_> One way to view it is there's a continuum (sp?) of bottoms, some of which you can identify in IO, others which you can't (eg, infinite loop)
11:56:29 <sjanssen> bottoms and execeptions aren't the same thing
11:56:34 <bd_> OOM, rather than being the bottom, then, would be simply IO reading the 'available memory' field of RealWorld, determining via its oracle that it's not enough to proceed, and throwing an exception :)
11:57:36 <wy> what are bottoms
11:57:58 <allbery_b> failed computations of various kinds
11:57:59 <bd_> [though GHC doesn't actually throw exceptions on OOM apparently]
11:58:05 <pejo> Why do we want more bottoms anyways?
11:58:17 <wy> I think it's just a mathematical concept, is due to make up a theory.
11:58:25 <tuukkah> bd_, docs say "StackOverflow and HeapOverflow are two examples of system-generated asynchronous exceptions."
11:58:58 <bd_> tuukkah: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#1 "GHC currently does not throw HeapOverflow exceptions."
11:58:59 <lambdabot> http://tinyurl.com/yk8zqb
11:59:18 <bd_> the bottom, per se, would be when the (pure) value of an expression is undefined, no matter what the IO state is
11:59:31 <tuukkah> bd_, same page, different section =)
11:59:37 <bd_> anything else would be an exception arising from the IO state...
12:00:32 <tuukkah> so there are bottoms that are not exceptions and exceptions that are not bottoms
12:00:59 <pejo> (Wasn't the whole idea with "FAst and Loose reasoning is morally correct" to be able to avoid reasoning about bottoms?)
12:01:09 <bd_> pretty much, though I expect you could cast any exception into a bottom, using GHC.Prim in the worst case
12:01:26 <bd_> pejo: Well, I don't usually think too hard about bottoms when actually coding, but metaphysics is fun from time to time
12:01:45 <hpaste>  glguy pasted: segments to polygon at http://fserv.pikapphi.umr.edu:8000/4
12:01:55 <ski> hat examples one can try : 'observe "undefined" undefined','error (observe "msg" "foo")','fix (observe "fix")'
12:01:55 <pejo> bd, hence why I said "reasoning".
12:02:11 <tuukkah> in systems like lambdabot i assume you have to take care of the specifics of bottoms
12:02:30 <glguy> bottoms can't be detected in your code
12:02:37 <glguy> without catch in IO
12:02:47 <tuukkah> so they can with catch in IO...
12:02:49 <bd_> tuukkah: To isolate them, you do need some awareness, yeah. You don't want > 1 / 0 to crash the bot :)
12:02:56 <bd_> But it's not usually at the forefront of one's mind
12:03:00 <bd_> they're mostly used to formalize laziness
12:03:04 <bd_> in the spec
12:03:58 <tuukkah> Prelude.catch: "Non-I/O exceptions are not caught by this variant; to catch all exceptions, use catch from Control.Exception."
12:04:41 <pejo> bd, doesn't 1/0 throw an exception though?
12:05:10 <tuukkah> so if ghc doesn't throw HeapOverflow exceptions, a heap overflow will kill lambdabot?
12:05:30 <tuukkah> pejo, so that would be a bottom that is an exception
12:05:57 <bd_> tuukkah: lambdabot spawns a new process to handle evals for this reason, I think. (might be wrong...)
12:06:00 <bd_> Prelude Control.Exception> ((return . Right) $! undefined) `Control.Exception.catch` (return . Left)
12:06:03 <bd_> Left Prelude.undefined
12:06:03 <nornagon> > 1/0
12:06:05 <lambdabot>  Infinity
12:06:20 <tuukkah> > 1 ` div` 0
12:06:21 <lambdabot>  Exception: divide by zero
12:06:39 <bd_> Prelude Control.Exception> ((return . Right) $! (1 `div` 0)) `Control.Exception.catch` (return . Left)
12:06:43 <bd_> Left divide by zero
12:06:46 <bd_> like that :)
12:09:22 <pejo> tuukkah, I must admit I find it rather confusing talking about bottoms that are exceptions. I should probably ponder it some.
12:09:24 <Lemmih> Prelude Control.Exception> try . evaluate $ div 1 0
12:09:24 <Lemmih> Left divide by zero
12:10:38 <Saizan> ?type try
12:10:39 <lambdabot> Not in scope: `try'
12:10:49 <Saizan> ?type Control.Exception.try
12:10:51 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
12:10:58 <dmhouse> Hrm, I'm rubbish at thinking up examples.
12:11:20 <dmhouse> > try (1 `div` 0)
12:11:21 <lambdabot>   Not in scope: `try'
12:11:29 <dmhouse> > Control.Exception.try (1 `div` 0)
12:11:30 <lambdabot>   Not in scope: `Control.Exception.try'
12:12:08 <Lemmih> dmhouse: (1 `div` 0) isn't an IO action.
12:12:24 <dmhouse> Oh, gotcha.
12:12:55 <tuukkah> so we might say that pure code has bottoms and io code has exceptions, and evaluate turns the first kind into the second kind?
12:12:56 <dmhouse> So how does evaluate work? It forces its argument to WHNF, but invokes ioError when its argument is _|_?
12:13:04 <dmhouse> Prelude Control.Exception> try (return $ 1 `div` 0)
12:13:05 <dmhouse> Right *** Exception: divide by zero
12:13:05 <dmhouse> Prelude Control.Exception> try (evaluate $ 1 `div` 0)
12:13:05 <dmhouse> Left divide by zero
12:13:07 <dmhouse> There's a difference there.
12:14:20 <pejo> dmhouse, I think the semantics of exceptions are that you have a set of exceptions, and the implementation might select any of them.
12:14:37 <hpaste>  glguy pasted: clearing up for non haskell programmers, maybe at http://fserv.pikapphi.umr.edu:8000/4#1
12:14:37 <bd_> dmhouse: evaluate _|_ = _|_; _|_ in IO throws an exception, when it's possible to do so
12:15:16 <bd_> dmhouse: on the other hand, return _|_ =/= _|_
12:15:20 <dmhouse> Ah, okay.
12:15:37 <bd_> so for example this is totally okay: return undefined >> return 42
12:15:48 <bd_> whereas this is an exception: evaluate undefined >> return 42
12:17:02 <dmhouse> Indeed:
12:17:03 <dmhouse> Prelude Control.Exception> undefined >> putStrLn "hello"
12:17:03 <dmhouse> *** Exception: Prelude.undefined
12:17:03 <dmhouse> Prelude Control.Exception> return undefined >> putStrLn "hello"
12:17:05 <dmhouse> hello
12:18:29 <bd_> evaluate = (return =<<) . (return $!), I believe
12:19:16 <nornagon> ?src evaluate
12:19:16 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
12:19:30 <nornagon> ?. pl src evaluate
12:19:30 <lambdabot> (line 1, column 1):
12:19:30 <lambdabot> unexpected end of input
12:19:30 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:19:46 <bd_> nornagon: (# #) is a ghc extension
12:19:54 <nornagon> i see.
12:20:02 <bd_> and you're peering into the heart of IO there :)
12:22:07 <dmhouse> (# , #) is an 'unboxed pair', so its values will be stored in memory as the values themselves, rather than pointers to values.
12:22:08 * heatsink is getting a Prelude.head: empty list error, but it's in the FGL library.
12:22:42 <beschmi> ?src rwhnf
12:22:42 <lambdabot> Source not found. Are you on drugs?
12:23:44 <dmhouse> Heya kowey :)
12:24:01 <heatsink> It's in Data.Graph.Inductive.Query.dom ... I don't know how to work around
12:24:11 <heatsink> I don't know how to work around that problem
12:25:05 <heatsink> I don't suppose anyone here has had problems with the graph library?
12:25:11 <dons> evening all
12:25:11 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:25:20 <glguy> evening
12:25:29 <heatsink> good afternoon, dons
12:27:53 <dons> ?uptime
12:27:53 <lambdabot> uptime: 1d 10h 59m 31s, longest uptime: 2d 3h 42m 19s
12:27:57 <dons> ?users
12:27:57 <lambdabot> Maximum users seen in #haskell: 311, currently: 296 (95.2%), active: 49 (16.6%)
12:28:21 <psnl> dons: how easy would be be to combine commands?
12:28:29 <lokadin> What's a good Monad tutorial?
12:29:06 <allbery_b> mny of them are good.  none of them is guaranteed to "work" for you
12:29:07 <dmhouse> lokadin: you need the metatutorial :)
12:29:17 <dmhouse> ?google metatutorial haskell site:haskell.org
12:29:18 <shapr> I like sigfpe's "You could have invented Monads" best.
12:29:19 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
12:29:19 <lambdabot> Title: Meta-tutorial - HaskellWiki
12:29:43 <dmhouse> I personally like Cale's Monad's as Containers, and the Wikibook's Understanding Monads and Advanced Monads chapters.
12:29:44 <allbery_b> I suggest going through several of them and experimenting
12:29:49 <dmhouse> With a bit of All About Monads thrown in there.
12:30:03 <lokadin> dmhouse: .ua.uiki'e(discovery happiness thanks)
12:31:04 <dmhouse> Err...
12:31:36 <shapr> mi djica lenu mi gunka
12:33:06 * dmhouse refactors his CPS article
12:33:18 <glguy> Main.lhs:18:8: Could not find module `Version':
12:33:23 <glguy> anyone know what that is?
12:33:39 <fasta> AARGH! matchAny g = let (m,g) = match (G.some_vertex g) g
12:33:41 <dmhouse> glguy: sounds like a package-specific module, what's the error from?
12:33:48 <glguy> lhs2tex 1.12
12:33:48 <fasta> No wonder my program went into an infinite loop...
12:33:59 <fasta> Is there any tool that can catch this bug?
12:37:30 <fasta> I almost will adopt this write a line, test a line coding approach.
12:39:30 <rahikkala> That's not Extreme enough, you should write the test first :(
12:39:41 <kolmodin> Jaak: try to pull and recompile binary and see if all tests work for you now
12:39:50 <dons> ?seen Jaak
12:39:51 <lambdabot> Jaak is in #haskell. I last heard Jaak speak 1h 20m 54s ago.
12:41:00 <Jaak> in a sec
12:42:26 <dons> yeah, we can trigger the bug, and the patch seems to fix it, on my machine
12:42:54 <dons> i think the bug was always there, but didn't manifest till you had 64 bits in your Ints, (guessing) enough to trigger some large numbers in the QC tests
12:44:42 <kolmodin> they failed on my 32bit ghc6.6 machine though
12:44:55 <Jaak> IntMap ByteString passes nicely now
12:45:01 <dons> good news
12:45:09 <glguy> how do I turn the results of lhs2TeX into a PDF
12:45:10 <kolmodin> Jaak: yay
12:45:16 <dons> brought to you by the Binary Serialisation Action Squad!
12:45:19 <kolmodin> Jaak: thanks for the report!
12:45:40 <kolmodin> Jaak: and for beeing patient with our questions... :)
12:45:46 <dons> yeah, cheers Jaak. bugs make us feel icky
12:46:26 <kolmodin> first bug to be found by "the public" ?
12:46:33 <dons> dons law: if you have a bug, you are missing a QC property
12:46:39 <dons> kolmodin: right
12:46:53 <dons> and around, hmm, bug 3 to make it into the repo?
12:46:55 <shapr> dons: please put that into HWN!
12:46:56 <dons> there's not been many
12:47:06 <dons> heh
12:47:22 <shapr> @remember dons dons law: if you have a bug, you are missing a QC property
12:47:22 <lambdabot> Done memoising quote for `dons', if that is their real name...
12:47:45 <kpreid> shouldn't that be "memorizing"?
12:47:46 <dons> lambdabot's all sillly
12:47:47 <Jaak> np, nice to have that fast fix :)
12:47:51 <dons> no, memoising!
12:47:52 <dons> ;)
12:48:09 <dmhouse> dons: do we have to request to get stuff into HWN or do you just do a weekly survey?
12:48:30 <dons> i just take the stuff from the @remember logs
12:48:38 <kpreid> dons: last I heard, memoising means something different
12:48:46 <dons> yeah, its a joke
12:49:00 <dons> sorry, i think it was new years eve and i'd had a bottle of wine when i coded up this narky bot code
12:49:25 <dons> not the reliable solid ralf lammel of a bot we normally have
12:49:34 <fasta> rahikkala: you can't run tests for which the functions don't exist yet, unless I am missing some point.
12:50:20 <kolmodin> it's nice to have static types after a bottle of wine
12:50:33 <dons> damn straight
12:51:06 <kolmodin> well, it's always nice :)
12:51:07 <sjanssen> @remember kolmodin it's nice to have static types after a bottle of wine
12:51:07 <lambdabot> Done memoising quote for `kolmodin', if that is their real name...
12:51:26 <shapr> fasta: I extended QuickCheck so that you could do exactly that.
12:51:29 <kolmodin> heh :)
12:54:50 <tuukkah> fasta, after you've written the test, the first error is the compiler complaining that some identifiers are not in scope. the second error is when the test execution hits your f = undefined
12:55:37 <fasta> tuukkah: I find that I reconsider my previous decisions quite often.
12:55:52 <shapr> I do like Test Driven Development, it's quite nifty.
12:56:10 <dmhouse> dons: sorry, re. my last question about getting stuff into HWN, I meant with news items rather than quotes.
12:56:33 <dons> news, you can send me patches
12:56:37 <dons> or i try to work it out
12:56:51 <tuukkah> fasta, what do you refer to?
12:57:24 * glguy doesn't know where his own code is stored
12:57:27 <glguy> ?where hpaste
12:57:27 <lambdabot> http://members.cox.net/stefanor/hpaste/
12:57:38 <dons>  sorear is hosting it?
12:57:39 <Saizan> :OO
12:58:31 <glguy> yeah
12:58:38 <tuukkah> fasta, do you say you're prototyping hacks like i would, and not doing proper software engineering? although i don't know how this view fits with the agile view
12:58:48 <glguy> I don't have a webserver to use for it
12:59:12 <shapr> glguy: You want to put it on scannedinavian?
12:59:28 <glguy> shapr: would I be able to push my own patches to that ?
12:59:32 <tuukkah> @google lambdaforge
12:59:34 <lambdabot> http://tunes.org/~nef/logs/haskell/06.10.10
12:59:35 <shapr> glguy: Yeah, I'd give you an account.
12:59:44 <glguy> oh, in that case, sure
13:00:02 <shapr> Ok, send me an ssh pub key. Do you know my email address?
13:00:10 <fasta> tuukkah: if by proper software engineering you mean that I design the entire thing upfront, and then implement it, then no.
13:00:11 <glguy> i don't know it, actually
13:00:17 <shapr> shae@scannedinavian.com
13:01:08 <tuukkah> fasta, not necessarily that, but that design and implementation are separate, measurable, controllable... blah blah... tasks
13:01:08 <glguy> done
13:02:13 <fasta> tuukkah: Those methods are applicable when the domain is well-known.
13:03:02 <fasta> Anyway, the only thing I would wish for is to see what the hell my program is evaluating.
13:03:11 <kosmikus> glguy: lhs2tex problems?
13:03:25 <glguy> kosmikus: resovled by not using Cabal
13:03:35 <tuukkah> fasta, they claim otherwise. they are not saying you can't iterate, intersperse, increment etc.
13:03:44 <kosmikus> hmm. why didn't Cabal work for you?
13:03:53 <glguy> couldn't find Version when compiling Main.
13:03:57 <lisppaste2> dmhouse pasted "shapr: build errors on your box" at http://paste.lisp.org/display/35587
13:04:04 <glguy> !paste
13:04:05 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
13:04:07 <dmhouse> shapr: ^^ does that mean I need to use the new SimpleHTTP?
13:04:38 <kosmikus> glguy: which OS, which Cabal version, which ghc version. and the "setup configure" output, please ;)
13:05:03 <fasta> tuukkah: I personally haven't seen any good software from people writing over these things. I think figuring out what you want is a process that works by for example creating a prototype.
13:05:04 <tuukkah> fasta, i'm not a software engineering fanboy, but i've realised they might have a point in that something is lost if the only product of the hacking sessions is the code and you have no documentation for the design choices
13:05:07 <glguy> OpenBSD 4.0, ghc 6.6
13:05:22 <fasta> tuukkah: oh, but I do document design choices.
13:05:33 <fasta> tuukkah: well, I will anyway.
13:05:54 <tuukkah> fasta, what they say about prototypes is sure you can write one, but you better throw it away then before you start to implement the real thing
13:06:13 <Excedrin> tuukkah: can't code serve as documentation? (either high quality comments or literate programming)
13:06:15 <fasta> tuukkah: I don't really agree with that.
13:06:18 <shapr> dmhouse: Yeah, use SimpleHTTP2
13:06:38 <fasta> tuukkah: Since my "prototype" is going to use all the proper data structures already
13:06:48 <tuukkah> Excedrin, code typically doesn't document the design process
13:07:07 <kosmikus> glguy: setup configure should create Version.lhs. if it doesn't, I'd expect an error message during "setup configure" ...
13:07:23 <kosmikus> glguy: and what was the question about generating PDF?
13:07:27 <tuukkah> fasta, that's why it's not a prototype without quotes =)
13:07:28 <dmhouse> shapr: so the old SimpleHTTP has completely been removed?!
13:07:38 <shapr> yup
13:08:00 <dmhouse> Why?
13:08:24 <fasta> tuukkah: There's already enough released prototypes in the world presented as end-user software.
13:08:47 <shapr> dmhouse: Alex wanted a different interface. Have you seen the new tutorial on Haskellwiki?
13:08:58 <tuukkah> fasta, that might be one explanation why they're mostly crap, no?-)
13:09:41 <glguy> kosmikus: it was me not knowing that lhs2tex didn't work on ">" formatted files
13:09:46 <fasta> tuukkah: the explanation is that most users only see bells and whistles and popularize the wrong software.
13:09:53 <dmhouse> shapr: I hadn't; I'm looking at it now. I wonder why the two interfaces couldn't have coexisted, though.
13:09:55 <glguy> kosmikus: I think I am missing FilePath
13:09:58 <glguy> kosmikus: I know how to fix that
13:10:07 <glguy> kosmikus:  I don't remember seeing that originally though
13:10:07 <fasta> tuukkah: example: xdvi can show 10K pages within a second, kdvi chokes.
13:10:09 <chr1s_> hey everyone
13:10:18 <chr1s_> I'm working with the HXmlToolbox
13:10:19 <kosmikus> glguy: lhs2tex *does* work on >-files
13:10:27 <fasta> tuukkah: "everyone" things kdvi is better
13:10:31 <fasta> er thinks
13:10:38 <glguy> but... expects me to write \begin{document} ?
13:10:41 <tuukkah> fasta, now the role of software engineering shouldn't be blaiming others but changing the world for better :-)
13:10:43 <glguy> or is there a ">" flag
13:10:49 <chr1s_> is there any good tutorial on that? The wiki and API don't provide much help
13:10:59 <pitecus> Are there interned strings somewhere in the haskell libraries?
13:11:19 <kosmikus> glguy: ... and there shouldn't be any dependency on a file path library (yet)
13:11:25 <fasta> tuukkah: yes, but I don't view software engineering as a very creative work.
13:11:35 <kosmikus> glguy: sure, it expects you to have a valid LaTeX document
13:11:43 <kosmikus> only the Haskell code is reformatted
13:11:53 <glguy> kosmikus: right, that's what I was getting at
13:12:02 <glguy> I didn't know that at first
13:12:08 <kosmikus> but you can have > or \begin-\end-code
13:12:14 <tuukkah> fasta, changing the world for better requires creativity for sure
13:12:14 <Saizan> ?where hrss -- there's an rss reader by cale that's quite nice to read
13:12:15 <lambdabot> I know nothing about hrss.
13:12:34 <fasta> tuukkah: no, it could be that others have already thought up the stuff, but they never implemented it.
13:13:17 <fasta> tuukkah: there's little creative work in it when you can copy the pseudo-code from some article. (Not that articles contain the best pseudo-code in the world)
13:13:20 <tuukkah> fasta, are you saying that going through other people's thoughts and implementing the effective ones isn't creative then?-)
13:13:49 <fasta> tuukkah: It depends on how much you need to reconstruct.
13:14:15 <tuukkah> you can also work on the meta-level
13:14:32 <tuukkah> but then you're not a programmer of course
13:15:16 <dmhouse> shapr: where's the Haddock API docs for SimpleHTTP2?
13:15:18 <fasta> tuukkah: you mean like "hey, dude, you build that, and then strap it together with the code from that other monkey"?
13:15:39 <Axioplase> Is there a balanced tree module somewhere ? (like Caml's Map.Make)
13:16:08 <fasta> Axioplase: Data.Map
13:16:17 <Axioplase> simply. thanks.
13:16:48 <fasta> Data.IntMap is an example of a good library.
13:17:00 <tuukkah> fasta, i mean like researching the process of software engineering of haskell programs and contributing insightful scientific articles on the subject
13:18:33 <tuukkah> "how to achieve reliable and repeatable quality and cost-effectiveness in creatively implementing software in haskell"
13:19:05 <fasta> tuukkah: I think providing good tools would be the first step.
13:19:09 <russo> kick McVelet <- he's spamming people who join the channel!!!
13:19:29 <fasta> tuukkah: lots of implementations have mediocre tools. (not only in Haskell)
13:19:49 <glguy> ?where hpaste
13:19:49 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
13:19:57 <tuukkah> fasta, are you saying there's a "phase 1" we need to complete before starting "phase 2"?
13:19:58 <mbishop> yeah McVelet is spamming
13:19:59 <kolmodin> g'night
13:20:08 <fasta> tuukkah: no
13:20:20 <Saizan> dmhouse: i found reading simpleHTTP2.hs the best doc
13:20:59 <Saizan> dmhouse: there's an example at the end
13:21:20 <shapr> dmhouse: Yeah, I think SimpleHTTP2 has zero Haddock
13:21:59 <tuukkah> i'm saying let the hackers hack and software engineers engineer and researchers research in parallel, but they should learn from each other and work together for better software
13:22:04 <musasabi> shapr: pull. It has some haddock now.
13:22:16 <glguy> ?tell sorear hpaste repo moved to http://www.scannedinavian.com/~eric/hpaste so I have push access now.
13:22:16 <lambdabot> Consider it noted.
13:22:25 <shapr> musasabi: yay!
13:22:28 <dmhouse> Right. So the HEAD is 100% non-backward compatible, with no detailed documentation aside from examples?
13:22:37 <dmhouse> musasabi: oh, that's good news.
13:23:22 <musasabi> dmhouse: if it makes things easier most of the examples are still broken.
13:23:42 <glguy> does HAppS have a way to store State / provide Reader functionality
13:23:43 <dmhouse> musasabi: why can't SimpleHTTP be included alongside SimpleHTTP2?
13:24:01 <glguy> so my simpleHTTP app .... has access to a common resource
13:24:04 <dmhouse> glguy: your entire application runs in an instance of MonadState.
13:24:20 <musasabi> dmhouse: because they have conflicting names iirc.
13:24:31 <glguy> I'm talking about stuff that shouldn't be persisted
13:24:37 <musasabi> dmhouse: you can use clever imports and get the old SimpleHTTP with HEAD. I think.
13:24:41 <glguy> in this case, a reference to a Chan
13:24:54 <musasabi> glguy: that has been done.
13:25:14 <glguy> yeah, I'm trying to figure out how I'm supposed to
13:25:17 <dmhouse> musasabi: I thought they were called Protocols.SimpleHTTP2 and Protocols.SimpleHTTP?
13:25:42 <musasabi> yes. HAppS.Protocols.SimpleHTTP and HAppS.Protocols.SimpleHTTP2
13:26:02 <glguy> ch :: Chan (String,String,String)
13:26:02 <glguy> ch = unsafePerformIO newChan
13:26:05 <glguy> I want to not do this
13:26:10 <dmhouse> musasabi: well I'm getting the following error which leads me to believe that the former no longer exists: http://paste.lisp.org/display/35587
13:26:47 <psnl> @hoogle count
13:26:48 <lambdabot> Text.ParserCombinators.ReadP.count :: Int -> ReadP a -> ReadP [a]
13:26:48 <lambdabot> Text.ParserCombinators.Parsec.Combinator.count :: Int -> GenParser tok st a -> GenParser tok st [a]
13:26:48 <lambdabot> Test.HUnit.Base.counts :: State -> Counts
13:27:23 <Saizan> dmhouse: they are not exposed in the cabal, last time i checked
13:28:03 <musasabi> yes, appears to be the cabal file.
13:28:35 <dmhouse> musasabi: any chance they could be?
13:29:37 <tuukkah> fasta, i hope i made any sense. at any rate i wasn't telling you should do something else than what works best for you
13:30:13 <glguy> so I need to wrape the whole thing in a ReaderT?
13:30:14 <musasabi> dmhouse: I think it could be at least enabled in the cabal file for the moment. I'll test if it breaks something and then commit.
13:30:31 <dmhouse> musasabi: thanks very much.
13:32:39 <musasabi> glguy: you can either get that into state by various tricks, or just create it in main and pass it as a parameter to things.
13:32:59 <glguy> what sort of state tricks?
13:33:14 <glguy> only two of my many pages use this resource
13:33:28 <glguy> I don't want to add a _ to all the rest
13:34:00 <musasabi> implicit parameters are a quicker and more evil alternative, but they tend to cause problems.
13:36:31 <Saizan> yeah this seems the kind of problem solved by dynamic scoped variables
13:37:02 <glguy> so am I trying to fit a round peg in square hole? or was instance level state just an oversight?
13:38:16 <musasabi> glguy: no, that is a known issue, just there is no really pretty solution.
13:38:32 <Saizan> or you can have app ch = app' where app= your current app
13:39:20 <glguy> I might just go that route...
13:43:11 <musasabi> dmhouse: commit coming up. SimpleHTTP had some new methods since the last release and needed fixing to get it working. no guarantees other than that it is compiling.
13:46:56 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
13:48:01 <glguy> a watched pot might not boil, but an unwatched one boils over
13:48:05 <glguy> I need a tea kettle
13:48:47 <musasabi> glguy: did you get the Chan working?
13:48:57 <glguy> app ch = app'
13:49:06 <glguy> app' GET _ [] = ...
13:49:08 <glguy> where ^
13:49:34 <glguy> I don't want to use -fimplicit or whatever that flag was
13:49:49 <musasabi> that looks like it should work nicely.
13:50:17 <glguy> and it is easy to expand if I have more stuff later
13:50:27 <musasabi> glguy: and you are aware of replay and that won't burn you?
13:50:41 <glguy> ?
13:50:43 <musasabi> (just checking)
13:51:04 <glguy> I do my IO with addSideEffect
13:51:17 <musasabi> ok, then you should be fine.
13:51:28 <glguy> addSideEffect 10 (writeChan ch whatever)
13:51:43 <glguy> it is all write
13:51:52 <glguy> and the bot has a thread listening on the other end
13:52:41 <dmhouse> musasabi: appreciate your time on this, thanks.
13:58:35 <therp> given a list of tuples of (key, value), is there an way (=easy, by combining prelude functions) to group them by equal keys? as in [(1, x), (2, y), (1, z)] => [(1,[x,z]), (2, [y])]
13:59:10 <therp> s/prelude/prelude or other base modules/
13:59:43 <dmhouse> therp: groupBy (\x y -> snd x == snd y)
13:59:47 <chessguy> @hoogle groupBy
13:59:47 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
13:59:50 <dmhouse> Err, s/snd/fst/
14:00:20 <dmhouse> In the HEAD libraries, there's an equating function, so you can do groupBy (equating fst), but as I said, that's in HEAD.
14:01:02 <chessguy> what's HEAD? haven't heard of that one
14:01:09 <Saizan> > groupBy (\x y -> fst x == fst y) [(1, 'a'), (2, 'b'), (1, 'c')]
14:01:11 <lambdabot>  [[(1,'a')],[(2,'b')],[(1,'c')]]
14:01:29 <allbery_b> terminology borrowed from CVS, means the latest code in the version control system
14:01:31 <Saizan> > groupBy (\x y -> fst x == fst y) . sort $ [(1, 'a'), (2, 'b'), (1, 'c')]
14:01:32 <lambdabot>  [[(1,'a'),(1,'c')],[(2,'b')]]
14:01:43 <therp> hm, I had a look at groupBy and I had the impression that it's unsuitable as it is a only a special case of group, which does the wrong thing .. imho
14:02:17 <Saizan> therp: you can go through a Map k [valuetype] using fromListWith
14:02:20 <ElPenguin> if haskell didn't use monads, what would be another good way of seperating pure and impure code?
14:02:29 <Saizan> fromListWith (++)
14:03:42 <chessguy> ElPenguin, that's a strange question
14:04:00 <ElPenguin> chessguy: yeah, i know :) i'm just looking at alternate approaches for some research
14:04:24 <therp> saizan: nice thanks
14:05:18 <ElPenguin> for example, by using monads haskell makes people mess about lifting functions to monads which can become repetitive, i'm wondering if there's a better way
14:05:58 <notsmack> ElPenguin: well anything that can call impure functions needs to itself be impure, right?
14:06:25 <ElPenguin> notsmack: *nod* but impure functions calling pure functions...
14:06:34 <notsmack> sure
14:07:02 <dmhouse> Monads with subtyping may be a solution there.
14:07:18 <dmhouse> You could define pure functions as subtypes of monadic ones, and then just use them normally.
14:07:37 <dmhouse> But that wouldn't be a very Haskell approach. I'm not sure how well those two features would interplay.
14:08:11 <kpreid> ElPenguin: another approach is 'uniqueness types' (if I got the name right)
14:08:13 <ElPenguin> for example say i define a pure function fac (that calculates the factorial) and i'm calling it within my main monad. it would be much easier to just be able to directly print the return value without having to mess about
14:08:23 <ElPenguin> kpreid: please explain :)
14:08:33 <ElPenguin> dmhouse: and you too :)
14:08:35 <notsmack> ElPenguin: what messing about?
14:09:27 <ElPenguin> notsmack: well i'm rather new to haskell, but i gather i couldn't just string them together
14:10:00 <ElPenguin> for example, in perl i'd just do: print fac(10); but in haskell it wouldn't quite work like that (And not just for type conversion)
14:10:02 <kpreid> ElPenguin: consider the state of the outside world to be a value, then have functions which compute new states-of-the-world, then use the type system to prohibit having two different states around at the same time
14:10:03 <notsmack> ElPenguin: calling pure functions from mainis pretty straightforward
14:10:13 <dmhouse> ElPenguin: no, it'd be print (fac 10).
14:10:13 <norpan> ElPenguin: that's exactly the way it works
14:10:26 <kpreid> main = print (fac 10)
14:10:28 <dmhouse> That seems acceptable to me.
14:10:33 <ctkrohn> well except for the (show (fac 10))
14:10:42 <norpan> print includes show
14:10:43 <dmhouse> ctkrohn: print = putStrLn . show
14:10:50 <ctkrohn> oh, nm, good call :)
14:10:54 <ctkrohn> didn't know that
14:10:58 <ElPenguin> kpreid: that's rather confusing
14:11:00 <dmhouse> ?hoogle print
14:11:01 <lambdabot> Prelude.print :: Show a => a -> IO ()
14:11:01 <lambdabot> Text.Printf.Print :: class Print
14:11:01 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
14:11:09 <kpreid> ElPenguin: Er, in what way?
14:11:22 <dmhouse> ElPenguin: I'm not sure this actually is a problem you get often.
14:11:23 <notsmack> ElPenguin: looks almost exactly like your perl example?
14:11:30 <ElPenguin> kpreid: i don't see about computing different states
14:11:38 <kpreid> ElPenguin: oh.
14:11:55 <monochrom> Someone said, for real projects, he writes all functions as monads, even pure ones --- use the Id monad for them.  Then three versions later he has no problem changing Id to another monad.
14:12:05 <dmhouse> ElPenguin: what's your background? Hobbyist or academic? The expression 'I'm doing research' takes on some very different meanings.
14:12:13 <ElPenguin> dmhouse: well for example i was reading that write a scheme in 48 hours thing which is written in haskell and it often had to use liftM which is just silly in many cases
14:12:13 <kpreid> ElPenguin: ask someone else to explain it; I've never actually used that sort of system
14:12:20 <ElPenguin> kpreid: thanks
14:12:38 <ElPenguin> notsmack: *nod*, perhaps a trivial example
14:13:55 <dmhouse> ElPenguin: I'd say explicit liftMs (or fmap, as I prefer) are a good thing; they make it clear what's pure code and what's monadic code.
14:14:05 <dmhouse> They're not used _that_ much in the typical project.
14:14:22 <ElPenguin> hrm
14:14:35 <notsmack> yeah, and when they are, it's usually for something that's actually non-trivial
14:14:40 <Philippa> dmhouse: you get some right academic/hobbyist mongrels around here though
14:14:56 <fasta> monochrom: I think he could be right.
14:15:05 <dmhouse> Philippa: sure, the conjunction wasn't a non-option. :)
14:15:24 <Philippa> yeah, but I have a pseudo-academic background and no academic position, for example...
14:16:31 <dmhouse> One can learn a lot by reading LtU :)
14:18:18 <ElPenguin> and another thing, is there a decent haskell mode for emacs? the one i've got doesn't work with layout properly and i constantly find myself having to manually align things
14:18:40 <dmhouse> ElPenguin: just keep hitting TAB.
14:18:48 <Baughn> ElPenguin: haskell-mode 2.1 seems to work pretty well. Is that the one you have?
14:18:52 <ElPenguin> it keeps indenting for ever and ever
14:18:56 <Baughn> Though I find myself longing for s-expressions
14:19:01 <dmhouse> ElPenguin: it has a TAB-cycle because for any given line, there are multiple possible layout indents.
14:19:03 <ElPenguin> Baughn: how can i get a version?
14:19:14 <dmhouse> ?where haskell-mode
14:19:14 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
14:19:15 <Baughn> ElPenguin: google?
14:19:25 <ElPenguin> ta
14:20:03 <thedward> is there any preexisting data type like Data.Map, but that keeps track of insert order?
14:20:04 <ElPenguin> oh, looks like i got it through portage...
14:20:10 <ElPenguin>      Installed versions:  2.1(02:21:12 12/29/06)
14:20:26 <dmhouse> ElPenguin: which indentation module are you using?
14:20:34 <ElPenguin> whatever is default?
14:20:58 <dmhouse> Well, what code did you insert into your .emacs?
14:21:22 <ElPenguin> i didn't, i just had it load the site-lisp directory
14:21:28 <ElPenguin> let me check what it's loading
14:21:29 <lisppaste2> dmhouse pasted "My .emacs additions" at http://paste.lisp.org/display/35598
14:21:37 <dmhouse> ElPenguin: for example, that's what I have.
14:22:47 <ElPenguin> right, so it doesn't enable the indentation by default? that would be why it's messed up here
14:23:54 <ElPenguin> i just banged that in my .emacs
14:23:57 <dmhouse> ElPenguin: I dunno, if you read the notes at the top of the haskell-site-file.el it has installation instructions.
14:24:11 <dmhouse> But my paste should do fine.
14:24:47 <ElPenguin> ah, that's much better, thanks
14:25:14 <dmhouse> ElPenguin: don't miss C-c C-l either, that's a useful key.
14:25:20 <ElPenguin> what's it bound to?
14:25:54 <dmhouse> inferior-haskell-load-file
14:25:59 <dmhouse> It loads the file in an embedded GHCi.
14:26:10 <ElPenguin> that could be very useful :)
14:26:25 <ElPenguin> i assume there's also a key combo to bring up a ghci session?
14:26:34 <dmhouse> M-x run-haskell
14:26:40 <ElPenguin> thanks
14:26:41 <dmhouse> I have that bound to F6, √ºber useful.
14:27:38 <ElPenguin> bit of a stretch for the fingers ;) i'll probably bind it to ^x-\ like i used to have gambit bound for scheme
14:28:28 <dmhouse> I have Eshell on F5, GHCi on F6 and erc-iswitch-b on F11. :)
14:28:55 <dmhouse> Well, not quite Eshell, but a self-written function that either switches to an Eshell buffer or back to the buffer you were at before if you're already on an Eshell buffer
14:29:03 <dmhouse> And C-<f5> creates a new Eshell session.
14:29:53 <dmhouse> I love my Emacs. :)
14:30:27 <ElPenguin> emacs could do with much improvement imo, starting with good unicode support. though i hear one of the versions patched in someone else's CVS works passably
14:31:05 <dmhouse> I use the unicode-2 CVS branch, mostly for the XFT support, but I guess it's got unicode support too. I can see weird characters that people post in the channel.
14:31:43 <ElPenguin> one thing i can't stand to do is use emacs for irc ;) irssi...
14:32:09 <allbery_b> I tried that once, hope they've improved it so it's not synchronous
14:32:24 <allbery_b> was "fun" when something happened to the server
14:32:46 <dmhouse> I'm an irssi -> ERC convert; I found it useful to have my text editor right nearby, cutting/pasting things into/from irssi was a nightmare.
14:33:33 <monochrom> In the earliest days people used emacs for irc, in fact they learned emacs just for irc.
14:33:45 <ElPenguin> ^w m-tab s-del
14:33:49 <ElPenguin> not too tricky :)
14:33:58 <ElPenguin> then m-tab ^y of course
14:36:14 <dmhouse> ElPenguin: you could use M-w instead of killing then reyanking.
14:36:46 <ElPenguin> dmhouse: useful tip, ty
14:38:20 <monochrom> emacs = esc meta alt ctrl shift
14:41:12 <ElPenguin> these type equations are really starting to confuse me
14:42:20 <kenny> hi
14:43:22 <nametab> I'm trying to write a simple java compiler in haskell (school assignment), but I'm running across some odd results lexing the java-code
14:44:39 <Saizan> like?
14:44:55 <therp> dmhouse: oh, is emacs xft ready finally? I'm on xemacs, just because of XFT
14:44:59 <ElPenguin> java has one of the most complex syntax trees imaginable
14:45:00 <nametab> when I try to ignore the comments (like /* text */) it does not skip the first lines of comment, but it does with all the other lines
14:45:11 <nametab> somehow it skips the first comments
14:46:20 <nametab> ElPenguin: we keep it simple
14:47:01 <dmhouse> therp: I've had nil problems with the emacs-unicode-2 branch of CVS emacs. I use Emacs Gtk with XFT fonts. :) http://www.emacswiki.org/cgi-bin/wiki/XftGnuEmacs
14:47:03 <lambdabot> Title: EmacsWiki: XftGnuEmacs
14:47:30 <therp> thanks, know this url already.
14:48:23 <therp> hm, I wonder when emacs-23 is out
14:53:31 <nametab> lexComment = (\_ _ _  -> "") <$> token "/*" <*> many (satisfy (\x -> True)) <*> token "*/"
14:53:52 <nametab> that schouldn't skip any lines with "/*" should it?
14:54:35 <nametab> of course, / and * are sepparate operators, the first time those commentsigns occur in the java-code the lexer recognises the comment signs as two sepparate operators
15:01:20 <ski> yay !!!
15:17:40 <sorear> tell fodder
15:17:40 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:18:01 <allbery_b> feed da bot?
15:18:38 <sorear> glguy: cool. /me removes his repo.
15:22:42 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
15:24:19 <SyntaxNinja> darcs.haskell.org had NO downtime in 2006 :)
15:24:37 <yaxu> I'm getting a "Non-exhaustive patterns in function" error but can't see how from staring at the code - is there an easy way of finding what isn't matching?
15:25:18 <sorear> hurray!
15:25:20 <sorear> yaxu: yes.
15:25:22 <sorear> yaxu: -Wall
15:25:26 <sorear> yaxu: -Wall -Werror
15:25:35 <yaxu> ah, thanks sorear
15:25:48 <sorear> sadly, there isn't a good runtime way
15:26:25 <sorear> CatCH iirc was a project to make safe "non-exhaustive" matches, but I don't know if it is usable yet
15:26:59 <yaxu> now my code won't compile, it says something about my code being dirty and full of loose ends
15:27:05 <yaxu> :)
15:27:48 <sorear> hopefully it will point to the trouble spot...
15:28:24 <SyntaxNinja> yaxu: look for a non-exaustive pattern match warning
15:28:41 <yaxu> yes i'm getting lots of those
15:28:49 <sorear> no he isn't
15:29:08 <sorear> if he followed my last recommendation they're errors :)
15:29:12 <yaxu> i guess the fact that i'm doing non-exhaustive pattern matches suggests that my types aren't well organised
15:29:28 <sorear> usually correct
15:29:57 <sorear> but "not well organized" does *not* imply any human will be able to find a better organization
15:30:31 <yaxu> ok i'll ask my cat
15:30:51 <nmessenger> cats are natural type theorists
15:31:10 <yaxu> so that's what they're thinking about all the time
15:32:25 * sorear just sent a patch to make @paste point to hpaste
15:33:04 <yaxu> oh, a pastebot written in haskell?
15:33:13 <sorear> yes
15:33:13 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
15:33:35 <nmessenger> I /msg'ed hpaste !paste, shouldn't it /msg me back?
15:33:42 <sorear> nmessenger: hah.
15:33:53 <sorear> I discovered that over a day ago ...
15:34:24 <sorear> the current architecture of PasteBot isn't very conducive to privmsg replies.
15:34:33 <SamB> @seen hpaste
15:34:33 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 1m 19s ago.
15:34:40 <sorear> it doesn't even do flood control
15:34:42 <SamB> hmm, #haskell only?
15:34:47 <sorear> SamB: yes :(
15:36:04 <yaxu> so just the ircd and clients left to rewrite
15:36:34 <huschi> i've just looked at Data.Monoid. why is there no instance for Maybe?
15:36:49 <yaxu> oops no a haskell irc client exists
15:36:59 <SamB> oh, speaking of which, won't it be annoying that lambdabot doesn't realize that freenode and freenode2 and freenode3 are actually the same network?
15:37:18 <huschi> yaxu: there is hircules afaik.
15:37:29 <yaxu> huschi: yes just spotted on google
15:37:30 <nmessenger> ?where hircules
15:37:30 <lambdabot> I know nothing about hircules.
15:37:36 <nmessenger> ?google hircules
15:37:39 <lambdabot> http://freshmeat.net/projects/hircules/
15:37:39 <lambdabot> Title: freshmeat.net: Project details for Hircules
15:45:08 <sorear> @seen tuukkah
15:45:08 <lambdabot> tuukkah is in #haskell. I last heard tuukkah speak 2h 15m 30s ago.
15:45:46 <tuukkah> what's up ?-)
15:46:24 <sorear> (reading the logs)
15:46:39 <sorear> > array (0,maxBound::Int) [(3,'e')]
15:46:41 <lambdabot> Terminated
15:46:43 <sorear> > array (0,maxBound::Int) [(2,'e')]
15:46:45 <lambdabot>  internal error: EVACUATED object entered!
15:46:45 <lambdabot>     Please report this as a bug to...
15:46:56 <sorear> Terminated == Segmentation fault.
15:47:01 <sorear> I just crashed runplugs.
15:47:27 <sorear> (you were asking about lambdabot failure recovery)
15:47:37 * nmessenger is impressed that a segfault doesn't kill LB
15:47:46 <sorear> fork! fork! fork!
15:48:01 <sorear> segfaults don't kill bash, either.
15:48:03 <tuukkah> right, so the only safe way is to fork anyway
15:49:51 <tuukkah> sorear, is it possible to access more than the prelude?
15:53:43 <nmessenger> tuukkah, in lambdabot?  LB imports a bunch of modules.
15:54:14 * shapr explodes!
15:54:35 * nmessenger sweeps up shapr parts
15:55:17 <tuukkah> nmessenger, are some of them qualified?
15:55:19 <nmessenger> very messy
15:55:26 <psnl> RIP shapr; unicyclist ans haskell hacker. may we see his like again.... amen
15:55:41 * sorear bows solemnly
15:55:49 <nmessenger> tuukkah, I'm not sure where you'd find that information
15:55:51 <nmessenger> @help run
15:55:52 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:55:54 * sorear tries to darcs revert the mess
15:56:03 <sorear> tuukkah: M.Map, S.Set
15:56:06 <sorear> tuukkah: check
15:56:13 <sorear> ?where lambdabot
15:56:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:56:16 <nmessenger> > empty :: Map Int Char
15:56:17 <lambdabot>   Not in scope: type constructor or class `Map'
15:56:19 <sorear> /State/Pristine.hs
15:56:29 <nmessenger> > M.empty :: M.Map Int Char
15:56:30 <lambdabot>  {}
15:56:34 <sorear> http://www.cse.unsw.edu.au/~dons/State/Pristine.hs
15:57:03 <sorear> import qualified Data.Map as M
15:57:04 <sorear> import qualified Data.Set as S
15:57:04 <sorear> import qualified Data.IntSet as I
15:58:01 <sorear> > G.fromConstr
15:58:02 <lambdabot>        add an instance declaration for (Typeable Data.Generics.Basics.Constr)
15:58:12 <nmessenger> (above url 404'ed for me)
15:58:17 <sorear> ok, Data.Generics as G
15:58:20 <sorear> me too
15:58:23 <sorear> I mis-typed it
15:58:28 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabotState/Pristine.hs
15:58:31 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/State/Pristine.hs
15:58:38 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
15:59:00 <nmessenger> :t lookup
15:59:02 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
15:59:10 <nmessenger> :t Prelude.lookup
15:59:11 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
15:59:25 <sorear> nmessenger: :t uses GHCi
15:59:57 <nmessenger> oh, so it doesn't have the @run imports?
16:00:03 <sorear> correct.
16:00:24 <bd_> :t G.fromConstr
16:00:25 <lambdabot> Couldn't find qualified module.
16:00:35 <bd_> :t Data.Generics.Basics.fromConstr
16:00:37 <lambdabot> forall a. (Data.Generics.Basics.Data a) => Data.Generics.Basics.Constr -> a
16:00:43 <tuukkah> huh, so lambdabot uses ghci and also ghci can use lambdabot :-)
16:00:44 <sorear> :t System.IO.Unsafe.unsafePerformIO
16:00:45 <lambdabot> forall a. IO a -> a
16:00:50 <shapr> psnl: :-P
16:01:02 <sorear> I bet @run doesn't import THAT...
16:01:07 <shapr> nmessenger: SHAZAM!
16:01:16 <tuukkah> > unsafePerformIO
16:01:17 <lambdabot>   Not in scope: `unsafePerformIO'
16:01:22 * nmessenger turns inside-out
16:02:00 * sorear hands nmessenger a wetsuit
16:02:09 <tuukkah> it could have some nice binding for unsafePerformIO...
16:02:18 <sorear> we used to :)
16:02:21 <nmessenger> thanks, I was getting chilly
16:02:52 <sorear> oh, you mean like the way old LB said "No IO allowed!" rather than <IO ()> ?
16:02:55 <sorear> @users
16:02:56 <lambdabot> Maximum users seen in #haskell: 311, currently: 288 (92.6%), active: 48 (16.7%)
16:03:34 <tuukkah> > getLine
16:03:36 <lambdabot>  <IO [Char]>
16:05:35 <tuukkah> @bind unsafePerformIO const $ error "Unsafety is bound to happen soon..."
16:05:36 <lambdabot> parse error on input `"'
16:05:50 <sorear>  @let
16:05:58 <nmessenger> @help bind
16:05:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:05:59 <tuukkah> @let unsafePerformIO = const $ error "Unsafety is bound to happen soon..."
16:06:00 <lambdabot> Defined.
16:06:08 <sorear> @bind___
16:06:08 <lambdabot> Unknown command, try @list
16:06:09 <sorear> @bind_
16:06:10 <lambdabot> parse error (possibly incorrect indentation)
16:06:13 <sorear> @_bind
16:06:15 <lambdabot> parse error (possibly incorrect indentation)
16:06:17 <sorear> @__bind
16:06:17 <lambdabot> Unknown command, try @list
16:06:28 <nmessenger> > unsafePerformIO (putStrLn "I'm Rick James, bitch!")
16:06:29 <lambdabot>  Add a type signature
16:07:03 * sorear doesn't get the reference
16:07:39 <tuukkah> @let unsafePerformIO = const $ error "Unsafety is bound to happen soon..." :: ()
16:07:40 <lambdabot> <local>:2:0:     Multiple declarations of `L.unsafePerformIO'     Declared at...
16:07:50 <nmessenger> @undefine
16:07:51 <tuukkah> @unlet
16:07:51 <lambdabot> Undefined.
16:07:52 <lambdabot> Defined.
16:07:57 <nmessenger> :D
16:08:06 <tuukkah> @let unsafePerformIO = const $ error "Unsafety is bound to happen soon..." :: ()
16:08:07 <lambdabot> Couldn't match `()' against `b -> a'
16:08:08 <sorear> @inlet
16:08:08 <lambdabot> Maybe you meant: figlet index let
16:08:14 <Saizan> we could have unsafePerformIO catch stdout and route it to channel
16:08:19 <tuukkah> @let unsafePerformIO = const $ error "Unsafety is bound to happen soon..." :: a -> ()
16:08:19 <lambdabot> Defined.
16:08:20 <sorear> @figlet foo?
16:08:21 <lambdabot> Couldn't run the figlet command.
16:08:22 <nmessenger> sorear, it's Chappelle's Show.  I'm kind of ashamed *blush*
16:08:35 <nmessenger> ?type const
16:08:37 <lambdabot> forall a b. a -> b -> a
16:08:39 <nmessenger> ?type asTypeOf
16:08:41 <lambdabot> forall a. a -> a -> a
16:08:44 <tuukkah> > unsafePerformIO $ getLine
16:08:45 <lambdabot>  Exception: Unsafety is bound to happen soon...
16:08:47 * sorear is really ashamed .... who's Chappelle?
16:09:15 <nmessenger> sorear, Dave Chappelle, black comedian on Comedy Central
16:10:54 <nmessenger> > unsafePerformIO $ putStrLn "and your father smelt of elderberries!" -- better?
16:10:55 <lambdabot>  Exception: Unsafety is bound to happen soon...
16:11:54 <chessguy> LB has a new Doomsdayer module
16:12:11 <sorear> ?
16:12:25 <sorear> it didn't show up it darcs pull 5m ago...
16:12:28 * nmessenger also doesn't know.  Googling...
16:13:14 <chessguy> it was a joke
16:13:16 <chessguy> never mind
16:13:48 * sorear can't take a joke, and isn't afraid to admit it :)
16:13:55 * nmessenger notes that referencing pop culture is largely hit-or-miss
16:14:21 <sorear> I go more for "is largely miss"
16:14:55 <nmessenger>  /agree
16:15:00 <sorear> what's this pop culture thing of which you speak? :)
16:15:20 * sorear actually has a vague idea of what it is
16:15:25 <nmessenger> Something to do with soda pop?  :P
16:19:55 <chessguy> can someone say something that requires UTF-8 to see, please?
16:19:58 <cjeris> pop culture is what you get when you pour some coke into a petri dish on top of a layer of agar and leave it in a swamp overnight
16:20:04 <chessguy> testing a new client
16:20:17 <sorear> ± -- unknown encoding :(
16:20:26 <nmessenger> „Åì„Çå„ÅØ„ÅÑ„ÅÑÔºü
16:20:36 <chessguy> is that hebrew?
16:20:42 <nmessenger> japanese
16:20:45 <shapr> chessguy: hyv√§√§ huomenta!
16:20:47 <chessguy> wow, cool
16:20:55 <cjeris> nmessenger: ??
16:20:57 <chessguy> shapr, God bless you!
16:21:02 * shapr sneezes
16:21:09 <cjeris> grr. opera's irc client is too stupid to send this stuff even though i can see it and type it
16:21:27 <sorear> irssi: 16:17 < nmessenger> ??????
16:21:43 <tuukkah> i only got two question marks
16:21:45 <nmessenger> kore wa ii?  (Is this okay?)
16:21:50 <chessguy> cool, i think i'm going to like schat, aside from the apparent inability to switch between channels using keyboard shortcuts
16:21:54 <allbery_b> ◊ñ◊î ◊¢◊ë◊®◊ô◊™ :)
16:22:02 <nmessenger> xchat: <cjeris> nmessenger: ??
16:23:34 <chessguy> test
16:23:47 <nmessenger> BOOM!
16:23:51 <chessguy> s/schat/xchat/ by the way
16:24:01 <chessguy> ddd
16:24:23 <tuukkah> chessguy =)
16:24:28 <thedward> ·É•·Éê·É†·Éó·É£·Éö·Éò ·Éî·Éú·Éê
16:24:32 <shapr> chessguy: try M-1 M-2 etc
16:24:41 <nmessenger> thedward, I see boxes
16:24:49 <chessguy> shapr, M?
16:24:50 <shapr> thedward: I see question marks.
16:24:54 <shapr> chessguy: meta
16:25:10 <chessguy> shapr, i don't know what you're talking about
16:25:10 <allbery_b> ◊ú◊ô◊ú◊î ◊ò◊ï◊ë
16:25:13 <thedward> shapr , nmessenger : I guess most folks don't have georgian fonts installed. :)
16:25:21 <tuukkah> ctrl-page up, ctrl-page down
16:25:37 <nmessenger> thedward, I use dejavu sans mono, copy-pasted into a different program, worked fine.
16:25:39 <shapr> chessguy: Try holding down Alt or the Windows key and pressing a number to switch to various xchat tabs.
16:25:43 <allbery_b> thedward: shows up fine for me, I think (not that I'd know Georgian)
16:25:48 <chessguy> oh
16:25:56 <tuukkah> thedward, so that's georgian... :-o
16:26:03 <chessguy> oh hey look at that
16:26:17 <thedward> weird, I'm just using irssi -> screen -> gnome-terminal ; everything pasted so far looks fine here
16:26:27 <nmessenger> Ctrl-PgUp, Ctrl-PgDn, also I added a binding for Ctrl-Tab since that's a common tab-switcher
16:26:53 <chessguy> yes, i'm used to ctrl-tab
16:27:07 <thedward> tukkah: it is my favorite alphabet of a language I don't speak
16:27:16 <nmessenger> Settings > Advanced > Keyboard Shortcuts
16:27:26 <tuukkah> thedward, i see =)
16:27:30 <thedward> :)
16:27:31 <chessguy> nmessenger, ok, then what
16:28:14 <tuukkah> i should add some bindings, i have slightly more than 9 tabs open
16:28:17 <nmessenger> chessguy, click add, then fill in the boxes
16:28:45 <nmessenger> (Ctrl-Shift-Tab doesn't work, though. *grumble*)
16:28:46 <chessguy> yeah but how do i put a Tab in for the Key
16:29:11 <nmessenger> just press Tab :)
16:29:22 <chessguy> that goes to the next field
16:29:51 <nmessenger> hmm, /me uses Windows, maybe a GTK thing?
16:30:45 <chessguy> ugh
16:31:02 <chessguy> oh well, ctrl+pg-up or pg-down isn't bad
16:31:41 <chessguy> ss
16:31:43 <chessguy> s
16:32:04 <nmessenger> sssssss!
16:32:10 <jcreigh> > repeat 's'
16:32:12 <lambdabot>  "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss...
16:32:26 <nmessenger> @. read run repeat 's'
16:32:27 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
16:32:29 <chessguy> jcreigh, showoff :)
16:32:34 <jcreigh> heh
16:32:47 <nmessenger> @. show run repeat 's'
16:32:47 <mbishop> :t repeat
16:32:50 <lambdabot> forall a. a -> [a]
16:32:50 <lambdabot> " \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss...\n"
16:33:06 <mbishop> > repeat "DEVELOPERS"
16:33:07 <lambdabot>  ["DEVELOPERS","DEVELOPERS","DEVELOPERS","DEVELOPERS","DEVELOPERS","DEVELOPER...
16:33:15 * mbishop giggles
16:33:17 * nmessenger laughs aloud
16:33:28 * chessguy doesn't get it
16:34:23 <nmessenger> ?google developers developers developers
16:34:26 <lambdabot> http://www.ntk.net/ballmer/mirrors.html
16:34:26 <lambdabot> Title: That Funny Steve Ballmer Video Thing
16:34:34 <chessguy> heh. good title
16:35:12 <nmessenger> > cycle "DEVELOPERS "
16:35:13 <lambdabot>  "DEVELOPERS DEVELOPERS DEVELOPERS DEVELOPERS DEVELOPERS DEVELOPERS DEVELOPER...
16:35:28 <chessguy> bah
16:35:45 <chessguy> this 'totem' thing that came with fedora can't play any movies. it's crap
16:36:21 <shapr> Linux often has problems playing movies that use patented codecs.
16:36:38 <shapr> Since Linus hasn't licensed any of the patents.
16:37:04 <sorear> <pedantic_nitpicker> Linus didn't write totem
16:37:16 * LoganCapaldo makes references to mplayer + sticking windows dlls in an appropiate place
16:37:27 * LoganCapaldo also assumes you are on x86
16:37:37 <chessguy> x86_64
16:37:50 <nmessenger> <pedantic_nitpicker>you forgot the closing tab :P</pedantic_nitpicker>
16:38:09 <nmessenger> s/tab/tag/ *blush*
16:38:34 <chessguy> * slap :Unknown command
16:38:36 <chessguy> awww
16:38:38 * LoganCapaldo says it will still work if you are running the x86 version of fedora or have an x86 chroot
16:38:45 <nmessenger> @slap nmessenger
16:38:46 <lambdabot> why on earth would I slap nmessenger
16:38:52 <chessguy> i'm running fedora-64
16:38:57 <nmessenger> Because I said so!
16:39:04 <chessguy> @slap me
16:39:04 * lambdabot slaps chessguy
16:39:07 <LoganCapaldo> However mplayer still beats on totem
16:39:14 <chessguy> ty
16:39:22 <LoganCapaldo> even if you can't use stolen windows codecs
16:39:34 <nmessenger> @slap me
16:39:34 <lambdabot> why on earth would I slap nmessenger
16:39:39 <nmessenger> :D
16:40:39 <chessguy> ?where punctuation
16:40:40 <lambdabot> I know nothing about punctuation.
16:40:42 <shapr> @shapr shapr
16:40:42 * lambdabot smacks shapr about with a large trout
16:40:47 <chessguy> apparently not
16:41:00 <nmessenger> ?where anything
16:41:00 <lambdabot> I know nothing about anything.
16:41:06 <tuukkah> lambdabot sometimes seems slightly partial
16:41:12 <nmessenger> ?where+ anything http://www.google.com/
16:41:12 <lambdabot> Done.
16:41:15 <chessguy> ?where nothing
16:41:15 <lambdabot> I know nothing about nothing.
16:42:31 <chessguy> well, that was a conversation-killer
16:43:03 <tuukkah> ?where lambdabot
16:43:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:43:14 <nmessenger> ?where myself
16:43:14 <lambdabot> I know nothing about myself.
16:43:42 <tuukkah> ?where+ myself Here I am.
16:43:42 <LoganCapaldo> ?where+ lambdabot Right here!
16:43:43 <lambdabot> Done.
16:43:43 <lambdabot> Done.
16:43:52 <tuukkah> ?where lambdabot
16:43:53 <lambdabot> Right here!
16:43:53 <LoganCapaldo> ?where lambdabot
16:43:53 <lambdabot> Right here!
16:44:07 <LoganCapaldo> hmm
16:44:10 <tuukkah> ?where myself
16:44:10 <lambdabot> Here I am.
16:44:16 <nmessenger> @where+ lambdabot Right here!  Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:44:16 <lambdabot> Done.
16:44:17 <LoganCapaldo> maybe I should put that back
16:44:36 <tuukkah> i got the pronouns wrong, where's my referential transparency
16:45:05 <tuukkah> ?where+ myself Here you are.
16:45:05 <lambdabot> Done.
16:45:40 <nmessenger> ?where me
16:45:40 <lambdabot> You're on IRC, presumably in front of a computer.
16:45:42 <sorear> ?where+ myself You tell me.
16:45:42 <lambdabot> Done.
16:46:04 <jcreigh> hmm, I'm starting to think there Text.Show.Functions should be in prelude, or ghci needs to have better error messages. (see the recent "Partial Application" thread on haskell-cafe)
16:46:19 <jcreigh> *think that
16:46:52 * nmessenger runs ':b Text.Show.Functions' in GHCi.  Gets... nothing.
16:47:03 <tuukkah> the problem with Show is Read
16:47:28 <jcreigh> ah, good point.
16:47:29 <tuukkah> or can we implement Read for functions with hoogle?
16:49:04 <jcreigh> I've just seen a couple threads with newbies getting confused by "No instance for (Show (Int -> Int))" errors, and was thinking about what we could do about it.
16:49:28 <nmessenger> I want 'instance Typeable a => Show a where show = show . typeOf'
16:49:30 <tuukkah> we need a better type system so (+1) and (+2) have separate types %-)
16:50:17 <nmessenger> or even show = ("<"++) . (++">") . show . typeOf, like LB
16:50:52 <nmessenger> at least for ghci toplevel
16:51:34 <tuukkah> that kind of recursion ;-)
16:51:41 <chessguy> ?help
16:51:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:52:05 <chessguy> grr, what's the command to see the system LB is running on
16:52:18 <chessguy> ?bot
16:52:18 <lambdabot> :)
16:52:25 <allbery_b> ?version
16:52:26 <lambdabot> lambdabot 4p469, GHC 6.5 (OpenBSD i386)
16:52:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:52:30 <chessguy> version, that's it
16:52:30 <nmessenger> tuukkah, nuh-uh, the inner 'show' operates on a 'TypeRep' not an 'a'.
16:52:55 <tuukkah> oops, right
16:52:56 <chessguy> heh. only 1500 patches
16:53:28 <nmessenger> well, technically it is recursion, just not the infinite kind :)
16:54:29 <tuukkah> not even of the arbitrary kind
16:54:53 * nmessenger blows a raspberry
16:54:54 * allbery_b doesn't see why ghci couldn't impliitly import something like his suggestion, possibly with a fallback for things that aren't Typeable
16:55:01 <sorear> instance (Finite a, Show b) => Show (a -> b) where show f= "{" ++ concatMap (\v -> show f v ++ " ") values ++ "}"
16:55:05 <chessguy> hmm, what else do i need to muck around with haskell packages? ghc, runhaskell, and darcs are present and accounted for
16:55:13 <sorear> mkcabal?
16:55:19 <LoganCapaldo> If thats recursion then let show = 3 in let show x = show + x in show 1 would be recursion
16:55:28 <allbery_b> ...and of course a recursion trap, presumably via a :set showlen = ...
16:55:30 <sorear> ^--- is a good idea, not *necessary*
16:55:38 <LoganCapaldo> > let show = 3 in let show x = show + x in show 1
16:55:38 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
16:55:39 <lambdabot>       Expe...
16:55:50 <sorear> @pl \fix -> let a = 2 in a
16:55:50 <lambdabot> ($ const 2)
16:55:50 <tuukkah> nmessenger, or how to say it, the shows aren't even the same function
16:55:53 <chessguy> ?where mkcabal
16:55:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
16:55:53 <LoganCapaldo> which it is apparently
16:55:55 <sorear> @pl \fix -> let a = 2 in fix a
16:55:55 <lambdabot> ap id ($ const 2)
16:55:58 <LoganCapaldo> heh
16:55:59 <allbery_b> (like lbot's, except that timing out is the user's problem :)
16:56:00 <nmessenger> LoganCapaldo, the second def of 'show' calls itself, a name is visible in its defintion.
16:56:01 <LoganCapaldo> silly me
16:56:10 <LoganCapaldo> too much ML
16:56:25 <LoganCapaldo> (I didn't say "rec" gosh darn it!)
16:57:06 <sorear> chessguy: what kind of mucking do you want to do?
16:57:17 <chessguy> sorear dunno, i'm a n00b
16:57:33 <sorear> making? installing?
16:57:33 <chessguy> what do i do with mkcabal once i've get'ted it
16:58:05 <sorear> mkcabal --init-project, answer questions, write code, publish
16:58:20 <sorear> it makes a standard empty cabal project
16:58:23 <master_baiter> > let factors n = filter (\m -> n `mod` m == 0) [1 .. n]
16:58:23 <lambdabot>  Parse error
16:58:26 <emu> ...Profit
16:58:30 <master_baiter> > factors n = filter (\m -> n `mod` m == 0) [1 .. n]
16:58:31 <lambdabot>  Parse error
16:58:52 <sorear> master_baiter: s/>/?let/
16:59:20 <master_baiter> ?let factors n = filter (\m -> n `mod` m == 0) [1 .. n]
16:59:21 <lambdabot> Defined.
16:59:28 <nmessenger> > factors 60
16:59:30 <lambdabot>  [1,2,3,4,5,6,10,12,15,20,30,60]
16:59:32 <master_baiter> > factors 18446744073709551557
16:59:36 <lambdabot> Terminated
16:59:57 <master_baiter> > factors 1844
16:59:58 <lambdabot>  [1,2,4,461,922,1844]
17:00:00 <sorear> dons has a CPU quota on the bot.
17:00:00 <nmessenger> > factors 84600
17:00:02 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,18,20,24,25,30,36,40,45,47,50,60,72,75,90,94,100,1...
17:00:12 <LoganCapaldo> > factors a_large_prime
17:00:13 <lambdabot>   Not in scope: `a_large_prime'
17:00:21 <sorear> > factors 39342908505320450
17:00:25 <lambdabot> Terminated
17:00:31 <master_baiter> cool
17:00:35 <nmessenger> > factors 1
17:00:36 <lambdabot>  [1]
17:00:46 <sorear> "That's funny"
17:00:50 <sorear> > take 5 factors 39342908505320450
17:00:51 <lambdabot>      The function `take' is applied to three arguments,
17:00:51 <lambdabot>     but its type `Int...
17:00:56 <sorear> > take 5 $ factors 39342908505320450
17:00:57 <lambdabot>  [1,2,5,10,25]
17:01:00 <sorear> > take 20 $ factors 39342908505320450
17:01:04 <lambdabot> Terminated
17:01:07 <chessguy> maybe i should wait until i find something i want to do, and then figure out what i need to do to do it
17:01:15 <koala_man> > factors 340282366920938463463374607431768211456
17:01:18 <lambdabot> Terminated
17:01:24 <koala_man> pff, it's just 2s
17:01:28 <sorear> waht do you want?
17:01:38 <chessguy> i hate that loose cable
17:02:01 * sorear pulls out his eth cable for 5s
17:02:10 <nmessenger> > factors $ (*(10^100)) $ sum $ map ord "Hasta la vista, baby."
17:02:11 <lambdabot>  []
17:02:19 <chessguy> i need to get wireless working on this machine too
17:02:20 <nmessenger> :(
17:02:33 * sorear needs a better explanation
17:03:46 <tuukkah> badly configured local-area networking
17:04:18 <sorear> I really did disconnect my computer for more like 20s (it's hard to reconnect cables in the dark)
17:04:26 <Botje> electro-magnetic pulses from French above ground nuke testing.
17:04:31 <sorear> and TCP retry did its thing as expected.
17:05:00 <LoganCapaldo> MAGIC
17:05:11 <LoganCapaldo> I love it when it behaves itself
17:05:21 <nmessenger> > factors $ product $ map ord "Hasta la vista, baby."
17:05:25 <lambdabot> Terminated
17:05:28 <nmessenger> Yay!
17:05:41 <tuukkah> sorear, you know how network cards do media sensing and operating systems act on changes and sometimes they may like to bring down the interfaces and kill the connections :-(
17:06:59 <tuukkah> actually it's pretty nice to get networking up the second you plug in the cable in the laptop
17:08:45 <complaisant> ?paste
17:08:46 <lambdabot> http://paste.lisp.org/new/haskell
17:08:52 <sorear> !paste
17:08:53 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
17:09:05 <sorear> lambdabot hasn't been updated yet.
17:10:50 <complaisant> is there any way to access WX window in ghci ?
17:11:22 <complaisant> i can't select anything when i run my program in ghci-6.4 & run the main function..
17:12:21 <LoganCapaldo> hpaste, wrong link. You mean: http://fserv.pikapphi.umr.edu:8000/new
17:12:45 <sorear>  @tell glguy
17:14:03 <tuukkah> complaisant, perhaps there isn't, this is what Gtk points one at: http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
17:14:05 <lambdabot> Title: Gtk2Hs ¬ª Blog Archive ¬ª Writing multi-threaded GUIs, http://tinyurl.com/j7dxw
17:17:01 <tuukkah> more specifically, ghci uses the threaded runtime and gui toolkits aren't compatible with that
17:26:42 <orbitz> allo!
17:27:49 <Botje> hello!
17:29:39 <chessguy> orbitz, salutations and other such pleasantries
17:30:04 <orbitz> hi chessguy, when are you going to grow up to go?
17:30:10 <chessguy> ooh, xchat doesn't have a timestamp. i'm going to miss that
17:30:21 <chessguy> eh?
17:30:30 <orbitz> goguy
17:30:35 <chessguy> oh
17:30:48 <chessguy> i think i'll wait until i solve chess. it's much easier
17:31:11 <orbitz> chess is solved you pansy move on
17:31:24 <chessguy> shows what you know
17:31:59 <chessguy> ooh look! timestamps!
17:32:03 <orbitz> i know all
17:32:15 <chessguy> sweet!
17:34:26 <glguy> hi
17:34:38 * glguy just got back from class
17:36:05 <chessguy> wb, glguy
17:36:35 <glguy> surprise 4 day weekends are great
17:37:30 <chessguy> heh, i bet
17:38:31 <glguy> I'd have plans and things I have to do if it was a planned weekend
17:38:47 <glguy> but I didn't find out until yesterday that I didn't have to work today or tomorrow
17:39:51 <chessguy> sweet
17:42:29 <glguy> !psate
17:42:31 <glguy> !paste
17:42:32 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
17:42:39 <glguy> ?where hpaste
17:42:40 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
17:43:20 <chessguy> so what's something simple i could work on for lambdabot? i want to submit a patch, just to learn how
17:44:02 <glguy> you'd have to ask dons or sorear
17:44:12 <glguy> I didn't bother learning lambdabot
17:44:21 <glguy> or haven't , yet :)
17:44:37 <chessguy> lol, is that a threat? :)
17:45:26 <chessguy> ?seen dons
17:45:27 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 4h 37m 37s ago.
17:46:46 <nmessenger> chessguy, how about @methods SomeClass?  I'd like that.
17:46:55 <glguy> ?src Ord
17:46:56 <lambdabot> class  (Eq a) => Ord a  where
17:46:56 <lambdabot>     compare      :: a -> a -> Ordering
17:46:56 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
17:46:56 <lambdabot>     max, min         :: a -> a -> a
17:47:05 <nmessenger> blah
17:47:15 <chessguy> ...
17:47:15 <chessguy> example?
17:47:20 <glguy> lol
17:48:03 <nmessenger> glguy, is there a @classes SomeType?
17:48:16 <nmessenger> ?src Int
17:48:16 <lambdabot> data Int = I# Int#
17:48:24 <glguy> I don't think so
17:48:27 <glguy> closest is
17:48:31 <glguy> ?instances Ord
17:48:32 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
17:49:28 <nmessenger> but that's only if you know which classes SomeType instanciates :P
17:50:10 <glguy> I said "I don't think so" :-p
17:51:54 <nmessenger> chessguy, @classes Int would show the 'instances' list, comma seperated: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AInt
17:51:56 <lambdabot> http://tinyurl.com/ovjef
17:52:30 <chessguy> are you saying it should get the list dynamically?
17:53:00 <nmessenger> I would presume so, but I've not used Typeable and family myself.
17:54:18 <chessguy> i've heard haskell's http support isn't so hot
17:56:55 <chessguy> Copying patch 1498 of 1498... done!
17:56:56 <chessguy> Applying patch 1498 of 1498... done.
17:56:56 <chessguy> Finished getting.
17:57:00 <chessguy> woohoo!
18:00:06 <jcreigh> > compare () ()
18:00:08 <lambdabot>  EQ
18:00:19 <jcreigh> huh...I didn't know unit was an instance of Orc.
18:00:21 <jcreigh> *Ord
18:00:43 <nmessenger> Zug zug
18:00:47 <mauke> hmm, I like Orc better
18:01:19 * allbery_b wonders what that is supposed to accomplish
18:01:39 <allbery_b> also, Orcs and Monsters?  what next?
18:01:50 <jcreigh> > () < ()
18:01:52 <lambdabot>  False
18:02:09 <jcreigh> yeah, I guess I don't see the point either.
18:02:12 <mauke> > ()> ()
18:02:12 <nmessenger> class Orc a where {pillage :: a -> (); growl :: String; ...}
18:02:13 <lambdabot>  False
18:02:18 <mauke> it's a fish
18:04:50 <jcreigh> > (()>())>(()<())
18:04:52 <lambdabot>  False
18:05:07 <nmessenger> Ordering is in Ord?
18:05:17 <jcreigh> yeah, I think so.
18:05:20 <jcreigh> > LT < GT
18:05:21 <lambdabot>  True
18:05:22 <allbery_b> > LT < EQ
18:05:23 <lambdabot>  True
18:05:28 <mauke> > sort [()..()]
18:05:29 <lambdabot>  [()]
18:05:30 <jcreigh> also, Bool
18:05:34 <jcreigh> > False < True
18:05:36 <lambdabot>  True
18:05:40 <nmessenger> self-referency
18:05:56 <allbery_b> that implies unit's also part of Enum --- another "huh?"
18:06:04 <nmessenger> > fromEnum ()
18:06:05 <lambdabot>  0
18:06:15 <nmessenger> delightful
18:06:27 <jcreigh> > maxBound :: ()
18:06:28 <lambdabot>  ()
18:07:08 <emu> > sort [undefined..undefined]
18:07:08 <lambdabot>  Add a type signature
18:07:13 <allbery_b> > [minBound .. maxBound] :: [()]
18:07:14 <lambdabot>  [()]
18:07:24 <nmessenger> sort [undefined :: Int .. undefined]
18:07:31 <nmessenger> > sort [undefined :: Int .. undefined]
18:07:32 <lambdabot>  Undefined
18:08:32 <emu> > sum [ (1/2)^k | k <- [1..50] ]
18:08:33 <lambdabot>  0.9999999999999991
18:08:55 <chessguy>  > sum [ (1/2)^k | k <- [1..500] ]
18:09:09 <emu> > sum [ (1/2)^k | k <- [0..50] ]
18:09:10 <lambdabot>  1.9999999999999991
18:09:15 <chessguy> oops
18:09:19 <emu> > 1 / (1 - 1/2)
18:09:20 <lambdabot>  2.0
18:09:27 <allbery_b> > sum [ (1/2)^k | k <- [1..500] ]
18:09:28 <lambdabot>  1.0
18:09:59 <emu> > 2 ^^ (log 3)
18:10:00 <jcreigh> Getting the answer you want is faster when you use floats. :)
18:10:00 <lambdabot>  Add a type signature
18:11:33 <chessguy> hmmm
18:11:41 <chessguy> anybody here tried to build lambdabot?
18:11:41 <glguy> what is the question
18:11:50 * allbery_b wonders if Ord is a prerequisite for Enum, and Enum is useful for serializing things like Ordering and ()
18:11:57 <emu> er, is there a way to raise to a fractional exponent?
18:12:11 <allbery_b> ?ty **
18:12:13 <lambdabot> parse error on input `**'
18:12:16 <mauke> > 2 ** log 3
18:12:17 <lambdabot>  2.141486063903278
18:12:18 <mbishop> fractions are silly
18:12:19 <allbery_b> ?ty (**)
18:12:21 <lambdabot> forall a. (Floating a) => a -> a -> a
18:12:21 <nmessenger> ?type (**)
18:12:21 <emu> > 3 ^ log 2
18:12:23 <lambdabot>  Add a type signature
18:12:23 <lambdabot> forall a. (Floating a) => a -> a -> a
18:12:25 <emu> > 3 ** log 2
18:12:25 <allbery_b> ?ty (^^)
18:12:27 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:12:27 <lambdabot>  2.1414860639032773
18:12:37 <emu> yow, 3 ways to do exponents
18:12:43 <allbery_b> yeh
18:12:51 <glguy> each one less efficient than the last
18:12:55 * allbery_b thinks the numeric typeclasses are just a trifle out of control
18:13:09 <glguy> ^ ^^ and ** aren't part of the typeclasses
18:13:11 <nmessenger> (^) integral, (^^) fractional raised to integral, (**) floating point
18:13:22 <glguy> nmessenger: close
18:13:35 <glguy> ^ is for positive powers, ^^ positive and negative
18:13:43 <glguy> ** fractional powers
18:13:48 <nmessenger> > 5 ^ (-2)
18:13:49 <lambdabot>  Exception: Prelude.^: negative exponent
18:14:22 <nmessenger> > 16 ^^ (-2)
18:14:24 <lambdabot>  3.90625e-3
18:21:14 <complaisant> [(row,col) | row <- [1..r] , col <- [1..l]] 5 5
18:21:26 <complaisant> > [(row,col) | row <- [1..r] , col <- [1..l]] 5 5
18:21:27 <lambdabot>   Not in scope: `l'
18:21:39 <nmessenger> (\l r -> ...) 5 5
18:21:59 <complaisant> > (\l r -> [(row,col) | row <- [1..r] , col <- [1..c]]) 5 5
18:22:00 <lambdabot>   Not in scope: `c'
18:22:09 <complaisant> > (\c r -> [(row,col) | row <- [1..r] , col <- [1..c]]) 5 5
18:22:10 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
18:22:50 <Botje> > import Data.Ix; range ((1,1),(5,5))
18:22:50 <lambdabot>  Parse error
18:22:55 <Botje> > range ((1,1),(5,5))
18:22:57 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
18:23:12 <Botje> well, at least you know what module it's in :)
18:23:14 <glguy> flip map [1..5] . (,) =<< [1..5]
18:23:21 * wolverian discovers the joy of debugging a fibonacci stack in java
18:23:27 <wolverian> er, heap..
18:24:16 <nmessenger> glguy, showoff :P
18:24:22 <Botje> that's just badass :(
18:24:34 <glguy> :-p yeah, because someone wouldever use that in real code
18:24:57 <complaisant> > (\(x,y) (w,z) -> (x,y) == (w+1,z+1)) (2,3) (3,4)
18:24:58 <lambdabot>  False
18:25:12 <nmessenger> @pl (\(x,y) (w,z) -> (x,y) == (w+1,z+1)
18:25:12 <lambdabot> (line 1, column 36):
18:25:13 <lambdabot> unexpected end of input
18:25:13 <lambdabot> expecting variable, "(", operator, "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or ")"
18:25:20 <nmessenger> @pl \(x,y) (w,z) -> (x,y) == (w+1,z+1)
18:25:21 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip ((. (1 +)) . (,) . (1 +)) . (((.) . (.) . (==)) .) . (,))
18:25:29 <nmessenger> :O
18:25:32 <complaisant> :O
18:25:33 <complaisant> ?
18:25:35 <complaisant> > (\(x,y) (w,z) -> (x,y) == (w+1,z+1)) (2,3) (3,4)
18:25:37 <lambdabot>  False
18:25:52 <complaisant> > (\(x,y) (w,z) -> (x,y) == (w+1,z+1)) (2,3) (1,2)
18:25:53 <lambdabot>  True
18:26:26 <complaisant> > filter (\(x,y) (w,z) -> (x,y) == (w+1,z+1)) (\c r -> [(row,col) | row <- [1..r] , col <- [1..c]]) 5 5
18:26:27 <lambdabot>      The function `filter' is applied to four arguments,
18:26:27 <lambdabot>     but its type `(a...
18:27:20 <LoganCapaldo> !paste
18:27:21 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
18:30:53 <complaisant> how can i filter these elements [[(1,1),(2,2),(3,3)],[(1,2),(2,3)],[(1,3)],[(2,1),(3,2)],[(3,1)]] from -> (\c r -> [(row,col) | row <- [1..r] , col <- [1..c]]) 33
18:30:55 <hpaste>  LoganCapaldo pasted: if? bah! at http://fserv.pikapphi.umr.edu:8000/5
18:30:56 <complaisant> ?
18:32:08 <glguy> complaisant: you are trying to generate diagonals?
18:32:13 <complaisant> yup
18:33:52 <glguy> > diags n = [[(x,y) | y <- [x..n] | x <- [1..n]] in diags 3 -- step one
18:33:52 <lambdabot>  Parse error
18:34:04 <glguy> > let diags n = [[(x,y) | y <- [x..n] | x <- [1..n]] in diags 3 -- step one
18:34:04 <lambdabot>  Parse error
18:34:10 <glguy> > let diags n = [[(x,y) | y <- [x..n]] | x <- [1..n]] in diags 3 -- step one
18:34:12 <lambdabot>  [[(1,1),(1,2),(1,3)],[(2,2),(2,3)],[(3,3)]]
18:34:19 <glguy> wait
18:34:21 <glguy> close
18:34:30 <Botje> :t inRange
18:34:31 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
18:34:33 <erider> gn
18:35:12 <glguy> > let diags n = [[(x,x-y) | y <- [0..x-1]] | x <- [1..n]] in diags 3 -- step one
18:35:13 <lambdabot>  [[(1,1)],[(2,2),(2,1)],[(3,3),(3,2),(3,1)]]
18:36:09 <Botje> > let add (x,y) = (x+1,y+1) in map (takeWhile (inRange ((1,1),(5,5))) . iterate add) (range ((1,1),(5,5)))
18:36:10 <lambdabot>  [[(1,1),(2,2),(3,3),(4,4),(5,5)],[(1,2),(2,3),(3,4),(4,5)],[(1,3),(2,4),(3,5...
18:36:25 <Botje> that even worked on the first try. scary..
18:37:12 <glguy> > let diags n = [[(x-y,y) | y <- [0..x-1]] | x <- [1..n]] in diags 3 -- step one
18:37:13 <lambdabot>  [[(1,0)],[(2,0),(1,1)],[(3,0),(2,1),(1,2)]]
18:37:44 <glguy> > let diags n = [[(x-y,y) | y <- [0..x]] | x <- [1..n]] in diags 3 -- step one
18:37:45 <lambdabot>  [[(1,0),(0,1)],[(2,0),(1,1),(0,2)],[(3,0),(2,1),(1,2),(0,3)]]
18:38:07 <Botje> huzzah!
18:38:09 <hpaste>  nmessenger pasted: if! bah? at http://fserv.pikapphi.umr.edu:8000/5#1
18:38:45 <ClaudiusMaximus> > (\ r c -> [(d+x,d+y) | d <- [1..(r `min` c)], x <- [0..(c-1)], y <- [0..(r-1)], d+x <= c, d+y <= r ]) 3 3
18:38:46 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(2,2),(2,3),(3,2),(3,...
18:38:47 <genbie> anyone knows if hIDE IDE is functional please?
18:39:14 <ClaudiusMaximus> oops, ignore me
18:39:33 <hpaste>  glguy pasted: if' ' at http://fserv.pikapphi.umr.edu:8000/5#2
18:39:58 <allbery_b> last I heard hIDE was stalled
18:40:22 <genbie> allbery thanks, any IDE you suggest plz?
18:40:43 <nostrademons> Emacs?
18:40:52 <allbery_b> not offhand if your'e looking for a traditional IDE.  I use emacs, myself
18:41:13 <allbery_b> visual haskell may be worth looking at for windows
18:41:27 <genbie> thanks nostra and allbery.. is it OK?
18:42:50 <chessguy> @tell dons what does this message mean when trying to build lambdabot? Setup.hs: cannot satisfy dependency regex-compat-any
18:42:50 <lambdabot> Consider it noted.
18:43:14 <allbery_b> I believe it means you need (a) ghc 6.6 (b) the extralibs foo
18:43:51 <chessguy> the README says that as long as i have at least ghc 4.1 it's ok
18:44:02 <genbie> allbery visual haskell requires windows or just .net?
18:44:25 <glguy> I HAVE to get one of these jobs doing bullshit math in the crime investigation labs
18:44:28 <allbery_b> couldn't tell you
18:44:29 <glguy> as seen on TV
18:44:34 <chessguy> err, 6.4, sorry
18:44:43 <glguy> genbie: visual haskell requires visual studio 200x
18:45:07 <allbery_b> the readme's out of date; it was recently changed to require 6.6 (or at least default to it, check for another cabal file for 6.4)
18:45:09 <genbie> thanks does visual studio run on .net for linux? like dotgnu or mono
18:45:15 <genbie> glguy
18:45:31 <glguy> highly unlikely
18:45:49 <complaisant> can you describe me how to find the polynomal expression for an hylomorphism intermediate data type
18:45:50 <complaisant> ?
18:45:55 <genbie> glyguy thanks,, you also just use emacs?
18:46:05 <glguy> genbie: I don't touch emacs
18:46:09 <glguy> I use visual haskell and vim
18:46:24 <genbie> ah ok ;-)
18:46:33 <genbie> do you run visual haskell on .net?
18:46:42 <genbie> visual studio i mean
18:46:48 <allbery_b> for linux there's also the possibility of eclipse (java-based) with http://eclipsefp.sourceforge.net, but that plugin's still in developmen and I couldn't tell you how complete it is
18:46:49 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
18:47:18 <genbie> yes thanks i know about that one... allbery_b
18:47:22 <glguy> visual haskell is a visual studio plugin
18:47:43 <genbie> yes sorry.. i meant do you run visual studio on .net?
18:48:59 <glguy> I don't know how to answer that question, I'm not sure that it means anything
18:49:03 <nmessenger> are you asking if it compiles Haskell to .Net bytecodes?  I believe it doesn't.
18:49:09 <complaisant> > let diags n = [[(x-y,y) | y <- [1..x-1]] | x <- [1..n]] in diags 3
18:49:11 <lambdabot>  [[],[(1,1)],[(2,1),(1,2)]]
18:49:40 <genbie> glguy i meant is it a .net application?
18:49:48 <Excedrin> does visual haskell do all that fancy argument completion stuff?
18:50:12 <nmessenger> ?google Visual Haskell
18:50:12 <glguy> Excedrin: it has the intellitype drop downs
18:50:12 <lambdabot> Plugin `search' failed with: IRCRaised connect: does not exist (Connection refused)
18:50:20 <nmessenger> :O!
18:50:21 <glguy> genbie: I doubt it
18:50:39 <genbie> http://www.mono-project.com/Working_with_Mono_and_Visual_Studio
18:50:41 <lambdabot> Title: Working with Mono and Visual Studio - Mono
18:50:43 <genbie> i found this
18:51:27 <genbie> lamdabot is one nifty program
18:51:44 <nmessenger> Aye, she is a beaut.
18:52:30 <genbie> looks like AI stuff ;-)
18:52:49 <nmessenger> @vixen Are you still broken?
18:52:49 <lambdabot> <undefined>
18:53:03 <genbie> lamdabot
18:53:33 <nmessenger> genbie, do '/msg lambdabot @' for a list of commands then @help command for information
18:54:08 <nmessenger> @yow
18:54:08 <lambdabot> Are you mentally here at Pizza Hut??
18:54:20 <nmessenger> @protontorpedo
18:54:20 <lambdabot> what makes haskell more fun than say clisp?
18:54:35 <nmessenger> @botsnack
18:54:36 <lambdabot> :)
18:54:48 <genbie> thanks nmessenger
18:55:08 <nmessenger> ?quote lambdabot
18:55:08 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
18:55:11 <genbie> @help
18:55:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:55:23 <genbie> list
18:55:32 <nmessenger> @list
18:55:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:55:36 <genbie> @list
18:55:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:56:35 <nmessenger> @slap genbie
18:56:36 * lambdabot smacks genbie about with a large trout
18:56:41 <genbie> ouch
18:56:44 <glguy> @where lambdabot-complete
18:56:44 <lambdabot> http://mikael.johanssons.org/irssi/lambdabot-complete.pl
18:56:55 <glguy> lambdabot command tab-completion for irssi
18:57:45 <genbie> good night all
18:57:51 <genbie> bye lambda
18:58:03 <nmessenger> 404'ed, googled, result: http://paste.lisp.org/display/34931
19:00:47 <Korollary> hpaste: url?
19:01:02 <sorear> @where hpaste
19:01:02 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
19:01:07 <sorear> tell fodder
19:01:34 <glguy> hi
19:01:38 <sorear> used to be on members.cox.net/stefanor, but shapr tempted glguy away :)
19:01:45 <glguy> :-p
19:01:51 <glguy> he gave me candy and ssh access
19:01:54 <nmessenger> !paste -- Korollary
19:01:54 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:02:02 <Korollary> ah
19:02:27 <Korollary> it looks nice
19:02:51 <sorear> chessguy: regex-compat is in extralibs
19:03:27 <nmessenger> glguy, maybe make hpaste respond to /^hpaste[:,] url/
19:03:33 <sorear> glguy's pre-hpaste @karma was 26
19:03:36 <chessguy> can i darcs get that somewhere?
19:03:40 <sorear> @karma glguy
19:03:40 <lambdabot> glguy has a karma of 38
19:03:48 <glguy> ?karma-all
19:03:48 <lambdabot>  "dons"                112
19:03:48 <lambdabot>  "audreyt"              60
19:03:48 <lambdabot>  "fglock"               42
19:03:48 <lambdabot>  "lambdabot"            42
19:03:48 <lambdabot>  "Cale"                 38
19:03:49 <sorear> @where regex-compat
19:03:50 <lambdabot> [610 @more lines]
19:03:52 <lambdabot> I know nothing about regex-compat.
19:04:00 <Korollary> chessguy: it's a separate download for 6.6
19:04:11 <Korollary> glguy++
19:04:18 <glguy> thanks ;)
19:04:23 <Korollary> who's fglock?
19:04:23 <glguy> nmessenger: that sounds reasonable
19:04:35 <nmessenger> ?seen fglock
19:04:35 <lambdabot> I saw fglock leaving #perl6 6h 39m 24s ago, and .
19:04:38 <chessguy> so i need to have ghc 6.6?
19:04:39 <Korollary> zh
19:04:44 <sorear> chessguy: no
19:04:44 <Korollary> ah
19:04:52 <sorear> chessguy: 6.6 or 6.4
19:05:12 <sorear> chessguy: regex-compat used to be part of the base download
19:05:23 <sorear> chessguy: you'll also need regex and binary
19:05:50 <chessguy> can i darcs get them all?
19:05:58 <sorear> chessguy: be prepared to downgrade binary until things work - there has been much incompatible hacking
19:06:07 <sorear> darcs.haskell.org/binary
19:06:14 <sorear> @where zlib
19:06:14 <lambdabot> darcs get http://haskell.org/~duncan/zlib
19:06:16 <glguy> > let test xs = " url" `isPrefixOf` break (==':') xs in test "hpaste: url"
19:06:17 <lambdabot>  Couldn't match `[Char]' against `([a], [a])'
19:06:22 <chessguy> oh i got zlip
19:06:25 <chessguy> zlib
19:06:28 <glguy> > let test xs = " url" `isPrefixOf`(snd$ break (==':') xs) in test "hpaste: url"
19:06:29 <lambdabot>  False
19:06:33 <sorear> as for regex-compat, any reasonable OS will have it as a package.
19:06:40 <glguy> break (==':') "hpaste: url"
19:06:41 <glguy> > break (==':') "hpaste: url"
19:06:43 <lambdabot>  ("hpaste",": url")
19:06:46 <glguy> oh
19:06:51 <sorear> @src break
19:06:52 <lambdabot> break p =  span (not . p)
19:06:57 <sorear> @src span
19:06:57 <lambdabot> Source not found. That's something I cannot allow to happen.
19:06:58 <chessguy> is zlib extralibs?
19:07:02 <sorear> chessguy: no
19:07:09 <Korollary> glguy: use a regex anyway
19:07:13 <sorear> anything with duncan in it isn't extralibs :)
19:07:31 <sorear> @quote jwz
19:07:32 <lambdabot> No quotes match. Take a stress pill and think things over.
19:07:40 <glguy> Korollary: I've never used a regex in haskell, what library is that?
19:07:47 <sorear> regex-foo
19:07:55 <sorear> e.g. regex-compat
19:07:57 <Korollary> glguy: It's exported from OpenGL
19:07:58 <sorear> e.g. regex-parsec
19:08:22 <glguy> import Text.Regex?
19:08:28 <sorear> i think so
19:08:41 <Korollary> sorry, that was not sarcasm?
19:08:42 <sorear> yes
19:08:53 <nmessenger> test xs = "hpaste" `isPrefixOf`xs && "url" `isContainedIn` xs where isContainedIn is left to the reader ;-)
19:08:54 <chessguy> so i need to darcs get regex-compat, regex, and binary
19:09:06 <sorear> chessguy: don't darcs get regex*
19:09:14 <sorear> chessguy: get it from {rpm,apt}
19:09:28 <sorear> chessguy: (or download it from haskell.org/ghc)
19:09:31 <mauke> @remember Makali Whenever a programmer thinks, "Hey, skins, what a cool idea", their computer's speakers should create some sort of cock-shaped soundwave and plunge it repeatedly through their skulls.
19:09:31 <lambdabot> Done memoising quote for `Makali', if that is their real name...
19:09:32 <glguy> > Text.Regex.mkRegex "^hpaste[:,] url"
19:09:33 <lambdabot>   Not in scope: `Text.Regex.mkRegex'
19:10:14 <sorear> regex is evil, parser combinators rule
19:10:39 <chessguy> grrrrrrrrrrr
19:10:58 <nmessenger> Regexes are only 'evil' in the sense that they are a very large hammer, and take some learning.
19:11:17 <LoganCapaldo> regex has its place, parser combinators rule
19:11:42 <sorear> a very large hammer cleverly engineered to explode if it hits anything that isn't a nail
19:12:02 <chessguy> darcs get darcs.haskell.org/binary doesn't work for me
19:12:38 <thedward> I was parsing a custom config file format with perl regexes; I just rewrote it with parsec and it is about the same size, but readable.
19:12:42 <nmessenger> mauke, where in the world did *that* come from?
19:12:58 <mauke> the internets
19:13:08 <thedward> nmessenger: jwz, if I am not mistaken
19:13:11 <glguy> nick >> oneOf ":," >> spaces >> string "url" -- ?
19:13:16 <sorear> chessguy: you need http:
19:13:29 <chessguy> oh, duh
19:13:48 <sorear> glguy: looks good
19:14:02 <nmessenger> I don't know if the full weight of a parser is necessary, you just need to check if it matches a pattern.  String test functions should suffice.
19:14:26 <chessguy> ok, that worked
19:14:37 <glguy> oops, string nick
19:14:57 <sorear> you weren't using the [Char] monad? :)
19:15:22 <sorear> > "slow!" >>= replicate 5
19:15:23 <lambdabot>  "ssssslllllooooowwwww!!!!!"
19:15:33 <nmessenger> hahaha
19:18:00 <nmessenger> @let xs `isContainedIn` ys = any (xs `isPrefixOf`) (tails ys)
19:18:01 <lambdabot> Defined.
19:18:28 <chessguy> now when i try to build binary, it's not finding Data.ByteString, even though i installed that
19:18:45 <nmessenger> test xs = "hpaste" `isPrefixOf` message && "url" `isContainedIn` message
19:18:53 <mauke> @index isInfixOf
19:18:54 <lambdabot> bzzt
19:18:56 <nmessenger> s/message/xs/
19:18:56 <sorear> @undef
19:18:57 <lambdabot> Undefined.
19:19:04 <mauke> @hoogle isInfixOf
19:19:04 <lambdabot> No matches found
19:19:07 <sorear> @let isContainedIn = isInfixOf
19:19:08 <lambdabot> <local>:1:16: Not in scope: `isInfixOf'
19:19:16 <mauke> :(
19:19:20 <nmessenger> was @undef'ed
19:19:24 <sorear> @hoogle [a] -> [a] -> Bool
19:19:24 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
19:19:24 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
19:19:41 <nmessenger> I did the same hoogle search.
19:19:41 <sorear> odd
19:20:00 <Korollary> this channel needs a collaborative source editing interface
19:20:00 <mauke> .oO( isCircumfixOf :: [a] -> [a] -> [a] -> Bool )
19:20:13 <nmessenger> :D
19:20:15 <sorear> @let isContainedIn = Data.List.isInfixOf
19:20:16 <lambdabot> <local>:1:16: Not in scope: `Data.List.isInfixOf'
19:20:23 <moconnor> Is it possible, given the string "foo" on the command line, to call function foo in the code *without* having something hardcoded (like a case/if/pattern match)?  I'm guessing no, b/c of the static typing, but I'm curious.
19:20:27 <sorear> It's in the LATEST doecs
19:20:38 <sorear> moconnor: it can be done
19:20:42 <nmessenger> doecs?
19:20:47 <sorear> moconnor: see "hs-plugins"
19:20:51 <sorear> docs
19:20:52 <moconnor> sorear: ok
19:21:16 <sorear> hs-plugins is an interface to the compiler and GHCi dynamic linker
19:21:34 <sorear> basically it gives you eval :: String -> Either ParseError Dynamic
19:21:53 <moconnor> cool!
19:22:07 <glguy> hpaste: url
19:22:07 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:22:10 <glguy> hpaste: ur
19:22:12 <glguy> hpaste:url
19:22:13 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:22:15 <nmessenger> hpaste:  url
19:22:15 <sorear> lisppaste2: begone!
19:22:16 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:22:17 <glguy> hpaste url
19:22:17 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:22:28 <sorear>  hpaste: url
19:22:31 <nmessenger> hpaste: will you please tell me the url
19:22:39 <glguy> lisppaste2: what is the url
19:22:42 <sorear> hpaste: quit
19:23:00 * sorear is also doing minor security testing
19:23:01 <nmessenger> hpaste: furl the sails!
19:23:23 <thedward> > (curry id) 'a' 2
19:23:25 <lambdabot>  ('a',2)
19:23:44 <thedward> that hurts my brain
19:23:56 <nmessenger> @check (\x y -> curry id x y == (,) x y)
19:23:56 <lambdabot>  Add a type signature
19:24:07 <sorear> just use (,)
19:24:11 <nmessenger> makes sense to me
19:24:11 <nornagon> :t id
19:24:13 <lambdabot> forall a. a -> a
19:24:29 <nornagon> ... how do you curry that?
19:24:34 <nornagon> :t curry
19:24:36 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
19:24:54 <mauke> easily
19:25:09 <thedward> okay. I've got it.
19:25:15 <nornagon> :t curry id
19:25:16 <lambdabot> forall a b. a -> b -> (a, b)
19:25:22 <nmessenger> '(a,b)' substitutes id's ''a'
19:25:23 <nornagon> zany :)
19:25:34 <mauke> > flip id 2 sqrt
19:25:36 <lambdabot>  1.4142135623730951
19:26:02 <nornagon> :t flip id
19:26:03 <lambdabot> forall b c. b -> (b -> c) -> c
19:26:13 <nmessenger> ($ 2) sqrt
19:26:16 <nmessenger> > ($ 2) sqrt
19:26:17 <lambdabot>  1.4142135623730951
19:26:25 <mauke> ($) = id
19:27:36 <sorear> ok, I'm about to try and kill hpaste by other devious routes...
19:27:53 <mauke> > (+) `id` 2 `id` 3
19:27:54 <lambdabot>  5
19:27:59 <nmessenger> @slap hpaste
19:28:00 * lambdabot slaps hpaste
19:28:51 <glguy> hpaste is smart enough to keep its head above water
19:28:56 <glguy> I'm sure you can find something
19:29:00 <glguy> good luck
19:29:11 <glguy> (I don't think that floods counts..)
19:29:29 <nmessenger> hpaste: gimme that url!
19:29:40 <nmessenger> hpaste: urlurlurlurlurl!!
19:29:41 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:29:55 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:30:00 <nmessenger> hpaste: URL maybe?
19:30:20 <sorear> so you don't consider that a legit attack ?
19:30:35 <glguy> you have to flood it
19:30:40 <glguy> it floods back..
19:30:48 <glguy> both go offline...
19:31:32 <glguy> ok, so I remove /msg responses
19:31:37 <Excedrin> does it ignore lambdabot?
19:31:37 <glguy> you have to be in #haskell
19:31:56 <glguy> Excedrin: if it responds, it does so with a space prefixed
19:32:00 <glguy> so there can't be a loop
19:32:10 <glguy> and lambdabot would have to not prefix with a space
19:32:27 <glguy> but it does
19:32:33 <nmessenger> @id hpaste: url
19:32:34 <lambdabot>  hpaste: url
19:32:38 <sorear> Lambdabot is immune to floods because it does client-side flood control, with 15s timeout on all sends
19:32:45 <lambdabot> No I don't.
19:33:00 <lambdabot> Not for ?msg #haskell, anyway.
19:33:16 <glguy> well, if you are trying to corrupt the channel, you'll just lose your lambdabot privledges
19:33:20 <glguy> so...
19:33:20 <syntaxfree> @help todo
19:33:21 <lambdabot> todo. List todo entries
19:33:27 <sorear> of course.
19:33:34 <syntaxfree> @help todo-add
19:33:35 <lambdabot> todo-add <idea>. Add a todo entry
19:33:38 <glguy> someone could +o and kick the bot
19:33:41 <glguy> it can't stop that either
19:34:33 <syntaxfree> @todo-add Come up with a decent Lord of the Monads joke. (One X to Y them all, one X' to Y' them all, one X'' to Y'' them all and in Z bind them)
19:34:33 <lambdabot> Entry added to the todo list
19:35:09 <sorear> make up your mind! :)
19:35:16 <chessguy> sorry
19:35:24 <chessguy> had some issues with xchat
19:35:53 <syntaxfree> 1:32 AM  lambdabot: 2. dons: write Haskell Manifesto
19:35:56 <syntaxfree> wow. that's ambitious.
19:37:38 <glguy> !paste
19:37:39 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:37:50 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:37:53 <lisppaste2> syntaxfree pasted "(lambdabot) there has to be some way outta this:" at http://paste.lisp.org/display/35611
19:38:02 <sorear> /new
19:38:02 <glguy> sorear: /msg hpaste !paste   please?
19:38:35 <glguy> there, now the bans list protects hpaste :)
19:38:39 <sorear> ok, is it deadlocked or just ignoring me?
19:38:45 <glguy> try in channel
19:38:48 <sorear> !paste
19:38:49 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
19:39:06 <syntaxfree> hpaste should be integrated into lambdabot.
19:39:23 <sorear> is the condition for can-use-msg ==glguy or /=sorear ?
19:39:29 <syntaxfree> maybe one should be even allowed to paste code into an IRC window!
19:39:34 <nmessenger> syntaxfree, maybe some @clip that drops the first five lines of output, thus '@. clip . clip todo' to start at 10?
19:39:53 <sorear> I still propose @paste-more
19:39:55 <syntaxfree> nmessenger: maybe just a way to extract arbitrary pieces.
19:40:09 <syntaxfree> @all, @fromTo, etc.
19:40:09 <lambdabot> Unknown command, try @list
19:40:21 <bd_> hmm, DCC CHAT pastebin perhaps?
19:40:25 <bd_> yikes
19:40:30 <nmessenger> yikes indeed
19:40:31 <glguy> sorear: it just ignores everyone else in /msg
19:40:35 <jcreigh> bd_: don't *do* that. :)
19:40:39 <syntaxfree> @all should be a combinator like @., of course.
19:40:48 <syntaxfree> not context-sensitive like @more. That's hacky.
19:40:49 <lambdabot> *** "Should" gcide "The Collaborative International Dictionary of English v.0.48"
19:40:49 <lambdabot> Shall \Shall\, v. i. & auxiliary. [imp. {Should}.] [OE. shal,
19:40:49 <lambdabot>    schal, imp. sholde, scholde, AS. scal, sceal, I am obliged,
19:40:49 <lambdabot>    imp. scolde, sceolde, inf. sculan; akin to OS. skulan, pres.
19:40:49 <lambdabot>    skal, imp. skolda, D. zullen, pres. zal, imp. zoude, zou,
19:40:51 <lambdabot> [1688 @more lines]
19:41:08 <sorear> @yow
19:41:09 <lambdabot> I'm afraid! I need something in a heavy cream sauce.
19:41:31 <sorear> can anyone say what happened?
19:41:59 <nmessenger> what happened?
19:42:01 <nmessenger> :P
19:42:09 <glguy> hpaste went into attack mode
19:42:09 <syntaxfree> 1:39 AM  lambdabot: 14. ski: provide '@more <number>', at least for privmsg
19:42:15 <syntaxfree> my idea is more general!
19:42:55 <nmessenger>  @fromTo would require partial application of commands to be useful in composition.  Is this possible?
19:42:56 <syntaxfree> @todo-add Instead of @more <number>, have a combinator like @. that extracts arbitrary lines. Example: @fromTo 10 15 @todo
19:42:56 <lambdabot> Entry added to the todo list
19:43:05 <sorear> I want fully generall combinators.
19:43:19 <sorear> @ drop 10 `fmap` todo
19:43:34 <sorear> yes, I want @ to be a monadic >
19:43:41 <syntaxfree> heheh.
19:44:01 <bd_> it occurs to me that lambdabot could use a stronger typesystem. Things like @. pl yow should be statically rejected ;)
19:44:06 <syntaxfree> bah, given Haskell I bet @more is harder to implement than @fromTo
19:44:18 <syntaxfree> bd_: tee hee
19:44:25 <syntaxfree> @. elite . pl yow
19:44:26 <lambdabot> (LIne 2, (01UMN 22): UNExP3(+3d "," exPeC+iNg VaRI4Ble, "(", 0pERa+Or 0r EnD OF InPut
19:44:48 <chessguy> lol
19:44:56 <syntaxfree> Type inference for lambdabot now!
19:44:59 <mauke> @. elite eval nothing
19:45:00 <lambdabot> Say again?
19:45:09 <sorear> @ yow >>= pl >>= elite
19:45:26 <nmessenger> eval does nothing (perversely)
19:45:29 <syntaxfree> @. is really more like bind than (.), right?
19:45:29 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "is"
19:45:42 <chessguy> eval should be a part of HOP
19:45:45 <sorear> more like >=> actually
19:45:55 <nmessenger> ?ty (>=>)
19:45:55 <syntaxfree> @. more . more . more todo
19:45:56 <lambdabot> Not in scope: `>=>'
19:46:06 <nmessenger> ?index (>=>)
19:46:06 <lambdabot> bzzt
19:46:12 <syntaxfree> hmm.
19:46:15 <syntaxfree> @. more todo
19:46:15 <sorear> ?let (a >=> b) c = a c >>= b
19:46:16 <lambdabot> Defined.
19:46:21 <sorear> it's in HEAD
19:46:29 <sorear> Kliesi composition
19:47:01 <sorear> ?pl \a b c -> a c >>= b
19:47:01 <lambdabot> flip . ((>>=) .)
19:47:13 <sorear> liftM flip (>>=)
19:47:13 <syntaxfree> hmm. (>=>) is intuitive in important ways.
19:47:15 <syntaxfree> for beginners.
19:47:21 <moconnor> Is there a tidy program / script for Haskell?
19:47:31 <sorear> yes?
19:47:34 <syntaxfree> I'm still convinced that do notation is evil and that better combinators must be ceated.
19:47:45 <syntaxfree> (>=>) is actually good in that sense.
19:47:47 <sorear> there are lots of tidy programs
19:47:50 <syntaxfree> CRUSH DO NOTATION!
19:47:59 <nmessenger> @slap do notation
19:47:59 <lambdabot> why on earth would I slap do notation
19:48:06 <syntaxfree> For Great Justice.
19:48:08 <sorear> few will admit to writing non-tidy-programs
19:48:19 * nmessenger will, freely!
19:48:20 <sorear> or do I misunderstand "tidy"
19:48:26 <glguy> hpaste isn't particularly tidy
19:48:33 <glguy> tidy is the HTML cleaning program
19:48:36 <glguy> i think he means in that spirit
19:48:42 <nmessenger> tidy like htmltidy?
19:48:47 <sorear> there's ?pretty
19:48:49 <syntaxfree> "tidier"
19:48:56 <syntaxfree> ?pretty woman
19:48:56 <lambdabot> "Parse error" at column 6
19:48:56 <nostrademons> so...Haskell program for cleaning HTML, or program for cleaning Haskell?
19:48:58 <moconnor> sorear: No, I mean tidy as in a program that formats your code for you
19:49:08 <sorear> ?. pretty unpl (flip .) (flip . (.))
19:49:08 <lambdabot> "Parse error" at column -17
19:49:14 <moconnor> sorear: Like perltidy will reformat perl code, and there are others for HTML and other langauges.
19:49:16 <sorear> ?unpl (flip .) . (flip . (.))
19:49:16 <lambdabot> (\ m s b c -> m (c s) b)
19:49:18 <bd_> negative 17?
19:49:23 <syntaxfree> moconnor = roconnor?
19:49:27 <moconnor> syntaxfree: nope
19:49:29 <glguy> ?pretty let a = 10; b = 20 in a + b
19:49:29 <lambdabot>  i = let a = 10
19:49:30 <lambdabot>          b = 20
19:49:30 <lambdabot>        in a + b
19:49:30 <sorear> ?pretty foo m s b c = m (c s) b
19:49:31 <lambdabot>  foo m s b c = m (c s) b
19:49:35 <syntaxfree> bah. confusing people.
19:49:39 <syntaxfree> there's also bringert and bakert.
19:49:43 <nmessenger> bd_, it anticipated a parse error :)
19:49:47 <syntaxfree> bringert is the clever one, bakert is the newbie.
19:49:59 <bd_> nmessenger: Laziness can reverse the flow of time? :)
19:50:50 <glguy> sorear: also: killing hpaste the irc bot doesn't take down the pastebin
19:51:06 <sorear> that's very good
19:51:18 <syntaxfree> @redo L.(<=>) f g
19:51:18 <lambdabot> L . (<=>) f g
19:51:29 <syntaxfree> hmm. not that.
19:51:36 <syntaxfree> @redo L.(>=>) f g
19:51:36 <lambdabot> L . (>=>) f g
19:51:42 <syntaxfree> not smart, redo.
19:51:46 <sorear> glguy: would you be opposed to @paste-more?
19:51:48 <syntaxfree> @src L.(>=>)
19:51:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:51:58 <glguy> sorear: what is the function
19:51:59 <bd_> :t L.(>=>)
19:52:00 <lambdabot> Not in scope: data constructor `L'
19:52:00 <lambdabot>  
19:52:00 <lambdabot> <interactive>:1:2: Not in scope: `>=>'
19:52:07 <nmessenger> :t (L.>=>)
19:52:09 <lambdabot> Couldn't find qualified module.
19:52:23 <sorear> glguy: dumps the entire more buffer into the nearest pastebin
19:52:35 <syntaxfree> 1:43 AM  sorear: ?let (a >=> b) c = a c >>= b
19:52:35 <syntaxfree> 1:43 AM  lambdabot: Defined.
19:52:37 <mauke> @redo (L.<=>) f g
19:52:37 <lambdabot> (L.<=>) f g
19:53:45 <nmessenger> @redo f x >>= g
19:53:45 <lambdabot> do { a <- f x; g a}
19:54:00 <sorear> syntaxfree: are you also opposed to {list,monad} comprehension?
19:54:00 <syntaxfree> 1:50 AM  lambdabot: 17. beelsebob_: "@tell command to make lambdabot give someone a message when they're next seen"
19:54:05 <syntaxfree> isn't that basically done?
19:54:15 <syntaxfree> sorear: not at all. I actually proposed a Comprehensible class in Haskell.
19:54:18 <sorear> @list tell
19:54:18 <lambdabot> tell provides: tell ask messages messages? clear-messages
19:54:24 <sorear> @list todo
19:54:24 <lambdabot> todo provides: todo todo-add
19:54:25 <glguy> sorear: so lambdabot pastes to hpaste?
19:54:28 <syntaxfree> er, in haskell-cafe.,
19:54:34 <glguy> sorear: via msg or http?
19:54:35 <syntaxfree> Data.Map should have comprehensions, too.
19:54:37 <nmessenger> @tell todo
19:54:38 <lambdabot> Consider it noted.
19:54:44 <nmessenger> er,
19:54:44 <sorear> glguy: http.
19:54:47 <nmessenger> @list todo
19:54:48 <lambdabot> todo provides: todo todo-add
19:54:52 <syntaxfree> sorear: do-notation is a broken metaphor.
19:54:53 <glguy> sorear: sure
19:54:57 <sorear> @t
19:54:57 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:55:05 <sorear> @todo 17
19:55:05 <lambdabot> Plugin `todo' failed with: IRCRaised @todo has no args, try @todo-add or @list todo
19:55:08 <sorear> @todo
19:55:08 <lambdabot> 0. SamB: A way to get multiple results from a google search
19:55:08 <lambdabot> 1. dons: improve formatting of @dict
19:55:08 <lambdabot> 2. dons: write Haskell Manifesto
19:55:08 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
19:55:08 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
19:55:10 <lambdabot> [22 @more lines]
19:55:15 <sorear> @todo-delete 17
19:55:15 <lambdabot> Removed: "@tell command to make lambdabot give someone a message when they're next seen"
19:55:22 <syntaxfree> broken analogies leak like neurotic pencils
19:55:30 <syntaxfree> @quote leak
19:55:32 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
19:55:36 <syntaxfree> yes, that.
19:55:41 <sorear> A bad analogy is like a leaky screwdriver
19:55:47 <sorear> oh, beaten
19:55:57 * sorear saw that in a .sig
19:55:59 <mauke> life is like an analogy
19:56:01 <syntaxfree> http://syntaxfree.wordpress.com/2006/12/13/reddit-discussion-considered-productive/
19:56:04 <lambdabot> Title: Reddit discussion considered productive ¬´ Data.Syntaxfree, http://tinyurl.com/yxd7sj
19:56:09 <jcreigh> mauke: no, life is a metaphor.
19:56:30 <syntaxfree> this is a response to reddit comments about my strong anti-do stance, and some musings on analogies, metaphores and abstractions.
19:56:47 <sorear> are those like semaphores? :)
19:57:34 <syntaxfree> hehe.
19:57:41 <syntaxfree> anyway, I'm the anti-do crusader.
19:57:52 <syntaxfree> I'd like to have monad comprehensions, though.
19:58:04 <syntaxfree> I like the type class pathway to syntactic sugar.
19:58:16 <chessguy> monad comprehensions? what would that look like?
19:58:28 <glguy> like list comprehensions
19:58:35 <nmessenger> [x] would be sugar for 'return x'
19:58:38 * sorear --> focus_on_homework
19:58:38 <syntaxfree> do and proc notation can be implemented with the proper type classes.
19:58:45 <syntaxfree> it's ugly that list comprehensions are arbitrary.
19:59:08 <syntaxfree> Lists shouldn't be *that* much of a special datatype in Haskell.
19:59:12 <sorear> btw, \ can be typed using deptypes and implicit parms
19:59:14 <sjanssen> syntaxfree: you don't like do but comprehensions are okay?
19:59:36 <syntaxfree> comprehensions are ugly because they're special for lists.
19:59:47 <sorear> ()_ | str <- getLine ; _ <- putStrLn str]
19:59:47 <syntaxfree> they should be implemented via a type class anyone can instance.
19:59:51 <sorear> [() | str <- getLine ; _ <- putStrLn str]
19:59:56 <sorear> how's that?
20:00:03 <sorear> mocomp IO
20:00:03 <jcreigh> chessguy: before Haskell98, List comprehensions *were* monad comprehensions.
20:00:20 <syntaxfree> in that sense, do notation is nice because I can get it for anything that implements the Monad class.
20:00:30 <syntaxfree> same for proc notation.
20:00:47 <nostrademons> I find proc notation to be basically impenetrable...
20:00:48 <syntaxfree> There's even some intuitive notion that if something fits do notation nicely it should be in Monad.
20:00:58 <syntaxfree> but the intuiition is clearer for comprehensions.
20:01:02 <nostrademons> arrow composition (>>>) makes sense to me, I totally don't understand procs
20:01:08 <syntaxfree> What a comprehension does is *evident*. It's set notation.
20:01:21 <syntaxfree> Why don't I have Set comprehensions?
20:01:30 <syntaxfree> Map comprehensions? Why are lists so special?
20:01:42 <syntaxfree> ergo, Comprehensible.
20:01:48 <chessguy> i don't see what's so bad about do notation, as long as you know what it's sugar for
20:02:00 <syntaxfree> with filter, map and zipWith
20:02:07 <syntaxfree> it's BROKEN.
20:02:12 <sjanssen> syntaxfree: the special privileges of [] don't end with comprehensions
20:02:17 <syntaxfree> again, http://syntaxfree.wordpress.com/2006/12/13/reddit-discussion-considered-productive/#comment-134
20:02:19 <lambdabot> http://tinyurl.com/yxd7sj
20:02:33 <sjanssen> syntaxfree: what is the zip of a Set?
20:02:34 <syntaxfree> sjanssen: well, besides the nice data constructor, what else?
20:03:05 <syntaxfree> sjanssen: dunno. Data.Map comprehensions are clear in my head, though.
20:03:11 <sjanssen> syntaxfree: [] has all the nice names too.  head, tail, map, ...
20:03:27 <sjanssen> syntaxfree: also, standard comprehensions can't express zips
20:03:31 <syntaxfree> that's not on the level of syntactic sugar, though.
20:03:39 <syntaxfree> I can actually attempt to bypass the prelude.
20:04:00 <syntaxfree> anyway, my point is that syntactic sugar should be implementable for arbitrary data types via type classes.
20:04:05 <moconnor> Is there a way to export everything from a module?  Or do you have to manually list every function?
20:04:19 <syntaxfree> failing to do that will gradually lead to Huge Complex Irregular Syntax.
20:04:28 <sjanssen> moconnor: just omit the export part
20:04:47 <sjanssen> syntaxfree: I wouldn't mind monad comprehensions making a comeback
20:04:48 <syntaxfree> I'm not in favor of syntactic minimalism. My nickname is a Sonic Youth tune.
20:04:52 <nmessenger> import Module {- no parens -}
20:04:59 <syntaxfree> monadcomprehensions++
20:05:02 <moconnor> sjanssen: thank you
20:05:18 <nmessenger> oh, export, nvm
20:05:21 <syntaxfree> sjanssen: the thing is: what has to be decided on the level of languae design is the comprehension syntactic sugar.
20:05:37 <syntaxfree> if Comprehensible is implemented, monad comprehnsions can be implemented by normal people.
20:06:01 <syntaxfree> I'm implementing the word "implemented" even in cases where it's not really implementable.
20:06:02 <sjanssen> syntaxfree: I don't see the benefit of introducing this new Comprehensible concept
20:06:05 <syntaxfree> or appropriate.
20:06:14 <syntaxfree> sjannsen: less chaos in syntax.
20:06:30 <nmessenger> Why is Comprehensible needed?  Doesn't 'Monad' specify everything for the sugar?
20:06:42 <sjanssen> syntaxfree: what nmessenger said
20:06:49 <syntaxfree> not really.
20:06:57 <sjanssen> syntaxfree: yes, it does
20:07:01 <syntaxfree> mapM, filterM, etc. are implemented from the baisic operators.
20:07:12 <syntaxfree> you might want map, filter, not derived from join and return.
20:07:18 <sjanssen> modulo the ugliness of fail over an mzero type thing
20:07:33 <sjanssen> syntaxfree: why does it matter how they're derived?
20:08:04 <syntaxfree> sjanssen: if I have an idea of how I want my map and my filter, but don't know how to reverse them into writing a proper bind and return.
20:08:05 <sjanssen> >>= and return are expressive enough, and we already have this great monad infrastructure
20:08:37 <syntaxfree> what I'm saying is that Monad does not contain Comprehensible.
20:09:19 <syntaxfree> It's ugly that I can't implement data MyList elem = Empty | Cons elem MyList
20:09:27 <syntaxfree> and have it use good syntax.
20:09:35 <Anon4888> I agree with syntaxfree, noone will ever use Haskell until we get rid of Monads
20:09:46 <syntaxfree> WAIT. I'M NOT SAYING THAT!
20:09:50 * Anon4888 ducks
20:10:12 * syntaxfree sheds blood from Anon4888's thighs.
20:10:16 <notsmack> @remember syntaxfree "Noone will ever use Haskell until we get rid of Monads."
20:10:16 <lambdabot> Done memoising quote for `syntaxfree', if that is their real name...
20:10:22 <notsmack> ;-)
20:10:23 <syntaxfree> OH FUCK.
20:10:28 <syntaxfree> :(
20:10:36 <sjanssen> Anon4888: keep learning Haskell and you'll change your position
20:10:47 <syntaxfree> if we start misquoting people we'll ruin @quote.
20:10:53 <Anon4888> It was a joke sjanssen ;)
20:11:12 <nmessenger> Anon4888, syntaxfree was re: notsmack
20:11:40 <nmessenger> and you were re: sjanssen.  Nevermind :D
20:12:34 <sjanssen> syntaxfree: I can't think of any types where join is outrageously more difficult than filter
20:12:39 <syntaxfree> sjanssen: do you see why extending syntax by type classes is better than extending them for individual types?
20:12:52 <sjanssen> syntaxfree: I agree on that point
20:13:00 <syntaxfree> well, that's my main point anyway.
20:13:04 <syntaxfree> the rest is implementation detail.
20:13:04 <sjanssen> I disagree that a separate class is needed for comprehensions
20:13:14 <nmessenger> syntaxfree, ditto, but what other sugar would benefit from classes?
20:13:15 <syntaxfree> yes. I didn't think Comprehensible fully through.
20:13:40 <chessguy> by the way, i ran across an interesting monad tutorial on the wiki that nobody seems to talk about much
20:14:33 <chessguy> http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
20:14:34 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki
20:14:48 <syntaxfree> I wonder if extending syntax by type classes is a concern at all for the standardization processes.
20:14:50 <nmessenger> sounds interesting
20:15:24 <chessguy> i think his idea of developing something really off-the-wall into a monad is a good one, though he goes way too far
20:15:30 <chessguy> and doesn't explain it all that well
20:16:15 <syntaxfree> of course, there's the temptation of putting stuff in type classes disregarding theorems that should hold.
20:16:46 <syntaxfree> e.g. making a new type an instance of Monad, even though it isn't, to get do notation.
20:16:50 <glguy> !quit -- restart test, pastebin site should stay up
20:17:00 <syntaxfree> as the language gets more popular, stupidity is bound to happen.
20:17:16 <syntaxfree> I already saw someone who redefined (.) to be reverse $
20:17:22 <syntaxfree> so he got [1,2,3].head
20:17:41 <sjanssen> syntaxfree: they do that in PLEAC
20:17:47 <syntaxfree> PLEAC?
20:17:53 <syntaxfree> maybe that's where I saw it.
20:18:03 <nmessenger> ?google PLEAC
20:18:04 <lambdabot> http://pleac.sourceforge.net/
20:18:04 <lambdabot> Title: PLEAC - Programming Language Examples Alike Cookbook
20:18:06 <sjanssen> programming language example something something
20:18:14 <syntaxfree> ah, yes, I think that was it.
20:18:18 <syntaxfree> That's evil, man.
20:18:35 <sjanssen> syntaxfree: the code is rife with little nasty things like that
20:18:47 <sjanssen> I wrote a mailing list rant about it once
20:18:48 <syntaxfree> why did they bother doing that?
20:19:11 <augustss> because they could :)
20:19:17 <sjanssen> syntaxfree: whoever wrote it wanted to look as similar to Perl as possible, I guess
20:19:20 <syntaxfree> anyway. Syntax Extension Typpe Classes should be designed so to discourage abuse.
20:19:48 <syntaxfree> I haven't seen  any case of do-notation abuse yet, but.
20:20:09 <glguy> !quit
20:20:16 <syntaxfree> what are other hanging bits of syntax in Haskell besides list comprehensions?
20:20:22 <chessguy> ?dict misogyny
20:20:23 <lambdabot> Supported dictionary-lookup commands:
20:20:23 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:20:23 <lambdabot> Use "dict-help [cmd...]" for more.
20:20:33 <chessguy> ?dict misogyny all-dicts
20:20:33 <lambdabot> Supported dictionary-lookup commands:
20:20:33 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:20:33 <lambdabot> Use "dict-help [cmd...]" for more.
20:20:36 <glguy> cool, I can restart the bot remotely
20:20:45 <chessguy> ?alldicts misogyny
20:20:46 <nmessenger> @wn misogyny
20:20:47 <lambdabot> *** "Misogyny" gcide "The Collaborative International Dictionary of English v.0.48"
20:20:47 <lambdabot> Misogyny \Mi*sog"y*ny\ (m[i^]*s[o^]j"[i^]*n[y^]; 277), n. [Gr.
20:20:47 <lambdabot>    misogyni`a: cf. F. misogynie.]
20:20:47 <lambdabot>    Hatred of women. Contrast {misandry}. --Johnson.
20:20:47 <lambdabot>    [1913 Webster]
20:20:49 <lambdabot> [17 @more lines]
20:20:51 <lambdabot> *** "misogyny" wn "WordNet (r) 2.0"
20:20:53 <lambdabot> misogyny
20:20:55 <lambdabot>      n : hatred of women [syn: {misogynism}]
20:20:58 <chessguy> aha
20:23:16 <glguy> !id echo
20:23:17 <hpaste> echo
20:23:19 <syntaxfree> About do-notation: "The problem here, as stated by ricercar, is that do-notation is by design an analogy to imperative (I should rather say, destructive-update sequential-evaluation) programming, and yet the analogy breaks the moment you step out of the IO monad ‚Äî for example, working with Parsec. "
20:23:34 <nmessenger> (.) = flip ($) -- in non-joke example code makes me nauseous
20:24:07 <chessguy> see, i don't see it as an analogy to imperative. to me, it's just a convenience
20:24:15 <glguy> ?type flip ($)
20:24:16 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
20:24:17 <chessguy> not that i know anything
20:24:34 <chessguy> ?src (.)
20:24:34 <lambdabot> (.) f g x = f (g x)
20:25:43 <syntaxfree> chessguy: have you seen YAHT?
20:25:53 <chessguy> sure
20:26:21 <augustss> Why is do notation like assignment?  List comprehension are very similar, and they don't get interpreted as assignments.
20:26:26 <syntaxfree> it mentions do notation -- in a complex, unrealistic  text-mode interaction example similar to the ones kids used to do in Basic too -- before polymorphic types or type clasaes are mentioned.
20:26:51 <nmessenger> To keep the analogies seperate, I always read '<-' as 'is drawn from'
20:27:00 <augustss> yep
20:27:08 <syntaxfree> so you're basically led to think do-notation is a separate imperative space in Haskell.
20:27:33 <syntaxfree> Larry Wall even said once something along the lines of "Haskell is pure and you can't set variables, except when you can."
20:28:02 <chessguy> Larry Wall has snide comment's to make about everything
20:28:13 <augustss> Well, misunderstandings about Haskell abound.
20:28:17 <syntaxfree> well, yes. But Larry Wall is an experienced programmer.
20:28:17 <chessguy> s/'//
20:28:44 <Korollary> There are a lot of experienced programmers.
20:28:46 <syntaxfree> if Larry freaking Wall can't grok something about our language, we're teaching it wrong.
20:28:59 <bos31337> syntaxfree: i doubt it.
20:29:11 <nmessenger> I understand now, the gripe is not that beginners have too much trouble understanding it, but that people who don't understand, misrepresent.
20:29:15 <augustss> I think some people are not willing to learn.  They think they already know everything.
20:29:20 <chessguy> first of all, he could have been completely joking when he said that. that meshes perfectly with his sense of humor
20:29:25 <Korollary> otoh, if you learned it, and Larry Wall couldn't, what does that tell about Larry Wall & you?
20:29:55 <syntaxfree> wait, wait, wait. What I'm criticizing here is specifically YAHT introducing do-notation too early and with an involved interaction example that's unrealistic in the post-1985 world.
20:30:31 * allbery_b thinsk lwall is not so much incapable as uninterested
20:30:36 <syntaxfree> Korollary: I didn't learn from pure YAHT. I learned from a mixture of Gentle Introduction, hack hack hack ask stupid questions hack hack hack and YAHT.
20:30:38 <chessguy> syntaxfree, that's not where you started from. you started from saying do-notation itself is evil
20:30:47 <syntaxfree> well, yes, wait.
20:30:54 <sjanssen> syntaxfree: if YAHT doesn't introduce do early enough, readers will complain that Haskell can't do IO
20:31:00 <chessguy> yup
20:31:04 <syntaxfree> sjanssen: TEACH INTERACT, damnit.
20:31:20 <sjanssen> syntaxfree: interact is not expressive enough
20:31:20 <chessguy> @type interact
20:31:22 <lambdabot> (String -> String) -> IO ()
20:31:25 <syntaxfree> I only found out about interact after writing a rant on my shiny new Haskell blog.
20:31:28 <augustss> syntaxfree: interact is only interesting for toys
20:31:36 <chessguy> what the heck is interact?
20:31:40 <syntaxfree> interact is interesting for Unix-type filters.
20:31:51 <syntaxfree> interact f = getContents >>= putStr . f
20:31:55 <augustss> filters that don't need arguments
20:31:57 <allbery_b> interact filters stdin to stdout through a user-defnned filter
20:32:02 <augustss> @src interact
20:32:02 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:32:10 <Korollary> You could write your own tutorial and see if more people like it. YAHT is what it is.
20:32:11 <nmessenger> > interact (unlines . sort . lines) -- is an input sorter
20:32:12 <lambdabot>  <IO ()>
20:32:16 <sjanssen> syntaxfree: the complaint becomes "Haskell can't read from multiple files" if you teach interact
20:32:30 <syntaxfree> write more combinators.
20:32:40 <syntaxfree> >=> as previously defined here is interesting.
20:32:55 <syntaxfree> it contains lambda expression explosion somewhat.
20:32:59 * nmessenger admits that he was a little scared of the myriad operators at first.
20:33:05 <chessguy> ?src L.(>=>)
20:33:06 <lambdabot> Source not found. You speak an infinite deal of nothing
20:33:10 <sjanssen> but we already have a well developed set of combinators for doing IO
20:33:21 <chessguy> @type L.(>=>)
20:33:23 <lambdabot> Not in scope: data constructor `L'
20:33:23 <lambdabot>  
20:33:23 <lambdabot> <interactive>:1:2: Not in scope: `>=>'
20:33:23 <nmessenger> chessguy, paren before L.
20:33:26 <syntaxfree> write more combinators for beginners.
20:33:32 <chessguy> @type (L.>=>)
20:33:33 <lambdabot> Couldn't find qualified module.
20:33:53 <nmessenger> musta been @undef'ed
20:34:04 <syntaxfree> most common IO patterns are easily abstractable away anyway.
20:34:20 <allbery_b> @type doesn't do @let stuff still
20:34:22 <lambdabot> parse error on input `do'
20:34:29 <allbery_b> hush, you :p
20:34:43 <syntaxfree> yes. error on do. No more do! Crush do! For great justice!
20:34:58 <nmessenger> What You Say !!
20:35:11 <chessguy> lol
20:35:13 <syntaxfree> wait. do you agree that do-notation is by design an analogy to imperative programming?
20:35:18 <syntaxfree> hint: DO notation.
20:35:26 <chessguy> All. Your. Do. Are. Belong. To Us.
20:35:33 <syntaxfree> not "multiline notation" or "sequence notation".
20:35:49 <nmessenger> Me?  I'm fond of it as a shortcut, now that I can desugar it in my head.
20:35:57 <sjanssen> syntaxfree: do does have a flavor of operations in sequence
20:36:16 <chessguy> syntaxfree, i don't agree with that. i think imperative programming is one way of comprehending do-notation, for people who are more familiar with thinking that way
20:36:23 <syntaxfree> just think of do notation for the list monad.
20:36:35 <syntaxfree> what sense does do-notation for lists make?
20:36:47 <sjanssen> it makes plenty of sense
20:36:48 <notsmack> is map by design an analogy to cartography?
20:37:30 <syntaxfree> map is not special syntactic sugar.
20:37:47 <syntaxfree> I can write "fudge = map" and be happy.
20:37:50 <notsmack> syntaxfree: it's pretty fun on lists.  you can treat multiple results as one, and feed them places that only expect one, getting all results
20:38:14 <nmessenger> > fudge negate [1..5]
20:38:14 <lambdabot>   Not in scope: `fudge'
20:38:17 <syntaxfree> nothing you can't do on the list monad.
20:38:22 <syntaxfree> er, on bind notation.
20:38:26 <allbery_b> are we going to bring up the map == fmap == (.) again, then?
20:38:35 <nmessenger> by all means!
20:38:36 <notsmack> syntaxfree: nor is IO?
20:38:41 <syntaxfree> > [1,2,3]>>=(+1)
20:38:42 <lambdabot>   add an instance declaration for (Num [b])
20:38:52 <syntaxfree> > "Hello" >>= toUpper
20:38:53 <lambdabot>  Couldn't match `[b]' against `Char'
20:39:00 <allbery_b> return?
20:39:05 <syntaxfree> yes.
20:39:13 <syntaxfree> > "Hello"  >>= return toUpper
20:39:14 <lambdabot>      Expecting a function type, but found `a'
20:39:14 <lambdabot>       Expected type: [b]
20:39:14 <lambdabot>       ...
20:39:16 <nmessenger> > "Hello" >>= return . toUpper
20:39:17 <lambdabot>  "HELLO"
20:39:19 <syntaxfree> bah, put a dot there.
20:39:26 <allbery_b> same with the other one :)
20:39:31 * sjanssen is off to watch Bill O'Reilly on the Colbert Report
20:39:52 <nmessenger> > "aah!" >>= replicate 5
20:39:53 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
20:40:02 <syntaxfree> hehe.
20:40:26 <LoganCapaldo> mmm, clever
20:40:35 <augustss> > do c <- "aah!"; replicate 5 c
20:40:36 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
20:40:47 <syntaxfree> Haskell has some ugly syntactic warts that can be fixed using ordinary combinators, that's where I rest my case.
20:40:53 <chessguy> @undo do { t <- foo; h <- bar }
20:40:54 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 25}) "Parse error"
20:41:19 <syntaxfree> @undo do { t <- foo; h <- bar; return 2 }
20:41:19 <lambdabot> foo >>= \ t -> bar >>= \ h -> return 2
20:41:23 <augustss> > [ d | c <- "aah!", d <- replicate 5 c ]
20:41:24 <nmessenger> not my own invention, someone earlier did '"slow!" >>= replicate 5'
20:41:24 <lambdabot>  "aaaaaaaaaahhhhh!!!!!"
20:41:27 <chessguy> oh, whoops
20:42:28 <syntaxfree> question: in do { t<-foo; h<-bar; return 2}, do foo and bar get called?
20:42:42 <syntaxfree> (I guess they do, looking at unsugared form)
20:42:53 <chessguy> i wouldn't think so
20:42:55 <allbery_b> they do if the monad permits it
20:43:01 <LoganCapaldo> Doesn't that depend on if they are needed?
20:43:03 <nmessenger> 19:15:22 <sorear> > "slow!" >>= replicate 5
20:43:08 <chessguy> they don't need to be evaluated
20:43:16 <augustss> It depends on exactly what >>= does
20:43:17 <allbery_b> if the monad is Maybe, foo will het called, bar won't if foo returned Nothing
20:43:28 <syntaxfree> then the sequencing interpretation of do {}  is broken.
20:43:48 <augustss> Who say do {} is sequencing?
20:43:49 <chessguy> but sequencing isn't the primary purpose of it
20:44:05 <syntaxfree> duh, layout, braces, semicolons, C syntax?
20:44:18 <syntaxfree> chessguy: I know that. You know that. That's because we know what (>>=) does.
20:44:24 <nmessenger> 'return' is also a little suggestive
20:44:33 <augustss> syntaxfree: it's all in your mind ;)
20:44:38 <chessguy> connect :: IO Bot
20:44:38 <chessguy> connect = notify $ do
20:44:38 <chessguy>     t <- getClockTime
20:44:38 <chessguy>     h <- connectTo server (PortNumber (fromIntegral port))
20:44:38 <chessguy>     hSetBuffering h NoBuffering
20:44:39 <chessguy>     return (Bot h t)
20:44:44 <chessguy> nobody could mistake that for C
20:45:09 <syntaxfree> one day, C and Java programmers are gonna come in reams to try and learn Haskell.
20:45:44 <nmessenger> emphasis on 'try'?
20:46:00 <syntaxfree> is do { [x]<-getArgs; y<-2*x; return y}  valid, btw?
20:46:14 <syntaxfree> @undo do { [x]<-getArgs; y<-2*x; return y}
20:46:14 <lambdabot> getArgs >>= \ a -> case a of { [x] -> 2 * x >>= \ y -> return y; _ -> fail ""}
20:46:30 <nmessenger> getArgs should be 'IO [String]' so you need to 'read x'
20:46:34 <chessguy> what the heck
20:46:37 <syntaxfree> well.
20:46:38 <augustss> syntaxfree: that's illegal with the normal *
20:46:46 <syntaxfree> what I mean is, y<-2*x valid?
20:46:52 * syntaxfree is still unsure of <- semantics.
20:46:58 <augustss> @type do { [x]<-getArgs; y<-2*x; return y}
20:46:59 <lambdabot> Not in scope: `getArgs'
20:47:05 <syntaxfree> augustss: you'll prolly need to liftM it, right?
20:47:21 <augustss> y <- return $ 2 * x
20:47:25 <nmessenger> you could 'return' it into IO, but since it's pure, a 'let' binding is probably better
20:47:41 <nmessenger> let y = 2 * x
20:48:04 <syntaxfree> now wait until java programmers do this:
20:48:05 <augustss> that's indeed what you should do
20:48:07 <syntaxfree> :t return
20:48:08 <nmessenger> s/x/(read x)/ of course
20:48:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
20:48:19 <syntaxfree> :t join
20:48:20 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
20:48:25 <nmessenger> JAVA PROGRAMMER BRAIN SPLODEY!
20:48:32 <syntaxfree> and conclude they need to join . join . return . return
20:48:40 <syntaxfree> :t join . return
20:48:42 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
20:49:00 <augustss> :t join . join . return . return
20:49:01 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
20:49:12 <nmessenger> > join (return [1])
20:49:13 <lambdabot>  [1]
20:49:15 <syntaxfree> how many beginners you have seen writing entire programs inside do?
20:49:17 <LoganCapaldo> hey look, its the identity function for monadic values :)
20:49:25 <syntaxfree> @free join
20:49:27 <lambdabot> Expected variable or '.'
20:49:33 <syntaxfree> @free join . return
20:49:34 <lambdabot> Extra stuff at end of line
20:49:39 <syntaxfree> @free return
20:49:41 <lambdabot> Expected variable or '.'
20:49:45 <syntaxfree> @free (+)
20:49:46 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:49:46 <LoganCapaldo> @free pizza
20:49:48 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `pizza'\n\n"
20:49:51 <syntaxfree> :(
20:49:53 <chessguy> lol
20:49:54 <syntaxfree> @free map
20:49:56 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
20:50:32 <chessguy> @help free
20:50:32 <lambdabot> free <ident>. Generate theorems for free
20:50:45 <Teltariat> Greets folk.  I'm no Haskell expert, so I have a couple of idiotic questions...
20:50:53 <augustss> I don't think @free can handle contexts
20:50:59 <chessguy> Teltariat, those are our favorite kind
20:51:07 <glguy> they are?
20:51:10 <syntaxfree> Teltrariat: join in the party.
20:51:17 <syntaxfree> Leave clothing at front door.
20:51:18 * chessguy glares at glguy
20:51:26 <nmessenger> Newbies to swamp! Yay!
20:51:27 <syntaxfree> s/clothing/imperative expectations
20:51:30 <Teltariat> Would it be safe to say that Glasgow Haskell is considered "THE" Haskell compiler?
20:51:47 <augustss> Teltariat: by most people
20:52:14 <syntaxfree> augustss: it seems to me that Haskell'  is basically standardizing what GHC already does.
20:52:27 <augustss> syntaxfree: some of what GHC does
20:52:33 <bd_> syntaxfree: That makes it easy to implement :)
20:52:46 <syntaxfree> anyway, Haskell'  isn't proposing new stuff, with compilers then running to implement them.
20:53:08 <syntaxfree> (Teltariat: Haskell'  will be the new proper, de jure Haskell standard)
20:53:13 <augustss> syntaxfree: No, the idea with Haskell' is to consolidate known and tried ideas.
20:53:19 <Teltariat> Although I haven't actually tried it, I like how it seems to be that darcs comes as a single standalone binary.  I have a stupid idea that I want to implement as a portable binary for Linux, BSD, Windows that I (and whoever else is as foolish as I) can just downloadn and run
20:53:24 <chessguy> well, haskell is just ahead of its documentation. worse things could happen to a language
20:53:26 <syntaxfree> augustss: is that the same with, say, C99?
20:53:50 <Teltariat> I wanted said binary to include, built-in, stuff like a web server, embedded database, the ability to serve RSS, talk to LDAP and other things
20:54:11 <Teltariat> Its a fool's errand, a lot of stuff involved, but thats why I'm considering doing it in a functional language
20:54:18 <augustss> syntaxfree: well, I think it was true for many features in C99.  Even if they changed syntax from e.g. gcc
20:54:21 <syntaxfree> Teltrariat: oh, well. you just need to compile for every platform you want to target.
20:54:29 <LoganCapaldo> -fkitchen-sink
20:54:32 <Teltariat> :)
20:54:46 <nmessenger> -fsimulate-lambdabot
20:54:54 <syntaxfree> There are a few web frameworks that are basically "web server generators".
20:54:55 <chessguy> heh
20:54:59 <Teltariat> As I just finished telling the Scheme guys, "But I am a fool. A fool who knows he is headed towards his destruction.  But nevertheless, I want to try still."
20:55:08 <chessguy> on that note....g'night all
20:55:15 <augustss> Teltariat: First, I'm not sure why you'd want all that in one binary.  Second, why not do it in Haskell?
20:55:37 <syntaxfree> augustss: but does C99 propose new features that weren't already in common C compilers?
20:55:37 <Teltariat> augustes: thats why I am here.  I an *considering* Haskell too
20:56:15 <augustss> Ah
20:56:22 <araujo> Teltariat, welcome to the fun(ctional)!
20:56:33 <syntaxfree> Teltariat: I've never seen  a community so welcoming to beginners and willing to answer basic questions.
20:56:36 <Teltariat> Apache Derby and HSQLDB are 100% embedded Java databases that can just be included into a Java project.  Does Haskell have something similar?
20:56:48 <Teltariat> Thanks araujo
20:56:56 <syntaxfree> Maybe it's that (a) we don't get many beginners, and not many stupid beginners for one too.
20:57:09 <syntaxfree> and (b) there are many many very very smart peop.
20:57:13 <syntaxfree> s/peop/people.
20:57:25 <syntaxfree> Arrogance is nonlinear on intelligence.
20:57:32 <bd_> Teltariat: There's HAppS, which is a web server, a mail server (?), and a transactional database, as well as some other stuff :)
20:57:39 <syntaxfree> It peaks at slightly-above-average and then collapses fast.
20:57:44 <Teltariat> I am afraid that if I /do/ choose Haskell, my idiocy will drive you all to your limits.
20:57:46 <bd_> [naturally you can disable the bits you don't need]
20:57:56 <Teltariat> bd_, that sounds interesting
20:58:03 <syntaxfree> Teltariat: they tolerated *me* when I started out.
20:58:11 <syntaxfree> They still do now that I also rant about it in public :P
20:58:12 <notsmack> ?where happs
20:58:12 <lambdabot> http://happs.org
20:58:44 <nmessenger> Teltariat, how comfortable are you coding Haskell?  Having you written a single line?
20:58:52 <nmessenger> s/Having/Have/
20:58:55 <bd_> Teltariat: best not to dive into HAppS for your first project ;)
20:59:09 <syntaxfree> Teltariat: my single piece of advice would be "try to think of what code means, not what it does".
20:59:33 <Teltariat> nmessenger: I am complete and utter newbie.  I don't know any functional languages, though I have been reading up and looking at code examples of Common Lisp, Erlang, Scheme and Haskell
20:59:40 <syntaxfree> (Later it's interesting to understand operational semantics, the time/space complexity of your code, etc. But not now)
20:59:53 <syntaxfree> Haskell is declarative. Enjoy it.
21:00:04 <notsmack> Teltariat: haskell sounds like a pretty good choice, but learn the basics before you dive into that.
21:00:08 <notsmack> ?where yaht
21:00:08 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:00:18 <nmessenger> Teltariat, go to haskell.org, click 'Haskell in 5 steps' on the left, then move on to 'Learning Haskell'
21:00:30 <LoganCapaldo> main = putStrLn "Hello, world!"
21:00:38 <LoganCapaldo> there, all you really need to know :)
21:00:57 <syntaxfree> Teltariat: think of Haskell as mathematics, not as a list of commands a robot will execute.
21:01:20 <syntaxfree> the first programming book I read had actually illustrations of robots reading pieces of paper with BASIC code.
21:01:51 <nmessenger> syntaxfree, while sage advice, it seems a little abstract for starting out.
21:01:55 <notsmack> right.  the runtime is evaluating the result of main, not executing lines of code
21:02:09 <Teltariat> If one were to pay enough attention to programming.reddit, the fear of Monads would be put into him, even though he doesn't know what Monads are.... :p
21:02:11 <syntaxfree> nmessenger: well, I'm trying to remove imperative expectations.
21:02:14 <glguy> Beware, for example Common Lisp only pretends to be functional, if it pretends at all
21:02:32 <syntaxfree> nmessenger: the most common complaint of complete beginners here is "what does X do?"
21:02:38 <glguy> prog.reddit.com might as well be digg.com now ;)
21:02:41 <nmessenger> > "Monads are fun!" >>= replicate 2
21:02:42 <Teltariat> glguy: come again?
21:02:42 <lambdabot>  "MMoonnaaddss  aarree  ffuunn!!"
21:02:52 <bd_> Teltariat: Monads just want to be your friends! They're a little shy though...
21:02:59 <syntaxfree> @type replicate
21:03:00 <lambdabot> forall a. Int -> a -> [a]
21:03:02 <mbishop> glguy: yeah
21:03:04 * mbishop sighs
21:03:05 <LoganCapaldo> Wow
21:03:13 <glguy> Teltariat: you mentioned common lisp ina list of functional languages
21:03:16 <mbishop> someone get some good hosting, use happs and start a new reddit :)
21:03:17 <nmessenger> > replicate 5 'a'
21:03:18 <lambdabot>  "aaaaa"
21:03:26 <syntaxfree> > "MOnads are fun!" >>= ("-"++) . replicate 2
21:03:27 <lambdabot>  "-MM-OO-nn-aa-dd-ss-  -aa-rr-ee-  -ff-uu-nn-!!"
21:03:34 <syntaxfree> that's better stuttering code.
21:03:39 <LoganCapaldo> > let  spooky = (>>= replicate 2) in spooky "I am a ghost"
21:03:40 <lambdabot>  "II  aamm  aa  gghhoosstt"
21:03:52 <nmessenger> Teltariat, you should also get to know lambdabot pretty well ;-)
21:04:02 <syntaxfree> Teltariat: think declarative.
21:04:05 <syntaxfree> god, we should have a TV ad.
21:04:12 <glguy> a motivational poster!
21:04:13 <Teltariat> lol
21:04:17 <nmessenger> Ooh! and a jingle!
21:04:26 <Teltariat> I know a bit of Photoshop, I can make one for you if you'd like. :)
21:04:28 <syntaxfree> "Because those who are crazy enough to prove theorems, are the ones who code."
21:04:28 <glguy> They aren't just good ideas, they are the monad laws
21:05:01 <augustss> syntaxfree: why "Think declarative."?  Why not just "Think!"? :)
21:05:22 <syntaxfree> Haskell is mathematics.
21:05:23 <bd_> > concat $ intersperse "-" $ map (replicate 2) "Readability is more fun!"
21:05:24 <lambdabot>  "RR-ee-aa-dd-aa-bb-ii-ll-ii-tt-yy-  -ii-ss-  -mm-oo-rr-ee-  -ff-uu-nn-!!"
21:05:32 <LoganCapaldo> "Haskell: This time, the grasshopper wins."
21:05:40 <syntaxfree> To its deepest core, Haskell is mathematics.
21:05:53 <syntaxfree> Think of it as mathematics and you'll have lotsa fun.
21:06:19 <augustss> syntaxfree: But all programming is mathematics, it's just hidden better in most other languages.
21:06:19 <nmessenger> x = blah -- is strong equivalence, the lhs can be used anywhere the rhs can
21:06:40 <glguy> syntaxfree: are you drunk? or is your mathematics key stuck?
21:06:51 <glguy> I count 4 mentions in the last 5 minutes
21:06:52 <glguy> ;)
21:07:13 <glguy> think of Haskell as mathematics--Haskell is mathematics.--To its deepest core, Haskell is mathematics.--Think of it as mathematics and you'll have lotsa fun.
21:07:16 <LoganCapaldo> > fix ("Mathematics":)
21:07:17 <lambdabot>  ["Mathematics","Mathematics","Mathematics","Mathematics","Mathematics","Math...
21:07:23 <Teltariat> Remember when I told you guys that my idiocy would press you all to your limits?  Well, I'm one of those people who never did that well with math. :-/
21:07:38 <Teltariat> lol, and the channel goes silent.
21:07:40 <notsmack> > unwords $ fix ("Developers, ")
21:07:41 <lambdabot>  Couldn't match `[String] -> [String]' against `[Char]'
21:07:42 <bd_> Teltariat: That's okay, it's a different kind of math than most people learn in school :)
21:07:47 <Korollary> Is there an xquery implementation in Haskell?
21:07:54 <notsmack> > unwords $ fix ("Developers, ":)
21:07:55 <lambdabot>  "Developers,  Developers,  Developers,  Developers,  Developers,  Developers...
21:08:03 <Teltariat> lol, Steve Balmer
21:08:07 <Teltariat> No, I'm not _THAT_ bad
21:08:13 <glguy> Teltariat: Haskell makes you learn to look at and approach problems differently
21:08:14 <Teltariat> I'm just no super-genius when it comes to math.
21:08:21 <mbishop> heh
21:08:22 <glguy> Teltariat: that's my "endorsement" of it :)
21:08:33 <notsmack> Teltariat: don't worry about it.  just start playing.
21:08:35 <Teltariat> glguy: I'm willing to do that if Haskell has the benefits I seek
21:08:40 <glguy> Teltariat: and that's why I think that it's worth learning
21:08:50 <allbery_b> Teltariat: I'm lousy at math.  I'm doing okay with Haskell
21:09:05 <glguy> Teltariat: if you aren't interested in expanding your mind in a programming sense, then move on to another of the languages that all look alike ;)
21:09:06 <sieni> Teltariat: Unless you want to be as good as Terry Tao, I think that the most important thing in learning math is to be truly interested in learning it.
21:09:30 <syntaxfree> Terry Too?
21:09:33 <glguy> ?
21:09:38 <emu> > fix ("Bork":)
21:09:39 <lambdabot>  ["Bork","Bork","Bork","Bork","Bork","Bork","Bork","Bork","Bork","Bork","Bork...
21:09:45 <Excedrin> Teltariat: I also did poorly with math, but I've become interested in math due to trying to learn Haskell
21:09:55 <syntaxfree> > fix (:1)
21:09:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
21:09:56 <lambdabot>       Expected...
21:10:01 <syntaxfree> ;)
21:10:01 <sieni> syntaxfree: http://en.wikipedia.org/wiki/Terence_Tao
21:10:04 <bd_> > fix $ fix const
21:10:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
21:10:05 <lambdabot>       Expec...
21:10:10 <bd_> tsk
21:10:32 <Teltariat> I have glimpsed a wee bit of the world of functional, and I know enough to see that it is the way I must go.  I'm willing to learn more, I'm not satisfied to remain as merely a "blub" programmer (though I'm not even a particularly _decent_ Blub programmer)
21:10:38 <syntaxfree> jesus fuck. Now I'm depressed.
21:10:50 <syntaxfree> I'm 24 and I have no Fields medal, or perspectives for getting one until my birthday.
21:11:03 <glguy> s/until/before
21:11:07 <glguy> :-p
21:11:09 <Korollary> Teltariat: just curious. What makes you so certain that it is the way?
21:11:24 <Teltariat> Korollary: You can do more with less.
21:11:35 <Teltariat> You can express more in less lines of code
21:11:36 <glguy> less lines?
21:11:40 <glguy> ah
21:11:41 <sieni> syntaxfree: yeah, the arithmetic progressions result was amazing
21:11:46 <Teltariat> It allows you to be more terse
21:11:54 <glguy> Teltariat: have you seen J
21:12:00 <Teltariat> J?
21:12:04 <Teltariat> Can't say I have
21:12:06 <glguy> www.jsoftware.com
21:12:13 <glguy> j programming language   on wikipedia
21:12:16 <syntaxfree> sieni: I'm taking a graduate-leve course in number theory these days.
21:12:41 <syntaxfree> s/leve/level.
21:12:54 <sieni> syntaxfree: what kind of stuff? algebraic number theory or what?
21:13:14 <syntaxfree> well, it's being pretty algebraic until now.
21:13:33 <syntaxfree> apparently analytic number theory will be the second part of the course.
21:13:41 <syntaxfree> noot sure if they'll cover probabilistic stuff though.
21:13:42 <sieni> ahh ok
21:13:54 <glguy> Teltariat: j code:
21:13:54 <glguy>    (+/%#) 1 3 7 10
21:13:55 <glguy> 5.25
21:14:03 <syntaxfree> some analytic proofs have been coming up, though.
21:14:10 <glguy> where (+/%#) find the average of a list
21:14:23 <glguy> if you want to get into "terse" code ;)
21:14:28 <moconnor> How do I find Data.ByteString.Char8 for GHC?  If that makes sense.
21:14:32 <Teltariat> glguy: ok, now thats too far off the path I had in mind to follow.... :)
21:14:38 <nmessenger> let mean = ... -- ;)
21:14:47 <bd_> moconnor: It's included in base for GHC 6.6
21:14:49 <nmessenger> mean [1,3,7,10]
21:15:02 <bd_> moconnor: if you mean 6.4, it's Data.PackedString in a seperate library I believe
21:15:05 <glguy> > let mean = liftM2 (/) sum genericLength in mean [1,3,7,10]
21:15:05 <bd_> ?where fps
21:15:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:15:06 <lambdabot>  5.25
21:15:08 <Teltariat> What about that programming language where you express everything with two letters?  Unlambda, was it?
21:15:14 <Teltariat> I can't recall
21:15:19 <bos31337> bd_: no, Data.PackedString is different
21:15:22 <moconnor> bd_: Yeah, I'm using 6.4
21:15:23 <LoganCapaldo> S and K combinators :)
21:15:26 <syntaxfree> we're in continuing fractions right now.
21:15:26 <Teltariat> yeah
21:15:27 <Teltariat> those
21:15:28 <bos31337> for ghc 6.4.2, it's called fps
21:15:37 <bos31337> ?where fps
21:15:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:15:50 <syntaxfree> Teltariat: Haskell isn't that much snobbish.
21:16:04 <glguy> Teltariat: that is decidedly *not terse* :)
21:16:07 <LoganCapaldo> K = const -- in Haskell
21:16:11 <bos31337> i have a coding idiom question.
21:16:22 <nmessenger> glguy, is just has longer names :P
21:16:23 <syntaxfree> Haskell is actually very pragmatic. It remains pure for good practical reasons, not for the sake of being esoteric.
21:16:30 <bos31337> declaring a record, should i use a prefix of the record name for the accessor functions?
21:16:38 <syntaxfree> :t const
21:16:39 <glguy> nmessenger: J does have better point free support
21:16:39 <lambdabot> forall a b. a -> b -> a
21:16:45 <bos31337> i.e. data Foo = Foo { fooFaf :: Int}
21:17:00 <bos31337> or is it better to just data Foo = Foo { faf :: Int }
21:17:03 <Teltariat> YAHT says that Hugs has a built-in graphics library.  Does that mean wxWindows?
21:17:23 <syntaxfree> I think that means GLUT.
21:17:35 <syntaxfree> graphics != window-managing.
21:17:38 * Teltariat smacks forehead
21:17:39 <Teltariat> sorry
21:17:43 <Teltariat> see what I was saying?
21:17:47 <augustss> bos31337: it depends, either works as long as you don't have clashes with the same module
21:17:59 <glguy> Teltariat: yup, that was strike 3... sorry , cya
21:18:03 <Teltariat> :-(
21:18:14 <bos31337> augustss: so one would handle clashes using import qualified, and just go with whatever looks tidiest? thanks.
21:18:23 <syntaxfree> anyway, GHC has good OpenGL support basically by default.
21:18:32 <augustss> bos31337: yes, qualified names work
21:18:33 <bos31337> clashes in client modules, that is.)
21:18:35 <nmessenger> Teltariat, small terminology mix-ups are nothing.  Worry not!
21:18:38 <syntaxfree> www.projecteuler.net
21:18:46 <syntaxfree> there's'a list of toy projects to try in Haskell.
21:19:03 * glguy wishes that projecteuler would stop releasing new problems, he used to have 100%
21:20:39 <ClaudiusMaximus> @check (\a b c -> (a + b) * c == a * c + b * c) :: Int -> Int -> Int -> Bool
21:20:40 <lambdabot>  OK, passed 500 tests.
21:20:45 <jcreigh> projecteuler always makes me feel stupid. I implement the brute-force algorithm, and then see in the thread how somebody did it purely with math.
21:20:58 <ClaudiusMaximus> @check (\a b c -> (a + b) * c == a * c + b * c) :: Double -> Double -> Double -> Bool
21:21:00 <lambdabot>  Falsifiable, after 0 tests: -0.3333333333333333, -2.0, -2.5
21:21:12 <bd_> @check (\a b c -> (a + b) * c == a * c + b * c) :: Int8 -> Int8 -> Int8 -> Bool
21:21:13 <lambdabot>   add an instance declaration for (Arbitrary Int8)     In the definition of `...
21:21:16 <bd_> aw
21:21:48 <LoganCapaldo> jcreigh, I agree, except my brute forces usually end up being wrong so I don't get to see the thread :)
21:23:10 <jcreigh> LoganCapaldo: heh, well, my ranking is currently #1075. where are you?
21:25:45 <glguy> I'm at 66 now
21:26:06 <LoganCapaldo> fix (1 +)
21:26:10 <LoganCapaldo> :)
21:28:08 <jcreigh> glguy: that's impressive
21:29:14 <glguy> thanks
21:30:09 <bd_> @hoogle mapAccum
21:30:09 <lambdabot> Data.IntMap.mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
21:30:09 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
21:30:09 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
21:30:12 <glguy> freetime does wonders for your projecteuler rank
21:31:30 <Teltariat> I aksed earlier about an embedded web server and database (not necessarily relational) for Haskell, and bc_ mentioned HAppS.  Are there any other suggestions?
21:32:01 <glguy> Teltariat: if you want to see example HAppS code,
21:32:04 <glguy> ?where hpaste
21:32:05 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
21:32:08 <glguy> !paste
21:32:09 <hpaste> Haskell paste bin: http://fserv.pikapphi.umr.edu:8000/
21:32:36 <Excedrin> there's HWS, but it's a web server with no database features
21:32:53 <glguy> There's a CGI library I thought...
21:32:56 <glguy> someoen else might know more
21:33:46 <Excedrin> I guess WASH sort of competes with HAppS
21:33:57 <Teltariat> Excedrin: thats OK, I don't necessarily mean a web server and database TOGETHER
21:34:15 <Teltariat> I'm just looking for functonality options for either
21:35:41 <Teltariat> btw, Seaside is a web framework written in Smalltalk.  Does Haskell have any as well?  And if so, do they play nicely with HAppS?
21:37:24 <bos31337> is there a runtime way to modify ghci's search path?
21:37:41 <bos31337> does :set -Ipath do it?
21:37:47 <bos31337> i've tried, but it seems not to.
21:37:57 <emu> -i
21:38:13 <Excedrin> haskelldb has a backend for flat files, but I don't think it's usable for "production" code
21:38:18 <bos31337> emu: thanks!
21:38:35 <glguy> Excedrin: because it uses flatfiles?
21:39:51 <Excedrin> glguy: the comments say "very experimental" and "concurrent writes leads to data loss"
21:40:17 <glguy> sounds serious!
21:40:49 <piggybox> Excedrin: which database library is better for production? I see too many such libs for haskell and get confused...
21:41:37 <Excedrin> haskelldb is fine, just use a real backend (postgres, oracle, mysql, whatever)
21:41:50 <Teltariat> :/
21:41:58 <Teltariat> My aim is to avoid dependencies
21:42:10 <Teltariat> external ones, anyway :)
21:42:36 <Excedrin> well, there's a few sqlite backends
21:49:29 <glguy> what was that Java program that look like mathcad
21:49:43 <glguy> and you could make worksheets that displayed diagrams and whatnot
21:50:02 * nmessenger checks reddit
21:50:12 <glguy> started with an E
21:50:16 * glguy is looking on reddit too
21:50:23 <Teltariat> nmessenger checked reddit! Oh no! He won't be back for a couple of hours! X-D
21:51:13 <nmessenger> glguy, you mean Vital?
21:51:21 <glguy> yeah, i htink so
21:51:25 <glguy> that sounds familair
21:51:27 <glguy> familiar
21:51:41 <glguy> thanks
21:52:21 <nmessenger> http://www.cs.kent.ac.uk/projects/vital/index.html
21:52:22 <lambdabot> Title: Vital homepage
21:52:29 <glguy> yup, I'm running it now
21:52:29 <ctkrohn> Teltariat: If you're interested in writing web programs in Haskell. there is the Network.CGI module which works pretty well with lighttpd
21:52:32 <glguy> it's a webstart app
21:52:55 <nmessenger> glguy, I played with it a few days ago.  The DNA example tickled my fancy.
21:52:56 <ctkrohn> Teltariat: There are a couple DB libraries of varying levels of functionality... we're using Takusen for our web project
21:53:34 <Teltariat> Thank you, ctkrohn.
21:54:31 <Teltariat> oh, one other question
21:54:44 <Teltariat> Python has "pickle/cpickle".  Haskell has something similar?
21:54:53 <nmessenger> Teltariat, after a quick search: http://haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
21:54:55 <lambdabot> Title: Libraries and tools/Database interfaces - HaskellWiki, http://tinyurl.com/3xb8dd
21:56:45 <Teltariat> ctkrohn, nmessenger, those are DB _interfaces_.  Know of any 100% Haskell embeddable DB libraries?  (Sorry to be so annoying)
21:58:05 <ctkrohn> Teltariat: I'm not sure exactly what you mean by an embeddable DB library... sort of a whole database written in haskell that can be used directly within an application?
21:59:46 <Teltariat> yea, so that the application directly writes and reads from a database file on disk, making it all self-contained
22:00:24 <ctkrohn> I see.  Unfortunately I'm not aware of any libraries like that.
22:01:25 <Excedrin> you can use MACID without HAppS afaik
22:02:41 <piggybox> teltariat: why not use sqlite?
22:02:50 <Excedrin> I guess "without the web related HAppS features" would be more accurate
22:04:01 <Teltariat> piggybox: I'd love to, but last I recall, I remember seeing that it was flakey on Windows.
22:04:49 <Teltariat> Also, I want to have a singe binary ball with no external deps
22:05:05 <Teltariat> though someone mentioned that I can compile SQLite into the binary
22:09:41 <piggybox> now sqlite is included in the lastest python by default. I guess that means sqlite is stable enough on Windows.
22:13:08 <Teltariat> yea, I guess, I'll do it that way.  For those of you who've beared with me, thank you for your help and patience
22:37:12 <syntaxfree> you could always just run wordpress & some plugins :P
22:44:50 <Anon4888> I don't really buy the explanation that "functional languages instruct the compiler on what to compute and imperative langauges instruct the compiler as to how"
22:45:01 <Anon4888> Both instruct what and how
22:50:20 <hpaste>  glguy pasted: graham scan at http://fserv.pikapphi.umr.edu:8000/6
22:51:40 <Saizan> Anon4888: i think that's kind of an iperbole but true too, for example ghc often transforms recursion in iteration or does deforestation, even an imperative compiler makes optimizations, but they are more conservative generally
22:52:00 <Excedrin> Anon4888: so would you say it's like 90%/10% split for functional languages and 10%/90% for imperative languages or do you disagree with it entirely?
22:54:29 <Anon4888> Hmm
22:55:09 <Anon4888> On the basis of just judging 'functional vs. imperative' I think I disagree entirely
22:56:14 <Anon4888> but functional langauges in particular examples probably do better than imperative on average
22:56:17 <bos31337> glguy: cute graham scan :-)
22:56:41 <glguy> thnx
22:57:06 <glguy> doesnt look much like the one in my book though :)
22:57:43 <bos31337> i bet the one in your book is written in C :-)
22:57:51 <glguy> pseudo
22:58:00 <glguy> imperative
22:58:05 <bos31337> turning imperative code into functional is a real brainfuck.
22:58:26 <Excedrin> isn't describing "the how" part of what it means for a language to be imperative?
22:58:40 <bos31337> especially if the imperative code is written in C, and doubly so if it's a piece of computational geometry.
23:00:18 <bos31337> i spent a bit of time looking at the standard algorithm for trangulating a polygon, and decided it was too much work to try to build a pure version at the time.
23:03:24 <hpaste>  glguy pasted: gift wrap algorithm at http://fserv.pikapphi.umr.edu:8000/6#1
23:11:42 <Excedrin> @quote imperative
23:11:42 <lambdabot> lennart says:  I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
23:11:43 <lambdabot> useful for functional code
23:12:00 <glguy> bos31337: still there>
23:12:05 <glguy> ?
23:12:31 <bos31337> glguy: yep
23:12:41 <glguy> were you refering to the ear clipping algorithm?
23:12:53 <bos31337> no, seidel's algorithm.
23:13:06 <bos31337> ear clipping is boring; O(n^2) complexity.
23:13:30 <Saizan> ?where hscolour
23:13:30 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
23:13:51 <bos31337> seidel relies on two dynamically updated structures which look awfully like they want to be imperative.
23:14:05 <glguy> bos31337: do you know a good psuedocode version?
23:14:18 <glguy> bos31337: I haven't gotten that far in my computational geometry class
23:14:30 <bos31337> no, but the exposition in seidel's paper is very clear.
23:14:32 * glguy checks textbook
23:15:55 <glguy> nope
23:16:05 <bos31337> the C implementations of the algorithm that i've seen are in very poor style; global static arrays all over the shop.
23:16:15 <bos31337> so they're rather hard to read.
23:18:33 <glguy> http://www.cs.unc.edu/~dm/CODE/GEM/chapter.html
23:18:34 <lambdabot> Title: Polygon Triangulation
23:18:39 <glguy> the 3 steps that this describes?
23:18:47 <bos31337> that's the one. read the code and weep :-)
23:19:03 <glguy> 404 on the code :)
23:19:10 <bos31337> glguy: but read seidel's paper; it's much more obvious what to do if you do.
23:19:30 <glguy> looking for it
23:20:14 <glguy> http://citeseer.ist.psu.edu/cache/papers/cs/7205/http:zSzzSzwww-tcs.cs.uni-sb.dezSzpaperszSztrap.pdf/seidel91simple.pdf
23:20:16 <lambdabot> http://tinyurl.com/yr48v9
23:20:29 <bos31337> glguy: bingo
23:22:20 <glguy> that's quite an algorithm!
23:23:20 * glguy save the paper to his desktop
23:23:29 <glguy> i won't be reading this and understanding it tonight
23:23:33 <bos31337> it's very clever. see what i mean about the need for imperative updates? you're basically modifying and rebuilding the query structure and tree as you traverse them.
23:29:57 <richcollins> Does this look right?
23:29:58 <richcollins> inject :: ((c, b) -> c) -> [b] -> c
23:31:45 <Welcome__> ?type foldl
23:31:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:32:35 <ClaudiusMaximus> ?hoogle ((c, b) -> c) -> [b] -> c
23:32:36 <lambdabot> No matches, try a more general search
23:33:03 <richcollins> (new - just starting to read http://www.haskell.org/tutorial/functions.html)
23:33:04 <lambdabot> Title: A Gentle Introduction to Haskell: Functions
23:33:12 <ClaudiusMaximus> i would guess that your inject is infeasible, as there is no "c" input and a "c" output
23:33:58 <richcollins> isn't there a c input in the first tuple?
23:34:22 <richcollins> perhaps I don't understand the syntax
23:35:06 <ClaudiusMaximus> a -> b -> c   is   a -> (b -> c)   isn't   (a -> b) -> c
23:35:48 <richcollins> I read it as: a function that returns b given c and b is applied to a list of b and returns c
23:36:02 <richcollins> hrm
23:36:10 <richcollins> yeah that doesn't sound quite right
23:36:52 <richcollins> coming from ruby
23:36:55 <richcollins> thinking in ruby terms
23:37:27 <seancorfield> a function that returns c given (a function that return c given c and b) and a list of b
23:37:52 <richcollins> that sounds right
23:39:34 <Excedrin> aha, I finally found the quote I was looking for: <monochrom> If I have an imperative program with just one variable x:int, I can probably turn it into a functional program by translating each assignment statement into a function int->int.
23:40:26 <seancorfield> or you could look at it as: a function that returns (a function that returns c given a list of b) given (a function that returns c given c and b)
23:40:42 <richcollins> seancorfield, (((b, c) -> c), [b]) -> c
23:40:44 <richcollins> ?
23:41:39 <seancorfield> well, a -> b -> c means a function that takes a and (effectively) returns a function that takes b and returns c
23:41:52 <ClaudiusMaximus> http://en.wikipedia.org/wiki/Currying
23:41:58 <seancorfield> or you can treat it as a function that takes an a and a b and returns c :)
23:42:49 <richcollins> ah ok
23:42:58 <seancorfield> it's why you can say: inc a = 1 + a or inc = (+1)
23:43:56 <seancorfield> incList = map inc ... or incList l = map inc l
