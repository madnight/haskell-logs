00:04:25 <Korollary> zeeeeee: That's a bit difficult. If you're creating a lot of different datatypes that all need to be hashed, perhaps Data.Generics may help.
00:12:31 <xic> what kind of exception is "openFile: inappropriate type (is a directory)" ?
00:14:00 <nacho> perhaps you tried to open a directory?
00:14:30 <xic> yeah, but how can i catch that exception?
00:14:49 <nacho> no idea :) I"m still a noob. maybe with catch?
00:14:55 <xic> docs say that openFile can fail only with: isAlreadyInUseError, isDoesNotExistError, or isPermissionError
00:15:00 <nacho> ?catch
00:20:41 <monochrom> if you use "catch" from Prelude you will catch all IO exceptions.
00:21:37 <monochrom> In your exception handler you may or may not be able to determine the variant of the exception.
00:22:36 <monochrom> The doc is incomplete too, as you have just found out.
00:23:30 <monochrom> But still, your exception handler can still do reasonable things about unknown exceptions.
00:28:00 <therp> good morning
00:29:23 <therp> hey adamant! Liskell is doing fine :) .. wanna see some nice source? http://clemens.endorphin.org/Prolog.lsk ... search for the word "Inject"
00:30:25 <xic> monochrom: well i'm interested in only catch that particular exception
00:30:37 <xic> monochrom: i can't find anything appropriate in System.IO.Error either
00:31:19 <monochrom> Right, there are many variants of IOError not distinguishable using the current library.
00:32:33 <xic> hm....
00:33:07 <humasect> do any public darcs (sourceforge / gna style) project hosting sites exist ?
00:34:03 <monochrom> probably not
00:35:11 <humasect> okay =)
00:35:28 <nacho> humasect: you can get darcs working on dreamhost
00:35:56 <humasect> ah nice idea, thanks
00:35:56 <xic> monochrom: so are there plans to add more IO error clasifications?
00:36:21 <monochrom> Not that I know of.
00:41:38 <xic> monochrom: this doesn't sound good
00:42:34 <ibid> has somebody been telling people about planet haskell lately? i usually get about one or two addition requests per month, now i got 6 in two days
00:43:19 <ski> therp : cool !
00:44:00 <toad3k> ghci lists a lot of ioerrors, :b IOErrorType
00:44:49 <therp> ski: actually, implementing the typed version would be cooler :) -- typed embedded prolog -- but my objection was to show automatic embedding
00:45:00 <therp> s/objection/aim/
00:45:34 <therp> or s/objection/objective/ .. I haven't had my black tea this morning.
00:45:54 <ski> is this the Seres and Spivey version, basically ?
00:48:13 <therp> ski: basically yes. although the classen, ljungl√∂f paper was my implemention guideline, they describe the embedding process better than seres/spivey
00:48:38 <ski> ok
00:48:39 <nacho> anyone play with intelij idea?
00:51:07 <therp> why does GHC joke on unary tupples?
00:51:32 <therp> unary=one element. not ().
00:52:07 <therp> s/joke/choke/. I should really get my tea.
00:53:31 <nacho> look at the type of (1)
00:53:32 <nacho> that's my guess.
00:53:37 <nacho> i forget how to do it with lambdabot
00:53:39 <nacho> :t (1)
00:53:45 <nacho> >:t (1)
00:53:50 <nacho> > 1
00:54:00 <nacho> ? 1
00:54:07 <nacho> i concede.
00:54:55 <ski> 1 :: Num a => a
00:55:12 <_Stinger_> @t (1)
00:55:16 <_Stinger_> @type (1)
00:55:21 <nacho> (1) :: (Num t) => t
00:55:23 <_Stinger_> I cant remember either :P
00:55:29 <ski> lambdabot seems to be sleeping
00:55:45 <_Stinger_> ?bot
00:55:52 <ski> @vixen wake up!
00:57:22 <nacho> did i kill it?
00:59:19 <ski> lambdabot was last seen active 2 hours and 40 minutes ago and .
01:00:16 <_Stinger_> anyway I think the gentle intro to haskell mentions something about unary tuples not existing
01:00:23 <_Stinger_> cause they are simply values
01:00:59 <_Stinger_> I could be mistaken though, someone more knowledgable care to confirm/deny?
01:01:35 <vegaiW> > (1) == 1
01:01:49 <ski> <therp> unary=one element. not ().
01:01:49 <vegaiW> True!
01:01:56 <monochrom> Heheh
01:02:28 <monochrom> Haskell does not have unary tuple.
01:02:34 <therp> but Liskell has :)
01:02:38 <_Stinger_> I win!
01:03:15 <therp> but haskell core lint does not like unary tuples. It just refuses them. I wonder why..
01:06:17 <Masklinn> good morning #haskell
01:10:47 <ski> hm .. could one have something like 'TNil# :: (#)','TCons# :: * -> (#) -> (#)','Tuple :: (#) -> *'
01:16:35 <wolfgangbeck> in a HAppS example, I saw an expression like $(inferRecordUpdaters ''MyState)
01:16:45 <wolfgangbeck> what is this?
01:17:43 <Cale> huh, could be a template haskell splice
01:17:43 <xic> @type ($)
01:18:08 <Cale> where's the example?
01:18:17 <nornagon> :t ($)
01:18:17 <wolfgangbeck> Ah, i'll google for template haskell, thanks
01:18:19 <nornagon> @bot
01:18:26 <nornagon> lambdabot: :(
01:18:59 <Cale> there was a netsplit and it died
01:19:14 <wolfgangbeck> It's in the HAppS distribution, session_ex.hs
01:19:18 <nornagon> i thought dons said he fixed that?
01:19:28 <Cale> I don't know then :)
01:20:37 <Cale> yeah, that's definitely template Haskell
01:21:44 <wolfgangbeck> now i know where to look
01:23:22 <Cale> It's probably not worth learning TH in order to understand what that does unless you have a bunch of free time. The HAppS documentation would be better I think. Basically all that's doing is splicing in some computed declarations.
01:24:29 <wolfgangbeck> It looks a bit like Camlp4
01:25:09 <Cale> It is a bit like that
01:25:16 <wolfgangbeck> HAppS documentation is a sad story
01:26:18 <wolfgangbeck> HAppS has many features, but without proper doc it's quite frustrating
01:27:11 <Cale> Sometimes Alex Jacobson is around here, I'm not sure what time of day.
01:28:13 <Cale> hmm, it's not made clear at all what the difference is between inferStartState and inferStartStateAny
01:30:07 <dcoutts> kaalikas, you can use cairo for vector and bitmap graphics
01:31:38 <Stinger_> gtk2hs for 6.6 yet?
01:32:14 <dcoutts> Stinger_, a pre-release is available: http://haskell.org/gtk2hs/gtk2hs-0.9.10.4.tar.gz
01:33:06 <pierre1> Cale: he usually can be found at #happs chanel
01:35:06 <wolfgangbeck> good to know that there is a #happs channel
01:36:10 <xic>  join it, it needs to grow :)
01:36:52 <Cale> I wonder if Alex has played Deus Ex. :)
01:36:53 <Andris> @type alloca
01:36:54 <mbot> Not in scope: `alloca'
01:37:06 <Cale> @index alloca
01:37:06 <mbot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
01:37:14 <Cale> @type Foreign.alloca
01:37:16 <mbot> forall b a. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
01:37:40 <Andris> thanks :)
01:37:54 <Andris> cannot be alloca made more safe?
01:38:11 <Cale> how?
01:38:14 <Andris> I mean, currently it is possible to tuck Ptr a into b, no?
01:38:29 <Cale> yes
01:38:32 <Andris> and use it out of the function
01:38:37 <Andris> after it was released
01:39:13 <Andris> could we declare that b must be independent of a?
01:39:16 <Cale> Yeah, you could probably use higher-rank types to make it safer, but Haskell 98 doesn't have those.
01:39:20 <Andris> ah
01:39:21 <Andris> ok
01:39:45 <Cale> The trick to use would be essentially the one that the ST monad uses.
01:39:47 <boegel> @seen Itkovian
01:39:48 <mbot> Last time I saw Itkovian was when I left #haskell 22h 52m 26s ago, and .
01:40:00 <Andris> btw, any plans for post-98 Haskell standard?
01:40:01 <boegel> lambdabot is dead?
01:40:22 <Andris> does m stand for monad? :)
01:40:22 <nornagon> netsplit'd :(
01:40:24 <Cale> Andris: it's being worked on, basically standardising a bunch of stuff that's in GHC and Hugs
01:40:38 <Cale> (but not all of it)
01:40:44 <sieni> Andris: http://hackage.haskell.org/trac/haskell-prime
01:40:45 <mbot> Title: Haskell Prime - Trac
01:40:51 <Andris> thanks
01:41:08 <Cale> Language development in Haskell is pretty much always ahead of the standard.
01:41:25 <Cale> In fact, I'd say H98 probably set things back a bit.
01:42:26 <Cale> Though I wasn't actually around at that time, I've just read the mailing lists from around then, and the earlier reference documents.
01:43:08 <Andris> There was a lot of complaints, I believe?
01:43:17 <augustss> I think it's very important to have a syable standard.  But H98 is clearly getting old now.
01:43:21 <Andris> "Why is my favorite feature not in the book"
01:43:44 <augustss> s/syable/stable/
01:43:44 <Cale> My complaints with H98 are more the things it says about the Prelude.
01:43:55 <Andris> Like what?
01:44:01 <Cale> The rest of the language has changed significantly
01:44:23 <Cale> Like fail being in the Monad class, MonadZero and MonadPlus being merged.
01:44:34 <Cale> Monad not being a subclass of Functor
01:44:55 <Cale> The types of many prelude functions can also be made more general.
01:45:17 <Andris> cannot the Prelude be ignored?
01:45:21 <Cale> I don't particularly care for the excessive use of Int
01:45:38 <Cale> Sort of, except that it's tied in with the rest of the libraries.
01:45:42 <Andris> well, the numerics in Haskell have bitten me a couple of times
01:46:02 <Andris> Even taking in account I wrote less than 1 KLOC in Haskell :)
01:46:10 <Cale> The numerics seem crazy when you first look at them, but they're actually pretty sane.
01:46:50 <Cale> They're a decent compromise between mathematical abstractness and the ways in which actual numeric types are represented in computers.
01:47:57 <Cale> That said, it would be nice to have something like the class aliases feature, so that we could split it up some more. Sometimes it would be nice to define + without *
01:48:02 <Cale> (or vice versa)
01:48:16 <Syzygy-> Hear, hear.
01:48:41 <Cale> There are also a few small oddnesses, but they're pretty minor compared with the problems with the monad class, in my opinion.
01:49:02 <Cale> Also, do-notation should have a different translation.
01:49:22 <Cale> I've said this lots of times, I wonder if anyone's getting tired of hearing it :)
01:49:36 <Andris> Cool, both multi-parameter type classes and higher-ranked types are in!
01:49:39 <xic> use the wiki
01:49:44 <ski> Cale : '(>>)' or pattern-matching ?
01:49:50 <Andris> what's wrong with do translation?
01:50:36 <Cale> I'd like do {p <- x} to expand differently depending on whether p is a refutable pattern or not
01:50:57 <Cale> If p is irrefutable (for instance, a simple variable)
01:51:03 <Cale> then the translation should be
01:51:22 <Cale> do {p <- x; <stmts>} ==> x >>= \p -> do {<stmts>}
01:51:33 <Cale> If p is refutable, then
01:52:11 <Cale> do {p <- x; <stmts>} ==> let ok p = do {<stmts>}; ok _ = mzero in x >>= ok
01:53:06 <Cale> And we'd split mzero off from the MonadPlus class to support this, reinstating MonadZero
01:53:29 <Cale> This way, potentially-failing pattern matches in do-blocks generate a MonadZero constraint.
01:53:56 <Cale> That means that the monad has to be capable of handling failure gracefully.
01:54:04 <Andris> Hmm, but how can mzero be analyzed without mplus?
01:54:13 <Andris> ah, in monad-specific way?
01:54:19 <ski> mzero >>= k  =  mzero
01:54:24 <Andris> a
01:54:27 <Cale> Like that :)
01:54:33 <Andris> ok
01:54:34 <ski> http://www.haskell.org/hawiki/MonadPlus
01:54:35 <mbot> Title: MonadPlus - The Haskell Wiki
01:56:05 <Andris> then why were they collapsed together?
01:56:30 <Cale> It was an oversight
01:56:40 <Cale> Monad comprehensions were being removed
01:57:01 <Cale> (which IMO was perhaps a bit of a mistake in and of itself)
01:57:28 <Cale> and MonadZero had originally been created to allow for monad comprehensions, so it was decided that it wouldn't be needed anymore
01:57:30 <Andris> What would be the motivation behind that?
01:57:40 <Cale> Making things easy for beginners
01:57:41 <Andris> I mean removing comprehensions
01:58:10 <Cale> Basically, beginners who make mistakes in list comprehensions don't like seeing stuff about monads in their error messages
01:58:14 <Vq^> Cale: so when everybody knows Haskell we can change it back?
01:58:31 <Cale> Hopefully sooner
01:58:48 <Andris> Then teach beginners not to use lists for everything :)
01:58:52 <Cale> I think this is more something that should be corrected through good teaching.
01:58:54 <Hirvinen> shapr: How come?
01:59:00 <Cale> Lists are indeed important
01:59:12 <Cale> They're as important as loops are in an imperative language.
01:59:16 <ski> one could imagine a '-fsimple-haskell' flag ..
01:59:22 <Cale> ski: indeed!
01:59:35 <Andris> like PLT Scheme?
01:59:44 <Cale> I think we need to define a couple of language strata.
01:59:45 <ski> or Helium
01:59:56 <Cale> yeah, how is Helium doing anyway?
01:59:57 <Vq^> ski: is the problem that the feature exists?
02:00:11 * ski has no idea
02:00:18 <ski> Vq^ : hm, what feature ?
02:00:21 <Vq^> isn't the problem that existing programs gets harder to comprehend?
02:00:31 <Cale> I think it would be really cool to be able to say things like (.) is the new fmap, and map = (.)
02:00:56 <Vq^> ski: any feature removed from haskell to make it simpler for beginners
02:01:08 <ski> (Cale : been listening to edwardk, eh ?)
02:01:31 <Cale> ski: hm?
02:02:04 <ski> (Cale : just that edwardk's been talking about using '(.)' for 'fmap' :)
02:02:17 <Cale> oh, I wonder who had the idea first
02:03:51 <ski> Vq^ : i think adding monad comprehensions probably would not change existing programs ..
02:05:28 <ski> Cale : hm, would '(>.>)' be 'comap', then ?
02:05:51 <Syzygy-> What would comap do?
02:06:02 <ski> class CoFunctor f
02:06:04 <ski>   where
02:06:05 <Syzygy-> And do we REALLY want Haskell to look like it's written by a bunch of Anime fans ircing? :P
02:06:08 <Cale> Apply a contravariant functor to a function
02:06:11 <ski>   comap :: (b -> a) -> (f a -> f b)
02:06:15 <Syzygy-> Cale: Ahhhhhhh. NEAT.
02:06:22 <Syzygy-> I want that! ;)
02:06:44 <Syzygy-> Hmm... instance CoFunctor (e(->)) should be writable then...
02:06:44 <ski> Syzygy- : heeheeh
02:06:59 <ski> no type lambdas
02:07:00 <Syzygy-> No wait. Is that (->)e?
02:07:12 <ski> (-> e)
02:07:40 <Vq^> ski: right, but beginners can get around writing programs without knowing of list-comprehensions, so why remove monad-comprehensions?
02:07:47 <xpika> if i have a list of type [Int] how do i obtain the sum of that list if the sum is larger than an int
02:07:47 <Syzygy-> ski: One of them already exists - implementing Monad. The other possibility is the common vector space dual (or generic dual), which is contravariant...
02:08:01 <Syzygy-> ?hoogle Int -> Integer
02:08:02 <mbot> Plugin `search' failed with: IRCRaised Lib.URL.isTextHTML: getHeader failed
02:08:09 <Syzygy-> o.O
02:08:16 <Syzygy-> @hoogle Int -> Integer
02:08:17 <mbot> Plugin `search' failed with: IRCRaised Lib.URL.isTextHTML: getHeader failed
02:08:20 <Syzygy-> O.o
02:08:22 <Syzygy-> Where is lambda?
02:08:28 <Syzygy-> And why doesn't mbot hoogle?
02:08:36 <xpika> >  sum ([1..100000] :: [Int])
02:08:37 <mbot>  705082704
02:08:43 <xpika> makes no sense
02:09:01 <Syzygy-> > sum (map toInteger [1..100000::Int])
02:09:02 <mbot>  5000050000
02:09:16 <Syzygy-> Int is the word-size integer. Integer is the bigint.
02:09:30 <xpika> >  toInteger $ sum ([1..100000] :: [Int])
02:09:31 <mbot>  705082704
02:09:32 <ski> > sum (map fromIntegral ([1..100000] :: [Int]) :: [Integer])
02:09:33 <mbot>  5000050000
02:09:47 <Syzygy-> Oh, and ski may have a better solution than I had.
02:10:04 <Syzygy-> xpika: You want to convert first and sum afterwards. Not the other way around.
02:10:05 <xpika> no they look the same to me
02:10:19 <ski> Vq^ : well, *i*'m not arguing for keeping monad comprehensions away
02:10:28 <Syzygy-> xpika: Nah, I use toInteger, ski uses fromIntegral. fromIntegral is slightly mor generic.
02:10:59 <Vq^> ski: i know :)
02:11:47 <Vq^> ski: i was just curious as to why we didn't just walk around the problem by not teaching it
02:12:38 <ski> Syzygy- : but '(r ->)' is '\a -> (r -> a)' or simply '(->) r' .. but '(-> o)' is '\a -> (a -> o)' .. but we don't have type-level lambdas :/
02:13:22 <ski> Vq^ : i guess one reason could be that beginners can use ':t', too .. also consider type errors when something goes wrong
02:15:38 <Vq^> hmm
02:17:17 <ski> so this perhaps is an argument in favor of language strata/levels in implementation(s) (/ language ??)
02:19:42 <zeeeeee> is there a hashtable written in ST?
02:33:24 <Masklinn> @seen dons
02:33:24 <mbot> dons is in #haskell. I don't know when dons last spoke.
02:33:38 <Masklinn> today's the last day of the hackathon right?
02:35:33 <Hunter_wow> what is hackthon? ppl go together and show up some programs?
02:39:03 <dons> Masklinn: yeah
02:39:17 <Masklinn> I'll be waiting for your report dons :D
02:49:54 <dons> ?bot
02:49:54 <mbot> :)
02:49:55 <lambdabot> :)
02:50:03 <dons> mbot: @part #haskell
02:50:05 <dons> ?users
02:50:05 <lambdabot> Maximum users seen in #haskell: 315, currently: 277 (87.9%), active: 1 (0.4%)
02:51:07 <psnl> dons: how is hac?
02:52:45 <dons> great!
02:52:48 <dons> seen the photos?
02:52:57 <dons> hopefully we can release the new binary IO lib today
02:57:29 <quazimodo> hullo
02:58:38 <quazimodo> i think i want to write a program that emulates my casio fx 115wa calculator
02:59:26 <quazimodo> not sure though
03:04:05 <xic> go for it
03:07:28 <xic> are IORefs thread safe?
03:08:00 <xpika> .msg lambdabot > 1
03:08:05 <waern> dons, where are those photos?
03:08:34 <dons> xic, no. (except 'atomicModifyIORef'
03:08:38 <dons> xic, use MVars
03:09:23 <xic> dons: ok it's just i'm reading through some code that appears to use as IORef as if they are thread safe
03:22:53 <quazimodo> i forgot, how do we get lambdabot to tell us the procedure of a function?
03:22:59 <quazimodo> or the algorithm...
03:28:09 <xic> @source null
03:28:09 <lambdabot> Not enough privileges
03:28:25 <Masklinn> @source map
03:28:26 <lambdabot> Not enough privileges
03:29:16 <Hunter_wow> dosent http://paste.lisp.org/new/haskell work ?
03:33:05 <dom> @type seq
03:33:07 <lambdabot> forall b a. a -> b -> b
03:33:24 <lisppaste2> Hunter_wow pasted "data Type" at http://paste.lisp.org/display/34971
03:33:44 <dons> ?src map
03:33:44 <lambdabot> map _ []     = []
03:33:45 <lambdabot> map f (x:xs) = f x : map f xs
03:34:12 <Hunter_wow> ?src replicateM
03:34:13 <lambdabot> replicateM n x = sequence (replicate n x)
03:34:55 <Lemmih> Hunter_wow: manad `elem` [...] ?
03:35:45 <paolino> hi, is there an Arrow function (a,f) -> f a ?
03:36:25 <Hunter_wow> Lemmih elem takes an matching value, I whant to put in the mounth(manda) and get out the correct/matching season
03:37:05 <paolino> @hoogle (a,a->b) -> b
03:37:06 <lambdabot> No matches, try a more general search
03:37:29 <paolino> @hoogle (a->b,a) -> b
03:37:30 <lambdabot> No matches, try a more general search
03:37:54 <Lemmih> Hunter_wow: Yes, exactly.
03:40:57 <Hunter_wow> Lemmih how would it look with the elem then? something like:    [Januari..Mars] `elem` Winter         would be no match I guess
03:44:41 <Lemmih> Hunter_wow: | manad `elem` [Januari .. Mars] = Spring | otherwise = Winter
03:47:21 <Hunter_wow> Lemmih yea, thanks, works now
03:51:24 <Hunter_wow> is it "elem" or ".." who force me to have "deriving Enum"?
03:51:40 <resiak> ..
03:52:13 <Hunter_wow> ok, thx
03:52:31 <resiak> @type enumFromTo -- this is the function that [ .. ] gets desugared to
03:52:33 <lambdabot> forall a. (Enum a) => a -> a -> [a]
04:01:38 <tphyahoo> :t (let x = 1:x in x)
04:01:40 <lambdabot> forall a. (Num a) => [a]
04:01:50 <tphyahoo> how does haskell infer the type for an infinite list?
04:02:39 <tphyahoo> :t head (let x = 1:x in x)
04:02:40 <lambdabot> forall a. (Num a) => a
04:02:52 <tphyahoo> :t head (1:2)
04:02:54 <lambdabot> forall a. (Num a, Num [a]) => a
04:03:58 <rahikkala> I don't know how it actually works, but since lists are homogenously typed I can't see how it would be a problem
04:04:13 <tphyahoo> I'm trying to figure out why head (infinite list works) but head (badly formed list -- eg no nil at end ) doesn't.
04:04:41 <tphyahoo> where (1:2) is a badly formed finite list
04:04:47 <paolino> tphyahoo: head (1:[2]) ??
04:05:04 <tphyahoo> > head (1:[2])
04:05:06 <lambdabot>  1
04:05:18 <lome> (:) :: a -> [a] -> [a]
04:05:21 <tphyahoo> that's a well formed list.
04:05:21 <boulez> :t head ('a':'b')
04:05:23 <lambdabot>     Couldn't match `[Char]' against `Char'
04:05:23 <lambdabot>       Expected type: [Char]
04:05:31 <lome> you cannot 1:2
04:05:45 <tphyahoo> yes, badly formed, no nil at end.
04:05:56 <tphyahoo> t: 1:2:[]
04:06:04 <tphyahoo> :t 1:2:[]
04:06:05 <lambdabot> forall a. (Num a) => [a]
04:06:13 <tphyahoo> :t 1:2
04:06:14 <lambdabot> forall a. (Num a, Num [a]) => [a]
04:06:16 <boulez> tphyahoo: the 'error' in :t (1:2) is that [a] probably won't be an instance of Num
04:07:11 <boulez> tphyahoo: now I think I misread your question
04:07:34 <lome> point is not that no nil at end (infinite list has not nil at end). List constructor (:) must have list with same type at second argument
04:07:42 <gds> tphyahoo: There's an ambiguity in what you want to do - if you're trying head (x:y) where x and y happen to be integers, it might mean you want to return x, or it might mean that you y isn't what you expected.
04:08:09 <jethr0> is "data [a] = [] | a : [a]" a valid haskell declaration or does this only work because it's a builtin?
04:08:22 <lome> valid
04:08:42 <tphyahoo> I asked about this before and got the same answer, but for some reason it's clearer 2nd time... so thanks.....
04:08:56 <lome> :-)
04:09:10 <vegaiW> lome: is it? ghc doesn't seem to like it, and I remember SOE mentioning that it isn't
04:09:41 <tphyahoo> I guess my fundamental error was thinking that lists need a nil at the end, and getting confused about that.
04:09:47 <tphyahoo> :t (:)
04:09:49 <lambdabot> forall a. a -> [a] -> [a]
04:10:21 <tphyahoo> :t (let x = 1:x in x)
04:10:23 <lambdabot> forall a. (Num a) => [a]
04:10:53 <tphyahoo> here, seems x is infered to be a of type [a] because it's in second argument.
04:10:55 <jethr0> why isn't there a let for data declarations? that would be so nice for lambdabot and ghci
04:11:42 <lome> vegaiW: AFAIK valid, but maybe i make mistake
04:12:42 <tphyahoo> I guess I got brainwashed by "the little schemer" ;)
04:13:54 <lome> vegaiW: it's a syntax sugar for data [] a = [] | a : [] a
04:16:58 <tphyahoo> jetrh0 I've thought the same myself. maybe there is a deep reason.
04:18:29 <Stinger_> hmm where have I seen jethr0 before
04:18:32 <jethr0> tphyahoo: well, in the AST they are two different things, but i don't see why you can't have local data types. ah, maybe because their instances could escape the let...
04:18:41 <jethr0> Stinger_: in #haskell
04:19:56 <tphyahoo> can you let be instances of ad hoc datatypes in ghci?
04:20:04 <tphyahoo> or lambdabot?
04:21:16 <jethr0> "let data X = A|B in A" would escape the data type from it's let binding...
04:21:53 <vincenz> jethr0: I don't see a problem with that
04:22:04 <vincenz> jethr0: make the type global, but not the data-cons
04:22:15 <vincenz> jethr0: just like a non-exported data-decl in a module
04:22:25 <jethr0> k
04:23:25 <vincenz> the only 'problem' will be with giving them a unique name, and then allowing the programmer to refer to this unique nae
04:26:26 <tphyahoo> > let x = 2
04:26:27 <lambdabot>  Parse error
04:26:43 <tphyahoo> any way I can get lambdabot to remember x?
04:27:08 <tphyahoo> > x=2
04:27:08 <lambdabot>  Parse error
04:27:11 <tphyahoo> > x = 2
04:27:12 <lambdabot>  Parse error
04:27:27 <Stinger_> @let x=2
04:27:28 <lambdabot> Defined.
04:27:28 <vegaiW> lome: ghc doesn't like that either :)
04:27:34 <Stinger_> > x
04:27:36 <lambdabot>  2
04:27:48 <tphyahoo> then we can all fight over x, eh :)
04:27:56 <tphyahoo> @let x = 3
04:27:57 <lambdabot> <local>:8:0:     Multiple declarations of `L.x'     Declared at: <local>:7:0 ...
04:28:04 <tphyahoo> you win :)
04:28:23 <Stinger_> heh cant remember how to get rid of it
04:28:27 <Stinger_> @forget
04:28:27 <lambdabot> Unknown command, try @list
04:28:58 <tphyahoo> @list
04:28:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:29:26 <tphyahoo> @undefine x
04:29:27 <lambdabot> Undefined.
04:29:34 <tphyahoo> @let x = 3
04:29:35 <lambdabot> Defined.
04:29:37 <tphyahoo> > x
04:29:38 <lambdabot>  3
04:29:42 <tphyahoo> I win.
04:30:20 <Stinger_> > x
04:30:21 <lambdabot>   Not in scope: `x'
04:30:38 <lome> vegaiW: yep. you're right.
04:30:41 <Stinger_> hmm chat commands work in a global instance
04:30:50 <tphyahoo> > x
04:30:50 <lambdabot>   Not in scope: `x'
04:30:55 <tphyahoo> huh?
04:31:01 <Stinger_> privmsgs
04:31:18 <sieni> G2222
04:31:20 <sieni> oosp
04:31:55 <tphyahoo>  @let x = 3
04:31:58 <jethr0> "@let" is very forgetful
04:32:05 <tphyahoo> > x
04:32:06 <lambdabot>   Not in scope: `x'
04:32:17 <sieni> @let x = "gubar"
04:32:18 <lambdabot> Defined.
04:32:20 <sieni> > x
04:32:22 <jethr0> i.e. it timeouts very quickly in order not to create a mess
04:32:22 <tphyahoo> @let x=3
04:32:22 <lambdabot>  "gubar"
04:32:23 <lambdabot> <local>:2:0:     Multiple declarations of `L.x'     Declared at: <local>:1:0 ...
04:32:25 <tphyahoo> > x
04:32:25 <sieni> > x
04:32:27 <lambdabot>  "gubar"
04:32:28 <lambdabot>  "gubar"
04:32:30 <sieni> > x
04:32:31 <lambdabot>  "gubar"
04:32:46 <sieni> > x
04:32:48 <lambdabot>  "gubar"
04:32:51 <jethr0> @let (+) = (-)
04:32:52 <lambdabot> Defined.
04:32:58 <jethr0> > 4 + 5
04:32:59 <tphyahoo> > x
04:32:59 <lambdabot> Terminated
04:32:59 <sieni> > 7 + 3
04:33:00 <lambdabot> Terminated
04:33:01 <lambdabot>  "gubar"
04:33:06 <jethr0> oh
04:33:12 <vincenz> tttw
04:33:14 <tphyahoo> > 7 + 3
04:33:14 <vincenz> oops
04:33:15 <vincenz> ttw
04:33:15 <lambdabot> Terminated
04:33:23 <sieni> @undef
04:33:25 <lambdabot> Undefined.
04:33:27 <Stinger_> see, what you can do, is msg lambdabot
04:33:28 <tphyahoo> > 7 + 3
04:33:30 <lambdabot>  10
04:33:42 <jethr0> Stinger_: ya, sry
04:34:08 <tphyahoo> > x
04:34:09 <lambdabot>   Not in scope: `x'
04:35:28 <tphyahoo> what would be really cool is if you could "declare" multiple lambdabot states, then you could have multiple collaborative lambdabot mucks from within irc.
04:35:58 <tphyahoo> and the need to avoid mess would be lessened.
04:36:15 <jethr0> or have the @let be user specific and less "forgetful"...
04:36:40 <tphyahoo> yeah, but then you couldn't "correct" me except by detailed telling me what to do.
04:37:06 <jethr0>  @asUser tphyahoo <code>
04:37:14 <Stinger_> @let should be channel specific
04:37:14 <lambdabot>  Parse error
04:37:18 <Stinger_> heh
04:37:35 <Stinger_> so if you are doing stuff in priv you get your own namespace
04:37:41 <vegaiW> > 1+2-3+4
04:37:41 <lambdabot> Terminated
04:37:48 <tphyahoo> I guess that would work, but then I could only have one "muck" session.
04:37:54 <vegaiW> > 1+2-3+4
04:37:56 <lambdabot>  4
04:38:18 <vegaiW> Sort of evil. Nice though that you cannot say @let (+) = doEvilThingsOnTheServer
04:38:54 <Stinger_> > return "oh nos the IO monad" :: IO String
04:38:56 <lambdabot>  <IO [Char]>
04:39:30 <vegaiW> hmmm... could you
04:39:50 <jethr0> vegaiW: lambdabot doesn't do side effects
04:39:58 <vegaiW> aww.
04:40:20 <tphyahoo> > putStrLn "blee"
04:40:21 <lambdabot>  <IO ()>
04:41:27 <paolino> @pl\ \s -> (map (map (lA rc ps !)) (placer dims (sort s)))
04:41:29 <lambdabot> map (map (lA rc ps !)) . placer dims . sort
04:42:58 <paolino> @unpl\ app . (snd &&& fst)
04:42:59 <lambdabot> (\ c -> app ((snd &&& fst) c))
04:49:09 <tphyahoo> :t 1A
04:49:11 <lambdabot> Not in scope: data constructor `A'
04:49:53 <tphyahoo> @pl \s -> sort s
04:49:54 <lambdabot> sort
04:50:03 <tphyahoo> @pl \s -> blibbedy s
04:50:03 <lambdabot> blibbedy
04:50:46 <tphyahoo> @pl ( \s -> sort s )
04:50:47 <lambdabot> sort
04:53:57 <tphyahoo> @unpl sort
04:53:58 <lambdabot> sort
04:54:55 <tphyahoo> @unpl app . (snd &&& fst)
04:54:56 <lambdabot> (\ c -> app ((snd &&& fst) c))
04:55:15 <tphyahoo> @unpl map sort
04:55:16 <lambdabot> map sort
04:55:28 <tphyahoo> @unpl map . sort
04:55:29 <lambdabot> (\ c -> map (sort c))
05:00:14 <xic> which fold is the best?
05:00:42 <paolino> what for ?
05:00:44 <paolino> :P
05:01:12 <tphyahoo> I think foldr can be used for infinite lists, foldl has some other advantage.
05:01:16 <xic> escaping a string for html so that < > & characters get converted to "&lt;" "&gt;" "&amp;"
05:01:31 <paolino> tphyahoo: the other way around
05:01:43 <sieni> xic: number 5 in that picture: http://origami.kvi.nl/models/pureland/purepup.gif
05:01:57 <xic> eh?
05:01:59 <augustss> paolino: huh, you can use foldr for infinite lists
05:02:06 <xic> i need support for infinite lists
05:02:15 <paolino> ah, I shut up
05:02:16 <tphyahoo> > take ( foldl (+) 0 [1..] )
05:02:18 <lambdabot>  Add a type signature
05:02:19 <augustss> > foldr (\ x y -> x) 0 [1..]
05:02:21 <lambdabot>  1
05:02:45 <tphyahoo> > foldl (+) 0 [1..5]
05:02:47 <lambdabot>  15
05:03:13 <tphyahoo> but I forget how you would fold an infinite list anyway
05:03:14 <xic> oh wait, i'm an idiot, i don't want fold
05:03:26 <augustss> xlc: which function is best depends on what you want to do and the strictness of the function
05:03:28 <xic> or do i?
05:04:08 <|Lupin|> Hi
05:04:18 <augustss> xic: what do you want to do?
05:04:18 <paolino> xic, I think foldl is ok
05:04:56 <paolino> augustss, escaping chars
05:04:57 <augustss> foldr is the most natural for lists, since it's the catamorphism for lists
05:05:26 <augustss> escaping chars?  sounds like a job for concatMap
05:06:24 <augustss> > concatMap (\ c -> if c == '%' then "%%" else [c]) "abc%def"
05:06:26 <lambdabot>  "abc%%def"
05:06:33 <tphyahoo> > take ( foldl (:) 0 [1..] )
05:06:35 <lambdabot>  Couldn't match `Int' against `[Int]'
05:06:41 <tphyahoo> > take ( foldl (:) 0 [1..] )
05:06:42 <lambdabot>  Couldn't match `Int' against `[Int]'
05:06:53 <tphyahoo> > take ( foldl (:) [] [1..] )
05:06:54 <lambdabot>  Couldn't match `Int' against `[Int]'
05:07:00 <Saizan> ?type take
05:07:02 <lambdabot> forall a. Int -> [a] -> [a]
05:07:06 <augustss> > take 5 (foldr (:) [] [1..])
05:07:08 <lambdabot>  [1,2,3,4,5]
05:07:36 <paolino> > take 5 (foldl (:) [] [1..])
05:07:37 <tphyahoo> see paolino! I said foldr was for infinite lists.
05:07:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
05:07:37 <lambdabot>       Expected...
05:07:45 <augustss> ake 5 (foldl (flip (:)) [] [1..])
05:07:54 <augustss> > take 5 (foldl (flip (:)) [] [1..])
05:07:59 <lambdabot> Terminated
05:08:07 <xic> i tried using foldl but it doesn't work on infinite strings!
05:08:22 <augustss> no, foldr is your friend for infinite lists
05:08:26 <tphyahoo> use foldr, i was right (though just reciting something I memorized)
05:08:56 <paolino> ah, I have to sudy something :/
05:09:00 <augustss> but do you need fold for escaping?
05:09:02 <paolino> about folding
05:09:35 <xerox> @go universality of fold
05:09:37 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
05:09:59 <augustss> A clue to why foldr is "better" is that you can define foldl from foldr, but not vice versa.
05:10:22 <tphyahoo> > take ( foldr (:) [] [1..] )
05:10:23 <lambdabot>  Couldn't match `[a]' against `Int'
05:10:43 <tphyahoo> > take 5( foldr (:) [] [1..] )
05:10:44 <Saizan> tphyahoo: "take" takes 2 arguments
05:10:45 <lambdabot>  [1,2,3,4,5]
05:11:00 <tphyahoo> the easy way to remember that foldr works on infinite lists...
05:11:29 <tphyahoo> the "kernel", eg the empty list nil, goes at the end, with foldr.
05:11:46 <tphyahoo> just as with a list, nil is the last thing to be consed on.
05:12:12 <tphyahoo> (even though with an infinite list you never make it to the last cons)
05:12:29 <tphyahoo> (it's only there to pass the type checker. or so I think.)
05:13:05 <paolino> I was convinced the opposite, thanks!
05:13:08 <tphyahoo> with foldl, the kernel goes at the beginning.
05:13:32 <tphyahoo> > foldl (-) 10 [5]
05:13:33 <lambdabot>  5
05:13:40 <tphyahoo> > foldr (-) 10 [5]
05:13:41 <lambdabot>  -5
05:13:57 * paolino goes searching his foldl in the code
05:13:59 <tphyahoo> > foldr (:) [] 5
05:14:00 <lambdabot>   add an instance declaration for (Num [a])
05:14:15 <tphyahoo> > foldr (:) [] [5]
05:14:16 <lambdabot>  [5]
05:14:18 <paolino> mmh, so foldM is a foldr ?
05:14:35 <tphyahoo> but foldr (:) [] ]
05:14:42 <Saizan> ?src foldM
05:14:43 <lambdabot> foldM _ a []     = return a
05:14:43 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
05:15:05 <tphyahoo> but foldr (:) [] [5] will fail, because the first arg to cons is a list, which is wrong.
05:15:20 <tphyahoo> I mean, foldl (:) [] [5] will fail
05:15:39 <tphyahoo> > foldl (:) [] [5]
05:15:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
05:15:41 <lambdabot>       Expected...
05:15:51 <Saizan> foldM is more like foldl but you can't go infinite in a monad as well
05:16:02 <tphyahoo> weird error message.
05:16:19 <Saizan> you have to flip (:)
05:16:33 <Saizan> foldl (flip (:)) [] [1..4]
05:16:37 <Saizan> > foldl (flip (:)) [] [1..4]
05:16:38 <lambdabot>  [4,3,2,1]
05:16:46 <paolino> @src foldr
05:16:47 <lambdabot> foldr k z xs = go xs
05:16:48 <lambdabot>     where go []     = z
05:16:48 <lambdabot>           go (y:ys) = y `k` go ys
05:19:28 <paolino> mmhh
05:20:29 <Saizan> > let foldr f z (x:xs) = f x (foldr f z xs); foldr f z [] = z in foldr (-) 0 [1..4] -- equivalently
05:20:31 <lambdabot>  -2
05:21:30 <paolino> > 4-3-2-1-0
05:21:32 <lambdabot>  -2
05:21:38 <slappybag> is there anyone around who's not too busy that could possibly help me understand 8 lines of code? could you pm me please :)
05:21:57 <vincenz> slappybag: easier: @paste it
05:22:07 <vincenz> @paste
05:22:07 <lambdabot> http://paste.lisp.org/new/haskell
05:22:21 <slappybag> ah ok thanks a lot
05:23:28 <lisppaste2> slappybag pasted ""N-grams"" at http://paste.lisp.org/display/34978
05:26:13 <vincenz> slappybag: perhaps annotate or mention what the problem is
05:26:23 <slappybag> ok will do
05:26:32 <augustss> slappybag: why don't you experiment whith the code?  Evaluate it in ghci.  Evaluate fragments of it.
05:26:54 <vincenz> augustss: meta-helping :)
05:27:50 <augustss> well, to quote Per Martin-L√∂v "In the end everyone has to understand for himself"
05:27:51 <slappybag> augustss: i have been experimenting for a while, but i'm fairly new with haskell and struggling to get to grips with the syntax
05:29:21 <Stinger_> @hoogle (a -> b) -> (a -> c) -> a
05:29:22 <lambdabot> No matches, try a more general search
05:29:55 <vincenz> slappybag: btw
05:29:59 <dons> sorry, bot will be back soon...
05:30:01 <vincenz> slappybag: it might be easier to first just build a list
05:30:03 <dons> just doing an upgrade
05:30:05 <vincenz> slappybag: and then doing M.fromList
05:30:11 <vincenz> dons: add haskell.dut ?
05:30:30 <augustss> dons: how is the hackathon going?
05:30:53 <dons> augustss: great. we've making some really good progress on the new binary IO library, and cabal
05:31:01 <dons> and there's lots of other things going on
05:31:11 <dons> Ross is here talking to Bjorn about hackage now
05:31:16 <slappybag> vincenz: ok thank you for your help, much appreciated (i am still annotating to try and explain my problem further)
05:31:18 <tphyahoo> Is there a faster way to get the last five elements of a list, than reversing the list and taking 5 ?
05:31:33 <tphyahoo> slow but works: take 5 $ foldl (flip (:)) [] [1,2..1000000]
05:32:29 <Stinger_> are there any extentions of flip?
05:32:34 <vincenz> slappybag: cleaning a bit
05:32:37 <vincenz> slappybag: what is fromListWith??
05:32:48 <Stinger_> for functions with 3 parameters for example?
05:32:49 <vincenz> slappybag: you mean concatMap?
05:33:11 <vincenz> ah ok
05:34:10 <augustss> tphyahoo: there is no good way to get elements from the end of a list.  reverse and take is as good as it gets.
05:34:13 <lisppaste2> vincenz annotated #34978 with "Cleaner + Complete Example" at http://paste.lisp.org/display/34978#1
05:34:44 <tphyahoo> augustss: could I use another data structure, eg array?
05:35:16 <augustss> tphyahoo: sure.  it all depends what you want to do with your data
05:36:15 <lisppaste2> vincenz annotated #34978 with "pointless fixes" at http://paste.lisp.org/display/34978#2
05:36:23 <augustss> like, are you concatenating a lot? consing? getting the head?  getting the last elements?  random access?
05:36:56 <vincenz> tphyahoo: why are they at the end?
05:37:00 <vincenz> tphyahoo: why not buidl the list in a reverse manner?
05:37:08 <slappybag> vincenz: thank you so much for all your help it's greatly appreciated, would it be ok to pm you and try to explain further?
05:37:21 <vincenz> slappybag: I'm afraid I can only commit partial attention
05:37:24 * vincenz is working
05:37:51 <slappybag> vincenz: your partial attention is far more useful than my full attention with this problem!
05:38:07 <vincenz> that was a hint in: please keep it i nthe channel cause I can't actually commit..
05:39:01 <tphyahoo> vincenz: no reason, I'm just learning.
05:40:10 <tphyahoo> I guess the question is, when to use list, when to use array.
05:40:23 <SamB_XP> use array when you want O(1) indexing
05:40:33 <SamB_XP> (approximately)
05:41:17 <tphyahoo> makes sense SamB++
05:41:45 <augustss> tphyahoo: there are many data structures besides lists and arrays
05:41:58 <vincenz> yep, like finger-trees
05:42:01 <vincenz> or what's their name
05:42:02 <augustss> tphyahoo: finger trees are excellent for certain things
05:42:12 * vincenz winks at augustss 
05:43:26 <tphyahoo> finger trees have some of the goodness of lists and arrays, right?
05:43:41 <vincenz> tphyahoo: correct
05:43:55 <slappybag> vincenz: would it be ok for me to paste the code again but with the initial filehandling? i think by excluding that i made a lot of my code void
05:43:59 <tphyahoo> actually, they have the goodness near the ends but not near the middle right?
05:44:12 <vincenz> slappybag: of course
05:44:20 <vincenz> tphyahoo: yep
05:44:41 <Masklinn> hello again
05:44:44 <tphyahoo> so in my example, I could have used a finger tree and it would have been faster. so... thanks :)
05:44:58 <vincenz> I am not certain a finger-tree implementation exists in haskell, however
05:45:04 <vincenz> But you can always roll your own :)
05:45:11 <lisppaste2> slappybag pasted "n-grams2" at http://paste.lisp.org/display/34980
05:45:41 <vincenz> slappybag: that's not a complete file, look at my example
05:45:55 <vincenz> slappybag: 1) you're not making a module, 2) you're not including Data.Map, 3) you can not refer to Data.Map as Data.Map
05:46:29 <slappybag> vincenz: d'oh, sorry. can i paste the whole thing with the includes? sorry for being so incompetent!
05:46:53 <lisppaste2> vincenz annotated #34980 with "better" at http://paste.lisp.org/display/34980#1
05:49:12 <lisppaste2> slappybag annotated #34980 with "complete" at http://paste.lisp.org/display/34980#2
05:50:03 <vincenz> slappybag: that compiles?
05:50:14 <slappybag> vincenz: yes it compiles and functions correctly
05:50:19 <vincenz> o.O
05:50:22 <vincenz> without a module XXX where?
05:50:42 <slappybag> vincenz: yup..
05:50:46 <vincenz> hmm
05:50:54 <vincenz> slappybag: anyways, using Data.Map like that in your code is bad practice
05:51:21 <vincenz> you imported it, so no need to prepend it with Data.Map
05:51:55 <dons> ?version
05:51:56 <slappybag> vincenz: ah i see. thank you
05:52:02 <vincenz> dons: :/ #haskell.dut
05:52:05 <vincenz> @join #haskell.dut
05:52:06 <dons> vincenz: yeay yeah
05:52:10 <lambdabot> lambdabot 4p457, GHC 6.5 (OpenBSD i386)
05:52:14 <dons> ?users
05:52:22 <lambdabot> Plugin `version' failed with: IRCRaised thread killed
05:52:26 <dons> ?users
05:52:28 <lambdabot> Maximum users seen in #haskell: 294, currently: 293 (99.7%), active: 3 (1.0%)
05:52:31 <vincenz> ah testing
05:52:35 <dons> ?seen dons
05:52:36 <lambdabot> Maximum users seen in #haskell: 294, currently: 293 (99.7%), active: 3 (1.0%)
05:52:42 <lambdabot> You are in #haskell.hac07, #haskell-overflow and #haskell. I last heard you speak just now.
05:53:09 <dons> ?seen lambdabot
05:53:18 <lambdabot> Yes, I'm here. I'm in #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.se, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #
05:53:23 <lambdabot> haskell.de, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
05:53:33 <vincenz> @bot
05:53:33 <lambdabot> :)
05:53:34 <psnl> woah, lots of haskell channels
05:53:42 <vincenz> @join #haskell.dut
05:53:42 <lambdabot> Not enough privileges
05:53:51 <yaarg> hey are letting me use haskell for my next project at work XD
05:53:58 <tphyahoo> vincenz, you said using fully qualified names is bad practice. doesn't it make it easier to read for people with less experience?
05:54:02 <dons> ?quit testing
05:54:02 <lambdabot> Not enough privileges
05:54:07 <dons> oh really?
05:54:08 <vincenz> tphyahoo: I typically import qualified
05:54:13 <dons> ?quit #haskell testing
05:54:13 <lambdabot> Not enough privileges
05:54:16 <dons> boo
05:54:23 <SamB_XP> hah
05:54:32 <vincenz> tphyahoo: import qualified Data.Map as M
05:54:37 <vegaiW> tphyahoo: He was against using qualified names if you didn't import qualified
05:54:48 <vegaiW> ... I think
05:54:49 <dons> ?quit try again
05:54:49 <lambdabot> Not enough privileges
05:55:00 <vincenz> vegaiW: correct, and using more than one word "Data.Map" it is misleading
05:55:02 <dons> sorear!
05:55:04 <SamB_XP> vegaiW: who is *for* that?
05:55:07 <vincenz> vegaiW: people will think you can refer to modules...
05:55:14 <dons> > 1+2
05:55:15 <lambdabot>  3
05:55:21 <dons> ok, that'll do for now
05:55:21 <vegaiW> SamB_XP: I was just clarifying :)
05:55:40 <tphyahoo> vincenz: i see.
05:55:40 <vincenz> dons: what changed, if I may ask
05:55:51 * SamB_XP likes his M.Map
05:55:57 <vincenz> SamB_XP: me too :)
05:56:00 <vincenz> M.Map S.Set
05:56:19 <tphyahoo> what's the M? monad?
05:56:22 <dons> vincenz: a bunch of things, but for one it now uses the new 'binary' library
05:56:27 <vincenz> dons: ah nice :)
05:56:37 <vincenz> tphyahoo: "import qualified Data.Map as M"
05:56:53 <vincenz> that way you don't have clashes with Data.List
05:56:59 <tphyahoo> i got that, just wondering what the M abbrev was.
05:57:06 <vincenz> short for Map?
05:57:12 <tphyahoo> oh wait...
05:57:35 <vegaiW> only 80% of things that start with M are monads :P
05:57:52 <tphyahoo> ah never mind, I just have to start trying some of this stuff out myself.
06:01:44 <slappybag> would it be possible for someone to clarify how 'Ord' works in Haskell? what are the implications in using it in: Ord a => [a] -> Map [a] [a]
06:02:30 <lisppaste2> Hunter_wow pasted "circle length" at http://paste.lisp.org/display/34981
06:02:33 <vincenz> slappybag: the type 'a' must be an instance of the Ord class
06:02:57 <allbery_b> ?instances Ord
06:02:58 <jethr0> don't you need "Ord [a]" for "Map [a] [a]"?
06:02:58 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
06:03:11 <jethr0> nm
06:03:50 <jethr0> :t Ord
06:03:52 <lambdabot> Not in scope: data constructor `Ord'
06:03:59 <vincenz> jethr0: Ord [a] depends on Ord a
06:04:13 <vincenz> instance Ord a => Ord [a] where ...
06:04:15 <jethr0> is there a way in ghci/lambdabot to show the functions declared by a type class?
06:04:30 <jethr0> k
06:04:35 <vincenz> jethr0: :i
06:04:39 <vincenz> :i Ord
06:04:43 <jethr0> i didn't know that Ord a implied Ord [a]
06:05:50 <vincenz> most higher-order types that derive Ord require Ord for their parameter
06:05:56 <vincenz> probably all
06:06:00 <vincenz> but I prefer not makng that claim
06:06:25 <Hunter_wow> was my type problem to hard? ^^
06:06:39 <vincenz> Hunter_wow: ?
06:07:21 <Hunter_wow> http://paste.lisp.org/display/34981
06:07:56 <Hunter_wow> mayby hard to understand what I¥m trying to do?
06:08:02 <vincenz> Hunter_wow: first of all, you can't use 'lenght'
06:08:03 <vincenz> it already exists
06:08:31 <Hunter_wow> ok, but still problem with length'
06:09:03 <vincenz> Hunter_wow: no should be fine if you rename it
06:09:04 <vincenz> it compiles
06:10:04 * vincenz copy-pasted it and it compiles and prints out just fine
06:10:20 <lisppaste2> vincenz annotated #34981 with "works" at http://paste.lisp.org/display/34981#1
06:10:34 <Hunter_wow> yea, true, but when I type: -> length (1,1) 1         Im getting the error "Type : Shape -> Double" Dosent match : a->b->c
06:10:42 <vincenz> Hunter_wow: obviously
06:10:48 <vincenz> Hunter_wow: length $ Circle (1,1) 1
06:10:58 <vincenz> You forgot the data-constructor
06:11:15 <vincenz> and you should have put that code in the paste..
06:11:22 <vincenz> how can I know what goes wrong if you don't show the code that borks
06:12:10 <Hunter_wow> I renamed the function to length just to make it clearer for you, I added the error message.....
06:12:21 <vincenz> Hunter_wow: look at my annotation and reread what I jsut said
06:12:53 <Hunter_wow> vincenz roger
06:12:57 <tphyahoo> ?instances Show
06:12:58 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
06:13:35 <notsmack> > (1, 2, 3, 4, 5)
06:13:36 <lambdabot>  (1,2,3,4,5)
06:14:33 <notsmack> i've got a question:  A program i'm working on has stopped running via "runhaskell", it says "Failed to load interface for 'Main'".  But when I ghci the same file and type main, it works fine...
06:15:14 <ibid> what about runghc?
06:15:33 <chessguy> ?where prelude
06:15:34 <lambdabot> I know nothing about prelude.
06:15:43 <chessguy> @hoogle prelude
06:15:44 <lambdabot> Prelude :: module
06:15:44 <lambdabot> Language.Haskell.Syntax.prelude_mod :: Module
06:15:44 <lambdabot> Distribution.Extension.NoImplicitPrelude :: Extension
06:15:56 <chessguy> ?src Prelude
06:15:56 <notsmack> runghc does the same as runhaskell
06:15:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:16:26 <vincenz> notsmack: is the file named Main.hs?
06:16:30 <xerox> ?source Prelude
06:16:30 <lambdabot> Not enough privileges
06:16:37 <xerox> ?fptools Prelude
06:16:37 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
06:16:43 <notsmack> vincenz: no, it isn't
06:16:48 <vincenz> notsmack: that is your problem ;)
06:16:58 <chessguy> ?doc
06:16:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
06:17:03 <ibid> vincenz: it shouldn't be
06:17:05 <vincenz> notsmack: how should it know which .hs file to know
06:17:08 <vincenz> ibid: yes it should
06:17:24 <vincenz> ibid: he's importing it, imported modules should have the same filename as modulename
06:17:40 <ibid> did he say he was importing it?
06:17:43 <vincenz> ibid: yes
06:17:46 <notsmack> vincenz: you're right, i now remember the main change since it last worked was changing this from a script to a module...
06:17:55 <ibid> when?
06:18:01 <notsmack> vincenz: i'm a bit confused though, shouldn't "runhaskell WebServer.hs" find WebServer.main?
06:18:07 <vincenz> ibid: "But when I ghci the same file..." implying he otherwise does not do this
06:18:19 <ibid> vincenz: that's not him saying that
06:18:48 <ibid> notsmack: are you importing the module from another module?
06:18:54 <notsmack> ibid: nope
06:18:56 <vincenz> ibid: he's importing it from inside ghci
06:19:00 <notsmack> vincenz: right.
06:19:02 <ibid> notsmack: or are you just calling it runghc Foo?
06:19:18 <notsmack> ibid: i'm trying both, ghci works
06:19:22 <ibid> vincenz: runghc should not care what the file given on the command line is called
06:19:23 <allbery_b> I thought it looked for Main.main, and a file with no "Module Foo where ..." was assumed to be module Main
06:19:28 <vincenz> ibid: THAT IS THE POINT
06:19:29 <ibid> vincenz: it's obviously the Main module
06:19:33 <chessguy> hmm, surely the list at  http://haskell.org/ghc/docs/latest/html/libraries/index.html isn't all the libraries
06:19:34 <vincenz> ibid: you missed the point
06:19:35 <ibid> vincenz: don't shout
06:19:49 * chessguy squirts a sedative in vincenz' coffee
06:19:50 <vincenz> ibid: Look, he doesn't put it on the commandline and probably does :m Main
06:19:59 <vincenz> ibid: and then when he does call ghci with it, it does work
06:20:09 <ibid> vincenz: did he dsay so? or are you ass u ming?
06:20:21 <vincenz> ibid: it is assumed on the fact that he diffferentiates wit "But"
06:20:24 <notsmack> nope, just commandline "ghci WebServer.hs", "main"
06:20:30 <ibid> vincenz: you are an ass
06:20:34 <vincenz> ibid: so are you
06:20:37 <kowey> notsmack: do you have a line that says "module ... where"?
06:20:40 * vincenz was trying to help
06:20:55 <notsmack> kowey: yeah, module WebServer where
06:21:04 <kowey> notsmack: i get the same thing when mine says something other than "module Main where"...
06:21:09 <ibid> vincenz: assuming stuff that is not true and then chiding me for not assuming such thing
06:21:09 <kowey> but my file can be named anything
06:21:14 <notsmack> vincenz: i certainly appreciate the help
06:21:18 <notsmack> ibid: from both of you
06:21:18 <vincenz> ibid: you were jumping down my throat
06:21:49 <kowey> notsmack: so renaming the module to Main works, if you just want a one-off script
06:21:52 <Stinger_> hmm how would I go about getting regex-pcre, should I be reading the cabal manual or the darcs manual
06:22:07 <ibid> vincenz: i was trying to find out if i had missed him saying those things. you said he did, and when i asked when you provided false evidence
06:22:15 <tphyahoo> Stinger: I asked that on the mailing list last week and got many replies.
06:22:16 <vincenz> notsmack: another option is to use the option "-main-is" however I am not sure this works for ghci, it does work for ghc, however.
06:22:22 <ibid> vincenz: if you had been right, i would have backed off
06:22:29 <vincenz> ibid: alright, truce
06:22:35 <ibid> vincenz: but you shouted at me!
06:22:41 * ibid goes to the bus, bbl
06:22:54 * notsmack didn't mean to start /that/
06:22:56 <tphyahoo> stinger: http://www.mail-archive.com/haskell-cafe@haskell.org/msg19348.html
06:22:59 <lambdabot> Title: Re: [Haskell-cafe] trivial function application question, http://tinyurl.com/vowef
06:23:01 <ibid> notsmack: not your fault
06:23:08 <vincenz> what ibid said
06:23:12 <tphyahoo> you need ghc 6.6, and you need to import some libraries.
06:23:22 <hk11> can anyone help - i've got some code that breaks down a text file into paragraphs and then ngrams- how would i put this broken down information into a table- i have the code to show you if anyone thinks they might know
06:23:29 <ibid> notsmack: as far as i could tell, the question was valid and proper, we just had a fight about how to interpret it
06:23:37 <tphyahoo> then you should be able to use regexes with =~ op. (I still haven't gotten this working because still on 6.4)
06:23:42 <vincenz> ibid: my assumption was "but when I gall ghci with it, it does work" ergo "ghci" vs "gchi filename" so in the prior case I assumed he was importing the module with some comand..
06:23:57 <vincenz> s/typos//
06:24:22 <ibid> vincenz: there is a reason i often ask stupid-sounding questions here. i try to find out if my assumptions are correct :)
06:24:30 <vincenz> ibid: alright :_
06:24:31 <vincenz> :)
06:24:34 <ibid> vincenz: ... questions in response to questions
06:24:52 <ibid> vincenz: it often comes out as very stupid because the assumptions *are* right :)
06:25:05 <vincenz> ibid: you're a CSer?
06:25:31 <chessguy> hk11, you'll need to define what you mean by a 'table'
06:25:32 <ibid> vincenz: former maths student, now working on PL-related stuff as a combined grad student and lecturer :)
06:25:51 <ibid> but i really do need to catch that bus :)
06:25:58 <vincenz> ibid: ah, that explains, also grad student but in EE, we tend to go with assumptions and fix the common case. but run ;)
06:27:10 <ibid> time to run, bbl
06:27:18 <ibid> vincenz: i'm ok if you are, btw
06:27:25 <vincenz> ibid: I am
06:27:28 <ibid> cool
06:27:28 <vincenz> :)
06:27:29 <ibid> -->
06:27:32 <chessguy> ibid, run already!
06:27:36 <vincenz> run, ibid, run
06:27:37 <xic> can i make my own Handle?
06:28:06 <hk11> cheesguy: basically i have broken down text into ngrams and the question i have to do next is 'Add the N-gram units to the table, and write out the results to a file for checking' does that make it any clearer?
06:28:09 <vincenz> xic: how do you mean?
06:28:20 <dons> @tell sorear where's the @source plugin gone?
06:28:21 <lambdabot> Consider it noted.
06:28:32 <dons> oh, @source conflicts with the 'source' keyword in the lambdabot .conf files maybe
06:28:56 <chessguy> ummm, not really.
06:29:01 <xic> vincenz: if i have a function that writes to a handle, Handle -> IO (), can i use my own handle object so that i can observe the writes?
06:29:04 <chessguy> maybe you could give an example?
06:29:41 <vincenz> xic: ah, oy.  Hmm, I don't know, but I think you'd have to get under the hood afaik
06:29:42 <notsmack> ok, moving the main definition to a Main.hs solved my problem, thanks guys
06:30:13 <dons> ?vixen test
06:30:14 <lambdabot> ain't it just like a man?
06:30:22 <hk11> cheeseguy: can i pm you about it?
06:30:23 <dons> ?seen dcoutts
06:30:24 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
06:30:50 <chessguy> hk11, there's a good chance i won't know the answer to your question, but i'm trying to help you ask the right question
06:30:51 <xic> vincenz: you mean i need to use c?
06:31:06 <vincenz> xic: no as in, you'd have to break into the module that defines handles
06:31:11 <vincenz> xic: but again, I'm no expet
06:31:21 <vincenz> at least not in that area
06:35:26 <chessguy> heh. guess he didn't want to give an example
06:40:35 <slappybag> is there an inbuilt function to strip punctuation from a sentence? excluding full stops (periods) ?
06:41:13 <Igloo> No
06:41:14 <vincenz> > 20 * 8 * 20
06:41:17 <dons> use filter with a predicate for the chars you want to remove
06:41:22 <lambdabot>  3200
06:41:22 <dons> > filter isSpace "haskell is fun"
06:41:24 <lambdabot>  "  "
06:41:27 <Igloo> But it's something like filter (`elem` ",;:")
06:41:28 <dons> > filter (not.isSpace) "haskell is fun"
06:41:29 <lambdabot>  "haskellisfun"
06:41:41 <Igloo> filter (`notElem` ",;:") even
06:41:52 <slappybag> brilliant, thank you very much!
06:41:56 <dons> > filter (`notElem` ",;:") "pu.nct;ation."
06:41:57 <lambdabot>  "pu.nctation."
06:42:02 <dons> > filter (`notElem` ".,;:") "pu.nct;ation."
06:42:03 <lambdabot>  "punctation"
06:42:15 <slappybag> great, thanks
06:45:49 <chessguy> punctation, hehe
06:45:57 <chessguy> sounds like a cool word
06:46:14 <paolino> @docs quickcheck
06:46:14 <lambdabot> quickcheck not available
06:52:04 <tphyahoo> :info notElem
06:52:18 <tphyahoo> > 1 + 3
06:52:20 <lambdabot>  4
06:52:27 <tphyahoo> ?info notElem
06:52:28 <lambdabot> notElem
06:52:49 <jethr0> Data.List.notElem
06:53:00 <tphyahoo> ?src notElem
06:53:01 <lambdabot> notElem x =  all (/= x)
06:53:04 <jethr0> not very helpful answer from lambdabot
06:53:19 <glguy>  ?info isn'ta command
06:53:23 <glguy> it matches ?index
06:53:28 <tphyahoo> ?index notElem
06:53:29 <lambdabot> Data.List, Prelude
06:53:29 <jethr0> ah
06:54:09 <jethr0> ?src all
06:54:09 <lambdabot> all p =  and . map p
06:54:19 <jethr0> ?src and
06:54:19 <glguy> or it matches something else, but my tab completion doesn't pick it up ;)
06:54:19 <lambdabot> and   =  foldr (&&) True
06:54:36 <jethr0> are notElem, all and and short-circuiting?
06:54:45 <glguy> yeah
06:54:50 <glguy> all due to lazy eval
06:54:55 <Saizan> notElem can't short circuit i suppose
06:54:58 <tphyahoo> ?index Elem
06:54:59 <lambdabot> bzzt
06:55:00 <glguy> sure it can
06:55:03 <tphyahoo> ?index elem
06:55:04 <lambdabot> Data.List, Prelude
06:55:05 <Saizan> ooh, yes
06:55:08 <glguy> 'a' `notElem` "aaaaaaaaaaaaaaaaaaaaaaa"
06:55:26 <tphyahoo> > 'a' `notElem` "aaaaaaaaaaaaaaaaaaaaaaa"
06:55:28 <lambdabot>  False
06:55:44 <ElPenguin> hi, i'm having some difficulty understanding haskell types. particularly regarding lifting values from monads to match type signatures etc.
06:55:47 <glguy> > 'a' `notElem` 'a' : undefined
06:55:48 <lambdabot>  False
06:56:18 <jethr0> ah, the short-circuiting of "&&" is used in all of them...
06:56:31 <jethr0> False && _ = False
06:56:43 <glguy> && shortcircuits due to lazy eval
06:57:09 <ElPenguin> any resources i could read?
06:57:44 <paolino> :t check
06:57:46 <lambdabot> Not in scope: `check'
06:57:48 <glguy> ?src liftM
06:57:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:57:52 <jethr0> glguy: more or less
06:58:09 <glguy> jethr0: there is nothing magic about &&
06:58:15 <jethr0> i know
06:58:39 <glguy> ElPenguin: see that liftM code?
06:58:43 <ElPenguin> glguy: yeah
06:58:52 <glguy> ?type liftM
06:58:53 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
06:59:05 <glguy> so, given a monad called m1
06:59:15 <glguy> you want to run a function on what is contained inside
06:59:26 <glguy> so x1 <- m1  runs m1, and binds the result to x1
06:59:36 <glguy> then you apply your function f to that value
06:59:41 <glguy> and create a new monad with return
06:59:58 <glguy> the result of return is a monad that when run, returns the value you specified
07:00:06 <ElPenguin> so i return from a monad, liftM on the value and then call a function on the lifted value?
07:00:33 <glguy> the value doesn't get lifted, the function does
07:00:37 <Stinger_> well you're lifting the function
07:00:44 <ElPenguin> the function gets lifted to operate on the value/
07:00:49 <glguy> yeah
07:00:53 <glguy> that's the "effect"
07:00:59 <glguy> ?src liftM
07:01:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:01:30 <glguy> x1 is the bound result of running m1
07:01:34 <glguy> you discard m1
07:01:42 <glguy> and make a new monadic computation
07:01:46 <glguy> that returns the new result
07:01:46 <ElPenguin> right. and that could be a standard non-monadic type?
07:01:54 <glguy> any monad type, right
07:01:57 <notsmack> ?type liftM
07:01:59 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
07:02:26 <ElPenguin> so it would have to be a monad with liftM? i couldn't return an Int for example?
07:02:54 <glguy> ?
07:03:05 <glguy> A list is a monad
07:03:08 <glguy> > [1,2,3]
07:03:11 <lambdabot>  [1,2,3]
07:03:18 <glguy> if I want the function +1 to operate on that
07:03:22 <glguy> I need to lift it into the monad
07:03:27 <glguy> > liftM (+1) [1,2,3]
07:03:29 <lambdabot>  [2,3,4]
07:04:09 <tphyahoo> the bind operator for list includes something with map I believe.
07:04:22 <ElPenguin> however say i'm using an IO monad to retrieve and integer from STDIN and i want to say increment that by lifting a function to the monad. i would have to return a monadic type?
07:04:27 <tphyahoo> explaining why the effect of what glguy is similar to what would have happened if you had used map instead of listm
07:05:03 <tphyahoo> ?src liftM
07:05:04 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:05:11 <tphyahoo> ?src [] liftM
07:05:11 <lambdabot> Source not found. stty: unknown mode: doofus
07:05:31 <tphyahoo> ?src liftM (+)
07:05:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:06:06 <chessguy> lol
07:06:24 <jethr0> xs >>= f = concat (map f xs) -- in list monad
07:06:26 <chessguy> the bot is really getting cheeky these days
07:09:57 <xic> is there a good haskell templating system, like python's Genshi/Jinja/SimpleTAL/Mighty/Cheetah?
07:10:21 <ElPenguin> i'm quite a fan of KID tbh in python
07:10:37 <xic> what about haskell?
07:10:59 <tphyahoo> ?src (>>=)
07:10:59 <lambdabot> Source not found. My pet ferret can type better than you!
07:11:07 <tphyahoo> ?src [] (>>=)
07:11:08 <lambdabot> m >>= k     = foldr ((++) . k) [] m
07:11:13 <chessguy> hehe
07:12:03 <tphyahoo> ?src mapConcat
07:12:03 <lambdabot> Source not found. My pet ferret can type better than you!
07:12:06 <tphyahoo> ?src mapconcat
07:12:07 <lambdabot> Source not found. It can only be attributed to human error.
07:12:14 <Jaak> ?src concatMap
07:12:15 <lambdabot> concatMap f = foldr ((++) . f) []
07:12:40 <Masklinn> xic > couldn't you just use HaXml?
07:13:01 <Masklinn> if you want to generate xml i mean
07:13:03 <xic> no, i want to stay away from xml
07:13:17 <Masklinn> are you generating xml or text?
07:13:22 <xic> html
07:13:22 <tphyahoo> ?src map
07:13:23 <lambdabot> map _ []     = []
07:13:24 <lambdabot> map f (x:xs) = f x : map f xs
07:14:31 <Masklinn> give haxml or The XML Toolbox a try
07:15:35 <chessguy> so, can every haskell program be represented in XML?
07:15:56 <xic> Masklinn: no, those won't work
07:16:00 <xic> i need to generate html 4
07:16:08 <Masklinn> so?
07:16:20 <Masklinn> both can serialize to HTML. HaXml can anyway
07:20:45 <Masklinn> chessguy > well XML is not a language, so you could probably find a way to translate Haskell structure in some XML dialect of your invention
07:21:33 <Masklinn> which doesn't mean that it would be a good idea
07:22:14 <Stinger_> can you import two modules into the same name space, using qualified as
07:22:44 <daniel_larsson> Why would you want to?
07:22:47 <norpan> xml is not a language, i wonder what the "l" stands for
07:23:19 <chessguy> well, it's a markup language, but not a programming language
07:23:44 <Stinger_> put Parsec and Parsec.ParsecToken into P
07:23:51 <Masklinn> xml is a meta-language, it's used to create dialects which are the "real" usable languages
07:24:09 <Masklinn> xml by itself isn't of any use, it's only a way to structure... stuff
07:24:19 <Masklinn> xml has no semantics whatsoever, it's a blank canvas
07:24:34 <norpan> <![CDATA[program text]]>
07:24:43 <chessguy> i was just curious from a perspective of genetic programming...creating and manipulating random trees which represent valid haskell programs
07:24:51 <jethr0> :t (->)
07:24:53 <lambdabot> parse error on input `->'
07:24:58 <jethr0> :info (->)
07:25:07 <Masklinn> the only thing it guarantees in and of itself is that it's well-structured (well the parser does guarantee it)
07:26:44 <Masklinn> xml is evil anyway
07:26:55 <chessguy> it has its uses
07:27:25 <cain--> hi all
07:27:31 <cain--> i have a problem with winhugs
07:27:33 <Masklinn> yes, but it's been abused far beyond what it was supposed to do, is viewed as a silver bullet by far too many people
07:27:48 <Masklinn> and even in it's application domain, it's not always ideal
07:27:49 <chessguy> any time anything's viewed as a silver bullet, it's a problem
07:27:56 <jethr0> like many good things XML is overhyped beyond repair
07:27:58 <cain--> Main> :load "C:\\Programme\\WinHugs\\packages\\hugsbase\\Hugs.hs"
07:28:11 <cain--> ERROR file:{Hugs}\packages\hugsbase\Hugs.hs - Module "Main" already loaded
07:28:12 <Masklinn> jethr0 > whether XML is a "good thing" is arguable.
07:28:14 <jethr0> haskell - the silver bullet (just kidding)
07:28:16 <cain--> ehat does this mean?
07:28:40 <jethr0> cain--: why are you trying to load Hugs.hs?
07:28:56 <Masklinn> cain-- > Hugs.hs is loaded when you start Hugs, why do you try to reload it?
07:28:58 <gds> chessguy: Surely you'd use Template Haskell for that? Manipulate the AST directly...?
07:28:58 <notsmack> Masklinn: XML is handy.
07:29:02 <cain--> because this is the file including my project
07:29:07 <jethr0> Masklinn: which alternative do you propose to save structured data to disk in a human readable form?
07:29:18 <chessguy> gds, i dunno
07:29:27 <daniel_larsson> RDF!
07:29:28 <chessguy> is there documentation for template haskell somewhere?
07:29:35 <jethr0> cain--: why would you save your project in that directory?
07:29:36 <chessguy> and what's AST?
07:29:40 <Masklinn> jethr0 > depends of the structure, simple stuff can be saved as a JSON-like structure
07:29:44 <gds> Abstract Syntax Tree
07:29:49 <chessguy> aha
07:29:50 <Nafai> jethr0: I sure wouldn't call most XML "human-readable"
07:29:52 <jethr0> @hawiki Template Haskell Tutorial
07:29:53 <lambdabot> Maybe you meant: gwiki wiki
07:30:01 <Nafai> jethr0: Sure, it's not a binary blog, but still...
07:30:05 <Nafai> s/blog/blob
07:30:08 <daniel_larsson> DocBook/XML is fairly readable
07:30:13 <chessguy> @wiki Template Haskell Tutorial
07:30:14 <lambdabot> http://www.haskell.org/haskellwiki/Template Haskell Tutorial
07:30:18 <cain--> i dont know :)
07:30:26 <Masklinn> jethr0 > YAML is also nice. But overall the best idea is probably to use the target language to configure itself, every time you can.
07:30:34 <cain--> i opened notepad and it saved the file into that dir by default
07:30:56 <Masklinn> cain-- > yeah, but don't load it, it's loaded by default when you start hugs
07:31:02 <notsmack> Masklinn: what if the language changes?
07:31:03 <Masklinn> there's no point in you manually loading it
07:31:22 <chessguy> ah, here it is
07:31:27 <cain--> ok then maybe i overwrote it
07:31:31 <chessguy> @go hawiki template haskell tutorial
07:31:31 <cain--> thanks
07:31:33 <lambdabot> http://www.nabble.com/new-TH-tutorial-(request-for-comments)-t958532.html
07:31:33 <lambdabot> Title: Nabble - new TH tutorial (request for comments)
07:31:35 <Masklinn> notsmack > what if the earth suddenly becomes cubic?
07:31:39 <jethr0> chessguy: http://haskell.org/hawiki/TemplateHaskellTutorial
07:31:40 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki
07:31:45 <notsmack> Masklinn: seems less likely
07:31:49 <chessguy> yes
07:32:06 <Masklinn> notsmack > I mean if the language you use changes in ways that break your config file, I really doubt the program itself will keep running, don't you think so?
07:32:32 <Masklinn> notsmack > config files usually aren't the most complex programming structures, some hashes, some lists, boom you're done
07:32:41 <daniel_larsson> The data might have to be shareable between applications, not all written in the same language though, much more likely than language itself changing )
07:32:49 <notsmack> Masklinn: i'm saying if the implementation language is changed
07:33:04 <Masklinn> notsmack > ah, ok then
07:33:47 <jethr0> Masklinn: also, xml is used as a transport encoding, especially between different languages...
07:34:08 <Masklinn> Well first of all the rewrite in an other language is usually a strawman, more than excedingly rare, the intercommunication is much more interesting and is the reason why XML was built in the first place
07:34:09 <notsmack> and any time you define a syntax, you don't need to write a new parser and validator
07:34:16 <Masklinn> but even in that, it's very often overkill
07:34:23 <chessguy> hmm, this tutorial doesn't look all that great
07:35:11 <jethr0> chessguy: :(
07:35:14 <Masklinn> notsmack > you don't need a validator, but you sure need a parser. Not a text parser, but a translator from your XML structure to your in-memory structures, unless you keep on reading & writing your XML structures in memory
07:35:30 <notsmack> Masklinn: it's just DOM traversal
07:35:38 <jethr0> chessguy: it does have links to all other resources at the time of writing
07:35:57 <jethr0> chessguy: why not?
07:35:58 <Masklinn> notsmack > DOM being the worst interface to XML that exists, I wouldn't consider that "just"
07:36:03 <Masklinn> it's a damn huge just.
07:36:28 <Masklinn> And my point was more about the fact that XML is often overkill, S-Exps, YAML, simple JSON-like structures are often more than enough
07:36:47 <Masklinn> and that's if you need readability, if you don't there's stuff like ASN-1
07:36:59 <daniel_larsson> ugh...
07:37:05 <chessguy> jethr0, well i haven't read it thoroughly, but it seems hard to read
07:37:06 <notsmack> Masklinn: have it your way
07:37:41 <daniel_larsson> ASN-1 makes XML look like heaven though
07:37:51 <jethr0> chessguy: took me long enough to write. but i agree that for a beginner's tutorial it might be complicated. but at least there is a tutorial at all now :)
07:38:00 <Masklinn> Yes and no, ASN-1's goals aren't XML's
07:38:22 <chessguy> i agree, it's certainly much better than nothing
07:38:24 <Masklinn> the issue with ASN-1 is that most language don't have ASN-1 modules
07:38:26 <chessguy> jethr0++
07:39:08 <jethr0> *bah* no pity please
07:39:18 <chessguy> pity?
07:40:43 <chessguy> jethr0, do you think template haskell could be used to generate random haskell programs?
07:40:55 <jethr0> inc'ing me if you think the tutorial sucks
07:41:14 <jethr0> chessguy: "could be used" - yes.
07:41:22 <chessguy> i'd much rather have a tutorial that could be improved than nothing at all
07:41:35 <chessguy> but not a good idea?
07:42:12 <pejo> Masklinn, heh, by any chance - do you work for HP?
07:42:24 <jethr0> hmm, i'm not a TH pro (there aren't many of those anyways), but generating "random" programs from an AST or grammar, although possible, doesn't seem to lead anywhere
07:42:32 <Masklinn> pejo > HP? Hewlett Packard? Nope, sorry
07:42:45 <jethr0> chessguy: wouldn't you want your function to do something sensible in the end?
07:42:58 <chessguy> hehe, of course.
07:43:06 <jethr0> and how would you evaluated how close to your goal they are performing?
07:43:17 <Masklinn> by trying to run them?
07:43:27 <chessguy> http://www.haskell.org/haskellwiki/Evolutionary_Chess
07:43:28 <lambdabot> Title: Evolutionary Chess - HaskellWiki
07:43:36 <jethr0> yes, but a random program would have a random return type, wouldn't it
07:44:10 <Masklinn> you would probably constraint the generation
07:44:13 <notsmack> jethr0: maybe random mutations that don't alter the type...
07:44:17 <jethr0> i guess mutating is a much more likely approach, but a lot of hassle in TH. it should be doable though, so chessguy give it a try
07:44:22 <jethr0> yes
07:44:27 <Masklinn> and in any case, the test framework's type would eliminate the mutations changing the output type
07:44:35 <chessguy> well, i would probably throw out the result in this case
07:44:45 <jethr0> hmm
07:44:54 <chessguy> well, i don't know
07:45:09 <chessguy> because what i really want is side effects
07:45:24 <jethr0> my guess would be that it's more realistic if you write an embedded/interpreted/compiled language specific to the needs of the chess algorithm and mutate in that language
07:46:30 <chessguy> well, the random code could include manipulations of the State
07:46:37 <therp> chessguy: my personal experiences from evolutionary computing is that interpreted approaches are usually faster for one-time-shot programs
07:46:39 <chessguy> contained by the ChessParser
07:47:14 <chessguy> therp, i'm not sure what you mean
07:47:37 <therp> chessguy: but btw. I just wrote a prolog to haskell transformer. it produces haskell core at the end from prolog statements..
07:47:52 <chessguy> nice
07:47:53 <therp> chessguy: You are aiming at genetic programming in haskell right?
07:48:17 <chessguy> yes, my project is http://www.haskell.org/haskellwiki/Evolutionary_Chess
07:48:18 <jethr0> therp: so you write a prolog interpreter in haskell core, or did i misunderstand that?
07:48:19 <lambdabot> Title: Evolutionary Chess - HaskellWiki
07:49:07 <therp> jethr0: no, not an interpreter. a compile-time prolog to haskell (Liskell actually) transformer. it produces intermediate haskell from prolog statements, which are sent to the compiler. it's a prolog compiler.
07:49:16 <jethr0> chessguy: don't you think mutations in a specialized language would be easier than in the whole of haskell? maybe write a language with only a few primitives and an interpreter
07:49:43 <chessguy> jethr0, perhaps so
07:49:49 <jethr0> therp: cool
07:50:00 <xerox> therp: is there any demonstration of this stuff? sounds nice
07:50:23 <therp> chessguy: from my personal experiences, it's faster to write your own interpreter for your own minimalistic language than to reuse the compiler in your environment (in my case it was SBCL/Allegro CL - common lisp that is)
07:50:23 <chessguy> but i would think that i could just as easily restrict the haskell generation to only generate a few primitives
07:50:34 <therp> chessguy: so I'm not sure if TH will give you anything here.
07:51:10 <chessguy> fair enough
07:52:22 <therp> xerox: http://clemens.endorphin.org/Prolog.lsk - before, that's Liskell, not Haskell. Liskell=sexp interface to Haskell.
07:52:22 <therp> s/before/beware/
07:52:31 <astrolabe> chessguy.  If your machine is going to learn/evolve by playing it's siblings, perhaps you should make it play from random positions, or it will only see a small subset of what is possible and be easy for people to confuse.
07:52:51 <jethr0> chessguy: also, TH is a bit tiring to work with IMHO
07:53:26 <vincenz> therp: what's the advantage?
07:53:37 <chessguy> astrolabe, i'm thinking of starting by evolving it from simple tactical positions, like mate-in-1, etc.
07:53:37 <vincenz> therp: you don't use macros apparently, so it's just haskell in paren-notation
07:53:38 <notsmack> i wonder if you could do anything interesting with mutated haskell like that.  input a function type, have djinn generate an example, then start mutating...
07:55:07 <astrolabe> chessguy: that might unnecessarily penalise programs that find mate in two, which in chess is just as good.
07:55:49 <chessguy> mmm, only if it's forced
07:56:04 <notsmack> "mate in two" implies that
07:56:39 <therp> xerox: the source can be divided into 3 parts. 1. prolog primitivies/helpers/unification 2. the parse tree transformers that translate a sexp-form of prolog into Liskell statements, 3. main
07:57:03 <vincenz> therp: ?
07:57:53 <therp> vincenz: what's the advantage of what?
07:57:59 <vincenz> therp: of liskell
07:58:05 <chessguy> anyway, i'm probably going to start without any primitives which give the ability to look ahead
07:58:06 <therp> vincenz: meta-programming
07:58:12 <vincenz> therp: but you don't use it in that example
07:58:14 <ibid> see ibid sit
07:58:22 * vincenz greets ibid 
07:58:28 <ibid> :)
07:58:58 <therp> vincenz: sure. just look at the prolog statements, near main. in the section before those statements, I have code that teaches the compiler how to transform these statements -> meta-programming
07:59:47 <gour> anyone familiar with SOE book? (i'd like to recommend one for my noob haskell friend)
08:01:06 <vincenz> therp: oh, the defenv
08:01:10 <jethr0> therp: how does defmacro work? how does it retain type safety?
08:01:18 <vincenz> therp: basically that changes your parser from there on?
08:01:21 <Stinger_> gour I thought it was pretty good
08:01:40 <gour> Stinger_: it looks more advanced than Craft?
08:01:55 <Stinger_> sorry don't know that one :)
08:02:05 <therp> vincenz: the parser stays the same, but you have a new transformer on parse trees before they are sent to the primitives, giving you the opportunity to rewrite them
08:02:29 * vincenz nods
08:03:05 <therp> jethr0: you get a very primitive approach to parse tree representation. basically ParseTree = 5 atoms + sublist of parsetrees.
08:03:20 <gour> i saw there is soegtk shipped with gtk2hs, so it could be a good tutorial for the kit? does everything from the bok works?
08:03:26 <gour> *work
08:03:29 <notsmack> gour: i've read craft and soe
08:03:50 <gour> notsmack: how do they compare? i'm still doing craft
08:03:51 <notsmack> craft is more of a general haskell overview, SOE focuses on doing a few cool things with it
08:03:54 <bakert> Anyone know roughly how long ghc 6.6 takes to compile on a 2Ghz machine?  it's been at it a few hours now ...
08:03:55 <therp> jethr0: so you don't get any semantic correctness with macros. they might produce complete junk. it's a bit more unsafe than TH, but you can produce semantic crap with TH as well (free unbound variables etc..) so the loss is not much for the flexibilty I gain
08:04:01 <notsmack> (soe is hudak, right?)
08:04:04 <jethr0> k, so it's not nearly as powerful as lisp macros then, but specialized to your prolog language, right?
08:04:05 <gour> yes
08:04:42 <notsmack> yeah.  i really like SOE.  if you're trying to bring him up to speed on the language, i'd say craft.  if you're trying to convince him it's a cool language, soe...
08:04:51 <therp> jethr0: lisp macros are inferior to parse tree transformers. I implemented backquoting with these things. you can't do that with macros in lisp. and no they are very generic, not specialized.
08:05:17 <jethr0> therp: interesting concept. so defmacro doesn't guarantee correctness, but the compiler will. very interesting...
08:05:53 <therp> jethr0: there is no way to guarantee correctness when you want turing completeness for meta-programming. halting problem.
08:06:14 <therp> so it's futile to try..
08:06:20 <jethr0> true, i was thinking of type safety
08:07:04 <therp> yes, true. safety does not come from typing, but from the semantic checks the compiler does lateron..
08:07:07 <jethr0> because what make TH so difficult to work with is carrying around all those type annotations
08:07:47 <therp> jethr0: TH is so hard to work with because you have to learn a new abstraction of your language. that's my personal theory why there ain't widespread adoption of TH
08:07:59 <notsmack> gour: another cool book is "haskell road to logic, maths, and programming"
08:08:11 <jethr0> therp: i agree
08:08:14 <Stinger_> how does TH compare to c++ templates
08:08:29 <jethr0> Stinger_: completely different animal
08:08:47 <Stinger_> hmm fair enough then
08:09:26 <therp> jethr0: well not entirely. there are guys that argue that c++ template give you a totally crappy but full-flexed functional-programming language at compile-time. but that's voodoo magic to me
08:09:28 <jethr0> c++ templates allow "generic programming", whereas TH allows abstract syntax tree transformations
08:09:38 <dmhouse> I think Category Theory could benefit well from polymorphism.
08:10:00 <araujo> morning
08:10:17 <jethr0> hmm, but templates don't allow you to create/alter ASTs
08:10:37 <dmhouse> jethr0: nor does Lisp.
08:10:41 <therp> jethr0: that's not possible with TH either. or?
08:10:57 <dmhouse> Oh, AST, not ADT. I misread.
08:11:05 <vincenz> therp: es it is
08:11:07 <vincenz> s/es/yes
08:11:15 <vincenz> with TH you work on the AST
08:11:20 <vincenz> literally
08:11:33 <therp> vincenz: yes, but it doesn't allow you transform a given AST, no? is it that reify* thing?
08:11:33 <dmhouse> Yes; modifying ASTs is more or less the whole point of TH.
08:12:06 <dmhouse> therp: TH gives you two operations. Splicing :: Haskell code -> AST and Reifying :: AST -> Haskell code.
08:12:09 <vincenz> therp: eh? what does it have to do with reify*?
08:12:14 <dmhouse> In between you can modify the AST.
08:12:29 <vincenz> @google reify definition
08:12:32 <lambdabot> http://www.answers.com/topic/reification
08:12:32 <lambdabot> Title: reify: Definition and Much More from Answers.com
08:12:43 <glguy> ?jargon reify
08:12:44 <lambdabot> No match for "reify".
08:12:55 <glguy> ?all-dicts reification
08:12:57 <lambdabot> *** "reification" wn "WordNet (r) 2.0"
08:12:57 <lambdabot> reification
08:12:57 <lambdabot>      n 1: regarding something abstract as a material thing [syn: {hypostatization},
08:12:59 <lambdabot>            {hypostatisation}]
08:13:01 <lambdabot>      2: representing a human being as a physical thing deprived of
08:13:03 <lambdabot> [3 @more lines]
08:13:07 <jethr0> TH doesn't allow working on already parsed code, but only on code to be parsed
08:13:10 <vincenz> @more
08:13:10 <lambdabot>         personal qualities or individuality; "according to Marx,
08:13:10 <lambdabot>         treating labor as a commodity exemplified the reification
08:13:10 <lambdabot>         of the individual" [syn: {depersonalization}, {depersonalisation}]
08:13:20 * vincenz reifies glguy 
08:13:44 * glguy feels refreshed
08:13:52 * jethr0 needs more mana
08:14:09 <jethr0> fishing for mana-ments ^_^
08:14:29 <vincenz> @users
08:14:29 <lambdabot> Maximum users seen in #haskell: 303, currently: 301 (99.3%), active: 41 (13.6%)
08:14:34 <glguy> ?losers
08:14:34 <lambdabot> Maximum users seen in #haskell: 303, currently: 301 (99.3%), active: 41 (13.6%)
08:14:36 <dmhouse> Ooh :)
08:14:42 <vincenz> > return "lambda-cookie" >>= replicate 303
08:14:43 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
08:15:22 <jethr0> > "lambda-cookie" >>= replicate 303
08:15:24 <lambdabot>  "lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll...
08:15:25 <glguy> > replicate 303 "" >> return "lambda-cookie"
08:15:26 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
08:15:36 <dons> > cycle "lambda-cookie"
08:15:37 <lambdabot>  "lambda-cookielambda-cookielambda-cookielambda-cookielambda-cookielambda-coo...
08:15:39 <jethr0> he
08:15:49 <glguy> ?botsnack
08:15:50 <lambdabot> :)
08:15:51 <therp> I'm glad that most of the regulars here have not lost their natural desire to play.
08:15:57 <dons> ?yow!
08:15:58 <lambdabot> Let's all show human CONCERN for REVEREND MOON's legal difficulties!!
08:16:23 <jethr0> @. vixen yow
08:16:24 <glguy> dons: did you see the lambdabot-complete.pl for irssi?
08:16:24 <lambdabot> Prolly
08:16:32 <dons> yeah, I heard about that
08:16:34 <dons> nice idea!
08:16:43 <glguy> @. girl19 yow
08:16:43 <lambdabot> nobody can catch me
08:16:50 <dmhouse> glguy: what does it do?
08:17:01 <glguy> dmhouse: tab completion on @ and ? commands
08:17:13 <glguy> it loads the COMMANDS file from dons site on load
08:17:26 <dmhouse> clever
08:18:40 <vincenz> and now that we have this clerver hack
08:18:49 <vincenz> dons can make a clever hack to track who's getting onto irc :)
08:18:53 <vincenz> this is how frameworks are evolved
08:19:14 <glguy> http://paste.lisp.org/display/34931
08:19:15 <notsmack> vincenz: he already did
08:19:18 <notsmack> @seen vincenz
08:19:18 <lambdabot> vincenz is in #oasis and #haskell. I last heard vincenz speak 25s ago.
08:19:24 <glguy> that is teh script
08:20:56 <glguy> the winner, it's you
08:23:29 <gour> notsmack: how does "road to.." compares with the other two?
08:25:50 <notsmack> gour: as i recall, it covers less of the language.  no coverage of monads, etc...  but the authors define data types for basic math/logic concepts and build up to pretty complicated stuff from there, with an emphasis on provability...
08:26:38 <moconnor> How come ghci is so slow to resond to Ctrl-C when in a tight loop (usually some kind infinite loop or mistake on my part)?
08:26:57 <glguy> In *nix?
08:26:59 <moconnor> yes
08:27:01 <notsmack> moconnor: you may be swapping heavily?
08:27:11 <glguy> thrashing about :)
08:27:11 <gour> notsmack: then, for more practical approach soe could be better (covering monads in greater detail) ?
08:27:29 <chessguy> SOE covers monads pretty thoroughly
08:27:31 <moconnor> oh, I was probably swapping.
08:27:42 <glguy> "because your harddrive is slow"
08:27:43 <chessguy> sorry, that was meant to be a question
08:27:45 <chessguy> SOE covers monads pretty thoroughly?
08:27:46 <notsmack> gour: yeah, maths definitely isn't practical
08:27:59 <gour> chessguy: that's good, saves one looking through many monad-tutorials
08:28:16 <chessguy> gour, i don't know that it does, i'm asking
08:28:26 <gour> notsmack: well, some math is ok, but for practical programming
08:28:27 <notsmack> i can't remember if it does at all, actually.
08:28:50 <gour> i was looking at lecture slides, and it looks pretty good
08:29:06 <chessguy> lecture slides for SOE?
08:29:11 <gour> http://www.haskell.org/soe/powerpoi.htm
08:29:12 <lambdabot> Title: Lecture Slides
08:29:14 <notsmack> gour: i was referring to "logic, maths, and programming", not math itself :-)
08:29:30 <gour> notsmack: ahh, even better
08:29:31 <jethr0> cale converted them to pdf on his wiki
08:29:49 <gour> jethr0: what's his url?
08:29:53 <notsmack> i certainly enjoyed SOE, but definitely still had to read several monad tutorials later :)
08:29:58 <jethr0> @where cale
08:29:58 <lambdabot> I know nothing about cale.
08:30:02 <gour> lol
08:30:18 <notsmack> cale.yi.org?
08:30:26 * gour laughs at dons conspiracy
08:30:28 <bakert> case sensitive?
08:30:30 <chessguy> @go cale wiki
08:30:31 <notsmack> http://cale.yi.org/index.php/Haskell_School_of_Expression_Lecture_Slides
08:30:32 <lambdabot> http://en.wikipedia.org/wiki/Cale
08:30:32 <lambdabot> Title: Cale - Wikipedia, the free encyclopedia
08:30:33 <lambdabot> Title: Haskell School of Expression Lecture Slides - CaleWiki, http://tinyurl.com/yxmq8r
08:30:37 <vincenz> gour: donspiracy?
08:31:09 <gour> vincenz: lamdba says: " I know nothing about cale."
08:31:11 <chessguy> lol, cale has an entry in wikipedia
08:32:17 <glguy> ?wiki Cale
08:32:17 <lambdabot> http://www.haskell.org/haskellwiki/Cale
08:32:23 <glguy> ?wikipedia Cale
08:32:25 <lambdabot> No Result Found.
08:32:28 <glguy> ?wikipedia cgibbard
08:32:30 <lambdabot> No Result Found.
08:32:33 <glguy> ?wikipedia cale gibbard
08:32:35 <lambdabot> No Result Found.
08:32:46 <chessguy> i'm torn as to what book i should get next
08:33:20 <chessguy> i think i have a grasp of monads in general, but little practical exposure to them
08:33:24 <gour> chessguy: what's your previous book?
08:33:36 <glguy> ?quote Saizan
08:33:36 <lambdabot> Saizan says: the problem is that we still have a silicon chip under us
08:33:41 <glguy> ?quote drunk
08:33:41 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
08:33:42 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
08:33:43 <chessguy> Road to math...
08:33:44 * kowey makes 'write a monads tutorial' a wikibook exercise
08:34:03 <glguy> ?quote drunk
08:34:03 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
08:34:06 <chessguy> @go write monad tutorial
08:34:09 <lambdabot> http://www.nomaware.com/monads/html/meet.html
08:34:09 <lambdabot> Title: Meet the Monads
08:34:10 <vincenz> @where vincenz
08:34:10 <lambdabot> http://www.esat.kuleuven.ac.be/~cpoucet/
08:34:18 * vincenz is part of the donspiracy
08:34:29 <gour> :-)
08:35:19 <notsmack> @where+ cale http://cale.yi.org/
08:35:19 <lambdabot> Done.
08:35:43 * jethr0 thought donspirators where defenestrated
08:36:05 <vincenz> we were reified
08:36:14 <jethr0> ah
08:36:17 <glguy> anyone used MonadLib before?
08:36:22 * jethr0 was deified
08:36:22 <glguy> (I just saw it mentioned in HWN)
08:36:31 <chessguy> as if a little defenestration would stop them
08:37:00 <cain_16> hi all
08:37:11 <notsmack> cain_16: hi
08:37:17 <cain_16> i have the function
08:37:19 <cain_16> istGleich :: Int -> Int -> Bool
08:37:19 <cain_16> istGleich x y = istGleich x-1 y-1
08:37:19 <cain_16> istGleich x 0 = False
08:37:19 <cain_16> istGleich 0 y = False
08:37:19 <cain_16> istGleich 0 0 = True
08:37:31 <cain_16> and the error
08:37:33 <cain_16> ERROR file:.\Test.hs:2 - Type error in explicitly typed binding
08:37:33 <cain_16> *** Term           : istGleich
08:37:33 <cain_16> *** Type           : Int -> Int -> Int -> Bool
08:37:33 <cain_16> *** Does not match : Int -> Int -> Bool
08:37:42 <cain_16> i dont get the error
08:38:03 <chessguy> istGeich x y = istGleich (x-1) (y-1)
08:38:16 <dylan> @paste
08:38:16 <glguy> cain_16: you are probably trying to use that function with 3 arguments somewhere
08:38:16 <lambdabot> http://paste.lisp.org/new/haskell
08:38:24 <glguy> OH
08:38:25 <glguy> yeah
08:38:26 <chessguy> you should have those lines in reverse order anyway
08:38:28 <glguy> what chessguy said
08:38:37 <cain_16> why
08:38:40 <chessguy> (except for the type definition)
08:38:44 <glguy> matching occurs top down
08:38:52 <glguy> and everything matches "x y"
08:39:02 <glguy> think case statements
08:39:08 <chessguy> the way you have it now, everything will be matched on the first lines, and it will never get to the base cases
08:39:22 <cain_16> ohh ok
08:39:27 <glguy> unless you were trying to secretly write an infinite loop
08:39:29 <cain_16> but it works now...
08:39:46 <dmhouse> cain_16: it might typecheck, but I bet it doesn't work.
08:39:55 <glguy> dmhouse: what's the difference?
08:40:06 <cain_16> it works but ill change it
08:40:10 <chessguy> glguy, this is a perfect example of the difference
08:40:18 <lisppaste2> dmhouse pasted "do-block translation?" at http://paste.lisp.org/display/34997
08:40:19 <chessguy> it'll typecheck, but it's an infinite loop
08:40:26 <glguy> chessguy: imagine that I was joking
08:40:45 <dmhouse> Is ^^ that paste the correct translation of do-blocks to >>=s?
08:40:53 <glguy> dmhouse: yeah
08:40:55 <cain_16> ok thanks
08:41:01 <glguy> ?undo do { y; x }
08:41:01 <lambdabot> y >> x
08:41:07 <cain_16> why do i have to put x-1 in brackets?
08:41:08 <glguy> ?undo do { v <- y; x }
08:41:08 <lambdabot> y >>= \ v -> x
08:41:22 <glguy> cain_16: function application has highest precedence
08:41:29 <glguy> cain_16: higher than operator application
08:41:35 <dmhouse> cain_16: because otherwise f x-1 will parse as f x (-1)
08:41:39 <glguy> so the -1 is occuring after calling the function
08:41:49 <cain_16> ok i see
08:41:53 <glguy> ?undo do { let y = v; x }
08:41:53 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 19}) "Parse error"
08:42:00 <glguy> whoopsie
08:42:11 * chessguy points and laughs at lambdabot
08:42:17 <glguy> dmhouse: I guess that do { let y = v; x } reduces to: x
08:42:41 <xerox> let y = v in x
08:42:48 <glguy> and since y never gets used
08:42:54 <glguy> it might just was well not exist?
08:43:01 <chessguy> ?do let y = v in x
08:43:02 <lambdabot> let y = v in x not available
08:43:12 <chessguy> ?do {let y = v in x }
08:43:12 <lambdabot> {let y = v in x } not available
08:43:13 <glguy> > let (_,_) = undefined in [1]
08:43:20 <lambdabot>  [1]
08:43:22 <dmhouse> glguy: you're making the assumption that y is free in x.
08:43:39 <glguy> dmhouse: I'm making the assumption that what you wrote is waht you were translating
08:43:57 <dmhouse> What I pasted wasn't _totally_ correct as a pattern match fail won't cause fail in the monad, but never mind.
08:44:21 <dmhouse> glguy: x ranges over expressions, it isn't just a value. Perhaps I need to make that clear.
08:44:40 <chessguy> wait, wouldn't it just translate as v >> x ?
08:44:49 <glguy> chessguy: the let example? no
08:45:01 <chessguy> why not?
08:45:15 <glguy> because that woudl be: do { v ; x }
08:45:20 <glguy> and not do { let y = v ; x }
08:45:35 <chessguy> hmm
08:45:45 <chessguy> so v is evaluated in the first, and not the second?
08:46:10 <glguy> yeah
08:46:18 <chessguy> gotcha
08:46:37 <glguy> > do { let y = 1; [1] } -- does lb support let in do blocks?
08:46:37 <lambdabot>  Parse error
08:46:56 <glguy> and that should have been [y]
08:46:58 <glguy> but either way
08:46:59 <vincenz> > do { let y  = 1; return 1}
08:47:00 <lambdabot>  Parse error
08:47:01 <dmhouse> > (do let y = 1; return 1) :: [Int]
08:47:01 <lambdabot>  Parse error
08:47:06 <dmhouse> Odd. I thought it worked.
08:47:09 <vincenz> > do { return 1}
08:47:10 <lambdabot>   add an instance declaration for (Show (m a))
08:47:12 <velco> {}
08:47:18 <dmhouse> velco: not neede.
08:47:32 <dmhouse> > (do x <- [1..4]; return (x + 1)) :: [Int]
08:47:33 <lambdabot>  [2,3,4,5]
08:47:36 <glguy> > do [1..3] ; [1..3]
08:47:38 <lambdabot>  [1,2,3,1,2,3,1,2,3]
08:48:02 <chessguy> whoah
08:48:07 <chessguy> what the heck is that?
08:48:11 <glguy> > do "magic" ; [1..3]
08:48:13 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:48:20 <glguy> > "magic >> [1..3]
08:48:21 <lambdabot>  Improperly terminated string
08:48:22 <chessguy> ?src magic
08:48:23 <lambdabot> Source not found. Do you think like you type?
08:48:24 <glguy> > "magic" >> [1..3]
08:48:25 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:48:33 <xerox> > [[1..3] | _ <- "magic"]
08:48:34 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
08:48:39 <xerox> concat that.
08:48:46 <chessguy> what the heck is magic?
08:48:49 <xerox> a string.
08:48:53 <chessguy> @type magic
08:48:54 <dmhouse> chessguy: just any old stirng.
08:48:55 <lambdabot> Not in scope: `magic'
08:49:01 <glguy> xerox: why must you ruin my fun?
08:49:09 <dmhouse> > do x <- "hello"; [1..3]
08:49:10 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:49:31 <chessguy> > do [1..3]
08:49:33 <lambdabot>  [1,2,3]
08:49:35 <dmhouse> chessguy: let's do the translation.
08:49:39 <dmhouse> do x <- "hello"; [1..3]
08:49:47 <dmhouse> "hello" >>= \x -> [1..3]
08:49:59 <dmhouse> concatMap (\x -> [1..3]) "hello"
08:50:08 <chessguy> wait
08:50:08 <xerox> > concatMap (const [1..3]) "magic"
08:50:10 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:50:13 <dmhouse> concat (map (\x -> [1..3]) "hello")
08:50:13 <chessguy> where'd that concatMap come from?
08:50:20 <dmhouse> chessguy: definition of >>= in the list monad.
08:50:25 <chessguy> oh right
08:50:25 <glguy> ?src [] >>=
08:50:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:50:37 <glguy> ?src Maybe >>=
08:50:37 <lambdabot> Source not found. It can only be attributed to human error.
08:50:40 <glguy> ?
08:50:43 <dmhouse> concat [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
08:50:43 <glguy> ?src [] (>>=)
08:50:43 <lambdabot> m >>= k     = foldr ((++) . k) [] m
08:50:48 <dmhouse> Etc.
08:50:53 <glguy> ?src concatMap
08:50:54 <lambdabot> concatMap f = foldr ((++) . f) []
08:51:02 <glguy> concatMap is =<<
08:51:04 <glguy> for list monad
08:51:10 <dmhouse> chessguy: make sense?
08:51:29 <chessguy> yes, i think so.
08:51:30 <glguy> ?src [] (=<<)
08:51:31 <lambdabot> Source not found. Do you think like you type?
08:51:36 <glguy> ?src (=<<)
08:51:37 <lambdabot> f =<< x = x >>= f
08:51:38 <chessguy> but lunch is here
08:53:32 * vincenz looks around, no it's not!
08:56:04 <xerox> > let x^y = length (sequence (replicate x (replicate y []))) in (1^5,2^2,3^4,9^3)
08:56:06 <lambdabot>  (5,4,64,19683)
08:56:29 <dmhouse> > (1^5, 2^2, 3^4, 9^ 3)
08:56:31 <lambdabot>  (1,4,81,729)
08:56:35 <xerox> oops.
08:57:08 <dmhouse> > (5 ^ 1, 2^2, 4^3, 3^9)
08:57:10 <lambdabot>  (5,4,64,19683)
08:57:13 <dmhouse> Hehe. :)
08:57:17 <xerox> (:
08:58:49 <chessguy_lunch> hmm, i like this, catered lunch every friday
09:09:35 <rongenre> morning everyone
09:09:46 <chessguy_lunch> good afternoon :)
09:13:47 <dmhouse> Cale: around?
09:21:37 <sm> morning all
09:21:50 <sm> are there any personal finance tools written in haskell ?
09:23:23 <Nafai> That would be cool; I haven't heard of any
09:24:55 <sm> not finding any
09:25:10 <notsmack> sm: time to start hacking
09:25:26 <sm> very well! I'm going to write one
09:25:35 <sm> it is the year 2007, Friday, January 12, 09:19 am, in Los Angeles, and now I begin.
09:25:52 <notsmack> now /that's/ the right response!
09:26:16 <Nafai> sm: What kind of tool are you wanting?  Quicken like?  Or something more like ledger?
09:26:51 <sm> first, I want something that makes data entry as efficient as possible, for me
09:26:54 <paolino> what "personal finance" means in poor words ?
09:27:20 <sm> and later exports it into gnucash etc.
09:27:46 <notsmack> sm: console based?
09:27:54 <sm> yes, initially
09:28:04 * paolino google ledger
09:28:18 <notsmack> sounds pretty straightforward
09:28:51 <sm> http://www.sql-ledger.org/
09:28:52 <lambdabot> Title: SQL-Ledger ERP
09:28:56 <Nafai> No
09:29:17 <Nafai> http://newartisans.com/ledger.html
09:29:19 <lambdabot> Title: New Artisans LLC
09:29:26 <Nafai> *That* ledger
09:29:30 <sm> aha, thx
09:29:47 <Nafai> I use it, like it a lot
09:32:28 <complaisant> ?paste
09:32:29 <lambdabot> http://paste.lisp.org/new/haskell
09:33:09 <lisppaste2> complaisant pasted "GHC BUG ?? wtf!?" at http://paste.lisp.org/display/35004
09:33:21 <complaisant> i need help here.. someone already got this errmsg?
09:34:11 <complaisant> i'm working with wx in ghc-6.4 i suddenly when i runned ghci-6.6 i got this errmsg
09:34:53 <notsmack> hmm... what does a type like this mean?
09:34:54 <notsmack> sresult 200 "test" :: (Monad m) => m Result
09:35:11 <complaisant> notsmack Maybe Result ?
09:35:11 <notsmack> a Result wrapped in any monad?
09:36:00 <complaisant> notsmack yes.
09:36:13 <notsmack> alright, ":: Maybe Result" and ":: [Result]" both work as i'd expect, so i see that that's true
09:37:51 <rongenre> Does anyone use particularly large hash tables?
09:39:36 <therp> complaisant: looks like a borken GHC installation?
09:41:10 <complaisant> therp.. it was workin yestarday -.-
09:41:32 <therp> complaisant: my installation contains IO.hi in /usr/lib/gcc-<your-version>/imports/GHC
09:43:37 <slappybag> anyone around and willing to help me with some code?
09:44:00 <notsmack> slappybag: probably, go ahead and ask
09:44:16 <notsmack> ?paste
09:44:16 <complaisant> well @?least ghci-6.4 works
09:44:17 <lambdabot> http://paste.lisp.org/new/haskell
09:44:43 <jethr0> slappybag: sure
09:44:46 <lisppaste2> slappybag pasted "automating a function" at http://paste.lisp.org/display/35005
09:44:56 <slappybag> just annotating to explain
09:45:01 <cinimod> where would I get a copy of emacs or xemacs for opensuse?
09:45:24 <lisppaste2> slappybag annotated #35005 with "what it is" at http://paste.lisp.org/display/35005#1
09:46:04 <complaisant> therp : amazing world of ghc.. i runned ghci-6.4 & then runned again ghci-6.6 & guess what? it's working again..
09:46:05 <complaisant> lol
09:46:31 <therp> complaisant: I better don't ask further questions :)
09:46:46 <lisppaste2> [d-_-b] pasted "parse erros on input '='" at http://paste.lisp.org/display/35006
09:46:50 <cinimod> sorry wrong channel :-(
09:46:52 <jethr0> slappybag: could you explain in a few sentences what you are trying to do (i.e. what ngrams are)?
09:47:08 <slappybag> jethr0: sure, as an annotation or here?
09:47:11 <notsmack> jethr0: an n-gram is a set of n consecutive characters
09:47:29 <jethr0> notsmack: i've heard of it, but i has type [String]
09:47:38 <Botje> slappybag: I'd do it in the readFile line, or the line below it
09:48:03 <notsmack> i'm with Botje, just from a quick skim
09:48:21 <slappybag> Botje: can i just add removePunc f to the same line? (sorry, i'm very inexperienced with Haskell)
09:48:49 <vincenz> removePunk
09:48:50 <notsmack> removePunc (readFile f)
09:48:57 <notsmack> wait, no?
09:48:58 <Botje> slappybag: you'd need to "myFile <- liftM (adjust . removePunc) $ readFile f"
09:48:59 <Botje> i think
09:49:10 <Botje> :t readFile
09:49:12 <lambdabot> FilePath -> IO String
09:49:19 <Botje> removePunc wants a string
09:49:28 <Botje> :t liftM tail $ readFile f
09:49:29 <lambdabot> Not in scope: `f'
09:49:32 <Botje> :t liftM tail $ readFile
09:49:34 <lambdabot>     Couldn't match `[a]' against `IO String'
09:49:34 <lambdabot>       Expected type: FilePath -> [a]
09:49:34 <notsmack> mapNGrams (paras (removePunc myFile)) should work
09:49:52 <Botje> :t liftM tail $ getContents
09:49:54 <lambdabot> IO [Char]
09:49:57 <Botje> yay
09:50:00 <Botje> I grok liftM
09:50:04 * Botje gains a level
09:50:08 <[d-_-b]> pasted "parse erros on input '='" at http://paste.lisp.org/display/35006 --anyone knows what is wrong?
09:50:13 <Botje> one down, 2^31-2 to go
09:50:36 <slappybag> thanks Botje, notsmack, i shall experiment with that now. much appreciated!
09:51:21 <jethr0> [d-_-b]: indentation
09:51:36 <jethr0> let needs to be used with "in" outside of do-notation
09:51:42 <bakert> Is there a haskell library that deals with dates and times that works with 6.4?
09:51:51 <jethr0> sry, in is there, but indentation is still wrong
09:52:13 <Botje> [d-_-b]: a tip if you're going to paste code: use english variable & type names
09:52:15 <jethr0> [d-_-b]: the line after the let has to be indented so that the b stands under the a
09:52:54 <jethr0> [d-_-b]: and the "in" has to stand under the "let"
09:53:39 <jethr0> Botje: what happens at 2^31-1? you reach nirvana?
09:54:28 <Botje> that or horrible fear of heights
09:54:57 <dons> mmm, nice, http://programming.reddit.com/goto?id=y2im
09:55:00 <lambdabot> Title: vincent kr&auml;utler: baby steps in haskell
09:55:17 <Nafai> dons: Yeah, I delicious'd that to read later
09:55:40 <dons> cool
09:55:49 <[d-_-b]> yaa thats it! it was necessary to put a ';' between the "a = ..." and "b = ...". Thanks :)
09:55:54 <slappybag> notsmack: thanks a lot, your idea worked perfectly! [ mapNGrams (paras (removePunc myFile)) ]
09:56:49 <genbie> anyone knows how to use read function please? i want to convert a string to int then multiply them and display the result
09:57:01 <genbie> to = two
09:57:29 <notsmack> slappybag: glad to hear it.  the thing to keep in mind is that readFile gives you an IO String, but once you bind it with (<-) you can use it like a String
09:58:17 <slappybag> notsmack: brilliant, it's finally starting to make sense! thanks again
09:58:23 <arjanoosting> > read "123" :: Int
09:58:24 <lambdabot>  123
09:58:35 <arjanoosting> genbie: ^^^
09:58:39 <Botje> > read "123" + read "42"
09:58:40 <lambdabot>  165
09:59:40 <slappybag> notsmack: is there a way to also run adjust with removePunc ?
09:59:45 <genbie> thanks, i was trying to use read with getLine but it is not compiling!
09:59:50 * notsmack looks back at the paste
09:59:51 <jethr0> \check \a b -> a == b+1-1
09:59:53 <lisppaste2> sm pasted "moneybags" at http://paste.lisp.org/display/35008
10:00:10 <sm> and so it begins! :)
10:00:15 <jethr0> ?check \a b -> a == b+1-1
10:00:16 <lambdabot>  Add a type signature
10:00:33 <notsmack> slappybag: i'd imagine you want to run adjust first, then removePunc?
10:00:46 <slappybag> notsmack: yeah that's right
10:00:47 <genbie> i did (arg <- getLine) (arg2 <- getLine) (read(arg) * read(arg2))
10:01:06 <notsmack> slappybag: just 'adjust( removePunc( myFile) )'
10:01:24 <sm> later all
10:01:45 <notsmack> slappybag: once you get sick of parentheses you might want to figure out (.) and ($), but that should work
10:01:57 <jethr0> notsmack: how is that first?
10:02:00 <notsmack> whoops, reverse those two though
10:02:02 <notsmack> jethr0: yep
10:02:23 <notsmack> <:-)   ( <- Dunce cap)
10:02:42 <jethr0> @notsmack
10:02:43 <lambdabot> :)
10:02:43 <notsmack> removePunc (adjust myFile)
10:04:07 <Botje> :t readLine
10:04:09 <lambdabot> Not in scope: `readLine'
10:04:10 <Botje> :t getLine
10:04:12 <lambdabot> IO String
10:04:20 <Botje> genbie: read wants a String, not an IO String
10:04:41 <Botje> and <- only works in do expressions
10:04:51 <Botje> which in turn only work in functions that return an IO *
10:04:52 <genbie> Botje thanks! Yes i did that in do
10:05:05 <paolino> anyone knows if I can control the number of elements of lists generated by quickcheck ?
10:05:09 <genbie> Botje how can i convert an IO string to a String?
10:05:25 <Botje> genbie: you can't.
10:05:33 <dons> do x <- getLine ; return x
10:05:40 <Botje> but you can perform the IO action, and get back the string
10:05:51 <slappybag> notsmack: i am getting a program error: pattern match failure
10:05:59 <jethr0> paolino: there is a tentative solution to this on either the QC site or the paper. but generating recursive datatypes is a tad difficult
10:06:07 <slappybag> i suspect it could be my incompetence
10:06:20 <genbie> i am just learning this stuff.. i just want to read 2 numbers and multiply them and print the result
10:06:31 <notsmack> ah, that adjust can't just be passed the whole string
10:07:19 <jethr0> main = do {arg1 <- getLine; arg2 <- getLine; let x = (read(arg1) * read(arg2)); putStrLn x}
10:07:51 <notsmack> slappybag: you want to break the input into words, and adjust each?
10:07:55 <jethr0> @pretty main = do {arg1 <- getLine; arg2 <- getLine; let x = (read(arg1) * read(arg2)); putStrLn x}
10:07:55 <lambdabot> "Parse error" at column 91
10:08:01 <genbie> jethr0 will read accept that?
10:08:11 <genbie> i mean that is an IO String not a String
10:08:19 <jethr0> yes. if it's not a number though it will fail at runtime
10:08:22 <slappybag> notsmack: yep that's right
10:08:33 <jethr0> the "<-" extracts the String from the IO String
10:08:52 <genbie> i will try it now thanks
10:09:25 <Cale> It does so by running the IO action
10:10:00 <Cale> (when the IO action described by the do-block is eventually run)
10:10:09 * jethr0 still thinks that it's unfortunate that beginners always want to do IO which is arguable one of the more "different" aspects of haskell :(
10:10:25 <jethr0> s/do IO/do IO first/
10:10:32 <Botje> jethr0: that's how most other languages start off, though
10:10:32 <notsmack> slappybag: well it looks like you could do "unwords (map (removePunc . adjust) (words myFile))"...
10:10:35 <Botje> "here's hello world"
10:10:36 <jethr0> i know
10:10:47 <notsmack> slappybag: the unwords assumes you want to combine it back into one big string
10:10:57 <slappybag> notsmack: ah i don't
10:11:09 <jethr0> but it gives people the feeling that haskell is an academic language whereas it just works very differently from anything they've seen before
10:11:31 <Botje> indeed
10:11:36 <notsmack> slappybag: well then just the map should give you the list of words, adjusted and removePuncd
10:11:48 <notsmack> though that may not go nicely into paras
10:12:12 <slappybag> notsmack: ok great, i shall play around with that. thanks a lot for all your help
10:12:41 <paolino> a powerful IDE would help, because next objection is ghci is not enough powerful to let people not fight IO in the beginning
10:12:49 <notsmack> slappybag: any time
10:13:26 <jethr0> paolino: huh?
10:14:11 <genbie> thanks, i finally got it ;-)
10:14:21 <Jaak> @type liftM2 (*) readLn readLn >>= print
10:14:23 <lambdabot> IO ()
10:14:35 <genbie> quite different from other languages including functional ones like ML
10:14:58 <paolino> I mean, I write my pure functions in an editor. But then using them in ghci is not satisfactory
10:15:28 <paolino> So I start thinking a UI for them
10:15:34 <jethr0> hmm
10:15:42 <paolino> and monads appears all around
10:18:26 <jethr0> the combination of @check and @free seems to open nice opportunities....
10:18:52 <jethr0> if only haskell supported a bit more stringent "proving" facilities than quickcheck
10:19:04 <paolino> @free ?
10:19:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:19:55 <jethr0> @free filter
10:19:57 <lambdabot> $map f . filter (g . f) = filter g . $map f
10:20:05 <jethr0> paolino: theorems for free :)
10:20:23 <paolino> wow
10:20:40 <jethr0> check \f g s -> (map (f::Int->Int) . filter (g . f)) s == (filter g . map f) (s::T)
10:20:47 <jethr0> @check \f g s -> (map (f::Int->Int) . filter (g . f)) s == (filter g . map f) (s::T)
10:20:52 <lambdabot>  OK, passed 500 tests.
10:21:26 <genbie> can the function read "7.5" or only integers like "7" please?
10:21:30 <genbie> convert
10:21:38 <jethr0> both
10:21:42 <notsmack> huh...  does quickcheck generate arbitrary functions Int->Int there?
10:21:44 <jethr0> > read "7.5" :: Double
10:21:45 <lambdabot>  7.5
10:21:53 <dons> notsmack: yeah
10:22:09 <notsmack> that seems... impressive
10:22:10 <genbie> i have an error when i try 7.5
10:22:16 <dons> ?check \f -> f True `elem` [True,False]
10:22:17 <lambdabot>  OK, passed 500 tests.
10:22:23 <dons> ?scheck \f -> f True `elem` [True,False]
10:22:24 <bos> dons: what does Data.Binary do about type safety, if anything?
10:22:24 <lambdabot>   Completed 4 test(s) without failure.
10:22:34 <jethr0> i wish there was version of free that returned a representation readable by @check, so that you can do @. check free filter
10:22:38 <iulus> genbie, can you paste the error?
10:22:39 <dons> bos, nothing yet. But that reminds me I need to write an instance Dynamic for it
10:22:39 <genbie> Prelude.read: no parse
10:22:40 <iulus> @paste
10:22:40 <lambdabot> http://paste.lisp.org/new/haskell
10:22:43 <HairyDude> is there any kind of ML channel on freenode? or other irc network?
10:22:47 <dons> so we can serialise values with their types
10:22:51 <jethr0> but i guess there's a little hand-crafting necessary to build a QC property
10:22:56 <dons> HairyDude: there's #ocaml, but its pretty quiet
10:23:12 <HairyDude> is ocaml a dialect of ml then?
10:23:16 <jethr0> genbie: what type does the program expect?
10:23:23 <jethr0> > read "7.5" :: Int
10:23:24 <lambdabot>  Exception: Prelude.read: no parse
10:23:25 <dons> HairyDude: yeah
10:23:30 <bos> dons: so a get expecting an Int will consume a put of a String?
10:23:30 <HairyDude> interesting
10:23:46 <dons> bos, andbad things will happen, yes
10:23:49 <genbie> i am using ghci jethr0
10:23:52 <bos> hmm.
10:23:56 <jethr0> genbie: so?
10:24:00 <dons> bos, though we plan to add at least an error handling layer
10:24:02 <genbie> i just type: read"7.5"
10:24:05 <dons> to get reasonable error messages
10:24:12 <genbie> an di get an erro
10:24:15 <dons> now, you could tag values with their types
10:24:17 <paolino> jethr0: you know what is coarbitrary ?
10:24:18 <dons> which would help
10:24:19 <iulus> genbie: type read "7.5" :: Double
10:24:27 <dons> i.e. serialise with typeables
10:24:27 <jethr0> hmm, try giving it a return type, otherwise it might default to Int (??)
10:24:33 <iulus> otherwise 'read'doesn't know what it is trying to parse
10:24:45 <bos> dons: right.
10:24:53 <jethr0> paolino: i read it in the paper somewhere but i already forgot again
10:25:05 <bos> dons: the behaviour of the python pickle module is nice in this regard.
10:25:10 <dons> bos, and people are free to write their own instances that do extra handling
10:25:13 <dons> for example, adding types and cksums
10:25:31 <dons> newtype T = T String ; intance Binary T where put x = put (typeOf x) ; put x
10:25:43 <Saizan> genbie: read behaves differently according to the requested type of the result, so  read "7.5" :: Int  is a parse error
10:25:44 <paolino> jethr0: I cannot understand that part
10:25:50 <bos> dons: but if i write my own instance, that doesn't help me with the safety of existing instances.
10:25:57 <jethr0> @let (+) = (-)
10:25:58 <notsmack> dons: have a link explaining how quickcheck does arbitrary functions?
10:25:59 <lambdabot> Defined.
10:26:15 <jethr0> > L.(+) 4 5
10:26:16 <lambdabot> Terminated
10:26:24 <jethr0> grmpf
10:26:33 <iulus> what?
10:26:39 <dons> notsmack: yeah, the QuickCheck paper
10:26:53 <dons> bos, right. so we have a plan for interleaving arbitrary stuff that you ant to do
10:27:10 <dons> such as adding a "put (typeOf x)" before every 'put x'
10:27:18 <dons> using a BinaryT transformer
10:27:20 <jethr0> dons: where does the "==>" operator in @let come from?
10:27:21 <bos> dons: mmm, yummy.
10:27:24 <dons> but so far just a sketch
10:27:27 <notsmack> dons: ICFP 2000?
10:27:29 <bos> dons: where are the plans written up?
10:27:33 <genbie> saizan thanks so what is teh solution?
10:27:34 <dons> so you could add, say, put (cksum x) too
10:27:40 <dons> to cksum, and type data, on disk
10:27:43 <dons> (or the network)
10:27:50 <dons> bos, verbally
10:27:59 <moconnor> If I make a type, "type Foo a = [([a],[a])]" and I want "a" to be in class Eq, is there anyway to say that in the type decleration so I don't have to say "Eq a =>" in every function's type signature?
10:28:17 <bos> dons: ah. wish i was in oxford, then :-)
10:28:30 <Saizan> genbie: depens on what you want, if you want reals you should use  (read string) :: Double
10:28:54 <jethr0> moconnor: my guess would be that for type synonyms it's not possible, but who knows...
10:30:02 <allbery_b> moconnor: you cn say it with -fglasgow-exts, but it has odd effects so don't do it
10:30:26 <genbie> Saizan thanks that worked. Also, I tried Double on "7.5" an don "7".. it worked both times.. so Double can be used always but not Int?
10:30:42 <allbery_b> (specifically it creates a new "temporary" type everywhere you use the synonym and can't figure out how to put them together again)
10:31:09 <moconnor> allbery_b: ok, I won't do it then.  I was just curious.  Thanks
10:31:21 <Saizan> genbie: well a Double can have or not a decimal part, where an Int cannot ever have it
10:31:39 <genbie> yes thanks
10:31:43 * allbery_b spent several days trying to debug a program that was broken because he'd used a class constraint ina  type synonym
10:32:23 <vincenz> allbery_b: debug?
10:32:26 <jethr0> allbery_b: how about data types?
10:32:27 <vincenz> allbery_b: you mean, detype
10:32:42 <broosters> visit http://broosters.blogspot.com for the best chicks and the better entertainment... LMAO
10:32:44 <broosters> visit http://broosters.blogspot.com for the best chicks and the better entertainment... LMAO
10:32:46 <broosters> visit http://broosters.blogspot.com for the best chicks and the better entertainment... LMAO
10:32:46 <vincenz> allbery_b: that's the nice thing of haskell, debuggin happens at compiletime, not runtime :)
10:32:51 <allbery_b> "trying to figure out why it refused to typecheck, wih strange errors"
10:32:58 --- mode: ChanServ set +o vincenz
10:33:09 <allbery_b> compile-time debugging is still debugging, in my world :)
10:33:11 <dons> bah
10:33:14 <Saizan> genbie: btw, there are other useful types for numbers in Haskell, so if you have specific needs you can look for more info, but this two covers the common case
10:33:16 <vincenz> he's still online
10:33:25 <dons> i'll block him from here with ChanServ
10:33:29 * vincenz nods
10:33:30 <paolino> vincenz loaded the bazooka
10:33:41 * jethr0 is wondering what happened to the "Monads as Computations" page on the wiki
10:33:49 <genbie> thanks saizan
10:34:13 --- mode: vincenz set -o vincenz
10:34:17 <vincenz> I should alias opping
10:34:24 <jethr0> AND i think searching is down in "hawiki"
10:34:28 <vincenz> ./msg Chanserv op #haskell vincenz
10:34:29 <vincenz> is too long
10:34:43 <dons> vincenz: do you use irssi?
10:34:53 <jethr0> vincenz: maybe add "@opme" to lambdabot :)
10:34:56 <iulus> is ChanServ some sort of bot?
10:35:04 <vincenz> dons: i do
10:35:09 <dons> I have: 05:32 op         msg chanserv op $C dons
10:35:17 <dons> which ops me in the current channel, using /op
10:35:22 <dons> iulus: yeah
10:35:28 --- mode: ChanServ set +o vincenz
10:35:30 --- mode: vincenz set -o vincenz
10:35:31 <dons> it handles some channel functions
10:35:34 <vincenz> dons: thanks, nice :)
10:35:49 <dons> conversly, msg chanserv op $C -dons
10:35:56 <vincenz> or just deop
10:36:33 <bos> dons: how much longer does the hackathon run?
10:36:40 <dons> a couple of hours :)
10:37:13 <bos> the verbal plan for Data.Binary sounds promising.
10:37:22 <bos> the existing code is nice and clean, too.
10:37:54 <dons> yeah, and runs in hugs!
10:40:15 * vincenz sigs
10:40:41 <bos> dons: i guess there's no plan to handle circular references?
10:40:43 <jethr0> sigs?
10:40:46 <vincenz> +h
10:40:53 <jethr0> h++
10:40:57 <dons> bos, yeah, not really.
10:41:02 <dons> circular structures are nasty ;)
10:41:06 <dons> but SerTH can do it
10:41:06 <vincenz> crappy semantical models
10:42:33 * vincenz goes
10:42:40 <bos> yeah, but SerTH uses template haskell.
10:43:24 <dons> yep
10:43:35 <dmhouse> What's a good example of a function other than map that you can write on any functor?
10:44:03 <Saizan> a fold?
10:44:26 <dmhouse> You need more than functor structure for a fold.
10:44:33 <xerox> traverse?
10:44:57 <HairyDude> compose?
10:45:10 <dmhouse> ?hoogle Functor f => a
10:45:11 <lambdabot> Prelude.undefined :: a
10:45:12 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:45:12 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
10:45:31 <xerox> return (:
10:45:43 <HairyDude> that's defined on all monads...
10:46:01 <dmhouse> HairyDude: how would compose be generalised to functors?
10:46:17 <HairyDude> I mean you can compose functors
10:46:21 <dmhouse> Oh, right.
10:47:09 <xerox> dmhouse: Functor f => f (f a -> a) -> f a
10:47:13 <dons> pictures live from the hackathon, http://cgi.cse.unsw.edu.au/~dons/blog/2007/01/13#hac07-day3
10:47:13 <lambdabot> Title: Haskell hacking
10:47:29 <ClaudiusMaximus> @paste
10:47:30 <lambdabot> http://paste.lisp.org/new/haskell
10:47:38 <HairyDude> ?hoogle Functor f => f a -> b
10:47:38 <lambdabot> Prelude.id :: a -> a
10:47:39 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:47:39 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:48:08 <dmhouse> ?instances Functor
10:48:09 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:48:27 <dmhouse> dons: names?
10:48:39 <xerox> dmhouse: check the group pic
10:48:40 <dons> see the group photo page
10:48:53 <dmhouse> Just saw it, thanks. :)
10:49:49 <rongenre> Does anyone have hints on tuning GC time on a hashtable?  I'm getting 35% productivity on something pretty simple
10:50:55 <lisppaste2> rongenre pasted "how to tune the GC time?" at http://paste.lisp.org/display/35011
10:51:10 <dons> Lemmih: did you commit your patches?
10:51:33 <Jaak> > fmap (*2) (+1) $ 1
10:51:34 <lambdabot> Terminated
10:51:36 <genbie> When I say something like this:  (read(arg1)::Double). Am I using "Double" as a way to convert a possible an Integer argument, or just to provide a signature? Or are these 2 concepts the same?
10:51:42 <Jaak> uh...
10:52:10 <bos> genbie: you're giving the signature of the result of read.
10:52:29 <bos> @type read
10:52:30 <lambdabot> forall a. (Read a) => String -> a
10:52:34 <allbery_b> @undefine
10:52:35 <lambdabot> Undefined.
10:52:43 <Jaak> oh
10:52:43 <allbery_b> > fmap (*2) (+1) $ 1
10:52:45 <Jaak> > fmap (*2) (+1) $ 1
10:52:46 <bos> @type read :: (String->Double)
10:52:46 <lambdabot>  4
10:52:46 <lambdabot>  4
10:52:47 <lambdabot> (String->Double) :: String -> Double
10:53:12 <genbie> bos, so if i provide read("3"), it will convert it to 3.0. this i sconversion, right?
10:53:28 <ClaudiusMaximus> ?hoogle (IO ()) -> IO ()
10:53:28 <lambdabot> System.Mem.Weak.addFinalizer :: key -> IO () -> IO ()
10:53:29 <lambdabot> Foreign.Concurrent.addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
10:53:29 <lambdabot> GHC.Conc.addMVarFinalizer :: MVar a -> IO () -> IO ()
10:53:36 <genbie> @type read
10:53:38 <lambdabot> forall a. (Read a) => String -> a
10:53:45 <HairyDude> read "3" is ambiguous
10:53:46 <bos> genbie: it will convert it to 3.0 if you constrain the type of the result to Double, yes
10:54:02 <Jaak> > let (+) = (-) in 1 + 1
10:54:04 <bos> > read "3"
10:54:04 <lambdabot>  0
10:54:05 <lambdabot>  Add a type signature
10:54:11 <bos> > read "3" :: Int
10:54:12 <lambdabot>  3
10:54:15 <bos> > read "3" :: Double
10:54:16 <lambdabot>  3.0
10:54:39 <jethr0> > read "3" :: Char
10:54:41 <lambdabot>  Exception: Prelude.read: no parse
10:54:51 <genbie> so it is always better to privide a type signature to read?
10:55:01 <Jaak> > read "foo" :: String
10:55:01 <HairyDude> > read "'3'" :: Char
10:55:03 <lambdabot>  '3'
10:55:03 <lambdabot>  Exception: Prelude.read: no parse
10:55:05 <bos> genbie: you don't have to if the compiler can figure it out for you.
10:55:08 <HairyDude> odd
10:55:22 <jethr0> > read "\"foo\"" :: String
10:55:24 <lambdabot>  "foo"
10:55:27 <genbie> thanks
10:55:38 <jethr0> HairyDude: read is dual to show
10:55:43 <jethr0> > show "foo"
10:55:44 <lambdabot>  "\"foo\""
10:55:46 <bos> and if the compiler can't figure it out, it won't guess; you'll get a compile error.
10:55:57 <resiak> > show '3'
10:55:59 <lambdabot>  "'3'"
10:56:27 * resiak notices that two lines of lambdabot's output were reversed, and understands
10:56:31 * SamB cheers for compilers that won't guess
10:56:48 <jethr0> compilerThatWontGuess++
10:56:54 <HairyDude> > read "\"foo\"" :: String
10:56:55 <lambdabot>  "foo"
10:56:57 <HairyDude> ah I see
10:58:18 <SamB> actually, occasionally GHC guesses about things, but in those cases it is already halting with an error, and just offers the guess as a suggestion...
10:59:05 <jethr0> SamB: also there's the default directive, which kind of let's the compiler guess :(
10:59:16 <jethr0> "default"
10:59:23 <notsmack> ?paste
10:59:24 <lambdabot> http://paste.lisp.org/new/haskell
11:03:26 <lisppaste2> notsmack pasted "HAppS/Monad confusion" at http://paste.lisp.org/display/35015
11:05:47 <notsmack> can anybody help with that?
11:07:21 <araujo> http://www.fmap.us/
11:07:23 <lambdabot> Title: fmap
11:07:26 <araujo> suggestion welcome!
11:07:26 <araujo> :-)
11:09:15 <LOKadin> how do I reassign the +,  su'i = (+) ?
11:09:47 <mahogny> what do you mean by reassign? what do you want to do?
11:09:59 <LOKadin> I want su'i to be used in place of +
11:10:05 <tibbe> > let add = (+) in add 1 2
11:10:07 <lambdabot>  3
11:10:40 <LOKadin> > le su'i = (+) in su'i 2 3
11:10:40 <lambdabot>  Parse error
11:10:44 <LOKadin> > let su'i = (+) in su'i 2 3
11:10:46 <lambdabot>  5
11:11:12 <LOKadin> so "su'i = (+)" should work?
11:11:22 <jethr0> not outside of "let"
11:11:38 <notsmack> why not?
11:11:38 <jethr0> you can't rebind variables/functions except in ghci
11:11:42 <notsmack> ah
11:11:43 <mahogny> let (+)=(++) in "a" + "b"
11:11:47 <notsmack> right.
11:12:01 <mahogny> but doing it globally... ah, don't
11:12:20 <mahogny> if you need to do some weird hacking like this, them maybe you want to look at template haskell
11:12:31 <mahogny> but this smells trouble
11:12:40 <syntaxfree> that Simonyi article that's on reddit is fascinating.
11:12:46 <mahogny> if I have say take 5 $ map f [1..], am I right in that the first elements will be throw away *without evaluating f at all*?
11:13:16 <mahogny> or is there some pitfall I should know about?
11:13:33 <LOKadin> What is template haskell?
11:13:43 <mahogny> LOKadin, metacoding for haskell, kind of
11:13:45 <notsmack> mahogny: you mean drop?
11:13:51 <mahogny> sorry yes
11:13:55 <dons> The hackathon is now just about over!
11:14:00 <dons> Happy lambdas everyone!
11:14:08 <dons> summaries appearing here: http://haskell.org/haskellwiki/Hac_2007/GroupPhoto#Summary
11:14:09 <lambdabot> Title: Hac 2007/GroupPhoto - HaskellWiki
11:14:21 <notsmack> it shouldn't get to f until it reaches the sixth element, correct
11:14:23 <LOKadin> coi.dons .ui(happiness)
11:14:40 <mahogny> ok. that pic contains a bunch of geeks :)
11:15:18 <glguy> ?lojban .ui
11:15:20 <lambdabot> Error: 501 Syntax error, illegal parameters
11:15:28 <glguy> ?lojban coi
11:15:29 <lambdabot> Error: 501 Syntax error, illegal parameters
11:15:39 <LOKadin> coi = hello
11:15:44 <LOKadin> .ui = I feel happiness
11:20:29 <mahogny> if I use lazyness to implement dynamic programming, is there something that can be done (without too much effort) to make sure I don't become a victim of compiler "optimization"? I guess it is not a problem in practice but it's good to know
11:20:50 <bos> a victim in what sense?
11:21:03 <mahogny> the compiler throws away the data and starts computing it again
11:21:34 <notsmack> no happs experts around?
11:22:32 <bos> mahogny: the compiler won't do that if your code doesn't do that.
11:23:51 <Cale> mahogny: Add enough type signatures to make sure that values are monomorphic when they're memoising things.
11:24:15 <mahogny> well, just giving an example: let x=f foo in (x,x), can anything be done to give hard guarantees in this case that it won't suddenly turn this into (f foo, f foo)? I don't see why it would but without a formal semantics :/
11:24:21 <Cale> mahogny: Other than that, lazy evaluation guarantees that values which came from the duplication of a function parameter are evaluated together.
11:25:10 <Cale> Just ensure that x is monomorphically typed.
11:25:25 <mahogny> hm. what is a monomorphic type?
11:25:34 <Cale> That is, not polymorphic.
11:25:41 <bos> all of the type parameters are concrete.
11:25:43 <SamB> mahogny: well, you can give a formal proof of correctness of the inliner maybe?
11:25:45 <mahogny> hm. alright
11:25:45 <Cale> If it's got a typeclass in its type, it'll be turned into a function which takes the dictionary as a parameter
11:26:01 <SamB> given an appropriate definition of correctness ;-)
11:26:02 <mahogny> SamB, I had hoped someone had already thought about it :)
11:26:07 <Cale> (and thus you'll lose sharing)
11:26:14 <SamB> mahogny: they all went crazy, actually
11:26:24 <SamB> at least, if you are referring to GHC's inliner ;-)
11:26:29 <Cale> also, the language changed
11:26:39 <Cale> At one point in history, Haskell had a formal semantics
11:26:44 <SamB> !
11:26:47 <mahogny> yup
11:27:06 <SamB> what I meant by "correctness" included things like "not duplicating work"
11:27:21 <mahogny> hm. so I take it just putting a :: at a proper location is as hard a guarantee I can get?
11:27:26 <SamB> and "not duplicating too much code"
11:27:46 <tibbe> where can I read up more on the emacs mode for haskell, key-chains and such
11:27:48 <SamB> (but maybe duplicating work if it can get rid of enough work in each instance to make it less work overall?)
11:27:50 <Cale> Well, if the compiler chooses to do something broken to your code, there's not much you can do about it but fix the compiler.
11:28:07 <SamB> maybe I should have said *nice*ness
11:28:19 <mahogny> or, *shrug*, code my own lazyness machinery :(
11:28:29 * mahogny rather fix the compiler then
11:28:44 <Cale> Basically though, you shouldn't have any problem with it :)
11:28:49 <SamB> you could try a {-# NOINLINE #-} pragma
11:28:54 <mahogny> yeah. just want to know the pitfalls :)
11:29:02 <SamB> if you really think it is a good idea!
11:29:35 <mahogny> if it takes less than a year to run the function then I should be on the safe side
11:30:09 <SamB> well, I currently think GHC goes rather on the safe side...
11:30:29 <mahogny> seems like that. there is a bug in the database regarding this and space leaks
11:31:02 <SamB> for instance, last I checked it was unwilling to duplicate computations which did not actually compute anything, only coerced things...
11:31:46 <mahogny> yeah; but this is also a source of space leaks. I find them even scarier :(
11:34:22 <Wikipedia-Gast60> I want to ask a question
11:36:07 <bos> Wikipedia-Gast60: shoot
11:36:18 <Wikipedia-Gast60> what should I ask?
11:37:12 <Jaak> bot
11:37:22 <Wikipedia-Gast60> what is bot
11:38:32 <bos> chanserv won't let me op myself.
11:39:33 <syntaxfree> hmm.
11:39:49 <syntaxfree> can you, possibly with some ghc extension, have parametrized monads?
11:39:59 <syntaxfree> i think the general question is if you can have parametrized instances of a type class.
11:40:30 <syntaxfree> let's say I have a type.
11:40:54 <syntaxfree> data Elephant = (Function, Storage)
11:41:08 <syntaxfree> as it is, Elephant can't be an instance of Monad.
11:41:26 <syntaxfree> but (f, "storage.txt") can.
11:41:54 <syntaxfree> uh, context.
11:42:30 <syntaxfree> the idea is that some values of a 1-adic function are stored in a file, and the function itself is only computed if the value can't be found on the file.
11:42:56 --- mode: ChanServ set +o Cale
11:43:20 --- mode: Cale set +b Wikipedia-Gast*!*@*
11:43:28 <syntaxfree> I know how to make one specific Elephant, tied to a function and a filename, an instance of Monad, following the monad laws and all.
11:43:29 --- mode: Cale set -o Cale
11:43:43 <syntaxfree> What I don't know is how I'm going to go about parametrizing it. Am I making any sense?
11:44:32 <glguy> Cale: *!i=JavaUser@* would probably be more effective
11:44:57 <glguy> Cale: that same mask was here trolling in the last week
11:44:59 <syntaxfree> one should admit it's funny, though.
11:45:11 <Cale> Oh, that too
11:45:19 <Cale> Wikipedia-Gast* is always a bot
11:45:24 --- mode: ChanServ set +o Cale
11:45:48 --- mode: Cale set +b *!i=JavaUser@*
11:45:52 --- mode: Cale set -o Cale
11:46:23 <Cale> Or we could just ban the Swiss ;)
11:46:36 <glguy> besides, we don't want anyone who considers themselves a "JavaUser"
11:47:47 <syntaxfree> haha.
11:47:59 <syntaxfree> :~
11:48:07 <syntaxfree> so, what about parametrized monads? :(
11:50:23 <syntaxfree> 5:09 PM  mahogny: if I have say take 5 $ map f [1..], am I right in that the first elements will be throw away *without evaluating f at all*?
11:51:04 <syntaxfree> btw, does this mean compilers transform (take n) . (map f) into (map f) . (take n)?
11:51:16 <syntaxfree> @free (take n) . (map f)
11:51:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:51:39 <syntaxfree> @free (\n f-> (take n) . (map f))
11:51:40 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:51:47 <syntaxfree> @free take
11:51:48 <lambdabot> $map f . take x = take x . $map f
11:52:05 <syntaxfree> @free drop
11:52:07 <lambdabot> $map f . drop x = drop x . $map f
11:52:46 <syntaxfree> @free takeWhile
11:52:48 <lambdabot> $map f . takeWhile (g . f) = takeWhile g . $map f
11:53:07 <syntaxfree> oh god. theorems for free!
11:53:32 <syntaxfree> @free liftM
11:53:34 <lambdabot> Expected variable or '.'
11:53:37 <syntaxfree> @free fmap
11:53:38 <lambdabot> Expected variable or '.'
11:53:59 <Botje> @free length
11:53:59 <syntaxfree> @free Control.Monad.liftM
11:54:01 <lambdabot> length = length . $map f
11:54:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:54:23 <syntaxfree> I wish I had some simple way of knowing what program transformatiion invariants GHC is aware of.
11:55:39 <syntaxfree> @free filter
11:55:40 <lambdabot> $map f . filter (g . f) = filter g . $map f
11:55:56 <Botje> what's with the $ ?
11:56:10 <syntaxfree> ah, it enforces fixity.
11:56:18 <Botje> oh
11:56:33 <syntaxfree> (map f) . filter (g . f)
11:56:49 <Botje> it's pretty confusing since i'm switching between this channel and #perl :)
11:56:54 <syntaxfree> hehe.
11:56:57 <syntaxfree> you don't know $ at all?
11:57:17 <syntaxfree> > 3 * 2 + 5
11:57:18 <lambdabot>  11
11:57:23 <syntaxfree> > 3 * (2 + 5)
11:57:25 <lambdabot>  21
11:57:28 <syntaxfree> > 3 * $ 2 + 5
11:57:29 <lambdabot>  Parse error
11:57:30 <Hunter_wow> is there no function to convert 2 :: Int to "Two" :: String ?? (not only type change but also the form)
11:57:42 <syntaxfree> > (*3) $ 2 + 5
11:57:43 <lambdabot>  21
11:57:54 <syntaxfree> bad example.
11:57:58 <Botje> I know about f $ x = f x
11:58:07 <syntaxfree> anyway, $ is like parentheseses  you don't have to close.
11:58:22 <Botje> but I thought filter g . $ map f was a syntax error
11:58:41 <syntaxfree> @pl filter g . $ map f
11:58:41 <lambdabot> (line 1, column 12):
11:58:41 <lambdabot> unexpected "$"
11:58:41 <lambdabot> expecting space or simple term
11:58:42 <sjanssen> Botje: yes, that is a syntax error
11:58:54 <syntaxfree> of course. same reason the above failed.
11:58:57 <syntaxfree> (.) is an infix operator.
11:59:07 <syntaxfree> @pl ((filter g).) $ map f
11:59:07 <lambdabot> filter g . map f
11:59:08 <norpan> > let convert 2 = "Two" in convert 2
11:59:09 <lambdabot>  "Two"
11:59:10 <sjanssen> syntaxfee: don't trust @pl's parser -- it isn't a real Haskell parser
11:59:25 <syntaxfree> sjanssen: what can I use to probe for parse errors?
11:59:29 <norpan> the rest is left as an exercise
11:59:40 <sjanssen> syntaxfree: @type would probably work
11:59:47 <syntaxfree> oh, true.
11:59:48 <bos> @hoogle \x->put (show x) >> put x
11:59:49 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\x->put (s'
11:59:53 <sjanssen> syntaxfree: undo/redo also
11:59:55 <Hunter_wow> let convert 3
11:59:56 <syntaxfree> @type ((filter g).) $ map f
11:59:57 <lambdabot> Not in scope: `g'
11:59:57 <lambdabot>  
11:59:57 <lambdabot> <interactive>:1:20: Not in scope: `f'
12:00:03 <bos> @pl \x->put (show x) >> put x
12:00:03 <lambdabot> ap ((>>) . put . show) put
12:00:05 <syntaxfree> that's not helfpul.
12:00:15 <Hunter_wow> >let convert 3
12:00:36 <syntaxfree> I just want to test for syntax, not for variables in scope.
12:01:00 <syntaxfree> @redo ((filter g).) $ map f
12:01:00 <lambdabot> ((filter g) .) $ map f
12:01:14 <syntaxfree> @redo 2 * $ 3 + 5
12:01:14 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}) "Parse error"
12:01:16 <glguy> ?unpl ((filter g) .) $ map f
12:01:17 <lambdabot> (\ h -> filter g (map f h))
12:01:18 <syntaxfree> good.
12:01:38 <sjanssen> any OS X + Emacs users around?  Which emacs distribution should I try?
12:01:45 <glguy> gvim
12:01:55 <glguy> sjanssen: Apple distributes one
12:01:56 <syntaxfree> there's Aquamacs.
12:01:59 <glguy> sjanssen: on their website
12:01:59 <syntaxfree> Gvim on OS X sucks.
12:02:09 <glguy> syntaxfree on OS X sucks!
12:02:10 <Jaak> @free it does?
12:02:11 <lambdabot> Extra stuff at end of line
12:02:15 <Jaak> *-@free
12:02:22 <sjanssen> yes, Vim.app is somewhat sucky
12:02:25 <syntaxfree> sjanssen: Hmm. Don't you have console-mode  emacs already?
12:02:34 <bos> sjanssen: http://emacs-app.sourceforge.net/
12:02:36 <lambdabot> Title: Emacs.app: NeXT/OpenStep Emacs for GNUstep and OS X
12:02:41 <glguy> what complaints did you guys have about it? I've been using it without much fuss
12:02:41 <pejo> sjanssen, I'm using 22.0.50.1 built on ww5pt109.bkc.ritsumei.ac.jp. I no longer have any idea where I got it from, but it handles my meta-key just fine, for example.
12:02:47 <Jaak> i guess i'd be using textmate anyways
12:02:53 <syntaxfree> sjanssen: there's also aquamacs. Do you want GUI-mode or console-mode emacs anyway?
12:03:00 <sjanssen> glguy: usually I'm a vi guy, but I want to try emacs+viper (the Vi emulation)
12:03:04 <syntaxfree> Mingus:~ syntax$ which emacs
12:03:04 <syntaxfree> Mingus:~ syntax$
12:03:06 <sjanssen> syntaxfree: GUI
12:03:20 <syntaxfree>  /usr/bin/emacs.
12:03:23 <pejo> sjanssen, I'm fairly sure it was a .dmg though that I just dropped in my applications-folder.
12:03:23 <glguy> sjanssen: but I've heard multiple complaints about gvim on osx, what's wrong that I'm missing
12:03:25 <syntaxfree> oh, well. I have Aquamacs here.
12:03:34 * glguy gets his powerbook out
12:03:54 <bos> sjanssen: there's also http://homepage.mac.com/zenitani/emacs-e.html
12:03:55 <lambdabot> Title: Carbon Emacs Package
12:04:05 <bos> those are the only two real contenders.
12:04:20 <syntaxfree> @google aquamacs
12:04:22 <lambdabot> http://aquamacs.org/
12:04:22 <lambdabot> Title: Aquamacs: Emacs for Mac OS X
12:04:24 <sjanssen> glguy: to edit several documents, you have to fork several copies of vim
12:04:28 <syntaxfree> how isn't that a real contender?
12:04:37 <syntaxfree> vim.app has bad redraw errors.
12:04:48 <sjanssen> glguy: and what syntaxfree said
12:05:12 <glguy> Hmm, I didn't notice the redraws, and use tabbed more
12:05:14 <glguy> mode*
12:05:17 <glguy> for multiple documents
12:05:22 <sjanssen> bos: I found those two.  But you prefer Emacs.app?
12:05:25 <syntaxfree> tabbed mode is a recent addition, yes.
12:05:45 <syntaxfree> I end up going back to subethaedit.
12:06:12 <syntaxfree> yay!
12:06:13 <syntaxfree> http://www.google.com/codejamlatinamerica/
12:06:13 <lambdabot> Title: Google Code Jam Latin America
12:06:15 <syntaxfree> now I'm in!
12:06:28 <syntaxfree> The competition is available in five programming languages - Java, C++, C#, VB.NET and Python.
12:06:28 <syntaxfree> :(
12:06:35 <sjanssen> bos: do you have any comments on Aquamacs?
12:06:44 <syntaxfree> gonna have to learn some python I guess.
12:07:54 <bos> sjanssen: haven't tried it, alas
12:08:12 <psnl> sjanssen: seems like a normal emacs for me
12:08:30 * syntaxfree can make no sense of emacsd.
12:08:34 <Saizan> if you have an emacs open but you are in the standard shell, is there a way to open a file in your emacs from there?
12:08:34 <glguy> does emacs on OS x support having multiple windows open?
12:08:35 <bos> aquamacs is considerably less actively developed than emacs.app or cocoa emacs.
12:08:52 <bos> Saizan: gnuclient or emacsclient
12:09:02 <pejo> glguy, you mean the one in /usr/bin?
12:09:25 <glguy> pejo: the emacs.app I downloaded from apple.com
12:09:27 <syntaxfree> I don't know about american shirt sizes.
12:09:57 <syntaxfree> I'm 169cm tall, about 65 kilograms.
12:09:57 <jethr0> > drop 1 $ map (+1) (undefined:[1..3])
12:09:59 <lambdabot>  [2,3,4]
12:10:04 <syntaxfree> do I want medium or large?
12:10:05 <sjanssen> glguy: Emacs.app does, at least
12:10:08 <syntaxfree> I'm guessing I don't want small.
12:10:22 <glguy> syntaxfree: Our shirts come in X*-Large
12:10:40 <lisppaste2> ClaudiusMaximus pasted "livecoding opengl in Haskell instead of Scheme?" at http://paste.lisp.org/display/35026
12:10:56 <syntaxfree> yes. there's small, medium, large, xlarge and xxlarge.
12:11:07 <syntaxfree> I'm trying to choose between large and medium.
12:11:14 <syntaxfree> maybe I should ask #wikipedia or something.
12:11:31 <glguy> syntaxfree: how tall are you
12:11:50 <syntaxfree> 169cm.
12:12:09 <glguy> <converting>
12:12:19 <syntaxfree> @google 169cm in inches
12:12:21 <lambdabot> 169 centimeters = 66.5354331 inches
12:12:22 <glguy> about 5 6"?
12:12:26 <glguy> ok
12:12:32 <syntaxfree> @google 66 inches in feet
12:12:32 <sjanssen> bleh!  Aquamacs default font isn't monospace!
12:12:33 <lambdabot> 66 inches = 5.5 feet
12:12:39 <glguy> I'm 5 9" and pretty skinny and I were a large
12:12:48 <syntaxfree> @google 65 kilograms in pounds
12:12:49 <lambdabot> 65 kilograms = 143.30047 pounds
12:12:51 <glguy> medium shirts are tight on me
12:13:04 <glguy> I'm 135lbs
12:13:18 <glguy> so if you are deciding between med and large, go large
12:13:46 <glguy> ?google large american in european
12:13:48 <lambdabot> http://people-press.org/reports/display.php3?ReportID=206
12:13:48 <lambdabot> Title: Summary of Findings: A Year After Iraq War
12:13:49 <glguy> (-;
12:13:52 <Cale> @google one foot in inches
12:13:55 <lambdabot> http://en.wikipedia.org/wiki/Foot_(unit_of_length)
12:13:55 <lambdabot> Title: Foot (unit of length) - Wikipedia, the free encyclopedia
12:13:59 <Cale> @google 1 foot in inches
12:14:00 <lambdabot> 1 foot = 12 inches
12:14:19 <SamB> oh, nice ;-)
12:14:22 <SamB> how does that work?
12:14:30 <glguy> google calculator
12:14:40 <glguy> ?google 1 dollar in euros
12:14:40 <sjanssen> @google speed of light in cubits per fortnight
12:14:41 <lambdabot> 1 U.S. dollar = 0.772797527 Euros
12:14:42 <lambdabot> the speed of light = 7.931517 x 10^14 cubits per fortnight
12:15:14 <glguy> ?google 1 haskell line of code in c
12:15:18 <lambdabot> http://lambda-the-ultimate.org/node/view/608
12:15:18 <lambdabot> Title: expressivity of "idiomatic C++" | Lambda the Ultimate
12:15:25 <sjanssen> haha
12:15:36 <SamB> no, not C++
12:15:54 <SamB> @karma C
12:15:55 <lambdabot> C has a karma of 2
12:15:59 <SamB> @karma c
12:15:59 <lambdabot> c has a karma of 18
12:16:11 <Cale> @google 1 square parsec in acres
12:16:12 <lambdabot> 1 (square Parsec) = 2.35279476 x 10^29 acres
12:16:12 <glguy> ?google half a cup in microlitters
12:16:15 <lambdabot> http://www.microscopy.com/cgi-bin/ReadPrintEmailHTML.pl?filename=9902.txt
12:16:15 <lambdabot> Title: Microscopy ListServer Archive Output
12:16:27 <glguy> ?google half a cup in microliters
12:16:28 <tibbe> I want to try TopCoder using haskell!
12:16:28 <lambdabot> half (1 US cup) = 118,294.119 microliters
12:16:36 <glguy> tibbe: it's supported now?
12:16:50 <Cale> @google pi squared over six factorial
12:16:52 <lambdabot> http://de.wikipedia.org/wiki/Benutzer:Berlin-Jurist/Spielwiese
12:16:57 <Cale> @google pi squared over 6 factorial
12:16:58 <lambdabot> (pi squared) over (6 factorial) = 0.0137077839
12:17:00 <tibbe> glguy, no, C++ C# and java
12:17:04 <Cale> @google (pi squared over 6) factorial
12:17:05 <lambdabot> ((pi squared) over 6) factorial = 1.47938805
12:17:09 <SamB> glguy: I meant how does lambdabot get the calculator results?
12:17:12 <glguy> tibbe: ah (when I used to participate I used C#)
12:17:16 <tibbe> I use neither of those in my spare time
12:17:21 <SamB> when I wrote that module, it didn't do that!
12:17:22 <glguy> SamB: try typing this stuff into google search
12:17:24 <syntaxfree> so, I'm going to enter Google's Code Jam.
12:17:36 <Cale> @version
12:17:36 <lambdabot> lambdabot 4p457, GHC 6.5 (OpenBSD i386)
12:17:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:17:44 <glguy> ?karma
12:17:45 <lambdabot> You have a karma of 17
12:17:46 <SamB> are you telling me it now has to do a full search?
12:17:55 <syntaxfree> What bad surprises should I get when facing python, as someone who knows only scheme and haskell?
12:17:56 <SamB> not just "I'm feeling lucky"?
12:18:01 <Cale> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Search.hs
12:18:13 <jethr0> feeling lucky should suffice
12:18:13 <Cale> horrible regex nonsense
12:18:18 <syntaxfree> @google 100 cm in pounds
12:18:20 <lambdabot> http://www.briess.com/about/packagingoptions.shtml
12:18:21 <lambdabot> Title: Briess Malt & Ingredients Company: About Briess
12:18:22 * SamB reboots
12:19:03 <Cale> @google 1000 kg in hundredweight
12:19:05 <lambdabot> http://www.cs.tut.fi/~jkorpela/metric.html
12:19:06 <lambdabot> Title: Go metric!
12:19:09 <Cale> heh
12:19:13 <jethr0> syntaxfree: 100 cm ~= 5.222 pounds :)
12:19:25 <syntaxfree> hehe.
12:19:33 <syntaxfree> @google 1 dollar in BRL
12:19:34 <lambdabot> 1 U.S. dollar = 2.1456 Brazil reais
12:19:40 <syntaxfree> @google 1 euro in BRL
12:19:41 <lambdabot> 1 Euro = 2.7764064 Brazil reais
12:19:43 <Cale> @google 1 dollar in baht
12:19:44 <lambdabot> 1 U.S. dollar = 35.9606 Thai baht
12:19:52 <jethr0> @google 1 u.s. dollar in linden dollars
12:19:56 <lambdabot> http://www.businessweek.com/magazine/content/06_18/b3982001.htm
12:19:56 <lambdabot> Title: My Virtual Life
12:19:59 <jethr0> ohh
12:20:41 <Cale> @google radius of earth
12:20:43 <lambdabot> http://en.wikipedia.org/wiki/Earth_radius
12:20:43 <lambdabot> Title: Earth radius - Wikipedia, the free encyclopedia
12:20:44 <Saizan> syntaxfree: aside from syntax python takes a lot from lisp, and there's a module called something like functionaltools to help you use the fucntional side of the language
12:20:51 <Cale> @google 1 * radius of earth
12:20:52 <lambdabot> 1 * radius of Earth = 6,378.1 kilometers
12:21:16 <syntaxfree> Saizan: I'm not sure what python modules they provide.
12:21:17 <maskd> @google the answer to life, the universe and everything
12:21:19 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
12:21:19 <lambdabot> Title: The Answer to Life, the Universe, and Everything - Wikipedia, the free encyclope ...
12:21:38 <syntaxfree> @google 42 in moles
12:21:39 <Cale> @google four thirds pi (1 * radius of earth) cubed
12:21:39 <lambdabot> 42 = 6.97426323 x 10^-23 moles
12:21:40 <glguy> ?google the answer to life the universe and everything
12:21:45 <lambdabot> http://answers.yahoo.ca/question/index?qid=20061202164015AAeGW8F
12:21:46 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
12:21:46 <lambdabot> Title: The Answer to Life, the Universe, and Everything - Wikipedia, the free encyclope ...
12:21:59 <glguy> when you google for the answer to life the universe and everything    manually, :the answer to life the universe and everything = 42
12:22:04 <Cale> @google 1 * four thirds pi radius of earth cubed
12:22:06 <lambdabot> 1 * (four thirds) * pi * (radius of Earth cubed) = 1.08683241 x 10^21 m^3
12:22:22 <syntaxfree> @google 1 mole in units
12:22:23 <lambdabot> 1 mole = 6.0221415 x 10^23 units
12:22:28 <jethr0> @google 1 * (the answer to life the universe and everything)
12:22:29 <lambdabot> 1 * the answer to life the universe and everything = 42
12:22:33 <glguy> ?google 1 day in dog years
12:22:35 <lambdabot> http://www.atomfilms.com/film/dog_years.jsp
12:22:35 <lambdabot> Title: AtomFilms: Dog Years
12:22:35 <syntaxfree> @google 7 x 10^-23 in moles
12:22:36 <lambdabot> 7 x (10^(-23)) = 1.1623772 x 10^-46 moles
12:22:45 <syntaxfree> uh,
12:22:51 <Cale> @google 1 * four pi radius of earth square
12:22:52 <lambdabot> https://matcmadison.edu/is/as/math/mathclub/ProblemSets/V01/V01S.html
12:22:53 <syntaxfree> @google 7 x (10^23) in moles
12:22:54 <Cale> @google 1 * four pi radius of earth squared
12:22:54 <lambdabot> 7 x (10^23) = 1.1623772 moles
12:22:57 <lambdabot> http://www.filesharingtalk.com/vb3/archive/index.php/t-1256.html
12:22:57 <lambdabot> Title: The Imperceptibility Of Santa Claus [Archive] - FileSharing Talk
12:22:57 <glguy> ?google 1 millioleg in dollars
12:22:59 <lambdabot> No Result Found.
12:23:05 <glguy> ?google 1 millioleg in Joules
12:23:07 <lambdabot> No Result Found.
12:23:13 <Saizan> syntaxfree: ah, sure, well you still have a lot, the main difference it's the typesystem, scheme is static no?
12:23:22 <syntaxfree> scheme is dynamic.
12:23:22 <jethr0> 1 millioleg in dollars = unaffordable
12:24:00 <Cale> Saizan: Python doesn't really properly encourage functional programming though.
12:24:03 <SamB_XP_> @google 1 joule in dollars
12:24:05 <lambdabot> http://www.colorado.edu/physics/phys3070/phys3070_sp06/capa2.pdf
12:24:05 <syntaxfree> @google haskell in python
12:24:07 <lambdabot> http://wiki.python.org/moin/PythonVsHaskell
12:24:08 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
12:24:25 <jethr0> python's "dictator" even discourages it
12:24:26 <Cale> If you try to write programs in a functional style in python, you'll find that it's a bit awkward.
12:24:32 <syntaxfree> maybe I should write a Haskell-to-Python compiler or something.
12:24:37 <SamB> Cale: not as bad as in C!
12:24:47 <Cale> SamB: sure
12:25:05 <Cale> But it specifically lacks features necessary for functional programming. For instance tail recursion optimisation isn't there.
12:25:07 <syntaxfree> otoh, if they allow C, I could just write stuff in Haskell and compile to C!
12:25:08 <syntaxfree> muhahahaah
12:25:10 <glguy> anyone know a program that can wrap another program to trick it into using a proxy server?
12:25:25 <syntaxfree> browseatwork?
12:25:31 <syntaxfree> nah, forget about it.
12:25:31 <bos> dons: ping
12:25:41 <Cale> And lambdas are a bit awkward and have confusing scoping issues.
12:25:59 <syntaxfree> so basically I have to know Oo to do anything real in python?
12:26:00 <bos> glguy: you want a socks LD_PRELOAD thingy.
12:26:17 <Saizan> Cale, well you have many good "functional" aspect though, like first class functions and closures, and optimization doesn't count much in one of the slower languanges on the market :D
12:26:21 <Cale> syntaxfree: well, you at least need to know procedural programming
12:26:29 <glguy> my plan is to rsync over an ssh-tunnel
12:26:34 <glguy> since rsync is blocked here
12:26:38 <syntaxfree> I know 8-year-old basic.
12:26:39 <jethr0> syntaxfree: not necessarily, i'd think. python's OO is also a bit weird
12:26:45 <syntaxfree> I mean, I know the Basic I knew as an 8-year-old.
12:26:48 * glguy discovers tsocks
12:26:50 <bos> rsync already tunnels over ssh.
12:26:50 <Cale> Saizan: that's not the issue, the issue is that without tail-recursion optimisation, you *will* blow the stack
12:27:01 <Cale> (if you try to write loops recursively)
12:27:09 <glguy> bos: I'm connecting to a non-ssh rsync server
12:27:15 <bos> glguy: ah.
12:27:18 <glguy> i'm going to portforward out to my remote machine
12:27:22 <glguy> and then rsync from there
12:27:28 <bos> then use ssh -D with tsocks.
12:27:36 <syntaxfree> Cale: I could rewrite map, filter, etc. in terms of loops.
12:27:42 <syntaxfree> I've done it in GNU R.
12:27:43 <Saizan> Cale: you have the for .. in ..: which is a map though
12:27:44 <Cale> syntaxfree: certainly
12:27:44 <syntaxfree> Oh, I know R.
12:27:49 <syntaxfree> R is procedural + copy-paste oriented.
12:28:00 <bos> python already has map, filter, reduce, etc.
12:28:00 <jethr0> syntaxfree: map, filter, etc are already there on top of iterators in itertools
12:28:06 <Cale> Yeah
12:28:12 <jethr0> a bit awkward though
12:28:41 <Saizan> there's no (.) iirc :)
12:28:55 <mauke> python doesn't let you do arbitrary stuff in expressions; instead, you have to put it in a named block ("function") and call it
12:28:58 <syntaxfree> I wonder how hard the Code Jam problems are.
12:29:33 <jethr0> it's been a while since i've used python, but functional programming is definitely not its forte (not least due to design decisions)
12:29:45 <syntaxfree> (I wonder how used I've gotten to lazy evaluation and such by now)
12:30:00 <SamB> mauke: haskell doesn't really, either!
12:30:14 <mauke> SamB: how so?
12:30:17 <SamB> mauke: I mean, you have to at least write well-typed code
12:30:28 <mauke> duh
12:30:31 <kilimanjaro> mauke: Partial application isn't arbitrary, although it may seem so.
12:30:35 * jethr0 thinks he would likely choose ruby over python...
12:30:44 <SamB> and, um, that means no side-effects in a map
12:30:45 <syntaxfree> haskell doesn't let you do arbitrary stuff in lambda expressions, of course.
12:30:46 <syntaxfree> looky.
12:30:54 <syntaxfree> > (\x -> find god) in x
12:30:54 <lambdabot>  Parse error
12:31:06 <syntaxfree> see?
12:31:06 <SamB> ?
12:31:12 <mauke> stop missing the point :(
12:31:17 <jethr0> and try to stay as far away from some perl nastinesses as possible. and also ruby is THE slowest language out there :)
12:31:20 <kilimanjaro> mauke: What is the point?
12:31:24 <emu> god is a free variable
12:31:32 <syntaxfree> jethr0: can't choose ruby.
12:31:39 <SamB> also, in is an out-of-place keyword
12:31:40 <jethr0> ohh :(
12:31:43 <reilly> ruby won't always be slow
12:31:48 <syntaxfree> allowed languages are c, c++, python and java.
12:31:59 <kilimanjaro> reilly: Right, because one day somebody will outdo it...
12:32:02 <mauke> kilimanjaro: python's lambda sucks because python distinguishes between expressions and statements, and you can't directly use statements in expressions
12:32:05 <syntaxfree> I just reckoned python was the closest to what I wanted.
12:32:20 <jethr0> my favourites (descending): python, java, c, c++ (depending on application of course)
12:32:29 <bos> python is a very nice language to program in.
12:32:34 <reilly> the ruby vm is essentially unoptimized
12:32:40 <SamB> syntaxfree: I think you reckoned right
12:32:44 <jethr0> but if you want type safety, python is a real bummer
12:32:57 <mauke> haskell and lisp just use expressions for everything, and perl can bridge the gap with sub {} or just do {}
12:33:00 <bos> python is perfectly type safe; it just all happens at runtime.
12:33:08 <SamB> jethr0: well, so are C, C++, and Java
12:33:13 <SamB> bos: no it isn't!
12:33:17 <syntaxfree> I don't want to learn 2345678905454263614536587643 keywords to write "Hello world".
12:33:22 <jethr0> bos: i meant static type safety (i.e. at compile-time)
12:33:23 <syntaxfree> Python's Hello World was the cleanest.
12:33:24 <SamB> not if you count AttributeErrors as type errors!
12:33:48 <syntaxfree> private sub function fucking public religious  int main () {  zzz. }
12:33:54 <Saizan> mauke: case .. of and if .. then .. else are not expressions (or am i missing the difference?)
12:34:18 <jethr0> un-found, simple errors in python can be a real nuissance. and reproducing a type checker in punit doesn't seem the best way to resolve that
12:34:25 <mauke> > 1 + (if True then 2 else 3) -- looks like an expression to me
12:34:27 <lambdabot>  3
12:34:32 <bos> jethr0: absolutely.
12:34:40 <reilly_> python is the bait-and-switch of recent programming languages
12:34:47 <bos> stupid type errors are the number 1 source of python bugs.
12:35:29 <jethr0> along with stupid typos
12:35:30 <kilimanjaro> Compiler errors are the number 1 source of Haskell bugs...
12:35:33 <Saizan> you just need a good unit test i suppose
12:35:35 <bos> i haven't seen anyone compare duck typing vs type classes. the latter give you most of the benefits of the former.
12:35:44 <jethr0> kilimanjaro: depends on your definition of "bug"
12:35:48 <SamB> #include <stdio.h> / int main() { printf("Hello, World!\n"); }
12:36:00 <SamB> count them... hmm, probably two keywords...
12:36:15 <SamB> and a special magic identifier
12:36:22 <bos> hmm, the fail function in the Get monad of Data.Binary has a bizarre circular definition.
12:36:30 <jethr0> including imports in comparisons is a bit over the top
12:36:35 <mauke> SamB: "int" and?
12:36:45 <SamB> mauke: I counted #include as a keyword
12:36:55 <bos> oh, it's failing in the State monad.
12:36:57 <jethr0> isn't that a preprocessor directive?
12:37:00 <mauke> it isn't, really
12:37:18 <SamB> well, it isn't what the spec calls a keyword
12:37:22 <Cale> bos: What is it? Mostly, I just ignore the fail function completely, as it's an abomination.
12:37:27 <SamB> but it is *key* and it is *like* a word
12:37:33 <jethr0> hehe
12:38:03 <bos> Cale: i haven't figured out what it's supposed to do. in practice, it results in hugs inflooping.
12:38:23 <bos> i want to throw an exception instead.
12:38:52 <bos> but i haven't gotten far enough in my haskell hacking to know how to throw an exception from the State monad, short of just calling "error"
12:39:09 <Cale> bos: basically the only case where it should show up is when you fail a pattern match on the left side of an <-
12:39:24 <bos> Cale: i see.
12:39:26 <Cale> The State monad doesn't have exceptions
12:39:31 <SamB> I figure that, in terms of work needed to learn, #include counts as a keyword
12:39:31 <bos> yes, i knopw.
12:39:40 <bos> so i need to call error?
12:39:46 <Cale> So fail is usually just implemented as something which crashes the program, yeah.
12:40:08 <mauke> it's two tokens
12:40:19 <Cale> (Unless it's caught, but catching errors thrown by error is usually tricky enough not to be worth the trouble.
12:40:20 <Cale> )
12:40:26 <bos> but i can catch error from inside the IO monad, right?
12:40:29 <Cale> yes
12:40:32 <Cale> technically
12:40:33 <bos> ok.
12:40:37 <bos> that's something.
12:40:59 <velco> Cale: what do you mean by tricky ? In std haskell98 ?
12:41:01 <Cale> If you really plan to throw errors, either return a Maybe value, or wrap your monad in an ErrorT
12:41:04 <bos> Cale: what i'm doing is building on Data.Binary and Typeable to give type-safe pickles.
12:41:20 <Cale> velco: It may even be impossible in Haskell 98, I don't remember.
12:41:41 <dmead> bonk
12:41:41 <Cale> It's tricky in current GHC, because you have to ensure that the error is actually evaluated inside the catch.
12:41:43 <bos> i'll have to put a bug in the ears of the Data.Binary hackers, then.
12:42:07 <Cale> Which involves careful use of Control.Exception.evaluate
12:42:08 <velco> Cale: oh? What could go wrong ?
12:42:21 <velco> hmm...
12:42:22 <Cale> You could return the error from the catch block without evaluating it.
12:42:31 <velco> ah, yes.
12:42:38 <Cale> This is especially true when you're returning some complex data structure.
12:43:00 <Cale> Errors can occur inside the structure, and those won't be caught unless you force the whole thing while in the catch block.
12:43:34 <Cale> This is why it's better just to use Maybe or Either
12:43:43 <velco> e.g. I have to use something like catchJust (errorCalls) (evaluate foo) (handle) ?
12:43:51 <Cale> yeah
12:44:12 <Cale> and if foo is something complicated, you may want to do more than that
12:44:36 <Cale> evaluate will only evaluate the thing to knowing the top-level constructor
12:45:17 <jethr0> Cale: but wouldn't the catchJust be taken along lazily?
12:45:22 <velco> i.e. I could get an evaluated [a, b, c] - but some of a, b,c may conatain errro calls ?
12:46:30 <Cale> jethr0: catchJust produces an IO action
12:46:40 <Cale> velco: yes
12:47:00 <jethr0> hmm
12:47:23 <Cale> It'll evaluate the thing to (:) someElt someTail where someElt and someTail may not have been evaluated yet.
12:47:25 <velco> is it possible to force an expression to be fully evaluated? seq maybe ?
12:47:43 <velco> i see.
12:47:44 <Cale> You can use a bunch of seqs over the structure to force it all.
12:48:01 <Cale> There are tools in Control.Parallel.Strategies for doing this.
12:48:56 <Cale> Though they can be a little confusing if you haven't seen them before, and are not as well maintained and documented as they ought to be.
12:49:07 <Cale> (The paper is not bad, but the Haddock is)
12:49:29 <velco> oh, not good ... I use a bunch of error calls when validatin certain input with he idea that froma certain point on everything will be well formed ...
12:49:33 <monochrom> talking about HXT?
12:49:42 <Cale> monochrom: just errors in general
12:50:00 <Cale> monochrom: In that case, I was referring to Control.Parallel.Strategies
12:50:08 <Cale> (just noticed when you came in)
12:50:39 <SamB> I still want to see a decent way to deal with errors *lazilly*
12:51:01 <Cale> SamB: in pure code or from IO?
12:51:14 <Cale> It would break referential transparency to allow catching errors in pure code.
12:51:28 <SamB> I don't necessarily mean that sort of error...
12:51:35 <SamB> in fact, I think I mean parse errors ;-)
12:51:39 <Cale> Oh, then use Either
12:51:46 <SamB> not lazy
12:51:52 <Cale> not lazy?
12:52:14 <pitecus> what's the minimum Double?
12:52:19 <SamB> you have to parse the whole thing before you can find out whether it was a Left or a Right
12:52:44 <velco> SamB: isn't is supposed on the first Left to bail out ?
12:52:44 <\z> Hi everyone.  I've got a typing question.
12:53:08 <SamB> hmm, okay, so you have to parse the whole thing to find out you have a Right
12:53:10 <glguy> asdf and jkl;
12:53:12 <\z> is it possible to write a function like foo :: (Some a) => String -> a
12:53:27 <mauke> :t read
12:53:29 <lambdabot> forall a. (Read a) => String -> a
12:53:33 <Cale> pitecus: minimum in which sense?
12:53:35 <\z> or is it necessary to construct that as foo :: String -> Something, where something is an algebraic datatype?
12:53:42 <Cale> pitecus: there's a -Inf value in the Double type
12:53:46 <velco> SamB: yes, but I guess this is unavoidable - how can yuo figure out if it's right without examining the whole?
12:53:53 <pitecus> Cale, that one, thanks
12:53:56 <glguy> :t Data.Map.lookup
12:53:58 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
12:54:02 <SamB> I won't argue the failing case -- it is pointless to talk about that when the success case has trouble
12:54:03 <Cale> To create it, do (-1/0)
12:54:08 <Cale> > (-1/0)
12:54:09 <lambdabot>  -Infinity
12:54:13 <\z> mauke: Yes, I know about read, but I want to write a function that returns something that's a member of a specific typeclass
12:54:15 <glguy> \z: The return type is allowed to be parameterized
12:54:30 <glguy> \z: he showed you that example because Read is a typeclass
12:54:44 <\z> Hm...
12:54:51 <\z> Maybe I need to rewrite that function.
12:54:54 <Cale> \z: all you have to do is define something in terms of the operations of whatever typeclass, and it'll be done
12:54:58 <SamB> velco: well, I want to see a way to deal with errors so that you don't have to find out whether (for example) parsing was successful *before* you start to use the results
12:55:00 <glguy> lisppaste2: url
12:55:00 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:55:03 <\z> There was a case statement in there, and it bound to the first concrete type in that typeclass
12:55:18 <Cale> case will certainly destroy any polymorphism
12:55:18 <\z> which implied that I couldn't have one function return one of two possible types
12:55:28 <\z> Ah.  So that's the error.  That makes sense now.
12:55:40 <xic> Cale: do you know a good way to do logging?
12:55:44 <velco> SamB: I see.
12:55:49 <glguy> hslogger is used by missingh
12:55:50 <Cale> xic: The writer monad.
12:56:16 <Cale> Well, really, it depends on what the logging is for.
12:56:17 <xic> can the writer monad write to a file?
12:56:28 <xic> logging for a webserver
12:56:42 <SamB> See, I think it should be possible to do things with, say, MAME's game list file without reading the whole file first...
12:56:55 <Cale> Then you may want to do the logging explicitly in the IO monad.
12:57:01 <xic> Cale: right
12:57:04 <SamB> probably because it is a really big file
12:57:10 <Cale> Chances are when you form connections, you'll be in the IO monad anyway.
12:57:15 <glguy> ?where hslogger
12:57:15 <lambdabot> I know nothing about hslogger.
12:57:34 <SamB> though it would help if XML libraries used Data.ByteString, and interned tag and attribute names
12:57:37 <Cale> SamB: yeah, but XML sort of prevents that.
12:57:45 <glguy> ?where+ hslogger http://software.complete.org/hslogger
12:57:46 <lambdabot> Done.
12:59:26 <Cale> You could parse the XML lazily and use an exception of death if things don't work out in the end. It's just that current libraries for parsing XML try to validate it at least as far as checking where tags close and such in order to give you a nice tree, rather than some list of elements.
13:00:04 * glguy wonders if you could wrap the Parsec monad with a ContT...
13:00:25 <glguy> Cale: doesn't HXT support not trying to validate?
13:00:45 <Cale> Well, yeah, but I mean a different kind of validation here.
13:00:55 <mahogny> glguy, didn't someone code something like a parsec transformer? maybe useful, dunno
13:00:56 <\z> How hard would it be to write a parser monad that returns IO [a], and uses unsafeInterleaveIO to continue parsing a string into a stream of tokens?
13:00:57 <Cale> It allows you not to validate the structure against a DTD
13:01:01 <\z> Or is that even a sane approach?
13:01:18 <Cale> \z: Why IO?
13:01:38 <\z> Cale: Good point.
13:02:10 <xic> glguy: hslogger looks cool
13:02:31 <glguy> ?where missingh
13:02:31 <lambdabot> http://quux.org/devel/missingh
13:02:38 <glguy> ?where+ missingh http://software.complete.org/missingh
13:02:38 <lambdabot> Done.
13:02:40 <glguy> ?where missingh
13:02:41 <lambdabot> http://software.complete.org/missingh
13:02:48 <bos> @paste
13:02:48 <lambdabot> http://paste.lisp.org/new/haskell
13:03:14 <lisppaste2> bos pasted "fails to type check" at http://paste.lisp.org/display/35032
13:03:41 <bos> i don't understand what i'm doing wrong above. could someone take a look, please?
13:03:50 <glguy> what's the error?
13:04:03 <Cale> bos: maybe you want something like   instance (Typeable a, Binary a) => Pickleable (Pickle a) where
13:04:16 <velco> types are instances
13:04:19 <Cale> or whatever that Pickle type is
13:04:20 <velco> not classes
13:04:53 <Cale> You're saying that any type in the Typeable and Binary classes will be made an instance of Pickleable by these definitions
13:04:54 <velco> err, nevermind
13:04:56 * velco stfus
13:04:58 <Cale> But then you pattern match
13:05:16 <glguy> shuts the f**k ups?]
13:05:19 <Cale> er, oh
13:05:30 <Cale> Sorry, I misread that
13:05:34 <velco> glguy: stfu being a verb ...
13:05:50 <bos> Cale: what you say makes sense.
13:05:52 <Cale> But still, you can't implement something of type Pickle -> a
13:06:02 <Cale> which is fully polymorphic
13:06:15 <Cale> well, you could, but it would have to return an error
13:06:15 <bos> so this is the monomorphism restriction raising its head again?
13:06:17 <Cale> no
13:06:33 <bos> hmm, ok, i don't get it.
13:06:44 <glguy> the only thing that inhabits all types is bottom
13:06:56 <Cale> oh hang on
13:06:58 <glguy> but
13:07:07 <Saizan> but he has a context there
13:07:08 <Cale> we have Typeable and Binary
13:07:12 <glguy> :)
13:07:32 <Cale> However, this class won't be allowed without undecidable instances
13:07:44 <Cale> this instance*
13:07:46 <Cale> because it lacks a type constructor
13:07:48 <lisppaste2> \z pasted "How do you implement polymorphic return types?" at http://paste.lisp.org/display/35033
13:08:05 <Cale> try compiling with -fallow-undecidable-instances
13:08:39 <bos> Cale: it still pukes, same error.
13:08:42 <glguy> :type fromIntegral
13:08:48 <glguy> :t fromIntegral
13:08:50 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:08:59 <Cale> bos: which error?
13:09:23 <glguy> :t toIntegral
13:09:23 <lisppaste2> bos annotated #35032 with "ghc error" at http://paste.lisp.org/display/35032#1
13:09:25 <lambdabot> Not in scope: `toIntegral'
13:09:41 <glguy> \z: I think you need to add a method to your typeclass
13:09:49 <glguy> \z: like "fromIntegral" is for Num
13:09:50 <Cale> bos: maybe add -fglasgow-exts as well?
13:10:15 <\z> glguy: I don't think so.
13:10:21 <Saizan> \z: to have a function (SomeClass a) => Sometype -> a  you need a function of this type in the typeclass i suspect
13:10:32 <\z> glguy: The int vs. Float in this class was just shorthand.
13:10:38 <Cale> \z: what you're trying to do is impossible.
13:10:50 <glguy> without existential types?
13:10:54 <Cale> yeah
13:10:56 <\z> The code I was working on used two different datatypes, both of which belonged to the same typeclass
13:11:00 <Cale> without existential types
13:11:11 <lisppaste2> bos annotated #35032 with "new error" at http://paste.lisp.org/display/35032#2
13:11:16 <glguy> \z: but that typeclass says: forall a . Scalar a =>  Bool -> a
13:11:23 <glguy> \z: that means "pick one a"
13:11:31 <glguy> and it must be an instance of Scalar
13:11:50 <bos> Cale: it looks like i don't have a way to get the compiler to DWIM.
13:11:57 <Cale> bos: It says you left out the definition of pickle for that instance
13:12:03 <\z> Right.  And I thought I declared ScalarInt and ScalarFloat to be instances of Scalar
13:12:08 <glguy> vs:  Bool -> (forall a. Scalar a => a)
13:12:20 <glguy> \z: different instances, you are trying to pick two, not one
13:12:44 <bos> Cale: hmm, the code seems to behave if i leave out those instance declarations.
13:12:44 <\z> So I need existential types then.  Hm...
13:12:51 <\z> Is this something that I could solve with generics?
13:13:04 <Cale> A type like  (Scalar a) => Bool -> a  means that *no matter what type of Scalar I want*, the code can produce one, given a Bool.
13:13:05 <glguy> \z: you could add a method to your typeclass
13:13:06 <\z> have one function return one of two possible types belonging to a single typeclass?
13:13:21 <Cale> That is, it's
13:13:31 <Cale> forall a. (Scalar a) => Bool -> a
13:13:33 <Cale> and not
13:13:33 <bos> Cale: should i be worried that i'm having to use -fglasgow-exts -fallow-undesirable-instances?
13:13:38 <bos> er, undecidable
13:13:44 <Cale> exists a. (Scalar a) => Bool -> a
13:13:48 <Cale> bos: a little bit
13:13:57 <Cale> undecidable
13:14:02 <Cale> not undesirable
13:14:08 <velco> heh
13:14:17 <bos> i take it this means that any code that uses this module would need to use the same flags?
13:14:25 <Cale> bos: I don't think so
13:15:16 <Cale> I think that this should be okay, but it does mean that anyone who tries to write their own instance of your class will quickly run into overlappinng instance problems.
13:15:30 <bos> oh?
13:15:31 <xic> glguy: is ConfigFile any good?
13:16:07 <lisppaste2> glguy annotated #35033 with "for \z" at http://paste.lisp.org/display/35033#1
13:16:10 <Cale> Well, the compiler generally works out which instance to use by looking at the type constructors involved.
13:16:13 <glguy> xic: couldn't tell you :)
13:17:37 <glguy> \z: in that annotation I showed you, f :: E -> [Char]
13:17:44 <\z> glguy: thanks.
13:18:00 <\z> I figured I needed to wrap the various instances in something
13:18:37 <\z> Since I couldn't get the Bool -> a to work, I just wrapped everything into an algebraic type and went with that
13:18:39 <lisppaste2> Cale annotated #35033 with "another similar way" at http://paste.lisp.org/display/35033#2
13:18:43 <\z> the only problem is that I lost all polymorphism
13:19:00 <\z> every method I wanted to add on that typeclass became a dispatch function, which kinda sucked.
13:19:56 <Cale> \z: The usual way to solve this is by packaging up operations rather than explicit data values
13:19:57 <bakert> Anyone got a suggestion for a library for a very simple web app?
13:20:00 <glguy> Cale: I didn't know about making that an instance of Show, but that's a good class
13:20:07 <Cale> \z: but existential types might be kinder to you
13:20:25 <glguy> bakert: have you played with HAppS yet?
13:20:34 <\z> Cale: I think that's what I was trying to do, but I couldn't make it work.  :-)
13:20:48 <bakert> glguy, yes.  it made me quite unhappy ;(  i don't think i'm at that level yet!
13:21:05 <Cale> \z: that is, make a datatype with one constructor that has functions for the abstract interface to the data you're working with
13:21:07 <\z> I was trying to create a typeclass with seven methods or so, and one function that would return one of three instances of that typeclass
13:21:07 <bakert> glguy, i did get my app working but there was a lot of magic there that i didn't get.
13:21:20 <Cale> \z: and then pass *those* around instead of the actual values
13:21:36 <\z> And not use typeclasses?
13:21:40 <Cale> Typeclass instances are not first class.
13:21:57 <\z> Aha.  That would explain a lot.  :-)
13:22:04 <Cale> Existential types essentially make them first class.
13:22:24 <Cale> By letting you say "this value is of some type which is a member of these classes"
13:22:40 <xic> existential types are pretty hard to find a use for, from what i understand
13:22:41 <Cale> rather than "this value could be *any* member of this typeclass"
13:22:43 <bakert> glguy, you don't know a good intro to HAppS i suppose?
13:23:03 <\z> OK.  So if I created a typeclass, then wrapped that with an existential type, I  could get polymorphic dispatch for free?
13:23:15 <Cale> xic: Well, not hard to find a use for, that's essentially what OO programming is. It's just that they're always avoidable.
13:23:43 <Cale> \z: well, yes, but you should be aware that you can *never* extract the original values
13:24:12 <monochrom> "data Showable = Showable (forall a. Show a => a)"  is a common example.
13:24:16 <Cale> Once you apply the existential constructor, the original type of the value is *gone*
13:24:21 <Cale> monochrom: see my paste :)
13:24:39 <monochrom> Darn.  Next time I'll try something else, like Monadable.
13:24:44 <Cale> and that means that you can only interact with the value through the members of your typeclass.
13:25:00 <xic> Cale: right. i was pointed to existential types when i wanted to have a list of [Shape], and the ability to rotate all the shapes, using each shape's custom rotation function
13:25:10 <Cale> xic: right
13:25:13 <\z> I think that's what I want to do.
13:25:21 <Cale> Types are like permissions to use values in particular ways.
13:25:28 <\z> For example, suppose I have a package.  It could be a zip file, a tarball, or a xar file.
13:25:36 <Cale> Having an ordinary type gives you permissions to do things like pattern matching.
13:25:50 <\z> the only things I want to do are get a list of contents, and get the content of a single entry in that list
13:26:01 <Cale> With an existential type, you throw away your permission to do anything but apply members of a given set of classes.
13:26:13 <Cale> \z: right
13:26:30 <\z> so, once I go through something like create :: Packageable a => String -> a, the only thing I can do is operate on that through functions on Packageable
13:26:42 <\z> and those functions on Packageable can just call the methods on Package
13:26:49 <Cale> Well, it would be like:
13:26:50 <\z> like Showable calls show
13:27:04 <Cale> data Package = forall a. Packageable a => Package a
13:27:10 <Cale> right
13:27:16 <Cale> once you apply Package
13:27:25 <Cale> then you can only apply the members of Packageable
13:27:36 <Cale> because the type a is forgotten
13:27:49 <Cale> You have something of type Package
13:28:13 <Cale> actually, perhaps I should have been clearer and named the data constructor something different from the type constructor there
13:28:20 <Cale> data Package = forall a. Packageable a => P a
13:28:54 <\z> So in that case, Package and a whole bunch of phantom classes are instances of Packageable
13:28:56 <Cale> Once you apply P to a value of type 'a' get a value of type Package, the type 'a' is forgotten.
13:29:16 <\z> and the instance for Package would just call the method on the Package value it's wrapping
13:29:27 <Cale> yeah
13:29:34 <nornagon> hang on, don't you get a value of type Package a?
13:29:37 <\z> Thanks.
13:29:38 <nornagon> oh, wait.
13:29:39 <nornagon> nm.
13:29:41 <Cale> I think you abused the word 'classes' there, but yeah :)
13:29:43 <\z> That's exactly what I wanted to do.
13:30:10 <\z> I think.
13:30:12 <Cale> That's essentially the core of what OO programming is about, at least in my mind.
13:30:16 <\z> Right.
13:30:29 <cinimod> @t (.).(.)
13:30:29 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
13:30:44 <\z> I'm trying to define a class, and pass around subclasses that only perform operations that are defined on the parent class.
13:30:46 <cinimod> @type (.).(.)
13:30:48 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:30:54 <Cale> People struggle to give a definition of OO programming. My attempt would be the systematic use of existential types.
13:31:15 <\z> But I want each subclass to be specialized in some way.
13:31:55 <Cale> \z: right -- my only warning is that you can never do a downcast, so make sure the parent class' interface is general enough
13:32:06 <\z> Cale: right.
13:32:17 <nornagon> @let Y = id
13:32:18 <lambdabot> <local>:1:0: Not in scope: data constructor `Y'
13:32:25 <\z> These are very constrained types in my system.
13:32:32 <nornagon> dangit.
13:32:45 <nornagon> @let data Y = Y a
13:32:46 <lambdabot> Invalid declaration
13:33:01 <Cale> Also, this is always avoidable -- note that in my Showable example, the values are essentially Strings after we apply the Showable data constructor to them.
13:33:34 <\z> Right.  The alternative I had was to wrap all possible instances into an algebraic type.
13:33:50 <Cale> Well, yeah, but that constrains the number of variants.
13:33:52 <\z> Like data Package = PackageA B | Package B B
13:34:24 <\z> Right.  But the whole point of the exercise is to describe an algorithm in the most general possible terms, and have specialized objects going through the system
13:34:26 <Cale> Instead, what I'm suggesting is taking all the functions in the Package class and storing functions of essentially those types.
13:34:33 <\z> so that each value uses the most appropriate definition of an operation.
13:35:03 <mauke> @let _ = undefined; data Y = Y
13:35:04 <lambdabot> Invalid declaration
13:35:05 <Cale> For example, instead of an operation to get a list of files, store the list of files. (It's lazy anyway)
13:35:08 <bos> hi, andy. long time, no see :-)
13:35:47 <andyjgill> Hi
13:35:51 <\z> Cale: Right.  I understand that.  But that doesn't work for me in this case.
13:36:00 <Cale> What is your actual interface?
13:36:06 <Cale> There's a pretty mechanical way to do it
13:36:11 <\z> I want to write a function that uses a single interface for multiple discrete implementations.
13:36:23 <Cale> Basically, it amounts to what the compiler is doing with the existential type behind the scenes.
13:36:38 <\z> The first step is to choose which implementation I want.  Basically, one specific member of a typeclass.
13:36:51 <\z> Then pass that value through a standard set of operations.
13:36:57 <\z> And come up with a concrete result.
13:37:01 <Cale> Can I see the list of operations?
13:37:21 <\z> OK.  Let me paste something up.
13:37:41 <bos> Cale: as you predicted, by using -fglasgow-exts and -fallow-undecidable-instances, the compiler goes belly-up when i try to declare new instances of Pickleable.
13:37:48 <Cale> bos: right
13:37:57 <bos> i don't know what to do about this, then.
13:38:23 <Cale> bos: write instances for specific datatypes?
13:38:31 <ClaudiusMaximus> \z: i've done something similar, oo-style implementation of an interface
13:38:37 <bos> i'd prefer not to write instances for every data type, because i'm lazy.
13:38:46 <bos> but the compiler is not going to allow me to be lazy.
13:39:04 <bos> it has arrogated the right of laziness to itself :-)
13:39:32 <Cale> How about adding -fallow-overlapping-instances ?
13:39:37 <Cale> That might let it mean what you want
13:40:05 <Cale> the only problem is that determining which instance it'll use in various circumstances becomes complicated
13:40:24 <Cale> You want to be able to override your general instance for Typeable, right?
13:40:39 <bos> yes.
13:40:44 <Cale> Yeah, then try that
13:40:52 <bos> and -fallow-overlapping-instances does work.
13:41:07 <bos> i'm concerned that i am painting myself into a corner the nature of which i don't understand.
13:41:08 <Cale> You're moving into Oleg-land though. :)
13:41:25 <Cale> Not so much a corner, but a bizarre and colourful world.
13:41:26 <bos> yeah, i doubt i have a femto-oleg of capacity.
13:41:57 <Cale> Maybe if one takes the right sort of drugs, those can be the same thing.
13:42:02 <xic> glguy: do you happen to know if hslogger is thread safe?
13:42:55 <Cale> "Look at all those little guys in the cracks of paint! Man, they're revealing the secrets of the universe to me! This is the best corner ever!"
13:43:08 <bos> heh heh.
13:43:11 <lisppaste2> \z pasted "Faking OOP in Haskell" at http://paste.lisp.org/display/35040
13:43:16 <lisppaste2> ClaudiusMaximus pasted "OO+state+sideeffects (for \z )" at http://paste.lisp.org/display/35041
13:43:26 <bakert> Is Control.Monad.State part of the standard libraries?
13:43:31 <glguy> mtl
13:43:41 <glguy> which is part of the standard extra libraries
13:43:48 <\z> Cale: that's a pretty simplified example of what I'm trying to achive
13:43:59 <\z> I've got a workflow constructed that's going to take one of a limited set of package types
13:44:30 <\z> the operations are constrained to those methods only
13:44:37 <\z> but each instance of the package class will define them differently
13:45:04 <\z> I want to be able to add new package types at will by adding a new instance and extending createPacakge
13:45:16 <\z> and not modify the workflow in any other way
13:45:21 <lisppaste2> Cale annotated #35040 with "another route" at http://paste.lisp.org/display/35040#1
13:46:22 <Cale> see how that works?
13:47:02 <Cale> It's exactly the same as using the existential type, without the existential type.
13:47:33 <Cale> Of course, if your interface was more colourful, we might actually store some functions.
13:47:55 <Cale> But this already demonstrates quite a bit.
13:47:56 <bakert> glguy, is that the "extralibs" thing on the ghc download page?
13:48:01 <Cale> Note the use of recursion :)
13:48:04 <glguy> bakert: yeah
13:48:13 <glguy> bakert: what platform are you using?
13:48:30 <bakert> should have built that too.  just spent 8 hours getting 6.6 on this box (ubuntu dapper)
13:48:33 <Cale> \z: does that make sense?
13:48:42 <dibblego> 6.06
13:48:44 <bakert> apparently i can install them at a later point with cabal so going to look into that
13:48:49 <\z> Yeah, it does.  I might not be explaining my problem well though.
13:48:55 <bakert> ghc 6.6 sorry not ubuntu
13:49:01 <bakert> ubuntu 6.10
13:49:03 <dibblego> oh
13:49:03 <bakert> (i think?)
13:49:08 <dibblego> that's edgy
13:49:10 <dibblego> dapper is 6.06
13:49:12 <\z> For example, each of the package objects need to carry some state, which is why operations like gather have type a -> a
13:49:25 <\z> But I see how packaging up the functions like you did could make that work
13:49:29 <bakert> yes sorry 6.06.  but it was ghc 6.6 that took 8 hours.
13:49:41 <\z> the data being managed is pretty common across different package variants.
13:49:45 <bakert> only now i have no libraries i think!
13:49:49 <\z> only the implementations of the specific operations vary.
13:49:55 <bakert> certainly not Control.State.Monad
13:50:04 <glguy> \z: all of that is gathered up when you do the createPackage in Cale's example
13:50:04 <Cale> \z: there's a way to translate any existential type into this style
13:50:32 <\z> I was thinking with my OO hat on.  I see how gathering the functions into a datatype works much more nicely.  :-)
13:50:33 <Cale> basically, instead of instances of your classes, you have values of type Package
13:50:45 <\z> Thanks!
13:50:47 <\z> Cale++
13:50:50 <\z> glguy++
13:51:20 <glguy> bah, how am I to catch up with Cale if he gets points when I do?? (-;
13:51:26 <Cale> hehe
13:51:35 <glguy> \z: yw
13:51:59 <glguy> ?. elite karma
13:52:00 <lambdabot> You HA\/e 4 KaRMA of 18
13:52:05 <glguy> ?. elite karma Cale
13:52:05 <lambdabot> c41E hAs A KarMA oph 38
13:52:13 <Cale> haha oph
13:52:32 <glguy> lol, my karma was 4/18
13:52:44 <bakert> @karma
13:52:45 <lambdabot> You have a karma of 1
13:52:51 <bakert> beat that suckahz
13:52:59 <bakert> ;)
13:53:06 <glguy> ?yow
13:53:06 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
13:53:06 <lambdabot> Belt," for $10.99!!
13:53:38 <\z> Speaking of 1962: http://www.flickr.com/photos/adamturoff/352785138/
13:53:40 <lambdabot> Title: Tech Review Lispy Centerfold on Flickr - Photo Sharing!
13:54:09 <\z> There's an annotated centerfold of eval and apply from the Lisp 1.5 Programmer's Manual  in this month's Technology Review.
13:54:42 <augustss> greetings from Aruba!
13:55:07 <bakert> ok i'm stuck.  i want to install mtl (for Control.Monad.State).  I have cabal as part of ghc 6.6 that I just installed.  what's the next step?
13:55:07 <Cale> greetings!
13:55:23 <Cale> bakert: mtl comes with ghc
13:55:26 <bakert> oh
13:55:32 <bakert> i have some other problem then!
13:55:42 <bakert>     Could not find module `Control.Monad.State':
13:55:52 <bakert> should that not be possible?
13:55:54 <glguy> Cale: I think he needs to install the extralibs package
13:56:05 <Cale> oh, maybe your distribution separated out all the packages
13:56:14 <glguy> that damned Loonucks is separating packages
13:56:22 <bakert> i think i have messed up the library path by installing ghc 6.6 from source.
13:56:33 <bakert> it only seems to be looking under the current dir.
13:56:43 <\z> baket: did you install just ghc, or ghc and extralibs?
13:56:59 <Cale> er, it should be installable that way, though you'll save *a lot* of time if you install from binaries.
13:57:09 <bakert> just ghc ... i believed the readme when it told me i could use cabal to install extralibs later.
13:57:25 <\z> OK.  It's later.  Now it's time to install extralibs.  :-)
13:57:28 <Cale> Basically, don't install ghc from source unless you are going to hack on it.
13:57:36 <xic> what do you guys think of the word "factory" as in the OOP design pattern?
13:57:38 <bakert> Cale, you're right but no 6.6 for ubuntu apart from in feisty.  believe me i tried using the debian-unstable and that was a DISASTER!
13:57:48 <glguy> xic: absolutely
13:57:50 <Cale> bakert: install from the generic binary package
13:58:21 <Cale> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-unknown-linux.tar.bz2
13:58:23 <lambdabot> http://tinyurl.com/y9myfk
13:58:24 <Cale> that one
13:58:27 <\z> bakert: Do what Cale says.
13:58:30 <bakert> oh
13:58:39 <bakert> missed that skipping down to the debian instructions.
13:58:42 <bakert> doh
13:58:42 <Cale> Compiling is a total waste of time.
13:58:46 <\z> But if you find yourself installing from source again for any reason, extract the ghc sources, then extract extralibs, then build.
13:58:50 <bakert> Cale, i see that now!
13:58:53 <xic> glguy: do you think it's an ok name for something like, type IntFactory = Config -> Int?
13:59:37 <bakert> hmm ... so i guess i need to uninstall the version i compiled or will the generic binary package overwrite happily?
13:59:40 <\z> Cale: I disagree.
13:59:57 <\z> Cale: Compiling ghc from source is worthwhile if you're in a cold room without a space heater.
13:59:58 <\z> :-)
14:00:17 <bakert> yeah ... it did warm my laptop up!
14:00:34 <bakert> i left it running on the tube home .. had to take it out of the bag in case it blew up!
14:00:59 <glguy> xic: I don't think that's what factory means in the OO sense, but I imagine it's a fine name...
14:01:02 <bakert> still .. i learnt something ... it takes a long time to compile!
14:02:01 <bakert> glguy, Cale, \z, do i need to remove 6.4.1 and/or the version of 6.6 i compiled before installing the generic binary of 6.6?
14:02:11 <bakert> or will it do the right thing?
14:02:36 <glguy> you can have multiple versiosn installed
14:02:42 <glguy> the symlinks should be updated
14:02:46 <glguy> and if they aren't you can
14:03:02 <Azmo> i have 4 versions installed :]
14:03:11 <bakert> cool ok i'll just go for it and sort out what ghc points at after.
14:03:27 <bakert> at least it isn't 8 hours to find out if it worked this time!
14:03:38 <bakert> thanks guys
14:04:16 <\z> bakert: http://www.cse.unsw.edu.au/~dons/blog/2006/12/03#build_ghc_fast
14:04:17 <lambdabot> Title: Haskell hacking
14:04:28 <\z> bakert: and http://www.cse.unsw.edu.au/~dons/blog/2006/12/05#build_ghc_faster
14:04:29 <lambdabot> Title: Haskell hacking
14:04:55 <\z> basically, if you bootstrap, expect Al Gore to be knocking on your door asking you to buy carbon credits to offset compiling ghc
14:05:25 <bakert> yo
14:05:32 <\z> but that's not totally necessary.
14:05:38 <\z> just don't bootstrap.
14:05:51 <bakert> yup
14:05:53 <bakert> got it
14:06:11 <bakert> i wish i had realised what that last link was in the list of linux x86 binaries!
14:06:14 <Cale> dons' machine compiles GHC in 9 minutes.
14:06:29 <bakert> wowzers.  i need one of those.
14:06:29 <Cale> I wonder what kind of heat dissipation that needs!
14:06:31 <\z> My machine didn't take much longer.  But it was made this year
14:06:32 <allbery_b> ...and melts a couple ice shelves along the way?
14:09:11 <monochrom> hahaha "don's machine drives up global temperature in 9 minutes!"
14:10:54 <reilly_> computation is entropy
14:11:03 <\z> g'nite everyone.
14:13:35 <temujin> mmmm
14:13:44 <bakert> well, looks like installing the generic binary takes me longer than 9 minutes!
14:13:45 <temujin> global entropy increased due to computation powers
14:14:03 <Botje> moore's law is destroying the planet!
14:14:14 <Botje> let's all go back to hand-powered 8086s!
14:14:15 <allbery_b> hm, it didn't take that long on my g4 macmini
14:15:03 <monochrom> Something is wrong if installing the binary takes more than 9 minutes.
14:17:00 <bakert> that might be an exaggeration.  it took a few minutes though.  sadly now i need this old readline thing and there's only an rpm.  time to work out alien.
14:18:21 <bakert> ha ha.  that actually went rather smoothly.  how good.
14:18:52 <bakert> and now i have Control.Monad.State AND ghc 6.6 for the first time.  now i just have to remember what i needed it for!
14:19:10 <allbery_b> global conquest, of course
14:19:54 <bakert> naturally ;)  it was something to do with ClockTime or something.  And XHtml and fps (both of which i had installed separately) and a general sense that that was what everyone else was running.
14:20:08 <glguy> I don't think you need fps now
14:20:12 <glguy> with Data.ByteString
14:20:25 <glguy> (but I could be wrong and fps could provide some other fucntionality..)
14:20:26 <bakert> it's a dependency for something (HDBC.PostgreSQL??)
14:20:48 <bakert> No, I think maybe HAppS.  I have it all in my README files for my apps ...
14:21:00 <bakert> yes, it's HAppS that wants fps
14:21:12 <allbery_b> check for a cabal file for 6.6
14:21:13 <daniel_larsson> Probably not needed any more though, since 6.6
14:21:25 <allbery_b> if not, edit the cabal file to specify base >= 2.0 instead of fps
14:22:35 <bakert> sorry -- i'm causing confusion.  HAppS only needs fps if you are running <ghc6.6
14:22:55 <bakert> i had to install it before when running 6.4.1 -- i had to add it to the cabal file too.  but now i should be plain sailing.
14:23:11 <xic> bakert: how is happs working for you?
14:23:27 <bakert> xic, it IS working.  but i don't understand what it is doing.
14:23:40 <bakert> i have an app that displays a form and writes to a postgresql db
14:23:56 <bakert> but gawd knows what those crazy functions i stole from the example folder are actually doing.
14:24:06 <bakert> i keep breaking it because i don't understand it.
14:24:15 <bakert> if anyone knows of a good intro doc then i would love to read it.
14:24:51 <bakert> for example in /examples/io_or_no_io.hs (which i used as the basis of my app) there is a function called "w" that is just craaaaazeeeee.
14:25:15 <Heffalump> anyone know much about visual haskell?
14:25:23 <bakert> w :: (FromMessage msg, ToHttpResultM (Wrap res)) => (msg -> UEv res) -> UEv (IO Result)
14:25:23 <bakert> w fun   = (toHttpResultM =<< fun =<< fromMessageM =<< getEvent) `catchEv` errorCase
14:25:28 <bakert> i mean, hello?
14:25:41 <bakert> i am not at that level yet.
14:26:01 <bakert> xic, do you use happs?
14:26:24 <xic> bakert: i tried using it, but in the end went with writing my own server
14:26:26 <allbery_b> get an event, translate it to internal format, run fun on it, translate back to external format, if something fails on the way invoke errorCase
14:26:55 <bakert> allbery_b, oooh, you're good.
14:26:59 * allbery_b doesn't know HAppS but can infer behaviors from the names
14:27:14 <allbery_b> and I know what <<= does
14:27:21 <bakert> yeah, that would be key ;)
14:27:45 <bakert> i'm still flailing around in haskell world i'm afraid.  it's still only 17 days since i took it up!
14:28:00 <allbery_b> <<= is flip (>>=) (monadic bind, which you can think of as function composition if you're just doing an overview)
14:28:38 <glguy> =<< ?
14:28:52 <allbery_b> yeh, sorym, typo
14:28:57 <allbery_b> =<<
14:28:57 <dibblego> bakert, are you writing to a database with hackagedb?
14:28:57 <bakert> i see
14:29:00 <daniel_larsson> in do syntax, it would be "do e <- event; m <- fromMessageM e; res <- fun m; toHttpResultM res;", I believe
14:29:22 <bakert> dibblego, i am using HDBC.PostgreSQL.  it is very good.
14:29:32 * allbery_b is still somewhat brainfuzzled, and regularly mistypes that operator at the best of times :/
14:29:43 <bakert> daniel_larsson, allbery_b, thanks that does actually make things clearer.
14:29:53 <allbery_b> @redo  (toHttpResultM =<< fun =<< fromMessageM =<< getEvent) `catchEv` errorCase
14:29:54 <lambdabot> (toHttpResultM =<< fun =<< fromMessageM =<< getEvent) `catchEv` errorCase
14:29:58 <allbery_b> oops
14:30:01 <daniel_larsson> hehe
14:30:09 <allbery_b> maybe not, then :p
14:30:10 <bakert> what about this line (it just appears brazenly in the code it's not part of a function):
14:30:12 <bakert> $(inferStartState ''MyState)
14:30:23 <glguy> that looks like TH
14:30:28 <allbery_b> I think that's template haskell.  I don't understand that yet
14:30:50 <shapr> bakert: Yeah, that's TH
14:31:02 * shapr is hacking on HAppS at the momen.t
14:31:05 <bakert> i think perhaps HAppS is asking too much of me at this stage.  Is there a more "for dummies" web framework?
14:31:18 <shapr> bakert: I'm writing an updated tutorial for HAppS as we speak ...
14:31:19 <bakert> or should i force myself to work it out for the good of my brain?
14:31:27 <bakert> shapr, oh lord that would be wonderful.
14:31:35 <shapr> There's a new API that's simpler in many respects.
14:31:38 <bakert> just to understand what it is supposed to mean.
14:31:41 <bakert> would be great
14:31:53 <shapr> bakert: Will you be around tomorrow?
14:31:57 <bakert> yes.
14:32:01 <bakert> i am in the UK
14:32:04 <bakert> but yes
14:32:15 <sm> shapr, excellent
14:32:17 <shapr> bakert: Once I've got the tutorial together, I want someone who doesn't know HAppS already to look at it.
14:32:23 <shapr> bakert: So I'd appreciate your input there :-)
14:32:25 * glguy wonders if the UK will be around tomorrow
14:32:28 <bakert> shapr, i am your man, that's for sure
14:32:34 <daniel_larsson> so stop learning it now, bakert!
14:32:37 <bakert> !!!
14:32:42 <shapr> bakert: thanks :-)
14:32:43 <allbery_b> heh
14:33:05 <bakert> shapr, if i bizarrely forget or something you can mail me on bakert at gmail dot com
14:33:09 <bakert> but i won't
14:33:23 <bakert> i neeeed that tutorial!
14:33:58 <Heffalump> glguy: I hope so..
14:34:29 <bakert> i also promised someone that i would write up a simple how to on Br
14:34:37 <bakert> s/Br/Network.Browser/g
14:35:07 <bakert> i'm not sure how much use my newbie burbling will be but at least that part of my code does what it is supposed to!
14:35:53 <shapr> bakert: Cool, will your howto be on the wiki?
14:36:13 <bakert> I suppose so.
14:36:33 <bakert> It's just going to be a simple thing about how to screen scrape programming.reddit.com i think
14:37:01 <PaulAJ> Let me guess: reddit cloud in Haskell?
14:37:08 <bakert> I'm quite proud of myself for fixing two teeny tiny cookie-handling bugs that programming.reddit.com highlighted when testing.
14:37:28 <Cale> We need a version of programming reddit without any crap in it :)
14:37:39 <bakert> if you download it now that's my  || x == ":" in there!
14:37:49 <allbery_b> problem is, then it becomes popular and turns into /.
14:38:00 <bakert> PaulAJ, no just literally grab the page and put it into a list of headline/story pairs
14:38:07 <bakert> something like that.
14:38:32 <PaulAJ> Cale: we could also ask for a Haskell reddit, but I think the Haskell stuff is helping to create a "buzz", at least for reddit readers.
14:38:34 <bakert> it's what my boss and i sat down and did to get to grips with how it worked (and if) writing an actual program
14:38:42 <Cale> PaulAJ: yeah
14:39:04 <bakert> I actually quite like programming.reddit.com -- since I started learning haskell it has far less irrelevant stuff on it!
14:39:16 * PaulAJ grins
14:39:30 <Cale> PaulAJ: The problem is that there's so much Agile junk and crap about business and graphic design and other things having very little to do with programming on there.
14:39:50 <velco> isn't reddit supposed to ajust to one's preferences ?
14:40:03 <Cale> If an article doesn't have snippets of source code in it, there's a very good chance I'm going to mod it down.
14:40:17 <PaulAJ> I think the "recommended" page does, but the rest is global.
14:40:21 <bakert> I only mod up.  I'm obviously an optimist.
14:40:27 <PaulAJ> Ditto.
14:40:34 <Cale> I mod down almost everything to get it out of my face :)
14:40:39 * allbery_b subscribed to programming.reddit for a few weeks then removed it from his aggregator; too slashdot-like for his tastes
14:40:54 * glguy bets that Cale frotn prog.reddit page doesn't have a "next" button
14:40:59 <allbery_b> (and use #haskell as a filter instead :)
14:41:13 * Botje moans about people tagging css crap as coding
14:41:13 <glguy> Cale's front*
14:41:29 <PaulAJ> On another topic, I'm thinking of writing a test extractor for Haddock comments.
14:41:35 <Cale> I fail to mod down about 9% of the articles on programming reddit.
14:41:48 <bakert> you guys are harsh!
14:42:06 <PaulAJ> Something like, able to recognise -- > q: reverse reverse ls = ls
14:42:21 <bakert> you won't like me, i modded up the article on optimizing ruby.
14:42:23 <PaulAJ> Does this sound like a good idea?
14:42:26 <Cale> "Is Safari Headed For Windows?" -- this belongs on programming reddit?
14:42:37 <jethr0> PaulAJ: that would be great. i loved that in python (or was it ruby)?
14:43:02 <PaulAJ> Ahh, if something simlar exists, that would be useful.  I'm trying to figure out the right markup.
14:43:02 <daniel_larsson> python has ability to write tests in docstrings
14:43:18 <PaulAJ> Can you point me at the documentation for that?
14:43:41 <jethr0> its just "> 5 == 5"
14:43:45 <daniel_larsson> http://www.python.org/doc/lib/module-doctest.html
14:43:47 <lambdabot> Title: 23.2 doctest -- Test interactive Python examples
14:43:49 <jethr0> s/"/"""/
14:43:55 <PaulAJ> I also think I saw some Haskell code where the author had hacked up something similar, just for that application.
14:44:02 <PaulAJ> daniel_larsson: thanks.
14:44:13 <Cale> It's actually doing sort of good right now, 11/100 articles are visible in New
14:44:19 <jethr0> yes, i've seen it done in haskell as well, but don't remember where, either
14:44:33 <Cale> Though not so many of those that I didn't mod down are really all that wonderful.
14:45:40 <glguy> I've seen about as many "I just started learning this new cool language and I have no fucking idea what i'm talking about" blog posts
14:45:44 <glguy> and I care to
14:46:00 <glguy> more than I care to, actually (-;
14:46:11 <Cale> hehe
14:46:18 <bakert> I have resisted one of those.
14:46:19 <bakert> !
14:46:30 <retybok> ?users
14:46:30 <lambdabot> Maximum users seen in #haskell: 303, currently: 291 (96.0%), active: 48 (16.5%)
14:46:34 <Cale> I mind that a whole lot less than the posts where the author takes a tone of knowing what they're talking about when they don't
14:47:07 <bakert> I can't detect those!
14:47:12 <dmhouse> Evening everyone.
14:47:18 <bakert> Good evening
14:47:26 <PaulAJ> glguy: I keep an eye on the "I'm learning Haskell" posts, for feedback on the Wikibook.
14:48:31 <Cale> A lot of the stuff written about design patterns is total BS in my humble opinion. Design patterns are a sign of flaws in your language, even the original design patterns book knew this, shut up and fix your language already!
14:48:31 <bakert> programming.reddit.com definitely does give the impression that most of the population of the earth recently started learning haskell.
14:48:50 <bakert> Ah, the NEW orthodoxy!
14:48:54 <PaulAJ> I've just had a look at that Python docstring test page, and I see how it works.  I'll meditate on this some more.
14:48:56 <Excedrin_> Cale: shouldn't you mod those sideways and comment that?
14:48:56 <bakert> (sorry Cale!)
14:49:34 <Cale> Excedrin_: I usually mod them down and post some comments to that regard. There are too many to comment on all of them.
14:49:48 <syntaxfree> bakert: I write my blog for those.
14:49:57 <Cale> I tend to remark when I see advocacy of the singleton pattern though.
14:50:01 <Cale> That's inexcusable.
14:50:20 <PaulAJ> I sometimes explain monads as a design pattern for sequencing actions.
14:50:39 <syntaxfree> what's the singleton pattern?
14:50:43 <Cale> Yeah, the difference is that we can actually build language constructs that formalise that pattern.
14:50:59 <Cale> syntaxfree: basically, global mutable variables in disguise
14:51:10 <syntaxfree> i.e. the state monad?
14:51:12 <PaulAJ> Cale: right.  Thats the big difference of course.
14:51:12 <Cale> You make an object which there can only be one of in the program.
14:51:15 <syntaxfree> ;)
14:51:19 <allbery_b> I'd say there are two different meanings for "design pattern".  one amounts to knowing how to use your tools; the other amounts to working around shortcomings in your language
14:51:32 <Cale> syntaxfree: no, more like unsafePerformIO (newIORef ...)
14:51:38 <allbery_b> the former is good, the latter bad
14:51:41 <PaulAJ> syntaxfree: singleton is a way to shoehorn global variables into an OO namespace.
14:51:47 <bakert> (syntaxfree, i'm afraid you've crossed some kind of line liking an Ali Smith novel.)
14:52:09 <syntaxfree> Cale: oh, sucks.
14:52:17 <syntaxfree> unsafePerformIO is evil!
14:52:27 <syntaxfree> unsafePerformIO is People!
14:52:28 <PaulAJ> But sometimes a necessary evil.
14:52:34 <syntaxfree> NO, IT'S EVIL!
14:52:35 <dmhouse> syntaxfree: it's the only way to get a global mutable variable.
14:52:36 <syntaxfree> EVIL! EVIL! EVIL!
14:52:46 <syntaxfree> yes, I know :(
14:53:05 <syntaxfree> NO GLOBAL MUTABLE VARS!
14:53:05 <dmhouse> (Not wishing to debate why you would actually want one of those.)
14:53:25 * allbery_b has only used unsafePerformIO once, and on;ly because he didn't know about Debug.Trace
14:53:31 <mgsloan> I tried doing that once, but it didn't seem to work
14:53:34 <glguy> I like the arguments that "Every language has design pattersn"
14:53:39 <mgsloan> Then I just did it properly :P
14:53:44 <PaulAJ> I once tried using unsafePerformIO to read a global config from a file, not even anything mutable.  However I wound up just passing the config object around in the end, because it was simpler that way.
14:53:45 <glguy> since the obvious response is that "no shit, no language is perfect"
14:53:54 <glguy> but that many of the patterns have been sovled already
14:53:56 <allbery_b> well, they also have them in y first sense of the word
14:53:58 * dmhouse has used unsafePerformIO quite safely.
14:53:59 <allbery_b> *my
14:54:08 <syntaxfree> glguy: I like people who argue "but you can do x in MyLang".
14:54:08 <allbery_b> or term if you prefer
14:54:19 <syntaxfree> well, yes, I'm sure you can do it in Malbolge as well.
14:54:27 <PaulAJ> As Cale says, the difference in Haskell is that our design patterns can generally be folded back into the language as higher order types or functions.
14:54:37 <mgsloan> I don't think patterns are bad thing, not being able to extract the pattern and give it a name, and use the pattern elsewhere is the problem :)
14:54:44 <mgsloan> right
14:54:51 <allbery_b> right, that's my first sense of the term
14:54:54 <dmhouse> http://www.joelonsoftware.com/items/2006/08/01.html
14:54:56 <lambdabot> Title: Can Your Programming Language Do This? - Joel on Software
14:55:16 <syntaxfree> doesn't Joel use a beefed-up VB?
14:55:17 <PaulAJ> The problem with patterns in OO languages is that they rely on pattern recognition, a bit like structured programming in Fortran.
14:55:42 * ClaudiusMaximus has used unsafePerformIO once, led to horrible crashes, i rewrote it all with all my functions in a huge where clause
14:55:51 <PaulAJ> You can reverse-engineer a while loop in Fortran if you know what to look for.
14:55:56 <allbery_b> that soulds like wrong tool
14:56:04 <syntaxfree> pass around explicit state, if monads don't cut it.
14:56:12 <PaulAJ> Similarly you can reverse engineer Observer in an OO class diagram if you know what to look for.
14:56:49 * glguy opens his GoF book of flaws
14:56:58 <syntaxfree> what are Java functors?
14:56:58 <Cale> If you want to call foldr a design pattern, that's not what I'm talking about though :)
14:56:59 <glguy> flips to p. 293, observer
14:57:19 <syntaxfree> foldr is a program construction block.
14:57:22 <syntaxfree> @free foldr
14:57:22 <Cale> I'm talking about things which are inexpressible in the language that keep cropping up in code.
14:57:23 <lambdabot> (forall x. f . h x = k (g x) . f) => f . foldr h y = foldr k (f y) . $map g
14:57:43 <syntaxfree> Cale: hey, do compilers know about this transformation?
14:57:46 <syntaxfree> @free drop
14:57:47 <lambdabot> $map f . drop x = drop x . $map f
14:58:11 <Cale> syntaxfree: they know about even better ones :)
14:58:13 <PaulAJ> Cale: thats what I'm talking about: in Haskell those things are much rarer.
14:58:18 <Cale> PaulAJ: right
14:58:20 <dmhouse> syntaxfree: transformations of Java categories?
14:58:24 <syntaxfree> Cale: I wish I had an explicit list of which theorems they're aware of.
14:58:34 <syntaxfree> dmhouse ;)
14:58:44 <dmhouse> By the way, what do the $ mean in that Free theorem?
14:58:45 <Cale> syntaxfree: look in the GHC implementations of the libraries
14:58:49 <bakert> thanks for your help with ghc6.6 folks.  good night.  i'm looking forward to getting HAppS-ed tomorrow shapr!
14:58:53 <Cale> you'll find lots of RULES pragmas
14:58:59 <Cale> (or at least a few)
14:59:01 <syntaxfree> dmhouse: that way you don't have to write (map f)
14:59:11 <Cale> those are the more explicit laws that they know about anyway
14:59:24 <Cale> GHC does foldr/build fusion
14:59:26 <dmhouse> syntaxfree: huh? map f . drop x = drop x . map f makes perfect sense.
14:59:28 <syntaxfree> Cale: basically, it should know about any free theorem that doesn't depend on nasty conditions?
14:59:48 <Cale> syntaxfree: well, it's not really enough just to know the free theorems
14:59:58 <twanvl> I think $map means something like "the map function from the prelude", so you don't get name conflicts
14:59:59 <syntaxfree> you have to have rewrite rules.
14:59:59 <Cale> You also have to know which theorems are actually useful to apply
15:00:07 <mgsloan> > (drop 1 . map  (+1)) [0,1,2,3]
15:00:08 <Cale> and in which direction
15:00:08 <lambdabot>  [2,3,4]
15:00:10 <jethr0> PaulAJ: but that would be arguing for lisp style macros (read time, compile time, ...) which make many things possible that pure haskell doesn't
15:00:16 <Cale> So yeah, rewrite rules
15:00:24 <mgsloan> yeah, the $ isn't the $ op
15:00:26 <syntaxfree> well, if drop . map comes up, map . drop is evidently better.
15:00:44 <Cale> It is?
15:00:53 <syntaxfree> sure. smaller list.
15:00:54 <Cale> I'd say they're the same
15:01:02 <syntaxfree> drop . map is calculating a lot of results that'll later be dropped.
15:01:02 <jethr0> syntaxfree: doesn't lazyness take care of that?
15:01:05 <Cale> Should be exactly the same performance
15:01:07 <PaulAJ> jethr0: I'm not sure about that, given that (with a couple of compiler flags) the Haskell type system is Turing complete.
15:01:14 <Cale> syntaxfree: no it's not
15:01:15 <syntaxfree> uhhh. sure.
15:01:17 <syntaxfree> stupid me, yes.
15:01:18 <syntaxfree> !
15:01:28 <mgsloan> map drop would be easier on the compiler though :)
15:01:30 <jethr0> PaulAJ: *bah*, not the turing completeness argument
15:01:36 <Cale> mgsloan: oh?
15:01:42 <glguy> > drop 10 $ map succ [1..]
15:01:44 <lambdabot>  [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,...
15:02:07 <PaulAJ> I very much prefer to work in declarative mode, but my point is that I don't think that actually limits you in Haskell.
15:02:13 <jethr0> PaulAJ: lisp macros are very powerful indeed and allow introspective abstractions, ...
15:02:19 <Cale> Laziness is taken care of by the runtime system, and the way that code is compiled. I don't think either one of these should really be easier in either case.
15:02:29 <mgsloan> cale - well, maybe not.  from the perspective of doing a simple interpreter with limited laziness it might be though
15:02:31 <mgsloan> ah
15:02:47 <PaulAJ> But the impression I get from reading Olegs stuff is that the Haskell type system is probably equally powerful.
15:03:07 <PaulAJ> (Not just Oleg of course, but he is the main exponent of type hackery)
15:03:21 <Cale> The problem is that programming at the type level is actually pretty awkward in Haskell's type system, despite the fact that you can do it.
15:03:29 <PaulAJ> Yes.
15:03:43 <jethr0> PaulAJ: apart from TH haskell lacks introspection
15:03:57 <PaulAJ> But most of the common stuff doesn't require hugely complex hackery.
15:04:27 <PaulAJ> jethr0: has anyone come up with statically type safe introspection?
15:04:42 <PaulAJ> (I must admit I'm getting out of my depth here)
15:05:10 <jethr0> i'm not saying that it's type safe. i was just saying that lisp macros make some things easier than haskell does. and thus in this metric lisp is "better" than haskell
15:05:57 <mgsloan> I guess you could have something like getFunc :: String -> Maybe a, and it would only work if the return type inferred matches the type of the function that the string matches
15:06:02 <PaulAJ> Well, sorta.  Yes, you can very easily invent your own DSL in Lisp by using macros.  http://www.paulgraham.com/avg discusses the advantages in some detail.
15:06:04 <lambdabot> Title: Paul Graham
15:06:44 <PaulAJ> http://www.paulgraham.com/avg.html
15:06:44 <lambdabot> Title: Beating the Averages
15:07:46 <jethr0> yes. all i'm saying is that when it comes to extracting abstractions haskell is not the end-all language and in this very respect there are better solutions.
15:07:59 <jethr0> it's very good at it though
15:08:06 <PaulAJ> But Lisp macros can also be imperative code, which makes me twitchy because there is no guarantee that two calls to the same macro will generate the same code.
15:08:19 <sorear> gensym!
15:08:26 <PaulAJ> I can certainly see that it can work well though: I'm not dissing Lisp.
15:08:47 <sorear> many macros (IANALP) *must* generate different code or they will fail.
15:08:50 <jethr0> true. i'm actually not a friend of macros because i'm usually too stupid to read complex ones; they do allow extracting abstractions very powerfullly though
15:08:52 <PaulAJ> (BTW, I have done almost no Lisp and have never used macros)
15:09:34 <PaulAJ> It would be an interesting exercise to review some Lisp macrology and cast it into Haskell.
15:09:40 <jethr0> neither have i (at least not any great ones) because i usually got a headache writing them or debugging them
15:10:13 <PaulAJ> Graham mentions that his 1997 web app was 60 or 70 % macros.
15:10:21 <jethr0> i was just talking to the guy who wrote liskell and he seems to have implemented something like that (though not entirely type safe)
15:11:07 <PaulAJ> But he also got a patent for using continuations in web applications, which makes me suspect that we could have done exactly the same thing with ContT (StateT ( IO a)))
15:11:35 * PaulAJ goes to google liskell
15:12:29 <jethr0> it's not published yet. it's lisp-like bindings which are transformed to haskell via TH
15:12:41 <jethr0> s/bindings/syntax/
15:12:58 <PaulAJ> TH = Type Hackery?
15:13:08 <jethr0> template haskell
15:14:01 <PaulAJ> Oh of course.  I have to admit I distrust TH for the same reason I distrust Lisp macros.  Thats not to say it isn't sometimes useful, but its a last resort.
15:14:42 <jethr0> hmm, but it's kinda painful (at least to me), so i don't have to restrain myself too badly not to use it
15:16:09 <PaulAJ> Goodnight all.
15:16:15 <jethr0> night
15:16:43 <syntaxfree> how hard to learn is TH?
15:17:20 <jethr0> soso, you can have a look at my tutorial, though :)
15:17:52 <jethr0> it's basically easy, because you are only modifying a tree structure which holds the AST
15:18:34 <jethr0> http://www.haskell.org/hawiki/TemplateHaskellTutorial
15:18:35 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki
15:21:04 <jethr0> there's another tutorial by bulat which you can find at the wiki page
15:21:08 <jethr0> @wiki Template_Haskell
15:21:09 <lambdabot> http://www.haskell.org/haskellwiki/Template_Haskell
15:24:22 <sorear> I feel stupid ...
15:24:33 <jethr0> how's that?
15:24:35 <sorear> you remember @source Prelude?
15:25:03 <sorear> the command which generated links to code-on-darcs.haskell?
15:25:06 <sorear> @help source
15:25:07 <lambdabot> source name. Read a file of commands (asynchonously)
15:25:13 <jethr0> hm
15:25:15 <sorear> name collision!
15:25:50 <jethr0> :( how?
15:26:20 <sorear> I created a second command named @source
15:26:26 <sorear> @list dummy
15:26:26 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs fptools
15:26:50 <sorear> oh, it doesn't even show up on the dummy-list anymore...
15:26:55 <sorear> @list offlinerc
15:26:56 <lambdabot> offlinerc has no visible commands
15:26:56 <jethr0> @get-shapr
15:26:57 <lambdabot> shapr!!
15:27:33 <glguy> ?faq -- i like this one
15:27:34 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:40 <glguy> ?map
15:27:40 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:27:43 <syntaxfree> hahahahaha
15:27:44 <syntaxfree> cooooool
15:27:54 <jethr0> ?faq how do i get String out of IO String
15:27:55 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:56 <sorear> @activity 999
15:27:57 <lambdabot> 568*total 345*#haskell 34*sorear 29*#gentoo-uy 27*Jaak 20*xerox 15*glguy 15*#haskell.it 11*dgoldsmith 11*Z4rd0Z 9*Binkley 9*#perl6 7*#haskell.hac07 6*Samus_ 5*monochrom 3*astrolabe 2*putter 2*pejo 2*
15:27:57 <lambdabot> notsmack 2*dons 2*Saizan 2*Lemmih 2*#oasis 1*offlinerc:null 1*vincenz 1*shapr 1*nickserv 1*huschi_ 1*allbery_b 1*#haskell.es 1*#Haskell-blah
15:28:16 <sorear> ever wonder who's hogging the bot? :)
15:28:40 <syntaxfree> hmm. so Template Haskell basically defines an AST for Haskell, or one was available from the language definition on?
15:28:53 <sorear> former, I believe
15:29:09 <jethr0> it's (unfortunately) a different AST from Language.Haskell
15:29:43 <jethr0> but i think they should be unified
15:30:18 <sorear> Cannot unify Language.Haskell.Expr with ...
15:30:20 <sorear> :)
15:30:49 <jethr0> but, IMHO they should be pretty "easily" isomorphic
15:31:14 <sorear> Fri Jan 12 08:47:32 PST 2007  Ian Lynagh <igloo@earth.li>
15:31:19 <sorear>   * Add a warning for tabs in source files
15:31:20 <sorear> Shall I pull this patch? (2/2)  [ynWvpxqadjk], or ? for help: y
15:31:22 <jethr0> they have almost 100% congruent structure (obviously), but there are slight differences
15:32:13 * sorear is running his daily darcs pull
15:33:16 <sorear> @where binary
15:33:17 <lambdabot> http://darcs.haskell.org/binary
15:33:22 <shapr> jethr0: You called?
15:33:40 <jethr0> i just love the lambdabot command :)
15:33:43 <shapr> :-)
15:33:52 <jethr0> nice to see you, hope i didn't interrupt anything important
15:34:16 <jethr0> how's the happs tutorial coming along?
15:34:23 <sorear> I found the problem with @source, it's a massively dumb mistake on my part
15:34:25 <syntaxfree> @yow
15:34:26 <lambdabot> What UNIVERSE is this, please??
15:34:58 <jethr0> @. elite yow
15:34:58 <lambdabot> what A C0in(iD3n(3! I'/\/\ 4N 4uT|-|0risED "snOoTz 0ph 7|-|3 5tArz" de41er!!
15:35:13 <syntaxfree> oh, fuck. is that possible now?
15:35:17 <dmhouse> sorear: what was the problem?
15:35:25 <dmhouse> syntaxfree: that's been possible forever.
15:35:27 <syntaxfree> @. elite pl f x = x + 1
15:35:27 <lambdabot> ph = (1 +)
15:35:33 <syntaxfree> tee hee.
15:35:37 <syntaxfree> @help @.
15:35:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:35:39 <sorear> dmhouse: there are two commands named 'source'
15:35:42 <syntaxfree> @help .
15:35:42 <shapr> jethr0: My sister's birthday party is now, so I'll be back tomorrow with more tutorial.
15:35:42 <lambdabot> . <cmd1> <cmd2> [args].
15:35:43 <lambdabot> . [or compose] is the composition of two plugins
15:35:43 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
15:35:50 <jethr0> @. elite vixen what is your name
15:35:51 <lambdabot> my Na/\/\3 i5 3/\/\i1y
15:35:59 <sorear> @help source  --- this is for you dmhouse
15:35:59 <lambdabot> source name. Read a file of commands (asynchonously)
15:36:01 <syntaxfree> @. pl unpl \x->x+1
15:36:01 <lambdabot> (1 +)
15:36:08 <jethr0> shapr: k, have lots of fun
15:36:11 <syntaxfree> @. unpl pl f x = x+1
15:36:12 <lambdabot> f a = 1 + a
15:36:18 <dmhouse> sorear: ah.
15:36:38 <syntaxfree> @. unpl pl f x = x^3 - 12*x
15:36:38 <lambdabot> f = (\ f -> f ^ 3) >>= \ b -> (\ g -> 12 * g) >>= \ a -> return (b - a)
15:36:56 <sorear> dmhouse: (too lazy to recheck the logs) were you the one who couldn't use @source earlier
15:37:02 <syntaxfree> @. elite  @. unpl pl f x = x^3 - 12*x
15:37:02 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ""
15:37:07 <syntaxfree> :'(
15:37:14 <dmhouse> sorear: nope, don't think so.
15:37:19 <allbery_b> no @ internally, that's just a prefix to get lbot's attention
15:37:22 <Cale> @. elite . unpl pl f x = x^3 - 12*x
15:37:22 <lambdabot> ph = (\ f -> F ^ 3) >>= \ B -> (\ g -> 12 * 9) >>= \ A -> R3Turn (B - 4)
15:37:54 <syntaxfree> @elite elite haskell!
15:37:54 <lambdabot> 3liTe |-|45KEl1!
15:38:16 <sorear> @source /etc/passwd
15:38:17 <lambdabot> Not enough privileges
15:38:30 <syntaxfree> @source ./.bashrc
15:38:30 <lambdabot> Not enough privileges
15:38:40 <jethr0> oh :(
15:38:43 <syntaxfree> @source of sorear's privileges.
15:38:43 <lambdabot> Not enough privileges
15:39:01 <sorear> nobody is privileged now :(
15:39:29 <sorear> I changed the procedure for privileging people and forgot to tell dons :(
15:40:01 <jethr0> haha
15:40:33 <jethr0> sorear: so it's not hardcoded any more?
15:40:56 <syntaxfree> @. elite . elite . elite elite Will this even survive?
15:40:56 <lambdabot> \/\/i1| +|-|is Ev3n $uR\/i\/3?
15:41:03 <sorear> OTOH, this means I've gotten to the point where dons doesn't bother to read my patches before applying them, which is kinda a compliment :)
15:41:07 <sorear> jethr0: correct.
15:41:16 <sorear> admins can say: @admin + jethr0
15:41:33 <sorear> there is also now a lambdabotrc file
15:41:38 <dmhouse> ?tell kowey I'm almost done with [[Haskell/Category theory]], some diagrams would be lovely, you feel like knocking some up? Seeing as you did those great ones for the monad articles :) http://www.cs.toronto.edu/~sme/presentations/cat101.pdf has some nice ones.
15:41:39 <lambdabot> Consider it noted.
15:41:42 <jethr0> sorear: let's hope it's still that way :)
15:42:35 <monochrom> How did you discover Steve Easterbrook's slides?
15:43:04 <dmhouse> > maxBound :: Int64
15:43:05 <lambdabot>  9223372036854775807
15:43:37 <dmhouse> > let yrs = (maxBound :: Int64) `div` 86400 in 1970 + yrs
15:43:39 <lambdabot>  106751991169270
15:43:42 <dmhouse> Great.
15:44:21 <allbery_b> erm, 86400 would be days, no?
15:44:31 <monochrom> oh haha
15:44:47 <jethr0> > 365 * 24 * 60 * 60
15:44:49 <lambdabot>  31536000
15:44:54 <dmhouse> Oops.
15:44:54 <jethr0> > 365 * 24 * 60
15:44:56 <lambdabot>  525600
15:45:03 <dmhouse> > let yrs = (maxBound :: Int64) `div` (86400 * 365) in 1970 + yrs
15:45:05 <lambdabot>  292471210647
15:45:09 <dmhouse> Still good enough. :)
15:45:17 <monochrom> I have memorized 86400.
15:45:17 <sorear> dmhouse: what'cha trying to do  ?
15:45:22 <sorear> me too!
15:45:28 <jethr0> no magic numbers!
15:45:29 <dmhouse> monochrom: every programmer worth their salt has :)
15:45:29 <Cale> @wiki Category_Theory
15:45:30 <lambdabot> http://www.haskell.org/haskellwiki/Category_Theory
15:45:36 <sorear> I've even memorized 1440 and 168 and 1728
15:45:46 <dmhouse> Cale: if you're refering to my ?tell kowey, I meant on the wikibook.
15:45:54 <Cale> ah
15:46:09 <dmhouse> sorear: in HAppS, there's a type EpochTime = Int64. I wanted to figure out the maximum date I could record.
15:46:20 <monochrom> I have also memorized the answer to map (2 ^) [0..16]
15:46:27 <Cale> If you need diagrams, use xypic
15:46:37 * sorear feels superior
15:46:54 <sorear> 131072, 262144, 524288, 1046576
15:47:04 <dmhouse> Cale: kowey has some nice Mac program that does them. http://en.wikibooks.org/wiki/Haskell/Understanding_monads for examples.
15:47:06 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
15:47:09 <Cale> which is a latex package for drawing category theory diagrams. It makes things pretty easy. It's rather like the syntax for matrices, only annotated to add the arrows.
15:47:26 <monochrom> I played with computers in the 80s.  16 bits ought to be enough. :)
15:47:44 <Cale> oh, I thought you were referring to the other sort of diagrams :)
15:47:44 <dmhouse> Cale: ah, well I don't really want diagrams in the CT sense, but rather some pictures to make the concepts clearer, like in the PDF I linked to.
15:48:09 <Cale> In that case, check out Inkscape
15:48:12 <monochrom> I sympathize with you poor young generation who need to memorize like 9223372036854775808!
15:48:15 <dmhouse> ?tell kowey I didn't mean diagrams in the CT sense, but rather some pictures to make the concepts clearer, like in that PDF I linked to.
15:48:16 <lambdabot> Consider it noted.
15:48:48 <dmhouse> Cale: but what did you use for your fold diagrams?
15:48:50 <Cale> It's getting close to being as good as Illustrator, at least for my needs.
15:48:55 <Cale> Inkscape
15:49:14 <Cale> In fact, it's better than Illustrator at some things
15:49:44 <sorear> you don't use gpic? :)
15:49:44 <cona1> ?src cofmap
15:49:45 <lambdabot> Source not found. Where did you learn to type?
15:49:50 <cona1> :)
15:50:04 <dmhouse> There's such a thing as Cofunctors?!
15:50:05 <cona1> is Cofunctor/cofmap in any std library?
15:50:09 <sorear> conal: there is no class of contravariant functor.
15:50:16 <sorear> dmhouse: yes!!!!
15:50:21 <Cale> dmhouse: contravariant functors
15:50:28 <dmhouse> I just thought you got covariant and contravariant functors.
15:50:29 <dmhouse> Ah, okay.
15:50:36 <cona1> i'm using it in a library i'm making.  i'd rather use a std one than my own.
15:50:39 <sorear> class Cofunctor x where cofmap :: (a -> b) -> x b -> x a
15:50:42 <Cale> Normally both are just referred to as "functor"
15:50:48 <dmhouse> Yeah, functors that flip the morphisms.
15:50:53 <Cale> right
15:51:08 <sorear> but in haskell we need a different name because of typing.
15:51:20 <jethr0> wouldn't that only work for reversible functions?
15:51:21 <sorear> or we could use Church-style booleans...
15:51:26 <sorear> no
15:51:37 <Cale> For the purposes of telling computers about them, it's probably best to use another name anyway
15:51:51 <Cale> Humans have no problem disambiguating based on context
15:51:57 <sorear> jethr0: cofmap_on_funs :: (a -> b) -> (b -> c) -> (a -> c) == flip (.)
15:52:07 <sorear> perfectly well-defined.
15:52:21 <cona1> i'm wondering what to do.  I could move my Cofunctor into Control.Cofunctor or some such in my library package, but then someone else do the same, and there'd be a conflict.
15:52:24 <jethr0> ah, my bad
15:52:51 <sorear> conal: split it into a separate library, cabalize it (it's easy), announce on the mailing list.
15:52:59 <cona1> and if i don't use a std module, then there's no point in using the class, since noone else will have instances of the same type class.
15:53:04 <sorear> @google don steward dlist lambda revolution
15:53:06 <lambdabot> http://www.abag.ca.gov/abag/events/estuary/pdfs/SOE_2005_abstracts_poster.pdf
15:53:16 <sorear> @google don stewart dlist lambda revolution
15:53:20 <lambdabot> http://pupeno.com/blog/the-lambda-revolution-episode-v-the-deb-strikes-back/
15:53:20 <lambdabot> Title: The lambda revolution, Episode V, the deb strikes back &mdash; Pupeno's web site
15:53:22 <cona1> sorear: yep, i could certainly do that.  a cabal with only one small module.
15:53:33 <Cale> I think my favourite contravariant functor is the coordinate ring functor.
15:53:43 <cona1> Cale: ??
15:53:45 <sorear> conal: sure!  see 'vty', I've published 1-module packages.
15:54:07 <cona1> sorear: good.  i'll look.  what's the url?
15:54:27 <cona1> sorear: i've been curious what vty is
15:54:34 <sorear> @where vty
15:54:35 <lambdabot> http://members.cox.net/stefanor/vty/
15:54:49 <sorear> curses replacement, has since grown to 2 modules
15:55:06 <sorear> 1.0 was ~150 non-blank non-comment lines
15:55:08 <cona1> oh.  thanks.
15:55:36 <Cale> cona1: do you know what an algebraic variety is?
15:55:46 * sorear wonders what use conal has for contravariant functors
15:57:31 <cona1> sorear: i've been working on a library for composable "interfaces" to functional values, including GUIs and IO.
15:57:57 <sorear> sounds fun
15:58:02 <cona1> the "interfaces" are typed consumers of typed value.  consumers are cofunctors.
15:58:51 <cona1> i've been working hard and am coming up on a first release.  it also ties in with my eros project: http://conal.net/papers/Eros/
15:58:53 <lambdabot> Title: Functional Programming by Interacting with Tangible Values
15:59:01 <sorear> uh huh, uh huh, uh huh... I think I'll wait to see the code before understanding it :)
15:59:14 <cona1> and is built on top of Phooey: http://conal.net/phooey
15:59:16 <lambdabot> Title: Phooey: A Functional UI Library
15:59:33 <cona1> sorear.  right.  coming soon.  i'm pretty excited about it.
15:59:40 <sorear> eros == EROS ?  (the Extremely Reliable Operating System, an AFAIK dead project)
15:59:53 <Cale> If F is a field, and S is a set of polynomials in F[x_1, x_2,..., x_n], then V(S) is the set of points x in F^n such that for all f in S, f(x) = 0. Such a set V(S) is called an affine, algebraic variety in F^n.
15:59:54 <cona1> sorear: no -- see the url.
15:59:58 <syntaxfree> if you thought Haskell had pedantic maths: http://pll.cpsc.ucalgary.ca/charity1/www/home.html
15:59:59 <lambdabot> Title: CHARITY - Home Page
16:00:00 <cona1> (above)
16:00:46 <Cale> Given an algebraic variety V(S), the set of polynomials in K = F[x_1,...,x_n] vanishing on V(S) is an ideal of the ring K.
16:01:17 <sorear> Cale: a slight generalization of that def sounds like it would make a useful generalization of the algebraic numbers. </ramble>
16:01:18 <Cale> I(V(S)) = { f in K : f(x) = 0 for all x in V(S) }
16:01:55 <cona1> Cale: thanks.
16:01:57 <Cale> The coordinate ring corresponding to a variety V(S), is A(V(S)) = K/I(V(S))
16:02:23 <Cale> The properties of this ring correspond really really nicely with the geometric properties of the variety.
16:02:24 <syntaxfree> Cale: is a variety the same as a manifold?
16:02:35 <Cale> Not quite, but they're related.
16:02:39 <syntaxfree> I often see "manifold" translated to "variedade".
16:02:46 <Cale> Some manifolds are varieties.
16:02:58 <syntaxfree> (which is the natural translation of 'variety')
16:03:03 <Cale> For a simple example
16:03:08 <cona1> hey -- i'd love to get some input on a choice for where in the module hiearchy to put my library.
16:03:15 <Cale> Let S be the set {x^2 + y^2 - 1}
16:03:25 <sorear> a manifold is a type of space, which has only one dimensionality and no self-intersections
16:03:32 <Cale> then V(S) is the unit circle (assuming F = R)
16:04:03 <Cale> sorear: hm?
16:04:05 <sorear> conal: what does it do?
16:04:12 <Cale> sorear: that's an odd definition :)
16:04:53 <sorear> It's a definition thats been feed through my understanding, my literal memory gave a not found :)
16:05:00 <cona1> sorear: composable interfaces.
16:05:16 <cona1> but not necessarily user interfaces.
16:05:17 * sorear supposes the code would explain better...
16:05:36 <Cale> It's probably a restricted definition given to you in some more restrictive context.
16:05:37 <dmhouse> Cale, thanks for the Inkscape recommendation, it's brilliant :)
16:05:42 <Cale> dmhouse: yeah :)
16:05:45 <cona1> i'll copy the haddock intro doc to the web.
16:05:57 <sorear> hi dcoutts!
16:07:35 <bos> dcoutts: nice hacking on Data.Binary
16:07:47 <Cale> An n-manifold is a (second countable, Hausdorff) topological space where every point has a neighbourhood homeomorphic to an open unit ball in R^n.
16:08:07 * allbery_b 's eyes glaze over
16:08:18 <sorear> that sounds right
16:08:21 <scodil> dcoutts: ping
16:08:30 <mgsloan> dmhouse - yeah, I use it all the time, even done a bit of hacking on it.  Actually, my main project for a few months has been helping to create a new geometry system for inkscape
16:08:31 <Cale> That is, it locally looks like ordinary n-dimensional space
16:08:38 <sorear> much easier to understand with my shiny new topology background :)
16:08:42 <Cale> but globally, it might be connected up differently
16:09:03 <sorear> so a manifold need NOT have the same dimension everywhere?
16:09:07 <Cale> For example, the surface of the Earth was long thought to be flat, because it's locally 2-dimensional.
16:09:13 <Cale> It does
16:09:16 <Cale> n is fixed
16:09:22 <sorear> ok,ok, that's what I though
16:10:56 <cona1> oh glurb.  i switched ssh'es and now i'm not being able to scp to darcs.haskell.org.
16:11:23 <Cale> There are lots of other objects which are called <something> manifolds that generalise that definition in various ways though.
16:11:36 <sorear> do you really need to specify Hausdorff?  i think I can derive global hausdorff from local hausdorff
16:11:49 <Saizan> an example of a surface of a solid that's not a manifold?
16:12:00 <Cale> sorear: possibly not
16:12:32 <sorear> Saizan: probably not. but, e.g, a filled circle is not a manifold
16:12:50 <sorear> since the edges "look like half-planes"
16:12:50 <Cale> Saizan: how about a sphere union with a disc, so that they intersect in a circle
16:13:15 <sorear> Cale: that's not the surface of an object
16:13:23 <Cale> It's its own surface
16:13:42 <sorear> I'm assuming he meant two-boundaries
16:13:53 <Saizan> mmh why?
16:14:06 <Cale> Or simpler, the letter Y
16:14:08 <sorear> two-boundaries in E^3
16:14:28 <Cale> It's not a 1-manifold because there's a point where it's not locally homeomorphic to an interval
16:14:33 * sorear feels his limited knowledge of topology showing
16:14:47 <Cale> (namely, the point where the 3 lines join)
16:15:32 <Cale> Then again, it's not the boundary of something
16:15:38 <Saizan> aah sort of like the union of a plane and a distinct line is not a vector space?
16:15:45 <Cale> yeah
16:15:57 <Cale> You can't mix dimensions
16:16:14 <Cale> also, pick any non-Hausdorff space, or any space which is not second-countable
16:16:21 <Cale> A nice example is the long line
16:16:34 <Cale> Take RxR under lexicographic ordering
16:16:45 <Saizan> uhm
16:16:46 * sorear has been trying to read an abandoned topology text for about a year
16:16:47 <Cale> that is (a,b) < (c,d) if a < c or a = c and b < d
16:16:54 <Cale> and then use the order topology on that
16:17:05 <Cale> You get an incredibly long line :)
16:17:13 <astrolabe> Isn't it the boundary of a sphere with a Y shaped cut?
16:17:16 <sorear> my topology book gave a much more complicated defn of the long line.
16:17:37 <sorear> I felt soo good when I figured out the re-topologized square
16:18:19 <Saizan> and it's not homeomorphic to R?
16:18:28 <Cale> er, right, maybe I wanted R x [0,1)
16:18:29 <sorear> something about well-ordering an uncountable number of open intervals such that each object had a countable number of predecessors...
16:18:32 <Cale> anyway
16:18:35 <Cale> something like that :)
16:18:37 <sorear> Saizan: no
16:18:53 <sorear> for instance, the long line has the fixed point property
16:19:23 <Cale> It's interesting that the long line is connected, but not path connected
16:19:30 * Saizan feels a huge hole in his math background
16:19:34 <Cale> because there are points too far away to be connected by a path
16:19:51 * syntaxfree feels a huge hole in his soul.
16:19:52 <sorear> is "path connected" another name for "arcwise connected"?
16:19:56 <Cale> yeah
16:19:58 * allbery_b is only vaguely halfway following this, sort of
16:20:08 <bos> has the type of ByteString changed since ghc 6.6?
16:20:13 * dmhouse <3 beziers
16:20:13 * allbery_b not a mathie :/
16:20:16 <sorear> there are certain disadvantages to having only read one topology book
16:20:23 <mbishop> allbery_b: got that card?
16:20:25 <Cale> er, almost.
16:20:36 <allbery_b> yes.  just haven't been at work or up to doing much all week
16:20:38 <sorear> i.e. terminology
16:20:41 <Cale> Not quite
16:20:49 * allbery_b stuffs card in backpack, maybe h'll be more human next week...
16:21:22 <Cale> arcwise-connected means that any two distinct points can be joined by an arc, which is a homeomorphism between the unit interval and its image in the space
16:21:48 <Cale> path connected just requires that there be a continuous map from [0,1] to the space which maps 0 to the first point and 1 to the second
16:22:16 <sorear> there are lots of equivalent defns of these things
16:22:20 <cona1> okay, i have a copy of my library docs on a server.  i'd love to get initial comments and some suggestions for where to put it in the module hierarchy.  See http://conal.net/TV/doc/html
16:22:31 <Cale> If a space is Hausdorff, arc connected and path connected are the same
16:22:40 <sorear> I'm rather fond of "every imbedding of the 0-sphere is inessential"
16:22:46 <cona1> and from there, the main module link (Graphics.UI.TV).
16:22:57 <Cale> an example of a space which is path connected, but not arc-connected is the unit interval with the point 0 doubled.
16:23:20 * sorear loves topology
16:24:00 <Cale> You can connect the two 0's with a path, but not an arc, because arcs can't double back on themselves.
16:24:08 <astrolabe> I don't like general topology, all that 'second countable' etc.  I like algebraic topology (what I can remember).
16:24:10 <mbishop> allbery_b: sick?
16:24:26 <falconair>  can someone clue me in about what a combinator library is and how i can create one to solve my own programming problem
16:24:32 <allbery_b> yeh, something's been chwewing me up and spitting me out, repeatedly, the past few weeks
16:24:49 <allbery_b> I thought I was finally getting over it Wed. and yesterday, then came today :/
16:24:57 <mbishop> :\
16:25:02 <mbishop> It's Lupis
16:25:12 * allbery_b needs to make doctor's appointment, this isn't just a stupid cold or something
16:25:18 <sorear> I think my book calls second countability "complete separability".
16:25:22 <Cale> falconair: A combinator library is essentially a library of values representing computations, together with functions which combine those values in various ways.
16:25:23 <mbishop> :P
16:25:36 <sorear> I really ought to read another one, just to get the equivalences down.
16:25:44 <sorear> My book is also 40 yrs old
16:25:59 <falconair> Cale, how is that different from a regular API?
16:26:21 <Cale> falconair: well, most common APIs give you direct tools for solving problems
16:26:39 <xic> is the state monad any good?
16:26:44 <Cale> Combinator libraries tend to give you very very simple tools to start with, and lots of glue to put them together.
16:26:51 <Cale> xic: It's all right :)
16:27:09 <sorear> Parsec is the canonical example.
16:27:09 <allbery_b> take a look at parsec as an example of a combinator library
16:27:12 <allbery_b> heh
16:27:14 <Cale> falconair: I think the best way to see a good example is to read the Parsec documentation
16:27:16 <Cale> yes
16:27:17 <Cale> hehe
16:27:33 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
16:27:41 <falconair> Cale: are there specific rules like combinators' input and output are the same (there for all combinators are 'combinable'?
16:27:44 <bos> what's the ghc flag to give me what cabal calls MultiParamTypeClasses?
16:27:51 <xic> i have some simple functional code, but it's kind of complicated since i need to pass in lots of shit and return lots of shit... i'm wondering if state monad can make things simpler.
16:27:55 <falconair> Cale: i've scanned parsec and financial contracts
16:27:55 * sorear wonders how much topology has changed in the last 40 yrs
16:28:00 <sorear> -fglasgow-exts
16:28:07 <Cale> It gives you a bunch of very simple parsers, together with ways to form a parser for the concatenation of languages, or the disjunction of languages
16:28:12 <bos> that's all? cool! thanks.
16:28:21 <mbishop> allbery_b: well, get better :P
16:28:37 * allbery_b wants to, this is both boring and frustrating
16:28:45 <Cale> and from these, you get things like many, which is a function that turns a parser into one which parses zero or more copies of itself
16:29:17 <astrolabe> sorear: I don't suppose the fundamentals have changed much.
16:29:35 <Cale> and sepBy, which parses zero or more occurrences of one language separated by copies of another
16:29:47 <Cale> So it turns into a language of parsers.
16:30:08 <Cale> You get some level of closure of the operations
16:30:22 <falconair> Cale: what i'm trying to figure out is, is development of combinator libraries basically an art or are there some rules of thumb?  (like designing a relational database schema may require experience and expertise but there are some rules, such as normal forms, to help out those who are just starting out)
16:30:24 <Cale> anyway, I have to go to supper, bbiab
16:30:33 <falconair> ok, thanks Cale
16:30:38 <bd_> xic: Depends on the problem; Reader is something you may want to look into as well
16:30:48 <Cale> falconair: the rules of thumb we currently like to use are called monads and Hughes arrows.
16:33:32 <bd_> xic: what values are you passing in and out?
16:34:15 <mgsloan> hmm, where are those shell commands implemented in haskell?
16:34:45 <xic> bd_: right now my function looks like :: Request -> IO (Maybe Response)
16:34:58 <xic> bd_: Request and Response are record types with a fiew fields
16:36:06 <sorear> @where h4sh
16:36:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
16:36:35 <bd_> hmm, maybe something like ReaderT Request (MaybeT IO Response)? Depending on the semantics you need of course - using a MaybeT (which isn't in the mtl but easy to implement and really should be) would halt IO processing as soon as it hits a mzero
16:37:02 <ClaudiusMaximus> cona1: i glanced through the eros.pdf, looks *awesome* (i use Pure-data and GridFlow quite a bit, but they are imperative/stateful/side-effectful...) [ http://gridflow.ca http://puredata.org ]
16:37:03 <lambdabot> Title: home page of GridFlow
16:37:09 <cona1> @src fmap
16:37:10 <lambdabot> Source not found. My pet ferret can type better than you!
16:37:12 <bd_> alternately if you want to sort of build up a response maybe ReaderT Request (StateT (Maybe Response) IO ()) with some accessors
16:37:13 <sorear> does anyone here have experience setting up ircds?
16:37:14 <bos> how do i view diffs of old changes in darcs?
16:37:20 <sorear> darcs changes -v
16:37:31 <xic> bd_: well, the thing is, most of these functions won't need to know the value of the Request
16:37:34 <bos> sorear: thanks!
16:37:39 <sorear> yw!
16:37:43 <cona1> ?src fmap
16:37:44 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:37:49 <bd_> xic: yeah, the Reader monad basically hides a passed-in argument in a monad
16:37:51 <sorear> ?src Functor
16:37:52 <lambdabot> class  Functor f  where
16:37:52 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:37:55 <xic> bd_: so it would be cool if some sort of monad were use so that if a function did need the value, it could do r <- getRequest
16:38:04 <bd_> xic: that's reader exactly :)
16:38:08 <dmhouse> mgsloan: ping
16:38:11 <cona1> sorear: thanks.  which module?
16:38:19 <mgsloan> dmhouse: pong
16:38:19 <sorear> cona1: Prelude
16:38:19 <bd_> xic: type Reader a r = a -> r; there's a ReaderT which is marginally more complex
16:38:39 <bd_> xic: You can use ask :: Reader r r, or asks :: (a -> r) -> Reader a r
16:38:40 <xic> bd_: but if i use Reader, then how will it work together with IO?
16:38:40 <sorear> ?src Reader
16:38:41 <lambdabot> Source not found. Are you on drugs?
16:38:52 <sorear> xic: ReaderT r IO
16:38:53 <dmhouse> mgsloan: mind if I bug you quickly with an Inkscape question? #inkscape is dead.
16:38:56 <bd_> xic: The mtl has a ReaderT which you can place on top of IO
16:39:03 <xic> what's mtl?
16:39:05 <bd_> :t runReaderT
16:39:07 <lambdabot> forall a (m :: * -> *) r. ReaderT r m a -> r -> m a
16:39:10 <bd_> the Monad Template Library
16:39:13 <cona1> sorear: thanks.  I'm wondering where in the hierarchy to place a Cofunctor module.  any preferences?  Data.Cofunctor ?
16:39:17 <bd_> it has a bunch of useful monads pre-implemented for you
16:39:18 <dmhouse> xic: the monad template library, a library of lots of useful monads.
16:39:24 <dmhouse> mgsloan: I'll be quick :)
16:39:31 <sorear> cona1: that sounds as good as any
16:39:41 * mgsloan switches to #inkscape :P
16:39:46 <cona1> sorear: am i showing up as "cona1"??
16:39:48 <bd_> xic: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
16:39:51 <lambdabot> http://tinyurl.com/y5j3az
16:39:55 <sorear> cona1: yes
16:40:04 <sorear> cona1: why don't you use conal?
16:40:15 <sorear> @seen cona1
16:40:16 <lambdabot> cona1 is in #haskell. I last heard cona1 speak 29s ago.
16:40:23 <sorear> @seen conal
16:40:24 <lambdabot> I saw conal leaving #haskell 1h 11m 14s ago, and .
16:40:33 <bd_> and?
16:40:38 <xic> bd_: is mtl part of ghc?
16:40:43 <cona1> sorear: oh, when i left home and came to this wi-fi cafe.
16:40:50 <bd_> xic: mtl is part of GHC's 'extralibs' package as of 6.6
16:41:01 <xic> bd_: ok nice
16:41:21 <sorear> ah, so you don't want to use your registered nick because of password insecurity ?
16:41:29 <bd_> Why isn't a MaybeT in mtl, anyway...?
16:42:44 <glguy> while comparing Bitstream Vera Mono and Lucidia console...
16:42:46 <conal> sorear: i don't know what happened.  oh, wait.  i switched clients from trillian to gaim.  i guess i lost my /nick command in the process.
16:42:50 * glguy notes that the fonts are extremely similar
16:43:28 <sorear> conal: I thought it was delibarate :)
16:43:45 <conal> nah.  :P
16:43:49 <conal> :p
16:43:56 <sorear> A command named 'source' read a file of commands.
16:44:03 <sorear> there is a name collision.
16:44:17 <sorear> I'm drawing a blank on other standard names.
16:44:25 <sorear> @...
16:44:26 <lambdabot> Not enough arguments to @.
16:44:45 <conal> sorear: what are you talking about now??
16:44:54 <sorear> @source Prelude
16:44:55 <lambdabot> Not enough privileges
16:44:59 <sorear> @help source
16:44:59 <lambdabot> source name. Read a file of commands (asynchonously)
16:45:11 <sorear> I accidentally shadowed the find-source-code command.
16:45:21 <allbery_b>  @rc?
16:45:33 <allbery_b>  @read?
16:45:41 <allbery_b>  @exec?
16:45:48 <glguy> ?repoint (concat . ) . map
16:45:48 <lambdabot> (\ d g -> concat (map d g))
16:45:48 <sorear> read sounds good thanks
16:45:53 <allbery_b> ...suppose that would be snchrnous though
16:45:57 <conal> what's with ? vs @ prefixes for chatting with lambdabot?
16:46:06 <glguy> conal: personal preference
16:46:09 <sorear> oh wait, @read is taken
16:46:20 <conal> glguy: both work?
16:46:21 <allbery_b> @script?
16:46:22 <lambdabot> Unknown command, try @list
16:46:26 <sorear> @read "hi"
16:46:27 <lambdabot>  hi
16:46:29 <allbery_b> bah, missed the spacebar
16:46:32 <glguy> the only s command is scheck
16:46:39 <allbery_b>  @src
16:46:47 <sorear>  @source
16:46:51 <allbery_b> whch is the problem
16:46:52 <sorear>  @spell
16:46:53 <glguy> hmm... does src not have a COMMANDS list?
16:47:01 <glguy> WHOA ignore that last command
16:47:08 <sorear> the COMMANDS list is fairlyh old
16:47:16 <glguy> I must have done something wrong, tab completion shows them now
16:47:21 <glguy> last comment*
16:47:37 <glguy> ?shootout
16:47:37 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:47:40 <sorear> do you see @activity or @admin yet?
16:47:47 <sorear> @listservers
16:47:47 <glguy> nope
16:47:48 <lambdabot> freenode
16:48:04 <glguy> COMMANDS isn't automatically generated?
16:48:33 <sorear> it is, but dons has to invoke the regeneration manually
16:48:40 <glguy> oh
16:48:54 <conal> anyway, if anybody is up for it, i'd appreciate some suggestions for a module hierarchy location for my interaction library.  there's an intro at http://conal.net/TV/doc/html/Graphics-UI-TV.html, with api docs and source pointers.
16:49:03 <mgsloan> anyone know where the linux-commands-as-haskell-functions are?
16:49:28 <mahogny> system?
16:49:32 <allbery_b> @where h4sh
16:49:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
16:49:39 <mahogny> aha
16:49:41 <dibblego> ?hoogle (a -> b) -> a -> IO b
16:49:42 <lambdabot> No matches, try a more general search
16:50:01 <dibblego> ?hoogle Monad m => (a -> b) -> a -> m b
16:50:02 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:50:02 <sorear> dibblego: fmat return
16:50:02 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:50:02 <lambdabot> Prelude.(.) :: (b -> c) -> (a -> b) -> a -> c
16:50:05 <sorear> dibblego: fmap return
16:50:13 <sorear> :t fmap return
16:50:15 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Functor f, Monad m) => f a -> f (m a)
16:50:16 <dibblego> ah yeah thanks
16:50:22 <mgsloan> ah, thanks
16:50:39 <sorear> :t (.return)
16:50:41 <lambdabot> forall (m :: * -> *) a c. (Monad m) => (m a -> c) -> a -> c
16:50:45 <twanvl> ?type (return .)
16:50:46 <sorear> :t (return.)
16:50:47 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
16:50:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
16:50:54 <conal> mahogny: was your "system?" aimed at my request?
16:50:58 <sorear> ah, 2 char shorter :)
16:51:15 <mgsloan> ah, no, I meant linux commands implemented in haskell, like grep, etc
16:51:27 <mahogny> conal, no, mgsloan
16:51:35 <conal> mahogny: thx
16:51:36 <mahogny> mgsloan, grep etc you will not find
16:51:51 <twanvl> http://haskell.org/haskellwiki/Simple_unix_tools
16:51:52 <lambdabot> Title: Simple unix tools - HaskellWiki
16:51:56 <mgsloan> well, not fully. maybe just find and such
16:51:58 <mgsloan> ah, thanks
16:51:59 <mahogny> mgsloan, but more basic commands like rm are of course in
16:53:05 <dibblego> :t (.)
16:53:07 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
16:53:44 <twanvl> conal: Graphics.UI seems fine to me
16:55:25 <conal> twanvl: i was okay with that choice when it was about user interfaces, but now it's much more general.  only 10 or so lines of GUI-related code.
16:57:01 <sorear> Control.TV ?
16:57:05 <conal> type classes allow such generality that it's hard to categorize things.  for instance, Arrow & Monad are under Control, but they're not really about control.  much more general
16:57:26 <conal> which is why i don't like the word "do".
16:57:43 <monochrom> Yeah, Algebra.Monad is more like it.
16:57:44 <twanvl> But (CLI|G)UIs are still the intendent use, right?
16:58:05 <conal> sometimes i want to say "be" instead of "do" !
16:58:14 <conal> that's why i program in haskell
16:58:18 <monochrom> But programmers being programmers, they despise math and embrace operations.
16:58:49 <dmhouse> ?tell kowey actually, never mind, I whipped a few up myself, tell me what you think. :)
16:58:50 <lambdabot> Consider it noted.
16:58:53 <conal> monochrom: maybe that's only because computers program people as much as vice versa.
16:59:14 <dmhouse> ?tell Cale thanks again for the Inkscape recommendation; you can see my handiwork at http://en.wikibooks.org/wiki/Haskell/Category_theory
16:59:14 <lambdabot> Consider it noted.
16:59:23 <Cale> cool
16:59:23 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
16:59:28 <Cale> heh
17:00:04 <sorear> @remember conal monochrom: maybe that's only because computers program people as much as vice versa.
17:00:04 <lambdabot> Done memoising quote for `conal', if that is their real name...
17:00:45 <conal> sorear: thx.  my first lambdabot quote!
17:01:05 <monochrom> Each field of endeavour attracts people of a certain personality trait.
17:01:05 <conal> afaik
17:01:09 <glguy> "if that is their real name..."? Where are the grammar Nazis?
17:01:36 <monochrom> Computing tends to attract control freaks and those who hate to document things.
17:01:39 <sorear> alas we only have @nazi-on, the spelling nazi
17:01:41 <allbery_b> "their" as genderless pronoun dates back to the 16th century, what's the problem?
17:01:48 <sorear> @quote conal
17:01:49 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
17:01:50 <sorear> @quote conal
17:01:51 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
17:01:52 <sorear> @quote conal
17:01:52 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
17:01:53 <sorear> @quote conal
17:01:54 <lambdabot> conal says: monochrom: maybe that's only because computers program people as much as vice versa.
17:02:17 <conal> i guess that's it.
17:02:21 <monochrom> I think this channel went through a thorough debate about "they" a while ago, precisely for this.
17:02:26 <sorear> conal: btw, the lambdabot quotes are what gets into hwn.
17:02:46 <conal> sorear: oh, i didn't realize that.
17:03:24 <sorear> so not everyone gets a HWN-quote on their first week in #haskell? :)
17:03:44 <jcreigh> hmm, really? But ISTR seeing quotes in HWN from blog postings and such.
17:04:01 <vincenz> sorear: woah stop
17:04:07 <sorear> jcreigh: lambdabot has quotes from blog postings
17:04:16 * allbery_b got quoted and then a bot crashh lost it, oh well
17:04:18 <sorear> even some way older
17:04:22 <sorear> @quote knuth
17:04:22 <lambdabot> knuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
17:04:22 <lambdabot> might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
17:04:29 * vincenz pokes sorear 
17:04:44 * sorear turns...
17:05:28 <conal> there's the gandhi quote "Never confuse what is habitual with what is natural".  applies to programming and personal communication (plug: http://awakeningcompassion.com/)
17:05:30 <lambdabot> Title: Awakening Compassion Home
17:06:50 <Botje> ehm
17:06:58 <Botje> knuth predicted 20 years before fact? ouch.
17:07:05 <Botje> *python
17:08:09 <allbery_b> less than that, first version of python I saw was released in 1987
17:09:02 <Botje> that's still 13 years
17:09:29 <Excedrin> is python the first language that uses indentation to express local structure?
17:09:41 <bos> no.
17:09:48 <Botje> whitespace beat it :P
17:09:54 <sorear> ABC IIRC
17:10:06 <sorear> Miranda perhaps earlier
17:10:22 <sorear> did SASL use a layout rule?
17:10:45 <sorear> but GvR has confessed to taking indentation from ABC specifically
17:11:24 <Excedrin> COBOL uses significant whitespace, but I don't think it counts
17:11:38 <sorear> FORTRAN!
17:12:38 <jcreigh> I don't know of any language that doesn't use whitespace to some extent. (excluding esoteric/joke languages.)
17:12:45 <bos> fortran notoriously doesn't care about whitespace at all.
17:13:02 <Botje> jcreigh: perl :p
17:13:06 <bos> well, it uses it a tiny bit.
17:13:11 <sorear> jcreigh: Brainfsck
17:13:14 <mbishop> I prefer haskells idea of layout to pythons force indentation stuff
17:13:18 <Excedrin> what about Self?
17:13:35 <jcreigh> sorear: How is BF *not* an esoteric/joke language? :)
17:13:56 <sorear> jcreigh: sorry, I misread "excluding" as "including"
17:14:17 <mgsloan> jcreigh - whitespace itself is an esoteric/joke language :)
17:14:35 <Excedrin> I guess KRC predates Miranda
17:14:49 <sorear> Even the mighty INTERCAL uses whitespace.
17:15:01 <sorear> of course, in a confusing and inconsistant way
17:15:10 <glguy> did you guys cover COBOL?
17:15:18 <sorear> <Excedrin> COBOL uses significant whitespace, but I don't think it counts
17:15:33 <glguy> ah (I just got back from an afk)
17:15:49 <bd_> jcreigh: Well, most languages use spaces as delimiters I guess. Probably the minimal usage in a 'real' language would be lispy usage
17:19:12 <mgsloan> is (error "blah") the same as (hPutStrLn stderr "blah")?
17:19:23 <mgsloan> ?src error
17:19:24 <lambdabot> error s = throw (ErrorCall s)
17:19:30 <mgsloan> hmm, i guess not
17:19:40 <mgsloan> ?src throw
17:19:41 <lambdabot> throw exception = raise# exception
17:19:58 <mgsloan> yeah, I'm dumb.  the stderr would be IO
17:20:00 <Excedrin> does ISWIM count?
17:20:12 <bd_> ?src raise#
17:20:13 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:20:24 <bd_> tsk, doesn't extract C source from the RTS? :)
17:20:30 <mgsloan> hehe
17:20:34 <glguy> ?src undefined
17:20:34 <lambdabot> undefined =  error "Prelude.undefined"
17:20:57 <mgsloan> that's interesting
17:21:16 <sorear> :t GHC.Prim.raise#
17:21:18 <lambdabot> forall b a. a -> b
17:21:27 <bd_> :t error
17:21:29 <lambdabot> forall a. [Char] -> a
17:21:29 <jcreigh> hmm...is error referentiallly transparent? I mean, error _ = _|_, so does that count?
17:21:34 <bd_> :t throw
17:21:36 <lambdabot> Not in scope: `throw'
17:21:42 <sorear> :t GHC.Prim.throw#
17:21:44 <lambdabot> Not in scope: `GHC.Prim.throw#'
17:21:45 <bd_> > fix raise#
17:21:46 <lambdabot>  Parse error
17:21:46 <sorear> :t GHC.Prim.throwError#
17:21:48 <lambdabot> Not in scope: `GHC.Prim.throwError#'
17:21:54 <sorear> :t GHC.Prim.throwExc#
17:21:56 <lambdabot> Not in scope: `GHC.Prim.throwExc#'
17:21:56 <sorear> :t GHC.Prim.throwExn#
17:21:58 <lambdabot> Not in scope: `GHC.Prim.throwExn#'
17:22:03 <sorear> ?docs GHC.Prim
17:22:04 <lambdabot> GHC.Prim not available
17:22:41 <sorear> http://haskell.org/ghc/dist/current/docs/libraries/base/GHC-Prim.html
17:22:43 <lambdabot> http://tinyurl.com/ygh5a3
17:22:44 <bd_> Prelude GHC.Prim Control.Monad.Fix> raise# ()
17:22:44 <bd_> *** Exception: Segmentation fault
17:22:46 <bd_> heh
17:23:18 <sorear> > array (0,maxBound::Int) [(1,'a')]
17:23:21 <lambdabot> Terminated
17:23:24 <sorear> > array (0,maxBound::Int) [(3,'a')]
17:23:26 <lambdabot>  internal error: END_TSO_QUEUE object entered!
17:23:26 <lambdabot>     Please report this as a bu...
17:24:13 <Z4rd0Z> a lot of people seem to be discouraging the use of do notation, but it seems that most of the documentation out there uses it, which makes it difficult to get out of that mindset
17:24:49 <jcreigh> Z4rd0Z: IMO, do-notation is great, but only when you understand what it's really doing.
17:24:49 <glguy> only discouraging for teaching purposes
17:25:22 <allbery_b> ...and much of that is specifcally because s many tutorials use it and people are ending up confused
17:25:28 <sorear> lots of n00bs ask questions like "what's the type of <-?"
17:25:45 <Z4rd0Z> heh, I asked a question almost like that
17:26:11 <bd_> > let (<-) = undefined in ()
17:26:11 <lambdabot>  Parse error
17:26:13 <bd_> tsk
17:26:46 <Z4rd0Z> I can convert 'do' to >>= sometimes though, so I'm starting to get the hang of it
17:27:32 <Z4rd0Z> learning haskell feels like learning programming all over again (I first learned C)
17:27:39 <bos> @hoogle Word8
17:27:40 <lambdabot> Data.Word.Word8 :: data Word8
17:27:42 <bd_> ?undo do { a <- b; let c = d; e; f c a }
17:27:43 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
17:27:49 <bd_> tsl
17:27:52 <bd_> tsk*
17:27:53 <glguy>  ?undo can't handle let
17:28:07 <glguy> neither can ?run
17:28:09 <bd_> is let in do an extension...?
17:28:11 <bos> @hoogle Int8
17:28:11 <lambdabot> Data.Int.Int8 :: data Int8
17:28:13 <bd_> ?run?
17:28:14 <lambdabot>  Parse error
17:28:22 <bd_> ?run 2 + 2
17:28:24 <lambdabot>  4
17:28:26 <allbery_b> ?run is thwe long form of >
17:28:27 <lambdabot>  Parse error
17:28:30 <bd_> ic
17:28:44 <sorear> actually, it's the layout's fault
17:29:05 <sorear> ?undo do { a <- b; let c = d; e; f c a }  == ?undo do { a <- b; let { c = d; e; f c a } }
17:29:05 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 26}) "Parse error"
17:29:06 <MarcWeber> What is tricky on anyToken in Text.Parsec.Combinator.hs ?
17:29:14 <sorear> the latter obviously makes no sense
17:29:17 <bos> @hoogle ByteArray
17:29:17 <lambdabot> No matches found
17:29:21 <sorear> ?undo do { a <- b; let { c = d } ; e; f c a }
17:29:21 <lambdabot> b >>= \ a -> let { c = d} in e >> f c a
17:29:27 <bd_> ah
17:29:30 <MarcWeber> Do I have missed something? Is'nt this equal to anyChar?
17:29:47 <sorear> MarcWeber: anyToken is more general
17:30:16 <sorear> anyToken can handle lists of Ints, lists of String, lists of file-handles, etc
17:30:22 <sorear> anyChar can handle strings.
17:30:26 <MarcWeber> sure anyChar can just parse a character. I'm rewriting the source position handling so that I can parse command line arguments, too ;)
17:31:05 <MarcWeber> sorear: GenParser vs CharParser. right. If that's all I still don't understand why its called tricky..
17:32:43 <genbie> anyone knows how to match a string in a case expression against a number of names which share the same expression plz? so i want to say: case name of ("John" || "Peter" || james") -> do something)
17:33:14 <genbie> all on the same line
17:33:51 <MarcWeber> genbie: use guards? | name `elem` ["john"] = .. ?
17:34:01 <pejo> Todays lesson: Great research could be improved even more if there were a few examples in the articles, or a technical report available with them.
17:34:15 <sorear> MarcWeber: CharParser == GenParser Char
17:35:28 <genbie> thanks marcweber i am trying to find a web page on guards
17:36:19 <MarcWeber> genbie Do you now yet another haskell tutorial?
17:36:27 <MarcWeber> >where yaht
17:36:37 <allbery_b> ?where yaht
17:36:38 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:36:47 <genbie> yes
17:37:02 <MarcWeber> You can find it there
17:37:20 <genbie> great thanks marc
17:39:53 <MarcWeber> http://rafb.net/p/e0PuoI66.html
17:39:54 <lambdabot> Title: Nopaste - simple guard example
17:41:13 * allbery_b thinks perhaps more to the point might be if name `elem` ["James", ...] then (or case version thereof)
17:42:32 <sorear> @tell dons Plugin.Vixen has type errors with binary-0.2
17:42:32 <lambdabot> Consider it noted.
17:42:39 <allbery_b> although I did use guards for one program instead
17:43:22 <MarcWeber> Sure genbie might use map toUpper on name and map (map toUpper) on the list to get case insensitive comparison
17:44:31 <genbie> i did that marc.. but my problem is in matching against three names on the same line
17:46:14 <MarcWeber> genbie: Did I miss your task?
17:46:44 <genbie> i am trying to find info on the web and the tutorial you mentioned
17:47:05 <glguy> the answer has already been given a few times though
17:47:08 <MarcWeber> genbie look above. I've posted a link.
17:47:31 <genbie> thanks
17:47:47 <MarcWeber> You are welcome :)
17:48:21 <sorear> @where joincabal
17:48:22 <lambdabot> I know nothing about joincabal.
17:48:26 <genbie>  i need to import monads too??
17:49:32 <genbie> OK if i have to understand monads for this then i will get to that stage later i think... now i will just duplicate the same action on seperate lines
17:49:49 * glguy wonders what genbie is going on about
17:50:23 <genbie> i am about that link that marcweber posted ;-)
17:50:28 <glguy> genbie: that code doesn't use those imports
17:50:37 <glguy> notice how none of the code does anything monadic
17:50:49 <glguy> You really should read YAHT
17:50:56 <genbie> http://rafb.net/p/e0PuoI66.html
17:50:57 <lambdabot> Title: Nopaste - simple guard example
17:51:02 <glguy> before you go much further to avoid missing out on a lot of stuff
17:51:16 <genbie> yes i know that but it says on the top of the poage import monads
17:51:43 <glguy> and I just told you that it doesn't do anything monadic, MarcWeber probably just had that in his text editor when he wrote you the example
17:51:56 <genbie> ah ok ;-)
17:51:58 <genbie> thanks
17:51:59 <glguy> if you would read YAHT or something similar you would be more likely to notice that
17:52:03 <glguy> I'm not trying ot be mean
17:52:15 <genbie> i am reading something similar
17:52:22 <glguy> i jus tthink that learning Haskell will be better for you if you are reading something that teachs Haskell
17:52:26 <genbie> but it did not mention anything about guards
17:52:58 <genbie> yes actually i am reading 2 things.. a book and an online tutorial ;-)
17:54:03 <MarcWeber> genbie: Have a look at http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html , too ;)
17:54:08 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
17:54:30 <bos> \@hoogle left
17:54:35 <bos> @hoogle left
17:54:35 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
17:54:36 <lambdabot> Prelude.Left :: a -> Either a b
17:54:36 <lambdabot> Control.Arrow.leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
17:55:08 <genbie> thanks marc
17:56:47 <bos> yay typesafe pickling!
17:56:55 <bos> > unpickle (pickle "foo") :: Either ParseError Int
17:56:55 <bos> Left (ParseError 14 "Data.Pickle: Expected Int, got [Char]")
17:56:56 <lambdabot>   Not in scope: type constructor or class `ParseError'
17:59:39 <mgsloan> hmm, why does ghci file IO always say "resource busy (file is locked)"
18:00:18 <mgsloan> hmm, I must be doing something odd because it says that even if i compile
18:00:46 <allbery_b> had you opened it previously?
18:00:58 <mgsloan> yeah, but that program is no longer running
18:01:00 <allbery_b> laziness and IO interact oddly
18:01:02 <allbery_b> oh
18:01:29 <mgsloan> oh, you mean opened it in the code. nah. here's my code:
18:01:50 <mgsloan> main = getArgs >>= return.head >>= (\n -> readFile n >>= return . unlines . map (takeWhile (/='#')) . lines >>= writeFile n)
18:02:32 <allbery_b> right.  writeFile is trying to open the file while readFile still has it open.  haskell file locking is protecting you
18:02:42 <allbery_b> like I said, laziness and I/O interact oddly
18:02:54 <mgsloan> ohh, its too bad that it can't lazily, atomically overwrite the file
18:03:40 <mgsloan> I better doify it then
18:03:44 <allbery_b> problem is most filesystems don't support that (unless someone's ported ghc to vms or something)
18:04:05 <allbery_b> it doesn't need doification so much as forcing the file contents to be read completely before the writeFile
18:04:53 <mgsloan> hmm, so do I need an explicit close file?
18:05:08 <allbery_b> no, it'll beclosed when it;s completely read
18:05:25 <mgsloan> oh.  So seq would do it then?
18:06:01 <bd_> You could write to a temp file, and then rename after
18:06:06 <monochrom> try to seq the length :)
18:06:14 <bd_> which avoids loading the entire file into memory
18:06:25 <mgsloan> true
18:06:26 <allbery_b> an explicit close would simply close it before you've read data
18:06:41 * allbery_b tried using close to force it, found out it didn't quite work that way :/
18:07:03 <SamB> allbery_b: heh
18:07:19 <monochrom> hmm length may use a lot of stack.  seq its last instead
18:07:52 <bd_> why would length use any more stack than last?
18:07:55 <bd_> ?src length
18:07:56 <lambdabot> Source not found. Do you think like you type?
18:08:07 <SamB> lambdabot: don't be cruel!
18:08:12 <SamB> lambdabot: @vixen don't be cruel!
18:08:13 <lambdabot> so?
18:08:39 <allbery_b> hee
18:08:46 <bd_> > length [0..1000000]
18:08:48 <lambdabot>  1000001
18:08:51 <bd_> > length [0..10000000]
18:08:55 <monochrom> Because the computer is allowed to construct a huge 1+(1+(1+... or (...(1+1)+1)+1 before the summing.
18:08:56 <lambdabot> Terminated
18:09:35 <bd_> monochrom: have more faith in the optimizations in GHC :)
18:09:42 <mgsloan> brb
18:10:01 <monochrom> Also length [0..10000000] may add another level because [0..n] constructs a long chain of succ(succ(succ...
18:10:22 <monochrom> I would test it out before having faith.
18:10:41 <bd_> monochrom: GHC's length implementation is tail-recursive
18:10:49 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/List.lhs
18:10:49 <bos> monochrom: the compiler will deforest stuff like that.
18:11:02 <bd_> genericLength does the 1 + 1 + 1 + ... thing though
18:11:07 <monochrom> However it's subtle to test out.  As I've just shown the test technique may invalidate the test result.
18:12:01 <monochrom> ok at least having lots of #'s is good news.
18:12:08 <bd_> monochrom: also enumFromTo for Int is tail-recursive
18:12:16 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Enum.lhs (implementation at eftInt)
18:12:25 <bd_> well
18:12:29 <bd_> not tail recursive
18:12:50 <monochrom> it's easier to say O(1) space. :)
18:12:52 <bd_> but specialized for Int anyway
18:12:54 <bd_> ehh
18:12:55 <bd_> heh*]
18:13:07 <bd_> if the list is bound somewhere it's O(n) :)
18:13:22 <monochrom> Someone discovered [1..] behaves badly
18:14:00 <monochrom> The mailing list chronicles the whole discussion.  It surprised quite a few experienced Haskellers.
18:14:07 <notsmack> monochrom: badly how?
18:14:25 <monochrom> [1..] constructs a huge succ(succ(succ...
18:14:43 <monochrom> Did you see it on the mailing list?
18:15:04 <stepcut> monochrom: yeah, it took me a while to figure out what was going on, and even then, I could not explain everything :-/
18:15:29 * monochrom feels like Constantine --- "am I the only one seeing spirits?"
18:15:32 <bd_> monochrom: surely enumFromTo is specialised for Int though? oO
18:15:43 <master_bater> did you hear about the dyslexic devil worshipper who sold his soul to santa?
18:16:00 <monochrom> heheh
18:16:05 <bd_> which thread is htis?
18:16:36 <monochrom> The optimized enumFromTo contributed to the surprise because the result is [1..n] is way more optimized than [1..]
18:16:45 * allbery_b recalls seeing it but forgets the topic
18:17:14 <bd_>     enumFrom (I# x) = eftInt x maxInt#
18:17:15 <bd_>         where I# maxInt# = maxInt
18:17:54 <allbery_b> hm.  "Stupid newbie question"?  (on quick scan of mailbox)
18:19:32 <monochrom> most likely
18:19:33 <bd_> ah
18:19:43 <bd_> it's because it's using Integer, I guess?
18:19:54 <monochrom> yeah that contributes to it too
18:20:20 <monochrom> The whole thing is tricky.
18:21:10 <bd_> right, because [1..] in Int is equivalent to [1..maxBound]
18:21:27 <bd_> whereas in Integer it need not worry about bounds
18:22:01 <Saizan> > last [1..] :: Int
18:22:05 <lambdabot> Terminated
18:22:15 <araujo> hello
18:22:18 <bd_> > [1..] !! 1000000
18:22:20 <lambdabot>  Exception: stack overflow
18:22:25 <bd_> > [1..1000001] !! 1000000
18:22:27 <lambdabot>  1000001
18:22:34 <ClaudiusMaximus> bd_: equivalent to [1..maxBound:_|_] ?
18:22:48 <bd_> ClaudiusMaximus: ?
18:23:12 <bd_> I wonder if it'd be a good idea to patch the GHC implementation so enumDeltaInteger x d = x `seq` x : enumDeltaInteger (x + d) d
18:23:55 <bd_> ClaudiusMaximus: from Enum.lhs: "remember that Int is bounded, so [1..] terminates at maxInt"
18:24:10 <ClaudiusMaximus> bd_: ok
18:24:33 <ClaudiusMaximus> bd_: i thought it would overflow, and i seem to remember Int overflow being undefined
18:24:54 <bd_> right, the code goes to some lengths to avoid overflow
18:26:25 <allbery_b> hm.  [1..], or [1 :: Int ..]?
18:26:44 <allbery_b> hrm, probably [(1 :: Int) ..]
18:28:38 <bd_> > head [1 :: Int ..]
18:28:40 <lambdabot>  1
18:29:08 <Stinger_> > last [1 :: Int ..]
18:29:10 <bd_> if the type inferencer can figure it out that works too
18:29:12 <lambdabot> Terminated
18:29:15 <bos> > head [1::Integer..]
18:29:15 <lambdabot>  Parse error
18:29:19 <bos> > head [1::Integer ..]
18:29:20 <lambdabot>  1
18:29:48 <bos> > last (take 1000000 [1::Integer ..])
18:29:49 <lambdabot>  Exception: stack overflow
18:30:49 <bd_> > last [maxBound - 5..maxBound :: Int]
18:30:51 <lambdabot>  2147483647
18:31:12 <quazimodo> @src foldr
18:31:13 <lambdabot> foldr k z xs = go xs
18:31:13 <lambdabot>     where go []     = z
18:31:13 <lambdabot>           go (y:ys) = y `k` go ys
18:31:28 <quazimodo> @src foldr1
18:31:29 <lambdabot> foldr1 _ [x]    = x
18:31:29 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
18:31:29 <lambdabot> foldr1 _ []     = undefined
18:31:41 <quazimodo> why do we want both foldr1 and foldr?
18:31:58 <jcreigh> quazimodo: sometimes you want to fold over non-empty lists.
18:32:11 <ClaudiusMaximus> quazimodo: max::Integer->Integer->Integer
18:32:16 <glguy> > foldr1 (flip const) [1..10]
18:32:18 <lambdabot>  10
18:32:33 <ClaudiusMaximus> > maxBound::Integer
18:32:33 <lambdabot>   add an instance declaration for (Bounded Integer)
18:32:33 <lambdabot>     In the expression: ma...
18:32:52 <bd_> Integer is intentionally unbounded :)
18:33:32 <ClaudiusMaximus> @type min
18:33:34 <lambdabot> forall a. (Ord a) => a -> a -> a
18:34:07 <bd_> > foldr1 min "Hello, world!"
18:34:09 <lambdabot>  ' '
18:34:14 <quazimodo> you guys scare me
18:34:31 <jcreigh> of course, there's always:
18:34:35 <jcreigh> @src minimum
18:34:36 <lambdabot> minimum [] = undefined
18:34:36 <lambdabot> minimum xs = foldl1 min xs
18:34:41 <bd_> quazimodo: Don't be frightened! We don't bite!
18:34:43 <bd_> (much)
18:34:45 <monochrom> foldr needs a seed value for the empty case.  sometimes you don't want to bother.
18:34:53 <quazimodo> hrm
18:34:59 <quazimodo> the seed value scares me too
18:35:06 <jcreigh> quazimodo: how so?
18:35:10 <quazimodo> dno
18:35:18 <quazimodo> im easily scared :P
18:35:26 <monochrom> It's a good sign.
18:35:45 <bd_> > foldr min maxBound "Hello, world!"
18:35:46 <lambdabot>  ' '
18:37:57 <quazimodo> well
18:38:01 <jcreigh> quazimodo: I don't know if this is a hard and fast rule, but it seems like you want to pick the value x, such that for all y, f x y = y. Eg, summing a list, you use 0, because x + 0 = 0. Taking the product of a list, 1, because x * 1 = x. Folding && over a list of Bools, True, because x && True = x. And so on.
18:38:24 <jcreigh> anyone care to comment on whether or not I'm right?
18:38:27 <bd_> jcreigh: It really depends on what you're trying to do with fold
18:38:42 <quazimodo> i see what you mean
18:38:56 <bd_> one way to think of fold is going over a list with a state value; in which case you need just pick an initial state
18:39:09 <bd_> for example, defining map with fold, you  want your state to be [] initially
18:39:22 <glguy> I think of folds as dragging a value through the list
18:39:46 <glguy> but fold1s as actually collapsing the list down
18:39:47 <bd_> > let map f l = foldr (\v l -> (f v):l) [] l in map succ [1,2,3]
18:39:49 <lambdabot>  [2,3,4]
18:39:51 <allbery_b> that's the same thing phrased differently
18:40:10 <jcreigh> s/x + 0 = 0/x + 0 = x/
18:41:15 <glguy> allbery_b: my example wasn't
18:41:19 <glguy> but I don't know if you were talking ot me
18:41:34 <allbery_b> <glguy> I think of folds as dragging a value through the list
18:41:43 <glguy> yeah, the non-1 folds
18:41:52 <allbery_b> same as bd_'s "going over a list with a state value"
18:42:00 <glguy> oh
18:42:06 <glguy> I thought you meant that my two statements were the same
18:42:12 <allbery_b> no, I was just slow
18:42:24 <dino-> Quick question if anybody knows.. Can you get the DPI through the gtk2hs API? Or even with gtk at all?
18:43:06 <allbery_b> it'd be at the gdk level in raw gtk.  no idea baout gtk2hs, which I have yet to get working anywhere :/
18:43:36 <bos> what's the idiom for saying "i can throw one of several kinds of error"?
18:43:56 <dino-> Worst case, I can use something like.. `xdpyinfo | grep resolution:` and parse the number(s) out of it. But, bah.
18:44:31 <bd_> bos: MonadError with a datatype with the appropriate set of constructors?
18:44:34 <dino-> allbery_b: hm, gdk, ok
18:45:13 <glguy> I've had gtk2hs work on Windows
18:45:13 <bos> bd_: i almost understand what you're saying. must read the awkward squad paper more closely :)
18:45:18 <glguy> I don't remember if I tried on OS X
18:45:27 <bd_> bos: awkward squad paper?
18:45:44 <bos> that's simonpj's tutorial on exceptions, io, concurrency, etc.
18:45:51 <glguy> ?where awkward
18:45:52 <lambdabot> I know nothing about awkward.
18:46:05 <glguy> ?google awkward squad
18:46:08 <lambdabot> http://en.wikipedia.org/wiki/Awkward_Squad
18:46:18 <mgsloan> hah
18:46:31 <glguy> lol
18:46:35 <glguy> that's definitely not it
18:46:45 <glguy> The name Awkward Squad was given in 2002/2003 to an informal grouping of left-leaning British trade unionists who were seen as sharing an opposition to the neo-liberal policies of the ruling New Labour faction of the Labour Party.
18:46:54 * glguy has read the paper, however
18:47:08 <glguy> ?google tackling the awkward squad
18:47:09 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
18:47:10 <lambdabot> Title: Simon Peyton Jones: papers
18:47:14 * allbery_b was under the impression gtk was incomplete to the point of nonfunctionality on OSX
18:47:26 <allbery_b> also couldn't build it on work linux box, because of autotools version skew
18:47:38 <bos> i have a function in another library that's returning Either ParseError RealValue, and i want to have a function that can return either a ParseError or an error of my own on the left, without too big a mess.
18:48:12 <allbery_b> Gdk.Drawable hgas the methods, I don't see how to get a Drawable representing the root window yet
18:48:53 <bd_> bos: hmm, not sure if this'll work, but you could try using an ErrorT around that Either. If the typeclass resolution rules are as clever as I'd like, then it should figure out which one you mean when you use catchError
18:49:15 <bd_> bos: ErrorT YourErrorType (Either ParseError RealValue)
18:49:37 <glguy> I can't imagine that working
18:49:42 <glguy> (the passthru)
18:49:52 <bd_> glguy: well, MonadError is parameterized on the error type as well as the monad
18:50:11 <glguy> :t catchError
18:50:12 <lambdabot> forall (m :: * -> *) e a. (MonadError e m) => m a -> (e -> m a) -> m a
18:50:14 <bos> wow, this stuff makes my head spin.
18:50:20 * bd_ tests
18:50:33 <glguy> bd_: ErrorT would have to define a MonadError instance that passed the call thru instead of using it
18:50:43 <glguy> ?src ErrorT catchError
18:50:43 <lambdabot> Source not found. Where did you learn to type?
18:51:03 <glguy> ?fptools Control.Monad.Error
18:51:03 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
18:52:08 <glguy> similarly, StateT s (State t) u   won't pass put through
18:52:18 <allbery_b> hm, ;looks like they hand off to Graphics.X11 for low level stuff, possib;y you should look there
18:52:27 <allbery_b> (some fiunctions, for example, return a Screen)
18:52:46 <glguy> instance (Error e) => MonadError e (Either e) where throwError             = Left Left  l `catchError` h = h l Right r `catchError` _ = Right r
18:53:54 <bos> glguy: did your cut and paste go screwy?
18:53:55 <bd_> glguy: hmm, could it be safely be defined then?
18:54:10 <glguy> bos: yeah, it removed the newlines
18:54:29 <glguy> bd_: I don't believe so
18:55:17 <dino-> I did find gdk_screen_width() and gdk_screen_width_mm() in the C. But.. not so sure those are exposed to me in the hs. :(
18:57:04 <bd_> hmm
18:57:16 <bd_> instance (MonadError e m) => MonadError e (ErrorT e' m) <-- fails the coverage condition...
18:57:43 <augustss> @yow
18:57:44 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
18:57:57 <bd_> bos: I suppose you could make your error type have a constructor which takes ParseError
18:57:58 * allbery_b doesn't see it in the hoogle
18:58:07 <bos> bd_: yeah
19:00:15 <sorear> hi
19:03:56 <notsmack> Text.XHtml.Strict doesn't have an <a> attribute?
19:04:32 <jcreigh> <pedantic>Perhaps it has an <a> element?</pedantic>
19:04:58 <notsmack> jcreigh: of course.
19:05:08 <notsmack> misspoke, don't see it
19:05:30 <notsmack> i guess (tag "a") would work
19:05:56 <glguy> ?docs Text.XHtml
19:05:56 <lambdabot> Text.XHtml not available
19:06:02 <jcreigh> if we're talking about this library: http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/doc/api/Text-XHtml-Strict.html, it looks like it has an "anchor"
19:06:03 <sorear> ?docs
19:06:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:06:06 <lambdabot> http://tinyurl.com/y7dv5r
19:06:15 <jcreigh> maybe they just didn't want to spell it "a".
19:06:37 <notsmack> jcreigh: they use "the[x]" for everything else, no "thea"...
19:07:06 <chessguy> @type show
19:07:08 <lambdabot> forall a. (Show a) => a -> String
19:07:25 <sorear> > show 42
19:07:26 <glguy> hotlink :: URL -> Html -> HotLink
19:07:26 <lambdabot>  "42"
19:07:31 <glguy> is it related to a "hotLink"?
19:07:39 <sorear> > show (Just "foo\"")
19:07:40 <lambdabot>  "Just \"foo\\\"\""
19:09:00 <glguy> oh
19:09:01 <glguy> anchor
19:09:16 <glguy> anchor              =  tag "a"
19:12:54 <notsmack> duh.
19:12:56 <notsmack> glguy++
19:13:16 <augustss> Anchors away!
19:13:20 <glguy> hotlink is a cute little way to deal with anchors that  Ipreviously did not know
19:13:30 <glguy> looks like anchor is only useful when you are doing something crazy
19:14:00 <glguy> though I'd have prefered "hyperlink"
19:14:01 <glguy> ;)
19:16:37 <SamB> anchor is probably for <a id="thing-to-use-with-hash-mark"/>, no?
19:17:17 <glguy> probably
19:17:46 <glguy> which browsers support anchors to things with id=".." instead of just name="" ?
19:17:46 <glguy> all?
19:18:32 <SamB> I believe HTML 4 says you can use id, and XHTML should not support name...
19:18:48 <sorear> id="" is used for CSS, I haven't heard of it being used for #foo
19:18:56 <glguy> Names an anchor. Use this attribute to create a bookmark in a document.
19:18:56 <glguy> In future versions of XHTML the name attribute will be replaced by the id attribute!!
19:19:06 * sorear is not an HTML expert
19:19:08 <glguy> w3schools.org seems to think that XHTML will eventually support that
19:19:18 <glguy> -- http://www.w3schools.com/tags/tag_a.asp
19:19:20 <lambdabot> Title: HTML A TAG
19:19:31 * sorear thinks the only legitimate HTML tags are HEAD, BODY, TITLE, A, P, and IMG
19:19:54 * SamB thinks sorear is exagerating a little
19:20:22 <SamB> surely h1, h2, and h3 have their uses as well?
19:20:27 <SamB> also maybe tables?
19:20:30 <sorear> maybe H[1..6], B, I, TABLE, TD, TR, but definitely not SCRIPT, STYLE, DIV, APPLET, etc.
19:20:32 <SamB> and lists?
19:20:36 <Excedrin> what about BLINK and MARQUEE?
19:20:40 <SamB> hmm.
19:20:59 <SamB> how are you supposed to use javascript to dynamify your content when possible?
19:21:03 <Excedrin> whew, glad to see that my blinking marquee made the cut
19:21:04 <glguy> w3schools seems to think that name= is the way to create bookmarks in xhtml and html
19:21:21 <SamB> glguy: maybe xhtml is crazy and supports name= too?
19:21:29 <sorear> dynamic content is by itself bad :)
19:21:34 <jcreigh> Excedrin: well, <blink> is non-standard. The correct way to do that is with CSS: text-decoration: blink :)
19:21:56 <glguy> what about <cite>
19:21:58 <SamB> well, I meant, maybe it can be used to make things run nicer
19:22:03 <glguy> <dl>
19:22:29 <sorear> long live text/plain!
19:22:32 <SamB> heh
19:22:33 <mgsloan> so, why does the following code still produce the file locked error?
19:22:33 <mgsloan> fop f n = readFile n >>= return.(\x-> seq (last x) (f x)) >>= writeFile n
19:23:05 <SamB> I still think javascript can be used to do some nice things
19:23:29 <glguy> or everyone's favorite, the <samp> tag
19:23:33 <SamB> just little things, maybe, but still nice
19:23:44 <SamB> jcreigh: I don't like that
19:24:00 <SamB> I wish gecko would not implement text-decoration: blink
19:24:04 <jcreigh> SamB: I'm joking...
19:24:11 <SamB> jcreigh: oh.
19:24:40 <glguy> or everyone's favorite <frameset>
19:24:41 <SamB> anyway, I wish mozilla wouldn't support BLINK tags actually blinking...
19:24:44 <SamB> glguy: hah
19:24:52 <SamB> favorite, yeah right...
19:24:55 <sorear> Someday I plan to implement a web browser in haskell.  I think it's right below "rewrite GHC".
19:25:00 * allbery_b thought there was a stunt somewhere to disable it
19:25:05 * glguy loves a good set of nested frames
19:25:05 <jcreigh> SamB: well, I'm sure these's an about:config option to turn it off...
19:25:18 <SamB> jcreigh: they should have it in the Firefox options, too
19:25:19 * sorear recommends hexedit(1)
19:25:24 <araujo> sorear, i had a similar idea a few months ago
19:25:26 <SamB> right next to the ad-blocker settings
19:25:32 <allbery_b> of course about:config is a bleedin' cesspool
19:25:32 <jcreigh> browser.blink_allowed, it looks like.
19:25:48 <SamB> and it should default to off.
19:26:09 <allbery_b> I'd almosr tather edit prefs.js directly
19:26:21 <sorear> if hexedit can change a GHC 6.4 binary that won't even dylink into one that produces working code, surely it can be used to repair gecko.
19:26:24 * allbery_b wonders how he managed to transpose those letters around a space
19:26:58 <SamB> sorear: surely I have gone beyond talking about gecko by now?
19:27:22 <Z4rd0Z> I'm not clear why, when creating a new type, you have to do 'data D = D {x :: String, y :: Bool}' instead of 'data D = {x :: String, y :: Bool}'
19:27:29 <sorear> I'm still amazed that I dared apply hexedit to /usr/local/lib/ghc-6.4.2.bin
19:27:37 <sorear> I'm even more amazed it worked
19:27:40 <SamB> the one advantage about:config has over editing prefs.js is that you don't have to restart the browser with about:config
19:27:50 <jcreigh> sorear: what did you have to hexedit?
19:28:02 <sorear> the GHC 6.4.2 binary
19:28:16 <jcreigh> sorear: right, sorry. Rather, why did you have to hexedit the GHC binary?
19:28:30 <sorear> change "readline.so.4" to "readline.so.5"
19:28:57 <sorear> Version numbers are a stupid idea.
19:29:27 <sorear> If they worked, then my change would neccessarily been disasterous, because there would be a true API change.
19:29:44 <bd_> sorear: It could've been an API change which only affected a few calls
19:29:47 * sorear starts a crusade for install-time type checking without version numbers
19:30:35 <sorear> bd_: my point exactly.  One-dimensional version numbers hopelessly distort compatibility checks.
19:30:43 <allbery_b> Z4rd0Z: because I can define D {a :: String, b :: Bool} and D1 {a :: String, b :: Bool, c :: Int} and then initialize only a and b.  so do I mean D, or D1 with c uninitialized?
19:31:15 <allbery_b> sorear: as this freebsd?
19:31:31 <bd_> sorear: Well, there's the other issue that if you're doing some other types of checks, it's difficult to determine which versions you need to keep around to keep all the installed programs working
19:31:49 <sorear> allbery: Debian unstable
19:32:02 * allbery_b thinks the base readline gets verbumped on major OS version upgrades even if it's not updated, which si a distortion of how shlibs are supposed to work
19:32:10 <allbery_b> maybe debian does the same thing
19:32:28 <sorear> allbery_b: debian has a fully working 6.6 package
19:32:32 <allbery_b> it's a broken way of doing things, albeit not as broken as openssl's versioning scheme
19:32:37 <bd_> debian generally has a policy of tracking upstream version numbers, unless those version numbers are wrong
19:32:45 <allbery_b> hm
19:32:49 <allbery_b> that seems odd then
19:33:00 <bd_> in which case they'd prefer to educate upstream rather than fork
19:33:24 <allbery_b> the *correct* way to handle this kind of thing is versioned symbols --- but wh wants everything to have c++-like symbol names?
19:33:25 <bd_> [since they want binary compatibility with third-party binary builds]
19:33:39 <sorear> If you want to know why with a working 6.6 I tried to install 6.4.2 ...
19:33:50 <allbery_b> hs-plugins support :>
19:33:52 <sorear> yeah.
19:34:17 * allbery_b is refusing t let macports update his ports-installed 6.4.2 for the same reason
19:34:23 <bd_> allbery_b: versioned symbols only help with dynamically linking two versions of a library due to indirect dependencies
19:34:30 <sorear> It's all dons' fault! :)
19:34:32 <bd_> allbery_b: you still need to choose which version to use
19:34:38 <bd_> or well when to bump the version
19:36:02 <allbery_b> bd_: arguably you bump versions whenever and the shlib manager handles determining whch one matches at runtime.  at compile time you generally have a system-specified version (hence foo.so vs. foo.so.N)
19:36:52 <allbery_b> compile uses foo.so which contains a pointer to an appropriate runtime versioned lib.  that would actually scale if you e.g. replaced the version with an md5sum of versioned symbols, or something
19:37:28 <bd_> If the version was a md5sum of versioned symbols... then you'll only be able to link with an exactly-matching version of the lib
19:37:32 <allbery_b> (yes md5sums are a bit long, but you should not have to care)
19:37:42 <bd_> which is exactly the same as the current system only it makes the filenames longer :)
19:37:56 <bd_> unless I misunderstand?
19:38:05 <allbery_b> bd_ the "version" reflects not an externally assigned version number, but an API version derived from the types and return values
19:38:11 <bd_> right
19:38:12 <allbery_b> hence c++-loking symbols
19:38:30 <allbery_b> if any of those change, well, you shouldn't expect it to work anyway
19:38:37 <bd_> you mean, automatically deriving the soname version?
19:39:16 <allbery_b> your function f, based on the function's api, becomes a symbol f_mumble where mumble is computed from its declared arguments and return type
19:39:29 <HairyDude> hrm, apparently ML can't unify the equivalent of Set a -> Set a -> Set a with b -> c -> c
19:39:33 <allbery_b> the so version is then generated by md5summing all the exported symbols in the shared object
19:39:48 <allbery_b> now the version changes only when the API does.
19:39:49 <sorear> I'd like to see a system where when you run the program, full unification is performed.  (memoization is encouraged.)
19:40:21 <bd_> allbery_b: Such a system would be inferior to the current system; first, it fails to account for changes in semantics of functions, second, it makes backwards-compatible changes (eg, adding functions) impossible
19:40:24 <allbery_b> you can still get the issue where you use only a subset of the api which didn't change, but for that you need to go from monpolithic shared libraries to individual smaller shared objects
19:42:03 <bd_> a single number strikes a balance between flexibility and easy-of-programming. Provided the programmer knows the rules anyway...
19:42:13 <sorear> my system solves most of those problems ...
19:43:01 <bd_> sorear: Makes it more complex for distributions to determine which versions need to be installed at any time for legacy programs......
19:44:05 <sorear> I have mad visions of just a net of functions depending on functions.  No package trickery.
19:46:44 * allbery_b notes that we already have tha:  it's called compiler and linker.  :p
19:47:35 <dino-> allbery_b: Ah, I was just going through the log of this, I missed what you said about Graphics.X11. There's stuff in there that will do this if I install libghc6-x11-dev
19:47:38 <monochrom> I like packages, hierarchical packages, ...
19:47:47 <allbery_b> (there are open source advocates who actually advance that as an argument with a straight face)
19:48:02 <dino-> widthOfScreen :: Screen -> Dimension  etc..
19:48:15 <mgsloan> perhaps this is just JITing?
19:48:18 <allbery_b> yeh.  might wan to check with someone who knows gtk2hs before jumping, though
19:56:54 <mgsloan> fop f n = readFile n >>= return.(f$!) >>= writeFile n
19:57:15 <mgsloan> I want this to read the whole file in, then do the operation, and write it out, but its not working properly
19:57:55 <mauke> how does it fail?
19:58:06 <mgsloan> resource busy (file is locked)
19:58:13 <mgsloan> I think the problem is the laziness
19:58:45 <mgsloan> I'm surprised laziness was applied to file IO, because, particularly on unix systems, a files contents are not necessarily static
20:01:01 <mgsloan> would be crazy on plan 9, where everything is a file
20:02:33 <mauke>  The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents
20:04:13 <mgsloan> right
20:04:36 <mgsloan> what if i want to readfile, operate on the string, and write it back out to the same file, though?
20:05:18 <mgsloan> This actually doesn't matter, just filling in some blanks on a language benchmark
20:05:36 <mgsloan> It basically says to do the modification inplace though
20:09:06 <bd_> mgsloan: In-place modification on a file is tricky to do with OS primitives - what if you need to extend the file, for example?
20:09:23 <bd_> I'm sure you could make some sort of framework to do it safely with lazy bytestrings, if you tried
20:09:34 <mgsloan> I don't mind if it reads in the whole file, deletes it even, and rewrites it
20:09:51 <bd_> that's probably the best way then
20:09:58 <bd_> or use a temp file, and rename over
20:10:00 <bd_> if possible
20:10:06 <mgsloan> right, but i can't get it to work :(
20:10:22 <mgsloan> nah, I think temp is outside of the specs of the problem
20:10:49 <mgsloan> "remove #-comments from a file (modifying the file, i.e. in place)"
20:10:59 <bd_> mgsloan: you can use Data.ByteString hGetContents
20:11:01 <bd_> which is not lazy
20:11:31 <bd_> or something like
20:11:39 <bd_> (length s) `seq` return ()
20:11:40 <bd_> in IO
20:12:09 <mgsloan> I've tried
20:12:10 <mgsloan> fop f n = readFile n >>= return.(f$!) >>= writeFile n
20:12:18 <mgsloan> but I've never really used seq before
20:12:26 <bd_> seq there is being used improperly
20:12:31 <bd_> since
20:12:36 <bd_> you're only seqing on the first list cell
20:12:38 <bd_> not the last
20:12:43 <sorear> The only correct way iirc to sequence something in the IO monad is Control.Exception.evaluate
20:12:52 <sorear> @ty Control.Exception.evaluate
20:12:54 <lambdabot> forall a. a -> IO a
20:12:58 <bd_> you need to force it to read all of the lsit
20:13:02 <bd_> ?src evaluate
20:13:03 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
20:13:39 <mauke> @src seq
20:13:39 <lambdabot> Source not found. Wrong!  You cheating scum!
20:13:43 <mgsloan> :t evaluate
20:13:45 <lambdabot> Not in scope: `evaluate'
20:14:00 <bd_> seq is primitive, or close to it
20:14:01 <mgsloan> :t Control.Exception.evaluate
20:14:03 <lambdabot> forall a. a -> IO a
20:14:09 <sorear> evaluate can't be written using just seq and return
20:14:30 <sorear> i think
20:14:30 <bd_> sorear: why not? a `seq` return () would exception if a is bottom
20:14:39 <sorear> ?docs Control.Exception
20:14:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
20:14:52 <sorear> bd_: it says what the difference is there
20:15:55 <sorear> oh, it looks like evaluate is mostly for sequencing stuff
20:15:58 <bd_> sorear: The difference does not matter here
20:16:08 <nornagon> @index raise#
20:16:09 <lambdabot> bzzt
20:16:29 <sorear> nornagon: GHC.Prim
20:16:34 <mgsloan> fop f n = readFile n >>= evaluate >>= return.f >>= writeFile n
20:16:39 <mgsloan> still get the same thing
20:16:50 <bd_> sorear: but yes, I can see how those semantics would be different
20:16:51 <mauke> yeah, it doesn't force the entire list
20:17:15 <bd_> mgsloan: \l -> (length l) `seq` return l, sort of thing
20:17:21 <sorear> readFile n >>= evaluate . reverse . reverse >>= return . f >>= writeFile n ?
20:17:33 <bd_> mgsloan: or just use Bytestring methods, which are likely to be faster anyway :)
20:17:57 <bd_> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html#29
20:17:59 <lambdabot> http://tinyurl.com/wn5rt
20:18:06 <mgsloan> right, but the main focus of the benchmark is code length :P
20:18:23 <bd_> import Data.ByteString as B
20:18:28 <mgsloan> while still writing it obviously
20:18:30 <mauke> ooh, is this online somewhere?
20:18:41 <bd_> fop f n = B.readFile n >>= writeFile . f
20:18:44 <bd_> er
20:18:46 <bd_> fop f n = B.readFile n >>= writeFile n . f
20:18:47 <mgsloan> http://merd.sourceforge.net/pixel/language-study/scripting-language/
20:18:49 <lambdabot> Title: Scriptometer: measuring the ease of SOP (Script-Oriented Programming) of program ..., http://tinyurl.com/2ekjk
20:19:10 <bd_> er
20:19:12 <bd_> B.writeFile too
20:19:36 <mauke> wait, they're using hugs?
20:19:51 <mgsloan> heh, probably old info
20:19:52 <bd_> hugs has bytestring I thought?
20:20:05 <bd_> or is it an external lib?
20:20:21 <mgsloan> it doesn't care about speed though, all about script-ability
20:20:53 <mgsloan> A tiny haskell program could probably enable "program can be passed on command line"
20:21:17 <bd_> hmm
20:21:29 * allbery_b thought ghc had some form of that already
20:21:46 <SamB_XP_> you mean ghc -e
20:21:47 <SamB_XP_> ?
20:21:50 <bd_> writeFile n (length l `seq` l)
20:21:56 <ClaudiusMaximus> @hoogle String -> IO (Maybe a)
20:21:57 <bd_> how's that then?
20:21:57 <lambdabot> No matches, try a more general search
20:22:10 <bd_> ClaudiusMaximus: ... how would that function work?
20:22:18 <Cale> What's up?
20:22:25 <bd_> ClaudiusMaximus: it'd only be able to return Nothing or Just _|_
20:22:29 <Cale> Talking about making file IO strict?
20:22:34 <allbery_b> yeh, -e
20:22:39 <mauke> haskell golf, really
20:22:39 <Cale> If I might ask, why? :)
20:22:58 <ClaudiusMaximus> @hoogle Typeable a => String -> IO (Maybe a)
20:22:59 <lambdabot> No matches, try a more general search
20:23:01 <bd_> Cale: scripting language competition, looking to express in-place editing of a file in the shortest (and clearest?) amount of code
20:23:12 <allbery_b> cale: he wants to read and write back to the same file in a single process
20:23:12 <bd_> ClaudiusMaximus: NewBinary?
20:23:16 <bd_> ?where newbinary
20:23:17 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
20:23:29 <mgsloan> it's old and mostly inactive, but i'm curious to see how nice i can make it
20:23:35 <ClaudiusMaximus> bd_: import System.Eval.Haskell  eval :: Typeable a => String -> [Import] -> IO (Maybe a)
20:23:39 <glguy> Is there a gtk2hs win32 binary for ghc6.6 that I forgot about?
20:23:41 <bd_> oh
20:24:23 <mauke> fmap (\l -> length l `seq` f l) (readFile n) >>= writeFile n?
20:24:24 <nornagon> i wonder, could eval be pure haskell? :)
20:24:54 <mauke> or does that still try to open the file before evaluating l
20:25:13 <bd_> nornagon: I'm sure you could do some horrible typeclass hacks, if you restrict which types can be returned
20:25:30 <mauke> argh
20:25:31 <glguy> since readFile is lazy, couldn't you just usea non-lazy file reading function?
20:25:35 <bd_> nornagon: There's of course no way to return a user-defined type across eval without RTS support
20:25:42 <nornagon> RTS?
20:25:56 <sorear> runtime system
20:25:56 <mgsloan> mauke - hmm, doesn't seem to work :(
20:26:17 <mauke> yeah, you need (writeFile n $!)
20:26:19 <bd_> nornagon: the support libraries (both C and haskell) for haskell
20:26:27 <bd_> mauke: that only forces the first list pair
20:26:42 <bd_> mauke: (\l -> writeFile n (length l `seq` l))
20:27:49 <mauke> bd_: doesn't work
20:27:54 <mauke> you need writeFile n $!
20:28:11 <bd_> ?src ($!)
20:28:12 <lambdabot> Source not found. Are you on drugs?
20:28:17 <Cale> mauke: huh?
20:28:25 <bd_> ($!) f a = a `seq` f a surely?
20:28:30 <Cale> bd_: yes
20:28:34 <bd_> oh
20:28:36 <bd_> I know
20:28:44 <bd_> (\l -> writeFile n $! (length l `seq` l))
20:28:48 <mauke> writeFile first opens the file, then looks at the list
20:28:53 <glguy> Cale: you know anything about gtk2hs for ghc6.6 on win32?
20:29:00 <Cale> glguy: nope
20:29:02 <mauke> my current version is fop f n = fmap f (readFile n) >>= \l -> writeFile n $! length l `seq` l
20:29:17 <Cale> glguy: I haven't used windows to any substantial degree in over 6 years.
20:29:40 <HairyDude> ?src $!
20:29:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:29:46 <HairyDude> hmm
20:29:53 <mgsloan> mauke - works!
20:30:00 <glguy> ?src ($!)
20:30:00 <lambdabot> Source not found. My mind is going. I can feel it.
20:30:10 <HairyDude> lots of 2001 references there
20:33:04 <mgsloan> why do you have to do seq so much though?
20:34:03 <lisppaste2> mauke pasted "complete solution" at http://paste.lisp.org/display/35078
20:34:48 <mgsloan> heh, did you cull that from my code or write your own?
20:34:52 <glguy> couldn't you just say: when (length l > 0) (writeFile n l)?
20:34:52 <Cale> flip the >>=
20:34:57 <Cale> =<< is clearer here
20:34:58 <mgsloan> because the rest is the same
20:35:09 <mauke> mgsloan: I haven't seen your code :-)
20:35:15 <mgsloan> LOL!
20:35:21 <mgsloan> it's exactly the same
20:35:36 <mgsloan> except I did (/='#')
20:36:11 <mauke> @index (=<<)
20:36:12 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:36:14 <Cale> why the $! ?
20:36:24 <mauke> to force evaluation of the list
20:36:32 <bd_> glguy: What if the output is zero bytes long?
20:36:53 <glguy> bd_: find: length > -1
20:36:55 <mgsloan> length l >= 0
20:37:06 <bd_> glguy: much better :)
20:37:07 <Cale> but even without the $! writeFile will have to evaluate the whole list (spine) to get the first element
20:37:40 <bd_> can we assume the platform is one which allows an open file to be deleted?
20:37:45 <Cale> because it will have to compute the length of it before it can pattern match to know if that string is empty or not
20:37:46 <nornagon> ?let #$%@! = "fuck, i don't know"
20:37:47 <mauke> Cale: yes, but only after trying to open the file, which is too late
20:37:47 <lambdabot>  Parse error
20:37:49 <nornagon> dang.
20:37:57 <mgsloan> bd - sure
20:38:53 <bd_> mgsloan: okay, how about:
20:39:09 <nornagon> ?let (#$%@!) = "fuck, i don't know"
20:39:10 <lambdabot> Defined.
20:39:19 <bd_> fop f n = readFile n >>= \s -> removeFile n >> writeFile n (f s)
20:39:42 <mgsloan> Somehow I doubt its really smart enough for that
20:39:59 <Cale> hmm, you're right, it does try to open the file sooner than I'd expect
20:40:44 <nornagon> ?let (#$%@!) = \_ _ "fuck, i don't know"
20:40:44 <lambdabot>  Parse error
20:40:45 <nornagon> gr
20:40:50 <nornagon> ?let (#$%@!) = \_ _ -> "fuck, i don't know"
20:40:51 <lambdabot> Defined.
20:41:18 <glguy> :-/
20:41:20 <bos> @seen mgsloan
20:41:20 <lambdabot> mgsloan is in #haskell. I last heard mgsloan speak 1m 37s ago.
20:41:32 <bos> mgsloan: you want to play with binary IO?
20:41:55 <Cale> fop f n = do l <- fmap f (readFile n)
20:41:55 <Cale>              evaluate (length l)
20:41:55 <Cale>              writeFile n l
20:41:59 <Cale> that might be clearer
20:42:23 <mauke> clarity is optional
20:43:35 <mgsloan> well, most of the things in that benchmark appear to be written clearly, not really insanely optimizing space.  Or just the author is biased and made all the languages he doesn't like to use for scripting long
20:43:58 <allbery_b> @. pl undo do { l <- fmap f (readFile n); evaluate (length l); writeFIle n l }
20:43:58 <lambdabot> ap ((>>) . evaluate . length) (writeFIle n) =<< fmap f (readFile n)
20:44:05 <allbery_b> ...maybe not :>
20:44:55 <mauke> wow, awk cheats hard
20:45:05 <glguy> temp file?
20:45:33 <bos> is there a norm for licensing haskell libraries?
20:45:42 <mauke> no, lots of external programs
20:45:42 <bos> LGPL, BSD, ...?
20:45:45 <glguy> GHC is revised BSD
20:45:58 <jcreigh> "revised" == "minus advertising clause"?
20:46:01 <glguy> yeah
20:46:12 <emu> and s/California/Glasgow!
20:46:45 <allbery_b> awk pretty much needs extrnal programs for that, bvarring gawk extensions (and I think even then for much of it)
20:46:55 <mauke> main = system "perl -pi '-es/#.*//'"  -- whee
20:47:07 <allbery_b> of course, by the "external programs" metric sh is doomed :)
20:47:45 <mauke> the lisp entry doesn't even work; it's just a function definition
20:48:54 <mgsloan> ah, if function definitions go then lots of the basic haskell things (smallest program, hello world) can be simplified
20:49:06 <mgsloan> My suggestion for a new smallest program is "main = main"
20:49:17 <ClaudiusMaximus> my attempt at smallest running haskell program is main=print"" (no newline at end of file, total 12 characters, works in runghc)
20:49:32 <mgsloan> main=main pwns joo :P
20:50:44 <mauke> ok, I don't think the C program there works
20:51:10 <mauke> er, wait
20:51:14 <mgsloan> well, C implementations are pretty sketchy :P
20:51:16 <Cale> haha, main=main is awesome
20:51:24 <Cale> It's even an infinite loop
20:51:34 <mgsloan> yep, _|_, and smallest program :)
20:53:03 <allbery_b> which c program?
20:53:27 <ClaudiusMaximus> hmm, 'echo "main=main" | runghc /dev/stdin' doesn't work, is there any fix?
20:53:30 <mauke> I'm pretty sure the C program fails for empty files
20:53:58 <glguy> main(){write(1,0,0);}
20:54:20 <glguy> or main(){write(1,"\n",1);} // would be closer
20:55:04 <allbery_b> hm, that program is flat out wrong.  stdio EOF is (-1), not 0
20:55:10 <bd_> ghc -e1 ?
20:55:15 <mauke> allbery_b: no, that part works
20:55:33 <mauke> allbery_b:  putc(c++, f);
20:55:44 <glguy> what is flat out wrong?
20:56:04 <Cale> ClaudiusMaximus: echo "main=main" > main.hs && runghc main
20:56:08 <allbery_b> hm, ok, missed that.  so yes, fails if first char "read" is EOF
20:56:30 <allbery_b> it's a peculiar way to write it, though
20:56:33 <mgsloan> yeah, looks like not much attention has been paid to the thing
20:56:41 <ClaudiusMaximus> Cale: i seem to remember a ghc flag that lets you change source extension?
20:56:59 <allbery_b> more attention paid to size than correctness
20:56:59 <mgsloan> stdin/out version:
20:57:03 <mgsloan> main = interact (unlines . map (takeWhile(/='#')) . lines)
20:57:35 <Cale> We should put an interactF in the libraries
20:57:44 <Cale> maybe call it something better than that
20:58:33 <mgsloan> would be cool
20:58:55 <Cale> The advantage is that it could do things the right way
20:59:13 <Cale> That is, read the whole file into a buffer at once, and convert it to a string lazily.
20:59:40 <Cale> For that matter, we ought to also have readFile'
20:59:56 <Cale> which does just that
21:00:23 <mauke> and sum' and product', while we're at it
21:01:14 <Cale> yeah
21:01:46 <bd_> Cale: readFile' = liftM BS.unpack . readFile
21:01:48 <bd_> ?
21:01:56 <bd_> BS.readFile even
21:01:58 <Cale> bd_: essentially
21:02:02 <ClaudiusMaximus> cat "main=main" | runghc -x hs /dev/stdin     << should work in "latest" ghc, not in ghc-6.4.2 it seems
21:02:30 <bd_> <interactive>:1:81:
21:02:30 <bd_>     Failed to load interface for `Main':
21:02:34 <bd_> with ClaudiusMaximus's command
21:02:42 <bos> @hoogle right
21:02:43 <lambdabot> Control.Arrow.right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
21:02:43 <lambdabot> Prelude.Right :: b -> Either a b
21:02:45 <lambdabot> Distribution.InstalledPackageInfo.copyright :: InstalledPackageInfo -> String
21:02:54 <bd_> does ghc -e1 count as a shortest program? :)
21:02:59 <mauke> @hoogle wrong
21:03:00 <lambdabot> No matches found
21:03:17 <bd_> wrong = unsafeCoerce#
21:03:19 <bd_> >.>
21:03:26 <bos> aren't there deconstructor functions for Either?
21:03:27 <glguy> cat "main=main"?   you mean echo "main=main"?
21:03:35 <ClaudiusMaximus> oops
21:03:43 <bd_> glguy: yes, factoring that fix in, it gives the above error :)
21:03:46 <Cale> There's either
21:03:50 <Cale> @type either
21:03:50 <bd_> :t either
21:03:52 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
21:03:52 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
21:04:10 <bos> ah, yes.
21:04:12 <bos> thanks.
21:04:21 <allbery_b> hoogle fromLeft
21:04:28 <bos> > either id undefined $ Either 1 2
21:04:29 <allbery_b> ?hoogle fromLeft
21:04:29 <lambdabot>   Not in scope: data constructor `Either'
21:04:29 <lambdabot> No matches found
21:04:51 <allbery_b> ?hoogle fromRight
21:04:51 <lambdabot> No matches found
21:05:21 <allbery_b> hm
21:05:28 <iulus> > either id undefined $ Right 1
21:05:29 <lambdabot>  Add a type signature
21:05:34 <bos> doh!@
21:05:42 <iulus> > either id undefined $ Left 1 :: Either Integer
21:05:43 <lambdabot>      `Either Integer' is not applied to enough type arguments
21:05:44 <lambdabot>     Expected ki...
21:05:48 <allbery_b> Eitheris either, not both :>
21:06:00 <Cale> > either id undefined $ Left 1 :: Either Integer String
21:06:01 <lambdabot>   add an instance declaration for (Num (Either Integer String))
21:06:05 <bos> either id undefined $ Left 1 :: Either Integer (Maybe Int)
21:06:07 <iulus> well, I failed, but you get the picture.
21:06:12 <bos> > either id undefined $ Left 1 :: Either Integer (Maybe Int)
21:06:12 <lambdabot>   add an instance declaration for (Num (Either Integer (Maybe Int)))
21:06:27 <Cale> > either id undefined (Left 1) :: Integer
21:06:28 <lambdabot>  1
21:06:30 <Cale> doh
21:06:37 <Cale> > either id undefined $ (Left 1 :: Either Integer String)
21:06:38 <lambdabot>  1
21:06:43 <Cale> > either id undefined (Left 1 :: Either Integer String)
21:06:44 <lambdabot>  1
21:06:45 <bos> ah, the type checker is so refreshing.
21:06:47 <Cale> See, $ is evil
21:06:57 <Cale> > either id undefined (Right "ack!" :: Either Integer String)
21:06:58 <lambdabot>  Undefined
21:07:02 <allbery_b> makes sense I guess
21:09:48 <bos> @t Right . id
21:09:48 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:09:53 <bos> :t Right . id
21:09:54 <lambdabot> forall a a1. a1 -> Either a a1
21:10:14 <bos> :t Right id
21:10:15 <lambdabot> forall a a1. Either a1 (a -> a)
21:12:48 <bos> do people use template haskell in "real" code, i.e. libraries that more than the author uses?
21:16:42 <ClaudiusMaximus> "It relies on the assumption that the passed values' Show instances produce valid Haskell literals"  -- does this hold for "deriving (Show, ...)" ?
21:17:36 <sorear> yes
21:17:53 <ClaudiusMaximus> sorear: thanks
21:19:23 <newsham> bos: the HAppS library defines some TH helpers and encourages library clients to use them
21:24:16 <bos> newsham: thanks
21:24:30 <bos> ClaudiusMaximus: what are you reading?
21:25:47 <ClaudiusMaximus> hs-plugins Sytem.Eval.Haskell docs
21:27:22 <ClaudiusMaximus> i've got a vague idea of hacking Fluxus to use Haskell as well as Scheme ( http://www.pawfal.org/Software/fluxus/docs/Introduction.html )
21:27:23 <lambdabot> Title: Introduction - Fluxus manual v0.10
21:30:48 <jcreigh> bos: BTW, I'd be interested in seeing your fnmatch() implementation, if you don't mind sharing your code. (I recent wrote a toy regex engine, and I'm interested in seeing how other people approached a similar problem. Specifically, I ended up using the list monad for backtracking, and I'm curious as to whether globbing requires any backtracking. My feeling is that no, it doesn't, but I'm not sure.)
21:31:34 <bos> jcreigh: sure, i'll put it up somewhere.
21:31:53 <bos> you have to backtrack a little for the kleene star, but that's trivial.
21:32:50 <bos> and it doesn't look like backtracking in my code, anyway :-)
21:33:16 <sorear> backtracking isn't neccessary as a search strategy
21:33:31 <sorear> breadth first search works as well
21:33:37 <SamB_XP> globbing has a kleene star?
21:33:44 <sorear> e.g memoizing ReadS, Earley
21:33:55 <sorear> SamB: close enough - *foo*bar*
21:34:00 <bos> SamB_XP: a very stupid kleene star.
21:34:12 <SamB_XP> @wikipedia kleene star
21:34:14 <lambdabot> No Result Found.
21:34:22 <SamB_XP> could someone fix @wikipedia?
21:34:27 <SamB_XP> or remove it, maybe?
21:34:54 <mgsloan> @wikipedia RPN
21:34:55 <lambdabot> No Result Found.
21:35:00 <mgsloan> yeah, doesn't work
21:35:03 <SamB_XP> it never finds anything
21:35:12 <SamB_XP> I don't think it has in years.
21:35:19 <SamB_XP> at least, assuming it is years old!
22:14:37 <glguy> anyone know how to manually install a package with ghc-pkg register?
22:14:41 <sorear> yes
22:14:41 <glguy> I've got the .conf files
22:14:52 <sorear> oh wait sorry
22:14:56 <glguy> trying to manually install gtk2hs for win32, 6.6 and 2.10
22:15:03 * sorear saw ./Setup.hs register
22:15:13 <sorear> oh wait yes
22:15:41 <sorear> ghc-pkg register <filename>
22:15:49 <sorear> I *have* done it
22:16:17 <sorear> Spend an hour or so automating the merge of my old packages.conf into my new one
22:16:37 <sorear> Didn't occur to me that, oh, 6.6 libs might be incompatible with 6.7 :)
22:16:46 <SamB_XP> hah
22:16:52 <SamB_XP> how did you forget?
22:17:32 <sorear> probably the same way one loses glasses in the designated holding area ...
22:20:49 <glguy> I set the pkglibdir envvar correctly
22:21:03 <glguy> and then ghc-pkg lies and says that the directory that *does* exist... doesn't
22:26:10 <lisppaste2> mgsloan pasted ".c -> .o selective compiler" at http://paste.lisp.org/display/35086
22:31:07 <jcreigh> what, "make" isn't good enough for you?
22:31:21 <mgsloan> :P
22:34:38 <jcreigh> scripts like that seem easier in other languages to me. eg, Dir["*.c"].each { |c| o = c.gsub(/\.c$/, '.o'); if not File.exist?(o) or File.mtime(c) > File.mtime(o); system("ghc -c -o #{o} #{c}"); end } in Ruby. (untested.)
22:36:33 <allbery_b> it could be that easy in haskell if someone assembled a scripting library
22:37:09 <allbery_b> I mean, the reason it's easy in ruby is because there's a standard directory lib with an "each" method
22:37:10 <glguy> ?seen dcoutts
22:37:11 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
22:37:19 <dcoutts> @yarr!
22:37:19 <lambdabot> Prepare to be boarded!
22:37:20 <jcreigh> or system("ghc", "-c", "-o", o, c) if we wanted to avoid possible shell-escaping errors.
22:37:27 * dcoutts is packing to go to PADL
22:37:33 <glguy> dcoutts: do you do gtk2hs?
22:37:37 <sorear> bye!
22:37:39 * dcoutts wrote it
22:37:48 <glguy> I'm trying to install that 0.9.10.4 zip file from your haskell homedir
22:37:55 <mgsloan> jcreigh - yep.  I'm actually doing this for a little ill-maintained scripting language benchmark.  The ruby looks a lot like yours except multilined
22:37:56 <glguy> but I can't figure out how to set pkglibdir
22:38:01 <glguy> to run ghc-pkg register
22:38:09 <glguy> I didn't knwo if you knew any tricks
22:38:46 <dcoutts> glguy, oh right, it's the root dir where you decide to install gtk2hs, eg "c:\program files\gtk2hs"
22:39:10 <glguy> dcoutts: should that have a ghc-6.6 dir inside?
22:39:17 <dcoutts> glguy, no
22:39:37 <dcoutts> glguy, sorry about that, ndm demanded I give him a tarball, but it's not designed to be installed by hand
22:39:37 <jcreigh> mgsloan: are you refering to http://merd.sourceforge.net/pixel/language-study/scripting-language/ ?
22:39:40 <lambdabot> Title: Scriptometer: measuring the ease of SOP (Script-Oriented Programming) of program ..., http://tinyurl.com/2ekjk
22:39:49 <mgsloan> yep
22:39:55 <glguy> dcoutts: is there any correct way to install for ghc6.6?
22:40:06 <dcoutts> glguy, it's really for the installer to do, but the installer isn't quite done yet.
22:40:33 <jcreigh> wow...that's creepy how mine is almost exactly the same, down to variable names.
22:40:43 <dcoutts> glguy, so the point is , you can use that for the next week or so, until I release the proper gtk2hs win32 installer
22:41:01 <dcoutts> at which point that will become the 'correct way'
22:41:10 <glguy> dcoutts: does it sound right that the envvar doesn't like spaces?
22:41:28 <dcoutts> not sure what you mean exactly
22:41:38 <glguy> it says C:\program  doesn't exist
22:41:40 <dcoutts> you can install into a dir with spaces
22:41:41 * mgsloan wonders if it's bad that he read dons' h4sh as "hash"
22:41:52 <dcoutts> glguy, using "" ?
22:41:56 <glguy> dcoutts: when I did that it said that a directory that did exist, didn't
22:42:09 <glguy> dcoutts: using "c:\....." it thinks that is an empty string
22:42:22 <dcoutts> oh, use / not \
22:42:42 <dcoutts> in Haskell strings \ needs to be escaped as \\
22:42:46 <dcoutts> or you can use /
22:42:50 <dcoutts> for win32 paths
22:43:00 <gour> dcoutts: morning. are you satisfied with hackathon?
22:43:13 <dcoutts> gour, yes, I think so. Seen the pics etc?
22:43:39 <gour> dcoutts: yes, like high-order priests :-)
22:43:43 <dcoutts> heh
22:43:57 <glguy> dcoutts: ghc-pkg "c:\progra~1\Haskell\gtk2hs\imports\glib" doesn't exist or isn't a directory
22:44:00 <glguy> LIES!
22:44:07 <gour> dcoutts: are you familiar with SOE book?
22:44:26 <dcoutts> gour, I know of it. I don't know it well.
22:44:30 <dcoutts> glguy, hmm
22:44:41 <gour> dcoutts: i'm asking after seeing that you made soegtk and could recommend it to my noob haskell friend (from croatia)
22:45:03 <dcoutts> glguy, what path did you set for ${pkglibdir}?
22:45:04 <sorear> @localtime dcoutts
22:45:05 <lambdabot> Local time for dcoutts is Sat Jan 13 06:42:04
22:45:47 <glguy> set pkglibdir=c:\progra~1\haskell\gtk2hs
22:45:51 <gour> dcoutts: based on the slides' content i'd say it is nice book
22:45:54 <glguy> without the ~1 it doesn't make it in at all
22:46:03 <glguy> with / it don't find anything either
22:46:17 <glguy> that set line gives the deepest not found error
22:46:28 <glguy> the same that I get when I use c:\gtk2hs
22:46:49 <dcoutts> glguy, ah, I see. I would just substitute into the thing.package.conf files directly, I don't know about the env var expansion
22:46:59 <dcoutts> glguy, ndm did that the other day and it worked.
22:47:05 <glguy> OH, so edit the files?
22:47:05 <glguy> ok
22:47:08 <dcoutts> yes
22:47:21 <dcoutts> that's what the installer does, it substitutes and then registers
22:48:09 <dcoutts> glguy, you can see this isn't a process that's normally supposed to be done by hand! :-)
22:49:00 <dcoutts> glguy, I'll ask you to test the installer in a few days :-)
22:49:19 <glguy> dcoutts: manual changes worked
22:49:35 <dcoutts> glguy, oh, good. so register in dep order, glib, cairo, gtk, etc
22:55:00 <glguy> dcoutts: I'vegot a bunch of .a files
22:55:05 <glguy> and ghc-pkg is looking for .o files?
22:55:20 <dcoutts> yes
22:55:31 <glguy> oh
22:55:34 <dcoutts> you can use ghc-pkg --auto-ghci-libs iirc
22:55:42 <dcoutts> which builds one from the other
22:56:10 <dcoutts> glguy, however you can't currently run gtk's main inside ghci anyway do to issues with threads.
22:56:26 <glguy> that --auto flag worked
22:56:33 <glguy> time to redo all the register commands :)
22:56:42 <glguy> but that is good to know
22:56:43 <dcoutts> glguy, ghc links with .a files, ghci links with .o files
22:57:15 <glguy> oh
22:57:23 <glguy> so there is no need to bother
22:57:43 <dcoutts> right, only if you want to use it in ghci, which doesn't work anyway :-)
22:58:00 <glguy> is this is new issue, or has this always been the case?
22:58:13 <dcoutts> glguy, since ghc-6.4.2, ghc-6.4.1 was ok
22:58:17 <dcoutts> glguy, btw, you don't want to help me maintain gtk2hs on windows do you? :-)
22:58:34 <glguy> I'm not sure that I'm qualified yet :-p
22:58:37 <glguy> but I can test stuff
22:58:42 <dcoutts> I don't have easy access to a windows box
22:58:53 <dcoutts> nor am I a win32 expert
22:58:59 <dcoutts> since I'm not a win32 user :-)
22:59:07 <glguy> I'll help where I can
22:59:13 <dcoutts> ta
22:59:14 <glguy> I haven't really written anything with gtk2hs yet
22:59:30 <glguy> but I want there to be a gui toolkit for win32
22:59:41 <glguy> i mean i know there is
22:59:54 <glguy> but yeah, I'll help where I can
22:59:58 <dcoutts> yeah, it's not technically necessary to write progs using things one maintains :-)
23:00:02 <glguy> lol
23:00:04 <mgsloan> haskell would do much better as a scripting language if it inferred imports :P
23:00:23 <dcoutts> glguy, mostly my issues with win32 are just building it regularly from source and making the installer work
23:00:33 <Cale> Only, that's getting lots harder, the way the libraries are going.
23:00:57 <Cale> I wonder how many libraries define map.
23:01:00 <dcoutts> glguy, perhaps we should talk about it more in a week or so when I'm back from this conference
23:01:09 <glguy> dcoutts: you know where to find me
23:01:16 <dcoutts> yep, right'o
23:01:42 <Stinger__> dcoutts god forbid library designers would have to use the lib in real life ;)
23:01:51 <dcoutts> Cale, though an IDE could have a good guess and provide suggestions of what you might want to import, based on the name and the type the undefined symbol must have.
23:01:58 <ho_ho_ho> anyone hardcore hardware fans?
23:02:04 <dcoutts> Stinger__, heh. It does help I guess :-)
23:02:10 <mgsloan> Cale - true.  It could see what made since in the type context.  That loads many more possibilities on the inference engine though...
23:02:53 <mgsloan> I think redefining map for your own type is pretty rediculous, though
23:03:11 <dcoutts> Stinger__, though maintaining a package on some platform doesn't involve using it at all, as the packaging folks for debian/gentoo/ etc can attest.
23:03:47 <mgsloan> actually, I don't want import inference
23:03:55 <mgsloan> more like explicit reference leading to imports
23:04:22 <mgsloan> eg, Directory.doesFileExist
23:04:51 * glguy successfully runs the helloworld demo
23:04:54 <glguy> hurrah, install working
23:05:00 <dcoutts> glguy, yay
23:05:29 <dcoutts> mgsloan, an IDE could automagically add 'import qualified System.Directory as Directory (doesFileExist)'
23:05:45 <glguy> dcoutts: VS2005 does that for you
23:05:56 <glguy> when you use a class that isn't in scope, it allows you to add the import line
23:06:07 <mgsloan> ah, i left off the System in that one. scriptometer uses the old libs...
23:06:11 <dcoutts> I think eclipse can too, it's a good idea
23:06:12 <glguy> from a context menu that you can click under the identifier
23:06:53 <mgsloan> that could be nice if you import your modules with specific func references to keep your scope clean, though
23:07:56 <glguy> is HaskellDB the in-memory db engine?
23:07:59 <glguy> is it "stable"?
23:08:16 <dcoutts> glguy, no it's a high level interface to other SQL dbs
23:08:24 <glguy> oh
23:08:24 <glguy> ok
23:08:29 <glguy> is there an in-memory library?
23:08:51 <dcoutts> glguy, Data.Map ? ;-)
23:08:57 <dcoutts> not that I know of
23:10:23 <glguy> Graphics.UI.Gtk.Mogul?
23:12:31 <dcoutts> glguy, that's gone.
23:12:57 <glguy> so that treeview demo isn't going to work then :)
23:13:29 <dcoutts> oh, did that .zip include the old demos?
23:13:40 <glguy> no demos at all
23:13:45 <glguy> this is from the .9.10.tar.gz
23:13:46 <dcoutts> right
23:14:09 <dcoutts> glguy, grab the ones from the .9.10.4.tar.gz
23:14:39 <bos> here's my first attempt at packaging a haskell library: http://darcs.serpentine.com/pickle/
23:14:41 <lambdabot> Title: Index of /pickle
23:15:00 <bos> the pickle package build on Data.Binary to provide typesafe serialisation.
23:15:08 <glguy> dcoutts: where is that?
23:15:13 <bos> if people of clue could take a brief glace, i'd be grateful.
23:15:26 <dcoutts> glguy, http://haskell.org/gtk2hs/gtk2hs-0.9.10.4.tar.gz
23:16:05 <dcoutts> bos, that was quick :-) Data.Binary is only 2 days old.
23:16:35 <bos> dcoutts: yeah, i came across it by accident.
23:16:36 <glguy> dcoutts: Failed to load interface for "Data.Tree"
23:16:41 <glguy> but the .exe ran
23:16:52 <glguy> in listdemo.exe
23:17:00 <dcoutts> glguy, that's odd, ghc-6.6 comes with Data.Tree
23:17:18 <glguy> yeah
23:17:20 <glguy> I have it in ghci
23:17:30 <glguy> Declaration for treeStoreNew:
23:17:39 <glguy> Failed to load interface for `Data.Tree`
23:17:47 <glguy> but not in make
23:18:09 <dcoutts> use -v to see where ghc is looking
23:18:24 <dcoutts> bos, you can ask me, dons, kolmodin and ndm to review
23:18:51 <bos> dcoutts: what's the best way to get people's attention?
23:19:18 <dcoutts> bos, well at the moment they're all travelling, so pretty hard :-)
23:19:37 <sorear> yay... I just created a two-node private IRC network.  now I can cause netsplits to my heart's content.  (debugging lambdabot, of course)
23:19:42 <dcoutts> bos, direct email cc'd to all, email to haskell-cafe asking for review?
23:19:59 <bos> dcoutts: will do, thanks.
23:20:04 * glguy knows that sorear just like the power of causing netsplits
23:20:25 <sorear> muahahahahaha
23:21:27 <Cale> Unless you connect, like 100 lambdabots to it, it won't be any fun to watch though
23:22:05 <sorear> I was going to
23:22:10 <Cale> You should op some of them in a channel and then ride the netsplit to take the channel over.
23:22:14 <sorear> actually I was planning on 50
23:22:31 <sorear> heh
23:24:23 <thetallguy> Any darcs experts here?
23:24:32 <thetallguy> darcs failThere are conflicts in the following files:
23:24:32 <thetallguy> ./src/compiler98/ByteCode/data/bytecode.xml
23:24:32 <thetallguy> ed:  Refusing to apply patches leading to conflicts.
23:24:32 <thetallguy> If you would rather apply the patch and mark the conflicts,
23:24:32 <thetallguy> use the --mark-conflicts option to apply.
23:27:40 <glguy> dcoutts: ghc is looking for Data.Tree in the gtk2hs dir
23:28:10 <glguy> locations searched: c:\program files\haskell\gtk2hs\imports\gtk/Data/Tree.hi
23:31:00 <humasect> 'Enum' applied to too many arguments ... but i see 'instance Enum Type Word8 where ..." in this code?
23:33:37 <Cale> Enum takes one type argument
23:33:58 <allbery_b> hat shoule be instance Enum Word8 where..., shouldn't it?
23:34:04 <Cale> My guess is you want one of Enum Type, Enum Word8, Enum (Type Word8)
23:34:33 <humasect> in SDL haskell binding code
23:35:23 <humasect> then 'fromEnum x = y'  and 'toEnum y = x'  .. this is not standard Enum is it ?
23:35:57 <markw2> humasect, which file in SDL?
23:36:07 <humasect> any under Core
23:36:12 <humasect> (.hsc))
23:36:42 <humasect> okay I see it, it is a custom Enum class (Utilities.hsc)
23:46:37 <dcoutts> glguy, hmm, that's interesting. remind me when I get back to check that out.
23:46:57 <glguy> dcoutts: alright
23:47:15 <glguy> thre have been two with issues, but I'll try to rebuild the .hi files later
23:47:45 <dcoutts> glguy, actually I think I can guess why that happens. feel free to email me or the dev list with any issues you find. That'll help me not to forget. :-)
23:47:56 <glguy> carsim is nifty
23:48:19 <glguy> I'm going to start a course in Computational Geometry on Tuesday
23:48:54 <glguy> I need to go through some of these demos so I can get up to speed and write my demo applets for the algorithms we do in class in gtk2hs
23:49:35 <dcoutts> glguy, that's probably the best way to learn the api at the moment - until we finish the tutorial, that and just referring to the haddock docs.
23:50:15 <glguy> the current haddock docs online seemed out of date
23:50:20 <mgsloan> write a computational geom lib :)
23:50:38 <glguy> I start the course Tuesday
23:50:47 <glguy> so I imagine that I'll need a few lectures before I've mastered it
23:51:38 <mgsloan> It's all pretty simple.  Main thing with the lib is design choices - correctness over usability
23:52:17 <mgsloan> eg, if you seperate Vectors and points you can't make a Num instance
23:52:49 <mgsloan> so you have to either make your own complicatedly named operators, or have just functions
23:53:15 <mgsloan> I've actually got a decent 2d geom start
23:54:14 <mgsloan> with a darcs history that includes seperation of point and vector and having just functions.  The current uses +^, -^, etc
23:59:27 <sorear> oh well, if I can't figure out how to cause a split on localhost ...
23:59:41 <sorear> squit kept saying *** Connection already registered
23:59:50 <sorear> @bot
