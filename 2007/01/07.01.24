00:00:04 <glguy> to shame you
00:00:12 <dons> heh
00:00:36 <glguy> you can have your code syntax colored however you like, as long as that color is "haskell"
00:01:05 <sjanssen> @remember glguy [on hpaste] you can have your code syntax colored however you like, as long as that color is "haskell"
00:01:06 <lambdabot> Done.
00:01:26 <glguy> I'd like my bikeshed painted "haskell", actually
00:02:03 <glguy> I think that sleeping is about to get in the way of my coding
00:02:09 <int-e> http://hpaste.org/71  doesn't look too bad ;)
00:02:34 <sjanssen> @src gcd
00:02:34 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
00:02:34 <lambdabot> gcd x y = gcd' (abs x) (abs y)
00:02:34 <lambdabot>    where gcd' a 0  =  a
00:02:34 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
00:03:06 <dons> the lexer based colouring is pretty flexible
00:03:17 <dons> so yeah, C looks good too
00:03:17 <hpaste>  sjanssen annotated "haskell C?" with "abomination!" at http://hpaste.org/71#1
00:03:43 <dons> heh
00:03:47 <dons> sjanssen++
00:04:02 <dons> i want 'reply'!
00:04:06 <dons> 'annotate' tells me nothin
00:04:19 <int-e> my vote: comment > annotate > reply ;-)
00:04:39 <int-e> where '>' is 'better as'.
00:04:42 <dons> glguy: the new input fields are much nicer
00:04:48 <glguy> thanks :)
00:04:52 <dons> i wanted those originally, and could't get the 1 pixel borders
00:05:04 <dons> glgu == leet css haxor
00:05:04 <glguy> I couldn't the first time I tried either
00:05:14 <glguy> s/leet/persistant
00:05:16 <int-e> sjanssen: I really wanted to test the highlighting :)
00:05:22 * allbery_b thinks the "link ..." links point the way, really
00:05:56 <hpaste>  dons annotated "haskell C?" with "better gcd" at http://hpaste.org/71#2
00:05:57 <allbery_b> annotate original / annotate #N
00:06:18 <int-e> dons: ouch
00:06:20 <sjanssen> heh
00:06:28 * glguy agrees
00:06:34 <allbery_b> yow
00:06:45 <glguy> allbery_b: "annotate annotation #1" ?
00:06:46 <glguy> :)
00:06:58 <allbery_b> just #1 will do, I think
00:07:02 <dons> allbery_b: but what about the 'annotate with no text' (i.e. comment)
00:07:11 <allbery_b> (I did think about that, briefly)
00:07:14 <glguy> lol
00:07:17 <allbery_b> "new annotation"
00:07:23 <Procyon> The submit buttons don't look right in my default Konqueror font size.
00:07:23 <dons> so reddit has 'comment for empty stuff, and 'reply' for annotatoins
00:07:51 * glguy might need to do a fontsize px for the submit buttons 
00:07:57 <glguy> since the image is fixed size
00:09:51 <allbery_b> or, since annotate for the entries has labels, bare annotate at the top seems not unreasonable
00:10:13 <glguy> allbery_b: i like bare because it is one word
00:10:16 <glguy> otherwise
00:10:22 <glguy> recent new annotation new
00:10:48 <dons> recent new reply
00:10:53 <dons> recent new comment
00:11:17 <glguy> but when they save that reply
00:11:21 <glguy> it will say
00:11:24 * allbery_b actually prefers separators there, e.g. recent | annotate | new
00:11:26 <glguy> "link to annotation #1"
00:11:40 <int-e> we need #haskell-bikeshed ;)
00:11:44 <allbery_b> words as you prefer of curse, but the visual separator is nice
00:11:50 <allbery_b> *course
00:13:32 <glguy> hmmm "new annotation" and "new"
00:13:54 <dons> 'link annotation #3' could really be 'link this' or 'link here'
00:14:07 <glguy> and annotate this?
00:14:11 <glguy> :)
00:14:21 <int-e> > fix link
00:14:21 <allbery_b> why not?
00:14:22 <lambdabot>   Not in scope: `link'
00:14:47 * allbery_b supposed anyoen who *really* doesn't like your decisions can use greasemonkey :)
00:14:51 <int-e> dons: it's a fixed point link.
00:15:12 <int-e> dons: or link fixed point, or something like that :)
00:15:46 <glguy> I'm going to start entering darcs patches with names:
00:15:53 <glguy> bikeshed: link wording
00:16:47 <glguy> there is a reason that HAppS supports XSLT
00:17:48 <astrolabe> I've got an interesting haskell problem
00:18:08 <astrolabe> I'll probably send it to cafe, but I thought I'd ask here first
00:18:45 <astrolabe> I'm coding up a tree search, a bit like a simple binary tree but more involved.
00:19:03 <astrolabe> It all codes into haskell very nicely, but....
00:19:17 <astrolabe> now I want to use bigger trees.
00:19:41 <dons> yay!
00:19:59 <dons> how big?
00:20:01 <astrolabe> I thought I could write a tree type that partitions the tree, and stores each partition in a different file
00:20:36 <astrolabe> Then write a function   unwrap :: StoredTree -> IO Tree
00:20:54 <astrolabe> and use my old tree search algorithms
00:21:07 <dons> glguy: I think I prefer "    * raw
00:21:07 <dons>     * link this
00:21:14 <astrolabe> But that doesn't work, because it says that all the file IO is done before the search
00:21:15 <dons> the origina to the "* this" form
00:21:17 <opqdonut> astrolabe: why not growTree :: Seed -> IO Tree :)
00:21:38 <dons> i.e. raw | link | annotate    instead of   raw   link tihs  annotate this
00:21:40 <astrolabe> opqdonut: :) Same problem I think.
00:21:47 <opqdonut> j/k :)
00:21:56 <int-e> astrolabe: that's akin to getContents, right? I hate suggesting this but it probably calls for  unsafeInterleaveIO.
00:22:01 <Procyon> Anyone here read "Types and Programming Languages" (affectionately known as TAPL)?
00:22:03 <glguy> dons: doesn't that get us back where we started?
00:22:09 <astrolabe> So, I think I need to have IO within the search algorithm
00:22:12 <dons> well, with | seperators
00:22:22 <dons> and no nosiying 'link annotatoin #3'
00:22:36 <dons> astrolabe: if you want to do IO off disk , on demand
00:22:40 <dons> unsafeInterleaveIO
00:22:41 <dons> should be ok
00:22:42 <astrolabe> int-e: thanks for the suggestion.  That would be a shame
00:23:02 <dons> its not really shameful or anything :) its the essence of the problem here
00:23:03 <opqdonut> astrolabe: "The getContents operation returns all user input as a single string, which is read lazily as it is needed (same as hGetContents stdin)."
00:23:13 <dons> partially storing things on disk (transparently)
00:23:13 <opqdonut> you'll probably want hGetContents
00:23:22 <int-e> astrolabe: but maybe that's still better than turning all your pretty pure code into IO code.
00:24:09 <astrolabe> Thanks dons, int-e, I'll look into that
00:24:13 <hpaste> last restart, and then bed!
00:24:23 <pejo> Procyon, lots of people have, why?
00:24:26 <astrolabe> thanks opqdonut:, I'm not sure that's sufficient
00:24:48 <astrolabe> opqdonut: The trouble is there are many files.
00:25:07 <araujo> hello
00:25:14 <dons> glguy: great. looks swishy dishy
00:25:24 <astrolabe> @hoogle unsafeInterleaveIO
00:25:24 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
00:25:34 <Procyon> pejo: does it cover type inferrence, with code (ie not just abstract theory) and specifically fixed point type inferrence?
00:25:48 <dons> my eyes burn when i see lisppaste now
00:25:52 <glguy> good night everyone
00:25:59 --- mode: ChanServ set +o dons
00:26:00 <astrolabe> g'night
00:26:02 --- kick: lisppaste2 was kicked by dons (dons)
00:26:06 --- mode: ChanServ set -o dons
00:26:07 <glguy> OMG lol
00:26:11 <dons> the victory is complete!
00:26:13 <Procyon> lol
00:26:22 <glguy> the sound effects were awesome
00:26:26 <pejo> Procyon, attapl has a chapter (out of 4?) on Hindley-Milner with type inference. Don't remember seeing any code in there.
00:26:36 <glguy> Colloquy actually blew lisppaste up
00:26:46 <dons> heh
00:26:47 <araujo> hello!
00:26:56 <glguy> "zipzip" "BOOM" "squeek"
00:27:01 <glguy> +o kick -o
00:27:04 <Procyon> pejo: thx
00:27:12 <pejo> Procyon, but the book by Simon Peyton Jones (avail on his webpage) has Miranda code for type inference in HM.
00:27:15 <dons> hey araujo. got hpaste yet?
00:27:26 --- mode: ChanServ set +o glguy
00:27:33 --- kick: glguy was kicked by glguy (bed)
00:27:41 <dons> oh dear
00:27:45 <dons> glguy's gone insane with power
00:28:05 <pejo> Procyon, if you're not in a great hurry it's probably worth taking the "detour" through TAPL though, I'd say.
00:28:10 <araujo> hi dons , how you doing!?
00:28:18 <araujo> dons, hpaste?
00:28:22 <dons> hpaste!
00:28:26 <dons> ?paste <--
00:28:26 <lambdabot> http://hpaste.org (Haskell pastebin)
00:28:31 <araujo> wow!!!!!
00:28:46 <araujo> yay!!
00:28:57 <dons> woo!
00:29:01 <araujo> nice stuff
00:29:02 <Procyon> pejo: I'm specifically looking for something to fully grok writing type inference algorithms... I specifically need to be able to type the Y combinator (which Haskell doesn't)  Hence I'm looking for a good, SICP style tutorial text just to wrap my brain around the issues
00:29:17 <astrolabe> Wow.  I haven't looked at the haskell weekly news for a while.  It's got a lot busier!
00:29:38 <dons> oh yeah, geez, need to get that out
00:30:50 <dons> bah, finally, 19:27  lambdabot> uptime: 19s, longest uptime: 2m 26d 6h 57m 25s
00:31:46 <pejo> Procyon, uh. Do you want to write your own fixed point combinator, or understand why it isn't typeable the way you expressed it, or something else?
00:33:31 <Procyon> pejo: Specifically, I am writing a Koza GP.  I want to implement variables and recursion, however, I don't want the messiness of dealing with the unelegant mix of lambda and crossover
00:34:05 <Procyon> pejo: Y in terms of S and K combinators seems to me like a great comprimise.
00:34:55 <Procyon> pejo: I will however, need some other primitives, and adding function application, I want to strongly type it to keep my search space constrained.
00:35:19 <dons> hey mnislaih
00:35:23 <dons> mnislaih: seen hpaste.org ?
00:35:29 <dons> our new pure haskell paste bin :)
00:35:38 <mnislaih> yeah, saw it !
00:35:54 <dons> finally, a good web app in haskell1 ;)
00:36:22 <Procyon> pejo: to my dismay, I am finding the concept of writing a type inference algorithm that can type S and K *and* not got infinite on me when I express the Y combinator extremely daunting as I have no experience with type unification in the first place.  So, I need a good text.
00:36:29 <mnislaih> that's certainly a step in the direction we want to follow
00:37:57 <therp> procyon: nice intentions. but how would you like to use haskell in this case? via the GHC api?
00:39:54 <Procyon> therp:  Well, beginning my study on the type inference problem led me to haskell... it's fascinating and so I am writing this particular little experiment in haskell just for the experience.  But no, I am coding it up as an interpreter in haskell using Parsec and ye ol' eval apply loop.
00:40:38 <Procyon> therp: I can't use haskell's type inference for 2 reasons
00:40:50 <therp> procyon: ah ok, so a lambda "interpreter"?
00:41:19 <pejo> Procyon, I'm guessing you're drifting over to SK-calculus, which I admittedly know nothing about. But why not put recursion on the top level, having a set of top level bindings g_i = v_i, with the type rule premise {g_i : tau_i} |- v_i : tau_i, for all i  and the conclusion |- { g_i = v_i } well-typed?
00:41:54 <Procyon> therp: 1) it doesn't do fixed points, so I can't express the Y combinator naturally 2) It doesn't reflect well enough that I can ask dynamically for a list of all functions matching type T without doing some severely advance stuff I don't want to do
00:42:22 <Procyon> therp: SKI interpreter actually, but yeah
00:42:56 <therp> procyon: SKI is just lambda at the inside, no?
00:43:20 <huschi> darcs tells me: "Couldn't read patch <date of patch> <author>"
00:43:29 <therp> I have written a lambda interpreter with a bit type inference in Common Lisp just for the purpose of GP
00:43:31 <huschi> has anybody ever noticed this failure?
00:43:32 <Procyon> therp: kinda.. both can be expressed as each other, but SKI has no variables (which are problematic in GP)
00:43:46 <therp> procyon: ah ic.
00:44:26 <int-e> In other words, SKI is pointfree. @pl contains a translation from lambda calculus to SKI (using ap, const and id), among other things.
00:44:40 <Procyon> SKI can *do* the same thing as variables, but as a special form of function application.
00:44:41 <therp> int-e: ah ok
00:45:58 <Procyon> pejo: Your notation is beyond me (If it wasn't I have a feeling I could code up a type inference algo right now, but as it is, I am still grokking the type problem)
00:46:47 <therp> procyon: do you know TAPL by benjamin pierce?
00:47:35 <huschi> huschi: i fixed my problem.
00:47:47 <Korollary> Procyon: Maybe this paper helps: http://lambda-the-ultimate.org/node/1929
00:47:48 <lambdabot> Title: A modern eye on ML type inference - Pottier 2005 | Lambda the Ultimate
00:48:05 <Procyon> therp: I know *of* it, which is what pejo and I were discussing.  I was asking if it would get my (a seasoned schemer and C++ guy's) mind around type algo's enough to just code up what I need.
00:48:19 <pejo> Procyon, well. I'm not sure it is what you are looking for actually. I don't think I fully understand your problem, and I definitely don't have a workaround for inferring infinite types.
00:49:33 <therp> procyon: sure. type inference isn't that hard. the algorithm itself is quite simple. unification is also quite simple. TAPL has ML-code available for download btw. you could start playing with it, and hope to undercut the effort of learning the basics.
00:49:51 <Procyon> pejo: I got a reference implementation of one the other day that fried my brain.
00:50:40 <astrolabe> TAPL only has one chapter in type inference iirc.  I haven't got to that chapter yet, but the rest is an almost obligatory introduction to types done properly from what I can tell.
00:50:59 <Procyon> therp: I grok unification.  Type inference is almost there.  I've been trying to undercut the learning for a bit now, and it's not working, so I need to formalize my training now ;)
00:51:41 <therp> procyon: well then, the first chapters of TAPL will do.. reading up to Chapter 9 should give you enough hints to read Chapter 22, type inference..
00:52:23 <mnislaih> any unification expert? What modifications wrt implementation does unification modulo a set equations require?
00:52:52 <mnislaih> I know that it is undecidible, but it should still usable for small problems I guess
00:53:03 <Procyon> therp: cool.  PLAI helped alot, but the actual implementation was "left for an excersize for the reader"... <sigh>
00:54:04 <therp> procyon: http://www.cis.upenn.edu/~bcpierce/tapl/checkers/recon/ <- that's the type reconstruction implementation from TAPL
00:54:05 <lambdabot> Title: Directory Index
00:54:56 <therp> procyon: core.ml contains the function "recon" which recursive generates the set of constraints that is later sent to "unify"
00:55:29 <Procyon> pejo: I have a feeling what you are suggesting is to make primitive bindings for automatically defined functions that allow recursion.  I could do that, but that gives me a finite arbitrary nimber of them.  I would like to do natural recursion by letting the GP use the Y combinator indescriminately.
00:55:30 <pejo> (I think it was Pottier who wrote the chapter in attapl as well, so the contents of that article from Korollary might be nearly the same if you're lucky).
00:56:41 * Procyon makes lots of bookmarks for some exhausting reading tomorrow
00:56:43 <pejo> Procyon, yeah, that was essentially what I was suggesting, I think.
00:59:20 <Procyon> SKI combinators solve all my issues (recursion and bindings-free variables) and are trivial to code up (I don't know haskell hardly at all and I have 90% of the interpreter done)  Typing them is the hard part ;)
01:00:03 <pejo> Procyon, does your language have recursive data types?
01:02:37 <Procyon> my language is trivial. The primitives S x y z = (x z)(y z), K x y = x, Integer, Double, Bool, Lists and some function primitives, like +,-,*,cons,car,cdr
01:03:03 <Procyon> No variables.  No lambdas.
01:03:32 <Procyon> As they can be expressed in terms of S and K, as can recursion, since Y can be expressed in terms of S and K
01:04:12 <int-e> Procyon: I'd consider adding Y (well, a fixed point combinator) as a primitive.
01:04:13 <Korollary> Wow
01:04:15 <Korollary> http://en.wikibooks.org/wiki/Programming:Haskell
01:04:25 <Korollary> The printable version is 260+ pages
01:04:59 <Procyon> int-e: yes.. just so the GP doesn't have to come up with it itself.  Getting it working at all is my main concern right now though ;)
01:05:01 <dons> its pretty good
01:05:14 <int-e> Procyon: the reason being that in the simply typed lambda calculus, fixed point combinators can't be typed. you need some sort of type polymorphism to do that which isn't entirely trivial (I don't know how it can be done)
01:05:26 <pejo> int-e, darn, you beat me to it.
01:05:40 <int-e> Procyon: and for the purpose of type inference, SK and lambda calculus are pretty much the same.
01:06:56 <int-e> Procyon: actually Haskell does that, too. If you look at the desugaring for let bindings, you'll find that they involve using 'fix' ... if you try to desugar fix itself you define fix in terms of fix.
01:07:07 <Procyon> int-e: sorear (sp?) inferred SKI types, including recursive in some code he gave me 2 days ago... I'm trying to wrap my brain around it.
01:07:12 <int-e> Procyon: as far as the haskell report goes, anyway.
01:08:21 <therp> procyon: why are you coding this? part of any academic research?
01:08:40 <hpaste>  procyon pasted "infered ski" at http://hpaste.org/72
01:09:14 <Procyon> therp: yes.  Informal research though.
01:09:31 <therp> procyon: located where?
01:09:59 <Procyon> therp: nowhere.  I'm on my own.
01:10:04 <therp> procyon: great
01:10:54 <Procyon> therp: Hope to go back to school one day.  For now I'm a code monkey, but I may begin at an AI startup in a few months.
01:10:55 <therp> procyon: as I said before, I've written something similiar in Common Lisp and the lambda calculus, with the same intentions
01:12:10 <Procyon> therp: yeah.  I did the first bit in scheme, then decided I needed to strongly type it, which led to a quest to grok type inference for tree generation, which led me to haskell, which led me here ;)
01:12:53 <therp> procyon: ha :) I also ended up with Haskell  working on GP
01:13:09 <therp> but at the moment I'm not doing GP, but a Lisp like Haskell variant
01:14:42 <Procyon> therp: Sounds great.  In my short time coding Haskell, I love the typing and lazy application... Hate the syntax.  It might be an "I'll get used to it" thing.
01:14:58 <araujo> Procyon, the syntax is one of its beauty!
01:15:23 <araujo> Real beauty takes time to be noticed.
01:15:31 <therp> procyon: I'm afraid, it's not one of such things for me. Editing Haskell code is so much more cumbersome than editing a sexp-based language. but soon this is changing :)
01:16:55 <Korollary> how is it changing?
01:17:34 <Procyon> araujo: It's pretty, yes.  What I don't like about it is it has all the warts of precedence and left-right-infixity that c++ has, except in C++ you generally don't chain and use point-free style so you speak in short sentances. In lisp, you simply don't concern yourself with syntax.
01:18:00 <therp> korollary: http://clemens.endorphin.org/ILC07-Liskell-draft.pdf
01:19:50 <therp> this paper is one month old, in the mean time I have lot of more nice things to show in the area of meta-programming :).. embedded prolog is my favorite
01:20:11 <araujo> Procyon, precedence is needed. though it is very simple to grasp at
01:21:25 <araujo> Procyon, we also don't use too much the word 'chain', but 'composition'
01:21:38 <Procyon> araujo: precedence is only needed because haskell mixes fixity.  If you only allowed prefix (or infix, or, god forbid postfix) then you eliminate the need for precedence, as Lisp does.
01:21:58 <araujo> Haskell syntax might be reduced to just function compositions.
01:23:12 <araujo> Procyon, and then to trow at us all those parentheses? :-)
01:23:46 <Procyon> araujo: it can be, but it's readibility rapidly approaches zero ;)  On one hand, I like the math-like look of the language.  On the other hand, I miss being able to just look at the front of the expression to see what it's doing.
01:23:56 <psnl> $ syntax $ is $ hard
01:24:04 <Procyon> hehe
01:24:07 <araujo> Haskell syntax makes it as natural as Lisp; you always can use operators as functions too.
01:24:28 <araujo> > (+) ((-) 6 2) 9
01:24:30 <lambdabot>  13
01:24:48 <araujo> operators == functions
01:25:20 <Procyon> araujo: you *can* write it just like lisp.  I think you'd get laughed at for doing so :)
01:25:41 <Procyon> ((+) ((-) 6 2) 9)
01:25:48 <araujo> Well, that's for all those lisp programmers that feel proud of so many parentheses
01:25:54 <araujo> we have more parentheses!
01:26:08 <Vq^> heh
01:26:11 <araujo> ;-)
01:26:18 <int-e> and to make things even better, ((+) 1 2 3) won't work :)
01:26:38 <araujo> int-e, redefine with map
01:26:40 <therp> int-e: In Liskell, this works.
01:26:44 <araujo> haha
01:26:51 <Korollary> I dont think more than 10% of this channel knows the precedence levels of prelude operators.
01:26:53 <Procyon> hehe.  I've seen lisp done with no perens, only indentation also.
01:26:54 <araujo> therp, you working on it right?
01:27:04 <araujo> Korollary, haha yeah
01:27:08 <therp> araujo: with respect to basic compiler syntax it's finished.
01:27:11 <Vq^> > ((((+) .) . (+)) 1 2 3)
01:27:12 <lambdabot>  6
01:27:41 <therp> araujo: at the moment I'm working on stuff like DRiFT reimplementation and an a field like syntax sugar.. macros work, quasiquotion works, prolog works.
01:27:43 <araujo> Really, precedence is very unnoticed because of Haskell simplicity
01:28:02 <dons> > (((((+)(.))(.)(+))(1)(2)(3)))
01:28:03 <lambdabot>   add an instance declaration for (Num (a -> b))
01:28:07 <araujo> The fact of making operators just plain functions; avoid all confusion.
01:28:08 <dons> doh ;)
01:28:12 <Vq^> dons: :P
01:28:18 <araujo> dons, insanely fun :-)
01:28:22 <dcoutts> @unmtl StateT Buffer (ContT [ByteString] IO) a
01:28:22 <lambdabot> Buffer -> ((a, Buffer) -> IO [ByteString]) -> IO [ByteString]
01:28:25 <dons> whitespace is for python!
01:28:28 <Korollary> therp: If this is going to be a GHC frontend, does that mean
01:28:33 <dons> parens forever!
01:28:50 <dcoutts> kolmodin, that's the example where @unmtl should curry
01:28:50 <Korollary> therp: that you're going to fork ghc, or check this in?
01:28:59 <dcoutts> the cont has type :: ((a, Buffer) -> IO [ByteString])
01:29:10 <sieni> Liskell looks really promising
01:29:12 <therp> korollary: I don't know. I will meat SPJ in April, presumable with that being the topic.
01:29:12 <dcoutts> but we want (a -> Buffer -> IO [ByteString])
01:29:26 <Korollary> Yum
01:29:29 <araujo> Procyon, It is difficult to see what an expression is doing right away, because you must be used to other syntax now. But try Haskell for a while; and you will realize how clear and concise it gets for you.
01:29:32 <therp> korollary: but at the moment, I'm fine with a separate darcs repo
01:29:40 <Korollary> therp: good luck either way
01:29:52 <kolmodin> dcoutts: something is wrong?
01:30:02 <dcoutts> kolmodin, I want more currying :-)
01:30:03 <therp> in fact, I'm fighting with mplex to merge my audio to my video stream to finally publish Liskell screencasts
01:30:15 <Procyon> araujo: I'm sure.  Right now it's annoying.  Eventually I'll get used to it (I hope)
01:30:16 <kolmodin> how would you like it?
01:30:34 <dcoutts> therp, you mean a proper way to add 'deriving Binary' to the language without extending the compiler?
01:30:35 <kolmodin> oh, /me reads up
01:30:46 <therp> procyon: except that emacs haskell-mode isn't as perfect as SLIME is, Haskell syntax is quite ok (for lisp guys like us)
01:30:50 <araujo> hello dcoutts , kolmodin
01:30:54 <dcoutts> hia araujo
01:31:10 <araujo> therp, we need to get hIDE :-)
01:31:23 <therp> dcoutts: right. I finished my personal proof-of-concept for "Eq" last week.
01:31:40 <dcoutts> therp, cool. We want deriving Binary!
01:32:02 <dcoutts> therp, our nearest solution at the moment is an SYB style function that generates code for Binary instances
01:32:05 <kolmodin> dcoutts: yeah, currying could be done. but I can't do it now
01:32:09 <Procyon> Anyway.   Need to sleep.  Night all.
01:32:10 <dcoutts> kolmodin, ok :-)
01:32:11 <therp> dcoutts: no problem :) .. writing source files that modify the compiler while being compiled is easy for Liskell :)
01:32:36 <dcoutts> therp, aye, we do that already with TH and GHC RULES
01:33:45 <therp> dcoutts: I have look at both, TH and RULES, and I've not had the impression that I can do stuff like this http://clemens.endorphin.org/Prolog.lsk with it
01:33:59 <therp> dcoutts: (the interesting thing is at the end)
01:34:15 <araujo> Procyon, you ar enot alone. I remember when i started learning haskell (coming from a C/Lisp background) ; Even C looked more readable by then. I couldn't find my way around al _that_ weird off-side rule for indentation. (why did they choose this syntax?; it's insane, i need to count whitespaces every time i need to indent something ....) , it's what i thought :-)
01:34:16 <therp> especiall main, where with-inference is used to evaluate prolog predicates
01:34:43 <araujo> argh, he left
01:34:47 <araujo> :-)
01:35:06 <dcoutts> therp, I'm not sure I understand what I'm looking at
01:35:50 <therp> dcoutts: ok well, nevermind. I hope to present this source in a better more pedagogical way soon.
01:35:57 * araujo is now scared of reading C code
01:35:58 <dcoutts> good good
01:36:31 <therp> when I ever come around to find a good mplex/mencoder tutorial..
01:38:47 * earthy isn't scared of reading C
01:39:00 <earthy> Java however...
01:39:04 * earthy shudders
01:47:52 <nornagon> earthy: hey, I'm told you have a nice vim script for haskell stuff
01:48:53 <kowey> (speaking of vim, /me just discovered that turning off cindent helps a big deal when dealing with birdtracks)
01:49:08 <nornagon> birdtracks?
01:49:24 <kowey> the > in literate Haskell files
01:49:48 <nornagon> oh.
01:50:02 <kowey> the problem with cindent is that it tries to indent them, e.g. "   >"
01:50:05 <nornagon> yeah, i usually have cindent off
01:50:12 <nornagon> autoindent works well
01:50:23 <kowey> cindent is probably a legacy from my Java days
01:50:51 <Korollary> You can't fight in here! This is the warroom!
01:51:06 <dr_strangelove> what's the difference between Control.Monad.State and Control.Monad.ST ?
01:52:41 <dr_strangelove> Korollary, ok I try to refrain
01:53:02 <int-e> dr_strangelove: that's a funny question. They have little in common.
01:54:03 <dr_strangelove> int-e, I'm just starting with haskell. I try to maintain some application state and don't know where to start ...
01:55:03 <int-e> dr_strangelove: ST is a monad that allows you to define computations that involve mutable arrays and variables and turn them into pure computations using runST. It's a 'magical' monad, akin to IO, but without actual I/O (it's limited to in-memory stuff). State is a monad that allows you to carry a state - of a type of your choice - around through a computation without having it to pass around explicitely.
01:55:40 <kolmodin> dcoutts: ok, I've got patches for currying now
01:55:41 <int-e> dr_strangelove: the State monad is also defined using pure Haskell code, unlike ST.
01:55:59 <dcoutts> kolmodin, hah hah, you said you had better things to do! :-)
01:56:03 <dcoutts> couldn't resist eh?
01:56:27 <kolmodin> I lied
01:56:29 <kolmodin> :)
01:56:44 <dr_strangelove> I have a gtk user interface and want to store the user input somewhere ... so probably ST?
01:56:46 <kolmodin> can you apply to the repo, otherwise I'll send them to dons
01:57:29 <kolmodin> dcoutts: ^^
01:57:36 <dcoutts> kolmodin, send it to dons, I don't have perms
01:57:42 <kolmodin> ait
01:58:04 <kolmodin> dcoutts: it joins tuples now too
01:58:12 <dcoutts> oh good
01:58:17 <int-e> dr_strangelove: no, probably not. probably a StateT ApplicationState IO (where ApplicationState is your own type), but ... uhm ... that may be a little too much at once if you're just starting
01:58:29 <kolmodin> so you don't end up with IO (((s,b),c),r)
01:58:34 <dcoutts> right
01:58:35 <kowey> (probably State is good enough to start out with)
01:58:47 <dcoutts> dr_strangelove, ST? the most straightforward is a IORef or MVar containing a state record
01:59:09 <dcoutts> or one can use a thread + channel and let the thread accumulate the state
01:59:25 <kolmodin> dr_strangelove: I've almost never used the ST monad, you only need it for very special things
02:00:15 <kowey> it is a fair question though... you look in the API for State, you see both ST and State and in the both docs, you see "State" and some other gobbledygook
02:00:32 <kolmodin> yeah, I've been confused about that too
02:02:00 <kowey> i also suspect that the IORef response is the most pain-free, since you're working in IO anyway
02:02:16 <int-e> . o O ( "If you have to ask, you don't want to use ST" )
02:02:38 <dr_strangelove> ok, thanks, I try to go with IORef ...
02:02:40 <kowey> i wonder if there is a polite way to phrase this in the docs
02:02:50 <kowey> "confused about ST vs. State? you probably want State"
02:03:24 <araujo> who wants State?
02:03:37 <int-e> StateT is nice.
02:04:04 <kolmodin> yeah, especially now that it's "sooo much easier" to roll your own... :D
02:04:05 <int-e> well, mostly nice. 'modify' has a strictness problem.
02:04:08 <araujo> State if for the weak
02:04:12 <araujo> is*
02:04:15 <kowey> purity of essence?
02:04:18 <kolmodin> araujo: how so?
02:04:43 <araujo> kolmodin, The State is for the weak.
02:04:49 <araujo> :-)
02:05:26 <kolmodin> the united states?
02:05:28 <kolmodin> :)
02:05:32 <araujo> hahaha
02:06:49 <int-e> > runState (replicateM_ 1000000 (modify succ)) 0
02:06:51 <lambdabot>  Exception: stack overflow
02:08:06 <kolmodin> yeah, but that's due to the (1+(1+(1+(1+....-problem, isn't it?
02:08:35 <kolmodin> that's to be expected. I don't want a strict state by default
02:09:06 <int-e> kolmodin: I agree, but having a strict version of modify would be nice.
02:09:18 <kolmodin> int-e: hmmm. true
02:09:32 <kolmodin> let's cal it modify!!!
02:09:42 <kolmodin> that is "modify!!!"
02:10:01 <kolmodin> I like when you can use ! and ? in names.. :)
02:10:08 <araujo> Most of the time i thought i had to use State on my programs ; it was because i was thinking from an imperative way
02:10:19 <int-e> maybe ... modify' f = do x <- get; let x' = f x; x' `seq` put x'
02:10:45 <kolmodin> int-e: that looks like the obvious way to do it. nice
02:10:47 <araujo> For the rest, IORef seems enough for most of the tasks.
02:11:13 <kolmodin> araujo: what a horrible thought
02:11:14 <roconnor> araujo: are you saying that you think that most uses of State were a mistake?
02:11:15 <int-e> kolmodin: oh. put $! x'
02:11:23 <kolmodin> int-e: right
02:11:28 <kolmodin> same but different
02:11:34 <kolmodin> hia Jaak
02:18:09 <Jaak> morning
02:19:21 * kolmodin goes away...
02:22:13 <csci> Just out of curiosity: How do I write a function like "pr [] = []     pr (x:xs) = x : pr xs" using guards starting "pr (x:xs)" . I tried several versions, but all gave me type errors? Besides the usability, is it possible?
02:23:24 <roconnor> I don't understand
02:23:38 <csci> I'll use paste, a second please
02:23:40 <csci> !paste
02:23:40 <hpaste> Haskell paste bin: http://hpaste.org/
02:24:54 <hpaste>  csci pasted "Guard question" at http://hpaste.org/73
02:25:19 <resiak> <some magic> is "null (x:xs)"
02:25:25 <resiak> but that's not going to work
02:26:04 <csci> yes, I tried (x:xs) == []
02:26:07 <csci> Gives me an exception
02:26:23 <nornagon> x:xs will never be null, though, right?
02:26:32 <norpan> never
02:26:48 <hpaste>  resiak annotated "Guard question" with "(no title)" at http://hpaste.org/73#1
02:27:05 <hpaste>  roconnor annotated "Guard question" with "(no title)" at http://hpaste.org/73#2
02:27:30 <resiak> the shortest answer is "pr = id" ;)
02:27:56 <csci> What does y@(x:xs) mean, never saw that syntax? (haskell beginner btw)
02:28:02 <csci> resiak: *g*
02:28:07 <norpan> it means y is bound to the whole list
02:28:14 <csci> ah, thanks
02:28:26 <norpan> but the list must be in x:xs form
02:28:35 <roconnor> yeah, it allows you to get a variable for the entire list, and do pattern matching as well.
02:28:46 <roconnor> norpan: oh crap you are right
02:28:50 <roconnor> my code doesn't work.
02:28:55 <resiak> y@~(x:xs) ? :)
02:29:19 <csci> yes, exception :-(
02:29:21 <norpan> roconnor: huh?
02:29:29 <hpaste>  (anonymous) annotated "Guard question" with "(no title)" at http://hpaste.org/73#3
02:29:51 <norpan> ah
02:30:00 <csci> And I thought this is a trivial syntactic question... *laughs*
02:30:15 <roconnor> heh, resiak is right, y@~(x:xs) will work, but it is very very wrong
02:30:20 <norpan> i suppose you can use y@~(x:xs)
02:30:28 <norpan> but WHY
02:30:57 <resiak> just match xs then use head and tail...
02:31:06 <roconnor> I like resiak's head tail solution best.
02:31:30 <csci> could you give an example. I'm not sure I understood
02:31:40 <roconnor> actually I like pr [] = []; pr (x:xs) = x : pr xs most of all
02:31:46 <norpan> pr list = if null list then ... else ... (head list) ... (tail list)
02:31:49 <csci> I do, too :)
02:32:06 <csci> norpan: Ah, yes, the non-guard version :)
02:32:09 <beschmi> and it shows why the original solution (matching on [] and (x:xs)) is superior
02:32:35 <csci> As I've written: It was just a "hmm, does this work" - curiosity question because it looks a bit "cleaner"
02:32:41 <resiak> csci: The first annotation on your paste is a working guardy version
02:32:41 <norpan> i often do it like this: pr list = case list of [] -> []; x:xs -> x:pr xs
02:33:01 <csci> yes, also a good idea
02:33:27 <norpan> that way you have access to "list" and also you only have to write the function name once
02:33:49 <norpan> of course, the best code is pr = id
02:34:04 <csci> ;-)
02:34:21 <norpan> saves you some cycles too
02:34:28 <norpan> or pr = map id
02:34:30 <csci> of course
02:34:51 <csci> Thanks to all who helped :). One curiosity question less
02:53:45 <araujo> roconnor, yes, in my case.
02:54:06 <araujo> kolmodin, why!? , it has worked fine for me
02:54:36 <araujo> Be careful, i am not saying state is evil. I am saying that most of my time it wasn't needed :-)
02:55:06 <roconnor> sure, I understand.  But now I'm thinking about my uses of state, and if they were needed.
02:55:27 <araujo> roconnor, that's important
02:55:33 <roconnor> I remember when I was a teenager when I was trying to shake my additction to goto.
02:55:47 <roconnor> I remember one Pascal program when I was sure I needed a goto.
02:55:56 <roconnor> Looking back, I was probably wrong.
02:55:58 <araujo> kolmodin, oh, i think i misunderstood your statement , hah, never mind :-)
02:56:04 <roconnor> Too bad I don't have that code to look at again.
02:56:38 <mux> there are a few cases where goto is useful in imperative languages
02:57:05 <roconnor> mux: true, I've used them in university in C in places where I would use a labeled break in java.
02:57:07 <mux> breaking out of nested loops without making the termination conditions a mess
02:57:19 <mux> when you have lots of resources to release (memory, mutexes..)
02:58:02 <araujo> i think goto is very useful on lower level code
02:58:07 <roconnor> I use State monad in my upcoming article in the Monad Reader.
02:58:22 <araujo> For example, a kernel, or driver
02:58:22 <roconnor> Actually I use the reader-writer-state monad.
02:58:40 <roconnor> Now I wonder how or if I could do it without state.
02:59:07 <mux> you can always add the State type as a parameter to every function and pass it around :-)
02:59:16 <roconnor> mux: ;)
02:59:16 <mux> but that's precisely what the State monad wants to avoid
02:59:46 <roconnor> okay, I know I could do it whithout the state monad, but how to do it some completely different, and more elegent way?
02:59:56 <araujo> roconnor, i think, that's _always_ a good queestion to ask yourself
02:59:59 <mux> I'm probably not qualified enough to speak
03:00:10 <mux> besides, I didn't see your code =)
03:00:24 <robreim> Anyone familiar with what might cause this problem in hs-plugins? user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
03:00:25 <roconnor> araujo: I thought my code was pretty elegent already ;)
03:00:35 <roconnor> mux: you will get to see it soon
03:00:55 * mux chokes
03:01:06 <mux> hs-plugins: bringing the joy of Linux shared library model to Haskell
03:01:42 <robreim> :)
03:02:21 <roconnor> mux: once house gets off the ground, we won't need Linux anymore ;)
03:02:27 <roconnor> House
03:02:57 <bakert> Anyone used Text.Html or Text.XHtml and know how to add a link? :(
03:03:08 <bakert> What is this bonkers hotlink thing, and do I have to use it?
03:03:56 <mux> roconnor: what's House?
03:05:47 <robreim> mux: Haskell User's Operating System And Environment: http://programatica.cs.pdx.edu/House/
03:05:49 <lambdabot> Title: House
03:05:58 <robreim> (shouldn't that be Huose?)
03:06:07 <mux> oh
03:06:13 <mux> thanks
03:09:13 <araujo> roconnor, :-)
03:09:40 <robreim> ?where House
03:09:41 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
03:10:10 <robreim> I should use lambdabot more...
03:10:43 <Axioplase> Is there a nice program that takes a haskell source and spits it out the coloured and HTMLized ? (except my text editor or yours)
03:11:45 <dr_strangelove> what do you recommend for web development? HAppS?
03:12:52 <robreim> dr_strangelove: I just used HAppS for a project and it was really nice. It's fairly new and I guess there might be some undiscovered problems but it seemed great for what I was doing.
03:14:22 <dcoutts> Axioplase, hscolour
03:14:33 <dcoutts> @where hscolour
03:14:33 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
03:14:41 <dr_strangelove> robreim, what database backends are supported?
03:15:52 <robreim> dr_strangelove: it doesn't use an external DBMS by default. AFAIK it doesn't support any at all. Instead it uses its own internal ACID storage facility. The upshot is it improves performance by not having to communicate with a DBMS all the time
03:16:58 <robreim> Also the storage is written asynchronously with communication from what I understand, so HTTP responses can be returned before data is commited rather than waiting for a DBMS update to complete
03:17:24 <bakert> Which is lovely if you aren't integrating with an existing system.
03:18:09 <robreim> Yeah. Even lovelier if you have to distribute it to people since it works out of the box without a DBMS.
03:18:13 * robreim hugs HAppS
03:18:47 <Axioplase> dcoutts: thanks
03:19:07 <musasabi> HAppS could support SQL databases if the API wrapped 2-phase-commit which several databases support, but their Haskell APIs not.
03:19:15 <bakert> I tried HAppS but as a haskell newbie with a postgresql db to use I got a bit stuck.  I'm going to have another go at it when I have something green field to do.
03:19:39 <bakert> I did get it talking to the postgres db but going any further than that was tricky.
03:20:04 <bakert> One of the guys on here is working on a more complete HAppS tutorial which will be good for clueless people like me!
03:26:32 <kolmodin> dcoutts, dons: I just where to the chalmers thesis stuff area, there really is a board there saying "haskell weekly news" :D
03:26:44 <dcoutts> yay :-)
03:27:21 <dons> hehe
03:27:36 <Saizan> bakert: still need help with hotlink?
03:28:05 <dons> 'newsflash: chalmers student writes lambdabot plugin'
03:28:13 <dons> still time to get that into the weekly news
03:28:30 <kolmodin> yay :)
03:28:32 <dons> bakert: there's plenty of 'hotlink' in hpaste
03:28:43 <dons> ?where hpaste <-- its all happs-ish
03:28:43 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
03:28:50 <kolmodin> dons: you saw the new patches in your mailbox?
03:28:53 <dons> yeah
03:28:59 <dons> gotta apply them in the morning.
03:29:01 <dons> sleep time now!
03:29:03 <dons> night all :)
03:29:03 <bakert> dons, Saizan, I used "anchor".   is that bad?
03:29:03 <kolmodin> ok, good
03:29:07 <kolmodin> g'night dons
03:29:19 <robreim> dons: any idea what might cause this in hs-plugins? user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
03:29:23 <bakert> Will have a look at hpaste source
03:29:31 <robreim> d'oh
03:29:56 <sris> I just installed http://haskell.org/ghc/dist/6.6/ghc-6.6-i386-apple-darwin.tar.bz2 but when i try to use ghc i get this  "Did find: /Library/Frameworks/GMP.framework/ Versions/A/GMP: mach-o, but wrong architecture" error message. Im gessing i have the wrong GMP.framework but im not sure if i can just remove it and try to reinstall. Because i read that the package was supposed to instal GMP for me.
03:29:57 <bakert> ah yes hotlink is better than anchor
03:30:20 <sris> I had an older ghc version installed before, but the "uninstall" didn't work so i simly removed it ; )
03:30:23 <Saizan> bakert: uhm, dunno, however you can do hotlink "url" << thing_that_will_be_inside_the_a_tag
03:31:07 <bakert> Saizan, I got confused by type "URL" for the first arg.  But that will take a String.  Must be a newtype or something.
03:31:12 <bakert> Thanks,
03:41:49 <Saizan> yeah, i'm often confused by all those type synonims
03:58:13 <dcoutts> Saizan, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
03:58:16 <dcoutts> @seen ndm
03:58:16 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 12h 11m 40s ago, and .
03:58:58 * dcoutts prepares the announcement
04:01:09 <kolmodin> dcoutts: yay!?!
04:01:53 <Saizan> dcoutts: properly detected "offending" .dlls :)
04:01:59 <dcoutts> Saizan, yay
04:02:07 <dcoutts> and it tells you where they are?
04:02:20 <Saizan> c:\programmi\ruby\bin\iconv.dll
04:02:20 <Saizan> c:\programmi\ruby\bin\zlib1.dll
04:02:22 <Saizan> yeah
04:02:34 <dcoutts> Saizan, if you've got any suggestions for more helpful instructions for dealing with the problem then do say
04:02:45 <dcoutts> I mean for the text that goes in that box
04:04:01 <dcoutts> kolmodin, aye, nearly done
04:04:12 <kolmodin> good news
04:04:44 <dcoutts> @arr
04:04:44 <lambdabot> Yo ho ho, and a bottle of rum!
04:05:10 <dcoutts> sent!
04:05:22 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.tar.gz
04:05:23 <dcoutts> http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
04:05:38 <dcoutts> Gtk2Hs 0.9.10.5 source and win32 installer ^^^
04:05:51 * dcoutts commends them to the world for testing!
04:07:10 <Saizan> dcoutts: it's quite clear to me, it could also suggest to put the gtk2hs path in front of the system-wide path maybe
04:07:36 <dcoutts> Saizan, yeah, that's one possibility though at the moment the installer would still bork on that.
04:07:45 <dcoutts> since it doesn't modify the global path
04:07:59 <dcoutts> and looks at the current path before installing anything
04:08:20 <dcoutts> we could possibly have an option to say "yes please modify my global path"
04:08:30 <dcoutts> at the moment I modify the user's path
04:08:39 <dcoutts> but that comes after the global path
04:08:53 <dcoutts> so the installer checks the global path for clashes
04:09:20 <dcoutts> also prepending to the global path is evil, since it should start with the windows and system dirs
04:09:37 <dcoutts> and appending to the global path is no different to prepending to the user's path
04:10:12 <dcoutts> so it'd have to do something cunning and insert itself somehwere in the middle of the path, after windows but before the one that causes problems
04:10:45 <kolmodin> dcoutts: will the ebuild be updated too?. .. :D
04:10:56 <dcoutts> kolmodin, oh yeah, good point :-)
04:11:00 * dcoutts does that
04:13:57 <roconnor> 10^16 GeV/c^2
04:14:04 <roconnor> @google 10^16 GeV/c^2 in milligrams
04:14:05 <lambdabot> ((10^16) GeV) / (c^2) = 1.78266173 x 10^-5 milligrams
04:21:22 <Saizan> dcoutts: yeah, but you could leave an option like "install this anyway i'll adjust my %Path% manually later"
04:21:46 <dcoutts> Saizan, yeah, could do.
04:21:57 <dcoutts> Saizan, I'll see how much works that is :-)
04:22:08 <Saizan> heh :)
04:22:54 * Saizan moves ruby\bin into the user path
04:25:10 <hpaste>  csci pasted "Syntax question: extending show on self-referencing data-types" at http://hpaste.org/74
04:25:33 <csci> ^^ (Hopefully trivial)
04:25:59 <csci> Whoever said, Haskell syntax is quite easy, well, he was either damn good or damn stupid ;-)
04:27:04 <Igloo> csci: I'm not sure what you want to do
04:27:41 <hpaste>  matthew-_ annotated "Syntax question: extending show on self-referencing data-types" with "something like this" at http://hpaste.org/74#1
04:27:43 <csci> Igloo: I have a datatype which I wanted to extend to be able to be "show"n, si I have to make it an instance of Show, right?
04:27:51 <Igloo> Right
04:28:03 <Igloo> Do you just want to ignore the second argument of Item?
04:28:30 <csci> No
04:28:51 <matthew_-> csci: does that annotated version work for you?
04:29:14 <csci> I've to admit no :-(
04:29:27 <hpaste>  ToRA annotated "Syntax question: extending show on self-referencing data-types" with "or this..." at http://hpaste.org/74#2
04:29:28 <matthew_-> mmm. maybe I should have tried it first ;)
04:29:38 <hpaste>  csci annotated "Syntax question: extending show on self-referencing data-types" with "error message " at http://hpaste.org/74#3
04:30:28 <matthew_-> oh yeah, ToRA's version has the missing bits ;)
04:31:31 <matthew_-> yes, MenuTree on it's own is a type constructor, so it needs to be applied to a type ('a' in this case) in order to be a type, hence that error you were getting
04:31:31 <hpaste>  csci annotated "Syntax question: extending show on self-referencing data-types" with "error message  on ToRA's" at http://hpaste.org/74#4
04:31:46 <csci> (I begin to dislike Haskell's type system ;-))
04:35:37 <roconnor> what is the type of pri?
04:36:46 <csci> give me a second
04:37:06 <hpaste>  csci annotated "Syntax question: extending show on self-referencing data-types" with "for convienience: the whole code" at http://hpaste.org/74#5
04:37:11 <hpaste>  ToRA|home annotated "Syntax question: extending show on self-referencing data-types" with "a variation" at http://hpaste.org/74#6
04:37:20 * roconnor thinks csci just dislikes ghc's error messages
04:37:51 <csci> roconnor: Just a bit. Sometimes it shows a linenumber far far away from the error ;-)
04:38:02 <roconnor> indeed
04:38:26 <matthew_-> it's just a big tease really ;)
04:38:31 <Igloo> pri takes a String but you are trying to give it an a
04:39:00 <csci> well, actually pri does not take a string
04:39:06 <csci> (I hope at least it doesnt)
04:39:08 <Igloo> Sorry, I mean indent does
04:39:08 <roconnor> pri takes a MenuTree String and you give it an a
04:39:15 <Igloo> So pri takes a MenuTree String
04:39:41 <roconnor> so rather than complining, haskell tries to unify a with MenuTree String, but doesn't get very far
04:39:48 <matthew_-> yes, so make pri :: (Show a) -> a -> Int -> String
04:39:59 <matthew_-> or rather
04:40:07 <matthew_-> yes, so make pri :: (Show a) -> MenuTree a -> Int -> String
04:40:11 <roconnor> however, I suspect your error is by passing an a into a function wanting MenuTree String
04:40:38 <roconnor> (Show a) => MenuTree a -> Int -> String actuall ;)
04:40:38 <roconnor> actually
04:40:52 <csci> ok, I have enough hints now to solve this. Thanks to all. Never been in such a nice channel :)
04:41:18 <matthew_-> roconnor: agh yes. bother bother bother ;)
04:41:20 <roconnor> csci: one helpful tip is to write type signatures for all (or almost all) your top level functions.
04:41:29 <mux> yeah, #haskell defies the IRC laws
04:42:02 <roconnor> this helps both documentation, and helps the type checker pinpoint errors closer to where the error actually occurs.
04:42:07 <csci> roconnor: I know I should, but it's sometimes really difficult, so normally I check using :t in ghci
04:42:31 <roconnor> csci: often I write a function, use GHC to find it's type, and then write down the result ;)
04:42:31 <matthew_-> once you do that however, put the sigs that ghci tells you back into your code
04:42:51 <Igloo> csci: FWIW, times " " n == replicate n ' '
04:42:52 <matthew_-> at least it puts more information in the code itself which is helpful to readers
04:42:55 <csci> ah yes, good idea. Did not knew that ghci uses this, I thought it's jsut for documentation
04:42:57 <Saizan> there's a script for vim that do it automagically
04:43:06 <Saizan> *does
04:43:17 <csci> Igloo: oh thanks
04:43:30 <roconnor> csci: well, if you write down the type directly that GHC gives, it actually won't help tracking down errors.
04:43:44 <roconnor> but it will help the humans still. ;)
04:43:59 <csci> roconnor: ...because those types given are too general?
04:44:07 <Igloo> csci: And foldr (++) "" == concat, and concat (map f xs) = concatMap f xs
04:44:24 <roconnor> GHC give the most general type yes.  So it is the same type that the type checker is using.
04:44:41 <csci> Which I can improve by providing more detailed types, I see.
04:44:43 <roconnor> So adding the type won't change the error message to be more helpful.
04:44:55 <csci> Oh :)
04:44:59 <roconnor> yes, if you give a more specific type, then the type checker and return better results.
04:45:11 <roconnor> er, can return better results.
04:45:23 <csci> ok, thanks for this info
04:45:24 * roconnor sucks a typing on a keyboard.
04:45:43 <roconnor> I should say ``return better error messages
04:45:56 <csci> atm that's quite the same for me ;-)
04:57:50 <Syzygy-> Hey roconnor
04:57:57 <roconnor> hey
04:58:05 * Syzygy- needs to generate four 100-bit random primes, preferably SOON.
04:58:17 <roconnor> that doesn't sound so hard
04:58:27 <Syzygy-> No, but I have teh stooopid today.
04:58:50 <vincenz> Syzygy-: keep generating numbers until you find a prime
04:58:58 <Syzygy-> I have Pari/GP - so if I get two numbers in the right area, I can get the next prime.
04:59:03 <Syzygy-> Which is good enough.
04:59:05 <roconnor> 1267650600228229401496703205653
04:59:10 <Syzygy-> So I want two danrom 100-bit primes.
04:59:13 <roconnor> 1267650600228229401496703205707
04:59:20 <roconnor> 1267650600228229401496703205823
04:59:23 <Syzygy-> roconnor: I think that's the second and third after 2^100.
04:59:27 <roconnor> 1267650600228229401496703205901
04:59:29 <roconnor> ;)
04:59:35 <roconnor> I got lucky
04:59:40 <Syzygy-> :P
04:59:52 <roconnor> that the thing about random numbers, you never can tell
05:00:21 <vincenz> Well you can use a few quick rules (forgot them sadly) to generate numbers that are more likely to be prime
05:01:02 <psykotic> like forcing the least significant bit to 1? that increases the odds by 50% :)
05:01:03 <notsmack> can i use guards in a ghci let?
05:01:32 <vincenz> http://citeseer.ist.psu.edu/silverman97fast.html
05:01:33 <lambdabot> Title: Fast Generation Of Random, Strong RSA Primes - Silverman (ResearchIndex)
05:01:48 <vincenz> psykotic: no like using 2^n-1, there are a few others like that
05:01:57 <Syzygy-> Hah! let newNum = getStdRandom (randomR (2^100,2^101))
05:02:10 <vincenz> Syzygy-: that won't be prime perse
05:02:11 <psykotic> vincenz, yeah, i was joking. but people actually do use the force-lsb-to-1 thing too :)
05:02:22 <Syzygy-> roconnor: Well, yeah, but this has a pedagogical application, so that's not necessarily a good criterion.
05:02:27 <Syzygy-> psykotic: Of course they do.
05:02:28 <vincenz> psykotic: of course, all quick rules that significantly reduce the search space are good ideas
05:02:38 <Syzygy-> vincenz: No, but nextprime(blah) in GP gives me a prime. :P
05:02:49 <vincenz> GP?
05:02:52 <roconnor> I was using nextprime in Maple.
05:05:04 <bakert> ?help
05:05:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:05:11 <bakert> ?help point
05:05:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:05:35 <bakert> ?help list
05:05:35 <lambdabot> list [module|command]
05:05:35 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:05:59 <bakert> ?pl main = print $ map renderHtml $ map reportToHtml $ map getReport bookies
05:05:59 <lambdabot> main = print (map renderHtml (map reportToHtml (map getReport bookies)))
05:06:23 <bakert> ?pointful main = print $ map renderHtml $ map reportToHtml $ map getReport bookies
05:06:24 <lambdabot> main = print (map renderHtml) (map reportToHtml) (map getReport bookies)
05:06:50 <bakert> hmm ... not a case for pointfree style there then.  back to the thinking board.
05:08:01 <roconnor> the result from pointful doesn't seem right
05:09:07 <roconnor> the pointful and pointless results should be the same because main doesn't have any arguments.
05:09:48 <SamB> what, Self 4.3 runs on Intel macs?
05:17:59 <bakert> ?pl x y = map oneThing $ map twoThing $ map threeThing y
05:17:59 <lambdabot> x = map (oneThing . twoThing . threeThing)
05:18:03 <bakert> aha!
05:18:05 <bakert> thanks roconnor !
05:19:03 <bakert> i thought there was something in that!
05:22:48 <Masklinn> hello haskell
05:29:37 <dcoutts> Igloo, good post about IsString
05:30:29 <Igloo> Thanks  :-)
05:34:25 <robreim> dcoutts: you're a C hacker, yeah? Any idea what could cause "couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference" with respect to hs-plugins?
05:34:43 <dcoutts> hmm
05:35:07 <dcoutts> no idea, sorry
05:35:12 <dcoutts> ndm!
05:35:16 <Igloo> robreim: Is that on the same machine you compiled on?
05:35:24 <robreim> Igloo: yeah
05:35:33 <ndm> dcoutts!
05:35:38 <dcoutts> ndm, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
05:35:45 * Igloo has no idea either then
05:35:52 <dcoutts> ndm, I think I've fixed all the things you reported, even the size calculation
05:36:05 <robreim> thanks anyway :)
05:36:30 <dcoutts> ndm, oh, actually the thing about ghc-6.4.2 complaining about multiple versions of the same package is more or less beyond my control.
05:36:37 <robreim> Igloo: actually, what were you going to suggest if it was a different machine?
05:36:47 <ndm> @karma+ dcoutts -- although will be undone if the install fails
05:36:48 <lambdabot> dcoutts's karma raised to 39.
05:36:48 <dcoutts> ndm, though as you say, I could include some release notes.
05:36:54 <dcoutts> hah hah
05:36:59 <ndm> dcoutts, just tell people to clean before building
05:37:06 <ndm> does GHC have --clean?
05:37:28 <dcoutts> ndm, no isn't it just a matter of unregistering the older version?
05:37:49 <ndm> dcoutts, turned out that doesn't matter, it was because i had old .o files hanging around, which grabbed the old version automatically
05:37:50 <Igloo> robreim: Nothing really, unless it was statically with libc. I was just wondering.
05:37:53 <dcoutts> ndm, or you mean partly rebuilding existing projects which still reference the old version?
05:38:00 <dcoutts> right, yeah
05:38:18 <ndm> dcoutts, yes, in a way (in my case it was more copmlex, since it was in a separate project i was -i  'ing in)
05:38:25 <Igloo> GHC doesn't have --clean, no
05:38:34 <Igloo> although cabal does
05:38:40 <robreim> ok
05:39:26 <dcoutts> Igloo, it'd be really helpful if when ghc notices that some .hi files reference a package that no longer exists if it could give a better error message, and suggest that things need rebuilding against the current version or something
05:39:41 <pejo> robreim, are you using some test version of your linux distribution?
05:40:06 <dcoutts> Igloo, currently it just says that it can't find a package that isn't even installed or mentioned anywhere by the user (it's in the .hi files of course but the user doesn't know that)
05:40:12 <robreim> pejo: no, this is my primary workstation. It's the first time I've encountered the error.
05:40:16 <ndm> dcoutts, i just installed and it looks really ugly - its using the GNOME theme, not the windows one
05:40:27 <dcoutts> ndm, what's the default?
05:40:38 <robreim> I'm wondering if something in the way hs-plugins loads libraries could have anything to do with such an error.
05:40:38 <dcoutts> hmm
05:40:48 <ndm> dcoutts, GNOME theme, i used to havethe windows one, not sure if that was the default or i changed it
05:41:00 <dcoutts> ndm, ok, I'll look into it
05:41:26 <pejo> robreim, ok, apparently fedora-test had similar problems with libc. Some googling suggests running ldconfig might solve it.
05:41:38 <ndm> dcoutts, does the theme changer come with your custom Gtk2Hs?
05:41:51 <Syzygy-> Is there a neat way to convince Haskell to take a hexadecimal string and give me the corresponding Integer?
05:41:52 <robreim> pejo: tah. I'll try that I guess.
05:41:53 <dcoutts> ndm, no
05:42:00 <Syzygy-> The inverse operation, I do with Text.Printf just fine.
05:42:04 <dcoutts> ndm, my intention was for it to always use the right theme
05:42:23 <ndm> dcoutts, that would be fine - but it doesn't currently, i have the GNOME theme
05:42:28 <dcoutts> yeah
05:43:13 <ndm> dcoutts, other than that niggle, perfect from begining to end, when deleting the .o's first
05:43:25 <dcoutts> great
05:43:37 * dcoutts tries to figure out how the gtk theme is set
05:43:56 <allbery_b> ~/.gtkrc?
05:44:07 <robreim> pejo: no joy. Thanks for the suggestion though.
05:45:28 <allbery_b> Syzygy-: read '0':'x':hexstr :: Int -- ?
05:47:33 <Igloo> Numeric.readHex / Numeric.showHex
05:53:03 <dcoutts> ndm, can you check something for me, add a file in Gtk2Hs/etc/gtk-2.0/gtk.rc containing the single line: gtk-theme-name = "MS-Windows"
05:54:40 <dcoutts> ndm, oops it should be gtkrc not gtk.rc
05:54:44 <ndm> dcoutts, did that, reran, no luck
05:55:01 <ndm> dcoutts, changing the name makes it work just fine
05:55:04 <ndm> dcoutts - that is the fix
05:55:19 <dcoutts> ndm, ok, great, that'll be easy to add to the installer...
05:58:28 <bakert> ?where Text.XHtml
05:58:28 <lambdabot> I know nothing about text.xhtml.
05:58:34 <bakert> ?where XHtml
05:58:34 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
06:03:28 <mwc> what's cool that's happened in haskell while my Hd was crashed?
06:03:51 <Botje> lambdabot took over.
06:04:30 <chessguy> @yarr
06:04:30 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
06:04:53 <mwc> oh. good. lambdaskynet
06:07:48 <bakert> Stoopid question.  If I have a list of strings and I want to print them in main, what can I do?  It doesn't like map because then I'm kind of returing a list of something.
06:08:00 <roconnor> thanks to haskell, humankind is one step closer to annihilation by AI.
06:08:04 <allbery_b> mapM_ ?
06:08:08 <bakert> I know I can "print list" but then I get the escaped newlines and so on.
06:08:14 <bakert> allbery_b, i'll look into it thanks.
06:09:14 <mwc> roconnor I prefer the term singularity
06:09:18 <allbery_b> :t mapM_
06:09:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
06:09:49 <roconnor> :t mapM_ putStrLn
06:09:50 <lambdabot> [String] -> IO ()
06:09:58 <bakert> allbery_b, wicked that's it.  plus i need putStr not print.  but yes that is gooood.  thanks!
06:11:50 <Anon4888> Is the k in haskell silent?
06:12:23 <roconnor> nope
06:12:41 <chessguy> Anon4888, no, 'haskell' sounds a lot like pascal, which causes much confusion among the common people
06:13:07 <mwc> no, but i  like to make one of The l's silent. guess which?
06:13:08 <resiak> If the K were silent, bad jokes could be made involving David Hasselhoff.
06:13:20 <pejo> mwc, "Haskell without the Hell"?
06:13:26 <Anon4888> Actually I was making a bad joke :)
06:14:01 <roconnor> Anon4888: awww, Haskell isn't a hassle :)
06:14:34 <roconnor> @karma+ haskell
06:14:35 <lambdabot> haskell's karma raised to 20.
06:14:40 <Anon4888> hehe
06:14:44 <allbery_b> try to bring wisdom to the people, they only see a hassle. :/
06:15:17 <allbery_b> (unfortunately you need to know Hebrew to get that one, oh well)
06:15:57 <roconnor> @google "try to bring wisdom to the people"
06:15:59 <lambdabot> No Result Found.
06:16:12 <mwc> damn your Zionist puns!
06:16:27 <mwc> ;)
06:17:24 <Saizan> something related to da'at?
06:17:50 <allbery_b> "haskeil" = wisdom
06:18:16 <allbery_b> ()
06:18:50 <matthew_-> ...and suddenly it's all clear ;)
06:18:55 <mwc> Awesome. I'll take that as evidence that God has settled the great language debate
06:19:08 <allbery_b> or 
06:19:20 <shapr> whoa
06:19:22 <shapr> cool
06:19:47 <allbery_b> somewhat amusingly "curry" also translates directly ( - call / cry)
06:21:06 <roconnor> cool, Konversation can handle RTL language IRC chanels.
06:21:25 <allbery_b> but "wisdom of a call" doesn't quite work; it'd be nicer if the names were reversed "call of wisdom"
06:21:31 <roconnor> allbery_b's name and time is on the right hand side of the window
06:22:34 <roconnor> is it time for #haskell-he ?
06:23:08 <allbery_b> I have enough trouble with math / CS terms in English :)
06:23:17 <roconnor> ;)
06:26:17 <bakert> allbery_b, you can definitely dispute the wisdom of a call in poker.
06:26:38 <allbery_b> sure, but I'd rather not have to disupte it in Haskell
06:26:43 <vincenz> or when stalking and using the phone
06:26:52 <allbery_b> ...and also rather not think of Haskell as poker :)
06:27:31 <bakert> it's exactly like poker.  show weakness and the compiler takes advantage and spits out an incomprehensible error message.  forge ahead positively and it compiles!
06:27:42 <vincenz> @quote urk
06:27:43 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
06:27:47 <vincenz> @quote Urk
06:27:47 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
06:27:56 <bakert> unless the compiler is slowplaying ...
06:28:00 <allbery_b> in my experience, forge ahead positively and get type errors all over the place :)
06:28:51 <vincenz> cjeris: you 1st year by any chance?
06:29:56 <sris> is it possible to execute a haskell-program from the terminal without compiling it or actually "starting" ghci
06:30:06 <ndm> sris: runhaskell
06:30:21 <Lemmih> ghc -e
06:30:26 <sris> nice, thanks ;)
06:30:27 <bakert> sris, you can put a shebang in the top of the file and make it executable (unix)
06:30:38 <wilx|wrk> runghc
06:31:00 <bakert> sris, using runhaskell or runghc ... i think runhaskell is more portable (???)
06:31:20 <allbery_b> Saizan: "dei'ah, binah v'haskeil" --- knowledge, understanding, and wisdom (dei'ah having the same root as da'at)
06:31:29 <allbery_b> ghc and hugs both provide runhaskell
06:31:42 <vincenz> cjeris: ??
06:33:20 <Saizan> allbery_b: so i picked the wrong sephira :)
06:34:33 <Syzygy-> Can I get lambda to show me the implementation of Read for Integer?
06:34:57 <allbery_b> ?src Integer read
06:34:58 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:35:02 <allbery_b> apparently not
06:35:06 <Syzygy-> Awwwww.
06:35:12 <Syzygy-> ?src read Integer
06:35:13 <lambdabot> Source not found. Are you on drugs?
06:35:19 <Syzygy-> No. Not that way around either...
06:35:30 <allbery_b> ?src Maybe (>>=)
06:35:30 <lambdabot> (Just x) >>= k      = k x
06:35:31 <lambdabot> Nothing  >>= _      = Nothing
06:35:41 <Syzygy-> ?src read
06:35:41 <lambdabot> read s = either error id (readEither s)
06:35:46 <Syzygy-> Ah. That's why.
06:35:49 <Syzygy-> ?src readEither
06:35:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:35:58 <Syzygy-> ?src Integer readEither
06:35:58 <lambdabot> Source not found. Do you think like you type?
06:36:22 <roconnor> lambdabot has gotten meaner
06:36:30 <roconnor> @karma- lambdabot
06:36:31 <lambdabot> lambdabot's karma lowered to 43.
06:36:49 <Saizan> @karma- lambdabot
06:36:50 <lambdabot> lambdabot's karma lowered to 42.
06:36:55 <vincenz> @google scratch harvard
06:36:57 <lambdabot> http://blogs.law.harvard.edu/cyberone/course-materials/scratch/
06:36:58 <lambdabot> Title: CyberOne: Law in the Court of Public Opinion  Scratch
06:37:02 <vincenz> hmm
06:37:02 <Saizan> just for the number
06:37:11 <roconnor> heh
06:37:43 <allbery_b> "readEither" that's one to remember
06:38:10 <njd> @seen
06:38:34 <njd> @users
06:38:34 <lambdabot> Maximum users seen in #haskell: 322, currently: 312 (96.9%), active: 39 (12.5%)
06:39:06 * vincenz ponders
06:39:12 <vincenz> imagine integrating lambdabot into irssi
06:39:16 <vincenz> cause I just tried to @google in a pm
06:39:22 <vincenz> (not with lambdabot)
06:39:46 <allbery_b> goa could probablybe hacked into something that would work :)
06:40:01 <vincenz> @google goa irc
06:40:07 <lambdabot> http://irc.netsplit.de/channels/details.php?chan=%23goa&net=ChillNet
06:40:07 <lambdabot> Title: Chat room #goa - irc.netsplit.de
06:40:23 <vincenz> ?
06:41:27 <allbery_b> @where goa
06:41:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
06:41:51 <allbery_b> it's actually an interface to ghci, but given that I imagine hooking it to something else wouldn't be to hard
06:43:04 <allbery_b> (I hear it';s also broken at the moment though; hac07 may have been too much for it, like it was for vixen)
06:51:06 <Saizan> we need an haskell ircclient on top of lambdabot
06:51:43 <Jaak> if we had one it better be able to beat irssi
06:52:12 <chessguy> you mean something curses-based?
06:52:38 <allbery_b> there's hircules but it's gtk2hs
06:52:56 <Saizan> ?where hircules
06:52:57 <lambdabot> I know nothing about hircules.
06:53:04 <dcoutts> there are several gtk2hs irc clients
06:53:04 <allbery_b> (and hey, the IRC support was gacked from lambdabot :)
06:53:10 <dcoutts> of varying sophistication
06:54:23 <Saizan> dcoutts, i've put a gtkrc with  gtk-theme-name = "MS-Windows" in etc, how do i return to the default theme? deleting it doesn't seem to work
06:54:24 <Jaak> scripting support is a must. :P
06:54:32 <shapr> Saizan: I think we should merge lambdabot and yi
06:54:51 <Nafai> Morning shapr
06:55:00 <shapr> good morning #haskell and Nafai !
06:55:04 <shapr> Nafai: How's that code going?
06:55:13 <dcoutts> Saizan, in etc/gtk-2.0/gtkrc, deleting that and re-running whatever prog should change it back to the default
06:55:15 <Saizan> shapr: true, but an irc client in my editor is too distracting :D
06:55:18 <shapr> allbery_b: Did vixen not survive hac07?
06:55:25 <allbery_b> @vixen
06:55:25 <lambdabot> <undefined>
06:55:38 <shapr> Saizan: That's how I've been using #haskell for more than five years!
06:55:41 <allbery_b> casualty of the changes to binary and to lbot's new regex code
06:55:43 <dcoutts> Saizan, but why would you not want to use the Windows theme on Windows? I wasn't planning on giving people the choice! :-)
06:55:44 <shapr> aww
06:56:02 <Igloo> dcoutts: Is there a reason some lines of fps:tests/Makefile use -O and others -O2?
06:56:13 <Nafai> shapr: Oh, not bad.  I decided to step back and read some more docs because I needed to re-learn some basics
06:56:15 <dcoutts> Igloo, not especially
06:56:42 <dcoutts> Igloo, I think everything should be fine with -O, I don't think -O2 makes it better irrc
06:57:04 <Igloo> dcoutts: Any reason not to always use -O2?
06:57:47 <Igloo> Oh, one of them turns the rules off. Hmm.
06:57:58 <dcoutts> Igloo, any reason to always use -O2 ?
06:58:09 <dcoutts> Igloo, yes, it's important to test with and without the rules
06:58:45 <Igloo> Well, I guess at worst it'll just do some redundant recompilation
06:59:49 <Igloo> Ah, and in fact it's forcing recompilation anyway. Oh well, I'll just live with that
07:00:24 <Saizan> dcoutts: mmh it seems i was wrong on which theme i was using.. i still get gnome icons however
07:00:44 <dcoutts> Saizan, yeah, dunno about the icons
07:00:57 <dcoutts> though they should be specified by the theme...
07:02:15 <huschi> read only fails if the input is not valid. is there any better reason that tells me about the error?
07:02:46 <Igloo> huschi: reads will give you the empty list rather than an exception, but not a reason
07:03:01 <huschi> Igloo: that's enough. thx.
07:03:13 <Syzygy-> Anyone care to give me a oneliner for euclidean algorithm / modular inversion?
07:03:21 <Syzygy-> Please?
07:06:56 <Igloo> dcoutts: Is the on-commit testsuite meant to succeed even though I get "lines \n                 : Falsifiable after 0 tests:"?
07:07:22 <dcoutts> Igloo, that might be the issue with lines we discovered recently
07:07:31 <dcoutts> ask dons for details
07:07:48 <dcoutts> we may have just fixed the instance to trigger it reliably and not fixed it yet
07:08:06 <Igloo> dcoutts: I'm not talking about the test failing, but about the commit being accepted
07:08:08 <dcoutts> Igloo, you're looking at the fps in base or the fps with the new fusion system?
07:08:27 <Igloo> http://www.cse.unsw.edu.au/~dons/code/fps/
07:08:27 <lambdabot> Title: Index of /~dons/code/fps
07:08:44 <dcoutts> Igloo, oh, right. No. If the tests fail then you can't record. Use --no-test or whatever darcs flag it is.
07:08:56 <dcoutts> ah ok, that's the version that's in base.
07:09:13 <Igloo> dcoutts: No, the test failed and I can record
07:09:19 <dcoutts> oh, hmm
07:09:25 <dcoutts> that's not supposed to happen
07:09:43 <shapr> Nafai: Are you enjoying it so far? Any suggestions for newbie improvement?
07:10:13 * Igloo is very dubious about this anyway. It's going to test the installed library, not the one I'm recording into
07:11:05 <bakert> ?hoogle liftIO
07:11:06 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
07:11:48 <bakert> ?src liftIO
07:11:48 <lambdabot> Source not found. Wrong!  You cheating scum!
07:12:05 <bd_> it's a class function :)
07:12:08 <bd_> ?src StateT liftIO
07:12:09 <lambdabot> Source not found. It can only be attributed to human error.
07:12:14 <bd_> :(
07:12:38 <bakert> I don't understand how my other code is using it ... I don't import Control.Monad.Trans.  Curious.
07:13:15 <bakert> there must be a version of it in Network.NewCGI in some way.
07:13:18 <bakert> ?!
07:13:18 <lambdabot> Maybe you meant: . v
07:13:50 <Saizan> it's used to perform an IO when you are in a monad around it
07:13:58 <Saizan> +an IO action
07:14:39 <bakert> I think actually I just don't need the liftIO.  I am copying code from a more complex example where IO, CGI and Either are interacting.  In this case I just have IO and Either.  I will try without.
07:15:48 <bakert> Yeah that seems to have done the trick.  Thanks Saizan, bd_
07:19:25 <syntaxfree> I don't get the reader monad to this day.
07:19:33 <syntaxfree> I came to IRC just to check one pl out.
07:19:38 <syntaxfree> @pl h x = f (g x) x
07:19:38 <lambdabot> h = f =<< g
07:19:45 <syntaxfree> what the hell is that?
07:20:10 <vincenz> readermonad : ((->) a)
07:20:13 <vincenz> or sugared:
07:20:15 <vincenz> a ->
07:20:32 <vincenz> g :: m b : a -> b
07:20:51 <vincenz> f :: b -> m c ::: b -> a -> c
07:21:07 <syntaxfree> what are the monad operations on that?
07:21:33 <Igloo> dcoutts: Do you have any unit tests rather than random-data tests?
07:21:42 <dcoutts> Igloo, no
07:22:32 <Botje> ..
07:22:33 <syntaxfree> gah. It's odd to see (a ->) as a monad.
07:23:22 <syntaxfree> > do { x<-g; f x} where {g = (+1); f=(+1);}
07:23:22 <lambdabot>  Parse error
07:23:54 <syntaxfree> > let {g = (+1); f=(+1);} in do { x<-g; return (f x)}
07:23:55 <lambdabot>  Add a type signature
07:25:07 <vincenz> f should take two args
07:25:23 <syntaxfree> hmm. true.
07:25:29 <syntaxfree> > let {g = (+1); f=(+);} in do { x<-g; return (f x)}
07:25:30 <lambdabot>  Add a type signature
07:25:32 <vincenz> > let { g = (+1); f = (+)} in do { v <- g; f v}
07:25:33 <lambdabot>  Add a type signature
07:25:40 <vincenz> > let { g = (+1); f = (+)} in do { v <- g; f v} :: (Int -> Int)
07:25:41 <lambdabot>  <Int -> Int>
07:25:52 <vincenz> > let { g = (+1); f = (+)} in (do { v <- g; f v}) 2
07:25:54 <lambdabot>  5
07:26:29 <vincenz> g >>= f = do {v <- g; f v}
07:26:38 <vincenz> @do g >>= f
07:26:38 <lambdabot> g >>= f not available
07:26:42 <vincenz> @undo g >>= f
07:26:43 <lambdabot> g >>= f
07:26:52 <vincenz> @undo {v <- g; f v}
07:26:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
07:26:57 <vincenz> @undo do {v <- g; f v}
07:26:58 <lambdabot> g >>= \ v -> f v
07:27:10 <vincenz> @. @pl @undo do {v <- g; f v}
07:27:11 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "@pl"
07:27:17 <vincenz> @. pl undo do {v <- g; f v}
07:27:18 <lambdabot> f =<< g
07:27:34 <resiak> why does @pl prefer =<< to >>=?!
07:27:42 <syntaxfree> No instance for (Monad ((->) String))
07:27:50 <Saizan> > map (*) [1..4] `sequence` 10
07:27:50 <syntaxfree> in this case =<< is more intuitive.
07:27:51 <lambdabot>  [10,20,30,40]
07:27:55 <emu> A]\
07:28:06 <shapr> A]!
07:28:06 <vincenz> Saizan: list monad
07:28:15 <beelsebob> @index unsafePerformIO
07:28:16 <lambdabot> System.IO.Unsafe, Foreign
07:28:19 <resiak> syntaxfree: I really don't see how...
07:28:30 <syntaxfree> why isn't ((->) String) an instance of Monad?
07:28:51 <vincenz> ((->) a) is
07:28:51 <bd_> syntaxfree: it is, you need Control.Monad.Reader imported for it though
07:28:51 <Saizan> ?type (map (*) [1..4] `sequence` )
07:28:53 <lambdabot> forall a. (Num a, Enum a) => a -> [a]
07:28:56 <syntaxfree> oh.
07:29:07 <Saizan> vincenz: it doesn't seem so
07:29:14 <vincenz> Saizan: yes, it returns a list...
07:29:18 <vincenz> a -> m a
07:29:19 <vincenz> m = []
07:29:31 <Saizan> ?type sequence
07:29:33 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:29:38 <vincenz> oh
07:29:40 <vincenz> hm
07:29:46 <bd_> syntaxfree: it really should be in Control.Monad or maybe the prelude though :)
07:29:55 <vincenz> Saizan: ok :)
07:30:02 <Saizan> :)
07:30:14 <syntaxfree> f =<< g looks just so pretty I'm thinking it *should* be intuitive and my mind's not good enough for it.
07:30:18 <Saizan> there's Control.Monad.Instances
07:30:45 <syntaxfree> I'd like to see the source for the Reader monad instance.
07:31:02 <emu> easy enough!
07:31:16 <bd_> syntaxfree: instance Monad ((->) a) where return = const; m >>= f = \a -> f (m a) a ?
07:31:17 <emu> doesn't All About Monads have sample implementations?
07:31:20 <syntaxfree> (btw, (->) is allowed as a data constructor as an syntactic exception, right?)
07:31:31 <bd_> type constructor
07:31:34 <bd_> I think?
07:31:45 <syntaxfree> bd_ : oh true. trivial.
07:31:52 <emu> yea data constructor would be Just
07:31:59 <emu> like*
07:32:17 <syntaxfree> type constructor, yes.
07:32:20 <bd_> or even: return = const; join f a = f a a; fmap f g = f . g :)
07:32:38 <syntaxfree> I prefer join definitions these days.
07:32:53 <syntaxfree> They look more primitive.
07:32:54 * cjeris wants hs2commutativediagram
07:33:05 <vincenz> dataconses start with : or Capitals
07:33:08 <syntaxfree> @free join
07:33:10 <lambdabot> Expected variable or '.'
07:33:14 <syntaxfree> vincenz: I know!
07:33:17 <shapr> cjeris: What would that do?
07:33:22 <syntaxfree> @free (>>=)
07:33:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
07:33:38 <syntaxfree> I love how @free throws assorted errors when it can't construct a theorem.
07:33:49 <vincenz> syntaxfree: just clarifying
07:33:54 <Botje> @free (+)
07:33:54 <bakert> ?hoogle stderr
07:33:54 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
07:33:55 <lambdabot> IO.stderr :: Handle
07:34:01 <syntaxfree> vincenz: thanks for the clarification, then :)
07:34:33 <bakert> is IO imported automatically?
07:35:01 <bd_> bakert: no, but certain specific actions are in the Prelude
07:35:12 <bd_> eg, putStrLn
07:35:20 <bakert> bd_, I'm just trying to work out how to putStrLn to stderr
07:35:33 <bd_> import System.IO and hPutStrLn stderr
07:35:42 <bd_> :)
07:35:46 <bakert> ahhhh ... _System_.IO
07:35:50 <bakert> thanks!
07:35:51 <bd_> yeah
07:35:56 <bd_> the one-word modules are deprecated :)
07:36:08 <bakert> (in page search for IO getting me nowhere ... should have tried case sensitive I suppose)
07:36:12 <bakert> thanks bd_
07:36:58 <bd_> @hoogle hPutStrLn
07:36:59 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
07:40:57 <beelsebob> win! LappyBob:~/Desktop/BF tatd2$ ./BF -m bf hello_world.b
07:40:57 <beelsebob> Hello World!
07:41:06 <beelsebob> working brainfuck and ook interpretter in Haskell
07:41:30 <vincenz> @bg ,a
07:41:30 <lambdabot> Maybe you meant: bf bug
07:41:32 <vincenz> @bf ,a
07:41:33 <lambdabot> Done.
07:41:35 <vincenz> @bf a,
07:41:36 <lambdabot> Done.
07:41:38 <vincenz> @bf a.
07:41:39 <lambdabot> Done.
07:41:42 <vincenz> hmm
07:44:49 <beelsebob> ookk?
07:46:11 <Jaak> @bf +++++++[->+++++++++<]>++>>+++++[-<+++++>]<+[-<.+>]
07:46:11 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZ
07:46:19 <beelsebob> bastards!
07:47:18 <shapr> ookk: Have you seen http://www.dangermouse.net/esoteric/ook.html ?
07:47:19 <lambdabot> Title: DM's Esoteric Programming Languages - Ook!
07:47:46 <vincenz> isomorphic langauges are boring
07:47:54 <shapr> Oh, I had an idea in the shower.
07:47:54 <ookk> shapr, nope
07:48:07 <shapr> What about writing a language that has ALL the scary bits?
07:48:21 <vincenz> you mean brainfuck on monads and arrows?
07:48:23 <shapr> For example, extreme laziness, mutation, an all that.
07:48:30 <vincenz> check k
07:48:37 <vincenz> @google k programming language
07:48:39 <lambdabot> http://en.wikipedia.org/wiki/K_programming_language
07:48:40 <bd_> Haskell plus implicit typecasting from IO a -> a ? :)
07:49:38 <vincenz> this is the right link http://www.cwi.nl/~tromp/cl/lazy-k.html
07:49:49 <vincenz> lazy ski
07:53:18 <Botje> I hereby christen (($).($).($)) the "capitalism operator"
07:53:38 <Saizan> ?type (($).($).($))
07:53:39 <lambdabot> forall a b. (a -> b) -> a -> b
07:54:54 <vincenz> @foldr1 (.) $ replicate 4 ($)
07:54:58 <lambdabot> No match for "(.)".
07:54:59 <lambdabot> No match for "$".
07:54:59 <lambdabot> No match for "replicate".
07:54:59 <lambdabot> No match for "4".
07:54:59 <lambdabot> No match for "($)".
07:55:00 <vincenz> @type foldr1 (.) $ replicate 4 ($)
07:55:02 <lambdabot> forall a b. (a -> b) -> a -> b
07:55:08 <vincenz> @type foldr1 (.) $ repeat ($)
07:55:10 <lambdabot> forall a b. (a -> b) -> a -> b
07:55:36 <vincenz> @type foldr (.) ($) $ repeat ($)
07:55:38 <lambdabot> forall b a. (a -> b) -> a -> b
07:55:59 <Botje> heheh :)
07:56:12 <vincenz> that's true capitalism
07:56:24 <vincenz> it essentially does nothing but takes an infinite amount of time to get done, no wait, that's bureaucracy
07:56:46 <vincenz> infinite amount of money ($), infinite amount of processing time, and all you get is `id`
07:57:33 <Botje> :)
08:00:00 <ndm> @seen lambdabot
08:00:00 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
08:00:46 <therp> vincenz: ;)
08:07:34 <dcoutts> liyang, ping
08:08:06 <liyang> *pong*
08:10:34 <liyang> new Gtk2Hs? I'm on it.
08:10:44 <dcoutts> ok, cool :-)
08:11:10 <dcoutts> liyang, btw, I was thinking of trying to make the new svgcairo package use librsvg rather than libsvg-cairo
08:11:19 <liyang> yes please.
08:11:19 <malebria> liyang: let me know when you got the package done, I'll test it.
08:11:20 <dcoutts> since nobody uses libsvg-cairo any more
08:11:37 <dcoutts> liyang, I've not done anything to make splitting packages easier btw,
08:11:41 <liyang> libsvg-cairo is kind of abandoned... or so its old packager tells me.
08:11:47 <dcoutts> yep
08:12:16 <dcoutts> I haven't seen a clean way of doing the splitting
08:12:18 <shapr> I've just realized that the unix philosophy of small, sharp, composable tools is the same as DSLs. Is that already obvious to everyone?
08:12:34 <dcoutts> liyang, and I hope to move to cabal in the not too distant future
08:12:35 <liyang> dcoutts: not to worry if it's too much effort. The existing setup is easier if anything since I don't have to change my build scripts. :)
08:12:42 <dcoutts> ok :-)
08:12:46 <Botje> shapr: every DSL eventually becomes turing complete.
08:13:16 <liyang> dcoutts: Cabal would make things simpler and less brittle I guess...
08:13:31 <dcoutts> yeah, but making cabal support gtk2hs is not trivial
08:13:36 <shapr> I was just reading the beginning of http://www.pcworld.com/article/id,128636/article.html and those first two paragraphs spell it out.
08:13:38 <lambdabot> Title: PC World - Linux Audio Players, Tested and Graded
08:14:35 <shapr> The reason it's easier to learn to program with a unix flavor is that you interact with the OS via an EDSL.
08:15:13 <shapr> A command shell is just like any other interpreter.
08:15:18 <allbery_b> shapr:  not obvious to everyone but not unknown either
08:15:44 <chessguy> shapr, what do you mean by DSLs?
08:15:51 <shapr> Pointy clicky monolithic solutions that do not interact with each other does not encourage composition.
08:16:41 <shapr> You can compose bits on the command line to do whatever you want, but programs like GarageBand and some other mixer software do not compose in Windows.
08:16:42 <allbery_b> packages of small, composable commands for various tasks are isomorphic with domain spcific languages
08:16:54 <allbery_b> for those tasks
08:17:13 <Nafai> I wish there was a way to "compose" graphical bits
08:17:26 <shapr> I wonder if the monolithic program approach is connected to the monolithic development approach by more than just culture?
08:17:45 <chessguy> well, to some extent, don't graphical libraries "compose graphical bits"?
08:18:13 <allbery_b> nafai: I think plan9 played with that idea in its windowing system to some extent.  (of course the translation to X11 would have lost it)
08:18:19 <shapr> chessguy: If you mean MFC-style, then no. Those are just controls.
08:18:21 <Nafai> bits, I mean distinct pieces of functionality
08:18:26 <liyang> dcoutts: oh, got a quick patch for you http://cs.nott.ac.uk/~lyh/Makefile.am-html_DATA.diff
08:18:43 <chessguy> shapr, i mean libraries like GTK
08:18:50 <allbery_b> also the old AT&T MGR system had some (limited and not very good) experimentation with it
08:18:51 <shapr> No, those are just control.
08:18:52 <dcoutts> lispy, ah that's 'Q' is it?
08:18:56 <shapr> They don't do anything themselves.
08:19:13 <shapr> As Nafai said, 'compose functionality'
08:19:14 <dcoutts> oops sorry lispy, I meant liyang
08:19:23 <chessguy> i'm not sure i see the difference
08:19:30 <dcoutts> liyang, what are all the numbers? 58 60 62 124
08:19:30 <liyang> dcoutts: Q and some symbols. :)
08:19:34 <dcoutts> oh ok
08:19:45 <dcoutts> liyang, ok ta
08:19:47 <Nafai> What I'm talking about is like there is an IE COM component, and maybe a component for a calendar, maybe a component for this or that
08:19:52 <shapr> My girlfriend is mixing music lately on MacOSX and on Win32, and she has to use one program for mixing, another program for filtering, and some other program for editing samples. Why can't those be composed?
08:19:56 <Nafai> And they can be tied together or used in some way
08:20:06 <dcoutts> shapr, see gstreamer :-)
08:20:20 <dcoutts> shapr, actually arrows would be perfect for gstreamer
08:20:20 <shapr> dcoutts: And jack, yeah I agree.
08:20:23 <liyang> dcoutts: I'm wondering why that bit isn't just a wildcard...
08:20:52 <shapr> But the windows development paradigm is 'monolithic standalone program'
08:20:53 <dcoutts> liyang, what would the wildcard be? remember the files don't exist 'til you run haddock
08:20:57 <liyang> no, nevermind. I've figured it out. :-/
08:21:02 <liyang> *nod*
08:21:04 <shapr> chessguy: Is it clear now?
08:21:30 <dcoutts> shapr, there was a nice paper at PADL about using arrows for unix style process graphs
08:21:49 <dcoutts> ie graphs that are a little more complex than just linear pipelines
08:21:50 <allbery_b> shapr: actually, only partly so.  you "compose" DCOM components, ideally.  modern VB / VBA is more or less about doing just that
08:22:07 <dcoutts> shapr, except typed :-)
08:22:13 <chessguy> shapr, not really. you're saying she has to use three separate programs, which should be composed into one, and in the same breath you're saying that the windows paradigm is bad because it encourages composing everything into one program
08:22:45 <dcoutts> chessguy, stuffing everything into one prog is probably not 'composing'
08:22:50 * allbery_b thinks monolithic standalone programs predated Windows, and that Microsoft has been unsuccessfully trying to get programmers to use composable DCOM instead
08:22:56 <kolmodin> I'd like to go to PADL too!
08:23:06 <shapr> dcoutts: which paper?
08:23:16 <dcoutts> the ability for progs to talk to each other without having been written for each other is what composing is all about
08:23:27 <dcoutts> shapr, erm... lemme check the proceedings
08:23:28 <shapr> chessguy: Yeah, what dcoutts said.
08:23:37 <chessguy> so what's the difference?
08:23:56 <shapr> I can write a spell checker in one line of shell script, and it uses at least three separate tools.
08:24:32 <dcoutts> shapr, "HPorter: Using Arrows to Compose Parallel Processes" by three authors including Paul Hudak.
08:24:42 <shapr> Ah, I love Hudak papers.
08:24:46 <dcoutts> aye
08:24:54 <chessguy> ah, so you're saying you should be able to easily compose the three existing tools into one without much effort
08:25:00 <shapr> chessguy: Yes!
08:25:15 <chessguy> ok, that makes more sense now
08:25:17 <allbery_b> I will also note that X11 is composable to some extent but it's ugly and hard to work with and about the only thing that uses it is embeddable browser components like e.g. acroread in mozilla
08:25:24 <dcoutts> shapr, they were doing this stuff with robotics and had a dozen or so programs for various components of the robot that all had to talk to each other over pipes
08:25:31 <allbery_b> ...and people tend to notice it's fragile and annoying
08:26:01 <dcoutts> shapr, and the script for launching this collection of processes and getting them plugged together correctly was very tricky.
08:26:07 <shapr> So the points I see are 1. command lines and input/output pipes are domain specific languages in interpreters and encourage users to learn programming just to use them. that leads to 2. monolithic non-composable programs discourage users from learning programming.
08:26:13 <Nafai> My ideal computing environment would be one where the entire stack horizontally and vertically is easily composable
08:26:21 <Nafai> Right now, there are separate silos
08:26:43 <Nafai> The shell and all of the standard Unix utilities, my X desktop (Gnome), Emacs, the web, etc
08:27:12 <shapr> chessguy: Do you think my 2. point is correct?
08:27:35 <shapr> Nafai: xclip is one piece along those lines.
08:27:44 <chessguy> at least from good programming, yes
08:27:49 <shapr> Next would be command line pipes for dbus and dcop
08:29:31 <shapr> I sort of feel like arguing with this guy when he says "Why should you need separate programs for receiving e-mail, sending e-mail, and filtering e-mail? The answer is, you shouldn't"
08:29:57 <Nafai> shapr: Yes!
08:30:41 <allbery_b> no, you shouldn't.  you shuld have components that fit together and a default combination of componenets for people who don't want to roll their own combination
08:30:55 <shapr> I use fetchmail to get my mail, procmail to filter my mail, and gnus to read and send replies to my local postfix.
08:31:01 <allbery_b> which for all practical purposes is a single program as seen by users like that
08:31:43 <chessguy> shapr, but if your argument is that they should be easily composable, then why not compose them and use them all together?
08:31:43 <bakert> i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it that way around.
08:32:34 <allbery_b> (composability is good.  forcing end users to compose stuff just to get a working email environment, not so much)
08:32:44 <chessguy> ?remember bakert i think it's a question of where you are looking from.  from the magician's point of view no one got sawn in half and from the audience's point of view someone did and they both like it that way around.
08:32:45 <lambdabot> Done.
08:32:46 <shapr> bakert: If I look at that as an argument in favor of abstraction, then I agree :-)
08:33:09 <allbery_b> difference beween it being possible and it being rammed down my thrat
08:33:12 <shapr> chessguy: Hm, I could do that with peti's postmaster.
08:33:16 <allbery_b> throat
08:33:44 <chessguy> shapr, and would it be convenient to do so?
08:33:59 <shapr> And I'm the only person who uses scannedinavian for business email, so if I broke it, it's my own fault.
08:34:14 <shapr> chessguy: Yeah, it would be actually.
08:34:38 <chessguy> then why do you have a problem with him saying you shouldn't need separate programs for receiving, sending, and filtering?
08:35:08 <chessguy> he's right, it would be convenient to be able to compose them well
08:35:36 <shapr> It seems to me that he's arguing against composition, and in favor of monolithic solutions.
08:36:29 <thedward> unified interfaces are great for lots of things, but just because there is one interface doesn't mean there has to be only one program.
08:36:30 <shapr> I prefer allbery_b's suggestion, solutions that work but are built of re-composable pieces.
08:36:43 <thedward> I think OpenDoc was an idea before its time.
08:36:50 <chessguy> well, i guess what he's arguing is irrelevant. the important thing is that monolithic solutions are a good thing if and only if it's composed of separate pieces that work well
08:37:13 <shapr> I'd say, pieces that work well in other situations also.
08:37:20 <shapr> Though here we're going off into code reusability.
08:37:21 <chessguy> yes
08:37:30 <shapr> I guess that fits with DSLs.
08:37:39 <chessguy> so how does this all translate into the GUI realm
08:38:02 <chessguy> i mean, buttons, toolbars, etc. seem to work together well in many situations
08:38:19 <allbery_b> code reusability is indeed central to this
08:38:20 <shapr> But those are just input, they're not functionality.
08:39:02 <chessguy> what do you mean by functionality? you write code behind a button that executes when the button is clicked on. doesn't the button then provide that functionality?
08:40:16 <allbery_b> buttons do provide functionality:  input and feedback
08:40:20 <shapr> I don't think so. I usually put the code in a separate chunk so it could be controlled by a variety of input widgets.
08:40:27 <allbery_b> you compose that with something that provides another functionality, an action
08:40:49 <shapr> chessguy: What you're describing sounds more like visual programming.
08:41:07 <chessguy> so what kind of functionality are you thinking of in the GUI realm that doesn't compose well?
08:41:50 <shapr> If a mixer is only accessible with the mouse, how can I compose it with other programs?
08:42:02 <chessguy> well yes, i'm a little tainted. most of the little GUI stuff i've done has been in something like Visual Studio <hangs head in shame>
08:42:05 <shapr> Unless it's something like the jackrack where I can drag'n'drop inputs and outputs...
08:42:37 <shapr> chessguy: Well, you're here on #haskell and learning stuff.
08:42:52 <chessguy> so you're saying there should be more serializable interaction behind the scenes in GUI apps?
08:42:52 <allbery_b> looked at Qt's model (signals and slots)?
08:42:57 <shapr> GHC dev is funded by Microsoft...
08:43:21 <shapr> chessguy: I think the GUI part is unrelated, I just want composition of some sort.
08:44:07 <chessguy> but the problem you identified is when things are 'only accessible with the mouse'...that's a GUI type of problem
08:44:18 <thedward> I'm not sure about the state of things on MacOS X, but there was a time on MacOS where pretty much every app was scriptable via AppleScript. There were lots of cool things you could do with scripts that called different apps.
08:44:38 <allbery_b> many apps still are
08:44:55 <allbery_b> and OSX AppleScript provides an ugly but serviceable way to fudge apps that aren't
08:44:57 <chessguy> yes, i think more programs should be extensible by adding scripts
08:45:29 <bakert> the unix pipeline is still the ultimate for scripting together lots of programs.
08:45:29 <thedward> DBUS is providing some of that functionality for some apps under linux.
08:45:35 <chessguy> ArcGIS does a good job of this, internally. not so much providing access to external programs, but being extensible itself
08:45:58 <allbery_b> most KDE programs can be scripted via the command line dcop client
08:46:09 <chessguy> oooh, a new xkcd is out!
08:47:03 <chessguy> heh
08:47:03 <koe> correct me if i'm wrong: monads are relatively simple syntax for defining ordered (and possibly stateful) operations, nothing more.
08:47:42 <chessguy> more like any operations with side effects, i think
08:48:12 <bakert> side effects is specifically the IO monad, no?
08:48:18 <allbery_b> mechanically they're syntax for intervening in the flow of data and doing things, which may involve sequencing, state, control flow (think Maybe), etc.
08:48:24 <Saizan> bakert: no
08:48:42 <bakert> oh.  so other monads can have side effects?
08:48:46 <chessguy> all monads control side effects
08:48:47 <allbery_b> ST
08:49:04 <Saizan> well depends on what you mean by side effects
08:49:19 <shapr> koe: I'd say monads are a really simple and smart way to compose code.
08:49:21 <bakert> i meant changing a file, database, website, etc.
08:49:44 <Saizan> in the State monad put has the side effect of altering the state, it returns nothing
08:49:47 <bakert> so i suppose by my definition i was right.  but perhaps my definition is awry.
08:49:52 <koe> shapr: i'm getting that "compose" means something special
08:50:17 <chessguy> shapr, DBUS looks pretty interesting. http://en.wikipedia.org/wiki/D-Bus
08:50:33 <shapr> koe: Not really.
08:50:34 <thedward> I remember seeing a haskell d-bus library somewhere
08:50:34 <chessguy> (try not to get caught up in 3 hours of fascinated clicking)
08:50:48 <allbery_b> chessguy: you might also want to look at Sun's ToolTalk
08:50:54 <shapr> koe: Part of the 'smart' in monads is that you can predict how things compose.
08:51:04 <shapr> koe: So maybe that's the special part?
08:51:51 <chessguy> hmm, these kinds of things do sound like monads
08:51:53 <shapr> koe: The Maybe monad is an abstraction of nested if then else statements, on the condition that you want the whole rat's nest to bail out upon the first failure, and only succeed if all statements are true.
08:52:24 <Anon4888> From my POV Monads are a scheme to embed one structure into another
08:52:26 <thedward> the semantics of the monadic operators seems quite different depending on what monad you are working with; it seems like they are primarily a shared syntax that enforces a certain set of rules
08:52:26 <koe> hmm.
08:52:35 <thedward> but I'm still figuring this all out. :)
08:53:03 <bakert> it makes no sense to me.  but little by little i find it takes less time to work out how to make it do what i want!
08:53:25 <shapr> koe: I like this one - http://www.haskell.org/haskellwiki/Monads_as_containers
08:53:26 <lambdabot> Title: Monads as containers - HaskellWiki
08:53:35 <bakert> i guess some conceptual understanding is forming in my subconscious.
08:53:40 <allbery_b> @go you could have invented monads
08:53:42 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
08:53:42 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
08:53:43 <shapr> koe: But this is my favorite http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
08:53:50 <shapr> allbery_b: you beat me to it!
08:53:51 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
08:54:01 <koe> i'm trying to get how monads work for Parsec *and* IO at the same time
08:54:02 <bakert> ?quote hello world
08:54:03 <lambdabot> No quotes for this person. stty: unknown mode: doofus
08:54:04 * allbery_b has that as a fingermacro these days :)
08:54:10 <bakert> ?quote hello
08:54:10 <lambdabot> No quotes match. I feel much better now.
08:54:18 <bakert> ?quote World
08:54:18 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
08:54:19 <shapr> @quote world
08:54:19 <lambdabot> syntaxfree says: monad tutorials are the "Hello world" of our community.
08:54:26 <bakert> there we are
08:54:30 <koe> lol
08:54:47 <Anon4888> sad but true
08:55:04 <chessguy> lol, no way
08:55:06 <shapr> koe: Anyway, once I 'got' monads, I suddenly wondered why people used those complicated object thingies :-)
08:55:12 <chessguy> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
08:55:12 <lambdabot>  Hello World!
08:55:38 <chessguy> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<
08:55:39 <lambdabot> Done.
08:55:43 <Anon4888> shapr: You see monads as a replacement to objects?
08:55:44 <chessguy> uh-oh
08:55:56 <Anon4888> I'd say type classes are the replacement for objects
08:56:13 <allbery_b> type classes don't really replace objects
08:56:15 <shapr> type classes don't hold state
08:56:44 <Anon4888> Ok, that's fair... a combination of the two then
08:57:01 <shapr> You want an abstraction that is predictably composable, and hides parts of the code that you're not working on right now.
08:57:08 <allbery_b> at most they give you method overloading, thus can be used useflly with monads (consider MonadState)
08:57:46 <chessguy> mm, it's not overloading, it's interfaces
08:57:50 <allbery_b> or MonadError, etc.
08:57:59 <allbery_b> interfaces are constrained overloading
08:58:00 <Anon4888> Typeclasses get you the polymorphism you have with object inheritence
08:58:09 <Anon4888> mostly
08:58:11 <shapr> Not really
08:58:24 <koe> what's the opposite of monadic in haskell?
08:58:32 <allbery_b> interfaces are how haskell provides overloading without turning into the anarchy of e.g. C++ overloading
08:58:33 <shapr> At least, you can't subclass a typeclass and have it count as an instance of the superclass.
08:58:33 <chessguy> non-monadic?
08:59:10 <Failure02> i'd like to bench a function i've written
08:59:14 <shapr> koe: Monads are just like any other code. Monads work fine in Ruby, Python, C, C++, Java, Scheme, or whatever.
08:59:19 <Failure02> i'm using Control.Exception.evaluate $ Control.Parallel.Strategies.rnf (stuff i want to evaluate)
08:59:21 <shapr> Failure02: I'll spot you.
08:59:24 <allbery_b> "fine"
08:59:34 <Failure02> how can i output the time it takes?
08:59:37 <koe> shapr: i'm starting to realize i've already written several in perl
08:59:38 <allbery_b> if you count syntax that makes templates look pretty
08:59:43 <shapr> koe: yup
08:59:50 <chessguy> Failure02, http://www.haskell.org/haskellwiki/Timing_computations
08:59:52 <lambdabot> Title: Timing computations - HaskellWiki
08:59:59 <Failure02> i can use :set +s, but then i have to do it manually for every function
09:00:05 <Failure02> chessguy: thanks, i'll look at it
09:00:32 <chessguy> on that note, i need to go compose some lunch into my stomach
09:00:33 <shapr> koe: Hey, are you in GA?
09:00:37 <koe> yes, why?
09:00:53 <shapr> I'd like to organize a Confederate FP meet, or some such.
09:01:10 <shapr> I'm in Alabama and looking for other nearby functional-programming-interested people.
09:01:18 <shapr> like Mr Anon4888 over there...
09:01:30 <shapr> dylan is in Florida
09:01:33 <koe> i'm a newbie to it, but i'm definitely interested
09:01:44 <Anon4888> I'm in Teyksas
09:02:01 <bakert> ?hoogle Monad
09:02:02 <lambdabot> Control.Monad :: module
09:02:02 <lambdabot> Data.Graph.Inductive.Monad :: module
09:02:02 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
09:02:12 <bakert> ?hoogle Maybe
09:02:13 <lambdabot> Maybe :: module
09:02:13 <lambdabot> Prelude.Maybe :: data Maybe a
09:02:13 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
09:02:22 <shapr> Anyway, I should get some work done...
09:02:44 <bakert> hmm ... so if I want the Maybe module what do I import?  Nothing?  "import Maybe"?
09:02:52 <bakert> I thought they all had qualified names now.
09:03:26 <bakert> Ah, it's Data.Maybe
09:03:35 <allbery_b> Maybe works in H98 mode
09:03:58 <bakert> I had Maybe already.  But I wanted to move to The Right Thing
09:05:47 <kolmodin> dcoutts: about the 'lookahead :: Int -> Get L.ByteString', wouldn't it be better if it took a 'Get a' instead for an Int
09:05:53 <kolmodin> dons: ^^
09:05:57 <bd_> @hoogle Ix
09:05:58 <lambdabot> Data.Ix :: module
09:05:58 <lambdabot> Ix :: module
09:05:58 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
09:06:00 <yaxu> my code is a mess, i think i'm missing a monad
09:06:40 <kolmodin> or maybe that it was ':: Get (Maybe a) -> Get (Maybe a)' and only advanced if the result is Just
09:07:12 <Anon4888> What's rule for when you need parens in (Class a) => Blah a and when you can just write Class a => Blah a?
09:07:23 <Botje> associativity?
09:07:34 <hpaste>  yaxu pasted "my code is a mess, i think i'm missing a monad" at http://hpaste.org/75
09:07:47 <yaxu> still, it makes a nice dot graph
09:09:45 <allbery_b> Class a => Blah a should always work, I think.  (Class a, Foo a) => Bar a
09:10:26 <kolmodin> yeah, I just think you need (x, y) when you want to state several classes
09:11:29 <Anon4888> thanks allbery
09:12:50 <dcoutts_> kolmodin, hmm
09:12:50 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
09:13:31 <dcoutts_> psnl, what was this about gtk2hs on osx ?
09:13:44 <dcoutts_> psnl, did you tell me this before ? I don't recall
09:14:08 <dcoutts_> kolmodin, so it'd be rather like parsec's try combinator
09:14:18 <dcoutts_> kolmodin, ie an unbounded lookahead
09:14:25 <dcoutts_> I think I like it :-)
09:14:31 <bakert> So I've got these two related but separate applications that need to share a few functions.  I've put them in a module but I'm a bit stuck about what to do next?  darcs doesn't do links, does it?  So I have to have the code in two places and do some kind of copy on build I guess.
09:14:57 <dcoutts_> bakert, or use a shared package
09:14:57 <bakert> both these apps are in the same source tree, by the way.
09:15:09 <bakert> dcoutts_, what's a shared package?
09:15:35 <dcoutts_> bakert, it's just an ordinary package but it'd be a dep of both apps
09:15:56 <dcoutts_> though if they're in the same source tree you can import directly using the -i flag to ghc
09:16:04 <bakert> dcoutts_, are we using the terms module and package interchangeably here.  I'd guess not.  So I need to find out about packages!
09:16:08 <dcoutts_> -i sets the module search path
09:16:30 <dcoutts_> bakert, packages are collections of modules and are the unit of app/lib distribution
09:17:04 <Saizan> packages are those listed by ghc-pkg list
09:17:42 <dcoutts_> and are managed/build with tools like cabal and cabal-get
09:17:42 <bakert>  /reconcile/balances, /reconcile/reconciler are the two "packages" ... so I guess I need to create something at /reconcile/shared and then point the .cabal files at it.  Or something.
09:18:21 <kolmodin> dcoutts_: cool. I'll look into rewriting the Get monad when I get home from work
09:18:47 <dcoutts_> kolmodin, ok great
09:19:03 <bakert> Saizan, dcoutts_, I see.  So I could install my shared thing and then they'd pick it up that way.  I'd rather not do that as it is really not general purpose code just general enough to be shared by those two.
09:19:17 <bakert> So should I just use the module search path to look in the shared dir as well as default locations?
09:19:20 <dcoutts_> kolmodin, I've not finished or pushed my changes to the get monad, the ones that treat the stream on the chunk level
09:19:27 <dcoutts_> kolmodin, though don't wait for me
09:19:31 <bakert> (I figure that's an option in the cabal file.)
09:19:58 <dcoutts_> bakert, you can specify source dirs in the .cabal file, yes.
09:20:05 <kolmodin> dcoutts_: oh, ok. good that you said that, I was about to rewrite it all :)
09:20:46 <bakert> How small is too small for a module would you say?
09:20:47 <kolmodin> dcoutts_: much left to implement? as long as it ~works you can commit so we all can get a look/crack at it
09:20:55 <dcoutts_> bakert, so you'd say something like, hs-source-dirs: src, shared
09:21:08 <bakert> dcoutts_, thanks.  i'll check it out.
09:21:08 <njd> @user igloo
09:21:09 <lambdabot> Maximum users seen in igloo: 1, currently: 0 (0.0%), active: 0 (NaN%)
09:21:22 <dcoutts_> bakert, nothing is too small for a module, too many small packages can get annoying though.
09:21:25 <bakert> ?seen Igloo
09:21:25 <lambdabot> Igloo is in #darcs, #ghc, #haskell.hac07 and #haskell. I last heard Igloo speak 1h 26m 6s ago.
09:21:35 <dcoutts_> kolmodin, no, it doesn't compile yet
09:21:47 <dcoutts_> kolmodin, changing the rep is easy, makeing it work again...
09:21:49 <Igloo> Hello?
09:22:11 <kolmodin> dcoutts_: that's why we have so many QC tests :)
09:22:13 * Igloo wonders what those numbers mean
09:22:20 <kolmodin> dcoutts_: although, they don't test everything
09:22:26 <kolmodin> dcoutts_: like skipping, lookahead, otc
09:22:30 <kolmodin> s/otc/etc/
09:22:36 <dcoutts_> kolmodin, I'm not at the QC stage, just making it compile!
09:22:44 <njd> Igloo: Hi, I was woundering if you had some time to go to #ghc and discuss some issues to do with the delayThread and registerDelay for windows?
09:22:53 <dcoutts_> kolmodin, feel free to add more tests of course
09:23:06 <kolmodin> dcoutts_: the nice thing about haskell is that when it does compile, it probably passes most QC tests too :D
09:23:14 <dcoutts_> aye :-)
09:23:26 <kolmodin> naturally, but it's not as fun as hacking Get monad.. ;)
09:23:35 <dcoutts_> @arr
09:23:36 <lambdabot> Ahoy mateys
09:23:38 <Igloo> njd: Could do, but I can't boot into Windows for 24 hours
09:24:04 <dcoutts_> Igloo, you impose win32 quotas on yourself to preserve your sanity? Good mad.
09:24:09 <dcoutts_> erm mad/man
09:24:20 <njd> Igloo: not a problem - i've got a "fix" for Unix side - need to ask some questions about the RTS on windows
09:24:46 <kolmodin> that's why the tests should be written first, otherwise there is a risk that they never will be implemented
09:24:48 <Igloo> dcoutts_: :-)  Just trying to see if memtest breaks after extended running on the laptop, as Linux does for some reason
09:25:00 <dcoutts_> ah, fair enough
09:25:18 <dcoutts_> Igloo, you can't get rdesktop access to some win32 server at GHC HQ?
09:25:24 <yaxu> how do i uniquify the elements of a sorted list?
09:25:31 <allbery_b> nub?
09:25:32 <Igloo> Nope
09:25:35 <bakert> yaxu, i think it's nub
09:25:37 <dcoutts_> Igloo, I use some 2-cpu win32 box in the comlab
09:25:44 <dcoutts_> via rdesktop
09:25:49 <Igloo> There isn't a nubSorted in the standard libraries, unfortunately
09:25:51 <bakert> ?hoogle nub
09:25:52 <lambdabot> List.nub :: Eq a => [a] -> [a]
09:25:52 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:26:18 <dcoutts_> nubSorted = map head . group . sort
09:26:22 <dcoutts_> (iirc)
09:26:23 <yaxu> oh, so i don't have to sort in advance?
09:26:35 <yaxu> thanks :)
09:26:46 <bakert> > let ns = map head . group . sort; ns [3,3,4,5,6,6,6]
09:26:46 <lambdabot>  Parse error
09:26:56 <bakert> > let ns = map head . group . sort
09:26:57 <lambdabot>  Parse error
09:27:02 <yaxu> > nub [4, 1, 4, 1, 3]
09:27:03 <lambdabot>  [4,1,3]
09:27:08 <dcoutts_> > let ns = map head . group . sort in ns [3,3,4,5,6,6,6]
09:27:10 <lambdabot>  [3,4,5,6]
09:27:22 <bakert> ah yes.  so used to using let in IO only.
09:27:24 <bakert> forget the in
09:27:32 <bakert> not in IO i use where.
09:27:44 <bakert> let or where.  odd one that.
09:27:44 <dcoutts_> > let ns = map head . group . sort in ns [3,4,3,4,5,7,6,3,6]
09:27:45 <lambdabot>  [3,4,5,6,7]
09:27:54 <dcoutts_> no need for the input to be sorted
09:29:32 * kolmodin heads home
09:29:53 <bakert> What's the function I should prefer to head because of empty lists?
09:30:19 <roconnor> pattern matching
09:30:27 <bakert> oh yes that's right.  thanks roconnor
09:30:44 <bakert> tricky in this case.
09:31:14 <roconnor> some times auxilarary functions are needed
09:37:08 <malebria> !paste
09:37:09 <hpaste> Haskell paste bin: http://hpaste.org/
09:37:47 <hpaste>  malebria pasted "Strange error without _ parameter" at http://hpaste.org/76
09:38:09 <malebria> I'm trying to compile this function using GHCi.
09:38:28 <malebria> I need to add this _ parameter for it to work.
09:38:29 <glguy> ?seen lisppaste2
09:38:29 <lambdabot> lisppaste2 is in #darcs and #haskell. I don't know when lisppaste2 last spoke.
09:38:52 <malebria> When I remove the _ parameter, I got the error:
09:38:54 * glguy pokes seen
09:39:28 <hpaste>  malebria annotated "Strange error without _ parameter" with "Error message" at http://hpaste.org/76#1
09:39:46 <malebria> glguy: it should keep remember me marked if I mark it one.
09:40:10 <glguy> malebria: if you mark it again it will change who it remembers you as..
09:41:08 <glguy> but your suggestion will be taken into consideration :-) you want it such that if you uncheck it it stops remembering you?
09:41:42 <malebria> glguy: that's how I thought it'd work.
09:41:50 <malebria> Ok, I made a simpler example.
09:42:39 <dcoutts_> bakert, in this case of map head after group, you know that group only gives you lists of non-empty lists.
09:42:56 <dcoutts_> hence head is fine
09:43:07 <bakert> i see.
09:43:23 <bakert> thanks dcoutts_
09:43:25 <hpaste>  malebria annotated "Strange error without _ parameter" with "Simple example" at http://hpaste.org/76#2
09:43:51 * dcoutts_ -> home
09:44:14 <malebria> It's very strange why with _ it compiles and without it I got a compilation error.
09:45:30 <sjanssen> malebria: is that the only error message?
09:45:36 <chessguy_away> Anon4888, whereabouts in TX?
09:45:42 <roconnor> @type liftIO
09:45:43 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
09:46:00 <roconnor> @type get
09:46:01 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
09:46:02 <malebria> sjanssen: yes.
09:46:17 <liyang> malebria: try giving it a type signature.
09:46:33 <roconnor> @type put
09:46:35 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => s -> m ()
09:46:50 <malebria> liyang: I can't, I get another error:
09:48:19 <hpaste>  malebria annotated "Strange error without _ parameter" with "type signature" at http://hpaste.org/76#3
09:49:29 <malebria> I can't get what difference _ makes.
09:49:33 <chessguy> where's the map that shwos where different #haskell people are
09:49:47 * glguy caused the part, no worries, brb
09:50:17 <roconnor> @map
09:50:18 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:50:27 <chessguy> ah, thanks
09:50:33 <liyang> malebria: try giving errorState :: StateT String IO ()
09:50:48 <Cale> We really should move that to the new wiki
09:50:49 <malebria> liyang: this isn't general enough for me.
09:51:20 <chessguy> Cale, it looks pretty outdated anyway
09:51:43 <liyang> malebria: without the _ parameter, you're stuck with the monomorphic restriction...
09:51:51 <psnl> dcoutts_: oh, had the odd bus error
09:51:56 <malebria> liyang: but it gives no error.
09:52:04 <psnl> dcoutts_: seems to be a problem in fontconfg
09:52:14 <psnl> dcoutts_: working nnow
09:53:14 <malebria> liyang: hum..
09:53:26 <liyang> malebria: it gives no error because it's able to infer a more general type.
09:54:01 <liyang> Unless you implement an alternative State monad, errorState :: MonadIO m => StateT String m () is as general as I can think of.
09:54:39 <malebria> I implemented an alternative monad.
09:54:53 <malebria> That's MonadState m and MonadReader m
09:56:18 <chessguy> ?hoogle MonadState
09:56:19 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
09:58:20 <liyang> malebria: I can get errorState :: (MonadIO m, MonadState String m) => m () if I allow -fglasgow-exts
09:59:44 <chessguy> ruh-roh
09:59:53 <chessguy> broken link on the libraries site
10:00:07 <chessguy> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html , click on 'Source code' at the top
10:00:09 <lambdabot> http://tinyurl.com/yy4aqu
10:01:29 <malebria> liyang: I prefer not to use -fglasgow-exts just because of this.
10:02:17 <chessguy> hmm, that's not the only source-code link that's broken
10:02:38 <liyang> malebria: funnily, ghci will happily /infer/ types (the MonadState String m) in the constraints, but won't allow you to give them in signatures.
10:03:25 <malebria> liyang: this is very strange.
10:03:44 <malebria> liyang: I asked about this in haskell-cafe@haskell.org, but no one answered.
10:07:55 <SyntaxNinja> yo
10:08:25 <dcoutts> @arr
10:08:25 <lambdabot> Swab the deck!
10:08:28 <dcoutts> hia SyntaxNinja
10:08:57 <chessguy> @yo
10:08:57 <lambdabot> I once decorated my apartment entirely in ten foot salad forks!!
10:09:41 <chessguy> i bet the chicks digged that
10:12:54 <glguy> ?hoogle PortNumber
10:12:54 <lambdabot> Network.PortNumber :: PortNumber -> PortID
10:12:54 <lambdabot> Network.PortNumber :: data PortNumber
10:12:54 <lambdabot> Network.Socket.PortNumber :: newtype PortNumber
10:13:42 <glguy> ?hooge connectTo
10:13:43 <lambdabot> Network.connectTo :: HostName -> PortID -> IO Handle
10:13:43 <lambdabot> Network.CGI.connectToCGIScript :: String -> PortID -> IO ()
10:14:51 <emu> hooge?
10:15:03 * glguy wonders if: PortNumber 1234   is the same as   PortNumber $ fromIntegral 1234
10:15:05 <glguy> in code
10:15:22 <glguy> since Haskell seems to call fromIntegral when it picks 1234's type
10:15:24 <emu> all integer literals are "fromInteger ..."
10:16:06 <thartman> how do most of you haskellers have your path set up, for stuff you check out from the semi-official repo of darcs.haskell.org?
10:16:20 <emu> PortNumber will require you to turn any concrete number type into Num a => a
10:16:27 <thartman> that was maybe not clear...
10:16:42 <emu> which path
10:17:46 <thartman> in your home dir, where you're working... do you have a directory like "darcs.haskell.org" that serves as a top level for whatever you would want to check out from there?
10:17:54 <emu> src/
10:17:59 <chessguy> hey glguy, do you know who this should be reported to? the link to source code from http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html (and a bunch of other source code links) is broken
10:18:00 <lambdabot> http://tinyurl.com/yy4aqu
10:18:10 <sjanssen> thartman: I generally darcs get directly in my home directory
10:18:20 * sjanssen happens to have a very messy ~ ;)
10:18:23 <chessguy> i have ~/haskell/
10:18:25 <emu> my home partition is full so i have a src/ dir on another one
10:18:38 <thartman> do you check out the whole darcs.haskell.org repo, or pick and choose?
10:18:41 <emu> i also have a ~/haskell/ for tinkering!
10:18:58 <emu> i only have ghc and maybe 1 or 2 other things
10:19:05 <glguy> chessguy: it would probably go in as doc bug in the tracker.... ideally added with a patch ;)
10:19:12 * kolmodin is home from work
10:19:13 <basvd> thartman: I have a directory development/haskell where I 'darcs get' any haskell projects. And I always also install them in my homedir: 'runhaskell Setup.hs configure --user --prefix=$HOME'
10:19:28 <chessguy> glguy, i don't know where it's supposed to go
10:19:33 <chessguy> what tracker?
10:19:37 <emu> i've also done $HOME/local on machines where i can't write to system dirs
10:20:32 <thartman> basvd, I think I'll be doing that too.
10:21:24 <glguy> chessguy: http://www.haskell.org/ghc/docs/latest/html/users_guide/bug-reporting.html
10:21:25 <lambdabot> Title: 1.2. Reporting bugs in GHC, http://tinyurl.com/zpaes
10:21:31 <basvd> thartman: See: http://www.haskell.org/ghc/docs/latest/html/Cabal/ for other ways of configuring...
10:21:32 <lambdabot> Title: Common Architecture for Building Applications and Libraries
10:22:00 <chessguy> glguy,thanks
10:23:27 <chessguy> ah, already reported.
10:23:28 <chessguy> http://hackage.haskell.org/trac/ghc/ticket/1044
10:23:30 <lambdabot> Title: #1044 (library docs on web have broken link) - GHC - Trac
10:28:13 <thartman> I"m trying to install NumericQuest: http://www.haskell.org/haskellwiki/Numeric_Quest
10:28:14 <lambdabot> Title: Numeric Quest - HaskellWiki
10:29:09 <thartman> after runghc Setup.lhs configure, next should be runghc Setup.lhs test... right?
10:29:17 <thartman> then runghc Setup.lhs instal... right?
10:30:07 <thartman>  get... Installing: /usr/local/lib/NumericQuest-0.0/ghc-6.4.1 & /usr/local/bin NumericQuest-0.0...
10:30:11 <thartman> Setup.lhs: Error: Could not find module: Eigensystem with any suffix: ["hi"]
10:32:05 <Saizan> have you run build?
10:33:34 <hpaste>  glguy pasted "how to I rewrite this?" at http://hpaste.org/77
10:38:09 <thartman> aha. first build, then install. seems to work. thx :)
10:38:44 <chessguy> aww, man. apparently when i'm at work people think i should be doing actual work :(
10:39:53 <kolmodin> dcoutts: the lookAhead stuff is pushed
10:40:00 <dcoutts> kolmodin, great
10:40:05 <dcoutts> that was quick!
10:40:07 <int-e> @where zlib
10:40:08 <lambdabot> darcs get http://haskell.org/~duncan/zlib
10:40:18 <kolmodin> dcoutts: that's because I haven't tested it... :D
10:40:22 <dcoutts> heh
10:40:37 <kolmodin> and it's only a few lines
10:40:54 <glguy> dcoutts: is that new functionality, or an enhancement?
10:41:05 <chessguy_work> int-e, hi! long time no see
10:41:28 <dcoutts> glguy, what? kolmodin's lookahead thing?
10:41:31 <glguy> yeah
10:41:40 <glguy> !paste
10:41:41 <hpaste> Haskell paste bin: http://hpaste.org/
10:41:49 <int-e> @where binary
10:41:50 <lambdabot> http://darcs.haskell.org/binary
10:42:03 <dcoutts> glguy, it allows you to do things that couldn't be done before
10:42:10 <int-e> lambdabot's dependencies have exploded :)
10:42:23 <int-e> chessguy_work: hmm, I've been around but mostly idle.
10:42:55 <chessguy_work> int-e, ah. i was just thinking earlier that i hadn't seen you much. glad to know you're still around
10:43:40 <kolmodin> you could just ask me, I'm still here? :)
10:43:53 <dcoutts> yeah, glguy, ask kolmodin :-)
10:44:10 <glguy> kolmodin:
10:44:27 <kolmodin> :)
10:44:37 <kolmodin> it gives you unlimited lookahead
10:45:27 <kolmodin> you give it a parser (of type 'Get a', 'Get (Maybe a)' or 'Get (Either a b)') and will or will not advance depending on what you return
10:45:44 <chessguy_work> is that for the new parser library?
10:46:07 <kolmodin> so it's kind of a cheep (ugly) backtracking
10:46:19 <kolmodin> chessguy_work: it's for the binary library
10:46:29 <chessguy_work> ah
10:47:00 <chessguy_work> by the way, did a new HWN go out yesterday?
10:47:00 <SyntaxNinja> @seen binkley
10:47:01 <lambdabot> I haven't seen binkley.
10:47:13 <SyntaxNinja> what's kirsten's nick?
10:47:29 <chessguy_work> brinkley, i think
10:47:51 <kolmodin> it's Binkley
10:48:02 <SyntaxNinja> @seen Binkley
10:48:03 <lambdabot> I haven't seen Binkley.
10:48:05 <SyntaxNinja> hmm
10:48:14 <chessguy_work> oh sorry
10:48:19 * chessguy_work slaps chessguy_work's bottom and grins cheekily
10:49:14 <SyntaxNinja> Oo
10:52:21 <profmakx> -.-
10:52:48 <Lemmih> musasabi: ping.
10:52:56 <musasabi> pong
10:55:12 * chessguy_work watches the ping-pong game
10:55:58 <Lemmih>          . |
10:56:03 <Lemmih>           '| *ping*
11:03:27 <glguy> dons: wake up:)
11:03:31 <glguy> musasabi: you around?
11:06:11 <glguy> ?tell dons Why did you determine that we couldn't write our own instance of encodeFPS?
11:06:11 <lambdabot> Consider it noted.
11:08:46 <basvd> cd ..
11:08:46 <basvd> l
11:08:55 <basvd> (oops wrong window)
11:11:11 <musasabi> glguy: yes.
11:11:32 <glguy> musasabi: did dons mention why he couldn't use encodeFPS in #happs yesterday?
11:11:47 <glguy> is it a big deal to convert a Lazy.Bytestring to a Base.ByteString
11:12:08 <dcoutts> glguy, yes. If the lazy bytestring is big.
11:12:24 <dcoutts> since it involves forcing the whole string into memory
11:12:28 <glguy> even if you intend to write the whole thing to a file anyway?
11:12:28 <musasabi> glguy: no, he didn't mention it.
11:12:31 <glguy> ok
11:12:50 <glguy> musasabi: but if we defined encodeFPS, encodeStringM would be defined in terms of it?
11:12:56 <dcoutts> glguy, if the whole lazy bytestring is in memory anyway then it's just a copy of the whole thing
11:13:05 <dcoutts> so not quite so expensive
11:13:11 <dcoutts> but it's still a copy
11:13:11 <glguy> dcoutts: the alternative is unpacking it to a String
11:13:37 <dcoutts> glguy, huh? you can process it as a ByteString or as a String but not as a lazy one?
11:13:59 <glguy>   encodeFPS :: (Monad m) => a -> m [Data.ByteString.Base.ByteString]
11:14:24 <glguy> encode :: (Binary a) => a -> Data.ByteString.Lazy.ByteString
11:14:43 <dcoutts> those two are basically the same
11:15:22 <dcoutts> they're convertible via to/fromChunks
11:15:23 <musasabi> glguy: the HAppS serialization API is from a time before lazy bytestrings.
11:15:34 <musasabi> thus it uses [StrictByteString]
11:15:40 <dcoutts> ah, I see
11:15:51 <glguy> would it be better to have it use LazyByteStrings now?
11:16:05 <dcoutts> so you can use fromChunks to get from [StrictByteString] to Lazy.ByteString
11:16:06 <glguy> especially if Data.Binary is going to a an excellent way to serialize data?
11:16:36 <dcoutts> musasabi, did you ever profile the HappS serialization btw?
11:16:51 <glguy> current code:
11:16:51 <glguy>         encodeStringM a = return . L.unpack . compress . encode $ a
11:16:52 <glguy>         decodeStringM s = L.length ps `seq` return (decode (decompress ps), "")
11:16:52 <glguy>             where ps = L.pack s
11:18:45 <glguy> default implementation
11:18:46 <glguy> encodeFPS x = liftM ((:[]) . P.pack) (encodeStringM x)
11:19:28 <glguy> seems like the present hpaste implementation is unpacking only to pack again
11:20:01 <svref> does compiling "ghc -O" turn off asserts?
11:20:38 <Procyon> How close to Miranda is Haskell syntax?  If I am going through "Implementation of Function Languages", would I be able to just use haskell for the examples with minimal transformation, or should I get a Miranda interpreter?
11:22:08 <pejo> Procyon, you should do fine with a haskell interpreter for the code in the book.
11:22:26 <svref> Augh!  Apperantly -O does turn off asserts!  No wonder they're not tripping!
11:22:34 <pejo> (I transcribed the type checker in some chapter (9?) to Haskell, it was mostly just typing).
11:23:07 <glguy> dcoutts: what was the function for copying a lazy bytestring to a strict one?
11:23:11 <Procyon> pejo: awesome.  Thanks.
11:23:27 <glguy> ?docs Data.ByteString
11:23:27 <lambdabot> Data.ByteString not available
11:23:32 <glguy> ?docs Data.Char
11:23:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
11:24:10 <abz> ?doc Prulude.error
11:24:11 <lambdabot> Prulude.error not available
11:24:35 <abz> ?doc Prelude.error
11:24:36 <lambdabot> Prelude.error not available
11:25:01 <saccade> any graph theorists hiding here?
11:25:28 <xerox> abz: there's a good explanation of error and what _|_ means in the Haskell Report.
11:25:36 <psnl> saccade: whats the question?
11:25:47 <abz> thanks xerox
11:26:18 <chessguy_work> [14:19] <saccade> I want to know the usual way of calculating the mean coefficient of clustering in graphs that include nodes of degree 1 or 0
11:26:23 <svref> saccade: I guess I'm a graph theorist
11:27:10 <svref> or maybe not,... I have no idea what Chessguy_work is talking about.
11:27:17 <musasabi> dcoutts: seriealization was not a very high factor when benchmarking generic HAppS performance and it was waiting for a "good" binary library to come around so it has not had very much focus.
11:27:28 <dcoutts> musasabi, right.
11:27:28 <psnl> saccade: I'm not that good with graphs
11:27:42 <saccade> I want to know the usual way of calculating the mean coefficient of clustering in graphs that include nodes of degree 1 or 0
11:27:48 <musasabi> the plan is to use the new binary library at some point.
11:27:53 <dcoutts> great
11:28:05 <saccade> chessguy_work: heh, thx
11:28:06 <svref> saccade: me=clueless.
11:28:10 <saccade> np, thx
11:28:17 <Anon4888> saccade: compute the coefficient of clustering for each graph, add them up, and divide by the total number of graphs
11:28:36 <saccade> Anon4888: are you being flip?
11:28:44 <Anon4888> yes
11:28:47 <saccade> ok
11:28:58 <saccade> I guess I got a giggle out of that
11:30:12 <glguy> dcoutts: so I need concat . toChunks?
11:30:17 <syntaxfree> new rant!
11:30:19 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/24/python-is-soup-in-a-cup/
11:30:22 <lambdabot> Title: Python is soup-in-a-cup  Data.Syntaxfree, http://tinyurl.com/2qpwp2
11:31:05 <dcoutts> glguy, you've got a list of chunks already, from your encodeFPS function. So call fromChunks on that list and you've got yourself a lazy bytestring
11:31:32 <glguy> dcoutts: I think I'm going the other direction with encodeFPS
11:31:38 <glguy> Lazy -> [Strict]
11:31:41 <dcoutts> glguy, why?
11:31:50 <glguy> dcoutts: this is for saving to disk
11:31:50 <dcoutts> oh list of strict is ok
11:32:08 <dcoutts> glguy, yeah, you can just call Data.ByteString.Lazy.writeFile
11:32:24 <glguy> dcoutts: that part is hidden away in HAppS :)
11:32:28 <dcoutts> glguy, the strict and lazy versions have almost exactly the same api
11:32:45 <chr1s> hi!
11:33:08 <chr1s> I've got a function which performs a map over a list
11:33:33 <syntaxfree> chr1s: that's a damn useful function, isn't it? ;)
11:33:45 <chr1s> I'd like to use different threads for every element
11:33:47 <sek> hm whats that function called that combines all elements of 2 lists together in relation to some function? Not zipWith that does (1,1) (2,2) and so on. I need all combinations
11:33:50 <chr1s> syntaxfree: hehe, yes
11:34:04 <chr1s> would it be easy to make that function multithreading?
11:34:08 <syntaxfree> I'm in a silly mood. I'm always in a silly mood after writing long meandering rants.
11:34:26 <xerox> sek: cartesian product of the two lists?
11:34:49 <sek> xerox three lists actually yes:)
11:34:52 <xerox> > liftM2 (,) [1..3] [5..7]
11:34:52 <sek> zipWith3 i was trying
11:34:53 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
11:35:01 <astrolabe> sek: I don't think it's in the prelude
11:35:01 <xerox> liftM3 (,,) will world
11:35:24 <xerox> world? work.
11:35:32 <sek> > liftM3 (*)  [1..3] [4..6] [7..9]
11:35:32 <lambdabot>   add an instance declaration for (Num (a -> r))
11:35:32 <lambdabot>     In an arithmetic sequenc...
11:35:42 <sek> > liftM3 (\x y z -> x*y*z) [1..3] [4..6] [7..9]
11:35:42 <xerox> (*) is not a ternary function
11:35:43 <lambdabot>  [28,32,36,35,40,45,42,48,54,56,64,72,70,80,90,84,96,108,84,96,108,105,120,13...
11:35:54 <Lemmih> @pl \x y z -> x*y*z
11:35:54 <lambdabot> ((*) .) . (*)
11:35:55 <chr1s> I looked into Concurrent.Parallel.Strategies, but I'm not sure if that's the right place to start
11:36:03 <sek> thats not quite what  wanted, hm
11:36:16 <chr1s> it does have parMap, but is that what I'm looking for?
11:36:18 <sek> oh i see
11:36:26 <sek> yeah thats it. thanks:)
11:36:32 <xerox> You're welcome.
11:36:32 <syntaxfree> (f .) . g should be formalized.
11:36:42 <xerox> (.:) = (.) . (.)
11:36:44 <xerox> f .: g
11:36:55 <syntaxfree> ah, yes. I firgot!
11:37:19 <malebria> @type (.:)
11:37:20 <chessguy_work> @type (.:)
11:37:20 <lambdabot> Not in scope: `.:'
11:37:22 <lambdabot> Not in scope: `.:'
11:37:30 <chessguy_work> ?hoogle (.:)
11:37:31 <lambdabot> Did you mean: (.:)
11:37:31 <lambdabot> Prelude.undefined :: a
11:37:31 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
11:37:39 <sek> xerox thats not in prelude though is it. Where can i find it
11:37:51 <xerox> ?index liftM3
11:37:52 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:37:53 <chessguy_work> ?type (.) . (.)
11:37:54 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:38:02 <Z4rd0Z> how to convert a CInt to an IO String?
11:38:09 <sek> so how will i load it?
11:38:09 <syntaxfree> boy, someone should send (.:) to the Haskell' and GHC people.
11:38:26 <xerox> sek - import Control.Monad
11:38:35 <Z4rd0Z> do I need to convert to a string in C, then use peekCString?
11:39:07 <thartman> in ghci, import Control.Monad.List works, but when I try to import something I darcs-got and built.... import numeric-quest.Roots .... complains "parse error on numeric"
11:39:08 <sek> i'm on interactive
11:39:14 <chessguy_work> > ((.) . (.)) (^2) (*) 2 3 -- /me crosses fingers
11:39:15 <lambdabot>  36
11:39:16 <syntaxfree> sek:
11:39:21 <syntaxfree> :m + Control.Monad
11:39:31 <syntaxfree> include the trailing ":"
11:39:32 <chessguy_work> ohhhh
11:39:37 <sek> great, thanks
11:39:47 <thartman> am I only allowed to import from the prelude?
11:40:02 <thartman> does import not like hyphens>
11:40:04 <chessguy_work> only haskell could have pornographic operators
11:40:10 <syntaxfree> Control.Monad isn't in the prelude.
11:40:37 <qwr> syntaxfree: about the python-soup... imho some scheme implementations do dynamic typechecking and native code compilation
11:40:55 <zeeeee> i'm not sure how to word my question without making it sound like i'm asking for TH, but is there a template system with a haskell backend? similar to the template systems often used to generate HTML using languages like PHP (i'm interested in generating java code)
11:40:57 <sek> syntaxfree, if i want to call sort on the result of this function it comaplins its not in scope
11:40:57 <syntaxfree> qwr: yes, Common Lisp implementations too.
11:41:06 <syntaxfree> That's why I didn't mention it.
11:41:44 <syntaxfree> zeeeee: I generate shell scripts with "putStrLn" :)
11:41:50 <zeeeee> or maybe something 'better' than templates...i'm just interested in code generation (currently i'm writing haskell that outputs the program using putStrLn)
11:41:57 <sek> ah its in List is it
11:42:06 <zeeeee> syntaxfree: we think alike!
11:42:11 <sek> yeap:)
11:42:29 <syntaxfree> zeeeee: :)
11:42:48 <zeeeee> i'm just wondering if there's a Better Way
11:43:28 <glguy> dcoutts: thanks for your help, we don't need to convert to String anymore to save
11:43:39 <glguy> musasabi: and thanks for all your work on HAppS :-D
11:43:40 <dcoutts> good good
11:43:57 <glguy> musasabi++
11:44:00 <glguy> dcoutts++
11:44:52 <syntaxfree> !paste
11:44:53 <hpaste> Haskell paste bin: http://hpaste.org/
11:45:09 * glguy notices that the memory footprint is smaller now
11:45:21 <glguy> I think that copying out to string was eating ram...
11:45:39 <syntaxfree> hpaste is looking pretty good, except for one detail.
11:45:51 <glguy> I can think of a few
11:45:56 <glguy> but what is yours?
11:46:11 <chessguy_work> > let .: = ((.) . (.)) in (.:) (^2) (*) 2 3   --
11:46:11 <syntaxfree> the purple buttons.
11:46:12 <lambdabot>  Parse error
11:46:22 <syntaxfree> the old squarey buttons were better.
11:46:26 <syntaxfree> I think I'd use plain links.
11:46:37 <glguy> plain links don't submit forms on their own
11:46:53 <chessguy_work> > let (.:) = ((.) . (.)) in (.:) (^2) (*) 2 3
11:46:55 <lambdabot>  36
11:46:58 <chessguy_work> ah
11:47:09 <syntaxfree> glguy: oh. you're right.
11:47:18 <syntaxfree> I liked the squarey buttons anyway.
11:47:53 <glguy> <!-- is a CSS comment?
11:47:59 <glguy> hm now
11:48:14 <glguy>  /* */ is
11:48:26 <chessguy_work> <!-- is an html comment
11:48:29 <glguy> right
11:48:37 * glguy doesn't comment enough to keep them all straight ;)
11:49:09 <syntaxfree> you get addicted to the haskell way, yes.
11:49:50 <glguy> I can change those buttons in CSS
11:49:51 <bos> > const True 1
11:49:52 <lambdabot>  True
11:49:55 <glguy> for example, look now
11:50:11 <syntaxfree> they still look the same to me.
11:50:20 <syntaxfree> oh.
11:50:21 <syntaxfree> i see.
11:50:36 <glguy> I can underline those to
11:50:37 <glguy> o
11:50:37 <syntaxfree> square is good.
11:51:08 <glguy> what about something like this?
11:51:42 <thartman> ?paste
11:51:42 <lambdabot> http://hpaste.org (Haskell pastebin)
11:52:43 <syntaxfree> cool!
11:52:52 <glguy> you like the roll over?
11:52:56 <syntaxfree> I like that. they could be black, and that'd be perfect.
11:53:02 <syntaxfree> yes!
11:53:04 <glguy> what would be black?
11:53:22 <glguy> border and text?
11:53:24 <syntaxfree> i'd use that roll-over and borders for the "annotate", etc. links as well.
11:53:24 <glguy> or just one
11:53:26 <syntaxfree> yes.
11:53:30 <syntaxfree> inverse background too.
11:54:07 <thartman> all right, I got Roots.hs from NumericQuest to work. hooray ;)
11:54:07 <glguy> now look
11:54:08 <chessguy_work> hmm, maybe 'when' should be 'age'
11:54:13 <glguy> I think that the purple might be better
11:55:10 <chessguy_work> ?hoogle (a->b) -> f a -> f b
11:55:10 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:55:11 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:55:11 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:55:15 <syntaxfree> http://programming.reddit.com/info/10d5z/comments
11:55:17 <syntaxfree> hahahahaha
11:55:17 <lambdabot> Title: Harmful Killfiles Considered (reddit.com)
11:55:23 <syntaxfree> oops., I thought I was on -blah.
11:55:34 <glguy> hey, stay on topic !
11:56:32 <syntaxfree> I like buttons now.
11:56:41 <glguy> the old ones?
11:56:47 <syntaxfree> I don't like purple.
11:56:49 <glguy> or in general
11:56:52 <glguy> :-p
11:57:18 <syntaxfree> right now.
11:57:26 <syntaxfree> Why not make them red?
11:57:40 <malebria> Where do I find the differences between hsql and hdbc?
11:58:24 <glguy> because the theme is white->gray->black   with blue/purple/teal shades in links highlighting buttons etc
11:58:51 <syntaxfree> that pruple looks like a viewed link in ordinary html.
11:58:58 <syntaxfree> Maybe anotther shade of purple.
11:59:01 <glguy> it's a BOX
11:59:11 <glguy> that turns opaque when you hover
11:59:32 <syntaxfree> that shade of purple is pass.
11:59:56 <syntaxfree> dunno. I don't want to be overcritical.
12:00:01 <Anon4888> syntaxFree, reading your rant:  Is an "integrity domain" the same thing as an "integral domain"?
12:00:28 <syntaxfree> an integrity domain is a ring where a * b = 0 ===> a = 0  or b = 0
12:00:39 <syntaxfree> or something like that :P
12:01:46 <Anon4888> That's an "integral domain" to me
12:01:52 <syntaxfree> so it is.
12:02:09 <syntaxfree> "integral domain" sounds dangerously close to "integration domain" to me.
12:02:14 <syntaxfree> But I never learned any maths in english.
12:04:39 <malebria> CosmicRay: is there a page with the differences between hsql and hdbc?
12:04:45 <glguy> The one "trivial" issue that I can't figure out is what to all the current "revisions" column "annotations" is long, "annos" isn't descriptive
12:05:30 <syntaxfree> replies?
12:05:34 <syntaxfree> "replies".
12:05:48 <syntaxfree> "Annotations" isn't descriptive anyway.
12:05:57 <glguy> "#"
12:06:09 <glguy> with a hover tool-tip?
12:06:15 <CosmicRay> malebria: not really, but I've probably written about it on the mailing lists from time to time
12:06:18 <glguy> or "+"
12:06:30 <syntaxfree> I suggest "replies".
12:06:37 * syntaxfree ducks
12:07:03 <twanvl> <abbr title="Annotations">ann.</abbr>?
12:07:05 <glguy> well.. if no one has an opnion, I'll just go with "number of annotations made"
12:07:12 <malebria> CosmicRay: there's not support for savepoints in hdbc, right?
12:07:21 <abz> I have a question wrt the use of Prelude.error within Haskell libraries: Is it okay for a Haskell library to use Prelude.error rather than Exceptions?
12:07:22 <CosmicRay> malebria: to summarize: hdbc doesn't segfault for me, it supports replacable parameters (precompiled queries) in every function, it feels more like a DBI-ish interface than HSQL, and IMHO has a better/more verifiable memory management model in the backend drivers
12:07:39 <malebria> hum...
12:08:00 <abz> Exceptions allow the programmer to recover from invalid input...
12:08:00 <CosmicRay> malebria: not directly, but you can issue arbitrary queries via HDBC so you could probably support it
12:08:18 <Anon4888> syntaxFree, search for "soup-in-a-coup"
12:08:37 <malebria> CosmicRay: yes, that's what I thought. I'm using haskelldb right now, but I think I'm gonna have to move to hdbc because of this lack of support.
12:08:45 <CosmicRay> malebria: see http://www.mail-archive.com/haskell@haskell.org/msg17868.html
12:08:45 <syntaxfree> with that spelling?
12:08:45 <syntaxfree> @google soup-in-a-coup
12:08:52 <Anon4888> in your rant :P
12:08:56 <Anon4888> and yes, with that spelling
12:09:04 <syntaxfree> oh, I did that?
12:09:06 <syntaxfree> WIll fix.
12:09:49 <glguy> http://hpaste.org/77
12:09:49 <Anon4888> Also you spelled fanboy wrong - it's fanboi
12:09:52 <glguy> any ideas?
12:10:02 <syntaxfree> Anon4888: I tend to spell "boi" as french.
12:10:03 <CosmicRay> malebria: I forgot the bit about not being able to reference columns by number in hsql.  that bugged me tremendously.
12:10:06 <malebria> CosmicRay: thanks.
12:10:10 <abz> malebria: what are you trying to do with haskelldb
12:10:13 <syntaxfree> er, not spell, pronounce.
12:10:19 <glguy> fanbeaux?
12:10:22 <Anon4888> I'm not serious
12:10:23 <malebria> abz: I'd like to be able to use savepoints.
12:10:34 <syntaxfree> no, fan-bwah.
12:10:53 <malebria> abz: If I could do this in haskelldb it would save me a lot of time of migration to hdbc.
12:11:01 <syntaxfree> Anon4888: oh god. In a <strong>sentence</strong> too!
12:11:15 * syntaxfree wonders if he can get Guido van Rossum bitching in his comment box now.
12:11:41 <Anon4888> syntaxfree - yes, that's why I couldn't just let it go :)
12:11:50 <syntaxfree> thanks. I appreciate it :)
12:11:52 * arjanoosting stares at his -private folder at decides he will eat first
12:12:13 <arjanoosting> oeps, wrong channel
12:12:22 <syntaxfree> it's fixed!
12:12:42 <dcoutts> liyang, yay, got it using librsvg!
12:12:53 <glguy> ?tell dons I wrote a encodeFPS in the spirit of your encodeStringM with great success (and memory savings)
12:12:55 <malebria> abz: do you know if it's possible?
12:13:01 <dcoutts> liyang, and the demo prog works. That'll be next release candidate.
12:13:03 <glguy> @bott
12:13:08 <malebria> CosmicRay: do you know if it's possible to use savepoints with haskelldb?
12:13:16 <glguy> lambdabot: died?
12:13:19 <glguy> @botsnack
12:13:35 <abz> malebria: mmm...I've come across similar problems with haskelldb, I couldn't find a way around other than to use HSQL
12:14:15 <malebria> abz: you mean mix haskelldb with hsql?
12:14:27 <abz> malebria: I use them together...
12:14:32 <syntaxfree> any netvibes users?
12:14:43 <abz> haskelldb for the normal queries and hsql for the hard stuff
12:14:55 <malebria> abz: but how do you get the Connection?
12:15:18 <syntaxfree> planet haskell mangles up my tables!
12:15:48 <abz> malebria: wrt connection. I was just using postgresql on a local machine
12:15:59 <abz> so a connection is trivial
12:16:21 <glguy> ?docs Data.IntMap
12:16:25 <glguy> bah
12:16:27 <glguy> I forgot already
12:16:39 * glguy had left to get some tea
12:17:02 <abz> I also use template haskell to generate large parts of the haskelldb
12:17:43 <syntaxfree> oh. shame on me.
12:17:57 <syntaxfree> My long uninformed rant obscured a post by Philip Wadler!
12:18:07 * syntaxfree kneels and prays in the direction of Glasgow for forgiveness.
12:18:14 <psnl> edinburgh, please
12:18:32 <syntaxfree> (obscured = not the latest post in Planet Haskell anymore)
12:18:45 <malebria> abz: but you don't use the same connection for both then.
12:18:51 <psnl> hell, if he is a true edinburgh person, then praying to glasgow is a far bigger mistake
12:19:17 <syntaxfree> the direction of glasgow is roughly the same as edinburgh from where I am.
12:19:27 <malebria> abz: I want to call haskelldb functions inside a "subtransaction" using savepoints.
12:19:41 <abz> malebria: god no. They are in different modules and I don't use haskelldb and HSQL with the one connection, they used their own
12:19:52 <syntaxfree> http://maps.google.com/maps?q=rio+de+janeiro&ll=-23.003912,-43.340120&spn=0.035143,0.040688&t=k&hl=en
12:19:56 <malebria> abz: that's what I wanted.
12:21:28 <abz> malebria: yeah, just can't do that with haskelldb, I wanted MD5 calls.
12:21:48 <abz> malebria: But HSQL should get you there.
12:22:11 <malebria> abz: Then I think I'll use only hdbc.
12:23:00 <abz> malebria: Have you tried using haskelldb for the simple stuff?
12:23:30 <abz> like just getting things out of the DB
12:24:29 <malebria> abz: yes, I'm using it.
12:28:34 <syntaxfree> http://swtch.com/~rsc/regexp/regexp1.html
12:28:58 <int-e> @help spell
12:33:57 <malebria> Is http://www.haskell.org/hawiki/TemplateHaskellTutorial the best template haskell tutorial?
12:36:31 <abz> malebria: I read the template haskell paper, but that tutorial looks really good.
12:37:10 <abz> looks easier to understand then paper...
12:37:16 <Anon4888> you might also want to check to see if syntaxfree has an incomprehensible rant on template haskell
12:37:54 <syntaxfree> HEH.
12:38:09 <Anon4888> ;)
12:38:11 <syntaxfree> god, do I really write *that* badly?
12:38:42 <Saizan> syntaxfree: do you know that there are at least 4 implementation of python?
12:38:51 <Saizan> +s
12:39:00 <syntaxfree> you mean, Jython, IronPython, PyPy, etc.?
12:39:08 <Saizan> yeah
12:39:26 <piggybox> and stackless python
12:39:28 <glguy> Does anyone know why toDescList is not exported by Data.Map or Data.IntMap?
12:39:44 <abz> syntaxfree: were you the coauthor of the TH paper?
12:39:51 <syntaxfree> EH.
12:39:53 <syntaxfree> HEH.
12:40:01 <syntaxfree> I'm the co-author of nothing.
12:40:06 <syntaxfree> My girlfriend left me.
12:40:12 <syntaxfree> I'm all alone in the world.
12:40:42 <glguy> could someone confirm that Data.Sequence is as efficient as Data.Map for updates and indexing?
12:41:13 <abz> Does anyone use zenirc with xemacs?
12:41:28 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.92.1 (of 2007-01-20)
12:43:02 <kolmodin> dcoutts: what happened to the writeN/writeN rule?
12:43:12 <kolmodin> did it work?
12:46:16 <malebria> do { a ; b} is the same as a >> b, right?
12:46:32 <bos> yep
12:46:33 <malebria> As do-blocks are decomposed to lots of expressions joined up by >>=, an mzero at any point will cause the entire do-block to become mzero.
12:46:43 <malebria> http://en.wikibooks.org/wiki/Haskell/MonadPlus
12:47:08 <bos> slightly incorrect wording.
12:47:45 <malebria> bos: I thought that a mzero in a do block would not cause the entire block to become zero.
12:48:01 <malebria> I thought that the return value of a function called in the middle of a do block was ignored.
12:48:12 <bd_> malebria: The /return value/ yes
12:48:21 <bd_> but mzero's effect isn't a return value
12:48:47 <bd_> mzero >>= _ == mzero is a MonadPlus law, I think :)
12:48:56 <bos> malebria: it does.
12:49:22 <malebria> bd_: it is.
12:49:24 <bos> the MonadPlus rules require that v >> mzero == mzero
12:49:42 <malebria> >> ?
12:49:46 <bos> and likewise that mzero >>= v == mzero
12:50:47 <bos> basically, as soon as you hit an mzero, your chain of monadic actions terminates with that mzero.
12:51:05 <malebria> In the GHC doc it sais about mzero >>= _ = mzero and _ >> mzero = mzero but not mzero >> _
12:51:07 <bos> if my understanding is correct, which it is surely not guaranteed to be.
12:51:27 <xerox> malebria: mzero >> _ = mzero >>= \_ -> _
12:51:53 <bos> malebria: if mzero >>= v == mzero, that implies that mzero >> v == mzero.
12:51:55 <Botje> ?src (>>)
12:52:02 <malebria> hum..
12:52:15 <Syzygy-> Botje: You may want to specify monad
12:52:18 <malebria> I didn't know this.
12:52:28 <allbery_b> ?src [] (>>)
12:52:28 <xerox> ?src (>>)
12:52:31 <xerox> ops.
12:52:32 <bos> >> is defined in terms of >>=/
12:52:38 <allbery_b> by default
12:52:41 <allbery_b> it can be overridden
12:52:43 <allbery_b> ?bo
12:52:45 <bos> sure.
12:52:46 <allbery_b> ?bot
12:52:49 <allbery_b> hmmm....
12:52:59 <bos> but even if it's not defined in those terms, it should behave as if it wass.
12:53:38 <syntaxfree> @google wasser
12:56:28 <malebria> I can't find Monad class definition in GHC source.
12:57:50 <chessguy_work> [14:51] <lambdabot> Title: Harmful Killfiles Considered (reddit.com)
12:57:57 <chessguy_work> looks like lambdabot's last words
12:58:34 <syntaxfree> @info eq
12:58:37 <syntaxfree> @info Eq
12:58:46 <chessguy_work> LB's dead syntaxfree
12:59:09 <syntaxfree> chessguy: I wonder if Harmful KillFiles Considered were lambdabot's shutdown passphrase.
12:59:27 <chessguy_work> maybe so
12:59:43 <bos> is "not even wrong" the new "considered harmful"?
12:59:51 <chessguy_work> anyway, it's clearly all your fault
13:00:13 <syntaxfree> heh.
13:00:26 <syntaxfree> I think I killed lambdabot with my newest uninformed rant.
13:00:43 <syntaxfree> "There *are* multiple Python implementations", it thought, and collapsed on the floor sobbing.
13:03:27 <Saizan> syntaxfree: i'll tell you more: you can even compile it to native code (a bit experimental though)
13:04:15 <syntaxfree> what is "native code"?
13:04:33 <bos> code run by people with flint tools and hide for clothes.
13:04:42 <syntaxfree> I remember hearing that VB didn't compile to native code (in the 3.0/4.0 era) because it just called the vbrunx00.dll files.
13:05:43 <bd_> There were plenty of decompilers available certainly
13:06:01 <syntaxfree> hmm.
13:06:05 <syntaxfree> so native code can't be decompiled?
13:06:20 <bos> it can, but it's a very hard job.
13:06:21 <allbery_b> it can, but it's harder than decompiling bytecode
13:06:46 <bos> and it's not always possible, especially on instruction sets like x86, to turn it into readable code.
13:07:06 <syntaxfree> what is thedefinition of "native code", then?
13:07:06 <nornagon> 'native code' essentially means 'assembler'
13:07:20 <syntaxfree> It seems to be dynamic language "compilers" always bundled a huge runtime.
13:07:21 <bos> the binary stuff that your CPU runs.
13:07:33 <dons> ?bot
13:07:37 <syntaxfree> it's all "native" if you take it as a whole.
13:08:16 <syntaxfree> what I'm trying to say is that "native code" is a fuzzy concept.
13:08:20 <allbery_b> that said, the line can be pretty fuzzy:  Forth is in some sense compiled into "native code" in interpreters
13:08:24 <bos> that's not a very useful way of thinking.
13:09:02 <cjeris> argh, monad transformer ist ein Kopfexplosion
13:09:36 <syntaxfree> das explosion in Festpielhaus!
13:09:42 <syntaxfree> lieben heit lieben!
13:10:01 <syntaxfree> WIllst du bist der Tod euch scheidet!
13:12:10 <syntaxfree> Treu ihr sein fr alle Tage!
13:12:36 <Saizan> rammstein?
13:12:56 <vincenz> DU hast!
13:12:57 <pejo> Is that correct german?
13:13:15 <Syzygy-> It has a slightly ballistic treatment of the '!'
13:13:49 <syntaxfree> Saizan: first, Einstuerzende Neubauten. Then Laibach, then Rammstein.
13:14:23 <cjeris> (einstuerzende neubauten) >>= return . ((+) 1)
13:14:33 <bos> wow, who knew we had a whole channel full of mitteleurope industrial fans?
13:16:01 <cjeris> syntaxfree: do you know Auto Aggression?
13:16:15 <syntaxfree> nope!
13:17:08 <cjeris> they have a very fun song '3,14'... about pi.  it's more EBM/synthpop than industrial though.
13:17:21 <allbery_b> @src Monad (>>)
13:17:22 <lambdabot> Source not found. It can only be attributed to human error.
13:17:28 <allbery_b> @src [] (>>)
13:17:29 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
13:31:44 <sjanssen> has anyone tried to Haskell-golf the FizzBuzz problem?
13:32:39 <SamB> I don't even know what that means!
13:32:50 <sjanssen> SamB: do you follow reddit?
13:33:00 <SamB> not really
13:33:02 <sjanssen> http://programming.reddit.com/info/10cah/comments
13:33:04 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding (reddit.com)
13:33:09 <sjanssen> http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding
13:33:12 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding  Imran On Tech, http://tinyurl.com/2k83vg
13:33:13 <SamB> what about "haskell-golf"?
13:33:15 <malebria> Is TH much used in practice?
13:33:24 <malebria> I mean, is there a lot of haskell projects that use it?
13:33:27 <sjanssen> SamB: write the shortest possible program to achieve a task
13:33:30 <SamB> malebria: not a whole lot
13:33:32 <dons> malebria: not widely  used
13:33:33 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:33:40 <SamB> there are a few though
13:33:58 <SamB> probably the most significant one is HOC
13:34:09 <malebria> I'm reading the page but I can't think of a situation where I should use it.
13:34:29 <sjanssen> SamB: in short, the problem is to print out the integers starting with 1.  However, when a number is divisible by 3, print "Buzz", divisible by 5 and print "Fizz", if divisible by both print "FizzBuzz"
13:34:47 <SamB> malebria: last resort when you are trying to get your code to be less repetetive?
13:35:13 <malebria> Is it similar to lisp macros?
13:36:55 <dons> yeah
13:37:04 <dons> mostly used for code generation tricks
13:37:19 <dons> but you can avoid most lisp macro issues with higher order functoins, laziness and SYB/generics
13:37:33 <resiak> @hoogle (&&&)
13:37:35 <lambdabot> Did you mean: (&&&)
13:37:35 <lambdabot> Prelude.undefined :: a
13:37:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:37:36 <malebria> hum...
13:37:46 <resiak> How can I ask lambdabot where (&&&) is?
13:37:47 <nornagon> uh.
13:38:03 <dons> @hoogle &&&
13:38:04 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
13:38:04 <nornagon> ?index (&&&)
13:38:05 <lambdabot> Control.Arrow
13:38:09 <resiak> Hrm, I see!
13:38:15 <dons> its a known bug
13:38:24 <resiak> okay, it's not just me being stupid, then :)
13:38:24 <dons> (in hoogle, not lambdabot!)
13:38:38 <int-e> > zipWith (\x y -> if null x then y else x) (zipWith (++) (cycle . lines $ "\n\nFizz") (cycle . lines $ "\n\n\n\nBuzz")) (map show [1..100])
13:38:40 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
13:39:12 <int-e> well, that's wrong still :)
13:39:14 <malebria> @type (***)
13:39:17 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:39:57 <malebria> There're just so many things to learn in haskell.
13:40:04 <xerox> What's that int-e?
13:40:16 <xerox> malebria: that's part of the design.
13:41:40 <int-e> no, actually that was correct. it was an attempt at sjanssen's suggestion
13:43:01 <xerox> aha
13:44:49 <dons> kolmodin: where's 'refragment' ?
13:44:54 <dons> its not in the QC.hs file?
13:44:58 <dons> @seen kolmodin
13:44:58 <lambdabot> kolmodin is in #darcs, #gentoo-haskell, #haskell.hac07 and #haskell. I don't know when kolmodin last spoke.
13:45:09 <dons> ?users
13:45:10 <lambdabot> Maximum users seen in #haskell: 322, currently: 306 (95.0%), active: 18 (5.9%)
13:46:16 <kolmodin> dons: it's in tests/QC.hs
13:46:30 <Botje> > map (\x -> if x`gcd`15 > 1 then (if x`div`3 > 0 then "" else "Fizz")++(if x`div`5 > 0 then "" else "Buzz") else show x) [1..100
13:46:31 <lambdabot>  Parse error
13:46:33 <Botje> > map (\x -> if x`gcd`15 > 1 then (if x`div`3 > 0 then "" else "Fizz")++(if x`div`5 > 0 then "" else "Buzz") else show x) [1..100]
13:46:36 <lambdabot>  ["1","2","Buzz","4","","","7","8","","","11","","13","14","","16","17","","1...
13:46:39 <dons> kolmodin: hmm. not in my src..
13:46:43 <dons> i wonder what's going on
13:46:44 <vincenz> Botje: read that, hmm?
13:46:57 <Botje> read what? :)
13:47:01 <kolmodin> dons: line 69 ?
13:47:18 <vincenz> Botje: buzz
13:47:20 <dons> checking against the main repo
13:47:31 <kolmodin> dons: http://darcs.haskell.org/binary/tests/QC.hs
13:47:32 <kolmodin> it's there
13:47:37 <Botje> I read the article, yes
13:47:56 <koe> how do i parse something without case sensitivity with Parsec?
13:48:04 <kolmodin> dons: it should probably splitAt instead of drop and take, but yeah yeah
13:48:11 <sjanssen> http://programming.reddit.com/info/10d7w/comments/c10g19 -- my shortest/most obfuscated FizzBuzz
13:48:13 <lambdabot> Title: FizzBuzz spoilers (reddit.com)
13:48:24 <kolmodin> koe: map toUpper input   :D
13:48:30 <koe> not an option
13:48:35 <kolmodin> ah, ok
13:49:17 <kolmodin> koe: don't know any obvious way
13:49:22 <Syzygy-> > toUpper '3'
13:49:23 <lambdabot>  '3'
13:49:27 <Syzygy-> Good.
13:49:41 <Botje> > map (\x -> if x`gcd`15 > 1 then (if x`mod`3 > 0 then "" else "Fizz")++(if x`mod`5 > 0 then "" else "Buzz") else show x) [1..100] -- duh
13:49:43 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
13:50:03 <kolmodin> dons: found it?
13:51:01 <vincenz> Botje: it'd be cooler if you'd say "that doesn't type"
13:51:02 <vincenz> :D
13:51:10 <Botje> bleh :p
13:52:08 <Botje> how do you print a newline? gah :)
13:52:25 <allbery_b> putStrLn ""
13:52:30 <allbery_b> or putStr "\n"
13:52:33 <koe> '\n'
13:52:35 <allbery_b> or putChar '\n'
13:52:39 <kolmodin> dons: do you have the patch Sat Jan 20 11:35:27 GMT 2007  Lennart Kolmodin <kolmodin@dtek.chalmers.se> * Refragment lazy bytestring's chunks in testing
13:52:43 <kolmodin> ?
13:52:59 <dons> kolmodin: i'm sure it'll turn up, i probably just accidentally unrecorded
13:53:10 <kolmodin> oh
13:53:37 <dons> i'm still pulling al the patches though, in a new repo
13:53:37 <Botje> mapM (\x -> if x`gcd`15 == 1 then print x else (when (x`mod`3==0) $ putStr "Fizz") >> (when (x`mod`5==0) $ putStr "Buzz") >> putChar '\n') [1..100]
13:53:45 <Botje> it's still too long though :P
13:54:30 <int-e> I feel dirty for using (cycle . lines $ "\n\nFizz")
13:56:29 <int-e> testing x`gcd`15 is nice.
13:56:34 <Botje> mapM (\x -> (when (x`mod`3==0) $ putStr "Fizz") >> (when (x`mod`5==0) $ putStr "Buzz") >> (putStrLn $ if x`gcd`15==1 then show x else "")) [1..100]
13:56:43 <Botje> that's the last one
13:56:49 <Botje> I don't see how to improve it further :/
13:57:05 <int-e> Botje: why not:  when (x`gcd`15 == 1) (print x) ?
13:57:20 <int-e> ah, because of the newline.
13:57:21 <beschmi> >  [concat $ ["Fizz" | k`mod` 3==0]++["Buzz" | k`mod` 5==0]++[show k| k `gcd` 15 == 1] | k<-[1..100]]
13:57:23 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
13:57:28 <dons> sjanssen: see JaffaCake's recommendation:
13:57:30 <dons> "I guess you could use nullByteArr# = (unsafeCoerce# True) - that shouldn't
13:57:30 <dons> cause anything to go horribly wrong if you don't do any operations on it."
13:57:47 <Botje> beschmi: woah :)
13:59:41 <int-e> beschmi: thanks.
14:00:02 <Botje> > concat [["Fizz" | k`mod` 3==0], ["Buzz" | k`mod` 5==0], [show k| k `gcd` 15 == 1]] | k<-[1..100]]
14:00:04 <lambdabot>  Parse error
14:00:08 <int-e> beschmi: the [foo | condition] trick is a useful one :)
14:00:11 <Botje> [> concat [["Fizz" | k`mod` 3==0], ["Buzz" | k`mod` 5==0], [show k| k `gcd` 15 == 1]] | k<-[1..100]]
14:00:15 <Botje> oh feh
14:00:18 <Botje> I suck at haskell golf
14:00:26 <Botje> i'll just go back to perl golf, which I don't suck so badly at.
14:00:39 <glguy> if at first you don't succeed
14:00:44 <glguy> play a different game!
14:01:50 <beschmi> int-e: had to stare all day at isabelle code where that is used ;)
14:04:29 <bd_> Botje: Char is not an instance of Num :)
14:05:00 <bd_> wait, that's not what you're doing
14:08:00 <AStorm> Hullo. Are there any nice Haskell sound libraries available? (bindings, being portable outside Linux is a plus)
14:08:17 <kolmodin> good night!
14:09:06 <dons> AStorm: the sound libs are listed on haskell.org's libraries page for 'sound and music'
14:09:09 <dons> there's some available
14:09:30 <bos> AStorm: OpenAL comes with GHC
14:09:33 <AStorm> Any recommendation? (that's what I was mainly asking about)
14:09:38 <AStorm> Hmm... nice :-)
14:12:51 <glguy> http://hpaste.org/77 -- I encourage anyone to tell me why this didn't work
14:12:53 <bos> the thing that is bundled with GHC always beats the thing that is not. unless it doesn't.
14:13:17 <AStorm> bos, ;-)
14:13:21 <bd_> in which case, wait for the next version of GHC ;)
14:13:31 <fasta> dons: after I "change " something in a state monad I often forget to get the new state. I would like to have an expression s.t. when referred to it, it finds the new value of the state. Is there some "easy"(< 2 hours of work) solution for that?
14:13:58 <AStorm> glguy, simple, you're serialising in the second variant.
14:14:01 <bd_> fasta: You can't have an expression whose value will change, that would break referential transparency
14:14:11 <bd_> fasta: you might be interested in the modify function however:
14:14:13 <bd_> :t modify
14:14:15 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
14:14:22 <fasta> bd_: I am familiar with the state monad.
14:14:29 <musasabi> what was the function like: (a -> a) -> a -> [a] ?
14:14:30 <fasta> I need a global program transformation.
14:14:40 <AStorm> glguy, until the runReaderT finishes, it won't return
14:14:51 <int-e> [f $ gcd n 15 | n <- [1..100], let f 1 = show n; f 3 = "Fizz"; f 5 = "Buzz"; f 15 = "FizzBuzz"]
14:14:51 <musasabi> i.e. with foo (+ 1) 0 = [1,2,3,4,5,...
14:15:10 <xerox> musasabi: iterate
14:15:13 <bd_> fasta: if you have an expression e, its value will be fixed, unless it is forced in the monad (and that would just be 'get').
14:15:29 <bd_> fasta: The usual solution is to build higher-level combinators, and avoid using get and put firstly
14:15:32 <bd_> directly*
14:15:35 <xerox> ?hoogle (a -> a) -> a -> [a]
14:15:36 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
14:15:36 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:15:36 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:15:38 <koe> musasabi: iterate - hoogle will show you
14:15:42 <koe> gah
14:17:01 <malebria> And about arrows, are they being widely used?
14:17:05 <fasta> bd_: And how does that solve this problem?
14:17:12 <SamB> malebria: much more than TH
14:17:35 <bd_> fasta: Well, if your combinators use get and put properly, then the real bulk of your code can happily ignore the whole problem of re-getting the state :)
14:17:51 <malebria> SamB: Do you think that they're always prefered instead of monads?
14:17:58 <SamB> of course not
14:18:05 <SamB> sometimes they get unwieldy
14:18:10 <Philippa> the do notation's normally nicer if something's ArrowApply
14:18:27 <fasta> bd_: can you give a trivial example with a data type definition used for the state that uses this technique, since I would be _very_ surprised if you could make it work.
14:18:41 <bd_> fasta: it's not a data type definition, it's the other direction entirely
14:18:42 <bd_> something like:
14:18:51 <bd_> foo = modify $ alterStateInSomeWay
14:19:01 <bd_> isFoo = get >>= return . checkIfStateIsFooish
14:19:13 <bd_> do { x <- isFoo; foo; y <- isFoo; ... }
14:19:28 <bd_> to go into more detail would require more information on how you're using this state monad
14:19:36 <int-e> > [case gcd n 15 of 1 -> show n; 3 -> "Fizz"; 5 -> "Buzz"; _ -> "FizzBuzz" | n <- [1..100]] -- last one
14:19:37 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
14:19:37 <fasta> bd_: I was telling you already.
14:19:44 <malebria> Is there a general rule for when to use monads and when to use arrows?
14:19:50 <fasta> bd_: I have a special data type for holding my state.
14:20:12 <fasta> bd_: You may assume it's called Foo and has one member bar.
14:20:22 <bd_> fasta: Without knowing more about this data type there's no way to many useful combinators for it.
14:20:26 <bd_> make any*
14:20:28 <fasta> bd_: bar gets updated in a function called frob
14:20:38 <AStorm> malebria, most of the time you don't need arrows.
14:20:47 <bd_> okay, fine: frob = modify $ \s -> s { bar = 42 }
14:20:54 <AStorm> Monads are best used for keeping state, arrows for stateful computation.
14:20:54 <bd_> satisfys the problem description :)
14:21:02 <malebria> AStorm: what's the motivation for using them?
14:21:03 <bd_> but seriously though
14:21:06 <fasta> bd_: I already said I was familiar with the state monad.
14:21:13 <fasta> bd_: You are not solving the problem.
14:21:15 <bd_> fasta: You're asking for something impossible.
14:21:19 <beschmi> int-e: that one is nice, perhaps you could even get <80 chars ;)
14:21:21 <fasta> bd_: No, I am not.
14:21:26 <AStorm> malebria, arrows are more general. If you have to ask, you don't need them :-)
14:21:31 <fasta> bd_: it can be achieved with TH
14:21:33 <bd_> You CANNOT have an expression which will evaluate to different values. That violates referential transparency.
14:21:39 <bd_> Oh dear.
14:22:01 <bd_> I can't comment much on TH, then :/
14:22:01 <AStorm> bd_, yes you can. That's a monad :P
14:22:32 <int-e> beschmi: without the superfluous spaces it is under 80 characters
14:22:37 <malebria> AStorm: but I won't know I need them until I know about them. And I will only know about them if I use them for a while.. =(
14:22:39 <fasta> bd_: And FYI, "referential transparancy" can make the code less clear in some cases.
14:22:41 <bd_> AStorm: Monads aren't expressions, and they are in fact pure :)
14:22:56 <fasta> They are not expressions?
14:22:58 <fasta> That would be new
14:23:02 <bd_> Monads are types.
14:23:09 <bd_> Partially applied types at that :)
14:23:17 <int-e> beschmi: but of course the main = mapM_ print  is still missing.
14:23:27 <fasta> A monad is a natural transformation with two endofunctors, IIRC.
14:23:28 <AStorm> bd_, hmm. I wonder if just marking some things as mutables would be nicer (it would convert them to monads, but w/o the nasty special syntax)
14:23:29 <Philippa> malebria: the best time to use arrows is when you *can't* use a monad - either because it's outright impossible or being a monad or arrowapply kills off a potential analysis you want
14:23:39 <bd_> IO is a monad; IO Int is an action/value/spacesuit/what-have-you in that monad
14:23:46 <SamB> bd_: no, a monad is a function from sets to sets and some functions that go with it...
14:23:53 <AStorm> bd_, yes
14:23:55 <bd_> AStorm: Well, how will you define order of operations then??
14:23:57 <AStorm> and no
14:23:59 <beschmi> int-e: yeah i'm trying with putStrLn$unlines
14:24:05 <Philippa> SamB: no, the category theory says nothing about sets...
14:24:09 <malebria> Philippa: hum..
14:24:12 <Philippa> (except insofar as sets form a category)
14:24:12 <SamB> okay.
14:24:12 <malebria> ok, thanks, guys.
14:24:15 <SamB> whatever
14:24:17 <malebria> I'll read a little bit more.
14:24:21 <AStorm> bd_, reading from a mutable would be just below parens
14:24:35 <SamB> Philippa: so you call them?
14:24:40 <AStorm> writing would be lower than almost anything.
14:24:51 <AStorm> Operators: := for writing
14:24:59 <AStorm> (instead of <- )
14:25:08 <syntaxfree> ":" is reserved for data constructors.
14:25:14 <bd_> AStorm: I mean order as in: f g = foo bar (readValue g) g ; foo bar v g = (writeValue g) `seq` (b, v, g)
14:25:17 <AStorm> :/
14:25:17 <chessguy_work> you're going to have another evil syntax like do
14:25:21 <Philippa> SamB: I tend to take a straight reading of the category theory and bear in mind I'm working with Hask or something similar as the underlying category
14:25:30 <syntaxfree> @google do notation considered harmful
14:25:34 <AStorm> bd_, depends :>
14:25:35 <lambdabot> http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/
14:25:36 <lambdabot> Title: Do-notation considered harmful  Data.Syntaxfree
14:25:38 <syntaxfree> ;)
14:25:40 <Philippa> so functor, not function. And it happens that it's always an endofunctor
14:25:40 <bd_> AStorm: sounds confusing :)
14:25:42 <SamB> Philippa: unfortunately I do not have a book about CT
14:25:51 <bd_> AStorm: Side-effects interact with laziness in .... interesting ways
14:25:57 <Philippa> SamB: look up functor and natural transformation on wikipedia, go from there
14:25:58 <syntaxfree> SamB: I have Asperti & Longo in PDF.
14:26:02 <syntaxfree> I can email it to you if you want to.
14:26:08 <Philippa> you don't need anything deep to deal with monads
14:26:12 <AStorm> No side effects :> It's still a monad, just you don't see it that directly.
14:26:15 <SamB> sure
14:26:22 <bd_> AStorm: How will the syntax work, then? :)
14:26:26 <SamB> syntaxfree: I don't suppose you know my email address?
14:26:42 <syntaxfree> Not supposing that is a good supposition, my friend.
14:26:44 <AStorm> Sample (with := operator, which isn't possible right now, with do notation)
14:26:54 <SamB> naesten at gmail dot com
14:27:16 <chessguy> oooh, another free email address to add to my spambot. muahhahaa
14:28:11 <AStorm> bd_, I just noticed it isn't necessary.
14:28:18 <bd_> AStorm: :) STRef?
14:28:23 <AStorm> Just make defining new types of monads easier.
14:28:30 <syntaxfree> I'm enclosing Freyd's as well.
14:28:37 <syntaxfree> Freyd is much harder to understand, though.
14:29:24 <bd_> AStorm: Actually making monads isn't that hard, if you can piece them out of existing transformers. Just do something like newtype FooT m a = FooT (StateT FooState m a) deriving (Monad, MonadPlus, Functor), and define any lifting functions you want
14:29:24 <int-e> beschmi:  mapM putStrLn  is shorter.
14:29:45 <bd_> AStorm: of course if you're trying to do something truly complex you may need to define your own combinators
14:30:09 <AStorm> That is what I don't like about Haskell: -~^...| operators :P
14:30:31 <AStorm> these make things unreadable. Yes, I know any function can be an operator.
14:30:36 <koe> better than perl in that respect, where they're *everywhere*
14:30:41 <bd_> ... I've never seen a ~ operator in haskell >.>
14:30:48 <dylan> > let
14:30:49 <lambdabot>  Parse error
14:30:49 <dylan> err
14:30:54 <AStorm> What about monadic operators? E.g. instead of modify?
14:30:55 <bd_> and - ^ are normal mathematical operators :)
14:31:00 <bd_> AStorm: hm?
14:31:06 <AStorm> bd_, that was a single operator :>
14:31:11 <dylan> > let (~) a b = a ++ b in "foo" ~ "bar"
14:31:12 <lambdabot>  Parse error
14:31:14 <bd_> AStorm: oh, don't do that :)
14:31:34 <syntaxfree> > let a ~ b = a ++ b in [2,3,4]~[5,6,7]
14:31:35 <lambdabot>   Pattern syntax in expression context: ~[5, 6, 7]
14:31:42 <AStorm> I'd also like to do some type casts in more automatic ways.
14:31:47 <dgriffi3> ?pl \x y -> (x * x) + (y * y)
14:31:48 <AStorm> syntaxfree, hmm, ~ is taken
14:31:48 <lambdabot> (. join (*)) . (+) . join (*)
14:31:52 <syntaxfree> automatic type casting is evil.
14:31:56 <syntaxfree> @type (~)
14:31:57 <lambdabot> parse error on input `)'
14:32:00 <AStorm> syntaxfree, not automatic
14:32:07 <AStorm> Explicit, but with a nice operator.
14:32:10 <koe> =~ and =~~ in Text.Regex.Posix
14:32:12 <bd_> > let ~(x, y) = undefined in "Lazy matching :)"
14:32:14 <lambdabot>  "Lazy matching :)"
14:32:18 <chessguy> let (~~) a b = a ++ b in "foo" ~ "bar"
14:32:23 <AStorm> Not that I have to write a truckload of functions
14:32:24 <chessguy> > let (~~) a b = a ++ b in "foo" ~ "bar"
14:32:24 <bd_> AStorm: What conversions? We have fromIntegral and etc...
14:32:26 <lambdabot>   Pattern syntax in expression context: ~"bar"
14:32:26 <syntaxfree> ahhh., yes.
14:32:30 <AStorm> bd_, yes, those
14:32:43 <AStorm> E.g. x :> Integral
14:32:48 <syntaxfree> the operator namespace sure is crowded.
14:32:50 <AStorm> (yes, : is taken)
14:32:54 <syntaxfree> :>  is a data constructor!
14:32:55 <chessguy> > let (~!) a b = a ++ b in "foo" ~ "bar"
14:32:56 <lambdabot>   Pattern syntax in expression context: ~"bar"
14:33:04 <AStorm> syntaxfree, I know that.
14:33:07 <chessguy> > let (~!) a b = a ++ b in "foo" `~!` "bar"
14:33:08 <lambdabot>  Parse error
14:33:14 <AStorm> Maybe x -> Integral or something
14:33:25 <syntaxfree> > let (<+!+>) a b = a ++ b in "foo" <+!+> "bar"
14:33:26 <lambdabot>  "foobar"
14:33:27 <AStorm> Not some fromIntegral x with a long name
14:33:36 <chessguy> lol
14:33:40 <bd_> AStorm: There's only one per class of things we might want to convert. I mean, the reason fromIntegral doesn't come from float is fromIntegral is supposed to be an information-preserving transformation. From Float, truncate is what you want.
14:33:49 <AStorm> fromIHateMyLifeIHateMyLife :/
14:33:49 <bd_> since then you're saying what to do with the excess data
14:33:52 <syntaxfree> @quote operator
14:33:53 <lambdabot> nmessenger says: (>:[) -- < vampire operator
14:34:22 <syntaxfree> @quote operator
14:34:23 <lambdabot> nmessenger says: (>:[) -- < vampire operator
14:34:25 <AStorm> bd_, Something like: a -> b
14:34:25 <chessguy> shouldn't that be (]:<)
14:34:30 <syntaxfree> @quote cast
14:34:30 <lambdabot> Binkley says: is it because of your mother that you added an integer to a pointer without a cast?
14:34:31 <bd_> AStorm: That's... impossible.
14:34:38 <syntaxfree> hahaha
14:34:39 <bd_> AStorm: In any language :)
14:34:46 <syntaxfree> @quote cast
14:34:46 <lambdabot> Binkley says: is it because of your mother that you added an integer to a pointer without a cast?
14:34:50 <bd_> Well, impossible to do in a meaningful way
14:34:53 <AStorm> bd_, yes, it is possible. Just reserve a name, like that fromXYZZY convention
14:35:01 <syntaxfree> man, one of these days they're gonna start putting a @quote quota on me.
14:35:09 <bd_> What would it mean to do (a -> b) where a :: (b -> (c, k -> (n, [y]))) and b :: Int ?
14:35:10 <AStorm> And make x -> Integral call it. Yes, syntactic sugar.
14:35:12 <chessguy> @quote quota
14:35:13 <lambdabot> blackdog says: wow, i'm cranky _and_ quotable!
14:35:22 <AStorm> bd_, not at all.
14:35:34 <AStorm> @quote quote
14:35:34 <lambdabot> lambdabot says: @quote lambdabot
14:35:37 <bd_> AStorm: not at all? The type you gave is satisfied by that :)
14:35:38 <syntaxfree> isn't (->) a reserved type constructor?
14:35:49 <AStorm> bd_, not necessarily - runtime error
14:35:52 <AStorm> :>
14:35:53 <fasta> @quote @quote
14:35:54 <lambdabot> delicious-malicious-test says: @quote dmt
14:36:00 <fasta> heh
14:36:04 <glguy> :k (->)
14:36:06 <lambdabot> ?? -> ? -> *
14:36:12 <bd_> AStorm: how would you add things to it then? The definition of a -> b would be fixed in the runtime, and be a horrible horrible hack at that
14:36:25 <bd_> [it'd need to be manually specialized to every combination of things you'd ever want to convert]
14:36:26 <JuanMarcus> how can i make a thread not block everything when is waiting for data on a socket?
14:36:31 <syntaxfree> :k =>
14:36:32 <lambdabot> parse error on input `=>'
14:36:37 <AStorm> bd_, not really everything
14:36:44 <syntaxfree> > let (=>) a b = a + b  in 2 => 2
14:36:45 <lambdabot>  Parse error
14:36:45 <bd_> JuanMarcus: It shouldn't block other threads.
14:36:46 <koe> :k <-
14:36:48 <lambdabot> parse error on input `<-'
14:36:55 <koe> :k (<-)
14:36:57 <syntaxfree> > let (==>) a b = a + b in 2 ==> 2
14:36:57 <lambdabot> parse error on input `<-'
14:36:58 <lambdabot>  4
14:37:01 <syntaxfree> yay!
14:37:01 <JuanMarcus> bd_: it does
14:37:01 <AStorm> But of course, most things. Other than that, give me macros :P
14:37:15 <syntaxfree> (<===) and (==>) and (=======>) sure are pretty operators.
14:37:15 <bd_> JuanMarcus: What haskell compiler/interpreter are you using?
14:37:17 <chessguy> hmmm, this reminds me of a mock discussion of a 'proof' of P=NP or something that i read once, except without the stupidity
14:37:19 <sjanssen> JuanMarcus: bd_ is correct, you must have something else going on
14:37:23 <JuanMarcus> bd_: ghc
14:37:36 <bd_> JuanMarcus: Which version? Are you using foreign calls?
14:37:42 <AStorm> So I can define x _> SomeName as the type conversion operator calling fromSomeName x
14:37:42 <JuanMarcus> bd_: no
14:37:45 <JuanMarcus> last version
14:37:51 <JuanMarcus> bd_: last version
14:38:05 <bd_> AStorm: there /is/ an unsafeCoerce#, if you really want an (a -> b) ... >.>
14:38:09 <bd_> !paste
14:38:10 <hpaste> Haskell paste bin: http://hpaste.org/
14:38:19 <bd_> JuanMarcus: Please paste an example of the failing code there
14:38:26 <AStorm> bd_, I was thinking about syntactic sugar, nothing more
14:38:31 <AStorm> Not that stupidity :>
14:38:37 <bd_> AStorm: ;)
14:38:54 <JuanMarcus> bd_: where? here?
14:39:00 <bd_> AStorm: in any case, the haskell type system doesn't allow a -> b, but with MPTCs you could have a class Castable a b where cast :: a -> b
14:39:03 <bd_> JuanMarcus: http://hpaste.org/
14:39:08 <koe> a java boss would hate me. 50 lines of haskell in 3 hours.
14:39:28 <JuanMarcus> bd_: hang on
14:39:39 <syntaxfree> I don't think code density is the same in Java and Haskell
14:39:45 <syntaxfree> Java's syntax is much more verbose.
14:39:55 <koe> the boss doesn't know or care
14:39:56 <syntaxfree> sp. if you don't annotate all types explicitly in your haskell code.
14:39:58 <AStorm> bd_, yes, yes YES. But I wouldn't want to write that myself for all basic types
14:40:29 <JuanMarcus> bd_: before i do that, i'm using recvFrom to receive UDP
14:40:32 <AStorm> And instead of cast, some shorter operator
14:41:00 <syntaxfree> koe: I think you might be misunderestimating your Java boss.
14:41:06 <AStorm> Which would work on various types (yes, like an *hack* overloaded function)
14:41:09 <bos> dons: i hacked on jeremy's ByteStringParser that you pointed me at, and my hacked-up parser is 2.5x faster than the one using Parsec.
14:41:13 <bd_> AStorm: How does it know what to cast to, if you're using this overloaded cast a lot?
14:41:14 <koe> i don't have a java boss. thank god.
14:41:16 <AStorm> (but instead just taking the other type as a parameter)
14:41:17 * syntaxfree knows misunderestimate is not a word. Please.
14:41:24 <bd_> AStorm: even fromIntegral is ambiguous often
14:41:25 <AStorm> bd_, it's explicit
14:41:31 <Excedrin> koe: that's like 3000 lines of Java! insanely productive!
14:41:37 <bd_> AStorm: The type you're casting to is explicit?
14:41:38 <syntaxfree> have you ever had a Java boss?
14:41:49 <AStorm> bd_, might be, e.g. x _> Int32
14:41:49 * Nafai has a Java boss
14:41:57 <koe> yes, once. i'll never do it again if i have a choice to live otherwise
14:42:01 <bd_> AStorm: hmm
14:42:06 <bd_> interesting idea
14:42:17 <syntaxfree> Nafai: can the Java boss grok that Haskell code tends to do more with less LOCs?
14:42:22 <bd_> would require TH though I guess
14:42:34 <AStorm> Yes, most likely.
14:42:58 <glguy> fewer LOC? so you aren't working as hard?
14:42:59 <Nafai> syntaxfree: This guy?  I doubt it.  It's pretty smart, but I think he would dismiss something like Haskell
14:43:07 <glguy> boss' like hard work!
14:43:26 <SamB> glguy: I thought they liked productivity
14:43:31 <AStorm> glguy, the nicest way to work around it is writing in Java and Haskell
14:43:44 <AStorm> Then appending some Lorem Ipsum to the equivalent Haskell code
14:43:47 <SamB> if they like hard work, they should throw out the computers and do everything by hand
14:43:48 <bd_> Sounds like a job for literate haskell :)
14:43:56 <dibblego> the best way to satisfy the Java boss is to get Haskell to compile to the JVM
14:43:56 <syntaxfree> Nafai: he might not want Haskell used in your organization, because manpower will be more expensive, etc. etc. But he sure can grok that one language can in n lines the same thing that another language takes 6n lines to do.
14:44:01 <AStorm> Yes, lhs :D
14:44:12 <fasta> SamB: would be good for up-time.
14:44:24 <AStorm> syntaxfree, 6n? You mean like 2^n
14:44:27 <SamB> fasta: wouldn't that be bad for uptime?
14:44:27 <bos> bosses like their employees to be able to work with each other. it's funny.
14:44:29 <dibblego> in the meantime, I am sticking with Scala
14:44:33 <SamB> because people need to sleep.
14:44:34 <Nafai> syntaxfree: He does; that's actually one of the reasons why we are seriously starting to use Jython for some of our development
14:44:38 <AStorm> Scala is nice, yes.
14:44:52 <syntaxfree> Nsfai: ergo, Java bosses aren't complete idiots.
14:45:05 <syntaxfree> is Scala pure?
14:45:08 <dibblego> no
14:45:16 <fasta> SamB: I was thinking of a redundant cluster.
14:45:19 <syntaxfree> does Scala have monsdic I/O?
14:45:29 <dibblego> no
14:45:31 <hpaste>  JuanMarcus pasted "Socket Thread Blocking" at http://hpaste.org/79
14:45:36 <JuanMarcus> cool
14:45:38 <syntaxfree> :(
14:45:56 <hpaste> English please
14:45:59 <AStorm> syntaxfree, but it's FP still
14:46:04 <Nafai> syntaxfree: Nope.  This guy is suprisingly clueful even though I don't always agree with the technology choices
14:46:05 <syntaxfree> JuanMarcus: are you a brazilian?
14:46:11 <dibblego> I think you'd be able to do monadic I/O though - I'm still not entirely familiar with the type system
14:46:12 <JuanMarcus> yep
14:46:21 <syntaxfree> yay! support #haskell.br
14:46:31 <syntaxfree> we have another #haskell.br denizen, maskd.
14:46:42 <syntaxfree> lambdabot also hangs in there sometimes.
14:46:43 <AStorm> Hmm, no #haskell.pl yet...
14:46:46 <syntaxfree> I wish he always did.
14:47:07 <chessguy> a #haskell channel for perl interpreters? :)
14:47:10 <SamB> who has admin?
14:47:11 <syntaxfree> @tell dons hey, could you add #haskell.br to lambdabot's autojoin list?
14:47:12 <lambdabot> Consider it noted.
14:47:13 <AStorm> No, PL
14:47:22 <AStorm> As in Poland.
14:47:32 <AStorm> #pugs is for perl interpreters
14:47:35 <chessguy> i thought that got annexed by russia or something
14:47:44 <JuanMarcus> bd_: what do you think?
14:47:55 <AStorm> #perl6 actually, or #perl. Or anyway :P
14:48:10 <Excedrin> CAL is nice
14:48:19 <koe> @h toUpper
14:48:20 <lambdabot> Maybe you meant: help hitchcock hoogle hoogle+ . v
14:48:25 <koe> @hoogle toUpper
14:48:26 <lambdabot> Char.toUpper :: Char -> Char
14:48:31 <syntaxfree> @hitchcoc
14:48:37 <syntaxfree> @hitchcock
14:48:40 <koe> @hitchcock foo
14:48:42 <lambdabot> No match for "foo".
14:48:48 <sjanssen> JuanMarcus: the escreve thread can't run until recebe reads some input from the socket
14:48:48 <syntaxfree> @help hitchcock
14:48:48 <lambdabot> I perform dictionary lookups via the following 13 commands:
14:48:49 <lambdabot> all-dicts ... Query all databases on dict.org
14:48:49 <lambdabot> devils ...... The Devil's Dictionary
14:48:49 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
14:48:49 <lambdabot> elements .... Elements database
14:48:50 <lambdabot> [9 @more lines]
14:48:55 <syntaxfree> @hitchcock death
14:48:56 <lambdabot> No match for "death".
14:49:01 <syntaxfree> @hitchcock murder
14:49:02 <lambdabot> No match for "murder".
14:49:11 <syntaxfree> @easton jesus
14:49:12 <lambdabot> *** "Jesus" easton "Easton's 1897 Bible Dictionary"
14:49:13 <lambdabot> Jesus
14:49:13 <lambdabot>    (1.) Joshua, the son of Nun (Acts 7:45; Heb. 4:8; R.V.,
14:49:13 <lambdabot>    "Joshua").
14:49:13 <lambdabot>  
14:49:13 <chessguy> syntaxfree, "via the following 13 commands"
14:49:14 <lambdabot> [61 @more lines]
14:49:38 <bd_> JuanMarcus: uh, your escreveMensagens thread blocks on chan, the recebeMensagens thread reads from the socket and writes to the chan
14:49:39 <JuanMarcus> sjanssen: i don't want that to happen...
14:49:40 <sjanssen> JuanMarcus: because escreve waits on a Chan that recebe must write to
14:50:21 <JuanMarcus> recebe writes to the chan...
14:50:23 <Excedrin> is Scala lazy?
14:50:37 <JuanMarcus> the channel is not blocking, i've tested it alone
14:50:40 <fasta> I believe it has lazy constructs
14:50:46 <dibblego> it can be if you want, just like Java can
14:50:47 <sjanssen> JuanMarcus: recebe only writes after it has called "recvFrom sock 8"
14:50:47 <JuanMarcus> the socket is blocking
14:51:00 <Excedrin> I think I'll stick with CAL
14:51:03 <bd_> JuanMarcus: GHC can detect deadlocks in some cases
14:51:05 <sjanssen> JuanMarcus: if recvFrom never returns, the escreve never runs
14:51:13 <bos> you can use laziness in scala, it's a bit cumbersome, as in ML.
14:51:14 <bd_> JuanMarcus: YOur testing probably ran into one of the deadlock checks :)
14:51:29 <AStorm> http://scala.epfl.ch/
14:51:31 <chessguy> Scala? is that the ebonics version of Scalar?
14:51:31 <lambdabot> Title: The Scala Programming Language
14:51:36 <JuanMarcus> lol
14:51:43 <JuanMarcus> i'm a think a little
14:51:47 <dibblego> one important thing is that you can call existing Java APIs transparently, further fulfilling the requirements of Java Boss
14:51:57 <syntaxfree> @google charity language
14:51:58 <lambdabot> http://en.wikipedia.org/wiki/Charity_programming_language
14:52:17 <JuanMarcus> thanks for the help
14:54:01 <Excedrin> dibblego: that's the same in CAL
14:54:02 <dibblego> I once wrote a lazy list in Java when I was working on the IBM Java implementation and I got in trouble for not using an array - to read/tokenise/etc. a public/private key store
14:54:14 <dibblego> Excedrin, I've not looked at CAL
14:55:13 <Excedrin> you can also do things like iterate over a lazy CAL list with a java.util.Iterator (from java)
14:55:27 <dibblego> yeah I did that
14:55:34 <ray> syntaxfree: nice flog post! it's not 2006 though, in fact
14:55:52 <dibblego> same with java.io.InputStream to List[Byte]
14:56:06 <syntaxfree> flog?
14:56:17 <ray> flog=blog
14:56:19 <ray> in rayspeak
14:56:20 <syntaxfree> heh. I wasn't *that* mean, was I?
14:56:21 <JuanMarcus> i tried again with two threads: one that reads from the socket and one that writes chars to the screen
14:56:28 <JuanMarcus> no channels...
14:56:34 <JuanMarcus> the socket thread still blocks
14:56:46 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/24/python-is-soup-in-a-cup/
14:56:49 <lambdabot> Title: Python is soup-in-a-cup  Data.Syntaxfree, http://tinyurl.com/2qpwp2
14:56:56 <bakert> Is there a way to say this /without/ the \x?
14:56:57 <bakert> (either (s++) (\x -> s) r))
14:57:10 <bakert> basically if it is Right then just s
14:57:12 <ray> i didn't think it was that mean
14:57:13 <dibblego> bakert, \_ -> s
14:57:16 <mahogny> RPC for haskell anyone?
14:57:29 <dgriffi3> ?pl \(a,b,c) -> [a,b,c]
14:57:30 <lambdabot> (line 1, column 6):
14:57:30 <lambdabot> unexpected ","
14:57:30 <lambdabot> expecting letter or digit, operator or ")"
14:57:30 <lambdabot> ambiguous use of a non associative operator
14:57:31 <bakert> dibblego, i mean in less characters.  although yours is an improvement
14:57:54 <ctkrohn> syntaxfree: yeah I read that... I had a hard time seeing it as a troll article; I thought it was pretty interesting
14:58:17 <ctkrohn> syntaxfree: although I thought that certain Lisps were compiled and didn't need a runtime, but yet were still dynamically typed
14:58:21 <syntaxfree> It's not really a troll article. It's more of a "devil's advocate" article.
14:58:41 <syntaxfree> ctkrohn: well, I did mention "pseudocompilers".
15:00:04 <JuanMarcus> sjanssen: i tried again with two threads: one that reads from the socket and one that writes chars to the screen
15:00:09 <hpaste>  bd_ annotated "Socket Thread Blocking" with "recebeMensagens doesn't seem to block..." at http://hpaste.org/79#1
15:00:19 <ray> lisps and their runtimes tend to be very intertwined
15:00:27 <syntaxfree> precisely.
15:00:34 <bd_> JuanMarcus: Take a look at that example. Works here. I don't understand what you expect to be running independently from receiving packets...
15:00:36 <sjanssen> JuanMarcus: and the char writer thread didn't run?
15:00:48 <JuanMarcus> bd_: i'm try something clearer
15:00:51 <bd_> JuanMarcus: oh!
15:00:54 <syntaxfree> Lisp compiles to a executable file? So what? That's trivial if you attach an entire runtime to code.
15:01:00 <bd_> JuanMarcus: maybe it's line-buffering? hSetBuffering stdout NoBuffering
15:01:01 <JuanMarcus> bd_: i tried again with two threads: one that reads from the socket and one that writes chars to the screen
15:01:09 <ray> yeah
15:01:11 <syntaxfree> of course, most dynamic languages compile to simpler object code, but how is that different from vbrun300.dll?
15:01:11 <bd_> [from System.IO]
15:01:18 <JuanMarcus> bd_: hum
15:01:22 <ray> it's impractical because the binary has the whole runtime tacked on
15:01:22 <JuanMarcus> bd_: let me check that
15:01:29 <ray> so much better to just install the runtime
15:01:46 <syntaxfree> not always.
15:02:29 <ray> if you only have the one program it wouldn't make too much of a difference
15:02:45 <syntaxfree> that is true.
15:03:03 <syntaxfree> I figure that Haskell compiled programs also carry some of a runtime. But how much work does a runtime need to do?
15:03:11 <fasta> syntaxfree: Second, there are Haskell interpreters and compilers around that formal specification <- formal specification?
15:03:12 <syntaxfree> Haakell programs carry a small profiler and suchlike.
15:03:29 <syntaxfree> fasta: I don't remember the context. Let me find it.
15:03:44 <syntaxfree> ah, yes. = Haskell 98, the standard.
15:03:47 <syntaxfree> Haskel', soon.
15:04:03 <bd_> syntaxfree: in the case of GHC, all needed portions of the runtime are statically-linked in
15:04:16 <bd_> and the runtime does quite a lot ;)
15:04:19 <syntaxfree> bd_: yes. In the case of compiled lisps too.
15:04:24 <SamB> what is another name for '\n'?
15:04:28 <mbishop> newline
15:04:29 <ray> newline
15:04:36 <syntaxfree> \'0x10
15:04:39 <dons> > ord '\n'
15:04:40 <lambdabot>  10
15:04:40 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:04:41 <bos> crashed wheelbarrow.
15:04:46 * syntaxfree knew it by heart!
15:04:48 <SamB> what does Alex call it?
15:04:49 <syntaxfree> haha.
15:04:51 <koe> syntaxfree: no...
15:04:52 <fasta> syntaxfree: I would not call it a formal specification.
15:04:57 * syntaxfree has childhood memories.
15:05:00 <bd_> syntaxfree: I think GHC can discard the parts of the standard libraries you're not using at least :)
15:05:02 <koe> syntaxfree: 0x10 is hexidecimal for 16, not 10
15:05:08 <syntaxfree> :(
15:05:09 <syntaxfree> true!
15:05:10 <SamB> > '\x10'
15:05:12 <lambdabot>  '\DLE'
15:05:13 <syntaxfree> > 0xA
15:05:14 <lambdabot>  10
15:05:15 <fasta> syntaxfree: Anyway, I think you missed soft-typing.
15:05:16 <SamB> > '\n'
15:05:18 <lambdabot>  '\n'
15:05:24 <dons> fasta: the formal semantics are available from separate papers that describe each part, but there are gaps
15:05:36 <syntaxfree> fasta: I missed "strong" vs "weak" typing, yes.
15:05:45 <fasta> dons: Those papers are full of bugs.
15:05:53 <dons> there are formal semantics of Core in twelf
15:06:02 <fasta> dons: Oh, that's new for me.
15:06:19 <dons> also, there are Isabelle implementations of Core as well
15:06:25 <fasta> syntaxfree: no, soft-typing is something different.
15:06:35 <syntaxfree> well, I missed it too, yes.
15:07:00 <syntaxfree> If I was to discuss strong vs weak and suchlike, I'd have to end up discussing H-M in detail, and I just don't have enough knowledge for that yet.
15:07:20 <bos> hmm, interesting. my parser is spending all its time inside satisfy.
15:07:21 <syntaxfree> I don't even know if type classes are in H-M. I'm guessing not, because ML is supposed not to have'em.
15:07:25 <fasta> syntaxfree: also suggesting "just use TH" makes it sound like TH is easy to use.
15:07:40 <syntaxfree> Well, there's an AST you can manipulate.
15:07:43 <fasta> syntaxfree: TH is not easy to use (judging by the pain Bulat) encountered.
15:07:44 <dons> syntaxfree: are you ranting about things you're not familiar with again? ;)
15:07:51 <dons> TH isn't easy.
15:08:01 <dons> and suitable for some problems, but not widely used
15:08:05 <fasta> syntaxfree: I read the paper, and Bulat's stuff and played around with it.
15:08:07 <syntaxfree> I didn't say it was!
15:08:29 <syntaxfree> I just said Haskell separate concerns :)
15:08:34 <Philippa> TH isn't too hard /for that class of solution/. But that class of solution makes most people's heads explode
15:08:37 * syntaxfree laughs.
15:08:51 <fasta> Philippa: I agree it's not too hard.
15:09:05 <dons> type class hackery is harder
15:09:13 <dons> TH is just code generation, easy
15:09:20 <Philippa> syntaxfree: you can discuss strong-vs-weak without having to deal with anything to do with implicit or inferred types
15:09:28 <AStorm> Yes, type class hackery is hard.
15:09:33 <bakert> ?logs
15:09:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:09:35 <syntaxfree> Philippa: yes, but that'd break the flow of the essay.
15:09:37 <AStorm> TH is simple compared to that. Just like macros.
15:09:42 <bakert> ?where logs
15:09:43 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
15:09:44 <syntaxfree> I really optimize essays for flow.
15:09:52 <dons> instead of content?
15:09:55 <fasta> haha
15:10:04 <fasta> That gotta hurt.
15:10:07 <dons> sorry
15:10:09 <hpaste>  bos pasted "can anyone see a faster way?" at http://hpaste.org/80
15:10:14 <syntaxfree> ouch.
15:10:19 <dons> i've not had my coffee yet, and my head hurts
15:10:20 * syntaxfree laughs manically.
15:10:24 <syntaxfree> @spell manically
15:10:25 <lambdabot> manically
15:10:55 <LoganCapaldo> @spell manaically
15:10:57 <bd_> bos, since you're checking for a null bytestring, you can use the unsafeHead and unsafeTail family of functions from Data.ByteString.Base
15:10:57 <lambdabot> maniacally manically maniacal magically
15:11:11 <syntaxfree> @webster1913 maniac
15:11:11 <AStorm> bos, maybe also use guards instead of if/else
15:11:11 <lambdabot> Unknown command, try @list
15:11:13 <dons> bos, ah yes. bd_ makes a good point
15:11:16 <syntaxfree> @web
15:11:20 <AStorm> Would look nicer.
15:11:23 <hpaste>  JuanMarcus annotated "Socket Thread Blocking" with "(no title)" at http://hpaste.org/79#2
15:11:26 <bd_> bos, also it'd probably be faster to make a combinator which works over a longer string, and checks bounds ahead of time
15:11:28 <bos> bd_: thanks.
15:11:28 <syntaxfree> @webs
15:11:29 <lambdabot> Unknown command, try @list
15:11:36 <syntaxfree> @all-dict maniac
15:11:37 <lambdabot> *** "Maniac" gcide "The Collaborative International Dictionary of English v.0.48"
15:11:37 <lambdabot> Maniac \Ma"ni*ac\, a. [F. maniaque. See {Mania}.]
15:11:37 <lambdabot>    Raving with madness; raging with disordered intellect;
15:11:37 <lambdabot>    affected with mania; mad.
15:11:37 <lambdabot>    [1913 Webster]
15:11:39 <lambdabot> [22 @more lines]
15:11:40 <bakert> maniacally, syntaxfree, if you mean "mwahahaha"
15:11:42 <syntaxfree> @all-dict manic
15:11:43 <lambdabot> *** "Manic" gcide "The Collaborative International Dictionary of English v.0.48"
15:11:44 <lambdabot> Manic \Man"ic\, a. [Gr. maniko`s mad, frenzied.] (Med.)
15:11:45 <lambdabot>    Of or pert. to, or characterized by, mania, or excitement;
15:11:47 <lambdabot>    frenzied; as, with manic energy.
15:11:49 <lambdabot>    [Webster 1913 Suppl.]
15:11:51 <lambdabot> [27 @more lines]
15:11:52 <LoganCapaldo> I mean manically and manaically both fit
15:11:57 <AStorm> @all-dict manically
15:11:58 <lambdabot> No match for "manically".
15:12:05 <AStorm> @all-dict maniacally
15:12:06 <lambdabot> *** "Maniacally" gcide "The Collaborative International Dictionary of English v.0.48"
15:12:07 <lambdabot> Maniacal \Ma*ni"a*cal\, a.
15:12:07 <lambdabot>    Affected with, or characterized by, madness; maniac. --
15:12:07 <lambdabot>    {Ma*ni"a*cal*ly}, adv.
15:12:07 <lambdabot>    [1913 Webster]
15:12:08 <lambdabot> [5 @more lines]
15:12:16 <syntaxfree> Maniac is crazier than manic it seems.
15:12:17 <bd_> hmm, Juan doesn't seem ot be around here anymore :)
15:12:24 <bd_> nor did he apparently actually paste the code
15:12:28 <Philippa> syntaxfree: they mean different things
15:12:43 <syntaxfree> well, yes.
15:12:44 <fasta> Also, saying that Data.Dynamic gives you the same abilities as lets say Scheme is not true.
15:12:53 <dons> bos, oh, but you're using lazy bytestrings
15:12:55 <Philippa> and not just in magnitude
15:12:59 <dons> so there's no unsafeHead/Tail
15:13:03 <syntaxfree> Maniac seems to relate directly to mania, while manic is "similar to ", etc. etc.
15:13:12 <syntaxfree> at least that's what 1913 Webster seems to imply.
15:13:25 <bd_> oh, wasn't clear from the paste. You could deconstruct it, I suppose, though that might not be much faster
15:13:26 <Philippa> the 1913 Webster is rather out of date on current meanings
15:13:37 <AStorm> But this is not a current word :P
15:13:48 <AStorm> It's Shakespearean.
15:13:49 <syntaxfree> "Mania" is an outdated psychiatric category.
15:13:50 <Philippa> manic implies energy, excitement
15:14:00 <bd_> [are lazy bytestrings allowed to have an empty strict bytestring as one of their components?]
15:14:01 <Philippa> manic, however, is in current use
15:14:02 <AStorm> syntaxfree, not at all
15:14:14 <SamB> it means "enthusiast" ;-)
15:14:22 <SamB> oh, wait
15:14:24 <SamB> maniac does
15:14:26 * SamB can't see
15:14:34 <Philippa> and actually, no - hypomania is a current diagnosis, for example
15:14:39 <syntaxfree> anyway, I was laughing with energy and excitement, with a hint of craziness.
15:14:50 <AStorm> syntaxfree, so, manically
15:14:56 <bos> bd_: no empty strict ByteStrings inside lazy ones.
15:14:57 <hpaste>  glguy annotated "can anyone see a faster way?" with "this isn't faster, but it uses fewer lines :)" at http://hpaste.org/80#1
15:14:57 <AStorm> #haskell - putting the language in place
15:14:59 <bakert> manically seems right then
15:15:01 <bd_> bos, you could pass around seperately the strict bytestring chunk you're working on, and only grab another one from the lazy bytestring when you run out of data in that one
15:15:07 <bd_> then you can use unsafeHead etc
15:15:15 <SamB> maniacally would be if you do that "bwahahahaha" evil laugh thing
15:15:21 <bos> bd_: yeah
15:15:41 <bos> i'm using satisfy to build up matchers for strings right now; i should switch those to something faster.
15:15:48 <bd_> your parser functions could even be strict on the strict bytestring arg, for that extra ounce of performance :)
15:15:48 <hpaste>  dons annotated "can anyone see a faster way?" with "satisfy" at http://hpaste.org/80#2
15:16:00 <bringert> today's #haskell challenge: write mapM using only return, ap and normal list stuff
15:16:19 <bos> dons: i already tried INLINE, and it bought me 10%
15:16:21 <dons> bd_, yeah, we do that in the Get monad for the binary parser
15:16:31 <dons> pass around the current strict chunk
15:16:34 <bos> btw, this is still 2.5x faster than Parsec
15:16:40 <dons> before getting the next one off the lazy list
15:16:54 <bd_> bos: nice! I'll have to use it for my toy compiler once it's ready :)
15:17:23 <LoganCapaldo> @type mapM
15:17:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
15:17:27 <bos> bd_: credit to jeremy shaw for the base code.
15:17:27 <AStorm> bringert, why would that be hard?
15:17:38 <bd_> bos: based on parsec?
15:17:48 <bringert> AStorm: it's not that hard
15:17:52 <bos> bd_: only loosely. the API is gratuitously incompatible, and much smaller.
15:17:58 <bd_> ah
15:18:05 <bos> bd_: but i'm extending it
15:18:06 <bringert> oh, I forgot to say that it should be points-free and as short as possible
15:18:08 <bd_> it'd be nice to put a parsec-compatibility layer on top... :)
15:18:11 <LoganCapaldo> @type ap
15:18:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:18:13 <sjanssen> bos: doesn't that bytestring parsec code have some fundamental problem?  ISTR that it always backtracks, or something
15:18:16 <bos> bd_: absolutely
15:18:32 <bos> sjanssen: it doesn't backtrack at all. i had to add a try combinator myself.
15:18:47 <bringert> and preferrably obvious when you look at it
15:18:59 <LoganCapaldo> bringert, this is too tough for me, do you have an easier question? :)
15:19:17 <bringert> my current one isn't very nice on the eyes
15:19:31 <dcoutts> dons, you can use unsafe head and tail since you've checked for null
15:19:38 <beelsebob> pwned
15:19:59 <dcoutts> dons, oh, hmm no it's on lazy bytestring, there is no unsafe head & tail
15:19:59 <beelsebob> previous brainfuck interpretter in Haskell -- 729 lines, mine -- 80 lines
15:20:08 <beelsebob> plus mine interprets ook too
15:20:25 <hpaste>  glguy pasted "challenge step one" at http://hpaste.org/81
15:20:39 <dcoutts> dons, you need an uncons that does only a single op
15:20:39 <glguy> I didn't actually check that that was correct
15:20:40 <glguy> so...
15:20:41 <AStorm> beelsebob, do it in a oneliner - it's possible
15:21:26 <bos> time to darcs record my current code before i start pulling chunks out of the lazy bytestring.
15:21:39 <beelsebob> AStorm: including parsing it all
15:21:41 <beelsebob> ?
15:21:53 <AStorm> Yes, parsing BF is easy :>
15:22:03 <dons> dcoutts: splitAt ?
15:22:11 <dcoutts> dons, splitAt 1 ?
15:22:26 <dons> yeah, or is that a take/drop?
15:22:32 <dcoutts> I don't recall
15:22:37 <beelsebob> AStorm: lets see then?
15:22:38 <bos> it is.
15:22:40 <dcoutts> I was going to an an uncons function
15:22:46 <dcoutts> an/add
15:22:54 <bakert> ?hoogle Maybe [a] -> [a]
15:22:55 <lambdabot> No matches, try a more general search
15:23:00 <dcoutts> it'd work great with SPJ's views
15:23:07 <bos> splitAt runs in a fairly complicated loop.
15:23:09 <AStorm> beelsebob, of course, it won't be as readable
15:23:14 <bos> yes, i want views last month.
15:23:19 <beelsebob> AStorm: I'd just like to see
15:23:24 <LoganCapaldo> @hoogle fromJust
15:23:25 <lambdabot> Maybe.fromJust :: Maybe a -> a
15:23:27 <dcoutts> bos, try writing an efficient uncons and use that
15:23:27 <glguy> bringert: does mine do what ou asked for?
15:23:31 <beelsebob> AStorm: I'd also contest that my 80 line one is more readable than the 800 line one
15:23:47 <beelsebob> @paste
15:23:48 <lambdabot> http://hpaste.org (Haskell pastebin)
15:24:02 <bakert> LoganCapaldo, thanks.  My problem is actually that my list is of (thing, Maybe blah) pairs which makes life trickier.
15:24:15 <hpaste>  Beelsebob pasted "BF and Ook" at http://hpaste.org/82
15:24:20 <bakert> [(a, Maybe b)] -> [(a, b)]
15:24:35 <beelsebob> AStorm: that's my one
15:24:37 <dcoutts> bos, you should only need two tests for that, one test for [] vs (:) on the list and then one test to see if that was the last char in the chunk
15:24:39 <bakert> I am doing it with a list comprehension.
15:24:44 <bos> dcoutts: yep.
15:24:46 <beelsebob> mmm... continuation passing style IO monad
15:25:03 <dcoutts> bos, actually you don't even need the second test for the otherwise -> Left branch since that doesn't use the tail
15:26:29 <LoganCapaldo> @type catMaybes . (map (\(x,y) -> case y of Nothing -> Nothing ; Just z -> Just (x, z)))
15:26:31 <lambdabot> forall a a1. [(a, Maybe a1)] -> [(a, a1)]
15:26:47 <AStorm> beelsebob, nice
15:26:59 <beelsebob> AStorm: really nice and simple isn't it
15:27:16 <AStorm> Not just that - also generic.
15:27:30 <glguy> :t flip foldr (return []) . (liftM2 (:) .)
15:27:33 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
15:27:37 <malebria> bringert: are you there?
15:29:20 <glguy> ?type flip foldr (return []) . ((ap  . (return (:) `ap`)) .)
15:29:22 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
15:29:25 <beelsebob> AStorm: indeed
15:30:25 <LoganCapaldo> @type let factor (a, b) = b >>= (\x -> return (a, x)) in factor
15:30:26 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a, m a1) -> m (a, a1)
15:31:09 <LoganCapaldo> @type let factor (a, b) = b >>= (\x -> return (a, x)) in catMaybes $ map factor
15:31:11 <lambdabot>     Expecting a function type, but found `a'
15:31:11 <lambdabot>       Expected type: [Maybe a]
15:31:23 <LoganCapaldo> @type let factor (a, b) = b >>= (\x -> return (a, x)) in catMaybes . map factor
15:31:25 <lambdabot> forall a a1. [(a, Maybe a1)] -> [(a, a1)]
15:33:03 <LoganCapaldo> > let factor (a, b) = b >>= (\x -> return (a, x)) in factor (1, [2,3,4])
15:33:05 <lambdabot>  [(1,2),(1,3),(1,4)]
15:33:13 <LoganCapaldo> ooooo
15:33:19 <LoganCapaldo> thats kind of cool
15:33:37 <syntaxfree> [(1,x) | x<-[2,3,4]]
15:33:45 <syntaxfree> > [(1,x) | x<-[2,3,4]]
15:33:47 <lambdabot>  [(1,2),(1,3),(1,4)]
15:33:54 <glguy> > map ((,) 1) [2,3,4]
15:33:55 <lambdabot>  [(1,2),(1,3),(1,4)]
15:34:06 <LoganCapaldo> gah
15:34:13 <LoganCapaldo> That's not the point :)
15:34:29 <syntaxfree> > [(1,2), (1,3), (1,4)]
15:34:30 <lambdabot>  [(1,2),(1,3),(1,4)]
15:34:41 <glguy> > let factor (a,b) = liftM ((,) a) b in factor (1,[2,3,4])
15:34:41 <syntaxfree> that's even shorter than the comprehension version!
15:34:43 <lambdabot>  [(1,2),(1,3),(1,4)]
15:34:58 <reilly> is there an hpaste.org API document, or do I have to reverse engineer the web-page?
15:35:03 <glguy> anytime >>= is followed by a return like that... you meant liftM :)
15:35:10 <dons> reilly: read the src?
15:35:13 <glguy> reilly: API?
15:35:16 <dons> reilly: what are you looking for?
15:35:34 <reilly> going to write an applescript plugin for posting to it
15:35:41 <dons> hmm.
15:35:48 <dons> well, its 3 days old, so um..
15:35:57 <SamB> reilly: you could follow the "darcs" link at the bottom!
15:35:57 <glguy> reilly: define "API"
15:35:59 <dons> (i'd like a darcs client :)
15:36:01 <glguy> you want to know the forms names?
15:36:10 <reilly> yeah
15:36:18 <dons> reilly: yeah, you should grab the src
15:36:22 <dons> ?where hpaste
15:36:23 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
15:36:30 <reilly> gotcha
15:36:42 <bringert> glguy: it's a mapM, but not point-free
15:36:47 <dons> you might want to document the api :)
15:36:51 <dons> so i can write a command line client
15:36:53 <reilly> will do
15:37:01 <glguy> reilly: nick   title    content
15:37:06 <bos> dons: looks like PS isn't exported from ByteString.Base, so I can't pull it apart
15:37:19 <dcoutts> bos, it is exported
15:37:32 <dcoutts> but it's called BS
15:37:36 <glguy> reilly: post those 3 var to /new
15:37:57 <glguy> Wed Jan 17 23:34:21 EST 2007  Stefan O'Rear <stefanor@cox.net>
15:37:57 <glguy>   * initial import of glguy's pastes
15:38:28 <bos> dcoutts: it is? in Data.ByteString.Base?
15:38:35 <dcoutts> bos, yep
15:39:09 <bos> maybe it got renamed. it's PS in the source i have (ghc/libraries/base)
15:39:14 <sjanssen> the version of Data.ByteString in the base package has it as PS
15:39:26 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/Data/ByteString/Base.hs says PS... and it's exported there
15:39:27 <lambdabot> http://tinyurl.com/2zc826
15:39:34 <dcoutts> ok PS, I'm forgetting :-)
15:39:43 <dcoutts> it should have been BS
15:40:10 <hpaste>  JuanMarcus annotated "Socket Thread Blocking" with "(no title)" at http://hpaste.org/79#3
15:40:27 <bd_> bos: there's also fromForeignPtr and toForeignPtr
15:40:47 <syntaxfree> I remember there was a web tool to browse darcs repositories.
15:40:53 <syntaxfree> what ever happened to that?
15:41:05 <bos> bd_ - yep
15:42:54 <glguy> dons: I should have hpaste serve itself
15:43:06 <glguy> dons: so you can always see the latest code
15:43:09 <glguy> by going to hpaste
15:44:01 <glguy> and see it highlighted
15:44:10 <bd_> I'm not sure the annotations model scales quite that well... :)
15:44:23 <glguy> :-p
15:44:32 <glguy> it would obviously be an automated page
15:44:41 <glguy> outside of the current system
15:44:49 <bos> @hoogle peekByteOff
15:44:50 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
15:45:19 <bos> @hoogle inlinePerformIO
15:45:20 <lambdabot> No matches found
15:45:25 <bos> hm.
15:45:53 <bos> @hoogle unsafePerformIO
15:45:54 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
15:46:07 <bd_> bos: there's an inlinable variant in Data.ByteString.Base as well - inlinePerformIO
15:46:10 <glguy> unsafeInterleaveIO?
15:46:29 <dcoutts> be very very careful with inlinePerformIO
15:46:39 <dcoutts> it's even less safe than unsafePerformIO
15:46:42 * glguy wonders what it does
15:46:50 <dcoutts> it can be CSE'd
15:47:08 <bd_> dcoutts: For peeking a constant buffer, it should be okay, right?
15:47:11 <glguy> go on
15:47:17 <dcoutts> bd_, yes
15:47:21 <JuanMarcus> bd_: tested the same code on linux, worked
15:47:34 <JuanMarcus> bd_: but i still need it to run on windows...
15:47:38 <bd_> JuanMarcus: You never posted any broken code...
15:47:50 <bd_> JuanMarcus: at least, not any code which looked like it /shouldn't/ block
15:47:53 <dcoutts> bd_, just make sure you don't do any memory allocation
15:48:06 <dcoutts> bd_, or any other side-effecty thing
15:48:22 <JuanMarcus> bd_: are you on windows?
15:48:32 <dcoutts> bd_, we had a bug where the allocation of two buffers got commoned up so the two values shared the same buffer.
15:48:49 <abz> is (.:) = (.) . (.) define anywhere in the standard libraries?
15:48:51 <bd_> JuanMarcus: no, but the paste you posted blocked on linux, and did so because it was apparently designed to block :)
15:48:56 <dcoutts> ie we ended up with singleton 'a' == singleton 'b'
15:48:59 <dcoutts> very bad :-)
15:49:04 <AStorm> :t (.:)
15:49:06 <lambdabot> Not in scope: `.:'
15:49:08 <bd_> JuanMarcus: and the second paste you had didn't have any code in it at all
15:49:13 <AStorm> :hoogle (.:)
15:49:23 <bd_> JuanMarcus: but you weren't in channel at the time so nobody could ask you about that :)O
15:49:28 <SamB> is this it? (.) . (.)
15:49:33 <JuanMarcus> bd_: i meant your code =D
15:49:37 <AStorm> Yeah, the Owl :>
15:49:37 <bd_> JuanMarcus: ah
15:49:48 <JuanMarcus> bd_: your code blocks on my windows
15:49:49 <bd_> JuanMarcus: I'm not on windows I'm afraid, but I could load ghc in wine...
15:49:49 <AStorm> :t (.) . (.)
15:49:51 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:50:08 <abz> guess not...
15:50:44 <seumadruga> Juan Marcus: you're not able to build a haskell program using threads...
15:50:50 <bd_> JuanMarcus: are you using runhaskell or ghc ?
15:51:04 <JuanMarcus> bd_: ghc --make -threaded ....
15:51:07 <bd_> seumadruga: ? GHC since ages ago has supported haskell-level threads, and as of 6.6 supports OS-level threads
15:51:24 <bd_> JuanMarcus: hm, just out of curiosity, can you try removing -threaded and seeing if it works?
15:51:38 <JuanMarcus> bd_: i think i did, let me double check
15:51:57 <seumadruga> i'm saing it becouse Juan Marcus is a newbie...
15:52:03 <seumadruga> he must study more...
15:52:21 <JuanMarcus> bd_: lol worked
15:52:29 <SamB> heh
15:52:29 <bd_> seumadruga: ... haskell threads aren't that hard to use? And... how is that evident in your message? XD
15:52:33 <bd_> JuanMarcus: hm, sounds like a ghc bug
15:52:38 <bd_> post on haskell-cafe about it
15:52:53 <JuanMarcus> bd_: a bunch of sites told me to use that option
15:53:02 <JuanMarcus> bd_: and i used the same option on linux...
15:54:13 <bd_> JuanMarcus: yes, -threaded enables the multiple-os-threads runtime, which is new in 6.6
15:54:24 <bd_> also it enables the native-haskell IO manager I believe
15:54:29 <bd_> which might be where the bug is
15:54:41 <bd_> ... and ghc-in-wine isn't working very well
15:55:02 <JuanMarcus> bd_: i see
15:55:16 <JuanMarcus> bd_: is there any kind of point system? so i can get you some =D
15:55:23 <bd_> <nick>++ :)
15:55:28 <bd_> @karma bd_
15:55:29 <lambdabot> You have a karma of 1
15:55:32 <bd_> I'm unloved :(
15:55:34 <JuanMarcus> bd_++
15:55:43 <JuanMarcus> <bd_>++
15:55:46 <JuanMarcus> ?!?
15:55:47 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
15:55:47 <bd_> no < > :P
15:55:51 <bd_> @karma <bd_>
15:55:51 <lambdabot> <bd_> has a karma of 1
15:55:52 <bd_> @karma bd_
15:55:53 <lambdabot> You have a karma of 2
15:55:58 <Excedrin> @karma <nick>
15:55:59 <lambdabot> <nick> has a karma of 1
15:56:01 <JuanMarcus> ok done =D
15:56:22 <bd_> anyway, mention it on -cafe, and if there's consensus something's broken file a bug in the GHC tracker
15:56:48 <bd_> and an appropriately high-level sage will swiftly take care of the demons plaguing you
15:56:55 <JuanMarcus> cafe?
15:57:09 <bd_> and in the meantime leave off -threaded, you won't gain anything from it unless you have multiple CPUs and use +RTS -N<cpus>
15:57:12 <bd_> JuanMarcus: one sec
15:57:20 <bd_> ?where haskell-cafe
15:57:21 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
15:57:24 <AStorm> Hmm, is hs-plugins already in ghc-6.6? :>
15:57:26 <bd_> there you go :)
15:57:27 <JuanMarcus> this bot is so cool
15:57:37 <bd_> AStorm: hs-plugins is broken in ghc-6.6 still last I heard :/
15:57:43 <bd_> @. elite quote
15:57:44 <lambdabot> $csibuG zAy5: I (0u1D havE s\/\/ORN IT was iNc0RR3c7 UN7Il I7 +Yp3-cH3CKed
15:58:45 <JuanMarcus> i need a better mirc client
15:58:49 <bd_> uh, that's interesting. wine-ghc isn't responding to kill -9
15:59:32 <AStorm> Damn, hs-plugins is too nice not to have :>
16:00:20 <dibblego> JuanMarcus, mirc *is* a client; do you mean a better IRC client?
16:01:07 <JuanMarcus> dibblego: we usually refer to irc as mirc here all the time
16:01:18 <AStorm> JuanMarcus, don't even try
16:01:29 <dibblego> where is "here"?
16:01:32 <Lemmih> JuanMarcus: Wow, that's so evil.
16:01:33 <AStorm> mirc is (r4p
16:01:53 <JuanMarcus> dibblego: Piaui, Brazil =D
16:01:58 <dibblego> my grandmother refers to windows as a computer
16:02:00 <AStorm> Yuck.
16:02:18 <dons> my grandma refers to email as the internet
16:02:29 <bd_> I know people who call side-effecting actions "functions"! Functions, of all things! Can you believe that?
16:02:36 <dibblego> amazing how naive and easily tricked the brain is
16:02:38 <dons> so i always get confused when she says she read some (personal detail) about me on the internet
16:02:57 <AStorm> bd_, I call them procedures.
16:06:05 <dons> ?where hpaste
16:06:06 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
16:06:17 <dons> glguy: we should move the hpaste source onto darcs.haskell.org
16:06:25 <hpaste> <-- right here
16:06:27 <dibblego> what happened to hpaste.org?
16:06:34 <dons> hmm?
16:06:41 <glguy> !paste
16:06:41 <hpaste> Haskell paste bin: http://hpaste.org/
16:06:47 <dibblego> ah
16:07:09 <glguy> dons: OK.. how do I do that
16:07:17 <dons> do what?
16:07:25 <glguy> push to darcs.
16:07:37 <dons> ah right. so you'd need an ssh account on darcs.haskell.org
16:07:47 <dons> which you get by talking to SimonM
16:07:50 <glguy> and simonm
16:07:52 <glguy> eyah
16:07:56 <dons> or , i push , and you send to me
16:08:09 <glguy> :(
16:08:09 * sjanssen wants views right now
16:08:18 <sjanssen> I'm trying to turn Parsec into GenParsec
16:08:21 <bd_> Are there any systems which allow one to provide darcs hosting account without full ssh access?
16:08:34 <dons> i'd like to know of one, bd_ :)
16:08:34 <reilly> ?src HsJudy
16:08:35 <lambdabot> Source not found. You speak an infinite deal of nothing
16:08:43 <dons> ?where HsJudy
16:08:43 <lambdabot> http://perlcabal.org/~audreyt/darcs/pugs/third-party/HsJudy/
16:08:48 <dons> ?src map
16:08:48 <lambdabot> map _ []     = []
16:08:49 <lambdabot> map f (x:xs) = f x : map f xs
16:08:54 <reilly> thanks
16:09:40 <bd_> dons: It would seem like one could just take emails through a procmail filter, and then into darcs apply --verify=... -a ...
16:09:55 <dons> yeah, that'd do
16:10:01 <dons> or cgi/auth using daan's server
16:10:05 <syntaxfree> @vote cheeky-off Yes
16:10:05 <lambdabot> voted on "Yes"
16:10:08 <syntaxfree> @poll
16:10:08 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
16:10:13 <syntaxfree> @poll-result cheeky-off
16:10:14 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=1, Yes=12
16:10:21 <bd_> @vote cheeky-off No
16:10:21 <lambdabot> voted on "No"
16:10:22 <reilly> seems like HsJudy should have its own repo
16:10:23 <bd_> >.>
16:10:43 <syntaxfree> hsjudy?
16:11:03 <syntaxfree> Haskell really needs better project names.
16:11:07 <syntaxfree> HsThis, HThat.
16:11:08 <Excedrin> is the following statement correct: procedures are more general than functions, since a function is simply a procedure with one output parameter
16:11:28 <AStorm> syntaxfree, HAcker for Ackermann function? :P
16:11:39 <syntaxfree> hahahaha
16:11:46 <reilly> HsJudy is an interface to Judy Arrays for haskell
16:11:52 <dons> Excedrin: but functions can implement procedures
16:12:00 <dons> where the state you modify is part of the input and output :)
16:12:15 <dons> so procedures are just special syntax for functions with an extra arg in and out
16:13:04 * LoganCapaldo wants Sarah arrays and Jane arrays and Samantha arrays
16:13:29 <reilly> Redundant Array of Inexpensive Women?
16:13:37 <Excedrin> dons: hmm, prefix "pure" to procedures and functions in the statement I asked about, does that change the meaning?
16:13:56 <csci> Hi, unfortunately I have to work on windows. Does anyone know a good (modern, i.e. no emacs) editor that is fast, light and has support for syntax coloring of haskell code?
16:14:04 <AStorm> csci, vim
16:14:06 <AStorm> :P
16:14:08 * AStorm ducks
16:14:15 <dons> i'm fairly sure that the lambda calculus tells us that all you need are functions :)
16:14:18 <dons> everything else is sugar
16:14:25 <a-priori> csci: kate?
16:14:31 <AStorm> dons, well, types are not
16:14:34 <AStorm> a-priori, Windoze
16:14:35 <Excedrin> csci: scite
16:14:40 <syntaxfree> csci: cream.
16:14:47 <AStorm> cream == vim
16:14:49 <LoganCapaldo> I've found that Haskell is the language I care the least about syntax highlighting for
16:14:56 <syntaxfree> Cream = modeless Vim.
16:15:04 <syntaxfree> It really looks and feels like a normal windows application.
16:15:09 <syntaxfree> You have to know nothing about Vim.
16:15:12 <LoganCapaldo> Ok, maybe I care about syntax highlighting less in forth, but only by a little bit :)
16:15:13 <syntaxfree> Use it as if it was Notepad.
16:15:32 * LoganCapaldo done making observation
16:15:37 <csci> I'm using vim under Linux as my main editor (in normal mode, not cream). But under Windows I'd like to have something more Gui-like :)
16:15:39 <syntaxfree> csci: Give Cream a chance, really.
16:15:42 <yaxu> is there blog software written in haskell?
16:15:49 <syntaxfree> yes.
16:15:51 <csci> Logan: Even less in any concatenative language ;-)
16:16:18 <syntaxfree> concatenative languages could have EXCELLENT syntax highlighting if editors worked outside the box.
16:16:18 <Procyon> dons: All you need are functions.. and love.  Assuming of course you can't express love in terms of lambda
16:16:30 <dons> i think there's a combinator for that
16:16:37 <Procyon> excellent!
16:16:42 <LoganCapaldo> csci, those tend to bring back that matched pairs of things though
16:16:42 <csci> syntaxfree: as I've written, normally I prefer vim, but here I'd like to have something more with Gui :)
16:16:49 <LoganCapaldo> which I like colors for
16:17:01 <csci> yes, right
16:17:42 <Procyon> dons: is that the <3 combinator ;)
16:17:57 <dons> heh
16:18:30 <dons> ?let me <$ you = (me,you)
16:18:32 <lambdabot> Defined.
16:18:42 <dons> though maybe that's the ice cream cone combinator
16:18:44 <Procyon> lol
16:18:46 <syntaxfree> csci: what more GUI than Cream can you have?
16:18:53 <syntaxfree> csci: only if you have WYSIWYG formatting!
16:18:57 <AStorm> :t (<$)
16:18:58 <lambdabot> Not in scope: `<$'
16:19:01 <AStorm> :t (l><$)
16:19:03 <lambdabot> Not in scope: `l'
16:19:03 <lambdabot>  
16:19:03 <lambdabot> <interactive>:1:2: Not in scope: `><$'
16:19:05 <AStorm> :t (L.<$)
16:19:06 <lambdabot> Couldn't find qualified module.
16:19:09 <dons> > "haskell" <$ "profit"
16:19:11 <lambdabot>  ("haskell","profit")
16:19:11 <AStorm> :t L.<$
16:19:13 <lambdabot> parse error on input `L.<$'
16:19:16 <AStorm> Hmm.
16:19:25 <dons> not in scope in the :t
16:19:31 <LoganCapaldo> forall a b. a -> b -> (a, b)
16:19:42 <LoganCapaldo> Better? :)
16:19:58 <dons> oh, factorCSS works nicely
16:20:09 <LoganCapaldo> I do my own type inference! ;)
16:20:16 <dons> and is pure haskell! yay.http://zamez.org/factorcss
16:20:20 <lambdabot> Title: Zamez.org
16:20:31 <Procyon> LoganCapald: You are a unifier amongst men
16:21:21 <dcoutts> Igloo, have you ever noticed that ghc puts in the #includes into the .hc file in the opposite order to how they're specified in the .cabal/.package.conf file ?
16:21:28 <AStorm> :t <3
16:21:30 <lambdabot> parse error on input `<'
16:21:33 <AStorm> Hmm...
16:21:40 <Igloo> dcoutts: No
16:21:46 <dcoutts> Igloo, if you ever fix that buglet I'll have to reverse my includes :-)
16:23:59 <Taral> @pl \r -> (head r, length r)
16:24:00 <lambdabot> liftM2 (,) head length
16:24:44 <Igloo> dcoutts: That's a pain, actually, because we probably shouldn't fix it before 6.8
16:24:51 <bos> @pl \z -> (head z, tail z)
16:24:52 <lambdabot> liftM2 (,) head tail
16:24:56 <dcoutts> Igloo, aye, probably so
16:25:16 <dcoutts> Igloo, the same bug has been around since at least 6.2
16:25:25 <dcoutts> and probably before
16:25:35 <dons> so hmm, should we port hackage to happs / hpaste now
16:25:55 <dcoutts> dons, if you've got enough monkeys to do it, go for it :-)
16:26:02 <dcoutts> dons, but don't work too hard
16:26:03 <Igloo> dons: What would the benefit be?
16:26:07 <LoganCapaldo> @type liftM2
16:26:09 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:26:11 <Igloo> dons: Did you get my patch e-mail, BTW?
16:26:20 <dons> Igloo: yes, thanks. and applied
16:26:24 <Igloo> Ah, cool
16:26:36 <Igloo> thanks
16:26:38 <dons> hmm, so who's the person to ask to get some haskcage instructions on the wiki?
16:26:53 <dons> is it usable *now*? do we just start/
16:27:01 <bos> sod, my uncons code has a bug. these 64k extents make it hard to manually find the corner cases :-)
16:27:26 <bd_> bos: manually construct a lazy bytestring with really weird extent sizes :)
16:27:30 <Igloo> dons: You can upload packages at http://hackage.haskell.org/packages/hackage.html
16:27:32 <lambdabot> Title: Basic Hackage interface
16:27:36 * bd_ ponders some kind of crossover of hpaste and a wiki...
16:27:41 <bos> bd_: this is exactly what i'm doing :-)
16:27:52 <LoganCapaldo> @type (,) head
16:27:54 <lambdabot> forall a b. b -> ([a] -> a, b)
16:28:02 <LoganCapaldo> @type (,) head tail
16:28:03 <lambdabot> forall a a1. ([a] -> a, [a1] -> [a1])
16:28:16 <dons> you could hack up a happs /hpaste frontend to darcs that worked like a wiki..
16:28:16 <dcoutts> bos, yeah we used quickcheck to generate chunks with small sizes
16:28:27 <LoganCapaldo> @type liftM2 (,)
16:28:28 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
16:29:07 <LoganCapaldo> @hoogle Id
16:29:07 <lambdabot> Prelude.id :: a -> a
16:29:08 <lambdabot> Control.Monad.Identity :: module
16:29:08 <lambdabot> Text.Read.Ident :: String -> Lexeme
16:29:08 <dons> dcoutts: does the 'preview' stuff actually preview on hackage now?
16:29:15 <LoganCapaldo> @hoogle Identity
16:29:16 <lambdabot> Control.Monad.Identity :: module
16:29:16 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
16:29:16 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
16:29:17 <dcoutts> dons, yes
16:29:40 <dcoutts> dons, Ross fixed it that day, it was just a cut'n'pasto
16:29:40 <JuanMarcus> bd_: guess what, - threaded doesn't matter
16:29:41 <dons> so i should just upload hpaste and all its deps..
16:29:47 <dcoutts> yep
16:29:49 <dons> hmm, including happs :)
16:29:57 <JuanMarcus> bd_: recvFrom blocks, recv doesn't
16:29:59 <dons> and haxml. mm. bigg
16:30:01 <dcoutts> if it's all cabalised then yeah
16:30:17 <bd_> JuanMarcus: blocks the runtime completely?
16:30:21 <dons> and then the download instructoins would all point to hackage urls
16:30:29 <bd_> JuanMarcus: As a workaround you can use threadWaitRead first, but sounds like a bug.
16:30:50 <JuanMarcus> bd_: what does it do?
16:30:59 <bd_> JuanMarcus: Waits until a handle is readable
16:30:59 <dons> ah, haxml is up there already good
16:31:08 <bd_> or were you working with a Socket...?
16:31:20 <JuanMarcus> bd_: with the socket
16:31:33 <JuanMarcus> bd_: should i turn it into a handle?
16:31:52 <hpaste>  bos annotated "can anyone see a faster way?" with "uncons, new and shiny, with bug" at http://hpaste.org/80#3
16:32:25 <bos> the damn thing seems to follow the informal invariants, as i understand them.
16:32:49 <bos> if i run it under ghci with faked-up lazy bytestrings, it seems fine.
16:32:55 <bos> on real data, croaksville.
16:33:04 <bd_> JuanMarcus: Hmm... I don't think there's a recvFrom for sockets. If you can ensure the Handle stays alive you can use both though...
16:33:07 <bd_> [maybe]
16:33:10 <dons> got a QuickCheck property for it, bos?
16:33:26 <dons> ie. uncons == (head x, tail x)
16:33:39 <bos> i have no quickcheck framework yet.
16:33:47 <dons> oh, this isn't in fps ?
16:33:51 <bos> no.
16:33:56 <dons> ah right i see
16:34:03 <dons> let me write you a little module to test... :)
16:34:08 <dons> hang on, scratch that
16:34:09 <bos> i could add uncons to fps, i suppose :-)
16:34:12 <dons> you can just steal the fps tests
16:34:14 <JuanMarcus> bd_: i don't think i'm ready to do that yet
16:34:58 <JuanMarcus> bd_: i used recvFrom because i needed the sender address
16:35:00 <hpaste>  bd_ annotated "Socket Thread Blocking" with "possible workaround?" at http://hpaste.org/79#4
16:35:07 <bd_> JuanMarcus: Try that?
16:35:14 <bd_> turns out threadWaitRead takes a fd :)
16:35:28 <bos> dons: i'm getting fps now.
16:36:41 <JuanMarcus> bd_: very simples code!
16:36:49 <bd_> JuanMarcus: but does it work?
16:36:55 <bd_> JuanMarcus: and in either case it's a bug in GHC
16:36:56 <JuanMarcus> bd_: gonna check
16:38:01 <bd_> JuanMarcus: also see if using forkOS rather than forkIO helps
16:38:02 * qwr wonders, why haskell needs separate map for lists, when there is fmap...
16:38:29 <dons> qwr, it doesn't :)
16:38:35 <dons> > fmap (+2) [1..10]
16:38:37 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
16:38:40 <dons> but it helps beginners
16:38:43 <dons> > fmap (+) [1..10]
16:38:44 <lambdabot>  Add a type signature
16:38:48 <JuanMarcus> bd_: windows illegal operation
16:38:49 <dons> > fmap (+) [1..10] :: [Int]
16:38:50 <lambdabot>      Expecting a function type, but found `b'
16:38:51 <lambdabot>       Expected type: a -> Int
16:38:51 <lambdabot>  ...
16:38:54 <JuanMarcus> bd_: lol
16:39:22 <bd_> JuanMarcus: hm, okay, that's non-portable I guess. forkOS will make a bound thread for the callouts though.
16:39:36 <bos> dons: i notice that the lazy bytestring code doesn't look into the internals of strict bytestring. so uncons is kind of grotesque in there.
16:39:38 <JuanMarcus> bd_: something else to try
16:39:45 <JuanMarcus> bd_: hang on
16:40:01 <dcoutts> bos, that's because there's no need to almost all the time
16:40:12 <bos> yeah.
16:40:34 <dcoutts> bos, the bytestring functions it calls are perfectly efficient so there's no need to break the abstraction barrier
16:40:41 <dcoutts> the compiler can inline it rather than me
16:40:51 <bos> sure.
16:41:00 <JuanMarcus> bd_: to use that i need -threaded =D
16:41:06 <dcoutts> bos, you'll notice it uses unsafeHead & tail when appropriate
16:41:16 <bd_> JuanMarcus: okay, try -threaded and forkOS :)
16:41:21 <bos> i don't know what i'd be winning with that uncons code, then. other than headaches :-)
16:41:28 <qwr> > fmap ($ 2) $ fmap (+) [1..10]
16:41:30 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
16:41:44 <beelsebob> lambdabot just lost the game
16:42:17 <JuanMarcus> bd_: yep, blocks
16:42:32 <bd_> JuanMarcus: weird
16:42:40 <dcoutts> bos, uncons should be really simple, it's just a pattern match on the list and a call to unsafeHead, unsafeTail and null (in that order)
16:42:55 <bos> yeah.
16:43:05 <bd_> dcoutts: wouldn't null be before unsafe*?
16:43:11 <dcoutts> bd_, nope
16:43:25 <dcoutts> bd_, and why is that? :-)
16:43:34 <dcoutts> hint, it's the data type invariant
16:43:37 <bd_> if null bs then Nothing else Just (unsafeHead bs, unsafeTail bs)
16:43:57 <bd_> oh, the lazy bytestring has no null chunks?
16:44:01 <bd_> ic
16:44:01 <dcoutts> right
16:44:13 <dcoutts> but you need to preserve that invariant
16:44:25 <dcoutts> hence you need to check if the tail you've now got is null
16:44:43 <dcoutts> uncons :: ByteString -> Maybe (Word8, ByteString)
16:44:43 <dcoutts> uncons (LPS []) = Nothing
16:44:43 <dcoutts> uncons (LPS (x:xs))
16:44:43 <dcoutts>   | P.length x == 1 = Just $! (P.unsafeHead x, LPS xs)
16:44:43 <dcoutts>   | otherwise       = Just $! (P.unsafeHead x, LPS (P.unsafeTail x : xs))
16:45:12 <Igloo> Huh? Does uncons exist?
16:45:19 <dcoutts> no, it's not included
16:45:25 <Igloo> Oh, why not?
16:45:26 <dcoutts> it's just in my local copy
16:45:34 <dcoutts> we never added it
16:45:36 <hpaste>  bos annotated "can anyone see a faster way?" with "son of uncons" at http://hpaste.org/80#4
16:45:40 * Igloo has it defined (with a different name) in a util lib somewhere
16:45:49 <Tama00> hi
16:45:57 <dons> hey Tama00
16:46:04 <bd_> bos: Unboxed tuples? :)
16:46:16 <dons> Tama00: learning haskell?
16:46:16 <dcoutts> Igloo, ask dons if he thinks we should add it
16:46:16 <Tama00> dons, whats haskell like for a programming langauge?
16:46:18 <bd_> bos: C.null rather than length > 1?
16:46:24 <Tama00> dons, yeah considering it
16:46:35 <dons> Tama00: a really nice one, in my opinion. check out haskell.org for lots of info and details
16:46:40 <Igloo> dons: Add it!
16:46:45 <dons> uncons, yeah
16:46:48 <dons> we should add it
16:47:06 <Tama00> dons, i might read this haskell tutorial for c programmers considering i am one:P
16:47:23 <bos> bd_: won't C.null always be True?
16:47:25 <dons> hmm, YAHT is considered good
16:47:27 <dons> ?where yaht
16:47:28 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:47:30 <sjanssen> uncons++ I've wanted this many times
16:47:37 <dons> but check the list of tutorials on haskell.org, there's *lots*
16:47:37 <AStorm> Challenge: create genetic algorithm writing proper Haskell
16:47:45 <AStorm> First challenge: text editor :P
16:47:45 <bos> since the invariant is non-empty strict bytestrings?
16:47:46 <dons> Tama00: also, just hang out here, and ask questions :)
16:47:54 <bd_> bos: ah, right. C.null on the result of unsafeTail maybe then?
16:47:55 <Tama00> dons, w0o0o yes im accepted:P
16:48:01 * dons hands AStorm a copy of yi
16:48:06 <bd_> probably doesn't matter at that point
16:48:18 <dons> Tama00: you in Sydney?
16:48:19 <AStorm> dons, it has to be machine-written, yi isn't
16:48:22 <bos> right, then I'm doing unnecessary work in unsafeTail
16:48:31 <dons> AStorm: how do you know??
16:48:38 <Tama00> Tama00, gold coast
16:48:41 <dons> i wrote a plugin for lambdabot that wrote yi in 2 weeks
16:48:44 <sjanssen> dons: Data.Sequence uses viewl/viewr, maybe those names are better?
16:48:45 <AStorm> The autor has the copyright.
16:48:52 <dons> Tama00: ah pity. so you're not doing haskell at uni?
16:48:59 <dons> sjanssen: hmm!
16:49:01 <AStorm> Also, too much English inside.
16:49:11 <bd_> AStorm: dons is actually a lambdabot plugin. The reason he gets so much done is because he's making good use of ghc's OS threading on his 8-core beast of a machine :)
16:49:13 <Tama00> dons, i start uni this year, so i dunno what they do lol
16:49:14 <dons> yeah, we should consider views compat
16:49:22 <dons> bd_ 16 cores
16:49:28 <AStorm> dons, not MIPS?
16:49:41 <dons> Tama00: ok. well, several places in .au teach haskell in first year, so its a good choice
16:49:59 <Tama00> wo0o:P
16:50:01 <dons> it'd be fairly safe to say that if you know haskell before getting to uni, you've got a bit of an advantage
16:50:12 * dons wonders what sorear's first year marks will be like
16:50:22 <syntaxfree> bd_: I have an opposite theory.
16:50:26 <bos> what, sorear is 10?
16:50:29 <syntaxfree> lambdabot's too smart to be true.
16:50:33 <dons> 16
16:50:33 <AStorm> dons, not in .pl :/ Here those stupids teach one of these: C, C++, C#, Pascal, Object Pascal, Java
16:50:34 <syntaxfree> It's dons typing all along.
16:50:36 <AStorm> Yuck.
16:50:38 <Tama00> dons, what do you like most about haskell?
16:50:54 <dons> hmm, flexibility?
16:50:58 <bd_> syntaxfree: ah, so the real reason hs-plugins is broken, and several of lambdabot's dependencies no longer build on 6.6, is to cover up this fact?
16:51:25 <dons> Tama00: i guess , really, its that i can get code done *quickly*  with less bugs
16:51:29 <bd_> 6.4 even
16:51:30 <csci> Is there some atoi-function atoi :: [Char] -> Int predefined and I just have not found it or do I have to implement it by myself?
16:51:33 <Igloo> dons: Would you accept a patch that made LazyBtyestring.cons lazy and added LazyBtyestring.strictCons?
16:51:36 <dons> because the language prevents a lot of common bugs
16:51:38 <bd_> csci: read
16:51:44 <allbery_b> :t read
16:51:44 <Procyon> sorear is 16?!?!!eleven
16:51:45 <syntaxfree> bd_: yes. In the old days, dons used to type out every lambdabot instance out there.
16:51:45 <dons> Igloo: you need it?
16:51:46 <lambdabot> forall a. (Read a) => String -> a
16:51:49 <AStorm> Instead of MIPS measure of computing power, we should use DIPS - Dons instructions per second
16:51:52 <syntaxfree> But now there are too many for him to control!
16:51:55 <syntaxfree> > reveal yourself, dons
16:51:55 <lambdabot>  Parse error
16:51:58 <csci> argh, yes
16:52:00 <Tama00> dons, nice.. also one more question, what compiler do you use?
16:52:01 <allbery_b> it's polymorphic so you kinda need to know what to look for
16:52:02 <syntaxfree> > you can't fool me!
16:52:03 <lambdabot>  Parse error
16:52:07 <sjanssen> foldr f n (viewl bs -> (x, xs)) = f x (foldr f n xs); foldr f n _ = n -- this is what Data.ByteString.foldr might look like with SPJ's views proposal
16:52:07 <AStorm> > !!!
16:52:07 <lambdabot>  Parse error
16:52:09 <dons> Tama00: ghc
16:52:14 <AStorm> ?type dons
16:52:15 <lambdabot> Not in scope: `dons'
16:52:16 <Tama00> dons, alright neat
16:52:20 <AStorm> Hmm, fake.
16:52:22 <Tama00> i might have a bit of a read over it then
16:52:31 <Igloo> dons: Yes. The other alternative would be cons and lazyCons, but that feels wrong to me when the datatype is called LazyBytestring
16:52:38 <dons> yeah
16:52:42 <dons> though strictCons hmm.
16:52:44 <dons> how about cons'
16:52:49 <sjanssen> dons: my vote (if I have one :) ) is with Igloo
16:52:57 <Igloo> cons' is fine with me
16:53:00 <dons> sjanssen: of course you have a vote :)
16:53:04 <dons> ok. cons/ cons'
16:53:07 <dons> Igloo: go for it.
16:53:09 <AStorm> s/cons'/dons/g :P
16:53:13 <AStorm> ?type cons'
16:53:14 <lambdabot> Not in scope: `cons''
16:53:15 <dcoutts> Igloo, what was your use case for lazy cons?
16:53:30 <Igloo> dcoutts: The same as lazy append, but when you are producing things character-at-a-time
16:53:33 <dons> (yeah, that's the other issue: breaking the api)
16:53:34 <qwr> Tama00: learning haskell feels a bit like relearning to program
16:53:39 <dons> but we clearly need a few things that are missing
16:53:41 <dons> like uncons/view
16:53:47 <Igloo> gunzip wants to use both
16:53:54 <Procyon> There should be a law against 16 year olds giving me algorithms that break my head.
16:53:55 <dcoutts> Igloo, but if you're producing char at a time you should be slapped with a trout
16:53:55 <syntaxfree> learning Haskell feels like learning mathematics.
16:54:04 <Tama00> qwr, yeah im looking at it now going wtf is this lol
16:54:06 <csci> qwr: Just a *bit* ;-)
16:54:07 <syntaxfree> damn. Sorear is like 16?
16:54:12 <dons> syntaxfree: yeah
16:54:16 <AStorm> Procyon, ROTFL
16:54:19 <bd_> @remember Procyon There should be a law against 16 year olds giving me algorithms that break my head.
16:54:20 <lambdabot> Done.
16:54:24 <dons> hence he always has to go off and do his math homework
16:54:25 <AStorm> Your head is indeed fragile.
16:54:27 <dcoutts> Igloo, it's soo slow
16:54:36 <syntaxfree> The summer course I'm taking (a first-year masters' course in number theory) has 3 or 4 child prodigies.
16:54:37 <dons> but wants to hang around here writing deadlock free stm code
16:54:58 <dcoutts> Igloo, one can always just use append and singleton
16:55:01 <syntaxfree> But since I don't care much about number theory, that's okay.
16:55:04 <syntaxfree> But hell, 16?
16:55:06 <syntaxfree> That hurts.
16:55:08 * AStorm hates integrals :P
16:55:18 <Igloo> dcoutts: Well part of the inflate algorithm is "read a few bits, convert them to a character, return that character"
16:55:23 <AStorm> They're like, hack.
16:55:24 <Igloo> dcoutts: Yes, but one shouldn't have to
16:55:30 <dcoutts> Igloo, btw, you should probably be using Builder which gives efficient O(1) appends
16:55:39 <Igloo> dcoutts: Where is Builder?
16:55:45 <dons> dcoutts: is there anyay to 'decompress' on a strict bytestring natively?
16:55:47 <dcoutts> Igloo, in the binary package
16:55:55 <dons> i hate having to copy my strict bytestrings to lazy ones to decompress in hpaste
16:55:59 <bd_> Oh, is this a pure-haskell gzip implementation you're referring to, Igloo?
16:56:09 <Igloo> bd_: Yes
16:56:09 <dons> I suppose i could move everything into lazy bytestrings insteadhmm
16:56:11 * sjanssen thinks its strange that append . singleton /= cons
16:56:16 <bd_> nice :)
16:56:30 <dcoutts> dons, no, compression works in chunks. the only thing you can do is concat at the end
16:56:34 <Igloo> dcoutts: OK, I'm not using that ATM
16:56:37 <dons> ok
16:56:57 <Igloo> bd_: It's in hackage (package: compression) if you're interested
16:57:00 <dons> dcoutts: so same issue as serialisation
16:57:14 <dons> dcoutts: with not knowing beforehand how large the buffer will need to be
16:57:18 <dcoutts> dons, right
16:57:28 <dcoutts> you know an upper bound only
16:57:28 <dons> though i guess its always smaller than the input bytestring?
16:57:57 <dons> Igloo: oh, i thought that was Bulat's compression-3000 lib
16:58:08 <dons> did we steal another name from the Bulat namespace?
16:58:13 <dcoutts> dons, there's usually a max expansion factor that compression libs give in the worst case
16:58:15 <dons> first streams, now compression. what next!
16:58:29 <Igloo> dons: AFAIK first person to hackage wins, ATM
16:58:33 <dons> :)
16:58:38 <bd_> dons: The RealWorld# :)
16:58:42 <dons> heh
16:58:42 <Igloo> People I've spoken to about more namespace control don't seem to think we need any
16:59:00 <dcoutts> dons, what bits of Bulat's namespace have we just stolen? and what other bits are left to steal? :-)
16:59:10 <dons> good question!
16:59:11 <Igloo> (I had no idea Bulat had a cabal package with that name, for the record)
16:59:13 <syntaxfree> damn.
16:59:19 <syntaxfree> I need to speed up on my learning Haskell.
16:59:19 <dons> Igloo: probably not cabalised
16:59:26 <syntaxfree> any suggestions?
16:59:31 <Igloo> Well, package of any description for that matter
17:00:31 <dons> hmm. so i could profitablly insert hackage urls for libraries needed by hpaste
17:00:40 <AStorm> syntaxfree, code
17:00:42 <dons> and can i upload stuff ot hackage that doesn't have all its deps on hackage/
17:00:44 <AStorm> :>
17:00:47 <syntaxfree> ;)
17:01:03 <dons> syntaxfree: yeah, less talk, more code! :)
17:01:07 <syntaxfree> I always start these projects and tdrop them at 20% completion.
17:01:09 <dons> syntaxfree: want to do a web app?
17:01:19 <syntaxfree> I did about 35% of a Pancito-workalike.
17:01:21 <dons> there must be some reddit replacement you could port hpaste over to
17:01:23 <Igloo> I'm not sure, but I suspect so
17:01:29 <dons> ok
17:01:30 <syntaxfree> Months before I ever heard of Pancito.
17:01:36 <syntaxfree> dons: reddit replacement?
17:01:58 <bos> syntaxfree: people wrote a rash of reddit clones when the reddit heretics abandoned lisp for python.
17:02:01 * AStorm will obsolete xmms2 maybe :>
17:02:20 <AStorm> haxmms? (sounds like haskell xmas)
17:03:06 <syntaxfree> hmm. and what does Haskell have to do with Reddit?
17:03:09 <LoganCapaldo> hamms
17:03:15 <bd_> ?fresh
17:03:15 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package.cgi?name=zlib&version=0.3
17:03:15 <lambdabot> Haej
17:03:18 <lambdabot> http://tinyurl.com/2z7mgf
17:03:27 <dons> Igloo: we need more canonical names for hackage packages
17:03:29 <LoganCapaldo> (it could work on more than just X)
17:03:30 <syntaxfree> I mean, what does Hpaste have to do with reddit clones?
17:03:37 <dons> i.e. hackage.haskell.org/zlib/3.0
17:03:38 <dons> or some such
17:03:45 <Procyon> I'm dreaming of a haxmms, just like the ones I used to know....
17:04:03 <syntaxfree> dons: dons: one thing that has kept me from working on projects that are already out there is that I never finish chasing dependencies, and eventually drop it in frustration.
17:04:13 <dons> syntaxfree: its a haskell-based web app, developed in 3 days, that only needs a bit more work to become a reddit :)
17:04:17 <syntaxfree> I've been wanting to write lambdabot plugins, but I never manage to compile it!
17:04:36 <syntaxfree> I've chased all dependencies, and now I get bona-fide compiling errors.
17:04:49 <dons> ok, well, practice makes perfect!
17:04:57 <LoganCapaldo> HAMMS: HAMMS, A MultiMedia System
17:05:22 <LoganCapaldo> Also delicious
17:05:25 <AStorm> humms, Humms Useful Multimedia System
17:05:32 <LoganCapaldo> oooo
17:05:33 * Igloo makes a note
17:05:39 <syntaxfree> so most of what I *really* do is explore abstract mathematical structures with type classes.
17:05:47 <LoganCapaldo> pertier
17:05:53 <dons> Igloo: its possible to run hackage locally, for development?
17:05:55 <syntaxfree> ah, yes. I have zlib.
17:06:10 <syntaxfree> @google haskell reddit clone
17:06:13 <lambdabot> http://programming.reddit.com/info/ils6/comments
17:06:13 <lambdabot> Title: Gallery of impressive Haskell code, including a one-line wc clone with the same  ...
17:06:15 <Igloo> dons: I assume so, but I've never looked for the code
17:06:22 <syntaxfree> what's the story of reddit clones and hpaste?
17:06:25 <dons> I should ask Ross
17:06:26 <AStorm> But that's for after the exams
17:06:35 <Igloo> Now I think about it, I think SimonM might have asked Ross to write notes somewhere on doing so
17:06:37 <Pseudonym> KRAMMS: KRAMMS' Recursive Acronym Multi-Media System
17:06:50 <dons> syntaxfree: take the hpaste src as a code base + hack == you've got reddit!
17:07:41 <dons> dcoutts: hmm, any problem with me commenting out the (broken) lazyGet/Put, tagging, and releasing binary 0.2?
17:07:44 <dons> so we can get it on hackage
17:07:50 <AStorm> Another project is a real tiny SMTP server (I need one as I hate Exim and no other has required features)
17:07:55 <dcoutts> dons, go for it
17:08:01 * dons does so
17:08:26 <Igloo> Hmm, can't find what I'm thinking of, though
17:08:59 <syntaxfree> oh! is hpaste liberally-licensed?
17:09:03 <dons> yes
17:09:05 <master_baiter> supposed you have the following equation, in C: "int x; x == -x". solve for x
17:09:06 <dons> BSD3
17:09:30 <dons> dcoutts "lord of the cabal", do we have a recursive cabal-get that pull deps of hackage now?
17:09:43 <dons> i've got 10 deps in hpaste that mostly live on hackage
17:09:57 <dcoutts> dons, I believe so
17:10:08 <Igloo> cabal-install, I think?
17:10:12 <dcoutts> try it and report bugs
17:10:16 <dons> url?
17:10:22 <Igloo> It's in the cabal repo
17:10:23 <bd_> master_baiter: undefined behavior :D
17:10:31 <dons> ok. cabal darcs head?
17:10:37 <Igloo> yup
17:10:43 <bd_> master_baiter: actually, I suppose, since you never use that expression, it's defined and does nothing at all.
17:10:45 <allbery_b> x is whatever garbage was on the stack, and you don't know the answer because you're throwing away the result of the comparison :)
17:10:47 * dons gets
17:11:04 <syntaxfree> I'll try and see if I can get hpaste to work on my box and start playing with iut.
17:11:18 <syntaxfree> The problem with developing web apps for me is that I can't run a server on this box.
17:11:25 <syntaxfree> Weird NAT networking.
17:11:41 <dons> syntaxfree: run hpaste locally
17:11:47 <dons> it serves its own pages up
17:11:48 <syntaxfree> sure!
17:11:51 <syntaxfree> I know, I know.
17:11:52 <dons> and you can talk to it on localhost
17:12:01 * dons likes these webservers in a can
17:12:14 <syntaxfree> I know. I've done some "Hello world" happs thing before.
17:12:28 <syntaxfree> actually, I've done "Oh bitty box".
17:12:38 <dons> here's the helloworld web site in happs,
17:12:39 <dons> import HAppS
17:12:39 <syntaxfree> I have a campaign to replace "Hello world" with "Oh Bitty Box".
17:12:40 <dons> main = stdHTTP [noState, h () () $ ok plain (val "example")]
17:12:55 <dons> it'll listen on port 8000, and serve up little pages
17:13:10 <dons> i was able to get 1000/req/sec before my fork bomb made my machine unusable today
17:13:34 <musasabi> and the new SimpleHTTP2 code is not optimized yet :)
17:13:39 <dons> :)
17:13:43 <dcoutts> dons, so HappS should use that user level threading stuff :-)
17:13:47 <dons> musasabi: the bottleneck was the request script
17:13:52 <dons> too, not happs
17:13:58 <musasabi> ^^
17:13:59 <bos> dons: use ab
17:14:09 <musasabi> but most of the code under HAppS.Protocols.HTTP is quite optimized.
17:14:19 <dons> dcoutts: hmm, yeah, the 10M user level threads with epoll
17:14:20 <dons> tasty
17:14:25 <dons> musasabi: have you seen 'unify' ?
17:14:35 <dons> the epoll-based user level haskell threads?
17:15:12 <dcoutts> with customisable thread schedulers
17:15:22 <musasabi> no. or was it the system which redefined IO? (I already have epoll-based things in network-alt)
17:15:43 <dons> yeah, they use their own fakey bytestring
17:15:54 <dons> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
17:15:55 <lambdabot> Title: Unifying events and threads
17:15:57 <dons> ?where+ unify http://www.seas.upenn.edu/~lipeng/homepage/unify.html
17:15:58 <lambdabot> Done.
17:16:05 <dons> the little web server in their is quite nice
17:16:11 <dons> in their package
17:16:27 <znephf> c    ///
17:16:36 <dons> but we need to take the researchy code, stick it in darcs, and use it
17:16:39 <orbitz> do haskell implementations run into all the GC issues java does?
17:16:48 <dcoutts> orbitz, like what?
17:17:11 <orbitz> dcoutts: the larger a heap you allow your JVm ot have the longer your GC's take
17:17:29 <musasabi> dons: the problem is that HAppS at least needs to be portable (so windows too)
17:17:30 <dcoutts> dons, aye, HappS might be ideal as a test bed for that events/threads stuff
17:17:30 <syntaxfree> Happs is fun, yes.
17:17:38 <dons> orbitz: i think java has worse overheads, and they're running bytecode. GCs rarely (like once a year) an issue for me
17:17:39 <dcoutts> to see how it works in practise in bigger apps
17:17:47 <orbitz> for instance we are looking a ta peice of hardware specially made to run java code that lets you have heaps upto several hundred gigs
17:17:55 <dons> musasabi: yeah
17:17:58 <orbitz> dons: how large of a heap have you dealt with thouhg?
17:18:00 <dcoutts> orbitz, the heap grows dynamically
17:18:15 <dons> msuoh, did glguy mention the lock up we had running -threaded
17:18:23 <dons> musasabi: that went away removing -threaded ?
17:18:48 <orbitz> dcoutts: right, but lets say you have 40gigs of objects alive, what happens? i don't know how haskell's gc works in any way but once java does a full gc the ystem basically stops while it shuffle all the data around
17:18:53 <dons> orbitz: hmm, 800M ?
17:18:55 <musasabi> dons: what OS?
17:19:07 <dons> hpaste running on scannedinavian
17:19:10 <dons> so linux (?)
17:19:11 <Philippa> is there no JVM with an incremental GC yet?
17:19:13 <dcoutts> orbitz, yes, major GC's have to scan the heap
17:19:15 <orbitz> er whati just sai was for dons
17:19:24 <orbitz> Philippa: it does but that doens't help for a major gc
17:19:29 <musasabi> hmm. linux should be quite well supported.
17:19:41 * syntaxfree tries to blame something for his programming incompetence.
17:19:41 <dons> so you use -threaded in production?
17:19:42 <dcoutts> orbitz, and it's not incremental or parallel yet, though parallel is under development.
17:19:45 <syntaxfree> It must be my chair, or my monitor.
17:19:54 <Philippa> orbitz: ... it should do
17:20:05 <orbitz> dcoutts: this peice of java hardware gives us 'pausless gc'
17:20:18 <orbitz> Philippa: it is fine for minor collections but full collections require pausing teh system basically
17:20:22 <dons> i guess the point is that you tend not to have 40 gigs of objects on the heap ;)
17:20:26 <bd_> dons: Are you referring to Juan's -threaded lockups?
17:20:32 <dcoutts> musasabi, the nice thing about this threads/events idea is that the scheduler and IO layer are replaceable, so you can use epoll in linux and whatever in other OSs since the scheduler is just written in Haskell.
17:20:35 <orbitz> dons: depend son teh app
17:20:40 <dons> bd_: hmm, no. hpaste was locking yesterday when we played with -threaded
17:20:43 <bd_> ah
17:20:52 <bd_> http://hpaste.org/79 apparently on windows this locks up with -threaded
17:20:55 <bd_> but works on linux
17:21:08 <dons> sounds like a bug report waiting to be born?
17:21:20 <bd_> indeed
17:21:20 <Philippa> orbitz: yeah, the point is you shouldn't ever need to do a full collection
17:21:25 <musasabi> dons: iirc we run the production code without -threaded and examples with -threaded.
17:21:26 <allbery_b> I think  in haskell if you have that much on the heap it's usually a bug and you're going to run out of heap no matter hwat gc does :)
17:21:27 <orbitz> Philippa: why not?
17:21:42 <Philippa> because you only need to collect as fast as you allocate
17:22:01 <Philippa> incremental GC means you can drop a GC and pick it up again later
17:22:11 <Philippa> so you never really have to do a full collection on the heap as-is
17:22:16 <dons> musasabi: on a multiproc machine, would my happs app be able to use smp, to have a couple of threads handle requests?
17:22:20 <Philippa> you can just keep running through it as you have time to
17:22:29 <orbitz> Philippa: do you knwo why java's gc still does major gc's in time?
17:23:06 <Philippa> orbitz: illuminate me. Oh, and name the JVM you're talking about
17:23:10 <bd_> Philippa: Incremental GC has runtime overhead though, I thought? Though I suppose it might not be so bad in a lazy language
17:23:17 <bd_> pure rather
17:23:35 <Philippa> bd_: it does, yes. But on a big enough system that's potentially a price worth paying
17:23:55 <orbitz> Philippa: we use sunspot (or hotspot?)
17:24:08 <musasabi> dons: yes, at least theoretically. (I haven't profiled on such machines)
17:24:49 <Philippa> orbitz: I say that because while I'm open to the idea the standard might mandate more than I know it does, GC behaviour isn't a property of the language alone
17:25:39 <dons> musasabi: ok. when i set up the 16 core box, you might want an account :)
17:26:02 <bos> interestingly, uncons makes my parser fractionally but reliably slower.
17:26:14 <dons> bos, inline?
17:26:18 <bos> yep
17:26:29 <dons> (its really important for exposing the bytestring internals, and hence all that strictness)
17:26:32 <bos> sure
17:26:57 <musasabi> dons: sounds interesting :)
17:28:00 <bos> basically, the only piece of inlining that wins for me is the satisfy (match one token with a predicate) combinator.
17:28:15 <bos> inlining that gives me 50%. everything else slows the parser down.
17:29:03 <dons> ?remember sorear Haskell-98 style records are widely acknowledged as sucking
17:29:03 <lambdabot> Done.
17:29:15 <dons> bos, hmm. ok.
17:29:16 <mathewm> anyone have a lead on a good calendar/date-manip library for haskell?
17:29:28 <dons> and you're not yet doing the separate 'current strict buffer' and 'lazy tail' split?
17:29:31 <dons> in the parser state?
17:29:36 <bos> dons: not yet, no.
17:29:45 <dons> mathewm: yeah, 'time' ?
17:29:47 <dons> ?where time
17:29:48 <lambdabot> I know nothing about time.
17:30:01 <bd_> ?where binary
17:30:02 <lambdabot> http://darcs.haskell.org/binary
17:30:07 <dons> ?where+ time http://hackage.haskell.org/cgi-bin/hackage-scripts/package.cgi?name=time&version=1.0
17:30:07 <lambdabot> Done.
17:30:16 <mathewm> I will look more at time, but I was hoping for Date -> DayOfWeek -> Date
17:30:29 <dons> it provides Data.Time.Calendar.WeekDate,
17:30:30 <mathewm> given a date, I want the next 'Monday'
17:30:42 <dons> ah ok. i actually have code for the next 'Tuesday'
17:30:53 * mathewm grins
17:30:54 <bos> dons: i'd sort of expect some fps code to show up in the profile if it was a performance problem.
17:30:56 <dons> would you like to adopt that. you'll have to hack it to work for 'Monday's though
17:31:15 * dons hunts for the code
17:31:15 <bos> unless it's compiled without -prof. never mind me.
17:31:15 <mathewm> I might generalize it to all weekdays , M-F :)
17:31:43 <bos> the firehose of haskell knowledge into my brain is a bit unreliable.
17:31:52 <dons> well, don't want to drown in abstractions now, mathewm !
17:32:21 <dons> findTuesday :: CalendarTime -> IO String
17:32:22 <dons> findTuesday time@(CalendarTime _ _ _ _ _ _ _ Tuesday _ _ _ _ )
17:32:22 <dons>     = return $ clean $ formatCalendarTime defaultTimeLocale fORMAT time
17:32:22 <dons> findTuesday time
17:32:22 <dons>     = let (TOD secs ps) = toClockTime time
17:32:24 <dons>       in do time' <- toCalendarTime (TOD (secs + 60*60*24) ps)
17:32:26 <dons>             findTuesday time'
17:32:45 <dons> so it just increments the day from now in a loop until it hits Tuesday
17:32:51 <dons> you can abstract over 'Tuesday' if you like
17:32:57 <dons> http://www.cse.unsw.edu.au/~dons/code/progress/progress.hs
17:33:10 <mathewm> dons: thanks
17:33:24 <dons> its run reliably for the last 4 years
17:33:31 <dons> so i'm fairly happy with it
17:34:22 <bos> parsing a 100,000 line file in 3 seconds seems ok to me.
17:34:37 <bos> maybe i won't worry any further about optimising this thing.
17:34:41 <dons> bos, nice.
17:35:00 * allbery_b used fromEnum + math to locate the next Saturday
17:35:29 <LoganCapaldo> is math Cabal-ised?
17:35:33 <dons> what happens with leap years and so on?
17:35:56 <dons> that was the concern i had, so i used pattern matching and the internal calendar lib gunk for dealing with that
17:38:08 <robreim> dons: any idea what might cause this in hs-plugins? user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
17:41:32 <dons> hmm
17:41:46 <dons> i've never seen that
17:41:50 <bos> hmm, ghc -O is only 50% faster than perl at parsing this file.
17:42:07 <dons> possibly missing loading rt before linking?
17:42:16 <bos> parser combinators: you win some, and you lose some.
17:42:23 <dons> bos, try -fliberate-case-threshold=1000
17:42:32 <dons> and maybe strictify the state type?
17:42:50 <dons> but yeah, you get flexibility, at the cost of some speed (compared to ,say , happy+bytestring)
17:43:15 <bos> -fliberate-case-threshold=1000 loses 10% on performance :-)
17:43:27 <dons> heh
17:43:33 <dons> you win some, you lose some
17:43:34 <mathewm> ?hoogle m (m a) -> m a
17:43:36 <lambdabot> Prelude.id :: a -> a
17:43:36 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:43:36 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:43:40 <dons> what about:  -O2 -optc-O3 ?
17:43:44 <bd_> mathewm: join?
17:43:46 <dons> -funbox-strict-fields
17:43:48 <mathewm> yeah!
17:43:49 <mathewm> thanks
17:44:04 <dons> ?djinn m (m a) -> m a
17:44:05 <lambdabot> -- f cannot be realized.
17:44:07 <bd_> dons: -optc-O3 is often a bit slower than -optc-O2 for me here :)
17:44:07 <dons> bah
17:44:18 <dons> yeah, sometimes it causes my programs to segfault
17:44:20 <dons> thanks gcc
17:44:20 <bd_> ?djinn Monad m => m (m a) -> m a
17:44:20 <lambdabot> Cannot parse command
17:44:23 <bd_> heh
17:44:40 <dons> i guess they don't use a typed IR or something ;)
17:44:43 <bd_> apparently gcc's priorities are not so much on correct code as 'good-enough' code >.>
17:45:03 <robreim> dons: ok, thanks.
17:45:15 <dons> robreim: compile with -DDEBUG
17:45:22 <dons> (if you're not already)
17:45:24 <bd_> [of course, with -optc you're also putting the evil mangler into the mix ...]
17:45:28 <sjanssen> bos: is your bytestring parser on the web?
17:45:44 <dons> yeah, get sjanssen on the case
17:45:48 <bos> sjanssen: not yet, it's just a modified version of jeremy shaw's stuff that dons pointed me at.
17:45:59 <dons> bos, stgot it in darcs?
17:46:04 <bos> yep.
17:46:10 <dons> you could stick it in darcs, i can upload it to darcs.haskell.org
17:46:15 <dons> and you could start getting contribs right now
17:46:19 <robreim> dons: ah, ok.
17:46:41 <sjanssen> bos: I think I've got a generalized version of Parsec working
17:46:51 <bos> sjanssen: oh? nice!
17:46:53 <dons> oh, you guys should really compare notes then
17:47:23 <bos> yeah, jeremy's cut-down parser loses quite a few nice parsecy features, though it's much easier to understand and modify for your noob.
17:47:30 <dons> Can I remark on how great it is to see new fundamental code coming out *every single day* from this channel
17:48:59 <malsyned> dons: what were those characters you typed to bos a few lines back supposed to be?  Xchat mangled them on me.  From "bos, st[?][?]got it in darcs?"
17:49:15 <syntaxfree> I have to say I admire how people reconcile a "concrete" attitude with an "abstract" outlook at computing.
17:49:40 <dons> malsyned: just some random wifi time out gunk. i wish irssi would just work over laggy links
17:49:49 <syntaxfree> There's something wrong with me, I'm always lost in abstraction, contemplating the possibilities.
17:49:52 <allbery_b> malsyned: they're ASCII DEL (0x7f)
17:49:55 <Philippa> syntaxfree: it's mostly just a case of where you sit in the stack
17:49:59 <Philippa> comes with practice
17:49:59 <allbery_b> he tried to backspace
17:50:10 <dons> yeah, and irssi timed out on the ESC
17:50:20 <dons> letting the chars through raw
17:50:28 <Philippa> you can take a "concrete" attitude at any level, just so long as it's expressive enough for there to be anything worth being concrete about
17:51:35 <ihope> Peirce's law!
17:52:20 <syntaxfree> I'm always starting toy projects and they never pass 20% completion.
17:52:44 <Philippa> figure out what a version 0.1 would look like, or do a spike solution
17:52:54 <Philippa> call that 100% completion but also have a version 2 in mind
17:52:57 <syntaxfree> I have hundreds of files with random snippets of code I can't even understand a year later, and I'm always abandoning toy projects because I thought of something more interesting in the process.
17:53:00 <Pseudonym> The nice thing about Haskell is a 20% complete toy project often does something interesting.
17:53:02 <Philippa> that tends to at least get v0.1 written
17:53:18 <Philippa> especially if 0.1's just about doable in an inspired night's hacking
17:53:19 <syntaxfree> Pseudonym: which might be why I'm attracted to Haskell.
17:53:25 <syntaxfree> Philippa: that's my approach to blogs.
17:53:37 <Pseudonym> Haskell: For smart people with short attention spans.
17:53:38 <syntaxfree> If I start writing something and leave it for later conclusion, I never do.
17:53:56 <xpika2> syntaxfree: be thankful you didnt have to work on the last %20 of the code which takes %80 of the time to complete
17:53:58 <malsyned> Philippa: wtf "spike solution"?
17:53:58 <syntaxfree> So I publish whatever I can scrape together in one sitting.
17:54:16 <syntaxfree> That's why my posts tend to be uninformed and poorly researched.
17:54:25 <Pseudonym> lambdabot was kinda like that.
17:54:32 <syntaxfree> I'm just trying to put down whatever insight I have so I've *done* something.
17:54:51 <syntaxfree> In my other blog, I have committed myself to writing two-paragraph posts.
17:55:17 <syntaxfree> They're often unreadable dense masses of thought, but at least Im writing stuff.
17:55:19 <Philippa> malsyned: the simplest thing that does the bit that's interesting while ignoring other concerns /including maintainability/
17:55:32 <Philippa> at least, you don't build infrastructure for maintainability
17:56:10 <malsyned> Philippa: thx
17:56:11 <Philippa> similarly, a spike solution IRC client probably doesn't have a nice UI - it may or may not be text mode
17:56:53 <syntaxfree> The feeling that there's something wrong with me that needs psychiatric evaluation has been increasing by the day.
17:57:06 <malsyned> syntaxfree: ever since you started using haskell? ;-)
17:57:43 <malsyned> My friends' feeling that there's something similarly wrong with me has certainly been increasing since I did.
17:58:08 <Philippa> I've got an interesting bundle of diagnoses already, no biggie
17:58:12 <malsyned> "but what if you really, really, really want a side-effect?" "nope." "you're mad."
17:58:21 <Philippa> heh
17:58:26 <Philippa> that's teasing, that is :-)
17:58:39 <Philippa> I know where to get my side-effects if I want them. They're just not side-effects in Haskell
17:59:16 <Philippa> http://c2.com/xp/SpikeSolution.html
17:59:18 <lambdabot> Title: Spike Solution
17:59:24 <musasabi> malsyned: I was thinking of medicine when I read that and thinking this was -blah.
17:59:56 <syntaxfree> maybe Haskell helps in that I can get some satisfaction without needing to step out of my "hit and run" default behaviour.
18:00:36 * allbery_b suddenly wonders if Haskell attracts depressives somehow
18:01:10 <Philippa> allbery_b: smarter people're more likely to be depressed, IIRC. Not my only diagnosis, though, and not the one I'd say has any relevance to why I like Haskell
18:01:15 <malsyned> If I try to read a c-formatted string using Prelude.read, will some subtle difference in syntax trip me up?
18:01:18 <bd_> malsyned: tsk, you've got unsafePerformIO :)
18:01:20 <Philippa> (except insofar as it doesn't depress me as often as eg Java does)
18:02:06 <allbery_b> (I know damned well I've got clinical depression.  unrelated to and predating my starting to play with Haskell.)
18:03:01 <malsyned> bd_: yikes.  I may have it, but I've yet to want it.
18:03:17 <syntaxfree> I don't think I have clinical depression in itself.
18:03:20 <allbery_b> malsyned: as in read "\"foo\"" :: String?  off the top of my head, \ddd is octal digits in C and decimal in Haskell (and not limited to 3 digts, so something like "\0334" will not do what you expect)
18:03:42 <malsyned> allbery_b: exactly the sort of thing I was wondering about.  Thanks.
18:03:45 <bd_> > ord '\10\
18:03:46 <lambdabot>  Improperly terminated character constant
18:03:48 <bd_> > ord '\010'
18:03:49 <lambdabot>  10
18:03:55 <bd_> malsyned: there's your subtle difference :)
18:04:09 <bd_> wrt read on C strings
18:04:24 <malsyned> damn.  now I've got to write a c-string reader.
18:04:28 <bd_> also, C99 spec lists a \? escape, which is not in the Haskell 98 report
18:04:37 <bd_> > ord '\?'
18:04:37 <lambdabot>  Illegal escape sequence
18:04:43 <bd_> It translates to ?
18:05:11 <malsyned> yeah.  \? is because of trigraphs.  I just discovered that a second ago reading the source to ls (whose output I'm trying to parse)
18:05:22 <allbery_b> C also specifies that \x for otherwise undefined x expands to x
18:05:27 <bd_> malsyned: It should be easy enough to mechanically translate the C spec's grammar to parsec or what-have-you
18:05:35 <bd_> > read "'\\?'"
18:05:36 <lambdabot>  Add a type signature
18:05:37 <allbery_b> oh, and I think one of the later Cxx standards says \xXX is hex
18:05:39 <bd_> > read "'\\?'" :: Char
18:05:40 <lambdabot>  Exception: Prelude.read: no parse
18:05:51 <sceadu> could someone help me get emacs configured correctly to work with haskell mode? the functions for ghci mode are void even after being loaded for some reason (same thing with haskell inferior mode, etc. it seems)
18:05:51 <bd_> allbery_b: yes, C99 specifies that at least
18:06:08 <malsyned> "??=" is equivalent to "#" in C, even in string constants.  You have to say "?\?=" to get that literal string.  In strict ansi, anyway.
18:06:34 <sjanssen> bos: http://darcs.haskell.org/~sjanssen/genparsec/
18:06:34 <syntaxfree> What I have is emotion amplification.
18:06:36 <lambdabot> Title: Index of /~sjanssen/genparsec
18:06:53 <sjanssen> that is a darcs repo, by the way
18:07:00 <syntaxfree> SMall frustrations take me to the bottom of the dark and neverending sea. Likewise, small victories lead me to huge, huge euphoria where I go out tapdancing.
18:07:54 <syntaxfree> oh wow. Mega lag.
18:08:01 <Philippa> syntaxfree: that can be consistant with clinical depression
18:08:11 <syntaxfree> I just got dozens of lines scrolling by, and the conversation went out :$
18:08:47 <syntaxfree> yeah, well. My parents can't afford any kind of clinical help right now, and I'm resolved not to drop out of graduate school until I get my master's.
18:09:08 <syntaxfree> *Then* I might get a soul-crushing job as an economist somewhere and find myself some professional help
18:09:31 <syntaxfree> bah, I'll take this conversation to -blah.
18:09:32 <syntaxfree> I'm sorry.
18:15:00 <allbery_b> syntaxfree: compilation-at-run-time = the Forth family
18:15:19 <malsyned> crap.  I left my copy of K&R at work.  Anybody know if there's a copy online or something?
18:16:00 <mbishop> I have it in pdf somewhere
18:16:00 <allbery_b> I doubt it, although you may be able to 10% it from Amazon's preview stuff
18:16:19 <mbishop> I don't think it's a very legal version though (but I do own the book)
18:16:44 <malsyned> yeah, but the grammar's in the back, and I doubt that's the 10% they'll give me.  Fortunately, comp.lang.c FAQ to the rescue
18:16:44 * Philippa reminds people that this chan is logged and logs are posted on the web
18:17:23 <mbishop> Heh, books? what are these books of which you speak?
18:17:25 * mbishop whistles
18:17:26 <malsyned> Philippa: of course, I was talking about a legal version.  I didn't think K&R was free, but on the other hand, it's been around so long I wouldn't have been surprised to find I was wrong.
18:17:34 * syntaxfree doesn't mind. If he ever gets a diagnosis, he'd mention it in his CV.
18:18:07 <allbery_b> it gets updated periodically.  possibly the old pre-ANSI one is available somewhere
18:18:28 <allbery_b> ...but even there I think it's still in copyright
18:18:30 <mbishop> actually if I'm not mistaken, I got my copy of K&R off of some website...it might be old, or a draft or something actually, *shrug*
18:18:40 <mbishop> I never use it, just use the actual book...if I ever use that, that is :)
18:18:56 <allbery_b> possible.  I have a final draft of the C99 standard, which was legall for distribution
18:28:18 <malsyned> allbery_b: where'd you get it?  you think it's still available legally?  or if you can legally distribute it, could I have a copy?
18:30:04 <allbery_b> hrm.  actually I won der if I do still have it, or if it's sitting on the disk that died that I should send in to see if it can be recovered (failure mode suggests it's the electronics, not the media, that failed)
18:31:57 <allbery_b> aha.  http://home/att.net/~jackklein/c/standards.html has a link to it in several formats
18:32:12 <allbery_b> oops
18:32:30 <allbery_b> http://home.att.net/~jackklein/c/standards.html
18:32:32 <lambdabot> Title: C And C++ Standards
18:32:35 <allbery_b> better :)
18:32:55 <malsyned> hot.  thanks
18:58:40 <syntaxfree> allbery_b: I have a huge, 1000+ page PDF called  "The New C Standard: an economic and cultural commentary">
18:59:01 <bd_> oO
18:59:37 <syntaxfree> If I recall correctly, it refers to C99.
18:59:52 <bd_> hmm, not this, is it? http://citeseer.ist.psu.edu/505143.html file seems too small...
19:00:01 <bd_> oh
19:00:04 <bd_> http://www.knosof.co.uk/cbook/cbook.html
19:00:05 <lambdabot> Title: The New C Standard: a free download
19:00:29 <syntaxfree> Jones (2002)?
19:01:04 <syntaxfree> Mingus:~/Documents/artigos syntax$ du Jones\ \(2002\)\ -\ The\ New\ C\ Standard
19:01:05 <syntaxfree> \,\ An\ Economic\ and\ Cultural\ Commentary.pdf
19:01:05 <syntaxfree> 15560   Jones (2002) - The New C Standard, An Economic and Cultural Commentary.pdf
19:01:15 <syntaxfree> that might not be the original filename. I rename PDFs in that fasihon.
19:01:46 <syntaxfree> anyway, I can email it to you if you want to :)
19:02:25 <malsyned> syntaxfree: is that the same thing as can be obtained from the link bd_ posted?
19:02:47 <syntaxfree> dunno, didn't open the link.
19:03:02 <syntaxfree> if it's written by "Jones" and published in 2002, chances are it is.
19:03:12 <malsyned> it is.  so don't worry about it, but thanks.
19:03:21 <bd_> version 1.0b, aug 5 2005?
19:03:32 <syntaxfree> that I don't know :)
19:03:59 <malsyned> also, I just realized that I what I want to parse aren't strictly C strings.  I was confusing the output of ls --quoting-style=c with the output of find -ls.
19:04:04 <bd_> well, the title's right, and it looks quite huge :)
19:04:20 <malsyned> the output of find -ls is much easier to handle.
19:04:35 <malsyned> or at least, much less prone to the effects of a standards process on what should be a simple operation ;-)
19:06:42 <bd_> malsyned: You could use System.Posix :)
19:07:04 <syntaxfree> haha. the Happs hello world example fails.
19:07:13 <bd_> hm, yep, 1616 pages, looks like the one
19:07:17 <syntaxfree> how depressing!
19:07:47 <musasabi> Did I break it again?
19:08:04 <malsyned> bd_: Yeah, I have spent some time torn between parsing the output of find -ls or basically reimplementing its functionality but with file names output with Prelude.show so that they can be read back in by Prelude.read
19:08:18 <musasabi> syntaxfree: any particular error?
19:08:21 <syntaxfree> ah, yes.
19:08:23 <syntaxfree> @paste
19:08:23 <lambdabot> http://hpaste.org (Haskell pastebin)
19:08:36 <bd_> malsyned: why not do it all in-process?
19:09:20 <hpaste>  syntaxfree pasted "happs hello world fails!" at http://hpaste.org/84
19:09:31 <malsyned> bd_: my eventual goal is to produce a file which records metadata and symlink destinations in order to commit it to a darcs repo, and then a utility to restore them from that file.
19:10:47 <syntaxfree> that "Hello world!" s straight from my very own file:///Users/syntax/HAppS/doc/tutorial.html
19:10:49 <bd_> malsyned: Hmm, does it need to use the ls format for that, though?
19:11:09 <bd_> malsyned: also, it's probably be better in the long run to add new patch types to darcs for that sort of thing...
19:12:17 * allbery_b thinks e heard something about a HAppS API change recently
19:12:32 <allbery_b> also, your error message cites line 34 of a 20-line file :)
19:12:57 <musasabi> syntaxfree: does examples/hello.hs work for you?
19:12:58 <dons> did I go too far?? http://programming.reddit.com/info/10fcn/comments/c10is1?context=5
19:13:01 <lambdabot> Title: Python is soup-in-a-cup (reddit.com), http://tinyurl.com/23eh2a
19:13:13 <malsyned> bd_: in the long run, that would be better.  However, I'm trying to get this done quickly so I can move on to other stuff.  I plan some day to come back and add those things to darcs, when I've got time and space in my head for the inevitable platform-independence battle.
19:13:25 <musasabi> syntaxfree: the API changed with the old api being available under HAppS.Protocols.SimpleHTTP
19:14:10 <musasabi> syntaxfree: http://haskell.org/haskellwiki/HAppS_tutorial is more current.
19:14:11 <lambdabot> Title: HAppS tutorial - HaskellWiki
19:14:21 <syntaxfree> ah, yes. examples/hello.hs compiled.
19:14:30 <syntaxfree> so I basically should ignore the present tutorial. cool.
19:14:40 <musasabi> syntaxfree: and look at the wiki tutorial.
19:14:49 <syntaxfree> thanks.
19:15:22 * syntaxfree first changes "Hello world" to "Oh bitty box!"
19:15:42 * syntaxfree wants to eventually replace "Hello world!" with "Oh bitty box!" everywhere.
19:17:28 <musasabi> now sleep for real ->
19:17:40 <syntaxfree> there's something wrong with MIME headers or something.
19:18:00 <syntaxfree> <h1>Oh bitty box!</h1> actually opens as a text file saying that in Safari.
19:18:14 <syntaxfree> Anyway, I should probably find out about that reading the new tutorial.
19:18:43 <syntaxfree> stm ( Software Transactional Memory, comes with GHC 6.6 )
19:18:43 <syntaxfree> template-haskell ( http://www.haskell.org/th, comes with GHC 6.6 )
19:18:46 <lambdabot> Title: Template Haskell
19:18:54 <syntaxfree> phew, I'm glad it does. I can see myself pulling my hair out in frustration.
19:20:01 <musasabi> syntaxfree: see ctype. but ->
19:20:19 <syntaxfree> -> = "I'm going to bed"?
19:20:26 <syntaxfree> I guess that means you're going to read in bed.
19:24:28 <syntaxfree> @tell musasabi how up-to-date is Haddock documentation for HAppS?
19:24:28 <lambdabot> Consider it noted.
19:25:00 <malsyned> haskell Chars are unicode code points?
19:25:31 <allbery_b> yeh
19:25:34 <bos31337> > Foreign.Storable.sizeOf
19:25:35 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
19:25:39 <allbery_b> > maxBound :: Char
19:25:40 <lambdabot>  '\1114111'
19:26:34 <malsyned> so if I've got, say, a list of utf-8-encoded characters, what's the best way to get to a list of Chars?
19:27:26 <bd_> A list of utf-8 encoded characters would be closer to [Word8] or Data.ByteString, really. I don't know if there's a utf8 parser in the standard libraries though...
19:27:30 <sjanssen> malsyned: there aren't any UTF-8 decoders in the standard libraries
19:28:23 <malsyned> oh well.  I guess decoding UTF-8 isn't that tough.
19:28:28 <allbery_b> apparently there's one in yhc that should work
19:28:53 <bos31337> sjanssen: is your parsec generalisation published anywhere yet?
19:28:54 <sjanssen> malsyned: there is a decoder that you can yank out of jhc
19:29:05 <allbery_b> oh, jhc, not yhc.  sorry
19:29:15 <syntaxfree> jhc  = Japan Haskell Compiler? ;)
19:29:25 <sjanssen> bos: darcs get http://darcs.haskell.org/~sjanssen/genparsec
19:29:29 <lambdabot> Title: Index of /~sjanssen/genparsec
19:29:29 <allbery_b> @go jhc utf8
19:29:32 <lambdabot> http://repetae.net/repos/jhc/UTF8.hs
19:29:36 <sjanssen> bos31337, that is
19:29:54 <bos> sjanssen: thanks
19:30:24 <malsyned> allbery_b: awesome.  thanks!
19:30:40 <dons> Challenge, anyone got some thoughts about the double instantiation problem here, http://programming.reddit.com/info/10fcn/comments/c10gzu
19:30:42 <lambdabot> Title: Python is soup-in-a-cup (reddit.com)
19:30:48 <dons> its pretty tricky, and my solutoin cheats
19:31:20 <bos> dons: darcs get http://darcs.serpentine.com/bytestringparser/
19:31:22 <lambdabot> Title: Index of /bytestringparser
19:31:22 <dons> (one soln is to store the function instantiated at two different types in the dictionary, of course)
19:31:26 <dons> cheers!
19:31:38 <sjanssen> bos: I'd be especially interested in any performance observations you can make
19:32:03 <syntaxfree> dons: d-oh, how did discussion get that far?
19:32:11 <bos> sjanssen: sure.
19:33:28 <dons> syntaxfree: basicalyl we stopped talking about the python flame, and started talking about code :)
19:33:54 * dons learnt a few months ago you should *never* mention other languages when talking about haskell
19:34:10 <dons> or no one will read beyond 'foo can't do what bar can'
19:34:22 <syntaxfree> I haven't still done the blog thing to its maximum.
19:34:30 <syntaxfree> I might drop it after one or two controversial posts more.
19:34:46 <dons> i'm not sure it helps us though, as a commuity, to be provocative like that
19:34:59 <bos> no.
19:35:01 <dons> we are not the lisp community
19:35:03 <syntaxfree> maybe.
19:35:25 <dons> so i'd encourage you not to write those kinds of semi-flames: they turn people off haskell
19:35:32 <syntaxfree> as I said, I might retire the blog soon.
19:35:56 <sjanssen> dons: sleepingsquirrel's problem was discussed on haskell-cafe recently
19:36:07 <sjanssen> naturally, Oleg had a wacky solution
19:36:14 <dons> sjanssen: ah rings a bell
19:36:19 <dons> was it the same problem?
19:36:33 <dons> (sleepingsquirrel is Greg Bucholz, iirc)
19:37:45 <malsyned> I'm a little lost about why the inferred type signature of twice is as restrictive as it is.
19:37:51 <sjanssen> dons: actually, the problem was mapTuple
19:37:58 <dons> bos, do di you put your wrapped binary online somewhere?
19:38:23 <bos> dons: yeah, but it's out of sync with the current binary stuff.
19:38:28 <syntaxfree> dons: anyway, I took your earlier suggestion to heart and I'm learning some basic Happs
19:38:32 <dons> malsyned: the problem is that you're taking a functoin from a -> b, but using it as something of (x -> y) and (y -> z), with arbitrary class contraints as weel
19:38:33 <sjanssen> mapTuple f (a, b) = (f a, f b) -- a and b have different types, so it's practically the same issue
19:38:36 <syntaxfree> If this ever works out, I'll look at hpaste next.
19:38:44 <dons> so finding the most general type for all those polymorphic types is tricky
19:38:58 <dons> sjanssen: ah yes
19:39:08 <dons> hmm
19:39:28 <malsyned> dons: I see.  so because it's got to be an (x -> y) and a (y -> z), the only way to satisfy that is (y -> y)?
19:39:30 * LoganCapaldo pretends theres a macro keyword in Haskell
19:39:47 <LoganCapaldo> macro twice f x = f (f x)
19:39:49 <dons> ?let twice f = (f *** f)
19:39:50 <lambdabot> Defined.
19:40:22 <sjanssen> dons: Oleg solved it by making a dummy type for the operation (like data SHOW = SHOW), and then a MPTC called Apply
19:40:27 <dons> malsyned: and the class constraints get in the way
19:40:33 <dons> sjanssen: yeah
19:40:42 <dons> that's what i wanted to do (and effectively do anyway)
19:40:50 <dons> you map the operatoin into the type level
19:40:58 <dons> and store the concrete function in the instance
19:41:03 <svref> What's the elegant way to test if a list is sorted?
19:41:05 <dons> then use the type to look up what you need
19:41:55 <MechaBlue> Any good primers on character encoding in Haskell?
19:42:39 <sjanssen> @type \xs -> all (uncurry (>=)) . zip xs $ tail xs -- this is how I'd do it, svref
19:42:41 <lambdabot> forall a. (Ord a) => [a] -> Bool
19:43:13 <bd_> MechaBlue: character encoding?
19:43:36 <malsyned> svref: sorted l = map (uncurry (<)) $ zip l (tail l)
19:43:38 <malsyned> is one way
19:43:39 <allbery_b> > length (groupBy (\l r -> l < r) [1..20])
19:43:41 <lambdabot>  1
19:43:45 <MechaBlue> I need to read in text data that can be in ASCII, ISO-8859-1, or UTF-8
19:44:08 <bd_> ?where iconv
19:44:08 <lambdabot> I know nothing about iconv.
19:44:16 <sjanssen> @check (\xs -> (all (uncurry (>=)) $ zip xs $ tail xs) == (xs == sort xs)) :: [Int] -> Bool
19:44:16 <svref> never would have thought of using "zip".
19:44:17 <lambdabot>  Falsifiable, after 0 tests: [-3,0]
19:44:26 <bd_> MechaBlue: http://hackage.haskell.org/packages/unstable/iconv/ possibly relevant...
19:44:28 <lambdabot> Title: Index of /packages/unstable/iconv
19:44:35 <sjanssen> @check (\xs -> (all (uncurry (<=)) $ zip xs $ tail xs) == (xs == sort xs)) :: [Int] -> Bool
19:44:37 <lambdabot>  OK, passed 500 tests.
19:44:45 <sjanssen> quickcheck++
19:44:57 <malsyned> svref: sjanssen is right.  <= is the right test, now <.  my bad.
19:45:36 <MechaBlue> bd_: Thanks; I'll have a closer look.
19:45:38 <bos> sjanssen: there are quite a few genparsec combinators marked TODO - i can't compile my parser.
19:46:18 <malsyned> That's the second time today I've used that idiom.  Is there a canonical way of expressing 'map (uncurry f) $ zip l $ zip tail l' ?
19:47:19 <sjanssen> bos: all of the TODOs were just missing type signatures, I think
19:47:31 <sjanssen> bos: which functions are missing?
19:47:41 <sjanssen> malsyned: use zipWith
19:47:43 <Cale> ap (zipWith f) tail
19:47:45 <sjanssen> @type zipWith
19:47:47 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
19:47:56 <Cale> @type ap (zipWith f) tail
19:47:58 <lambdabot> Not in scope: `f'
19:48:00 <Cale> er
19:48:03 <bos> sjanssen: of the ones i use, manyTill, eof, count
19:48:05 <Cale> @type \f -> ap (zipWith f) tail
19:48:07 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
19:48:40 <Cale> > ap (zipWith (-)) tail [1,2,3,4,5,10,7]
19:48:41 <lambdabot>  [-1,-1,-1,-1,-5,3]
19:48:53 <bos> @hoogle eof
19:48:54 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
19:48:54 <lambdabot> Text.Read.EOF :: Lexeme
19:48:54 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
19:48:57 <malsyned> so, svref: sorted l = and $ zipWith (<=) l $ tail l
19:49:12 <Cale> I recommend not chaining $'s like that.
19:49:21 <malsyned> inefficient or just ugly?
19:49:28 <Cale> just ugly
19:49:28 <svref> Cale: why?
19:49:33 <Cale> It's better to use composition
19:49:44 <svref> Cale: why??
19:49:59 <Cale> because compositions are easier to see refactorings in
19:50:07 <Cale> composition is a nice associative operation
19:50:15 <Cale> $ is just function application
19:50:22 <Cale> which isn't associative
19:51:01 <Cale> I personally consider the associativity of $ to be a bug in the standard as well :)
19:51:03 <svref> Today I was wishing for a macro, called foo, such that foo a b c d e was equal to a $ b $ c $ d $ e
19:51:12 <sjanssen> bos: should things like manyTill return ByteStrings?
19:51:31 <Cale> uh...
19:51:37 <svref> Then I realized there weren't macros.  :*(
19:51:44 <bos> sjanssen: i think so.
19:51:47 <Cale> Also, why do you want that?
19:52:04 <svref> space bar is easier to hit than space-$-space!
19:52:15 <Cale> f $ x = f x
19:52:23 <sjanssen> bos: not sure how to handle that in genparsec att the moment
19:52:32 <bos> sjanssen: it's not clear to me what the type of eof should be.
19:52:37 <chessguy> 'evening haskellers
19:52:39 <svref> Oh, did I mention, I wanted it variable arity.
19:52:41 <chessguy> !paste
19:52:42 <hpaste> Haskell paste bin: http://hpaste.org/
19:52:54 <bos> sjanssen: yes, returning bytestrings isn't all that urgent :-)
19:53:05 <bos> i think that getting the current signatures worked out is more so.
19:53:15 <sjanssen> bos: Haskell infers "eof :: (Show [tok], Show tok, Viewable c tok) => GenParser c tok st ()"
19:53:39 <chessguy> i had an ephiphany today. i know why haskell is so difficult for newcomers
19:53:49 <bos> sjanssen: yes, but then you get     No instance for (Viewable c Char)
19:53:49 <bos>       arising from use of `eof' at GCC/Dump/GenParsecParser.hs:11:22-24
19:53:50 <Cale> I don't know whether it's any easier for you to type, but I recommend replacing a $ b $ c $ d $ e with a . b . c . d $ e
19:54:13 <Cale> or something like that... usually there are a few options
19:54:20 <sjanssen> bos: oh!  I need to push a patch
19:54:33 <malsyned> Cale: I would usually agree, but functions like zipWith don't lend themselves to readability in that format.
19:54:43 <bos> chessguy: ...and?
19:54:49 <chessguy> it has to do with code readability. take a language like perl, which isn't known for it's readability
19:55:00 <Cale> You can always suck a bit more into that end part.
19:55:09 <chessguy> if anything, it's known for not being easily readable, because of all the punctuation
19:55:26 <svref> Cale: well, '.' is unshifted, and closer to the home keys, so yeah it helps some.
19:55:28 <malsyned> then again, my code wasn't readable in that way either.  I think I prefer 'sort l = and $ zipWith (<=) l (tail l)' best
19:55:29 <bos> you're going to complain about infix operators like ~~~~?
19:55:29 <sjanssen> bos: darcs pull to get the Viewable instance for ByteString
19:55:47 <chessguy> but once you learn a little, it's not too hard for you to be able to get an idea how to read over code
19:55:54 <Cale> malsyned: yeah, that's how I'd probably write it
19:56:11 <chessguy> but tell me, what's an english way of reading this fairly typical snippet of code:
19:56:17 <bos> sjanssen: i'm not using ByteString in my parser yet, just seeing if your code will compile without modification.
19:56:20 <chessguy> loop b = do
19:56:20 <chessguy>   forkIO $ runReaderT chanListener b
19:56:20 <chessguy>   runReaderT run b `catch` \_ -> return ()
19:56:48 <wolverian> chessguy, is it the lack of structure, or naming conventions, or visual typing clues?
19:57:11 <chessguy> it's the lack of a good english translation
19:57:45 <malsyned> chessguy: is part of the problem that any english description of it would take a paragraph or two?
19:58:00 <chessguy> probably
19:59:56 <chessguy> of course, i don't really have a good solution either
20:00:09 <malsyned> anybody know what I have to do under the GPL in order to lift UTF8.hs out of jhc?
20:01:01 <malsyned> chessguy: The problem seems to be that the ideas are so abstract and so compressed that there's not a succinct way of explaining them.  I imagine hardcore haskellers would respond to the critique by saying "what's the problem?  that's what we use Haskell for in the first place."
20:01:09 <sjanssen> malsyned: do not distribute your source or object code?
20:01:13 <chessguy> i suspect this is why no formal semantics have been defined, too (to my knowledge)
20:01:14 <Excedrin> just read 'T' as transformer and say "more than meets the eye" at the end
20:01:34 <sjanssen> bos: just pushed a patch to give type signatures for every function in Combinators
20:01:54 <malsyned> sjanssen: lets say I wanted eventually to distribute my code, though
20:02:09 <LoganCapaldo> malsyned, the sanest thing to do is to try and get the copyright holders to license just those bits under a different license
20:02:10 <chessguy> well, i would even settle for a more long-winded explanation, if it could be standardized
20:03:10 <sjanssen> malsyned: if you want to distribute your code under a license other than the GPL, you shouldn't use the jhc code
20:03:38 <malsyned> I'm fine with distributing under the GPL.
20:03:52 <sjanssen> then you're good
20:04:26 <sjanssen> however, IANAL, etc.
20:04:53 <chessguy> did the HWN come out yet?
20:05:00 <malsyned> sjanssen: thanks
20:05:10 <chessguy> for this week
20:05:45 <chessguy> wow, i really caught the channel at a dead time
20:05:52 <dons> chessguy: not this week
20:05:57 <bos> sjanssen: your GenParsec stuff seems to have broken regular Parsec :-(
20:06:05 <sjanssen> bos: wha?
20:06:06 <dons> i might just get it out today, depending on jet lag
20:06:13 <sjanssen> bos: in what way
20:06:21 <bos> sjanssen: /home/bos/lib64/parsec-2.0/ghc-6.6/HSparsec-2.0.o: unknown symbol `parseczm2zi0_TextziParserCombinatorsziGenParsecziError_ParseError_con_info'
20:06:27 <chessguy> dons, ah ok. that's fine, i just think i've been missing it, so i want to figure out why
20:06:39 <bos> this is in code that loads Parsec, but not GenParsec
20:06:42 <dons> missing --make ?
20:06:52 <dons> hmm
20:07:22 <sjanssen> bos: this should install over your existing parsec installation
20:07:26 <bos> is there a haskell demangler?
20:07:38 <bos> er, ghc demangler?
20:07:38 <chessguy> demangler?
20:07:44 <bos> for symbol names.
20:07:50 <dons> zi == .
20:08:27 <bos> sjanssen: whew, it was a build problem.
20:08:38 <sjanssen> good, good
20:08:42 <bos> i thought running "runghc Setup.hs build" again would build the stuff i'd pulled from you.
20:08:46 <bos> but it buggered something up.
20:09:40 <bos> sorry, i lie. it is indeed broken.
20:10:28 <hpaste>  bos pasted "aiiiieeeee" at http://hpaste.org/85
20:10:37 <chessguy> bugged something up...is that the technical diagnosis?
20:11:05 <bos> hey, i like the syntax colouring of ghci output by hpaste :-)
20:17:53 <slava> does ghc build on arm?
20:19:12 <dons> slava: check with Igloo, problem is the floating point, iirc
20:19:17 <dons> so if you can live without Double... :)
20:20:38 <sjanssen> bos: that is happening over here too.  It works when I compile with ghc instead of using runghc/ghci
20:25:13 <slava> dons: i want to run darcs
20:25:19 <slava> dons: surely there's fp emulation?
20:25:42 <bos> sjanssen: that's odd.
20:25:58 <sjanssen> bos: I found the bug, expect a patch in 90s
20:26:14 <bos> whee!
20:26:30 <bos> sjanssen: i worked around it by renaming the package to genparsec, and only building GenParsec
20:27:24 <sjanssen> bos: pull!
20:27:36 <glguy> syntaxfree: you there?
20:27:39 <sjanssen> it was just a missing exposed module
20:28:14 <dons> slava: I think there's ghc support on debian/arm, but check with Igloo
20:28:17 <dons> he's working on that port
20:28:19 <sjanssen> bos: regarding Viewable, to fundep or not to fundep?
20:28:36 <slava> dons: ok, thanks
20:28:42 <slava> i'm porting factor, to do that first i need darcs to work :)
20:28:50 <dons> :)
20:29:14 <bos> sjanssen: fundep on what?
20:29:15 <dons> you can always wget darcs repos back and forth, as a short term workaround
20:29:19 <dons> or scp
20:29:22 <slava> or nfs
20:29:26 <dons> yeah
20:29:33 <slava> i tried to install an nfs kernel on my embedded board, screwed up, now its a paperweight
20:29:38 <slava> have to send it back to the factory for reflash
20:29:40 <dons> yikes
20:29:44 <slava> so i'm trying another approach, installing debian/arm in qemu
20:30:43 <bos> sjanssen: the type signature of eof is wrong, and i think by extension several other functions
20:30:45 <hpaste>  glguy annotated "happs hello world fails!" with "why it broke" at http://hpaste.org/84#1
20:31:03 <bos> sjanssen: it's internally consistent, but not usable
20:32:14 <bos> iow i can't get this to typecheck, which it does with Parsec: parseTest eof ""
20:33:07 <bos> wow, i had no idea that TRE was so cool.
20:33:43 <sjanssen> bos: parseTest (eof :: GenParser [Char] Char () ()) "" -- does work
20:33:49 <sjanssen> I think we do need that fundep
20:35:08 <bos> what should it look like?
20:36:21 <sjanssen> bos: you can pull the change now
20:36:40 <sjanssen> the fundep now states that the "container" type determines the "contained" type
20:37:23 <glguy> ?seen dons
20:37:24 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7m 44s ago.
20:37:39 <sjanssen> which precludes parsing a ByteString as both Word8 and Char, but that's okay
20:37:54 <bos> hmm, fundeps are new to me
20:38:24 <bos> have to go off and read the haskell report and figure out what that "| c -> x" means
20:38:26 <bd_> sjanssen: Why not? One container for Data.ByteString and one for .Char8, and a set of conversion functions, possibly...
20:38:42 <glguy> fundeps are in the haskell report?
20:38:51 <bd_> bos: It's an extension :) and it means that given a particular c, there is only one x which will satisfy the typeclass.
20:38:56 <bos> well, they're somewhere, and i don't know what they are :-)
20:38:57 <sjanssen> bos: they're not in the report
20:39:22 <bos> ooh, nice.
20:39:31 <bos> the fundep makes eof happy without that huge nasty signature
20:39:39 <sjanssen> right
20:39:53 <sjanssen> fundeps help the compiler infer types
20:40:38 <sjanssen> "| x -> y" means that when you fix x to some concrete type, y is also fixed
20:41:15 <sjanssen> bd_: Data.ByteString.ByteString and Data.ByteString.Char8.ByteString are actually the same type
20:41:25 <bd_> sjanssen: ... ah
20:45:55 <bos> sjanssen: darcs pull http://darcs.serpentine.com/genparsec
20:45:57 <lambdabot> Title: Index of /genparsec
20:46:18 <dons> glguy: /
20:46:30 <bos> i have to wash some dishes. the genparsec code compiles ok - don't have time to test until dishes done :-)
20:46:38 <glguy> dons: I put your patch in, reducing the file size by 500 bytes
20:46:57 <glguy> to 5/6ths its original size :)
20:46:59 <dons> ok good
20:47:03 <dons> same rendering?
20:47:09 <glguy> Sees so
20:47:21 <dons> nice
20:47:24 <glguy> though I am quite surprised that that tool sorted the sections alphabetically
20:47:31 <dons> weird eh?
20:47:37 <glguy> part of the magic of a cascading style sheet is that it is cascading
20:47:41 <glguy> so... order counts
20:47:51 <dons> yeah, so it doesn't work on ones where ordering matters
20:47:54 <dons> (say the docs)
20:47:59 <glguy> ah
20:48:11 <dons> ?google FactorCSS
20:48:14 <lambdabot> http://zamez.org/source/factorcss/
20:48:15 <lambdabot> Title: Zamez.org CVS - directory - james: factorcss
20:48:38 <dons> ?where+ factorcss http://zamez.org/factorcss
20:48:38 <lambdabot> Done.
20:48:41 <chessguy> @type (+)
20:48:43 <lambdabot> forall a. (Num a) => a -> a -> a
20:48:51 <dons> glguy: this "The only known case where the output is not equivalent to the input is when the stylesheet depends on the order of rules"
20:49:02 <dons> is that what you mean, or is that something more subtle?
20:49:03 <chessguy> ?src (+)
20:49:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:49:13 <dons> ?src Int (+)
20:49:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:49:20 <dons> ?src Num
20:49:21 <lambdabot> class  (Eq a, Show a) => Num a  where
20:49:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:49:21 <lambdabot>     negate, abs, signum     :: a -> a
20:49:21 <lambdabot>     fromInteger             :: Integer -> a
20:50:32 <bd_> ?src Show (,)
20:50:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:51:46 <chessguy> dons, do you think it's possible to come up with a natural english translation of every haskell function/class/monad so that there would be a translation from haskell to readable english?
20:52:07 <dons> no idea
20:52:19 <dons> could greek letters and lambdas be used?
20:52:40 <chessguy> preferably not
20:52:54 <chessguy> but i'd settle for it if it was the only way to do it
20:53:07 <dons> what's the point?
20:53:41 <chessguy> dons, i think the trouble a lot of newcomers have is not having a clue how to read a given snippet of code
20:53:58 <base_16> chessguy: i have that problem a lot
20:54:08 <base_16> but i don't know if natural language would help
20:54:18 <dons> just knock up a wiki page
20:54:19 <bos> i have a fundep on dishes. there is only one state of dish dirtiness that will satisfy my wife.
20:54:28 <chessguy> like what's the natural meaning of:
20:54:28 <chessguy> loop b = do
20:54:29 <chessguy>   forkIO $ runReaderT chanListener b
20:54:29 <chessguy>   runReaderT run b `catch` \_ -> return ()
20:54:31 <dons> \x -> x == "The anonymous function from x to x"
20:55:19 <base_16> chessguy: yeah, i have no idea what's going on there
20:55:26 <sjanssen> chessguy: where is that code?
20:55:29 <chessguy> to me, that just looks like a bunch of names of different haskell things thrown together
20:55:36 <dons> fork a thread which runs a chanListener in the ReaderT monad, and also evaluate the 'run' function in an identical ReaderT, catching any errors
20:55:49 <sjanssen> const (return ()) at the end is more clear
20:55:50 <chessguy> sjanssen, random piece of code i pulled off the pastebin
20:56:01 <slava> chessguy: basically its a definition, a do block, and function calls
20:56:06 <slava> there's nothing to it, really
20:56:10 <dons> yeah
20:56:16 <chessguy> but you guys aren't newcomer
20:56:17 <chessguy> s
20:56:18 <slava> oh, and a lambda \_ -> return ()
20:56:18 <dons> then you recursively lookup what the functions are
20:56:22 <slava> chessguy: i am
20:56:26 <dons> forkIO, runReaderT, catch, return, ..
20:56:28 <monochrom> I oppose natural English.  It is a hinderance to learning formal languages such as Haskell.
20:56:33 <slava> chessguy: haskell doesn't have boilerplate. most code consists of function application
20:56:46 <slava> if you learn about various functions you'll be able to understand code that calls them
20:56:56 <dons> this is an interesting point newbies make sometimes: there's no syntactic 'boilerplate' to hang their eyes on
20:57:09 <dons> they look for ; and { } to help them draw breath
20:57:17 <dons> but instead they need to look for ( ) and newline
20:57:32 <chessguy> mmmm, i don't think it's so much that they want a boilerplate
20:57:45 <chessguy> i think it's more not knowing how to go about sorting out what the code means
20:57:59 <monochrom> Haskell is supposed to be a cultural shock.  I think it does the language a disservice to avoid the cultural shock.
20:58:05 <dons> :)
20:58:07 <slava> that code only uses a small number of syntax rules. mostly it is just function calls
20:58:20 <base_16> monochrom: yeah-- the culture shock is what attracted me to haskell, actually
20:58:22 <slava> there's very little to sort out
20:58:37 <slava> you're assuming each token is a special piece of syntax in the grammar, it isn't
20:58:44 <dons> Haskell: taking imperative programmers out of their comfort zone, and into the higher order, polymorphic frying pan since 1990
20:58:45 <chessguy> yeah, but once you get over the shock, it's still a steep learning curve
20:58:58 <monochrom> loop b = do { forkIO $ runReaderT chanListener b; runReaderT run b `catch` \_ -> return () }   is not for newbies to begin with.
20:59:15 <dons> ?undo do { forkIO $ runReaderT chanListener b; runReaderT run b `catch` \_ -> return () }
20:59:16 <lambdabot> forkIO $ runReaderT chanListener b >> runReaderT run b `catch` \ _ -> return ()
20:59:18 <mbishop> The only thing hard about haskell to me is monads (not really the idea of monads, but dealing with them, particularly with IO)
20:59:21 <base_16> does runXXXX always mean to do something in the XXXX monad?
20:59:22 <dons> ?src (>>)
20:59:23 <lambdabot> m >> k      = m >>= \_ -> k
20:59:24 <chessguy> monochrom, no, but it seemed like a pretty typical piece of code
20:59:28 <dons> ?src ($)
20:59:28 <lambdabot> f $ x = f x
20:59:30 <bos> simply the size of the quantity of library you need to know in order to read other people's code, or write your own, is large.
20:59:35 <mbishop> But I'm a super noob :P
20:59:42 <bos> and i mean you need to *know* it.
20:59:48 <dons> forkIO (runReaderT chanListener b) >>= \_ -> (runReaderT run b `catch` \ _ -> return ())
20:59:57 <dons> ?src IO (>>=)
20:59:58 <lambdabot> m >>= k     = bindIO m k
21:00:16 <dons> bindIO (forkIO (runReaderT chanListener b)) (\_ -> (runReaderT run b `catch` \ _ -> return ()))
21:00:20 <dons> ?src bindIO
21:00:21 <lambdabot> bindIO (IO m) k = IO ( \ s ->
21:00:21 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
21:00:47 <dons> well, maybe that way doesn't lie further clarity
21:00:50 <chessguy> lol
21:00:55 <monochrom> Any pretty typical piece of code from any language, even Java and C, must be hostile to newbies.
21:01:07 <monochrom> The only exception is COBOL.
21:01:14 <cge> I'd say the runReaderT is the biggest hurdle with that piece of code
21:01:30 <cge> Since one has to know about Control.Monad.Reader
21:01:30 <dons> IO (\s -> case forkIO (runReaderT chanListener b) of (s' , ()) -> unIO (\_ -> (runReaderT run b `catch` \ _ -> return ()) ()) s'
21:01:39 <base_16> ?src runReaderT
21:01:40 <lambdabot> Source not found. My mind is going. I can feel it.
21:01:47 <dons> ?src unIO
21:01:47 <lambdabot> Source not found. Take a stress pill and think things over.
21:02:00 <dons> but you're getting at the essence now:
21:02:10 <dons> case forkIO (runReaderT chanListener b) of (s' , ()) -> runReaderT run b `catch` \ _ -> return ()
21:02:11 <monochrom> Perhaps s/hostile/obscure/
21:02:17 <chessguy> dons, but you always run into that question of "oh...what do i do now"
21:02:24 <dons> then just look up runReaderT and ponder monad transformers for a week
21:02:32 <slava> chessguy: which languages don't have this problem?
21:02:51 <dons>  ReaderT { runReaderT :: r -> m a }
21:02:56 <chessguy> slava, i think other languages have a much more natural translation
21:03:15 <slava> other being intercal, ibm 360 assembly, and cobol?
21:03:18 <dons> i.e. it just wraps the functoin in RedaerT
21:03:22 <glguy> dons: that was what I meant
21:03:35 <glguy> dons: but I believe that it is quite common to depend on the order of the file
21:03:42 <chessguy> no, being c, perl, c++, java, whatever
21:03:42 <dons> maybe
21:03:44 <glguy> I'm surprised they make that transformation
21:03:55 <slava> chessguy: i don't find c, perl, c++ or java more readable than haskell. the opposite, actually
21:04:09 <dons> at least we *can* reason about haskell by inlining alone
21:04:12 <slava> if you spent many years with curly brace languages, learning anything new takes a bit of work but it doesn't mean its less readable, you're just not used to it
21:04:18 <monochrom> Look, Haskell's expressive power comes from being UNtranslatable into English.  Why does no one program in English?  Answer that first.
21:04:57 <chessguy> slava, i don't mean to say they're more readable, i mean to say it's easier to translate other code to something very readable
21:05:04 <slava> chessguy: no it isn't
21:05:13 <slava> c/c++/java code reads like a list of register transfers
21:05:20 <chessguy> slava, i guess we'll have to agree to disagree then
21:05:27 <dons> if the other code used higher order functions and monads, it would be hard too
21:05:28 <dons> :)
21:05:29 <slava> its not telling you what is being done, but how it is done by a low level machine
21:05:35 <allbery_b> because any given sentence in ENglish admits to a dozen possible interpretations, only (usually) determinable by context?
21:05:38 <dons> but if its all monomorphic, imperative stuff, that's easy in haskell too
21:05:49 <dons> do x <- getChar ; let y = toUpper x ; putChar y
21:06:00 <allbery_b> (nd sometimes by tone of voice)
21:06:07 <dons> as soon as you do anything semantically interesting, in *any* language, it'll ge thard to explain in english
21:06:15 <chessguy> dons, good point
21:06:22 <dons> just happens that semantically interesting things are common in haskell :)
21:06:47 <slava> chessguy: consider this. all the languages you listed are procedural. haskell isn't. this is why you're having problems, its a new paradigm. stick with it and you'll internalize the key abstractions over time
21:07:02 <dons> for example, your first example uses concurrency and reader monad transformers
21:07:10 <base_16> slava: i would argue that other functional languages may be easier for newbies to make it over the gap in
21:07:10 <chessguy> slava, i understand the functional paradigm, it's not that
21:07:21 <monochrom> I think chessguy has been speaking for potential newbies rather than for chessguy.
21:07:22 <base_16> i had far, far less trouble with common lisp
21:07:29 <dons> doing the same in , say, C++ would be just as complex to explain (more so, most likely, since you wouldn't be able to write it in 3 lines of C++)
21:07:29 <chessguy> monochrom, right.
21:07:55 <chessguy> dons, true
21:08:08 <slava> chessguy: so what functional languages have you used which you find easier to translate to english than haskell?
21:08:32 <dons> and things like lisp/scheme are more like the pure, listy subset of haskell, without the interesting abstractions
21:08:37 <chessguy> slava, i haven't extensively used any other functional languages
21:08:40 <base_16> dons: true
21:08:40 <dons> toss some macros in and things get sneaky too
21:08:46 <slava> chessguy: so you don't understand functional programming :)
21:08:53 <slava> dons: lisp and scheme have abstractions which haskell lacks, too
21:09:04 <dons> yeah and they're hard to explain :)
21:09:08 <base_16> dons: exactly. what i'm saying is that functional programming isn't necessarily the problem, but the other concepts that show up in haskell that are difficult to understnad
21:09:09 <cge> ML seems a bit easier to understand - but then again it doesn't have the same level of abstraction
21:09:16 <slava> dons: macros, CLOS, setf
21:09:19 <dons> yeah
21:09:21 <chessguy> slava, are you saying you can't understand FP by only studying haskell?
21:09:27 <monochrom> ML functors are hard to explain
21:09:34 <slava> chessguy: you can only understand FP by writing FP code.
21:09:36 <dons> they are. harder than type classes
21:09:44 <chessguy> i have written FP code. in haskell
21:10:01 <monochrom> OOP is hard to explain.
21:10:17 <dons> its the semantic density that matters
21:10:27 <slava> OOP is mostly just procedural with structural polymorphism
21:10:51 <dons> so, say, runReaderT represents a fair bit of code and several research papers
21:11:32 <dons> its a feature of FP, and Haskell, that you can learn it for years and still hit code that does things you couldn't imagine writing yourself
21:11:35 <dons> :)
21:11:46 <dons> the semantic ceiling is pretty high up
21:11:59 <cge> There is a lack of documentation on some things too, like the Reader monad.
21:12:00 <chessguy> several research papers just on runReaderT?
21:12:08 <dons> on monad transformers
21:12:45 <dons> instance (Monad m) => Monad (ReaderT r m) where
21:12:45 <dons>         return a = ReaderT $ \_ -> return a
21:12:45 <dons>         m >>= k  = ReaderT $ \r -> do
21:12:45 <dons>                 a <- runReaderT m r
21:12:46 <dons>                 runReaderT (k a) r
21:12:59 <dons> so to explain that, you have to understand typeclasses (several more papers)
21:13:02 <dons> and monads
21:13:04 <dons> and laziness
21:13:07 <allbery_b> the problem with documentation is that all too oftewn the documentation seems to be the research papers.  which are, er, kinda dense for dense folks like me :)
21:13:08 <dons> and higher order functions
21:13:12 <dons> and lambda abstractions
21:13:17 <chessguy> is that all? :)
21:13:20 <dons> and multiparameter type classes
21:13:22 <base_16> lambda abstractions shouldn't be a big deal
21:13:24 <base_16> or laziness
21:13:27 <dons> and hmm, unification in H-M
21:13:57 <monochrom> OOP books are a hundred times more than Haskell books.  That represents how hard it is to explain OOP in "plain English".  On the research and theory side, just look at type systems such as F_omega< and boggle --- ten times more complicated than that of GHC.
21:14:09 <dons> a working knowledge type constructors probably would help
21:14:24 <Modius> OOP is a vague term and should probably be avoided.  It's a grab bag of concepts, never heard 2 people who mean the same thing from OOP
21:15:14 <Modius> In the C/C++ high performance/game world, it was used to refer to rising out of pure functions.  Other people mean any manifestation of polymorphism.  Some mean just splitting data up, some mean inheritance.
21:15:31 <Modius> All in all, OOP has been a big fraud.
21:15:39 <monochrom> I mention OOP as just an example.  My point is: how hard and how futile it is to talk down to newbies.
21:15:59 <dons> think of a monad as a spacesuite full of nuclear waste in the ocean
21:16:10 <dons> next to a container of apples
21:16:13 <chessguy> haha
21:16:15 <dons> now, you can't put oranges in the space suite
21:16:22 <allbery_b> @quote bad-analog
21:16:22 <lambdabot> No quotes match. My mind is going. I can feel it.
21:16:26 <dons> or the nucelar waste falls in the ocean
21:16:33 <allbery_b> @quote analogies
21:16:34 <lambdabot> No quotes match. My pet ferret can type better than you!
21:16:38 <allbery_b> @quote analogy
21:16:39 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
21:16:43 <dons> *but* the apples are carried around anyway, and you just take what you need
21:16:49 <allbery_b> @quote analogy
21:16:50 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
21:17:01 <allbery_b> hm
21:17:05 <dons> now. if you try to unicycle over the space suite, that won't work see?
21:17:09 <dons> since the oranges and apples don't fit
21:17:20 <dons> and ghc will complain with:
21:17:21 <dons> ?ghc
21:17:21 <lambdabot> ghc says: Illegal binding of built-in syntax
21:17:25 <dons> for example
21:17:27 <chessguy> ?remember dons think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need.
21:17:27 <lambdabot> Done.
21:17:32 <bd_> My brain just exploded.
21:17:40 <allbery_b> the quote about monads-as-bad-analoogies got lost?
21:17:47 <chessguy> @quote monad
21:17:47 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
21:17:55 <chessguy> @quote monad
21:17:56 <lambdabot> Cale says: [more monad clarity] monads as food gathering in post-industrial America
21:17:59 <bd_> @quote monoid
21:18:00 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
21:18:04 <chessguy> @quote monad
21:18:05 <lambdabot> Cale says: I spent a whole summer being paid to write a nondeterministic search program like this, in the list monad in Haskell
21:18:15 <chessguy> @quote monad
21:18:16 <lambdabot> Philippa says: hey, if the guy wants a monadectomy that's his choice
21:18:23 <chessguy> @quote monad
21:18:24 <lambdabot> dons says: think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples.  now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
21:18:24 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
21:18:38 <chessguy> @quote monad
21:18:39 <lambdabot> monochrom says: If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
21:19:00 <moconnor> If I have some structured data, "data Foo = Foo {a::Int, b::Int, c::Int}", and I want to transform "Foo 1 2 3" into "Foo 1 5 3" is there any easy way to do that?  I have lots of functions like:  set_b :: Foo -> Int -> Foo; set_b (Foo a _ c) x = Foo a x c
21:19:15 <dons> hmm
21:19:21 <bd_> moconnor: set_b f newB = f { b = new_b }
21:19:31 <bd_> moconnor: or do it inline: someFoo { b = 5 }
21:19:34 <moconnor> jesus, you're kidding me.
21:19:36 <allbery_b> moconnor: use records and update syntax?
21:19:38 <dons> you've got the record syntax, so yeah, use it. :)
21:19:45 * moconnor slaps head
21:19:46 <moconnor> thanks
21:20:16 * allbery_b needs to look at what others are typing instead of trying to copyedit himself
21:20:28 <allbery_b> of course then my typing would be even more artocious
21:20:47 <dons> artilicious?
21:20:59 <allbery_b> *atrocious
21:21:15 <chessguy> anyway, this has been an enlightening discussion, as usual
21:21:15 <dons> artosaurus?
21:21:45 <augustss> howdy!
21:21:51 <chessguy> hi augustss
21:22:12 <monochrom> chessguy: I recommend Piaget's theory of learning on the subject you brought up.  In a nutshell, a newbie has to familiarize with basic things before moving on to advanced things.  The basic things can be taught using what the newbie already has, e.g. English, but the advanced things can't, the advanced things have to be built on the basic things.  As for typical code, well typical code = code for real jobs = advanced.
21:22:20 <robreim> super fraja callo listic expi-al artocious
21:22:54 <dons> monadocious
21:23:27 <monochrom> Note: "built on" /= defined by.  In fact, "built on" = raise the level of abstraction, there is a leap.
21:23:41 <dons> ?remember RunarJordahl Haskell has quite the following among the alpha geeks
21:23:42 <lambdabot> Done.
21:23:59 <dons> alpha geeks unite!
21:24:09 <dons> the revolution will be declared!
21:24:16 <monochrom> In fact a crucial point of Piaget's theory is there is a leap every time you move on to the next level of abstraction.
21:24:20 <bd_> I resent that expression. We are clearly lambda geeks.
21:24:20 <chessguy> what about the beta and gamma geeks
21:24:48 <dons> first against the wall will be the reactionary side effects!
21:25:01 <zarvok> Is development on Hope still active?  The website seems to be down.
21:25:24 <dons> bd_, but on the type level we are Pi alpha . alpha
21:25:36 <dons> zarvok: i think so
21:25:42 <bos> dons: i think that was nat torkington, no?
21:25:42 <dons> check with bring
21:25:44 <bd_> dons: We have kind (* -> *) ?
21:25:45 <dons> bringert.
21:25:54 <zarvok> dons: yeah, thanks, I will
21:25:59 <dons> bos, on oreilly?
21:26:03 <bos> yes
21:26:03 <bd_> Or am I parsing the precedence incorrectly?
21:26:19 <bos> he's trying to get simonpj to keynote at oscon.
21:26:26 <xpika2> > [0,0.2..1]
21:26:28 <lambdabot>  [0.0,0.2,0.4,0.6000000000000001,0.8,1.0]
21:26:34 <xpika2> can someone fix this?
21:26:39 <xpika2> plz :)
21:26:42 <dons> looks fine to me
21:26:47 <chessguy> what the...
21:26:47 <dons> got a problem with the fpu?
21:26:56 <dons> talk to lennart
21:27:06 <chessguy> oh, .6 can't be represented as accurately in binary as the others?
21:27:10 <dons> > 1.1 + 2.2
21:27:11 <lambdabot>  3.3000000000000003
21:27:13 <bos> xpika2: it's fine, you can't represent that properly
21:27:21 <monochrom> .1 is also never accurate
21:27:39 <xpika2> > .1
21:27:40 <lambdabot>  Parse error
21:27:42 <allbery_b> hard to represent non-powers-of-2 in base 2 floating point
21:27:45 <xpika2> > 0.1
21:27:47 <lambdabot>  0.1
21:27:49 <xpika2> negative
21:27:52 <chessguy> i did have an interesting community idea today. it would be cool to run interactive classes for newbies. tutorials are great, but they only go so far
21:27:56 <dons> > map (prinft "%0.2f" :: Double -> String) [0,0.2..1]
21:27:57 <lambdabot>   Not in scope: `prinft'
21:27:58 <allbery_b> if you compute it though
21:28:03 <bos> hugs uses dybvig's float rendering algorithm
21:28:05 <dons> > map (printf "%0.2f" :: Double -> String) [0,0.2..1]
21:28:06 <lambdabot>  ["0.00","0.20","0.40","0.60","0.80","1.00"]
21:28:07 <allbery_b> > 0.2 - 0.1
21:28:09 <lambdabot>  0.1
21:28:09 <dons> fixed :}
21:28:18 <bos> so it doesn't get the boogums with the continued fraction
21:28:29 <dons> Hugs.Base> 1.1 + 2.2
21:28:29 <dons> 3.3
21:28:31 <dons> swwet
21:28:36 <allbery_b> depends on what exactly you do, it may be something that gets recognzed as 0.1, it might be off just enough in low digits to mess up
21:28:39 <bos> dybvig, clever old chap.
21:28:50 <allbery_b> if you really care, use Data.Ratio :)
21:28:52 <dons> chessguy: hmm. yeah
21:28:57 <dons> lambdaweb + a tutorial
21:28:57 <monochrom> To see that 0.1 cannot be stored accurately, you have to sum up a lot of 0.1's.
21:29:12 <dons> > [ 1%10 .. 10%10 ]
21:29:14 <lambdabot>  [1%10,11%10]
21:29:18 <dons> heh
21:29:26 <robreim> There really doesn't seem to be any changes to compiler/iface/BinIface.hs since ghc 6.4.2 that seem relevant to hs-plugins :(
21:29:36 <dons> > [ 1%10, 2%10 .. 10%10 ]
21:29:38 <lambdabot>  [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
21:29:57 <chessguy> what's lambdabweb?
21:29:59 <dons> robreim: hmm
21:30:09 <dons> i was sure the module name crept into the symbols though?
21:30:19 <dons> module version, sorry
21:30:49 <allbery_b> you also need to check anything imported by BinIface.hs
21:31:07 <allbery_b> it could be using a helper function somewhere that changed
21:31:15 <robreim> There seems to already be module version information in 6.4.2. In fact it looks like it was always there given how Parser.hs is written to account fori t?
21:31:34 <dons> maybe i'm thinking of the symbols in the objects
21:31:38 <dons> they have version numbers now, perhaps?
21:31:47 <dons> so when we construct symbol names on lookup, we need to know the versio ntoo
21:31:51 <chessguy> dons, what's lambdaweb?
21:32:05 <dons> ?where lambdaweb
21:32:06 <lambdabot> http://lambdabot.codersbase.com
21:32:10 <robreim> really? Hmm... I'll look for where that's handled.
21:32:16 <dons> lambdabot running in your browser
21:32:24 <allbery_b> http://www.lambdaweb.net -- ?
21:32:27 <lambdabot> Title: www.lambdaweb.net
21:32:33 <allbery_b> hm, no
21:32:40 <allbery_b> parked domain, in French
21:32:50 <allbery_b> er
21:32:52 <allbery_b> no French
21:33:00 <allbery_b> look closer.  .no?
21:33:04 <allbery_b> norway?
21:33:16 <base_16> hmm, it gave me an error
21:33:32 <base_16> it doesn't like ":t lift"
21:33:48 <allbery_b> I think that's newer than the lambdabot on thta page
21:33:50 <allbery_b> try @type
21:34:22 <chessguy> dons, does that have all the functionality of LB?
21:34:33 <chessguy> @undo doesn't seem to work
21:34:34 <lambdabot> doesn't seem to work
21:34:47 <allbery_b> heh
21:34:47 <base_16> allbery_b: i get no response when trying @lift on anything
21:34:48 <chessguy> oops
21:35:06 <allbery_b> @help lift
21:35:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:35:08 <xpika2> hey looky
21:35:10 <xpika2> > [0,0.2..1] :: [Float]
21:35:12 <lambdabot>  [0.0,0.2,0.4,0.6,0.8,1.0]
21:35:36 <allbery_b> @lift -- not there?
21:35:37 <lambdabot> No module "-- not there?" loaded
21:35:41 <dons> it might be a bit old
21:36:19 * allbery_b wonders how that got parsed
21:36:51 <augustss> > [ 0.1, 2%10 .. 1 ]
21:36:53 <lambdabot>  [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
21:37:12 <xpika2> that works too
21:37:41 <augustss> > 3.14159256 :: Rational
21:37:43 <lambdabot>  39269907%12500000
21:38:05 <xpika2> lol, that looks computationally inexpensive
21:38:49 <augustss> > 1.4e12 :: Rational
21:38:50 <lambdabot>  1400000000000%1
21:39:28 <augustss> what looks like floating point literals is Haskell has type Rational
21:40:16 <marc_> emacs question?
21:40:27 <monochrom> vi answer!
21:40:31 <allbery_b> > 22%7
21:40:33 <lambdabot>  22%7
21:40:34 <bos> we got your parens right here.
21:40:40 <allbery_b> > fromRational 22%7
21:40:42 <lambdabot>  Add a type signature
21:40:51 <allbery_b> > fromRational 22%7 :: Double
21:40:52 <lambdabot>  Couldn't match `Double' against `Ratio a'
21:40:59 <allbery_b> > (fromRational 22%7) :: Double
21:41:00 <lambdabot>  Couldn't match `Double' against `Ratio a'
21:41:13 * allbery_b dunno
21:41:16 <marc_> tnx monochrom
21:41:17 <augustss> > fromRational (22%7) :: Double
21:41:19 <lambdabot>  3.142857142857143
21:41:26 <allbery_b> duh
21:41:30 <marc_> does haskell-indent.el work?
21:41:30 <monochrom> Haha you're welcome
21:41:37 <monochrom> Yes it does.
21:42:09 <allbery_b> >  3.141592653589 :: Rational
21:42:11 <lambdabot>  3141592653589%1000000000000
21:42:17 <allbery_b> heh
21:42:20 <augustss> marc_: for some definition of work
21:42:56 <bos> is there a "normal" way to pick a ReqArg out of a list of Flags returned by getOpt?
21:43:06 <marc_> it just does dumb indentation for me
21:43:08 <augustss> :t approxRational
21:43:11 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
21:43:20 <marc_> absolutely useless
21:44:15 <augustss> > approxRational (3.141592653589 :: Rational) (1%10)
21:44:17 <lambdabot>  16%5
21:44:48 <augustss> > approxRational (3.141592653589 :: Rational) (0.01)
21:44:50 <lambdabot>  22%7
21:44:52 <bd_> @hoogle Rational -> Float
21:44:53 <lambdabot> No matches, try a more general search
21:45:01 <bd_> @hoogle Ratio n -> Float
21:45:02 <lambdabot> No matches, try a more general search
21:45:07 <allbery_b> :t fromRational
21:45:09 <lambdabot> forall a. (Fractional a) => Rational -> a
21:45:11 <bd_> ah
21:45:51 <augustss> > approxRational (3.141592653589 :: Rational) (0.001)
21:45:53 <lambdabot>  201%64
21:50:27 <allbery_b> > approxRational (3.141592653589 :: Rational) (0.0001)
21:50:29 <lambdabot>  333%106
21:50:56 <augustss> approxRational is one of the more amazing functions in the prelude
21:51:31 <augustss> > approxRational (3.141592653589 :: Double) (0.0001)
21:51:33 <lambdabot>  333%106
21:51:49 <augustss> > approxRational (3.141592653589 :: Float) (0.0001)
21:51:51 <lambdabot>  333%106
21:52:02 <augustss> > approxRational (3.141592653589 :: Float) (0.000000001)
21:52:04 <lambdabot>  13176795%4194304
21:52:08 <glguy> anyone know the precedence of Data.Array.! ?
21:52:23 <augustss> > approxRational (3.141592653589 :: Double) (0.000000001)
21:52:25 <lambdabot>  103993%33102
21:52:34 <syntaxfree> I think it's pretty cool that the prelude has gcd and lcm.
21:52:49 <syntaxfree> > approxRational (0.333333333333 : Double)
21:52:50 <lambdabot>   Not in scope: data constructor `Double'
21:53:01 <syntaxfree> > approxRational (0.333333333333 :: Double)
21:53:02 <lambdabot>  <Double -> Ratio Integer>
21:53:11 <augustss> you need an epsilon
21:53:17 <syntaxfree> I saw :)
21:53:22 <syntaxfree> > approxRational (0.333333333333 : Double) 0.000000000001
21:53:23 <lambdabot>   Not in scope: data constructor `Double'
21:53:28 <sorear> tellfodder
21:53:32 <syntaxfree> I know what I did wrong, but I won't fix it.
21:53:35 <syntaxfree> sorear++
21:53:39 <syntaxfree> hey, you're my new idol.
21:53:57 <augustss> what has he done?
21:54:01 <syntaxfree> man, when I was 16, I was, like, trying to get XFree86 to work, and thinking I was cool.
21:54:03 * sorear freezes in self-conciousness
21:54:04 <xpika2> > map (approxRational (3.141592653589 :: Double)) (take 10 $ iterate (/10) 1)
21:54:06 <lambdabot>  [3%1,16%5,22%7,201%64,333%106,355%113,355%113,75948%24175,100798%32085,10399...
21:54:06 <bd_> ?src approxRational
21:54:07 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:54:09 <bd_> :(
21:54:20 <sorear> ?index approxRational
21:54:21 <lambdabot> Data.Ratio
21:54:41 <syntaxfree> 22/7 and 355/113 are classic approximations.
21:54:50 <syntaxfree> I wish the show method for Rational would just use "/".
21:54:52 <xpika2> and 3!
21:56:20 <bos> sjanssen: ping
21:56:22 <bos> @seen sjanssen
21:56:23 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard sjanssen speak 1h 33s ago.
21:56:27 <bos> hmm.
21:56:44 <bos> so genparsec typechecks cleanly, but it's 50% slower than vanilla parsec.
21:56:57 <bd_> bos: Is it specialised? :)
21:57:59 <sorear> is there a standard parsing benchmark?
21:58:15 <bos> there's mine :-)
21:58:20 * sorear wants to try his hand at porting ReadP to bytestrings
21:59:19 <sorear> @tell conal TV uses DOS linefeeds (bug?)
21:59:20 <lambdabot> Consider it noted.
21:59:40 <syntaxfree> what's the name of that ghci plugin that comes with some lambdabot tools?
21:59:47 <sorear> goa
21:59:47 <bos> goa
21:59:47 <syntaxfree> like hoogle and suchlike.
21:59:50 <sorear> @where goa
21:59:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
21:59:57 <syntaxfree> ok! thanks.
22:00:18 <sorear> is hacking haskell really that much cooler than hacking Xorg?
22:00:30 <sorear> s/XFree/ I feel young
22:00:36 <bos> ?
22:00:48 <xpika2> is there a library for printing Ratio's pretty
22:01:08 <sorear> define pretty
22:01:11 <xpika2> like mathematica
22:01:16 <syntaxfree> bah, Goa requires lambdabot.
22:01:27 <syntaxfree> sorear: it's certainly both more difficult and more productive.
22:01:54 <syntaxfree> hacking XFree on a Red Hat 3.0 box is a nerd feat of sorts, but it basically only makes you a nerd.
22:02:03 <syntaxfree> You're on your way to greater things, man :)
22:02:18 <augustss> yo!
22:02:21 <sorear> yo?
22:02:28 <augustss> @yow
22:02:29 <lambdabot> It don't mean a THING if you ain't got that SWING!!
22:03:12 <augustss> what more can I say?
22:05:38 <bos> i'm trying to build a package against a profiled build of genparsec, and having no success.
22:06:28 <MechaBlue> Is there a more n00bish channel to hang around in?  I'm feeling a bit overwhelmed
22:06:49 <bos> hmm, there is a call for #haskellnewbies :-)
22:06:57 <sorear> this is the n00b channel, I'm afraid
22:07:04 <augustss> MechaBlue: hey, ask away.  we don't eat n00bies
22:07:11 <sorear> we discuss esoterica when we think there are no n00bs
22:07:23 <glguy> MechaBlue: what could you hope to learn from noobs? :)
22:08:07 <MechaBlue> glguy: It's more about preserving some shreds of my ego than learning ;)
22:08:08 <syntaxfree> @quote stereo
22:08:08 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
22:08:23 <sorear> we use adaptive coding regulation ... talk denser to experters
22:08:26 <monochrom> You need to shred ego to learn Haskell.
22:08:26 <syntaxfree> MechaBlue: people are very nice here.
22:08:48 <sorear> I wish ... #haskell has been only feeding my ego.
22:09:07 <glguy> @snack
22:09:08 <lambdabot> Unknown command, try @list
22:09:08 <augustss> MechaBlue: Just start out with some nonsense statement like "I don't quite get how monads relate to the Riemann hypothesis"
22:09:09 <mbishop> @insult sorear
22:09:10 <lambdabot> Unknown command, try @list
22:09:17 <mbishop> heh, lambdabot needs an insult command :P
22:09:30 * bos just registered #haskellnewbies
22:09:31 <sorear> @src insult me
22:09:32 <lambdabot> Source not found. Where did you learn to type?
22:09:36 <glguy> augustss: that sounds like a great way for him to get his own quote command ;)
22:10:06 <sorear> @protontorpedo
22:10:06 <monochrom> @botsnack
22:10:07 <lambdabot> does haskel work one windows?
22:10:07 <lambdabot> :)
22:10:14 <syntaxfree> "Comonadic evaluation of the Lb equivalence principle yields a yonedic equivalence class of endofunctors."
22:10:22 <syntaxfree> HAH. Beat that.
22:10:27 <MechaBlue> I'm mostly looking at pushing around bytes to do network testing and need a convenient way to convert String to UTF-8 and ISO-8859-1 byteStrings
22:10:28 <monochrom> Is that a sigfpe title?
22:10:37 <sorear> AHHH!
22:10:41 <bos> MechaBlue: you're slightly out of luck
22:10:42 <sorear> Not ANOTHER one!
22:11:10 <sorear> we have more wanters of that than lines that would need to be added to implement it in base!
22:11:13 <MechaBlue> And it needs to be platform independent.  Well, Mac and Windows compatible.
22:11:24 <bos> and a pony.
22:11:41 <MechaBlue> I can crank out an ugly inefficient way of doing it but I figured I should ask first
22:11:45 <merus> bos++
22:12:21 <syntaxfree> monochrom: no, that'snonsense.
22:12:23 <MechaBlue> Are there any efforts to do so right now?  Or should I just go nuts?
22:12:24 <sorear> MechaBlue: get a copy of darcs, copy the file 'UTF8.lhs', moan, whine on the mailing list, if geographically convenient taunt the $BASELIB_MAINTAINER
22:12:34 <sorear> (smarlow?)
22:12:34 <augustss> syntaxfree: I like the sigfpe pseudo-quote :)
22:12:36 <syntaxfree> I'd like to write a @mathematical-nonsense plugin.
22:12:41 <dons> MechaBlue: the 'binary' lib serialisers data structures to lazy bytestrings
22:12:44 <syntaxfree> @pseudosigfpe
22:12:44 <dons> which then go to the network
22:12:44 <lambdabot> Unknown command, try @list
22:12:51 <dons> String is serialised as UTF-8
22:12:52 <syntaxfree> If I could ony get lambdabot to compile.
22:12:53 <dons> ?where binary
22:12:53 <lambdabot> http://darcs.haskell.org/binary
22:13:01 * merus <3 sigfpe
22:13:02 <dons> i'm about to release it today, in fact
22:13:11 <sorear> syntaxfree: just deps, or does LB itself fail compilations?
22:13:14 <augustss> I remember the good old day when I could understand the sigfpe blog posts
22:13:17 <dons> MechaBlue: so grab binary, and serialise your data!
22:13:20 <syntaxfree> LB itself fails compilation.
22:13:27 <syntaxfree> I finally chased all dependencies.
22:13:41 <dons> MechaBlue: also, it writes stuff out in network order, in a hugs/ghc portable manner
22:13:44 <sorear> ... in Vixen?
22:13:54 <MechaBlue> Thanks; I'll have a look
22:13:54 <sorear> ambiguous tyvar foo?
22:13:55 <dons> so you should even be able to send data from ghc on x86, and read it back in hugs on sparc
22:14:00 <syntaxfree> yes, in Vixen. How did you know?
22:14:19 <dons> MechaBlue: its only a couple of weeks old, but has had a lot of work. i'd be interested to see how you used it
22:14:20 <sorear> syntaxfree: that's where binary/lambdabot broke compat recently
22:14:30 <augustss> @vixen
22:14:31 <lambdabot> <undefined>
22:14:34 <syntaxfree> I don't remember the specific error.
22:14:37 <syntaxfree> Hmm.
22:14:37 <sorear> syntaxfree: I *think* it's just been fixed ... can you darcs pull and try again?
22:14:43 <syntaxfree> sure!
22:14:55 <sorear> couple of UNDO: patches
22:15:13 <syntaxfree> I don't know how to do that in darcs yet.
22:15:29 * syntaxfree goes read tutorials again.
22:15:52 <sorear> just pull - the patches are on the server
22:16:03 <syntaxfree> hmm. lambdabotr or binary?
22:16:04 <allbery_b> I think that means the patches are titled UNDO: ..., not that you need to undo (that's unpull? I think(
22:16:19 <syntaxfree> @where lambdabot
22:16:20 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:16:25 <allbery_b> pull will ask you about each patch, I just tell it to pull all of them
22:17:17 <sorear> allbery_b: that's what I meant
22:17:19 <sorear> syntaxfree: lambdabot
22:17:41 <augustss> syntaxfree: are we going to have any more blog installments on Haskell and fun sex?
22:17:41 <syntaxfree> will try. thanks.
22:18:03 <syntaxfree> I'm thinking of focusing on the sex from now on.
22:18:32 <augustss> syntaxfree: not a bad choice ;)
22:18:32 <syntaxfree> I intended the blog as a journal of  my Haskell hacking. I don't know how it turned into a Cringely-ish pulpit.
22:18:40 <syntaxfree> Blame it on my ex.
22:18:58 <augustss> syntaxfree: I liked it.
22:19:28 <syntaxfree> It's not properly researched. But if I don't publish something right away, I know I'll never get back to work in it.
22:20:31 <syntaxfree> I've actually done a lot more image manipulation in Pancito.
22:20:46 <syntaxfree> hue region-based enhancement filters.
22:21:12 <augustss> syntaxfree: so you have a working Pancito repo?
22:21:30 <syntaxfree> nah, I'm just exploiting it to write some filters.
22:21:39 <syntaxfree> I once did about 15% of Pancito independently.
22:21:44 <syntaxfree> I'd been pining for that forever.
22:21:54 <syntaxfree> but I never get anything done.
22:23:13 <MechaBlue> Are GHC compiled programs limitted to light-weight threads?
22:23:25 <allbery_b> ghc6.6 can use OS threads
22:23:34 <allbery_b> ghc +RTS --help
22:23:52 <MechaBlue> Thank you muchly
22:24:19 <sorear> of course GHC programs are limited to light weight threads.
22:24:35 <sorear> why use heavy weight threads when the light weight ones are just as good?
22:24:46 <hpaste>  syntaxfree pasted "darcs is mocking me" at http://hpaste.org/86
22:24:47 <MechaBlue> Multi-core?
22:24:51 <dons> yeah
22:24:54 <sorear> in GHC the light weight threads can even use SMP
22:25:01 <dons> smp multicore with +RTS -N4
22:25:02 <dons> for example
22:25:05 <sorear> but they're still light weigh
22:25:14 <MechaBlue> Are those light-weight?
22:25:20 <bos> it's 2-level threading.
22:25:31 <dons> you map N haskell light threads onto M OS threads runing across multiple cpus
22:25:39 <bos> similar to the way some OSes implemented threads for a long time.
22:25:39 <sorear> heavy weight threads are ones that are so inefficient you have to pay attn to the irrelevant
22:25:42 <MechaBlue> Ah, okay.
22:25:53 <allbery_b> syntaxfree:  it's elling you your repo is --partial so pulling doesn;t work
22:26:07 <syntaxfree> oh.
22:26:07 <allbery_b> you may need to start over with darcs get --complete
22:26:14 <syntaxfree> because i did darcs get --partiasl to begin with.
22:26:16 <syntaxfree> sure, sure.
22:26:19 <sorear> --complete is the default btw
22:26:22 <dons> MechaBlue: what kind of app are you writing?
22:26:23 <bos> my profiling output isn't giving me much info.
22:26:29 <dons> sounds interesting? network/ serialisation/threads?
22:26:34 <allbery_b> maybe soemne else here has real darcs-fu and knows how to turn a --partial repo to a --complete
22:26:43 <dons> bos, you might need to put SCC pragmas on key functions
22:26:47 <dons> to get their measurements
22:26:48 <bos> it's not accounting any costs to some modules that i know are being used.
22:26:58 <bos> dons: but on my laptop, i got sane numbers.
22:27:12 <bos> maybe it's an x86_64 platform bug.
22:27:31 <MechaBlue> dons: I'm working on 2 projects.  One is a tester for RTSP and RTSP with HTTP tunnelling.  The other is a FPS using the Sauerbraten engine.
22:27:48 <dons> both in haskell?
22:28:22 * bos fires up the laptop
22:28:45 <MechaBlue> dons: The Sauerbraten engine will be linked in with FFI.
22:28:50 <dons> yep
22:28:54 <MechaBlue> dons: Other than that, yeah.
22:28:58 <sorear> what is the Sauerbraten engine?
22:29:02 <dons> sounds very interesting. do keep us up to date on how you go
22:29:07 <syntaxfree> it's a gaming engine, it seems.
22:29:08 <sorear> and what does it have to do with fast packed strings?
22:29:17 <sorear> oh ...
22:29:19 <dons> you might even get some help if you mention details here, or on the mailing list (haskell-cafe@haskell.org)
22:29:22 <MechaBlue> http://sauerbraten.org/
22:29:24 <lambdabot> Title: Sauerbraten / Cube 2
22:29:26 <bos> dons: does Setup.hs configure --enable-library-profiling imply -auto-all?
22:29:36 <syntaxfree> first person shooter.
22:29:47 <dons> bos, hmm!
22:29:52 <dons> i hope so, check with -v
22:29:55 <syntaxfree> ghc --make --fextra-blood
22:29:56 <bos> i think that's what's happening.
22:30:05 <dons> could be. if so: darcs bug
22:30:06 <sjanssen> bos: pong
22:30:22 <dons> and would very well explain why my hpaste profiling didn't say much...
22:30:24 * dons checks
22:30:33 <bos> dons: it does not
22:30:39 <bos> -prof yes, -auto-all no
22:30:43 <sorear> bos: what are you trying to parse?  (for ByteString ReadP testing)
22:30:45 <dons> ah!
22:30:47 <dons> bos++
22:30:48 <bos> sjanssen: genparsec is slow :-)
22:31:07 <bos> sorear: files output by gcc -fdump-translation-unit
22:31:10 <sjanssen> bos: regarding slowness, I'd say there isn't enough specialization going on
22:31:22 <bos> sjanssen: probably not.
22:31:41 <dons> check the core output
22:31:55 <dons> and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing
22:32:02 <bos> um, is that next to the dilithium crystals?
22:32:06 * dons bytestring tip of the day
22:32:33 <dons> yeah, up and to the left.
22:32:52 <dons> dont bump the crystals though, or we'l be drifting without power
22:32:56 <bos> dons: shall i file a bug against cabal for -prof?
22:33:02 <dons> yeah i reckon
22:33:04 <dons> and bug dcoutts
22:33:29 <dons> yeah, no -auto-all. hmm
22:33:44 <sorear> * User halt in 1 minute (sleep)
22:33:51 <allbery_b> @remember bos [dons] and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing [bos] um, is that next to the dilithium crystals?
22:33:52 <lambdabot> Done.
22:34:51 <bos> dons: are the trac instances on haskell.org related? do they share user info?
22:35:02 <dons> yeah
22:35:05 <dons> (i think..)
22:35:44 <sorear> why are so many quotes lost?
22:35:52 <sorear> @flush
22:35:58 <dons> ah great.
22:36:05 <dons> finally i get some profiling info from hpaste
22:36:12 <bos> sod. i can't log into the hackage trac.
22:36:18 <allbery_b> @quote LAMBDAZ
22:36:19 <lambdabot> No quotes match. The more you drive -- the dumber you get.
22:36:22 <dons> sorear: hmm, maybe things aren't flushing on sigterm anymore?
22:36:24 <bos> it says it wants guest/haskell, and it won't let me in.
22:36:28 <allbery_b> yeh, it's gone :/
22:36:37 <bos> dons: is there a cabal workaround to add -auto-all?
22:36:41 <sjanssen> bos: can I get a copy of the parser/data that you're using to test genparsec?
22:36:51 <dons> yeah, add -auto-all to the ghc-options: field in the .cabal file
22:36:53 <dons> next to -O
22:36:55 <sjanssen> bos: add it to the ghc-options field
22:37:07 <bos> sjanssen: yeah, give me a few minutes
22:37:20 <bos> i have to edit the .cabal file? eughewbleurgh.
22:37:44 <dons> yeah, clearly a bug
22:38:00 <sjanssen> I think the no -auto-all is intentional
22:38:30 <sjanssen> I think it's more information than you typically want unless you're trying to fix the library itself
22:38:42 * rahikkala looks at Java homework and sighs
22:39:46 <sjanssen> it would clutter up the profiling results for clients of the library
22:40:30 <allbery_b> rahikkala: write it in haskell and then translate it :)
22:40:57 <bos> dons: i pinged cabal-devel
22:41:20 <dons> sjanssen: but for --enable-executable-profiling ?
22:42:16 <sjanssen> -auto-all is probably nice then :)
22:43:34 <bos> i spend a lot of time reading strace output when i'm trying to figure out new compiler tools.
22:45:06 <bos> augh! still no cost centres outside my executable!
22:46:35 <rahikkala> allbery_b: Blowing up code automatically with @pl is amusing... blowing it up manually by writing it in Java isn't :(
22:46:49 <allbery_b> there is that
22:47:25 <allbery_b> I wonder if 	(a) yhc has a java backend (b) the graders would accept its output
22:47:26 <MechaBlue> rahikkala: Writing anything fun?
22:47:32 <bos> i'm at a loss now.
22:49:41 <rahikkala> MechaBlue: Well... kinda :)
22:50:37 <bos> sjanssen: darcs get http://darcs.serpentine.com/gcchs
22:50:38 <lambdabot> Title: Index of /gcchs
22:50:54 <bos> sjanssen: then ghc -O --make -prof -auto-all DumpReader
22:51:11 <bos> you'll need to darcs get http://darcs.serpentine.com/bytestringparser too
22:51:13 <lambdabot> Title: Index of /bytestringparser
22:51:14 <dons> bos, you'll need to compile all the lib deps with -auto-all too
22:51:15 <bos> and build
22:51:22 <bos> dons: i did.
22:53:09 <bos> i see cost centres for them in the output, but they're all zero.
22:53:38 <bos> and the entries seem to be for modules, not functions inside them.
22:53:46 <bos> oh, this sounds familiar.
22:55:39 <sjanssen> bos: what should I use as input?
22:56:20 <bos> http://darcs.serpentine.com/huge.tu.bz2
22:56:46 <bos> it's 104,000 lines long.
22:57:00 <bos> i'd suggest making shorter copies :-)
22:57:13 <glguy> dons: I think that the new CSS changed the color of the buttons
22:57:18 <glguy> the blank ones with white text :)
22:57:23 <glguy> which is now black
22:57:34 <bos> the current reader doesn't try to reconstruct the parse tree, it just hands back a list. so reading a truncated file is fine.
22:59:23 <glguy> ?tell dons that CSS refactor program doesn't do selectors like :hover and :first-letter correctly
22:59:23 <lambdabot> Consider it noted.
23:02:27 <dons> hey
23:02:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
23:02:38 <bos> sjanssen: don't forget to pull my genparsec change
23:03:28 <bos> profiling and optimising haskell code is just as much of a black art as it was 12 years ago...
23:04:40 <dons> oh, its not too bad:) use fast libraries and ask on irc :)
23:04:57 <bos> dons: looks like an x86_64 profiling bug, all right.
23:05:08 <bos> as in, i get filled in cost centres on i386, but not x86)64.
23:05:11 <sjanssen> bos: got it.  now I'm pouring over oodles of profiling data
23:05:54 <sjanssen> bos: did you runghc Setup.hs clean after you added -auto-all?
23:06:12 <bos> sjanssen: i run 'find . -name "*.hi" | xargs rm' :-)
23:06:30 <sjanssen> with great justice
23:06:43 <glguy> move all zig?!
23:07:36 <bos> huh, genparsec spends most of its time in tokenPrimEx, which is HUGE.
23:08:41 <sjanssen> normal parsec spends plenty of time in that tokenPrimEx too
23:08:46 <bos> well, i must say, having gone from not being able to write "hello world" two weeks ago to fiddling with monadic parser libraries is the fun.
23:08:49 <bos> sjanssen: oh, sure.
23:10:24 <glguy> can anyone thing of a more clear why to name these variables?
23:10:25 <glguy> isTangent v (ti_1 : ti : ti1 : _)
23:10:41 <glguy> from (previous : current : next : _)?
23:11:00 <bos> glguy: more computational geometry?
23:11:04 <glguy> yeah
23:11:13 <glguy> I want my haskell code to be readable by non Haskell programmers
23:11:18 <bos> determining which direction an elbow is going in?
23:11:33 <glguy> >     isTangent v (ti_1 : ti : ti1 : _)
23:11:33 <glguy> >       = orient v ti ti_1 == GT && orient v ti ti1 == GT
23:11:34 <lambdabot>   Pattern syntax in expression context: _
23:11:34 <lambdabot>  Parse error
23:12:15 <bos> prev:curr:next -> much clearer.
23:14:01 <glguy> I'm trying to think of a better way than: p' = p ++ take 2 p
23:14:19 <glguy> to allow my list traversal to try all points
23:14:54 <glguy> I could just have my isTangent function support [prev,curr] (and use the first point)
23:15:00 <glguy> [curr] and use the next two
23:15:07 <glguy> and [] return false...
23:15:35 <glguy> but that kind of blurs the division of responsibility
23:23:29 <dancor> so there are no classes right
23:23:49 <dancor> you just define types which are like interfaces and then write functions on those types
23:23:56 <dancor> which can be namespaced with modules
23:24:46 <monochrom> There is typeclass.  It is like interface.
23:24:51 <glguy> You are correct about namespacing with modules at least
23:25:14 <allbery_b> liftM3 (isTangent v) id tail (tail.tail)
23:25:14 <dancor> so do you normally do one namespace per "class"
23:25:23 <dancor> s/namespace/module
23:25:30 <glguy> thanks allbery_b :)
23:25:39 <allbery_b> isTangent takes v prev curr next
23:25:56 <glguy> I'm aware :-p
23:26:10 <glguy> that makes the code *so much* easier to read for non Haskell programmer ;)
23:26:16 * allbery_b is a little surprised he pulled that one 
23:26:18 <allbery_b> eh
23:26:57 <allbery_b> if you want readable, you're not going to come up with too much that's "nice" for traversing the list
23:27:03 <notsmack> glguy: just put a comment with the url of YAHT above it
23:27:11 <monochrom> What is "readable"?
23:27:29 <allbery_b> he wants code that won't make non-haskellers faint
23:27:47 <dancor> how would you do in haskell something where you have a class with a bunch of methods and an instantiation of that class gets passed to a function that calls a bunch of the methods
23:27:52 <glguy> if I can keep it reasonable, I won't have to write "pseudo code"
23:28:35 <monochrom> Some people says, readable means every instruction does one little thing so that each instruction is easy to follow.  Well by that logic, RISC machine code is readable, which is absurd.
23:28:55 <glguy> well, I'm not using an extreme definition
23:28:56 <glguy> so...
23:29:08 <glguy> ?quote readable
23:29:08 <lambdabot> kyevan says: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.  (I'm not refering to my sexuality, either)
23:29:19 <MechaBlue> I'm guessing something that keeps non-Haskellers from voiding their bowels at the sight of the source would be good.
23:30:13 <allbery_b> dancor: I don't understand the question.
23:30:41 <allbery_b> the only thing tricky is the type signature:  foo :: Class a => a -> YourResultType
23:31:11 <glguy> > contains :: (Ord a, Num a)           -- forall numeric, ordered types
23:31:11 <glguy> >          => [Point a]                -- take the points in Q
23:31:11 <glguy> >          -> [Point a]                -- take the points in P
23:31:12 <glguy> >          -> Bool                     -- check Q contains P
23:31:12 <lambdabot>   Not in scope: `contains'
23:31:12 <lambdabot>  Parse error
23:31:12 <lambdabot>  Parse error
23:31:13 <lambdabot>  Parse error
23:31:17 <glguy> I try to write those out somewhat
23:32:41 <pstickne> there is a haskell-obsessed person in my discrete math class. not that haskell isn't something to be excited about but he's as big a zealot as you can get. are there any good books in-print to learn haskell? I've tried YAHT several times but always get killed at chapter 6.
23:33:17 <MechaBlue> I found Haskell: The Craft of Functional Programming to be pretty good
23:33:20 <dons> glguy: do we need a darcs version of xhtml?
23:33:22 <monochrom> Why should "readable" for Haskell mean friendly to non-Haskellers?  I have not heard of a similar criterion for other languages.  For example, no one worries about non-Perlers getting lost in a Perl script written by a guru.
23:33:33 <glguy> dons: atm, for the "thefor"
23:33:43 <glguy> dons: but we could write a local version of that
23:33:51 <allbery_b> monochrom: that's because non-perlers are gong to get lost anyway :)
23:34:11 <MechaBlue> monochrom: Are you arguing against maintainable code?
23:34:30 <allbery_b> (and actually, that's not really true:  _Perl Best Practices_)
23:34:32 <monochrom> For all other languages, I have only heard of: "readable for L" = "comprehensible by those well-versed in L"
23:34:45 <glguy> monochrom: say you are writing code and you expect to be able to explain it easily to someone what doesn't know Haskell, because you want to write it in Haskell and not something else
23:34:47 <glguy> then
23:34:53 <glguy> you need to make sure it will be explainable
23:34:56 <allbery_b> and you don't hear about it for Python because Python is, in general, pretty readable
23:35:15 <monochrom> So, by the same logic, I take "readable Haskell" to mean "comprehensible by those well-versed in Haskell".  Where do newbies and non-Haskellers come into the picture?
23:35:22 <MechaBlue> monochrom: "well-versed" is a rarity, even among those with several years of experience
23:35:45 <pstickne> the language and readability of code are only partly related...
23:35:50 <Korollary> pstickne: This is online, but it's surprisingly good: http://en.wikibooks.org/wiki/Programming:Haskell
23:35:50 <allbery_b> how many of us are Olegs?  raise your hands ... that's what I thought :)
23:35:54 <glguy> excepting that I expect people to be argumentative for its own sake here :) I don't see why we are even having this discussion :-p
23:36:00 <monochrom> OK, change that to, "comprehensible by those with 3 years of Haskell experience".  Does that sound fair enough now?
23:36:10 <pstickne> Korollary, thanks, I may have to abuse my school printers ;)
23:37:09 <MechaBlue> monochrom: Not really.  Experience influences, but does not determine, ability.
23:37:27 <pstickne> MechaBlue, what if it's mind-killing experience? O.o
23:37:37 <pstickne> ohh, nvm
23:38:11 <monochrom> I am not talking about ability.
23:38:21 <MechaBlue> monochrom: If code is more readable, the less skilled are more likely to understand it and the more skilled will take less time to understand it.
23:38:53 <monochrom> That is not even true for English.
23:39:09 <MechaBlue> monochrom: Actually, it is...
23:39:29 <dons> hmm. we need a hackage plugin
23:39:41 <dons> there's enough stuff up there now that @where should return hackage pges
23:40:28 <allbery_b> Should I use loqiacity and antiquated constructions, is your appreciation of my persiflage increased or diminished?
23:41:10 <dons> glguy: can we tag the current hpaste?
23:41:11 <glguy> yes
23:41:15 <glguy> dons: yes
23:41:19 <dons> i'd like to upload the tarball to hackage
23:41:20 * allbery_b could pull out a thesaurus and make it even more impenetrable, if that isn;t enogh to make the point
23:41:31 <dons> all the non-darcs deps are on hackage too now
23:41:36 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/recent.cgi
23:41:38 <lambdabot> Title: Hackage: recent additions
23:41:46 <dons> so all the deps can be gathered fairly easily
23:41:47 <glguy> allbery_b: yes, my appreciation is increased or diminished
23:41:51 <dons> and cabal-get might just about do the job
23:42:26 <glguy> dons: what should I tag it as?
23:43:11 <dons> darcs tag 0.3
23:43:13 <dons> :)
23:43:20 <dons> bump the .cabal file first
23:43:24 <dons> and apply the patch i just sent
23:43:25 <glguy> too late
23:43:34 <glguy> looks like 0.4 is in the works
23:43:41 <dons> well, better apply my patch anyway
23:44:04 <glguy> dons: HAppS > 0.8.4
23:44:11 <glguy> you need the new API
23:44:11 <dons> ah yes
23:44:20 <glguy> yeah, I checked your patch this time ;)
23:45:57 <dons> let me know when you've done tagging and so on
23:45:59 <glguy> wow... does each patch really need to include the names of *all the previous patches*?
23:46:01 <dons> and i'll upload the dist
23:46:36 <glguy> so, what should I change the happs dependency to?
23:46:43 <glguy> > 0.8.4?
23:46:44 <lambdabot>  Parse error
23:46:44 <dons> well, 'darcs version' i guess
23:46:47 <dons> yeah
23:47:10 <dons> I think this hackage will really help encourage people back to depending only on stable versions of things
23:47:14 <dons> i.e. stuffs that are on hackage
23:47:26 <dons> ?where hackage
23:47:27 <lambdabot> http://hackage.haskell.org/trac/hackage
23:47:30 <dons> ?where+ hackage http://hackage.haskell.org/packages/archive/pkg-list.html
23:47:30 <lambdabot> Done.
23:47:43 <monochrom> The less skilled should get themselves some education before they attempt the code of the more skilled.  Clearly.
23:48:04 <glguy> dons: should I tag 0.3 again?
23:48:10 <glguy> or do I need to pick a new tag
23:48:11 <dons> if you like
23:48:17 <dons> 0.3.0
23:48:17 <dons> ?
23:48:30 <glguy> tagged
23:48:33 <glguy> 0.3.0
23:51:18 <dons> ok. i'll upload that version to hackage
23:51:29 <glguy> nifty :)
23:51:32 <MechaBlue> Is there a standard GUI library for Haskell?
23:51:59 <Cale> No, but there are a couple good ones.
23:52:14 <Cale> Gtk2Hs is decent.
23:52:33 <dons> gtk2hs and wxHaskell
23:52:40 <dons> gttk2hs is verging on standard
23:52:42 <dons> ?where gtk2hs
23:52:43 <lambdabot> http://haskell.org/gtk2hs/
23:53:05 <dons> hackage is really ready to go!
23:53:07 <dons> yay!
23:53:23 <dons> musasabi: we need a happs version to stick up there
23:53:29 <dons> bringert: and xhtml too!
23:53:32 <earthy> oeh, that'd be great
23:53:33 * glguy wonders if anyone who doesn't already have a copy of the source tree will install hpaste
23:53:42 <earthy> doaitse has been bitching and moaning
23:53:43 <dons> glguy: maybe not
23:53:46 <dons> but at least they can find the src
23:53:59 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html
23:54:04 <MechaBlue> Thanks :)
23:54:12 <dons> almsot all the 10 or so deps needed by hpaste are on hackage now
23:54:16 <dons> yay for centralised libs
23:54:28 <earthy> 'why don't I have arrows' 'what GHC o you have?' '6.6' 'you need the extralibs package' 'why is that so hard?!'
23:54:51 <earthy> 'no normal and sane person can figure this out! this is undiscoverable!'
23:54:57 <dons> yeah
23:55:09 <earthy> @hackage++
23:55:09 <lambdabot> Unknown command, try @list
23:55:12 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package.cgi?name=arrows&version=0.2
23:55:15 <lambdabot> http://tinyurl.com/2c8pv2
23:55:17 <earthy> @karma+ hackage
23:55:18 <lambdabot> hackage's karma raised to 1.
23:55:22 <dons> though i've asked ross for shorter hackage urls
23:55:28 <glguy> they need to complain to their distro's software packaging maintainer
23:55:38 <dons> i'd like http://hackage.haskell.org/package/arrow
23:56:05 <earthy> that bit cgi-bin/hackage-scripts/package.cgi? is quite superfluous, yes
23:56:08 <dons> earthy: did you explain the problem is that there are too many haskell libraries now? :)
23:56:28 <dancor> so basically typeclass = interface
23:56:52 <sjanssen> dancor: there are some similarities
23:57:00 <earthy> dons: I did. that wasn't the problem he was bitching and moaning about.. :)
23:57:14 <dancor> sjanssen: what are important differences
23:57:18 <earthy> (he 'just' wanted to run the tangible values demo programs :))
23:57:23 <glguy> dancor: you are really interested in pinning haskell down in terms of your oo terminology, eh? :)
23:57:30 <dancor> glguy: no
23:57:43 <dancor> i need a gateway to understanding
23:58:01 <dancor> i'm not trying to [haskell] you
23:58:10 <sjanssen> dancor: Haskell class methods can have default implementations, interfaces usually can't
23:58:14 <merus> It's like pouring tea into an already full teacup.
23:58:21 <MechaBlue> dancor: I think that the functions in the typeclass are also virtual
23:58:22 <amiddelk> earthy: that's the problem with OSX people. They expect everything to work out-of-the-box :)
23:58:39 <MechaBlue> amiddelk: That's why we bought OSX :P
23:58:40 * glguy is an os x people
23:58:55 <sieni> a whole people?
23:59:02 <dancor> he's that into it
23:59:04 <glguy> you know it!
23:59:04 <dancor> , people
23:59:24 <earthy> amiddelk: not necessarily
23:59:36 <earthy> amiddelk: but we *do* expect discoverability
